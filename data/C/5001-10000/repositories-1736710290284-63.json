{
  "metadata": {
    "timestamp": 1736710290284,
    "page": 63,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "wireshark/wireshark",
      "stars": 7483,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 0.3447265625,
          "content": "task:\n  timeout_in: 120m\n  freebsd_instance:\n    matrix:\n      - image_family: freebsd-13-0-snap\n      - image_family: freebsd-12-1\n  env:\n    ASSUME_ALWAYS_YES: YES\n  setup_script:\n    - pkg update -f\n    - pkg install bash\n    - tools/bsd-setup.sh --install-optional\n  build_script:\n    - mkdir build\n    - cd build\n    - cmake -GNinja ..\n    - ninja\n"
        },
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 0.7392578125,
          "content": "# You can use clang-tidy with CMake by:\n#\n# Checking files individually by passing `-DCMAKE_EXPORT_COMPILE_COMMANDS=ON`\n# to CMake, then running `clang-tidy <file>`\n#\n# Checking the entire build by passing `-DCMAKE_C_CLANG_TIDY=clang-tidy`\n# and `-DCMAKE_CXX_CLANG_TIDY=clang-tidy` to CMake\n\n# A full list of Clang-tidy checks can be found at\n# https://clang.llvm.org/extra/clang-tidy/checks/list.html\nExtraArgs:\n  - '-Wno-unknown-warning-option'\n\n# Checks to run. A complete list of checks can be found at\n# https://clang.llvm.org/extra/clang-tidy/checks/list.html\nChecks:\n  - '-*'\n  - 'misc-no-recursion'\n\n# We can remove the configs under epan and plugins, and wiretap if we\n# ever uncomment this.\n\n#WarningsAsErrors: 'misc-no-recursion'\n\nUseColor: true\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 1.2705078125,
          "content": "#\n# Editor configuration\n#\n# https://editorconfig.org\n#\n\n# Global settings\n\n# We're the top. We're the Coliseum.\nroot = true\n\n[*]\ntab_width = 8\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n# CMake\n# The CMake project itself uses two spaces:\n# https://gitlab.kitware.com/cmake/cmake/-/blob/master/.editorconfig\n[{CMake*,*.cmake,*.cmake.in}]\nindent_style = tab\n[CMake*.json]\nindent_style = space\nindent_size = 2\n\n# Makefiles. Although we dropped Autotools we still have a few lying around.\n[Makefile*]\nindent_style = tab\nindent_size = 8\n\n# Python\n[*.{py,py.in}]\nindent_style = space\nindent_size = 4\n\n# Lemon\n[*.lemon]\nindent_style = space\nindent_size = 4\n\n# WiX. The `xmllint --format` default is two spaces.\n[*.wx?]\nindent_style = space\nindent_size = 2\n\n# NSIS\n[*.ns[ih]]\nindent_style = space\nindent_size = 2\n\n# YAML\n[*.yml]\nindent_style = space\nindent_size = 2\n\n# Asciidoc\n[*.adoc]\nindent_style = space\nindent_size = 4\n\n# GraphViz. The examples at https://gitlab.com/graphviz/graphviz/-/blob/master/graphs\n# seem to be all over the place, so just go with 4 spaces for now.\n[*.gv]\nindent_style = space\nindent_size = 4\n\n# C/C++/Objective C\n[*.{c,cpp,h,m}]\nindent_style = space\nindent_size = 4\n\n# Flex (lexical analyzer generator)\n[*.l]\nindent_style = tab\nindent_size = 8\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.36328125,
          "content": "*                           text=auto\n*.sh                        eol=lf\n/test/run_and_catch_crashes eol=lf\n.bzrignore                  export-ignore\n.gitattributes              export-ignore\n.gitignore                  export-ignore\n.gitreview                  export-ignore\ntools/make-version.py       export-subst\npackaging/source/git-export-release.sh.in export-subst\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.986328125,
          "content": "#\n# This file is tracked by git for the wireshark repository, and thus\n# should only contain ignore entries common to all wireshark developers.\n# To ignore files specific to your local repository, for example files\n# generated by your editor, add them to your repository exclude file\n# (.git/info/exclude) or your global ~/.gitignore_global. For details\n# see:\n#   https://help.github.com/articles/ignoring-files\n#\n\n# Note that this affects tools other than git. For example, ripgrep (rg)\n# and The Silver Searcher (ag) will obey this file by default.\n\n# Compiled or generated source #\n################################\n*.dll\n*.exe\n*.la\n*.lai\n*.lo\n*.obj\n*.pyc\n*.so\n*.so.*\n*.[oa]\n*.dylib\n*grammar.out\n*grammar.[ch]\n*scanner.c\n*_dict.c\n*_lex.h\nepan/dissectors/dcerpc/idl2wrs\nepan/dissectors/dcerpc/*/packet-dcerpc-*.[hc]\nepan/dissectors/mesa\nepan/dissectors/xcbproto\nepan/dissectors/packet-ncp2222.c\nepan/dissectors/dissectors.c\nepan/dissectors/dissectors.in.txt\nepan/dtd_parse.c\nepan/dtd_preparse.c\nepan/uat_load.c\nepan/wslua/declare_wslua.h\nepan/wslua/register_wslua.c\nepan/wslua/taps.txt\nepan/wslua/taps_wslua.c\nepan/ps.c\nplugins/epan/*/plugin.c\nplugins/wiretap/*/plugin.c\nplugins/codecs/*/plugin.c\nplugins/epan/mate/mate_parser.c\ntools/lemon/lemon\ntshark-tap-register.c\nwiretap/ascend.c\nwiretap/ascend.h\nwiretap/k12text.c\nwireshark-tap-register.c\n\n# CMake #\n##################\n/*build*/\nCMakeCache.txt\nCMakeFiles\nCMakeUserPresets.json\ncmake_install.cmake\nCPackConfig.cmake\nCPackSourceConfig.cmake\nlib/\nWiresharkConfig.cmake\nWiresharkConfigVersion.cmake\nwireshark.pc\nrun/\nbuild.ninja\nrules.ninja\n.ninja_deps\n.ninja_log\nepan/dissectors/asn1/*/*-stamp\nepan/dissectors/pidl/*-stamp\nepan/dissectors/dcerpc/*-stamp\n\n# Doc #\n########\ndoc/man_pages/*.html\ndoc/man_pages/*.[14]\ndoc/developer-guide*.xml\ndoc/user-guide*.xml\ndoc/*-guide-*.pdf\ndoc/ws?g_html/\ndoc/ws?g_html_chunked/\ndoc/Wireshark Release Notes.html\ndoc/Wireshark Release Notes.txt\ndoc/Stratoshark Release Notes.html\ndoc/Stratoshark Release Notes.txt\ndoc/wsluarm\ndoc/wsluarm_src/\nwsar_html/\nwsar_html.zip\n\n# Qt #\n######\n/ui/qt/__/\n/ui/qt/*.qm\n/ui/qt/**/moc_*.cpp\n/ui/qt/i18n.qrc\n/ui/qt/qrc_*.cpp\n/ui/qt/ui_*.h\n*.ui.autosave\n\n# Windows Stuff #\n#################\n*.bsc\n*.dir/\n*.dsp\n*.dsw\n*.exp\n*.lib\n*.ilk\n*.manifest\n*.pdb\n*.nativecodeanalysis.xml\n*.rc\n!file_dlg_win32.rc\n*.res\n*.vcxproj*\n/Copying.txt\n/News.txt\n/README.txt\n/README.windows.txt\nWireshark.opensdf\nWireshark.sdf\nWireshark.sln\nWireshark.*.suo\npackaging/nsis/all-manifest.nsh\npackaging/nsis/config.nsh\npackaging/nsis/qt-dll-manifest.nsh\npackaging/portableapps/WiresharkPortable/\npackaging/portableapps/Files/\npackaging/portableapps/appinfo.ini\nwireshark-win??-libs*/\n\n# macOS Stuff\n.DS_Store\nmacosx-support-libs\npackaging/macosx/Info.plist\npackaging/macosx/osx-dmg.sh\npackaging/macosx/PkgInfo\n\n# clangd #\n##########\n.cache\ncompile_commands.json\n\n# Qt Creator\nCMakeLists.txt.user*\n\n# Debian packaging\n/debian/\n\n# Misc #\n########\n.vagrant\n.vscode\n.idea\n*.sw?\n*~\ncscope.*\ntags\nTAGS\nvgcore.*\n.pytest_cache/\ntest/*.log\n*.code-workspace\n__pycache__/\n"
        },
        {
          "name": ".gitlab-ci.yml",
          "type": "blob",
          "size": 60.6591796875,
          "content": "# In the interest of reliability and performance, please avoid installing\n# external dependencies here, e.g. via tools/*-setup.sh, apt, dnf, or yum.\n# Do so in the appropriate Dockerfile at\n# https://gitlab.com/wireshark/wireshark-containers/ instead.\n# The resulting images can be found at\n# https://gitlab.com/wireshark/wireshark-containers/container_registry\n\nstages:\n  - build\n  - analysis\n  - test\n  - fuzz-asan\n  - fuzz-randpkt\n  - fuzz-valgrind\n\nvariables:\n  # Ensure that checkouts are a) fast and b) have a reachable tag. In a\n  # brighter, more glorious future we might be able to use --shallow-since:\n  # https://gitlab.com/gitlab-org/gitlab-runner/-/issues/3460\n  # In the mean time, fetching the last 5000 commits does the job.\n  # Ensure that all variables are string\n  GIT_DEPTH: \"1\"\n  GIT_FETCH_EXTRA_FLAGS: \"--depth=5000\"\n  CCACHE_DIR: \"${CI_PROJECT_DIR}/ccache\"\n  # The Qt versions that we ship in the development installers.\n  WINDOWS_QT_VERSION: \"6.8.1\"\n  MACOS_QT_VERSION: \"6.5.3\"\n  # Enable color output in various tools.\n  # CMake, Ninja, and others: https://bixense.com/clicolors/\n  CLICOLOR_FORCE: \"1\"\n  # pytest\n  FORCE_COLOR: \"1\"\n  # Homebrew\n  HOMEBREW_COLOR: \"1\"\n  # Skip irrelevant SAST scanners:\n  SAST_EXCLUDED_ANALYZERS: \"brakeman,eslint,security-code-scan,semgrep,spotbugs\"\n\nworkflow:\n  auto_cancel:\n    # Automatically cancel pipelines if new changes are pushed to a branch\n    # and the job is interruptible. Jobs are not interruptible by default.\n    on_new_commit: interruptible\n\n# Scheduled builds additionally set SCHEDULE_TYPE, which can be one of:\n# - 2x-daily: Twice daily at 07:00 and 19:00 UTC\n# - daily: Daily at 10:00 UTC\n# - weekly: Sunday at 14:00 UTC\n# - coverity-visual-c++: Monday, Wednesday, & Friday at 12:00 UTC\n# - coverity-gcc: Sunday, Tuesday, Thursday & Saturday at 12:00 UTC\n\n# Common rule stanzas\n# These must currently be including using \"!reference tags\". \"extends:\" and\n# YAML anchors won't work:\n# https://gitlab.com/gitlab-org/gitlab/-/issues/322992\n\n# Commits that have been approved and merged. Run automatically in the main\n# repo and allow manual runs in the web UI and in forks.\n# Release builds: CI_PIPELINE_SOURCE=api\n.if-merged:\n  # Regular commits: CI_PIPELINE_SOURCE=push, CI_COMMIT_BRANCH=master\n  - if: '$CI_PIPELINE_SOURCE == \"push\" && $CI_COMMIT_BRANCH == \"master\" && $CI_PROJECT_URL =~ /.*gitlab.com\\/wireshark\\/wireshark/'\n  # \"Run pipeline\" button commits, cherry picks\n  - if: '$CI_PIPELINE_SOURCE == \"web\" && $CI_COMMIT_BRANCH == \"master\" && $CI_PROJECT_URL =~ /.*gitlab.com\\/wireshark\\/wireshark/'\n  # Tagged release builds: CI_PIPELINE_SOURCE=api (should be \"web\"?)\n  - if: '$CI_PIPELINE_SOURCE == \"api\"'\n  - if: '$CI_PIPELINE_SOURCE == \"push\" && $CI_PROJECT_URL !~ /.*gitlab.com\\/wireshark\\/wireshark/'\n    when: manual\n# Merged commits for runners which are only available in\n# wireshark/wireshark, e.g. wireshark-windows-*. Run automatically in\n# the main repo and allow manual runs in the web UI.\n.if-w-w-only-merged:\n  - if: '$CI_PIPELINE_SOURCE == \"push\" && $CI_COMMIT_BRANCH == \"master\" && $CI_PROJECT_URL =~ /.*gitlab.com\\/wireshark\\/wireshark/'\n  - if: '$CI_PIPELINE_SOURCE == \"web\" && $CI_COMMIT_BRANCH == \"master\" && $CI_PROJECT_URL =~ /.*gitlab.com\\/wireshark\\/wireshark/'\n  - if: '$CI_PIPELINE_SOURCE == \"api\"'\n# Incoming merge requests.\n.if-merge-request:\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n    interruptible: true\n# Incoming non-detached merge requests. Must be used for runners which are only\n# available in wireshark/wireshark, e.g. wireshark-windows-*\n.if-w-w-only-merge-request:\n  - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\" && $CI_PROJECT_URL =~ /.*gitlab.com\\/wireshark\\/wireshark/'\n    interruptible: true\n# Scheduled jobs. Care should be taken when changing this since the scheduler\n# often doesn't report errors.\n.if-weekly-schedule:\n  - if: '$CI_PIPELINE_SOURCE == \"schedule\" && $SCHEDULE_TYPE == \"weekly\"'\n.if-daily-schedule:\n  - if: '$CI_PIPELINE_SOURCE == \"schedule\" && $SCHEDULE_TYPE == \"daily\"'\n.if-2x-daily-schedule:\n  - if: '$CI_PIPELINE_SOURCE == \"schedule\" && $SCHEDULE_TYPE == \"2x-daily\"'\n# Fuzz jobs. Care should be taken when changing this since the scheduler\n# often doesn't report errors.\n.if-fuzz-schedule:\n  - if: '$CI_PIPELINE_SOURCE == \"schedule\" && $SCHEDULE_TYPE == \"fuzz\"'\n\n.build-linux:\n  stage: build\n  tags:\n    - saas-linux-small-amd64\n  before_script:\n    - printf \"\\e[0Ksection_start:%s:ci_env_section[collapsed=true]\\r\\e[0KCI environment variables\" \"$(date +%s)\"\n    - env | grep ^CI | sort\n    - printf \"\\e[0Ksection_end:%s:ci_env_section\\r\\e[0K\" \"$(date +%s)\"\n  after_script:\n    - for builddir in build/packaging/rpm/BUILD/wireshark-*/build build/packaging/rpm/BUILD/wireshark-* build obj-*; do [ ! -d \"$builddir/run\" ] || break; done\n    - if [[ \"$CI_JOB_NAME\" == \"build:rpm-opensuse-\"* ]]; then export LD_LIBRARY_PATH=$builddir/run; fi\n    - if [ -f $builddir/run/tshark ]; then $builddir/run/tshark --version; fi\n  needs: []\n\n.test-linux:\n  stage: test\n  tags:\n    - saas-linux-small-amd64\n  variables:\n    GIT_STRATEGY: none\n\n.build-ubuntu:\n  extends: .build-linux\n  image: registry.gitlab.com/wireshark/wireshark-containers/ubuntu-dev\n  retry: 1\n  # https://gould.cx/ted/blog/2017/06/10/ccache-for-Gitlab-CI/\n  cache:\n    # XXX Use ${CI_JOB_NAME}-${CI_MERGE_REQUEST_TARGET_BRANCH_NAME} instead?\n    key: ${CI_JOB_NAME}-master\n    paths:\n      - ccache/\n  before_script:\n    - printf \"\\e[0Ksection_start:%s:ci_env_section[collapsed=true]\\r\\e[0KCI environment variables\" \"$(date +%s)\"\n    - env | grep ^CI | sort\n    - printf \"\\e[0Ksection_end:%s:ci_env_section\\r\\e[0K\" \"$(date +%s)\"\n    - useradd user\n    - export LANG=en_US.UTF-8\n    - export PYTEST_ADDOPTS=--skip-missing-programs=dumpcap,rawshark\n    - mkdir -p ccache\n    - ccache --show-stats\n    - export DEB_BUILD_OPTIONS=\"nocheck parallel=$(( $(getconf _NPROCESSORS_ONLN) + 2 ))\"\n    - export DH_QUIET=1\n    - export MAKEFLAGS=--silent\n    - NUM_COMMITS=$(curl --silent $CI_API_V4_URL/projects/$CI_MERGE_REQUEST_PROJECT_ID/merge_requests/$CI_MERGE_REQUEST_IID/commits | jq length)\n    - echo \"$NUM_COMMITS commit(s) in this MR\"\n    - mkdir build\n    - cd build\n  script:\n    # setcap restricts our library paths\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - CFLAGS=-Wl,-rpath=$(pwd)/run CXXFLAGS=-Wl,-rpath=$(pwd)/run cmake -GNinja -DENABLE_CCACHE=ON $CMAKE_ARGS ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - ninja install\n  after_script:\n    # The cache should be large enough to be useful but it shouldn't take\n    # too long to restore+save each run.\n    - cd \"$CI_PROJECT_DIR\"\n    - ccache --max-size $( du --total --summarize --block-size=1M *build*/ | awk 'END {printf (\"%dM\", $1 * 1.5)}' )\n\n.build-rpm:\n  extends: .build-linux\n  rules: !reference [.if-2x-daily-schedule]\n  before_script:\n    # Hack to let ninja make full use of the system on Fedora and Rocky.\n    - export RPM_BUILD_NCPUS=$(( $( getconf _NPROCESSORS_ONLN ) + 2 ))\n    - git config --global user.email \"you@example.com\"\n    - git config --global user.name \"Your Name\"\n    - mkdir build\n    - cd build\n    - ../tools/make-version.py --set-release ..\n    - mv -v ../wireshark-*.tar.* .\n  artifacts:\n    paths:\n      - build/packaging/rpm/RPMS\n    expire_in: 3 days\n  needs:\n    - 'Source Package'\n\n.test-rpm:\n  extends: .test-linux\n  rules: !reference [.if-2x-daily-schedule]\n\n.build-windows:\n  stage: build\n  retry: 1\n  before_script:\n    - if (-Not (Test-Path C:\\Development)) { New-Item -Path C:\\Development -ItemType \"directory\" }\n    - $env:WIRESHARK_BASE_DIR = \"C:\\Development\"\n    - $env:Configuration = \"RelWithDebInfo\"\n    - $env:Path += \";C:\\Program Files\\CMake\\bin\"\n    - $env:CMAKE_PREFIX_PATH = \"C:\\qt\\$($env:WINDOWS_QT_VERSION)\\msvc2022_64\"\n    # https://help.appveyor.com/discussions/questions/18777-how-to-use-vcvars64bat-from-powershell\n    - cmd.exe /c \"call `\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat`\" && set \" | Foreach-Object { if ($_ -match \"^(.*?)=(.*)$\") { Set-Content \"env:\\$($matches[1])\" $matches[2] } }\n    # Testing / debugging only.\n    # - cmd.exe /c \"set CI_PIPELINE_SOURCE\"\n    # - cmd.exe /c \"set CI_PROJECT_URL\"\n    #- dir c:\\\n    #- dir c:\\qt\n    #- $env:path.split(\";\")\n    #- cmd.exe /c \"set\"\n    #- Get-Location\n    - mkdir build\n    - cd build\n  needs: []\n\n# macOS runners are still beta:\n# https://about.gitlab.com/blog/2021/08/23/build-cloud-for-macos-beta/\n# https://docs.gitlab.com/ee/ci/runners/saas/macos/environment.html#vm-images\n# https://gitlab.com/gitlab-org/ci-cd/shared-runners/images/macstadium/orka/-/blob/main/toolchain/monterey.yml\n.build-macos:\n  stage: build\n  tags: [ saas-macos-medium-m1 ] # https://docs.gitlab.com/ee/ci/runners/saas/macos/environment.html\n  retry: 1\n  # https://gould.cx/ted/blog/2017/06/10/ccache-for-Gitlab-CI/\n  cache:\n    key: ${CI_JOB_NAME}-master\n    paths:\n      - ccache/\n  variables:\n    HOMEBREW_NO_AUTO_UPDATE: \"1\"\n    HOMEBREW_DISPLAY_INSTALL_TIMES: \"1\"\n    HOMEBREW_NO_INSTALL_CLEANUP: \"1\"\n    HOMEBREW_NO_INSTALL_UPGRADE: \"1\"\n    HOMEBREW_NO_INSTALLED_DEPENDENTS_CHECK: \"1\"\n    HOMEBREW_NO_UPDATE_REPORT_NEW: \"1\"\n  before_script:\n    - printf \"\\e[0Ksection_start:%s:ci_env_section[collapsed=true]\\r\\e[0KCI environment variables\" \"$(date +%s)\"\n    - env | grep ^CI | sort\n    - printf \"\\e[0Ksection_end:%s:ci_env_section\\r\\e[0K\" \"$(date +%s)\"\n    - brew --version\n    - printf \"\\e[0Ksection_start:%s:brew_section[collapsed=true]\\r\\e[0KInstalling prerequisites\" \"$( date +%s)\"\n    - ./tools/macos-setup-brew.sh --install-optional --install-test-deps\n    - printf \"\\e[0Ksection_end:%s:brew_section\\r\\e[0K\" \"$( date +%s)\"\n    - python3 -m venv $CI_PROJECT_DIR/.venv\n    - source $CI_PROJECT_DIR/.venv/bin/activate\n    - pip3 install pytest pytest-xdist\n    - export PYTEST_ADDOPTS=--skip-missing-programs=dumpcap,rawshark\n    - mkdir -p ccache\n    - ccache --show-stats\n    - mkdir build\n    - cd build\n  script:\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja -DENABLE_CCACHE=ON -DTEST_EXTRA_ARGS=--disable-capture ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - ninja test-programs\n    - pytest --disable-capture\n  after_script:\n    # The cache should be large enough to be useful but it shouldn't take\n    # too long to restore+save each run.\n    - ccache --max-size $( gdu --summarize --block-size=1M \"$CI_PROJECT_DIR/build\" | awk '{printf (\"%dM\", $1 * 1.5)}' )\n  needs: []\n\n.build-mingw:\n  stage: build\n  image: registry.gitlab.com/wireshark/wireshark-containers/mingw-dev\n  tags:\n    - saas-linux-small-amd64\n  cache:\n    # XXX Use ${CI_JOB_NAME}-${CI_MERGE_REQUEST_TARGET_BRANCH_NAME} instead?\n    key: ${CI_JOB_NAME}-master\n    paths:\n      - ccache/\n  before_script:\n    - printf \"\\e[0Ksection_start:%s:ci_env_section[collapsed=true]\\r\\e[0KCI environment variables\" \"$(date +%s)\"\n    - env | grep ^CI | sort\n    - printf \"\\e[0Ksection_end:%s:ci_env_section\\r\\e[0K\" \"$(date +%s)\"\n    - mkdir -p ccache\n    - ccache --show-stats\n    - mkdir build\n    - cd build\n  script:\n    - mingw64-cmake -G Ninja -DENABLE_CCACHE=Yes -DFETCH_lua=Yes ..\n    - ninja\n  after_script:\n    # The cache should be large enough to be useful but it shouldn't take\n    # too long to restore+save each run.\n    - ccache --max-size $( du --summarize --block-size=1M \"$CI_PROJECT_DIR/build\" | awk '{printf (\"%dM\", $1 * 1.5)}' )\n  needs: []\n\nSource Package:\n  extends: .build-ubuntu\n  stage: .pre\n  rules:\n    - !reference [.if-w-w-only-merged]\n    - !reference [.if-2x-daily-schedule]\n  script:\n    - ../tools/make-version.py --set-release --wireshark-version-file=wireshark_version.txt --stratoshark-version-file=stratoshark_version.txt ..\n    - ../tools/update-appdata.py\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja $CMAKE_ARGS ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - cd $CI_PROJECT_DIR\n    - build/packaging/source/git-export-release.sh -d .\n    - cd build\n    - ninja release_notes\n    - WIRESHARK_VERSION=$(< wireshark_version.txt)\n    - cp -v \"doc/Wireshark Release Notes.html\" ../wireshark-release-notes-${WIRESHARK_VERSION}.html\n    - cp -v \"doc/Wireshark Release Notes.txt\" ../wireshark-release-notes-${WIRESHARK_VERSION}.txt\n    - STRATOSHARK_VERSION=$(< stratoshark_version.txt)\n    - cp -v \"doc/Stratoshark Release Notes.html\" ../stratoshark-release-notes-${STRATOSHARK_VERSION}.html\n    - cp -v \"doc/Stratoshark Release Notes.txt\" ../stratoshark-release-notes-${STRATOSHARK_VERSION}.txt\n    - cd ..\n    - zstdcat --threads=0 wireshark-${WIRESHARK_VERSION}.tar.zst | xz --threads=0 > wireshark-${WIRESHARK_VERSION}.tar.xz\n  after_script:\n    # - ccache --max-size $( du --summarize --block-size=1M \"$CI_PROJECT_DIR/build\" | awk '{printf (\"%dM\", $1 * 1.5)}' )\n    - if [ \"$CI_JOB_STATUS\" != \"success\" ]; then exit 0 ; fi\n    - if [ -n \"$SCHEDULE_TYPE\" ] ; then exit 0 ; fi\n    - stat --format=\"%n %s bytes\" wireshark-*.tar.*\n    - for digest in sha512 sha256 sha1 ; do openssl $digest wireshark-*.tar.* ; done\n    - if [ -n \"$MC_DESTINATION_DIST\" ] ; then mc --quiet cp wireshark-*.tar.* \"$MC_DESTINATION_DIST/\" ; fi\n    - if [ -n \"$MC_DESTINATION_RELEASE\" ] ; then mc --quiet cp {wire,strato}shark-release-notes-*.{txt,html} \"$MC_DESTINATION_RELEASE/\" ; fi\n  artifacts:\n    paths:\n      - wireshark-*.tar.*\n      - wireshark-release-notes-*.html\n      - wireshark-release-notes-*.txt\n      - stratoshark-release-notes-*.html\n      - stratoshark-release-notes-*.txt\n\n# Job to generate packages for Debian stable\nDebian Stable APT Package:\n  extends: .build-linux\n  rules: !reference [.if-2x-daily-schedule]\n  image: registry.gitlab.com/wireshark/wireshark-containers/debian-stable-dev\n  script:\n    - ln --symbolic --no-dereference --force packaging/debian\n    - tools/make-version.py --set-release .\n    # Shared GitLab runners limit the log size to 4M, so reduce verbosity. See\n    # https://gitlab.com/gitlab-com/support-forum/issues/2790\n    - export DEB_BUILD_OPTIONS=\"nocheck parallel=$(( $(getconf _NPROCESSORS_ONLN) + 2 ))\"\n    - export DH_QUIET=1\n    - export MAKEFLAGS=--silent\n    - CC=/usr/lib/ccache/gcc CXX=/usr/lib/ccache/g++ dpkg-buildpackage -b --no-sign -jauto -zfast\n    # Please don't add a Lintian step unless you can guarantee that someone\n    # will fix any breakages that invariably pop up.\n    - mkdir debian-packages\n    - mv -v ../*.deb debian-packages/\n  artifacts:\n    paths:\n      - debian-packages/*.deb\n    expire_in: 3 days\n\nDebian Stable APT Test:\n  extends: .test-linux\n  rules: !reference [.if-2x-daily-schedule]\n  image: registry.gitlab.com/wireshark/wireshark-containers/debian-stable-dev\n  stage: test\n  script:\n    - DEBIAN_FRONTEND=noninteractive apt-get install ./debian-packages/*.deb -y\n    - tshark --version\n  variables:\n    GIT_STRATEGY: none\n  needs: [ 'Debian Stable APT Package' ]\n\nFedora RPM Package:\n  extends: .build-rpm\n  image: registry.gitlab.com/wireshark/wireshark-containers/fedora-dev\n  script:\n    # Shared GitLab runners limit the log size to 4M, so reduce verbosity. See\n    # https://gitlab.com/gitlab-com/support-forum/issues/2790\n    - export FORCE_CMAKE_NINJA_NON_VERBOSE=1\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake3 -G Ninja ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja wireshark_rpm\n\n# Fedora RPM Test:\n#   extends: .test-rpm\n#   image: fedora\n#   script:\n#     - dnf install -y build/packaging/rpm/RPMS/x86_64/*.rpm\n#     - tshark --version\n#  needs: [ 'Fedora RPM Package' ]\n\nopenSUSE 15.6 RPM Package:\n  extends: .build-rpm\n  image: registry.gitlab.com/wireshark/wireshark-containers/opensuse-15.6-dev\n  script:\n    - source /gcc-latest.env\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja wireshark_rpm\n\nopenSUSE 15.6 RPM Test:\n  extends: .test-rpm\n  image: registry.gitlab.com/wireshark/wireshark-containers/opensuse-15.6-dev\n  script:\n    - zypper --no-gpg-checks --no-remote install -y build/packaging/rpm/RPMS/x86_64/*.rpm\n    - tshark --version\n  needs: [ 'openSUSE 15.6 RPM Package' ]\n\nRocky Linux 9 RPM Package:\n  extends: .build-rpm\n  image: registry.gitlab.com/wireshark/wireshark-containers/rockylinux-9-dev\n  script:\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja -DUSE_qt6=OFF ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja wireshark_rpm\n\nRocky Linux 9 RPM Test:\n  extends: .test-rpm\n  image: registry.gitlab.com/wireshark/wireshark-containers/rockylinux-9-dev\n  script:\n    - dnf --nogpgcheck localinstall -y build/packaging/rpm/RPMS/x86_64/*.rpm\n    - tshark --version\n  needs: [ 'Rocky Linux 9 RPM Package' ]\n\nUbuntu APT Package:\n  extends: .build-ubuntu\n  rules: !reference [.if-2x-daily-schedule]\n  script:\n    # build-ubuntu puts us in `build`.\n    - cd ..\n    - ln --symbolic --no-dereference --force packaging/debian\n    - CC=/usr/lib/ccache/gcc CXX=/usr/lib/ccache/g++ MAKE=ninja dpkg-buildpackage -us -uc -rfakeroot -jauto -zfast\n    # Please don't add a Lintian step unless you can guarantee that someone\n    # will fix any breakages that invariably pop up.\n    - mkdir ubuntu-packages\n    - mv ../*.deb ubuntu-packages/\n  after_script:\n    # dpkg-buildpackage builds in obj-<triplet>, so we need to override\n    # .build-ubuntu. We also build more stuff, so decrease our multiplier.\n    - ccache --max-size $( du --summarize --block-size=1M --total \"$CI_PROJECT_DIR\"/obj-* | awk '/total$/ {printf (\"%dM\", $1 * 1.25)}' )\n  artifacts:\n    paths:\n      - ubuntu-packages/*.deb\n    expire_in: 3 days\n\nUbuntu APT Test:\n  extends: .test-linux\n  rules: !reference [.if-2x-daily-schedule]\n  image: registry.gitlab.com/wireshark/wireshark-containers/ubuntu-dev\n  stage: test\n  script:\n    - DEBIAN_FRONTEND=noninteractive apt-get install ./ubuntu-packages/*.deb -y\n    - tshark --version\n  variables:\n    GIT_STRATEGY: none\n  needs: [ 'Ubuntu APT Package' ]\n\nArch Linux :\n  extends: .build-linux\n  rules: !reference [.if-2x-daily-schedule]\n  image: registry.gitlab.com/wireshark/wireshark-containers/arch-dev\n  script:\n    - COMMON_PACMAN_ARGS=\"--sync --refresh --sysupgrade --needed --noconfirm\"\n    - ./tools/make-version.py --set-release --wireshark-version-file=wireshark_version.txt .\n    - WIRESHARK_VERSION=$(cat wireshark_version.txt)\n    - WIRESHARK_PREFIX=\"/opt/wireshark-$WIRESHARK_VERSION\"\n    # There are no falcosecurity/libs or falcosecurity/plugins packages for Arch,\n    # so just build them ourselves for now.\n    - pushd /tmp\n    # falcosecurity/plugins\n    - pacman $COMMON_PACMAN_ARGS go\n    - git clone https://github.com/falcosecurity/plugins.git falco-plugins\n    - pushd /tmp/falco-plugins/plugins/cloudtrail\n    - make\n    - popd\n    - pushd /tmp/falco-plugins/plugins/gcpaudit\n    - make\n    - popd\n    # falcosecurity/libs\n    - pacman $COMMON_PACMAN_ARGS uthash libelf onetbb jsoncpp re2\n    - export LDFLAGS=-Wl,-rpath,'$ORIGIN/../lib'\n    - git clone https://github.com/falcosecurity/libs.git falco-libs\n    - cd /tmp/falco-libs\n    - git switch -c 0.18.1 0.18.1\n    - printf \"\\e[0Ksection_start:%s:fslibs_cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -B build -G Ninja -DBUILD_SHARED_LIBS=on -DMINIMAL_BUILD=on -DBUILD_DRIVER=off -DENABLE_ENGINE_KMOD=off -DBUILD_LIBSCAP_EXAMPLES=off -DUSE_BUNDLED_DEPS=off -DUSE_BUNDLED_VALIJSON=on -DCREATE_TEST_TARGETS=off -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_INSTALL_RPATH='$ORIGIN/../lib' -DCMAKE_INSTALL_PREFIX=$WIRESHARK_PREFIX\n    - printf \"\\e[0Ksection_end:%s:fslibs_cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja -C build\n    - ninja -C build install\n    - sed -i -e 's/-linstall_lib_link_libraries-NOTFOUND/-lscap_platform -lscap_platform_util/g' $WIRESHARK_PREFIX/lib/pkgconfig/libscap.pc\n    - popd\n    - export CMAKE_PREFIX_PATH=$WIRESHARK_PREFIX\n    - mkdir build\n    - cd build\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja -DBUILD_stratoshark=on -DBUILD_sshdig=on -DBUILD_falcodump=on -DFALCO_PLUGINS=\"/tmp/falco-plugins/plugins/cloudtrail/libcloudtrail.so;/tmp/falco-plugins/plugins/gcpaudit/libgcpaudit.so\" -DCMAKE_INSTALL_PREFIX=$WIRESHARK_PREFIX ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - ninja install\n    - install -v -D -m 755 -t $WIRESHARK_PREFIX/lib/stratoshark/plugins/4.5/epan run/plugins/4.5/epan/falco-bridge.so\n    - install -v -D -m 755 -t $WIRESHARK_PREFIX/lib/stratoshark/plugins/falco run/plugins/falco/*.so\n    # XXX Need to add an install prereqs script\n    - tar -C / -cJf $CI_PROJECT_DIR/wireshark-arch-$WIRESHARK_VERSION.tar.xz opt/wireshark-$WIRESHARK_VERSION\n  artifacts:\n    paths:\n      - $CI_PROJECT_DIR/wireshark-arch-*.tar.xz\n\nWindows x64 Package:\n  extends: .build-windows\n  rules: !reference [.if-w-w-only-merged]\n  tags:\n    - wireshark-windows-x64-package\n  before_script:\n    - $env:WIRESHARK_BASE_DIR = \"C:\\Development\"\n    - $env:Configuration = \"RelWithDebInfo\"\n    - $env:CMAKE_PREFIX_PATH = \"C:\\Qt\\$($env:WINDOWS_QT_VERSION)\\msvc2022_64\"\n    # https://help.appveyor.com/discussions/questions/18777-how-to-use-vcvars64bat-from-powershell\n    - cmd.exe /c \"call `\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat`\" && set\" | Foreach-Object { if ($_ -match \"^(.*?)=(.*)$\") { Set-Content \"env:\\$($matches[1])\" $matches[2] } }\n    - mkdir build\n    - cd build\n  script:\n    - C:\\Windows\\py.exe ..\\tools\\make-version.py --set-release --wireshark-version-file=wireshark_version.txt --stratoshark-version-file=stratoshark_version.txt ..\n    - cmake -G \"Visual Studio 17 2022\" -A x64 -DENABLE_LTO=off -DBUILD_stratoshark=on -DBUILD_sshdig=on -DBUILD_falcodump=on -DENABLE_SIGNED_NSIS=on ..\n    - msbuild /verbosity:minimal \"/consoleloggerparameters:PerformanceSummary;NoSummary\" /maxcpucount Wireshark.sln\n    - msbuild /verbosity:minimal /maxcpucount test-programs.vcxproj\n    - msbuild /verbosity:minimal /maxcpucount wireshark_nsis_prep.vcxproj\n    - msbuild /verbosity:minimal /maxcpucount stratoshark_nsis_prep.vcxproj\n    - msbuild /verbosity:minimal /maxcpucount wireshark_wix_prep.vcxproj\n    - C:\\gitlab-builds\\bin\\sign-files.ps1 -Recurse -Path run\\RelWithDebInfo\n    - msbuild /verbosity:minimal wireshark_nsis.vcxproj\n    - msbuild /verbosity:minimal stratoshark_nsis.vcxproj\n    # No need for explicit signing of NSIS installer here. The signing is done by makensis.\n    - msbuild /verbosity:minimal wireshark_wix.vcxproj\n    - C:\\gitlab-builds\\bin\\sign-files.ps1 -Path packaging\\wix\\Wireshark-*.msi\n    - msbuild /verbosity:minimal wireshark_portableapps.vcxproj\n    - C:\\gitlab-builds\\bin\\sign-files.ps1 -Path packaging\\portableapps\\WiresharkPortable*.exe\n    - $plugins = Get-ChildItem run\\RelWithDebInfo\\plugins\\*\\*.dll ; signtool verify /q /pa /all run\\RelWithDebInfo\\*.exe run\\RelWithDebInfo\\extcap\\wireshark\\*.exe $plugins run\\RelWithDebInfo\\libwireshark.dll run\\RelWithDebInfo\\libwiretap.dll run\\RelWithDebInfo\\libwsutil.dll packaging\\nsis\\Wireshark-*-x64.exe packaging\\nsis\\Stratoshark-*-x64.exe packaging\\wix\\Wireshark-*-x64.msi packaging\\portableapps\\WiresharkPortable??_*.paf.exe\n    - msbuild /verbosity:minimal pdb_zip_package.vcxproj\n    - C:\\gitlab-builds\\bin\\mse-scan.ps1\n    - run\\RelWithDebInfo\\tshark --version\n    - $packages = Get-ChildItem \"packaging\\nsis\\Wireshark-*-x64.exe\", \"packaging\\nsis\\Stratoshark-*-x64.exe\", \"packaging\\wix\\Wireshark-*-x64.msi\", \"packaging\\portableapps\\WiresharkPortable??_*.paf.exe\", \"Wireshark-pdb-*x64.zip\"\n    - foreach ($package in $packages) { Write-Host $package.name $(Get-Filehash -Algorithm SHA256 $package).Hash $package.length \"bytes\" }\n    - if (Test-Path env:MC_DESTINATION_WINDOWS_X64) { C:\\gitlab-builds\\bin\\mc --quiet cp $packages \"$env:MC_DESTINATION_WINDOWS_X64/\" }\n    - $wiresharkVersion = Get-Content .\\wireshark_version.txt\n    - $wiresharkNsisSha256 = (Get-FileHash -Algorithm SHA256 .\\packaging\\nsis\\Wireshark-*-x64.exe).Hash\n    - Set-Content -Path wireshark-release-info-$($wiresharkVersion)-windows-x64.ini -Value (\"[DEFAULT]`nnsis_sha256 = $wiresharkNsisSha256\")\n    - $stratosharkVersion = Get-Content .\\stratoshark_version.txt\n    - $stratosharkNsisSha256 = (Get-FileHash -Algorithm SHA256 .\\packaging\\nsis\\Stratoshark-*-x64.exe).Hash\n    - Set-Content -Path stratoshark-release-info-$($stratosharkVersion)-windows-x64.ini -Value (\"[DEFAULT]`nnsis_sha256 = $stratosharkNsisSha256\")\n    - if (Test-Path env:MC_DESTINATION_RELEASE) { C:\\gitlab-builds\\bin\\mc --quiet cp $(Get-ChildItem \"*shark-release-info-*-windows-*.ini\") \"$env:MC_DESTINATION_RELEASE/\" }\n    - C:\\Windows\\py.exe -m pytest\n  artifacts:\n    paths:\n      - build/*shark-release-info-*-windows-*.ini\n\nWindows Arm64 Package:\n  extends: .build-windows\n  rules: !reference [.if-w-w-only-merged]\n  tags:\n    - wireshark-windows-arm64-package\n  before_script:\n    - $env:WIRESHARK_BASE_DIR = \"C:\\Development\"\n    - $env:Configuration = \"RelWithDebInfo\"\n    - $env:CMAKE_PREFIX_PATH = \"C:\\Qt\\$($env:WINDOWS_QT_VERSION)\\msvc2022_arm64\"\n    # https://help.appveyor.com/discussions/questions/18777-how-to-use-vcvars64bat-from-powershell\n    - cmd.exe /c \"call `\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvarsarm64.bat`\" && set\" | Foreach-Object { if ($_ -match \"^(.*?)=(.*)$\") { Set-Content \"env:\\$($matches[1])\" $matches[2] } }\n    - mkdir build\n    - cd build\n  script:\n    - C:\\Windows\\py.exe ..\\tools\\make-version.py --set-release --wireshark-version-file=wireshark_version.txt --stratoshark-version-file=stratoshark_version.txt ..\n    - cmake -G \"Visual Studio 17 2022\" -A arm64 -DENABLE_LTO=off -DBUILD_stratoshark=on -DBUILD_sshdig=on -DBUILD_falcodump=on -DENABLE_SIGNED_NSIS=on ..\n    - msbuild /verbosity:minimal \"/consoleloggerparameters:PerformanceSummary;NoSummary\" /maxcpucount Wireshark.sln\n    - msbuild /verbosity:minimal /maxcpucount test-programs.vcxproj\n    - msbuild /verbosity:minimal /maxcpucount wireshark_nsis_prep.vcxproj\n    - msbuild /verbosity:minimal /maxcpucount stratoshark_nsis_prep.vcxproj\n    - C:\\gitlab-builds\\bin\\sign-files.ps1 -Recurse -Path run\\RelWithDebInfo\n    - msbuild /verbosity:minimal wireshark_nsis.vcxproj\n    - msbuild /verbosity:minimal stratoshark_nsis.vcxproj\n    - $plugins = Get-ChildItem run\\RelWithDebInfo\\plugins\\*\\*.dll ; signtool verify /q /pa /all run\\RelWithDebInfo\\*.exe run\\RelWithDebInfo\\extcap\\wireshark\\*.exe $plugins run\\RelWithDebInfo\\libwireshark.dll run\\RelWithDebInfo\\libwiretap.dll run\\RelWithDebInfo\\libwsutil.dll packaging\\nsis\\Wireshark-*-arm64.exe packaging\\nsis\\Stratoshark-*-arm64.exe\n    - msbuild /verbosity:minimal pdb_zip_package.vcxproj\n    - C:\\gitlab-builds\\bin\\mse-scan.ps1\n    - run\\RelWithDebInfo\\tshark --version\n    - $packages = Get-ChildItem \"packaging\\nsis\\Wireshark-*-arm64.exe\", \"packaging\\nsis\\Stratoshark-*-arm64.exe\", \"Wireshark-pdb-*arm64.zip\"\n    - foreach ($package in $packages) { Write-Host $package.name $(Get-Filehash -Algorithm SHA256 $package).Hash $package.length \"bytes\" }\n    - if (Test-Path env:MC_DESTINATION_WINDOWS_ARM64) { C:\\gitlab-builds\\bin\\mc --quiet cp $packages \"$env:MC_DESTINATION_WINDOWS_ARM64/\" }\n    - $wiresharkVersion = Get-Content .\\wireshark_version.txt\n    - $wiresharkNsisSha256 = (Get-FileHash -Algorithm SHA256 .\\packaging\\nsis\\Wireshark-*-arm64.exe).Hash\n    - Set-Content -Path wireshark-release-info-$($wiresharkVersion)-windows-arm64.ini -Value (\"[DEFAULT]`nnsis_sha256 = $wiresharkNsisSha256\")\n    - $stratosharkVersion = Get-Content .\\stratoshark_version.txt\n    - $stratosharkNsisSha256 = (Get-FileHash -Algorithm SHA256 .\\packaging\\nsis\\Stratoshark-*-arm64.exe).Hash\n    - Set-Content -Path stratoshark-release-info-$($stratosharkVersion)-windows-arm64.ini -Value (\"[DEFAULT]`nnsis_sha256 = $stratosharkNsisSha256\")\n    - if (Test-Path env:MC_DESTINATION_RELEASE) { C:\\gitlab-builds\\bin\\mc --quiet cp $(Get-ChildItem \"*shark-release-info-*-windows-*.ini\") \"$env:MC_DESTINATION_RELEASE/\" }\n    - C:\\Windows\\py.exe -m pytest\n  artifacts:\n    paths:\n      - build/*shark-release-info-*-windows-*.ini\n\nWindows MinGW-w64 Package:\n  extends: .build-mingw\n  rules: !reference [.if-w-w-only-merged]\n  script:\n    - mingw64-cmake -G Ninja -DENABLE_CCACHE=Yes -DFETCH_lua=Yes ..\n    - ninja\n    - ninja user_guide_html\n    - ninja wireshark_nsis_prep\n    - ninja wireshark_nsis\n  artifacts:\n    paths:\n      - build/packaging/nsis/wireshark-*.exe\n    expire_in: 3 days\n\nmacOS Arm Package:\n  stage: build\n  rules: !reference [.if-w-w-only-merged]\n  variables:\n    CODE_SIGN_IDENTITY: \"Wireshark Foundation\"\n  tags:\n    - wireshark-macos-arm-package\n  retry: 1\n  script:\n    - export CMAKE_PREFIX_PATH=/usr/local/Qt-$MACOS_QT_VERSION\n    # Not needed for Falco libs 0.19?\n    - export CXXFLAGS=\"-isystem /usr/local/include/falcosecurity\"\n    - export PATH=\"$PATH:$HOME/bin\"\n    - mkdir build\n    - cd build\n    - ../tools/make-version.py --set-release --wireshark-version-file=wireshark_version.txt --stratoshark-version-file=stratoshark_version.txt ..\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -DENABLE_CCACHE=ON -DCMAKE_APPLE_SILICON_PROCESSOR=arm64 -DCMAKE_OSX_DEPLOYMENT_TARGET=11.0 -DCMAKE_OSX_ARCHITECTURES=arm64 -DBUILD_stratoshark=on -DBUILD_sshdig=on -DBUILD_falcodump=on -DFALCO_PLUGINS=/usr/local/lib/falco-plugins/libcloudtrail.so -DTEST_EXTRA_ARGS=--enable-release -G Ninja ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - codesign-prep\n    - security find-identity -v -s \"$CODE_SIGN_IDENTITY\"\n    - ninja wireshark_dmg\n    - ninja stratoshark_dmg\n    - cd run\n    - xcrun notarytool submit Wireshark?[1-9]*.dmg --apple-id \"$MACOS_NOTARIZATION_APPLE_ID\" --team-id \"$MACOS_NOTARIZATION_TEAM_ID\" --password \"$MACOS_NOTARIZATION_PWD\" --wait --timeout 10m\n    - xcrun stapler staple Wireshark?[1-9]*.dmg\n    - xcrun notarytool submit Stratoshark?[0-9]*.dmg --apple-id \"$MACOS_NOTARIZATION_APPLE_ID\" --team-id \"$MACOS_NOTARIZATION_TEAM_ID\" --password \"$MACOS_NOTARIZATION_PWD\" --wait --timeout 10m\n    - xcrun stapler staple Stratoshark?[0-9]*.dmg\n    - spctl --assess --type open --context context:primary-signature --verbose=2 Wireshark?[1-9]*.dmg Stratoshark?[0-9]*.dmg\n    - stat -f \"%N %z bytes\" Wireshark*.dmg Stratoshark*.dmg\n    - for digest in sha512 sha256 sha1 ; do openssl $digest Wireshark*.dmg Stratoshark*.dmg ; done\n    - |\n      if [ -n \"$S3_DESTINATION_MACOS_ARM64\" ] ; then\n        aws s3 cp Wireshark?[1-9]*Arm*.dmg \"$S3_DESTINATION_MACOS_ARM64/\"\n        aws s3 cp Wireshark?dSYM*Arm*.dmg \"$S3_DESTINATION_MACOS_ARM64/\"\n        aws s3 cp Stratoshark?[0-9]*Arm*.dmg \"$S3_DESTINATION_MACOS_ARM64/\"\n        aws s3 cp Stratoshark?dSYM*Arm*.dmg \"$S3_DESTINATION_MACOS_ARM64/\"\n      fi\n    - $CI_PROJECT_DIR/build/run/tshark --version\n    - WIRESHARK_SPARKLE_SIGNATURE=$( age --decrypt --identity=\"$MACOS_AGE_IDENTITY\" \"$MACOS_SPARKLE_BLOB\" | /usr/local/Sparkle-2.2.2/bin/sign_update --ed-key-file - Wireshark?[1-9]*.dmg )\n    - WIRESHARK_DMG_SHA256=$( shasum --algorithm 256 Wireshark?[1-9]*.dmg | awk '{print $1}' )\n    - WIRESHARK_VERSION=$(< ../wireshark_version.txt)\n    - printf '[DEFAULT]\\nsparkle_signature = %s\\ndmg_sha256 = %s\\n' \"$WIRESHARK_SPARKLE_SIGNATURE\" \"$WIRESHARK_DMG_SHA256\" > wireshark-release-info-${WIRESHARK_VERSION}-macos-arm64.ini\n    - STRATOSHARK_SPARKLE_SIGNATURE=$( age --decrypt --identity=\"$MACOS_AGE_IDENTITY\" \"$MACOS_SPARKLE_BLOB\" | /usr/local/Sparkle-2.2.2/bin/sign_update --ed-key-file - Stratoshark?[0-9]*.dmg )\n    - STRATOSHARK_DMG_SHA256=$( shasum --algorithm 256 Stratoshark?[0-9]*.dmg | awk '{print $1}' )\n    - STRATOSHARK_VERSION=$(< ../stratoshark_version.txt)\n    - printf '[DEFAULT]\\nsparkle_signature = %s\\ndmg_sha256 = %s\\n' \"$STRATOSHARK_SPARKLE_SIGNATURE\" \"$STRATOSHARK_DMG_SHA256\" > stratoshark-release-info-${STRATOSHARK_VERSION}-macos-arm64.ini\n    - |\n      if [ -n \"$S3_DESTINATION_RELEASE\" ] ; then\n        aws s3 cp wireshark-release-info-*-macos-*.ini \"$S3_DESTINATION_RELEASE/\"\n        aws s3 cp stratoshark-release-info-*-macos-*.ini \"$S3_DESTINATION_RELEASE/\"\n      fi\n    - cd ..\n    - ninja test\n  artifacts:\n    paths:\n      - build/run/*shark-release-info-*-macos-*.ini\n  needs: []\n\nmacOS Intel Package:\n  stage: build\n  rules: !reference [.if-w-w-only-merged]\n  variables:\n    CODE_SIGN_IDENTITY: \"Wireshark Foundation\"\n  tags:\n    - wireshark-macos-intel-package\n  retry: 1\n  script:\n    - export CMAKE_PREFIX_PATH=/usr/local/Qt-$MACOS_QT_VERSION\n    # Not needed for Falco libs 0.19?\n    - export CXXFLAGS=\"-isystem /usr/local/include/falcosecurity\"\n    - export PATH=\"$PATH:$HOME/bin\"\n    - mkdir build\n    - cd build\n    - ../tools/make-version.py --set-release --wireshark-version-file=wireshark_version.txt --stratoshark-version-file=stratoshark_version.txt ..\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -DENABLE_CCACHE=ON -DCMAKE_OSX_DEPLOYMENT_TARGET=11.0 -DBUILD_stratoshark=on -DBUILD_sshdig=on -DBUILD_falcodump=on -DFALCO_PLUGINS=/usr/local/lib/falco-plugins/libcloudtrail.so -DTEST_EXTRA_ARGS=--enable-release -G Ninja ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - codesign-prep\n    - security find-identity -v -s \"$CODE_SIGN_IDENTITY\"\n    - ninja wireshark_dmg\n    - ninja stratoshark_dmg\n    - cd run\n    - xcrun notarytool submit Wireshark?[1-9]*.dmg --apple-id \"$MACOS_NOTARIZATION_APPLE_ID\" --team-id \"$MACOS_NOTARIZATION_TEAM_ID\" --password \"$MACOS_NOTARIZATION_PWD\" --wait --timeout 10m\n    - xcrun stapler staple Wireshark?[1-9]*.dmg\n    - xcrun notarytool submit Stratoshark?[0-9]*.dmg --apple-id \"$MACOS_NOTARIZATION_APPLE_ID\" --team-id \"$MACOS_NOTARIZATION_TEAM_ID\" --password \"$MACOS_NOTARIZATION_PWD\" --wait --timeout 10m\n    - xcrun stapler staple Stratoshark?[0-9]*.dmg\n    - spctl --assess --type open --context context:primary-signature --verbose=2 Wireshark?[1-9]*.dmg Stratoshark?[0-9]*.dmg\n    - stat -f \"%N %z bytes\" Wireshark*.dmg Stratoshark*.dmg\n    - for digest in sha512 sha256 sha1 ; do openssl $digest Wireshark*.dmg Stratoshark*.dmg ; done\n    - |\n      if [ -n \"$S3_DESTINATION_MACOS_INTEL64\" ] ; then\n        aws s3 cp Wireshark?[1-9]*Intel*.dmg \"$S3_DESTINATION_MACOS_INTEL64/\"\n        aws s3 cp Wireshark?dSYM*Intel*.dmg \"$S3_DESTINATION_MACOS_INTEL64/\"\n        aws s3 cp Stratoshark?[0-9]*Intel*.dmg \"$S3_DESTINATION_MACOS_INTEL64/\"\n        aws s3 cp Stratoshark?dSYM*Intel*.dmg \"$S3_DESTINATION_MACOS_INTEL64/\"\n      fi\n    - $CI_PROJECT_DIR/build/run/tshark --version\n    - WIRESHARK_SPARKLE_SIGNATURE=$( age --decrypt --identity=\"$MACOS_AGE_IDENTITY\" \"$MACOS_SPARKLE_BLOB\" | /usr/local/Sparkle-2.2.2/bin/sign_update --ed-key-file - Wireshark?[1-9]*.dmg )\n    - WIRESHARK_DMG_SHA256=$( shasum --algorithm 256 Wireshark?[1-9]*.dmg | awk '{print $1}' )\n    - WIRESHARK_VERSION=$(< ../wireshark_version.txt)\n    - printf '[DEFAULT]\\nsparkle_signature = %s\\ndmg_sha256 = %s\\n' \"$WIRESHARK_SPARKLE_SIGNATURE\" \"$WIRESHARK_DMG_SHA256\" > wireshark-release-info-${WIRESHARK_VERSION}-macos-intel64.ini\n    - STRATOSHARK_SPARKLE_SIGNATURE=$( age --decrypt --identity=\"$MACOS_AGE_IDENTITY\" \"$MACOS_SPARKLE_BLOB\" | /usr/local/Sparkle-2.2.2/bin/sign_update --ed-key-file - Stratoshark?[0-9]*.dmg )\n    - STRATOSHARK_DMG_SHA256=$( shasum --algorithm 256 Stratoshark?[0-9]*.dmg | awk '{print $1}' )\n    - STRATOSHARK_VERSION=$(< ../stratoshark_version.txt)\n    - printf '[DEFAULT]\\nsparkle_signature = %s\\ndmg_sha256 = %s\\n' \"$STRATOSHARK_SPARKLE_SIGNATURE\" \"$STRATOSHARK_DMG_SHA256\" > stratoshark-release-info-${STRATOSHARK_VERSION}-macos-intel64.ini\n    - |\n      if [ -n \"$S3_DESTINATION_RELEASE\" ] ; then\n        aws s3 cp wireshark-release-info-*-macos-*.ini \"$S3_DESTINATION_RELEASE/\"\n        aws s3 cp stratoshark-release-info-*-macos-*.ini \"$S3_DESTINATION_RELEASE/\"\n      fi\n    - cd ..\n    - ninja test\n  artifacts:\n    paths:\n      - build/run/*shark-release-info-*-macos-*.ini\n  needs: []\n\n# Build the User's Guide and Developer's Guide\nDocumentation:\n  extends: .build-linux\n  image: registry.gitlab.com/wireshark/wireshark-containers/ubuntu-dev\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"push\" && $CI_COMMIT_BRANCH == \"master\" && $CI_PROJECT_URL =~ /.*gitlab.com\\/wireshark\\/wireshark/'\n      changes:\n        - \"doc/**/*\"\n        - \"epan/wslua/**/*\"\n    - if: '$CI_PIPELINE_SOURCE == \"push\"'\n      when: manual\n      allow_failure: true\n  script:\n    # XXX We might want to move this to wireshark-ubuntu-dev or debian-setup.sh.\n    - DEBIAN_FRONTEND=noninteractive apt-get update\n    - DEBIAN_FRONTEND=noninteractive apt-get --yes install ruby-asciidoctor-pdf ruby-coderay ruby-dev\n    - NOKOGIRI_USE_SYSTEM_LIBRARIES=1 gem install asciidoctor-epub3\n    - mkdir build\n    - cd build\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -GNinja ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja all_guides\n    - cd doc\n    - for HTML_DIR in ws[ud]g_html{,_chunked} ; do zip -9 -r \"$HTML_DIR.zip\" \"$HTML_DIR\" ; done\n    - if [ -n \"$MC_DESTINATION_DOCS\" ] ; then mc --quiet cp ws[ud]g_html{,_chunked}.zip Wireshark*Guide.{epub,pdf} \"$MC_DESTINATION_DOCS/\" ; fi\n    - mv -v ws[ud]g_html{,_chunked}.zip Wireshark*Guide.{epub,pdf} ../..\n  after_script:\n    - if [ \"$CI_JOB_STATUS\" != \"success\" ]; then exit 0 ; fi\n  artifacts:\n    paths:\n      - wsug_html.zip\n      - wsug_html_chunked.zip\n      - wsdg_html.zip\n      - wsdg_html_chunked.zip\n      - \"Wireshark User's Guide.pdf\"\n      - \"Wireshark Developer's Guide.pdf\"\n      - \"Wireshark User's Guide.epub\"\n      - \"Wireshark Developer's Guide.epub\"\n  needs: []\n\n\n# https://docs.gitlab.com/ee/user/gitlab_com/index.html#linux-shared-runners\n\nCommit Check:\n  extends: .build-ubuntu\n  rules: !reference [.if-merge-request]\n  script:\n    # build-ubuntu puts us in `build`.\n    - cd ..\n    - git status\n    # We have the following options for displaying information in a merge request\n    # from a pipleline job:\n    #\n    # - The Notes API, which requires a valid GitLab CI_JOB_TOKEN variable, which\n    #   isn't available for outside projects:\n    #   https://gitlab.com/gitlab-org/gitlab/-/issues/464591.\n    #\n    # - Code Quality, which requires extra configuration, using a special container\n    #   image, and writing a custom plugin:\n    #   https://docs.gitlab.com/ee/ci/testing/code_quality.html.\n    #\n    # - Unit test reports, which must be formatted as JUnit XML:\n    #   https://docs.gitlab.com/ee/ci/testing/unit_test_reports.html\n    #   https://www.ibm.com/docs/en/developer-for-zos/14.2?topic=formats-junit-xml-format\n    #\n    # Let's generate a unit test report using tools/wrap-ci-test.py.\n    - REPORT_FILE=commit_checks.xml\n    - TEST_SUITE=commit_checks\n    - EXIT_CODE=0\n    - ./tools/wrap-ci-test.py --file $REPORT_FILE --suite $TEST_SUITE --case num_commits --command \"[ $NUM_COMMITS -lt 2 ] || (echo 'ℹ️ This merge request has more than one commit. Please squash any trivial ones:\\n'; git log --oneline --no-decorate --max-count=$NUM_COMMITS ; false)\" || true\n    - ./tools/wrap-ci-test.py --file $REPORT_FILE --suite $TEST_SUITE --case tools/pre-commit ./tools/pre-commit $( git log --max-count=$NUM_COMMITS --pretty=format:%h ) || EXIT_CODE=1\n    - ./tools/wrap-ci-test.py --file $REPORT_FILE --suite $TEST_SUITE --case tools/validate-commit ./tools/validate-commit.py $( git log --max-count=$NUM_COMMITS --pretty=format:%h ) || EXIT_CODE=1\n    - ./tools/wrap-ci-test.py --file $REPORT_FILE --suite $TEST_SUITE --case tools/checklicenses ./tools/checklicenses.py || EXIT_CODE=1\n    - ./tools/wrap-ci-test.py --file $REPORT_FILE --suite $TEST_SUITE --case tools/check_help_urls ./tools/check_help_urls.py || EXIT_CODE=1\n    - exit $EXIT_CODE\n  artifacts:\n    when: always\n    paths:\n      - commit_checks.xml\n    reports:\n      junit: commit_checks.xml\n\nUbuntu GCC Build:\n  extends: .build-ubuntu\n  rules: !reference [.if-merge-request]\n  variables:\n    CC: \"gcc\"\n    CXX: \"g++\"\n  needs: [ 'Commit Check' ]\n  script:\n    - source /gcc-latest.env\n    # build-ubuntu puts us in `build`.\n    - cd ..\n    - mv build \"🦈 build 🦈\"\n    - cd \"🦈 build 🦈\"\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    # Test release build.\n    - cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DENABLE_CCACHE=ON -DENABLE_WERROR=ON -DCMAKE_EXPORT_COMPILE_COMMANDS=on ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - script --command ninja --flush --quiet --return ../gcc_report.txt\n    - ansi2html < ../gcc_report.txt > ../gcc_report.html\n    - ninja test-programs\n    - chown -R user .\n    - if [ -f run/dumpcap ]; then setcap cap_net_raw,cap_net_admin+eip run/dumpcap; fi\n    - if [ -f run/dumpcap ]; then su user -c \"run/dumpcap -D\" ; fi\n    - su user -c \"pytest-3 --junitxml=../ubuntu_tests.xml\"\n    # Test CMake install code and CPack config code. Select any one of the archive generators.\n    - ninja user_guide_html\n    - ninja developer_guide_html\n    - cpack -G TZST .\n    - ls wireshark-*.tar.zst{,.sha256}\n  artifacts:\n    when: always\n    paths:\n      - gcc_report.html\n    reports:\n      junit: ubuntu_tests.xml\n\nUbuntu Qt5 Build:\n  extends: .build-ubuntu\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n      interruptible: true\n      changes:\n        - \"ui/**/*\"\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n      when: manual\n      allow_failure: true\n  needs: [ 'Commit Check' ]\n  script:\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja -DENABLE_CCACHE=ON -DENABLE_WERROR=ON -DUSE_qt6=OFF ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - run/wireshark -v\n\nFedora MinGW Build:\n  extends: .build-mingw\n  rules: !reference [.if-merge-request]\n  needs: [ 'Commit Check' ]\n\nClang + Code Checks:\n  extends: .build-ubuntu\n  tags:\n    - saas-linux-medium-amd64\n  rules: !reference [.if-merge-request]\n  needs: [ 'Commit Check' ]\n  script:\n    - source /clang-latest.env\n    - apt-get update && apt-get --yes install python3-venv\n    - python3 -m venv $CI_PROJECT_DIR/.venv\n    - source $CI_PROJECT_DIR/.venv/bin/activate\n    # build-ubuntu puts us in `build`.\n    - cd ..\n    - mkdir cppcheck\n    - ./tools/cppcheck/cppcheck.sh -l $NUM_COMMITS | tee cppcheck/cppcheck_report.txt\n    - if [[ -s \"cppcheck/cppcheck_report.txt\" ]]; then ./tools/cppcheck/cppcheck.sh -l $NUM_COMMITS -x > cppcheck/cppcheck_report.xml ; fi\n    - if [[ -s \"cppcheck/cppcheck_report.txt\" ]]; then cppcheck-htmlreport --file cppcheck/cppcheck_report.xml  --report-dir cppcheck ; fi\n    - cd build\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    # We don't have an \"All options\" job, so build fuzzshark and tfshark here.\n    - cmake -DENABLE_CHECKHF_CONFLICT=on -DCMAKE_EXPORT_COMPILE_COMMANDS=on -DCMAKE_C_CLANG_TIDY=clang-tidy-$CLANG_VERSION -DCMAKE_CXX_CLANG_TIDY=clang-tidy-$CLANG_VERSION -DBUILD_fuzzshark=ON -DBUILD_tfshark=On -DBUILD_stratoshark=ON -DENABLE_DEBUG=ON -DENABLE_CCACHE=ON -DENABLE_WERROR=ON -G Ninja ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - printf \"\\e[0Ksection_start:%s:asn1_section[collapsed=false]\\r\\e[0KRegenerating ASN.1 dissectors\" \"$( date +%s)\"\n    - ninja --quiet asn1\n    - git diff --exit-code ${CI_COMMIT_SHA} ..\n    - printf \"\\e[0Ksection_end:%s:asn1_section\\r\\e[0K\" \"$( date +%s)\"\n    - printf \"\\e[0Ksection_start:%s:pidl_section[collapsed=true]\\r\\e[0KRegenerating PIDL dissectors\" \"$( date +%s)\"\n    - ninja pidl-dissectors\n    - ninja idl2wrs-dissectors\n    - git diff --exit-code ${CI_COMMIT_SHA} ..\n    - printf \"\\e[0Ksection_end:%s:pidl_section\\r\\e[0K\" \"$( date +%s)\"\n    - mkdir ../html\n    - script --command ninja --flush --quiet --return ../tmp_clang_report.txt\n    - ansi2txt < ../tmp_clang_report.txt > ../clang_report.txt\n    - ansi2html < ../tmp_clang_report.txt > ../html/clang_report.html\n    - ./run/tshark -v 2> >(tee ../checkhf_conflict.txt)\n    - ../tools/validate-clang-check.sh -c $CLANG_VERSION 2> >(tee ../tmp_clang_analyzer_check.txt)\n    - ansi2txt < ../tmp_clang_analyzer_check.txt > ../clang_analyzer_check.txt\n    - ansi2html < ../tmp_clang_analyzer_check.txt > ../html/clang_analyzer_check.html\n    - ninja checkAPI\n    - ninja shellcheck\n    - cd ..\n    - pip3 install pyspellchecker\n    - ./tools/check_spelling.py --no-wikipedia --comments --commits $NUM_COMMITS | tee spelling_check.txt\n    - ./tools/check_typed_item_calls.py --consecutive --label --mask --check-bitmask-fields --commits $NUM_COMMITS | tee item_calls_check.txt\n    - ./tools/check_tfs.py --check-value-strings --commits $NUM_COMMITS | tee tfs_check.txt\n    - ./tools/check_val_to_str.py --commits $NUM_COMMITS | tee val_to_str_check.txt\n    - ./tools/check_col_apis.py --commits $NUM_COMMITS | tee col_apis_check.txt\n  artifacts:\n    paths:\n      - clang_report.txt\n      - clang_analyzer_check.txt\n      - cppcheck\n      - spelling_check.txt\n      - item_calls_check.txt\n      - tfs_check.txt\n      - val_to_str_check.txt\n      - col_apis_check.txt\n      - checkhf_conflict.txt\n      - html/\n\nNo options:\n  extends: .build-ubuntu\n  rules: !reference [.if-merge-request]\n  needs: [ 'Commit Check' ]\n  script: |\n    cmake -GNinja -DENABLE_CCACHE=ON \\\n      -DENABLE_BROTLI=OFF -DENABLE_CAP=OFF -DENABLE_CHECKHF_CONFLICT=ON -DENABLE_GNUTLS=OFF \\\n      -DENABLE_KERBEROS=OFF -DENABLE_LIBXML2=OFF -DENABLE_ILBC=OFF -DENABLE_LUA=OFF -DENABLE_LZ4=OFF \\\n      -DENABLE_MINIZIP=OFF -DENABLE_NETLINK=OFF -DENABLE_NGHTTP2=OFF -DENABLE_NGHTTP3=OFF \\\n      -DENABLE_BCG729=OFF -DENABLE_OPUS=OFF -DENABLE_PCAP=OFF -DENABLE_PLUGIN_IFDEMO=ON \\\n      -DENABLE_PLUGINS=OFF -DENABLE_SBC=OFF -DENABLE_SMI=OFF -DENABLE_SNAPPY=OFF -DENABLE_SPANDSP=OFF \\\n      -DENABLE_ZLIB=OFF -DENABLE_ZSTD=OFF -DBUILD_mmdbresolve=OFF ..\n    ninja\n\n# Windows runners are still beta, at least technically:\n# https://docs.gitlab.com/ee/user/gitlab_com/index.html#windows-shared-runners-beta\nWindows Build:\n  extends: .build-windows\n  rules: !reference [.if-w-w-only-merge-request]\n  tags:\n    - wireshark-windows-merge-req\n  needs: [ 'Commit Check' ]\n  script:\n    # lib{sinsp,scap} don't support Configuration=Debug, so we can't enable\n    # BUILD_stratoshark or BUILD_falcodump here just yet.\n    - cmake -G \"Visual Studio 17 2022\" -A x64 -DENABLE_LTO=off ..\n    - msbuild /verbosity:minimal /maxcpucount /property:Configuration=Debug Wireshark.sln\n    - msbuild /verbosity:minimal /maxcpucount /property:Configuration=Debug test-programs.vcxproj\n    - C:\\Windows\\py.exe -m pytest --disable-gui --build-type=Debug --junitxml=../windows_tests.xml\n  artifacts:\n    when: always\n    reports:\n      junit: windows_tests.xml\n\nmacOS Build:\n  extends: .build-macos\n  rules: !reference [.if-w-w-only-merge-request]\n  script:\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DENABLE_CCACHE=ON -DTEST_EXTRA_ARGS=--disable-capture ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - ninja test-programs\n    - pytest --disable-capture --junitxml=../macos_tests.xml\n  artifacts:\n    when: always\n    reports:\n      junit: macos_tests.xml\n  needs: [ 'Commit Check' ]\n\n# Adapted from https://www.synopsys.com/blogs/software-security/integrating-coverity-scan-with-gitlab-ci/\n# and https://gitlab.gnome.org/GNOME/glib/-/blob/8f57a5b9/.gitlab-ci.yml#L481\nCoverity GCC Scan:\n  image: registry.gitlab.com/wireshark/wireshark-containers/ubuntu-dev\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"schedule\" && $SCHEDULE_TYPE == \"coverity-gcc\"'\n  stage: analysis\n  needs: []\n  variables:\n    CC: gcc\n    CXX: g++\n    # cov-build doesn’t handle GLIB_DEPRECATED_ENUMERATOR\n    CFLAGS: '-DGLIB_DISABLE_DEPRECATION_WARNINGS'\n    CXXFLAGS: '-DGLIB_DISABLE_DEPRECATION_WARNINGS'\n  script:\n    - curl --output /tmp/cov-analysis-linux64.tar.gz --form project=$COVERITY_SCAN_PROJECT_NAME --form token=$COVERITY_SCAN_TOKEN https://scan.coverity.com/download/linux64\n    - tar --directory=/tmp --extract --gzip --file /tmp/cov-analysis-linux64.tar.gz\n    - mkdir build\n    - cd build\n    - cmake -G Ninja ..\n    - /tmp/cov-analysis-linux64-*/bin/cov-build --return-emit-failures --dir ../cov-int ninja\n    - cd ..\n    - tar --create --gzip --file cov-int.tar.gz cov-int\n    - echo \"export ARTIFACT_JOB_URL=$CI_JOB_URL\" > job_environment_variables.sh\n    - echo \"export GIT_DESCRIPTION=$( git describe --tags --match \"v[1-9]*\" )\" >> job_environment_variables.sh\n  artifacts:\n    paths:\n      - cov-int.tar.gz\n      - job_environment_variables.sh\n\nCoverity GCC Submit:\n  image: curlimages/curl\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"schedule\" && $SCHEDULE_TYPE == \"coverity-gcc\"'\n  stage: .post\n  script:\n    - . job_environment_variables.sh\n    - echo $ARTIFACT_JOB_URL\n    - echo $GIT_DESCRIPTION\n    - curl --fail --data \"project=$COVERITY_SCAN_PROJECT_NAME&token=$COVERITY_SCAN_TOKEN&email=$GITLAB_USER_EMAIL&url=$ARTIFACT_JOB_URL/artifacts/raw/cov-int.tar.gz&version=$GIT_DESCRIPTION&description=Ubuntu $GIT_DESCRIPTION $CI_COMMIT_REF_NAME:$CI_PIPELINE_ID\" https://scan.coverity.com/builds\n  needs: [ 'Coverity GCC Scan' ]\n\nCoverity Visual C++ Scan:\n  extends: .build-windows\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"schedule\" && $SCHEDULE_TYPE == \"coverity-visual-c++\"'\n  tags:\n    - wireshark-windows-merge-req\n  stage: analysis\n  needs: []\n  script:\n    - $gitDescription = (( git describe --tags ) | Out-String).Trim()\n    - C:\\Windows\\System32\\curl --output $env:temp\\cov-analysis-win64.zip --form project=$COVERITY_SCAN_PROJECT_NAME --form token=$COVERITY_SCAN_TOKEN https://scan.coverity.com/download/win64\n    - C:\\ProgramData\\chocolatey\\tools\\7z x \"$env:temp\\cov-analysis-win64.zip\" -y -r -o\"$env:temp\"\n    - cmake -DTEST_EXTRA_ARGS=--enable-release -DENABLE_LTO=off -G \"Visual Studio 17 2022\" -A x64 ..\n    - $covAnalysisWin64 = (Get-ChildItem -Path $env:temp -Filter \"cov-analysis-win64-*\" -Directory)[0].FullName\n    - Invoke-Expression \"& $covAnalysisWin64\\bin\\cov-build.exe --return-emit-failures --dir ..\\cov-int msbuild /verbosity:minimal `\"/consoleloggerparameters:PerformanceSummary;NoSummary`\" /maxcpucount:1 Wireshark.sln\"\n    - cd ..\n    - C:\\ProgramData\\chocolatey\\tools\\7z a -tzip cov-int.zip cov-int\n    - '\"export ARTIFACT_JOB_URL=$env:CI_JOB_URL\" | Out-File -Encoding ascii job_environment_variables.sh'\n    - '\"export GIT_DESCRIPTION=$gitDescription\" | Out-File -Encoding ascii -Append job_environment_variables.sh'\n  artifacts:\n    paths:\n      - cov-int.zip\n      - job_environment_variables.sh\n\nCoverity Visual C++ Submit:\n  image: curlimages/curl\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"schedule\" && $SCHEDULE_TYPE == \"coverity-visual-c++\"'\n  stage: .post\n  script:\n    - sed -i -e 's/\\r//' job_environment_variables.sh\n    - . job_environment_variables.sh\n    - echo $ARTIFACT_JOB_URL\n    - echo $GIT_DESCRIPTION\n    - curl --fail --data \"project=$COVERITY_SCAN_PROJECT_NAME&token=$COVERITY_SCAN_TOKEN&email=$GITLAB_USER_EMAIL&url=$ARTIFACT_JOB_URL/artifacts/raw/cov-int.zip&version=$GIT_DESCRIPTION&description=Windows $GIT_DESCRIPTION $CI_COMMIT_REF_NAME:$CI_PIPELINE_ID\" https://scan.coverity.com/builds\n  needs: [ 'Coverity Visual C++ Scan' ]\n\nClang Static Analyzer:\n  extends: .build-ubuntu\n  rules: !reference [.if-daily-schedule]\n  stage: analysis\n  needs: []\n  script:\n    - source /clang-latest.env\n    - scan-build-${CLANG_VERSION} --exclude tools cmake -DCMAKE_BUILD_TYPE=Debug -DENABLE_WERROR=OFF -G Ninja ..\n    - scan-build-${CLANG_VERSION} --exclude tools -o ../sbout ninja\n    - cd ../sbout\n    - RAW_DIR=$( find ../sbout -type d -name \"20??-??-??-*\" -printf \"%P\\n\" | head )\n    - SB_DIR=\"scan-build-$RAW_DIR\"\n    - mv \"$RAW_DIR\" \"$SB_DIR\"\n    - if [ -d logs ] ; then mv logs $SB_DIR ; fi\n    - chmod -R u=rwX,go=rX \"$SB_DIR\"\n    - zip -9 -r \"${SB_DIR}.zip\" \"$SB_DIR\"\n    - if [ -n \"$MC_DESTINATION_ANALYSIS\" ] ; then mc --quiet cp \"${SB_DIR}.zip\" \"$MC_DESTINATION_ANALYSIS/\" ; fi\n\n# Windows runners are still beta, at least technically:\n# https://docs.gitlab.com/ee/user/gitlab_com/index.html#windows-shared-runners-beta\nVisual Studio Code Analysis:\n  extends: .build-windows\n  tags:\n    - wireshark-windows-dev\n  rules:\n    # The wireshark-windows-* tags are only available in wireshark/wireshark.\n    - if: '$CI_PIPELINE_SOURCE == \"schedule\" && $SCHEDULE_TYPE == \"daily\" && $CI_PROJECT_URL =~ /.*gitlab.com\\/wireshark\\/wireshark/'\n  script:\n    - py -m venv sarif-tools.venv\n    - sarif-tools.venv\\Scripts\\pip.exe install sarif-tools\n    - New-Item -Path C:\\MinIO -Type \"directory\"\n    - Invoke-Webrequest -OutFile C:\\MinIO\\mc.exe https://dl.min.io/client/mc/release/windows-amd64/archive/mc.RELEASE.2024-07-03T20-17-25Z\n    - if ($( Get-FileHash -Algorithm SHA256 -Path C:\\MinIO\\mc.exe ).Hash -ne \"A379139FB32C0ADDB6C05786782602B5106D13402759AC1B4A88285A4D5EAAD3\" ) { Exit 1 }\n    - $env:caexcludepath = \"C:\\Qt;$env:INCLUDE\"\n    - cmake -DENABLE_CODE_ANALYSIS=ON -G \"Visual Studio 17 2022\" -A x64 -DENABLE_LTO=off ..\n    - msbuild /verbosity:minimal \"/consoleloggerparameters:PerformanceSummary;NoSummary\" /maxcpucount:2 Wireshark.sln\n    - $report = \"visual-c++-analyze-\" + (Get-Date -format \"yyyy-MM-dd\") + \".html\"\n    - sarif-tools.venv\\Scripts\\sarif html --output $report\n    - if (Test-Path env:MC_DESTINATION_ANALYSIS) { C:\\MinIO\\mc --quiet cp \"$report\" \"$env:MC_DESTINATION_ANALYSIS/\" }\n\n# Build all doxygen docs\nAPI Reference:\n  extends: .build-ubuntu\n  rules: !reference [.if-daily-schedule]\n  script:\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -GNinja ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja wsar_html_zip 2>&1 > doxygen_output.txt | tee doxygen_errors.txt\n    - mv wsar_html.zip doxygen_{output,errors}.txt ..\n    - cd ..\n    - if [ -n \"$MC_DESTINATION_DOCS\" ] ; then mc --quiet cp wsar_html.zip \"$MC_DESTINATION_DOCS/\" ; fi\n  after_script:\n    - if [ \"$CI_JOB_STATUS\" != \"success\" ]; then exit 0 ; fi\n  artifacts:\n    paths:\n    - doxygen_errors.txt\n    - doxygen_output.txt\n    - wsar_html.zip\n  needs: []\n\nCode Lines and Data:\n  extends: .build-ubuntu\n  rules: !reference [.if-daily-schedule]\n  stage: analysis\n  variables:\n    CLOC_OUT: /tmp/cloc.txt\n    SCC_OUT: /tmp/scc.txt\n    SLOC_OUT: /tmp/sloccount.txt\n    TOKEI_OUT: /tmp/tokei.txt\n  script:\n    - DEBIAN_FRONTEND=noninteractive apt-get update\n    - DEBIAN_FRONTEND=noninteractive apt-get --yes install sloccount cloc curl unzip\n    - pushd /tmp\n    - curl -L -O https://github.com/boyter/scc/releases/download/v3.0.0/scc-3.0.0-x86_64-unknown-linux.zip\n    - unzip scc-3.0.0-x86_64-unknown-linux.zip\n    - curl -L -O https://github.com/XAMPPRocky/tokei/releases/download/v12.1.2/tokei-x86_64-unknown-linux-gnu.tar.gz\n    - tar -xf tokei-x86_64-unknown-linux-gnu.tar.gz\n    - popd\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - cd ..\n    - echo -n \"cloc version:\\ \"\n    - cloc --version\n    - cloc --quiet . | tee $CLOC_OUT\n    - /tmp/scc --version\n    - /tmp/scc --not-match 'qt/.*.ts' . | tee $SCC_OUT\n    - echo -n \"SLOCCount version:\\ \"\n    - sloccount --version\n    - sloccount . | awk \"/^Computing results/ { results=1 } { if (results) print }\" | tee $SLOC_OUT\n    - /tmp/tokei --version\n    - /tmp/tokei --exclude 'qt/*.ts' . | tee $TOKEI_OUT\n    - |\n      cat > manuf <<FIN\n      # This file was generated by TShark $(git describe --tags | sed -e 's/^v//') with the\n      # command \\`tshark -G manuf\\`. Its canonical location is\n      #\n      # https://www.wireshark.org/download/automated/data/manuf.gz\n      #\n      # The first column contains the MAC address block (24, 28 or 36 bits wide,\n      # per IEEE allocation sizes), the second column contains the shortened name\n      # used by Wireshark for address name resolution and the third column contains the\n      # full vendor name from the registry.\n      #\n      FIN\n    - build/run/tshark -G manuf | sed -e 's,:00:00:00/24,,' >> manuf\n    - gzip --best --keep manuf\n    - if [ -n \"$MC_DESTINATION_ANALYSIS\" ] ; then mc --quiet cp \"$CLOC_OUT\" \"$SCC_OUT\" \"$SLOC_OUT\" \"$TOKEI_OUT\" \"$MC_DESTINATION_ANALYSIS/\" ; fi\n    - if [ -n \"$MC_DESTINATION_DATA\" ] ; then mc --quiet cp manuf manuf.gz \"$MC_DESTINATION_DATA/\" ; fi\n  artifacts:\n    paths:\n    - manuf\n    - manuf.gz\n  needs: []\n\n# Fuzz TShark using ASAN and valgrind.\n.fuzz-ubuntu:\n  extends: .build-ubuntu\n  retry: 0\n  rules: !reference [.if-fuzz-schedule]\n  tags:\n    - wireshark-ubuntu-fuzz\n  resource_group: fuzz-master\n  variables:\n    INSTALL_PREFIX: \"$CI_PROJECT_DIR/_install\"\n    MIN_PLUGINS: 10\n    MAX_PASSES: 15\n  before_script:\n    - source /clang-latest.env\n    - DEBIAN_FRONTEND=noninteractive apt-get update\n    # Use DPkg::options::=\"--force-overwrite\" until\n    # https://bugs.launchpad.net/ubuntu/+source/llvm-toolchain-15/+bug/2008755\n    # https://github.com/llvm/llvm-project/issues/62104\n    # are fixed.\n    - DEBIAN_FRONTEND=noninteractive apt-get --yes --option DPkg::options::=\"--force-overwrite\" install llvm-$CLANG_VERSION\n    - mkdir -p ccache\n    - mkdir /tmp/fuzz\n    - mkdir build\n    - cd build\n  after_script:\n    # The cache should be large enough to be useful but it shouldn't take\n    # too long to restore+save each run.\n    - ccache --max-size $( du --summarize --block-size=1M \"$CI_PROJECT_DIR/build\" | awk '{printf (\"%dM\", $1 * 1.5)}' )\n    - if [ \"$CI_JOB_STATUS\" == \"canceled\" ]; then exit 0 ; fi\n    - . /tmp/fuzz_result.sh\n    - if $FUZZ_PASSED ; then exit 0 ; fi\n    - echo Fuzzing failed. Generating report.\n    - FUZZ_CAPTURE=$( find /tmp/fuzz -name \"fuzz-*.pcap\" -o -name \"randpkt-*.pcap\" | head -n 1 )\n    - FUZZ_ERRORS=\"/tmp/fuzz/$( basename \"$FUZZ_CAPTURE\" .pcap ).err\"\n    - printf \"\\nfuzz-test.sh stderr:\\n\" >> \"$FUZZ_ERRORS\"\n    - cat fuzz-test.err >> \"$FUZZ_ERRORS\"\n    - if [ -n \"$MC_DESTINATION_FUZZ\" ] ; then mc --quiet cp \"$FUZZ_CAPTURE\" \"$FUZZ_ERRORS\" \"$MC_DESTINATION_FUZZ/\" ; fi\n\nASan Menagerie Fuzz:\n  extends: .fuzz-ubuntu\n  stage: fuzz-asan\n  variables:\n    WIRESHARK_LOG_FATAL: \"critical\"\n  script:\n    - MAX_SECONDS=$(( 6 * 60 * 60 ))\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja -DBUILD_wireshark=OFF -DCMAKE_BUILD_TYPE=Debug -DENABLE_ASAN=ON -DCMAKE_INSTALL_PREFIX=$INSTALL_PREFIX -DENABLE_CCACHE=ON -DENABLE_WERROR=Off ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - ninja install\n    - cd ..\n    - FUZZ_PASSED=true\n    # /var/menagerie contains captures harvested from wireshark.org's mailing list, wiki, issues, etc.\n    # We have more captures than we can fuzz in $MAX_SECONDS, so we shuffle them each run.\n    - ./tools/fuzz-test.sh -a -2 -P $MIN_PLUGINS -b $INSTALL_PREFIX/bin -d /tmp/fuzz -t $MAX_SECONDS $( shuf -e /var/menagerie/*/* ) 2> fuzz-test.err || FUZZ_PASSED=false\n    # Signal after_script, which runs in its own shell.\n    - echo \"export FUZZ_PASSED=$FUZZ_PASSED\" > /tmp/fuzz_result.sh\n    - $FUZZ_PASSED\n\nASan randpkt Fuzz:\n  extends: .fuzz-ubuntu\n  stage: fuzz-randpkt\n  variables:\n    WIRESHARK_LOG_FATAL: \"critical\"\n  script:\n    # XXX Reuse fuzz-asan?\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja -DBUILD_wireshark=OFF -DCMAKE_BUILD_TYPE=Debug -DENABLE_ASAN=ON -DCMAKE_INSTALL_PREFIX=$INSTALL_PREFIX -DENABLE_CCACHE=ON -DENABLE_WERROR=Off ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - ninja install\n    - cd ..\n    - FUZZ_PASSED=true\n    - ./tools/randpkt-test.sh -a -b $INSTALL_PREFIX/bin -d /tmp/fuzz -p $MAX_PASSES 2> fuzz-test.err || FUZZ_PASSED=false\n    - echo \"export FUZZ_PASSED=$FUZZ_PASSED\" > /tmp/fuzz_result.sh\n    - $FUZZ_PASSED\n  needs: [ 'ASan Menagerie Fuzz' ]\n\nValgrind Menagerie Fuzz:\n  extends: .fuzz-ubuntu\n  stage: fuzz-valgrind\n  resource_group: fuzz-master-valgrind\n  variables:\n    # Use DWARF-4 debug info. Valgrind does not support Clang 14 with DWARF-5.\n    # https://gitlab.com/wireshark/wireshark/-/issues/18191\n    # https://www.mail-archive.com/valgrind-users@lists.sourceforge.net/msg07239.html\n    CFLAGS: \"-gdwarf-4\"\n    WIRESHARK_LOG_FATAL: \"critical\"\n  script:\n    - DEBIAN_FRONTEND=noninteractive apt-get update\n    - DEBIAN_FRONTEND=noninteractive apt-get --yes install valgrind\n    - MAX_SECONDS=$(( 3 * 60 * 60 ))\n    - printf \"\\e[0Ksection_start:%s:cmake_section[collapsed=true]\\r\\e[0KRunning CMake\" \"$( date +%s)\"\n    - cmake -G Ninja -DBUILD_wireshark=OFF -DCMAKE_BUILD_TYPE=Debug -DENABLE_ASAN=OFF -DCMAKE_INSTALL_PREFIX=$INSTALL_PREFIX -DENABLE_CCACHE=ON -DENABLE_WERROR=Off ..\n    - printf \"\\e[0Ksection_end:%s:cmake_section\\r\\e[0K\" \"$( date +%s)\"\n    - ninja\n    - ninja install\n    - cd ..\n    - FUZZ_PASSED=true\n    - ./tools/fuzz-test.sh -g -P $MIN_PLUGINS -b $INSTALL_PREFIX/bin -d /tmp/fuzz -t $MAX_SECONDS $( shuf -e /var/menagerie/*/* ) 2> fuzz-test.err || FUZZ_PASSED=false\n    - echo \"export FUZZ_PASSED=$FUZZ_PASSED\" > /tmp/fuzz_result.sh\n    - $FUZZ_PASSED\n  needs: [ 'ASan randpkt Fuzz' ]\n\n\ninclude:\n  - template: Security/SAST.gitlab-ci.yml\n"
        },
        {
          "name": ".gitlab",
          "type": "tree",
          "content": null
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 18.814453125,
          "content": "Adam Parker <foreverska@protonmail.com>  foreverska <foreverska@protonmail.com>\nAdrian Simionov <daniel.simionov@gmail.com> <daniel.simionov@gmail.com>\nAhmad Fatoum <ahmad@a3f.at> Ahmad Fatoum <ahmad.fatoum@siemens.com>\nAlan Partis <alpartis@thundernet.com> alpartis <alpartis@thundernet.com>\nAlbert Chuang <achuang@wi-fi.org> WFA-achuang <achuang@wi-fi.org>\nAlexander Gärtner <sphinxs1988@googlemail.com> alage <sphinxs1988@googlemail.com>\nAlexander Wetzel <alexander.wetzel@web.de> deagol\nAlexandr Savca <alexandr.savca89@gmail.com> Alexandr Savca <s.alex08@mail.ru>\nAlexandr Savca <alexandr.savca89@gmail.com> chinarulezzz <alexandr.savca89@gmail.com>\nAlexandr Savca <alexandr.savca89@gmail.com> chinarulezzz <s.alex08@mail.ru>\nAlex Sirr <alexsirruw@gmail.com> alexsirr <alexsirruw@gmail.com>\nAnders Broman <a.broman58@gmail.com> <a.broman58@gmail.com>\nAnders Broman <a.broman58@gmail.com> <a.broman@bredband.net>\nAnders Broman <a.broman58@gmail.com> <anders.broman@ericsson.com>\nAndreas Karlsson <se.nakarlsson@gmail.com> nakarlsson <se.nakarlsson@gmail.com>\nAndreas Schultz <andreas.schultz@travelping.com> Andreas Schultz <aschultz@warp10.net>\nAndrew Shultzabarger <andrew@ardnew.com> ardnew <andrew@ardnew.com>\nAndrey Tverd <andr.tverd@gmail.com> Andrey <andr.tverd@gmail.com>\nAndy Ling <andy.ling@s-a-m.com> AndyL <andy.ling@s-a-m.com>\nAnil Kumar K K <anilkumar911@gmail.com> anilkumar911 <anilkumar911@gmail.com>\nAnish <anish@chelsio.com> Anish Bhatt <anish@gatech.edu>\nAntony Bridle <ant.bridle@gmail.com> antony.bridle <ant.bridle@gmail.com>\nBalint Reczey <balint@balintreczey.hu> Balint Reczey <balint.reczey@canonical.com>\nBalint Reczey <balint@balintreczey.hu> <balint.reczey@ericsson.com>\nBartolo Otrit <bartolootrit@gmail.com> bartolootrit <bartolootrit@code.wireshark.org>\nBaşak Kalfa <basakkalfa@gmail.com> basakkal <basakkalfa@gmail.com>\nBaşak Kalfa <basakkalfa@gmail.com> <basakkalfa@gmail.com>\nBoris Bochkarev <Boris-Bochkaryov@yandex.ru> boris.bochkarev <Boris-Bochkaryov@yandex.ru>\nBrian Whitney <brian.m.whitney@outlook.com> bwhitn <brian.m.whitney@outlook.com>\nCal Turney <cturney111@gmail.com> Cal Turney <cal.turney@emc.com>\nCal Turney <cturney111@gmail.com> Cal Turney <cturney@charter.net>\nCal Turney <cturney111@gmail.com> cturney <cturney@charter.net>\nCamille Guerin <guerincamille56@gmail.com> cacamille3 <guerincamille56@gmail.com>\nCarlos Pignataro <cpignata@gmail.com> Carlos Pignataro <cpignata@cisco.com> \nCedric Izoard <cedric.izoard@ceva-dsp.com> Cedric Izoard <cedric.izoard@rivierawaves.com>\nChaoyong Zhou <bgnvendor@163.com> chaoyongzhou <bgnvendor@163.com>\nChris Bontje <cbontje@gmail.com> cbontje <cbontje@gmail.com>\nChris Bontje <cbontje@gmail.com> chrisbontje <cbontje@gmail.com>\nChris Brandson <chris.brandson@gmail.com> Chris Brandson <cjb@exegin.com>\nChris Dunlop <chris.dunlop3@gmail.com> cjdunlop\nChris Maynard <Christopher.Maynard@GTECH.COM> <Christopher.Maynard@igt.com>\nChristian M. Amsüss <chrysn@fsfe.org> chrysn <chrysn@fsfe.org>\nChristophe Guerber <christophe.guerber[AT]enac.fr> Christophe GUERBER <christophe.guerber[AT]gmail.com>\nChristophe Guerber <christophe.guerber@gmail.com Christophe GUERBER <christophe.guerber@gmail.com>\nChristoph Jähnigen <nuabaranda@web.de> desolat <nuabaranda@web.de>\nChristoph Schlosser <christoph@schlosser.xyz> Christoph Schlosser <christoph.schlosser@br-automation.com>\nClaudius Zingerli <czingerl@gmail.com> zeuz <czingerl@gmail.com>\nDana Sy <dana.hayden.sy@gmail.com> Dana Sy <dhs@exegin.com>\nDaniel Mouscher <dmouscher[AT]gmail.com> Mouscher, Daniel [Intern] <dmouscher@gmail.com>\nDaniel Tan <BACdaBASpert@optigo.net> BACdaBASpert <BACdaBASpert@optigo.net>\nDaniël van Eeden <wireshark@myname.nl> Daniel van Eeden\nDaniël van Eeden <wireshark@myname.nl> <git@myname.nl>\nDarien Spencer <cusneud@mail.com> DarienSpencer65 <cusneud@mail.com>\nDario Lombardo <lomato@gmail.com> dario <lomato@gmail.com>\nDarius Davis <darius-wireshark@free-range.com.au> dariusd0 <darius-gitlab@free-range.com.au>\nDarius Davis <darius-wireshark@free-range.com.au> dariusd0 <darius@vmware.com>\nDarius Davis <darius-wireshark@free-range.com.au> Darius Davis <darius@vmware.com>\nDave Tapuska <dtapuska@google.com> dave@tapuska.com\nDavid Aggeler <david_aggeler@yahoo.com> david-aggeler <david_aggeler@yahoo.com>\nDavid Ameiss <dameiss@29west.com> <netshark@ameissnet.com>\nDavid Bastiani <daveb64@yahoo.com>Dave B <daveb64@yahoo.com>\nDavid Perry <boolean263@protonmail.com> David Perry <d.perry@utoronto.ca>\nDavid Zoller <zollerd@gmail.com> dz-msfc <zollerd@gmail.com>\nDeep Datta <ddatta@ixiacom.com> Deep Datta <deepdatta2010@yahoo.co.in>\nDenis Janssen <janssend@gmail.com> janssend <janssend@gmail.com>\nDennis Lanov <dennis.lanov@gmail.com> dennis.lanov <dennis.lanov@gmail.com>\nDhiru Kholia <kholia@kth.se> Dhiru Kholia <dhiru.kholia@gmail.com>\nDidier Gautheron <dgautheron@magic.fr> didier <dgautheron@magic.fr>\nDiego Dupin <diego.dupin@mariadb.com> diego dupin <diego.dupin@mariadb.com>\nDirk Jagdmann <doj@cubic.org> Dirk <doj@cubic.org>\nDirk Römmen <dirk.roemmen@cslab.de> Dirk Römmen <dro@cslab.de>\nDisha Daniel <ddaniel@empirix.com> dishadaniel <ddaniel@empirix.com>\nDmitry Bazhenov <dima_b@pigeonpoint.com> U-beauty\\bdn <dima_b@pigeonpoint.com>\nDmitry Lazurkin <dilaz03@gmail.com> Dmitry Lazurkin <dmitry.lazurkin@synesis.ru>\nDr. Lars Voelker <lars-github@larsvoelker.de> Dr. Lars Voelker <lars.voelker@bmw.de>\nDylan Ulis  <daulis0@gmail.com> D. Ulis <daulis0@gmail.com>\nEason Wei <sharkhw@huawei.com> easonweii <sharkhw@huawei.com>\nEd Beroset <beroset@ieee.org> Ed Beroset <beroset@mindspring.com>\nEdward Smith <edward.smith@nowlegent.com> Ed <edward.smith@nowlegent.com>\nEdwin Groothuis <edwin@mavetju.org> <wireshark@mavetju.org>\nErik de Jong <erikdejong@gmail.com> erikdejong <erikdejong@gmail.com>\nEugene Adell <eugene.adell@gmail.com> Eugene Adell <eugene.adell@d2-si.eu>\nEugene Exarevsky <eugene.exarevsky@dsr-company.com> dsrsupport <eugene.exarevsky@dsr-company.com>\nEvan Huus <eapache@gmail.com> <evan.huus@jadedpixel.com>\nFlorian Fainelli <florian@openwrt.org> Florian Fainelli <f.fainelli@gmail.com>\nFrancesco Fondelli <francesco.fondelli@gmail.com> ff <francesco.fondelli@gmail.com>\nFrancisco Javier Sánchez-Roselly <franciscojavier.sanchezroselly@ujaen.es> franciscojavier.sanchezroselly <franciscojavier.sanchezroselly@ujaen.es>\nFranklin Mathieu <franklinmathieu@gmail.com> Franklin \"Snaipe\" Mathieu <snaipe@diacritic.io>\nFranklin Mathieu <franklinmathieu@gmail.com> Snaipe <franklinmathieu@gmail.com>\nGabor Spaits <gabor.spaits[AT]ericsson.com> Gábor Spaits <gaborspaits1[AT]gmail.com>\nGabriel Ganne <gabriel.ganne@enea.com> Gabriel Ganne <gabriel.ganne@qosmos.com>\nGerald Combs <gerald@wireshark.org> Gerald Combs <gerald.combs@riverbed.com>\nGerald Combs <gerald@wireshark.org> <gerald@zing.org>\nGilbert Ramirez <gram@alumni.rice.edu> <gilramir@cisco.com>\nGizem Yurdagul <gizemnuryurdagul@gmail.com> gizem.yurdagul <gizemnuryurdagul@gmail.com>\nGloria Pozuelo <gloria.pozuelo@bics.com> glores <gloria.pozuelo@bics.com>\nGraeme Lunt <graeme.lunt@smhs.co.uk> gal <graeme.lunt@smhs.co.uk>\nGreg Morris <GMORRIS@novell.com> gmor1207@gmail.com <gmor1207@gmail.com>\nGregorio Maglione <gregorio.maglione@city.ac.uk> GREGORIO-M <gregorio.maglione@city.ac.uk>\nGuy Davies <aguydavies@gmail.com> guydavies <aguydavies@gmail.com>\nHadriel Kaplan <hadrielk@yahoo.com> <hadriel@128technology.com>\nHannes R. Boehm <hannes@boehm.org> hannes <hannes@localhost>\nHiddencodes Sec <hidd3ncod3s@gmail.com> hidd3ncod3s <hidd3ncod3s@gmail.com>\nHitesh K Maisheri <maisheri.hitesh@gmail.com> <hmaisher@cisco.com>\nHitesh K Maisheri <maisheri.hitesh@gmail.com> maisheri <maisheri.hitesh@gmail.com>\nHuang Qiangxiong <qiangxiong.huang@qq.com> huangqiangxiong <qiangxiong.huang@qq.com>\nIrene Rüngeler <ruengeler@wireshark.org> Irene Ruengeler <ruengeler@wireshark.org>\nIrene Rüngeler <ruengeler@wireshark.org> <I.Ruengeler@fh-muenster.de>\nIrene Rüngeler <ruengeler@wireshark.org> <ruengeler@localhost>\nIrene Rüngeler <ruengeler@wireshark.org> <ruengeler@MacBookIrene.local>\nIrene Rüngeler <ruengeler@wireshark.org> ruengeler <ruengeler@wireshark.org>\nIshaan Gandhi <ishaangandhi@gmail.com> ishaangandhi <ishaangandhi@gmail.com>\nIsmael Mendez Matamoros <ismael@rti.com> ismaelrti <ismael@rti.com>\nJaap Keuter <jaap.keuter@xs4all.nl> Jaap Keuter <jkeuter@aimvalley.nl>\nJaime Caamaño Ruiz <jcaamano@suse.com> Jaime Caamaño Ruiz <jaime.caamano.ruiz@ericsson.com>\nJakub Zawadzki <darkjames-ws@darkjames.pl> <darkjames@darkjames.pl>\nJeff Morriss <jeff.morriss.ws@gmail.com> <jeff.morriss@netscout.com>\nJeff Morriss <jeff.morriss.ws@gmail.com> <jeff.morriss@ulticom.com>\nJeff Morriss <jeff.morriss.ws@gmail.com> <morriss@ulticom.com>\nJeff Oconnell <jeffo@rulez.com> jeff oconnell <jeffo@rulez.com>\nJeremy McCormick <jjmccormick@protonmail.com> <jeremy.mccormick@craftdesigns.net>\nJeroen Sack <jeroen@jeroensack.nl> Jeroen Sack <jsack@lely.com>\nJim Schaettle <jimschaettle@gmail.com> Nick <jimschaettle@gmail.com>\nJiří Engelthaler <engycz@gmail.com> Jiri Engelthaler <engycz@gmail.com>\nJirka Novak <j.novak@netsystem.cz> j.novak@netsystem.cz\nJirka Novak <j.novak@netsystem.cz> novakji\nJoão Valverde <j@v6e.pt> João Valverde <joao.valverde@tecnico.ulisboa.pt>\nJoeri de Ruiter <joeri@cypherpunk.nl> Joeri <joeri@cypherpunk.nl>\nJohn Miner <optommp@gmail.com> John <optommp@gmail.com>\nJonathan Fleming <jonathan@optigo.net> Jonathan Fleming <jonathanfleming135@gmail.com>\nJonathan Muñoz <jonathan.munoz@inria.fr> Jonathan Munoz <jonathan.munoz@inria.fr>\nJorge Power <jpower@rsscorp.org> jorge power\nJörg Mayer <jmayer@loplof.de> Joerg Mayer <jmayer@loplof.de>\nJörg Mayer <jmayer@loplof.de> Jörg Mayer <jmayer@egg.fg-networking.de>\nJoseph Huffman <jhuffman@codeaurora.org> <jhuffman@qce.qualcomm.com>\nJose Rubio <joserubiovidales@gmail.com> clairvoyant <joserubiovidales@gmail.com>\nJosh Schmelzle <josh[AT]joshschmelzle.com> Josh Schmelzle <13954434+joshschmelzle[AT]users.noreply.github.com>\nJosh Schmelzle <josh@joshschmelzle.com> Josh Schmelzle <13954434+joshschmelzle[AT]users.noreply.github.com>\nJuan Jose Martin Carrascosa <juanjo@rti.com> Juanjo <juanjo@rti.com>\nJuan Pablo Mendoza <jpablo@gmail.com> jpmendoza <jpablo@gmail.com>\nKary Rogers <kary.rogers@gmail.com> karyrogers <kary.rogers@gmail.com>\nKasper Deng <kasper.deng@ericsson.com> KasperDeng <kasper.deng@ericsson.com>\nKirill Chernyshov <nideff.ru@gmail.com> kanidef <nideff.ru@gmail.com>\nKrishna Chaitanya <chaitanya.mgit@gmail.com> tkc <chaitanya.mgit@gmail.com>\nLukas Emersberger <lukas.emersberger@gmail.com> <lukas.emersberger@br-automation.co.at>\nLukas Emersberger <lukas.emersberger@gmail.com> <lukas.emersberger@br-automation.com>\nMarcel Essig <marcel.essig@gmx.de> <essig.marcel@gmail.com>\nMarian Ďurkovič <md@bts.sk> Marian Durkovic\nMarius Paliga <marius.paliga@gmail.com> Marius <mareko.paliga@gmail.com>\nMarius Paliga <marius.paliga@gmail.com> Marius Paliga <mareko.paliga@gmail.com>\nMark Ciechanowski <markciechanowski@gmail.com> ciechanowski <markciechanowski@gmail.com>\nMark Phillips <mark.s.phillips@outlook.com> Mark Phillips <mark.phil@samsung.com>\nMark Phillips <mark.s.phillips@outlook.com> MarkPhillips <mark.s.phillips@outlook.com>\nMartin Kaiser <wireshark@kaiser.cx> <martin.kaiser@paytec.ch>\nMartin Kaiser <wireshark@kaiser.cx> <martin@reykholt.kaiser.cx>\nMartin Kaiser <wireshark@kaiser.cx> <martin@skogar.kaiser.cx>\nMartin Tibenský <martin.tibensky@alcatel-lucent.com> matibens\nMartin Tibenský <martin.tibensky@alcatel-lucent.com> matibens <martin.tibensky@alcatel-lucent.com>\nMartin Tibenský <martin.tibensky@alcatel-lucent.com> <tibensky233@gmail.com>\nMatheus K. Ferst <matheus.ferst@gmail.com> ferst <matheus.ferst@gmail.com>\nMatthew Weant <msweant@gmail.com> Matthew Weant <msweant@gmail.com>\nMatthieu Coudron <matthieu.coudron@lip6.fr> <mattator@gmail.com>\nMatthieu Texier <matthieu@texier.tv> Matt Texier <matthieu@texier.tv>\nMehmet Oguz Sakaoglu <mehmet.oguz.mnz@gmail.com> moguz <mehmet.oguz.mnz@gmail.com>\nMichael Oed <michael.oed@gmail.com> Mike78 <michael.oed@gmail.com>\nMichael Tüxen <tuexen@wireshark.org> <tuexen@fh-muenster.de>\nMichael Tüxen <tuexen@wireshark.org> <tuexen@mba.local>\nMichail Koreshkov <michail.koreshkov@mail.ru> Michail Koreshkov <drkor@hotbox.ru>\nMichail Koreshkov <michail.koreshkov@mail.ru> Mikhail Koreshkov <drkor@hotbox.ru>\nMikhail Koreshkov <michail.koreshkov@mail.ru> unknown <drkor@hotbox.ru>\nMichail Koreshkov <michail.koreshkov@mail.ru> kor <drkor@bk.ru>\nMichał Łabędzki <michal.labedzki@wireshark.org> Michal Labedzki <michal.labedzki@tieto.com>\nMichał Orynicz <michal.orynicz@tieto.com> michal.orynicz\nMichal Prívozník <mprivozn@redhat.com> <miso.privoznik@gmail.com>\nMichal Prívozník <mprivozn@redhat.com> <mprivozn@redhat.com>\nMikael Kanstrup <mikael.kanstrup@gmail.com> Mikael Kanstrup <mikael.kanstrup@sony.com>\nMikael Kanstrup <mikael.kanstrup@gmail.com> Mikael Kanstrup <mikael.kanstrup@sonymobile.com>\nMilos Jovanovic <jeyem815@gmail.com> LoSmX <jeyem815@gmail.com>\nMoraney Jalil <moraney.jalil@outlook.com> moraney.jalil\nMoshe Kaplan <me@moshekaplan.com> moshekaplan <me@moshekaplan.com>\nMoshe Kaplan <me@moshekaplan.com> Your Name <you@example.com>\nNicolas Bertin <nicolas.bertin@al-enterprise.com> nbertin <nicolas.bertin@al-enterprise.com>\nNikhil Acharya Prakash <nikhilap@arista.com> Nikhil AP <nikhilap@arista.com>\nOlga Kornievskaia <kolga@netapp.com> Olga Kornievskaia <olga.kornievskaia@gmail.com>\nOliver Downard <oliver.downard@couchbase.com> olivermd <oliver.downard@couchbase.com>\nØyvind Rønningstad <ronningstad@gmail.com> oyv <ronningstad@gmail.com>\nPascal Quantin <pascal@wireshark.org> <pascal@localhost>\nPascal Quantin <pascal@wireshark.org> Pascal Quantin <pascal.quantin@gmail.com>\nPatrick Servello <patrick.servello@gmail.com> Patrick <patrick.servello@gmail.com>\nPatrik Moško <patrikmosko95@gmail.com> PatrikMosko <patrikmosko95@gmail.com>\nPaul Williamson <paul@mustbeart.com> MustBeArt<paul@mustbeart.com>\nPavel Strnad <strnadp@tiscali.cz> Pavel Strnad <pavel_strnad@hotmail.com>\nPeter McLean <peterm@arista.com> <peterm@arista.com>\nPeter Ross <peter.ross@dsto.defence.gov.au> <peter.ross@rmit.edu.au>\nPeter Wu <peter@lekensteyn.nl> <lekensteyn@gmail.com>\nPetr Gotthard <petr.gotthard@honeywell.com> Petr Gotthard <petr.gotthard@centrum.cz>\nPratik Yeole <pyeole@ncsu.edu> Pyeole <pyeole@ncsu.edu>\nQiaoyin Yang <qiaoyin.yang@gmail.com> <qiaoyin.yang[AT]gmail.com>\nRemi Vichery <remi.vichery@gmail.com>\nRichard Kuemmel <kuemmel.ric@googlemail.com> richardk <kuemmel.ric@googlemail.com>\nRichard Sharpe <realrichardsharpe@gmail.com> Richard Sharpe <richard.sharpe@primarydata.com>\nRichard Sharpe <realrichardsharpe@gmail.com> Richard Sharpe <rsharpe@samba.org>\nRichard Sharpe <realrichardsharpe@gmail.com> <sharpe@ns.aus.com>\nRobert Cragie <robert.cragie@gmail.com> Robert Cragie <robert.cragie@arm.com>\nRobert Grange <robionekenobi@bluewin.ch> robioneknobi\nRonen Boazi <ronen.boazi@intel.com> Boazi <ronen.boazi@intel.com>\nRonnie Sahlberg <ronniesahlberg@gmail.com> <ronnie_sahlberg@ozemail.com.au>\nRoss Jacobs <rossbjacobs@gmail.com> Ross <rossbjacobs@gmail.com>\nRoss Jacobs <rossbjacobs@gmail.com> Ross <whim42+github@gmail.com>\nRudra Rugge  <rrugge@juniper.net> Rudra Rugge <rudrarugge@gmail.com>\nRui ZHANG <rzhang@grandstream.cn> ZHANG Rui <rzhang@grandstream.cn>\nRussel Howe <russel@appliedinvention.com> Russel <russel@appliedinvention.com>\nRustam Safargalin <rustam.safargalin@sifox.ru> Rustam S <rustam.safargalin@sifox.ru>\nSaku Ytti <saku@ytti.fi> ytti <saku@ytti.fi>\nSamiran Saha <ssahasamiran@gmail.com> samsaha <ssahasamiran@gmail.com>\nSangeetha Jain <ssi@extremenetworks.com> Sangeetha Jain <sangeethasijain@gmail.com>\nSanket Godbole <sanket.godbole@spirent.com> sangodbole <sanket.godbole@spirent.com>\nSelva Kumar <v.selvamuthukumar@gmail.com> Selva <v.selvamuthukumar@gmail.com>\nShekhar Chandra <ranushekhar@gmail.com> ranushekhar\nShuai Xiao <iamhihi@gmail.com> shuai xiao <iamhihi@gmail.com>\nSimon Barber <simon.barber@meraki.net> Simon Barber <sbarber@parc.com>\nSimon Zhong <szhong.jnpr@gmail.com> szhong <szhong.jnpr@gmail.com>\nSlavka Michal <slavka.michal@gmail.com> slavka <slavka.michal@gmail.com>\nS. Shapira <sswsdev@gmail.com> sswsdev <sswsdev@gmail.com>\nStefan Battmer <stefan.battmer@matrix-vision.de> bat <stefan.battmer@matrix-vision.de>\nStella Randall <stella.randall@emeerson.com> rosemountSkp <rosemountSkp@code.wireshark.org>\nStephen Donnelly <stephen@endace.com> sfd <stephen.donnelly@emulex.com>\nStephen Donnelly <stephen@endace.com> sfd <stephen.donnelly@endace.com>\nStephen Donnelly <stephen@endace.com> Stephen Donnelly <stephen.donnelly@emulex.com>\nStephen Fisher <stephenfisher@centurylink.net> <sfisher@panix.com>\nStephen Fisher <stephenfisher@centurylink.net> <sfisher@sdf.org>\nStephen Fisher <stephenfisher@centurylink.net> <stephenfisher-wireshark@outlook.com>\nStephen Fisher <stephenfisher@centurylink.net> <steve@stephen-fisher.com>\nSumit Kumar Jha <sjha3@ncsu.edu> sjha3 <sjha3@ncsu.edu>\nTengfei Chang <tengfei.chang@inria.fr> tchang <tengfei.chang@inria.fr>\nThies Moeller <thies.moeller[AT]baslerweb.com> <thies.moeller@baslerweb.com>\nThomas d'Otreppe <tdotreppe@aircrack-ng.org> Mister X <tdotreppe@aircrack-ng.org>\nThomas Portassau <thomas.portassau@hotmail.fr> Thomas PORTASSAU <thomas.portassau@hotmail.fr>\nToshihiro Kataoka <kataoka.toshihiro@gmail.com> KATAOKA, Toshihiro <kataoka.toshihiro@gmail.com>\nUli Heilmeier <uh@heilmeier.eu> Uli Heilmeier <openid@heilmeier.eu>\nUli Heilmeier <uh@heilmeier.eu> Uli Heilmeier <ulrich.heilmeier@vitesco.com>\nUli Heilmeier <uh@heilmeier.eu> Uli Heilmeier <ulrich.heilmeier@web.de>\nVadim Fedorenko <vadimjunk@gmail.com> Vadim Fedorenko <junk@yandex-team.ru>\nVahap Emin Agaogullari <vahapemin44@gmail.com> vahapemin <vahapemin44@gmail.com>\nVasil Velichkov <vvvelichkov@gmail.com> Vasil Velichckov <vvvelichkov@gmail.com>\nVasil Velichkov <vvvelichkov@gmail.com> Vasil Velichkov <vasko@192.168.1.12>\nVasil Velichkov <vvvelichkov@gmail.com> Vasil Velichkov <vasko@vvelichkov2.dev.opencode.com>\nVikram Hegde <vikram.h@samsung.com> Vikram Hegde <vikram.h@amsung.com>\nVincent Helfre <vincent.helfre@gmx.net> Vincent Helfre <vincenthelfre@googlemail.com>\nVincenzo Reale <smart2128vr@gmail.com> Vincenzo Reale <smart2128@baslug.org>\nVolodymyr Khomenko <Khomenko.Volodymyr@gmail.com> Volodymyr Khomenko <Volodymyr_Khomenko@DellTeam.com>\nWarren Moxam <warrenmptgrey@gmail.com> warrenm <warrenmptgrey@gmail.com>\nWarren Moxam <warrenmptgrey@gmail.com> <warren@peter-ubuntu32.(none)>\nWido Kelling <kellingwido@aol.com> Widok <kellingwido@aol.com>\nYang Luo <hsluoyz@qq.com> hsluoyz <hsluoyz@qq.com>\nYang Luo <hsluoyz@qq.com> Yang Luo <hsluoyz@gmail.com>\nYaniv Kaul <mykaul@gmail.com> <yaniv.kaul@emc.com>\nYasuyuki Tanaka <yasuyuki.tanaka@inria.fr> Yasuyuki Tanaka <yatch1.tanaka@toshiba.co.jp>\nYasuyuki Tanaka <yasuyuki.tanaka@inria.fr> Yasuyuki Tanaka <yatch@isl.rdc.toshiba.co.jp>\nYasuyuki Tanaka <yasuyuki.tanaka@inria.fr> <yatch@isl.rdc.toshiba.co.jp>\nZachary Holcomb <zholcomb2017[AT]my.fit.edu> Zachary <zholcomb2017@my.fit.edu>\nZhang Zhilei <zhangzhilei@360.cn> <zhangzhilei@360.cn>\nZhao Lin <zlbinghamton@gmail.com> linzhao115 <zlbinghamton@gmail.com>\nZhongwei Situ <zsitu@extremenetworks.com> zhongweisitu <zsitu@extremenetworks.com>\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.205078125,
          "content": "language: minimal\ndist: bionic\nmatrix:\n  include:\n    - name: OSX (xcode12.2 clang-12.0.0)\n      os: osx\n      osx_image: xcode12.2\n    - name: Linux amd64 (gcc-9)\n      os: linux\n      addons:\n        apt:\n          update: true\n          sources:\n            - ubuntu-toolchain-r-test\n            - sourceline: ppa:ubuntu-toolchain-r/test\n          packages: g++-9\n      env:\n        - CXX=g++-9\n        - CC=gcc-9\n    - name: Linux arm64 (gcc-8)\n      os: linux\n      arch: arm64\n      addons:\n        apt:\n          packages: g++-8\n      env:\n        - CXX=g++-8\n        - CC=gcc-8\n    - name: Linux s390x (gcc-7)\n      os: linux\n      arch: s390x\n    - name: Linux ppc64le (gcc-7)\n      os: linux\n      arch: ppc64le\n    - name: Linux amd64 (clang)\n      os: linux\n      env:\n        - CXX=clang++\n        - CC=clang\n    - name: Linux arm64 (clang)\n      os: linux\n      arch: arm64\n      env:\n        - CXX=clang++\n        - CC=clang\n    - name: Linux s390x (clang)\n      os: linux\n      arch: s390x\n      env:\n        - CXX=clang++\n        - CC=clang\n    - name: Linux ppc64le (clang)\n      os: linux\n      arch: ppc64le\n      env:\n        - CXX=clang++\n        - CC=clang\n  allow_failures:\n    # Those builds frequently fail due to builds longer than maximum allowed.\n    # Let them fail quietly.\n    arch: ppc64le\nbefore_install:\n  - echo $TRAVIS_OS_NAME\n  # macos\n  - if [ \"$TRAVIS_OS_NAME\" == \"osx\" ]; then ./tools/macos-setup-brew.sh; fi\n  - if [ \"$TRAVIS_OS_NAME\" == \"osx\" ]; then brew install softhsm; fi\n  - if [ \"$TRAVIS_OS_NAME\" == \"osx\" ]; then sed s/access_bpf/staff/ packaging/macosx/ChmodBPF/ChmodBPF | sudo bash; fi\n  # linux\n  - if [ \"$TRAVIS_OS_NAME\" == \"linux\" ]; then sudo ./tools/debian-setup.sh --install-optional --install-test-deps -q; fi\n  - if [ \"$TRAVIS_OS_NAME\" == \"linux\" ]; then sudo apt-get install -y python3-pip; fi\n  # all platforms\n  - pip3 install pytest pytest-xdist\nbefore_script:\n  - mkdir build\n  - cd build\n  - cmake -GNinja ..\nscript:\n  - ninja || travis_assert\n  - ninja test-programs\n  - if [ \"$TRAVIS_OS_NAME\" == \"linux\" ]; then sudo setcap cap_net_raw,cap_net_admin+eip run/dumpcap; fi\n  - pytest\nafter_script:\n  - if [ -f run/tshark ]; then run/tshark --version; fi\n  - ../test/travis-upload-artifacts.sh\n"
        },
        {
          "name": ".tx",
          "type": "tree",
          "content": null
        },
        {
          "name": ".well-known",
          "type": "tree",
          "content": null
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 167.5107421875,
          "content": "\n\n= Original Author =\n\nGerald Combs            <gerald[AT]wireshark.org>\n\n\n= Contributors =\n\nGilbert Ramirez         <gram[AT]alumni.rice.edu> {\n\tWiretap\n\tPrinting\n\tToken-Ring, TR MAC\n\t802.2 LLC\n\tIPX, SPX, NCP\n\tBOOTP/DHCP\n\tLPD\n\tWin32 support\n\ttvbuffs\n\tMiscellaneous enhancements and fixes\n}\n\nThomas Bottom           <tom.bottom[AT]labxtechnologies.com> {\n\tIEEE 1722.1 support\n}\n\nChris Pane              <chris.pane[AT]labxtechnologies.com> {\n\tIEEE 1722.1 support\n}\n\nHannes R. Boehm         <hannes[AT]boehm.org> {\n\thttp://hannes.boehm.org/\n\n\tOSPFv2\n\tRIPv1, RIPv2\n\tCDP (Cisco Discovery Protocol Version 1)\n}\n\nMike Hall               <mike[AT]hallzone.net> {\n\tFollow TCP Stream\n}\n\nBobo Rajec              <bobo[AT]bsp-consulting.sk> {\n\tDNS protocol support\n}\n\nLaurent Deniel          <laurent.deniel[AT]free.fr> {\n\tName resolution\n\tEthernet/Manufacturer files support\n\tFDDI support\n\tOMG GIOP/IIOP support\n\tISO/OSI CLNP/COTP support\n\tReal time capture and display enhancement\n\tMany display filters added\n\tGUI enhancements (about & help windows)\n\tFollow TCP stream for IPv6\n\tProtocol activation/deactivation (Edit:protocols)\n\tAbility to mark the frames and associated features\n\t\"Protocol Properties...\" menu item\n\tRing buffer rework\n\tX11 decoding enhancements and fixes\n\tMiscellaneous enhancements and fixes\n}\n\nDon Lafontaine          <lafont02[AT]cn.ca> {\n\tBanyan Vines support\n\tIGRP support\n}\n\nGuy Harris              <guy[AT]alum.mit.edu> {\n\tDNS and NetBIOS Name Service enhancements\n\tBitfield decoding\n\tIP and TCP option decoding\n\tHTTP support\n\tNNTP support\n\tATM and LANE decoding\n\tQ.931 decoding\n\tChanges to the popup packet windows\n\tMiscellaneous enhancements and fixes\n}\n\nSimon Wilkinson         <sxw[AT]dcs.ed.ac.uk> {\n\tAppleTalk support\n}\n\nJörg Mayer              <jmayer[AT]loplof.de> {\n\tBanyan Vines support\n\tNTP fixes\n\tDHCP support for Intel PXEclient DHCP requests\n\tSupport for \"-N\" flag enabling selected forms of name resolution\n\tChanges to structure initializations to initialize all members\n\tDefine __USE_XOPEN in files that use \"strptime()\"\n\tVarious signed vs. unsigned fixes\n\tCrank up the warning level in GCC\n\tSkinny (Official Name: SCCP)\n\tRemove trailing blanks from hex dump in print/Tethereal\n\tRemove unused variables and declarations of non-existent\n\t    functions\n\tIn configure scripts, if the compiler is GCC, add to CFLAGS a -D\n\t    flag to define _U_ as something that marks an argument\n\t    unused in GCC, and as nothing for other compilers\n\tAdd _U_ to unused arguments, and turn off \"-Wno-unused\"\n\t.cvsignore fixes\n\tMake a pile of stuff not used outside one source file static\n\tClean up #includes\n\tMark last packet of TFTP transfer as such in the Info column\n\tDissect both the BOOTP server and client ports as bootp/DHCP\n\tFix some small memleaks found by valgrind\n\tSome Extreme protocols\n\tSome 3com management protocol\n}\n\nMartin Maciaszek        <fastjack[AT]i-s-o.net> {\n\tRPM .spec file\n}\n\nDidier Jorand           <Didier.Jorand[AT]alcatel.fr> {\n\tSNMP support\n\tTCP SEQ/ACK analysis bugfix for sequence number wrapping.\n\tFIX 4.0 to 4.4 fields\n}\n\nJun-ichiro itojun Hagino <itojun[AT]itojun.org> {\n\thttp://www.itojun.org/\n\n\tIPv6 support\n\tRIPng support\n\tIPsec support\n\tPIM (Prototocol-Independent Multicast) support\n\tIPComp (IP Payload Compression) support\n\tBGP (Border Gateway Protocol) support\n}\n\nRichard Sharpe          <realrichardsharpe[AT]gmail.com> {\n\tTFTP, FTP, POP, Telnet support\n\tInfrastructure changes for the benefit of TFTP\n\tSMB support\n\tLDP\n\tGSS-API and SPNEGO work\n\tMS RPC WKSSVC dissector\n}\n\nJohn McDermott          <jjm[AT]jkintl.com> {\n\tPacket coloring support\n\tPseudo-real-time capture\n}\n\nJeff Jahr               <jjahr[AT]shastanets.com> {\n\tPPP over Ethernet (PPPoe)\n}\n\nBrad Robel-Forrest      <bradr[AT]watchguard.com> {\n\tISAKMP, GRE, PPTP\n}\n\nAshok Narayanan         <ashokn[AT]cisco.com> {\n\tRSVP\n\tMatch Selected functionality\n\tSupport for reading compressed capture files\n\tMPLS\n\tLink Management Protocol\n\tIEEE 802.1ad and 802.1ah\n}\n\nAaron Hillegass         <aaron[AT]classmax.com> {\n\tSummary dialogue\n}\n\nJason Lango             <jal[AT]netapp.com> {\n\tRTSP, SDP\n\tRTCP fixes\n}\n\nJohan Feyaerts          <Johan.Feyaerts[AT]siemens.com> {\n\tRADIUS\n}\n\nOlivier Abad            <oabad[AT]noos.fr> {\n\tX.25 support in iptrace files and Sniffer files\n\tSupport for files from RADCOM WAN/LAN analyzers\n\t    and HP-UX nettl traces\n\tLAPB, X.25\n\tPlugins support\n\tSupport for capturing packet data from pipes\n\tSupport for writing NetXRay 2.x (Windows Sniffer) format captures\n}\n\nThierry Andry           <Thierry.Andry[AT]advalvas.be> {\n\tLinux ATM Classical IP support\n\tMore filterable fields in SNMP\n}\n\nJeff Foster             <jfoste[AT]woodward.com> {\n\tNetBEUI/NBF support (NetBIOS atop 802.2 LLC, the\n\t    original NetBIOS encapsulation)\n\tSMB Mailslot and Netlogin protocol support\n\tPopup packet windows\n\tSupport for protocols registering themselves with dissectors for\n\t    protocols on top of which they run\n\tRlogin support\n\tSupport for associating a dissector with a conversation, and for\n\t    use of that dissector by TCP and UDP\n\tSOCKS support\n\tMicrosoft Proxy protocol support\n\tSupport for conversations with \"wildcard\" destination addresses\n\t   and/or ports\n\tInitial support for constructing filter expressions\n\tSupport for reading Sniffer Frame Relay captures\n\tPartial support for determining the type of \"Internetwork\n\t    analyzer\" Sniffer captures (we don't yet have enough captures\n\t    to do it all)\n}\n\nPeter Torvals           <petertv[AT]xoommail.com> {\n\tInternet Cache Protocol support\n}\n\nChristophe Tronche      <ch.tronche[AT]computer.org> {\n\thttps://tronche.com\n\tBPDU (spanning tree protocol) support\n\tX11 requests support\n}\n\nNathan Neulinger        <nneul[AT]umr.edu> {\n\tYahoo Messenger YHOO protocol, and Yahoo Pager (YPNS?) protocol\n\t    support\n\tNTP (Network Time Protocol) support\n\tRX protocol support\n\tAndrew File System protocol support\n\t802.1q VLAN support\n\tMisc. RPC program dissectors\n\tTNS/Oracle dissector\n\tTacacs+/XTacacs dissector\n\tIRC dissector\n\tAppleTalk NBP dissector\n\tAppleTalk RTMP response dissector\n\tAutomake and autoconf updates to handle the current CVS versions\n\t    of automake (which will probably eventually become the next\n\t    releases of automake and autoconf)\n\tAdditional cipher suite names for SSL\n\tSEBEK - Kernel read() data capture protocol support\n\tLinux IPVS Synchronization Daemon support\n}\n\nTomislav Vujec          <tvujec[AT]carnet.hr> {\n\tAdditional NTP support\n}\n\nKojak                   <kojak[AT]bigwig.net> {\n\tICQ support\n}\n\nUwe Girlich             <Uwe.Girlich[AT]philosys.de> {\n\tONC RPC support\n\tNFS support\n\tMount Protocol support started\n\tNLM support started\n\tPCNFSD support started\n\tTSP support\n\tQuake dissector\n\tQuakeWorld dissector\n\tQuake II dissector\n\tQuake 3 Arena dissector\n\tDTPT dissector\n\tINTERLINK dissector\n}\n\nWarren Young            <tangent[AT]mail.com> {\n\t\"Print\" button support in \"Tools:Follow TCP Stream\" window\n}\n\nHeikki Vatiainen        <hessu[AT]cs.tut.fi> {\n\tCisco Auto-RP protocol support\n\tSAP (Session Announcement Protocol) support\n\tVRRP (Virtual Router Redundancy)\n\tHSRP (Hot Standby Router Protocol)\n\toption to control whether to interpret the IPv4 TOS field as\n\t    such or as the DiffServ field\n\tCOPS\n\tSIP (Session Initiation Protocol)\n\tBGP tvbuffification\n\tIPv6 and ICMPv6 tvbuffification\n\tPIM enhancements and fixes\n\tSupport for Enter/Return toggling expansion of selected protocol\n\t    tree item\n\tIGMP fixes and multicast traceroute support\n\tMSDP support\n\tIPv6 name resolution support on Solaris 8\n\tEnhancements to the \"bad sed\" tests\n\tMake \"get_host_ipaddr()\" require dotted-quad IP addresses to\n\t    really be quads\n\tCGMP-over-Ethernet II support\n\tFix the test for IS-IS virtual links\n\tDocumentation improvements\n}\n\nGreg Hankins            <gregh[AT]twoguys.org> {\n\thttp://www.twoguys.org/~gregh\n\n\tupdates to BGP (Border Gateway Protocol) support\n}\n\nJerry Talkington        <jtalkington[AT]users.sourceforge.net> {\n\ttvb_uncompress()/HTTP Content-Encoding decompression\n\tHTTP chunked encoding dissection\n\tupdates to HTTP support\n\tFilter selection/editing GUI improvements\n\tWCCP 1.0 support\n\tRight-mouse-button menu support\n}\n\nDave Chapeskie          <dchapes[AT]ddm.on.ca> {\n\tupdates to ISAKMP support\n}\n\nJames Coe               <jammer[AT]cin.net> {\n\tSRVLOC (Service Location Protocol) support\n\tNCP over IP support\n}\n\nBert Driehuis           <driehuis[AT]playbeing.org> {\n\tI4B (ISDN for BSD) wiretap module\n\tV.120\n}\n\nStuart Stanley          <stuarts[AT]mxmail.net> {\n\tISIS on CLNP support\n}\n\nJohn Thomes             <john[AT]ensemblecom.com> {\n\tL2TP support\n}\n\nLaurent Cazalet         <laurent.cazalet[AT]mailclub.net> {\n\tupdates to L2TP support\n}\n\nThomas Parvais          <thomas.parvais[AT]advalvas.be> {\n\tupdates to L2TP support\n}\n\nGerrit Gehnen           <G.Gehnen[AT]atrie.de> {\n\tsupport for \"Inactive Subset\" of ISO CLNP\n\tDecoding of OSI COTP TSAPs as text when they're plain text\n\tSinec H1 protocol support\n}\n\nCraig Newell            <craign[AT]cheque.uq.edu.au> {\n\tTFTP options (RFC 2347) support\n}\n\nEd Meaney               <emeaney[AT]cisco.com> {\n\tWin32 support\n}\n\nDietmar Petras          <DPetras[AT]ELSA.de> {\n\tTime protocol support\n\tFix to handling of SNMPv2 TRAP PDUs\n}\n\nFred Reimer             <fwr[AT]ga.prestige.net> {\n\tTCP segment length in TCP packet summary\n}\n\nFlorian Lohoff          <flo[AT]rfc822.org> {\n\tVarious enhancements to RADIUS support\n\tFixes to L2TP result and error code dissection\n\tRedback SmartEdge SE400/800 tcpdump disassembly\n\tRedback Lawful Intercept dissection\n}\n\nJochen Friedrich        <jochen+ethereal[AT]scram.de> {\n\tSNA improvements\n\tFix to IPv6 fragment handling\n\tSMUX and SNMPv3 support\n\tZebra support\n\tHPR/UDP (RFC 2353, Enterprise Extender)\n\tRPL support\n\tHP extended 802.2 LLC support\n\tHP remote management protocol support\n\tSNMP over HP extended 802.2 LLC support\n}\n\nPaul Welchinski         <paul.welchinski[AT]telusplanet.net> {\n\tFixes to Win32 packet capture code\n}\n\nDoug Nazar              <nazard[AT]dragoninc.on.ca> {\n\tLDAP support\n}\n\nAndreas Sikkema         <h323[AT]ramdyne.nl> {\n\tFixes to SMB dissector\n\tFixes to capture file handling on Win32\n\tRTCP, RTP, TPKT (RFC 1006), H.261\n\tQ.931 enhancements\n}\n\nMark Muhlestein         <mmm[AT]netapp.com> {\n\tCIFS-over-TCP support\n}\n\nGraham Bloice           <graham.bloice[AT]trihedral.com> {\n\tWin32 icon for Wireshark, and Win32 resource-compiler files to\n\t    add version/copyright/etc. information to Win32 executables\n\tSupport for sorting columns in the summary by clicking on them\n\tWin32 Makefile improvements\n\tSupport for \"Update list of packets in real time\" during capture\n\t    on Win32\n\tSupport for inverse video rather than boldface highlighting of\n\t    the bytes, in the hex dump window, corresponding to a selected\n\t    field\n\tSupport for DNP\n}\n\nRalf Schneider          <ralf.schneider[AT]alcatel.se> {\n\tEnhancements to OSI CLNP, CLTP, and ISIS support\n\tOSI ESIS support\n}\n\nYaniv Kaul              <mykaul[AT]gmail.com> {\n\tEnhancements to ISAKMP\n\tCPHA support\n\tDCERPC OXID operation #5 dissection\n\tTDS enhancements\n\tDCERPC: Resolve UUID to interface names on win32 platforms\n\tPCT support\n\tX509 Certificates over HTTP support\n\tVNC heuristic dissection\n\tTightVNC dissection\n\tMore tags in the DAAP dissector\n\tSPICE dissector\n}\n\nPaul Ionescu            <paul[AT]acorp.ro> {\n\tIPX-over-GRE support\n\tEIGRP support\n\tCisco IGRP support\n\tX.25-over-TCP support\n\tDEC LANBridge Spanning Tree Protocol support\n\tX.25-over-LLC support\n\tIP Prefix field support in CDP\n\tFrame Relay support\n\tFrame-Relay-over-GRE support\n\tIPX SAP over IPX EIGRP support\n\tFleshed out TACACS/XTACACS/TACACS+ dissector\n\tDLSw support\n}\n\nMark Burton             <markb[AT]ordern.com> {\n\tAssorted SMB fixes and enhancements\n\tiSCSI support\n}\n\nStefan Raab             <sraab[AT]cisco.com> {\n\tMobile IP\n}\n\nMark Clayton            <clayton[AT]shore.net> {\n\tSupport for capturing on ATM interfaces on Linux\n}\n\nMichael Rozhavsky       <mike[AT]tochna.technion.ac.il> {\n\tOSPF enhancements\n\tCRLDP support\n}\n\nDug Song                <dugsong[AT]monkey.org> {\n\tRPCSEC_GSS credential/verifier dissection for ONC RPC\n}\n\nMichael Tüxen           <tuexen[AT]wireshark.org> {\n\tSCTP support\n\tM3UA support\n\tISDN Q.921-User Adaptation Layer (IUA) support\n\tSUA and SUA Light support\n\tMTP3 support\n\tMacOS X support\n\tUpdate of M2PA support for later Internet drafts\n\tMTP2 support\n\tSCTP support in text2pcap\n\tSCCP-atop-M3UA support\n\tM2UA support\n\tASAP support\n\tENRP support\n\tFix SCTP port number for M2PA\n}\n\nBruce Korb              <bkorb[AT]sco.com> {\n\tImproved autogen.sh script\n}\n\nJose Pedro Oliveira     <jpo[AT]di.uminho.pt> {\n\tDHCP enhancements\n}\n\nDavid Frascone          <dave[AT]frascone.com> {\n\tDIAMETER support\n\tBug fixes and enhancements to Mobile IP\n\tSupport for Mobile IP's use of ICMP Router Advertisements\n\tRemoval of unused variables and functions\n\tLWAPP support\n}\n\nPeter Kjellerstedt      <pkj[AT]axis.com> {\n\tSRVLOC fixes\n\tICQ enhancements\n\tautogen.sh fixes\n}\n\nPhil Techau             <phil_t[AT]altavista.net> {\n\tAdded \"col_append_str()\"\n\tSigned integer support in display filters and in the protocol tree\n\tBOOTP fixes\n\tAdditional NTP reference clock identifiers\n}\n\nWes Hardaker            <hardaker[AT]users.sourceforge.net> {\n\tKerberos 5 support\n\toccasional ucd-snmp/net-snmp help.\n}\n\nRobert Tsai             <rtsai[AT]netapp.com> {\n\tRsh support\n\tSupport for embedded newlines in SDP fields\n\tSupport for leading LWS in RTSP headers\n}\n\nCraig Metz              <cmetz[AT]inner.net> {\n\tOSPF type 7 LSA dissection\n}\n\nPer Flock               <per.flock[AT]axis.com> {\n\tA6 and DNAME resource record support\n\tRFC 2673 bitstring label support\n}\n\nJack Keane              <jkeane[AT]OpenReach.com> {\n\tISAKMP fixes to handle malformed packets\n}\n\nBrian Wellington        <bwelling[AT]xbill.org> {\n\tSupport for DNS CERT, KX, TSIG, and TKEY records\n\tSupport for NOTIFY and UPDATE DNS opcodes\n\tSupport for YXDOMAIN, YXRRSSET, NXRRRSET, NOTAUTH, NOTZONE, and\n\t   TSIG/TKEY error DNS reply codes\n\tPartial support for DNS-over-TCP\n}\n\nSanteri Paavolainen     <santtu[AT]ssh.com> {\n\t\"Capture->Stop\" menu bar item\n\tImproved capture statistics box\n\tMake doc/Makefile.am work in POSIXLY_CORRECT environment\n\tMobile IPv6 fixes\n}\n\nUlrich Kiermayr         <uk[AT]ap.univie.ac.at> {\n\tECN Extension support\n}\n\nNeil Hunter             <neil.hunter[AT]energis-squared.com> {\n\tWAP support\n}\n\nRalf Holzer             <ralf[AT]well.com> {\n\tAIM/OSCAR support\n}\n\nCraig Rodrigues         <rodrigc[AT]attbi.com> {\n\tGIOP 1.2 support and other GIOP enhancements\n\tHandle current versions of RPM, which compress man pages\n\tReal-time CORBA priority value support\n}\n\nEd Warnicke             <hagbard[AT]physics.rutgers.edu> {\n\tMGCP dissector\n\tPCLI ( Packet Cable Lawful Intercept ) dissector\n}\n\nJohan Jorgensen         <johan.jorgensen[AT]axis.com> {\n\tIEEE 802.11 support\n}\n\nFrank Singleton         <frank.singleton[AT]ericsson.com> {\n\tShort integer CDR support for GIOP\n\tSupport for protocols running atop GIOP\n\tGIOP CosNaming support\n}\n\nKevin Shi               <techishi[AT]ms22.hinet.net> {\n\tGVRP support\n}\n\nMike Frisch             <mfrisch[AT]isurfer.ca> {\n\tNFSv4 support\n\tHCLNFSD support\n\trquota support\n\tAUTH_DES support\n\tTvbuffified NFS dissector\n\tRPCSEC_GSS fixes\n\tPCNFSD updates\n\tNFS_ACL support\n\tPVFS2 support\n}\n\nBurke Lau               <burke_lau[AT]agilent.com> {\n\tPPP FCS checking\n\tCisco HDLC support in PPP dissector\n\tMPLS-over-PPP support\n}\n\nMartti Kuparinen        <martti.kuparinen[AT]iki.fi> {\n\tMobile IPv6 support\n\tHMIPv6 support\n}\n\nDavid Hampton           <dhampton[AT]mac.com> {\n\tSupport for HTTP methods added by GENA (the uPnP protocol)\n\tSupport for the HTTP-based SSDP protocol\n\t\"Decode As\" dialog\n}\n\nKent Engström           <kent[AT]unit.liu.se> {\n\tCDP VTP Management Domain item support\n}\n\nRonnie Sahlberg         <ronniesahlberg[AT]gmail.com> {\n\tNLM dissector enhancements\n\tMount dissector enhancements\n\tSupport for status monitor protocol and status monitor callback\n\t    protocol\n\tYPSERV dissector enhancements\n\tBOOTPARAM dissector enhancements\n\tRWALL support\n\tHCLNFSD dissector enhancements\n\tIP fragment reassembly\n\tYPPASSWD support\n\tKLM support\n\tSPRAY support\n\trquota support completed\n\tXDR array support\n\tNIS+ support\n\tRewritten IGMP dissector\n\tTvbuffified and bug-fixed RX and AFS dissectors\n\tSupport for filtering on absolute and relative time fields\n\tDVMRP support\n\tMRDISC support\n\tMSNIP support\n\tTvbuffified ISIS dissector\n\tTvbuffified SMB NETLOGON dissector\n\tTvbuffified SMB BROWSER dissector\n\tTCP segment reassembly and support for it in ONC RPC and NBSS\n\t    dissectors\n\tFilterable fields for XoT and RIP\n\tTimes in NFS done as FT_ABSOLUTE_TIME and FT_RELATIVE_TIME\n\tFT_UINT64 support, code to handle 64-bit integers without\n\t    requiring compiler support for them, and updates to the\n\t    Diameter, L2TP, NFS, and NLM dissectors to use it and to the\n\t    ONC RPC dissector to allow ONC RPC subdissectors to use it\n\tSMB tvbuffication and enhancement\n\tNDMPv3 support\n\tAdd time between request and reply as a field to ONC RPC replies\n\tFile handle to file name resolution in NFS and related protocols\n\tDCE RPC enhancements\n\tSAMR updates\n\tNETLOGON implementation\n\tLSA updates\n\tNFS AUTH stub implementation\n\tMAPI skeleton dissector\n\tDCE/RPC fragment reassembly\n\tTCP ACK/SEQ number analysis and relative sequence numbers\n\tTAP system and ONC RPC and DCE RPC examples\n\tDISTCC updates\n\tH225 and H245 dissectors and PER dissector helpers\n\tKerberos decryption\n\tPacketCable protocol\n}\n\nBorosa Tomislav         <tomislav.borosa[AT]SIEMENS.HR> {\n\tUpdates to mobile IPv6\n}\n\nAlexandre P. Ferreira   <alexandref[AT]tcoip.com.br> {\n\tWTLS support\n\tWSP fixes and enhancements\n}\n\nSimharajan Srishylam    <Simharajan.Srishylam[AT]netapp.com> {\n\tAssorted WCCP2 enhancements\n\tICAP support\n}\n\nGreg Kilfoyle           <gregk[AT]redback.com> {\n\tBOOTP option 82 (Relay Agent Information option) support\n}\n\nJames E. Flemer         <jflemer[AT]acm.jhu.edu> {\n\tHidden Boolean fields set if the IP or ICMP checksums are bad\n}\n\nPeter Lei               <peterlei[AT]cisco.com> {\n\tRFC 3024 reverse tunneling support for the Mobile IP dissector\n}\n\nThomas Gimpel           <thomas.gimpel[AT]ferrari.de> {\n\tFixes to the Q.931 dissector\n}\n\nAlbert Chin             <china[AT]thewrittenword.com> {\n\tFixes to Lemon to get it to compile on platforms (such as some\n\t    versions of Tru64 UNIX) that define TRUE and FALSE\n\tFixes for various non-GCC compiler warnings\n\tFix to TCP graph code to eliminate a GCCism\n\tSimplify some autoconf code\n\tAssorted cleanups\n\tAutoconf/automake cleanups\n}\n\nCharles Levert          <charles[AT]comm.polymtl.ca> {\n\tCUPS browsing protocol support\n}\n\nTodd Sabin              <tas[AT]webspan.net> {\n\tDCE RPC support\n\tCleaned up \"get_column_format_matches()\"\n\tSkeleton NSPI dissector\n}\n\nEduardo Pérez Ureta     <eperez[AT]dei.inf.uc3m.es> {\n\tGUI fixes\n}\n\nMartin Thomas           <martin_a_thomas[AT]yahoo.com> {\n\tSupport for TPKT being used for its original purpose (TCP port\n\t    102, containing OSI transport layer PDUs)\n\tHandle address lengths based on TOA bit in X.25\n}\n\nHartmut Mueller         <hartmut[AT]wendolene.ping.de> {\n\tBACNET support\n}\n\nMichal Melerowicz       <Michal.Melerowicz[AT]nokia.com> {\n\tGTP support\n\tGTPv1 support and GTPv0 improvements\n}\n\nHannes Gredler          <hannes[AT]juniper.net> {\n\tOSI network layer over PPP support\n\tMany IS-IS enhancements\n\tJuniper Networks vendor ID in RADIUS dissector\n\tHELLO message support in RSVP\n\tMany BGP enhancements and bug fixes\n\tFix display of OSI system IDs to use a dot rather than a dash\n\t    before the PSN byte\n\tDecode the sample rate factor in cflowd5 headers\n\tSupport OSI over CHDLC\n\tShow the type value for OSI protocols symbolically in GRE\n\tSupport MPLS over CHDLC\n\tBi-directional Fault Detection (BFD) support\n\tSupport for Juniper's DLT_JUNIPER_ATM1, DLT_JUNIPER_ATM2 values\n\tSupport for Juniper's PPPOE encapsulation\n}\n\nInoue                   <inoue[AT]ainet.or.jp> {\n\tPreference dialog crash fix\n}\n\nOlivier Biot            <obiot.ethereal[AT]gmail.com> {\n\tVarious WTP fixes and enhancements\n\tRewrite of much of WSP\n\tWBXML/WMLC support\n\tREADME.win32 updates for Cygwin\n\tUDH dissection in SMPP\n\tWTP-over-SMPP and WSP-over-SMPP\n\tGSM SMS, CBS and DCS support for the SMPP dissector\n\tDisplay filter operator: matches (PCRE syntax)\n\tCompuserve GIF image dissector\n\tJPEG File Interchange Format (JFIF) dissector\n\tDissector for message/http media type\n\tGeneric line-based textual data dissector\n\tMultipart media dissector\n\tDisplay filter operator: bitwise_and\n\tGeneric media dissector (in analogy to the data dissector)\n}\n\nPatrick Wolfe           <pjw[AT]zocalo.cellular.ameritech.com> {\n\tWTLS client and trusted key ID handling enhancements\n}\n\nMartin Held             <Martin.Held[AT]icn.siemens.de> {\n\tRANAP support\n}\n\nRiaan Swart             <rswart[AT]cs.sun.ac.za> {\n\tModbus/TCP support\n}\n\nChristian Lacunza       <celacunza[AT]gmx.net> {\n\tCommand-line option to control automatic scrolling in \"Update\n\t    list of packets in real time\" captures\n}\n\nScott Renfro            <scott[AT]renfro.org> {\n\tLDAP checks for invalid packets\n\t\"-t\" flag for editcap, to adjust timestamps in frames\n\tSSL/TLS support\n\tMergecap utility for merging capture files\n\tFixes for some calls to \"localtime()\" that didn't check whether\n\t   the call succeeded (it doesn't always do so on Windows, for\n\t   example)\n}\n\nJuan Toledo             <toledo[AT]users.sourceforge.net> {\n\tPassive FTP support\n}\n\nJean-Christian Pennetier <jeanchristian.pennetier[AT]rd.francetelecom.fr> {\n\tISIS IPv6 routing TLV dissection\n\tISIS traffic engineering TLV dissection\n\tIS neighbor and IP reachability TLVs given their own subtree\n\t    types\n\tAssorted other ISIS fixes\n}\n\nJian Yu                 <bgp4news[AT]yahoo.com> {\n\tBGP enhancements\n}\n\nEran Mann               <emann[AT]opticalaccess.com> {\n\tFix to LDP prefix FEC dissection for IPv4\n}\n\nAndy Hood               <ajhood[AT]fl.net.au> {\n\t\"--with-ssl\" configuration option, to use if UCD SNMP is\n\t   compiled with crypto support and needs -lcrypto\n\tOn Solaris, with GCC, add flags to reduce warnings from\n\t   inadequacies of function declarations in X11 headers\n\tTranslate enterprise OIDs in SNMP traps to strings if possible\n\tAODV6 dissector compile fixes for AIX\n}\n\nRandy McEoin            <rmceoin[AT]ahbelo.com> {\n\tAppletalk Data Stream Interface (used by AFP-over-TCP) support\n\tXyplex protocol support\n\tAvaya IPSI Control\n}\n\nEdgar Iglesias          <edgar.iglesias[AT]axis.com> {\n\tFix to TCP reassembly code for retransmitted data\n}\n\nMartina Obermeier       <Martina.Obermeier[AT]icn.siemens.de> {\n\tISUP (ISDN User Part, ITU-T recommendation Q.763) support\n}\n\nJavier Achirica         <achirica[AT]ttd.net> {\n\tIEEE 802.11 bug fixes and WEP support\n}\n\nB. Johannessen          <bob[AT]havoq.com> {\n\tGnutella support\n}\n\nThierry Pelle           <thierry.pelle[AT]laposte.net> {\n\tMP-BGP message support\n\tRedback vendor-specific items for RADIUS and L2TP\n\tIPv6CP support\n}\n\nFrancisco Javier Cabello <fjcabello[AT]vtools.es> {\n\tRFC 2250 MPEG1 support\n}\n\nLaurent Rabret          <laurent.rabret[AT]rd.francetelecom.fr> {\n\tLCP-over Ethernet and IPCP-over-Ethernet support (to handle\n\t    captures on Windows; PPP packets show up as Ethernet\n\t    packets, courtesy of NDISWAN, and apparently internal-to-PPP\n\t    protocols get passed through, with PPP protocol types\n\t    appearing in the Ethernet protocol type field)\n\tPAP support\n\tBGP bug fix\n\tISIS fixes and enhancements\n\tOPSI support\n}\n\nnuf si                  <gnippiks[AT]yahoo.com> {\n\tRTSP fixes\n}\n\nJeff Morriss            <jeff.morriss.ws[AT]gmail.com> {\n\tM2PA support\n\tSupport for ANSI flavor of MTP3\n\tSCCP support\n\tSCCP Management support\n\tMTP3 Management support\n\tSupport for China and Japan ITU SS7 variants\n\tSSCOP over UDP and SSCF-NNI support\n\tVarious bug fixes and enhancements\n}\n\nAamer Akhter            <aakhter[AT]cisco.com> {\n\tSupport for draft-rosen-vpn-ospf-bgp-mpls\n\tSupport for additional BGP extended communities\n\tLDP support for draft-martini-l2circuit-trans-mpls, LDP status\n\t    code updates, and small LDP cleanups\n\tLDP support for draft-martini-l2circuit-encap-mpls for\n\t    Ethernet-over-MPLS\n\tFix initialization of ett_slarp in CHDLC dissector\n\tLDP PWE updates\n}\n\nPekka Savola            <pekkas[AT]netcore.fi> {\n\tAutoconf support for glibc IPv6 support\n}\n\nDavid Eisner            <deisner[AT]gmail.com> {\n\tNCP-over-IP bug fix\n}\n\nSteve Dickson           <steved[AT]talarian.com> {\n\tPGM (Pragmatic General Multicast) support\n}\n\nMarkus Seehofer         <Markus.Seehofer[AT]hirschmann.de> {\n\tGMRP support\n\tIEEE 1588 / PTP version 2 support\n}\n\nLee Berger              <lberger[AT]roy.org> {\n\tFix to FT_UINT_STRING handling\n}\n\nMotonori Shindo         <motonori[AT]shin.do> {\n\tShiva PAP, EAP, and CBCP negotiation in LCP Callback Operation\n\t    support in PPP dissector\n\tSupport for decoding additional data, for CHAP, in LCP\n\t    Authentication Protocol option\n\tAdditional vendor (CoSine) for Radius\n\tCoSine VSA support for Radius\n\tPatches to PPP for CHAP support\n\tPatches to packet-x11-keysym.h to clean up 8-bit chars\n\tFixes to take the Vendor-Specific attribute into consideration\n\t    when dissecting L2TP\n\tL2TP Disconnect Cause Information AVP support\n\tPPP CCP support\n\tPPP compressed packet support\n\tAssorted BGP improvements\n\tCBCP support in PPP\n\tFix Ascend/Lucent trace reading code to handle later trace\n\t    formats that have an ASCII dump at the end of the line\n\tGet rid of \"send output to /dev/null\" hack in Ascend/Lucent\n\t   trace reading code's Flex scanner\n\tBACP and BAP support in PPP dissector\n\tAdd necessary cast in TCP graph code\n\tFix up the generation of PDB files, clean them up on a \"nmake -f\n\t    makefile.nmake clean\", and put all the PDB files into the\n\t    Windows binary distribution\n\tDelete installed data files on a Windows uninstallation\n\tOSPF fixes\n\tSupport for reading CoSine L2 debug output\n\tAssorted LDP enhancements and fixes\n\tKey Information dissection in EAPOL-Key messages\n\tsFlow/NetFlow/IPFIX dissector enhancement\n}\n\nTerje Krogdahl          <tekr[AT]nextra.com> {\n\tAdditional AVPs, and Event-Timestamp support, in RADIUS\n}\n\nJean-Francois Mule      <jfm[AT]cablelabs.com> {\n\tAdditional SIP methods\n}\n\nThomas Wittwer          <thomas.wittwer[AT]iclip.ch> {\n\tHTTP dissector registered by name\n\t\"prefs_register_string_preference()\" made available to plugins\n\tRemove unnecessary calls to \"prefs_module_foreach()\"\n\tSupport for stopping capture at specified capture file size or\n\t    capture duration\n}\n\nMatthias Nyffenegger    <matthias.nyffenegger[AT]iclip.ch> {\n\tSupport for stopping capture at specified capture file size or\n\t    capture duration\n}\n\nPalle Lyckegaard        <Palle[AT]lyckegaard.dk> {\n\tOSPFv3 support\n}\n\nNicolas Balkota         <balkota[AT]mac.com> {\n\tGTPv1 support and GTPv0 improvements\n}\n\nTom Uijldert            <Tom.Uijldert[AT]cmg.nl> {\n\tWTP fixes\n\tMMSE support\n\tPush-traffic dissecting for WSP/WTLS\n\tUCP support\n\tSMPP support\n\tmultipart-content support in WSP/MMSE\n\tWTP reassembly\n\tWTP TPI dissection\n}\n\nAkira Endoh             <endoh[AT]netmarks.co.jp> {\n\tSupport for dissecting multiple BGP capabilities\n\tSync PPP protocol names with the IANA database\n\tMPLSCP, CDPCP, and CDP over PPP support\n\tBGP support for draft-ietf-idr-as4bytes-06.txt and\n\t    draft-ietf-idr-dynamic-cap-03.txt\n\tWellfleet Breath of Life support\n\tRSVP support for draft-ietf-mpls-nodeid-subobject-00.txt, and\n\t    other bug fixes and enhancements\n\tDiffserv MPLS signaling protocol support\n\tIGAP support\n}\n\nGraeme Hewson           <ghewson[AT]wormhole.me.uk> {\n\tAdditional Ascend codes, and IETF codes, for Radius\n\tFix various capture problems\n\tAdd some sanity checks to DNS dissector to avoid loops\n\tCommand-line interface cleanups\n\tVarargs code cleanup in \"simple_dialog.c\"\n\tMake dialog box pop up only after a minimum period of time\n}\n\nPasi Eronen             <pe[AT]iki.fi> {\n\tPatches to the dcerpc dissector for data representation decoding\n\tXDMCP support\n\tSupport for PCT cipher suites and record layer in SSL\n\tDissect the packet inside an LCP Protocol-Reject message\n}\n\nGeorg von Zezschwitz    <gvz[AT]2scale.net> {\n\tWSP fixes\n\tSupport for concatenated PDUs\n\tPut URL of WSP GET/POST in the Info column\n\tFix a bug with WSP Connect requests with headers > 256 bytes\n\tImplement attributes of WSP Suspend/Resume\n}\n\nSteffen Weinreich       <steve[AT]weinreich.org> {\n\tUCP fixes\n}\n\nMarc Milgram            <ethereal[AT]mmilgram.NOSPAMmail.net> {\n\tVMS TCPIPtrace wiretap module\n\tDBS Etherwatch wiretap module\n}\n\nGordon McKinney         <gordon[AT]night-ray.com> {\n\tEnhanced Ethereal icon for Windows\n\tSupport for time stamping packets in text2pcap\n\tFix to text2pcap to handle colons after offset field\n\tMake IP-over-PPP work with the TCP graph code\n}\n\nPavel Novotny           <Pavel.Novotny[AT]icn.siemens.de> {\n\tAdditional items for RADIUS tunnels\n}\n\nShinsuke Suzuki         <suz[AT]kame.net> {\n\tDHCPv6 and PIM enhancements\n\tIPv6 payload for GRE\n\tMLDv2 enhancements\n}\n\nAndrew C. Feren         <acferen[AT]yahoo.com> {\n\tMakefile fix\n\tSolaris packaging fixes\n\tAdd ifdefs to the top-level Makefile.nmake to avoid using\n\t    Python if PYTHON isn't defined\n\tmake-manuf fix\n\tPut all of Cisco's OUIs into manuf.tmpl\n\tPut human-readable descriptions in the combo box entries for\n\t    \"Interface:\" on Windows\n\tntop nProbe and Plixer Mailinizer extensions for the Netflow dissector\n}\n\nTomas Kukosa            <tomas.kukosa[AT]siemens.com> {\n\tAdditional routines made available to plugins\n\tSupport for registering subdissectors for Q.931 IEs and codesets\n\tReassembly of segmented Q.931 messages\n\tASN2WRS compiler to convert ASN.1 definitions to PER/DER dissectors\n\tH.323 family dissectors (H.225.0, H.245, H.235, H.450, H.460)\n\tQSIG\n\tPlugin API for codecs (for RTP player)\n}\n\nAndreas Stockmeier      <a.stockmeier[AT]avm.de> {\n\tIPCOMP transformation and ID_IPV4_ADDR_SUBNET for ISAKMP\n\tFix the file dialog box code to use \"g_strdup()\", not \"strdup()\"\n\t    to copy strings\n}\n\nPekka Nikander          <pekka.nikander[AT]nomadiclab.com> {\n\tIEEE 802.1x, a/k/a EAPOL\n\tPPP/EAPOL EAP support\n}\n\nHamish Moffatt          <hamish[AT]cloud.net.au> {\n\tMPLS support for handling either IPv4 or IPv6 as the payload\n\t    protocol type\n\tWin32 Makefile fixes\n\tUse pod2html rather than man2html to build HTML man pages\n\tFix ethereal.nsi.in for recent versions of NSIS\n}\n\nKazushi Sugyo           <k-sugyou[AT]nwsl.mesh.ad.jp> {\n\tFix to display of AH length field\n\tFix to code to scan the SIOCGIFCONF list\n}\n\nTim Potter              <tpot[AT]samba.org> {\n\tSupport for DCE RPC atop SMB\n\tSupport for several Microsoft DCE RPC services used with SMB\n\tAdded code to call request and reply subdissectors in DCE RPC\n\tDisplay the FID in the Info column of NT Create and X replies\n\tDisplay the setup words in some SMB Transaction messages and\n\t    extract the FID from them\n\tUse the FID, for DCE RPC-over-SMB, as part of the conversation\n\t   matching\n\tAssorted SMB fixes\n\tNT SID dissection\n}\n\nRaghu Angadi            <rangadi[AT]inktomi.com> {\n\tWCCP capability info dissection bug fix\n}\n\nTaisuke Sasaki          <sasaki[AT]soft.net.fujitsu.co.jp> {\n\tOSPF fixes\n}\n\nTim Newsham             <newsham[AT]lava.net> {\n\tSupport for 802.11+Prism II monitor-mode link-layer headers\n}\n\nTom Nisbet              <Tnisbet[AT]VisualNetworks.com> {\n\tSupport for reading Visual Networks traffic capture files\n\tSLIMP3 protocol version 2 support\n}\n\nDarren New              <dnew[AT]san.rr.com> {\n\tBXXP dissector modified to be a BEEP dissector\n}\n\nPavel Mores             <pvl[AT]uh.cz> {\n\tTCP time-sequence, round-trip time, and throughput graphs\n}\n\nBernd Becker            <bb[AT]bernd-becker.de> {\n\tSupport for LOCATION_FORWARD, LOCATION_FORWARD_PERM and\n\t    NEEDS_ADDRESSING_MODE replies in GIOP\n\tethereal_gen.py cleanups\n\tReset the Protocol column to GIOP if no heuristic dissectors\n\t    succeed\n\tEnhancements to TNS dissector, including desegmentation\n\tGIOP fixes\n}\n\nHeinz Prantner          <Heinz.Prantner[AT]radisys.com> {\n\tM2TP support\n}\n\nIrfan Khan              <ikhan[AT]qualcomm.com> {\n\tpppdump reader fixes\n\tVan Jacobson decompression support for PPP\n}\n\nJayaram V.R             <vjayar[AT]cisco.com> {\n\tPPP multiplexing support\n}\n\nDinesh Dutt             <ddutt[AT]cisco.com> {\n\tSCSI dissector, for use by iSCSI and other protocols that\n\t    transport SCSI operations\n\tFibre Channel (over IP) support, and support for various\n\t    protocols running atop FC\n\tCisco MDS switch Debug Port Adapter (Boardwalk)\n\t    FC-inside-Ethernet dissector\n\tCisco MDS switch internal FC-inside-Ethernet dissector\n}\n\nNagarjuna Venna         <nvenna[AT]Brixnet.com> {\n\tOnly display the reason in BYE RTCP packets if it's present\n\tSupport for RTCP-XR support as in RFC 3611\n}\n\nJirka Novak             <j.novak[AT]netsystem.cz> {\n\tSupport for generating filter expressions based on packet list\n\t    column values\n\tSupport for adding filter expressions generated from column or\n\t    protocol tree field values to the current expression rather\n\t    than replacing the current expression\n\tSupport for hex dump mode in \"Follow TCP Stream\" window showing\n\t    hex and ASCII data\n}\n\nRicardo Barroetaveña    <rbarroetavena[AT]veufort.com> {\n\tEnhanced LDP support\n\tSupport TCP reassembly requiring multiple steps (e.g.,\n\t    reassemble the PDU header to get the length of the PDU, then\n\t    reassemble the PDU based on that length)\n}\n\nAlan Harrison           <alanharrison[AT]mail.com> {\n\tFixes to EtherPeek file reader code\n}\n\nMike Frantzen           <frantzen[AT]w4g.org> {\n\tSupport for capturing on, and reading captures from, OpenBSD\n\t    firewall logging virtual interface\n}\n\nCharlie Duke            <cduke[AT]fvc.com> {\n\tAdded routines to the plugin table\n}\n\nAlfred Arnold           <Alfred.Arnold[AT]elsa.de> {\n\tIAPP support\n}\n\nDermot Bradley          <dermot.bradley[AT]openwave.com> {\n\tSupport for Openwave-specific WSP headers\n\tSupport for Openwave-specific WSP field names\n\tSupport for additional WSP content types from Openwave\n\tSupport for additional WSP language values\n}\n\nAdam Sulmicki           <adam[AT]cfar.umd.edu> {\n\tAdd more type values for EAP.\n\tFix off-by-one bug when displaying Code of EAP message.\n\tAdditional AVPs for RADIUS, and making RD_TP_CONNECT_INFO a\n\t    RADIUS_STRING rather than a RADIUS_STRING_TAGGED\n\tDissect EAP messages inside RADIUS\n\tDissect SSL-encoded stuff inside EAP\n\tCisco LEAP support\n\tEAP-TLS reassembly\n\tOther EAP enhancements\n}\n\nKari Tiirikainen        <kari.tiirikainen[AT]nokia.com> {\n\tCOPS-PR extension support\n\tSupport for reading MIBs containing converted PIBs in COPS\n\t    dissector\n}\n\nJohn Mackenzie          <John.A.Mackenzie[AT]t-online.de> {\n\tPut missing initializations of table entries in \"plugins.c\"\n\tRegister GIOP dissector as a UDP heuristic dissector\n}\n\nPeter Valchev           <pvalchev[AT]openbsd.org> {\n\tFix editcap to assign the result of \"getopt()\" to an \"int\" and\n\t   to check \"getopt()\"s return value with -1 rather than EOF\n}\n\nAlex Rozin              <Arozin[AT]mrv.com> {\n\tSupport for IEEE 802.1w RST BPDUs\n}\n\nJouni Malinen           <jkmaline[AT]cc.hut.fi> {\n\t802.11 authentication frame dissection bug fix\n\tFix offset of challenge element in 802.11 dissector\n\tShow fragmented 802.11 frames as fragments\n\tEAP bug fix for NAK packets\n\tEAP-MD5, EAP-SIM, EAP-PEAP, and EAP-MSCHAPv2 support\n\t802.11g element support\n\t802.11i enhancements\n\tNew WSC 2.0 attributes and values support\n\tWi-Fi Alliance P2P dissector\n}\n\nPaul E. Erkkila         <pee[AT]erkkila.org> {\n\tSkinny Client Control Protocol enhancements\n\tHazelcast Dissector\n}\n\nJakob Schlyter          <jakob[AT]openbsd.org> {\n\tSIP method additions\n}\n\nJim Sienicki            <sienicki[AT]issanni.com> {\n\tAdditional vendor (Issani) for Radius\n\tIssani VSA support for Radius\n}\n\nSteven French           <sfrench[AT]us.ibm.com> {\n\tAdd names for some additional spool service RPCs\n\tDecode NT Rename SMB\n}\n\nDiana Eichert           <deicher[AT]sandia.gov> {\n\t\"-q\" flag to Tethereal to suppress packet count display\n}\n\nBlair Cooper            <blair[AT]teamon.com> {\n\tWebDAV support\n}\n\nKikuchi Ayamura         <ayamura[AT]ayamura.org> {\n\tInclude <ucd-snmp/ucd-snmp-config.h> to fix IRIX compilation\n\t    problems\n}\n\nDidier Gautheron        <dgautheron[AT]magic.fr> {\n\tX11 bug fix\n\tAppleTalk Transaction Protocol, AppleTalk Stream Protocol, and\n\t    AppleTalk Filing Protocol support\n\tDSI updates\n\t\"frame.marked\" field set on marked frames\n\tDon't show progress bar for quick \"Find Frame\" searches\n\tAdd \"Find Next\" and \"Find Previous\" to repeat searches\n\tMove port number from AppleTalk addresses to separate column\n\tPut in hidden fields for AppleTalk source and destination\n\t    addresses\n\tAppleTalk Zone Information Protocol support\n\tFix to work with automake 1.7\n\tFix gtk Makefile entry to rebuild \"ethereal-tap-register.c\"\n\tFix handling of cross in TCP graph code\n\tFix sequence number overflow problems in TCP graph code and\n\t    desegmentation code\n\tDon't update the progress bar too often (only every 100ms)\n}\n\nPhil Williams           <csypbw[AT]comp.leeds.ac.uk> {\n\tSupport for looking up fields by name\n}\n\nKevin Humphries         <khumphries[AT]networld.com> {\n\tAdditional PIM hello options support\n}\n\nErik Nordström          <erik.nordstrom[AT]it.uu.se> {\n\tAODV dissection support\n}\n\nDevin Heitmueller       <dheitmueller[AT]netilla.com> {\n\tAdditional RAP error code\n\tGive the user a warning if they click \"New\" in the filter list\n\t    editing code without having specified a filter name and string\n\tFix to treat the \"send buffer length\" in SMB RAP messages as\n\t    being present in the packet\n\tDissection of NTLMSSP authentication for DCERPC\n\tShow proper field names for SAMR UnicodeChangePassword2\n\tAdd MD4 and RC4 crypto support\n\tDecrypt the NT password encryption block in\n\t    UnicodeChangePassword2\n\tSupply offset to dissectors for connection-oriented DCERPC PDU\n\t    types\n\tSupport for decrypting DCERPC conversations using NTLMSSP\n\t    version 1\n\tAIM enhancements\n\tFollow TCP Stream support for showing stream data as C byte\n\t    arrays\n\tYMSG desegmentation\n}\n\nChenjiang Hu            <chu[AT]chiaro.com> {\n\tISIS bug fix for dissecting unreserved bandwidths\n}\n\nKan Sasaki              <sasaki[AT]fcc.ad.jp> {\n\tVSA decoding and other changes to RADIUS\n}\n\nStefan Wenk             <stefan.wenk[AT]gmx.at> {\n\tSIP heuristic dissector\n\tFilterable header fields in SIP dissector\n}\n\nRuud Linders            <ruud[AT]lucent.com> {\n\tReport errors from \"g_module_open()\"\n\tHeuristic version of the RTP dissector\n}\n\nAndrew Esh              <Andrew.Esh[AT]tricord.com> {\n\tSupport for additional interest levels in\n\t    TRANS2_QUERY_FS_INFORMATION, and fix handling of level 1022\n\t    to treat the file name as always being in Unicode\n\tFix a compiler warning\n\tTypo fix in iSCSI dissector\n}\n\nGreg Morris             <GMORRIS[AT]novell.com> {\n\tNCP - NetWare Core Protocol\n\tNDPS - Novell Distributed Print System\n\t\"Find Frame\" code to search for text or binary data\n\tSRVLOC-over-TCP support\n}\n\nDirk Steinberg          <dws[AT]dirksteinberg.de> {\n\tFixes to BGP problems\n}\n\nKari Heikkila           <kari.o.heikkila[AT]nokia.com> {\n\tFix for WTP PDUs not containing user data\n}\n\nOlivier Dreux           <Olivier.Dreux[AT]alcatel.fr> {\n\tAdd PPP support to GTP\n}\n\nMichael Stiller         <ms[AT]2scale.net> {\n\tJava RMI protocol support\n}\n\nAntti Tuominen          <ajtuomin[AT]tml.hut.fi> {\n\tAODV6 support\n}\n\nMartin Gignac           <lmcgign[AT]mobilitylab.net> {\n\tVarious MMSE fixes\n}\n\nJohn Wells              <wells[AT]ieee.org> {\n\tMIP fix.\n}\n\nLoic Tortay             <tortay[AT]cc.in2p3.fr> {\n\tDisplay AFS KAUTH information\n}\n\nSteve Housley           <Steve_Housley[AT]eur.3com.com> {\n\t802.3ad LACP support\n}\n\nPeter Hawkins           <peter[AT]hawkins.emu.id.au> {\n\tVarious bounds-check fixes\n}\n\nBill Fumerola           <billf[AT]FreeBSD.org> {\n\tRecognize \"Option negotiated failed\" error in TFTP\n\tRewritten Cisco NetFlow protocol support\n}\n\nChris Waters            <chris[AT]waters.co.nz> {\n\tDon't use \"bool\" as a variable name or structure member, as it's\n\t    a C++ keyword\n\tCheck 802.11 FCS if present\n\tPut the \"wlan.fc.fromds\" and \"wlan.fc.tods\" fields into the\n\t    protocol tree\n\tExport \"find_dissector_table()\" and add\n\t    \"dissector_handle_get_protocol_index()\"\n\tSupport Tazmen Sniffer Protocol and DLT_TZSP captures from\n\t    network-based libpcaps that use that protocol\n\tMSN Messenger support\n}\n\nSolomon Peachy          <pizza[AT]shaftnet.org> {\n\tWEP support and other mangling of the 802.11 dissector\n\tSupport for new \"wlancap\" 802.11 extra-information header\n}\n\nJaime Fournier          <Jaime.Fournier[AT]hush.com> {\n\tHandle DCE RPC connectionless CANCEL PDUs with no body\n\tDCE/RPC stub dissectors for RSEC_LOGIN, RS_ACCT, RS_ATTR, RS_MISC,\n\t\tRS_PGO, RS_REPLIST, RS_UNIX, RPRIV, ROVERRIDE, RS_REPADM,\n\t\tDTSSTIME_REQ, CDS_SOLICIT, CPRPC_SERVER, DTSPROVIDER,\n\t\tUBIKDISK, UBIKVOTE, BOSSVR, FTSERVER, CDS_CLERKSERVER,\n\t\tKRB5RPC, REP_PROC, SECIDMAP, TKN4INT, FLDB, AFS4INT,\n\t\tUPDATE, BUDB, BUTC, RS_BIND, RS_PLCY, ICL RPC,\n\t\tRS_PROP_ACCT, LLB, RDACLIF, RS_ATTR_SCHEMA, RS_PROP_ACL,\n\t\tRS_PROP_ATTR, RS_PROP_PGO, RS_PROP_PLCY, RS_PWD_MGMT,\n\t\tRS_REPMGR\n\tDCE RPC EPM version 4 support\n}\n\nMarkus Steinmann        <ms[AT]seh.de> {\n\tAdd IPX SAP for SEH's InterCon Printserver\n\tSupport for writing LANalyzer files\n}\n\nTsutomu Mieno           <iitom[AT]utouto.com> {\n\tDHCPv6 updates\n}\n\nYasuhiro Shirasaki      <yasuhiro[AT]gnome.gr.jp> {\n\tDHCPv6 updates\n}\n\nAnand V. Narwani        <anand[AT]narwani.org> {\n\tgtk/Makefile.am fix\n\tDOCSIS support, including support for \"Ethernet\" captures where\n\t    the raw frame is a DOCSIS frame rather than an Ethernet\n\t    frame (some Cisco cable-modem head-end gear can send out a\n\t    trace of all traffic on an Ethernet, but what it sends are\n\t    the raw bytes of DOCSIS frames, not Ethernet frames)\n}\n\nChristopher K. St. John <cks[AT]distributopia.com> {\n\tApache JServ Protocol v1.3 support\n}\n\nNix                     <nix[AT]esperi.demon.co.uk> {\n\tDon't add \"-I/usr/include\" to CFLAGS or CPPFLAGS\n\tExpand the plugin directory path at install time\n}\n\nLiviu Daia              <Liviu.Daia[AT]imar.ro> {\n\tFix to eliminate crash when setting \"column.format\" preference\n\t    from the command line\n}\n\nRichard Urwin           <richard[AT]soronlin.org.uk> {\n\tDeveloper documentation fixes and updates\n\tSupport for a system-wide color filter file and color filter\n\t    import and export\n}\n\nPrabhakar Krishnan      <Prabhakar.Krishnan[AT]netapp.com> {\n\tAdd item to SMB protocol tree for time between request and\n\t    response\n\tDissect NetApp ONTAP file handles\n}\n\nJim McDonough           <jmcd[AT]us.ibm.com> {\n\tEnhancements to SMB and the DCE RPC-based protocols used by SMB\n\tNTLMSSP updates\n}\n\nSergei Shokhor          <sshokhor[AT]uroam.com> {\n\tBugfix for EPM\n}\n\nHidetaka Ogawa          <ogawa[AT]bs2.qnes.nec.co.jp> {\n\tFix PPP FCS computation to include address and control field if\n\t    present\n}\n\nJan Kratochvil          <short[AT]ucw.cz> {\n\tFix to MMSE handling of strings with specified character set\n}\n\nAlfred Koebler          <ak[AT]icon-sult.de> {\n\tSupport for interpreting Ethernet captures as CheckPoint\n\t    FireWall-1 monitor files (those files look like snoop\n\t    files for Ethernet)\n}\n\nVassilii Khachaturov    <Vassilii.Khachaturov[AT]comverse.com> {\n\tPut protocol blurbs into tables generated with the \"-G fields\"\n\t    flag\n}\n\nBill Studenmund         <wrstuden[AT]wasabisystems.com> {\n\tFix handling of SCSI mode sense\n}\n\nBrian Bruns             <camber[AT]ais.org> {\n\tTDS\n}\n\nFlavio Poletti          <flavio[AT]polettix.it> {\n\tFix bug in decoding of maximum uplink and downlink rate in GTP\n\t    v1\n\tHandle 3GPP QoS in RADIUS messages\n}\n\nMarcus Haebler          <haeblerm[AT]yahoo.com> {\n\tHandle a sub-protocol field of 0x00 as PPP\n}\n\nUlf Lamping             <ulf.lamping[AT]web.de> {\n\tPut \"bytes\" after the byte counts for the frame sizes in the\n\t    top-level item for the \"Frame\" protocol\n\tPut the source and destination MAC addresses into the top-level\n\t    item for Ethernet\n\tAdded more information to progress dialog box\n\tChange some #define names to avoid name collisions on Windows\n\t    that cause compiler warnings\n\tDecoding of IEEE float and doubles for DCE-RPC\n\tWin32 fixes\n\tCount ARP packets in capture progress dialog box\n\tShow total running time of capture in capture progress dialog box\n\tToolbar\n\tRedesign of the print dialog\n}\n\nMatthew Smart           <smart[AT]monkey.org> {\n\tOriginal Cisco NetFlow protocol support\n\tPartial NetFlow V9 support\n}\n\nLuke Howard             <lukeh[AT]au.padl.com> {\n\tNETLOGON bugfix for LogonGetDomainInfo\n\tVarious NETLOGON fixes\n}\n\nPC Drew                 <drewpc[AT]ibsncentral.com> {\n\tDissector for the FIX protocol\n}\n\nRenzo Tomas             <renzo.toma[AT]xs4all.nl> {\n\tSkinny bugfix for configStat and serverRes\n}\n\nClive A. Stubbings      <eth[AT]vjet.demon.co.uk> {\n\t802.1s Multiple Spanning Tree Protocol\n}\n\nSteve Langasek          <vorlon[AT]netexpress.net> {\n\tSupport for MS SQL 7 authentication in TDS\n}\n\nBrad Hards              <bhards[AT]bigpond.net.au> {\n\tSupport for SRVLOC v2\n\tSupport for mDNS/LLMNR \"cache flush\" bit\n\tLabel mDNS and DNS differently in the Protocol column\n\tClean up summary line for PTR records\n\tInitial rsync support\n\tACAP support\n\tDISTCC support\n\tJabber client-to-server protocol support\n\tInitial Laplink support\n}\n\ncjs 2895                <cjs2895[AT]hotmail.com> {\n\tCompile fixes for IBM's C compiler for AIX\n\tFix configure check for pcap_version\n}\n\nLutz Jaenicke           <Lutz.Jaenicke[AT]aet.TU-Cottbus.DE> {\n\tFix an \"htonl()\" to use \"g_htonl()\"\n}\n\nSenthil Kumar Nagappan  <sknagappan[AT]yahoo.com> {\n\tSmall SCSI dissector fix\n\tSmall OSPF dissector enhancement\n}\n\nJason House             <jhouse[AT]mitre.org> {\n\tWin32 compilation fixes\n\tTAP support for TCP protocol\n}\n\nPeter Fales             <psfales[AT]lucent.com> {\n\tARCNET support\n}\n\nFritz Budiyanto         <fritzb88[AT]yahoo.com> {\n\tAssorted GTP fixes\n}\n\nJean-Baptiste Marchand  <Jean-Baptiste.Marchand[AT]hsc.fr> {\n\tMake it possible to filter on UUIDs\n\tFix typo in README.developer\n\tAdded an MSRPC (DCERPC) atsvc dissector\n\tAdded descriptions of permissions for SAM_SERVER and SAM_USER\n\t    objects in SAMR\n\tFix for NETLOGON/DsrGetSiteName and other NETLOGON functions\n\tInitial DRSUAPI (Active Directory directory replication) support\n\tChanged or added procedure names for a number of DCE RPC\n\t    interfaces\n\tEncryptedFileSystem (EFS) support.\n\tMS Eventlog support\n\tWKSSVC enhancements\n\tFile Replication Services (frsrpc and frsapi) support\n\tStub dissectors for rras and pnp MSRPC interfaces\n}\n\nAndreas Trauer          <andreas.trauer[AT]siemens.com> {\n\tGTP enhancements\n\tAdd subtrees for each link in a Router-LSA in an OSPF LS Update\n\t    packet\n\tDissect the L2TP AVPs Initial Received LCP CONFREQ, Last\n\t    Received LCP CONFREQ, Last Sent LCP CONFREQ\n}\n\nRonald Henderson        <Ronald.Henderson[AT]CognicaseUSA.com> {\n\tIn LDAP dissector, handle Sequence Of header being split across\n\t    TCP segments\n\tSupport for colored graphs in Gtk1 version of IO_STAT\n\tMake labels for filters in IO_STAT dialog box be \"Filter:\"\n\t    buttons to pop up a filter dialog\n\tFix up \"snprintf()\" and \"vsnprintf()\" calls in \"epan/proto.c\" to\n\t    properly handle string truncation\n\tMake \"format_text()\", on Windows, escape all characters that\n\t    aren't printable ASCII, as GTK+ for Windows thinks strings\n\t    are UTF-8 but the strings we give it wouldn't be UTF-8\n}\n\nBrian Ginsbach          <ginsbach[AT]cray.com> {\n\t\"dissect_rpc_bytes()\" routine to allow fixed-length opaque data\n\t    to be dissected\n\tSupport for SGI's variant of the ONC RPC mount protocol\n\tSupport for additional snoop file encapsulations in UNICOS/mp\n\tSymbolic names for Fibre Channel Network Address Authority\n\t    identifiers\n}\n\nDave Richards           <d_m_richards[AT]comcast.net> {\n\tBACNET over 802.2\n\tBACNET-over-ARCNET fix (it's really BACNET-over-802.2-over-ARCNET)\n}\n\nMartin Regner           <martin.regner[AT]chello.se> {\n\tRPC bug fix\n\tPIM bug fixes\n}\n\nJason Greene            <jason[AT]inetgurus.net> {\n\tFix for LDAPv3 modrdn requests\n}\n\nMarco Molteni           <mmolteni[AT]cisco.com> {\n\tFix a comment to reflect reality\n}\n\nJames Harris            <jharris[AT]fourhorsemen.org> {\n\tRADIUS user password decryption\n}\n\nrmkml                   <rmkml[AT]wanadoo.fr> {\n\tSupport for capturing from a pipe in Tethereal\n}\n\nAnders Broman           <a.broman58[AT]gmail.com> {\n\tAdditional SCTP payload protocol identifiers\n\tAssorted ISUP enhancements\n\tMEGACO updates and fixes\n\tT.35 country code support for H.245\n\tBICC dissection\n\tMultipart media dissector\n\tE.164 number dissector\n\tAssorted SIP enhancements\n\tAssorted DIAMETER enhancements\n\tSIP-T dissection\n\tPoC1 Application dissection in RTCP\n\tInitial SIGCOMP support\n\tUMA dissection\n\tParlay dissection\n\tRANAP by asn2eth\n\tRNSAP dissection\n\tNBAP dissection\n\tMSRP dissection\n\tInitial TIPC support\n\tBSSAP+ dissection\n\tULP dissection\n\tRRLP Dissection\n\tLDAP by asn2wrs\n\tSNMP by asn2wrs\n\tS1AP by asn2wrs\n\tX2AP by asn2wrs\n\tRRC by asn2wrs\n\tANSI TCAP by asn2wrs\n\tCAMEL by asn2wrs\n\tINAP by asn2wrs\n\tPCAP by asn2wrs\n\tH264 dissection\n\tAMR dissection\n\tMP4V-ES dissection\n\tNAS EPS dissection\n\tGTPv2 dissection\n\tSGsAP dissection\n\tWork on the initial version of the new packet list\n\tROHC dissection\n\tMiscellaneous enhancements and fixes\n}\n\nChristian Falckenberg   <christian.falckenberg[AT]nortelnetworks.com> {\n\tInitial MEGACO support\n\tGPRS SNDCP support\n}\n\nHuagang Xie             <xie[AT]lids.org> {\n\tMySQL support\n\tSSH support\n}\n\nPasi Kovanen            <Pasi.Kovanen[AT]tahoenetworks.fi> {\n\tDisplay flow label IE in GTP v0 in hex\n}\n\nTeemu Rinta-aho         <teemu.rinta-aho[AT]nomadiclab.com> {\n\tDraft 20 MIPv6 support\n}\n\nMartijn Schipper        <mschipper[AT]globespanvirata.com> {\n\tFix for tag for 802.11g ERP Information field\n\tSupport for reading AiroPeek files in V9 capture file format\n\t(AiroPeek 2.x)\n}\n\nWayne Parrott           <wayne_p[AT]pacific.net.au> {\n\tYahoo Messenger YMSG protocol support\n}\n\nLaurent Meyer           <laurent.meyer6[AT]wanadoo.fr> {\n\tX.25 reassembly\n\tFilterable fields in COTP\n\tCOTP reassembly\n}\n\nLars Roland             <Lars.Roland[AT]gmx.net> {\n\tMGCP request/response matching and MGCP statistics tap\n\tCommon routines for use by statistics taps\n\tH.225 message and reason tag counter taps and Service Response\n\t    Times\n\tTethereal version of SIP statistics tap\n\tSupport for building libethereal.dll with MSVC\n}\n\nMiha Jemec              <m.jemec[AT]iskratel.si> {\n\tSupport to follow a RTP stream and save it as a file.\n\tSupport for G.711 codec\n\tOriginal RTP analysis tap\n}\n\nMarkus Friedl           <markus[AT]openbsd.org> {\n\tSupport for OpenBSD Encapsulating Device\n\tSupport for Ethernet-within-IP encapsulation\n\tRemove duplicate SSH code\n}\n\nTodd Montgomery         <tmontgom[AT]tibco.com> {\n\tUpdate PGM to RFC 3208\n}\n\nemre                    <emre[AT]flash.net> {\n\t\"Filter out this stream\" feature for Follow TCP Stream\n}\n\nStephen Shelley         <steve.shelley[AT]attbi.com> {\n\tFull payload dissection of compliance levels 0, 1 and 2 function\n\t    codes for Modbus/TCP\n}\n\nErwin Rol               <erwin[AT]erwinrol.com> {\n\tArtNET support\n\tRTNET support\n\tACN support\n\tENTTEC and RDM support\n\tMonotone support\n}\n\nDuncan Laurie           <duncan[AT]sun.com> {\n\tIPMI-over-LAN support (IPMI, RMCP, partial ASF)\n}\n\nTony Schene             <schene[AT]pcisys.net> {\n\tInitial stub Kerberos kadmin support\n\tKerberos-over-TCP support\n\tAUTH_GSSAPI support\n}\n\nMatthijs Melchior       <mmelchior[AT]xs4all.nl> {\n\tTCP support in text2pcap\n\tSupport for automatically generating all declarations and\n\t    definitions for plugin ABI from a single file\n\tSupport for registering fields after all the protocol\n\t    registration routines are called\n\tGeneric ASN.1 dissection plugin\n}\n\nGarth Bushell           <gbushell[AT]elipsan.com> {\n\tiSNS support\n}\n\nMark C. Brown           <mbrown[AT]hp.com> {\n\tImprovements to code that reads HP-UX nettl files\n\tCisco Port Aggregation Protocol support\n\tNettl dissector\n}\n\nCan Erkin Acar          <canacar[AT]eee.metu.edu.tr> {\n\tSupport for new DLT_PFLOG format\n}\n\nMartin Warnes           <martin.warnes[AT]ntlworld.com> {\n\tSupport for VMS UCX$TRACE output in wiretap\n}\n\nJ Bruce Fields          <bfields[AT]fieldses.org> {\n\tSome work on packet_rpc.c to support RPCSEC_GSS\n}\n\ntz                      <tz1[AT]mac.com> {\n\tDecode the base-64 string for HTTP Basic authorization\n}\n\nJeff Liu                <jqliu[AT]broadcom.com> {\n\tWPA and WPA IE support\n}\n\nNiels Koot              <Niels.Koot[AT]logicacmg.com> {\n\tSupport for subdissectors in SUA\n\tAssorted SUA fixes\n\tDBS Etherwatch file reader enhancements\n}\n\nLionel Ains             <lains[AT]gmx.net> {\n\t\"-d\" flag for decode-as support in Tethereal\n}\n\nJoakim Wiberg           <jow[AT]hms-networks.com> {\n\tSupport for Common Industrial Protocol over IP\n}\n\nJeff Rizzo              <riz[AT]boogers.sf.ca.us> {\n\tsFlow support\n}\n\nChristoph Wiest         <ch.wiest[AT]tesionmail.de> {\n\tRedo MEGACO dissector to more fully parse text-format messages\n}\n\nXuan Zhang              <xz[AT]aemail4u.com> {\n\teDonkey support\n}\n\nThierry Martin          <thierry.martin[AT]accellent-group.com> {\n\tSupport for reading files from Accellent 5Views LAN agents\n}\n\nOleg Terletsky          <oleg.terletsky[AT]comverse.com> {\n\tLWRES support\n\tAgentX support\n\tSCTP chunk statistic\n}\n\nMichael Lum             <mlum[AT]telostech.com> {\n\tSupport for saving list of disabled protocols\n\tANSI TCAP support\n\tANSI MAP support\n\tALCAP (Q.2630.1) support\n\tIS-637-A (SMS) support\n\tIS-683-A (OTA) support\n\tIS-801 (PLD) support\n\tBSSAP (GSM 08.06)/BSAP (IOS 4.0.1) support\n\tIOS 4.0.1 support\n\tGSM BSSMAP (GSM 08.08) support\n\tGSM DTAP (3GPP TS 24.008) support\n\tGSM SMS (3GPP TS 24.011) support\n\tGSM SS (3GPP TS 24.080) support\n\tGSM SMS TPDU (3GPP TS 23.040) support\n\tGSM Supplementary Services support\n\tGSM MAP fixes and parameter separation\n\tTaps for ANSI A-interface statistics\n\tSupport for SS7 point codes as address types\n\tTaps for GSM A-interface statistics\n\tTap for ANSI MAP message statistics\n\tTap for ISUP message statistics\n\tTap for GSM MAP message statistics\n\tTap for MTP3 MSU statistics and summary\n}\n\nShiang-Ming Huang       <smhuang[AT]pcs.csie.nctu.edu.tw> {\n\tSTUN (RFC 3489) support\n}\n\nTony Lindstrom          <tony.lindstrom[AT]ericsson.com> {\n\tUpdates of DHCPV6 dissector to draft-ietf-dhc-dhcpv6-28,\n\t    draft-ietf-dhc-dhcpv6-opt-prefix-delegation-04, and\n\t    draft-ietf-dhc-dhcpv6-opt-dnsconfig-03, and addition of NIS\n\t    and time configuration option drafts\n\t    draft-ietf-dhc-dhcpv6-opt-nisconfig-02 and\n\t    draft-ietf-dhc-dhcpv6-opt-timeconfig-02\n}\n\nNiklas Ogren            <niklas.ogren[AT]71.se> {\n\tH.263 support for RTP\n}\n\nJesper Peterson         <jesper[AT]endace.com> {\n\tCisco HDLC FCS support\n\tSupport for reading Endace ERF files\n}\n\nGiles Scott             <gscott[AT]arubanetworks.com> {\n\tNortel/SynOptics Network Management Protocol support\n\tAlteon/Nortel Transparent Proxy Control Protocol support\n\tEthernet MAC Control Frame support\n\tPort weak key detection from Airsnort\n\tWlan tap\n\tRetix spanning tree protocol support\n\tAruba ADP protocol support\n}\n\nVincent Jardin          <vincent.jardin[AT]6wind.com> {\n\tSupport for TEREDO\n\tAdditional DHCPv6 options\n}\n\nJean-Michel Fayard      <jean-michel.fayard[AT]moufrei.de> {\n\tShow in Tools:Summary window statistics about packets that\n\t    passed the current display filter\n\tBOOTP/DHCP, HTTP, and WSP statistics taps\n}\n\nJosef Korelus           <jkor[AT]quick.cz> {\n\tGPRS Network Service-over-Frame-Relay support\n\tGPRS BSSGP support\n\tGPRS LLC support\n}\n\nBrian K. Teravskis      <Brian_Teravskis[AT]Cargill.com> {\n\tSupport for saving RTP analysis data in CSV form\n}\n\nNathan Jennings         <natej.git[AT]gmail.com> {\n\tSupport for user-supplied interface descriptions\n\tSupport for hiding interfaces in drop-down list in capture\n\t    dialog\n}\n\nHans Viens              <hviens[AT]mediatrix.com> {\n\tT.38 Support\n}\n\nKevin A. Noll           <kevin.noll[AT]versatile.com> {\n\tRFC 2833 RTP Events support\n\tSupport for WLCCP version 0xC1\n}\n\nEmanuele Caratti        <wiz[AT]libero.it> {\n\tFull TACACS+ dissection\n}\n\nGraeme Reid             <graeme.reid[AT]norwoodsystems.com> {\n\tH.450 support\n}\n\nLars Ruoff              <lars.ruoff[AT]sxb.bsf.alcatel.fr> {\n\tRewritten RTP analysis tap\n}\n\nSamuel Qu               <samuel.qu[AT]utstar.com> {\n\tITU TCAP support\n}\n\nBaktha Muralitharan     <muralidb[AT]cisco.com> {\n\tLink Management Protocol (LMP) fixes\n}\n\nLoïc Minier             <lool[AT]dooz.org> {\n\tHTTP header and payload desegmentation\n}\n\nMarcel Holtmann         <marcel[AT]holtmann.org> {\n\tSupport for reading Linux Bluez Bluetooth stack \"hcidump -w\"\n\t    traces\n}\n\nScott Emberley          <scotte[AT]netinst.com> {\n\tSupport for reading Network Instruments version 9 capture files\n}\n\nBrian Fundakowski Feldman <bfeldman[AT]fla.fujitsu.com> {\n\tSupport for setting link-layer type when capturing\n}\n\nYuriy Sidelnikov        <ysidelnikov[AT]hotmail.com> {\n\tISO 8327-1 Session Protocol support\n\tISO 8823 Presentation Protocol support\n\tISO 10035-1 ACSE support\n\tISO 8571 FTAM support\n}\n\nMatthias Drochner       <M.Drochner[AT]fz-juelich.de> {\n\tSupport for mode 6 and mode 7 control packets, and NTP4 autokey\n\t    extension data, in NTP\n}\n\nDave Sclarsky           <dave_sclarsky[AT]cnt.com> {\n\tCPFI support\n}\n\nScott Hovis             <scott.hovis[AT]ums.msfc.nasa.gov> {\n\tCCSDS (Consultative Committee for Space Data Systems) support\n}\n\nDavid Fort              <david.fort[AT]irisa.fr> {\n\tDNS DS RR support\n\tMLDv2 report message decoding\n\tDNS IPSECKEY RR support\n}\n\nFelix Fei               <felix.fei[AT]utstar.com> {\n\tGSM MAP support\n}\n\nChristoph Neusch        <christoph.neusch[AT]nortelnetworks.com> {\n\tV5UA support\n}\n\nJan Kiszka              <jan.kiszka[AT]web.de> {\n\tIrDA support\n}\n\nJoshua Craig Douglas    <jdouglas[AT]enterasys.com> {\n\tEnterasys Interswitch Message Protocol (ISMP)\n\tEnterasys Discovery Protocol (EDP) (ISMP subprotocol)\n}\n\nDick Gooris             <gooris[AT]alcatel-lucent.com> {\n\tAdded packet range selections in the save(as) dialog\n\tPacketCable support in the COPS dissector\n\tXcsl dissector\n}\n\nMichael Shuldman        <michaels[AT]inet.no> {\n\tX11 replies, events and errors (matched to their request)\n}\n\nTadaaki Nagao           <nagao[AT]iij.ad.jp> {\n\tAdded a global version of disabled_protos\n}\n\nAaron Woo               <woo[AT]itd.nrl.navy.mil> {\n\tOptimized Link State Routing Protocol (OLSR)\n}\n\nChris Wilson            <chris[AT]mxtelecom.com> {\n\tSMPP dissection of concatenated PDUs\n\tSeparate GSM SMS User Data dissector from the SMPP dissector\n}\n\nRolf Fiedler            <Rolf.Fiedler[AT]Innoventif.com> {\n\tISDN TEI management frame support\n\tSupport for reading and writing EyeSDN USB S0 trace files\n}\n\nAlastair Maw            <ethereal[AT]almaw.com> {\n\tIAX2 support\n}\n\nSam Leffler             <sam[AT]errno.com> {\n\tSupport for Radiotap 802.11 radio header (header used by FreeBSD\n\t   5.2 and later and by NetBSD-current\n\t802.11s mesh support\n}\n\nMartin Mathieson        <martin.r.mathieson[AT]googlemail.com> {\n\tSIP sipfrag support\n\tSIP statistics tap\n\tShow setupframe in RTP and RTCP\n\tH.225.0 updates\n\tMGCP updates\n\tRDT (RealPlayer) support\n\tMMS support (MS Media Server protocol)\n\tPPP Chap updates\n\tCatapult DCT2000 file support\n\tUMTS FP support\n\tLTE: MAC, RLC and PDCP support\n\tLTE MAC and RLC Stats\n\tTshark expert info tap\n}\n\nChristian Wagner        <Christian.Wagner[AT]stud.uni-karlsruhe.de> {\n\tSoul Seek (slsk) protocol support\n}\n\nEdwin Calo              <calo[AT]fusemail.com> {\n\tExtract strings from a Postgresql datastream\n}\n\nIan Schorr              <ischorr[AT]comcast.net> {\n\t\"Host list\" taps\n\tFMP support\n}\n\nRowan McFarland         <rmcfarla[AT]cisco.com> {\n\tSupport for Cisco CallManager 4.x in Skinny, CAST support.\n}\n\nJohn Engelhart          <johne[AT]zang.com> {\n\tCDP Hello packet support\n}\n\nRyuji Somegawa          <ryuji-so[AT]is.aist-nara.ac.jp> {\n\tCDMA2000 A11 support\n}\n\nmetatech                <metatechbe[AT]gmail.com> {\n\tIBM WebSphere MQ protocol support\n\tIBM MQ Programmable Command Formats protocol support\n\tInitial BEA Tuxedo protocol support\n\tDistributed Relational Database Architecture protocol support\n\tBorland StarTeam protocol support\n\tAdobe Real Time Messaging Protocol support\n\tActiveMQ OpenWire protocol support\n}\n\nBrian Wheeler           <Brian.Wheeler[AT]arrisi.com> {\n\tDOCSIS 2.0 support\n}\n\nJosh Bailey             <joshbailey[AT]lucent.com> {\n\tIPDC support\n\tLucent/Ascend trace parsing updates\n}\n\nJelmer Vernooij         <jelmer[AT]samba.org> {\n\tAIM enhancements\n\tDCOM IRemUnknown and IRemUnknown2 support\n\tBitTorrent support\n}\n\nDuncan Sargeant         <dunc-ethereal-dev[AT]rcpt.to> {\n\tCisco SS7 RUDP, RLM, and Session Management support\n}\n\nLove Hörnquist Åstrand  <lha[AT]it.su.se> {\n\tHAVE_HEIMDAL_KERBEROS support to allow Ethereal to use heimdal\n\tlibraries to decrypt kerberos encrypted blobs.\n}\n\nLukas Pokorny           <maskis[AT]seznam.cz> {\n\tRTPS (Real-Time Publish-Subscribe) support\n}\n\nCarlos Pignataro        <cpignata[AT]cisco.com> {\n\tGraceful Restart Mechanism for LDP [RFC3478]\n\tFault Tolerance for LDP [RFC3479]\n\tOther LDP enhancements\n\tPPP OSI Network Layer Control Protocol [RFC1377]\n\tFix dissecting of CLNS Protocols over Cisco HDLC\n\tPWE3 Interface parameter additions and miscellaneous updates\n\t    from various IETF PWE3 drafts\n\tMPLS PW Control Channel Header\n\tMultiprotocol Label Switching Echo [draft-ietf-mpls-lsp-ping-05]\n\tMPLS in Generic Routing Encapsulation (GRE)\n\tOSPF Traffic Engineering enhancements\n\tMP-BGP Updates\n\tBGPv4 SAFI-Specific Attribute support\n\tTunnel SAFI support for BGP\n\tLayer Two Tunneling Protocol version 3\n\t    [L2TPv3] updates and enhancements\n\tMPLS Echo updates and Label Switching Router Self-Test\n\t    [draft-ietf-mpls-lsr-self-test-04] support\n}\n\nThomas Anders           <thomas.anders[AT]blue-cable.de> {\n\tPacketCable DHCP options\n\tPacketCable (PKTC) updates and enhancements\n\tMGCP sub-parameter dissection\n\tSNMP Engine ID dissection for SNMP and PKTC\n}\n\nRich Coe                <Richard.Coe[AT]med.ge.com> {\n\tDICOM support\n}\n\nDominic Béchaz          <bdo[AT]zhwin.ch> {\n\tIEEE 1588 / PTP support\n\tEPL v1 support\n}\n\nRichard van der Hoff\t<richardv[AT]mxtelecom.com> {\n\tIAX2 updates\n\tCRC16 routines\n\tH.223 Support\n\tException logic fixes\n}\n\nShaun Jackman\t\t<sjackman[AT]gmail.com> {\n\tRDM enhancements\n\tSerial Infrared support\n\tIrDA support\n\tMPEG support\n}\n\nJon Oberheide           <jon[AT]oberheide.org> {\n\tgiFT support\n}\n\nHenry Ptasinski\t\t<henryp[AT]broadcom.com> {\n\tSupport for 802.11e WME/QoS info\n}\n\nRoberto Morro\t\t<roberto.morro[AT]telecomitalia.it> {\n\tSupport for GMPLS UNI and E-NNI objects/TLVs\n\t\tin RSVP and OSPF\n\tRSVP: Support for PROTECTION obj c-type 2 (RFC4872),\n\t\tnew TLVs for IF_ID (RFC4920), Path Key subobj in ERO (RFC5520),\n\t\tnew ASSOCIATION obj c-type 4 (oif2008.389),\n\t\tnew LSP_ATTRIBUTES and LSP_REQUIRED_ATTRIBUTES objects (RFC5420),\n\t\tand various changes/improvements\n\n}\n\nChris Maynard\t\t<Christopher.Maynard[AT]GTECH.COM> {\n\tAdd support for RFC 2520: NHRP with Mobile NHCs\n\t    and RFC 2735: NHRP Support for Virtual Private Networks\n\tAdd support for PPP-over-USB\n\tWakeOnLAN support\n\tMiscellaneous enhancements and fixes\n}\n\nSEKINE Hideki\t\t<sekineh[AT]gf7.so-net.ne.jp> {\n\tRoutines for AX/4000 Test Block dissection\n}\n\nJeff Connelly\t\t<shellreef+mp2p[AT]gmail.com> {\n\tMANOLITO support\n}\n\nIrene Rüngeler\t\t<ruengeler[AT]wireshark.org> {\n\tGraphical SCTP analysis\n\tSupport PPID and SCTP port based selection in Decode as\n}\n\nM. Ortega y Strupp\t<moys[AT]loplof.de> {\n\tISC DHCP Server 3.0 failover protocol dissection\n}\n\nKelly Byrd\t\t<kbyrd-ethereal[AT]memcpy.com> {\n\tDAAP support\n}\n\nLuis Ontanon\t\t<luis.ontanon[AT]gmail.com> {\n\tMATE plugin\n\tH.248 context tracing\n\tALCAP call tracing\n\tRADIUS dictionary support\n\tXML dissector (DTD support)\n\tIuUP dissector\n\tLua interface\n\tTektronix K12 rf5 file support\n\tSNMPv3 decryption support\n}\n\nLuca Deri\t\t<deri[AT]ntop.org> {\n\tNetFlow v9 enhancements\n}\n\nViorel Suman\t\t<vsuman[AT]avmob.ro> {\n\tTALI (RFC 3094) support\n\tVarious GSM SMS fixes\n\tComputer Interface to Message Distribution (CIMD) version 2 dissection\n}\n\nAlejandro Vaquero\t<alejandro.vaquero[AT]verso.com> {\n\tRTP graphic analysis\n\tVoIP call analysis\n}\n\nFrancesco Fondelli\t<francesco.fondelli[AT]gmail.com> {\n\tICE protocol support\n\tDCCP protocol support\n\tITU-T Y.1711 (OAM mechanism for MPLS networks) support\n\tRSVP/OSPF Extensions for Support of Diffserv-aware MPLS-TE, RFC 4124\n\tLinux Packet Generator support\n\trval_to_str() and alike\n\tExport the capture file into C Arrays format\n\tPW Associated Channel Header dissection, RFC 4385\n\tPW MPLS Control Word dissection, RFC 4385\n\tMPLS subdissector table indexed by label value\n\tenhanced \"what's past last MPLS label?\" heuristic\n\tEthernet PW (with/without CW) support, RFC 4448\n\tATM PW (with/without CW) support, RFC 4717\n\tLMP, update to RFC 4204\n\tRSVP extensions for G.709 Optical Transport Networks Control, RFC 4328\n\tUpdate GMPLS GPID, Switching and Encoding type values\n\tSupport for generalized label interpretation:\n\t    SUKLM format for SONET/SDH label (RFC 4606), t3t2t1 format for\n\t    G.709 ODUk label (RFC 4328), G.694 format for lambda label\n\t    (draft-ietf-ccamp-gmpls-g-694-lambda-labels-05).  Add related\n\t    user preference option.\n\tRSVP IF_ID ERROR_STRING TLV support, RFC 4783\n\tSupport for Vendor Private objects, RFC 3936\n\tSupport for MPLS Packet Loss and Delay Measurement, RFC 6374\n\tSupport for DCCP Simultaneous-Open for NAT Traversal, RFC 5596\n\tMPLS-TP Protection State Coordination (PSC) Protocol, RFC 6378\n\tSupport for Exclude Routes (XRO) in RSVP-TE, RFC 4874\n\tSupport for Shared Use of Experimental TCP Options\n\tSupport for TCP Fast Open\n\tOpenFlow heuristic logic\n\tPath setup type in PCEP messages, draft-ietf-pce-lsp-setup-type-00\n\tPCEP Extensions for Segment Routing, draft-ietf-pce-segment-routing-01\n\tPCEP Extensions for Association, draft-ietf-pce-association-group-00\n\tBGP-LS extensions for Segment Routing, draft-gredler-idr-bgp-ls-segment-routing-ext-01\n\tHL7 protocol support\n}\n\nArtem Tamazov           <artem.tamazov[AT]tellabs.com> {\n\tFrame Relay PW in MPLS PSN, FR DLCI mode, RFC 4619\n\tSAToP PW in MPLS PSN, no RTP headers, RFC 4553\n\tSAToP PW in IP PSN/UDP demux, no RTP headers, RFC 4553\n\tCESoPSN PW in MPLS PSN, Basic NxDS0 mode, no RTP headers, RFC 5086\n\tCESoPSN PW in IP PSN/UDP demux, Basic NxDS0 mode, no RTP headers, RFC 5086\n\tATM PW in MPLS PSN, RFC 4717\n\tLLC SNAP auto-detection in ATM decoder\n\t\"Raw\" BFD support in MPLS PW Associated Channel, RFC 4385\n\tDecoding of UDP-multiplexed CESoPSN and SAToP traffic\n}\n\nDmitry Trebich          <dmitry.trebich[AT]gmail.com> {\n\tPreference for selecting default dissector for MPLS payloads.\n\tHDLC PW in MPLS PSN, HDLC mode (no CW) with PPP payload, RFC 4618 5.1\n\tHDLC PW in MPLS PSN, FR port mode (no CW), RFC 4618 5.2\n\tFrame Relay PW in MPLS PSN, FR DLCI mode, RFC 4619\n\tSAToP PW in MPLS PSN, no RTP headers, RFC 4553\n\tCESoPSN PW in MPLS PSN, Basic NxDS0 mode, no RTP headers, RFC 5086\n}\n\nBill Meier\t\t<wmeier[AT]newsguy.com> {\n\tTDS4/TDS5 enhancements\n\tNetXRay/Windows Sniffer file enhancements\n\tTCP graph enhancements\n}\n\nSusanne Edlund\t\t<Susanne.Edlund[AT]ericsson.com> {\n\tNSIP protocol support\n}\n\nVictor Stratan\t\t<hidralisk[AT]yahoo.com> {\n\tGSM SMS enhancements\n}\n\nPeter Johansson\t\t<PeterJohansson73[AT]gmail.com> {\n\t\"Template\" conversations\n}\n\nStefan Metzmacher\t<metze[AT]samba.org> {\n\tLDAP Controls support in the LDAP dissector\n\tWINS Replication protocol\n\tVarious SMB/SMB2 dissector enhancements\n}\n\nAbhijit Menon-Sen\t<ams[AT]oryx.com> {\n\tPostgresql v3 dissector\n}\n\nJames Fields\t\t<jvfields[AT]tds.net> {\n\tCorrectly handle time stamps in some Windows Sniffer files\n}\n\nKevin Johnson\t\t<kjohnson[AT]secureideas.net> {\n\tCorrectly handle time stamps in some Windows Sniffer files\n}\n\nMike Duigou\t\t<bondolo[AT]dev.java.net> {\n\tDissector for JXTA protocol\n}\n\nDeepak Jain\t\t<jain1971[AT]yahoo.com> {\n\tL2TP v3 support\n\tNext Hop Resolution Protocol support\n}\n\nStefano Pettini\t\t<spettini[AT]users.sourceforge.net> {\n\tRMT support for ALC and NORM\n}\n\nJon Ringle\t\t<ml-ethereal[AT]ringle.org> {\n\tConversations demarked by setup frame number\n}\n\nTim Endean\t\t<endeant[AT]hotmail.com> {\n\tDissector for INAP protocol\n}\n\nCharlie Lenahan\t\t<clenahan[AT]fortresstech.com> {\n\tSupport for the Cisco DTP Protocol\n\tSupport for some HP switch protocol\n}\n\nTakeshi Nakashima\t<T.Nakashima[AT]jp.yokogawa.com> {\n\tSupport for the KINK protocol.\n}\n\nShoichi Sakane\t\t<sakane[AT]tanu.org> {\n\tIKEv2 support\n\tCOAP protocol support\n}\n\nMichael Richardson\t<Michael.Richardson[AT]protiviti.com> {\n\tSAMR updates and new info levels\n}\n\nOlivier Jacques\t\t<olivier.jacques[AT]hp.com> {\n\tSupport for the Camel protocol.\n}\n\nFrancisco Alcoba\t<francisco.alcoba[AT]ericsson.com> {\n\tASCII art version of VOIP call analysis\n}\n\nNils O. Selåsdal\t<noselasd[AT]asgaard.homelinux.org> {\n\t9P support\n}\n\nGuillaume Chazarain \t<guichaz[AT]yahoo.fr> {\n\tArmagetronad support\n}\n\nAngelo Bannack\t\t<angelo.bannack[AT]siemens.com> {\n\tCSM_ENCAPS support\n}\n\nPaolo Frigo\t\t<paolofrigo[AT]gmail.com> {\n\tTANGO support\n}\n\nJeremy J Ouellette\t<jouellet[AT]scires.com> {\n\tDIS support\n}\n\nAboo Valappil\t\t<valappil_aboo[AT]emc.com> {\n\tiFCP support\n}\n\nFred Hoekstra\t\t<fred.hoekstra[AT]philips.com> {\n\tDEC DNA Routing support\n}\n\nAnkur Aggarwal\t\t<ankur[AT]in.athenasemi.com> {\n\tIEEE 802.11e (QoS) decoding\n\tImproved IEEE 802.11h decoding\n}\n\nLucian Piros\t\t<lpiros[AT]avmob.ro> {\n\tComputer Interface to Message Distribution (CIMD) version 2 dissection\n}\n\nJuan Gonzalez\t\t<juan.gonzalez[AT]pikatech.com> {\n\tLLDP dissection\n}\n\nBrian Bogora\t\t<brian_bogora[AT]mitel.com> {\n\tLLDP dissection\n}\n\nJim Young\t\t<sysjhy[AT]langate.gsu.edu> {\n\tImprovements LLDP dissection (803.3 \"PMD Auto-Negotiation Advertised\n\t\tCapability\" and \"Operational MAU Type\")\n\tCapinfos time order checking\n\tEditcap time order forcing\n\n}\n\nJeff Snyder\t\t<jeff[AT]mxtelecom.com> {\n\tDesegmentation support in IAX2\n\tH.223 Support\n}\n\nWilliam Fiveash\t\t<William.Fiveash[AT]sun.com> {\n\tKerberos PA_ENCTYPE_INFO2 and aes crypto defines\n}\n\nGraeme Lunt\t\t<graeme.lunt[AT]smhs.co.uk> {\n\tROS support\n\tRTS support\n\tX.411 (P1) support\n\tX.420 (P22) support\n\tSTANAG 4406 (P772) support\n\tX.500 (DAP) support\n\tX.500 (DSP) support\n\tX.500 (DISP) support\n}\n\nMenno Andriesse\t\t<s5066[AT]nc3a.nato.int> {\n\thttp://s5066.nc3a.nato.int\n\tSTANAG 5066 support\n}\n\nStig Bjørlykke\t\t<stig[AT]bjorlykke.org> {\n\tP_Mul (ACP142) packet disassembly\n\tCDT (CompressedDataType) support\n\tDMP (STANAG 4406 Direct Message Profile) support\n\tCOTP and RTSE reassembly improvements\n\tConfiguration Profiles\n\tWLAN Traffic Statistics\n\tFilter autocompletion usability improvements\n\tRemote capture improvements and RPCAP support\n\tBJNP, DropBox, Memcache, nat-pmp, PacketLogger, rpcap\n\tImproved dissectors using ASN.1 (BER).\n\tLua functions and improvements.\n\tStatistics improvements (Protocol Hierarchy, Conversations, I/O Graph)\n\tColumn handling functions (right-click column headers)\n\tEnhancements and fixes in the new packet list\n\tVarious User Guide updates\n\tMiscellaneous enhancements and fixes\n}\n\nKyle J. Harms\t\t<kyle.j.harms[AT]boeing.com> {\n\tCIGI dissection\n}\n\nEric Wedel\t\t<ewedel[AT]bluearc.com> {\n\tKPASSWD over TCP support\n}\n\nSecfire\t\t\t<secfire[AT]gmail.com> {\n\tOICQ\n\tJuniper NSRP\n}\n\nEric Hultin\t\t<Eric.Hultin[AT]arrisi.com> {\n\tCableLab's DCC packet\n\tDCD packet\n}\n\nPaolo Abeni\t\t<paolo.abeni[AT]email.it> {\n\tSSL-decryption\n\tDissector for USB packets and pcap/wiretap support\n}\n\nW. Borgert\t\t<debacle[AT]debian.org> {\n\tGIOP enhancements\n}\n\nFrederic Roudaut\t<frederic.roudaut[AT]irisa.fr> {\n\tIPsec ESP payload decryption\n}\n\nChristoph Scholz\t<scholz_ch[AT]web.de> {\n\tBluetooth stack: http://affix.sourceforge.net/archive/ethereal_affix-3.patch\n}\n\nWolfgang Hansmann\t<hansmann[AT]cs.uni-bonn.de> {\n\tPart of bluetooth stack from http://affix.sourceforge.net/archive/ethereal_affix-3.patch\n}\n\nKees Cook\t\t<kees[AT]outflux.net> {\n\tTiVoConnect Discovery Protocol\n}\n\nThomas Dreibholz\t<dreibh[AT]simula.no> {\n\tCalculation Application Protocol support\n\tComponent Status Protocol support\n\tFractal Generator Protocol support\n\tDCCP dissector improvements\n\tFollow DCCP stream feature\n\tNetPerfMeter Protocol support\n\tPing Pong Protocol support\n\tRSerPol protocol stack\n\tSCTP dissector improvements\n\tScripting Service Protocol support\n}\n\nAuthesserre Samuel\t<sauthess[AT]gmail.com> {\n\tSSL decryption updates\n\tDTLS\n}\n\nBalint Reczey\t\t<balint[AT]balintreczey.hu> {\n\tLua fixes and enhancements\n\tMiscellaneous enhancements and fixes\n}\n\nStephen Fisher\t\t<stephenfisher[AT]centurylink.net> {\n\tREXEC support\n\tVeritas Low Latency Transport support\n\tMAPI new mail protocol support\n\tInitial work on custom columns\n\tVNC protocol support\n\tWoW protocol support\n\tDaytime protocol support\n\tPart of WLCCP support\n\tcommview and packetlogger wiretap support\n\tExport Object support\n\tPixmap saving routines\n\tWork on the initial version of the new packet list\n\tMiscellaneous enhancements and fixes\n}\n\nKrzysztof Burghardt\t<krzysztof[AT]burghardt.pl> {\n\tKISMET support\n}\n\nPeter Racz\t\t<racz[AT]ifi.unizh.ch> {\n\tPANA support\n}\n\nJakob Bratkovic\t\t<j.bratkovic[AT]iskratel.si> {\n\tMulticast stream analysis support\n}\n\nMark Lewis\t\t<mlewis[AT]altera.com> {\n\t2dParityFec dissector\n}\n\nDavid Buechi\t\t<bhd[AT]zhwin.ch> {\n\tEPL v1 support\n}\n\nBill Florac\t\t<bill.florac[AT]etcconnect.com> {\n\tACN support\n}\n\nAlex Burlyga\t\t<Alex.Burlyga[AT]netapp.com> {\n\tNetApp NFS filehandle dissectors\n}\n\nDouglas Pratley\t\t<Douglas.pratley[AT]detica.com> {\n\tEpoch timestamps\n}\n\nGiorgio Tino\t\t<giorgio.tino[AT]cacetech.com> {\n\tAirPcap support\n\tWPA UI support\n\tStatic text preferences\n}\n\nDavide Schiera\t\t<davide.schiera[AT]riverbed.com> {\n\tWPA and WPA2 decryption\n}\n\nSebastien Tandel\t<sebastien[AT]tandel.be> {\n\tembedding python in *shark\n\tsubtrees management for ptvcursor\n\tgcc warning hunter\n\tHomeplug support\n}\n\nClay Jones\t\t<clay.jones[AT]email.com> {\n\tShomiti wireless packet support\n\t802.11n support\n}\n\nKriang Lerdsuwanakij\t<lerdsuwa[AT]users.sourceforge.net> {\n\tSSCOP improvements\n\tK12-rf5 file format improvements\n}\n\nAbhik Sarkar \t\t<sarkar.abhik[AT]gmail.com> {\n\tSupport for decoding of SS7 MSUs embedded in syslog messages\n\t(as generated by the Cisco ITP packet logging facility)\n\tSMPP statistics\n\tSMPP update to v5.0\n\tDiameter conversations and statistics\n\tUAT for unknown HTTP headers\n\tKyoto Tycoon (binary protocol) dissector\n}\n\nRobin Seggelmann\t<seggelmann[AT]fh-muenster.de> {\n\tSupport for SCTP reassembly.\n\tImprove chunk statistics.\n}\n\nChris Bontje\t\t<cbontje[AT]gmail.com> {\n\tSupport for DNP3 Application Layer dissection\n\tSupport for SEL Fast Message dissection\n\tSupport for RTAC Serial dissection\n}\n\nRyan Wamsley\t\t<wamslers[AT]sbcglobal.net> {\n\tConnection Configuration Object support in EtherNet/IP\n}\n\nDave Butt\t\t<davidbutt[AT]mxtelecom.com> {\n\tRTP payload reassembly support\n\tH.223-over-RTP support\n}\n\nJulian Cable\t\t<julian_cable[AT]yahoo.com> {\n\tDCP ETSI support\n}\n\nJoost Yervante Damad\t<joost[AT]teluna.org> {\n\tErlang Port Mapper Daemon dissection support\n}\n\nMartin Sustrik\t\t<sustrik[AT]imatix.com>  {\n\tAMQP support\n}\n\nJon Smirl\t\t<jonsmirl[AT]gmail.com> {\n\tUSB conversations/endpoints list\n}\n\nDavid Kennedy\t\t<sgsguy[AT]gmail.com> {\n\tSymantec SGS v3 support\n}\n\nMatthijs Mekking\t<matthijs[AT]mlnetlabs.nl> {\n\tShim6 support\n}\n\nDustin Johnson\t\t<dustin[AT]dustinj.us> {\n\t802.11n support\n}\n\nVictor Fajardo\t\t<vfajardo[AT]tari.toshiba.com> {\n\tPANA draft 15a support\n}\n\nTamas Regos\t\t<tamas.regos[AT]ericsson.com> {\n\tLua Enhancements\n}\n\nTamas Regos\t\t<tamas.regos[AT]infostam.com> {\n\tGSMTAP Enhancements\n\tSimple Statistics Dialog Enhancements\n}\n\nMôshe van der Sterre\t<moshevds[AT]gmail.com> {\n\tFirebird/Interbase dissection\n}\n\nRob Casey\t\t<rcasey[AT]gmail.com> {\n\tKingfisher support\n}\n\nTed Percival\t\t<ted[AT]midg3t.net> {\n\tSupport for PA-S4U2Self Kerberos packet type\n}\n\nMarc Petit-Huguenin\t<marc[AT]petit-huguenin.org> {\n\tUpdate STUN2 to draft-ietf-behave-rfc3489bis-07\n}\n\nFlorent Drouin\t\t<florent.drouin[AT]alcatel-lucent.fr> {\n\tTCAP statistics\n}\n\nKaren Feng\t\t<kfeng[AT]fas.harvard.edu> {\n\t802.1ad and 802.1ah support\n}\n\nStephen Croll\t\t<croll[AT]mobilemetrics.net> {\n\tWiMAX ASN Control Plane dissection\n}\n\nJens Bräuer\t\t<jensb[AT]cs.tu-berlin.de> {\n\tWifi Simple Config aka Wifi Protected Setup\n}\n\nSake Blok\t\t<sake[AT]euronet.nl> {\n\tCisco proprietary MST format support\n\t\"Copy as Filter\" functionality\n\tSplit time_delta in time delta captured and time delta displayed\n\tNetScreen snoop output (ascii) support\n\tTCP Conversation timestamps\n\tenable/disable indiviual coloring rules\n\ttemporary coloring rules with hotkeys\n\tCopy Fieldname / Copy Value\n\tIgnore all packets functionality\n\tEnable printing of all occurrences of fields\n\tFollow TCP stream enhancements\n\tExport SSL Session Keys\n\tVSS-Monitoring dissector\n\tMiscellaneous enhancements and fixes\n}\n\nFulko Hew\t\t<fulko.hew[AT]gmail.com> {\n\tSITA protocol dissection (ALC, UTS, Frame Relay, X.25)\n\tUTS WAN protocol dissection\n\tIPARS/ALC (International Passenger Airline Reservation System/Airline\n\tLink Control) WAN protocol dissection\n}\n\nYukiyo Akisada\t\t<Yukiyo.Akisada[AT]jp.yokogawa.com> {\n\tFOUNDATION fieldbus\n}\n\nAndy Chu\t\t<chu.dev[AT]gmail.com> {\n\tChina Mobile Point to Point\n}\n\nShane Kearns\t\t<shane.kearns[AT]symbian.com> {\n\tSupport Symbian OS btsnoop\n}\n\nLoris Degioanni\t\t<loris.degioanni[AT]riverbed.com> {\n\tRawshark\n}\n\nSven Meier\t\t<msv[AT]zhwin.ch> {\n\tPRP (Parallel Redundancy Protocol; IEC62439 Chapter 6) dissection\n}\n\nHolger Pfrommer\t\t<hpfrommer[AT]hilscher.com> {\n\tHilscher analyzer protocols dissection\n}\n\nHariharan Ananthakrishnan <hariharan.a[AT]gmail.com> {\n\tISIS LSP-ID and hostname enhancements\n}\n\nHannes Kälber\t\t<hannes.kaelber--wireshark[AT]x2e.de> {\n\tAutomotive DLTs\n}\n\nStephen Donnelly\t<stephen[AT]endace.com> {\n\tInfiniband support\n}\n\nPhilip Frey\t\t<frey.philip[AT]gmail.com> {\n\tiWARP dissectors (MPA, DDP and RDMAP)\n}\n\nYves Geissbuehler\t<yves.geissbuehler[AT]gmail.com> {\n\tiWARP dissectors (MPA, DDP and RDMAP)\n}\n\nShigeo Nakamura\t\t<naka_shigeo[AT]yahoo.co.jp> {\n\tXpress Transport Protocol dissector\n}\n\nSven Eckelmann\t\t<sven[AT]narfation.org> {\n\tB.A.T.M.A.N. dissector\n\tB.A.T.M.A.N. Advanced dissector\n}\n\nEdward J. Paradise\t<pdice[AT]cisco.com> {\n\tRFC4938bis enhancements to PPPoE\n}\n\nBrian Stormont\t\t<nospam[AT]stormyprods.com> {\n\tWPA group key decryption\n}\n\nVincent Helfre\t\t<vincent.helfre[AT]ericsson.com> {\n\tSNDCP XID dissection\n}\n\nBrooss\t\t\t<brooss.teambb[AT]gmail.com> {\n\tTeamspeak2 dissector\n}\n\nJoan Ramió\t\t<joan[AT]ramio.cat> {\n\tIEC 60870-5-104 dissector\n}\n\nDavid Castleford\t<david.castleford[AT]orange-ftgroup.com> {\n\tISMACryp dissector\n\tSimulcrypt dissector\n}\n\nPeter Harris\t\t<pharris[AT]opentext.com> {\n\tX11 extension decoding\n\tX11 dissector fixes\n}\n\nMartin Lutz\t\t<MartinL[AT]copadata.at> {\n\tIEC 61850 GOOSE Dissector\n}\n\nJohnny Mitrevski\t<mitrevj[AT]hotmail.com> {\n\tBSSAP LE Dissector\n}\n\nNeil Horman\t\t<nhorman[AT]tuxdriver.com> {\n\tNetdump dissector\n}\n\nAndreas Schuler\t\t<krater[AT]badterrorist.com> {\n\tDECT dissector\n}\n\nMatthias Wenzel\t\t<dect[AT]mazzoo.de> {\n\tDECT dissector\n}\n\nChristian Durrer\t<christian.durrer[AT]sensemail.ch> {\n\tsbus dissector\n}\n\nNaoyoshi Ueda\t\t<piyomaru3141[AT]gmail.com> {\n\tIKEv2 decryption support\n\tTLS 1.2 decryption support\n\tDTLS 1.0 decryption fixes\n}\n\nJavier Cardona\t\t<javier[AT]cozybit.com> {\n\tMesh header dissector\n}\n\nJens Steinhauser\t<jens.steinhauser[AT]omicron.at> {\n\tIEEE C37.118 synchrophasor dissector\n}\n\nJulien Kerihuel\t\t<j.kerihuel[AT]openchange.org> {\n\tExchange RFR dissector\n}\n\nVincenzo Condoleo\t<vcondole[AT]hsr.ch> {\n\tIP packet comparison\n}\n\nMohammad Ebrahim Mohammadi Panah <mebrahim[AT]gmail.com> {\n\tInitial Paltalk support\n}\n\nGreg Schwendimann\t<gregs[AT]iol.unh.edu> {\n\tWPA decryption security association caching\n}\n\nNick Lewis\t\t<nick.lewis[AT]atltelecom.com> {\n\tShow timestamp problems in RTP player\n}\n\nFred Fierling\t\t<fff[AT]exegin.com> {\n\tDaintree's Sensor Network Analyzer file support\n}\n\nSamu Varjonen\t\t<samu.varjonen[AT]hiit.fi> {\n\tHost Identity Protocol (HIP) support\n}\n\nAlexis La Goutte\t<alexis.lagoutte[AT]gmail.com> {\n\tAdd FT_EUI64 Field Type\n\tAruba ERM, IAP, PAPI dissector\n\tATMTCP dissector\n\tCAPWAP dissector\n\tHTTP2 dissector\n\tQUIC dissector\n\tMONGO dissector\n\tWebSocket dissector\n\tMiscellaneous ISAKMP enhancements\n\tMiscellaneous ICMPv6 enhancements\n\tMiscellaneous 802.11 enhancements\n\tPacket TCP Mood Option (RFC5841) support\n\tPPTP, GRE, PPP PAP, RIPng dissector enhancements (Rework)\n}\n\nVarun Notibala\t\t<nbvarun[AT]gmail.com> {\n\tSCTP NR-SACK support\n}\n\nNathan Hartwell\t\t<nhartwell[AT]gmail.com> {\n\tHP NIC Teaming dissector\n}\n\nDon Chirieleison\t<donc[AT]mitre.org> {\n\tDTN Bundle Protocol\n}\n\nHarald Welte\t\t<laforge[AT]gnumonks.org> {\n\tGSM A-bis over IP dissector\n\tGSM A-bis OML dissector\n\tGSM RLP dissector\n\tGSMTAP dissector\n\tGSM SIM/USIM dissector\n\tEricsson extensions to L2TP\n\tip.access extensions to A-bis RSL\n\tEricsson extensions to A-bis RSL\n\tEricsson HDLC dissector\n\tEricsson A-bis TFP dissector\n\tEricsson P-GSL dissector\n\tEricsson TFP dissector\n\tEricsson OM2000 dissector\n}\n\nChris Costa\t\t<chcosta75[AT]hotmail.com> {\n\tAdd defragmentation code to NDMP dissectot\n\tProperly decode SMB2 error response\n}\n\nBruno Prémont\t\t<bonbons[AT]linux-vserver.org> {\n\tCollectD dissector\n}\n\nFlorian Forster\t\t<octo[AT]verplant.org> {\n\tCollectD dissector\n}\n\nIvan Sy Jr.\t\t<ivan_jr[AT]yahoo.com> {\n\tAdded DNS RRs: DLV, SSHFP, SPF, HIP, DHCID, NSEC3PARAM, APL, PX,\n\t               GPOS, NSAP, NSAP-PTR, AFSDB, RP, X25, ISDN, RT, RR\n\tAllow some network control block addresses with ttl != 1.\n\tMiscellaneous IPv6 enhancements.\n}\n\nMatthieu Patou\t\t<mat[AT]matws.net> {\n\tNTLM v1 and v2 decryption.\n\tLDAP fixes.\n\tNetlogon/Schannel decryption.\n}\n\nKovarththanan Rajaratnam <kovarththanan.rajaratnam[AT]gmail.com> {\n\tWork on the new packet list.\n\tMiscellaneous fixes and enhancements.\n}\n\nMatt Watchinski\t\t<mwatchinski[AT]sourcefire.com> {\n\tOMRON-FINS dissector\n}\n\nRavi Kondamuru\t\t<Ravi.Kondamuru[AT]citrix.com> {\n\tSupport to read citrix netscaler capture file format.\n}\n\nJan Gerbecks\t\t<jan.gerbecks[AT]stud.uni-due.de> {\n\tPNRP dissector\n}\n\nVladimir Smrekar\t<vladimir.smrekar[AT]gmail.com> {\n\tV.52 dissector\n\tV5UA dissector\n}\n\nTobias Erichsen \t<t.erichsen[AT]gmx.de> {\n\tApple network-midi session establishment dissector\n}\n\nErwin van Eijk\t\t<erwin.vaneijk[AT]gmail.com> {\n\tETSI ts 101 671 dissector\n}\n\nVenkateshwaran Dorai\t<venkateshwaran.d[AT]gmail.com> {\n\tServer/Application State Protocol [SASP] (RFC 4678 ) dissector\n}\n\nBen Greear\t\t<greearb[AT]candelatech.com> {\n\tLANforge dissector\n}\n\nRichard Kümmel\t\t<r.kuemmel[AT]beckhoff.de> {\n\tEtherCAT dissector\n}\n\nYi Yu\t\t\t<yiyu.inbox[AT]gmail.com> {\n\tUpdates to the sFlow dissector\n}\n\nAniruddha A\t\t<aniruddha.a[AT]gmail.com> {\n\tANCP (Access Node Control Protocol) dissector\n}\n\nDavid Aggeler\t\t<david_aggeler[AT]hispeed.ch> {\n\tNumerous DICOM dissector enhancements and fixes\n\tVMLAB (VMware Lab Manager) dissector\n}\n\nJens Kilian\t\t<jjk[AT]acm.org> {\n\tVXI-11 (a.k.a. Network Instrument Protocol) dissector\n}\n\nDavid Bond\t\t<mokon[AT]mokon.net> {\n\tTRILL (TRansparent Interconnection of Lots of Links) dissector\n}\n\nPaul J. Metzger\t\t<pjm[AT]ll.mit.edu> {\n\tAdd support for decoding DIS Electromagnetic Emission packets\n}\n\nRobert Hogan\t\t<robert[AT]roberthogan.net> {\n\tTN3270 fixes\n\tTN5250 dissector\n}\n\nTorrey Atcitty\t\t<torrey.atcitty[AT]harman.com> {\n\tPTP dissector: Added support for 802.1AS D7.0\n\tIEEE 802.1Qat (Multiple Stream Reservation Protocol) dissector\n\tIEEE 1722(AVB Transport Protocol) dissector\n}\n\nDave Olsen\t\t<dave.olsen[AT]harman.com> {\n\tPTP dissector: Added support for 802.1AS D7.0\n\tIEEE 1722(AVB Transport Protocol) dissector\n}\n\nCraig Gunther\t\t<craig.gunther[AT]harman.com> {\n\tIEEE 802.1Qat (Multiple Stream Reservation Protocol) dissector\n}\n\nLevi Pearson\t\t<levi.pearson[AT]harman.com> {\n\tIEEE 1722(AVB Transport Protocol) dissector\n}\n\nAllan M. Madsen\t\t<allan.m[AT]madsen.dk> {\n\tBluetooth HCI cmd/evt dissectors ver. 2.1-4.0 support\n\tBluetooth ATT dissector\n\tBluetooth OBEX dissector\n\tBluetooth SMP dissector\n}\n\nSlava\t\t\t<slavak[AT]gmail.com> {\n\tSupport for PortCounters and PortCounters Extended performance\n\t\tmanagement datagrams (Infiniband)\n\tSupport for Infiniband-SDP\n}\n\nH.sivank\t\t<hsivank[AT]gmail.com> {\n\tGtkOSXApplication support\n}\n\nEdgar Gladkich\t\t<edgar.gladkich[AT]inacon.de> {\n\tProtocol help\n}\n\nMichael Bernhard\t<michael.bernhard[AT]bfh.ch> {\n\tIEC 61850 dissector\n}\n\nHolger Hans Peter Freyther <zecke[AT]selfish.org> {\n\tNexusWare C7 MTP over UDP dissector\n\tDVB-H IPDC ESG\n}\n\nJose Pico\t\t<jose[AT]taddong.com> {\n\tRoutines for exporting SMB objects\n}\n\nDavid Perez\t\t<david[AT]taddong.com> {\n\tRoutines for exporting SMB objects\n}\n\nHåkon Nessjøen\t\t<haakon.nessjoen[AT]gmail.com> {\n\tMikrotik RouterOS protocol dissector\n\tDigium TDMoE protocol dissector\n}\n\nHerbert Lischka\t\t<herbert[AT]lischka-berlin.de> {\n\tBACNET dissector fixes and enhancements\n}\n\nFelix Krämer\t\t<sauter-cumulus[AT]de.sauter-bc.com> {\n\tStats Tree for BACapp dissector\n}\n\nTom Hughes\t\t<tom[AT]compton.nu> {\n\tFCGI dissector\n}\n\nOwen Kirby\t\t<osk[AT]exegin.com> {\n\tSCoP dissector\n\tRPL support in ICMPv6 (with Colin O'Flynn)\n}\n\nColin O'Flynn\t\t<coflynn[AT]newae.com> {\n\tRPL support in ICMPv6 (with Owen Kirby)\n}\n\nJuha Siltanen\t\t<juha.siltanen[AT]nsn.com> {\n\tFLIP dissector\n}\n\nCal Turney\t\t<cturney111[AT]gmail.com> {\n\tUpdates to iSCSI, HTTP, TCP, NFS, SMB, BER\n}\n\nLukasz Kotasa\t\t<lukasz.kotasa[AT]tieto.com> {\n\tWAI authentication protocol\n}\n\nJason Masker\t\t<jason[AT]masker.net> {\n\tUpdates for Cisco ERSPAN Type III (version 2)\n}\n\nGiuliano Fabris\t\t<giuliano.fabris[AT]appeartv.com> {\n\tEnhanced DVB Simulcrypt protocol dissector:\n\t   EIS <-> SCS, (P)SIG <-> MUX, MUX <-> CiM\n\t   and (P) <-> CiP support\n}\n\nAlexander Koeppe\t<format_c[AT]online.de> {\n\tTCP Graph - Window Scaling\n\tFTP Extensions for IPv6 and NATs (RFC2428)\n}\n\nHolger Grandy \t\t<Holger.Grandy[AT]bmw-carit.de> {\n\tETCH dissector\n}\n\nHadriel Kaplan\t\t<hadrielk[AT]yahoo.com> {\n\tIPFIX wiretap support\n}\n\nSrinivasa Pradeep\t<sippyemail-wireshark[AT]yahoo.com> {\n\tLDP dissector: Add/Update PseudoWire TLV support\n}\n\nLori Tribble\t\t<ljtconsulting[AT]gmail.com> {\n\tSupport for vendor-specific subdissectors for\n\tBACnet Private Transfer Messages\n}\n\nThomas Boehne\t\t<TBoehne[AT]ADwin.de> {\n\tADwin and ADwin-config protocol dissectors\n}\n\nGerhard Gappmeier\t<gerhard.gappmeier[AT]ascolab.com> {\n\tOPCUA dissector plugin\n}\n\nHannes Mezger\t\t<hannes.mezger[AT]ascolab.com> {\n\tOPCUA dissector plugin\n}\n\nDavid Katz\t\t<dkatz[AT]airspan.com> {\n\tSupport for versioning in the WiMAX ASN CP dissector\n}\n\nToralf Förster\t\t<toralf.foerster[AT]gmx.de> {\n\tSAMETIME dissector\n}\n\nStéphane Bryant\t\t<stephane[AT]glycon.org> {\n\tRELOAD dissector\n\tRELOAD Framing dissector\n}\n\nEmil Wojak\t\t<emil[AT]wojak.eu> {\n\tTDS dissector improvements\n}\n\nSteve Huston\t\t<shuston[AT]riverace.com> {\n\tAMQP 0-10 support\n}\n\nLoránd Jakab\t\t<ljakab[AT]ac.upc.edu> {\n\tLocator/ID Separation Protocol dissector\n}\n\nGrzegorz Szczytowski\t<Grzegorz.Szczytowski[AT]gmail.com>  {\n\tDiameter dictionary RFC 3588 AVP 299\n\tGTPv1 Bearer Control Mode dissection\n\tE212 dissector MCC 260 upgrade and modification\n}\n\nMartin Kaiser\t\t<wireshark[AT]kaiser.cx> {\n\tDVB-CI (Common Interface) dissector\n\tHDCP dissector\n}\n\nJakub Zawadzki\t\t<darkjames-ws[AT]darkjames.pl> {\n\tJSON dissector\n\tWiretap cleanup and support for fast random access to gzipped\n\t    files\n}\n\nRoland Knall\t\t<roland.knall[AT]br-automation.com> {\n\tSupport for heuristic subdissectors for SERCOS III\n\topenSAFETY dissector\n}\n\nXiao Xiangquan\t\t<xiaoxiangquan[AT]gmail.com> {\n\tBT-UTP dissector\n\tBT-DHT dissector\n\tVuze-DHT dissector\n}\n\nHans-Christoph Schemmel\t<hans-christoph.schemmel[AT]cinterion.com> {\n\t3GPP TS 27.010 multiplexing protocol\n}\n\nTyson Key\t\t<tyson.key[AT]gmail.com> {\n\tUSB-encapsulated AT Commands dissector\n}\n\nJohannes Jochen\t\t<johannes.jochen[AT]belden.com> {\n\tMultiple MAC Registration Protocol dissector\n}\n\nFlorian Fainelli\t<florian[AT]openwrt.org> {\n\tHomePlug AV protocol dissector\n}\n\nDaniel Willmann\t\t<daniel[AT]totalueberwachung.de> {\n\tCN/IP (EIA-852) protocol dissector\n\tLontalk protocol (EIA-709.1) dissector\n}\n\nBrian Cavagnolo\t\t<brian[AT]cozybit.com> {\n\tUpdate 802.11s packet dissecting\n}\n\nAllison\t\t\t<aobourn[AT]isilon.com> {\n\tHDFS and HDFS data Dissector\n}\n\nEdwin Groothuis\t\t<wireshark[AT]mavetju.org> {\n\tTime Shift functionality\n\tFilter Toolbar Save functionality\n}\n\nAndrew Kampjes\t\t<andrew.kampjes[AT]endace.com> {\n\tEndace ERF channelisation and \"New BFS\" extension header support\n}\n\nKurnia Hendrawan\t<kurnia.hendrawan[AT]consistec.de> {\n\tSaving User Specified Decodes into profile\n}\n\nLeonard Tracy\t\t<letracy[AT]cisco.com> {\n\tCisco FabricPath protocol dissector\n}\n\nElliott Aldrich\t\t<elliott[AT]aldrichart.com> {\n\tVarious icons\n}\n\nGlenn Matthews\t\t<glenn.matthews[AT]cisco.com> {\n\tXMCP dissector\n}\n\nDonnie Savage\t\t<dsavage[AT]cisco.com> {\n\tEIGRP TLV 2.0 and 3.0 support\n\tSAF support\n}\n\nSpenser Sheng\t\t<spenser.sheng[AT]ericsson.com> {\n\tLCS-AP support\n}\n\nBenjamin Stocks\t\t<bmstocks[AT]ra.rockwell.com> {\n\tCIP Motion dissector\n}\n\nFlorian Reichert\t<refl[AT]zhaw.ch> {\n\tHSR and PRP-1 dissector\n}\n\nMartin Renold\t\t<reld[AT]zhaw.ch> {\n\tHSR and PRP-1 dissector\n}\n\nIain Arnell\t\t<iarnell[AT]epo.org> {\n\tajp13 enhancements\n}\n\nMariusz Okrój\t\t<okrojmariusz[AT]gmail.com> {\n\tXMPP enhancements\n}\n\nIvan Lawrow\t\t<ivan.lawrow[AT]jennic.com> {\n\tAdded IEEE 802.15.4-2003 AES-CCM security modes\n}\n\nKari Vatjus-Anttila\t<kari.vatjus-anttila[AT]cie.fi> {\n\tkNet (KristalliNet) dissector\n}\n\nShobhank Sharma\t\t<ssharma5[AT]ncsu.edu> {\n\tMPLS Enhancement - Generic Associated Channel, as per RFC 5586\n}\n\nSalil Kanitkar\t\t<sskanitk[AT]ncsu.edu> {\n\tOSPF Router Informational Capabilities - Opaque RI TLV - RFC4970\n\tOSPF Dynamic Hostname TLV in RI Opaque TLV - RFC5642\n}\n\nMichael Sakaluk\t\t<mdsakalu[AT]ncsu.edu> {\n\tBGP Encapsulation SAFI support (RFC 5512)\n\tLoad balancing for mesh softwires (RFC 5640)\n}\n\nMayuresh Raut\t\t<msraut[AT]ncsu.edu> {\n\tLSP ping over MPLS tunnels (RFC 6424)\n}\n\nSheetal Kshirsagar\t<sdkshirs[AT]ncsu.edu> {\n\tRPL SRH dissector enhancements (RFC 6554)\n}\n\nAndrew Williams\t\t<anwilli5[AT]ncsu.edu> {\n\tIPv6 preference for RPL SRH strict compliance to RFC 6554\n}\n\nPer Liedberg\t\t<per.liedberg[AT]ericsson.com> {\n\tRoHC dissection improvements\n}\n\nGaurav Tungatkar\t<gauravstt[AT]gmail.com> {\n\tExtended ICMP - Multipart Message Support (RFC 4884)\n\tand Extension for Interface and Next-Hop\n}\n\nBill Schiller\t\t<bill.schiller[AT]emerson.com> {\n\tHART/IP dissector\n}\n\nAditya Ambadkar\t\t<arambadk[AT]ncsu.edu> {\n\tSupport for flow label sub-tlv according to RFC 6391\n}\n\nDiana Chris\t\t<dvchris[AT]ncsu.edu> {\n\tSupport for flow label sub-tlv according to RFC 6391\n}\n\nGuy Martin\t\t<gmsoft[AT]tuxicoman.be> {\n\tDVB-DATA MultiProtocol Encapsulation dissector\n\tDVB Event Information Table (EIT) dissector\n\tDVB Network Information Table (NIT) dissector\n\tDVB Service Description Table (SDT) dissector\n\tDVB Time and Date Table (TDT) dissector\n\tDVB Time Offset Table (TOT) dissector\n\tDVB Bouquet Association Table (BAT) dissector\n\tMPEG2 Conditional Access Table (CA) dissector\n\tMPEG2 descriptors dissector\n\tMPEG2 Program Associate Table (PAT) dissector\n\tMPEG2 Program Map Table (PMT) dissector\n\tMPEG2 Section dissector\n}\n\nDeepti Ragha\t\t<dlragha[AT]ncsu.edu> {\n\tAdditions to ARP dissector to support opcodes as specified by IANA in\nhttps://www.iana.org/assignments/arp-parameters/arp-parameters.xml\n}\n\nNiels de Vos\t\t<ndevos[AT]redhat.com> {\n\tGluster dissectors\n}\n\nClement Marrast\t\t<clement.marrast[AT]molex.com> {\n\tWSE Remote Ethernet protocol\n}\n\nJacob Nordgren\t\t<jnordgren[AT]gmail.com> {\n\tUMTS FP/MAC/RLC dissection enhancement based on NBAP signaling\n}\n\nRishie Sharma\t\t<rishie[AT]kth.se> {\n\tUMTS FP/MAC/RLC dissection enhancement based on NBAP signaling\n}\n\nRichard Stearn\t\t<richard[AT]rns-stearn.demon.co.uk> {\n\tAX.25 support\n}\n\nTobias Rutz\t\t<tobias.rutz[AT]work-microwave.de> {\n\tDVB-S2 Baseband Frame and GSE support\n}\n\nMichał Łabędzki\t\t<michal.labedzki[AT]wireshark.org> {\n\tBluetooth BNEP dissector\n\tBluetooth HID dissector\n\tBluetooth SAP dissector\n\tBluetooth AVCTP dissector\n\tBluetooth AVRCP dissector\n\tBluetooth HCI USB transport dissector\n\tBluetooth HCI Linux Monitor transport dissector\n\tBluetooth MCAP dissector\n\tBluetooth HCRP dissector\n\tBluetooth AVDTP/A2DP/VDP/SBC dissectors\n\tBluetooth SDP significant improvements\n\tUbertooth USB firmware dissector\n\tELF file dissector\n\tAndroid ADB dissectors\n\tAndroid Logcat binary logs support\n}\n\nMichał Orynicz\t\t<michal.orynicz[AT]tieto.com> {\n\tAndroid Logcat text logs support\n}\n\nWido Kelling\t\t<kellingwido[AT]aol.com> {\n\tProfinet: Updated disecction regarding the IEC 61158\n}\n\nKaushal Shah\t\t<kshah3[AT]ncsu.edu> {\n\tSupport for Type Classification of Experimental\n\tand Reserved sub-TLVs as per Section 6 of RFC3630\n}\n\nSubramanian Ramachandran <sramach6[AT]ncsu.edu> {\n\tSupport for BFD for MPLS LSP's as per RFC 5884\n}\n\nManuel Hofer\t\t<manuel[AT]mnlhfr.at> {\n\tOpenVPN dissector\n\tSSTP Dissection\n}\n\nGaurav Patwardhan\t<gspatwar[AT]ncsu.edu> {\n\tSupport for GTSM Flag as per RFC 6720\n}\n\nPeter Hatina\t\t<phatina[AT]redhat.com> {\n\tGtk3 Wireshark fixes\n}\n\nTomasz Moń\t\t<desowin[AT]gmail.com> {\n\tUSBPcap support\n}\n\nUli Heilmeier\t\t<uh[AT]heilmeier.eu> {\n\tCARP dissector\n\tImproved SMTP Authentication dissection\n}\n\nRupesh Patro\t\t<rbpatro[AT]ncsu.edu> {\n\tSupport for Upstream-Assigned Label TLVs and Sub-TLVs as per RFC 6389\n}\n\nVaibhav Katkade\t\t<katkade_v[AT]yahoo.com> {\n\tSupport for Cisco MetaData (CMD) ethertype\n}\n\nAllan W. Nielsen\t<anielsen[AT]vitesse.com> {\n\tSupport for MACSEC ethertype/dissector\n}\n\nIshraq Ibne Ashraf\t<ishraq[AT]tinkerforge.com> {\n\ttfp (Tinkerforge) dissector\n}\n\nRobert Grange\t\t<robionekenobi[AT]bluewin.ch> {\n\tIBM WebSphere MQ protocol dissector enhancements\n}\n\nZoltan Lajos Kis\t<zoltan.lajos.kis[AT]ericsson.com> {\n\tOpenFlow dissector\n}\n\nJuan Antonio Montesinos <juan.mondl[AT]gmail.com> {\n\tDissector for the CCSDS CFDP protocol\n}\n\nAnish Bhatt\t\t<anish[AT]chelsio.com> {\n\tDissector for CIN DCBx\n\tDissector for CEE DCBx\n\tDissector for IEEE DCBx (802.1az)\n\tDissector for Congestion Notification (802.1Qau)\n}\n\nDmitry Bazhenov\t\t<dima_b[AT]pigeonpoint.com> {\n\tDissector for IPMI Trace\n}\n\nMasatake Yamato\t\t<yamato[AT]redhat.com> {\n\tDissector Distributed Lock Manager (dlm3)\n\tDissector for pulse\n\tDissectors for totemnet and totemsrp (Corosync)\n}\n\nJohn Miner\t\t<wiresharkdissectorcoder[AT]gmail.com> {\n\tDissector for OptoMMP\n}\n\n竹下 恵 (Megumi Takeshita) <megumi[AT]ikeriri.ne.jp> {\n\tJapanese translation of the Qt User Interface\n}\n\nRemi Vichery\t\t<remi.vichery[AT]gmail.com> {\n\tDissector for Stateless Transport Tunneling (STT)\n}\n\nKevin Cox\t\t<kevincox[AT]kevincox.ca> {\n\tDissector for Ceph\n}\n\nDavid Ameiss\t\t<dameiss[AT]29west.com> {\n\t29West/LBM dissectors\n}\n\nSean O. Stalley\t\t<sean.stalley[AT]intel.com> {\n\tDissector for Media Agnostic USB (MA USB)\n}\n\nQiaoyin Yang\t\t<qiaoyin.yang[AT]gmail.com> {\n\tDissector for CP 'Cooper' 2179\n}\n\nThomas Wiens\t\t<th.wiens[AT]gmx.de> {\n\tDissector for S7 Communication\n}\n\nGilles Roudiere\t\t<gilles[AT]roudiere.net> {\n\tDissector for the Dynamic Source Routing (DSR) protocol (RFC 4728)\n}\n\nAlexander Gaertner\t<gaertner.alex[AT]gmx.de> {\n\tKNXnetIP dissector\n}\n\nRaphaël Doursenaud\t<rdoursenaud[AT]free.fr> {\n\tHarman Pro HiQnet dissector\n}\n\nRyan Doyle\t\t<ryan[AT]doylenet.net> {\n\tDissector for Elasticsearch\n\tDissector for Performance Co-Pilot\n}\n\nJesse Gross\t\t<jesse[AT]nicira.com> {\n\tDissector for Geneve\n}\n\nJoe Fowler\t\t<fowlerja[AT]us.ibm.com> {\n\tDissector for Shared Memory Communication over RDMA (SMC-R)\n}\n\nEnrico Jorns\t\t<ejo[AT]pengutronix.de> {\n\tCANopen dissector enhancements and fixes\n}\n\nHitesh K Maisheri\t<maisheri.hitesh[AT]gmail.com> {\n        EAPOL-MKA support\n}\n\nDario Lombardo\t\t<lomato[AT]gmail.com> {\n\tchargen (Character Generator) dissector\n\tItalian translation (QT)\n\tHCrt (Hotline Command-Response Transaction) dissector\n}\n\nPratik Yeole\t\t<pyeole[AT]ncsu.edu> {\n         Fixed incorrect decoding of Network Layer Reachability Information (NLRI) in BGP UPDATE message with add-path support\n}\n\nGuillaume Autran\t<gautran[AT]clearpath.ai> {\n\tTCPROS support\n}\n\nBarbu Paul - Gheorghe\t<barbu.paul.gheorghe[AT]gmail.com> {\n\tDeveloper documentation improvements\n}\n\nMartin Kacer\t<kacer.martin[AT]gmail.com> {\n\tJSON and Elasticsearch tshark output\n\tjson2pcap\n}\n\nBen Stewart\t\t<bst[AT]google.com> {\n\tSCTE-35 dissector\n}\n\nSumit Kumar Jha\t\t<sjha3[AT]ncsu.edu> {\n\tGeneric Protocol Extension Support for VXLAN\n}\n\nKim Kempf\t\t<kim.kempf[AT]apcon.com> {\n\t802.1BR E-Tag dissector\n}\n\nS. Shapira\t\t<sswsdev[AT]gmail.com> {\n\tUMTS FP heuristic dissectors\n}\n\nLazar Sumar\t\t<bugzilla[AT]lazar.co.nz> {\n\tCAN-ETH dissectors\n}\n\nKingson Chan\t<k.chan[AT]samsung.com> {\n\tWi-Fi Alliance Neighbor Awareness Networking (NAN) dissector\n}\n\nEge Elgun\t\t<e.elgun[AT]samsung.com> {\n\tWi-Fi Alliance Neighbor Awareness Networking (NAN) dissector\n}\n\nConnor Newton   <c.newton[AT]samsung.com> {\n\tWi-Fi Alliance Neighbor Awareness Networking (NAN) dissector\n}\n\nHuang Qiangxiong        <qiangxiong.huang[AT]qq.com> {\n\tProtobuf dissector\n\tgRPC dissector\n\tHTTP2 dissector: add streaming mode reassembly and dissecting DATA according to content-type features.\n\tReassembly: add types and functions to simplify streaming data reassembly.\n\tHTTP dissector: support dissecting chunked data in streaming reassembly mode.\n}\n\nJeffrey Nichols\t\t<jsnichols[AT]suprocktech.com> {\n\tAsphodel dissector\n}\n\nErik Rigtorp\t\t<erik[AT]rigtorp.se> {\n\tSupport for reading ZSTD and LZ4 compressed files\n}\n\nMartin Mayer\t\t<martin.mayer[AT]m2-it-solutions.de> {\n\tAllied Telesis Loop Detection Frames (LDF) dissector\n\tOpen Control Protocol for AES70/OCA (OCP.1) dissector\n}\n\nMattia Cazzola\t\t<mattiac[AT]alinet.it> {\n\tProvided a patch to the hex dump display routine.\n}\n\nand by:\n\nGeorgi Guninski\t\t<guninski[AT]guninski.com>\nJason Copenhaver\t<jcopenha[AT]typedef.org>\nEric Perie\t\t<eric.perie[AT]colubris.com>\nDavid Yon\t\t<yon[AT]tacticalsoftware.com>\nMarcio Franco\t\t<franco.marcio[AT]rd.francetelecom.fr>\nKaloian Stoilov\t\t<kalkata[AT]yahoo.com>\nSteven Lass\t\t<stevenlass[AT]mail.com>\nGregory Stark\t\t<gsstark[AT]mit.edu>\nDarren Steele\t\t<steeley[AT]steeley.co.uk>\nMichael Kopp\t\t<michael.kopp[AT]isarnet.de>\nBernd Leibing\t\t<bernd.leibing[AT]kiz.uni-ulm.de>\nChris Heath\t\t<chris[AT]heathens.co.nz>\nGisle Vanem\t\t<gvanem[AT]broadpark.no>\nRitchie\t\t\t<ritchie[AT]tipsybottle.com>\nAki Immonen\t\t<aki.immonen[AT]golftalma.fi>\nDavid E. Weekly\t\t<david[AT]weekly.org>\nSteve Ford\t\t<sford[AT]geeky-boy.com>\nMasaki Chikama\t\t<masaki-c[AT]is.aist-nara.ac.jp>\nMohammad Hanif\t\t<mhanif[AT]nexthop.com>\nReinhard Speyerer\t<rspmn[AT]arcor.de>\nPatrick Kursawe\t\t<phosphan[AT]gentoo.org>\nArsen Chaloyan\t\t<achaloyan[AT]yahoo.com>\nArnaud Jacques\t\t<webmaster[AT]securiteinfo.com>\nD. Manzella\t\t<manzella[AT]lucent.com>\nJari Mustajarvi\t\t<jari.mustajarvi[AT]nokia.com>\nPierre Juhen\t\t<pierre.juhen[AT]wanadoo.fr>\nDavid Richards\t\t<drichards[AT]alum.mit.edu>\nShusaku Ueda\t\t<ueda[AT]sra.co.jp>\nJonathan Perkins\t<jonathan.perkins[AT]ipaccess.com>\nHolger Schurig\t\t<h.schurig[AT]mn-logistik.de>\nPeter J. Creath\t\t<peter-ethereal[AT]creath.net>\nMagnus Hansson\t\t<mah[AT]hms.se>\nPavel Kankovsky\t\t<kan[AT]dcit.cz>\nNick Black\t\t<dank[AT]reflexsecurity.com>\nBill Guyton\t\t<guyton[AT]bguyton.com>\nChernishov Yury\t\t<Chernishov[AT]iskrauraltel.ru>\nThomas Palmer\t\t<Thomas.Palmer[AT]Gunter.AF.mil>\nClinton Work\t\t<clinton[AT]scripty.com>\nJoe Marcus Clarke\t<marcus[AT]marcuscom.com>\nKendy Kutzner\t\t<kutzner[AT]tm.uka.de>\nJames H. Cloos Jr.\t<cloos[AT]jhcloos.com>\nTim Farley\t\t<tfarley[AT]iss.net>\nDaniel Thompson\t\t<daniel.thompson[AT]st.com>\nChris Jepeway\t\t<thai-dragon[AT]eleven29.com>\nMatthew Bradley\t\t<matthew.bradley[AT]cnsonline.net>\nNathan Alger\t\t<nathan[AT]wasted.com>\nStas Grabois\t\t<sagig[AT]radware.com>\nAinsley Pereira\t\t<APereira[AT]Witness.com>\nPhilippe Mazeau\t\t<philippe.mazeau[AT]swissvoice.net>\nCarles Kishimoto\t<ckishimo[AT]ac.upc.es>\nDennis Lim\t\t<postadal[AT]suse.cz>\nDennis Lim\t\t<Dennis.Lim[AT]motorola.com>\nMartin van der Werff\t<martin[AT]vanderwerff.org>\nMarco van den Bovenkamp\t<marco[AT]linuxgoeroe.dhs.org>\nMing Zhang\t\t<mingz[AT]ele.uri.edu>\nNeil Piercy\t\t<Neil.Piercy[AT]ipaccess.com>\nRémi Denis-Courmont\t<courmisch[AT]via.ecp.fr>\nThomas Palmer\t\t<tpalmer[AT]elmore.rr.com>\nMårten Svantesson\t<f95-msv[AT]f.kth.se>\nSteve Sommars\t\t(e-mail address removed at contributor's request)\nKestutis Kupciunas\t<kesha[AT]soften.ktu.lt>\nRené Pilz\t\t<rene.pilz[AT]ftw.at>\nLaurent Constantin\t<laurent.constantin[AT]aql.fr>\nMartin Pichlmaier\t<martin.pichlmaier[AT]siemens.com>\nMark Phillips\t\t<msp[AT]nortelnetworks.com>\nNils Ohlmeier\t\t<lists[AT]ohlmeier.org>\nIgnacio Goyret\t\t<igoyret[AT]lucent.com>\nBart Braem\t\t<bart.braem[AT]gmail.com>\nShingo Horisawa\t\t<name4n5[AT]hotmail.com>\nLane Hu\t\t\t<lane.hu[AT]utstar.com>\nMarc Poulhiès\t\t<marc.poulhies[AT]epfl.ch>\nTomasz Mrugalski\t<thomson[AT]klub.com.pl>\nBrett Kuskie\t\t<mstrprgmmr[AT]chek.com>\nBrian Caswell\t\t<bmc[AT]sourcefire.com>\nYann\t\t\t<yann_eads[AT]hotmail.com>\nJulien Leproust\t\t<julien[AT]via.ecp.fr>\nMutsuya Irie\t\t<irie[AT]sakura-catv.ne.jp>\nYoshihiro Oyama\t\t<y.oyama[AT]netagent.co.jp>\nChris Eagle\t\t<cseagle[AT]nps.edu>\nDominique Bastien\t<dbastien[AT]accedian.com>\nNicolas Dichtel\t\t<nicolas.dichtel[AT]6wind.com>\nRicardo Muggli\t\t<ricardo.muggli[AT]mnsu.edu>\nVladimir Kondratiev\t<vladimir.kondratiev[AT]gmail.com>\nJaap Keuter\t\t<jaap.keuter[AT]xs4all.nl>\nFrederic Peters\t\t<fpeters[AT]debian.org>\nAnton Ivanov\t\t<anthony_johnson[AT]mail.ru>\nIlya Konstantinov\t<future[AT]shiny.co.il>\nNeil Kettle \t\t<mu-b[AT]65535.com>\nSteve Karg\t\t<skarg[AT]users.sourceforge.net>\nJavier Acuna\t\t<javier.acuna[AT]sixbell.cl>\nMiklos Szurdi\t\t<szurdimiklos[AT]yahoo.com>\nCvetan Ivanov\t\t<zezo[AT]spnet.net>\nVasanth Manickam\t<vasanth.manickam[AT]bt.com>\nJulian Onions\t\t<julian.onions[AT]gmail.com>\nSamuel Thibault\t\t<samuel.thibault[AT]ens-lyon.org>\nPeter Kovář\t\t<peter.kovar[AT]gmail.com>\nPaul Ollis\t\t<paul.ollis[AT]roke.co.uk>\nDominik Kuhlen\t\t<dkuhlen[AT]gmx.net>\nKarl Knoebl\t\t<karl.knoebl[AT]siemens.com>\nMaria-Luiza Crivat\t<luizacri[AT]gmail.com>\nBrice Augustin\t\t<bricecotte[AT]gmail.com>\nMatt Thornton\t\t<MATT_THORNTON[AT]appsig.com>\nTimo Metsala\t\t<timo.metsala[AT]gmail.com>\nTomer Shani\t\t<thetour[AT]japan.com>\nManu Pathak\t\t<mapathak[AT]cisco.com>\nJohn Sullivan\t\t<john[AT]kanargh.force9.co.uk>\nMartin André\t\t<andre[AT]clarinet.u-strasbg.fr>\nAndrei Emeltchenko\t<Andrei.Emeltchenko[AT]nokia.com>\nKirby Files\t\t<kfiles[AT]masergy.com>\nRavi Valmikam\t\t<rvalmikam[AT]airvananet.com>\nDiego Pettenò\t\t<flameeyes[AT]gentoo.org>\nDaniel Black\t\t<dragonheart[AT]gentoo.org>\nChristoph Werle\t\t<Christoph.Werle[AT]ira.uka.de>\nAaron Christensen\t<aaronmf[AT]gmail.com>\nIan Abel\t\t<ianabel[AT]mxtelecom.com>\nBryant Eastham\t\t<beastham[AT]slc.mew.com>\nTaner Kurtulus\t\t<taner.kurtulus[AT]tubitak.gov.tr>\nJoe Breher\t\t<linux[AT]q-music.com>\nPatrick vd Lageweg\t<patrick[AT]bitwizard.nl>\nThomas Sillaber\t\t<Thomas.Sillaber[AT]gmx.de>\nMike Davies\t\t<m.davies[AT]btinternet.com>\nBoris Misenov\t\t<Boris.Misenov[AT]oktelabs.ru>\nJoe McEachern\t\t<joe[AT]qacafe.com>\nCharles Lepple\t\t<clepple[AT]gmail.com>\nTuomas Maattanen\t<maattanen[AT]iki.fi>\nJoe Eykholt\t\t<joe[AT]nuovasystems.com>\nIan Brumby\t\t<ian.brumby[AT]baesystems.com>\nTodd J Martin\t\t<todd.martin[AT]acm.org>\nScott Robinson\t\t<scott.robinson[AT]flukenetworks.com>\nMartin Peylo\t\t<wireshark[AT]izac.de>\nStéphane Loeuillet\t<leroutier[AT]gmail.com>\nAndrei Rubaniuk\t\t<rubaniuk[AT]mail.ru>\nMikael Magnusson\t<mikma264[AT]gmail.com>\nTimo Teräs\t\t<timo.teras[AT]iki.fi>\nMárton Németh\t\t<nm127[AT]freemail.hu>\nKai Blin\t\t<kai[AT]samba.org>\nOlivier Montanuy\t<olivier.montanuy[AT]orange-ftgroup.com>\nThomas Morin\t\t<thomas.morin[AT]orange-ftgroup.com>\nJesus Roman\t\t<jroman[AT]teldat.com>\nGiodi Giorgi\t\t<g.giorgi[AT]gmail.com>\nPeter Hertting\t\t<Peter.Hertting[AT]gmx.net>\nJess Balint\t\t<jbalint[AT]gmail.com>\nBahaa Naamneh\t\t<b.naamneh[AT]gmail.com>\nMagnus Sörman\t\t<magnus.sorman[AT]ericsson.com>\nPascal Quantin\t\t<pascal.quantin[AT]gmail.com>\nRoy Marples\t\t<roy[AT]marples.name>\nWard van Wanrooij\t<ward[AT]ward.nu>\nFederico Mena Quintero\t<federico[AT]novell.com>\nAndreas Heise\t\t<andreas.heise[AT]nextiraone.de>\nAlex Lindberg\t\t<alindber[AT]yahoo.com>\nRama Chitta\t\t<rama[AT]gear6.com>\nRoberto Mariani\t\t<jelot-wireshark[AT]jelot.it>\nSandhya Gopinath\t<Sandhya.Gopinath[AT]citrix.com>\nRaghav SN\t\t<Raghav.SN[AT]citrix.com>\nMurali Raja\t\t<Murali.Raja[AT]citrix.com>\nDevesh Prakash\t\t<Devesh.Prakash[AT]citrix.com>\nDarryl Champagne\t<dchampagne[AT]sta.samsung.com>\nMichael Speck\t\t<Michael.Speck[AT]avl.com>\nGerasimos Dimitriadis\t<dimeg[AT]intracom.gr>\nRobert Simac\t\t<rsimac[AT]cronsult.com>\nJohanna Sochos\t\t<johanna.sochos[AT]swissqual.com>\nFelix Obenhuber\t\t<felix[AT]obenhuber.de>\nHilko Bengen\t\t<bengen--wireshark[AT]hilluzination.de>\nHadar Shoham\t\t<hadar.shoham[AT]gmail.com>\nRobert Bullen\t\t<robert[AT]robertbullen.com>\nChuck Kristofek\t\t<chuck.kristofek[AT]ngc.com>\nMarkus Renz\t\t<Markus.Renz[AT]hirschmann.de>\nToshihiro Kataoka\t<kataoka.toshihiro[AT]gmail.com>\nPetr Lautrbach\t\t<plautrba[AT]redhat.com>\nFrank Lahm\t\t<franklahm[AT]googlemail.com>\nJon Ellch\t\t<jellch[AT]harris.com>\nAlex Badea\t\t<vamposdecampos[AT]gmail.com>\nDirk Jagdmann\t\t<doj[AT]cubic.org>\nRSA  \t\t\t<ryazanov.s.a[AT]gmail.com>\nJuliusz Chroboczek\t<jch[AT]pps.jussieu.fr>\nVladimir Kazansky\t<vovjo[AT]yandex.ru>\nPeter Paluch \t\t<peter.paluch[AT]fri.uniza.sk>\nTom Brezinski\t\t<tombr[AT]netinst.com>\nNick Glass\t\t<nick.glass[AT]lycos.com>\nMichael Mann\t\t<mmann78[AT]netscape.net>\nRomain Fliedel\t\t<romain.fliedel+wireshark[AT]gmail.com>\nMichael Chen\t\t<michaelc[AT]idssoftware.com>\nPaul Stath\t\t<pstath[AT]axxcelera.com>\nDeCount\t\t\t<aatrade[AT]libero.it>\nAndras Veres-Szentkiralyi <vsza[AT]vsza.hu>\nJakob Hirsch \t\t<jh.wireshark-bugzilla[AT]plonk.de>\nРоман Донченко\t\t<dpb[AT]corrigendum.ru>\nbillyjeans\t\t<billyjeans[AT]gmail.com>\nEvan Huus\t\t<eapache[AT]gmail.com>\nTom Cook\t\t<tcook[AT]ixiacom.com>\nTom Alexander\t\t<talexander[AT]ixiacom.com>\nKlaus Heckelmann\t<klaus.heckelmann[AT]nashtech.com>\nBen Bowen\t\t<bbowen[AT]godaddy.com>\nBodo Petermann\t\t<bp245[AT]hotmail.com>\nMartin Kupec\t\t<martin.kupec[AT]kupson.cz>\nLitao Gao\t\t<ltgao[AT]juniper.net>\nNiels Widger\t\t<niels[AT]qacafe.com>\nPontus Fuchs\t\t<pontus.fuchs[AT]gmail.com>\nBill Parker\t\t<wp02855[AT]gmail.com>\nTomofumi Hayashi\t<s1061123[AT]gmail.com>\nTim Hentenaar\t\t<tim.hentenaar[AT]gmail.com>\nKrishnamurthy Mayya\t<krishnamurthymayya[AT]gmail.com>\nNikitha Malgi\t\t<nikitha01[AT]gmail.com>\nAdam Butcher\t\t<adam[AT]jessamine.co.uk>\nHendrik Uhlmann\t\t<Hendrik.Uhlmann[AT]rheinmetall.com>\nSebastiano Di Paola\t<sebastiano.dipaola[AT]gmail.com>\nSteven J. Magnani\t<steve[AT]digidescorp.com>\nDavid Arnold\t\t<davida[AT]pobox.com>\nAlexander Chemeris\t<alexander.chemeris[AT]gmail.com>\nIvan Klyuchnikov\t<kluchnikovi[AT]gmail.com>\nMax Baker\t\t<max[AT]warped.org>\nDiederik de Groot\t<dkgroot[AT]talon.nl>\nHauke Mehrtens\t\t<hauke[AT]hauke-m.de>\n0xBismarck\t\t<0xbismarck[AT]gmail.com>\nPeter Van Eynde\t\t<pevaneyn[AT]cisco.com>\nMarko Hrastovec\t\t<marko.hrastovec[AT]sloveniacontrol.si>\nMike Garratt\t\t<mg.wireshark[AT]evn.co.nz>\nFabio Tarabelloni\t<fabio.tarabelloni[AT]reloc.it>\nChas Williams\t\t<chas[AT]cmf.nrl.navy.mil>\nJavier Godoy\t\t<uce[AT]rjgodoy.com.ar>\nMatt Texier\t\t<matthieu[AT]texier.tv>\nLinas Vepstas\t\t<linasvepstas[AT]gmail.com>\nSimon Zhong\t\t<szhong[AT]juniper.net>\nBart Van Assche\t\t<bvanassche[AT]acm.org>\nPeter Lemenkov\t\t<lemenkov[AT]gmail.com>\nKarl Beldan\t\t<karl.beldan[AT]gmail.com>\nJiri Engelthaler\t<engycz[AT]gmail.com>\nStephen Ludin\t\t<sludin[AT]ludin.org>\nAndreas Urke\t\t<andurke[AT]gmail.com>\nPatrik Lundquist\t<patrik.lundquist[AT]gmail.com>\nMark Vitale\t\t<mvitale[AT]sinenomine.net>\nPeter Wu\t\t<peter[AT]lekensteyn.nl>\nJerry Negele\t\t<jerry.negele[AT]arrisi.com>\nHannes Hofer\t\t<hhofer[AT]barracuda.com>\nLuca Coelho\t\t<luca[AT]coelho.fi>\nMasayuki Takemura\t<masayuki.takemura[AT]gmail.com>\nEd Beroset\t\t<beroset[AT]mindspring.com>\ne.yimjia\t\t<jy.m12.0[AT]gmail.com>\nJonathon Jongsma\t<jjongsma[AT]redhat.com>\nZeljko Ancimer\t\t<zancimer[AT]gmail.com>\nDeon van der Westhuysen\t<deonvdw[AT]gmail.com>\nIbrahim Can Yuce\t<canyuce[AT]gmail.com>\nRobert Jongbloed\t<robertj[AT]voxlucida.com.au>\nPavel Moravec\t\t<pmoravec[AT]redhat.com>\nRobert Long\t\t<rlong[AT]sandia.gov>\nJames Lynch\t\t<lynch007[AT]gmail.com>\nChidambaram Arunachalam\t<carunach[AT]cisco.com>\nJoão Valverde\t\t<j[AT]v6e.pt>\nBenoît Canet\t\t<benoit[AT]scylladb.com>\nHåkon Øye Amundsen\t<haakon.amundsen[AT]nordicsemi.no>\nJeffrey Wildman\t\t<jeffrey.wildman[AT]ll.mit.edu>\nJan Schiefer\t\t<jan.schiefer[AT]keysight.com>\nTriton Circonflexe\t<triton+enuiqr[AT]kumal.info>\n\n\n= From git log =\n\naaptel\t\t\t<aaptel[AT]suse.com>\nAaron Brice\t\t<aaron.brice[AT]nikolamotor.com>\nAaron Turner\t\t<synfinatic[AT]gmail.com>\nAbhinav Chandran\t<abhinav.chandran[AT]hpe.com>\nAbhinay Ramesh\t\t<rabhinay[AT]vmware.com>\nAchuthan Paramanathan\t<acp[AT]kamstrup.com>\nAdam Aposhian\t\t<adam.aposhian[AT]fireflyautomatix.com>\nAdam Goldman\t\t<adam.goldman[AT]intel.com>\nAdam Mitz\t\t<mitza[AT]objectcomputing.com>\nAdam Mitz\t\t<mitza[AT]ociweb.com>\nAdam Morrison\t\t<adammo[AT]extrahop.com>\nAdam Parker\t\t<foreverska[AT]protonmail.com>\nAdam Pridgen\t\t<adam.pridgen[AT]thecoverofnight.com>\nAdam Schwalm\t\t<adam.schwalm[AT]dynetics.com>\nAdam W\t\t\t<dev[AT]wujek.eu>\nAdam Wujek\t\t<adam.wujek[AT]cern.ch>\nAdam Wujek\t\t<dev_public[AT]wujek.eu>\naddobric\t\t<adrian.dobrica[AT]keysight.com>\nAdedeji Adeloye\t\t<adadeloy[AT]microsoft.com>\nAdedeji Adeloye\t\t<adeloyedeji[AT]gmail.com>\nAditya Jain\t\t<aditya.jain[AT]samsung.com>\nAdrian Granados\t\t<adrian[AT]adriangranados.com>\nAdrian Granados\t\t<adrian[AT]intuitibits.com>\nAdrian Ratiu\t\t<adrian.ratiu[AT]collabora.com>\nAdrian Simionov\t\t<daniel.simionov[AT]gmail.com>\nAdrian-Ken Rueegsegger\t<ken[AT]codelabs.ch>\nAdrien Aubry\t\t<adraub[AT]gmail.com>\nAdrien Destugues\t<adestugues[AT]toulouse.viveris.com>\nAdrien Destugues\t<adrien.destugues[AT]opensource.viveris.fr>\nAeneas Jaißle\t\t<aj[AT]ajaissle.de>\nAhmad Fatoum\t\t<ahmad[AT]a3f.at>\nAhmad Hazimeh\t\t<ahmad.hazimeh[AT]epfl.ch>\nAhmet Alperen\t\t<bltalperen[AT]gmail.com>\nAidan MacDonald\t\t<amachronic[AT]protonmail.com>\nAitor Garcia\t\t<garcia.aitor[AT]gmail.com>\nAjay Panicker\t\t<apanicke[AT]google.com>\nakuchekar\t\t<akuchekar[AT]empirix.com>\nAlan Birtles\t\t<alan.birtles[AT]eu.sony.com>\nAlan Partis\t\t<alpartis[AT]thundernet.com>\nAlbert Chuang\t\t<achuang[AT]wi-fi.org>\nAlberto Pasquale\t<alberto[AT]apworks.eu>\nAlberto Sartori\t\t<alberto.sartori.as[AT]gmail.com>\nAleksej Matis\t\t<amat[AT]magure.de>\nAles Povalac\t\t<alpov[AT]alpov.net>\nAlex Badea\t\t<abadea[AT]ixiacom.com>\nAlex Converse\t\t<alexconv[AT]twitch.tv>\nAlex Nik\t\t<rage.iz.me[AT]gmail.com>\nAlex Sirr\t\t<alexsirruw[AT]gmail.com>\nAlex Tessmer\t\t<dev[AT]tessmer.me>\nAlexander Aring\t\t<aahringo[AT]redhat.com>\nAlexander Basargin\t<alexander.bsrgin[AT]yandex.ru>\nAlexander Clouter\t<aclouter[AT]networkradius.com>\nAlexander Clouter\t<alex[AT]digriz.org.uk>\nAlexander Couzens\t<lynxis[AT]fe80.eu>\nAlexander Dahl\t\t<ada[AT]thorsis.com>\nAlexander Funke\t\t<alexander.funke[AT]fh-muenster.de>\nAlexander Gärtner\t<sphinxs1988[AT]googlemail.com>\nAlexander Gryanko\t<xpahos[AT]gmail.com>\nAlexander Meier\t\t<MeierAPunkt[AT]googlemail.com>\nAlexander Nogikh\t<wp32pw[AT]gmail.com>\nAlexander Stein\t\t<alexanders83[AT]web.de>\nAlexander Werth\t\t<alexander.werth[AT]gmx.de>\nAlexander Wetzel\t<alexander.wetzel[AT]web.de>\nAlexander Zubkov\t<green[AT]qrator.net>\nAlexandr Savca\t\t<alexandr.savca89[AT]gmail.com>\nAlexis Green\t\t<alexis.green[AT]nokia.com>\nAlexis Gryta\t\t<alexis.gryta[AT]liquid-markets.com>\nAlexL\t\t\t<loginov.alex.valer[AT]gmail.com>\nAlfred Koebler\t\t<alfred.koebler[AT]gmx.de>\nAlfredo\t\t\t<aandreswork[AT]hotmail.com>\nAli Sabil\t\t<ali.sabil[AT]koperadev.com>\nAlistair Leslie-Hughes\t<leslie_alistair[AT]hotmail.com>\nAllan Møller Madsen\t<almomadk[AT]gmail.com>\nAlvin\t\t\t<alvin.xu[AT]nokia-sbell.com>\nAmbarish Malpani\t<ambarish[AT]defend7.com>\nAmeya Deshpande\t\t<ameya.181co205[AT]nitk.edu.in>\nAmeya Deshpande\t\t<ameyanrd[AT]gmail.com>\nAmeya Deshpande\t\t<ameyanrd[AT]outlook.com>\nAmine Kherbouche\t<amine.kherbouche[AT]6wind.com>\nAmit Cohen\t\t<amcohen[AT]nvidia.com>\nAmit Khatri\t\t<amit7861234[AT]gmail.com>\nAmitoj Setia\t\t<asetia[AT]juniper.net>\nAna Pantar\t\t<ana.pantar[AT]gmail.com>\nAnaël Fiaux\t\t<anael[AT]fiaux.org>\nAnanya\t\t\t<ananyagopal61[AT]gmail.com>\nAnders Esbensen\t\t<Anders.Esbensen[AT]silabs.com>\nAndoni Diaz de Cerio\t<andoni.diazdecerio[AT]nemergent-solutions.com>\nAndre Luyer\t\t<andre[AT]luyer.nl>\nAndre Puschmann\t\t<andre[AT]softwareradiosystems.com>\nAndreas Gruenbacher\t<andreas.gruenbacher[AT]gmail.com>\nAndreas Karlsson\t<se.nakarlsson[AT]gmail.com>\nAndreas Leibold\t\t<andreas.leibold[AT]harman.com>\nAndreas Schultz\t\t<andreas.schultz[AT]travelping.com>\nAndreas Stieger\t\t<andreas.stieger[AT]gmx.de>\nAndreas Urke\t\t<arurke[AT]netwurke.com>\nAndrei Cipu\t\t<acipu[AT]ixiacom.com>\nAndrew Chernyh\t\t<andrew.chernyh[AT]gmail.com>\nAndrew Hoag\t\t<Andrew.Hoag[AT]aireon.com>\nAndrew Shultzabarger\t<andrew[AT]ardnew.com>\nAndrey Kulikov\t\t<amdei[AT]cryptopro.ru>\nAndrey Tverd\t\t<andr.tverd[AT]gmail.com>\nAndrii Vladyka\t\t<a.vladyka[AT]ukr.net>\nAndrii Vladyka\t\t<andrii.vladyka[AT]harmonicinc.com>\nAndy Grover\t\t<agrover[AT]cloudflare.com>\nAndy Ling\t\t<Andy.Ling[AT]quantel.com>\nAndy Ling\t\t<andy.ling[AT]s-a-m.com>\nAndy Zhao\t\t<jinhzhx[AT]gmail.com>\nAngelo Spampinato\t<aspampinato[AT]protonmail.com>\nAngelos Drossos\t\t<wireshark.develangel[AT]mail.drossos.de>\nAnil Kumar\t\t<anilkumar911[AT]gmail.com>\nAnndy Ke\t\t<anndymaktub[AT]yahoo.com.tw>\nanonsvn\t\t\t<anonsvn[AT]localhost>\nAnthony Coddington\t<anthony.coddington[AT]endace.com>\nAnthony Crawford\t<anthony.r.crawford[AT]charter.com>\nAntoine Gardiol\t\t<antoine.gardiol[AT]fiveco.ch>\nAnton Butenko\t\t<ant.butenko[AT]gmail.com>\nAnton Glukhov\t\t<anton.a.glukhov[AT]gmail.com>\nAnton Kharchenko\t<astotal[AT]gmail.com>\nAnton Thomasson\t\t<anton.thomasson[AT]ericsson.com>\nAntonio Vázquez Blanco\t<antoniovazquezblanco[AT]gmail.com>\nAntony Bridle\t\t<ant.bridle[AT]gmail.com>\nApeksha Singhal\t\t<apeksha.singhal[AT]gmail.com>\nArjen Zonneveld\t\t<arjen[AT]bz2.nl>\nArkadiusz Bokowy\t<a.bokowy[AT]samsung.com>\nArkadiusz Bokowy\t<arkadiusz.bokowy[AT]gmail.com>\nArkady Gilinsky\t\t<8351139-ark-g[AT]users.noreply.gitlab.com>\nArkady Gilinsky\t\t<arkady.gilinsky[AT]harmonicinc.com>\nArmin Felder\t\t<Armin.Felder[AT]gmail.com>\nArnd Hannemann\t\t<arnd[AT]arndnet.de>\nArne Schwabe\t\t<arne[AT]rfc2549.org>\nArnout Vandecappelle (Essensium/Mind) <arnout[AT]mind.be>\nArtem Kan\t\t<artyom.kan[AT]dsr-corporation.com>\nArtem Kan\t\t<kan.art.email[AT]gmail.com>\nArtem Mygaiev\t\t<joculator[AT]gmail.com>\nArtur Nowosielski\t<artnowo[AT]gmail.com>\nArvind Dalvi\t\t<ardalvi[AT]outlook.in>\nAsaf Kave\t\t<kaveasaf[AT]gmail.com>\nAshish Shukla\t\t<shukla.a[AT]gmail.com>\nAtli Guðmundsson\t<atli[AT]tern.is>\natsju\t\t\t<atsju2[AT]yahoo.fr>\natul358\t\t\t<atul358[AT]gmail.com>\nAudric Schiltknecht\t<audric+gitlab[AT]schiltknecht.org>\nAudric Schiltknecht\t<audric.schiltknecht[AT]external.thalesaleniaspace.com>\nAurelien Aptel\t\t<aaptel[AT]nvidia.com>\nAymeric Moizard\t\t<amoizard[AT]gmail.com>\nBabak Farrokhi\t\t<babak[AT]farrokhi.net>\nBahadir Ozgun\t\t<bhdrozgn[AT]gmail.com>\nBalint Reczey\t\t<rbalint[AT]ubuntu.com>\nBart-Baekelandt\t\t<bart.stefan.baekelandt[AT]gmail.com>\nBartel Eerdekens\t<bartel.eerdekens[AT]constell8.be>\nBartłomiej Nóżka\t<git[AT]nozka.net.pl>\nBartolo Otrit\t\t<bartolootrit[AT]gmail.com>\nBaruch Siach\t\t<baruch[AT]tkos.co.il>\nBaşak Kalfa\t\t<basakkalfa[AT]gmail.com>\nBasil\t\t\t<addremover[AT]gmail.com>\nBastien Bailly\t\t<babassbailly[AT]free.fr>\nBen Bass\t\t<ben.bass[AT]metaswitch.com>\nBen Burwell\t\t<bburwell[AT]lutron.com>\nBen Cartwright-Cox\t<ben[AT]benjojo.co.uk>\nBen Fox-Moore\t\t<ben.foxmoore[AT]accelleran.com>\nBen Huddleston\t\t<ben.huddleston[AT]couchbase.com>\nBenedikt Heumüller\t<BHeumueller[AT]hilscher.com>\nBenjamin Aschenbrenner\t<benjamin.aschenbrenner[AT]gmail.com>\nBenjamin Coddington\t<bcodding[AT]redhat.com>\nBenjamin Hesmans\t<benjamin.hesmans[AT]uclouvain.be>\nBenjamin Levine\t\t<levbinyamin[AT]gmail.com>\nBenjamin Parzella\t<bparzella[AT]gmail.com>\nBenjamin Roch\t\t<benjamin.roch[AT]tttech.com>\nBenoit Grange\t\t<benoit.grange[AT]gmail.com>\nBerk Akinci\t\t<berka[AT]alum.wpi.edu>\nBernhard Dick\t\t<bernhard[AT]bdick.de>\nBert van Leeuwen\t<bert.vanleeuwen[AT]gmail.com>\nBertrand Bonnefoy-Claudet <bertrandbc[AT]gmail.com>\nBharath Ravindranath\t<bravindranath[AT]arista.com>\nBill Durr\t\t<billyburly[AT]gmail.com>\nBin Peng\t\t<binpengsmail[AT]gmail.com>\nBinh Trinh\t\t<beango[AT]gmail.com>\nBirol Capa\t\t<birol.capa[AT]siemens.com>\nBiswapriyo Nath\t\t<nathbappai[AT]gmail.com>\nBjoern Riemer\t\t<bjoern.riemer[AT]fokus.fraunhofer.de>\nBjörn Ruytenberg\t<bjorn[AT]bjornweb.nl>\nBob Hinden\t\t<bob.hinden[AT]gmail.com>\nBob Kuo\t\t\t<bobjkuo[AT]gmail.com>\nBogdan Nicorici\t\t<bogdannbv[AT]gmail.com>\nbookding\t\t<bookding[AT]gmail.com>\nBoris Bochkarev\t\t<Boris-Bochkaryov[AT]yandex.ru>\nBradford Boyle\t\t<bradford.d.boyle[AT]gmail.com>\nBradley Hughes\t\t<brad[AT]bradleyehughes.com>\nBrandon Enochs\t\t<enochs.brandon[AT]gmail.com>\nBranimir Rajtar\t\t<branimir.rajtar[AT]5x9networks.com>\nBranimir Rajtar\t\t<branimir.rajtar[AT]gmail.com>\nBranislav Makan\t\t<branislav.makan1994[AT]gmail.com>\nBrendan Meath\t\t<bmeath[AT]proton.me>\nBrendan O'Connor\t<brendan[AT]leviathansecurity.com>\nBrenton Rothchild\t<brentonr[AT]dorm.org>\nBrian Jongekryg\t\t<bej[AT]arbin.net>\nBrian Sipos\t\t<brian.sipos[AT]gmail.com>\nBrian Sipos\t\t<brian.sipos[AT]jhuapl.edu>\nBrian Tracy\t\t<brian.tracy33[AT]gmail.com>\nBrian Whitney\t\t<brian.m.whitney[AT]outlook.com>\nBritt McKinley\t\t<bmckinley[AT]sonusnet.com>\nBruno Mauricio\t\t<bruno.mauricio[AT]dsr-corporation.com>\nBruno Verstuyft\t\t<bruno.verstuyft[AT]excentis.com>\nbzdula\t\t\t<bzdula[AT]bzdulnet.pl>\nC. Guerber\t\t<cguerber[AT]yahoo.com>\nCaleb Chiu\t\t<caleb.chiu[AT]macnica.com>\nCaleb Chiu\t\t<work.chiu[AT]gmail.com>\nCamille Guerin\t\t<guerincamille56[AT]gmail.com>\nCar Benjamin\t\t<Benjamin.Car[AT]elektrobit.com>\nCarl Hörberg\t\t<carl.hoerberg[AT]gmail.com>\nCarlo Carraro\t\t<colrack[AT]gmail.com>\nCarlos Pignataro\t<cpignata[AT]gmail.com>\nCarlos Velasco\t\t<carlos.velasco[AT]nimastelecom.com>\nCasper Meijn\t\t<casper[AT]meijn.net>\nCathy Yang\t\t<cathy.y.yang[AT]ericsson.com>\nCédric Delmas\t\t<cedricde[AT]outlook.fr>\nCedric Izoard\t\t<cedric.izoard[AT]ceva-dsp.com>\nCenk Gündoğan\t\t<cnkgndgn[AT]gmail.com>\nCenk Gündoğan\t\t<mail+dev[AT]gundogan.net>\ncff339\t\t\t<cff339[AT]gmail.com>\nChaitanya T K\t\t<chaitanya.mgit[AT]gmail.com>\nChaitanya Tata\t\t<Chaitanya.Tata[AT]nordicsemi.no>\nChaoyong Zhou\t\t<bgnvendor[AT]163.com>\nCharles Chan\t\t<charles[AT]zeerd.com>\nCharles Nepveu\t\t<charles.nepveu[AT]verint.com>\nCharlie Lenahan\t\t<clenahan[AT]sonicbison.com>\ncheloftus\t\t<cheloftus[AT]gmail.com>\nChema Gonzalez\t\t<chemag[AT]fb.com>\nChema Gonzalez\t\t<chemag[AT]gmail.com>\nChen Wenyi\t\t<chenwenyi20[AT]163.com>\nchiachin2686\t\t<chiachin112686[AT]gmail.com>\nChien Wong\t\t<m[AT]xv97.com>\nChloe Pelling\t\t<cpelling[AT]google.com>\nChris Bontje\t\t<chris_bontje[AT]selinc.com>\nChris Brandson\t\t<chris.brandson[AT]gmail.com>\nChris Caldwell\t\t<ccaldwell[AT]opto22.com>\nChris Dunlop\t\t<chris.dunlop3[AT]gmail.com>\nChris Wills\t\t<xenkrs[AT]outlook.com>\nChristian Ambach\t<ambi[AT]samba.org>\nChristian Fischer\t<christian.fischer[AT]greenbone.net>\nChristian Kreibich\t<christian[AT]corelight.com>\nChristian Krump\t\t<christian.krump[AT]br-automation.com>\nChristian Lamparter\t<chunkeey[AT]googlemail.com>\nChristian M. Amsüss\t<chrysn[AT]fsfe.org>\nChristian Reusch\t<creusch[AT]crnetpackets.com>\nChristian Svensson\t<blue[AT]cmd.nu>\nChristian Tellefsen\t<chris-git[AT]tellefsen.net>\nChristian Ullrich\t<chris[AT]chrullrich.net>\nChristoph Burger-Scheidlin <mail[AT]christoph.burger-scheidlin.name>\nChristoph Jähnigen\t<nuabaranda[AT]web.de>\nChristoph Portner\t<christoph.portner[AT]gmail.com>\nChristoph Schlosser\t<christoph[AT]schlosser.xyz>\nChristoph Wurm\t\t<wurm[AT]elastic.co>\nChristoph Zeller\t<zeller_chr[AT]bluewin.ch>\nChristophe Guerber\t<christophe.guerber[AT]enac.fr>\nChristophe GUERBER\t<christophe.guerber[AT]gmail.com>\nChristopher Farman\t<christopher.farman[AT]couchbase.com>\nChristopher Kilgour\t<techie[AT]whiterocker.com>\nChuan He\t\t<bupthc[AT]gmail.com>\nChuck Craft\t\t<bubbasnmp[AT]gmail.com>\nChuck Lever\t\t<chuck.lever[AT]oracle.com>\nChugzilla\t\t<chugzilla77[AT]gmail.com>\nChun-Yeow Yeoh\t\t<yeohchunyeow[AT]gmail.com>\nClaudius Zingerli\t<czingerl[AT]gmail.com>\nClément Notin\t\t<clement.notin[AT]gmail.com>\nClément Notin\t\t<clement[AT]notin.org>\nCody Doucette\t\t<doucette[AT]bu.edu>\nCody Planteen\t\t<codplant[AT]amazon.com>\nCole Wu\t\t\t<chw[AT]exegin.com>\nColin Finck\t\t<c.finck[AT]enlyze.com>\nColin Foster\t\t<colin.foster[AT]in-advantage.com>\nColin Sames\t\t<sames.colin[AT]gmail.com>\nConstantine Gavrilov\t<constg[AT]il.ibm.com>\nCraig Jackson\t\t<cejackson51[AT]gmail.com>\nCristian Sava\t\t<contact[AT]cristiansava.ro>\nD. W. Poon\t\t<dwpoon[AT]mail.ubc.ca>\nDaan De Meyer\t\t<daan.j.demeyer[AT]gmail.com>\nDaisuke Matsuda\t\t<matsuda-daisuke[AT]fujitsu.com>\nDamian Krolik\t\t<damian.krolik[AT]nordicsemi.no>\nDamir Franusic\t\t<damir.franusic[AT]gmail.com>\nDan\t\t\t<DanOfTheRoses[AT]gmail.com>\nDan Robertson\t\t<danlrobertson89[AT]gmail.com>\nDana Sy\t\t\t<dana.hayden.sy[AT]gmail.com>\nDániel Bakai\t\t<bakaidl[AT]gmail.com>\nDaniel Dulaney\t\t<dan[AT]dulaney.xyz>\nDaniel Dulaney\t\t<dulaney.daniel[AT]gmail.com>\nDaniel Estévez\t\t<daniel[AT]destevez.net>\nDaniel Hirschberger\t<daniel.hirschberger+wireshark[AT]rub.de>\nDaniel Kamil Kozar\t<dkk089[AT]gmail.com>\nDaniel Lenski\t\t<dlenski[AT]gmail.com>\nDaniel Mack\t\t<daniel[AT]zonque.org>\nDaniel McCarney\t\t<daniel[AT]binaryparadox.net>\nDaniel McLean\t\t<maczor[AT]gmail.com>\nDaniel Mouscher\t\t<dmouscher[AT]gmail.com>\nDaniel Stenberg\t\t<daniel[AT]haxx.se>\nDaniel Tan\t\t<BACdaBASpert[AT]optigo.net>\nDaniel Ulied Guevara\t<daniel.ulied[AT]i2cat.net>\nDaniël van Eeden\t<github[AT]myname.nl>\nDaniël van Eeden\t<wireshark[AT]myname.nl>\nDaniel Willmann\t\t<dwillmann[AT]sysmocom.de>\nDaniele Lacamera\t<daniele.lacamera[AT]technicolor.com>\nDanielle Church\t\t<dani.church[AT]gmail.com>\nDanny Tsai\t\t<danny.yd.tsai[AT]gmail.com>\ndarcro\t\t\t<dacroucher[AT]gmail.com>\nDarien Spencer\t\t<cusneud[AT]mail.com>\nDarius Davis\t\t<darius-wireshark[AT]free-range.com.au>\nDarshan Nevgi\t\t<darshan.sn[AT]samsung.com>\ndatabase64128\t\t<free122448[AT]hotmail.com>\nDave Barach\t\t<dave[AT]barachs.net>\nDave Goodell\t\t<dave[AT]goodell.io>\nDave Pifke\t\t<dave[AT]pifke.org>\nDave Rigby\t\t<daver[AT]couchbase.com>\nDave Tapuska\t\t<dtapuska[AT]google.com>\nDavid Aggeler\t\t<david_aggeler[AT]yahoo.com>\nDavid Ameiss\t\t<david[AT]ameissnet.com>\nDavid Arnold\t\t<d[AT]0x1.org>\nDavid Barrera\t\t<davidbb[AT]gmail.com>\nDavid Bastiani\t\t<daveb64[AT]yahoo.com>\nDavid Creswick\t\t<dcrewi[AT]gyrae.net>\nDavid Fort\t\t<contact[AT]hardening-consulting.com>\nDavid Garcia Villalba\t<656663-dagavi[AT]users.noreply.gitlab.com>\nDavid Johansen\t\t<davejohansen[AT]gmail.com>\nDavid Kreitschmann\t<dkreitschmann[AT]seemoo.tu-darmstadt.de>\nDavid Lamparter\t\t<equinox[AT]diac24.net>\nDavid McKay\t\t<mckay.david[AT]gmail.com>\nDavid Morsberger\t<dave[AT]morsberger.com>\nDavid Perry\t\t<boolean263[AT]protonmail.com>\nDavid Snowdon\t\t<daves[AT]metamako.com>\nDavid Tapuska\t\t<dave[AT]tapuska.com>\nDavid Zoller\t\t<zollerd[AT]gmail.com>\nDavide Caratti\t\t<davide.caratti[AT]gmail.com>\nDeep Datta\t\t<ddatta[AT]ixiacom.com>\nDeep Datta\t\t<deep.datta[AT]keysight.com>\nDeepthi Mary\t\t<deepthi.kalaiarasan[AT]microchip.com>\ndeepthi-tech\t\t<deepthimary7[AT]gmail.com>\ndeluxe2\t\t\t<samuel[AT]hufen.xyz>\nDenis Janssen\t\t<janssend[AT]gmail.com>\nDenis Ovsienko\t\t<denis[AT]ovsienko.info>\nDenis Pronin\t\t<dannftk[AT]yandex.ru>\nDenis Zhang\t\t<daquan.zhang[AT]perfectek.com>\nDennis Bush\t\t<bush[AT]tcnj.edu>\nDennis Lanov\t\t<dennis.lanov[AT]gmail.com>\ndennisschagt\t\t<dennisschagt[AT]gmail.com>\nDerick Rethans\t\t<github[AT]derickrethans.nl>\nDevan Lai\t\t<devanl[AT]davisinstruments.com>\nDeveloper Alexander\t<dev[AT]alex-mails.de>\nDevin Heitmueller\t<dheitmueller[AT]kernellabs.com>\nDexter Gerig\t\t<dexgerig[AT]gmail.com>\nDhananjay Patki\t\t<dhpatki[AT]cisco.com>\nDhiru Kholia\t\t<kholia[AT]kth.se>\nDiablosOffens\t\t<DiablosOffens[AT]gmx.de>\nDidier Arenzana\t\t<darenzana[AT]yahoo.fr>\nDidier Barvaux\t\t<didier.barvaux[AT]toulouse.viveris.com>\nDiederik de Groot\t<ddegroot[AT]talon.nl>\nDiego Dupin\t\t<diego.dupin[AT]mariadb.com>\nDieter Dobbelaere\t<dieter.dobbelaere[AT]excentis.com>\nDieter Dobbelaere\t<dieter.dobbelaere[AT]gmail.com>\nDirk Eibach\t\t<dirk.eibach[AT]gdsys.cc>\nDirk Römmen\t\t<dirk.roemmen[AT]cslab.de>\nDirk Weise\t\t<code[AT]dirk-weise.de>\nDirk Ziegelmeier\t<dirk[AT]ziegelmeier.net>\nDirk Ziegelmeier\t<dziegelmeier[AT]de.pepperl-fuchs.com>\nDisha Daniel\t\t<ddaniel[AT]empirix.com>\nDmitriy Eliseev\t\t<eliseev_d[AT]ntcees.ru>\nDmitry Bravikov\t\t<dmitry[AT]bravikov.pro>\nDmitry Buzdyk\t\t<dima.buzdyk[AT]gmail.com>\nDmitry Kozlyuk\t\t<dmitry.kozliuk[AT]gmail.com>\nDmitry Lazurkin\t\t<dilaz03[AT]gmail.com>\nDmitry Linikov\t\t<linikov[AT]arrival.com>\nDmitry Radivonchik\t<mitya[AT]oktetlabs.ru>\nDom Gifford\t\t<Dominic.Gifford[AT]atmel.com>\nDominic Chen\t\t<d.c.ddcc[AT]gmail.com>\nDominic Pearson\t\t<dsp[AT]technoanimal.net>\nDominik Kilian\t\t<Dominik.Kilian[AT]nordicsemi.no>\nDomonkos P. Tomcsanyi\t<domi[AT]tomcsanyi.net>\nDonatas Abraitis\t<donatas[AT]opensourcerouting.org>\nDonatas Saulys\t\t<donatas.saulys[AT]alipescapital.com>\nDongle Su\t\t<agdsdl[AT]sina.com.cn>\nĐorđije Manojlović\t<djordjije.manojlovic[AT]omicronenergy.com>\nDoug Brown\t\t<doug[AT]downtowndougbrown.com>\nDr. Lars Voelker\t<lars-github[AT]larsvoelker.de>\nDr. Lars Völker\t\t<lars.voelker[AT]bmw.de>\nDr. Lars Völker\t\t<lars.voelker[AT]technica-engineering.de>\nDr. Matthias St. Pierre\t<matthias.st.pierre[AT]ncp-e.com>\nDror Eiger\t\t<droreiger[AT]gmail.com>\nDwayne Rich\t\t<dwayne_rich[AT]selinc.com>\nDylan Ulis\t\t<daulis0[AT]gmail.com>\neason wei\t\t<sharkhw[AT]huawei.com>\nEbben Aries\t\t<exa[AT]fb.com>\neckart haug\t\t<wireshark[AT]syntacs.com>\nEclipsedSolari\t\t<6197698-EclipsedSolari[AT]users.noreply.gitlab.com>\nEd Beroset\t\t<beroset[AT]ieee.org>\nEderson de Souza\t<ederson.desouza[AT]intel.com>\nEdward Dao\t\t<edmailbox[AT]gmail.com>\nEdward Smith\t\t<edward.smith[AT]nowlegent.com>\nEdwin Groothuis\t\t<edwin[AT]mavetju.org>\nEelco Chaudron\t\t<echaudro[AT]redhat.com>\nEldon Stegall\t\t<wireshark-gerrit[AT]eldondev.com>\nElijah Conners\t\t<business[AT]elijahpepe.com>\nEliot Lear\t\t<lear[AT]cisco.com>\nElisey Shemyakin\t<shemyakin[AT]roentgenprom.ru>\nElouan\t\t\t<xse[AT]riseup.net>\nElvin Arias Soto\t<eeariass[AT]gmail.com>\nEmanuele Bovisio\t<emanuele.bovisio[AT]eolo.it>\nEmery Hemingway\t\t<emery[AT]vfemail.net>\nÉmilio Gonzalez\t\t<egg997[AT]gmail.com>\nEmmanuel Grumbach\t<emmanuel.grumbach[AT]intel.com>\nEmmanuel Pauchard\t<emmanuel.pauchard[AT]gmail.com>\nEmmanuel Touzery\t<etouzery[AT]gmail.com>\nEnrique Giraldo\t\t<enrique.giraldo[AT]wslw.es>\nEric Anderson\t\t<andersoe[AT]cs.cmu.edu>\nEric Anderson\t\t<eanderson[AT]tridium.com>\nÉric Piel\t\t<piel[AT]delmic.com>\nEric Wang\t\t<terminal_0[AT]aol.com>\nEric Wetzel\t\t<thewetzel[AT]gmail.com>\nEric Wild\t\t<ewild[AT]sysmocom.de>\nErik de Jong\t\t<erikdejong[AT]gmail.com>\nErik Ekman\t\t<eekman[AT]google.com>\nErik Sandgren\t\t<erik.sandgren[AT]nordicsemi.no>\nErika Szelleova\t\t<szelleerika[AT]gmail.com>\nErnst Oudhof\t\t<ernst[AT]mailfrom.nl>\nEthan Everett\t\t<ethan.everett[AT]meraki.net>\nEthan Young\t\t<imfargo[AT]gmail.com>\nEtienne Dechamps\t<etienne[AT]edechamps.fr>\nEtienne MARAIS\t\t<etienne[AT]marais.green>\nEtienne Millon\t\t<etienne[AT]cryptosense.com>\nEugene Adell\t\t<eugene.adell[AT]gmail.com>\nEugene Exarevsky\t<eugene.exarevsky[AT]dsr-company.com>\nEugene Sukhodolin\t<eugene[AT]sukhodolin.com>\nEvan Welsh\t\t<noreply[AT]evanwelsh.com>\nEvelio Vila\t\t<eveliovila[AT]gmail.com>\nFabian Bäumer\t\t<fabian.baeumer[AT]rub.de>\nFabian Bäumer\t\t<fabian.baeumer[AT]ruhr-uni-bochum.de>\nFabian Raetz\t\t<fabian.raetz[AT]gmail.com>\nFabian Viöl\t\t<Fabian.Vioel[AT]webfleet.com>\nFabrice Fontaine\t<fontaine.fabrice[AT]gmail.com>\nFabrizio Demaria\t<fabrizio.demaria[AT]intel.com>\nFederico Di Pierro\t<nierro92[AT]gmail.com>\nFelix Ruess\t\t<felix.ruess[AT]roboception.de>\nFerry Huberts\t\t<ferry.huberts[AT]pelagic.nl>\nFerry Huberts\t\t<mailings[AT]hupie.com>\nFilip Kågesson\t\t<exfik[AT]hms.se>\nFilip Sohajek\t\t<filip.sohajek[AT]gmail.com>\nFilip Thyssen\t\t<filip.thyssen[AT]excentis.com>\nFilipe Laíns\t\t<lains[AT]archlinux.org>\nFlavio Santes\t\t<flavio.santes[AT]1byt3.com>\nFlorian Adamsky\t\t<fa-git[AT]haktar.org>\nFlorian Bezold\t\t<florian.bezold[AT]esrlabs.com>\nFlorian Lohoff\t\t<f[AT]zz.de>\nFrancisco Javier Sánchez-Roselly <franciscojavier.sanchezroselly[AT]ujaen.es>\nFrancisco Jose Alvarez\t<francisco.alvarez[AT]galgus.net>\nFranciszek Witt\t\t<franek.witt[AT]gmail.com>\nFrancois Nguyen\t\t<francois[AT]daily-prophet.org>\nFrancois Schneider\t<francois.schneider[AT]airbus.com>\nFrancois-Xavier Le Bail\t<fx.lebail[AT]yahoo.com>\nFrancois-Xavier Seingier <francoisxavier.seingier[AT]broadpeak.tv>\nFrank Carpenter\t\t<frank.carpenter[AT]spectralink.com>\nFrank Gorgas-Waller\t<frank.gorgas-waller[AT]auerswald.de>\nFranklin Mathieu\t<franklinmathieu[AT]gmail.com>\nFrans Meulenbroeks\t<fransmeulenbroeks[AT]yahoo.com>\nFrédéric Perrin\t\t<fred[AT]fperrin.net>\nFrederik Verwaest\t<frederik.verwaest[AT]airties.com>\nFrostie314159\t\t<iam.an.programmer[AT]gmail.com>\nfrst\t\t\t<frst[AT]LT-FD3L2F3>\nGabor Spaits\t\t<Gabor.Spaits[AT]hightec-rt.com>\nGabor Spaits\t\t<gabor.spaits[AT]ericsson.com>\nGabor Spaits\t\t<gaborspaits1[AT]gmail.com>\nGabor Vaszkun\t\t<vaszkun[AT]gmail.com>\nGabriel Ganne\t\t<gabriel.ganne[AT]enea.com>\nGabriel Ganne\t\t<gabriel.ganne[AT]gmail.com>\nGael Langlais\t\t<gael.langlais[AT]protonmail.com>\nGandharav Katyal\t<gandharav4ever[AT]gmail.com>\nGanesh Nawsupe\t\t<ganesh991[AT]gmail.com>\nGarming Sam\t\t<garming[AT]catalyst.net.nz>\ngarrymar\t\t<g.djavadyan[AT]gmail.com>\nGBLCA\\amrobles\t\t<amrobles[AT]gblsys.com>\nGene Cumm\t\t<gene.cumm[AT]gmail.com>\nGennadiy Apollonov\t<andorian.rus[AT]gmail.com>\nGeoffroy Gramaize\t<geoffroy+dev[AT]gramaize.eu>\nGeorg Brandl\t\t<georg[AT]python.org>\nGeorg Richter\t\t<georg[AT]mariadb.org>\nGeorg Sauthoff\t\t<mail[AT]gms.tf>\nGeorge Hopkins\t\t<george-hopkins[AT]null.net>\nGeorge Powers\t\t<gpowers[AT]google.com>\nGerard Garcia\t\t<ggarcia[AT]deic.uab.cat>\nGergely Nagy\t\t<ngg[AT]ngg.hu>\nGerhard KHUENY\t\t<Gerhard.KHUENY[AT]bachmann.info>\nGian Lorenzo Meocci\t<gianlorenzo.meocci[AT]athonet.com>\nGianluca Borello\t<g.borello[AT]gmail.com>\nGilbert Ramirez\t\t<gilbertr[AT]gmail.com>\nGilles Dufour\t\t<dufour.gilles[AT]gmail.com>\nGiovanni Musto\t\t<giovanni.musto[AT]partner.italdesign.it>\nGisle Vanem\t\t<gvanem[AT]online.no>\nGizem Yurdagul\t\t<gizemnuryurdagul[AT]gmail.com>\nGlenden Lee\t\t<thornhillextreme[AT]gmail.com>\nGloria Pozuelo\t\t<gloria.pozuelo[AT]bics.com>\nGordon Ross\t\t<gordon.w.ross[AT]gmail.com>\nGraham Shanks\t\t<graham.shanks[AT]blueyonder.co.uk>\nGreg Morris\t\t<greg.morris[AT]microfocus.com>\nGregor Beck\t\t<gbeck[AT]sernet.de>\nGregor Jasny\t\t<gjasny[AT]googlemail.com>\nGregor Jasny\t\t<gregor.jasny[AT]logmein.com>\nGregor Miernik\t\t<gregor.miernik[AT]hytec.de>\nGregorio Maglione\t<gregorio.maglione[AT]city.ac.uk>\nGrzegorz Niemirowski\t<grzegorz[AT]grzegorz.net>\ngtker\t\t\t<github[AT]gtker.com>\nGtker\t\t\t<git[AT]gtker.com>\nGtker\t\t\t<wireshark[AT]gtker.com>\nGuillaume Autran\t<gautran[AT]clearpathrobotics.com>\nGulshan Singh\t\t<gsingh2011[AT]gmail.com>\nGünther Deschner\t<gd[AT]samba.org>\nGustavo Garcia\t\t<gustavogb[AT]gmail.com>\nGuvenc Gulce\t\t<guvenc[AT]linux.ibm.com>\nGuy Davies\t\t<aguydavies[AT]gmail.com>\nGuy Harris\t\t<gharris[AT]sonic.net>\nHackrrr\t\t\t<Hackrrr[AT]users.noreply.github.com>\nHaiyun Liu\t\t<liu0hy[AT]gmail.com>\nHal Rosenstock\t\t<hal.rosenstock[AT]gmail.com>\nHannes Reinecke\t\t<hare[AT]suse.de>\nHans Hinrichsen\t\t<hinrichsen.hans[AT]gmail.com>\nHanspeter Portner\t<dev[AT]open-music-kontrollers.ch>\nHarald Welte\t\t<laforge[AT]osmocom.org>\nHassan Sultan\t\t<sultah[AT]amazon.com>\nHauke Mehrtens\t\t<hauke.mehrtens[AT]intel.com>\nHeikki Linnakangas\t<heikki.linnakangas[AT]iki.fi>\nheinrich5991\t\t<heinrich5991[AT]gmail.com>\nHelmut Buchsbaum\t<helmut.buchsbaum[AT]gmail.com>\nHenri Chataing\t\t<henrichataing[AT]google.com>\nHerwin Weststrate\t<herwin[AT]quarantainenet.nl>\nHessam Jalali\t\t<hessam.jalali[AT]gmail.com>\nhidd3ncod3s Sec\t\t<hidd3ncod3s[AT]gmail.com>\nHideaki HAYASHI\t\t<hide.zebra[AT]gmail.com>\nHiroaki KAWAI\t\t<hiroaki.kawai[AT]gmail.com>\nHiroshi Ioka\t\t<hirochachacha[AT]gmail.com>\nHitoshi Irino\t\t<irino[AT]sfc.wide.ad.jp>\nHolger Hans Peter Freyther <holger[AT]moiji-mobile.com>\nHolger Jeromin\t\t<mailgithub[AT]katur.de>\nHOMEPC\\eaosk\t\t<ea.oskolkov[AT]yandex.ru>\nHuang Hao\t\t<hao.1.huang[AT]nokia-sbell.com>\nhutcheb\t\t\t<ben.hutche[AT]gmail.com>\nIain R. Learmonth\t<irl[AT]fsfe.org>\nIan Chard\t\t<ian[AT]chard.org>\nIdo Schimmel\t\t<idosch[AT]mellanox.com>\nIgnacio Martínez\t<ignacio.martinez.rivera[AT]gmail.com>\nIgnacy Gawędzki\t\t<ignacy.gawedzki[AT]green-communications.fr>\nIgor Dmitriev\t\t<igor.dmitriev[AT]eke.fi>\nIgor Passchier\t\t<igor.passchier[AT]tassinternational.com>\nIke Gilbert\t\t<ike[AT]imgilbert.com>\nIlya Gavrilov\t\t<ilya.dev[AT]gmail.com>\nIlya Kulakov\t\t<kulakov.ilya[AT]gmail.com>\nIndraneel Guha\t\t<indraneelg[AT]gmail.com>\ninfostam\t\t<github[AT]infostam.com>\nIntegral\t\t<integral[AT]member.fsf.org>\nIonut Ceausu\t\t<ionut.ceausu[AT]gmail.com>\nIsaac Boukris\t\t<iboukris[AT]gmail.com>\nIshaan Gandhi\t\t<ishaangandhi[AT]gmail.com>\nIsmael Mendez Matamoros\t<ismael[AT]rti.com>\nIsmael Pérez\t\t<ismael.perez[AT]omicronenergy.com>\nIvan Ermakov\t\t<iermakov[AT]yahoo.com>\nIvan Nardi\t\t<nardi.ivan[AT]gmail.com>\nIvan Quach\t\t<ivan.quach[AT]aireon.com>\nIvan Secerin\t\t<ivan.severin.m[AT]gmail.com>\nIvan Stanoev\t\t<istanoev[AT]hotmail.com>\nIvan Tan\t\t<ivantan1524[AT]gmail.com>\nIvan Ugryumov\t\t<smille2003[AT]yandex.ru>\nIWASE Yusuke\t\t<iwase.yusuke0[AT]gmail.com>\nJ M\t\t\t<jm.commercial[AT]posteo.de>\nJ. Bruce Fields\t\t<bfields[AT]redhat.com>\nJack Culhane\t\t<jackculhane[AT]gmail.com>\nJack Kaplan\t\t<efraimkaplan7[AT]gmail.com>\nJacob Lodge\t\t<jacob.lodge.at.bda[AT]gmail.com>\nJaime Caamaño Ruiz\t<jcaamano[AT]suse.com>\nJakub Adam\t\t<jakub.adam[AT]collabora.com>\nJakub Jirutka\t\t<jakub[AT]jirutka.cz>\nJakub Pawlowski\t\t<jpawlowski[AT]google.com>\nJakub Rotkiewicz\t<jakub.rotkiewicz[AT]codecoup.pl>\nJakub Rotkiewicz\t<rotkiewicz[AT]google.com>\nJambukumar Kulandaivel\t<jambukumar[AT]codeaurora.org>\nJames Coleman\t\t<jamesc[AT]dspsrv.com>\nJames Ko\t\t<jck[AT]exegin.com>\nJames Ring\t\t<sjr[AT]jdns.org>\nJamie Hare\t\t<jamie.n.hare[AT]gmail.com>\nJamil Nimeh\t\t<jnimeh[AT]gmail.com>\nJan Fuchs\t\t<jf[AT]simonwunderlich.de>\nJan Holthuis\t\t<jan.holthuis[AT]ruhr-uni-bochum.de>\nJan Kaisrlik\t\t<j.kaisrlik[AT]seznam.cz>\nJan Romann\t\t<jan.romann[AT]gmail.com>\nJan Romann\t\t<jan.romann[AT]uni-bremen.de>\nJan Seda\t\t<hodor[AT]hodor.cz>\nJan Snydr-Michal\t<jan[AT]dogsontheroof.de>\nJan Spevak\t\t<jan.spevak[AT]nokia.com>\nJan Wiesemann\t\t<kontakt[AT]janwiesemann.de>\nJan-Hendrik Bolte\t<jabolte[AT]uos.de>\nJann Horn\t\t<jannh[AT]google.com>\nJano Svitok\t\t<jsv[AT]whitestein.com>\nJared Rittle\t\t<jrittle[AT]cisco.com>\nJarrad Raumati\t\t<jarrad.raumati[AT]gmail.com>\nJason Cohen\t\t<7011141-kryojenik[AT]users.noreply.gitlab.com>\nJason Cohen\t\t<j.cohen[AT]f5.com>\nJason Cohen\t\t<kryojenik2[AT]gmail.com>\nJason Heimann\t\t<jheimann[AT]pertino.com>\nJason Tang\t\t<10972498-jtang613[AT]users.noreply.gitlab.com>\nJason Uher\t\t<jason.uher[AT]jhuapl.edu>\nJason Zhekov\t\t<jasssonpet[AT]gmail.com>\nJavier Cardona\t\t<jcardona[AT]fb.com>\nJC Wren\t\t\t<jcwren[AT]jcwren.com>\nJean Thomas\t\t<jeanthomas[AT]sierrawireless.com>\nJean Yap\t\t<jean.yap[AT]team.telstra.com>\nJean-Philippe Lebel\t<jp[AT]lebel.pro>\nJean-Philippe Lebel\t<jpl[AT]ds.tools>\nJeff Dyer\t\t<jmasterfunk[AT]gmail.com>\nJeff Layton\t\t<jlayton[AT]kernel.org>\nJeff Layton\t\t<jlayton[AT]redhat.com>\nJeff Oconnell\t\t<jeffo[AT]rulez.com>\nJeff Widman\t\t<jeff[AT]jeffwidman.com>\nJeffrey Forhan\t\t<jforhan[AT]cisco.com>\nJeffrey Goff\t\t<jgoff[AT]arubanetworks.com>\nJeffrey Goff\t\t<jgoff[AT]hpe.com>\nJeffrey Smith\t\t<whydoubt[AT]gmail.com>\nJens Kilian\t\t<jens.kilian[AT]advantest.com>\nJeremiejig\t\t<me[AT]jeremiejig.fr>\nJeremy Browne\t\t<jer[AT]ifni.ca>\nJeremy Hitt\t\t<jeremy.hitt[AT]isilon.com>\nJeremy Kerr\t\t<jk[AT]codeconstruct.com.au>\nJeremy Kerr\t\t<jk[AT]ozlabs.org>\nJeremy Martin\t\t<boardermartin[AT]gmail.com>\nJeremy McCormick\t<jjmccormick[AT]protonmail.com>\nJeroen Roovers\t\t<jer[AT]gentoo.org>\nJeroen Sack\t\t<jeroen.sack[AT]agcocorp.com>\nJeroen Sack\t\t<jeroen[AT]jeroensack.nl>\nJérôme HAMM\t\t<jerome.hamm[AT]planete-sciences.org>\nJérôme LAFORGE\t\t<jerome.laforge[AT]gmail.com>\nJérôme Pouiller\t\t<jerome.pouiller[AT]silabs.com>\nJesse Gross\t\t<jesse[AT]kernel.org>\njfp_martin\t\t<john[AT]purplemeanie.co.uk>\nJiajun Wang\t\t<me[AT]jiajunw.com>\nJianwei Mao\t\t<maojianwei2012[AT]126.com>\nJie Han\t\t\t<jie.han[AT]samsung.com>\nJim Borden\t\t<jim.borden[AT]couchbase.com>\nJim Schaettle\t\t<jimschaettle[AT]gmail.com>\nJim Walker\t\t<jim[AT]couchbase.com>\nJim Young\t\t<jim.young.ws[AT]gmail.com>\nJim Young\t\t<jyoung[AT]gsu.edu>\nJiří Engelthaler\t<Jiri.Engelthaler[AT]zat.cz>\nJiri Pirko\t\t<jiri[AT]resnulli.us>\nJo Rueschel\t\t<wireshark[AT]rueschel.de>\nJo-Philipp Wich\t\t<jo[AT]mein.io>\nJoakim Andersson\t<joakim.andersson[AT]nordicsemi.no>\nJoakim Andersson\t<joerchan[AT]gmail.com>\nJoakim Karlsson\t\t<oakimk[AT]gmail.com>\nJoakim Karlsson A\t<joakim.a.karlsson[AT]ericsson.com>\nJoakim Wiberg\t\t<jow[AT]hms.se>\nJoel Colledge\t\t<joel.colledge[AT]linbit.com>\nJoel Helling\t\t<jhelling[AT]gblsys.com>\nJoeri de Ruiter\t\t<joeri[AT]cypherpunk.nl>\nJoey Salazar\t\t<jgsal[AT]protonmail.com>\nJohan Wahl\t\t<johan.wahl[AT]ericsson.com>\nJohannes Altmanninger\t<aclopte[AT]gmail.com>\nJohannes Löthberg\t<johannes[AT]kyriasis.com>\nJohannes Singler\t<johannes[AT]singler.name>\nJohn A. Thacker\t\t<johnthacker[AT]gmail.com>\nJohn Bankier\t\t<opensource.jbankier[AT]gmail.com>\nJohn E. Schimmel\t<jes[AT]arista.com>\nJohn Keeping\t\t<john[AT]metanate.com>\nJohn Miner\t\t<optommp[AT]gmail.com>\nJohn Moon\t\t<john.moon[AT]vts-i.com>\nJohn Serock\t\t<serock-wireshark-dev[AT]outlook.com>\nJohn Tapparo\t\t<j.tapparo[AT]f5.com>\nJohn Viklund\t\t<john.viklund[AT]effnet.com>\nJohnathan Raymond\t<johnathan.raymond[AT]cpacketnetworks.com>\nJohnathan Raymond\t<johnathan.raymond[AT]knightswhosaynil.com>\nJon\t\t\t<jon[AT]jon-ryzen>\nJon Dennis\t\t<j.dennis[AT]cablelabs.com>\nJon DeVree\t\t<nuxi[AT]vault24.org>\nJonas Blust\t\t<jonas.blust[AT]rohde-schwarz.com>\nJonas Falkevik\t\t<jonas.falkevik[AT]gmail.com>\nJonas Jonsson\t\t<jonas[AT]ludd.ltu.se>\nJonas Wamsler\t\t<jonas.wamsler[AT]usd.de>\nJonathan Brucker\t<jonathan.brucke[AT]gmail.com>\nJonathan Fleming\t<jonathan[AT]optigo.net>\nJonathan Landis\t\t<jkl[AT]calibersecurity.com>\nJonathan Lennox\t\t<jonathan.lennox[AT]8x8.com>\nJonathan Muñoz\t\t<jonathan.munoz[AT]inria.fr>\nJonathan Nieder\t\t<jrnieder[AT]gmail.com>\nJones Syue\t\t<jonessyue[AT]qnap.com>\nJordan Keister\t\t<grokspawn[AT]gmail.com>\nJörg Mayer\t\t<jmghc[AT]loplof.de>\nJorge Mora\t\t<jmora1300[AT]gmail.com>\nJorge Power\t\t<jpower[AT]rsscorp.org>\nJoris Peeraer\t\t<joris.peeraer[AT]nokia.com>\nJose Rubio\t\t<joserubiovidales[AT]gmail.com>\nJosef Baumgartner\t<josef.baumgartner[AT]br-automation.com>\nJoseph Huffman\t\t<jhuffman[AT]codeaurora.org>\nJosh Schmelzle\t\t<13954434+joshschmelzle[AT]users.noreply.github.com>\nJosh Schmelzle\t\t<josh[AT]joshschmelzle.com>\nJosh Strohminger\t<18415319-joshstrohminger[AT]users.noreply.gitlab.com>\nJosip Medved\t\t<jmedved[AT]jmedved.com>\nJosselin VALLET\t\t<josselin.vallet[AT]toulouse.viveris.com>\nJourney Spratt\t\t<jspratt217[AT]gmail.com>\nJuan Jose Martin Carrascosa <juanjo[AT]rti.com>\nJuan Matias\t\t<jmrepetti[AT]gmail.com>\nJuan Pablo Mendoza\t<jpablo[AT]gmail.com>\nJuanma Sanchez\t\t<juasanch[AT]redhat.com>\nJuergen Kosel\t\t<juergen.kosel[AT]gmx.de>\nJuha Kuikka\t\t<kuikka[AT]fb.com>\nJuha Takala\t\t<juha.takala+rauta[AT]iki.fi>\nJuhani Puurula\t\t<juhani.puurula[AT]arm.com>\nJulian Cable\t\t<julian.cable[AT]yahoo.com>\nJulian Renz\t\t<julian[AT]renz.cloud>\nJun Wang\t\t<sdn_app[AT]163.com>\nJunpei Yoshino\t\t<junpei.yoshino[AT]gmail.com>\nJustin\t\t\t<fakesteakjustincase[AT]gmail.com>\nJustin Dailey\t\t<justin[AT]mti-systems.com>\nJustin Helgesen\t\t<justinhelgesen[AT]gmail.com>\nJustin Iurman\t\t<justin.iurman[AT]uliege.be>\nJustin J. Novack\t<jnovack[AT]gmail.com>\nJustinKu\t\t<jiunrong[AT]gmail.com>\nKa-Shu Wong\t\t<kswong[AT]exablaze.com>\nKaige Ye\t\t<ye[AT]kaige.org>\nkardam\t\t\t<netkardam[AT]gmail.com>\nKarl Knoebl\t\t<karl.knoebl[AT]technikum-wien.at>\nKarsten Graul\t\t<kgraul[AT]linux.ibm.com>\nKary Rogers\t\t<kary.rogers[AT]gmail.com>\nKas-tle\t\t\t<joshdcastle[AT]gmail.com>\nKasper Deng\t\t<kasper.deng[AT]ericsson.com>\nKeith Scott\t\t<keithlscott[AT]gmail.com>\nKen Aaker\t\t<kenaaker[AT]gmail.com>\nKenneth Soerensen\t<knnthsrnsn[AT]gmail.com>\nkenneth topp\t\t<toppk[AT]bllue.org>\nKenny Root\t\t<kenny[AT]the-b.org>\nKenrick Trip\t\t<kenrick.trip[AT]hotmail.com>\nKevin A. Noll\t\t<kevinanoll[AT]gmail.com>\nKevin Albertson\t\t<kevin.eric.albertson[AT]gmail.com>\nKevin Bracey\t\t<kevin.bracey[AT]arm.com>\nKevin Cernekee\t\t<cernekee[AT]chromium.org>\nKevin Grigorenko\t<kevin.grigorenko[AT]us.ibm.com>\nKevin Hausman\t\t<kevin.hausman[AT]sentaca.com>\nKevin Herron\t\t<kevinherron[AT]gmail.com>\nKevin Hogan\t\t<kwabena[AT]google.com>\nKevin Schoonover\t<gitlab[AT]kschoon.me>\nKhalifa NDIAYE\t\t<khalifa.ndiaye[AT]orange.com>\nKim Bäckström\t\t<kim.backstrom[AT]gmail.com>\nKirill Chernyshov\t<nideff.ru[AT]gmail.com>\nKirill Smorodinnikov\t<shaitkir[AT]gmail.com>\nkirstenv\t\t<kirsten[AT]persistent-telecom.net>\nkkoizumi\t\t<kkoizumi46[AT]gmail.com>\nkoenig-arthur\t\t<koenig-arthur[AT]gmx.ch>\nKonrad Wolsing\t\t<wolsing[AT]comsys.rwth-aachen.de>\nKripa Varma\t\t<krvarma[AT]cisco.com>\nKrunal Soni\t\t<krunaldsoni[AT]gmail.com>\nKrzysztof Opasiak\t<k.opasiak[AT]samsung.com>\nKyoungho An\t\t<kyoungho[AT]rti.com>\nLajos Olah\t\t<lajos.olah.jr[AT]gmail.com>\nLars Christensen\t<larsch[AT]belunktum.dk>\nLars Sundström\t\t<lars.x.sundstrom[AT]ericsson.com>\nLasse Luttermann Poulsen <lasse.luttermann[AT]gmail.com>\nLaszlo Papp\t\t<laszlo.papp[AT]hubersuhner.com>\nLaurent Fasnacht\t<laurent.fasnacht[AT]proton.ch>\nLaurenz Kamp\t\t<laurenz.kamp[AT]gmx.de>\nLee Mitchell\t\t<lee[AT]indigopepper.com>\nLee Serin\t\t<serinee95[AT]gmail.com>\nlemur117\t\t<lemur117[AT]protonmail.com>\nLéo Gaspard\t\t<leo[AT]gaspard.io>\nLeonard Penzer\t\t<leonard.penzer[AT]rohde-schwarz.com>\nLev Stipakov\t\t<lstipakov[AT]gmail.com>\nLewis Hamilton\t\t<lewish[AT]arista.com>\nLi Zhengqiang\t\t<lizhengqiang[AT]anban.tech>\nLiam Kearney\t\t<liam.kearney[AT]morsemicro.com>\nliam-black\t\t<liam.black[AT]enea.com>\nLiangYuxuan\t\t<lyx[AT]lyx.es>\nLichen Liu\t\t<llc123456a[AT]gmail.com>\nLin Alan\t\t<linalan[AT]gmail.com>\nLin Sun\t\t\t<lin.sun[AT]zoom.us>\nLin Sun\t\t\t<sunlin7[AT]yahoo.com>\nlindnerp\t\t<lindnerp[AT]ohio.edu>\nLingao Meng\t\t<menglingao[AT]xiaomi.com>\nliningjie\t\t<1350445139[AT]qq.com>\nLoganaden Velvindron\t<logan[AT]cyberstorm.mu>\nLoganaden Velvindron\t<loganaden[AT]gmail.com>\nLorenzo Vannucci\t<vannucci[AT]ntop.org>\nLoris Degioanni\t\t<ld[AT]degio.org>\nLoris Degioanni\t\t<loris[AT]sysdig.com>\nLotte Steenbrink\t<lotte[AT]zombietetris.de>\nLouis Scalbert\t\t<louis.scalbert[AT]6wind.com>\nLuca Melette\t\t<luca[AT]srlabs.de>\nLucas Drufva\t\t<lucas.drufva[AT]gmail.com>\nLucas Pardue\t\t<lucaspardue.24.7[AT]gmail.com>\nLucas Simopoulos\t<lsimopoulos[AT]gmail.com>\nLuckinger Florian\t<Florian.Luckinger[AT]elektrobit.com>\nLudovic Cintrat\t\t<l.cintrat[AT]traxens.com>\nLudovic Rousseau\t<ludovic.rousseau[AT]free.fr>\nLuis Colmenero\t\t<colmenero.sendra[AT]gmail.com>\nLuis Colmenero\t\t<colmenero[AT]rti.com>\nLuis Rosa\t\t<lmrosa[AT]dei.uc.pt>\nLukas Emersberger\t<lukas.emersberger[AT]gmail.com>\nLukas Stermann\t\t<lukas.stermann[AT]googlemail.com>\nLuke Chou\t\t<luke.chou[AT]gmail.com>\nLuke Lynch\t\t<llynch2017[AT]my.fit.edu>\nLuke Mewburn\t\t<luke[AT]mewburn.net>\nlutianxiong\t\t<lutianxiong[AT]huawei.com>\nLutz Kresge\t\t<LutzKr[AT]protonmail.ch>\nm.kaldenbach\t\t<m.kaldenbach[AT]wearetriple.com>\nMaarten Bezemer\t\t<maarten.bezemer[AT]gmail.com>\nMagnus Henoch\t\t<magnus.henoch[AT]gmail.com>\nMaka0\t\t\t<Maka0[AT]yurei.net>\nMakoto Shimamura\t<makoto.shimamura[AT]toshiba.co.jp>\nMaksim Salau\t\t<maksim.salau[AT]gmail.com>\nMalcolm Walters\t\t<malcolm.walters[AT]acano.com>\nMališa Vučinić\t\t<malishav[AT]gmail.com>\nManasa S\t\t<msrinivas[AT]extremenetworks.com>\nManawyrm\t\t<git[AT]tbspace.de>\nManfred\t\t\t<mx2927[AT]gmail.com>\nMarc Bevand\t\t<mbevand[AT]google.com>\nMarc Fournier\t\t<marc.fournier[AT]camptocamp.com>\nMarcel Essig\t\t<marcel.essig[AT]gmx.de>\nMarcelo Ricardo Leitner\t<marcelo.leitner[AT]gmail.com>\nMarcin Rokicki\t\t<marcin.rokicki[AT]gmail.com>\nMarco Hünseler\t\t<marco.huenseler[AT]h-brs.de>\nMarco Oliverio\t\t<marco[AT]wolfssl.com>\nMarcoKaldenbach\t\t<marcokaldenbach[AT]gmail.com>\nMarcus Sundberg\t\t<marcus.sundberg[AT]aptilo.com>\nMarian Ďurkovič\t\t<md[AT]bts.sk>\nMarie Janssen\t\t<jamuraa[AT]google.com>\nMarios Makassikis\t<mmakassikis[AT]gmail.com>\nMarius David\t\t<marius.david[AT]keysight.com>\nMarius Paliga\t\t<marius.paliga[AT]gmail.com>\nMarius Preuten\t\t<marius.preuten[AT]lancom.de>\nMariusz Zaborski\t<oshogbo[AT]vexillium.org>\nMark Ciechanowski\t<markciechanowski[AT]gmail.com>\nMark Cunningham\t\t<launchpad[AT]markcunningham.ie>\nMark Phillips\t\t<mark.s.phillips[AT]outlook.com>\nMark Stemm\t\t<mark.stemm[AT]gmail.com>\nMark Weel\t\t<markweel[AT]hotmail.com>\nMarkku Leiniö\t\t<markku[AT]iki.fi>\nMarko Hrastovec\t\t<marko.hrastovec[AT]gmail.com>\nMarkus Becker\t\t<markus.becker[AT]tridonic.com>\nmarmonier_c\t\t<cmarmonier[AT]ifotec.com>\nMarouen Ghodhbane\t<marouen.ghodhbane[AT]nxp.com>\nMartin\t\t\t<martin.lutz[AT]gmail.com>\nMartin Boye Petersen\t<martinboyepetersen[AT]gmail.com>\nMartin Boye Petersen\t<martinboyepetersen[AT]hotmail.com>\nMartin Fesser\t\t<martin.fesser[AT]allegro-packets.com>\nMartin Gallo\t\t<martin.gallo[AT]gmail.com>\nMartin Gallo\t\t<mgallo[AT]secureauth.com>\nMartin Greenberg\t<mgreenberg[AT]cpacket.com>\nMartin Haaß\t\t<vvvrrooomm[AT]gmail.com>\nMartin Heusse\t\t<martin.heusse[AT]imag.fr>\nMartin Lutz\t\t<martin.lutz+github[AT]gmail.com>\nMartin Mathieson\t<martin.mathieson[AT]keysight.com>\nMartin Mathieson\t<martin.r.mathieson[AT]gmail.com>\nMartin Nyhus\t\t<gitlab[AT]nyhus.dev>\nMartin Nyhus\t\t<martin.nyhus[AT]gmx.com>\nMartin Nyhus\t\t<martin[AT]nyhus.dev>\nMartin Sehnoutka\t<msehnout[AT]redhat.com>\nMartin Sirokov\t\t<martin.sirokov[AT]wayren.ee>\nMartin Stigge\t\t<martin[AT]stigge.org>\nMartin Stigge\t\t<mstigge[AT]arista.com>\nMartin Tibenský\t\t<martin.tibensky[AT]alcatel-lucent.com>\nMartin Tschoepe\t\t<martin.tschoepe[AT]web.de>\nMartin Vit\t\t<martin[AT]voipmonitor.org>\nMasaru Tsuchiyama\t<m.tmatma[AT]gmail.com>\nMasashi Honma\t\t<masashi.honma[AT]gmail.com>\nMatan Perelman\t\t<matan1008[AT]gmail.com>\nMatej Košík\t\t<5764c029b688c1c0d24a2e97cd764f[AT]gmail.com>\nMatej Tkac\t\t<matej.tkac.mt[AT]gmail.com>\nMatheus Eduardo Garbelini <mgarbelix[AT]gmail.com>\nMatheus K. Ferst\t<matheus.ferst[AT]gmail.com>\nMathias Kurth\t\t<mathias.kurth[AT]commsolid.com>\nMathis Marion\t\t<mathis.marion[AT]silabs.com>\nMathis MARION\t\t<mathis.marion1[AT]gmail.com>\nMathy Vanhoef\t\t<Mathy.Vanhoef[AT]nyu.edu>\nMatias Karhumaa\t\t<matias.karhumaa[AT]gmail.com>\nMatt Carabine\t\t<matt.carabine[AT]hotmail.co.uk>\nMatt Claiborne\t\t<matt.claiborne[AT]hpe.com>\nMatt Lawrence\t\t<bugzilla.wireshark[AT]erisa.co.uk>\nMatt Parker\t\t<matt.parker[AT]poly.com>\nMatt Porter\t\t<mporter[AT]konsulko.com>\nMatthew Weant\t\t<msweant[AT]gmail.com>\nMatthias Brendel\t<mcbrendel[AT]gmx.de>\nMatthias Dietrich\t<matthias.dietrich[AT]gmx.fr>\nMatthias Isele\t\t<matthias.isele[AT]gmx.net>\nMatthias Lang\t\t<matthias[AT]corelatus.com>\nMatthias Ringwald\t<matthias[AT]ringwald.ch>\nMatthieu Coudron\t<matthieu.coudron[AT]lip6.fr>\nMaurice Lam\t\t<me[AT]mauricelam.com>\nMauro Levra\t\t<mauro.levra[AT]viavisolutions.com>\nMauro Levra\t\t<mauro[AT]nazardo.it>\nMax Dmitrichenko\t<dmitrmax[AT]gmail.com>\nMax Schrötter\t\t<mail[AT]schrc3b6.de>\nMaxence Younsi\t\t<mx.yns[AT]outlook.fr>\nMaxim Kolesnikov\t<indev.src[AT]gmail.com>\nMaxim Kropp\t\t<maxim.kropp[AT]hotmail.de>\nMaxim Sharabayko\t<maxim.sharabayko[AT]gmail.com>\nMaxim Sharabayko\t<maxlovic[AT]gmail.com>\nMaxime Goffart\t\t<maxime.goffart[AT]uliege.be>\nMaxime Meignan\t\t<meignanmaxime[AT]hotmail.fr>\nMaximilian Kohler\t<maximilian.kohler[AT]viavisolutions.com>\nmbutkereit\t\t<marvin.butkereit[AT]haw-hamburg.de>\nMehmet Oguz Sakaoglu\t<mehmet.oguz.mnz[AT]gmail.com>\nMerlin Chlosta\t\t<merlin.chlosta+gnuradio[AT]ruhr-uni-bochum.de>\nmGhony99\t\t<mGhony99[AT]gmail.com>\nMicha Reiser\t\t<michafamreiser.ch>\nMichael Adam\t\t<obnox[AT]samba.org>\nMichaël Bouchaud\t<michael.bouchaud[AT]external.thalesaleniaspace.com>\nMichaël Bouchaud\t<michael.bouchaud[AT]gmail.com>\nMichael Bouchaud (yoz)\t<michael.bouchaud[AT]toulouse.viveris.com>\nMichael Canning\t\t<michael.canning[AT]biamp.com>\nMichael Cistera\t\t<michael.cistera[AT]netscout.com>\nMichael Honsel\t\t<lesnoh[AT]gmx.de>\nMichael Mann\t\t<Michael.Mann[AT]jbtc.com>\nMichael McConville\t<mmcco[AT]mykolab.com>\nMichael McTernan\t<mike.mcternan[AT]wavemobile.com>\nMichael Metzinger\t<michael.metzinger[AT]solace.com>\nMichael Oed\t\t<michael.oed[AT]gmail.com>\nMichael Penick\t\t<penick[AT]gmail.com>\nMichael Pergament\t<mpergament[AT]gmail.com>\nMichael Pergament\t<mpergament[AT]googlemail.com>\nMichael Schmitt\t\t<mschmitt[AT]fastmail.net>\nMichael Sweet\t\t<michael.r.sweet[AT]gmail.com>\nMichael Vigovsky\t<upliner[AT]gmail.com>\nMichail Koreshkov\t<drkor[AT]bk.ru>\nMichail Koreshkov\t<michail.koreshkov[AT]mail.ru>\nMichał Kaźmierowski\t<michal.kazmierowski[AT]q-free.com>\nMichał Kępień\t\t<michal[AT]isc.org>\nMichal Kubecek\t\t<mkubecek[AT]suse.cz>\nMichal Pazdera\t\t<michal.pazdera[AT]gmail.com>\nMichal Prívozník\t<mprivozn[AT]redhat.com>\nMichal Ruprich\t\t<michalruprich[AT]gmail.com>\nMichal Ruprich\t\t<mruprich[AT]redhat.com>\nMichał Skalski\t\t<mskalski13[AT]gmail.com>\nMichal Slavka\t\t<slavka.michal[AT]gmail.com>\nMichalis Kapsalakis\t<kapsalis1989[AT]gmail.com>\nMichele Baldessari\t<michele[AT]acksyn.org>\nMichele Mazzante\t<mazzante[AT]gmail.com>\nMiguel Company\t\t<MiguelCompany[AT]eprosima.com>\nMihai Codrean\t\t<mihaicodrean[AT]gmail.com>\nMikael Kanstrup\t\t<mikaeka[AT]axis.com>\nMikael Kanstrup\t\t<mikael.kanstrup[AT]axis.com>\nMikael Kanstrup\t\t<mikael.kanstrup[AT]gmail.com>\nMike Beaumont\t\t<mjboamail[AT]gmail.com>\nMike Frysinger\t\t<vapier[AT]chromium.org>\nMike Gerschefske\t<msgersch2[AT]gmail.com>\nMike Lugo\t\t<mlugo.apx[AT]gmail.com>\nMike Morrin\t\t<morrinmike[AT]gmail.com>\nMike Ryan\t\t<mikeryan[AT]lacklustre.net>\nMikhail Gusarov\t\t<dottedmag[AT]dottedmag.net>\nMikhail Karpenko\t<karpenko[AT]fastmail.com>\nMiklos Marton\t\t<martonmiklosqdev[AT]gmail.com>\nMikołaj Małecki\t\t<mmalecki[AT]haivision.com>\nMilan Justel\t\t<milancjustel[AT]gmail.com>\nMilan Stute\t\t<mstute[AT]seemoo.tu-darmstadt.de>\nMilos Jovanovic\t\t<jeyem815[AT]gmail.com>\nMiltos Patsiouras\t<mipatsio[AT]gmail.com>\nMin Wang\t\t<wang[AT]mins.app>\nMing Chen\t\t<mingc2099[AT]gmail.com>\nMinh Phan\t\t<phanducnhatminh[AT]gmail.com>\nMirko Parthey\t\t<mirko.parthey[AT]web.de>\nmirkodeckert\t\t<mirko.deckert[AT]adtran.com>\nMiroslav Lichvar\t<mlichvar[AT]redhat.com>\nmistral13\t\t<mistral[AT]gmx.ch>\nmivens\t\t\t<mark.ivens[AT]vitrifi.net>\nmkg20001\t\t<mkg20001[AT]gmail.com>\nMokhtar Ben Messaoud\t<mokhtar.ben-messaoud[AT]sagemcom.com>\nMoraney Jalil\t\t<moraney.jalil[AT]outlook.com>\nMorten Tryfoss\t\t<morten[AT]tryfoss.no>\nMoshe Kaplan\t\t<me[AT]moshekaplan.com>\nMoshe Kaplan\t\t<mosheekaplan[AT]gmail.com>\nmStiglec\t\t<sticgoc[AT]gmail.com>\nmverkleij\t\t<mail[AT]mverkleij.nl>\nnaesten\t\t\t<naesten[AT]gmail.com>\nnaf\t\t\t<naf[AT]sdf.org>\nNan Xiao\t\t<nan[AT]chinadtrace.org>\nNatale Patriciello\t<natale.patriciello[AT]gmail.com>\nNathalie Romo\t\t<nathalie.romo-moreno[AT]telekom.de>\nNathan Cole\t\t<nath[AT]thecoleresidence.co.uk>\nNathan Houghton\t\t<nathan[AT]brainwerk.org>\nNathaniel Clark\t\t<Nathaniel.Clark[AT]misrule.us>\nNathaniel Clark\t\t<nathaniel.l.clark[AT]intel.com>\nNeels Hofmeyr\t\t<neels[AT]hofmeyr.de>\nNeil Ostroff\t\t<neil[AT]mangosoup.com>\nNiall Dugera\t\t<niall.dugera[AT]anam.com>\nNick Bedbury\t\t<npbedbur[AT]syr.edu>\nNick Calus\t\t<ncalus[AT]nalys-group.com>\nNick Carter\t\t<ncarter100[AT]gmail.com>\nNick James\t\t<mookito[AT]tuta.io>\nNick Lowe\t\t<nick.lowe[AT]gmail.com>\nnickvsnetworking\t<nick[AT]nickvsnetworking.com>\nNico\t\t\t<n.camil[AT]free.fr>\nNicolás Alvarez\t\t<nicolas.alvarez[AT]gmail.com>\nNicolas Bertin\t\t<nicolas.bertin[AT]al-enterprise.com>\nNicolas Cavallari\t<nicolas.cavallari[AT]green-communications.fr>\nNicolas Darchis\t\t<ndarchis[AT]cisco.com>\nNicolas Fella\t\t<nicolas.fella[AT]gmx.de>\nNicolas Josef Zunker\t<n.zunker[AT]campus.tu-berlin.de>\nNicolas S. Dade\t\t<nic.dade[AT]gmail.com>\nNicolas Zunker\t\t<nic.da.zunk[AT]gmail.com>\nNikhil Acharya Prakash\t<nikhilap[AT]arista.com>\nNikita Ryaskin\t\t<nikita.ryaskin[AT]dsr-corporation.com>\nNikolai Ipatyev\t\t<wallprime[AT]yandex.com>\nNikolas Koesling\t<nikolas[AT]koesling.info>\nNikolay Kovtun\t\t<nikolay.kovtun[AT]dsr-corporation.com>\nNils Björklund\t\t<nils.bjorklund[AT]effnet.com>\nNils Hanke\t\t<nils.hanke[AT]outlook.de>\nNils Ohlmeier\t\t<github[AT]ohlmeier.org>\nNitzan Carmi\t\t<nitzanc[AT]mellanox.com>\nNoan\t\t\t<noan.perrot[AT]gmail.com>\nNoan Perrot\t\t<noan.perrot[AT]apizee.com>\nNoel Power\t\t<noel.power[AT]suse.com>\nNora Sandler\t\t<nsandler[AT]securityinnovation.com>\nOdysseus Yang\t\t<wiresharkyyh[AT]outlook.com>\nOkan Palaz\t\t<okan.palaz[AT]airties.com>\nOke Hargens\t\t<oke.hargens[AT]cetitec.com>\nOlaf Bergmann\t\t<bergmann[AT]tzi.org>\nOlaf Flaschel\t\t<olaf.flaschel[AT]vestifi.de>\nOlaf Westrik\t\t<olaf.westrik[AT]festo.com>\nOle André Vadla Ravnås\t<oleavr[AT]gmail.com>\nOlga Kornievskaia\t<kolga[AT]netapp.com>\nOliver\t\t\t<cellotape[AT]gmail.com>\nOliver Downard\t\t<oliver.downard[AT]couchbase.com>\nOliver Hartkopp\t\t<socketcan[AT]hartkopp.net>\nOliver Smith\t\t<osmith[AT]sysmocom.de>\nOlivier Verriest\t<verri[AT]x25.pm>\nOmer Shapira\t\t<omer.shapira+github[AT]gmail.com>\nOphir Artzi\t\t<ophir.artzi[AT]keysight.com>\nOren Koler\t\t<clicker78[AT]gmail.com>\nOrgad Shaneh\t\t<orgad.shaneh[AT]audiocodes.com>\nOrgad Shaneh\t\t<orgads[AT]gmail.com>\nOscar Gonzalez de Dios\t<oscar.gonzalezdedios[AT]telefonica.com>\nOsman Sakalla\t\t<osman.sakalla[AT]ericsson.com>\nOtto Moerbeek\t\t<otto[AT]drijf.net>\nOwen Williams\t\t<williams.owen[AT]gmail.com>\nØyvind Rønningstad\t<ronningstad[AT]gmail.com>\nPablo Cases\t\t<cases.pablo[AT]gmail.com>\nPablo Martin-Gomez\t<pmartin-gomez[AT]freebox.fr>\nPaolo Abeni\t\t<pabeni[AT]redhat.com>\nPaolo Abeni\t\t<paolo.abeni[AT]gmail.com>\nParav Pandit\t\t<paravpandit[AT]yahoo.com>\nPascal Artho\t\t<pascalartho[AT]gmail.com>\nPascal Quantin\t\t<pascal[AT]wireshark.org>\nPascal S. de Kloe\t<pascal[AT]quies.net>\nPatrice Fournier\t<patrice.fournier[AT]ifax.com>\nPatricia Lindner\t<plindner6912[AT]gmail.com>\nPatrick Große\t\t<patrick.pgrosse[AT]gmail.com>\nPatrick MacArthur\t<pmacarth[AT]iol.unh.edu>\nPatrick Rauscher\t<prauscher[AT]prauscher.de>\nPatrick Servello\t<patrick.servello[AT]gmail.com>\nPatrik Moško\t\t<patrikmosko95[AT]gmail.com>\nPatrik Thunström\t<patrik.thunstroem[AT]technica-engineering.de>\nPatryk Nowak\t\t<patryk.nowak[AT]tieto.com>\nPau Espin Pedrol\t<pespin[AT]sysmocom.de>\nPaul Aurich\t\t<paul[AT]darkrain42.org>\nPaul Chambon\t\t<pchambon[AT]toulouse.viveris.com>\nPaul Donald\t\t<newtwen+github[AT]gmail.com>\nPaul Emge\t\t<paul.emge[AT]digidescorp.com>\nPaul Koning\t\t<paul_koning[AT]dell.com>\nPaul Offord\t\t<paul.offord58[AT]gmail.com>\nPaul Offord\t\t<paul.offord[AT]advance7.com>\nPaul Thomas\t\t<pthomas8589[AT]gmail.com>\nPaul Tyler\t\t<paul.tyler2[AT]rolls-royce.com>\nPaul Weiß\t\t<paulniklasweiss[AT]gmail.com>\nPaul Williamson\t\t<paul[AT]mustbeart.com>\nPaul Zander\t\t<p.j.zander[AT]lighting.com>\nPaulo Roberto Brandão\t<betobrandao[AT]gmail.com>\nPaulThompson\t\t<lankygitster[AT]gmail.com>\nPavel Karneliuk\t\t<pavel_karneliuk[AT]epam.com>\nPavel Moravec\t\t<mgr.pavel[AT]gmail.com>\nPavel Odintsov\t\t<pavel.odintsov[AT]gmail.com>\nPavel Strnad\t\t<strnadp[AT]tiscali.cz>\nPavlos Antoniou\t\t<pant[AT]intracom-telecom.com>\npavol47\t\t\t<pavoloresky47[AT]gmail.com>\nPedro\t\t\t<13929766-bunnis[AT]users.noreply.gitlab.com>\nPedro Alvarez\t\t<pinheirp[AT]tcd.ie>\nPedro Jose Marron\t<pjmarron[AT]locoslab.com>\nPedro Malagon\t\t<malagon[AT]die.upm.es>\npegah hajiani\t\t<pegah_haj[AT]yahoo.com>\nPeikang Zhang\t\t<peikang.zhang[AT]microchip.com>\nPeng Li\t\t\t<seudut[AT]gmail.com>\nPeng Tao\t\t<tao.peng[AT]primarydata.com>\npengtian\t\t<pengtianabc[AT]hotmail.com>\npespin.shar@gmail.com\t<pespin.shar[AT]gmail.com>\nPeter Collingbourne\t<pcc[AT]google.com>\nPeter Dobransky\t\t<pdobransky[AT]verizon.net>\nPeter Dobransky\t\t<peter.dobransky[AT]harmonicinc.com>\nPeter Eszlari\t\t<peter.eszlari[AT]gmail.com>\nPeter Hamilton\t\t<qmear55[AT]protonmail.com>\nPeter Krystad\t\t<peter.krystad[AT]linux.intel.com>\nPeter McLean\t\t<peterm[AT]arista.com>\nPeter Membrey\t\t<peter[AT]membrey.hk>\nPeter Oettig\t\t<peter.oettig[AT]1und1.de>\nPeter Ross\t\t<peter.ross[AT]dsto.defence.gov.au>\nPeter van der Perk\t<peter.vanderperk[AT]nxp.com>\nPetr Gotthard\t\t<petr.gotthard[AT]honeywell.com>\nPetr Janecek\t\t<janecek[AT]ucw.cz>\nPetr Špaček\t\t<pspacek[AT]isc.org>\nPetr Štetiar\t\t<petr.stetiar[AT]gaben.cz>\nPetr Stuchlík\t\t<stuchl4n3k[AT]gmail.com>\nPetr Sumbera\t\t<petr.sumbera[AT]oracle.com>\nPhil Beeson\t\t<bugzilla[AT]philbeeson.com>\nPhilip Gladstone\t<philip[AT]gladstonefamily.net>\nPhilip Rosenberg-Watt\t<p.rosenberg-watt[AT]cablelabs.com>\nPhilipp Dittmann\t<dittmann[AT]cs.uni-bremen.de>\nPhilipp Haefele\t\t<psykoman1990[AT]gmx.de>\nPhilipp Hancke\t\t<fippo[AT]andyet.net>\nPhilipRoman\t\t<frfilips[AT]gmail.com>\nPHO\t\t\t<pho[AT]cielonegro.org>\nPierre-Henri MASSET\t<phmasset[AT]gmail.com>\nPino Toscano\t\t<pino[AT]debian.org>\nPiotr Gawlowicz\t\t<piotr.gawlowicz[AT]srs.io>\nPiotr Pawłowski\t\t<ppiotru[AT]gmail.com>\nPiotr Sarna\t\t<sarna[AT]scylladb.com>\nPiotr Smolinski\t\t<piotr.smolinski[AT]confluent.io>\nPiotr Tulpan\t\t<piotr.tulpan[AT]netscan.pl>\nPiotr Winiarczyk\t<piotr.winiarczyk[AT]silvair.com>\nPiotr Winiarczyk\t<wino45[AT]gmail.com>\nPiotrek Żygieło\t\t<4977588-piotr.zygielo[AT]users.noreply.gitlab.com>\npo307ax\t\t\t<pavol.oresky[AT]student.tuke.sk>\nPoompatai Puntitpong\t<poompatai[AT]google.com>\nPoornima G\t\t<pgurusid[AT]redhat.com>\npranay nag\t\t<pranay.dilip[AT]graniteriverlabs.in>\nPrashant Tripathi\t<prashant_tripathi[AT]selinc.com>\nPrashanth Pai\t\t<ppai[AT]redhat.com>\nPreben Guldberg\t\t<preben[AT]guldberg.org>\nPrerit Jain\t\t<prerit.jain[AT]gmail.com>\nPrerit Jain\t\t<prerit.jain[AT]samsung.com>\nPreston Hunt\t\t<me[AT]prestonhunt.com>\nPrince Paul\t\t<prince.paul.k[AT]gmail.com>\nPriyanka Mondal\t\t<priyanka02010[AT]gmail.com>\nQuentin Armitage\t<quentin[AT]armitage.org.uk>\nRadek Liska\t\t<radek.liska[AT]mavenir.com>\nRadhashyam Behera\t<radhashyambehera[AT]gmail.com>\nRado Radoulov\t\t<rad0x6f[AT]gmail.com>\nRadu Nichita\t\t<rnichita[AT]drwholdings.com>\nRafał Kuźnia\t\t<rafal.kuznia[AT]protonmail.com>\nRainer Keller\t\t<Rainer.Keller[AT]qt.io>\nRalf Nasilowski\t\t<Ralf.Nasilowski[AT]ise.de>\nRalph Boehme\t\t<slow[AT]samba.org>\nRamin Moussavi\t\t<lordrasmus[AT]gmail.com>\nRanjeet Kumar Singh\t<ranjeetsih[AT]gmail.com>\nRasmus Jonsson\t\t<wasmus[AT]zom.bi>\nRay Gomez\t\t<rayvincent.gomez[AT]gmail.com>\nrbroker\t\t\t<rstbroker[AT]gmail.com>\nRediet\t\t\t<getachew.redieteab[AT]orange.com>\nRemi Gacogne\t\t<remi.gacogne[AT]powerdns.com>\nRemous-Aris Koutsiamanis <aris[AT]ariskou.com>\nRémy Léone\t\t<remy.leone[AT]gmail.com>\nRene Nielsen\t\t<rene.nielsen[AT]microchip.com>\nreno\t\t\t<renovetrov[AT]gmail.com>\nRic Li\t\t\t<ricmli[AT]outlook.com>\nRicardo Cristian Ramirez <r.cristian.ramirez[AT]gmail.com>\nRich Coe\t\t<richcoe2[AT]gmail.com>\nRichard E. Silverman\t<res[AT]qoxp.net>\nRichard Kuemmel\t\t<kuemmel.ric[AT]googlemail.com>\nRichard Laager\t\t<rlaager[AT]wiktel.com>\nRichard Smith\t\t<pcy190[AT]126.com>\nRickard Holmberg\t<rickard.holmberg[AT]raysearchlabs.com>\nRickard Holmberg\t<rickard[AT]avkrok.net>\nRishi Dev Singh\t\t<rishi.dev[AT]samsung.com>\nRiya Dixit\t\t<riyadixitagra[AT]gmail.com>\nRob Gill\t\t<rrobgill[AT]protonmail.com>\nRobert Beardsworth\t<rob_beardsworth[AT]hotmail.com>\nRobert Cragie\t\t<robert.cragie[AT]gmail.com>\nRobert Crowston\t\t<crowston[AT]protonmail.com>\nRobert Falkenberg\t<robert.falkenberg[AT]srs.io>\nRobert Frohl\t\t<rfrohl[AT]suse.com>\nRobert P\t\t<tehownt[AT]gmail.com>\nRobert Sauter\t\t<sauter[AT]locoslab.com>\nRobert Shade\t\t<robert.shade[AT]gmail.com>\nRobert Shade\t\t<rshade[AT]blueorigin.com>\nRody Liu\t\t<rody.liu[AT]ericsson.com>\nRoger Light\t\t<roger[AT]atchoo.org>\nRohan Saini\t\t<rohan.saini[AT]nokia.com>\nRoi Berkovich\t\t<roiberkovich[AT]gmail.com>\nRoland Haenel\t\t<roland[AT]haenel.me>\nRoland Knall\t\t<r.knall[AT]commend.com>\nRoland Knall\t\t<r.knall[AT]moba.cc>\nRoland Knall\t\t<rknall[AT]gmail.com>\nRomain Tartière\t\t<romain[AT]blogreen.org>\nRoman Dudin\t\t<9205230+1ndahous3[AT]users.noreply.github.com>\nRoman Koshelev\t\t<roman.koshelev[AT]bk.ru>\nRoman Leonhartsberger\t<ro.leonhartsberger[AT]gmail.com>\nRoman Schmitz\t\t<5892385-schm1tz1[AT]users.noreply.gitlab.com>\nRoman Volkov\t\t<volkoff_roman[AT]ukr.net>\nRonald Wahl\t\t<rwahl[AT]gmx.de>\nRonen Boazi\t\t<ronen.boazi[AT]intel.com>\nRoss Jacobs\t\t<rossbjacobs[AT]gmail.com>\nRoy Chateau\t\t<chateau.royw[AT]gmail.com>\nRoy Zhang\t\t<roy.zhang[AT]nokia-sbell.com>\nRubin Gerritsen\t\t<rubin.gerritsen[AT]nordicsemi.no>\nRudra Rugge\t\t<rrugge[AT]juniper.net>\nRui\t\t\t<ruicunham[AT]hotmail.com>\nRui ZHANG\t\t<rzhang[AT]grandstream.cn>\nRussel Howe\t\t<russel[AT]appliedinvention.com>\nRussell Lowes\t\t<russelll[AT]metamako.com>\nRustam Safargalin\t<rustam.safargalin[AT]sifox.ru>\nRyan Mullen\t\t<rmmullen[AT]gmail.com>\nSaagar Jha\t\t<saagar[AT]saagarjha.com>\nSake Blok\t\t<sake.blok[AT]SYN-bit.nl>\nSaku Ytti\t\t<saku[AT]ytti.fi>\nSam Cisneros\t\t<Sam.Cisneros15[AT]protonmail.com>\nSam James\t\t<sam[AT]gentoo.org>\nSamiran Saha\t\t<ssahasamiran[AT]gmail.com>\nSamuel D. Leslie\t<sdl[AT]nexiom.net>\nSamuel Wein\t\t<poshul[AT]gmail.com>\nSamy CHBINOU\t\t<samy.chbinou[AT]greenflows.fr>\nSandeep Dahiya\t\t<sdahiya[AT]gmail.com>\nSander Steffann\t\t<sander[AT]steffann.nl>\nSandip Mukherjee\t<mukherjee.sandy30[AT]gmail.com>\nSangeetha Jain\t\t<ssi[AT]extremenetworks.com>\nSanket Deshmukh\t\t<sanketd[AT]juniper.net>\nSanket Godbole\t\t<sanket.godbole[AT]spirent.com>\nSawssen Hadded\t\t<saw.hadded[AT]gmail.com>\nSayuri Mizushima\t<yamaguchi55[AT]protonmail.ch>\nScott Deandrea\t\t<sdeandrea[AT]apple.com>\nScott McKay\t\t<smckay[AT]pathwayconnect.com>\nSebastian\t\t<mail[AT]sebastians.dev>\nSebastian Kloeppel\t<sk[AT]nakedape.net>\nSebastian Reimers\t<hallo[AT]studio-link.de>\nSebastian Schildt\t<sebastian[AT]frozenlight.de>\nSébastien Deronne\t<sebastien.deronne[AT]gmail.com>\nSebastien Henri\t\t<sebastien.henri[AT]meraki.net>\nSébastien RAILLARD\t<sr[AT]coexsi.fr>\nSektor van Skijlen\t<ethouris[AT]gmail.com>\nSelva Kumar\t\t<v.selvamuthukumar[AT]gmail.com>\nSelvamegala\t\t<sselvamegala[AT]gmail.com>\nSergey Avseyev\t\t<sergey.avseyev[AT]gmail.com>\nSergey Bogdanov\t\t<Sergey.Bogdanov[AT]astrosoft.ru>\nSergey Rak\t\t<sergrak[AT]iotecha.com>\nSergey V. Lobanov\t<sergey.v.lobanov[AT]yandex.ru>\nSergey V. Lobanov\t<sergey[AT]lobanov.in>\nSergio de Paula\t\t<sergio.paula[AT]dsr-corporation.com>\nSergio Moreno Mozota\t<sergio.morenomozota[AT]telefonica.com>\nSeth Alexander\t\t<seth.alexander[AT]cosmicaes.com>\nSharon Brizinov\t\t<SharonBrizinov[AT]users.noreply.github.com>\nSharvil Nanavati\t<sharvil[AT]playground.global>\nShekhar Chandra\t\t<ranushekhar[AT]gmail.com>\nsherber1\t\t<sebastian.herber[AT]hbkworld.com>\nSherwin  Clutter\t<sclutter[AT]flybynite.net>\nShinjo Park\t\t<peremen[AT]gmail.com>\nShoichi Sakane\t\t<wireshark-shoichi[AT]tanu.org>\nshqking\t\t\t<shqking[AT]gmail.com>\nShreesh Roliwal\t\t<sroliwal[AT]gmail.com>\nShu Shen\t\t<shu.shen[AT]gmail.com>\nShuai Xiao\t\t<iamhihi[AT]gmail.com>\nShubham jha\t\t<itsshubhamjha[AT]gmail.com>\nShudong Zhou\t\t<shudongzhou[AT]gmail.com>\nSignat Sibirskiy\t<ord.blant[AT]gmail.com>\nSilvio Gissi\t\t<silvio.gissi[AT]gmail.com>\nSimon Barber\t\t<simon.barber[AT]meraki.net>\nSimon Cornish\t\t<cgpmp5vkq2[AT]liamekaens.com>\nSimon Graham\t\t<simgrxp[AT]gmail.com>\nSimon Holesch\t\t<simon[AT]holesch.de>\nSimon Long\t\t<hobei[AT]whitedoor.plus.com>\nSimon Steinmann\t\t<simon.steinmann91[AT]gmail.com>\nSimon Vans-Colina\t<simon[AT]monzo.com>\nSimon Waldherr\t\t<git[AT]simon.waldherr.eu>\nSimon Zhong\t\t<szhong.jnpr[AT]gmail.com>\nSlava Bacherikov\t<slava[AT]bacher09.org>\nSlava Shwartsman\t<slavash[AT]mellanox.com>\nsnicket2100\t\t<15079832-snicket2100[AT]users.noreply.gitlab.com>\nsnicket2100\t\t<snicket2100[AT]protonmail.com>\nsofiane degoui\t\t<degoui.sofiane[AT]gmail.com>\nSolganik Alexander\t<solganik[AT]gmail.com>\nSontol Bonggol\t\t<sonbonggol[AT]gmail.com>\nSoumya Koduri\t\t<skoduri[AT]redhat.com>\nSteev Klimaszewski\t<threeway[AT]gmail.com>\nStefan Battmer\t\t<stefan.battmer[AT]matrix-vision.de>\nStefan Doehla\t\t<stefan.doehla[AT]iis.fraunhofer.de>\nStefan Hajnoczi\t\t<stefanha[AT]redhat.com>\nStefan Kimmer\t\t<skimmer[AT]s2e-systems.com>\nStefan Pöschel\t\t<github[AT]basicmaster.de>\nStefan Sauer\t\t<st.kost[AT]gmail.com>\nStefan Tatschner\t<stefan[AT]rumpelsepp.org>\nStefan Völkel\t\t<sv[AT]its-v.de>\nStella Randall\t\t<stella.randall[AT]emeerson.com>\nStepan Chernousov\t<stepan.chernousov[AT]dsr-corporation.com>\nStephan Brunner\t\t<s.brunner[AT]stephan-brunner.net>\nStephan Kappertz\t<octopus.sk[AT]googlemail.com>\nStephane\t\t<stephane.for.test[AT]gmail.com>\nStephane Bryant\t\t<stephane.ml.bryant[AT]gmail.com>\nStéphane Lapie\t\t<stephane.lapie[AT]darkbsd.org>\nStephen Donnelly\t<stephen.donnelly[AT]endace.com>\nStephen Hemminger\t<stephen[AT]networkplumber.org>\nSteve Alexander\t\t<sca[AT]ca35.com>\nSteve Bennett\t\t<steveb[AT]workware.net.au>\nSteve Osselton\t\t<steve.osselton[AT]gmail.com>\nSteve Williams\t\t<steve.williams[AT]getcruise.com>\nsteve71\t\t\t<steve[AT]clarke.org.uk>\nStijn Last\t\t<stijn.last[AT]barco.com>\nsubhav8\t\t\t<subhadevi88[AT]gmail.com>\nSultan Qasim Khan\t<sultan.qasimkhan[AT]nccgroup.com>\nSunil Mushran\t\t<sunil.mushran[AT]oracle.com>\nSven Eckelmann\t\t<sven[AT]open-mesh.com>\nSven Schnelle\t\t<svens[AT]stackframe.org>\nSwapnil Roy\t\t<swapnil.advent[AT]gmail.com>\nSylvain Heiniger\t<sploutchy[AT]gmail.com>\nSylvain Munaut\t\t<tnt[AT]246tNt.com>\nT. Scholz\t\t<scholzt234[AT]googlemail.com>\nTadeusz Struk\t\t<tadeusz.struk[AT]intel.com>\nTadeusz Struk\t\t<tstruk[AT]gmail.com>\nTaisuke Sasaki\t\t<taisasak[AT]cisco.com>\nTamas Regos\t\t<regost[AT]gmail.com>\nTamir Duberstein\t<tamird[AT]google.com>\nTara Evans-Ellis\t<taraevansellis[AT]gmail.com>\nTatsuhiro Tsujikawa\t<tatsuhiro.t[AT]gmail.com>\nTengfei Chang\t\t<tengfei.chang[AT]inria.fr>\nTeyut\t\t\t<teyut[AT]free.fr>\nthe-Chain-Warden-thresh\t<18302010006[AT]fudan.edu.cn>\ntherrmann-adwin\t\t<therrmann[AT]adwin.de>\nThibault Gerondal\t<github[AT]tycale.be>\nThibaut Vandervelden\t<thvdveld[AT]vub.be>\nThies Moeller\t\t<thies.moeller[AT]baslerweb.com>\nThiyagarajan P\t\t<psvthiyagarajan[AT]gmail.com>\nThomas Chen\t\t<funorpain[AT]gmail.com>\nThomas d'Otreppe\t<tdotreppe[AT]aircrack-ng.org>\nThomas Dreibholz\t<dreibh[AT]iem.uni-due.de>\nThomas Goodrum\t\t<tgoodrum[AT]rbbn.com>\nThomas Habets\t\t<thomas[AT]habets.se>\nThomas Jansen\t\t<mithi[AT]mithi.net>\nThomas Klausner\t\t<tk[AT]giga.or.at>\nThomas Portassau\t<thomas.portassau[AT]hotmail.fr>\nThomas Sailer\t\t<gitlab[AT]sailer.dynip.lugs.ch>\nThomas Sailer\t\t<sailer[AT]tsailer.ch>\nThomas Shen\t\t<thomashen[AT]gmail.com>\nThomas Stewart\t\t<thomas[AT]stewarts.org.uk>\nThomas Vogt\t\t<gitwiresharktv[AT]ist-einmalig.de>\nTigran Mkrtchyan\t<tigran.mkrtchyan[AT]desy.de>\nTim (Thanh) Nguyen\t<tnnguyen[AT]broadcom.com>\nTim Cuthbertson\t\t<tim[AT]gfxmonk.net>\nTim Furlong\t\t<tim.furlong[AT]gmail.com>\nTim Potter\t\t<tim.potter[AT]viasat.com>\nTimmy Brolin\t\t<tib[AT]hms.se>\nTimo Warns\t\t<timow+git[AT]DiningPhilosopher.DE>\nTimo Warns\t\t<timow+github[AT]DiningPhilosopher.DE>\nTimo Warns\t\t<timow+gitlab[AT]diningphilosopher.de>\nTimotej Ecimovic\t<timotej.ecimovic[AT]silabs.com>\nTimothy Geiser\t\t<slimshady007[AT]inbox.lv>\nTobias\t\t\t<tobiasmicheler[AT]outlook.de>\nTobias Brunner\t\t<tobias[AT]strongswan.org>\nTobias Mueller\t\t<gitlab[AT]muelli.cryptobitch.de>\nTobias Mueller\t\t<muelli[AT]cryptobitch.de>\nTobias Rasmusson\t<tobias.rasmusson[AT]gmail.com>\nTobias Stoeckmann\t<tobias[AT]stoeckmann.org>\nToff\t\t\t<christophe.paris[AT]free.fr>\nTom\t\t\t<tom916[AT]qq.com>\nTom Haynes\t\t<loghyr[AT]hammerspace.com>\nTom Haynes\t\t<loghyr[AT]primarydata.com>\nTom Nisbet\t\t<t.talk[AT]nisbethome.com>\nTom Yan\t\t\t<tom.yan[AT]nokia-sbell.com>\nTomas Konecny\t\t<tomas.konecny[AT]eldis.cz>\nTomas Kukosa\t\t<kukosa[AT]herman.cz>\nTomas Kukosa\t\t<tkeksa[AT]gmail.com>\nTomas Kukosa\t\t<tomas.kukosa[AT]ixperta.com>\nTomas Liscak\t\t<tomas.liscak[AT]nokia.com>\nTomasz Woszczynski\t<duchowe50k[AT]gmail.com>\nToni Uhlig\t\t<matzeton[AT]googlemail.com>\nTony Ciavarella\t\t<tony.ciavarella[AT]squalllinesoftware.com>\nTopi Miettinen\t\t<toiwoton[AT]gmail.com>\nTrevor Bergeron\t\t<mal[AT]sec.gd>\nTriton Circonflexe\t<triton[AT]kumal.info>\nTrond Myklebust\t\t<trond.myklebust[AT]primarydata.com>\nTrond Norbye\t\t<trond.norbye[AT]gmail.com>\nTrond Norbye\t\t<trond[AT]couchbase.com>\nTroy Dowling\t\t<twd[AT]exegin.com>\nUgur ILTER\t\t<ugur.ilter[AT]airties.com>\nUlf\t\t\t<ulf33286[AT]gmail.com>\nUli Schlachter\t\t<psychon[AT]znc.in>\nUmberto Corponi\t\t<umberto.corponi[AT]athonet.com>\nUri Simchoni\t\t<urisimchoni[AT]gmail.com>\nuser202729\t\t<25191436+user202729[AT]users.noreply.github.com>\nUwe Heuert\t\t<uwe.heuert[AT]exceeding-solutions.de>\nUwe Kleine-König\t<uwe[AT]kleine-koenig.org>\nVadim Fedorenko\t\t<vadimjunk[AT]gmail.com>\nVadim Yanitskiy\t\t<axilirator[AT]gmail.com>\nVadim Yanitskiy\t\t<vyanitskiy[AT]sysmocom.de>\nVafokhon Safokhujaev\t<vafo.main[AT]gmail.com>\nVahap Emin Agaogullari\t<emin.agaogullari[AT]siemens.com>\nVahap Emin Agaogullari\t<vahapemin44[AT]gmail.com>\nValdikSS\t\t<iam[AT]valdikss.org.ru>\nValentin Vidic\t\t<Valentin.Vidic[AT]CARNet.hr>\nValerii Zapodovnikov\t<val.zapod.vz[AT]gmail.com>\nVan Ly Vu\t\t<van.ly.vu[AT]vestifi.de>\nVanson Lim\t\t<vlim[AT]cisco.com>\nVasil Velichkov\t\t<vvvelichkov[AT]gmail.com>\nVasily Utkin\t\t<vautkin[AT]teknik.io>\nVasuki Manikarnike\t<vasuki.manikarnike[AT]hpe.com>\nVictor Barratault\t<victor.barratault[AT]gmail.com>\nVictor Dodon\t\t<dodonvictor[AT]gmail.com>\nVictor Voronkov\t\t<victor.voronkov[AT]gmail.com>\nVidar Madsen\t\t<vidarino[AT]gmail.com>\nVik\t\t\t<vkp129+ubuntu[AT]gmail.com>\nVikhyat Umrao\t\t<vumrao[AT]redhat.com>\nVikram Hegde\t\t<vikram.h[AT]samsung.com>\nVille Skyttä\t\t<ville.skytta[AT]iki.fi>\nVincent Hamp\t\t<vincent.hamp[AT]higaski.at>\nVincent Helfre\t\t<vincent.helfre[AT]gmx.net>\nVincenzo Reale\t\t<smart2128vr[AT]gmail.com>\nViorela Marcu\t\t<viorela.marcu[AT]keysight.com>\nVitaliy Guschin\t\t<guschin108[AT]gmail.com>\nVivek Mangala\t\t<vivekmangala[AT]gmail.com>\nVivek Pandey\t\t<vivek_pandey[AT]comcast.com>\nVladimir Bespalov\t<vladimir.bespalov[AT]dsr-corporation.com>\nVladimir Kondratiev\t<qca_vkondrat[AT]qca.qualcomm.com>\nVladimir Rutsky\t\t<rutsky[AT]google.com>\nVladislav Grishenko\t<themiron[AT]mail.ru>\nVladlen Popov\t\t<vladlen.popov[AT]yahoo.com>\nVojtech Salanda\t\t<salandav[AT]gmail.com>\nVojtěch Svědiroh\t<vojta.svediroh[AT]gmail.com>\nVolker Lendecke\t\t<vl[AT]samba.org>\nVolodymyr Khomenko\t<Khomenko.Volodymyr[AT]gmail.com>\nVolodymyr Khomenko\t<volodymyr[AT]vastdata.com>\nVolodymyr Veskera\t<volodymyrv[AT]interfacemasters.com>\nvxcute\t\t\t<freemasry[AT]proton.me>\nvyacheslav.kostyuchenko\t<vyacheslav.kostyuchenko[AT]dsr-corporation.com>\nWarren Moxam\t\t<warrenmptgrey[AT]gmail.com>\nWasim Abu Moch\t\t<wasim[AT]mellanox.com>\nWeston Andros Adamson\t<dros[AT]primarydata.com>\nWeston Schmidt\t\t<weston_schmidt[AT]alumni.purdue.edu>\nwi24rd\t\t\t<wi24rd+gitlab[AT]fedoraproject.org>\nWill Aftring\t\t<william.aftring[AT]outlook.com>\nWill Glynn\t\t<will[AT]willglynn.com>\nWill Robertson\t\t<aliask[AT]gmail.com>\nWilliam Tu\t\t<u9012063[AT]gmail.com>\nwinprotocolwireshark\t<winprotocolwireshark[AT]microsoft.com>\nWolfgang Steinwender\t<steinwender[AT]web.de>\nXavi Hernandez\t\t<xhernandez[AT]redhat.com>\nXavier Brouckaert\t<xabrouck[AT]cisco.com>\nXavier Chantry\t\t<xavier.chantry[AT]intersec.com>\nXiaochuan Sun\t\t<linuxvxworks[AT]gmail.com>\nXiaofeng Wang\t\t<wasphin[AT]gmail.com>\nXiaoxia Lang\t\t<xxlang[AT]grandstream.cn>\nXiong Nandi\t\t<xndchn[AT]gmail.com>\nXuNiu\t\t\t<993273596[AT]qq.com>\nYan Burman\t\t<yanb[AT]mellanox.com>\nYang Luo\t\t<hsluoyz[AT]qq.com>\nYaniv Kaul\t\t<yaniv.kaul[AT]scylladb.com>\nYann Diorcet\t\t<yann[AT]diorcet.fr>\nYann Garcia\t\t<yann.garcia[AT]fscom.frSkype>\nYann Lejeune\t\t<yann.lejeune[AT]gmail.com>\nYann Lejeune\t\t<ylejeune[AT]netyl.org>\nYann Pomarede\t\t<yannpomarede[AT]gmail.com>\nYann Pomarède\t\t<yann.pomarede[AT]gmail.com>\nYannik Enss\t\t<Yannik.Enss[AT]rohde-schwarz.com>\nYaroslav Rosomakho\t<yaroslavros[AT]gmail.com>\nYasuyuki Tanaka\t\t<yasuyuki.tanaka[AT]inria.fr>\nYDKK\t\t\t<13453291-YDKK[AT]users.noreply.gitlab.com>\nYehonatan Zecharia\t<yonti95[AT]gmail.com>\nYehudah Aaron\t\t<yehmron[AT]gmail.com>\nYFdyh000\t\t<yfdyh000[AT]gmail.com>\nYingjie Deng\t\t<17322619133[AT]163.com>\nYohei Konno\t\t<konnoy[AT]craftone.jpn.org>\nYoni Gilad\t\t<yonig[AT]radcom.com>\nYoshihiro Ueda\t\t<uyoshihiro[AT]users.noreply.gitlab.com>\nYoshiyuki Kurauchi\t<ahochauwaaaaa[AT]gmail.com>\nYu Gao\t\t\t<katgao[AT]cisco.com>\nYu Gao\t\t\t<katherinegy0515[AT]gmail.com>\nyuanjungong\t\t<yuanjungong96[AT]gmail.com>\nYuri Chislov\t\t<yuri.chislov[AT]gmail.com>\nYurii Lysyi\t\t<yurii.lysyi[AT]ericsson.com>\nYury Gargay\t\t<yury.gargay[AT]gmail.com>\nYuya Kawakami\t\t<github[AT]yuyarin.net>\nYuya Kawakami\t\t<yuyarin[AT]yuyarin.net>\nYuya Kusakabe\t\t<y-kusakabe[AT]bbsakura.net>\nZach Chadwick\t\t<zachad[AT]qacafe.com>\nZachary Holcomb\t\t<zholcomb2017[AT]my.fit.edu>\nZackhardtoname\t\t<zack.hardtoname[AT]gmail.com>\nZdeněk Žamberský\t<zzdevel[AT]seznam.cz>\nZhang Zhilei\t\t<zhangzhilei[AT]360.cn>\nZhao Lin\t\t<zlbinghamton[AT]gmail.com>\nZhaoHao\t\t\t<zhaohao360[AT]gmail.com>\nZhenhua Hu\t\t<fattiger1102[AT]gmail.com>\nZhongwei Situ\t\t<zsitu[AT]extremenetworks.com>\nZhongYao Luo\t\t<LuoZhongYao[AT]gmail.com>\nzhudewen\t\t<zhudewen[AT]iauto.com>\nZizhao Wang\t\t<21307130036[AT]m.fudan.edu.cn>\nZoran Bošnjak\t\t<zoran.bosnjak[AT]sloveniacontrol.si>\nZoran Bošnjak\t\t<zoran.bosnjak[AT]via.si>\nzyoshoka\t\t<zyoshoka[AT]gmail.com>\nДмитрий Цветцих\t\t<dmitrycvet[AT]gmail.com>\n"
        },
        {
          "name": "CMakeGraphVizOptions.cmake",
          "type": "blob",
          "size": 0.4638671875,
          "content": "# CMake configuration to control the look and contents of generated graphviz files.\n#\n# Documentation: https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html\n#\n# To generate a dependency graph from the build directory:\n#\n#   cmake . --graphviz=wireshark.dot\n#   fdp wireshark.dot -Tpdf -o wireshark.pdf\n\nset(GRAPHVIZ_GRAPH_NAME \"Wireshark dependency graph\")\nset(GRAPHVIZ_GRAPH_HEADER \\tsize=\"5!\" \\n\\tgraph[splines=\"true\",forcelabels=\"true\",overlap=\"false\"] \\n)\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 152.7734375,
          "content": "# CMakeLists.txt\n#\n# Wireshark - Network traffic analyzer\n# By Gerald Combs <gerald@wireshark.org>\n# Copyright 1998 Gerald Combs\n#\n# SPDX-License-Identifier: GPL-2.0-or-later\n#\nif(DEFINED ENV{FORCE_CMAKE_NINJA_NON_VERBOSE})\n\t#\n\t# Forcibly unset CMAKE_VERBOSE_MAKEFILE,\n\t# to make *CERTAIN* that we don't do\n\t# anything verbose here!\n\t#\n\tunset(CMAKE_VERBOSE_MAKEFILE CACHE)\nendif()\n\n# https://doc.qt.io/qt-6/cmake-supported-cmake-versions.html\ncmake_minimum_required(VERSION 3.16)\nif(POLICY CMP0135)\n\tcmake_policy(SET CMP0135 NEW)\nendif()\n\nif(WIN32 AND NOT DEFINED ENV{MSYSTEM})\n\tset(_project_name Wireshark)\n\tset(STRATOSHARK_NAME Stratoshark)\nelse()\n\tset(_project_name wireshark)\n\tset(STRATOSHARK_NAME stratoshark)\nendif()\n\nproject(${_project_name} C CXX)\n\nif(WIN32)\n\tset(_msystem False)\n\tset(_repository False)\n\tif(DEFINED ENV{MSYSTEM})\n\t\tset(_msystem $ENV{MSYSTEM})\n\t\tmessage(STATUS \"Using MSYS2 with MSYSTEM=${_msystem}\")\n\telseif(MSVC)\n\t\tset(_repository True)\n\t\tmessage(STATUS \"Using 3rd party repository\")\n\telse()\n\t\t# Neither own package repository nor MSYS2 repository.\n\tendif()\n\tset(USE_MSYSTEM ${_msystem} CACHE INTERNAL \"Use MSYS2 subsystem\")\n\tset(HAVE_MSYSTEM ${USE_MSYSTEM}) # For config.h\n\tset(USE_REPOSITORY ${_repository} CACHE INTERNAL \"Use Wireshark 3rd Party Repository\")\nendif()\n\n# Updated by tools/make-version.py\nset(PROJECT_MAJOR_VERSION 4)\nset(PROJECT_MINOR_VERSION 5)\nset(PROJECT_PATCH_VERSION 0)\nset(PROJECT_BUILD_VERSION 0)\nset(PROJECT_VERSION_EXTENSION \"\")\n\nif(DEFINED ENV{WIRESHARK_VERSION_EXTRA})\n\tset(PROJECT_VERSION_EXTENSION \"$ENV{WIRESHARK_VERSION_EXTRA}\")\nendif()\n\nset(PROJECT_VERSION \"${PROJECT_MAJOR_VERSION}.${PROJECT_MINOR_VERSION}.${PROJECT_PATCH_VERSION}${PROJECT_VERSION_EXTENSION}\")\n\nset(STRATOSHARK_MAJOR_VERSION 0)\nset(STRATOSHARK_MINOR_VERSION 9)\nset(STRATOSHARK_PATCH_VERSION 0)\nset(STRATOSHARK_BUILD_VERSION 0)\nset(STRATOSHARK_VERSION_EXTENSION \"\")\n\nif(DEFINED ENV{STRATOSHARK_VERSION_EXTRA})\n\tset(STRATOSHARK_VERSION_EXTENSION \"$ENV{STRATOSHARK_VERSION_EXTRA}\")\nendif()\n\nset(STRATOSHARK_VERSION \"${STRATOSHARK_MAJOR_VERSION}.${STRATOSHARK_MINOR_VERSION}.${STRATOSHARK_PATCH_VERSION}${STRATOSHARK_VERSION_EXTENSION}\")\n\ninclude( CMakeOptions.txt )\n\n# We require minimum C11\nset(CMAKE_C_STANDARD 11)\nset(CMAKE_C_STANDARD_REQUIRED ON)\n\n# We require minimum C++11\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\nmessage(STATUS \"Generating build using CMake ${CMAKE_VERSION}\")\n\nif(USE_MSYSTEM)\n\t# Prevent FindPython3.cmake from using the Python path in the registry,\n\t# only use the $PATH environment variable (which is set up for MSYS2).\n\tset(Python3_FIND_REGISTRY NEVER)\nendif()\nfind_package(Python3 3.6 REQUIRED)\n\n# Strawberry is a web browser away from being its own operating system. Find\n# Perl before finding anything else so that we can avoid building with any of\n# of Strawberry's components. Adding Strawberry's \"/c\" subdirectory to\n# CMAKE_IGNORE_PREFIX_PATH should help us avoid pulling in libraries such as\n# zlib and executables such as xsltproc. CMake 3.29.1 and later ignores their\n# pkg-config: https://gitlab.kitware.com/cmake/cmake/-/merge_requests/9375\nfind_package(Perl)\nif(WIN32 AND PERL_EXECUTABLE)\n\tstring(TOLOWER ${PERL_EXECUTABLE} lower_perl)\n\tif (${lower_perl} MATCHES \"^.:/strawberry/\")\n\t\tstring(REGEX REPLACE \"^(.:/[^/]+).*\" \"\\\\1\" strawberry_prefix ${PERL_EXECUTABLE})\n\t\t# CMAKE_IGNORE_PREFIX_PATH must be an exact installation prefix.\n\t\tlist(APPEND CMAKE_IGNORE_PREFIX_PATH \"${strawberry_prefix}/c\")\n\t\tmessage(STATUS \"Added ${strawberry_prefix}/c to CMAKE_IGNORE_PREFIX_PATH\")\n\t\tunset(lower_perl)\n\t\tunset(strawberry_prefix)\n\tendif()\nendif()\n\n\n# Set a default build type if none was specified\nset(_default_build_type \"RelWithDebInfo\")\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n\tset(CMAKE_BUILD_TYPE \"${_default_build_type}\" CACHE STRING \"Choose the type of build.\" FORCE)\n\t# Set the possible values of build type for cmake-gui\n\tset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\" \"MinSizeRel\" \"RelWithDebInfo\")\nendif()\n\n# Build type is ignored by multi-config generators.\nif (NOT CMAKE_CONFIGURATION_TYPES)\n\tmessage(STATUS \"Using \\\"${CMAKE_GENERATOR}\\\" generator and build type \\\"${CMAKE_BUILD_TYPE}\\\"\")\nelse()\n\tmessage(STATUS \"Using \\\"${CMAKE_GENERATOR}\\\" generator (multi-config)\")\nendif()\n\n#Where to find local cmake scripts\nset(WS_CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/modules)\nset(CMAKE_MODULE_PATH ${WS_CMAKE_MODULE_PATH})\n\n# CMake >= 3.9.0 supports LTO/IPO.\nif (ENABLE_LTO)\n\tinclude(CheckIPOSupported)\n\tcheck_ipo_supported(RESULT lto_supported OUTPUT lto_output)\n\tif(lto_supported)\n\t\tset(CMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE TRUE)\n\t\tmessage(STATUS \"LTO/IPO is enabled for Release configuration\")\n\telse()\n\t\tmessage(STATUS \"LTO/IPO requested but it is not supported by the compiler: ${lto_output}\")\n\tendif()\nelse()\n\tmessage(STATUS \"LTO/IPO is not enabled\")\nendif()\n\n# If our target platform is enforced by our generator, set\n# WIRESHARK_TARGET_PLATFORM accordingly. Otherwise use\n# %WIRESHARK_TARGET_PLATFORM%.\n\nif(WIN32)\n\tif(DEFINED ENV{WIRESHARK_TARGET_PLATFORM})\n\t\tstring(TOLOWER $ENV{WIRESHARK_TARGET_PLATFORM} _target_platform)\n\t\tset(WIRESHARK_TARGET_PLATFORM ${_target_platform})\n\telseif(USE_MSYSTEM MATCHES \"MINGW64|CLANG64|UCRT64\")\n\t\t# https://www.msys2.org/docs/environments\n\t\t#    MSYS2 comes with different environments/subsystems and\n\t\t#    the first thing you have to decide is which one to use.\n\t\t#    The differences among the environments are mainly environment\n\t\t#    variables, default compilers/linkers, architecture,\n\t\t#    system libraries used etc. If you are unsure, go with UCRT64.\n\t\tset(WIRESHARK_TARGET_PLATFORM x64)\n\telseif(USE_MSYSTEM)\n\t\tif($ENV{MSYSTEM_CARCH} MATCHES \"x86_64\")\n\t\t\tset(WIRESHARK_TARGET_PLATFORM x64)\n\t\telseif($ENV{MSYSTEM_CARCH} MATCHES \"i686\")\n\t\t\tset(WIRESHARK_TARGET_PLATFORM win32)\n\t\telseif($ENV{MSYSTEM_CARCH} MATCHES \"aarch64\")\n\t\t\tset(WIRESHARK_TARGET_PLATFORM \"arm64\")\n\t\telse()\n\t\t\tset(WIRESHARK_TARGET_PLATFORM \"$ENV{MSYSTEM_CARCH}\")\n\t\tendif()\n\telseif($ENV{Platform} MATCHES arm64 OR CMAKE_GENERATOR_PLATFORM MATCHES arm64)\n\t\tset(WIRESHARK_TARGET_PLATFORM arm64)\n\telseif(CMAKE_CL_64 OR CMAKE_GENERATOR MATCHES x64)\n\t\tset(WIRESHARK_TARGET_PLATFORM x64)\n\telse()\n\t\tmessage(WARNING \"Assuming \\\"x64\\\" target platform\")\n\t\tset(WIRESHARK_TARGET_PLATFORM x64)\n\tendif()\n\n\tif(WIRESHARK_TARGET_PLATFORM MATCHES \"win32\")\n\t\tmessage(FATAL_ERROR \"Deprecated target platform ${WIRESHARK_TARGET_PLATFORM}. See https://gitlab.com/wireshark/wireshark/-/issues/17779 for details.\")\n\telseif(NOT (WIRESHARK_TARGET_PLATFORM MATCHES \"x64\" OR WIRESHARK_TARGET_PLATFORM MATCHES \"arm64\"))\n\t\tmessage(FATAL_ERROR \"Invalid target platform: ${WIRESHARK_TARGET_PLATFORM}\")\n\tendif()\n\n\t# Sanity check\n\tif(MSVC AND DEFINED ENV{PLATFORM})\n\t\tstring(TOLOWER $ENV{PLATFORM} _vs_platform)\n\t\tif(\n\t\t\t(_vs_platform STREQUAL \"x64\" AND NOT WIRESHARK_TARGET_PLATFORM STREQUAL \"x64\")\n\t\t\tOR\n\t\t\t(_vs_platform STREQUAL \"arm64\" AND NOT WIRESHARK_TARGET_PLATFORM STREQUAL \"arm64\")\n\t\t)\n\t\t\tmessage(FATAL_ERROR \"The PLATFORM environment variable (${_vs_platform})\"\n\t\t\t\t\" doesn't match the generator platform (${WIRESHARK_TARGET_PLATFORM})\")\n\t\tendif()\n\tendif()\n\n\tmessage(STATUS\n\t\t\"Building for ${WIRESHARK_TARGET_PLATFORM}\"\n\t)\n\n\tif(NOT CMAKE_CROSSCOMPILING)\n\t\tfind_package(PowerShell REQUIRED)\n\tendif()\n\n\t# Determine where the 3rd party libraries will be\n\tif(USE_REPOSITORY)\n\t\tif( DEFINED ENV{WIRESHARK_LIB_DIR} )\n\t\t\t# The buildbots set WIRESHARK_LIB_DIR but not WIRESHARK_BASE_DIR.\n\t\t\tfile( TO_CMAKE_PATH \"$ENV{WIRESHARK_LIB_DIR}\" _PROJECT_LIB_DIR )\n\t\telseif( DEFINED ENV{WIRESHARK_BASE_DIR} )\n\t\t\tfile( TO_CMAKE_PATH \"$ENV{WIRESHARK_BASE_DIR}\" _WS_BASE_DIR )\n\t\t\tset( _PROJECT_LIB_DIR \"${_WS_BASE_DIR}/wireshark-${WIRESHARK_TARGET_PLATFORM}-libs\" )\n\t\telse()\n\t\t\t# Don't know what to do\n\t\t\tmessage(FATAL_ERROR \"Neither WIRESHARK_BASE_DIR or WIRESHARK_LIB_DIR are defined\")\n\t\tendif()\n\n\t\t# Download third-party libraries\n\t\tfile (TO_NATIVE_PATH ${CMAKE_SOURCE_DIR}/tools/win-setup.ps1 _win_setup)\n\t\tfile (TO_NATIVE_PATH ${_PROJECT_LIB_DIR} _ws_lib_dir)\n\t\tfile (TO_NATIVE_PATH ${CMAKE_COMMAND} _win_cmake_command)\n\n\t\t# Is it possible to have a one-time, non-cached option in CMake? If\n\t\t# so, we could add a \"-DFORCE_WIN_SETUP\" which passes -Force to\n\t\t# win-setup.ps1.\n\t\texecute_process(\n\t\t\tCOMMAND ${POWERSHELL_COMMAND} \"\\\"${_win_setup}\\\"\" -Destination \"${_ws_lib_dir}\" -Platform ${WIRESHARK_TARGET_PLATFORM} -CMakeExecutable \"\\\"${_win_cmake_command}\\\"\"\n\t\t\tRESULT_VARIABLE _win_setup_failed\n\t\t\tERROR_VARIABLE _win_setup_error_output\n\t\t)\n\t\tif(_win_setup_failed)\n\t\t\tmessage(FATAL_ERROR \"Windows setup (win-setup.ps1) failed: ${_win_setup_error_output}.\")\n\t\tendif()\n\n\t\tset(EXTRA_INSTALLER_DIR ${_ws_lib_dir})\n\n\t\t# XXX Add a dependency on ${_ws_lib_dir}/current_tag.txt?\n\telse()\n\t\tset(EXTRA_INSTALLER_DIR ${CMAKE_BINARY_DIR}/packaging/nsis)\n\tendif()\n\n\tinclude(FetchContent)\n\tset(LIBS_URL \"https://dev-libs.wireshark.org/windows/packages\")\n\tfile(TO_CMAKE_PATH ${EXTRA_INSTALLER_DIR} _file_download_dir)\n\n\t# Download Npcap required by the Windows installer\n\tset(NPCAP_VERSION \"1.80\")\n\tset(NPCAP_SHA256 \"ac4f26d7d9f994d6f04141b2266f02682def51af63c09c96a7268552c94a6535\")\n\tset(NPCAP_FILENAME \"npcap-${NPCAP_VERSION}.exe\")\n\tset(NPCAP_URL \"${LIBS_URL}/Npcap/${NPCAP_FILENAME}\")\n\tFetchContent_Declare(Npcap\n\t\tURL ${NPCAP_URL}\n\t\tDOWNLOAD_DIR ${_file_download_dir}\n\t\tURL_HASH SHA256=${NPCAP_SHA256}\n\t\tDOWNLOAD_NO_EXTRACT True\n\t)\n\n\t# Download USBPcap required by the Windows installer\n\tset(USBPCAP_VERSION \"1.5.4.0\")\n\tset(USBPCAP_SHA256 \"87a7edf9bbbcf07b5f4373d9a192a6770d2ff3add7aa1e276e82e38582ccb622\")\n\tset(USBPCAP_FILENAME \"USBPcapSetup-${USBPCAP_VERSION}.exe\")\n\tset(USBPCAP_URL \"${LIBS_URL}/USBPcap/${USBPCAP_FILENAME}\")\n\tFetchContent_Declare(USBPcap\n\t\tURL ${USBPCAP_URL}\n\t\tDOWNLOAD_DIR ${_file_download_dir}\n\t\tURL_HASH SHA256=${USBPCAP_SHA256}\n\t\tDOWNLOAD_NO_EXTRACT True\n\t)\nendif(WIN32)\n\ninclude(UseCustomIncludes)\nADD_CUSTOM_CMAKE_INCLUDE()\n\n# Ensure that all executables and libraries end up in the same directory. Actual\n# files might end up in a configuration subdirectory, e.g. run/Debug or\n# run/Release. We try to set DATAFILE_DIR to actual location below.\nif(NOT ARCHIVE_OUTPUT_PATH)\n\tset(ARCHIVE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/run CACHE INTERNAL\n\t\t   \"Single output directory for building all archives.\")\nendif()\nif(NOT EXECUTABLE_OUTPUT_PATH)\n\tset(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/run CACHE INTERNAL\n\t\t   \"Single output directory for building all executables.\")\nendif()\nif(NOT LIBRARY_OUTPUT_PATH)\n\tset(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR}/run CACHE INTERNAL\n\t\t   \"Single output directory for building all libraries.\")\nendif()\n\n#\n# The release mode (CMAKE_BUILD_TYPE=release) defines NDEBUG for\n# the Unix Makefile generator.\n#\n\n# Defines CMAKE_INSTALL_BINDIR, CMAKE_INSTALL_DATADIR, etc ...\nif(WIN32 AND NOT USE_MSYSTEM)\n\t# Override some values on Windows, to match the existing\n\t# convention of installing everything to a single root folder.\n\tset(CMAKE_INSTALL_BINDIR \".\")\n\tset(CMAKE_INSTALL_LIBDIR \".\")\n\tset(CMAKE_INSTALL_INCLUDEDIR \"include\")\n\tset(CMAKE_INSTALL_DATADIR \".\")\n\tset(CMAKE_INSTALL_DOCDIR \".\")\nendif()\ninclude(GNUInstallDirs)\n\nset(PROJECT_INSTALL_INCLUDEDIR \"${CMAKE_INSTALL_INCLUDEDIR}/${PROJECT_NAME}\")\n\n# Make sure our executables can load our libraries if we install into\n# a non-default directory on Unix-like systems other than macOS.\n# https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/RPATH-handling\nset(LIBRARY_INSTALL_RPATH \"${CMAKE_INSTALL_RPATH}\")\nset(EXECUTABLE_INSTALL_RPATH \"${CMAKE_INSTALL_RPATH}\")\nset(EXTCAP_INSTALL_RPATH \"${CMAKE_INSTALL_RPATH}\")\nif(NOT (WIN32 OR APPLE OR USE_STATIC))\n\t# Try to set a RPATH for installed binaries if the library directory is\n\t# not already included in the default search list.\n\tlist(FIND CMAKE_C_IMPLICIT_LINK_DIRECTORIES \"${CMAKE_INSTALL_FULL_LIBDIR}\" IS_SYSTEM_DIR)\n\tif(IS_SYSTEM_DIR EQUAL -1)\n\t\t# Some systems support $ORIGIN in RPATH to enable relocatable\n\t\t# binaries. In other cases, only absolute paths can be used.\n\t\t# https://www.lekensteyn.nl/rpath.html\n\t\t#\n\t\t# Also note that some systems (notably those using GNU libc)\n\t\t# silently ignore $ORIGIN in RPATH for binaries that are\n\t\t# setuid root or use privileged capabilities.\n\t\t#\n\t\tif(CMAKE_SYSTEM_NAME MATCHES \"^(Linux|SunOS|FreeBSD)$\")\n\t\t\tset(_enable_rpath_origin TRUE)\n\t\telse()\n\t\t\tset(_enable_rpath_origin FALSE)\n\t\tendif()\n\n\t\t# Provide a knob to optionally force absolute rpaths,\n\t\t# to support old/buggy systems and as a user preference\n\t\t# for hardening.\n\t\t# XXX Should this be a CMake option?\n\t\tset(ENABLE_RPATH_ORIGIN ${_enable_rpath_origin} CACHE BOOL\n\t\t\t\"Use $ORIGIN with INSTALL_RPATH\")\n\t\tmark_as_advanced(ENABLE_RPATH_ORIGIN)\n\n\t\tif(ENABLE_RPATH_ORIGIN)\n\t\t\tset(LIBRARY_INSTALL_RPATH     \"$ORIGIN\")\n\t\t\tset(EXECUTABLE_INSTALL_RPATH  \"$ORIGIN/../${CMAKE_INSTALL_LIBDIR}\")\n\t\t\tset(EXTCAP_INSTALL_RPATH      \"$ORIGIN/../..\")\n\t\telse()\n\t\t\tset(LIBRARY_INSTALL_RPATH     \"${CMAKE_INSTALL_FULL_LIBDIR}\")\n\t\t\tset(EXECUTABLE_INSTALL_RPATH  \"${CMAKE_INSTALL_FULL_LIBDIR}\")\n\t\t\tset(EXTCAP_INSTALL_RPATH      \"${CMAKE_INSTALL_FULL_LIBDIR}\")\n\t\tendif()\n\t\t# Include non-standard external libraries by default in RPATH.\n\t\tif(NOT DEFINED CMAKE_INSTALL_RPATH_USE_LINK_PATH)\n\t\t\tset(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)\n\t\tendif()\n\tendif()\nendif()\n\n# Ensure that executables in the build directory always have the same RPATH.\n# This ensures relocatable binaries and reproducible builds (invariant of the\n# build directory location). (Requires CMake 3.14)\nset(CMAKE_BUILD_RPATH_USE_ORIGIN ON)\n\nif(MSVC)\n    # Linking with wsetargv.obj enables \"wildcard expansion\" of\n    # command-line arguments.\n    set(WILDCARD_OBJ wsetargv.obj)\nendif()\n\ninclude(CheckSymbolExists)\n\n#\n# Large file support on UN*X, a/k/a LFS.\n#\n# On Windows, we require _fseeki64() and _ftelli64().  Visual\n# Studio has had supported them since Visual Studio 2005/MSVCR80,\n# and we require newer versions, so we know we have them.\n#\nif(NOT MSVC)\n\tinclude(FindLFS)\n\tif(LFS_FOUND)\n\t\t#\n\t\t# Add the required #defines.\n\t\t#\n\t\tadd_definitions(${LFS_DEFINITIONS})\n\tendif()\n\n\t#\n\t# Check for fseeko as well.\n\t#\n\tinclude(FindFseeko)\n\tif(FSEEKO_FOUND)\n\t\tset(HAVE_FSEEKO ON)\n\n\t\t#\n\t\t# Add the required #defines.\n\t\t#\n\t\tadd_definitions(${FSEEKO_DEFINITIONS})\n\tendif()\nendif()\n\n# Banner shown at top right of Qt welcome screen.\nif(DEFINED ENV{WIRESHARK_VERSION_FLAVOR})\n\tset(VERSION_FLAVOR \"$ENV{WIRESHARK_VERSION_FLAVOR}\")\nelse()\n\tset(VERSION_FLAVOR \"Development Build\")\nendif()\n\n# Used in .rc files and manifests\nset(MANIFEST_PROCESSOR_ARCHITECTURE ${WIRESHARK_TARGET_PLATFORM})\nif (MANIFEST_PROCESSOR_ARCHITECTURE MATCHES \"x64\")\n\tset(MANIFEST_PROCESSOR_ARCHITECTURE \"amd64\")\nendif()\nset(RC_VERSION ${PROJECT_MAJOR_VERSION},${PROJECT_MINOR_VERSION},${PROJECT_PATCH_VERSION},${PROJECT_BUILD_VERSION})\nset(STRATOSHARK_RC_VERSION ${STRATOSHARK_MAJOR_VERSION},${STRATOSHARK_MINOR_VERSION},${PROJECT_PATCH_VERSION},${STRATOSHARK_BUILD_VERSION})\n\nmessage(STATUS \"V: ${PROJECT_VERSION}, MaV: ${PROJECT_MAJOR_VERSION}, MiV: ${PROJECT_MINOR_VERSION}, PL: ${PROJECT_PATCH_VERSION}, EV: ${PROJECT_VERSION_EXTENSION}.\")\n\ninclude(UseLemon)\ninclude(UseMakePluginReg)\ninclude(UseMakeTaps)\ninclude(UseExecutableResources)\ninclude(UseAsn2Wrs)\n\n# The following snippet has been taken from\n# https://github.com/USESystemEngineeringBV/cmake-eclipse-helper/wiki/HowToWorkaroundIndexer\n# The eclipse indexer otherwise assumes __cplusplus=199711L which will lead to broken\n# lookup tables for the epan libraries\n# Check if CXX flags have been set to c++11 -> Setup Eclipse Indexer correctly!\n# Also setup the project slightly different\nif(CMAKE_EXTRA_GENERATOR MATCHES \"Eclipse CDT4\")\n\tSET(CXX_ENABLED 0)\n\tLIST(LENGTH CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS LIST_LEN)\n\tif(LIST_LEN GREATER 0)\n\t\tSET(CXX_ENABLED 1)\n\tendif()\n\tSET(C_ENABLED 0)\n\tLIST(LENGTH CMAKE_EXTRA_GENERATOR_C_SYSTEM_DEFINED_MACROS LIST_LEN)\n\tif(LIST_LEN GREATER 0)\n\t\tSET(C_ENABLED 1)\n\tendif()\n\tif(C_ENABLED EQUAL 1 AND CXX_ENABLED EQUAL 1)\n\t\t# Combined project (C and CXX). This will confuse the indexer. For that reason\n\t\t# we unsert set the __cplusplus variable for the indexer\n\t\tlist(FIND CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS \"__cplusplus\" GEN_MACRO_INDEX)\n\t\tif(GEN_MACRO_INDEX GREATER -1)\n\t\t\tlist(REMOVE_AT CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS ${GEN_MACRO_INDEX})\n\t\t\tlist(REMOVE_AT CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS ${GEN_MACRO_INDEX})\n\t\tendif()\n\t\tSET(CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS ${CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS} CACHE INTERNAL \"\")\n\telseif((CXX_ENABLED EQUAL 1) AND (CMAKE_CXX_FLAGS MATCHES \".*-std=c\\\\+\\\\+11.*\"))\n\t\t#add_definitions (-D__cplusplus=201103L)\n\t\t# CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS\n\t\tlist(FIND CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS \"199711L\" GEN_MACRO_INDEX)\n\t\tif(GEN_MACRO_INDEX GREATER -1)\n\t\t\tlist(REMOVE_AT CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS ${GEN_MACRO_INDEX})\n\t\t\tlist(INSERT CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS ${GEN_MACRO_INDEX} \"201103L\")\n\t\t\tSET(CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS ${CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS} CACHE INTERNAL \"\")\n\t\tendif()\n\tendif()\nendif()\n\ninclude_directories(\n\t${CMAKE_BINARY_DIR}\n\t${CMAKE_SOURCE_DIR}\n\t${CMAKE_SOURCE_DIR}/include\n)\n\nif( DUMPCAP_INSTALL_OPTION STREQUAL \"suid\" )\n\tset( DUMPCAP_SETUID \"SETUID\" )\nelse()\n\tset( DUMPCAP_SETUID )\nendif()\nif( NOT CMAKE_SYSTEM_NAME STREQUAL \"Linux\" AND\n\tDUMPCAP_INSTALL_OPTION STREQUAL \"capabilities\" )\n\tmessage( WARNING \"Capabilities are only supported on Linux\" )\n\tset( DUMPCAP_INSTALL_OPTION )\nendif()\n\nset(OSS_FUZZ OFF CACHE BOOL \"Whether building for oss-fuzz\")\nmark_as_advanced(OSS_FUZZ)\nif(OSS_FUZZ)\n\tif(ENABLE_FUZZER)\n\t\t# In oss-fuzz mode, the fuzzing engine can be afl or libFuzzer.\n\t\tmessage(FATAL_ERROR \"Cannot force libFuzzer when using oss-fuzz\")\n\tendif()\n\t# Must not depend on external dependencies so statically link all libs.\n\tset(USE_STATIC ON)\nendif()\n\nif(USE_STATIC)\n\tset(CMAKE_FIND_LIBRARY_SUFFIXES \".a\")\nendif()\n\n#\n# Linking can consume a lot of memory, especially when built with ASAN and\n# static libraries (like oss-fuzz) or Debug mode. With Ninja, the number of\n# parallel linker processes is constrained by job parallelism (-j), but this can\n# be reduced further by setting \"job pools\" to a lower number.\n#\nif(CMAKE_MAKE_PROGRAM MATCHES \"ninja\" AND OSS_FUZZ)\n\t# Assume oss-fuzz linker jobs do not require more than 1.2G per task\n\tset(per_job_memory_mb 1200)\n\tcmake_host_system_information(RESULT total_memory_mb QUERY TOTAL_PHYSICAL_MEMORY)\n\tmath(EXPR parallel_link_jobs \"${total_memory_mb} / ${per_job_memory_mb}\")\n\tif(parallel_link_jobs LESS 1)\n\t\tset(parallel_link_jobs 1)\n\tendif()\n\tset_property(GLOBAL APPEND PROPERTY JOB_POOLS link_job_pool=${parallel_link_jobs})\n\tset(CMAKE_JOB_POOL_LINK link_job_pool)\n\tmessage(STATUS \"Ninja job pool size: ${parallel_link_jobs}\")\nendif()\n\n# Always enable position-independent code when compiling, even for\n# executables, so you can build position-independent executables.\n# -pie is added below for non-MSVC, but requires objects to be built with\n# -fPIC/-fPIE (so set CMAKE_POSITION_INDEPENDENT_CODE to enable that).\nset(CMAKE_POSITION_INDEPENDENT_CODE ON)\n\n# Preprocessor definitions common to all compilers\nset_property(DIRECTORY\n\tPROPERTY COMPILE_DEFINITIONS\n\t\t\"G_DISABLE_DEPRECATED\"\n\t\t\"G_DISABLE_SINGLE_INCLUDES\"\n\t\t$<$<OR:$<BOOL:${ENABLE_DEBUG}>,$<CONFIG:Debug>>:WS_DEBUG>\n\t\t$<$<OR:$<AND:$<BOOL:${ENABLE_DEBUG}>,$<BOOL:${ENABLE_DEBUG_UTF_8}>>,$<CONFIG:Debug>>:WS_DEBUG_UTF_8>\n\t\t$<$<BOOL:${ENABLE_ASSERT}>:ENABLE_ASSERT>\n)\n\nif(WIN32)\n\t#\n\t# NOTE: Because of the way Qt moc is including \"config.h\" (not as the\n\t# first header) this *MUST* be defined on the command line to precede\n\t# every included header and not trigger symbol redefinition errors.\n\t#\n\tadd_definitions(\n\t\t-DWIN32_LEAN_AND_MEAN\n\t\t#\n\t\t# Use Unicode in Windows runtime functions.\n\t\t#\n\t\t-DUNICODE\n\t\t-D_UNICODE\n\t\t#\n\t\t# NOMINMAX keeps windows.h from defining \"min\" and \"max\" via windef.h.\n\t\t# This avoids conflicts with the C++ standard library.\n\t\t#\n\t\t-DNOMINMAX\n\t)\nendif()\n\nif(MINGW)\n\tadd_definitions(\n\t\t#\n\t\t# Enable POSIX APIs. This will switch stdio to ANSI C functions and\n\t\t# enable C99 conformant vsnprintf() among other things.\n\t\t#\n\t\t-D_POSIX\n\t)\n\tlist(APPEND CMAKE_REQUIRED_DEFINITIONS -D_POSIX)\nendif()\n\nif( CMAKE_C_COMPILER_ID MATCHES \"MSVC\")\n\tif (MSVC_VERSION LESS \"1928\")\n\t\tmessage(FATAL_ERROR \"Microsoft Visual Studio 2019 version 16.8 or later is required\")\n\tendif()\n\tif (MSVC_VERSION GREATER_EQUAL \"2000\")\n\t\tmessage(FATAL_ERROR \"You are using an unsupported version of MSVC\")\n\tendif()\n\n\tadd_definitions(\n\t\t/D_CRT_SECURE_NO_DEPRECATE\n\t\t# -DPSAPI_VERSION=1                 Programs that must run on earlier versions of Windows as well as Windows 7 and later\n\t\t#                                   versions should always call this function as GetProcessMemoryInfo. To ensure correct\n\t\t#                                   resolution of symbols, add Psapi.lib to the TARGETLIBS macro and compile the program\n\t\t#                                   with -DPSAPI_VERSION=1.To use run-time dynamic linking, load Psapi.dll.\n\t\t#                                   https://docs.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getprocessmemoryinfo\n\t\t# -D_ALLOW_KEYWORD_MACROS           For VS2012 onwards the, C++ STL does not permit macro redefinitions of keywords\n\t\t#                                   (see https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2012/bb531344(v=vs.110))\n\t\t#                                   This definition prevents the complaint about the redefinition of inline by WinPCap\n\t\t#                                   in pcap-stdinc.h when compiling C++ files, e.g. the Qt UI\n\t\t/DPSAPI_VERSION=1\n\t\t/D_ALLOW_KEYWORD_MACROS\n\t\t# Disable deprecation of POSIX function names.\n\t\t# https://stackoverflow.com/questions/37845163/what-is-the-purpose-of-microsofts-underscore-c-functions\n\t\t/D_CRT_NONSTDC_NO_WARNINGS\n\t)\n\n\tif(NOT WIRESHARK_TARGET_PLATFORM STREQUAL \"x64\")\n\t\tadd_definitions(\"/D_BIND_TO_CURRENT_CRT_VERSION=1\")\n\tendif()\n\n\t# TODO: Re-enable /W3. It was disabled for a year and some warnings crept\n\t# in that will fail with /Wx.\n\tset(LOCAL_CFLAGS\n\t\t/MP\n\t\t/W3\n\t)\n\n\tset(WS_LINK_FLAGS \"/LARGEADDRESSAWARE /MANIFEST:NO /INCREMENTAL:NO /RELEASE\")\n\n\t# To do: Add /external:... See https://devblogs.microsoft.com/cppblog/broken-warnings-theory/\n\t#\n\t# /diagnostics:caret                Place a caret under compilation issues similar to\n\t#                                   Clang and gcc.\n\t# /Zo                               Enhanced debugging of optimised code\n\t# /utf-8                            Set Source and Executable character sets to UTF-8\n\t#                                   VS2015(MSVC14): On by default when /Zi or /Z7 used.\n\t# /guard:cf                         Control Flow Guard (compile and link).\n\t#                                   See https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard\n\t#                                   Note: This requires CMake 3.9.0 or newer.\n\t#                                   https://gitlab.kitware.com/cmake/cmake/commit/f973d49ab9d4c59b93f6dac812a94bb130200836\n\t# /Qspectre                         Speculative execution attack mitigation\n\t#                                   See https://devblogs.microsoft.com/cppblog/spectre-mitigations-in-msvc/\n\tlist(APPEND LOCAL_CFLAGS /diagnostics:caret /Zo /utf-8 /guard:cf)\n\tset(WS_LINK_FLAGS \"${WS_LINK_FLAGS} /guard:cf\")\n\tset(WS_LINK_FLAGS \"${WS_LINK_FLAGS} /STACK:0x800000\")\n\t# /Qspectre depends on the optional \"Microsoft.VisualStudio.Component...Spectre\" components,\n\t# so we need to test for its availability.\n\tset(WIRESHARK_COMMON_FLAGS /Qspectre)\n\n\tif(ENABLE_CODE_ANALYSIS)\n\t\t# We should probably add a code_analysis.props file and use it to set\n\t\t# CAExcludePath, otherwise we trigger on Qt's headers:\n\t\t# https://stackoverflow.com/questions/59669026/how-to-add-property-to-affect-code-analysis-in-cmake\n\t\t# https://gitlab.kitware.com/cmake/cmake/-/issues/19682\n\t\t# For now, we set CAExcludePath=C:\\Qt;%include% in the Visual Studio\n\t\t# Code Analys builder's environment.\n\t\tlist(APPEND LOCAL_CFLAGS\n\t\t\t/analyze:WX-\n\t\t\t/analyze:log:format:sarif\n\t\t\t)\n\tendif()\n\n\t# Additional compiler warnings to be treated as \"Level 3\"\n\t# when compiling Wireshark sources. (Selected from \"level 4\" warnings).\n\t## 4295: array is too small to include a terminating null character\n\t## 4100: unreferenced formal parameter\n\t## 4189: local variable is initialized but not referenced\n\t# Disable warnings about use of flexible array members:\n\t## 4200: nonstandard extension used : zero-sized array in struct/union\n\tlist(APPEND LOCAL_CFLAGS /w34295 /w34100 /w34189 /wd4200)\n\n\t# MSVC 14.28 + C11 enables C5105, but older Windows SDKs aren't completely compatible.\n\t# Windows SDK 10.0.17763.0 generates syntax errors with C11 enabled.\n\t# The variable CMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION does not work with the Ninja generator. Presumably it requires a VS generator.\n\tif (CMAKE_GENERATOR MATCHES \"Visual Studio\")\n\t\tif (CMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION VERSION_LESS 10.0.18362.0)\n\t\t\tmessage(FATAL_ERROR \"Windows SDK ${CMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION} doesn't support C11. Please make sure you're using 10.0.20348.0 or later.\")\n\t\tendif()\n\t\t# Windows SDK 10.0.18362.0 to 10.0.19041.685 generate warning C5105 with C11 enabled.\n\t\tif(CMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION VERSION_LESS 10.0.20348.0)\n\t\t\tmessage(WARNING \"Windows SDK ${CMAKE_VS_WINDOWS_TARGET_PLATFORM_VERSION} doesn't support C11. Please make sure you're using 10.0.20348.0 or later.\")\n\t\t\t## 5105: macro expansion producing 'defined' has undefined behavior\n\t\t\tlist(APPEND LOCAL_CFLAGS /wd5105)\n\t\tendif()\n\tendif()\n\n\t# We've matched these to specific compiler versions using the\n\t# checks above. There's no need to pass them to check_c_compiler_flag\n\t# or check_cxx_compiler_flag, which can be slow.\n\tstring(REPLACE \";\" \" \" _flags \"${LOCAL_CFLAGS}\")\n\tset(CMAKE_C_FLAGS \"${_flags} ${CMAKE_C_FLAGS}\")\n\tset(CMAKE_CXX_FLAGS \"${_flags} ${CMAKE_CXX_FLAGS}\")\n\nelse() # ! MSVC\n\tif(APPLE)\n\t\t# MIN_MACOS_VERSION is used to set LSMinimumSystemVersion\n\t\t# in Info.plist, so start with something low.\n\t\tset(MIN_MACOS_VERSION 10.13)\n\t\tif(CMAKE_OSX_DEPLOYMENT_TARGET)\n\t\t\tif(CMAKE_OSX_DEPLOYMENT_TARGET VERSION_LESS MIN_MACOS_VERSION)\n\t\t\t\tmessage(FATAL_ERROR \"We don't support building for macOS < ${MIN_MACOS_VERSION}\")\n\t\t\tendif()\n\t\t\tset(MIN_MACOS_VERSION ${CMAKE_OSX_DEPLOYMENT_TARGET})\n\t\tendif()\n\tendif()\n\n\t#\n\t# NOTE: Adding new warnings is a policy decision that can have far-reaching\n\t# implications for the project and each developers workflow. Modern\n\t# C compilers are on a race to add new warnings, not always sensibly.\n\t# They are opt-in so take a moment to fully consider the implications\n\t# of enabling the latest shiny new warning.\n\t# If in doubt ask on the Wireshark developer list (recommended).\n\t#\n\tlist(APPEND WIRESHARK_COMMON_FLAGS\n\t\t#\n\t\t### Flags common to C and C++ ###\n\t\t#\n\t\t# -O<X> and -g get set by the CMAKE_BUILD_TYPE\n\t\t-Wall\n\t\t-Wextra\n\t\t-Wformat\n\t\t-Wformat=2\n\t\t-Wtrampolines\t\t\t# Enable warnings about trampolines that require executable stacks\n\t\t-Wbidi-chars=any\n\t\t-Wpointer-arith\n\t\t-Wformat-security\n\t\t-fexcess-precision=fast\t# GCC-only\n\t\t-Wvla\n\t\t-Wattributes\n\t\t-Wpragmas\t\t# Clang-only\n\t\t-Wheader-guard\t\t# Clang-only\n\t\t-Wcomma\t\t\t# Clang-only\n\t\t-Wshorten-64-to-32\t# Clang-only\n\t\t-Wredundant-decls\n\t\t-Wunreachable-code\t# Clang-only\n\t\t-Wdocumentation\t\t# Clang-only\n\t\t-Wlogical-op\t\t# GCC-only\n\n\t\t# Run-time protections mechanisms\n\t\t-fstrict-flex-arrays=3\t\t\t# Consider a trailing array in a struct as a flexible array if declared as []\n\t\t-fstack-clash-protection\t\t# Increased reliability of stack overflow detection\n\t\t-fcf-protection=full\t\t# Enable control flow protection to counter Return Oriented Programming (ROP) and Jump Oriented Programming (JOP) attacks on many x86 architectures\n\t\t-mbranch-protection=standard\t# Enable branch protection to counter Return Oriented Programming (ROP) and Jump Oriented Programming (JOP) attacks on AArch64\n\t\t-D_GLIBCXX_ASSERTIONS\t\t\t\t# Precondition checks for C++ standard library calls. Can impact performance.\n\t\t-fstack-protector-strong\t\t\t# Stack smashing protector\n\t\t-fno-delete-null-pointer-checks\t\t# Force retention of null pointer checks\n\t\t# The above used to fail on macOS El Capitan clang (see below in PEDANTIC) Does it work now?\n\t\t-fno-strict-overflow\t\t\t# Defines signed overflow as wrapping on gcc and clang, prevents optimizations that assume overflow never happens\n\t\t-fno-strict-aliasing\t\t\t\t# Do not assume strict aliasing\n\t\t-ftrivial-auto-var-init\t\t\t# Perform trivial auto variable initialization\n\t\t-fexceptions\t\t\t\t\t# Enable exception propagation to harden multi-threaded C code\n\n\t\t#\n\t\t# Disable errors unconditionally for some static analysis warnings\n\t\t# that are dormant at lower optimizations levels or active only in\n\t\t# bleeding edge versions of a compiler and possibly also\n\t\t# prone to false positives and compiler bugs. This is\n\t\t# a big nuisance because the warning is dormant and a low\n\t\t# priority target for action. That is very disruptive\n\t\t# with -Werror enabled (the default on the master branch).\n\t\t#\n\t\t#-Wno-error=stringop-overflow=\n\t\t#\n\t\t# XXX Now that we have a CI job with Release build type (using\n\t\t# -O3 optimization level) the dormancy issue should be ameliorated\n\t\t# so comment out these exceptions to re-evaluate the impact.\n\t\t#-Wno-error=maybe-uninitialized\n\t\t#-Wno-error=alloc-size-larger-than=\n\t\t#\n\t\t# Updating external dependencies can introduce new deprecations.\n\t\t# Also fixing new internal deprecations takes time.\n\t\t# We want to be able to build with -Werror in that case. New\n\t\t# code should not introduce new deprecations in any case.\n\t\t#\n\t\t#-Wno-error=deprecated-declarations\n\t)\n\n\tif (CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n\t\t# Avoid \"argument unused during compilation\" warnings for\n\t\t# -fstack-clash-protection and -mbranch-protection=standard\n\t\tlist(APPEND WIRESHARK_COMMON_FLAGS -Qunused-arguments)\n\tendif()\n\n\tif(NOT CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n\t\t# _FORTIFY_SOURCE requires -O1 or higher, and the Debug\n\t\t# build type has no optimization\n\t\tif((CMAKE_C_COMPILER_ID STREQUAL \"GNU\" AND CMAKE_C_COMPILER_VERSION VERSION_GREATER_EQUAL \"12.0\") OR\n\t\t   (CMAKE_C_COMPILER_ID MATCHES \"Clang\" AND CMAKE_C_COMPILER_VERSION VERSION_GREATER_EQUAL \"9.0\"))\n\t\t\t# On some gcc < 12.0, test_compiler_flag will report that\n\t\t\t# -D_FORTIFY_SOURCE=3 is valid, but actually trying to compile\n\t\t\t# with it will give a warning that it has the same effect as\n\t\t\t# -D_FORTIFY_SOURCE=2\n\t\t\tlist(APPEND WIRESHARK_COMMON_FLAGS\n\t\t\t-U_FORTIFY_SOURCE\t# Run-time buffer overflow detection. For dist like Ubuntu, U_FORTIFY_SOURCE must be input before D_FORTIFY_SOURCE\n\t\t\t-D_FORTIFY_SOURCE=3\t\t\t\t# Fortify sources with compile- and run-time checks for unsafe libc usage and buffer overflows. Requires -O1 or higher\n\t\t\t)\n\t\tendif()\n\tendif()\n\n\t# test_compiler_flag doesn't seem to test that a flag is supported on\n\t# a cross-compiled target, only for the native architecture. (Thus\n\t# conversely it does work to verify that -mbranch-protection=standard\n\t# doesn't work on x64 when compiling natively.)\n\t# TODO: Check that this approach works.\n\t#if(NOT CMAKE_CROSSCOMPILING)\n\t#\tlist(APPEND WIRESHARK_COMMON_FLAGS\n\t#\t-fhardened\t\t\t\t\t# Enable pre-determined set of hardening options in GCC. Currently, -fhardened is only supported on GNU/Linux targets\n\t#\t)\n\t#endif()\n\n\tif((NOT ENABLE_ASAN) AND (NOT ENABLE_TSAN) AND (NOT ENABLE_UBSAN) AND (NOT DISABLE_FRAME_LARGER_THAN_WARNING))\n\t\t#\n\t\t# Only do this if none of ASan, TSan, and UBSan are\n\t\t# enabled; the instrumentation they add increases\n\t\t# the stack usage - we only care about stack\n\t\t# usage in normal operation.\n\t\t#\n\t\tlist(APPEND WIRESHARK_COMMON_FLAGS\n\t\t\t-Wframe-larger-than=32768\n\t\t)\n\tendif()\n\n\tlist(APPEND WIRESHARK_C_ONLY_FLAGS\n\t\t#\n\t\t### Flags for C only ###\n\t\t#\n\t\t#\n\t\t# XXX - some versions of GCC, including the one in at\n\t\t# least some Xcode versions that come with Mac OS X\n\t\t# 10.5, complain about variables in function and\n\t\t# function pointer *declarations* shadowing other\n\t\t# variables.  The autoconf script checked for that; we\n\t\t# don't.\n\t\t-Wshadow\n\t\t-Wold-style-definition\n\t\t-Wstrict-prototypes\n\t\t-Wincompatible-pointer-types\n\t\t-Wint-conversion\n\t)\n\n\t#\n\t# The universal zero initializer (in C: struct s x = { 0 };) for\n\t# structures with multiple members is perfectly legal, but some older\n\t# compilers warn about it. Silence those older compilers.\n\t#\n\tif((CMAKE_C_COMPILER_ID STREQUAL \"GNU\" AND CMAKE_C_COMPILER_VERSION VERSION_LESS \"5.1\") OR\n\t   (CMAKE_C_COMPILER_ID STREQUAL \"Clang\" AND CMAKE_C_COMPILER_VERSION VERSION_LESS \"6.0\") OR\n\t   (CMAKE_C_COMPILER_ID STREQUAL \"AppleClang\" AND CMAKE_C_COMPILER_VERSION VERSION_LESS \"12.0\"))\n\t\tif(NOT CMAKE_C_COMPILER_ID STREQUAL \"GNU\" OR CMAKE_C_COMPILER_VERSION VERSION_LESS \"5.0\")\n\t\t\tlist(APPEND WIRESHARK_C_ONLY_FLAGS -Wno-missing-field-initializers)\n\t\tendif()\n\t\t# Silence warnings for initialization of nested structs like\n\t\t# struct { struct { int a, b; } s; int c; } v = { 0 };\n\t\tlist(APPEND WIRESHARK_C_ONLY_FLAGS -Wno-missing-braces)\n\tendif()\n\n\tlist(APPEND WIRESHARK_CXX_ONLY_FLAGS\n\t\t#\n\t\t### Flags for C++ only ###\n\t\t#\n\t\t-Wextra-semi\t# Clang-only\n\t)\n\n\t#\n\t# Not all warnings are the same. They fall on a spectrum from \"critical\"\n\t# to \"pedantic nonsense\". These are warnings that realistically are worth\n\t# fixing eventually.\n\t# TODO https://gitlab.com/wireshark/wireshark/-/issues/19995\n\t#\n\tif(ENABLE_TODO_WARNINGS)\n\t\tlist(APPEND WIRESHARK_COMMON_FLAGS\n\t\t\t#\n\t\t\t# All the registration functions block these for now.\n\t\t\t#\n\t\t\t-Wmissing-prototypes\n\t\t\t-Wmissing-declarations\n\n\t\t\t-Wconversion\n\t\t\t-Wsign-conversion\n\t\t\t#\n\t\t\t# A bunch of \"that might not work on SPARC\" code blocks\n\t\t\t# this one for now; some of it is code that *will* work\n\t\t\t# on SPARC, such as casts of \"struct sockaddr *\" to\n\t\t\t# \"struct sockaddr_in *\", which are required by some\n\t\t\t# APIs such as getifaddrs().\n\t\t\t#\n\t\t\t-Wcast-align\n\t\t)\n\telse()\n\t\tlist(APPEND WIRESHARK_COMMON_FLAGS\n\t\t\t#\n\t\t\t# Converting from g_printf() and g_snprintf() to stdio.h turns\n\t\t\t# up many of these warnings. They will have to be handled later.\n\t\t\t# It can be a lot of work to fix properly and none of them\n\t\t\t# seem to flag very interesting issues.\n\t\t\t#\n\t\t\t-Wno-format-truncation # Enabled with -Wall\n\n\t\t\t-Wno-format-nonliteral\t# Enabled with -Wformat=2\n\t\t)\n\t\tlist(APPEND WIRESHARK_C_ONLY_FLAGS\n\t\t\t-Wno-pointer-sign # Enabled with -Wall\n\t\t)\n\tendif()\n\n\t#\n\t# These are not enabled by default, because the warnings they\n\t# produce are very hard or impossible to eliminate.\n\t#\n\tif(ENABLE_PEDANTIC_COMPILER_WARNINGS)\n\t\tlist(APPEND WIRESHARK_COMMON_FLAGS\n\t\t\t# The following are for C and C++\n\t\t\t-Wpedantic\n\t\t\t-Wno-overlength-strings\n\t\t\t-Wno-long-long\n\t\t\t#\n\t\t\t# As we use variadic macros, we don't want warnings\n\t\t\t# about them, even with -Wpedantic.\n\t\t\t#\n\t\t\t-Wno-variadic-macros\n\t\t\t#\n\t\t\t# Various code blocks this one.\n\t\t\t#\n\t\t\t-Woverflow\n\t\t\t-fstrict-overflow -Wstrict-overflow=4\n\t\t\t#\n\t\t\t# Due to various places where APIs we don't control\n\t\t\t# require us to cast away constness, we can probably\n\t\t\t# never enable this one with -Werror.\n\t\t\t#\n\t\t\t-Wcast-qual\n\t\t\t#\n\t\t\t# Doesn't warn of interesting issues. Usually the\n\t\t\t# duplicated branches are protocol constants that\n\t\t\t# happen to be equal and are relevant for documentation\n\t\t\t# and readability and are trivially optimized by the\n\t\t\t# compiler.\n\t\t\t#\n\t\t\t-Wduplicated-branches\t\t# GCC-only\n\t\t\t#\n\t\t\t# No longer supported by El Capitan clang on C++\n\t\t\t# XXX - is this one of those where CMake's check\n\t\t\t# doesn't fail, so it won't reject this?\n\t\t\t#\n\t\t\t-fno-delete-null-pointer-checks\n\t\t)\n\n\t\t#\n\t\t# Some loops are safe, but it's hard to convince the compiler of\n\t\t# that. Always disable the warning on GCC 7 due to a bug that\n\t\t# cause lots of false positives.\n\t\t# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81408\n\t\t#\n\t\tif(CMAKE_C_COMPILER_ID STREQUAL \"GNU\" AND NOT CMAKE_C_COMPILER_VERSION MATCHES \"^7\\\\.\")\n\t\t\tlist(APPEND WIRESHARK_COMMON_FLAGS -Wunsafe-loop-optimizations)\n\t\tendif()\n\n\t\tlist(APPEND WIRESHARK_C_ONLY_FLAGS\n\t\t\t# The following are C only, not C++\n\t\t\t#\n\t\t\t# Due to various places where APIs we don't control\n\t\t\t# require us to cast away constness, we can probably\n\t\t\t# never enable this one with -Werror.\n\t\t\t#\n\t\t\t-Wbad-function-cast\n\t\t)\n\n\t\tlist(APPEND WIRESHARK_CXX_ONLY_FLAGS\n\t\t)\n\tendif()\n\n\tif(ENABLE_COMPILER_COLOR_DIAGNOSTICS)\n\t\tif(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n\t\t\tset(WIRESHARK_COMMON_FLAGS ${WIRESHARK_COMMON_FLAGS}\n\t\t\t\t-fcolor-diagnostics\n\t\t\t)\n\t\telseif(CMAKE_C_COMPILER_ID MATCHES \"GNU\")\n\t\t\tset(WIRESHARK_COMMON_FLAGS ${WIRESHARK_COMMON_FLAGS}\n\t\t\t\t-fdiagnostics-color=always\n\t\t\t)\n\t\tendif()\n\tendif()\n\n\tset(WIRESHARK_LD_FLAGS\n\t\t# See also CheckCLinkerFlag.cmake\n\t\t-Wl,--as-needed\n\t\t# -flto\n\t\t# -fwhopr\n\t\t# -fwhole-program\n\t)\nendif() # ! MSVC\n\n# Counterhack to work around some cache magic in CHECK_C_SOURCE_COMPILES\ninclude(CheckCCompilerFlag)\ninclude(CheckCXXCompilerFlag)\n\nif(ENABLE_STATIC)\n\tset(BUILD_SHARED_LIBS 0)\nelse()\n\tset(BUILD_SHARED_LIBS 1)\nendif()\n\nfunction(test_compiler_flag _lang _this_flag _valid_flags_var)\n\tstring(MAKE_C_IDENTIFIER \"${_lang}${_this_flag}_VALID\" _flag_var)\n\tset(_test_flags \"${${_valid_flags_var}} ${_this_flag}\")\n\tif(_lang STREQUAL \"C\")\n\t\tcheck_c_compiler_flag(\"${_test_flags}\" ${_flag_var})\n\telseif(_lang STREQUAL \"CXX\")\n\t\tcheck_cxx_compiler_flag(\"${_test_flags}\" ${_flag_var})\n\telse()\n\t\tmessage(FATAL_ERROR \"Language must be C or CXX\")\n\tendif()\n\tif (${_flag_var})\n\t\tset(${_valid_flags_var} \"${_test_flags}\" PARENT_SCOPE)\n\tendif()\nendfunction()\n\nforeach(THIS_FLAG ${WIRESHARK_COMMON_FLAGS} ${WIRESHARK_C_ONLY_FLAGS})\n\ttest_compiler_flag(C ${THIS_FLAG} ADDED_CMAKE_C_FLAGS)\nendforeach()\nset(CMAKE_C_FLAGS \"${ADDED_CMAKE_C_FLAGS} ${CMAKE_C_FLAGS}\")\n\nforeach(THIS_FLAG ${WIRESHARK_COMMON_FLAGS} ${WIRESHARK_CXX_ONLY_FLAGS})\n\ttest_compiler_flag(CXX ${THIS_FLAG} ADDED_CMAKE_CXX_FLAGS)\nendforeach()\nset(CMAKE_CXX_FLAGS \"${ADDED_CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS}\")\n\n# Strips the source and build directory prefix from the __FILE__ macro to ensure\n# reproducible builds. Supported since GCC 8, Clang support is pending.\nif(CMAKE_C_COMPILER_ID MATCHES \"GNU\" OR CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n\t# If the build dir is within the source dir, CMake will use something\n\t# like ../epan/dfilter/semcheck.c. Map these relative paths in addition\n\t# to CMAKE_BINARY_DIR since compile_commands.json uses absolute paths.\n\tfile(RELATIVE_PATH _relative_source_dir \"${CMAKE_BINARY_DIR}\" \"${CMAKE_SOURCE_DIR}\")\n\tstring(REGEX REPLACE \"/$\" \"\" _relative_source_dir \"${_relative_source_dir}\")\n\n\tcheck_c_compiler_flag(-fmacro-prefix-map=old=new C_fmacro_prefix_map_old_new_VALID)\n\tcheck_cxx_compiler_flag(-fmacro-prefix-map=old=new CXX_fmacro_prefix_map_old_new_VALID)\n\tforeach(_lang C CXX)\n\t\tif(${_lang}_fmacro_prefix_map_old_new_VALID)\n\t\t\tset(_flags CMAKE_${_lang}_FLAGS)\n\t\t\tset(${_flags} \"${${_flags}} -fmacro-prefix-map=\\\"${CMAKE_SOURCE_DIR}/\\\"=\")\n\t\t\tset(${_flags} \"${${_flags}} -fmacro-prefix-map=\\\"${CMAKE_BINARY_DIR}/\\\"=\")\n\t\t\tif(_relative_source_dir MATCHES \"\\\\.\\\\.$\")\n\t\t\t\tset(${_flags} \"${${_flags}} -fmacro-prefix-map=\\\"${_relative_source_dir}/\\\"=\")\n\t\t\tendif()\n\t\tendif()\n\tendforeach()\nendif()\n\ninclude(CMakePushCheckState)\n\nif(ENABLE_ASAN)\n\t# Available since MSVC 2019 version 16.9 (https://gitlab.com/wireshark/wireshark/-/merge_requests/14912 for more details)\n\tcmake_push_check_state()\n\tset(ASAN_FLAG \"-fsanitize=address\")\n\tset(CMAKE_REQUIRED_FLAGS ${ASAN_FLAG})\n\tif(MSVC)\n\t\tmessage(NOTICE \"ENABLE_ASAN was requested. Checking if ASAN is supported requires SPECTRE-mitigation to be disabled globally impacting all build types.\")\n\t\tmessage(NOTICE \"If ASAN is supported, then it is re-enabled selectively depending on the build types.\")\n\t\tset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} /Qspectre-\")\n\t\tset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /Qspectre-\")\n\tendif()\n\tcheck_c_compiler_flag(${ASAN_FLAG} C__fsanitize_address_VALID)\n\tcheck_cxx_compiler_flag(${ASAN_FLAG} CXX__fsanitize_address_VALID)\n\tcmake_pop_check_state()\n\tif(NOT C__fsanitize_address_VALID OR NOT CXX__fsanitize_address_VALID)\n\t\tmessage(FATAL_ERROR \"ENABLE_ASAN was requested, but not supported!\")\n\tendif()\n\tif(MSVC)\n\t\tmessage(NOTICE \"ASAN is supported.\")\n\t\tif(ENABLE_ASAN_WITH_SPECTRE)\n\t\t\tmessage(NOTICE \"ENABLE_ASAN_WITH_SPECTRE was requested.\")\n\t\t\tmessage(NOTICE \"For Debug and RelWithDebInfo, SPECTRE-mitigation has been re-enabled and ASAN has been enabled too.\")\n\t\t\tadd_compile_options(\"$<$<CONFIG:Debug>:/Qspectre>\" \"$<$<CONFIG:Debug>:${ASAN_FLAG}>\")\n\t\t\tadd_compile_options(\"$<$<CONFIG:RelWithDebInfo>:/Qspectre>\" \"$<$<CONFIG:RelWithDebInfo>:${ASAN_FLAG}>\")\n\t\t\tset(CPU ${WIRESHARK_TARGET_PLATFORM})\n\t\t\tif (${CPU} MATCHES \"win32\")\n\t\t\t\tset(CPU x86)\n\t\t\tendif()\n\t\t\tadd_link_options(\"$<$<CONFIG:Debug>:/libpath:$ENV{VCToolsInstallDir}lib\\\\spectre\\\\${CPU}>\" \"$<$<CONFIG:Debug>:/libpath:$ENV{VCToolsInstallDir}lib\\\\${CPU}>\")\n\t\t\tadd_link_options(\"$<$<CONFIG:RelWithDebInfo>:/libpath:$ENV{VCToolsInstallDir}lib\\\\spectre\\\\${CPU}>\" \"$<$<CONFIG:RelWithDebInfo>:/libpath:$ENV{VCToolsInstallDir}lib\\\\${CPU}>\")\n\t\telse()\n\t\t\tmessage(NOTICE \"ENABLE_ASAN_WITH_SPECTRE was not requested\")\n\t\t\tmessage(NOTICE \"For Debug and RelWithDebInfo, SPECTRE-mitigation stays disabled and ASAN has been enabled.\")\n\t\t\tadd_compile_options(\"$<$<CONFIG:Debug>:${ASAN_FLAG}>\")\n\t\t\tadd_compile_options(\"$<$<CONFIG:RelWithDebInfo>:${ASAN_FLAG}>\")\n\t\tendif()\n\t\tmessage(NOTICE \"For Release and MinSizeRel, SPECTRE-mitigation has been re-enabled and ASAN has been skipped.\")\n\t\tadd_compile_options(\"$<$<CONFIG:Release>:/Qspectre>\")\n\t\tadd_compile_options(\"$<$<CONFIG:MinSizeRel>:/Qspectre>\")\n\telse()\n\t\tadd_compile_options(${ASAN_FLAG})\n\tendif()\n\tif(MSVC)\n\t\t# Using ASAN makes some of our code require object files with\n\t\t# a 32-bit index to the section table instead of 16-bit.\n\t\t# This makes the .obj files slightly larger (~2%) and makes\n\t\t# it so that Microsoft linkers prior to MSVC 2005 can't read\n\t\t# the files, but those are too old anyway.\n\t\tadd_compile_options(/bigobj)\n\t\t# The Microsoft LINK linker doesn't recognize or need the\n\t\t# ASAN flag, and will give a LNK4044 warning.\n\telse()\n\t\t# Clang/gcc need the flag added to the linker\n\t\t# add_link_options since CMake 3.13 (our minimum)\n\t\tadd_link_options(${ASAN_FLAG})\n\tendif()\nendif()\n\nif(MSVC)\n\tif(NOT ENABLE_ASAN AND ENABLE_ASAN_WITH_SPECTRE)\n\t\tmessage(FATAL_ERROR \"ENABLE_ASAN_WITH_SPECTRE was requested, but without ENABLE_ASAN!\")\n\tendif()\nendif()\n\nif(ENABLE_TSAN)\n\t# Available since Clang >= 3.2 and GCC >= 4.8\n\tcmake_push_check_state()\n\tset(CMAKE_REQUIRED_LIBRARIES \"-fsanitize=thread\")\n\tcheck_c_compiler_flag(-fsanitize=thread C__fsanitize_thread_VALID)\n\tcheck_cxx_compiler_flag(-fsanitize=thread CXX__fsanitize_thread_VALID)\n\tcmake_pop_check_state()\n\tif(NOT C__fsanitize_thread_VALID OR NOT CXX__fsanitize_thread_VALID)\n\t\tmessage(FATAL_ERROR \"ENABLE_TSAN was requested, but not supported!\")\n\tendif()\n\tset(CMAKE_C_FLAGS \"-fsanitize=thread ${CMAKE_C_FLAGS}\")\n\tset(CMAKE_CXX_FLAGS \"-fsanitize=thread ${CMAKE_CXX_FLAGS}\")\n\tset(WS_LINK_FLAGS \"-fsanitize=thread ${WS_LINK_FLAGS}\")\nendif()\n\nif(ENABLE_UBSAN)\n\t# Available since Clang >= 3.3 and GCC >= 4.9\n\tcmake_push_check_state()\n\tset(CMAKE_REQUIRED_LIBRARIES \"-fsanitize=undefined\")\n\tcheck_c_compiler_flag(-fsanitize=undefined C__fsanitize_undefined_VALID)\n\tcheck_cxx_compiler_flag(-fsanitize=undefined CXX__fsanitize_undefined_VALID)\n\tcmake_pop_check_state()\n\tif(NOT C__fsanitize_undefined_VALID OR NOT CXX__fsanitize_undefined_VALID)\n\t\tmessage(FATAL_ERROR \"ENABLE_UBSAN was requested, but not supported!\")\n\tendif()\n\tset(CMAKE_C_FLAGS \"-fsanitize=undefined ${CMAKE_C_FLAGS}\")\n\tset(CMAKE_CXX_FLAGS \"-fsanitize=undefined ${CMAKE_CXX_FLAGS}\")\nendif()\n\nif(ENABLE_LSAN)\n\t# Available since Clang >= 3.4 and GCC >= 4.9\n\tcmake_push_check_state()\n\tset(CMAKE_REQUIRED_LIBRARIES \"-fsanitize=leak\")\n\tcheck_c_compiler_flag(-fsanitize=leak C__fsanitize_leak_VALID)\n\tcheck_cxx_compiler_flag(-fsanitize=leak CXX__fsanitize_leak_VALID)\n\tcmake_pop_check_state()\n\tif(NOT C__fsanitize_leak_VALID OR NOT CXX__fsanitize_leak_VALID)\n\t\tmessage(FATAL_ERROR \"ENABLE_LSAN was requested, but not supported!\")\n\tendif()\n\tset(CMAKE_C_FLAGS \"-fsanitize=leak ${CMAKE_C_FLAGS}\")\n\tset(CMAKE_CXX_FLAGS \"-fsanitize=leak ${CMAKE_CXX_FLAGS}\")\nendif()\n\nif(ENABLE_FUZZER)\n\t# Available since Clang >= 6\n\t# Will enable coverage flags which can be used by the fuzzshark target.\n\tcmake_push_check_state()\n\tset(CMAKE_REQUIRED_LIBRARIES \"-fsanitize=fuzzer-no-link\")\n\tcheck_c_compiler_flag(-fsanitize=fuzzer C__fsanitize_fuzzer_no_link_VALID)\n\tcheck_cxx_compiler_flag(-fsanitize=fuzzer CXX__fsanitize_fuzzer_no_link_VALID)\n\tcmake_pop_check_state()\n\tif(NOT C__fsanitize_fuzzer_no_link_VALID OR NOT CXX__fsanitize_fuzzer_no_link_VALID)\n\t\tmessage(FATAL_ERROR \"ENABLE_FUZZER was requested, but not supported!\")\n\tendif()\n\tset(CMAKE_C_FLAGS \"-fsanitize=fuzzer-no-link ${CMAKE_C_FLAGS}\")\n\tset(CMAKE_CXX_FLAGS \"-fsanitize=fuzzer-no-link ${CMAKE_CXX_FLAGS}\")\nendif()\n\nif(NOT MSVC)\n\t# Disable sanitizers for build-time tools, e.g. lemon\n\tcheck_c_compiler_flag(-fno-sanitize=all C__fno_sanitize_all_VALID)\n\tif(C__fno_sanitize_all_VALID)\n\t\tset(NO_SANITIZE_CFLAGS \"-fno-sanitize=all\")\n\t\tset(NO_SANITIZE_LDFLAGS \"-fno-sanitize=all\")\n\tendif()\nendif()\n\nif(MSVC)\n\tif(ENABLE_VLD)\n\t\tinclude(FindVLD)\n\t\tif(NOT VLD_FOUND)\n\t\t\tmessage(FATAL_ERROR \"ENABLE_VLD was requested, but not found!\")\n\t\tendif()\n\t\tmessage(STATUS \"Enabling Visual Leak Detector in Debug configuration\")\n\t\tset(WS_MSVC_DEBUG_LINK_FLAGS ${VLD_LINK_FLAGS})\n\tendif()\nendif()\n\nset(WERROR_COMMON_FLAGS \"\")\nif(ENABLE_WERROR)\n\tif(CMAKE_C_COMPILER_ID MATCHES \"MSVC\")\n\t\tset(WERROR_COMMON_FLAGS \"/WX\")\n\telse()\n\t\t#\n\t\t# If a warning has been enabled by -Wall or -W,\n\t\t# and have specified -Werror, there appears to be\n\t\t# no way, in Apple's llvm-gcc, to prevent that\n\t\t# particular warning from giving an error - not\n\t\t# with a pragma, not with -Wno-{warning}, and not\n\t\t# with -Wno-error={warning}.\n\t\t#\n\t\t# Therefore, with that compiler, we just disable\n\t\t# -Werror.\n\t\t#\n\t\tif ((NOT APPLE) OR CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n\t\t\tcheck_c_compiler_flag(-Werror WERROR)\n\t\t\tif (WERROR)\n\t\t\t\tset(WERROR_COMMON_FLAGS \"-Werror\")\n\t\t\tendif()\n\t\tendif()\n\tendif()\nendif()\n\n#\n# Try to have the compiler default to hiding symbols, so that only\n# symbols explicitly exported with WS_DLL_PUBLIC will be visible\n# outside (shared) libraries; that way, more UN*X builds will catch\n# failures to export symbols, rather than having that fail only on\n# Windows.\n#\n# We don't need that with MSVC, as that's the default.\n#\nif( NOT CMAKE_C_COMPILER_ID MATCHES \"MSVC\")\n\t#\n\t# Try the GCC-and-compatible -fvisibility-hidden first.\n\t#\n\tcheck_c_compiler_flag(-fvisibility=hidden FVHIDDEN)\n\tif(FVHIDDEN)\n\t\tset(CMAKE_C_FLAGS \"-fvisibility=hidden ${CMAKE_C_FLAGS}\")\n\telse()\n\t\t#\n\t\t# OK, try the Sun^WOracle C -xldscope=hidden\n\t\t#\n\t\tcheck_c_compiler_flag(-xldscope=hidden XLDSCOPEHIDDEN)\n\t\tif(XLDSCOPEHIDDEN)\n\t\t\tset(CMAKE_C_FLAGS \"-xldscope=hidden ${CMAKE_C_FLAGS}\")\n\t\telse()\n\t\t\t#\n\t\t\t# Anything else?\n\t\t\t# If there is anything else, we might want to\n\t\t\t# make a list of options to try, and try them\n\t\t\t# in a loop.\n\t\t\t#\n\t\t\tmessage(WARNING \"Hiding shared library symbols is not supported by the compiler.\"\n\t\t\t\t\" All shared library symbols will be exported.\")\n\t\tendif()\n\tendif()\nendif()\n\ninclude(CheckCLinkerFlag)\n\nif(NOT CMAKE_C_COMPILER_ID MATCHES \"MSVC\" AND NOT OSS_FUZZ)\n\t#\n\t# The -pie linker option produces a position-independent executable.\n\t# Some Linux distributions have this enabled by default in the compiler,\n\t# so setting it here will be superfluous though.\n\t#\n\t# Note that linking with static libraries that are not position\n\t# independent may fail, the user can set CMAKE_EXE_LINKER_FLAGS=-no-pie\n\t# as a workaround.\n\t#\n\tif(CMAKE_VERSION VERSION_LESS \"3.14\")\n\t\tcheck_c_linker_flag(-pie LINK_pie_VALID)\n\t\tif(LINK_pie_VALID)\n\t\t\tset(CMAKE_EXE_LINKER_FLAGS \"-pie ${CMAKE_EXE_LINKER_FLAGS}\")\n\t\tendif()\n\telse()\n\t\tinclude(CheckPIESupported)\n\t\tcheck_pie_supported()\n\tendif()\nendif()\n\nforeach(THIS_FLAG ${WIRESHARK_LD_FLAGS})\n\tstring(MAKE_C_IDENTIFIER \"LINK${THIS_FLAG}_VALID\" _flag_var)\n\tcheck_c_linker_flag(${THIS_FLAG} ${_flag_var})\n\tif (${_flag_var})\n\t\tset(WS_LINK_FLAGS \"${WS_LINK_FLAGS} ${THIS_FLAG}\")\n\tendif()\nendforeach()\nmessage(STATUS \"Linker flags: ${WS_LINK_FLAGS}\")\n\nif(APPLE AND EXISTS /usr/local/opt/gettext)\n\t# GLib on macOS requires libintl. Homebrew installs gettext (and\n\t# libintl) in /usr/local/opt/gettext\n\tinclude_directories(SYSTEM /usr/local/opt/gettext/include)\n\tlink_directories(/usr/local/opt/gettext/lib)\nendif()\n\n# Resets cache variables if the <PackageName>_LIBRARY has become invalid.\n# Call it before a find_package(<PackageName> ...) invocation that uses\n# find_library(<PackageName>_LIBRARY ...).\n#\n# Usage: reset_find_package(<PackageName> [<extra variables to clear>])\nfunction(reset_find_package _package_name)\n\tset(variables\n\t\t# find_library / find_package\n\t\t${_package_name}_LIBRARY\n\t\t${_package_name}_INCLUDE_DIR\n\t\t# mark_as_advanced\n\t\t${_package_name}_LIBRARIES\n\t\t${_package_name}_INCLUDE_DIRS\n\t\t# Others\n\t\t${_package_name}_DLL_DIR\n\t\t${_package_name}_DLLS\n\t\t${_package_name}_DLL\n\t\t${_package_name}_PDB\n\t\t${ARGN}\n\t)\n\tif(NOT ${_package_name}_LIBRARY OR EXISTS ${${_package_name}_LIBRARY})\n\t\t# Cache variable is already missing or cache entry is valid.\n\t\treturn()\n\tendif()\n\tmessage(STATUS \"Package ${_package_name} has changed, clearing cache.\")\n\tforeach(_var IN LISTS variables)\n\t\tunset(${_var} CACHE)\n\tendforeach()\nendfunction()\n\n# ws_find_package(<PackageName>\n#             <CMakeOptions.txt boolean variable>\n#             <cmakeconfig.h.in macro definition>\n#             [remaining find_package() arguments])\nmacro(ws_find_package _package_name _enable_package _package_cmakedefine)\n\tif(${_enable_package})\n\t\t# Clear outdated cache variables if not already.\n\t\treset_find_package(${_package_name})\n\t\tfind_package(${_package_name} ${ARGN})\n\t\tif(${_package_name}_FOUND)\n\t\t\tset(${_package_cmakedefine} 1)\n\t\tendif()\n\tendif()\nendmacro()\n\n# The minimum package list\nfind_package(Git)\nreset_find_package(GLIB2 GLIB2_MAIN_INCLUDE_DIR GLIB2_INTERNAL_INCLUDE_DIR)\nfind_package(GLIB2 \"2.54.0\" REQUIRED)\ninclude_directories(SYSTEM ${GLIB2_INCLUDE_DIRS})\nreset_find_package(GMODULE2)\nfind_package(GMODULE2)\nreset_find_package(GTHREAD2)\nfind_package(GTHREAD2 REQUIRED)\nreset_find_package(GCRYPT GCRYPT_ERROR_LIBRARY)\nfind_package(GCRYPT \"1.8.0\" REQUIRED)\n# C Asynchronous resolver\nreset_find_package(CARES)\nfind_package(CARES \"1.13.0\" REQUIRED)\nif (CARES_VERSION VERSION_GREATER_EQUAL \"1.28.0\")\n\t# Suppress deprecation warnings.\n\tadd_compile_definitions(CARES_NO_DEPRECATED)\nendif ()\nfind_package(LEX REQUIRED)\nreset_find_package(PCRE2 PCRE2_DEBUG_LIBRARY)\nfind_package(PCRE2 REQUIRED)\n\nif (NOT WIN32)\n\tfind_package(Gettext)\n\tfind_package(M REQUIRED)\nendif()\n\nif(BUILD_sshdump OR BUILD_ciscodump OR BUILD_wifidump OR BUILD_sshdig)\n\tset(ENABLE_LIBSSH ON)\nelse()\n\tset(ENABLE_LIBSSH OFF)\nendif()\nws_find_package(LIBSSH ENABLE_LIBSSH HAVE_LIBSSH \"0.8.5\")\n\nws_find_package(PCAP ENABLE_PCAP HAVE_LIBPCAP)\nws_find_package(Systemd BUILD_sdjournal HAVE_SYSTEMD)\n\n# Build one of the Qt GUIs?\nif(BUILD_wireshark OR BUILD_stratoshark)\n\tif(USE_qt6)\n\t\tset(qtver 6)\n\t\tif(DEFINED ENV{WIRESHARK_QT6_PREFIX_PATH})\n\t\t\tlist(APPEND CMAKE_PREFIX_PATH $ENV{WIRESHARK_QT6_PREFIX_PATH})\n\t\tendif()\n\n\t\tset(CMAKE_CXX_STANDARD 17)\n\t\t# Setting CMAKE_CXX_STANDARD is not sufficient with MSVC, see\n\t\t#   https://gitlab.kitware.com/cmake/cmake/-/issues/18837\n\t\t# The below test can be found in Qt6, lib/cmake/Qt6/QtFeature.cmake\n\t\tif(CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\" AND MSVC_VERSION GREATER_EQUAL 1913)\n\t\t\t# Cannot use add_definitions() here because rc.exe does not understand this flag.\n\t\t\t# https://cmake.org/pipermail/cmake/2009-August/031672.html\n\t\t\tset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Zc:__cplusplus\")\n\t\tendif()\n\n\t\tfind_package(Qt6 REQUIRED\n\t\t\tCOMPONENTS\n\t\t\t\tCore\n\t\t\t\tGui\n\t\t\t\tLinguistTools\n\t\t\t\tPrintSupport\n\t\t\t\tWidgets\n\t\t\t\tConcurrent\n\t\t\t\tCore5Compat\n\t\t\tOPTIONAL_COMPONENTS\n\t\t\t\tDBus\n\t\t\t\tMultimedia\n\t\t)\n\n\t\tif (WIN32 AND Qt6Widgets_VERSION VERSION_LESS 6.5.3)\n\t\t\tmessage(WARNING \"Qt 6.5.3 or later is required.\")\n\t\tendif()\n\t\tif (APPLE AND Qt6Widgets_VERSION VERSION_LESS 6.5.3)\n\t\t\tmessage(WARNING \"Qt 6.5.3 or later is required.\")\n\t\tendif()\n\telse(USE_qt6)\n\t\tset(qtver 5)\n\t\tif(DEFINED ENV{WIRESHARK_QT5_PREFIX_PATH})\n\t\t\tlist(APPEND CMAKE_PREFIX_PATH $ENV{WIRESHARK_QT5_PREFIX_PATH})\n\t\tendif()\n\t\tif(APPLE AND EXISTS /usr/local/opt/qt5)\n\t\t\t# Homebrew installs Qt5 (up to at least 5.11.0) in\n\t\t\t# /usr/local/qt5. Ensure that it can be found by CMake\n\t\t\t# since it is not in the default /usr/local prefix.\n\t\t\t# Add it to PATHS so that it doesn't override the\n\t\t\t# CMAKE_PREFIX_PATH environment variable.\n\t\t\t# QT_FIND_PACKAGE_OPTIONS should be passed to find_package,\n\t\t\t# e.g. find_package(Qt5Core ${QT_FIND_PACKAGE_OPTIONS})\n\t\t\tlist(APPEND QT5_FIND_PACKAGE_OPTIONS PATHS /usr/local/opt/qt5)\n\t\tendif()\n\n\t\tset(QT5_PACKAGELIST\n\t\t\tQt5Core\n\t\t\tQt5Gui\n\t\t\tQt5LinguistTools\n\t\t\tQt5PrintSupport\n\t\t\tQt5Widgets\n\t\t\tQt5Concurrent\n\t\t)\n\t\tset(QT5_OPTIONAL_PACKAGELIST\n\t\t\tQt5Multimedia\n\t\t)\n\t\tif(WIN32)\n\t\t\tlist(APPEND QT5_PACKAGELIST Qt5WinExtras)\n\t\tendif()\n\t\tif(NOT WIN32 AND NOT APPLE)\n\t\t\t# DBus is a core component of Qt6, but was an add-on in Qt5.\n\t\t\tlist(APPEND QT5_OPTIONAL_PACKAGELIST Qt5DBus)\n\t\tendif()\n\t\tforeach(_qt5_package IN LISTS QT5_PACKAGELIST)\n\t\t\tfind_package(${_qt5_package} REQUIRED ${QT5_FIND_PACKAGE_OPTIONS})\n\t\t\tlist(APPEND QT5_LIBRARIES ${${_qt5_package}_LIBRARIES})\n\t\t\tlist(APPEND QT5_INCLUDE_DIRS ${${_qt5_package}_INCLUDE_DIRS})\n\t\t\tlist(APPEND QT5_COMPILE_DEFINITIONS ${${_qt5_package}_COMPILE_DEFINITIONS})\n\t\tendforeach()\n\t\tforeach(_qt5_package IN LISTS QT5_OPTIONAL_PACKAGELIST)\n\t\t\tfind_package(${_qt5_package} ${QT5_FIND_PACKAGE_OPTIONS})\n\t\t\tlist(APPEND QT5_LIBRARIES ${${_qt5_package}_LIBRARIES})\n\t\t\tlist(APPEND QT5_INCLUDE_DIRS ${${_qt5_package}_INCLUDE_DIRS})\n\t\t\tlist(APPEND QT5_COMPILE_DEFINITIONS ${${_qt5_package}_COMPILE_DEFINITIONS})\n\t\tendforeach()\n\n\t\tif (Qt5Widgets_VERSION VERSION_LESS 5.15)\n\t\t\tmessage(FATAL_ERROR \"Qt 5.15 or later is required. Qt 6 is recommended.\")\n\t\tendif()\n\n\t\tif(APPLE AND \"/usr/local/opt/qt5/lib/QtCore.framework\" IN_LIST Qt5Core_INCLUDE_DIRS)\n\t\t\t# When qt@6 and qt@5 are both installed via Homebrew,\n\t\t\t# /usr/local/include/QtCore/qvariant.h points to Qt 6 headers.\n\t\t\t# Normally the Headers from `-iframework /usr/local/opt/qt5/lib`\n\t\t\t# should be used, but `-isystem /usr/local/include` (via\n\t\t\t# Libgcrypt and others) seems to prioritized, resulting in use\n\t\t\t# of the Qt6 headers. Resolve this by explicit including Qt5.\n\t\t\tlist(APPEND QT5_INCLUDE_DIRS /usr/local/opt/qt5/include)\n\t\tendif()\n\tendif(USE_qt6)\n\n\tset(QT_FOUND ON)\n\tif(APPLE)\n\t\tws_find_package(Sparkle ENABLE_SPARKLE HAVE_SOFTWARE_UPDATE 2)\n\tendif()\n\tif(Qt6Multimedia_FOUND OR Qt5Multimedia_FOUND)\n\t\tset(QT_MULTIMEDIA_LIB 1)\n\tendif()\n\tif(Qt6DBus_FOUND OR Qt5DBus_FOUND)\n\t\tset(QT_DBUS_LIB 1)\n\tendif()\n\tif(NOT DEFINED MOC_OPTIONS)\n\t\t# Squelch moc verbose \"nothing to do\" output\n\t\tset(MOC_OPTIONS -nn)\n\tendif()\nendif()\n\n# MaxMind DB address resolution\nreset_find_package(MAXMINDDB)\nws_find_package(MaxMindDB BUILD_mmdbresolve HAVE_MAXMINDDB)\n\n# SMI SNMP\nreset_find_package(SMI SMI_SHARE_DIR)\nws_find_package(SMI ENABLE_SMI HAVE_LIBSMI)\n\n# Support for TLS decryption using RSA private keys.\nws_find_package(GNUTLS ENABLE_GNUTLS HAVE_LIBGNUTLS \"3.5.8\")\n\n# Kerberos\nws_find_package(KERBEROS ENABLE_KERBEROS HAVE_KERBEROS)\n\n# Zlib-ng compression\nws_find_package(ZLIBNG ENABLE_ZLIBNG HAVE_ZLIBNG)\n\n#if(NOT ZLIBNG_FOUND)\n    # Zlib compression\n    ws_find_package(ZLIB ENABLE_ZLIB HAVE_ZLIB)\n#endif()\n\n# Minizip-ng compression\nws_find_package(Minizipng ENABLE_MINIZIPNG HAVE_MINIZIPNG)\n\nif(NOT MINIZIPNG_FOUND)\n  # Minizip compression\n  ws_find_package(Minizip ENABLE_MINIZIP HAVE_MINIZIP)\nendif()\n\n# Brotli compression\nws_find_package(BROTLI ENABLE_BROTLI HAVE_BROTLI)\n\n# LZ4 compression\nws_find_package(LZ4 ENABLE_LZ4 HAVE_LZ4)\n\n# Snappy compression\nws_find_package(SNAPPY ENABLE_SNAPPY HAVE_SNAPPY)\n\n# zstd compression\nws_find_package(ZSTD ENABLE_ZSTD HAVE_ZSTD \"1.0.0\")\n\n# Enhanced HTTP/2 dissection\nws_find_package(NGHTTP2 ENABLE_NGHTTP2 HAVE_NGHTTP2 \"1.11.0\")\n\n# Enhanced HTTP/3 dissection\nws_find_package(NGHTTP3 ENABLE_NGHTTP3 HAVE_NGHTTP3)\n\n# Embedded Lua interpreter\nif(FETCH_lua)\n\t# Download and build lua\n\tinclude(${CMAKE_SOURCE_DIR}/cmake/external/lua54/Lua54.cmake)\nelse()\n\tset(LUA_FIND_VERSIONS \"5.4;5.3\" CACHE STRING \"Lua versions valid for the build (as a list)\")\n\tws_find_package(Lua ENABLE_LUA HAVE_LUA)\nendif()\n\nws_find_package(NL ENABLE_NETLINK HAVE_LIBNL)\n\nws_find_package(SBC ENABLE_SBC HAVE_SBC)\n\n# SpanDSP codec\nws_find_package(SPANDSP ENABLE_SPANDSP HAVE_SPANDSP)\n\nws_find_package(BCG729 ENABLE_BCG729 HAVE_BCG729)\n\nws_find_package(AMRNB ENABLE_AMRNB HAVE_AMRNB)\n\nws_find_package(ILBC ENABLE_ILBC HAVE_ILBC)\n\nws_find_package(OPUS ENABLE_OPUS HAVE_OPUS)\n\nif (BUILD_stratoshark)\n\t# libsinsp+libscap, required for falco-bridge\n\tws_find_package(Sinsp ENABLE_SINSP HAVE_SINSP \"0.17.1\")\nendif()\n\n# CMake 3.9 and below used 'LIBXML2_LIBRARIES' as the name of the cache entry\n# storing the find_library result. Transfer it to the new cache variable such\n# that reset_find_package can detect and clear outdated cache variables.\nif(DEFINED LIBXML2_LIBRARIES AND NOT DEFINED LIBXML2_LIBRARY)\n\tset(LIBXML2_LIBRARY ${LIBXML2_LIBRARIES} CACHE FILEPATH \"\")\nendif()\n# Call reset_find_package explicitly since variables are in upper case.\nreset_find_package(LIBXML2)\nws_find_package(LibXml2 ENABLE_LIBXML2 HAVE_LIBXML2)\nif(NOT LIBXML2_FOUND)\n\t# CMake 3.9 and below used LIBXML2_LIBRARIES as the name of\n\t# the cache entry storing the find_library result.\n\t# Current CMake (3.13) and below sets LIBXML2_LIBRARIES and LIBXML2_INCLUDE_DIRS\n\t# to a non-empty value, be sure to clear it when not found.\n\tset(LIBXML2_LIBRARIES \"\")\n\tset(LIBXML2_INCLUDE_DIRS \"\")\nendif()\n\n# Capabilities to run dumpcap as non-root user.\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\tws_find_package(CAP ENABLE_CAP HAVE_LIBCAP)\n\tfind_package(SETCAP)\nendif()\n\n# Windows version updates\nws_find_package(WinSparkle ENABLE_WINSPARKLE HAVE_SOFTWARE_UPDATE)\n\nfind_package( Asciidoctor 1.5 )\nfind_package( XSLTPROC )\n\nfind_package(DOXYGEN)\n\n# The SpeexDSP resampler is required iff building wireshark or sharkd.\nif(BUILD_wireshark OR BUILD_stratoshark OR BUILD_sharkd)\n\tfind_package(SpeexDSP REQUIRED)\nendif()\n\n# Generate the distribution tarball.\nadd_custom_target(dist\n\tCOMMAND ${CMAKE_BINARY_DIR}/packaging/source/git-export-release.sh -d \"${CMAKE_BINARY_DIR}\"\n\tWORKING_DIRECTORY ${CMAKE_SOURCE_DIR}\n)\n\nif(GNUTLS_FOUND)\n\t# Calculating public keys from PKCS #11 private keys requires GnuTLS\n\t# 3.4.0 or greater.\n\t#\n\t# Check that the support is present in case GnuTLS was compiled\n\t# --without-p11-kit as macos-setup.sh did until December 2020.\n\tcmake_push_check_state()\n\tif(WIN32 AND NOT MINGW)\n\t\tset(CMAKE_REQUIRED_DEFINITIONS -Dssize_t=int)\n\tendif()\n\tset(CMAKE_REQUIRED_INCLUDES ${GNUTLS_INCLUDE_DIRS})\n\tset(CMAKE_REQUIRED_LIBRARIES ${GNUTLS_LIBRARIES})\n\tcheck_symbol_exists(gnutls_pkcs11_obj_list_import_url4 gnutls/pkcs11.h HAVE_GNUTLS_PKCS11)\n\tcmake_pop_check_state()\nendif()\n\nif (QT_FOUND)\n\t# CMake uses qmake to find Qt4. It relies on Qt's CMake modules\n\t# to find Qt5. This means that we can't assume that the qmake\n\t# in our PATH is the correct one. We can fetch qmake's location\n\t# from Qt5::qmake, which is defined in Qt5CoreConfigExtras.cmake.\n\tget_target_property(QT_QMAKE_EXECUTABLE Qt${qtver}::qmake IMPORTED_LOCATION)\n\tget_filename_component(_qt_bin_path \"${QT_QMAKE_EXECUTABLE}\" DIRECTORY)\n\tset(QT_BIN_PATH \"${_qt_bin_path}\" CACHE INTERNAL\n\t\t\"Path to qmake, macdeployqt, windeployqt, and other Qt utilities.\"\n\t)\n\t# Use qmake to find windeployqt and macdeployqt. Ideally one of\n\t# the modules in ${QTDIR}/lib/cmake would do this for us.\n\tif(WIN32)\n\t\tif (USE_qt6 AND USE_MSYSTEM)\n\t\t\tset(_windeployqt_name \"windeployqt-qt6\")\n\t\telse()\n\t\t\tset(_windeployqt_name \"windeployqt\")\n\t\tendif()\n\t\tfind_program(QT_WINDEPLOYQT_EXECUTABLE ${_windeployqt_name}\n\t\t\tHINTS \"${QT_BIN_PATH}\"\n\t\t\tDOC \"Path to the windeployqt utility.\"\n\t\t)\n\t\t# As of Qt 6.5.0, the official Qt \"MSVC 2019 ARM64 (TP)\" libraries don't ship\n\t\t# with native Arm64 executables. Instead, you get x64 executables installed in\n\t\t# msvc2019_x64. Look for the path to \"qmake.bat\", which has to be passed to\n\t\t# windeployqt so that it can install the proper DLLs.\n\t\t# https://bugreports.qt.io/browse/QTBUG-100070\n\t\tset(QT_WINDEPLOYQT_EXTRA_ARGS)\n\t\tfind_program(_qt_qmake_bat qmake.bat\n\t\t\tHINTS ENV CMAKE_PREFIX_PATH\n\t\t\tPATH_SUFFIXES bin\n\t\t\tDOC \"Path to qmake.bat.\"\n\t\t)\n\t\tif(_qt_qmake_bat)\n\t\t\tset (QT_WINDEPLOYQT_EXTRA_ARGS \"--qmake \\\"${_qt_qmake_bat}\\\"\")\n\t\tendif()\n\telseif(APPLE)\n\t\tfind_program(QT_MACDEPLOYQT_EXECUTABLE macdeployqt\n\t\t\tHINTS \"${QT_BIN_PATH}\"\n\t\t\tDOC \"Path to the macdeployqt utility.\"\n\t\t)\n\t\tfind_program(DMGBUILD_EXECUTABLE dmgbuild\n\t\t\tDOC \"Path to the dmgbuild utility\"\n\t\t)\n\t\t# https://doc.qt.io/qt-5/supported-platforms.html\n\t\t# https://doc.qt.io/archives/qt-6.0/supported-platforms.html\n\t\t# https://doc.qt.io/qt-6.5/supported-platforms.html\n\t\t# https://doc.qt.io/qt-6.8/supported-platforms.html\n\t\t# https://doc-snapshots.qt.io/qt6-dev/supported-platforms.html\n\t\tif(Qt${qtver}Widgets_VERSION VERSION_GREATER_EQUAL \"6.8.0\" AND MIN_MACOS_VERSION VERSION_LESS \"12.0\")\n\t\t\tset(MIN_MACOS_VERSION 12.0)\n\t\telseif(Qt${qtver}Widgets_VERSION VERSION_GREATER_EQUAL \"6.5.0\" AND MIN_MACOS_VERSION VERSION_LESS \"11.0\")\n\t\t\tset(MIN_MACOS_VERSION 11.0)\n\t\telseif(Qt${qtver}Widgets_VERSION VERSION_GREATER_EQUAL \"6.0.0\" AND MIN_MACOS_VERSION VERSION_LESS \"10.14\")\n\t\t\tset(MIN_MACOS_VERSION 10.14)\n\t\tendif()\n\t\tif(CMAKE_OSX_DEPLOYMENT_TARGET AND CMAKE_OSX_DEPLOYMENT_TARGET VERSION_LESS MIN_MACOS_VERSION)\n\t\t\tmessage(FATAL_ERROR \"Qt version ${Qt${qtver}Widgets_VERSION} requires CMAKE_OSX_DEPLOYMENT_TARGET (${CMAKE_OSX_DEPLOYMENT_TARGET}) >= ${MIN_MACOS_VERSION}\")\n\t\tendif()\n\tendif()\n\n\t# Qt requires MSVC /permissive- option since 6.3 release\n\tif(CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\" AND Qt${qtver}Widgets_VERSION VERSION_GREATER_EQUAL \"6.3.0\")\n\t\tadd_compile_options(\"/permissive-\")\n\tendif()\nendif()\n\nif(ENABLE_CHECKHF_CONFLICT)\n\tset(ENABLE_CHECK_FILTER 1)\nendif()\n\n#\n# Platform-specific additional libraries.\n#\nif(WIN32)\n\tset(WIN_COMCTL32_LIBRARY comctl32.lib)\n\tset(WIN_IPHLPAPI_LIBRARY iphlpapi.lib)\n\tset(WIN_PSAPI_LIBRARY    psapi.lib)\n\tset(WIN_VERSION_LIBRARY  version.lib)\n\tset(WIN_WS2_32_LIBRARY   ws2_32.lib)\nendif()\n\nif(APPLE)\n\t#\n\t# We assume that APPLE means macOS so that we have the macOS\n\t# frameworks.\n\t#\n\tset(HAVE_MACOS_FRAMEWORKS 1)\n\tFIND_LIBRARY (APPLE_APPLICATION_SERVICES_LIBRARY ApplicationServices)\n\tFIND_LIBRARY (APPLE_APPKIT_LIBRARY AppKit)\n\tFIND_LIBRARY (APPLE_CORE_FOUNDATION_LIBRARY CoreFoundation)\n\tFIND_LIBRARY (APPLE_SYSTEM_CONFIGURATION_LIBRARY SystemConfiguration)\n\n\tmessage(STATUS \"Building for Mac OS X/OS X/macOS ${MIN_MACOS_VERSION} using SDK ${CMAKE_OSX_SYSROOT}\")\nendif()\n\ninclude(ConfigureChecks.cmake)\n\n# Global properties\nset_property(GLOBAL PROPERTY USE_FOLDERS ON)\n\nif(ENABLE_CCACHE)\n\tif(NOT (CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID MATCHES \"Clang\"))\n\t\t# https://ccache.dev/platform-compiler-language-support.html\n\t\tmessage(WARNING \"Ccache is enabled, but your compiler is ${CMAKE_C_COMPILER_ID}.\"\n\t\t\" We wish you the best of luck.\")\n\tendif()\n\tfind_program(CCACHE_EXECUTABLE ccache)\n\tif(CCACHE_EXECUTABLE)\n\t\tset(CMAKE_C_COMPILER_LAUNCHER \"${CCACHE_EXECUTABLE}\")\n\t\tset(CMAKE_CXX_COMPILER_LAUNCHER \"${CCACHE_EXECUTABLE}\")\n\t\tset(CMAKE_C_LINKER_LAUNCHER \"${CCACHE_EXECUTABLE}\")\n\t\tset(CMAKE_CXX_LINKER_LAUNCHER \"${CCACHE_EXECUTABLE}\")\n\tendif()\nendif()\n\n# The top level checkAPIs target, add before subdirectory calls so it's available to all\nadd_custom_target(checkAPI)\nset_target_properties(checkAPI\n\tPROPERTIES\n\t\tFOLDER \"Auxiliary\"\n\t\tEXCLUDE_FROM_ALL True\n\t\tEXCLUDE_FROM_DEFAULT_BUILD True\n)\n\ninclude( UseCheckAPI )\n\n# Target platform locations\n# UN*X in general, including macOS if not building an app bundle:\n# $DESTDIR/lib/wireshark/extcap\n# Windows: $DESTDIR/extcap\n# macOS app bundle: Wireshark.app/Contents/Resources/share/wireshark/extcap\n# If you change the nesting level be sure to check also the INSTALL_RPATH\n# target property.\nif(WIN32 AND NOT USE_MSYSTEM)\n\tset(EXTCAP_INSTALL_LIBDIR \"extcap/${PROJECT_NAME}\" CACHE INTERNAL \"The Wireshark extcap dir\")\n\tif (BUILD_stratoshark)\n\t\tset(STRATOSHARK_EXTCAP_INSTALL_LIBDIR \"extcap/${STRATOSHARK_NAME}\" CACHE INTERNAL \"The Stratoshark extcap dir\")\n\tendif()\nelse()\n\tset(EXTCAP_INSTALL_LIBDIR \"${CMAKE_INSTALL_LIBDIR}/${PROJECT_NAME}/extcap\" CACHE INTERNAL \"The Wireshark extcap dir\")\n\tif (BUILD_stratoshark)\n\t\tset(STRATOSHARK_EXTCAP_INSTALL_LIBDIR \"${CMAKE_INSTALL_LIBDIR}/${STRATOSHARK_NAME}/extcap\" CACHE INTERNAL \"The Stratoshark extcap dir\")\n\tendif()\nendif()\n\nif(APPLE)\n\t#\n\t# As https://developer.apple.com/library/archive/technotes/tn2206/_index.html\n\t# says,\n\t#\n\t# \"Note that a location where code is expected to reside cannot generally\n\t# contain directories full of nested code, because those directories tend\n\t# to be interpreted as bundles. So this occasional practice is not\n\t# recommended and not officially supported. If you do do this, do not use\n\t# periods in the directory names. The code signing machinery interprets\n\t# directories with periods in their names as code bundles and will reject\n\t# them if they don't conform to the expected code bundle layout.\"\n\t#\n\tset(PLUGIN_PATH_ID \"${PROJECT_MAJOR_VERSION}-${PROJECT_MINOR_VERSION}\")\nelse()\n\tset(PLUGIN_PATH_ID \"${PROJECT_MAJOR_VERSION}.${PROJECT_MINOR_VERSION}\")\nendif()\n\n# Directory where plugins and Lua dissectors can be found.\nif(WIN32 AND NOT USE_MSYSTEM)\n\tset(PLUGIN_INSTALL_LIBDIR \"plugins\" CACHE INTERNAL \"The plugin dir\")\nelse()\n\tset(PLUGIN_INSTALL_LIBDIR \"${CMAKE_INSTALL_LIBDIR}/${PROJECT_NAME}/plugins\" CACHE INTERNAL \"The plugin dir\")\nendif()\nset(PLUGIN_INSTALL_FULL_LIBDIR \"${CMAKE_INSTALL_PREFIX}/${PLUGIN_INSTALL_LIBDIR}\")\nset(PLUGIN_INSTALL_VERSION_LIBDIR \"${PLUGIN_INSTALL_LIBDIR}/${PLUGIN_PATH_ID}\")\nset(PLUGIN_VERSION_DIR \"plugins/${PLUGIN_PATH_ID}\")\n\nadd_subdirectory( capture )\nadd_subdirectory( epan )\nadd_subdirectory( extcap )\nadd_subdirectory( randpkt_core )\nif(NOT LEMON_EXECUTABLE)\n\tadd_subdirectory( tools/lemon )\nendif()\nif(PCAP_FOUND)\n\tadd_subdirectory( tools/radiotap-gen )\nendif()\nadd_subdirectory( ui )\nadd_subdirectory( wiretap )\nadd_subdirectory( writecap )\n\n# Location of our data files. This should be set to a value that allows\n# running from the build directory on Windows, on macOS when building an\n# application bundle, and on UNIX in general if\n# WIRESHARK_RUN_FROM_BUILD_DIRECTORY is set.\nif(ENABLE_APPLICATION_BUNDLE)\n\tif(CMAKE_CFG_INTDIR STREQUAL \".\")\n\t\tset(_datafile_dir \"${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/Resources/share/wireshark\")\n\telse()\n\t\t# Xcode\n\t\tset(_datafile_dir \"${CMAKE_BINARY_DIR}/run/${CMAKE_CFG_INTDIR}/Wireshark.app/Contents/Resources/share/wireshark\")\n\tendif()\nelseif(NOT CMAKE_CFG_INTDIR STREQUAL \".\")\n\t# Visual Studio, Xcode, etc.\n\tset(_datafile_dir \"${CMAKE_BINARY_DIR}/run/${CMAKE_CFG_INTDIR}\")\nelse()\n\t# Makefile, Ninja, etc.\n\tset(_datafile_dir \"${CMAKE_BINARY_DIR}/run\")\nendif()\n\nset(DATAFILE_DIR ${_datafile_dir} CACHE INTERNAL \"Build time data file location.\")\n\nif(ENABLE_APPLICATION_BUNDLE)\n\tif(CMAKE_CFG_INTDIR STREQUAL \".\")\n\t\tset(_stratoshark_datafile_dir \"${CMAKE_BINARY_DIR}/run/Stratoshark.app/Contents/Resources/share/stratoshark\")\n\telse()\n\t\t# Xcode\n\t\tset(_stratoshark_datafile_dir \"${CMAKE_BINARY_DIR}/run/${CMAKE_CFG_INTDIR}/Stratoshark.app/Contents/Resources/share/stratoshark\")\n\tendif()\n\tset(STRATOSHARK_DATAFILE_DIR ${_stratoshark_datafile_dir} CACHE INTERNAL \"Build time log analysis data file location.\")\n# XXX We need to update wsutil/filesystem.c and packaging/nsis/*stratoshark* to match.\n# elseif(NOT CMAKE_CFG_INTDIR STREQUAL \".\")\n# \t# Visual Studio, Xcode, etc.\n# \tset(_stratoshark_datafile_dir \"${CMAKE_BINARY_DIR}/run/${CMAKE_CFG_INTDIR}/share/stratoshark\")\n# else()\n# \t# Makefile, Ninja, etc.\n# \tset(_stratoshark_datafile_dir \"${CMAKE_BINARY_DIR}/run/share/stratoshark\")\nendif()\n\n# wsutil must be added after DATAFILE_DIR is set such that filesystem.c can\n# learn about the directory location.\nadd_subdirectory( wsutil )\n\n# doc/ must be added after DATAFILE_DIR is set so that the guides can be\n# copied there for running from the build directory\nadd_subdirectory( doc )\n\nif(BUILD_wireshark AND QT_FOUND)\n\tadd_subdirectory( ui/qt )\nelseif(BUILD_wireshark AND USE_qt6)\n\tmessage(VERBOSE \"To use Qt5 instead of Qt6 use CMake option USE_qt6=OFF.\")\nendif()\n\nif(BUILD_stratoshark AND QT_FOUND)\n\tadd_subdirectory( ui/stratoshark )\nendif()\n\n# Location of our plugins. PLUGIN_DIR should allow running\n# from the build directory similar to DATAFILE_DIR above.\nif(ENABLE_PLUGINS)\n\t# Target platform locations\n\t# UN*X in general, including macOS if not building an app bundle:\n\t# $DESTDIR/lib/wireshark/plugins/$VERSION\n\t# Windows: $DESTDIR/wireshark/plugins/$VERSION\n\t# macOS app bundle: Wireshark.app/Contents/PlugIns/wireshark\n\tset(HAVE_PLUGINS 1)\n\tadd_custom_target(plugins)\n\tset_target_properties(plugins PROPERTIES FOLDER \"Plugins\")\n\tset(PLUGIN_SRC_DIRS\n\t\tplugins/epan/ethercat\n\t\tplugins/epan/gryphon\n\t\tplugins/epan/irda\n\t\tplugins/epan/mate\n\t\tplugins/epan/opcua\n\t\tplugins/epan/profinet\n\t\tplugins/epan/stats_tree\n\t\tplugins/epan/transum\n\t\tplugins/epan/unistim\n\t\tplugins/epan/wimax\n\t\tplugins/epan/wimaxasncp\n\t\tplugins/epan/wimaxmacphy\n\t\tplugins/epan/dfilter/ipaddr\n\t\tplugins/wiretap/usbdump\n\t\tplugins/codecs/G711\n\t\tplugins/codecs/l16_mono\n\t\t${CUSTOM_PLUGIN_SRC_DIR}\n\t)\n\tset(STRATOSHARK_PLUGIN_SRC_DIRS)\n\tif(SINSP_FOUND)\n\t\tlist(APPEND STRATOSHARK_PLUGIN_SRC_DIRS\n\t\t\tplugins/epan/falco_bridge\n\t\t)\n\tendif()\n\tif(SPANDSP_FOUND)\n\t\tlist(APPEND PLUGIN_SRC_DIRS\n\t\t\tplugins/codecs/G722\n\t\t\tplugins/codecs/G726\n\t\t)\n\tendif()\n\tif(BCG729_FOUND)\n\t\tlist(APPEND PLUGIN_SRC_DIRS\n\t\t\tplugins/codecs/G729\n\t\t)\n\tendif()\n\tif(AMRNB_FOUND)\n\t\tlist(APPEND PLUGIN_SRC_DIRS\n\t\t\tplugins/codecs/amrnb\n\t\t)\n\tendif()\n\tif(ILBC_FOUND)\n\t\tlist(APPEND PLUGIN_SRC_DIRS\n\t\t\tplugins/codecs/iLBC\n\t\t)\n\tendif()\n\tif(OPUS_FOUND)\n\t\tlist(APPEND PLUGIN_SRC_DIRS\n\t\t\tplugins/codecs/opus_dec\n\t\t)\n\tendif()\n\tif(SBC_FOUND)\n\t\tlist(APPEND PLUGIN_SRC_DIRS\n\t\t\tplugins/codecs/sbc\n\t\t)\n\tendif()\n\n\t# Build demo plugin, only if asked explicitly\n\tif(ENABLE_PLUGIN_IFDEMO)\n\t\tlist(APPEND PLUGIN_SRC_DIRS\n\t\t\tplugins/epan/pluginifdemo\n\t\t)\n\tendif()\n\nelse()\n\tset(PLUGIN_SRC_DIRS )\n\tset(STRATOSHARK_PLUGIN_SRC_DIRS )\nendif()\n\nif(ENABLE_APPLICATION_BUNDLE)\n\tif(CMAKE_CFG_INTDIR STREQUAL \".\")\n\t\tset(_plugin_dir \"${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/PlugIns/wireshark/${PLUGIN_PATH_ID}\")\n\telse()\n\t\t# Xcode\n\t\tset(_plugin_dir \"${CMAKE_BINARY_DIR}/run/$<CONFIG>/Wireshark.app/Contents/PlugIns/wireshark/${PLUGIN_PATH_ID}\")\n\tendif()\n\tif(CMAKE_CFG_INTDIR STREQUAL \".\")\n\t\tset(_stratoshark_plugin_dir \"${CMAKE_BINARY_DIR}/run/Stratoshark.app/Contents/PlugIns/stratoshark/${PLUGIN_PATH_ID}\")\n\telse()\n\t\t# Xcode\n\t\tset(_stratoshark_plugin_dir \"${CMAKE_BINARY_DIR}/run/$<CONFIG>/Stratoshark.app/Contents/PlugIns/stratoshark/${PLUGIN_PATH_ID}\")\n\tendif()\nelseif(MSVC AND NOT CMAKE_CFG_INTDIR STREQUAL \".\")\n\tset(_plugin_dir \"${CMAKE_BINARY_DIR}/run/$<CONFIG>/${PLUGIN_VERSION_DIR}\")\n\tset(_stratoshark_plugin_dir ${_plugin_dir})\nelse()\n\tset(_plugin_dir \"${DATAFILE_DIR}/${PLUGIN_VERSION_DIR}\")\n\tset(_stratoshark_plugin_dir ${_plugin_dir})\nendif()\nset (PLUGIN_DIR ${_plugin_dir} CACHE INTERNAL \"Build time plugin location.\")\nset (STRATOSHARK_PLUGIN_DIR ${_stratoshark_plugin_dir} CACHE INTERNAL \"Build time Stratoshark plugin location.\")\n\nforeach(_plugin_src_dir ${PLUGIN_SRC_DIRS} ${STRATOSHARK_PLUGIN_SRC_DIRS})\n\tadd_subdirectory( ${_plugin_src_dir} )\nendforeach()\n\nif(VCSVERSION_OVERRIDE)\n\t# Allow distributors to override detection of the Git tag and version.\n\tstring(CONFIGURE \"#define VCSVERSION \\\"@VCSVERSION_OVERRIDE@\\\"\\n\"\n\t\t_version_h_contents ESCAPE_QUOTES)\n\tfile(WRITE \"${CMAKE_BINARY_DIR}/vcs_version.h\" \"${_version_h_contents}\")\n\tmessage(STATUS \"VCSVERSION_OVERRIDE: ${VCSVERSION_OVERRIDE}\")\nelse()\n\tadd_custom_target(vcs_version\n\t\tBYPRODUCTS vcs_version.h\n\t\tCOMMAND ${Python3_EXECUTABLE}\n\t\t\t${CMAKE_SOURCE_DIR}/tools/make-version.py\n\t\t\t${CMAKE_SOURCE_DIR}\n\t)\n\tset_target_properties(vcs_version PROPERTIES FOLDER \"Auxiliary\")\nendif()\n\nset( configure_input \"Built with CMake ${CMAKE_VERSION}\" )\nconfigure_file(${CMAKE_SOURCE_DIR}/cmakeconfig.h.in ${CMAKE_BINARY_DIR}/config.h)\n\nconfigure_file(${CMAKE_SOURCE_DIR}/ws_version.h.in ${CMAKE_BINARY_DIR}/ws_version.h)\n\n# Doxygen variables\nfile(GLOB TOP_LEVEL_SOURCE_LIST *.c *.cpp *.h)\nstring (REPLACE \";\" \" \" DOXYGEN_TOP_LEVEL_SOURCES \"${TOP_LEVEL_SOURCE_LIST}\")\nset(DOXYGEN_INPUT_DIRECTORY ${CMAKE_SOURCE_DIR})\nset(DOXYGEN_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})\n\nset(CFG_OUT_FILES\n\tdoxygen.cfg\n\tpackaging/macosx/osx-app.sh\n\tpackaging/macosx/osx-dmg.sh\n\tpackaging/macosx/wireshark-app.dmgbuild\n\tpackaging/macosx/wireshark-dsym.dmgbuild\n\tpackaging/macosx/WiresharkInfo.plist\n\tpackaging/source/git-export-release.sh\n\tresources/dumpcap.rc\n\tresources/libwireshark.rc\n\tresources/libwiretap.rc\n\tresources/libwsutil.rc\n\tresources/wireshark.exe.manifest\n\tresources/wireshark.pc\n\tresources/wireshark.rc\n)\n\nif(BUILD_stratoshark)\n\tlist(APPEND CFG_OUT_FILES\n\t\tpackaging/macosx/StratosharkInfo.plist\n\t\tpackaging/macosx/stratoshark-app.dmgbuild\n\t\tpackaging/macosx/stratoshark-dsym.dmgbuild\n\t\tresources/stratoshark.exe.manifest\n\t)\nendif()\n\nforeach( _cfg_file ${CFG_OUT_FILES} )\n\tconfigure_file( ${CMAKE_SOURCE_DIR}/${_cfg_file}.in ${CMAKE_BINARY_DIR}/${_cfg_file} @ONLY )\nendforeach()\n\ninclude(FeatureSummary)\nset_package_properties(CAP PROPERTIES\n\tDESCRIPTION \"The Libcap package implements the user-space interfaces to the POSIX 1003.1e capabilities available in Linux kernels\"\n\tURL \"https://sites.google.com/site/fullycapable/\"\n\tPURPOSE \"Allow packet captures without running as root\"\n)\nset_package_properties(SBC PROPERTIES\n\tDESCRIPTION \"Bluetooth low-complexity, subband codec (SBC) decoder\"\n\tURL \"https://git.kernel.org/pub/scm/bluetooth/sbc.git\"\n\tPURPOSE \"Support for playing SBC codec in RTP player\"\n)\nset_package_properties(SPANDSP PROPERTIES\n\tDESCRIPTION \"a library of many DSP functions for telephony\"\n\tURL \"https://www.soft-switch.org\"\n\tPURPOSE \"Support for G.722 and G.726 codecs in RTP player\"\n)\nset_package_properties(BCG729 PROPERTIES\n\tDESCRIPTION \"G.729 decoder\"\n\tURL \"https://www.linphone.org/technical-corner/bcg729\"\n\tPURPOSE \"Support for G.729 codec in RTP player\"\n)\nset_package_properties(AMRNB PROPERTIES\n\tDESCRIPTION \"AMRNB decoder\"\n\tURL \"https://sourceforge.net/p/opencore-amr\"\n\tPURPOSE \"Support for AMRNB codec in RTP player\"\n)\nset_package_properties(ILBC PROPERTIES\n\tDESCRIPTION \"iLBC decoder\"\n\tURL \"https://github.com/TimothyGu/libilbc\"\n\tPURPOSE \"Support for iLBC codec in RTP player\"\n)\nset_package_properties(OPUS PROPERTIES\n\tDESCRIPTION \"opus decoder\"\n\tURL \"https://opus-codec.org/\"\n\tPURPOSE \"Support for opus codec in RTP player\"\n)\nset_package_properties(LIBXML2 PROPERTIES\n\tDESCRIPTION \"XML parsing library\"\n\tURL \"http://xmlsoft.org/\"\n\tPURPOSE \"Read XML configuration files in EPL dissector\"\n)\nset_package_properties(LIBSSH PROPERTIES\n\tDESCRIPTION \"Library for implementing SSH clients\"\n\tURL \"https://www.libssh.org/\"\n\tPURPOSE \"extcap remote SSH interfaces (sshdump, ciscodump, wifidump, sshdig)\"\n)\nset_package_properties(LZ4 PROPERTIES\n\tDESCRIPTION \"LZ4 is a fast lossless compression algorithm\"\n\tURL \"http://www.lz4.org\"\n\tPURPOSE \"LZ4 decompression in CQL and Kafka dissectors, read compressed capture files\"\n)\nset_package_properties(SNAPPY PROPERTIES\n\tDESCRIPTION \"A fast compressor/decompressor from Google\"\n\tURL \"https://google.github.io/snappy/\"\n\tPURPOSE \"Snappy decompression in Couchbase, CQL, Kafka and Mongo dissectors\"\n)\nset_package_properties(ZSTD PROPERTIES\n\tDESCRIPTION \"A compressor/decompressor from Facebook providing better compression than Snappy at a cost of speed\"\n\tURL \"https://facebook.github.io/zstd/\"\n\tPURPOSE \"Zstd decompression in Kafka dissector, read compressed capture files\"\n)\nset_package_properties(NGHTTP2 PROPERTIES\n\tDESCRIPTION \"HTTP/2 C library and tools\"\n\tURL \"https://nghttp2.org\"\n\tPURPOSE \"Header decompression in HTTP2\"\n)\nset_package_properties(NGHTTP3 PROPERTIES\n\tDESCRIPTION \"HTTP/3 C library and tools\"\n\tURL \"https://nghttp2.org\"\n\tPURPOSE \"Header decompression in HTTP3\"\n)\nset_package_properties(CARES PROPERTIES\n\tDESCRIPTION \"Library for asynchronous DNS requests\"\n\tURL \"https://c-ares.org/\"\n\tPURPOSE \"DNS name resolution for captures\"\n)\nset_package_properties(Systemd PROPERTIES\n\tURL \"https://freedesktop.org/wiki/Software/systemd/\"\n\tDESCRIPTION \"System and Service Manager (libraries)\"\n\tPURPOSE \"Support for systemd journal extcap interface (sdjournal)\"\n)\nset_package_properties(NL PROPERTIES\n\tURL \"https://www.infradead.org/~tgr/libnl/\"\n\tDESCRIPTION \"Libraries for using the Netlink protocol on Linux\"\n\tPURPOSE \"Support for managing wireless 802.11 interfaces\"\n)\nset_package_properties(MaxMindDB PROPERTIES\n\tURL \"https://github.com/maxmind/libmaxminddb\"\n\tDESCRIPTION \"C library for the MaxMind DB file format\"\n\tPURPOSE \"Support for GeoIP lookup\"\n)\nset_package_properties(SpeexDSP PROPERTIES\n\tURL \"https://www.speex.org/\"\n\tDESCRIPTION \"SpeexDSP is a patent-free, Open Source/Free Software DSP library\"\n\tPURPOSE \"RTP audio resampling\"\n)\nset_package_properties(Minizip PROPERTIES\n\tURL \"https://github.com/madler/zlib\"\n\tDESCRIPTION \"Mini zip and unzip based on zlib\"\n\tPURPOSE \"Support for profiles import/export\"\n)\nset_package_properties(Minizipng PROPERTIES\n\tURL \"https://github.com/zlib-ng/minizip-ng\"\n\tDESCRIPTION \"A fork of the minizip library - Mini zip and unzip based on zlib\"\n\tPURPOSE \"Support for profiles import/export\"\n)\nset_package_properties(SMI PROPERTIES\n\tURL \"https://www.ibr.cs.tu-bs.de/projects/libsmi/\"\n\tDESCRIPTION \"Library to access SMI management information\"\n\tPURPOSE \"Support MIB and PIB parsing and OID resolution\"\n)\nset_package_properties(PCRE2 PROPERTIES\n\tURL \"https://www.pcre.org\"\n\tDESCRIPTION \"Regular expression pattern matching using the same syntax and semantics as Perl 5\"\n\tPURPOSE \"Support for regular expressions\"\n)\nset_package_properties(Sinsp PROPERTIES\n\tDESCRIPTION \"libsinsp and libscap\"\n\tURL \"https://github.com/falcosecurity/libs/\"\n\tPURPOSE \"Support for Falco plugins\"\n)\nset_package_properties(Lua PROPERTIES\n\tDESCRIPTION \"Lua is a powerful, efficient, lightweight, embeddable scripting language\"\n\tURL \"https://www.lua.org/\"\n\tPURPOSE \"Lua allows writing dissectors and other extensions without a C/C++ compiler\"\n)\n\nstring(TOUPPER \"${CMAKE_BUILD_TYPE}\" _build_type)\nmessage(STATUS \"C-Flags: ${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${_build_type}}\")\nmessage(STATUS \"CXX-Flags: ${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_${_build_type}}\")\nif(WERROR_COMMON_FLAGS)\n\tmessage(STATUS \"Warnings as errors enabled: ${WERROR_COMMON_FLAGS}\")\nelse()\n\tmessage(STATUS \"Warnings as errors disabled\")\nendif()\n\nfeature_summary(WHAT ALL)\n\n# Should this be part of libui?\nif(WIN32)\n\tset(PLATFORM_UI_SRC\n\t\tui/win32/file_dlg_win32.cpp\n\t)\nelseif(APPLE)\n\tset(PLATFORM_UI_SRC\n\t\tui/macosx/cocoa_bridge.mm\n\t)\n\tif (SPARKLE_FOUND)\n\t\tlist(APPEND PLATFORM_UI_SRC ui/macosx/sparkle_bridge.m)\n\tendif()\nendif()\n\nset(TSHARK_TAP_SRC\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-credentials.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-camelsrt.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-diameter-avp.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-expert.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-exportobject.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-endpoints.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-flow.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-follow.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-funnel.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-gsm_astat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-hosts.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-httpstat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-icmpstat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-icmpv6stat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-iostat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-iousers.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-macltestat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-oran.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-protocolinfo.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-protohierstat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-rlcltestat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-rpcprogs.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-rtd.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-rtp.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-rtspstat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-sctpchunkstat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-simple_stattable.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-sipstat.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-smbsids.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-srt.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-stats_tree.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-sv.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-voip.c\n\t${CMAKE_SOURCE_DIR}/ui/cli/tap-wspstat.c\n\t${CUSTOM_TSHARK_TAP_SRC}\n\n)\n\n# Copied into ${DATAFILE_DIR} at build time and ${CMAKE_INSTALL_DATADIR}/wireshark\n# at install time.\nset(INSTALL_DIRS\n\tresources/share/wireshark/profiles\n\tresources/protocols/diameter\n\tresources/protocols/dtds\n\tresources/protocols/radius\n\tresources/protocols/tpncp\n\tresources/protocols/wimaxasncp\n)\n\n# Copied into ${DATAFILE_DIR} at build time and ${CMAKE_INSTALL_DATADIR}/wireshark\n# at install time.\nset(INSTALL_FILES\n\tresources/share/wireshark/cfilters\n\tresources/share/wireshark/colorfilters\n\tresources/share/wireshark/dmacros\n\tresources/share/wireshark/dfilters\n\tresources/share/wireshark/ipmap.html\n\tresources/share/wireshark/smi_modules\n\twka\n)\n\nset(DOC_FILES\n\tresources/share/doc/wireshark/pdml2html.xsl\n\tdoc/README.xml-output\n\tdoc/ws.css\n)\n\nif (BUILD_stratoshark)\n\tset(STRATOSHARK_INSTALL_DIRS\n\t\tresources/share/stratoshark/profiles\n\t)\n\n\tset(STRATOSHARK_INSTALL_FILES\n\t\tdoc/ws.css\n\t\tresources/share/stratoshark/colorfilters\n\t\tresources/share/stratoshark/dfilter_buttons\n\t)\nendif()\n\nif (ASCIIDOCTOR_FOUND)\n\tlist(APPEND DOC_FILES\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/androiddump.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/udpdump.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/capinfos.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/captype.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/ciscodump.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/dumpcap.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/editcap.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/extcap.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/mergecap.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/randpkt.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/randpktdump.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/etwdump.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/rawshark.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/reordercap.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/sshdig.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/sshdump.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/stratoshark.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/wifidump.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/text2pcap.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/tshark.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/wireshark.html\n\t\t${CMAKE_BINARY_DIR}/doc/man_pages/wireshark-filter.html\n\t\t\"${CMAKE_BINARY_DIR}/doc/Wireshark Release Notes.html\"\n\t\t\"${CMAKE_BINARY_DIR}/doc/Stratoshark Release Notes.html\"\n\t)\n\tif(MAXMINDDB_FOUND)\n\t\tlist(APPEND DOC_FILES ${CMAKE_BINARY_DIR}/doc/man_pages/mmdbresolve.html)\n\tendif()\n\n\tif (BUILD_corbaidl2wrs)\n\t\tlist(APPEND DOC_FILES ${CMAKE_BINARY_DIR}/doc/man_pages/idl2wrs.html)\n\tendif()\n\tif (BUILD_xxx2deb)\n\t\tlist(APPEND DOC_FILES\n\t\t\t${CMAKE_BINARY_DIR}/doc/man_pages/asn2deb.html\n\t\t\t${CMAKE_BINARY_DIR}/doc/man_pages/idl2deb.html\n\t\t)\n\tendif()\n\tif (BUILD_stratoshark)\n\t\tlist(APPEND DOC_FILES\n\t\t\t${CMAKE_BINARY_DIR}/doc/man_pages/falcodump.html\n\t\t)\n\tendif()\nendif()\n\nif(NOT WIN32)\n\t# We do this for Windows further down in the copy_data_files target.\n\tlist(APPEND DOC_FILES COPYING)\nendif()\n\nif(USE_REPOSITORY)\n\tset(_dll_output_dir \"$<TARGET_FILE_DIR:wsutil>\")\n\tadd_custom_target(copy_cli_dlls)\n\tset_target_properties(copy_cli_dlls PROPERTIES FOLDER \"Copy Tasks\")\n\tadd_custom_command(TARGET copy_cli_dlls PRE_BUILD\n\t\tCOMMAND ${CMAKE_COMMAND} -E make_directory \"${_dll_output_dir}\"\n\t)\n\n\t# XXX Can (and should) we iterate over these similar to the way\n\t# the top-level CMakeLists.txt iterates over the package list?\n\n\t# Required DLLs and their corresponding PDBs.\n\tadd_custom_command(TARGET copy_cli_dlls PRE_BUILD\n\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t\t\"$<IF:$<CONFIG:Debug>,${GLIB2_DLLS_DEBUG},${GLIB2_DLLS_RELEASE}>\"\n\t\t\t\"$<IF:$<CONFIG:Debug>,${GLIB2_PDBS_DEBUG},${GLIB2_PDBS_RELEASE}>\"\n\t\t\t\"${_dll_output_dir}\"\n\t\tWORKING_DIRECTORY $<IF:$<CONFIG:Debug>,${GLIB2_DLL_DIR_DEBUG},${GLIB2_DLL_DIR_RELEASE}>\n\t\tCOMMAND_EXPAND_LISTS\n\t)\n\n\tadd_custom_command(TARGET copy_cli_dlls PRE_BUILD\n\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t\t\"$<IF:$<CONFIG:Debug>,${PCRE2_DEBUG_DLL},${PCRE2_RELEASE_DLL}>\"\n\t\t\t\"$<IF:$<CONFIG:Debug>,${PCRE2_DEBUG_PDB},${PCRE2_RELEASE_PDB}>\"\n\t\t\t\"${_dll_output_dir}\"\n\t\tWORKING_DIRECTORY $<IF:$<CONFIG:Debug>,${PCRE2_DEBUG_DLL_DIR},${PCRE2_RELEASE_DLL_DIR}>\n\t\tCOMMAND_EXPAND_LISTS\n\t)\n\n\tif (MSVC AND VLD_FOUND)\n\t\tadd_custom_command(TARGET copy_cli_dlls PRE_BUILD\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E \"$<IF:$<CONFIG:Debug>,copy_if_different,true>\"\n\t\t\t\"${VLD_FILES}\"\n\t\t\t\"${_dll_output_dir}\"\n\t\t\tCOMMAND_EXPAND_LISTS\n\t\t)\n\tendif()\n\n\t# Third party DLLs and PDBs.\n\tset (THIRD_PARTY_DLLS)\n\tset (THIRD_PARTY_PDBS)\n\tlist (APPEND THIRD_PARTY_DLLS \"${CARES_DLL_DIR}/${CARES_DLL}\")\n\tlist (APPEND THIRD_PARTY_PDBS \"${CARES_DLL_DIR}/${CARES_PDB}\")\n\t# vcpkg's libmaxminddb is static-only for now. This can be uncommented when\n\t# https://github.com/maxmind/libmaxminddb/commit/3998f42bdb6678cbaa1a543057e5c81ba1668ac2\n\t# percolates up to vcpkg.\n\t# if (MAXMINDDB_FOUND)\n\t# \tlist (APPEND THIRD_PARTY_DLLS \"${MAXMINDDB_DLL_DIR}/${MAXMINDDB_DLL}\")\n\t# endif(MAXMINDDB_FOUND)\n\tif (LIBSSH_FOUND)\n\t\tforeach( _dll ${LIBSSH_DLLS} )\n\t\t\tlist (APPEND THIRD_PARTY_DLLS \"${LIBSSH_DLL_DIR}/${_dll}\")\n\t\tendforeach(_dll)\n\tendif(LIBSSH_FOUND)\n\tforeach( _dll ${GCRYPT_DLLS} )\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${GCRYPT_DLL_DIR}/${_dll}\")\n\tendforeach(_dll)\n\tforeach( _dll ${GNUTLS_DLLS} )\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${GNUTLS_DLL_DIR}/${_dll}\")\n\tendforeach(_dll)\n\tforeach( _dll ${KERBEROS_DLLS} )\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${KERBEROS_DLL_DIR}/${_dll}\")\n\tendforeach(_dll)\n\tif (LUA_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${LUA_DLL_DIR}/${LUA_DLL}\")\n\tendif(LUA_FOUND)\n\tif (LZ4_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${LZ4_DLL_DIR}/${LZ4_DLL}\")\n\t\tlist (APPEND THIRD_PARTY_PDBS \"${LZ4_DLL_DIR}/${LZ4_PDB}\")\n\tendif(LZ4_FOUND)\n\tif (MINIZIP_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${MINIZIP_DLL_DIR}/${MINIZIP_DLL}\")\n\t\tlist (APPEND THIRD_PARTY_PDBS \"${MINIZIP_DLL_DIR}/${MINIZIP_PDB}\")\n\tendif()\n\tif (MINIZIPNG_FOUND)\n\t\tforeach( _dll ${MINIZIPNG_DLLS} )\n\t\t\tlist (APPEND THIRD_PARTY_DLLS \"${MINIZIPNG_DLL_DIR}/${_dll}\")\n\t\tendforeach(_dll)\n\t\tforeach( _pdb ${MINIZIPNG_PDBS} )\n\t\t\tlist (APPEND THIRD_PARTY_PDBS \"${MINIZIPNG_DLL_DIR}/${_pdb}\")\n\t\tendforeach(_pdb)\n\tendif()\n\tif (NGHTTP2_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${NGHTTP2_DLL_DIR}/${NGHTTP2_DLL}\")\n\t\tlist (APPEND THIRD_PARTY_PDBS \"${NGHTTP2_DLL_DIR}/${NGHTTP2_PDB}\")\n\tendif(NGHTTP2_FOUND)\n\tif (NGHTTP3_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${NGHTTP3_DLL_DIR}/${NGHTTP3_DLL}\")\n\t\tlist (APPEND THIRD_PARTY_PDBS \"${NGHTTP3_DLL_DIR}/${NGHTTP3_PDB}\")\n\tendif(NGHTTP3_FOUND)\n\tif (SBC_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${SBC_DLL_DIR}/${SBC_DLL}\")\n\tendif(SBC_FOUND)\n\tif (SPANDSP_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${SPANDSP_DLL_DIR}/${SPANDSP_DLL}\")\n\tendif(SPANDSP_FOUND)\n\tif (BCG729_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${BCG729_DLL_DIR}/${BCG729_DLL}\")\n\tendif(BCG729_FOUND)\n\tif (AMRNB_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${AMRNB_DLL_DIR}/${AMRNB_DLL}\")\n\tendif(AMRNB_FOUND)\n\tif (ILBC_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${ILBC_DLL_DIR}/${ILBC_DLL}\")\n\tendif(ILBC_FOUND)\n\tif (OPUS_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${OPUS_DLL_DIR}/${OPUS_DLL}\")\n\tendif(OPUS_FOUND)\n\tif (LIBXML2_FOUND)\n\t\tforeach( _dll ${LIBXML2_DLLS} )\n\t\t\tlist (APPEND THIRD_PARTY_DLLS \"${LIBXML2_DLL_DIR}/${_dll}\")\n\t\tendforeach(_dll)\n\t\tforeach( _pdb ${LIBXML2_PDBS} )\n\t\t\tlist (APPEND THIRD_PARTY_PDBS \"${LIBXML2_DLL_DIR}/${_pdb}\")\n\t\tendforeach(_pdb)\n\tendif(LIBXML2_FOUND)\n\tif (SMI_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${SMI_DLL_DIR}/${SMI_DLL}\")\n\t\t# Wireshark.nsi wants SMI_DIR which is the base SMI directory\n\t\tget_filename_component(SMI_DIR ${SMI_DLL_DIR} DIRECTORY)\n\t\tadd_custom_command(TARGET copy_cli_dlls PRE_BUILD\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E make_directory\n\t\t\t\t\"${_dll_output_dir}/snmp\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E make_directory\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\t\t\"${SMI_SHARE_DIR}/mibs/iana\"\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\t\t\"${SMI_SHARE_DIR}/mibs/ietf\"\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\t\t\"${SMI_SHARE_DIR}/mibs/irtf\"\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\t\t\"${SMI_SHARE_DIR}/mibs/site\"\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\t\t\"${SMI_SHARE_DIR}/mibs/tubs\"\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\t\t\"${SMI_SHARE_DIR}/pibs\"\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\t\t\"${SMI_SHARE_DIR}/yang\"\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs\"\n\t\t\t#remove the extra directories copied (shallow copying the above would remove the need for this)\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E remove_directory\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs/iana\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E remove_directory\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs/ietf\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E remove_directory\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs/site\"\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E remove_directory\n\t\t\t\t\"${_dll_output_dir}/snmp/mibs/tubs\"\n\t\t)\n\tendif(SMI_FOUND)\n\tif (SNAPPY_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${SNAPPY_DLL_DIR}/${SNAPPY_DLL}\")\n\tendif(SNAPPY_FOUND)\n\tif (WINSPARKLE_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${WINSPARKLE_DLL_DIR}/${WINSPARKLE_DLL}\")\n\tendif(WINSPARKLE_FOUND)\n\tif (ZLIB_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${ZLIB_DLL_DIR}/${ZLIB_DLL}\")\n\t\tlist (APPEND THIRD_PARTY_PDBS \"${ZLIB_DLL_DIR}/${ZLIB_PDB}\")\n\tendif(ZLIB_FOUND)\n\tif (ZLIBNG_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${ZLIBNG_DLL_DIR}/${ZLIBNG_DLL}\")\n\t\tlist (APPEND THIRD_PARTY_PDBS \"${ZLIBNG_DLL_DIR}/${ZLIBNG_PDB}\")\n\tendif(ZLIBNG_FOUND)\n\tif (BROTLI_FOUND)\n\t\tforeach( _dll ${BROTLI_DLLS} )\n\t\t\tlist (APPEND THIRD_PARTY_DLLS \"${BROTLI_DLL_DIR}/${_dll}\")\n\t\tendforeach(_dll)\n\tendif(BROTLI_FOUND)\n\tif (SPEEXDSP_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${SPEEXDSP_DLL_DIR}/${SPEEXDSP_DLL}\")\n\tendif()\n\tif (ZSTD_FOUND)\n\t\tlist (APPEND THIRD_PARTY_DLLS \"${ZSTD_DLL_DIR}/${ZSTD_DLL}\")\n\tendif()\n\n\t# With libs downloaded to c:/wireshark-x64-libs this currently\n\t# (early 2018) expands to about 1900 characters.\n\tif (THIRD_PARTY_DLLS)\n\t\tadd_custom_command(TARGET copy_cli_dlls PRE_BUILD\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t\t\t${THIRD_PARTY_DLLS}\n\t\t\t\t\"${_dll_output_dir}\"\n\t\t\tVERBATIM\n\t\t)\n\t\tinstall(FILES ${THIRD_PARTY_DLLS} DESTINATION \"${CMAKE_INSTALL_BINDIR}\")\n\tendif(THIRD_PARTY_DLLS)\n\n\tif (THIRD_PARTY_PDBS)\n\t\tadd_custom_command(TARGET copy_cli_dlls PRE_BUILD\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t\t\t${THIRD_PARTY_PDBS}\n\t\t\t\t\"${_dll_output_dir}\"\n\t\t\tVERBATIM\n\t\t)\n\tendif(THIRD_PARTY_PDBS)\n\n\tadd_dependencies(epan copy_cli_dlls)\n\n\t# We have a lot of choices for creating zip archives:\n\t# - 7z, WinZip, etc., which require a separate download+install.\n\t# - \"CMake -E tar cz\", which creates a tar file.\n\t# - CPack, which requires a CPack configuration.\n\t# - PowerShell via PSCX or System.IO.Compression.FileSystem.\n\t# - Python via zipfile.\n\t# For now, just look for 7z. It's installed on the Windows builders,\n\t# which might be the only systems that use this target.\n\tfind_program(ZIP_EXECUTABLE 7z\n\t\tPATH \"$ENV{PROGRAMFILES}/7-Zip\" \"$ENV{PROGRAMW6432}/7-Zip\"\n\t\tDOC \"Path to the 7z utility.\"\n\t)\n\tif(ZIP_EXECUTABLE)\n\t\tadd_custom_target(pdb_zip_package COMMENT \"This packages .PDBs but will not create them.\")\n\t\tset_target_properties(pdb_zip_package PROPERTIES FOLDER \"Packaging\")\n\t\tset(_pdb_zip \"${CMAKE_BINARY_DIR}/Wireshark-pdb-${PROJECT_VERSION}-${WIRESHARK_TARGET_PLATFORM}.zip\")\n\t\tfile(TO_NATIVE_PATH \"${_pdb_zip}\" _pdb_zip_win)\n\t\tadd_custom_command(TARGET pdb_zip_package POST_BUILD\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E remove -f \"${_pdb_zip}\"\n\t\t\tCOMMAND ${ZIP_EXECUTABLE} a -tzip -mmt=on \"${_pdb_zip_win}\"\n\t\t\t\t-bb0 -bd\n\t\t\t\t-r *.pdb *.lib\n\t\t\tWORKING_DIRECTORY \"${_dll_output_dir}\"\n\t\t)\n\tendif()\nendif()\n\n# List of extra dependencies for the \"copy_data_files\" target\nset(copy_data_files_depends)\n\nif(WIN32)\n\tforeach(_install_as_txt_file COPYING README.md)\n\t\t# On Windows, install some files with a .txt extension so that they're\n\t\t# double-clickable.\n\t\tstring(REGEX REPLACE \".md$\" \"\" _no_md_file ${_install_as_txt_file})\n\t\tset(_output_file \"${DATAFILE_DIR}/${_no_md_file}.txt\")\n\t\tadd_custom_command(OUTPUT ${_output_file}\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t\t\t${CMAKE_SOURCE_DIR}/${_install_as_txt_file}\n\t\t\t\t${_output_file}\n\t\t\tDEPENDS\n\t\t\t\t${CMAKE_SOURCE_DIR}/${_install_as_txt_file}\n\t\t)\n\t\tlist(APPEND copy_data_files_depends \"${_output_file}\")\n\tendforeach()\nendif()\n\nforeach(_install_file ${INSTALL_FILES} ${DOC_FILES})\n\tget_filename_component(_install_file_src \"${_install_file}\" ABSOLUTE)\n\tget_filename_component(_install_basename \"${_install_file}\" NAME)\n\tset(_output_file \"${DATAFILE_DIR}/${_install_basename}\")\n\tadd_custom_command(OUTPUT \"${_output_file}\"\n\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t\t\"${_install_file_src}\"\n\t\t\t\"${_output_file}\"\n\t\tDEPENDS\n\t\t\tdocs\n\t\t\t\"${_install_file}\"\n\t)\n\tlist(APPEND copy_data_files_depends \"${_output_file}\")\nendforeach()\n\nif (BUILD_stratoshark)\n\tif (ENABLE_APPLICATION_BUNDLE)\n\t\tforeach(_install_file ${STRATOSHARK_INSTALL_FILES} ${DOC_FILES})\n\t\t\tget_filename_component(_install_file_src \"${_install_file}\" ABSOLUTE)\n\t\t\tget_filename_component(_install_basename \"${_install_file}\" NAME)\n\t\t\tset(_output_file \"${STRATOSHARK_DATAFILE_DIR}/${_install_basename}\")\n\t\t\tadd_custom_command(OUTPUT \"${_output_file}\"\n\t\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t\t\t\t\"${_install_file_src}\"\n\t\t\t\t\t\"${_output_file}\"\n\t\t\t\tDEPENDS\n\t\t\t\t\tdocs\n\t\t\t\t\t\"${_install_file}\"\n\t\t\t)\n\t\t\tlist(APPEND copy_data_files_depends \"${_output_file}\")\n\t\tendforeach()\n\telse()\n\t\t# XXX The default profile (colorfilters, dfilters) is at the\n\t\t# top-level resources directory for both Wireshark and Stratoshark.\n\tendif()\nendif()\n\nset(_protocol_data_dir ${CMAKE_SOURCE_DIR}/resources/protocols)\n# Glob patterns relative to the source directory that should be copied to\n# ${DATAFILE_DIR} (including directory prefixes)\n# TODO shouldn't this use full (relative) paths instead of glob patterns?\nset(DATA_FILES_SRC\n\t${_protocol_data_dir}/tpncp/tpncp.dat\n\t${_protocol_data_dir}/wimaxasncp/*.dtd\n\t${_protocol_data_dir}/wimaxasncp/*.xml\n)\n\n# Copy all paths from the source tree to the data directory. Directories are\n# automatically created if missing as the filename is given.\nfile(GLOB _data_files RELATIVE ${_protocol_data_dir} ${DATA_FILES_SRC})\nforeach(_data_file ${_data_files})\n\tadd_custom_command(OUTPUT \"${DATAFILE_DIR}/${_data_file}\"\n\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t\t${_protocol_data_dir}/${_data_file}\n\t\t\t${DATAFILE_DIR}/${_data_file}\n\t\tDEPENDS\n\t\t\t${_protocol_data_dir}/${_data_file}\n\t)\n\tlist(APPEND copy_data_files_depends ${DATAFILE_DIR}/${_data_file})\nendforeach()\n\nfile(GLOB _dtds_src_files RELATIVE ${_protocol_data_dir} ${_protocol_data_dir}/dtds/*.dtd)\n\nset (_dtds_data_files)\nset (_dtds_dep_files)\nforeach(_data_file ${_dtds_src_files})\n\tlist(APPEND _dtds_data_files ${DATAFILE_DIR}/${_data_file})\n\tlist(APPEND _dtds_dep_files ${_protocol_data_dir}/${_data_file})\nendforeach()\n\nadd_custom_command(\n\tOUTPUT ${_dtds_data_files}\n\tCOMMAND ${CMAKE_COMMAND} -E make_directory ${DATAFILE_DIR}/dtds\n\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t${_dtds_src_files}\n\t\t${DATAFILE_DIR}/dtds\n\tVERBATIM\n\tDEPENDS ${_dtds_dep_files}\n\tWORKING_DIRECTORY ${_protocol_data_dir}\n)\n\nfile(GLOB _diameter_src_files RELATIVE ${_protocol_data_dir}\n\t${_protocol_data_dir}/diameter/*.dtd\n\t${_protocol_data_dir}/diameter/*.xml\n)\n\nset (_diameter_data_files)\nset (_diameter_dep_files)\nforeach(_data_file ${_diameter_src_files})\n\tlist(APPEND _diameter_data_files ${DATAFILE_DIR}/${_data_file})\n\tlist(APPEND _diameter_dep_files ${_protocol_data_dir}/${_data_file})\nendforeach()\n\nadd_custom_command(\n\tOUTPUT ${_diameter_data_files}\n\tCOMMAND ${CMAKE_COMMAND} -E make_directory ${DATAFILE_DIR}/diameter\n\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t${_diameter_src_files}\n\t\t${DATAFILE_DIR}/diameter\n\tVERBATIM\n\tDEPENDS ${_diameter_dep_files}\n\tWORKING_DIRECTORY ${_protocol_data_dir}\n)\n\nfile(GLOB _radius_src_files RELATIVE ${_protocol_data_dir}\n\tCONFIGURE_DEPENDS\n\t${_protocol_data_dir}/radius/README.radius_dictionary\n\t${_protocol_data_dir}/radius/custom.includes\n\t${_protocol_data_dir}/radius/dictionary\n\t${_protocol_data_dir}/radius/dictionary.*\n)\n\nset (_radius_data_files)\nset (_radius_dep_files)\nforeach(_data_file ${_radius_src_files})\n\tlist(APPEND _radius_data_files ${DATAFILE_DIR}/${_data_file})\n\tlist(APPEND _radius_dep_files ${_protocol_data_dir}/${_data_file})\nendforeach()\n\nadd_custom_command(\n\tOUTPUT ${_radius_data_files}\n\tCOMMAND ${CMAKE_COMMAND} -E make_directory ${DATAFILE_DIR}/radius\n\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t${_radius_src_files}\n\t\t${DATAFILE_DIR}/radius\n\tVERBATIM\n\tDEPENDS ${_radius_dep_files}\n\tWORKING_DIRECTORY ${_protocol_data_dir}\n)\n\nfile(GLOB _protobuf_src_files RELATIVE ${_protocol_data_dir}\n\t${_protocol_data_dir}/protobuf/*.proto\n)\nset (_protobuf_data_files)\nset (_protobuf_dep_files)\nforeach(_data_file ${_protobuf_src_files})\n\tlist(APPEND _protobuf_data_files ${DATAFILE_DIR}/${_data_file})\n\tlist(APPEND _protobuf_dep_files ${_protocol_data_dir}/${_data_file})\nendforeach()\n\nadd_custom_command(\n\tOUTPUT ${_protobuf_data_files}\n\tCOMMAND ${CMAKE_COMMAND} -E make_directory ${DATAFILE_DIR}/protobuf\n\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t${_protobuf_src_files}\n\t\t${DATAFILE_DIR}/protobuf\n\tVERBATIM\n\tDEPENDS ${_protobuf_dep_files}\n\tWORKING_DIRECTORY ${_protocol_data_dir}\n)\n\nset(_profiles_src_dir ${CMAKE_SOURCE_DIR}/resources/share/wireshark)\nfile(GLOB _profiles_src_files RELATIVE ${_profiles_src_dir} ${_profiles_src_dir}/profiles/*/*)\nset (_profiles_data_files)\nforeach(_data_file ${_profiles_src_files})\n\tlist(APPEND _profiles_data_files \"${DATAFILE_DIR}/${_data_file}\")\nendforeach()\n\nadd_custom_command(\n\tOUTPUT ${_profiles_data_files}\n\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\"${CMAKE_SOURCE_DIR}/resources/share/wireshark/profiles\" \"${DATAFILE_DIR}/profiles\"\n)\n\nset (_stratoshark_profiles_data_files)\nif (BUILD_stratoshark AND ENABLE_APPLICATION_BUNDLE)\n\tset(_profiles_src_dir ${CMAKE_SOURCE_DIR}/resources/share/stratoshark)\n\tfile(GLOB _profiles_src_files RELATIVE ${_profiles_src_dir} ${_profiles_src_dir}/profiles/*/*)\n\tforeach(_data_file ${_profiles_src_files})\n\t\tlist(APPEND _stratoshark_profiles_data_files \"${STRATOSHARK_DATAFILE_DIR}/${_data_file}\")\n\tendforeach()\n\n\tadd_custom_command(\n\t\tOUTPUT ${_stratoshark_profiles_data_files}\n\t\tCOMMAND ${CMAKE_COMMAND} -E copy_directory\n\t\t\t\"${CMAKE_SOURCE_DIR}/resources/share/stratoshark/profiles\" \"${STRATOSHARK_DATAFILE_DIR}/profiles\"\n\t)\nendif()\n\nlist(APPEND copy_data_files_depends\n\t${_dtds_data_files}\n\t${_diameter_data_files}\n\t${_radius_data_files}\n\t${_protobuf_data_files}\n\t${_profiles_data_files}\n\t${_stratoshark_profiles_data_files}\n)\n\n# Copy files including ${INSTALL_FILES} and ${INSTALL_DIRS} to ${DATAFILE_DIR}\nadd_custom_target(copy_data_files ALL DEPENDS ${copy_data_files_depends} )\nset_target_properties(copy_data_files PROPERTIES FOLDER \"Copy Tasks\")\n\n# sources common for wireshark, tshark, rawshark and sharkd\nadd_library(shark_common OBJECT\n\tcfile.c\n\textcap_parser.c\n\tfile_packet_provider.c\n\tsync_pipe_write.c\n)\nadd_library(cli_main OBJECT cli_main.c)\n\nif(BUILD_wireshark AND QT_FOUND)\n\tset(WIRESHARK_SRC\n\t\tfile.c\n\t\tfileset.c\n\t\textcap.c\n\t\t${PLATFORM_UI_SRC}\n\t)\n\tset(wireshark_FILES\n\t\t$<TARGET_OBJECTS:shark_common>\n\t\t${WIRESHARK_SRC}\n\t\t${PLATFORM_UI_RC_FILES}\n\t)\n\tset_executable_resources(wireshark \"Wireshark\" UNIQUE_RC)\nendif()\n\nif(BUILD_stratoshark AND QT_FOUND)\n\tset(STRATOSHARK_SRC\n\t\tfile.c\n\t\tfileset.c\n\t\textcap.c\n\t\t${PLATFORM_UI_SRC}\n\t)\n\tset(stratoshark_FILES\n\t\t$<TARGET_OBJECTS:shark_common>\n\t\t${STRATOSHARK_SRC}\n\t\t${PLATFORM_UI_RC_FILES}\n\t)\n\tset_executable_resources(stratoshark \"Stratoshark\" UNIQUE_RC)\nendif()\n\nif(ENABLE_APPLICATION_BUNDLE)\n\t#\n\t# Add -Wl,-single_module to the LDFLAGS used with shared\n\t# libraries, to fix some error that show up in some cases;\n\t# some Apple documentation recommends it for most shared\n\t# libraries.\n\t#\n\tset( CMAKE_SHARED_LINKER_FLAGS \"-Wl,-single_module ${CMAKE_SHARED_LINKER_FLAGS}\" )\n\t#\n\t# Add -Wl,-headerpad_max_install_names to the LDFLAGS, as\n\t# code-signing issues is running out of padding space.\n\t#\n\t# Add -Wl,-search_paths_first to make sure that if we search\n\t# directories A and B, in that order, for a given library, a\n\t# non-shared version in directory A, rather than a shared\n\t# version in directory B, is chosen (so we can use\n\t# --with-pcap=/usr/local to force all programs to be linked\n\t# with a static version installed in /usr/local/lib rather than\n\t# the system version in /usr/lib).\n\t#\n\n\tset(CMAKE_EXE_LINKER_FLAGS\n\t\"-Wl,-headerpad_max_install_names -Wl,-search_paths_first ${CMAKE_EXE_LINKER_FLAGS}\"\n\t)\n\n\t# Add files to the Wireshark application bundle\n\t# Wireshark.app/Contents\n\tfile(WRITE ${CMAKE_BINARY_DIR}/packaging/macosx/wireshark/PkgInfo \"APPLWshk\\n\")\n\tset(WIRESHARK_BUNDLE_CONTENTS_FILES\n\t\t${CMAKE_BINARY_DIR}/packaging/macosx/wireshark/PkgInfo\n\t)\n\tset_source_files_properties(${WIRESHARK_BUNDLE_CONTENTS_FILES} PROPERTIES\n\t\tMACOSX_PACKAGE_LOCATION .\n\t)\n\n\t# Wireshark.app/Contents/Resources\n\tset(WIRESHARK_BUNDLE_RESOURCE_FILES\n\t\t${CMAKE_SOURCE_DIR}/packaging/macosx/Wireshark.icns\n\t\t${CMAKE_SOURCE_DIR}/packaging/macosx/Wiresharkdoc.icns\n\t)\n\tset_source_files_properties(${WIRESHARK_BUNDLE_RESOURCE_FILES} PROPERTIES\n\t\tMACOSX_PACKAGE_LOCATION Resources\n\t)\n\n\t# Wireshark.app/Contents/Resources/share/man/man1\n\tset_source_files_properties(${WIRESHARK_BUNDLE_RESOURCE_SHARE_MAN1_FILES} PROPERTIES\n\t\tMACOSX_PACKAGE_LOCATION Resources/share/man/man1\n\t\tGENERATED 1\n\t)\n\n\t# Wireshark.app/Contents/Resources/share/man/man4\n\tset_source_files_properties(${WIRESHARK_BUNDLE_RESOURCE_SHARE_MAN4_FILES} PROPERTIES\n\t\tMACOSX_PACKAGE_LOCATION Resources/share/man/man4\n\t\tGENERATED 1\n\t)\n\n\t# INSTALL_FILES and INSTALL_DIRS are handled by copy_data_files\n\n\tset(EXTRA_WIRESHARK_BUNDLE_FILES\n\t\t${WIRESHARK_BUNDLE_CONTENTS_FILES}\n\t\t${WIRESHARK_BUNDLE_RESOURCE_FILES}\n\t\t${WIRESHARK_BUNDLE_RESOURCE_SHARE_MAN1_FILES}\n\t\t${WIRESHARK_BUNDLE_RESOURCE_SHARE_MAN4_FILES}\n\t)\n\n\t# Add files to the Stratoshark application bundle\n\t# Stratoshark.app/Contents\n\tfile(WRITE ${CMAKE_BINARY_DIR}/packaging/macosx/stratoshark/PkgInfo \"APPLLgry\\n\")\n\tset(STRATOSHARK_BUNDLE_CONTENTS_FILES\n\t\t${CMAKE_BINARY_DIR}/packaging/macosx/stratoshark/PkgInfo\n\t)\n\tset_source_files_properties(${STRATOSHARK_BUNDLE_CONTENTS_FILES} PROPERTIES\n\t\tMACOSX_PACKAGE_LOCATION .\n\t)\n\n\t# Stratoshark.app/Contents/Resources\n\tset(STRATOSHARK_BUNDLE_RESOURCE_FILES\n\t\t${CMAKE_SOURCE_DIR}/packaging/macosx/Stratoshark.icns\n\t\t${CMAKE_SOURCE_DIR}/packaging/macosx/Wiresharkdoc.icns\n\t)\n\tset_source_files_properties(${STRATOSHARK_BUNDLE_RESOURCE_FILES} PROPERTIES\n\t\tMACOSX_PACKAGE_LOCATION Resources\n\t)\n\n\t# Stratoshark.app/Contents/Resources/share/man/man1\n\tset_source_files_properties(${STRATOSHARK_BUNDLE_RESOURCE_SHARE_MAN1_FILES} PROPERTIES\n\t\tMACOSX_PACKAGE_LOCATION Resources/share/man/man1\n\t\tGENERATED 1\n\t)\n\n\t# Stratoshark.app/Contents/Resources/share/man/man4\n\tset_source_files_properties(${STRATOSHARK_BUNDLE_RESOURCE_SHARE_MAN4_FILES} PROPERTIES\n\t\tMACOSX_PACKAGE_LOCATION Resources/share/man/man4\n\t\tGENERATED 1\n\t)\n\n\t# INSTALL_FILES and INSTALL_DIRS are handled by copy_data_files\n\n\tset(EXTRA_STRATOSHARK_BUNDLE_FILES\n\t\t${STRATOSHARK_BUNDLE_CONTENTS_FILES}\n\t\t${STRATOSHARK_BUNDLE_RESOURCE_FILES}\n\t\t${STRATOSHARK_BUNDLE_RESOURCE_SHARE_MAN1_FILES}\n\t\t${STRATOSHARK_BUNDLE_RESOURCE_SHARE_MAN4_FILES}\n\t)\n\nelse()\n\tset(EXTRA_WIRESHARK_BUNDLE_FILES)\n\tset(EXTRA_STRATOSHARK_BUNDLE_FILES)\nendif()\n\nif(BUILD_wireshark AND QT_FOUND)\n\tset(wireshark_LIBS\n\t\tui\n\t\tqtui\n\t\tcapchild\n\t\tcaputils\n\t\tiface_monitor\n\t\twiretap\n\t\tepan\n\t\tsummary\n\t\t${QT5_LIBRARIES}\n\t\t${APPLE_APPLICATION_SERVICES_LIBRARY}\n\t\t${APPLE_APPKIT_LIBRARY}\n\t\t${APPLE_CORE_FOUNDATION_LIBRARY}\n\t\t${APPLE_SYSTEM_CONFIGURATION_LIBRARY}\n\t\t${SPARKLE_LIBRARIES}\n\t\t${WIN_WS2_32_LIBRARY}\n\t\t${WIN_VERSION_LIBRARY}\n\t\t${WINSPARKLE_LIBRARIES}\n\t\t$<$<BOOL:${WIN32}>:uxtheme.lib>\n\t\t${SPEEXDSP_LIBRARIES}\n\t\t${ZLIB_LIBRARIES}\n\t\t${ZLIBNG_LIBRARIES}\n\t\t${MINIZIP_LIBRARIES}\n\t\t${MINIZIPNG_LIBRARIES}\n\t)\n\n\tadd_executable(wireshark WIN32 MACOSX_BUNDLE ${wireshark_FILES} ${EXTRA_WIRESHARK_BUNDLE_FILES})\n\tif(MSVC)\n\t\tset_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT wireshark)\n\tendif()\n\tset(PROGLIST ${PROGLIST} wireshark)\n\tset_target_properties(wireshark PROPERTIES\n\t\tLINK_FLAGS \"${WS_LINK_FLAGS}\"\n\t\tFOLDER \"Executables\"\n\t\tINSTALL_RPATH \"${EXECUTABLE_INSTALL_RPATH}\"\n\t\tAUTOMOC ON\n\t\tAUTOUIC ON\n\t\tAUTORCC ON\n\t)\n\tif(MSVC)\n\t\tset_target_properties(wireshark PROPERTIES LINK_FLAGS_DEBUG \"${WS_MSVC_DEBUG_LINK_FLAGS}\")\n\tendif()\n\tif (USE_MSYSTEM)\n\t\tset_target_properties(wireshark PROPERTIES OUTPUT_NAME wireshark)\n\telseif(ENABLE_APPLICATION_BUNDLE OR WIN32)\n\t\tset_target_properties(wireshark PROPERTIES OUTPUT_NAME Wireshark)\n\tendif()\n\n\tif(ENABLE_APPLICATION_BUNDLE)\n\t\tif(ASCIIDOCTOR_FOUND)\n\t\t\t# Make sure to generate files referenced by\n\t\t\t# WIRESHARK_BUNDLE_RESOURCE_SHARE_MAN1_FILES\n\t\t\tadd_dependencies(wireshark manpages)\n\t\tendif()\n\t\tset_target_properties(\n\t\t\twireshark PROPERTIES\n\t\t\t\tMACOSX_BUNDLE_INFO_PLIST ${CMAKE_BINARY_DIR}/packaging/macosx/WiresharkInfo.plist\n\t\t)\n\t\tif(CMAKE_CFG_INTDIR STREQUAL \".\")\n\t\t\t# Add a wrapper script which opens the bundle. This is more convenient\n\t\t\t# and lets Sparkle find our CFBundleIdentifier, but means that you have\n\t\t\t# to pass the full path to run/Wireshark.app/Contents/MacOS/Wireshark\n\t\t\t# to your debugger.\n\t\t\t# It is not created if using Xcode\n\t\t\tfile(REMOVE ${CMAKE_BINARY_DIR}/run/wireshark)\n\t\t\tfile(WRITE ${CMAKE_BINARY_DIR}/run/wireshark \"#!/bin/sh\\n\")\n\t\t\tfile(APPEND ${CMAKE_BINARY_DIR}/run/wireshark \"# Generated by ${CMAKE_CURRENT_LIST_FILE}\\n\")\n\t\t\tfile(APPEND ${CMAKE_BINARY_DIR}/run/wireshark \"# Wrapper script which ensures that we're properly activated via Launch Services\\n\")\n\t\t\tfile(APPEND ${CMAKE_BINARY_DIR}/run/wireshark \"exec \\\"${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/MacOS/Wireshark\\\" \\\"\\$\\@\\\"\\n\")\n\t\t\texecute_process(COMMAND chmod a+x ${CMAKE_BINARY_DIR}/run/wireshark)\n\t\tendif()\n\tendif()\n\n\ttarget_link_libraries(wireshark ${wireshark_LIBS})\n\ttarget_include_directories(wireshark SYSTEM PRIVATE ${SPARKLE_INCLUDE_DIRS})\n\n\tinstall(\n\t\tTARGETS wireshark\n\t\tRUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n\t\tBUNDLE DESTINATION ${CMAKE_INSTALL_BINDIR}\n\t)\n\n\tif(QT_WINDEPLOYQT_EXECUTABLE)\n\t\tadd_custom_target(copy_qt_dlls ALL)\n\t\tset_target_properties(copy_qt_dlls PROPERTIES FOLDER \"Copy Tasks\")\n\t\t# Will we ever need to use --debug? Windeployqt seems to\n\t\t# be smart enough to copy debug DLLs when needed.\n\t\tif (USE_MSYSTEM AND Qt${qtver}Widgets_VERSION VERSION_EQUAL 6.5.0)\n\t\t\t# windeployqt released with Qt 6.5.0 is broken.\n\t\t\t# https://bugreports.qt.io/browse/QTBUG-112204\n\t\t\tmessage(WARNING \"Qt Deploy Tool 6.5.0 is broken, please upgrade to a later version.\")\n\t\t\t# lconvert will fail\n\t\tendif()\n\t\tadd_custom_command(TARGET copy_qt_dlls\n\t\t\tPOST_BUILD\n\t\t\tCOMMAND set \"PATH=${QT_BIN_PATH};%PATH%\"\n\t\t\tCOMMAND \"${QT_WINDEPLOYQT_EXECUTABLE}\"\n\t\t\t\t${QT_WINDEPLOYQT_EXTRA_ARGS}\n\t\t\t\t--no-compiler-runtime\n\t\t\t\t--verbose 0\n\t\t\t\t$<$<BOOL:${MSVC}>:--pdb>\n\t\t\t\t\"$<TARGET_FILE:wireshark>\"\n\t\t)\n\t\tadd_dependencies(copy_qt_dlls wireshark)\n\n\t\tinstall(CODE \"execute_process(COMMAND\n\t\t\t\\\"${QT_WINDEPLOYQT_EXECUTABLE}\\\"\n\t\t\t--no-compiler-runtime\n\t\t\t\\\"\\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_BINDIR}/Wireshark.exe\\\")\"\n\t\t)\n\n\tendif(QT_WINDEPLOYQT_EXECUTABLE)\nendif()\n\nif(BUILD_stratoshark AND QT_FOUND)\n\tset(stratoshark_LIBS\n\t\tui\n\t\tui_stratoshark\n\t\tcapchild\n\t\tcaputils\n\t\tiface_monitor\n\t\twiretap\n\t\tepan\n\t\tsummary\n\t\t${QT5_LIBRARIES}\n\t\t${APPLE_APPLICATION_SERVICES_LIBRARY}\n\t\t${APPLE_APPKIT_LIBRARY}\n\t\t${APPLE_CORE_FOUNDATION_LIBRARY}\n\t\t${APPLE_SYSTEM_CONFIGURATION_LIBRARY}\n\t\t${SPARKLE_LIBRARIES}\n\t\t${WIN_WS2_32_LIBRARY}\n\t\t${WIN_VERSION_LIBRARY}\n\t\t${WINSPARKLE_LIBRARIES}\n\t\t$<$<BOOL:${WIN32}>:uxtheme.lib>\n\t\t${SPEEXDSP_LIBRARIES}\n\t\t${ZLIB_LIBRARIES}\n\t\t${ZLIBNG_LIBRARIES}\n\t\t${MINIZIP_LIBRARIES}\n\t\t${MINIZIPNG_LIBRARIES}\n\t)\n\n\tadd_executable(stratoshark WIN32 MACOSX_BUNDLE ${stratoshark_FILES} ${EXTRA_STRATOSHARK_BUNDLE_FILES})\n\tif(WIN32 AND NOT BUILD_wireshark)\n\t\tset_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT stratoshark)\n\tendif()\n\tset(PROGLIST ${PROGLIST} stratoshark)\n\tset_target_properties(stratoshark PROPERTIES\n\t\tLINK_FLAGS \"${WS_LINK_FLAGS}\"\n\t\tFOLDER \"Executables\"\n\t\tINSTALL_RPATH \"${EXECUTABLE_INSTALL_RPATH}\"\n\t\tAUTOMOC ON\n\t\tAUTOUIC ON\n\t\tAUTORCC ON\n\t)\n\tif(MSVC)\n\t\tset_target_properties(stratoshark PROPERTIES LINK_FLAGS_DEBUG \"${WS_MSVC_DEBUG_LINK_FLAGS}\")\n\tendif()\n\tif(ENABLE_APPLICATION_BUNDLE OR WIN32)\n\t\tset_target_properties(stratoshark PROPERTIES OUTPUT_NAME Stratoshark)\n\tendif()\n\n\tif(ENABLE_APPLICATION_BUNDLE)\n\t\tif(ASCIIDOCTOR_FOUND)\n\t\t\t# Make sure to generate files referenced by\n\t\t\t# STRATOSHARK_BUNDLE_RESOURCE_SHARE_MAN1_FILES\n\t\t\tadd_dependencies(stratoshark manpages)\n\t\tendif()\n\t\tset_target_properties(\n\t\t\tstratoshark PROPERTIES\n\t\t\t\tMACOSX_BUNDLE_INFO_PLIST ${CMAKE_BINARY_DIR}/packaging/macosx/StratosharkInfo.plist\n\t\t)\n\t\tif(CMAKE_CFG_INTDIR STREQUAL \".\")\n\t\t\t# Add a wrapper script which opens the bundle. This is more convenient\n\t\t\t# and lets Sparkle find our CFBundleIdentifier, but means that you have\n\t\t\t# to pass the full path to run/Wireshark.app/Contents/MacOS/Stratoshark\n\t\t\t# to your debugger.\n\t\t\t# It is not created if using Xcode\n\t\t\tfile(REMOVE ${CMAKE_BINARY_DIR}/run/stratoshark)\n\t\t\tfile(WRITE ${CMAKE_BINARY_DIR}/run/stratoshark \"#!/bin/sh\\n\")\n\t\t\tfile(APPEND ${CMAKE_BINARY_DIR}/run/stratoshark \"# Generated by ${CMAKE_CURRENT_LIST_FILE}\\n\")\n\t\t\tfile(APPEND ${CMAKE_BINARY_DIR}/run/stratoshark \"# Wrapper script which ensures that we're properly activated via Launch Services\\n\")\n\t\t\tfile(APPEND ${CMAKE_BINARY_DIR}/run/stratoshark \"exec \\\"${CMAKE_BINARY_DIR}/run/Stratoshark.app/Contents/MacOS/Stratoshark\\\" \\\"\\$\\@\\\"\\n\")\n\t\t\texecute_process(COMMAND chmod a+x ${CMAKE_BINARY_DIR}/run/stratoshark)\n\t\tendif()\n\tendif()\n\n\ttarget_link_libraries(stratoshark ${stratoshark_LIBS})\n\ttarget_include_directories(stratoshark SYSTEM PRIVATE ${SPARKLE_INCLUDE_DIRS})\n\n\tinstall(\n\t\tTARGETS stratoshark\n\t\tRUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n\t\tBUNDLE DESTINATION ${CMAKE_INSTALL_BINDIR}\n\t)\n\n\t# The build can fail if the copy_stratoshark_qt_dlls target is run at\n\t# the same time as the copy_qt_dlls target, so just assume that\n\t# copy_qt_dlls will provide everything we need for now.\n\tif(QT_WINDEPLOYQT_EXECUTABLE AND NOT BUILD_wireshark)\n\t\tadd_custom_target(copy_stratoshark_qt_dlls ALL)\n\t\tset_target_properties(copy_stratoshark_qt_dlls PROPERTIES FOLDER \"Copy Tasks\")\n\t\t# Will we ever need to use --debug? Windeployqt seems to\n\t\t# be smart enough to copy debug DLLs when needed.\n\t\tadd_custom_command(TARGET copy_stratoshark_qt_dlls\n\t\t\tPOST_BUILD\n\t\t\tCOMMAND set \"PATH=${QT_BIN_PATH};%PATH%\"\n\t\t\tCOMMAND \"${QT_WINDEPLOYQT_EXECUTABLE}\"\n\t\t\t\t--no-compiler-runtime\n\t\t\t\t--verbose 0\n\t\t\t\t$<$<BOOL:${MSVC}>:--pdb>\n\t\t\t\t\"$<TARGET_FILE:stratoshark>\"\n\t\t)\n\t\tadd_dependencies(copy_stratoshark_qt_dlls stratoshark)\n\n\t\tinstall(CODE \"execute_process(COMMAND\n\t\t\t\\\"${QT_WINDEPLOYQT_EXECUTABLE}\\\"\n\t\t\t--no-compiler-runtime\n\t\t\t\\\"\\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_BINDIR}/Stratoshark.exe\\\")\"\n\t\t)\n\n\tendif(QT_WINDEPLOYQT_EXECUTABLE AND NOT BUILD_wireshark)\nendif()\n\nif (BUILD_stratoshark AND FALCO_PLUGINS)\n\tadd_custom_target(copy_falco_plugins)\n\tadd_custom_command(TARGET copy_falco_plugins POST_BUILD\n\t\t# XXX Falco plugins should probably be installed in a path that reflects\n\t\t# the Falco version or its plugin API version.\n\t\tCOMMAND ${CMAKE_COMMAND} -E make_directory ${STRATOSHARK_PLUGIN_DIR}/../falco\n\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different ${FALCO_PLUGINS} ${STRATOSHARK_PLUGIN_DIR}/../falco\n\t\tVERBATIM\n\t)\n\tadd_dependencies(stratoshark copy_falco_plugins)\nendif()\n\n# Common properties for CLI executables\nmacro(set_extra_executable_properties _executable _folder)\n\tset_target_properties(${_executable} PROPERTIES\n\t\tLINK_FLAGS \"${WILDCARD_OBJ} ${WS_LINK_FLAGS}\"\n\t\tFOLDER ${_folder}\n\t\tINSTALL_RPATH \"${EXECUTABLE_INSTALL_RPATH}\"\n\t)\n\tif(MSVC)\n\t\tset_target_properties(${_executable} PROPERTIES LINK_FLAGS_DEBUG \"${WS_MSVC_DEBUG_LINK_FLAGS}\")\n\tendif()\n\n\tset(PROGLIST ${PROGLIST} ${_executable})\n\n\tif(ENABLE_APPLICATION_BUNDLE)\n\t\tif(NOT CMAKE_CFG_INTDIR STREQUAL \".\")\n\t\t\t# Xcode\n\t\t\tset_target_properties(${_executable} PROPERTIES\n\t\t\t\tRUNTIME_OUTPUT_DIRECTORY run/$<CONFIG>/Wireshark.app/Contents/MacOS\n\t\t\t)\n\t\telse ()\n\t\t\tset_target_properties(${_executable} PROPERTIES\n\t\t\t\tRUNTIME_OUTPUT_DIRECTORY run/Wireshark.app/Contents/MacOS\n\t\t\t)\n\t\t\t# Create a convenience link from run/<name> to its respective\n\t\t\t# target in the application bundle.\n\t\t\tadd_custom_target(${_executable}-symlink\n\t\t\t\tCOMMAND ln -s -f\n\t\t\t\t\tWireshark.app/Contents/MacOS/${_executable}\n\t\t\t\t\t${CMAKE_BINARY_DIR}/run/${_executable}\n\t\t\t)\n\t\t\tadd_dependencies(${_executable} ${_executable}-symlink)\n\t\tendif()\n\tendif()\nendmacro()\n\nmacro(executable_link_mingw_unicode _target)\n\t# target_link_options() requires CMake >= 3.13\n\tif (MINGW)\n\t\ttarget_link_options(${_target} PRIVATE \"-municode\")\n\tendif()\nendmacro()\n\nregister_tap_files(tshark-tap-register.c\n\t${TSHARK_TAP_SRC}\n)\n\nif(BUILD_tshark)\n\tset(tshark_LIBS\n\t\tui\n\t\tcapchild\n\t\tcaputils\n\t\twiretap\n\t\tepan\n\t\tiface_monitor\n\t\twsutil\n\t\t${APPLE_CORE_FOUNDATION_LIBRARY}\n\t\t${APPLE_SYSTEM_CONFIGURATION_LIBRARY}\n\t\t${WIN_WS2_32_LIBRARY}\n\t)\n\tset(tshark_FILES\n\t\t$<TARGET_OBJECTS:cli_main>\n\t\t$<TARGET_OBJECTS:shark_common>\n\t\ttshark-tap-register.c\n\t\ttshark.c\n\t\textcap.c\n\t\t${TSHARK_TAP_SRC}\n\t)\n\n\tset_executable_resources(tshark \"TShark\" UNIQUE_RC)\n\tadd_executable(tshark ${tshark_FILES})\n\tset_extra_executable_properties(tshark \"Executables\")\n\ttarget_link_libraries(tshark ${tshark_LIBS})\n\texecutable_link_mingw_unicode(tshark)\n\tinstall(TARGETS tshark RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_tfshark)\n\tset(tfshark_LIBS\n\t\tm\n\t\tui\n\t\twiretap\n\t\tepan\n\t\t${APPLE_CORE_FOUNDATION_LIBRARY}\n\t\t${APPLE_SYSTEM_CONFIGURATION_LIBRARY}\n\t)\n\tset(tfshark_FILES\n\t\t$<TARGET_OBJECTS:cli_main>\n\t\t$<TARGET_OBJECTS:shark_common>\n\t\ttfshark.c\n\t\t${TSHARK_TAP_SRC}\n\t)\n\tset_executable_resources(tfshark \"TFShark\")\n\tadd_executable(tfshark ${tfshark_FILES})\n\tset_extra_executable_properties(tfshark \"Executables\")\n\ttarget_link_libraries(tfshark ${tfshark_LIBS})\n\tinstall(TARGETS tfshark RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_rawshark AND PCAP_FOUND)\n\tset(rawshark_LIBS\n\t\tcaputils\n\t\tui\n\t\twiretap\n\t\tepan\n\t\t${APPLE_CORE_FOUNDATION_LIBRARY}\n\t\t${APPLE_SYSTEM_CONFIGURATION_LIBRARY}\n\t\t${WIN_WS2_32_LIBRARY}\n\t)\n\tset(rawshark_FILES\n\t\t$<TARGET_OBJECTS:cli_main>\n\t\t$<TARGET_OBJECTS:shark_common>\n\t\trawshark.c\n\t)\n\tset_executable_resources(rawshark \"Rawshark\")\n\tadd_executable(rawshark ${rawshark_FILES})\n\tset_extra_executable_properties(rawshark \"Executables\")\n\ttarget_link_libraries(rawshark ${rawshark_LIBS})\n\texecutable_link_mingw_unicode(rawshark)\n\tinstall(TARGETS rawshark RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_sharkd)\n\tset(sharkd_LIBS\n\t\tui\n\t\twiretap\n\t\tepan\n\t\t${APPLE_CORE_FOUNDATION_LIBRARY}\n\t\t${APPLE_SYSTEM_CONFIGURATION_LIBRARY}\n\t\t${WIN_WS2_32_LIBRARY}\n\t\t${SPEEXDSP_LIBRARIES}\n\t\t${GCRYPT_LIBRARIES}\n\t)\n\tset(sharkd_FILES\n\t\t#\n\t\t# XXX - currently doesn't work on Windows if it uses\n\t\t# $<TARGET_OBJECTS:cli_main> and has real_main().\n\t\t#\n\t\t$<TARGET_OBJECTS:shark_common>\n\t\tui/cli/simple_dialog.c\n\t\tsharkd.c\n\t\tsharkd_daemon.c\n\t\tsharkd_session.c\n\t\t${TSHARK_TAP_SRC}\n\t)\n\tset_executable_resources(sharkd \"SharkD\")\n\tadd_executable(sharkd ${sharkd_FILES})\n\tset_extra_executable_properties(sharkd \"Executables\")\n\ttarget_link_libraries(sharkd ${sharkd_LIBS})\n\ttarget_include_directories(sharkd SYSTEM PUBLIC ${SPEEXDSP_INCLUDE_DIRS})\n\n\tinstall(TARGETS sharkd RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_dftest)\n\tset(dftest_LIBS\n\t\tui\n\t\twiretap\n\t\tepan\n\t)\n\tset(dftest_FILES\n\t\tdftest.c\n\t)\n\tset_executable_resources(dftest \"Dftest\")\n\tadd_executable(dftest ${dftest_FILES})\n\tset_extra_executable_properties(dftest \"Tests\")\n\ttarget_link_libraries(dftest ${dftest_LIBS})\n\n\tinstall(TARGETS dftest RUNTIME\n\t\tDESTINATION ${CMAKE_INSTALL_BINDIR}\n\t\tCOMPONENT \"Development\"\n\t\tEXCLUDE_FROM_ALL\n\t)\nendif()\n\nif(BUILD_randpkt)\n\tset(randpkt_LIBS\n\t\trandpkt_core\n\t\tui\n\t\twiretap\n\t\twsutil\n\t)\n\tset(randpkt_FILES\n\t\t$<TARGET_OBJECTS:cli_main>\n\t\trandpkt.c\n\t)\n\tset_executable_resources(randpkt \"Randpkt\"\n\t\tCOPYRIGHT_INFO \"Copyright (C) 1999 by Gilbert Ramirez <gram@alumni.rice.edu>\")\n\tadd_executable(randpkt ${randpkt_FILES})\n\tset_extra_executable_properties(randpkt \"Executables\")\n\ttarget_link_libraries(randpkt ${randpkt_LIBS})\n\texecutable_link_mingw_unicode(randpkt)\n\tinstall(TARGETS randpkt RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_fuzzshark OR ENABLE_FUZZER OR OSS_FUZZ)\n\tadd_subdirectory(fuzz)\nendif()\n\nif(BUILD_text2pcap)\n\tset(text2pcap_LIBS\n\t\twiretap\n\t\twsutil\n\t\tui\n\t\tepan\n\t\t${ZLIB_LIBRARIES}\n\t\t${ZLIBNG_LIBRARIES}\n\t)\n\tset(text2pcap_FILES\n\t\t$<TARGET_OBJECTS:cli_main>\n\t\ttext2pcap.c\n\t)\n\tset_executable_resources(text2pcap \"Text2pcap\"\n\t\tCOPYRIGHT_INFO \"2001 Ashok Narayanan <ashokn@cisco.com>\")\n\tadd_executable(text2pcap ${text2pcap_FILES})\n\tset_extra_executable_properties(text2pcap \"Executables\")\n\ttarget_link_libraries(text2pcap ${text2pcap_LIBS})\n\texecutable_link_mingw_unicode(text2pcap)\n\tinstall(TARGETS text2pcap RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_mergecap)\n\tset(mergecap_LIBS\n\t\tui\n\t\twiretap\n\t\t${ZLIB_LIBRARIES}\n\t\t${ZLIBNG_LIBRARIES}\n\t\t${CMAKE_DL_LIBS}\n\t)\n\tset(mergecap_FILES\n\t\t$<TARGET_OBJECTS:cli_main>\n\t\tmergecap.c\n\t)\n\tset_executable_resources(mergecap \"Mergecap\")\n\tadd_executable(mergecap ${mergecap_FILES})\n\tset_extra_executable_properties(mergecap \"Executables\")\n\ttarget_link_libraries(mergecap ${mergecap_LIBS})\n\texecutable_link_mingw_unicode(mergecap)\n\tinstall(TARGETS mergecap RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_reordercap)\n\tset(reordercap_LIBS\n\t\tui\n\t\twiretap\n\t\t${ZLIB_LIBRARIES}\n\t\t${ZLIBNG_LIBRARIES}\n\t\t${CMAKE_DL_LIBS}\n\t)\n\tset(reordercap_FILES\n\t\t$<TARGET_OBJECTS:cli_main>\n\t\treordercap.c\n\t)\n\tset_executable_resources(reordercap \"Reordercap\")\n\tadd_executable(reordercap ${reordercap_FILES})\n\tset_extra_executable_properties(reordercap \"Executables\")\n\ttarget_link_libraries(reordercap ${reordercap_LIBS})\n\texecutable_link_mingw_unicode(reordercap)\n\tinstall(TARGETS reordercap RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_capinfos)\n\tset(capinfos_LIBS\n\t\tui\n\t\twiretap\n\t\twsutil\n\t\t${ZLIB_LIBRARIES}\n\t\t${ZLIBNG_LIBRARIES}\n\t\t${GCRYPT_LIBRARIES}\n\t\t${CMAKE_DL_LIBS}\n\t)\n\tset(capinfos_FILES\n\t\t$<TARGET_OBJECTS:cli_main>\n\t\tcapinfos.c\n\t)\n\tset_executable_resources(capinfos \"Capinfos\")\n\tadd_executable(capinfos ${capinfos_FILES})\n\tset_extra_executable_properties(capinfos \"Executables\")\n\ttarget_link_libraries(capinfos ${capinfos_LIBS})\n\ttarget_include_directories(capinfos SYSTEM PRIVATE ${GCRYPT_INCLUDE_DIRS})\n\texecutable_link_mingw_unicode(capinfos)\n\tinstall(TARGETS capinfos RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_captype)\n\tset(captype_LIBS\n\t\tui\n\t\twiretap\n\t\twsutil\n\t\t${ZLIB_LIBRARIES}\n\t\t${ZLIBNG_LIBRARIES}\n\t\t${CMAKE_DL_LIBS}\n\t)\n\tset(captype_FILES\n\t\t$<TARGET_OBJECTS:cli_main>\n\t\tcaptype.c\n\t)\n\tset_executable_resources(captype \"Captype\")\n\tadd_executable(captype ${captype_FILES})\n\tset_extra_executable_properties(captype \"Executables\")\n\ttarget_link_libraries(captype ${captype_LIBS})\n\texecutable_link_mingw_unicode(captype)\n\tinstall(TARGETS captype RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_editcap)\n\tset(editcap_LIBS\n\t\tui\n\t\twiretap\n\t\t${ZLIB_LIBRARIES}\n\t\t${ZLIBNG_LIBRARIES}\n\t\t${GCRYPT_LIBRARIES}\n\t\t${CMAKE_DL_LIBS}\n\t)\n\tset(editcap_FILES\n\t\t$<TARGET_OBJECTS:cli_main>\n\t\teditcap.c\n\t)\n\tset_executable_resources(editcap \"Editcap\")\n\tadd_executable(editcap ${editcap_FILES})\n\tset_extra_executable_properties(editcap \"Executables\")\n\ttarget_link_libraries(editcap ${editcap_LIBS})\n\ttarget_include_directories(editcap SYSTEM PRIVATE ${GCRYPT_INCLUDE_DIRS})\n\texecutable_link_mingw_unicode(editcap)\n\tinstall(TARGETS editcap RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(BUILD_dumpcap AND PCAP_FOUND)\n\tset(dumpcap_LIBS\n\t\twritecap\n\t\twsutil_static\n\t\tpcap::pcap\n\t\t${CAP_LIBRARIES}\n\t\t${ZLIB_LIBRARIES}\n\t\t${ZLIBNG_LIBRARIES}\n\t\t${NL_LIBRARIES}\n\t\t${APPLE_CORE_FOUNDATION_LIBRARY}\n\t\t${APPLE_SYSTEM_CONFIGURATION_LIBRARY}\n\t\t${WIN_WS2_32_LIBRARY}\n\t)\n\tif(UNIX)\n\t\tlist(APPEND CAPUTILS_SRC\n\t\t\tcapture/capture-pcap-util-unix.c)\n\tendif()\n\tif(WIN32)\n\t\tlist(APPEND CAPUTILS_SRC\n\t\t\tcapture/capture_win_ifnames.c\n\t\t\tcapture/capture-wpcap.c\n\t\t)\n\tendif()\n\tlist(APPEND CAPUTILS_SRC\n\t\tcapture/capture-pcap-util.c\n\t)\n\t#\n\t# We don't link with libiface_monitor or libui because those\n\t# are built to be linked against libwsutil as a shared library,\n\t# and dumpcap is deliberately not linked against any of\n\t# Wireshark's shared libraries, to reduce the amount of code\n\t# it uses, and linking against the non-shared libiface_monitor\n\t# or libui libraries will fail on Windows.\n\t#\n\t# Instead, we just include source files for the relevant code\n\t# to be built as part of dumpcap, so that they're built with\n\t# ENABLE_STATIC defined, and will be able to be built with\n\t# the static version of libwsutil.\n\t#\n\tset(dumpcap_FILES\n\t\tcli_main.c\n\t\tdumpcap.c\n\t\tringbuffer.c\n\t\tsync_pipe_write.c\n\t\tcapture/iface_monitor.c\n\t\tcapture/ws80211_utils.c\n\t\tui/capture_opts.c\n\t\t${CAPUTILS_SRC}\n\t)\n\tset_executable_resources(dumpcap \"Dumpcap\" UNIQUE_RC)\n\tadd_executable(dumpcap ${dumpcap_FILES})\n\tset_extra_executable_properties(dumpcap \"Executables\")\n\ttarget_link_libraries(dumpcap ${dumpcap_LIBS})\n\ttarget_include_directories(dumpcap SYSTEM PRIVATE ${ZLIB_INCLUDE_DIRS} ${ZLIBNG_INCLUDE_DIRS} ${NL_INCLUDE_DIRS})\n\ttarget_compile_definitions(dumpcap PRIVATE ENABLE_STATIC)\n\texecutable_link_mingw_unicode(dumpcap)\n\tinstall(TARGETS dumpcap\n\t\t\tRUNTIME\tDESTINATION ${CMAKE_INSTALL_BINDIR}\n\t\t\tPERMISSIONS ${DUMPCAP_SETUID}\n\t\t\t\tOWNER_READ OWNER_WRITE OWNER_EXECUTE\n\t\t\t\tGROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE\n\t)\n\tif(ENABLE_DUMPCAP_GROUP)\n\t\tinstall(CODE \"execute_process(COMMAND chgrp ${DUMPCAP_INSTALL_GROUP} ${CMAKE_INSTALL_FULL_BINDIR}/dumpcap)\")\n\t\tinstall(CODE \"execute_process(COMMAND chmod o-x ${CMAKE_INSTALL_FULL_BINDIR}/dumpcap)\")\n\tendif()\n\tif(DUMPCAP_INSTALL_OPTION STREQUAL \"capabilities\")\n\t\tinstall( CODE \"execute_process(\n\t\t\tCOMMAND\n\t\t\t\t${SETCAP_EXECUTABLE}\n\t\t\t\tcap_net_raw,cap_net_admin+ep\n\t\t\t\t${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_BINDIR}/dumpcap${CMAKE_EXECUTABLE_SUFFIX}\n\t\t\tRESULT_VARIABLE\n\t\t\t\t_SETCAP_RESULT\n\t\t\t)\n\t\t\tif( _SETCAP_RESULT )\n\t\t\t\tmessage( WARNING \\\"setcap failed (${_SETCAP_RESULT}).\\\")\n\t\t\tendif()\"\n\t\t)\n\tendif()\n\tif(BUILD_stratoshark AND ENABLE_APPLICATION_BUNDLE)\n\t\tadd_custom_command(TARGET dumpcap POST_BUILD\n\t\t\tCOMMAND ${CMAKE_COMMAND} -E copy_if_different\n\t\t\t\t$<TARGET_FILE:dumpcap> run/Stratoshark.app/Contents/MacOS/dumpcap\n\t\t)\n\tendif()\nelseif(BUILD_dumpcap AND ENABLE_PCAP)\n\tmessage(WARNING \"Dumpcap was requested but libpcap dependency is not available. \"\n\t\t\"Wireshark will be built without packet capture capability.\")\nendif()\n\n# We have two idl2wrs utilities: this and the CORBA version in tools.\n# We probably shouldn't do that.\nif(BUILD_dcerpcidl2wrs)\n\tset(idl2wrs_LIBS\n\t\twsutil\n\t)\n\tset(idl2wrs_FILES\n\t\tepan/dissectors/dcerpc/idl2wrs.c\n\t)\n\n\tadd_executable(idl2wrs ${idl2wrs_FILES})\n\tset_target_properties(idl2wrs PROPERTIES FOLDER \"Executables\")\n\tset_extra_executable_properties(idl2wrs \"Executables\")\n\ttarget_link_libraries(idl2wrs ${idl2wrs_LIBS})\n\tinstall(TARGETS idl2wrs RUNTIME\n\t\tDESTINATION ${CMAKE_INSTALL_BINDIR}\n\t\tCOMPONENT \"Development\"\n\t\tEXCLUDE_FROM_ALL\n\t)\nendif()\n\nif(WIN32)\n\tfind_package( MSVC_REDIST )\n\n\t# Must come after executable targets are defined.\n\tfind_package( NSIS )\n\n\tif(MAKENSIS_EXECUTABLE)\n\t\tadd_subdirectory( packaging/nsis EXCLUDE_FROM_ALL )\n\t\tADD_NSIS_PACKAGE_TARGETS()\n\tendif()\n\n\tfind_package( WiX )\n\n\tif(WIX_CANDLE_EXECUTABLE)\n\t\tadd_subdirectory( packaging/wix EXCLUDE_FROM_ALL )\n\t\tADD_WIX_PACKAGE_TARGET()\n\tendif()\n\n\tfind_package( PortableApps )\n\tif(PORTABLEAPPS_LAUNCHER_GENERATOR_EXECUTABLE AND PORTABLEAPPS_INSTALLER_EXECUTABLE)\n\t\tadd_subdirectory( packaging/portableapps EXCLUDE_FROM_ALL )\n\t\tADD_PORTABLEAPPS_PACKAGE_TARGET()\n\tendif()\nendif()\n\nif (MAXMINDDB_FOUND)\n\tset(mmdbresolve_LIBS\n\t\t# Note: libmaxminddb is not GPL-2 compatible.\n\t\t${MAXMINDDB_LIBRARY}\n\t\t# Needed for CMake-built libmaxminddb.lib <= 1.43.\n\t\t${WIN_WS2_32_LIBRARY}\n\t)\n\tset(mmdbresolve_FILES\n\t\tmmdbresolve.c\n\t)\n\tset_executable_resources(mmdbresolve \"Mmdbresolve\")\n\tadd_executable(mmdbresolve ${mmdbresolve_FILES})\n\tset_extra_executable_properties(mmdbresolve \"Executables\")\n\ttarget_link_libraries(mmdbresolve ${mmdbresolve_LIBS})\n\ttarget_include_directories(mmdbresolve PUBLIC ${MAXMINDDB_INCLUDE_DIRS})\n\ttarget_compile_definitions(mmdbresolve PUBLIC ${MAXMINDDB_DEFINITIONS})\n\tinstall(TARGETS mmdbresolve RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(ENABLE_APPLICATION_BUNDLE AND ASCIIDOCTOR_FOUND AND (BUILD_wireshark OR BUILD_stratoshark))\n\tset(_wireshark_foundation_donate \"packaging/macosx/Donate to the Wireshark Foundation.html\")\n\tASCIIDOCTOR2HTML(\"packaging/macosx/Donate_to_the_Wireshark_Foundation.adoc\"\n\t\tOUTPUT ${_wireshark_foundation_donate}\n\t\tCONVERT_UNDERSCORES\n\t)\nendif()\n\nif(ENABLE_APPLICATION_BUNDLE AND BUILD_wireshark)\n\tfile(MAKE_DIRECTORY \"${CMAKE_BINARY_DIR}/run/${CMAKE_CFG_INTDIR}/Wireshark.app/Contents/Resources/Extras\")\n\n\t# --preserve-xattr is undocumented but ensures that we install\n\t# a signed ChmodBPF script.\n\tset (_chmodbpf_version 1.2)\n\tset (install_chmodbpf_component_pkg \"${CMAKE_BINARY_DIR}/install.ChmodBPF.pkg\")\n\tadd_custom_command(OUTPUT \"${install_chmodbpf_component_pkg}\"\n\t\tCOMMAND find\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root\"\n\t\t\t-type d\n\t\t\t-exec chmod 755 \"{}\" +\n\t\tCOMMAND chmod 644\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/LaunchDaemons/org.wireshark.ChmodBPF.plist\"\n\t\tCOMMAND chmod 755\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/Application Support/Wireshark/ChmodBPF/ChmodBPF\"\n\t\tCOMMAND \"${CMAKE_SOURCE_DIR}/packaging/macosx/osx-extras.sh\"\n\t\tCOMMAND pkgbuild\n\t\t\t--identifier org.wireshark.ChmodBPF.pkg\n\t\t\t--version ${_chmodbpf_version}\n\t\t\t--preserve-xattr\n\t\t\t--root \"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root\"\n\t\t\t--scripts \"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-scripts\"\n\t\t\t${install_chmodbpf_component_pkg}\n\t\tDEPENDS\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/Application Support/Wireshark/ChmodBPF/ChmodBPF\"\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/LaunchDaemons/org.wireshark.ChmodBPF.plist\"\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-scripts/postinstall\"\n\t)\n\tset (install_chmodbpf_pkg \"${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Install ChmodBPF.pkg\")\n\tadd_custom_command(OUTPUT \"${install_chmodbpf_pkg}\"\n\t\tCOMMAND productbuild\n\t\t\t--identifier org.wireshark.install.ChmodBPF.product\n\t\t\t--version ${_chmodbpf_version}\n\t\t\t--distribution \"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-distribution.xml\"\n\t\t\t--package-path \"${CMAKE_BINARY_DIR}\"\n\t\t\t${install_chmodbpf_pkg}\n\t\tDEPENDS\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-distribution.xml\"\n\t\t\t${install_chmodbpf_component_pkg}\n\t)\n\n\tset (uninstall_chmodbpf_component_pkg \"${CMAKE_BINARY_DIR}/uninstall.ChmodBPF.pkg\")\n\tadd_custom_command(OUTPUT \"${uninstall_chmodbpf_component_pkg}\"\n\t\tCOMMAND pkgbuild\n\t\t\t--identifier org.wireshark.uninstall.ChmodBPF.pkg\n\t\t\t--version ${_chmodbpf_version}\n\t\t\t--nopayload\n\t\t\t--scripts \"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-scripts\"\n\t\t\t${uninstall_chmodbpf_component_pkg}\n\t\tDEPENDS\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-scripts/postinstall\"\n\t)\n\tset (uninstall_chmodbpf_pkg \"${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Uninstall ChmodBPF.pkg\")\n\tadd_custom_command(OUTPUT \"${uninstall_chmodbpf_pkg}\"\n\t\tCOMMAND productbuild\n\t\t\t--identifier org.wireshark.uninstall.ChmodBPF.product\n\t\t\t--version ${_chmodbpf_version}\n\t\t\t--distribution \"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-distribution.xml\"\n\t\t\t--package-path \"${CMAKE_BINARY_DIR}\"\n\t\t\t${uninstall_chmodbpf_pkg}\n\t\tDEPENDS\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-distribution.xml\"\n\t\t\t${uninstall_chmodbpf_component_pkg}\n\t)\n\n\tadd_custom_target(chmodbpf DEPENDS ${install_chmodbpf_pkg} ${uninstall_chmodbpf_pkg})\n\n\tset (_path_helper_version 1.1)\n\tset (install_path_helper_component_pkg \"${CMAKE_BINARY_DIR}/install.path_helper.pkg\")\n\tadd_custom_command(OUTPUT \"${install_path_helper_component_pkg}\"\n\t\tCOMMAND find\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/root\"\n\t\t\t-type d\n\t\t\t-exec chmod 755 \"{}\" +\n\t\tCOMMAND find\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/root\"\n\t\t\t-type f\n\t\t\t-exec chmod 644 \"{}\" +\n\t\tCOMMAND pkgbuild\n\t\t\t--identifier org.wireshark.path_helper.pkg\n\t\t\t--version ${_path_helper_version}\n\t\t\t--root \"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/root/etc\"\n\t\t\t--install-location /private/etc\n\t\t\t${install_path_helper_component_pkg}\n\t\tDEPENDS\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/root/etc/paths.d/Wireshark\"\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/root/etc/manpaths.d/Wireshark\"\n\t)\n\tset (install_path_helper_pkg \"${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Add Wireshark to the system path.pkg\")\n\tadd_custom_command(OUTPUT \"${install_path_helper_pkg}\"\n\t\tCOMMAND productbuild\n\t\t\t--identifier org.wireshark.install.path_helper.product\n\t\t\t--version ${_path_helper_version}\n\t\t\t--distribution \"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/install-distribution.xml\"\n\t\t\t--package-path \"${CMAKE_BINARY_DIR}\"\n\t\t\t${install_path_helper_pkg}\n\t\tDEPENDS\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/install-distribution.xml\"\n\t\t\t${install_path_helper_component_pkg}\n\t)\n\n\tset (uninstall_path_helper_component_pkg \"${CMAKE_BINARY_DIR}/uninstall.path_helper.pkg\")\n\tadd_custom_command(OUTPUT \"${uninstall_path_helper_component_pkg}\"\n\t\tCOMMAND pkgbuild\n\t\t\t--identifier org.wireshark.uninstall.path_helper.pkg\n\t\t\t--version ${_path_helper_version}\n\t\t\t--nopayload\n\t\t\t--scripts \"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-scripts\"\n\t\t\t${uninstall_path_helper_component_pkg}\n\t\tDEPENDS\n\t\t\t\"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-scripts/postinstall\"\n\t)\n\tset (uninstall_path_helper_pkg \"${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Remove Wireshark from the system path.pkg\")\n\tadd_custom_command(OUTPUT \"${uninstall_path_helper_pkg}\"\n\t\tCOMMAND productbuild\n\t\t\t--identifier org.wireshark.uninstall.path_helper.product\n\t\t\t--version ${_path_helper_version}\n\t\t\t--distribution \"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-distribution.xml\"\n\t\t\t--package-path \"${CMAKE_BINARY_DIR}\"\n\t\t\t${uninstall_path_helper_pkg}\n\t\tDEPENDS\n\t\t\t${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-distribution.xml\n\t\t\t${uninstall_path_helper_component_pkg}\n\t)\n\n\tadd_custom_target(path_helper DEPENDS ${install_path_helper_pkg} ${uninstall_path_helper_pkg})\n\n\tadd_custom_target(wireshark_app_bundle)\n\tset_target_properties(wireshark_app_bundle PROPERTIES FOLDER \"Copy Tasks\")\n\tadd_custom_command(TARGET wireshark_app_bundle\n\t\tPOST_BUILD\n\t\tCOMMAND \"${CMAKE_BINARY_DIR}/packaging/macosx/osx-app.sh\"\n\t\tWORKING_DIRECTORY \"${CMAKE_BINARY_DIR}/run\"\n\t)\n\tadd_dependencies(wireshark_app_bundle ${PROGLIST} chmodbpf path_helper)\n\n\tadd_custom_target(wireshark_dmg_prep DEPENDS wireshark_app_bundle)\n\n\tif (ASCIIDOCTOR_FOUND)\n\t\tset(_wireshark_read_me_first \"packaging/macosx/wireshark/Read me first.html\")\n\t\tASCIIDOCTOR2HTML(\"packaging/macosx/Wireshark_read_me_first.adoc\"\n\t\t\tOUTPUT ${_wireshark_read_me_first}\n\t\t\tCONVERT_UNDERSCORES\n\t\t)\n\n\t\tset(_wireshark_dsym_installation \"packaging/macosx/wireshark/Debugging symbols installation.html\")\n\t\tASCIIDOCTOR2HTML(\"packaging/macosx/Wireshark_dsym_installation.adoc\"\n\t\t\tOUTPUT ${_wireshark_dsym_installation}\n\t\t\tCONVERT_UNDERSCORES\n\t\t)\n\n\t\tadd_custom_target(wireshark_dmg_readmes DEPENDS ${_wireshark_read_me_first} ${_wireshark_foundation_donate} ${_wireshark_dsym_installation})\n\t\tadd_dependencies(wireshark_dmg_prep wireshark_dmg_readmes)\n\tendif()\n\n\tADD_CUSTOM_TARGET( wireshark_dmg\n\t\tCOMMAND bash -x ${CMAKE_BINARY_DIR}/packaging/macosx/osx-dmg.sh\n\t\t# Unlike wireshark_nsis_prep + wireshark_nsis, we can add a direct\n\t\t# dependency here.\n\t\tDEPENDS wireshark_dmg_prep\n\t\t# We create Wireshark.app in \"run\". Do our work there.\n\t\tWORKING_DIRECTORY ${CMAKE_BINARY_DIR}/run\n\t)\n\nendif()\n\nif(ENABLE_APPLICATION_BUNDLE AND BUILD_stratoshark)\n\tadd_custom_target(stratoshark_app_bundle)\n\tset_target_properties(stratoshark_app_bundle PROPERTIES FOLDER \"Copy Tasks\")\n\tadd_custom_command(TARGET stratoshark_app_bundle\n\t\tPOST_BUILD\n\t\tCOMMAND \"${CMAKE_BINARY_DIR}/packaging/macosx/osx-app.sh\" --bundle Stratoshark.app\n\t\tWORKING_DIRECTORY \"${CMAKE_BINARY_DIR}/run\"\n\t)\n\n\tadd_custom_target(stratoshark_dmg_prep DEPENDS stratoshark_app_bundle)\n\n\tif (ASCIIDOCTOR_FOUND)\n\t\tset(_stratoshark_read_me_first \"packaging/macosx/stratoshark/Read me first.html\")\n\t\tASCIIDOCTOR2HTML(\"packaging/macosx/Stratoshark_read_me_first.adoc\"\n\t\t\tOUTPUT ${_stratoshark_read_me_first}\n\t\t\tCONVERT_UNDERSCORES\n\t\t)\n\n\t\tset(_stratoshark_dsym_installation \"packaging/macosx/stratoshark/Debugging symbols installation.html\")\n\t\tASCIIDOCTOR2HTML(\"packaging/macosx/Stratoshark_dsym_installation.adoc\"\n\t\t\tOUTPUT ${_stratoshark_dsym_installation}\n\t\t\tCONVERT_UNDERSCORES\n\t\t)\n\n\t\tadd_custom_target(stratoshark_dmg_readmes DEPENDS ${_stratoshark_read_me_first} ${_wireshark_foundation_donate} ${_stratoshark_dsym_installation})\n\t\tadd_dependencies(stratoshark_dmg_prep stratoshark_dmg_readmes)\n\tendif()\n\n\tADD_CUSTOM_TARGET( stratoshark_dmg\n\t\tCOMMAND bash -x ${CMAKE_BINARY_DIR}/packaging/macosx/osx-dmg.sh --app-name Stratoshark\n\t\t# Unlike wireshark_nsis_prep + wireshark_nsis, we can add a direct\n\t\t# dependency here.\n\t\tDEPENDS stratoshark_dmg_prep\n\t\t# We create Wireshark.app in \"run\". Do our work there.\n\t\tWORKING_DIRECTORY ${CMAKE_BINARY_DIR}/run\n\t)\n\nendif()\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\tfind_program(RPMBUILD_EXECUTABLE rpmbuild)\n\tfind_program(GIT_EXECUTABLE git)\n\t# Should we add appimaged's monitored directories\n\t# as HINTS?\n\t# https://github.com/AppImage/appimaged\n\tfind_program(LINUXDEPLOY_EXECUTABLE NAMES linuxdeploy-x86_64.AppImage linuxdeploy)\n\tfind_program(_linuxdeploy_plugin_qt NAMES linuxdeploy-plugin-qt-x86_64.AppImage linuxdeploy-plugin-qt)\n\tfind_program(APPIMAGETOOL_EXECUTABLE NAMES appimagetool-x86_64.AppImage\n appimagetool)\nendif()\n\n\nstring(REPLACE \"-\" \"_\" RPM_VERSION \"${PROJECT_VERSION}\")\nconfigure_file(packaging/rpm/wireshark.spec.in ${CMAKE_BINARY_DIR}/packaging/rpm/SPECS/wireshark.spec)\nif(RPMBUILD_EXECUTABLE)\n\tforeach(_rpm_dir BUILD RPMS SOURCES SPECS SRPMS)\n\t\tfile(MAKE_DIRECTORY \"${CMAKE_BINARY_DIR}/packaging/rpm/${_rpm_dir}\")\n\tendforeach()\n\n\tset(_rpmbuild_with_args)\n\t#\n\t# This is ugly.\n\t#\n\t# At least some versions of rpmbuild define the cmake_build\n\t# macro to run \"cmake --build\" with the \"--verbose\" option,\n\t# with no obvious way to easily override that, so, if you\n\t# are doing a build with lots of source files, and with\n\t# lots of compiler options (for example, a log of -W flags),\n\t# you can get a lot of output from rpmbuild.\n\t#\n\t# Wireshark is a program with lots of source files and\n\t# lots of compiler options.\n\t#\n\t# GitLab's shared builders have a limit of 4MB on logs\n\t# from build jobs.\n\t#\n\t# Wireshark uses the shared builders, and can produce\n\t# more than 4MB with the Fedora RPM build; this causes\n\t# the builds to fail.\n\t#\n\t# Forcibly overriding the cmake_build macro with a\n\t# version that lacks the --version file should\n\t# prevent ninja from being run with the -v flag,\n\t# so that it prints the compact output rather\n\t# than the raw command.\n\t#\n\t# We don't do that by default; if the build has the\n\t# FORCE_CMAKE_NINJA_QUIET environment variable set,\n\t# it will add it.\n\t#\n\tif(DEFINED ENV{FORCE_CMAKE_NINJA_NON_VERBOSE})\n\t\t#\n\t\t# Get the output of a pipeline running\n\t\t# \"rpmbuild --showrc\", to find the settings\n\t\t# of all macros, piped to an awk script\n\t\t# to extract the value of the cmake_build\n\t\t# macro.\n\t\t#\n\t\texecute_process(\n\t\t\tCOMMAND rpmbuild --showrc\n\t\t\tCOMMAND awk \"/: cmake_build/ { getline; print \\$0; exit }\"\n\t\t\tOUTPUT_VARIABLE CMAKE_BUILD_VALUE\n\t\t\tOUTPUT_STRIP_TRAILING_WHITESPACE)\n\t\tif (CMAKE_BUILD_VALUE MATCHES \".*--verbose.*\")\n\t\t\t#\n\t\t\t# OK, the setting contains \"--verbose\".\n\t\t\t# Rip it out.\n\t\t\t#\n\t\t\tstring(REPLACE \"--verbose\" \"\"\n\t\t\t\tNON_VERBOSE_CMAKE_BUILD_VALUE\n\t\t\t\t${CMAKE_BUILD_VALUE})\n\t\t\tlist(APPEND _rpmbuild_with_args --define \"cmake_build ${NON_VERBOSE_CMAKE_BUILD_VALUE}\")\n\t\tendif()\n\telse()\n\t\tif(CMAKE_VERBOSE_MAKEFILE)\n\t\t\tlist(APPEND _rpmbuild_with_args -v)\n\t\tendif()\n\tendif()\n\tif(CMAKE_C_COMPILER_ID STREQUAL \"Clang\")\n\t\tlist(APPEND _rpmbuild_with_args --with toolchain_clang)\n\tendif()\n\tif(CMAKE_GENERATOR STREQUAL \"Ninja\")\n\t\tlist(APPEND _rpmbuild_with_args --with ninja)\n\tendif()\n\tif(CCACHE_EXECUTABLE)\n\t\tlist(APPEND _rpmbuild_with_args --with ccache)\n\tendif()\n\tif(NOT BUILD_wireshark)\n\t\tlist(APPEND _rpmbuild_with_args --without qt5 --without qt6)\n\telseif(USE_qt6)\n\t\tlist(APPEND _rpmbuild_with_args --without qt5 --with qt6)\n\telse()\n\t\tlist(APPEND _rpmbuild_with_args --with qt5 --without qt6)\n\tendif()\n\tif (MAXMINDDB_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with mmdbresolve)\n\tendif()\n\tif (LUA_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with lua)\n\tendif()\n\tif (LZ4_FOUND AND SNAPPY_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with lz4_and_snappy)\n\tendif()\n\tif (SPANDSP_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with spandsp)\n\tendif()\n\tif (BCG729_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with bcg729)\n\tendif()\n\tif (AMRNB_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with amrnb)\n\tendif()\n\tif (ILBC_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with ilbc)\n\tendif()\n\tif (OPUS_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with opus)\n\tendif()\n\tif (LIBXML2_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with libxml2)\n\tendif()\n\tif (NGHTTP2_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with nghttp2)\n\tendif()\n\tif (NGHTTP3_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with nghttp3)\n\tendif()\n\tif (SYSTEMD_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with sdjournal)\n\tendif()\n\tif (BROTLI_FOUND)\n\t\tlist(APPEND _rpmbuild_with_args --with brotli)\n\tendif()\n\tif(ASCIIDOCTOR_FOUND AND XSLTPROC_EXECUTABLE)\n\t\tlist(APPEND _rpmbuild_with_args --with guides)\n\tendif()\n\n\texecute_process(\n\t\tCOMMAND ${Python3_EXECUTABLE}\n\t\t\t${CMAKE_SOURCE_DIR}/tools/make-version.py\n\t\t\t${CMAKE_SOURCE_DIR}\n\t)\n\n\tadd_custom_target(copy-dist\n\t\tCOMMAND cp ${CMAKE_BINARY_DIR}/wireshark*tar* ${CMAKE_BINARY_DIR}/packaging/rpm/SOURCES/\n\t\tDEPENDS dist\n\t)\n\tadd_custom_target(wireshark_rpm\n\t\tCOMMAND ${RPMBUILD_EXECUTABLE}\n\t\t\t--define \"_topdir ${CMAKE_BINARY_DIR}/packaging/rpm\"\n\t\t\t--define \"_prefix ${CMAKE_INSTALL_PREFIX}\"\n\t\t\t${_rpmbuild_with_args}\n\t\t\t-ba SPECS/wireshark.spec\n\t\tDEPENDS copy-dist\n\t\tWORKING_DIRECTORY \"${CMAKE_BINARY_DIR}/packaging/rpm\"\n\t\tCOMMENT \"Create a rpm from the current git commit.\"\n\t)\nendif()\n\nif(BUILD_wireshark AND QT_FOUND AND LINUXDEPLOY_EXECUTABLE AND _linuxdeploy_plugin_qt AND APPIMAGETOOL_EXECUTABLE)\n\tconfigure_file(packaging/appimage/Wireshark-AppRun.in ${CMAKE_BINARY_DIR}/packaging/appimage/Wireshark-AppRun @ONLY)\n\t# Require production builds (/usr + Release).\n\tif (CMAKE_BUILD_TYPE STREQUAL \"Release\" AND CMAKE_INSTALL_PREFIX STREQUAL \"/usr\" )\n\t\tadd_custom_target(wireshark_appimage_prerequisites)\n\t\tadd_dependencies(wireshark_appimage_prerequisites ${PROGLIST})\n\telse()\n\t\tadd_custom_target(wireshark_appimage_prerequisites\n\t\t\tCOMMAND echo \"CMAKE_BUILD_TYPE isn't Release or CMAKE_INSTALL_PREFIX isn't /usr.\"\n\t\t\tCOMMAND false\n\t\t)\n\tendif()\n\tset (_wireshark_ai_appdir ${CMAKE_BINARY_DIR}/packaging/appimage/wireshark.appdir)\n\tadd_custom_target(wireshark_appimage_appdir\n\t\tCOMMAND ${CMAKE_COMMAND} -E make_directory ${_wireshark_ai_appdir}\n\t\tCOMMAND env DESTDIR=${_wireshark_ai_appdir}\n\t\t\t${CMAKE_COMMAND} --build . --target install\n\t\tDEPENDS wireshark_appimage_prerequisites\n\t)\n\tset(_wireshark_appimage_exe_args)\n\tforeach(_prog ${PROGLIST})\n\t\t# XXX This needs to be more robust.\n\t\tif (${_prog} STREQUAL \"dftest\" OR ${_prog} STREQUAL \"stratoshark\")\n\t\t\tcontinue()\n\t\tendif()\n\t\tlist(APPEND _wireshark_appimage_exe_args --executable=${_wireshark_ai_appdir}/usr/bin/${_prog})\n\tendforeach()\n\t# It looks like linuxdeploy can't handle executables in nonstandard\n\t# locations, so use it to prep our staging directory here and use\n\t# appimagetool to to build the appimage.\n\tadd_custom_target(wireshark_appimage_prep\n\t\tCOMMAND env LD_LIBRARY_PATH=${_wireshark_ai_appdir}/${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR} ${LINUXDEPLOY_EXECUTABLE}\n\t\t\t--appdir=${_wireshark_ai_appdir}\n\t\t\t${_wireshark_appimage_exe_args}\n\t\t\t--desktop-file=${_wireshark_ai_appdir}/usr/share/applications/org.wireshark.Wireshark.desktop\n\t\t\t--icon-file=${CMAKE_SOURCE_DIR}/resources/icons/wsicon256.png\n\t\t\t--custom-apprun=${CMAKE_BINARY_DIR}/packaging/appimage/Wireshark-AppRun\n\t\t\t--plugin=qt\n\t\tDEPENDS wireshark_appimage_appdir\n\t)\n\tadd_custom_target(wireshark_appimage\n\t\tCOMMAND env VERSION=${PROJECT_VERSION} ${APPIMAGETOOL_EXECUTABLE} ${_wireshark_ai_appdir}\n\t\tDEPENDS wireshark_appimage_prep\n\t)\nendif()\n\nif(BUILD_stratoshark AND QT_FOUND AND LINUXDEPLOY_EXECUTABLE AND _linuxdeploy_plugin_qt AND APPIMAGETOOL_EXECUTABLE)\n\tconfigure_file(packaging/appimage/Stratoshark-AppRun.in ${CMAKE_BINARY_DIR}/packaging/appimage/Stratoshark-AppRun @ONLY)\n\t# Require production builds (/usr + Release).\n\tif (CMAKE_BUILD_TYPE STREQUAL \"Release\" AND CMAKE_INSTALL_PREFIX STREQUAL \"/usr\" )\n\t\tadd_custom_target(stratoshark_appimage_prerequisites)\n\t\tadd_dependencies(stratoshark_appimage_prerequisites ${PROGLIST})\n\telse()\n\t\tadd_custom_target(stratoshark_appimage_prerequisites\n\t\t\tCOMMAND echo \"CMAKE_BUILD_TYPE isn't Release or CMAKE_INSTALL_PREFIX isn't /usr.\"\n\t\t\tCOMMAND false\n\t\t)\n\tendif()\n\tset (_stratoshark_ai_appdir ${CMAKE_BINARY_DIR}/packaging/appimage/stratoshark.appdir)\n\tadd_custom_target(stratoshark_appimage_appdir\n\t\tCOMMAND ${CMAKE_COMMAND} -E make_directory ${_stratoshark_ai_appdir}\n\t\tCOMMAND env DESTDIR=${_stratoshark_ai_appdir}\n\t\t\t${CMAKE_COMMAND} --build . --target install\n\t\tDEPENDS stratoshark_appimage_prerequisites\n\t)\n\tset(_stratoshark_appimage_exe_args)\n\tforeach(_prog ${PROGLIST})\n\t\t# XXX This needs to be more robust.\n\t\tif (${_prog} STREQUAL \"dftest\" OR ${_prog} STREQUAL \"stratoshark\")\n\t\t\tcontinue()\n\t\tendif()\n\t\tlist(APPEND _stratoshark_appimage_exe_args --executable=${_stratoshark_ai_appdir}/usr/bin/${_prog})\n\tendforeach()\n\t# It looks like linuxdeploy can't handle executables in nonstandard\n\t# locations, so use it to prep our staging directory here and use\n\t# appimagetool to to build the appimage.\n\tadd_custom_target(stratoshark_appimage_prep\n\t\tCOMMAND env LD_LIBRARY_PATH=${_stratoshark_ai_appdir}/${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR} ${LINUXDEPLOY_EXECUTABLE}\n\t\t\t--appdir=${_stratoshark_ai_appdir}\n\t\t\t${_stratoshark_appimage_exe_args}\n\t\t\t--desktop-file=${_stratoshark_ai_appdir}/usr/share/applications/org.wireshark.Stratoshark.desktop\n\t\t\t--icon-file=${CMAKE_SOURCE_DIR}/resources/icons/ssicon256.png\n\t\t\t--custom-apprun=${CMAKE_BINARY_DIR}/packaging/appimage/Stratoshark-AppRun\n\t\t\t--plugin=qt\n\t\tDEPENDS stratoshark_appimage_appdir\n\t)\n\tadd_custom_target(stratoshark_appimage\n\t\tCOMMAND env VERSION=${STRATOSHARK_VERSION} ${APPIMAGETOOL_EXECUTABLE} ${_stratoshark_ai_appdir}\n\t\tDEPENDS stratoshark_appimage_prep\n\t)\nendif()\n\nset(CLEAN_C_FILES\n\t${dumpcap_FILES}\n\t${wireshark_FILES}\n\t${stratoshark_FILES}\n\t${tshark_FILES}\n\t${tfshark_FILES}\n\t${rawshark_FILES}\n\t${dftest_FILES}\n\t${randpkt_FILES}\n\t${randpktdump_FILES}\n\t${etwdump_FILES}\n\t${falcodump_FILES}\n\t${udpdump_FILES}\n\t${text2pcap_FILES}\n\t${mergecap_FILES}\n\t${capinfos_FILES}\n\t${captype_FILES}\n\t${editcap_FILES}\n\t${idl2wrs_FILES}\n\t${mmdbresolve_FILES}\n\t${sharkd_FILES}\n)\n\nif(CLEAN_C_FILES)\n\t# Make sure we don't pass /WX to rc.exe. Rc doesn't have a /WX flag,\n\t# but it does have /W (warn about invalid code pages) and /X (ignore\n\t# the INCLUDE environment variable).\n\t# This should apparently be handled for us via CMAKE_RC_FLAG_REGEX\n\t# in CMakeRCInformation.cmake but that doesn't appear to work.\n\tif(WIN32)\n\t\tlist(FILTER CLEAN_C_FILES EXCLUDE REGEX \".*\\\\.rc\")\n\tendif()\n\n\t# XXX This also contains object files ($<TARGET_OBJECTS:...>), is that an issue?\n\tset_source_files_properties(\n\t\t${CLEAN_C_FILES}\n\t\tPROPERTIES\n\t\tCOMPILE_FLAGS \"${WERROR_COMMON_FLAGS}\"\n\t)\nendif()\n\ninstall(\n\tFILES\n\t\t${INSTALL_FILES}\n\tPERMISSIONS\n\t\tOWNER_WRITE OWNER_READ\n\t\tGROUP_READ\n\t\tWORLD_READ\n\tDESTINATION\n\t\t${CMAKE_INSTALL_DATADIR}/${PROJECT_NAME}\n)\n\nif (BUILD_stratoshark)\n\tinstall(\n\t\tFILES\n\t\t\t${STRATOSHARK_INSTALL_FILES}\n\t\tPERMISSIONS\n\t\t\tOWNER_WRITE OWNER_READ\n\t\t\tGROUP_READ\n\t\t\tWORLD_READ\n\t\tDESTINATION\n\t\t\t${CMAKE_INSTALL_DATADIR}/${STRATOSHARK_NAME}\n\t)\nendif()\n\ninstall(\n\tFILES\n\t\t${DOC_FILES}\n\tDESTINATION\n\t\t${CMAKE_INSTALL_DOCDIR}\n)\n\nif(ASCIIDOCTOR_FOUND AND XSLTPROC_EXECUTABLE)\n\tinstall(\n\t\tDIRECTORY \"${CMAKE_BINARY_DIR}/doc/wsug_html_chunked\"\n\t\tDESTINATION \"${CMAKE_INSTALL_DOCDIR}\"\n\t\tCOMPONENT \"UserGuide\"\n\t\tEXCLUDE_FROM_ALL\n\t)\n\tinstall(\n\t\tDIRECTORY \"${CMAKE_BINARY_DIR}/doc/wsdg_html_chunked\"\n\t\tDESTINATION \"${CMAKE_INSTALL_DOCDIR}\"\n\t\tCOMPONENT \"DeveloperGuide\"\n\t\tEXCLUDE_FROM_ALL\n\t)\nendif()\n\nset(SHARK_PUBLIC_HEADERS\n\tcfile.h\n\tcli_main.h\n\tfile.h\n\tinclude/ws_attributes.h\n\tinclude/ws_codepoints.h\n\tinclude/ws_compiler_tests.h\n\tinclude/ws_diag_control.h\n\tinclude/ws_exit_codes.h\n\tinclude/ws_log_defs.h\n\tinclude/ws_posix_compat.h\n\tinclude/ws_symbol_export.h\n\tinclude/wireshark.h\n\t${CMAKE_BINARY_DIR}/ws_version.h\n)\n\ninstall(FILES ${SHARK_PUBLIC_HEADERS}\n\tDESTINATION ${PROJECT_INSTALL_INCLUDEDIR}\n\tCOMPONENT \"Development\"\n\tEXCLUDE_FROM_ALL\n)\n\n# Install icons and other desktop files for Freedesktop.org-compliant desktops.\nif(BUILD_wireshark AND QT_FOUND AND NOT APPLE AND (NOT WIN32 OR USE_MSYSTEM))\n\tinstall(FILES resources/freedesktop/org.wireshark.Wireshark-mime.xml\n\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/mime/packages\"\n\t\tRENAME org.wireshark.Wireshark.xml\n\t)\n\tinstall(FILES resources/freedesktop/org.wireshark.Wireshark.metainfo.xml\n\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/metainfo\"\n\t)\n\tif(BUILD_wireshark AND QT_FOUND)\n\t\tinstall(FILES resources/freedesktop/org.wireshark.Wireshark.desktop\n\t\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/applications\")\n\tendif()\n\tforeach(size 16 24 32 48 64 128 256)\n\t\tinstall(FILES resources/icons/wsicon${size}.png\n\t\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/icons/hicolor/${size}x${size}/apps\"\n\t\t\tRENAME org.wireshark.Wireshark.png)\n\t\tinstall(FILES resources/icons/WiresharkDoc-${size}.png\n\t\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/icons/hicolor/${size}x${size}/mimetypes\"\n\t\t\tRENAME org.wireshark.Wireshark-mimetype.png)\n\tendforeach()\nendif()\n\nif(BUILD_stratoshark AND QT_FOUND AND NOT APPLE AND (NOT WIN32 OR USE_MSYSTEM))\n\tinstall(FILES resources/freedesktop/org.wireshark.Stratoshark-mime.xml\n\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/mime/packages\"\n\t\tRENAME org.wireshark.Stratoshark.xml\n\t)\n\tinstall(FILES resources/freedesktop/org.wireshark.Stratoshark.metainfo.xml\n\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/metainfo\"\n\t)\n\tif(BUILD_wireshark AND QT_FOUND)\n\t\tinstall(FILES resources/freedesktop/org.wireshark.Stratoshark.desktop\n\t\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/applications\")\n\tendif()\n\tforeach(size 16 32 48 64 128 256)\n\t\tinstall(FILES resources/icons/ssicon${size}.png\n\t\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/icons/hicolor/${size}x${size}/apps\"\n\t\t\tRENAME org.wireshark.Stratoshark.png)\n\t\tinstall(FILES resources/icons/WiresharkDoc-${size}.png\n\t\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/icons/hicolor/${size}x${size}/mimetypes\"\n\t\t\tRENAME org.wireshark.Stratoshark-mimetype.png)\n\tendforeach()\n\tinstall(FILES resources/icons/ssicon.svg\n\t\tDESTINATION \"${CMAKE_INSTALL_DATAROOTDIR}/icons/hicolor/scalable/apps\"\n\t\tRENAME org.wireshark.Stratoshark.svg)\nendif()\n\ninstall(FILES \"${CMAKE_BINARY_DIR}/resources/wireshark.pc\"\n\tDESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig\n\tCOMPONENT \"Development\"\n\tEXCLUDE_FROM_ALL\n)\n\ninstall(\n\tDIRECTORY\n\t\t${INSTALL_DIRS}\n\tDESTINATION\n\t\t${CMAKE_INSTALL_DATADIR}/${PROJECT_NAME}\n\tFILE_PERMISSIONS\n\t\tOWNER_WRITE OWNER_READ\n\t\tGROUP_READ\n\t\tWORLD_READ\n\tDIRECTORY_PERMISSIONS\n\t\tOWNER_EXECUTE OWNER_WRITE OWNER_READ\n\t\tGROUP_EXECUTE GROUP_READ\n\t\tWORLD_EXECUTE WORLD_READ\n\tPATTERN \".git\" EXCLUDE\n\tPATTERN \".svn\" EXCLUDE\n\tPATTERN \"Makefile.*\" EXCLUDE\n)\n\nif (BUILD_stratoshark)\n\tinstall(\n\t\tDIRECTORY\n\t\t\t${STRATOSHARK_INSTALL_DIRS}\n\t\tDESTINATION\n\t\t\t${CMAKE_INSTALL_DATADIR}/${STRATOSHARK_NAME}\n\t\tFILE_PERMISSIONS\n\t\t\tOWNER_WRITE OWNER_READ\n\t\t\tGROUP_READ\n\t\t\tWORLD_READ\n\t\tDIRECTORY_PERMISSIONS\n\t\t\tOWNER_EXECUTE OWNER_WRITE OWNER_READ\n\t\t\tGROUP_EXECUTE GROUP_READ\n\t\t\tWORLD_EXECUTE WORLD_READ\n\t\tPATTERN \".git\" EXCLUDE\n\t\tPATTERN \".svn\" EXCLUDE\n\t\tPATTERN \"Makefile.*\" EXCLUDE\n\t)\nendif()\n\nif(WIN32 AND NOT USE_MSYSTEM)\n\t# Note: CMake export mechanism misbehaves with a '.' in the\n\t# path (incorrect relative path computation).\n\tset(WIRESHARK_INSTALL_CMAKEDIR \"cmake\")\nelse()\n\tset(WIRESHARK_INSTALL_CMAKEDIR \"${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\")\nendif()\n\ninclude(CMakePackageConfigHelpers)\n\nconfigure_package_config_file(WiresharkConfig.cmake.in\n\t${CMAKE_BINARY_DIR}/WiresharkConfig.cmake\n\tINSTALL_DESTINATION ${WIRESHARK_INSTALL_CMAKEDIR}\n\tPATH_VARS\n\t\tCMAKE_INSTALL_LIBDIR\n\t\tCMAKE_INSTALL_INCLUDEDIR\n\t\tPLUGIN_INSTALL_VERSION_LIBDIR\n\t\tEXTCAP_INSTALL_LIBDIR\n)\n\nwrite_basic_package_version_file(\n\t${CMAKE_BINARY_DIR}/WiresharkConfigVersion.cmake\n\tCOMPATIBILITY AnyNewerVersion\n)\n\ninstall(\n\tFILES\n\t\t${CMAKE_BINARY_DIR}/WiresharkConfig.cmake\n\t\t${CMAKE_BINARY_DIR}/WiresharkConfigVersion.cmake\n\tDESTINATION\n\t\t${WIRESHARK_INSTALL_CMAKEDIR}\n\tCOMPONENT\n\t\t\"Development\"\n\tEXCLUDE_FROM_ALL\n)\n\ninstall(EXPORT WiresharkTargets\n\tDESTINATION ${WIRESHARK_INSTALL_CMAKEDIR}\n\tCOMPONENT \"Development\"\n\tEXCLUDE_FROM_ALL\n)\n\n# This isn't strictly needed but it makes working around debhelper's\n# cleverness a lot easier.\nadd_custom_target(install-headers\n\tCOMMAND ${CMAKE_COMMAND} -DCOMPONENT=Development -P cmake_install.cmake\n)\n\nif (DOXYGEN_EXECUTABLE)\n\t# API reference\n\t# We don't have a good way of tracking dependencies, so we simply\n\t# recreate the whole thing from scratch each time.\n\tadd_custom_target(wsar_html\n\t\tCOMMAND ${CMAKE_COMMAND} -E remove_directory wsar_html\n\t\tCOMMAND ${DOXYGEN_EXECUTABLE} doxygen.cfg\n\t)\n\n\tif(WIN32 AND NOT USE_MSYSTEM)\n\t\tadd_custom_target(wsar_html_perms DEPENDS wsar_html)\n\telse()\n\t\tadd_custom_target(wsar_html_perms\n\t\t\tCOMMAND find wsar_html\n\t\t\t\t-type d\n\t\t\t\t-exec chmod 755 \"{}\" +\n\t\t\tCOMMAND find wsar_html\n\t\t\t\t-type f\n\t\t\t\t-exec chmod 644 \"{}\" +\n\t\t\tDEPENDS wsar_html)\n\tendif()\n\n\tadd_custom_target(wsar_html_zip\n\t\tCOMMAND ${CMAKE_COMMAND} -E tar \"cfv\" \"wsar_html.zip\" --format=zip wsar_html\n\t\tDEPENDS wsar_html_perms\n\t)\n\tset_target_properties(wsar_html wsar_html_zip PROPERTIES\n\t\tFOLDER \"Documentation\"\n\t\tEXCLUDE_FROM_DEFAULT_BUILD True\n\t)\nendif(DOXYGEN_EXECUTABLE)\n\nadd_custom_target(test-programs\n\tDEPENDS exntest\n\t\tfifo_string_cache_test\n\t\toids_test\n\t\treassemble_test\n\t\ttvbtest\n\t\twmem_test\n\t\twscbor_test\n\t\ttest_epan\n\t\ttest_wsutil\n\tCOMMENT \"Building unit test programs and wrapper\"\n)\nset_target_properties(test-programs PROPERTIES\n\tFOLDER \"Tests\"\n\tEXCLUDE_FROM_DEFAULT_BUILD True\n)\n\n# Add target to enable capturing from the build directory. Requires Linux capabilities\n# and running with sudo.\nif(TARGET dumpcap AND SETCAP_EXECUTABLE)\n\tadd_custom_target(test-capture\n\t\tCOMMAND ${SETCAP_EXECUTABLE} cap_net_raw,cap_net_admin+ep $<TARGET_FILE:dumpcap>\n\t)\nendif()\n\nadd_custom_target(test\n\tCOMMAND ${CMAKE_COMMAND} -E env PYTHONIOENCODING=UTF-8\n\t\t${Python3_EXECUTABLE} -m pytest\n\t\t${TEST_EXTRA_ARGS}\n\tWORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n\tDEPENDS test-programs\n\tUSES_TERMINAL\n)\n\n# Make it possible to run pytest without passing the full path as argument.\nif(NOT CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)\n\tfile(READ \"${CMAKE_CURRENT_SOURCE_DIR}/pytest.ini\" pytest_ini)\n\tstring(REGEX REPLACE \"\\naddopts = ([^\\n]+)\"\n\t\t\"\\naddopts = ${CMAKE_CURRENT_SOURCE_DIR}/test \\\\1\"\n\t\tpytest_ini \"${pytest_ini}\")\n\tfile(WRITE \"${CMAKE_BINARY_DIR}/pytest.ini\" \"${pytest_ini}\")\nendif()\n\nif (GIT_EXECUTABLE)\n\t# Update AUTHORS file with entries from git shortlog\n\tadd_custom_target(\n\t\tgen-authors\n\t\tCOMMAND ${Python3_EXECUTABLE} tools/generate_authors.py AUTHORS\n\t\tWORKING_DIRECTORY ${CMAKE_SOURCE_DIR}\n\t)\nelse (GIT_EXECUTABLE)\n\tadd_custom_target( gen-authors COMMAND ${CMAKE_COMMAND} -E echo \"Git not found.\" )\nendif (GIT_EXECUTABLE)\nset_target_properties(gen-authors PROPERTIES FOLDER \"Documentation\")\n\nif(WIN32 AND NOT USE_MSYSTEM)\n\tfile (TO_NATIVE_PATH ${CMAKE_SOURCE_DIR}/tools/Get-HardenFlags.ps1 _win_harden_flags)\n\tadd_custom_target(hardening-check\n\t\tCOMMAND ${POWERSHELL_COMMAND} \"${_win_harden_flags}\" \"${_dll_output_dir_win}\"\n\t\tDEPENDS ${PROGLIST}\n\t\tCOMMENT \"Checking binaries for security features\"\n\t)\n\tset_target_properties(hardening-check PROPERTIES FOLDER \"Tests\")\nelse()\n\tfind_program(HARDENING_CHECK_EXECUTABLE hardening-check\n\t\tDOC \"Path to the hardening-check utility.\"\n\t)\n\tif(HARDENING_CHECK_EXECUTABLE)\n\t\tforeach(_prog ${PROGLIST})\n\t\t\tget_target_property(_prog_dir ${_prog} RUNTIME_OUTPUT_DIRECTORY)\n\t\t\tif(NOT _prog_dir)\n\t\t\t\tset(_prog_dir \"${CMAKE_BINARY_DIR}/run\")\n\t\t\tendif()\n\t\t\tset(_prog_paths ${_prog_paths} \"${_prog_dir}/${_prog}\")\n\t\tendforeach()\n\t\tadd_custom_target(hardening-check\n\t\t\tCOMMAND ${HARDENING_CHECK_EXECUTABLE} ${_prog_paths}\n\t\t\tDEPENDS ${PROGLIST}\n\t\t\tCOMMENT \"Checking binaries for security features\"\n\t\t)\n\tendif()\nendif()\n\nCHECKAPI(\n\tNAME\n\t  main\n\tSWITCHES\n\tSOURCES\n\t  ${WIRESHARK_SRC}\n\t  ${TSHARK_TAP_SRC}\n)\n\nfind_program(SHELLCHECK_EXECUTABLE shellcheck\n\tDOC \"Path to the shellcheck utility.\"\n)\nif(SHELLCHECK_EXECUTABLE)\n\tadd_custom_target(shellcheck)\n\tset_target_properties(shellcheck PROPERTIES FOLDER \"Tests\")\n\t# --external-sources requires 0.4.0 or later.\n\t# ChmodBPF uses \"shellcheck shell=bash\". Not sure which version\n\t# added support for that.\n\tadd_custom_command(TARGET shellcheck POST_BUILD\n\t\tCOMMAND shellcheck --external-sources\n\t\t\tresources/stock_icons/svg-to-png.sh\n\t\t\tresources/stock_icons/layouts-to-png.sh\n\t\t\tpackaging/appimage/Stratoshark-AppRun.in\n\t\t\tpackaging/appimage/Wireshark-AppRun.in\n\t\t\t\"packaging/macosx/ChmodBPF/root/Library/Application Support/Wireshark/ChmodBPF/ChmodBPF\"\n\t\t\tpackaging/macosx/osx-app.sh.in\n\t\t\tpackaging/macosx/osx-dmg.sh.in\n\t\t\tpackaging/source/git-export-release.sh.in\n\t\t\ttools/arch-setup.sh\n\t\t\ttools/bsd-setup.sh\n\t\t\ttools/debian-setup.sh\n\t\t\ttools/fuzz-test.sh\n\t\t\ttools/gen-bugnote\n\t\t\ttools/macos-setup-brew.sh\n\t\t\ttools/pre-commit\n\t\t\ttools/randpkt-test.sh\n\t\t\ttools/release-update-debian-soversions.sh\n\t\t\ttools/rpm-setup.sh\n\t\t\ttools/test-captures.sh\n\t\t\ttools/update-tx\n\t\t\ttools/valgrind-wireshark.sh\n\t\tWORKING_DIRECTORY \"${CMAKE_SOURCE_DIR}\"\n\t)\nendif()\n\n# uninstall target\nconfigure_file(\n\t\"${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in\"\n\t\"${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake\"\n\tIMMEDIATE @ONLY)\n\nadd_custom_target(uninstall\n\tCOMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)\n\n# Break on programmer errors when debugging in Visual Studio\nif(MSVC)\n\tget_property(_targets DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY BUILDSYSTEM_TARGETS)\n\tforeach(_target ${_targets})\n\t\tset_target_properties(${_target} PROPERTIES VS_DEBUGGER_ENVIRONMENT \"G_DEBUG=fatal-criticals\")\n\tendforeach()\nendif()\n\n# -----------------------------------------------------------------------------\n# Packaging (CPack)\n# -----------------------------------------------------------------------------\ninclude(ConfigCPack.cmake)\n\n#\n# Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n#\n# Local variables:\n# c-basic-offset: 8\n# tab-width: 8\n# indent-tabs-mode: t\n# End:\n#\n# vi: set shiftwidth=8 tabstop=8 noexpandtab:\n# :indentSize=8:tabSize=8:noTabs=false:\n#\n"
        },
        {
          "name": "CMakeListsCustom.txt.example",
          "type": "blob",
          "size": 1.2041015625,
          "content": "# CMakeListsCustom.txt\n#\n# Wireshark - Network traffic analyzer\n# By Gerald Combs <gerald@wireshark.org>\n# Copyright 1998 Gerald Combs\n#\n# SPDX-License-Identifier: GPL-2.0-or-later\n#\n# Add a list of your custom plugins SRC dir here including the path\n#\n\n# Fail CMake stage if any of these plugins are missing from source tree\nset(CUSTOM_PLUGIN_SRC_DIR\n#\tprivate_plugins/foo\n# or\n#\tplugins/epan/foo\n)\n\n# Do not fail CMake stage if any of the optional plugins are missing from source tree\nset(_OPTIONAL_CUSTOM_PLUGIN_SRC_DIR\n#\tplugins/epan/bar\n)\n\n# Add your custom TShark taps here\nset(CUSTOM_TSHARK_TAP_SRC\n#\tui/cli/tap-baz.c\n)\n\n# This loop handles supporting optional plugins\nforeach(  _plugin_dir ${_OPTIONAL_CUSTOM_PLUGIN_SRC_DIR} )\n\tif( EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${_plugin_dir}/CMakeLists.txt )\n\t\tlist( APPEND CUSTOM_PLUGIN_SRC_DIR ${_plugin_dir} )\n\telse()\n\t\tmessage( WARNING \"Custom plugins: No ${_plugin_dir}/CMakeLists.txt file found - ignoring\" )\n\tendif()\nendforeach()\n\n#\n# Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n#\n# Local variables:\n# c-basic-offset: 8\n# tab-width: 8\n# indent-tabs-mode: t\n# End:\n#\n# vi: set shiftwidth=8 tabstop=8 noexpandtab:\n# :indentSize=8:tabSize=8:noTabs=false:\n#\n"
        },
        {
          "name": "CMakeOptions.txt",
          "type": "blob",
          "size": 7.255859375,
          "content": "# Build options for use by CMake\n\noption(BUILD_wireshark     \"Build Wireshark\" ON)\noption(BUILD_stratoshark   \"Build Stratoshark\" OFF)\nif(BUILD_wireshark OR BUILD_stratoshark)\n\toption(USE_qt6     \"Use Qt6 (preferred) instead of Qt5\" ON)\nendif()\noption(BUILD_tshark        \"Build tshark\" ON)\noption(BUILD_tfshark       \"Build tfshark\" OFF)\noption(BUILD_rawshark      \"Build rawshark\" ON)\noption(BUILD_dumpcap       \"Build dumpcap\" ON)\noption(BUILD_text2pcap     \"Build text2pcap\" ON)\noption(BUILD_mergecap      \"Build mergecap\" ON)\noption(BUILD_reordercap    \"Build reordercap\" ON)\noption(BUILD_editcap       \"Build editcap\" ON)\noption(BUILD_capinfos      \"Build capinfos\" ON)\noption(BUILD_captype       \"Build captype\" ON)\noption(BUILD_randpkt       \"Build randpkt\" ON)\noption(BUILD_dftest        \"Build dftest\" ON)\noption(BUILD_corbaidl2wrs  \"Build corbaidl2wrs\" OFF)\noption(BUILD_dcerpcidl2wrs \"Build dcerpcidl2wrs\" ON)\noption(BUILD_xxx2deb       \"Build xxx2deb\" OFF)\n\noption(BUILD_androiddump   \"Build androiddump\" ON)\noption(BUILD_sshdump       \"Build sshdump\" ON)\noption(BUILD_ciscodump     \"Build ciscodump\" ON)\noption(BUILD_dpauxmon      \"Build dpauxmon\" ON)\noption(BUILD_randpktdump   \"Build randpktdump\" ON)\noption(BUILD_wifidump      \"BUild wifidump\" ON)\nif(WIN32 AND NOT MINGW)\n\toption(BUILD_etwdump\t   \"Build etwdump\" ON)\nelse()\n\toption(BUILD_etwdump\t   \"Build etwdump\" OFF)\nendif()\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\toption(BUILD_sdjournal   \"Build sdjournal\" ON)\nelse()\n\toption(BUILD_sdjournal   \"Build sdjournal\" OFF)\nendif()\noption(BUILD_udpdump       \"Build udpdump\" ON)\noption(BUILD_falcodump     \"Build falcodump\" OFF)\noption(BUILD_sshdig        \"Build sshdig\" ON)\n\noption(BUILD_sharkd        \"Build sharkd\" ON)\noption(BUILD_mmdbresolve   \"Build MaxMind DB resolver\" ON)\noption(BUILD_fuzzshark     \"Build fuzzshark\" OFF)\n\noption(ENABLE_WERROR     \"Treat warnings as errors\" ON)\n# Debugging is enabled for \"Debug\" build type.\noption(ENABLE_DEBUG      \"Enable debugging for all build configurations\" OFF)\noption(ENABLE_DEBUG_UTF_8  \"Enable UTF-8 sanity checks (requires ENABLE_DEBUG)\" ON)\noption(ENABLE_DEBUG_A2W  \"Enable line directive from .cnf file\" OFF)\n# Assertions are enabled for \"Debug\" and \"RelWithDebInfo\" build types.\noption(ENABLE_ASSERT     \"Enable assertions for all build configurations\" OFF)\n\noption(ENABLE_CCACHE     \"Speed up compiling and linking using ccache if possible\" OFF)\noption(DISABLE_FRAME_LARGER_THAN_WARNING \"Disable warning if the size of a function frame is large\" OFF)\noption(EXTCAP_ANDROIDDUMP_LIBPCAP    \"Build androiddump using libpcap\" OFF)\noption(ENABLE_TODO_WARNINGS \"Enable compiler warnings that are yet to be fixed\" OFF)\noption(ENABLE_PEDANTIC_WARNINGS \"Enable pedantic or unfixable compiler warnings (noisy)\" OFF)\noption(ENABLE_CODE_ANALYSIS \"Enable the compiler's static analyzer if possible\" OFF)\noption(ENABLE_ASAN \"Enable AddressSanitizer (ASAN) for debugging (degrades performance)\" OFF)\noption(ENABLE_LSAN \"Enable LeakSanitizer (LSAN) for debugging (less overhead than ASAN)\" OFF)\noption(ENABLE_TSAN \"Enable ThreadSanitizer (TSan) for debugging\" OFF)\noption(ENABLE_UBSAN \"Enable UndefinedBehaviorSanitizer (UBSan) for debugging\" OFF)\noption(ENABLE_FUZZER \"Enable libFuzzer instrumentation for use with fuzzshark\" OFF)\noption(ENABLE_CHECKHF_CONFLICT \"Enable hf conflict check for debugging (start-up may be slower)\" OFF)\n\nif(CMAKE_GENERATOR STREQUAL \"Ninja\")\n\toption(ENABLE_COMPILER_COLOR_DIAGNOSTICS \"Always enable the compiler's color diagnostic output\" ON)\nelse()\n\toption(ENABLE_COMPILER_COLOR_DIAGNOSTICS \"Always enable the compiler's color diagnostic output\" OFF)\nendif()\n\noption(ENABLE_LTO \"Use Link Time Optimization (release configuration only)\" OFF)\n\nif(WIN32)\n\toption(ENABLE_VLD \"Enable Visual Leak Detect in Debug configuration\" OFF)\nendif()\n\noption(ENABLE_PCAP       \"Enable libpcap support (required for capturing)\" ON)\noption(ENABLE_STATIC            \"Build Wireshark libraries statically\" OFF)\noption(USE_STATIC               \"Always link statically with external libraries\" OFF)\noption(ENABLE_PLUGINS           \"Build with plugins\" ON)\noption(ENABLE_PLUGIN_IFDEMO     \"Build with plugin interface demo\" OFF)\n\noption(ENABLE_ZLIB       \"Build with zlib compression support\" ON)\noption(ENABLE_ZLIBNG     \"Build with zlib-ng compression support\" ON)\noption(ENABLE_MINIZIP    \"Build with zip file compression support\" ON)\noption(ENABLE_MINIZIPNG  \"Build with zip file compression support\" ON)\noption(ENABLE_LZ4        \"Build with LZ4 compression support\" ON)\noption(ENABLE_BROTLI     \"Build with brotli compression support\" ON)\noption(ENABLE_SNAPPY     \"Build with Snappy compression support\" ON)\noption(ENABLE_ZSTD       \"Build with Facebook zstd compression support\" ON)\noption(ENABLE_NGHTTP2    \"Build with HTTP/2 header decompression support\" ON)\noption(ENABLE_NGHTTP3    \"Build with HTTP/3 header decompression support\" ON)\noption(ENABLE_LUA        \"Build with Lua dissector support\" ON)\noption(ENABLE_SMI        \"Build with libsmi snmp support\" ON)\noption(ENABLE_GNUTLS     \"Build with RSA decryption support\" ON)\nif(WIN32 AND USE_REPOSITORY)\n\toption(ENABLE_WINSPARKLE \"Enable automatic updates using WinSparkle\" ON)\nendif()\nif (NOT WIN32)\n\toption(ENABLE_CAP        \"Build with Posix capabilities support\" ON)\nendif()\nif(UNIX)\n\t# Libnl is Linux-specific.\n\tif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\t\tset(_enable_libnl ON)\n\tendif()\n\toption(ENABLE_NETLINK    \"Build with libnl support\" ${_enable_libnl})\nendif()\noption(ENABLE_KERBEROS   \"Build with Kerberos support\" ON)\noption(ENABLE_SBC        \"Build with SBC Codec support in RTP Player\" ON)\noption(ENABLE_SPANDSP    \"Build with G.722/G.726 codecs support in RTP Player\" ON)\noption(ENABLE_BCG729     \"Build with G.729 codec support in RTP Player\" ON)\noption(ENABLE_AMRNB      \"Build with AMRNB codec support in RTP Player\" ON)\noption(ENABLE_ILBC       \"Build with iLBC codec support in RTP Player\" ON)\noption(ENABLE_LIBXML2    \"Build with libxml2 support\" ON)\noption(ENABLE_OPUS       \"Build with opus support\" ON)\noption(ENABLE_SINSP      \"Build with libsinsp+libscap support\" ON)\n\noption(FETCH_lua         \"Download and build Lua\" OFF)\n\n# How to install\nset(DUMPCAP_INSTALL_OPTION   \"normal\" CACHE STRING \"Permissions to install\")\nset_property(CACHE DUMPCAP_INSTALL_OPTION PROPERTY STRINGS \"normal\" \"suid\" \"capabilities\")\n\nif(UNIX)\n\toption(ENABLE_DUMPCAP_GROUP \"Install dumpcap with group ownership and permissions (default \\\"wireshark\\\")\" OFF)\n\tset(DUMPCAP_INSTALL_GROUP \"wireshark\" CACHE STRING \"Group name for dumpcap (must exist)\")\nendif()\n\nif(APPLE)\n\toption(ENABLE_APPLICATION_BUNDLE \"Build a macOS application bundle (Wireshark.app)\" ON)\n\toption(ENABLE_SPARKLE \"Enable automatic updates using Sparkle\" ON)\nendif()\n\nif(WIN32)\n\t# Enable signing of NSIS installer by default only if we have 'sign-wireshark.bat' on the path\n\t# of the host system.\n\tset(_enable_signed_nsis False)\n\tif(CMAKE_HOST_WIN32)\n\t\tfind_file(SIGN_WIRESHARK_BAT \"sign-wireshark.bat\")\n\t\tif (SIGN_WIRESHARK_BAT)\n\t\t\tset(_enable_signed_nsis True)\n\t\tendif()\n\tendif()\n\toption(ENABLE_SIGNED_NSIS         \"Enable the code signing step of the NSIS installer build\" ${_enable_signed_nsis})\n\n\t# Advanced options for developers to work-around limitations in the build\n\t# when cross-compiling to Windows.\n\toption(SKIP_NSIS_QT_DLLS    \"Skip deploying Qt runtime DLLs with installer\" OFF)\n\tmark_as_advanced(SKIP_NSIS_QT_DLLS)\nendif()\n"
        },
        {
          "name": "CODE_OF_CONDUCT.adoc",
          "type": "blob",
          "size": 8.541015625,
          "content": "// This can also be found at https://www.wireshark.org/code-of-conduct.html and MUST be synchronized with that document.\n= The Wireshark Code of Conduct\n\n== Preamble\n\nWireshark helps people understand, build, troubleshoot, and secure the computer networks that drive the world around us.\nThis is possible due to the support, hard work and enthusiasm of hundreds of people.\n\nThis document offers some guidance to ensure that the Wireshark community can cooperate effectively in a positive and inspiring atmosphere, and to explain how together we can strengthen and support each other.\n\nThis Code of Conduct is shared by all contributors and users who engage with the Wireshark development team and its community services.\n\n== Overview\n\nThis Code of Conduct presents a summary of the shared values and “common sense” thinking in our community.\nThe basic social ingredients that hold our project together include:\n\n* Be considerate\n* Be respectful\n* Be collaborative\n* Be pragmatic\n* Support others in the community\n* Get support from others in the community\n\nOur community is made up of several groups of individuals and organizations which can roughly be divided into three groups:\n\n* Developers, or those who add value to the project through improving Wireshark and its associated services.\n* Educators, or those who teach people how to use Wireshark and analyze networks.\n* Users, or those who use Wireshark to learn about and analyze networks.\n\nThis Code of Conduct reflects the agreed standards of behavior for members of the Wireshark community, in any forum, mailing list, wiki, web site, chat channel, public meeting or private correspondence within the context of the Wireshark team and its services.\nThe community acts according to the standards written down in this Code of Conduct and will defend these standards for the benefit of the community.\nLeaders of any group, such as moderators of mailing lists, chat channels, forums, etc., will exercise the right to suspend access to any person who persistently breaks our shared Code of Conduct.\n\n== Be considerate\n\nYour actions and work will affect and be used by other people and you in turn will depend on the work and actions of others.\nAny decision you take will affect other community members, and we expect you to take those consequences into account when making decisions.\n\nAs a contributor, ensure that you give full credit for the work of others and bear in mind how your changes affect others.\nIt is also expected that you try to follow the development schedule and guidelines.\n\nAs a user, remember that contributors work hard on their part of Wireshark and take great pride in it.\nIf you are frustrated your problems are more likely to be resolved if you can give accurate and well-mannered information to all concerned.\n\n== Be respectful\n\nIn order for the Wireshark community to stay healthy its members must feel comfortable and accepted.\nTreating one another with respect is absolutely necessary for this. In a disagreement, above all try to assume that people mean well.\n\nWe do not tolerate personal attacks, racism, sexism or any other form of discrimination.\nDisagreement is inevitable, from time to time, but respect for the views of others will go a long way to winning respect for your own views.\nRespecting other people, their work, their contributions and assuming well-meaning motivation will make community members feel comfortable and safe and will result in motivation and productivity.\n\nWe expect members of our community to be respectful when dealing with other contributors, users and communities.\nRemember that Wireshark is an international project and that you may be unaware of important aspects of other cultures.\n\n== Be collaborative\n\nAs with other open source software, Wireshark depends on collaboration. It helps limit duplication of effort while improving the quality of the software produced.\nIn order to avoid any misunderstandings, try to be clear and concise when requesting help or giving it.\nRemember it is easy to misunderstand emails (especially when they are not written in your mother tongue).\nAsk for clarifications if unsure how something is meant; remember the first rule — assume in the first instance that people mean well.\n\nAs a contributor, you should aim to collaborate with other community members, as well as with other communities that are interested in or depend on the work you do.\nWhen making a major change or creating a significant new feature, it’s often best to discuss your work beforehand in the appropriate forum (usually the wireshark-dev mailing list).\n// Your work should be transparent and be fed back into the community when available, not just when Wireshark releases.\n// If you wish to work on something new in existing projects, keep those projects informed of your ideas and progress.\n\nIt may not always be possible to reach consensus on the implementation of an idea, so don’t feel obliged to achieve this before you begin.\nHowever, always ensure that you keep the outside world informed of your work, and publish it in a way that allows outsiders to test, discuss and contribute to your efforts.\n\nAs with any other project, contributors come and go.\nWhen you leave or disengage from the project, in whole or in part, you should do so with pride about what you have achieved and by acting responsibly towards others who come after you to continue the project.\n\nAs a user, your feedback is important, as is its form.\nPoorly thought out comments can cause pain and the demotivation of other community members, but considerate discussion of problems can bring positive results.\nAn encouraging word works wonders.\n\n== Be pragmatic\n\nWireshark is a pragmatic community.\nWe value tangible results over having the last word in a discussion.\nWe defend our core values like freedom and respectful collaboration, but we don’t let arguments about minor issues get in the way of achieving more important results.\nWe are open to suggestions and welcome solutions regardless of their origin.\nWhen in doubt support a solution which helps getting things done over one which has theoretical merits, but isn’t being worked on.\nUse the tools and methods which help getting the job done.\nLet decisions be taken by those who do the work.\n\n== Support others in the community\n\nOur community is made strong by mutual respect, collaboration and pragmatic, responsible behavior.\nSometimes there are situations where this has to be defended and other community members need help.\n\nIf you witness others being attacked, think first about how you can offer them personal support.\nIf you feel that the situation is beyond your ability to help individually, go privately to the victim and ask if some form of official intervention is needed.\nSimilarly you should support anyone who appears to be in danger of burning out, either through work-related stress or personal problems.\n\nWhen problems do arise, consider respectfully reminding those involved of our shared Code of Conduct as a first action.\nLeaders are defined by their actions, and can help set a good example by working to resolve issues in the spirit of this Code of Conduct before they escalate.\n\n== Get support from others in the community\n\nDisagreements, both political and technical, happen all the time.\nOur community is no exception to the rule.\nThe goal is not to avoid disagreements or differing views but to resolve them constructively.\nYou should turn to the community to seek advice and to resolve disagreements and where possible consult those most directly involved.\n\nThink deeply before turning a disagreement into a public dispute.\nIf necessary request mediation, trying to resolve differences in a less highly-emotional medium.\nIf you do feel that you or your work is being attacked, take your time to breathe through before writing heated replies.\nConsider a 24-hour moratorium if emotional language is being used — a cooling off period is sometimes all that is needed.\nIf you really want to go a different way, then we encourage you to publish your ideas and your work, so that it can be tried and tested.\n\n_This document is licensed under the Creative Commons Attribution - Share Alike 3.0 License._\n\n__This document was adapted from the https://kde.org/code-of-conduct/[KDE Code of Conduct]. The original attribution can be found below.__\n\n---\n\n_The authors of this document would like to thank the KDE community and those who have worked to create such a dynamic environment to share in and who offered their thoughts and wisdom in the authoring of this document.__\n__We would also like to thank other vibrant communities that have helped shape this document with their own examples, such as the Ubuntu community and their Code of Conduct._\n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.8779296875,
          "content": "# Contributing to Wireshark\n\n<!--\nTo do:\n- Provide an overview of project governance.\n- CoC?\n- Sponsorship?\n- SharkFest?\n-->\n\nThank you for your interest in contributing to Wireshark!\nWe wouldn’t be as successful as we are today without the help of our community.\nThere are many ways to contribute and help improve Wireshark.\n\n## Help People Use Wireshark\n\nIt’s not always obvious how to capture traffic or interpret what Wireshark shows you.\nWe provide two primary ways to ask for help: the question and answer site at\nhttps://ask.wireshark.org/\nand a mailing list at\n[wireshark-users@wireshark.org](https://www.wireshark.org/lists/).\nYour constructive and respectful assistance is welcome in both places.\n\n## Report Issues\n\nIf you run across a problem with Wireshark or have a suggestion for improvement, you’re welcome to tell us about it on our [issue tracker](https://gitlab.com/wireshark/wireshark/-/issues).\nWhen creating an issue, please select from one of the predefined templates and fill in each section as needed.\nYou can increase the likelihood that a bug will be fixed by providing any materials or information required to replicate the issue.\nFor most issues this means uploading a capture file, but please make sure that it doesn’t contain any private or sensitive information.\n\nThe User’s Guide also has a section on [reporting problems](https://www.wireshark.org/docs/wsug_html_chunked/ChIntroHelp.html#_reporting_problems).\n\n## Write Code And Documentation\n\nWireshark is primarily written in C, with the exception of the main application UI, which is written in C++.\nYou can find its source code at https://gitlab.com/wireshark/wireshark/-/tree/master.\nYou can set up a [build environment](https://www.wireshark.org/docs/wsdg_html_chunked/PartEnvironment.html) on Windows, UNIX, and UNIX-like platforms, including macOS and Linux.\n\nIf you would like to contribute changes to Wireshark’s source code, you must create a [merge request](https://gitlab.com/wireshark/wireshark/-/merge_requests).\nComplete details on doing so can be found in the [Developer’s Guide](https://www.wireshark.org/docs/wsdg_html_chunked/ChSrcContribute.html) and on the [wiki](https://gitlab.com/wireshark/wireshark/-/wikis/Development/SubmittingPatches).\nWhen you submit a merge request, a series of automated tests will be run in order to ensure that compiles across different platforms and conforms to our coding guidelines.\nThe change will also be manually reviewed by a core developer and will be merged when the change passes both automated and manual review.\n\nThe Wireshark User’s Guide and Developer’s Guide are maintained in the [doc directory](https://gitlab.com/wireshark/wireshark/-/tree/master/doc) in the main repository.\nYou don’t need a complete development environment to contribute to them, but you do need git and a text editor.\nDocumentation updates must be made via a merge request similar to source code changes.\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 194.8291015625,
          "content": "ccaa67c1ea Last batch of col_ API changes\n8420e64fde btle: Get rid of unecessary frame_number variable\n91a40d3355 btle: Extract out dissect_btle_adv()\n316e14e502 WSDG: Add some information about Lua loading order\n1331532387 BGP: fix check of length of labeled prefix\nee3471894f LIX2: Update to 3GPP TS 33.128 V18.8.0\n62d985f191 asterix: Fix dissector for extended items\nd8eed38731 SMB2: Add SMB2 notifications capabilities flag\n897864da07 epan: Do not prime with hfids wanted by disabled postdissectors\n99096b76ed Improve some more col_ calls, and script improvements\n2e97567825 wslua: Change one stray static function return value to bool\n524613daed Improve more col_ API calls\n1dd922be36 Add option to run tshark with profile from global profiles\ndc4271d78b nettrace_3gpp_32_423: Eliminate unnecessary copies of RE matches.\n4c40367838 Qt: no Windows META key - only Q_OS_MAC at this time\n8f6b40c4fd Tools: Update a couple of doc directory references\n04ee1cf9dd Qt: disable follow if no frame selected\nedecbd535b MacOS: Update some package versions.\n09dbf1e9b6 Change some non-optimal col_ calls\ne80d3eb9bf Add tools/check_col_apis.py\nbbd3ce58db WSUG: add Reset Layout to main toolbar\nfe0a53b873 ntlmssp: Prevent leaks of cipher contexts\n254b74b974 Docs: update README files\n7cd25d2861 SDP: Update an enum\nade004d6b0 cllog: Check the stripped time stamp validity\nb8040bad31 gitignore: Update the Doc section\n1f865ae6a2 [Automatic update for 2024-07-28]\n37e871a756 GTPv2: Don't include padding in the RAC in ULI\nba07b59501 iee80211: Update status codes per 802.11-2020\n862a2f2fd0 tcp: Convert a function name to C99 style\nd976b3d848 Qt: add reset layout button to toolbar\n902df16bc3 dtls: Don't call gcry_cipher_encrypt on a null cipher context\n66dcd56f1e ntlmssp: Don't insert a key created on the stack into a hash table\n8b45d8a85b pgsql: Handle \"direct SSL\" negotiation\nc599d6962e monero: Stop dissection on an invalid type\n6e08eae526 Qt: Fix clearing displayFilterCombo on Qt < 5.15\ne25e93082a USB HID: Do not store complete usb conv info\n10e6789834 Media Type: Add a structured suffix table\nad53eb6a78 ILP: Fix a field name\n4b1f094c18 Docs: Asciidoctor compat-mode transitioned to modern syntax\n2e71982fee nstime: use consistent names for FILETIME-epoch conversion routines.\nbde8fa5f67 bpv7: Initialize subj_ts\n487b336942 WiX: Install the release notes as \"Release Notes.html\"\nf4d9153a3a Use col_append_str for literal strings with no specifiers\nf439919447 smb: use COUNT_BYTES_SUBR() and COUNT_BYTES_TRANS_SUBR() macros.\n347e6c616f pidl: fix the check for Windows.\n1f00714415 pidl: handle compilers whose cpp doesn't strip // comments.(win) [skip ci]\n8e6c608b31 Clean up handling of times based on the NT FILETIME epoch.\nb48759e4a4 qnet6: Do not use col_set_str on the result of val_to_str\n5792487cf2 Fix various ASN.1 generation warnings and require UTF-8\n9e3e17136c For literal strings, prefer col_set_str() to col_add_fstr()\nd48edda709 USBLL: Reassemble High-Bandwidth interrupt endpoint data\ncfc9dc3a00 USB: Fix High-Bandwidth endpoint sanitization\n9ee0999cac DCERPC: Do not include glib.\nc8c73f6678 packaging: Fix the RPM build\n668881fec7 NSIS+WiX: Switch from \"NEWS\" to \"Release Notes.html\"\nabbd64a3a1 CIGI: Convert CIGI 4 to a dissector table\n4bc1d198b8 GTPv2: Add units of kbps to AMBR\ned3a7c8e31 Release notes: We now ship with NPcap 1.79\nb07275791d composite_tvbs: speed up by using GQueue\nc51e992a23 packaging: Install release-notes.html in our RPM package\n42eb155e05 Docs: Update our targets\n57af0553f1 GitLab CI: Try to limit interruptibility to merge requests\ndd8f9c1087 pidl: handle compilers whose cpp doesn't strip // comments. [skip ci]\ndabf84e0d7 GitLab CI: Our guides are now in the doc directory\n54d279dd7e Docs: Move the User's and Developer's Guides to the doc directory\nea842c8be0 Don't include glib when not needed.\nb9eec9503c BTLE: increase str_addr_len to accomidate new longer string name after #16417\ne8dc6be7df PFCP:Use wmem to allocate memmory\n3b75810424 WSUG: Add FTP-DATA to exported objects.\ndd7cb22c82 Convert remaining dcerpc dissectors to C99 types\nea348265a1 ZBEE SEC: Enable empty payload security check\nae17322376 PID_RELATED_ENTITY_GUID and PID_RELATED_ORIGINAL_WRITER_INFO\n86f47a4249 cigi: fix typo on hf name\ncb22bc045a ErlDP: Add missing tags\nf71745c6bd dcerpc: get rid of guint1632 and guint3264 types.\n7574b47b5f pidl: explain the \"Syntax error near '/'\" errors. [skip ci]\n8abd58d9a0 CIGI: Use a dissector table for packet id for version 3\nb55ee60a7a DHCPv6: decode DHCPv4-over-DHCPv6\n0fa2751812 ANCP: Extend with new data from IANA registery\na7a0f772f7 Update our mailing list URLs\n0e4ff696b7 Art-Net: Add oem code values and extensions to todControl cmds\n375fdb472f Change some function names and variable types to use C99 types.\n0e17c06c35 AERON: Add Resolution frame type identification\n1e925dc843 ELF: Extend some value ranges\nbb65650dfe EPAN: various cleanups to addr_resolv\n4047e3a851 DOC: Document Enable IP geolocation checkbox in name resolv prefs\ne1e449c5bd RTCP: make notification a bool\n054ae0c79c Re-enable disabled pidl dissectors and regenerate for C99\n429b5dcd14 pidl: remove an unused variable. [skip ci]\nc7091b057c Convert a number of \"guint\" to \"uint\" in function names and alike.\nb72753c50a capture_info_dialog.cpp: fix warning (found by check tools)\nf0c1d9d58d NAS 5GS: upgrade dissector to v18.7.0\n8e8c831d44 Docs: typo in previous name\n7232a302ee pidl: more C99 types.\ne4acb0276e dcerpc: change pidl to use C99 types.\n319fb7bd56 pidl: fix some more build issues.\n1af47e5f64 Make it possible to generate the PIDL dissectors with CMake.\n70cd5a04ba epan: Deprecate the GLib-style tvb_get_gu?int functions\nf889eabb12 Qt: Use a shared model for DisplayFilterCombo\n0fd3d14601 SMB: Remove bogus malformed error\ncaffeba5ec GDT: Remove unneccessary includes.\nbbee0f9340 Convert use of G_GINT64_MODIFIER to PRIu64/PRId64\n048e2de8fd Convert G_GUINT32_FORMAT to PRIu32\nc4247075cf convert-dissectors-h-to-C99, remove include glib\n5743153197 Convert gushort to C99 types\n5bd8b730d0 Convert zbee-direct to C99 types\n55b9e55a13 Convert remaining DCERPC dissectors to C99 Types\n5ed65d3195 ORAN FH CUS: trivial edits\n0274951625 epan: Update our remaining old-style tvb integer accessors\nf4af6bdc0a Replace gint with int in README.dissector\n125d712770 Zabbix: Add separate subtree identifier for Flags tree\n4829e3ff39 CBOR: Register CBOR Sequence dissector with description\nb70a243d64 CoAP: Remove duplicate value string entry\na4ecb58643 Convert dcerpc templates co C99 types\ne40128d030 DCM: Update data structures, dictionary and message exchange\nb517de1634 mp2t: Fix an underflow\n96fa766c4b Add Protected S1G Action frame dissection\nd14c086703 Rename tvb_get_guintvar tvb_get_uintvar\n6a053794a0 Convert dtd files to C99 types\n3ed8b04363 Convert types used in comments to C99 types\nc4aac41433 Convert some temp variable names to C99 style\nf8610965c5 PFCP:Change tvb_get_guint.. to tvb_get_uint...\nc41c23a818 Fix some mask warnings (from check_typed_item_calls.py)\ne9a42a9fd6 Convert g(u)intptr -> (u)intptr_t\n3c33dccf7c Modernize some function names\nd6ff757f0f docs: Use pdf theme option that works for asciidoctorj\n6b0f20668c frame_tvbuff: Modernize a couple of function names\n058a3d56d4 epan: Deprecate some GLib-style functions\n3a6fda7882 asciidoctor: Prefer batch file commands on Windows\n0eed9bdf8b Remove the g prefix from the tvb search routines.\n1b2bf20dbc docs: Use new-style tvb integer accessors in the Developer's Guide\n00f7d51730 wslua: Use new-style tvb integer accessors\n2c4e056c08 Pass a set of PIDL flags, not \"is open\" and \"is close\" Booleans.\n1337bf40a2 convert-rf4ce-secur-to-C99-types\n205293aa52 Fix some spelling errors\na9ebc96d48 [Automatic update for 2024-07-21]\nb29c855ba3 radiotap: retrieve field with appropriate function\n355afd1dee CIGI: Don't define identical TFS multiple times\n8b978c94de ZMTP: minor changes\n46df62bb0f convert-opensafety-to-C99\n7f1bf1a26c convert-tvb_get_guintx\n81066453e7 epan: Use new-style tvb integer accessors in our top-level code\n09c01b8521 UI: Use new-style tvb integer accessors\ndfc63ba2ff nmf: Use varint API, don't throw exceptions or undefined shift\n04968e140f nmf: Remove proto initialization\n2e7ca427b4 convert-x11-helpers-to-C99-types\n5951fed220 Convert pidl .cnf files to C99 types\ne6d5e8c815 convert file-dissectors to C99 types\ne9845bd3f9 6LoWPAN: Fix base of Page Number field\nbc5f7d729d Convert dissectors 1-9 to C99 types\n029dce389b Convert dissectors W to C99 types\n97f93df2e4 Convert dissectors YZ to C99 types\naf353f48f5 Convert dissectors X to C99 types\nffdced10e8 Convert dissectors V to c99 types\n5d72821204 epan: convert dissectors S to C99 types\n75ea337b68 epan: convert dissectors P to C99 types\nf61c344fb9 docs: Support more symbols in asciidoctor-pdf\n7274fe8c97 epan: convert dissectors T to C99 types\n866bb943f2 tvbuff.h: include headers to define macros used herein.\ncb9eac4bc2 check_typed_item_calls.py: trying to get warning count down\ndbd3f3778e sysdig: add the latest kernel APIs\n38a1f99d7a NAS EPS: upgrade dissector to v18.7.0\n650b164ad0 wsdg: specify debian sym link\nbd12a6750f SOMEIP: Fix a broken test\n4cd3c7e870 Diameter 3GPP: Add Feature-List for SWx, S6b\nf0a1fb231d Update netlink generation tool and update netlink nl82011 dissector\ncbcb180095 Update ISOBUS parameters\n734df63153 IANA added another IPv6 special block\n1ac5195df2 DOC: complement SNMP user table description\n315aaf2e77 FBZERO and GQUIC: chacha20 -> chacha12\nda91cb25fa ORAN FH CUS: fix a check - dereference pointer before test\n4ce51e5667 windows-common: don't export legacy {NT,WERR,HRES}_errors\n7c0402e75b pidl:dcerpc-*: regenerate dissectors after {NT,WERR,HRES}_errors_ext pidl changes\n46d74a4fbd svcctl.cnf: make use of WERR_errors_ext\n003d4b0ac0 tools/pidl: make use of {NT,WERR,HRES}_errors_ext\n6e69523711 pidl:dcerpc-*: regenerate dissectors after BASE_DEC/HEX pidl changes\nc58a16350b tools/pidl: don't use hardcoded BASE_HEX nor BASE_DEC\n8eeb888ab2 dcerpc-{budb,butc}: regenerate after {NT,WERR}_errors_ext idl2wrs changes\nd0e762051f idl2wrs: make use of {NT,WERR}_errors_ext\nd789da7260 smb-direct: make use of &NT_errors_ext\n29dee5fc82 kerberos: make use of &NT_errors_ext\nef30c03372 nmf: initial commit for [MC-NMF] .NET Message Framing Protocol\nce1e3ad96e xml: add o:BinarySecurityToken => GSSAPI dissection\n3c042d997d xml: run ./tools/convert-glib-types.py epan/dissectors/packet-xml.*\n10b644a26f epan: convert dissectors U to C99 types\n18aa227772 epan: convert dissectors R to C99 types\nf7d0e4a633 epan: convert dissectors Q to C99 types\n75fec70124 epan: convert dissectors O to C99 types\n5ac53351ff ieee80211: Eliminate false positive maybe-initialized\n8f01b0aeea Remove break after return\nd15fc6e1ca GSM A GM: upgrade dissector to v18.6.0\nbaea7be0ab wslua: Expose pinfo saved_can_desegment to Lua pktinfo\n7f96b474b8 GitLab CI: Enable automatic pipeline cancellation\nf85b22fd18 Qt: I/O Graph Throughput and zero values handling\n32c5280dfa Qt: update filenames in comments; remove HelpContents icon property\n38c3cf5c2f Switch our GLib 64-bit format specifiers to their C99 equivalents\n490bd19bb5 epan: convert dissectors N to C99 types\n81bdcbd378 epan: convert dissectors M to C99 types\n8156dd0d94 epan: convert dissectors L to C99 types\na275a44abf Bluetooth: update UUID registery\n61c68a601f BACAPP: Update vendor registery\n40e3bc99a5 Version: 4.3.0 → 4.3.1\n1c3cf00f75 Build: 4.3.0\n27c7e2adc8 TCP: Performance improvement for managing the OOO list\n945f04c2a2 epan: convert dissectors K to C99 types\nea170b811f epan: convert dissectors J to C99 types\n31e722a7c4 IEC101/104: Add some expert infos\nc12607d0da WSDG: correction of broken gitlab URL\n451a082623 BTATT: restore wrongly C99 change\nd4e2030103 f5ethtrailer: restore wrongly gboolean->C99 change\n8dda8c25d4 epan: convert dissectors I to C99 types\neeb129b4c2 epan: convert dissectors H to C99 types (rerun script)\n3b09b6becc epan: convert dissectors F to C99 types (rerun script)\n7c581d7fd1 epan: convert dissectors E to C99 types (rerun script)\na96264f689 epan: convert dissectors D to C99 types (rerun script)\na6e1171b82 epan: convert dissectors C to C99 types (rerun script)\n40801edc48 epan: convert dissectors B to C99 types (rerun script)\n2b757660e5 epan: convert dissectors A to C99 types (rerun script)\n6293415f09 epan: convert dissectors H to C99 types\n0a8e4ded45 Plugins: Use new-style integer accessors\n5e17761308 lbmsrs: Do not throw exceptions in heuristics\nb23e9ac8ec GitLab CI: Fix an if statement\n94713cb032 Update the tvb_get API calls in our ASN.1 dissectors\n2ca68dd3c7 Qt: Allow moving the I/O Graph legend\n1edd2e1053 Revert \"Qt: Have all DisplayFilterEdits have bookmarks\"\n39b94e6b70 Revert \"Qt: DisplayFilterEdit touch-ups\"\n5f5e173754 Revert \"Qt: DisplayFilterEdit bookmark button background\"\n5b4d32ab60 epan: Switch the tvb_get_g?int API to C99 names\n7a15145e84 docs: Update I/O Graph\n665f28c0a2 wiretap: More refactoring of wtap_open_offline.\n52138877a7 QUIC: update link to lasted draft multipath support\nc7a234ac1e QUIC: remove draft-04 support (multipath)\n9892ec13ea QUIC: rename MP_ACK to ACK_MP (multipath-draft10)\nbcf9cdf247 QUIC: Add new frame type MAX_PATH_ID from multipath-draft09\n1f4f2a487d QUIC: add new TP max_path_id from multipath-draft09\ne49774d247 epan: convert dissectors G to C99 types\nc30ccfc352 epan: convert dissectors F to C99 types\nc8e41384e9 epan: convert dissectors D to C99 types\ne106fe5e78 epan: convert dissectors E to C99 types\n67daaa3421 Qt: Parent GeometryStateDialogs when setting them modal\nae1259aa66 F1AP: dissect new NR RRC containers\nda1b897e80 Changing packet-nordic_ble.c as well\n7e5a1f054b Replacing CSB (Connectionless Slave Broadcast) with CPB (Connectionless Peripheral Broadcast) everywhere\nbacb217683 first pass, before fixing CSB -> CPB more thoroughly\nbd29aea24d Zabbix: Add proxy tasks command support, also improve packet info headers\n9bc66492a2 epan: convert dissectors C to C99 types\n85e03ae80d Address more value_string warnings\n3686d0e52b snort: typo in comment about TraceWrangler\nd3882d0941 Windows: upgrade Npcap to 1.79\n8f1d02f2e2 ORAN FH CUS: better support for C Section Type 6 (channel info)\nee21fd0dcf E2AP: register multiple versions of CCC\n8ede4780fa ORAN FH CUS: SE 21 affects SE 6, which configures SE 11\n59fdb05228 LTE RRC: upgrade dissector to v18.2.0\n3a3efb5a3d TCP: Fix SACK interpretation when deinterlacing and Relative SEQ\n2e3c1cfbf3 macos-install: fix a bogus path in an mv command. [skip ci]\n910ab43578 Qt: Keep Export Dissections save button disabled when changing files\n3a63db2abb [Automatic update for 2024-07-14]\n3b8e1b6813 Qt: Parent the QColorDialog in ColoringRulesDialog\nca4d0554b6 Qt: Parent the testCaptureFileClose message box\nfc3042177f editcap: Add extract-secrets\n3a74a9aecc Support more than one context in a single OAM Get request\nb30524d912 Zigbee ZCL: Fix Discovery Attributes Extended dissectors\na9cf73310e nmea0183: Convert to using C99 types\na31de2c480 BGP: Add a couple of missing items to EVPN value_string\n59be13307b Signal PDU: Cache get_signal_value_name_config results\na63f5fc802 wiretap: De-duplicate file-opening code.\n7759efe69d SMB: Eliminate Response<unknown> errors (GNS365)\n9bc41fe152 RSL: Fixed message discriminator for Location Services messages\n4e88a22d9b More issues detected by ruff\nde57b76a5c NRPPa: upgrade dissector to v18.2.0\nb6122016a7 LPPa: upgrade dissector to v18.2.0\n055846990f LPP: upgrade dissector to v18.2.0\ne3e52d8c74 Fix up some python script issues seen with ruff\nd6f8580675 Be more careful about escaping in python REs\n483e3394cf F1AP: upgrade dissector to v18.2.0\n89da7713c4 Zabbix: Add zabbix.hostmap_revision\ndd45029160 packaging: Add checkpoint RADIUS dictionary to nsi packaging\nb12141f9b4 capture-sync: Fix deadlock with lots of interfaces.\n1fd7c1df45 GNSS: add dissection for SBAS L1 MT24 with vel code = 1\nf430181d56 kerberos: implement service response time statistics\ne9d9713aa2 kerberos: add better autodetection of KRB_ERROR e-data\n4abf8fe493 CMake: don't build release-notes.html multiple times\n704bf1ab31 Qt: Connect ExportDissectionDialog signals at compile time\na5a265ef23 SNMP: Free the error string if unused\n7fdca9c201 Qt: initialize variable\nad804dac7f SNMP: Allow for key expansion algorithm selection\n44b0041da8 E1AP: upgrade dissector to v18.2.0\nc9fd29af56 sync pipe: Close pipe before waiting for child, better error message\n8b332123da Docs: Move our AsciiDoctor macros to the doc directory\nbc55f82c67 XnAP: upgrade dissector to v18.2.0\n04031a71e5 addr_resolv: Don't continually look up ethers that didn't resolve\n6f42825c9f asterix: adjust to upstream change\n858faad7df Qt: Window Scaling Bytes in Flight calculation update\n4a9802621e Thrift: fix incorrect proto_depth calculation\n1476e292f9 OpenVPN: Reassemble TLS control messages of arbitrary size\n2a8b1973f8 tools: Make some regex expressions raw strings\n03c56e9ee6 Qt: DisplayFilterEdit bookmark button background\n4e0e35b799 Qt: DisplayFilterEdit touch-ups\nd056dc1bb3 exported_pdu: add tag for 3GPP identity\nea85e2a621 exported_pdu: use c99 types\n63f5995f39 GTPv2: Update to 3GPP TS 29.274 V18.7.0\n198dfd0450 Add nghttp3 support to RPM package\n5cdd62375d BTLE: don't implicitly cast bool value to int\naa69a03769 SIP: decoding for quoted value of utran-cell-id-3gpp\n3260a07d7f NGAP: upgrade dissector to v18.2.0\nf92e4a3f3d Qt: Allow more than one path separator in stats tree plugin\n0b83828004 TCP: Fix minor array boundaries reading for SACKs\naa20732fdd X2AP: upgrade dissector to v18.2.0\n57af237421 S1AP: upgrade dissector to v18.2.0\nc841175d22 GitLab CI: Try to fix the Visual Studio Code Analysis job\nf9c360d5d4 tvbuff: Use the clamped value for retrieving unaligned le bits\nb37c836a2d Fix some spelling errors in tools folder\n409bb10764 CMake: ASCIIDOCTOR2TXT - html is input\n843c3056c7 GSM-L2RCOP: use a common tfs entry instead of defining own\n404021bd7b dumpcap: Use GetTickCount64 on Windows\ndb6e438509 dcm-dispatch: fix Dead Store found by Clang Analyzer\na21668e303 TCP: Fix minor array boundaries reading for SACKs\n33f606b52f CMake: Add custom sources and headers only if they're defined\n374c9a79da dumpcap: Convert to C99 types\n5af51e3802 tshark: Convert to C99 types\n6b732f0274 Convert sharkd to C99 types\n3a1b36bca8 Convert rawshark and tfshark to C99 types\nb75e9b696c Falco Bridge: Use approved API calls\ncefebb8a35 CMake: Fix our Logray source paths\n08e428d690 Convert capture_opts to C99\n439184901f GitLab CI: Use a common Python virtualenv directory\n8b582d6172 Convert file.h and cfile.h to C99 types\n86a5c21075 GitLab CI: Use MinIO mc in another place\n56a6b71f40 docs: Update to the IETF Internet-Draft for the TLS Key Log File\n92d97c7106 Convert ringbuffer, frame_tvbuff, and file_packet_provider to C99\nab1c56f9a9 Docs: adoc possible invalid reference (change to link:)\na354b30315 Convert the smaller executables to C99 types\n6a1695d1cd [Automatic update for 2024-07-07]\nd7eefd41a2 GitLab CI: Use Mino mc on Ubuntu\n80d5a22693 Docs: Move ws.css to the doc directory\n50902e8582 Qt: Fix crash on exit with previous focus\n8b57c010b2 doc: Document additional secrets types editcap injects\nb4b00dc7f2 text2pcap: Convert to C99 types\n1053544305 GNSS: add dissector for SBAS L1 MT17\n3fa2f2dd7b tfs: add off/on true_false_string\n50cb222d78 nmea0183: Add GLL sentence dissector\ncdd9bbcc1f docs: Use attribute substitution for wiki links\n60cbd23eed wsug: Change two wiki links from SSL to TLS\nc7745b4dde docs: Switch the WSUG and WSDG back to using wiki.wireshark.org\n9b59ce6e58 Docs: add css_dir path to ws.css source\nac61d261b4 editcap: Fix handling of unrecognized long options\n311ca847a7 epan: Use the logging system for sequence analysis\n970714f2be exported_pdu: Pad TCP_INFO_DATA to 32-bit boundary\n43fe6bcdad Docs: update Asciidoctor copycss path to ws.css\n9c8aa1ba55 editcap: Convert to C99 types\na724879e51 pfcp: correction of IE Downlink Data Service Information\n93c092f93d epan: Convert ASN.1 dissectors to C99\nacd8dca562 DCHP: Fix Relay Agent Information Source Port\nfb89750e32 Don't call g_string_free() with bool - it takes gboolean\na0c8344f16 editcap: Use cmdarg_err in some places\n3275e6fb18 BTATT: don't call g_string_free() with bool - it takes gboolean\n0600b68737 Convert a bunch of gconstpointers to const void pointers\n42ddcf5b7f nmea0183: Add ROT sentence dissector\nb5e9fb3951 pidl: Convert generated types to C99\ncc9566f396 z21: bool cast fix after C99 convert\n35a0eca08d Qt: Add zoom packet list header\ndfbf4b6030 Docs: Fix the CSS paths in our manual pages\nf7ee3b17b2 epan: convert dissectors A-B to C99 types\n81e58b5bbc kerberos: Fix a conflicting type\nfe6ade19ab protobuf: Fix timestamp conversion\n068dc779be doc: Use uniform coding style in README.dissector\n6ff41d0dd8 mpeg-pes: Fix return type for dissect_mpeg_pes\n19f7deabc8 epan: update make-taps script with C99 types\nd62f91bff6 text2pcap: L3PIDs are Ethertypes; update help and man page\n078be6e0c8 BLF: Simplify code for LIN endianness fix\n00df4e247e BLF: Add support for BLF_OBJTYPE_LIN_SLEEP\nc57be2ced1 BLF: Add support for BLF_OBJTYPE_LIN_WAKEUP2\nbbc1a60c1e BLF: Add support for BLF_OBJTYPE_LIN_WAKEUP\n30ca0f066e BLF: Add support for BLF_OBJTYPE_LIN_RCV_ERROR2\n21487d5108 BLF: Add support for BLF_OBJTYPE_LIN_RCV_ERROR\na217395efb BLF: Add missing breaks\n7c2355d2ef pcapng: Write Simple Packet Block when appropriate\na5fbbe4642 UI: scan interface warning lowered to debug\n304d6ffe86 epan: Convert dissectors to C99 types\nf6185bb54b packaging: Add new RADIUS dictionaries to nsi packaging\na849cf7d9b WSDG: update help messages.\n790a1f89ab Fix some spelling errors\ne20a6a9115 dumpcap: don't mention rpcap in the help message absent rpcap support.\nd7ebffe147 Monero dissector extended - full breakdown of all data structures\ne3e91db8e6 BTMESH: Register pbadv reassembly table only once\nfb95d0b65f BTMESH: Register upper transport reassembly table only once\n045e7c1010 MTP2: Register reassembly table only once\n3df525f9ea BTMESH: Register proxy reassembly table only once\ncb1a36d39b capinfos: fix more names for earliest and latest packets.\n1cbd9f95ae capinfos: use the right terms for earliest and latest packets.\n534010d88f exported_pdu: remove extra reads\n4492a831be JSON: convert to C99 types\n2451bd6ba1 Run 3 dissectors through tools/convert-glib-types.py\n3f1be241b9 epan: convert epan/*.{c|h} to C99 types\n3d60efa467 TCAP: Convert some types to C99\n563099a370 TCP: better handling of the Retrans/OOO analysis\n396b39adf9 Fix CMake macro ADD_CUSTOM_CMAKE_INCLUDE\n928ed7a375 pfcp: convert to C99 types\n29df76c053 Wireshark: Cmd-line prefs override profile prefs\n03c844febf ASN1: call asn1_ctx_init() with true rather than TRUE\n2bbe84d29d win-setup: Use correct c-ares package on arm\nb9601a3add win-setup: Fix c-ares checksum.\n2a77afa9db WSDG: clarify taps and stats\nc7ced5b18a bittorrent: Fix reassembly when header and message type are segmented\n75ef0dd83e epan: Convert sequence analysis to C99 types\na91b029920 Qt: Make dragging the Sequence Diagram axis not sticky\n2fe05aed94 Update 3party libraries.\n9124b6c944 Qt: IPv4 aggregation memory leak fix\nfc7833d40c Call register_tap in registration function\n4a05466243 epan: Convert the CRC API to C99 types\n1b5cf82bb5 cmake: Remove outdated readme.txt\n98736ddb36 ITS: Register for VAM Message type\ndef3862451 Fix some spelling errors\n05d4858cf1 Qt: Make it a little easier to drag the comment axis\n70c13238d9 cmake: Fix indent and layout\n6fe180d19c merge: squelch some compiler warnings.\n8c6f913e19 Qt: Make sequence graph Comment column width adjustable\n5358de8dd1 NFS: Limit number of ops dissected.\n48229378f1 Qt: IPv4 aggregation for Endpoints/Conversations\n18f2e7f12c wsutil: Fix the local documentation directory on macOS\n2e8cb1bf08 DOCSIS: add links to specifications\n83d3311440 DOCSIS: Use common units for Hz and MHz\n497271482a DOCSIS: UCD Subcarrier 0 Center frequency: fix type and add unit\nb8375ff5b9 DOCSIS: add DPR (DOCSIS 4.0)\n9ce2592bf0 DOCSIS: add ECT-REQ and ECT-RSP (DOCSIS 4.0)\nc845f75cb4 DOCSIS: add CWT-REQ and CWT-RSP (DOCSIS 4.0)\n24914aebdb DOCSIS: BPKM: DOCSIS 4.0 MMM types, fields and DER decoding\ncd2ecbe85a DOCSIS: 2 digits suffice for quarters\nda8c619ee8 DOCSIS: OPT-RSP: Add missing and DOCSIS 4.0 fields\n7af658b2cd DOCSIS: OPT-REQ: add v5 multipart\na6a5fae0ed DOCSIS: OCD: FDX Indicator field (DOCSIS 4.0) and v5 multipart\n4738e648ed DOCSIS: MDD: Add BPI+ version and config (DOCSIS 4.0)\n1cfcca4ed4 DOCSIS: MDD: Replace D4.0 FDX Descriptor with D4.0 Advanced Band Plan Descriptor\neb511cd759 DOCSIS: MDD: docsis_mdd.tlv cleanup, Version fixes and DOCSIS 4.0 Version\ndb6edf6290 DOCSIS: MDD: Add DS Active Channel List FDX field and remove Primary Capable use for FDX (DOCSIS 4.0)\n7d5ff94ae6 DOCSIS: MAP: Use common tfs in DOCSIS Probe MAP\n77d6dde228 DOCSIS: MAP: Add Probe IE ECT Control (DOCSIS 4.0)\n7b5316defc editcap: Support for a large number of frames\neffc8d7c7a TPNCP: Replace static allocations with wmem_arrays.\neacc5010be GNSS: Augment COL_INFO for Galileo I/NAV Word 0\n40341b4b35 GNSS: add dissector for Galileo I/Nav Word 1\n670c3533c8 wsutil: Add constant for UTF-8 square root\n7a9677e487 DHCPFO: Use ip_num_to_str() to show little-endian IPv4\n14a47aa6e8 Qt: Show Minizip version\nb6d9f3c836 Add minizip-ng to Mac using brew.\nfe4852caae merge: report errors inside the merge API routines.\nad7a7f7d67 Qt: Add a null check to the Endpoint dialog\ndd12fe3498 Replace some 'guint8 offset' usage with gint\n97e8c51916 NBAP:Only create the global maps once\n3bd416d3ee ASN protocols: update APIs and generated code for bool\nc03ad5099b proto.c: Increase number of preallocated fields.\n9edf5c5598 More gboolean -> bool conversion\n2a205059ff cllog: fix a reversed conditional test.\n16ea412dda file merging: report errors using report_message functions.\ndfec1bb322 MATE: Improve reporting of a mate config syntax error\neaa7fba6d4 DHCPFO: Remove duplicate client hw address output\n59f4650e42 TCP: Initialize 'tcp_snd_manual_analysis' field.\n7800ad8737 Qt: add \"ellipsis\" to elide pref description\n0039ebf599 Docs: Move the manual pages to their own directory\nf1a671f1dc Qt: I/O Graph Throughput calculation\n7316303d43 GNSS: remove unnecessary #include in Galileo I/NAV dissector\n9084f0b452 GNSS: add handoff for GAL I/NAV nominal page data words\nbc91a1d4bb Qt: Replace \"Contents\" with \"User's Guide\"\nfcbc39038d radius: More FreeRADIUS updates\n48ea9d8d84 findMinizipng: Bcrypt is windows only\naf85afa4e0 Add minizip-ng dlls to the installers (fix typo)\n49164027c6 radius: Support sub-TLVs of sub-TLVs\n21c9aeb014 RRC: Only create the global U-RNTI / C-RNTI map once\n66632c5d2b Minizip-ng: Adjust FindMinizipng.cmake to work on Fedora\n8d84eed1ab smb2: Always show the compressed payload\nb6b382c428 [Automatic update for 2024-06-30]\ndbae820abe Add minizip-ng dlls to the installers\n709b09c6fb Logray: Propagate the radius nsi changes to Logray.\n4c30a109a4 Add G_GNUC_ALLOC_SIZE annotations to wmem functions.\n5d02f6631f Logray:Add MINIZIPNG_INCLUDE_DIRS\n9a9595e498 BLF: Do not set timestamp for metadata\n6e9f1ea6b4 BLF: Override the timestamp with 0 for metadata objects\n4ecab35300 radius: Update more dictionaries from FreeRADIUS 3.2.4\n43d73dfb47 radius: Update NSI packaging\nbe17f7458a Qt: Improve a warning in Show Packet Bytes\n0e8cb9dbbe Qt: Add a check for empty uncompressed tvb\n5f80d2af9e radius: Move the illegal elements in ascend and usr to new files\n2d5bc134f4 radius: More dictionary updates\n6507ab6201 Make range_t.ranges a flexible array member.\n235a349188 CIP: Const-ify attribute_info_t instances.\ncdd9cbb56d Add minizip-ng to replace minizip\n0790c172a1 Qt: Extend Show Packet Bytes uncompress\nc029a63a26 Lua: Fix TvbRange:uncompress_hpack_huff\n40da1d4875 radius: Update dictionaries to FreeRADIUS 3.2.4\n28a8de771b Update gitignore for .so files\n72290a356a col_set_writable(): use bool for remaining cases\n71fc611d60 col_set_writable(): call with bool\n035f8a6925 ORAN & MAC-LTE: use bool internally\n3301f2df24 docs: Add documentation for decode as Percent-Encoding\nca6761150a Qt: Add support for Base64Url in Show Packet Bytes\nac81cdbc92 Qt: Keep axes in sync for Window Scaling graph\n4f500cfec7 radius: Update RFC dictionary files to FreeRADIUS 3.2.4\n0f339d3672 prefs: Make auto-preferences work with dissectors with description\n6b543256b8 pidl: Revert some links back to wiki.wireshark.org\nf523013e5a DCOM: Implement IStorage and InstanceInfo in ISystemActivator dissection\n25ecab0cc7 CIP: Improve CIP Security support\n5b75d79de7 Docs: Update the Visual Studio setup instructions\n9fef88013d Revert \"CMake: Always add /Qspectre when building with Visual C++\"\nf742fb5cab Resources: Update the default Logray coloring rules\n1c0b350f6d A little more checking of range_strings\ne91a34ebbe Logray: Update styleSheet on ApplicationPaletteChange event\ncee160e862 Logray: Remove empty sub menus when Reload Lua Plugins\nd9e8d52baf LTE: Reset RLC & PDCP bearer states opon certain RRC events\n5793a0f0ff pfcp: Update to 3GPP TS 29.244 V18.6.0\n4f56c263ee MAC-LTE: Add a single (hidden) lcid field for both directions\nba83258400 CMake: Always add /Qspectre when building with Visual C++\n3adb05fd0b blf: update error messages and fix comments.\n795f2a7145 BLF: Replace g_try_malloc0 with g_try_malloc\nf4a05e2dd9 BLF: Remove unused members from blf_log_container struct\nfc56c21253 BLF: Support objects outside log containers\na1dfac3610 blf: update a comment to reflect reality.\n3593713101 BLF: Skip objects without log container without failing\nbf4c1c1200 WiSUN: Do not store offset in a 8 bit integer\nc5759ba199 Fix some spelling errors\n732f2e8753 sapigs: Remove execute bit\n41a75fc456 blf: remove a set-but-unused variable.\n7a42f3e48f RTP: Use the extended sequence number to count cycles\n6dbbeccbbf epan: Distinguish unregistered handle name and description\n2f19d0db5c prefs: Add one space back to gui.debounce_timer description\n2030a1a783 idl2wrs.c: Pick up recent changes and regenerate\nf3f19e8fbb idl2wrs.c: Fix generation of idl2wrs-dissectors\n4d021395a7 blf: not all top-level objects are containers.\n5f807da9ba epan: Convert the stream API to C99 types\n5106dec70c Fix null derefs reported by clang-analyzer\n6931eb67e7 WiSUN: correct offset logic errors\n3a00768fb4 ieee1905:Client Association Control Request TLV: Timed block, Indefinite block\nb325469b42 epan: Don't allow NULL or empty registered dissector names\n100563111c epan update character set list\nfe98af0e30 prefs: Get rid of line continuations for gui.debounce.timer description\n49ff6ebe35 GNSS: rename SBAS L1 MT25 rate of change of ephemeris time correction\nc7cddf00dd GNSS: fix typo for SBAS L1 MT25 rate of change of ephemeris time correction\nd5e50dd596 GNSS: fix typo on SBAS L1 UDREI mapping\nb14ceeb6b6 Qt: Write gui.fileopen_remembered_dir to recent with native separators\nf918016604 idl2wrs: Convert glib types to C99 types, regenerate dissectors\nf40578a486 tools: Convert make-plugin-reg.py to C99 types\nbc75a699c4 Qt: Improve Show Packet Bytes base64 decoding\ne95d11881c idl2wrs: Update wireshark_gen.py to match memory scope changes\n7a69039fbb idl2wrs: Update generator to match recent commit\n0146fe4eb6 capture sync: extend max length for system with many interfaces\n3d482f7602 MySQL: Fix when exec stmt with 0 params\n1e33765bb8 ARP - add Unified Bus (UB hardware type)\n4c50a91531 prefs: Use common function to check module alias names\n793106c7bb DNS: additional Resource Record (RR) types, RESINFO and WALLET\ne141816fa3 dcerpc-browser: Generate with pidl\nd7c1a5a245 stcsig: Don't register the dissector handle twice\ne3cdd778df wiretap: have per-compreession-type \"recognizers\".\n2394249795 [Automatic update for 2024-06-23]\nbdb719f846 pidl: Another C99 type conversion\nda4c136c96 Qt: Conversations for unique IP addresses\n2be22f3a45 pidl: Auto-generate srvsvc and wkssvc from pidl\n1dc242656f dhcp Display option dhcp-option 211 PXE reboot time\n10b046cbdd pidl: Remove init of proto variables\n4df8d2884d pidl: Convert the pidl dissector generation code to C99 types\n02ec34bc2a doc: update logray quick start\n91207cac31 UDP: If no IP layer, ignore 0 checksum\n8c1af5f9f1 epan: Convert our remaining string APIs to C99 types\n4f917cef27 Docs: Update the Logray quick start\n6e4c81b324 pidl: Update test for removal of ett initialization\n1369a90722 pidl: Cherry-pick commit from upstream Samba\n37ad476b37 pidl: Cherry-pick commit from upstream Samba\n2e2a0456e8 pidl: Cherry-pick commits from upstream Samba\nd788f6e1e7 pidl: Cherry-pick commits from upstream Samba\n34cbafb931 pidl: Cherry-pick commit from upstream Samba\nb9b2dd736d pidl: Cherry-pick commits from upstream Samba.\n5712a6f402 pidl: Cherry-pick commits from upstream Samba.\n1c3471df29 pidl: Cherry-pick commits from upstream Samba\n7c93595447 pidl: Cherry-pick commits from upstream Samba\n5441003874 Fix array bounds in conversation_new_deinterlaced().\n7cf192e18d pidl: Cherry-pick a commit from upstream Samba\n517c9103f5 pidl: Cherry-pick commits from upstream Samba\n417ec805d0 pidl: Cherry-pick commits from upstream Samba\nbb51cf8845 pidl: Cherry-pick commits from upstream Samba\n08c71b5496 pidl: Cherry-pick commits from upstream Samba\n9f8237abf3 pidl: Cherry-pick commits from upstream Samba\n4fec16ec30 pidl: Cherry-pick commits from upstream Samba\nf3c5fb8faf pidl: Cherry-pick commits from upstream Samba\nfb652df574 pidl: Cherry-pick commits from upstream Samba\n7a6ca829e4 pidl: Cherry-pick commits from upstream Samba\n2c1d7ea874 pidl: Cherry-pick commits from upstream Samba\n340d8ec982 pidl: Cherry-picks from upstream Samba\n6f2b96ff52 pidl: Cherry-pick from upstream Samba\nade6577f10 pidl: Don't assign hash undef, assign it an empty array\ncf89c3a208 vssmonitoring: fix Dead Store found by Clang Analyzer\n568275f2d2 cql: Fix Dead Store found by Clang Analyzer\nf405b3a8b2 pidl: Cherry-picks from upstream Samba\n4144e6578b pidl: Cherry-picks from upstream Samba\n0abae4e5c3 pidl: More cherry-picks from upstream Samba\na990934b56 pidl: Cherry-pick more commits from upstream Samba\n455d5c5e2a pidl: Cherry-pick more commits from upstream\n879b6186aa pidl: Cherry-pick more commits from upstream Samba\ncb9cbe1f93 Flag identical entries in value_strings\nf1338bc521 pidl: Cherry-pick commits from upstream Samba\nebd0dbb11f pidl: Cherry pick commits from upstream Samba\nf179c30162 pidl: Update closer to upstream Samba\n1bd74ff91a radius: Update the dictionary parsing code to C99 types\nb9f0c6b305 rmpt: prefer use proto_tree_add_item when it is possible\n7f7953b54d radius: Read dictionary files with octets length and concat\n21bef1de66 matter: Properly dissect Additional Data characteristic\nb17828f010 Qt: Add filter buttons to QToolBar as QActions\n4a892f4dea X11: Remove a few stray glib types from process-x11-xcb\n06bfc99ca9 Convert the X11 generator and code to C99 types\n270ed45065 tools: convert eti2wireshark.py\n333adde36f Qt: fix unreadable syntax filter in dark mode on KDE with Qt 6\nbec3abdf15 More init removal for hf\n2f76452bee Qt: Connect more main window signals and slots at compile time\n6fa13ededa radius: Support $INCLUDEs with absolute paths\n416c99129f Add support for LeakSanitizer.\na77391d494 Add missing MAP tag in Erlang distribution dissector\n1e3a41a808 matter: Fix Flags type for Matter Advertising Data dissector\na69feb8e02 rpc: Add RPC-over-TLS registered ALPN\n98d71abb49 wiretap: simplify fill_out_buffer().\n86ca02a9cd wiretap: rename gz_head() to check_for_compression().\nef37a3e41e radius: Switch back to the previous FILE if an $INCLUDE doesn't open\n989c4e192c JSON: display number object as a double\nbe796b759a wiretap: mark #else and #endif with comments.\n80ddd6bdec ITS: Fix reading of containerId so the right container is used\n8501d71346 wiretap: define and use USE_ZLIB_OR_ZLIBNG if we have either library.\n8a063371c3 wiretap: put decompression stream information together.\n22aad01a3c plugins/codecs: convert to C99 types\n9334cca935 ntlmssp: also create an anonymous session key with an 1 byte lm_response\n3b4c215a5f Make sure .scap is a valid pcapng extension\ne329f96a87 stats_tree: convert to C99 types\n16553ade76 MySQL: Add dissection of more types in binary protocol\ne9acac7088 packet-cql.c: use proto_tree_add_item_ret_string()\nada3dfa824 packet-cql.c: properly parse a schema change result\n5c4291d440 Qt: Pluralize \"%Ln bit(s)\"\n5ebf5ca5e4 miwi-p2pstar: remove init for expert_field variable\n78d95ad9aa saprfc: remove init for expert_field variable\nd1a6a88806 rk512: fix indent (using tab)\ne599ff8366 rk512: remove init for expert_field variable\n3f7c2adf90 egnos-ems: remove init for hf/ett/proto variable\nf8af789411 miwi-p2pstar: remove init for hf/ett/proto variable\n601a2e1bdb iec104: remove init for hf variable\n9e5cbbacee DHCP : Display DOTS information RFC 8973, additional status codes from RFC7724\na7e746090d Qt: Show bits size for appropriate fields in status bar, packet dialog\nb3a0cb32ae plugins/epan: convert to C99 types\nbb2aef6f7d docs: Remove user interface section from Wireshark man page\n7e7986fa9d WSUG: Update the automatic profile switching docs\nda80ca3ccb Qt: Directly connect more signals and slots\n0f77268bc8 epan: packet change return to bool\nb0ac6dcb53 WSUG: Update the Configuration Profiles dialog screenshot\n050ac413ff mp2t: Support files like BDAV M2TS with a header\n6597563934 Qt: Fix build on older Qt 5\n984b2ba803 tvbuff: use bool rather than gboolean for return values and local variables.\n00d761d224 capinfo: convert to C99 types\n9cd0d15d21 matter: Add dissector for BLE advertising data\n3853be5bba Fix some spelling errors\ncc8490681f epan: Convert the value_string code to C99 types\nb9a6ecdb0a capinfo: table_report_header should be boolean.\ned34fc324a TACAS: remove unused code\n1b6222d1fa DNS: Add new top-level \"Answer Type\" statistic\n56537aa72a Dumpcap: u_char -> uint8_t\nf358612e7a MySQL: Decode execution of prepared statement with query attributes\ne712788773 BIER: Add BIER encapsulated in MPLS (RFC 8296)\nef2e116fab VS19: Suppress a couple of const warnings\n60b33815fa Fix some spelling errors\nf5170aa507 MySQL: Add tree item for each field in binary protocol\n2fdbb6ee0a dfilter: Have editorconfig refere to correct translator filenames\nc473803e19 Fix 9P stat permission parsing\ndd893873bf Qt: Have all DisplayFilterEdits have bookmarks\ndd316b00ce prefs: Add help URLs for the modules added normally\na1a7d236b7 Qt: Open the Preferences dialog help section for the current pane\n0b2b1cc498 Qt: Make sure the profile switcher has an initialized profile list\n03d88c9f41 CMake: clear stale PCRE2 cache entry if needed\n8c6619efd6 MySQL: Use json dissector for JSON results\nd0759e5f1e MySQL: Decode JSON in binary resultset\n8a3be65f04 fix dead URLs for CCSDS\n51668e48ca epan: heuristic to pass void *data to dissector\ncf57c1aa5c PW Eth: More heuristic tweaks\ndbe10e253f manuf-data: Don't omit the privately registered IEEE assignments\ndb956a9b80 [Automatic update for 2024-06-16]\n55bba99ea6 NTP identify chrony frequency transfer and network correction extfields\nc1fe4ce86d packaging: Fix RPM on SUSE\n6fcb1445e0 Clean up the dissector handle code.\nc1bd0d561b thrift: fix return value of dissector\n3b46d9294f PNIO: fix return value of dissector\naa5929b2fd stun: distinguish between draft and RFC XOR-MAPPED-ADDRESS.\n56ac0722f2 Remove some unnecessary extra layers of dissector.\n563479c322 docs: Add VERBATIM to add_custom_command\n15b77d6845 MPLS Pseudowires: Add dissectors to first nibble table\n667fcaa14b docs: Install user guide to build dir\n4f8bb21107 epan: changed heur_dissector_t to bool\n30eba22945 packaging: Build RPM with guides by default if we can\n6ead3e2657 log3gpp: Fix read of uninitialized data.\nfbedfaa160 NSIS: clarify personal configuration uninstall message\n1bd09aa109 More spellings\n1692f91fb1 ui: Fix help url comments\n392a2a695a wsug: Use \"Font and Colors\" not \"Fonts and Color\"\nc2d133a6e2 Qt: Explicitly connect some signals and slots\n9de1089ad8 UI: switch back to wiki.wireshark.org, fix some URLs\na3becdd643 Qt: Explicitly connect our welcome page signals and slots\n4876c160d6 Fix C6323: \"Use of arithmetic operator on Boolean type(s)\".\nccc085af59 MPLS: Add a dissector table for first nibble, heuristic list\n37a449345b Lua: Default Dumper to pcapng\nba5777a8bc check_typed_item_calls.py: fix a test\n5a94fd5022 capinfos: Fix printing packet comment headers with -TM\n2584980a7e dumpcap: Always drop capabilities other than NET_RAW and NET_ADMIN\n3440f67211 Fix some more spellings in header files\n440b23d4bf Qt: Call init_profile_list() early\n4c8aa06cc3 dumpcap: Enable capability debugging through the normal log system\n9443744980 Initialize some variables\nf90c517f45 Docs: Add option block titles to the falcodump man page\n15f90c2dcd MATE: stop config on unknown Proto/Transport/field\nd86e2fcaa7 CmakeFindZLIBNG: Add library name\n9520691e0f macos-setup: Build zlib-ng\n387e653017 Qt: Make sure we don't scan interfaces more than once\n4e5cd1ae68 Qt: Add a null check to the Conversation dialog\n365a821298 wmem: Remove G_GNUC_MALLOC from wmem_realloc and wmem_memdup.\n8f664d3784 EVS: do not append \"EVS Primary 2.8 kbps\" twice\n6099e2ed9e EVS: fix dissection for hf-only=1\n4740168ef2 ZMTP: Add null checks\n4da2be8875 merge: Don't abort a merge on a short read\n12ccb05cf8 MATE: dbg_print - frame line break; print name:id of matching GOG\n9ec125e617 MATE (WSUG): update Overview chapter; booleans are now words\n25696b8612 Change some `wmem_packet_scope()` to `pinfo->pool`\n2660a0f76a GitLab CI: Add Falco plugins to our macOS packages\n8ebb1132f8 mailmap: alias two email addresses\n413b33fe5c Build: 4.3.0rc1\nb186f0b802 GitLab CI: Fix a copy+paste error\n3f13b35a12 GitLab CI: More macOS build tweaks\ne8c06e558b Update the release notes\n40140ecc65 GSM MAP: Fallback Application Context version on unmatched transactions\n0b58495ffb Falco Bridge: follow stream only for syscall\ne879491e75 packet-c15ch: Enhancement of the C15 dissector\na71a628840 GitLab CI: Another temporary include fix\n7ba18b976f GitLab CI: Temporary include fix\n426d81bdd2 GitLab CI: We don't have Falco plugins on macOS yet\n61305fd4b1 GitLab CI: Build Logray DMGs on macOS\nef46758d9c Qt: Check for a null recentList\na8db45c8a7 Address resolution using SNI found in captured handshake packets\n5b43a3464e Windows: Update our Falco plugins\n77a5c37879 Spellings in dissector header files\n6023b8de6b dumpcap: Restore printing machine readable interface list to console\n9dae98036a HTTP2: Don't add mutimedia/mixed as the stream id dissector.\n35c8b1721f vmware-hb: Update Build Number\n490d821054 macos-setup: Fix some shellcheck warnings\n9e0b8f0baa capture_sync: Don't exit a command on a log msg\n49ac59ee88 Fix some spelling errors\n7101f2878b Qt: Adjust stretching for Edit Column\nf55e50d7bf stanag4607: Fix mask bugs and enhance dissection\n01d8231515 eth: Fix location of src not group address expert info\nece75c40ae Qt: UatFrame and UatDialog contiguous selection\nd81b529d09 Qt: Move the IOGraph up/down buttons to the left of clear\n71221471a9 Qt: Fix a crash in Endpoints/Conversations if recentList is NULL\n5c92113ecb Qt: Contiguous selection in IOGraphs\ne44e99b8e2 UAT: Add a function to remove multiple records\na41bfaf11e Prefer col_add_str() to col_add_fstr() with \"%s\"\n5f8d76543d [Automatic update for 2024-06-09]\nd150240236 Release-notes:Add zlib-ng information.\nfd6a792c54 RPM: Add zlib-ng-dev as an optional package.\n71f0456103 MATE (WSUG): update tcp.mate example; code examples formatting\nc9456daf47 Falco Bridge: add falco to dissector name\n8f9a9efc65 USB Audio: Fix typo: \"vwalue\" -> \"wvalue\".\naddd201369 CMake+NSIS: Add the CloudTrail Falco plugin\nc6bbfe0934 wsutil: Fix extcap configuration initialization on Windows\n54f7a3f89a check_tfs.py: add a flag to count usage of common elements\n9696c24c90 Versioninfo: Add missing space in zlibng version string\n2e47e888a3 Add & use tfs_data_pdu_control_pdu\n21767abdd4 Versioninfo: Fix zlibng version string.\n22e5945b38 Make .c files in wiretap include the corresponding .h first\nce3ee9ba0f Brew add zlib-ng\nfab6e005b7 dumpcap: Implement the -Q (really quiet) option\n39d8467d88 RTPS: Add ability to decode RTPS messages protected with PSK\n77888b168b rtmpt: fix clang warning about unused variable\nf2f03f6fe2 A-bis/RSL: dissect known COMMAND VALUEs\nf7e6a27d23 A-bis/RSL: fix parsing of hf_rsl_command, add hf_rsl_command_ext\n1bc0ffa9de A-bis/RSL: fix parsing of Command Indicator IE\nf35f053445 NSIS: Don't install the CloudTrail Falco plugin\n2d05ed5ed9 wsutil: Fixup our debug console window title\ne349937b18 Windows: Fix the Falco libs Arm64 package\nf2b994eb88 GitLab CI+CMake+tools: Add Falco libs 0.17.1 and build Logray\n6c911a833a zlib-ng2: add DLL to NSIS and WIX installers\n19ea7ca8d3 capture: Support the -F option, request nanosecond time stamp for pcap\n69c06cb9cc pw-eth-nocw: Strengthen the heuristic check\n11157e6f74 MATE: new AVPL first added left at end of list\n37c5883848 ieee80211: fix trigger name type displayed in Info column\ncea97e5dfa Zigbee ZCL: Improve Thermostat Cluster support\n2c84133c1e ipsec: Have a preference to allow bogus padding to pass NULL heuristic\naa0911e709 MATE: Switch times from floats to doubles\n28677566a6 Bluetooth: Convert 32 and 128 bit SIG UUIDs to 16 bit\nddec068b0c lldp: Make dissector less greedy\n25e1a8e48a macos-setup: Fixup the Falco libs pkgconfig generation\n6e89d99e09 RTMPT: Attempt to fix OSS-Fuzz 69219\n82124e2571 ieee80211-radiotap: Fix integer handling issues\n9c5be0c9fe ieee80211-radio: Fix array indexing\nf833bec344 Add some more spelling words\n7b29a0ac90 Add more spelling words to wireshark_words.txt\n96fc4db55f ieee80211-radio: Add EHT Data rate computation\n2059cd7144 saprfc: fix Dead Store found by Clang Analyzer\n389151f569 Qt: Allow the Learn links to word wrap\n19405895f6 E212: Fix a duplicate entry in mnc value_string\n6b33196381 Try adding spellchecker to pipeline\n3db6a6624c win-setup: Fix packasger name of zlib-ng on arm\n2bbc6d5ce2 BLF: Don't include zlib-ng.h twice.\n885a9b2811 findZLIBNG: Fix hint. zlib-nf is in its own folder and include\n70656cd8b3 ZLIB-NG: Add posibillity to use ZLIB-NG.\n93ec0877ee zb-ncp: Add r23 packets to dissector\n1eb6d49815 Add updated windows packages zlib-ng and cvpkg-export\n1b7d3415b3 packet_range: Get the number of packets chosen\n55e08da673 Qt: Update last applied filter if and only if applying\ne1144a24f6 SMB2: Update NETWORK_INTERFACE_INFO \"RSS Queue Count\" to Reserved\nbdc66cff21 MATE (WSUG): add images to List of Figures\n75924801d9 Fix some spelling errors\n3760147893 RK512: make a preference variable static\n92d958ad45 Make FT_AX25 a string-like type\n3ac65170d2 Qt: Fix leak in InterfaceTreeCacheModel\n68d4f1be3c VRRP: Change default method for\tVRRPv3 checksum\tcalculation\ne179984f0a MATE (WSUG): consistent acronyms; ToC formatting\n27385a62e3 miwi-p2p-star: fix clang warning about documentation\n2b30075493 miwi-p2p-star: fix commit check error\nba5613e681 miwi-p2pstar: fix build\n0072947520 Add MiWi P2P star dissectors\nc463ac88cb Qt: Use the term \"event\" in more places\n714d4ca0c9 btatt: Fix direction of Mesh Proxy Data In\nb883762491 tap-iostat: Reduce memory usage\n25f125c5b9 Qt: Make it more obvious and user-friendly to restore snaplen to default\nf622eac21f Qt: Make it possible to clear Comments from all interfaces\ndddd244dc0 Qt: Put toolTips on the label stack as well\n154cbfc3f0 [Automatic update for 2024-06-02]\n7091d67d46 Logray: Hide some menu items\ndb39247719 check_typed_item_calls.py: blurb and repeated filters\nc29c1bb27c Qt: Fix leak on CaptureFileDialog preview of file with errors\ncc8264d68f test: skip test_sharkd_req_follow_http2 test if no http2 support\naa68da794f Protobuf: avoid a couple of redundant assignments\ne8c0851bf6 sharkd: Add \"comments\" field to \"frames\" method\n3952b0a11f epan: Convert the follow code to C99 types\n938f0722ce epan: Convert the address types code to C99 types\nc65b263354 YMSG: Replace content field values with field names where possible\nd747de352a YMSG: Update Dissector with reversed Commands, Statuses and Content Fields\nb3263e5b3c Change the Telephony stat groups names to reflect their current position\n9d1113f293 ETW: Expand flags and property fields\n931c71a406 Zabbix: Add zabbix.agent.redirection filter\n138d043886 Qt: Endpoints and Conversations last opened tabs\n2cbfa825f2 Falco bridge+falcodump: Update to Falco libs 0.17.1\n16d4c4ad66 ORAN FH CUS: update some comments quoting section numbers\nd9c5e3585f Fix some spelling errors\nadb9543df7 NAS 5GS: fix dissection of extended rejected NSSAI IE\n2bd458e5aa SMB: Eliminate \"[transact continuation]\nb71ddc7afc matter: Bluetooth Transport Protocol dissector\nfc77875129 Qt: Raise autostop filesize limit to 2 TB, enforce in the GUI\n8b9c3c620e Qt: Fix CaptureOptionsDialog tooltip for stop files spinbox\nff2d72decf SAPRFC: Call val_to_str_const() as no format in default string\n718c035b04 lua: Add methods for other compression and decoding algorithms\n17a14beb71 Fix remaining 'redundant' item blurbs\n3fb21089d6 btle: Extract out function obtaining btle_context\n61e906f67d btle: Dissect CRC in one place only\n01c4326045 btle: Remove btle_context_t::connection_info\n4690e7328d Tools: Minor arch-setup and alpine-setup cleanups\nfa15d4042b Remove more redundant item blurbs\nb91773117c Update mailmap\n2b8f96969c Fix typos in packet-tls-utils\n3f28340979 epan: Rename tvb_[child_]uncompress to tvb_[child_]uncompress_zlib\n8e5f8de883 SPRT: Fixed SPRT Parser Crash\n6cb8ac5676 Protobuf:  don't write beyond end of array\n448ae64bf3 USB-Audio: Add dissector for Extension Units\n9962a87a8a MySQL: Handle DATETIME if the column definition is unsigned\n11a834966a Update packet-lldp.c\n9c2e5f9166 lldp: prefer proto_tree_add_item for LLDP PNIO Port Status\n9510d0303a lldp: fix duplicate display filter\n08d864bd0e LLDP: use tfs(on_off) for Profinet Class3 Fragmentation\n05f6364cbd SPRT: Fix crash\n72baba76a6 Add RK512 dissector\nab47b25fa3 cmake: lemon: wipe CMAKE_SYSROOT if needed.\nab2b4ff756 SAPRFC: Fix compilation\n3ab27e2356 SAPRFC: Added SAP RFC protocol as main dissector\n86bfe36281 LLDP: add more information for 802.3bt properties\ne2f44831aa LLDP: format new 802.3bt power values as Watts\ncbe856fbc0 LLDP: update power-over-MDI decoding to 802.3-2022\n719fbc53bd adler: Use zlibs version if available to benefit from any optimisations\n53ece3998e lua: Update the documentation for tvbrange:uncompress\nf20dfedbdf Falco bridge: Translation fixes\nf21418adce Qt: Keep status bar correct in multiple file mode\n3e8eaf03ce adwin-config: Restrict UDP dissector to port 7000\n20c464f32a Delete yet more redundant item blurbs\nbd660b39d0 Falco bridge: Add a string length check\n14dbca3f71 Ignore Conversation Filter, Conversations, & Endpoints stat groups\nd62171c1f5 epan: constify field_info as a parameter in a few functions\n0120000427 doc: Move UAT tables back up a level in WSUG\nd12b9a7662 X11: Finish const-ifying.\ndeffaab5aa Delete more redundant item blurbs\na6a74afa8c Iperf2: Isochronous and FQ Headers should be present if CCA flag is set\neaeb83584e Qt: Put MENU_STAT_GENERIC / REGISTER_STAT_GROUP_GENERIC stats somewhere\n91032f6fbc capture: Always pass the interface description to the capture child\nfe16c00a67 SCSI: Const-ify scsi_cdb_table_t instances.\nc775c96f24 IPMI: Const-ify ipmi_cmd_t instances.\n100fd9f2ec SMB: Const-ify SMB{,2} function dissector tables.\n05b5359301 DHCP: Const-ify some option-parsing structures.\n3696e92990 Lua: update globals and test\n335b153951 Lua: Update the docs for 5.3 and later\n91cdcb2737 lua: Register new ProtoFields and ProtoExperts in Evaluate window\nea927f9cb0 LUA:Drop support for LUA 5.1\n66aab8bfc5 Make crc32 use zlib function when available\n61dfa20808 wslua: Update register_menu doc for consistency\n631c1af6da wslua: Remove bogus register_menu documentation\nc535090848 Qt: Add MENU_STAT_TELEPHONY_SCTP groups to the GUI\nfbaad1657c wslua: Set the log domain for the files that use logging\nd40040eac7 Qt: Only remove and delete the FunnelTextDialog's own buttons\na3d57e8897 Qt: Always return paths with native directory separators\na3c63ce61f Docsis TLV: remove blurbs that are just subsets of labels\n8dea03b0df Zabbix: Add support for agent redirection message\nf12e11acca lua: Update manual links from 5.1 to 5.4\n10329ac196 MySQL: Assume a minimal set of capability flags\n5443e9192e Qt: Fix a leak of the MaxMindDB paths in the About dialog\n5a8a7077f1 lua: Fix leaks when reloading plugins\n8cc925bc2e [Automatic update for 2024-05-26]\n460c22a146 epan: Fix another leak in dfilter translator\n9001df8d64 Fix some spelling errors\nfa1f32c2e0 epan: Fix leak in display filter translator\n6e891ac5f6 doc: Mention the MaxMind default directories\n293262bc37 Qt: activateWindow when asking about unsaved packets\n8850120bd6 enterprises: const-ify the table and use array_length.\na4db80d018 enterprises: Manual update in preparation for \"const\"ing.\nea2e15be6c RTMPT: Add Enhanced RTMP Multitrack Support\n59561df10a Qt: Drag and drop for I/O Graphs and other UAT-based views\n4a916ce570 docs: Update Display Filter Macros, UATs in WSUG and elsewhere\n2e7fbd021a ftypes: Const-ify ftype_t references and instances.\n5d4bd0e9b0 MMS: Initialize parameter_tvb, check if it's NULL\naa760445c3 sharkd: Fix bad \"stream\"/\"sub_stream\" reponse fields in \"frame\" method\nc659f21bc3 btatt: Support Read Multi Variable Read / Response\n6b9cca6e59 Fix build after 10d70661343a2548b5867bfd5a1964def327e938\n10d7066134 Use array_length instead of \"sizeof arr / sizeof (TYPE)\" (Part 2).\nc7635588d9 uat: Minor updates\n863b5f6d98 CMake+tools: Add more scripts to the shellcheck target\n26c57d271d dfilter: fix memory leaks in translation registry\nc0100f5705 wsutil/CMakeLists: add missing array.h\n13ca1a4ca4 Delete more redundant blurbs\n591550c315 Use array_length instead of \"sizeof arr / sizeof (TYPE)\".\n1358f8cb35 Qt: Add context menu to launch I/O Graph\nbf3172e86f qt: Work around gcc 12.1 optimization bug (more e1a6913a).\n466f77c706 LTE RRC: Use array_length and fix a minor bug.\ne60926f848 Falco bridge: Fix compilation\na4904bc1dd Fix GATT service discovery when both sides have services\n7b87fb200d tools/check_typed_item_calls.py: check blurb vs label\ne09cfc09f2 Pass conversation types to conversation functions\nfc1dcd86e7 Replace \"ElementsOf\" macro with common \"array_length\".\n779525d436 Replace all \"sizeof x / sizeof x[0]\" with array_length.\ne3adfd5c36 Consolidate array_length and g_ptr_array_len into a new header.\ne49d6dd7cb Shellcheck updates\n0c3bf2d77e RLC LTE: fix dissection of EUTRA DL CCCH messages\nb457e92c82 caneth: Initialize the other fields of the can_info\nbf1f858061 TCP: Set base sequence, relative sequence numbers for IP fragments\n5fe00c99b2 Debian: Update our po files\n8f1bf84efb Debian: Logray packaging updates\n7c4bb6eb3c epan+UI: Add display filter translators\n5819e47e84 Zigbee GP: Don't try to decrypt truncated TVBs\n15ced22366 Revert \"Lua: Fix handling of Wireshark exceptions inside dissectors\"\nc37480e0dc Lua: Fix handling of Wireshark exceptions inside dissectors\ne73d316bcf Zabbix: Change GLib types to C99\n59e6eb3d23 Fix some spelling errors\nadfa002030 TCP Stream: Make sure the SACK rel/abs sequence number is correct\n53d8c1b659 MySQL: Handle displaying parameters and result sets in charset\n8f6822071e Qt: Switch rwin_graph axes depending on TCP Stream graph selected\nd2f17dcb84 IEC104: Fix some range_string values with -ve range\na24f2fa307 tls: Support ECDHE_PSK cipher suites from RFC 8442\n8e2a8b9eba kerberos: add aD-PFS used by apple\ndf1d24a247 kerberos: add basic dissection for pA-SRP (used by apple)\n8a2a42241f Const-ify dcerpc_sub_dissector structures.\nf678ff67bd DCERPC: const-ify references to dcerpc_sub_dissector.\nba36d7474e [Automatic update for 2024-05-19]\n46387e29d8 tls: Refactor PSK key exchange\nb3cd29910a Qt: Disconnect UatModel when closing file in IOGraphDialog\nf38c37c7c3 ui: Add include for io graph item\n3c57680a48 Qt: Add a getter for fileClosed in WiresharkDialog\n9fb91d58a6 CMAKE: Fix ENABLE_ASAN for MSVC\ne831244038 smb2: allow decryption using keys learned by kerberos\na5f9dcec48 smb2: support 32bit session keys they are used with kerberos\n80404fa096 smb2: mark invalid frame_{req,res} with UINT32_MAX, frame_req=0 can be a valid one\n4994c7d3ce kerberos: copy pac_names from EncTicketPart_key to EncAPRepPart_subkey\na5070214be kerberos: let dissect_krb5_PAC_DEVICE_INFO/netlogon_dissect_PAC_DEVICE_INFO provide device_sid\n1ba660c0b3 kerberos: remember account details from dissect_krb5_PAC_UPN_DNS_INFO on EncTicketPart_key\nf28f515e44 kerberos: simplify struct dcerpc_info faking und use ptype = UINT8_MAX\ne4e4074c36 dcerpc-netlogon: let netlogon_dissect_PAC_DEVICE_INFO() generate a device_sid\n3effa6c750 dcerpc-nt: add dissect_ndr_nt_PSID_cb()\ncc099f7c96 dcerpc-nt: let dissect_ndr_nt_PSID use CB_STR_ITEM_LEVELS(2)\nf5a48b11c3 dcerpc: move ndr_pointer stuff to dcerpc_info and avoid globals\n7942590f18 dcerpc: pass di to find_pointer_index()\n0045546576 dcerpc: fix warnings when converting guint * to char *\na9c5a7639a UDP: Correct level of hierarchy for the payload subtree\ne0a328e372 Implement IEC60870-5-7 Secure Authentication\n523776ee68 Tools: Update debian-setup\n6e8a12a738 tls/dtls: Add support for ECDHE_PSK\na3117aed72 tools: Update Lua to 5.4 for Alpine\n7bf71c0b3a tools: Update alpine-setup\n59b376dce0 CMake: Look for the lua library with versioned suffixes\n1ed58a814a tls/dtls: Add support for DHE_PSK\n8d97dd8959 dtls13: support early data and various fixes\n004782d734 GitLab CI: Fix our commit count\n933f1dbcce Lua: Use pushnumber or pushinteger on structs depending if it fits\nacd72486e8 Lua: Check size of lua_Integer\naf5960edf7 Qt: Disable a I/O Graph Dialog's UAT when the capture file is closed\n9094db82e1 Zabbix: Rewrite passive agent detection\n845948ecae ntlmssp: generate a session key for anonymous authentication\nada4ff5a72 LINK16: update Message and NPG strings\n3261d39edc UA3G: Flag a couple of value_strings that have wrong values\nb94fd299ed macos-setup: Upgrade Ninja to 1.12.1\n260d28ed9f Gitlab CI: Use the Medium GitLab SaaS Linux Runner for Clang-Tidy\n2e0d1b8da0 btle: Fix usage of periodic_adv_info_tree to avoid memory corruption\n29012e8497 CMake: Have CheckAPI targets depend on the source files\nc0bb8a18fe Fix a copy/paste error in tools/check_typed_item_calls.py\n1219a22255 dtls13: add support for DTLSv1.3 decryption\n8beafca0e0 dtls: v1.2: refactor out appdata dissection\n7af116b4d2 ieee80211: Add \"HE PHY\" BSS membership selector\nea4b5de09a static-ify a bunch of const locals.\n7698e03ba1 Qt: Fix RTP Player crash\n98cf88ca7f Zabbix: Detect and show pre-7.0 passive agent error messages\n9d7b2b0ad2 Fix some spelling errors\n6ccb0e0677 CQL: Use val_to_str_const\n169392ce60 Packaging: Get MinGW cross-compiling working with Qt 6.7\n70a3c9f829 wslua: Fix segfault when registering a field / ei twice\n02afc549f8 epan: Convert the column API to C99 types\ncdc1222434 smb2: fix ahndling of pre-3.10 Negotiate Protocol.\neb9b12e60a SMB: Display bytes before TDC is reached\nff99ab6bc3 SMB: Display bytes until TDC in TRANS2\nc2769f24fc SMB: display bytes before total data count\n600fe274c5 Qt: Add context menu to I/O Graph UAT header to resize to contents\n49fda244c8 [Automatic update for 2024-05-12]\n6c077b3c06 release-notes: Mention graph updates\n05ef1f4451 Qt: Fix a crash when retapping I/O Graphs\n2b2b032af2 lua: Deregister heuristic lists added via heuristic_new on reload\nc0b47f7a7b Bluetooth: Mark AUX_SYNC_IND as AUX_SYNC_IND instead of AUX_COMMON\n411babf083 Bluetooth: Improve packet dissection when PDU type is unknown\nab18953439 tls-utils: fix JA4 fingerprints for QUIC and DTLS\ne5bac5721a spellings in ipv6 comments\n3d19dffc02 docs: update README files for some static initial values\n858bd5c2a0 Falco bridge: Make EOFs less verbose\n8c21bdd76e NSIS: Fix logray.nsi\n4049ea7e6c Lua: Fix DissectorTable on certain Lua versions (e.g., 32 bit)\ne2d1030255 dumpcap: Print a pcapng block type in hex\nc1c3cd75f7 Falco bridge: Fix our event cache\nc67f85430c macos-setup: Update to GnuTLS 3.8.4\n9ca9618194 Zabbix: Add Zabbix 7.0 features\n1428fe28e6 Lua: Revert a mistaken change to lua_pushinteger\n7882e2dd2f Qt: Add visual notification to UAT Model entries that won't be saved\n706c40efe4 Z21: dissect LAN_GET_HWINFO\n25a49ed0da Z21: dissect LAN_GET_BROADCASTFLAGS and LAN_SET_BROADCASTFLAGS\n2bdaac6de8 Z21: dissect LAN_GET_LOCOMODE, LAN_SET_LOCOMODE and LAN_SYSTEMSTATE_GETDATA\nd11798e575 macos-setup: Add opencore-amr 0.1.6\n6622e10475 matter: add comments with references to spec sections\neb4d4ba5bb matter: use C99 integer types instead of glib types\nab31326397 wslua: Use Lua_Integer where we can for the wslua_ functions\n969b716740 Windows: Add opencore-amr 0.1.6\n00e069e6cd Add a ENC_TIME_ZBEE_ZCL time encoding and use it.\n48680be67a tzsp: register dissector table sooner\n96095979f8 Add and use tfs_activate_do_not_activate\neccf1104d6 GitLab CI: Remove LUA_FIND_VERSIONS ANY\n4438847557 Qt: Apply pending I/O Graph UAT changes when changing profiles\neffad83df8 ui: Return failure on a zero or smaller I/O interval\n1b443364a6 Qt: Keep the I/O Graph legend in order\nb119b9d601 Windows: Upgrade GnuTLS to 3.8.4\ndf25f11ef5 Qt: Fix I/O Graphs crash with multiple dialogs\n4acd5d3dbc 802.1CB: add a trailer field.\nc8a21fd579 Fix some spelling errors\n8c92ca7aff rpc: fix handling of ONC RPC with unknown protocol.\na53c458c7d samr: fix arguments to lsarpc_dissect_struct_lsa_BinaryString().\nb98d0939bc falcodump/falco_bridge: Add back ZLIB_INCLUDE_DIR on Windows\nfe51f8424f Windows: Upgrade nghttp2 to 1.61.0\ne23cbfee8b spengo: add basic dissection of IAKERB pdus\n86895994d6 Rename ENC_TIME_MP4_SECS to ENC_TIME_MP4_FILE_SECS.\ncbc005f9fc tzsp: use a dissector table for the encapsulated protocols\n7178f56825 Rename ENC_TIME_CLASSIC_MAC_OS_SECS to ENC_TIME_MP4_SECS.\n0a94c0b2ca Zigbee ZCL: OTA Upgrade Time can be UTC not offset time\nbb479f4ea6 Convert a process_specified_records callback to a bool\nb5355046a2 GTPv2: Add Information element on IE Types with multiple instances\na0e399e5c3 gitlab-ci: Remove docker tag from jobs\n73b0c12e38 epan: Convert a save_protos_list callback to a bool\n24a0417eb0 Qt: Restore TCP Stream switching between absolute and relative seq\n6eb74c5b36 Qt: Connect the TCP Stream Dialog crosshairs action\nc558094638 MySQL: Update collation data\n33c5c85f10 Revert \"MySQL: Multibyte Collation Support\"\n14cb797040 Qt: Use customContextMenuRequest signal with QCustomPlot\n4464c7f245 TCP Stream: Make better decision about which side is the server\n5ca4d08b9a dot11decrypt: Have Dot11DecryptFtDerivePtk return failure on failure\n2ce3882d3b epan: Convert a follow callback to bool\n74aa73afe7 epan: Filter address columns for types without a filter function\nfc8e0d583d kafka: Dissect assuming a supported API version\ndf1a129b19 [Automatic update for 2024-05-05]\n80cb54344c Kafka: Sanity check array dissection\n3bf649206a Qt: Flow Graph for unique addresses\nc0deea09ee docs: update WSUG and man pages for network resolution\nf306c1653a epan: Switch our capture dissector callbacks to bools\n723bb5d37a epan: Switch our decode_as callbacks to bools\nfb438a29b7 Peekremote (v2): Add Data rate computation\n2d722e7ad7 epan: Switch a conversation filter callback to bool\n30bb8f5950 docs: Combine the FILES section of man pages using an include\nebcc6be29f Fix some spelling errors\n122f0aff99 Qt: Export the entire flow graph as image (or as much as we can)\n9ab952b964 ZigBee TLV: fix infinite loop in deeply nested packets\n593ea4b16f dot11decrypt: Prevent maybe-uninitialized warnings with LTO\nfe4ef60a53 MAC-NR: decode MSGB PDUs\n23d36f4b38 Zigbee ZCL: Complete IAS ACE Cluster dissector\nb4bcf69166 wimax: Change include_cor2_changes to a bool where it's declared\n0842745d10 recent: Lazily fix the recent column width and alignment list\n317b93dbb8 CMake: Fix our Falco plugin path\n704fe87abd Qt: Fix an typo of row vs count in columnListModel\n045e00939c Qt: Fix Coverity CID 1596731\n9ca6eff53d PIDL: Don't initialise static hf and ett variables.\na1ece0131d Add error handling for gcry_md_open.\na127ce71b3 Zigbee GP: Fix crash with check if data is null\nf3a42c5cd5 DTLS: Don't check legacy record version in dissect_dtls\nae5d917309 Qt: Check Flow Graph \"Limit to Display Filter\" in constructor\ne9c92d0b64 tls: Add expert info for unsupported, illegal key exchanges\ne1cb009f6e logray: github macos action with brew install\nd55dab93e7 wimax: move shared preferences to a header file.\nd5c90cf182 sequence analysis: Fix inconsistent and illogical use of \"Any\"\n742648ccdc TLS: Add missing break statement\n8e1ce872ad DTLS: Support heuristics for DTLS 1.3 unified header\n8747d60e3e dcerpc: PFC_HDR_SIGNING is negotiated only once per transport connection\nfc6dfad9df CQL: Add some more information on various CQL packets in the COL_INFO\n775c3be838 MySQL: COM_CHANGE_USER may not have connattrs\nc832290745 MySQL: Multibyte Collation Support\n14b592ca78 Qt: Cleanup Flow Graph a bit\n1da57b5ad5 LAPD: Set source address\n2884e9a5b8 irdma: IBM i TRCCNN RDMA dissector\n78c6af54ab dcerpc-netlogon: add ServerAuthenticateKerberos()\n3156103b8f Diameter: Remove Whitespace error\n7a37fa1837 Diameter: Decode MME-Number-for-MT-SMS(1645) to ISDN number\nc9d1bb229c epan: Remove a couple of unused struct elements from tvbparse_wanted_t\n2e89527513 Qt: enable tooltips in Copy menus\n17c238e25a gssapi: also register \"gss-tsig\" as \"dns.tsig.mac\"\ne1a965d2f2 Github/workflows: update actions using node\na95dec6ef9 Qt: Fix ProgressFrame location in non-VoIP Flow Graph\n44aec53735 Github/workflow: update upload-artifact action to v4\nb088414e38 nettrace_3gpp_32_423: expand name length\n8a5717c08a DNS: Add DNS Error Reporting (RFC9567)\nb2cfbb7279 Copy as Printable Text: specify ASCII or UTF-8\n1f35d50889 epan: Switch the prefs API to C99 types\n6ab1417123 epan: constify the header_field_info in the field_info\nfa8b28f013 CMake: Get rid of a check for WIRESHARK_BUILD_WITH_QT5\n956747b76a Appstream: Fix appstream errors for Flatpak\na136377981 DTLS: Scan server hello correctly\n826ddddfe9 falcodump/falco_bridge: remove ZLIB_INCLUDE_DIR\nf844a1b722 Qt: Move I/O Graph reset button to button box\n50ea04e4dd epan: constify the packet_info pointer in find_conversation functions\n18422c168c Conversations: code maintenance for the deinterlacing method\nc8044fffaf macsec: Fix Coverity CID 1596640\n84fe646b78 Qt: Use afterLayout signal for Flow Graph y axis labels\n674e79c29e GitLab CI: Fix the Documentation job artifacts\n7ef8501c34 ptp: multiple tlv_pathsequence in announce message\n4f8f52dea0 GitLab CI: Fix the Documentation job\n4320031c97 ipars: Fix truncation warning\n9ea2377c80 [Automatic update for 2024-04-28]\nf566d380e2 sharkd: Support microsecond intervals in \"iograph\" method\n15392c324d wslua: Fix integer validation signedness\n0810f94f88 Fix some warnings from check_typed_item_calls.py\nbaafc805bb Fix some spelling errors\nf1dd3bf4f2 5co-rap: Use ITEM_LABEL_LENGTH for snprintf in CF_FUNCs\n575bce404c Qt: Fix Flow Graph y axis column widths\ne703e51887 \"Linux IPMB-over-I2C\" is really just \"Linux I2C\".\n2056120ddc 5co-legacy: Use ITEM_LABEL_LENGTH for snprintf in CF_FUNCs\n03acee1d0f Qt: Add a preference for automatic profile switching\n03579023ca Qt: queue Flow Graph replots that result from mouse moves\ncc4c931b4a Qt: Fix flow graph scroll direction via keyboard\n22a6672fee Qt: Explicitly connect our profile dialog signals and slots\nb778bebe50 PROFINET plugin: dissect PROFIenergy measurements\n259bbbff2a Qt: Fix Window scaling graph axis labels\nea5ed37426 TLS: SM3 and SM2 are not in TLS (Signature|Hash)Algorithm registries\nbb38a9fa13 TLS: make reassembly function table static\n85e8f07b7c SDP: Don't replace generated Call-ID list\n8b8ea851e3 BLF: Add support for ETHERNET_RX_ERROR and ETHERNET_ERROR_EX objects\n5bcff02df9 tshark: Set dumpcap update interval to 0 with -l\n8b393bc304 Add support for MACsec traffic decryption\na2eaaa4e88 E212: update MNC information\nf186f44a71 github/workflow: fix macos\n4205eb2dbd Fix some (trivial) warnings in pidl dissectors\n6966cdb73e SSH: Handle \"curve25519-sha256@libssh.org\" KEX name\n60a6bbd6f3 DCERPC spellings\n289a159042 sharkd: Improve sub-stream support in \"frame\" and \"follow\" methods\n19521b5419 CMake: Find and link with QtDBus on Qt6\n24d02021e8 Qt: Move the I/O Graph tracer to frame selected in main window\n7969fd6bec GitLab CI: Fix a job status check\n9b0150eaba Peekremote V0 enhancements to indicate band\ne03a58958e GitLab CI: after_script updates\ne095dd464a GTPv2: refresh IEs name according to latest release\nbdc5f76203 dcerpc-pn-io(profinet): Fix warning about display filter\n289c6a1257 Falco bridge: Fill in our initial internal events\nbb9e79510c BLF: Fix optional Hardware Channel in ETHERNET_FRAME_EX\na16241b23f TLS: Enable handshake reassembly across connection migration\nae39eeb370 DCERPC dissectors: make some symbols static\na9f783600f EPLv2: modified limitation of valid SDO segment size\n6f8ca8498b fix typo after gcf19f6f27\n591daaf5a3 QUIC: Restore cipher after a key phase change if decryption fails\ne8b256c9a0 fcfzs: fix calculation of the number of fill bytes.\ne267bfdd88 lldpd: move hf_lldp_tlv_enable_system_cap* to capabilities_enabled_tree\n24f5c8d424 zmtp: fix Dead Store found by Clang Analyzer\nad231c7a9c nfapi: fix Dead Store found by Clang Analyzer\ncf19f6f275 dtls: fix Dead Store found by Clang Analyzer\n4107962715 cql: fix Dead Store found by Clang Analyzer\n7db83791a7 tipc: use the message length to compute the filler size.\nd44e951488 tipc: use proto_tree_add_item_ret_length().\n8c06c62a89 Update the Keysight Ixia Netflow fields with new SIP fields\n39cc00a972 tipc: use HTTPS, add a direct URL to the protocol spec.\n1a40e22a00 icmpv6: Do not add time string when lifetime is infinity\nab3511c597 NAS 5GS: fix dissection of NAS message container IE\nc28e620561 LIX2: update Timestamp to show UTC instead of Local\ne40ec77006 NR-RRC: Remove version from SIB dissector table name.\naea66ddc33 tipc: fix byte count.\n161b9809b1 CQL: dissect Prepared response\ncda7c030e1 tipc: fix padding after bearer instance string.\n291822a25c CQL: take into account NULL and unset values\n93a577ca1e CQL: fix two implementation bugs\nf0462182da PER: When showing internal bitfields handle integer values.\ndfec2284f3 NR-RRC: Add callable dissectors for SIB messages\nba75d1bad2 CQL: add parsing for error codes\n196780d4c2 Add Tracing UUID to result dissection\n0d5be00e26 [Automatic update for 2024-04-21]\n32ce95de22 fcfzs: mention the FC specification that describes this.\nd277ecdb3f pcapio: fix a check for idb_filter size.\n9e16b57164 TCP: Fix extra \"TCP port numbers reused\" with missing SYN\n9dffc3834e GSM RP: fix dissection of SMS in 5G Nf interface\nb0aab2f796 MMS: Add more IEC 61850 dissection.\nbe3550b3b1 editcap, libwiretap: Don't use array of initial DSBs after freeing\n0261fd7da6 http: Fix buffer overflow, use after free in HTTP Range\nd7c082bc0d Revert \"Refactor plugin registration and add ABI/license check\"\n80156b405c Revert \"plugins: Fill in short description field\"\n539f85782c Revert \"Update README.plugins and release notes\"\na76fa03e42 Revert \"plugins: Remove unused \"min_api_level\" field\"\n4e12581711 Revert \"Remove plugin license check\"\n7a8e0c6700 Revert \"Qt: Add plugin description/homepage fields to About dialog\"\n1043b044ad Revert \"plugins: Remove unused argument to scan_plugins_dir()\"\n2925a22554 Revert \"Qt: Replace plugin column \"Path\" with \"Scope\" in About dialog\"\n4d93ab1f3f Revert \"Qt: Add Install Plugin to Tools menu\"\na94db07e7b Revert \"plugins: Rename \"dfilter\" to \"dfunction\"\"\na818fd93ce Revert \"Plugins: Fix the issue of duplicate scanning of the same directory\"\n8f3c30d274 Revert \"plugins: Give higher priority to the personal folder\"\n39a2befd09 Revert \"plugins: Remove an assertion\"\n91399562d6 Revert \"plugins: Improve build with !HAVE_PLUGINS\"\n87d06cdb5b Revert \"wslua: Add a scope field to lua plugin description\"\n7f60f901a3 Revert \"wslua: Add support for SPDX/URL/Description info\"\na6fafc9f7d Revert \"Qt: Add back \"Path\" column to Plugins tab\"\nb06c7b8f12 Revert \"Qt: Fix plugins double-click/show in folder\"\n9d70cce3f8 Revert \"Qt: Remove an #ifdef for Windows\"\n1435054a92 Revert \"plugins: Lower a log level\"\n2bc0f26e54 Revert \"Qt: Remove another plugin #ifdef\"\nbf45ef8310 Revert \"epan: Remove HAVE_PLUGINS #ifdef\"\n6a10ec2292 Revert \"Qt: Remove HAVE_PLUGINS #ifdef\"\nbef72fcf5f Revert \"epan: Remove register_all_tap_listeners plugin callback\"\n11fd52fdea Revert \"epan: Add plugin get_descriptions callback\"\n28808100aa Revert \"CMake: Refactor plugin add_library() macros\"\nb64c5077a2 Revert \"Remove version component from plugin path\"\n6d1b32b688 Revert \"plugins: Add a codecs API level\"\n3d42d1dce7 Revert \"Rename some codec plugin folders to lowercase\"\ne6bfc5d34b Revert \"wslua: Add another exception for binary plugin subfolders\"\nfc6871fe55 Revert \"CMake: Fix WiX packaging\"\ne7c8cd4197 Revert \"Try to fix macOS packaging\"\n7a228c11fb Revert \"Try to fix Debian package\"\n94e1851f3e Revert \"Add plugin extension to wireshark.pc\"\ne840517752 Revert \"osx-app.sh: Sign plugins with .so extensions\"\ne4d44aa340 DCERPC-MAPI: call val_to_str_const()\n3964ee302d IP: Fixed clang errors\n1771f09ff8 BER: Only append text to empty/missing strings. Use MISSING as text.\n8920fb270f BER: Add info about empty strings.\n05b26c4c8e nmea0183: Add DPT sentence dissector\n1ffdd2360d ISO15765: Update autosar link\n9d67d6b246 ISO15765: Fix reassembling when different flows overlap\ndd6e07b9b7 Move some WS_LOG_DOMAIN definitions\n0e2d9b7056 Windows: Use the common Qt Export and File dialogs\n9778cc8220 sharkd: Fix SIP follow filter returned in \"frame\" command\n0b094f7df7 ISO15765: Fix out of order reassembly\n74820a1dc6 CIGI: Don't have multiple identical tfs entries\n35bb4273d9 MMS: Make sure we initialize a struct\nb4a3e0d6c5 BLF: Fix random read in the middle of a linear read\n90d7ecf697 Windows: Add include depended upon packets checkbox\n53db86fb6d HTTP: Improved robustness and memory freed\nd4da04f8ee ieee80211: Fix typo in display filters\nb8b73109c4 ieee80211: Add new fields in RSN extension element\ncff321563b pidl: add more issues to the README.\n9f5475293a pidl: add more issues to the README.\n283af80b85 Peekremote Version 3 that encapsulates radiotap\ndb9ed8844c dumpcap: Fix our pcapng block length check\n317177d1d0 Qt: Fix removing ignored packets from selected range\nef65ed493c x11: update with the latest main-branch xcbproto and mesa.\n5617e2d082 gtp: Use slash as protocol separator\n2796b7c479 MMS: Add a NULL check\n1c0f9aeeec rohc: Use slash as protocol separator\n5f3fbb318c Fix some spelling errors\n4362cf100a PDCP-NR: limit security updates to SMC\ne5b34fed00 pfcp: fix code check warnings\n0ea560dacc SIP: Do request/response matching on other transport types\nd9874489f5 debian: Check if dfilter.h is usable, too, in headers-check.c.\n30cd04270c Debian: Build-depend on quilt\n47a208d21e pcapng: option sizers don't calculate padding\n202760f434 Correctly format 'Hash Algorithm:' single vs multiple\nb36749f56a pcapng: fix writing hash options\n4d3c0147f4 PIM: Added support for two new message Types (rfc9465)\n5c5b18de0e MMS: Fix #19767 + more enhancements\n5e60fc7964 NR RRC: fix SRB4 configuration in MAC NR\nb7598b2010 pfcp: Update to 3GPP TS 29.244 V18.5.0\n09b83c0ece pcapng: Fix logging\ncbae3bfc66 VXLAN: add Linux default port\ne1a6557d34 c-ares: Suppress deprecation warnings\na2c5e159fd HTTP2: Override existing header with fake header\nf14d5538b8 addr_resolv: Use ares_init_options\n9d2ecd0c07 PFCP: Add request/reply matching max time preference\n3d33427dd9 MMS: Fix fuss test #19756 and add itemid str.\nd71e8f0291 GTP: add more context fields for PDCP-LTE frames\n4b4e6a39bd MAC-NR: LCIDs 3+4 may be SRB or DRB\nd6ecaf1d1d PDCP-NR: be more careful about length of IP payload\n6dc78e62fd gtpv2: Dissect PSCell ID IE\n97b871fe02 Switch some GLib-isms in asn2wrs.py to their C99 equivalents\n03e0762a4f tools: Miscellaneous C99 updates\nf4a192a2af epan: Switch proto_tree_add_item_ret_boolean to bools\n52573ed9af [Automatic update for 2024-04-14]\n50d0cbc1c5 epan: Switch more gboolean *s to bool *s\n14e24bec38 PFCP, GTP: Remove unused structures\n3fdd76f9c4 Qt: Fix overflow-before-widen\n60a2f917ee TCP: Replace hard-coded number by appropriate constant\n2aca89319d PDCP-NR: don't link back to (not set) security frame 0\nd14f36e90a nmea0183: Add GGA sentence dissector\nfee2eef9c7 ieee80211: Mark TPC Report link margin as reserved in certain frames\n8c473a4970 MMS: Add IEC-61850 PDU names\nc5a8168f8a epan: Switch ptvcursor_add_ret_boolean to bool\n61cdb88799 epan: Switch process_reassembled_data to bools\n986bd67a0a GNSS: add dissector for Galileo E1-B I/NAV navigation messages\nb46c1e9fc7 IO Graph: Add intervals down to 1 microsecond\n0bf8a291ed Resources: Add column preferences to the CloudTrail profile\n6126f56551 ieee1905: Add dissection of supported VHT MCS sets\n179bf05a4d ieee1905: Fix bit ordering of HE-MCS set\ned7f4df031 Dissectors: 'return(x)' -> 'return x;'\n06a9f5feab Qt: Remove unused include from IO Graph\ncc25d57bc4 Qt: Use nstime_t in the rest of IO Graph\nbfcc3d7a35 Qt: Start to use nstime_t in IO Graph\n2aed3428ec Falco bridge: Add error message for missing display attribute\n2224b243c2 Qt: Recalculate I/O Graph if zero plotting changed\na0f675728b Update Ixia/Keysight netflow fields. new fields for https headers, for Appstack v4.12\n2ef222903e Kafka: Update messages to their latest versions\ne84adf41da Qt: Hide export dissections dialog when accepting\nea70c16e05 Qt: Fix crash when closing TimeShiftDialog before redissection done\na2a911ea1a fix: Hmac Missing\n9c352cf9ab BLF: Properly skip 0-length containers\n14902cfe82 BLF: Fix debug message\n50018d8994 GTPv2: fix bearer_qos_oct1_flags and tra_info_pgw_flags\n90c1736b10 Kafka: Fix the snappy decompression (again).\n1924285965 Kafka: Fix two mis-dissections in old message format.\n0ef10e400c tcp: Send the header to the tap even with exceptions in options\n2ab349d0f6 Snappy: Use the tvbuff_snappy routines in Couchbase and Kafka.\n9363a27350 Snappy: Minor cleanups.\n9df309fce8 bacapp: fix typo\ndf4023b5ed epan: Switch our column format match list from gboolean to bool\n9448de75ad Docs: Add a note about recursion to README.developer\n1cc371fa57 Clear queued rescans when opening a file\nae1d09e9fa PDCP-NR: fix issues around userplane ciphering and integrity\n15c086c5e8 RTCP: suppress or fix some spellings\ne556035728 RTCP: Use dissector table for RTCP-RTPFB payload types\n21d170a957 \"const\"-ify extcap/* and wsutil/*.\n6b95c52a49 Conversations: Introduce a deinterlacing method\n107666afa1 Fix type of queued_rescan_type\n304cb10701 file: Don't tap the same frames twice in a live capture\n8ca35924ed Add support for snappy content encoding to http packet dissector\n4637eeea9c tap: Remove redundant console warning text\n365b4dbec8 Qt: Don't try to remove an already removed IO Graph tap\nfe2b3001b1 LUA: Update documentation to the fact we now support LUA 5.3 and newer.\n5abfe91cc1 Qt: Work around Qt6 dataChanged pessimization\n4f2abc9b46 [Automatic update for 2024-04-07]\nd54cd5e0ba HTTP: Fix null pointer deferences\ndbc22579cb Updates to NTP reference identifier codes.\n76f52fc911 wslua: Remove obsoleted @since tags\n63087ee7b2 http: Test strstr result against NULL before adding\n3852a0b5b0 LUA: Requre version 5.3 or greater\n40c420ab9b  MMAS: Add a preference to dissect as iec61850\nc56a81d41c TCP: Add a flow counter to the statistics\n3b034815a2 Asterix: \"const\"-ify all the data structures.\n4606845990 Qt: Rescale IO Graph axes before getting the x axis range\n8f889b5833 Qt: Remove the URL code from the profile model & view\n748e482dc7 Qt: Add Apply to Preferences Dialog\nb63d6d3bb0 Qt: Fix IO Graph startOffset when packets aren't added\n2ae6c42ce2 Qt: Fix IO Graph currentActiveGraph\n5d8fcce4d6 Qt: Enable IO Graph Crosshairs context menu action\na3e7a7fb29 fix: \"const\"-ify most of fix_fields.\nd0b143bbec Remove init to zero for static variables\nc47011890a HTTP: Incorrect request/response matching\nf291ea8f30 HTTP: corrected request/response matching\n1e591a35db # This is a combination of 3 commits. # This is the 1st commit message:\n4e4897423b HTTP: Incorrect request/response matching\n4f8343feb7 HTTP: Change to TestDecryptTLS.test_tls13_rfc8446\n447023d544 HTTP: Fixed indentaion error\n18a1e3294f HTTP: Change to Ubuntu pipeline test\n49b3fb60b2 HTTP: Incorrect request/response matching\n84c0e00130 HTTP: Fix request/reply matching\n4751c4a9da HTTP: Fix request/reply matching\n40f57684d9 HTTP: correct req/resp matching without comments\nf97a8a5b58 HTTP: corrected request/response\n437fd1dacd HTTP: Fixed error in last commit\n2670533eb5 HTTP: Fixed incorrect request/response matching\n211c3034e7 HTTP: Request-response matching corrected\nbf57ada43f HTTP: Ranges are used to match reqs/resps\n6649fa88c1 HTTP: removed unused function declaration\n33ab83081d HTTP: Incorrect request/response matching\n24307ccdbe wslua: Add missing @since tag\nf650b22bb4 busmaster: update a URL to HTTPS.\nd17e3a2842 wslua: Improve documentation\nf3e4237af7 Qt: Expand on a comment\nd6d6053716 LTE RRC: upgrade dissector to v17.8.0\n475661b597 F1AP: upgrade dissector to v17.8.0\n07f68d0d15 http: Initialize a variable\ncc4f989805 Telnet: vSPC: Track the \"vMotion conversation\".\nca4f217083 conversation: Add support for a \"blob\" conversation-element type.\nd63bac4d77 Telnet: vSPC: Dissect \"sequence\" and \"secret\" in easy cases.\nd6bc7d969d wslua: Add integer atttribute setter/getter macros\n0cbdec7f71 fix: Migrate packet-fix.h changes back to source files.\n410b435fd7 E1AP: upgrade dissector to v17.8.0\n4fd6630d9b XnAP: upgrade dissector to v17.8.0\nc84115f881 wslua: Add ProtoField attributes\nc48b750be9 wslua: Fix type conversion macro names\n600d66f1ac MSWSP: const-ify \"GuidPropertySet\".\ndc03f8790c IO Graph: Use a larger maximum index size\nfc77bd3ee9 Qt: Enable min/max button on GeometryStateDialogs by default\n0a636a636c QUIC: Remove support of old draft-deconnick-quic-multipath\n9de88ef317 fix: Use bsearch for tag lookup.\n0c637a2b5e reordercap: Handle IDBs in the middle of the file\n8b802bffd1 Zigbee Direct: Fixed UUID mismatch with join, pjoin & leave characteristics\n64158f3e3a Switch away from gshort and glong\n393d3e059d RakNet: Update encryption state on open_connection_reply_2\n9268a4838a ceph: give c_warn_ver() a more sensible data type.\n93ff0a109a NGAP: upgrade dissector to v17.8.0\nd54b84d0ac Protobuf: when matching against URIs, allow '*' wildcards\n81f925907a Qt: Add automatic profile switching\n7130e33d30 Qt: Ensure Copy Bytes as C String is a valid C string\n7d5172dec1 NR RRC: upgrade dissector to v17.8.0\nb456632e40 X2AP: upgrade dissector to v17.7.0\n5e290a99ab NMEA0183: make a function static\n8b2d15115b S1AP: upgrade dissector to v17.6.0\n668e6c6f79 packet-vnc.c: desegment multiple TCP packets when not enough data is received\n7f2043c720 Qt: IO Graph human readable axis ticker with SI prefixes\n5b637bd968 wsutil: format units with floating point\n76879a480a http: optional check for ASCII headers\n9710a98b67 Initial work on supporting DTLS 1.3\nacaf5ad7f9 Qt: Only retap when making an IO Graph visible if necessary\n85e93bb30b Use bsearch for lookups in sorted extended value strings.\n82bc36ba53 CLNP: use a dissect-as dissector table for the OSI security option.\na85952e2ce GTPv2: Dissect UP Security Policy\n5db5366f9b Dissectors: don't do e.g. return (0)\n8f6a4d3b3b text2pcap: Fix a printf format\n7a3a258118 Qt: Retap when changing to or from a IO Graph LOAD graph\n67d7b1e58c extcap: Fix a strlen check\n83f46b61ef Fix some spelling errors\ncd5630e375 MMS: Add IEC 61850 decoding to some fields\nf98f501b61 fileset: Check for g_regex_new error\n74827d33dd EHT PhyType support for wlan_radio dissector\n755fc1dbd3 ui: Convert our remaining UI code to C99 types\n124d73b6e9 RADIUS: Updates to dictionary.huawei\n932ec25362 Qt: Fix a preferences dialog data type\nd5b092268f Convert extcap_parser to C99 types\n4dda75fb0d Add a built-in dissector for ZMTP\n0949fd3498 doc: Mention updated Lua 5.3/5.4 support\nefdeaac67d Qt: Change IO Graph tracer when current UAT row changes\nd7926e3290 epan: Switch proto_get_frame_protocols to bools\nf0f8cdce36 Qt: Add some comments and links to IO Graph TODO\n76255f37fd Mitel DECT: Change a gboolean to bool\n4cf64a4ace ATN: update some comments.\nb5970abe2d UAT: Handle TRUE and FALSE regardless of case\n0b93055203 prefs: Don't cast a bool pointer to a gboolean pointer\n6afe57a1b8 Remove parentheses from return bool\n5a91ac3af9 Doc: tweak some of the Lua API documentation\n5919c84347 Move libm linkage to libraries\n773bcf6cb9 tcap: make a variable not used outside the dissector static.\n7084b6e4db Change some extern references to boolean preferences\nfb70e77fd1 Qt: Convert our utilities to C99 types\nb00b162a87 Qt: Convert our widgets to C99 types\nf3311c1840 Qt: Convert our models to C99 types\n2ec0c3ff90 epan: Convert the color filters code to C99 types\ncd3588d52f ui: Convert the CLI code to C99 types\nd81488c167 Lua: Convert to C99 types\n45e75413a8 wslua: make the heading for the example a discrete heading.\na8c5341dcc Qt: IO Graph Y Axis factor needs to trigger a recalc\n7b6e196c41 wslua: put the example of use for treeitem:add at the right level.\n949191823f epan: Use bools in our pref_set_pair_cb callbacks\n62bc594401 wslua: fix the documentation for Tvb:reported_length_remaining.\n5a9393c646 Switch our boolean preferences to bool\n20046e4a0d NTLMSSP: Initialize encrypted session key\n7c744e7933 editcap: Don't memmove more than allocated in the buffer\n6aed3e5232 Qt: IO Graph bar border color\n9aa9a6b048 nmea0183: Add ZDA sentence dissector\n0fae2569bf [Automatic update for 2024-03-31]\nbe55ec3c0c Mongo: Strengthen heuristic a bit\n90654d3f76 Fix some IP lengths\n2862ae66f5 Qt: Update ProgressFrame to use a bool\n57d98f1362 Qt: Recalculate IO Graph when switching plottable\n2562674df0 epan: Convert the secrets code to C99 types\n4bc1dcaa83 Protobuf: don't warn about re-including base types\ne85196966d epan: Convert a couple of proto tree callbacks to C99 types\ne10839dd5d epan: Convert our stream printing code to C99 types\n1816bd1a11 Lua+ui: Convert the funnel code to C99 types\n444cb3cea1 ui: Convert the top-level ui files to C99 types\n574ed488d1 Qt: Only rescale the one visible IO Graph\n81c7238776 Qt: Recalculate IO Graph at more appropriate times\n59fbdef13e Check number of selected bytes for FT_IPv4/FT_IPv6 fields\n38c0efcee8 Mongo: Ensure the offset advances\n75b1ffe119 macos-setup: Add a warning about a comparomised version of XZ.\nee4891977b Qt: constify some IO Graph getters\n75aa5599b4 ui: Convert capture_ui_utils to C99 types\nb2f1dbff0e ui: Convert dissect_opts to C99 types\n2b4117c5bb ui: Convert the failure_message routines to C99 types\n7686e79601 Qt: Constify PacketListModel::getRowFdata\n2d3c6050ba Qt: Retap IO Graph if the Y field changes\n119a385ba2 GQUIC+DOCSIS MAC MGMT: Recursion updates\nf8760b70ba wow: Fix identical branches for some messages\n98b08894c7 check_typed_item_calls: don't warn about width of field for add_uint()\n8285e80224 JSON-3GPP: Handle 5GC over HTTP/1.1 (OAI), don't create HTTP/2 sessions\n1c90d8197f ltp: Add correlation of cancel and cancel-ack segments and heuristic dissector\n16186deb94 epan: Add some Clang-tidy suppressions\n318e8d3161 cpu_info: fix missing decl in else macro block\n1a4abf8e6a Qt: Modernize some of our main window signal+slot connections\n0bb3161d7f ws-function-blocks.dia: Update some outdated information\n5824e57120 docs: The 'manarg' macro splits by line\n9e388820d0 tcpcl: fix Dead Store found by Clang Analyzer\nb261d1cdd8 dns: fix Dead Store found by Clang Analyzer\n63bb4b023a pldm: fix Dead Store found by Clang Analyzer\n83687ce837 ipv6: fix Dead Store found by Clang Analyzer\nb18a2989ee tcp: fix Dead Store found by Clang Analyzer\n2e33fcf230 bssgp: use the right table for Attach Indicator string lookup\n3a7b618897 IPPUSB: Avoid (mostly harmless) string overread\n6f688e19d2 Qt: IO Graph: Use logarithmic ticks for log scaled Y axis\nc5510d931e packet-lldp.c: ttl == 0 means Shutdown PDU, decode accordingly\n6c0d76206b Qt: Treat IO Graphs with lines and data points as line graphs\n1205a5a38d socketcan: fix CAN packet type detection\na91509ea7c Change some `wmem_packet_scope()` to `pinfo->pool`\nb43ae13285 Assert on heur dissector list not found\necea70dbd3 Qt: Actually display the intended IO Graph Legend Title\nbddf6b7fbd IO Graph: Make LOAD graphs displayed\nab26d00454 PROFINET plugin: init PE service_modifier always\n24b27a78e2 Qt: Apply the fix for SyntaxComboBoxes to Qt 5.15.3\n484de637d5 Fix syntax in tshark man page examples\n66a6c53914 Qt: Ensure IO Graph Legend appears if box checked\na780f96f1b Qt: Actually swap the plottables when rearranging IO Graphs\n393197fdee PROFINET plugin: decode PEservice responses\nd10e9883bf ui: Switch the recent and simple dialog files to C99 types\na7236f6a57 sharkd: Add \"column_info\" field to \"status\" method\n18625d706b Dissector for RTCP Congestion Control Feedback payload type\n1f63e02a9e tools: Add gdb to the debian-setup.sh test dependencies\n350917786d I/O Graphs: Squeeze some bytes out of io_graph_item_t\n070a974b48 wlan-radio: Fix access of unitialized bool\n3b61f4fd74 IO Graph: eliminate possible overflow in LOAD graphs\n10f41cb995 macos-setup.sh: Various changes to build on a newly setup up M2-mbp\nb9b19599f7 packet-dhcp.c: Fix a typo in aerohive suboption\n39bc393c86 Qt: Copy IO Graph absolute time to CSV when time of day is selected\nd8b291c566 ASN.1: Regenerate dissectors\n7a34922f05 GTPv2: Dissect Alternative IMSI IE\n5887358afc asn2wrs: Remove unicode char '->', it fails on windows\ndc5b8b9c60 wow: Remove extra newline at file end\nce8bfd9975 wow: Autogenerate all messages for all protocol versions\nbcc7145d75 wow: Add add_string function\n1cda9725d4 wow: Rename ett_wow_realms to ett_message\ne658085377 wow: Refactor dissect_wow_pdu function to improve locality\n94505a4a23 wow: Move main parsing into own function\n0dcbd4cf90 wow: Convert to use ptvcursor\n981f7f2709 wow: Completely rename variables in preparation for autogenerated\nc746778018 wow: Change opcode names to match actual names\nc92d04accb wow: Make protocol_version localized to conversation\n8d5f016225 wow: Make message layout be dependent on protocol version\n407da2a8c1 wow: Pass game_version directly through parameters\n436eb02100 Update Ixia/Keysight netflow fields.\nf6454f6dd3 follow: Get rid of frs_return_t\n0e28b66dd8 Qt: I/O Graph fix highlight and click on last interval\n2438e82c40 Clang-tidy: Enable recursion errors for dissectors and wiretap\n105da2927f DVB-S2: Add a null check\n4534258885 ISO 7816: Add a null check\n0cc1a5f110 H.264+H.265: Add null checks\naf3ded6742 [Automatic update for 2024-03-24]\nb48ff4df36 wiretap: Recursion updates\nb39cd257db Fix some spelling errors\ncd564f93e5 PNIO: Add a missing Clang-tidy suppression\n6d4375846b Recursion updates for Gryphon, MATE, OpcUa, PNIO, and WiMAX ASN CP\n5366c18d28 Add recursion checks to SoulSeek, SML, and Socks\nf9e954497f Add recursion checks to LLRP, MQ PCF, OPSI, and OSC\n823b49f6c3 BLF: Fixing Flags Decoding in FlexRayRcvMessage(Ex) (BUGFIX)\neb5a4b149a GTPv2: Add NF Instance ID and Timer in Seconds IEs\n7e49e3155d expert: add a new expert group for dissector bugs.\ne4a3342068 expert: register ei_unreassembled with proto_unreassembled.\n7c7ae3c72c Fix some Perl scripts.\n0e551efb92 nmea0183: Fix end of line warning\n0e1bad2875 USBVIDEO: Add a class data type check\nc733727c76 Windows: Upgrade c-ares to 1.27.0\n668c6e1eeb woww: Update from autogenerated message information\ne6ad1f677e Amend whitespace in reordercap.c\nef64dcf328 Fix reordercap -n flag generating empty output file\n534f7c32cd socketcan: update CAN CiA 611-1 definitions\na98b35d988 socketcan: display len8dlc content for Classical CAN\n3456a9809e socketcan: display CANFD_FDF and CANXL_XLF flag content\nd3dd050c6a socketcan: simplify CAN packet type detection\nc414c067d6 CIP: Fix Forward Open Response Parsing\n13c8a2f887 Convert Wiretap to C99\n5738b5ca2c epan: BCD strings with multiple filler nibbles at the end\ne640ecd591 TFTP: Fix export objects in single pass tshark\n2b7fc4b8d2 wiretap: Add a Clang-tidy suppression for BLF\n0302978a2b LISP: Add missing Clang-tidy suppressions\n1ed5bd8dd2 Add recursion checks to EXTREME MESH, LwM2M-TLV, MPLS ECHO, SNA, and TCAP\n30f77b439b nmea0183: Add generic NMEA0183 dissector\n6adb987104 Qt: Dynamically allocate IO Graph items with a higher limit\n28be55d9ef hci_mon: Support decoding ISO data\na9bf01aad1 ICMP: fix minimum original datagram length\n15660308cf epan: Don't change ports in error packets, similar to addresses\nf940d12361 GNSS: add EMS meta data synthesis to EMS text node\nf410c309be Debian: Add a Logray package\n3ea56842a3 mac-lte: fix more bogus casts.\n5de524bc20 mac-lte: Fix memory access in LONG_BSR_LCID\n02bf9e15d8 Qt: Fix some leaks in IO Graph\n696baec976 Falcodump: Fix a couple of option names\n6afdbf2de0 Falcodump: Add options to exclude syscalls\nb41e5eaed1 Qt: IO Graph label precision, make scale factor a constant\n4c5f838c58 MinGW+NSIS: Install NSIS package in setup script\n3cff44e4a0 MinGW+NSIS: Work around QTBug-122257 when building\n3757f42e5f DOF+Etch+SIMULCRYPT: Add missing Clang-tidy suppressions\n6653bfd82e Add recursion checks to DCOM, MPEG PES, PROXY, Snort config, and Thread\ne9f0d2c22a Add recursion checks to DICOM, FC-SWILS, PIM, RSL, and WASSP\ndb886b4acb Add recursion checks to DCCP, KNX/IP, PANA, SOME/IP, and WLCCP\nbfa4ad9041 GitLab CI: Re-disable Homebrew updates\n73b6bf25e2 Add recursion checks to CSN.1, GSM A-bis OML, NAS-5GS, SolarEdge, and WMIO\n68f427822a Qt: Scale IO Graph bar widths to the interval\n96281f0369 [Automatic update for 2024-03-17]\n53d9f11e01 Qt: Queue IO Graph reports during mouse moves\nf90b2df701 packaging: Quiet a Python SyntaxWarning\n088bcd5682 packet: Add missing param documentation\nab5c10662a test: INVALID_INTERFACE is a possible exitcode for tshark interface test\ndf78e393c8 CQL: Fix a recursion check\n277d965657 Add recursion checks to CQL, GSM GSUP, MSWSP, RSVP, and WTP\n624822b073 QUIC: Handle older MP draft as well\ned83f9b2ee QUIC: Support decrypting Multipath draft-07 with Path ID\n33125aadcb TCP, UDP: Add fields for relative packet numbers within stream\nd25124910f Goto the nearest undisplayed frame\nf5024976f7 epan: Remove subnum from frame_data\n1a417f5840 Convert fuzz to C99 types\n93e6399046 tools: Install Lua 5.4.6 on macOS\n7122291d5d Add recursion checks to COSE, GQUIC, SUA, and XML\n5b29346f9b Add recursion checks to COROSYNC/TOTEMSRP, HSMS, ProtoBuf, RTLS, and YAMI\n0ff53d7a49 Falcodump: Add capture filters\n6d10f6144e Falco Bridge: Dissect JSON objects for cloudtrail fields\n1923c6cab0 Qt: Limit on how often mouse moves update the RTP Player graph\n50c8bc46f4 Windows: Upgrade Lua on Arm64 to 5.4.6\n55c9a08651 Qt: Add Clang-tidy suppressions for ProtoNode\n87a9a18726 Convert extcap to C99 types\n69797c06a9 androiddump: Unused variable on WIN32\nfa1a1b82e0 Lua: Switch the downloaded Lua to 5.3\n3621124cd8 packaging: Have Debian Build-Depend on lua 5.3\nc77748ae86 release-notes: Add Lua\n50af5f1dee tools: Install Lua 5.4 with MacOS brew\n533c186bc8 Sysdig Event: Update our events\nc810864876 NSIS: Fix some paths\n89cbc5baa2 SOME/IP: Improved robustness of UAT-based HFs (part 2)\n371f9e1418 Convert randpkt_core to C99 types\nf8b4e9d974 Tools: Add a quiet option to asn2wrs\n497b90a4a1 Qt: Make visibleIndexOf O(1), not O(N)\n42a13925a0 Fix potential integer overflow in getnum\n7cfffcfef3 DNS: Added limit check to TTL indices used in new statistics\nfcc5709ce8 Qt: Don't select and scroll to packets twice\n75c54c2a8b Fix common spelling mistakes\n72bdaefacb CI: Update location of extcap plugins for signing\n14c0f79ec4 text2pcap: Make sure our plugin directory is initialized\n8d5036b994 diameter: support Diameter Address type in vendor dictionaries.\n654fbcb5ec Fix our WiX package\n73f516a3c4 tools: Add opencore-amr to additional list for macOS homebrew\n25f6f3ba0e tools: Optionally install Qt5 DBus on SUSE\n91ea231d5e packaging: BuildRequire a Lua version, not just 5.1 or 5.2\neb58552384 wsutil: Allow converting zero length bytestrings again\n0baad53fba falcodump doc: update to libcloudtrail 0.12\n32689c250f wsutil: Fix init_plugin_dir\n8e703dfb9a tools: Install lua 5.3 on Alpine and Arch Linux\ne3a77df837 QUIC: rename DCID by Path Identifier (multipath draft-07)\ne4cf02711c QUIC: a new MP_[NEW|_RETIRE]_CONNECTION_ID from multipath draft-07\n2b09b0c66b QUIC: MP_[NEW|RETIRE]_CONNECTION use old draft value\n3b4b9c8dde QUIC: Add MAX PATHS from pre-draft07 multipath\n3e03082288 tls-utils: add Initial MAX Paths TP (multipath)\n1ea44a05e9 Qt: queue TCP stream graph replots during mouse moves\ncc694b7f2f Resources: Update the default Logray profile\n08ddd7e863 wsutl: filesystem updates\n2155ef34b0 Qt: About dialog \"Folders\" updates\n8512d130f6 UBDP: Reformat code\n4929ecb906 UBDP: Decode hostname as UTF-8 instead of ASCII.\n6420dcff7f UBDP: Add new fields\n302af75963 dfilter: Don't crash on arithmetic between string literals\n97bef124ae SNMP set correct req/resp relation when req's are repeated.\n8026883af8 SOME/IP: Improved robustness of UAT-based HFs\n1f3933913a dfilter: FT_PROTOCOL does not have a value string\n6afb4f52d4 check_typed_item_calls.py: Look for fields that could be FT_FRAMENUM\n8541041922 CMake+wsutil: Split our Wireshark and Logray extcaps\n1b8aa82a23 Let `check_dissector.py` work on plugin dissectors\n8c371a912e dfilter: Allow character constants in arithmetic\n0969baf2c7 Fix some spelling errors\ne05dfae553 dfilter: Fix parsing of single character hex character escapes\n7134a293fa dfilter: Allow calling upper and lower on function results, literals\nadbba6df7b Qt: Sort SCTP All Associations items numerically\n0c58df3d1d TLS: Set unused debug file pref to the empty string, not NULL\nf3bf4969e5 Zigbee NWK GP dissector - APP ID 0b0010 decryption\n26c42f4535 NAS 5GS: remove an unused dissector handle\na72bd62458 PEEKREMOTE: Add 11be support in the dissector.\n6e525aa148 TLS: Don't let the debug file and key log file point to the same file\nc778292a10 GNSS: add dissector for SBAS L1 MT63\nd29e7b6599 GNSS: add dissector for SBAS L1 MT0\n3ffddc19a4 NAS 5GS: add dissection of Tests Procedures messages\n826bafe869 SMB2: Change frame fields to use FT_FRAMENUM\nebb5ef3bbb CIGI: Don't throw exceptions in heuristics\ne89dc8e2ab NFS: Add a NFSv4 SRT table for operations\ne7d47c929d Fixed Zigbee NWK GP dissector - scenes command\n47538631d4 SANE: prefer to give uint to WORD_OR_RETURN()\nc084f120a2 wiretap: Add a Clang-tidy suppression to the Ascend file scanner\na2d40c7cde Falcodump: Fix compilation\n9bfa8d9142 Add recursion checks to BVLC, DOCSIS MAC MGMT, MsgPack, RTMPT, and ZigBee ZCL\nf5b887fa38 Fix some spelling errors\n6307233ec9 Fix some cppcheck warnings\n128c298122 Add recursion checks to BT SDP, GTPv2, NHRP, SCTP, and Windows common\ne50ef0effb Add recursion checks to BT BNEP, DOF, ICQ, Q.2931, and S7COMM\n75fdad769f [Automatic update for 2024-03-10]\nd98913aa82 Qt: Don't call begin/endRetapPackets() twice\n77ec5a5068 GitLab CI+tools: Homebrew recently adopted PEP 668\n6f2514fba5 Add recursion checks to BGP, Etch, LI5G, RPL, and SIMULCRYPT\n018fecc284 ASTERIX: Add Clang-tidy suppressions\n709404e401 Add recursion checks to BFCP, EDONKEY, QNET, RTPS, and XMPP\n7013af8367 wsutil: On Windows handle hard links in files identical\nb8f2baa8ba wslua: Update comment to mention FT_NONE DissectorTable\nc2e95293d2 dfilter: Add vals (value string) function\n4d57ab3498 opus: Use BASE_ALLOW_ZERO for frame data\nba362cbf35 USBLL: Show data field for Zero Length Packets\nec6b75ec46 Qt: Add lint recursion suppression to findText\n5a4e2bce58 wslua_dissector: Support 'decode_as' from DissectorTable:try()\nbaa7944443 Qt: Honor pref for hiding interfaces in interface list.\n34be81a6e9 opus: Fix dissection of payloads with multiple Opus frames\n9bb019d3bc packet-x75: Add sub-dissector table for \"Decode as...\"\n221220f2b4 release-notes: Mention Find Packet improvements\n0228fefb10 falcodump: Add builtin (syscall) capture support\n2992aa2e24 Logray profile: Add dfilter_buttons\nc3c06e7c5f cllog: do more correctness checks on the file contents.\neaf07372e1 tshark: Custom fields for -e based on field expressions\neb9a4ae8ef cllog: do some additional checks for valid values.\n9476748548 cllog: add support for log files from CLX000 CAN loggers from CSS Electronics.\n6fd3af5e99 t38: Allocate forced defragmented memory in correct scope\n6e11f84301 RTPS: Return end offset on failure\n7fbd190c84 Qt: Don't allow tap dialogs to apply with no capture file\nc2bb7e3e6e Spelling: highlight found Wikipedia words\n2b390596c0 prefs: Don't remove initial handles from auto port prefs\nbeced82218 Make a couple of variables from ASN dissectors static\n99a887066d DNS: Added new statistics called Query-Response.\na2a9382629 oids: Read SMI library configuration files\n03df722198 ieee80211: Fix sizeof AID column\n4eb2924388 smtp: Fix password decryption\nc85a0a11f2 Tools: Install libopencore-amrnb-dev in debian-setup.sh\nba82fcdef6 ICMPv6: Remove recursion check from 0 length option path\n54717a81d1 GSMTAP: check version field\n674e35bd62 http2: Return header value decoded from US-ASCII\nc03998f6d2 LUA: Use LUIA 5.4.6 for Windows\nc831e05400 CMake: Allow overriding rpath on macOS\n8103dd92fc ieee80211: Add address type for RA and TA\n2188257743 Lua: Make tests work on Lua 5.4\nd46e93b274 ASAP: More recursion updates\nf38f79d6e1 Add recursion checks to Bencode, BT-DHT, ErlDP, H.233, and H.264\nfcde25cfb8 Add recursion checks and suppressions to BEEP, Kafka, and OpenFlow\n48e65f0c54 Add recursion checks to Banana, ISAKMP, KINK, M2UA, and M3UA\ncc69ce9399 GNSS: add dissector for UBX-RXM-MEASX\ne1c8fb7681 TCP: RTT value is missing for GSO/GRO or repackaged segments\ncde165b480 TCP: Regression on ACKed unseen segments\nb67073e19d fgcp: Add Session Protocol (0x8893)\n4e997a93ea Lua: Replace lua_pushnumber with lua_pushinteger where apropriate.\n972bb56d0a Remove our recursion checks in ICMPv6 and NETLINK\ne5f006fab3 vmware-hb: Handle zero length address\n897dc0bd37 LUA: Ue LUA 5.3 in our setup scripts\n1cb540d1f7 PROFINET plugin: add dissector for PROFIenergy service request/response\n7a190ad5d4 LUA: Use LUA 5.3 for windows builds\nbe3b5d04f0 ieee80211: Add fixed dialog token to some WNM Actions\n61e8d3392a Lua: Convert the time to an integer in tests\n52d7053944 ipv6: dissector: ioam: fix nodelen=0 with OSS\nad69c29f8e Lua: Don't test for removed functions\n5e4d7dd565 Lua: In tests, use load instead of loadstring on Lua > 5.1\n4e9c97d2a0 ORAN FH CUS: Update some comments, long string texts, etc\n97a6ea116e [Automatic update for 2024-03-03]\ndc84bddc1f ASAP: Make sure pinfo is set\nc4d62f9761 Add recursion checks to BACnet, CIP, IPP, LISP, and NETLINK\n556ffd3c03 Fix some spelling mistakes\nc49e1f2cea Add recursion checks to ASAP, iSCSI, JXTA, MBIM, and MQTT-SN\na59656a1a4 iee80211: Fix SID endianness when adding to the tree\n3948fe5132 Add recursion checks to AMQP, GNW, LDP, CFLOW, and RDP\n65fe09f74b MEGACO: Display descriptors inside audit descriptors\n7e2e622231 z21: Add some heuristics\nd0c09f4859 Add recursion checks to various protocols\n91b7ef3930 ieee80211: Fix typos\n177dfab770 Rebuild our ASN.1 dissectors\n4f35c3a34a epan: Add simple recursion checks\n2bb39e1386 TWAMP: Fix Sender Timestamp format\nfebcf46bbc gRPC: Add separate dissector handles for gRPC Web and Web Text\n6c23554f68 doc: Update falcodump manpage\n95f6f94f8b tools: Parse ranges in make-services.py\n73b0f9e5d3 JSON: Make it possible to disable JSON_3GPP handling\n6dabac0cfe CMake+wsutil: Switch back to the default INSTALL_DATADIR\nac97a42bcc Check that string_string arrays are terminated\ncc2c5dad77 MEGACO: Find the token when the auditItem is a descriptor\n3d1cb2cb19 MEGACO: Fix streamid item length\nfcb734e17d HTTP2: Add heuristic dissector for on TCP directly\n0300fec1bc TCPCL: Add preference to allow missing Contact Header\nbb37fcb026 docs: Explicitly set wildcard when including dissection-options tags\n0ce98d0fd3 Tools: Install Qt6 on Debian bookworm or later\nd5d22dad96 Debian: Switch to Qt6\n02942d9aae Tools: Another debian-setup.sh fix\n566927e653 Tools: Fix our Debian Qt6 package installation\necc1f6d9b4 Tools: Update our Debian Qt6 packages\naa812f47cc check_typed_item_calls.py: check string_string entries for duplicated keys\nade326dbf5 JSON-3GPP: Don't crash on empty suppFeat JSON value\n7dc0f853c6 prefs: Fix null defererences, remove obsolete function\n7583014fb0 MEGACO: Remove some long obsolete code\nd62cc2b175 MEGACO: Dissect statisticsDescriptor inside mediaDescriptor\n3d8e72fdf9 macos-setup-brew: Use LUA 5.4\nfdcc57302f gsup: Add PCO IE\n46123c430a gsup: Add ePDG Tunnel Request/Error/Result messages\n611ed98634 Diameter: add 3GPP Third-Context-Identifier AVP definition\n84ffa648ea ENRP: Check for invalid parameter & error cause lengths\n49d15ea4e8 Wifi(NAN): Minor fix for NAN dissector\n96ab1b9571 ptp: Improve display of rateRatio allowing more decimals.\n2b9dcdc346 Protobuf: Add a UAT table to map URI -> message_type\nbce195d8e0 Update existing NAN attributes to NAN R4\nb517471bc4 Qt: Show tooltip in sequence diagram for elided comments\n4fcb4b5364 Remove PREF_DECODE_AS_UINT\n9840e6247f Thrift: Align the endianness for double\n4eaf10bc4e Thrift: Fix recursion check\n8989c732fc sharkd: Increase JSON buffer size from 2048 to 8192 bytes\nd22842f662 Qt: Add case sensitive find to Follow Stream and Show Packet Bytes\n3540bbc969 GSSAPI: Avoid dissecting checksum in signed-only KRB_TOKEN_CFX_WRAP\n09f6a3aaa6 Qt: copy correct hidden state to device\n4d6941caa6 hipercontracer: don't consume LDAP/SASL/KRB_TOKEN_CFX_WRAP messages\n33c9657365 asterix: adjust to upstream change\ne0300eaed8 Fix lots of spellings\neb706e9b84 [Automatic update for 2024-02-25]\n2744c7e7d0 doc: remove redundant section\n30c0ab964f CSV Export: Last column no longer exported when hidden.\nc0288ca829 Qt: Only set Packet List style sheet when relevant prefs change\nea38f142e8 Qt: Work around QTBUG-122109 when applying packet list style sheet\ne5e0797bd5 Qt: If no preferences have changed, don't signal\n63d6edbd3e thrift: make some functions static\n92573aad71 RNSAP: Dissect IMSI\n62e8882701 SCCP: Use register_dissector_preference\ne5168435b5 dfilter: Add functions to override field base\nac90d8c834 Inject TLS Secrets: Check for NULL used secrets map\n5239b6bc8d Look into some items where VALS doesn't fit in mask\n54b52063c5 falcodump: add missing AWS regions\na5dee645cf DNSCrypt: Add support to parse DNSCrypt Initial DNS request\na65cce3c70 extcap: Use extcap.cfg as extcap config file name\n0eb0d6fdb4 ICMPv6: Add a recursion check\n5a04c4ecee DHCPv6: Add a recursion check\n1515b211e2 SMB2: Add recursion checks\n40b210e1d6 cose: Peek ahead for map principal value before dissecting map items\n8f49a831cf ptp: Corrected data type for cumulativeScaledRateOffset.\nc72fc5b163 Fix some spelling errors\nb5ffe3deac QUIC: Handle early 1-RTT data from server\n00c938b7a9 OSITP: Pass ED-TPDU to subdissectors\nff23d579de SNMP: Add support for RFC 5343\n25487eceef feat(#19647): decode Datum enum and Ver field\n1703eea653 feat(#19647): decode resolution fields\nf501c57fc3 feat(#19647): check longitude and latitude max value\n5e9e75537a fix(#19647): correction of fractional calculations\nac9ff53c7a LUA: Pickup LUA 5.3 or 5.4 if available and use it.\n8b0e90d62e AllJoyn: Add recursion checks\n34c90f7a3d 6LoWPAN: Add recursion checks\n302eb58770 GTP: Fix filtering of UL/DL items\nf9e052b88e LUA: Make it compile with LUA 5.4\n926344c16c LUA bitop: Convery our lua_bitop.c to work with 5.3 and 5.4\n282bd19e88 TN5250: Add a recursion check\nf8af3cd410 Add Clang-Tidy suppressions to various dissectors\n7183ac40da MONGO: Add a recursion check\n722816c68e dfilter: Handle 64-bit extended value strings\n2f6833b5f7 SMB2: Update reserved field and add new dissection\nfea3d36a7b extcap: Allow starting from extcap config\n942d7f4b41 R-GOOSE: Strengthen heuristic for CLTP on UDP\n339d6d4aba text2pcap: Set encapsulation to WIRESHARK_UPPER_PDU with -P\nc99e37131b TPNCP: Fix two potential array overruns.\nb8c6c9e1a8 5co-rap: Add a Clang-Tidy suppression\nd7b15ff6d1 RBM: Add a recursion check\nbb73b87bc7 MP4: Add Clang-Tidy suppressions\n46c652102f JPEG: Add a recursion check\nff93425a66 Thrift: Add support for raw sub-dissectors\ne911f8ec9d stats tree: Update plugins for new path separator\n57c19da670 ISIS-LSP: fix masks for attach set of flags\n4176fb8f15 BLF: Fix the build\n3b2c961eeb BLF: Add a recursion check\nf3e1d98434 Clang-Tidy: Fixup some suppressions\n55798da218 PLDM: Fix coverity warning about version printing\n6f79b432dc Annotate short names of VP9 fields in field names.\n16d85df6f4 ISIS LSP: Add a recursion check\n45f9dae43c GIOP: Add a recursion check\n6c52cdf959 ENRP: Add a recursion check\nfed4751087 add missing field for Roon Discovery\n4300f713b1 prefs: Always write main prefs file\n70157523b7 wsutil: Only copy configuration files that are regular files\n8bdc10c6ca Telnet: Include a packet summary in Info column.\naa64b079a4 x509sat: fix type of organizationIdentifier\n11350a714a Couchbase: fix link to memcache text protocol\n7426e8c3b0 PLDM: rework the way the version string is generated\n028f423f4e CBOR: Update our recursion checks\naa10123bf0 BACapp: Update our recursion checks\n5f0672d749 Add initial Clang-Tidy configuration files and a CI check\n9a67fac86f prefs: Backwards and forwards compability for hiding columns\n61e4026336 Add missing status/flags to packet-couchbase.c\n4ee708f3a1 Protobuf: Add a pref for last-ditch message name to try\n87c0f372e0 x509sat: Add Organizationidentifier (2.5.4.97)\n28e94c2670 rlcmac: Add USF to COL_INFO in DL CTRL blocks\n4cfbe0f5c1 dfilter: Don't allow \"matches\" operator with FT_FRAMENUM\ne248d37036 Thrift: always generate field_id proto item\n268e742541 extcap: Fix writing preferences to file\n4d4f264153 added copy as C Array\n4fb2ef8af8 extcap: Really don't load extcap interfaces if disabled\n48bb12831b Some spellings\nd7b2445089 [Automatic update for 2024-02-18]\ndeac878dd5 tools: Don't assume that Homebrew has Lua 5.1\nf91c6bc812 Tools: Use bsearch to look up vendor in pci-ids.\na9064a1048 PLDM: don't separately fetch field values - use _ret_uint() instead\n887767433f VP9: Fix spatial layers label and add generated field\na383ce12fb IPSec: Check ESP ICV with Extended Sequence Numbers\n270ad4feeb doc: Mention that Lua 5.3 and later doesn't work in the WSDG.\n165cf06f5c Protobuf: add media type application/x-protobuf\ndff1a79961 GTPv2:Use more proto_tree_add_bitmask_list\nb1bd18d826 macOS: Update our app bundle plist info\n76cfa03d61 wireshark metainfo: Add a developer name tag\ne540c8777e Qt: Drop command line options when changing configuration profiles\n8b63b0243c PLDM: change some distracting formatting\n456b8af98b doc: extcap_example.py SyntaxWarnings with Python3.12\n595359c793 Qt: Implement macOS \"Show in Finder\" in Cocoa.\n775fedcef1 Adding PLDM dissector for FRU Specification\ne49da31a8d epan: Fix copy-paste error\n1307fa9226 extcap: Update comments about callback\n5ed34995de extcap: Don't add args to a list just to destroy it\nf1d0622b47 IPv6: Implementation of conversations with stream identifiers\n30c0b28f87 Qt: Implement \"Show in Folder\" using DBus.\n99df5f588b prefs: Read the old hidden column preference\nd54031eda9 GitLab CI: Add release notes artifacts\n8803d13aec stats_tree: Free the split string array\n49540ec646 columns: Allow any field expression syntax to be used in columns\n19904e94ae Modbus: Show register/coil number as generated without link to data\n150e2ed18d Modbus: Decode data in Write function to Value\ne2862d77d6 DNS: Stats tree updates\n53638f9ccf Stats tree: Change our path separator\n28c42e2656 Some more spellings in dissector comments\nb2be437e39 Add EARO status codes from draft-ietf-6lo-multicast-registration-16\ne78684d793 Dissect P-field in Neighbor Discovery EARO option\nefa68ae1d7 Rename nd_opt_earo_flag_val\n285f9ec650 DRBD: Add support for dissecting the DRBD \"lb-tcp\" transport\n1e067dc17d DRBD: Add support for new versions of P_OV_RESULT and other packets\nf845ce118e check_spelling.py: add globs\ncf22e64b21 X11: static-ify the generated dissector.\n83bff589ea X11: update to the latest xcbproto and Mesa.\n556e604e12 X11: Revert part of efcaa68807151b46e4352bb7dbdd4134057237a1.\n37937ef514 candump: use WTAP_ENCAP_SOCKETCAN, not WTAP_ENCAP_WIRESHARK_UPPER_PDU.\nb7b7a6ce96 macOS: Try to keep launchctl from failing in ChmodBPF\nda3a73d68c busmaster: use g_htonl() rather than g_ntohl().\n49934c1d14 dfilter: Add a flag to return field values for the tree root\n098462e703 CMake: Fix some version checks\n38a29e82cc socketcan: the priority/VCID field in the CAN XL header is big-endian.\na018829a36 Falco bridge: Sort our Container I/O totals\n0e5416efbe Falco bridge: Fix our default container name\nfc6255688d OCP.1: Add message size check in loops\n4c9584ef45 column: Update custom column regex\nc787f791bf AT LDF: Minor improvements\n7161168838 epan: custom column FT_NONE and FT_PROTOCOL check marks\n3b6785683b AT-RL: Support Allied Telesis Resiliency Link\n920d2774bf stats_tree API updates\na902951351 Art-Net: Add missing fields and update to Rev. DI\n0cdbb03d95 socketcan: use the right byte order when manually fetching a field.\n849c1251df busmaster: use WTAP_ENCAP_SOCKETCAN, not WTAP_ENCAP_WIRESHARK_UPPER_PDU.\nfdf4ecdb4a socketcan: fetch the protocol/VCID field in the right byte order.\na313faaa42 Fix two typo'd words.\na201387e32 Fix checks for SocketCAN field availability.\n8143babe21 Byte-swap CAN XL headers in LINKTYPE_LINUX_SLL/LINKTYPE_LINUX_SLL2 packets.\na57b564f81 socketcan: don't use the byte-swapping preference for CAN XL.\n4508a77bbc NFS: add support for dissecting GET_DIR_DELEGATION operations\n55c75998ce NFS: rename the \"notification\" fields in the dissector\n41930060b0 prefs: Use column index, not format, for hidden state\nb9c2ffd180 column: Split custom column formats from the right\n9fbff8d554 Qt: Stats tree dialog speedup\n938192ca9c TCP: Fix location of Timestamp Option values\n93c79e2bfd [Automatic update for 2024-02-11]\n8f670352df blf: if there are no log containers, return FALSE when pulling one.\ne5c519ba45 socketcan: provide more information in the Info column for CAN XL.\n825f27723c socketcan: append text only after putting the value into the tree.\n214a744bb7 dfilter: Return the register containing fvalues\nb96747823d socketcan: show more unsigned values with %u.\nc713f7260a socketcan: show all relevant digits in Info column and top-level item.\n7d6f2b182b socketcan: clean up some variable names.\n2c40e6c903 socketcan: add a CAN XL SDU type subdissector table.\nbb495a512c SOCKETCAN: Fix a couple of spellings and use XL length field\nf2fae54a58 recent: Don't use format info at all\n07b8a53361 Add & use tfs_should_be_traced_should_not_be_traced\n4aa91006d0 GTP: const-ify some big data structures.\n9989fd2830 Add Stack Overflow links for showing file in folder.\n319101f544 Falco bridge: Make sure our strings are UTF-8\n5e10272450 Falco bridge: Add container I/O stats\n57a1be8873 Falco bridge: Skip some more syscall fields\n6f0c9d4f0b socketcan: work around libpcap bug, add CAN XL support.\n127548227e recent: Keep recent column width in sync with prefs\n2574d5b9c6 Qt: Add width and alignment to column preferences\neebe0a38be Qt: Fix the FilterExpressionToolBar context menu position\nd3c837f6e0 Falco bridge: Fix a couple of integer casts\n4ec1ae4523 wsutil: Add null checks to wmem_map\ne967a3ecc3 Fixed Zigbee NWK GP dissector heuristics\ncd33794373 Fix: formatting\n9b36918071 Qt: added preference for hiding 'Welcom page' -> 'Open'\nb571c553b4 DCM: const-ify some big data structures.\nc0c2cac89e DCM: Update from 2021b release to 2024a.\n3f69f2a0f8 Tools: Expand licence-check horizon to 160 lines.\n1d16a8fb89 Frame: Use \"System Event\"\n98ebebec80 Sysdig Event+Falco Bridge: Highlight I/O data\nb7ae4f2eb7 Qt: Add null checks to the protocol tree\nb8999a383c Fix some more spelling errors\n754a16258c LI5G: update column protocol and filter name\n75a64a96b7 Qt: Only save the filtered rows to the Map\n7fbff7a381 GNSS: add dissector for UBX-RXM-RAWX messages of u-blox GNSS receivers\n59d56d7520 Move unit string for cycles to unit_strings.h\n5a761cf95c GNSS: use proto_tree_add_bitmask() for UBX bitmask fields\n54fa2250bd GNSS: replace usage of \"^2\" by UTF8_SUPERSCRIPT_TWO\n44bcfa9f0a GNSS: add dissector for UBX-NAV-SBAS messages\nf1463bbd32 GNSS: Map GNSS ID in UBX-NAV-SAT SV info subtrees\nd66973d947 GNSS: reduce ett_ubx_nav_sat_sv_info length\n48a5255a25 GNSS: make available SBAS UDREI mapping to other files\nc3305a4bd1 GNSS: add dissector for UBX-NAV-TIMEUTC messages\n4b68415213 dcerpc-netlogon: fix const related compiler warnings\nb85a56ac73 dcerpc-netlogon: fix dissecting NetrLogonGetCapabilities\n962979a802 dcerpc-netlogon: add basic dissection for NetrChainSetClientAttributes\nd65b6075af dcerpc-netlogon: add decryption support for netlogon.sendtosam.opaquebuffer\ne673fc411d dcerpc-netlogon: fix dissecting of NetrLogonSendToSam\n4f1ed11da0 dcerpc-netlogon: fix netlogon_dissect_NETLOGON_SECURE_CHANNEL_TYPE for NDR64\na8ad212436 dcerpc-netlogon: add the latest opcodes from [MS-NRPC]\n8a6a10b02d dcerpc-netlogon: make use of common dissect_ndr_nt_SE_GROUP_ATTRIBUTES()\n3a0891a257 dcerpc-nt: add dissect_ndr_nt_SE_GROUP_ATTRIBUTES\ndde539d342 windows-commoni: add new wellknown rids values\ndff5065873 windows-common: fix handling of Compounded Authentication/Claims Valid SIDs\n4be3aad2a4 pkinit: pass kerberos_is_win2k_pkinit() over actx boundaries\n647bb10117 Kerberos: add support for aes256-cts-hmac-sha1-96-sk\n8b15994f2b Kerberos: add support for PAC_FULL_CHECKSUM\n8efeee83d1 Kerberos: add AP_OPTIONS UNVERIFIED_TARGET_NAME flag\necb4562e3b M3UA: also dissect tcp/2905, implement reassembly\nc9bbcca3b8 Qt: Show \"Events\" in the status bar when appropriate\neab4734a0d Logray: UI updates\n2de251261d conversation: Fix conversation_element_list_values.\nb5d010d44e CMake+Logray: Add the About → Authors CSV resource\n2a73e99cfb Falco bridge: Syscall conversation updates\ne972a755d2 dfilter: Handle null arguments to min, max\n795dc54aae ldap: make use of STRING_CASE_INSENSITIVE for CLDAP\nf6efcb3313 ldap: assume GSS-SPNEGO as default\n9dde2bee6e DHCP: interpret option 108 properly\n714e568f66 Fix some more spelling errors\n600de02805 PDCP-NR: Show Integrity data\ndcaad51341 XnAP: fix a typo in a variable name\n7b114620c7 opcua: Have a default signature length preference\n89ce06c459 Fix a grab-bag of typos.\n2735ae7219 Qt: Add delta times to the follow dialog text formats\ndae546e83a [Automatic update for 2024-02-04]\nd74c040e9e file: Use the compiled dfcode in cf_filter_packets\n126c95fe2b Falco bridge: Set our sinsp buffer format\n6a0277a9e4 diameter: add Travelping vendor dictionary\n78e9f6e003 F1AP: Set a UEId for PDCP-NR frames\n97f33510e7 GTPv2: update IE F-Container to utilize expert field\n80ced3ccb5 ERF: ignore a non-contigous mask\nad5439e064 gsup: PDP Address IE: Update naming and improve dissecting\n546d8763e9 GTPv2: Handle EPS Security Context long EAR data\nb69943609a extcap: Fix some leaks of argument settings\n15c4bccee1 Updated to use new PI_RECEIVE and PI_INTERFACE extert Info categories\n1e0e261b23 Separate ERF Expert Info fields\n5e74e92934 ERF Interface Id Extension\nadfa18fe50 Endace ERF Interface Id extension\nbf79e63b1d const-ify enum introspection data.\n0db3d8e012 const-ify proto/handoff/tap registration data.\n7f7650b945 wslua: Allow UInt64 to be passed as value to a boolean field\n8a14ae6304 Add some new expert info groups.\nbfa4a36313 FAQ: Fix our Wireshark Foundation URLs\nf3b0bf4a7e Sysdig event: Dissect parameters only when we have some\nc8a2abdcf0 NSIS: Miscellaneous Logray fixes\n3d49e841a6 check_dissector: check spelling of comments for chosen dissector\n7bbaba61c0 SRT: Added handling for more handshake extensions\n1ad0cd4580 tshark: process async DNS queue during the first pass\n132847b6a4 epan: Pass in a 64 bit integer to proto_tree_add_boolean functions\ne476661bde DOCSIS: Common MultiPart handling for MMM v5 and up\nee1afcfe61 DOCSIS: Hardware Friendly Resource Block Assignment (DOCSIS 4.0)\n90e94555aa DOCSIS: MAC Frame Control Type 0b01 becomes Special Use MAC Header (DOCSIS 4.0)\n91e3b39918 addr_resolv: Wait for pending lookups when switching to synchronous mode\n8a54995b1c wsutil+tools: Version info updates\nee90fb0f41 GTP: improve dissection of PDU session container\n2a67af62fe NSIS: Ship Logray's profiles with Logray\n80bf3025af osx-app.sh: Sign plugins with .so extensions\nc66700d7dc Windows: Upgrade libssh to 1.10.6plus\n8cea8e7120 Fix more spellings - mostly comments\nf4e71562d0 NSIS: Fixup the Logray installer\n868b38040b Logray: Use the name \"Logray\" in more places\n6cc1ff055a ASAM CMP: Fix Vendor Data limit and missing UDP Encapsulation\nd053622cea Falco bridge: Allocate our tap data\n5b6454aacf RTP: Add the extended timestamp to the tree\n575d285554 WSUG: update Service Response Time support list\nbf5ec983ab pfcp: small spelling correction\n9eec8a12eb Fix some spelling errors\n3d63241756 BLF: Fix handling of 0-length log containers\n0032e25a8a RTP Analysis: Use extended timestamp in statinfo\nab73082708 CMake: Fix our falcodump symlink\n3588090b2a Falco bridge+falcodump: Various fixes\n574fc0e1a6 Qt: Use \"Logray\" in the about box when appropriate\nf241cd6208 SANE: Improve the way opcode is remembered for resps\n28e9035eec MATE: Update examples\n81d094d47f RTMPT: Convert to ws_log system\n24669a5ab4 ISAKMP: add parse auth_method and proto for China IPSec VPN specification\n4e987dc451 epan: Remove layers when a dissector consumes no bytes via fragmentation\ndc66792430 epan: When exporting as C arrays, don't end a line with backslash\n4ec5c7f78f MATE: Handle fields that are in different data sources\nf33439ea03 epan: Don't fake child nodes of visible proto items\ndf24178150 RTCP: Implement Profile Specific Extensions as a payload table\n3383ac2d32 TLS: Explain legacy_version more\n3e519a0385 Falco bridge: Correctly handle trailing internal events\nfc6a511997 x50ce: addic Dissection of IPv4/IPv6\nfbd408cb58 x509ce: Display unknown IP Address (DATA) when it is not 4 or 16\n05ee426d93 Logray: Make the Syscalls profile the default\nef65fcb94d Bump the Logray version to 0.9.0\n044ca84eeb macos-setup: Conditionally install Falco libs\n2b5fd572f7 File sets: Match both formats, compressed files\na8aebe5cf4 Check for item long text being 0 - prefer NULL\nda8c8fc1cf NGAP: append SMF PDU in column info\nfde6865fe9 PLDM: make a function static\nc6fee3ab52 Fix some more item warnings\n4a948ad57a SANE: Quality improvements and correction\n76909e44d2 [Automatic update for 2024-01-28]\n57bfe3d4a3 COSE: Fix a leak\n2d22fa26ba XMPP: Fix some leaks on malformed data\n859e70fbb3 WOW: Fix use of unitialized memory\nc77448d793 GTP, GTPv2: stat taps can't be wmem_file_scope\n5dc8c6d5fb Check valid display value set for ipv4 fields\n73c7fcab1e Check that string items have display set to BASE_NONE\n7b58f82228 Set BASE_NONE for FT_BOOLEAN items with zero mask\nf3216e8c4a RTP: Add OPUS dynamic clockrate\n25f8695771 Be careful with scope of strings used for columns in SRT table\n0103e8f9d7 DNS: add queried names to DNS statistics\n38bcee5963 Services: const-ify the data structures.\n989002841e BACnet:Fixed dissector for authentication related properties.\ndd846520f4 [Zigbee GP] Fixed move and step cmd dissectors\nd424f4b330 feat(ssh): Add support for ping@openssh.com message dissection\na335e10838 feat(ssh): Add SSH dissection support for proprietary extensions\nc85c4dcfef feat(ssh): Add SSH_MSG_NEWCOMPRESS message value\n7039e85f8e feat(ssh): Add  SSH dissection support for RFC8308 extensions\n19ddbcaaae feat(ssh): Add SSH extension dissection support (RFC8308)\n352fe53a15 dfilter: use strpbrk when checking if macro or field reference\nf09710965a [#19584] show heur dissectors in `tshark -G` report\n56292dc522 Qt: Set imported hexdumps as tmpfiles, don't set last open dir on then\na3900a5d5e change display order of IEEE802154 address fields\n08956f6d13 DNS: Add expert info for missing response\nf5f8a574b1 Tools: const-ify pci-ids data.\n864c212b51 SRT: Parse the Group HS extension\n1e3a1d7118 Adding PLDM dissector for Platform Specification\ncb259891f7 Qt: Restore drag and drop filter buttons\nd1301fecc1 macos-setup: Use `set -e`\n4571d9f194 Fix more FT_BOOLEAN items with no mask - set len to BASE_NONE\nfa84f7541e Check that FT_BOOLEAN items with zero-mask use BASE_NONE\nbf30e483c0 bthci_vendor: Add broadcom read mem and refactor writemem\n5a28b01e86 rtmpt: Don't allow chunk_size to be zero or negative\n86705cc863 macos-setup: zstd and lz4 fixes\n4d6a8c85b5 Fix base for FT_BOOLEAN without bitmask(BASE_NONE)\n08cf0e9553 file: Don't recompile the dfilter during a live capture\n70e78cd390 ringbuffer: Use g_path_get_basename to find the last component\n26c6e3af12 test: Skip mongo zstd test if we don't have zstd\ncf74fae3d9 HTTP2: Heuristicly detect application/json\nffcf580230 epan: Make hex_str_to_bytes reject an odd # of hex characters >= 3\nf274be5523 dfilter: Handle null arguments in macros better\nc538dd9ff9 tools: Add a protected branch check to validate-commit.py\nffbf7ff540 dfilter: Allow semicolons to separate macro name from arg list\n5c972dd075 GNSS: fix formatting of SBAS MT25 velocities\n72e83ae49a ieee80211: Add decode as Wi-Fi for UDP payload\n78a8793cbc \"Follow\" implementation in logray\n457764fce3 HTTP2: Heuristically detect multipart/mixed\n808d9d39f7 openSAFETY: adapted verification of ID fields in sub frames\nb6a9c48eb5 E2AP CCC: Clarify that V1 has been added\nb05def7a50 dfilter: Don't parse invalid characters in macro names\n0755cde944 Qt: Don't offer field completion for literals containing ':'\nde98508497 gsup: Fix decoding of empty IEs\n0926a98b30 Zigbee ZDP dissector field parsing fix\n34c703f7de Windows: Updgrade GnuTLS to 3.8.3\na4b88e3d8b macos-setup: update to GnuTLS 3.8.3\n4a27b7e3e8 someip: Fix Dead Store found by Clang Analyzer\n9d65454c9f Update dictionary.aruba based on Aruba ClearPass 6.11.4 RADIUS attributes\n7b43059f1d Qt: Add back \"Copy as Printable Text\"\n676478c8d3 epan: Use an ellipsis to indicate truncated fields\n271496bd23 Lua: `DissectorTable.heuristic_new()` with description\n2456e96caa Tools: More macos-setup.sh cleanup\n49050877b3 tools: Add an installation prefix option to macos-setup.sh\n6e474d1af1 [Automatic update for 2024-01-21]\n760e512dd4 capture: Remove the logging parts before each line\n3bbf468421 Qt: Indicate that the grammar has changed when reloading macros\n651122a798 Undo some more double colons\nc3e98efd5b http2: Use our own process_reassembled_data\n534cc08ebc LUA: allow conversion from string to uint64 in any base\n39aeb7a7dd tools: If macos-setup installs Python, install a recent one\n6d39c511fb extcap: Set matching libssh log level\n55214bdacd extcap: Provide a more useful error message when key passphrase is bad\na7f7cd6487 Tools: macos-setup.sh shouldn't install legacy PCRE\n9a97bf2216 Add support for attributes defined in NAN Spec R4\nd1723c98d4 Qt: Fix some leaks in ExtcapArgument\n4bb69a479d capture: silence warning for non-root user\nd0bb6b3dfe Dissectors: remove accidental double-colons\n1058293e78 X11: ConfigureWindow: Fix 'window' and bitmask fields.\n76bb8cca37 Tools: Clean up macos-setup.sh\n94c2f18924 Fix -o capture.auto_scroll: setting\n49ada98a88 Increase libssh minimum version to 0.8.5\n87f06bfd58 netflow: Handle variable length fields with zero length\n256c9bebac Adding dissecator version 4 for GICI protocol\nf67b74550b ISUP: Add recursion checks\n0cca51a61b UCP: Handle alphanumeric OAdC\n577d8313fc GSM A DTAP: use proper tree for spare bits in de_bearer_cap()\n2640465545 tools/check_val_to_str.py: add option to test generated files\nb411905eb9 NRPPA: trivial cleanups\n8cf61be180 capture: Don't print an empty error message on extcap errors\n2d6310f4f8 SMB2: make a function static\n79c6e9db9d HTTP3: Huffman decoding\nc3c0fb7263 SMB2: dissect FSCTL, Query info, and Server notification\n8d79ea2f0d Falco bridge: Improve our internal event detection\n73ece5e8c8 epan/dissectors/packet-cql.c: fix few typos\n80a3890dab extcap: fix build with older libssh\n84cf907fcb WSMP: Set correct length of N and T headers\n05e1338d61 GTPv2: correction of IE Monitoring Event Information\n524621ca21 NRPPa: upgrade dissector to v17.6.0\nbf909bf93e Add descriptions for heur dissector tables\nf20d45f1aa Qt: Always enable our \"Follow\" menu items\n9703cf23a8 TLS: Update the follow tap name to match other dissectors\n7983d70203 GNSS: SBAS dissection improvements\n75d79e5d7d rdpudp: Fix leak\n85aeaf1f34 Adds a dissector for SANE (Scanner Access Now Easy).\nbcfa25bdfc Falco bridge: Add a quick CPU+PID cache\nd302ff5b42 F1AP: upgrade dissector to v17.7.0\n893a68e6d9 [#19585] Add description for heur dissector tables\n7919c374d7 E1AP: upgrade dissector to v17.7.0\n1295d416ed XnAP: upgrade dissector to v17.7.0\ne31f805c81 NGAP: upgrade dissector to v17.7.0\n28c7e0cce3 NR RRC: upgrade dissector to v17.7.0\nfeff9a8b80 LTE RRC: upgrade dissector to v17.7.0\n87dfdbb915 LPP: upgrade dissector to v17.7.0\ne0811c1aa0 x75: don't register for WTAP_ENCAP_LAPB.\n760462e2dc Qt: Status bar updates\n5c8c379b69 extcap: Add ability to enable SHA-1 algorithms\nb8f252dd99 Qt: Add support for date and time before file index in multi file mode\nb5c839815e Remove duplicative members from interface_t\neeb818f5e7 TLS: Display minimum supported version when version unknown in Client Hello\n91e75f3e46 NBSS: Handle short packets\nf5615dd9f9 IPv4/v6: fix field offset calculation for GeoIP entries\n7da3a871a3 [Automatic update for 2024-01-14]\nc413d81967 rtmpt: Add a default chunksize preference\nf374ddf2fb Falco bridge: Add conversation filters\n666443ebd1 Resources: Update the Logray Syscalls profile\n06f80366d5 Falco bridge: Update our memory stats\n664b858d44 SOMEIP-SD: call val_to_str_const()\n2c9b66d14a RTP: Use the same extended seqno / timestamp cycle for a new setup msg\n6e12e504b9 iface_lists: Do not reset capture options when refreshing interface list\nd4bc9d4036 opcua: Parse more Server and Client Certificates\n6c26a3c7dc Fix uintptr_t not found error\neec059c598 Falco bridge: Use ws_strtoi\n04bd21b700 pcapng: Sysidg events don't always have timestamps\na0f5d63515 Release notes: Note that the Parlay dissector has been removed\n520fb7848e GitLab CI: Install ruby-dev in the Documentation job\n490d0514d9 Parlay: Retire the dissector.\n846fae3141 rtmpt: Mark depended upon frames\n9152670fe5 opcua: Use fragment_add_seq_offset\n16fa05d719 Help: on macOS local pages are found in the DATA_DIR of the bundle\nf99cc3a69b WSUG: Document the creation of filter button groups\nb7ece5f111 RLC Stats: Check earlier for whether frames should be considered\ncaa9bfbe41 wsutil: Check GLib version for g_spawn Linux bug\n73e5eeae50 GNSS: add dissectors for further UBX messages\n2d04c10741 tftp: fix a typo.\n3c62d285ac Falco bridge: Use g_str_hash\n8f3756431f Falco bridge: Remove an unused struct member\n821fa78fee Fix some spelling errors\n7ce05b9dd7 opcua: X.509 Certificate dissection\n10a77d7b46 Parlay: Add a recursion check\n76f6b5285d opcua: fix payload size for unencrypted chunked messages\n4a5965fee6 Logray: Mark unused parameter key in follow\nf13740da74 Qt: Allow Manage Interfaces columns to be sortable\n610e5f0543 Support enhanced-RTMP ExVideoTagHeader\n65c04f2886 Fill gaps in AWDL DataPathStateTLV.\n1c25228013 tshark: Fake unused proto items when -e is given\nfe54aa6371 Revert \"Main dialog: Wireshark stops extcap on exit if no packets received yet\"\n53e180491c SOME/IP-SD: Improve handling of ANY values and unknown entries\n5d2bcdd377 pfcp: Update to 3GPP TS 29.244 V18.4.0\n9aff6a9314 netlink: show padding between short attributes\n27857b268e ISO15765: Cleanup and fix incomplete dissector warnings\n73bf0d5b23 Falco bridge: Minor performance improvement\nf01e345749 Logray: Add back the \"Follow Stream\" dialog\nc3293b9520 Don't overwrite error message from dumpcap\nba6f76e0d5 Falco bridge: Add a preference to show internal events\nc659ffbed1 Falco bridge: Disable memory statistics debugging\nc8281ec58a netlink-netfilter: Show padding bytes\n885e638a03 NAS 5GS: set subdissector for SMS NAS messages in HTTP2\n624ba9311c packet-cql.c: add support (partial) for custom payload result response\nf52841191b capture_opts: Use g_list_free_full\n626caf9699 Fix crash in capture_interface_stat_start.\n579aa4117c WMIO: Fix an infinite loop spotted by coverity\n7eaf8bcba2 ATLDF: Remove unused macro\n14767f824c iface_lists: Reduce some unnecessary string copying of if_info_t\nf9b2ad18c2 dfilter: Be ready for unparsed syntax type in semantics check\nde12268a9f Epan: Cleanup plugins only after all possible calls are made\n2fe5b48cf8 Falco bridge: Add a subtree to show process ancestors\nc0d0e01f95 Falco bridge: Hide some syscall fields\n6af57646d7 Falco Bridge: Reduce our cache memory usage\n186706b6cb Falco bridge: Add support for event arguments\nb8bf79eb21 Falco bridge: Cache our extracted data\n5822f3d101 Falco bridge: Add a null check\nf7dad73b9f CMake: Fix the Logray plugin directory\n66c607f118 Document discontinuities in OSPF and IRDA dissectors\nec4b92c69f Wireshark + Logray: Batch interface capabilities in one call\nae3afe910b Infiniband: fix a couple of item offsets\na195204327 ORAN FH CUS: fix an offset and a length\n4b04c3fd05 ISO15765/UDS: Clean up of Address Handling\n6cc134358d Dot11Decrypt: Switch from recursion to iteraton\n218db31955 asn2wrs: Fix our recursion checks\nb29a969131 capture: Restore save file template when stopping multiple file mode\n6a2dd639ef tshark: Retrieve interface capabilities in one call\nb4c07ac165 NAS 5GS: upgrade dissector to v17.13.0\n0c923da588 [RF4CE] Fix for RF4CE NWK heuristics\ne1efe33c0b WMIO: make a variable static\nd52dc11ae4 cbor: add recursion depth check\n352ad96b57 Fix some spelling errors\n1d6c7eecb0 [Automatic update for 2024-01-07]\n5b87714ec8 Add parsing support for IWbemServices and WMIO\n4feb30a85e Qt: Packet List vertical autoscroll only\nb8e7db6600 QUIC: Fix running dissectors on 0-RTT data\nec232d03d3 SOME/IP: Do not ignore messages with empty payload\nd3b5f367e9 T38: Fully initialize t38_conv struct, part 2\n4232cb5575 rtmpt: Limit initial allocation size instead of max packet size\n91266a7683 doc: Update WSUG for TCP Completeness filters\n822a95d156 rtmpt: Fix iteration check\n7afb54035f Windows: Update our minimum version\n1a81a7cacf RSVP: Support Capability Object\n4f3b03b72a NTLMSSP: Zero out the session key at the start of creating a v1 key\ne68771714a Qt: Update some comments related to WinSparkle\n96b0a674c7 Qt+WinSparkle: Don't close the main window in the can shutdown callback\nb1e900496c E2AP: Check whether table entry was found\n75fa97e7f2 RSVP: Fix typo\n75fc7e11e8 TCP: Duplicate ACKs hidden by Window Update and SACK presence\na8bfde6eb7 UAT: fix wrong cbdata being passed to cb.set()\n25fb6c316c SocketCAN: Add hidden CAN item to protocol tree in case of CANFD\n4278536da4 Tools: add script to make value_strings used by bluetooth\naf8643c5ae epan: Make \"frames passed the display filter\" the default\n8f7f7cd7de s4607: Add to \"decode as\"\nca02798714 RTPS: Don't leak in the guid hash\ndd7df70be8 Add \".snoop\" to the list of capture file extensions.\n40111d9e8f GitLab CI: Generate our release notes\n2e30826a61 Debian: Ship sharkd\nbcb0d02568 NSIS+WiX: Install sharkd\n69c9e06dae Thread: Update for Thread version 1.2 and 1.3 along with TREL\nc550e9f26a SSH: don't hide signature types you don't dissect\n5816b3c75c SSH: We don't use Gerrit for a while now, remove its port from defaults\n0e9ea401f7 TCP: Prefer full checksum over partial if the same\n6f17dcd67d RTPS: Fixed User Data Dissection feature\n329523afee TCPCL: Do not call g_int64_hash on a gint\n370e5db90a E2AP: check table pointers when adding ranFunction\nd44e171cee T38: Fully initialize t38_conv struct\n9f05d77cec sctp: Fully initialize tmpinfo struct\n8f797db63c asn2wrs: Add recursion checks\nc9c40514d8 MLE: Don't call tvb_bytes_to_str with zero length\n1229ee0468 COSE: Fix some leaks in cose_header_context_t\n940feb7bf2 maxmind_db: Set CLOEXEC on the pipe file descriptors\nfdaba24262 Ethernet: Implementation of conversations with stream identifiers\ne60046305f Qt: Add capture comment to custom title\n77b0583568 DOCSIS: Extended EH Elements are not recursive\nbf1ab5c304 macOS: Include the admin group into access_bpf.\n7fcc15cb54 pfcp: Add Service Response Time statistics\n45b929a1b6 RTPS: Fully initialize a struct\ne07603d512 ChmodBPF: Specify AssociatedBundleIdentifiers in the Launch Daemon property list\n4a74687e60 addr_resolv: Return NULL for unknown port types\nb67b86059e IAX2: Unknown HF is now 0, not -1\n322ae0f0d8 Happy New Year 2024\n9600ef2279 dumpcap: Pass the Capchild log level from parent to dumpcap\n3fbefe9c36 dumpcap: Make capture child logging work\n2bf14f5fe6 JSON-3GPP: fix a (presumed) typo\n695740ea41 capture: Don't print a warning for an empty message\n4f46ed269f USB: Dissect protocol also at interface level\na024563fb3 [Automatic update for 2023-12-31]\n96207a4e27 Don't pass UTF_8 arg to valgrind script\nc08e6e56fd Remove packet scope usage from a few dissectors\n4a454d8d62 dumpcap: Don't use fd 2 (stderr) for the sync pipe\n17fcdb4735 pcap: Update link_type_vals\ndc6f197726 dumpcap: treat connect errors as remote capture errors.\nd9247e7edb GitLab CI: Get our clang version from our container\n68d85c8032 wtap: Add DLT for DECT_NR\n648b18c92f Qt: Fix crash on Windows adding pipe when interface list isn't loaded\n1b9d95d6b5 Look into some cases where 1 value_string value is missing\nef2eb13350 netfilter: improve nftables dissection\naf5a53efc0 ISO15765: clean up code and fix typo\nfe3b55d85d ISO10681: Code Cleanup\n35fa4fa36d SOME/IP: remove empty line\n97d59fc20f CFM: Fix check for Management Address [Domain] when Chassis ID Len is 0\n4e6484600d LLDP: fix return value of lldp dissector\n42e85b29e1 GNSS: fix SBAS MT1 - MT5 field lengths\n1ccbc482a0 packet-sv: fix the seqData validity\nb0e87a4207 irda: make it clearer that the control field is at the current offset.\nc635a0b388 irda: update some comments with new and additional links.\n84ddc8c446 LIN: Don't process payload if the frame has an error\n1d6abf627c Bluetooth: update UUID and Company ID registry\n7e0004ed96 tools/check_static.py: show in output if file was generated\n9bb31318fe GNSS: add dissector for SBAS L1 MT24\n64b9bad199 BTL2CAP: Switch to using more efficient bluetooth_uuid_vals_ext\n2dae7c2d79 BT_ATT: Adjust ranges for protocol registration\n1243b49c49 tools/check_static.py: make script more readable\nbfad74780a [Automatic update for 2023-12-24]\n74d97afd72 capture: Fix leak of secondary messages\nc7c5d962e0 Tools: update generation scripts to no longer initialize proto vars\n922d1f6219 SCTP: Use hashmaps for association indexing\na1b2a14ad3 Qt: Set Packet List autoscroll off\n9b4c2ffb33 ICMPv4: Mark formally deprecated types\n3794caff71 capture: Fix up getting stats\n52c1ebb4e1 SCTP: Send sctp_info to the tap even if there's an exception\n87d749d2fe ISO15765: added a bit of documentation\nf863b276c3 JSON-3GPP: Fix label for mapdu item\n5f870017f7 E2AP: fix range check while registering RAN-function dissectors\n54ed27e11a Qt: [Re]start the stats when filling the interface list\n0fc2359812 tshark: Deprecate -G with no argument\n685ea4f15d Don't include net/if_var.h; it's not present on all *BSDs.\n8e3de579a0 tshark doc: Mention that -G must be the first option given\n5de1a339c4 Fix some spelling errors\ndb28c15aeb DTLS: Initial support for adding DTLSv1.3 to the Protocol column\n60dd24f701 E2AP: Add stats counter to Telephony menu\naf408571e5 JSON 3GPP: add TS 29.502 ch6.1.8 Feature negotiation support\n50bf11fd8c IPv4: Mark deprecated option types\ne293a19071 usb-audio: Fix Dead Store found by Clang Analyzer\n8069ffebb0 dumpcap: fix Dead Store found by Clang Analyzer\na37c90e497 addr_resolv: Fix Dead Store found by Clang Analyzer\n0b9c79598b radiotap: Fix Dead Store found by Clang Analyzer\n4d3475223a bgp: fix Dead Store found by Clang Analyzer\n6b837c6f28 QUIC: fix Dead Store warnings found by Clang\na09c648670 E2AP: When updating mapping from OID, take care over pointers\n2a33688291 packet-gtp: Avoid dissect MS Network Capability when len = 0\n8bb3d89065 ITS: Use CAM Version 2.1 ASN code\n689ff45cfd tools: Switch to target UNRELEASED in make-version.py, too\na0d904896d Qt: connect SCTP All Associations Analyze button correctly\n2634e62b70 SCTP: Add chunks as FT_NONE instead of text-only node\nf554ac643e epan: Add as much of a text-only subtree length as we can\n95a9fc5c0f QUIC: handle connection migrations for zero length CIDs\nacf419cfc9 iscsi: display number of bytes to Write\n999f9f65c7 iscsi: display number of bytes to Write\necdb67b4a0 ISCSI: Add R2T time and bytes transferred in List\nf699b10405 Display number of bytes to Write\n6a3f441da8 tshark: Load the profile settings before certain reports\n2b21fe5e4f capture_sync: Keep PIPE_BUF_SIZE and SP_MAX_MSG_LEN related\nc1ecdb49b3 s4607 - Fix Dwell Mask\nc55ae0513f NSIS: Remove some references to WinPcap\n29e56d0167 asn2wrs: Fix compilation without -L flag\nbe5f98b851 androiddump: Don't hang for 20s on Linux if loopback is down\nfd8e052955 capture: Fix Coverity 1559542\nf2095c8027 Recurse into folders while checking URLs\na7d5c07a13 E2AP:  In E2Setup message, read/use OID outside of shortName\ne2594ef0e4 ieee80211: Allow RPS IE dissector to parse multiple raw assignments\n607b3671c8 dumpcap: Add a welcome mode\nb22ed213e0 capture: Move pcap failure secondary message to header\n08eb1d87c7 wol: use the Wayback Machine for a now-dead link.\n71344aa160 Qt: Don't clear selected interface when auto sorting\ned3b6e6b50 Check for some document URLs\ndd6b58fcb8 Have a common provider routine to provide time stamps.\nb8bad2c745 asterix: 'number' upstream change adjustment\naa7bc121b6 RLC Graph: set initial x-axis scale correctly\n1724e23865 capture: More prep for retrieving and caching capabilities\n11e8b5e8d7 Qt: Fix build with DEBUG_STARTUP_TIME\n3a7169a5f9 GTP: Correction of IE RFSP Index\n66ab1e64e5 Revert \"Debian: Move codec plugins to the proper place\"\n05d9608dbd NR Taps: more fixes\n71da5f72b5 ieee80211: Fix RPS IE (802.11ah / S1G) dissector for RAW slot definition.\n3421eff1bc capture: Move deserializing the interface list to a static function\na3467677cf [Automatic update for 2023-12-17]\n1a95f230b9 dumpcap: Allow retrieving interface list + caps\ndadc6f1fa0 Update mailmap with new contact for Carlos Pignataro.\n9b6c116324 bitcoin: code simplification by using `proto_item_set_end(...)`\n005dfe2271 capture: Get regular and monitor mode link type lists at the same time\n63840f1cfb extcap: Fix Coverity 1559270\n636f0a989a capture: Add return messages to the if_capabilities_t struct\nc655b8e103 capture_opts: Free the if_list on a bad adapter index\n26e3979971 Add plugin extension to wireshark.pc\ne1f599cf51 Debian: Move codec plugins to the proper place\n38ff71b5ef Try to fix Debian package\n03d59b1458 DNS: fix warning\ned0a777776 RTCP: extend list of transport layer feedback formats\nd43c1754b6 RDPUDP: fix conflict about incompatible types\n974e09b0c6 scsi-sbc: fix checkAPI warning about shadow variable (index)\n34edc1a3be bitcoin: fix checkAPI warning about shadow variable (index)\nf10ca976ab BGP: Add Source Address to Type 1 Session Transformed Route\n7c38369bb6 Try to fix macOS packaging\nba2f53ef11 Windows: Upgrade libpcap to 1.10.4\n8c45aaeb06 CMake: Fix WiX packaging\nb2213b12e9 wslua: Add another exception for binary plugin subfolders\n36065ab356 Rename some codec plugin folders to lowercase\n7f32c90ab9 plugins: Add a codecs API level\nb52d9173f8 Remove version component from plugin path\nb51a3933ba CMake: Refactor plugin add_library() macros\n70383151ae doc: Mention partial checksums in Checksum Section\n7b4d667f30 BLF: Fix BLF_OBJTYPE_CAN_FD_ERROR_64 not decoded as error\n9c2959b483 EPLv2: textual decoding of ASnd error code\nb983decbcb opcua_application_layer: fix Dead Store found by Clang Analyzer\n6081bf1535 merge(wiretap): fix Dead Store found by Clang Analyzer\n00be42a1f2 tls-utils(ECH): fix Dead Store found by Clang Analyzer\ncd8893db10 capture: Serialize the machine readable interface list\ne3837d403e Falco bridge: Minor code cleanup\nbaf8ec83ef Logray: Add a Syscalls coloring rule\n5353057795 GitLab CI: Switch to clang 17\ne9d4f4f846 GTPv2: Dissect IE Group ID\n8ba4fb537d Improve pkg-config description\n4a9214b12d GTPv2: Dissect IE PGW Set FQDN Extendable\n897c94bd04 Qt: Don't connect in the .ui file only to disconnect in constructor\n107550c9c0 Move wireshark.pc.in and make our .pc file paths relative\nc0bfd405b5 Resolve GCC clobbered variable warnings\n1fc41b77b2 Logray: Fix the Syscall profile\nac524cff38 Windows: Upgrade GnuTLS to 3.8.2\n0d52ed247e srt: Parse Key Material message.\n934fe03fca Falco bridge: Add protocols for each filter check type\n8486ba26c6 epan: Add plugin get_descriptions callback\n5bcfa5b261 epan: Remove register_all_tap_listeners plugin callback\n0ed89bb91b Qt: Remove HAVE_PLUGINS #ifdef\nfd21a7717f epan: Remove HAVE_PLUGINS #ifdef\n4e7b79edce MAC and RLC statistics: fix filter expressions to work with NR\n4158fd0115 Zigbee improved Smart Energy time format and display\n6b7664bfd3 Fix some broken dissector URLs\n04165f8536 Monero: Use col_add_str\nb16190ab6d Falco bridge: Set our event number\n807413ea33 ORAN FH CUS: Update some value_strings for v13.0\ne2dff8eb27 Qt: Remove another plugin #ifdef\nedc7ebfcdb Qt: Don't fill in interfaces if we're just doing a caps query\ncc7f348b38 capture: Free capabilities automatically when the hash is destroyed\na57069a7ca CIP & PLDM: make some functions static\n2936f5c026 E2AP: add support for CCC RAN Function\n79d26352f2 GSM-MAP: use common tfs.c true_false_string\n66c4987948 RLC Graph: some improvements\n3d5ac61f29 GTPv2: Dissect IE PGW Change Info Extendable\n719ca70130 HTTP3: Use BASE_SHOW_ASCII_PRINTABLE for QPACK\n88e5ae3d14 HTTP3: Use the Wireshark logging system\n360cb3f40a plugins: Lower a log level\n22c27f2dae Qt: Remove an #ifdef for Windows\ne3d23bfad4 Improve paragraph about the GPLv2 in the README\nae170d9b22 Logray: Only retrieve the extcap interfaces\nccb8a79bc2 [Automatic update for 2023-12-10]\n0c9cceebe3 Qt: Cache the capture interface list in Wireshark and Logray\n2e5f5ab645 HTTP3, QUIC: Desegment HTTP3 QPACK Encoder Streams\n17d479f876 nflog: time stamps are in seconds/microseconds, not seconds/nanoseconds.\n2e288ae393 HTTP/3: Only decode a QPACK encoder stream on the first pass\nf50c46ea8c On *BSD, use a PF_ROUTE socket to get indications of new/removed interfaces.\n7a6338c60c QUIC: Don't desegment and call app handles for 0-length stream segments\n25bce48873 Qt: Fix plugins double-click/show in folder\n12234b2064 Qt: Add back \"Path\" column to Plugins tab\nbb09bed969 wslua: Add support for SPDX/URL/Description info\n4db3e8f3f1 Capture: Check to see if the interface name is a Windows Named Pipe\n0bcd2b6e6f wslua: Add a scope field to lua plugin description\n5f6b5c40f4 plugins: Improve build with !HAVE_PLUGINS\n8db858b667 RLC-NR: Further fixes to tapping NACK_SN + ranges\n47376298a5 plugins: Remove an assertion\nb1521550c6 plugins: Give higher priority to the personal folder\ne0acd7ef1e rdp: add dissecting of relative mouse moves\nbfda80d230 check_typed_item_calls.py:  Improve checks around items in bitmask calls\n8cda6390de Fix some issues around tapping RLC NR ACKs\n9a9b2e114f GitLab CI: Make sure we set the ccache size in our fuzz jobs\na23e4fa086 Plugins: Fix the issue of duplicate scanning of the same directory\n5e370aa748 assa_r3: Dissect UPSTREAMFIELD_NOTUSED as an unknown type\na7827322fc plugins: Rename \"dfilter\" to \"dfunction\"\nc76a28fca4 Qt: Add Install Plugin to Tools menu\n158e104569 ITS: CAMv2 uses \"pld\" PathHistory defenition.\nf5e25421a8 SOME/IP-SD: Adding expert info for StopSub/Sub combination\n18a5b0976a Qt: Fix crash related to new TCP analysis pref\n6ec6e5b545 Another check for a routine returning an error.\nc512da8b8b SOME/IP-SD: Adding expert info for Offer Service without Endpoints\n5b2533af87 TECMP: Adding support for ILaS data\ndd9e07ae6d MAC 3GPP Stats: treat all CRC errors as generic failures\n70497ac5f8 check_tfs.py: ignore utf-8 encoding errors\n2971ce995d Check for success of routines called between pcap_create() and pcap_activate().\nc6e03be53a dumpcap: check whether pcap_stats() succeeds.\ne17a22df89 Fix some spelling errors\n866de7bcde Zigbee display Smart Energy Fast Poll End Time as numeric and string\nfec945c2c6 Correcting AVP Type for Framed-Pool and Charging-Gateway-Function-Host AVPs\n00bbec71ca Adding Diameter AVPs to CiscoSystems.xml\n8e8e07d892 epan: Remember whether heuristic dissectors are enabled by default\n51c6fa874d Qt: Replace plugin column \"Path\" with \"Scope\" in About dialog\n678a048549 plugins: Remove unused argument to scan_plugins_dir()\n8ebde1309d Improve interface displaying and writing with multiple sections\n577cc97f32 HTTP3: Improve QPACK dissection split across packets, prevent crash\n62529defd3 recent: Fix leaks\n52eb0cab5b Added dissector for the Monero wire protocol\n74f3dad37c Don't warn about rdp.flags.pkt being non-contigous\nf6913a9107 GitLab CI: Disable more options in no options build\n184cf9e28b Qt: Disable the capture actions at startup if built without libpcap\nb14d9c963c Remove init of tap variables\n3644aa86a4 Draft: Make LTE Uu stats and graph work for NR too\ne7a6c296b6 Qt: Disconnect signals in PreferenceEditorFrame\n024f8a27bd Fix dumpcap build on platforms where isfinite() is in libm.\n85e0909553 Fix wsutil/ws_strptime.c to compile on FreeBSD.\n71fd16605c RDP: copy_address considered leaky\n9c39c82cb1 Qt: Add plugin description/homepage fields to About dialog\n242ddbb24b wslua: Fix loading \"init.lua\" in subdirectories\n869728143d Remove plugin license check\nc001d55cc4 Qt: Fix profile menu widget parent relationships\nd069a39c89 Busmirroring: Add expert item for invalid value\n6230344148 Adding PLDM dissector for Base Specification\ndc148e0ea5 CIP: Improve Connection Analysis\n01796d6f2e IPv4: Implementation of conversations with stream identifiers\n0e01240e78 SDP: Don't look past the fmtp parameter tokenlen for equals\n1da30947b0 Qt: fix build with older Qt <5.15\n98a8a9787b ZigBee TLV: Add a recursion check\nfedc96177f [Automatic update for 2023-12-04]\n1a33c02055 check_tfs.py: iterate through subdirs of epan/dissectors\n388f928c01 Test: Disable an ASTERIX test\n0b2bb4fdb3 plugins: Remove unused \"min_api_level\" field\n412f184af2 PDCP-NR (trivial): show calculated digest preceded with 0x\ne66f010ca2 Qt: Add context menu to Resolved Addresses\n369651d618 BLF: Fix BLF_OBJTYPE_SYS_VARIABLE dissection\nf835dc800f Update README.plugins and release notes\n60f1972fa3 plugins: Fill in short description field\n90b16b4092 Refactor plugin registration and add ABI/license check\n87ec22e63d bitcoin: implemented dissecting `addrv2` messages\na7568772e7 Test: Make sure sampleif.py uses our current Python executable\n9cd0366734 Qt: Add Copy, Save As to Resolved Addresses dialog\n5877ba7fc5 Resolved Addresses: Only show used services\nd34b57d7de Resolved Addresses: Only show hosts that are in the capture file\n64723c6fdc check_tfs.py: show more clearly how to use tfs i.s.o. value_string\n6f38651c3f Fix some spelling errors\n3e877c3ecf Resolved Addresses: Only show ethers actually used in the capture file\nf93fa9d896 GitLab CI: Use the default / stable macOS image\ne5e6e67965 Resolved Addresses: Only show OUI actually used in the capture\n268df12057 doc: Update WSUG for Windows 8.1, Server 2012\n1ca9a8d872 Resolved Addresses: Only show wka actually used in the capture\n0a68875657 TCP: Show the frame in which a PDU is reassembled\ne200051eda manuf: Resolving of MA-M, MA-S, 28 and 36 bit OUIs\n17acb9541e Qt: Use per-interface filters in CompiledFilterOutput\n6409a42f4b Qt: Invalidate the idle dissection timer when clearing packet list\n5256414290 AUTHORS: Change to my email address\n2792c89909 Add \"Use monitor mode on all 802.11 devices if possible\"\n363e0a7447 DNS: Reduce false positives of the DNS heuristic\n8aea8c2156 DNS: fix typo in DNSSEC algorithm name ECDSAP386SHA386 -> ECDSAP384SHA384\n2be3a61834 Qt: Save GeometryStateDialog splitter states\n2f3f879f90 manuf: Remove curly quotes, double angle brackets\n7234ce727b manuf: Update make-manuf for a few more Chinese names\n93591e5ea1 Added Diameter AVPs 6080-6081 to VerizonWireless.xml\nfc0f96477e TECMP: Make ASAM CMP detection backward compatible (Bugfix)\n52c9976bba srt: Show rejection reason name for internal codes.\nd0b08c94d7 Diameter: Fix capitalisation of \"SCEF-Reference-ID-for-Deletion-Ext\"\n1c2093eec8 pcapng: support the if_tsoffset option.\n2cab4226ef GNSS: add dissector for SBAS L1 MT26\nf4883589eb CIP: Update Safety Application Reply handling\n1885540bc0 Glib-compat: adding g_array_binary_search\n958924d17a Qt: Improve DisplayFilterEdit completer selection with mouse\nf9914098f6 Qt: Handle manufacturer names with spaces in Resolved Addresses\n715f817682 capture: Always return the capability hash table\n78383d6784 ZigBee ZCL: fix a memory leak introduced in be881f4 (CID 1558103)\nc3048b3e3e check_tfs.py: use a set for the files to be checked\nbe881f404b Zigbee make the formatting of Zigbee UTC Time more readable and usable\n3b8fb201a0 ieee80211: Fix two issues\n8873aba1a0 Fix parse number of scalability structures in VP9\na8eef49a9e libwiretap: add support for signed integer-valued options.\n14c524a278 Handle the if_fcslen option as having an unsigned 1-byte value.\n10eece14e3 editcap: fix a tpyo in a comment.\n860c3e0ba3 QUIC: Short Header packets can't be coalesced with Initial or 0-RTT\nbd796dd1e7 wiretap: Fix rejecting non-EMS files\n55a1f8b602 BACapp: Update BACnet vendor ID's\n7bc7cd788c USB Audio: Initial control transfers dissection support\n83c94249b4 icmpv6: Make ND_RA_FLAG_RSV the two last bits\n653d79ef09 rdp: add preliminary RDPEAR channel support\nea259b8841 rdp: various fix for the dynamic channel\ne0d86ea198 Qt: Use Qt [save|restore]Geometry for GeometryStateDialog\ncbc2cd039d check_tfs.py: remove unnecessary wrapper\ned91d8ae37 Qt: Add side-by-side layout preference option for Packet Dialog\n34cc9b2e1a ipars: eomtype should not be global\nd27c0adb5a ipars: don't throw an exception under if (tree)\n9969584dae ipars: pinfo is used\n7d732bad8c [Automatic update for 2023-11-26]\nb7d4527bb6 Use prefs_register_dissector_preference()\n2f1392169a prefs: Add prefs_register_dissector_preference()\n92546a4a66 tshark: Don't dissect just because color is requested\n457810c4d8 Qt: Also reset splitter recent values on layout change pref\n52b7ce523a recent: Move new main geometry state to recent_common\n6a6f83abc4 debian: Silence library-not-linked-against-libc Lintian error\na09853ddbd debian: Set target distribution to UNRELEASED\nac3326b4ab debian: Drop the wireshark-dbg package\n1dec9cef99 debian: Merge wireshark-qt to the wireshark package\nf393db6b9c recent: Main maximized is only in recent_common\n699a60b2fd mgcp: Fix a buffer overrun\nd762dd521a Qt: Disable Ok button on invalid range preference\n3b9de4df3d tshark: Cache the interface list\nc62e98c0f5 capture_opts: Don't retrieve the interface list for \"-\"\nf5cc6ebbe5 ui: Make sure to use user-specified interface descriptions\na36ec2a2f0 ui: Move the check for the ex-opt for stdin_descr\n74101e73f5 Qt: Plug leak in ManageInterfaceDialog\n13a9f710eb tshark: Remove a useless call to get_interface_descriptive_name\ne508e9364d Fix some item filters\n8237070fca ui: Have get_interface_descriptive_name take the capture_options\n3381725b71 Zigbee fix incorrect endianness on Smart Energy (SE) Tunnel Close Timeout Value\n4e8603b604 BLF: Implement a mechanism for linear read\n2b18176645 Capture: Fix deserializing single if capabilities on Windows\n39ed3527a5 BLF: Use binary search on log containers\n0837f2015a wustil: Warn about passing NULL string to ws_label_strcpy\n697f37cf2b Capture: Get our capabilities list in one dumpcap call\na8586fde3a gvcp: Don't try to add a NULL string to a column\n8defdda060 Qt: Fix View.. Reset Layout\n1506126169 dfilter: Fix diameter.3GPP-* filters\n2590f82a81 debian: Revert to listing Wireshark Self-made package as the maintainer\n1b4f3f491d debian: Use strict generated shlibs instead of symbols files\n136ca4287d TLS: recognize ech_required alert\n26630c3587 LBAs are zero-based thus one(1) must be added to them.\n29445cbfdf iSCSI Read Capacity\n3852197510 WIP iSCSI Read Capacity fix for Ubuntu failure\n99a9d40601 iSCSI Fix LBAs and display Binary Prefix sizes\nd8b8400c27 TCP: changed \"[TCP segment of a reassembled PDU]\"\n455a21f751 RTCP: Add MCPTT values from TS 24.380 V17.7.0\n120c5cce8d Fixed typo in zcl temp meas cluster\n06d81f7b32 ZBee ZCL Closures: make a function static\n30d0165bbd Try to fix tests on ARM64\ne9de042644 Qt: Remember what monitor we last ran on when maximizing\n1fdb2720b1 Qt: Free the old splitter geometry values when saving new ones\n898ec16857 Qt: Save the main window QSplitter states and restore them\n002b40de89 rdp: fix indentation in file\n6ec01c0583 rdp: various fixes and enhancements\n05accf6c9b Zigbee: Add support of window covering cluster\nc16eaeb014 ENIP: Add TCP/IP Interface service\n2e41f52062 CIP Safety: Improve Analysis\n0d93782443 dumpcap: Serialize machine readable interface caps as JSON\n212cfe132c wsutil: Add wsjson function to get boolean\n3570a9a219 isakmp: update dh_group value_string with RFC8031 and RFC9385\n24e7627fe4 Change some `wmem_packet_scope()` to `pinfo->pool`\n24c0cba235 doc: Mention rpcap fix in release notes\ne425fb606c recent: Remove unused wlan_stats_pane geometry (GTK-only)\nafb03fa515 GVCP: add ASCII (0x02) to Character Set value_string\n69f04acd3d DCERPC: update LSA idl from upstream variant, adds support for new calls\nc3548e3005 manuf: Add back the special case for all zeroes\nff447b1aec Qt: Store active remote hosts in a preference file\n2fa48bbbd5 Make recent remote interfaces a list\nad6947eb71 GNSS: add dissector for EGNOS Message Server (EMS) files\ncea4faac39 GNSS: add wiretap for EGNOS Message Server (EMS) files\n1ae5f9714c Fix extraneous include\ne68689783c lustre: Decode lvm_user_md_v1\nff153d4471 WSUG: Windows and macOS installation updates\n182bf5b835 Qt: Don't pre-populate Remote Interfaces with recent data\nd1699f0c67 Qt: Prevent infinite recursive stack smash in CaptureOptionsDialog\na0fd835e80 F5ethtrailer: add session parameter to file info\nf082e564d2 dfilter: Fixup b72d65302e\nbcc082f1ef Qt: Only call pcap_freecode on success\nb72d65302e dfilter: Fix subtraction with NN-MM\n9c9b270cb1 Remove README.aix and README.hpux\na9b0dc0aa7 ZigBee ZCL: Fix an array bounds check\n3e86238f7e PROFINET: Correctly decode AR APDU status\nc6ad48d3f2 LLDP: Decode more PROFINET subtypes\n2a9bc63325 Remove init of proto variables\ne8e16400d8 tools: Improve match for proto variables\n04e12ad947 CMake: Move wireshark.pc.in\n64b3136321 [Automatic update for 2023-11-19]\n47a4d7f480 GitLab CI: Check help URLs in Commit Check\n2a482336b8 epan: Fix truncation of BASE_OUI labels\n8c22a6cc02 blf: expand a comment.\nfe23a8bdef More item fussing\nb61c0ac536 dissectors: Remove init of hf and ett variable arrays\nf2774d4b5b file-blf: add some sanity checks of length fields.\n90f2fcd329 dissectors: Use gint for ett variables\nd9bd2d2155 GitLab CI: Don't run Lintian\n3e296c041f blf: check the validity of the header length field.\nba5a010f47 synphasor: Remove indent from ett variables\necb295c6dc rdpmt: Rename hf variables\n958131ca10 docs: Alter FollowStreamSection anchor\n5f95a57ff2 docs: Add Time Shift section to WSUG\n49f5bea629 Qt: Don't try to compile capture filters for unknown dlts\n4ae05e6c9f Qt: Fix leaks in CompiledFilterOutput\n2b4c88cb42 Fix saving recently used capture filters\n454bf3f260 netflow: Rename hf variables\nae5c7ff41b blf: add more error checks.\nec915136d9 blf: add some comments to the header.\n855c445d14 Capture Filter Syntax Worker: free BPF program\ne15d167646 wsug: Add interface name to temporary capture file name\n7c9946bdab ncp-sss: Fix header field abbrevs\nd6f158c848 5Co: Fix protocol name in fields\n5c8ba89ef3 bmp: fix peer down RFC9069 TLV parsing\n5a57a8499d dissectors: Rename hf and ett variables\n6e39bcc7fa rdpudp: Fix header field abbrevs\nea85bff16c dcerpc-netlogon: Fix header field abbrevs\n1222d2ec65 tei_management: Fix header field abbrevs\n50585a94bb idn: Fix header field abbrevs\n935df1e875 bitcoin: dissecting segwit transactions (witness fields etc.)\n3fac54aaa8 XML: fix issue about parsing encoding attr when standalone attr exists\n34d9cc68a1 dissectors: Remove init of hf and ett variable arrays\n9e59a18db8 dissectors: Rename expert_field variables\n3b386ed6e6 docs: Temporary capture file format\n656649d033 wiretap: Write MPEG-2 Transport Streams to native format\ne675c13f89 SCSI-SBC: Handle Service Action In limited by allocation length\n07638b0646 RSVD: Handle MS-RSVD TUNNEL_SCSI_RESPONSE spec 7.0-10.0\n25db7cf10b RSVD: Don't create tasks twice, handle responses before requests\nc25e0f9084 Fix overriding capture option prefs at the command line\n9a28224e93 Exporting hex strings: speed up a little by not zeroing temp buffer\n71cec914fe QUIC: Heuristically search for coalesced (e.g. GSO) short header packets\n5d52bc5e10 Mongo: Detect both with and without TLS\nc4b97d1f52 Start to check range_strings\n3bb1c53aaa DHCP: adding Enterprise handle in Opt 124 Vendor Class\n17b30b2e9a h265: Remove unused comments in hf variables\nc1c8a04db4 TCP, UDP: fix formatting for zero-padded partial checksums\n200a52616d NGAP: add dissection of n2MbsSmInfo media type payload\n5233a55fdf A few more item warning fixes\na2e90a6557 Qt: Update correct row in Advanced preferences\nbee7b2cb8e Qt: Fix Recent Files Max Count at startup\n8988d21d26 Qt: Use qstring_strdup in more places\nb40c7d6c8a LIX2: Update to 3GPP TS 33.128 V18.5.0\n6360ddacb3 LI5G: lift dissector to ETSI TS 103 221-2 V1.6.1\ne1fdc2224a tshark: -U must be one of the export PDU taps\n304868dcf6 capture_file_dialog: update a comment.\n81edda6c32 http: clean up some issues with the Load Distribution statistics.\nd48e0a75cc Fix (or disable) more dissector item warnings\n7b550c21d4 docs: Add wsug chapter on 802.11 Decryption Keys, link UAT help\nfb3e2bf984 Qt: Add an option to show changed preferences\n7cd82a923c GitLab CI: Copy our Debian packages instead of moving them\n6ce97e418b Docs: Move attributes.adoc to the doc directory\na0839b6e5e dot11decrypt: Fix bits number\n09e9b352d0 dot11decrypt: Explain why key parsing failed\n7a82a9707c Make the code that handles the file open dialog style common code.\n46a97fe111 More fixes when converting display macro configuration\n22c6a8f0d4 RF4CE: protect against an out of bounds copy\n3fa9915a1a Debian: Update our symbols\n91465bcb8b Qt: Fix display filter macros when switching profiles\n24570a3573 dot11decrypt: Don't keep copying and converting strings and bytes\n2cbed520a2 Qt: define QProcess::splitCommand for older Qt 5 versions\n8ca602f6e7 Fix (or ignore) more consecutive item filters\n0f7edbcd4e Packaging: Fix our WiX DLLs\nb553202875 WSUG: Update Display Filter Macro documentation\nb0ae205c51 dot11decrypt: Percent-decode WPA passphrase in parse_key_string\n774d5b2175 DHCPv6: Add option 79 handling (Client Link-Layer Address)\n58b3d0163f Windows: Update libsmi\nb64a54b43b Windows: Make sure we ship our minizip DLL\n487dfc8743 [Automatic update for 2023-11-12]\ndf2e0b7d61 Qt: add command line options support in the TLS Keylog Launcher\nfee9fb26e8 Zigbee: add support for NWK verified frame counter flag in security header\n90b1a157dc dot11decrypt: Fix setting log domain\n7ab4bbb9d0 Qt: DisplayFilter left align buttons\n814dc49d61 Qt: More missing ApplicationPaletteChange event workarounds\n7b726e3f6e Qt: Change button style in FilterExpressionFrame\nccfc06c25e Resources: Update AppStream metadata to the latest format\n12f6d8df8d BLF: Set the name of the STATUS interfaces from channels XML too\nbe3d45fcb0 BLF: Extract channels and ports names from AppText Metadata XML\n19f7e572a4 Work around macOS running applications in /.\n12b015d1c4 SNMP: Add prettification for DateAndTime in the other branch\n4e7b1b611a Fix possible overrun in radius dictionary parsing\nd6912ddf1d Qt: Fix header name for Display Filter Macro Dialog\n3ddad3fcae GitLab CI: Run lintian after we've created our artifacts\ncf5811140d isdn-sup: Properly register dissectors\n84141d45c2 TCP, UDP: Calculate partial (pseudo header) checksums for offload\ncb21172447 HTTP3: Guarantee unique offsets for the header data\n3498469956 HTTP3: Fix field highlights\n36a9f4231b Qt: Update styleSheet in AccordionFrame\n44454184f5 Remove unneeded includes of \"ui/last_open_dir.h\".\na1467a8ce2 Minor corrections to release notes\nca78434471 Add a newline at the end of the last line.\n3b08042a4e Remove README.windows.\n88ce30d51b RF4CE: NULL dereferences in packet-rf4ce_secur.c\na5e0be51df Windows: Upgrade Minizip to 1.3\ncefcf0ac02 Windows: Upgrade c-ares to 1.19.1\n5550ec4b69 Qt: Update ComboBox in updateStyleSheet()\nd139a97067 Fix some spelling errors\n20a98a485c doc: Add hard line break between secrets types in editcap man page\n17d129b903 Qt: Update styleSheet on ApplicationPaletteChange event\n0520153cb5 UAT: Fix a Coverity warning\n4365250098 dfilter: Add back unparsed syntax type\n85f0a53f77 dfilter: Fix an error message\nadfbd315b6 GitHub CI: Use the latest version of macOS\n625c1a5ded GitLab CI: Always publish our Debian Stable APT Package artifacts\n0b69bfcafa ANSI-MAP: Add parameters to the OriginationRequest SET\n5eea10e4e4 GSM SIM: fix dissection of READ / UPDATE BINARY commands\n7161431cec Qt: Use QLineEdit border only on macOS\n92753cb401 pfcp: correction of Outer Header IE bitshift\nb34ec48b1e Ethernet, PRP: Convert PRP to trailer dissector\n4ebb6e9893 tshark: Escape delimiter separated value in compliant ways\n85262b5a89 ISO15765: Fix error in dissection of STmin\n3d79f131e8 Fix AVP decryption in Radius dissector\n4fcceef21c Qt: Remove PINOs from Enabled Protocols dialog\na9c1fa3a68 bmp: version 4 capacility expert info fix\nbdaae9ddef Qt: Add QLineEdit border in AccordionFrame\nb2f5ac5123 Qt: Change InterfaceToolbarLineEdit border color\n3ab45fe831 GitLab CI: Make our Debian symbols downloadable\ncd757e0c16 Qt: Add macro name validator\n3e8e39061f Qt: Remove an errant tr()\nbc528a344e Fix some more copy/pasted filters\n4d23680d25 Qt: Reduce the spacing between the two rows of the search frame\n7d87367e22 dfilter: Add a function-like macro syntax\nc568589189 Qt: SyntaxLineEdit state-icon top position\nc6af671324 dfilter: Add macro check\n9ae752109c dftest: Add option to dump macros\nbc64efa538 dfilter: Replace macro UAT config file and update GUI\n4205d41163 TCP: Don't export PDUs that are desegmented in a later frame\nd93cbe28f6 Qt: Add InterfaceToolbarLineEdit border\n5880b2195e Qt: Fix Export Packet Dissections Help button, connections on non-Windows\n398ef5f09b Use case-insensitive capture filter match\n177cc29ea6 wsutil: Make filter lists dynamic and on-demand\ncdd2d1902a tests: Use fixture for dftest command\n99a7079bc0 sharkd: Fix displayed delta times in \"frames\" method\n9daf31cc10 Infiniband dissector: Fix typo in comment of parse_DCCETH()\n186e6512f9 Infiniband dissector: Enable to parse ATOMIC Write operation packets\n472de027ea Infiniband dissector: Enable to parse FLUSH operation packets\nf85da38c5a Infiniband dissector: Add definitions of FLUSH and ATOMIC Write\nb7cc44eb34 epan: Convert uat.h indentation to 4-space\nf4301d5113 dfilter: Remove an assertion\n5113423596 dfilter: Reformat switch code style\na1dd95456c dftest: Enable flex/lemon debugging with -D\n1e532ee7c3 UAT: Add uat_destroy()\need96b41fb Add support for comments in cfilters/dfilters\n26785e7394 Remove support for deprecated \"filters\" configuration file\n0deeb8caf1 SMB2: dissect SMB2_FS_POSIX_INFO info level\n4d294c0b73 epan: Prepare dissectors for initialize static values to 0\n5cedcc970b plugins: Initialize static proto values to 0\neb4eeb07ca epan: Initialize static proto values to 0\n309a47997e tools: Initialize static proto values\nb5644e111a Qt: Add DSBs info to capture file properties\n40219156f9 GTPv2: Add SCEF Reference Id Ext to Monitoring Event Extended\n29090f6236 tests: Use tmp_path pytest fixture to create home dir\n29ec73de9a UAT: Remove unused boolean field \"from_global\"\n5fe1dcab27 GTPv2: comment an unused hf entry\nce2822a2c4 GTPv2: remove a trailing : in a field description\n5a6ebf213e GTPv2: Add SCEF Reference ID Ext to monitor event\ne973c15aaa GitLab CI: Fix the Commit Check job for external projects\n434f378500 GitLab CI: Fix a couple of paths\n7d0025eaea GitLab CI: Run `tshark --version` in a few places\n817e7c01cf ISO15765: Remove the duplicated text in the \"Information\" column\n6a1015061b macsec: Calculate FCS correctly for short frames\ndc6113083e dfilter: Check function name for validity\nd967ce3605 dfilter: Fix scanner for protocol names starting with digit\nd661136b77 GitLab CI: Conditionally install the GitLab CLI (glab)\n3c410aa9be bmp: add support for draft-ietf-grow-bmp-tlv-13\n841d8e9b49 [Automatic update for 2023-11-05]\nf821b03d5e macos-setup: work around problem with the Xcode 15 linker.\n6a514b62c5 HomePNA: Also set the length of the proto item when short\n8bffe8954e WebSocket: Make the max unmasked payload length configurale\n6646a33a54 Thrift: Update field_id in all sub-dissector functions.\nac72413cdd IEEE1905: cleanup dissector\nea60ff33e2 AVSP: Fix FCS calculation\n426e26f11a mikey: Skip unknown payload types\n4b6438ee36 OpenFlow(v1): Add Actions to FLOW_MOD\n6fcb86615d HomePNA: Fix FCS calculation when there is no piggybacked payload\n743a9b3b0e SMB2: add SMB2_FILE_LINK_INFO\n1646b2a3be SMB2: fix dissecting device number\n79aec8b002 SMB2: fix order of file size and allocation size in SMB3 POSIX info\n19de076fed iperf(2): fix conflict for display filter name\nfa3836a57c Detect more copy/pasted filters - looking further back\n9433d37731 GitLab CI: Make sure GITLAB_TOKEN is set in the Commit Check job\n0f38e1662f rsvp: Add missing hf for exclude route\n28dfc3eae1 TNS: Handle connect data in subsequent packet and data descriptor type\ndac5a920ab coap/tls: Remove SSL_COMMON_LIST_T proto init\n82015a0a88 LDAP: val_to_str() format string has double %\n40ea13a17d RF4CE: remove two useless local variables\n140132d0ab HTTP3: fix web-transport\n0969229bbf ICMPv6: Improve Option 21 PvD ID\n62d45fcc7c WLAN: Fix header field registrations using 0 rather than NULL\naecba1f68b gitignore: Fix our Vim swap file pattern\ne3642264fa RTPproxy: fix an unaligned access reported by UBSan\nd1f64e9cbb SMB2: prevent calling wmem_array_append() without a valid pointer\nce1b766a95 per: Fix check for extension addition group\nf6d51ddc6f Add Message-Authenticator validation to the radius dissector\n77ea80001e OPA MAD: fix unaligned access introduced in 036f2e12\n9c36381961 RF4CE: Fix illegal memory accesses\nc27483bf7d zigbee-direct: rename time variable for avoid checkAPI warnings\n4350dac99f HTTP: Fix chunking detection for certain request methods\n3d8da75ba9 Qt: Fix show bytes as image typo\n2cac1ca9e0 asn2wrs: Update to not initialize static proto values\n660cefa708 PNIO: clean up the title and description of the GSD folder path preference.\n4035dfa94d GitLab CI: Repository and error handling fixups\n7d0b92aa0e Initialize static proto values to 0\n520f0d8e26 Qt: Enforce Minimum Qt version 5.11\n8fc6ea3229 opcua: fix CID 1548379\nf17f629870 fix return value of decrypt_opcua if decryption fails\na84dc083c3 ISAKMP: Update value strings from IANA registry.\n04335b02d7 GitLab CI: Update some commit check result text\n74dce085af Infiniband dissector: Fix output format of 'Unknown OpCode' packets\n491857ae7e dfilter: Elide branch jumps to next instruction\n5a4d883f85 dfilter: Fix crash with nested function calls\ne0cafce263 BusMirroring: Add brief introduction of the protocol\n3f51655358 BusMirroring: Add the dissection of FlexRay frame\nafdbc17b96 capinfos: Fix count of IP address and decryption secrets\na3fd4fd25b pcapng: convert FCS lengths between bytes and bits.\nc9d41e2641 Revert \"sttype-op(dfilter): fix Dead initialization\"\nb40931cd17 dfilter: Print function argument types for constants\n27e8c8ebde FindPCAP: mystery solved!\naf91d78a54 macos-setup: don't build GLib tests, to work around a bug.\nec001766f6 WSLua DissectorTable GUID Support\n14a934fb22 GitLab CI: More rules updates\ne9c7326d9c macos-setup: update to zstd 1.5.5. [skip ci]\n1b634a3a8b GitLab CI: Print more CI variables and update job rules\n9be8dc83ad RF4CE: Improving dissector heuristic\ne50ffe7cb1 ICMPv6: Add Option 21 PvD ID\n53876ae73b GitLab CI: Show a commit log when we have multiple commits\n7733526e0a ENIP/CIP-I/O: Use CIP-I/O as protocol name for CIP-I/O\n3173400167 addr_resolv: Remove confusing \"only use profile hosts\" preference\n7ac827fd74 LAPD: Set address AT_STRINGZ\nf051e97906 Fix Dead initialization found by Clang Analyzer\nacdee88430 sttype-op(dfilter): fix Dead initialization\nfa99fe81cc GitLab CI: Add plumbing for merge request feedback\n4cf6568b2e Qt: fix handling display filter dialog TFS NULL value\n347fa8a8a1 tshark: fix memory leak when printing an IPv4 address\nde43cc7eee WSUG: Mention the at operator and field references\n276fb25e61 ISOBUS: Remove incomplete warning and cleanup\n0ee04d759f GTP: add dissection of RIM Routing Address IE\n4d71744d84 uat: Small comment update about update callbacks\n1484169815 prefs: GUI preferences don't affect dissection\n3b09f561f2 opcua: add more comments\n308336a05d opcua: add sanity check in keylog parser\n9f17196a9d opcua: add lost sig_len parsing due to rebasing\n2e835dc2c2 opcua: add encrypted capture file with embedded keys\ndf8b016ea8 opcua: make strtok_r compatible with MSVC\n3c9e7bc58b opcua: implement loading keylog file from pcapng embedded DSB\n36e7c60c50 epan: export secrets_register_type to be useable in plugins.\n8f3fc34a0c editcap: add new SECRETS_TYPE_OPCUA\nca8594cc55 JSON: Shorten the name of JSON in INFO column\n5789bc7977 Use C99 instead of GLib types in doc+docbook\n47b310da47 GTP, GTPv2: use wmem_maps instead of GHashTables\n5f3ed0670e QUIC: Add a null check\n7fc8ed84d8 Qt: Unmark field when not found in a Byte View\nd1f81f131e Alias my old email address in mailmap\ne9b8349c14 ORAN FH CUS: Fix up ext 6 handling\n6affa937f3 epan: Fix display filter macro post update\na913c2a334 Apply 1 suggestion(s) to 1 file(s)\n8eceea5315 Apply 3 suggestion(s) to 1 file(s)\ne240a45454 RTP ED137 Improve dissection with req/rsp and text in info column\n5d7a0c149a NSIS: Make a bunch of sections hidden / mandatory\n2dc3887a3b INAP: Fix dissection of local code in ExtensionField\n9b62ec029e dfilter: Fix slices with byte references\n1dd58a0559 ISOBUS: change to value_string_ext for faster lookup\n0256c588a7 UDS: change to value_string_ext for faster lookup\n946f1fd1a4 OSPF: Fix offset for dissect_ospf_lsa_opaque_ri\n133f6594ad Qt: Fix address editor leak\n9765f8575c wsutil: Rename inet_netw.[ch]\nb9667fa9ce tcp: TCP Segment Len is not found in the packet bytes\n0cf6471f68 epan: Move tvbuff functions to tvbuff.c\na178ec8a38 wsutil: Move and consolidate CIDR code\n0509398c4f wsutil: Consolidate IP address code\n1c0f9cd3ae IPv6: Move IPv6 header definitions to epan/dissectors\n3ebeda8dd9 QUIC: Support testing if the QUIC bit can be greased (RFC 9287)\ndee60892fc Qt: Rename the Browser SSL Keylog dialog to SSL Keylog Launcher\n47ee58bf26 rf4ce: make a couple of symbols static\n49f39be301 dfilter: Add IP address plugin\n96f0f487d7 IANA IP Registry: More API refactoring\n813be7fe50 dfilter: Allow writing references without curly braces\ndb49708b17 bitcoin: implemented parsing of missing service flags\ndec1748f90 AUTOSAR IPDUM: Adding macros to header file\n0e1945d4b7 ISOBUS: Adding support for Signal PDU dissection\n8bbec5cc54 SOMEIP: Add macros to header and clean up\nd0aa502d06 BLF: Give a different message for known but unsupported object types\ncd2eea19b1 BLF: Add support for BLF_OBJTYPE_ETHERNET_PHY_STATE\ndcc7ab3cea BLF: Add support for BLF_OBJTYPE_LIN_SND_ERROR and BLF_OBJTYPE_LIN_SND_ERROR2\nc0f287ad69 BLF: Extract FDF, BRS and ESI flags\n6db83ce7eb BLF: BLF_OBJTYPE_ETHERNET_STATUS: Add new field 'linkUpDuration'\n2bff692d10 Add support for BLF_OBJTYPE_LIN_CRC_ERROR and BLF_OBJTYPE_LIN_CRC_ERROR2\nc6c87a4abd BLF: Add support for BLF_OBJTYPE_CAN_OVERLOAD\n91acc78466 BLF: Add support for BLF_OBJTYPE_LIN_MESSAGE2\n8b631bf23f radiotap: Improve indication of 6 GHz band channels\n2adc59ff92 Prefs: Fix TCP sequence analysis override pref handling\nd300f30469 cmake: work around a mysterious macOS dyld problem.\n6f4a9a9c92 Debian: Add missing symbols\ne99a97f14a QUIC: add support of multipath draft06\nb2def83df6 UDS: Fix error in dissection of \"Sub Function\"\nc18aecc063 Exported PDU: Add new tag EXP_PDU_TAG_USER_DATA_PDU\n9bd3965603 NSIS: Save our installation directory in the registry\n233d97b69a netscreen2dump: drop support for netscreen2dump.py\nfce1d98daf make-taps: compatible with Python 3.12\nc51587af21 BLF: Fix relative timestamp\n9752f1dd16 Tools: Clean up the lists in rpm-setup\n726466ea4f epan: Use available space for FT_BYTES labels\n42442281f7 nr-rrc: lookup UE ID from MAC,RLC,PDCP (in order)\n0d941ce280 make-authors-csv: compatible with Python 3.12\nd5eded157a ieee80211-radiotap: Remove undefined S1G NDP and indent update\n35da15174b QUIC: Update to ACK Frequency draft07\nc9b1866ca0 BLF: Fix compiler warning\n4e0494e654 epan: When exporting packets as C Arrays, use C++ comments\n8f28a0e9f3 plugins: Make flags unsigned\n6f5fd697d9 [Automatic update for 2023-10-29]\n24c8d79d53 bitcoin: implemented dissecting `sendcmpct` messages\n904cad5297 Fix some spelling errors\ne12c89f3ca IPv4: Fix wrong endianness displaying source/dest addresses\nca392f6ddc wsutil/to_str: Deprecate ip_to_str() for endian-explicit versions\n1c2cf8064a Qt: Make Edit Name Resolution combobox size adjust to contents\n41be4c8cf7 ZigBee: Fix decryption of first APS packet\n0ea6bbb9e3 RF4CE: Fix illegal memory accesses\n0ba993c81f Qt: Update address editor for FT_IPv4 changes\nc88e3b332e bitcoin: parsing `feefilter` messages\n5aec5b6046 Debian: Add missing symbols\n250474a738 GitLab CI: Fix our Windows release info paths\ned482b263f GitLab CI: Add Windows package release info\nde0be93e1e Tools: Fix the version file version\nfa1be49d40 GitLab CI+tools: Switch to a raw version file\ncd0b1be8da prefs: TCP override pref check field flags\n0da43f2d42 HTTP3: dissect control stream, various display improvements\n3beeba3161 HTTP3: fix nghttp3_qpack_stream_context_new memleak on error path\neabe5e268a dfilter: Refactor initialization and registration of functions\ndb99904eea Qt: Include functions in display filter completions\nf46b9b1b40 RTP: Indicate when padding is bogus\n919eb1c53f GitLab CI+tools: Add version environment files\ne15d826b53 Qt: Fix leak in prefs\nea3bdb9eaf [RF4CE] Applying code review suggestions\nf975adc436 [RF4CE] Applying code review suggestions\n38b6c7cd0a [RF4CE] Added RF4CE protocols to release notes\n63f90e34a8 [RF4CE] Fixing CI issue\nf413a2da88 [RF4CE] Fixes after code review\n46e0b5f168 [RF4CE] Fixing trailing white spaces\n5bc1f9d07f RF4CE: add RF4CE protocol dissector\n6fec850f62 dfilter: Install plugin headers\n1a8e1b1466 Use explicit test for Clang with compiler attributes\n0d46d9a60a ftypes: Add IPv4 setter/getter\ne9c3747488 Qt: remove use of qAsConst which is deprecated in Qt 6.6\n33b66952ac opcua: fix parsing of service payload for messages without payload\n06b7217fd0 CMake: Have the docs target depend on the manpages target\n7e351192e2 bitcoin: handling `sendaddrv2`, `sendheaders` and `wtxidrelay` commands\ne583fcd9f3 Infiniband dissector: Fix inaccurate comments in the header\n5fa851911e TLS: add SNI to Info column, display common extensions up in the tree\n4846ecdade Qt: Fix our \"Go To\" menu connections\n60a9e1124b Find: Matching multiple occurrences in Packet Bytes\na6f3e61d70 wsutil: Add a reverse mempbrk function\n0cec46bb25 wsutil: Add a memrchr implementation\n6c424b610d TLS: Change wmem_packet_scope() to pinfo->pool\n44c2af8d62 Added ERF FlowID Hash Type inner bit\n8aaef0e515 Qt: Check if focusWidget() is nullptr when setting previous focus\nb02fb85020 More item check fixes\n04b86acbb2 ISOBUS: make a couple of functions static\nbaa9f5b249 rdp: fix segfaults when decoding egfx packets\n4a3472b9d4 rdp: parse redirected authentication flag in nego request\nadaacddc48 opcua: add decryption support\n32ed5eac61 doc: Fix the description of the \"Raw\" Follow Stream mode\n112733d39b OER: Support signed field for unconstrained INTEGER\n4212131392 BusMirroring: Add validation for data length legality\n1f70205c58 BusMirroring: Add the basic implementation of dissector\n59ae57050c Diameter: Add missing AVPs and update AVP names\ndbfbfb608c TLS: extend support for more SupportedGroups and SignatureAlgs\ne5b4007d05 macos-setup: Update GLib to 2.76.6\nb558c5c2e6 ISOBUS: Improving the dissector\nd99efed280 dfilter: Add display filter plugins\n41e8d5a9b3 dfilter: Add WS_DLL_PUBLIC to more functions\n7fbed5b306 plugins: Allow multiple types in description\n061eea1c37 GitLab CI: Use PowerShell's Get-FileHash\n1e5a2f16d4 bitcoin: added 5 missing `inv_types` (for `inv` and `getdata`)\n953a52f040 pgsql: backend msg parse fail\ne6215e7db0 IANA IP Registry: Use binary search\nc2ace8931c Qt: Follow Stream stream and substream spinboxes keyboard handling\n5f2bff0c45 Qt: Fix resetting follow tap when the filter changes\nd44e9d3b4c IPv6: Add special-purpose block flags\nc37d10383d IPv6: Make the \"show address detail\" preference default enabled\n9a0e4a7980 IPv6: Improve some address labels\n75f50ad622 IEEE 1722: Fix unitialized can_info\nd917fa693e Qt: Fix Qt5 and Clang\n670176726d Translation(qt): Add Korean translation\na35aa997ad RTPS: string dissection, unicode improvements\ne21f61ed70 Falco bridge: Plugin fixups\ne9e891da14 Qt: Use std::move in follow stream\nea5f48aa93 Fixups to IANA IP special purpose registry\n799ae75010 dfilter: Refactor function semantic check\n47746f0316 dfilter: Minor cleanup\n5609c77144 dfilter: Allow testing for nonzero function result\nebbd6439c9 dfilter: Fixup e2a3acefe9\n3b63098fb1 mergecap: prevent appending to an input file\ne2a3acefe9 dfilter: Use a constant to declare function return type\n4a377d49ff IPv6: Use IANA IP special purpose registry API\nb82b32fdd7 Add IPv4/IPv6 IANA special purpose registry as generated data\n29decd00bd BLF: Show comment, attachment and traceline in info column\n3d9376499d BLF: Remove AppText minimum length\n30ec1dc396 BLF: Add support for BLF_OBJTYPE_APP_TEXT Metadata segmentation\n845507e98a Update Pinfo.port_type tests now that it's writeable\n4b0281310c Allow writing of PInfo.port_type in lua\n4d27035fa6 Add option to copy bytes as Go literal\nfb21b775b0 BLF: Fix CAN usage of payload_length and payload_length_valid\nda835213e9 BLF: CAN_MESSAGE: Remove payload length check since the size is fixed\n3d94fceccd BLF: Fix CAN parsing\nc50c2f63aa TLS: remove tls13_cipher_create()\ne427db11ff ED137: Fix additional feature dissection\n13e73a6bf6 RTPS: Added fields init_vector_suffix and session_id\n62375e61c6 Qt: Remove obsolete comment about GTK+ follow\n56200e40f5 Follow: Use common follow_reset_stream\n3a50b6dac7 Qt: Remove unused member from follow\nfcee2a36d2 mac-nr: add mac-nr-framed protocol\na0edd523b4 capture-wpcap.c: fix typo, move a #include.\n9375a43d48 dumpcap: recommend upgrading Npcap for promiscuous-mode errors.\n63b08c9850 Qt: Move addText to FollowStreamText\nd16f0271a7 Falco bridge: Minor fixes\n0bc3f1c89d Qt: Minor follow stream optimizations\n36391da1b2 Qt: Fixup application bundle paths on macOS\n99ebe90e89 macos-setup.sh: fix build of latest libgcrypt. [skip ci]\n619ce9fbc5 XML: Add UDP port range pref, set 3702 (WS-Discovery)\nf49f9c0020 Diameter: add support for SCEF Extended Reference IDs\nf1339763f9 Qt: Improve FollowStreamText scroll performance\n7f7e153100 TECMP: Fixing length of CAN payload (BUGFIX)\nc86a85022d dfilter: Add \"bitand\" as an alternative operator keyword\n1ee70cf25f dfilter: Fix failed assertion with time arithmetic\n21a3ba0bf2 dfilter: Compute more compile-time constant arithmetic\n33cd0c0f06 ieee80211: Update the naming of description and display filter\n61696e68d4 Thrift: Multiple fixes in compact protocol\n8d630d43e7 dfilter: Add back check for division by zero\n1af4b495f2 dfilter: Use better assertions for invalid enums\n128472b007 Windows: upgrade Npcap to 1.78\nbc1b7c281c Packaging: Make sure we ship our PCRE DLL\n6b1b8fb33c [Automatic update for 2023-10-22]\n9be24e6c86 wsutil: wmem_strjoinv behavior on empty array\n899002e8d8 dftest: Use debug level instead of on/off\nb86a14be4a dfilter: Fix a compiler warning [-Wmaybe-uninitialized]\n356b3ed6c9 dfilter: Add time multiplication by scalar floats\n96932fe305 dfilter: Fix an error parsing byte strings\n881dec9b90 dfilter: Add number lexical type\nec669afcbb dfilter: Add time multiplication by scalar integers\n8710ec9cf1 dfilter: Rewrite if-else block using a switch\n3f24475b8c TLS: improve visualization of Token Binding estension\n6fddc23021 Docs+tools: Remove GPLv3 with Bison from the allowed license list\nbde3da4445 BLF: Fix BLF_OBJTYPE_ETHERNET_STATUS\n18b5564537 Docs: Move the FAQ to the doc directory\n3aedd8751f VNC: Remove globals\n0a2a388d32 epan: Fix NTP time encoding edge case\n48cd7f9284 TLS: JA4 fix non printable ALPN values\ne1455bc55d USB-COM: make some functions static\n0156b04d75 Logray: Add some global profiles\nd27f9e6ac5 Falco bridge: Make sure we have a valid syscall source name\nc6b1d97a06 nettrace_3gpp_32_423: Timestamp wrongly calculated.\n95159bbcdd Fix some spelling errors\ndfddf5a557 macos-setup: Update libgcrypt\n7bf7a13676 BLF: Fix LIN parsing\n666a4f7f09 DHCP: Fix offset for SIP Server (option 120)\nfa5f0a1264 Re-run pidl after upstream samba samr.idl changes\n4ee9d4ee15 Add lsa_BinaryString from samba upstream lsa.idl\n800831cab2 Fixup vcpkg-export-20231017-1\n652b6b186f Add vcpkg-export-20231017-1\n938111c587 BLF: Fix memory leak\nf5a4548ddd BLF: Fix BLF_APPTEXT_METADATA and BLF_APPTEXT_COMMENT\n55f57b73a6 Sysdig: Use libsinsp for native syscalls\nc542f6aa3a MAC-NR: Fix handling of RedCap UL CCCH SDUs\n4bf4b0b68c Translation: Update to transifex APIv3\na274d763df GitLab CI: Switch the openSUSE builds to 15.5\n2799ca5485 macos-setup: Don't try to install too old versions\n3bb57caa99 macos-setup: We require Qt 5.10, hence macOS 10.11\n3d4689d819 gnutls: Set FIPS mode to lax if enabled\nc3fefcc537 GitLab CI: Print our CI variables\nd53abf8c7e PFCP: Wrong length used for TEID\n7595fc7b01 Revert \"plugins: Do not require a \"type\" subfolder hierarchy\"\nb0b6428471 ieee80211: Add different display filter for each WMM AC\n21c6892d2a vmware-hb: Update build number\nc2f98ec895 vmware-hb: fix display filter name\n0d5be1eb42 Nettrace: add handle of both NAS-EPS and NAS-5GS\n0382c7785b nettrace_3gpp_32_423: Offset for msg advanced twice.\n1419acc886 wslog: Add WS_NOT_IMPLEMENTED() macro\n4c3b5db000 dfilter: Improve type inferrence for constant values\n311dacfe8e macos-setup: use compile options for libpcre and zstd. [skip ci]\nb97e94627c macos-setup: fix a comment. [skip ci]\n9605f3d3f4 USB: Differentiate IN and OUT endpoints\nda7b7c81de USBLL: Call USB dissector after USBLL address is set\nc21e23722c USB CDC: Add follow USB CDC Data stream\n861a3eef63 Qt: Edit capture comments in separate dialog\n988635fd26 VMware HeartBeat: Enhance dissection\n0a58117fed Frame: dissector table for PcapNG custom blocks\n65d035d1bb ieee80211: Add dissection of ETAG FILS Request Parameter\n09dc64dfdd MAC-NR:Handle the length off all UL lcid.\n3be1c99180 netscreen: do bounds checking for each byte of packet data.\nc5d9aa2812 Windows: Upgrade to nghttp3 1.0.0\n2cc9d615e9 plugins: Add back a (flexible) folder type hierarchy\n14fbc968f7 BLF: Fix memory leak for interface name\nbb293845dc androiddoc: Update man page\n968483728f androiddump: support capture filter\nb89bee479a Windows: Upgrade to nghttp2 1.57.0\nb227c21dce tls-utils: Make a value_string static\n1d123c46cb blf: Use WTAP_ENCAP_NONE, record linktypes must match interface linktype\n390b5e3fd9 MAC-NR: Handle RedCap CCCH SDUs (length and which RRC dissector to call)\nc7d0e02b49 plugins: Optimize directory scanning\n95340cfdc1 TLS: add JA4 TLS client fingerprinting\n067dce3fdf BTatt: add value to time related items\nc108e75142 BTatt: factor out timestamp code\nf15c7ee135 http3: Don't point to file scoped memory after leaving the scope\nb2a9654292 mac-nr: Make defines and value strings for LCID values.\n3489952a81 Make `grep proto_register_protocol` more useful\nadb4f1d91b CI,Tools: auto-enable Homebrew updates in CI, remove brew doctor\neca88da1c5 HTTP3: remove nghttp3 min version, update setup scripts\n19fd8b7e81 nghttp3: Add runtime version information, if present\nb42cd0df29 Fix some more item-related warnings (check_typed_item_calls.py)\nf59981450d Lua context commands: only populate for single frame selection\n4d51ce86d7 Docs: Simplify our man page markup\n83b56c3b55 [Automatic update for 2023-10-15]\nf1f6c1369d Don't use frames without timestamp for delta time calculations\n8da773da7a Qt: Move section comments to the section area\n64937eb552 merge: Add merge comment\na4b6cd460d Qt: Display all the section comments in Capture File Properties\nd9bd00a22f HTTP3: fix ASAN stack-use-after-return error\n6c185f2773 Qt: Fix leaks of interfaces in Capture File Properties\na4527fa041 btmesh: Reintroduce column info fix\n5c420697d6 tshark: Support --read-file and filter long opts\n3a636f339f Update for HiPerConTracer 2.0 to also decode HiPerConTracer over UDP and TCP.\n669d47119b Tools: Add an install-test-deps option to macos-setup-brew\n25f263b5cc Tools: Clean up the lists in debian-setup\n924a8a5420 Tools: Various macos-setup-brew updates\n2a5639984d ftype: Clean up IPv6 interface\nefa009878c ftypes: Rename comparison methods\n4241589159 cmake: Sort source files alphabetical\n28bc2c1536 github: fix macos workflow.\n66df826c47 wireguard: Handle unexpected inability to decrypt due to FIPS mode\n6b0197da07 http: Only allocate server address for upgrade once\n8a422b5d02 docs: Make version option handling consistent\n38d05ad97a output of the own (lua-)dissector as root-tree element\nf8cd3046fc SSH: make ssh_get_message() static\n52d4bff808 EVS: Fix a couple of value_string labels\n3f850e3d8a Fix Wi-SUN LFNVER-IE display\n50f322ec17 update column before calling subdissector\nd3fab19401 btmesh: the pinfo column of the own (lua-)dissector was overwritten by the packet-btmesh.c dissector\n1a25bcb0c0 doc: Man page minor grammar fix\n35ac9c43c9 json: Add JSON objects as FT_STRING with no display value\nf36039c003 Q933: Bring some value_string values into range\nb0d2087e4f OSPF: Support for draft-ietf-ospf-shortcut-abr-02\n4deb4c6e4c wsutil: Rename ws_strcasestr to ws_ascii_strcasestr\nf0df148413 wsutil: Do not use built in strcasestr\nd5492abc89 gcrypt: Disable FIPS mode if possible\ndf2f966d15 wireguard: Get rid of some redundant log warning text\ne20dd41824 websocket: Support port dissector table for Decode As and Heuristics\n33655a9266 Move our Falco plugin directories\n63287fb104 BTatt: factor out common code\n20ae161ac5 wslog: Omit the file/line/func with ws_info()\n73f23af063 NGAP: Improve with display Sub-Cause in Info\nef836e9afe plugins: Do not require a \"type\" subfolder hierarchy\n8bdf5d7906 wmem_list: increment count for insert_sorted\n31e99747e3 epan: Allow BASE_NO_DISPLAY_VALUE for string-like field types\na2eeea6391 wiretap: set WS_LOG_DOMAIN to LOG_DOMAIN_WIRETAP if wslog.h is used.\n135b364609 wiretap: don't include wslog.h if you don't use anything from it.\n3c3c640cba Add wiretap log domain to wiretap/blf\n9b1726f062 IEEE1609dot2: Clean up the asn1 files.\nadbc9d58f9 NGAP: add Cause in Info column\n19301a5489 mdb: start dissecting comms gw reports\nb9dfdd9086 CMake: Fix a target name\n0fd3aa76b7 ssh: reassembly of channel data\n51cd935af2 TLS, DNS: add dissection of Encrypted Client Hello\nd81d6b859f mdb: dissect peripheral id response\n1ca628d595 mdb: start dissecting comms gw expansion\n31dbbcaf95 r09 (trivial): fix some typos\n8b751c0463 r09: use proto_tree_add_item for bcd fields\n97254d7dd7 Docs: Add \"Staying Current\" to the packaging section\nd362623957 x75: clean up string handling, fix fuzzer warnings\na21ec18678 asn2wrs: Handle c-style comments by removing them in preparse state.\n49b75e003f BTatt: fix indentation of two dissectors\nb69cd1333c SSH: Set up channel pairings properly\nf2d2384876 BLF: create Ethernet Interface IDs based on channel and hwchannel\nb3f8d12795 ftypes: Use 64-bit integers only internally\n64bba16c80 dftest: Show types with -d\nc22dd98eae Qt: Remove a separator from the Help menu\nf8b0e232af Windows: upgrade Npcap to 1.77\n433e4f3f72 [Automatic update for 2023-10-08]\nae3b2033e4 sctp tap: Fix copying checksum string\neb5516d1d3 ssh: Enable DH Group Exchange\n50a4840696 Qt: Normalize SCTP dialogs\n0bed6790c3 BLF: Fix Ethernet Status Filter\n61f77a175a Tools: Have update-appdata.py print release information\n310668173c mdb: dissect comms gw config\n33ed814669 diameter: Decode User-Name as an IMSI in S13/S13'\n82084f606f Packaging: Make sure we stash our version info when creating a tarball\n5a2d1f11ca Tools: More update-appdata.py updates\n36fb1a1122 Doc: Fix the include path in the release notes\nd0bc4c6505 Tools: Fix a comment in update-appdata.py\n8962b0c46b GitLab CI: Update our Freedesktop metainformation when we build our tarball\n32cef085d2 mdb: dissect comms gw's setup command\na8a8e5b878 dect-nwk: use proto_tree_add_item for bcd fields\n146333ca22 tvbuff: (trivial) fix indentation\n80dded9664 ieee80211: Update the naming of display filter in EHT multi-link fields\n6c069829b1 mdb: show comms gw responses\n027cbbf247 ssh: Fix Coverity CID 1504410\n2dacfaff0b SSH: Only try to decrypt packets on the first pass\nbce8c7f287 DCT2000: when dissecting mac-nr frame, fill in sfn/sf into struct\n84da1d805d mdb: start Communications Gateway support\nf3faac2753 ssh: Plug leak of MAC context when using ChaCha20\n6d14da97ca DCERPC: Add dissector for IWbemLoginClientIDEx(9f6c78ef-fce5-42fa-abea-3e7df91921dc) Interface\nc2d223d0e3 mdb: dissect vending messages\n8d6e559bba [#19371] file-pcapng: check SHB endianness sooner\n09ba1a1409 MAC-NR: Add UL CE Timing Advance Report\n348c9991f9 ssh: Fix some invalid reads and writes, infinite loops\nb09ce5c762 ssh: Don't close a cipher twice\ncfe780dd03 asn2wrs: Ignore the \"WITH SUCCESSORS\" directive\n5028f7d725 mdb: start dissecting Optional Feature Enabled\n5b3e32acb5 regex: Accept a subj_offset in ws_regex_matches_pos\n4c05d067f3 Windows packaging: Close a tag\n642e77d6f5 CMake: Fix our macOS Intel deployment target\nbd801bf093 GitLab CI: Only run the Windows Qt5 Build job if the UI code changes\n6d96f6dd51 Fix some spelling errors\n81cb82abf4 CMake: Try to fix release notes dependencies (take 2)\ncd01931eb9 dfilter: Remove syntax node magic number\nc0885fe390 Find: Switch search_pos to the start byte\n6de60e12be CMake: Try to fix release notes dependencies\n14f9bcacc2 YACC: Update yacc.py to 3.11\nc38e6ecbf6 SAToP: Add optional RTP header handling\n46a7f4c17f WSDG: Update build type flags to reflect reality\n7db4de58af GitLab CI: Switch the macOS builds to Qt 6.5.3\nc1c86c4d8b Debian: Fix a couple of symbol versions\n15d3e3ff68 GUI: Add release notes to Help menu\n7f8dc702da GitLab CI: Fix a filename\na89f301313 GitLab CI: macOS signature workflow updates.\nfd3d36b10d LPP: upgrade dissector to v17.6.0\nc00e73e890 F1AP: upgrade dissector to v17.6.0\n35afac76f3 E1AP: upgrade dissector to v17.6.0\nba655f9214 XnAP: upgrade dissector to v17.6.0\nbb5ef53e20 NGAP: upgrade dissector to v17.6.0\n91fbc04b3a NR RRC: upgrade dissector to v17.6.0\n68266efa92 X2AP: upgrade dissector to v17.6.0\n15af80bf09 LTE RRC: upgrade dissector to v17.6.0\nc40d0b4508 NAS 5GS: upgrade dissector to v17.12.0\n49599f68b0 NAS EPS: upgrade dissector to v17.11.0\n8c073467d4 GitLab CI: Fix a path\ne05e08e049 GitLab CI: More macOS signature updates\ne1234e277a [Automatic update for 2023-10-01]\n8e59e06395 find: Use ws_memmem in match_binary\n67914dc866 wsutil: Optimize memmem some more\n9956361f4b WSUG: Title spelling fix\n9c90105c36 Find: Remove redundant match_narrow function\nd96594ad93 Qt: In find packet, disable character encoding combobox when unused\n894221f2c8 DHCP: Add preference for seconds elapsed field endianness\n147b95d2d5 Find: Update search frame for Finding multiple fields\n4c69b8facf Find Packet: Find packet details multiple matches in a frame\n3a0e70d6eb wsutil: memset mempbrk pattern when compiling\n46e3bffb3d debian: Make Lintian happy about version numbers\n23458361e4 Debian: Add missing symbols\n51b875f573 debian lintian: Remove Synopsys override\nf3dd768d35 Fix some misspellings in dissectors\nf3b687aaf2 GitLab CI: Generate Sparkle signatures on macOS\nddd0c4a83b wslog: Set a GLib default handler\n10e312fde1 More value_string fixes\n3f3ef7f463 macos-setup: fix uninstalling sparkle\n5cc394fa96 macos-setup: fix building of spandsp\n8ad5adb32b macos-setup: update location of zlib\n672637758a macos-setup: Install Sparkle 2.2.2\n8bd086302f GitLab CI: More macOS updates\n26fab0dab2 GitLab CI: Fix a couple of paths\n19a8e8ebeb GitLab CI: Generate Sparkle signatures on macOS\ne314032dc8 mdb: start dissecting the Peripheral ID response\n505e5be0f4 vmware-hb: add value_string for build number\n05f471ab9b zvt: simpler dissection of big-endian packed bcd fields\n1d9ba7de54 IEEE 1609.2: Update asn1 descriptions and add CAMP\n4258c3a02f mdb: start dissecting Expansion messages\ne1386531ec NFS: Fix value_string values that were our of range\n28902c6901 tvbuff: support endianness setting for packed BCD\n662b3b4f84 IPv6: Ensure that fragment extension header length is adjusted\n42bed37e07 mdb: dissect reader config data\n826d0149e5 Fix WBXML nested tag indentation\nc517bf0d25 Docs: Update our Qt6 LTS version\n07e8b273d7 SOME/IP: Simplifying the TP Header Parser Code\nc778a99db8 Tools: Add constant conversions to convert-glib-types\nab99d061ef Fixed memory leak of match_info, made regex easier to read\n5b5042b1ee [#19362] afp: on't pass null pinfo\na7872672c2 GitLab CI: Switch the Windows builds to Qt 6.5.3\n07f6b8d934 dfilter: Fix use-after-free\n37568f2fb8 iperf3: replace info column local time by time sent\n628219c08e mdb: dissect max/min prices\nd7bc20d3ea dfilter: Refactor DFVM_VALUE_STRING argument\n6275d509e1 dfilter: Allow using matches operator with value strings\n8f6c9f2f1b dfilter: Add value string optimization\ndcce728bb7 dfilter: Add support for BASE_CUSTOM value strings\n6b27217bd3 dfilter: Do not compare value strings lexicographically\neb3d347c02 dfilter: Compute value string at runtime\n7006e356ac ieee1905: Sync Message and TLV with EasyMesh SPEC v5.0\n003ba726e3 awdl: fix conflict for awdl.servicesparams.values\n82e80778f1 Added limits on regular expressions\n5c7d0376ad Better memory management for regex in TS32.423 parser\nb7acb29c5a mdb: start dissecting the cashless setup command\n80a4187b30 mdb: simpler approach for filter stings\nb261f2a7eb pcapng: Add Sysdig meta event types\nbd07966d3a Debian: Add a missing symbol\nb38f051a7e XML: Set a maximum length in a regex capture group\n24d88d3b74 Qt: Fix highlighting of protocol bytes when clicking proto tree item\n8e8f87ab29 NTP: remove wrong value from peer event code vs\n5d54dccdf1 Docs: Reset release notes after 4.2 branch\n2b4f939761 lemon: Add -- support to end options, use in our lemon\n4fc1eadde2 GitLab CI: Add a MinGW build to MR pipeline\n37697f7f4e Revert \"lemon: Add -- support to end options\"\n55f13726ac Logray: Fix slots for updateTitlebar()\n5d91fece06 UI: Fix slots for updateTitlebar()\nf8f2734f96 epan: Fix compile error\nb28619576b mgcp, sdp: disable handling SDP RTP if Osmux is announced in MGCP body\ndc5f082447 mgcp: Simplify cascade if-else block\n4995e9a8d5 proto.c: `proto_tree_add_mac48_detail()` function\n67ddf9d5db DCERPC: Add dissector for IWbemLoginClientID Interface\n7936638b1d rtp-events: fix id conflict\nb929ceeafb tshark+dumpcap: fail on unknown ringbuffer option\n3716933046 lemon: Add -- support to end options\n7ea5bbb53b Change some `wmem_packet_scope()` to `pinfo->pool`\n051c8cb7b3 Revert changes to JSON boolean format\n6bc8c6c682 tshark: more efficient `-b printname:FILE`\nc9c641d45d tshark: support `-b printname:FILE`\n9af5c31864 GitLab CI: Fix a build directory name\n8085b6d7f1 Docs: Fix a few spelling issues\n47ae3fcdce dumpcap: `RINGBUFFER_MIN_NUM_FILES` logic error\n94e78bf560 pfcp: Update to 3GPP TS 29.244 V18.3.0\n4ee1b1291e oampdu: give the dgt_set_t a better name.\n884a19b8ef r09: give the dgt_set_t a better name.\nb2f6dd2e29 UI: Fix capturing information in the title when prefs are saved\n6ecadcd0f3 ITS: Update Collective Perception Service (CPS) to ETSI TR 103 562 V2.1.1\nfafb3e3154 Test and handle spaces in our build directory\n54b19db4ee TS32.423: Fix dissector for various formats\nf8d48d04d5 Fix misppellings in root and ui directories\n15e753136e iperf3: Rework UDP loss/out-of-order detection\ndf391e6f5f WSDG: Update the automated builds section\n"
        },
        {
          "name": "ConfigCPack.cmake",
          "type": "blob",
          "size": 3.3515625,
          "content": "############################\n# CPack configuration file #\n############################\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the copyright\n#    notice, this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n# 3. The name of the author may not be used to endorse or promote products\n#    derived from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\n## General ##\n\nif(WIN32)\n\tset(CPACK_PACKAGE_NAME \"Wireshark\")\nelse()\n\tset(CPACK_PACKAGE_NAME \"wireshark\")\nendif()\nset(CPACK_PACKAGE_VENDOR \"Wireshark Foundation\")\nset(CPACK_PACKAGE_VERSION_MAJOR ${PROJECT_MAJOR_VERSION})\nset(CPACK_PACKAGE_VERSION_MINOR ${PROJECT_MINOR_VERSION})\nset(CPACK_PACKAGE_VERSION_PATCH ${PROJECT_PATCH_VERSION})\nset(CPACK_PACKAGE_VERSION ${PROJECT_VERSION})\nset(CPACK_PACKAGE_DESCRIPTION\n\"Wireshark is the world’s most popular network protocol analyzer.\"\n\"It is used for troubleshooting, analysis, development and education.\"\n)\nset(CPACK_PACKAGE_DESCRIPTION_SUMMARY \"Network protocol analyzer\")\nset(CPACK_PACKAGE_HOMEPAGE_URL \"https://www.wireshark.org/\")\nset(CPACK_PACKAGE_ICON \"${CMAKE_SOURCE_DIR}/resources/icons/wiresharkinst.ico\")\nset(CPACK_PACKAGE_CONTACT \"Wireshark-Dev Mailing List <wireshark-dev@wireshark.org>\")\n\nset(CPACK_PACKAGE_FILE_NAME ${CPACK_PACKAGE_NAME}-${CPACK_PACKAGE_VERSION})\nset(CPACK_PACKAGE_CHECKSUM \"SHA256\")\n\nif(WIN32)\n    set(CPACK_PACKAGE_INSTALL_DIRECTORY \"Wireshark\")\n    set(CPACK_STRIP_FILES FALSE)\nelse()\n    set(CPACK_PACKAGE_INSTALL_DIRECTORY \"wireshark\")\n    set(CPACK_STRIP_FILES TRUE)\nendif()\n\n# This creates a screen in the windows installers asking users to \"Agree\" to the GPL which is incorrect.\n# set(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_SOURCE_DIR}/COPYING\")\nset(CPACK_RESOURCE_FILE_README \"${CMAKE_SOURCE_DIR}/README.md\")\n# set( CPACK_RESOURCE_FILE_WELCOME \"${CMAKE_SOURCE_DIR}/README.md\") # TODO: can we use this?\n\nset(CPACK_WARN_ON_ABSOLUTE_INSTALL_DESTINATION TRUE)\n\n# specific config for source packaging (note this is used by the 'dist' target)\nset(CPACK_SOURCE_GENERATOR \"TXZ\")\nset(CPACK_SOURCE_PACKAGE_FILE_NAME ${PROJECT_VERSION})\nset(CPACK_SOURCE_IGNORE_FILES \"~$;[.]swp$;/[.]svn/;/[.]git/;.gitignore;/build/;/obj*/;cscope.*;.gitlab*;.coveragerc;*.md;\")\n\nset(CPACK_ARCHIVE_COMPONENT_INSTALL ON)\n\n## load cpack module (do this *after* all the CPACK_* variables have been set)\ninclude(CPack)\n"
        },
        {
          "name": "ConfigureChecks.cmake",
          "type": "blob",
          "size": 6.4072265625,
          "content": "# ConfigureChecks.cmake\n#\n# Wireshark - Network traffic analyzer\n# By Gerald Combs <gerald@wireshark.org>\n# Copyright 1998 Gerald Combs\n#\n# SPDX-License-Identifier: GPL-2.0-or-later\n#\n\ninclude(CMakePushCheckState)\n\n#check system for includes\ninclude(CheckIncludeFile)\ninclude(CheckIncludeFiles)\ncheck_include_file(\"arpa/inet.h\"            HAVE_ARPA_INET_H)\ncheck_include_file(\"grp.h\"                  HAVE_GRP_H)\n#\n# This may require <sys/types.h> to be included\n#\ncheck_include_files(\"sys/types.h;ifaddrs.h\" HAVE_IFADDRS_H)\ncheck_include_file(\"netinet/in.h\"           HAVE_NETINET_IN_H)\ncheck_include_file(\"netdb.h\"                HAVE_NETDB_H)\ncheck_include_file(\"pwd.h\"                  HAVE_PWD_H)\ncheck_include_file(\"sys/select.h\"           HAVE_SYS_SELECT_H)\ncheck_include_file(\"sys/socket.h\"           HAVE_SYS_SOCKET_H)\ncheck_include_file(\"sys/time.h\"             HAVE_SYS_TIME_H)\ncheck_include_file(\"sys/utsname.h\"          HAVE_SYS_UTSNAME_H)\ncheck_include_file(\"sys/wait.h\"             HAVE_SYS_WAIT_H)\ncheck_include_file(\"unistd.h\"               HAVE_UNISTD_H)\n\n#\n# On Linux, check for some additional headers, which we need as a\n# workaround for a bonding driver bug and for libpcap's current lack\n# of its own workaround for that bug.\n#\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\t#\n\t# Those header files require <sys/socket.h>.\n\t#\n\tcheck_c_source_compiles(\n\t\t\"#include <sys/socket.h>\n\t\t#include <linux/sockios.h>\n\t\tint main(void)\n\t\t{\n\t\t\treturn 0;\n\t\t}\"\n\t\tHAVE_LINUX_SOCKIOS_H\n\t)\n\tcheck_c_source_compiles(\n\t\t\"#include <sys/socket.h>\n\t\t#include <linux/if_bonding.h>\n\t\tint main(void)\n\t\t{\n\t\t\treturn 0;\n\t\t}\"\n\t\tHAVE_LINUX_IF_BONDING_H\n\t)\nendif()\n\n#Functions\ninclude(CheckFunctionExists)\ninclude(CheckSymbolExists)\n\n#\n# Platform-specific functions used in platform-specific code.\n# We check for them only on the platform on which we use them.\n#\nif(CMAKE_SYSTEM_NAME STREQUAL \"HP-UX\")\n\t#\n\t# HP-UX\n\t#\n\tcmake_push_check_state()\n\tset(CMAKE_REQUIRED_LIBRARIES ${CMAKE_DL_LIBS})\n\tcheck_function_exists(\"dlget\"           HAVE_DLGET)\n\tcmake_pop_check_state()\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\" AND CMAKE_SYSTEM_VERSION MATCHES \"5[.][0-9.]*\")\n\t#\n\t# Solaris\n\t#\n\tcheck_function_exists(\"getexecname\"     HAVE_GETEXECNAME)\nendif()\n\ncheck_symbol_exists(\"clock_gettime\"  \"time.h\"   HAVE_CLOCK_GETTIME)\n# Some platforms (macOS pre 10.15) are non-conformant with C11 and lack timespec_get()\ncheck_symbol_exists(\"timespec_get\"   \"time.h\"   HAVE_TIMESPEC_GET)\nif(NOT MSVC)\n\tcheck_symbol_exists(\"localtime_r\"    \"time.h\"   HAVE_LOCALTIME_R)\n\tcheck_symbol_exists(\"gmtime_r\"       \"time.h\"   HAVE_GMTIME_R)\n\tcheck_symbol_exists(\"timegm\"         \"time.h\"   HAVE_TIMEGM)\n\tcheck_symbol_exists(\"tzset\"          \"time.h\"   HAVE_TZSET)\n\tcheck_symbol_exists(\"tzname\"         \"time.h\"   HAVE_TZNAME)\n\tcheck_symbol_exists(\"getline\"\t     \"stdio.h\"  HAVE_GETLINE)\nendif()\ncheck_function_exists(\"getifaddrs\"       HAVE_GETIFADDRS)\ncheck_function_exists(\"issetugid\"        HAVE_ISSETUGID)\ncheck_function_exists(\"setresgid\"        HAVE_SETRESGID)\ncheck_function_exists(\"setresuid\"        HAVE_SETRESUID)\nif (APPLE)\n\tcmake_push_check_state()\n\tset(CMAKE_REQUIRED_LIBRARIES ${APPLE_CORE_FOUNDATION_LIBRARY})\n\tcheck_function_exists(\"CFPropertyListCreateWithStream\" HAVE_CFPROPERTYLISTCREATEWITHSTREAM)\n\tcmake_pop_check_state()\nendif()\nif(UNIX)\n\tcmake_push_check_state()\n\tlist(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE)\n\tcheck_symbol_exists(\"memmem\"        \"string.h\"   HAVE_MEMMEM)\n\tcheck_symbol_exists(\"memrchr\"       \"string.h\"   HAVE_MEMRCHR)\n\tcheck_symbol_exists(\"strerrorname_np\" \"string.h\" HAVE_STRERRORNAME_NP)\n\tcheck_symbol_exists(\"strptime\"      \"time.h\"     HAVE_STRPTIME)\n\tcheck_symbol_exists(\"vasprintf\"     \"stdio.h\"    HAVE_VASPRINTF)\n\tcmake_pop_check_state()\nendif()\n\n#Struct members\ninclude(CheckStructHasMember)\ncheck_struct_has_member(\"struct stat\"     st_blksize     sys/stat.h   HAVE_STRUCT_STAT_ST_BLKSIZE)\ncheck_struct_has_member(\"struct stat\"     st_birthtime   sys/stat.h   HAVE_STRUCT_STAT_ST_BIRTHTIME)\ncheck_struct_has_member(\"struct stat\"     __st_birthtime sys/stat.h   HAVE_STRUCT_STAT___ST_BIRTHTIME)\ncheck_struct_has_member(\"struct tm\"       tm_zone        time.h       HAVE_STRUCT_TM_TM_ZONE)\ncheck_struct_has_member(\"struct tm\"       tm_gmtoff      time.h       HAVE_STRUCT_TM_TM_GMTOFF)\n\n# Types\ninclude(CheckTypeSize)\ncheck_type_size(\"ssize_t\"       SSIZE_T)\n\n#\n# Check if the libc vsnprintf() conforms to C99. If this fails we may\n# need to fall-back on GLib I/O.\n#\n# If cross-compiling we can't check so just assume this requirement is met.\n#\nif(NOT CMAKE_CROSSCOMPILING)\n\tcheck_c_source_runs(\"\n\t\t#include <stdio.h>\n\n\t\t#pragma GCC diagnostic push\n\t\t#pragma GCC diagnostic ignored \\\"-Wall\\\"\n\t\tint main(void)\n\t\t{\n\t\t\t/* Check that snprintf() and vsnprintf() don't return\n\t\t\t* -1 if the buffer is too small. C99 says this value\n\t\t\t* is the length that would be written not including\n\t\t\t* the nul byte. */\n\t\t\tchar buf[3];\n\t\t\treturn snprintf(buf, sizeof(buf), \\\"%s\\\", \\\"ABCDEF\\\") > 0 ? 0 : 1;\n\t\t}\n\t\t#pragma GCC diagnostic pop\"\n\t\tHAVE_C99_VSNPRINTF\n\t)\n\tif (NOT HAVE_C99_VSNPRINTF)\n\t\tmessage(FATAL_ERROR\n\"Building Wireshark requires a C99 compliant vsnprintf() and this \\\ntarget does not meet that requirement. Compiling for ${CMAKE_SYSTEM} \\\nusing ${CMAKE_C_COMPILER_ID}. Please report this issue to the Wireshark \\\ndevelopers at wireshark-dev@wireshark.org.\"\n\t\t)\n\tendif()\nendif()\n\n#\n# *If* we found libnl, check if we can use nl80211 stuff with it.\n#\nif (NL_FOUND)\n\tcheck_c_source_compiles(\n\t\t\"#include <linux/nl80211.h>\n\t\tint main(void) {\n\t\t\tint x = NL80211_FREQUENCY_ATTR_MAX_TX_POWER;\n\t\t\tx |= NL80211_ATTR_SUPPORTED_IFTYPES;\n\t\t\tx |= NL80211_ATTR_SUPPORTED_COMMANDS;\n\t\t\tx |= NL80211_ATTR_WIPHY_FREQ;\n\t\t\tx |= NL80211_CHAN_NO_HT;\n\t\t\t(void)x;\n\t\t}\"\n\t\tHAVE_NL80211\n\t)\n\tcheck_c_source_compiles(\n\t\t\"#include <linux/nl80211.h>\n\t\tint main(void) {\n\t\t\tenum nl80211_commands x = NL80211_CMD_SET_CHANNEL;\n\t\t}\"\n\t\tHAVE_NL80211_CMD_SET_CHANNEL\n\t)\n\tcheck_c_source_compiles(\n\t\t\"#include <linux/nl80211.h>\n\t\tint main(void) {\n\t\t\tenum nl80211_protocol_features x = NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP;\n\t\t}\"\n\t\tHAVE_NL80211_SPLIT_WIPHY_DUMP\n\t)\n\tcheck_c_source_compiles(\n\t\t\"#include <linux/nl80211.h>\n\t\tint main(void) {\n\t\t\tenum nl80211_attrs x = NL80211_ATTR_VHT_CAPABILITY;\n\t\t}\"\n\t\tHAVE_NL80211_VHT_CAPABILITY\n\t)\nendif()\n\n#\n# Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n#\n# Local variables:\n# c-basic-offset: 8\n# tab-width: 8\n# indent-tabs-mode: t\n# End:\n#\n# vi: set shiftwidth=8 tabstop=8 noexpandtab:\n# :indentSize=8:tabSize=8:noTabs=false:\n#\n"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 8.5849609375,
          "content": "See also https://wiki.wireshark.org/Development/\nand the Developer's Guide located at https://www.wireshark.org/docs/\nand in the doc/ subdirectory.\n\nInstallation\n============\n\nThese are installation instructions for Unix and Unix-like systems.\nThese are not the installation instructions for Windows systems; see\nthe Wireshark User's Guide and Wireshark Developer's Guide at\nhttps://www.wireshark.org/docs/ for those.\n\n0. This is software.  Beware.\n\n1. If you wish to build Wireshark, make sure you have the Qt and GLib\n   development packages installed. Try running\n   'pkg-config glib-2.0 --modversion' to see if you have GLib 2.x\n   installed.  Then try running 'pkg-config Qt6Widgets --modversion'\n   to see if you have Qt 6 installed.  If not, then try running\n   'pkg-config Qt5Widgets --modversion' to see if you have Qt 5.\n   Wireshark requires Qt 5.15 or later, but the most recent LTS release\n   is strongly recommended.  Building against Qt 5 will require the\n   CMake option '-DUSE_qt6=OFF'.  Wireshark requires version 2.54.0 or\n   above of GLib.  If you need to install or re-install GLib, you can\n   find the packages at:\n\n        https://download.gnome.org/sources/glib/\n\n   You can find Qt at:\n\n        https://www.qt.io/download\n\n   If you installed Qt or GLib from binary packages, you may have to\n   install corresponding \"development\" packages; there may be separate\n   \"user's\" and \"developer's\" packages, with the former not including\n   header files and the like.  For example, Red Hat users will need to\n   install a \"glib2-devel\" .rpm.\n\n2. If you wish to build TShark, the line-mode version of Wireshark,\n   make sure you have GLib installed.  See note #1 above for instructions\n   on checking if you have GLib installed.\n\n3. If you want to capture packets, make sure you have libpcap\n   installed.  The latest \"official\" version can be found at\n\n        https://www.tcpdump.org .\n\n   If you installed libpcap from a binary package, you may have to\n   install a \"development\" package; for example, there's\n   apparently a \"libpcap0\" Debian package, but it just includes a\n   shared library, a copyright notice, changelog files, and a\n   README.md file - you also need to install a \"libpcap-dev\" package\n   to get header files, a non-shared library, and the man page.\n   Similarly, Red Hat users will need to install a \"libpcap-devel\"\n   .rpm to go along with the \"libpcap\" .rpm.\n\n4. Building Wireshark requires Python, flex, and Asciidoctor.\n\n5. Create a build directory separate from the source directory. It can\n   be anywhere, but you might run into issues if the path contains\n   spaces.\n\n6. Run 'cmake <options> <path/to/the/wireshark/sources>' in your build\n   directory. Running 'cmake -LH <path/to/the/wireshark/sources>'\n   displays a complete list of options. The \"Tool Reference\" section of\n   Developer's Guide contains general instructions for using CMake. Some\n   of the Wireshark-specific options are as follows:\n\n    -G Ninja\n        CMake supports many different build systems, including UNIX\n        Make, MSBuild, and Ninja. UNIX Make is the default, but Ninja\n        tends to be faster.\n\n    -DBUILD_wireshark=OFF\n        By default CMake tries to find the Qt libraries so Wireshark,\n        the GUI packet analyzer, can be built.  You can disable the\n        build of the GUI version of Wireshark with this switch.\n\n    -DBUILD_tshark=OFF\n        By default the line-mode packet analyzer, TShark, is built.\n        Use this switch to avoid building it.\n\n    -DBUILD_editcap=OFF\n        By default the capture-file editing program is built.\n        Use this switch to avoid building it.\n\n    -DBUILD_capinfos=OFF\n        By default the capture-file statistics reporting program\n        is built. Use this switch to avoid building it.\n\n    -DBUILD_captype=OFF\n        By default the capture-type reporting program is built. Use this\n        switch to avoid building it.\n\n    -DBUILD_mergecap=OFF\n        By default the capture-file merging program is built.\n        Use this switch to avoid building it.\n\n    -DBUILD_reordercap=OFF\n        By default the capture-file reordering program is built.\n        Use this switch to avoid building it.\n\n    -DBUILD_text2pcap=OFF\n        By default the hex-dump-to-capture file conversion program\n        is built. Use this switch to avoid building it.\n\n    -DBUILD_dftest=OFF\n        By default the display-filter-compiler test program is built.\n        Use this switch to avoid building it.\n\n    -DBUILD_randpkt=OFF\n        By default the program which creates random packet-capture files\n        is built. Use this switch to avoid building it.\n\n    -DBUILD_dumpcap=OFF\n        By default the network traffic capture program is built.\n        Use this switch to avoid building it.\n\n    -DBUILD_rawshark=OFF\n        By default the program used to dump and analyze raw libpcap data\n        is built. Use this switch to avoid building it.\n\n    -DUSE_qt6=OFF\n        By default if Qt is needed CMake tries to find the Qt 6 libraries.\n        Use this switch to search for and build with Qt 5 instead.\n\n    -DDUMPCAP_INSTALL_OPTION=suid\n    -DDUMPCAP_INSTALL_OPTION=capabilities\n        Wireshark and TShark rely on dumpcap for packet capture. Setting\n        this flag to \"suid\" installs dumpcap with setuid root\n        permissions, which lets any user on the system capture live\n        traffic. If this is not desired, you can restrict dumpcap's\n        permissions so that only a single user or group can run it and\n        set the \"capabilities\" flag.\n\n        Running Wireshark or TShark as root is not recommended.\n\n    -DENABLE_CAP=OFF\n        By default, if 'cmake' finds libcap (the POSIX capabilities\n        library) dumpcap will be built so that if it is installed setuid\n        root, it will attempt to retain CAP_NET_RAW and CAP_NET_ADMIN\n        before dropping root privileges. Use this option to disable this\n        behavior.\n\n    -DENABLE_PCAP=OFF\n        If you choose to build a packet analyzer that can analyze\n        capture files but cannot capture packets on its own, but you\n        *do* have libpcap installed, or if you are trying to build\n        Wireshark on a system that doesn't have libpcap installed (in\n        which case you have no choice but to build a version that can\n        analyze capture files but cannot capture packets on its own),\n        use -DENABLE_PCAP=OFF to avoid using libpcap.\n\n    -DENABLE_ZLIB=OFF\n        By default, if 'cmake' finds zlib (a.k.a, libz), the\n        wiretap library will be built so that it can read compressed\n        capture files. If you have zlib but do not wish to build\n        it into the wiretap library, used by Wireshark, TShark, and\n        the capture-file utilities that come in this package, use\n        this switch.\n\n    -DENABLE_BROTLI=OFF\n        By default, if 'cmake' finds brotli, the wiretap library\n        will be built so that it can read brotli compressed capture\n        files. If you have brotli but do not wish to build it into\n        the wiretap library, used by Wireshark, TShark, and the\n        capture-file utilities that come in this package, use this switch.\n\n    -DENABLE_PLUGINS=OFF\n        By default, if your system can support run-time loadable modules,\n        the packet analyzers are build with support for plugins.\n        Use this switch to build packet analyzers without plugin support.\n\n7. After running 'cmake', you will see a summary of some\n   of the options you chose. Ensure that the summary reflects\n   what you want. If it doesn't, re-run 'cmake' with new options.\n\n8. Run 'make', or 'ninja' if you chose to create Ninja build files.\n   Hopefully, you won't run into any problems.\n\n9. Run './run/wireshark' or './run/tshark' or ./run/dumpcap, and make sure things are\n   working. You must have root privileges in order to capture live data.\n\n10./a. Run 'make install'.  If you're running a system that supports\n   the RPM packaging systems you can run\n\n        make wireshark_rpm\n\n   or\n\n        ninja wireshark_rpm\n\n   to make an installable package for your system. The installation path\n   defaults to /usr/local, so you'll probably want to pass\n   -DCMAKE_INSTALL_PREFIX=/usr to CMake.\n\n10/b. If you 're running a system that supports APT (Debian/Ubuntu/etc.)\n   run\n\n        ln -sn packaging/debian\n        dpkg-buildpackage -us -uc -rfakeroot\n\n   in the source directory right after extracting of checking out\n   Wireshark's source code. (You don't have to run CMake/make/Ninja/etc.\n   prior to running dpkg-buildpackage)\n\n\nIf you have trouble with the build or installation process, you can\nfind assistance on the wireshark-users and wireshark-dev mailing lists (see\nhttps://www.wireshark.org/lists/ for details) or the Wireshark Q&A site:\nhttps://ask.wireshark.org .\n"
        },
        {
          "name": "README.DECT",
          "type": "blob",
          "size": 1.244140625,
          "content": "Description:\n============\nDECT pcap files can be obtained by using tools included with the linux\nkernel driver for the Dosch-and-Amand COM-ON-AIR cards. The driver is\ncalled com-on-air_cs.\n\nWireshark cannot directly record from the DECT HW, as the driver\ncurrently lacks a virtual network interface.\n\nThere is ongoing work to change this (see this work by Patrick McHardy):\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/kaber/dect-2.6.git\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/kaber/libnl-dect.git\ngit clone git://git.kernel.org/pub/scm/libs/netlink/libnl.git\nAlso needed are a proper linktype value assigned by the libpcap team and\nthe proper patches for libpcap to support this (the value used in the\npatch below is not officially assigned!):\ngit://git.kernel.org/pub/scm/linux/kernel/git/kaber/libpcap-dect.git\n\nTo nicely view DECT pcap files in wireshark, set up a custom layout:\n\nEdit->Preferences...\n  User Interface\n    Columns\n\n      No.      | Number\n      Protocol | Protocol\n      Frame    | Custom Column: dect.framenumber\n      TA       | Custom Column: dect.cc.TA\n      A-Field  | Custom Column: dect.cc.AField\n      B-Field  | Custom Column: dect.cc.BField\n  OK\n\n\nEdit->Configuration Profiles...\n  New\n  Profile Name = dect\n  OK\n\n\n"
        },
        {
          "name": "README.bsd",
          "type": "blob",
          "size": 2.8984375,
          "content": "Installing Wireshark on FreeBSD/OpenBSD/NetBSD/DragonFly BSD\n========================================================================\n\n     1. Berkeley Packet Filter (BPF) requirement\n     2. Running Wireshark as a non-root user\n\nFor general installation instructions, see the INSTALL file, along with\nthe Developer's Guide located at https://www.wireshark.org/docs/ and\nin the doc/ directory.  Additional BSD specific notes and requirements\nfollow.\n\n1. Berkeley Packet Filter (BPF) requirement\n--------------------------------------------\nIn order to capture packets (with Wireshark/TShark, tcpdump, or any\nother packet capture program) on a BSD system, your kernel must have the\nBerkeley Packet Filter mechanism enabled.  The default kernel\nconfigurations in recent versions of BSD systems have this enabled\nalready.  To verify the bpf device is present, look in the /dev\ndirectory:\n\n    ls -l /dev/bpf*\n\nYou should see one or more bpf devices listed similar to this:\n\n    crw-------  1 root  wheel    0,  90 Aug 10 21:05 /dev/bpf0\n    crw-------  1 root  wheel    0,  91 Aug 10 21:05 /dev/bpf1\n\nPacket-capturing programs will pick the first bpf device that's not in\nuse.  Recent versions of most BSDs will create bpf devices as needed, so\nyou don't have to configure the number of devices that will be\navailable.\n\n2. Running wireshark as a non-root user\n-------------------------------------------\nSince the bpf devices are read-only by the owner (root), you normally\nhave to run packet capturing programs such as Wireshark as root.  It is\nsafer to run programs as a non-root user if possible.  To run Wireshark\nas a non-root user, you must change the permissions on the bpf device(s).\nIf you are the only user that needs to use Wireshark, the easiest way\nis to change the owner of each bpf device to your username.  You can also\nadd the read/write ability to the group (typically wheel) and add users\nthat need to use Wireshark to the wheel group.  Check your operating\nsystem's documentation on how to make permanent these changes as they\nare often reset upon reboot; if /dev is implemented with devfs, it might\nbe possible to configure devfs to create all bpf devices owned by a\nparticular user and/or group and with particular permissions.  In\nFreeBSD 6.0 and later this can be done by creating an /etc/devfs.rules\nfile with content such as\n\n\t[localrules=10]\n\tadd path 'bpf*' {mode and permissions}\n\nwhere \"mode and permissions\" can include clauses such as\n\n\tmode {octal permissions}\n\nto set the permissions on the device (e.g., \"mode 0660\" to set the\npermissions to rw-rw-r--),\n\n\tuser {user}\n\nto set the user who owns the device, or\n\n\tgroup {group}\n\nto set the group that owns the device and adding a line such as\n\n\tdevfs_system_ruleset=localrules\n\nto /etc/rc.conf.  For example, an /etc/devfs.rules file with\n\n\t[localrules=10]\n\tadd path 'bpf*' mode 0660 group wheel\n\nwill grant read and write permissions on all BPF devices to all users in\nthe \"wheel\" group.\n"
        },
        {
          "name": "README.linux",
          "type": "blob",
          "size": 5.515625,
          "content": "In order to capture packets (with Wireshark/TShark, tcpdump, or any\nother libpcap-based packet capture program) on a Linux system, the\n\"packet\" protocol must be supported by your kernel.  If it is not, you\nmay get error messages such as\n\n\tmodprobe: can't locate module net-pf-17\n\nin \"/var/adm/messages\", or may get messages such as\n\n\tsocket: Address family not supported by protocol\n\nfrom applications using libpcap.\n\nMost recent Linux distributions will have this configured in by default. \nIf it is not configured in with the default kernel, and if it is not a\nmodule loaded by default, you must configure the kernel with the\nCONFIG_PACKET option for this protocol; the following note is from the\nLinux \"Configure.help\" file for the 2.0[.x] kernel:\n\n\tPacket socket\n\tCONFIG_PACKET\n\t  The Packet protocol is used by applications which communicate\n\t  directly with network devices without an intermediate network\n\t  protocol implemented in the kernel, e.g. tcpdump. If you want them\n\t  to work, choose Y. \n\n\t  This driver is also available as a module called af_packet.o ( =\n\t  code which can be inserted in and removed from the running kernel\n\t  whenever you want). If you want to compile it as a module, say M\n\t  here and read Documentation/modules.txt; if you use modprobe or\n\t  kmod, you may also want to add \"alias net-pf-17 af_packet\" to \n\t  /etc/modules.conf.\n\nand the note for the 2.2[.x] kernel says:\n\n\tPacket socket\n\tCONFIG_PACKET\n\t  The Packet protocol is used by applications which communicate\n\t  directly with network devices without an intermediate network\n\t  protocol implemented in the kernel, e.g. tcpdump. If you want them\n\t  to work, choose Y. This driver is also available as a module called\n\t  af_packet.o ( = code which can be inserted in and removed from the\n\t  running kernel whenever you want). If you want to compile it as a\n\t  module, say M here and read Documentation/modules.txt.  You will\n\t  need to add 'alias net-pf-17 af_packet' to your /etc/conf.modules\n\t  file for the module version to function automatically.  If unsure,\n\t  say Y.\n\nIn addition, there is an option that, in 2.2 and later kernels, will\nallow packet capture filters specified to programs such as tcpdump to be\nexecuted in the kernel, so that packets that don't pass the filter won't\nbe copied from the kernel to the program, rather than having all packets\ncopied to the program and libpcap doing the filtering in user mode. \n\nCopying packets from the kernel to the program consumes a significant\namount of CPU, so filtering in the kernel can reduce the overhead of\ncapturing packets if a filter has been specified that discards a\nsignificant number of packets.  (If no filter is specified, it makes no\ndifference whether the filtering isn't performed in the kernel or isn't\nperformed in user mode. :-))\n\nMost recent Linux distributions will have this configured in by default. \nIf it is not configured in with the default kernel, you must configure\nthe kernel with the CONFIG_FILTER option; the \"Configure.help\" file\nsays:\n\n\tSocket filtering\n\tCONFIG_FILTER\n\t  The Linux Socket Filter is derived from the Berkeley Packet Filter.\n\t  If you say Y here, user-space programs can attach a filter to any\n\t  socket and thereby tell the kernel that it should allow or disallow\n\t  certain types of data to get through the socket. Linux Socket\n\t  Filtering works on all socket types except TCP for now. See the text\n\t  file linux/Documentation/networking/filter.txt for more information.\n\t  If unsure, say N.\n\nAn additional problem, on Linux, with older versions of libpcap, is that\ncapture filters do not work when snooping loopback devices; if you're\ncapturing on a Linux loopback device, do not use a capture filter, as it\nwill probably reject most if not all packets, including the packets it's\nintended to accept - instead, capture all packets and use a display\nfilter to select the packets you want to see.  Most recent Linux\ndistribution releases will not have this problem.\n\nIn addition, older versions of libpcap will, on Linux systems with a\n2.0[.x] kernel, or if built for systems with a 2.0[.x] kernel, not turn\npromiscuous mode off on a network device until the program using\npromiscuous mode exits, so if you start a capture with Wireshark on some\nLinux distributions, the network interface will be put in promiscuous\nmode and will remain in promiscuous mode until Wireshark exits.  There\nmight be additional libpcap bugs that cause it not to be turned off even\nwhen Wireshark exits; if your network is busy, this could cause the Linux\nnetworking stack to do a lot more work discarding packets not intended\nfor the machine, so you may want to check, after running Wireshark,\nwhether any network interfaces are in promiscuous mode (the output of\n\"ifconfig -a\" will say something such as\n\neth0      Link encap:Ethernet  HWaddr 00:00:66:66:66:66\n          inet addr:66.66.66.66  Bcast:66.66.66.255  Mask:255.255.255.0\n          UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1500  Metric:1\n          RX packets:6493 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:3380 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:100 \n          Interrupt:18 Base address:0xfc80 \n\nwith \"PROMISC\" indicating that the interface is in promiscuous mode),\nand, if any interfaces are in promiscuous mode and no capture is being\ndone on that interface, turn promiscuous mode off by hand with\n\n\tifconfig <ifname> -promisc\n\nwhere \"<ifname>\" is the name of the interface.\n\nNewer versions of libpcap shouldn't have this problem, even on 2.0[.x]\nkernels; no version of libpcap should have that problem on systems with\n2.2 or later kernels.\n"
        },
        {
          "name": "README.macos",
          "type": "blob",
          "size": 6.5595703125,
          "content": "MacOS Quick Start (Using Homebrew)\n-----------------------------------\n\n> Note that this method is particularly recommended for M1 and later Macs.\n\n1. Install the latest Xcode from the MacOS app store.\n   See https://guide.macports.org/#installing.xcode for details.\n\n2. Install Homebrew (https://brew.sh/)\n\n3. From the top-level source directory, run tools/macos-setup-brew.sh and wait\n   for it to complete.\n\n   Note: You may set the environment variable HOMEBREW_NO_AUTO_UPDATE=1 if you\n         do not want the script to update homebrew.\n\n4. Create a build directory and enter it:\n    mkdir build && cd build\n\n5. Configure the build:\n    cmake ..\n\n6. Build wireshark!\n    make -j\n\nThe wireshark binary will be found at run/wireshark under your build directory.\n\nNote that for subsequent builds, you will only need to enter the build\ndirectory and run \"make -j\".\n\nNote that if you cannot use homebrew, or otherwise need to manually install\nprerequisites, you cannot use this method; continue reading for more detailed\ninstructions.\n\n\nNon-Homebrew Setup and Build of Wireshark for macOS\n----------------------------------------------------\nThis file tries to help building Wireshark for macOS (The Operating\nSystem Formerly Known As Mac OS X And Then OS X) (Wireshark does not\nwork on the classic Mac OS).\n\nYou must have the developer tools (called Xcode) installed.  For\nversions of macOS up to and including Snow Leopard, Xcode 3 should be\navailable on the install DVD; Xcode 4 is available for download from\ndeveloper.apple.com and, for Lion and later releases, from the Mac App\nStore.  See\n\n\thttps://guide.macports.org/#installing.xcode\n\nfor details.  For Xcode 4, you will need to install the command-line\ntools; select Preferences from the Xcode menu, select Downloads in the\nPreferences window, and install Command Line Tools.\n\n\nYou must also have GLib and, if you want to build Wireshark as well as\nTShark, you must have also Qt installed.  You can download precompiled\nQt packages and source code from\n\n\thttps://www.qt.io/download\n\nor use the tools/macos-setup.sh script described below.\n\nYou should have CMake installed; you can download binary distributions\nfor macOS from\n\n\thttps://cmake.org/download/\n\nThe tools/macos-setup.sh script can be used to download, patch as\nnecessary, build as necessary, and install those libraries and the\nlibraries on which they depend, along with tools such as CMake; it will,\nby default, also install other libraries that can be used by Wireshark\nand TShark.  The versions of libraries and tools to download are\nspecified by variables set early in the script; you can comment out the\nsettings of optional libraries if you don't want them downloaded and\ninstalled.  Before running the tools/macos-setup.sh script, and before\nattempting to build Wireshark, make sure your PKG_CONFIG_PATH\nenvironment variable's setting includes /usr/local/lib/pkgconfig.\n\nThe tools/macos-setup.sh script must be run from the top-level source\ndirectory.\n\nAfter you have installed those libraries:\n\n 1. It is generally recommended to install Qt with the online installer\n    provided by Qt - see https://www.qt.io/download\n\n\tIf you are building on an Apple Silicon machine, it is highly recommended\n\tto use at least Qt 6.2.4, as this architecture is not fully supported\n\twith Qt 5.15\n\n 2. Make a directory in which Wireshark is to be built, separate\n\tfrom the top-level source directory for Wireshark - it can be a\n\tsubdirectory of that top-level source directory;\n\n 3. cd to that directory, and run CMake, with an argument that is a\n\tpath to the top-level source directory;\n\n 4. When CMake finishes, run make to build Wireshark.\n\nFor example, to build Wireshark in a subdirectory of the top-level\nsource directory, named \"build\", do, from the top-level source\ndirectory;\n\n\tmkdir build\n\tcd build\n\tcmake ..\n\tmake\n\nIt is also possible to use the Xcode IDE to build and debug Wireshark\nusing cmake's Xcode generator. Create a separate build directory, as\ndescribed above and run cmake with the \"-G Xcode\" argument to create\na Xcode project file in the current directory.\n\n\tcmake -G Xcode ..\n\n 1. Double click Wireshark.xcodeproj\n\n 2. Choose to create schemes manually\n\n 3. Create a scheme for the ALL_BUILD target\n\n 4. Edit the scheme, go to the run configuration and select Wireshark.app\n  as executable\n\nIf you upgrade the major release of macOS on which you are building\nWireshark, we advise that, before you do any builds after the upgrade,\nyou remove the build directory and all its subdirectories, and repeat the\nabove process, re-running CMake and rebuilding from scratch.\n\nOn Snow Leopard (10.6) and later releases, if you are building on a\nmachine with a 64-bit processor (with the exception of the early Intel\nCore Duo and Intel Core Solo machines, all Apple machines with Intel\nprocessors have 64-bit processors), the C/C++/Objective-C compiler will\nbuild 64-bit by default.\n\nThis means that you will, by default, get a 64-bit version of Wireshark.\n\nOne consequence of this is that, if you built and installed any required\nor optional libraries for Wireshark on an earlier release of macOS, those\nare probably 32-bit versions of the libraries, and you will need to\nun-install them and rebuild them on your current version of macOS, to get\n64-bit versions.\n\nSome required and optional libraries require special attention if you\ninstall them by building from source code on Snow Leopard and later\nreleases; the tools/macos-setup.sh script will handle that for you.\n\nGLib - the GLib configuration script determines whether the system's\nlibiconv is GNU iconv or not by checking whether it has libiconv_open(),\nand the compile will fail if that test doesn't correctly indicate\nwhether libiconv is GNU iconv.  In macOS, libiconv is GNU iconv, but the\n64-bit version doesn't have libiconv_open(); a workaround for this is to\nreplace all occurrences of \"libiconv_open\" with \"iconv_open\" in the\nconfigure script before running the script.  The tools/macos-setup.sh\nsetup script will patch GLib to work around this.\n\nlibgcrypt - the libgcrypt configuration script attempts to determine\nwhich flavor of assembler-language routines to use based on the platform\ntype determined by standard autoconf code.  That code uses uname to\ndetermine the processor type; however, in macOS, uname always reports\n\"i386\" as the processor type on Intel machines, even Intel machines with\n64-bit processors, so it will attempt to assemble the 32-bit x86\nassembler-language routines, which will fail.  The workaround for this\nis to run the configure script with the --disable-asm argument, so that\nthe assembler-language routines are not used.  The tools/macos-setup.sh\nwill configure libgcrypt with that option.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.18359375,
          "content": "General Information\n-------------------\n\nWireshark is a network traffic analyzer, or \"sniffer\", for Linux, macOS,\n\\*BSD and other Unix and Unix-like operating systems and for Windows.\nIt uses Qt, a graphical user interface library, and libpcap and npcap as\npacket capture and filtering libraries.\n\nThe Wireshark distribution also comes with TShark, which is a\nline-oriented sniffer (similar to Sun's snoop or tcpdump) that uses the\nsame dissection, capture-file reading and writing, and packet filtering\ncode as Wireshark, and with editcap, which is a program to read capture\nfiles and write the packets from that capture file, possibly in a\ndifferent capture file format, and with some packets possibly removed\nfrom the capture.\n\nThe official home of Wireshark is https://www.wireshark.org.\n\nThe latest distribution can be found in the subdirectory https://www.wireshark.org/download\n\n\nInstallation\n------------\n\nThe Wireshark project builds and tests regularly on the following platforms:\n\n  - Linux (Ubuntu)\n  - Microsoft Windows\n  - macOS / {Mac} OS X\n\nOfficial installation packages are available for Microsoft Windows and\nmacOS.\n\nIt is available as either a standard or add-on package for many popular\noperating systems and Linux distributions including Debian, Ubuntu, Fedora,\nCentOS, RHEL, Arch, Gentoo, openSUSE, FreeBSD, DragonFly BSD, NetBSD, and\nOpenBSD.\n\nAdditionally it is available through many third-party packaging systems\nsuch as pkgsrc, OpenCSW, Homebrew, and MacPorts.\n\nIt should run on other Unix-ish systems without too much trouble.\n\nIn some cases the current version of Wireshark might not support your\noperating system. This is the case for Windows XP, which is supported by\nWireshark 1.10 and earlier. In other cases the standard package for\nWireshark might simply be old. This is the case for Solaris and HP-UX.\n\nPython 3 is needed to build Wireshark. AsciiDoctor is required to build\nthe documentation, including the man pages. Perl and flex are required\nto generate some of the source code.\n\nYou must therefore install Python 3, AsciiDoctor, and GNU \"flex\" (vanilla\n\"lex\" won't work) on systems that lack them. You might need to install\nPerl as well.\n\nFull installation instructions can be found in the INSTALL file and in the\nDeveloper's Guide at https://www.wireshark.org/docs/wsdg_html_chunked/\n\nSee also the appropriate README._OS_ files for OS-specific installation\ninstructions.\n\nUsage\n-----\n\nIn order to capture packets from the network, you need to make the\ndumpcap program set-UID to root or you need to have access to the\nappropriate entry under `/dev` if your system is so inclined (BSD-derived\nsystems, and systems such as Solaris and HP-UX that support DLPI,\ntypically fall into this category).  Although it might be tempting to\nmake the Wireshark and TShark executables setuid root, or to run them as\nroot please don't.  The capture process has been isolated in dumpcap;\nthis simple program is less likely to contain security holes and is thus\nsafer to run as root.\n\nPlease consult the man page for a description of each command-line\noption and interface feature.\n\n\nMultiple File Types\n-------------------\n\nWireshark can read packets from a number of different file types.  See\nthe Wireshark man page or the Wireshark User's Guide for a list of\nsupported file formats.\n\nWireshark can transparently read compressed versions of any of those files if\nthe required compression library was available when Wireshark was compiled.\nCurrently supported compression formats are:\n\n- GZIP\n- LZ4\n- ZSTD\n\nGZIP and LZ4 (when using independent blocks, which is the default) support\nfast random seeking, which offers much better GUI performance on large files.\nAny of these compression formats can be disabled at compile time by passing\nthe corresponding option to cmake, i.e., `cmake -DENABLE_ZLIB=OFF`,\n`cmake -DENABLE_LZ4=OFF`, or `cmake -DENABLE_ZSTD=OFF`.\n\nAlthough Wireshark can read AIX iptrace files, the documentation on\nAIX's iptrace packet-trace command is sparse.  The `iptrace` command\nstarts a daemon which you must kill in order to stop the trace. Through\nexperimentation it appears that sending a HUP signal to that iptrace\ndaemon causes a graceful shutdown and a complete packet is written\nto the trace file. If a partial packet is saved at the end, Wireshark\nwill complain when reading that file, but you will be able to read all\nother packets.  If this occurs, please let the Wireshark developers know\nat wireshark-dev@wireshark.org; be sure to send us a copy of that trace\nfile if it's small and contains non-sensitive data.\n\nSupport for Lucent/Ascend products is limited to the debug trace output\ngenerated by the MAX and Pipline series of products.  Wireshark can read\nthe output of the `wandsession`, `wandisplay`, `wannext`, and `wdd`\ncommands.\n\nWireshark can also read dump trace output from the Toshiba \"Compact Router\"\nline of ISDN routers (TR-600 and TR-650). You can telnet to the router\nand start a dump session with `snoop dump`.\n\nCoSine L2 debug output can also be read by Wireshark. To get the L2\ndebug output first enter the diags mode and then use\n`create-pkt-log-profile` and `apply-pkt-lozg-profile` commands under\nlayer-2 category. For more detail how to use these commands, you\nshould examine the help command by `layer-2 create ?` or `layer-2 apply ?`.\n\nTo use the Lucent/Ascend, Toshiba and CoSine traces with Wireshark, you must\ncapture the trace output to a file on disk.  The trace is happening inside\nthe router and the router has no way of saving the trace to a file for you.\nAn easy way of doing this under Unix is to run `telnet <ascend> | tee <outfile>`.\nOr, if your system has the \"script\" command installed, you can save\na shell session, including telnet, to a file. For example to log to a file\nnamed tracefile.out:\n\n~~~\n$ script tracefile.out\nScript started on <date/time>\n$ telnet router\n..... do your trace, then exit from the router's telnet session.\n$ exit\nScript done on <date/time>\n~~~\n\n\nName Resolution\n---------------\n\nWireshark will attempt to use reverse name resolution capabilities\nwhen decoding IPv4 and IPv6 packets.\n\nIf you want to turn off name resolution while using Wireshark, start\nWireshark with the `-n` option to turn off all name resolution (including\nresolution of MAC addresses and TCP/UDP/SMTP port numbers to names) or\nwith the `-N mt` option to turn off name resolution for all\nnetwork-layer addresses (IPv4, IPv6, IPX).\n\nYou can make that the default setting by opening the Preferences dialog\nusing the Preferences item in the Edit menu, selecting \"Name resolution\",\nturning off the appropriate name resolution options, and clicking \"OK\".\n\n\nSNMP\n----\n\nWireshark can do some basic decoding of SNMP packets; it can also use\nthe libsmi library to do more sophisticated decoding by reading MIB\nfiles and using the information in those files to display OIDs and\nvariable binding values in a friendlier fashion.  CMake  will automatically\ndetermine whether you have the libsmi library on your system.  If you\nhave the libsmi library but _do not_ want Wireshark to use it, you can run\ncmake with the `-DENABLE_SMI=OFF` option.\n\nHow to Report a Bug\n-------------------\n\nWireshark is under constant development, so it is possible that you will\nencounter a bug while using it. Please report bugs at https://gitlab.com/wireshark/wireshark/-/issues.\nBe sure you enter into the bug:\n\n1. The complete build information from the \"About Wireshark\"\n   item in the Help menu or the output of `wireshark -v` for\n   Wireshark bugs and the output of `tshark -v` for TShark bugs;\n\n2. If the bug happened on Linux, the Linux distribution you were\n   using, and the version of that distribution;\n\n3. The command you used to invoke Wireshark, if you ran\n   Wireshark from the command line, or TShark, if you ran\n   TShark, and the sequence of operations you performed that\n   caused the bug to appear.\n\nIf the bug is produced by a particular trace file, please be sure to\nattach to the bug a trace file along with your bug description.  If the\ntrace file contains sensitive information (e.g., passwords), then please\ndo not send it.\n\nIf Wireshark died on you with a 'segmentation violation', 'bus error',\n'abort', or other error that produces a UNIX core dump file, you can\nhelp the developers a lot if you have a debugger installed.  A stack\ntrace can be obtained by using your debugger ('gdb' in this example),\nthe wireshark binary, and the resulting core file.  Here's an example of\nhow to use the gdb command 'backtrace' to do so.\n\n~~~\n$ gdb wireshark core\n(gdb) backtrace\n..... prints the stack trace\n(gdb) quit\n$\n~~~\n\nThe core dump file may be named \"wireshark.core\" rather than \"core\" on\nsome platforms (e.g., BSD systems).  If you got a core dump with\nTShark rather than Wireshark, use \"tshark\" as the first argument to\nthe debugger; the core dump may be named \"tshark.core\".\n\nLicense\n-------\n\nWireshark is distributed under the GNU GPLv2. See the file COPYING for\nthe full text of the license. When in doubt the full text is the legally\nbinding part. These notes are just to make it easier for people that are not\nfamiliar with the GPLv2.\n\nThere are no restrictions on its use. There are restrictions on its distribution\nin source or binary form.\n\nMost parts of Wireshark are covered by a \"GPL version 2 or later\" license.\nSome files are covered by different licenses that are compatible with\nthe GPLv2.\n\nAs a notable exception, some utilities distributed with the Wireshark source are\ncovered by other licenses that are not themselves directly compatible with the\nGPLv2. This is OK, as only the tools themselves are licensed this way, the\noutput of the tools is not considered a derived work, and so can be safely\nlicensed for Wireshark's use. An incomplete selection of these tools includes:\n - the pidl utility (tools/pidl) is licensed under the GPLv3+.\n\nParts of Wireshark can be built and distributed as libraries. These\nparts are still covered by the GPL, and NOT by the Lesser General Public\nLicense or any other license.\n\nIf you integrate all or part of Wireshark into your own application and you\nopt to publish or release it then the combined work must be released under\nthe terms of the GPLv2.\n\n\nDisclaimer\n----------\n\nThere is no warranty, expressed or implied, associated with this product.\nUse at your own risk.\n\n\nGerald Combs <gerald@wireshark.org>\n\nGilbert Ramirez <gram@alumni.rice.edu>\n\nGuy Harris <gharris@sonic.net>\n"
        },
        {
          "name": "README.msys2",
          "type": "blob",
          "size": 0.4033203125,
          "content": "The MSYS2 installer can be downloaded from https://www.msys2.org.\n\nWireshark is available as an MSYS2 binary package[1]. It can be installed using pacman,\nfor example using the UCRT64 shell:\n\n    $ pacman -S mingw-w64-ucrt-x86_64-wireshark\n\nInstructions for building Wireshark from source code are available in\nthe Wireshark Developer's Guide.\n\nReferences:\n\n[1]https://packages.msys2.org/base/mingw-w64-wireshark\n"
        },
        {
          "name": "Vagrantfile",
          "type": "blob",
          "size": 1.5,
          "content": "# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n# Vagrantfile API/syntax version. Don't touch unless you know what you're doing!\nVAGRANTFILE_API_VERSION = \"2\"\n\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n\n  # Bump the default resources as building is expensive\n  config.vm.provider \"virtualbox\" do |v|\n    v.memory = 8096\n    v.cpus = 4\n  end\n\n  # Permit X11 forwarding so running the graphical Wireshark works\n  config.ssh.forward_x11 = true\n\n  # Mounting to /vagrant (the default) won't work for building a\n  # Debian package. Let's be consistent for all boxes.\n  config.vm.synced_folder \".\", \"/vagrant\", disabled: true\n  config.vm.synced_folder \".\", \"/home/vagrant/wireshark\", type: \"virtualbox\"\n\n  # Install and build the various things (including wireshark!)\n  config.vm.define \"ubuntu\", autostart: false do |deb|\n    deb.vm.box = \"ubuntu/jammy64\"\n\n    deb.vm.provision \"shell\" do |s|\n      s.path = 'tools/debian-setup.sh'\n      s.args = ['--install-optional', '--assume-yes', '--install-qt6-deps']\n    end\n    deb.vm.provision :shell, inline: \"apt-get -y install ccache\"\n    deb.vm.provision :shell, path: 'vagrant_build.sh', privileged: false\n  end\n\n  config.vm.define \"fedora\", autostart: false do |rpm|\n    rpm.vm.box = \"fedora/28-cloud-base\"\n\n    rpm.vm.provision \"shell\" do |s|\n      s.path = 'tools/rpm-setup.sh'\n      s.args = ['--install-optional', '--assumeyes']\n    end\n    rpm.vm.provision :shell, inline: \"yum -y install ccache\"\n    rpm.vm.provision :shell, path: 'vagrant_build.sh', privileged: false\n  end\nend\n"
        },
        {
          "name": "WiresharkConfig.cmake.in",
          "type": "blob",
          "size": 1.24609375,
          "content": "set(Wireshark_MAJOR_VERSION @PROJECT_MAJOR_VERSION@)\nset(Wireshark_MINOR_VERSION @PROJECT_MINOR_VERSION@)\nset(Wireshark_PATCH_VERSION @PROJECT_PATCH_VERSION@)\nset(Wireshark_VERSION \"@PROJECT_VERSION@\")\n\nset(Wireshark_PLUGINS_ENABLED @HAVE_PLUGINS@)\nset(Wireshark_PLUGIN_LIBDIR \"@PLUGIN_INSTALL_VERSION_LIBDIR@\")\n\n@PACKAGE_INIT@\n\nset_and_check(Wireshark_INSTALL_PREFIX     \"${PACKAGE_PREFIX_DIR}\")\nset_and_check(Wireshark_LIB_DIR            \"@PACKAGE_CMAKE_INSTALL_LIBDIR@\")\nset_and_check(Wireshark_INCLUDE_DIR        \"@PACKAGE_CMAKE_INSTALL_INCLUDEDIR@/wireshark\")\n#\n# set_and_check() cannot be used with directories that may or may not exist.\n# If no plugins or extcaps are built the respective directories will not exist in the target\n# system and set_and_check() and therefore find_package() will fail with a FATAL_ERROR,\n# which is not helpful because the variable is correct, it's just that the empty directories\n# were not created (also correctly, empty directories are just noise).\n#\nif(Wireshark_PLUGINS_ENABLED)\n    set(Wireshark_PLUGIN_INSTALL_DIR \"@PACKAGE_PLUGIN_INSTALL_VERSION_LIBDIR@\")\nendif()\nset(Wireshark_EXTCAP_INSTALL_DIR \"@PACKAGE_EXTCAP_INSTALL_LIBDIR@\")\n\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/WiresharkTargets.cmake\")\n\ncheck_required_components(Wireshark)\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 2.5068359375,
          "content": "version: build{build}\nimage: Visual Studio 2019\n\nenvironment:\n  WIRESHARK_BASE_DIR: C:\\wireshark-libs\n  matrix:\n    # Note: if VS2017 win32 is added, just use Qt msvc2015 (binary compatible).\n    - PLATFORM: x64\n      CMAKE_GENERATOR: Visual Studio 16 2019\n      QT5_BASE_DIR: C:\\Qt\\5.15\\msvc2019_64\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n\ncache:\n  - '%WIRESHARK_BASE_DIR%'\n  - C:\\ProgramData\\chocolatey\\bin\n  - C:\\ProgramData\\chocolatey\\lib\n\ninstall:\n  - choco install winflexbison\n  # Java is already installed, prevent an expensive upgrade (102 seconds).\n  - choco install --ignore-dependencies asciidoctorj docbook-bundle xsltproc\n  # Py2 fails the test_tshark_unicode_display_filter test, so use Py3.\n  - set PATH=C:\\Python37-x64;C:\\Python37-x64\\Scripts;%PATH%\n  - pip install pytest pytest-xdist\n  - ps: New-Item -ItemType Directory -Force -Path $Env:WIRESHARK_BASE_DIR\n  - ps: |   # For pkcs11 tests.\n      Invoke-WebRequest -Uri https://github.com/disig/SoftHSM2-for-Windows/releases/download/v2.5.0/SoftHSM2-2.5.0.msi -OutFile $Env:WIRESHARK_BASE_DIR\\SoftHSM2-2.5.0.msi\n      & msiexec /qn /i $Env:WIRESHARK_BASE_DIR\\SoftHSM2-2.5.0.msi\n  # https://help.appveyor.com/discussions/questions/18777-how-to-use-vcvars64bat-from-powershell\n  - ps: cmd.exe /c \"call `\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat`\" && set > %temp%\\vcvars.txt\"\n  - ps: Get-Content \"$env:temp\\vcvars.txt\" | Foreach-Object { if ($_ -match \"^(.*?)=(.*)$\") { Set-Content \"env:\\$($matches[1])\" $matches[2] } }\n\n# Note: the NSIS installer lacks debug dlls for Debug builds.\nconfiguration: RelWithDebInfo\n\nbuild:\n  parallel: true\n  project: build\\Wireshark.sln\n\nbefore_build:\n  - python3 tools/make-version.py --set-release --untagged-version-extra=-{vcsinfo}-AppVeyor --tagged-version-extra=-AppVeyor\n  - mkdir build\n  - cd build\n  - cmake -E time cmake -DCMAKE_SYSTEM_VERSION=10.0.20348.0 -G \"%CMAKE_GENERATOR%\" ..\n\nafter_build:\n  - msbuild /m wireshark_nsis_prep.vcxproj\n  - msbuild /m wireshark_nsis.vcxproj\n  # Publish installers only for development branches to avoid exceeding the\n  # artifact storage limit of 50 GB.\n  - ps: |\n      if ($Env:APPVEYOR_REPO_BRANCH -notlike \"master*\") {\n        Get-Item packaging\\nsis\\Wireshark-*.exe | % { Push-AppveyorArtifact $_.FullName -FileName $_.Name }\n      }\n\nbefore_test:\n  - msbuild /m test-programs.vcxproj\n\ntest_script:\n  - pytest\n\non_finish:\n  - ps: |\n      $Tshark = \"run\\\\$Env:CONFIGURATION\\\\tshark.exe\"\n      if (Test-Path $Tshark) { & $Tshark --version }\n\ndeploy: off\n"
        },
        {
          "name": "capinfos.c",
          "type": "blob",
          "size": 58.3759765625,
          "content": "/* capinfos.c\n * Reports capture file information including # of packets, duration, others\n *\n * Copyright 2004 Ian Schorr\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n/*\n * 2009-09-19: jyoung\n *\n * New capinfos features\n *\n * Continue processing additional files after\n * a wiretap open failure.  The new -C option\n * reverts to capinfos' original behavior which\n * is to cancel any further file processing at\n * first file open failure.\n *\n * Change the behavior of how the default display\n * of all infos is initiated.  This gets rid of a\n * special post getopt() argument count test.\n *\n * Add new table output format (with related options)\n * This feature allows outputting the various infos\n * into a tab delimited text file, or to a comma\n * separated variables file (*.csv) instead of the\n * original \"long\" format.\n *\n * 2011-04-05: wmeier\n * behaviour changed: Upon exit capinfos will return\n *  an error status if an error occurred at any\n *  point during \"continuous\" file processing.\n *  (Previously a success status was always\n *   returned if the -C option was not used).\n *\n */\n\n\n#include <config.h>\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <locale.h>\n\n#include <ws_exit_codes.h>\n#include <wsutil/ws_getopt.h>\n\n#include <glib.h>\n\n#include <wiretap/wtap.h>\n\n#include <wsutil/cmdarg_err.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/privileges.h>\n#include <cli_main.h>\n#include <wsutil/version_info.h>\n#include <wiretap/wtap_opttypes.h>\n\n#ifdef HAVE_PLUGINS\n#include <wsutil/plugins.h>\n#endif\n\n#include <wsutil/str_util.h>\n#include <wsutil/to_str.h>\n#include <wsutil/file_util.h>\n#include <wsutil/ws_assert.h>\n#include <wsutil/wslog.h>\n\n#include <gcrypt.h>\n\n#include \"ui/failure_message.h\"\n\n/*\n * By default capinfos now continues processing\n * the next filename if and when wiretap detects\n * a problem opening or reading a file.\n * Use the '-C' option to revert back to original\n * capinfos behavior which is to abort any\n * additional file processing at the first file\n * open or read failure.\n */\n\nstatic bool stop_after_failure;\n\n/*\n * table report variables\n */\n\nstatic bool long_report               = true;  /* By default generate long report       */\nstatic bool table_report_header       = true;  /* Generate column header by default     */\nstatic char field_separator           = '\\t';  /* Use TAB as field separator by default */\nstatic char quote_char                = '\\0';  /* Do NOT quote fields by default        */\nstatic bool machine_readable; /* Display machine-readable numbers      */\n\n/*\n * capinfos has the ability to report on a number of\n * various characteristics (\"infos\") for each input file.\n *\n * By default reporting of all info fields is enabled.\n *\n * Optionally the reporting of any specific info field\n * or combination of info fields can be enabled with\n * individual options.\n */\n\nstatic bool report_all_infos   = true;  /* Report all infos           */\n\nstatic bool cap_file_type      = true;  /* Report capture type        */\nstatic bool cap_file_encap     = true;  /* Report encapsulation       */\nstatic bool cap_snaplen        = true;  /* Packet size limit (snaplen)*/\nstatic bool cap_packet_count   = true;  /* Report packet count        */\nstatic bool cap_file_size      = true;  /* Report file size           */\nstatic bool cap_comment        = true;  /* Display the capture comment */\nstatic bool cap_file_more_info = true;  /* Report more file info      */\nstatic bool cap_file_idb       = true;  /* Report Interface info      */\nstatic bool cap_file_nrb       = true;  /* Report Name Resolution Block info      */\nstatic bool cap_file_dsb       = true;  /* Report Decryption Secrets Block info      */\n\nstatic bool cap_data_size      = true;  /* Report packet byte size    */\nstatic bool cap_duration       = true;  /* Report capture duration    */\nstatic bool cap_earliest_packet_time = true;  /* Report timestamp of earliest packet */\nstatic bool cap_latest_packet_time = true;  /* Report timestamp of latest packet */\nstatic bool time_as_secs; /* Report time values as raw seconds */\n\nstatic bool cap_data_rate_byte = true;  /* Report data rate bytes/sec */\nstatic bool cap_data_rate_bit  = true;  /* Report data rate bites/sec */\nstatic bool cap_packet_size    = true;  /* Report average packet size */\nstatic bool cap_packet_rate    = true;  /* Report average packet rate */\nstatic bool cap_order          = true;  /* Report if packets are in chronological order (True/False) */\nstatic bool pkt_comments       = true;  /* Report individual packet comments */\n\nstatic bool cap_file_hashes    = true;  /* Calculate file hashes */\n\n// Strongest to weakest\n#define HASH_SIZE_SHA256 32\n#define HASH_SIZE_SHA1   20\n\n#define HASH_STR_SIZE (65) /* Max hash size * 2 + '\\0' */\n#define HASH_BUF_SIZE (1024 * 1024)\n\n\nstatic char file_sha256[HASH_STR_SIZE];\nstatic char file_sha1[HASH_STR_SIZE];\n\nstatic char  *hash_buf;\nstatic gcry_md_hd_t hd;\n\nstatic unsigned int num_ipv4_addresses;\nstatic unsigned int num_ipv6_addresses;\nstatic unsigned int num_decryption_secrets;\n\n/*\n * If we have at least two packets with time stamps, and they're not in\n * order - i.e., the later packet has a time stamp older than the earlier\n * packet - the time stamps are known not to be in order.\n *\n * If every packet has a time stamp, and they're all in order, the time\n * stamp is known to be in order.\n *\n * Otherwise, we have no idea.\n */\ntypedef enum {\n    IN_ORDER,\n    NOT_IN_ORDER,\n    ORDER_UNKNOWN\n} order_t;\n\ntypedef struct _pkt_cmt {\n  int recno;\n  char *cmt;\n  struct _pkt_cmt *next;\n} pkt_cmt;\n\ntypedef struct _capture_info {\n    const char           *filename;\n    uint16_t              file_type;\n    wtap_compression_type compression_type;\n    int                   file_encap;\n    int                   file_tsprec;\n    wtap                 *wth;\n    int64_t               filesize;\n    uint64_t              packet_bytes;\n    bool                  times_known;\n    nstime_t              earliest_packet_time;\n    int                   earliest_packet_time_tsprec;\n    nstime_t              latest_packet_time;\n    int                   latest_packet_time_tsprec;\n    uint32_t              packet_count;\n    bool                  snap_set;                 /* If set in capture file header      */\n    uint32_t              snaplen;                  /* value from the capture file header */\n    uint32_t              snaplen_min_inferred;     /* If caplen < len for 1 or more rcds */\n    uint32_t              snaplen_max_inferred;     /*  ...                               */\n    bool                  drops_known;\n    uint32_t              drop_count;\n\n    nstime_t              duration;\n    int                   duration_tsprec;\n    double                packet_rate;\n    double                packet_size;\n    double                data_rate;                /* in bytes/s */\n    bool                  know_order;\n    order_t               order;\n\n    int                  *encap_counts;             /* array of per_packet encap counts; array has one entry per wtap_encap type */\n    pkt_cmt              *pkt_cmts;                 /* list of packet comments */\n\n    unsigned int                 num_interfaces;           /* number of IDBs, and thus size of interface_packet_counts array */\n    GArray               *interface_packet_counts;  /* array of per_packet interface_id counts; one entry per file IDB */\n    uint32_t              pkt_interface_id_unknown; /* counts if packet interface_id didn't match a known one */\n    GArray               *idb_info_strings;         /* array of IDB info strings */\n} capture_info;\n\nstatic char *decimal_point;\n\nstatic void\nenable_all_infos(void)\n{\n    report_all_infos   = true;\n\n    cap_file_type      = true;\n    cap_file_encap     = true;\n    cap_snaplen        = true;\n    cap_packet_count   = true;\n    cap_file_size      = true;\n    cap_comment        = true;\n    pkt_comments       = true;\n    cap_file_more_info = true;\n    cap_file_idb       = true;\n    cap_file_nrb       = true;\n    cap_file_dsb       = true;\n\n    cap_data_size      = true;\n    cap_duration       = true;\n    cap_earliest_packet_time = true;\n    cap_latest_packet_time = true;\n    cap_order          = true;\n\n    cap_data_rate_byte = true;\n    cap_data_rate_bit  = true;\n    cap_packet_size    = true;\n    cap_packet_rate    = true;\n\n    cap_file_hashes    = true;\n}\n\nstatic void\ndisable_all_infos(void)\n{\n    report_all_infos   = false;\n\n    cap_file_type      = false;\n    cap_file_encap     = false;\n    cap_snaplen        = false;\n    cap_packet_count   = false;\n    cap_file_size      = false;\n    cap_comment        = false;\n    pkt_comments       = false;\n    cap_file_more_info = false;\n    cap_file_idb       = false;\n    cap_file_nrb       = false;\n    cap_file_dsb       = false;\n\n    cap_data_size      = false;\n    cap_duration       = false;\n    cap_earliest_packet_time = false;\n    cap_latest_packet_time = false;\n    cap_order          = false;\n\n    cap_data_rate_byte = false;\n    cap_data_rate_bit  = false;\n    cap_packet_size    = false;\n    cap_packet_rate    = false;\n\n    cap_file_hashes    = false;\n}\n\nstatic const char *\norder_string(order_t order)\n{\n    switch (order) {\n\n        case IN_ORDER:\n            return \"True\";\n\n        case NOT_IN_ORDER:\n            return \"False\";\n\n        case ORDER_UNKNOWN:\n            return \"Unknown\";\n\n        default:\n            return \"???\";  /* \"cannot happen\" (the next step is \"Profit!\") */\n    }\n}\n\nstatic char *\nabsolute_time_string(nstime_t *timer, int tsprecision, capture_info *cf_info)\n{\n    /*\n     *    https://web.archive.org/web/20120513133703/http://www.idrbt.ac.in/publications/workingpapers/Working%20Paper%20No.%209.pdf\n     *\n     * says:\n     *\n     *    A 64-bit Unix time would be safe for the indefinite future, as\n     *    this variable would not overflow until 2**63 or\n     *    9,223,372,036,854,775,808 (over nine quintillion) seconds\n     *    after the beginning of the Unix epoch - corresponding to\n     *    GMT 15:30:08, Sunday, 4th December, 292,277,026,596.\n     *\n     * So, if we're displaying the time as YYYY-MM-DD HH:MM:SS.SSSSSSSSS,\n     * we'll have the buffer be large enough for a date of the format\n     * 292277026596-MM-DD HH:MM:SS.SSSSSSSSS, which is the biggest value\n     * you'll get with a 64-bit time_t and a nanosecond-resolution\n     * fraction-of-a-second.\n     *\n     * That's 12+1+2+1+2+1+2+1+2+2+2+1+9+1, including the terminating\n     * \\0, or 39.\n     *\n     * If we're displaying the time as epoch time, and the time is\n     * unsigned, 2^64-1 is 18446744073709551615, so the buffer has\n     * to be big enough for 18446744073709551615.999999999.  That's\n     * 20+1+9+1, including the terminating '\\0', or 31.  If it's\n     * signed, 2^63 is 9223372036854775808, so the buffer has to\n     * be big enough for -9223372036854775808.999999999, which is\n     * again 20+1+9+1, or 31.\n     *\n     * So we go with 39.\n     */\n    static char time_string_buf[39];\n\n    if (cf_info->times_known && cf_info->packet_count > 0) {\n        if (time_as_secs) {\n            display_epoch_time(time_string_buf, sizeof time_string_buf, timer, tsprecision);\n        } else {\n            format_nstime_as_iso8601(time_string_buf, sizeof time_string_buf, timer, decimal_point, true, tsprecision);\n        }\n    } else {\n        snprintf(time_string_buf, sizeof time_string_buf, \"n/a\");\n    }\n    return time_string_buf;\n}\n\nstatic char *\nrelative_time_string(nstime_t *timer, int tsprecision, capture_info *cf_info, bool want_seconds)\n{\n    const char  *second = want_seconds ? \" second\" : \"\";\n    const char  *plural = want_seconds ? \"s\" : \"\";\n    /*\n     * If we're displaying the time as epoch time, and the time is\n     * unsigned, 2^64-1 is 18446744073709551615, so the buffer has\n     * to be big enough for \"18446744073709551615.999999999 seconds\".\n     * That's 20+1+9+1+7+1, including the terminating '\\0', or 39.\n     * If it'ssigned, 2^63 is 9223372036854775808, so the buffer has to\n     * be big enough for \"-9223372036854775808.999999999 seconds\",\n     * which is again 20+1+9+1+7+1, or 39.\n     */\n    static char  time_string_buf[39];\n\n    if (cf_info->times_known && cf_info->packet_count > 0) {\n        char *ptr;\n        size_t remaining;\n        int num_bytes;\n\n        ptr = time_string_buf;\n        remaining = sizeof time_string_buf;\n        num_bytes = snprintf(ptr, remaining,\n                             \"%\"PRId64,\n                             (int64_t)timer->secs);\n        if (num_bytes < 0) {\n            /*\n             * That got an error.\n             * Not much else we can do.\n             */\n            snprintf(ptr, remaining, \"snprintf() failed\");\n            return time_string_buf;\n        }\n        if ((unsigned int)num_bytes >= remaining) {\n            /*\n             * That filled up or would have overflowed the buffer.\n             * Nothing more we can do.\n             */\n            return time_string_buf;\n        }\n        ptr += num_bytes;\n        remaining -= num_bytes;\n\n        if (tsprecision != 0) {\n            /*\n             * Append the fractional part.\n             */\n            num_bytes = format_fractional_part_nsecs(ptr, remaining, timer->nsecs, decimal_point, tsprecision);\n            if ((unsigned int)num_bytes >= remaining) {\n                /*\n                 * That filled up or would have overflowed the buffer.\n                 * Nothing more we can do.\n                 */\n                return time_string_buf;\n            }\n            ptr += num_bytes;\n            remaining -= num_bytes;\n        }\n\n        /*\n         * Append the units.\n         */\n        snprintf(ptr, remaining, \"%s%s\",\n                 second,\n                 timer->secs == 1 ? \"\" : plural);\n\n        return time_string_buf;\n    }\n\n    snprintf(time_string_buf, sizeof time_string_buf, \"n/a\");\n    return time_string_buf;\n}\n\nstatic void print_value(const char *text_p1, int width, const char *text_p2, double value)\n{\n    if (value > 0.0)\n        printf(\"%s%.*f%s\\n\", text_p1, width, value, text_p2);\n    else\n        printf(\"%sn/a\\n\", text_p1);\n}\n\n/* multi-line comments would conflict with the formatting that capinfos uses\n   we replace linefeeds with spaces */\nstatic void\nstring_replace_newlines(char *str)\n{\n    char *p;\n\n    if (str) {\n        p = str;\n        while (*p != '\\0') {\n            if (*p == '\\n')\n                *p = ' ';\n            if (*p == '\\r')\n                *p = ' ';\n            p++;\n        }\n    }\n}\n\nstatic void\nshow_option_string(const char *prefix, const char *option_str)\n{\n    char *str;\n\n    if (option_str != NULL && option_str[0] != '\\0') {\n        str = g_strdup(option_str);\n        string_replace_newlines(str);\n        printf(\"%s%s\\n\", prefix, str);\n        g_free(str);\n    }\n}\n\nstatic void\nprint_stats(const char *filename, capture_info *cf_info)\n{\n    const char           *file_type_string, *file_encap_string;\n    char                 *size_string;\n    pkt_cmt               *p, *prev;\n\n    /* Build printable strings for various stats */\n    if (machine_readable) {\n        file_type_string = wtap_file_type_subtype_name(cf_info->file_type);\n        file_encap_string = wtap_encap_name(cf_info->file_encap);\n    }\n    else {\n        file_type_string = wtap_file_type_subtype_description(cf_info->file_type);\n        file_encap_string = wtap_encap_description(cf_info->file_encap);\n    }\n\n    if (filename)           printf     (\"File name:           %s\\n\", filename);\n    if (cap_file_type) {\n        const char *compression_type_description;\n        compression_type_description = wtap_compression_type_description(cf_info->compression_type);\n        if (compression_type_description == NULL)\n            printf     (\"File type:           %s\\n\",\n                    file_type_string);\n        else\n            printf     (\"File type:           %s (%s)\\n\",\n                    file_type_string, compression_type_description);\n    }\n    if (cap_file_encap) {\n        printf      (\"File encapsulation:  %s\\n\", file_encap_string);\n        if (cf_info->file_encap == WTAP_ENCAP_PER_PACKET) {\n            int i;\n            printf    (\"Encapsulation in use by packets (# of pkts):\\n\");\n            for (i=0; i<WTAP_NUM_ENCAP_TYPES; i++) {\n                if (cf_info->encap_counts[i] > 0)\n                    printf(\"                     %s (%d)\\n\",\n                            wtap_encap_description(i), cf_info->encap_counts[i]);\n            }\n        }\n    }\n    if (cap_file_more_info) {\n        printf      (\"File timestamp precision:  %s (%d)\\n\",\n                wtap_tsprec_string(cf_info->file_tsprec), cf_info->file_tsprec);\n    }\n\n    if (cap_snaplen && cf_info->snap_set)\n        printf     (\"Packet size limit:   file hdr: %u bytes\\n\", cf_info->snaplen);\n    else if (cap_snaplen && !cf_info->snap_set)\n        printf     (\"Packet size limit:   file hdr: (not set)\\n\");\n    if (cf_info->snaplen_max_inferred > 0) {\n        if (cf_info->snaplen_min_inferred == cf_info->snaplen_max_inferred)\n            printf     (\"Packet size limit:   inferred: %u bytes\\n\", cf_info->snaplen_min_inferred);\n        else\n            printf     (\"Packet size limit:   inferred: %u bytes - %u bytes (range)\\n\",\n                    cf_info->snaplen_min_inferred, cf_info->snaplen_max_inferred);\n    }\n    if (cap_packet_count) {\n        printf     (\"Number of packets:   \");\n        if (machine_readable) {\n            printf (\"%u\\n\", cf_info->packet_count);\n        } else {\n            size_string = format_size(cf_info->packet_count, FORMAT_SIZE_UNIT_NONE, 0);\n            printf (\"%s\\n\", size_string);\n            g_free(size_string);\n        }\n    }\n    if (cap_file_size) {\n        printf     (\"File size:           \");\n        if (machine_readable) {\n            printf     (\"%\" PRId64 \" bytes\\n\", cf_info->filesize);\n        } else {\n            size_string = format_size(cf_info->filesize, FORMAT_SIZE_UNIT_BYTES, 0);\n            printf (\"%s\\n\", size_string);\n            g_free(size_string);\n        }\n    }\n    if (cap_data_size) {\n        printf     (\"Data size:           \");\n        if (machine_readable) {\n            printf     (\"%\" PRIu64 \" bytes\\n\", cf_info->packet_bytes);\n        } else {\n            size_string = format_size(cf_info->packet_bytes, FORMAT_SIZE_UNIT_BYTES, 0);\n            printf (\"%s\\n\", size_string);\n            g_free(size_string);\n        }\n    }\n    if (cf_info->times_known) {\n        if (cap_duration) /* XXX - shorten to hh:mm:ss */\n            printf(\"Capture duration:    %s\\n\", relative_time_string(&cf_info->duration, cf_info->duration_tsprec, cf_info, true));\n        if (cap_earliest_packet_time)\n            printf(\"Earliest packet time: %s\\n\", absolute_time_string(&cf_info->earliest_packet_time, cf_info->earliest_packet_time_tsprec, cf_info));\n        if (cap_latest_packet_time)\n            printf(\"Latest packet time:   %s\\n\", absolute_time_string(&cf_info->latest_packet_time, cf_info->latest_packet_time_tsprec, cf_info));\n        if (cap_data_rate_byte) {\n            printf(\"Data byte rate:      \");\n            if (machine_readable) {\n                print_value(\"\", 2, \" bytes/sec\",   cf_info->data_rate);\n            } else {\n                size_string = format_size((int64_t)cf_info->data_rate, FORMAT_SIZE_UNIT_BYTES_S, 0);\n                printf (\"%s\\n\", size_string);\n                g_free(size_string);\n            }\n        }\n        if (cap_data_rate_bit) {\n            printf(\"Data bit rate:       \");\n            if (machine_readable) {\n                print_value(\"\", 2, \" bits/sec\",    cf_info->data_rate*8);\n            } else {\n                size_string = format_size((int64_t)(cf_info->data_rate*8), FORMAT_SIZE_UNIT_BITS_S, 0);\n                printf (\"%s\\n\", size_string);\n                g_free(size_string);\n            }\n        }\n    }\n    if (cap_packet_size)    printf(\"Average packet size: %.2f bytes\\n\",        cf_info->packet_size);\n    if (cf_info->times_known) {\n        if (cap_packet_rate) {\n            printf(\"Average packet rate: \");\n            if (machine_readable) {\n                print_value(\"\", 2, \" packets/sec\", cf_info->packet_rate);\n            } else {\n                size_string = format_size((int64_t)cf_info->packet_rate, FORMAT_SIZE_UNIT_PACKETS_S, 0);\n                printf (\"%s\\n\", size_string);\n                g_free(size_string);\n            }\n        }\n    }\n    if (cap_file_hashes) {\n        printf     (\"SHA256:              %s\\n\", file_sha256);\n        printf     (\"SHA1:                %s\\n\", file_sha1);\n    }\n    if (cap_order)          printf     (\"Strict time order:   %s\\n\", order_string(cf_info->order));\n\n    bool has_multiple_sections = (wtap_file_get_num_shbs(cf_info->wth) > 1);\n\n    for (unsigned int section_number = 0;\n            section_number < wtap_file_get_num_shbs(cf_info->wth);\n            section_number++) {\n        wtap_block_t shb;\n\n        // If we have more than one section, add headers for each section.\n        if (has_multiple_sections)\n            printf(\"Section %u:\\n\\n\", section_number);\n\n        shb = wtap_file_get_shb(cf_info->wth, section_number);\n        if (shb != NULL) {\n            if (cap_file_more_info) {\n                char *str;\n\n                if (wtap_block_get_string_option_value(shb, OPT_SHB_HARDWARE, &str) == WTAP_OPTTYPE_SUCCESS)\n                    show_option_string(\"Capture hardware:    \", str);\n                if (wtap_block_get_string_option_value(shb, OPT_SHB_OS, &str) == WTAP_OPTTYPE_SUCCESS)\n                    show_option_string(\"Capture oper-sys:    \", str);\n                if (wtap_block_get_string_option_value(shb, OPT_SHB_USERAPPL, &str) == WTAP_OPTTYPE_SUCCESS)\n                    show_option_string(\"Capture application: \", str);\n            }\n            if (cap_comment) {\n                unsigned int i;\n                char *str;\n\n                for (i = 0; wtap_block_get_nth_string_option_value(shb, OPT_COMMENT, i, &str) == WTAP_OPTTYPE_SUCCESS; i++) {\n                    show_option_string(\"Capture comment:     \", str);\n                }\n            }\n        }\n    }\n\n    if (pkt_comments && cf_info->pkt_cmts != NULL) {\n      for (p = cf_info->pkt_cmts; p != NULL; prev = p, p = p->next, g_free(prev)) {\n        if (machine_readable){\n          printf(\"Packet %d Comment:    %s\\n\", p->recno, g_strescape(p->cmt, NULL));\n        } else {\n          printf(\"Packet %d Comment:    %s\\n\", p->recno, p->cmt);\n        }\n        g_free(p->cmt);\n      }\n    }\n\n    if (cap_file_idb && cf_info->num_interfaces != 0) {\n        unsigned int i;\n        ws_assert(cf_info->num_interfaces == cf_info->idb_info_strings->len);\n        printf     (\"Number of interfaces in file: %u\\n\", cf_info->num_interfaces);\n        for (i = 0; i < cf_info->idb_info_strings->len; i++) {\n            char *s = g_array_index(cf_info->idb_info_strings, char*, i);\n            uint32_t packet_count = 0;\n            if (i < cf_info->interface_packet_counts->len)\n                packet_count = g_array_index(cf_info->interface_packet_counts, uint32_t, i);\n            printf   (\"Interface #%u info:\\n\", i);\n            printf   (\"%s\", s);\n            printf   (\"                     Number of packets = %u\\n\", packet_count);\n        }\n    }\n\n    if (cap_file_nrb) {\n        if (num_ipv4_addresses != 0)\n            printf   (\"Number of resolved IPv4 addresses in file: %u\\n\", num_ipv4_addresses);\n        if (num_ipv6_addresses != 0)\n            printf   (\"Number of resolved IPv6 addresses in file: %u\\n\", num_ipv6_addresses);\n    }\n    if (cap_file_dsb) {\n        if (num_decryption_secrets != 0)\n            printf   (\"Number of decryption secrets in file: %u\\n\", num_decryption_secrets);\n    }\n}\n\nstatic void\nputsep(void)\n{\n    if (field_separator) putchar(field_separator);\n}\n\nstatic void\nputquote(void)\n{\n    if (quote_char) putchar(quote_char);\n}\n\nstatic void\nprint_stats_table_header_label(const char *label)\n{\n    putsep();\n    putquote();\n    printf(\"%s\", label);\n    putquote();\n}\n\nstatic void\nprint_stats_table_header(capture_info *cf_info)\n{\n    pkt_cmt *p;\n    char    *buf;\n    size_t   buf_len;\n\n    putquote();\n    printf(\"File name\");\n    putquote();\n\n    if (cap_file_type)      print_stats_table_header_label(\"File type\");\n    if (cap_file_encap)     print_stats_table_header_label(\"File encapsulation\");\n    if (cap_file_more_info) print_stats_table_header_label(\"File time precision\");\n    if (cap_snaplen) {\n        print_stats_table_header_label(\"Packet size limit\");\n        print_stats_table_header_label(\"Packet size limit min (inferred)\");\n        print_stats_table_header_label(\"Packet size limit max (inferred)\");\n    }\n    if (cap_packet_count)   print_stats_table_header_label(\"Number of packets\");\n    if (cap_file_size)      print_stats_table_header_label(\"File size (bytes)\");\n    if (cap_data_size)      print_stats_table_header_label(\"Data size (bytes)\");\n    if (cap_duration)       print_stats_table_header_label(\"Capture duration (seconds)\");\n    if (cap_earliest_packet_time) print_stats_table_header_label(\"Start time\");\n    if (cap_latest_packet_time) print_stats_table_header_label(\"End time\");\n    if (cap_data_rate_byte) print_stats_table_header_label(\"Data byte rate (bytes/sec)\");\n    if (cap_data_rate_bit)  print_stats_table_header_label(\"Data bit rate (bits/sec)\");\n    if (cap_packet_size)    print_stats_table_header_label(\"Average packet size (bytes)\");\n    if (cap_packet_rate)    print_stats_table_header_label(\"Average packet rate (packets/sec)\");\n    if (cap_file_hashes) {\n        print_stats_table_header_label(\"SHA256\");\n        print_stats_table_header_label(\"SHA1\");\n    }\n    if (cap_order)          print_stats_table_header_label(\"Strict time order\");\n    if (cap_file_more_info) {\n        print_stats_table_header_label(\"Capture hardware\");\n        print_stats_table_header_label(\"Capture oper-sys\");\n        print_stats_table_header_label(\"Capture application\");\n    }\n    if (cap_comment)        print_stats_table_header_label(\"Capture comment\");\n\n    if (pkt_comments && cf_info->pkt_cmts != NULL) {\n      /* Packet 2^64 Comment\" + NULL */\n      buf_len = strlen(\"Packet 18446744073709551616 Comment\") + 1;\n      buf = (char *)g_malloc0(buf_len);\n\n      for (p = cf_info->pkt_cmts; p != NULL; p = p->next) {\n        snprintf(buf, buf_len, \"Packet %d Comment\", p->recno);\n        print_stats_table_header_label(buf);\n      }\n    }\n\n    printf(\"\\n\");\n}\n\nstatic void\nprint_stats_table(const char *filename, capture_info *cf_info)\n{\n    const char           *file_type_string, *file_encap_string;\n    pkt_cmt               *p, *prev;\n\n    /* Build printable strings for various stats */\n    file_type_string = wtap_file_type_subtype_name(cf_info->file_type);\n    file_encap_string = wtap_encap_name(cf_info->file_encap);\n\n    if (filename) {\n        putquote();\n        printf(\"%s\", filename);\n        putquote();\n    }\n\n    if (cap_file_type) {\n        putsep();\n        putquote();\n        printf(\"%s\", file_type_string);\n        putquote();\n    }\n\n    /* ToDo: If WTAP_ENCAP_PER_PACKET, show the list of encapsulations encountered;\n     *       Output a line for each different encap with all fields repeated except\n     *        the encapsulation field which has \"Per Packet: ...\" for each\n     *        encapsulation type seen ?\n     */\n    if (cap_file_encap) {\n        putsep();\n        putquote();\n        printf(\"%s\", file_encap_string);\n        putquote();\n    }\n\n    if (cap_file_more_info) {\n        putsep();\n        putquote();\n        printf(\"%s\", wtap_tsprec_string(cf_info->file_tsprec));\n        putquote();\n    }\n\n    if (cap_snaplen) {\n        putsep();\n        putquote();\n        if (cf_info->snap_set)\n            printf(\"%u\", cf_info->snaplen);\n        else\n            printf(\"(not set)\");\n        putquote();\n        if (cf_info->snaplen_max_inferred > 0) {\n            putsep();\n            putquote();\n            printf(\"%u\", cf_info->snaplen_min_inferred);\n            putquote();\n            putsep();\n            putquote();\n            printf(\"%u\", cf_info->snaplen_max_inferred);\n            putquote();\n        }\n        else {\n            putsep();\n            putquote();\n            printf(\"n/a\");\n            putquote();\n            putsep();\n            putquote();\n            printf(\"n/a\");\n            putquote();\n        }\n    }\n\n    if (cap_packet_count) {\n        putsep();\n        putquote();\n        printf(\"%u\", cf_info->packet_count);\n        putquote();\n    }\n\n    if (cap_file_size) {\n        putsep();\n        putquote();\n        printf(\"%\" PRId64, cf_info->filesize);\n        putquote();\n    }\n\n    if (cap_data_size) {\n        putsep();\n        putquote();\n        printf(\"%\" PRIu64, cf_info->packet_bytes);\n        putquote();\n    }\n\n    if (cap_duration) {\n        putsep();\n        putquote();\n        printf(\"%s\", relative_time_string(&cf_info->duration, cf_info->duration_tsprec, cf_info, false));\n        putquote();\n    }\n\n    if (cap_earliest_packet_time) {\n        putsep();\n        putquote();\n        printf(\"%s\", absolute_time_string(&cf_info->earliest_packet_time, cf_info->earliest_packet_time_tsprec, cf_info));\n        putquote();\n    }\n\n    if (cap_latest_packet_time) {\n        putsep();\n        putquote();\n        printf(\"%s\", absolute_time_string(&cf_info->latest_packet_time, cf_info->latest_packet_time_tsprec, cf_info));\n        putquote();\n    }\n\n    if (cap_data_rate_byte) {\n        putsep();\n        putquote();\n        if (cf_info->times_known)\n            printf(\"%.2f\", cf_info->data_rate);\n        else\n            printf(\"n/a\");\n        putquote();\n    }\n\n    if (cap_data_rate_bit) {\n        putsep();\n        putquote();\n        if (cf_info->times_known)\n            printf(\"%.2f\", cf_info->data_rate*8);\n        else\n            printf(\"n/a\");\n        putquote();\n    }\n\n    if (cap_packet_size) {\n        putsep();\n        putquote();\n        printf(\"%.2f\", cf_info->packet_size);\n        putquote();\n    }\n\n    if (cap_packet_rate) {\n        putsep();\n        putquote();\n        if (cf_info->times_known)\n            printf(\"%.2f\", cf_info->packet_rate);\n        else\n            printf(\"n/a\");\n        putquote();\n    }\n\n    if (cap_file_hashes) {\n        putsep();\n        putquote();\n        printf(\"%s\", file_sha256);\n        putquote();\n\n        putsep();\n        putquote();\n        printf(\"%s\", file_sha1);\n        putquote();\n    }\n\n    if (cap_order) {\n        putsep();\n        putquote();\n        printf(\"%s\", order_string(cf_info->order));\n        putquote();\n    }\n\n    for (unsigned section_number = 0;\n            section_number < wtap_file_get_num_shbs(cf_info->wth);\n            section_number++) {\n        wtap_block_t shb;\n\n        shb = wtap_file_get_shb(cf_info->wth, section_number);\n        if (cap_file_more_info) {\n            char *str;\n\n            putsep();\n            putquote();\n            if (wtap_block_get_string_option_value(shb, OPT_SHB_HARDWARE, &str) == WTAP_OPTTYPE_SUCCESS) {\n                printf(\"%s\", str);\n            }\n            putquote();\n\n            putsep();\n            putquote();\n            if (wtap_block_get_string_option_value(shb, OPT_SHB_OS, &str) == WTAP_OPTTYPE_SUCCESS) {\n                printf(\"%s\", str);\n            }\n            putquote();\n\n            putsep();\n            putquote();\n            if (wtap_block_get_string_option_value(shb, OPT_SHB_USERAPPL, &str) == WTAP_OPTTYPE_SUCCESS) {\n                printf(\"%s\", str);\n            }\n            putquote();\n        }\n\n        /*\n         * One might argue that the following is silly to put into a table format,\n         * but oh well note that there may be *more than one* of each of these types\n         * of options.  To mitigate some of the potential silliness the if(cap_comment)\n         * block is moved AFTER the if(cap_file_more_info) block.  This will make any\n         * comments the last item(s) in each row.  We now have a new -K option to\n         * disable cap_comment to more easily manage the potential silliness.\n         * Potential silliness includes multiple comments (therefore resulting in\n         * more than one additional column and/or comments with embedded newlines\n         * and/or possible delimiters).\n         *\n         * To mitigate embedded newlines and other special characters, use -M\n         */\n        if (cap_comment) {\n            unsigned int i;\n            char *opt_comment;\n            bool have_cap = false;\n\n            for (i = 0; wtap_block_get_nth_string_option_value(shb, OPT_COMMENT, i, &opt_comment) == WTAP_OPTTYPE_SUCCESS; i++) {\n                have_cap = true;\n                putsep();\n                putquote();\n                if (machine_readable){\n                  printf(\"%s\", g_strescape(opt_comment, NULL));\n                } else {\n                  printf(\"%s\", opt_comment);\n                }\n                putquote();\n            }\n            if(!have_cap) {\n                /* Maintain column alignment when we have no OPT_COMMENT */\n                putsep();\n                putquote();\n                putquote();\n            }\n        }\n\n    }\n\n    if (pkt_comments && cf_info->pkt_cmts != NULL) {\n      for(p = cf_info->pkt_cmts; p != NULL; prev = p, p = p->next, g_free(prev)) {\n        putsep();\n        putquote();\n        if (machine_readable) {\n          printf(\"%s\", g_strescape(p->cmt, NULL));\n        } else {\n          printf(\"%s\", p->cmt);\n        }\n        g_free(p->cmt);\n        putquote();\n      }\n    }\n\n    printf(\"\\n\");\n}\n\nstatic void\ncleanup_capture_info(capture_info *cf_info)\n{\n    unsigned int i;\n    ws_assert(cf_info != NULL);\n\n    g_free(cf_info->encap_counts);\n    cf_info->encap_counts = NULL;\n\n    g_array_free(cf_info->interface_packet_counts, true);\n    cf_info->interface_packet_counts = NULL;\n\n    if (cf_info->idb_info_strings) {\n        for (i = 0; i < cf_info->idb_info_strings->len; i++) {\n            char *s = g_array_index(cf_info->idb_info_strings, char*, i);\n            g_free(s);\n        }\n        g_array_free(cf_info->idb_info_strings, true);\n    }\n    cf_info->idb_info_strings = NULL;\n}\n\nstatic void\ncount_ipv4_address(const unsigned int addr _U_, const char *name _U_, const bool static_entry _U_)\n{\n    num_ipv4_addresses++;\n}\n\nstatic void\ncount_ipv6_address(const ws_in6_addr *addrp _U_, const char *name _U_, const bool static_entry _U_)\n{\n    num_ipv6_addresses++;\n}\n\nstatic void\ncount_decryption_secret(uint32_t secrets_type _U_, const void *secrets _U_, unsigned int size _U_)\n{\n    /* XXX - count them based on the secrets type (which is an opaque code,\n       not a small integer)? */\n    num_decryption_secrets++;\n}\n\nstatic void\nhash_to_str(const unsigned char *hash, size_t length, char *str)\n{\n    int i;\n\n    for (i = 0; i < (int) length; i++) {\n        snprintf(str+(i*2), 3, \"%02x\", hash[i]);\n    }\n}\n\nstatic void\ncalculate_hashes(const char *filename)\n{\n    FILE  *fh;\n    size_t hash_bytes;\n\n    (void) g_strlcpy(file_sha256, \"<unknown>\", HASH_STR_SIZE);\n    (void) g_strlcpy(file_sha1, \"<unknown>\", HASH_STR_SIZE);\n\n    if (cap_file_hashes) {\n        fh = ws_fopen(filename, \"rb\");\n        if (fh && hd) {\n            while((hash_bytes = fread(hash_buf, 1, HASH_BUF_SIZE, fh)) > 0) {\n                gcry_md_write(hd, hash_buf, hash_bytes);\n            }\n            gcry_md_final(hd);\n            hash_to_str(gcry_md_read(hd, GCRY_MD_SHA256), HASH_SIZE_SHA256, file_sha256);\n            hash_to_str(gcry_md_read(hd, GCRY_MD_SHA1), HASH_SIZE_SHA1, file_sha1);\n        }\n        if (fh) fclose(fh);\n        if (hd) gcry_md_reset(hd);\n    }\n}\n\nstatic int\nprocess_cap_file(const char *filename, bool need_separator)\n{\n    int                   status = 0;\n    int                   err;\n    char                 *err_info;\n    int64_t               size;\n    int64_t               data_offset;\n\n    uint32_t              packet = 0;\n    int64_t               bytes  = 0;\n    uint32_t              snaplen_min_inferred = 0xffffffff;\n    uint32_t              snaplen_max_inferred =          0;\n    wtap_rec              rec;\n    capture_info          cf_info;\n    bool                  have_times = true;\n    nstime_t              earliest_packet_time;\n    int                   earliest_packet_time_tsprec;\n    nstime_t              latest_packet_time;\n    int                   latest_packet_time_tsprec;\n    nstime_t              cur_time;\n    nstime_t              prev_time;\n    bool                  know_order = false;\n    order_t               order = IN_ORDER;\n    unsigned int                 i;\n    wtapng_iface_descriptions_t *idb_info;\n\n    pkt_cmt *pc = NULL, *prev = NULL;\n\n    cf_info.wth = wtap_open_offline(filename, WTAP_TYPE_AUTO, &err, &err_info, false);\n    if (!cf_info.wth) {\n        cfile_open_failure_message(filename, err, err_info);\n        return 2;\n    }\n\n    /*\n     * Calculate the checksums. Do this after wtap_open_offline, so we don't\n     * bother calculating them for files that are not known capture types\n     * where we wouldn't print them anyway.\n     */\n    calculate_hashes(filename);\n\n    if (need_separator && long_report) {\n        printf(\"\\n\");\n    }\n\n    nstime_set_zero(&earliest_packet_time);\n    earliest_packet_time_tsprec = WTAP_TSPREC_UNKNOWN;\n    nstime_set_zero(&latest_packet_time);\n    latest_packet_time_tsprec = WTAP_TSPREC_UNKNOWN;\n    nstime_set_zero(&cur_time);\n    nstime_set_zero(&prev_time);\n\n    cf_info.encap_counts = g_new0(int,WTAP_NUM_ENCAP_TYPES);\n\n    idb_info = wtap_file_get_idb_info(cf_info.wth);\n\n    ws_assert(idb_info->interface_data != NULL);\n\n    cf_info.pkt_cmts = NULL;\n    cf_info.num_interfaces = idb_info->interface_data->len;\n    cf_info.interface_packet_counts  = g_array_sized_new(false, true, sizeof(uint32_t), cf_info.num_interfaces);\n    g_array_set_size(cf_info.interface_packet_counts, cf_info.num_interfaces);\n    cf_info.pkt_interface_id_unknown = 0;\n\n    g_free(idb_info);\n    idb_info = NULL;\n\n    /* Zero out the counters for the callbacks. */\n    num_ipv4_addresses = 0;\n    num_ipv6_addresses = 0;\n    num_decryption_secrets = 0;\n\n    /* Register callbacks for new name<->address maps from the file and\n       decryption secrets from the file. */\n    wtap_set_cb_new_ipv4(cf_info.wth, count_ipv4_address);\n    wtap_set_cb_new_ipv6(cf_info.wth, count_ipv6_address);\n    wtap_set_cb_new_secrets(cf_info.wth, count_decryption_secret);\n\n    /* Tally up data that we need to parse through the file to find */\n    wtap_rec_init(&rec, 1514);\n    while (wtap_read(cf_info.wth, &rec, &err, &err_info, &data_offset))  {\n        if (rec.presence_flags & WTAP_HAS_TS) {\n            prev_time = cur_time;\n            cur_time = rec.ts;\n            if (packet == 0) {\n                earliest_packet_time = rec.ts;\n                earliest_packet_time_tsprec = rec.tsprec;\n                latest_packet_time  = rec.ts;\n                latest_packet_time_tsprec = rec.tsprec;\n                prev_time  = rec.ts;\n            }\n            if (nstime_cmp(&cur_time, &prev_time) < 0) {\n                order = NOT_IN_ORDER;\n            }\n            if (nstime_cmp(&cur_time, &earliest_packet_time) < 0) {\n                earliest_packet_time = cur_time;\n                earliest_packet_time_tsprec = rec.tsprec;\n            }\n            if (nstime_cmp(&cur_time, &latest_packet_time) > 0) {\n                latest_packet_time = cur_time;\n                latest_packet_time_tsprec = rec.tsprec;\n            }\n        } else {\n            have_times = false; /* at least one packet has no time stamp */\n            if (order != NOT_IN_ORDER)\n                order = ORDER_UNKNOWN;\n        }\n\n        if (rec.rec_type == REC_TYPE_PACKET) {\n            bytes += rec.rec_header.packet_header.len;\n            packet++;\n            /* packet comments */\n            if (pkt_comments && wtap_block_count_option(rec.block, OPT_COMMENT) > 0) {\n              char *cmt_buff;\n              for (i = 0; wtap_block_get_nth_string_option_value(rec.block, OPT_COMMENT, i, &cmt_buff) == WTAP_OPTTYPE_SUCCESS; i++) {\n                pc = g_new0(pkt_cmt, 1);\n\n                pc->recno = packet;\n                pc->cmt = g_strdup(cmt_buff);\n                pc->next = NULL;\n\n                if (prev == NULL)\n                  cf_info.pkt_cmts = pc;\n                else\n                  prev->next = pc;\n\n                prev = pc;\n              }\n            }\n\n            /* If caplen < len for a rcd, then presumably           */\n            /* 'Limit packet capture length' was done for this rcd. */\n            /* Keep track as to the min/max actual snapshot lengths */\n            /*  seen for this file.                                 */\n            if (rec.rec_header.packet_header.caplen < rec.rec_header.packet_header.len) {\n                if (rec.rec_header.packet_header.caplen < snaplen_min_inferred)\n                    snaplen_min_inferred = rec.rec_header.packet_header.caplen;\n                if (rec.rec_header.packet_header.caplen > snaplen_max_inferred)\n                    snaplen_max_inferred = rec.rec_header.packet_header.caplen;\n            }\n\n            if ((rec.rec_header.packet_header.pkt_encap > 0) &&\n                    (rec.rec_header.packet_header.pkt_encap < WTAP_NUM_ENCAP_TYPES)) {\n                cf_info.encap_counts[rec.rec_header.packet_header.pkt_encap] += 1;\n            } else {\n                fprintf(stderr, \"capinfos: Unknown packet encapsulation %d in frame %u of file \\\"%s\\\"\\n\",\n                        rec.rec_header.packet_header.pkt_encap, packet, filename);\n            }\n\n            /* Packet interface_id info */\n            if (rec.presence_flags & WTAP_HAS_INTERFACE_ID) {\n                /* cf_info.num_interfaces is size, not index, so it's one more than max index */\n                if (rec.rec_header.packet_header.interface_id >= cf_info.num_interfaces) {\n                    /*\n                     * OK, re-fetch the number of interfaces, as there might have\n                     * been an interface that was in the middle of packets, and\n                     * grow the array to be big enough for the new number of\n                     * interfaces.\n                     */\n                    idb_info = wtap_file_get_idb_info(cf_info.wth);\n\n                    cf_info.num_interfaces = idb_info->interface_data->len;\n                    g_array_set_size(cf_info.interface_packet_counts, cf_info.num_interfaces);\n\n                    g_free(idb_info);\n                    idb_info = NULL;\n                }\n                if (rec.rec_header.packet_header.interface_id < cf_info.num_interfaces) {\n                    g_array_index(cf_info.interface_packet_counts, uint32_t,\n                            rec.rec_header.packet_header.interface_id) += 1;\n                }\n                else {\n                    cf_info.pkt_interface_id_unknown += 1;\n                }\n            }\n            else {\n                /* it's for interface_id 0 */\n                if (cf_info.num_interfaces != 0) {\n                    g_array_index(cf_info.interface_packet_counts, uint32_t, 0) += 1;\n                }\n                else {\n                    cf_info.pkt_interface_id_unknown += 1;\n                }\n            }\n        }\n\n        wtap_rec_reset(&rec);\n    } /* while */\n    wtap_rec_cleanup(&rec);\n\n    /*\n     * Get IDB info strings.\n     * We do this at the end, so we can get information for all IDBs in\n     * the file, even those that come after packet records, and so that\n     * we get, for example, a count of the number of statistics entries\n     * for each interface as of the *end* of the file.\n     */\n    idb_info = wtap_file_get_idb_info(cf_info.wth);\n\n    cf_info.idb_info_strings = g_array_sized_new(false, false, sizeof(char*), cf_info.num_interfaces);\n    cf_info.num_interfaces = idb_info->interface_data->len;\n    for (i = 0; i < cf_info.num_interfaces; i++) {\n        const wtap_block_t if_descr = g_array_index(idb_info->interface_data, wtap_block_t, i);\n        char *s = wtap_get_debug_if_descr(if_descr, 21, \"\\n\");\n        g_array_append_val(cf_info.idb_info_strings, s);\n    }\n\n    g_free(idb_info);\n    idb_info = NULL;\n\n    if (err != 0) {\n        fprintf(stderr,\n                \"capinfos: An error occurred after reading %u packets from \\\"%s\\\".\\n\",\n                packet, filename);\n        cfile_read_failure_message(filename, err, err_info);\n        if (err == WTAP_ERR_SHORT_READ) {\n            /* Don't give up completely with this one. */\n            status = 1;\n            fprintf(stderr,\n                    \"  (will continue anyway, checksums might be incorrect)\\n\");\n        } else {\n            cleanup_capture_info(&cf_info);\n            wtap_close(cf_info.wth);\n            return 2;\n        }\n    }\n\n    /* File size */\n    size = wtap_file_size(cf_info.wth, &err);\n    if (size == -1) {\n        fprintf(stderr,\n                \"capinfos: Can't get size of \\\"%s\\\": %s.\\n\",\n                filename, g_strerror(err));\n        cleanup_capture_info(&cf_info);\n        wtap_close(cf_info.wth);\n        return 2;\n    }\n\n    cf_info.filesize = size;\n\n    /* File Type */\n    cf_info.file_type = wtap_file_type_subtype(cf_info.wth);\n    cf_info.compression_type = wtap_get_compression_type(cf_info.wth);\n\n    /* File Encapsulation */\n    cf_info.file_encap = wtap_file_encap(cf_info.wth);\n\n    cf_info.file_tsprec = wtap_file_tsprec(cf_info.wth);\n\n    /* Packet size limit (snaplen) */\n    cf_info.snaplen = wtap_snapshot_length(cf_info.wth);\n    if (cf_info.snaplen > 0)\n        cf_info.snap_set = true;\n    else\n        cf_info.snap_set = false;\n\n    cf_info.snaplen_min_inferred = snaplen_min_inferred;\n    cf_info.snaplen_max_inferred = snaplen_max_inferred;\n\n    /* # of packets */\n    cf_info.packet_count = packet;\n\n    /* File Times */\n    cf_info.times_known = have_times;\n    cf_info.earliest_packet_time = earliest_packet_time;\n    cf_info.earliest_packet_time_tsprec = earliest_packet_time_tsprec;\n    cf_info.latest_packet_time = latest_packet_time;\n    cf_info.latest_packet_time_tsprec = latest_packet_time_tsprec;\n    nstime_delta(&cf_info.duration, &latest_packet_time, &earliest_packet_time);\n    /* Duration precision is the higher of the earliest and latest packet timestamp precisions. */\n    if (cf_info.latest_packet_time_tsprec > cf_info.earliest_packet_time_tsprec)\n        cf_info.duration_tsprec = cf_info.latest_packet_time_tsprec;\n    else\n        cf_info.duration_tsprec = cf_info.earliest_packet_time_tsprec;\n    cf_info.know_order = know_order;\n    cf_info.order = order;\n\n    /* Number of packet bytes */\n    cf_info.packet_bytes = bytes;\n\n    cf_info.data_rate   = 0.0;\n    cf_info.packet_rate = 0.0;\n    cf_info.packet_size = 0.0;\n\n    if (packet > 0) {\n        double delta_time = nstime_to_sec(&latest_packet_time) - nstime_to_sec(&earliest_packet_time);\n        if (delta_time > 0.0) {\n            cf_info.data_rate   = (double)bytes  / delta_time; /* Data rate per second */\n            cf_info.packet_rate = (double)packet / delta_time; /* packet rate per second */\n        }\n        cf_info.packet_size = (double)bytes / packet;                  /* Avg packet size      */\n    }\n\n    if (!long_report && table_report_header) {\n      print_stats_table_header(&cf_info);\n    }\n\n    if (long_report) {\n        print_stats(filename, &cf_info);\n    } else {\n        print_stats_table(filename, &cf_info);\n    }\n\n    cleanup_capture_info(&cf_info);\n    wtap_close(cf_info.wth);\n\n    return status;\n}\n\nstatic void\nprint_usage(FILE *output)\n{\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: capinfos [options] <infile> ...\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"General infos:\\n\");\n    fprintf(output, \"  -t display the capture file type\\n\");\n    fprintf(output, \"  -E display the capture file encapsulation\\n\");\n    fprintf(output, \"  -I display the capture file interface information\\n\");\n    fprintf(output, \"  -F display additional capture file information\\n\");\n    fprintf(output, \"  -H display the SHA256 and SHA1 hashes of the file\\n\");\n    fprintf(output, \"  -k display the capture comment\\n\");\n    fprintf(output, \"  -p display individual packet comments\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Size infos:\\n\");\n    fprintf(output, \"  -c display the number of packets\\n\");\n    fprintf(output, \"  -s display the size of the file (in bytes)\\n\");\n    fprintf(output, \"  -d display the total length of all packets (in bytes)\\n\");\n    fprintf(output, \"  -l display the packet size limit (snapshot length)\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Time infos:\\n\");\n    fprintf(output, \"  -u display the capture duration (in seconds)\\n\");\n    fprintf(output, \"  -a display the timestamp of the earliest packet\\n\");\n    fprintf(output, \"  -e display the timestamp of the latest packet\\n\");\n    fprintf(output, \"  -o display the capture file chronological status (True/False)\\n\");\n    fprintf(output, \"  -S display earliest and latest packet timestamps as seconds\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Statistic infos:\\n\");\n    fprintf(output, \"  -y display average data rate (in bytes/sec)\\n\");\n    fprintf(output, \"  -i display average data rate (in bits/sec)\\n\");\n    fprintf(output, \"  -z display average packet size (in bytes)\\n\");\n    fprintf(output, \"  -x display average packet rate (in packets/sec)\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Metadata infos:\\n\");\n    fprintf(output, \"  -n display number of resolved IPv4 and IPv6 addresses\\n\");\n    fprintf(output, \"  -D display number of decryption secrets\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Output format:\\n\");\n    fprintf(output, \"  -L generate long report (default)\\n\");\n    fprintf(output, \"  -T generate table report\\n\");\n    fprintf(output, \"  -M display machine-readable values in long reports\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Table report options:\\n\");\n    fprintf(output, \"  -R generate header record (default)\\n\");\n    fprintf(output, \"  -r do not generate header record\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"  -B separate infos with TAB character (default)\\n\");\n    fprintf(output, \"  -m separate infos with comma (,) character\\n\");\n    fprintf(output, \"  -b separate infos with SPACE character\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"  -N do not quote infos (default)\\n\");\n    fprintf(output, \"  -q quote infos with single quotes (')\\n\");\n    fprintf(output, \"  -Q quote infos with double quotes (\\\")\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Miscellaneous:\\n\");\n    fprintf(output, \"  -h, --help               display this help and exit\\n\");\n    fprintf(output, \"  -v, --version            display version info and exit\\n\");\n    fprintf(output, \"  -C cancel processing if file open fails (default is to continue)\\n\");\n    fprintf(output, \"  -A generate all infos (default)\\n\");\n    fprintf(output, \"  -K disable displaying the capture comment\\n\");\n    fprintf(output, \"  -P disable displaying individual packet comments\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Options are processed from left to right order with later options superseding\\n\");\n    fprintf(output, \"or adding to earlier options.\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"If no options are given the default is to display all infos in long report\\n\");\n    fprintf(output, \"output format.\\n\");\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char  *configuration_init_error;\n    bool need_separator = false;\n    int    opt;\n    int    overall_error_status = EXIT_SUCCESS;\n    static const struct ws_option long_options[] = {\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        {0, 0, 0, 0 }\n    };\n\n    int status = 0;\n\n    /* Set the program name. */\n    g_set_prgname(\"capinfos\");\n\n    /*\n     * Set the C-language locale to the native environment and set the\n     * code page to UTF-8 on Windows.\n     */\n#ifdef _WIN32\n    setlocale(LC_ALL, \".UTF-8\");\n#else\n    setlocale(LC_ALL, \"\");\n#endif\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, WS_EXIT_INVALID_OPTION);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n    /* Get the decimal point. */\n    decimal_point = g_strdup(localeconv()->decimal_point);\n\n#ifdef _WIN32\n    create_app_running_mutex();\n#endif /* _WIN32 */\n\n    /*\n     * Get credential information for later use.\n     */\n    init_process_policies();\n\n    /*\n     * Attempt to get the pathname of the directory containing the\n     * executable file.\n     */\n    configuration_init_error = configuration_init(argv[0]);\n    if (configuration_init_error != NULL) {\n        fprintf(stderr,\n                \"capinfos: Can't get pathname of directory containing the capinfos program: %s.\\n\",\n                configuration_init_error);\n        g_free(configuration_init_error);\n    }\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"Capinfos\", NULL, NULL);\n\n    init_report_failure_message(\"capinfos\");\n\n    wtap_init(true);\n\n    /* Process the options */\n    while ((opt = ws_getopt_long(argc, argv, \"abcdehiklmnopqrstuvxyzABCDEFHIKLMNPQRST\", long_options, NULL)) !=-1) {\n\n        switch (opt) {\n\n            case 't':\n                if (report_all_infos) disable_all_infos();\n                cap_file_type = true;\n                break;\n\n            case 'E':\n                if (report_all_infos) disable_all_infos();\n                cap_file_encap = true;\n                break;\n\n            case 'l':\n                if (report_all_infos) disable_all_infos();\n                cap_snaplen = true;\n                break;\n\n            case 'c':\n                if (report_all_infos) disable_all_infos();\n                cap_packet_count = true;\n                break;\n\n            case 's':\n                if (report_all_infos) disable_all_infos();\n                cap_file_size = true;\n                break;\n\n            case 'd':\n                if (report_all_infos) disable_all_infos();\n                cap_data_size = true;\n                break;\n\n            case 'u':\n                if (report_all_infos) disable_all_infos();\n                cap_duration = true;\n                break;\n\n            case 'a':\n                if (report_all_infos) disable_all_infos();\n                cap_earliest_packet_time = true;\n                break;\n\n            case 'e':\n                if (report_all_infos) disable_all_infos();\n                cap_latest_packet_time = true;\n                break;\n\n            case 'S':\n                time_as_secs = true;\n                break;\n\n            case 'y':\n                if (report_all_infos) disable_all_infos();\n                cap_data_rate_byte = true;\n                break;\n\n            case 'i':\n                if (report_all_infos) disable_all_infos();\n                cap_data_rate_bit = true;\n                break;\n\n            case 'z':\n                if (report_all_infos) disable_all_infos();\n                cap_packet_size = true;\n                break;\n\n            case 'x':\n                if (report_all_infos) disable_all_infos();\n                cap_packet_rate = true;\n                break;\n\n            case 'H':\n                if (report_all_infos) disable_all_infos();\n                cap_file_hashes = true;\n                break;\n\n            case 'o':\n                if (report_all_infos) disable_all_infos();\n                cap_order = true;\n                break;\n\n            case 'k':\n                if (report_all_infos) disable_all_infos();\n                cap_comment = true;\n                break;\n\n            case 'p':\n                if (report_all_infos) disable_all_infos();\n                pkt_comments = true;\n                break;\n\n            case 'K':\n                cap_comment = false;\n                break;\n\n            case 'P':\n                pkt_comments = false;\n                break;\n\n            case 'F':\n                if (report_all_infos) disable_all_infos();\n                cap_file_more_info = true;\n                break;\n\n            case 'I':\n                if (report_all_infos) disable_all_infos();\n                cap_file_idb = true;\n                break;\n\n            case 'n':\n                if (report_all_infos) disable_all_infos();\n                cap_file_nrb = true;\n                break;\n\n            case 'D':\n                if (report_all_infos) disable_all_infos();\n                cap_file_dsb = true;\n                break;\n\n            case 'C':\n                stop_after_failure = true;\n                break;\n\n            case 'A':\n                enable_all_infos();\n                break;\n\n            case 'L':\n                long_report = true;\n                break;\n\n            case 'T':\n                long_report = false;\n                break;\n\n            case 'M':\n                machine_readable = true;\n                break;\n\n            case 'R':\n                table_report_header = true;\n                break;\n\n            case 'r':\n                table_report_header = false;\n                break;\n\n            case 'N':\n                quote_char = '\\0';\n                break;\n\n            case 'q':\n                quote_char = '\\'';\n                break;\n\n            case 'Q':\n                quote_char = '\"';\n                break;\n\n            case 'B':\n                field_separator = '\\t';\n                break;\n\n            case 'm':\n                field_separator = ',';\n                break;\n\n            case 'b':\n                field_separator = ' ';\n                break;\n\n            case 'h':\n                show_help_header(\"Print various information (infos) about capture files.\");\n                print_usage(stdout);\n                goto exit;\n                break;\n\n            case 'v':\n                show_version();\n                goto exit;\n                break;\n\n            case '?':              /* Bad flag - print usage message */\n                print_usage(stderr);\n                overall_error_status = WS_EXIT_INVALID_OPTION;\n                goto exit;\n                break;\n        }\n    }\n\n    if ((argc - ws_optind) < 1) {\n        print_usage(stderr);\n        overall_error_status = WS_EXIT_INVALID_OPTION;\n        goto exit;\n    }\n\n    if (cap_file_hashes) {\n        gcry_check_version(NULL);\n        gcry_md_open(&hd, GCRY_MD_SHA256, 0);\n        if (hd)\n            gcry_md_enable(hd, GCRY_MD_SHA1);\n\n        hash_buf = (char *)g_malloc(HASH_BUF_SIZE);\n    }\n\n    overall_error_status = 0;\n\n    for (opt = ws_optind; opt < argc; opt++) {\n\n        status = process_cap_file(argv[opt], need_separator);\n        if (status) {\n            /* Something failed.  It's been reported; remember that processing\n               one file failed and, if -C was specified, stop. */\n            overall_error_status = status;\n            if (stop_after_failure)\n                goto exit;\n        }\n        if (status != 2) {\n            /* Either it succeeded or it got a \"short read\" but printed\n               information anyway.  Note that we need a blank line before\n               the next file's information, to separate it from the\n               previous file. */\n            need_separator = true;\n        }\n    }\n\nexit:\n    g_free(hash_buf);\n    gcry_md_close(hd);\n    wtap_cleanup();\n    free_progdirs();\n    return overall_error_status;\n}\n"
        },
        {
          "name": "capture",
          "type": "tree",
          "content": null
        },
        {
          "name": "captype.c",
          "type": "blob",
          "size": 4.201171875,
          "content": "/* captype.c\n * Reports capture file type\n *\n * Based on capinfos.c\n * Copyright 2004 Ian Schorr\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <locale.h>\n\n#include <wsutil/ws_getopt.h>\n\n#include <glib.h>\n\n#include <wiretap/wtap.h>\n\n#include <wsutil/cmdarg_err.h>\n#include <wsutil/file_util.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/privileges.h>\n#include <cli_main.h>\n#include <wsutil/version_info.h>\n\n#ifdef HAVE_PLUGINS\n#include <wsutil/plugins.h>\n#endif\n\n#include <wsutil/str_util.h>\n#include <wsutil/wslog.h>\n\n#include \"ui/failure_message.h\"\n\nstatic void\nprint_usage(FILE *output)\n{\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: captype [options] <infile> ...\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Miscellaneous:\\n\");\n    fprintf(output, \"  -h, --help               display this help and exit\\n\");\n    fprintf(output, \"  -v, --version            display version info and exit\\n\");\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char  *configuration_init_error;\n    wtap  *wth;\n    int    err;\n    char *err_info;\n    int    i;\n    int    opt;\n    int    overall_error_status;\n    static const struct ws_option long_options[] = {\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        {0, 0, 0, 0 }\n    };\n\n    /* Set the program name. */\n    g_set_prgname(\"captype\");\n\n    /*\n     * Set the C-language locale to the native environment and set the\n     * code page to UTF-8 on Windows.\n     */\n#ifdef _WIN32\n    setlocale(LC_ALL, \".UTF-8\");\n#else\n    setlocale(LC_ALL, \"\");\n#endif\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, 1);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n#ifdef _WIN32\n    create_app_running_mutex();\n#endif /* _WIN32 */\n\n    /*\n     * Get credential information for later use.\n     */\n    init_process_policies();\n\n    /*\n     * Attempt to get the pathname of the directory containing the\n     * executable file.\n     */\n    configuration_init_error = configuration_init(argv[0]);\n    if (configuration_init_error != NULL) {\n        fprintf(stderr,\n                \"captype: Can't get pathname of directory containing the captype program: %s.\\n\",\n                configuration_init_error);\n        g_free(configuration_init_error);\n    }\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"Captype\", NULL, NULL);\n\n    init_report_failure_message(\"captype\");\n\n    wtap_init(true);\n\n    /* Process the options */\n    while ((opt = ws_getopt_long(argc, argv, \"hv\", long_options, NULL)) !=-1) {\n\n        switch (opt) {\n\n            case 'h':\n                show_help_header(\"Print the file types of capture files.\");\n                print_usage(stdout);\n                exit(0);\n                break;\n\n            case 'v':\n                show_version();\n                exit(0);\n                break;\n\n            case '?':              /* Bad flag - print usage message */\n                print_usage(stderr);\n                exit(1);\n                break;\n        }\n    }\n\n    if (argc < 2) {\n        print_usage(stderr);\n        return 1;\n    }\n\n    overall_error_status = 0;\n\n    for (i = 1; i < argc; i++) {\n        wth = wtap_open_offline(argv[i], WTAP_TYPE_AUTO, &err, &err_info, false);\n\n        if(wth) {\n            printf(\"%s: %s\\n\", argv[i], wtap_file_type_subtype_name(wtap_file_type_subtype(wth)));\n            wtap_close(wth);\n        } else {\n            if (err == WTAP_ERR_FILE_UNKNOWN_FORMAT)\n                printf(\"%s: unknown\\n\", argv[i]);\n            else {\n                cfile_open_failure_message(argv[i], err, err_info);\n                overall_error_status = 2; /* remember that an error has occurred */\n            }\n        }\n\n    }\n\n    wtap_cleanup();\n    free_progdirs();\n    return overall_error_status;\n}\n"
        },
        {
          "name": "cfile.c",
          "type": "blob",
          "size": 0.47265625,
          "content": "/* cfile.c\n * capture_file GUI-independent manipulation\n * Vassilii Khachaturov <vassilii@tarunz.org>\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n\n#include <glib.h>\n\n#include <epan/packet.h>\n\n#include \"cfile.h\"\n\nvoid\ncap_file_init(capture_file *cf)\n{\n    /* Initialize the capture file struct */\n    memset(cf, 0, sizeof(capture_file));\n}\n"
        },
        {
          "name": "cfile.h",
          "type": "blob",
          "size": 7.7099609375,
          "content": "/** @file\n *\n * capture_file definition & GUI-independent manipulation\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#ifndef __CFILE_H__\n#define __CFILE_H__\n\n#include <epan/epan.h>\n#include <epan/column-info.h>\n#include <epan/dfilter/dfilter.h>\n#include <epan/frame_data.h>\n#include <epan/frame_data_sequence.h>\n#include <wiretap/wtap.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n/* Current state of file. */\ntypedef enum {\n    FILE_CLOSED,                  /* No file open */\n    FILE_READ_PENDING,            /* A file to read, but haven't opened it yet */\n    FILE_READ_IN_PROGRESS,        /* Reading a file we've opened */\n    FILE_READ_ABORTED,            /* Read aborted by user */\n    FILE_READ_DONE                /* Read completed */\n} file_state;\n\n/* Requested packets rescan action. */\ntypedef enum {\n    RESCAN_NONE = 0,              /* No rescan requested */\n    RESCAN_SCAN,                  /* Request rescan without full redissection. */\n    RESCAN_REDISSECT              /* Request full redissection. */\n} rescan_type;\n\n/* Character set for text search. */\ntypedef enum {\n    SCS_NARROW_AND_WIDE,\n    SCS_NARROW,\n    SCS_WIDE\n        /* add EBCDIC when it's implemented */\n} search_charset_t;\n\ntypedef enum {\n    SD_FORWARD,\n    SD_BACKWARD\n} search_direction;\n\n/*\n * Packet provider for programs using a capture file.\n */\nstruct packet_provider_data {\n    wtap        *wth;                    /* Wiretap session */\n    const frame_data *ref;\n    frame_data  *prev_dis;\n    frame_data  *prev_cap;\n    frame_data_sequence *frames;         /* Sequence of frames, if we're keeping that information */\n    GTree       *frames_modified_blocks; /* BST with modified blocks for frames (key = frame_data) */\n};\n\ntypedef struct _capture_file {\n    epan_t                     *epan;\n    file_state                  state;                /* Current state of capture file */\n    char                       *filename;             /* Name of capture file */\n    char                       *source;               /* Temp file source, e.g. \"Pipe from elsewhere\" */\n    bool                        is_tempfile;          /* Is capture file a temporary file? */\n    bool                        unsaved_changes;      /* Does the capture file have changes that have not been saved? */\n    bool                        stop_flag;            /* Stop current processing (loading, searching, etc.) */\n\n    int64_t                     f_datalen;            /* Size of capture file data (uncompressed) */\n    uint16_t                    cd_t;                 /* File type of capture file */\n    unsigned int                open_type;            /* open_routine index+1 used, if selected, or WTAP_TYPE_AUTO */\n    wtap_compression_type       compression_type;     /* Compression type of the file, or uncompressed */\n    int                         lnk_t;                /* File link-layer type; could be WTAP_ENCAP_PER_PACKET */\n    GArray                     *linktypes;            /* Array of packet link-layer types */\n    uint32_t                    count;                /* Total number of frames */\n    uint64_t                    packet_comment_count; /* Number of comments in frames (could be >1 per frame... */\n    uint32_t                    displayed_count;      /* Number of displayed frames */\n    uint32_t                    marked_count;         /* Number of marked frames */\n    uint32_t                    ignored_count;        /* Number of ignored frames */\n    uint32_t                    ref_time_count;       /* Number of time referenced frames */\n    bool                        drops_known;          /* true if we know how many packets were dropped */\n    uint32_t                    drops;                /* Dropped packets */\n    nstime_t                    elapsed_time;         /* Elapsed time */\n    int                         snap;                 /* Maximum captured packet length; 0 if unknown */\n    dfilter_t                  *rfcode;               /* Compiled read filter program */\n    dfilter_t                  *dfcode;               /* Compiled display filter program */\n    char                       *dfilter;              /* Display filter string */\n    bool                        redissecting;         /* true if currently redissecting (cf_redissect_packets) */\n    bool                        read_lock;            /* true if currently processing a file (cf_read) */\n    rescan_type                 redissection_queued;  /* Queued redissection type. */\n    /* search */\n    char                       *sfilter;              /* Filter, hex value, or string being searched */\n    /* XXX: Some of these booleans should be enums; they're exclusive cases */\n    bool                        hex;                  /* true if \"Hex value\" search was last selected */\n    bool                        string;               /* true if \"String\" (or \"Regex\"?) search was last selected */\n    bool                        summary_data;         /* true if \"String\" search in \"Packet list\" (Info column) was last selected */\n    bool                        decode_data;          /* true if \"String\" search in \"Packet details\" was last selected */\n    bool                        packet_data;          /* true if \"String\" search in \"Packet data\" was last selected */\n    uint32_t                    search_pos;           /* Byte position of first byte found in a hex search */\n    uint32_t                    search_len;           /* Length of bytes matching the search */\n    bool                        case_type;            /* true if case-insensitive text search */\n    ws_regex_t                 *regex;                /* Set if regular expression search */\n    search_charset_t            scs_type;             /* Character set for text search */\n    search_direction            dir;                  /* Direction in which to do searches */\n    bool                        search_in_progress;   /* true if user just clicked OK in the Find dialog or hit <control>N/B */\n    /* packet provider */\n    struct packet_provider_data provider;\n    /* frames */\n    uint32_t                    first_displayed;      /* Frame number of first frame displayed */\n    uint32_t                    last_displayed;       /* Frame number of last frame displayed */\n    /* Data for currently selected frame */\n    column_info                 cinfo;                /* Column formatting information */\n    frame_data                 *current_frame;        /* Frame data */\n    epan_dissect_t             *edt;                  /* Protocol dissection */\n    field_info                 *finfo_selected;       /* Field info */\n    wtap_rec                    rec;                  /* Record header */\n    Buffer                      buf;                  /* Record data */\n\n    void *                      window;               /* Top-level window associated with file */\n    unsigned long               computed_elapsed;     /* Elapsed time to load the file (in msec). */\n\n    uint32_t                    cum_bytes;\n} capture_file;\n\nextern void cap_file_init(capture_file *cf);\n\nconst nstime_t *cap_file_provider_get_frame_ts(struct packet_provider_data *prov, uint32_t frame_num);\nconst char *cap_file_provider_get_interface_name(struct packet_provider_data *prov, uint32_t interface_id, unsigned section_number);\nconst char *cap_file_provider_get_interface_description(struct packet_provider_data *prov, uint32_t interface_id, unsigned section_number);\nwtap_block_t cap_file_provider_get_modified_block(struct packet_provider_data *prov, const frame_data *fd);\nvoid cap_file_provider_set_modified_block(struct packet_provider_data *prov, frame_data *fd, const wtap_block_t new_block);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* cfile.h */\n"
        },
        {
          "name": "cli_main.c",
          "type": "blob",
          "size": 1.908203125,
          "content": "/*\n * Compile and link this with all CLI programs where the main routine\n * should get UTF-8 arguments on Windows.  In those programs, include the\n * cli_main.h header to rename main to real_main on Windows.\n *\n * This is used in software licensed under the GPLv2, and its license MUST\n * be compatible with that license.\n *\n * This is used in software licensed under the Apache 2.0 license, and its\n * license MUST be compatible with that license.\n *\n * For that purpose, we use the MIT (X11) license.\n *\n * SPDX-License-Identifier: MIT\n */\n\n#include \"cli_main.h\"\n\n#ifdef _WIN32\n#include <stdlib.h>\n#include <stdio.h>\n#include <windows.h>\n\nint\nwmain(int argc, wchar_t *wc_argv[])\n{\n\tchar **argv;\n\tint i;\n\tint return_code;\n\n\targv = (char **)malloc((argc + 1) * sizeof(char *));\n\tif (argv == NULL) {\n\t\tfprintf(stderr, \"Out of memory for converted argument list\\n\");\n\t\treturn 2;\n\t}\n\tfor (i = 0; i < argc; i++) {\n\t\t/*\n\t\t * XXX = use WC_ERR_INVALID_CHARS rather than 0, and fail if\n\t\t * the argument isn't valid UTF-16?\n\t\t */\n\t\tint width;\n\t\tchar *utf8_string;\n\n\t\twidth = WideCharToMultiByte(CP_UTF8, 0, wc_argv[i], -1, NULL, 0,\n\t\t    NULL, NULL);\n\t\tif (width == 0) {\n\t\t\tfprintf(stderr, \"WideCharToMultiByte failed: %d\\n\",\n\t\t\t    width);\n\t\t\treturn 2;\n\t\t}\n\t\tutf8_string = malloc(width);\n\t\tif (utf8_string == NULL) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"Out of memory for converted argument list\\n\");\n\t\t\treturn 2;\n\t\t}\n\t\tif (WideCharToMultiByte(CP_UTF8, 0, wc_argv[i], -1, utf8_string,\n\t\t    width, NULL, NULL) == 0) {\n\t\t\tfprintf(stderr, \"WideCharToMultiByte failed: %d\\n\",\n\t\t\t    width);\n\t\t\treturn 2;\n\t\t}\n\t\targv[i] = utf8_string;\n\t}\n\targv[i] = NULL;\n\t/*\n\t * The original \"main\" routine was renamed to \"real_main\" via a macro in\n\t * the cli_main.h header file since either \"main\" or \"wmain\" can be\n\t * defined on Windows, but not both.\n\t */\n\treturn_code = real_main(argc, argv);\n\tfor (i = 0; i < argc; i++) {\n\t\tfree(argv[i]);\n\t}\n\tfree(argv);\n\treturn return_code;\n}\n#endif\n"
        },
        {
          "name": "cli_main.h",
          "type": "blob",
          "size": 0.6748046875,
          "content": "/** @file\n *\n * Declaration of the real main routine, for all CLI programs where the\n * main routine should get UTF-8 arguments on Windows.  In those programs,\n * in the file that defines the main routine, include this header and link\n * those programs with cli_main.c.\n *\n * This is used in software licensed under the GPLv2, and its license MUST\n * be compatible with that license.\n *\n * This is used in software licensed under the Apache 2.0 license, and its\n * license MUST be compatible with that license.\n *\n * For that purpose, we use the MIT (X11) license.\n *\n * SPDX-License-Identifier: MIT\n */\n\n#ifdef _WIN32\nint real_main(int argc, char *argv[]);\n#define main    real_main\n#endif\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake_uninstall.cmake.in",
          "type": "blob",
          "size": 1.388671875,
          "content": "#\n# Wireshark - Network traffic analyzer\n# By Gerald Combs <gerald@wireshark.org>\n# Copyright 1998 Gerald Combs\n#\n# SPDX-License-Identifier: BSD-3-Clause\n#\n\nif(NOT EXISTS \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\")\n\tmessage(FATAL_ERROR \"Cannot find install manifest: @CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\")\nendif(NOT EXISTS \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\")\n\nfile(READ \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\" files)\nstring(REGEX REPLACE \"\\n\" \";\" files \"${files}\")\nforeach(file ${files})\n\tmessage(STATUS \"Uninstalling $ENV{DESTDIR}${file}\")\n\tif(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n\t\texec_program(\n\t\t    \"@CMAKE_COMMAND@\" ARGS \"-E remove \\\"$ENV{DESTDIR}${file}\\\"\"\n\t\t    OUTPUT_VARIABLE rm_out\n\t\t    RETURN_VALUE rm_retval\n\t\t)\n\t\tif(NOT \"${rm_retval}\" STREQUAL 0)\n\t\t\tmessage(FATAL_ERROR \"Problem when removing $ENV{DESTDIR}${file}\")\n\t\tendif(NOT \"${rm_retval}\" STREQUAL 0)\n\telse(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n\t\tmessage(STATUS \"File $ENV{DESTDIR}${file} does not exist.\")\n\tendif(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\nendforeach(file)\n\n#\n# Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n#\n# Local variables:\n# c-basic-offset: 2\n# tab-width: 2\n# indent-tabs-mode: nil\n# End:\n#\n# vi: set shiftwidth=2 tabstop=2 noexpandtab:\n# :indentSize=8:tabSize=8:noTabs=false:\n#\n"
        },
        {
          "name": "cmakeconfig.h.in",
          "type": "blob",
          "size": 13.271484375,
          "content": "/* cmakeconfig.h.in */\n\n#ifndef __CONFIG_H__\n#define __CONFIG_H__\n\n/* Note: You cannot use earlier #defines in later #cmakedefines (cmake 2.6.2). */\n\n/* Name of package */\n#define PACKAGE \"wireshark\"\n\n#define VERSION_EXTRA \"$ENV{WIRESHARK_VERSION_EXTRA}\"\n\n/* Version number of Wireshark and associated utilities */\n#define VERSION \"${PROJECT_VERSION}${VERSION_EXTRA}\"\n#define VERSION_MAJOR ${PROJECT_MAJOR_VERSION}\n#define VERSION_MINOR ${PROJECT_MINOR_VERSION}\n#define VERSION_MICRO ${PROJECT_PATCH_VERSION}\n\n/* Version number of Stratoshark and associated utilities */\n#define STRATOSHARK_VERSION \"${STRATOSHARK_VERSION}${VERSION_EXTRA}\"\n\n#define PLUGIN_PATH_ID \"${PLUGIN_PATH_ID}\"\n#define VERSION_FLAVOR \"${VERSION_FLAVOR}\"\n\n/* Build wsutil with SIMD optimization */\n#cmakedefine HAVE_SSE4_2 1\n\n/* Define to 1 if we want to enable plugins */\n#cmakedefine HAVE_PLUGINS 1\n\n/*  Define to 1 if we check hf conflict */\n#cmakedefine ENABLE_CHECK_FILTER 1\n\n/* Link Wireshark libraries statically */\n#cmakedefine ENABLE_STATIC 1\n\n/* Enable AddressSanitizer (and LeakSanitizer on clang/gcc) */\n#cmakedefine ENABLE_ASAN 1\n\n/* Enable LeakSanitizer standalone */\n#cmakedefine ENABLE_LSAN 1\n\n/* Define to 1 if you have the <arpa/inet.h> header file. */\n#cmakedefine HAVE_ARPA_INET_H 1\n\n/* Define to 1 if you have the `clock_gettime` function. */\n#cmakedefine HAVE_CLOCK_GETTIME 1\n\n/* Define to 1 if you have the `timespec_get` function. */\n#cmakedefine HAVE_TIMESPEC_GET 1\n\n/* Define to 1 if you have the `localtime_r` function. */\n#cmakedefine HAVE_LOCALTIME_R 1\n\n/* Define to 1 if you have the `gmtime_r` function. */\n#cmakedefine HAVE_GMTIME_R 1\n\n/* Define to 1 if you have the `timegm` function. */\n#cmakedefine HAVE_TIMEGM 1\n\n/* Define to 1 if you have the `tzset` function. */\n#cmakedefine HAVE_TZSET 1\n\n/* Define to use the MaxMind DB library */\n#cmakedefine HAVE_MAXMINDDB 1\n/* MaxmindDB version */\n#define MAXMINDDB_VERSION \"${MAXMINDDB_VERSION}\"\n\n\n/* Define to 1 if you have the <ifaddrs.h> header file. */\n#cmakedefine HAVE_IFADDRS_H 1\n\n/* Define to 1 if yu have the `fseeko` function. */\n#cmakedefine HAVE_FSEEKO 1\n\n/* Define to 1 if you have the `getexecname' function. */\n#cmakedefine HAVE_GETEXECNAME 1\n\n/* Define to 1 if you have the `getifaddrs' function. */\n#cmakedefine HAVE_GETIFADDRS 1\n\n/* Define if LIBSSH support is enabled */\n#cmakedefine HAVE_LIBSSH 1\n\n/* Define if you have the 'dlget' function. */\n#cmakedefine HAVE_DLGET 1\n\n/* Define to 1 if you have the <grp.h> header file. */\n#cmakedefine HAVE_GRP_H 1\n\n/* Define to use heimdal kerberos */\n#cmakedefine HAVE_HEIMDAL_KERBEROS 1\n\n/* Define to 1 if you have the `krb5_pac_verify' function. */\n#cmakedefine HAVE_KRB5_PAC_VERIFY 1\n\n/* Define to 1 if you have the `krb5_c_fx_cf2_simple' function. */\n#cmakedefine HAVE_KRB5_C_FX_CF2_SIMPLE 1\n\n/* Define to 1 if you have the `decode_krb5_enc_tkt_part' function. */\n#cmakedefine HAVE_DECODE_KRB5_ENC_TKT_PART 1\n\n/* Define to 1 if you have the `encode_krb5_enc_tkt_part' function. */\n#cmakedefine HAVE_ENCODE_KRB5_ENC_TKT_PART 1\n\n/* Define to 1 if you have the `inflatePrime' function. */\n#cmakedefine HAVE_INFLATEPRIME 1\n\n/* Define to 1 if you have the `zng_gzopen' function. */\n#cmakedefine WITH_GZFILEOP 1\n\n/* Define to 1 if you have the `issetugid' function. */\n#cmakedefine HAVE_ISSETUGID 1\n\n/* Define to use kerberos */\n#cmakedefine HAVE_KERBEROS 1\n\n/* Define to use nghttp2 */\n#cmakedefine HAVE_NGHTTP2 1\n\n/* Define to use nghttp3 */\n#cmakedefine HAVE_NGHTTP3 1\n\n/* Define to use the libcap library */\n#cmakedefine HAVE_LIBCAP 1\n\n/* Define to use GnuTLS library */\n#cmakedefine HAVE_LIBGNUTLS 1\n\n/* Define to 1 if GnuTLS was built with pkcs11 support. */\n#cmakedefine HAVE_GNUTLS_PKCS11 1\n\n/* Enable libnl support */\n#cmakedefine HAVE_LIBNL 1\n\n/* libnl version 1 */\n#cmakedefine HAVE_LIBNL1 1\n\n/* libnl version 2 */\n#cmakedefine HAVE_LIBNL2 1\n\n/* libnl version 3 */\n#cmakedefine HAVE_LIBNL3 1\n\n/* Define to use libpcap library */\n#cmakedefine HAVE_LIBPCAP 1\n\n/* Define to 1 if you have the `smi' library (-lsmi). */\n#cmakedefine HAVE_LIBSMI 1\n\n/* Define to 1 if libsmi exports a version string (and that symbol is visible). */\n#cmakedefine HAVE_SMI_VERSION_STRING 1\n\n/* Define to use zlib library */\n#cmakedefine HAVE_ZLIB 1\n\n/* Define to use zlib-ng library */\n#cmakedefine HAVE_ZLIBNG 1\n#define ZLIBNG_VERSION_STRING \"${ZLIBNG_VERSION_STRING}\"\n\n/* Define to use the minizip library */\n#cmakedefine HAVE_MINIZIP 1\n#define MINIZIP_VERSION \"${MINIZIP_VERSION}\"\n\n/* Define to use the minizip-ng library */\n#cmakedefine HAVE_MINIZIPNG 1\n#define MINIZIPNG_VERSION \"${MINIZIPNG_VERSION}\"\n\n/* Define if `dos_date' (with underscore) field exists in `zip_fileinfo'  */\n#cmakedefine HAVE_MZCOMPAT_DOS_DATE 1\n\n/* Define to use brotli library */\n#cmakedefine HAVE_BROTLI 1\n\n/* Define to use lz4 library */\n#cmakedefine HAVE_LZ4 1\n\n/* Check for lz4frame */\n#cmakedefine HAVE_LZ4FRAME_H 1\n\n/* Define to use snappy library */\n#cmakedefine HAVE_SNAPPY 1\n#define SNAPPY_VERSION \"${SNAPPY_VERSION}\"\n\n/* Define to use zstd library */\n#cmakedefine HAVE_ZSTD 1\n\n/* Define to 1 if you have the <linux/sockios.h> header file. */\n#cmakedefine HAVE_LINUX_SOCKIOS_H 1\n\n/* Define to 1 if you have the <linux/if_bonding.h> header file. */\n#cmakedefine HAVE_LINUX_IF_BONDING_H 1\n\n/* Define to use Lua */\n#cmakedefine HAVE_LUA 1\n\n/* Define to 1 if we have Lua with Unicode for Windows patches. */\n#cmakedefine HAVE_LUA_UNICODE 1\n\n/* The size of the lua_Integer type, if we have Lua. */\n#cmakedefine LUA_INTEGER_SIZE ${LUA_INTEGER_SIZE}\n\n/* Define to use MIT kerberos */\n#cmakedefine HAVE_MIT_KERBEROS 1\n\n/* Define to 1 if you have the <netdb.h> header file. */\n#cmakedefine HAVE_NETDB_H 1\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n#cmakedefine HAVE_NETINET_IN_H 1\n\n/* nl80211.h is new enough */\n#cmakedefine HAVE_NL80211 1\n\n/* SET_CHANNEL is supported */\n#cmakedefine HAVE_NL80211_CMD_SET_CHANNEL 1\n\n/* SPLIT_WIPHY_DUMP is supported */\n#cmakedefine HAVE_NL80211_SPLIT_WIPHY_DUMP 1\n\n/* VHT_CAPABILITY is supported */\n#cmakedefine HAVE_NL80211_VHT_CAPABILITY 1\n\n/* Define to 1 if you have macOS frameworks */\n#cmakedefine HAVE_MACOS_FRAMEWORKS 1\n\n/* Define to 1 if you have the macOS CFPropertyListCreateWithStream function */\n#cmakedefine HAVE_CFPROPERTYLISTCREATEWITHSTREAM 1\n\n/* Define to 1 if you have the `pcap_open' function. */\n#cmakedefine HAVE_PCAP_OPEN 1\n\n/* Define to 1 if you have libpcap/Npcap remote capturing support. */\n#cmakedefine HAVE_PCAP_REMOTE 1\n\n/* Define to 1 if you have the `pcap_setsampling' function. */\n#cmakedefine HAVE_PCAP_SETSAMPLING 1\n\n/* Define to 1 if you have the `pcap_set_tstamp_precision' function. */\n#cmakedefine HAVE_PCAP_SET_TSTAMP_PRECISION 1\n\n/* Define to 1 if you have the `pcap_set_tstamp_type' function. */\n#cmakedefine HAVE_PCAP_SET_TSTAMP_TYPE 1\n\n/* Define to 1 if you have the `PCAP_ERROR_PROMISC_PERM_DENIED' symbol. */\n#cmakedefine HAVE_PCAP_ERROR_PROMISC_PERM_DENIED 1\n\n/* Define to 1 if you have the `PCAP_WARNING_TSTAMP_TYPE_NOTSUP' symbol. */\n#cmakedefine HAVE_PCAP_WARNING_TSTAMP_TYPE_NOTSUP 1\n\n/* Define to 1 if you have the <pwd.h> header file. */\n#cmakedefine HAVE_PWD_H 1\n\n/* Define to 1 if you want to playing SBC by standalone BlueZ SBC library */\n#cmakedefine HAVE_SBC 1\n\n/* Define to 1 if you have the SpanDSP library. */\n#cmakedefine HAVE_SPANDSP 1\n\n/* Define to 1 if you have the bcg729 library. */\n#cmakedefine HAVE_BCG729 1\n\n/* Define to 1 if you have the opencore-amrnb library. */\n#cmakedefine HAVE_AMRNB 1\n\n/* Define to 1 if you have the ilbc library. */\n#cmakedefine HAVE_ILBC 1\n\n/* Define to 1 if you have the opus library. */\n#cmakedefine HAVE_OPUS 1\n\n/* Define to 1 if you have the lixbml2 library. */\n#cmakedefine HAVE_LIBXML2 1\n\n/* Define to 1 if you have the `setresgid' function. */\n#cmakedefine HAVE_SETRESGID 1\n\n/* Define to 1 if you have the `setresuid' function. */\n#cmakedefine HAVE_SETRESUID 1\n\n/* Define to 1 if you have the Sparkle or WinSparkle library */\n#cmakedefine HAVE_SOFTWARE_UPDATE 1\n\n/* Define if you have the 'strptime' function. */\n#cmakedefine HAVE_STRPTIME 1\n\n/* Define if you have the 'memmem' function. */\n#cmakedefine HAVE_MEMMEM 1\n\n/* Define if you have the 'memrchr' function. */\n#cmakedefine HAVE_MEMRCHR 1\n\n/* Define if you have the 'strerrorname_np' function. */\n#cmakedefine HAVE_STRERRORNAME_NP 1\n\n/* Define if you have the 'vasprintf' function. */\n#cmakedefine HAVE_VASPRINTF 1\n\n/* Define to 1 if `st_birthtime' is a member of `struct stat'. */\n#cmakedefine HAVE_STRUCT_STAT_ST_BIRTHTIME 1\n\n/* Define if st_blksize field exists in struct stat */\n#cmakedefine HAVE_STRUCT_STAT_ST_BLKSIZE 1\n\n/* Define to 1 if `__st_birthtime' is a member of `struct stat'. */\n#cmakedefine HAVE_STRUCT_STAT___ST_BIRTHTIME 1\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#cmakedefine HAVE_SYS_SOCKET_H 1\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#cmakedefine HAVE_SYS_TIME_H 1\n\n/* Define to 1 if you have the <sys/utsname.h> header file. */\n#cmakedefine HAVE_SYS_UTSNAME_H 1\n\n/* Define to 1 if you have the <sys/wait.h> header file. */\n#cmakedefine HAVE_SYS_WAIT_H 1\n\n/* Define if tm_gmtoff field exists in struct tm */\n#cmakedefine HAVE_STRUCT_TM_TM_GMTOFF 1\n\n/* Define if tm_zone field exists in struct tm */\n#cmakedefine HAVE_STRUCT_TM_TM_ZONE 1\n\n/* Define if tzname array exists */\n#cmakedefine HAVE_TZNAME 1\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#cmakedefine HAVE_UNISTD_H 1\n\n/* Define if we have QtMultimedia */\n#cmakedefine QT_MULTIMEDIA_LIB 1\n\n/* Define if we have QtDBus */\n#cmakedefine QT_DBUS_LIB 1\n\n/* Build androiddump with libpcap instead of wireshark stuff */\n#cmakedefine ANDROIDDUMP_USE_LIBPCAP 1\n\n/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a\n   `char[]'. */\n/* Note: not use in the code */\n#cmakedefine YYTEXT_POINTER\n\n/* Define to 1 if the 'ssize_t' type exists. */\n#cmakedefine HAVE_SSIZE_T 1\n\n/* Define to 1 if we are using the msys2 environment to build. */\n#cmakedefine HAVE_MSYSTEM 1\n\n/* Define if we have sinsp and scap */\n#cmakedefine HAVE_SINSP 1\n\n#ifdef HAVE_SINSP\n#define SINSP_VERSION_MAJOR ${SINSP_VERSION_MAJOR}\n#define SINSP_VERSION_MINOR ${SINSP_VERSION_MINOR}\n#define SINSP_VERSION_MICRO ${SINSP_VERSION_MICRO}\n#endif\n\n#if defined(_MSC_VER)\n#  define strncasecmp strnicmp\n#  define popen       _popen\n#  define pclose      _pclose\n#endif\n\n#if defined(_WIN32)\n   /*\n    * Flex (v 2.5.35) uses this symbol to \"exclude\" unistd.h\n    */\n#  define YY_NO_UNISTD_H\n\n#  ifndef __STDC__\n#    define __STDC__ 0\n#  endif\n\n/*\n * Make sure everyone is using the same API and that it's sufficient\n * for our needs.\n * This should match the following:\n * - The <compatibility><application> section in resources\\wireshark.exe.manifest.in\n * - The WinVer parts of packaging\\nsis\\wireshark.nsi\n * - The VersionNT parts of packaging\\wix\\Prerequisites.wxi\n */\n#  ifndef NTDDI_VERSION\n#  define NTDDI_VERSION   NTDDI_WIN10\n#  endif\n\n#  ifndef _WIN32_WINNT\n#  define _WIN32_WINNT    _WIN32_WINNT_WIN10\n#  endif\n#endif\n\n#define PCRE2_CODE_UNIT_WIDTH  8\n\n/*\n * If HAVE_PCAP_REMOTE is defined, it forces the WinPcap header files to\n * define things required for remote capture, by defining HAVE_REMOTE.\n *\n * With all versions of the WinPcap SDK, if:\n *\n *    1) you are building with any current WinPcap SDK;\n *    2) you do not define HAVE_REMOTE before including pcap.h (or\n *       pcap/pcap.h);\n *    3) you define a struct pcap_stat and pass it to a call to\n *       pcap_stats();\n *    4) the system you're running on has WinPcap, rather than Npcap,\n *       installed;\n *\n * whatever is in memory after the struct pcap_stat may get overwritten,\n * with unpredictable results, because the pcap_stats() implementation for\n * WinPcap will assume that the structure has the additional members that\n * are added if and only if HAVE_REMOTE is defined, and will fill them in,\n * even if they're not there.\n *\n * Yes, this is a WinPcap bug; if your project has a public header file\n * that checks or otherwise uses a #define that's defined by your project's\n * configuration process, and don't ensure that it's always defined\n * appropriately when that header file is included, before its first use,\n * you have made a mistake.\n *\n * In libpcap 1.7.0 and later, the pcap_stats() implementation for WinPcap\n * will not fill those fields in; however, no WinPcap implementation was\n * based on that recent a libpcap release, so they all have the bug.\n *\n * Npcap was originally based on libpcap 1.8.0, and later releases are\n * based on later releases of libpcap, so they will not overwrite memory\n * past the end of the structure.\n *\n * The header file bug is fixed in libpcap 1.9.0 or later - the fields\n * are present on Windows, regardless of whether HAVE_REMOTE is defined\n * or not when the header is included (and are not present on UN*X), so\n * if you build with an SDK with libpcap 1.9.0 or later headers, you\n * do not need to define HAVE_REMOTE before including pcap.h (including it\n * will make no difference).\n *\n * No version of the WinPcap SDK provided libpcap 1.9.0-or-later headers.\n * The Npcap SDK, as of SDK version 1.04, provides them, so this is\n * only necessary for building with the WinPcap SDK.\n *\n * WinPcap isn't supported at runtime anymore, but it's possible to build\n * with the WinPcap SDK and run with Npcap, so long as this is defined.\n * That's what currently happens when cross-compiling with Fedora Linux,\n * which includes a MinGW WinPcap package.\n */\n#ifdef HAVE_PCAP_REMOTE\n#define HAVE_REMOTE\n#endif\n\n#include <ws_log_defs.h>\n\n#endif /* __CONFIG_H__ */\n"
        },
        {
          "name": "dftest.c",
          "type": "blob",
          "size": 15.712890625,
          "content": "/* dftest.c\n * Shows display filter byte-code, for debugging dfilter routines.\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <locale.h>\n#include <string.h>\n#include <errno.h>\n\n#include <glib.h>\n\n#include <ws_exit_codes.h>\n\n#include <epan/epan.h>\n#include <epan/timestamp.h>\n#include <epan/prefs.h>\n#include <epan/dfilter/dfilter.h>\n#include <epan/dfilter/dfilter-macro.h>\n\n#ifdef HAVE_PLUGINS\n#include <wsutil/plugins.h>\n#endif\n#include <wsutil/filesystem.h>\n#include <wsutil/file_util.h>\n#include <wsutil/privileges.h>\n#include <wsutil/wslog.h>\n#include <wsutil/ws_getopt.h>\n#include <wsutil/utf8_entities.h>\n\n#include <wiretap/wtap.h>\n\n#include \"ui/util.h\"\n#include \"wsutil/cmdarg_err.h\"\n#include \"ui/failure_message.h\"\n#include \"wsutil/version_info.h\"\n\nstatic int opt_verbose;\nstatic int opt_debug_level; /* currently up to 2 */\nstatic int opt_flex;\nstatic int opt_lemon;\nstatic int opt_syntax_tree;\nstatic int opt_return_vals;\nstatic int opt_timer;\nstatic long opt_optimize = 1;\nstatic int opt_show_types;\nstatic int opt_dump_refs;\nstatic int opt_dump_macros;\n\nstatic int64_t elapsed_expand;\nstatic int64_t elapsed_compile;\n\n#ifndef HAVE_GETLINE\n/* Maximum supported line length of a filter. */\n#define MAX_LINELEN     4096\n\n/** Read a line without trailing (CR)LF. Returns -1 on failure.  */\nstatic int\nfgetline(char *buf, int size, FILE *fp)\n{\n    if (fgets(buf, size, fp)) {\n        int len = (int)strcspn(buf, \"\\r\\n\");\n        buf[len] = '\\0';\n        return len;\n    }\n    return -1;\n\n} /* fgetline */\n#endif /* HAVE_GETLINE */\n\nstatic void\nputloc(FILE *fp, df_loc_t loc)\n{\n    for (long i = 0; i < loc.col_start; i++) {\n        fputc(' ', fp);\n    }\n    fputc('^', fp);\n\n    for (size_t l = loc.col_len; l > 1; l--) {\n        fputc('~', fp);\n    }\n    fputc('\\n', fp);\n}\n\nWS_NORETURN static void\nprint_usage(int status)\n{\n    FILE *fp = stdout;\n    fprintf(fp, \"\\n\");\n    fprintf(fp, \"Usage: dftest [OPTIONS] -- EXPRESSION\\n\");\n    fprintf(fp, \"Options:\\n\");\n    fprintf(fp, \"  -V, --verbose       enable verbose mode\\n\");\n    fprintf(fp, \"  -C <config profile> run with specified configuration profile\\n\");\n    fprintf(fp, \"  -d, --debug[=N]     increase or set debug level\\n\");\n    fprintf(fp, \"  -D                  set maximum debug level\\n\");\n    fprintf(fp, \"  -f, --flex          enable Flex debug trace\\n\");\n    fprintf(fp, \"  -l, --lemon         enable Lemon debug trace\\n\");\n    fprintf(fp, \"  -s, --syntax        print syntax tree\\n\");\n    fprintf(fp, \"  -m  --macros        print saved macros\\n\");\n    fprintf(fp, \"  -t, --timer         print elapsed compilation time\\n\");\n    fprintf(fp, \"  -r  --return-vals   return field values for the tree root\\n\");\n    fprintf(fp, \"  -0, --optimize=0    do not optimize (check syntax)\\n\");\n    fprintf(fp, \"      --types         show field value types\\n\");\n    /* NOTE: References are loaded during runtime and dftest only does compilation.\n     * Unless some static reference data is hard-coded at compile time during\n     * development the --refs option to dftest is useless because it will just\n     * print empty reference vectors. */\n    fprintf(fp, \"      --refs          dump some runtime data structures\\n\");\n    fprintf(fp, \"      --file <path>   read filters line-by-line from a file (use '-' for stdin)\\n\");\n    fprintf(fp, \"  -h, --help          display this help and exit\\n\");\n    fprintf(fp, \"  -v, --version       print version\\n\");\n    fprintf(fp, \"\\n\");\n    ws_log_print_usage(fp);\n    exit(status);\n}\n\nstatic void\nprint_syntax_tree(dfilter_t *df)\n{\n    printf(\"Syntax tree:\\n%s\\n\\n\", dfilter_syntax_tree(df));\n}\n\nstatic void\nprint_macros(void)\n{\n    if (dfilter_macro_table_count() == 0) {\n        printf(\"Macros: (empty)\\n\\n\");\n        return;\n    }\n\n    struct dfilter_macro_table_iter iter;\n    const char *name, *text;\n\n    dfilter_macro_table_iter_init(&iter);\n    printf(\"Macros:\\n\");\n    while (dfilter_macro_table_iter_next(&iter, &name, &text)) {\n        printf(\" \"UTF8_BULLET\" %s:\\n\", name);\n        printf(\"      %s\\n\", text);\n    }\n    printf(\"\\n\");\n}\n\nstatic void\nprint_warnings(dfilter_t *df)\n{\n    unsigned i;\n    GPtrArray *deprecated;\n    int count = 0;\n\n    for (GSList *l = dfilter_get_warnings(df); l != NULL; l = l->next) {\n        printf(\"\\nWarning: %s.\", (char *)l->data);\n        count++;\n    }\n\n    deprecated = dfilter_deprecated_tokens(df);\n    if (deprecated && deprecated->len) {\n        for (i = 0; i < deprecated->len; i++) {\n            const char *token = g_ptr_array_index(deprecated, i);\n            printf(\"\\nWarning: Deprecated token \\\"%s\\\".\", token);\n            count++;\n        }\n    }\n\n    if (count) {\n        printf(\"\\n\");\n    }\n}\n\nstatic void\nprint_elapsed(void)\n{\n    printf(\"\\nElapsed: %\"PRId64\" µs (%\"PRId64\" µs + %\"PRId64\" µs)\\n\",\n            elapsed_expand + elapsed_compile,\n            elapsed_expand,\n            elapsed_compile);\n}\n\nstatic char *\nexpand_filter(const char *text)\n{\n    char *expanded = NULL;\n    df_error_t *err = NULL;\n    int64_t start;\n\n    start = g_get_monotonic_time();\n    expanded = dfilter_expand(text, &err);\n    if (expanded == NULL) {\n        fprintf(stderr, \"Error: %s\\n\", err->msg);\n        df_error_free(&err);\n    }\n    elapsed_expand = g_get_monotonic_time() - start;\n    return expanded;\n}\n\nstatic bool\ncompile_filter(const char *text, dfilter_t **dfp)\n{\n    unsigned df_flags = 0;\n    bool ok;\n    df_error_t *df_err = NULL;\n    int64_t start;\n\n    if (opt_optimize > 0)\n        df_flags |= DF_OPTIMIZE;\n    if (opt_syntax_tree)\n        df_flags |= DF_SAVE_TREE;\n    if (opt_flex)\n        df_flags |= DF_DEBUG_FLEX;\n    if (opt_lemon)\n        df_flags |= DF_DEBUG_LEMON;\n    if (opt_return_vals)\n        df_flags |= DF_RETURN_VALUES;\n\n    start = g_get_monotonic_time();\n    ok = dfilter_compile_full(text, dfp, &df_err, df_flags, \"dftest\");\n    if (!ok) {\n        fprintf(stderr, \"Error: %s\\n\", df_err->msg);\n        if (df_err->loc.col_start >= 0) {\n            fprintf(stderr, \"  %s\\n  \", text);\n            putloc(stderr, df_err->loc);\n        }\n        df_error_free(&df_err);\n    }\n    elapsed_compile = g_get_monotonic_time() - start;\n    return ok;\n}\n\nstatic int\noptarg_to_digit(const char *arg)\n{\n    if (strlen(arg) > 1 || !g_ascii_isdigit(*arg)) {\n        printf(\"Error: \\\"%s\\\" is not a valid number 0-9\\n\", arg);\n        print_usage(WS_EXIT_INVALID_OPTION);\n    }\n    errno = 0;\n    int digit = (int)strtol(ws_optarg, NULL, 10);\n    if (errno) {\n        printf(\"Error: %s\\n\", g_strerror(errno));\n        print_usage(WS_EXIT_INVALID_OPTION);\n    }\n    return digit;\n}\n\nstatic int\ntest_filter(const char *text)\n{\n    char        *expanded_text = NULL;\n    dfilter_t   *df = NULL;\n\n    printf(\"Filter:\\n %s\\n\\n\", text);\n\n    /* Expand macros. */\n    expanded_text = expand_filter(text);\n    if (expanded_text == NULL) {\n        goto fail;\n    }\n\n    if (strcmp(text, expanded_text) != 0)\n        printf(\"Filter (after expansion):\\n %s\\n\\n\", expanded_text);\n\n    /* Compile it */\n    if (!compile_filter(expanded_text, &df)) {\n        goto fail;\n    }\n\n    /* If logging is enabled add an empty line. */\n    if (opt_debug_level > 0) {\n        printf(\"\\n\");\n    }\n\n    if (df == NULL) {\n        printf(\"Filter is empty.\\n\");\n        goto fail;\n    }\n\n    if (opt_syntax_tree)\n        print_syntax_tree(df);\n\n    uint16_t dump_flags = 0;\n    if (opt_show_types)\n        dump_flags |= DF_DUMP_SHOW_FTYPE;\n    if (opt_dump_refs)\n        dump_flags |= DF_DUMP_REFERENCES;\n\n    dfilter_dump(stdout, df, dump_flags);\n\n    print_warnings(df);\n\n    if (opt_timer)\n        print_elapsed();\n\n    g_free(expanded_text);\n    dfilter_free(df);\n\n    return EXIT_SUCCESS;\n\nfail:\n    g_free(expanded_text);\n    dfilter_free(df);\n    return WS_EXIT_INVALID_FILTER;\n}\n\nint\nmain(int argc, char **argv)\n{\n    char\t\t*configuration_init_error;\n    char        *path = NULL;\n    char        *text = NULL;\n    int          exit_status = EXIT_FAILURE;\n\n    /* Set the program name. */\n    g_set_prgname(\"dftest\");\n\n    /*\n     * Set the C-language locale to the native environment and set the\n     * code page to UTF-8 on Windows.\n     */\n#ifdef _WIN32\n    setlocale(LC_ALL, \".UTF-8\");\n#else\n    setlocale(LC_ALL, \"\");\n#endif\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early for startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, 1);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n    /*\n     * Get credential information for later use.\n     */\n    init_process_policies();\n\n    /*\n     * Attempt to get the pathname of the directory containing the\n     * executable file.\n     */\n    configuration_init_error = configuration_init(argv[0]);\n    if (configuration_init_error != NULL) {\n        fprintf(stderr, \"Error: Can't get pathname of directory containing \"\n                        \"the dftest program: %s.\\n\",\n            configuration_init_error);\n        g_free(configuration_init_error);\n    }\n\n    ws_init_version_info(\"DFTest\", NULL, NULL);\n\n    const char *optstring = \"hvC:dDflsmrtV0\";\n    static struct ws_option long_options[] = {\n        { \"help\",     ws_no_argument,   0,  'h' },\n        { \"version\",  ws_no_argument,   0,  'v' },\n        { \"debug\",    ws_optional_argument, 0, 'd' },\n        { \"flex\",     ws_no_argument,   0,  'f' },\n        { \"lemon\",    ws_no_argument,   0,  'l' },\n        { \"syntax\",   ws_no_argument,   0,  's' },\n        { \"macros\",   ws_no_argument,   0,  'm' },\n        { \"timer\",    ws_no_argument,   0,  't' },\n        { \"verbose\",  ws_no_argument,   0,  'V' },\n        { \"return-vals\", ws_no_argument,   0,  'r' },\n        { \"optimize\", ws_required_argument, 0, 1000 },\n        { \"types\",    ws_no_argument,   0, 2000 },\n        { \"refs\",     ws_no_argument,   0, 3000 },\n        { \"file\",     ws_required_argument, 0, 4000 },\n        { NULL,       0,                0,  0   }\n    };\n    int opt;\n\n    for (;;) {\n        opt = ws_getopt_long(argc, argv, optstring, long_options, NULL);\n        if (opt == -1)\n            break;\n\n        switch (opt) {\n            case 'V':\n                opt_verbose = 1;\n                break;\n            case 'd':\n                if (ws_optarg) {\n                    opt_debug_level = optarg_to_digit(ws_optarg);\n                }\n                else {\n                    opt_debug_level++;\n                }\n                opt_show_types = 1;\n                break;\n            case 'C':   /* Configuration Profile */\n                if (profile_exists (ws_optarg, false)) {\n                    set_profile_name (ws_optarg);\n                } else {\n                    cmdarg_err(\"Configuration Profile \\\"%s\\\" does not exist\", ws_optarg);\n                    print_usage(WS_EXIT_INVALID_OPTION);\n                }\n                break;\n            case 'D':\n                opt_debug_level = 9;\n                opt_lemon = 1;\n                opt_flex = 1;\n                opt_show_types = 1;\n                break;\n            case 'f':\n                opt_flex = 1;\n                break;\n            case 'l':\n                opt_lemon = 1;\n                break;\n            case 's':\n                opt_syntax_tree = 1;\n                break;\n            case 'm':\n                opt_dump_macros = 1;\n                break;\n            case 't':\n                opt_timer = 1;\n                break;\n            case 'r':\n                opt_return_vals = 1;\n                break;\n            case '0':\n                opt_optimize = 0;\n                break;\n            case 1000:\n                opt_optimize = optarg_to_digit(ws_optarg);\n                break;\n            case 2000:\n                opt_show_types = 1;\n                break;\n            case 3000:\n                opt_dump_refs = 1;\n                break;\n            case 4000:\n                path = ws_optarg;\n                break;\n            case 'v':\n                show_version();\n                exit(EXIT_SUCCESS);\n                break;\n            case 'h':\n                show_help_header(NULL);\n                print_usage(EXIT_SUCCESS);\n                break;\n            case '?':\n                print_usage(EXIT_FAILURE);\n            default:\n                ws_assert_not_reached();\n        }\n    }\n\n    /* Check for filter on command line. */\n    if (argv[ws_optind] == NULL) {\n        /* If not printing macros we need a filter expression to compile. */\n        if (!opt_dump_macros && !path) {\n            printf(\"Error: Missing argument.\\n\");\n            print_usage(EXIT_FAILURE);\n        }\n    }\n\n    /* Set dfilter domain logging. */\n    if (opt_debug_level > 1) {\n        ws_log_set_noisy_filter(LOG_DOMAIN_DFILTER);\n    }\n    else if (opt_debug_level > 0 || opt_flex || opt_lemon) {\n        /* Also enable some dfilter logs with flex/lemon traces for context. */\n        ws_log_set_debug_filter(LOG_DOMAIN_DFILTER);\n    }\n\n    init_report_failure_message(\"dftest\");\n\n    timestamp_set_type(TS_RELATIVE);\n    timestamp_set_seconds_type(TS_SECONDS_DEFAULT);\n\n    /*\n     * Libwiretap must be initialized before libwireshark is, so that\n     * dissection-time handlers for file-type-dependent blocks can\n     * register using the file type/subtype value for the file type.\n     */\n    wtap_init(true);\n\n    /* Register all dissectors; we must do this before checking for the\n       \"-g\" flag, as the \"-g\" flag dumps a list of fields registered\n       by the dissectors, and we must do it before we read the preferences,\n       in case any dissectors register preferences. */\n    if (!epan_init(NULL, NULL, true))\n        goto out;\n\n    /* Load libwireshark settings from the current profile. */\n    epan_load_settings();\n\n    /* notify all registered modules that have had any of their preferences\n       changed either from one of the preferences file or from the command\n       line that its preferences have changed. */\n    prefs_apply_all();\n\n    if (opt_dump_macros) {\n        print_macros();\n        if (argv[ws_optind] == NULL) {\n            /* No filter expression, we're done. */\n            exit(EXIT_SUCCESS);\n        }\n    }\n\n    /* This is useful to prevent confusion with option parsing.\n     * Skips printing options and argv[0]. */\n    if (opt_verbose) {\n        for (int i = ws_optind; i < argc; i++) {\n            fprintf(stderr, \"argv[%d]: %s\\n\", i, argv[i]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (path) {\n        FILE *filter_p;\n        if (strcmp(path, \"-\") == 0) {\n            filter_p = stdin;\n        } else {\n            filter_p = ws_fopen(path, \"r\");\n            if (filter_p == NULL) {\n                open_failure_message(path, errno, false);\n                exit_status = WS_EXIT_INVALID_FILE;\n                goto out;\n            }\n        }\n        bool first = true;\n#ifdef HAVE_GETLINE\n        char *line = NULL;\n        size_t len = 0;\n        while (getline(&line, &len, filter_p) >= 0) {\n#else\n        char line[MAX_LINELEN];\n        while (fgetline(line, sizeof(line), filter_p) >= 0) {\n#endif\n            if (first) {\n                first = false;\n            } else {\n                printf(\"\\n\");\n            }\n            exit_status = test_filter(line);\n            /* A keep going option could be added. */\n            if (exit_status != EXIT_SUCCESS)\n                break;\n        }\n#ifdef HAVE_GETLINE\n        g_free(line);\n#endif\n        fclose(filter_p);\n    } else {\n\n        /* Check again for filter on command line */\n        if (argv[ws_optind] == NULL) {\n            printf(\"Error: Missing argument.\\n\");\n            print_usage(EXIT_FAILURE);\n        }\n\n        /* Get filter text */\n        text = get_args_as_string(argc, argv, ws_optind);\n\n        exit_status = test_filter(text);\n    }\n\nout:\n    epan_cleanup();\n    g_free(text);\n    exit(exit_status);\n}\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "doxygen.cfg.in",
          "type": "blob",
          "size": 111.111328125,
          "content": "# Doxyfile 1.8.17\n\n# This file describes the settings to be used by the documentation system\n# doxygen (www.doxygen.org) for a project.\n#\n# All text after a double hash (##) is considered a comment and is placed in\n# front of the TAG it is preceding.\n#\n# All text after a single hash (#) is considered a comment and will be ignored.\n# The format is:\n# TAG = value [value, ...]\n# For lists, items can also be appended using:\n# TAG += value [value, ...]\n# Values that contain spaces should be placed between quotes (\\\" \\\").\n\n#---------------------------------------------------------------------------\n# Project related configuration options\n#---------------------------------------------------------------------------\n\n# This tag specifies the encoding used for all characters in the configuration\n# file that follow. The default is UTF-8 which is also the encoding used for all\n# text before the first occurrence of this tag. Doxygen uses libiconv (or the\n# iconv built into libc) for the transcoding. See\n# https://www.gnu.org/software/libiconv/ for the list of possible encodings.\n# The default value is: UTF-8.\n\nDOXYFILE_ENCODING      = UTF-8\n\n# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by\n# double-quotes, unless you are using Doxywizard) that should identify the\n# project for which the documentation is generated. This name is used in the\n# title of most generated pages and in a few other places.\n# The default value is: My Project.\n\nPROJECT_NAME           = \"Wireshark\"\n\n# The PROJECT_NUMBER tag can be used to enter a project or revision number. This\n# could be handy for archiving the generated documentation or if some version\n# control system is used.\n\nPROJECT_NUMBER         = @PROJECT_VERSION@\n\n# Using the PROJECT_BRIEF tag one can provide an optional one line description\n# for a project that appears at the top of each page and should give viewer a\n# quick idea about the purpose of the project. Keep the description short.\n\nPROJECT_BRIEF          = \"The Wireshark network protocol analyzer\"\n\n# With the PROJECT_LOGO tag one can specify a logo or an icon that is included\n# in the documentation. The maximum height of the logo should not exceed 55\n# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy\n# the logo to the output directory.\n\nPROJECT_LOGO           = @DOXYGEN_INPUT_DIRECTORY@/resources/icons/wsicon48.png\n\n# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path\n# into which the generated documentation will be written. If a relative path is\n# entered, it will be relative to the location where doxygen was started. If\n# left blank the current directory will be used.\n\nOUTPUT_DIRECTORY       = @DOXYGEN_OUTPUT_DIRECTORY@\n\n# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-\n# directories (in 2 levels) under the output directory of each output format and\n# will distribute the generated files over these directories. Enabling this\n# option can be useful when feeding doxygen a huge amount of source files, where\n# putting all generated files in the same directory would otherwise causes\n# performance problems for the file system.\n# The default value is: NO.\n\nCREATE_SUBDIRS         = NO\n\n# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII\n# characters to appear in the names of generated files. If set to NO, non-ASCII\n# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode\n# U+3044.\n# The default value is: NO.\n\nALLOW_UNICODE_NAMES    = NO\n\n# The OUTPUT_LANGUAGE tag is used to specify the language in which all\n# documentation generated by doxygen is written. Doxygen will use this\n# information to generate all constant output in the proper language.\n# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,\n# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),\n# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,\n# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),\n# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,\n# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,\n# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,\n# Ukrainian and Vietnamese.\n# The default value is: English.\n\nOUTPUT_LANGUAGE        = English\n\n# The OUTPUT_TEXT_DIRECTION tag is used to specify the direction in which all\n# documentation generated by doxygen is written. Doxygen will use this\n# information to generate all generated output in the proper direction.\n# Possible values are: None, LTR, RTL and Context.\n# The default value is: None.\n\nOUTPUT_TEXT_DIRECTION  = None\n\n# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member\n# descriptions after the members that are listed in the file and class\n# documentation (similar to Javadoc). Set to NO to disable this.\n# The default value is: YES.\n\nBRIEF_MEMBER_DESC      = YES\n\n# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief\n# description of a member or function before the detailed description\n#\n# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the\n# brief descriptions will be completely suppressed.\n# The default value is: YES.\n\nREPEAT_BRIEF           = YES\n\n# This tag implements a quasi-intelligent brief description abbreviator that is\n# used to form the text in various listings. Each string in this list, if found\n# as the leading text of the brief description, will be stripped from the text\n# and the result, after processing the whole list, is used as the annotated\n# text. Otherwise, the brief description is used as-is. If left blank, the\n# following values are used ($name is automatically replaced with the name of\n# the entity):The $name class, The $name widget, The $name file, is, provides,\n# specifies, contains, represents, a, an and the.\n\nABBREVIATE_BRIEF       = \"The $name class\" \\\n                         \"The $name widget\" \\\n                         \"The $name file\" \\\n                         is \\\n                         provides \\\n                         specifies \\\n                         contains \\\n                         represents \\\n                         a \\\n                         an \\\n                         the\n\n# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then\n# doxygen will generate a detailed section even if there is only a brief\n# description.\n# The default value is: NO.\n\nALWAYS_DETAILED_SEC    = NO\n\n# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all\n# inherited members of a class in the documentation of that class as if those\n# members were ordinary class members. Constructors, destructors and assignment\n# operators of the base classes will not be shown.\n# The default value is: NO.\n\nINLINE_INHERITED_MEMB  = NO\n\n# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path\n# before files name in the file list and in the header files. If set to NO the\n# shortest path that makes the file name unique will be used\n# The default value is: YES.\n\nFULL_PATH_NAMES        = YES\n\n# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.\n# Stripping is only done if one of the specified strings matches the left-hand\n# part of the path. The tag can be used to show relative paths in the file list.\n# If left blank the directory from which doxygen is run is used as the path to\n# strip.\n#\n# Note that you can specify absolute paths here, but also relative paths, which\n# will be relative from the directory where doxygen is started.\n# This tag requires that the tag FULL_PATH_NAMES is set to YES.\n\nSTRIP_FROM_PATH        =\n\n# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the\n# path mentioned in the documentation of a class, which tells the reader which\n# header file to include in order to use a class. If left blank only the name of\n# the header file containing the class definition is used. Otherwise one should\n# specify the list of include paths that are normally passed to the compiler\n# using the -I flag.\n\nSTRIP_FROM_INC_PATH    =\n\n# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but\n# less readable) file names. This can be useful is your file systems doesn't\n# support long names like on DOS, Mac, or CD-ROM.\n# The default value is: NO.\n\nSHORT_NAMES            = NO\n\n# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the\n# first line (until the first dot) of a Javadoc-style comment as the brief\n# description. If set to NO, the Javadoc-style will behave just like regular Qt-\n# style comments (thus requiring an explicit @brief command for a brief\n# description.)\n# The default value is: NO.\n\nJAVADOC_AUTOBRIEF      = NO\n\n# If the JAVADOC_BANNER tag is set to YES then doxygen will interpret a line\n# such as\n# /***************\n# as being the beginning of a Javadoc-style comment \"banner\". If set to NO, the\n# Javadoc-style will behave just like regular comments and it will not be\n# interpreted by doxygen.\n# The default value is: NO.\n\nJAVADOC_BANNER         = NO\n\n# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first\n# line (until the first dot) of a Qt-style comment as the brief description. If\n# set to NO, the Qt-style will behave just like regular Qt-style comments (thus\n# requiring an explicit \\brief command for a brief description.)\n# The default value is: NO.\n\nQT_AUTOBRIEF           = NO\n\n# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a\n# multi-line C++ special comment block (i.e. a block of //! or /// comments) as\n# a brief description. This used to be the default behavior. The new default is\n# to treat a multi-line C++ comment block as a detailed description. Set this\n# tag to YES if you prefer the old behavior instead.\n#\n# Note that setting this tag to YES also means that rational rose comments are\n# not recognized any more.\n# The default value is: NO.\n\nMULTILINE_CPP_IS_BRIEF = NO\n\n# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the\n# documentation from any documented member that it re-implements.\n# The default value is: YES.\n\nINHERIT_DOCS           = YES\n\n# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new\n# page for each member. If set to NO, the documentation of a member will be part\n# of the file/class/namespace that contains it.\n# The default value is: NO.\n\nSEPARATE_MEMBER_PAGES  = NO\n\n# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen\n# uses this value to replace tabs by spaces in code fragments.\n# Minimum value: 1, maximum value: 16, default value: 4.\n\nTAB_SIZE               = 4\n\n# This tag can be used to specify a number of aliases that act as commands in\n# the documentation. An alias has the form:\n# name=value\n# For example adding\n# \"sideeffect=@par Side Effects:\\n\"\n# will allow you to put the command \\sideeffect (or @sideeffect) in the\n# documentation, which will result in a user-defined paragraph with heading\n# \"Side Effects:\". You can put \\n's in the value part of an alias to insert\n# newlines (in the resulting output). You can put ^^ in the value part of an\n# alias to insert a newline as if a physical newline was in the original file.\n# When you need a literal { or } or , in the value part of an alias you have to\n# escape them by means of a backslash (\\), this can lead to conflicts with the\n# commands \\{ and \\} for these it is advised to use the version @{ and @} or use\n# a double escape (\\\\{ and \\\\})\n\nALIASES                =\n\n# This tag can be used to specify a number of word-keyword mappings (TCL only).\n# A mapping has the form \"name=value\". For example adding \"class=itcl::class\"\n# will allow you to use the command class in the itcl::class meaning.\n\nTCL_SUBST              =\n\n# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources\n# only. Doxygen will then generate output that is more tailored for C. For\n# instance, some of the names that are used will be different. The list of all\n# members will be omitted, etc.\n# The default value is: NO.\n\nOPTIMIZE_OUTPUT_FOR_C  = NO\n\n# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or\n# Python sources only. Doxygen will then generate output that is more tailored\n# for that language. For instance, namespaces will be presented as packages,\n# qualified scopes will look different, etc.\n# The default value is: NO.\n\nOPTIMIZE_OUTPUT_JAVA   = NO\n\n# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran\n# sources. Doxygen will then generate output that is tailored for Fortran.\n# The default value is: NO.\n\nOPTIMIZE_FOR_FORTRAN   = NO\n\n# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL\n# sources. Doxygen will then generate output that is tailored for VHDL.\n# The default value is: NO.\n\nOPTIMIZE_OUTPUT_VHDL   = NO\n\n# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice\n# sources only. Doxygen will then generate output that is more tailored for that\n# language. For instance, namespaces will be presented as modules, types will be\n# separated into more groups, etc.\n# The default value is: NO.\n\nOPTIMIZE_OUTPUT_SLICE  = NO\n\n# Doxygen selects the parser to use depending on the extension of the files it\n# parses. With this tag you can assign which parser to use for a given\n# extension. Doxygen has a built-in mapping, but you can override or extend it\n# using this tag. The format is ext=language, where ext is a file extension, and\n# language is one of the parsers supported by doxygen: IDL, Java, JavaScript,\n# Csharp (C#), C, C++, D, PHP, md (Markdown), Objective-C, Python, Slice,\n# Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:\n# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser\n# tries to guess whether the code is fixed or free formatted code, this is the\n# default for Fortran type files), VHDL, tcl. For instance to make doxygen treat\n# .inc files as Fortran files (default is PHP), and .f files as C (default is\n# Fortran), use: inc=Fortran f=C.\n#\n# Note: For files without extension you can use no_extension as a placeholder.\n#\n# Note that for custom extensions you also need to set FILE_PATTERNS otherwise\n# the files are not read by doxygen.\n\nEXTENSION_MAPPING      =\n\n# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments\n# according to the Markdown format, which allows for more readable\n# documentation. See https://daringfireball.net/projects/markdown/ for details.\n# The output of markdown processing is further processed by doxygen, so you can\n# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in\n# case of backward compatibilities issues.\n# The default value is: YES.\n\nMARKDOWN_SUPPORT       = YES\n\n# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up\n# to that level are automatically included in the table of contents, even if\n# they do not have an id attribute.\n# Note: This feature currently applies only to Markdown headings.\n# Minimum value: 0, maximum value: 99, default value: 5.\n# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.\n\nTOC_INCLUDE_HEADINGS   = 0\n\n# When enabled doxygen tries to link words that correspond to documented\n# classes, or namespaces to their corresponding documentation. Such a link can\n# be prevented in individual cases by putting a % sign in front of the word or\n# globally by setting AUTOLINK_SUPPORT to NO.\n# The default value is: YES.\n\nAUTOLINK_SUPPORT       = YES\n\n# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want\n# to include (a tag file for) the STL sources as input, then you should set this\n# tag to YES in order to let doxygen match functions declarations and\n# definitions whose arguments contain STL classes (e.g. func(std::string);\n# versus func(std::string) {}). This also make the inheritance and collaboration\n# diagrams that involve STL classes more complete and accurate.\n# The default value is: NO.\n\nBUILTIN_STL_SUPPORT    = NO\n\n# If you use Microsoft's C++/CLI language, you should set this option to YES to\n# enable parsing support.\n# The default value is: NO.\n\nCPP_CLI_SUPPORT        = NO\n\n# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:\n# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen\n# will parse them like normal C++ but will assume all classes use public instead\n# of private inheritance when no explicit protection keyword is present.\n# The default value is: NO.\n\nSIP_SUPPORT            = NO\n\n# For Microsoft's IDL there are propget and propput attributes to indicate\n# getter and setter methods for a property. Setting this option to YES will make\n# doxygen to replace the get and set methods by a property in the documentation.\n# This will only work if the methods are indeed getting or setting a simple\n# type. If this is not the case, or you want to show the methods anyway, you\n# should set this option to NO.\n# The default value is: YES.\n\nIDL_PROPERTY_SUPPORT   = YES\n\n# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC\n# tag is set to YES then doxygen will reuse the documentation of the first\n# member in the group (if any) for the other members of the group. By default\n# all members of a group must be documented explicitly.\n# The default value is: NO.\n\nDISTRIBUTE_GROUP_DOC   = NO\n\n# If one adds a struct or class to a group and this option is enabled, then also\n# any nested class or struct is added to the same group. By default this option\n# is disabled and one has to add nested compounds explicitly via \\ingroup.\n# The default value is: NO.\n\nGROUP_NESTED_COMPOUNDS = NO\n\n# Set the SUBGROUPING tag to YES to allow class member groups of the same type\n# (for instance a group of public functions) to be put as a subgroup of that\n# type (e.g. under the Public Functions section). Set it to NO to prevent\n# subgrouping. Alternatively, this can be done per class using the\n# \\nosubgrouping command.\n# The default value is: YES.\n\nSUBGROUPING            = YES\n\n# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions\n# are shown inside the group in which they are included (e.g. using \\ingroup)\n# instead of on a separate page (for HTML and Man pages) or section (for LaTeX\n# and RTF).\n#\n# Note that this feature does not work in combination with\n# SEPARATE_MEMBER_PAGES.\n# The default value is: NO.\n\nINLINE_GROUPED_CLASSES = NO\n\n# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions\n# with only public data fields or simple typedef fields will be shown inline in\n# the documentation of the scope in which they are defined (i.e. file,\n# namespace, or group documentation), provided this scope is documented. If set\n# to NO, structs, classes, and unions are shown on a separate page (for HTML and\n# Man pages) or section (for LaTeX and RTF).\n# The default value is: NO.\n\nINLINE_SIMPLE_STRUCTS  = NO\n\n# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or\n# enum is documented as struct, union, or enum with the name of the typedef. So\n# typedef struct TypeS {} TypeT, will appear in the documentation as a struct\n# with name TypeT. When disabled the typedef will appear as a member of a file,\n# namespace, or class. And the struct will be named TypeS. This can typically be\n# useful for C code in case the coding convention dictates that all compound\n# types are typedef'ed and only the typedef is referenced, never the tag name.\n# The default value is: NO.\n\nTYPEDEF_HIDES_STRUCT   = NO\n\n# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This\n# cache is used to resolve symbols given their name and scope. Since this can be\n# an expensive process and often the same symbol appears multiple times in the\n# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small\n# doxygen will become slower. If the cache is too large, memory is wasted. The\n# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range\n# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536\n# symbols. At the end of a run doxygen will report the cache usage and suggest\n# the optimal cache size from a speed point of view.\n# Minimum value: 0, maximum value: 9, default value: 0.\n\nLOOKUP_CACHE_SIZE      = 0\n\n#---------------------------------------------------------------------------\n# Build related configuration options\n#---------------------------------------------------------------------------\n\n# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in\n# documentation are documented, even if no documentation was available. Private\n# class members and static file members will be hidden unless the\n# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.\n# Note: This will also disable the warnings about undocumented members that are\n# normally produced when WARNINGS is set to YES.\n# The default value is: NO.\n\nEXTRACT_ALL            = NO\n\n# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will\n# be included in the documentation.\n# The default value is: NO.\n\nEXTRACT_PRIVATE        = NO\n\n# If the EXTRACT_PRIV_VIRTUAL tag is set to YES, documented private virtual\n# methods of a class will be included in the documentation.\n# The default value is: NO.\n\nEXTRACT_PRIV_VIRTUAL   = NO\n\n# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal\n# scope will be included in the documentation.\n# The default value is: NO.\n\nEXTRACT_PACKAGE        = NO\n\n# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be\n# included in the documentation.\n# The default value is: NO.\n\nEXTRACT_STATIC         = NO\n\n# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined\n# locally in source files will be included in the documentation. If set to NO,\n# only classes defined in header files are included. Does not have any effect\n# for Java sources.\n# The default value is: YES.\n\nEXTRACT_LOCAL_CLASSES  = YES\n\n# This flag is only useful for Objective-C code. If set to YES, local methods,\n# which are defined in the implementation section but not in the interface are\n# included in the documentation. If set to NO, only methods in the interface are\n# included.\n# The default value is: NO.\n\nEXTRACT_LOCAL_METHODS  = NO\n\n# If this flag is set to YES, the members of anonymous namespaces will be\n# extracted and appear in the documentation as a namespace called\n# 'anonymous_namespace{file}', where file will be replaced with the base name of\n# the file that contains the anonymous namespace. By default anonymous namespace\n# are hidden.\n# The default value is: NO.\n\nEXTRACT_ANON_NSPACES   = NO\n\n# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all\n# undocumented members inside documented classes or files. If set to NO these\n# members will be included in the various overviews, but no documentation\n# section is generated. This option has no effect if EXTRACT_ALL is enabled.\n# The default value is: NO.\n\nHIDE_UNDOC_MEMBERS     = NO\n\n# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all\n# undocumented classes that are normally visible in the class hierarchy. If set\n# to NO, these classes will be included in the various overviews. This option\n# has no effect if EXTRACT_ALL is enabled.\n# The default value is: NO.\n\nHIDE_UNDOC_CLASSES     = NO\n\n# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend\n# declarations. If set to NO, these declarations will be included in the\n# documentation.\n# The default value is: NO.\n\nHIDE_FRIEND_COMPOUNDS  = NO\n\n# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any\n# documentation blocks found inside the body of a function. If set to NO, these\n# blocks will be appended to the function's detailed documentation block.\n# The default value is: NO.\n\nHIDE_IN_BODY_DOCS      = NO\n\n# The INTERNAL_DOCS tag determines if documentation that is typed after a\n# \\internal command is included. If the tag is set to NO then the documentation\n# will be excluded. Set it to YES to include the internal documentation.\n# The default value is: NO.\n\nINTERNAL_DOCS          = NO\n\n# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file\n# names in lower-case letters. If set to YES, upper-case letters are also\n# allowed. This is useful if you have classes or files whose names only differ\n# in case and if your file system supports case sensitive file names. Windows\n# (including Cygwin) ands Mac users are advised to set this option to NO.\n# The default value is: system dependent.\n\nCASE_SENSE_NAMES       = NO\n\n# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with\n# their full class and namespace scopes in the documentation. If set to YES, the\n# scope will be hidden.\n# The default value is: NO.\n\nHIDE_SCOPE_NAMES       = NO\n\n# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will\n# append additional text to a page's title, such as Class Reference. If set to\n# YES the compound reference will be hidden.\n# The default value is: NO.\n\nHIDE_COMPOUND_REFERENCE= NO\n\n# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of\n# the files that are included by a file in the documentation of that file.\n# The default value is: YES.\n\nSHOW_INCLUDE_FILES     = YES\n\n# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each\n# grouped member an include statement to the documentation, telling the reader\n# which file to include in order to use the member.\n# The default value is: NO.\n\nSHOW_GROUPED_MEMB_INC  = NO\n\n# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include\n# files with double quotes in the documentation rather than with sharp brackets.\n# The default value is: NO.\n\nFORCE_LOCAL_INCLUDES   = NO\n\n# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the\n# documentation for inline members.\n# The default value is: YES.\n\nINLINE_INFO            = YES\n\n# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the\n# (detailed) documentation of file and class members alphabetically by member\n# name. If set to NO, the members will appear in declaration order.\n# The default value is: YES.\n\nSORT_MEMBER_DOCS       = YES\n\n# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief\n# descriptions of file, namespace and class members alphabetically by member\n# name. If set to NO, the members will appear in declaration order. Note that\n# this will also influence the order of the classes in the class list.\n# The default value is: NO.\n\nSORT_BRIEF_DOCS        = NO\n\n# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the\n# (brief and detailed) documentation of class members so that constructors and\n# destructors are listed first. If set to NO the constructors will appear in the\n# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.\n# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief\n# member documentation.\n# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting\n# detailed member documentation.\n# The default value is: NO.\n\nSORT_MEMBERS_CTORS_1ST = NO\n\n# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy\n# of group names into alphabetical order. If set to NO the group names will\n# appear in their defined order.\n# The default value is: NO.\n\nSORT_GROUP_NAMES       = NO\n\n# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by\n# fully-qualified names, including namespaces. If set to NO, the class list will\n# be sorted only by class name, not including the namespace part.\n# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.\n# Note: This option applies only to the class list, not to the alphabetical\n# list.\n# The default value is: NO.\n\nSORT_BY_SCOPE_NAME     = NO\n\n# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper\n# type resolution of all parameters of a function it will reject a match between\n# the prototype and the implementation of a member function even if there is\n# only one candidate or it is obvious which candidate to choose by doing a\n# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still\n# accept a match between prototype and implementation in such cases.\n# The default value is: NO.\n\nSTRICT_PROTO_MATCHING  = NO\n\n# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo\n# list. This list is created by putting \\todo commands in the documentation.\n# The default value is: YES.\n\nGENERATE_TODOLIST      = YES\n\n# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test\n# list. This list is created by putting \\test commands in the documentation.\n# The default value is: YES.\n\nGENERATE_TESTLIST      = YES\n\n# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug\n# list. This list is created by putting \\bug commands in the documentation.\n# The default value is: YES.\n\nGENERATE_BUGLIST       = YES\n\n# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)\n# the deprecated list. This list is created by putting \\deprecated commands in\n# the documentation.\n# The default value is: YES.\n\nGENERATE_DEPRECATEDLIST= YES\n\n# The ENABLED_SECTIONS tag can be used to enable conditional documentation\n# sections, marked by \\if <section_label> ... \\endif and \\cond <section_label>\n# ... \\endcond blocks.\n\nENABLED_SECTIONS       =\n\n# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the\n# initial value of a variable or macro / define can have for it to appear in the\n# documentation. If the initializer consists of more lines than specified here\n# it will be hidden. Use a value of 0 to hide initializers completely. The\n# appearance of the value of individual variables and macros / defines can be\n# controlled using \\showinitializer or \\hideinitializer command in the\n# documentation regardless of this setting.\n# Minimum value: 0, maximum value: 10000, default value: 30.\n\nMAX_INITIALIZER_LINES  = 30\n\n# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at\n# the bottom of the documentation of classes and structs. If set to YES, the\n# list will mention the files that were used to generate the documentation.\n# The default value is: YES.\n\nSHOW_USED_FILES        = YES\n\n# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This\n# will remove the Files entry from the Quick Index and from the Folder Tree View\n# (if specified).\n# The default value is: YES.\n\nSHOW_FILES             = YES\n\n# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces\n# page. This will remove the Namespaces entry from the Quick Index and from the\n# Folder Tree View (if specified).\n# The default value is: YES.\n\nSHOW_NAMESPACES        = YES\n\n# The FILE_VERSION_FILTER tag can be used to specify a program or script that\n# doxygen should invoke to get the current version for each file (typically from\n# the version control system). Doxygen will invoke the program by executing (via\n# popen()) the command command input-file, where command is the value of the\n# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided\n# by doxygen. Whatever the program writes to standard output is used as the file\n# version. For an example see the documentation.\n\nFILE_VERSION_FILTER    =\n\n# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed\n# by doxygen. The layout file controls the global structure of the generated\n# output files in an output format independent way. To create the layout file\n# that represents doxygen's defaults, run doxygen with the -l option. You can\n# optionally specify a file name after the option, if omitted DoxygenLayout.xml\n# will be used as the name of the layout file.\n#\n# Note that if you run doxygen from a directory containing a file called\n# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE\n# tag is left empty.\n\nLAYOUT_FILE            =\n\n# The CITE_BIB_FILES tag can be used to specify one or more bib files containing\n# the reference definitions. This must be a list of .bib files. The .bib\n# extension is automatically appended if omitted. This requires the bibtex tool\n# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.\n# For LaTeX the style of the bibliography can be controlled using\n# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the\n# search path. See also \\cite for info how to create references.\n\nCITE_BIB_FILES         =\n\n#---------------------------------------------------------------------------\n# Configuration options related to warning and progress messages\n#---------------------------------------------------------------------------\n\n# The QUIET tag can be used to turn on/off the messages that are generated to\n# standard output by doxygen. If QUIET is set to YES this implies that the\n# messages are off.\n# The default value is: NO.\n\nQUIET                  = NO\n\n# The WARNINGS tag can be used to turn on/off the warning messages that are\n# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES\n# this implies that the warnings are on.\n#\n# Tip: Turn warnings on while writing the documentation.\n# The default value is: YES.\n\nWARNINGS               = YES\n\n# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate\n# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag\n# will automatically be disabled.\n# The default value is: YES.\n\nWARN_IF_UNDOCUMENTED   = NO\n\n# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for\n# potential errors in the documentation, such as not documenting some parameters\n# in a documented function, or documenting parameters that don't exist or using\n# markup commands wrongly.\n# The default value is: YES.\n\nWARN_IF_DOC_ERROR      = YES\n\n# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that\n# are documented, but have no documentation for their parameters or return\n# value. If set to NO, doxygen will only warn about wrong or incomplete\n# parameter documentation, but not about the absence of documentation. If\n# EXTRACT_ALL is set to YES then this flag will automatically be disabled.\n# The default value is: NO.\n\nWARN_NO_PARAMDOC       = NO\n\n# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when\n# a warning is encountered.\n# The default value is: NO.\n\nWARN_AS_ERROR          = NO\n\n# The WARN_FORMAT tag determines the format of the warning messages that doxygen\n# can produce. The string should contain the $file, $line, and $text tags, which\n# will be replaced by the file and line number from which the warning originated\n# and the warning text. Optionally the format may contain $version, which will\n# be replaced by the version of the file (if it could be obtained via\n# FILE_VERSION_FILTER)\n# The default value is: $file:$line: $text.\n\nWARN_FORMAT            = \"$file:$line: $text\"\n\n# The WARN_LOGFILE tag can be used to specify a file to which warning and error\n# messages should be written. If left blank the output is written to standard\n# error (stderr).\n\nWARN_LOGFILE           =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the input files\n#---------------------------------------------------------------------------\n\n# The INPUT tag is used to specify the files and/or directories that contain\n# documented source files. You may enter file names like myfile.cpp or\n# directories like /usr/src/myproject. Separate the files or directories with\n# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING\n# Note: If this tag is empty the current directory is searched.\n\n# ls */*.h | xargs -n1 dirname | sort -u\nINPUT                  = @DOXYGEN_INPUT_DIRECTORY@/wireshark.dox \\\n                         @DOXYGEN_TOP_LEVEL_SOURCES@ \\\n                         @DOXYGEN_INPUT_DIRECTORY@/capture \\\n                         @DOXYGEN_INPUT_DIRECTORY@/epan \\\n                         @DOXYGEN_INPUT_DIRECTORY@/extcap \\\n                         @DOXYGEN_INPUT_DIRECTORY@/plugins \\\n                         @DOXYGEN_INPUT_DIRECTORY@/randpkt_core \\\n                         @DOXYGEN_INPUT_DIRECTORY@/ui \\\n                         @DOXYGEN_INPUT_DIRECTORY@/wiretap \\\n                         @DOXYGEN_INPUT_DIRECTORY@/writecap \\\n                         @DOXYGEN_INPUT_DIRECTORY@/wsutil\n\n# This tag can be used to specify the character encoding of the source files\n# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses\n# libiconv (or the iconv built into libc) for the transcoding. See the libiconv\n# documentation (see: https://www.gnu.org/software/libiconv/) for the list of\n# possible encodings.\n# The default value is: UTF-8.\n\nINPUT_ENCODING         = UTF-8\n\n# If the value of the INPUT tag contains directories, you can use the\n# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and\n# *.h) to filter out the source-files in the directories.\n#\n# Note that for custom extensions or not directly supported extensions you also\n# need to set EXTENSION_MAPPING for the extension otherwise the files are not\n# read by doxygen.\n#\n# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,\n# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,\n# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,\n# *.m, *.markdown, *.md, *.mm, *.dox (to be provided as doxygen C comment),\n# *.doc (to be provided as doxygen C comment), *.txt (to be provided as doxygen\n# C comment), *.py, *.pyw, *.f90, *.f95, *.f03, *.f08, *.f, *.for, *.tcl, *.vhd,\n# *.vhdl, *.ucf, *.qsf and *.ice.\n\nFILE_PATTERNS          = *.c \\\n                         *.cc \\\n                         *.cxx \\\n                         *.cpp \\\n                         *.c++ \\\n                         *.java \\\n                         *.ii \\\n                         *.ixx \\\n                         *.ipp \\\n                         *.i++ \\\n                         *.inl \\\n                         *.idl \\\n                         *.ddl \\\n                         *.odl \\\n                         *.h \\\n                         *.hh \\\n                         *.hxx \\\n                         *.hpp \\\n                         *.h++ \\\n                         *.cs \\\n                         *.d \\\n                         *.php \\\n                         *.php4 \\\n                         *.php5 \\\n                         *.phtml \\\n                         *.inc \\\n                         *.m \\\n                         *.markdown \\\n                         *.md \\\n                         *.mm \\\n                         *.dox \\\n                         *.py \\\n                         *.pyw \\\n                         *.f90 \\\n                         *.f95 \\\n                         *.f03 \\\n                         *.f08 \\\n                         *.f \\\n                         *.for \\\n                         *.tcl \\\n                         *.vhd \\\n                         *.vhdl \\\n                         *.ucf \\\n                         *.qsf\n\n# The RECURSIVE tag can be used to specify whether or not subdirectories should\n# be searched for input files as well.\n# The default value is: NO.\n\nRECURSIVE              = YES\n\n# The EXCLUDE tag can be used to specify files and/or directories that should be\n# excluded from the INPUT source files. This way you can easily exclude a\n# subdirectory from a directory tree whose root is specified with the INPUT tag.\n#\n# Note that relative paths are relative to the directory from which doxygen is\n# run.\n\nEXCLUDE                = @DOXYGEN_INPUT_DIRECTORY@/ui/qt/widgets/qcustomplot.cpp \\\n                         @DOXYGEN_INPUT_DIRECTORY@/ui/qt/widgets/qcustomplot.h \\\n                         @DOXYGEN_INPUT_DIRECTORY@/plugins/epan/pluginifdemo/ui/uiclasshandler.cpp\n\n# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or\n# directories that are symbolic links (a Unix file system feature) are excluded\n# from the input.\n# The default value is: NO.\n\nEXCLUDE_SYMLINKS       = NO\n\n# If the value of the INPUT tag contains directories, you can use the\n# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude\n# certain files from those directories.\n#\n# Note that the wildcards are matched against the file with absolute path, so to\n# exclude all test directories for example use the pattern */test/*\n\n# CMake places MOC and UIC output in qtui_autogen.\n# XXX Should we exclude CMAKE_BINARY_DIR?\nEXCLUDE_PATTERNS       = */CMakeFiles/* \\\n                         */epan/dissectors/asn1/* \\\n                         */qtui_autogen/* \\\n                         *.idl*\n\n# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names\n# (namespaces, classes, functions, etc.) that should be excluded from the\n# output. The symbol name can be a fully qualified name, a word, or if the\n# wildcard * is used, a substring. Examples: ANamespace, AClass,\n# AClass::ANamespace, ANamespace::*Test\n#\n# Note that the wildcards are matched against the file with absolute path, so to\n# exclude all test directories use the pattern */test/*\n\nEXCLUDE_SYMBOLS        =\n\n# The EXAMPLE_PATH tag can be used to specify one or more files or directories\n# that contain example code fragments that are included (see the \\include\n# command).\n\nEXAMPLE_PATH           =\n\n# If the value of the EXAMPLE_PATH tag contains directories, you can use the\n# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and\n# *.h) to filter out the source-files in the directories. If left blank all\n# files are included.\n\nEXAMPLE_PATTERNS       = *\n\n# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be\n# searched for input files to be used with the \\include or \\dontinclude commands\n# irrespective of the value of the RECURSIVE tag.\n# The default value is: NO.\n\nEXAMPLE_RECURSIVE      = NO\n\n# The IMAGE_PATH tag can be used to specify one or more files or directories\n# that contain images that are to be included in the documentation (see the\n# \\image command).\n\nIMAGE_PATH             =\n\n# The INPUT_FILTER tag can be used to specify a program that doxygen should\n# invoke to filter for each input file. Doxygen will invoke the filter program\n# by executing (via popen()) the command:\n#\n# <filter> <input-file>\n#\n# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the\n# name of an input file. Doxygen will then use the output that the filter\n# program writes to standard output. If FILTER_PATTERNS is specified, this tag\n# will be ignored.\n#\n# Note that the filter must not add or remove lines; it is applied before the\n# code is scanned, but not when the output code is generated. If lines are added\n# or removed, the anchors will not be placed correctly.\n#\n# Note that for custom extensions or not directly supported extensions you also\n# need to set EXTENSION_MAPPING for the extension otherwise the files are not\n# properly processed by doxygen.\n\nINPUT_FILTER           =\n\n# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern\n# basis. Doxygen will compare the file name with each pattern and apply the\n# filter if there is a match. The filters are a list of the form: pattern=filter\n# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how\n# filters are used. If the FILTER_PATTERNS tag is empty or if none of the\n# patterns match the file name, INPUT_FILTER is applied.\n#\n# Note that for custom extensions or not directly supported extensions you also\n# need to set EXTENSION_MAPPING for the extension otherwise the files are not\n# properly processed by doxygen.\n\nFILTER_PATTERNS        =\n\n# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using\n# INPUT_FILTER) will also be used to filter the input files that are used for\n# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).\n# The default value is: NO.\n\nFILTER_SOURCE_FILES    = NO\n\n# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file\n# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and\n# it is also possible to disable source filtering for a specific pattern using\n# *.ext= (so without naming a filter).\n# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.\n\nFILTER_SOURCE_PATTERNS =\n\n# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that\n# is part of the input, its contents will be placed on the main page\n# (index.html). This can be useful if you have a project on for instance GitHub\n# and want to reuse the introduction page also for the doxygen output.\n\nUSE_MDFILE_AS_MAINPAGE =\n\n#---------------------------------------------------------------------------\n# Configuration options related to source browsing\n#---------------------------------------------------------------------------\n\n# If the SOURCE_BROWSER tag is set to YES then a list of source files will be\n# generated. Documented entities will be cross-referenced with these sources.\n#\n# Note: To get rid of all source code in the generated output, make sure that\n# also VERBATIM_HEADERS is set to NO.\n# The default value is: NO.\n\nSOURCE_BROWSER         = NO\n\n# Setting the INLINE_SOURCES tag to YES will include the body of functions,\n# classes and enums directly into the documentation.\n# The default value is: NO.\n\nINLINE_SOURCES         = NO\n\n# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any\n# special comment blocks from generated source code fragments. Normal C, C++ and\n# Fortran comments will always remain visible.\n# The default value is: YES.\n\nSTRIP_CODE_COMMENTS    = YES\n\n# If the REFERENCED_BY_RELATION tag is set to YES then for each documented\n# entity all documented functions referencing it will be listed.\n# The default value is: NO.\n\nREFERENCED_BY_RELATION = NO\n\n# If the REFERENCES_RELATION tag is set to YES then for each documented function\n# all documented entities called/used by that function will be listed.\n# The default value is: NO.\n\nREFERENCES_RELATION    = NO\n\n# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set\n# to YES then the hyperlinks from functions in REFERENCES_RELATION and\n# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will\n# link to the documentation.\n# The default value is: YES.\n\nREFERENCES_LINK_SOURCE = YES\n\n# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the\n# source code will show a tooltip with additional information such as prototype,\n# brief description and links to the definition and documentation. Since this\n# will make the HTML file larger and loading of large files a bit slower, you\n# can opt to disable this feature.\n# The default value is: YES.\n# This tag requires that the tag SOURCE_BROWSER is set to YES.\n\nSOURCE_TOOLTIPS        = YES\n\n# If the USE_HTAGS tag is set to YES then the references to source code will\n# point to the HTML generated by the htags(1) tool instead of doxygen built-in\n# source browser. The htags tool is part of GNU's global source tagging system\n# (see https://www.gnu.org/software/global/global.html). You will need version\n# 4.8.6 or higher.\n#\n# To use it do the following:\n# - Install the latest version of global\n# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file\n# - Make sure the INPUT points to the root of the source tree\n# - Run doxygen as normal\n#\n# Doxygen will invoke htags (and that will in turn invoke gtags), so these\n# tools must be available from the command line (i.e. in the search path).\n#\n# The result: instead of the source browser generated by doxygen, the links to\n# source code will now point to the output of htags.\n# The default value is: NO.\n# This tag requires that the tag SOURCE_BROWSER is set to YES.\n\nUSE_HTAGS              = NO\n\n# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a\n# verbatim copy of the header file for each class for which an include is\n# specified. Set to NO to disable this.\n# See also: Section \\class.\n# The default value is: YES.\n\nVERBATIM_HEADERS       = YES\n\n# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the\n# clang parser (see: http://clang.llvm.org/) for more accurate parsing at the\n# cost of reduced performance. This can be particularly helpful with template\n# rich C++ code for which doxygen's built-in parser lacks the necessary type\n# information.\n# Note: The availability of this option depends on whether or not doxygen was\n# generated with the -Duse_libclang=ON option for CMake.\n# The default value is: NO.\n\nCLANG_ASSISTED_PARSING = NO\n\n# If clang assisted parsing is enabled you can provide the compiler with command\n# line options that you would normally use when invoking the compiler. Note that\n# the include paths will already be set by doxygen for the files and directories\n# specified with INPUT and INCLUDE_PATH.\n# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.\n\nCLANG_OPTIONS          =\n\n# If clang assisted parsing is enabled you can provide the clang parser with the\n# path to the compilation database (see:\n# http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html) used when the files\n# were built. This is equivalent to specifying the \"-p\" option to a clang tool,\n# such as clang-check. These options will then be passed to the parser.\n# Note: The availability of this option depends on whether or not doxygen was\n# generated with the -Duse_libclang=ON option for CMake.\n\nCLANG_DATABASE_PATH    =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the alphabetical class index\n#---------------------------------------------------------------------------\n\n# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all\n# compounds will be generated. Enable this if the project contains a lot of\n# classes, structs, unions or interfaces.\n# The default value is: YES.\n\nALPHABETICAL_INDEX     = YES\n\n# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in\n# which the alphabetical index list will be split.\n# Minimum value: 1, maximum value: 20, default value: 5.\n# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.\n\nCOLS_IN_ALPHA_INDEX    = 5\n\n# In case all classes in a project start with a common prefix, all classes will\n# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag\n# can be used to specify a prefix (or a list of prefixes) that should be ignored\n# while generating the index headers.\n# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.\n\nIGNORE_PREFIX          =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the HTML output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output\n# The default value is: YES.\n\nGENERATE_HTML          = YES\n\n# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\n# it.\n# The default directory is: html.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_OUTPUT            = wsar_html\n\n# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each\n# generated HTML page (for example: .htm, .php, .asp).\n# The default value is: .html.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_FILE_EXTENSION    = .html\n\n# The HTML_HEADER tag can be used to specify a user-defined HTML header file for\n# each generated HTML page. If the tag is left blank doxygen will generate a\n# standard header.\n#\n# To get valid HTML the header file that includes any scripts and style sheets\n# that doxygen needs, which is dependent on the configuration options used (e.g.\n# the setting GENERATE_TREEVIEW). It is highly recommended to start with a\n# default header using\n# doxygen -w html new_header.html new_footer.html new_stylesheet.css\n# YourConfigFile\n# and then modify the file new_header.html. See also section \"Doxygen usage\"\n# for information on how to generate the default header that doxygen normally\n# uses.\n# Note: The header is subject to change so you typically have to regenerate the\n# default header when upgrading to a newer version of doxygen. For a description\n# of the possible markers and block names see the documentation.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_HEADER            =\n\n# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each\n# generated HTML page. If the tag is left blank doxygen will generate a standard\n# footer. See HTML_HEADER for more information on how to generate a default\n# footer and what special commands can be used inside the footer. See also\n# section \"Doxygen usage\" for information on how to generate the default footer\n# that doxygen normally uses.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_FOOTER            =\n\n# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style\n# sheet that is used by each HTML page. It can be used to fine-tune the look of\n# the HTML output. If left blank doxygen will generate a default style sheet.\n# See also section \"Doxygen usage\" for information on how to generate the style\n# sheet that doxygen normally uses.\n# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as\n# it is more robust and this tag (HTML_STYLESHEET) will in the future become\n# obsolete.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_STYLESHEET        =\n\n# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined\n# cascading style sheets that are included after the standard style sheets\n# created by doxygen. Using this option one can overrule certain style aspects.\n# This is preferred over using HTML_STYLESHEET since it does not replace the\n# standard style sheet and is therefore more robust against future updates.\n# Doxygen will copy the style sheet files to the output directory.\n# Note: The order of the extra style sheet files is of importance (e.g. the last\n# style sheet in the list overrules the setting of the previous ones in the\n# list). For an example see the documentation.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_EXTRA_STYLESHEET  =\n\n# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or\n# other source files which should be copied to the HTML output directory. Note\n# that these files will be copied to the base HTML output directory. Use the\n# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these\n# files. In the HTML_STYLESHEET file, use the file name only. Also note that the\n# files will be copied as-is; there are no commands or markers available.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_EXTRA_FILES       =\n\n# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen\n# will adjust the colors in the style sheet and background images according to\n# this color. Hue is specified as an angle on a colorwheel, see\n# https://en.wikipedia.org/wiki/Hue for more information. For instance the value\n# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300\n# purple, and 360 is red again.\n# Minimum value: 0, maximum value: 359, default value: 220.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_COLORSTYLE_HUE    = 220\n\n# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors\n# in the HTML output. For a value of 0 the output will use grayscales only. A\n# value of 255 will produce the most vivid colors.\n# Minimum value: 0, maximum value: 255, default value: 100.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_COLORSTYLE_SAT    = 100\n\n# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the\n# luminance component of the colors in the HTML output. Values below 100\n# gradually make the output lighter, whereas values above 100 make the output\n# darker. The value divided by 100 is the actual gamma applied, so 80 represents\n# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not\n# change the gamma.\n# Minimum value: 40, maximum value: 240, default value: 80.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_COLORSTYLE_GAMMA  = 80\n\n# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML\n# page will contain the date and time when the page was generated. Setting this\n# to YES can help to show when doxygen was last run and thus if the\n# documentation is up to date.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_TIMESTAMP         = NO\n\n# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML\n# documentation will contain a main index with vertical navigation menus that\n# are dynamically created via JavaScript. If disabled, the navigation index will\n# consists of multiple levels of tabs that are statically embedded in every HTML\n# page. Disable this option to support browsers that do not have JavaScript,\n# like the Qt help browser.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_DYNAMIC_MENUS     = YES\n\n# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML\n# documentation will contain sections that can be hidden and shown after the\n# page has loaded.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_DYNAMIC_SECTIONS  = NO\n\n# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries\n# shown in the various tree structured indices initially; the user can expand\n# and collapse entries dynamically later on. Doxygen will expand the tree to\n# such a level that at most the specified number of entries are visible (unless\n# a fully collapsed tree already exceeds this amount). So setting the number of\n# entries 1 will produce a full collapsed tree by default. 0 is a special value\n# representing an infinite number of entries and will result in a full expanded\n# tree by default.\n# Minimum value: 0, maximum value: 9999, default value: 100.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_INDEX_NUM_ENTRIES = 100\n\n# If the GENERATE_DOCSET tag is set to YES, additional index files will be\n# generated that can be used as input for Apple's Xcode 3 integrated development\n# environment (see: https://developer.apple.com/xcode/), introduced with OSX\n# 10.5 (Leopard). To create a documentation set, doxygen will generate a\n# Makefile in the HTML output directory. Running make will produce the docset in\n# that directory and running make install will install the docset in\n# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at\n# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy\n# genXcode/_index.html for more information.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nGENERATE_DOCSET        = NO\n\n# This tag determines the name of the docset feed. A documentation feed provides\n# an umbrella under which multiple documentation sets from a single provider\n# (such as a company or product suite) can be grouped.\n# The default value is: Doxygen generated docs.\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\n\nDOCSET_FEEDNAME        = \"Doxygen generated docs\"\n\n# This tag specifies a string that should uniquely identify the documentation\n# set bundle. This should be a reverse domain-name style string, e.g.\n# com.mycompany.MyDocSet. Doxygen will append .docset to the name.\n# The default value is: org.doxygen.Project.\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\n\nDOCSET_BUNDLE_ID       = org.doxygen.Project\n\n# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify\n# the documentation publisher. This should be a reverse domain-name style\n# string, e.g. com.mycompany.MyDocSet.documentation.\n# The default value is: org.doxygen.Publisher.\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\n\nDOCSET_PUBLISHER_ID    = org.doxygen.Publisher\n\n# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.\n# The default value is: Publisher.\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\n\nDOCSET_PUBLISHER_NAME  = Publisher\n\n# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three\n# additional HTML index files: index.hhp, index.hhc, and index.hhk. The\n# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop\n# (see: https://www.microsoft.com/en-us/download/details.aspx?id=21138) on\n# Windows.\n#\n# The HTML Help Workshop contains a compiler that can convert all HTML output\n# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML\n# files are now used as the Windows 98 help format, and will replace the old\n# Windows help format (.hlp) on all Windows platforms in the future. Compressed\n# HTML files also contain an index, a table of contents, and you can search for\n# words in the documentation. The HTML workshop also contains a viewer for\n# compressed HTML files.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nGENERATE_HTMLHELP      = NO\n\n# The CHM_FILE tag can be used to specify the file name of the resulting .chm\n# file. You can add a path in front of the file if the result should not be\n# written to the html output directory.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nCHM_FILE               =\n\n# The HHC_LOCATION tag can be used to specify the location (absolute path\n# including file name) of the HTML help compiler (hhc.exe). If non-empty,\n# doxygen will try to run the HTML help compiler on the generated index.hhp.\n# The file has to be specified with full path.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nHHC_LOCATION           =\n\n# The GENERATE_CHI flag controls if a separate .chi index file is generated\n# (YES) or that it should be included in the master .chm file (NO).\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nGENERATE_CHI           = NO\n\n# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)\n# and project file content.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nCHM_INDEX_ENCODING     =\n\n# The BINARY_TOC flag controls whether a binary table of contents is generated\n# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it\n# enables the Previous and Next buttons.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nBINARY_TOC             = NO\n\n# The TOC_EXPAND flag can be set to YES to add extra items for group members to\n# the table of contents of the HTML help documentation and to the tree view.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nTOC_EXPAND             = NO\n\n# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and\n# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that\n# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help\n# (.qch) of the generated HTML documentation.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nGENERATE_QHP           = NO\n\n# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify\n# the file name of the resulting .qch file. The path specified is relative to\n# the HTML output folder.\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQCH_FILE               =\n\n# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help\n# Project output. For more information please see Qt Help Project / Namespace\n# (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).\n# The default value is: org.doxygen.Project.\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHP_NAMESPACE          = org.doxygen.Project\n\n# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt\n# Help Project output. For more information please see Qt Help Project / Virtual\n# Folders (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-\n# folders).\n# The default value is: doc.\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHP_VIRTUAL_FOLDER     = doc\n\n# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom\n# filter to add. For more information please see Qt Help Project / Custom\n# Filters (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-\n# filters).\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHP_CUST_FILTER_NAME   =\n\n# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the\n# custom filter to add. For more information please see Qt Help Project / Custom\n# Filters (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-\n# filters).\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHP_CUST_FILTER_ATTRS  =\n\n# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this\n# project's filter section matches. Qt Help Project / Filter Attributes (see:\n# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHP_SECT_FILTER_ATTRS  =\n\n# The QHG_LOCATION tag can be used to specify the location of Qt's\n# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the\n# generated .qhp file.\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHG_LOCATION           =\n\n# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be\n# generated, together with the HTML files, they form an Eclipse help plugin. To\n# install this plugin and make it available under the help contents menu in\n# Eclipse, the contents of the directory containing the HTML and XML files needs\n# to be copied into the plugins directory of eclipse. The name of the directory\n# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.\n# After copying Eclipse needs to be restarted before the help appears.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nGENERATE_ECLIPSEHELP   = NO\n\n# A unique identifier for the Eclipse help plugin. When installing the plugin\n# the directory name containing the HTML and XML files should also have this\n# name. Each documentation set should have its own identifier.\n# The default value is: org.doxygen.Project.\n# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.\n\nECLIPSE_DOC_ID         = org.doxygen.Project\n\n# If you want full control over the layout of the generated HTML pages it might\n# be necessary to disable the index and replace it with your own. The\n# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top\n# of each HTML page. A value of NO enables the index and the value YES disables\n# it. Since the tabs in the index contain the same information as the navigation\n# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nDISABLE_INDEX          = NO\n\n# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index\n# structure should be generated to display hierarchical information. If the tag\n# value is set to YES, a side panel will be generated containing a tree-like\n# index structure (just like the one that is generated for HTML Help). For this\n# to work a browser that supports JavaScript, DHTML, CSS and frames is required\n# (i.e. any modern browser). Windows users are probably better off using the\n# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can\n# further fine-tune the look of the index. As an example, the default style\n# sheet generated by doxygen has an example that shows how to put an image at\n# the root of the tree instead of the PROJECT_NAME. Since the tree basically has\n# the same information as the tab index, you could consider setting\n# DISABLE_INDEX to YES when enabling this option.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nGENERATE_TREEVIEW      = NO\n\n# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that\n# doxygen will group on one line in the generated HTML documentation.\n#\n# Note that a value of 0 will completely suppress the enum values from appearing\n# in the overview section.\n# Minimum value: 0, maximum value: 20, default value: 4.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nENUM_VALUES_PER_LINE   = 4\n\n# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used\n# to set the initial width (in pixels) of the frame in which the tree is shown.\n# Minimum value: 0, maximum value: 1500, default value: 250.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nTREEVIEW_WIDTH         = 250\n\n# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to\n# external symbols imported via tag files in a separate window.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nEXT_LINKS_IN_WINDOW    = NO\n\n# Use this tag to change the font size of LaTeX formulas included as images in\n# the HTML documentation. When you change the font size after a successful\n# doxygen run you need to manually remove any form_*.png images from the HTML\n# output directory to force them to be regenerated.\n# Minimum value: 8, maximum value: 50, default value: 10.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nFORMULA_FONTSIZE       = 10\n\n# Use the FORMULA_TRANSPARENT tag to determine whether or not the images\n# generated for formulas are transparent PNGs. Transparent PNGs are not\n# supported properly for IE 6.0, but are supported on all modern browsers.\n#\n# Note that when changing this option you need to delete any form_*.png files in\n# the HTML output directory before the changes have effect.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nFORMULA_TRANSPARENT    = YES\n\n# The FORMULA_MACROFILE can contain LaTeX \\newcommand and \\renewcommand commands\n# to create new LaTeX commands to be used in formulas as building blocks. See\n# the section \"Including formulas\" for details.\n\nFORMULA_MACROFILE      =\n\n# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see\n# https://www.mathjax.org) which uses client side JavaScript for the rendering\n# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX\n# installed or if you want to formulas look prettier in the HTML output. When\n# enabled you may also need to install MathJax separately and configure the path\n# to it using the MATHJAX_RELPATH option.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nUSE_MATHJAX            = NO\n\n# When MathJax is enabled you can set the default output format to be used for\n# the MathJax output. See the MathJax site (see:\n# http://docs.mathjax.org/en/latest/output.html) for more details.\n# Possible values are: HTML-CSS (which is slower, but has the best\n# compatibility), NativeMML (i.e. MathML) and SVG.\n# The default value is: HTML-CSS.\n# This tag requires that the tag USE_MATHJAX is set to YES.\n\nMATHJAX_FORMAT         = HTML-CSS\n\n# When MathJax is enabled you need to specify the location relative to the HTML\n# output directory using the MATHJAX_RELPATH option. The destination directory\n# should contain the MathJax.js script. For instance, if the mathjax directory\n# is located at the same level as the HTML output directory, then\n# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax\n# Content Delivery Network so you can quickly see the result without installing\n# MathJax. However, it is strongly recommended to install a local copy of\n# MathJax from https://www.mathjax.org before deployment.\n# The default value is: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/.\n# This tag requires that the tag USE_MATHJAX is set to YES.\n\nMATHJAX_RELPATH        = https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/\n\n# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax\n# extension names that should be enabled during MathJax rendering. For example\n# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols\n# This tag requires that the tag USE_MATHJAX is set to YES.\n\nMATHJAX_EXTENSIONS     =\n\n# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces\n# of code that will be used on startup of the MathJax code. See the MathJax site\n# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an\n# example see the documentation.\n# This tag requires that the tag USE_MATHJAX is set to YES.\n\nMATHJAX_CODEFILE       =\n\n# When the SEARCHENGINE tag is enabled doxygen will generate a search box for\n# the HTML output. The underlying search engine uses javascript and DHTML and\n# should work on any modern browser. Note that when using HTML help\n# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)\n# there is already a search function so this one should typically be disabled.\n# For large projects the javascript based search engine can be slow, then\n# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to\n# search using the keyboard; to jump to the search box use <access key> + S\n# (what the <access key> is depends on the OS and browser, but it is typically\n# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down\n# key> to jump into the search results window, the results can be navigated\n# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel\n# the search. The filter options can be selected when the cursor is inside the\n# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>\n# to select a filter and <Enter> or <escape> to activate or cancel the filter\n# option.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nSEARCHENGINE           = YES\n\n# When the SERVER_BASED_SEARCH tag is enabled the search engine will be\n# implemented using a web server instead of a web client using JavaScript. There\n# are two flavors of web server based searching depending on the EXTERNAL_SEARCH\n# setting. When disabled, doxygen will generate a PHP script for searching and\n# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing\n# and searching needs to be provided by external tools. See the section\n# \"External Indexing and Searching\" for details.\n# The default value is: NO.\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nSERVER_BASED_SEARCH    = NO\n\n# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP\n# script for searching. Instead the search results are written to an XML file\n# which needs to be processed by an external indexer. Doxygen will invoke an\n# external search engine pointed to by the SEARCHENGINE_URL option to obtain the\n# search results.\n#\n# Doxygen ships with an example indexer (doxyindexer) and search engine\n# (doxysearch.cgi) which are based on the open source search engine library\n# Xapian (see: https://xapian.org/).\n#\n# See the section \"External Indexing and Searching\" for details.\n# The default value is: NO.\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nEXTERNAL_SEARCH        = NO\n\n# The SEARCHENGINE_URL should point to a search engine hosted by a web server\n# which will return the search results when EXTERNAL_SEARCH is enabled.\n#\n# Doxygen ships with an example indexer (doxyindexer) and search engine\n# (doxysearch.cgi) which are based on the open source search engine library\n# Xapian (see: https://xapian.org/). See the section \"External Indexing and\n# Searching\" for details.\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nSEARCHENGINE_URL       =\n\n# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed\n# search data is written to a file for indexing by an external tool. With the\n# SEARCHDATA_FILE tag the name of this file can be specified.\n# The default file is: searchdata.xml.\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nSEARCHDATA_FILE        = searchdata.xml\n\n# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the\n# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is\n# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple\n# projects and redirect the results back to the right project.\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nEXTERNAL_SEARCH_ID     =\n\n# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen\n# projects other than the one defined by this configuration file, but that are\n# all added to the same external search index. Each project needs to have a\n# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of\n# to a relative location where the documentation can be found. The format is:\n# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nEXTRA_SEARCH_MAPPINGS  =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the LaTeX output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.\n# The default value is: YES.\n\nGENERATE_LATEX         = NO\n\n# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\n# it.\n# The default directory is: latex.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_OUTPUT           = latex\n\n# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be\n# invoked.\n#\n# Note that when not enabling USE_PDFLATEX the default is latex when enabling\n# USE_PDFLATEX the default is pdflatex and when in the later case latex is\n# chosen this is overwritten by pdflatex. For specific output languages the\n# default can have been set differently, this depends on the implementation of\n# the output language.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_CMD_NAME         = latex\n\n# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate\n# index for LaTeX.\n# Note: This tag is used in the Makefile / make.bat.\n# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file\n# (.tex).\n# The default file is: makeindex.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nMAKEINDEX_CMD_NAME     = makeindex\n\n# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to\n# generate index for LaTeX. In case there is no backslash (\\) as first character\n# it will be automatically added in the LaTeX code.\n# Note: This tag is used in the generated output file (.tex).\n# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.\n# The default value is: makeindex.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_MAKEINDEX_CMD    = makeindex\n\n# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX\n# documents. This may be useful for small projects and may help to save some\n# trees in general.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nCOMPACT_LATEX          = NO\n\n# The PAPER_TYPE tag can be used to set the paper type that is used by the\n# printer.\n# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x\n# 14 inches) and executive (7.25 x 10.5 inches).\n# The default value is: a4.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nPAPER_TYPE             = a4\n\n# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names\n# that should be included in the LaTeX output. The package can be specified just\n# by its name or with the correct syntax as to be used with the LaTeX\n# \\usepackage command. To get the times font for instance you can specify :\n# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}\n# To use the option intlimits with the amsmath package you can specify:\n# EXTRA_PACKAGES=[intlimits]{amsmath}\n# If left blank no extra packages will be included.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nEXTRA_PACKAGES         =\n\n# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the\n# generated LaTeX document. The header should contain everything until the first\n# chapter. If it is left blank doxygen will generate a standard header. See\n# section \"Doxygen usage\" for information on how to let doxygen write the\n# default header to a separate file.\n#\n# Note: Only use a user-defined header if you know what you are doing! The\n# following commands have a special meaning inside the header: $title,\n# $datetime, $date, $doxygenversion, $projectname, $projectnumber,\n# $projectbrief, $projectlogo. Doxygen will replace $title with the empty\n# string, for the replacement values of the other commands the user is referred\n# to HTML_HEADER.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_HEADER           =\n\n# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the\n# generated LaTeX document. The footer should contain everything after the last\n# chapter. If it is left blank doxygen will generate a standard footer. See\n# LATEX_HEADER for more information on how to generate a default footer and what\n# special commands can be used inside the footer.\n#\n# Note: Only use a user-defined footer if you know what you are doing!\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_FOOTER           =\n\n# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined\n# LaTeX style sheets that are included after the standard style sheets created\n# by doxygen. Using this option one can overrule certain style aspects. Doxygen\n# will copy the style sheet files to the output directory.\n# Note: The order of the extra style sheet files is of importance (e.g. the last\n# style sheet in the list overrules the setting of the previous ones in the\n# list).\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_EXTRA_STYLESHEET =\n\n# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or\n# other source files which should be copied to the LATEX_OUTPUT output\n# directory. Note that the files will be copied as-is; there are no commands or\n# markers available.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_EXTRA_FILES      =\n\n# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is\n# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will\n# contain links (just like the HTML output) instead of page references. This\n# makes the output suitable for online browsing using a PDF viewer.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nPDF_HYPERLINKS         = YES\n\n# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate\n# the PDF file directly from the LaTeX files. Set this option to YES, to get a\n# higher quality PDF documentation.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nUSE_PDFLATEX           = YES\n\n# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode\n# command to the generated LaTeX files. This will instruct LaTeX to keep running\n# if errors occur, instead of asking the user for help. This option is also used\n# when generating formulas in HTML.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_BATCHMODE        = NO\n\n# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the\n# index chapters (such as File Index, Compound Index, etc.) in the output.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_HIDE_INDICES     = NO\n\n# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source\n# code with syntax highlighting in the LaTeX output.\n#\n# Note that which sources are shown also depends on other settings such as\n# SOURCE_BROWSER.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_SOURCE_CODE      = NO\n\n# The LATEX_BIB_STYLE tag can be used to specify the style to use for the\n# bibliography, e.g. plainnat, or ieeetr. See\n# https://en.wikipedia.org/wiki/BibTeX and \\cite for more info.\n# The default value is: plain.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_BIB_STYLE        = plain\n\n# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated\n# page will contain the date and time when the page was generated. Setting this\n# to NO can help when comparing the output of multiple runs.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_TIMESTAMP        = NO\n\n# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)\n# path from which the emoji images will be read. If a relative path is entered,\n# it will be relative to the LATEX_OUTPUT directory. If left blank the\n# LATEX_OUTPUT directory will be used.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_EMOJI_DIRECTORY  =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the RTF output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The\n# RTF output is optimized for Word 97 and may not look too pretty with other RTF\n# readers/editors.\n# The default value is: NO.\n\nGENERATE_RTF           = NO\n\n# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\n# it.\n# The default directory is: rtf.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nRTF_OUTPUT             = rtf\n\n# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF\n# documents. This may be useful for small projects and may help to save some\n# trees in general.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nCOMPACT_RTF            = NO\n\n# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will\n# contain hyperlink fields. The RTF file will contain links (just like the HTML\n# output) instead of page references. This makes the output suitable for online\n# browsing using Word or some other Word compatible readers that support those\n# fields.\n#\n# Note: WordPad (write) and others do not support links.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nRTF_HYPERLINKS         = NO\n\n# Load stylesheet definitions from file. Syntax is similar to doxygen's\n# configuration file, i.e. a series of assignments. You only have to provide\n# replacements, missing definitions are set to their default value.\n#\n# See also section \"Doxygen usage\" for information on how to generate the\n# default style sheet that doxygen normally uses.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nRTF_STYLESHEET_FILE    =\n\n# Set optional variables used in the generation of an RTF document. Syntax is\n# similar to doxygen's configuration file. A template extensions file can be\n# generated using doxygen -e rtf extensionFile.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nRTF_EXTENSIONS_FILE    =\n\n# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code\n# with syntax highlighting in the RTF output.\n#\n# Note that which sources are shown also depends on other settings such as\n# SOURCE_BROWSER.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nRTF_SOURCE_CODE        = NO\n\n#---------------------------------------------------------------------------\n# Configuration options related to the man page output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for\n# classes and files.\n# The default value is: NO.\n\nGENERATE_MAN           = NO\n\n# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\n# it. A directory man3 will be created inside the directory specified by\n# MAN_OUTPUT.\n# The default directory is: man.\n# This tag requires that the tag GENERATE_MAN is set to YES.\n\nMAN_OUTPUT             = man\n\n# The MAN_EXTENSION tag determines the extension that is added to the generated\n# man pages. In case the manual section does not start with a number, the number\n# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is\n# optional.\n# The default value is: .3.\n# This tag requires that the tag GENERATE_MAN is set to YES.\n\nMAN_EXTENSION          = .3\n\n# The MAN_SUBDIR tag determines the name of the directory created within\n# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by\n# MAN_EXTENSION with the initial . removed.\n# This tag requires that the tag GENERATE_MAN is set to YES.\n\nMAN_SUBDIR             =\n\n# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it\n# will generate one additional man file for each entity documented in the real\n# man page(s). These additional files only source the real man page, but without\n# them the man command would be unable to find the correct page.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_MAN is set to YES.\n\nMAN_LINKS              = NO\n\n#---------------------------------------------------------------------------\n# Configuration options related to the XML output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that\n# captures the structure of the code including all documentation.\n# The default value is: NO.\n\nGENERATE_XML           = NO\n\n# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\n# it.\n# The default directory is: xml.\n# This tag requires that the tag GENERATE_XML is set to YES.\n\nXML_OUTPUT             = xml\n\n# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program\n# listings (including syntax highlighting and cross-referencing information) to\n# the XML output. Note that enabling this will significantly increase the size\n# of the XML output.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_XML is set to YES.\n\nXML_PROGRAMLISTING     = YES\n\n# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, doxygen will include\n# namespace members in file scope as well, matching the HTML output.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_XML is set to YES.\n\nXML_NS_MEMB_FILE_SCOPE = NO\n\n#---------------------------------------------------------------------------\n# Configuration options related to the DOCBOOK output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files\n# that can be used to generate PDF.\n# The default value is: NO.\n\nGENERATE_DOCBOOK       = NO\n\n# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.\n# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in\n# front of it.\n# The default directory is: docbook.\n# This tag requires that the tag GENERATE_DOCBOOK is set to YES.\n\nDOCBOOK_OUTPUT         = docbook\n\n# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the\n# program listings (including syntax highlighting and cross-referencing\n# information) to the DOCBOOK output. Note that enabling this will significantly\n# increase the size of the DOCBOOK output.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_DOCBOOK is set to YES.\n\nDOCBOOK_PROGRAMLISTING = NO\n\n#---------------------------------------------------------------------------\n# Configuration options for the AutoGen Definitions output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an\n# AutoGen Definitions (see http://autogen.sourceforge.net/) file that captures\n# the structure of the code including all documentation. Note that this feature\n# is still experimental and incomplete at the moment.\n# The default value is: NO.\n\nGENERATE_AUTOGEN_DEF   = NO\n\n#---------------------------------------------------------------------------\n# Configuration options related to the Perl module output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module\n# file that captures the structure of the code including all documentation.\n#\n# Note that this feature is still experimental and incomplete at the moment.\n# The default value is: NO.\n\nGENERATE_PERLMOD       = NO\n\n# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary\n# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI\n# output from the Perl module output.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_PERLMOD is set to YES.\n\nPERLMOD_LATEX          = NO\n\n# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely\n# formatted so it can be parsed by a human reader. This is useful if you want to\n# understand what is going on. On the other hand, if this tag is set to NO, the\n# size of the Perl module output will be much smaller and Perl will parse it\n# just the same.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_PERLMOD is set to YES.\n\nPERLMOD_PRETTY         = YES\n\n# The names of the make variables in the generated doxyrules.make file are\n# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful\n# so different doxyrules.make files included by the same Makefile don't\n# overwrite each other's variables.\n# This tag requires that the tag GENERATE_PERLMOD is set to YES.\n\nPERLMOD_MAKEVAR_PREFIX =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the preprocessor\n#---------------------------------------------------------------------------\n\n# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all\n# C-preprocessor directives found in the sources and include files.\n# The default value is: YES.\n\nENABLE_PREPROCESSING   = YES\n\n# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names\n# in the source code. If set to NO, only conditional compilation will be\n# performed. Macro expansion can be done in a controlled way by setting\n# EXPAND_ONLY_PREDEF to YES.\n# The default value is: NO.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nMACRO_EXPANSION        = NO\n\n# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then\n# the macro expansion is limited to the macros specified with the PREDEFINED and\n# EXPAND_AS_DEFINED tags.\n# The default value is: NO.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nEXPAND_ONLY_PREDEF     = NO\n\n# If the SEARCH_INCLUDES tag is set to YES, the include files in the\n# INCLUDE_PATH will be searched if a #include is found.\n# The default value is: YES.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nSEARCH_INCLUDES        = YES\n\n# The INCLUDE_PATH tag can be used to specify one or more directories that\n# contain include files that are not input files but should be processed by the\n# preprocessor.\n# This tag requires that the tag SEARCH_INCLUDES is set to YES.\n\nINCLUDE_PATH           =\n\n# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard\n# patterns (like *.h and *.hpp) to filter out the header-files in the\n# directories. If left blank, the patterns specified with FILE_PATTERNS will be\n# used.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nINCLUDE_FILE_PATTERNS  =\n\n# The PREDEFINED tag can be used to specify one or more macro names that are\n# defined before the preprocessor is started (similar to the -D option of e.g.\n# gcc). The argument of the tag is a list of macros of the form: name or\n# name=definition (no spaces). If the definition and the \"=\" are omitted, \"=1\"\n# is assumed. To prevent a macro definition from being undefined via #undef or\n# recursively expanded use the := operator instead of the = operator.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nPREDEFINED             =\n\n# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this\n# tag can be used to specify a list of macro names that should be expanded. The\n# macro definition that is found in the sources will be used. Use the PREDEFINED\n# tag if you want to use a different macro definition that overrules the\n# definition found in the source code.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nEXPAND_AS_DEFINED      =\n\n# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will\n# remove all references to function-like macros that are alone on a line, have\n# an all uppercase name, and do not end with a semicolon. Such function macros\n# are typically used for boiler-plate code, and will confuse the parser if not\n# removed.\n# The default value is: YES.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nSKIP_FUNCTION_MACROS   = YES\n\n#---------------------------------------------------------------------------\n# Configuration options related to external references\n#---------------------------------------------------------------------------\n\n# The TAGFILES tag can be used to specify one or more tag files. For each tag\n# file the location of the external documentation should be added. The format of\n# a tag file without this location is as follows:\n# TAGFILES = file1 file2 ...\n# Adding location for the tag files is done as follows:\n# TAGFILES = file1=loc1 \"file2 = loc2\" ...\n# where loc1 and loc2 can be relative or absolute paths or URLs. See the\n# section \"Linking to external documentation\" for more information about the use\n# of tag files.\n# Note: Each tag file must have a unique name (where the name does NOT include\n# the path). If a tag file is not located in the directory in which doxygen is\n# run, you must also specify the path to the tagfile here.\n\nTAGFILES               =\n\n# When a file name is specified after GENERATE_TAGFILE, doxygen will create a\n# tag file that is based on the input files it reads. See section \"Linking to\n# external documentation\" for more information about the usage of tag files.\n\nGENERATE_TAGFILE       =\n\n# If the ALLEXTERNALS tag is set to YES, all external class will be listed in\n# the class index. If set to NO, only the inherited external classes will be\n# listed.\n# The default value is: NO.\n\nALLEXTERNALS           = NO\n\n# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed\n# in the modules index. If set to NO, only the current project's groups will be\n# listed.\n# The default value is: YES.\n\nEXTERNAL_GROUPS        = YES\n\n# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in\n# the related pages index. If set to NO, only the current project's pages will\n# be listed.\n# The default value is: YES.\n\nEXTERNAL_PAGES         = YES\n\n#---------------------------------------------------------------------------\n# Configuration options related to the dot tool\n#---------------------------------------------------------------------------\n\n# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram\n# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to\n# NO turns the diagrams off. Note that this option also works with HAVE_DOT\n# disabled, but it is recommended to install and use dot, since it yields more\n# powerful graphs.\n# The default value is: YES.\n\nCLASS_DIAGRAMS         = YES\n\n# You can include diagrams made with dia in doxygen documentation. Doxygen will\n# then run dia to produce the diagram and insert it in the documentation. The\n# DIA_PATH tag allows you to specify the directory where the dia binary resides.\n# If left empty dia is assumed to be found in the default search path.\n\nDIA_PATH               =\n\n# If set to YES the inheritance and collaboration graphs will hide inheritance\n# and usage relations if the target is undocumented or is not a class.\n# The default value is: YES.\n\nHIDE_UNDOC_RELATIONS   = YES\n\n# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is\n# available from the path. This tool is part of Graphviz (see:\n# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent\n# Bell Labs. The other options in this section have no effect if this option is\n# set to NO\n# The default value is: YES.\n\nHAVE_DOT               = NO\n\n# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed\n# to run in parallel. When set to 0 doxygen will base this on the number of\n# processors available in the system. You can set it explicitly to a value\n# larger than 0 to get control over the balance between CPU load and processing\n# speed.\n# Minimum value: 0, maximum value: 32, default value: 0.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_NUM_THREADS        = 0\n\n# When you want a differently looking font in the dot files that doxygen\n# generates you can specify the font name using DOT_FONTNAME. You need to make\n# sure dot is able to find the font, which can be done by putting it in a\n# standard location or by setting the DOTFONTPATH environment variable or by\n# setting DOT_FONTPATH to the directory containing the font.\n# The default value is: Helvetica.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_FONTNAME           = Helvetica\n\n# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of\n# dot graphs.\n# Minimum value: 4, maximum value: 24, default value: 10.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_FONTSIZE           = 10\n\n# By default doxygen will tell dot to use the default font as specified with\n# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set\n# the path where dot can find it using this tag.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_FONTPATH           =\n\n# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for\n# each documented class showing the direct and indirect inheritance relations.\n# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nCLASS_GRAPH            = YES\n\n# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a\n# graph for each documented class showing the direct and indirect implementation\n# dependencies (inheritance, containment, and class references variables) of the\n# class with other documented classes.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nCOLLABORATION_GRAPH    = YES\n\n# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for\n# groups, showing the direct groups dependencies.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nGROUP_GRAPHS           = YES\n\n# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and\n# collaboration diagrams in a style similar to the OMG's Unified Modeling\n# Language.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nUML_LOOK               = NO\n\n# If the UML_LOOK tag is enabled, the fields and methods are shown inside the\n# class node. If there are many fields or methods and many nodes the graph may\n# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the\n# number of items for each type to make the size more manageable. Set this to 0\n# for no limit. Note that the threshold may be exceeded by 50% before the limit\n# is enforced. So when you set the threshold to 10, up to 15 fields may appear,\n# but if the number exceeds 15, the total amount of fields shown is limited to\n# 10.\n# Minimum value: 0, maximum value: 100, default value: 10.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nUML_LIMIT_NUM_FIELDS   = 10\n\n# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and\n# collaboration graphs will show the relations between templates and their\n# instances.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nTEMPLATE_RELATIONS     = NO\n\n# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to\n# YES then doxygen will generate a graph for each documented file showing the\n# direct and indirect include dependencies of the file with other documented\n# files.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nINCLUDE_GRAPH          = YES\n\n# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are\n# set to YES then doxygen will generate a graph for each documented file showing\n# the direct and indirect include dependencies of the file with other documented\n# files.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nINCLUDED_BY_GRAPH      = YES\n\n# If the CALL_GRAPH tag is set to YES then doxygen will generate a call\n# dependency graph for every global function or class method.\n#\n# Note that enabling this option will significantly increase the time of a run.\n# So in most cases it will be better to enable call graphs for selected\n# functions only using the \\callgraph command. Disabling a call graph can be\n# accomplished by means of the command \\hidecallgraph.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nCALL_GRAPH             = NO\n\n# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller\n# dependency graph for every global function or class method.\n#\n# Note that enabling this option will significantly increase the time of a run.\n# So in most cases it will be better to enable caller graphs for selected\n# functions only using the \\callergraph command. Disabling a caller graph can be\n# accomplished by means of the command \\hidecallergraph.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nCALLER_GRAPH           = NO\n\n# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical\n# hierarchy of all classes instead of a textual one.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nGRAPHICAL_HIERARCHY    = YES\n\n# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the\n# dependencies a directory has on other directories in a graphical way. The\n# dependency relations are determined by the #include relations between the\n# files in the directories.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDIRECTORY_GRAPH        = YES\n\n# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images\n# generated by dot. For an explanation of the image formats see the section\n# output formats in the documentation of the dot tool (Graphviz (see:\n# http://www.graphviz.org/)).\n# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order\n# to make the SVG files visible in IE 9+ (other browsers do not have this\n# requirement).\n# Possible values are: png, png:cairo, png:cairo:cairo, png:cairo:gd, png:gd,\n# png:gd:gd, jpg, jpg:cairo, jpg:cairo:gd, jpg:gd, jpg:gd:gd, gif, gif:cairo,\n# gif:cairo:gd, gif:gd, gif:gd:gd, svg, png:gd, png:gd:gd, png:cairo,\n# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and\n# png:gdiplus:gdiplus.\n# The default value is: png.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_IMAGE_FORMAT       = png\n\n# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to\n# enable generation of interactive SVG images that allow zooming and panning.\n#\n# Note that this requires a modern browser other than Internet Explorer. Tested\n# and working are Firefox, Chrome, Safari, and Opera.\n# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make\n# the SVG files visible. Older versions of IE do not have SVG support.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nINTERACTIVE_SVG        = NO\n\n# The DOT_PATH tag can be used to specify the path where the dot tool can be\n# found. If left blank, it is assumed the dot tool can be found in the path.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_PATH               =\n\n# The DOTFILE_DIRS tag can be used to specify one or more directories that\n# contain dot files that are included in the documentation (see the \\dotfile\n# command).\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOTFILE_DIRS           =\n\n# The MSCFILE_DIRS tag can be used to specify one or more directories that\n# contain msc files that are included in the documentation (see the \\mscfile\n# command).\n\nMSCFILE_DIRS           =\n\n# The DIAFILE_DIRS tag can be used to specify one or more directories that\n# contain dia files that are included in the documentation (see the \\diafile\n# command).\n\nDIAFILE_DIRS           =\n\n# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the\n# path where java can find the plantuml.jar file. If left blank, it is assumed\n# PlantUML is not used or called during a preprocessing step. Doxygen will\n# generate a warning when it encounters a \\startuml command in this case and\n# will not generate output for the diagram.\n\nPLANTUML_JAR_PATH      =\n\n# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a\n# configuration file for plantuml.\n\nPLANTUML_CFG_FILE      =\n\n# When using plantuml, the specified paths are searched for files specified by\n# the !include statement in a plantuml block.\n\nPLANTUML_INCLUDE_PATH  =\n\n# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes\n# that will be shown in the graph. If the number of nodes in a graph becomes\n# larger than this value, doxygen will truncate the graph, which is visualized\n# by representing a node as a red box. Note that doxygen if the number of direct\n# children of the root node in a graph is already larger than\n# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that\n# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.\n# Minimum value: 0, maximum value: 10000, default value: 50.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_GRAPH_MAX_NODES    = 50\n\n# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs\n# generated by dot. A depth value of 3 means that only nodes reachable from the\n# root by following a path via at most 3 edges will be shown. Nodes that lay\n# further from the root node will be omitted. Note that setting this option to 1\n# or 2 may greatly reduce the computation time needed for large code bases. Also\n# note that the size of a graph can be further restricted by\n# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.\n# Minimum value: 0, maximum value: 1000, default value: 0.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nMAX_DOT_GRAPH_DEPTH    = 0\n\n# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent\n# background. This is disabled by default, because dot on Windows does not seem\n# to support this out of the box.\n#\n# Warning: Depending on the platform used, enabling this option may lead to\n# badly anti-aliased labels on the edges of a graph (i.e. they become hard to\n# read).\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_TRANSPARENT        = NO\n\n# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output\n# files in one run (i.e. multiple -o and -T options on the command line). This\n# makes dot run faster, but since only newer versions of dot (>1.8.10) support\n# this, this feature is disabled by default.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_MULTI_TARGETS      = NO\n\n# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page\n# explaining the meaning of the various boxes and arrows in the dot generated\n# graphs.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nGENERATE_LEGEND        = YES\n\n# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot\n# files that are used to generate the various graphs.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_CLEANUP            = YES\n"
        },
        {
          "name": "dumpcap.c",
          "type": "blob",
          "size": 239.60546875,
          "content": "/* dumpcap.c\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN LOG_DOMAIN_CAPCHILD\n\n#include <stdio.h>\n#include <stdlib.h> /* for exit() */\n#include <glib.h>\n\n#include <string.h>\n\n#include <ws_exit_codes.h>\n\n#include <sys/types.h>\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n\n#include <wsutil/ws_getopt.h>\n\n#if defined(__APPLE__) && defined(__LP64__)\n#include <sys/utsname.h>\n#endif\n\n#include <signal.h>\n#include <errno.h>\n\n#include <wsutil/application_flavor.h>\n#include <wsutil/array.h>\n#include <wsutil/cmdarg_err.h>\n#include <wsutil/report_message.h>\n#include <wsutil/failure_message_simple.h>\n#include <wsutil/strtoi.h>\n#include <cli_main.h>\n#include <wsutil/version_info.h>\n\n#include <wsutil/socket.h>\n#include <wsutil/wslog.h>\n#include <wsutil/file_util.h>\n\n#ifdef HAVE_LIBCAP\n# include <sys/prctl.h>\n# include <sys/capability.h>\n#endif\n\n#include \"ringbuffer.h\"\n\n#include \"capture/capture_ifinfo.h\"\n#include \"capture/capture-pcap-util.h\"\n#include \"capture/capture-pcap-util-int.h\"\n#ifdef _WIN32\n#include \"capture/capture-wpcap.h\"\n#endif /* _WIN32 */\n\n#include \"writecap/pcapio.h\"\n\n#ifndef _WIN32\n#include <sys/un.h>\n#endif\n\n#include <wsutil/clopts_common.h>\n#include <wsutil/privileges.h>\n\n#include \"sync_pipe.h\"\n\n#include \"ui/capture_opts.h\"\n#include <capture/capture_session.h>\n#include <capture/capture_sync.h>\n\n#include \"wsutil/tempfile.h\"\n#include \"wsutil/file_util.h\"\n#include \"wsutil/cpu_info.h\"\n#include \"wsutil/os_version_info.h\"\n#include \"wsutil/str_util.h\"\n#include \"wsutil/inet_addr.h\"\n#include \"wsutil/time_util.h\"\n#include \"wsutil/please_report_bug.h\"\n#include \"wsutil/glib-compat.h\"\n#include <wsutil/json_dumper.h>\n#include <wsutil/ws_assert.h>\n\n#include \"capture/ws80211_utils.h\"\n\n#include \"extcap.h\"\n\n/*\n * Get information about libpcap format from \"wiretap/libpcap.h\".\n * Get information about pcapng format from \"wiretap/pcapng_module.h\".\n * XXX - can we just use pcap_open_offline() to read the pipe?\n */\n#include \"wiretap/libpcap.h\"\n#include \"wiretap/pcapng_module.h\"\n#include \"wiretap/pcapng.h\"\n\n/*\n * Define these for extra logging. Note that when dumpcap is spawned as\n * a child process, logs are sent to the parent via the sync pipe.\n * The parent will pass along the Capchild domain log level settings,\n * so \"--log-debug Capchild\" or \"--log-level debug\" can be used to get\n * debugging from dumpcap sent to the parent.\n */\n//#define DEBUG_DUMPCAP       /* Waits for keypress on quitting on Windows */\n//#define DEBUG_CHILD_DUMPCAP /* Writes logs to file */\n\n#ifdef _WIN32\n#include \"wsutil/win32-utils.h\"\n#ifdef DEBUG_DUMPCAP\n#include <conio.h>          /* _getch() */\n#endif\n#endif\n\n#ifdef DEBUG_CHILD_DUMPCAP\nFILE *debug_log;   /* for logging debug messages to  */\n                   /*  a file if DEBUG_CHILD_DUMPCAP */\n                   /*  is defined                    */\n#include <stdarg.h> /* va_copy */\n#endif\n\nstatic GAsyncQueue *pcap_queue;\nstatic int64_t pcap_queue_bytes;\nstatic int64_t pcap_queue_packets;\nstatic int64_t pcap_queue_byte_limit;\nstatic int64_t pcap_queue_packet_limit;\n\nstatic bool capture_child; /* false: standalone call, true: this is an Wireshark capture child */\nstatic const char *report_capture_filename; /* capture child file name */\n#ifdef _WIN32\nstatic char *sig_pipe_name;\nstatic HANDLE sig_pipe_handle;\nstatic bool signal_pipe_check_running(void);\n#endif\nstatic int sync_pipe_fd = 2;\n\n#if defined (ENABLE_ASAN) || defined (ENABLE_LSAN)\n/* This has public visibility so that if compiled with shared libasan (the\n * gcc default) function interposition occurs.\n */\nWS_DLL_PUBLIC int\n__lsan_is_turned_off(void)\n{\n    /* If we're in capture child mode, don't run a LSan report and\n     * send it to stderr, because it isn't properly formatted for\n     * the sync pipe.\n     * We could, if debugging variables are set, send the reports\n     * elsewhere instead, by calling __sanitizer_set_report_path()\n     * or __sanitizer_set_report_fd()\n     */\n    if (capture_child) {\n        return 1;\n    }\n#ifdef HAVE_LIBCAP\n    /* LSan dies with a fatal error without explanation if it can't ptrace.\n     * Normally, the \"dumpable\" attribute (which also controls ptracing)\n     * is set to 1 (SUID_DUMP_USER, process is dumpable.) However, it is\n     * reset to the current value in /proc/sys/fs/suid_dumpable in the\n     * following circumstances: euid/egid changes, fsuid/fsgid changes,\n     * execve of a setuid or setgid program that changes the euid or egid,\n     * execve of a program with capabilities exceeding those already\n     * permitted for the process.\n     *\n     * Unless we're running as root, one of those applies to dumpcap.\n     *\n     * The default value of /proc/sys/fs/suid_dumpable is 0, SUID_DUMP_DISABLE.\n     * In such a case, LeakSanitizer temporarily sets the value to 1 to\n     * allow ptracing, and then sets it back to 0.\n     *\n     * Another possible value, used by Ubuntu, Fedora, etc., is 2,\n     * which creates dumps readable by root only. For security reasons,\n     * unprivileged programs are not allowed to change the value to 2.\n     * (See https://nvd.nist.gov/vuln/detail/CVE-2006-2451 )\n     *\n     * LSan does not check for the value 2 and change dumpable to 1 in that\n     * case, possibly because if it did it could not change it back to 2\n     * and would have to either leave the process dumpable or change it to 0.\n     *\n     * The usual way to control the family of sanitizers is through environment\n     * variables. However, complicating things, changing the dumpable attribute\n     * to 0 or 2 changes the ownership of files in /proc/[pid] (including\n     * /proc/self ) to root:root, in particular /proc/[pid]/environ, and so\n     * ASAN_OPTIONS=detect_leaks=0 has no effect. (Unless the process has\n     * CAP_SYS_PTRACE, which allows tracing of any process, but that's also\n     * a security risk and we'll have dropped that with other privileges.)\n     *\n     * So if prctl(PR_GET_DUMPABLE) returns 2, we know that the process will\n     * die with a fatal error if it attempts to run LSan, so don't.\n     *\n     * See proc(5), prctl(2), ptrace(2), and\n     * https://github.com/google/sanitizers/issues/1306\n     * https://github.com/llvm/llvm-project/issues/55944\n     */\n    if (prctl(PR_GET_DUMPABLE) == 2) {\n        ws_debug(\"Not running LeakSanitizer because /proc/sys/fs/suid_dumpable is 2\");\n        return 1;\n    }\n#endif\n    return 0;\n}\n\nWS_DLL_PUBLIC const char*\n__asan_default_options(void)\n{\n    /* By default don't override our exit code if there's a leak or error.\n     * We particularly don't want to do this if running as a capture child,\n     * because capture/capture_sync doesn't expect the ASan exit codes.\n     */\n    return \"exitcode=0\";\n}\n\nWS_DLL_PUBLIC const char*\n__lsan_default_options(void)\n{\n    /* By default don't override our exit code if there's a leak or error.\n     * We particularly don't want to do this if running as a capture child,\n     * because capture/capture_sync doesn't expect the LSan exit codes.\n     */\n    return \"exitcode=0\";\n}\n#endif\n\n#ifdef SIGINFO\nstatic bool infodelay;      /* if true, don't print capture info in SIGINFO handler */\nstatic bool infoprint;      /* if true, print capture info after clearing infodelay */\n#endif /* SIGINFO */\n\n/** Stop a low-level capture (stops the capture child). */\nstatic void capture_loop_stop(void);\n/** Close a pipe, or socket if \\a from_socket is true */\nstatic void cap_pipe_close(int pipe_fd, bool from_socket);\n\n#if defined (__linux__)\n/* whatever the deal with pcap_breakloop, linux doesn't support timeouts\n * in pcap_dispatch(); on the other hand, select() works just fine there.\n * Hence we use a select for that come what may.\n *\n * XXX - with TPACKET_V1 and TPACKET_V2, it currently uses select()\n * internally, and, with TPACKET_V3, once that's supported, it'll\n * support timeouts, at least as I understand the way the code works.\n */\n#define MUST_DO_SELECT\n#endif\n\n/** init the capture filter */\ntypedef enum {\n    INITFILTER_NO_ERROR,\n    INITFILTER_BAD_FILTER,\n    INITFILTER_OTHER_ERROR\n} initfilter_status_t;\n\ntypedef enum {\n    STATE_EXPECT_REC_HDR,\n    STATE_READ_REC_HDR,\n    STATE_EXPECT_DATA,\n    STATE_READ_DATA\n} cap_pipe_state_t;\n\ntypedef enum {\n    PIPOK,\n    PIPEOF,\n    PIPERR,\n    PIPNEXIST\n} cap_pipe_err_t;\n\ntypedef struct _pcap_pipe_info {\n    bool                         byte_swapped; /**< true if data in the pipe is byte swapped. */\n    struct pcap_hdr              hdr;          /**< Pcap header when capturing from a pipe */\n    struct pcaprec_modified_hdr  rechdr;       /**< Pcap record header when capturing from a pipe */\n} pcap_pipe_info_t;\n\ntypedef struct _pcapng_pipe_info {\n    pcapng_block_header_t bh;                  /**< Pcapng general block header when capturing from a pipe */\n    GArray *src_iface_to_global;               /**< Int array mapping local IDB numbers to global_ld.interface_data */\n} pcapng_pipe_info_t;\n\nstruct _loop_data; /* forward declaration so we can use it in the cap_pipe_dispatch function pointer */\n\n/*\n * A source of packets from which we're capturing.\n */\ntypedef struct _capture_src {\n    uint32_t                     received;\n    uint32_t                     dropped;\n    uint32_t                     flushed;\n    pcap_t                      *pcap_h;\n#ifdef MUST_DO_SELECT\n    int                          pcap_fd;                /**< pcap file descriptor */\n#endif\n    bool                         pcap_err;\n    unsigned                     interface_id;\n    unsigned                     idb_id;                 /**< If from_pcapng is false, the output IDB interface ID. Otherwise the mapping in src_iface_to_global is used. */\n    GThread                     *tid;\n    int                          snaplen;\n    int                          linktype;\n    bool                         ts_nsec;                /**< true if we're using nanosecond precision. */\n                                                         /**< capture pipe (unix only \"input file\") */\n    bool                         from_cap_pipe;          /**< true if we are capturing data from a capture pipe */\n    bool                         from_cap_socket;        /**< true if we're capturing from socket */\n    bool                         from_pcapng;            /**< true if we're capturing from pcapng format */\n    union {\n        pcap_pipe_info_t         pcap;                   /**< Pcap info when capturing from a pipe */\n        pcapng_pipe_info_t       pcapng;                 /**< Pcapng info when capturing from a pipe */\n    } cap_pipe_info;\n#ifdef _WIN32\n    HANDLE                       cap_pipe_h;             /**< The handle of the capture pipe */\n#endif\n    int                          cap_pipe_fd;            /**< the file descriptor of the capture pipe */\n    bool                         cap_pipe_modified;      /**< true if data in the pipe uses modified pcap headers */\n    char *                       cap_pipe_databuf;       /**< Pointer to the data buffer we've allocated */\n    size_t                       cap_pipe_databuf_size;  /**< Current size of the data buffer */\n    unsigned                     cap_pipe_max_pkt_size;  /**< Maximum packet size allowed */\n#if defined(_WIN32)\n    char *                       cap_pipe_buf;           /**< Pointer to the buffer we read into */\n    DWORD                        cap_pipe_bytes_to_read; /**< Used by cap_pipe_dispatch */\n    DWORD                        cap_pipe_bytes_read;    /**< Used by cap_pipe_dispatch */\n#else\n    size_t                       cap_pipe_bytes_to_read; /**< Used by cap_pipe_dispatch */\n    size_t                       cap_pipe_bytes_read;    /**< Used by cap_pipe_dispatch */\n#endif\n    int (*cap_pipe_dispatch)(struct _loop_data *, struct _capture_src *, char *, size_t);\n    cap_pipe_state_t cap_pipe_state;\n    cap_pipe_err_t cap_pipe_err;\n\n#if defined(_WIN32)\n    GMutex                      *cap_pipe_read_mtx;\n    GAsyncQueue                 *cap_pipe_pending_q, *cap_pipe_done_q;\n#endif\n} capture_src;\n\ntypedef struct _saved_idb {\n    bool deleted;\n    unsigned interface_id; /* capture_src->interface_id for the associated SHB */\n    uint8_t *idb;        /* If non-NULL, IDB read from capture_src. This is an interface specified on the command line otherwise. */\n    unsigned idb_len;\n} saved_idb_t;\n\n/*\n * Global capture loop state.\n */\ntypedef struct _loop_data {\n    /* common */\n    bool      go;                  /**< true as long as we're supposed to keep capturing */\n    int       err;                 /**< if non-zero, error seen while capturing */\n    int       packets_captured;    /**< Number of packets we have already captured */\n    unsigned  inpkts_to_sync_pipe; /**< Packets not already send out to the sync_pipe */\n#ifdef SIGINFO\n    bool      report_packet_count; /**< Set by SIGINFO handler; print packet count */\n#endif\n    GArray   *pcaps;               /**< Array of capture_src's on which we're capturing */\n    bool      pcapng_passthrough;  /**< We have one source and it's pcapng. Pass its SHB and IDBs through. */\n    uint8_t  *saved_shb;           /**< SHB to write when we have one pcapng input */\n    GArray   *saved_idbs;          /**< Array of saved_idb_t, written when we have a new section or output file. */\n    GRWLock   saved_shb_idb_lock;  /**< Saved IDB RW mutex */\n    /* output file(s) */\n    FILE     *pdh;\n    int       save_file_fd;\n    char     *io_buffer;           /**< Our IO buffer if we increase the size from the standard size */\n    uint64_t  bytes_written;       /**< Bytes written for the current file. */\n    /* autostop conditions */\n    int       packets_written;     /**< Packets written for the current file. */\n    int       file_count;\n    /* ring buffer conditions */\n    GTimer  *file_duration_timer;\n    time_t   next_interval_time;\n    int      interval_s;\n} loop_data;\n\ntypedef struct _pcap_queue_element {\n    capture_src        *pcap_src;\n    union {\n        struct pcap_pkthdr  phdr;\n        pcapng_block_header_t  bh;\n    } u;\n    uint8_t             *pd;\n} pcap_queue_element;\n\n/*\n * This needs to be static, so that the SIGINT handler can clear the \"go\"\n * flag and for saved_shb_idb_lock.\n */\nstatic loop_data   global_ld;\n\n/*\n * Timeout, in milliseconds, for reads from the stream of captured packets\n * from a capture device.\n *\n * A bug in Mac OS X 10.6 and 10.6.1 causes calls to pcap_open_live(), in\n * 64-bit applications, with sub-second timeouts not to work.  The bug is\n * fixed in 10.6.2, re-broken in 10.6.3, and again fixed in 10.6.5.\n */\n#if defined(__APPLE__) && defined(__LP64__)\nstatic bool need_timeout_workaround;\n\n#define CAP_READ_TIMEOUT        (need_timeout_workaround ? 1000 : 250)\n#else\n#define CAP_READ_TIMEOUT        250\n#endif\n\n/*\n * Timeout, in microseconds, for reads from the stream of captured packets\n * from a pipe.  Pipes don't have the same problem that BPF devices do\n * in Mac OS X 10.6, 10.6.1, 10.6.3, and 10.6.4, so we always use a timeout\n * of 250ms, i.e. the same value as CAP_READ_TIMEOUT when not on one\n * of the offending versions of Snow Leopard.\n *\n * On Windows this value is converted to milliseconds and passed to\n * WaitForSingleObject. If it's less than 1000 WaitForSingleObject\n * will return immediately.\n */\n#if defined(_WIN32)\n#define PIPE_READ_TIMEOUT   100000\n#else\n#define PIPE_READ_TIMEOUT   250000\n#endif\n\n#define WRITER_THREAD_TIMEOUT 100000 /* usecs */\n\nstatic void\ndumpcap_log_writer(const char *domain, enum ws_log_level level,\n                                   const char *file, long line, const char *func,\n                                   const char *fatal_msg, ws_log_manifest_t *mft,\n                                   const char *user_format, va_list user_ap,\n                                   void *user_data);\n\n/* capture related options */\nstatic capture_options global_capture_opts;\nstatic GPtrArray *capture_comments;\nstatic bool quiet;\nstatic bool really_quiet;\nstatic bool use_threads;\nstatic uint64_t start_time;\n\nstatic void capture_loop_write_packet_cb(uint8_t *pcap_src_p, const struct pcap_pkthdr *phdr,\n                                         const uint8_t *pd);\nstatic void capture_loop_queue_packet_cb(uint8_t *pcap_src_p, const struct pcap_pkthdr *phdr,\n                                         const uint8_t *pd);\nstatic void capture_loop_write_pcapng_cb(capture_src *pcap_src, const pcapng_block_header_t *bh, uint8_t *pd);\nstatic void capture_loop_queue_pcapng_cb(capture_src *pcap_src, const pcapng_block_header_t *bh, uint8_t *pd);\nstatic void capture_loop_get_errmsg(char *errmsg, size_t errmsglen,\n                                    char *secondary_errmsg,\n                                    size_t secondary_errmsglen,\n                                    const char *fname, int err,\n                                    bool is_close);\n\nWS_NORETURN static void exit_main(int err);\n\nstatic void report_new_capture_file(const char *filename);\nstatic void report_packet_count(unsigned int packet_count);\nstatic void report_packet_drops(uint32_t received, uint32_t pcap_drops, uint32_t drops, uint32_t flushed, uint32_t ps_ifdrop, char *name);\nstatic void report_capture_error(const char *error_msg, const char *secondary_error_msg);\nstatic void report_cfilter_error(capture_options *capture_opts, unsigned i, const char *errmsg);\n\n#define MSG_MAX_LENGTH 4096\n\nstatic void\nprint_usage(FILE *output)\n{\n    fprintf(output, \"\\nUsage: dumpcap [options] ...\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Capture interface:\\n\");\n    fprintf(output, \"  -i <interface>, --interface <interface>\\n\");\n    fprintf(output, \"                           name or idx of interface (def: first non-loopback)\\n\"\n#ifdef HAVE_PCAP_REMOTE\n                    \"                           or for remote capturing, use one of these formats:\\n\"\n                    \"                               rpcap://<host>/<interface>\\n\"\n#else\n                    \"                           or for remote capturing, use this format:\\n\"\n#endif\n                    \"                               TCP@<host>:<port>\\n\");\n    fprintf(output, \"  --ifname <name>          name to use in the capture file for a pipe from which\\n\");\n    fprintf(output, \"                           we're capturing\\n\");\n    fprintf(output, \"  --ifdescr <description>\\n\");\n    fprintf(output, \"                           description to use in the capture file for a pipe\\n\");\n    fprintf(output, \"                           from which we're capturing\\n\");\n    fprintf(output, \"  -f <capture filter>      packet filter in libpcap filter syntax\\n\");\n    fprintf(output, \"  -s <snaplen>, --snapshot-length <snaplen>\\n\");\n    fprintf(output, \"                           packet snapshot length (def: appropriate maximum)\\n\");\n    fprintf(output, \"  -p, --no-promiscuous-mode\\n\");\n    fprintf(output, \"                           don't capture in promiscuous mode\\n\");\n    fprintf(output, \"  -I, --monitor-mode       capture in monitor mode, if available\\n\");\n    fprintf(output, \"  -B <buffer size>, --buffer-size <buffer size>\\n\");\n    fprintf(output, \"                           size of kernel buffer in MiB (def: %dMiB)\\n\", DEFAULT_CAPTURE_BUFFER_SIZE);\n    fprintf(output, \"  -y <link type>, --linktype <link type>\\n\");\n    fprintf(output, \"                           link layer type (def: first appropriate)\\n\");\n    fprintf(output, \"  --time-stamp-type <type> timestamp method for interface\\n\");\n    fprintf(output, \"  -D, --list-interfaces    print list of interfaces and exit\\n\");\n    fprintf(output, \"  -L, --list-data-link-types\\n\");\n    fprintf(output, \"                           print list of link-layer types of iface and exit\\n\");\n    fprintf(output, \"  --list-time-stamp-types  print list of timestamp types for iface and exit\\n\");\n    fprintf(output, \"  --update-interval        interval between updates with new packets, in milliseconds (def: %dms)\\n\", DEFAULT_UPDATE_INTERVAL);\n    fprintf(output, \"  -d                       print generated BPF code for capture filter\\n\");\n    fprintf(output, \"  -k <freq>,[<type>],[<center_freq1>],[<center_freq2>]\\n\");\n    fprintf(output, \"                           set channel on wifi interface\\n\");\n    fprintf(output, \"  -S                       print statistics for each interface once per second\\n\");\n    fprintf(output, \"  -M                       for -D, -L, and -S, produce machine-readable output\\n\");\n    fprintf(output, \"\\n\");\n#ifdef HAVE_PCAP_REMOTE\n    fprintf(output, \"RPCAP options:\\n\");\n    fprintf(output, \"  -r                       don't ignore own RPCAP traffic in capture\\n\");\n    fprintf(output, \"  -u                       use UDP for RPCAP data transfer\\n\");\n    fprintf(output, \"  -A <user>:<password>     use RPCAP password authentication\\n\");\n#ifdef HAVE_PCAP_SETSAMPLING\n    fprintf(output, \"  -m <sampling type>       use packet sampling\\n\");\n    fprintf(output, \"                           count:NUM - capture one packet of every NUM\\n\");\n    fprintf(output, \"                           timer:NUM - capture no more than 1 packet in NUM ms\\n\");\n#endif\n#endif\n    fprintf(output, \"Stop conditions:\\n\");\n    fprintf(output, \"  -c <packet count>        stop after n packets (def: infinite)\\n\");\n    fprintf(output, \"  -a <autostop cond.> ..., --autostop <autostop cond.> ...\\n\");\n    fprintf(output, \"                           duration:NUM - stop after NUM seconds\\n\");\n    fprintf(output, \"                           filesize:NUM - stop this file after NUM kB\\n\");\n    fprintf(output, \"                              files:NUM - stop after NUM files\\n\");\n    fprintf(output, \"                            packets:NUM - stop after NUM packets\\n\");\n    /*fprintf(output, \"\\n\");*/\n    fprintf(output, \"Output (files):\\n\");\n    fprintf(output, \"  -w <filename>            name of file to save (def: tempfile)\\n\");\n    fprintf(output, \"  -g                       enable group read access on the output file(s)\\n\");\n    fprintf(output, \"  -b <ringbuffer opt.> ..., --ring-buffer <ringbuffer opt.>\\n\");\n    fprintf(output, \"                           duration:NUM - switch to next file after NUM secs\\n\");\n    fprintf(output, \"                           filesize:NUM - switch to next file after NUM kB\\n\");\n    fprintf(output, \"                              files:NUM - ringbuffer: replace after NUM files\\n\");\n    fprintf(output, \"                            packets:NUM - ringbuffer: replace after NUM packets\\n\");\n    fprintf(output, \"                           interval:NUM - switch to next file when the time is\\n\");\n    fprintf(output, \"                                          an exact multiple of NUM secs\\n\");\n    fprintf(output, \"                          printname:FILE - print filename to FILE when written\\n\");\n    fprintf(output, \"                                           (can use 'stdout' or 'stderr')\\n\");\n    fprintf(output, \"  -n                       use pcapng format instead of pcap (default)\\n\");\n    fprintf(output, \"  -P                       use libpcap format instead of pcapng\\n\");\n    fprintf(output, \"  --capture-comment <comment>\\n\");\n    fprintf(output, \"                           add a capture comment to the output file\\n\");\n    fprintf(output, \"                           (only for pcapng)\\n\");\n    fprintf(output, \"  --temp-dir <directory>   write temporary files to this directory\\n\");\n    fprintf(output, \"                           (default: %s)\\n\", g_get_tmp_dir());\n    fprintf(output, \"\\n\");\n\n    ws_log_print_usage(output);\n    fprintf(output, \"\\n\");\n\n    fprintf(output, \"Miscellaneous:\\n\");\n    fprintf(output, \"  -N <packet_limit>        maximum number of packets buffered within dumpcap\\n\");\n    fprintf(output, \"  -C <byte_limit>          maximum number of bytes used for buffering packets\\n\");\n    fprintf(output, \"                           within dumpcap\\n\");\n    fprintf(output, \"  -t                       use a separate thread per interface\\n\");\n    fprintf(output, \"  -q                       don't report packet capture counts\\n\");\n    fprintf(output, \"  --application-flavor <flavor>\\n\");\n    fprintf(output, \"                           set the application flavor\\n\");\n    fprintf(output, \"  -v, --version            print version information and exit\\n\");\n    fprintf(output, \"  -h, --help               display this help and exit\\n\");\n    fprintf(output, \"\\n\");\n#ifdef __linux__\n    fprintf(output, \"Dumpcap can benefit from an enabled BPF JIT compiler if available.\\n\");\n    fprintf(output, \"You might want to enable it by executing:\\n\");\n    fprintf(output, \" \\\"echo 1 > /proc/sys/net/core/bpf_jit_enable\\\"\\n\");\n    fprintf(output, \"Note that this can make your system less secure!\\n\");\n    fprintf(output, \"\\n\");\n#endif\n    fprintf(output, \"Example: dumpcap -i eth0 -a duration:60 -w output.pcapng\\n\");\n    fprintf(output, \"\\\"Capture packets from interface eth0 until 60s passed into output.pcapng\\\"\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Use Ctrl-C to stop capturing at any time.\\n\");\n}\n\n/*\n * Report an error in command-line arguments.\n * If we're a capture child, send a message back to the parent, otherwise\n * just print it.\n */\nstatic void\ndumpcap_cmdarg_err(const char *fmt, va_list ap)\n{\n    if (capture_child) {\n        char *msg;\n        /* Generate a 'special format' message back to parent */\n        msg = ws_strdup_vprintf(fmt, ap);\n        sync_pipe_write_errmsgs_to_parent(sync_pipe_fd, msg, \"\");\n        g_free(msg);\n    } else {\n        fprintf(stderr, \"dumpcap: \");\n        vfprintf(stderr, fmt, ap);\n        fprintf(stderr, \"\\n\");\n    }\n}\n\n/*\n * Report additional information for an error in command-line arguments.\n * If we're a capture child, send a message back to the parent, otherwise\n * just print it.\n */\nstatic void\ndumpcap_cmdarg_err_cont(const char *fmt, va_list ap)\n{\n    if (capture_child) {\n        char *msg;\n        msg = ws_strdup_vprintf(fmt, ap);\n        sync_pipe_write_errmsgs_to_parent(sync_pipe_fd, msg, \"\");\n        g_free(msg);\n    } else {\n        vfprintf(stderr, fmt, ap);\n        fprintf(stderr, \"\\n\");\n    }\n}\n\n#ifdef HAVE_LIBCAP\nstatic void\n/* see 'man cap_to_text()' for explanation of output                         */\n/* '='   means 'all= '  ie: no capabilities                                  */\n/* '=ip' means 'all=ip' ie: all capabilities are permissible and inheritable */\n/* ....                                                                      */\nprint_caps(const char *pfx) {\n    if (ws_log_msg_is_active(WS_LOG_DOMAIN, LOG_LEVEL_NOISY)) {\n        cap_t caps = cap_get_proc();\n        char *caps_text = cap_to_text(caps, NULL);\n        ws_noisy(\"%s: EUID: %d  Capabilities: %s\", pfx, geteuid(), caps_text);\n        cap_free(caps_text);\n        cap_free(caps);\n    }\n}\n\nstatic void\nrelinquish_all_capabilities(void)\n{\n    /* Drop any and all capabilities this process may have.            */\n    /* Allowed whether or not process has any privileges.              */\n    cap_t caps = cap_init();    /* all capabilities initialized to off */\n    print_caps(\"Pre-clear\");\n    if (cap_set_proc(caps)) {\n        cmdarg_err(\"cap_set_proc() fail return: %s\", g_strerror(errno));\n    }\n    print_caps(\"Post-clear\");\n    cap_free(caps);\n}\n#endif\n\nstatic void\nget_capture_device_open_failure_messages(cap_device_open_status open_status,\n                                         const char *open_status_str,\n                                         const char *iface,\n                                         char *errmsg, size_t errmsg_len,\n                                         char *secondary_errmsg,\n                                         size_t secondary_errmsg_len)\n{\n    switch (open_status) {\n\n    case CAP_DEVICE_OPEN_ERROR_NO_SUCH_DEVICE:\n        snprintf(errmsg, errmsg_len,\n                 \"There is no device named \\\"%s\\\".\\n(%s)\",\n                 iface, open_status_str);\n        break;\n\n    case CAP_DEVICE_OPEN_ERROR_RFMON_NOTSUP:\n        snprintf(errmsg, errmsg_len,\n                 \"Capturing in monitor mode is not supported on device \\\"%s\\\".\\n(%s)\",\n                 iface, open_status_str);\n        break;\n\n    case CAP_DEVICE_OPEN_ERROR_PERM_DENIED:\n        snprintf(errmsg, errmsg_len,\n                 \"You do not have permission to capture on device \\\"%s\\\".\\n(%s)\",\n                 iface, open_status_str);\n        break;\n\n    case CAP_DEVICE_OPEN_ERROR_IFACE_NOT_UP:\n        snprintf(errmsg, errmsg_len,\n                 \"Device \\\"%s\\\" is not up.\\n(%s)\",\n                 iface, open_status_str);\n        break;\n\n    case CAP_DEVICE_OPEN_ERROR_PROMISC_PERM_DENIED:\n        snprintf(errmsg, errmsg_len,\n                 \"You do not have permission to capture in promiscuous mode on device \\\"%s\\\".\\n(%s)\",\n                 iface, open_status_str);\n        break;\n\n    case CAP_DEVICE_OPEN_ERROR_OTHER:\n    default:\n        snprintf(errmsg, errmsg_len,\n                 \"The capture session could not be initiated on capture device \\\"%s\\\".\\n(%s)\",\n                 iface, open_status_str);\n        break;\n    }\n    snprintf(secondary_errmsg, secondary_errmsg_len, \"%s\",\n               get_pcap_failure_secondary_error_message(open_status, open_status_str));\n}\n\nstatic bool\ncompile_capture_filter(const char *iface, pcap_t *pcap_h,\n                       struct bpf_program *fcode, const char *cfilter)\n{\n    bpf_u_int32 netnum, netmask;\n    char        lookup_net_err_str[PCAP_ERRBUF_SIZE];\n\n    if (pcap_lookupnet(iface, &netnum, &netmask, lookup_net_err_str) < 0) {\n        /*\n         * Well, we can't get the netmask for this interface; it's used\n         * only for filters that check for broadcast IP addresses, so\n         * we just punt and use 0.  It might be nice to warn the user,\n         * but that's a pain in a GUI application, as it'd involve popping\n         * up a message box, and it's not clear how often this would make\n         * a difference (only filters that check for IP broadcast addresses\n         * use the netmask).\n         */\n        /*cmdarg_err(\n          \"Warning:  Couldn't obtain netmask info (%s).\", lookup_net_err_str);*/\n        netmask = 0;\n    }\n\n    /*\n     * Sigh.  Older versions of libpcap don't properly declare the\n     * third argument to pcap_compile() as a const pointer.  Cast\n     * away the warning.\n     */\nDIAG_OFF(cast-qual)\n    if (pcap_compile(pcap_h, fcode, (char *)cfilter, 1, netmask) < 0)\n        return false;\nDIAG_ON(cast-qual)\n    return true;\n}\n\nstatic bool\nshow_filter_code(capture_options *capture_opts)\n{\n    interface_options *interface_opts;\n    pcap_t *pcap_h;\n    cap_device_open_status open_status;\n    char open_status_str[PCAP_ERRBUF_SIZE];\n    char errmsg[MSG_MAX_LENGTH+1];\n    char secondary_errmsg[MSG_MAX_LENGTH+1];\n    struct bpf_program fcode;\n    struct bpf_insn *insn;\n    u_int i;\n    unsigned j;\n\n    for (j = 0; j < capture_opts->ifaces->len; j++) {\n        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, j);\n        pcap_h = open_capture_device(capture_opts, interface_opts,\n            CAP_READ_TIMEOUT, &open_status, &open_status_str);\n        if (pcap_h == NULL) {\n            /* Open failed; get messages */\n            get_capture_device_open_failure_messages(open_status, open_status_str,\n                                                     interface_opts->name,\n                                                     errmsg, sizeof errmsg,\n                                                     secondary_errmsg,\n                                                     sizeof secondary_errmsg);\n            /* And report them */\n            report_capture_error(errmsg, secondary_errmsg);\n            return false;\n        }\n\n        /* Set the link-layer type. */\n        if (!set_pcap_datalink(pcap_h, interface_opts->linktype, interface_opts->name,\n                               errmsg, sizeof errmsg,\n                               secondary_errmsg, sizeof secondary_errmsg)) {\n            pcap_close(pcap_h);\n            report_capture_error(errmsg, secondary_errmsg);\n            return false;\n        }\n\n        /* OK, try to compile the capture filter. */\n        if (!compile_capture_filter(interface_opts->name, pcap_h, &fcode,\n                                    interface_opts->cfilter)) {\n            snprintf(errmsg, sizeof(errmsg), \"%s\", pcap_geterr(pcap_h));\n            pcap_close(pcap_h);\n            report_cfilter_error(capture_opts, j, errmsg);\n            return false;\n        }\n        pcap_close(pcap_h);\n\n        /* Now print the filter code. */\n        insn = fcode.bf_insns;\n\n        for (i = 0; i < fcode.bf_len; insn++, i++)\n            printf(\"%s\\n\", bpf_image(insn, i));\n    }\n    /* If not using libcap: we now can now set euid/egid to ruid/rgid         */\n    /*  to remove any suid privileges.                                        */\n    /* If using libcap: we can now remove NET_RAW and NET_ADMIN capabilities  */\n    /*  (euid/egid have already previously been set to ruid/rgid.             */\n    /* (See comment in main() for details)                                    */\n    /* XXX - On Linux, if we're capturing on a mac80211 device and enabling   */\n    /* rfmon via libpcap with libnl support, that creates a new monitor mode  */\n    /* device that libpcap will attempt to delete when capture is done. That  */\n    /* will fail with EPERM because we dropped privileges.                    */\n#ifndef HAVE_LIBCAP\n    relinquish_special_privs_perm();\n#else\n    relinquish_all_capabilities();\n#endif\n    if (capture_child) {\n        /* Let our parent know we succeeded. */\n        sync_pipe_write_string_msg(sync_pipe_fd, SP_SUCCESS, NULL);\n    }\n    return true;\n}\n\nstatic void\nprint_machine_readable_if_capabilities(json_dumper *dumper, if_capabilities_t *caps, int queries);\n\n/*\n * Output a machine readable list of the interfaces\n * This list is retrieved by the sync_interface_list_open() function\n * The actual output of this function can be viewed with the command \"dumpcap -D -Z none\"\n */\nstatic int\nprint_machine_readable_interfaces(GList *if_list, int caps_queries, bool print_statistics)\n{\n    GList       *if_entry;\n    if_info_t   *if_info;\n    GSList      *addr;\n    if_addr_t   *if_addr;\n    char        addr_str[WS_INET6_ADDRSTRLEN];\n    int         status;\n\n    json_dumper dumper = {\n        .output_string = g_string_new(NULL),\n        .flags = JSON_DUMPER_FLAGS_NO_DEBUG,\n        // Don't abort on failure\n    };\n    json_dumper_begin_array(&dumper);\n\n    /*\n     * Print the contents of the if_entry struct in a parseable format (JSON)\n     */\n    for (if_entry = g_list_first(if_list); if_entry != NULL;\n         if_entry = g_list_next(if_entry)) {\n        if_info = (if_info_t *)if_entry->data;\n\n        json_dumper_begin_object(&dumper);\n        json_dumper_set_member_name(&dumper, if_info->name);\n\n        json_dumper_begin_object(&dumper);\n\n        json_dumper_set_member_name(&dumper, \"friendly_name\");\n        json_dumper_value_string(&dumper, if_info->friendly_name);\n\n        json_dumper_set_member_name(&dumper, \"vendor_description\");\n        json_dumper_value_string(&dumper, if_info->vendor_description);\n\n        json_dumper_set_member_name(&dumper, \"type\");\n        json_dumper_value_anyf(&dumper, \"%i\", if_info->type);\n\n        json_dumper_set_member_name(&dumper, \"addrs\");\n\n        json_dumper_begin_array(&dumper);\n        for (addr = g_slist_nth(if_info->addrs, 0); addr != NULL;\n                    addr = g_slist_next(addr)) {\n\n            if_addr = (if_addr_t *)addr->data;\n            switch(if_addr->ifat_type) {\n            case IF_AT_IPv4:\n                json_dumper_value_string(&dumper, ws_inet_ntop4(&if_addr->addr.ip4_addr, addr_str, sizeof(addr_str)));\n                break;\n            case IF_AT_IPv6:\n                json_dumper_value_string(&dumper, ws_inet_ntop6(&if_addr->addr.ip6_addr, addr_str, sizeof(addr_str)));\n                break;\n            default:\n                json_dumper_value_anyf(&dumper, \"<type unknown %i>\", if_addr->ifat_type);\n            }\n        }\n        json_dumper_end_array(&dumper);\n\n        json_dumper_set_member_name(&dumper, \"loopback\");\n        json_dumper_value_anyf(&dumper, \"%s\", if_info->loopback ? \"true\" : \"false\");\n\n        json_dumper_set_member_name(&dumper, \"extcap\");\n        json_dumper_value_string(&dumper, if_info->extcap);\n\n        if (if_info->caps && caps_queries) {\n            json_dumper_set_member_name(&dumper, \"caps\");\n            json_dumper_begin_object(&dumper);\n            print_machine_readable_if_capabilities(&dumper, if_info->caps, caps_queries);\n            json_dumper_end_object(&dumper);\n        }\n        json_dumper_end_object(&dumper);\n        json_dumper_end_object(&dumper);\n    }\n    json_dumper_end_array(&dumper);\n    if (json_dumper_finish(&dumper)) {\n        status = 0;\n        if (capture_child) {\n            if (print_statistics) {\n                sync_pipe_write_string_msg(sync_pipe_fd, SP_IFACE_LIST, dumper.output_string->str);\n            } else {\n                /* Let our parent know we succeeded. */\n                sync_pipe_write_string_msg(sync_pipe_fd, SP_SUCCESS, NULL);\n                printf(\"%s\", dumper.output_string->str);\n            }\n        } else {\n            printf(\"%s\", dumper.output_string->str);\n        }\n    } else {\n        status = 2;\n        if (capture_child) {\n            sync_pipe_write_errmsgs_to_parent(sync_pipe_fd, \"Unexpected JSON error\", \"\");\n        } else {\n            cmdarg_err(\"Unexpected JSON error\");\n        }\n    }\n    g_string_free(dumper.output_string, TRUE);\n    return status;\n}\n\n/*\n * If you change the machine-readable output format of this function,\n * you MUST update capture_ifinfo.c:capture_get_if_capabilities() accordingly!\n */\nstatic void\nprint_machine_readable_if_capabilities(json_dumper *dumper, if_capabilities_t *caps, int queries)\n{\n    GList *lt_entry, *ts_entry;\n    const char *desc_str;\n\n    json_dumper_set_member_name(dumper, \"status\");\n    json_dumper_value_anyf(dumper, \"%i\", caps->status);\n    if (caps->primary_msg) {\n        json_dumper_set_member_name(dumper, \"primary_msg\");\n        json_dumper_value_string(dumper, caps->primary_msg);\n    }\n\n    if (queries & CAPS_QUERY_LINK_TYPES) {\n        json_dumper_set_member_name(dumper, \"rfmon\");\n        json_dumper_value_anyf(dumper, \"%s\", caps->can_set_rfmon ? \"true\" : \"false\");\n        json_dumper_set_member_name(dumper, \"data_link_types\");\n        json_dumper_begin_array(dumper);\n        for (lt_entry = caps->data_link_types; lt_entry != NULL;\n             lt_entry = g_list_next(lt_entry)) {\n          data_link_info_t *data_link_info = (data_link_info_t *)lt_entry->data;\n          if (data_link_info->description != NULL)\n            desc_str = data_link_info->description;\n          else\n            desc_str = \"(not supported)\";\n          json_dumper_begin_object(dumper);\n          json_dumper_set_member_name(dumper, \"dlt\");\n          json_dumper_value_anyf(dumper, \"%d\", data_link_info->dlt);\n          json_dumper_set_member_name(dumper, \"name\");\n          json_dumper_value_string(dumper, data_link_info->name);\n          json_dumper_set_member_name(dumper, \"description\");\n          json_dumper_value_string(dumper, desc_str);\n          json_dumper_end_object(dumper);\n        }\n        json_dumper_end_array(dumper);\n\n        json_dumper_set_member_name(dumper, \"data_link_types_rfmon\");\n        json_dumper_begin_array(dumper);\n        for (lt_entry = caps->data_link_types_rfmon; lt_entry != NULL;\n             lt_entry = g_list_next(lt_entry)) {\n          data_link_info_t *data_link_info = (data_link_info_t *)lt_entry->data;\n          if (data_link_info->description != NULL)\n            desc_str = data_link_info->description;\n          else\n            desc_str = \"(not supported)\";\n          json_dumper_begin_object(dumper);\n          json_dumper_set_member_name(dumper, \"dlt\");\n          json_dumper_value_anyf(dumper, \"%d\", data_link_info->dlt);\n          json_dumper_set_member_name(dumper, \"name\");\n          json_dumper_value_string(dumper, data_link_info->name);\n          json_dumper_set_member_name(dumper, \"description\");\n          json_dumper_value_string(dumper, desc_str);\n          json_dumper_end_object(dumper);\n        }\n        json_dumper_end_array(dumper);\n    }\n    if (queries & CAPS_QUERY_TIMESTAMP_TYPES) {\n        json_dumper_set_member_name(dumper, \"timestamp_types\");\n        json_dumper_begin_array(dumper);\n        for (ts_entry = caps->timestamp_types; ts_entry != NULL;\n             ts_entry = g_list_next(ts_entry)) {\n          timestamp_info_t *timestamp = (timestamp_info_t *)ts_entry->data;\n          if (timestamp->description != NULL)\n            desc_str = timestamp->description;\n          else\n            desc_str = \"(none)\";\n          json_dumper_begin_object(dumper);\n          json_dumper_set_member_name(dumper, \"name\");\n          json_dumper_value_string(dumper, timestamp->name);\n          json_dumper_set_member_name(dumper, \"description\");\n          json_dumper_value_string(dumper, desc_str);\n          json_dumper_end_object(dumper);\n        }\n        json_dumper_end_array(dumper);\n    }\n}\n\ntypedef struct {\n    char *name;\n    pcap_t *pch;\n} if_stat_t;\n\n/* Print the number of packets captured for each interface until we're killed. */\nstatic int\nprint_statistics_loop(bool machine_readable)\n{\n    GList       *if_list, *if_entry, *stat_list = NULL, *stat_entry;\n    if_info_t   *if_info;\n    if_stat_t   *if_stat;\n    int         err;\n    char        *err_str;\n    pcap_t      *pch;\n    char        errbuf[PCAP_ERRBUF_SIZE];\n    struct pcap_stat ps;\n\n    if_list = get_interface_list(&err, &err_str);\n    if (if_list == NULL) {\n        if (err == 0) {\n            cmdarg_err(\"There are no interfaces on which a capture can be done\");\n            err = WS_EXIT_NO_INTERFACES;\n        }\n        else {\n            cmdarg_err(\"%s\", err_str);\n            g_free(err_str);\n        }\n        return err;\n    }\n\n    for (if_entry = g_list_first(if_list); if_entry != NULL; if_entry = g_list_next(if_entry)) {\n        if_info = (if_info_t *)if_entry->data;\n\n#ifdef __linux__\n        /* On Linux nf* interfaces don't collect stats properly and don't allows multiple\n         * connections. We avoid collecting stats on them.\n         */\n        if (!strncmp(if_info->name, \"nf\", 2)) {\n            ws_debug(\"Skipping interface %s for stats\", if_info->name);\n            continue;\n        }\n#endif\n\n#ifdef HAVE_PCAP_OPEN\n\t/*\n\t * If we're opening a remote device, use pcap_open(); that's currently\n\t * the only open routine that supports remote devices.\n\t */\n        if (strncmp(if_info->name, \"rpcap://\", 8) == 0)\n            pch = pcap_open(if_info->name, MIN_PACKET_SIZE, 0, 0, NULL, errbuf);\n        else\n#endif\n        pch = pcap_open_live(if_info->name, MIN_PACKET_SIZE, 0, 0, errbuf);\n\n        if (pch) {\n            if_stat = g_new(if_stat_t, 1);\n            if_stat->name = g_strdup(if_info->name);\n            if_stat->pch = pch;\n            stat_list = g_list_append(stat_list, if_stat);\n        }\n    }\n\n    if (!stat_list) {\n        cmdarg_err(\"There are no interfaces on which a capture can be done\");\n        return 2;\n    }\n\n    if (capture_child) {\n        /* Let our parent know we succeeded. */\n        sync_pipe_write_string_msg(sync_pipe_fd, SP_SUCCESS, NULL);\n    }\n\n    if (!machine_readable) {\n        printf(\"%-15s  %10s  %10s\\n\", \"Interface\", \"Received\",\n            \"Dropped\");\n    }\n\n    global_ld.go = true;\n    while (global_ld.go) {\n        for (stat_entry = g_list_first(stat_list); stat_entry != NULL; stat_entry = g_list_next(stat_entry)) {\n            if_stat = (if_stat_t *)stat_entry->data;\n            /* XXX - what if this fails? */\n            if (pcap_stats(if_stat->pch, &ps) == 0) {\n                if (!machine_readable) {\n                    printf(\"%-15s  %10u  %10u\\n\", if_stat->name,\n                           ps.ps_recv, ps.ps_drop);\n                } else {\n                    printf(\"%s\\t%u\\t%u\\n\", if_stat->name,\n                           ps.ps_recv, ps.ps_drop);\n                    fflush(stdout);\n                }\n            }\n        }\n#ifdef _WIN32\n        /* If we have a dummy signal pipe check it */\n        if (!signal_pipe_check_running()) {\n            global_ld.go = false;\n        }\n        Sleep(1 * 1000);\n#else\n        sleep(1);\n#endif\n    }\n\n    /* XXX - Not reached.  Should we look for 'q' in stdin? */\n    for (stat_entry = g_list_first(stat_list); stat_entry != NULL; stat_entry = g_list_next(stat_entry)) {\n        if_stat = (if_stat_t *)stat_entry->data;\n        pcap_close(if_stat->pch);\n        g_free(if_stat->name);\n        g_free(if_stat);\n    }\n    g_list_free(stat_list);\n    free_interface_list(if_list);\n\n    return 0;\n}\n\n\n#ifdef _WIN32\nstatic BOOL WINAPI\ncapture_cleanup_handler(DWORD dwCtrlType)\n{\n    /* CTRL_C_EVENT is sort of like SIGINT, CTRL_BREAK_EVENT is unique to\n       Windows, CTRL_CLOSE_EVENT is sort of like SIGHUP, CTRL_LOGOFF_EVENT\n       is also sort of like SIGHUP, and CTRL_SHUTDOWN_EVENT is sort of\n       like SIGTERM at least when the machine's shutting down.\n\n       For now, if we're running as a command rather than a capture child,\n       we handle all but CTRL_LOGOFF_EVENT as indications that we should\n       clean up and quit, just as we handle SIGINT, SIGHUP, and SIGTERM\n       in that way on UN*X.\n\n       If we're not running as a capture child, we might be running as\n       a service; ignore CTRL_LOGOFF_EVENT, so we keep running after the\n       user logs out.  (XXX - can we explicitly check whether we're\n       running as a service?) */\n\n    ws_info(\"Console: Control signal\");\n    ws_debug(\"Console: Control signal, CtrlType: %lu\", dwCtrlType);\n\n    /* Keep capture running if we're a service and a user logs off */\n    if (capture_child || (dwCtrlType != CTRL_LOGOFF_EVENT)) {\n        capture_loop_stop();\n        return true;\n    } else {\n        return false;\n    }\n}\n#else\nstatic void\ncapture_cleanup_handler(int signum _U_)\n{\n    /* On UN*X, we cleanly shut down the capture on SIGINT, SIGHUP, and\n       SIGTERM.  We assume that if the user wanted it to keep running\n       after they logged out, they'd have nohupped it. */\n\n    capture_loop_stop();\n}\n#endif\n\n\nstatic void\nreport_capture_count(bool reportit)\n{\n    /* Don't print this if we're a capture child. */\n    if (!capture_child && reportit) {\n        fprintf(stderr, \"\\rPackets captured: %d\\n\", global_ld.packets_captured);\n        /* stderr could be line buffered */\n        fflush(stderr);\n    }\n}\n\n\n#ifdef SIGINFO\nstatic void\nreport_counts_for_siginfo(void)\n{\n    report_capture_count(quiet);\n    infoprint = false; /* we just reported it */\n}\n\nstatic void\nreport_counts_siginfo(int signum _U_)\n{\n    int sav_errno = errno;\n\n    /* If we've been told to delay printing, just set a flag asking\n       that we print counts (if we're supposed to), otherwise print\n       the count of packets captured (if we're supposed to). */\n    if (infodelay)\n        infoprint = true;\n    else\n        report_counts_for_siginfo();\n    errno = sav_errno;\n}\n#endif /* SIGINFO */\n\nstatic void\nexit_main(int status)\n{\n    ws_cleanup_sockets();\n\n#ifdef _WIN32\n    /* can be helpful for debugging */\n#ifdef DEBUG_DUMPCAP\n    printf(\"Press any key\\n\");\n    _getch();\n#endif\n\n#endif /* _WIN32 */\n\n    if (ringbuf_is_initialized()) {\n        /* save_file is managed by ringbuffer, be sure to release the memory and\n         * avoid capture_opts_cleanup from double-freeing 'save_file'. */\n        ringbuf_free();\n        global_capture_opts.save_file = NULL;\n    }\n\n    capture_opts_cleanup(&global_capture_opts);\n    exit(status);\n}\n\n#ifdef HAVE_LIBCAP\n/*\n * If we were linked with libcap (not related to libpcap), make sure we have\n * CAP_NET_ADMIN and CAP_NET_RAW, then relinquish our permissions.\n * (See comment in main() for details)\n */\nstatic void\nrelinquish_privs_except_capture(void)\n{\n    /*\n     * Drop any capabilities other than NET_ADMIN and NET_RAW:\n     *\n     * CAP_NET_ADMIN: Promiscuous mode and a truckload of other\n     *                stuff we don't need (and shouldn't have).\n     * CAP_NET_RAW:   Packet capture (raw sockets).\n     *\n     * If 'started_with_special_privs' (ie: suid) then drop our\n     * suid privileges.\n     */\n\n    cap_t current_caps = cap_get_proc();\n    print_caps(\"Pre set\");\n\n    cap_t caps = cap_init();    /* all capabilities initialized to off */\n\n    /*\n     * We can only set capabilities that are in the permitted set.\n     * If the real or effective user ID is 0 (root), then the file\n     * inherited and permitted sets are ignored, and our permitted\n     * set should be all ones - unless the effective ID is 0, the\n     * real ID is not zero, and the binary has file capabilities,\n     * in which case the permitted set is only that of the file.\n     * (E.g., set-user-ID-root + file capabilities.)\n     *\n     * If one or more of the euid, ruid, and saved set user ID are\n     * all zero and all change to nonzero, then all capabilities are\n     * cleared from the permitted, effective, and ambient sets.\n     * PR_SET_KEEPCAPS causes the permitted set to be retained, so\n     * we can relinquish our changed user ID.\n     *\n     * All capabilities are always cleared from the effective set\n     * when the euid is changed from 0 to nonzero.\n     *\n     * See capabilities(7).\n     */\n    if (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) == -1) {\n        cmdarg_err(\"prctl() fail return: %s\", g_strerror(errno));\n    }\n\n    if (started_with_special_privs()) {\n        relinquish_special_privs_perm();\n    }\n\n    /*\n     * If cap_set_proc() fails, it leaves the capabilities unchanged.\n     * So the only way to guarantee that we've dropped all other\n     * capabilities is to ensure that cap_set_proc() succeeds.\n     * One option might be to exit if cap_set_proc() fails - but some\n     * captures will work with CAP_NET_RAW but not CAP_NET_ADMIN.\n     */\n\n    cap_value_t cap_list[1] = { CAP_NET_ADMIN };\n    int cl_len = array_length(cap_list);\n    cap_flag_value_t value;\n\n    cap_get_flag(current_caps, cap_list[0], CAP_PERMITTED, &value);\n\n    if (value != CAP_SET) {\n        // XXX - Should we warn here? Some captures will still work.\n    }\n    cap_set_flag(caps, CAP_PERMITTED, cl_len, cap_list, value);\n    // XXX - Do we really need CAP_INHERITABLE?\n    cap_set_flag(caps, CAP_INHERITABLE, cl_len, cap_list, value);\n    cap_set_flag(caps, CAP_EFFECTIVE, cl_len, cap_list, value);\n\n    cap_list[0] = CAP_NET_RAW;\n    cap_get_flag(current_caps, cap_list[0], CAP_PERMITTED, &value);\n\n    if (value != CAP_SET) {\n        // XXX - Should we warn here?\n    }\n    cap_set_flag(caps, CAP_PERMITTED, cl_len, cap_list, value);\n    // XXX - Do we really need CAP_INHERITABLE?\n    cap_set_flag(caps, CAP_INHERITABLE, cl_len, cap_list, value);\n    cap_set_flag(caps, CAP_EFFECTIVE, cl_len, cap_list, value);\n\n    if (cap_set_proc(caps)) {\n        /*\n         * This shouldn't happen, we're only trying to set capabilities\n         * already in the permitted set.\n         */\n        cmdarg_err(\"cap_set_proc() fail return: %s\", g_strerror(errno));\n    }\n\n    print_caps(\"Post set\");\n\n    cap_free(current_caps);\n    cap_free(caps);\n}\n\n#endif /* HAVE_LIBCAP */\n\n/* Map DLT_ values, as returned by pcap_datalink(), to LINKTYPE_ values,\n   as are written to capture files.\n\n   Most of the time, a DLT_ value and the corresponding LINKYPE_ value\n   are the same, but there are some cases, where a numeric value as\n   a DLT_ doesn't uniquely identify a particular link-layer header type,\n   where they differ, so that the values in files *do* identify\n   particular link-layer header types. */\n\n/* LINKTYPE_ values that don't match corresponding DLT_ values on\n    all platforms. */\n#define LINKTYPE_ATM_RFC1483\t100\n#define LINKTYPE_RAW\t\t101\n#define LINKTYPE_SLIP_BSDOS\t102\n#define LINKTYPE_PPP_BSDOS\t103\n#define LINKTYPE_C_HDLC\t\t104\n#define LINKTYPE_IEEE802_11\t105\n#define LINKTYPE_ATM_CLIP\t106\n#define LINKTYPE_FRELAY\t\t107\n#define LINKTYPE_LOOP\t\t108\n#define LINKTYPE_ENC\t\t109\n#define LINKTYPE_NETBSD_HDLC\t112\n#define LINKTYPE_PFSYNC\t\t246\n#define LINKTYPE_PKTAP\t\t258\n\nstatic int\ndlt_to_linktype(int dlt)\n{\n\t/* DLT_NULL through DLT_FDDI have the same numeric value on\n\t   all platforms, so the corresponding LINKTYPE_s have the\n\t   same numeric values. */\n\tif (dlt >= DLT_NULL && dlt <= DLT_FDDI)\n\t\treturn (dlt);\n\n#if defined(DLT_PFSYNC) && DLT_PFSYNC != LINKTYPE_PFSYNC\n\t/* DLT_PFSYNC has a value on several platforms that's in the\n\t   non-matching range, a value on FreeBSD that's in the high\n\t   matching range and that's *not* equal to LINKTYPE_PFSYNC,\n\t   and has a value on the rmaining platforms that's equal\n\t   to LINKTYPE_PFSYNC, which is in the high matching range.\n\n\t   Map it to LINKTYPE_PFSYNC if it's not equal to LINKTYPE_PFSYNC. */\n\tif (dlt == DLT_PFSYNC)\n\t\treturn (LINKTYPE_PFSYNC);\n#endif\n\n\t/* DLT_PKTAP is defined as DLT_USER2 - which is in the high\n\t   matching range - on Darwin because Apple used DLT_USER2\n\t   on systems that users ran, not just as an internal thing.\n\n\t   We map it to LINKTYPE_PKTAP if it's not equal to LINKTYPE_PKTAP\n\t   so that DLT_PKTAP captures from Apple machines can be read by\n\t   software that either doesn't handle DLT_USER2 or that handles it\n\t   as something other than Apple PKTAP. */\n#if defined(DLT_PKTAP) && DLT_PKTAP != LINKTYPE_PKTAP\n\tif (dlt == DLT_PKTAP)\n\t\treturn (LINKTYPE_PKTAP);\n#endif\n\n\t/* For all other DLT_s with values beyond 104, the value\n\t   of the corresponding LINKTYPE_ is the same. */\n\tif (dlt >= 104)\n\t\treturn (dlt);\n\n\t/* These DLT_ values have different values on different\n\t   platforms, so we assigned them LINKTYPE_ values just\n\t   below the lower bound of the high matchig range;\n\t   those values should never be equal to any DLT_\n\t   values, so that should avoid collisions.\n\n\t   That way, for example, \"raw IP\" packets will have\n\t   LINKTYPE_RAW as the code in all savefiles for\n\t   which the code that writes them maps to that\n\t   value, regardless of the platform on which they\n\t   were written, so they should be readable on all\n\t   platforms without having to determine on which\n\t   platform they were written.\n\n\t   We map the DLT_ values on this platform, whatever\n\t   it might be, to the corresponding LINKTYPE_ values. */\n#ifdef DLT_ATM_RFC1483\n\tif (dlt == DLT_ATM_RFC1483)\n\t\treturn (LINKTYPE_ATM_RFC1483);\n#endif\n#ifdef DLT_RAW\n\tif (dlt == DLT_RAW)\n\t\treturn (LINKTYPE_RAW);\n#endif\n#ifdef DLT_SLIP_BSDOS\n\tif (dlt == DLT_SLIP_BSDOS)\n\t\treturn (LINKTYPE_SLIP_BSDOS);\n#endif\n#ifdef DLT_PPP_BSDOS\n\tif (dlt == DLT_PPP_BSDOS)\n\t\treturn (LINKTYPE_PPP_BSDOS);\n#endif\n\n\t/* These DLT_ values were originally defined on some platform,\n\t   and weren't defined on other platforms.\n\n\t   At least some of those values, on at least one platform,\n\t   collide with the values of other DLT_s on other platforms,\n\t   e.g. DLT_LOOP, so we don't just define them, on all\n\t   platforms, as having the same value as on the original\n\t   platform.\n\n\t   Therefore, we assigned new LINKTYPE_ values to them, and,\n\t   on the platforms where they weren't originally defined,\n\t   define the DLT_s to have the same value as the corresponding\n\t   LINKTYPE_.\n\n\t   This means that, for capture files with the original\n\t   platform's DLT_ value rather than the LINKTYPE_ value\n\t   as a link-layer type, we will recognize those types\n\t   on that platform, but not on other platforms. */\n#ifdef DLT_FR\n\t/* BSD/OS Frame Relay */\n\tif (dlt == DLT_FR)\n\t\treturn (LINKTYPE_FRELAY);\n#endif\n#if defined(DLT_HDLC) && DLT_HDLC != LINKTYPE_NETBSD_HDLC\n\t/* NetBSD HDLC */\n\tif (dlt == DLT_HDLC)\n\t\treturn (LINKTYPE_NETBSD_HDLC);\n#endif\n#if defined(DLT_C_HDLC) && DLT_C_HDLC != LINKTYPE_C_HDLC\n\t/* BSD/OS Cisco HDLC */\n\tif (dlt == DLT_C_HDLC)\n\t\treturn (LINKTYPE_C_HDLC);\n#endif\n#if defined(DLT_LOOP) && DLT_LOOP != LINKTYPE_LOOP\n\t/* OpenBSD DLT_LOOP */\n\tif (dlt == DLT_LOOP)\n\t\treturn (LINKTYPE_LOOP);\n#endif\n#if defined(DLT_ENC) && DLT_ENC != LINKTYPE_ENC\n\t/* OpenBSD DLT_ENC */\n\tif (dlt == DLT_ENC)\n\t\treturn (LINKTYPE_ENC);\n#endif\n\n\t/* These DLT_ values are not on all platforms, but, so far,\n\t   there don't appear to be any platforms that define\n\t   other DLT_s with those values; we map them to\n\t   different LINKTYPE_ values anyway, just in case. */\n#ifdef DLT_ATM_CLIP\n\t/* Linux ATM Classical IP */\n\tif (dlt == DLT_ATM_CLIP)\n\t\treturn (LINKTYPE_ATM_CLIP);\n#endif\n\n\t/* Treat all other DLT_s as having the same value as the\n\t   corresponding LINKTYPE_. */\n\treturn (dlt);\n}\n\n/* Take care of byte order in the libpcap headers read from pipes.\n * (function taken from wiretap/libpcap.c) */\nstatic void\ncap_pipe_adjust_pcap_header(bool byte_swapped, struct pcap_hdr *hdr, struct pcaprec_hdr *rechdr)\n{\n    if (byte_swapped) {\n        /* Byte-swap the record header fields. */\n        rechdr->ts_sec = GUINT32_SWAP_LE_BE(rechdr->ts_sec);\n        rechdr->ts_usec = GUINT32_SWAP_LE_BE(rechdr->ts_usec);\n        rechdr->incl_len = GUINT32_SWAP_LE_BE(rechdr->incl_len);\n        rechdr->orig_len = GUINT32_SWAP_LE_BE(rechdr->orig_len);\n    }\n\n    /* In file format version 2.3, the \"incl_len\" and \"orig_len\" fields were\n       swapped, in order to match the BPF header layout.\n\n       Unfortunately, some files were, according to a comment in the \"libpcap\"\n       source, written with version 2.3 in their headers but without the\n       interchanged fields, so if \"incl_len\" is greater than \"orig_len\" - which\n       would make no sense - we assume that we need to swap them.  */\n    if (hdr->version_major == 2 &&\n        (hdr->version_minor < 3 ||\n         (hdr->version_minor == 3 && rechdr->incl_len > rechdr->orig_len))) {\n        uint32_t temp;\n\n        temp = rechdr->orig_len;\n        rechdr->orig_len = rechdr->incl_len;\n        rechdr->incl_len = temp;\n    }\n}\n\n/* Wrapper: distinguish between recv/read if we're reading on Windows,\n * or just read().\n */\nstatic ssize_t\ncap_pipe_read(int pipe_fd, char *buf, size_t sz, bool from_socket _U_)\n{\n#ifdef _WIN32\n    if (from_socket) {\n        return recv(pipe_fd, buf, (int)sz, 0);\n    } else {\n        return -1;\n    }\n#else\n    return ws_read(pipe_fd, buf, sz);\n#endif\n}\n\n#if defined(_WIN32)\n/*\n * Thread function that reads from a pipe and pushes the data\n * to the main application thread.\n */\n/*\n * XXX Right now we use async queues for basic signaling. The main thread\n * sets cap_pipe_buf and cap_bytes_to_read, then pushes an item onto\n * cap_pipe_pending_q which triggers a read in the cap_pipe_read thread.\n * Iff the read is successful cap_pipe_read pushes an item onto\n * cap_pipe_done_q, otherwise an error is signaled. No data is passed in\n * the queues themselves (yet).\n *\n * We might want to move some of the cap_pipe_dispatch logic here so that\n * we can let cap_thread_read run independently, queuing up multiple reads\n * for the main thread (and possibly get rid of cap_pipe_read_mtx).\n */\nstatic void *cap_thread_read(void *arg)\n{\n    capture_src *pcap_src;\n#ifdef _WIN32\n    BOOL res;\n    DWORD last_err, bytes_read;\n#else /* _WIN32 */\n    size_t bytes_read;\n#endif /* _WIN32 */\n\n    pcap_src = (capture_src *)arg;\n    while (pcap_src->cap_pipe_err == PIPOK) {\n        g_async_queue_pop(pcap_src->cap_pipe_pending_q); /* Wait for our cue (ahem) from the main thread */\n        g_mutex_lock(pcap_src->cap_pipe_read_mtx);\n        bytes_read = 0;\n        while (bytes_read < pcap_src->cap_pipe_bytes_to_read) {\n           if ((pcap_src->from_cap_socket)\n#ifndef _WIN32\n              || 1\n#endif\n              )\n           {\n               ssize_t b;\n               b = cap_pipe_read(pcap_src->cap_pipe_fd, pcap_src->cap_pipe_buf+bytes_read,\n                        pcap_src->cap_pipe_bytes_to_read - bytes_read, pcap_src->from_cap_socket);\n               if (b <= 0) {\n                   if (b == 0) {\n                       pcap_src->cap_pipe_err = PIPEOF;\n                       bytes_read = 0;\n                       break;\n                   } else {\n                       pcap_src->cap_pipe_err = PIPERR;\n                       bytes_read = -1;\n                       break;\n                   }\n               } else {\n                   bytes_read += (DWORD)b;\n               }\n           }\n#ifdef _WIN32\n           else\n           {\n               /* If we try to use read() on a named pipe on Windows with partial\n                * data it appears to return EOF.\n                */\n               DWORD b;\n               res = ReadFile(pcap_src->cap_pipe_h, pcap_src->cap_pipe_buf+bytes_read,\n                              pcap_src->cap_pipe_bytes_to_read - bytes_read,\n                              &b, NULL);\n\n               bytes_read += b;\n               if (!res) {\n                   last_err = GetLastError();\n                   if (last_err == ERROR_MORE_DATA) {\n                       continue;\n                   } else if (last_err == ERROR_HANDLE_EOF || last_err == ERROR_BROKEN_PIPE || last_err == ERROR_PIPE_NOT_CONNECTED) {\n                       pcap_src->cap_pipe_err = PIPEOF;\n                       bytes_read = 0;\n                       break;\n                   }\n                   pcap_src->cap_pipe_err = PIPERR;\n                   bytes_read = -1;\n                   break;\n               } else if (b == 0 && pcap_src->cap_pipe_bytes_to_read > 0) {\n                   pcap_src->cap_pipe_err = PIPEOF;\n                   bytes_read = 0;\n                   break;\n               }\n           }\n#endif /*_WIN32 */\n        }\n        pcap_src->cap_pipe_bytes_read = bytes_read;\n        if (pcap_src->cap_pipe_bytes_read >= pcap_src->cap_pipe_bytes_to_read) {\n            g_async_queue_push(pcap_src->cap_pipe_done_q, pcap_src->cap_pipe_buf); /* Any non-NULL value will do */\n        }\n        g_mutex_unlock(pcap_src->cap_pipe_read_mtx);\n    }\n    /* Post to queue if we didn't read enough data as the main thread waits for the message */\n    g_mutex_lock(pcap_src->cap_pipe_read_mtx);\n    if (pcap_src->cap_pipe_bytes_read < pcap_src->cap_pipe_bytes_to_read) {\n        /* There's still more of the record to read. */\n        g_async_queue_push(pcap_src->cap_pipe_done_q, pcap_src->cap_pipe_buf); /* Any non-NULL value will do */\n    }\n    g_mutex_unlock(pcap_src->cap_pipe_read_mtx);\n    return NULL;\n}\n\n/*\n * Do a blocking read from a pipe within the main thread, by pushing\n * the read onto the pipe queue and then popping it off that queue;\n * the pipe will block until the pushed read completes.\n *\n * We do it with another thread because we can't use select() on\n * pipes on Windows, as we can on UN*Xes, we can only use it on\n * sockets.\n */\nvoid\npipe_read_sync(capture_src *pcap_src, void *buf, DWORD nbytes)\n{\n    pcap_src->cap_pipe_buf = (char *) buf;\n    pcap_src->cap_pipe_bytes_read = 0;\n    pcap_src->cap_pipe_bytes_to_read = nbytes;\n    /* We don't have to worry about cap_pipe_read_mtx here */\n    g_async_queue_push(pcap_src->cap_pipe_pending_q, pcap_src->cap_pipe_buf);\n    g_async_queue_pop(pcap_src->cap_pipe_done_q);\n}\n#endif\n\n/* Provide select() functionality for a single file descriptor\n * on UNIX/POSIX. Windows uses cap_pipe_read via a thread.\n *\n * Returns the same values as select.\n */\nstatic int\ncap_pipe_select(int pipe_fd)\n{\n    fd_set      rfds;\n    struct timeval timeout;\n\n    FD_ZERO(&rfds);\n    FD_SET(pipe_fd, &rfds);\n\n    timeout.tv_sec = PIPE_READ_TIMEOUT / 1000000;\n    timeout.tv_usec = PIPE_READ_TIMEOUT % 1000000;\n\n    return select(pipe_fd+1, &rfds, NULL, NULL, &timeout);\n}\n\n#define DEF_TCP_PORT 19000\n\nstatic int\ncap_open_socket(char *pipename, capture_src *pcap_src, char *errmsg, size_t errmsgl)\n{\n    struct sockaddr_storage sa;\n    socklen_t sa_len;\n    int fd;\n\n    /* Skip the initial \"TCP@\" in the pipename. */\n    if (ws_socket_ptoa(&sa, pipename + 4, DEF_TCP_PORT) < 0) {\n        snprintf(errmsg, errmsgl,\n                \"The capture session could not be initiated because\"\n                \"\\\"%s\\\" is not a valid socket specification\", pipename);\n        pcap_src->cap_pipe_err = PIPERR;\n        return -1;\n    }\n\n    if ((fd = (int)socket(sa.ss_family, SOCK_STREAM, 0)) < 0) {\n        snprintf(errmsg, errmsgl,\n            \"The capture session could not be initiated because\"\n            \" the socket couldn't be created due to the socket error: \\n\"\n#ifdef _WIN32\n            \"         %s\", win32strerror(WSAGetLastError()));\n#else\n            \"         %d: %s\", errno, g_strerror(errno));\n#endif\n        pcap_src->cap_pipe_err = PIPERR;\n        return -1;\n    }\n\n    if (sa.ss_family == AF_INET6)\n        sa_len = sizeof(struct sockaddr_in6);\n    else\n        sa_len = sizeof(struct sockaddr_in);\n    if (connect(fd, (struct sockaddr *)&sa, sa_len) < 0) {\n        snprintf(errmsg, errmsgl,\n            \"The capture session could not be initiated because\"\n            \" the socket couldn't be connected due to the socket error: \\n\"\n#ifdef _WIN32\n            \"         %s\", win32strerror(WSAGetLastError()));\n#else\n            \"         %d: %s\", errno, g_strerror(errno));\n#endif\n        pcap_src->cap_pipe_err = PIPERR;\n\n        cap_pipe_close(fd, true);\n        return -1;\n    }\n\n    pcap_src->from_cap_socket = true;\n    return fd;\n}\n\n/* Wrapper: distinguish between closesocket on Windows; use ws_close\n * otherwise.\n */\nstatic void\ncap_pipe_close(int pipe_fd, bool from_socket)\n{\n#ifdef _WIN32\n    if (from_socket) {\n        closesocket(pipe_fd);\n    }\n#else\n    (void) from_socket; /* Mark unused, similar to Q_UNUSED */\n    ws_close(pipe_fd);\n#endif\n}\n\n/** Read bytes from a capture source, which is assumed to be a pipe or\n * socket.\n *\n * Returns -1, or the number of bytes read similar to read(2).\n * Sets pcap_src->cap_pipe_err on error or EOF.\n */\nstatic ssize_t\ncap_pipe_read_data_bytes(capture_src *pcap_src, char *errmsg, size_t errmsgl)\n{\n    int sel_ret;\n    int fd = pcap_src->cap_pipe_fd;\n#ifdef _WIN32\n    DWORD sz, bytes_read = 0;\n#else /* _WIN32 */\n    ssize_t sz, bytes_read = 0;\n#endif /* _WIN32 */\n    ssize_t b;\n\n#ifdef LOG_CAPTURE_VERBOSE\n    ws_debug(\"cap_pipe_read_data_bytes read %lu of %lu\",\n          pcap_src->cap_pipe_bytes_read, pcap_src->cap_pipe_bytes_to_read);\n#endif\n    sz = pcap_src->cap_pipe_bytes_to_read - pcap_src->cap_pipe_bytes_read;\n    while (bytes_read < sz) {\n        if (fd == -1) {\n            snprintf(errmsg, errmsgl, \"Invalid file descriptor.\");\n            pcap_src->cap_pipe_err = PIPNEXIST;\n            return -1;\n        }\n\n        sel_ret = cap_pipe_select(fd);\n        if (sel_ret < 0) {\n            snprintf(errmsg, errmsgl,\n                       \"Unexpected error from select: %s.\", g_strerror(errno));\n            pcap_src->cap_pipe_err = PIPERR;\n            return -1;\n        } else if (sel_ret > 0) {\n            b = cap_pipe_read(fd, pcap_src->cap_pipe_databuf+pcap_src->cap_pipe_bytes_read+bytes_read,\n                              sz-bytes_read, pcap_src->from_cap_socket);\n            if (b <= 0) {\n                if (b == 0) {\n                    snprintf(errmsg, errmsgl,\n                               \"End of file reading from pipe or socket.\");\n                    pcap_src->cap_pipe_err = PIPEOF;\n                } else {\n#ifdef _WIN32\n                    /*\n                     * On Windows, we only do this for sockets.\n                     */\n                    DWORD lastError = WSAGetLastError();\n                    errno = lastError;\n                    snprintf(errmsg, errmsgl,\n                               \"Error reading from pipe or socket: %s.\",\n                               win32strerror(lastError));\n#else\n                    snprintf(errmsg, errmsgl,\n                               \"Error reading from pipe or socket: %s.\",\n                               g_strerror(errno));\n#endif\n                    pcap_src->cap_pipe_err = PIPERR;\n                }\n                return -1;\n            }\n#ifdef _WIN32\n            bytes_read += (DWORD)b;\n#else\n            bytes_read += b;\n#endif\n        }\n    }\n    pcap_src->cap_pipe_bytes_read += bytes_read;\n#ifdef LOG_CAPTURE_VERBOSE\n    ws_debug(\"cap_pipe_read_data_bytes read %lu of %lu\",\n          pcap_src->cap_pipe_bytes_read, pcap_src->cap_pipe_bytes_to_read);\n#endif\n    return bytes_read;\n}\n\n/* Some forward declarations for breaking up cap_pipe_open_live for pcap and pcapng formats */\nstatic void pcap_pipe_open_live(int fd, capture_src *pcap_src,\n                                struct pcap_hdr *hdr,\n                                char *errmsg, size_t errmsgl,\n                                char *secondary_errmsg, size_t secondary_errmsgl);\nstatic void pcapng_pipe_open_live(int fd, capture_src *pcap_src,\n                                  char *errmsg, size_t errmsgl);\nstatic int pcapng_pipe_dispatch(loop_data *ld, capture_src *pcap_src,\n                                char *errmsg, size_t errmsgl);\n\n/* For problems that are probably Not Our Fault. */\nstatic char not_our_bug[] =\n    \"Please report this to the developers of the program writing to the pipe.\";\n\n/* Mimic pcap_open_live() for pipe captures\n\n * We check if \"pipename\" is \"-\" (stdin), a AF_UNIX socket, or a FIFO,\n * open it, and read the header.\n *\n * N.B. : we can't read the libpcap formats used in RedHat 6.1 or SuSE 6.3\n * because we can't seek on pipes (see wiretap/libpcap.c for details) */\nstatic void\ncap_pipe_open_live(char *pipename,\n                   capture_src *pcap_src,\n                   void *hdr,\n                   char *errmsg, size_t errmsgl,\n                   char *secondary_errmsg, size_t secondary_errmsgl)\n{\n#ifndef _WIN32\n    ws_statb64         pipe_stat;\n    struct sockaddr_un sa;\n#else /* _WIN32 */\n    uintptr_t extcap_pipe_handle;\n#endif\n    bool extcap_pipe = false;\n    ssize_t  b;\n    int      fd = -1, sel_ret;\n    size_t   bytes_read;\n    uint32_t magic = 0;\n    pcap_src->cap_pipe_fd = -1;\n#ifdef _WIN32\n    pcap_src->cap_pipe_h = INVALID_HANDLE_VALUE;\n#endif\n\n    ws_debug(\"cap_pipe_open_live: %s\", pipename);\n\n    /*\n     * XXX - this blocks until a pcap per-file header has been written to\n     * the pipe, so it could block indefinitely.\n     */\n    if (strcmp(pipename, \"-\") == 0) {\n#ifndef _WIN32\n        fd = 0; /* read from stdin */\n#else /* _WIN32 */\n        pcap_src->cap_pipe_h = GetStdHandle(STD_INPUT_HANDLE);\n#endif  /* _WIN32 */\n    } else if (!strncmp(pipename, \"TCP@\", 4)) {\n       if ((fd = cap_open_socket(pipename, pcap_src, errmsg, errmsgl)) < 0) {\n          return;\n       }\n    } else {\n#ifndef _WIN32\n        if ( g_strrstr(pipename, EXTCAP_PIPE_PREFIX) != NULL )\n            extcap_pipe = true;\n\n        if (ws_stat64(pipename, &pipe_stat) < 0) {\n            if (errno == ENOENT || errno == ENOTDIR)\n                pcap_src->cap_pipe_err = PIPNEXIST;\n            else {\n                snprintf(errmsg, errmsgl,\n                           \"The capture session could not be initiated \"\n                           \"due to error getting information on pipe or socket: %s.\", g_strerror(errno));\n                pcap_src->cap_pipe_err = PIPERR;\n            }\n            return;\n        }\n        if (S_ISFIFO(pipe_stat.st_mode)) {\n            fd = ws_open(pipename, O_RDONLY | O_NONBLOCK, 0000 /* no creation so don't matter */);\n            if (fd == -1) {\n                snprintf(errmsg, errmsgl,\n                           \"The capture session could not be initiated \"\n                           \"due to error on pipe open: %s.\", g_strerror(errno));\n                pcap_src->cap_pipe_err = PIPERR;\n                return;\n            }\n        } else if (S_ISSOCK(pipe_stat.st_mode)) {\n            fd = socket(AF_UNIX, SOCK_STREAM, 0);\n            if (fd == -1) {\n                snprintf(errmsg, errmsgl,\n                           \"The capture session could not be initiated \"\n                           \"due to error on socket create: %s.\", g_strerror(errno));\n                pcap_src->cap_pipe_err = PIPERR;\n                return;\n            }\n            sa.sun_family = AF_UNIX;\n            /*\n             * The Single UNIX Specification says:\n             *\n             *   The size of sun_path has intentionally been left undefined.\n             *   This is because different implementations use different sizes.\n             *   For example, 4.3 BSD uses a size of 108, and 4.4 BSD uses a size\n             *   of 104. Since most implementations originate from BSD versions,\n             *   the size is typically in the range 92 to 108.\n             *\n             *   Applications should not assume a particular length for sun_path\n             *   or assume that it can hold {_POSIX_PATH_MAX} bytes (256).\n             *\n             * It also says\n             *\n             *   The <sys/un.h> header shall define the sockaddr_un structure,\n             *   which shall include at least the following members:\n             *\n             *   sa_family_t  sun_family  Address family.\n             *   char         sun_path[]  Socket pathname.\n             *\n             * so we assume that it's an array, with a specified size,\n             * and that the size reflects the maximum path length.\n             */\n            if (g_strlcpy(sa.sun_path, pipename, sizeof sa.sun_path) > sizeof sa.sun_path) {\n                /* Path name too long */\n                snprintf(errmsg, errmsgl,\n                           \"The capture session could not be initiated \"\n                           \"due to error on socket connect: Path name too long.\");\n                pcap_src->cap_pipe_err = PIPERR;\n                ws_close(fd);\n                return;\n            }\n            b = connect(fd, (struct sockaddr *)&sa, sizeof sa);\n            if (b == -1) {\n                snprintf(errmsg, errmsgl,\n                           \"The capture session could not be initiated \"\n                           \"due to error on socket connect: %s.\", g_strerror(errno));\n                pcap_src->cap_pipe_err = PIPERR;\n                ws_close(fd);\n                return;\n            }\n        } else {\n            if (S_ISCHR(pipe_stat.st_mode)) {\n                /*\n                 * Assume the user specified an interface on a system where\n                 * interfaces are in /dev.  Pretend we haven't seen it.\n                 */\n                pcap_src->cap_pipe_err = PIPNEXIST;\n            } else {\n                snprintf(errmsg, errmsgl,\n                           \"The capture session could not be initiated because\\n\"\n                           \"\\\"%s\\\" is neither an interface nor a socket nor a pipe.\", pipename);\n                pcap_src->cap_pipe_err = PIPERR;\n            }\n            return;\n        }\n\n#else /* _WIN32 */\n        if (sscanf(pipename, EXTCAP_PIPE_PREFIX \"%\" SCNuPTR, &extcap_pipe_handle) == 1)\n        {\n            /* The client is already connected to extcap pipe.\n             * We have inherited the handle from parent process.\n             */\n            extcap_pipe = true;\n            pcap_src->cap_pipe_h = (HANDLE)extcap_pipe_handle;\n        }\n        else\n        {\n            if (!win32_is_pipe_name(pipename)) {\n                snprintf(errmsg, errmsgl,\n                    \"The capture session could not be initiated because\\n\"\n                    \"\\\"%s\\\" is neither an interface nor a pipe.\", pipename);\n                pcap_src->cap_pipe_err = PIPNEXIST;\n                return;\n            }\n\n            /* Wait for the pipe to appear */\n            while (1) {\n                pcap_src->cap_pipe_h = CreateFile(utf_8to16(pipename), GENERIC_READ, 0, NULL,\n                        OPEN_EXISTING, 0, NULL);\n\n                if (pcap_src->cap_pipe_h != INVALID_HANDLE_VALUE)\n                    break;\n\n                if (GetLastError() != ERROR_PIPE_BUSY) {\n                    snprintf(errmsg, errmsgl,\n                        \"The capture session on \\\"%s\\\" could not be started \"\n                        \"due to error on pipe open: %s.\",\n                        pipename, win32strerror(GetLastError()));\n                    pcap_src->cap_pipe_err = PIPERR;\n                    return;\n                }\n\n                if (!WaitNamedPipe(utf_8to16(pipename), 30 * 1000)) {\n                    snprintf(errmsg, errmsgl,\n                        \"The capture session on \\\"%s\\\" timed out during \"\n                        \"pipe open: %s.\",\n                        pipename, win32strerror(GetLastError()));\n                    pcap_src->cap_pipe_err = PIPERR;\n                    return;\n                }\n            }\n        }\n#endif /* _WIN32 */\n    }\n\n    pcap_src->from_cap_pipe = true;\n\n    /*\n     * We start with a 2KB buffer for packet data, which should be\n     * large enough for most regular network packets.  We increase it,\n     * up to the maximum size we allow, as necessary.\n     */\n    pcap_src->cap_pipe_databuf = (char*)g_malloc(2048);\n    pcap_src->cap_pipe_databuf_size = 2048;\n\n    /*\n     * Read the first 4 bytes of data from the pipe.\n     *\n     * If a pcap file is being written to it, that will be\n     * the pcap magic number.\n     *\n     * If a pcapng file is being written to it, that will be\n     * the block type of the initial SHB.\n     */\n#ifdef _WIN32\n    /*\n     * On UN*X, we can use select() on pipes or sockets.\n     *\n     * On Windows, we can only use it on sockets; to do non-blocking\n     * reads from pipes, we currently do reads in a separate thread\n     * and use GLib asynchronous queues from the main thread to start\n     * read operations and to wait for them to complete.\n     */\n    if (pcap_src->from_cap_socket)\n#endif\n    {\n        bytes_read = 0;\n        while (bytes_read < sizeof magic) {\n            sel_ret = cap_pipe_select(fd);\n            if (sel_ret < 0) {\n                snprintf(errmsg, errmsgl,\n                           \"Unexpected error from select: %s.\",\n                           g_strerror(errno));\n                goto error;\n            } else if (sel_ret > 0) {\n                b = cap_pipe_read(fd, ((char *)&magic)+bytes_read,\n                                  sizeof magic-bytes_read,\n                                  pcap_src->from_cap_socket);\n                /* jump messaging, if extcap had an error, stderr will provide the correct message */\n                if (extcap_pipe && b <= 0)\n                    goto error;\n\n                if (b <= 0) {\n                    if (b == 0)\n                        snprintf(errmsg, errmsgl,\n                                   \"End of file on pipe magic during open.\");\n                    else\n                        snprintf(errmsg, errmsgl,\n                                   \"Error on pipe magic during open: %s.\",\n                                   g_strerror(errno));\n                    goto error;\n                }\n                bytes_read += b;\n            }\n        }\n    }\n#ifdef _WIN32\n    else {\n        /* Create a thread to read from this pipe */\n        g_thread_new(\"cap_pipe_open_live\", &cap_thread_read, pcap_src);\n\n        pipe_read_sync(pcap_src, &magic, sizeof(magic));\n        /* jump messaging, if extcap had an error, stderr will provide the correct message */\n        if (pcap_src->cap_pipe_bytes_read <= 0 && extcap_pipe)\n            goto error;\n\n        if (pcap_src->cap_pipe_bytes_read <= 0) {\n            if (pcap_src->cap_pipe_bytes_read == 0)\n                snprintf(errmsg, errmsgl,\n                           \"End of file on pipe magic during open.\");\n            else\n                snprintf(errmsg, errmsgl,\n                           \"Error on pipe magic during open: %s.\",\n                           g_strerror(errno));\n            goto error;\n        }\n    }\n#endif\n\n    switch (magic) {\n    case PCAP_MAGIC:\n    case PCAP_NSEC_MAGIC:\n        /* This is a pcap file.\n           The host that wrote it has our byte order, and was running\n           a program using either standard or ss990417 libpcap. */\n        pcap_src->cap_pipe_info.pcap.byte_swapped = false;\n        pcap_src->cap_pipe_modified = false;\n        pcap_src->ts_nsec = magic == PCAP_NSEC_MAGIC;\n        break;\n    case PCAP_MODIFIED_MAGIC:\n        /* This is a pcap file.\n           The host that wrote it has our byte order, but was running\n           a program using either ss990915 or ss991029 libpcap. */\n        pcap_src->cap_pipe_info.pcap.byte_swapped = false;\n        pcap_src->cap_pipe_modified = true;\n        break;\n    case PCAP_SWAPPED_MAGIC:\n    case PCAP_SWAPPED_NSEC_MAGIC:\n        /* This is a pcap file.\n           The host that wrote it has a byte order opposite to ours,\n           and was running a program using either standard or\n           ss990417 libpcap. */\n        pcap_src->cap_pipe_info.pcap.byte_swapped = true;\n        pcap_src->cap_pipe_modified = false;\n        pcap_src->ts_nsec = magic == PCAP_SWAPPED_NSEC_MAGIC;\n        break;\n    case PCAP_SWAPPED_MODIFIED_MAGIC:\n        /* This is a pcap file.\n           The host that wrote it out has a byte order opposite to\n           ours, and was running a program using either ss990915\n           or ss991029 libpcap. */\n        pcap_src->cap_pipe_info.pcap.byte_swapped = true;\n        pcap_src->cap_pipe_modified = true;\n        break;\n    case BLOCK_TYPE_SHB:\n        /* This is a pcapng file. */\n        pcap_src->from_pcapng = true;\n        pcap_src->cap_pipe_dispatch = pcapng_pipe_dispatch;\n        pcap_src->cap_pipe_info.pcapng.src_iface_to_global = g_array_new(FALSE, FALSE, sizeof(uint32_t));\n        global_capture_opts.use_pcapng = true;      /* we can only output in pcapng format */\n        break;\n    default:\n        /* Not a pcapng file, and either not a pcap type we know about\n           or not a pcap file, either. */\n        snprintf(errmsg, errmsgl,\n                   \"File type is neither a supported pcap nor pcapng format. (magic = 0x%08x)\", magic);\n        snprintf(secondary_errmsg, secondary_errmsgl, \"%s\",\n                   not_our_bug);\n        goto error;\n    }\n\n    if (pcap_src->from_pcapng)\n        pcapng_pipe_open_live(fd, pcap_src, errmsg, errmsgl);\n    else\n        pcap_pipe_open_live(fd, pcap_src, (struct pcap_hdr *) hdr, errmsg, errmsgl,\n                            secondary_errmsg, secondary_errmsgl);\n\n    return;\n\nerror:\n    ws_debug(\"cap_pipe_open_live: error %s\", errmsg);\n    pcap_src->cap_pipe_err = PIPERR;\n    cap_pipe_close(fd, pcap_src->from_cap_socket);\n    pcap_src->cap_pipe_fd = -1;\n#ifdef _WIN32\n    pcap_src->cap_pipe_h = INVALID_HANDLE_VALUE;\n#endif\n}\n\n/*\n * Read the part of the pcap file header that follows the magic\n * number (we've already read the magic number).\n */\nstatic void\npcap_pipe_open_live(int fd,\n                    capture_src *pcap_src,\n                    struct pcap_hdr *hdr,\n                    char *errmsg, size_t errmsgl,\n                    char *secondary_errmsg, size_t secondary_errmsgl)\n{\n    size_t   bytes_read;\n    ssize_t  b;\n    int      sel_ret;\n\n    /*\n     * We're reading from a pcap file.  We've already read the magic\n     * number; read the rest of the header.\n     *\n     * (Note that struct pcap_hdr is a structure for the part of a\n     * pcap file header *following the magic number*; it does not\n     * include the magic number itself.)\n     */\n#ifdef _WIN32\n    if (pcap_src->from_cap_socket)\n#endif\n    {\n        /* Keep reading until we get the rest of the header. */\n        bytes_read = 0;\n        while (bytes_read < sizeof(struct pcap_hdr)) {\n            sel_ret = cap_pipe_select(fd);\n            if (sel_ret < 0) {\n                snprintf(errmsg, errmsgl,\n                           \"Unexpected error from select: %s.\",\n                           g_strerror(errno));\n                goto error;\n            } else if (sel_ret > 0) {\n                b = cap_pipe_read(fd, ((char *)hdr)+bytes_read,\n                                  sizeof(struct pcap_hdr) - bytes_read,\n                                  pcap_src->from_cap_socket);\n                if (b <= 0) {\n                    if (b == 0)\n                        snprintf(errmsg, errmsgl,\n                                   \"End of file on pipe header during open.\");\n                    else\n                        snprintf(errmsg, errmsgl,\n                                   \"Error on pipe header during open: %s.\",\n                                   g_strerror(errno));\n                    snprintf(secondary_errmsg, secondary_errmsgl,\n                               \"%s\", not_our_bug);\n                    goto error;\n                }\n                bytes_read += b;\n            }\n        }\n    }\n#ifdef _WIN32\n    else {\n        pipe_read_sync(pcap_src, hdr, sizeof(struct pcap_hdr));\n        if (pcap_src->cap_pipe_bytes_read <= 0) {\n            if (pcap_src->cap_pipe_bytes_read == 0)\n                snprintf(errmsg, errmsgl,\n                           \"End of file on pipe header during open.\");\n            else\n                snprintf(errmsg, errmsgl,\n                           \"Error on pipe header header during open: %s.\",\n                           g_strerror(errno));\n            snprintf(secondary_errmsg, secondary_errmsgl, \"%s\",\n                       not_our_bug);\n            goto error;\n        }\n    }\n#endif\n\n    if (pcap_src->cap_pipe_info.pcap.byte_swapped) {\n        /* Byte-swap the header fields about which we care. */\n        hdr->version_major = GUINT16_SWAP_LE_BE(hdr->version_major);\n        hdr->version_minor = GUINT16_SWAP_LE_BE(hdr->version_minor);\n        hdr->snaplen = GUINT32_SWAP_LE_BE(hdr->snaplen);\n        hdr->network = GUINT32_SWAP_LE_BE(hdr->network);\n    }\n    /*\n     * The link-layer header type field of the pcap header is\n     * probably a LINKTYPE_ value, as the vast majority of\n     * LINKTYPE_ values and their corresponding DLT_ values\n     * are the same.\n     *\n     * However, in case the file was written by a program\n     * that used a DLT_ value, rather than a LINKTYPE_ value,\n     * in one of the cases where the two differ, use dlt_to_linktype()\n     * to map to a LINKTYPE_ value, just as we use it to map\n     * the result of pcap_datalink() to a LINKTYPE_ value.\n     */\n    pcap_src->linktype = dlt_to_linktype(hdr->network);\n    /* Pick the appropriate maximum packet size for the link type */\n    switch (pcap_src->linktype) {\n\n    case 231: /* DLT_DBUS */\n        pcap_src->cap_pipe_max_pkt_size = WTAP_MAX_PACKET_SIZE_DBUS;\n        break;\n\n    case 279: /* DLT_EBHSCR */\n        pcap_src->cap_pipe_max_pkt_size = WTAP_MAX_PACKET_SIZE_EBHSCR;\n        break;\n\n    case 249: /* DLT_USBPCAP */\n        pcap_src->cap_pipe_max_pkt_size = WTAP_MAX_PACKET_SIZE_USBPCAP;\n        break;\n\n    default:\n        pcap_src->cap_pipe_max_pkt_size = WTAP_MAX_PACKET_SIZE_STANDARD;\n        break;\n    }\n\n    if (hdr->version_major < 2) {\n        snprintf(errmsg, errmsgl,\n                   \"The old pcap format version %d.%d is not supported.\",\n                   hdr->version_major, hdr->version_minor);\n        snprintf(secondary_errmsg, secondary_errmsgl, \"%s\",\n                   not_our_bug);\n        goto error;\n    }\n\n    pcap_src->cap_pipe_fd = fd;\n    return;\n\nerror:\n    ws_debug(\"pcap_pipe_open_live: error %s\", errmsg);\n    pcap_src->cap_pipe_err = PIPERR;\n    cap_pipe_close(fd, pcap_src->from_cap_socket);\n    pcap_src->cap_pipe_fd = -1;\n#ifdef _WIN32\n    pcap_src->cap_pipe_h = INVALID_HANDLE_VALUE;\n#endif\n}\n\n/*\n * Synchronously read the fixed portion of the pcapng section header block\n * (we've already read the pcapng block header).\n */\nstatic int\npcapng_read_shb(capture_src *pcap_src,\n                char *errmsg,\n                size_t errmsgl)\n{\n    pcapng_section_header_block_t shb;\n\n#ifdef _WIN32\n    if (pcap_src->from_cap_socket)\n#endif\n    {\n        pcap_src->cap_pipe_bytes_to_read = sizeof(pcapng_block_header_t) + sizeof(pcapng_section_header_block_t);\n        if (cap_pipe_read_data_bytes(pcap_src, errmsg, errmsgl) < 0) {\n            return -1;\n        }\n    }\n#ifdef _WIN32\n    else {\n        pipe_read_sync(pcap_src, pcap_src->cap_pipe_databuf + sizeof(pcapng_block_header_t),\n            sizeof(pcapng_section_header_block_t));\n        if (pcap_src->cap_pipe_bytes_read <= 0) {\n            if (pcap_src->cap_pipe_bytes_read == 0)\n                snprintf(errmsg, errmsgl,\n                           \"End of file reading from pipe or socket.\");\n            else\n                snprintf(errmsg, errmsgl,\n                           \"Error reading from pipe or socket: %s.\",\n                           g_strerror(errno));\n            return -1;\n        }\n        /* Continuing with STATE_EXPECT_DATA requires reading into cap_pipe_databuf at offset cap_pipe_bytes_read */\n        pcap_src->cap_pipe_bytes_read = sizeof(pcapng_block_header_t) + sizeof(pcapng_section_header_block_t);\n    }\n#endif\n    memcpy(&shb, pcap_src->cap_pipe_databuf + sizeof(pcapng_block_header_t), sizeof(pcapng_section_header_block_t));\n    switch (shb.magic)\n    {\n    case PCAPNG_MAGIC:\n        ws_debug(\"pcapng SHB MAGIC\");\n        break;\n    case PCAPNG_SWAPPED_MAGIC:\n        ws_debug(\"pcapng SHB SWAPPED MAGIC\");\n        /*\n         * pcapng sources can contain all sorts of block types.\n         * Rather than add a bunch of complexity to this code (which is\n         * often privileged), punt and tell the user to swap bytes\n         * elsewhere.\n         *\n         * XXX - punting means that the Wireshark test suite must be\n         * modified to:\n         *\n         *  1) have both little-endian and big-endian versions of\n         *     all pcapng files piped to dumpcap;\n         *\n         *  2) pipe the appropriate file to dumpcap, depending on\n         *     the byte order of the host on which the tests are\n         *     being run;\n         *\n         * as per comments in bug 15772 and 15754.\n         *\n         * Are we *really* certain that the complexity added would be\n         * significant enough to make adding it a security risk?  And\n         * why would this code even be running with any elevated\n         * privileges if you're capturing from a pipe?  We should not\n         * only have given up all additional privileges if we're reading\n         * from a pipe, we should give them up in such a fashion that\n         * we can't reclaim them.\n         */\n#if G_BYTE_ORDER == G_BIG_ENDIAN\n#define OUR_ENDIAN \"big\"\n#define IFACE_ENDIAN \"little\"\n#else\n#define OUR_ENDIAN \"little\"\n#define IFACE_ENDIAN \"big\"\n#endif\n        snprintf(errmsg, errmsgl,\n                   \"Interface %u is \" IFACE_ENDIAN \" endian but we're \" OUR_ENDIAN \" endian.\",\n                   pcap_src->interface_id);\n        return -1;\n    default:\n        /* Not a pcapng type we know about, or not pcapng at all. */\n        snprintf(errmsg, errmsgl,\n                   \"Unrecognized pcapng format or not pcapng data.\");\n        return -1;\n    }\n\n    pcap_src->cap_pipe_max_pkt_size = WTAP_MAX_PACKET_SIZE_STANDARD;\n\n    /* Setup state to capture any options following the section header block */\n    pcap_src->cap_pipe_state = STATE_EXPECT_DATA;\n\n    return 0;\n}\n\n/*\n * Save IDB blocks for playback whenever we change output files, and\n * fix LINKTYPE_ values that are really platform-dependent DLT_ values.\n * Rewrite EPB and ISB interface IDs.\n */\nstatic bool\npcapng_adjust_block(capture_src *pcap_src, const pcapng_block_header_t *bh, uint8_t *pd)\n{\n    switch(bh->block_type) {\n    case BLOCK_TYPE_SHB:\n    {\n        if (global_ld.pcapng_passthrough) {\n            /*\n             * We have a single pcapng input. We pass the SHB through when\n             * writing a single output file and for the first ring buffer\n             * file. We need to save it for the second and subsequent ring\n             * buffer files.\n             */\n            g_free(global_ld.saved_shb);\n            global_ld.saved_shb = (uint8_t *) g_memdup2(pd, bh->block_total_length);\n\n            /*\n             * We're dealing with one section at a time, so we can (and must)\n             * get rid of our old IDBs.\n             */\n            for (unsigned i = 0; i < global_ld.saved_idbs->len; i++) {\n                saved_idb_t *idb_source = &g_array_index(global_ld.saved_idbs, saved_idb_t, i);\n                g_free(idb_source->idb);\n            }\n            g_array_set_size(global_ld.saved_idbs, 0);\n        } else {\n            /*\n             * We have a new SHB from this capture source. We need to keep\n             * global_ld.saved_idbs intact, so we mark IDBs we previously\n             * collected from this source as deleted.\n             */\n            for (unsigned i = 0; i < pcap_src->cap_pipe_info.pcapng.src_iface_to_global->len; i++) {\n                uint32_t iface_id = g_array_index(pcap_src->cap_pipe_info.pcapng.src_iface_to_global, uint32_t, i);\n                saved_idb_t *idb_source = &g_array_index(global_ld.saved_idbs, saved_idb_t, iface_id);\n                ws_assert(idb_source->interface_id == pcap_src->interface_id);\n                g_free(idb_source->idb);\n                memset(idb_source, 0, sizeof(saved_idb_t));\n                idb_source->deleted = true;\n                ws_debug(\"%s: deleted pcapng IDB %u\", G_STRFUNC, iface_id);\n            }\n        }\n        g_array_set_size(pcap_src->cap_pipe_info.pcapng.src_iface_to_global, 0);\n    }\n        break;\n    case BLOCK_TYPE_IDB:\n    {\n        /*\n         * Always gather IDBs. We can remove them or mark them as deleted\n         * when we get a new SHB.\n         */\n        saved_idb_t idb_source = { 0 };\n        idb_source.interface_id = pcap_src->interface_id;\n        idb_source.idb_len = bh->block_total_length;\n        idb_source.idb = (uint8_t *) g_memdup2(pd, idb_source.idb_len);\n        g_array_append_val(global_ld.saved_idbs, idb_source);\n        uint32_t iface_id = global_ld.saved_idbs->len - 1;\n        g_array_append_val(pcap_src->cap_pipe_info.pcapng.src_iface_to_global, iface_id);\n        ws_debug(\"%s: mapped pcapng IDB %u -> %u from source %u\",\n              G_STRFUNC, pcap_src->cap_pipe_info.pcapng.src_iface_to_global->len - 1, iface_id, pcap_src->interface_id);\n    }\n        break;\n    case BLOCK_TYPE_EPB:\n    case BLOCK_TYPE_ISB:\n    {\n        if (global_ld.pcapng_passthrough) {\n            /* Our input and output interface IDs are the same. */\n            break;\n        }\n        /* The interface ID is the first 32-bit field after the BH for both EPBs and ISBs. */\n        uint32_t iface_id;\n        memcpy(&iface_id, pd + sizeof(pcapng_block_header_t), 4);\n        if (iface_id < pcap_src->cap_pipe_info.pcapng.src_iface_to_global->len) {\n            memcpy(pd + sizeof(pcapng_block_header_t),\n                   &g_array_index(pcap_src->cap_pipe_info.pcapng.src_iface_to_global, uint32_t, iface_id), 4);\n        } else {\n            ws_debug(\"%s: pcapng EPB or ISB interface id %u > max %u\", G_STRFUNC, iface_id, pcap_src->cap_pipe_info.pcapng.src_iface_to_global->len);\n            return false;\n        }\n    }\n        break;\n    default:\n        break;\n    }\n\n    return true;\n}\n\n/*\n * Return true if the block contains packet, event, or log data. Return false otherwise.\n */\nstatic bool is_data_block(uint32_t block_type)\n{\n    // Any block types that lead to calling wtap_read_bytes_buffer in\n    // wiretap/pcapng.c should be listed here.\n    switch (block_type) {\n        case BLOCK_TYPE_PB:\n        case BLOCK_TYPE_EPB:\n        case BLOCK_TYPE_SPB:\n        case BLOCK_TYPE_SYSTEMD_JOURNAL_EXPORT:\n        case BLOCK_TYPE_SYSDIG_EVENT:\n        case BLOCK_TYPE_SYSDIG_EVENT_V2:\n        case BLOCK_TYPE_SYSDIG_EVENT_V2_LARGE:\n            return true;\n        default:\n            break;\n    }\n    return false;\n}\n\n/*\n * Read the part of the initial pcapng SHB following the block type\n * (we've already read the block type).\n */\nstatic void\npcapng_pipe_open_live(int fd,\n                      capture_src *pcap_src,\n                      char *errmsg,\n                      size_t errmsgl)\n{\n    uint32_t type = BLOCK_TYPE_SHB;\n    pcapng_block_header_t *bh = &pcap_src->cap_pipe_info.pcapng.bh;\n\n    ws_debug(\"pcapng_pipe_open_live: fd %d\", fd);\n\n    /*\n     * A pcapng block begins with the block type followed by the block\n     * total length; we've already read the block type, now read the\n     * block length.\n     */\n#ifdef _WIN32\n    /*\n     * On UN*X, we can use select() on pipes or sockets.\n     *\n     * On Windows, we can only use it on sockets; to do non-blocking\n     * reads from pipes, we currently do reads in a separate thread\n     * and use GLib asynchronous queues from the main thread to start\n     * read operations and to wait for them to complete.\n     */\n    if (pcap_src->from_cap_socket)\n#endif\n    {\n        memcpy(pcap_src->cap_pipe_databuf, &type, sizeof(uint32_t));\n        pcap_src->cap_pipe_bytes_read = sizeof(uint32_t);\n        pcap_src->cap_pipe_bytes_to_read = sizeof(pcapng_block_header_t);\n        pcap_src->cap_pipe_fd = fd;\n        if (cap_pipe_read_data_bytes(pcap_src, errmsg, errmsgl) < 0) {\n            goto error;\n        }\n        memcpy(bh, pcap_src->cap_pipe_databuf, sizeof(pcapng_block_header_t));\n    }\n#ifdef _WIN32\n    else {\n        g_thread_new(\"cap_pipe_open_live\", &cap_thread_read, pcap_src);\n\n        bh->block_type = type;\n        pipe_read_sync(pcap_src, &bh->block_total_length,\n            sizeof(bh->block_total_length));\n        if (pcap_src->cap_pipe_bytes_read <= 0) {\n            if (pcap_src->cap_pipe_bytes_read == 0)\n                snprintf(errmsg, errmsgl,\n                           \"End of file reading from pipe or socket.\");\n            else\n                snprintf(errmsg, errmsgl,\n                           \"Error reading from pipe or socket: %s.\",\n                           g_strerror(errno));\n            goto error;\n        }\n        pcap_src->cap_pipe_bytes_read = sizeof(pcapng_block_header_t);\n        memcpy(pcap_src->cap_pipe_databuf, bh, sizeof(pcapng_block_header_t));\n        pcap_src->cap_pipe_fd = fd;\n    }\n#endif\n    if ((bh->block_total_length & 0x03) != 0) {\n        snprintf(errmsg, errmsgl,\n                   \"block_total_length read from pipe is %u, which is not a multiple of 4.\",\n                   bh->block_total_length);\n        goto error;\n    }\n    if (pcapng_read_shb(pcap_src, errmsg, errmsgl)) {\n        goto error;\n    }\n\n    return;\n\nerror:\n    ws_debug(\"pcapng_pipe_open_live: error %s\", errmsg);\n    pcap_src->cap_pipe_err = PIPERR;\n    cap_pipe_close(fd, pcap_src->from_cap_socket);\n    pcap_src->cap_pipe_fd = -1;\n#ifdef _WIN32\n    pcap_src->cap_pipe_h = INVALID_HANDLE_VALUE;\n#endif\n}\n\n/* We read one record from the pipe, take care of byte order in the record\n * header, write the record to the capture file, and update capture statistics. */\nstatic int\npcap_pipe_dispatch(loop_data *ld, capture_src *pcap_src, char *errmsg, size_t errmsgl)\n{\n    struct pcap_pkthdr  phdr;\n    enum { PD_REC_HDR_READ, PD_DATA_READ, PD_PIPE_EOF, PD_PIPE_ERR,\n           PD_ERR } result;\n#ifdef _WIN32\n    void *    q_status;\n#endif\n    ssize_t   b;\n    unsigned new_bufsize;\n    pcap_pipe_info_t *pcap_info = &pcap_src->cap_pipe_info.pcap;\n\n#ifdef LOG_CAPTURE_VERBOSE\n    ws_debug(\"pcap_pipe_dispatch\");\n#endif\n\n    switch (pcap_src->cap_pipe_state) {\n\n    case STATE_EXPECT_REC_HDR:\n#ifdef _WIN32\n        if (g_mutex_trylock(pcap_src->cap_pipe_read_mtx)) {\n#endif\n\n            pcap_src->cap_pipe_state = STATE_READ_REC_HDR;\n            pcap_src->cap_pipe_bytes_to_read = pcap_src->cap_pipe_modified ?\n                sizeof(struct pcaprec_modified_hdr) : sizeof(struct pcaprec_hdr);\n            pcap_src->cap_pipe_bytes_read = 0;\n\n#ifdef _WIN32\n            pcap_src->cap_pipe_buf = (char *) &pcap_info->rechdr;\n            g_async_queue_push(pcap_src->cap_pipe_pending_q, pcap_src->cap_pipe_buf);\n            g_mutex_unlock(pcap_src->cap_pipe_read_mtx);\n        }\n#endif\n        /* Fall through */\n\n    case STATE_READ_REC_HDR:\n#ifdef _WIN32\n        if (pcap_src->from_cap_socket)\n#endif\n        {\n            b = cap_pipe_read(pcap_src->cap_pipe_fd, ((char *)&pcap_info->rechdr)+pcap_src->cap_pipe_bytes_read,\n                 pcap_src->cap_pipe_bytes_to_read - pcap_src->cap_pipe_bytes_read, pcap_src->from_cap_socket);\n            if (b <= 0) {\n                if (b == 0)\n                    result = PD_PIPE_EOF;\n                else\n                    result = PD_PIPE_ERR;\n                break;\n            }\n#ifdef _WIN32\n            pcap_src->cap_pipe_bytes_read += (DWORD)b;\n#else\n            pcap_src->cap_pipe_bytes_read += b;\n#endif\n        }\n#ifdef _WIN32\n        else {\n            q_status = g_async_queue_timeout_pop(pcap_src->cap_pipe_done_q, PIPE_READ_TIMEOUT);\n            if (pcap_src->cap_pipe_err == PIPEOF) {\n                result = PD_PIPE_EOF;\n                break;\n            } else if (pcap_src->cap_pipe_err == PIPERR) {\n                result = PD_PIPE_ERR;\n                break;\n            }\n            if (!q_status) {\n                return 0;\n            }\n        }\n#endif\n        if (pcap_src->cap_pipe_bytes_read < pcap_src->cap_pipe_bytes_to_read) {\n            /* There's still more of the pcap packet header to read. */\n            return 0;\n        }\n        result = PD_REC_HDR_READ;\n        break;\n\n    case STATE_EXPECT_DATA:\n#ifdef _WIN32\n        if (g_mutex_trylock(pcap_src->cap_pipe_read_mtx)) {\n#endif\n\n            pcap_src->cap_pipe_state = STATE_READ_DATA;\n            pcap_src->cap_pipe_bytes_to_read = pcap_info->rechdr.hdr.incl_len;\n            pcap_src->cap_pipe_bytes_read = 0;\n\n#ifdef _WIN32\n            pcap_src->cap_pipe_buf = pcap_src->cap_pipe_databuf;\n            g_async_queue_push(pcap_src->cap_pipe_pending_q, pcap_src->cap_pipe_buf);\n            g_mutex_unlock(pcap_src->cap_pipe_read_mtx);\n        }\n#endif\n        /* Fall through */\n\n    case STATE_READ_DATA:\n#ifdef _WIN32\n        if (pcap_src->from_cap_socket)\n#endif\n        {\n            b = cap_pipe_read(pcap_src->cap_pipe_fd,\n                              pcap_src->cap_pipe_databuf+pcap_src->cap_pipe_bytes_read,\n                              pcap_src->cap_pipe_bytes_to_read - pcap_src->cap_pipe_bytes_read,\n                              pcap_src->from_cap_socket);\n            if (b <= 0) {\n                if (b == 0)\n                    result = PD_PIPE_EOF;\n                else\n                    result = PD_PIPE_ERR;\n                break;\n            }\n#ifdef _WIN32\n            pcap_src->cap_pipe_bytes_read += (DWORD)b;\n#else\n            pcap_src->cap_pipe_bytes_read += b;\n#endif\n        }\n#ifdef _WIN32\n        else {\n\n            q_status = g_async_queue_timeout_pop(pcap_src->cap_pipe_done_q, PIPE_READ_TIMEOUT);\n            if (pcap_src->cap_pipe_err == PIPEOF) {\n                result = PD_PIPE_EOF;\n                break;\n            } else if (pcap_src->cap_pipe_err == PIPERR) {\n                result = PD_PIPE_ERR;\n                break;\n            }\n            if (!q_status) {\n                return 0;\n            }\n        }\n#endif /* _WIN32 */\n        if (pcap_src->cap_pipe_bytes_read < pcap_src->cap_pipe_bytes_to_read) {\n            /* There's still more of the pcap packet data to read. */\n            return 0;\n        }\n        result = PD_DATA_READ;\n        break;\n\n    default:\n        snprintf(errmsg, errmsgl,\n                   \"pcap_pipe_dispatch: invalid state\");\n        result = PD_ERR;\n\n    } /* switch (pcap_src->cap_pipe_state) */\n\n    /*\n     * We've now read as much data as we were expecting, so process it.\n     */\n    switch (result) {\n\n    case PD_REC_HDR_READ:\n        /*\n         * We've read the packet header, so we know the captured length,\n         * and thus the number of packet data bytes. Take care of byte order.\n         */\n        cap_pipe_adjust_pcap_header(pcap_src->cap_pipe_info.pcap.byte_swapped, &pcap_info->hdr,\n                               &pcap_info->rechdr.hdr);\n        if (pcap_info->rechdr.hdr.incl_len > pcap_src->cap_pipe_max_pkt_size) {\n            /*\n             * The record contains more data than the advertised/allowed in the\n             * pcap header, do not try to read more data (do not change to\n             * STATE_EXPECT_DATA) as that would not fit in the buffer and\n             * instead stop with an error.\n             */\n            snprintf(errmsg, errmsgl, \"Frame %u too long (%d bytes)\",\n                       ld->packets_captured+1, pcap_info->rechdr.hdr.incl_len);\n            break;\n        }\n\n        if (pcap_info->rechdr.hdr.incl_len > pcap_src->cap_pipe_databuf_size) {\n            /*\n             * Grow the buffer to the packet size, rounded up to a power of\n             * 2.\n             */\n            new_bufsize = pcap_info->rechdr.hdr.incl_len;\n            /*\n             * https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n             */\n            new_bufsize--;\n            new_bufsize |= new_bufsize >> 1;\n            new_bufsize |= new_bufsize >> 2;\n            new_bufsize |= new_bufsize >> 4;\n            new_bufsize |= new_bufsize >> 8;\n            new_bufsize |= new_bufsize >> 16;\n            new_bufsize++;\n            pcap_src->cap_pipe_databuf = (char*)g_realloc(pcap_src->cap_pipe_databuf, new_bufsize);\n            pcap_src->cap_pipe_databuf_size = new_bufsize;\n        }\n\n        if (pcap_info->rechdr.hdr.incl_len) {\n            /*\n             * The record has some data following the header, try\n             * to read it next time.\n             */\n            pcap_src->cap_pipe_state = STATE_EXPECT_DATA;\n            return 0;\n        }\n\n        /*\n         * No data following the record header? Then no more data needs to be\n         * read and we will fallthrough and emit an empty packet.\n         */\n        /* FALLTHROUGH */\n\n    case PD_DATA_READ:\n        /*\n         * We've read the full contents of the packet record.\n         * Fill in a \"struct pcap_pkthdr\", and process the packet.\n         */\n        phdr.ts.tv_sec = pcap_info->rechdr.hdr.ts_sec;\n        phdr.ts.tv_usec = pcap_info->rechdr.hdr.ts_usec;\n        phdr.caplen = pcap_info->rechdr.hdr.incl_len;\n        phdr.len = pcap_info->rechdr.hdr.orig_len;\n\n        if (use_threads) {\n            capture_loop_queue_packet_cb((uint8_t *)pcap_src, &phdr, pcap_src->cap_pipe_databuf);\n        } else {\n            capture_loop_write_packet_cb((uint8_t *)pcap_src, &phdr, pcap_src->cap_pipe_databuf);\n        }\n\n        /*\n         * Now we want to read the next packet's header.\n         */\n        pcap_src->cap_pipe_state = STATE_EXPECT_REC_HDR;\n        return 1;\n\n    case PD_PIPE_EOF:\n        pcap_src->cap_pipe_err = PIPEOF;\n        return -1;\n\n    case PD_PIPE_ERR:\n        snprintf(errmsg, errmsgl, \"Error reading from pipe: %s\",\n#ifdef _WIN32\n                   win32strerror(GetLastError()));\n#else\n                   g_strerror(errno));\n#endif\n        /* Fall through */\n    case PD_ERR:\n        break;\n    }\n\n    pcap_src->cap_pipe_err = PIPERR;\n    /* Return here rather than inside the switch to prevent GCC warning */\n    return -1;\n}\n\nstatic int\npcapng_pipe_dispatch(loop_data *ld, capture_src *pcap_src, char *errmsg, size_t errmsgl)\n{\n    enum { PD_REC_HDR_READ, PD_DATA_READ, PD_PIPE_EOF, PD_PIPE_ERR,\n           PD_ERR } result;\n#ifdef _WIN32\n    void *    q_status;\n#endif\n    unsigned new_bufsize;\n    pcapng_block_header_t *bh = &pcap_src->cap_pipe_info.pcapng.bh;\n\n#ifdef LOG_CAPTURE_VERBOSE\n    ws_debug(\"pcapng_pipe_dispatch\");\n#endif\n\n    switch (pcap_src->cap_pipe_state) {\n\n    case STATE_EXPECT_REC_HDR:\n#ifdef LOG_CAPTURE_VERBOSE\n        ws_debug(\"pcapng_pipe_dispatch STATE_EXPECT_REC_HDR\");\n#endif\n#ifdef _WIN32\n        if (g_mutex_trylock(pcap_src->cap_pipe_read_mtx)) {\n#endif\n\n            pcap_src->cap_pipe_state = STATE_READ_REC_HDR;\n            pcap_src->cap_pipe_bytes_to_read = sizeof(pcapng_block_header_t);\n            pcap_src->cap_pipe_bytes_read = 0;\n\n#ifdef _WIN32\n            if (!pcap_src->from_cap_socket) {\n                pcap_src->cap_pipe_buf = pcap_src->cap_pipe_databuf;\n                g_async_queue_push(pcap_src->cap_pipe_pending_q, pcap_src->cap_pipe_buf);\n            }\n            g_mutex_unlock(pcap_src->cap_pipe_read_mtx);\n        }\n#endif\n        /* Fall through */\n\n    case STATE_READ_REC_HDR:\n#ifdef LOG_CAPTURE_VERBOSE\n        ws_debug(\"pcapng_pipe_dispatch STATE_READ_REC_HDR\");\n#endif\n#ifdef _WIN32\n        if (pcap_src->from_cap_socket) {\n#endif\n            if (cap_pipe_read_data_bytes(pcap_src, errmsg, errmsgl) < 0) {\n                return -1;\n            }\n#ifdef _WIN32\n        } else {\n            q_status = g_async_queue_timeout_pop(pcap_src->cap_pipe_done_q, PIPE_READ_TIMEOUT);\n            if (pcap_src->cap_pipe_err == PIPEOF) {\n                result = PD_PIPE_EOF;\n                break;\n            } else if (pcap_src->cap_pipe_err == PIPERR) {\n                result = PD_PIPE_ERR;\n                break;\n            }\n            if (!q_status) {\n                return 0;\n            }\n        }\n#endif\n        if (pcap_src->cap_pipe_bytes_read < pcap_src->cap_pipe_bytes_to_read) {\n            /* There's still more of the pcapng block header to read. */\n            return 0;\n        }\n        memcpy(bh, pcap_src->cap_pipe_databuf, sizeof(pcapng_block_header_t));\n        result = PD_REC_HDR_READ;\n        break;\n\n    case STATE_EXPECT_DATA:\n#ifdef LOG_CAPTURE_VERBOSE\n        ws_debug(\"pcapng_pipe_dispatch STATE_EXPECT_DATA\");\n#endif\n#ifdef _WIN32\n        if (g_mutex_trylock(pcap_src->cap_pipe_read_mtx)) {\n#endif\n            pcap_src->cap_pipe_state = STATE_READ_DATA;\n            pcap_src->cap_pipe_bytes_to_read = bh->block_total_length;\n\n#ifdef _WIN32\n            if (!pcap_src->from_cap_socket) {\n                pcap_src->cap_pipe_bytes_to_read -= pcap_src->cap_pipe_bytes_read;\n                pcap_src->cap_pipe_buf = pcap_src->cap_pipe_databuf + pcap_src->cap_pipe_bytes_read;\n                pcap_src->cap_pipe_bytes_read = 0;\n                g_async_queue_push(pcap_src->cap_pipe_pending_q, pcap_src->cap_pipe_buf);\n            }\n            g_mutex_unlock(pcap_src->cap_pipe_read_mtx);\n        }\n#endif\n        /* Fall through */\n\n    case STATE_READ_DATA:\n#ifdef LOG_CAPTURE_VERBOSE\n        ws_debug(\"pcapng_pipe_dispatch STATE_READ_DATA\");\n#endif\n#ifdef _WIN32\n        if (pcap_src->from_cap_socket) {\n#endif\n            if (cap_pipe_read_data_bytes(pcap_src, errmsg, errmsgl) < 0) {\n                return -1;\n            }\n#ifdef _WIN32\n        } else {\n\n            q_status = g_async_queue_timeout_pop(pcap_src->cap_pipe_done_q, PIPE_READ_TIMEOUT);\n            if (pcap_src->cap_pipe_err == PIPEOF) {\n                result = PD_PIPE_EOF;\n                break;\n            } else if (pcap_src->cap_pipe_err == PIPERR) {\n                result = PD_PIPE_ERR;\n                break;\n            }\n            if (!q_status) {\n                return 0;\n            }\n        }\n#endif /* _WIN32 */\n        if (pcap_src->cap_pipe_bytes_read < pcap_src->cap_pipe_bytes_to_read) {\n            /* There's still more of the pcap block contents to read. */\n            return 0;\n        }\n        result = PD_DATA_READ;\n        break;\n\n    default:\n        snprintf(errmsg, errmsgl,\n                   \"pcapng_pipe_dispatch: invalid state\");\n        result = PD_ERR;\n\n    } /* switch (pcap_src->cap_pipe_state) */\n\n    /*\n     * We've now read as much data as we were expecting, so process it.\n     */\n    switch (result) {\n\n    case PD_REC_HDR_READ:\n        /*\n         * We've read the pcapng block header, so we know the block type\n         * and length.\n         */\n        if (bh->block_type == BLOCK_TYPE_SHB) {\n            /*\n             * We need to read the fixed portion of the SHB before to\n             * get the endianness before we can interpret the block length.\n             * (The block type of the SHB is byte-order-independent, so that\n             * an SHB can be recognized before we know the endianness of\n             * the section.)\n             *\n             * Continue the read process.\n             */\n            pcapng_read_shb(pcap_src, errmsg, errmsgl);\n            return 1;\n        }\n\n        if ((bh->block_total_length & 0x03) != 0) {\n            snprintf(errmsg, errmsgl,\n                       \"Total length of pcapng block read from pipe is %u, which is not a multiple of 4.\",\n                       bh->block_total_length);\n            break;\n        }\n        if (is_data_block(bh->block_type) && bh->block_total_length > pcap_src->cap_pipe_max_pkt_size) {\n            /*\n            * The record contains more data than the advertised/allowed in the\n            * pcapng header, do not try to read more data (do not change to\n            * STATE_EXPECT_DATA) as that would not fit in the buffer and\n            * instead stop with an error.\n            */\n            snprintf(errmsg, errmsgl, \"Block %u type 0x%08x too long (%d bytes)\",\n                    ld->packets_captured+1, bh->block_type, bh->block_total_length);\n            break;\n        }\n\n        if (bh->block_total_length > pcap_src->cap_pipe_databuf_size) {\n            /*\n            * Grow the buffer to the packet size, rounded up to a power of\n            * 2.\n            */\n            new_bufsize = bh->block_total_length;\n            /*\n            * https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n            */\n            new_bufsize--;\n            new_bufsize |= new_bufsize >> 1;\n            new_bufsize |= new_bufsize >> 2;\n            new_bufsize |= new_bufsize >> 4;\n            new_bufsize |= new_bufsize >> 8;\n            new_bufsize |= new_bufsize >> 16;\n            new_bufsize++;\n            pcap_src->cap_pipe_databuf = (unsigned char*)g_realloc(pcap_src->cap_pipe_databuf, new_bufsize);\n            pcap_src->cap_pipe_databuf_size = new_bufsize;\n        }\n\n        /* The record always has at least the block total length following the header */\n        if (bh->block_total_length < sizeof(pcapng_block_header_t)+sizeof(uint32_t)) {\n            snprintf(errmsg, errmsgl,\n                       \"malformed pcapng block_total_length < minimum\");\n            pcap_src->cap_pipe_err = PIPEOF;\n            return -1;\n        }\n\n        /*\n         * Now we want to read the block contents.\n         */\n        pcap_src->cap_pipe_state = STATE_EXPECT_DATA;\n        return 0;\n\n    case PD_DATA_READ:\n        /*\n         * We've read the full contents of the block.\n         * Process the block.\n         */\n        if (use_threads) {\n            capture_loop_queue_pcapng_cb(pcap_src, bh, pcap_src->cap_pipe_databuf);\n        } else {\n            capture_loop_write_pcapng_cb(pcap_src, bh, pcap_src->cap_pipe_databuf);\n        }\n\n        /*\n         * Now we want to read the next block's header.\n         */\n        pcap_src->cap_pipe_state = STATE_EXPECT_REC_HDR;\n        return 1;\n\n    case PD_PIPE_EOF:\n        pcap_src->cap_pipe_err = PIPEOF;\n        return -1;\n\n    case PD_PIPE_ERR:\n        snprintf(errmsg, errmsgl, \"Error reading from pipe: %s\",\n#ifdef _WIN32\n                   win32strerror(GetLastError()));\n#else\n                   g_strerror(errno));\n#endif\n        /* Fall through */\n    case PD_ERR:\n        break;\n    }\n\n    pcap_src->cap_pipe_err = PIPERR;\n    /* Return here rather than inside the switch to prevent GCC warning */\n    return -1;\n}\n\n/** Open the capture input sources; each one is either a pcap device,\n *  a capture pipe, or a capture socket.\n *  Returns true if it succeeds, false otherwise. */\nstatic bool\ncapture_loop_open_input(capture_options *capture_opts, loop_data *ld,\n                        char *errmsg, size_t errmsg_len,\n                        char *secondary_errmsg, size_t secondary_errmsg_len)\n{\n    cap_device_open_status open_status;\n    char                open_status_str[PCAP_ERRBUF_SIZE];\n    char               *sync_msg_str;\n    interface_options  *interface_opts;\n    capture_src        *pcap_src;\n    unsigned            i;\n\n    if ((use_threads == false) &&\n        (capture_opts->ifaces->len > 1)) {\n        snprintf(errmsg, errmsg_len,\n                   \"Using threads is required for capturing on multiple interfaces.\");\n        return false;\n    }\n\n    int pcapng_src_count = 0;\n    for (i = 0; i < capture_opts->ifaces->len; i++) {\n        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);\n        pcap_src = g_new0(capture_src, 1);\n        if (pcap_src == NULL) {\n            snprintf(errmsg, errmsg_len,\n                   \"Could not allocate memory.\");\n            return false;\n        }\n\n#ifdef MUST_DO_SELECT\n        pcap_src->pcap_fd = -1;\n#endif\n        pcap_src->interface_id = i;\n        pcap_src->linktype = -1;\n#ifdef _WIN32\n        pcap_src->cap_pipe_h = INVALID_HANDLE_VALUE;\n#endif\n        pcap_src->cap_pipe_fd = -1;\n        pcap_src->cap_pipe_dispatch = pcap_pipe_dispatch;\n        pcap_src->cap_pipe_state = STATE_EXPECT_REC_HDR;\n        pcap_src->cap_pipe_err = PIPOK;\n#ifdef _WIN32\n        pcap_src->cap_pipe_read_mtx = g_new(GMutex, 1);\n        g_mutex_init(pcap_src->cap_pipe_read_mtx);\n        pcap_src->cap_pipe_pending_q = g_async_queue_new();\n        pcap_src->cap_pipe_done_q = g_async_queue_new();\n#endif\n        g_array_append_val(ld->pcaps, pcap_src);\n\n        ws_debug(\"capture_loop_open_input : %s\", interface_opts->name);\n        pcap_src->pcap_h = open_capture_device(capture_opts, interface_opts,\n            CAP_READ_TIMEOUT, &open_status, &open_status_str);\n\n        if (pcap_src->pcap_h != NULL) {\n            /* we've opened \"iface\" as a network device */\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n            /* Find out if we're getting nanosecond-precision time stamps */\n            pcap_src->ts_nsec = have_high_resolution_timestamp(pcap_src->pcap_h);\n#endif\n\n#if defined(HAVE_PCAP_SETSAMPLING)\n            if (interface_opts->sampling_method != CAPTURE_SAMP_NONE) {\n                struct pcap_samp *samp;\n\n                if ((samp = pcap_setsampling(pcap_src->pcap_h)) != NULL) {\n                    switch (interface_opts->sampling_method) {\n                    case CAPTURE_SAMP_BY_COUNT:\n                        samp->method = PCAP_SAMP_1_EVERY_N;\n                        break;\n\n                    case CAPTURE_SAMP_BY_TIMER:\n                        samp->method = PCAP_SAMP_FIRST_AFTER_N_MS;\n                        break;\n\n                    default:\n                        sync_msg_str = ws_strdup_printf(\n                            \"Unknown sampling method %d specified,\\n\"\n                            \"continue without packet sampling\",\n                            interface_opts->sampling_method);\n                        report_capture_error(\"Couldn't set the capture \"\n                                             \"sampling\", sync_msg_str);\n                        g_free(sync_msg_str);\n                    }\n                    samp->value = interface_opts->sampling_param;\n                } else {\n                    report_capture_error(\"Couldn't set the capture sampling\",\n                                         \"Cannot get packet sampling data structure\");\n                }\n            }\n#endif\n\n            /* setting the data link type only works on real interfaces */\n            if (!set_pcap_datalink(pcap_src->pcap_h, interface_opts->linktype,\n                                   interface_opts->name,\n                                   errmsg, errmsg_len,\n                                   secondary_errmsg, secondary_errmsg_len)) {\n                return false;\n            }\n            pcap_src->linktype = dlt_to_linktype(get_pcap_datalink(pcap_src->pcap_h, interface_opts->name));\n        } else {\n            /* We couldn't open \"iface\" as a network device. */\n            /* Try to open it as a pipe */\n            bool pipe_err = false;\n            cap_pipe_open_live(interface_opts->name, pcap_src,\n                               &pcap_src->cap_pipe_info.pcap.hdr,\n                               errmsg, errmsg_len,\n                               secondary_errmsg, secondary_errmsg_len);\n\n#ifdef _WIN32\n            if (pcap_src->from_cap_socket) {\n#endif\n                if (pcap_src->cap_pipe_fd == -1) {\n                    pipe_err = true;\n                }\n#ifdef _WIN32\n            } else {\n                if (pcap_src->cap_pipe_h == INVALID_HANDLE_VALUE) {\n                    pipe_err = true;\n                }\n            }\n#endif\n\n            if (pipe_err) {\n                if (pcap_src->cap_pipe_err == PIPNEXIST) {\n                    /*\n                     * We tried opening as an interface, and that failed,\n                     * so we tried to open it as a pipe, but the pipe\n                     * doesn't exist.  Report the error message for\n                     * the interface.\n                     */\n                    get_capture_device_open_failure_messages(open_status,\n                                                             open_status_str,\n                                                             interface_opts->name,\n                                                             errmsg,\n                                                             errmsg_len,\n                                                             secondary_errmsg,\n                                                             secondary_errmsg_len);\n                }\n                /*\n                 * Else pipe (or file) does exist and cap_pipe_open_live() has\n                 * filled in errmsg\n                 */\n                return false;\n            } else {\n                /*\n                 * We tried opening as an interface, and that failed,\n                 * so we tried to open it as a pipe, and that succeeded.\n                 */\n                open_status = CAP_DEVICE_OPEN_NO_ERR;\n            }\n        }\n\n/* XXX - will this work for tshark? */\n#ifdef MUST_DO_SELECT\n        if (!pcap_src->from_cap_pipe) {\n            pcap_src->pcap_fd = pcap_get_selectable_fd(pcap_src->pcap_h);\n        }\n#endif\n\n        /* Is \"open_status\" something other than CAP_DEVICE_OPEN_NO_ERR?\n           If so, \"open_capture_device()\" returned a warning; print it,\n           but keep capturing. */\n        if (open_status != CAP_DEVICE_OPEN_NO_ERR) {\n            sync_msg_str = ws_strdup_printf(\"%s.\", open_status_str);\n            report_capture_error(sync_msg_str, \"\");\n            g_free(sync_msg_str);\n        }\n        if (pcap_src->from_pcapng) {\n            /*\n             * We will use the IDBs from the source (but rewrite the\n             * interface IDs if there's more than one source.)\n             */\n            pcapng_src_count++;\n        } else {\n            /*\n             * Add our pcapng interface entry.\n             */\n            saved_idb_t idb_source = { 0 };\n            idb_source.interface_id = i;\n            g_rw_lock_writer_lock (&ld->saved_shb_idb_lock);\n            pcap_src->idb_id = global_ld.saved_idbs->len;\n            g_array_append_val(global_ld.saved_idbs, idb_source);\n            g_rw_lock_writer_unlock (&ld->saved_shb_idb_lock);\n            ws_debug(\"%s: saved capture_opts %u to IDB %u\",\n                  G_STRFUNC, i, pcap_src->idb_id);\n        }\n    }\n\n    /*\n     * Are we capturing from one source that is providing pcapng\n     * information?\n     */\n    if (capture_opts->ifaces->len == 1 && pcapng_src_count == 1) {\n        /*\n         * Yes; pass through SHBs and IDBs from the source, rather\n         * than generating our own.\n         */\n        ld->pcapng_passthrough = true;\n        g_rw_lock_writer_lock (&ld->saved_shb_idb_lock);\n        ws_assert(global_ld.saved_idbs->len == 0);\n        ws_debug(\"%s: Pass through SHBs and IDBs directly\", G_STRFUNC);\n        g_rw_lock_writer_unlock (&ld->saved_shb_idb_lock);\n    }\n\n    /* If not using libcap: we now can now set euid/egid to ruid/rgid         */\n    /*  to remove any suid privileges.                                        */\n    /* If using libcap: we can now remove NET_RAW and NET_ADMIN capabilities  */\n    /*  (euid/egid have already previously been set to ruid/rgid.             */\n    /* (See comment in main() for details)                                    */\n#ifndef HAVE_LIBCAP\n    relinquish_special_privs_perm();\n#else\n    relinquish_all_capabilities();\n#endif\n    return true;\n}\n\n/* close the capture input file (pcap or capture pipe) */\nstatic void capture_loop_close_input(loop_data *ld)\n{\n    unsigned     i;\n    capture_src *pcap_src;\n\n    ws_debug(\"capture_loop_close_input\");\n\n    for (i = 0; i < ld->pcaps->len; i++) {\n        pcap_src = g_array_index(ld->pcaps, capture_src *, i);\n        /* Pipe, or capture device? */\n        if (pcap_src->from_cap_pipe) {\n            /* Pipe. If open, close the capture pipe \"input file\". */\n            if (pcap_src->cap_pipe_fd >= 0) {\n                cap_pipe_close(pcap_src->cap_pipe_fd, pcap_src->from_cap_socket);\n                pcap_src->cap_pipe_fd = -1;\n            }\n#ifdef _WIN32\n            if (pcap_src->cap_pipe_h != INVALID_HANDLE_VALUE) {\n                CloseHandle(pcap_src->cap_pipe_h);\n                pcap_src->cap_pipe_h = INVALID_HANDLE_VALUE;\n            }\n#endif\n            if (pcap_src->cap_pipe_databuf != NULL) {\n                /* Free the buffer. */\n                g_free(pcap_src->cap_pipe_databuf);\n                pcap_src->cap_pipe_databuf = NULL;\n            }\n            if (pcap_src->from_pcapng) {\n                g_array_free(pcap_src->cap_pipe_info.pcapng.src_iface_to_global, TRUE);\n                pcap_src->cap_pipe_info.pcapng.src_iface_to_global = NULL;\n            }\n        } else {\n            /* Capture device.  If open, close the pcap_t. */\n            if (pcap_src->pcap_h != NULL) {\n                ws_debug(\"capture_loop_close_input: closing %p\", (void *)pcap_src->pcap_h);\n                pcap_close(pcap_src->pcap_h);\n                pcap_src->pcap_h = NULL;\n            }\n        }\n    }\n\n    ld->go = false;\n}\n\n\n/* init the capture filter */\nstatic initfilter_status_t\ncapture_loop_init_filter(pcap_t *pcap_h, bool from_cap_pipe,\n                         const char * name, const char * cfilter)\n{\n    struct bpf_program fcode;\n\n    ws_debug(\"capture_loop_init_filter: %s\", cfilter);\n\n    /* capture filters only work on real interfaces */\n    if (cfilter && !from_cap_pipe) {\n        /* A capture filter was specified; set it up. */\n        if (!compile_capture_filter(name, pcap_h, &fcode, cfilter)) {\n            /* Treat this specially - our caller might try to compile this\n               as a display filter and, if that succeeds, warn the user that\n               the display and capture filter syntaxes are different. */\n            return INITFILTER_BAD_FILTER;\n        }\n        if (pcap_setfilter(pcap_h, &fcode) < 0) {\n            pcap_freecode(&fcode);\n            return INITFILTER_OTHER_ERROR;\n        }\n        pcap_freecode(&fcode);\n    }\n\n    return INITFILTER_NO_ERROR;\n}\n\n/*\n * Write the dumpcap pcapng SHB and IDBs if needed.\n * Called from capture_loop_init_output and do_file_switch_or_stop.\n */\nstatic bool\ncapture_loop_init_pcapng_output(capture_options *capture_opts, loop_data *ld,\n                                int *err)\n{\n    g_rw_lock_reader_lock (&ld->saved_shb_idb_lock);\n\n    if (ld->pcapng_passthrough && !ld->saved_shb) {\n        /* We have a single pcapng capture interface and this is the first or only output file. */\n        ws_debug(\"%s: skipping dumpcap SHB and IDBs in favor of source\", G_STRFUNC);\n        g_rw_lock_reader_unlock (&ld->saved_shb_idb_lock);\n        return true;\n    }\n\n    bool successful = true;\n    GString *os_info_str = g_string_new(\"\");\n\n    *err = 0;\n    get_os_version_info(os_info_str);\n\n    if (ld->saved_shb) {\n        /* We have a single pcapng capture interface and multiple output files. */\n\n        pcapng_block_header_t bh;\n\n        memcpy(&bh, ld->saved_shb, sizeof(pcapng_block_header_t));\n\n        successful = pcapng_write_block(ld->pdh, ld->saved_shb, bh.block_total_length, &ld->bytes_written, err);\n\n        ws_debug(\"%s: wrote saved passthrough SHB %d\", G_STRFUNC, successful);\n    } else {\n        GString *cpu_info_str = g_string_new(\"\");\n        get_cpu_info(cpu_info_str);\n\n        successful = pcapng_write_section_header_block(ld->pdh,\n                                                       capture_comments,   /* Comments */\n                                                       cpu_info_str->str,           /* HW */\n                                                       os_info_str->str,            /* OS */\n                                                       get_appname_and_version(),\n                                                       -1,                          /* section_length */\n                                                       &ld->bytes_written,\n                                                       err);\n        ws_debug(\"%s: wrote dumpcap SHB %d\", G_STRFUNC, successful);\n        g_string_free(cpu_info_str, TRUE);\n    }\n\n    for (unsigned i = 0; successful && (i < ld->saved_idbs->len); i++) {\n        saved_idb_t idb_source = g_array_index(ld->saved_idbs, saved_idb_t, i);\n        if (idb_source.deleted) {\n            /*\n             * Our interface is out of scope. Suppose we're writing multiple\n             * files and a source switches sections. We currently write dummy\n             * IDBs like so:\n             *\n             * File 1: IDB0, IDB1, IDB2\n             * [ The source of IDBs 1 and 2 writes an SHB with two new IDBs ]\n             * [ We switch output files ]\n             * File 2: IDB0, dummy IDB, dummy IDB, IDB3, IDB4\n             *\n             * It might make more sense to write the original data so that\n             * so that our IDB lists are more consistent across files.\n             */\n            successful = pcapng_write_interface_description_block(global_ld.pdh,\n                                                                  \"Interface went out of scope\",    /* OPT_COMMENT       1 */\n                                                                  \"dummy\",                          /* IDB_NAME          2 */\n                                                                  \"Dumpcap dummy interface\",        /* IDB_DESCRIPTION   3 */\n                                                                  NULL,                             /* IDB_FILTER       11 */\n                                                                  os_info_str->str,                 /* IDB_OS           12 */\n                                                                  NULL,                             /* IDB_HARDWARE     15 */\n                                                                  -1,\n                                                                  0,\n                                                                  &(global_ld.bytes_written),\n                                                                  0,                                /* IDB_IF_SPEED      8 */\n                                                                  6,                                /* IDB_TSRESOL       9 */\n                                                                  &global_ld.err);\n            ws_debug(\"%s: skipping deleted pcapng IDB %u\", G_STRFUNC, i);\n        } else if (idb_source.idb && idb_source.idb_len) {\n            successful = pcapng_write_block(global_ld.pdh, idb_source.idb, idb_source.idb_len, &ld->bytes_written, err);\n            ws_debug(\"%s: wrote pcapng IDB %d\", G_STRFUNC, successful);\n        } else if (idb_source.interface_id < capture_opts->ifaces->len) {\n            unsigned if_id = idb_source.interface_id;\n            interface_options *interface_opts = &g_array_index(capture_opts->ifaces, interface_options, if_id);\n            capture_src *pcap_src = g_array_index(ld->pcaps, capture_src *, if_id);\n            if (pcap_src->from_cap_pipe) {\n                pcap_src->snaplen = pcap_src->cap_pipe_info.pcap.hdr.snaplen;\n            } else {\n                pcap_src->snaplen = pcap_snapshot(pcap_src->pcap_h);\n            }\n            successful = pcapng_write_interface_description_block(global_ld.pdh,\n                                                                   NULL,                       /* OPT_COMMENT       1 */\n                                                                  (interface_opts->ifname != NULL) ? interface_opts->ifname : interface_opts->name, /* IDB_NAME          2 */\n                                                                  interface_opts->descr,      /* IDB_DESCRIPTION   3 */\n                                                                  interface_opts->cfilter,    /* IDB_FILTER       11 */\n                                                                  os_info_str->str,           /* IDB_OS           12 */\n                                                                  interface_opts->hardware,   /* IDB_HARDWARE     15 */\n                                                                  pcap_src->linktype,\n                                                                  pcap_src->snaplen,\n                                                                  &(global_ld.bytes_written),\n                                                                  0,                          /* IDB_IF_SPEED      8 */\n                                                                  pcap_src->ts_nsec ? 9 : 6,  /* IDB_TSRESOL       9 */\n                                                                  &global_ld.err);\n            ws_debug(\"%s: wrote capture_opts IDB %d: %d\", G_STRFUNC, if_id, successful);\n        }\n    }\n    g_rw_lock_reader_unlock (&ld->saved_shb_idb_lock);\n\n    g_string_free(os_info_str, TRUE);\n\n    return successful;\n}\n\n/* set up to write to the already-opened capture output file/files */\nstatic bool\ncapture_loop_init_output(capture_options *capture_opts, loop_data *ld, char *errmsg, int errmsg_len)\n{\n    int err = 0;\n\n    ws_debug(\"capture_loop_init_output\");\n\n    if ((capture_opts->use_pcapng == false) &&\n        (capture_opts->ifaces->len > 1)) {\n        snprintf(errmsg, errmsg_len,\n                   \"Using PCAPNG is required for capturing on multiple interfaces. Use the -n option.\");\n        return false;\n    }\n\n    /* Set up to write to the capture file. */\n    if (capture_opts->multi_files_on) {\n        ld->pdh = ringbuf_init_libpcap_fdopen(&err);\n    } else {\n        ld->pdh = ws_fdopen(ld->save_file_fd, \"wb\");\n        if (ld->pdh == NULL) {\n            err = errno;\n        } else {\n            size_t buffsize = IO_BUF_SIZE;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n            ws_statb64 statb;\n\n            if (ws_fstat64(ld->save_file_fd, &statb) == 0) {\n                if (statb.st_blksize > IO_BUF_SIZE) {\n                    buffsize = statb.st_blksize;\n                }\n            }\n#endif\n            /* Increase the size of the IO buffer */\n            ld->io_buffer = (char *)g_malloc(buffsize);\n            setvbuf(ld->pdh, ld->io_buffer, _IOFBF, buffsize);\n            ws_debug(\"capture_loop_init_output: buffsize %zu\", buffsize);\n        }\n    }\n    if (ld->pdh) {\n        bool successful;\n        if (capture_opts->use_pcapng) {\n            successful = capture_loop_init_pcapng_output(capture_opts, ld, &err);\n        } else {\n            capture_src *pcap_src;\n            pcap_src = g_array_index(ld->pcaps, capture_src *, 0);\n            if (pcap_src->from_cap_pipe) {\n                pcap_src->snaplen = pcap_src->cap_pipe_info.pcap.hdr.snaplen;\n            } else {\n                pcap_src->snaplen = pcap_snapshot(pcap_src->pcap_h);\n            }\n            successful = libpcap_write_file_header(ld->pdh, pcap_src->linktype, pcap_src->snaplen,\n                                                pcap_src->ts_nsec, &ld->bytes_written, &err);\n        }\n        if (!successful) {\n            fclose(ld->pdh);\n            ld->pdh = NULL;\n            g_free(ld->io_buffer);\n            ld->io_buffer = NULL;\n        }\n    }\n\n    if (ld->pdh == NULL) {\n        /* We couldn't set up to write to the capture file. */\n        /* XXX - use cf_open_error_message from tshark instead? */\n        if (err < 0) {\n            snprintf(errmsg, errmsg_len,\n                       \"The file to which the capture would be\"\n                       \" saved (\\\"%s\\\") could not be opened: Error %d.\",\n                       capture_opts->save_file, err);\n        } else {\n            snprintf(errmsg, errmsg_len,\n                       \"The file to which the capture would be\"\n                       \" saved (\\\"%s\\\") could not be opened: %s.\",\n                       capture_opts->save_file, g_strerror(err));\n        }\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool\ncapture_loop_close_output(capture_options *capture_opts, loop_data *ld, int *err_close)\n{\n\n    unsigned int i;\n    capture_src *pcap_src;\n    uint64_t     end_time = create_timestamp();\n    bool success;\n\n    ws_debug(\"capture_loop_close_output\");\n\n    if (capture_opts->multi_files_on) {\n        return ringbuf_libpcap_dump_close(&capture_opts->save_file, err_close);\n    } else {\n        if (capture_opts->use_pcapng) {\n            for (i = 0; i < global_ld.pcaps->len; i++) {\n                pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);\n                if (!pcap_src->from_cap_pipe) {\n                    uint64_t isb_ifrecv, isb_ifdrop;\n                    struct pcap_stat stats;\n\n                    if (pcap_stats(pcap_src->pcap_h, &stats) >= 0) {\n                        isb_ifrecv = pcap_src->received;\n                        isb_ifdrop = stats.ps_drop + pcap_src->dropped + pcap_src->flushed;\n                   } else {\n                        isb_ifrecv = UINT64_MAX;\n                        isb_ifdrop = UINT64_MAX;\n                    }\n                    pcapng_write_interface_statistics_block(ld->pdh,\n                                                            i,\n                                                            &ld->bytes_written,\n                                                            \"Counters provided by dumpcap\",\n                                                            start_time,\n                                                            end_time,\n                                                            isb_ifrecv,\n                                                            isb_ifdrop,\n                                                            err_close);\n                }\n            }\n        }\n        if (fclose(ld->pdh) == EOF) {\n            if (err_close != NULL) {\n                *err_close = errno;\n            }\n            success = false;\n        } else {\n            success = true;\n        }\n        g_free(ld->io_buffer);\n        ld->io_buffer = NULL;\n        return success;\n    }\n}\n\n/* dispatch incoming packets (pcap or capture pipe)\n *\n * Waits for incoming packets to be available, and calls pcap_dispatch()\n * to cause them to be processed.\n *\n * Returns the number of packets which were processed.\n *\n * Times out (returning zero) after CAP_READ_TIMEOUT ms; this ensures that the\n * packet-batching behaviour does not cause packets to get held back\n * indefinitely.\n */\nstatic int\ncapture_loop_dispatch(loop_data *ld,\n                      char *errmsg, int errmsg_len, capture_src *pcap_src)\n{\n    int    inpkts = 0;\n    int    packet_count_before;\n    int    sel_ret;\n\n    packet_count_before = ld->packets_captured;\n    if (pcap_src->from_cap_pipe) {\n        /* dispatch from capture pipe */\n#ifdef LOG_CAPTURE_VERBOSE\n        ws_debug(\"capture_loop_dispatch: from capture pipe\");\n#endif\n#ifdef _WIN32\n        if (pcap_src->from_cap_socket) {\n#endif\n            sel_ret = cap_pipe_select(pcap_src->cap_pipe_fd);\n            if (sel_ret <= 0) {\n                if (sel_ret < 0 && errno != EINTR) {\n                    snprintf(errmsg, errmsg_len,\n                            \"Unexpected error from select: %s\", g_strerror(errno));\n                    report_capture_error(errmsg, please_report_bug());\n                    ld->go = false;\n                }\n            }\n#ifdef _WIN32\n        } else {\n            /* Windows does not have select() for pipes. */\n            /* Proceed with _dispatch() which waits for cap_pipe_done_q\n             * notification from cap_thread_read() when ReadFile() on\n             * the pipe has read enough bytes. */\n            sel_ret = 1;\n        }\n#endif\n        if (sel_ret > 0) {\n            /*\n             * \"select()\" says we can read from the pipe without blocking\n             */\n            inpkts = pcap_src->cap_pipe_dispatch(ld, pcap_src, errmsg, errmsg_len);\n            if (inpkts < 0) {\n                ws_debug(\"%s: src %u pipe reached EOF or err, rcv: %u drop: %u flush: %u\",\n                      G_STRFUNC, pcap_src->interface_id, pcap_src->received, pcap_src->dropped, pcap_src->flushed);\n                ws_assert(pcap_src->cap_pipe_err != PIPOK);\n            }\n        }\n    }\n    else\n    {\n        /* dispatch from pcap */\n#ifdef MUST_DO_SELECT\n        /*\n         * If we have \"pcap_get_selectable_fd()\", we use it to get the\n         * descriptor on which to select; if that's -1, it means there\n         * is no descriptor on which you can do a \"select()\" (perhaps\n         * because you're capturing on a special device, and that device's\n         * driver unfortunately doesn't support \"select()\", in which case\n         * we don't do the select - which means it might not be possible\n         * to stop a capture until a packet arrives.  If that's unacceptable,\n         * plead with whoever supplies the software for that device to add\n         * \"select()\" support, or upgrade to libpcap 0.8.1 or later, and\n         * rebuild Wireshark or get a version built with libpcap 0.8.1 or\n         * later, so it can use pcap_breakloop().\n         */\n#ifdef LOG_CAPTURE_VERBOSE\n        ws_debug(\"capture_loop_dispatch: from pcap_dispatch with select\");\n#endif\n        if (pcap_src->pcap_fd != -1) {\n            sel_ret = cap_pipe_select(pcap_src->pcap_fd);\n            if (sel_ret > 0) {\n                /*\n                 * \"select()\" says we can read from it without blocking; go for\n                 * it.\n                 *\n                 * We don't have pcap_breakloop(), so we only process one packet\n                 * per pcap_dispatch() call, to allow a signal to stop the\n                 * processing immediately, rather than processing all packets\n                 * in a batch before quitting.\n                 */\n                if (use_threads) {\n                    inpkts = pcap_dispatch(pcap_src->pcap_h, 1, capture_loop_queue_packet_cb, (uint8_t *)pcap_src);\n                } else {\n                    inpkts = pcap_dispatch(pcap_src->pcap_h, 1, capture_loop_write_packet_cb, (uint8_t *)pcap_src);\n                }\n                if (inpkts < 0) {\n                    if (inpkts == -1) {\n                        /* Error, rather than pcap_breakloop(). */\n                        pcap_src->pcap_err = true;\n                    }\n                    ld->go = false; /* error or pcap_breakloop() - stop capturing */\n                }\n            } else {\n                if (sel_ret < 0 && errno != EINTR) {\n                    snprintf(errmsg, errmsg_len,\n                               \"Unexpected error from select: %s\", g_strerror(errno));\n                    report_capture_error(errmsg, please_report_bug());\n                    ld->go = false;\n                }\n            }\n        }\n        else\n#endif /* MUST_DO_SELECT */\n        {\n            /* dispatch from pcap without select */\n#if 1\n#ifdef LOG_CAPTURE_VERBOSE\n            ws_debug(\"capture_loop_dispatch: from pcap_dispatch\");\n#endif\n#ifdef _WIN32\n            /*\n             * On Windows, we don't support asynchronously telling a process to\n             * stop capturing; instead, we check for an indication on a pipe\n             * after processing packets.  We therefore process only one packet\n             * at a time, so that we can check the pipe after every packet.\n             */\n            if (use_threads) {\n                inpkts = pcap_dispatch(pcap_src->pcap_h, 1, capture_loop_queue_packet_cb, (uint8_t *)pcap_src);\n            } else {\n                inpkts = pcap_dispatch(pcap_src->pcap_h, 1, capture_loop_write_packet_cb, (uint8_t *)pcap_src);\n            }\n#else\n            if (use_threads) {\n                inpkts = pcap_dispatch(pcap_src->pcap_h, -1, capture_loop_queue_packet_cb, (uint8_t *)pcap_src);\n            } else {\n                inpkts = pcap_dispatch(pcap_src->pcap_h, -1, capture_loop_write_packet_cb, (uint8_t *)pcap_src);\n            }\n#endif\n            if (inpkts < 0) {\n                if (inpkts == -1) {\n                    /* Error, rather than pcap_breakloop(). */\n                    pcap_src->pcap_err = true;\n                }\n                ld->go = false; /* error or pcap_breakloop() - stop capturing */\n            }\n#else /* pcap_next_ex */\n#ifdef LOG_CAPTURE_VERBOSE\n            ws_debug(\"capture_loop_dispatch: from pcap_next_ex\");\n#endif\n            /* XXX - this is currently unused, as there is some confusion with pcap_next_ex() vs. pcap_dispatch() */\n\n            /*\n             * WinPcap's remote capturing feature doesn't work with pcap_dispatch(),\n             * see https://gitlab.com/wireshark/wireshark/-/wikis/CaptureSetup/WinPcapRemote\n             * This should be fixed in the WinPcap 4.0 alpha release.\n             *\n             * For reference, an example remote interface:\n             * rpcap://[1.2.3.4]/\\Device\\NPF_{39993D68-7C9B-4439-A329-F2D888DA7C5C}\n             */\n\n            /* emulate dispatch from pcap */\n            {\n                int in;\n                struct pcap_pkthdr *pkt_header;\n                uint8_t *pkt_data;\n\n                in = 0;\n                while(ld->go &&\n                      (in = pcap_next_ex(pcap_src->pcap_h, &pkt_header, &pkt_data)) == 1) {\n                    if (use_threads) {\n                        capture_loop_queue_packet_cb((uint8_t *)pcap_src, pkt_header, pkt_data);\n                    } else {\n                        capture_loop_write_packet_cb((uint8_t *)pcap_src, pkt_header, pkt_data);\n                    }\n                }\n\n                if (in < 0) {\n                    pcap_src->pcap_err = true;\n                    ld->go = false;\n                }\n            }\n#endif /* pcap_next_ex */\n        }\n    }\n\n#ifdef LOG_CAPTURE_VERBOSE\n    ws_debug(\"capture_loop_dispatch: %d new packet%s\", inpkts, plurality(inpkts, \"\", \"s\"));\n#endif\n\n    return ld->packets_captured - packet_count_before;\n}\n\n#ifdef _WIN32\n/* Isolate the Universally Unique Identifier from the interface.  Basically, we\n * want to grab only the characters between the '{' and '}' delimiters.\n *\n * Returns a GString that must be freed with g_string_free(). */\nstatic GString *\nisolate_uuid(const char *iface)\n{\n    char    *ptr;\n    GString *gstr;\n\n    ptr = strchr(iface, '{');\n    if (ptr == NULL)\n        return g_string_new(iface);\n    gstr = g_string_new(ptr + 1);\n\n    ptr = strchr(gstr->str, '}');\n    if (ptr == NULL)\n        return gstr;\n\n    gstr = g_string_truncate(gstr, ptr - gstr->str);\n    return gstr;\n}\n#endif\n\n/* open the output file (temporary/specified name/ringbuffer/named pipe/stdout) */\n/* Returns true if the file opened successfully, false otherwise. */\nstatic bool\ncapture_loop_open_output(capture_options *capture_opts, int *save_file_fd,\n                         char *errmsg, int errmsg_len)\n{\n    char     *capfile_name = NULL;\n    char     *prefix, *suffix;\n    bool      is_tempfile;\n    GError   *err_tempfile = NULL;\n\n    ws_debug(\"capture_loop_open_output: %s\",\n          (capture_opts->save_file) ? capture_opts->save_file : \"(not specified)\");\n\n    if (capture_opts->save_file != NULL) {\n        /* We return to the caller while the capture is in progress.\n         * Therefore we need to take a copy of save_file in\n         * case the caller destroys it after we return.\n         */\n        capfile_name = g_strdup(capture_opts->save_file);\n\n        if (capture_opts->output_to_pipe == true) { /* either \"-\" or named pipe */\n            if (capture_opts->multi_files_on) {\n                /* ringbuffer is enabled; that doesn't work with standard output or a named pipe */\n                snprintf(errmsg, errmsg_len,\n                           \"Ring buffer requested, but capture is being written to standard output or to a named pipe.\");\n                g_free(capfile_name);\n                return false;\n            }\n            if (strcmp(capfile_name, \"-\") == 0) {\n                /* write to stdout */\n                *save_file_fd = 1;\n#ifdef _WIN32\n                /* set output pipe to binary mode to avoid Windows text-mode processing (eg: for CR/LF)  */\n                _setmode(1, O_BINARY);\n#endif\n            } else {\n                /* Try to open the specified FIFO for use as a capture buffer.\n                   Do *not* create it if it doesn't exist.  There's nothing\n                   to truncate. If we need to read it, We Have A Problem. */\n                *save_file_fd = ws_open(capfile_name, O_WRONLY|O_BINARY, 0);\n            }\n        } /* if (...output_to_pipe ... */\n\n        else {\n            if (capture_opts->multi_files_on) {\n                /* ringbuffer is enabled */\n                *save_file_fd = ringbuf_init(capfile_name,\n                                             (capture_opts->has_ring_num_files) ? capture_opts->ring_num_files : 0,\n                                             capture_opts->group_read_access,\n                                             capture_opts->compress_type,\n                                             capture_opts->has_nametimenum);\n\n                /* capfile_name is unused as the ringbuffer provides its own filename. */\n                if (*save_file_fd != -1) {\n                    g_free(capfile_name);\n                    capfile_name = NULL;\n                }\n                if (capture_opts->print_file_names) {\n                    if (!ringbuf_set_print_name(capture_opts->print_name_to, NULL)) {\n                        snprintf(errmsg, errmsg_len, \"Could not write filenames to %s: %s.\\n\",\n                                   capture_opts->print_name_to,\n                                   g_strerror(errno));\n                        g_free(capfile_name);\n                        ringbuf_error_cleanup();\n                        return false;\n                    }\n                }\n            } else {\n                /* Try to open/create the specified file for use as a capture buffer. */\n                *save_file_fd = ws_open(capfile_name, O_WRONLY|O_BINARY|O_TRUNC|O_CREAT,\n                                        (capture_opts->group_read_access) ? 0640 : 0600);\n            }\n        }\n        is_tempfile = false;\n    } else {\n        /* Choose a random name for the temporary capture buffer */\n        if (global_capture_opts.ifaces->len > 1) {\n            /*\n             * More than one interface; just use the number of interfaces\n             * to generate the temporary file name prefix.\n             */\n            prefix = ws_strdup_printf(\"wireshark_%d_interfaces\", global_capture_opts.ifaces->len);\n        } else {\n            /*\n             * One interface; use its description, if it has one, to generate\n             * the temporary file name, otherwise use its name.\n             */\n            char *basename;\n            const interface_options *interface_opts;\n\n            interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, 0);\n\n            /*\n             * Do we have a description?\n             */\n            if (interface_opts->descr) {\n                /*\n                 * Yes - use it.\n                 *\n                 * Strip off any stuff we shouldn't use in the file name,\n                 * by getting the last component of what would be a file\n                 * name.\n                 */\n                basename = g_path_get_basename(interface_opts->descr);\n            } else {\n                /*\n                 * No - use the name.\n                 *\n                 * Strip off any stuff we shouldn't use in the file name,\n                 * by getting the last component of what would be a file\n                 * name.\n                 */\n                basename = g_path_get_basename(interface_opts->name);\n#ifdef _WIN32\n                /*\n                 * This is Windows, where we might have an ugly GUID-based\n                 * interface name.\n                 *\n                 * If it's an ugly GUID-based name, use the generic portion\n                 * of the interface GUID to form the basis of the filename.\n                 */\n                if (strncmp(\"NPF_{\", basename, 5) == 0) {\n                    /*\n                     * We have a GUID-based name; extract the GUID digits\n                     * as the basis of the filename.\n                     */\n                    GString *iface;\n                    iface = isolate_uuid(basename);\n                    g_free(basename);\n                    basename = g_strdup(iface->str);\n                    g_string_free(iface, TRUE);\n                }\n#endif\n            }\n            /* generate the temp file name prefix */\n            prefix = g_strconcat(\"wireshark_\", basename, NULL);\n            g_free(basename);\n        }\n\n        /* Generate the appropriate suffix. */\n        if (capture_opts->use_pcapng) {\n            suffix = \".pcapng\";\n        } else {\n            suffix = \".pcap\";\n        }\n        *save_file_fd = create_tempfile(capture_opts->temp_dir, &capfile_name, prefix, suffix, &err_tempfile);\n        g_free(prefix);\n        is_tempfile = true;\n    }\n\n    /* did we fail to open the output file? */\n    if (*save_file_fd == -1) {\n        if (is_tempfile) {\n            snprintf(errmsg, errmsg_len,\n                       \"The temporary file to which the capture would be saved \"\n                       \"could not be opened: %s.\", err_tempfile->message);\n            g_error_free(err_tempfile);\n        } else {\n            if (capture_opts->multi_files_on) {\n                /* Ensures that the ringbuffer is not used. This ensures that\n                 * !ringbuf_is_initialized() is equivalent to\n                 * capture_opts->save_file not being part of ringbuffer. */\n                ringbuf_error_cleanup();\n            }\n\n            snprintf(errmsg, errmsg_len,\n                       \"The file to which the capture would be saved (\\\"%s\\\") \"\n                       \"could not be opened: %s.\", capfile_name,\n                       g_strerror(errno));\n        }\n        g_free(capfile_name);\n        return false;\n    }\n\n    g_free(capture_opts->save_file);\n    if (!is_tempfile && capture_opts->multi_files_on) {\n        /* In ringbuffer mode, save_file points to a filename from ringbuffer.c.\n         * capfile_name was already freed before. */\n        capture_opts->save_file = (char *)ringbuf_current_filename();\n    } else {\n        /* capture_opts_cleanup will g_free(capture_opts->save_file). */\n        capture_opts->save_file = capfile_name;\n    }\n\n    return true;\n}\n\nstatic time_t get_next_time_interval(int interval_s) {\n    time_t next_time = time(NULL);\n    next_time -= next_time % interval_s;\n    next_time += interval_s;\n    return next_time;\n}\n\n/* Do the work of handling either the file size or file duration capture\n   conditions being reached, and switching files or stopping. */\nstatic bool\ndo_file_switch_or_stop(capture_options *capture_opts)\n{\n    bool              successful;\n\n    if (capture_opts->multi_files_on) {\n        if (capture_opts->has_autostop_files &&\n            ++global_ld.file_count >= capture_opts->autostop_files) {\n            /* no files left: stop here */\n            global_ld.go = false;\n            return false;\n        }\n\n        /* Switch to the next ringbuffer file */\n        if (ringbuf_switch_file(&global_ld.pdh, &capture_opts->save_file,\n                                &global_ld.save_file_fd, &global_ld.err)) {\n\n            /* File switch succeeded: reset the conditions */\n            global_ld.bytes_written = 0;\n            global_ld.packets_written = 0;\n            if (capture_opts->use_pcapng) {\n                successful = capture_loop_init_pcapng_output(capture_opts, &global_ld, &global_ld.err);\n            } else {\n                capture_src *pcap_src;\n                pcap_src = g_array_index(global_ld.pcaps, capture_src *, 0);\n                successful = libpcap_write_file_header(global_ld.pdh, pcap_src->linktype, pcap_src->snaplen,\n                                                       pcap_src->ts_nsec, &global_ld.bytes_written, &global_ld.err);\n            }\n\n            if (!successful) {\n                fclose(global_ld.pdh);\n                global_ld.pdh = NULL;\n                global_ld.go = false;\n                g_free(global_ld.io_buffer);\n                global_ld.io_buffer = NULL;\n                return false;\n            }\n            if (global_ld.file_duration_timer) {\n                g_timer_reset(global_ld.file_duration_timer);\n            }\n            if (global_ld.next_interval_time) {\n                global_ld.next_interval_time = get_next_time_interval(global_ld.interval_s);\n            }\n            fflush(global_ld.pdh);\n            if (global_ld.inpkts_to_sync_pipe) {\n                if (!quiet)\n                    report_packet_count(global_ld.inpkts_to_sync_pipe);\n                global_ld.inpkts_to_sync_pipe = 0;\n            }\n            report_new_capture_file(capture_opts->save_file);\n        } else {\n            /* File switch failed: stop here */\n            global_ld.go = false;\n            return false;\n        }\n    } else {\n        /* single file, stop now */\n        global_ld.go = false;\n        return false;\n    }\n    return true;\n}\n\nstatic void *\npcap_read_handler(void* arg)\n{\n    capture_src *pcap_src = (capture_src *)arg;\n    char         errmsg[MSG_MAX_LENGTH+1];\n\n    ws_info(\"Started thread for interface %d.\", pcap_src->interface_id);\n\n    /* If this is a pipe input it might finish early. */\n    while (global_ld.go && pcap_src->cap_pipe_err == PIPOK) {\n        /* dispatch incoming packets */\n        capture_loop_dispatch(&global_ld, errmsg, sizeof(errmsg), pcap_src);\n    }\n\n    ws_info(\"Stopped thread for interface %d.\", pcap_src->interface_id);\n    g_thread_exit(NULL);\n    return (NULL);\n}\n\n/* Try to pop an item off the packet queue and if it exists, write it */\nstatic bool\ncapture_loop_dequeue_packet(void) {\n    pcap_queue_element *queue_element;\n\n    g_async_queue_lock(pcap_queue);\n    queue_element = (pcap_queue_element *)g_async_queue_timeout_pop_unlocked(pcap_queue, WRITER_THREAD_TIMEOUT);\n    if (queue_element) {\n        if (queue_element->pcap_src->from_pcapng) {\n            pcap_queue_bytes -= queue_element->u.bh.block_total_length;\n        } else {\n            pcap_queue_bytes -= queue_element->u.phdr.caplen;\n        }\n        pcap_queue_packets -= 1;\n    }\n    g_async_queue_unlock(pcap_queue);\n    if (queue_element) {\n        if (queue_element->pcap_src->from_pcapng) {\n            ws_info(\"Dequeued a block of type 0x%08x of length %d captured on interface %d.\",\n                  queue_element->u.bh.block_type, queue_element->u.bh.block_total_length,\n                  queue_element->pcap_src->interface_id);\n\n            capture_loop_write_pcapng_cb(queue_element->pcap_src,\n                                        &queue_element->u.bh,\n                                        queue_element->pd);\n        } else {\n            ws_info(\"Dequeued a packet of length %d captured on interface %d.\",\n                queue_element->u.phdr.caplen, queue_element->pcap_src->interface_id);\n\n            capture_loop_write_packet_cb((uint8_t *) queue_element->pcap_src,\n                                        &queue_element->u.phdr,\n                                        queue_element->pd);\n        }\n        g_free(queue_element->pd);\n        g_free(queue_element);\n        return true;\n    }\n    return false;\n}\n\n/*\n * Note: this code will never be run on any OS other than Windows.\n *\n * We keep the arguments in case there's something in the future\n * that needs to be reported as an NPCAP bug.\n */\nstatic char *\nhandle_npcap_bug(char *adapter_name _U_, char *cap_err_str _U_)\n{\n    bool have_npcap = false;\n\n#ifdef _WIN32\n    have_npcap = caplibs_have_npcap();\n#endif\n\n    if (!have_npcap) {\n        /*\n         * We're not using Npcap, so don't recommend a user\n         * file a bug against Npcap.\n         */\n        return g_strdup(\"\");\n    }\n\n    return ws_strdup_printf(\"If you have not removed that adapter, this \"\n                          \"is probably a known issue in Npcap resulting from \"\n                          \"the behavior of the Windows networking stack. \"\n                          \"Work is being done in Npcap to improve the \"\n                          \"handling of this issue; it does not need to \"\n                          \"be reported as a Wireshark or Npcap bug.\");\n}\n\n/* Do the low-level work of a capture.\n   Returns true if it succeeds, false otherwise. */\nstatic bool\ncapture_loop_start(capture_options *capture_opts, bool *stats_known, struct pcap_stat *stats)\n{\n#ifdef _WIN32\n    ULONGLONG         upd_time, cur_time; /* GetTickCount64() returns a \"ULONGLONG\" */\n#else\n    struct timeval    upd_time, cur_time;\n#endif\n    int               err_close;\n    int               inpkts;\n    GTimer           *autostop_duration_timer = NULL;\n    bool              write_ok;\n    bool              close_ok;\n    bool              cfilter_error         = false;\n    char              errmsg[MSG_MAX_LENGTH+1];\n    char              secondary_errmsg[MSG_MAX_LENGTH+1];\n    capture_src      *pcap_src;\n    interface_options *interface_opts;\n    unsigned          i, error_index        = 0;\n\n    *errmsg           = '\\0';\n    *secondary_errmsg = '\\0';\n\n    /* init the loop data */\n    global_ld.go                  = true;\n    global_ld.packets_captured    = 0;\n#ifdef SIGINFO\n    global_ld.report_packet_count = false;\n#endif\n    global_ld.inpkts_to_sync_pipe = 0;\n    global_ld.err                 = 0;  /* no error seen yet */\n    global_ld.pdh                 = NULL;\n    global_ld.save_file_fd        = -1;\n    global_ld.io_buffer           = NULL;\n    global_ld.file_count          = 0;\n    global_ld.file_duration_timer = NULL;\n    global_ld.next_interval_time  = 0;\n    global_ld.interval_s          = 0;\n\n    /* We haven't yet gotten the capture statistics. */\n    *stats_known      = false;\n\n    ws_info(\"Capture loop starting ...\");\n    capture_opts_log(LOG_DOMAIN_CAPCHILD, LOG_LEVEL_DEBUG, capture_opts);\n\n    /* open the \"input file\" from network interface or capture pipe */\n    if (!capture_loop_open_input(capture_opts, &global_ld, errmsg, sizeof(errmsg),\n                                 secondary_errmsg, sizeof(secondary_errmsg))) {\n        goto error;\n    }\n    for (i = 0; i < capture_opts->ifaces->len; i++) {\n        pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);\n        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);\n        /* init the input filter from the network interface (capture pipe will do nothing) */\n        /*\n         * When remote capturing WinPCap crashes when the capture filter\n         * is NULL. This might be a bug in WPCap. Therefore we provide an empty\n         * string.\n         */\n        switch (capture_loop_init_filter(pcap_src->pcap_h, pcap_src->from_cap_pipe,\n                                         interface_opts->name,\n                                         interface_opts->cfilter?interface_opts->cfilter:\"\")) {\n\n        case INITFILTER_NO_ERROR:\n            break;\n\n        case INITFILTER_BAD_FILTER:\n            cfilter_error = true;\n            error_index = i;\n            snprintf(errmsg, sizeof(errmsg), \"%s\", pcap_geterr(pcap_src->pcap_h));\n            goto error;\n\n        case INITFILTER_OTHER_ERROR:\n            snprintf(errmsg, sizeof(errmsg), \"Can't install filter (%s).\",\n                       pcap_geterr(pcap_src->pcap_h));\n            snprintf(secondary_errmsg, sizeof(secondary_errmsg), \"%s\", please_report_bug());\n            goto error;\n        }\n    }\n\n    /* If we're supposed to write to a capture file, open it for output\n       (temporary/specified name/ringbuffer) */\n    if (capture_opts->saving_to_file) {\n        if (!capture_loop_open_output(capture_opts, &global_ld.save_file_fd,\n                                      errmsg, sizeof(errmsg))) {\n            goto error;\n        }\n\n        /* set up to write to the already-opened capture output file/files */\n        if (!capture_loop_init_output(capture_opts, &global_ld, errmsg,\n                                      sizeof(errmsg))) {\n            goto error;\n        }\n\n        /* XXX - capture SIGTERM and close the capture, in case we're on a\n           Linux 2.0[.x] system and you have to explicitly close the capture\n           stream in order to turn promiscuous mode off?  We need to do that\n           in other places as well - and I don't think that works all the\n           time in any case, due to libpcap bugs. */\n\n        /* Well, we should be able to start capturing.\n\n           Sync out the capture file, so the header makes it to the file system,\n           and send a \"capture started successfully and capture file created\"\n           message to our parent so that they'll open the capture file and\n           update its windows to indicate that we have a live capture in\n           progress. */\n        fflush(global_ld.pdh);\n        report_new_capture_file(capture_opts->save_file);\n    }\n\n    if (capture_opts->has_file_interval) {\n        global_ld.interval_s = capture_opts->file_interval;\n        global_ld.next_interval_time = get_next_time_interval(global_ld.interval_s);\n    }\n    /* create stop conditions */\n    if (capture_opts->has_autostop_filesize) {\n        if (capture_opts->autostop_filesize > UINT32_C(2000000000)) {\n            capture_opts->autostop_filesize = UINT32_C(2000000000);\n        }\n    }\n    if (capture_opts->has_autostop_duration) {\n        autostop_duration_timer = g_timer_new();\n    }\n\n    if (capture_opts->multi_files_on) {\n        if (capture_opts->has_file_duration) {\n            global_ld.file_duration_timer = g_timer_new();\n        }\n    }\n\n    /* init the time values */\n#ifdef _WIN32\n    upd_time = GetTickCount64();\n#else\n    gettimeofday(&upd_time, NULL);\n#endif\n    start_time = create_timestamp();\n    ws_info(\"Capture loop running.\");\n    capture_opts_log(LOG_DOMAIN_CAPCHILD, LOG_LEVEL_DEBUG, capture_opts);\n\n    /* WOW, everything is prepared! */\n    /* please fasten your seat belts, we will enter now the actual capture loop */\n    if (use_threads) {\n        pcap_queue = g_async_queue_new();\n        pcap_queue_bytes = 0;\n        pcap_queue_packets = 0;\n        for (i = 0; i < global_ld.pcaps->len; i++) {\n            pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);\n            /* XXX - Add an interface name here? */\n            pcap_src->tid = g_thread_new(\"Capture read\", pcap_read_handler, pcap_src);\n        }\n    }\n    while (global_ld.go) {\n        /* dispatch incoming packets */\n        if (use_threads) {\n            bool dequeued = capture_loop_dequeue_packet();\n\n            if (dequeued) {\n                inpkts = 1;\n            } else {\n                inpkts = 0;\n            }\n        } else {\n            pcap_src = g_array_index(global_ld.pcaps, capture_src *, 0);\n            inpkts = capture_loop_dispatch(&global_ld, errmsg,\n                                           sizeof(errmsg), pcap_src);\n        }\n        if (inpkts == 0) {\n            /* Stop capturing if all of our sources are pipes and none of them are open. */\n            bool open_interfaces = false;\n            for (i = 0; i < global_ld.pcaps->len; i++) {\n                pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);\n                if (pcap_src->cap_pipe_err == PIPOK) {\n                    /* True for both non-pipes and open pipes. */\n                    open_interfaces = true;\n                }\n            }\n            if (!open_interfaces) {\n                global_ld.go = false;\n            }\n        }\n#ifdef SIGINFO\n        /* Were we asked to print packet counts by the SIGINFO handler? */\n        if (global_ld.report_packet_count) {\n            fprintf(stderr, \"%u packet%s captured\\n\", global_ld.packets_captured,\n                    plurality(global_ld.packets_captured, \"\", \"s\"));\n            global_ld.report_packet_count = false;\n        }\n#endif\n\n#ifdef _WIN32\n        /* any news from our parent (signal pipe)? -> just stop the capture */\n        if (!signal_pipe_check_running()) {\n            global_ld.go = false;\n        }\n#endif\n\n        if (inpkts > 0) {\n            if (capture_opts->output_to_pipe) {\n                fflush(global_ld.pdh);\n            }\n        } /* inpkts */\n\n        /* Only update after an interval so as not to overload slow displays.\n         * This also prevents too much context-switching between the dumpcap\n         * and wireshark processes.\n         * XXX: Should we send updates sooner if there have been lots of\n         * packets we haven't notified the parent about, such as on fast links?\n         */\n#ifdef _WIN32\n        cur_time = GetTickCount64();\n        if ((cur_time - upd_time) > capture_opts->update_interval)\n#else\n        gettimeofday(&cur_time, NULL);\n        if (((uint64_t)cur_time.tv_sec * 1000000 + cur_time.tv_usec) >\n            ((uint64_t)upd_time.tv_sec * 1000000 + upd_time.tv_usec + capture_opts->update_interval*1000))\n#endif\n        {\n\n            upd_time = cur_time;\n\n#if 0\n            if (pcap_stats(pch, stats) >= 0) {\n                *stats_known = true;\n            }\n#endif\n            /* Let the parent process know. */\n            if (global_ld.inpkts_to_sync_pipe) {\n                /* do sync here */\n                fflush(global_ld.pdh);\n\n                /* Send our parent a message saying we've written out\n                   \"global_ld.inpkts_to_sync_pipe\" packets to the capture file. */\n                if (!quiet)\n                    report_packet_count(global_ld.inpkts_to_sync_pipe);\n\n                global_ld.inpkts_to_sync_pipe = 0;\n            }\n\n            /* check capture duration condition */\n            if (autostop_duration_timer != NULL && g_timer_elapsed(autostop_duration_timer, NULL) >= capture_opts->autostop_duration) {\n                /* The maximum capture time has elapsed; stop the capture. */\n                global_ld.go = false;\n                continue;\n            }\n\n            /* check capture file duration condition */\n            if (global_ld.file_duration_timer != NULL && g_timer_elapsed(global_ld.file_duration_timer, NULL) >= capture_opts->file_duration) {\n                /* duration limit reached, do we have another file? */\n                if (!do_file_switch_or_stop(capture_opts))\n                    continue;\n            } /* cnd_file_duration */\n\n            /* check capture file interval condition */\n            if (global_ld.interval_s && time(NULL) >= global_ld.next_interval_time) {\n                /* end of interval reached, do we have another file? */\n                if (!do_file_switch_or_stop(capture_opts))\n                    continue;\n            } /* cnd_file_interval */\n        }\n    }\n\n    ws_info(\"Capture loop stopping ...\");\n    if (use_threads) {\n\n        for (i = 0; i < global_ld.pcaps->len; i++) {\n            pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);\n            ws_info(\"Waiting for thread of interface %u...\", pcap_src->interface_id);\n            g_thread_join(pcap_src->tid);\n            ws_info(\"Thread of interface %u terminated.\", pcap_src->interface_id);\n        }\n        while (1) {\n            bool dequeued = capture_loop_dequeue_packet();\n            if (!dequeued) {\n                break;\n            }\n            if (capture_opts->output_to_pipe) {\n                fflush(global_ld.pdh);\n            }\n        }\n    }\n\n\n    /* delete stop conditions */\n    if (global_ld.file_duration_timer != NULL)\n        g_timer_destroy(global_ld.file_duration_timer);\n    if (autostop_duration_timer != NULL)\n        g_timer_destroy(autostop_duration_timer);\n\n    /* did we have a pcap (input) error? */\n    for (i = 0; i < capture_opts->ifaces->len; i++) {\n        pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);\n        if (pcap_src->pcap_err) {\n            /* On Linux, if an interface goes down while you're capturing on it,\n               you'll get \"recvfrom: Network is down\".\n               (At least you will if g_strerror() doesn't show a local translation\n               of the error.)\n\n               Newer versions of libpcap maps that to just\n               \"The interface went down\".\n\n               On FreeBSD, DragonFly BSD, and macOS, if a network adapter\n               disappears while you're capturing on it, you'll get\n               \"read: Device not configured\" error (ENXIO).  (See previous\n               parenthetical note.)\n\n               On OpenBSD, you get \"read: I/O error\" (EIO) in the same case.\n\n               With WinPcap and Npcap, you'll get\n               \"read error: PacketReceivePacket failed\" or\n               \"PacketReceivePacket error: The device has been removed. (1617)\".\n\n               Newer versions of libpcap map some or all of those to just\n               \"The interface disappeared\" or something beginning with\n               \"The interface disappeared\".\n\n               These should *not* be reported to the Wireshark developers,\n               although, with Npcap, \"The interface disappeared\" messages\n               should perhaps be reported to the Npcap developers, at least\n               until errors of that sort that shouldn't happen are fixed,\n               if that's possible. */\n            char *cap_err_str;\n            char *primary_msg;\n            char *secondary_msg;\n\n            interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);\n            cap_err_str = pcap_geterr(pcap_src->pcap_h);\n            if (strcmp(cap_err_str, \"The interface went down\") == 0 ||\n                strcmp(cap_err_str, \"recvfrom: Network is down\") == 0) {\n                primary_msg = ws_strdup_printf(\"The network adapter \\\"%s\\\" \"\n                                              \"is no longer running; the \"\n                                              \"capture has stopped.\",\n                                              interface_opts->display_name);\n                secondary_msg = g_strdup(\"\");\n            } else if (strcmp(cap_err_str, \"The interface disappeared\") == 0 ||\n                       strcmp(cap_err_str, \"read: Device not configured\") == 0 ||\n                       strcmp(cap_err_str, \"read: I/O error\") == 0 ||\n                       strcmp(cap_err_str, \"read error: PacketReceivePacket failed\") == 0) {\n                primary_msg = ws_strdup_printf(\"The network adapter \\\"%s\\\" \"\n                                              \"is no longer attached; the \"\n                                              \"capture has stopped.\",\n                                              interface_opts->display_name);\n                secondary_msg = g_strdup(\"\");\n            } else if (g_str_has_prefix(cap_err_str, \"The interface disappeared \")) {\n                /*\n                 * Npcap, if it picks up a recent commit to libpcap, will\n                 * report an error *beginning* with \"The interface\n                 * disappeared\", with the name of the Windows status code,\n                 * and the corresponding NT status code, after it.\n                 *\n                 * Those should be reported as Npcap issues.\n                 */\n                primary_msg = ws_strdup_printf(\"The network adapter \\\"%s\\\" \"\n                                              \"is no longer attached; the \"\n                                              \"capture has stopped.\",\n                                              interface_opts->display_name);\n                secondary_msg = handle_npcap_bug(interface_opts->display_name,\n                                                 cap_err_str);\n            } else if (g_str_has_prefix(cap_err_str, \"PacketReceivePacket error:\") &&\n                       g_str_has_suffix(cap_err_str, \"(1617)\")) {\n                /*\n                 * \"PacketReceivePacket error: {message in arbitrary language} (1617)\",\n                 * which is ERROR_DEVICE_REMOVED.\n                 *\n                 * Current libpcap/Npcap treat ERROR_GEN_FAILURE as\n                 * \"the device is no longer attached\"; users are also\n                 * getting ERROR_DEVICE_REMOVED.\n                 *\n                 * For now, some users appear to be getg ERROR_DEVICE_REMOVED\n                 * in cases where the device *wasn't* removed, so tell\n                 * them to report this as an Npcap issue; I seem to\n                 * remember some discussion between Daniel and somebody\n                 * at Microsoft about the Windows 10 network stack setup/\n                 * teardown code being modified to try to prevent those\n                 * sort of problems popping up, but I can't find that\n                 * discussion.\n                 */\n                primary_msg = ws_strdup_printf(\"The network adapter \\\"%s\\\" \"\n                                              \"is no longer attached; the \"\n                                              \"capture has stopped.\",\n                                              interface_opts->display_name);\n                secondary_msg = handle_npcap_bug(interface_opts->display_name,\n                                                 \"The interface disappeared (error code ERROR_DEVICE_REMOVED/STATUS_DEVICE_REMOVED)\");\n            } else if (strcmp(cap_err_str, \"The other host terminated the connection.\") == 0 ||\n                       g_str_has_prefix(cap_err_str, \"Is the server properly installed?\")) {\n                /*\n                 * Networking error for a remote capture.\n                 */\n                primary_msg = g_strdup(cap_err_str);\n                secondary_msg = g_strdup(\"This may be a problem with the \"\n                                         \"remote host on which you are \"\n                                         \"capturing packets.\");\n            } else {\n                primary_msg = ws_strdup_printf(\"Error while capturing packets: %s\",\n                                              cap_err_str);\n                secondary_msg = g_strdup(please_report_bug());\n            }\n            report_capture_error(primary_msg, secondary_msg);\n            g_free(primary_msg);\n            g_free(secondary_msg);\n            break;\n        } else if (pcap_src->from_cap_pipe && pcap_src->cap_pipe_err == PIPERR) {\n            report_capture_error(errmsg, \"\");\n            break;\n        }\n    }\n    /* did we have an output error while capturing? */\n    if (global_ld.err == 0) {\n        write_ok = true;\n    } else {\n        capture_loop_get_errmsg(errmsg, sizeof(errmsg), secondary_errmsg,\n                                sizeof(secondary_errmsg),\n                                capture_opts->save_file, global_ld.err, false);\n        report_capture_error(errmsg, secondary_errmsg);\n        write_ok = false;\n    }\n\n    if (capture_opts->saving_to_file) {\n        /* close the output file */\n        close_ok = capture_loop_close_output(capture_opts, &global_ld, &err_close);\n    } else\n        close_ok = true;\n\n    /* there might be packets not yet notified to the parent */\n    /* (do this after closing the file, so all packets are already flushed) */\n    if (global_ld.inpkts_to_sync_pipe) {\n        if (!quiet)\n            report_packet_count(global_ld.inpkts_to_sync_pipe);\n        global_ld.inpkts_to_sync_pipe = 0;\n    }\n\n    /* If we've displayed a message about a write error, there's no point\n       in displaying another message about an error on close. */\n    if (!close_ok && write_ok) {\n        capture_loop_get_errmsg(errmsg, sizeof(errmsg), secondary_errmsg,\n                                sizeof(secondary_errmsg),\n                                capture_opts->save_file, err_close, true);\n        report_capture_error(errmsg, secondary_errmsg);\n    }\n\n    /*\n     * XXX We exhibit different behaviour between normal mode and sync mode\n     * when the pipe is stdin and not already at EOF.  If we're a child, the\n     * parent's stdin isn't closed, so if the user starts another capture,\n     * cap_pipe_open_live() will very likely not see the expected magic bytes and\n     * will say \"Unrecognized libpcap format\".  On the other hand, in normal\n     * mode, cap_pipe_open_live() will say \"End of file on pipe during open\".\n     */\n\n    report_capture_count(!really_quiet);\n\n    /* get packet drop statistics from pcap */\n    for (i = 0; i < capture_opts->ifaces->len; i++) {\n        uint32_t received;\n        uint32_t pcap_dropped = 0;\n\n        pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);\n        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);\n        received = pcap_src->received;\n        if (pcap_src->pcap_h != NULL) {\n            ws_assert(!pcap_src->from_cap_pipe);\n            /* Get the capture statistics, so we know how many packets were dropped. */\n            if (pcap_stats(pcap_src->pcap_h, stats) >= 0) {\n                *stats_known = true;\n                /* Let the parent process know. */\n                pcap_dropped += stats->ps_drop;\n            } else {\n                snprintf(errmsg, sizeof(errmsg),\n                           \"Can't get packet-drop statistics: %s\",\n                           pcap_geterr(pcap_src->pcap_h));\n                report_capture_error(errmsg, please_report_bug());\n            }\n        }\n        report_packet_drops(received, pcap_dropped, pcap_src->dropped, pcap_src->flushed, stats->ps_ifdrop, interface_opts->display_name);\n    }\n\n    /* close the input file (pcap or capture pipe) */\n    capture_loop_close_input(&global_ld);\n\n    ws_info(\"Capture loop stopped.\");\n\n    /* ok, if the write and the close were successful. */\n    return write_ok && close_ok;\n\nerror:\n    if (capture_opts->multi_files_on) {\n        /* cleanup ringbuffer */\n        ringbuf_error_cleanup();\n    } else {\n        /* We can't use the save file, and we have no FILE * for the stream\n           to close in order to close it, so close the FD directly. */\n        if (global_ld.save_file_fd != -1) {\n            ws_close(global_ld.save_file_fd);\n        }\n\n        /* We couldn't even start the capture, so get rid of the capture\n           file. */\n        if (capture_opts->save_file != NULL) {\n            ws_unlink(capture_opts->save_file);\n        }\n    }\n    if (cfilter_error)\n        report_cfilter_error(capture_opts, error_index, errmsg);\n    else\n        report_capture_error(errmsg, secondary_errmsg);\n\n    /* close the input file (pcap or cap_pipe) */\n    capture_loop_close_input(&global_ld);\n\n    ws_info(\"Capture loop stopped with error\");\n\n    return false;\n}\n\n\nstatic void\ncapture_loop_stop(void)\n{\n    unsigned     i;\n    capture_src *pcap_src;\n\n    for (i = 0; i < global_ld.pcaps->len; i++) {\n        pcap_src = g_array_index(global_ld.pcaps, capture_src *, i);\n        if (pcap_src->pcap_h != NULL)\n            pcap_breakloop(pcap_src->pcap_h);\n    }\n    global_ld.go = false;\n}\n\n\nstatic void\ncapture_loop_get_errmsg(char *errmsg, size_t errmsglen, char *secondary_errmsg,\n                        size_t secondary_errmsglen, const char *fname,\n                        int err, bool is_close)\n{\n    static const char find_space[] =\n        \"You will need to free up space on that file system\"\n        \" or put the capture file on a different file system.\";\n\n    switch (err) {\n\n    case ENOSPC:\n        snprintf(errmsg, errmsglen,\n                   \"Not all the packets could be written to the file\"\n                   \" to which the capture was being saved\\n\"\n                   \"(\\\"%s\\\") because there is no space left on the file system\\n\"\n                   \"on which that file resides.\",\n                   fname);\n        snprintf(secondary_errmsg, secondary_errmsglen, \"%s\", find_space);\n        break;\n\n#ifdef EDQUOT\n    case EDQUOT:\n        snprintf(errmsg, errmsglen,\n                   \"Not all the packets could be written to the file\"\n                   \" to which the capture was being saved\\n\"\n                   \"(\\\"%s\\\") because you are too close to, or over,\"\n                   \" your disk quota\\n\"\n                   \"on the file system on which that file resides.\",\n                   fname);\n        snprintf(secondary_errmsg, secondary_errmsglen, \"%s\", find_space);\n        break;\n#endif\n\n    default:\n        if (is_close) {\n            snprintf(errmsg, errmsglen,\n                       \"The file to which the capture was being saved\\n\"\n                       \"(\\\"%s\\\") could not be closed: %s.\",\n                       fname, g_strerror(err));\n        } else {\n            snprintf(errmsg, errmsglen,\n                       \"An error occurred while writing to the file\"\n                       \" to which the capture was being saved\\n\"\n                       \"(\\\"%s\\\"): %s.\",\n                       fname, g_strerror(err));\n        }\n        snprintf(secondary_errmsg, secondary_errmsglen,\n                   \"%s\", please_report_bug());\n        break;\n    }\n}\n\n/*\n * We wrote one packet. Update some statistics and check if we've met any\n * autostop or ring buffer conditions.\n */\nstatic void\ncapture_loop_wrote_one_packet(capture_src *pcap_src) {\n    global_ld.packets_captured++;\n    global_ld.packets_written++;\n    global_ld.inpkts_to_sync_pipe++;\n\n    if (!use_threads) {\n        pcap_src->received++;\n    }\n\n    /* check -c NUM */\n    if (global_capture_opts.has_autostop_packets && global_ld.packets_captured >= global_capture_opts.autostop_packets) {\n        fflush(global_ld.pdh);\n        global_ld.go = false;\n        return;\n    }\n    /* check -a packets:NUM (treat like -c NUM) */\n    if (global_capture_opts.has_autostop_written_packets && global_ld.packets_captured >= global_capture_opts.autostop_written_packets) {\n        fflush(global_ld.pdh);\n        global_ld.go = false;\n        return;\n    }\n    /* check -b packets:NUM */\n    if (global_capture_opts.has_file_packets && global_ld.packets_written >= global_capture_opts.file_packets) {\n        do_file_switch_or_stop(&global_capture_opts);\n        return;\n    }\n    /* check -a filesize:NUM */\n    if (global_capture_opts.has_autostop_filesize &&\n        global_capture_opts.autostop_filesize > 0 &&\n        global_ld.bytes_written / 1000 >= global_capture_opts.autostop_filesize) {\n        /* Capture size limit reached, do we have another file? */\n        do_file_switch_or_stop(&global_capture_opts);\n        return;\n    }\n}\n\n/* one pcapng block was captured, process it */\nstatic void\ncapture_loop_write_pcapng_cb(capture_src *pcap_src, const pcapng_block_header_t *bh, uint8_t *pd)\n{\n    int          err;\n\n    /*\n     * This should never be called if we're not writing pcapng.\n     */\n    ws_assert(global_capture_opts.use_pcapng);\n\n    /* We may be called multiple times from pcap_dispatch(); if we've set\n       the \"stop capturing\" flag, ignore this packet, as we're not\n       supposed to be saving any more packets. */\n    if (!global_ld.go) {\n        pcap_src->flushed++;\n        return;\n    }\n\n    if (!pcapng_adjust_block(pcap_src, bh, pd)) {\n        ws_info(\"%s failed to adjust pcapng block.\", G_STRFUNC);\n        ws_assert_not_reached();\n        return;\n    }\n\n    if (bh->block_type == BLOCK_TYPE_SHB && !global_ld.pcapng_passthrough) {\n        /*\n         * capture_loop_init_pcapng_output should've handled this. We need\n         * to write ISBs when they're initially read so we shouldn't skip\n         * them here.\n         */\n        return;\n    }\n\n    if (global_ld.pdh) {\n        bool successful;\n\n        /* We're supposed to write the packet to a file; do so.\n           If this fails, set \"ld->go\" to false, to stop the capture, and set\n           \"ld->err\" to the error. */\n        successful = pcapng_write_block(global_ld.pdh,\n                                       pd,\n                                       bh->block_total_length,\n                                       &global_ld.bytes_written, &err);\n\n        fflush(global_ld.pdh);\n        if (!successful) {\n            global_ld.go = false;\n            global_ld.err = err;\n            pcap_src->dropped++;\n        } else if (is_data_block(bh->block_type)) {\n            /* Count packets for block types that should be dissected, i.e. ones that show up in the packet list. */\n            ws_debug(\"Wrote a pcapng block type 0x%04x of length %d captured on interface %u.\",\n                   bh->block_type, bh->block_total_length, pcap_src->interface_id);\n            capture_loop_wrote_one_packet(pcap_src);\n        } else if (bh->block_type == BLOCK_TYPE_SHB && report_capture_filename) {\n            ws_debug(\"Sending SP_FILE on first SHB\");\n            /* SHB is now ready for capture parent to read on SP_FILE message */\n            sync_pipe_write_string_msg(sync_pipe_fd, SP_FILE, report_capture_filename);\n            report_capture_filename = NULL;\n        }\n    }\n}\n\n/* one pcap packet was captured, process it */\nstatic void\ncapture_loop_write_packet_cb(uint8_t *pcap_src_p, const struct pcap_pkthdr *phdr,\n                             const uint8_t *pd)\n{\n    capture_src *pcap_src = (capture_src *) (void *) pcap_src_p;\n    int          err;\n    unsigned     ts_mul    = pcap_src->ts_nsec ? 1000000000 : 1000000;\n\n    ws_debug(\"capture_loop_write_packet_cb\");\n\n    /* We may be called multiple times from pcap_dispatch(); if we've set\n       the \"stop capturing\" flag, ignore this packet, as we're not\n       supposed to be saving any more packets. */\n    if (!global_ld.go) {\n        pcap_src->flushed++;\n        return;\n    }\n\n    if (global_ld.pdh) {\n        bool successful;\n\n        /* We're supposed to write the packet to a file; do so.\n           If this fails, set \"ld->go\" to false, to stop the capture, and set\n           \"ld->err\" to the error. */\n        if (global_capture_opts.use_pcapng) {\n            successful = pcapng_write_enhanced_packet_block(global_ld.pdh,\n                                                            NULL,\n                                                            phdr->ts.tv_sec, (int32_t)phdr->ts.tv_usec,\n                                                            phdr->caplen, phdr->len,\n                                                            pcap_src->idb_id,\n                                                            ts_mul,\n                                                            pd, 0,\n                                                            &global_ld.bytes_written, &err);\n        } else {\n            successful = libpcap_write_packet(global_ld.pdh,\n                                              phdr->ts.tv_sec, (int32_t)phdr->ts.tv_usec,\n                                              phdr->caplen, phdr->len,\n                                              pd,\n                                              &global_ld.bytes_written, &err);\n        }\n        if (!successful) {\n            global_ld.go = false;\n            global_ld.err = err;\n            pcap_src->dropped++;\n        } else {\n            ws_debug(\"Wrote a pcap packet of length %d captured on interface %u.\",\n                   phdr->caplen, pcap_src->interface_id);\n            capture_loop_wrote_one_packet(pcap_src);\n        }\n    }\n}\n\n/* one packet was captured, queue it */\nstatic void\ncapture_loop_queue_packet_cb(uint8_t *pcap_src_p, const struct pcap_pkthdr *phdr,\n                             const uint8_t *pd)\n{\n    capture_src        *pcap_src = (capture_src *) (void *) pcap_src_p;\n    pcap_queue_element *queue_element;\n    bool                limit_reached;\n\n    /* We may be called multiple times from pcap_dispatch(); if we've set\n       the \"stop capturing\" flag, ignore this packet, as we're not\n       supposed to be saving any more packets. */\n    if (!global_ld.go) {\n        pcap_src->flushed++;\n        return;\n    }\n\n    queue_element = g_new(pcap_queue_element, 1);\n    if (queue_element == NULL) {\n       pcap_src->dropped++;\n       return;\n    }\n    queue_element->pcap_src = pcap_src;\n    queue_element->u.phdr = *phdr;\n    queue_element->pd = (uint8_t *)g_malloc(phdr->caplen);\n    if (queue_element->pd == NULL) {\n        pcap_src->dropped++;\n        g_free(queue_element);\n        return;\n    }\n    memcpy(queue_element->pd, pd, phdr->caplen);\n    g_async_queue_lock(pcap_queue);\n    if (((pcap_queue_byte_limit == 0) || (pcap_queue_bytes < pcap_queue_byte_limit)) &&\n        ((pcap_queue_packet_limit == 0) || (pcap_queue_packets < pcap_queue_packet_limit))) {\n        limit_reached = false;\n        g_async_queue_push_unlocked(pcap_queue, queue_element);\n        pcap_queue_bytes += phdr->caplen;\n        pcap_queue_packets += 1;\n    } else {\n        limit_reached = true;\n    }\n    g_async_queue_unlock(pcap_queue);\n    if (limit_reached) {\n        pcap_src->dropped++;\n        g_free(queue_element->pd);\n        g_free(queue_element);\n        ws_info(\"Dropped a packet of length %d captured on interface %u.\",\n              phdr->caplen, pcap_src->interface_id);\n    } else {\n        pcap_src->received++;\n        ws_info(\"Queued a packet of length %d captured on interface %u.\",\n              phdr->caplen, pcap_src->interface_id);\n    }\n    /* I don't want to hold the mutex over the debug output. So the\n       output may be wrong */\n    ws_info(\"Queue size is now %\" PRId64 \" bytes (%\" PRId64 \" packets)\",\n          pcap_queue_bytes, pcap_queue_packets);\n}\n\n/* one pcapng block was captured, queue it */\nstatic void\ncapture_loop_queue_pcapng_cb(capture_src *pcap_src, const pcapng_block_header_t *bh, uint8_t *pd)\n{\n    pcap_queue_element *queue_element;\n    bool                limit_reached;\n\n    /* We may be called multiple times from pcap_dispatch(); if we've set\n       the \"stop capturing\" flag, ignore this packet, as we're not\n       supposed to be saving any more packets. */\n    if (!global_ld.go) {\n        pcap_src->flushed++;\n        return;\n    }\n\n    queue_element = g_new(pcap_queue_element, 1);\n    if (queue_element == NULL) {\n       pcap_src->dropped++;\n       return;\n    }\n    queue_element->pcap_src = pcap_src;\n    queue_element->u.bh = *bh;\n    queue_element->pd = (uint8_t *)g_malloc(bh->block_total_length);\n    if (queue_element->pd == NULL) {\n        pcap_src->dropped++;\n        g_free(queue_element);\n        return;\n    }\n    memcpy(queue_element->pd, pd, bh->block_total_length);\n    g_async_queue_lock(pcap_queue);\n    if (((pcap_queue_byte_limit == 0) || (pcap_queue_bytes < pcap_queue_byte_limit)) &&\n        ((pcap_queue_packet_limit == 0) || (pcap_queue_packets < pcap_queue_packet_limit))) {\n        limit_reached = false;\n        g_async_queue_push_unlocked(pcap_queue, queue_element);\n        pcap_queue_bytes += bh->block_total_length;\n        pcap_queue_packets += 1;\n    } else {\n        limit_reached = true;\n    }\n    g_async_queue_unlock(pcap_queue);\n    if (limit_reached) {\n        pcap_src->dropped++;\n        g_free(queue_element->pd);\n        g_free(queue_element);\n        ws_info(\"Dropped a packet of length %d captured on interface %u.\",\n              bh->block_total_length, pcap_src->interface_id);\n    } else {\n        pcap_src->received++;\n        ws_info(\"Queued a block of type 0x%08x of length %d captured on interface %u.\",\n              bh->block_type, bh->block_total_length, pcap_src->interface_id);\n    }\n    /* I don't want to hold the mutex over the debug output. So the\n       output may be wrong */\n    ws_info(\"Queue size is now %\" PRId64 \" bytes (%\" PRId64 \" packets)\",\n          pcap_queue_bytes, pcap_queue_packets);\n}\n\nstatic int\nset_80211_channel(const char *iface, const char *opt)\n{\n    uint32_t freq = 0;\n    int type = -1;\n    uint32_t center_freq1 = 0;\n    uint32_t center_freq2 = 0;\n    int args;\n    int ret = 0;\n    char **options = NULL;\n\n    options = g_strsplit_set(opt, \",\", 4);\n    for (args = 0; options[args]; args++)\n        ;\n\n    ret = ws80211_init();\n    if (ret != WS80211_INIT_OK) {\n        if (ret == WS80211_INIT_NOT_SUPPORTED)\n            cmdarg_err(\"Setting 802.11 channels is not supported on this platform\");\n        else\n            cmdarg_err(\"Failed to init ws80211: %s\", g_strerror(abs(ret)));\n        ret = 2;\n        goto out;\n    }\n\n    if (options[0])\n        freq = get_nonzero_uint32(options[0], \"802.11 channel frequency\");\n\n    if (args >= 1 && options[1]) {\n        type = ws80211_str_to_chan_type(options[1]);\n        if (type == -1) {\n            cmdarg_err(\"\\\"%s\\\" is not a valid 802.11 channel type\", options[1]);\n            ret = EINVAL;\n            goto out;\n        }\n    }\n\n    if (args >= 2 && options[2])\n        center_freq1 = get_nonzero_uint32(options[2], \"VHT center frequency\");\n\n    if (args >= 3 && options[3])\n        center_freq2 = get_nonzero_uint32(options[3], \"VHT center frequency 2\");\n\n    ret = ws80211_set_freq(iface, freq, type, center_freq1, center_freq2);\n\n    if (ret) {\n        cmdarg_err(\"%d: Failed to set channel: %s\\n\", abs(ret), g_strerror(abs(ret)));\n        ret = 2;\n        goto out;\n    }\n\n    if (capture_child)\n        sync_pipe_write_string_msg(sync_pipe_fd, SP_SUCCESS, NULL);\n\nout:\n    g_strfreev(options);\n    return ret;\n}\n\nstatic void\ngather_dumpcap_compiled_info(feature_list l)\n{\n    /* Capture libraries */\n    gather_caplibs_compile_info(l);\n}\n\nstatic void\ngather_dumpcap_runtime_info(feature_list l)\n{\n    /* Capture libraries */\n    gather_caplibs_runtime_info(l);\n}\n\n#define LONGOPT_IFNAME              LONGOPT_BASE_APPLICATION+1\n#define LONGOPT_IFDESCR             LONGOPT_BASE_APPLICATION+2\n#define LONGOPT_CAPTURE_COMMENT     LONGOPT_BASE_APPLICATION+3\n#define LONGOPT_APPLICATION_FLAVOR  LONGOPT_BASE_APPLICATION+4\n#ifdef _WIN32\n#define LONGOPT_SIGNAL_PIPE         LONGOPT_BASE_APPLICATION+5\n#endif\n\n/* And now our feature presentation... [ fade to music ] */\nint\nmain(int argc, char *argv[])\n{\n    char             *err_msg;\n    int               opt;\n    static const struct ws_option long_options[] = {\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        LONGOPT_CAPTURE_COMMON\n        {\"ifname\", ws_required_argument, NULL, LONGOPT_IFNAME},\n        {\"ifdescr\", ws_required_argument, NULL, LONGOPT_IFDESCR},\n        {\"capture-comment\", ws_required_argument, NULL, LONGOPT_CAPTURE_COMMENT},\n        {\"application-flavor\", ws_required_argument, NULL, LONGOPT_APPLICATION_FLAVOR},\n#ifdef _WIN32\n        {\"signal-pipe\", ws_required_argument, NULL, LONGOPT_SIGNAL_PIPE},\n#endif\n        {0, 0, 0, 0 }\n    };\n\n    bool              arg_error             = false;\n\n#ifndef _WIN32\n    struct sigaction  action, oldaction;\n#endif\n\n    bool              stats_known;\n    struct pcap_stat  stats = {0};\n    bool              list_interfaces       = false;\n    int               caps_queries          = 0;\n    bool              print_bpf_code        = false;\n    bool              set_chan              = false;\n    char             *set_chan_arg          = NULL;\n    bool              machine_readable      = false;\n    bool              print_statistics      = false;\n    int               status, run_once_args = 0;\n    int               i;\n    unsigned          j;\n#if defined(__APPLE__) && defined(__LP64__)\n    struct utsname    osinfo;\n#endif\n    GString          *str;\n\n    /* Set the program name. */\n    g_set_prgname(\"dumpcap\");\n\n    /*\n     * Determine if dumpcap is being requested to run in a special\n     * capture_child mode by going thru the command line args to see if\n     * a -Z is present. (-Z is a hidden option).\n     *\n     * The primary result of running in capture_child mode is that\n     * all messages sent out on stderr are in a special type/len/string\n     * format to allow message processing by type.  These messages include\n     * error messages if dumpcap fails to start the operation it was\n     * requested to do, as well as various \"status\" messages which are sent\n     * when an actual capture is in progress, and a \"success\" message sent\n     * if dumpcap was requested to perform an operation other than a\n     * capture.\n     *\n     * Capture_child mode would normally be requested by a parent process\n     * which invokes dumpcap and obtains dumpcap stderr output via a pipe\n     * to which dumpcap stderr has been redirected.  It might also have\n     * another pipe to obtain dumpcap stdout output; for operations other\n     * than a capture, that information is formatted specially for easier\n     * parsing by the parent process.\n     *\n     * Capture_child mode needs to be determined immediately upon\n     * startup so that any messages generated by dumpcap in this mode\n     * (eg: during initialization) will be formatted properly.\n     */\n\n    for (i=1; i<argc; i++) {\n        if (strcmp(\"-Z\", argv[i]) == 0) {\n            capture_child    = true;\n            machine_readable = true;  /* request machine-readable output */\n            i++;\n            if (i >= argc) {\n                exit_main(1);\n            }\n\n            if (strcmp(argv[i], SIGNAL_PIPE_CTRL_ID_NONE) != 0) {\n                // get_positive_int calls cmdarg_err\n                if (!ws_strtoi(argv[i], NULL, &sync_pipe_fd) || sync_pipe_fd <= 0) {\n                    exit_main(1);\n                }\n#ifdef _WIN32\n                /* On UN*X the fd is the same when we fork + exec.\n                 * On Windows the HANDLE value is the same for inherited\n                 * handles in the child process and the parent, although\n                 * not necessarily the fd value from _open_osfhandle.\n                 * https://learn.microsoft.com/en-us/windows/win32/procthread/inheritance\n                 * Also, \"64-bit versions of Windows use 32-bit handles for\n                 * interoperability... only the lower 32 bits are significant,\n                 * so it is safe to truncate... or sign-extend the handle.\"\n                 * https://learn.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication\n                 */\n                /* set output pipe to binary mode, avoid ugly text conversions */\n                sync_pipe_fd = _open_osfhandle( (intptr_t) sync_pipe_fd, _O_BINARY);\n#endif\n            }\n        }\n    }\n\n    cmdarg_err_init(dumpcap_cmdarg_err, dumpcap_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init_with_writer(dumpcap_log_writer, vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, 1);\n\n#if DEBUG_CHILD_DUMPCAP\n    /* Assume that if we're specially compiled with dumpcap debugging\n     * then we want maximum debugging.\n     */\n    if (capture_child) {\n        ws_log_set_level(LOG_LEVEL_NOISY);\n    }\n\n    if ((debug_log = ws_fopen(\"dumpcap_debug_log.tmp\",\"w\")) == NULL) {\n        fprintf (stderr, \"Unable to open debug log file .\\n\");\n        exit (1);\n    }\n#endif\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n#ifdef _WIN32\n    create_app_running_mutex();\n\n    /*\n     * Initialize our DLL search path. MUST be called before LoadLibrary\n     * or g_module_open.\n     */\n    ws_init_dll_search_path();\n\n    /* Load wpcap if possible. Do this before collecting the run-time version information */\n    load_wpcap();\n#endif\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"Dumpcap\", gather_dumpcap_compiled_info,\n                         gather_dumpcap_runtime_info);\n\n#ifdef HAVE_PCAP_REMOTE\n#define OPTSTRING_r \"r\"\n#define OPTSTRING_u \"u\"\n#else\n#define OPTSTRING_r\n#define OPTSTRING_u\n#endif\n\n#ifdef HAVE_PCAP_SETSAMPLING\n#define OPTSTRING_m \"m:\"\n#else\n#define OPTSTRING_m\n#endif\n\n#define OPTSTRING OPTSTRING_CAPTURE_COMMON \"C:dghk:\" OPTSTRING_m \"MN:nPqQ\" OPTSTRING_r \"St\" OPTSTRING_u \"vw:Z:\"\n\n#if defined(__APPLE__) && defined(__LP64__)\n    /*\n     * Is this Mac OS X 10.6.0, 10.6.1, 10.6.3, or 10.6.4?  If so, we need\n     * a bug workaround - timeouts less than 1 second don't work with libpcap\n     * in 64-bit code.  (The bug was introduced in 10.6, fixed in 10.6.2,\n     * re-introduced in 10.6.3, not fixed in 10.6.4, and fixed in 10.6.5.\n     * The problem is extremely unlikely to be reintroduced in a future\n     * release.)\n     */\n    if (uname(&osinfo) == 0) {\n        /*\n         * {Mac} OS X/macOS 10.x uses Darwin {x+4}.0.0; 10.x.y uses Darwin\n         * {x+4}.y.0 (except that 10.6.1 appears to have a uname version\n         * number of 10.0.0, not 10.1.0 - go figure).\n         */\n        if (strcmp(osinfo.release, \"10.0.0\") == 0 ||    /* 10.6, 10.6.1 */\n            strcmp(osinfo.release, \"10.3.0\") == 0 ||    /* 10.6.3 */\n            strcmp(osinfo.release, \"10.4.0\") == 0)              /* 10.6.4 */\n            need_timeout_workaround = true;\n    }\n#endif\n\n    /* Initialize the pcaps list and IDBs */\n    global_ld.pcaps = g_array_new(FALSE, FALSE, sizeof(capture_src *));\n    global_ld.pcapng_passthrough = false;\n    global_ld.saved_shb = NULL;\n    global_ld.saved_idbs = g_array_new(FALSE, TRUE, sizeof(saved_idb_t));\n\n    err_msg = ws_init_sockets();\n    if (err_msg != NULL)\n    {\n        ws_log(LOG_DOMAIN_CAPCHILD, LOG_LEVEL_ERROR,\n                          \"ERROR: %s\", err_msg);\n        g_free(err_msg);\n        ws_log(LOG_DOMAIN_CAPCHILD, LOG_LEVEL_ERROR,\n                          \"%s\", please_report_bug());\n        exit_main(1);\n    }\n\n#ifdef _WIN32\n    /* Set handler for Ctrl+C key */\n    SetConsoleCtrlHandler(capture_cleanup_handler, true);\n#else\n    /* Catch SIGINT and SIGTERM and, if we get either of them, clean up\n       and exit.  Do the same with SIGPIPE, in case, for example,\n       we're writing to our standard output and it's a pipe.\n       Do the same with SIGHUP if it's not being ignored (if we're\n       being run under nohup, it might be ignored, in which case we\n       should leave it ignored).\n\n       XXX - apparently, Coverity complained that part of action\n       wasn't initialized.  Perhaps it's running on Linux, where\n       struct sigaction has an ignored \"sa_restorer\" element and\n       where \"sa_handler\" and \"sa_sigaction\" might not be two\n       members of a union. */\n    memset(&action, 0, sizeof(action));\n    action.sa_handler = capture_cleanup_handler;\n    /*\n     * Arrange that system calls not get restarted, because when\n     * our signal handler returns we don't want to restart\n     * a call that was waiting for packets to arrive.\n     */\n    action.sa_flags = 0;\n    sigemptyset(&action.sa_mask);\n    sigaction(SIGTERM, &action, NULL);\n    sigaction(SIGINT, &action, NULL);\n    sigaction(SIGPIPE, &action, NULL);\n    sigaction(SIGHUP, NULL, &oldaction);\n    if (oldaction.sa_handler == SIG_DFL)\n        sigaction(SIGHUP, &action, NULL);\n\n#ifdef SIGINFO\n    /* Catch SIGINFO and, if we get it and we're capturing in\n       quiet mode, report the number of packets we've captured. */\n    action.sa_handler = report_counts_siginfo;\n    action.sa_flags = SA_RESTART;\n    sigemptyset(&action.sa_mask);\n    sigaction(SIGINFO, &action, NULL);\n#endif /* SIGINFO */\n#endif  /* _WIN32 */\n\n    /* ----------------------------------------------------------------- */\n    /* Privilege and capability handling                                 */\n    /* Cases:                                                            */\n    /* 1. Running not as root or suid root; no special capabilities.     */\n    /*    Action: none                                                   */\n    /*                                                                   */\n    /* 2. Running logged in as root (euid=0; ruid=0); Not using libcap.  */\n    /*    Action: none                                                   */\n    /*                                                                   */\n    /* 3. Running logged in as root (euid=0; ruid=0). Using libcap.      */\n    /*    Action:                                                        */\n    /*      - Near start of program: Enable NET_RAW and NET_ADMIN        */\n    /*        capabilities; Drop all other capabilities;                 */\n    /*      - If not -w  (ie: doing -S or -D, etc) run to completion;    */\n    /*        else: after  pcap_open_live() in capture_loop_open_input() */\n    /*         drop all capabilities (NET_RAW and NET_ADMIN);            */\n    /*         (Note: this means that the process, although logged in    */\n    /*          as root, does not have various permissions such as the   */\n    /*          ability to bypass file access permissions).              */\n    /*      XXX: Should we just leave capabilities alone in this case    */\n    /*          so that user gets expected effect that root can do       */\n    /*          anything ??                                              */\n    /*                                                                   */\n    /* 4. Running as suid root (euid=0, ruid=n); Not using libcap.       */\n    /*    Action:                                                        */\n    /*      - If not -w  (ie: doing -S or -D, etc) run to completion;    */\n    /*        else: after  pcap_open_live() in capture_loop_open_input() */\n    /*         drop suid root (set euid=ruid).(ie: keep suid until after */\n    /*         pcap_open_live).                                          */\n    /*                                                                   */\n    /* 5. Running as suid root (euid=0, ruid=n); Using libcap.           */\n    /*    Action:                                                        */\n    /*      - Near start of program: Enable NET_RAW and NET_ADMIN        */\n    /*        capabilities; Drop all other capabilities;                 */\n    /*        Drop suid privileges (euid=ruid);                          */\n    /*      - If not -w  (ie: doing -S or -D, etc) run to completion;    */\n    /*        else: after  pcap_open_live() in capture_loop_open_input() */\n    /*         drop all capabilities (NET_RAW and NET_ADMIN).            */\n    /*                                                                   */\n    /*      XXX: For some Linux versions/distros with capabilities       */\n    /*        a 'normal' process with any capabilities cannot be         */\n    /*        'killed' (signaled) from another (same uid) non-privileged */\n    /*        process.                                                   */\n    /*        For example: If (non-suid) Wireshark forks a               */\n    /*        child suid dumpcap which acts as described here (case 5),  */\n    /*        Wireshark will be unable to kill (signal) the child        */\n    /*        dumpcap process until the capabilities have been dropped   */\n    /*        (after pcap_open_live()).                                  */\n    /*        This behaviour will apparently be changed in the kernel    */\n    /*        to allow the kill (signal) in this case.                   */\n    /*        See the following for details:                             */\n    /*           https://www.mail-archive.com/  [wrapped]                */\n    /*             linux-security-module@vger.kernel.org/msg02913.html   */\n    /*                                                                   */\n    /*        It is therefore conceivable that if dumpcap somehow hangs  */\n    /*        in pcap_open_live or before that wireshark will not        */\n    /*        be able to stop dumpcap using a signal (INT, TERM, etc).   */\n    /*        In this case, exiting wireshark will kill the child        */\n    /*        dumpcap process.                                           */\n    /*                                                                   */\n    /* 6. Not root or suid root; Running with NET_RAW & NET_ADMIN        */\n    /*     capabilities; Using libcap.  Note: capset cmd (which see)     */\n    /*     used to assign capabilities to file.                          */\n    /*    Action:                                                        */\n    /*      - If not -w  (ie: doing -S or -D, etc) run to completion;    */\n    /*        else: after  pcap_open_live() in capture_loop_open_input() */\n    /*         drop all capabilities (NET_RAW and NET_ADMIN)             */\n    /*                                                                   */\n    /* ToDo: -S (stats) should drop privileges/capabilities when no      */\n    /*       longer required (similar to capture).                       */\n    /*                                                                   */\n    /* ----------------------------------------------------------------- */\n\n    init_process_policies();\n\n#ifdef HAVE_LIBCAP\n    /* If 'started with special privileges' (and using libcap)  */\n    /*   Set to keep only NET_RAW and NET_ADMIN capabilities;   */\n    /*   Set euid/egid = ruid/rgid to remove suid privileges    */\n    relinquish_privs_except_capture();\n#endif\n\n    init_report_failure_message_simple(\"dumpcap\");\n\n    /* Set the initial values in the capture options. This might be overwritten\n       by the command line parameters. */\n    capture_opts_init(&global_capture_opts, get_interface_list);\n    /* We always save to a file - if no file was specified, we save to a\n       temporary file. */\n    global_capture_opts.saving_to_file      = true;\n    global_capture_opts.has_ring_num_files  = true;\n\n    /* Pass on capture_child mode for capture_opts */\n    global_capture_opts.capture_child = capture_child;\n\n    /* Now get our args */\n    while ((opt = ws_getopt_long(argc, argv, OPTSTRING, long_options, NULL)) != -1) {\n        switch (opt) {\n        case 'h':        /* Print help and exit */\n            show_help_header(\"Capture network packets and dump them into a pcapng or pcap file.\");\n            print_usage(stdout);\n            exit_main(0);\n            break;\n        case 'v':        /* Show version and exit */\n            show_version();\n            exit_main(0);\n            break;\n        case LONGOPT_APPLICATION_FLAVOR:\n            set_application_flavor(application_name_to_flavor(ws_optarg));\n            break;\n        /*** capture option specific ***/\n        case 'a':        /* autostop criteria */\n        case 'b':        /* Ringbuffer option */\n        case 'c':        /* Capture x packets */\n        case 'f':        /* capture filter */\n        case 'F':        /* capture file type */\n        case 'g':        /* enable group read access on file(s) */\n        case 'i':        /* Use interface x */\n        case LONGOPT_SET_TSTAMP_TYPE: /* Set capture timestamp type */\n        case 'n':        /* Use pcapng format */\n        case 'p':        /* Don't capture in promiscuous mode */\n        case 'P':        /* Use pcap format */\n        case 's':        /* Set the snapshot (capture) length */\n        case 'w':        /* Write to capture file x */\n        case 'y':        /* Set the pcap data link type */\n#ifdef HAVE_PCAP_REMOTE\n        case 'u':        /* Use UDP for data transfer */\n        case 'r':        /* Capture own RPCAP traffic too */\n        case 'A':        /* Authentication */\n#endif\n#ifdef HAVE_PCAP_SETSAMPLING\n        case 'm':        /* Sampling */\n#endif\n        case 'B':        /* Buffer size */\n        case 'I':        /* Monitor mode */\n        case LONGOPT_COMPRESS_TYPE:        /* compress type */\n        case LONGOPT_CAPTURE_TMPDIR:       /* capture temp directory */\n        case LONGOPT_UPDATE_INTERVAL:      /* sync pipe update interval */\n            status = capture_opts_add_opt(&global_capture_opts, opt, ws_optarg);\n            if (status != 0) {\n                exit_main(status);\n            }\n            break;\n            /*** hidden option: Wireshark child mode (using binary output messages) ***/\n        case LONGOPT_IFNAME:\n            if (global_capture_opts.ifaces->len > 0) {\n                interface_options *interface_opts;\n\n                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, global_capture_opts.ifaces->len - 1);\n                interface_opts->ifname = g_strdup(ws_optarg);\n            } else {\n                cmdarg_err(\"--ifname must be specified after a -i option\");\n                exit_main(1);\n            }\n            break;\n        case LONGOPT_IFDESCR:\n            if (global_capture_opts.ifaces->len > 0) {\n                interface_options *interface_opts;\n\n                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, global_capture_opts.ifaces->len - 1);\n                interface_opts->descr = g_strdup(ws_optarg);\n            } else {\n                cmdarg_err(\"--ifdescr must be specified after a -i option\");\n                exit_main(1);\n            }\n            break;\n        case LONGOPT_CAPTURE_COMMENT:  /* capture comment */\n            if (capture_comments == NULL) {\n                capture_comments = g_ptr_array_new_with_free_func(g_free);\n            }\n            g_ptr_array_add(capture_comments, g_strdup(ws_optarg));\n            break;\n        case 'Z':\n            capture_child = true;\n            /*\n             * Handled above\n             */\n            break;\n#ifdef _WIN32\n        case LONGOPT_SIGNAL_PIPE:\n            if (!capture_child) {\n                /* We have already checked for -Z at the very beginning. */\n                cmdarg_err(\"--signal-pipe may only be specified with -Z\");\n                exit_main(1);\n            }\n            /*\n             * ws_optarg = the control ID, aka the PPID, currently used for the\n             * signal pipe name.\n             */\n            if (strcmp(ws_optarg, SIGNAL_PIPE_CTRL_ID_NONE) != 0) {\n                sig_pipe_name = ws_strdup_printf(SIGNAL_PIPE_FORMAT, ws_optarg);\n                sig_pipe_handle = CreateFile(utf_8to16(sig_pipe_name),\n                                             GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);\n\n                if (sig_pipe_handle == INVALID_HANDLE_VALUE) {\n                    ws_info(\"Signal pipe: Unable to open %s.  Dead parent?\",\n                          sig_pipe_name);\n                    exit_main(1);\n                }\n            }\n            break;\n#endif\n        case 'q':        /* Quiet */\n            quiet = true;\n            break;\n        case 'Q':        /* Really quiet */\n            quiet = true;\n            really_quiet = true;\n            break;\n        case 't':\n            use_threads = true;\n            break;\n            /*** all non capture option specific ***/\n        case 'D':        /* Print a list of capture devices and exit */\n            if (!list_interfaces && !caps_queries & !print_statistics) {\n                run_once_args++;\n            }\n            list_interfaces = true;\n            break;\n        case 'L':        /* Print list of link-layer types and exit */\n            if (!list_interfaces && !caps_queries & !print_statistics) {\n                run_once_args++;\n            }\n            caps_queries |= CAPS_QUERY_LINK_TYPES;\n            break;\n        case LONGOPT_LIST_TSTAMP_TYPES:\n            if (!list_interfaces && !caps_queries & !print_statistics) {\n                run_once_args++;\n            }\n            caps_queries |= CAPS_QUERY_TIMESTAMP_TYPES;\n            break;\n        case 'd':        /* Print BPF code for capture filter and exit */\n            if (!print_bpf_code) {\n                print_bpf_code = true;\n                run_once_args++;\n            }\n            break;\n        case 'S':        /* Print interface statistics once a second */\n            if (!list_interfaces && !caps_queries & !print_statistics) {\n                run_once_args++;\n            }\n            print_statistics = true;\n            break;\n        case 'k':        /* Set wireless channel */\n            if (!set_chan) {\n                set_chan = true;\n                set_chan_arg = ws_optarg;\n                run_once_args++;\n            } else {\n                cmdarg_err(\"Only one -k flag may be specified\");\n                arg_error = true;\n            }\n            break;\n        case 'M':        /* For -D, -L, and -S, print machine-readable output */\n            machine_readable = true;\n            break;\n        case 'C':\n            pcap_queue_byte_limit = get_positive_int(ws_optarg, \"byte_limit\");\n            break;\n        case 'N':\n            pcap_queue_packet_limit = get_positive_int(ws_optarg, \"packet_limit\");\n            break;\n        default:\n            cmdarg_err(\"Invalid Option: %s\", argv[ws_optind-1]);\n            /* FALLTHROUGH */\n        case '?':        /* Bad flag - print usage message */\n            arg_error = true;\n            break;\n        }\n    }\n    if (!arg_error) {\n        argc -= ws_optind;\n        argv += ws_optind;\n        if (argc >= 1) {\n            /* user specified file name as regular command-line argument */\n            /* XXX - use it as the capture file name (or something else)? */\n            argc--;\n            argv++;\n        }\n        if (argc != 0) {\n            /*\n             * Extra command line arguments were specified; complain.\n             * XXX - interpret as capture filter, as tcpdump and tshark do?\n             */\n            cmdarg_err(\"Invalid argument: %s\", argv[0]);\n            arg_error = true;\n        }\n    }\n\n    if ((pcap_queue_byte_limit > 0) || (pcap_queue_packet_limit > 0)) {\n        use_threads = true;\n    }\n    if ((pcap_queue_byte_limit == 0) && (pcap_queue_packet_limit == 0)) {\n        /* Use some default if the user hasn't specified some */\n        /* XXX: Are these defaults good enough? */\n        pcap_queue_byte_limit = 1000 * 1000;\n        pcap_queue_packet_limit = 1000;\n    }\n    if (arg_error) {\n        if (ws_optopt == 'F') {\n            capture_opts_list_file_types();\n            exit_main(1);\n        }\n        print_usage(stderr);\n        exit_main(1);\n    }\n\n    if (run_once_args > 1) {\n        cmdarg_err(\"Only one of -D, -L, -d, -k or -S may be supplied.\");\n        exit_main(1);\n    } else if (run_once_args == 1) {\n        /* We're supposed to print some information, rather than\n           to capture traffic; did they specify a ring buffer option? */\n        if (global_capture_opts.multi_files_on) {\n            cmdarg_err(\"Ring buffer requested, but a capture isn't being done.\");\n            exit_main(1);\n        }\n    } else {\n        /* We're supposed to capture traffic; */\n\n        /* Are we capturing on multiple interface? If so, use threads and pcapng. */\n        if (global_capture_opts.ifaces->len > 1) {\n            use_threads = true;\n            global_capture_opts.use_pcapng = true;\n        }\n\n        if (capture_comments &&\n            (!global_capture_opts.use_pcapng || global_capture_opts.multi_files_on)) {\n            /* XXX - for ringbuffer, should we apply the comments to each file? */\n            cmdarg_err(\"Capture comments can only be set if we capture into a single pcapng file.\");\n            exit_main(1);\n        }\n\n        /* Was the ring buffer option specified and, if so, does it make sense? */\n        if (global_capture_opts.multi_files_on) {\n            /* Ring buffer works only under certain conditions:\n               a) ring buffer does not work with temporary files;\n               b) it makes no sense to enable the ring buffer if the maximum\n               file size is set to \"infinite\". */\n            if (global_capture_opts.save_file == NULL) {\n                cmdarg_err(\"Ring buffer requested, but capture isn't being saved to a permanent file.\");\n                global_capture_opts.multi_files_on = false;\n            }\n            if (!global_capture_opts.has_autostop_filesize &&\n                !global_capture_opts.has_file_duration &&\n                !global_capture_opts.has_file_interval &&\n                !global_capture_opts.has_file_packets) {\n                cmdarg_err(\"Ring buffer requested, but no maximum capture file size, duration \"\n                           \"interval, or packets were specified.\");\n#if 0\n                /* XXX - this must be redesigned as the conditions changed */\n                global_capture_opts.multi_files_on = false;\n#endif\n            }\n            if (global_capture_opts.has_file_duration && global_capture_opts.has_file_interval) {\n                cmdarg_err(\"Ring buffer file duration and interval can't be used at the same time.\");\n                exit_main(1);\n            }\n        }\n    }\n\n    /*\n     * \"-D\" requires no interface to be selected; it's supposed to list\n     * all interfaces.\n     */\n    if (list_interfaces) {\n        /* Get the list of interfaces */\n        GList *if_list;\n        int    err;\n        char *err_str;\n\n        if_list = get_interface_list(&err, &err_str);\n        if (if_list == NULL) {\n            if (err == 0) {\n                /*\n                 * If we're being run by another program, just give them\n                 * an empty list of interfaces, don't report this as\n                 * an error; that lets them decide whether to report\n                 * this as an error or not.\n                 */\n                if (!machine_readable) {\n                    cmdarg_err(\"There are no interfaces on which a capture can be done\");\n                    exit_main(2);\n                }\n            } else {\n                cmdarg_err(\"%s\", err_str);\n                g_free(err_str);\n                exit_main(2);\n            }\n        }\n\n        if (!machine_readable) {\n            status = 0;\n            capture_opts_print_interfaces(if_list);\n        }\n\n        if (caps_queries) {\n            if_info_t *if_info;\n            interface_options *interface_opts;\n            cap_device_open_status open_status;\n            char *open_status_str;\n            for (GList *if_entry = if_list; if_entry != NULL; if_entry = g_list_next(if_entry)) {\n                if_info = (if_info_t *)if_entry->data;\n\n                /*\n                 * XXX - If on the command line we had the options -i <interface> -I,\n                 * we should retrieve the link-types for the interface in monitor mode.\n                 * We've already copied that information to global_capture_opts, but\n                 * the below statement wipes it away.\n                 */\n                interface_opts = interface_opts_from_if_info(&global_capture_opts, if_info);\n\n                if_info->caps = get_if_capabilities(interface_opts, &open_status, &open_status_str);\n\n                if (!machine_readable) {\n                    if (if_info->caps == NULL) {\n                        cmdarg_err(\"The capabilities of the capture device \"\n                                    \"\\\"%s\\\" could not be obtained (%s).\\n%s\",\n                                    interface_opts->name, open_status_str,\n                                    get_pcap_failure_secondary_error_message(open_status, open_status_str));\n                        g_free(open_status_str);\n                        /* Break after one error, as when printing selected\n                         * interface capabilities. (XXX: We could print all\n                         * the primary status strings, and only the unique\n                         * set of secondary messages / suggestions; printing\n                         * the same long secondary error is a lot.)\n                         */\n                        interface_opts_free(interface_opts);\n                        g_free(interface_opts);\n                        break;\n                    } else {\n                        status = capture_opts_print_if_capabilities(if_info->caps, interface_opts, caps_queries);\n                        if (status != 0) {\n                            interface_opts_free(interface_opts);\n                            g_free(interface_opts);\n                            break;\n                        }\n                    }\n                } else {\n                    if (if_info->caps == NULL) {\n                        if_info->caps = g_new0(if_capabilities_t, 1);\n                        if_info->caps->primary_msg = open_status_str;\n                        if_info->caps->secondary_msg = get_pcap_failure_secondary_error_message(open_status, open_status_str);\n                    }\n                    if_info->caps->status = open_status;\n                }\n\n                interface_opts_free(interface_opts);\n                g_free(interface_opts);\n            }\n        }\n\n        if (machine_readable) {\n            status = print_machine_readable_interfaces(if_list, caps_queries, print_statistics);\n        }\n        free_interface_list(if_list);\n        if (!print_statistics) {\n            exit_main(status);\n        }\n    }\n\n    /*\n     * \"-S\" requires no interface to be selected; it gives statistics\n     * for all interfaces.\n     */\n    if (print_statistics) {\n        status = print_statistics_loop(machine_readable);\n        exit_main(status);\n    }\n\n    if (set_chan) {\n        interface_options *interface_opts;\n\n        if (global_capture_opts.ifaces->len != 1) {\n            cmdarg_err(\"Need one interface\");\n            exit_main(2);\n        }\n\n        interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, 0);\n        status = set_80211_channel(interface_opts->name, set_chan_arg);\n        exit_main(status);\n    }\n\n    /*\n     * \"-L\", \"-d\", and capturing act on a particular interface, so we have to\n     * have an interface; if none was specified, pick a default.\n     */\n    status = capture_opts_default_iface_if_necessary(&global_capture_opts, NULL);\n    if (status != 0) {\n        /* cmdarg_err() already called .... */\n        exit_main(status);\n    }\n\n    if (caps_queries) {\n        /* Get the list of link-layer and/or timestamp types for the capture device. */\n        if_capabilities_t *caps;\n        cap_device_open_status open_status;\n        char *open_status_str;\n        unsigned  ii;\n\n        if (machine_readable) {\n            json_dumper dumper = {\n                .output_file = stdout,\n                .flags = JSON_DUMPER_FLAGS_NO_DEBUG,\n                // Don't abort on failure\n            };\n            json_dumper_begin_array(&dumper);\n            for (ii = 0; ii < global_capture_opts.ifaces->len; ii++) {\n                interface_options *interface_opts;\n\n                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, ii);\n\n                json_dumper_begin_object(&dumper);\n                json_dumper_set_member_name(&dumper, interface_opts->name);\n\n                json_dumper_begin_object(&dumper);\n\n                open_status = CAP_DEVICE_OPEN_NO_ERR;\n                caps = get_if_capabilities(interface_opts, &open_status, &open_status_str);\n                if (caps == NULL) {\n                    json_dumper_set_member_name(&dumper, \"status\");\n                    json_dumper_value_anyf(&dumper, \"%i\", open_status);\n                    json_dumper_set_member_name(&dumper, \"primary_msg\");\n                    json_dumper_value_string(&dumper, open_status_str);\n                    g_free(open_status_str);\n                } else {\n                    caps->status = open_status;\n                    print_machine_readable_if_capabilities(&dumper, caps, caps_queries);\n                    free_if_capabilities(caps);\n                }\n                json_dumper_end_object(&dumper);\n                json_dumper_end_object(&dumper);\n            }\n            json_dumper_end_array(&dumper);\n            if (json_dumper_finish(&dumper)) {\n                status = 0;\n                if (capture_child) {\n                    /* Let our parent know we succeeded. */\n                    sync_pipe_write_string_msg(sync_pipe_fd, SP_SUCCESS, NULL);\n                }\n            } else {\n                status = 2;\n                if (capture_child) {\n                    sync_pipe_write_errmsgs_to_parent(sync_pipe_fd, \"Unexpected JSON error\", \"\");\n                }\n            }\n        } else {\n            for (ii = 0; ii < global_capture_opts.ifaces->len; ii++) {\n                interface_options *interface_opts;\n\n                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, ii);\n\n                caps = get_if_capabilities(interface_opts, &open_status, &open_status_str);\n                if (caps == NULL) {\n                    if (capture_child) {\n                        char *error_msg = ws_strdup_printf(\"The capabilities of the capture device \"\n                                                    \"\\\"%s\\\" could not be obtained (%s)\",\n                                                    interface_opts->name, open_status_str);\n                        sync_pipe_write_errmsgs_to_parent(sync_pipe_fd, error_msg,\n                                get_pcap_failure_secondary_error_message(open_status, open_status_str));\n                        g_free(error_msg);\n                    }\n                    else {\n                        cmdarg_err(\"The capabilities of the capture device \"\n                                    \"\\\"%s\\\" could not be obtained (%s).\\n%s\",\n                                    interface_opts->name, open_status_str,\n                                    get_pcap_failure_secondary_error_message(open_status, open_status_str));\n                    }\n                    g_free(open_status_str);\n                    exit_main(2);\n                }\n\n                /* XXX: We might want to print also the interface name */\n                status = capture_opts_print_if_capabilities(caps,\n                                                            interface_opts,\n                                                            caps_queries);\n                free_if_capabilities(caps);\n                if (status != 0)\n                    break;\n            }\n        }\n        exit_main(status);\n    }\n\n#ifdef HAVE_PCAP_SET_TSTAMP_TYPE\n    for (j = 0; j < global_capture_opts.ifaces->len; j++) {\n        interface_options *interface_opts;\n\n        interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);\n        if (interface_opts->timestamp_type) {\n            interface_opts->timestamp_type_id = pcap_tstamp_type_name_to_val(interface_opts->timestamp_type);\n            if (interface_opts->timestamp_type_id < 0) {\n                cmdarg_err(\"Invalid argument to option: --time-stamp-type=%s\", interface_opts->timestamp_type);\n                exit_main(1);\n            }\n        }\n    }\n#endif\n\n    /* We're supposed to do a capture, or print the BPF code for a filter. */\n\n    /* Let the user know what interfaces were chosen. */\n    if (capture_child) {\n        for (j = 0; j < global_capture_opts.ifaces->len; j++) {\n            interface_options *interface_opts;\n\n            interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);\n            ws_debug(\"Interface: %s\\n\", interface_opts->name);\n        }\n    } else {\n        str = g_string_new(\"\");\n#ifdef _WIN32\n        if (global_capture_opts.ifaces->len < 2)\n#else\n        if (global_capture_opts.ifaces->len < 4)\n#endif\n        {\n            for (j = 0; j < global_capture_opts.ifaces->len; j++) {\n                interface_options *interface_opts;\n\n                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, j);\n                if (j > 0) {\n                    if (global_capture_opts.ifaces->len > 2) {\n                        g_string_append_printf(str, \",\");\n                    }\n                    g_string_append_printf(str, \" \");\n                    if (j == global_capture_opts.ifaces->len - 1) {\n                        g_string_append_printf(str, \"and \");\n                    }\n                }\n                if (interface_opts->ifname != NULL) {\n                    /*\n                     * Re-generate the display name based on the strins\n                     * we were handed.\n                     */\n                    g_free(interface_opts->display_name);\n                    if (interface_opts->descr != NULL) {\n#ifdef _WIN32\n                        interface_opts->display_name = ws_strdup_printf(\"%s\",\n                            interface_opts->descr);\n#else\n                        interface_opts->display_name = ws_strdup_printf(\"%s: %s\",\n                            interface_opts->descr, interface_opts->ifname);\n#endif\n                    } else {\n                        interface_opts->display_name = ws_strdup_printf(\"%s\",\n                            interface_opts->ifname);\n                    }\n                }\n                g_string_append_printf(str, \"'%s'\", interface_opts->display_name);\n            }\n        } else {\n            g_string_append_printf(str, \"%u interfaces\", global_capture_opts.ifaces->len);\n        }\n        if (!really_quiet)\n            fprintf(stderr, \"Capturing on %s\\n\", str->str);\n        g_string_free(str, TRUE);\n    }\n\n    /* Process the snapshot length, as that affects the generated BPF code. */\n    capture_opts_trim_snaplen(&global_capture_opts, MIN_PACKET_SIZE);\n\n    if (print_bpf_code) {\n        show_filter_code(&global_capture_opts);\n        exit_main(0);\n    }\n\n    /* We're supposed to do a capture.  Process the ring buffer arguments. */\n    capture_opts_trim_ring_num_files(&global_capture_opts);\n\n    /* flush stderr prior to starting the main capture loop */\n    fflush(stderr);\n\n    /* Now start the capture. */\n    if (capture_loop_start(&global_capture_opts, &stats_known, &stats) == true) {\n        /* capture ok */\n        exit_main(0);\n    } else {\n        /* capture failed */\n        exit_main(1);\n    }\n    return 0; /* never here, make compiler happy */\n}\n\nstatic void\ndumpcap_log_writer(const char *domain, enum ws_log_level level,\n                                    const char *file, long line, const char *func,\n                                    const char *fatal_msg _U_,\n                                    ws_log_manifest_t *mft,\n                                    const char *user_format, va_list user_ap,\n                                    void *user_data _U_)\n{\n    if (ws_log_msg_is_active(domain, level)) {\n        /* log messages go to stderr or    */\n        /* to parent especially formatted if dumpcap running as child. */\n#ifdef DEBUG_CHILD_DUMPCAP\n        va_list user_ap_copy;\n        va_copy(user_ap_copy, user_ap);\n#endif\n        if (capture_child) {\n            /* Format the log mesage as the numeric level, followed\n             * by a colon and then a string matching the standard log\n             * string. In the future perhaps we serialize file, line,\n             * and func (which can be NULL) instead.\n             */\n            GString *msg = g_string_new(NULL);\n            g_string_append_printf(msg, \"%u:\", level);\n            if (file != NULL) {\n                g_string_append_printf(msg, \"%s\", file);\n                if (line >= 0) {\n                    g_string_append_printf(msg, \":%ld\", line);\n                }\n            }\n            g_string_append(msg, \" --\");\n            if (func != NULL) {\n                g_string_append_printf(msg, \" %s():\", func);\n            }\n            g_string_append_c(msg, ' ');\n            g_string_append_vprintf(msg, user_format, user_ap);\n\n            sync_pipe_write_string_msg(sync_pipe_fd, SP_LOG_MSG, msg->str);\n            g_string_free(msg, TRUE);\n        } else {\n            ws_log_console_writer(domain, level, file, line, func, mft, user_format, user_ap);\n        }\n#ifdef DEBUG_CHILD_DUMPCAP\n        ws_log_file_writer(debug_log, domain, level, file, line, func, mft, user_format, user_ap_copy);\n        va_end(user_ap_copy);\n#endif\n    }\n}\n\n\n/****************************************************************************************************************/\n/* indication report routines */\n\n\nstatic void\nreport_packet_count(unsigned int packet_count)\n{\n    static unsigned int count = 0;\n\n    if (capture_child) {\n        ws_debug(\"Packets: %u\", packet_count);\n        sync_pipe_write_uint_msg(sync_pipe_fd, SP_PACKET_COUNT, packet_count);\n    } else {\n        count += packet_count;\n        fprintf(stderr, \"\\rPackets: %u \", count);\n        /* stderr could be line buffered */\n        fflush(stderr);\n    }\n}\n\nstatic void\nreport_new_capture_file(const char *filename)\n{\n    if (capture_child) {\n        ws_debug(\"File: %s\", filename);\n        if (global_ld.pcapng_passthrough) {\n            /* Save filename for sending SP_FILE to capture parent after SHB is passed-through */\n            ws_debug(\"Delaying SP_FILE until first SHB\");\n            report_capture_filename = filename;\n        } else {\n            sync_pipe_write_string_msg(sync_pipe_fd, SP_FILE, filename);\n        }\n    } else {\n#ifdef SIGINFO\n        /*\n         * Prevent a SIGINFO handler from writing to the standard error\n         * while we're doing so; instead, have it just set a flag telling\n         * us to print that information when we're done.\n         */\n        infodelay = true;\n#endif /* SIGINFO */\n        if (!really_quiet) {\n            fprintf(stderr, \"File: %s\\n\", filename);\n            /* stderr could be line buffered */\n            fflush(stderr);\n        }\n\n#ifdef SIGINFO\n        /*\n         * Allow SIGINFO handlers to write.\n         */\n        infodelay = false;\n\n        /*\n         * If a SIGINFO handler asked us to write out capture counts, do so.\n         */\n        if (infoprint)\n          report_counts_for_siginfo();\n#endif /* SIGINFO */\n    }\n}\n\nstatic void\nreport_cfilter_error(capture_options *capture_opts, unsigned i, const char *errmsg)\n{\n    interface_options *interface_opts;\n    char tmp[MSG_MAX_LENGTH+1+6];\n\n    if (i < capture_opts->ifaces->len) {\n        if (capture_child) {\n            snprintf(tmp, sizeof(tmp), \"%u:%s\", i, errmsg);\n            ws_debug(\"Capture filter error: %s\", errmsg);\n            sync_pipe_write_string_msg(sync_pipe_fd, SP_BAD_FILTER, tmp);\n        } else {\n            /*\n             * clopts_step_invalid_capfilter in test/suite-clopts.sh MUST match\n             * the error message below.\n             */\n            interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);\n            cmdarg_err(\n              \"Invalid capture filter \\\"%s\\\" for interface '%s'.\\n\"\n              \"\\n\"\n              \"That string isn't a valid capture filter (%s).\\n\"\n              \"See the User's Guide for a description of the capture filter syntax.\",\n              interface_opts->cfilter, interface_opts->name, errmsg);\n        }\n    }\n}\n\nstatic void\nreport_capture_error(const char *error_msg, const char *secondary_error_msg)\n{\n    if (capture_child) {\n        ws_debug(\"Primary Error: %s\", error_msg);\n        ws_debug(\"Secondary Error: %s\", secondary_error_msg);\n        sync_pipe_write_errmsgs_to_parent(sync_pipe_fd, error_msg, secondary_error_msg);\n    } else {\n        cmdarg_err(\"%s\", error_msg);\n        if (secondary_error_msg[0] != '\\0')\n          cmdarg_err_cont(\"%s\", secondary_error_msg);\n    }\n}\n\nstatic void\nreport_packet_drops(uint32_t received, uint32_t pcap_drops, uint32_t drops, uint32_t flushed, uint32_t ps_ifdrop, char *name)\n{\n    uint32_t total_drops = pcap_drops + drops + flushed;\n\n    if (capture_child) {\n        char* tmp = ws_strdup_printf(\"%u:%s\", total_drops, name);\n\n        ws_debug(\"Packets received/dropped on interface '%s': %u/%u (pcap:%u/dumpcap:%u/flushed:%u/ps_ifdrop:%u)\",\n            name, received, total_drops, pcap_drops, drops, flushed, ps_ifdrop);\n        sync_pipe_write_string_msg(sync_pipe_fd, SP_DROPS, tmp);\n        g_free(tmp);\n    } else {\n        if (!really_quiet) {\n            fprintf(stderr,\n                \"Packets received/dropped on interface '%s': %u/%u (pcap:%u/dumpcap:%u/flushed:%u/ps_ifdrop:%u) (%.1f%%)\\n\",\n                name, received, total_drops, pcap_drops, drops, flushed, ps_ifdrop,\n                received ? 100.0 * received / (received + total_drops) : 0.0);\n            /* stderr could be line buffered */\n            fflush(stderr);\n        }\n    }\n}\n\n\n/************************************************************************************************/\n/* signal_pipe handling */\n\n\n#ifdef _WIN32\nstatic bool\nsignal_pipe_check_running(void)\n{\n    /* any news from our parent? -> just stop the capture */\n    DWORD    avail = 0;\n    bool result;\n\n    /* if we are running standalone, no check required */\n    if (!capture_child) {\n        return true;\n    }\n\n    if (!sig_pipe_name || !sig_pipe_handle) {\n        /* This shouldn't happen */\n        ws_info(\"Signal pipe: No name or handle\");\n        return false;\n    }\n\n    /*\n     * XXX - We should have the process ID of the parent (from the \"-Z\" flag)\n     * at this point.  Should we check to see if the parent is still alive,\n     * e.g. by using OpenProcess?\n     */\n\n    result = PeekNamedPipe(sig_pipe_handle, NULL, 0, NULL, &avail, NULL);\n\n    if (!result || avail > 0) {\n        /* peek failed or some bytes really available */\n        /* (if not piping from stdin this would fail) */\n        ws_info(\"Signal pipe: Stop capture: %s\", sig_pipe_name);\n        ws_debug(\"Signal pipe: %s (%p) result: %u avail: %lu\", sig_pipe_name,\n            sig_pipe_handle, result, avail);\n        return false;\n    } else {\n        /* pipe ok and no bytes available */\n        return true;\n    }\n}\n#endif\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "editcap.c",
          "type": "blob",
          "size": 101.6591796875,
          "content": "/* editcap.c\n * Edit capture files.  We can delete packets, adjust timestamps, or\n * simply convert from one format to another format.\n *\n * Originally written by Richard Sharpe.\n * Improved by Guy Harris.\n * Further improved by Richard Sharpe.\n *\n * Copyright 2013, Richard Sharpe <realrichardsharpe[AT]gmail.com>\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <math.h>\n#include <stddef.h>\n\n#include <time.h>\n#include <glib.h>\n#include <gcrypt.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include <ws_exit_codes.h>\n#include <wsutil/ws_getopt.h>\n\n#include <wiretap/secrets-types.h>\n#include <wiretap/wtap.h>\n\n#include \"epan/etypes.h\"\n#include \"epan/dissectors/packet-ieee80211-radiotap-defs.h\"\n\n#ifdef _WIN32\n#include <process.h>    /* getpid */\n#include <winsock2.h>\n#endif\n\n#include <wsutil/clopts_common.h>\n#include <wsutil/cmdarg_err.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/file_util.h>\n#include <wsutil/plugins.h>\n#include <wsutil/privileges.h>\n#include <wsutil/strnatcmp.h>\n#include <wsutil/str_util.h>\n#include <cli_main.h>\n#include <wsutil/version_info.h>\n#include <wsutil/pint.h>\n#include <wsutil/strtoi.h>\n#include <wsutil/ws_assert.h>\n#include <wsutil/wslog.h>\n#include <wiretap/wtap_opttypes.h>\n\n#include \"ui/failure_message.h\"\n\n#include \"ringbuffer.h\" /* For RINGBUFFER_MAX_NUM_FILES */\n\n/* Additional exit codes */\n#define CANT_EXTRACT_PREFIX 2\n#define WRITE_ERROR         2\n#define DUMP_ERROR          2\n\n#define NANOSECS_PER_SEC 1000000000\n\n/*\n * Some globals so we can pass things to various routines\n */\n\nstruct select_item {\n    bool inclusive;\n    uint64_t first, second;\n};\n\n/*\n * Duplicate frame detection\n */\ntypedef struct _fd_hash_t {\n    uint8_t    digest[16];\n    uint32_t   len;\n    nstime_t   frame_time;\n} fd_hash_t;\n\n#define DEFAULT_DUP_DEPTH       5   /* Used with -d */\n#define MAX_DUP_DEPTH     1000000   /* the maximum window (and actual size of fd_hash[]) for de-duplication */\n\nstatic fd_hash_t fd_hash[MAX_DUP_DEPTH];\nstatic int       dup_window    = DEFAULT_DUP_DEPTH;\nstatic int       cur_dup_entry;\n\nstatic uint32_t  ignored_bytes;  /* Used with -I */\n\n#define ONE_BILLION 1000000000\n\n/* Weights of different errors we can introduce */\n/* We should probably make these command-line arguments */\n/* XXX - Should we add a bit-level error? */\n#define ERR_WT_BIT      5   /* Flip a random bit */\n#define ERR_WT_BYTE     5   /* Substitute a random byte */\n#define ERR_WT_ALNUM    5   /* Substitute a random character in [A-Za-z0-9] */\n#define ERR_WT_FMT      2   /* Substitute \"%s\" */\n#define ERR_WT_AA       1   /* Fill the remainder of the buffer with 0xAA */\n#define ERR_WT_TOTAL    (ERR_WT_BIT + ERR_WT_BYTE + ERR_WT_ALNUM + ERR_WT_FMT + ERR_WT_AA)\n\n#define ALNUM_CHARS     \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n#define ALNUM_LEN       (sizeof(ALNUM_CHARS) - 1)\n\nstruct time_adjustment {\n    nstime_t tv;\n    int is_negative;\n};\n\ntypedef struct _chop_t {\n    int len_begin;\n    int off_begin_pos;\n    int off_begin_neg;\n    int len_end;\n    int off_end_pos;\n    int off_end_neg;\n} chop_t;\n\n\n/* Table of user comments */\nGTree *frames_user_comments;\nGPtrArray *capture_comments;\n\n#define MAX_SELECTIONS 512\nstatic struct select_item     selectfrm[MAX_SELECTIONS];\nstatic unsigned               max_selected;\nstatic bool                   keep_em;\nstatic int                    out_file_type_subtype     = WTAP_FILE_TYPE_SUBTYPE_UNKNOWN;\nstatic int                    out_frame_type            = -2; /* Leave frame type alone */\nstatic bool                   verbose; /* Not so verbose         */\nstatic struct time_adjustment time_adj; /* no adjustment */\nstatic nstime_t               relative_time_window; /* de-dup time window */\nstatic double                 err_prob                  = -1.0;\nstatic nstime_t               starttime;\nstatic bool                   have_starttime;\nstatic nstime_t               stoptime;\nstatic bool                   have_stoptime;\nstatic bool                   check_startstop;\nstatic bool                   rem_vlan;\nstatic bool                   dup_detect;\nstatic bool                   dup_detect_by_time;\nstatic bool                   skip_radiotap;\nstatic bool                   discard_all_secrets;\nstatic bool                   discard_cap_comments;\nstatic bool                   set_unused;\nstatic bool                   discard_pkt_comments;\nstatic bool                   do_extract_secrets;\n\nstatic int                    do_strict_time_adjustment;\nstatic struct time_adjustment strict_time_adj; /* strict time adjustment */\nstatic nstime_t               previous_time; /* previous time */\n\nstatic const struct {\n    const char *str;\n    uint32_t    id;\n} secrets_types[] = {\n    { \"tls\",    SECRETS_TYPE_TLS },\n    { \"ssh\",    SECRETS_TYPE_SSH },\n    { \"wg\",     SECRETS_TYPE_WIREGUARD },\n    { \"opcua\",  SECRETS_TYPE_OPCUA },\n};\n\nstatic unsigned find_dct2000_real_data(const uint8_t *buf);\nstatic void handle_chopping(chop_t chop, wtap_packet_header *phdr,\n                            uint8_t **buf, bool adjlen);\n\nstatic char *\nabs_time_to_str_with_sec_resolution(const nstime_t *abs_time)\n{\n    struct tm *tmp;\n    char      *buf = (char *)g_malloc(16);\n\n    tmp = localtime(&abs_time->secs);\n\n    if (tmp) {\n        snprintf(buf, 16, \"%d%02d%02d%02d%02d%02d\",\n            tmp->tm_year + 1900,\n            tmp->tm_mon+1,\n            tmp->tm_mday,\n            tmp->tm_hour,\n            tmp->tm_min,\n            tmp->tm_sec);\n    } else {\n        buf[0] = '\\0';\n    }\n\n    return buf;\n}\n\nstatic char *\nfileset_get_filename_by_pattern(unsigned idx, const nstime_t *ts,\n                                char *fprefix, char *fsuffix)\n{\n    char  filenum[5+1];\n    char *timestr;\n    char *abs_str;\n\n    snprintf(filenum, sizeof(filenum), \"%05u\", idx % RINGBUFFER_MAX_NUM_FILES);\n    if (ts) {\n        timestr = abs_time_to_str_with_sec_resolution(ts);\n        abs_str = g_strconcat(fprefix, \"_\", filenum, \"_\", timestr, fsuffix, NULL);\n        g_free(timestr);\n    } else\n        abs_str = g_strconcat(fprefix, \"_\", filenum, fsuffix, NULL);\n\n    return abs_str;\n}\n\nstatic bool\nfileset_extract_prefix_suffix(const char *fname, char **fprefix, char **fsuffix, wtap_compression_type *compression_typep)\n{\n    char  *pfx, *last_pathsep;\n    char *save_file;\n    wtap_compression_type compression_type;\n\n    save_file = g_strdup(fname);\n    if (save_file == NULL) {\n        fprintf(stderr, \"editcap: Out of memory\\n\");\n        return false;\n    }\n\n    last_pathsep = strrchr(save_file, G_DIR_SEPARATOR);\n    if (last_pathsep == NULL) {\n        last_pathsep = save_file;\n    }\n    pfx = strrchr(last_pathsep, '.');\n    if (pfx != NULL) {\n        /* The pathname has a \".\" in it, and it's in the last component\n         * of the pathname (because there is either only one component,\n         * i.e. last_pathsep is null as there are no path separators,\n         * or the \".\" is after the path separator before the last\n         * component.\n\n         * Treat it as a separator between the rest of the file name and\n         * the file name suffix, and arrange that the names given to the\n         * ring buffer files have the specified suffix, i.e. put the\n         * changing part of the name *before* the suffix. */\n        pfx[0] = '\\0';\n        compression_type = wtap_extension_to_compression_type(pfx + 1);\n        if (compression_type != WTAP_UNKNOWN_COMPRESSION) {\n            char *pfx2 = strrchr(last_pathsep, '.');\n            if (pfx2 != NULL) {\n                pfx[0] = '.';\n                pfx = pfx2;\n                pfx[0] = '\\0';\n            }\n            if (compression_typep && *compression_typep == WTAP_UNKNOWN_COMPRESSION) {\n                *compression_typep = compression_type;\n            }\n            /* XXX - What if there's an extension matching a compression type\n             * and the passed in compression type is known but something else?\n             */\n        }\n        *fprefix = g_strdup(save_file);\n        pfx[0] = '.'; /* restore capfile_name */\n        *fsuffix = g_strdup(pfx);\n    } else {\n        /* Either there's no \".\" in the pathname, or it's in a directory\n         * component, so the last component has no suffix. */\n        *fprefix = g_strdup(save_file);\n        *fsuffix = NULL;\n    }\n    g_free(save_file);\n    return true;\n}\n\n/* Add a selection item, a simple parser for now */\nstatic bool\nadd_selection(char *sel, uint64_t* max_selection)\n{\n    char *locn;\n    char *next;\n\n    if (max_selected >= MAX_SELECTIONS) {\n        /* Let the user know we stopped selecting */\n        fprintf(stderr, \"Out of room for packet selections.\\n\");\n        return false;\n    }\n\n    if (verbose)\n        fprintf(stderr, \"Add_Selected: %s\\n\", sel);\n\n    if ((locn = strchr(sel, '-')) == NULL) { /* No dash, so a single number? */\n        if (verbose)\n            fprintf(stderr, \"Not inclusive ...\");\n\n        selectfrm[max_selected].inclusive = false;\n        selectfrm[max_selected].first = get_uint64(sel, \"packet number\");\n        if (selectfrm[max_selected].first > *max_selection)\n            *max_selection = selectfrm[max_selected].first;\n\n        if (verbose)\n            fprintf(stderr, \" %\" PRIu64 \"\\n\", selectfrm[max_selected].first);\n    } else {\n        if (verbose)\n            fprintf(stderr, \"Inclusive ...\");\n\n        *locn = '\\0';    /* split the range */\n        next = locn + 1;\n        selectfrm[max_selected].inclusive = true;\n        selectfrm[max_selected].first = get_uint64(sel, \"beginning of packet range\");\n        selectfrm[max_selected].second = get_uint64(next, \"end of packet range\");\n\n        if (selectfrm[max_selected].second == 0)\n        {\n            /* Not a valid number, presume all */\n            selectfrm[max_selected].second = *max_selection = UINT64_MAX;\n        }\n        else if (selectfrm[max_selected].second > *max_selection)\n            *max_selection = selectfrm[max_selected].second;\n\n        if (verbose)\n            fprintf(stderr, \" %\" PRIu64 \", %\" PRIu64 \"\\n\", selectfrm[max_selected].first,\n                   selectfrm[max_selected].second);\n    }\n\n    max_selected++;\n    return true;\n}\n\n/* Was the packet selected? */\n\nstatic bool\nselected(uint64_t recno)\n{\n    unsigned i;\n\n    for (i = 0; i < max_selected; i++) {\n        if (selectfrm[i].inclusive) {\n            if (selectfrm[i].first <= recno && selectfrm[i].second >= recno)\n                return true;\n        } else {\n            if (recno == selectfrm[i].first)\n                return true;\n        }\n    }\n\n    return false;\n}\n\nstatic bool\nset_time_adjustment(char *optarg_str_p)\n{\n    char   *frac, *end;\n    long    val;\n    size_t  frac_digits;\n\n    if (!optarg_str_p)\n        return true;\n\n    /* skip leading whitespace */\n    while (*optarg_str_p == ' ' || *optarg_str_p == '\\t')\n        optarg_str_p++;\n\n    /* check for a negative adjustment */\n    if (*optarg_str_p == '-') {\n        time_adj.is_negative = 1;\n        optarg_str_p++;\n    }\n\n    /* collect whole number of seconds, if any */\n    if (*optarg_str_p == '.') {         /* only fractional (i.e., .5 is ok) */\n        val  = 0;\n        frac = optarg_str_p;\n    } else {\n        val = strtol(optarg_str_p, &frac, 10);\n        if (frac == NULL || frac == optarg_str_p\n            || val == LONG_MIN || val == LONG_MAX) {\n            fprintf(stderr, \"editcap: \\\"%s\\\" isn't a valid time adjustment\\n\",\n                    optarg_str_p);\n            return false;\n        }\n        if (val < 0) {            /* implies '--' since we caught '-' above  */\n            fprintf(stderr, \"editcap: \\\"%s\\\" isn't a valid time adjustment\\n\",\n                    optarg_str_p);\n            return false;\n        }\n    }\n    time_adj.tv.secs = val;\n\n    /* now collect the partial seconds, if any */\n    if (*frac != '\\0') {             /* chars left, so get fractional part */\n        val = strtol(&(frac[1]), &end, 10);\n        /* if more than 9 fractional digits truncate to 9 */\n        if ((end - &(frac[1])) > 9) {\n            frac[10] = 't'; /* 't' for truncate */\n            val = strtol(&(frac[1]), &end, 10);\n        }\n        if (*frac != '.' || end == NULL || end == frac || val < 0\n            || val >= ONE_BILLION || val == LONG_MIN || val == LONG_MAX) {\n            fprintf(stderr, \"editcap: \\\"%s\\\" isn't a valid time adjustment\\n\",\n                    optarg_str_p);\n            return false;\n        }\n    } else {\n        return true;                     /* no fractional digits */\n    }\n\n    /* adjust fractional portion from fractional to numerator\n     * e.g., in \"1.5\" from 5 to 500000000 since .5*10^9 = 500000000 */\n    frac_digits = end - frac - 1;   /* fractional digit count (remember '.') */\n    while(frac_digits < 9) {    /* this is frac of 10^9 */\n        val *= 10;\n        frac_digits++;\n    }\n\n    time_adj.tv.nsecs = (int)val;\n    return true;\n}\n\nstatic bool\nset_strict_time_adj(char *optarg_str_p)\n{\n    char   *frac, *end;\n    long    val;\n    size_t  frac_digits;\n\n    if (!optarg_str_p)\n        return true;\n\n    /* skip leading whitespace */\n    while (*optarg_str_p == ' ' || *optarg_str_p == '\\t')\n        optarg_str_p++;\n\n    /*\n     * check for a negative adjustment\n     * A negative strict adjustment value is a flag\n     * to adjust all frames by the specified delta time.\n     */\n    if (*optarg_str_p == '-') {\n        strict_time_adj.is_negative = 1;\n        optarg_str_p++;\n    }\n\n    /* collect whole number of seconds, if any */\n    if (*optarg_str_p == '.') {         /* only fractional (i.e., .5 is ok) */\n        val  = 0;\n        frac = optarg_str_p;\n    } else {\n        val = strtol(optarg_str_p, &frac, 10);\n        if (frac == NULL || frac == optarg_str_p\n            || val == LONG_MIN || val == LONG_MAX) {\n            fprintf(stderr, \"editcap: \\\"%s\\\" isn't a valid time adjustment\\n\",\n                    optarg_str_p);\n            return false;\n        }\n        if (val < 0) {            /* implies '--' since we caught '-' above  */\n            fprintf(stderr, \"editcap: \\\"%s\\\" isn't a valid time adjustment\\n\",\n                    optarg_str_p);\n            return false;\n        }\n    }\n    strict_time_adj.tv.secs = val;\n\n    /* now collect the partial seconds, if any */\n    if (*frac != '\\0') {             /* chars left, so get fractional part */\n        val = strtol(&(frac[1]), &end, 10);\n        /* if more than 9 fractional digits truncate to 9 */\n        if ((end - &(frac[1])) > 9) {\n            frac[10] = 't'; /* 't' for truncate */\n            val = strtol(&(frac[1]), &end, 10);\n        }\n        if (*frac != '.' || end == NULL || end == frac || val < 0\n            || val >= ONE_BILLION || val == LONG_MIN || val == LONG_MAX) {\n            fprintf(stderr, \"editcap: \\\"%s\\\" isn't a valid time adjustment\\n\",\n                    optarg_str_p);\n            return false;\n        }\n    } else {\n        return true;                     /* no fractional digits */\n    }\n\n    /* adjust fractional portion from fractional to numerator\n     * e.g., in \"1.5\" from 5 to 500000000 since .5*10^9 = 500000000 */\n    frac_digits = end - frac - 1;   /* fractional digit count (remember '.') */\n    while(frac_digits < 9) {    /* this is frac of 10^9 */\n        val *= 10;\n        frac_digits++;\n    }\n\n    strict_time_adj.tv.nsecs = (int)val;\n    return true;\n}\n\nstatic bool\nset_rel_time(char *optarg_str_p)\n{\n    char   *frac, *end;\n    long    val;\n    size_t  frac_digits;\n\n    if (!optarg_str_p)\n        return true;\n\n    /* skip leading whitespace */\n    while (*optarg_str_p == ' ' || *optarg_str_p == '\\t')\n        optarg_str_p++;\n\n    /* ignore negative adjustment  */\n    if (*optarg_str_p == '-')\n        optarg_str_p++;\n\n    /* collect whole number of seconds, if any */\n    if (*optarg_str_p == '.') {         /* only fractional (i.e., .5 is ok) */\n        val  = 0;\n        frac = optarg_str_p;\n    } else {\n        val = strtol(optarg_str_p, &frac, 10);\n        if (frac == NULL || frac == optarg_str_p\n            || val == LONG_MIN || val == LONG_MAX) {\n            fprintf(stderr, \"1: editcap: \\\"%s\\\" isn't a valid rel time value\\n\",\n                    optarg_str_p);\n            return false;\n        }\n        if (val < 0) {            /* implies '--' since we caught '-' above  */\n            fprintf(stderr, \"2: editcap: \\\"%s\\\" isn't a valid rel time value\\n\",\n                    optarg_str_p);\n            return false;\n        }\n    }\n    relative_time_window.secs = val;\n\n    /* now collect the partial seconds, if any */\n    if (*frac != '\\0') {             /* chars left, so get fractional part */\n        val = strtol(&(frac[1]), &end, 10);\n        /* if more than 9 fractional digits truncate to 9 */\n        if ((end - &(frac[1])) > 9) {\n            frac[10] = 't'; /* 't' for truncate */\n            val = strtol(&(frac[1]), &end, 10);\n        }\n        if (*frac != '.' || end == NULL || end == frac || val < 0\n            || val >= ONE_BILLION || val == LONG_MIN || val == LONG_MAX) {\n            fprintf(stderr, \"3: editcap: \\\"%s\\\" isn't a valid rel time value\\n\",\n                    optarg_str_p);\n            return false;\n        }\n    } else {\n        return true;                     /* no fractional digits */\n    }\n\n    /* adjust fractional portion from fractional to numerator\n     * e.g., in \"1.5\" from 5 to 500000000 since .5*10^9 = 500000000 */\n    frac_digits = end - frac - 1;   /* fractional digit count (remember '.') */\n    while(frac_digits < 9) {    /* this is frac of 10^9 */\n        val *= 10;\n        frac_digits++;\n    }\n\n    relative_time_window.nsecs = (int)val;\n    return true;\n}\n\n#define SLL_ADDRLEN 8 /* length of address field */\nstruct sll_header {\n\tuint16_t sll_pkttype;\t\t/* packet type */\n\tuint16_t sll_hatype;\t\t/* link-layer address type */\n\tuint16_t sll_halen;\t\t/* link-layer address length */\n\tuint8_t  sll_addr[SLL_ADDRLEN];\t/* link-layer address */\n\tuint16_t sll_protocol;\t\t/* protocol */\n};\n\nstruct sll2_header {\n\tuint16_t sll2_protocol;\t\t\t/* protocol */\n\tuint16_t sll2_reserved_mbz;\t\t/* reserved - must be zero */\n\tuint32_t sll2_if_index;\t\t\t/* 1-based interface index */\n\tuint16_t sll2_hatype;\t\t\t/* link-layer address type */\n\tuint8_t  sll2_pkttype;\t\t\t/* packet type */\n\tuint8_t  sll2_halen;\t\t\t/* link-layer address length */\n\tuint8_t  sll2_addr[SLL_ADDRLEN];\t/* link-layer address */\n};\n\n#define VLAN_SIZE 4\nstatic void\nsll_remove_vlan_info(uint8_t* fd, uint32_t* len) {\n    if (pntoh16(fd + offsetof(struct sll_header, sll_protocol)) == ETHERTYPE_VLAN) {\n        int rest_len;\n        /* point to start of vlan */\n        fd = fd + offsetof(struct sll_header, sll_protocol);\n        /* bytes to read after vlan info */\n        rest_len = *len - (offsetof(struct sll_header, sll_protocol) + VLAN_SIZE);\n        /* remove vlan info from packet */\n        memmove(fd, fd + VLAN_SIZE, rest_len);\n        *len -= 4;\n    }\n}\n\n\n\nstatic void\nsll_set_unused_info(uint8_t* fd) {\n    uint32_t ha_len;\n    ha_len = pntoh16(fd + offsetof(struct sll_header, sll_halen));\n\n    if (ha_len < SLL_ADDRLEN) {\n        int unused;\n        unused = SLL_ADDRLEN - ha_len;\n        /* point to end of sll_ddr */\n        fd = fd + offsetof(struct sll_header, sll_addr) + ha_len;\n        /* set zeros in the unused data */\n        memset(fd, 0, unused);\n    }\n}\n\nstatic void\nsll2_set_unused_info(uint8_t* fd) {\n    uint32_t ha_len;\n    ha_len = *(fd + offsetof(struct sll2_header, sll2_halen));\n\n    if (ha_len < SLL_ADDRLEN) {\n        int unused;\n        unused = SLL_ADDRLEN - ha_len;\n        /* point to end of sll2_addr */\n        fd = fd + offsetof(struct sll2_header, sll2_addr) + ha_len;\n        /* set zeros in the unused data */\n        memset(fd, 0, unused);\n    }\n}\n\nstatic void\nremove_vlan_info(wtap_packet_header *phdr, uint8_t* fd) {\n    switch (phdr->pkt_encap) {\n        case WTAP_ENCAP_SLL:\n            sll_remove_vlan_info(fd, &phdr->caplen);\n            break;\n        default:\n            /* no support for current pkt_encap */\n            break;\n    }\n}\n\nstatic void\nset_unused_info(const wtap_packet_header *phdr, uint8_t* fd) {\n    switch (phdr->pkt_encap) {\n        case WTAP_ENCAP_SLL:\n            sll_set_unused_info(fd);\n            break;\n        case WTAP_ENCAP_SLL2:\n            sll2_set_unused_info(fd);\n            break;\n        default:\n            /* no support for current pkt_encap */\n            break;\n    }\n}\n\nstatic bool\nis_duplicate(uint8_t* fd, uint32_t len) {\n    int i;\n    const struct ieee80211_radiotap_header* tap_header;\n\n    /*Hint to ignore some bytes at the start of the frame for the digest calculation(-I option) */\n    uint32_t offset = ignored_bytes;\n    uint32_t new_len;\n    uint8_t *new_fd;\n\n    if (len <= ignored_bytes) {\n        offset = 0;\n    }\n\n    /* Get the size of radiotap header and use that as offset (-p option) */\n    if (skip_radiotap == true) {\n        tap_header = (const struct ieee80211_radiotap_header*)fd;\n        offset = pletoh16(&tap_header->it_len);\n        if (offset >= len)\n            offset = 0;\n    }\n\n    new_fd  = &fd[offset];\n    new_len = len - (offset);\n\n    cur_dup_entry++;\n    if (cur_dup_entry >= dup_window)\n        cur_dup_entry = 0;\n\n    /* Calculate our digest */\n    gcry_md_hash_buffer(GCRY_MD_MD5, fd_hash[cur_dup_entry].digest, new_fd, new_len);\n\n    fd_hash[cur_dup_entry].len = len;\n\n    /* Look for duplicates */\n    for (i = 0; i < dup_window; i++) {\n        if (i == cur_dup_entry)\n            continue;\n\n        if (fd_hash[i].len == fd_hash[cur_dup_entry].len\n            && memcmp(fd_hash[i].digest, fd_hash[cur_dup_entry].digest, 16) == 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nstatic bool\nis_duplicate_rel_time(uint8_t* fd, uint32_t len, const nstime_t *current) {\n    int i;\n\n    /*Hint to ignore some bytes at the start of the frame for the digest calculation(-I option) */\n    uint32_t offset = ignored_bytes;\n    uint32_t new_len;\n    uint8_t *new_fd;\n\n    if (len <= ignored_bytes) {\n        offset = 0;\n    }\n\n    new_fd  = &fd[offset];\n    new_len = len - (offset);\n\n    cur_dup_entry++;\n    if (cur_dup_entry >= dup_window)\n        cur_dup_entry = 0;\n\n    /* Calculate our digest */\n    gcry_md_hash_buffer(GCRY_MD_MD5, fd_hash[cur_dup_entry].digest, new_fd, new_len);\n\n    fd_hash[cur_dup_entry].len = len;\n    fd_hash[cur_dup_entry].frame_time.secs = current->secs;\n    fd_hash[cur_dup_entry].frame_time.nsecs = current->nsecs;\n\n    /*\n     * Look for relative time related duplicates.\n     * This is hopefully a reasonably efficient mechanism for\n     * finding duplicates by rel time in the fd_hash[] cache.\n     * We check starting from the most recently added hash\n     * entries and work backwards towards older packets.\n     * This approach allows the dup test to be terminated\n     * when the relative time of a cached entry is found to\n     * be beyond the dup time window.\n     *\n     * Of course this assumes that the input trace file is\n     * \"well-formed\" in the sense that the packet timestamps are\n     * in strict chronologically increasing order (which is NOT\n     * always the case!!).\n     *\n     * The fd_hash[] table was deliberately created large (1,000,000).\n     * Looking for time related duplicates in large trace files with\n     * non-fractional dup time window values can potentially take\n     * a long time to complete.\n     */\n\n    for (i = cur_dup_entry - 1;; i--) {\n        nstime_t delta;\n        int cmp;\n\n        if (i < 0)\n            i = dup_window - 1;\n\n        if (i == cur_dup_entry) {\n            /*\n             * We've decremented back to where we started.\n             * Check no more!\n             */\n            break;\n        }\n\n        if (nstime_is_unset(&(fd_hash[i].frame_time))) {\n            /*\n             * We've decremented to an unused fd_hash[] entry.\n             * Check no more!\n             */\n            break;\n        }\n\n        nstime_delta(&delta, current, &fd_hash[i].frame_time);\n\n        if (delta.secs < 0 || delta.nsecs < 0) {\n            /*\n             * A negative delta implies that the current packet\n             * has an absolute timestamp less than the cached packet\n             * that it is being compared to.  This is NOT a normal\n             * situation since trace files usually have packets in\n             * chronological order (oldest to newest).\n             *\n             * There are several possible ways to deal with this:\n             * 1. 'continue' dup checking with the next cached frame.\n             * 2. 'break' from looking for a duplicate of the current frame.\n             * 3. Take the absolute value of the delta and see if that\n             * falls within the specified dup time window.\n             *\n             * Currently this code does option 1.  But it would pretty\n             * easy to add yet-another-editcap-option to select one of\n             * the other behaviors for dealing with out-of-sequence\n             * packets.\n             */\n            continue;\n        }\n\n        cmp = nstime_cmp(&delta, &relative_time_window);\n\n        if (cmp > 0) {\n            /*\n             * The delta time indicates that we are now looking at\n             * cached packets beyond the specified dup time window.\n             * Check no more!\n             */\n            break;\n        } else if (fd_hash[i].len == fd_hash[cur_dup_entry].len\n                   && memcmp(fd_hash[i].digest, fd_hash[cur_dup_entry].digest, 16) == 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nstatic void\nmutate_packet_data(wtap_rec *rec, uint8_t *buf, uint32_t change_offset, uint64_t count)\n{\n    uint32_t caplen;\n    unsigned real_data_start = 0;\n\n    caplen = 0;\n\n    switch (rec->rec_type) {\n\n    case REC_TYPE_PACKET:\n        caplen = rec->rec_header.packet_header.caplen;\n\n        /*\n         * Protect some non-protocol data.\n         * XXX - any reason not to fuzz this part?\n         */\n        if (rec->rec_header.packet_header.pkt_encap == WTAP_ENCAP_CATAPULT_DCT2000)\n            real_data_start = find_dct2000_real_data(buf);\n        break;\n\n    case REC_TYPE_FT_SPECIFIC_EVENT:\n    case REC_TYPE_FT_SPECIFIC_REPORT:\n        caplen = rec->rec_header.ft_specific_header.record_len;\n        break;\n\n    case REC_TYPE_SYSCALL:\n        caplen = rec->rec_header.syscall_header.event_filelen;\n        break;\n\n    case REC_TYPE_SYSTEMD_JOURNAL_EXPORT:\n        caplen = rec->rec_header.systemd_journal_export_header.record_len;\n        break;\n\n    default:\n        /* We don't mutate anything else. */\n        return;\n    }\n\n    if (change_offset > caplen) {\n        fprintf(stderr, \"change offset %u is longer than caplen %u in packet %\" PRIu64 \"\\n\",\n            change_offset, caplen, count);\n        return;\n    }\n\n    real_data_start += change_offset;\n\n    for (unsigned i = real_data_start; i < caplen; i++) {\n        if (rand() <= err_prob * RAND_MAX) {\n            int err_type = rand() / (RAND_MAX / ERR_WT_TOTAL + 1);\n\n            if (err_type < ERR_WT_BIT) {\n                buf[i] ^= 1 << (rand() / (RAND_MAX / 8 + 1));\n                err_type = ERR_WT_TOTAL;\n            } else {\n                err_type -= ERR_WT_BYTE;\n            }\n\n            if (err_type < ERR_WT_BYTE) {\n                buf[i] = rand() / (RAND_MAX / 255 + 1);\n                err_type = ERR_WT_TOTAL;\n            } else {\n                err_type -= ERR_WT_BYTE;\n            }\n\n            if (err_type < ERR_WT_ALNUM) {\n                buf[i] = ALNUM_CHARS[rand() / (RAND_MAX / ALNUM_LEN + 1)];\n                err_type = ERR_WT_TOTAL;\n            } else {\n                err_type -= ERR_WT_ALNUM;\n            }\n\n            if (err_type < ERR_WT_FMT) {\n                if (i < caplen - 2)\n                    (void) g_strlcpy((char*) &buf[i], \"%s\", 2);\n                err_type = ERR_WT_TOTAL;\n            } else {\n                err_type -= ERR_WT_FMT;\n            }\n\n            if (err_type < ERR_WT_AA) {\n                for (unsigned j = i; j < caplen; j++)\n                    buf[j] = 0xAA;\n                i = caplen;\n            }\n        }\n    }\n}\n\nstatic void\nprint_usage(FILE *output)\n{\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: editcap [options] ... <infile> <outfile> [ <packet#>[-<packet#>] ... ]\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"<infile> and <outfile> must both be present; use '-' for stdin or stdout.\\n\");\n    fprintf(output, \"A single packet or a range of packets can be selected.\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Packet selection:\\n\");\n    fprintf(output, \"  -r                     keep the selected packets; default is to delete them.\\n\");\n    fprintf(output, \"  -A <start time>        only read packets whose timestamp is after (or equal\\n\");\n    fprintf(output, \"                         to) the given time.\\n\");\n    fprintf(output, \"  -B <stop time>         only read packets whose timestamp is before the\\n\");\n    fprintf(output, \"                         given time.\\n\");\n    fprintf(output, \"                         Time format for -A/-B options is\\n\");\n    fprintf(output, \"                         YYYY-MM-DDThh:mm:ss[.nnnnnnnnn][Z|+-hh:mm]\\n\");\n    fprintf(output, \"                         Unix epoch timestamps are also supported.\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Duplicate packet removal:\\n\");\n    fprintf(output, \"  --novlan               remove vlan info from packets before checking for duplicates.\\n\");\n    fprintf(output, \"  -d                     remove packet if duplicate (window == %d).\\n\", DEFAULT_DUP_DEPTH);\n    fprintf(output, \"  -D <dup window>        remove packet if duplicate; configurable <dup window>.\\n\");\n    fprintf(output, \"                         Valid <dup window> values are 0 to %d.\\n\", MAX_DUP_DEPTH);\n    fprintf(output, \"                         NOTE: A <dup window> of 0 with -V (verbose option) is\\n\");\n    fprintf(output, \"                         useful to print MD5 hashes.\\n\");\n    fprintf(output, \"  -w <dup time window>   remove packet if duplicate packet is found EQUAL TO OR\\n\");\n    fprintf(output, \"                         LESS THAN <dup time window> prior to current packet.\\n\");\n    fprintf(output, \"                         A <dup time window> is specified in relative seconds\\n\");\n    fprintf(output, \"                         (e.g. 0.000001).\\n\");\n    fprintf(output, \"           NOTE: The use of the 'Duplicate packet removal' options with\\n\");\n    fprintf(output, \"           other editcap options except -V may not always work as expected.\\n\");\n    fprintf(output, \"           Specifically the -r, -t or -S options will very likely NOT have the\\n\");\n    fprintf(output, \"           desired effect if combined with the -d, -D or -w.\\n\");\n    fprintf(output, \"  --skip-radiotap-header skip radiotap header when checking for packet duplicates.\\n\");\n    fprintf(output, \"                         Useful when processing packets captured by multiple radios\\n\");\n    fprintf(output, \"                         on the same channel in the vicinity of each other.\\n\");\n    fprintf(output, \"  --set-unused           set unused byts to zero in sll link addr.\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Packet manipulation:\\n\");\n    fprintf(output, \"  -s <snaplen>           truncate each packet to max. <snaplen> bytes of data.\\n\");\n    fprintf(output, \"  -C [offset:]<choplen>  chop each packet by <choplen> bytes. Positive values\\n\");\n    fprintf(output, \"                         chop at the packet beginning, negative values at the\\n\");\n    fprintf(output, \"                         packet end. If an optional offset precedes the length,\\n\");\n    fprintf(output, \"                         then the bytes chopped will be offset from that value.\\n\");\n    fprintf(output, \"                         Positive offsets are from the packet beginning,\\n\");\n    fprintf(output, \"                         negative offsets are from the packet end. You can use\\n\");\n    fprintf(output, \"                         this option more than once, allowing up to 2 chopping\\n\");\n    fprintf(output, \"                         regions within a packet provided that at least 1\\n\");\n    fprintf(output, \"                         choplen is positive and at least 1 is negative.\\n\");\n    fprintf(output, \"  -L                     adjust the frame (i.e. reported) length when chopping\\n\");\n    fprintf(output, \"                         and/or snapping.\\n\");\n    fprintf(output, \"  -t <time adjustment>   adjust the timestamp of each packet.\\n\");\n    fprintf(output, \"                         <time adjustment> is in relative seconds (e.g. -0.5).\\n\");\n    fprintf(output, \"  -S <strict adjustment> adjust timestamp of packets if necessary to ensure\\n\");\n    fprintf(output, \"                         strict chronological increasing order. The <strict\\n\");\n    fprintf(output, \"                         adjustment> is specified in relative seconds with\\n\");\n    fprintf(output, \"                         values of 0 or 0.000001 being the most reasonable.\\n\");\n    fprintf(output, \"                         A negative adjustment value will modify timestamps so\\n\");\n    fprintf(output, \"                         that each packet's delta time is the absolute value\\n\");\n    fprintf(output, \"                         of the adjustment specified. A value of -0 will set\\n\");\n    fprintf(output, \"                         all packets to the timestamp of the first packet.\\n\");\n    fprintf(output, \"  -E <error probability> set the probability (between 0.0 and 1.0 incl.) that\\n\");\n    fprintf(output, \"                         a particular packet byte will be randomly changed.\\n\");\n    fprintf(output, \"  -o <change offset>     When used in conjunction with -E, skip some bytes from the\\n\");\n    fprintf(output, \"                         beginning of the packet. This allows one to preserve some\\n\");\n    fprintf(output, \"                         bytes, in order to have some headers untouched.\\n\");\n    fprintf(output, \"  --seed <seed>          When used in conjunction with -E, set the seed to use for\\n\");\n    fprintf(output, \"                         the pseudo-random number generator. This allows one to\\n\");\n    fprintf(output, \"                         repeat a particular sequence of errors.\\n\");\n    fprintf(output, \"  -I <bytes to ignore>   ignore the specified number of bytes at the beginning\\n\");\n    fprintf(output, \"                         of the frame during MD5 hash calculation, unless the\\n\");\n    fprintf(output, \"                         frame is too short, then the full frame is used.\\n\");\n    fprintf(output, \"                         Useful to remove duplicated packets taken on\\n\");\n    fprintf(output, \"                         several routers (different mac addresses for\\n\");\n    fprintf(output, \"                         example).\\n\");\n    fprintf(output, \"                         e.g. -I 26 in case of Ether/IP will ignore\\n\");\n    fprintf(output, \"                         ether(14) and IP header(20 - 4(src ip) - 4(dst ip)).\\n\");\n    fprintf(output, \"  -a <framenum>:<comment> Add or replace comment for given frame number\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Output File(s):\\n\");\n    fprintf(output, \"                         if the output file(s) have the .gz extension, then\\n\");\n    fprintf(output, \"                         gzip compression will be used\\n\");\n    fprintf(output, \"  -c <packets per file>  split the packet output to different files based on\\n\");\n    fprintf(output, \"                         uniform packet counts with a maximum of\\n\");\n    fprintf(output, \"                         <packets per file> each.\\n\");\n    fprintf(output, \"  -i <seconds per file>  split the packet output to different files based on\\n\");\n    fprintf(output, \"                         uniform time intervals with a maximum of\\n\");\n    fprintf(output, \"                         <seconds per file> each.\\n\");\n    fprintf(output, \"  -F <capture type>      set the output file type; default is pcapng.\\n\");\n    fprintf(output, \"                         An empty \\\"-F\\\" option will list the file types.\\n\");\n    fprintf(output, \"  -T <encap type>        set the output file encapsulation type; default is the\\n\");\n    fprintf(output, \"                         same as the input file. An empty \\\"-T\\\" option will\\n\");\n    fprintf(output, \"                         list the encapsulation types.\\n\");\n    fprintf(output, \"  --inject-secrets <type>,<file>  Insert decryption secrets from <file>. List\\n\");\n    fprintf(output, \"                         supported secret types with \\\"--inject-secrets help\\\".\\n\");\n    fprintf(output, \"  --extract-secrets      Extract decryption secrets into the output file instead.\\n\");\n    fprintf(output, \"                         Incompatible with other options besides -V.\\n\");\n    fprintf(output, \"  --discard-all-secrets  Discard all decryption secrets from the input file\\n\");\n    fprintf(output, \"                         when writing the output file.  Does not discard\\n\");\n    fprintf(output, \"                         secrets added by \\\"--inject-secrets\\\" in the same\\n\");\n    fprintf(output, \"                         command line.\\n\");\n    fprintf(output, \"  --capture-comment <comment>\\n\");\n    fprintf(output, \"                         Add a capture file comment, if supported.\\n\");\n    fprintf(output, \"  --discard-capture-comment\\n\");\n    fprintf(output, \"                         Discard capture file comments from the input file\\n\");\n    fprintf(output, \"                         when writing the output file.  Does not discard\\n\");\n    fprintf(output, \"                         comments added by \\\"--capture-comment\\\" in the same\\n\");\n    fprintf(output, \"                         command line.\\n\");\n    fprintf(output, \"  --discard-packet-comments\\n\");\n    fprintf(output, \"                         Discard all packet comments from the input file\\n\");\n    fprintf(output, \"                         when writing the output file.  Does not discard\\n\");\n    fprintf(output, \"                         comments added by \\\"-a\\\" in the same command line.\\n\");\n    fprintf(output, \"  --compress <type>      Compress the output file using the type compression format.\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Miscellaneous:\\n\");\n    fprintf(output, \"  -h, --help             display this help and exit.\\n\");\n    fprintf(output, \"  -V                     verbose output.\\n\");\n    fprintf(output, \"                         If -V is used with any of the 'Duplicate Packet\\n\");\n    fprintf(output, \"                         Removal' options (-d, -D or -w) then Packet lengths\\n\");\n    fprintf(output, \"                         and MD5 hashes are printed to standard-error.\\n\");\n    fprintf(output, \"  -v, --version          print version information and exit.\\n\");\n}\n\nstruct string_elem {\n    const char *sstr;   /* The short string */\n    const char *lstr;   /* The long string */\n};\n\nstatic int\nstring_nat_compare(const void *a, const void *b)\n{\n    return ws_ascii_strnatcmp(((const struct string_elem *)a)->sstr,\n        ((const struct string_elem *)b)->sstr);\n}\n\nstatic void\nstring_elem_print(void *data, void *stream_ptr)\n{\n    fprintf((FILE *) stream_ptr, \"    %s - %s\\n\",\n        ((struct string_elem *)data)->sstr,\n        ((struct string_elem *)data)->lstr);\n}\n\nstatic void\nlist_capture_types(FILE *stream) {\n    GArray *writable_type_subtypes;\n\n    fprintf(stream, \"editcap: The available capture file types for the \\\"-F\\\" flag are:\\n\");\n    writable_type_subtypes = wtap_get_writable_file_types_subtypes(FT_SORT_BY_NAME);\n    for (unsigned i = 0; i < writable_type_subtypes->len; i++) {\n        int ft = g_array_index(writable_type_subtypes, int, i);\n        fprintf(stream, \"    %s - %s\\n\", wtap_file_type_subtype_name(ft),\n                wtap_file_type_subtype_description(ft));\n    }\n    g_array_free(writable_type_subtypes, TRUE);\n}\n\nstatic void\nlist_encap_types(FILE *stream) {\n    int i;\n    struct string_elem *encaps;\n    GSList *list = NULL;\n\n    encaps = g_new(struct string_elem, WTAP_NUM_ENCAP_TYPES);\n    fprintf(stream, \"editcap: The available encapsulation types for the \\\"-T\\\" flag are:\\n\");\n    for (i = 0; i < WTAP_NUM_ENCAP_TYPES; i++) {\n        encaps[i].sstr = wtap_encap_name(i);\n        if (encaps[i].sstr != NULL) {\n            encaps[i].lstr = wtap_encap_description(i);\n            list = g_slist_insert_sorted(list, &encaps[i], string_nat_compare);\n        }\n    }\n    g_slist_foreach(list, string_elem_print, stream);\n    g_slist_free(list);\n    g_free(encaps);\n}\n\nstatic void\nlist_output_compression_types(void) {\n    GSList *output_compression_types;\n\n    fprintf(stderr, \"editcap: The available output compress type(s) for the \\\"--compress\\\" flag are:\\n\");\n    output_compression_types = wtap_get_all_output_compression_type_names_list();\n    for (GSList *compression_type = output_compression_types;\n        compression_type != NULL;\n        compression_type = g_slist_next(compression_type)) {\n            fprintf(stderr, \"   %s\\n\", (const char *)compression_type->data);\n        }\n\n    g_slist_free(output_compression_types);\n}\n\nstatic void\nlist_secrets_types(FILE *stream)\n{\n    for (unsigned i = 0; i < G_N_ELEMENTS(secrets_types); i++) {\n        fprintf(stream, \"    %s\\n\", secrets_types[i].str);\n    }\n}\n\nstatic uint32_t\nlookup_secrets_type(const char *type)\n{\n    for (unsigned i = 0; i < G_N_ELEMENTS(secrets_types); i++) {\n        if (!strcmp(secrets_types[i].str, type)) {\n            return secrets_types[i].id;\n        }\n    }\n    return 0;\n}\n\nstatic void\nvalidate_secrets_file(const char *filename, uint32_t secrets_type, const char *data)\n{\n    if (secrets_type == SECRETS_TYPE_TLS) {\n        /*\n         * A key log file is unlikely going to look like either:\n         * - a PEM-encoded private key file.\n         * - a BER-encoded PKCS #12 file (\"PFX file\"). (Look for a Constructed\n         *   SEQUENCE tag, e.g. bytes 0x30 which happens to be ASCII '0'.)\n         */\n        if (g_str_has_prefix(data, \"-----BEGIN \") || data[0] == 0x30) {\n            fprintf(stderr,\n                    \"editcap: Warning: \\\"%s\\\" is not a key log file, but an unsupported private key file. Decryption will not work.\\n\",\n                    filename);\n        }\n    }\n}\n\nstatic int\nframenum_compare(const void *a, const void *b, void *user_data _U_)\n{\n    uint64_t *frame_a = (uint64_t*)a;\n    uint64_t *frame_b = (uint64_t*)b;\n    if (*frame_a < *frame_b)\n        return -1;\n\n    if (*frame_a > *frame_b)\n        return 1;\n\n    return 0;\n}\n\nstatic wtap_dumper *\neditcap_dump_open(const char *filename, const wtap_dump_params *params,\n                  GArray *idbs_seen, int *err, char **err_info,\n                  wtap_compression_type compression_type)\n{\n    wtap_dumper *pdh;\n\n    if (strcmp(filename, \"-\") == 0) {\n        /* Write to the standard output. */\n        pdh = wtap_dump_open_stdout(out_file_type_subtype, compression_type,\n                                    params, err, err_info);\n    } else {\n        pdh = wtap_dump_open(filename, out_file_type_subtype, compression_type,\n                             params, err, err_info);\n    }\n    if (pdh == NULL)\n        return NULL;\n\n    /*\n     * If the output file supports identifying the interfaces on which\n     * packets arrive, add all the IDBs we've seen so far.\n     *\n     * That mean that the abstract interface provided by libwiretap\n     * involves WTAP_BLOCK_IF_ID_AND_INFO blocks.\n     */\n    if (wtap_file_type_subtype_supports_block(wtap_dump_file_type_subtype(pdh),\n                                              WTAP_BLOCK_IF_ID_AND_INFO) != BLOCK_NOT_SUPPORTED) {\n        for (unsigned i = 0; i < idbs_seen->len; i++) {\n            wtap_block_t if_data = g_array_index(idbs_seen, wtap_block_t, i);\n            wtap_block_t if_data_copy;\n\n            /*\n             * Make a copy of this IDB, so that we can change the\n             * encapsulation type without trashing the original.\n             */\n            if_data_copy = wtap_block_make_copy(if_data);\n\n            /*\n             * If an encapsulation type was specified, override the\n             * encapsulation type of the interface.\n             */\n            if (out_frame_type != -2) {\n                wtapng_if_descr_mandatory_t *if_mand;\n\n                if_mand = (wtapng_if_descr_mandatory_t *)wtap_block_get_mandatory_data(if_data_copy);\n                if_mand->wtap_encap = out_frame_type;\n            }\n\n            /*\n             * Add this possibly-modified IDB to the file to which\n             * we're currently writing.\n             */\n            if (!wtap_dump_add_idb(pdh, if_data_copy, err, err_info)) {\n                int close_err;\n                char *close_err_info;\n\n                wtap_dump_close(pdh, NULL, &close_err, &close_err_info);\n                g_free(close_err_info);\n                wtap_block_unref(if_data_copy);\n                return NULL;\n            }\n\n            /*\n             * Release the copy - wtap_dump_add_idb() makes its own copy.\n             */\n            wtap_block_unref(if_data_copy);\n        }\n    }\n\n    return pdh;\n}\n\nstatic bool\nprocess_new_idbs(wtap *wth, wtap_dumper *pdh, GArray *idbs_seen,\n                 int *err, char **err_info)\n{\n    wtap_block_t if_data;\n\n    while ((if_data = wtap_get_next_interface_description(wth)) != NULL) {\n        /*\n         * Only add interface blocks if the output file supports (meaning\n         * *requires*) them.\n         *\n         * That mean that the abstract interface provided by libwiretap\n         * involves WTAP_BLOCK_IF_ID_AND_INFO blocks.\n         */\n        if (pdh != NULL && wtap_file_type_subtype_supports_block(wtap_dump_file_type_subtype(pdh),\n                                                  WTAP_BLOCK_IF_ID_AND_INFO) != BLOCK_NOT_SUPPORTED) {\n            wtap_block_t if_data_copy;\n\n            /*\n             * Make a copy of this IDB, so that we can change the\n             * encapsulation type without trashing the original.\n             */\n            if_data_copy = wtap_block_make_copy(if_data);\n\n            /*\n             * If an encapsulation type was specified, override the\n             * encapsulation type of the interface.\n             */\n            if (out_frame_type != -2) {\n                wtapng_if_descr_mandatory_t *if_mand;\n\n                if_mand = (wtapng_if_descr_mandatory_t *)wtap_block_get_mandatory_data(if_data_copy);\n                if_mand->wtap_encap = out_frame_type;\n            }\n\n            /*\n             * Add this possibly-modified IDB to the file to which\n             * we're currently writing.\n             */\n            if (!wtap_dump_add_idb(pdh, if_data_copy, err, err_info))\n                return false;\n\n            /*\n             * Release the copy - wtap_dump_add_idb() makes its own copy.\n             */\n            wtap_block_unref(if_data_copy);\n\n            /*\n             * Also add an unmodified copy to the set of IDBs we've seen,\n             * in case we start writing to another file (which would be\n             * of the same type as the current file, and thus will also\n             * require interface IDs).\n             */\n            if_data_copy = wtap_block_make_copy(if_data);\n            g_array_append_val(idbs_seen, if_data_copy);\n        }\n    }\n    return true;\n}\n\nstatic int\nextract_secrets(wtap *wth, char* filename, int *err, char **err_info)\n{\n    wtap_rec                     read_rec;\n    int64_t       offset;\n    char         *fprefix            = NULL;\n    char         *fsuffix            = NULL;\n\n    /* Read all of the packets in turn */\n    wtap_rec_init(&read_rec, 1514);\n    while (wtap_read(wth, &read_rec, err, err_info, &offset)) {\n        /* Do we want to respect the max packet number on the command line?\n         * Probably more confusing than it's worth, because a user might\n         * not know if a DSB is at the end of the file.\n         */\n        wtap_rec_reset(&read_rec);\n    }\n    wtap_rec_cleanup(&read_rec);\n\n    wtapng_dsb_mandatory_t *dsb;\n    if (strcmp(filename, \"-\") == 0) {\n        /* Sure. Why not. */\n        for (unsigned dsb_num = 0; dsb_num < wtap_file_get_num_dsbs(wth); ++dsb_num) {\n            dsb = (wtapng_dsb_mandatory_t *)wtap_block_get_mandatory_data(wtap_file_get_dsb(wth, dsb_num));\n            if (verbose) {\n                fprintf(stderr, \"Writing secrets type \\\"%s\\\" (0x%08x) to standard out.\\n\",\n                        secrets_type_description(dsb->secrets_type), dsb->secrets_type);\n            }\n            if (fwrite(dsb->secrets_data, 1, dsb->secrets_len, stdout) != dsb->secrets_len) {\n                return WRITE_ERROR;\n            }\n        }\n    } else if (wtap_file_get_num_dsbs(wth) == 1) {\n        dsb = (wtapng_dsb_mandatory_t *)wtap_block_get_mandatory_data(wtap_file_get_dsb(wth, 0));\n        if (verbose) {\n            fprintf(stderr, \"Writing secrets type \\\"%s\\\" (0x%08x) to \\\"%s\\\".\\n\",\n                    secrets_type_description(dsb->secrets_type), dsb->secrets_type,\n                    filename);\n        }\n        if (!write_file_binary_mode(filename, dsb->secrets_data, dsb->secrets_len)) {\n            return WRITE_ERROR;\n        }\n    } else {\n        /* We have more than one DSB, so write multiple files. While for some\n         * types, we could combine the information from different DSBs togther\n         * (and most of those are text-based, so we'd want to write in text\n         * mode so that the line endings are uniform (which makes testing\n         * harder), we don't know that for every type.\n         */\n        if (!fileset_extract_prefix_suffix(filename, &fprefix, &fsuffix, NULL)) {\n            return CANT_EXTRACT_PREFIX;\n        }\n        char *extract_filename;\n        for (unsigned dsb_num = 0; dsb_num < wtap_file_get_num_dsbs(wth); ++dsb_num) {\n            dsb = (wtapng_dsb_mandatory_t *)wtap_block_get_mandatory_data(wtap_file_get_dsb(wth, dsb_num));\n            extract_filename = fileset_get_filename_by_pattern(dsb_num, NULL, fprefix, fsuffix);\n            if (verbose) {\n                fprintf(stderr, \"Writing secrets type \\\"%s\\\" (0x%08x) to \\\"%s\\\".\\n\",\n                        secrets_type_description(dsb->secrets_type), dsb->secrets_type,\n                        extract_filename);\n            }\n            if (!write_file_binary_mode(extract_filename, dsb->secrets_data, dsb->secrets_len)) {\n                /* write_file_binary_mode already reports failures */\n                g_free(extract_filename);\n                g_free(fprefix);\n                g_free(fsuffix);\n\n                return WRITE_ERROR;\n            }\n            g_free(extract_filename);\n        }\n        g_free(fprefix);\n        g_free(fsuffix);\n    }\n    return EXIT_SUCCESS;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char         *configuration_init_error;\n    wtap         *wth = NULL;\n    int           i, read_err, write_err;\n    char         *read_err_info, *write_err_info;\n    int           opt;\n\n#define LONGOPT_NO_VLAN                 LONGOPT_BASE_APPLICATION+1\n#define LONGOPT_SKIP_RADIOTAP_HEADER    LONGOPT_BASE_APPLICATION+2\n#define LONGOPT_SEED                    LONGOPT_BASE_APPLICATION+3\n#define LONGOPT_INJECT_SECRETS          LONGOPT_BASE_APPLICATION+4\n#define LONGOPT_DISCARD_ALL_SECRETS     LONGOPT_BASE_APPLICATION+5\n#define LONGOPT_CAPTURE_COMMENT         LONGOPT_BASE_APPLICATION+6\n#define LONGOPT_DISCARD_CAPTURE_COMMENT LONGOPT_BASE_APPLICATION+7\n#define LONGOPT_SET_UNUSED              LONGOPT_BASE_APPLICATION+8\n#define LONGOPT_DISCARD_PACKET_COMMENTS LONGOPT_BASE_APPLICATION+9\n#define LONGOPT_EXTRACT_SECRETS         LONGOPT_BASE_APPLICATION+10\n#define LONGOPT_COMPRESS                LONGOPT_BASE_APPLICATION+11\n\n    static const struct ws_option long_options[] = {\n        {\"novlan\", ws_no_argument, NULL, LONGOPT_NO_VLAN},\n        {\"skip-radiotap-header\", ws_no_argument, NULL, LONGOPT_SKIP_RADIOTAP_HEADER},\n        {\"seed\", ws_required_argument, NULL, LONGOPT_SEED},\n        {\"inject-secrets\", ws_required_argument, NULL, LONGOPT_INJECT_SECRETS},\n        {\"discard-all-secrets\", ws_no_argument, NULL, LONGOPT_DISCARD_ALL_SECRETS},\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        {\"capture-comment\", ws_required_argument, NULL, LONGOPT_CAPTURE_COMMENT},\n        {\"discard-capture-comment\", ws_no_argument, NULL, LONGOPT_DISCARD_CAPTURE_COMMENT},\n        {\"set-unused\", ws_no_argument, NULL, LONGOPT_SET_UNUSED},\n        {\"discard-packet-comments\", ws_no_argument, NULL, LONGOPT_DISCARD_PACKET_COMMENTS},\n        {\"extract-secrets\", ws_no_argument, NULL, LONGOPT_EXTRACT_SECRETS},\n        {\"compress\", ws_required_argument, NULL, LONGOPT_COMPRESS},\n        {0, 0, 0, 0 }\n    };\n\n    char         *p;\n    uint32_t      snaplen            = 0; /* No limit               */\n    chop_t        chop               = {0, 0, 0, 0, 0, 0}; /* No chop */\n    bool          adjlen             = false;\n    wtap_dumper  *pdh                = NULL;\n    GArray       *idbs_seen          = NULL;\n    uint64_t      count              = 1;\n    uint64_t      duplicate_count    = 0;\n    int64_t       data_offset;\n    uint8_t      *buf;\n    uint64_t      read_count         = 0;\n    uint64_t      split_packet_count = 0;\n    uint64_t      written_count      = 0;\n    char         *filename           = NULL;\n    bool          ts_okay;\n    nstime_t      secs_per_block     = NSTIME_INIT_UNSET;\n    int           block_cnt          = 0;\n    nstime_t      block_next         = NSTIME_INIT_UNSET;\n    char         *fprefix            = NULL;\n    char         *fsuffix            = NULL;\n    uint32_t      change_offset      = 0;\n    uint64_t      max_packet_number  = 0;\n    GArray       *dsb_types          = NULL;\n    GPtrArray    *dsb_filenames      = NULL;\n    wtap_rec                     read_rec;\n    wtap_dump_params             params = WTAP_DUMP_PARAMS_INIT;\n    char                        *shb_user_appl;\n    int                          ret = EXIT_SUCCESS;\n    bool                         valid_seed = false;\n    unsigned int                 seed = 0;\n    bool                         edit_option_specified = false;\n    wtap_compression_type compression_type   = WTAP_UNKNOWN_COMPRESSION;\n\n    /* Set the program name. */\n    g_set_prgname(\"editcap\");\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n    memset(&read_rec, 0, sizeof read_rec);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, WS_EXIT_INVALID_OPTION);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n#ifdef _WIN32\n    create_app_running_mutex();\n#endif /* _WIN32 */\n\n    /*\n     * Get credential information for later use.\n     */\n    init_process_policies();\n\n    /*\n     * Attempt to get the pathname of the directory containing the\n     * executable file.\n     */\n    configuration_init_error = configuration_init(argv[0]);\n    if (configuration_init_error != NULL) {\n        cmdarg_err(\"Can't get pathname of directory containing the editcap program: %s.\",\n                configuration_init_error);\n        g_free(configuration_init_error);\n    }\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"Editcap\", NULL, NULL);\n\n    init_report_failure_message(\"editcap\");\n\n    wtap_init(true);\n\n    /* Process the options */\n    while ((opt = ws_getopt_long(argc, argv, \"a:A:B:c:C:dD:E:F:hi:I:Lo:rs:S:t:T:vVw:\", long_options, NULL)) != -1) {\n        if (opt != LONGOPT_EXTRACT_SECRETS && opt != 'V') {\n            edit_option_specified = true;\n        }\n        switch (opt) {\n        case LONGOPT_NO_VLAN:\n        {\n            rem_vlan = true;\n            break;\n        }\n\n        case LONGOPT_SKIP_RADIOTAP_HEADER:\n        {\n            skip_radiotap = true;\n            break;\n        }\n\n        case LONGOPT_SEED:\n        {\n            if (sscanf(ws_optarg, \"%u\", &seed) != 1) {\n                cmdarg_err(\"\\\"%s\\\" isn't a valid seed\", ws_optarg);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            valid_seed = true;\n            break;\n        }\n\n        case LONGOPT_INJECT_SECRETS:\n        {\n            uint32_t secrets_type_id = 0;\n            const char *secrets_filename = NULL;\n            if (strcmp(\"help\", ws_optarg) == 0) {\n                list_secrets_types(stdout);\n                goto clean_exit;\n            }\n            char **splitted = g_strsplit(ws_optarg, \",\", 2);\n            if (splitted[0] && splitted[0][0] != '\\0') {\n                secrets_type_id = lookup_secrets_type(splitted[0]);\n                if (secrets_type_id == 0) {\n                    cmdarg_err(\"\\\"%s\\\" isn't a valid secrets type\", splitted[0]);\n                    g_strfreev(splitted);\n                    ret = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                secrets_filename = splitted[1];\n            } else {\n                cmdarg_err(\"no secrets type was specified for --inject-secrets\");\n                g_strfreev(splitted);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            if (!dsb_filenames) {\n                dsb_types = g_array_new(FALSE, FALSE, sizeof(uint32_t));\n                dsb_filenames = g_ptr_array_new_with_free_func(g_free);\n            }\n            g_array_append_val(dsb_types, secrets_type_id);\n            g_ptr_array_add(dsb_filenames, g_strdup(secrets_filename));\n            g_strfreev(splitted);\n            break;\n        }\n\n        case LONGOPT_DISCARD_ALL_SECRETS:\n        {\n            discard_all_secrets = true;\n            break;\n        }\n\n        case LONGOPT_CAPTURE_COMMENT:\n        {\n            /*\n             * Make sure this would fit in a pcapng option.\n             *\n             * XXX - 65535 is the maximum size for an option in pcapng;\n             * what if another capture file format supports larger\n             * comments?\n             */\n            if (strlen(ws_optarg) > 65535) {\n                /* It doesn't fit.  Tell the user and give up. */\n                cmdarg_err(\"Capture comment %u is too large to save in a capture file.\",\n                           capture_comments->len + 1);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n\n            /* pcapng supports multiple comments, so support them here too.\n             */\n            if (!capture_comments) {\n                capture_comments = g_ptr_array_new_with_free_func(g_free);\n            }\n            g_ptr_array_add(capture_comments, g_strdup(ws_optarg));\n            break;\n        }\n\n        case LONGOPT_DISCARD_CAPTURE_COMMENT:\n        {\n            discard_cap_comments = true;\n            break;\n        }\n\n        case LONGOPT_SET_UNUSED:\n        {\n            set_unused = true;\n            break;\n        }\n\n        case LONGOPT_DISCARD_PACKET_COMMENTS:\n        {\n            discard_pkt_comments = true;\n            break;\n        }\n\n        case LONGOPT_EXTRACT_SECRETS:\n        {\n            do_extract_secrets = true;\n            /* XXX - Would it make sense to specify what types of secrets\n             * to extract (or any)?\n             */\n            break;\n        }\n\n        case LONGOPT_COMPRESS:\n        {\n            compression_type = wtap_name_to_compression_type(ws_optarg);\n            if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n                cmdarg_err(\"\\\"%s\\\" isn't a valid output compression mode\",\n                            ws_optarg);\n                list_output_compression_types();\n                goto clean_exit;\n            }\n            break;\n        }\n\n        case 'a':\n        {\n            uint64_t frame_number;\n            int string_start_index = 0;\n\n            if ((sscanf(ws_optarg, \"%\" SCNu64 \":%n\", &frame_number, &string_start_index) < 1) || (string_start_index == 0)) {\n                cmdarg_err(\"\\\"%s\\\" isn't a valid <frame>:<comment>\", ws_optarg);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n\n            /*\n             * Make sure this would fit in a pcapng option.\n             *\n             * XXX - 65535 is the maximum size for an option in pcapng;\n             * what if another capture file format supports larger\n             * comments?\n             */\n            if (strlen(ws_optarg+string_start_index) > 65535) {\n                /* It doesn't fit.  Tell the user and give up. */\n                cmdarg_err(\"A comment for frame %\" PRIu64 \" is too large to save in a capture file.\",\n                           frame_number);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n\n            /* Lazily create the table */\n            if (!frames_user_comments) {\n                frames_user_comments = g_tree_new_full(framenum_compare, NULL, g_free, g_free);\n            }\n\n            /* Insert this entry (framenum -> comment) */\n            uint64_t *frame_p = g_new(uint64_t, 1);\n            *frame_p = frame_number;\n            g_tree_replace(frames_user_comments, frame_p, g_strdup(ws_optarg+string_start_index));\n            break;\n        }\n\n        case 'A':\n        case 'B':\n        {\n            nstime_t in_time;\n\n            check_startstop = true;\n            if ((NULL != iso8601_to_nstime(&in_time, ws_optarg, ISO8601_DATETIME)) || (NULL != unix_epoch_to_nstime(&in_time, ws_optarg))) {\n                if (opt == 'A') {\n                    nstime_copy(&starttime, &in_time);\n                    have_starttime = true;\n                } else {\n                    nstime_copy(&stoptime, &in_time);\n                    have_stoptime = true;\n                }\n                break;\n            }\n            else {\n                cmdarg_err(\"\\\"%s\\\" isn't a valid date and time\", ws_optarg);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n        }\n\n        case 'c':\n            split_packet_count = get_nonzero_uint64(ws_optarg, \"packet count\");\n            break;\n\n        case 'C':\n        {\n            int choplen = 0, chopoff = 0;\n\n            switch (sscanf(ws_optarg, \"%d:%d\", &chopoff, &choplen)) {\n            case 1: /* only the chop length was specified */\n                choplen = chopoff;\n                chopoff = 0;\n                break;\n\n            case 2: /* both an offset and chop length was specified */\n                break;\n\n            default:\n                cmdarg_err(\"\\\"%s\\\" isn't a valid chop length or offset:length\", ws_optarg);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n                break;\n            }\n\n            if (choplen > 0) {\n                chop.len_begin += choplen;\n                if (chopoff > 0)\n                    chop.off_begin_pos += chopoff;\n                else\n                    chop.off_begin_neg += chopoff;\n            } else if (choplen < 0) {\n                chop.len_end += choplen;\n                if (chopoff > 0)\n                    chop.off_end_pos += chopoff;\n                else\n                    chop.off_end_neg += chopoff;\n            }\n            break;\n        }\n\n        case 'd':\n            dup_detect = true;\n            dup_detect_by_time = false;\n            dup_window = DEFAULT_DUP_DEPTH;\n            break;\n\n        case 'D':\n            dup_detect = true;\n            dup_detect_by_time = false;\n            dup_window = get_uint32(ws_optarg, \"duplicate window\");\n            if (dup_window > MAX_DUP_DEPTH) {\n                cmdarg_err(\"\\\"%d\\\" duplicate window value must be between 0 and %d inclusive.\",\n                        dup_window, MAX_DUP_DEPTH);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            break;\n\n        case 'E':\n            err_prob = g_ascii_strtod(ws_optarg, &p);\n            if (p == ws_optarg || err_prob < 0.0 || err_prob > 1.0) {\n                cmdarg_err(\"probability \\\"%s\\\" must be between 0.0 and 1.0\", ws_optarg);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            break;\n\n        case 'F':\n            out_file_type_subtype = wtap_name_to_file_type_subtype(ws_optarg);\n            if (out_file_type_subtype < 0) {\n                cmdarg_err(\"\\\"%s\\\" isn't a valid capture file type\\n\", ws_optarg);\n                list_capture_types(stderr);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            break;\n\n        case 'h':\n            show_help_header(\"Edit and/or translate the format of capture files.\");\n            print_usage(stdout);\n            goto clean_exit;\n            break;\n\n        case 'i': /* break capture file based on time interval */\n        {\n            double spb = get_positive_double(ws_optarg, \"time interval\");\n            if (spb == 0.0) {\n              cmdarg_err(\"The specified interval is zero\");\n              ret = WS_EXIT_INVALID_OPTION;\n              goto clean_exit;\n            }\n\n            double spb_int, spb_frac;\n            spb_frac = modf(spb, &spb_int);\n            secs_per_block.secs = (time_t) spb_int;\n            secs_per_block.nsecs = (int) (NANOSECS_PER_SEC * spb_frac);\n        }\n            break;\n\n        case 'I': /* ignored_bytes at the beginning of the frame for duplications removal */\n            ignored_bytes = get_uint32(ws_optarg, \"number of bytes to ignore\");\n            break;\n\n        case 'L':\n            adjlen = true;\n            break;\n\n        case 'o':\n            change_offset = get_uint32(ws_optarg, \"change offset\");\n            break;\n\n        case 'r':\n            if (keep_em) {\n                cmdarg_err(\"-r was specified twice\");\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            keep_em = true;\n            break;\n\n        case 's':\n            snaplen = get_nonzero_uint32(ws_optarg, \"snapshot length\");\n            break;\n\n        case 'S':\n            if (!set_strict_time_adj(ws_optarg)) {\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            do_strict_time_adjustment = true;\n            break;\n\n        case 't':\n            if (!set_time_adjustment(ws_optarg)) {\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            break;\n\n        case 'T':\n            out_frame_type = wtap_name_to_encap(ws_optarg);\n            if (out_frame_type < 0) {\n                cmdarg_err(\"\\\"%s\\\" isn't a valid encapsulation type\\n\", ws_optarg);\n                list_encap_types(stderr);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            break;\n\n        case 'V':\n            if (verbose) {\n                cmdarg_err(\"-V was specified twice\");\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            verbose = true;\n            break;\n\n        case 'v':\n            show_version();\n            goto clean_exit;\n            break;\n\n        case 'w':\n            dup_detect = false;\n            dup_detect_by_time = true;\n            dup_window = MAX_DUP_DEPTH;\n            if (!set_rel_time(ws_optarg)) {\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            break;\n\n        case '?':              /* Bad options - print usage */\n        default:\n            switch(ws_optopt) {\n            case'F':\n                list_capture_types(stdout);\n                break;\n            case'T':\n                list_encap_types(stdout);\n                break;\n            case LONGOPT_COMPRESS:\n                    list_output_compression_types();\n                    break;\n            default:\n                print_usage(stderr);\n                ret = WS_EXIT_INVALID_OPTION;\n                break;\n            }\n            goto clean_exit;\n            break;\n        }\n    } /* processing command-line options */\n\n#ifdef DEBUG\n    fprintf(stderr, \"Optind = %i, argc = %i\\n\", ws_optind, argc);\n#endif\n\n    if ((argc - ws_optind) < 2) {\n        print_usage(stderr);\n        ret = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (out_file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_UNKNOWN) {\n      /* default to pcapng   */\n      out_file_type_subtype = wtap_pcapng_file_type_subtype();\n    }\n\n    if (split_packet_count != 0 || !nstime_is_unset(&secs_per_block)) {\n        if (!fileset_extract_prefix_suffix(argv[ws_optind+1], &fprefix, &fsuffix, &compression_type)) {\n            ret = CANT_EXTRACT_PREFIX;\n            goto clean_exit;\n        }\n    } else if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n        /* An explicitly specified compression type overrides filename\n         * magic. (Should we allow specifying \"no\" compression with, e.g.\n         * a \".gz\" extension?) */\n        const char *sfx = strrchr(argv[ws_optind+1], '.');\n        if (sfx) {\n            compression_type = wtap_extension_to_compression_type(sfx + 1);\n        }\n    }\n\n    if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n        compression_type = WTAP_UNCOMPRESSED;\n    }\n\n    if (!wtap_can_write_compression_type(compression_type)) {\n        cmdarg_err(\"Output files can't be written as %s\",\n                wtap_compression_type_description(compression_type));\n        ret = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (compression_type != WTAP_UNCOMPRESSED && !wtap_dump_can_compress(out_file_type_subtype)) {\n        cmdarg_err(\"The file format %s can't be written to output compressed format\",\n            wtap_file_type_subtype_name(out_file_type_subtype));\n        ret = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (err_prob >= 0.0) {\n        if (!valid_seed) {\n            seed = (unsigned int) (time(NULL) + ws_getpid());\n        }\n        if (verbose) {\n            fprintf(stderr, \"Using seed %u\\n\", seed);\n        }\n        srand(seed);\n    }\n\n    if (have_starttime && have_stoptime &&\n        nstime_cmp(&starttime, &stoptime) > 0) {\n        cmdarg_err(\"start time is after the stop time\");\n        ret = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (split_packet_count != 0 && !nstime_is_unset(&secs_per_block)) {\n        cmdarg_err(\"can't split on both packet count and time interval\");\n        cmdarg_err_cont(\"at the same time\");\n        ret = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    wth = wtap_open_offline(argv[ws_optind], WTAP_TYPE_AUTO, &read_err, &read_err_info, false);\n\n    if (!wth) {\n        cfile_open_failure_message(argv[ws_optind], read_err, read_err_info);\n        ret = WS_EXIT_INVALID_FILE;\n        goto clean_exit;\n    }\n\n    if (verbose) {\n        fprintf(stderr, \"File %s is a %s capture file.\\n\", argv[ws_optind],\n                wtap_file_type_subtype_description(wtap_file_type_subtype(wth)));\n    }\n\n    if (skip_radiotap) {\n        if (ignored_bytes != 0) {\n            cmdarg_err(\"can't skip radiotap headers and %d byte(s)\", ignored_bytes);\n            cmdarg_err_cont(\"at the start of packet at the same time\");\n            ret = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n\n        if (wtap_file_encap(wth) != WTAP_ENCAP_IEEE_802_11_RADIOTAP) {\n            cmdarg_err(\"can't skip radiotap header because input file has non-radiotap packets\");\n            if (wtap_file_encap(wth) == WTAP_ENCAP_PER_PACKET) {\n                cmdarg_err_cont(\"expected '%s', not all packets are necessarily that type\",\n                        wtap_encap_description(WTAP_ENCAP_IEEE_802_11_RADIOTAP));\n            } else {\n                cmdarg_err_cont(\"expected '%s', packets are '%s'\",\n                        wtap_encap_description(WTAP_ENCAP_IEEE_802_11_RADIOTAP),\n                        wtap_encap_description(wtap_file_encap(wth)));\n            }\n            ret = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n    }\n\n    if (do_extract_secrets) {\n        if (edit_option_specified) {\n            cmdarg_err(\"can't extract secrets and use other options at the same time\");\n            ret = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n        if (compression_type != WTAP_UNCOMPRESSED) {\n            cmdarg_err(\"compression isn't supported for extracting secrets\");\n            ret = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n        ret = extract_secrets(wth, argv[ws_optind+1], &read_err, &read_err_info);\n\n        if (read_err != 0) {\n            /* Print a message noting that the read failed somewhere along the\n             * line. */\n            cfile_read_failure_message(argv[ws_optind], read_err, read_err_info);\n        }\n        goto clean_exit;\n    }\n\n    wtap_dump_params_init_no_idbs(&params, wth);\n\n    /*\n     * Discard any secrets we read in while opening the file.\n     */\n    if (discard_all_secrets) {\n        wtap_dump_params_discard_decryption_secrets(&params);\n    }\n\n    /*\n     * Discard capture file comments.\n     */\n    if (discard_cap_comments) {\n        for (unsigned b = 0; b < params.shb_hdrs->len; b++) {\n            wtap_block_t shb = g_array_index(params.shb_hdrs, wtap_block_t, b);\n            while (WTAP_OPTTYPE_SUCCESS == wtap_block_remove_nth_option_instance(shb, OPT_COMMENT, 0)) {\n                ;\n            }\n        }\n    }\n\n    /*\n     * Add new capture file comments.\n     */\n    if (capture_comments != NULL) {\n        for (unsigned b = 0; b < params.shb_hdrs->len; b++) {\n            wtap_block_t shb = g_array_index(params.shb_hdrs, wtap_block_t, b);\n            for (unsigned c = 0; c < capture_comments->len; c++) {\n                char *comment = (char *)g_ptr_array_index(capture_comments, c);\n                wtap_block_add_string_option(shb, OPT_COMMENT, comment, strlen(comment));\n            }\n        }\n    }\n\n    if (dsb_filenames) {\n        for (unsigned k = 0; k < dsb_filenames->len; k++) {\n            uint32_t secrets_type_id = g_array_index(dsb_types, uint32_t, k);\n            const char *secrets_filename = (const char *)g_ptr_array_index(dsb_filenames, k);\n            char *data;\n            size_t data_len;\n            wtap_block_t block;\n            wtapng_dsb_mandatory_t *dsb;\n            GError *err = NULL;\n\n            if (!g_file_get_contents(secrets_filename, &data, &data_len, &err)) {\n                cmdarg_err(\"\\\"%s\\\" could not be read: %s\", secrets_filename, err->message);\n                g_clear_error(&err);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            if (data_len == 0) {\n                cmdarg_err(\"\\\"%s\\\" is an empty file, ignoring\", secrets_filename);\n                g_free(data);\n                continue;\n            }\n            if (data_len >= INT_MAX) {\n                cmdarg_err(\"\\\"%s\\\" is too large, ignoring\", secrets_filename);\n                g_free(data);\n                continue;\n            }\n\n            /* Warn for badly formatted files, but proceed anyway. */\n            validate_secrets_file(secrets_filename, secrets_type_id, data);\n\n            block = wtap_block_create(WTAP_BLOCK_DECRYPTION_SECRETS);\n            dsb = (wtapng_dsb_mandatory_t *)wtap_block_get_mandatory_data(block);\n            dsb->secrets_type = secrets_type_id;\n            dsb->secrets_len = (unsigned)data_len;\n            dsb->secrets_data = data;\n            if (params.dsbs_initial == NULL) {\n                params.dsbs_initial = g_array_new(FALSE, FALSE, sizeof(wtap_block_t));\n            }\n            g_array_append_val(params.dsbs_initial, block);\n        }\n    }\n\n    /*\n     * If an encapsulation type was specified, override the encapsulation\n     * type of the input file.\n     */\n    if (out_frame_type != -2)\n        params.encap = out_frame_type;\n\n    /*\n     * If a snapshot length was specified, and it's less than the snapshot\n     * length of the input file, override the snapshot length of the input\n     * file.\n     */\n    if (snaplen != 0 && snaplen < wtap_snapshot_length(wth))\n        params.snaplen = snaplen;\n\n    /*\n     * Now process the arguments following the input and output file\n     * names, if any; they specify packets to include/exclude.\n     */\n    for (i = ws_optind + 2; i < argc; i++)\n        if (add_selection(argv[i], &max_packet_number) == false)\n            break;\n\n    if (keep_em && max_selected == 0) {\n        cmdarg_err(\"must specify packets to keep when using -r\");\n        ret = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (!keep_em)\n        max_packet_number = UINT64_MAX;\n\n    if (dup_detect || dup_detect_by_time) {\n        for (i = 0; i < dup_window; i++) {\n            memset(&fd_hash[i].digest, 0, 16);\n            fd_hash[i].len = 0;\n            nstime_set_unset(&fd_hash[i].frame_time);\n        }\n    }\n\n    /* Set up an array of all IDBs seen */\n    idbs_seen = g_array_new(FALSE, FALSE, sizeof(wtap_block_t));\n\n    /* Read all of the packets in turn */\n    wtap_rec_init(&read_rec, 1514);\n    while (wtap_read(wth, &read_rec, &read_err, &read_err_info, &data_offset)) {\n        /*\n         * XXX - what about non-packet records in the file after this?\n         * NRBs, DSBs, and ISBs are now written when wtap_dump_close() calls\n         * pcapng_dump_finish(), and we handle IDBs below, but what about\n         * custom blocks?\n         */\n        if (max_packet_number <= read_count)\n            break;\n\n        read_count++;\n\n        /* Extra actions for the first packet */\n        if (read_count == 1) {\n            if (split_packet_count != 0 || !nstime_is_unset(&secs_per_block)) {\n                filename = fileset_get_filename_by_pattern(block_cnt++,\n                                                           (read_rec.presence_flags & WTAP_HAS_TS) ? &read_rec.ts : NULL,\n                                                           fprefix, fsuffix);\n            } else {\n                filename = g_strdup(argv[ws_optind+1]);\n            }\n            ws_assert(filename);\n\n            /* If we don't have an application name add one */\n            if (wtap_block_get_string_option_value(g_array_index(params.shb_hdrs, wtap_block_t, 0), OPT_SHB_USERAPPL, &shb_user_appl) != WTAP_OPTTYPE_SUCCESS) {\n                wtap_block_add_string_option_format(g_array_index(params.shb_hdrs, wtap_block_t, 0), OPT_SHB_USERAPPL, \"%s\", get_appname_and_version());\n            }\n\n            pdh = editcap_dump_open(filename, &params, idbs_seen, &write_err,\n                                    &write_err_info, compression_type);\n\n            if (pdh == NULL) {\n                cfile_dump_open_failure_message(filename,\n                                                write_err, write_err_info,\n                                                out_file_type_subtype);\n                ret = WS_EXIT_INVALID_FILE;\n                goto clean_exit;\n            }\n        } /* first packet only handling */\n\n        /*\n         * Process whatever IDBs we haven't seen yet.\n         */\n        if (!process_new_idbs(wth, pdh, idbs_seen, &write_err, &write_err_info)) {\n            cfile_write_failure_message(argv[ws_optind], filename,\n                                        write_err, write_err_info,\n                                        read_count,\n                                        out_file_type_subtype);\n            ret = DUMP_ERROR;\n\n            /*\n             * Close the dump file, but don't report an error\n             * or set the exit code, as we've already reported\n             * an error.\n             */\n            wtap_dump_close(pdh, NULL, &write_err, &write_err_info);\n            goto clean_exit;\n        }\n\n        buf = ws_buffer_start_ptr(&read_rec.data);\n\n        /*\n         * Not all packets have time stamps. Only process the time\n         * stamp if we have one.\n         */\n        if (read_rec.presence_flags & WTAP_HAS_TS) {\n            if (!nstime_is_unset(&secs_per_block)) {\n                if (nstime_is_unset(&block_next)) {\n                    block_next = read_rec.ts;\n                    nstime_add(&block_next, &secs_per_block);\n                }\n                while (nstime_cmp(&read_rec.ts, &block_next) > 0) { /* time for the next file */\n\n                    /* We presumably want to write the DSBs from files given\n                     * on the command line to every file.\n                     */\n                    wtap_block_array_ref(params.dsbs_initial);\n                    if (!wtap_dump_close(pdh, NULL, &write_err, &write_err_info)) {\n                        cfile_close_failure_message(filename, write_err,\n                                                    write_err_info);\n                        ret = WRITE_ERROR;\n                        goto clean_exit;\n                    }\n                    g_free(filename);\n                    /* Use the interval start time for the filename. */\n                    filename = fileset_get_filename_by_pattern(block_cnt++, &block_next, fprefix, fsuffix);\n                    ws_assert(filename);\n                    nstime_add(&block_next, &secs_per_block); /* reset for next interval */\n\n                    if (verbose)\n                        fprintf(stderr, \"Continuing writing in file %s\\n\", filename);\n\n                    pdh = editcap_dump_open(filename, &params, idbs_seen,\n                                            &write_err, &write_err_info, compression_type);\n\n                    if (pdh == NULL) {\n                        cfile_dump_open_failure_message(filename,\n                                                        write_err,\n                                                        write_err_info,\n                                                        out_file_type_subtype);\n                        ret = WS_EXIT_INVALID_FILE;\n                        goto clean_exit;\n                    }\n                }\n            }\n        }  /* time stamp handling */\n\n        if (split_packet_count != 0) {\n            /* time for the next file? */\n            if (written_count > 0 && (written_count % split_packet_count) == 0) {\n\n                /* We presumably want to write the DSBs from files given\n                 * on the command line to every file.\n                 */\n                wtap_block_array_ref(params.dsbs_initial);\n                if (!wtap_dump_close(pdh, NULL, &write_err, &write_err_info)) {\n                    cfile_close_failure_message(filename, write_err,\n                                                write_err_info);\n                    ret = WRITE_ERROR;\n                    goto clean_exit;\n                }\n\n                g_free(filename);\n                filename = fileset_get_filename_by_pattern(block_cnt++,\n                                                           (read_rec.presence_flags & WTAP_HAS_TS) ? &read_rec.ts : NULL,\n                                                           fprefix, fsuffix);\n                ws_assert(filename);\n\n                if (verbose)\n                    fprintf(stderr, \"Continuing writing in file %s\\n\", filename);\n\n                pdh = editcap_dump_open(filename, &params, idbs_seen,\n                                        &write_err, &write_err_info, compression_type);\n                if (pdh == NULL) {\n                    cfile_dump_open_failure_message(filename,\n                                                    write_err, write_err_info,\n                                                    out_file_type_subtype);\n                    ret = WS_EXIT_INVALID_FILE;\n                    goto clean_exit;\n                }\n            }\n        } /* split packet handling */\n\n        if (check_startstop) {\n            ts_okay = false;\n            /*\n             * Is the packet in the selected timeframe?\n             * If the packet has no time stamp, the answer is \"no\".\n             */\n            if (read_rec.presence_flags & WTAP_HAS_TS) {\n                if (have_starttime && have_stoptime) {\n                    ts_okay = nstime_cmp(&read_rec.ts, &starttime) >= 0 &&\n                              nstime_cmp(&read_rec.ts, &stoptime) < 0;\n                } else if (have_starttime) {\n                    ts_okay = nstime_cmp(&read_rec.ts, &starttime) >= 0;\n                } else if (have_stoptime) {\n                    ts_okay = nstime_cmp(&read_rec.ts, &stoptime) < 0;\n                }\n            }\n        } else {\n            /*\n             * No selected timeframe, so all packets are \"in the\n             * selected timeframe\".\n             */\n            ts_okay = true;\n        }\n\n        if (ts_okay && ((!selected(count) && !keep_em)\n                        || (selected(count) && keep_em))) {\n            /* Write the record, possibly after modifying it. */\n\n            if (verbose && !dup_detect && !dup_detect_by_time)\n                fprintf(stderr, \"Packet: %\" PRIu64 \"\\n\", count);\n\n            if (read_rec.presence_flags & WTAP_HAS_TS) {\n                /* Do we adjust timestamps to ensure strict chronological\n                 * order? */\n                if (do_strict_time_adjustment) {\n                    if (previous_time.secs || previous_time.nsecs) {\n                        if (!strict_time_adj.is_negative) {\n                            nstime_t current;\n                            nstime_t delta;\n\n                            current = read_rec.ts;\n\n                            nstime_delta(&delta, &current, &previous_time);\n\n                            if (delta.secs < 0 || delta.nsecs < 0) {\n                                /*\n                                 * A negative delta indicates that the current packet\n                                 * has an absolute timestamp less than the previous packet\n                                 * that it is being compared to.  This is NOT a normal\n                                 * situation since trace files usually have packets in\n                                 * chronological order (oldest to newest).\n                                 */\n                                /* fprintf(stderr, \"++out of order, need to adjust this packet!\\n\"); */\n                                read_rec.ts.secs = previous_time.secs + strict_time_adj.tv.secs;\n                                read_rec.ts.nsecs = previous_time.nsecs;\n                                if (read_rec.ts.nsecs + strict_time_adj.tv.nsecs >= ONE_BILLION) {\n                                    /* carry */\n                                    read_rec.ts.secs++;\n                                    read_rec.ts.nsecs += strict_time_adj.tv.nsecs - ONE_BILLION;\n                                } else {\n                                    read_rec.ts.nsecs += strict_time_adj.tv.nsecs;\n                                }\n                            }\n                        } else {\n                            /*\n                             * A negative strict time adjustment is requested.\n                             * Unconditionally set each timestamp to previous\n                             * packet's timestamp plus delta.\n                             */\n                            read_rec.ts.secs = previous_time.secs + strict_time_adj.tv.secs;\n                            read_rec.ts.nsecs = previous_time.nsecs;\n                            if (read_rec.ts.nsecs + strict_time_adj.tv.nsecs >= ONE_BILLION) {\n                                /* carry */\n                                read_rec.ts.secs++;\n                                read_rec.ts.nsecs += strict_time_adj.tv.nsecs - ONE_BILLION;\n                            } else {\n                                read_rec.ts.nsecs += strict_time_adj.tv.nsecs;\n                            }\n                        }\n                    }\n                    previous_time = read_rec.ts;\n                }\n\n                if (time_adj.tv.secs != 0) {\n                    if (time_adj.is_negative)\n                        read_rec.ts.secs -= time_adj.tv.secs;\n                    else\n                        read_rec.ts.secs += time_adj.tv.secs;\n                }\n\n                if (time_adj.tv.nsecs != 0) {\n                    if (time_adj.is_negative) { /* subtract */\n                        if (read_rec.ts.nsecs < time_adj.tv.nsecs) { /* borrow */\n                            read_rec.ts.secs--;\n                            read_rec.ts.nsecs += ONE_BILLION;\n                        }\n                        read_rec.ts.nsecs -= time_adj.tv.nsecs;\n                    } else {                  /* add */\n                        if (read_rec.ts.nsecs + time_adj.tv.nsecs >= ONE_BILLION) {\n                            /* carry */\n                            read_rec.ts.secs++;\n                            read_rec.ts.nsecs += time_adj.tv.nsecs - ONE_BILLION;\n                        } else {\n                            read_rec.ts.nsecs += time_adj.tv.nsecs;\n                        }\n                    }\n                }\n            } /* time stamp adjustment */\n\n            if (read_rec.rec_type == REC_TYPE_PACKET) {\n                if (snaplen != 0) {\n                    /* Limit capture length to snaplen */\n                    if (read_rec.rec_header.packet_header.caplen > snaplen) {\n                        read_rec.rec_header.packet_header.caplen = snaplen;\n                    }\n                    /* If -L, also set reported length to snaplen */\n                    if (adjlen && read_rec.rec_header.packet_header.len > snaplen) {\n                        read_rec.rec_header.packet_header.len = snaplen;\n                    }\n                }\n\n                /*\n                 * If an encapsulation type was specified, override the\n                 * encapsulation type of the packet.\n                 */\n                if (out_frame_type != -2) {\n                    read_rec.rec_header.packet_header.pkt_encap = out_frame_type;\n                }\n\n                /*\n                 * CHOP\n                 */\n                handle_chopping(chop, &read_rec.rec_header.packet_header,\n                                &buf, adjlen);\n\n                /* set unused info */\n                if (set_unused) {\n                    /* set unused bytes to zero so that duplicates check ignores unused bytes */\n                    set_unused_info(&read_rec.rec_header.packet_header, buf);\n                }\n\n                /* remove vlan info */\n                if (rem_vlan) {\n                    remove_vlan_info(&read_rec.rec_header.packet_header, buf);\n                }\n\n                /* suppress duplicates by packet window */\n                if (dup_detect) {\n                    if (is_duplicate(buf, read_rec.rec_header.packet_header.caplen)) {\n                        if (verbose) {\n                            fprintf(stderr, \"Skipped: %\" PRIu64 \", Len: %u, MD5 Hash: \",\n                                    count,\n                                    read_rec.rec_header.packet_header.caplen);\n                            for (i = 0; i < 16; i++)\n                                fprintf(stderr, \"%02x\",\n                                        (unsigned char)fd_hash[cur_dup_entry].digest[i]);\n                            fprintf(stderr, \"\\n\");\n                        }\n                        duplicate_count++;\n                        count++;\n                        continue;\n                    } else {\n                        if (verbose) {\n                            fprintf(stderr, \"Packet: %\" PRIu64 \", Len: %u, MD5 Hash: \",\n                                    count,\n                                    read_rec.rec_header.packet_header.caplen);\n                            for (i = 0; i < 16; i++)\n                                fprintf(stderr, \"%02x\",\n                                        (unsigned char)fd_hash[cur_dup_entry].digest[i]);\n                            fprintf(stderr, \"\\n\");\n                        }\n                    }\n                } /* suppression of duplicates */\n\n                if (read_rec.presence_flags & WTAP_HAS_TS) {\n                    /* suppress duplicates by time window */\n                    if (dup_detect_by_time) {\n                        nstime_t current;\n\n                        current.secs  = read_rec.ts.secs;\n                        current.nsecs = read_rec.ts.nsecs;\n\n                        if (is_duplicate_rel_time(buf,\n                                                  read_rec.rec_header.packet_header.caplen,\n                                                  &current)) {\n                            if (verbose) {\n                                fprintf(stderr, \"Skipped: %\" PRIu64 \", Len: %u, MD5 Hash: \",\n                                        count,\n                                        read_rec.rec_header.packet_header.caplen);\n                                for (i = 0; i < 16; i++)\n                                    fprintf(stderr, \"%02x\",\n                                            (unsigned char)fd_hash[cur_dup_entry].digest[i]);\n                                fprintf(stderr, \"\\n\");\n                            }\n                            duplicate_count++;\n                            count++;\n                            continue;\n                        } else {\n                            if (verbose) {\n                                fprintf(stderr, \"Packet: %\" PRIu64 \", Len: %u, MD5 Hash: \",\n                                        count,\n                                        read_rec.rec_header.packet_header.caplen);\n                                for (i = 0; i < 16; i++)\n                                    fprintf(stderr, \"%02x\",\n                                            (unsigned char)fd_hash[cur_dup_entry].digest[i]);\n                                fprintf(stderr, \"\\n\");\n                            }\n                        }\n                    }\n                } /* suppress duplicates by time window */\n            }\n\n            /* Random error mutation */\n            if (err_prob > 0.0) {\n                mutate_packet_data(&read_rec, buf, change_offset, count);\n            } /* random error mutation */\n\n            /* Discard all packet comments when writing */\n            if (discard_pkt_comments) {\n                while (WTAP_OPTTYPE_SUCCESS == wtap_block_remove_nth_option_instance(read_rec.block, OPT_COMMENT, 0)) {\n                    read_rec.block_was_modified = true;\n                }\n            }\n\n            /* Find a packet comment we may need to write */\n            if (frames_user_comments) {\n                const char *comment =\n                    (const char*)g_tree_lookup(frames_user_comments, &read_count);\n                if (comment != NULL) {\n                    /* Erase any existing comments before adding the new one */\n                    while (WTAP_OPTTYPE_SUCCESS == wtap_block_remove_nth_option_instance(read_rec.block, OPT_COMMENT, 0)) {\n                        read_rec.block_was_modified = true;\n                    }\n\n                    /* The comment is not modified by dumper, cast away. */\n                    wtap_block_add_string_option(read_rec.block, OPT_COMMENT, (char *)comment, strlen((char *)comment));\n                    read_rec.block_was_modified = true;\n                } else {\n                    read_rec.block_was_modified = false;\n                }\n            }\n\n            if (discard_all_secrets) {\n                /*\n                 * Discard any secrets we've read since the last packet\n                 * we wrote.\n                 */\n                wtap_dump_discard_decryption_secrets(pdh);\n            }\n\n            /* Attempt to dump out current frame to the output file */\n            if (!wtap_dump(pdh, &read_rec, buf, &write_err, &write_err_info)) {\n                cfile_write_failure_message(argv[ws_optind], filename,\n                                            write_err, write_err_info,\n                                            read_count,\n                                            out_file_type_subtype);\n                ret = DUMP_ERROR;\n\n                /*\n                 * Close the dump file, but don't report an error\n                 * or set the exit code, as we've already reported\n                 * an error.\n                 */\n                wtap_dump_close(pdh, NULL, &write_err, &write_err_info);\n                goto clean_exit;\n            }\n            written_count++;\n        }\n        count++;\n        wtap_rec_reset(&read_rec);\n    }\n    wtap_rec_cleanup(&read_rec);\n\n    if (verbose)\n        fprintf(stderr, \"Total selected: %\" PRIu64 \"\\n\", written_count);\n\n    if (read_err != 0) {\n        /* Print a message noting that the read failed somewhere along the\n         * line. */\n        cfile_read_failure_message(argv[ws_optind], read_err, read_err_info);\n    }\n\n    if (!pdh) {\n        /* No valid packets found, open the outfile so we can write an\n         * empty header */\n        g_free (filename);\n        filename = g_strdup(argv[ws_optind+1]);\n\n        pdh = editcap_dump_open(filename, &params, idbs_seen, &write_err,\n                                &write_err_info, compression_type);\n        if (pdh == NULL) {\n            cfile_dump_open_failure_message(filename,\n                                            write_err, write_err_info,\n                                            out_file_type_subtype);\n            ret = WS_EXIT_INVALID_FILE;\n            goto clean_exit;\n        }\n    }\n\n    /*\n     * Process whatever IDBs we haven't seen yet.\n     */\n    if (!process_new_idbs(wth, pdh, idbs_seen, &write_err, &write_err_info)) {\n        cfile_write_failure_message(argv[ws_optind], filename,\n                                    write_err, write_err_info,\n                                    read_count,\n                                    out_file_type_subtype);\n        ret = DUMP_ERROR;\n\n        /*\n         * Close the dump file, but don't report an error\n         * or set the exit code, as we've already reported\n         * an error.\n         */\n        wtap_dump_close(pdh, NULL, &write_err, &write_err_info);\n        goto clean_exit;\n    }\n\n    if (!wtap_dump_close(pdh, NULL, &write_err, &write_err_info)) {\n        cfile_close_failure_message(filename, write_err, write_err_info);\n        ret = WRITE_ERROR;\n        goto clean_exit;\n    }\n\n    if (dup_detect) {\n        fprintf(stderr, \"%\" PRIu64 \" packet%s seen, %\" PRIu64 \" packet%s skipped with duplicate window of %i packets.\\n\",\n                count - 1, plurality(count - 1, \"\", \"s\"), duplicate_count,\n                plurality(duplicate_count, \"\", \"s\"), dup_window);\n    } else if (dup_detect_by_time) {\n        fprintf(stderr, \"%\" PRIu64 \" packet%s seen, %\" PRIu64 \" packet%s skipped with duplicate time window equal to or less than %ld.%09ld seconds.\\n\",\n                count - 1, plurality(count - 1, \"\", \"s\"), duplicate_count,\n                plurality(duplicate_count, \"\", \"s\"),\n                (long)relative_time_window.secs,\n                (long int)relative_time_window.nsecs);\n    }\n\nclean_exit:\n    g_free(fprefix);\n    g_free(fsuffix);\n\n    if (filename) {\n        g_free(filename);\n    }\n    if (frames_user_comments) {\n        g_tree_destroy(frames_user_comments);\n    }\n    if (dsb_filenames) {\n        g_array_free(dsb_types, TRUE);\n        g_ptr_array_free(dsb_filenames, TRUE);\n    }\n    if (idbs_seen != NULL) {\n        for (unsigned b = 0; b < idbs_seen->len; b++) {\n            wtap_block_t if_data = g_array_index(idbs_seen, wtap_block_t, b);\n            wtap_block_unref(if_data);\n        }\n        g_array_free(idbs_seen, TRUE);\n    }\n    g_free(params.idb_inf);\n    wtap_dump_params_cleanup(&params);\n    if (wth != NULL)\n        wtap_close(wth);\n    wtap_rec_reset(&read_rec);\n    wtap_cleanup();\n    free_progdirs();\n    if (capture_comments != NULL) {\n        g_ptr_array_free(capture_comments, TRUE);\n        capture_comments = NULL;\n    }\n    return ret;\n}\n\n/* Skip meta-information read from file to return offset of real\n * protocol data */\nstatic unsigned\nfind_dct2000_real_data(const uint8_t *buf)\n{\n    unsigned n = 0;\n\n    for (n = 0; buf[n] != '\\0'; n++);   /* Context name */\n    n++;\n    n++;                                /* Context port number */\n    for (; buf[n] != '\\0'; n++);        /* Timestamp */\n    n++;\n    for (; buf[n] != '\\0'; n++);        /* Protocol name */\n    n++;\n    for (; buf[n] != '\\0'; n++);        /* Variant number (as string) */\n    n++;\n    for (; buf[n] != '\\0'; n++);        /* Outhdr (as string) */\n    n++;\n    n += 2;                             /* Direction & encap */\n\n    return n;\n}\n\n/*\n * We support up to 2 chopping regions in a single pass: one specified by the\n * positive chop length, and one by the negative chop length.\n */\nstatic void\nhandle_chopping(chop_t chop, wtap_packet_header *phdr, uint8_t **buf,\n                bool adjlen)\n{\n    /* If we're not chopping anything from one side, then the offset for that\n     * side is meaningless. */\n    if (chop.len_begin == 0)\n        chop.off_begin_pos = chop.off_begin_neg = 0;\n    if (chop.len_end == 0)\n        chop.off_end_pos = chop.off_end_neg = 0;\n\n    if (chop.off_begin_neg < 0) {\n        chop.off_begin_pos += phdr->caplen + chop.off_begin_neg;\n        chop.off_begin_neg = 0;\n    }\n    if (chop.off_end_pos > 0) {\n        chop.off_end_neg += chop.off_end_pos - phdr->caplen;\n        chop.off_end_pos = 0;\n    }\n\n    /* If we've crossed chopping regions, swap them */\n    if (chop.len_begin && chop.len_end) {\n        if (chop.off_begin_pos > ((int)phdr->caplen + chop.off_end_neg)) {\n            int tmp_len, tmp_off;\n\n            tmp_off = phdr->caplen + chop.off_end_neg + chop.len_end;\n            tmp_len = -chop.len_end;\n\n            chop.off_end_neg = chop.len_begin + chop.off_begin_pos - phdr->caplen;\n            chop.len_end = -chop.len_begin;\n\n            chop.len_begin = tmp_len;\n            chop.off_begin_pos = tmp_off;\n        }\n    }\n\n    /* Make sure we don't chop off more than we have available */\n    if (phdr->caplen < (uint32_t)(chop.off_begin_pos - chop.off_end_neg)) {\n        chop.len_begin = 0;\n        chop.len_end = 0;\n    }\n    if ((uint32_t)(chop.len_begin - chop.len_end) >\n        (phdr->caplen - (uint32_t)(chop.off_begin_pos - chop.off_end_neg))) {\n        chop.len_begin = phdr->caplen - (chop.off_begin_pos - chop.off_end_neg);\n        chop.len_end = 0;\n    }\n\n    /* Handle chopping from the beginning.  Note that if a beginning offset\n     * was specified, we need to keep that piece */\n    if (chop.len_begin > 0) {\n        if (chop.off_begin_pos > 0) {\n            memmove(*buf + chop.off_begin_pos,\n                    *buf + chop.off_begin_pos + chop.len_begin,\n                    phdr->caplen - (chop.off_begin_pos + chop.len_begin));\n        } else {\n            *buf += chop.len_begin;\n        }\n        phdr->caplen -= chop.len_begin;\n\n        if (adjlen) {\n            if (phdr->len > (uint32_t)chop.len_begin)\n                phdr->len -= chop.len_begin;\n            else\n                phdr->len = 0;\n        }\n     }\n\n    /* Handle chopping from the end.  Note that if an ending offset was\n     * specified, we need to keep that piece */\n    if (chop.len_end < 0) {\n        if (chop.off_end_neg < 0) {\n            memmove(*buf + (int)phdr->caplen + (chop.len_end + chop.off_end_neg),\n                    *buf + (int)phdr->caplen + chop.off_end_neg,\n                    -chop.off_end_neg);\n        }\n        phdr->caplen += chop.len_end;\n\n        if (adjlen) {\n            if (((signed int) phdr->len + chop.len_end) > 0)\n                phdr->len += chop.len_end;\n            else\n                phdr->len = 0;\n        }\n    }\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "epan",
          "type": "tree",
          "content": null
        },
        {
          "name": "extcap.c",
          "type": "blob",
          "size": 67.4638671875,
          "content": "/* extcap.c\n *\n * Routines for extcap external capture\n * Copyright 2013, Mike Ryan <mikeryan@lacklustre.net>\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN LOG_DOMAIN_EXTCAP\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <windows.h>\n#include <process.h>\n#include <time.h>\n#else\n/* Include for unlink */\n#include <unistd.h>\n#endif\n\n#include <sys/types.h>\n\n#include <glib.h>\n\n#include <epan/prefs.h>\n#include <epan/prefs-int.h>\n\n#include \"ui/iface_toolbar.h\"\n\n#include <wsutil/file_util.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/ws_pipe.h>\n#include <wsutil/tempfile.h>\n#include <wsutil/wslog.h>\n#include <wsutil/ws_assert.h>\n#include <wsutil/version_info.h>\n\n#include \"capture/capture_session.h\"\n#include \"ui/capture_opts.h\"\n\n#include \"extcap.h\"\n#include \"extcap_parser.h\"\n\n/* Number of seconds to wait for extcap process to exit after cleanup.\n * If extcap does not exit before the timeout, it is forcefully terminated.\n */\n#ifdef _WIN32\n/* Extcap interface does not specify SIGTERM replacement on Windows yet */\n#define EXTCAP_CLEANUP_TIMEOUT 0\n#else\n#define EXTCAP_CLEANUP_TIMEOUT 30\n#endif\n\n/* internal container, for all the extcap executables that have been found.\n * Will be reset if extcap_clear_interfaces() is being explicitly called\n * and is being used for printing information about all extcap interfaces found,\n * as well as storing all sub-interfaces\n */\nstatic GHashTable * _loaded_interfaces;\n\n/* Internal container, which maps each ifname to the tool providing it, for faster\n * lookup. The key and string value are owned by this table.\n */\nstatic GHashTable * _tool_for_ifname;\n\n/* internal container, for all the extcap executables that have been found\n * and that provides a toolbar with controls to be added to a Interface Toolbar\n */\nstatic GHashTable *_toolbars;\n\n/* internal container, to map preference names to pointers that hold preference\n * values. These ensure that preferences can survive extcap if garbage\n * collection, and does not lead to dangling pointers in the prefs subsystem.\n */\nstatic GHashTable *_extcap_prefs_dynamic_vals;\n\ntypedef struct _extcap_callback_info_t\n{\n    const char * extcap;\n    const char * ifname;\n    char * output;\n    void * data;\n    char ** err_str;\n} extcap_callback_info_t;\n\n/* Callback definition for extcap_run_one.\n * N.B.: extcap_run_one does not use the return value, which is\n * vestigial from extcap_foreach, which no longer exists.\n * Now extcap operations are run in parallel in multiple threads.\n */\ntypedef bool(*extcap_cb_t)(extcap_callback_info_t info_structure);\n\n/** GThreadPool does not support pushing new work from a thread while waiting\n * for the thread pool to finish. This data structure tracks ongoing work.\n * See https://gitlab.gnome.org/GNOME/glib/issues/1598 */\ntypedef struct thread_pool {\n    GThreadPool    *pool;\n    int             count;  /**< Number of tasks that have not finished. */\n    GCond           cond;\n    GMutex          data_mutex;\n} thread_pool_t;\n\n/**\n * Callback definition for extcap_run_all, invoked with a thread pool (to\n * schedule new tasks), an opaque data parameter, and the output from last task\n * (or NULL if it failed). The output must be freed by the callback function.\n * The implementation MUST be thread-safe.\n */\ntypedef void (*extcap_run_cb_t)(thread_pool_t *pool, void *data, char *output);\n\ntypedef struct extcap_run_task {\n    const char     *extcap_path;\n    char          **argv;       /**< NULL-terminated arguments list, freed when the task is completed. */\n    extcap_run_cb_t output_cb;\n    void           *data;       /** Parameter to be passed to output_cb. */\n} extcap_run_task_t;\n\ntypedef struct extcap_iface_info {\n    char *ifname;                       /**< Interface name. */\n    char *output;                       /**< Output of --extcap-config. */\n} extcap_iface_info_t;\n\ntypedef struct extcap_run_extcaps_info {\n    char    *extcap_path;               /**< Extcap program path, MUST be the first member.  */\n    char    *output;                    /**< Output of --extcap-interfaces. */\n    unsigned num_interfaces;            /**< Number of discovered interfaces. */\n    extcap_iface_info_t *iface_infos;   /**< Per-interface information. */\n} extcap_run_extcaps_info_t;\n\n\nstatic void extcap_load_interface_list(void);\n\n/* Used for lazily loading our interfaces. */\nstatic void extcap_ensure_all_interfaces_loaded(void) {\n    if ( !_loaded_interfaces || g_hash_table_size(_loaded_interfaces) == 0 )\n        extcap_load_interface_list();\n}\n\nstatic bool\nthread_pool_push(thread_pool_t *pool, void *data, GError **error)\n{\n    g_mutex_lock(&pool->data_mutex);\n    ++pool->count;\n    g_mutex_unlock(&pool->data_mutex);\n    return g_thread_pool_push(pool->pool, data, error);\n}\n\nstatic void\nthread_pool_wait(thread_pool_t *pool)\n{\n    g_mutex_lock(&pool->data_mutex);\n    while (pool->count != 0) {\n        g_cond_wait(&pool->cond, &pool->data_mutex);\n    }\n    g_mutex_unlock(&pool->data_mutex);\n}\n\nstatic GHashTable *\nextcap_loaded_interfaces(void)\n{\n    if (prefs.capture_no_extcap)\n        return NULL;\n\n    extcap_ensure_all_interfaces_loaded();\n\n    return _loaded_interfaces;\n}\n\nvoid\nextcap_clear_interfaces(void)\n{\n    if ( _loaded_interfaces )\n        g_hash_table_destroy(_loaded_interfaces);\n    _loaded_interfaces = NULL;\n\n    if ( _tool_for_ifname )\n        g_hash_table_destroy(_tool_for_ifname);\n    _tool_for_ifname = NULL;\n}\n\nstatic int\ncompare_tools(const void *a, const void *b)\n{\n    return g_strcmp0((*(extcap_info *const *)a)->basename, (*(extcap_info *const *)b)->basename);\n}\n\nvoid\nextcap_get_descriptions(extcap_plugin_description_callback callback, void *callback_data)\n{\n    extcap_ensure_all_interfaces_loaded();\n\n    GHashTable * tools = extcap_loaded_interfaces();\n    GPtrArray *tools_array = g_ptr_array_new();\n\n    if (tools && g_hash_table_size(tools) > 0) {\n        GList * keys = g_hash_table_get_keys(tools);\n        GList * walker = g_list_first(keys);\n        while (walker && walker->data) {\n            extcap_info * tool = (extcap_info *)g_hash_table_lookup(tools, walker->data);\n            if (tool) {\n                g_ptr_array_add(tools_array, tool);\n            }\n            walker = g_list_next(walker);\n        }\n        g_list_free(keys);\n    }\n\n    g_ptr_array_sort(tools_array, compare_tools);\n\n    for (unsigned i = 0; i < tools_array->len; i++) {\n        extcap_info *tool = (extcap_info *)tools_array->pdata[i];\n        callback(tool->basename, tool->version, \"extcap\", tool->full_path, callback_data);\n    }\n\n    g_ptr_array_free(tools_array, true);\n}\n\nstatic void\nprint_extcap_description(const char *basename, const char *version,\n                        const char *description, const char *filename,\n                        void *user_data _U_)\n{\n    printf(\"%-16s\\t%s\\t%s\\t%s\\n\", basename, version, description, filename);\n}\n\nvoid\nextcap_dump_all(void)\n{\n    extcap_get_descriptions(print_extcap_description, NULL);\n}\n\nstatic GSList *\nextcap_get_extcap_paths_from_dir(GSList * list, const char * dirname)\n{\n    GDir * dir;\n    const char * file;\n\n    GSList * paths = list;\n\n    if ((dir = g_dir_open(dirname, 0, NULL)) != NULL) {\n        while ((file = g_dir_read_name(dir)) != NULL) {\n            /* full path to extcap binary */\n            char *extcap_path = ws_strdup_printf(\"%s\" G_DIR_SEPARATOR_S \"%s\", dirname, file);\n            /* treat anything executable as an extcap binary */\n            if (g_file_test(extcap_path, G_FILE_TEST_IS_REGULAR) &&\n                g_file_test(extcap_path, G_FILE_TEST_IS_EXECUTABLE)) {\n                paths = g_slist_append(paths, extcap_path);\n            } else {\n                g_free(extcap_path);\n            }\n\n        }\n        g_dir_close(dir);\n    }\n\n    return paths;\n}\n\n/**\n * Obtains a list of extcap program paths. Use g_slist_free_full(paths, g_free)\n * to destroy the list.\n */\nstatic GSList *\nextcap_get_extcap_paths(void)\n{\n    GSList *paths = NULL;\n\n    paths = extcap_get_extcap_paths_from_dir(paths, get_extcap_pers_dir());\n    paths = extcap_get_extcap_paths_from_dir(paths, get_extcap_dir());\n\n    return paths;\n}\n\nstatic extcap_interface *\nextcap_find_interface_for_ifname(const char *ifname)\n{\n    extcap_interface * result = NULL;\n\n    if ( !ifname || ! _tool_for_ifname || ! _loaded_interfaces )\n        return result;\n\n    char * extcap_util = (char *)g_hash_table_lookup(_tool_for_ifname, ifname);\n    if ( ! extcap_util )\n        return result;\n\n    extcap_info * element = (extcap_info *)g_hash_table_lookup(_loaded_interfaces, extcap_util);\n    if ( ! element )\n        return result;\n\n    GList * walker = element->interfaces;\n    while ( walker && walker->data && ! result )\n    {\n        extcap_interface * interface = (extcap_interface *)walker->data;\n        if ( g_strcmp0(interface->call, ifname) == 0 )\n        {\n            result = interface;\n            break;\n        }\n\n        walker = g_list_next ( walker );\n    }\n\n    return result;\n}\n\nstatic void\nextcap_free_toolbar(void *data)\n{\n    if (!data)\n    {\n        return;\n    }\n\n    iface_toolbar *toolbar = (iface_toolbar *)data;\n\n    g_free(toolbar->menu_title);\n    g_free(toolbar->help);\n    g_list_free_full(toolbar->ifnames, g_free);\n    g_list_free_full(toolbar->controls, (GDestroyNotify)extcap_free_toolbar_control);\n    g_free(toolbar);\n}\n\nstatic char *\nextcap_if_executable(const char *ifname)\n{\n    extcap_interface *interface = extcap_find_interface_for_ifname(ifname);\n    return interface != NULL ? interface->extcap_path : NULL;\n}\n\nstatic bool\nextcap_iface_toolbar_add(const char *extcap, iface_toolbar *toolbar_entry)\n{\n    char *toolname;\n    bool ret = false;\n\n    if (!extcap || !toolbar_entry)\n    {\n        return ret;\n    }\n\n    toolname = g_path_get_basename(extcap);\n\n    if (!g_hash_table_lookup(_toolbars, toolname))\n    {\n        g_hash_table_insert(_toolbars, g_strdup(toolname), toolbar_entry);\n        ret = true;\n    }\n\n    g_free(toolname);\n    return ret;\n}\n\nstatic char **\nextcap_convert_arguments_to_array(GList * arguments)\n{\n    char ** result = NULL;\n    if ( arguments )\n    {\n        GList * walker = g_list_first(arguments);\n        int cnt = 0;\n\n        result = (char **) g_malloc0(sizeof(char *) * (g_list_length(arguments)));\n\n        while(walker)\n        {\n            result[cnt] = g_strdup((const char *)walker->data);\n            walker = g_list_next(walker);\n            cnt++;\n        }\n    }\n    return result;\n}\n\nstatic void extcap_free_array(char ** args, int argc)\n{\n    int cnt = 0;\n\n    for ( cnt = 0; cnt < argc; cnt++ )\n        g_free(args[cnt]);\n    g_free(args);\n}\n\nstatic void\nextcap_free_extcaps_info_array(extcap_run_extcaps_info_t *infos, unsigned count)\n{\n    for (unsigned i = 0; i < count; i++) {\n        g_free(infos[i].extcap_path);\n        g_free(infos[i].output);\n        for (unsigned j = 0; j < infos[i].num_interfaces; j++) {\n            extcap_iface_info_t *iface_info = &infos[i].iface_infos[j];\n            g_free(iface_info->ifname);\n            g_free(iface_info->output);\n        }\n        g_free(infos[i].iface_infos);\n    }\n    g_free(infos);\n}\n\nstatic void\nextcap_run_one(const extcap_interface *interface, GList *arguments, extcap_cb_t cb, void *user_data, char **err_str)\n{\n    const char *dirname = get_extcap_dir();\n    char **args = extcap_convert_arguments_to_array(arguments);\n    int cnt = g_list_length(arguments);\n    char *command_output;\n    if (ws_pipe_spawn_sync(dirname, interface->extcap_path, cnt, args, &command_output)) {\n        extcap_callback_info_t cb_info = {\n            .ifname = interface->call,\n            .extcap = interface->extcap_path,\n            .output = command_output,\n            .data = user_data,\n            .err_str = err_str,\n        };\n        cb(cb_info);\n        g_free(command_output);\n    }\n    extcap_free_array(args, cnt);\n}\n\n/** Thread callback to run an extcap program and pass its output. */\nstatic void\nextcap_thread_callback(void *data, void *user_data)\n{\n    extcap_run_task_t *task = (extcap_run_task_t *)data;\n    thread_pool_t *pool = (thread_pool_t *)user_data;\n    const char *dirname = get_extcap_dir();\n\n    char *command_output;\n    if (ws_pipe_spawn_sync(dirname, task->extcap_path, g_strv_length(task->argv), task->argv, &command_output)) {\n        task->output_cb(pool, task->data, command_output);\n    } else {\n        task->output_cb(pool, task->data, NULL);\n    }\n    g_strfreev(task->argv);\n    g_free(task);\n\n    // Notify when all tasks are completed and no new subtasks were created.\n    g_mutex_lock(&pool->data_mutex);\n    if (--pool->count == 0) {\n        g_cond_signal(&pool->cond);\n    }\n    g_mutex_unlock(&pool->data_mutex);\n}\n\n/*\n * Run all extcap programs with the given arguments list, invoke the callback to\n * do some processing and return the results.\n *\n * @param [IN] argv NULL-terminated arguments list.\n * @param [IN] output_cb Thread callback function that receives the output.\n * @param [IN] data_size Size of the per-program information that will be returned.\n * @param [OUT] count Size of the returned array.\n * @return Array of information or NULL if there are none. The first member of\n * each element (char *extcap_path) must be freed.\n */\nstatic void *\nextcap_run_all(const char *argv[], extcap_run_cb_t output_cb, size_t data_size, unsigned *count)\n{\n    /* Need enough space for at least 'extcap_path'. */\n    ws_assert(data_size >= sizeof(char *));\n\n    GSList *paths = extcap_get_extcap_paths();\n    int i = 0;\n    int max_threads = (int)g_get_num_processors();\n\n    if (!paths) {\n        *count = 0;\n        return NULL;\n    }\n\n    uint64_t start_time = g_get_monotonic_time();\n    unsigned paths_count = g_slist_length(paths);\n    /* GSList is not thread-safe, so pre-allocate an array instead. */\n    void *infos = g_malloc0_n(paths_count, data_size);\n\n    thread_pool_t pool;\n    pool.pool = g_thread_pool_new(extcap_thread_callback, &pool, max_threads, false, NULL);\n    pool.count = 0;\n    g_cond_init(&pool.cond);\n    g_mutex_init(&pool.data_mutex);\n\n    for (GSList *path = paths; path; path = g_slist_next(path), i++) {\n        extcap_run_task_t *task = g_new0(extcap_run_task_t, 1);\n\n        task->extcap_path = (char *)path->data;\n        task->argv = g_strdupv((char **)argv);\n        task->output_cb = output_cb;\n        task->data = ((char *)infos) + (i * data_size);\n        *((char **)task->data) = (char *)path->data;\n\n        thread_pool_push(&pool, task, NULL);\n    }\n    g_slist_free(paths);    /* Note: the contents are transferred to 'infos'. */\n\n    /* Wait for all (sub)tasks to complete. */\n    thread_pool_wait(&pool);\n\n    g_mutex_clear(&pool.data_mutex);\n    g_cond_clear(&pool.cond);\n    g_thread_pool_free(pool.pool, false, true);\n\n    ws_debug(\"extcap: completed discovery of %d tools in %.3fms\",\n            paths_count, (g_get_monotonic_time() - start_time) / 1000.0);\n    *count = paths_count;\n    return infos;\n}\n\nstatic void extcap_free_dlt(void *d, void *user_data _U_)\n{\n    if (d == NULL)\n    {\n        return;\n    }\n\n    g_free(((extcap_dlt *)d)->name);\n    g_free(((extcap_dlt *)d)->display);\n    g_free(d);\n}\n\nstatic void extcap_free_dlts(GList *dlts)\n{\n    g_list_foreach(dlts, extcap_free_dlt, NULL);\n    g_list_free(dlts);\n}\n\nstatic bool cb_dlt(extcap_callback_info_t cb_info)\n{\n    GList *dlts = NULL, *temp = NULL;\n\n    if_capabilities_t *caps;\n    GList *linktype_list = NULL;\n    data_link_info_t *data_link_info;\n    extcap_dlt *dlt_item;\n\n    dlts = extcap_parse_dlts(cb_info.output);\n    temp = dlts;\n\n    ws_debug(\"Extcap pipe %s \", cb_info.extcap);\n\n    /*\n     * Allocate the interface capabilities structure.\n     */\n    caps = (if_capabilities_t *) g_malloc0(sizeof * caps);\n    caps->can_set_rfmon = false;\n    caps->timestamp_types = NULL;\n\n    while (dlts)\n    {\n        dlt_item = (extcap_dlt *)dlts->data;\n        if (dlt_item)\n        {\n            ws_debug(\"  DLT %d name=\\\"%s\\\" display=\\\"%s\\\" \", dlt_item->number,\n                  dlt_item->name, dlt_item->display);\n\n            data_link_info = g_new(data_link_info_t, 1);\n            data_link_info->dlt = dlt_item->number;\n            data_link_info->name = g_strdup(dlt_item->name);\n            data_link_info->description = g_strdup(dlt_item->display);\n            linktype_list = g_list_append(linktype_list, data_link_info);\n        }\n\n        dlts = g_list_next(dlts);\n    }\n\n    /* Check to see if we built a list */\n    if (linktype_list != NULL)\n    {\n        caps->data_link_types = linktype_list;\n    }\n    else\n    {\n        caps->primary_msg = g_strdup(\"Extcap returned no DLTs\");\n        if (cb_info.err_str)\n        {\n            ws_debug(\"  returned no DLTs\");\n            *(cb_info.err_str) = g_strdup(caps->primary_msg);\n        }\n    }\n    if (cb_info.data != NULL)\n    {\n        *(if_capabilities_t **) cb_info.data = caps;\n    } else\n    {\n#ifdef HAVE_LIBPCAP\n        free_if_capabilities(caps);\n#else\n        /* TODO: free_if_capabilities is in capture-pcap-util.c and doesn't\n         * get defined unless HAVE_LIBPCAP is set.\n         */\n        g_free(caps);\n#endif\n    }\n\n    extcap_free_dlts(temp);\n\n    return false;\n}\n\nif_capabilities_t *\nextcap_get_if_dlts(const char *ifname, char **err_str)\n{\n    GList * arguments = NULL;\n    if_capabilities_t *caps = NULL;\n\n    if (err_str != NULL)\n    {\n        *err_str = NULL;\n    }\n\n    /* Update the extcap interfaces and get a list of their if_infos */\n    extcap_ensure_all_interfaces_loaded();\n\n    extcap_interface *interface = extcap_find_interface_for_ifname(ifname);\n    if (interface)\n    {\n        arguments = g_list_append(arguments, g_strdup(EXTCAP_ARGUMENT_LIST_DLTS));\n        arguments = g_list_append(arguments, g_strdup(EXTCAP_ARGUMENT_INTERFACE));\n        arguments = g_list_append(arguments, g_strdup(ifname));\n\n        extcap_run_one(interface, arguments, cb_dlt, &caps, err_str);\n\n        g_list_free_full(arguments, g_free);\n    }\n\n    return caps;\n}\n\nstatic void extcap_free_interface(void *i)\n{\n\n    extcap_interface *interface = (extcap_interface *)i;\n\n    if (i == NULL)\n    {\n        return;\n    }\n\n    g_free(interface->call);\n    g_free(interface->display);\n    g_free(interface->version);\n    g_free(interface->help);\n    g_free(interface->extcap_path);\n    g_free(interface);\n}\n\nstatic void extcap_free_interfaces(GList *interfaces)\n{\n    if (interfaces == NULL)\n    {\n        return;\n    }\n\n    g_list_free_full(interfaces, extcap_free_interface);\n}\n\nstatic int\nif_info_compare(const void *a, const void *b)\n{\n    int comp = 0;\n    const if_info_t *if_a = (const if_info_t *)a;\n    const if_info_t *if_b = (const if_info_t *)b;\n\n    if ((comp = g_strcmp0(if_a->name, if_b->name)) == 0)\n    {\n        return g_strcmp0(if_a->friendly_name, if_b->friendly_name);\n    }\n\n    return comp;\n}\n\nchar *\nextcap_get_help_for_ifname(const char *ifname)\n{\n    extcap_ensure_all_interfaces_loaded();\n\n    extcap_interface *interface = extcap_find_interface_for_ifname(ifname);\n    return interface != NULL ? interface->help : NULL;\n}\n\nGList *\nappend_extcap_interface_list(GList *list)\n{\n    GList *interface_list = NULL;\n    extcap_interface *data = NULL;\n    GList *ifutilkeys_head = NULL, *ifutilkeys = NULL;\n\n    if (prefs.capture_no_extcap)\n        return list;\n\n    /* Update the extcap interfaces and get a list of their if_infos */\n    extcap_ensure_all_interfaces_loaded();\n\n    ifutilkeys_head = g_hash_table_get_keys(_loaded_interfaces);\n    ifutilkeys = ifutilkeys_head;\n    while ( ifutilkeys && ifutilkeys->data )\n    {\n        extcap_info * extinfo =\n                (extcap_info *) g_hash_table_lookup(_loaded_interfaces, (char *)ifutilkeys->data);\n        GList * walker = extinfo->interfaces;\n        while ( walker && walker->data )\n        {\n            interface_list = g_list_append(interface_list, walker->data);\n            walker = g_list_next(walker);\n        }\n\n        ifutilkeys = g_list_next(ifutilkeys);\n    }\n    g_list_free(ifutilkeys_head);\n\n    /* Sort that list */\n    interface_list = g_list_sort(interface_list, if_info_compare);\n\n    /* Append the interfaces in that list to the list we're handed. */\n    while (interface_list != NULL)\n    {\n        GList *entry = g_list_first(interface_list);\n        data = (extcap_interface *)entry->data;\n        interface_list = g_list_delete_link(interface_list, entry);\n\n        if_info_t * if_info = g_new0(if_info_t, 1);\n        if_info->name = g_strdup(data->call);\n        if_info->friendly_name = g_strdup(data->display);\n\n        if_info->type = IF_EXTCAP;\n\n        if_info->extcap = g_strdup(data->extcap_path);\n\n        list = g_list_append(list, if_info);\n    }\n\n    return list;\n}\n\nvoid extcap_register_preferences(void)\n{\n    /* Unconditionally register the extcap configuration file, so that\n     * it is copied if we copy the profile even if we're not going to\n     * read it because extcaps are disabled.\n     */\n    profile_register_persconffile(\"extcap.cfg\");\n\n    if (prefs.capture_no_extcap)\n        return;\n\n    module_t *dev_module = prefs_find_module(\"extcap\");\n\n    if (!dev_module)\n    {\n        return;\n    }\n\n    // Will load information about extcaps and their supported config.\n    extcap_ensure_all_interfaces_loaded();\n}\n\n/**\n * Releases the dynamic preference value pointers. Must not be called before\n * prefs_cleanup since these pointers could still be in use.\n */\nvoid extcap_cleanup(void)\n{\n    if (_extcap_prefs_dynamic_vals)\n        g_hash_table_destroy(_extcap_prefs_dynamic_vals);\n\n    if (_loaded_interfaces)\n        g_hash_table_destroy(_loaded_interfaces);\n\n    if (_tool_for_ifname)\n        g_hash_table_destroy(_tool_for_ifname);\n}\n\n/**\n * Obtains a pointer which can store a value for the given preference name.\n * The preference name that can be passed to the prefs API is stored into\n * 'prefs_name'.\n *\n * Extcap interfaces (and their preferences) are dynamic, they can be created\n * and destroyed at will. Thus their data structures are insufficient to pass to\n * the preferences APIs which require pointers which are valid until the\n * preferences are removed (at exit).\n */\nstatic char **extcap_prefs_dynamic_valptr(const char *name, char **pref_name)\n{\n    char **valp;\n    if (!_extcap_prefs_dynamic_vals)\n    {\n        /* Initialize table only as needed, most preferences are not dynamic */\n        _extcap_prefs_dynamic_vals = g_hash_table_new_full(g_str_hash, g_str_equal,\n                                    g_free, g_free);\n    }\n    if (!g_hash_table_lookup_extended(_extcap_prefs_dynamic_vals, name,\n                                      (void * *)pref_name, (void * *)&valp))\n    {\n        /* New dynamic pref, allocate, initialize and store. */\n        valp = g_new0(char *, 1);\n        *pref_name = g_strdup(name);\n        g_hash_table_insert(_extcap_prefs_dynamic_vals, *pref_name, valp);\n    }\n    return valp;\n}\n\nvoid extcap_free_if_configuration(GList *list, bool free_args)\n{\n    GList *elem, *sl;\n\n    for (elem = g_list_first(list); elem; elem = elem->next)\n    {\n        if (elem->data != NULL)\n        {\n            sl = g_list_first((GList *)elem->data);\n            if (free_args)\n            {\n                extcap_free_arg_list(sl);\n            }\n            else\n            {\n                g_list_free(sl);\n            }\n        }\n    }\n    g_list_free(list);\n}\n\npref_t *\nextcap_pref_for_argument(const char *ifname, struct _extcap_arg *arg)\n{\n    pref_t *pref = NULL;\n\n    extcap_ensure_all_interfaces_loaded();\n\n    GRegex *regex_name = g_regex_new(\"[-]+\", G_REGEX_RAW, (GRegexMatchFlags) 0, NULL);\n    GRegex *regex_ifname = g_regex_new(\"(?![a-zA-Z0-9_]).\", G_REGEX_RAW, (GRegexMatchFlags) 0, NULL);\n    if (regex_name && regex_ifname)\n    {\n        module_t *extcap_module = prefs_find_module(\"extcap\");\n        if (extcap_module)\n        {\n            char *pref_name = g_regex_replace(regex_name, arg->call, strlen(arg->call), 0, \"\", (GRegexMatchFlags) 0, NULL);\n            char *ifname_underscore = g_regex_replace(regex_ifname, ifname, strlen(ifname), 0, \"_\", (GRegexMatchFlags) 0, NULL);\n            char *ifname_lowercase = g_ascii_strdown(ifname_underscore, -1);\n            char *pref_ifname = g_strconcat(ifname_lowercase, \".\", pref_name, NULL);\n\n            pref = prefs_find_preference(extcap_module, pref_ifname);\n\n            g_free(pref_name);\n            g_free(ifname_underscore);\n            g_free(ifname_lowercase);\n            g_free(pref_ifname);\n        }\n    }\n    if (regex_name)\n    {\n        g_regex_unref(regex_name);\n    }\n    if (regex_ifname)\n    {\n        g_regex_unref(regex_ifname);\n    }\n\n    return pref;\n}\n\nstatic bool cb_preference(extcap_callback_info_t cb_info)\n{\n    bool new_pref = false;\n    GList *arguments = NULL;\n    GList **il = (GList **) cb_info.data;\n    module_t *dev_module = NULL;\n\n    arguments = extcap_parse_args(cb_info.output);\n\n    dev_module = prefs_find_module(\"extcap\");\n\n    if (dev_module)\n    {\n        GList *walker = arguments;\n\n        GRegex *regex_name = g_regex_new(\"[-]+\", G_REGEX_RAW, (GRegexMatchFlags) 0, NULL);\n        GRegex *regex_ifname = g_regex_new(\"(?![a-zA-Z0-9_]).\", G_REGEX_RAW, (GRegexMatchFlags) 0, NULL);\n        if (regex_name && regex_ifname)\n        {\n            while (walker != NULL)\n            {\n                extcap_arg *arg = (extcap_arg *)walker->data;\n                arg->device_name = g_strdup(cb_info.ifname);\n\n                if (arg->save)\n                {\n                    char *pref_name = g_regex_replace(regex_name, arg->call, strlen(arg->call), 0, \"\", (GRegexMatchFlags) 0, NULL);\n                    char *ifname_underscore = g_regex_replace(regex_ifname, cb_info.ifname, strlen(cb_info.ifname), 0, \"_\", (GRegexMatchFlags) 0, NULL);\n                    char *ifname_lowercase = g_ascii_strdown(ifname_underscore, -1);\n                    char *pref_ifname = g_strconcat(ifname_lowercase, \".\", pref_name, NULL);\n\n                    if (prefs_find_preference(dev_module, pref_ifname) == NULL)\n                    {\n                        char *pref_name_for_prefs;\n                        char *pref_title = wmem_strdup(wmem_epan_scope(), arg->display);\n                        new_pref = true;\n                        arg->pref_valptr = extcap_prefs_dynamic_valptr(pref_ifname, &pref_name_for_prefs);\n                        /* Set an initial value if any (the string will be copied at registration) */\n                        if (arg->default_complex)\n                        {\n                            *arg->pref_valptr = arg->default_complex->_val;\n                        }\n\n                        if (arg->arg_type == EXTCAP_ARG_PASSWORD)\n                        {\n                            prefs_register_password_preference(dev_module, pref_name_for_prefs,\n                                                         pref_title, pref_title, (const char **)arg->pref_valptr);\n                        } else {\n                            prefs_register_string_preference(dev_module, pref_name_for_prefs,\n                                                         pref_title, pref_title, (const char **)arg->pref_valptr);\n                        }\n                    }\n                    else\n                    {\n                        /* Been here before, restore stored value */\n                        if (arg->pref_valptr == NULL)\n                        {\n                            arg->pref_valptr = (char**)g_hash_table_lookup(_extcap_prefs_dynamic_vals, pref_ifname);\n                        }\n                    }\n\n                    g_free(pref_name);\n                    g_free(ifname_underscore);\n                    g_free(ifname_lowercase);\n                    g_free(pref_ifname);\n                }\n\n                walker = g_list_next(walker);\n            }\n        }\n        if (regex_name)\n        {\n            g_regex_unref(regex_name);\n        }\n        if (regex_ifname)\n        {\n            g_regex_unref(regex_ifname);\n        }\n    }\n\n    if (il) {\n        *il = g_list_append(*il, arguments);\n    } else {\n        extcap_free_arg_list(arguments);\n    }\n\n    return new_pref;\n}\n\nGList *\nextcap_get_if_configuration(const char *ifname)\n{\n    GList * arguments = NULL;\n    GList *ret = NULL;\n\n    extcap_ensure_all_interfaces_loaded();\n\n    extcap_interface *interface = extcap_find_interface_for_ifname(ifname);\n    if (interface)\n    {\n        ws_debug(\"Extcap path %s\", get_extcap_dir());\n\n        arguments = g_list_append(arguments, g_strdup(EXTCAP_ARGUMENT_CONFIG));\n        arguments = g_list_append(arguments, g_strdup(EXTCAP_ARGUMENT_INTERFACE));\n        arguments = g_list_append(arguments, g_strdup(ifname));\n\n        extcap_run_one(interface, arguments, cb_preference, &ret, NULL);\n\n        g_list_free_full(arguments, g_free);\n    }\n\n    return ret;\n}\n\nstatic bool cb_reload_preference(extcap_callback_info_t cb_info)\n{\n    GList *arguments = NULL, * walker = NULL;\n    GList **il = (GList **) cb_info.data;\n\n    arguments = extcap_parse_values(cb_info.output);\n\n    walker = g_list_first(arguments);\n    while (walker != NULL)\n    {\n        extcap_value * val = (extcap_value *)walker->data;\n        *il = g_list_append(*il, val);\n        walker = g_list_next(walker);\n    }\n    g_list_free(arguments);\n\n    return false;\n}\n\nGList *\nextcap_get_if_configuration_values(const char * ifname, const char * argname, GHashTable *arguments)\n{\n    GList * args = NULL;\n    GList *ret = NULL;\n\n    extcap_ensure_all_interfaces_loaded();\n\n    extcap_interface *interface = extcap_find_interface_for_ifname(ifname);\n    if (interface)\n    {\n        ws_debug(\"Extcap path %s\", get_extcap_dir());\n\n        args = g_list_append(args, g_strdup(EXTCAP_ARGUMENT_CONFIG));\n        args = g_list_append(args, g_strdup(EXTCAP_ARGUMENT_INTERFACE));\n        args = g_list_append(args, g_strdup(ifname));\n        args = g_list_append(args, g_strdup(EXTCAP_ARGUMENT_RELOAD_OPTION));\n        args = g_list_append(args, g_strdup(argname));\n\n        if ( arguments )\n        {\n            GList * keys = g_hash_table_get_keys(arguments);\n            GList * walker = g_list_first(keys);\n            while ( walker )\n            {\n                const char * key_data = (const char *)walker->data;\n                args = g_list_append(args, g_strdup(key_data));\n                args = g_list_append(args, g_strdup((const char *)g_hash_table_lookup(arguments, key_data)));\n                walker = g_list_next(walker);\n            }\n            g_list_free(keys);\n        }\n\n        extcap_run_one(interface, args, cb_reload_preference, &ret, NULL);\n\n        g_list_free_full(args, g_free);\n    }\n\n    return ret;\n}\n\nbool\n_extcap_requires_configuration_int(const char *ifname, bool check_required)\n{\n    GList *arguments = 0;\n    GList *walker = 0, * item = 0;\n    bool found = false;\n\n    extcap_ensure_all_interfaces_loaded();\n\n    arguments = extcap_get_if_configuration(ifname);\n    walker = g_list_first(arguments);\n\n    while (walker != NULL && !found)\n    {\n        item = g_list_first((GList *)(walker->data));\n        while (item != NULL && !found)\n        {\n            if ((extcap_arg *)(item->data) != NULL)\n            {\n                extcap_arg *arg = (extcap_arg *)(item->data);\n                /* Should required options be present, or any kind of options */\n                if (!check_required)\n                {\n                    found = true;\n                }\n                /* Following branch is executed when check of required items is requested */\n                else if (arg->is_required)\n                {\n                    const char *stored = NULL;\n                    const char *defval = NULL;\n\n                    if (arg->pref_valptr != NULL)\n                    {\n                        stored = *arg->pref_valptr;\n                    }\n\n                    if (arg->default_complex != NULL && arg->default_complex->_val != NULL)\n                    {\n                        defval = arg->default_complex->_val;\n                    }\n\n                    if (arg->is_required)\n                    {\n                        if (!defval && (!stored || !*stored))\n                        {\n                            found = true;\n                        }\n                    }\n\n                    if (arg->arg_type == EXTCAP_ARG_FILESELECT)\n                    {\n                        if (arg->fileexists && !(file_exists(defval) || file_exists(stored)))\n                        {\n                            found = true;\n                        }\n                    }\n                }\n            }\n\n            item = item->next;\n        }\n        walker = walker->next;\n    }\n    extcap_free_if_configuration(arguments, true);\n\n    return found;\n}\n\nbool\nextcap_has_configuration(const char *ifname)\n{\n  return _extcap_requires_configuration_int(ifname, false);\n}\n\nbool\nextcap_requires_configuration(const char *ifname)\n{\n  return _extcap_requires_configuration_int(ifname, true);\n}\n\nstatic bool cb_verify_filter(extcap_callback_info_t cb_info)\n{\n    extcap_filter_status *status = (extcap_filter_status *)cb_info.data;\n    size_t output_size, i;\n\n    output_size = strlen(cb_info.output);\n    if (output_size == 0) {\n        *status = EXTCAP_FILTER_VALID;\n    } else {\n        *status = EXTCAP_FILTER_INVALID;\n        for (i = 0; i < output_size; i++) {\n            if (cb_info.output[i] == '\\n' || cb_info.output[i] == '\\r') {\n                cb_info.output[i] = '\\0';\n                break;\n            }\n        }\n        *cb_info.err_str = g_strdup(cb_info.output);\n    }\n\n    return true;\n}\n\nextcap_filter_status\nextcap_verify_capture_filter(const char *ifname, const char *filter, char **err_str)\n{\n    GList * arguments = NULL;\n    extcap_filter_status status = EXTCAP_FILTER_UNKNOWN;\n\n    extcap_ensure_all_interfaces_loaded();\n\n    extcap_interface *interface = extcap_find_interface_for_ifname(ifname);\n    if (interface)\n    {\n        ws_debug(\"Extcap path %s\", get_extcap_dir());\n\n        arguments = g_list_append(arguments, g_strdup(EXTCAP_ARGUMENT_CAPTURE_FILTER));\n        arguments = g_list_append(arguments, g_strdup(filter));\n        arguments = g_list_append(arguments, g_strdup(EXTCAP_ARGUMENT_INTERFACE));\n        arguments = g_list_append(arguments, g_strdup(ifname));\n\n        extcap_run_one(interface, arguments, cb_verify_filter, &status, err_str);\n        g_list_free_full(arguments, g_free);\n    }\n\n    return status;\n}\n\nbool\nextcap_has_toolbar(const char *ifname)\n{\n    if (!iface_toolbar_use())\n    {\n        return false;\n    }\n\n    extcap_ensure_all_interfaces_loaded();\n\n    GList *toolbar_list = g_hash_table_get_values (_toolbars);\n    for (GList *walker = toolbar_list; walker; walker = walker->next)\n    {\n        iface_toolbar *toolbar = (iface_toolbar *) walker->data;\n        if (g_list_find_custom(toolbar->ifnames, ifname, (GCompareFunc) g_strcmp0))\n        {\n            g_list_free(toolbar_list);\n            return true;\n        }\n    }\n\n    g_list_free(toolbar_list);\n    return false;\n}\n\n#ifdef HAVE_LIBPCAP\nstatic gboolean extcap_terminate_cb(void *user_data)\n{\n    capture_session *cap_session = (capture_session *)user_data;\n    capture_options *capture_opts = cap_session->capture_opts;\n    interface_options *interface_opts;\n    unsigned icnt;\n    bool all_finished = true;\n\n    for (icnt = 0; icnt < capture_opts->ifaces->len; icnt++)\n    {\n        interface_opts = &g_array_index(capture_opts->ifaces, interface_options,\n                                       icnt);\n\n        /* skip native interfaces */\n        if (interface_opts->if_type != IF_EXTCAP)\n        {\n            continue;\n        }\n\n        if (interface_opts->extcap_pid != WS_INVALID_PID)\n        {\n#ifdef _WIN32\n            TerminateProcess(interface_opts->extcap_pid, 0);\n#else\n            kill(interface_opts->extcap_pid, SIGKILL);\n#endif\n            all_finished = false;\n        }\n\n        /* Do not care about stdout/stderr anymore */\n        if (interface_opts->extcap_stdout_watch > 0)\n        {\n            g_source_remove(interface_opts->extcap_stdout_watch);\n            interface_opts->extcap_stdout_watch = 0;\n        }\n\n        if (interface_opts->extcap_stderr_watch > 0)\n        {\n            g_source_remove(interface_opts->extcap_stderr_watch);\n            interface_opts->extcap_stderr_watch = 0;\n        }\n    }\n\n    capture_opts->wait_for_extcap_cbs = true;\n    capture_opts->extcap_terminate_id = 0;\n    if (all_finished)\n    {\n        capture_process_finished(cap_session);\n    }\n\n    return G_SOURCE_REMOVE;\n}\n\nvoid extcap_request_stop(capture_session *cap_session)\n{\n    capture_options *capture_opts = cap_session->capture_opts;\n    interface_options *interface_opts;\n    unsigned icnt = 0;\n\n    if (capture_opts->extcap_terminate_id > 0)\n    {\n        /* Already requested, do not extend timeout */\n        return;\n    }\n\n    if (capture_opts->wait_for_extcap_cbs)\n    {\n        /* Terminate callback was called, waiting for child callbacks */\n        return;\n    }\n\n    if (extcap_session_stop(cap_session))\n    {\n        /* Nothing left to do, all extcaps have fully finished */\n        return;\n    }\n\n    for (icnt = 0; icnt < capture_opts->ifaces->len; icnt++)\n    {\n        interface_opts = &g_array_index(capture_opts->ifaces, interface_options,\n                                       icnt);\n\n        /* skip native interfaces */\n        if (interface_opts->if_type != IF_EXTCAP)\n        {\n            continue;\n        }\n\n        ws_debug(\"Extcap [%s] - Requesting stop PID: %\"PRIdMAX, interface_opts->name,\n              (intmax_t)interface_opts->extcap_pid);\n\n#ifndef _WIN32\n        if (interface_opts->extcap_pid != WS_INVALID_PID)\n        {\n            kill(interface_opts->extcap_pid, SIGTERM);\n        }\n#endif\n    }\n\n    capture_opts->extcap_terminate_id =\n        g_timeout_add_seconds(EXTCAP_CLEANUP_TIMEOUT, extcap_terminate_cb, cap_session);\n}\n\nstatic gboolean\nextcap_add_arg_and_remove_cb(void *key, void *value, void *data)\n{\n    GPtrArray *args = (GPtrArray *)data;\n\n    if (key != NULL)\n    {\n        g_ptr_array_add(args, g_strdup((const char *)key));\n\n        if (value != NULL)\n        {\n            g_ptr_array_add(args, g_strdup((const char *)value));\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nbool extcap_session_stop(capture_session *cap_session)\n{\n    capture_options *capture_opts = cap_session->capture_opts;\n    interface_options *interface_opts;\n    unsigned i;\n\n    for (i = 0; i < capture_opts->ifaces->len; i++)\n    {\n        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);\n        if (interface_opts->if_type != IF_EXTCAP)\n        {\n            continue;\n        }\n\n        if ((interface_opts->extcap_pid != WS_INVALID_PID) ||\n            (interface_opts->extcap_stdout_watch > 0) ||\n            (interface_opts->extcap_stderr_watch > 0))\n        {\n            /* Capture session is not finished, wait for remaining watches */\n            return false;\n        }\n\n        g_free(interface_opts->extcap_pipedata);\n        interface_opts->extcap_pipedata = NULL;\n\n#ifdef _WIN32\n        if (interface_opts->extcap_pipe_h != INVALID_HANDLE_VALUE)\n        {\n            ws_debug(\"Extcap [%s] - Closing pipe\", interface_opts->name);\n            FlushFileBuffers(interface_opts->extcap_pipe_h);\n            DisconnectNamedPipe(interface_opts->extcap_pipe_h);\n            CloseHandle(interface_opts->extcap_pipe_h);\n            interface_opts->extcap_pipe_h = INVALID_HANDLE_VALUE;\n        }\n        if (interface_opts->extcap_control_in_h != INVALID_HANDLE_VALUE)\n        {\n            ws_debug(\"Extcap [%s] - Closing control_in pipe\", interface_opts->name);\n            FlushFileBuffers(interface_opts->extcap_control_in_h);\n            DisconnectNamedPipe(interface_opts->extcap_control_in_h);\n            CloseHandle(interface_opts->extcap_control_in_h);\n            interface_opts->extcap_control_in_h = INVALID_HANDLE_VALUE;\n        }\n        if (interface_opts->extcap_control_out_h != INVALID_HANDLE_VALUE)\n        {\n            ws_debug(\"Extcap [%s] - Closing control_out pipe\", interface_opts->name);\n            FlushFileBuffers(interface_opts->extcap_control_out_h);\n            DisconnectNamedPipe(interface_opts->extcap_control_out_h);\n            CloseHandle(interface_opts->extcap_control_out_h);\n            interface_opts->extcap_control_out_h = INVALID_HANDLE_VALUE;\n        }\n#else\n        if (interface_opts->extcap_fifo != NULL && file_exists(interface_opts->extcap_fifo))\n        {\n            /* If extcap didn't open the fifo, dumpcap would be waiting on it\n             * until user manually stops capture. Simply open and close fifo\n             * here to let dumpcap return from the select() call. This has no\n             * effect if dumpcap is not waiting.\n             */\n            int fd = ws_open(interface_opts->extcap_fifo, O_WRONLY|O_NONBLOCK, 0000);\n            if (fd != -1) {\n                close(fd);\n            }\n            /* the fifo will not be freed here, but with the other capture_opts in capture_sync */\n            ws_unlink(interface_opts->extcap_fifo);\n            get_dirname(interface_opts->extcap_fifo);\n            rmdir(interface_opts->extcap_fifo);\n            interface_opts->extcap_fifo = NULL;\n        }\n        if (interface_opts->extcap_control_in && file_exists(interface_opts->extcap_control_in))\n        {\n            ws_unlink(interface_opts->extcap_control_in);\n            interface_opts->extcap_control_in = NULL;\n        }\n        if (interface_opts->extcap_control_out && file_exists(interface_opts->extcap_control_out))\n        {\n            ws_unlink(interface_opts->extcap_control_out);\n            interface_opts->extcap_control_out = NULL;\n        }\n#endif\n    }\n\n    /* All child processes finished */\n    capture_opts->wait_for_extcap_cbs = false;\n    if (capture_opts->extcap_terminate_id > 0)\n    {\n        g_source_remove(capture_opts->extcap_terminate_id);\n        capture_opts->extcap_terminate_id = 0;\n    }\n\n    /* Nothing left to do, do not prevent capture session stop */\n    return true;\n}\n\nstatic void\nextcap_watch_removed(capture_session *cap_session, interface_options *interface_opts)\n{\n    if ((interface_opts->extcap_pid == WS_INVALID_PID) &&\n        (interface_opts->extcap_stdout_watch == 0) &&\n        (interface_opts->extcap_stderr_watch == 0))\n    {\n        /* Close session if this was the last remaining process */\n        capture_process_finished(cap_session);\n    }\n}\n\nstatic interface_options *\nextcap_find_channel_interface(capture_session *cap_session, GIOChannel *source)\n{\n    capture_options *capture_opts = cap_session->capture_opts;\n    interface_options *interface_opts;\n    unsigned i;\n\n    for (i = 0; i < capture_opts->ifaces->len; i++)\n    {\n        ws_pipe_t *pipedata;\n        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);\n        pipedata = (ws_pipe_t *)interface_opts->extcap_pipedata;\n        if (pipedata &&\n            ((pipedata->stdout_io == source) || (pipedata->stderr_io == source)))\n        {\n            return interface_opts;\n        }\n    }\n\n    ws_assert_not_reached();\n}\n\nstatic gboolean\nextcap_stdout_cb(GIOChannel *source, GIOCondition condition _U_, void *data)\n{\n    capture_session *cap_session = (capture_session *)data;\n    interface_options *interface_opts = extcap_find_channel_interface(cap_session, source);\n    char buf[128];\n    size_t bytes_read = 0;\n    GIOStatus status = G_IO_STATUS_EOF;\n\n    /* Discard data to prevent child process hanging on stdout write */\n    if (condition & G_IO_IN)\n    {\n        status = g_io_channel_read_chars(source, buf, sizeof(buf), &bytes_read, NULL);\n    }\n\n    if ((bytes_read == 0) || (status != G_IO_STATUS_NORMAL))\n    {\n        interface_opts->extcap_stdout_watch = 0;\n        extcap_watch_removed(cap_session, interface_opts);\n        return G_SOURCE_REMOVE;\n    }\n    return G_SOURCE_CONTINUE;\n}\n\nstatic gboolean\nextcap_stderr_cb(GIOChannel *source, GIOCondition condition, void *data)\n{\n    capture_session *cap_session = (capture_session *)data;\n    interface_options *interface_opts = extcap_find_channel_interface(cap_session, source);\n    char buf[128];\n    size_t bytes_read = 0;\n    GIOStatus status = G_IO_STATUS_EOF;\n\n    if (condition & G_IO_IN)\n    {\n        status = g_io_channel_read_chars(source, buf, sizeof(buf), &bytes_read, NULL);\n    }\n\n#define STDERR_BUFFER_SIZE 1024\n    if (bytes_read > 0)\n    {\n        if (interface_opts->extcap_stderr == NULL)\n        {\n            interface_opts->extcap_stderr = g_string_new_len(buf, bytes_read);\n        }\n        else\n        {\n            ssize_t remaining = STDERR_BUFFER_SIZE - interface_opts->extcap_stderr->len;\n            if (remaining > 0)\n            {\n                ssize_t bytes = bytes_read;\n                bytes = MIN(bytes, remaining);\n                g_string_append_len(interface_opts->extcap_stderr, buf, bytes);\n            }\n        }\n    }\n\n    if ((bytes_read == 0) || (status != G_IO_STATUS_NORMAL))\n    {\n        interface_opts->extcap_stderr_watch = 0;\n        extcap_watch_removed(cap_session, interface_opts);\n        return G_SOURCE_REMOVE;\n    }\n    return G_SOURCE_CONTINUE;\n}\n\nstatic void extcap_child_watch_cb(GPid pid, int status _U_, void *user_data)\n{\n    unsigned i;\n    interface_options *interface_opts;\n    capture_session *cap_session = (capture_session *)(user_data);\n    capture_options *capture_opts = cap_session->capture_opts;\n\n    /* Close handle to child process. */\n    g_spawn_close_pid(pid);\n\n    /* Update extcap_pid in interface options structure. */\n    for (i = 0; i < capture_opts->ifaces->len; i++)\n    {\n        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);\n        if (interface_opts->extcap_pid == pid)\n        {\n            ws_debug(\"Extcap [%s] - Closing spawned PID: %\"PRIdMAX, interface_opts->name,\n                     (intmax_t)interface_opts->extcap_pid);\n            interface_opts->extcap_pid = WS_INVALID_PID;\n            extcap_watch_removed(cap_session, interface_opts);\n            break;\n        }\n    }\n}\n\nstatic\nGPtrArray *extcap_prepare_arguments(interface_options *interface_opts)\n{\n    GPtrArray *result = NULL;\n\n    if (interface_opts->if_type == IF_EXTCAP)\n    {\n        result = g_ptr_array_new();\n\n#define add_arg(X) g_ptr_array_add(result, g_strdup(X))\n\n        add_arg(interface_opts->extcap);\n        add_arg(EXTCAP_ARGUMENT_RUN_CAPTURE);\n        add_arg(EXTCAP_ARGUMENT_INTERFACE);\n        add_arg(interface_opts->name);\n        if (interface_opts->cfilter && strlen(interface_opts->cfilter) > 0)\n        {\n            add_arg(EXTCAP_ARGUMENT_CAPTURE_FILTER);\n            add_arg(interface_opts->cfilter);\n        }\n        add_arg(EXTCAP_ARGUMENT_RUN_PIPE);\n        add_arg(interface_opts->extcap_fifo);\n        if (interface_opts->extcap_control_in)\n        {\n            add_arg(EXTCAP_ARGUMENT_CONTROL_OUT);\n            add_arg(interface_opts->extcap_control_in);\n        }\n        if (interface_opts->extcap_control_out)\n        {\n            add_arg(EXTCAP_ARGUMENT_CONTROL_IN);\n            add_arg(interface_opts->extcap_control_out);\n        }\n        if (interface_opts->extcap_args == NULL || g_hash_table_size(interface_opts->extcap_args) == 0)\n        {\n            /* User did not perform interface configuration.\n             *\n             * Check if there are any boolean flags that are set by default\n             * and hence their argument should be added.\n             */\n            GList *arglist;\n            GList *elem;\n\n            arglist = extcap_get_if_configuration(interface_opts->name);\n            for (elem = g_list_first(arglist); elem; elem = elem->next)\n            {\n                GList *arg_list;\n                extcap_arg *arg_iter;\n\n                if (elem->data == NULL)\n                {\n                    continue;\n                }\n\n                arg_list = g_list_first((GList *)elem->data);\n                while (arg_list != NULL)\n                {\n                    const char *stored = NULL;\n                    /* In case of boolflags only first element in arg_list is relevant. */\n                    arg_iter = (extcap_arg *)(arg_list->data);\n                    if (arg_iter->pref_valptr != NULL)\n                    {\n                        stored = *arg_iter->pref_valptr;\n                    }\n\n                    if (arg_iter->arg_type == EXTCAP_ARG_BOOLFLAG)\n                    {\n                        if (!stored && extcap_complex_get_bool(arg_iter->default_complex))\n                        {\n                            add_arg(arg_iter->call);\n                        }\n                        else if (g_strcmp0(stored, \"true\") == 0)\n                        {\n                            add_arg(arg_iter->call);\n                        }\n                    }\n                    else\n                    {\n                        if (stored && strlen(stored) > 0) {\n                            add_arg(arg_iter->call);\n                            add_arg(stored);\n                        }\n                    }\n\n                    arg_list = arg_list->next;\n                }\n            }\n\n            extcap_free_if_configuration(arglist, true);\n        }\n        else\n        {\n            g_hash_table_foreach_remove(interface_opts->extcap_args, extcap_add_arg_and_remove_cb, result);\n        }\n        add_arg(NULL);\n#undef add_arg\n\n    }\n\n    return result;\n}\n\nstatic void ptr_array_free(void *data, void *user_data _U_)\n{\n    g_free(data);\n}\n\n#ifdef _WIN32\nstatic bool extcap_create_pipe(const char *ifname, char **fifo, HANDLE *handle_out, const char *pipe_prefix)\n{\n    char timestr[ 14 + 1 ];\n    time_t current_time;\n    char *pipename = NULL;\n    SECURITY_ATTRIBUTES security;\n\n    /* create pipename */\n    current_time = time(NULL);\n    /*\n     * XXX - we trust Windows not to return a time before the Epoch here,\n     * so we won't get a null pointer back from localtime().\n     */\n    strftime(timestr, sizeof(timestr), \"%Y%m%d%H%M%S\", localtime(&current_time));\n    pipename = g_strconcat(\"\\\\\\\\.\\\\pipe\\\\\", pipe_prefix, \"_\", ifname, \"_\", timestr, NULL);\n\n    /* Security struct to enable Inheritable HANDLE */\n    memset(&security, 0, sizeof(SECURITY_ATTRIBUTES));\n    security.nLength = sizeof(SECURITY_ATTRIBUTES);\n    security.bInheritHandle = false;\n    security.lpSecurityDescriptor = NULL;\n\n    /* create a namedPipe */\n    *handle_out = CreateNamedPipe(\n                 utf_8to16(pipename),\n                 PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,\n                 PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,\n                 1, 65536, 65536,\n                 300,\n                 &security);\n\n    if (*handle_out == INVALID_HANDLE_VALUE)\n    {\n        ws_debug(\"Error creating pipe => (%ld)\", GetLastError());\n        g_free (pipename);\n        return false;\n    }\n    else\n    {\n        ws_debug(\"Wireshark Created pipe =>(%s) handle (%\" PRIuMAX \")\", pipename, (uintmax_t)*handle_out);\n        *fifo = g_strdup(pipename);\n    }\n\n    return true;\n}\n#else\nstatic bool extcap_create_pipe(const char *ifname, char **fifo, const char *temp_dir, const char *pipe_prefix)\n{\n    char *subdir_tmpl = g_strdup_printf(\"%s_%s_XXXXXX\", pipe_prefix, ifname);\n    char *temp_subdir = create_tempdir(temp_dir, subdir_tmpl, NULL);\n\n    g_free(subdir_tmpl);\n    if (temp_subdir == NULL)\n    {\n        return false;\n    }\n\n    char *fifo_path = g_build_path(G_DIR_SEPARATOR_S, temp_subdir, \"fifo\", NULL);\n    g_free(temp_subdir);\n\n    ws_debug(\"Extcap - Creating fifo: %s\", fifo_path);\n\n    if (mkfifo(fifo_path, 0600) == 0)\n    {\n        *fifo = fifo_path;\n    }\n    else\n    {\n        g_free(fifo_path);\n    }\n    return true;\n}\n#endif\n\n/* call mkfifo for each extcap,\n * returns false if there's an error creating a FIFO */\nbool\nextcap_init_interfaces(capture_session *cap_session)\n{\n    capture_options *capture_opts = cap_session->capture_opts;\n    unsigned i;\n    interface_options *interface_opts;\n    ws_pipe_t *pipedata;\n\n    extcap_ensure_all_interfaces_loaded();\n\n    for (i = 0; i < capture_opts->ifaces->len; i++)\n    {\n        GPtrArray *args = NULL;\n        GPid pid = WS_INVALID_PID;\n\n        interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);\n\n        /* skip native interfaces */\n        if (interface_opts->if_type != IF_EXTCAP)\n        {\n            continue;\n        }\n\n        /* create control pipes if having toolbar */\n        if (extcap_has_toolbar(interface_opts->name))\n        {\n            extcap_create_pipe(interface_opts->name, &interface_opts->extcap_control_in,\n#ifdef _WIN32\n                               &interface_opts->extcap_control_in_h,\n#else\n                               capture_opts->temp_dir,\n#endif\n                               EXTCAP_CONTROL_IN_PREFIX);\n            extcap_create_pipe(interface_opts->name, &interface_opts->extcap_control_out,\n#ifdef _WIN32\n                               &interface_opts->extcap_control_out_h,\n#else\n                               capture_opts->temp_dir,\n#endif\n                               EXTCAP_CONTROL_OUT_PREFIX);\n        }\n\n        /* create pipe for fifo */\n        if (!extcap_create_pipe(interface_opts->name, &interface_opts->extcap_fifo,\n#ifdef _WIN32\n                                &interface_opts->extcap_pipe_h,\n#else\n                               capture_opts->temp_dir,\n#endif\n                                EXTCAP_PIPE_PREFIX))\n        {\n            return false;\n        }\n\n\n        /* Create extcap call */\n        args = extcap_prepare_arguments(interface_opts);\n\n        pipedata = g_new0(ws_pipe_t, 1);\n\n        pid = ws_pipe_spawn_async(pipedata, args);\n\n        g_ptr_array_foreach(args, ptr_array_free, NULL);\n        g_ptr_array_free(args, true);\n\n        if (pid == WS_INVALID_PID)\n        {\n            g_free(pipedata);\n            continue;\n        }\n\n        g_io_channel_unref(pipedata->stdin_io);\n        pipedata->stdin_io = NULL;\n        interface_opts->extcap_pid = pid;\n\n        g_child_watch_add_full(G_PRIORITY_HIGH, pid, extcap_child_watch_cb,\n                               (void *)cap_session, NULL);\n        interface_opts->extcap_stdout_watch =\n            g_io_add_watch(pipedata->stdout_io, G_IO_IN | G_IO_HUP,\n                           extcap_stdout_cb, (void *)cap_session);\n        interface_opts->extcap_stderr_watch =\n            g_io_add_watch(pipedata->stderr_io, G_IO_IN | G_IO_HUP,\n                           extcap_stderr_cb, (void *)cap_session);\n\n        /* Pipedata pointers are only used to match GIOChannel to interface.\n         * GIOChannel watch holds the only remaining reference.\n         */\n        g_io_channel_unref(pipedata->stdout_io);\n        g_io_channel_unref(pipedata->stderr_io);\n\n#ifdef _WIN32\n        /* On Windows, wait for extcap to connect to named pipe.\n         * Some extcaps will present UAC screen to user.\n         * 30 second timeout should be reasonable timeout for extcap to\n         * connect to named pipe (including user interaction).\n         * Wait on multiple object in case of extcap termination\n         * without opening pipe.\n         */\n        if (pid != WS_INVALID_PID)\n        {\n            HANDLE pipe_handles[3];\n            int num_pipe_handles = 1;\n            pipe_handles[0] = interface_opts->extcap_pipe_h;\n\n            if (extcap_has_toolbar(interface_opts->name))\n            {\n                pipe_handles[1] = interface_opts->extcap_control_in_h;\n                pipe_handles[2] = interface_opts->extcap_control_out_h;\n                num_pipe_handles += 2;\n             }\n\n            ws_pipe_wait_for_pipe(pipe_handles, num_pipe_handles, pid);\n        }\n#endif\n\n        interface_opts->extcap_pipedata = (void *) pipedata;\n    }\n\n    return true;\n}\n#endif /* HAVE_LIBPCAP */\n\n/************* EXTCAP LOAD INTERFACE LIST ***************\n *\n * The following code handles loading and reloading the interface list. It is explicitly\n * kept separate from the rest\n */\n\n\nstatic void\nextcap_free_interface_info(void *data)\n{\n    extcap_info *info = (extcap_info *)data;\n\n    g_free(info->basename);\n    g_free(info->full_path);\n    g_free(info->version);\n    g_free(info->help);\n\n    extcap_free_interfaces(info->interfaces);\n\n    g_free(info);\n}\n\nstatic extcap_info *\nextcap_ensure_interface(const char * toolname, bool create_if_nonexist)\n{\n    extcap_info * element = 0;\n\n    if ( prefs.capture_no_extcap )\n        return NULL;\n\n    if ( ! toolname )\n        return element;\n\n    if ( ! _loaded_interfaces )\n        _loaded_interfaces = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, extcap_free_interface);\n\n    element = (extcap_info *) g_hash_table_lookup(_loaded_interfaces, toolname );\n    if ( element )\n        return NULL;\n\n    if ( ! element && create_if_nonexist )\n    {\n        g_hash_table_insert(_loaded_interfaces, g_strdup(toolname), g_new0(extcap_info, 1));\n        element = (extcap_info *) g_hash_table_lookup(_loaded_interfaces, toolname );\n    }\n\n    return element;\n}\n\nextcap_info *\nextcap_get_tool_by_ifname(const char *ifname)\n{\n    extcap_ensure_all_interfaces_loaded();\n\n    if ( ifname && _tool_for_ifname )\n    {\n        char * toolname = (char *)g_hash_table_lookup(_tool_for_ifname, ifname);\n        if ( toolname )\n            return extcap_ensure_interface(toolname, false);\n    }\n\n    return NULL;\n}\n\nextcap_info *\nextcap_get_tool_info(const char * toolname)\n{\n    extcap_ensure_all_interfaces_loaded();\n\n    return extcap_ensure_interface(toolname, false);\n}\n\nstatic void remove_extcap_entry(void *entry, void *data _U_)\n{\n    extcap_interface *int_iter = (extcap_interface*)entry;\n\n    if (int_iter->if_type == EXTCAP_SENTENCE_EXTCAP)\n        extcap_free_interface(entry);\n}\n\nstatic void\nprocess_new_extcap(const char *extcap, char *output)\n{\n    GList * interfaces = NULL, * control_items = NULL, * walker = NULL;\n    extcap_interface * int_iter = NULL;\n    extcap_info * element = NULL;\n    iface_toolbar * toolbar_entry = NULL;\n    char * toolname = g_path_get_basename(extcap);\n\n    GList * interface_keys = g_hash_table_get_keys(_loaded_interfaces);\n\n    /* Load interfaces from utility */\n    interfaces = extcap_parse_interfaces(output, &control_items);\n\n    ws_debug(\"Loading interface list for %s \", extcap);\n\n    /* Seems, that there where no interfaces to be loaded */\n    if ( ! interfaces || g_list_length(interfaces) == 0 )\n    {\n        ws_debug(\"Cannot load interfaces for %s\", extcap );\n        g_list_free(interface_keys);\n        g_free(toolname);\n        return;\n    }\n\n    /* Load or create the storage element for the tool */\n    element = extcap_ensure_interface(toolname, true);\n    if ( element == NULL )\n    {\n        ws_warning(\"Cannot store interface %s, already loaded as personal plugin\", extcap );\n        g_list_foreach(interfaces, remove_extcap_entry, NULL);\n        g_list_free(interfaces);\n        g_list_free(interface_keys);\n        g_free(toolname);\n        return;\n    }\n\n    if (control_items)\n    {\n        toolbar_entry = g_new0(iface_toolbar, 1);\n        toolbar_entry->controls = control_items;\n    }\n\n    walker = interfaces;\n    char* help = NULL;\n    while (walker != NULL)\n    {\n        int_iter = (extcap_interface *)walker->data;\n\n        if (int_iter->call != NULL)\n            ws_debug(\"Interface found %s\\n\", int_iter->call);\n\n        /* Help is not necessarily stored with the interface, but rather with the version string.\n         * As the version string always comes in front of the interfaces, this ensures, that it gets\n         * properly stored with the interface */\n        if (int_iter->if_type == EXTCAP_SENTENCE_EXTCAP)\n        {\n            if (int_iter->call != NULL)\n                ws_debug(\"  Extcap [%s] \", int_iter->call);\n\n            /* Only initialize values if none are set. Need to check only one element here */\n            if ( ! element->version )\n            {\n                element->version = g_strdup(int_iter->version);\n                element->basename = g_strdup(toolname);\n                element->full_path = g_strdup(extcap);\n                element->help = g_strdup(int_iter->help);\n            }\n\n            help = int_iter->help;\n            if (toolbar_entry)\n            {\n                toolbar_entry->menu_title = g_strdup(int_iter->display);\n                toolbar_entry->help = g_strdup(int_iter->help);\n            }\n\n            walker = g_list_next(walker);\n            continue;\n        }\n\n        /* Only interface definitions will be parsed here. help is already set by the extcap element,\n         * which makes it necessary to have version in the list before the interfaces. This is normally\n         * the case by design, but could be changed by separating the information in extcap-base. */\n        if ( int_iter->if_type == EXTCAP_SENTENCE_INTERFACE )\n        {\n            if ( g_list_find(interface_keys, int_iter->call) )\n            {\n                ws_warning(\"Extcap interface \\\"%s\\\" is already provided by \\\"%s\\\" \",\n                      int_iter->call, extcap_if_executable(int_iter->call));\n                walker = g_list_next(walker);\n                continue;\n            }\n\n            if ((int_iter->call != NULL) && (int_iter->display))\n                ws_debug(\"  Interface [%s] \\\"%s\\\" \", int_iter->call, int_iter->display);\n\n            int_iter->extcap_path = g_strdup(extcap);\n\n            /* Only set the help, if it exists and no parsed help information is present */\n            if ( ! int_iter->help && help )\n                int_iter->help = g_strdup(help);\n\n            element->interfaces = g_list_append(element->interfaces, int_iter);\n            g_hash_table_insert(_tool_for_ifname, g_strdup(int_iter->call), g_strdup(toolname));\n\n            if (toolbar_entry)\n            {\n                if (!toolbar_entry->menu_title)\n                {\n                    toolbar_entry->menu_title = g_strdup(int_iter->display);\n                }\n                toolbar_entry->ifnames = g_list_append(toolbar_entry->ifnames, g_strdup(int_iter->call));\n            }\n        }\n\n        walker = g_list_next(walker);\n    }\n\n    if (toolbar_entry && toolbar_entry->menu_title)\n    {\n        iface_toolbar_add(toolbar_entry);\n        if (extcap_iface_toolbar_add(extcap, toolbar_entry))\n        {\n            toolbar_entry = NULL;\n        }\n    }\n\n    extcap_free_toolbar(toolbar_entry);\n    g_list_foreach(interfaces, remove_extcap_entry, NULL);\n    g_list_free(interfaces);\n    g_list_free(interface_keys);\n    g_free(toolname);\n}\n\n\n/** Thread callback to save the output of a --extcap-config call. */\nstatic void\nextcap_process_config_cb(thread_pool_t *pool _U_, void *data, char *output)\n{\n    extcap_iface_info_t *iface_info = (extcap_iface_info_t *)data;\n    iface_info->output = output;\n}\n\n/**\n * Thread callback to process discovered interfaces, scheduling more tasks to\n * retrieve the configuration for each interface. Called once for every extcap\n * program.\n */\nstatic void\nextcap_process_interfaces_cb(thread_pool_t *pool, void *data, char *output)\n{\n    extcap_run_extcaps_info_t *info = (extcap_run_extcaps_info_t *)data;\n    unsigned i = 0;\n    unsigned num_interfaces = 0;\n\n    if (!output) {\n        // No interfaces available, nothing to do.\n        return;\n    }\n\n    // Save output for process_new_extcap.\n    info->output = output;\n\n    // Are there any interfaces to query information from?\n    GList *interfaces = extcap_parse_interfaces(output, NULL);\n    for (GList *iface = interfaces; iface; iface = g_list_next(iface)) {\n        extcap_interface *intf = (extcap_interface *)iface->data;\n        if (intf->if_type == EXTCAP_SENTENCE_INTERFACE) {\n            ++num_interfaces;\n        }\n    }\n    if (num_interfaces == 0) {\n        // nothing to do.\n        g_list_free_full(interfaces, extcap_free_interface);\n        return;\n    }\n\n    /* GSList is not thread-safe, so pre-allocate an array instead. */\n    info->iface_infos = g_new0(extcap_iface_info_t, num_interfaces);\n    info->num_interfaces = num_interfaces;\n\n    // Schedule new commands to retrieve the configuration.\n    for (GList *iface = interfaces; iface; iface = g_list_next(iface)) {\n        extcap_interface *intf = (extcap_interface *)iface->data;\n        if (intf->if_type != EXTCAP_SENTENCE_INTERFACE) {\n            continue;\n        }\n\n        const char *argv[] = {\n            EXTCAP_ARGUMENT_CONFIG,\n            EXTCAP_ARGUMENT_INTERFACE,\n            intf->call,\n            NULL\n        };\n        extcap_run_task_t *task = g_new0(extcap_run_task_t, 1);\n        extcap_iface_info_t *iface_info = &info->iface_infos[i++];\n\n        task->extcap_path = info->extcap_path;\n        task->argv = g_strdupv((char **)argv);\n        task->output_cb = extcap_process_config_cb;\n        task->data = iface_info;\n        iface_info->ifname = g_strdup(intf->call);\n\n        thread_pool_push(pool, task, NULL);\n    }\n    g_list_free_full(interfaces, extcap_free_interface);\n}\n\n/**\n * Thread callback to check whether the new-style --list-interfaces call with an\n * explicit function succeeded. If not, schedule a call without the new version\n * argument.\n */\nstatic void\nextcap_list_interfaces_cb(thread_pool_t *pool, void *data, char *output)\n{\n    extcap_run_extcaps_info_t *info = (extcap_run_extcaps_info_t *)data;\n\n    if (!output) {\n        /* No output available, schedule a fallback query. */\n        const char *argv[] = {\n            EXTCAP_ARGUMENT_LIST_INTERFACES,\n            NULL\n        };\n        extcap_run_task_t *task = g_new0(extcap_run_task_t, 1);\n\n        task->extcap_path = info->extcap_path;\n        task->argv = g_strdupv((char **)argv);\n        task->output_cb = extcap_process_interfaces_cb;\n        task->data = info;\n\n        thread_pool_push(pool, task, NULL);\n    } else {\n        extcap_process_interfaces_cb(pool, info, output);\n    }\n}\n\n\n/* Handles loading of the interfaces. */\nstatic void\nextcap_load_interface_list(void)\n{\n    bool prefs_registered = false;\n    if (prefs.capture_no_extcap)\n        return;\n\n    if (_toolbars)\n    {\n        // Remove existing interface toolbars here instead of in extcap_clear_interfaces()\n        // to avoid flicker in shown toolbars when refreshing interfaces.\n        GList *toolbar_list = g_hash_table_get_values (_toolbars);\n        for (GList *walker = toolbar_list; walker; walker = walker->next)\n        {\n            iface_toolbar *toolbar = (iface_toolbar *) walker->data;\n            iface_toolbar_remove(toolbar->menu_title);\n        }\n        g_list_free(toolbar_list);\n        g_hash_table_remove_all(_toolbars);\n    } else {\n        _toolbars = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, extcap_free_toolbar);\n    }\n\n    if (_loaded_interfaces == NULL)\n    {\n        int major = 0;\n        int minor = 0;\n        unsigned count = 0;\n        extcap_run_extcaps_info_t *infos;\n\n        _loaded_interfaces = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, extcap_free_interface_info);\n        /* Cleanup lookup table */\n        if ( _tool_for_ifname )\n        {\n            g_hash_table_remove_all(_tool_for_ifname);\n            _tool_for_ifname = 0;\n        } else {\n            _tool_for_ifname = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n        }\n\n        get_ws_version_number(&major, &minor, NULL);\n        char *arg_version = ws_strdup_printf(\"%s=%d.%d\", EXTCAP_ARGUMENT_VERSION, major, minor);\n        const char *argv[] = {\n            EXTCAP_ARGUMENT_LIST_INTERFACES,\n            arg_version,\n            NULL\n        };\n        infos = (extcap_run_extcaps_info_t *)extcap_run_all(argv,\n                extcap_list_interfaces_cb, sizeof(extcap_run_extcaps_info_t),\n                &count);\n        for (unsigned i = 0; i < count; i++) {\n            if (!infos[i].output) {\n                continue;\n            }\n\n            // Save new extcap and each discovered interface.\n            process_new_extcap(infos[i].extcap_path, infos[i].output);\n            for (unsigned j = 0; j < infos[i].num_interfaces; j++) {\n                extcap_iface_info_t *iface_info = &infos[i].iface_infos[j];\n\n                if (!iface_info->output) {\n                    continue;\n                }\n\n                extcap_callback_info_t cb_info = {\n                    .ifname = iface_info->ifname,\n                    .output = iface_info->output,\n                    .data = NULL,\n                };\n                prefs_registered = cb_preference(cb_info);\n            }\n        }\n        extcap_free_extcaps_info_array(infos, count);\n        g_free(arg_version);\n    }\n\n    if (prefs_registered)\n    {\n        prefs_read_module(\"extcap\");\n    }\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "extcap.h",
          "type": "blob",
          "size": 8.4609375,
          "content": "/** @file\n *\n * Definitions for extcap external capture\n * Copyright 2013, Mike Ryan <mikeryan@lacklustre.net>\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#ifndef __EXTCAP_H__\n#define __EXTCAP_H__\n\n\n#include <glib.h>\n\n#ifdef _WIN32\n#include <wsutil/unicode-utils.h>\n#endif\n\n#include <wsutil/plugins.h>\n\n#include \"capture/capture_session.h\"\n#include <ui/capture_ui_utils.h>\n\n/* As boolean flags will be allowed any form of yes, true or any number != 0 (or starting with 0)\n * The regex will be matched case-insensitive, so only the lower-case is defined here. */\n#define EXTCAP_BOOLEAN_REGEX \"^.*([yt1-9])\"\n\n/* Prefix for the pipe interfaces */\n#define EXTCAP_PIPE_PREFIX \"wireshark_extcap\"\n#define EXTCAP_CONTROL_IN_PREFIX  \"wireshark_control_ext_to_ws\"\n#define EXTCAP_CONTROL_OUT_PREFIX \"wireshark_control_ws_to_ext\"\n\n#define EXTCAP_ARGUMENT_CONFIG                  \"--extcap-config\"\n#define EXTCAP_ARGUMENT_RELOAD_OPTION           \"--extcap-reload-option\"\n#define EXTCAP_ARGUMENT_LIST_INTERFACES         \"--extcap-interfaces\"\n#define EXTCAP_ARGUMENT_INTERFACE               \"--extcap-interface\"\n#define EXTCAP_ARGUMENT_LIST_DLTS               \"--extcap-dlts\"\n#define EXTCAP_ARGUMENT_VERSION                 \"--extcap-version\"\n\n#define EXTCAP_ARGUMENT_RUN_CAPTURE             \"--capture\"\n#define EXTCAP_ARGUMENT_CAPTURE_FILTER          \"--extcap-capture-filter\"\n#define EXTCAP_ARGUMENT_RUN_PIPE                \"--fifo\"\n#define EXTCAP_ARGUMENT_CONTROL_IN              \"--extcap-control-in\"\n#define EXTCAP_ARGUMENT_CONTROL_OUT             \"--extcap-control-out\"\n\ntypedef struct _extcap_info {\n    char * basename;\n    char * full_path;\n    char * version;\n    char * help;\n\n    GList * interfaces;\n} extcap_info;\n\ntypedef enum {\n    EXTCAP_FILTER_UNKNOWN,\n    EXTCAP_FILTER_VALID,\n    EXTCAP_FILTER_INVALID\n} extcap_filter_status;\n\ntypedef void (*extcap_plugin_description_callback)(const char *, const char *,\n                                                  const char *, const char *,\n                                                  void *);\n\nstruct _extcap_arg;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n/**\n * Registers preferences for all interfaces.\n * Initializes the extcap interface list if that hasn't already been done.\n */\nvoid\nextcap_register_preferences(void);\n\n/**\n * Fetches the interface capabilities for the named extcap interface.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param ifname The interface name.\n * @param err_str Set to NULL on success, error description on failure.\n * @return The interface capabilities on success, NULL on failure.\n */\nif_capabilities_t *\nextcap_get_if_dlts(const char * ifname, char ** err_str);\n\n/**\n * Append a list of all extcap capture interfaces to the specified list.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param list An existing GList of if_info_t.\n * @return An updated list on success, an unchanged list on failure.\n */\nGList *\nappend_extcap_interface_list(GList *list);\n\n/**\n * Retrieves information about an extcap executable.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param toolname The extcap name.\n * @return The extcap information on success, NULL on failure.\n */\nextcap_info *\nextcap_get_tool_info(const char * toolname);\n\n/**\n * Retrieves information about an extcap interface.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param ifname The extcap interface name.\n * @return The extcap information on success, NULL on failure.\n */\nextcap_info *\nextcap_get_tool_by_ifname(const char *ifname);\n\n/**\n * Retrieves help information for an extcap interface.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param ifname The extcap interface name.\n * @return A help string on success or NULL on failure.\n */\nchar *\nextcap_get_help_for_ifname(const char *ifname);\n\n/**\n * Remove all loaded extcap interfaces.\n */\nvoid\nextcap_clear_interfaces(void);\n\n/**\n * Retrieves information about all available extcap executables.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param callback The description callback routine.\n * @param callback_data Data to be passed to the callback routine.\n */\nvoid\nextcap_get_descriptions(extcap_plugin_description_callback callback, void *callback_data);\n\n/**\n * Print information about all available extcap executables.\n * Initializes the extcap interface list if that hasn't already been done.\n */\nvoid\nextcap_dump_all(void);\n\n/**\n * Returns the configuration for the given interface name, or an\n * empty list, if no configuration has been found.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param ifname The interface name.\n */\nGList *\nextcap_get_if_configuration(const char * ifname);\n\n/**\n * Returns the configuration values for the given argument, or an\n * empty list, if no values could been found.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param ifname The interface name.\n * @param argname The name of the argument for which the values should be retrieved.\n */\nGList *\nextcap_get_if_configuration_values(const char * ifname, const char * argname, GHashTable * arguments);\n\n/**\n * Check if the capture filter for the given interface name is valid.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param ifname Interface to check\n * @param filter Capture filter to check\n * @param err_str Error string returned if filter is invalid\n * @return Filter check status.\n */\nextcap_filter_status\nextcap_verify_capture_filter(const char *ifname, const char *filter, char **err_str);\n\n/**\n * Frees the memory from extcap_get_if_configuration.\n * @param list The list returned by extcap_get_if_configuration.\n * @param free_args true if all arguments in the list must be freed too or false\n * if the ownership of the arguments is taken by the caller.\n */\nvoid\nextcap_free_if_configuration(GList *list, bool free_args);\n\n/**\n * Checks to see if an interface has configurable options.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param ifname Interface to check.\n */\nbool\nextcap_has_configuration(const char * ifname);\n\n/**\n * Checks if an interface has configurable options and if all are configured.\n * Returns true when the extcap interface has\n * configurable options that required modification. (For example, when an\n * argument is required but empty.)\n * Initializes the extcap interface list if that hasn't already been done.\n * @param ifname Interface to check.\n */\nbool\nextcap_requires_configuration(const char * ifname);\n\n/**\n * Checks to see if the interface has an associated toolbar.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param ifname Interface to check.\n * @return true if the interface has a toolbar, false otherwise.\n */\nbool\nextcap_has_toolbar(const char *ifname);\n\n#ifdef HAVE_LIBPCAP\n/**\n * Cleanup after capture session.\n * @param cap_session Capture session.\n * @return true if session can be stopped, false if there are remaining tasks.\n */\nbool\nextcap_session_stop(capture_session *cap_session);\n\n/**\n * Initializes each extcap interface with the supplied capture session.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param cap_session Capture session.\n * @return true on success, false on failure.\n */\nbool\nextcap_init_interfaces(capture_session *cap_session);\n#endif /* HAVE_LIBPCAP */\n\n/**\n * Notify all extcaps that capture session should be stopped.\n * Forcefully stop session if extcaps do not finish before timeout.\n * @param cap_session Capture session.\n */\nvoid\nextcap_request_stop(capture_session *cap_session);\n\n/**\n * Fetch an extcap preference for a given argument.\n * Initializes the extcap interface list if that hasn't already been done.\n * @param ifname The interface to check.\n * @param arg The command line argument to check.\n * @return The associated preference on success, NULL on failure.\n */\npref_t *\nextcap_pref_for_argument(const char *ifname, struct _extcap_arg * arg);\n\n/**\n * Clean up global extcap stuff on program exit.\n */\nvoid extcap_cleanup(void);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "extcap",
          "type": "tree",
          "content": null
        },
        {
          "name": "extcap_parser.c",
          "type": "blob",
          "size": 33.4072265625,
          "content": "/* extcap_parser.c\n *\n * Routines for extcap external capture\n * Copyright 2013, Mike Ryan <mikeryan@lacklustre.net>\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN LOG_DOMAIN_EXTCAP\n\n#include <stdio.h>\n#include <glib.h>\n#include <string.h>\n\n#include \"ui/iface_toolbar.h\"\n#include \"wsutil/strtoi.h\"\n\n#include \"extcap.h\"\n#include \"extcap_parser.h\"\n#include \"ws_attributes.h\"\n\nvoid extcap_printf_complex(extcap_complex *comp) {\n    char *ret = extcap_get_complex_as_string(comp);\n    printf(\"%s\", ret);\n    g_free(ret);\n}\n\nchar *extcap_get_complex_as_string(extcap_complex *comp) {\n    return (comp ? g_strdup(comp->_val) : NULL);\n}\n\nextcap_complex *extcap_parse_complex(extcap_arg_type complex_type,\n                                     const char *data) {\n\n    extcap_complex *rc = g_new0(extcap_complex, 1);\n\n    rc->_val = g_strdup(data);\n    rc->complex_type = complex_type;\n\n    return rc;\n}\n\nbool extcap_compare_is_default(extcap_arg *element, extcap_complex *test) {\n    if (element == NULL || element->default_complex == NULL || test == NULL)\n        return false;\n\n    if (g_strcmp0(element->default_complex->_val, test->_val) == 0)\n        return true;\n\n    return false;\n}\n\nvoid extcap_free_complex(extcap_complex *comp) {\n    if (comp)\n        g_free(comp->_val);\n    g_free(comp);\n}\n\nint extcap_complex_get_int(extcap_complex *comp) {\n    if (comp == NULL || comp->_val == NULL || comp->complex_type != EXTCAP_ARG_INTEGER)\n        return (int)0;\n\n    return (int) g_ascii_strtoll(comp->_val, NULL, 10);\n}\n\nunsigned extcap_complex_get_uint(extcap_complex *comp) {\n    if (comp == NULL || comp->_val == NULL || comp->complex_type != EXTCAP_ARG_UNSIGNED)\n        return (unsigned)0;\n    return (unsigned) g_ascii_strtoull(comp->_val, NULL, 10);\n}\n\nint64_t extcap_complex_get_long(extcap_complex *comp) {\n    if (comp == NULL || comp->_val == NULL || comp->complex_type != EXTCAP_ARG_LONG)\n        return (int64_t)0;\n    return g_ascii_strtoll(comp->_val, NULL, 10);\n}\n\ndouble extcap_complex_get_double(extcap_complex *comp) {\n    if (comp == NULL || comp->_val == NULL || comp->complex_type != EXTCAP_ARG_DOUBLE)\n        return (double)0;\n    return g_strtod(comp->_val, NULL);\n}\n\nstatic bool matches_regex(const char *pattern, const char *subject) {\n    if (!g_utf8_validate(subject, -1, NULL))\n        return false;\n    return g_regex_match_simple(pattern, subject, (GRegexCompileFlags) (G_REGEX_CASELESS), (GRegexMatchFlags)0);\n}\n\nbool extcap_complex_get_bool(extcap_complex *comp) {\n    if (comp == NULL || comp->_val == NULL)\n        return false;\n\n    if (comp->complex_type != EXTCAP_ARG_BOOLEAN && comp->complex_type != EXTCAP_ARG_BOOLFLAG)\n        return false;\n\n    return matches_regex(EXTCAP_BOOLEAN_REGEX, comp->_val);\n}\n\nchar *extcap_complex_get_string(extcap_complex *comp) {\n    /* Not checking for argument type, to use this method as fallback if only strings are needed */\n    return comp != NULL ? comp->_val : NULL;\n}\n\nstatic extcap_token_sentence *extcap_tokenize_sentence(const char *s) {\n    GRegex *regex = NULL;\n    GMatchInfo *match_info = NULL;\n    GError *error = NULL;\n    char *param_value = NULL;\n    unsigned param_type = EXTCAP_PARAM_UNKNOWN;\n\n    if (!g_utf8_validate(s, -1, NULL))\n        return NULL;\n\n    extcap_token_sentence *rs = g_new0(extcap_token_sentence, 1);\n\n    rs->sentence = NULL;\n\n    /* Regex for catching just the allowed values for sentences */\n    if ((regex = g_regex_new(\"^[\\\\t| ]*(arg|value|interface|extcap|dlt|control)(?=[\\\\t| ]+\\\\{)\",\n                             (GRegexCompileFlags) (G_REGEX_CASELESS),\n                             (GRegexMatchFlags) 0, NULL)) != NULL) {\n        g_regex_match(regex, s, (GRegexMatchFlags) 0, &match_info);\n\n        if (g_match_info_matches(match_info))\n            rs->sentence = g_match_info_fetch(match_info, 0);\n\n        g_match_info_free(match_info);\n        g_regex_unref(regex);\n    }\n    /* No valid sentence found, exiting here */\n    if (rs->sentence == NULL) {\n        g_free(rs);\n        return NULL;\n    }\n\n    rs->param_list = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);\n\n    /* Capture the argument and the value of the list. This will ensure,\n     * that regex patterns given to {validation=} are parsed correctly,\n     * as long as }{ does not occur within the pattern */\n    regex = g_regex_new(\"\\\\{([a-zA-Z_-]*?)\\\\=(.*?)\\\\}(?=\\\\{|$|\\\\s)\",\n                        (GRegexCompileFlags) (G_REGEX_CASELESS),\n                        (GRegexMatchFlags) 0, NULL);\n    if (regex != NULL) {\n        g_regex_match_full(regex, s, -1, 0, (GRegexMatchFlags) 0, &match_info, &error);\n        while (g_match_info_matches(match_info)) {\n            char *arg = g_match_info_fetch(match_info, 1);\n\n            if (arg == NULL)\n                break;\n\n            param_value = g_match_info_fetch(match_info, 2);\n\n            if (g_ascii_strcasecmp(arg, \"number\") == 0) {\n                param_type = EXTCAP_PARAM_ARGNUM;\n            } else if (g_ascii_strcasecmp(arg, \"call\") == 0) {\n                param_type = EXTCAP_PARAM_CALL;\n            } else if (g_ascii_strcasecmp(arg, \"display\") == 0) {\n                param_type = EXTCAP_PARAM_DISPLAY;\n            } else if (g_ascii_strcasecmp(arg, \"type\") == 0) {\n                param_type = EXTCAP_PARAM_TYPE;\n            } else if (g_ascii_strcasecmp(arg, \"arg\") == 0) {\n                param_type = EXTCAP_PARAM_ARG;\n            } else if (g_ascii_strcasecmp(arg, \"default\") == 0) {\n                param_type = EXTCAP_PARAM_DEFAULT;\n            } else if (g_ascii_strcasecmp(arg, \"value\") == 0) {\n                param_type = EXTCAP_PARAM_VALUE;\n            } else if (g_ascii_strcasecmp(arg, \"range\") == 0) {\n                param_type = EXTCAP_PARAM_RANGE;\n            } else if (g_ascii_strcasecmp(arg, \"tooltip\") == 0) {\n                param_type = EXTCAP_PARAM_TOOLTIP;\n            } else if (g_ascii_strcasecmp(arg, \"placeholder\") == 0) {\n                param_type = EXTCAP_PARAM_PLACEHOLDER;\n            } else if (g_ascii_strcasecmp(arg, \"mustexist\") == 0) {\n                param_type = EXTCAP_PARAM_FILE_MUSTEXIST;\n            } else if (g_ascii_strcasecmp(arg, \"fileext\") == 0) {\n                param_type = EXTCAP_PARAM_FILE_EXTENSION;\n            } else if (g_ascii_strcasecmp(arg, \"group\") == 0) {\n                param_type = EXTCAP_PARAM_GROUP;\n            } else if (g_ascii_strcasecmp(arg, \"name\") == 0) {\n                param_type = EXTCAP_PARAM_NAME;\n            } else if (g_ascii_strcasecmp(arg, \"enabled\") == 0) {\n                param_type = EXTCAP_PARAM_ENABLED;\n            } else if (g_ascii_strcasecmp(arg, \"parent\") == 0) {\n                param_type = EXTCAP_PARAM_PARENT;\n            } else if (g_ascii_strcasecmp(arg, \"reload\") == 0) {\n                param_type = EXTCAP_PARAM_RELOAD;\n            } else if (g_ascii_strcasecmp(arg, \"required\") == 0) {\n                param_type = EXTCAP_PARAM_REQUIRED;\n            } else if (g_ascii_strcasecmp(arg, \"save\") == 0) {\n                param_type = EXTCAP_PARAM_SAVE;\n            } else if (g_ascii_strcasecmp(arg, \"validation\") == 0) {\n                param_type = EXTCAP_PARAM_VALIDATION;\n            } else if (g_ascii_strcasecmp(arg, \"version\") == 0) {\n                param_type = EXTCAP_PARAM_VERSION;\n            } else if (g_ascii_strcasecmp(arg, \"help\") == 0) {\n                param_type = EXTCAP_PARAM_HELP;\n            } else if (g_ascii_strcasecmp(arg, \"control\") == 0) {\n                param_type = EXTCAP_PARAM_CONTROL;\n            } else if (g_ascii_strcasecmp(arg, \"role\") == 0) {\n                param_type = EXTCAP_PARAM_ROLE;\n            } else {\n                param_type = EXTCAP_PARAM_UNKNOWN;\n            }\n\n            g_hash_table_insert(rs->param_list, ENUM_KEY(param_type), param_value);\n\n            g_match_info_next(match_info, &error);\n            g_free(arg);\n        }\n        g_match_info_free(match_info);\n        g_regex_unref(regex);\n    }\n\n    return rs;\n}\n\nstatic GList *extcap_tokenize_sentences(const char *s) {\n\n    GList *sentences = NULL;\n    extcap_token_sentence *item = NULL;\n    char **list, **list_iter;\n\n    list_iter = list = g_strsplit(s, \"\\n\", 0);\n    while (*list_iter != NULL) {\n        item = extcap_tokenize_sentence(*list_iter);\n        if (item)\n            sentences = g_list_append(sentences, item);\n        list_iter++;\n    }\n\n    g_strfreev(list);\n\n    return sentences;\n}\n\nstatic void extcap_free_value(extcap_value *v) {\n    if (v == NULL)\n        return;\n\n    g_free(v->call);\n    g_free(v->display);\n    g_free(v->parent);\n\n    g_free(v);\n}\n\nstatic void extcap_free_valuelist(void *data, void *user_data _U_) {\n    extcap_free_value((extcap_value *) data);\n}\n\nvoid extcap_free_arg(extcap_arg *a) {\n\n    if (a == NULL)\n        return;\n\n    g_free(a->call);\n    g_free(a->display);\n    g_free(a->tooltip);\n    g_free(a->placeholder);\n    g_free(a->fileextension);\n    g_free(a->regexp);\n    g_free(a->group);\n    g_free(a->device_name);\n\n    if (a->range_start != NULL)\n        extcap_free_complex(a->range_start);\n\n    if (a->range_end != NULL)\n        extcap_free_complex(a->range_end);\n\n    if (a->default_complex != NULL)\n        extcap_free_complex(a->default_complex);\n\n    g_list_foreach(a->values, (GFunc) extcap_free_valuelist, NULL);\n    g_list_free(a->values);\n    g_free(a);\n}\n\nstatic void extcap_free_toolbar_value(iface_toolbar_value *value)\n{\n    if (value == NULL)\n    {\n        return;\n    }\n\n    g_free(value->value);\n    g_free(value->display);\n    g_free(value);\n}\n\nvoid extcap_free_toolbar_control(iface_toolbar_control *control)\n{\n    if (control == NULL)\n    {\n        return;\n    }\n\n    g_free(control->display);\n    g_free(control->validation);\n    g_free(control->tooltip);\n    g_free(control->placeholder);\n    if (control->ctrl_type == INTERFACE_TYPE_STRING) {\n        g_free(control->default_value.string);\n    }\n    g_list_free_full(control->values, (GDestroyNotify)extcap_free_toolbar_value);\n    g_free(control);\n}\n\nvoid extcap_free_arg_list(GList *a) {\n    g_list_free_full(a, (GDestroyNotify)extcap_free_arg);\n}\n\nstatic int glist_find_numbered_arg(const void *listelem, const void *needle) {\n    if (((const extcap_arg *) listelem)->arg_num == *((const int *) needle))\n        return 0;\n    return 1;\n}\n\nstatic int glist_find_numbered_control(const void *listelem, const void *needle) {\n    if (((const iface_toolbar_control *) listelem)->num == *((const int *) needle))\n        return 0;\n    return 1;\n}\n\nstatic void extcap_free_tokenized_sentence(void *s, void *user_data _U_) {\n    extcap_token_sentence *t = (extcap_token_sentence *)s;\n\n    if (t == NULL)\n        return;\n\n    g_free(t->sentence);\n    g_hash_table_destroy(t->param_list);\n    g_free(t);\n}\n\nstatic void extcap_free_tokenized_sentences(GList *sentences) {\n    if (sentences == NULL)\n        return;\n\n    g_list_foreach(sentences, extcap_free_tokenized_sentence, NULL);\n    g_list_free(sentences);\n}\n\nstatic extcap_value *extcap_parse_value_sentence(extcap_token_sentence *s) {\n    extcap_value *value = NULL;\n    char *param_value = NULL;\n\n    int tint = 0;\n\n    if (s == NULL)\n        return value;\n\n    if (g_ascii_strcasecmp(s->sentence, \"value\") == 0) {\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_ARG)))\n                == NULL) {\n            printf(\"no arg in VALUE sentence\\n\");\n            return NULL;\n        }\n\n        if (sscanf(param_value, \"%d\", &tint) != 1) {\n            printf(\"invalid arg in VALUE sentence\\n\");\n            return NULL;\n        }\n\n        value = g_new0(extcap_value, 1);\n        value->arg_num = tint;\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_VALUE)))\n                == NULL) {\n            /* printf(\"no value in VALUE sentence\\n\"); */\n            extcap_free_value(value);\n            return NULL;\n        }\n        value->call = g_strdup(param_value);\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_DISPLAY)))\n                == NULL) {\n            /* printf(\"no display in VALUE sentence\\n\"); */\n            extcap_free_value(value);\n            return NULL;\n        }\n        value->display = g_strdup(param_value);\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_PARENT)))\n                != NULL) {\n            value->parent = g_strdup(param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_DEFAULT)))\n                != NULL) {\n            /* printf(\"found default value\\n\"); */\n            value->is_default = matches_regex(EXTCAP_BOOLEAN_REGEX, param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_ENABLED)))\n                != NULL) {\n            value->enabled = matches_regex(EXTCAP_BOOLEAN_REGEX, param_value);\n        }\n    }\n\n    return value;\n}\n\nstatic extcap_arg *extcap_parse_arg_sentence(GList *args, extcap_token_sentence *s) {\n    char *param_value = NULL;\n\n    extcap_arg *target_arg = NULL;\n    extcap_value *value = NULL;\n    GList *entry = NULL;\n\n    extcap_sentence_type sent = EXTCAP_SENTENCE_UNKNOWN;\n\n    if (s == NULL)\n        return target_arg;\n\n    if (g_ascii_strcasecmp(s->sentence, \"arg\") == 0) {\n        sent = EXTCAP_SENTENCE_ARG;\n        /* printf(\"ARG sentence\\n\"); */\n    } else if (g_ascii_strcasecmp(s->sentence, \"value\") == 0) {\n        sent = EXTCAP_SENTENCE_VALUE;\n        /* printf(\"VALUE sentence\\n\"); */\n    }\n\n    if (sent == EXTCAP_SENTENCE_ARG) {\n        target_arg = g_new0(extcap_arg, 1);\n        target_arg->arg_type = EXTCAP_ARG_UNKNOWN;\n        target_arg->save = true;\n\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_ARGNUM))) == NULL) {\n            extcap_free_arg(target_arg);\n            return NULL;\n        }\n\n        if (sscanf(param_value, \"%d\", &(target_arg->arg_num)) != 1) {\n            extcap_free_arg(target_arg);\n            return NULL;\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_CALL))) == NULL) {\n            extcap_free_arg(target_arg);\n            return NULL;\n        }\n        target_arg->call = g_strdup(param_value);\n\n        /* No value only parameters allowed */\n        if (strlen(target_arg->call) == 0) {\n            extcap_free_arg(target_arg);\n            return NULL;\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_DISPLAY))) == NULL) {\n            extcap_free_arg(target_arg);\n            return NULL;\n        }\n        target_arg->display = g_strdup(param_value);\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_TOOLTIP)))\n                != NULL) {\n            target_arg->tooltip = g_strdup(param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_PLACEHOLDER)))\n                != NULL) {\n            target_arg->placeholder = g_strdup(param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_FILE_MUSTEXIST)))\n                != NULL) {\n            target_arg->fileexists = matches_regex(EXTCAP_BOOLEAN_REGEX, param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_FILE_EXTENSION)))\n                != NULL) {\n            target_arg->fileextension = g_strdup(param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_VALIDATION)))\n                != NULL) {\n            target_arg->regexp = g_strdup(param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_GROUP)))\n                != NULL) {\n            target_arg->group = g_strdup(param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_REQUIRED)))\n                != NULL) {\n            target_arg->is_required = matches_regex(EXTCAP_BOOLEAN_REGEX, param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_TYPE)))\n                == NULL) {\n            /* printf(\"no type in ARG sentence\\n\"); */\n            extcap_free_arg(target_arg);\n            return NULL;\n        }\n\n        if (g_ascii_strcasecmp(param_value, \"integer\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_INTEGER;\n        } else if (g_ascii_strcasecmp(param_value, \"unsigned\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_UNSIGNED;\n        } else if (g_ascii_strcasecmp(param_value, \"long\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_LONG;\n        } else if (g_ascii_strcasecmp(param_value, \"double\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_DOUBLE;\n        } else if (g_ascii_strcasecmp(param_value, \"boolean\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_BOOLEAN;\n        } else if (g_ascii_strcasecmp(param_value, \"boolflag\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_BOOLFLAG;\n        } else if (g_ascii_strcasecmp(param_value, \"selector\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_SELECTOR;\n        } else if (g_ascii_strcasecmp(param_value, \"editselector\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_EDIT_SELECTOR;\n        } else if (g_ascii_strcasecmp(param_value, \"radio\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_RADIO;\n        } else if (g_ascii_strcasecmp(param_value, \"string\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_STRING;\n        } else if (g_ascii_strcasecmp(param_value, \"password\") == 0) {\n            /* Password is never saved because is mapped to PREF_PASSWORD later */\n            target_arg->arg_type = EXTCAP_ARG_PASSWORD;\n        } else if (g_ascii_strcasecmp(param_value, \"fileselect\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_FILESELECT;\n        } else if (g_ascii_strcasecmp(param_value, \"multicheck\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_MULTICHECK;\n        } else if (g_ascii_strcasecmp(param_value, \"timestamp\") == 0) {\n            target_arg->arg_type = EXTCAP_ARG_TIMESTAMP;\n        } else {\n            printf(\"invalid type %s in ARG sentence\\n\", param_value);\n            extcap_free_arg(target_arg);\n            return NULL;\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_SAVE)))\n                != NULL) {\n            target_arg->save = matches_regex(EXTCAP_BOOLEAN_REGEX, param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_RELOAD)))\n                != NULL) {\n            target_arg->reload = matches_regex(EXTCAP_BOOLEAN_REGEX, param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_RANGE)))\n                != NULL) {\n            char *cp = g_strstr_len(param_value, -1, \",\");\n\n            if (cp == NULL) {\n                printf(\"invalid range, expected value,value got %s\\n\",\n                       param_value);\n                extcap_free_arg(target_arg);\n                return NULL;\n            }\n\n            if ((target_arg->range_start = extcap_parse_complex(\n                                               target_arg->arg_type, param_value)) == NULL) {\n                printf(\"invalid range, expected value,value got %s\\n\",\n                       param_value);\n                extcap_free_arg(target_arg);\n                return NULL;\n            }\n\n            if ((target_arg->range_end = extcap_parse_complex(\n                                             target_arg->arg_type, cp + 1)) == NULL) {\n                printf(\"invalid range, expected value,value got %s\\n\",\n                       param_value);\n                extcap_free_arg(target_arg);\n                return NULL;\n            }\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_DEFAULT)))\n                != NULL) {\n            if (target_arg->arg_type != EXTCAP_ARG_MULTICHECK && target_arg->arg_type != EXTCAP_ARG_SELECTOR)\n            {\n                if ((target_arg->default_complex = extcap_parse_complex(\n                                                       target_arg->arg_type, param_value)) == NULL) {\n                    printf(\"invalid default, couldn't parse %s\\n\", param_value);\n                }\n            }\n        }\n\n    } else if (sent == EXTCAP_SENTENCE_VALUE) {\n        value = extcap_parse_value_sentence(s);\n        if (value == NULL)\n            return NULL;\n\n        if ((entry = g_list_find_custom(args, &value->arg_num, glist_find_numbered_arg))\n                == NULL) {\n            printf(\"couldn't find arg %d in list for VALUE sentence\\n\", value->arg_num);\n            return NULL;\n        }\n\n        ((extcap_arg *) entry->data)->values = g_list_append(\n                ((extcap_arg *) entry->data)->values, value);\n\n        return NULL;\n    }\n\n    return target_arg;\n}\n\nGList *extcap_parse_args(char *output) {\n    GList *result = NULL;\n    GList *walker = NULL;\n    GList *temp = NULL;\n\n    walker = extcap_tokenize_sentences(output);\n    temp = walker;\n\n    while (walker) {\n        extcap_arg *ra = NULL;\n        extcap_token_sentence *sentence = (extcap_token_sentence *)walker->data;\n\n        if ((ra = extcap_parse_arg_sentence(result, sentence)) != NULL)\n            result = g_list_append(result, (void *) ra);\n\n        walker = g_list_next(walker);\n    }\n\n    extcap_free_tokenized_sentences(temp);\n\n    return result;\n}\n\nGList *extcap_parse_values(char *output) {\n    GList *result = NULL;\n    GList *walker = NULL;\n    GList *temp = NULL;\n\n    walker = extcap_tokenize_sentences(output);\n    temp = walker;\n\n    while (walker) {\n        extcap_value *ra = NULL;\n        extcap_token_sentence *sentence = (extcap_token_sentence *)walker->data;\n\n        if ((ra = extcap_parse_value_sentence(sentence)) != NULL)\n            result = g_list_append(result, (void *) ra);\n\n        walker = g_list_next(walker);\n    }\n\n    extcap_free_tokenized_sentences(temp);\n\n    return result;\n}\n\nstatic extcap_interface *extcap_parse_interface_sentence(extcap_token_sentence *s) {\n    extcap_sentence_type sent = EXTCAP_SENTENCE_UNKNOWN;\n    char *param_value = NULL;\n    extcap_interface *ri = NULL;\n\n    if (s == NULL)\n        return NULL;\n\n    if (g_ascii_strcasecmp(s->sentence, \"interface\") == 0) {\n        sent = EXTCAP_SENTENCE_INTERFACE;\n    } else if (g_ascii_strcasecmp(s->sentence, \"extcap\") == 0) {\n        sent = EXTCAP_SENTENCE_EXTCAP;\n    }\n\n    if (sent == EXTCAP_SENTENCE_UNKNOWN)\n        return NULL;\n\n    ri = g_new0(extcap_interface, 1);\n\n    ri->if_type = sent;\n\n    if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_VALUE)))\n            == NULL && sent == EXTCAP_SENTENCE_INTERFACE) {\n        printf(\"No value in INTERFACE sentence\\n\");\n        g_free(ri);\n        return NULL;\n    }\n    ri->call = g_strdup(param_value);\n\n    if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_DISPLAY)))\n            == NULL && sent == EXTCAP_SENTENCE_INTERFACE) {\n        printf(\"No display in INTERFACE sentence\\n\");\n        g_free(ri->call);\n        g_free(ri);\n        return NULL;\n    }\n    ri->display = g_strdup(param_value);\n\n    if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_VERSION)))\n            != NULL) {\n        ri->version = g_strdup(param_value);\n    }\n\n    if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_HELP)))\n            != NULL) {\n        ri->help = g_strdup(param_value);\n    }\n\n    return ri;\n}\n\nstatic iface_toolbar_control *extcap_parse_control_sentence(GList *control_items, extcap_token_sentence *s)\n{\n    extcap_sentence_type sent = EXTCAP_SENTENCE_UNKNOWN;\n    char *param_value = NULL;\n    iface_toolbar_control *control = NULL;\n    iface_toolbar_value *value = NULL;\n    GList *entry = NULL;\n    uint32_t num = 0;\n\n    if (s == NULL)\n        return NULL;\n\n    if (g_ascii_strcasecmp(s->sentence, \"control\") == 0) {\n        sent = EXTCAP_SENTENCE_CONTROL;\n    } else if (g_ascii_strcasecmp(s->sentence, \"value\") == 0) {\n        sent = EXTCAP_SENTENCE_VALUE;\n    }\n\n    if (sent == EXTCAP_SENTENCE_UNKNOWN)\n        return NULL;\n\n    if (sent == EXTCAP_SENTENCE_CONTROL) {\n        control = g_new0(iface_toolbar_control, 1);\n        control->ctrl_type = INTERFACE_TYPE_UNKNOWN;\n\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_ARGNUM));\n        if (param_value == NULL) {\n            extcap_free_toolbar_control(control);\n            return NULL;\n        }\n\n        if (!ws_strtou32(param_value, NULL, &num)) {\n            extcap_free_toolbar_control(control);\n            return NULL;\n        }\n        control->num = (int)num;\n\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_DISPLAY));\n        if (param_value == NULL) {\n            extcap_free_toolbar_control(control);\n            return NULL;\n        }\n        control->display = g_strdup(param_value);\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_VALIDATION)))\n            != NULL) {\n            control->validation = g_strdup(param_value);\n        }\n\n        if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_REQUIRED)))\n            != NULL) {\n            control->is_required = matches_regex(EXTCAP_BOOLEAN_REGEX, param_value);\n        }\n\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_TOOLTIP));\n        control->tooltip = g_strdup(param_value);\n\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_PLACEHOLDER));\n        control->placeholder = g_strdup(param_value);\n\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_TYPE));\n        if (param_value == NULL) {\n            extcap_free_toolbar_control(control);\n            return NULL;\n        }\n\n        extcap_arg_type arg_type = EXTCAP_ARG_UNKNOWN;\n        if (g_ascii_strcasecmp(param_value, \"boolean\") == 0) {\n            control->ctrl_type = INTERFACE_TYPE_BOOLEAN;\n            arg_type = EXTCAP_ARG_BOOLEAN;\n        } else if (g_ascii_strcasecmp(param_value, \"button\") == 0) {\n            control->ctrl_type = INTERFACE_TYPE_BUTTON;\n        } else if (g_ascii_strcasecmp(param_value, \"selector\") == 0) {\n            control->ctrl_type = INTERFACE_TYPE_SELECTOR;\n        } else if (g_ascii_strcasecmp(param_value, \"string\") == 0) {\n            control->ctrl_type = INTERFACE_TYPE_STRING;\n            arg_type = EXTCAP_ARG_STRING;\n        } else {\n            printf(\"invalid type %s in CONTROL sentence\\n\", param_value);\n            extcap_free_toolbar_control(control);\n            return NULL;\n        }\n\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_ROLE));\n        if (param_value != NULL) {\n            if (g_ascii_strcasecmp(param_value, \"control\") == 0) {\n                control->ctrl_role = INTERFACE_ROLE_CONTROL;\n            } else if (g_ascii_strcasecmp(param_value, \"help\") == 0) {\n                control->ctrl_role = INTERFACE_ROLE_HELP;\n            } else if (g_ascii_strcasecmp(param_value, \"logger\") == 0) {\n                control->ctrl_role = INTERFACE_ROLE_LOGGER;\n            } else if (g_ascii_strcasecmp(param_value, \"restore\") == 0) {\n                control->ctrl_role = INTERFACE_ROLE_RESTORE;\n            } else {\n                printf(\"invalid role %s in CONTROL sentence\\n\", param_value);\n                control->ctrl_role = INTERFACE_ROLE_UNKNOWN;\n            }\n        } else {\n            /* Default role */\n            control->ctrl_role = INTERFACE_ROLE_CONTROL;\n        }\n\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_DEFAULT));\n        if (param_value != NULL) {\n            if (arg_type != EXTCAP_ARG_UNKNOWN) {\n                extcap_complex *complex = extcap_parse_complex(arg_type, param_value);\n                if (complex != NULL) {\n                    if (arg_type == EXTCAP_ARG_BOOLEAN) {\n                        control->default_value.boolean = extcap_complex_get_bool(complex);\n                    } else if (arg_type == EXTCAP_ARG_STRING) {\n                        control->default_value.string = g_strdup(complex->_val);\n                    }\n                    extcap_free_complex(complex);\n                } else {\n                    printf(\"invalid default, couldn't parse %s\\n\", param_value);\n                }\n            }\n        }\n\n    } else if (sent == EXTCAP_SENTENCE_VALUE) {\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_CONTROL));\n        if (param_value == NULL) {\n            printf(\"no control in VALUE sentence\\n\");\n            return NULL;\n        }\n\n        if (!ws_strtou32(param_value, NULL, &num)) {\n            extcap_free_toolbar_control(control);\n            return NULL;\n        }\n\n        entry = g_list_find_custom(control_items, &num, glist_find_numbered_control);\n        if (entry == NULL) {\n            printf(\"couldn't find control %u in list for VALUE sentence\\n\", num);\n            return NULL;\n        }\n\n        value = g_new0(iface_toolbar_value, 1);\n        value->num = (int)num;\n\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_VALUE));\n        if (param_value == NULL) {\n            extcap_free_toolbar_value(value);\n            return NULL;\n        }\n        value->value = g_strdup(param_value);\n\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_DISPLAY));\n        if (param_value == NULL) {\n            extcap_free_toolbar_value(value);\n            return NULL;\n        }\n        value->display = g_strdup(param_value);\n\n        param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_DEFAULT));\n        if (param_value != NULL) {\n            value->is_default = matches_regex(EXTCAP_BOOLEAN_REGEX, param_value);\n        }\n\n        control = (iface_toolbar_control *)entry->data;\n        control->values = g_list_append(control->values, value);\n\n        return NULL;\n    }\n\n    return control;\n}\n\nGList *extcap_parse_interfaces(char *output, GList **control_items) {\n\n    GList *result = NULL;\n    GList *tokens = NULL;\n    GList *walker = extcap_tokenize_sentences(output);\n    tokens = walker;\n\n    while (walker) {\n        extcap_interface *ri = NULL;\n        iface_toolbar_control *ti = NULL;\n        extcap_token_sentence *if_sentence = (extcap_token_sentence *) walker->data;\n\n        if (if_sentence) {\n            if ((g_ascii_strcasecmp(if_sentence->sentence, \"interface\") == 0) ||\n                (g_ascii_strcasecmp(if_sentence->sentence, \"extcap\") == 0))\n            {\n                if ((ri = extcap_parse_interface_sentence(if_sentence))) {\n                    result = g_list_append(result, ri);\n                }\n            } else if (control_items &&\n                       ((g_ascii_strcasecmp(if_sentence->sentence, \"control\") == 0) ||\n                        (g_ascii_strcasecmp(if_sentence->sentence, \"value\") == 0)))\n            {\n                if ((ti = extcap_parse_control_sentence(*control_items, if_sentence))) {\n                    *control_items = g_list_append(*control_items, ti);\n                }\n            }\n        }\n\n        walker = g_list_next(walker);\n    }\n\n    extcap_free_tokenized_sentences(tokens);\n\n    return result;\n}\n\n/* Parse a tokenized set of sentences and validate, looking for DLT definitions */\nstatic extcap_dlt *extcap_parse_dlt_sentence(extcap_token_sentence *s) {\n    char *param_value = NULL;\n    extcap_sentence_type sent = EXTCAP_SENTENCE_UNKNOWN;\n    extcap_dlt *result = NULL;\n\n    if (s == NULL)\n        return result;\n\n    if (g_ascii_strcasecmp(s->sentence, \"dlt\") == 0) {\n        sent = EXTCAP_SENTENCE_DLT;\n    }\n\n    if (sent == EXTCAP_SENTENCE_UNKNOWN)\n        return result;\n\n    result = g_new0(extcap_dlt, 1);\n\n    result->number = -1;\n    result->name = NULL;\n    result->display = NULL;\n\n    if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_ARGNUM)))\n            == NULL) {\n        printf(\"No number in DLT sentence\\n\");\n        g_free(result);\n        return NULL;\n    }\n    if (sscanf(param_value, \"%d\", &(result->number)) != 1) {\n        printf(\"Invalid number in DLT sentence\\n\");\n        g_free(result);\n        return NULL;\n    }\n\n    if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_NAME)))\n            == NULL) {\n        printf(\"No name in DLT sentence\\n\");\n        g_free(result);\n        return NULL;\n    }\n    result->name = g_strdup(param_value);\n\n    if ((param_value = (char *)g_hash_table_lookup(s->param_list, ENUM_KEY(EXTCAP_PARAM_DISPLAY)))\n            == NULL) {\n        printf(\"No display in DLT sentence\\n\");\n        g_free(result->name);\n        g_free(result);\n        return NULL;\n    }\n    result->display = g_strdup(param_value);\n\n    return result;\n}\n\nGList *extcap_parse_dlts(char *output) {\n\n    GList *walker = NULL;\n    GList *temp = NULL;\n    GList *result = NULL;\n\n    walker = extcap_tokenize_sentences(output);\n\n    temp = walker;\n\n    while (walker) {\n        extcap_dlt *data = NULL;\n\n        if ((data = extcap_parse_dlt_sentence((extcap_token_sentence *)walker->data)) != NULL)\n            result = g_list_append(result, data);\n\n        walker = g_list_next(walker);\n    }\n\n    extcap_free_tokenized_sentences(temp);\n\n    return result;\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "extcap_parser.h",
          "type": "blob",
          "size": 5.08984375,
          "content": "/** @file\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#ifndef __EXTCAP_PARSER_H__\n#define __EXTCAP_PARSER_H__\n\n#include <stdio.h>\n#include <glib.h>\n#include <string.h>\n\n#include \"ui/iface_toolbar.h\"\n\ntypedef enum {\n    EXTCAP_SENTENCE_UNKNOWN,\n    EXTCAP_SENTENCE_ARG,\n    EXTCAP_SENTENCE_VALUE,\n    EXTCAP_SENTENCE_EXTCAP,\n    EXTCAP_SENTENCE_INTERFACE,\n    EXTCAP_SENTENCE_DLT,\n    EXTCAP_SENTENCE_CONTROL\n} extcap_sentence_type;\n\ntypedef enum {\n    /* Simple types */\n    EXTCAP_ARG_UNKNOWN,\n    EXTCAP_ARG_INTEGER,\n    EXTCAP_ARG_UNSIGNED,\n    EXTCAP_ARG_LONG,\n    EXTCAP_ARG_DOUBLE,\n    EXTCAP_ARG_BOOLEAN,\n    EXTCAP_ARG_BOOLFLAG,\n    EXTCAP_ARG_STRING,\n    EXTCAP_ARG_PASSWORD,\n    /* Complex GUI types which are populated with value sentences */\n    EXTCAP_ARG_SELECTOR,\n    EXTCAP_ARG_EDIT_SELECTOR,\n    EXTCAP_ARG_RADIO,\n    EXTCAP_ARG_MULTICHECK,\n    EXTCAP_ARG_FILESELECT,\n    EXTCAP_ARG_TIMESTAMP\n} extcap_arg_type;\n\ntypedef enum {\n    /* value types */\n    EXTCAP_PARAM_UNKNOWN,\n    EXTCAP_PARAM_ARGNUM,\n    EXTCAP_PARAM_CALL,\n    EXTCAP_PARAM_DISPLAY,\n    EXTCAP_PARAM_TYPE,\n    EXTCAP_PARAM_ARG,\n    EXTCAP_PARAM_DEFAULT,\n    EXTCAP_PARAM_VALUE,\n    EXTCAP_PARAM_RANGE,\n    EXTCAP_PARAM_TOOLTIP,\n    EXTCAP_PARAM_PLACEHOLDER,\n    EXTCAP_PARAM_NAME,\n    EXTCAP_PARAM_ENABLED,\n    EXTCAP_PARAM_FILE_MUSTEXIST,\n    EXTCAP_PARAM_FILE_EXTENSION,\n    EXTCAP_PARAM_GROUP,\n    EXTCAP_PARAM_PARENT,\n    EXTCAP_PARAM_REQUIRED,\n    EXTCAP_PARAM_RELOAD,\n    EXTCAP_PARAM_SAVE,\n    EXTCAP_PARAM_VALIDATION,\n    EXTCAP_PARAM_VERSION,\n    EXTCAP_PARAM_HELP,\n    EXTCAP_PARAM_CONTROL,\n    EXTCAP_PARAM_ROLE\n} extcap_param_type;\n\n#define ENUM_KEY(s) GUINT_TO_POINTER((unsigned)s)\n\n/* Values for a given sentence; values are all stored as a call\n * and a value string, or a valid range, so we only need to store\n * those and repeat them */\ntypedef struct _extcap_value {\n    int arg_num;\n\n    char *call;\n    char *display;\n    bool enabled;\n    bool is_default;\n    char *parent;\n} extcap_value;\n\n/* Complex-ish struct for storing complex values */\ntypedef struct _extcap_complex {\n    extcap_arg_type complex_type;\n    char * _val;\n} extcap_complex;\n\n/* An argument sentence and accompanying options */\ntypedef struct _extcap_arg {\n    int arg_num;\n\n    char *call;\n    char *display;\n    char *tooltip;\n    char *placeholder;\n\n    char * fileextension;\n    bool fileexists;\n\n    bool is_required;\n    bool save;\n\n    bool reload;\n\n    char * regexp;\n\n    char * group;\n\n    extcap_arg_type arg_type;\n\n    extcap_complex *range_start;\n    extcap_complex *range_end;\n    extcap_complex *default_complex;\n\n    char ** pref_valptr; /**< A copy of the pointer containing the current preference value. */\n    char * device_name;\n\n    GList * values;\n} extcap_arg;\n\ntypedef struct _extcap_interface {\n    char * call;\n    char * display;\n    char * version;\n    char * help;\n    char * extcap_path;\n\n    extcap_sentence_type if_type;\n} extcap_interface;\n\ntypedef struct _extcap_dlt {\n    int number;\n    char *name;\n    char *display;\n} extcap_dlt;\n\ntypedef struct _extcap_token_sentence {\n    char *sentence;\n\n    GHashTable *param_list;\n} extcap_token_sentence;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Parse a string into a complex type */\nextcap_complex *extcap_parse_complex(extcap_arg_type complex_type,\n        const char *data);\n\n/* Free a complex */\nvoid extcap_free_complex(extcap_complex *comp);\n\n/* Print a complex value out for debug */\nvoid extcap_printf_complex(extcap_complex *comp);\n\n/*\n * Return a string representation of a complex type\n * Caller is responsible for calling g_free on the returned string\n */\nchar *extcap_get_complex_as_string(extcap_complex *comp);\n\nint extcap_complex_get_int(extcap_complex *comp);\nunsigned extcap_complex_get_uint(extcap_complex *comp);\nint64_t extcap_complex_get_long(extcap_complex *comp);\ndouble extcap_complex_get_double(extcap_complex *comp);\nbool extcap_complex_get_bool(extcap_complex *comp);\nchar *extcap_complex_get_string(extcap_complex *comp);\n\n/* compares the default value of an element with a given parameter */\nbool extcap_compare_is_default(extcap_arg *element, extcap_complex *test);\n\n\n/* Free a single argument */\nvoid extcap_free_arg(extcap_arg *a);\n\n/* Free entire toolbar control structure */\nvoid extcap_free_toolbar_control(iface_toolbar_control *control);\n\n/* Free an entire arg list */\nvoid extcap_free_arg_list(GList *a);\n\n\n/** Parser for extcap data */\n\n/* Parse all sentences for args and values */\nGList * extcap_parse_args(char *output);\n\n/* Parse all sentences for values */\nGList * extcap_parse_values(char *output);\n\n/* Parse all sentences for interfaces */\nGList * extcap_parse_interfaces(char *output, GList **control_items);\n\n/* Parse all sentences for DLTs */\nGList * extcap_parse_dlts(char *output);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "file.c",
          "type": "blob",
          "size": 206.8525390625,
          "content": "/* file.c\n * File I/O routines\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN LOG_DOMAIN_CAPTURE\n\n#include <time.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n\n#include <wsutil/file_util.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/json_dumper.h>\n#include <wsutil/wslog.h>\n#include <wsutil/ws_assert.h>\n#include <wsutil/version_info.h>\n#include <wsutil/report_message.h>\n\n#include <wiretap/merge.h>\n\n#include <epan/exceptions.h>\n#include <epan/epan.h>\n#include <epan/column.h>\n#include <epan/packet.h>\n#include <epan/column-utils.h>\n#include <epan/expert.h>\n#include <epan/prefs.h>\n#include <epan/dfilter/dfilter.h>\n#include <epan/epan_dissect.h>\n#include <epan/tap.h>\n#include <epan/timestamp.h>\n#include <epan/strutil.h>\n#include <epan/addr_resolv.h>\n#include <epan/color_filters.h>\n#include <epan/secrets.h>\n\n#include \"cfile.h\"\n#include \"file.h\"\n#include \"fileset.h\"\n\n#include \"ui/simple_dialog.h\"\n#include \"ui/main_statusbar.h\"\n#include \"ui/progress_dlg.h\"\n#include \"ui/urls.h\"\n#include \"ui/ws_ui_util.h\"\n#include \"ui/packet_list_utils.h\"\n\n/* Needed for addrinfo */\n#include <sys/types.h>\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\n#ifdef HAVE_NETINET_IN_H\n# include <netinet/in.h>\n#endif\n\n#ifdef _WIN32\n# include <winsock2.h>\n# include <ws2tcpip.h>\n#endif\n\nstatic bool read_record(capture_file *cf, wtap_rec *rec, dfilter_t *dfcode,\n    epan_dissect_t *edt, column_info *cinfo, int64_t offset,\n    fifo_string_cache_t *frame_dup_cache, GChecksum *frame_cksum);\n\nstatic void rescan_packets(capture_file *cf, const char *action, const char *action_item, bool redissect);\n\ntypedef enum {\n    MR_NOTMATCHED,\n    MR_MATCHED,\n    MR_ERROR\n} match_result;\ntypedef match_result (*ws_match_function)(capture_file *, frame_data *,\n        wtap_rec *, void *);\nstatic match_result match_protocol_tree(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic void match_subtree_text(proto_node *node, void *data);\nstatic void match_subtree_text_reverse(proto_node *node, void *data);\nstatic match_result match_summary_line(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_narrow_and_wide(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_narrow_and_wide_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_narrow_and_wide_case(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_narrow_and_wide_case_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_narrow_case(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_narrow_case_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_wide(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_wide_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_wide_case(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_wide_case_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_binary(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_binary_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_regex(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_regex_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_dfilter(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_marked(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic match_result match_time_reference(capture_file *cf, frame_data *fdata,\n        wtap_rec *, void *criterion);\nstatic bool find_packet(capture_file *cf, ws_match_function match_function,\n        void *criterion, search_direction dir, bool start_current);\n\n/* Seconds spent processing packets between pushing UI updates. */\n#define PROGBAR_UPDATE_INTERVAL 0.150\n\n/* Show the progress bar after this many seconds. */\n#define PROGBAR_SHOW_DELAY 0.5\n\n/*\n * Maximum number of records we support in a file.\n *\n * It is, at most, the maximum value of a uint32_t, as we use a uint32_t\n * for the frame number.\n *\n * We allow it to be set to a lower value; see issue #16908 for why\n * we're doing this.  Thanks, Qt!\n */\nstatic uint32_t max_records = UINT32_MAX;\n\nvoid\ncf_set_max_records(unsigned max_records_arg)\n{\n    max_records = max_records_arg;\n}\n\n/*\n * We could probably use g_signal_...() instead of the callbacks below but that\n * would require linking our CLI programs to libgobject and creating an object\n * instance for the signals.\n */\ntypedef struct {\n    cf_callback_t cb_fct;\n    void *        user_data;\n} cf_callback_data_t;\n\nstatic GList *cf_callbacks;\n\nstatic void\ncf_callback_invoke(int event, void *data)\n{\n    cf_callback_data_t *cb;\n    GList              *cb_item = cf_callbacks;\n\n    /* there should be at least one interested */\n    ws_assert(cb_item != NULL);\n\n    while (cb_item != NULL) {\n        cb = (cf_callback_data_t *)cb_item->data;\n        cb->cb_fct(event, data, cb->user_data);\n        cb_item = g_list_next(cb_item);\n    }\n}\n\nvoid\ncf_callback_add(cf_callback_t func, void *user_data)\n{\n    cf_callback_data_t *cb;\n\n    cb = g_new(cf_callback_data_t,1);\n    cb->cb_fct = func;\n    cb->user_data = user_data;\n\n    cf_callbacks = g_list_prepend(cf_callbacks, cb);\n}\n\nvoid\ncf_callback_remove(cf_callback_t func, void *user_data)\n{\n    cf_callback_data_t *cb;\n    GList              *cb_item = cf_callbacks;\n\n    while (cb_item != NULL) {\n        cb = (cf_callback_data_t *)cb_item->data;\n        if (cb->cb_fct == func && cb->user_data == user_data) {\n            cf_callbacks = g_list_remove(cf_callbacks, cb);\n            g_free(cb);\n            return;\n        }\n        cb_item = g_list_next(cb_item);\n    }\n\n    ws_assert_not_reached();\n}\n\nunsigned long\ncf_get_computed_elapsed(capture_file *cf)\n{\n    return cf->computed_elapsed;\n}\n\nstatic void\ncompute_elapsed(capture_file *cf, int64_t start_time)\n{\n    int64_t delta_time = g_get_monotonic_time() - start_time;\n\n    cf->computed_elapsed = (unsigned long) (delta_time / 1000); /* ms */\n}\n\nstatic epan_t *\nws_epan_new(capture_file *cf)\n{\n    static const struct packet_provider_funcs funcs = {\n        cap_file_provider_get_frame_ts,\n        cap_file_provider_get_interface_name,\n        cap_file_provider_get_interface_description,\n        cap_file_provider_get_modified_block\n    };\n\n    return epan_new(&cf->provider, &funcs);\n}\n\ncf_status_t\ncf_open(capture_file *cf, const char *fname, unsigned int type, bool is_tempfile, int *err)\n{\n    wtap  *wth;\n    char *err_info;\n\n    wth = wtap_open_offline(fname, type, err, &err_info, true);\n    if (wth == NULL)\n        goto fail;\n\n    /* The open succeeded.  Close whatever capture file we had open,\n       and fill in the information for this file. */\n    cf_close(cf);\n\n    /* Initialize the record information.\n       XXX - we really want to initialize this after we've read all\n       the packets, so we know how much we'll ultimately need. */\n    wtap_rec_init(&cf->rec, 1514);\n\n    /* We're about to start reading the file. */\n    cf->state = FILE_READ_IN_PROGRESS;\n\n    /* If there was a pending redissection for the old file (there\n     * shouldn't be), clear it. cf_close() should have failed if the\n     * old file's read lock was held, but it doesn't hurt to clear it. */\n    cf->read_lock = false;\n    cf->redissection_queued = RESCAN_NONE;\n\n    cf->provider.wth = wth;\n    cf->f_datalen = 0;\n\n    /* Set the file name because we need it to set the follow stream filter.\n       XXX - is that still true?  We need it for other reasons, though,\n       in any case. */\n    cf->filename = g_strdup(fname);\n\n    /* Indicate whether it's a permanent or temporary file. */\n    cf->is_tempfile = is_tempfile;\n\n    /* No user changes yet. */\n    cf->unsaved_changes = false;\n\n    cf->computed_elapsed = 0;\n\n    /* Record the file's type and compression type. */\n    cf->cd_t        = wtap_file_type_subtype(cf->provider.wth);\n    cf->compression_type = wtap_get_compression_type(cf->provider.wth);\n\n    cf->open_type   = type;\n    cf->linktypes = g_array_sized_new(FALSE, FALSE, (unsigned) sizeof(int), 1);\n    cf->count     = 0;\n    cf->packet_comment_count = 0;\n    cf->displayed_count = 0;\n    cf->marked_count = 0;\n    cf->ignored_count = 0;\n    cf->ref_time_count = 0;\n    cf->drops_known = false;\n    cf->drops     = 0;\n    cf->snap      = wtap_snapshot_length(cf->provider.wth);\n\n    /* Allocate a frame_data_sequence for the frames in this file */\n    cf->provider.frames = new_frame_data_sequence();\n\n    nstime_set_zero(&cf->elapsed_time);\n    cf->provider.ref = NULL;\n    cf->provider.prev_dis = NULL;\n    cf->provider.prev_cap = NULL;\n    cf->cum_bytes = 0;\n\n    /* Create new epan session for dissection.\n     * (The old one was freed in cf_close().)\n     */\n    cf->epan = ws_epan_new(cf);\n\n    packet_list_queue_draw();\n    cf_callback_invoke(cf_cb_file_opened, cf);\n\n    wtap_set_cb_new_ipv4(cf->provider.wth, add_ipv4_name);\n    wtap_set_cb_new_ipv6(cf->provider.wth, (wtap_new_ipv6_callback_t) add_ipv6_name);\n    wtap_set_cb_new_secrets(cf->provider.wth, secrets_wtap_callback);\n\n    return CF_OK;\n\nfail:\n    report_cfile_open_failure(fname, *err, err_info);\n    return CF_ERROR;\n}\n\n/*\n * Add an encapsulation type to cf->linktypes.\n */\nstatic void\ncf_add_encapsulation_type(capture_file *cf, int encap)\n{\n    unsigned i;\n\n    for (i = 0; i < cf->linktypes->len; i++) {\n        if (g_array_index(cf->linktypes, int, i) == encap)\n            return; /* it's already there */\n    }\n    /* It's not already there - add it. */\n    g_array_append_val(cf->linktypes, encap);\n}\n\n/* Reset everything to a pristine state */\nvoid\ncf_close(capture_file *cf)\n{\n    cf->stop_flag = false;\n    if (cf->state == FILE_CLOSED || cf->state == FILE_READ_PENDING)\n        return; /* Nothing to do */\n\n    /* Die if we're in the middle of reading a file. */\n    ws_assert(cf->state != FILE_READ_IN_PROGRESS);\n    ws_assert(!cf->read_lock);\n\n    cf_callback_invoke(cf_cb_file_closing, cf);\n\n    /* close things, if not already closed before */\n    color_filters_cleanup();\n\n    if (cf->provider.wth) {\n        wtap_close(cf->provider.wth);\n        cf->provider.wth = NULL;\n    }\n    /* We have no file open... */\n    if (cf->filename != NULL) {\n        /* If it's a temporary file, remove it. */\n        if (cf->is_tempfile)\n            ws_unlink(cf->filename);\n        g_free(cf->filename);\n        cf->filename = NULL;\n    }\n    /* ...which means we have no changes to that file to save. */\n    cf->unsaved_changes = false;\n\n    /* no open_routine type */\n    cf->open_type = WTAP_TYPE_AUTO;\n\n    /* Clean up the record information. */\n    wtap_rec_cleanup(&cf->rec);\n\n    /* Clear the packet list. */\n    packet_list_freeze();\n    packet_list_clear();\n    packet_list_thaw();\n\n    dfilter_free(cf->rfcode);\n    cf->rfcode = NULL;\n    if (cf->provider.frames != NULL) {\n        free_frame_data_sequence(cf->provider.frames);\n        cf->provider.frames = NULL;\n    }\n    if (cf->provider.frames_modified_blocks) {\n        g_tree_destroy(cf->provider.frames_modified_blocks);\n        cf->provider.frames_modified_blocks = NULL;\n    }\n    cf_unselect_packet(cf);   /* nothing to select */\n    cf->first_displayed = 0;\n    cf->last_displayed = 0;\n\n    /* No frames, no frame selected, no field in that frame selected. */\n    cf->count = 0;\n    cf->current_frame = NULL;\n    cf->finfo_selected = NULL;\n\n    /* No frame link-layer types, either. */\n    if (cf->linktypes != NULL) {\n        g_array_free(cf->linktypes, TRUE);\n        cf->linktypes = NULL;\n    }\n\n    cf->f_datalen = 0;\n    nstime_set_zero(&cf->elapsed_time);\n\n    reset_tap_listeners();\n\n    epan_free(cf->epan);\n    cf->epan = NULL;\n\n    /* We have no file open. */\n    cf->state = FILE_CLOSED;\n\n    cf_callback_invoke(cf_cb_file_closed, cf);\n}\n\n/*\n * true if the progress dialog doesn't exist and it looks like we'll\n * take > PROGBAR_SHOW_DELAY (500ms) to load, false otherwise.\n */\nstatic inline bool\nprogress_is_slow(progdlg_t *progdlg, GTimer *prog_timer, int64_t size, int64_t pos)\n{\n    double elapsed;\n\n    if (progdlg) return false;\n    elapsed = g_timer_elapsed(prog_timer, NULL);\n    /* This only gets checked between reading records, which doesn't help if\n     * a single record takes a very long time, e.g., the first TLS packet if\n     * the SSLKEYLOGFILE is very large. (#17051) */\n    if ((elapsed * 2 > PROGBAR_SHOW_DELAY && (size / pos) >= 2) /* It looks like we're going to be slow. */\n            || elapsed > PROGBAR_SHOW_DELAY) { /* We are indeed slow. */\n        return true;\n    }\n    return false;\n}\n\nstatic float\ncalc_progbar_val(capture_file *cf, int64_t size, int64_t file_pos, char *status_str, unsigned long status_size)\n{\n    float progbar_val;\n\n    progbar_val = (float) file_pos / (float) size;\n    if (progbar_val > 1.0) {\n\n        /*  The file probably grew while we were reading it.\n         *  Update file size, and try again.\n         */\n        size = wtap_file_size(cf->provider.wth, NULL);\n\n        if (size >= 0)\n            progbar_val = (float) file_pos / (float) size;\n\n        /*  If it's still > 1, either \"wtap_file_size()\" failed (in which\n         *  case there's not much we can do about it), or the file\n         *  *shrank* (in which case there's not much we can do about\n         *  it); just clip the progress value at 1.0.\n         */\n        if (progbar_val > 1.0f)\n            progbar_val = 1.0f;\n    }\n\n    snprintf(status_str, status_size,\n            \"%\" PRId64 \"KB of %\" PRId64 \"KB\",\n            file_pos / 1024, size / 1024);\n\n    return progbar_val;\n}\n\ncf_read_status_t\ncf_read(capture_file *cf, bool reloading)\n{\n    int                  err = 0;\n    char                *err_info = NULL;\n    volatile bool        too_many_records = false;\n    char                *name_ptr;\n    progdlg_t           *volatile progbar = NULL;\n    GTimer              *prog_timer = g_timer_new();\n    int64_t              size;\n    int64_t              start_time;\n    epan_dissect_t       edt;\n    wtap_rec             rec;\n    dfilter_t           *dfcode = NULL;\n    column_info         *cinfo;\n    volatile bool        create_proto_tree;\n    unsigned             tap_flags;\n    bool                 compiled _U_;\n    volatile bool        is_read_aborted = false;\n\n    /* The update_progress_dlg call below might end up accepting a user request to\n     * trigger redissection/rescans which can modify/destroy the dissection\n     * context (\"cf->epan\"). That condition should be prevented by callers, but in\n     * case it occurs let's fail gracefully.\n     */\n    if (cf->read_lock) {\n        ws_warning(\"Failing due to recursive cf_read(\\\"%s\\\", %d) call!\",\n                cf->filename, reloading);\n        return CF_READ_ERROR;\n    }\n    /* This is a full dissection, so clear any pending request for one. */\n    cf->redissection_queued = RESCAN_NONE;\n    cf->read_lock = true;\n\n    /* Compile the current display filter.\n     * The code it compiles to might have changed, e.g. if a display\n     * filter macro used has changed.\n     *\n     * We assume this will not fail since cf->dfilter is only set in\n     * cf_filter IFF the filter was valid.\n     * XXX - This is not necessarily true, if the filter has a FT_IPv4\n     * or FT_IPv6 field compared to a resolved hostname in it, because\n     * we do a new host lookup, and that *could* timeout this time\n     * (though with the read lock above we shouldn't have many lookups at\n     * once, reducing the chances of that)... (#19612)\n     */\n    if (cf->dfilter) {\n        compiled = dfilter_compile(cf->dfilter, &dfcode, NULL);\n        ws_assert(compiled && dfcode);\n    }\n\n    dfilter_free(cf->dfcode);\n    cf->dfcode = dfcode;\n\n    /* The compiled dfilter might have a field reference; recompiling it\n     * means that the field references won't match anything. That's what\n     * we want since this is a new sequential read and we don't have\n     * a selected frame with a tree. (Will taps with filters with display\n     * references also have cleared display references?)\n     */\n\n    /* Get the union of the flags for all tap listeners. */\n    tap_flags = union_of_tap_listener_flags();\n\n    /*\n     * Determine whether we need to create a protocol tree.\n     * We do if:\n     *\n     *    we're going to apply a display filter;\n     *\n     *    one of the tap listeners is going to apply a filter;\n     *\n     *    one of the tap listeners requires a protocol tree;\n     *\n     *    a postdissector wants field values or protocols on\n     *    the first pass.\n     */\n    create_proto_tree =\n        (cf->dfcode != NULL || have_filtering_tap_listeners() ||\n         (tap_flags & TL_REQUIRES_PROTO_TREE) || postdissectors_want_hfids());\n\n    reset_tap_listeners();\n\n    name_ptr = g_filename_display_basename(cf->filename);\n\n    if (reloading)\n        cf_callback_invoke(cf_cb_file_reload_started, cf);\n    else\n        cf_callback_invoke(cf_cb_file_read_started, cf);\n\n    /* The packet list window will be empty until the file is completely loaded */\n    packet_list_freeze();\n\n    cf->stop_flag = false;\n    start_time = g_get_monotonic_time();\n\n    epan_dissect_init(&edt, cf->epan, create_proto_tree, false);\n\n    /* If the display filter or any tap listeners require the columns,\n     * construct them. */\n    cinfo = (tap_listeners_require_columns() ||\n        dfilter_requires_columns(cf->dfcode)) ? &cf->cinfo : NULL;\n\n    /* Find the size of the file. */\n    size = wtap_file_size(cf->provider.wth, NULL);\n\n    /* If we are to ignore duplicate frames, we need a container to store\n     * hashes frame contents */\n    fifo_string_cache_t frame_dup_cache;\n    GChecksum *volatile cksum = NULL;\n\n    if (prefs.ignore_dup_frames) {\n        fifo_string_cache_init(&frame_dup_cache, prefs.ignore_dup_frames_cache_entries, g_free);\n        cksum = g_checksum_new(G_CHECKSUM_SHA256);\n    }\n\n    g_timer_start(prog_timer);\n\n    wtap_rec_init(&rec, 1514);\n\n    TRY {\n        int64_t file_pos;\n        int64_t data_offset;\n\n        float   progbar_val;\n        char    status_str[100];\n\n        while ((wtap_read(cf->provider.wth, &rec, &err, &err_info,\n                        &data_offset))) {\n            if (size >= 0) {\n                if (cf->count == max_records) {\n                    /*\n                     * Quit if we've already read the maximum number of\n                     * records allowed.\n                     */\n                    too_many_records = true;\n                    break;\n                }\n                file_pos = wtap_read_so_far(cf->provider.wth);\n\n                /* Create the progress bar if necessary. */\n                if (progress_is_slow(progbar, prog_timer, size, file_pos)) {\n                    progbar_val = calc_progbar_val(cf, size, file_pos, status_str, sizeof(status_str));\n                    progbar = delayed_create_progress_dlg(cf->window, NULL, NULL, true,\n                            &cf->stop_flag, progbar_val);\n                }\n\n                /*\n                 * Update the progress bar, but do it only after\n                 * PROGBAR_UPDATE_INTERVAL has elapsed. Calling update_progress_dlg\n                 * and packets_bar_update will likely trigger UI paint events, which\n                 * might take a while depending on the platform and display. Reset\n                 * our timer *after* painting.\n                 */\n                if (progbar && g_timer_elapsed(prog_timer, NULL) > PROGBAR_UPDATE_INTERVAL) {\n                    progbar_val = calc_progbar_val(cf, size, file_pos, status_str, sizeof(status_str));\n                    /* update the packet bar content on the first run or frequently on very large files */\n                    update_progress_dlg(progbar, progbar_val, status_str);\n                    compute_elapsed(cf, start_time);\n                    packets_bar_update();\n                    g_timer_start(prog_timer);\n                }\n                /*\n                 * The previous GUI triggers should not have destroyed the running\n                 * session. If that did happen, it could blow up when read_record tries\n                 * to use the destroyed edt.session, so detect it right here.\n                 */\n                ws_assert(edt.session == cf->epan);\n            }\n\n            if (cf->state == FILE_READ_ABORTED) {\n                /* Well, the user decided to exit Wireshark.  Break out of the\n                   loop, and let the code below (which is called even if there\n                   aren't any packets left to read) exit. */\n                is_read_aborted = true;\n                break;\n            }\n            if (cf->stop_flag) {\n                /* Well, the user decided to abort the read. He/She will be warned and\n                   it might be enough for him/her to work with the already loaded\n                   packets.\n                   This is especially true for very large capture files, where you don't\n                   want to wait loading the whole file (which may last minutes or even\n                   hours even on fast machines) just to see that it was the wrong file. */\n                break;\n            }\n            read_record(cf, &rec, cf->dfcode, &edt, cinfo, data_offset, &frame_dup_cache, cksum);\n            wtap_rec_reset(&rec);\n        }\n    }\n    CATCH(OutOfMemoryError) {\n        simple_message_box(ESD_TYPE_ERROR, NULL,\n                \"More information and workarounds can be found at\\n\"\n                WS_WIKI_URL(\"KnownBugs/OutOfMemory\"),\n                \"Sorry, but Wireshark has run out of memory and has to terminate now.\");\n#if 0\n        /* Could we close the current capture and free up memory from that? */\n#else\n        /* we have to terminate, as we cannot recover from the memory error */\n        exit(1);\n#endif\n    }\n    ENDTRY;\n\n    // If we're ignoring duplicate frames, clear the data structures.\n    // We really could look at prefs.ignore_dup_frames here, but it's even\n    // safer to check if we had allocated 'cksum'.\n    if (cksum != NULL) {\n        fifo_string_cache_free(&frame_dup_cache);\n        g_checksum_free(cksum);\n    }\n\n    /* We're done reading sequentially through the file. */\n    cf->state = FILE_READ_DONE;\n\n    /* Destroy the progress bar if it was created. */\n    if (progbar != NULL)\n        destroy_progress_dlg(progbar);\n    g_timer_destroy(prog_timer);\n\n    /* Free the display name */\n    g_free(name_ptr);\n\n    epan_dissect_cleanup(&edt);\n    wtap_rec_cleanup(&rec);\n\n    /* Close the sequential I/O side, to free up memory it requires. */\n    wtap_sequential_close(cf->provider.wth);\n\n    /* Allow the protocol dissectors to free up memory that they\n     * don't need after the sequential run-through of the packets. */\n    postseq_cleanup_all_protocols();\n\n    /* compute the time it took to load the file */\n    compute_elapsed(cf, start_time);\n\n    /* Set the file encapsulation type now; we don't know what it is until\n       we've looked at all the packets, as we don't know until then whether\n       there's more than one type (and thus whether it's\n       WTAP_ENCAP_PER_PACKET). */\n    cf->lnk_t = wtap_file_encap(cf->provider.wth);\n\n    cf->current_frame = frame_data_sequence_find(cf->provider.frames, cf->first_displayed);\n\n    packet_list_thaw();\n\n    /* It is safe again to execute redissections or sort. */\n    ws_assert(cf->read_lock);\n    cf->read_lock = false;\n\n    if (reloading)\n        cf_callback_invoke(cf_cb_file_reload_finished, cf);\n    else\n        cf_callback_invoke(cf_cb_file_read_finished, cf);\n\n    /* If we have any displayed packets to select, select the first of those\n       packets by making the first row the selected row. */\n    if (cf->first_displayed != 0) {\n        packet_list_select_row_from_data(NULL);\n    }\n\n    if (is_read_aborted) {\n        /*\n         * Well, the user decided to exit Wireshark while reading this *offline*\n         * capture file (Live captures are handled by something like\n         * cf_continue_tail). Clean up accordingly.\n         */\n        cf_close(cf);\n        cf->redissection_queued = RESCAN_NONE;\n        return CF_READ_ABORTED;\n    }\n\n    if (cf->redissection_queued != RESCAN_NONE) {\n        /* Redissection was queued up. Clear the request and perform it now. */\n        bool redissect = cf->redissection_queued == RESCAN_REDISSECT;\n        rescan_packets(cf, NULL, NULL, redissect);\n    }\n\n    if (cf->stop_flag) {\n        simple_message_box(ESD_TYPE_WARN, NULL,\n                \"The remaining packets in the file were discarded.\\n\"\n                \"\\n\"\n                \"As a lot of packets from the original file will be missing,\\n\"\n                \"remember to be careful when saving the current content to a file.\\n\",\n                \"File loading was cancelled.\");\n        return CF_READ_ERROR;\n    }\n\n    if (err != 0) {\n        /* Put up a message box noting that the read failed somewhere along\n           the line.  Don't throw out the stuff we managed to read, though,\n           if any. */\n        report_cfile_read_failure(NULL, err, err_info);\n        return CF_READ_ERROR;\n    } else if (too_many_records) {\n        simple_message_box(ESD_TYPE_WARN, NULL,\n                \"The remaining packets in the file were discarded.\\n\"\n                \"\\n\"\n                \"As a lot of packets from the original file will be missing,\\n\"\n                \"remember to be careful when saving the current content to a file.\\n\"\n                \"\\n\"\n                \"The command-line utility editcap can be used to split \"\n                \"the file into multiple smaller files\",\n                \"The file contains more records than the maximum \"\n                \"supported number of records, %u.\", max_records);\n        return CF_READ_ERROR;\n    } else\n        return CF_READ_OK;\n}\n\n#ifdef HAVE_LIBPCAP\ncf_read_status_t\ncf_continue_tail(capture_file *cf, volatile int to_read, wtap_rec *rec,\n        int *err, fifo_string_cache_t *frame_dup_cache, GChecksum *frame_cksum)\n{\n    char             *err_info;\n    volatile int      newly_displayed_packets = 0;\n    epan_dissect_t    edt;\n    bool              create_proto_tree;\n    unsigned          tap_flags;\n\n    /* Don't compile the current display filter. The current display filter\n     * text might compile to different code than when the capture started:\n     *\n     *    If it has a IP address resolved name, calling get_host_ipaddr every\n     *    time new packets arrive can mean a *lot* of gethostbyname calls\n     *    in flight at once, eventually leading to a timeout (#19612).\n     *    addr_resolv.c says that ares_gethostbyname is \"usually interactive\",\n     *    unlike ares_gethostbyaddr (used in dissection), and violating that\n     *    expectation is bad.\n     *\n     *    If it has a display filter macro, the definition might have changed.\n     *\n     *    If it has a field reference, the selected frame / current proto tree\n     *    might have changed, and we don't have the old one. If we recompile,\n     *    we can't set the field references to the old values.\n     *\n     * For a rescan, redissection, reload, retap, or opening a new file, we\n     * want to compile. What about here, when new frames have arrived in a live\n     * capture? We might be able to cache the host lookup, and a user might want\n     * the new display filter macro definition, but the user almost surely wants\n     * the field references to refer to values from the proto tree when the\n     * filter was applied, not whatever it happens to be now if the user has\n     * clicked on a different packet.\n     *\n     * To get the new compiled filter, the user should refilter.\n     */\n\n    /* Get the union of the flags for all tap listeners. */\n    tap_flags = union_of_tap_listener_flags();\n\n    /*\n     * Determine whether we need to create a protocol tree.\n     * We do if:\n     *\n     *    we're going to apply a display filter;\n     *\n     *    one of the tap listeners is going to apply a filter;\n     *\n     *    one of the tap listeners requires a protocol tree;\n     *\n     *    a postdissector wants field values or protocols on\n     *    the first pass.\n     */\n    create_proto_tree =\n        (cf->dfcode != NULL || have_filtering_tap_listeners() ||\n         (tap_flags & TL_REQUIRES_PROTO_TREE) || postdissectors_want_hfids());\n\n    *err = 0;\n\n    /* Don't freeze/thaw the list when doing live capture */\n    /*packet_list_freeze();*/\n\n    epan_dissect_init(&edt, cf->epan, create_proto_tree, false);\n\n    TRY {\n        int64_t data_offset = 0;\n        column_info *cinfo;\n\n        /* If the display filter or any tap listeners require the columns,\n         * construct them. */\n        cinfo = (tap_listeners_require_columns() ||\n            dfilter_requires_columns(cf->dfcode)) ? &cf->cinfo : NULL;\n\n        while (to_read != 0) {\n            wtap_cleareof(cf->provider.wth);\n            if (!wtap_read(cf->provider.wth, rec, err, &err_info,\n                        &data_offset)) {\n                break;\n            }\n            if (cf->state == FILE_READ_ABORTED) {\n                /* Well, the user decided to exit Wireshark.  Break out of the\n                   loop, and let the code below (which is called even if there\n                   aren't any packets left to read) exit. */\n                break;\n            }\n            if (read_record(cf, rec, cf->dfcode, &edt, cinfo, data_offset, frame_dup_cache, frame_cksum)) {\n                newly_displayed_packets++;\n            }\n            to_read--;\n        }\n        wtap_rec_reset(rec);\n    }\n    CATCH(OutOfMemoryError) {\n        simple_message_box(ESD_TYPE_ERROR, NULL,\n                \"More information and workarounds can be found at\\n\"\n                WS_WIKI_URL(\"KnownBugs/OutOfMemory\"),\n                \"Sorry, but Wireshark has run out of memory and has to terminate now.\");\n#if 0\n        /* Could we close the current capture and free up memory from that? */\n        return CF_READ_ABORTED;\n#else\n        /* we have to terminate, as we cannot recover from the memory error */\n        exit(1);\n#endif\n    }\n    ENDTRY;\n\n    /* Update the file encapsulation; it might have changed based on the\n       packets we've read. */\n    cf->lnk_t = wtap_file_encap(cf->provider.wth);\n\n    epan_dissect_cleanup(&edt);\n\n    /* Don't freeze/thaw the list when doing live capture */\n    /*packet_list_thaw();*/\n    /* With the new packet list the first packet\n     * isn't automatically selected.\n     */\n    if (!cf->current_frame && !packet_list_multi_select_active())\n        packet_list_select_row_from_data(NULL);\n\n    if (cf->state == FILE_READ_ABORTED) {\n        /* Well, the user decided to exit Wireshark.  Return CF_READ_ABORTED\n           so that our caller can kill off the capture child process;\n           this will cause an EOF on the pipe from the child, so\n           \"cf_finish_tail()\" will be called, and it will clean up\n           and exit. */\n        return CF_READ_ABORTED;\n    } else if (*err != 0) {\n        /* We got an error reading the capture file.\n           XXX - pop up a dialog box instead? */\n        if (err_info != NULL) {\n            ws_warning(\"Error \\\"%s\\\" while reading \\\"%s\\\" (\\\"%s\\\")\",\n                    wtap_strerror(*err), cf->filename, err_info);\n            g_free(err_info);\n        } else {\n            ws_warning(\"Error \\\"%s\\\" while reading \\\"%s\\\"\",\n                    wtap_strerror(*err), cf->filename);\n        }\n        return CF_READ_ERROR;\n    } else\n        return CF_READ_OK;\n}\n\nvoid\ncf_fake_continue_tail(capture_file *cf)\n{\n    if (cf->state == FILE_CLOSED) {\n        cf->state = FILE_READ_PENDING;\n    }\n}\n\ncf_read_status_t\ncf_finish_tail(capture_file *cf, wtap_rec *rec, int *err,\n        fifo_string_cache_t *frame_dup_cache, GChecksum *frame_cksum)\n{\n    char      *err_info;\n    int64_t    data_offset;\n    column_info *cinfo;\n    epan_dissect_t edt;\n    bool       create_proto_tree;\n    unsigned   tap_flags;\n\n    /* All the comments above in cf_continue_tail apply regarding the\n     * current display filter.\n     */\n\n    /* Get the union of the flags for all tap listeners. */\n    tap_flags = union_of_tap_listener_flags();\n\n    /* If the display filter or any tap listeners require the columns,\n     * construct them. */\n    cinfo = (tap_listeners_require_columns() ||\n        dfilter_requires_columns(cf->dfcode)) ? &cf->cinfo : NULL;\n\n    /*\n     * Determine whether we need to create a protocol tree.\n     * We do if:\n     *\n     *    we're going to apply a display filter;\n     *\n     *    one of the tap listeners is going to apply a filter;\n     *\n     *    one of the tap listeners requires a protocol tree;\n     *\n     *    a postdissector wants field values or protocols on\n     *    the first pass.\n     */\n    create_proto_tree =\n        (cf->dfcode != NULL || have_filtering_tap_listeners() ||\n         (tap_flags & TL_REQUIRES_PROTO_TREE) || postdissectors_want_hfids());\n\n    if (cf->provider.wth == NULL) {\n        cf_close(cf);\n        return CF_READ_ERROR;\n    }\n\n    /* Don't freeze/thaw the list when doing live capture */\n    /*packet_list_freeze();*/\n\n    epan_dissect_init(&edt, cf->epan, create_proto_tree, false);\n\n    while ((wtap_read(cf->provider.wth, rec, err, &err_info, &data_offset))) {\n        if (cf->state == FILE_READ_ABORTED) {\n            /* Well, the user decided to abort the read.  Break out of the\n               loop, and let the code below (which is called even if there\n               aren't any packets left to read) exit. */\n            break;\n        }\n        read_record(cf, rec, cf->dfcode, &edt, cinfo, data_offset, frame_dup_cache, frame_cksum);\n        wtap_rec_reset(rec);\n    }\n\n    epan_dissect_cleanup(&edt);\n\n    /* Don't freeze/thaw the list when doing live capture */\n    /*packet_list_thaw();*/\n\n    if (cf->state == FILE_READ_ABORTED) {\n        /* Well, the user decided to abort the read.  We're only called\n           when the child capture process closes the pipe to us (meaning\n           it's probably exited), so we can just close the capture\n           file; we return CF_READ_ABORTED so our caller can do whatever\n           is appropriate when that happens. */\n        cf_close(cf);\n        return CF_READ_ABORTED;\n    }\n\n    /* We're done reading sequentially through the file. */\n    cf->state = FILE_READ_DONE;\n\n    /* We're done reading sequentially through the file; close the\n       sequential I/O side, to free up memory it requires. */\n    wtap_sequential_close(cf->provider.wth);\n\n    /* Allow the protocol dissectors to free up memory that they\n     * don't need after the sequential run-through of the packets. */\n    postseq_cleanup_all_protocols();\n\n    /* Update the file encapsulation; it might have changed based on the\n       packets we've read. */\n    cf->lnk_t = wtap_file_encap(cf->provider.wth);\n\n    /* Update the details in the file-set dialog, as the capture file\n     * has likely grown since we first stat-ed it */\n    fileset_update_file(cf->filename);\n\n    if (*err != 0) {\n        /* We got an error reading the capture file.\n           XXX - pop up a dialog box? */\n        if (err_info != NULL) {\n            ws_warning(\"Error \\\"%s\\\" while reading \\\"%s\\\" (\\\"%s\\\")\",\n                    wtap_strerror(*err), cf->filename, err_info);\n            g_free(err_info);\n        } else {\n            ws_warning(\"Error \\\"%s\\\" while reading \\\"%s\\\"\",\n                    wtap_strerror(*err), cf->filename);\n        }\n        return CF_READ_ERROR;\n    } else {\n        return CF_READ_OK;\n    }\n}\n#endif /* HAVE_LIBPCAP */\n\nchar *\ncf_get_display_name(capture_file *cf)\n{\n    char *displayname;\n\n    /* Return a name to use in displays */\n    if (!cf->is_tempfile) {\n        /* Get the last component of the file name, and use that. */\n        if (cf->filename) {\n            displayname = g_filename_display_basename(cf->filename);\n        } else {\n            displayname=g_strdup(\"(No file)\");\n        }\n    } else {\n        /* The file we read is a temporary file from a live capture or\n           a merge operation; we don't mention its name, but, if it's\n           from a capture, give the source of the capture. */\n        if (cf->source) {\n            displayname = g_strdup(cf->source);\n        } else {\n            displayname = g_strdup(\"(Untitled)\");\n        }\n    }\n    return displayname;\n}\n\nchar *\ncf_get_basename(capture_file *cf)\n{\n    char *displayname;\n\n    /* Return a name to use in the GUI for the basename for files to\n       which we save statistics */\n    if (!cf->is_tempfile) {\n        /* Get the last component of the file name, and use that. */\n        if (cf->filename) {\n            displayname = g_filename_display_basename(cf->filename);\n\n            /* If the file name ends with any extension that corresponds\n               to a file type we support - including compressed versions\n               of those files - strip it off. */\n            size_t displayname_len = strlen(displayname);\n            GSList *extensions = wtap_get_all_file_extensions_list();\n            GSList *suffix;\n            for (suffix = extensions; suffix != NULL; suffix = g_slist_next(suffix)) {\n                /* Does the file name end with that extension? */\n                const char *extension = (char *)suffix->data;\n                size_t extension_len = strlen(extension);\n                if (displayname_len > extension_len &&\n                        displayname[displayname_len - extension_len - 1] == '.' &&\n                        strcmp(&displayname[displayname_len - extension_len], extension) == 0) {\n                    /* Yes.  Strip the extension off, and return the result. */\n                    displayname[displayname_len - extension_len - 1] = '\\0';\n                    break;\n                }\n            }\n            wtap_free_extensions_list(extensions);\n        } else {\n            displayname=g_strdup(\"\");\n        }\n    } else {\n        /* The file we read is a temporary file from a live capture or\n           a merge operation; we don't mention its name, but, if it's\n           from a capture, give the source of the capture. */\n        if (cf->source) {\n            displayname = g_strdup(cf->source);\n        } else {\n            displayname = g_strdup(\"\");\n        }\n    }\n    return displayname;\n}\n\nvoid\ncf_set_tempfile_source(capture_file *cf, char *source)\n{\n    if (cf->source) {\n        g_free(cf->source);\n    }\n\n    if (source) {\n        cf->source = g_strdup(source);\n    } else {\n        cf->source = g_strdup(\"\");\n    }\n}\n\nconst char *\ncf_get_tempfile_source(capture_file *cf)\n{\n    if (!cf->source) {\n        return \"\";\n    }\n\n    return cf->source;\n}\n\n/* XXX - use a macro instead? */\nint\ncf_get_packet_count(capture_file *cf)\n{\n    return cf->count;\n}\n\n/* XXX - use a macro instead? */\nbool\ncf_is_tempfile(capture_file *cf)\n{\n    return cf->is_tempfile;\n}\n\nvoid\ncf_set_tempfile(capture_file *cf, bool is_tempfile)\n{\n    cf->is_tempfile = is_tempfile;\n}\n\n\n/* XXX - use a macro instead? */\nvoid\ncf_set_drops_known(capture_file *cf, bool drops_known)\n{\n    cf->drops_known = drops_known;\n}\n\n/* XXX - use a macro instead? */\nvoid\ncf_set_drops(capture_file *cf, uint32_t drops)\n{\n    cf->drops = drops;\n}\n\n/* XXX - use a macro instead? */\nbool\ncf_get_drops_known(capture_file *cf)\n{\n    return cf->drops_known;\n}\n\n/* XXX - use a macro instead? */\nuint32_t\ncf_get_drops(capture_file *cf)\n{\n    return cf->drops;\n}\n\nvoid\ncf_set_rfcode(capture_file *cf, dfilter_t *rfcode)\n{\n    cf->rfcode = rfcode;\n}\n\nstatic void\nadd_packet_to_packet_list(frame_data *fdata, capture_file *cf,\n        epan_dissect_t *edt, dfilter_t *dfcode, column_info *cinfo,\n        wtap_rec *rec, bool add_to_packet_list)\n{\n    frame_data_set_before_dissect(fdata, &cf->elapsed_time,\n            &cf->provider.ref, cf->provider.prev_dis);\n    cf->provider.prev_cap = fdata;\n\n    if (dfcode != NULL) {\n        epan_dissect_prime_with_dfilter(edt, dfcode);\n    }\n#if 0\n    /* Prepare coloring rules, this ensures that display filter rules containing\n     * frame.color_rule references are still processed.\n     * TODO: actually detect that situation or maybe apply other optimizations? */\n    if (edt->tree && color_filters_used()) {\n        color_filters_prime_edt(edt);\n        fdata->need_colorize = 1;\n    }\n#endif\n\n    if (!fdata->visited) {\n        /* This is the first pass, so prime the epan_dissect_t with the\n           hfids postdissectors want on the first pass. */\n        prime_epan_dissect_with_postdissector_wanted_hfids(edt);\n    }\n\n    /* Initialize passed_dfilter here so that dissectors can hide packets. */\n    /* XXX We might want to add a separate \"visible\" bit to frame_data instead. */\n    fdata->passed_dfilter = 1;\n\n    /* Dissect the frame. */\n    epan_dissect_run_with_taps(edt, cf->cd_t, rec, fdata, cinfo);\n\n    if (fdata->passed_dfilter && dfcode != NULL) {\n        fdata->passed_dfilter = dfilter_apply_edt(dfcode, edt) ? 1 : 0;\n\n        if (fdata->passed_dfilter && edt->pi.fd->dependent_frames) {\n            /* This frame passed the display filter but it may depend on other\n             * (potentially not displayed) frames.  Find those frames and mark them\n             * as depended upon.\n             */\n            g_hash_table_foreach(edt->pi.fd->dependent_frames, find_and_mark_frame_depended_upon, cf->provider.frames);\n        }\n    }\n\n    if (fdata->passed_dfilter || fdata->ref_time) {\n        cf->displayed_count++;\n        fdata->dis_num = cf->displayed_count;\n    }\n\n    if (add_to_packet_list) {\n        /* We fill the needed columns from new_packet_list */\n        packet_list_append(cinfo, fdata);\n    }\n\n    if (fdata->passed_dfilter || fdata->ref_time)\n    {\n        frame_data_set_after_dissect(fdata, &cf->cum_bytes);\n        /* The only way we use prev_dis is to get the time stamp of\n         * the previous displayed frame, so ignore it if it doesn't\n         * have a time stamp, because we're presumably interested in\n         * the timestamp of the previously displayed frame with a\n         * time. XXX: What if in the future we want to use the previously\n         * displayed frame for something else, too?\n         */\n        if (fdata->has_ts) {\n            cf->provider.prev_dis = fdata;\n        }\n\n        /* If we haven't yet seen the first frame, this is it. */\n        if (cf->first_displayed == 0)\n            cf->first_displayed = fdata->num;\n\n        /* This is the last frame we've seen so far. */\n        cf->last_displayed = fdata->num;\n    }\n\n    epan_dissect_reset(edt);\n}\n\n/*\n * Read in a new record.\n * Returns true if the packet was added to the packet (record) list,\n * false otherwise.\n */\nstatic bool\nread_record(capture_file *cf, wtap_rec *rec, dfilter_t *dfcode,\n        epan_dissect_t *edt, column_info *cinfo, int64_t offset,\n        fifo_string_cache_t *frame_dup_cache, GChecksum *frame_cksum)\n{\n    frame_data    fdlocal;\n    frame_data   *fdata;\n    bool          passed = true;\n    bool          added = false;\n    const char    *cksum_string;\n    bool          was_in_cache;\n\n    /* Add this packet's link-layer encapsulation type to cf->linktypes, if\n       it's not already there.\n       XXX - yes, this is O(N), so if every packet had a different\n       link-layer encapsulation type, it'd be O(N^2) to read the file, but\n       there are probably going to be a small number of encapsulation types\n       in a file. */\n    if (rec->rec_type == REC_TYPE_PACKET) {\n        cf_add_encapsulation_type(cf, rec->rec_header.packet_header.pkt_encap);\n    }\n\n    /* The frame number of this packet, if we add it to the set of frames,\n       would be one more than the count of frames in the file so far. */\n    frame_data_init(&fdlocal, cf->count + 1, rec, offset, cf->cum_bytes);\n\n    if (cf->rfcode) {\n        epan_dissect_t rf_edt;\n        column_info *rf_cinfo = NULL;\n\n        epan_dissect_init(&rf_edt, cf->epan, true, false);\n        epan_dissect_prime_with_dfilter(&rf_edt, cf->rfcode);\n        if (dfilter_requires_columns(cf->rfcode)) {\n                rf_cinfo = &cf->cinfo;\n        }\n        epan_dissect_run(&rf_edt, cf->cd_t, rec, &fdlocal, rf_cinfo);\n        passed = dfilter_apply_edt(cf->rfcode, &rf_edt);\n        epan_dissect_cleanup(&rf_edt);\n    }\n\n    if (passed) {\n        added = true;\n\n        /* This does a shallow copy of fdlocal, which is good enough. */\n        fdata = frame_data_sequence_add(cf->provider.frames, &fdlocal);\n\n        cf->count++;\n        if (rec->block != NULL)\n            cf->packet_comment_count += wtap_block_count_option(rec->block, OPT_COMMENT);\n         cf->f_datalen = offset + fdlocal.cap_len;\n\n        // Should we check if the frame data is a duplicate, and thus, ignore\n        // this frame?\n        if (frame_cksum != NULL && rec->rec_type == REC_TYPE_PACKET) {\n            g_checksum_reset(frame_cksum);\n            g_checksum_update(frame_cksum, ws_buffer_start_ptr(&rec->data), ws_buffer_length(&rec->data));\n            cksum_string = g_strdup(g_checksum_get_string(frame_cksum));\n            was_in_cache = fifo_string_cache_insert(frame_dup_cache, cksum_string);\n            if (was_in_cache) {\n                g_free((void *)cksum_string);\n                fdata->ignored = true;\n                cf->ignored_count++;\n            }\n        }\n\n        /* When a redissection is in progress (or queued), do not process packets.\n         * This will be done once all (new) packets have been scanned. */\n        if (!cf->redissecting && cf->redissection_queued == RESCAN_NONE) {\n            add_packet_to_packet_list(fdata, cf, edt, dfcode, cinfo, rec, true);\n        }\n    }\n\n    return added;\n}\n\n\ntypedef struct _callback_data_t {\n    void *           pd_window;\n    int64_t          f_len;\n    progdlg_t       *progbar;\n    GTimer          *prog_timer;\n    bool             stop_flag;\n} callback_data_t;\n\n\nstatic bool\nmerge_callback(merge_event event, int num _U_,\n        const merge_in_file_t in_files[], const unsigned in_file_count,\n        void *data)\n{\n    unsigned i;\n    callback_data_t *cb_data = (callback_data_t*) data;\n\n    ws_assert(cb_data != NULL);\n\n    switch (event) {\n\n        case MERGE_EVENT_INPUT_FILES_OPENED:\n            /* do nothing */\n            break;\n\n        case MERGE_EVENT_FRAME_TYPE_SELECTED:\n            /* do nothing */\n            break;\n\n        case MERGE_EVENT_READY_TO_MERGE:\n            /* Get the sum of the sizes of all the files. */\n            for (i = 0; i < in_file_count; i++)\n                cb_data->f_len += in_files[i].size;\n\n            cb_data->prog_timer = g_timer_new();\n            g_timer_start(cb_data->prog_timer);\n            break;\n\n        case MERGE_EVENT_RECORD_WAS_READ:\n            {\n                /* Create the progress bar if necessary.\n                   We check on every iteration of the loop, so that it takes no\n                   longer than the standard time to create it (otherwise, for a\n                   large file, we might take considerably longer than that standard\n                   time in order to get to the next progress bar step). */\n                if (cb_data->progbar == NULL) {\n                    cb_data->progbar = delayed_create_progress_dlg(cb_data->pd_window, NULL, NULL,\n                            false, &cb_data->stop_flag, 0.0f);\n                }\n\n                /*\n                 * Update the progress bar, but do it only after\n                 * PROGBAR_UPDATE_INTERVAL has elapsed. Calling update_progress_dlg\n                 * and packets_bar_update will likely trigger UI paint events, which\n                 * might take a while depending on the platform and display. Reset\n                 * our timer *after* painting.\n                 */\n                if (g_timer_elapsed(cb_data->prog_timer, NULL) > PROGBAR_UPDATE_INTERVAL) {\n                    float  progbar_val;\n                    int64_t file_pos = 0;\n                    /* Get the sum of the seek positions in all of the files. */\n                    for (i = 0; i < in_file_count; i++)\n                        file_pos += wtap_read_so_far(in_files[i].wth);\n\n                    progbar_val = (float) file_pos / (float) cb_data->f_len;\n                    if (progbar_val > 1.0f) {\n                        /* Some file probably grew while we were reading it.\n                           That \"shouldn't happen\", so we'll just clip the progress\n                           value at 1.0. */\n                        progbar_val = 1.0f;\n                    }\n\n                    if (cb_data->progbar != NULL) {\n                        char status_str[100];\n                        snprintf(status_str, sizeof(status_str),\n                                \"%\" PRId64 \"KB of %\" PRId64 \"KB\",\n                                file_pos / 1024, cb_data->f_len / 1024);\n                        update_progress_dlg(cb_data->progbar, progbar_val, status_str);\n                    }\n                    g_timer_start(cb_data->prog_timer);\n                }\n            }\n            break;\n\n        case MERGE_EVENT_DONE:\n            /* We're done merging the files; destroy the progress bar if it was created. */\n            if (cb_data->progbar != NULL)\n                destroy_progress_dlg(cb_data->progbar);\n            g_timer_destroy(cb_data->prog_timer);\n            break;\n    }\n\n    return cb_data->stop_flag;\n}\n\n\n\ncf_status_t\ncf_merge_files_to_tempfile(void *pd_window, const char *temp_dir, char **out_filenamep,\n        int in_file_count, const char *const *in_filenames,\n        int file_type, bool do_append)\n{\n    bool                       status;\n    merge_progress_callback_t  cb;\n    callback_data_t           *cb_data = g_new0(callback_data_t, 1);\n\n    /* prepare our callback routine */\n    cb_data->pd_window = pd_window;\n    cb.callback_func = merge_callback;\n    cb.data = cb_data;\n\n    cf_callback_invoke(cf_cb_file_merge_started, NULL);\n\n    /* merge the files */\n    status = merge_files_to_tempfile(temp_dir, out_filenamep, \"wireshark\", file_type,\n            in_filenames,\n            in_file_count, do_append,\n            IDB_MERGE_MODE_ALL_SAME, 0 /* snaplen */,\n            \"Wireshark\", &cb);\n\n    g_free(cb.data);\n\n    cf_callback_invoke(cf_cb_file_merge_finished, NULL);\n\n    if (!status) {\n        /* Callers aren't expected to treat an error or an explicit abort\n           differently - the merge code puts up error dialogs itself, so\n           they don't have to. */\n        return CF_ERROR;\n    } else\n        return CF_OK;\n}\n\ncf_status_t\ncf_filter_packets(capture_file *cf, char *dftext, bool force)\n{\n    const char *filter_new = dftext ? dftext : \"\";\n    const char *filter_old = cf->dfilter ? cf->dfilter : \"\";\n    dfilter_t  *dfcode;\n    df_error_t *df_err;\n\n    /* if new filter equals old one, do nothing unless told to do so */\n    /* XXX - The text can be the same without compiling to the same code.\n     * (Macros, field references, etc.)\n     */\n    if (!force && strcmp(filter_new, filter_old) == 0) {\n        return CF_OK;\n    }\n\n    dfcode=NULL;\n\n    if (dftext == NULL) {\n        /* The new filter is an empty filter (i.e., display all packets).\n         * so leave dfcode==NULL\n         */\n    } else {\n        /*\n         * We have a filter; make a copy of it (as we'll be saving it),\n         * and try to compile it.\n         */\n        dftext = g_strdup(dftext);\n        if (!dfilter_compile(dftext, &dfcode, &df_err)) {\n            /* The attempt failed; report an error. */\n            simple_message_box(ESD_TYPE_ERROR, NULL,\n                    \"See the help for a description of the display filter syntax.\",\n                    \"\\\"%s\\\" isn't a valid display filter: %s\",\n                    dftext, df_err->msg);\n            df_error_free(&df_err);\n            g_free(dftext);\n            return CF_ERROR;\n        }\n\n        /* Was it empty? */\n        if (dfcode == NULL) {\n            /* Yes - free the filter text, and set it to null. */\n            g_free(dftext);\n            dftext = NULL;\n        }\n    }\n\n    /* We have a valid filter.  Replace the current filter. */\n    g_free(cf->dfilter);\n    cf->dfilter = dftext;\n\n    /* We'll recompile this when the rescan starts, or in cf_read()\n     * if no file is open currently. However, if no file is open and\n     * we start a new capture, we want to use this rather than\n     * recompiling in cf_continue_tail() */\n    dfilter_free(cf->dfcode);\n    cf->dfcode = dfcode;\n\n    /* Now rescan the packet list, applying the new filter, but not\n     * throwing away information constructed on a previous pass.\n     * If a dissection is already in progress, queue it.\n     */\n    if (cf->redissection_queued == RESCAN_NONE) {\n        if (cf->read_lock) {\n            cf->redissection_queued = RESCAN_SCAN;\n        } else if (cf->state != FILE_CLOSED) {\n            if (dftext == NULL) {\n                rescan_packets(cf, \"Resetting\", \"filter\", false);\n            } else {\n                rescan_packets(cf, \"Filtering\", dftext, false);\n            }\n        }\n    }\n\n    return CF_OK;\n}\n\nvoid\ncf_redissect_packets(capture_file *cf)\n{\n    if (cf->read_lock || cf->redissection_queued == RESCAN_SCAN) {\n        /* Dissection in progress, signal redissection rather than rescanning. That\n         * would destroy the current (in-progress) dissection in \"cf_read\" which\n         * will cause issues when \"cf_read\" tries to add packets to the list.\n         * If a previous rescan was requested, \"upgrade\" it to a full redissection.\n         */\n        cf->redissection_queued = RESCAN_REDISSECT;\n    }\n    if (cf->redissection_queued != RESCAN_NONE) {\n        /* Redissection is (already) queued, wait for \"cf_read\" to finish. */\n        /* XXX - what if whatever set and later clears read_lock is *not*\n         * cf_read, e.g. process_specified_records ? We need to handle a\n         * queued redissection there too like we do in cf_read.\n         */\n        return;\n    }\n\n    if (cf->state != FILE_CLOSED) {\n        /* Restart dissection in case no cf_read is pending. */\n        rescan_packets(cf, \"Reprocessing\", \"all packets\", true);\n    }\n}\n\nbool\ncf_read_record(capture_file *cf, const frame_data *fdata, wtap_rec *rec)\n{\n    int    err;\n    char *err_info;\n\n    if (!wtap_seek_read(cf->provider.wth, fdata->file_off, rec, &err, &err_info)) {\n        report_cfile_read_failure(cf->filename, err, err_info);\n        return false;\n    }\n    return true;\n}\n\nbool\ncf_read_record_no_alert(capture_file *cf, const frame_data *fdata,\n        wtap_rec *rec)\n{\n    int    err;\n    char *err_info;\n\n    if (!wtap_seek_read(cf->provider.wth, fdata->file_off, rec, &err, &err_info)) {\n        g_free(err_info);\n        return false;\n    }\n    return true;\n}\n\nbool\ncf_read_current_record(capture_file *cf)\n{\n    return cf_read_record(cf, cf->current_frame, &cf->rec);\n}\n\n/* Rescan the list of packets, reconstructing the CList.\n\n   \"action\" describes why we're doing this; it's used in the progress\n   dialog box.\n\n   \"action_item\" describes what we're doing; it's used in the progress\n   dialog box.\n\n   \"redissect\" is true if we need to make the dissectors reconstruct\n   any state information they have (because a preference that affects\n   some dissector has changed, meaning some dissector might construct\n   its state differently from the way it was constructed the last time). */\nstatic void\nrescan_packets(capture_file *cf, const char *action, const char *action_item, bool redissect)\n{\n    /* Rescan packets new packet list */\n    uint32_t    framenum;\n    frame_data *fdata;\n    wtap_rec    rec;\n    progdlg_t  *progbar = NULL;\n    GTimer     *prog_timer = g_timer_new();\n    int         count;\n    frame_data *selected_frame, *preceding_frame, *following_frame, *prev_frame;\n    int         selected_frame_num, preceding_frame_num, following_frame_num, prev_frame_num;\n    bool        selected_frame_seen;\n    float       progbar_val;\n    int64_t     start_time;\n    char        status_str[100];\n    epan_dissect_t  edt;\n    dfilter_t  *dfcode = NULL;\n    column_info *cinfo;\n    bool        create_proto_tree;\n    bool        filtering_tap_listeners = false;\n    unsigned    tap_flags;\n    bool        add_to_packet_list = false;\n    bool        compiled _U_;\n    uint32_t    frames_count;\n    rescan_type queued_rescan_type = RESCAN_NONE;\n\n    if (cf->state == FILE_CLOSED || cf->state == FILE_READ_PENDING) {\n        return;\n    }\n\n    /* Rescan in progress, clear pending actions. */\n    cf->redissection_queued = RESCAN_NONE;\n    ws_assert(!cf->read_lock);\n    cf->read_lock = true;\n\n    wtap_rec_init(&rec, 1514);\n\n    /* Compile the current display filter.\n     * The code it compiles to might have changed, e.g. if a display\n     * filter macro used has changed.\n     *\n     * We assume this will not fail since cf->dfilter is only set in\n     * cf_filter IFF the filter was valid.\n     * XXX - This is not necessarily true, if the filter has a FT_IPv4\n     * or FT_IPv6 field compared to a resolved hostname in it, because\n     * we do a new host lookup, and that *could* timeout this time\n     * (though with the read lock above we shouldn't have many lookups at\n     * once, reducing the chances of that)... (#19612)\n     */\n    if (cf->dfilter) {\n        compiled = dfilter_compile(cf->dfilter, &dfcode, NULL);\n        ws_assert(compiled && dfcode);\n    }\n\n    dfilter_free(cf->dfcode);\n    cf->dfcode = dfcode;\n\n    /* Do we have any tap listeners with filters? */\n    filtering_tap_listeners = have_filtering_tap_listeners();\n\n    /* Update references in filters (if any) for the protocol\n     * tree corresponding to the currently selected frame in the GUI. */\n    if (cf->edt != NULL && cf->edt->tree != NULL) {\n        if (cf->dfcode)\n            dfilter_load_field_references(cf->dfcode, cf->edt->tree);\n        if (filtering_tap_listeners)\n            tap_listeners_load_field_references(cf->edt);\n    }\n\n    if (cf->dfcode != NULL) {\n        dfilter_log_full(LOG_DOMAIN_DFILTER, LOG_LEVEL_NOISY, NULL, -1, NULL,\n                        cf->dfcode, \"Rescanning packets with display filter\");\n    }\n\n    /* Get the union of the flags for all tap listeners. */\n    tap_flags = union_of_tap_listener_flags();\n\n    /* If the display filter or any tap listeners require the columns,\n     * construct them. */\n    cinfo = (tap_listeners_require_columns() ||\n        dfilter_requires_columns(cf->dfcode)) ? &cf->cinfo : NULL;\n\n    /*\n     * Determine whether we need to create a protocol tree.\n     * We do if:\n     *\n     *    we're going to apply a display filter;\n     *\n     *    one of the tap listeners is going to apply a filter;\n     *\n     *    one of the tap listeners requires a protocol tree;\n     *\n     *    we're redissecting and a postdissector wants field\n     *    values or protocols on the first pass.\n     */\n    create_proto_tree =\n        (cf->dfcode != NULL || filtering_tap_listeners ||\n         (tap_flags & TL_REQUIRES_PROTO_TREE) ||\n         (redissect && postdissectors_want_hfids()));\n\n    reset_tap_listeners();\n    /* Which frame, if any, is the currently selected frame?\n       XXX - should the selected frame or the focus frame be the \"current\"\n       frame, that frame being the one from which \"Find Frame\" searches\n       start? */\n    selected_frame = cf->current_frame;\n\n    /* Mark frame num as not found */\n    selected_frame_num = -1;\n\n    /* Freeze the packet list while we redo it, so we don't get any\n       screen updates while it happens. */\n    packet_list_freeze();\n\n    if (redissect) {\n        /* We need to re-initialize all the state information that protocols\n           keep, because some preference that controls a dissector has changed,\n           which might cause the state information to be constructed differently\n           by that dissector. */\n\n        /* We might receive new packets while redissecting, and we don't\n           want to dissect those before their time. */\n        cf->redissecting = true;\n\n        /* 'reset' dissection session */\n        epan_free(cf->epan);\n        if (cf->edt && cf->edt->pi.fd) {\n            /* All pointers in \"per frame proto data\" for the currently selected\n               packet are allocated in wmem_file_scope() and deallocated in epan_free().\n               Free them here to avoid unintended usage in packet_list_clear(). */\n            frame_data_destroy(cf->edt->pi.fd);\n        }\n        cf->epan = ws_epan_new(cf);\n        cf->cinfo.epan = cf->epan;\n\n        /* A new Lua tap listener may be registered in lua_prime_all_fields()\n           called via epan_new() / init_dissection() when reloading Lua plugins. */\n        if (!create_proto_tree && have_filtering_tap_listeners()) {\n            create_proto_tree = true;\n        }\n        if (!cinfo && tap_listeners_require_columns()) {\n            cinfo = &cf->cinfo;\n        }\n\n        /* We need to redissect the packets so we have to discard our old\n         * packet list store. */\n        packet_list_clear();\n        add_to_packet_list = true;\n    }\n\n    /* We don't yet know which will be the first and last frames displayed. */\n    cf->first_displayed = 0;\n    cf->last_displayed = 0;\n\n    /* We currently don't display any packets */\n    cf->displayed_count = 0;\n\n    /* Iterate through the list of frames.  Call a routine for each frame\n       to check whether it should be displayed and, if so, add it to\n       the display list. */\n    cf->provider.ref = NULL;\n    cf->provider.prev_dis = NULL;\n    cf->provider.prev_cap = NULL;\n    cf->cum_bytes = 0;\n\n    cf_callback_invoke(cf_cb_file_rescan_started, cf);\n\n    g_timer_start(prog_timer);\n    /* Count of packets at which we've looked. */\n    count = 0;\n    /* Progress so far. */\n    progbar_val = 0.0f;\n\n    cf->stop_flag = false;\n    start_time = g_get_monotonic_time();\n\n    /* no previous row yet */\n    prev_frame_num = -1;\n    prev_frame = NULL;\n\n    preceding_frame_num = -1;\n    preceding_frame = NULL;\n    following_frame_num = -1;\n    following_frame = NULL;\n\n    selected_frame_seen = false;\n\n    frames_count = cf->count;\n\n    epan_dissect_init(&edt, cf->epan, create_proto_tree, false);\n\n    if (redissect) {\n        /*\n         * Decryption secrets and name resolution blocks are read while\n         * sequentially processing records and then passed to the dissector.\n         * During redissection, the previous information is lost (see epan_free\n         * above), but they are not read again from the file as only packet\n         * records are re-read. Therefore reset the wtap secrets and name\n         * resolution callbacks such that wtap resupplies the callbacks with\n         * previously read information.\n         */\n        wtap_set_cb_new_ipv4(cf->provider.wth, add_ipv4_name);\n        wtap_set_cb_new_ipv6(cf->provider.wth, (wtap_new_ipv6_callback_t) add_ipv6_name);\n        wtap_set_cb_new_secrets(cf->provider.wth, secrets_wtap_callback);\n    }\n\n    for (framenum = 1; framenum <= frames_count; framenum++) {\n        fdata = frame_data_sequence_find(cf->provider.frames, framenum);\n\n        /* Create the progress bar if necessary.\n           We check on every iteration of the loop, so that it takes no\n           longer than the standard time to create it (otherwise, for a\n           large file, we might take considerably longer than that standard\n           time in order to get to the next progress bar step). */\n        if (progbar == NULL)\n            progbar = delayed_create_progress_dlg(cf->window, action, action_item, true,\n                    &cf->stop_flag,\n                    progbar_val);\n\n        /*\n         * Update the progress bar, but do it only after PROGBAR_UPDATE_INTERVAL\n         * has elapsed. Calling update_progress_dlg and packets_bar_update will\n         * likely trigger UI paint events, which might take a while depending on\n         * the platform and display. Reset our timer *after* painting.\n         */\n        if (g_timer_elapsed(prog_timer, NULL) > PROGBAR_UPDATE_INTERVAL) {\n            /* let's not divide by zero. I should never be started\n             * with count == 0, so let's assert that\n             */\n            ws_assert(cf->count > 0);\n            progbar_val = (float) count / frames_count;\n\n            if (progbar != NULL) {\n                snprintf(status_str, sizeof(status_str),\n                        \"%4u of %u frames\", count, frames_count);\n                update_progress_dlg(progbar, progbar_val, status_str);\n            }\n\n            g_timer_start(prog_timer);\n        }\n\n        queued_rescan_type = cf->redissection_queued;\n        if (queued_rescan_type != RESCAN_NONE) {\n            /* A redissection was requested while an existing redissection was\n             * pending. */\n            break;\n        }\n\n        if (cf->stop_flag) {\n            /* Well, the user decided to abort the filtering.  Just stop.\n\n               XXX - go back to the previous filter?  Users probably just\n               want not to wait for a filtering operation to finish;\n               unless we cancel by having no filter, reverting to the\n               previous filter will probably be even more expensive than\n               continuing the filtering, as it involves going back to the\n               beginning and filtering, and even with no filter we currently\n               have to re-generate the entire clist, which is also expensive.\n\n               I'm not sure what Network Monitor does, but it doesn't appear\n               to give you an unfiltered display if you cancel. */\n            break;\n        }\n\n        count++;\n\n        if (redissect) {\n            /* Since all state for the frame was destroyed, mark the frame\n             * as not visited, free the GSList referring to the state\n             * data (the per-frame data itself was freed by\n             * \"init_dissection()\"), and null out the GSList pointer. */\n            frame_data_reset(fdata);\n            frames_count = cf->count;\n        }\n\n        /* Frame dependencies from the previous dissection/filtering are no longer valid. */\n        fdata->dependent_of_displayed = 0;\n\n        if (!cf_read_record(cf, fdata, &rec))\n            break; /* error reading the frame */\n\n        /* If the previous frame is displayed, and we haven't yet seen the\n           selected frame, remember that frame - it's the closest one we've\n           yet seen before the selected frame. */\n        if (prev_frame_num != -1 && !selected_frame_seen && prev_frame->passed_dfilter) {\n            preceding_frame_num = prev_frame_num;\n            preceding_frame = prev_frame;\n        }\n\n        add_packet_to_packet_list(fdata, cf, &edt, cf->dfcode, cinfo, &rec,\n                add_to_packet_list);\n\n        /* If this frame is displayed, and this is the first frame we've\n           seen displayed after the selected frame, remember this frame -\n           it's the closest one we've yet seen at or after the selected\n           frame. */\n        if (fdata->passed_dfilter && selected_frame_seen && following_frame_num == -1) {\n            following_frame_num = fdata->num;\n            following_frame = fdata;\n        }\n        if (fdata == selected_frame) {\n            selected_frame_seen = true;\n            if (fdata->passed_dfilter)\n                selected_frame_num = fdata->num;\n        }\n\n        /* Remember this frame - it'll be the previous frame\n           on the next pass through the loop. */\n        prev_frame_num = fdata->num;\n        prev_frame = fdata;\n        wtap_rec_reset(&rec);\n    }\n\n    epan_dissect_cleanup(&edt);\n    wtap_rec_cleanup(&rec);\n\n    /* We are done redissecting the packet list. */\n    cf->redissecting = false;\n\n    if (redissect) {\n        frames_count = cf->count;\n        /* Clear out what remains of the visited flags and per-frame data\n           pointers.\n\n           XXX - that may cause various forms of bogosity when dissecting\n           these frames, as they won't have been seen by this sequential\n           pass, but the only alternative I see is to keep scanning them\n           even though the user requested that the scan stop, and that\n           would leave the user stuck with an Wireshark grinding on\n           until it finishes.  Should we just stick them with that? */\n        for (; framenum <= frames_count; framenum++) {\n            fdata = frame_data_sequence_find(cf->provider.frames, framenum);\n            frame_data_reset(fdata);\n        }\n    }\n\n    /* We're done filtering the packets; destroy the progress bar if it\n       was created. */\n    if (progbar != NULL)\n        destroy_progress_dlg(progbar);\n    g_timer_destroy(prog_timer);\n\n    /* Unfreeze the packet list. */\n    if (!add_to_packet_list)\n        packet_list_recreate_visible_rows();\n\n    /* Compute the time it took to filter the file */\n    compute_elapsed(cf, start_time);\n\n    packet_list_thaw();\n\n    /* It is safe again to execute redissections or sort. */\n    ws_assert(cf->read_lock);\n    cf->read_lock = false;\n\n    cf_callback_invoke(cf_cb_file_rescan_finished, cf);\n\n    if (selected_frame_num == -1) {\n        /* The selected frame didn't pass the filter. */\n        if (selected_frame == NULL) {\n            /* That's because there *was* no selected frame.  Make the first\n               displayed frame the current frame. */\n            selected_frame_num = 0;\n        } else {\n            /* Find the nearest displayed frame to the selected frame (whether\n               it's before or after that frame) and make that the current frame.\n               If the next and previous displayed frames are equidistant from the\n               selected frame, choose the next one. */\n            ws_assert(following_frame == NULL ||\n                    following_frame->num >= selected_frame->num);\n            ws_assert(preceding_frame == NULL ||\n                    preceding_frame->num <= selected_frame->num);\n            if (following_frame == NULL) {\n                /* No frame after the selected frame passed the filter, so we\n                   have to select the last displayed frame before the selected\n                   frame. */\n                selected_frame_num = preceding_frame_num;\n                selected_frame = preceding_frame;\n            } else if (preceding_frame == NULL) {\n                /* No frame before the selected frame passed the filter, so we\n                   have to select the first displayed frame after the selected\n                   frame. */\n                selected_frame_num = following_frame_num;\n                selected_frame = following_frame;\n            } else {\n                /* Frames before and after the selected frame passed the filter, so\n                   we'll select the previous frame */\n                selected_frame_num = preceding_frame_num;\n                selected_frame = preceding_frame;\n            }\n        }\n    }\n\n    if (selected_frame_num == -1) {\n        /* There are no frames displayed at all. */\n        cf_unselect_packet(cf);\n    } else {\n        /* Either the frame that was selected passed the filter, or we've\n           found the nearest displayed frame to that frame.  Select it, make\n           it the focus row, and make it visible. */\n        /* Set to invalid to force update of packet list and packet details */\n        if (selected_frame_num == 0) {\n            packet_list_select_row_from_data(NULL);\n        }else{\n            if (!packet_list_select_row_from_data(selected_frame)) {\n                /* We didn't find a row corresponding to this frame.\n                   This means that the frame isn't being displayed currently,\n                   so we can't select it. */\n                simple_message_box(ESD_TYPE_INFO, NULL,\n                        \"The capture file is probably not fully dissected.\",\n                        \"End of capture exceeded.\");\n            }\n        }\n    }\n\n    /* If another rescan (due to dfilter change) or redissection (due to profile\n     * change) was requested, the rescan above is aborted and restarted here. */\n    if (queued_rescan_type != RESCAN_NONE) {\n        redissect = redissect || queued_rescan_type == RESCAN_REDISSECT;\n        rescan_packets(cf, \"Reprocessing\", \"all packets\", redissect);\n    }\n}\n\n\n/*\n * Scan through all frame data and recalculate the ref time\n * without rereading the file.\n * XXX - do we need a progress bar or is this fast enough?\n */\nvoid\ncf_reftime_packets(capture_file* cf)\n{\n    uint32_t    framenum;\n    frame_data *fdata;\n    nstime_t rel_ts;\n\n    cf->provider.ref = NULL;\n    cf->provider.prev_dis = NULL;\n    cf->cum_bytes = 0;\n\n    for (framenum = 1; framenum <= cf->count; framenum++) {\n        fdata = frame_data_sequence_find(cf->provider.frames, framenum);\n\n        /* just add some value here until we know if it is being displayed or not */\n        fdata->cum_bytes = cf->cum_bytes + fdata->pkt_len;\n\n        /*\n         * Timestamps\n         */\n\n        if (fdata->has_ts) {\n            /* If we don't have the time stamp of the first packet in the\n               capture, it's because this is the first packet.  Save the time\n               stamp of this packet as the time stamp of the first packet. */\n            if (cf->provider.ref == NULL)\n                cf->provider.ref = fdata;\n            /* if this frames is marked as a reference time frame, reset\n               firstsec and firstusec to this frame */\n            if (fdata->ref_time)\n                cf->provider.ref = fdata;\n\n            /* Get the time elapsed between the first packet and this one. */\n            fdata->frame_ref_num = (fdata != cf->provider.ref) ? cf->provider.ref->num : 0;\n            nstime_delta(&rel_ts, &fdata->abs_ts, &cf->provider.ref->abs_ts);\n\n            /* If it's greater than the current elapsed time, set the elapsed\n               time to it (we check for \"greater than\" so as not to be\n               confused by time moving backwards). */\n            if ((int32_t)cf->elapsed_time.secs < rel_ts.secs\n                    || ((int32_t)cf->elapsed_time.secs == rel_ts.secs && (int32_t)cf->elapsed_time.nsecs < rel_ts.nsecs)) {\n                cf->elapsed_time = rel_ts;\n            }\n\n            /* If this frame is displayed, get the time elapsed between the\n               previous displayed packet and this packet. */\n            /* XXX: What if in the future we want to use the previously\n             * displayed frame for something else, too? Then we'd want\n             * to store this frame as prev_dis even if it doesn't have a\n             * timestamp. */\n            if ( fdata->passed_dfilter ) {\n                /* If we don't have the time stamp of the previous displayed\n                   packet, it's because this is the first displayed packet.\n                   Save the time stamp of this packet as the time stamp of\n                   the previous displayed packet. */\n                if (cf->provider.prev_dis == NULL) {\n                    cf->provider.prev_dis = fdata;\n                }\n\n                fdata->prev_dis_num = cf->provider.prev_dis->num;\n                cf->provider.prev_dis = fdata;\n            }\n        } else {\n            /* If this frame doesn't have a timestamp, don't calculate\n               anything with relative times. */\n            /* However, if this frame is marked as a reference time frame,\n               clear the reference frame so that the next frame with a\n               timestamp becomes the reference frame. */\n            if (fdata->ref_time) {\n                cf->provider.ref = NULL;\n            }\n        }\n\n        /*\n         * Byte counts\n         */\n        if ( (fdata->passed_dfilter) || (fdata->ref_time) ) {\n            /* This frame either passed the display filter list or is marked as\n               a time reference frame.  All time reference frames are displayed\n               even if they don't pass the display filter */\n            if (fdata->ref_time) {\n                /* if this was a TIME REF frame we should reset the cum_bytes field */\n                cf->cum_bytes = fdata->pkt_len;\n                fdata->cum_bytes = cf->cum_bytes;\n            } else {\n                /* increase cum_bytes with this packets length */\n                cf->cum_bytes += fdata->pkt_len;\n            }\n        }\n    }\n}\n\ntypedef enum {\n    PSP_FINISHED,\n    PSP_STOPPED,\n    PSP_FAILED\n} psp_return_t;\n\nstatic psp_return_t\nprocess_specified_records(capture_file *cf, packet_range_t *range,\n        const char *string1, const char *string2, bool terminate_is_stop,\n        bool (*callback)(capture_file *, frame_data *,\n            wtap_rec *, void *),\n        void *callback_args,\n        bool show_progress_bar)\n{\n    uint32_t         framenum;\n    frame_data      *fdata;\n    wtap_rec         rec;\n    psp_return_t     ret     = PSP_FINISHED;\n\n    progdlg_t       *progbar = NULL;\n    GTimer          *prog_timer = g_timer_new();\n    int              progbar_count;\n    float            progbar_val;\n    char             progbar_status_str[100];\n    range_process_e  process_this;\n\n    wtap_rec_init(&rec, 1514);\n\n    g_timer_start(prog_timer);\n    /* Count of packets at which we've looked. */\n    progbar_count = 0;\n    /* Progress so far. */\n    progbar_val = 0.0f;\n\n    /* XXX - It should be ok to have multiple readers, so long as nothing\n     * frees the epan context, e.g. rescan_packets with redissect true,\n     * or anything that closes the file (including reload and certain forms\n     * of saving.) This is mostly to stop cf_save_records but should probably\n     * be handled by callers in order to allow multiple readers (e.g.,\n     * restarting taps after adding or changing one.) We should probably\n     * make this a real reader-writer lock.\n     */\n    if (cf->read_lock) {\n        ws_warning(\"Failing due to nested process_specified_records(\\\"%s\\\") call!\", cf->filename);\n        return PSP_FAILED;\n    }\n    cf->read_lock = true;\n\n    cf->stop_flag = false;\n\n    if (range != NULL)\n        packet_range_process_init(range);\n\n    /* Iterate through all the packets, printing the packets that\n       were selected by the current display filter.  */\n    for (framenum = 1; framenum <= cf->count; framenum++) {\n        fdata = frame_data_sequence_find(cf->provider.frames, framenum);\n\n        /* Create the progress bar if necessary.\n           We check on every iteration of the loop, so that it takes no\n           longer than the standard time to create it (otherwise, for a\n           large file, we might take considerably longer than that standard\n           time in order to get to the next progress bar step). */\n        if (show_progress_bar && progbar == NULL)\n            progbar = delayed_create_progress_dlg(cf->window, string1, string2,\n                    terminate_is_stop,\n                    &cf->stop_flag,\n                    progbar_val);\n\n        /*\n         * Update the progress bar, but do it only after PROGBAR_UPDATE_INTERVAL\n         * has elapsed. Calling update_progress_dlg and packets_bar_update will\n         * likely trigger UI paint events, which might take a while depending on\n         * the platform and display. Reset our timer *after* painting.\n         */\n        if (progbar && g_timer_elapsed(prog_timer, NULL) > PROGBAR_UPDATE_INTERVAL) {\n            /* let's not divide by zero. I should never be started\n             * with count == 0, so let's assert that\n             */\n            ws_assert(cf->count > 0);\n            progbar_val = (float) progbar_count / cf->count;\n\n            snprintf(progbar_status_str, sizeof(progbar_status_str),\n                    \"%4u of %u packets\", progbar_count, cf->count);\n            update_progress_dlg(progbar, progbar_val, progbar_status_str);\n\n            g_timer_start(prog_timer);\n        }\n\n        if (cf->stop_flag) {\n            /* Well, the user decided to abort the operation.  Just stop,\n               and arrange to return PSP_STOPPED to our caller, so they know\n               it was stopped explicitly. */\n            ret = PSP_STOPPED;\n            break;\n        }\n\n        progbar_count++;\n\n        if (range != NULL) {\n            /* do we have to process this packet? */\n            process_this = packet_range_process_packet(range, fdata);\n            if (process_this == range_process_next) {\n                /* this packet uninteresting, continue with next one */\n                continue;\n            } else if (process_this == range_processing_finished) {\n                /* all interesting packets processed, stop the loop */\n                break;\n            }\n        }\n\n        /* Get the packet */\n        if (!cf_read_record(cf, fdata, &rec)) {\n            /* Attempt to get the packet failed. */\n            ret = PSP_FAILED;\n            break;\n        }\n        /* Process the packet */\n        if (!callback(cf, fdata, &rec, callback_args)) {\n            /* Callback failed.  We assume it reported the error appropriately. */\n            ret = PSP_FAILED;\n            break;\n        }\n        wtap_rec_reset(&rec);\n    }\n\n    /* We're done printing the packets; destroy the progress bar if\n       it was created. */\n    if (progbar != NULL)\n        destroy_progress_dlg(progbar);\n    g_timer_destroy(prog_timer);\n\n    ws_assert(cf->read_lock);\n    cf->read_lock = false;\n\n    wtap_rec_cleanup(&rec);\n\n    return ret;\n}\n\ntypedef struct {\n    epan_dissect_t edt;\n    column_info *cinfo;\n} retap_callback_args_t;\n\nstatic bool\nretap_packet(capture_file *cf, frame_data *fdata, wtap_rec *rec, void *argsp)\n{\n    retap_callback_args_t *args = (retap_callback_args_t *)argsp;\n\n    epan_dissect_run_with_taps(&args->edt, cf->cd_t, rec, fdata, args->cinfo);\n    epan_dissect_reset(&args->edt);\n\n    return true;\n}\n\ncf_read_status_t\ncf_retap_packets(capture_file *cf)\n{\n    packet_range_t        range;\n    retap_callback_args_t callback_args;\n    bool                  create_proto_tree;\n    bool                  filtering_tap_listeners;\n    unsigned              tap_flags;\n    psp_return_t          ret;\n\n    /* Presumably the user closed the capture file. */\n    if (cf == NULL) {\n        return CF_READ_ABORTED;\n    }\n\n    /* XXX - If cf->read_lock is true, process_specified_records will fail\n     * due to a nested call. We fail here so that we don't reset the tap\n     * listeners if this tap isn't going to succeed.\n     */\n    if (cf->read_lock) {\n        ws_warning(\"Failing due to nested process_specified_records(\\\"%s\\\") call!\", cf->filename);\n        return CF_READ_ERROR;\n    }\n\n    cf_callback_invoke(cf_cb_file_retap_started, cf);\n\n    /* Do we have any tap listeners with filters? */\n    filtering_tap_listeners = have_filtering_tap_listeners();\n\n    /* Update references in filters (if any) for the protocol\n     * tree corresponding to the currently selected frame in the GUI. */\n    /* XXX - What if we *don't* have a currently selected frame in the GUI,\n     * but we did the last time we loaded field references? Then they'll\n     * match something instead of nothing (unless they've been recompiled).\n     * Should we have a way to clear the field references even with a NULL tree?\n     */\n    if (cf->edt != NULL && cf->edt->tree != NULL) {\n        if (filtering_tap_listeners)\n            tap_listeners_load_field_references(cf->edt);\n    }\n\n    /* Get the union of the flags for all tap listeners. */\n    tap_flags = union_of_tap_listener_flags();\n\n    /* If any tap listeners require the columns, construct them. */\n    callback_args.cinfo = (tap_listeners_require_columns()) ? &cf->cinfo : NULL;\n\n    /*\n     * Determine whether we need to create a protocol tree.\n     * We do if:\n     *\n     *    one of the tap listeners is going to apply a filter;\n     *\n     *    one of the tap listeners requires a protocol tree.\n     */\n    create_proto_tree =\n        (filtering_tap_listeners || (tap_flags & TL_REQUIRES_PROTO_TREE));\n\n    /* Reset the tap listeners. */\n    reset_tap_listeners();\n    uint32_t count = cf->count;\n\n    epan_dissect_init(&callback_args.edt, cf->epan, create_proto_tree, false);\n\n    /* Iterate through the list of packets, dissecting all packets and\n       re-running the taps. */\n    packet_range_init(&range, cf);\n    packet_range_process_init(&range);\n\n    if (cf->state == FILE_READ_IN_PROGRESS) {\n        /* We're not done with the sequential read of the file and might\n         * add more frames while process_specified_records is going. We\n         * don't want to tap new frames twice, so limit the range to the\n         * frames already here.\n         *\n         * cf_read sets read_lock so we don't tap in case of an offline\n         * file, but cf_continue_tail and cf_finish_tail don't, and we\n         * don't want them to, because tapping new packets in a live\n         * capture is a common use case.\n         *\n         * Note that most other users of process_specified_records (saving,\n         * printing) do want to process new packets, unlike taps.\n         */\n        if (count) {\n            char* range_str = g_strdup_printf(\"-%u\", count);\n            packet_range_convert_str(&range, range_str);\n            g_free(range_str);\n        } else {\n            /* range_t treats a missing number as meaning 1, not 0, and\n             * reverses the order if backwards; thus the syntax -0 means\n             * 0-1, so to only take zero packets we do this.\n             */\n            packet_range_convert_str(&range, \"0\");\n        }\n        range.process = range_process_user_range;\n    }\n\n    ret = process_specified_records(cf, &range, \"Recalculating statistics on\",\n            \"all packets\", true, retap_packet,\n            &callback_args, true);\n\n    packet_range_cleanup(&range);\n    epan_dissect_cleanup(&callback_args.edt);\n\n    cf_callback_invoke(cf_cb_file_retap_finished, cf);\n\n    switch (ret) {\n        case PSP_FINISHED:\n            /* Completed successfully. */\n            return CF_READ_OK;\n\n        case PSP_STOPPED:\n            /* Well, the user decided to abort the refiltering.\n               Return CF_READ_ABORTED so our caller knows they did that. */\n            return CF_READ_ABORTED;\n\n        case PSP_FAILED:\n            /* Error while retapping. */\n            return CF_READ_ERROR;\n    }\n\n    ws_assert_not_reached();\n    return CF_READ_OK;\n}\n\ntypedef struct {\n    print_args_t *print_args;\n    bool          print_header_line;\n    char         *header_line_buf;\n    int           header_line_buf_len;\n    bool          print_formfeed;\n    bool          print_separator;\n    char         *line_buf;\n    int           line_buf_len;\n    int          *col_widths;\n    int           num_visible_cols;\n    int          *visible_cols;\n    epan_dissect_t edt;\n} print_callback_args_t;\n\nstatic bool\nprint_packet(capture_file *cf, frame_data *fdata, wtap_rec *rec, void *argsp)\n{\n    print_callback_args_t *args = (print_callback_args_t *)argsp;\n    int             i;\n    char           *cp;\n    int             line_len;\n    int             column_len;\n    int             cp_off;\n    char            bookmark_name[9+10+1];  /* \"__frameNNNNNNNNNN__\\0\" */\n    char            bookmark_title[6+10+1]; /* \"Frame NNNNNNNNNN__\\0\"  */\n    col_item_t*     col_item;\n    const char*    col_text;\n\n    /* Fill in the column information if we're printing the summary\n       information. */\n    if (args->print_args->print_summary) {\n        col_custom_prime_edt(&args->edt, &cf->cinfo);\n        epan_dissect_run(&args->edt, cf->cd_t, rec, fdata, &cf->cinfo);\n        epan_dissect_fill_in_columns(&args->edt, false, true);\n    } else\n        epan_dissect_run(&args->edt, cf->cd_t, rec, fdata, NULL);\n\n    if (args->print_formfeed) {\n        if (!new_page(args->print_args->stream))\n            goto fail;\n\n        /*\n         * Print another header line if we print a packet summary on the\n         * new page.\n         */\n        if (args->print_args->print_col_headings)\n            args->print_header_line = true;\n    } else {\n        if (args->print_separator) {\n            if (!print_line(args->print_args->stream, 0, \"\"))\n                goto fail;\n        }\n    }\n\n    /*\n     * We generate bookmarks, if the output format supports them.\n     * The name is \"__frameN__\".\n     */\n    snprintf(bookmark_name, sizeof bookmark_name, \"__frame%u__\", fdata->num);\n\n    if (args->print_args->print_summary) {\n        if (!args->print_args->print_col_headings)\n            args->print_header_line = false;\n        if (args->print_header_line) {\n            if (!print_line(args->print_args->stream, 0, args->header_line_buf))\n                goto fail;\n            args->print_header_line = false;  /* we might not need to print any more */\n        }\n        cp = &args->line_buf[0];\n        line_len = 0;\n        for (i = 0; i < args->num_visible_cols; i++) {\n            col_item = &cf->cinfo.columns[args->visible_cols[i]];\n            col_text = get_column_text(&cf->cinfo, args->visible_cols[i]);\n            /* Find the length of the string for this column. */\n            column_len = (int) strlen(col_text);\n            if (args->col_widths[i] > column_len)\n                column_len = args->col_widths[i];\n\n            /* Make sure there's room in the line buffer for the column; if not,\n               double its length. */\n            line_len += column_len + 1;   /* \"+1\" for space */\n            if (line_len > args->line_buf_len) {\n                cp_off = (int) (cp - args->line_buf);\n                args->line_buf_len = 2 * line_len;\n                args->line_buf = (char *)g_realloc(args->line_buf, args->line_buf_len + 1);\n                cp = args->line_buf + cp_off;\n            }\n\n            /* Right-justify the packet number column. */\n            if (col_item->col_fmt == COL_NUMBER || col_item->col_fmt == COL_NUMBER_DIS)\n                snprintf(cp, column_len+1, \"%*s\", args->col_widths[i], col_text);\n            else\n                snprintf(cp, column_len+1, \"%-*s\", args->col_widths[i], col_text);\n            cp += column_len;\n            if (i != args->num_visible_cols - 1)\n                *cp++ = ' ';\n        }\n        *cp = '\\0';\n\n        /*\n         * Generate a bookmark, using the summary line as the title.\n         */\n        if (!print_bookmark(args->print_args->stream, bookmark_name,\n                    args->line_buf))\n            goto fail;\n\n        if (!print_line(args->print_args->stream, 0, args->line_buf))\n            goto fail;\n    } else {\n        /*\n         * Generate a bookmark, using \"Frame N\" as the title, as we're not\n         * printing the summary line.\n         */\n        snprintf(bookmark_title, sizeof bookmark_title, \"Frame %u\", fdata->num);\n        if (!print_bookmark(args->print_args->stream, bookmark_name,\n                    bookmark_title))\n            goto fail;\n    } /* if (print_summary) */\n\n    if (args->print_args->print_dissections != print_dissections_none) {\n        if (args->print_args->print_summary) {\n            /* Separate the summary line from the tree with a blank line. */\n            if (!print_line(args->print_args->stream, 0, \"\"))\n                goto fail;\n        }\n\n        /* Print the information in that tree. */\n        if (!proto_tree_print(args->print_args->print_dissections,\n                    args->print_args->print_hex, &args->edt, NULL,\n                    args->print_args->stream))\n            goto fail;\n\n        /* Print a blank line if we print anything after this (aka more than one packet). */\n        args->print_separator = true;\n\n        /* Print a header line if we print any more packet summaries */\n        if (args->print_args->print_col_headings)\n            args->print_header_line = true;\n    }\n\n    if (args->print_args->print_hex) {\n        if (args->print_args->print_summary || (args->print_args->print_dissections != print_dissections_none)) {\n            if (!print_line(args->print_args->stream, 0, \"\"))\n                goto fail;\n        }\n        /* Print the full packet data as hex. */\n        if (!print_hex_data(args->print_args->stream, &args->edt, args->print_args->hexdump_options))\n            goto fail;\n\n        /* Print a blank line if we print anything after this (aka more than one packet). */\n        args->print_separator = true;\n\n        /* Print a header line if we print any more packet summaries */\n        if (args->print_args->print_col_headings)\n            args->print_header_line = true;\n    } /* if (args->print_args->print_dissections != print_dissections_none) */\n\n    epan_dissect_reset(&args->edt);\n\n    /* do we want to have a formfeed between each packet from now on? */\n    if (args->print_args->print_formfeed) {\n        args->print_formfeed = true;\n    }\n\n    return true;\n\nfail:\n    epan_dissect_reset(&args->edt);\n    return false;\n}\n\ncf_print_status_t\ncf_print_packets(capture_file *cf, print_args_t *print_args,\n        bool show_progress_bar)\n{\n    print_callback_args_t callback_args;\n    int           data_width;\n    char         *cp;\n    int           i, cp_off, column_len, line_len;\n    int           num_visible_col = 0, last_visible_col = 0, visible_col_count;\n    psp_return_t  ret;\n    GList        *clp;\n    fmt_data     *cfmt;\n    bool          proto_tree_needed;\n\n    callback_args.print_args = print_args;\n    callback_args.print_header_line = print_args->print_col_headings;\n    callback_args.header_line_buf = NULL;\n    callback_args.header_line_buf_len = 256;\n    callback_args.print_formfeed = false;\n    callback_args.print_separator = false;\n    callback_args.line_buf = NULL;\n    callback_args.line_buf_len = 256;\n    callback_args.col_widths = NULL;\n    callback_args.num_visible_cols = 0;\n    callback_args.visible_cols = NULL;\n\n    if (!print_preamble(print_args->stream, cf->filename, get_ws_vcs_version_info())) {\n        destroy_print_stream(print_args->stream);\n        return CF_PRINT_WRITE_ERROR;\n    }\n\n    if (print_args->print_summary) {\n        /* We're printing packet summaries.  Allocate the header line buffer\n           and get the column widths. */\n        callback_args.header_line_buf = (char *)g_malloc(callback_args.header_line_buf_len + 1);\n\n        /* Find the number of visible columns and the last visible column */\n        for (i = 0; i < prefs.num_cols; i++) {\n\n            clp = g_list_nth(prefs.col_list, i);\n            if (clp == NULL) /* Sanity check, Invalid column requested */\n                continue;\n\n            cfmt = (fmt_data *) clp->data;\n            if (cfmt->visible) {\n                num_visible_col++;\n                last_visible_col = i;\n            }\n        }\n\n        /* if num_visible_col is 0, we are done */\n        if (num_visible_col == 0) {\n            g_free(callback_args.header_line_buf);\n            return CF_PRINT_OK;\n        }\n\n        /* Find the widths for each of the columns - maximum of the\n           width of the title and the width of the data - and construct\n           a buffer with a line containing the column titles. */\n        callback_args.num_visible_cols = num_visible_col;\n        callback_args.col_widths = g_new(int, num_visible_col);\n        callback_args.visible_cols = g_new(int, num_visible_col);\n        cp = &callback_args.header_line_buf[0];\n        line_len = 0;\n        visible_col_count = 0;\n        for (i = 0; i < cf->cinfo.num_cols; i++) {\n\n            clp = g_list_nth(prefs.col_list, i);\n            if (clp == NULL) /* Sanity check, Invalid column requested */\n                continue;\n\n            cfmt = (fmt_data *) clp->data;\n            if (cfmt->visible == false)\n                continue;\n\n            /* Save the order of visible columns */\n            callback_args.visible_cols[visible_col_count] = i;\n\n            /* Don't pad the last column. */\n            if (i == last_visible_col)\n                callback_args.col_widths[visible_col_count] = 0;\n            else {\n                callback_args.col_widths[visible_col_count] = (int) strlen(cf->cinfo.columns[i].col_title);\n                data_width = get_column_char_width(get_column_format(i));\n                if (data_width > callback_args.col_widths[visible_col_count])\n                    callback_args.col_widths[visible_col_count] = data_width;\n            }\n\n            /* Find the length of the string for this column. */\n            column_len = (int) strlen(cf->cinfo.columns[i].col_title);\n            if (callback_args.col_widths[visible_col_count] > column_len)\n                column_len = callback_args.col_widths[visible_col_count];\n\n            /* Make sure there's room in the line buffer for the column; if not,\n               double its length. */\n            line_len += column_len + 1;   /* \"+1\" for space */\n            if (line_len > callback_args.header_line_buf_len) {\n                cp_off = (int) (cp - callback_args.header_line_buf);\n                callback_args.header_line_buf_len = 2 * line_len;\n                callback_args.header_line_buf = (char *)g_realloc(callback_args.header_line_buf,\n                        callback_args.header_line_buf_len + 1);\n                cp = callback_args.header_line_buf + cp_off;\n            }\n\n            /* Right-justify the packet number column. */\n/*          if (cf->cinfo.col_fmt[i] == COL_NUMBER || cf->cinfo.col_fmt[i] == COL_NUMBER_DIS)\n                snprintf(cp, column_len+1, \"%*s\", callback_args.col_widths[visible_col_count], cf->cinfo.columns[i].col_title);\n            else*/\n            snprintf(cp, column_len+1, \"%-*s\", callback_args.col_widths[visible_col_count], cf->cinfo.columns[i].col_title);\n            cp += column_len;\n            if (i != cf->cinfo.num_cols - 1)\n                *cp++ = ' ';\n\n            visible_col_count++;\n        }\n        *cp = '\\0';\n\n        /* Now start out the main line buffer with the same length as the\n           header line buffer. */\n        callback_args.line_buf_len = callback_args.header_line_buf_len;\n        callback_args.line_buf = (char *)g_malloc(callback_args.line_buf_len + 1);\n    } /* if (print_summary) */\n\n    /* Create the protocol tree, and make it visible, if we're printing\n       the dissection or the hex data.\n       XXX - do we need it if we're just printing the hex data? */\n    proto_tree_needed =\n        callback_args.print_args->print_dissections != print_dissections_none ||\n        callback_args.print_args->print_hex ||\n        have_custom_cols(&cf->cinfo) || have_field_extractors();\n    epan_dissect_init(&callback_args.edt, cf->epan, proto_tree_needed, proto_tree_needed);\n\n    /* Iterate through the list of packets, printing the packets we were\n       told to print. */\n    ret = process_specified_records(cf, &print_args->range, \"Printing\",\n            \"selected packets\", true, print_packet,\n            &callback_args, show_progress_bar);\n    epan_dissect_cleanup(&callback_args.edt);\n    g_free(callback_args.header_line_buf);\n    g_free(callback_args.line_buf);\n    g_free(callback_args.col_widths);\n    g_free(callback_args.visible_cols);\n\n    switch (ret) {\n\n        case PSP_FINISHED:\n            /* Completed successfully. */\n            break;\n\n        case PSP_STOPPED:\n            /* Well, the user decided to abort the printing.\n\n               XXX - note that what got generated before they did that\n               will get printed if we're piping to a print program; we'd\n               have to write to a file and then hand that to the print\n               program to make it actually not print anything. */\n            break;\n\n        case PSP_FAILED:\n            /* Error while printing.\n\n               XXX - note that what got generated before they did that\n               will get printed if we're piping to a print program; we'd\n               have to write to a file and then hand that to the print\n               program to make it actually not print anything. */\n            destroy_print_stream(print_args->stream);\n            return CF_PRINT_WRITE_ERROR;\n    }\n\n    if (!print_finale(print_args->stream)) {\n        destroy_print_stream(print_args->stream);\n        return CF_PRINT_WRITE_ERROR;\n    }\n\n    if (!destroy_print_stream(print_args->stream))\n        return CF_PRINT_WRITE_ERROR;\n\n    return CF_PRINT_OK;\n}\n\ntypedef struct {\n    FILE *fh;\n    epan_dissect_t edt;\n    print_args_t *print_args;\n    json_dumper jdumper;\n} write_packet_callback_args_t;\n\nstatic bool\nwrite_pdml_packet(capture_file *cf, frame_data *fdata, wtap_rec *rec,\n        void *argsp)\n{\n    write_packet_callback_args_t *args = (write_packet_callback_args_t *)argsp;\n\n    /* Create the protocol tree, but don't fill in the column information. */\n    epan_dissect_run(&args->edt, cf->cd_t, rec, fdata, NULL);\n\n    /* Write out the information in that tree. */\n    write_pdml_proto_tree(NULL, &args->edt, &cf->cinfo, args->fh, false);\n\n    epan_dissect_reset(&args->edt);\n\n    return !ferror(args->fh);\n}\n\ncf_print_status_t\ncf_write_pdml_packets(capture_file *cf, print_args_t *print_args)\n{\n    write_packet_callback_args_t callback_args;\n    FILE         *fh;\n    psp_return_t  ret;\n\n    fh = ws_fopen(print_args->file, \"w\");\n    if (fh == NULL)\n        return CF_PRINT_OPEN_ERROR; /* attempt to open destination failed */\n\n    write_pdml_preamble(fh, cf->filename);\n    if (ferror(fh)) {\n        fclose(fh);\n        return CF_PRINT_WRITE_ERROR;\n    }\n\n    callback_args.fh = fh;\n    callback_args.print_args = print_args;\n    epan_dissect_init(&callback_args.edt, cf->epan, true, true);\n\n    /* Iterate through the list of packets, printing the packets we were\n       told to print. */\n    ret = process_specified_records(cf, &print_args->range, \"Writing PDML\",\n            \"selected packets\", true,\n            write_pdml_packet, &callback_args, true);\n\n    epan_dissect_cleanup(&callback_args.edt);\n\n    switch (ret) {\n\n        case PSP_FINISHED:\n            /* Completed successfully. */\n            break;\n\n        case PSP_STOPPED:\n            /* Well, the user decided to abort the printing. */\n            break;\n\n        case PSP_FAILED:\n            /* Error while printing. */\n            fclose(fh);\n            return CF_PRINT_WRITE_ERROR;\n    }\n\n    write_pdml_finale(fh);\n    if (ferror(fh)) {\n        fclose(fh);\n        return CF_PRINT_WRITE_ERROR;\n    }\n\n    /* XXX - check for an error */\n    fclose(fh);\n\n    return CF_PRINT_OK;\n}\n\nstatic bool\nwrite_psml_packet(capture_file *cf, frame_data *fdata, wtap_rec *rec,\n        void *argsp)\n{\n    write_packet_callback_args_t *args = (write_packet_callback_args_t *)argsp;\n\n    /* Fill in the column information */\n    col_custom_prime_edt(&args->edt, &cf->cinfo);\n    epan_dissect_run(&args->edt, cf->cd_t, rec, fdata, &cf->cinfo);\n    epan_dissect_fill_in_columns(&args->edt, false, true);\n\n    /* Write out the column information. */\n    write_psml_columns(&args->edt, args->fh, false);\n\n    epan_dissect_reset(&args->edt);\n\n    return !ferror(args->fh);\n}\n\ncf_print_status_t\ncf_write_psml_packets(capture_file *cf, print_args_t *print_args)\n{\n    write_packet_callback_args_t callback_args;\n    FILE         *fh;\n    psp_return_t  ret;\n\n    bool proto_tree_needed;\n\n    fh = ws_fopen(print_args->file, \"w\");\n    if (fh == NULL)\n        return CF_PRINT_OPEN_ERROR; /* attempt to open destination failed */\n\n    write_psml_preamble(&cf->cinfo, fh);\n    if (ferror(fh)) {\n        fclose(fh);\n        return CF_PRINT_WRITE_ERROR;\n    }\n\n    callback_args.fh = fh;\n    callback_args.print_args = print_args;\n\n    /* Fill in the column information, only create the protocol tree\n       if having custom columns or field extractors. */\n    proto_tree_needed = have_custom_cols(&cf->cinfo) || have_field_extractors();\n    epan_dissect_init(&callback_args.edt, cf->epan, proto_tree_needed, proto_tree_needed);\n\n    /* Iterate through the list of packets, printing the packets we were\n       told to print. */\n    ret = process_specified_records(cf, &print_args->range, \"Writing PSML\",\n            \"selected packets\", true,\n            write_psml_packet, &callback_args, true);\n\n    epan_dissect_cleanup(&callback_args.edt);\n\n    switch (ret) {\n\n        case PSP_FINISHED:\n            /* Completed successfully. */\n            break;\n\n        case PSP_STOPPED:\n            /* Well, the user decided to abort the printing. */\n            break;\n\n        case PSP_FAILED:\n            /* Error while printing. */\n            fclose(fh);\n            return CF_PRINT_WRITE_ERROR;\n    }\n\n    write_psml_finale(fh);\n    if (ferror(fh)) {\n        fclose(fh);\n        return CF_PRINT_WRITE_ERROR;\n    }\n\n    /* XXX - check for an error */\n    fclose(fh);\n\n    return CF_PRINT_OK;\n}\n\nstatic bool\nwrite_csv_packet(capture_file *cf, frame_data *fdata, wtap_rec *rec,\n        void *argsp)\n{\n    write_packet_callback_args_t *args = (write_packet_callback_args_t *)argsp;\n\n    col_custom_prime_edt(&args->edt, &cf->cinfo);\n    epan_dissect_run(&args->edt, cf->cd_t, rec, fdata, &cf->cinfo);\n    epan_dissect_fill_in_columns(&args->edt, false, true);\n\n    /* Write out the column information. */\n    write_csv_columns(&args->edt, args->fh);\n\n    epan_dissect_reset(&args->edt);\n\n    return !ferror(args->fh);\n}\n\ncf_print_status_t\ncf_write_csv_packets(capture_file *cf, print_args_t *print_args)\n{\n    write_packet_callback_args_t callback_args;\n    bool            proto_tree_needed;\n    FILE         *fh;\n    psp_return_t  ret;\n\n    fh = ws_fopen(print_args->file, \"w\");\n    if (fh == NULL)\n        return CF_PRINT_OPEN_ERROR; /* attempt to open destination failed */\n\n    write_csv_column_titles(&cf->cinfo, fh);\n    if (ferror(fh)) {\n        fclose(fh);\n        return CF_PRINT_WRITE_ERROR;\n    }\n\n    callback_args.fh = fh;\n    callback_args.print_args = print_args;\n\n    /* only create the protocol tree if having custom columns or field extractors. */\n    proto_tree_needed = have_custom_cols(&cf->cinfo) || have_field_extractors();\n    epan_dissect_init(&callback_args.edt, cf->epan, proto_tree_needed, proto_tree_needed);\n\n    /* Iterate through the list of packets, printing the packets we were\n       told to print. */\n    ret = process_specified_records(cf, &print_args->range, \"Writing CSV\",\n            \"selected packets\", true,\n            write_csv_packet, &callback_args, true);\n\n    epan_dissect_cleanup(&callback_args.edt);\n\n    switch (ret) {\n\n        case PSP_FINISHED:\n            /* Completed successfully. */\n            break;\n\n        case PSP_STOPPED:\n            /* Well, the user decided to abort the printing. */\n            break;\n\n        case PSP_FAILED:\n            /* Error while printing. */\n            fclose(fh);\n            return CF_PRINT_WRITE_ERROR;\n    }\n\n    /* XXX - check for an error */\n    fclose(fh);\n\n    return CF_PRINT_OK;\n}\n\nstatic bool\ncarrays_write_packet(capture_file *cf, frame_data *fdata, wtap_rec *rec,\n        void *argsp)\n{\n    write_packet_callback_args_t *args = (write_packet_callback_args_t *)argsp;\n\n    epan_dissect_run(&args->edt, cf->cd_t, rec, fdata, NULL);\n    write_carrays_hex_data(fdata->num, args->fh, &args->edt);\n    epan_dissect_reset(&args->edt);\n\n    return !ferror(args->fh);\n}\n\ncf_print_status_t\ncf_write_carrays_packets(capture_file *cf, print_args_t *print_args)\n{\n    write_packet_callback_args_t callback_args;\n    FILE         *fh;\n    psp_return_t  ret;\n\n    fh = ws_fopen(print_args->file, \"w\");\n\n    if (fh == NULL)\n        return CF_PRINT_OPEN_ERROR; /* attempt to open destination failed */\n\n    if (ferror(fh)) {\n        fclose(fh);\n        return CF_PRINT_WRITE_ERROR;\n    }\n\n    callback_args.fh = fh;\n    callback_args.print_args = print_args;\n    epan_dissect_init(&callback_args.edt, cf->epan, true, true);\n\n    /* Iterate through the list of packets, printing the packets we were\n       told to print. */\n    ret = process_specified_records(cf, &print_args->range,\n            \"Writing C Arrays\",\n            \"selected packets\", true,\n            carrays_write_packet, &callback_args, true);\n\n    epan_dissect_cleanup(&callback_args.edt);\n\n    switch (ret) {\n        case PSP_FINISHED:\n            /* Completed successfully. */\n            break;\n        case PSP_STOPPED:\n            /* Well, the user decided to abort the printing. */\n            break;\n        case PSP_FAILED:\n            /* Error while printing. */\n            fclose(fh);\n            return CF_PRINT_WRITE_ERROR;\n    }\n\n    fclose(fh);\n    return CF_PRINT_OK;\n}\n\nstatic bool\nwrite_json_packet(capture_file *cf, frame_data *fdata, wtap_rec *rec,\n        void *argsp)\n{\n    write_packet_callback_args_t *args = (write_packet_callback_args_t *)argsp;\n\n    /* Create the protocol tree, but don't fill in the column information. */\n    epan_dissect_run(&args->edt, cf->cd_t, rec, fdata, NULL);\n\n    /* Write out the information in that tree. */\n    write_json_proto_tree(NULL, args->print_args->print_dissections,\n            args->print_args->print_hex,\n            &args->edt, &cf->cinfo, proto_node_group_children_by_unique,\n            &args->jdumper);\n\n    epan_dissect_reset(&args->edt);\n\n    return !ferror(args->fh);\n}\n\ncf_print_status_t\ncf_write_json_packets(capture_file *cf, print_args_t *print_args)\n{\n    write_packet_callback_args_t callback_args;\n    FILE         *fh;\n    psp_return_t  ret;\n\n    fh = ws_fopen(print_args->file, \"w\");\n    if (fh == NULL)\n        return CF_PRINT_OPEN_ERROR; /* attempt to open destination failed */\n\n    callback_args.jdumper = write_json_preamble(fh);\n    if (ferror(fh)) {\n        fclose(fh);\n        return CF_PRINT_WRITE_ERROR;\n    }\n\n    callback_args.fh = fh;\n    callback_args.print_args = print_args;\n    epan_dissect_init(&callback_args.edt, cf->epan, true, true);\n\n    /* Iterate through the list of packets, printing the packets we were\n       told to print. */\n    ret = process_specified_records(cf, &print_args->range, \"Writing JSON\",\n            \"selected packets\", true,\n            write_json_packet, &callback_args, true);\n\n    epan_dissect_cleanup(&callback_args.edt);\n\n    switch (ret) {\n\n        case PSP_FINISHED:\n            /* Completed successfully. */\n            break;\n\n        case PSP_STOPPED:\n            /* Well, the user decided to abort the printing. */\n            break;\n\n        case PSP_FAILED:\n            /* Error while printing. */\n            fclose(fh);\n            return CF_PRINT_WRITE_ERROR;\n    }\n\n    write_json_finale(&callback_args.jdumper);\n    if (ferror(fh)) {\n        fclose(fh);\n        return CF_PRINT_WRITE_ERROR;\n    }\n\n    /* XXX - check for an error */\n    fclose(fh);\n\n    return CF_PRINT_OK;\n}\n\nbool\ncf_find_packet_protocol_tree(capture_file *cf, const char *string,\n        search_direction dir, bool multiple)\n{\n    match_data mdata;\n\n    mdata.frame_matched = false;\n    mdata.halt = false;\n    mdata.string = string;\n    mdata.string_len = strlen(string);\n    mdata.cf = cf;\n    mdata.prev_finfo = cf->finfo_selected;\n    if (multiple && cf->finfo_selected && cf->edt) {\n        if (dir == SD_FORWARD) {\n            proto_tree_children_foreach(cf->edt->tree, match_subtree_text, &mdata);\n        } else {\n            proto_tree_children_foreach(cf->edt->tree, match_subtree_text_reverse, &mdata);\n        }\n        if (mdata.frame_matched) {\n            packet_list_select_finfo(mdata.finfo);\n            return true;\n        }\n    }\n    return find_packet(cf, match_protocol_tree, &mdata, dir, true);\n}\n\nfield_info*\ncf_find_string_protocol_tree(capture_file *cf, proto_tree *tree)\n{\n    match_data mdata;\n    mdata.frame_matched = false;\n    mdata.halt = false;\n    mdata.string = convert_string_case(cf->sfilter, cf->case_type);\n    mdata.string_len = strlen(mdata.string);\n    mdata.cf = cf;\n    mdata.prev_finfo = NULL;\n    /* Iterate through all the nodes looking for matching text */\n    if (cf->dir == SD_FORWARD) {\n        proto_tree_children_foreach(tree, match_subtree_text, &mdata);\n    } else {\n        proto_tree_children_foreach(tree, match_subtree_text_reverse, &mdata);\n    }\n    g_free((char *)mdata.string);\n    return mdata.frame_matched ? mdata.finfo : NULL;\n}\n\nstatic match_result\nmatch_protocol_tree(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    match_data     *mdata = (match_data *)criterion;\n    epan_dissect_t  edt;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    /* Construct the protocol tree, including the displayed text */\n    epan_dissect_init(&edt, cf->epan, true, true);\n    /* We don't need the column information */\n    epan_dissect_run(&edt, cf->cd_t, rec, fdata, NULL);\n\n    /* Iterate through all the nodes, seeing if they have text that matches. */\n    mdata->cf = cf;\n    mdata->frame_matched = false;\n    mdata->halt = false;\n    mdata->prev_finfo = NULL;\n    /* We don't care about the direction here, because we're just looking\n     * for one match and we'll destroy this tree anyway. (We find the actual\n     * field later in PacketList::selectionChanged().) Forwards is faster.\n     */\n    proto_tree_children_foreach(edt.tree, match_subtree_text, mdata);\n    epan_dissect_cleanup(&edt);\n    return mdata->frame_matched ? MR_MATCHED : MR_NOTMATCHED;\n}\n\nstatic void\nmatch_subtree_text(proto_node *node, void *data)\n{\n    match_data   *mdata      = (match_data *) data;\n    const char   *string     = mdata->string;\n    size_t        string_len = mdata->string_len;\n    capture_file *cf         = mdata->cf;\n    field_info   *fi         = PNODE_FINFO(node);\n    char          label_str[ITEM_LABEL_LENGTH];\n    char         *label_ptr;\n    size_t        label_len;\n    uint32_t      i, i_restart;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* dissection with an invisible proto tree? */\n    ws_assert(fi);\n\n    if (mdata->frame_matched) {\n        /* We already had a match; don't bother doing any more work. */\n        return;\n    }\n\n    /* Don't match invisible entries. */\n    if (proto_item_is_hidden(node))\n        return;\n\n    if (mdata->prev_finfo) {\n        /* Haven't found the old match, so don't match this node. */\n        if (fi == mdata->prev_finfo) {\n            /* Found the old match, look for the next one after this. */\n            mdata->prev_finfo = NULL;\n        }\n    } else {\n        /* was a free format label produced? */\n        if (fi->rep) {\n            label_ptr = fi->rep->representation;\n        } else {\n            /* no, make a generic label */\n            label_ptr = label_str;\n            proto_item_fill_label(fi, label_str, NULL);\n        }\n\n        if (cf->regex) {\n            if (ws_regex_matches(cf->regex, label_ptr)) {\n                mdata->frame_matched = true;\n                mdata->finfo = fi;\n                return;\n            }\n        } else if (cf->case_type) {\n            /* Case insensitive match */\n            label_len = strlen(label_ptr);\n            i_restart = 0;\n            for (i = 0; i < label_len; i++) {\n                if (i_restart == 0 && c_match == 0 && (label_len - i < string_len))\n                    break;\n                c_char = label_ptr[i];\n                c_char = g_ascii_toupper(c_char);\n                /* If c_match is non-zero, save candidate for retrying full match. */\n                if (c_match > 0 && i_restart == 0 && c_char == string[0])\n                    i_restart = i;\n                if (c_char == string[c_match]) {\n                    c_match++;\n                    if (c_match == string_len) {\n                        mdata->frame_matched = true;\n                        mdata->finfo = fi;\n                        /* No need to look further; we have a match */\n                        return;\n                    }\n                } else if (i_restart) {\n                    i = i_restart;\n                    c_match = 1;\n                    i_restart = 0;\n                } else\n                    c_match = 0;\n            }\n        } else if (strstr(label_ptr, string) != NULL) {\n            /* Case sensitive match */\n            mdata->frame_matched = true;\n            mdata->finfo = fi;\n            return;\n        }\n    }\n\n    /* Recurse into the subtree, if it exists */\n    if (node->first_child != NULL)\n        proto_tree_children_foreach(node, match_subtree_text, mdata);\n}\n\nstatic void\nmatch_subtree_text_reverse(proto_node *node, void *data)\n{\n    match_data   *mdata      = (match_data *) data;\n    const char   *string     = mdata->string;\n    size_t        string_len = mdata->string_len;\n    capture_file *cf         = mdata->cf;\n    field_info   *fi         = PNODE_FINFO(node);\n    char          label_str[ITEM_LABEL_LENGTH];\n    char         *label_ptr;\n    size_t        label_len;\n    uint32_t      i, i_restart;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* dissection with an invisible proto tree? */\n    ws_assert(fi);\n\n    /* We don't have an easy way to search backwards in the tree\n     * (see also, proto_find_field_from_offset()) because we don't\n     * have a previous node pointer, so we search backwards by\n     * searching forwards, only stopping if we see the old match\n     * (if we have one).\n     */\n\n    if (mdata->halt) {\n        return;\n    }\n\n    /* Don't match invisible entries. */\n    if (proto_item_is_hidden(node))\n        return;\n\n    if (mdata->prev_finfo && fi == mdata->prev_finfo) {\n        /* Found the old match, use the previous match. */\n        mdata->halt = true;\n        return;\n    }\n\n    /* was a free format label produced? */\n    if (fi->rep) {\n        label_ptr = fi->rep->representation;\n    } else {\n        /* no, make a generic label */\n        label_ptr = label_str;\n        proto_item_fill_label(fi, label_str, NULL);\n    }\n\n    if (cf->regex) {\n        if (ws_regex_matches(cf->regex, label_ptr)) {\n            mdata->frame_matched = true;\n            mdata->finfo = fi;\n        }\n    } else if (cf->case_type) {\n        /* Case insensitive match */\n        label_len = strlen(label_ptr);\n        i_restart = 0;\n        for (i = 0; i < label_len; i++) {\n            if (i_restart == 0 && c_match == 0 && (label_len - i < string_len))\n                break;\n            c_char = label_ptr[i];\n            c_char = g_ascii_toupper(c_char);\n            /* If c_match is non-zero, save candidate for retrying full match. */\n            if (c_match > 0 && i_restart == 0 && c_char == string[0])\n                i_restart = i;\n            if (c_char == string[c_match]) {\n                c_match++;\n                if (c_match == string_len) {\n                    mdata->frame_matched = true;\n                    mdata->finfo = fi;\n                    break;\n                }\n            } else if (i_restart) {\n                i = i_restart;\n                c_match = 1;\n                i_restart = 0;\n            } else\n                c_match = 0;\n        }\n    } else if (strstr(label_ptr, string) != NULL) {\n        /* Case sensitive match */\n        mdata->frame_matched = true;\n        mdata->finfo = fi;\n    }\n\n    /* Recurse into the subtree, if it exists */\n    if (node->first_child != NULL)\n        proto_tree_children_foreach(node, match_subtree_text_reverse, mdata);\n}\n\nbool\ncf_find_packet_summary_line(capture_file *cf, const char *string,\n        search_direction dir)\n{\n    match_data mdata;\n\n    mdata.string = string;\n    mdata.string_len = strlen(string);\n    return find_packet(cf, match_summary_line, &mdata, dir, true);\n}\n\nstatic match_result\nmatch_summary_line(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    match_data     *mdata      = (match_data *)criterion;\n    const char     *string     = mdata->string;\n    size_t          string_len = mdata->string_len;\n    epan_dissect_t  edt;\n    const char     *info_column;\n    size_t          info_column_len;\n    match_result    result     = MR_NOTMATCHED;\n    int             colx;\n    uint32_t        i, i_restart;\n    uint8_t         c_char;\n    size_t          c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    /* Don't bother constructing the protocol tree */\n    epan_dissect_init(&edt, cf->epan, false, false);\n    /* Get the column information */\n    epan_dissect_run(&edt, cf->cd_t, rec, fdata, &cf->cinfo);\n\n    /* Find the Info column */\n    for (colx = 0; colx < cf->cinfo.num_cols; colx++) {\n        if (cf->cinfo.columns[colx].fmt_matx[COL_INFO]) {\n            /* Found it.  See if we match. */\n            info_column = get_column_text(edt.pi.cinfo, colx);\n            info_column_len = strlen(info_column);\n            if (cf->regex) {\n                if (ws_regex_matches(cf->regex, info_column)) {\n                    result = MR_MATCHED;\n                    break;\n                }\n            } else if (cf->case_type) {\n                /* Case insensitive match */\n                i_restart = 0;\n                for (i = 0; i < info_column_len; i++) {\n                    if (i_restart == 0 && c_match == 0 && (info_column_len - i < string_len))\n                        break;\n                    c_char = info_column[i];\n                    c_char = g_ascii_toupper(c_char);\n                    /* If c_match is non-zero, save candidate for retrying full match. */\n                    if (c_match > 0 && i_restart == 0 && c_char == string[0])\n                        i_restart = i;\n                    if (c_char == string[c_match]) {\n                        c_match++;\n                        if (c_match == string_len) {\n                            result = MR_MATCHED;\n                            break;\n                        }\n                    } else if (i_restart) {\n                        i = i_restart;\n                        c_match = 1;\n                        i_restart = 0;\n                    } else\n                        c_match = 0;\n                }\n            } else if (strstr(info_column, string) != NULL) {\n                /* Case sensitive match */\n                result = MR_MATCHED;\n            }\n            break;\n        }\n    }\n    epan_dissect_cleanup(&edt);\n    return result;\n}\n\ntypedef struct {\n    const uint8_t *data;\n    size_t        data_len;\n    ws_mempbrk_pattern *pattern;\n} cbs_t;    /* \"Counted byte string\" */\n\n\n/*\n * The current match_* routines only support ASCII case insensitivity and don't\n * convert UTF-8 inputs to UTF-16 for matching.  The UTF-16 support just\n * interleaves with \\0 bytes, which works for 7 bit ASCII.\n *\n * We could modify them to use the GLib Unicode routines or the International\n * Components for Unicode library but it's not apparent that we could do so\n * without consuming a lot more CPU and memory or that searching would be\n * significantly better.\n *\n * XXX: We could test the search string to see if it's all ASCII, and if not\n * use Unicode aware routines for case insensitive searches or any UTF-16\n * search.\n */\n\nbool\ncf_find_packet_data(capture_file *cf, const uint8_t *string, size_t string_size,\n        search_direction dir, bool multiple)\n{\n    cbs_t  info;\n    uint8_t needles[3];\n    ws_mempbrk_pattern pattern = {0};\n    ws_match_function match_function;\n\n    info.data = string;\n    info.data_len = string_size;\n\n    /* Regex, String or hex search? */\n    if (cf->regex) {\n        /* Regular Expression search */\n        match_function = (dir == SD_FORWARD) ? match_regex : match_regex_reverse;\n    } else if (cf->string) {\n        /* String search - what type of string? */\n        if (cf->case_type) {\n            needles[0] = string[0];\n            needles[1] = g_ascii_tolower(needles[0]);\n            needles[2] = '\\0';\n            ws_mempbrk_compile(&pattern, needles);\n            info.pattern = &pattern;\n            switch (cf->scs_type) {\n\n                case SCS_NARROW_AND_WIDE:\n                    match_function = (dir == SD_FORWARD) ? match_narrow_and_wide_case : match_narrow_and_wide_case_reverse;\n                    break;\n\n                case SCS_NARROW:\n                    match_function = (dir == SD_FORWARD) ? match_narrow_case : match_narrow_case_reverse;\n                    break;\n\n                case SCS_WIDE:\n                    match_function = (dir == SD_FORWARD) ? match_wide_case : match_wide_case_reverse;\n                    break;\n\n                default:\n                    ws_assert_not_reached();\n                    return false;\n            }\n\n        } else {\n            switch (cf->scs_type) {\n\n                case SCS_NARROW_AND_WIDE:\n                    match_function = (dir == SD_FORWARD) ? match_narrow_and_wide : match_narrow_and_wide_reverse;\n                    break;\n\n                case SCS_NARROW:\n                    /* Narrow, case-sensitive match is the same as looking\n                     * for a converted hexstring. */\n                    match_function = (dir == SD_FORWARD) ? match_binary : match_binary_reverse;\n                    break;\n\n                case SCS_WIDE:\n                    match_function = (dir == SD_FORWARD) ? match_wide : match_wide_reverse;\n                    break;\n\n                default:\n                    ws_assert_not_reached();\n                    return false;\n            }\n        }\n    } else {\n        match_function = (dir == SD_FORWARD) ? match_binary : match_binary_reverse;\n    }\n\n    if (multiple && cf->current_frame && (cf->search_pos || cf->search_len)) {\n        /* Use the current frame (this will perform the equivalent of\n         * cf_read_current_record() in match_function).\n         */\n        if (match_function(cf, cf->current_frame, &cf->rec, &info)) {\n            cf->search_in_progress = true;\n            if (cf->edt) {\n                field_info *fi = NULL;\n                /* The regex match can match an empty string. */\n                if (cf->search_len) {\n                    fi = proto_find_field_from_offset(cf->edt->tree, cf->search_pos + cf->search_len - 1, cf->edt->tvb);\n                }\n                packet_list_select_finfo(fi);\n            } else {\n                packet_list_select_row_from_data(cf->current_frame);\n            }\n            cf->search_in_progress = false;\n            return true;\n        }\n    }\n    cf->search_pos = 0; /* Reset the position */\n    cf->search_len = 0; /* Reset length */\n    return find_packet(cf, match_function, &info, dir, true);\n}\n\nstatic match_result\nmatch_narrow_and_wide(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info       = (cbs_t *)criterion;\n    const uint8_t *ascii_text = info->data;\n    size_t        textlen    = info->data_len;\n    match_result  result;\n    uint32_t      buf_len;\n    const uint8_t *pd, *buf_start, *buf_end;\n    uint32_t      i;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    result = MR_NOTMATCHED;\n    buf_len = fdata->cap_len;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    buf_end = buf_start + buf_len;\n    pd = buf_start;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte past the previous match start */\n        pd += cf->search_pos + 1;\n    }\n    for (; pd < buf_end; pd++) {\n        pd = (uint8_t *)memchr(pd, ascii_text[0], buf_end - pd);\n        if (pd == NULL) break;\n        /* Try narrow match at this start location */\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = pd[i];\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n            } else {\n                break;\n            }\n        }\n\n        /* Now try wide match at the same start location. */\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = pd[i];\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n                i++;\n                if (pd + i >= buf_end || pd[i] != '\\0') break;\n            } else {\n                break;\n            }\n        }\n    }\n\ndone:\n    return result;\n}\n\nstatic match_result\nmatch_narrow_and_wide_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info       = (cbs_t *)criterion;\n    const uint8_t *ascii_text = info->data;\n    size_t        textlen    = info->data_len;\n    match_result  result;\n    uint32_t      buf_len;\n    const uint8_t *pd, *buf_start, *buf_end;\n    uint32_t      i;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    result = MR_NOTMATCHED;\n    /* Has to be room to hold the sought data. */\n    if (textlen > fdata->cap_len) {\n        return result;\n    }\n    buf_len = fdata->cap_len;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    buf_end = buf_start + buf_len;\n    pd = buf_end - textlen;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte before the previous match start */\n        pd = buf_start + cf->search_pos - 1;\n    }\n    for (; pd < buf_end; pd++) {\n        pd = (uint8_t *)ws_memrchr(buf_start, ascii_text[0], pd - buf_start + 1);\n        if (pd == NULL) break;\n        /* Try narrow match at this start location */\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = pd[i];\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n            } else {\n                break;\n            }\n        }\n\n        /* Now try wide match at the same start location. */\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = pd[i];\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n                i++;\n                if (pd + i >= buf_end || pd[i] != '\\0') break;\n            } else {\n                break;\n            }\n        }\n    }\n\ndone:\n    return result;\n}\n\n/* Case insensitive match */\nstatic match_result\nmatch_narrow_and_wide_case(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info       = (cbs_t *)criterion;\n    const uint8_t *ascii_text = info->data;\n    size_t        textlen    = info->data_len;\n    ws_mempbrk_pattern *pattern = info->pattern;\n    match_result  result;\n    uint32_t      buf_len;\n    const uint8_t *pd, *buf_start, *buf_end;\n    uint32_t      i;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    ws_assert(pattern != NULL);\n\n    result = MR_NOTMATCHED;\n    buf_len = fdata->cap_len;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    buf_end = buf_start + buf_len;\n    pd = buf_start;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte past the previous match start */\n        pd += cf->search_pos + 1;\n    }\n    for (; pd < buf_end; pd++) {\n        pd = (uint8_t *)ws_mempbrk_exec(pd, buf_end - pd, pattern, &c_char);\n        if (pd == NULL) break;\n        /* Try narrow match at this start location */\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = g_ascii_toupper(pd[i]);\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n            } else {\n                break;\n            }\n        }\n\n        /* Now try wide match at the same start location. */\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = g_ascii_toupper(pd[i]);\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n                i++;\n                if (pd + i >= buf_end || pd[i] != '\\0') break;\n            } else {\n                break;\n            }\n        }\n    }\n\ndone:\n    return result;\n}\n\nstatic match_result\nmatch_narrow_and_wide_case_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info       = (cbs_t *)criterion;\n    const uint8_t *ascii_text = info->data;\n    size_t        textlen    = info->data_len;\n    ws_mempbrk_pattern *pattern = info->pattern;\n    match_result  result;\n    uint32_t      buf_len;\n    const uint8_t *pd, *buf_start, *buf_end;\n    uint32_t      i;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    ws_assert(pattern != NULL);\n\n    result = MR_NOTMATCHED;\n    /* Has to be room to hold the sought data. */\n    if (textlen > fdata->cap_len) {\n        return result;\n    }\n    buf_len = fdata->cap_len;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    buf_end = buf_start + buf_len;\n    pd = buf_end - textlen;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte before the previous match start */\n        pd = buf_start + cf->search_pos - 1;\n    }\n    for (; pd >= buf_start; pd--) {\n        pd = (uint8_t *)ws_memrpbrk_exec(buf_start, pd - buf_start + 1, pattern, &c_char);\n        if (pd == NULL) break;\n        /* Try narrow match at this start location */\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = g_ascii_toupper(pd[i]);\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n            } else {\n                break;\n            }\n        }\n\n        /* Now try wide match at the same start location. */\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = g_ascii_toupper(pd[i]);\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n                i++;\n                if (pd + i >= buf_end || pd[i] != '\\0') break;\n            } else {\n                break;\n            }\n        }\n    }\n\ndone:\n    return result;\n}\n\n/* Case insensitive match */\nstatic match_result\nmatch_narrow_case(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info       = (cbs_t *)criterion;\n    const uint8_t *ascii_text = info->data;\n    size_t        textlen    = info->data_len;\n    ws_mempbrk_pattern *pattern = info->pattern;\n    match_result  result;\n    uint32_t      buf_len;\n    const uint8_t *pd, *buf_start, *buf_end;\n    uint32_t      i;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    ws_assert(pattern != NULL);\n\n    result = MR_NOTMATCHED;\n    buf_len = fdata->cap_len;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    buf_end = buf_start + buf_len;\n    pd = buf_start;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte past the previous match start */\n        pd += cf->search_pos + 1;\n    }\n    for (; pd < buf_end; pd++) {\n        pd = (uint8_t *)ws_mempbrk_exec(pd, buf_end - pd, pattern, &c_char);\n        if (pd == NULL) break;\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = g_ascii_toupper(pd[i]);\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    /* Save position and length for highlighting the field. */\n                    result = MR_MATCHED;\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\ndone:\n    return result;\n}\n\nstatic match_result\nmatch_narrow_case_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info       = (cbs_t *)criterion;\n    const uint8_t *ascii_text = info->data;\n    size_t        textlen    = info->data_len;\n    ws_mempbrk_pattern *pattern = info->pattern;\n    match_result  result;\n    uint32_t      buf_len;\n    const uint8_t *pd, *buf_start, *buf_end;\n    uint32_t      i;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    ws_assert(pattern != NULL);\n\n    result = MR_NOTMATCHED;\n    /* Has to be room to hold the sought data. */\n    if (textlen > fdata->cap_len) {\n        return result;\n    }\n    buf_len = fdata->cap_len;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    buf_end = buf_start + buf_len;\n    pd = buf_end - textlen;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte before the previous match start */\n        pd = buf_start + cf->search_pos - 1;\n    }\n    for (; pd >= buf_start; pd--) {\n        pd = (uint8_t *)ws_memrpbrk_exec(buf_start, pd - buf_start + 1, pattern, &c_char);\n        if (pd == NULL) break;\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = g_ascii_toupper(pd[i]);\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    /* Save position and length for highlighting the field. */\n                    result = MR_MATCHED;\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\ndone:\n    return result;\n}\n\nstatic match_result\nmatch_wide(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info       = (cbs_t *)criterion;\n    const uint8_t *ascii_text = info->data;\n    size_t        textlen    = info->data_len;\n    match_result  result;\n    uint32_t      buf_len;\n    const uint8_t *pd, *buf_start, *buf_end;\n    uint32_t      i;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    result = MR_NOTMATCHED;\n    buf_len = fdata->cap_len;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    buf_end = buf_start + buf_len;\n    pd = buf_start;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte past the previous match start */\n        pd += cf->search_pos + 1;\n    }\n    for (; pd < buf_end; pd++) {\n        pd = (uint8_t *)memchr(pd, ascii_text[0], buf_end - pd);\n        if (pd == NULL) break;\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = pd[i];\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n                i++;\n                if (pd + i >= buf_end || pd[i] != '\\0') break;\n            } else {\n                break;\n            }\n        }\n    }\n\ndone:\n    return result;\n}\n\nstatic match_result\nmatch_wide_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info       = (cbs_t *)criterion;\n    const uint8_t *ascii_text = info->data;\n    size_t        textlen    = info->data_len;\n    match_result  result;\n    uint32_t      buf_len;\n    const uint8_t *pd, *buf_start, *buf_end;\n    uint32_t      i;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    result = MR_NOTMATCHED;\n    /* Has to be room to hold the sought data. */\n    if (textlen > fdata->cap_len) {\n        return result;\n    }\n    buf_len = fdata->cap_len;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    buf_end = buf_start + buf_len;\n    pd = buf_end - textlen;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte before the previous match start */\n        pd = buf_start + cf->search_pos - 1;\n    }\n    for (; pd < buf_end; pd++) {\n        pd = (uint8_t *)ws_memrchr(buf_start, ascii_text[0], pd - buf_start + 1);\n        if (pd == NULL) break;\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = pd[i];\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n                i++;\n                if (pd + i >= buf_end || pd[i] != '\\0') break;\n            } else {\n                break;\n            }\n        }\n    }\n\ndone:\n    return result;\n}\n\n/* Case insensitive match */\nstatic match_result\nmatch_wide_case(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info       = (cbs_t *)criterion;\n    const uint8_t *ascii_text = info->data;\n    size_t        textlen    = info->data_len;\n    ws_mempbrk_pattern *pattern = info->pattern;\n    match_result  result;\n    uint32_t      buf_len;\n    const uint8_t *pd, *buf_start, *buf_end;\n    uint32_t      i;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    ws_assert(pattern != NULL);\n\n    result = MR_NOTMATCHED;\n    buf_len = fdata->cap_len;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    buf_end = buf_start + buf_len;\n    pd = buf_start;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte past the previous match start */\n        pd += cf->search_pos + 1;\n    }\n    for (; pd < buf_end; pd++) {\n        pd = (uint8_t *)ws_mempbrk_exec(pd, buf_end - pd, pattern, &c_char);\n        if (pd == NULL) break;\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = g_ascii_toupper(pd[i]);\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n                i++;\n                if (pd + i >= buf_end || pd[i] != '\\0') break;\n            } else {\n                break;\n            }\n        }\n    }\n\ndone:\n    return result;\n}\n\n/* Case insensitive match */\nstatic match_result\nmatch_wide_case_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info       = (cbs_t *)criterion;\n    const uint8_t *ascii_text = info->data;\n    size_t        textlen    = info->data_len;\n    ws_mempbrk_pattern *pattern = info->pattern;\n    match_result  result;\n    uint32_t      buf_len;\n    const uint8_t *pd, *buf_start, *buf_end;\n    uint32_t      i;\n    uint8_t       c_char;\n    size_t        c_match    = 0;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    ws_assert(pattern != NULL);\n\n    result = MR_NOTMATCHED;\n    /* Has to be room to hold the sought data. */\n    if (textlen > fdata->cap_len) {\n        return result;\n    }\n    buf_len = fdata->cap_len;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    buf_end = buf_start + buf_len;\n    pd = buf_end - textlen;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte before the previous match start */\n        pd = buf_start + cf->search_pos - 1;\n    }\n    for (; pd >= buf_start; pd--) {\n        pd = (uint8_t *)ws_memrpbrk_exec(buf_start, pd - buf_start + 1, pattern, &c_char);\n        if (pd == NULL) break;\n        c_match = 0;\n        for (i = 0; pd + i < buf_end; i++) {\n            c_char = g_ascii_toupper(pd[i]);\n            if (c_char == ascii_text[c_match]) {\n                c_match++;\n                if (c_match == textlen) {\n                    result = MR_MATCHED;\n                    /* Save position and length for highlighting the field. */\n                    cf->search_pos = (uint32_t)(pd - buf_start);\n                    cf->search_len = (uint32_t)(i + 1);\n                    goto done;\n                }\n                i++;\n                if (pd + i >= buf_end || pd[i] != '\\0') break;\n            } else {\n                break;\n            }\n        }\n    }\n\ndone:\n    return result;\n}\n\nstatic match_result\nmatch_binary(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info        = (cbs_t *)criterion;\n    size_t        datalen     = info->data_len;\n    match_result  result;\n    const uint8_t *pd = NULL, *buf_start;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    result = MR_NOTMATCHED;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    size_t offset = 0;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte past the previous match start */\n        offset = cf->search_pos + 1;\n    }\n    if (offset < fdata->cap_len) {\n        pd = ws_memmem(buf_start + offset, fdata->cap_len - offset, info->data, datalen);\n    }\n    if (pd != NULL) {\n        result = MR_MATCHED;\n        /* Save position and length for highlighting the field. */\n        cf->search_pos = (uint32_t)(pd - buf_start);\n        cf->search_len = (uint32_t)datalen;\n    }\n\n    return result;\n}\n\nstatic match_result\nmatch_binary_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion)\n{\n    cbs_t        *info        = (cbs_t *)criterion;\n    size_t        datalen     = info->data_len;\n    match_result  result;\n    const uint8_t *pd = NULL, *buf_start;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    result = MR_NOTMATCHED;\n    buf_start = ws_buffer_start_ptr(&rec->data);\n    /* Has to be room to hold the sought data. */\n    if (datalen > fdata->cap_len) {\n        return result;\n    }\n    pd = buf_start + fdata->cap_len - datalen;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte before the previous match start */\n        pd = buf_start + cf->search_pos - 1;\n    }\n    for (; pd >= buf_start; pd--) {\n        pd = (uint8_t *)ws_memrchr(buf_start, info->data[0], pd - buf_start + 1);\n        if (pd == NULL) break;\n        if (memcmp(pd, info->data, datalen) == 0) {\n            result = MR_MATCHED;\n            /* Save position and length for highlighting the field. */\n            cf->search_pos = (uint32_t)(pd - buf_start);\n            cf->search_len = (uint32_t)datalen;\n            break;\n        }\n    }\n\n    return result;\n}\n\nstatic match_result\nmatch_regex(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion _U_)\n{\n    match_result  result = MR_NOTMATCHED;\n    size_t result_pos[2] = {0, 0};\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    size_t offset = 0;\n    if (cf->search_len || cf->search_pos) {\n        /* we want to start searching one byte past the previous match start */\n        offset = cf->search_pos + 1;\n    }\n    if (offset < fdata->cap_len) {\n        if (ws_regex_matches_pos(cf->regex,\n                                    (const char *)ws_buffer_start_ptr(&rec->data),\n                                    fdata->cap_len, offset,\n                                    result_pos)) {\n            //TODO: A chosen regex can match the empty string (zero length)\n            // which doesn't make a lot of sense for searching the packet bytes.\n            // Should we search with the PCRE2_NOTEMPTY option?\n            //TODO: Fix cast.\n            /* Save position and length for highlighting the field. */\n            cf->search_pos = (uint32_t)(result_pos[0]);\n            cf->search_len = (uint32_t)(result_pos[1] - result_pos[0]);\n            result = MR_MATCHED;\n        }\n    }\n    return result;\n}\n\nstatic match_result\nmatch_regex_reverse(capture_file *cf, frame_data *fdata,\n        wtap_rec *rec, void *criterion _U_)\n{\n    match_result  result = MR_NOTMATCHED;\n    size_t result_pos[2] = {0, 0};\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    size_t offset = fdata->cap_len - 1;\n    if (cf->search_pos) {\n        /* we want to start searching one byte before the previous match */\n        offset = cf->search_pos - 1;\n    }\n    for (; offset > 0; offset--) {\n        if (ws_regex_matches_pos(cf->regex,\n                                    (const char *)ws_buffer_start_ptr(&rec->data),\n                                    fdata->cap_len, offset,\n                                    result_pos)) {\n            //TODO: A chosen regex can match the empty string (zero length)\n            // which doesn't make a lot of sense for searching the packet bytes.\n            // Should we search with the PCRE2_NOTEMPTY option?\n            //TODO: Fix cast.\n            /* Save position and length for highlighting the field. */\n            cf->search_pos = (uint32_t)(result_pos[0]);\n            cf->search_len = (uint32_t)(result_pos[1] - result_pos[0]);\n            result = MR_MATCHED;\n            break;\n        }\n    }\n    return result;\n}\n\nbool\ncf_find_packet_dfilter(capture_file *cf, dfilter_t *sfcode,\n        search_direction dir, bool start_current)\n{\n    return find_packet(cf, match_dfilter, sfcode, dir, start_current);\n}\n\nbool\ncf_find_packet_dfilter_string(capture_file *cf, const char *filter,\n        search_direction dir)\n{\n    dfilter_t *sfcode;\n    bool       result;\n\n    if (!dfilter_compile(filter, &sfcode, NULL)) {\n        /*\n         * XXX - this shouldn't happen, as the filter string is machine\n         * generated\n         */\n        return false;\n    }\n    if (sfcode == NULL) {\n        /*\n         * XXX - this shouldn't happen, as the filter string is machine\n         * generated.\n         */\n        return false;\n    }\n    result = find_packet(cf, match_dfilter, sfcode, dir, true);\n    dfilter_free(sfcode);\n    return result;\n}\n\nstatic match_result\nmatch_dfilter(capture_file *cf, frame_data *fdata, wtap_rec *rec,\n        void *criterion)\n{\n    dfilter_t      *sfcode = (dfilter_t *)criterion;\n    epan_dissect_t  edt;\n    match_result    result;\n\n    /* Load the frame's data. */\n    if (!cf_read_record(cf, fdata, rec)) {\n        /* Attempt to get the packet failed. */\n        return MR_ERROR;\n    }\n\n    epan_dissect_init(&edt, cf->epan, true, false);\n    epan_dissect_prime_with_dfilter(&edt, sfcode);\n    epan_dissect_run(&edt, cf->cd_t, rec, fdata, NULL);\n    result = dfilter_apply_edt(sfcode, &edt) ? MR_MATCHED : MR_NOTMATCHED;\n    epan_dissect_cleanup(&edt);\n    return result;\n}\n\nbool\ncf_find_packet_marked(capture_file *cf, search_direction dir)\n{\n    return find_packet(cf, match_marked, NULL, dir, true);\n}\n\nstatic match_result\nmatch_marked(capture_file *cf _U_, frame_data *fdata, wtap_rec *rec _U_,\n        void *criterion _U_)\n{\n    return fdata->marked ? MR_MATCHED : MR_NOTMATCHED;\n}\n\nbool\ncf_find_packet_time_reference(capture_file *cf, search_direction dir)\n{\n    return find_packet(cf, match_time_reference, NULL, dir, true);\n}\n\nstatic match_result\nmatch_time_reference(capture_file *cf _U_, frame_data *fdata, wtap_rec *rec _U_,\n        void *criterion _U_)\n{\n    return fdata->ref_time ? MR_MATCHED : MR_NOTMATCHED;\n}\n\nstatic bool\nfind_packet(capture_file *cf, ws_match_function match_function,\n        void *criterion, search_direction dir, bool start_current)\n{\n    frame_data  *start_fd;\n    uint32_t     framenum;\n    uint32_t     prev_framenum;\n    frame_data  *fdata;\n    wtap_rec     rec;\n    frame_data  *new_fd = NULL;\n    progdlg_t   *progbar = NULL;\n    GTimer      *prog_timer = g_timer_new();\n    int          count;\n    bool         wrap = prefs.gui_find_wrap;\n    bool         succeeded;\n    float        progbar_val;\n    char         status_str[100];\n    match_result result;\n\n    wtap_rec_init(&rec, 1514);\n\n    start_fd = start_current ? cf->current_frame : NULL;\n    if (start_fd != NULL)  {\n        prev_framenum = start_fd->num;\n    } else {\n        prev_framenum = 0;  /* No start packet selected. */\n        wrap = false;\n    }\n\n    /* Iterate through the list of packets, starting at the packet we've\n       picked, calling a routine to run the filter on the packet, see if\n       it matches, and stop if so.  */\n    count = 0;\n    framenum = prev_framenum;\n    if (framenum == 0 && dir == SD_BACKWARD) {\n        /* If we have no start packet selected, and we're going backwards,\n         * start at the end (even if wrap is off.)\n         */\n        framenum = cf->count + 1;\n    }\n\n    g_timer_start(prog_timer);\n    /* Progress so far. */\n    progbar_val = 0.0f;\n\n    cf->stop_flag = false;\n\n    for (;;) {\n        /* Create the progress bar if necessary.\n           We check on every iteration of the loop, so that it takes no\n           longer than the standard time to create it (otherwise, for a\n           large file, we might take considerably longer than that standard\n           time in order to get to the next progress bar step). */\n        if (progbar == NULL)\n            progbar = delayed_create_progress_dlg(cf->window, NULL, NULL,\n                    false, &cf->stop_flag, progbar_val);\n\n        /*\n         * Update the progress bar, but do it only after PROGBAR_UPDATE_INTERVAL\n         * has elapsed. Calling update_progress_dlg and packets_bar_update will\n         * likely trigger UI paint events, which might take a while depending on\n         * the platform and display. Reset our timer *after* painting.\n         */\n        if (g_timer_elapsed(prog_timer, NULL) > PROGBAR_UPDATE_INTERVAL) {\n            /* let's not divide by zero. I should never be started\n             * with count == 0, so let's assert that\n             */\n            ws_assert(cf->count > 0);\n\n            progbar_val = (float) count / cf->count;\n\n            snprintf(status_str, sizeof(status_str),\n                    \"%4u of %u packets\", count, cf->count);\n            update_progress_dlg(progbar, progbar_val, status_str);\n\n            g_timer_start(prog_timer);\n        }\n\n        if (cf->stop_flag) {\n            /* Well, the user decided to abort the search.  Go back to the\n               frame where we started.\n               XXX - This ends up selecting the start packet and reporting\n               \"success\". Perhaps new_fd should stay NULL? */\n            new_fd = start_fd;\n            break;\n        }\n\n        /* Go past the current frame. */\n        if (dir == SD_BACKWARD) {\n            /* Go on to the previous frame. */\n            if (framenum <= 1) {\n                /*\n                 * XXX - other apps have a bit more of a detailed message\n                 * for this, and instead of offering \"OK\" and \"Cancel\",\n                 * they offer things such as \"Continue\" and \"Cancel\";\n                 * we need an API for popping up alert boxes with\n                 * {Verb} and \"Cancel\".\n                 */\n\n                if (wrap) {\n                    statusbar_push_temporary_msg(\"Search reached the beginning. Continuing at end.\");\n                    framenum = cf->count;     /* wrap around */\n                    wrap = false;\n                } else {\n                    statusbar_push_temporary_msg(\"Search reached the beginning.\");\n                    framenum = prev_framenum; /* stay on previous packet */\n                }\n            } else\n                framenum--;\n        } else {\n            /* Go on to the next frame. */\n            if (framenum == cf->count) {\n                if (wrap) {\n                    statusbar_push_temporary_msg(\"Search reached the end. Continuing at beginning.\");\n                    framenum = 1;             /* wrap around */\n                    wrap = false;\n                } else {\n                    statusbar_push_temporary_msg(\"Search reached the end.\");\n                    framenum = prev_framenum; /* stay on previous packet */\n                }\n            } else\n                framenum++;\n        }\n\n        fdata = frame_data_sequence_find(cf->provider.frames, framenum);\n        count++;\n\n        /* Is this packet in the display? */\n        if (fdata && fdata->passed_dfilter) {\n            /* Yes.  Does it match the search criterion? */\n            result = (*match_function)(cf, fdata, &rec, criterion);\n            if (result == MR_ERROR) {\n                /* Error; our caller has reported the error.  Go back to the frame\n                   where we started.\n                   XXX - This ends up selecting the start packet and reporting\n                   \"success.\" Perhaps new_fd should stay NULL? */\n                new_fd = start_fd;\n                break;\n            } else if (result == MR_MATCHED) {\n                /* Yes.  Go to the new frame. */\n                new_fd = fdata;\n                break;\n            }\n            wtap_rec_reset(&rec);\n        }\n\n        if (fdata == start_fd) {\n            /* We're back to the frame we were on originally, and that frame\n               doesn't match the search filter.  The search failed. */\n            break;\n        }\n    }\n\n    /* We're done scanning the packets; destroy the progress bar if it\n       was created. */\n    if (progbar != NULL)\n        destroy_progress_dlg(progbar);\n    g_timer_destroy(prog_timer);\n\n    if (new_fd != NULL) {\n        /* We found a frame that's displayed and that matches.\n           Try to find and select the packet summary list row for that frame. */\n        bool found_row;\n\n        cf->search_in_progress = true;\n        found_row = packet_list_select_row_from_data(new_fd);\n        cf->search_in_progress = false;\n        if (!found_row) {\n            /* We didn't find a row corresponding to this frame.\n               This means that the frame isn't being displayed currently,\n               so we can't select it. */\n            cf->search_pos = 0; /* Reset the position */\n            cf->search_len = 0; /* Reset length */\n            simple_message_box(ESD_TYPE_INFO, NULL,\n                    \"The capture file is probably not fully dissected.\",\n                    \"End of capture exceeded.\");\n            succeeded = false; /* The search succeeded but we didn't find the row */\n        } else\n            succeeded = true; /* The search succeeded and we found the row */\n    } else\n        succeeded = false;   /* The search failed */\n    wtap_rec_cleanup(&rec);\n    return succeeded;\n}\n\nbool\ncf_goto_frame(capture_file *cf, unsigned fnumber, bool exact)\n{\n    frame_data *fdata;\n\n    if (cf == NULL || cf->provider.frames == NULL) {\n        /* we don't have a loaded capture file - fix for bugs 11810 & 11989 */\n        statusbar_push_temporary_msg(\"There is no file loaded\");\n        return false;   /* we failed to go to that packet */\n    }\n\n    fdata = frame_data_sequence_find(cf->provider.frames, fnumber);\n\n    if (fdata == NULL) {\n        /* we didn't find a packet with that packet number */\n        statusbar_push_temporary_msg(\"There is no packet number %u.\", fnumber);\n        return false;   /* we failed to go to that packet */\n    }\n    if (!fdata->passed_dfilter) {\n        /* that packet currently isn't displayed */\n        /* XXX - add it to the set of displayed packets? */\n        if (cf->first_displayed == 0 || exact) {\n            /* We only want that exact frame, or no frames are displayed. */\n            statusbar_push_temporary_msg(\"Packet number %u isn't displayed.\", fnumber);\n            return false;   /* we failed to go to that packet */\n        }\n        if (fdata->prev_dis_num == 0) {\n            /* There is no previous displayed frame, so this frame is\n             * before the first displayed frame. Go to the first line,\n             * which is the closest frame.\n             */\n            fdata = NULL; /* This will select the first row. */\n            statusbar_push_temporary_msg(\"Packet number %u isn't displayed, going to the first displayed packet, %u.\", fnumber, cf->first_displayed);\n        } else {\n            uint32_t delta = fnumber - fdata->prev_dis_num;\n            /* The next displayed frame might be closer, we can do an\n             * O(log n) binary search for the earliest displayed frame\n             * in the open interval (fnumber, fnumber + delta).\n             *\n             * This is possibly overkill, we could just go to the previous\n             * displayed frame.\n             */\n            frame_data *fdata2;\n            uint32_t lower_bound = fnumber + 1;\n            uint32_t upper_bound = fnumber + delta - 1;\n            bool found = false;\n            while (lower_bound <= upper_bound) {\n                uint32_t middle = (lower_bound + upper_bound) / 2;\n                fdata2 = frame_data_sequence_find(cf->provider.frames, middle);\n                if (fdata2 == NULL) {\n                    /* We don't have a frame of that number, so search before it. */\n                    upper_bound = middle - 1;\n                    continue;\n                }\n                /* We have a frame of that number. What's the displayed\n                 * frame before it? */\n                if (fdata2->prev_dis_num > fnumber) {\n                    /* The previous frame that passed the filter is also after\n                     * our target, so our answer is no later than that.\n                     */\n                    upper_bound = fdata2->prev_dis_num;\n                } else {\n                    /* The previous displayed frame is before fnumber.\n                     * (We already know fnumber itself is not displayed.)\n                     * Is this frame itself displayed?\n                     */\n                    if (fdata2->passed_dfilter) {\n                        /* Yes. So this is our answer. */\n                        found = true;\n                        break;\n                    }\n                    /* No. So our answer, if any, is after this frame. */\n                    lower_bound = middle + 1;\n                }\n            }\n            if (found) {\n                fdata = fdata2;\n                statusbar_push_temporary_msg(\"Packet number %u isn't displayed, going to the next displayed packet, %u.\", fnumber, fdata->num);\n            } else {\n                statusbar_push_temporary_msg(\"Packet number %u isn't displayed, going to the previous displayed packet, %u.\", fnumber, fdata->prev_dis_num);\n                fdata = frame_data_sequence_find(cf->provider.frames, fdata->prev_dis_num);\n            }\n        }\n    }\n\n    if (!packet_list_select_row_from_data(fdata)) {\n        /* We didn't find a row corresponding to this frame.\n           This means that the frame isn't being displayed currently,\n           so we can't select it. */\n        simple_message_box(ESD_TYPE_INFO, NULL,\n                \"The capture file is probably not fully dissected.\",\n                \"End of capture exceeded.\");\n        return false;\n    }\n    return true;  /* we got to that packet */\n}\n\n/*\n * Go to frame specified by currently selected protocol tree item.\n */\nbool\ncf_goto_framenum(capture_file *cf)\n{\n    const header_field_info *hfinfo;\n    uint32_t           framenum;\n\n    if (cf->finfo_selected) {\n        hfinfo = cf->finfo_selected->hfinfo;\n        ws_assert(hfinfo);\n        if (hfinfo->type == FT_FRAMENUM) {\n            framenum = fvalue_get_uinteger(cf->finfo_selected->value);\n            if (framenum != 0) {\n                /* We probably only want to go to the exact match,\n                 * even though \"Go to Previous Packet in History\" exists.\n                 */\n                return cf_goto_frame(cf, framenum, true);\n            }\n        }\n    }\n\n    return false;\n}\n\n/* Select the packet on a given row. */\nvoid\ncf_select_packet(capture_file *cf, frame_data *fdata)\n{\n    epan_dissect_t *old_edt;\n\n    /* check the frame data struct pointer for this frame */\n    if (fdata == NULL) {\n        return;\n    }\n\n    /* Get the data in that frame. */\n    if (!cf_read_record(cf, fdata, &cf->rec)) {\n        return;\n    }\n\n    /* Record that this frame is the current frame. */\n    cf->current_frame = fdata;\n\n    /*\n     * The change to defer freeing the current epan_dissect_t was in\n     * commit a2bb94c3b33d53f42534aceb7cc67aab1d1fb1f9; to quote\n     * that commit's comment:\n     *\n     *   Clear GtkTreeStore before freeing edt\n     *\n     *   When building current data for packet details treeview we store two\n     *   things.\n     *      - Generated string with item label\n     *      - Pointer to node field_info structure\n     *\n     *   After epan_dissect_{free, cleanup} pointer to field_info node is no\n     *   longer valid so we should clear GtkTreeStore before freeing.\n     *\n     * XXX - we're no longer using GTK+; is there a way to ensure that\n     * *nothing* refers to any of the current frame information before\n     * we replace it?\n     */\n    old_edt = cf->edt;\n    /* Create the logical protocol tree. */\n    /* We don't need the columns here. */\n    cf->edt = epan_dissect_new(cf->epan, true, true);\n\n    tap_build_interesting(cf->edt);\n    epan_dissect_run(cf->edt, cf->cd_t, &cf->rec, cf->current_frame, NULL);\n\n    if (old_edt != NULL)\n        epan_dissect_free(old_edt);\n}\n\n/* Unselect the selected packet, if any. */\nvoid\ncf_unselect_packet(capture_file *cf)\n{\n    epan_dissect_t *old_edt = cf->edt;\n\n    /*\n     * See the comment in cf_select_packet() about deferring the freeing\n     * of the old cf->edt.\n     */\n    cf->edt = NULL;\n\n    /* No packet is selected. */\n    cf->current_frame = NULL;\n\n    /* Destroy the epan_dissect_t for the unselected packet. */\n    if (old_edt != NULL)\n        epan_dissect_free(old_edt);\n}\n\n/*\n * Mark a particular frame.\n */\nvoid\ncf_mark_frame(capture_file *cf, frame_data *frame)\n{\n    if (! frame->marked) {\n        frame->marked = true;\n        if (cf->count > cf->marked_count)\n            cf->marked_count++;\n    }\n}\n\n/*\n * Unmark a particular frame.\n */\nvoid\ncf_unmark_frame(capture_file *cf, frame_data *frame)\n{\n    if (frame->marked) {\n        frame->marked = false;\n        if (cf->marked_count > 0)\n            cf->marked_count--;\n    }\n}\n\n/*\n * Ignore a particular frame.\n */\nvoid\ncf_ignore_frame(capture_file *cf, frame_data *frame)\n{\n    if (! frame->ignored) {\n        frame->ignored = true;\n        if (cf->count > cf->ignored_count)\n            cf->ignored_count++;\n    }\n}\n\n/*\n * Un-ignore a particular frame.\n */\nvoid\ncf_unignore_frame(capture_file *cf, frame_data *frame)\n{\n    if (frame->ignored) {\n        frame->ignored = false;\n        if (cf->ignored_count > 0)\n            cf->ignored_count--;\n    }\n}\n\n/*\n * Modify the section comment.\n */\nvoid\ncf_update_section_comment(capture_file *cf, char *comment)\n{\n    wtap_block_t shb_inf;\n    char *shb_comment;\n\n    /* Get the first SHB. */\n    /* XXX - support multiple SHBs */\n    shb_inf = wtap_file_get_shb(cf->provider.wth, 0);\n\n    /* Get the first comment from the SHB. */\n    /* XXX - support multiple comments */\n    if (wtap_block_get_nth_string_option_value(shb_inf, OPT_COMMENT, 0, &shb_comment) != WTAP_OPTTYPE_SUCCESS) {\n        /* There's no comment - add one. */\n        wtap_block_add_string_option(shb_inf, OPT_COMMENT, comment, strlen(comment));\n    } else {\n        /* See if the comment has changed or not */\n        if (strcmp(shb_comment, comment) == 0) {\n            g_free(comment);\n            return;\n        }\n\n        /* The comment has changed, let's update it */\n        wtap_block_set_nth_string_option_value(shb_inf, OPT_COMMENT, 0, comment, strlen(comment));\n    }\n    /* Mark the file as having unsaved changes */\n    cf->unsaved_changes = true;\n}\n\n/*\n * Modify the section comments for a given section.\n */\nvoid\ncf_update_section_comments(capture_file *cf, unsigned shb_idx, char **comments)\n{\n    wtap_block_t shb_inf;\n    char *shb_comment;\n\n    shb_inf = wtap_file_get_shb(cf->provider.wth, shb_idx);\n    if (shb_inf == NULL) {\n        /* Shouldn't happen. XXX: Report it if it does? */\n        return;\n    }\n\n    unsigned n_comments = g_strv_length(comments);\n    unsigned i;\n    char* comment;\n\n    for (i = 0; i < n_comments; i++) {\n        comment = comments[i];\n        if (wtap_block_get_nth_string_option_value(shb_inf, OPT_COMMENT, i, &shb_comment) != WTAP_OPTTYPE_SUCCESS) {\n            /* There's no comment - add one. */\n            wtap_block_add_string_option_owned(shb_inf, OPT_COMMENT, comment);\n            cf->unsaved_changes = true;\n        } else {\n            /* See if the comment has changed or not */\n            if (strcmp(shb_comment, comment) != 0) {\n                /* The comment has changed, let's update it */\n                wtap_block_set_nth_string_option_value(shb_inf, OPT_COMMENT, 0, comment, strlen(comment));\n                cf->unsaved_changes = true;\n            }\n            g_free(comment);\n        }\n    }\n    /* We either transferred ownership of the comments or freed them\n     * above, so free the array of strings but not the strings themselves. */\n    g_free(comments);\n\n    /* If there are extra old comments, remove them. Start at the end. */\n    for (i = wtap_block_count_option(shb_inf, OPT_COMMENT); i > n_comments; i--) {\n        wtap_block_remove_nth_option_instance(shb_inf, OPT_COMMENT, i - 1);\n        cf->unsaved_changes = true;\n    }\n}\n\n/*\n * Get the packet block for a packet (record).\n * If the block has been edited, it returns the result of the edit,\n * otherwise it returns the block from the file.\n * NB. Caller must wtap_block_unref() the result when done.\n */\nwtap_block_t\ncf_get_packet_block(capture_file *cf, const frame_data *fd)\n{\n    /* If this block has been modified, fetch the modified version */\n    if (fd->has_modified_block)\n        return wtap_block_ref(cap_file_provider_get_modified_block(&cf->provider, fd));\n    else {\n        wtap_rec rec; /* Record information */\n        wtap_block_t block;\n\n        /* fetch record block */\n        wtap_rec_init(&rec, 1514);\n\n        if (!cf_read_record(cf, fd, &rec))\n        { /* XXX, what we can do here? */ }\n\n        /* rec.block is owned by the record, steal it before it is gone. */\n        block = wtap_block_ref(rec.block);\n\n        wtap_rec_cleanup(&rec);\n        return block;\n    }\n}\n\n/*\n * Update(replace) the block on a capture from a frame\n */\nbool\ncf_set_modified_block(capture_file *cf, frame_data *fd, const wtap_block_t new_block)\n{\n    wtap_block_t pkt_block = cf_get_packet_block(cf, fd);\n\n    /* It's possible to further modify the modified block \"in place\" by doing\n     * a call to cf_get_packet_block() that returns an already created modified\n     * block, modifying that, and calling this function.\n     * If the caller did that, then the block pointers will be equal.\n     */\n    if (pkt_block == new_block) {\n        /* No need to save anything here, the caller changes went right\n         * onto the block.\n         * Unfortunately we don't have a way to know how many comments were\n         * in the block before the caller modified it, so tell the caller\n         * it is its responsibility to update the comment count.\n         */\n        return false;\n    }\n    else {\n        if (pkt_block)\n            cf->packet_comment_count -= wtap_block_count_option(pkt_block, OPT_COMMENT);\n\n        if (new_block)\n            cf->packet_comment_count += wtap_block_count_option(new_block, OPT_COMMENT);\n\n        cap_file_provider_set_modified_block(&cf->provider, fd, new_block);\n\n        expert_update_comment_count(cf->packet_comment_count);\n    }\n\n    /* Either way, we have unsaved changes. */\n    wtap_block_unref(pkt_block);\n    cf->unsaved_changes = true;\n    return true;\n}\n\n/*\n * What types of comments does this capture file have?\n */\nuint32_t\ncf_comment_types(capture_file *cf)\n{\n    uint32_t comment_types = 0;\n\n    /*\n     * Does this file have any sections with at least one comment?\n     */\n    for (unsigned section_number = 0;\n            section_number < wtap_file_get_num_shbs(cf->provider.wth);\n            section_number++) {\n        wtap_block_t shb_inf;\n        char *shb_comment;\n\n        shb_inf = wtap_file_get_shb(cf->provider.wth, section_number);\n\n        /* Try to get the first comment from that SHB. */\n        if (wtap_block_get_nth_string_option_value(shb_inf, OPT_COMMENT, 0,\n                    &shb_comment) == WTAP_OPTTYPE_SUCCESS) {\n            /* We succeeded, so this file has at least one section comment. */\n            comment_types |= WTAP_COMMENT_PER_SECTION;\n\n            /* We don't need to search any more. */\n            break;\n        }\n    }\n    if (cf->packet_comment_count != 0)\n        comment_types |= WTAP_COMMENT_PER_PACKET;\n    return comment_types;\n}\n\n/*\n * Add a resolved address to this file's list of resolved addresses.\n */\nbool\ncf_add_ip_name_from_string(capture_file *cf, const char *addr, const char *name)\n{\n    /*\n     * XXX - support multiple resolved address lists, and add to the one\n     * attached to this file?\n     */\n    if (!add_ip_name_from_string(addr, name))\n        return false;\n\n    /* OK, we have unsaved changes. */\n    cf->unsaved_changes = true;\n    return true;\n}\n\ntypedef struct {\n    wtap_dumper *pdh;\n    const char  *fname;\n    int          file_type;\n    bool         export;\n} save_callback_args_t;\n\n/*\n * Save a capture to a file, in a particular format, saving either\n * all packets, all currently-displayed packets, or all marked packets.\n *\n * Returns true if it succeeds, false otherwise; if it fails, it pops\n * up a message box for the failure.\n */\nstatic bool\nsave_record(capture_file *cf, frame_data *fdata, wtap_rec *rec, void *argsp)\n{\n    save_callback_args_t *args = (save_callback_args_t *)argsp;\n    wtap_rec      new_rec;\n    int           err;\n    char         *err_info;\n    wtap_block_t pkt_block;\n\n    /* Copy the record information from what was read in from the file. */\n    new_rec = *rec;\n\n    /* Make changes based on anything that the user has done but that\n       hasn't been saved yet. */\n    if (fdata->has_modified_block)\n        pkt_block = cap_file_provider_get_modified_block(&cf->provider, fdata);\n    else\n        pkt_block = rec->block;\n    new_rec.block  = pkt_block;\n    new_rec.block_was_modified = fdata->has_modified_block ? true : false;\n\n    if (!nstime_is_zero(&fdata->shift_offset)) {\n        if (new_rec.presence_flags & WTAP_HAS_TS) {\n            nstime_add(&new_rec.ts, &fdata->shift_offset);\n        }\n    }\n\n    /* and save the packet */\n    if (!wtap_dump(args->pdh, &new_rec, ws_buffer_start_ptr(&rec->data), &err, &err_info)) {\n        report_cfile_write_failure(NULL, args->fname, err, err_info, fdata->num,\n                args->file_type);\n        return false;\n    }\n\n    /* If we are saving (i.e., replacing the current file with the one we're\n     * writing), then update the frame data to clear the shift offset.\n     * This keeps us from having to re-read the entire file.\n     * We could do this in rescan_file(), but\n     * 1) Ideally we shouldn't have to call rescan_file if all we're doing\n     * is changing the timestamps, since that shouldn't change the offsets.\n     * 2) The long term goal is to try to do the offset adjustment here\n     * instead of using rescan_file, which should be faster (#1257).\n     *\n     * If we're exporting to a different file, then don't do that.\n     */\n    if (!args->export && new_rec.presence_flags & WTAP_HAS_TS) {\n        nstime_set_zero(&fdata->shift_offset);\n    }\n\n    return true;\n}\n\n/*\n * Can this capture file be written out in any format using Wiretap\n * rather than by copying the raw data?\n */\nbool\ncf_can_write_with_wiretap(capture_file *cf)\n{\n    /* We don't care whether we support the comments in this file or not;\n       if we can't, we'll offer the user the option of discarding the\n       comments. */\n    return wtap_dump_can_write(cf->linktypes, 0);\n}\n\n/*\n * Should we let the user do a save?\n *\n * We should if:\n *\n *  the file has unsaved changes, and we can save it in some\n *  format through Wiretap\n *\n * or\n *\n *  the file is a temporary file and has no unsaved changes (so\n *  that \"saving\" it just means copying it).\n *\n * XXX - we shouldn't allow files to be edited if they can't be saved,\n * so cf->unsaved_changes should be true only if the file can be saved.\n *\n * We don't care whether we support the comments in this file or not;\n * if we can't, we'll offer the user the option of discarding the\n * comments.\n */\nbool\ncf_can_save(capture_file *cf)\n{\n    if (cf->unsaved_changes && wtap_dump_can_write(cf->linktypes, 0)) {\n        /* Saved changes, and we can write it out with Wiretap. */\n        return true;\n    }\n\n    if (cf->is_tempfile && !cf->unsaved_changes) {\n        /*\n         * Temporary file with no unsaved changes, so we can just do a\n         * raw binary copy.\n         */\n        return true;\n    }\n\n    /* Nothing to save. */\n    return false;\n}\n\n/*\n * Should we let the user do a \"save as\"?\n *\n * That's true if:\n *\n *  we can save it in some format through Wiretap\n *\n * or\n *\n *  the file is a temporary file and has no unsaved changes (so\n *  that \"saving\" it just means copying it).\n *\n * XXX - we shouldn't allow files to be edited if they can't be saved,\n * so cf->unsaved_changes should be true only if the file can be saved.\n *\n * We don't care whether we support the comments in this file or not;\n * if we can't, we'll offer the user the option of discarding the\n * comments.\n */\nbool\ncf_can_save_as(capture_file *cf)\n{\n    if (wtap_dump_can_write(cf->linktypes, 0)) {\n        /* We can write it out with Wiretap. */\n        return true;\n    }\n\n    if (cf->is_tempfile && !cf->unsaved_changes) {\n        /*\n         * Temporary file with no unsaved changes, so we can just do a\n         * raw binary copy.\n         */\n        return true;\n    }\n\n    /* Nothing to save. */\n    return false;\n}\n\n/*\n * Does this file have unsaved data?\n */\nbool\ncf_has_unsaved_data(capture_file *cf)\n{\n    /*\n     * If this is a temporary file, or a file with unsaved changes, it\n     * has unsaved data.\n     */\n    return (cf->is_tempfile && cf->count>0) || cf->unsaved_changes;\n}\n\n/*\n * Quick scan to find packet offsets.\n */\nstatic cf_read_status_t\nrescan_file(capture_file *cf, const char *fname, bool is_tempfile)\n{\n    wtap_rec             rec;\n    int                  err;\n    char                *err_info;\n    char                *name_ptr;\n    int64_t              data_offset;\n    progdlg_t           *progbar        = NULL;\n    GTimer              *prog_timer = g_timer_new();\n    int64_t              size;\n    float                progbar_val;\n    int64_t              start_time;\n    char                 status_str[100];\n    uint32_t             framenum;\n    frame_data          *fdata;\n\n    /* Close the old handle. */\n    wtap_close(cf->provider.wth);\n\n    /* Open the new file. */\n    /* XXX: this will go through all open_routines for a matching one. But right\n       now rescan_file() is only used when a file is being saved to a different\n       format than the original, and the user is not given a choice of which\n       reader to use (only which format to save it in), so doing this makes\n       sense for now. (XXX: Now it is also used when saving a changed file,\n       e.g. comments or time-shifted frames.) */\n    cf->provider.wth = wtap_open_offline(fname, WTAP_TYPE_AUTO, &err, &err_info, true);\n    if (cf->provider.wth == NULL) {\n        report_cfile_open_failure(fname, err, err_info);\n        return CF_READ_ERROR;\n    }\n\n    /* We're scanning a file whose contents should be the same as what\n       we had before, so we don't discard dissection state etc.. */\n    cf->f_datalen = 0;\n\n    /* Set the file name because we need it to set the follow stream filter.\n       XXX - is that still true?  We need it for other reasons, though,\n       in any case. */\n    if (cf->filename != NULL) {\n        g_free(cf->filename);\n    }\n    cf->filename = g_strdup(fname);\n\n    /* Indicate whether it's a permanent or temporary file. */\n    cf->is_tempfile = is_tempfile;\n\n    /* No user changes yet. */\n    cf->unsaved_changes = false;\n\n    /* Record the file's type and compression type. */\n    cf->cd_t        = wtap_file_type_subtype(cf->provider.wth);\n    cf->compression_type = wtap_get_compression_type(cf->provider.wth);\n    if (cf->linktypes != NULL) {\n        g_array_free(cf->linktypes, TRUE);\n    }\n    cf->linktypes = g_array_sized_new(FALSE, FALSE, (unsigned) sizeof(int), 1);\n\n    cf->snap      = wtap_snapshot_length(cf->provider.wth);\n\n    name_ptr = g_filename_display_basename(cf->filename);\n\n    cf_callback_invoke(cf_cb_file_rescan_started, cf);\n\n    /* Find the size of the file. */\n    size = wtap_file_size(cf->provider.wth, NULL);\n\n    g_timer_start(prog_timer);\n\n    cf->stop_flag = false;\n    start_time = g_get_monotonic_time();\n\n    framenum = 0;\n    wtap_rec_init(&rec, 1514);\n    while ((wtap_read(cf->provider.wth, &rec, &err, &err_info,\n                      &data_offset))) {\n        framenum++;\n        fdata = frame_data_sequence_find(cf->provider.frames, framenum);\n        if (G_LIKELY(fdata != NULL)) {\n            fdata->file_off = data_offset;\n        }\n        if (size >= 0) {\n            cf->f_datalen = wtap_read_so_far(cf->provider.wth);\n\n            /* Create the progress bar if necessary. */\n            if (progress_is_slow(progbar, prog_timer, size, cf->f_datalen)) {\n                progbar_val = calc_progbar_val(cf, size, cf->f_datalen, status_str, sizeof(status_str));\n                progbar = delayed_create_progress_dlg(cf->window, NULL, NULL,\n                        true, &cf->stop_flag, progbar_val);\n            }\n\n            /*\n             * Update the progress bar, but do it only after PROGBAR_UPDATE_INTERVAL\n             * has elapsed. Calling update_progress_dlg and packets_bar_update will\n             * likely trigger UI paint events, which might take a while depending on\n             * the platform and display. Reset our timer *after* painting.\n             */\n            if (progbar && g_timer_elapsed(prog_timer, NULL) > PROGBAR_UPDATE_INTERVAL) {\n                progbar_val = calc_progbar_val(cf, size, cf->f_datalen, status_str, sizeof(status_str));\n                /* update the packet bar content on the first run or frequently on very large files */\n                update_progress_dlg(progbar, progbar_val, status_str);\n                compute_elapsed(cf, start_time);\n                packets_bar_update();\n                g_timer_start(prog_timer);\n            }\n        }\n\n        if (cf->stop_flag) {\n            /* Well, the user decided to abort the rescan.  Sadly, as this\n               isn't a reread, recovering is difficult, so we'll just\n               close the current capture. */\n            break;\n        }\n\n        /* Add this packet's link-layer encapsulation type to cf->linktypes, if\n           it's not already there.\n           XXX - yes, this is O(N), so if every packet had a different\n           link-layer encapsulation type, it'd be O(N^2) to read the file, but\n           there are probably going to be a small number of encapsulation types\n           in a file. */\n        if (rec.rec_type == REC_TYPE_PACKET) {\n            cf_add_encapsulation_type(cf, rec.rec_header.packet_header.pkt_encap);\n        }\n        wtap_rec_reset(&rec);\n    }\n    wtap_rec_cleanup(&rec);\n\n    /* Free the display name */\n    g_free(name_ptr);\n\n    /* We're done reading the file; destroy the progress bar if it was created. */\n    if (progbar != NULL)\n        destroy_progress_dlg(progbar);\n    g_timer_destroy(prog_timer);\n\n    /* We're done reading sequentially through the file. */\n    cf->state = FILE_READ_DONE;\n\n    /* Close the sequential I/O side, to free up memory it requires. */\n    wtap_sequential_close(cf->provider.wth);\n\n    /* compute the time it took to load the file */\n    compute_elapsed(cf, start_time);\n\n    /* Set the file encapsulation type now; we don't know what it is until\n       we've looked at all the packets, as we don't know until then whether\n       there's more than one type (and thus whether it's\n       WTAP_ENCAP_PER_PACKET). */\n    cf->lnk_t = wtap_file_encap(cf->provider.wth);\n\n    cf_callback_invoke(cf_cb_file_rescan_finished, cf);\n\n    if (cf->stop_flag) {\n        /* Our caller will give up at this point. */\n        return CF_READ_ABORTED;\n    }\n\n    if (err != 0) {\n        /* Put up a message box noting that the read failed somewhere along\n           the line.  Don't throw out the stuff we managed to read, though,\n           if any. */\n        report_cfile_read_failure(NULL, err, err_info);\n        return CF_READ_ERROR;\n    } else\n        return CF_READ_OK;\n}\n\ncf_write_status_t\ncf_save_records(capture_file *cf, const char *fname, unsigned save_format,\n        wtap_compression_type compression_type,\n        bool discard_comments, bool dont_reopen)\n{\n    char            *err_info = \"Unknown error\";\n    char            *fname_new = NULL;\n    wtap_dumper     *pdh;\n    frame_data      *fdata;\n    addrinfo_lists_t *addr_lists;\n    unsigned         framenum;\n    int              err;\n    enum {\n        SAVE_WITH_MOVE,\n        SAVE_WITH_COPY,\n        SAVE_WITH_WTAP\n    }                    how_to_save;\n    save_callback_args_t callback_args;\n    callback_args.export = false;\n    bool needs_reload = false;\n\n    /* XXX caller should avoid saving the file while a read is pending\n     * (e.g. by delaying the save action) */\n    if (cf->read_lock) {\n        ws_warning(\"cf_save_records(\\\"%s\\\") while the file is being read, potential crash ahead\", fname);\n    }\n\n    cf_callback_invoke(cf_cb_file_save_started, (void *)fname);\n\n    addr_lists = get_addrinfo_list();\n\n    if (save_format == cf->cd_t && compression_type == cf->compression_type\n            && !discard_comments && !cf->unsaved_changes\n            && (wtap_addrinfo_list_empty(addr_lists) || wtap_file_type_subtype_supports_block(save_format, WTAP_BLOCK_NAME_RESOLUTION) == BLOCK_NOT_SUPPORTED)) {\n        /* We're saving in the format it's already in, and we're not discarding\n           comments, and there are no changes we have in memory that aren't saved\n           to the file, and we have no name resolution information to write or\n           the file format we're saving in doesn't support writing name\n           resolution information, so we can just move or copy the raw data. */\n\n        if (cf->is_tempfile) {\n            /* The file being saved is a temporary file from a live\n               capture, so it doesn't need to stay around under that name;\n               first, try renaming the capture buffer file to the new name.\n               This acts as a \"safe save\", in that, if the file already\n               exists, the existing file will be removed only if the rename\n               succeeds.\n\n               Sadly, on Windows, as we have the current capture file\n               open, even MoveFileEx() with MOVEFILE_REPLACE_EXISTING\n               (to cause the rename to remove an existing target), as\n               done by ws_stdio_rename() (ws_rename() is #defined to\n               be ws_stdio_rename() on Windows) will fail.\n\n               According to the MSDN documentation for CreateFile(), if,\n               when we open a capture file, we were to directly do a CreateFile(),\n               opening with FILE_SHARE_DELETE|FILE_SHARE_READ, and then\n               convert it to a file descriptor with _open_osfhandle(),\n               that would allow the file to be renamed out from under us.\n\n               However, that doesn't work in practice.  Perhaps the problem\n               is that the process doing the rename is the process that\n               has the file open. */\n#ifndef _WIN32\n            if (ws_rename(cf->filename, fname) == 0) {\n                /* That succeeded - there's no need to copy the source file. */\n                how_to_save = SAVE_WITH_MOVE;\n            } else {\n                if (errno == EXDEV) {\n                    /* They're on different file systems, so we have to copy the\n                       file. */\n                    how_to_save = SAVE_WITH_COPY;\n                } else {\n                    /* The rename failed, but not because they're on different\n                       file systems - put up an error message.  (Or should we\n                       just punt and try to copy?  The only reason why I'd\n                       expect the rename to fail and the copy to succeed would\n                       be if we didn't have permission to remove the file from\n                       the temporary directory, and that might be fixable - but\n                       is it worth requiring the user to go off and fix it?) */\n                    report_rename_failure(cf->filename, fname, errno);\n                    goto fail;\n                }\n            }\n#else\n            /* Windows - copy the file to its new location. */\n            how_to_save = SAVE_WITH_COPY;\n#endif\n        } else {\n            /* It's a permanent file, so we should copy it, and not remove the\n               original. */\n            how_to_save = SAVE_WITH_COPY;\n        }\n\n        if (how_to_save == SAVE_WITH_COPY) {\n            /* Copy the file, if we haven't moved it.  If we're overwriting\n               an existing file, we do it with a \"safe save\", by writing\n               to a new file and, if the write succeeds, renaming the\n               new file on top of the old file. */\n            if (file_exists(fname)) {\n                fname_new = ws_strdup_printf(\"%s~\", fname);\n                if (!copy_file_binary_mode(cf->filename, fname_new))\n                    goto fail;\n            } else {\n                if (!copy_file_binary_mode(cf->filename, fname))\n                    goto fail;\n            }\n        }\n    } else {\n        /* Either we're saving in a different format or we're saving changes,\n           such as added, modified, or removed comments, that haven't yet\n           been written to the underlying file; we can't do that by copying\n           or moving the capture file, we have to do it by writing the packets\n           out in Wiretap. */\n\n        wtap_dump_params params;\n        int encap;\n\n        how_to_save = SAVE_WITH_WTAP;\n        wtap_dump_params_init(&params, cf->provider.wth);\n\n        /* Determine what file encapsulation type we should use. */\n        encap = wtap_dump_required_file_encap_type(cf->linktypes);\n        params.encap = encap;\n\n        /* Use the snaplen from cf (XXX - does wtap_dump_params_init handle that?) */\n        params.snaplen = cf->snap;\n\n        if (file_exists(fname)) {\n            /* We're overwriting an existing file; write out to a new file,\n               and, if that succeeds, rename the new file on top of the\n               old file.  That makes this a \"safe save\", so that we don't\n               lose the old file if we have a problem writing out the new\n               file.  (If the existing file is the current capture file,\n               we *HAVE* to do that, otherwise we're overwriting the file\n               from which we're reading the packets that we're writing!) */\n            fname_new = ws_strdup_printf(\"%s~\", fname);\n            pdh = wtap_dump_open(fname_new, save_format, compression_type, &params,\n                    &err, &err_info);\n        } else {\n            pdh = wtap_dump_open(fname, save_format, compression_type, &params,\n                    &err, &err_info);\n        }\n        /* XXX idb_inf is documented to be used until wtap_dump_close. */\n        g_free(params.idb_inf);\n        params.idb_inf = NULL;\n\n        if (pdh == NULL) {\n            report_cfile_dump_open_failure(fname, err, err_info, save_format);\n            goto fail;\n        }\n\n        /* Add address resolution */\n        wtap_dump_set_addrinfo_list(pdh, addr_lists);\n\n        /* Iterate through the list of packets, processing all the packets. */\n        callback_args.pdh = pdh;\n        callback_args.fname = fname;\n        callback_args.file_type = save_format;\n        switch (process_specified_records(cf, NULL, \"Saving\", \"packets\",\n                    true, save_record, &callback_args, true)) {\n\n            case PSP_FINISHED:\n                /* Completed successfully. */\n                break;\n\n            case PSP_STOPPED:\n                /* The user decided to abort the saving.\n                   If we're writing to a temporary file, remove it.\n                   XXX - should we do so even if we're not writing to a\n                   temporary file? */\n                wtap_dump_close(pdh, NULL, &err, &err_info);\n                if (fname_new != NULL)\n                    ws_unlink(fname_new);\n                cf_callback_invoke(cf_cb_file_save_stopped, NULL);\n                wtap_dump_params_cleanup(&params);\n                return CF_WRITE_ABORTED;\n\n            case PSP_FAILED:\n                /* Error while saving.\n                   If we're writing to a temporary file, remove it. */\n                if (fname_new != NULL)\n                    ws_unlink(fname_new);\n                wtap_dump_close(pdh, NULL, &err, &err_info);\n                wtap_dump_params_cleanup(&params);\n                goto fail;\n        }\n\n        if (!wtap_dump_close(pdh, &needs_reload, &err, &err_info)) {\n            report_cfile_close_failure(fname, err, err_info);\n            wtap_dump_params_cleanup(&params);\n            goto fail;\n        }\n\n        wtap_dump_params_cleanup(&params);\n    }\n\n    if (fname_new != NULL) {\n        /* We wrote out to fname_new, and should rename it on top of\n           fname.  fname_new is now closed, so that should be possible even\n           on Windows.  However, on Windows, we first need to close whatever\n           file descriptors we have open for fname. */\n#ifdef _WIN32\n        wtap_fdclose(cf->provider.wth);\n#endif\n        /* Now do the rename. */\n        if (ws_rename(fname_new, fname) == -1) {\n            /* Well, the rename failed. */\n            report_rename_failure(fname_new, fname, errno);\n#ifdef _WIN32\n            /* Attempt to reopen the random file descriptor using the\n               current file's filename.  (At this point, the sequential\n               file descriptor is closed.) */\n            if (!wtap_fdreopen(cf->provider.wth, cf->filename, &err)) {\n                /* Oh, well, we're screwed. */\n                report_cfile_open_failure(cf->filename, err, NULL);\n            }\n#endif\n            goto fail;\n        }\n        g_free(fname_new);\n    }\n\n    /* If this was a temporary file, and we didn't do the save by doing\n       a move, so the tempoary file is still around under its old name,\n       remove it. */\n    if (cf->is_tempfile && how_to_save != SAVE_WITH_MOVE) {\n        /* If this fails, there's not much we can do, so just ignore errors. */\n        ws_unlink(cf->filename);\n    }\n\n    cf_callback_invoke(cf_cb_file_save_finished, NULL);\n    cf->unsaved_changes = false;\n\n    if (!dont_reopen) {\n        switch (how_to_save) {\n\n            case SAVE_WITH_MOVE:\n                /* We just moved the file, so the wtap structure refers to the\n                   new file, and all the information other than the filename\n                   and the \"is temporary\" status applies to the new file; just\n                   update that. */\n                g_free(cf->filename);\n                cf->filename = g_strdup(fname);\n                cf->is_tempfile = false;\n                cf_callback_invoke(cf_cb_file_fast_save_finished, cf);\n                break;\n\n            case SAVE_WITH_COPY:\n                /* We just copied the file, so all the information other than\n                   the file descriptors, the filename, and the \"is temporary\"\n                   status applies to the new file; just update that. */\n                wtap_fdclose(cf->provider.wth);\n                /* Attempt to reopen the random file descriptor using the\n                   new file's filename.  (At this point, the sequential\n                   file descriptor is closed.) */\n                if (!wtap_fdreopen(cf->provider.wth, fname, &err)) {\n                    report_cfile_open_failure(fname, err, err_info);\n                    cf_close(cf);\n                } else {\n                    g_free(cf->filename);\n                    cf->filename = g_strdup(fname);\n                    cf->is_tempfile = false;\n                }\n                cf_callback_invoke(cf_cb_file_fast_save_finished, cf);\n                break;\n\n            case SAVE_WITH_WTAP:\n                /* Open and read the file we saved to.\n\n                   XXX - this is somewhat of a waste; we already have the\n                   packets, all this gets us is updated file type information\n                   (which we could just stuff into \"cf\"), and having the new\n                   file be the one we have opened and from which we're reading\n                   the data, and it means we have to spend time opening and\n                   reading the file, which could be a significant amount of\n                   time if the file is large.\n\n                   If the capture-file-writing code were to return the\n                   seek offset of each packet it writes, we could save that\n                   in the frame_data structure for the frame, and just open\n                   the file without reading it again...\n\n                   ...as long as, for gzipped files, the process of writing\n                   out the file *also* generates the information needed to\n                   support fast random access to the compressed file. */\n                /* rescan_file will cause us to try all open_routines, so\n                   reset cfile's open_type */\n                cf->open_type = WTAP_TYPE_AUTO;\n                /* There are cases when SAVE_WITH_WTAP can result in new packets\n                   being written to the file, e.g ERF records\n                   In that case, we need to reload the whole file */\n                if(needs_reload) {\n                    if (cf_open(cf, fname, WTAP_TYPE_AUTO, false, &err) == CF_OK) {\n                        if (cf_read(cf, /*reloading=*/true) != CF_READ_OK) {\n                            /* The rescan failed; just close the file.  Either\n                               a dialog was popped up for the failure, so the\n                               user knows what happened, or they stopped the\n                               rescan, in which case they know what happened.  */\n                            /* XXX: This is inconsistent with normal open/reload behaviour. */\n                            cf_close(cf);\n                        }\n                    }\n                }\n                else {\n                    if (rescan_file(cf, fname, false) != CF_READ_OK) {\n                        /* The rescan failed; just close the file.  Either\n                           a dialog was popped up for the failure, so the\n                           user knows what happened, or they stopped the\n                           rescan, in which case they know what happened.  */\n                        cf_close(cf);\n                    }\n                }\n                break;\n        }\n\n        /* If we were told to discard the comments, do so. */\n        if (discard_comments) {\n            /* Remove SHB comment, if any. */\n            wtap_write_shb_comment(cf->provider.wth, NULL);\n\n            /* remove all user comments */\n            for (framenum = 1; framenum <= cf->count; framenum++) {\n                fdata = frame_data_sequence_find(cf->provider.frames, framenum);\n\n                // XXX: This also ignores non-comment options like verdict\n                fdata->has_modified_block = false;\n            }\n\n            if (cf->provider.frames_modified_blocks) {\n                g_tree_destroy(cf->provider.frames_modified_blocks);\n                cf->provider.frames_modified_blocks = NULL;\n            }\n\n            cf->packet_comment_count = 0;\n        }\n    }\n    return CF_WRITE_OK;\n\nfail:\n    if (fname_new != NULL) {\n        /* We were trying to write to a temporary file; get rid of it if it\n           exists.  (We don't care whether this fails, as, if it fails,\n           there's not much we can do about it.  I guess if it failed for\n           a reason other than \"it doesn't exist\", we could report an\n           error, so the user knows there's a junk file that they might\n           want to clean up.) */\n        ws_unlink(fname_new);\n        g_free(fname_new);\n    }\n    cf_callback_invoke(cf_cb_file_save_failed, NULL);\n    return CF_WRITE_ERROR;\n}\n\ncf_write_status_t\ncf_export_specified_packets(capture_file *cf, const char *fname,\n        packet_range_t *range, unsigned save_format,\n        wtap_compression_type compression_type)\n{\n    char                        *fname_new = NULL;\n    int                          err;\n    char                        *err_info;\n    wtap_dumper                 *pdh;\n    save_callback_args_t         callback_args;\n    wtap_dump_params             params;\n    int                          encap;\n\n    callback_args.export = true;\n    packet_range_process_init(range);\n\n    /* We're writing out specified packets from the specified capture\n       file to another file.  Even if all captured packets are to be\n       written, don't special-case the operation - read each packet\n       and then write it out if it's one of the specified ones. */\n\n    wtap_dump_params_init(&params, cf->provider.wth);\n\n    /* Determine what file encapsulation type we should use. */\n    encap = wtap_dump_required_file_encap_type(cf->linktypes);\n    params.encap = encap;\n\n    /* Use the snaplen from cf (XXX - does wtap_dump_params_init handle that?) */\n    params.snaplen = cf->snap;\n\n    if (file_exists(fname)) {\n        /* We're overwriting an existing file; write out to a new file,\n           and, if that succeeds, rename the new file on top of the\n           old file.  That makes this a \"safe save\", so that we don't\n           lose the old file if we have a problem writing out the new\n           file.  (If the existing file is the current capture file,\n           we *HAVE* to do that, otherwise we're overwriting the file\n           from which we're reading the packets that we're writing!) */\n        fname_new = ws_strdup_printf(\"%s~\", fname);\n        pdh = wtap_dump_open(fname_new, save_format, compression_type, &params,\n                &err, &err_info);\n    } else {\n        pdh = wtap_dump_open(fname, save_format, compression_type, &params,\n                &err, &err_info);\n    }\n    /* XXX idb_inf is documented to be used until wtap_dump_close. */\n    g_free(params.idb_inf);\n    params.idb_inf = NULL;\n\n    if (pdh == NULL) {\n        report_cfile_dump_open_failure(fname, err, err_info, save_format);\n        goto fail;\n    }\n\n    /* Add address resolution */\n    wtap_dump_set_addrinfo_list(pdh, get_addrinfo_list());\n\n    /* Iterate through the list of packets, processing the packets we were\n       told to process.\n\n       XXX - we've already called \"packet_range_process_init(range)\", but\n       \"process_specified_records()\" will do it again.  Fortunately,\n       that's harmless in this case, as we haven't done anything to\n       \"range\" since we initialized it. */\n    callback_args.pdh = pdh;\n    callback_args.fname = fname;\n    callback_args.file_type = save_format;\n    switch (process_specified_records(cf, range, \"Writing\", \"specified records\",\n                true, save_record, &callback_args, true)) {\n\n        case PSP_FINISHED:\n            /* Completed successfully. */\n            break;\n\n        case PSP_STOPPED:\n            /* The user decided to abort the saving.\n               If we're writing to a temporary file, remove it.\n               XXX - should we do so even if we're not writing to a\n               temporary file? */\n            wtap_dump_close(pdh, NULL, &err, &err_info);\n            if (fname_new != NULL) {\n                ws_unlink(fname_new);\n                g_free(fname_new);\n            }\n            wtap_dump_params_cleanup(&params);\n\n            return CF_WRITE_ABORTED;\n\n        case PSP_FAILED:\n            /* Error while saving. */\n            wtap_dump_close(pdh, NULL, &err, &err_info);\n            /*\n             * We don't report any error from closing; the error that caused\n             * process_specified_records() to fail has already been reported.\n             */\n            goto fail;\n    }\n\n    if (!wtap_dump_close(pdh, NULL, &err, &err_info)) {\n        report_cfile_close_failure(fname, err, err_info);\n        goto fail;\n    }\n\n    if (fname_new != NULL) {\n        /* We wrote out to fname_new, and should rename it on top of\n           fname; fname is now closed, so that should be possible even\n           on Windows.  Do the rename. */\n        if (ws_rename(fname_new, fname) == -1) {\n            /* Well, the rename failed. */\n            report_rename_failure(fname_new, fname, errno);\n            goto fail;\n        }\n        g_free(fname_new);\n    }\n    wtap_dump_params_cleanup(&params);\n\n    return CF_WRITE_OK;\n\nfail:\n    if (fname_new != NULL) {\n        /* We were trying to write to a temporary file; get rid of it if it\n           exists.  (We don't care whether this fails, as, if it fails,\n           there's not much we can do about it.  I guess if it failed for\n           a reason other than \"it doesn't exist\", we could report an\n           error, so the user knows there's a junk file that they might\n           want to clean up.) */\n        ws_unlink(fname_new);\n        g_free(fname_new);\n    }\n    wtap_dump_params_cleanup(&params);\n\n    return CF_WRITE_ERROR;\n}\n\n/* Reload the current capture file. */\ncf_status_t\ncf_reload(capture_file *cf)\n{\n    char     *filename;\n    bool      is_tempfile;\n    cf_status_t cf_status = CF_OK;\n    int       err;\n\n    if (cf->read_lock) {\n        ws_warning(\"Failing cf_reload(\\\"%s\\\") since a read is in progress\", cf->filename);\n        return CF_ERROR;\n    }\n\n    /* If the file could be opened, \"cf_open()\" calls \"cf_close()\"\n       to get rid of state for the old capture file before filling in state\n       for the new capture file.  \"cf_close()\" will remove the file if\n       it's a temporary file; we don't want that to happen (for one thing,\n       it'd prevent subsequent reopens from working).  Remember whether it's\n       a temporary file, mark it as not being a temporary file, and then\n       reopen it as the type of file it was.\n\n       Also, \"cf_close()\" will free \"cf->filename\", so we must make\n       a copy of it first. */\n    filename = g_strdup(cf->filename);\n    is_tempfile = cf->is_tempfile;\n    cf->is_tempfile = false;\n    if (cf_open(cf, filename, cf->open_type, is_tempfile, &err) == CF_OK) {\n        switch (cf_read(cf, /*reloading=*/true)) {\n\n            case CF_READ_OK:\n            case CF_READ_ERROR:\n                /* Just because we got an error, that doesn't mean we were unable\n                   to read any of the file; we handle what we could get from the\n                   file. */\n                break;\n\n            case CF_READ_ABORTED:\n                /* The user bailed out of re-reading the capture file; the\n                   capture file has been closed. */\n                break;\n        }\n    } else {\n        /* The open failed, so \"cf->is_tempfile\" wasn't set to \"is_tempfile\".\n           Instead, the file was left open, so we should restore \"cf->is_tempfile\"\n           ourselves.\n\n           XXX - change the menu?  Presumably \"cf_open()\" will do that;\n           make sure it does! */\n        cf->is_tempfile = is_tempfile;\n        cf_status = CF_ERROR;\n    }\n    /* \"cf_open()\" made a copy of the file name we handed it, so\n       we should free up our copy. */\n    g_free(filename);\n    return cf_status;\n}\n"
        },
        {
          "name": "file.h",
          "type": "blob",
          "size": 23.849609375,
          "content": "/** @file\n *\n * Definitions for file structures and routines\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#ifndef __FILE_H__\n#define __FILE_H__\n\n#include <wiretap/wtap.h>\n#include <epan/epan.h>\n#include <epan/print.h>\n#include <epan/fifo_string_cache.h>\n#include <ui/packet_range.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n/** Return values from functions that only can succeed or fail. */\ntypedef enum {\n    CF_OK,      /**< operation succeeded */\n    CF_ERROR    /**< operation got an error (function may provide err with details) */\n} cf_status_t;\n\n/** Return values from functions that read capture files. */\ntypedef enum {\n    CF_READ_OK,      /**< operation succeeded */\n    CF_READ_ERROR,   /**< operation got an error (function may provide err with details) */\n    CF_READ_ABORTED  /**< operation aborted by user */\n} cf_read_status_t;\n\n/** Return values from functions that write out packets. */\ntypedef enum {\n    CF_WRITE_OK,      /**< operation succeeded */\n    CF_WRITE_ERROR,   /**< operation got an error (function may provide err with details) */\n    CF_WRITE_ABORTED  /**< operation aborted by user */\n} cf_write_status_t;\n\n/** Return values from functions that print sets of packets. */\ntypedef enum {\n    CF_PRINT_OK,            /**< print operation succeeded */\n    CF_PRINT_OPEN_ERROR,    /**< print operation failed while opening printer */\n    CF_PRINT_WRITE_ERROR    /**< print operation failed while writing to the printer */\n} cf_print_status_t;\n\ntypedef enum {\n    cf_cb_file_opened,\n    cf_cb_file_closing,\n    cf_cb_file_closed,\n    cf_cb_file_read_started,\n    cf_cb_file_read_finished,\n    cf_cb_file_reload_started,\n    cf_cb_file_reload_finished,\n    cf_cb_file_rescan_started,\n    cf_cb_file_rescan_finished,\n    cf_cb_file_retap_started,\n    cf_cb_file_retap_finished,\n    cf_cb_file_merge_started, /* Qt only */\n    cf_cb_file_merge_finished, /* Qt only */\n    cf_cb_file_fast_save_finished,\n    cf_cb_file_save_started,\n    cf_cb_file_save_finished,\n    cf_cb_file_save_failed,\n    cf_cb_file_save_stopped\n} cf_cbs;\n\ntypedef void (*cf_callback_t) (int event, void *data, void *user_data);\n\ntypedef struct {\n    const char    *string;\n    size_t         string_len;\n    capture_file  *cf;\n    field_info    *finfo;\n    field_info    *prev_finfo;\n    bool           frame_matched;\n    bool           halt;\n} match_data;\n\n/**\n * Set maximum number of records per capture file.\n *\n * @param max_records maximum number of records to support.\n */\nextern void\ncf_set_max_records(unsigned max_records);\n\n/**\n * Add a capture file event callback.\n *\n * @param func The function to be called for each event.\n *             The function will be passed three parameters: The event type (event),\n *             event-dependent data (data), and user-supplied data (user_data).\n *             Event-dependent data may be a capture_file pointer, character pointer,\n *             or NULL.\n * @param user_data User-supplied data to pass to the callback. May be NULL.\n */\n\nextern void\ncf_callback_add(cf_callback_t func, void *user_data);\n\n/**\n * Remove a capture file event callback.\n *\n * @param func The function to be removed.\n * @param user_data User-supplied data. Must be the same value supplied to cf_callback_add.\n */\n\nextern void\ncf_callback_remove(cf_callback_t func, void *user_data);\n\n/**\n * Open a capture file.\n *\n * @param cf the capture file to be opened\n * @param fname the filename to be opened\n * @param type WTAP_TYPE_AUTO for automatic or index to direct open routine\n * @param is_tempfile is this a temporary file?\n * @param err error code\n * @return one of cf_status_t\n */\ncf_status_t cf_open(capture_file *cf, const char *fname, unsigned int type, bool is_tempfile, int *err);\n\n/**\n * Close a capture file.\n *\n * @param cf the capture file to be closed\n */\nvoid cf_close(capture_file *cf);\n\n/**\n * Reload a capture file.\n *\n * @param cf the capture file to be reloaded\n * @return one of cf_status_t\n */\ncf_status_t cf_reload(capture_file *cf);\n\n/**\n * Read all packets of a capture file into the internal structures.\n *\n * @param cf the capture file to be read\n * @param reloading reread asked for from cf_save_records()\n * @return one of cf_read_status_t\n */\ncf_read_status_t cf_read(capture_file *cf, bool reloading);\n\n/**\n * Read the information for a record.  It will pop up an alert box\n * if there's an error.\n *\n * @param cf the capture file from which to read the record\n * @param fdata the frame_data structure for the record in question\n * @param rec pointer to a wtap_rec structure to contain the\n *           record's information\n * @return true if the read succeeded, false if there was an error\n */\nbool cf_read_record(capture_file *cf, const frame_data *fdata,\n                    wtap_rec *rec);\n\n/** Same as cf_read_record() but does not pop alert box on error */\nbool cf_read_record_no_alert(capture_file *cf, const frame_data *fdata,\n                             wtap_rec *rec);\n\n\n/**\n * Read the information for the current record into a capture_file\n * structure's rec for the current record.\n * It will pop up an alert box if there's an error.\n *\n * @param cf the capture file from which to read the record\n * @return true if the read succeeded, false if there was an error\n */\nbool cf_read_current_record(capture_file *cf);\n\n/**\n * Read packets from the \"end\" of a capture file.\n *\n * @param cf the capture file to be read from\n * @param to_read the number of packets to read\n * @param rec pointer to wtap_rec to use when reading\n * @param err the error code, if an error had occurred\n * @return one of cf_read_status_t\n */\ncf_read_status_t cf_continue_tail(capture_file *cf, volatile int to_read,\n                                  wtap_rec *rec, int *err,\n                                  fifo_string_cache_t *frame_dup_cache, GChecksum *frame_cksum);\n\n/**\n * Fake reading packets from the \"end\" of a capture file.\n *\n * @param cf the capture file to be read from\n */\nvoid cf_fake_continue_tail(capture_file *cf);\n\n/**\n * Finish reading from \"end\" of a capture file.\n *\n * @param cf the capture file to be read from\n * @param rec pointer to wtap_rec to use when reading\n * @param err the error code, if an error had occurred\n * @return one of cf_read_status_t\n */\ncf_read_status_t cf_finish_tail(capture_file *cf, wtap_rec *rec,\n                                int *err,\n                                fifo_string_cache_t *frame_dup_cache, GChecksum *frame_cksum);\n\n/**\n * Determine whether this capture file (or a range of it) can be written\n * in any format using Wiretap rather than by copying the raw data.\n *\n * @param cf the capture file to check\n * @return true if it can be written, false if it can't\n */\nbool cf_can_write_with_wiretap(capture_file *cf);\n\n/**\n * Determine whether this capture file can be saved with a \"save\" operation;\n * if there's nothing unsaved, it can't.\n *\n * @param cf the capture file to check\n * @return true if it can be saved, false if it can't\n */\nbool cf_can_save(capture_file *cf);\n\n/**\n * Determine whether this capture file can be saved with a \"save as\" operation.\n *\n * @param cf the capture file to check\n * @return true if it can be saved, false if it can't\n */\nbool cf_can_save_as(capture_file *cf);\n\n/**\n * Determine whether this capture file has unsaved data.\n *\n * @param cf the capture file to check\n * @return true if it has unsaved data, false if it doesn't\n */\nbool cf_has_unsaved_data(capture_file *cf);\n\n/**\n * Save all packets in a capture file to a new file, and, if that succeeds,\n * make that file the current capture file.  If there's already a file with\n * that name, do a \"safe save\", writing to a temporary file in the same\n * directory and, if the write succeeds, renaming the new file on top of the\n * old file, so that if the write fails, the old file is still intact.\n *\n * @param cf the capture file to save to\n * @param fname the filename to save to\n * @param save_format the format of the file to save (libpcap, ...)\n * @param compression_type type of compression to use when writing, if any\n * @param discard_comments true if we should discard comments if the save\n * succeeds (because we saved in a format that doesn't support\n * comments)\n * @param dont_reopen true if it shouldn't reopen and make that file the\n * current capture file\n * @return one of cf_write_status_t\n */\ncf_write_status_t cf_save_records(capture_file * cf, const char *fname,\n                                  unsigned save_format,\n                                  wtap_compression_type compression_type,\n                                  bool discard_comments,\n                                  bool dont_reopen);\n\n/**\n * Export some or all packets from a capture file to a new file.  If there's\n * already a file with that name, do a \"safe save\", writing to a temporary\n * file in the same directory and, if the write succeeds, renaming the new\n * file on top of the old file, so that if the write fails, the old file is\n * still intact.\n *\n * @param cf the capture file to write to\n * @param fname the filename to write to\n * @param range the range of packets to write\n * @param save_format the format of the file to write (libpcap, ...)\n * @param compression_type type of compression to use when writing, if any\n * @return one of cf_write_status_t\n */\ncf_write_status_t cf_export_specified_packets(capture_file *cf,\n                                              const char *fname,\n                                              packet_range_t *range,\n                                              unsigned save_format,\n                                              wtap_compression_type compression_type);\n\n/**\n * Get a displayable name of the capture file.\n *\n * @param cf the capture file\n * @return the displayable name (must be g_free'd)\n */\nchar *cf_get_display_name(capture_file *cf);\n\n/**\n * Get a name that can be used to generate a file name from the\n * capture file name.  It's based on the displayable name, so it's\n * UTF-8; if it ends with a suffix that's used by a file type libwiretap\n * can read, we strip that suffix off.\n *\n * @param cf the capture file\n * @return the base name (must be g_free'd)\n */\nchar *cf_get_basename(capture_file *cf);\n\n/**\n * Set the source of the capture data for temporary files, e.g.\n * \"Interface eth0\" or \"Pipe from Pong\"\n *\n * @param cf the capture file\n * @param source the source description. this will be copied internally.\n */\nvoid cf_set_tempfile_source(capture_file *cf, char *source);\n\n/**\n * Get the source of the capture data for temporary files. Guaranteed to\n * return a non-null value. The returned value should not be freed.\n *\n * @param cf the capture file\n */\nconst char *cf_get_tempfile_source(capture_file *cf);\n\n/**\n * Get the number of packets in the capture file.\n *\n * @param cf the capture file\n * @return the number of packets in the capture file\n */\nint cf_get_packet_count(capture_file *cf);\n\n/**\n * Is this capture file a temporary file?\n *\n * @param cf the capture file\n * @return true if it's a temporary file, false otherwise\n */\nbool cf_is_tempfile(capture_file *cf);\n\n/**\n * Set flag, that this file is a tempfile.\n */\nvoid cf_set_tempfile(capture_file *cf, bool is_tempfile);\n\n/**\n * Set flag, if the number of packet drops while capturing are known or not.\n *\n * @param cf the capture file\n * @param drops_known true if the number of packet drops are known, false otherwise\n */\nvoid cf_set_drops_known(capture_file *cf, bool drops_known);\n\n/**\n * Set the number of packet drops while capturing.\n *\n * @param cf the capture file\n * @param drops the number of packet drops occurred while capturing\n */\nvoid cf_set_drops(capture_file *cf, uint32_t drops);\n\n/**\n * Get flag state, if the number of packet drops while capturing are known or not.\n *\n * @param cf the capture file\n * @return true if the number of packet drops are known, false otherwise\n */\nbool cf_get_drops_known(capture_file *cf);\n\n/**\n * Get the number of packet drops while capturing.\n *\n * @param cf the capture file\n * @return the number of packet drops occurred while capturing\n */\nuint32_t cf_get_drops(capture_file *cf);\n\n/**\n * Set the read filter.\n * @todo this shouldn't be required, remove it somehow\n *\n * @param cf the capture file\n * @param rfcode the readfilter\n */\nvoid cf_set_rfcode(capture_file *cf, dfilter_t *rfcode);\n\n/**\n * \"Display Filter\" packets in the capture file.\n *\n * @param cf the capture file\n * @param dfilter the display filter\n * @param force true if do in any case, false only if dfilter changed\n * @return one of cf_status_t\n */\ncf_status_t cf_filter_packets(capture_file *cf, char *dfilter, bool force);\n\n/**\n * Scan through all frame data and recalculate the ref time\n * without rereading the file.\n *\n * @param cf the capture file\n */\nvoid cf_reftime_packets(capture_file *cf);\n\n/**\n * Return the time it took to load the file (in msec).\n */\nunsigned long cf_get_computed_elapsed(capture_file *cf);\n\n/**\n * \"Something\" has changed, rescan all packets.\n *\n * @param cf the capture file\n */\nvoid cf_redissect_packets(capture_file *cf);\n\n/**\n * Rescan all packets and just run taps - don't reconstruct the display.\n *\n * @param cf the capture file\n * @return one of cf_read_status_t\n */\ncf_read_status_t cf_retap_packets(capture_file *cf);\n\n/* print_range, enum which frames should be printed */\ntypedef enum {\n    print_range_selected_only,    /* selected frame(s) only (currently only one) */\n    print_range_marked_only,      /* marked frames only */\n    print_range_all_displayed,    /* all frames currently displayed */\n    print_range_all_captured      /* all frames in capture */\n} print_range_e;\n\ntypedef struct {\n    print_stream_t *stream;       /* the stream to which we're printing */\n    print_format_e format;        /* plain text or PostScript */\n    bool to_file;             /* true if we're printing to a file */\n    char *file;                   /* file output pathname */\n    char *cmd;                    /* print command string (not win32) */\n    packet_range_t range;\n\n    bool print_summary;       /* true if we should print summary line. */\n    bool print_col_headings;  /* true if we should print column headings */\n    print_dissections_e print_dissections;\n    bool print_hex;           /* true if we should print hex data;\n                                   * false if we should print only if not dissected. */\n    unsigned hexdump_options;        /* Hexdump options if print_hex is true. */\n    bool print_formfeed;      /* true if a formfeed should be printed before\n                                   * each new packet */\n} print_args_t;\n\n/**\n * Print the capture file.\n *\n * @param cf the capture file\n * @param print_args the arguments what and how to print\n * @param show_progress_bar true if a progress bar is to be shown\n * @return one of cf_print_status_t\n */\ncf_print_status_t cf_print_packets(capture_file *cf, print_args_t *print_args,\n                                   bool show_progress_bar);\n\n/**\n * Print (export) the capture file into PDML format.\n *\n * @param cf the capture file\n * @param print_args the arguments what and how to export\n * @return one of cf_print_status_t\n */\ncf_print_status_t cf_write_pdml_packets(capture_file *cf, print_args_t *print_args);\n\n/**\n * Print (export) the capture file into PSML format.\n *\n * @param cf the capture file\n * @param print_args the arguments what and how to export\n * @return one of cf_print_status_t\n */\ncf_print_status_t cf_write_psml_packets(capture_file *cf, print_args_t *print_args);\n\n/**\n * Print (export) the capture file into CSV format.\n *\n * @param cf the capture file\n * @param print_args the arguments what and how to export\n * @return one of cf_print_status_t\n */\ncf_print_status_t cf_write_csv_packets(capture_file *cf, print_args_t *print_args);\n\n/**\n * Print (export) the capture file into C Arrays format.\n *\n * @param cf the capture file\n * @param print_args the arguments what and how to export\n * @return one of cf_print_status_t\n */\ncf_print_status_t cf_write_carrays_packets(capture_file *cf, print_args_t *print_args);\n\n/**\n * Print (export) the capture file into JSON format.\n *\n * @param cf the capture file\n * @param print_args the arguments what and how to export\n * @return one of cf_print_status_t\n */\ncf_print_status_t cf_write_json_packets(capture_file *cf, print_args_t *print_args);\n\n/**\n * Find packet with a protocol tree item that contains a specified text string.\n *\n * @param cf the capture file\n * @param string the string to find\n * @param dir direction in which to search\n * @param multiple whether to look for the next occurrence of the same string\n * in the current packet, or to only match once per frame\n * @return true if a packet was found, false otherwise\n */\nbool cf_find_packet_protocol_tree(capture_file *cf, const char *string,\n                                      search_direction dir, bool multiple);\n\n/**\n * Find field with a label that contains the text string cfile->sfilter in\n * a protocol tree.\n *\n * @param cf the capture file\n * @param tree the protocol tree\n * @return The first field in the tree that matched the string if found, NULL otherwise\n */\nextern field_info* cf_find_string_protocol_tree(capture_file *cf, proto_tree *tree);\n\n/**\n * Find packet whose summary line contains a specified text string.\n *\n * @param cf the capture file\n * @param string the string to find\n * @param dir direction in which to search\n * @return true if a packet was found, false otherwise\n */\nbool cf_find_packet_summary_line(capture_file *cf, const char *string,\n                                     search_direction dir);\n\n/**\n * Find packet whose data contains a specified byte string.\n *\n * @param cf the capture file\n * @param string the string to find\n * @param string_size the size of the string to find\n * @param dir direction in which to search\n * @param multiple whether to look for the next occurrence of the same string\n * in the current packet, or to only match once per frame\n * @return true if a packet was found, false otherwise\n */\nbool cf_find_packet_data(capture_file *cf, const uint8_t *string,\n                             size_t string_size, search_direction dir,\n                             bool multiple);\n\n/**\n * Find packet that matches a compiled display filter.\n *\n * @param cf the capture file\n * @param sfcode the display filter to match\n * @param dir direction in which to search\n * @param start_current whether to start searching from the current frame\n * @return true if a packet was found, false otherwise\n */\nbool cf_find_packet_dfilter(capture_file *cf, dfilter_t *sfcode,\n                                search_direction dir, bool start_current);\n\n/**\n * Find packet that matches a display filter given as a text string.\n *\n * @param cf the capture file\n * @param filter the display filter to match\n * @param dir direction in which to search\n * @return true if a packet was found, false otherwise\n */\nbool\ncf_find_packet_dfilter_string(capture_file *cf, const char *filter,\n                              search_direction dir);\n\n/**\n * Find marked packet.\n *\n * @param cf the capture file\n * @param dir direction in which to search\n * @return true if a packet was found, false otherwise\n */\nbool cf_find_packet_marked(capture_file *cf, search_direction dir);\n\n/**\n * Find time-reference packet.\n *\n * @param cf the capture file\n * @param dir direction in which to search\n * @return true if a packet was found, false otherwise\n */\nbool cf_find_packet_time_reference(capture_file *cf, search_direction dir);\n\n/**\n * GoTo Packet with the given row.\n *\n * @param cf the capture file\n * @param row the row to go to\n * @param exact if true, fail if the row exists and is filtered (not displayed)\n * if false, go to the nearest displayed packet instead\n * @return true if this row exists, false otherwise\n */\nbool cf_goto_frame(capture_file *cf, unsigned row, bool exact);\n\n/**\n * Go to frame specified by currently selected protocol tree field.\n * (Go To Corresponding Packet)\n * @todo this is ugly and should be improved!\n *\n * @param cf the capture file\n * @return true if this packet exists, false otherwise\n */\nbool cf_goto_framenum(capture_file *cf);\n\n/**\n * Select the packet in the given row.\n *\n * @param cf the capture file\n * @param frame the frame to be selected\n */\nvoid cf_select_packet(capture_file *cf, frame_data *frame);\n\n/**\n * Unselect all packets, if any.\n *\n * @param cf the capture file\n */\nvoid cf_unselect_packet(capture_file *cf);\n\n/**\n * Mark a particular frame in a particular capture.\n *\n * @param cf the capture file\n * @param frame the frame to be marked\n */\nvoid cf_mark_frame(capture_file *cf, frame_data *frame);\n\n/**\n * Unmark a particular frame in a particular capture.\n *\n * @param cf the capture file\n * @param frame the frame to be unmarked\n */\nvoid cf_unmark_frame(capture_file *cf, frame_data *frame);\n\n/**\n * Ignore a particular frame in a particular capture.\n *\n * @param cf the capture file\n * @param frame the frame to be ignored\n */\nvoid cf_ignore_frame(capture_file *cf, frame_data *frame);\n\n/**\n * Unignore a particular frame in a particular capture.\n *\n * @param cf the capture file\n * @param frame the frame to be unignored\n */\nvoid cf_unignore_frame(capture_file *cf, frame_data *frame);\n\n/**\n * Merge two or more capture files into a temporary file.\n * @todo is this the right place for this function? It doesn't have to do a lot with capture_file.\n *\n * @param pd_window Window pointer suitable for use by delayed_create_progress_dlg.\n * @param out_filenamep Points to a pointer that's set to point to the\n *        pathname of the temporary file; it's allocated with g_malloc()\n * @param in_file_count the number of input files to merge\n * @param in_filenames array of input filenames\n * @param file_type the output filetype\n * @param do_append false to merge chronologically, true simply append\n * @return one of cf_status_t\n */\ncf_status_t\ncf_merge_files_to_tempfile(void *pd_window, const char *temp_dir, char **out_filenamep,\n                           int in_file_count, const char *const *in_filenames,\n                           int file_type, bool do_append);\n\n/**\n * Update(replace) the comment on a capture from the SHB data block\n * XXX - should support multiple sections.\n *\n * @param cf the capture file\n * @param comment the string replacing the old comment\n */\nvoid cf_update_section_comment(capture_file *cf, char *comment);\n\n/**\n * Update(replace) the comments on a capture from the SHB data block\n *\n * @param cf the capture file\n * @param shb_idx the index of the SHB (0-indexed)\n * @param comments a NULL-terminated string array of comments. The function\n * takes ownership of the string array and frees it and the contents.\n */\nvoid cf_update_section_comments(capture_file *cf, unsigned shb_idx, char **comments);\n\n/*\n * Get the packet block for a packet (record).\n * If the block has been edited, it returns the result of the edit,\n * otherwise it returns the block from the file.\n *\n * @param cf the capture file\n * @param fd the frame_data structure for the frame\n * @returns A block (use wtap_block_unref to free) or NULL if there is none.\n */\nwtap_block_t cf_get_packet_block(capture_file *cf, const frame_data *fd);\n\n/**\n * Update(replace) the block on a capture from a frame\n *\n * @param cf the capture file\n * @param fd the frame_data structure for the frame\n * @param new_block the block replacing the old block\n *\n * @return true if the block is modified for the first time. false if\n * the block was already modified before, in which case the caller is\n * responsible for updating the comment count.\n */\nbool cf_set_modified_block(capture_file *cf, frame_data *fd, const wtap_block_t new_block);\n\n/**\n * What types of comments does this file have?\n *\n * @param cf the capture file\n * @return bitset of WTAP_COMMENT_ values\n */\nuint32_t cf_comment_types(capture_file *cf);\n\n/**\n * Add a resolved address to this file's list of resolved addresses.\n *\n * @param cf the capture file\n * @param addr a string representing an IPv4 or IPv6 address\n * @param name a string containing a name corresponding to that address\n * @return true if it succeeds, false if not\n */\nbool cf_add_ip_name_from_string(capture_file *cf, const char *addr, const char *name);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* file.h */\n"
        },
        {
          "name": "file_packet_provider.c",
          "type": "blob",
          "size": 3.5810546875,
          "content": "/* file_packet_provider_data.c\n * Routines for a packet_provider_data for packets from a file.\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n#include \"config.h\"\n\n#include <stdint.h>\n#include <glib.h>\n#include \"cfile.h\"\n\nconst nstime_t *\ncap_file_provider_get_frame_ts(struct packet_provider_data *prov, uint32_t frame_num)\n{\n    const frame_data *fd = NULL;\n\n    if (prov->ref && prov->ref->num == frame_num) {\n        fd = prov->ref;\n    } else if (prov->prev_dis && prov->prev_dis->num == frame_num) {\n        fd = prov->prev_dis;\n    } else if (prov->prev_cap && prov->prev_cap->num == frame_num) {\n        fd = prov->prev_cap;\n    } else if (prov->frames) {\n        fd = frame_data_sequence_find(prov->frames, frame_num);\n    }\n\n    return (fd && fd->has_ts) ? &fd->abs_ts : NULL;\n}\n\nstatic int\nframe_cmp(const void *a, const void *b, void *user_data _U_)\n{\n  const frame_data *fdata1 = (const frame_data *) a;\n  const frame_data *fdata2 = (const frame_data *) b;\n\n  return (fdata1->num < fdata2->num) ? -1 :\n    (fdata1->num > fdata2->num) ? 1 :\n    0;\n}\n\nconst char *\ncap_file_provider_get_interface_name(struct packet_provider_data *prov, uint32_t interface_id, unsigned section_number)\n{\n  wtapng_iface_descriptions_t *idb_info;\n  wtap_block_t wtapng_if_descr = NULL;\n  char* interface_name;\n\n  idb_info = wtap_file_get_idb_info(prov->wth);\n\n  unsigned gbl_iface_id = wtap_file_get_shb_global_interface_id(prov->wth, section_number, interface_id);\n\n  if (gbl_iface_id < idb_info->interface_data->len)\n    wtapng_if_descr = g_array_index(idb_info->interface_data, wtap_block_t, gbl_iface_id);\n\n  g_free(idb_info);\n\n  if (wtapng_if_descr) {\n    if (wtap_block_get_string_option_value(wtapng_if_descr, OPT_IDB_NAME, &interface_name) == WTAP_OPTTYPE_SUCCESS)\n      return interface_name;\n    if (wtap_block_get_string_option_value(wtapng_if_descr, OPT_IDB_DESCRIPTION, &interface_name) == WTAP_OPTTYPE_SUCCESS)\n      return interface_name;\n    if (wtap_block_get_string_option_value(wtapng_if_descr, OPT_IDB_HARDWARE, &interface_name) == WTAP_OPTTYPE_SUCCESS)\n      return interface_name;\n  }\n  return \"unknown\";\n}\n\nconst char *\ncap_file_provider_get_interface_description(struct packet_provider_data *prov, uint32_t interface_id, unsigned section_number)\n{\n  wtapng_iface_descriptions_t *idb_info;\n  wtap_block_t wtapng_if_descr = NULL;\n  char* interface_name;\n\n  idb_info = wtap_file_get_idb_info(prov->wth);\n\n  interface_id = wtap_file_get_shb_global_interface_id(prov->wth, section_number, interface_id);\n\n  if (interface_id < idb_info->interface_data->len)\n    wtapng_if_descr = g_array_index(idb_info->interface_data, wtap_block_t, interface_id);\n\n  g_free(idb_info);\n\n  if (wtapng_if_descr) {\n    if (wtap_block_get_string_option_value(wtapng_if_descr, OPT_IDB_DESCRIPTION, &interface_name) == WTAP_OPTTYPE_SUCCESS)\n      return interface_name;\n  }\n  return NULL;\n}\n\nwtap_block_t\ncap_file_provider_get_modified_block(struct packet_provider_data *prov, const frame_data *fd)\n{\n  if (prov->frames_modified_blocks)\n     return (wtap_block_t)g_tree_lookup(prov->frames_modified_blocks, fd);\n\n  /* ws_warning? */\n  return NULL;\n}\n\nvoid\ncap_file_provider_set_modified_block(struct packet_provider_data *prov, frame_data *fd, const wtap_block_t new_block)\n{\n  if (!prov->frames_modified_blocks)\n    prov->frames_modified_blocks = g_tree_new_full(frame_cmp, NULL, NULL, (GDestroyNotify)wtap_block_unref);\n\n  /* insert new packet block */\n  g_tree_replace(prov->frames_modified_blocks, fd, (void *)new_block);\n\n  fd->has_modified_block = 1;\n}\n"
        },
        {
          "name": "fileset.c",
          "type": "blob",
          "size": 12.0634765625,
          "content": "/* fileset.c\n * Routines for handling file sets\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n\n#ifdef HAVE_SYS_WAIT_H\n# include <sys/wait.h>\n#endif\n\n#include <stdio.h>\n#include <string.h>\n\n#include <glib.h>\n\n#include <wsutil/file_util.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/ws_assert.h>\n\n#include <wiretap/wtap.h>\n\n#include <epan/strutil.h>\n\n#include \"fileset.h\"\n\ntypedef struct _fileset {\n    GList   *entries;\n    char    *dirname;\n} fileset;\n\n/*\n * This is the fileset's global data.\n *\n * XXX This should probably be per-main-window instead of global.\n */\nstatic fileset set;\n\n/*\n * Given a stat structure, get the creation time of the file if available,\n * or 0 if not.\n */\n#ifdef _WIN32\n  /* Microsoft's documentation says this is the creation time */\n  #define ST_CREATE_TIME(statb) ((statb).st_ctime)\n#else /* _WIN32 */\n  /* UN*X - do we have a creation time? */\n  #if defined(HAVE_STRUCT_STAT_ST_BIRTHTIME)\n    #define ST_CREATE_TIME(statb) ((statb).st_birthtime)\n  #elif defined(HAVE_STRUCT_STAT___ST_BIRTHTIME)\n    #define ST_CREATE_TIME(statb) ((statb).__st_birthtime)\n  #else /* nothing */\n    #define ST_CREATE_TIME(statb) (0)\n  #endif /* creation time on UN*X */\n#endif /* _WIN32 */\n\n/* is this a probable file of a file set (does the naming pattern match)? */\nfileset_match_t\nfileset_filename_match_pattern(const char *fname, char **prefix, char **suffix, char **time)\n{\n    char        *sfx;\n    char        *filename;\n    fileset_match_t ret = FILESET_NO_MATCH;\n    static char *pattern = \"(?P<prefix>.*)_\\\\d{5}_(?P<time>\\\\d{14})$\";\n    static char *pattern2 = \"(?P<prefix>.*)_(?P<time>\\\\d{14})_\\\\d{5}$\";\n    static GRegex *regex = NULL;\n    static GRegex *regex2 = NULL;\n\n    if (regex == NULL) {\n        GError *gerr = NULL;\n        regex = g_regex_new(pattern,\n                        (GRegexCompileFlags)(G_REGEX_OPTIMIZE | G_REGEX_ANCHORED),\n                        G_REGEX_MATCH_ANCHORED, &gerr);\n        if (gerr) {\n                ws_warning(\"failed to compile regex: %s\", gerr->message);\n                g_error_free(gerr);\n                regex = NULL;\n                return ret;\n        }\n    }\n\n    if (regex2 == NULL) {\n        GError *gerr = NULL;\n        regex2 = g_regex_new(pattern2,\n                        (GRegexCompileFlags)(G_REGEX_OPTIMIZE | G_REGEX_ANCHORED),\n                        G_REGEX_MATCH_ANCHORED, &gerr);\n        if (gerr) {\n                ws_warning(\"failed to compile regex: %s\", gerr->message);\n                g_error_free(gerr);\n                regex2 = NULL;\n                return ret;\n        }\n    }\n\n    /* d:\\dir1\\test_00001_20050418010750.cap */\n    filename = g_path_get_basename(fname);\n\n    /* test_00001_20050418010750.cap */\n    sfx = strrchr(filename, '.');\n    if (sfx != NULL) {\n        *sfx = '\\0';\n        GSList *compression_type_extensions = wtap_get_all_compression_type_extensions_list();\n        char *ext = g_ascii_strdown(sfx + 1, -1);\n        for (GSList *compression_extension = compression_type_extensions;\n                compression_extension != NULL;\n                compression_extension = g_slist_next(compression_extension)) {\n            if (g_strcmp0(ext, (const char*)compression_extension->data) == 0) {\n                sfx = strrchr(filename, '.');\n                if (sfx != NULL) {\n                    *sfx = '\\0';\n                }\n                break;\n            }\n        }\n        g_free(ext);\n        g_slist_free(compression_type_extensions);\n    } else { /* suffix is optional */\n        sfx = filename + strlen(filename);\n    }\n\n    /* test_00001_20050418010750 */\n\n    GMatchInfo *match_info;\n    g_regex_match(regex, filename, 0, &match_info);\n    if (g_match_info_matches(match_info)) {\n        if (prefix) {\n            *prefix = g_match_info_fetch_named(match_info, \"prefix\");\n        }\n        if (time) {\n            *time = g_match_info_fetch_named(match_info, \"time\");\n        }\n        if (suffix) {\n            *suffix = g_strdup(sfx);\n        }\n        ret = FILESET_NUM_TIME;\n    }\n    g_match_info_free(match_info);\n\n    if (ret == FILESET_NO_MATCH) {\n        g_regex_match(regex2, filename, 0, &match_info);\n        if (g_match_info_matches(match_info)) {\n            if (prefix) {\n                *prefix = g_match_info_fetch_named(match_info, \"prefix\");\n            }\n            if (time) {\n                *time = g_match_info_fetch_named(match_info, \"time\");\n            }\n            if (suffix) {\n                *suffix = g_strdup(sfx);\n            }\n            ret = FILESET_TIME_NUM;\n        }\n        g_match_info_free(match_info);\n    }\n\n    g_free(filename);\n\n    return ret;\n}\n\n\n/* test if both files could be in the same file set */\n/* (fname2 must already be in correct shape) */\nstatic bool\nfileset_is_file_in_set(const char *fname1, const char *fname2)\n{\n    char        *pfx1;\n    char        *pfx2;\n    char        *sfx1;\n    char        *sfx2;\n    fileset_match_t match1;\n    fileset_match_t match2;\n    bool        ret = false;\n\n    match1 = fileset_filename_match_pattern(fname1, &pfx1, &sfx1, NULL);\n    if (match1 == FILESET_NO_MATCH) {\n        return false;\n    }\n\n    match2 = fileset_filename_match_pattern(fname2, &pfx2, &sfx2, NULL);\n    /* just to be sure ... */\n    ws_assert(match2 != FILESET_NO_MATCH);\n    if (match1 == match2 && g_strcmp0(pfx1, pfx2) == 0 && g_strcmp0(sfx1, sfx2) == 0) {\n        ret = true;\n    }\n\n    g_free(pfx1);\n    g_free(pfx2);\n    g_free(sfx1);\n    g_free(sfx2);\n\n    return ret;\n}\n\n/* GCompareFunc helper for g_list_find_custom() */\nstatic int\nfileset_find_by_path(const void *a, const void *b)\n{\n    const fileset_entry *entry;\n    const char *path;\n\n    entry = (const fileset_entry *) a;\n    path  = (const char *) b;\n\n    return g_strcmp0(entry->fullname, path);\n}\n\n/* update the time and size of this file in the list */\nvoid\nfileset_update_file(const char *path)\n{\n    int fh, result;\n    ws_statb64 buf;\n    fileset_entry *entry = NULL;\n    GList *entry_list;\n\n    fh = ws_open( path, O_RDONLY, 0000 /* no creation so don't matter */);\n    if(fh !=  -1) {\n\n        /* Get statistics */\n        result = ws_fstat64( fh, &buf );\n\n        /* Show statistics if they are valid */\n        if( result == 0 ) {\n            entry_list = g_list_find_custom(set.entries, path,\n                                            fileset_find_by_path);\n\n            if (entry_list) {\n                entry = (fileset_entry *) entry_list->data;\n                entry->ctime    = ST_CREATE_TIME(buf);\n                entry->mtime    = buf.st_mtime;\n                entry->size     = buf.st_size;\n            }\n        }\n\n        ws_close(fh);\n    }\n}\n\n/* we know this file is part of the set, so add it */\nstatic fileset_entry *\nfileset_add_file(const char *dirname, const char *fname, bool current)\n{\n    int fh, result;\n    ws_statb64 buf;\n    char *path;\n    fileset_entry *entry = NULL;\n\n\n    path = ws_strdup_printf(\"%s%s\", dirname, fname);\n\n    fh = ws_open( path, O_RDONLY, 0000 /* no creation so don't matter */);\n    if(fh !=  -1) {\n\n        /* Get statistics */\n        result = ws_fstat64( fh, &buf );\n\n        /* Show statistics if they are valid */\n        if( result == 0 ) {\n            entry = g_new(fileset_entry, 1);\n\n            entry->fullname = g_strdup(path);\n            entry->name     = g_strdup(fname);\n            entry->ctime    = ST_CREATE_TIME(buf);\n            entry->mtime    = buf.st_mtime;\n            entry->size     = buf.st_size;\n            entry->current  = current;\n\n            set.entries = g_list_append(set.entries, entry);\n        }\n\n        ws_close(fh);\n    }\n\n    g_free(path);\n\n    return entry;\n}\n\n\n/* compare two list entries by creation date/time (through filename) */\nstatic int\nfileset_sort_compare(const void *a, const void *b)\n{\n    const fileset_entry *entry_a = (const fileset_entry *)a;\n    const fileset_entry *entry_b = (const fileset_entry *)b;\n\n    return strcmp(entry_a->name, entry_b->name);\n}\n\n\n/* add all file set entries to the dialog */\nvoid fileset_update_dlg(void *window)\n{\n    GList         *le;\n\n    /* Add all entries to the dialog. */\n    fileset_dlg_begin_add_file(window);\n    le = g_list_first(set.entries);\n    while(le) {\n        fileset_dlg_add_file((fileset_entry *)le->data, window);\n        le = g_list_next(le);\n    }\n    fileset_dlg_end_add_file(window);\n}\n\n\n/* walk through the directory of the loaded file and add every file matching the current file */\nvoid\nfileset_add_dir(const char *fname, void *window)\n{\n    WS_DIR        *dir;             /* scanned directory */\n    WS_DIRENT     *file;            /* current file */\n    const char    *name;\n    GString       *dirname;\n    char          *fname_dup;\n\n\n    /* get (convert) directory name, but don't touch the given string */\n    fname_dup = g_strdup(fname);\n    dirname = g_string_new(get_dirname(fname_dup));\n    g_free(fname_dup);\n\n    set.dirname = g_strdup(dirname->str);\n\n    dirname = g_string_append_c(dirname, G_DIR_SEPARATOR);\n\n    /* is the current file probably a part of any fileset? */\n    if(fileset_filename_match_pattern(fname, NULL, NULL, NULL)) {\n        /* yes, go through the files in the directory and check if the file in question is part of the current file set */\n        if ((dir = ws_dir_open(dirname->str, 0, NULL)) != NULL) {\n            while ((file = ws_dir_read_name(dir)) != NULL) {\n                name = ws_dir_get_name(file);\n                if(fileset_is_file_in_set(name, get_basename(fname))) {\n                    fileset_add_file(dirname->str, name, strcmp(name, get_basename(fname))== 0 /* current */);\n                }\n            } /* while */\n\n            ws_dir_close(dir);\n        } /* if */\n    } else {\n        /* no, this is a \"standalone file\", just add this one */\n        fileset_add_file(dirname->str, get_basename(fname), true /* current */);\n        /* don't add the file to the dialog here, this will be done in fileset_update_dlg() below */\n    }\n\n    g_string_free(dirname, TRUE /* free_segment */);\n\n    /* sort entries by creation time */\n    set.entries = g_list_sort(set.entries, fileset_sort_compare);\n\n    fileset_update_dlg(window);\n}\n\n\n/* get current directory name */\nconst char *\nfileset_get_dirname(void)\n{\n    return set.dirname;\n}\n\n\n/* get the current list entry, or NULL */\nstatic GList *\nfileset_get_current(void)\n{\n    GList         *le;\n    fileset_entry *entry;\n\n\n    /* add all entries to the dialog */\n    le = g_list_first(set.entries);\n    while(le) {\n        entry = (fileset_entry *)le->data;\n        if(entry->current) {\n            return le;\n        }\n        le = g_list_next(le);\n    }\n\n    return NULL;\n}\n\n\n/* get the file set entry after the current one, or NULL */\nfileset_entry *\nfileset_get_next(void)\n{\n    GList         *le;\n\n\n    le = fileset_get_current();\n    if(le == NULL) {\n        return NULL;\n    }\n\n    le = g_list_next(le);\n    if(le == NULL) {\n        return NULL;\n    }\n\n    return (fileset_entry *)le->data;\n}\n\n\n/* get the file set entry before the current one, or NULL */\nfileset_entry *\nfileset_get_previous(void)\n{\n    GList         *le;\n\n\n    le = fileset_get_current();\n    if(le == NULL) {\n        return NULL;\n    }\n\n    le = g_list_previous(le);\n    if(le == NULL) {\n        return NULL;\n    }\n\n    return (fileset_entry *)le->data;\n}\n\n\n/* delete a single entry */\nstatic void fileset_entry_delete(void *data, void *user_data _U_)\n{\n    fileset_entry *entry = (fileset_entry *)data;\n\n    g_free( (void *) entry->fullname);\n    entry->fullname = NULL;\n    g_free( (void *) entry->name);\n    entry->name = NULL;\n    g_free(entry);\n}\n\n\n/* delete the whole file set */\nvoid fileset_delete(void)\n{\n    /* free the entry list */\n    if(set.entries) {\n        g_list_foreach(set.entries, fileset_entry_delete, NULL);\n        g_list_free(set.entries);\n        set.entries = NULL;\n    }\n\n    /* free the rest */\n    if(set.dirname) {\n        g_free( (void *) set.dirname);\n        set.dirname = NULL;\n    }\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "fileset.h",
          "type": "blob",
          "size": 3.2216796875,
          "content": "/** @file\n *\n * Definitions for routines for file sets.\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#ifndef __FILESET_H__\n#define __FILESET_H__\n\n#include <inttypes.h>\n#include <time.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\ntypedef struct _fileset_entry {\n    char     *fullname;      /* File name with path (g_strdup'ed) */\n    char     *name;          /* File name without path (g_strdup'ed) */\n    time_t   ctime;          /* create time */\n    time_t   mtime;          /* last modified time */\n    int64_t  size;           /* size of file in bytes */\n    bool     current;        /* is this the currently loaded file? */\n} fileset_entry;\n\ntypedef enum {\n    FILESET_NO_MATCH,\n    FILESET_TIME_NUM,\n    FILESET_NUM_TIME\n} fileset_match_t;\n\n/* helper: is this a probable file of a file set (does the naming pattern match)?\n * Possible naming patterns are prefix_NNNNN_YYYYMMDDHHMMSS.ext[.gz] and\n * prefix_YYYYMMDDHHMMSS_NNNNN.ext[.gz], where any compression suffix\n * supported by libwiretap is allowed. The validation is minimal; e.g., the\n * time is only checked to see if all 14 characters are digits.\n *\n * @param[in] fname The filename to check for a naming pattern.\n * @param[out] prefix If not NULL and the filename matches, the prefix\n * @param[out] suffix If not NULL and the filename matches, the suffix\n * (file extension) not including the compression suffix\n * @param[out] time If not NULL and the filename matches, the time component\n * @return The type of pattern match, or FILESET_NO_MATCH.\n * */\nextern fileset_match_t fileset_filename_match_pattern(const char *fname, char **prefix, char **suffix, char **time);\n\nextern void fileset_add_dir(const char *fname, void *window);\n\nextern void fileset_delete(void);\n\n/* get the current directory name */\nextern const char *fileset_get_dirname(void);\n\nextern fileset_entry *fileset_get_next(void);\nextern fileset_entry *fileset_get_previous(void);\n\n/**\n * Add an entry to our dialog / window. Called by fileset_update_dlg.\n * Must be implemented in the UI.\n *\n * @param entry The new fileset entry.\n * @param window Window / dialog reference provided by the UI code.\n */\nextern void fileset_dlg_add_file(fileset_entry *entry, void *window);\n\n/**\n * Notify our dialog / window that we're about to add files. Called by fileset_update_dlg.\n * Must be implemented in the UI.\n *\n * @param window Window / dialog reference provided by the UI code.\n */\nextern void fileset_dlg_begin_add_file(void *window);\n\n/**\n * Notify our dialog / window that we're done adding files. Called by fileset_update_dlg.\n * Must be implemented in the UI.\n *\n * @param window Window / dialog reference provided by the UI code.\n */\nextern void fileset_dlg_end_add_file(void *window);\n\nextern void fileset_update_dlg(void *window);\n\nextern void fileset_update_file(const char *path);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* __FILESET_H__ */\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "fix",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "globals.h",
          "type": "blob",
          "size": 0.701171875,
          "content": "/** @file\n *\n * Global defines, etc.\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#ifndef __GLOBALS_H__\n#define __GLOBALS_H__\n\n#include \"file.h\"\n#include <epan/timestamp.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\nextern capture_file cfile;\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* __GLOBALS_H__ */\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "mergecap.c",
          "type": "blob",
          "size": 14.072265625,
          "content": "/* Combine dump files, either by appending or by merging by timestamp\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n *\n * Mergecap written by Scott Renfro <scott@renfro.org> based on\n * editcap by Richard Sharpe and Guy Harris\n *\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#include <wsutil/ws_getopt.h>\n\n#include <string.h>\n\n#include <wiretap/wtap.h>\n\n#include <wsutil/clopts_common.h>\n#include <wsutil/cmdarg_err.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/file_util.h>\n#include <wsutil/privileges.h>\n#include <wsutil/strnatcmp.h>\n#include <wsutil/ws_assert.h>\n#include <wsutil/wslog.h>\n\n#include <cli_main.h>\n#include <wsutil/version_info.h>\n\n#ifdef HAVE_PLUGINS\n#include <wsutil/plugins.h>\n#endif\n\n#include <wiretap/merge.h>\n\n#include \"ui/failure_message.h\"\n\n#define LONGOPT_COMPRESS                LONGOPT_BASE_APPLICATION+1\n\n/*\n * Show the usage\n */\nstatic void\nprint_usage(FILE *output)\n{\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: mergecap [options] -w <outfile>|- <infile> [<infile> ...]\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Output:\\n\");\n    fprintf(output, \"  -a                concatenate rather than merge files.\\n\");\n    fprintf(output, \"                    default is to merge based on frame timestamps.\\n\");\n    fprintf(output, \"  -s <snaplen>      truncate packets to <snaplen> bytes of data.\\n\");\n    fprintf(output, \"  -w <outfile>|-    set the output filename to <outfile> or '-' for stdout.\\n\");\n    fprintf(output, \"                    if the output filename has the .gz extension, it will be compressed to a gzip archive\\n\");\n    fprintf(output, \"  -F <capture type> set the output file type; default is pcapng.\\n\");\n    fprintf(output, \"                    an empty \\\"-F\\\" option will list the file types.\\n\");\n    fprintf(output, \"  -I <IDB merge mode> set the merge mode for Interface Description Blocks; default is 'all'.\\n\");\n    fprintf(output, \"                    an empty \\\"-I\\\" option will list the merge modes.\\n\");\n    fprintf(output, \"  --compress <type> compress the output file using the type compression format.\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Miscellaneous:\\n\");\n    fprintf(output, \"  -h, --help        display this help and exit.\\n\");\n    fprintf(output, \"  -V                verbose output.\\n\");\n    fprintf(output, \"  -v, --version     print version information and exit.\\n\");\n}\n\nstatic void\nlist_capture_types(void) {\n    GArray *writable_type_subtypes;\n\n    fprintf(stderr, \"mergecap: The available capture file types for the \\\"-F\\\" flag are:\\n\");\n    writable_type_subtypes = wtap_get_writable_file_types_subtypes(FT_SORT_BY_NAME);\n    for (unsigned i = 0; i < writable_type_subtypes->len; i++) {\n        int ft = g_array_index(writable_type_subtypes, int, i);\n        fprintf(stderr, \"    %s - %s\\n\", wtap_file_type_subtype_name(ft),\n                wtap_file_type_subtype_description(ft));\n    }\n    g_array_free(writable_type_subtypes, TRUE);\n}\n\nstatic void\nlist_idb_merge_modes(void) {\n    int i;\n\n    fprintf(stderr, \"mergecap: The available IDB merge modes for the \\\"-I\\\" flag are:\\n\");\n    for (i = 0; i < IDB_MERGE_MODE_MAX; i++) {\n        fprintf(stderr, \"    %s\\n\", merge_idb_merge_mode_to_string(i));\n    }\n}\n\nstatic void\nlist_output_compression_types(void) {\n    GSList *output_compression_types;\n\n    fprintf(stderr, \"mergecap: The available output compress type(s) for the \\\"--compress\\\" flag are:\\n\");\n    output_compression_types = wtap_get_all_output_compression_type_names_list();\n    for (GSList *compression_type = output_compression_types;\n        compression_type != NULL;\n        compression_type = g_slist_next(compression_type)) {\n            fprintf(stderr, \"   %s\\n\", (const char *)compression_type->data);\n        }\n\n    g_slist_free(output_compression_types);\n}\n\nstatic bool\nmerge_callback(merge_event event, int num,\n        const merge_in_file_t in_files[], const unsigned in_file_count,\n        void *data _U_)\n{\n    unsigned i;\n\n    switch (event) {\n\n        case MERGE_EVENT_INPUT_FILES_OPENED:\n            for (i = 0; i < in_file_count; i++) {\n                fprintf(stderr, \"mergecap: %s is type %s.\\n\", in_files[i].filename,\n                        wtap_file_type_subtype_description(wtap_file_type_subtype(in_files[i].wth)));\n            }\n            break;\n\n        case MERGE_EVENT_FRAME_TYPE_SELECTED:\n            /* for this event, num = frame_type */\n            if (num == WTAP_ENCAP_PER_PACKET) {\n                /*\n                 * Find out why we had to choose WTAP_ENCAP_PER_PACKET.\n                 */\n                int first_frame_type, this_frame_type;\n\n                first_frame_type = wtap_file_encap(in_files[0].wth);\n                for (i = 1; i < in_file_count; i++) {\n                    this_frame_type = wtap_file_encap(in_files[i].wth);\n                    if (first_frame_type != this_frame_type) {\n                        fprintf(stderr, \"mergecap: multiple frame encapsulation types detected\\n\");\n                        fprintf(stderr, \"          defaulting to WTAP_ENCAP_PER_PACKET\\n\");\n                        fprintf(stderr, \"          %s had type %s (%s)\\n\",\n                                in_files[0].filename,\n                                wtap_encap_description(first_frame_type),\n                                wtap_encap_name(first_frame_type));\n                        fprintf(stderr, \"          %s had type %s (%s)\\n\",\n                                in_files[i].filename,\n                                wtap_encap_description(this_frame_type),\n                                wtap_encap_name(this_frame_type));\n                        break;\n                    }\n                }\n            }\n            fprintf(stderr, \"mergecap: selected frame_type %s (%s)\\n\",\n                    wtap_encap_description(num),\n                    wtap_encap_name(num));\n            break;\n\n        case MERGE_EVENT_READY_TO_MERGE:\n            fprintf(stderr, \"mergecap: ready to merge records\\n\");\n            break;\n\n        case MERGE_EVENT_RECORD_WAS_READ:\n            /* for this event, num = count */\n            fprintf(stderr, \"Record: %d\\n\", num);\n            break;\n\n        case MERGE_EVENT_DONE:\n            fprintf(stderr, \"mergecap: merging complete\\n\");\n            break;\n    }\n\n    /* false = do not stop merging */\n    return false;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char               *configuration_init_error;\n    int                 opt;\n    static const struct ws_option long_options[] = {\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        {\"compress\", ws_required_argument, NULL, LONGOPT_COMPRESS},\n        {0, 0, 0, 0 }\n    };\n    bool                  do_append        = false;\n    bool                  verbose          = false;\n    int                   in_file_count    = 0;\n    uint32_t              snaplen          = 0;\n    int                   file_type        = WTAP_FILE_TYPE_SUBTYPE_UNKNOWN;\n    char                  *out_filename    = NULL;\n    bool                  status           = true;\n    idb_merge_mode        mode             = IDB_MERGE_MODE_MAX;\n    wtap_compression_type compression_type = WTAP_UNKNOWN_COMPRESSION;\n    merge_progress_callback_t cb;\n\n    /* Set the program name. */\n    g_set_prgname(\"mergecap\");\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, 1);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n#ifdef _WIN32\n    create_app_running_mutex();\n#endif /* _WIN32 */\n\n    /*\n     * Get credential information for later use.\n     */\n    init_process_policies();\n\n    /*\n     * Attempt to get the pathname of the directory containing the\n     * executable file.\n     */\n    configuration_init_error = configuration_init(argv[0]);\n    if (configuration_init_error != NULL) {\n        cmdarg_err(\n                \"Can't get pathname of directory containing the mergecap program: %s.\",\n                configuration_init_error);\n        g_free(configuration_init_error);\n    }\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"Mergecap\", NULL, NULL);\n\n    init_report_failure_message(\"mergecap\");\n\n    wtap_init(true);\n\n    /* Process the options first */\n    while ((opt = ws_getopt_long(argc, argv, \"aF:hI:s:vVw:\", long_options, NULL)) != -1) {\n\n        switch (opt) {\n            case 'a':\n                do_append = !do_append;\n                break;\n\n            case 'F':\n                file_type = wtap_name_to_file_type_subtype(ws_optarg);\n                if (file_type < 0) {\n                    cmdarg_err(\"\\\"%s\\\" isn't a valid capture file type\",\n                               ws_optarg);\n                    list_capture_types();\n                    status = false;\n                    goto clean_exit;\n                }\n                break;\n\n            case 'h':\n                show_help_header(\"Merge two or more capture files into one.\");\n                print_usage(stdout);\n                goto clean_exit;\n                break;\n\n            case 'I':\n                mode = merge_string_to_idb_merge_mode(ws_optarg);\n                if (mode == IDB_MERGE_MODE_MAX) {\n                    cmdarg_err(\"\\\"%s\\\" isn't a valid IDB merge mode\",\n                               ws_optarg);\n                    list_idb_merge_modes();\n                    status = false;\n                    goto clean_exit;\n                }\n                break;\n\n            case 's':\n                snaplen = get_nonzero_uint32(ws_optarg, \"snapshot length\");\n                break;\n\n            case 'V':\n                verbose = true;\n                break;\n\n            case 'v':\n                show_version();\n                goto clean_exit;\n                break;\n\n            case 'w':\n                out_filename = ws_optarg;\n                break;\n\n            case LONGOPT_COMPRESS:\n                compression_type = wtap_name_to_compression_type(ws_optarg);\n                if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n                    cmdarg_err(\"\\\"%s\\\" isn't a valid output compression mode\",\n                                ws_optarg);\n                    list_output_compression_types();\n                    goto clean_exit;\n                }\n                break;\n            case '?':              /* Bad options if GNU getopt */\n                switch(ws_optopt) {\n                    case'F':\n                        list_capture_types();\n                        break;\n                    case'I':\n                        list_idb_merge_modes();\n                        break;\n                    case LONGOPT_COMPRESS:\n                        list_output_compression_types();\n                        break;\n                    default:\n                        print_usage(stderr);\n                }\n                status = false;\n                goto clean_exit;\n                break;\n        }\n    }\n\n    /* Default to pcapng when writing. */\n    if (file_type == WTAP_FILE_TYPE_SUBTYPE_UNKNOWN)\n        file_type = wtap_pcapng_file_type_subtype();\n\n    cb.callback_func = merge_callback;\n    cb.data = NULL;\n\n    /* check for proper args; at a minimum, must have an output\n     * filename and one input file\n     */\n    in_file_count = argc - ws_optind;\n    if (!out_filename) {\n        cmdarg_err(\"an output filename must be set with -w\");\n        cmdarg_err_cont(\"run with -h for help\");\n        status = false;\n        goto clean_exit;\n    }\n    if (in_file_count < 1) {\n        cmdarg_err(\"No input files were specified\");\n        return 1;\n    }\n\n    if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n        /* An explicitly specified compression type overrides filename\n         * magic. (Should we allow specifying \"no\" compression with, e.g.\n         * a \".gz\" extension?) */\n        const char *sfx = strrchr(out_filename, '.');\n        if (sfx) {\n            compression_type = wtap_extension_to_compression_type(sfx + 1);\n        }\n    }\n\n    if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n        compression_type = WTAP_UNCOMPRESSED;\n    }\n\n    if (!wtap_can_write_compression_type(compression_type)) {\n        cmdarg_err(\"Output files can't be written as %s\",\n                wtap_compression_type_description(compression_type));\n        status = false;\n        goto clean_exit;\n    }\n\n    if (compression_type != WTAP_UNCOMPRESSED && !wtap_dump_can_compress(file_type)) {\n        cmdarg_err(\"The file format %s can't be written to output compressed format\",\n            wtap_file_type_subtype_name(file_type));\n        status = false;\n        goto clean_exit;\n    }\n\n    /*\n     * Setting IDB merge mode must use a file format that supports\n     * (and thus requires) interface ID and information blocks.\n     */\n    if (mode != IDB_MERGE_MODE_MAX &&\n            wtap_file_type_subtype_supports_block(file_type, WTAP_BLOCK_IF_ID_AND_INFO) == BLOCK_NOT_SUPPORTED) {\n        cmdarg_err(\"The IDB merge mode can only be used with an output format that identifies interfaces\");\n        status = false;\n        goto clean_exit;\n    }\n\n    /* if they didn't set IDB merge mode, set it to our default */\n    if (mode == IDB_MERGE_MODE_MAX) {\n        mode = IDB_MERGE_MODE_ALL_SAME;\n    }\n\n    /* open the outfile */\n    if (strcmp(out_filename, \"-\") == 0) {\n        /* merge the files to the standard output */\n        status = merge_files_to_stdout(file_type,\n                (const char *const *) &argv[ws_optind],\n                in_file_count, do_append, mode, snaplen,\n                get_appname_and_version(),\n                verbose ? &cb : NULL, compression_type);\n    } else {\n        /* merge the files to the outfile */\n        status = merge_files(out_filename, file_type,\n                (const char *const *) &argv[ws_optind], in_file_count,\n                do_append, mode, snaplen, get_appname_and_version(),\n                verbose ? &cb : NULL, compression_type);\n    }\n\nclean_exit:\n    wtap_cleanup();\n    free_progdirs();\n    return status ? 0 : 2;\n}\n"
        },
        {
          "name": "mmdbresolve.c",
          "type": "blob",
          "size": 6.7607421875,
          "content": "/* Read IPv4 and IPv6 addresses on stdin and print their MMDB entries on stdout.\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * This program uses the MaxMind DB library (libmaxminddb) and MUST be\n * compatible with its license (Apache 2.0).\n *\n * SPDX-License-Identifier: MIT\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <maxminddb.h>\n\n#define MAX_ADDR_LEN 46\n#define MMDBR_STRINGIFY(x) MMDBR_STRINGIFY_S(x)\n#define MMDBR_STRINGIFY_S(s) #s\n#define OUT_BUF_SIZE 65536\n\n// Uncomment to enable slow lookups. Only useful on Windows for now.\n// #define MMDB_DEBUG_SLOW 1\n\n#ifdef MMDB_DEBUG_SLOW\n#ifdef _WIN32\n#include <Windows.h>\n#endif\n#endif\n\nstatic const char *co_iso_key[]     = {\"country\", \"iso_code\", NULL};\nstatic const char *co_name_key[]    = {\"country\", \"names\", \"en\", NULL};\nstatic const char *ci_name_key[]    = {\"city\", \"names\", \"en\", NULL};\nstatic const char *asn_o_key[]      = {\"autonomous_system_organization\", NULL};\nstatic const char *asn_key[]        = {\"autonomous_system_number\", NULL};\nstatic const char *l_lat_key[]      = {\"location\", \"latitude\", NULL};\nstatic const char *l_lon_key[]      = {\"location\", \"longitude\", NULL};\nstatic const char *l_accuracy_key[] = {\"location\", \"accuracy_radius\", NULL};\nstatic const char *empty_key[]      = {NULL};\n\nstatic const char **lookup_keys[] = {\n    co_iso_key,\n    co_name_key,\n    ci_name_key,\n    asn_o_key,\n    asn_key,\n    l_lat_key,\n    l_lon_key,\n    l_accuracy_key,\n    empty_key\n};\n\nstatic void exit_err(void) {\n    fprintf(stderr, \"Usage: mmdbresolve -f db_file [-f db_file ...]\\n\");\n    exit(1);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char addr_str[MAX_ADDR_LEN+1];\n    size_t mmdb_count = 0;\n    MMDB_s *mmdbs = NULL, *new_mmdbs;\n    int mmdb_err;\n\n    char *out_buf = (char *) malloc(OUT_BUF_SIZE);\n    if (out_buf == NULL) {\n        fprintf(stdout, \"ERROR: malloc failed\\n\");\n        return 1;\n    }\n    setvbuf(stdout, out_buf, _IOFBF, OUT_BUF_SIZE);\n\n    fprintf(stdout, \"[init]\\n\");\n\n    // If we need to handle anything beyond \"-f\" we'll probably want to\n    // link with GLib and use GOption.\n    int arg_idx = 0;\n    while (arg_idx < argc - 1) {\n        if (strcmp(argv[arg_idx], \"-f\") == 0) {\n            arg_idx++;\n            const char *db_arg = argv[arg_idx];\n            MMDB_s try_mmdb;\n            mmdb_err = MMDB_open(db_arg, 0, &try_mmdb);\n            fprintf(stdout, \"db.%zd.path: %s\\n\", mmdb_count, db_arg);\n            fprintf(stdout, \"db.%zd.status: \", mmdb_count);\n            if (mmdb_err == MMDB_SUCCESS) {\n                mmdb_count++;\n                new_mmdbs = (MMDB_s *) realloc(mmdbs, mmdb_count * sizeof(MMDB_s));\n                if (new_mmdbs == NULL) {\n                    free(mmdbs);\n                    fprintf(stdout, \"ERROR out of memory\\n\");\n                    return 1;\n                }\n                mmdbs = new_mmdbs;\n                mmdbs[mmdb_count - 1] = try_mmdb;\n                fprintf(stdout, \"OK\\n\");\n                fprintf(stdout, \"db.%zd.type: %s\\n\", mmdb_count, mmdbs[mmdb_count - 1].metadata.database_type);\n            } else {\n                fprintf(stdout, \"ERROR %s\\n\", MMDB_strerror(mmdb_err));\n            }\n        }\n        arg_idx++;\n    }\n\n    fprintf(stdout, \"mmdbresolve.status: %s\\n\", mmdb_count > 0 ? \"true\": \"false\");\n    fprintf(stdout, \"# End init\\n\");\n    fflush(stdout);\n\n    if (arg_idx != argc || mmdb_count < 1) {\n        exit_err();\n    }\n\n    int in_items = 0;\n    while (in_items != EOF) {\n        int gai_err;\n\n        in_items = fscanf(stdin, \"%\" MMDBR_STRINGIFY(MAX_ADDR_LEN) \"s\", addr_str);\n\n        if (in_items < 1) {\n            continue;\n        }\n\n        fprintf(stdout, \"[%s]\\n\", addr_str);\n\n#ifdef MMDB_DEBUG_SLOW\n#ifdef _WIN32\n        Sleep(1000);\n#endif\n#endif\n\n        for (size_t mmdb_idx = 0; mmdb_idx < mmdb_count; mmdb_idx++) {\n            fprintf(stdout, \"# %s\\n\", mmdbs[mmdb_idx].metadata.database_type);\n            MMDB_lookup_result_s result = MMDB_lookup_string(&mmdbs[mmdb_idx], addr_str, &gai_err, &mmdb_err);\n\n            if (result.found_entry && gai_err == 0 && mmdb_err == MMDB_SUCCESS) {\n                for (size_t key_idx = 0; lookup_keys[key_idx][0]; key_idx++) {\n                    MMDB_entry_data_s entry_data;\n                    int status = MMDB_aget_value(&result.entry, &entry_data, lookup_keys[key_idx]);\n                    if (status == MMDB_SUCCESS && entry_data.has_data) {\n                        char *sep = \"\";\n                        for (int idx = 0; lookup_keys[key_idx][idx] != 0; idx++) {\n                            fprintf(stdout, \"%s%s\", sep, lookup_keys[key_idx][idx]);\n                            sep = \".\";\n                        }\n                        switch (entry_data.type) {\n                            case MMDB_DATA_TYPE_UTF8_STRING:\n                            {\n                                char len_fmt[12]; // : %.xxxxxs\\n\\0\n                                snprintf(len_fmt, 11, \": %%.%us\\n\", entry_data.data_size);\n                                fprintf(stdout, len_fmt, entry_data.utf8_string);\n                            }\n                            break;\n                            case MMDB_DATA_TYPE_UINT16:\n                                fprintf(stdout, \": %u\\n\", entry_data.uint16);\n                                break;\n                            case MMDB_DATA_TYPE_UINT32:\n                                fprintf(stdout, \": %u\\n\", entry_data.uint32);\n                                break;\n                            case MMDB_DATA_TYPE_INT32:\n                                fprintf(stdout, \": %d\\n\", entry_data.int32);\n                                break;\n                            case MMDB_DATA_TYPE_BOOLEAN:\n                                fprintf(stdout, \": %s\\n\", entry_data.boolean ? \"True\" : \"False\");\n                                break;\n                            case MMDB_DATA_TYPE_DOUBLE:\n                                fprintf(stdout, \": %f\\n\", entry_data.double_value);\n                                break;\n                            case MMDB_DATA_TYPE_FLOAT:\n                                fprintf(stdout, \": %f\\n\", entry_data.float_value);\n                                break;\n                            default:\n                                fprintf(stdout, \": UNKNOWN (%u)\\n\", entry_data.type);\n                        }\n                    }\n                }\n            } else {\n                // dump error info.\n            }\n        }\n        fprintf(stdout, \"# End %s\\n\", addr_str);\n        fflush(stdout);\n    }\n\n    free(mmdbs);\n\n    return 0;\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "packaging",
          "type": "tree",
          "content": null
        },
        {
          "name": "plugins",
          "type": "tree",
          "content": null
        },
        {
          "name": "pytest.ini",
          "type": "blob",
          "size": 0.0986328125,
          "content": "[pytest]\nminversion = 3.0\ntestpaths = test\npython_files = suite_*.py group_*.py\naddopts = -ra -nauto\n"
        },
        {
          "name": "randpkt.c",
          "type": "blob",
          "size": 8.2412109375,
          "content": "/*\n * randpkt.c\n * ---------\n * Creates random packet traces. Useful for debugging sniffers by testing\n * assumptions about the veracity of the data found in the packet.\n *\n * Copyright (C) 1999 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <glib.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <ws_exit_codes.h>\n#include <wsutil/clopts_common.h>\n#include <ui/failure_message.h>\n#include <wsutil/cmdarg_err.h>\n#include <wsutil/file_util.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/privileges.h>\n#include <cli_main.h>\n\n#ifdef HAVE_PLUGINS\n#include <wsutil/plugins.h>\n#endif\n\n#include <wsutil/wslog.h>\n\n#include <wsutil/ws_getopt.h>\n#include <wsutil/version_info.h>\n\n#include \"randpkt_core/randpkt_core.h\"\n\n/* Additional exit codes */\n#define INVALID_TYPE 2\n#define CLOSE_ERROR  2\n\nstatic void\nlist_capture_types(void) {\n    GArray *writable_type_subtypes;\n\n    cmdarg_err(\"The available capture file types for the \\\"-F\\\" flag are:\\n\");\n    writable_type_subtypes = wtap_get_writable_file_types_subtypes(FT_SORT_BY_NAME);\n    for (unsigned i = 0; i < writable_type_subtypes->len; i++) {\n        int ft = g_array_index(writable_type_subtypes, int, i);\n        fprintf(stderr, \"    %s - %s\\n\", wtap_file_type_subtype_name(ft),\n            wtap_file_type_subtype_description(ft));\n    }\n    g_array_free(writable_type_subtypes, TRUE);\n}\n\n/* Print usage statement and exit program */\nstatic void\nusage(bool is_error)\n{\n    FILE *output;\n    char** abbrev_list;\n    char** longname_list;\n    unsigned i = 0;\n\n    if (!is_error) {\n        output = stdout;\n    }\n    else {\n        output = stderr;\n    }\n\n    fprintf(output, \"Usage: randpkt [options] <outfile>\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Options:\\n\");\n    fprintf(output, \"  -b                maximum bytes per packet (default: 5000)\\n\");\n    fprintf(output, \"  -c                packet count (default: 1000)\\n\");\n    fprintf(output, \"  -F                output file type (default: pcapng)\\n\");\n    fprintf(output, \"                    an empty \\\"-F\\\" option will list the file types\\n\");\n    fprintf(output, \"  -r                select a different random type for each packet\\n\");\n    fprintf(output, \"  -t                packet type\\n\");\n    fprintf(output, \"  -h, --help        display this help and exit.\\n\");\n    fprintf(output, \"  -v, --version     print version information and exit.\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Types:\\n\");\n\n    /* Get the examples list */\n    randpkt_example_list(&abbrev_list, &longname_list);\n    while (abbrev_list[i] && longname_list[i]) {\n        fprintf(output, \"\\t%-16s%s\\n\", abbrev_list[i], longname_list[i]);\n        i++;\n    }\n\n    g_strfreev(abbrev_list);\n    g_strfreev(longname_list);\n\n    fprintf(output, \"\\nIf type is not specified, a random packet type will be chosen\\n\\n\");\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char *configuration_init_error;\n    int opt;\n    int produce_type = -1;\n    char *produce_filename = NULL;\n    int produce_max_bytes = 5000;\n    int produce_count = 1000;\n    int file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_UNKNOWN;\n    randpkt_example *example;\n    uint8_t* type = NULL;\n    bool allrandom = false;\n    wtap_dumper *savedump;\n    int ret = EXIT_SUCCESS;\n    static const struct ws_option long_options[] = {\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        {0, 0, 0, 0 }\n    };\n\n    /* Set the program name. */\n    g_set_prgname(\"randpkt\");\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, WS_EXIT_INVALID_OPTION);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n    /*\n     * Get credential information for later use.\n     */\n    init_process_policies();\n\n    /*\n     * Attempt to get the pathname of the directory containing the\n     * executable file.\n     */\n    configuration_init_error = configuration_init(argv[0]);\n    if (configuration_init_error != NULL) {\n        fprintf(stderr,\n            \"capinfos: Can't get pathname of directory containing the capinfos program: %s.\\n\",\n            configuration_init_error);\n        g_free(configuration_init_error);\n    }\n\n    init_report_failure_message(\"randpkt\");\n\n    wtap_init(true);\n\n#ifdef _WIN32\n    create_app_running_mutex();\n#endif /* _WIN32 */\n\n    ws_init_version_info(\"Randpkt\", NULL, NULL);\n\n    while ((opt = ws_getopt_long(argc, argv, \"b:c:F:ht:rv\", long_options, NULL)) != -1) {\n        switch (opt) {\n            case 'b':\t/* max bytes */\n                produce_max_bytes = get_positive_int(ws_optarg, \"max bytes\");\n                if (produce_max_bytes > 65536) {\n                    cmdarg_err(\"max bytes is > 65536\");\n                    ret = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n\n            case 'c':\t/* count */\n                produce_count = get_positive_int(ws_optarg, \"count\");\n                break;\n\n            case 'F':\n                file_type_subtype = wtap_name_to_file_type_subtype(ws_optarg);\n                if (file_type_subtype < 0) {\n                    cmdarg_err(\"\\\"%s\\\" isn't a valid capture file type\", ws_optarg);\n                    list_capture_types();\n                    return WS_EXIT_INVALID_OPTION;\n                }\n                break;\n\n            case 't':\t/* type of packet to produce */\n                type = g_strdup(ws_optarg);\n                break;\n\n            case 'h':\n                show_help_header(NULL);\n                usage(false);\n                goto clean_exit;\n                break;\n\n            case 'r':\n                allrandom = true;\n                break;\n\n            case 'v':\n                show_version();\n                goto clean_exit;\n                break;\n\n            case '?':\n                switch(ws_optopt) {\n                    case 'F':\n                        list_capture_types();\n                        return WS_EXIT_INVALID_OPTION;\n                }\n                /* FALLTHROUGH */\n\n            default:\n                usage(true);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n                break;\n        }\n    }\n\n    /* any more command line parameters? */\n    if (argc > ws_optind) {\n        produce_filename = argv[ws_optind];\n    } else {\n        usage(true);\n        ret = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_UNKNOWN) {\n        file_type_subtype = wtap_pcapng_file_type_subtype();\n    }\n\n    if (!allrandom) {\n        produce_type = randpkt_parse_type(type);\n        g_free(type);\n\n        example = randpkt_find_example(produce_type);\n        if (!example) {\n            ret = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n\n        ret = randpkt_example_init(example, produce_filename, produce_max_bytes, file_type_subtype);\n        if (ret != EXIT_SUCCESS)\n            goto clean_exit;\n        randpkt_loop(example, produce_count, 0);\n    } else {\n        if (type) {\n            fprintf(stderr, \"Can't set type in random mode\\n\");\n            ret = INVALID_TYPE;\n            goto clean_exit;\n        }\n\n        produce_type = randpkt_parse_type(NULL);\n        example = randpkt_find_example(produce_type);\n        if (!example) {\n            ret = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n        ret = randpkt_example_init(example, produce_filename, produce_max_bytes, file_type_subtype);\n        if (ret != EXIT_SUCCESS)\n            goto clean_exit;\n\n        while (produce_count-- > 0) {\n            randpkt_loop(example, 1, 0);\n            produce_type = randpkt_parse_type(NULL);\n\n            savedump = example->dump;\n\n            example = randpkt_find_example(produce_type);\n            if (!example) {\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            example->dump = savedump;\n            example->filename = produce_filename;\n        }\n    }\n    if (!randpkt_example_close(example)) {\n        ret = CLOSE_ERROR;\n    }\n\nclean_exit:\n    wtap_cleanup();\n    return ret;\n}\n"
        },
        {
          "name": "randpkt_core",
          "type": "tree",
          "content": null
        },
        {
          "name": "rawshark.c",
          "type": "blob",
          "size": 48.52734375,
          "content": "/* rawshark.c\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * Rawshark - Raw field extractor by Gerald Combs <gerald@wireshark.org>\n * and Loris Degioanni <loris.degioanni@cacetech.com>\n * Based on TShark, by Gilbert Ramirez <gram@alumni.rice.edu> and Guy Harris\n * <guy@alum.mit.edu>.\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n/*\n * Rawshark does the following:\n * - Opens a specified file or named pipe\n * - Applies a specified DLT or \"decode as\" encapsulation\n * - Reads frames prepended with a libpcap packet header.\n * - Prints a status line, followed by fields from a specified list.\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n#include <limits.h>\n\n#ifndef _WIN32\n#include <sys/time.h>\n#include <sys/resource.h>\n#endif\n\n#include <errno.h>\n\n#include <ws_exit_codes.h>\n#include <wsutil/ws_getopt.h>\n\n#include <glib.h>\n#include <epan/epan.h>\n\n#include <epan/tfs.h>\n#include <wsutil/array.h>\n#include <wsutil/cmdarg_err.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/file_util.h>\n#include <wsutil/socket.h>\n#include <wsutil/privileges.h>\n#include <wsutil/please_report_bug.h>\n#include <wsutil/wslog.h>\n#include <wsutil/clopts_common.h>\n\n#ifdef _WIN32\n#include <wsutil/unicode-utils.h>\n#include <wsutil/win32-utils.h>\n#endif\n\n#include \"globals.h\"\n#include <epan/packet.h>\n#include <epan/ftypes/ftypes.h>\n#include \"file.h\"\n#include <epan/disabled_protos.h>\n#include <epan/prefs.h>\n#include <epan/column.h>\n#include <epan/print.h>\n#include <epan/addr_resolv.h>\n#ifdef HAVE_LIBPCAP\n#include \"ui/capture_ui_utils.h\"\n#endif\n#include \"ui/util.h\"\n#include \"ui/dissect_opts.h\"\n#include \"ui/failure_message.h\"\n#include <epan/epan_dissect.h>\n#include <epan/stat_tap_ui.h>\n#include <epan/timestamp.h>\n#include \"epan/column-utils.h\"\n#include \"epan/proto.h\"\n#include <epan/tap.h>\n\n#include <wiretap/wtap.h>\n#include <wiretap/libpcap.h>\n#include <wiretap/pcap-encap.h>\n\n#include <cli_main.h>\n#include <wsutil/version_info.h>\n\n#include \"capture/capture-pcap-util.h\"\n\n#ifdef HAVE_LIBPCAP\n#include <setjmp.h>\n#ifdef _WIN32\n#include \"capture/capture-wpcap.h\"\n#endif /* _WIN32 */\n#endif /* HAVE_LIBPCAP */\n\n#if 0\n/*\n * This is the template for the decode as option; it is shared between the\n * various functions that output the usage for this parameter.\n */\nstatic const char decode_as_arg_template[] = \"<layer_type>==<selector>,<decode_as_protocol>\";\n#endif\n\n/* Additional exit codes */\n#define INVALID_DFILTER 2\n#define FORMAT_ERROR    2\n\ncapture_file cfile;\n\nstatic uint32_t cum_bytes;\nstatic frame_data ref_frame;\nstatic frame_data prev_dis_frame;\nstatic frame_data prev_cap_frame;\n\n/*\n * The way the packet decode is to be written.\n */\ntypedef enum {\n    WRITE_TEXT, /* summary or detail text */\n    WRITE_XML   /* PDML or PSML */\n    /* Add CSV and the like here */\n} output_action_e;\n\nstatic bool line_buffered;\nstatic print_format_e print_format = PR_FMT_TEXT;\n\nstatic bool want_pcap_pkthdr;\n\ncf_status_t raw_cf_open(capture_file *cf, const char *fname);\nstatic bool load_cap_file(capture_file *cf);\nstatic bool process_packet(capture_file *cf, epan_dissect_t *edt, int64_t offset,\n                               wtap_rec *rec);\nstatic void show_print_file_io_error(int err);\n\nstatic void protocolinfo_init(char *field);\nstatic bool parse_field_string_format(char *format);\n\ntypedef enum {\n    SF_NONE,    /* No format (placeholder) */\n    SF_NAME,    /* %D Field name / description */\n    SF_NUMVAL,  /* %N Numeric value */\n    SF_STRVAL   /* %S String value */\n} string_fmt_e;\n\ntypedef struct string_fmt_s {\n    char *plain;\n    string_fmt_e format;    /* Valid if plain is NULL */\n} string_fmt_t;\n\nint n_rfilters;\nint n_rfcodes;\ndfilter_t *rfcodes[64];\nint n_rfieldfilters;\ndfilter_t *rfieldfcodes[64];\nint fd;\nint encap;\nGPtrArray *string_fmts;\n\nstatic void\nprint_usage(FILE *output)\n{\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: rawshark [options] ...\\n\");\n    fprintf(output, \"\\n\");\n\n    fprintf(output, \"Input file:\\n\");\n    fprintf(output, \"  -r <infile>, --read-file <infile>\\n\");\n    fprintf(output,\"                            set the pipe or file name to read from\\n\");\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Processing:\\n\");\n    fprintf(output, \"  -d <encap:linktype>|<proto:protoname>\\n\");\n    fprintf(output, \"                           packet encapsulation or protocol\\n\");\n    fprintf(output, \"  -F <field>               field to display\\n\");\n#if !defined(_WIN32) && defined(RLIMIT_AS)\n    fprintf(output, \"  -m                       virtual memory limit, in bytes\\n\");\n#endif\n    fprintf(output, \"  -n                       disable all name resolutions (def: \\\"mNd\\\" enabled, or\\n\");\n    fprintf(output, \"                           as set in preferences)\\n\");\n    fprintf(output, \"  -N <name resolve flags>  enable specific name resolution(s): \\\"mnNtdv\\\"\\n\");\n    fprintf(output, \"  -p                       use the system's packet header format\\n\");\n    fprintf(output, \"                           (which may have 64-bit timestamps)\\n\");\n    fprintf(output, \"  -R <read filter>, --read-filter <read filter>\\n\");\n    fprintf(output, \"                           packet filter in Wireshark display filter syntax\\n\");\n    fprintf(output, \"  -s                       skip PCAP header on input\\n\");\n    fprintf(output, \"  -Y <display filter>, --display-filter <display filter>\\n\");\n    fprintf(output, \"                           packet filter in Wireshark display filter syntax\\n\");\n    fprintf(output, \"  --enable-protocol <proto_name>\\n\");\n    fprintf(output, \"                           enable dissection of proto_name\\n\");\n    fprintf(output, \"  --disable-protocol <proto_name>\\n\");\n    fprintf(output, \"                           disable dissection of proto_name\\n\");\n    fprintf(output, \"  --only-protocols <protocols>\\n\");\n    fprintf(output, \"                           Only enable dissection of these protocols, comma\\n\");\n    fprintf(output, \"                           separated. Disable everything else\\n\");\n    fprintf(output, \"  --disable-all-protocols\\n\");\n    fprintf(output, \"                           Disable dissection of all protocols\\n\");\n    fprintf(output, \"  --enable-heuristic <short_name>\\n\");\n    fprintf(output, \"                           enable dissection of heuristic protocol\\n\");\n    fprintf(output, \"  --disable-heuristic <short_name>\\n\");\n    fprintf(output, \"                           disable dissection of heuristic protocol\\n\");\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Output:\\n\");\n    fprintf(output, \"  -l                       flush output after each packet\\n\");\n    fprintf(output, \"  -S                       format string for fields\\n\");\n    fprintf(output, \"                           (%%D - name, %%S - stringval, %%N numval)\\n\");\n    fprintf(output, \"  -t (a|ad|adoy|d|dd|e|r|u|ud|udoy)[.[N]]|.[N]\\n\");\n    fprintf(output, \"                           output format of time stamps (def: r: rel. to first)\\n\");\n    fprintf(output, \"  -u s|hms                 output format of seconds (def: s: seconds)\\n\");\n    fprintf(output, \"\\n\");\n\n    ws_log_print_usage(output);\n    fprintf(output, \"\\n\");\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Miscellaneous:\\n\");\n    fprintf(output, \"  -h, --help               display this help and exit\\n\");\n    fprintf(output, \"  -v, --version            display version info and exit\\n\");\n    fprintf(output, \"  -o <name>:<value> ...    override preference setting\\n\");\n    fprintf(output, \"  -K <keytab>              keytab file to use for kerberos decryption\\n\");\n}\n\n/**\n * Open a pipe for raw input.  This is a stripped-down version of\n * pcap_loop.c:cap_pipe_open_live().\n * We check if \"pipe_name\" is \"-\" (stdin) or a FIFO, and open it.\n * @param pipe_name The name of the pipe or FIFO.\n * @return A POSIX file descriptor on success, or -1 on failure.\n */\nstatic int\nraw_pipe_open(const char *pipe_name)\n{\n#ifndef _WIN32\n    ws_statb64 pipe_stat;\n#else\n    DWORD err;\n    wchar_t *err_str;\n    HANDLE hPipe = NULL;\n#endif\n    int          rfd;\n\n    ws_log(LOG_DOMAIN_CAPCHILD, LOG_LEVEL_DEBUG, \"open_raw_pipe: %s\", pipe_name);\n\n    /*\n     * XXX Rawshark blocks until we return\n     */\n    if (strcmp(pipe_name, \"-\") == 0) {\n        rfd = 0; /* read from stdin */\n#ifdef _WIN32\n        /*\n         * This is needed to set the stdin pipe into binary mode, otherwise\n         * CR/LF are mangled...\n         */\n        _setmode(0, _O_BINARY);\n#endif  /* _WIN32 */\n    } else {\n#ifndef _WIN32\n        if (ws_stat64(pipe_name, &pipe_stat) < 0) {\n            fprintf(stderr, \"rawshark: The pipe %s could not be checked: %s\\n\",\n                    pipe_name, g_strerror(errno));\n            return -1;\n        }\n        if (! S_ISFIFO(pipe_stat.st_mode)) {\n            if (S_ISCHR(pipe_stat.st_mode)) {\n                /*\n                 * Assume the user specified an interface on a system where\n                 * interfaces are in /dev.  Pretend we haven't seen it.\n                 */\n            } else\n            {\n                fprintf(stderr, \"rawshark: \\\"%s\\\" is neither an interface nor a pipe\\n\",\n                        pipe_name);\n            }\n            return -1;\n        }\n        rfd = ws_open(pipe_name, O_RDONLY | O_NONBLOCK, 0000 /* no creation so don't matter */);\n        if (rfd == -1) {\n            fprintf(stderr, \"rawshark: \\\"%s\\\" could not be opened: %s\\n\",\n                    pipe_name, g_strerror(errno));\n            return -1;\n        }\n#else /* _WIN32 */\n        if (!win32_is_pipe_name(pipe_name)) {\n            fprintf(stderr, \"rawshark: \\\"%s\\\" is neither an interface nor a pipe\\n\",\n                    pipe_name);\n            return -1;\n        }\n\n        /* Wait for the pipe to appear */\n        while (1) {\n            hPipe = CreateFile(utf_8to16(pipe_name), GENERIC_READ, 0, NULL,\n                               OPEN_EXISTING, 0, NULL);\n\n            if (hPipe != INVALID_HANDLE_VALUE)\n                break;\n\n            err = GetLastError();\n            if (err != ERROR_PIPE_BUSY) {\n                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n                              NULL, err, 0, (LPTSTR) &err_str, 0, NULL);\n                fprintf(stderr, \"rawshark: \\\"%s\\\" could not be opened: %s (error %lu)\\n\",\n                        pipe_name, utf_16to8(err_str), err);\n                LocalFree(err_str);\n                return -1;\n            }\n\n            if (!WaitNamedPipe(utf_8to16(pipe_name), 30 * 1000)) {\n                err = GetLastError();\n                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,\n                              NULL, err, 0, (LPTSTR) &err_str, 0, NULL);\n                fprintf(stderr, \"rawshark: \\\"%s\\\" could not be waited for: %s (error %lu)\\n\",\n                        pipe_name, utf_16to8(err_str), err);\n                LocalFree(err_str);\n                return -1;\n            }\n        }\n\n        rfd = _open_osfhandle((intptr_t) hPipe, _O_RDONLY);\n        if (rfd == -1) {\n            fprintf(stderr, \"rawshark: \\\"%s\\\" could not be opened: %s\\n\",\n                    pipe_name, g_strerror(errno));\n            return -1;\n        }\n#endif /* _WIN32 */\n    }\n\n    return rfd;\n}\n\n/**\n * Parse a link-type argument of the form \"encap:<pcap linktype>\" or\n * \"proto:<proto name>\".  \"Pcap linktype\" must be a name conforming to\n * pcap_datalink_name_to_val() or an integer; the integer should be\n * a LINKTYPE_ value supported by Wiretap.  \"Proto name\" must be\n * a protocol name, e.g. \"http\".\n */\nstatic bool\nset_link_type(const char *lt_arg) {\n    char *spec_ptr = strchr(lt_arg, ':');\n    char *p;\n    int dlt_val;\n    long val;\n    dissector_handle_t dhandle;\n    GString *pref_str;\n    char *errmsg = NULL;\n\n    if (!spec_ptr)\n        return false;\n\n    spec_ptr++;\n\n    if (strncmp(lt_arg, \"encap:\", strlen(\"encap:\")) == 0) {\n        dlt_val = linktype_name_to_val(spec_ptr);\n        if (dlt_val == -1) {\n            errno = 0;\n            val = strtol(spec_ptr, &p, 10);\n            if (p == spec_ptr || *p != '\\0' || errno != 0 || val > INT_MAX) {\n                return false;\n            }\n            dlt_val = (int)val;\n        }\n        /*\n         * In those cases where a given link-layer header type\n         * has different LINKTYPE_ and DLT_ values, linktype_name_to_val()\n         * will return the OS's DLT_ value for that link-layer header\n         * type, not its OS-independent LINKTYPE_ value.\n         *\n         * On a given OS, wtap_pcap_encap_to_wtap_encap() should\n         * be able to map either LINKTYPE_ values or DLT_ values\n         * for the OS to the appropriate Wiretap encapsulation.\n         */\n        encap = wtap_pcap_encap_to_wtap_encap(dlt_val);\n        if (encap == WTAP_ENCAP_UNKNOWN) {\n            return false;\n        }\n        return true;\n    } else if (strncmp(lt_arg, \"proto:\", strlen(\"proto:\")) == 0) {\n        dhandle = find_dissector(spec_ptr);\n        if (dhandle) {\n            encap = WTAP_ENCAP_USER0;\n            pref_str = g_string_new(\"uat:user_dlts:\");\n            /* This must match the format used in the user_dlts file */\n            g_string_append_printf(pref_str,\n                                   \"\\\"User 0 (DLT=147)\\\",\\\"%s\\\",\\\"0\\\",\\\"\\\",\\\"0\\\",\\\"\\\"\",\n                                   spec_ptr);\n            if (prefs_set_pref(pref_str->str, &errmsg) != PREFS_SET_OK) {\n                g_string_free(pref_str, TRUE);\n                g_free(errmsg);\n                return false;\n            }\n            g_string_free(pref_str, TRUE);\n            return true;\n        }\n    }\n    return false;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char                *err_msg;\n    int                  opt, i;\n    df_error_t          *df_err;\n\n#if !defined(_WIN32) && defined(RLIMIT_AS)\n    struct rlimit limit;\n#endif  /* !_WIN32 */\n\n    char                *pipe_name = NULL;\n    char                *rfilters[64];\n    e_prefs             *prefs_p;\n    GPtrArray           *disp_fields = g_ptr_array_new();\n    unsigned             fc;\n    bool                 skip_pcap_header = false;\n    int                  ret = EXIT_SUCCESS;\n    static const struct ws_option long_options[] = {\n      {\"help\", ws_no_argument, NULL, 'h'},\n      {\"version\", ws_no_argument, NULL, 'v'},\n      LONGOPT_DISSECT_COMMON\n      LONGOPT_READ_CAPTURE_COMMON\n      {0, 0, 0, 0 }\n    };\n\n#define OPTSTRING_INIT OPTSTRING_DISSECT_COMMON OPTSTRING_READ_CAPTURE_COMMON \"F:hlm:o:psS:v\"\n\n    static const char    optstring[] = OPTSTRING_INIT;\n\n    /* Set the program name. */\n    g_set_prgname(\"rawshark\");\n\n    /*\n     * Set the C-language locale to the native environment and set the\n     * code page to UTF-8 on Windows.\n     */\n#ifdef _WIN32\n    setlocale(LC_ALL, \".UTF-8\");\n#else\n    setlocale(LC_ALL, \"\");\n#endif\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, WS_EXIT_INVALID_OPTION);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n#ifdef _WIN32\n    create_app_running_mutex();\n#endif /* _WIN32 */\n\n    /*\n     * Get credential information for later use.\n     */\n    init_process_policies();\n\n    /*\n     * Clear the filters arrays\n     */\n    memset(rfilters, 0, sizeof(rfilters));\n    memset(rfcodes, 0, sizeof(rfcodes));\n    n_rfilters = 0;\n    n_rfcodes = 0;\n\n    /*\n     * Initialize our string format\n     */\n    string_fmts = g_ptr_array_new();\n\n    /*\n     * Attempt to get the pathname of the directory containing the\n     * executable file.\n     */\n    err_msg = configuration_init(argv[0]);\n    if (err_msg != NULL) {\n        fprintf(stderr, \"rawshark: Can't get pathname of rawshark program: %s.\\n\",\n                err_msg);\n    }\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"Rawshark\",\n                         epan_gather_compile_info,\n                         NULL);\n\n    init_report_failure_message(\"rawshark\");\n\n    timestamp_set_type(TS_RELATIVE);\n    timestamp_set_precision(TS_PREC_AUTO);\n    timestamp_set_seconds_type(TS_SECONDS_DEFAULT);\n\n    /*\n     * XXX - is this necessary, given that we're not reading a\n     * regular capture file, we're reading rawshark's packet\n     * stream format?\n     *\n     * If it is, note that libwiretap must be initialized before\n     * libwireshark is, so that dissection-time handlers for\n     * file-type-dependent blocks can register using the file\n     * type/subtype value for the file type.\n     */\n    wtap_init(false);\n\n    /* Register all dissectors; we must do this before checking for the\n       \"-G\" flag, as the \"-G\" flag dumps information registered by the\n       dissectors, and we must do it before we read the preferences, in\n       case any dissectors register preferences. */\n    if (!epan_init(NULL, NULL, true)) {\n        ret = WS_EXIT_INIT_FAILED;\n        goto clean_exit;\n    }\n\n    /* Load libwireshark settings from the current profile. */\n    prefs_p = epan_load_settings();\n\n#ifdef _WIN32\n    ws_init_dll_search_path();\n    /* Load Wpcap, if possible */\n    load_wpcap();\n#endif\n\n    cap_file_init(&cfile);\n\n    /* Print format defaults to this. */\n    print_format = PR_FMT_TEXT;\n\n    /* Initialize our encapsulation type */\n    encap = WTAP_ENCAP_UNKNOWN;\n\n    /* Now get our args */\n    /* XXX - We should probably have an option to dump libpcap link types */\n    while ((opt = ws_getopt_long(argc, argv, optstring, long_options, NULL)) != -1) {\n        switch (opt) {\n            case 'd':        /* Payload type */\n                /* XXX: This option should probably be changed so it doesn't\n                 * conflict with the common dissection option for Decode As.\n                 */\n                if (!set_link_type(ws_optarg)) {\n                    cmdarg_err(\"Invalid link type or protocol \\\"%s\\\"\", ws_optarg);\n                    ret = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'F':        /* Read field to display */\n                g_ptr_array_add(disp_fields, g_strdup(ws_optarg));\n                break;\n            case 'h':        /* Print help and exit */\n                show_help_header(\"Dump and analyze network traffic.\");\n                print_usage(stdout);\n                goto clean_exit;\n                break;\n            case 'l':        /* \"Line-buffer\" standard output */\n                /* This isn't line-buffering, strictly speaking, it's just\n                   flushing the standard output after the information for\n                   each packet is printed; however, that should be good\n                   enough for all the purposes to which \"-l\" is put (and\n                   is probably actually better for \"-V\", as it does fewer\n                   writes).\n\n                   See the comment in \"process_packet()\" for an explanation of\n                   why we do that, and why we don't just use \"setvbuf()\" to\n                   make the standard output line-buffered (short version: in\n                   Windows, \"line-buffered\" is the same as \"fully-buffered\",\n                   and the output buffer is only flushed when it fills up). */\n                line_buffered = true;\n                break;\n#if !defined(_WIN32) && defined(RLIMIT_AS)\n            case 'm':\n                limit.rlim_cur = get_positive_int(ws_optarg, \"memory limit\");\n                limit.rlim_max = get_positive_int(ws_optarg, \"memory limit\");\n\n                if(setrlimit(RLIMIT_AS, &limit) != 0) {\n                    cmdarg_err(\"setrlimit(RLIMIT_AS) failed: %s\",\n                               g_strerror(errno));\n                    ret = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n#endif\n            case 'o':        /* Override preference from command line */\n            {\n                char *errmsg = NULL;\n\n                switch (prefs_set_pref(ws_optarg, &errmsg)) {\n\n                    case PREFS_SET_OK:\n                        break;\n\n                    case PREFS_SET_SYNTAX_ERR:\n                        cmdarg_err(\"Invalid -o flag \\\"%s\\\"%s%s\", ws_optarg,\n                                errmsg ? \": \" : \"\", errmsg ? errmsg : \"\");\n                        g_free(errmsg);\n                        ret = WS_EXIT_INVALID_OPTION;\n                        goto clean_exit;\n                        break;\n\n                    case PREFS_SET_NO_SUCH_PREF:\n                        cmdarg_err(\"-o flag \\\"%s\\\" specifies unknown preference\", ws_optarg);\n                        ret = WS_EXIT_INVALID_OPTION;\n                        goto clean_exit;\n                        break;\n\n                    case PREFS_SET_OBSOLETE:\n                        cmdarg_err(\"-o flag \\\"%s\\\" specifies obsolete preference\", ws_optarg);\n                        ret = WS_EXIT_INVALID_OPTION;\n                        goto clean_exit;\n                        break;\n                }\n                break;\n            }\n            case 'p':        /* Expect pcap_pkthdr packet headers, which may have 64-bit timestamps */\n                want_pcap_pkthdr = true;\n                break;\n            case 'r':        /* Read capture file xxx */\n                pipe_name = g_strdup(ws_optarg);\n                break;\n            case 'R':        /* Read file filter */\n            case 'Y':        /* Read file filter */\n                /* Read and display filters are the same for rawshark */\n                if(n_rfilters < (int)array_length(rfilters)) {\n                    rfilters[n_rfilters++] = ws_optarg;\n                }\n                else {\n                    cmdarg_err(\"Too many display filters\");\n                    ret = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 's':        /* Skip PCAP header */\n                skip_pcap_header = true;\n                break;\n            case 'S':        /* Print string representations */\n                if (!parse_field_string_format(ws_optarg)) {\n                    cmdarg_err(\"Invalid field string format\");\n                    ret = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'v':        /* Show version and exit */\n            {\n                show_version();\n                goto clean_exit;\n            }\n            /* Common dissection options - 'd' for Decode As also makes\n             * sense, but rawshark uses it for the payload link layer/\n             * dissector selection.\n             */\n            case 'K':        /* Kerberos keytab file */\n            case 'n':        /* No name resolution */\n            case 'N':        /* Select what types of addresses/port #s to resolve */\n            case 't':        /* Time stamp type */\n            case 'u':        /* Seconds type */\n            case LONGOPT_DISABLE_PROTOCOL: /* disable dissection of protocol */\n            case LONGOPT_ENABLE_HEURISTIC: /* enable heuristic dissection of protocol */\n            case LONGOPT_DISABLE_HEURISTIC: /* disable heuristic dissection of protocol */\n            case LONGOPT_ENABLE_PROTOCOL: /* enable dissection of protocol (that is disabled by default) */\n            case LONGOPT_ONLY_PROTOCOLS: /* enable dissection of only this comma separated list of protocols */\n            case LONGOPT_DISABLE_ALL_PROTOCOLS: /* enable dissection of protocol (that is disabled by default) */\n                if (!dissect_opts_handle_opt(opt, ws_optarg)) {\n                    ret = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            default:\n            case '?':        /* Bad flag - print usage message */\n                print_usage(stderr);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n        }\n    }\n\n    /* Notify all registered modules that have had any of their preferences\n       changed either from one of the preferences file or from the command\n       line that their preferences have changed.\n       Initialize preferences before display filters, otherwise modules\n       like MATE won't work. */\n    prefs_apply_all();\n\n    /* Initialize our display fields */\n    for (fc = 0; fc < disp_fields->len; fc++) {\n        protocolinfo_init((char *)g_ptr_array_index(disp_fields, fc));\n    }\n    g_ptr_array_free(disp_fields, TRUE);\n    printf(\"\\n\");\n    fflush(stdout);\n\n    /* If no capture filter or read filter has been specified, and there are\n       still command-line arguments, treat them as the tokens of a capture\n       filter (if no \"-r\" flag was specified) or a read filter (if a \"-r\"\n       flag was specified. */\n    if (ws_optind < argc) {\n        if (pipe_name != NULL) {\n            if (n_rfilters != 0) {\n                cmdarg_err(\"Read filters were specified both with \\\"-R\\\" \"\n                           \"and with additional command-line arguments\");\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            rfilters[n_rfilters] = get_args_as_string(argc, argv, ws_optind);\n        }\n    }\n\n    /* Make sure we got a dissector handle for our payload. */\n    if (encap == WTAP_ENCAP_UNKNOWN) {\n        cmdarg_err(\"No valid payload dissector specified.\");\n        ret = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    err_msg = ws_init_sockets();\n    if (err_msg != NULL)\n    {\n        cmdarg_err(\"%s\", err_msg);\n        g_free(err_msg);\n        cmdarg_err_cont(\"%s\", please_report_bug());\n        ret = WS_EXIT_INIT_FAILED;\n        goto clean_exit;\n    }\n\n    if (global_dissect_options.time_format != TS_NOT_SET)\n        timestamp_set_type(global_dissect_options.time_format);\n    if (global_dissect_options.time_precision != TS_PREC_NOT_SET)\n        timestamp_set_precision(global_dissect_options.time_precision);\n\n    /*\n     * Enabled and disabled protocols and heuristic dissectors as per\n     * command-line options.\n     */\n    if (!setup_enabled_and_disabled_protocols()) {\n        ret = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    /* Build the column format array */\n    build_column_format_array(&cfile.cinfo, prefs_p->num_cols, true);\n\n    if (n_rfilters != 0) {\n        for (i = 0; i < n_rfilters; i++) {\n            if (!dfilter_compile(rfilters[i], &rfcodes[n_rfcodes], &df_err)) {\n                cmdarg_err(\"%s\", df_err->msg);\n                df_error_free(&df_err);\n                ret = INVALID_DFILTER;\n                goto clean_exit;\n            }\n            n_rfcodes++;\n        }\n    }\n\n    if (pipe_name) {\n        /*\n         * We're reading a pipe (or capture file).\n         */\n\n        /*\n         * Immediately relinquish any special privileges we have; we must not\n         * be allowed to read any capture files the user running Rawshark\n         * can't open.\n         */\n        relinquish_special_privs_perm();\n\n        if (raw_cf_open(&cfile, pipe_name) != CF_OK) {\n            ret = WS_EXIT_OPEN_ERROR;\n            goto clean_exit;\n        }\n\n        /* Do we need to PCAP header and magic? */\n        if (skip_pcap_header) {\n            unsigned int bytes_left = (unsigned int) sizeof(struct pcap_hdr) + sizeof(uint32_t);\n            char buf[sizeof(struct pcap_hdr) + sizeof(uint32_t)];\n            while (bytes_left != 0) {\n                ssize_t bytes = ws_read(fd, buf, bytes_left);\n                if (bytes <= 0) {\n                    cmdarg_err(\"Not enough bytes for pcap header.\");\n                    ret =  FORMAT_ERROR;\n                    goto clean_exit;\n                }\n                bytes_left -= (unsigned int)bytes;\n            }\n        }\n\n        /* Process the packets in the file */\n        if (!load_cap_file(&cfile)) {\n            ret = WS_EXIT_OPEN_ERROR;\n            goto clean_exit;\n        }\n    } else {\n        /* If you want to capture live packets, use TShark. */\n        cmdarg_err(\"Input file or pipe name not specified.\");\n        ret = WS_EXIT_OPEN_ERROR;\n        goto clean_exit;\n    }\n\nclean_exit:\n    g_free(pipe_name);\n    epan_free(cfile.epan);\n    epan_cleanup();\n    wtap_cleanup();\n    return ret;\n}\n\n/**\n * Read data from a raw pipe.  The \"raw\" data consists of a libpcap\n * packet header followed by the payload.\n * @param rec [IN/OUT] A wtap_rec into which to read packet metadata\n *           and data.\n * @param err [OUT] Error indicator.  Uses wiretap values.\n * @param err_info [OUT] Error message.\n * @param data_offset [OUT] data offset in the pipe.\n * @return true on success, false on failure.\n */\nstatic bool\nraw_pipe_read(wtap_rec *rec, int *err, char **err_info, int64_t *data_offset) {\n    struct pcap_pkthdr mem_hdr;\n    struct pcaprec_hdr disk_hdr;\n    ssize_t bytes_read = 0;\n    unsigned int bytes_needed = (unsigned int) sizeof(disk_hdr);\n    unsigned char *ptr = (unsigned char*) &disk_hdr;\n\n    *err = 0;\n\n    if (want_pcap_pkthdr) {\n        bytes_needed = sizeof(mem_hdr);\n        ptr = (unsigned char*) &mem_hdr;\n    }\n\n    /*\n     * Newer versions of the VC runtime do parameter validation. If stdin\n     * has been closed, calls to _read, _get_osfhandle, et al will trigger\n     * the invalid parameter handler and crash.\n     * We could alternatively use ReadFile or set an invalid parameter\n     * handler.\n     * We could also tell callers not to close stdin prematurely.\n     */\n#ifdef _WIN32\n    DWORD ghi_flags;\n    if (fd == 0 && GetHandleInformation(GetStdHandle(STD_INPUT_HANDLE), &ghi_flags) == 0) {\n        *err = 0;\n        *err_info = NULL;\n        return false;\n    }\n#endif\n\n    /* Copied from capture_loop.c */\n    while (bytes_needed > 0) {\n        bytes_read = ws_read(fd, ptr, bytes_needed);\n        if (bytes_read == 0) {\n            *err = 0;\n            *err_info = NULL;\n            return false;\n        } else if (bytes_read < 0) {\n            *err = errno;\n            *err_info = NULL;\n            return false;\n        }\n        bytes_needed -= (unsigned int)bytes_read;\n        *data_offset += bytes_read;\n        ptr += bytes_read;\n    }\n\n    rec->rec_type = REC_TYPE_PACKET;\n    rec->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n    if (want_pcap_pkthdr) {\n        rec->ts.secs = mem_hdr.ts.tv_sec;\n        rec->ts.nsecs = (int32_t)mem_hdr.ts.tv_usec * 1000;\n        rec->rec_header.packet_header.caplen = mem_hdr.caplen;\n        rec->rec_header.packet_header.len = mem_hdr.len;\n    } else {\n        rec->ts.secs = disk_hdr.ts_sec;\n        rec->ts.nsecs = disk_hdr.ts_usec * 1000;\n        rec->rec_header.packet_header.caplen = disk_hdr.incl_len;\n        rec->rec_header.packet_header.len = disk_hdr.orig_len;\n    }\n    bytes_needed = rec->rec_header.packet_header.caplen;\n\n    rec->rec_header.packet_header.pkt_encap = encap;\n\n#if 0\n    printf(\"mem_hdr: %lu disk_hdr: %lu\\n\", sizeof(mem_hdr), sizeof(disk_hdr));\n    printf(\"tv_sec: %d (%04x)\\n\", (unsigned int) rec->ts.secs, (unsigned int) rec->ts.secs);\n    printf(\"tv_nsec: %d (%04x)\\n\", rec->ts.nsecs, rec->ts.nsecs);\n    printf(\"caplen: %d (%04x)\\n\", rec->rec_header.packet_header.caplen, rec->rec_header.packet_header.caplen);\n    printf(\"len: %d (%04x)\\n\", rec->rec_header.packet_header.len, rec->rec_header.packet_header.len);\n#endif\n    if (bytes_needed > WTAP_MAX_PACKET_SIZE_STANDARD) {\n        *err = WTAP_ERR_BAD_FILE;\n        *err_info = ws_strdup_printf(\"Bad packet length: %lu\",\n                   (unsigned long) bytes_needed);\n        return false;\n    }\n\n    ws_buffer_assure_space(&rec->data, bytes_needed);\n    ptr = ws_buffer_start_ptr(&rec->data);\n    while (bytes_needed > 0) {\n        bytes_read = ws_read(fd, ptr, bytes_needed);\n        if (bytes_read == 0) {\n            *err = WTAP_ERR_SHORT_READ;\n            *err_info = NULL;\n            return false;\n        } else if (bytes_read < 0) {\n            *err = errno;\n            *err_info = NULL;\n            return false;\n        }\n        bytes_needed -= (unsigned int)bytes_read;\n        *data_offset += bytes_read;\n        ptr += bytes_read;\n    }\n    return true;\n}\n\nstatic bool\nload_cap_file(capture_file *cf)\n{\n    int          err;\n    char        *err_info = NULL;\n    int64_t      data_offset = 0;\n\n    wtap_rec     rec;\n    epan_dissect_t edt;\n\n    wtap_rec_init(&rec, 1514);\n\n    epan_dissect_init(&edt, cf->epan, true, false);\n\n    while (raw_pipe_read(&rec, &err, &err_info, &data_offset)) {\n        process_packet(cf, &edt, data_offset, &rec);\n    }\n\n    epan_dissect_cleanup(&edt);\n\n    wtap_rec_cleanup(&rec);\n    if (err != 0) {\n        /* Print a message noting that the read failed somewhere along the line. */\n        cfile_read_failure_message(cf->filename, err, err_info);\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool\nprocess_packet(capture_file *cf, epan_dissect_t *edt, int64_t offset,\n               wtap_rec *rec)\n{\n    frame_data fdata;\n    bool passed;\n    int i;\n\n    if(rec->rec_header.packet_header.len == 0)\n    {\n        /* The user sends an empty packet when he wants to get output from us even if we don't currently have\n           packets to process. We spit out a line with the timestamp and the text \"void\"\n        */\n        printf(\"%lu %\" PRIu64 \" %d void -\\n\", (unsigned long int)cf->count,\n               (uint64_t)rec->ts.secs, rec->ts.nsecs);\n\n        fflush(stdout);\n\n        return false;\n    }\n\n    /* Count this packet. */\n    cf->count++;\n\n    /* If we're going to print packet information, or we're going to\n       run a read filter, or we're going to process taps, set up to\n       do a dissection and do so. */\n    frame_data_init(&fdata, cf->count, rec, offset, cum_bytes);\n\n    passed = true;\n\n    /* If we're running a read filter, prime the epan_dissect_t with that\n       filter. */\n    if (n_rfilters > 0) {\n        for(i = 0; i < n_rfcodes; i++) {\n            epan_dissect_prime_with_dfilter(edt, rfcodes[i]);\n        }\n    }\n\n    printf(\"%lu\", (unsigned long int) cf->count);\n\n    frame_data_set_before_dissect(&fdata, &cf->elapsed_time,\n                                  &cf->provider.ref, cf->provider.prev_dis);\n\n    if (cf->provider.ref == &fdata) {\n       ref_frame = fdata;\n       cf->provider.ref = &ref_frame;\n    }\n\n    /* We only need the columns if we're printing packet info but we're\n     *not* verbose; in verbose mode, we print the protocol tree, not\n     the protocol summary. */\n    epan_dissect_run_with_taps(edt, cf->cd_t, rec, &fdata, &cf->cinfo);\n\n    frame_data_set_after_dissect(&fdata, &cum_bytes);\n    prev_dis_frame = fdata;\n    cf->provider.prev_dis = &prev_dis_frame;\n\n    prev_cap_frame = fdata;\n    cf->provider.prev_cap = &prev_cap_frame;\n\n    for(i = 0; i < n_rfilters; i++) {\n        /* Run the read filter if we have one. */\n        if (rfcodes[i])\n            passed = dfilter_apply_edt(rfcodes[i], edt);\n        else\n            passed = true;\n\n        /* Print a one-line summary */\n        printf(\" %d\", passed ? 1 : 0);\n    }\n\n    printf(\" -\\n\");\n\n    /* The ANSI C standard does not appear to *require* that a line-buffered\n       stream be flushed to the host environment whenever a newline is\n       written, it just says that, on such a stream, characters \"are\n       intended to be transmitted to or from the host environment as a\n       block when a new-line character is encountered\".\n\n       The Visual C++ 6.0 C implementation doesn't do what is intended;\n       even if you set a stream to be line-buffered, it still doesn't\n       flush the buffer at the end of every line.\n\n       So, if the \"-l\" flag was specified, we flush the standard output\n       at the end of a packet.  This will do the right thing if we're\n       printing packet summary lines, and, as we print the entire protocol\n       tree for a single packet without waiting for anything to happen,\n       it should be as good as line-buffered mode if we're printing\n       protocol trees.  (The whole reason for the \"-l\" flag in either\n       tcpdump or Rawshark is to allow the output of a live capture to\n       be piped to a program or script and to have that script see the\n       information for the packet as soon as it's printed, rather than\n       having to wait until a standard I/O buffer fills up. */\n    if (line_buffered)\n        fflush(stdout);\n\n    if (ferror(stdout)) {\n        show_print_file_io_error(errno);\n        exit(2);\n    }\n\n    epan_dissect_reset(edt);\n    frame_data_destroy(&fdata);\n\n    return passed;\n}\n\n/****************************************************************************************\n * FIELD EXTRACTION ROUTINES\n ****************************************************************************************/\ntypedef struct _pci_t {\n    char *filter;\n    int hf_index;\n    int cmd_line_index;\n} pci_t;\n\nstatic const char* ftenum_to_string(header_field_info *hfi)\n{\n    const char* str;\n    if (!hfi) {\n        return \"n.a.\";\n    }\n\n    if (string_fmts->len > 0 && hfi->strings) {\n        return \"FT_STRING\";\n    }\n\n    str = ftype_name(hfi->type);\n    if (str == NULL) {\n        str = \"n.a.\";\n    }\n\n    return str;\n}\n\nstatic void field_display_to_string(header_field_info *hfi, char* buf, int size)\n{\n    if (hfi->type != FT_BOOLEAN)\n    {\n        (void) g_strlcpy(buf, proto_field_display_to_string(hfi->display), size);\n    }\n    else\n    {\n        snprintf(buf, size, \"(Bit count: %d)\", hfi->display);\n    }\n}\n\n/*\n * Copied from various parts of proto.c\n */\n#define FIELD_STR_INIT_LEN 256\n#define cVALS(x) (const value_string*)(x)\nstatic bool print_field_value(field_info *finfo, int cmd_line_index)\n{\n    const header_field_info *hfinfo;\n    char                *fs_buf;\n    char                *fs_ptr = NULL;\n    static GString     *label_s = NULL;\n    size_t              fs_len;\n    unsigned           i;\n    string_fmt_t       *sf;\n    uint32_t           uvalue;\n    int32_t            svalue;\n    uint64_t           uvalue64;\n    int64_t            svalue64;\n\n    hfinfo = finfo->hfinfo;\n\n    if (!label_s) {\n        label_s = g_string_new(\"\");\n    }\n\n    fs_buf = fvalue_to_string_repr(NULL, finfo->value,\n                          FTREPR_DFILTER, finfo->hfinfo->display);\n    if (fs_buf != NULL) {\n        /*\n         * this field has an associated value,\n         * e.g: ip.hdr_len\n         */\n        fs_len = strlen(fs_buf);\n        fs_ptr = fs_buf;\n\n        /* String types are quoted. Remove them. */\n        if (FT_IS_STRING(fvalue_type_ftenum(finfo->value)) && fs_len > 2) {\n            fs_buf[fs_len - 1] = '\\0';\n            fs_ptr++;\n        }\n    }\n\n    if (string_fmts->len > 0 && finfo->hfinfo->strings) {\n        g_string_truncate(label_s, 0);\n        for (i = 0; i < string_fmts->len; i++) {\n            sf = (string_fmt_t *)g_ptr_array_index(string_fmts, i);\n            if (sf->plain) {\n                g_string_append(label_s, sf->plain);\n            } else {\n                switch (sf->format) {\n                    case SF_NAME:\n                        g_string_append(label_s, hfinfo->name);\n                        break;\n                    case SF_NUMVAL:\n                        g_string_append(label_s, fs_ptr);\n                        break;\n                    case SF_STRVAL:\n                        switch(hfinfo->type) {\n                            case FT_BOOLEAN:\n                                uvalue64 = fvalue_get_uinteger64(finfo->value);\n                                g_string_append(label_s, tfs_get_string(!!uvalue64, hfinfo->strings));\n                                break;\n                            case FT_INT8:\n                            case FT_INT16:\n                            case FT_INT24:\n                            case FT_INT32:\n                                DISSECTOR_ASSERT(!hfinfo->bitmask);\n                                svalue = fvalue_get_sinteger(finfo->value);\n                                if (hfinfo->display & BASE_RANGE_STRING) {\n                                    g_string_append(label_s, rval_to_str_const(svalue, (const range_string *) hfinfo->strings, \"Unknown\"));\n                                } else if (hfinfo->display & BASE_EXT_STRING) {\n                                    g_string_append(label_s, val_to_str_ext_const(svalue, (value_string_ext *) hfinfo->strings, \"Unknown\"));\n                                } else {\n                                    g_string_append(label_s, val_to_str_const(svalue, cVALS(hfinfo->strings), \"Unknown\"));\n                                }\n                                break;\n                            case FT_INT40: /* XXX: Shouldn't these be as smart as FT_INT{8,16,24,32}? */\n                            case FT_INT48:\n                            case FT_INT56:\n                            case FT_INT64:\n                                DISSECTOR_ASSERT(!hfinfo->bitmask);\n                                svalue64 = fvalue_get_sinteger64(finfo->value);\n                                if (hfinfo->display & BASE_VAL64_STRING) {\n                                    g_string_append(label_s, val64_to_str_const(svalue64, (const val64_string *)(hfinfo->strings), \"Unknown\"));\n                                }\n                                break;\n                            case FT_UINT8:\n                            case FT_UINT16:\n                            case FT_UINT24:\n                            case FT_UINT32:\n                                DISSECTOR_ASSERT(!hfinfo->bitmask);\n                                uvalue = fvalue_get_uinteger(finfo->value);\n                                if (!hfinfo->bitmask && hfinfo->display & BASE_RANGE_STRING) {\n                                    g_string_append(label_s, rval_to_str_const(uvalue, (const range_string *) hfinfo->strings, \"Unknown\"));\n                                } else if (hfinfo->display & BASE_EXT_STRING) {\n                                    g_string_append(label_s, val_to_str_ext_const(uvalue, (value_string_ext *) hfinfo->strings, \"Unknown\"));\n                                } else {\n                                    g_string_append(label_s, val_to_str_const(uvalue, cVALS(hfinfo->strings), \"Unknown\"));\n                                }\n                                break;\n                            case FT_UINT40: /* XXX: Shouldn't these be as smart as FT_INT{8,16,24,32}? */\n                            case FT_UINT48:\n                            case FT_UINT56:\n                            case FT_UINT64:\n                                DISSECTOR_ASSERT(!hfinfo->bitmask);\n                                uvalue64 = fvalue_get_uinteger64(finfo->value);\n                                if (hfinfo->display & BASE_VAL64_STRING) {\n                                    g_string_append(label_s, val64_to_str_const(uvalue64, (const val64_string *)(hfinfo->strings), \"Unknown\"));\n                                }\n                                break;\n                            default:\n                                break;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n        printf(\" %d=\\\"%s\\\"\", cmd_line_index, label_s->str);\n        wmem_free(NULL, fs_buf);\n        return true;\n    }\n\n    if(fs_buf)\n    {\n        printf(\" %d=\\\"%s\\\"\", cmd_line_index, fs_ptr);\n        wmem_free(NULL, fs_buf);\n        return true;\n    }\n\n    /*\n     * This field doesn't have an associated value,\n     * e.g. http\n     * We return n.a.\n     */\n    printf(\" %d=\\\"n.a.\\\"\", cmd_line_index);\n    return true;\n}\n\nstatic tap_packet_status\nprotocolinfo_packet(void *prs, packet_info *pinfo _U_, epan_dissect_t *edt, const void *dummy _U_, tap_flags_t flags _U_)\n{\n    pci_t *rs=(pci_t *)prs;\n    GPtrArray *gp;\n    unsigned i;\n\n    gp=proto_get_finfo_ptr_array(edt->tree, rs->hf_index);\n    if(!gp){\n        printf(\" n.a.\");\n        return TAP_PACKET_DONT_REDRAW;\n    }\n\n    /*\n     * Print each occurrence of the field\n     */\n    for (i = 0; i < gp->len; i++) {\n        print_field_value((field_info *)gp->pdata[i], rs->cmd_line_index);\n    }\n\n    return TAP_PACKET_DONT_REDRAW;\n}\n\nint g_cmd_line_index;\n\n/*\n * field must be persistent - we don't g_strdup() it below\n */\nstatic void\nprotocolinfo_init(char *field)\n{\n    pci_t *rs;\n    header_field_info *hfi;\n    GString *error_string;\n    char hfibuf[100];\n\n    hfi=proto_registrar_get_byname(field);\n    if(!hfi){\n        fprintf(stderr, \"rawshark: Field \\\"%s\\\" doesn't exist.\\n\", field);\n        exit(1);\n    }\n\n    field_display_to_string(hfi, hfibuf, sizeof(hfibuf));\n    printf(\"%d %s %s - \",\n            g_cmd_line_index,\n            ftenum_to_string(hfi),\n            hfibuf);\n\n    rs=g_new(pci_t, 1);\n    rs->hf_index=hfi->id;\n    rs->filter=field;\n    rs->cmd_line_index = g_cmd_line_index++;\n\n    error_string=register_tap_listener(\"frame\", rs, rs->filter, TL_REQUIRES_PROTO_TREE, NULL, protocolinfo_packet, NULL, NULL);\n    if(error_string){\n        /* error, we failed to attach to the tap. complain and clean up */\n        fprintf(stderr, \"rawshark: Couldn't register field extraction tap: %s\\n\",\n                error_string->str);\n        g_string_free(error_string, TRUE);\n        if(rs->filter){\n            g_free(rs->filter);\n        }\n        g_free(rs);\n\n        exit(1);\n    }\n}\n\n/*\n * Given a format string, split it into a GPtrArray of string_fmt_t structs\n * and fill in string_fmt_parts.\n */\n\nstatic void\nadd_string_fmt(string_fmt_e format, char *plain) {\n    string_fmt_t *sf = g_new(string_fmt_t, 1);\n\n    sf->format = format;\n    sf->plain = g_strdup(plain);\n\n    g_ptr_array_add(string_fmts, sf);\n}\n\nstatic bool\nparse_field_string_format(char *format) {\n    size_t len;\n    size_t pos = 0;\n\n    if (!format) {\n        return false;\n    }\n\n    GString *plain_s = g_string_new(\"\");\n\n    len = strlen(format);\n    g_ptr_array_set_size(string_fmts, 0);\n\n    while (pos < len) {\n        if (format[pos] == '%') {\n            if (pos >= (len-1)) { /* There should always be a following specifier character */\n                return false;\n            }\n            pos++;\n            if (plain_s->len > 0) {\n                add_string_fmt(SF_NONE, plain_s->str);\n                g_string_truncate(plain_s, 0);\n            }\n            switch (format[pos]) {\n                case 'D':\n                    add_string_fmt(SF_NAME, NULL);\n                    break;\n                case 'N':\n                    add_string_fmt(SF_NUMVAL, NULL);\n                    break;\n                case 'S':\n                    add_string_fmt(SF_STRVAL, NULL);\n                    break;\n                case '%':\n                    g_string_append_c(plain_s, '%');\n                    break;\n                default: /* Invalid format */\n                    return false;\n            }\n        } else {\n            g_string_append_c(plain_s, format[pos]);\n        }\n        pos++;\n    }\n\n    if (plain_s->len > 0) {\n        add_string_fmt(SF_NONE, plain_s->str);\n    }\n    g_string_free(plain_s, TRUE);\n\n    return true;\n}\n/****************************************************************************************\n * END OF FIELD EXTRACTION ROUTINES\n ****************************************************************************************/\n\nstatic void\nshow_print_file_io_error(int err)\n{\n    switch (err) {\n\n        case ENOSPC:\n            cmdarg_err(\"Not all the packets could be printed because there is \"\n                       \"no space left on the file system.\");\n            break;\n\n#ifdef EDQUOT\n        case EDQUOT:\n            cmdarg_err(\"Not all the packets could be printed because you are \"\n                       \"too close to, or over your disk quota.\");\n            break;\n#endif\n\n        default:\n            cmdarg_err(\"An error occurred while printing packets: %s.\",\n                       g_strerror(err));\n            break;\n    }\n}\n\nstatic epan_t *\nraw_epan_new(capture_file *cf)\n{\n    static const struct packet_provider_funcs funcs = {\n        cap_file_provider_get_frame_ts,\n        cap_file_provider_get_interface_name,\n        cap_file_provider_get_interface_description,\n        NULL,\n    };\n\n    return epan_new(&cf->provider, &funcs);\n}\n\ncf_status_t\nraw_cf_open(capture_file *cf, const char *fname)\n{\n    if ((fd = raw_pipe_open(fname)) < 0)\n        return CF_ERROR;\n\n    /* The open succeeded.  Fill in the information for this file. */\n\n    /* Create new epan session for dissection. */\n    epan_free(cf->epan);\n    cf->epan = raw_epan_new(cf);\n\n    cf->provider.wth = NULL;\n    cf->f_datalen = 0; /* not used, but set it anyway */\n\n    /* Set the file name because we need it to set the follow stream filter.\n       XXX - is that still true?  We need it for other reasons, though,\n       in any case. */\n    cf->filename = g_strdup(fname);\n\n    /* Indicate whether it's a permanent or temporary file. */\n    cf->is_tempfile = false;\n\n    /* No user changes yet. */\n    cf->unsaved_changes = false;\n\n    cf->cd_t      = WTAP_FILE_TYPE_SUBTYPE_UNKNOWN;\n    cf->open_type = WTAP_TYPE_AUTO;\n    cf->count     = 0;\n    cf->drops_known = false;\n    cf->drops     = 0;\n    cf->snap      = 0;\n    nstime_set_zero(&cf->elapsed_time);\n    cf->provider.ref = NULL;\n    cf->provider.prev_dis = NULL;\n    cf->provider.prev_cap = NULL;\n\n    return CF_OK;\n}\n\n/*\n * Editor modelines\n *\n * Local Variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * ex: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "reordercap.c",
          "type": "blob",
          "size": 10.5048828125,
          "content": "/* Reorder the frames from an input dump file, and write to output dump file.\n * Martin Mathieson and Jakub Jawadzki\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glib.h>\n\n#include <ws_exit_codes.h>\n#include <wsutil/ws_getopt.h>\n\n#include <wiretap/wtap.h>\n\n#include <wsutil/cmdarg_err.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/file_util.h>\n#include <wsutil/privileges.h>\n#include <cli_main.h>\n#include <wsutil/version_info.h>\n#include <wiretap/wtap_opttypes.h>\n\n#ifdef HAVE_PLUGINS\n#include <wsutil/plugins.h>\n#endif\n\n#include <wsutil/wslog.h>\n\n#include \"ui/failure_message.h\"\n\n/* Additional exit codes */\n#define OUTPUT_FILE_ERROR 1\n\n/* Show command-line usage */\nstatic void\nprint_usage(FILE *output)\n{\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: reordercap [options] <infile> <outfile>\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Options:\\n\");\n    fprintf(output, \"  -n                don't write to output file if the input file is ordered.\\n\");\n    fprintf(output, \"  -h, --help        display this help and exit.\\n\");\n    fprintf(output, \"  -v, --version     print version information and exit.\\n\");\n}\n\n/* Remember where this frame was in the file */\ntypedef struct FrameRecord_t {\n    int64_t      offset;\n    unsigned     num;\n\n    nstime_t     frame_time;\n} FrameRecord_t;\n\n\n/**************************************************/\n/* Debugging only                                 */\n\n/* Enable this symbol to see debug output */\n/* #define REORDER_DEBUG */\n\n#ifdef REORDER_DEBUG\n#define DEBUG_PRINT printf\n#else\n#define DEBUG_PRINT(...)\n#endif\n/**************************************************/\n\n\nstatic void\nframe_write(FrameRecord_t *frame, wtap *wth, wtap_dumper *pdh,\n            wtap_rec *rec, const char *infile, const char *outfile)\n{\n    int    err;\n    char   *err_info;\n\n    DEBUG_PRINT(\"\\nDumping frame (offset=%\" PRIu64 \")\\n\",\n                frame->offset);\n\n\n    /* Re-read the frame from the stored location */\n    if (!wtap_seek_read(wth, frame->offset, rec, &err, &err_info)) {\n        if (err != 0) {\n            /* Print a message noting that the read failed somewhere along the line. */\n            fprintf(stderr,\n                    \"reordercap: An error occurred while re-reading \\\"%s\\\".\\n\",\n                    infile);\n            cfile_read_failure_message(infile, err, err_info);\n            exit(1);\n        }\n    }\n\n    /* Copy, and set length and timestamp from item. */\n    /* TODO: remove when wtap_seek_read() fills in rec,\n       including time stamps, for all file types  */\n    rec->ts = frame->frame_time;\n\n    /* Dump frame to outfile */\n    if (!wtap_dump(pdh, rec, ws_buffer_start_ptr(&rec->data), &err, &err_info)) {\n        cfile_write_failure_message(infile, outfile, err, err_info, frame->num,\n                                    wtap_file_type_subtype(wth));\n        exit(1);\n    }\n    wtap_rec_reset(rec);\n}\n\n/* Comparing timestamps between 2 frames.\n   negative if (t1 < t2)\n   zero     if (t1 == t2)\n   positive if (t1 > t2)\n*/\nstatic int\nframes_compare(const void *a, const void *b)\n{\n    const FrameRecord_t *frame1 = *(const FrameRecord_t *const *) a;\n    const FrameRecord_t *frame2 = *(const FrameRecord_t *const *) b;\n\n    const nstime_t *time1 = &frame1->frame_time;\n    const nstime_t *time2 = &frame2->frame_time;\n\n    return nstime_cmp(time1, time2);\n}\n\n/********************************************************************/\n/* Main function.                                                   */\n/********************************************************************/\nint\nmain(int argc, char *argv[])\n{\n    char *configuration_init_error;\n    wtap *wth = NULL;\n    wtap_dumper *pdh = NULL;\n    wtap_rec rec;\n    int err;\n    char *err_info;\n    int64_t data_offset;\n    unsigned wrong_order_count = 0;\n    bool write_output_regardless = true;\n    unsigned i;\n    wtap_dump_params params;\n    int                          ret = EXIT_SUCCESS;\n\n    GPtrArray *frames;\n    FrameRecord_t *prevFrame = NULL;\n\n    int opt;\n    static const struct ws_option long_options[] = {\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        {0, 0, 0, 0 }\n    };\n    int file_count;\n    char *infile;\n    const char *outfile;\n\n    /* Set the program name. */\n    g_set_prgname(\"reordercap\");\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, WS_EXIT_INVALID_OPTION);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n    /*\n     * Get credential information for later use.\n     */\n    init_process_policies();\n\n    /*\n     * Attempt to get the pathname of the directory containing the\n     * executable file.\n     */\n    configuration_init_error = configuration_init(argv[0]);\n    if (configuration_init_error != NULL) {\n        fprintf(stderr,\n                \"reordercap: Can't get pathname of directory containing the reordercap program: %s.\\n\",\n                configuration_init_error);\n        g_free(configuration_init_error);\n    }\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"Reordercap\", NULL, NULL);\n\n    init_report_failure_message(\"reordercap\");\n\n    wtap_init(true);\n\n    /* Process the options first */\n    while ((opt = ws_getopt_long(argc, argv, \"hnv\", long_options, NULL)) != -1) {\n        switch (opt) {\n            case 'n':\n                write_output_regardless = false;\n                break;\n            case 'h':\n                show_help_header(\"Reorder timestamps of input file frames into output file.\");\n                print_usage(stdout);\n                goto clean_exit;\n            case 'v':\n                show_version();\n                goto clean_exit;\n            case '?':\n                print_usage(stderr);\n                ret = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n        }\n    }\n\n    /* Remaining args are file names */\n    file_count = argc - ws_optind;\n    if (file_count == 2) {\n        infile  = argv[ws_optind];\n        outfile = argv[ws_optind+1];\n    }\n    else {\n        print_usage(stderr);\n        ret = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    /* Open infile */\n    /* TODO: if reordercap is ever changed to give the user a choice of which\n       open_routine reader to use, then the following needs to change. */\n    wth = wtap_open_offline(infile, WTAP_TYPE_AUTO, &err, &err_info, true);\n    if (wth == NULL) {\n        cfile_open_failure_message(infile, err, err_info);\n        ret = WS_EXIT_OPEN_ERROR;\n        goto clean_exit;\n    }\n    DEBUG_PRINT(\"file_type_subtype is %d\\n\", wtap_file_type_subtype(wth));\n\n    /* Allocate the array of frame pointers. */\n    frames = g_ptr_array_new();\n\n    /* Read each frame from infile */\n    wtap_rec_init(&rec, 1514);\n    while (wtap_read(wth, &rec, &err, &err_info, &data_offset)) {\n        FrameRecord_t *newFrameRecord;\n\n        newFrameRecord = g_slice_new(FrameRecord_t);\n        newFrameRecord->num = frames->len + 1;\n        newFrameRecord->offset = data_offset;\n        if (rec.presence_flags & WTAP_HAS_TS) {\n            newFrameRecord->frame_time = rec.ts;\n        } else {\n            nstime_set_unset(&newFrameRecord->frame_time);\n        }\n\n        if (prevFrame && frames_compare(&newFrameRecord, &prevFrame) < 0) {\n           wrong_order_count++;\n        }\n\n        g_ptr_array_add(frames, newFrameRecord);\n        prevFrame = newFrameRecord;\n        wtap_rec_reset(&rec);\n    }\n    wtap_rec_cleanup(&rec);\n    if (err != 0) {\n      /* Print a message noting that the read failed somewhere along the line. */\n      cfile_read_failure_message(infile, err, err_info);\n    }\n\n    printf(\"%u frames, %u out of order\\n\", frames->len, wrong_order_count);\n\n    wtap_dump_params_init(&params, wth);\n\n    /* Sort the frames */\n    /* XXX - Does this handle multiple SHBs correctly? */\n    if (wrong_order_count > 0) {\n        g_ptr_array_sort(frames, frames_compare);\n    }\n\n\n    /* Avoid writing if already sorted and configured to */\n    if (write_output_regardless || (wrong_order_count > 0)) {\n        /* Open outfile (same filetype/encap as input file) */\n        if (strcmp(outfile, \"-\") == 0) {\n          pdh = wtap_dump_open_stdout(wtap_file_type_subtype(wth),\n                                      WTAP_UNCOMPRESSED, &params, &err, &err_info);\n        } else {\n          pdh = wtap_dump_open(outfile, wtap_file_type_subtype(wth),\n                               WTAP_UNCOMPRESSED, &params, &err, &err_info);\n        }\n        g_free(params.idb_inf);\n        params.idb_inf = NULL;\n\n        if (pdh == NULL) {\n            cfile_dump_open_failure_message(outfile, err, err_info,\n                                            wtap_file_type_subtype(wth));\n            wtap_dump_params_cleanup(&params);\n            ret = OUTPUT_FILE_ERROR;\n            goto clean_exit;\n        }\n\n\n        /* Write out each sorted frame in turn */\n        wtap_rec_init(&rec, 1514);\n        for (i = 0; i < frames->len; i++) {\n            FrameRecord_t *frame = (FrameRecord_t *)frames->pdata[i];\n\n            frame_write(frame, wth, pdh, &rec, infile, outfile);\n\n            g_slice_free(FrameRecord_t, frame);\n        }\n\n        wtap_rec_cleanup(&rec);\n\n\n\n        /* Close outfile */\n        if (!wtap_dump_close(pdh, NULL, &err, &err_info)) {\n            cfile_close_failure_message(outfile, err, err_info);\n            wtap_dump_params_cleanup(&params);\n            ret = OUTPUT_FILE_ERROR;\n            goto clean_exit;\n        }\n    } else {\n        printf(\"Not writing output file because input file is already in order.\\n\");\n\n        /* Free frame memory */\n        for (i = 0; i < frames->len; i++) {\n            FrameRecord_t *frame = (FrameRecord_t *)frames->pdata[i];\n\n            g_slice_free(FrameRecord_t, frame);\n        }\n    }\n\n\n    /* Free the whole array */\n    g_ptr_array_free(frames, TRUE);\n\n    wtap_dump_params_cleanup(&params);\n\n    /* Finally, close infile and release resources. */\n    wtap_close(wth);\n\nclean_exit:\n    wtap_cleanup();\n    free_progdirs();\n    return ret;\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "ringbuffer.c",
          "type": "blob",
          "size": 15.341796875,
          "content": "/* ringbuffer.c\n * Routines for packet capture windows\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n/*\n * <laurent.deniel@free.fr>\n *\n * Almost completely rewritten in order to:\n *\n * - be able to use a unlimited number of ringbuffer files\n * - close the current file and open (truncating) the next file at switch\n * - set the final file name once open (or reopen)\n * - avoid the deletion of files that could not be truncated (can't arise now)\n *   and do not erase empty files\n *\n * The idea behind that is to remove the limitation of the maximum # of\n * ringbuffer files being less than the maximum # of open fd per process\n * and to be able to reduce the amount of virtual memory usage (having only\n * one file open at most) or the amount of file system usage (by truncating\n * the files at switch and not the capture stop, and by closing them which\n * makes possible their move or deletion after a switch).\n *\n */\n\n#include <config.h>\n\n#ifdef HAVE_LIBPCAP\n\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <glib.h>\n\n#include <pcap/pcap.h>\n\n#include <glib.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifdef _WIN32\n#include <wsutil/win32-utils.h>\n#endif\n\n#include \"ringbuffer.h\"\n#include <wsutil/array.h>\n#include <wsutil/file_util.h>\n\n#ifdef HAVE_ZLIBNG\n#define ZLIB_PREFIX(x) zng_ ## x\n#include <zlib-ng.h>\ntypedef zng_stream zlib_stream;\n#else\n#ifdef HAVE_ZLIB\n#define ZLIB_PREFIX(x) x\n#include <zlib.h>\ntypedef z_stream zlib_stream;\n#endif /* HAVE_ZLIB */\n#endif\n\n/* Ringbuffer file structure */\ntypedef struct _rb_file {\n    char          *name;\n} rb_file;\n\n#define MAX_FILENAME_QUEUE  100\n\n/** Ringbuffer data structure */\ntypedef struct _ringbuf_data {\n    rb_file      *files;\n    unsigned      num_files;           /**< Number of ringbuffer files (1 to ...) */\n    unsigned      curr_file_num;       /**< Number of the current file (ever increasing) */\n    char         *fprefix;             /**< Filename prefix */\n    char         *fsuffix;             /**< Filename suffix */\n    bool          nametimenum;         /**< ...num_time... or ...time_num...   */\n    bool          unlimited;           /**< true if unlimited number of files */\n\n    int           fd;                  /**< Current ringbuffer file descriptor */\n    FILE         *pdh;\n    char         *io_buffer;              /**< The IO buffer used to write to the file */\n    bool          group_read_access;   /**< true if files need to be opened with group read access */\n    FILE         *name_h;              /**< write names of completed files to this handle */\n    char         *compress_type;       /**< compress type */\n\n    GMutex        mutex;               /**< mutex for oldnames */\n    char         *oldnames[MAX_FILENAME_QUEUE];       /**< filename list of pending to be deleted */\n} ringbuf_data;\n\nstatic ringbuf_data rb_data;\n\n/*\n * delete pending uncompressed pcap files.\n */\nstatic void\nCleanupOldCap(char* name)\n{\n    ws_statb64 statb;\n    size_t i;\n\n    g_mutex_lock(&rb_data.mutex);\n\n    /* Delete pending delete file */\n    for (i = 0; i < array_length(rb_data.oldnames); i++) {\n        if (rb_data.oldnames[i] != NULL) {\n            ws_unlink(rb_data.oldnames[i]);\n            if (ws_stat64(rb_data.oldnames[i], &statb) != 0) {\n                g_free(rb_data.oldnames[i]);\n                rb_data.oldnames[i] = NULL;\n            }\n        }\n    }\n\n    if (name) {\n        /* push the current file to pending list if it failed to delete */\n        if (ws_stat64(name, &statb) == 0) {\n            for (i = 0; i < array_length(rb_data.oldnames); i++) {\n                if (rb_data.oldnames[i] == NULL) {\n                    rb_data.oldnames[i] = g_strdup(name);\n                    break;\n                }\n            }\n        }\n    }\n\n    g_mutex_unlock(&rb_data.mutex);\n}\n\n#if defined (HAVE_ZLIB) || defined (HAVE_ZLIBNG)\n/*\n * compress capture file\n */\nstatic int\nringbuf_exec_compress(char* name)\n{\n    uint8_t *buffer = NULL;\n    char* outgz = NULL;\n    int  fd = -1;\n    ssize_t nread;\n    bool delete_org_file = true;\n    gzFile fi = NULL;\n\n    fd = ws_open(name, O_RDONLY | O_BINARY, 0000);\n    if (fd < 0) {\n        return -1;\n    }\n\n    outgz = ws_strdup_printf(\"%s.gz\", name);\n    fi = ZLIB_PREFIX(gzopen)(outgz, \"wb\");\n    g_free(outgz);\n    if (fi == NULL) {\n        ws_close(fd);\n        return -1;\n    }\n\n#define FS_READ_SIZE 65536\n    buffer = (uint8_t*)g_malloc(FS_READ_SIZE);\n    if (buffer == NULL) {\n        ws_close(fd);\n        ZLIB_PREFIX(gzclose)(fi);\n        return -1;\n    }\n\n    while ((nread = ws_read(fd, buffer, FS_READ_SIZE)) > 0) {\n        int n = ZLIB_PREFIX(gzwrite)(fi, buffer, (unsigned int)nread);\n        if (n <= 0) {\n            /* mark compression as failed */\n            delete_org_file = false;\n            break;\n        }\n    }\n    if (nread < 0) {\n        /* mark compression as failed */\n        delete_org_file = false;\n    }\n    ws_close(fd);\n    ZLIB_PREFIX(gzclose)(fi);\n    g_free(buffer);\n\n    /* delete the original file only if compression succeeds */\n    if (delete_org_file) {\n        ws_unlink(name);\n        CleanupOldCap(name);\n    }\n    g_free(name);\n    return 0;\n}\n\n/*\n * thread to compress capture file\n */\nstatic void*\nexec_compress_thread(void* arg)\n{\n    ringbuf_exec_compress((char*)arg);\n    return NULL;\n}\n\n/*\n * start a thread to compress capture file\n */\nstatic int\nringbuf_start_compress_file(rb_file* rfile)\n{\n    char* name = g_strdup(rfile->name);\n    g_thread_new(\"exec_compress\", &exec_compress_thread, name);\n    return 0;\n}\n#endif\n\n/*\n * create the next filename and open a new binary file with that name\n */\nstatic int\nringbuf_open_file(rb_file *rfile, int *err)\n{\n    char    filenum[5+1];\n    char    timestr[14+1];\n    time_t  current_time;\n    struct tm *tm;\n\n    if (rfile->name != NULL) {\n        if (rb_data.unlimited == false) {\n            /* remove old file (if any, so ignore error) */\n            ws_unlink(rfile->name);\n        }\n#if defined (HAVE_ZLIB) || defined (HAVE_ZLIBNG)\n        else if (rb_data.compress_type != NULL && strcmp(rb_data.compress_type, \"gzip\") == 0) {\n            ringbuf_start_compress_file(rfile);\n        }\n#endif\n        g_free(rfile->name);\n    }\n\n#ifdef _WIN32\n    _tzset();\n#endif\n    current_time = time(NULL);\n\n    snprintf(filenum, sizeof(filenum), \"%05u\", (rb_data.curr_file_num + 1) % RINGBUFFER_MAX_NUM_FILES);\n    tm = localtime(&current_time);\n    if (tm != NULL)\n        strftime(timestr, sizeof(timestr), \"%Y%m%d%H%M%S\", tm);\n    else\n        (void) g_strlcpy(timestr, \"196912312359\", sizeof(timestr)); /* second before the Epoch */\n    if (rb_data.nametimenum) {\n        rfile->name = g_strconcat(rb_data.fprefix, \"_\", timestr, \"_\", filenum, rb_data.fsuffix, NULL);\n    } else {\n        rfile->name = g_strconcat(rb_data.fprefix, \"_\", filenum, \"_\", timestr, rb_data.fsuffix, NULL);\n    }\n\n    if (rfile->name == NULL) {\n        if (err != NULL)\n            *err = ENOMEM;\n        return -1;\n    }\n\n    rb_data.fd = ws_open(rfile->name, O_RDWR|O_BINARY|O_TRUNC|O_CREAT,\n            rb_data.group_read_access ? 0640 : 0600);\n\n    if (rb_data.fd == -1 && err != NULL) {\n        *err = errno;\n    }\n\n    return rb_data.fd;\n}\n\n/*\n * Initialize the ringbuffer data structures\n */\nint\nringbuf_init(const char *capfile_name, unsigned num_files, bool group_read_access,\n        char *compress_type, bool has_nametimenum)\n{\n    unsigned int i;\n    char        *pfx;\n    char        *dir_name, *base_name;\n\n    rb_data.files = NULL;\n    rb_data.curr_file_num = 0;\n    rb_data.fprefix = NULL;\n    rb_data.fsuffix = NULL;\n    rb_data.nametimenum = has_nametimenum;\n    rb_data.unlimited = false;\n    rb_data.fd = -1;\n    rb_data.pdh = NULL;\n    rb_data.io_buffer = NULL;\n    rb_data.group_read_access = group_read_access;\n    rb_data.name_h = NULL;\n    rb_data.compress_type = compress_type;\n    g_mutex_init(&rb_data.mutex);\n\n    /* just to be sure ... */\n    if (num_files <= RINGBUFFER_MAX_NUM_FILES) {\n        rb_data.num_files = num_files;\n    } else {\n        rb_data.num_files = RINGBUFFER_MAX_NUM_FILES;\n    }\n\n    /* Check file name */\n    if (capfile_name == NULL) {\n        /* ringbuffer does not work with temporary files! */\n        return -1;\n    }\n\n    /* set file name prefix/suffix */\n\n    base_name = g_path_get_basename(capfile_name);\n    dir_name = g_path_get_dirname(capfile_name);\n    pfx = strrchr(base_name, '.');\n    if (pfx != NULL) {\n        /* The basename has a \".\" in it.\n\n           Treat it as a separator between the rest of the file name and\n           the file name suffix, and arrange that the names given to the\n           ring buffer files have the specified suffix, i.e. put the\n           changing part of the name *before* the suffix.\n\n           XXX - If we ever handle writing compressed files directly\n           (#19159) make sure we deal with any compression suffix\n           appropriately. */\n        pfx[0] = '\\0';\n        rb_data.fprefix = g_build_filename(dir_name, base_name, NULL);\n        pfx[0] = '.'; /* restore capfile_name */\n        rb_data.fsuffix = g_strdup(pfx);\n    } else {\n        /* The last component has no suffix. */\n        rb_data.fprefix = g_strdup(capfile_name);\n        rb_data.fsuffix = NULL;\n    }\n    g_free(dir_name);\n    g_free(base_name);\n\n    /* allocate rb_file structures (only one if unlimited since there is no\n       need to save all file names in that case) */\n\n    if (num_files == RINGBUFFER_UNLIMITED_FILES) {\n        rb_data.unlimited = true;\n        rb_data.num_files = 1;\n    }\n\n    rb_data.files = g_new(rb_file, rb_data.num_files);\n    if (rb_data.files == NULL) {\n        return -1;\n    }\n\n    for (i=0; i < rb_data.num_files; i++) {\n        rb_data.files[i].name = NULL;\n    }\n\n    /* create the first file */\n    if (ringbuf_open_file(&rb_data.files[0], NULL) == -1) {\n        ringbuf_error_cleanup();\n        return -1;\n    }\n\n    return rb_data.fd;\n}\n\n/*\n * Set name of file to which to print ringbuffer file names.\n */\nbool\nringbuf_set_print_name(char *name, int *err)\n{\n    if (rb_data.name_h != NULL) {\n        if (EOF == fclose(rb_data.name_h)) {\n            if (err != NULL) {\n                *err = errno;\n            }\n            return false;\n        }\n    }\n    if (!strcmp(name, \"-\") || !strcmp(name, \"stdout\")) {\n        rb_data.name_h = stdout;\n    } else if (!strcmp(name, \"stderr\")) {\n        rb_data.name_h = stderr;\n    } else {\n        if (NULL == (rb_data.name_h = ws_fopen(name, \"wt\"))) {\n            if (err != NULL) {\n                *err = errno;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\n/*\n * Whether the ringbuf filenames are ready.\n * (Whether ringbuf_init is called and ringbuf_free is not called.)\n */\nbool\nringbuf_is_initialized(void)\n{\n    return rb_data.files != NULL;\n}\n\nconst char *\nringbuf_current_filename(void)\n{\n    return rb_data.files[rb_data.curr_file_num % rb_data.num_files].name;\n}\n\n/*\n * Calls ws_fdopen() for the current ringbuffer file\n */\nFILE *\nringbuf_init_libpcap_fdopen(int *err)\n{\n    rb_data.pdh = ws_fdopen(rb_data.fd, \"wb\");\n    if (rb_data.pdh == NULL) {\n        if (err != NULL) {\n            *err = errno;\n        }\n    } else {\n        size_t buffsize = IO_BUF_SIZE;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n        ws_statb64 statb;\n\n        if (ws_fstat64(rb_data.fd, &statb) == 0) {\n            if (statb.st_blksize > IO_BUF_SIZE) {\n                buffsize = statb.st_blksize;\n            }\n        }\n#endif\n        /* Increase the size of the IO buffer */\n        rb_data.io_buffer = (char *)g_realloc(rb_data.io_buffer, buffsize);\n        setvbuf(rb_data.pdh, rb_data.io_buffer, _IOFBF, buffsize);\n    }\n\n    return rb_data.pdh;\n}\n\n/*\n * Switches to the next ringbuffer file\n */\nbool\nringbuf_switch_file(FILE **pdh, char **save_file, int *save_file_fd, int *err)\n{\n    int     next_file_index;\n    rb_file *next_rfile = NULL;\n\n    /* close current file */\n\n    if (fclose(rb_data.pdh) == EOF) {\n        if (err != NULL) {\n            *err = errno;\n        }\n        ws_close(rb_data.fd);  /* XXX - the above should have closed this already */\n        rb_data.pdh = NULL;    /* it's still closed, we just got an error while closing */\n        rb_data.fd = -1;\n        g_free(rb_data.io_buffer);\n        rb_data.io_buffer = NULL;\n        return false;\n    }\n\n    rb_data.pdh = NULL;\n    rb_data.fd  = -1;\n\n    if (rb_data.name_h != NULL) {\n        fprintf(rb_data.name_h, \"%s\\n\", ringbuf_current_filename());\n        fflush(rb_data.name_h);\n    }\n\n    /* get the next file number and open it */\n\n    rb_data.curr_file_num++ /* = next_file_num*/;\n    next_file_index = (rb_data.curr_file_num) % rb_data.num_files;\n    next_rfile = &rb_data.files[next_file_index];\n\n    if (ringbuf_open_file(next_rfile, err) == -1) {\n        return false;\n    }\n\n    if (ringbuf_init_libpcap_fdopen(err) == NULL) {\n        return false;\n    }\n\n    /* switch to the new file */\n    *save_file = next_rfile->name;\n    *save_file_fd = rb_data.fd;\n    (*pdh) = rb_data.pdh;\n\n    return true;\n}\n\n/*\n * Calls fclose() for the current ringbuffer file\n */\nbool\nringbuf_libpcap_dump_close(char **save_file, int *err)\n{\n    bool      ret_val = true;\n\n    /* close current file, if it's open */\n    if (rb_data.pdh != NULL) {\n        if (fclose(rb_data.pdh) == EOF) {\n            if (err != NULL) {\n                *err = errno;\n            }\n            ws_close(rb_data.fd);\n            ret_val = false;\n        }\n        rb_data.pdh = NULL;\n        rb_data.fd  = -1;\n        g_free(rb_data.io_buffer);\n        rb_data.io_buffer = NULL;\n\n    }\n\n    if (rb_data.name_h != NULL) {\n        fprintf(rb_data.name_h, \"%s\\n\", ringbuf_current_filename());\n        fflush(rb_data.name_h);\n\n        if (EOF == fclose(rb_data.name_h)) {\n            /* Can't really do much about this, can we? */\n        }\n    }\n\n    /* set the save file name to the current file */\n    *save_file = rb_data.files[rb_data.curr_file_num % rb_data.num_files].name;\n    return ret_val;\n}\n\n/*\n * Frees all memory allocated by the ringbuffer\n */\nvoid\nringbuf_free(void)\n{\n    unsigned int i;\n\n    if (rb_data.files != NULL) {\n        for (i=0; i < rb_data.num_files; i++) {\n            if (rb_data.files[i].name != NULL) {\n                g_free(rb_data.files[i].name);\n                rb_data.files[i].name = NULL;\n            }\n        }\n        g_free(rb_data.files);\n        rb_data.files = NULL;\n    }\n    if (rb_data.fprefix != NULL) {\n        g_free(rb_data.fprefix);\n        rb_data.fprefix = NULL;\n    }\n    if (rb_data.fsuffix != NULL) {\n        g_free(rb_data.fsuffix);\n        rb_data.fsuffix = NULL;\n    }\n\n    CleanupOldCap(NULL);\n}\n\n/*\n * Frees all memory allocated by the ringbuffer\n */\nvoid\nringbuf_error_cleanup(void)\n{\n    unsigned int i;\n\n    /* try to close via wtap */\n    if (rb_data.pdh != NULL) {\n        if (fclose(rb_data.pdh) == 0) {\n            rb_data.fd = -1;\n        }\n        rb_data.pdh = NULL;\n    }\n\n    /* close directly if still open */\n    if (rb_data.fd != -1) {\n        ws_close(rb_data.fd);\n        rb_data.fd = -1;\n    }\n\n    if (rb_data.files != NULL) {\n        for (i=0; i < rb_data.num_files; i++) {\n            if (rb_data.files[i].name != NULL) {\n                ws_unlink(rb_data.files[i].name);\n            }\n        }\n    }\n    g_free(rb_data.io_buffer);\n    rb_data.io_buffer = NULL;\n\n    if (rb_data.name_h != NULL) {\n        if (EOF == fclose(rb_data.name_h)) {\n            /* Can't really do much about this, can we? */\n        }\n    }\n\n    /* free the memory */\n    ringbuf_free();\n}\n\n#endif /* HAVE_LIBPCAP */\n"
        },
        {
          "name": "ringbuffer.h",
          "type": "blob",
          "size": 1.2138671875,
          "content": "/** @file\n *\n * Definitions for capture ringbuffer files\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#ifndef __RINGBUFFER_H__\n#define __RINGBUFFER_H__\n\n#include <wireshark.h>\n#include <stdio.h>\n\n#define RINGBUFFER_UNLIMITED_FILES 0\n/* Minimum number of ringbuffer files */\n#define RINGBUFFER_MIN_NUM_FILES 0\n/* Maximum number of ringbuffer files */\n/* Avoid crashes on very large numbers. Should be a power of 10 */\n#define RINGBUFFER_MAX_NUM_FILES 100000\n/* Maximum number for FAT filesystems */\n#define RINGBUFFER_WARN_NUM_FILES 65535\n\nint ringbuf_init(const char *capture_name, unsigned num_files, bool group_read_access, char* compress_type,\n                 bool nametimenum);\nbool ringbuf_is_initialized(void);\nconst char *ringbuf_current_filename(void);\nFILE *ringbuf_init_libpcap_fdopen(int *err);\nbool ringbuf_switch_file(FILE **pdh, char **save_file, int *save_file_fd,\n                             int *err);\nbool ringbuf_libpcap_dump_close(char **save_file, int *err);\nvoid ringbuf_free(void);\nvoid ringbuf_error_cleanup(void);\nbool ringbuf_set_print_name(char *name, int *err);\n\n#endif /* ringbuffer.h */\n"
        },
        {
          "name": "sharkd.c",
          "type": "blob",
          "size": 19.662109375,
          "content": "/* sharkd.c\n *\n * Daemon variant of Wireshark\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <signal.h>\n\n#include <glib.h>\n\n#include <epan/exceptions.h>\n#include <epan/epan.h>\n\n#include <wsutil/clopts_common.h>\n#include <wsutil/cmdarg_err.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/file_util.h>\n#include <wsutil/privileges.h>\n#include <wsutil/wslog.h>\n#include <wsutil/version_info.h>\n#include <wiretap/wtap_opttypes.h>\n\n#include <epan/decode_as.h>\n#include <epan/timestamp.h>\n#include <epan/packet.h>\n#include <epan/disabled_protos.h>\n#include <epan/prefs.h>\n#include <epan/column.h>\n#include <epan/print.h>\n#include <epan/addr_resolv.h>\n#include \"ui/util.h\"\n#include \"ui/ws_ui_util.h\"\n#include \"ui/decode_as_utils.h\"\n#include \"wsutil/filter_files.h\"\n#include \"ui/tap_export_pdu.h\"\n#include \"ui/failure_message.h\"\n#include <wiretap/wtap.h>\n#include <epan/epan_dissect.h>\n#include <epan/tap.h>\n#include <epan/uat-int.h>\n#include <epan/secrets.h>\n\n#include <wsutil/codecs.h>\n\n#include <wsutil/str_util.h>\n#include <wsutil/utf8_entities.h>\n\n#ifdef HAVE_PLUGINS\n#include <wsutil/plugins.h>\n#endif\n\n#include \"sharkd.h\"\n\n#define SHARKD_INIT_FAILED 1\n#define SHARKD_EPAN_INIT_FAIL 2\n\ncapture_file cfile;\n\nstatic uint32_t cum_bytes;\nstatic frame_data ref_frame;\n\nstatic void\nprint_current_user(void)\n{\n    char *cur_user, *cur_group;\n\n    if (started_with_special_privs()) {\n        cur_user = get_cur_username();\n        cur_group = get_cur_groupname();\n        fprintf(stderr, \"Running as user \\\"%s\\\" and group \\\"%s\\\".\",\n                cur_user, cur_group);\n        g_free(cur_user);\n        g_free(cur_group);\n        if (running_with_special_privs()) {\n            fprintf(stderr, \" This could be dangerous.\");\n        }\n        fprintf(stderr, \"\\n\");\n    }\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char                *configuration_init_error;\n\n    char                *err_msg = NULL;\n    e_prefs             *prefs_p;\n    int                  ret = EXIT_SUCCESS;\n\n    /* Set the program name. */\n    g_set_prgname(\"sharkd\");\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, SHARKD_INIT_FAILED);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n    /*\n     * Get credential information for later use, and drop privileges\n     * before doing anything else.\n     * Let the user know if anything happened.\n     */\n    init_process_policies();\n    relinquish_special_privs_perm();\n    print_current_user();\n\n    /*\n     * Attempt to get the pathname of the executable file.\n     */\n    configuration_init_error = configuration_init(argv[0]);\n    if (configuration_init_error != NULL) {\n        fprintf(stderr, \"sharkd: Can't get pathname of sharkd program: %s.\\n\",\n                configuration_init_error);\n    }\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"Sharkd\",\n                         epan_gather_compile_info,\n                         epan_gather_runtime_info);\n\n    if (sharkd_init(argc, argv) < 0)\n    {\n        fputs(\"Cannot initialize sharkd.\\n\", stderr);\n        ret = SHARKD_INIT_FAILED;\n        goto clean_exit;\n    }\n\n    init_report_failure_message(\"sharkd\");\n\n    timestamp_set_type(TS_RELATIVE);\n    timestamp_set_precision(TS_PREC_AUTO);\n    timestamp_set_seconds_type(TS_SECONDS_DEFAULT);\n\n    /*\n     * Libwiretap must be initialized before libwireshark is, so that\n     * dissection-time handlers for file-type-dependent blocks can\n     * register using the file type/subtype value for the file type.\n     */\n    wtap_init(true);\n\n    /* Register all dissectors; we must do this before checking for the\n       \"-G\" flag, as the \"-G\" flag dumps information registered by the\n       dissectors, and we must do it before we read the preferences, in\n       case any dissectors register preferences. */\n    if (!epan_init(NULL, NULL, true)) {\n        ret = SHARKD_EPAN_INIT_FAIL;\n        goto clean_exit;\n    }\n\n    codecs_init();\n\n    /* Load libwireshark settings from the current profile. */\n    prefs_p = epan_load_settings();\n\n    if (!color_filters_init(&err_msg, NULL)) {\n        fprintf(stderr, \"%s\\n\", err_msg);\n        g_free(err_msg);\n    }\n\n    cap_file_init(&cfile);\n\n    /* Notify all registered modules that have had any of their preferences\n       changed either from one of the preferences file or from the command\n       line that their preferences have changed. */\n    prefs_apply_all();\n\n    /* Build the column format array */\n    build_column_format_array(&cfile.cinfo, prefs_p->num_cols, true);\n\n#ifdef HAVE_MAXMINDDB\n    /* mmdbresolve is started from mmdb_resolve_start(), which is called from epan_load_settings via: read_prefs -> (...) uat_load_all -> maxmind_db_post_update_cb.\n     * Need to stop it, otherwise all sharkd will have same mmdbresolve process, including pipe descriptors to read and write. */\n    uat_get_table_by_name(\"MaxMind Database Paths\")->reset_cb();\n#endif\n\n    ret = sharkd_loop(argc, argv);\nclean_exit:\n    col_cleanup(&cfile.cinfo);\n    codecs_cleanup();\n    wtap_cleanup();\n    free_progdirs();\n    return ret;\n}\n\nstatic epan_t *\nsharkd_epan_new(capture_file *cf)\n{\n    static const struct packet_provider_funcs funcs = {\n        cap_file_provider_get_frame_ts,\n        cap_file_provider_get_interface_name,\n        cap_file_provider_get_interface_description,\n        cap_file_provider_get_modified_block\n    };\n\n    return epan_new(&cf->provider, &funcs);\n}\n\nstatic bool\nprocess_packet(capture_file *cf, epan_dissect_t *edt, int64_t offset,\n               wtap_rec *rec)\n{\n    frame_data     fdlocal;\n    bool           passed;\n\n    /* If we're not running a display filter and we're not printing any\n       packet information, we don't need to do a dissection. This means\n       that all packets can be marked as 'passed'. */\n    passed = true;\n\n    /* The frame number of this packet, if we add it to the set of frames,\n       would be one more than the count of frames in the file so far. */\n    frame_data_init(&fdlocal, cf->count + 1, rec, offset, cum_bytes);\n\n    /* If we're going to print packet information, or we're going to\n       run a read filter, or display filter, or we're going to process taps, set up to\n       do a dissection and do so. */\n    if (edt) {\n        if (gbl_resolv_flags.mac_name || gbl_resolv_flags.network_name ||\n                gbl_resolv_flags.transport_name)\n            /* Grab any resolved addresses */\n            host_name_lookup_process();\n\n        /* If we're running a read filter, prime the epan_dissect_t with that\n           filter. */\n        if (cf->rfcode)\n            epan_dissect_prime_with_dfilter(edt, cf->rfcode);\n\n        if (cf->dfcode)\n            epan_dissect_prime_with_dfilter(edt, cf->dfcode);\n\n        /* This is the first and only pass, so prime the epan_dissect_t\n           with the hfids postdissectors want on the first pass. */\n        prime_epan_dissect_with_postdissector_wanted_hfids(edt);\n\n        frame_data_set_before_dissect(&fdlocal, &cf->elapsed_time,\n                &cf->provider.ref, cf->provider.prev_dis);\n        if (cf->provider.ref == &fdlocal) {\n            ref_frame = fdlocal;\n            cf->provider.ref = &ref_frame;\n        }\n\n        epan_dissect_run(edt, cf->cd_t, rec, &fdlocal, NULL);\n\n        /* Run the read filter if we have one. */\n        if (cf->rfcode)\n            passed = dfilter_apply_edt(cf->rfcode, edt);\n    }\n\n    if (passed) {\n        frame_data_set_after_dissect(&fdlocal, &cum_bytes);\n        cf->provider.prev_cap = cf->provider.prev_dis = frame_data_sequence_add(cf->provider.frames, &fdlocal);\n\n        /* If we're not doing dissection then there won't be any dependent frames.\n         * More importantly, edt.pi.fd.dependent_frames won't be initialized because\n         * epan hasn't been initialized.\n         * if we *are* doing dissection, then mark the dependent frames, but only\n         * if a display filter was given and it matches this packet.\n         */\n        if (edt && cf->dfcode) {\n            if (dfilter_apply_edt(cf->dfcode, edt) && edt->pi.fd->dependent_frames) {\n                g_hash_table_foreach(edt->pi.fd->dependent_frames, find_and_mark_frame_depended_upon, cf->provider.frames);\n            }\n        }\n\n        cf->count++;\n    } else {\n        /* if we don't add it to the frame_data_sequence, clean it up right now\n         * to avoid leaks */\n        frame_data_destroy(&fdlocal);\n    }\n\n    if (edt)\n        epan_dissect_reset(edt);\n\n    return passed;\n}\n\n\nstatic int\nload_cap_file(capture_file *cf, int max_packet_count, int64_t max_byte_count)\n{\n    int          err;\n    char        *err_info = NULL;\n    int64_t      data_offset;\n    wtap_rec     rec;\n    epan_dissect_t *edt = NULL;\n\n    {\n        /* Allocate a frame_data_sequence for all the frames. */\n        cf->provider.frames = new_frame_data_sequence();\n\n        {\n            bool create_proto_tree;\n\n            /*\n             * Determine whether we need to create a protocol tree.\n             * We do if:\n             *\n             *    we're going to apply a read filter;\n             *\n             *    we're going to apply a display filter;\n             *\n             *    a postdissector wants field values or protocols\n             *    on the first pass.\n             */\n            create_proto_tree =\n                (cf->rfcode != NULL || cf->dfcode != NULL || postdissectors_want_hfids());\n\n            /* We're not going to display the protocol tree on this pass,\n               so it's not going to be \"visible\". */\n            edt = epan_dissect_new(cf->epan, create_proto_tree, false);\n        }\n\n        wtap_rec_init(&rec, 1514);\n\n        while (wtap_read(cf->provider.wth, &rec, &err, &err_info, &data_offset)) {\n            if (process_packet(cf, edt, data_offset, &rec)) {\n                wtap_rec_reset(&rec);\n                /* Stop reading if we have the maximum number of packets;\n                 * When the -c option has not been used, max_packet_count\n                 * starts at 0, which practically means, never stop reading.\n                 * (unless we roll over max_packet_count ?)\n                 */\n                if ( (--max_packet_count == 0) || (max_byte_count != 0 && data_offset >= max_byte_count)) {\n                    err = 0; /* This is not an error */\n                    break;\n                }\n            }\n        }\n\n        if (edt) {\n            epan_dissect_free(edt);\n            edt = NULL;\n        }\n\n        wtap_rec_cleanup(&rec);\n\n        /* Close the sequential I/O side, to free up memory it requires. */\n        wtap_sequential_close(cf->provider.wth);\n\n        /* Allow the protocol dissectors to free up memory that they\n         * don't need after the sequential run-through of the packets. */\n        postseq_cleanup_all_protocols();\n\n        cf->provider.prev_dis = NULL;\n        cf->provider.prev_cap = NULL;\n    }\n\n    if (err != 0) {\n        cfile_read_failure_message(cf->filename, err, err_info);\n    }\n\n    return err;\n}\n\ncf_status_t\ncf_open(capture_file *cf, const char *fname, unsigned int type, bool is_tempfile, int *err)\n{\n    wtap  *wth;\n    char *err_info;\n\n    wth = wtap_open_offline(fname, type, err, &err_info, true);\n    if (wth == NULL)\n        goto fail;\n\n    /* The open succeeded.  Fill in the information for this file. */\n\n    cf->provider.wth = wth;\n    cf->f_datalen = 0; /* not used, but set it anyway */\n\n    /* Set the file name because we need it to set the follow stream filter.\n       XXX - is that still true?  We need it for other reasons, though,\n       in any case. */\n    cf->filename = g_strdup(fname);\n\n    /* Indicate whether it's a permanent or temporary file. */\n    cf->is_tempfile = is_tempfile;\n\n    /* No user changes yet. */\n    cf->unsaved_changes = false;\n\n    cf->cd_t      = wtap_file_type_subtype(cf->provider.wth);\n    cf->open_type = type;\n    cf->count     = 0;\n    cf->drops_known = false;\n    cf->drops     = 0;\n    cf->snap      = wtap_snapshot_length(cf->provider.wth);\n    nstime_set_zero(&cf->elapsed_time);\n    cf->provider.ref = NULL;\n    cf->provider.prev_dis = NULL;\n    cf->provider.prev_cap = NULL;\n\n    /* Create new epan session for dissection. */\n    epan_free(cf->epan);\n    cf->epan = sharkd_epan_new(cf);\n\n    cf->state = FILE_READ_IN_PROGRESS;\n\n    wtap_set_cb_new_ipv4(cf->provider.wth, add_ipv4_name);\n    wtap_set_cb_new_ipv6(cf->provider.wth, (wtap_new_ipv6_callback_t) add_ipv6_name);\n    wtap_set_cb_new_secrets(cf->provider.wth, secrets_wtap_callback);\n\n    return CF_OK;\n\nfail:\n    cfile_open_failure_message(fname, *err, err_info);\n    return CF_ERROR;\n}\n\ncf_status_t\nsharkd_cf_open(const char *fname, unsigned int type, bool is_tempfile, int *err)\n{\n    return cf_open(&cfile, fname, type, is_tempfile, err);\n}\n\nint\nsharkd_load_cap_file(void)\n{\n    return load_cap_file(&cfile, 0, 0);\n}\n\nframe_data *\nsharkd_get_frame(uint32_t framenum)\n{\n    return frame_data_sequence_find(cfile.provider.frames, framenum);\n}\n\nenum dissect_request_status\nsharkd_dissect_request(uint32_t framenum, uint32_t frame_ref_num,\n        uint32_t prev_dis_num, wtap_rec *rec,\n        column_info *cinfo, uint32_t dissect_flags,\n        sharkd_dissect_func_t cb, void *data,\n        int *err, char **err_info)\n{\n    frame_data *fdata;\n    epan_dissect_t edt;\n    bool create_proto_tree;\n\n    fdata = sharkd_get_frame(framenum);\n    if (fdata == NULL)\n        return DISSECT_REQUEST_NO_SUCH_FRAME;\n\n    if (!wtap_seek_read(cfile.provider.wth, fdata->file_off, rec, err, err_info)) {\n        if (cinfo != NULL)\n            col_fill_in_error(cinfo, fdata, false, false /* fill_fd_columns */);\n        return DISSECT_REQUEST_READ_ERROR; /* error reading the record */\n    }\n\n    create_proto_tree = ((dissect_flags & SHARKD_DISSECT_FLAG_PROTO_TREE) ||\n            ((dissect_flags & SHARKD_DISSECT_FLAG_COLOR) && color_filters_used()) ||\n            (cinfo && have_custom_cols(cinfo)));\n    epan_dissect_init(&edt, cfile.epan, create_proto_tree, (dissect_flags & SHARKD_DISSECT_FLAG_PROTO_TREE));\n\n    if (dissect_flags & SHARKD_DISSECT_FLAG_COLOR) {\n        color_filters_prime_edt(&edt);\n        fdata->need_colorize = 1;\n    }\n\n    if (cinfo)\n        col_custom_prime_edt(&edt, cinfo);\n\n    /*\n     * XXX - need to catch an OutOfMemoryError exception and\n     * attempt to recover from it.\n     */\n    fdata->ref_time = (framenum == frame_ref_num);\n    fdata->frame_ref_num = frame_ref_num;\n    fdata->prev_dis_num = prev_dis_num;\n    epan_dissect_run(&edt, cfile.cd_t, rec, fdata, cinfo);\n\n    if (cinfo) {\n        /* \"Stringify\" non frame_data vals */\n        epan_dissect_fill_in_columns(&edt, false, true/* fill_fd_columns */);\n    }\n\n    cb(&edt, (dissect_flags & SHARKD_DISSECT_FLAG_PROTO_TREE) ? edt.tree : NULL,\n            cinfo, (dissect_flags & SHARKD_DISSECT_FLAG_BYTES) ? edt.pi.data_src : NULL,\n            data);\n\n    wtap_rec_reset(rec);\n    epan_dissect_cleanup(&edt);\n    return DISSECT_REQUEST_SUCCESS;\n}\n\nint\nsharkd_retap(void)\n{\n    uint32_t         framenum;\n    frame_data      *fdata;\n    wtap_rec         rec;\n    int err;\n    char *err_info = NULL;\n\n    unsigned      tap_flags;\n    bool          create_proto_tree;\n    epan_dissect_t edt;\n    column_info   *cinfo;\n\n    /* Get the union of the flags for all tap listeners. */\n    tap_flags = union_of_tap_listener_flags();\n\n    /* If any tap listeners require the columns, construct them. */\n    cinfo = (tap_listeners_require_columns()) ? &cfile.cinfo : NULL;\n\n    /*\n     * Determine whether we need to create a protocol tree.\n     * We do if:\n     *\n     *    one of the tap listeners is going to apply a filter;\n     *\n     *    one of the tap listeners requires a protocol tree.\n     */\n    create_proto_tree =\n        (have_filtering_tap_listeners() || (tap_flags & TL_REQUIRES_PROTO_TREE));\n\n    wtap_rec_init(&rec, 1514);\n    epan_dissect_init(&edt, cfile.epan, create_proto_tree, false);\n\n    reset_tap_listeners();\n\n    for (framenum = 1; framenum <= cfile.count; framenum++) {\n        fdata = sharkd_get_frame(framenum);\n\n        if (!wtap_seek_read(cfile.provider.wth, fdata->file_off, &rec, &err, &err_info))\n            break;\n\n        fdata->ref_time = false;\n        fdata->frame_ref_num = (framenum != 1) ? 1 : 0;\n        fdata->prev_dis_num = framenum - 1;\n        epan_dissect_run_with_taps(&edt, cfile.cd_t, &rec, fdata, cinfo);\n        wtap_rec_reset(&rec);\n        epan_dissect_reset(&edt);\n    }\n\n    wtap_rec_cleanup(&rec);\n    epan_dissect_cleanup(&edt);\n\n    draw_tap_listeners(true);\n\n    return 0;\n}\n\nint\nsharkd_filter(const char *dftext, uint8_t **result)\n{\n    dfilter_t  *dfcode = NULL;\n\n    uint32_t framenum, prev_dis_num = 0;\n    uint32_t frames_count;\n    wtap_rec rec;\n    int err;\n    char *err_info = NULL;\n\n    uint8_t *result_bits;\n    uint8_t passed_bits;\n\n    epan_dissect_t edt;\n\n    if (!dfilter_compile(dftext, &dfcode, NULL)) {\n        return -1;\n    }\n\n    /* if dfilter_compile() success, but (dfcode == NULL) all frames are matching */\n    if (dfcode == NULL) {\n        *result = NULL;\n        return 0;\n    }\n\n    frames_count = cfile.count;\n\n    wtap_rec_init(&rec, 1514);\n    epan_dissect_init(&edt, cfile.epan, true, false);\n\n    passed_bits = 0;\n    result_bits = (uint8_t *) g_malloc(2 + (frames_count / 8));\n\n    for (framenum = 1; framenum <= frames_count; framenum++) {\n        frame_data *fdata = sharkd_get_frame(framenum);\n\n        if ((framenum & 7) == 0) {\n            result_bits[(framenum / 8) - 1] = passed_bits;\n            passed_bits = 0;\n        }\n\n        if (!wtap_seek_read(cfile.provider.wth, fdata->file_off, &rec, &err, &err_info))\n            break;\n\n        /* frame_data_set_before_dissect */\n        epan_dissect_prime_with_dfilter(&edt, dfcode);\n\n        fdata->ref_time = false;\n        fdata->frame_ref_num = (framenum != 1) ? 1 : 0;\n        fdata->prev_dis_num = prev_dis_num;\n        epan_dissect_run(&edt, cfile.cd_t, &rec, fdata, NULL);\n\n        if (dfilter_apply_edt(dfcode, &edt)) {\n            passed_bits |= (1 << (framenum % 8));\n            prev_dis_num = framenum;\n        }\n\n        /* if passed or ref -> frame_data_set_after_dissect */\n\n        wtap_rec_reset(&rec);\n        epan_dissect_reset(&edt);\n    }\n\n    if ((framenum & 7) == 0)\n        framenum--;\n    result_bits[framenum / 8] = passed_bits;\n\n    wtap_rec_cleanup(&rec);\n    epan_dissect_cleanup(&edt);\n\n    dfilter_free(dfcode);\n\n    *result = result_bits;\n\n    return framenum;\n}\n\n/*\n * Get the modified block if available, nothing otherwise.\n * Must be cloned if changes desired.\n */\nwtap_block_t\nsharkd_get_modified_block(const frame_data *fd)\n{\n    return cap_file_provider_get_modified_block(&cfile.provider, fd);\n}\n\n/*\n * Gets the modified block if available, otherwise the packet's default block,\n * or a new packet block.\n * User must wtap_block_unref() it when done.\n */\nwtap_block_t\nsharkd_get_packet_block(const frame_data *fd)\n{\n    if (fd->has_modified_block)\n        return wtap_block_ref(cap_file_provider_get_modified_block(&cfile.provider, fd));\n    else\n    {\n        wtap_rec rec; /* Record information */\n        wtap_block_t block;\n        int err;\n        char *err_info;\n\n        wtap_rec_init(&rec, 1514);\n\n        if (!wtap_seek_read(cfile.provider.wth, fd->file_off, &rec, &err, &err_info))\n        { /* XXX, what we can do here? */ }\n\n        /* rec.block is owned by the record, steal it before it is gone. */\n        block = wtap_block_ref(rec.block);\n\n        wtap_rec_cleanup(&rec);\n        return block;\n    }\n}\n\nint\nsharkd_set_modified_block(frame_data *fd, wtap_block_t new_block)\n{\n    cap_file_provider_set_modified_block(&cfile.provider, fd, new_block);\n    return 0;\n}\n"
        },
        {
          "name": "sharkd.h",
          "type": "blob",
          "size": 2.2158203125,
          "content": "/** @file\n *\n * Copyright (C) 2016 Jakub Zawadzki\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#ifndef __SHARKD_H\n#define __SHARKD_H\n\n#include <file.h>\n#include <wiretap/wtap_opttypes.h>\n\n#define SHARKD_DISSECT_FLAG_NULL       0x00u\n#define SHARKD_DISSECT_FLAG_BYTES      0x01u\n#define SHARKD_DISSECT_FLAG_COLUMNS    0x02u\n#define SHARKD_DISSECT_FLAG_PROTO_TREE 0x04u\n#define SHARKD_DISSECT_FLAG_COLOR      0x08u\n\n#define SHARKD_MODE_CLASSIC_CONSOLE    1\n#define SHARKD_MODE_CLASSIC_DAEMON     2\n#define SHARKD_MODE_GOLD_CONSOLE       3\n#define SHARKD_MODE_GOLD_DAEMON        4\n\ntypedef void (*sharkd_dissect_func_t)(epan_dissect_t *edt, proto_tree *tree, struct epan_column_info *cinfo, const GSList *data_src, void *data);\n\n/* sharkd.c */\ncf_status_t sharkd_cf_open(const char *fname, unsigned int type, bool is_tempfile, int *err);\nint sharkd_load_cap_file(void);\nint sharkd_retap(void);\nint sharkd_filter(const char *dftext, uint8_t **result);\nframe_data *sharkd_get_frame(uint32_t framenum);\nenum dissect_request_status {\n  DISSECT_REQUEST_SUCCESS,\n  DISSECT_REQUEST_NO_SUCH_FRAME,\n  DISSECT_REQUEST_READ_ERROR\n};\nenum dissect_request_status\nsharkd_dissect_request(uint32_t framenum, uint32_t frame_ref_num,\n                       uint32_t prev_dis_num, wtap_rec *rec,\n                       column_info *cinfo, uint32_t dissect_flags,\n                       sharkd_dissect_func_t cb, void *data,\n                       int *err, char **err_info);\nwtap_block_t sharkd_get_modified_block(const frame_data *fd);\nwtap_block_t sharkd_get_packet_block(const frame_data *fd);\nint sharkd_set_modified_block(frame_data *fd, wtap_block_t new_block);\nconst char *sharkd_version(void);\n\n/* sharkd_daemon.c */\nint sharkd_init(int argc, char **argv);\nint sharkd_loop(int argc _U_, char* argv[] _U_);\n\n/* sharkd_session.c */\nint sharkd_session_main(int mode_setting);\n\n#endif /* __SHARKD_H */\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 8\n * tab-width: 8\n * indent-tabs-mode: t\n * End:\n *\n * vi: set shiftwidth=8 tabstop=8 noexpandtab:\n * :indentSize=8:tabSize=8:noTabs=false:\n */\n"
        },
        {
          "name": "sharkd_daemon.c",
          "type": "blob",
          "size": 15.7265625,
          "content": "/* sharkd_daemon.c\n *\n * Copyright (C) 2016 Jakub Zawadzki\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN LOG_DOMAIN_MAIN\n\n#include <glib.h>\n\n#include <stdio.h>\n#include <errno.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <signal.h>\n\n#ifdef _WIN32\n#include <wsutil/unicode-utils.h>\n#include <wsutil/win32-utils.h>\n#endif\n\n#include <wsutil/filesystem.h>\n#include <wsutil/socket.h>\n#include <wsutil/inet_addr.h>\n#include <wsutil/please_report_bug.h>\n#include <wsutil/wslog.h>\n#include <wsutil/ws_getopt.h>\n\n#ifndef _WIN32\n#include <sys/un.h>\n#include <netinet/tcp.h>\n#endif\n\n#include <wsutil/strtoi.h>\n#include <wsutil/version_info.h>\n\n#include \"sharkd.h\"\n\n#ifdef _WIN32\n/*\n * TCP sockets can work on Linux and other systems, but is disabled by default\n * because we do not want to encourage insecure setups. Unfiltered access to\n * sharkd could potentially result in arbitrary command execution.\n * On Windows, Unix sockets are not supported, so we enable it there.\n */\n# define SHARKD_TCP_SUPPORT\n#endif\n\n#ifndef _WIN32\n# define SHARKD_UNIX_SUPPORT\n#endif\n\nstatic int mode;\nstatic socket_handle_t _server_fd = INVALID_SOCKET;\n\nstatic socket_handle_t\nsocket_init(char *path)\n{\n    socket_handle_t fd = INVALID_SOCKET;\n    char *err_msg;\n\n    err_msg = ws_init_sockets();\n    if (err_msg != NULL) {\n        ws_warning(\"ERROR: %s\", err_msg);\n        g_free(err_msg);\n        ws_warning(\"%s\", please_report_bug());\n        return fd;\n    }\n\n    if (!strncmp(path, \"unix:\", 5))\n    {\n#ifdef SHARKD_UNIX_SUPPORT\n        struct sockaddr_un s_un;\n        socklen_t s_un_len;\n\n        path += 5;\n\n        if (strlen(path) + 1 > sizeof(s_un.sun_path)) {\n            fputs(\"Socket path too long.\\n\", stderr);\n            return INVALID_SOCKET;\n        }\n\n        fd = socket(AF_UNIX, SOCK_STREAM, 0);\n        if (fd == INVALID_SOCKET) {\n            fprintf(stderr, \"Failed to create socket: %s\\n\", g_strerror(errno));\n            return INVALID_SOCKET;\n        }\n\n        memset(&s_un, 0, sizeof(s_un));\n        s_un.sun_family = AF_UNIX;\n        (void) g_strlcpy(s_un.sun_path, path, sizeof(s_un.sun_path));\n\n        s_un_len = (socklen_t)(offsetof(struct sockaddr_un, sun_path) + strlen(s_un.sun_path));\n\n        if (s_un.sun_path[0] == '@')\n            s_un.sun_path[0] = '\\0';\n\n        if (bind(fd, (struct sockaddr *) &s_un, s_un_len))\n        {\n            fprintf(stderr, \"Failed to bind socket: %s\\n\", g_strerror(errno));\n            closesocket(fd);\n            return INVALID_SOCKET;\n        }\n#else\n        fputs(\"Unix sockets are not available on Windows, use tcp instead.\\n\", stderr);\n        return INVALID_SOCKET;\n#endif\n    } else if (!strncmp(path, \"tcp:\", 4)) {\n#ifdef SHARKD_TCP_SUPPORT\n        struct sockaddr_in s_in;\n        int one = 1;\n        char *port_sep;\n        uint16_t port;\n\n        path += 4;\n\n        port_sep = strchr(path, ':');\n        if (!port_sep) {\n            fputs(\"Missing port number in socket path.\\n\", stderr);\n            return INVALID_SOCKET;\n        }\n\n        *port_sep = '\\0';\n\n        if (ws_strtou16(port_sep + 1, NULL, &port) == false) {\n            fputs(\"Invalid port number.\\n\", stderr);\n            return INVALID_SOCKET;\n        }\n\n#ifdef _WIN32\n        /* Need to use WSASocket() to disable overlapped I/O operations,\n            this way on windows SOCKET can be used as HANDLE for stdin/stdout */\n        fd = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, 0);\n#else\n        fd = socket(AF_INET, SOCK_STREAM, 0);\n#endif\n        if (fd == INVALID_SOCKET) {\n            fprintf(stderr, \"Failed to open socket: %s\\n\",\n#ifdef _WIN32\n                    win32strerror(WSAGetLastError())\n#else\n                    g_strerror(errno)\n#endif\n                   );\n            return INVALID_SOCKET;\n        }\n\n        s_in.sin_family = AF_INET;\n        ws_inet_pton4(path, (ws_in4_addr *)&(s_in.sin_addr.s_addr));\n        s_in.sin_port = g_htons(port);\n        *port_sep = ':';\n\n        setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (void *) &one, sizeof(one));\n\n        if (bind(fd, (struct sockaddr *) &s_in, sizeof(struct sockaddr_in)))\n        {\n            fprintf(stderr, \"Failed to bind socket: %s\\n\", g_strerror(errno));\n            closesocket(fd);\n            return INVALID_SOCKET;\n        }\n#else\n        fputs(\"TCP sockets are not available for security reasons, use Unix sockets instead.\\n\", stderr);\n        return INVALID_SOCKET;\n#endif\n    }\n    else\n    {\n        fprintf(stderr, \"Unsupported socket path '%s', try unix:... for Unix sockets\\n\", path);\n        return INVALID_SOCKET;\n    }\n\n    if (listen(fd, SOMAXCONN))\n    {\n        fprintf(stderr, \"Failed to listen on socket: %s\\n\", g_strerror(errno));\n        closesocket(fd);\n        return INVALID_SOCKET;\n    }\n\n    return fd;\n}\n\nstatic void\nprint_usage(FILE* output)\n{\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: sharkd [options]\\n\");\n    fprintf(output, \"  or   sharkd -\\n\");\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Options:\\n\");\n    fprintf(output, \"  -a <socket>, --api <socket>\\n\");\n    fprintf(output, \"                           listen on this socket instead of the console\\n\");\n    fprintf(output, \"  --foreground             do not detach from console\\n\");\n    fprintf(output, \"  -h, --help               show this help information\\n\");\n    fprintf(output, \"  -v, --version            show version information\\n\");\n    fprintf(output, \"  -C <config profile>, --config-profile <config profile>\\n\");\n    fprintf(output, \"                           start with specified configuration profile\\n\");\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Supported socket types:\\n\");\n#ifdef SHARKD_UNIX_SUPPORT\n    fprintf(output, \"    unix:/tmp/sharkd.sock - listen on Unix domain socket file /tmp/sharkd.sock\\n\");\n    fprintf(output, \"    unix:@sharkd          - listen on abstract Unix socket 'sharkd' (Linux-only)\\n\");\n#else\n    fprintf(output, \"    (Unix domain sockets are unavailable on this platform.)\\n\");\n#endif\n#ifdef SHARKD_TCP_SUPPORT\n    fprintf(output, \"    tcp:127.0.0.1:4446    - listen on TCP port 4446\\n\");\n#else\n    fprintf(output, \"    (TCP sockets are disabled in this build)\\n\");\n#endif\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"If no socket option is provided, or if 'sharkd -' is used,\\n\");\n    fprintf(output, \"sharkd will accept commands via console (standard input).\\n\");\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Examples:\\n\");\n    fprintf(output, \"    sharkd -\\n\");\n    fprintf(output, \"    sharkd -C myprofile\\n\");\n#ifdef SHARKD_UNIX_SUPPORT\n    fprintf(output, \"    sharkd -a unix:/tmp/sharkd.sock -C myprofile\\n\");\n#elif defined(SHARKD_TCP_SUPPORT)\n    fprintf(output, \"    sharkd -a tcp:127.0.0.1:4446 -C myprofile\\n\");\n#endif\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"For security reasons, do not directly expose sharkd to the public Internet.\\n\");\n    fprintf(output, \"Instead, have a separate backend service to interact with sharkd.\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"For full details, see https://wiki.wireshark.org/Development/sharkd\\n\");\n    fprintf(output, \"\\n\");\n}\n\nint\nsharkd_init(int argc, char **argv)\n{\n    /*\n     * The leading + ensures that getopt_long() does not permute the argv[]\n     * entries.\n     *\n     * We have to make sure that the first getopt_long() preserves the content\n     * of argv[] for the subsequent getopt_long() call.\n     *\n     * We use getopt_long() in both cases to ensure that we're using a routine\n     * whose permutation behavior we can control in the same fashion on all\n     * platforms, and so that, if we ever need to process a long argument before\n     * doing further initialization, we can do so.\n     *\n     * Glibc and Solaris libc document that a leading + disables permutation\n     * of options, regardless of whether POSIXLY_CORRECT is set or not; *BSD\n     * and macOS don't document it, but do so anyway.\n     *\n     * We do *not* use a leading - because the behavior of a leading - is\n     * platform-dependent.\n     */\n\n#define OPTSTRING \"+\" \"a:hmvC:\"\n#define LONGOPT_FOREGROUND 4000\n\n    static const char    optstring[] = OPTSTRING;\n\n    static const struct ws_option long_options[] = {\n        {\"api\", ws_required_argument, NULL, 'a'},\n        {\"foreground\", ws_no_argument, NULL, LONGOPT_FOREGROUND},\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        {\"config-profile\", ws_required_argument, NULL, 'C'},\n        {0, 0, 0, 0 }\n    };\n\n    int opt;\n\n#ifndef _WIN32\n    pid_t pid;\n#endif\n    socket_handle_t fd;\n    bool foreground = false;\n\n    if (argc < 2)\n    {\n        print_usage(stderr);\n        return -1;\n    }\n\n    // check for classic command line\n    if (!strcmp(argv[1], \"-\") || argv[1][0] == 't' || argv[1][0] == 'u')\n    {\n        mode = SHARKD_MODE_CLASSIC_CONSOLE;\n\n#ifndef _WIN32\n        signal(SIGCHLD, SIG_IGN);\n#endif\n\n        if (!strcmp(argv[1], \"-\"))\n        {\n            mode = SHARKD_MODE_CLASSIC_CONSOLE;\n        }\n        else\n        {\n            fd = socket_init(argv[1]);\n            if (fd == INVALID_SOCKET)\n                return -1;\n            _server_fd = fd;\n            mode = SHARKD_MODE_CLASSIC_DAEMON;\n        }\n    }\n    else\n        mode = SHARKD_MODE_GOLD_CONSOLE;  // assume we are running as gold console\n\n    if (mode >= SHARKD_MODE_GOLD_CONSOLE)\n    {\n        /*\n           In Daemon Mode, we will come through here twice; once when we start the Daemon and\n           once again after we have forked the session process.  The second time through, the\n           session process has already had its stdin and stdout wired up to the TCP or UNIX\n           socket and so in the original version of sharkd the session process is invoked with\n           the command line: sharkd -\n\n           When not using the classic command line, we want to spawn the session process with\n           the complete command line with all the new options but with the -a option and\n           parameter removed.  Invoking a second time with the -a option will cause a loop\n           where we repeatedly spawn a new session process.\n           */\n\n        do {\n            if (ws_optind > (argc - 1))\n                break;\n\n            opt = ws_getopt_long(argc, argv, optstring, long_options, NULL);\n\n            switch (opt) {\n                case 'C':        /* Configuration Profile */\n                    if (profile_exists(ws_optarg, false)) {\n                        set_profile_name(ws_optarg);  // In Daemon Mode, we may need to do this again in the child process\n                    }\n                    else {\n                        fprintf(stderr, \"Configuration Profile \\\"%s\\\" does not exist\\n\", ws_optarg);\n                        return -1;\n                    }\n                    break;\n\n                case 'a':\n                    fd = socket_init(ws_optarg);\n                    if (fd == INVALID_SOCKET)\n                        return -1;\n                    _server_fd = fd;\n\n                    fprintf(stderr, \"Sharkd listening on: %s\\n\", ws_optarg);\n\n                    mode = SHARKD_MODE_GOLD_DAEMON;\n                    break;\n\n                case 'h':\n                    show_help_header(\"Daemon variant of Wireshark\");\n                    print_usage(stdout);\n                    exit(0);\n                    break;\n\n                case 'm':\n                    // m is an internal-only option used when the daemon session process is created\n                    mode = SHARKD_MODE_GOLD_CONSOLE;\n                    break;\n\n                case 'v':         /* Show version and exit */\n                    show_version();\n                    exit(0);\n                    break;\n\n                case LONGOPT_FOREGROUND:\n                    foreground = true;\n                    break;\n\n                default:\n                    if (!ws_optopt)\n                        fprintf(stderr, \"This option isn't supported: %s\\n\", argv[ws_optind]);\n                    fprintf(stderr, \"Use sharkd -h for details of supported options\\n\");\n                    exit(0);\n                    break;\n            }\n        } while (opt != -1);\n    }\n\n    if (!foreground && (mode == SHARKD_MODE_CLASSIC_DAEMON || mode == SHARKD_MODE_GOLD_DAEMON))\n    {\n        /* all good - try to daemonize */\n#ifndef _WIN32\n        pid = fork();\n        if (pid == -1)\n            fprintf(stderr, \"cannot go to background fork() failed: %s\\n\", g_strerror(errno));\n\n        if (pid != 0)\n        {\n            /* parent */\n            exit(0);\n        }\n#endif\n    }\n\n    return 0;\n}\n\nint\n#ifndef _WIN32\nsharkd_loop(int argc _U_, char* argv[] _U_)\n#else\nsharkd_loop(int argc _U_, char* argv[])\n#endif\n{\n    if (mode == SHARKD_MODE_CLASSIC_CONSOLE || mode == SHARKD_MODE_GOLD_CONSOLE)\n    {\n        return sharkd_session_main(mode);\n    }\n\n    while (1)\n    {\n#ifndef _WIN32\n        pid_t pid;\n#else\n        size_t i_handles;\n        HANDLE handles[2];\n        PROCESS_INFORMATION pi;\n        STARTUPINFO si;\n        char *exename;\n        char command_line[2048];\n#endif\n        socket_handle_t fd;\n\n        fd = accept(_server_fd, NULL, NULL);\n        if (fd == INVALID_SOCKET)\n        {\n            fprintf(stderr, \"cannot accept(): %s\\n\", g_strerror(errno));\n            continue;\n        }\n\n        /* wireshark is not ready for handling multiple capture files in single process, so fork(), and handle it in separate process */\n#ifndef _WIN32\n        pid = fork();\n        if (pid == 0)\n        {\n            closesocket(_server_fd);\n            /* redirect stdin, stdout to socket */\n            dup2(fd, 0);\n            dup2(fd, 1);\n            close(fd);\n\n            exit(sharkd_session_main(mode));\n        }\n\n        if (pid == -1)\n        {\n            fprintf(stderr, \"cannot fork(): %s\\n\", g_strerror(errno));\n        }\n\n#else\n        memset(&pi, 0, sizeof(pi));\n        memset(&si, 0, sizeof(si));\n\n        si.cb = sizeof(si);\n        si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\n        si.hStdInput = (HANDLE) fd;\n        si.hStdOutput = (HANDLE) fd;\n        si.hStdError = GetStdHandle(STD_ERROR_HANDLE);\n\n        i_handles = 0;\n        handles[i_handles++] = (HANDLE)fd;\n        if (si.hStdError != NULL) {\n            handles[i_handles++] = si.hStdError;\n        }\n\n        exename = get_executable_path(\"sharkd\");\n\n        // we need to pass in all of the command line parameters except the -a parameter\n        // passing in -a at this point would could a loop, each iteration of which would generate a new session process\n        memset(&command_line, 0, sizeof(command_line));\n\n        if (mode <= SHARKD_MODE_CLASSIC_DAEMON)\n        {\n            (void) g_strlcat(command_line, \"sharkd.exe -\", sizeof(command_line));\n        }\n        else\n        {\n            // The -m option used here is an internal-only option that notifies the child process that it should\n            // run in Gold Console mode\n            (void) g_strlcat(command_line, \"sharkd.exe -m\", sizeof(command_line));\n\n            for (int i = 1; i < argc; i++)\n            {\n                if (\n                        !g_ascii_strncasecmp(argv[i], \"-a\", strlen(argv[i]))\n                        || !g_ascii_strncasecmp(argv[i], \"--api\", strlen(argv[i]))\n                   )\n                {\n                    i++;  // skip the socket details\n                }\n                else\n                {\n                    (void) g_strlcat(command_line, \" \", sizeof(command_line));\n                    (void) g_strlcat(command_line, argv[i], sizeof(command_line));\n                }\n            }\n        }\n\n        if (!win32_create_process(exename, command_line, NULL, NULL, i_handles, handles, 0, NULL, NULL, &si, &pi))\n        {\n            fprintf(stderr, \"win32_create_process(%s) failed\\n\", exename);\n        }\n        else\n        {\n            CloseHandle(pi.hThread);\n        }\n\n        g_free(exename);\n#endif\n\n        closesocket(fd);\n    }\n    return 0;\n}\n"
        },
        {
          "name": "sharkd_session.c",
          "type": "blob",
          "size": 196.45703125,
          "content": "/* sharkd_session.c\n *\n * Copyright (C) 2016 Jakub Zawadzki\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <inttypes.h>\n\n#include <glib.h>\n\n#include <wsutil/wsjson.h>\n#include <wsutil/json_dumper.h>\n#include <wsutil/ws_assert.h>\n#include <wsutil/wsgcrypt.h>\n\n#include <file.h>\n#include <epan/epan_dissect.h>\n#include <epan/exceptions.h>\n#include <epan/color_filters.h>\n#include <epan/prefs.h>\n#include <epan/prefs-int.h>\n#include <epan/uat-int.h>\n#include <wiretap/wtap.h>\n\n#include <epan/column.h>\n#include <epan/column-info.h>\n\n#include <ui/ssl_key_export.h>\n\n#include <ui/io_graph_item.h>\n#include <epan/stats_tree_priv.h>\n#include <epan/stat_tap_ui.h>\n#include <epan/conversation_table.h>\n#include <epan/sequence_analysis.h>\n#include <epan/expert.h>\n#include <epan/export_object.h>\n#include <epan/follow.h>\n#include <epan/rtd_table.h>\n#include <epan/srt_table.h>\n#include <epan/to_str.h>\n\n#include <epan/dissectors/packet-h225.h>\n#include <epan/rtp_pt.h>\n#include <ui/voip_calls.h>\n#include <ui/rtp_stream.h>\n#include <ui/tap-rtp-common.h>\n#include <ui/tap-rtp-analysis.h>\n#include <ui/cli/tap-protohierstat.h>\n#include <ui/cli/tap-voip.h>\n#include <wsutil/version_info.h>\n#include <epan/to_str.h>\n\n#include <epan/addr_resolv.h>\n#include <epan/dissectors/packet-rtp.h>\n#include <ui/rtp_media.h>\n#include <ui/mcast_stream.h>\n#include <speex/speex_resampler.h>\n\n#include <epan/maxmind_db.h>\n\n#include <wsutil/pint.h>\n#include <wsutil/strnatcmp.h>\n#include <wsutil/strtoi.h>\n\n#include \"globals.h\"\n\n#include \"sharkd.h\"\n\nstruct sharkd_filter_item\n{\n    uint8_t *filtered; /* can be NULL if all frames are matching for given filter. */\n};\n\nstatic GHashTable *filter_table;\n\nstatic int mode;\nstatic uint32_t rpcid;\n\nstatic json_dumper dumper;\n\n\nstatic const char *\njson_find_attr(const char *buf, const jsmntok_t *tokens, int count, const char *attr)\n{\n    int i;\n\n    for (i = 0; i < count; i += 2)\n    {\n        const char *tok_attr  = &buf[tokens[i + 0].start];\n        const char *tok_value = &buf[tokens[i + 1].start];\n\n        if (!strcmp(tok_attr, attr))\n            return tok_value;\n    }\n\n    return NULL;\n}\n\nstatic void\njson_print_base64(const uint8_t *data, size_t len)\n{\n    json_dumper_begin_base64(&dumper);\n    json_dumper_write_base64(&dumper, data, len);\n    json_dumper_end_base64(&dumper);\n}\n\nstatic void G_GNUC_PRINTF(2, 3)\nsharkd_json_value_anyf(const char *key, const char *format, ...)\n{\n    if (key)\n        json_dumper_set_member_name(&dumper, key);\n\n    va_list ap;\n    va_start(ap, format);\n    json_dumper_value_va_list(&dumper, format, ap);\n    va_end(ap);\n}\n\nstatic void\nsharkd_json_value_string(const char *key, const char *str)\n{\n    if (key)\n        json_dumper_set_member_name(&dumper, key);\n    json_dumper_value_string(&dumper, str);\n}\n\nstatic void\nsharkd_json_value_base64(const char *key, const uint8_t *data, size_t len)\n{\n    if (key)\n        json_dumper_set_member_name(&dumper, key);\n    json_print_base64(data, len);\n}\n\nstatic void G_GNUC_PRINTF(2, 3)\nsharkd_json_value_stringf(const char *key, const char *format, ...)\n{\n    if (key)\n        json_dumper_set_member_name(&dumper, key);\n\n    va_list ap;\n    va_start(ap, format);\n    char* sformat = ws_strdup_printf(\"\\\"%s\\\"\", format);\n    json_dumper_value_va_list(&dumper, sformat, ap);\n    g_free(sformat);\n    va_end(ap);\n}\n\nstatic void\nsharkd_json_array_open(const char *key)\n{\n    if (key)\n        json_dumper_set_member_name(&dumper, key);\n    json_dumper_begin_array(&dumper);\n}\n\nstatic void\nsharkd_json_array_close(void)\n{\n    json_dumper_end_array(&dumper);\n}\n\nstatic void\nsharkd_json_object_open(const char *key)\n{\n    if (key)\n        json_dumper_set_member_name(&dumper, key);\n    json_dumper_begin_object(&dumper);\n}\n\nstatic void\nsharkd_json_object_close(void)\n{\n    json_dumper_end_object(&dumper);\n}\n\nstatic void\nsharkd_json_response_open(uint32_t id)\n{\n    json_dumper_begin_object(&dumper);  // start the message\n    sharkd_json_value_string(\"jsonrpc\", \"2.0\");\n    sharkd_json_value_anyf(\"id\", \"%d\", id);\n}\n\nstatic void\nsharkd_json_response_close(void)\n{\n    json_dumper_end_object(&dumper);  // end the message\n\n    json_dumper_finish(&dumper);\n\n    /*\n     * We do an explicit fflush after every line, because\n     * we want output to be written to the socket as soon\n     * as the line is complete.\n     *\n     * The stream is fully-buffered by default, so it's\n     * only flushed when the buffer fills or the FILE *\n     * is closed.  On UN*X, we could set it to be line\n     * buffered, but the MSVC standard I/O routines don't\n     * support line buffering - they only support *byte*\n     * buffering, doing a write for every byte written,\n     * which is too inefficient, and full buffering,\n     * which is what you get if you request line buffering.\n     */\n    fflush(stdout);\n}\n\nstatic void\nsharkd_json_result_prologue(uint32_t id)\n{\n    sharkd_json_response_open(id);\n    sharkd_json_object_open(\"result\");  // start the result object\n}\n\nstatic void\nsharkd_json_result_epilogue(void)\n{\n    json_dumper_end_object(&dumper);  // end the result object\n    sharkd_json_response_close();\n}\n\nstatic void\nsharkd_json_result_array_prologue(uint32_t id)\n{\n    sharkd_json_response_open(id);\n    sharkd_json_array_open(\"result\");   // start the result array\n}\n\nstatic void\nsharkd_json_result_array_epilogue(void)\n{\n    sharkd_json_array_close();        // end of result array\n    sharkd_json_response_close();\n}\n\nstatic void\nsharkd_json_simple_ok(uint32_t id)\n{\n    sharkd_json_result_prologue(id);\n    sharkd_json_value_string(\"status\", \"OK\");\n    sharkd_json_result_epilogue();\n}\n\nstatic void\nsharkd_json_warning(uint32_t id, char *warning)\n{\n    sharkd_json_result_prologue(id);\n    sharkd_json_value_string(\"status\", \"Warning\");\n    sharkd_json_value_string(\"warning\", warning);\n    sharkd_json_result_epilogue();\n}\n\nstatic void G_GNUC_PRINTF(4, 5)\nsharkd_json_error(uint32_t id, int code, char* data, char* format, ...)\n{\n    sharkd_json_response_open(id);\n    sharkd_json_object_open(\"error\");\n    sharkd_json_value_anyf(\"code\", \"%d\", code);\n\n    if (format)\n    {\n        // format the text message\n        va_list args;\n\n        va_start(args, format);\n        char *error_msg = ws_strdup_vprintf(format, args);\n        va_end(args);\n\n        sharkd_json_value_string(\"message\", error_msg);\n\n        g_free(error_msg);\n    }\n\n    sharkd_json_object_close();\n\n    if (data)\n        sharkd_json_value_string(\"data\", data);\n\n    sharkd_json_response_close();\n}\n\nstatic bool\nis_param_match(const char *param_in, const char *valid_param)\n{\n    char* ptr;\n\n    if ((ptr = g_strrstr(valid_param, \"*\")))\n    {\n        size_t prefix_len = ptr - valid_param;\n        return !strncmp(param_in, valid_param, prefix_len);\n    }\n    else\n        return !strcmp(param_in, valid_param);\n}\n\n/*\n * json_prep does four things:\n *\n *   1. check the syntax of the root and parameter members\n *   2. tokenize the names and values by zero terminating them\n *   3. unescape the names and values\n *   4. extracts and saves the rpcid\n *      - we have to do it here as it's needed for the error messages\n *\n * The objective is to minimise the validation work in the functions\n * that process each called method.\n *\n * This gets a little messy as the JSON parser creates a flat list\n * of all members rather than create a tree.\n */\nstatic bool\njson_prep(char* buf, const jsmntok_t* tokens, int count)\n{\n    int i;\n    const char* method = NULL;\n    char* attr_name = NULL;\n    char* attr_value = NULL;\n\n#define SHARKD_JSON_ANY      0\n#define SHARKD_JSON_STRING   1\n#define SHARKD_JSON_INTEGER  2\n#define SHARKD_JSON_UINTEGER 3\n#define SHARKD_JSON_FLOAT    4\n#define SHARKD_JSON_OBJECT   5\n#define SHARKD_JSON_ARRAY    6\n#define SHARKD_JSON_BOOLEAN  7\n#define SHARKD_ARRAY_END     99\n\n    struct member_attribute {\n        const char* parent_ctx;\n        const char* name;\n        int level;\n        jsmntype_t type;\n        int value_type;\n        bool is_mandatory;\n    };\n\n#define SHARKD_MANDATORY true\n#define SHARKD_OPTIONAL false\n\n    /*\n     * The member attribute structure is key to the syntax checking.  The\n     * array contains all of the root level (1) member names, the data\n     * types permissible for the value and a boolean that indicates whether\n     * or not the member is mandatory.\n     *\n     * Once we get into the next layer (2) of the json tree, we need to check\n     * params member names and data types dependent in the context of the method\n     * (parent_ctx).\n     */\n\n    struct member_attribute name_array[] = {\n        // Root members\n        {NULL,         \"jsonrpc\",        1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_MANDATORY},\n        {NULL,         \"userid\",         1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {NULL,         \"id\",             1, JSMN_PRIMITIVE,    SHARKD_JSON_UINTEGER, SHARKD_MANDATORY},\n        {NULL,         \"method\",         1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_MANDATORY},\n        {NULL,         \"params\",         1, JSMN_OBJECT,       SHARKD_JSON_OBJECT,   SHARKD_OPTIONAL},\n\n        // Valid methods\n        {\"method\",     \"analyse\",        1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"bye\",            1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"check\",          1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"complete\",       1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"download\",       1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"dumpconf\",       1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"follow\",         1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"frame\",          1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"frames\",         1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"info\",           1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"intervals\",      1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"iograph\",        1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"load\",           1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"setcomment\",     1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"setconf\",        1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"status\",         1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"method\",     \"tap\",            1, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n\n        // Parameters and their method context\n        {\"check\",      \"field\",          2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"check\",      \"filter\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"complete\",   \"field\",          2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"complete\",   \"pref\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"download\",   \"token\",          2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"dumpconf\",   \"pref\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"follow\",     \"follow\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_MANDATORY},\n        {\"follow\",     \"filter\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_MANDATORY},\n        {\"follow\",     \"sub_stream\",     2, JSMN_PRIMITIVE,    SHARKD_JSON_UINTEGER, SHARKD_OPTIONAL},\n        {\"frame\",      \"frame\",          2, JSMN_PRIMITIVE,    SHARKD_JSON_UINTEGER, SHARKD_MANDATORY},\n        {\"frame\",      \"proto\",          2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"frame\",      \"ref_frame\",      2, JSMN_PRIMITIVE,    SHARKD_JSON_UINTEGER, SHARKD_OPTIONAL},\n        {\"frame\",      \"prev_frame\",     2, JSMN_PRIMITIVE,    SHARKD_JSON_UINTEGER, SHARKD_OPTIONAL},\n        {\"frame\",      \"columns\",        2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"frame\",      \"color\",          2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"frame\",      \"bytes\",          2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"frame\",      \"hidden\",         2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"frames\",     \"column*\",        2, JSMN_UNDEFINED,    SHARKD_JSON_ANY,      SHARKD_OPTIONAL},\n        {\"frames\",     \"filter\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"frames\",     \"skip\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_UINTEGER, SHARKD_OPTIONAL},\n        {\"frames\",     \"limit\",          2, JSMN_PRIMITIVE,    SHARKD_JSON_UINTEGER, SHARKD_OPTIONAL},\n        {\"frames\",     \"refs\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"intervals\",  \"interval\",       2, JSMN_PRIMITIVE,    SHARKD_JSON_UINTEGER, SHARKD_OPTIONAL},\n        {\"intervals\",  \"filter\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"interval\",       2, JSMN_PRIMITIVE,    SHARKD_JSON_UINTEGER, SHARKD_OPTIONAL},\n        {\"iograph\",    \"interval_units\", 2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"graph0\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_MANDATORY},\n        {\"iograph\",    \"graph1\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"graph2\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"graph3\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"graph4\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"graph5\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"graph6\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"graph7\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"graph8\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"graph9\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter0\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter1\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter2\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter3\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter4\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter5\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter6\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter7\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter8\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"filter9\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"iograph\",    \"aot0\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"iograph\",    \"aot1\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"iograph\",    \"aot2\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"iograph\",    \"aot3\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"iograph\",    \"aot4\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"iograph\",    \"aot5\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"iograph\",    \"aot6\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"iograph\",    \"aot7\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"iograph\",    \"aot8\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"iograph\",    \"aot9\",           2, JSMN_PRIMITIVE,    SHARKD_JSON_BOOLEAN,  SHARKD_OPTIONAL},\n        {\"load\",       \"file\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_MANDATORY},\n        {\"setcomment\", \"frame\",          2, JSMN_PRIMITIVE,    SHARKD_JSON_UINTEGER, SHARKD_MANDATORY},\n        {\"setcomment\", \"comment\",        2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"setconf\",    \"name\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_MANDATORY},\n        {\"setconf\",    \"value\",          2, JSMN_UNDEFINED,    SHARKD_JSON_ANY,      SHARKD_MANDATORY},\n        {\"tap\",        \"tap0\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_MANDATORY},\n        {\"tap\",        \"tap1\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap2\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap3\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap4\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap5\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap6\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap7\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap8\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap9\",           2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap10\",          2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap11\",          2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap12\",          2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap13\",          2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap14\",          2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"tap15\",          2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n        {\"tap\",        \"filter\",         2, JSMN_STRING,       SHARKD_JSON_STRING,   SHARKD_OPTIONAL},\n\n        // End of the name_array\n        {NULL,         NULL,             0, JSMN_STRING,       SHARKD_ARRAY_END,   SHARKD_OPTIONAL},\n    };\n\n    rpcid = 0;\n\n    /* sanity check, and split strings */\n    if (count < 1 || tokens[0].type != JSMN_OBJECT)\n    {\n        sharkd_json_error(\n                rpcid, -32600, NULL,\n                \"The request must an object\"\n                );\n        return false;\n    }\n\n    /* don't need [0] token */\n    tokens++;\n    count--;\n\n    if (count & 1)\n    {\n        sharkd_json_error(\n                rpcid, -32600, NULL,\n                \"The request must contain name/value pairs\"\n                );\n        return false;\n    }\n\n    for (i = 0; i < count; i += 2)\n    {\n        buf[tokens[i + 0].end] = '\\0';\n        buf[tokens[i + 1].end] = '\\0';\n    }\n\n    // we must get the id as soon as possible so that it's available in all future error messages\n    attr_value = (char*)json_find_attr(buf, tokens, count, \"id\");\n    if (attr_value)\n    {\n        if (!ws_strtou32(attr_value, NULL, &rpcid))\n        {\n            sharkd_json_error(\n                    rpcid, -32600, NULL,\n                    \"The id value must be a positive integer\"\n                    );\n            return false;\n        }\n    }\n\n    method = json_find_attr(buf, tokens, count, \"method\");\n\n    if (method)\n    {\n        bool is_supported = false;\n        i = 0;  // name array index\n\n        // check that the request method is good\n        while (name_array[i].value_type != SHARKD_ARRAY_END)\n        {\n            if (name_array[i].parent_ctx)\n            {\n                if (!strcmp(method, name_array[i].name) && !strcmp(name_array[i].parent_ctx, \"method\"))\n                    is_supported = true;  // the method is valid\n            }\n\n            i++;\n        }\n\n        if (!is_supported)\n        {\n            sharkd_json_error(\n                    rpcid, -32601, NULL,\n                    \"The method %s is not supported\", method\n                    );\n            return false;\n        }\n    }\n\n    for (i = 0; i < count; i += 2)\n    {\n        if (tokens[i].type != JSMN_STRING)\n        {\n            sharkd_json_error(\n                    rpcid, -32600, NULL,\n                    \"Member names must be a string - member %d is not string\", (i / 2) + 1\n                    );\n            return false;\n        }\n\n        attr_name = &buf[tokens[i + 0].start];\n        attr_value = &buf[tokens[i + 1].start];\n\n        if (!strcmp(attr_name, \"jsonrpc\"))\n        {\n            if (strcmp(&buf[tokens[i + 1].start], \"2.0\"))\n            {\n                sharkd_json_error(\n                        rpcid, -32600, NULL,\n                        \"Only JSON %s is supported\", \"2.0\"\n                        );\n                return false;\n            }\n        }\n\n        /* unescape only value, as keys are simple strings */\n        if (tokens[i + 1].type == JSMN_STRING && !json_decode_string_inplace(attr_value))\n        {\n            sharkd_json_error(\n                    rpcid, -32600, NULL,\n                    \"Cannot unescape the value string of member %d\", (i / 2) + 1\n                    );\n            return false;\n        }\n\n        /* Confirm that the member is valid */\n        bool match = false;\n\n        // We need to check root members (level 1) and parameters (level 2), hence the for loop.\n\n        for (int level = 1; level < 3; level++)\n        {\n            size_t j = 0;\n\n            while (name_array[j].value_type != SHARKD_ARRAY_END)  // iterate through the array until we hit the end\n            {\n                if (is_param_match(attr_name, name_array[j].name) && name_array[j].level == level)\n                {\n                    // We need to be sure the match is in the correct context\n                    // i.e. is this a match for a root member (level 1) or for a parameter (level 2).\n\n                    if (level == 1)\n                    {\n                        // need to guard against a parameter name matching a method name\n                        if (method)\n                        {\n                            if (name_array[j].parent_ctx)\n                            {\n                                j++;\n                                continue;\n                            }\n\n                            if (!strcmp(method, &buf[tokens[i + 0].start]))\n                            {\n                                j++;\n                                continue;\n                            }\n                        }\n\n                        match = true;\n                    }\n                    else if (method)\n                    {\n                        if (level == 2 && !strcmp(name_array[j].parent_ctx, method))\n                            match = true;\n                        else\n                        {\n                            j++;\n                            continue;\n                        }\n                    }\n                    else\n                    {\n                        j++;\n                        continue;\n                    }\n\n                    // The match looks good, let's now check the data types\n\n                    if (tokens[i + 1].type != name_array[j].type && name_array[j].type != SHARKD_JSON_ANY)\n                    {\n                        sharkd_json_error(\n                                rpcid, -32600, NULL,\n                                \"The data type for member %s is not valid\", attr_name\n                                );\n                        return false;\n                    }\n                    else if (name_array[j].type == JSMN_PRIMITIVE && name_array[j].value_type == SHARKD_JSON_UINTEGER)\n                    {\n                        uint32_t temp;\n                        if (!ws_strtou32(attr_value, NULL, &temp) || temp <= 0)\n                        {\n                            sharkd_json_error(\n                                    rpcid, -32600, NULL,\n                                    \"The value for %s must be a positive integer\", name_array[j].name\n                                    );\n                            return false;\n                        }\n                    }\n                    else if (name_array[j].type == JSMN_PRIMITIVE && name_array[j].value_type == SHARKD_JSON_BOOLEAN)\n                    {\n                        if (strcmp(attr_value, \"true\") && strcmp(attr_value, \"false\"))\n                        {\n                            sharkd_json_error(\n                                    rpcid, -32600, NULL,\n                                    \"The value for %s must be a boolean (true or false)\", name_array[j].name\n                                    );\n                            return false;\n                        }\n\n                    }\n                    break; // looks like a valid match\n                }\n                j++;\n            }\n        }\n\n        if (!match)\n        {\n            sharkd_json_error(\n                    rpcid, -32600, NULL,\n                    \"%s is not a valid member name\", attr_name\n                    );\n            return false;\n        }\n    }\n\n    /* check for mandatory members */\n    size_t j = 0;\n\n    while (name_array[j].value_type != SHARKD_ARRAY_END)\n    {\n        if (name_array[j].is_mandatory && name_array[j].level == 1)\n        {\n            if (!json_find_attr(buf, tokens, count, name_array[j].name))\n            {\n                sharkd_json_error(\n                        rpcid, -32600, NULL,\n                        \"Mandatory member %s is missing\", name_array[j].name\n                        );\n                return false;\n            }\n        }\n        j++;\n    }\n\n    // check that the current request contains the mandatory parameters\n    j = 0;\n\n    while (name_array[j].value_type != SHARKD_ARRAY_END)\n    {\n        if (name_array[j].is_mandatory && name_array[j].level == 2 && !strcmp(method, name_array[j].parent_ctx))\n        {\n            if (!json_find_attr(buf, tokens, count, name_array[j].name))\n            {\n                sharkd_json_error(\n                        rpcid, -32600, NULL,\n                        \"Mandatory parameter %s is missing\", name_array[j].name\n                        );\n                return false;\n            }\n        }\n        j++;\n    }\n\n\n    // check that the parameters for the current request are valid for the method and that the data type for the value is valid\n\n    return true;\n}\n\nstatic void\nsharkd_session_filter_free(void *data)\n{\n    struct sharkd_filter_item *l = (struct sharkd_filter_item *) data;\n\n    g_free(l->filtered);\n    g_free(l);\n}\n\nstatic const struct sharkd_filter_item *\nsharkd_session_filter_data(const char *filter)\n{\n    struct sharkd_filter_item *l;\n\n    l = (struct sharkd_filter_item *) g_hash_table_lookup(filter_table, filter);\n    if (!l)\n    {\n        uint8_t *filtered = NULL;\n\n        int ret = sharkd_filter(filter, &filtered);\n\n        if (ret == -1)\n            return NULL;\n\n        l = g_new(struct sharkd_filter_item, 1);\n        l->filtered = filtered;\n\n        g_hash_table_insert(filter_table, g_strdup(filter), l);\n    }\n\n    return l;\n}\n\nstatic bool\nsharkd_rtp_match_init(rtpstream_id_t *id, const char *init_str)\n{\n    bool ret = false;\n    char **arr;\n    uint32_t tmp_addr_src, tmp_addr_dst;\n    address tmp_src_addr, tmp_dst_addr;\n\n    memset(id, 0, sizeof(*id));\n\n    arr = g_strsplit(init_str, \"_\", 7); /* pass larger value, so we'll catch incorrect input :) */\n    if (g_strv_length(arr) != 5)\n        goto fail;\n\n    /* TODO, for now only IPv4 */\n    if (!get_host_ipaddr(arr[0], &tmp_addr_src))\n        goto fail;\n\n    if (!ws_strtou16(arr[1], NULL, &id->src_port))\n        goto fail;\n\n    if (!get_host_ipaddr(arr[2], &tmp_addr_dst))\n        goto fail;\n\n    if (!ws_strtou16(arr[3], NULL, &id->dst_port))\n        goto fail;\n\n    if (!ws_hexstrtou32(arr[4], NULL, &id->ssrc))\n        goto fail;\n\n    set_address(&tmp_src_addr, AT_IPv4, 4, &tmp_addr_src);\n    copy_address(&id->src_addr, &tmp_src_addr);\n    set_address(&tmp_dst_addr, AT_IPv4, 4, &tmp_addr_dst);\n    copy_address(&id->dst_addr, &tmp_dst_addr);\n\n    ret = true;\n\nfail:\n    g_strfreev(arr);\n    return ret;\n}\n\nstatic bool\nsharkd_session_process_info_nstat_cb(const void *key, void *value, void *userdata _U_)\n{\n    stat_tap_table_ui *stat_tap = (stat_tap_table_ui *) value;\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_string(\"name\", stat_tap->title);\n    sharkd_json_value_stringf(\"tap\", \"nstat:%s\", (const char *) key);\n    json_dumper_end_object(&dumper);\n\n    return false;\n}\n\nstatic bool\nsharkd_session_process_info_conv_cb(const void* key, void* value, void* userdata _U_)\n{\n    struct register_ct *table = (struct register_ct *) value;\n\n    const char *label = (const char *) key;\n\n    if (get_conversation_packet_func(table))\n    {\n        json_dumper_begin_object(&dumper);\n        sharkd_json_value_stringf(\"name\", \"Conversation List/%s\", label);\n        sharkd_json_value_stringf(\"tap\", \"conv:%s\", label);\n        json_dumper_end_object(&dumper);\n    }\n\n    if (get_endpoint_packet_func(table))\n    {\n        json_dumper_begin_object(&dumper);\n        sharkd_json_value_stringf(\"name\", \"Endpoint/%s\", label);\n        sharkd_json_value_stringf(\"tap\", \"endpt:%s\", label);\n        json_dumper_end_object(&dumper);\n    }\n    return false;\n}\n\nstatic bool\nsharkd_session_seq_analysis_cb(const void *key, void *value, void *userdata _U_)\n{\n    register_analysis_t *analysis = (register_analysis_t *) value;\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_string(\"name\", sequence_analysis_get_ui_name(analysis));\n    sharkd_json_value_stringf(\"tap\", \"seqa:%s\", (const char *) key);\n    json_dumper_end_object(&dumper);\n\n    return false;\n}\n\nstatic bool\nsharkd_export_object_visit_cb(const void *key _U_, void *value, void *user_data _U_)\n{\n    register_eo_t *eo = (register_eo_t *) value;\n\n    const int proto_id = get_eo_proto_id(eo);\n    const char *filter = proto_get_protocol_filter_name(proto_id);\n    const char *label  = proto_get_protocol_short_name(find_protocol_by_id(proto_id));\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_stringf(\"name\", \"Export Object/%s\", label);\n    sharkd_json_value_stringf(\"tap\", \"eo:%s\", filter);\n    json_dumper_end_object(&dumper);\n\n    return false;\n}\n\nstatic bool\nsharkd_srt_visit_cb(const void *key _U_, void *value, void *user_data _U_)\n{\n    register_srt_t *srt = (register_srt_t *) value;\n\n    const int proto_id = get_srt_proto_id(srt);\n    const char *filter = proto_get_protocol_filter_name(proto_id);\n    const char *label  = proto_get_protocol_short_name(find_protocol_by_id(proto_id));\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_stringf(\"name\", \"Service Response Time/%s\", label);\n    sharkd_json_value_stringf(\"tap\", \"srt:%s\", filter);\n    json_dumper_end_object(&dumper);\n\n    return false;\n}\n\nstatic bool\nsharkd_rtd_visit_cb(const void *key _U_, void *value, void *user_data _U_)\n{\n    register_rtd_t *rtd = (register_rtd_t *) value;\n\n    const int proto_id = get_rtd_proto_id(rtd);\n    const char *filter = proto_get_protocol_filter_name(proto_id);\n    const char *label  = proto_get_protocol_short_name(find_protocol_by_id(proto_id));\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_stringf(\"name\", \"Response Time Delay/%s\", label);\n    sharkd_json_value_stringf(\"tap\", \"rtd:%s\", filter);\n    json_dumper_end_object(&dumper);\n\n    return false;\n}\n\nstatic bool\nsharkd_follower_visit_cb(const void *key _U_, void *value, void *user_data _U_)\n{\n    register_follow_t *follower = (register_follow_t *) value;\n\n    const int proto_id = get_follow_proto_id(follower);\n    const char *label  = proto_get_protocol_short_name(find_protocol_by_id(proto_id));\n    const char *filter = label; /* correct: get_follow_by_name() is registered by short name */\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_stringf(\"name\", \"Follow/%s\", label);\n    sharkd_json_value_stringf(\"tap\", \"follow:%s\", filter);\n    json_dumper_end_object(&dumper);\n\n    return false;\n}\n\nstatic void\nsharkd_session_print_capture_types(void)\n{\n    unsigned i;\n    GArray *writable_type_subtypes;\n    writable_type_subtypes = wtap_get_writable_file_types_subtypes(FT_SORT_BY_NAME);\n    for (i = 0; i < writable_type_subtypes->len; i++) {\n        int ft = g_array_index(writable_type_subtypes, int, i);\n        sharkd_json_object_open(NULL);\n        sharkd_json_value_string(\"name\", wtap_file_type_subtype_name(ft));\n        sharkd_json_value_string(\"description\", wtap_file_type_subtype_description(ft));\n        sharkd_json_object_close();\n    }\n    g_array_free(writable_type_subtypes, TRUE);\n}\n\nstruct encap_type_info\n{\n    const char *name;\n    const char *description;\n};\n\nstatic int\nencap_type_info_nat_compare(const void *a, const void *b)\n{\n    return ws_ascii_strnatcmp(((const struct encap_type_info *)a)->name,\n                              ((const struct encap_type_info *)b)->name);\n}\n\nstatic void\nencap_type_info_visit(void *data, void *user_data _U_)\n{\n    sharkd_json_object_open(NULL);\n    sharkd_json_value_string(\"name\", ((struct encap_type_info *)data)->name);\n    sharkd_json_value_string(\"description\", ((struct encap_type_info *)data)->description);\n    sharkd_json_object_close();\n}\n\nstatic void\nsharkd_session_print_encap_types(void)\n{\n    int i;\n    struct encap_type_info *encaps;\n    GSList *list = NULL;\n    encaps = g_new(struct encap_type_info, WTAP_NUM_ENCAP_TYPES);\n    for (i = 0; i < WTAP_NUM_ENCAP_TYPES; i++) {\n        encaps[i].name = wtap_encap_name(i);\n        if (encaps[i].name != NULL) {\n            encaps[i].description = wtap_encap_description(i);\n            list = g_slist_insert_sorted(list, &encaps[i], encap_type_info_nat_compare);\n        }\n    }\n    g_slist_foreach(list, encap_type_info_visit, NULL);\n    g_slist_free(list);\n    g_free(encaps);\n}\n\n/**\n * sharkd_session_process_info()\n *\n * Process info request\n *\n * Output object with attributes:\n *   (m) version - version number\n *\n *   (m) columns - available column formats, array of object with attributes:\n *                  'name'   - column name\n *                  'format' - column format-name\n *\n *   (m) stats   - available statistics, array of object with attributes:\n *                  'name' - statistic name\n *                  'tap'  - sharkd tap-name for statistic\n *\n *   (m) convs   - available conversation list, array of object with attributes:\n *                  'name' - conversation name\n *                  'tap'  - sharkd tap-name for conversation\n *\n *   (m) eo      - available export object list, array of object with attributes:\n *                  'name' - export object name\n *                  'tap'  - sharkd tap-name for eo\n *\n *   (m) srt     - available service response time list, array of object with attributes:\n *                  'name' - service response time name\n *                  'tap'  - sharkd tap-name for srt\n *\n *   (m) rtd     - available response time delay list, array of object with attributes:\n *                  'name' - response time delay name\n *                  'tap'  - sharkd tap-name for rtd\n *\n *   (m) seqa    - available sequence analysis (flow) list, array of object with attributes:\n *                  'name' - sequence analysis name\n *                  'tap'  - sharkd tap-name\n *\n *   (m) taps    - available taps, array of object with attributes:\n *                  'name' - tap name\n *                  'tap'  - sharkd tap-name\n *\n *   (m) follow  - available followers, array of object with attributes:\n *                  'name' - tap name\n *                  'tap'  - sharkd tap-name\n *\n *   (m) ftypes  - conversation table for FT_ number to string, array of FT_xxx strings.\n *\n *   (m) nstat   - available table-based taps, array of object with attributes:\n *                  'name' - tap name\n *                  'tap'  - sharkd tap-name\n *\n *   (m) capture_types - available capture types, array of object with attributes:\n *                        'name'        - capture type name\n *                        'description' - capture type description\n *\n *   (m) encap_types   - available encapsulation types, array of object with attributes:\n *                        'name'        - encapsulation type name\n *                        'description' - encapsulation type description\n */\nstatic void\nsharkd_session_process_info(void)\n{\n    int i;\n\n    sharkd_json_result_prologue(rpcid);\n\n    sharkd_json_array_open(\"columns\");\n    for (i = 0; i < NUM_COL_FMTS; i++)\n    {\n        const char *col_format = col_format_to_string(i);\n        const char *col_descr  = col_format_desc(i);\n\n        json_dumper_begin_object(&dumper);\n        sharkd_json_value_string(\"name\", col_descr);\n        sharkd_json_value_string(\"format\", col_format);\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"stats\");\n    {\n        GList *cfg_list = stats_tree_get_cfg_list();\n        GList *l;\n\n        for (l = cfg_list; l; l = l->next)\n        {\n            stats_tree_cfg *cfg = (stats_tree_cfg *) l->data;\n\n            json_dumper_begin_object(&dumper);\n            sharkd_json_value_string(\"name\", cfg->title);\n            sharkd_json_value_stringf(\"tap\", \"stat:%s\", cfg->abbr);\n            json_dumper_end_object(&dumper);\n        }\n\n        g_list_free(cfg_list);\n    }\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"ftypes\");\n    for (i = 0; i < FT_NUM_TYPES; i++)\n        sharkd_json_value_string(NULL, ftype_name((ftenum_t) i));\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"capture_types\");\n    sharkd_session_print_capture_types();\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"encap_types\");\n    sharkd_session_print_encap_types();\n    sharkd_json_array_close();\n\n    sharkd_json_value_string(\"version\", get_ws_vcs_version_info_short());\n\n    sharkd_json_array_open(\"nstat\");\n    i = 0;\n    stat_tap_iterate_tables(sharkd_session_process_info_nstat_cb, &i);\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"convs\");\n    i = 0;\n    conversation_table_iterate_tables(sharkd_session_process_info_conv_cb, &i);\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"seqa\");\n    i = 0;\n    sequence_analysis_table_iterate_tables(sharkd_session_seq_analysis_cb, &i);\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"taps\");\n    {\n        json_dumper_begin_object(&dumper);\n        sharkd_json_value_string(\"name\", \"UDP Multicast Streams\");\n        sharkd_json_value_string(\"tap\", \"multicast\");\n        json_dumper_end_object(&dumper);\n\n        json_dumper_begin_object(&dumper);\n        sharkd_json_value_string(\"name\", \"RTP streams\");\n        sharkd_json_value_string(\"tap\", \"rtp-streams\");\n        json_dumper_end_object(&dumper);\n\n        json_dumper_begin_object(&dumper);\n        sharkd_json_value_string(\"name\", \"Protocol Hierarchy Statistics\");\n        sharkd_json_value_string(\"tap\", \"phs\");\n        json_dumper_end_object(&dumper);\n\n        json_dumper_begin_object(&dumper);\n        sharkd_json_value_string(\"name\", \"VoIP Calls\");\n        sharkd_json_value_string(\"tap\", \"voip-calls\");\n        json_dumper_end_object(&dumper);\n\n        json_dumper_begin_object(&dumper);\n        sharkd_json_value_string(\"name\", \"VoIP Conversations\");\n        sharkd_json_value_string(\"tap\", \"voip-convs\");\n        json_dumper_end_object(&dumper);\n\n        json_dumper_begin_object(&dumper);\n        sharkd_json_value_string(\"name\", \"Expert Information\");\n        sharkd_json_value_string(\"tap\", \"expert\");\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"eo\");\n    i = 0;\n    eo_iterate_tables(sharkd_export_object_visit_cb, &i);\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"srt\");\n    i = 0;\n    srt_table_iterate_tables(sharkd_srt_visit_cb, &i);\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"rtd\");\n    i = 0;\n    rtd_table_iterate_tables(sharkd_rtd_visit_cb, &i);\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"follow\");\n    i = 0;\n    follow_iterate_followers(sharkd_follower_visit_cb, &i);\n    sharkd_json_array_close();\n\n    sharkd_json_result_epilogue();\n}\n\n/**\n * sharkd_session_process_load()\n *\n * Process load request\n *\n * Input:\n *   (m) file - file to be loaded\n *\n * Output object with attributes:\n *   (m) err - error code\n */\nstatic void\nsharkd_session_process_load(const char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_file = json_find_attr(buf, tokens, count, \"file\");\n    int err = 0;\n\n    if (!tok_file)\n        return;\n\n    fprintf(stderr, \"load: filename=%s\\n\", tok_file);\n\n    if (sharkd_cf_open(tok_file, WTAP_TYPE_AUTO, false, &err) != CF_OK)\n    {\n        sharkd_json_error(\n                rpcid, -2001, NULL,\n                \"Unable to open the file\"\n                );\n        return;\n    }\n\n    TRY\n    {\n        err = sharkd_load_cap_file();\n    }\n    CATCH(OutOfMemoryError)\n    {\n        sharkd_json_error(\n                rpcid, -32603, NULL,\n                \"Load failed, out of memory\"\n                );\n        fprintf(stderr, \"load: OutOfMemoryError\\n\");\n        err = ENOMEM;\n    }\n    ENDTRY;\n\n    if (err == 0)\n    {\n        sharkd_json_simple_ok(rpcid);\n    }\n    else\n    {\n        sharkd_json_result_prologue(rpcid);\n        sharkd_json_value_string(\"status\", wtap_strerror(err));\n        sharkd_json_value_anyf(\"err\", \"%d\", err);\n        sharkd_json_result_epilogue();\n    }\n\n}\n\n/**\n * sharkd_session_process_status()\n *\n * Process status request\n *\n * Output object with attributes:\n *   (m) frames      - count of currently loaded frames\n *   (m) duration    - time difference between time of first frame, and last loaded frame\n *   (o) filename    - capture filename\n *   (o) filesize    - capture filesize\n *   (o) columns     - array of column titles\n *   (o) column_info - array of column infos, array of object with attributes:\n *                      'title'    - column title\n *                      'format'   - column format (%x or %Cus:<expr>:<occurrence> if COL_CUSTOM)\n *                      'visible'  - true if column is visible\n *                      'display'  - column display format; 'U', 'R' or 'D'\n */\nstatic void\nsharkd_session_process_status(void)\n{\n    sharkd_json_result_prologue(rpcid);\n\n    sharkd_json_value_anyf(\"frames\", \"%u\", cfile.count);\n    sharkd_json_value_anyf(\"duration\", \"%.9f\", nstime_to_sec(&cfile.elapsed_time));\n\n    if (cfile.filename)\n    {\n        char *name = g_path_get_basename(cfile.filename);\n\n        sharkd_json_value_string(\"filename\", name);\n        g_free(name);\n    }\n\n    if (cfile.provider.wth)\n    {\n        int64_t file_size = wtap_file_size(cfile.provider.wth, NULL);\n\n        if (file_size > 0)\n            sharkd_json_value_anyf(\"filesize\", \"%\" PRId64, file_size);\n    }\n\n    if (cfile.cinfo.num_cols > 0)\n    {\n        sharkd_json_array_open(\"columns\");\n        for (int i = 0; i < cfile.cinfo.num_cols; ++i)\n        {\n            sharkd_json_value_string(NULL, get_column_title(i));\n        }\n        sharkd_json_array_close();\n\n        sharkd_json_array_open(\"column_info\");\n        for (int i = 0; i < cfile.cinfo.num_cols; ++i)\n        {\n            int fmt = get_column_format(i);\n            sharkd_json_object_open(NULL);\n            sharkd_json_value_string(\"title\", get_column_title(i));\n            if (fmt != COL_CUSTOM)\n            {\n                sharkd_json_value_string(\"format\", col_format_to_string(fmt));\n            } else {\n                sharkd_json_value_stringf(\"format\", \"%s:%s:%d\", col_format_to_string(fmt), get_column_custom_fields(i), get_column_custom_occurrence(i));\n            }\n            sharkd_json_value_anyf(\"visible\", get_column_visible(i) ? \"true\" : \"false\");\n            sharkd_json_value_stringf(\"display\", \"%c\", get_column_display_format(i));\n            sharkd_json_object_close();\n        }\n        sharkd_json_array_close();\n    }\n\n    sharkd_json_result_epilogue();\n}\n\nstruct sharkd_analyse_data\n{\n    GHashTable *protocols_set;\n    nstime_t *first_time;\n    nstime_t *last_time;\n};\n\nstatic void\nsharkd_session_process_analyse_cb(epan_dissect_t *edt, proto_tree *tree _U_,\n        struct epan_column_info *cinfo _U_, const GSList *data_src _U_, void *data)\n{\n    struct sharkd_analyse_data *analyser = (struct sharkd_analyse_data *) data;\n    packet_info *pi = &edt->pi;\n    frame_data *fdata = pi->fd;\n\n    if (analyser->first_time == NULL || nstime_cmp(&fdata->abs_ts, analyser->first_time) < 0)\n        analyser->first_time = &fdata->abs_ts;\n\n    if (analyser->last_time == NULL || nstime_cmp(&fdata->abs_ts, analyser->last_time) > 0)\n        analyser->last_time = &fdata->abs_ts;\n\n    if (pi->layers)\n    {\n        wmem_list_frame_t *frame;\n\n        for (frame = wmem_list_head(pi->layers); frame; frame = wmem_list_frame_next(frame))\n        {\n            int proto_id = GPOINTER_TO_UINT(wmem_list_frame_data(frame));\n\n            if (!g_hash_table_lookup_extended(analyser->protocols_set, GUINT_TO_POINTER(proto_id), NULL, NULL))\n            {\n                g_hash_table_insert(analyser->protocols_set, GUINT_TO_POINTER(proto_id), GUINT_TO_POINTER(proto_id));\n                sharkd_json_value_string(NULL, proto_get_protocol_filter_name(proto_id));\n            }\n        }\n    }\n\n}\n\n/**\n * sharkd_session_process_status()\n *\n * Process analyse request\n *\n * Output object with attributes:\n *   (m) frames  - count of currently loaded frames\n *   (m) protocols - protocol list\n *   (m) first     - earliest frame time\n *   (m) last      - latest frame time\n */\nstatic void\nsharkd_session_process_analyse(void)\n{\n    struct sharkd_analyse_data analyser;\n    wtap_rec rec; /* Record information */\n\n    analyser.first_time = NULL;\n    analyser.last_time  = NULL;\n    analyser.protocols_set = g_hash_table_new(NULL /* g_direct_hash() */, NULL /* g_direct_equal */);\n\n    sharkd_json_result_prologue(rpcid);\n\n    sharkd_json_value_anyf(\"frames\", \"%u\", cfile.count);\n\n    sharkd_json_array_open(\"protocols\");\n\n    wtap_rec_init(&rec, 1514);\n\n    for (uint32_t framenum = 1; framenum <= cfile.count; framenum++)\n    {\n        enum dissect_request_status status;\n        int err;\n        char *err_info;\n\n        status = sharkd_dissect_request(framenum,\n                (framenum != 1) ? 1 : 0, framenum - 1,\n                &rec, NULL, SHARKD_DISSECT_FLAG_NULL,\n                &sharkd_session_process_analyse_cb, &analyser,\n                &err, &err_info);\n        switch (status) {\n\n            case DISSECT_REQUEST_SUCCESS:\n                break;\n\n            case DISSECT_REQUEST_NO_SUCH_FRAME:\n                /* XXX - report the error. */\n                break;\n\n            case DISSECT_REQUEST_READ_ERROR:\n                /*\n                 * Free up the error string.\n                 * XXX - report the error.\n                 */\n                g_free(err_info);\n                break;\n        }\n    }\n\n    sharkd_json_array_close();\n\n    if (analyser.first_time)\n        sharkd_json_value_anyf(\"first\", \"%.9f\", nstime_to_sec(analyser.first_time));\n\n    if (analyser.last_time)\n        sharkd_json_value_anyf(\"last\", \"%.9f\", nstime_to_sec(analyser.last_time));\n\n    sharkd_json_result_epilogue();\n\n    wtap_rec_cleanup(&rec);\n\n    g_hash_table_destroy(analyser.protocols_set);\n}\n\nstatic column_info *\nsharkd_session_create_columns(column_info *cinfo, const char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *columns_custom[32];\n    uint16_t columns_fmt[32];\n    int16_t columns_occur[32];\n\n    int i, cols;\n\n    for (i = 0; i < 32; i++)\n    {\n        const char *tok_column;\n        char tok_column_name[64];\n        char *custom_sepa;\n\n        snprintf(tok_column_name, sizeof(tok_column_name), \"column%d\", i);\n        tok_column = json_find_attr(buf, tokens, count, tok_column_name);\n        if (tok_column == NULL)\n            break;\n\n        columns_custom[i] = NULL;\n        columns_occur[i] = 0;\n\n        if ((custom_sepa = strchr(tok_column, ':')))\n        {\n            *custom_sepa = '\\0'; /* XXX, C abuse: discarding-const */\n\n            columns_fmt[i] = COL_CUSTOM;\n            columns_custom[i] = tok_column;\n\n            if (!ws_strtoi16(custom_sepa + 1, NULL, &columns_occur[i]))\n                return NULL;\n        }\n        else\n        {\n            if (!ws_strtou16(tok_column, NULL, &columns_fmt[i]))\n                return NULL;\n\n            if (columns_fmt[i] >= NUM_COL_FMTS)\n                return NULL;\n\n            /* if custom, that it shouldn't be just custom number -> error */\n            if (columns_fmt[i] == COL_CUSTOM)\n                return NULL;\n        }\n    }\n\n    cols = i;\n\n    col_setup(cinfo, cols);\n\n    for (i = 0; i < cols; i++)\n    {\n        col_item_t *col_item = &cinfo->columns[i];\n\n        col_item->col_fmt = columns_fmt[i];\n        col_item->col_title = NULL; /* no need for title */\n\n        if (col_item->col_fmt == COL_CUSTOM)\n        {\n            col_item->col_custom_fields = g_strdup(columns_custom[i]);\n            col_item->col_custom_occurrence = columns_occur[i];\n        }\n\n        col_item->col_fence = 0;\n    }\n\n    col_finalize(cinfo);\n\n    return cinfo;\n}\n\nstatic void\nsharkd_session_process_frames_cb(epan_dissect_t *edt, proto_tree *tree _U_,\n        struct epan_column_info *cinfo, const GSList *data_src _U_, void *data _U_)\n{\n    packet_info *pi = &edt->pi;\n    frame_data *fdata = pi->fd;\n    wtap_block_t pkt_block = NULL;\n    unsigned int i;\n    char *comment = NULL;\n\n    json_dumper_begin_object(&dumper);\n\n    sharkd_json_array_open(\"c\");\n    for (int col = 0; col < cinfo->num_cols; ++col)\n    {\n        sharkd_json_value_string(NULL, get_column_text(cinfo, col));\n    }\n    sharkd_json_array_close();\n\n    sharkd_json_value_anyf(\"num\", \"%u\", pi->num);\n\n    /*\n     * Get the block for this record, if it has one.\n     */\n    pkt_block = sharkd_get_packet_block(fdata);\n\n    /*\n     * Does this record have any comments?\n     */\n    if (pkt_block != NULL &&\n            WTAP_OPTTYPE_SUCCESS == wtap_block_get_nth_string_option_value(pkt_block, OPT_COMMENT, 0, &comment))\n    {\n        sharkd_json_value_anyf(\"ct\", \"true\");\n\n        sharkd_json_array_open(\"comments\");\n        for (i = 0; wtap_block_get_nth_string_option_value(pkt_block, OPT_COMMENT, i, &comment) == WTAP_OPTTYPE_SUCCESS; i++) {\n            sharkd_json_value_string(NULL, comment);\n        }\n        sharkd_json_array_close();\n    }\n\n    if (fdata->ignored)\n        sharkd_json_value_anyf(\"i\", \"true\");\n\n    if (fdata->marked)\n        sharkd_json_value_anyf(\"m\", \"true\");\n\n    if (fdata->color_filter)\n    {\n        sharkd_json_value_stringf(\"bg\", \"%06x\", color_t_to_rgb(&fdata->color_filter->bg_color));\n        sharkd_json_value_stringf(\"fg\", \"%06x\", color_t_to_rgb(&fdata->color_filter->fg_color));\n    }\n\n    wtap_block_unref(pkt_block);\n    json_dumper_end_object(&dumper);\n}\n\n/**\n * sharkd_session_process_frames()\n *\n * Process frames request\n *\n * Input:\n *   (o) column0...columnXX - requested columns either number in range [0..NUM_COL_FMTS), or custom (syntax <dfilter>:<occurrence>).\n *                            If column0 is not specified default column set will be used.\n *   (o) filter - filter to be used\n *   (o) skip=N   - skip N frames\n *   (o) limit=N  - show only N frames\n *   (o) refs  - list (comma separated) with sorted time reference frame numbers.\n *\n * Output array of frames with attributes:\n *   (m) c   - array of column data\n *   (m) num - frame number\n *   (o) i   - if frame is ignored\n *   (o) m   - if frame is marked\n *   (o) ct  - if frame is commented\n *   (o) comments - array of comment strings\n *   (o) bg  - color filter - background color in hex\n *   (o) fg  - color filter - foreground color in hex\n */\nstatic void\nsharkd_session_process_frames(const char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_filter = json_find_attr(buf, tokens, count, \"filter\");\n    const char *tok_column = json_find_attr(buf, tokens, count, \"column0\");\n    const char *tok_skip   = json_find_attr(buf, tokens, count, \"skip\");\n    const char *tok_limit  = json_find_attr(buf, tokens, count, \"limit\");\n    const char *tok_refs   = json_find_attr(buf, tokens, count, \"refs\");\n\n    const uint8_t *filter_data = NULL;\n\n    uint32_t prev_dis_num = 0;\n    uint32_t current_ref_frame = 0, next_ref_frame = UINT32_MAX;\n    uint32_t skip;\n    uint32_t limit;\n\n    wtap_rec rec; /* Record information */\n    column_info *cinfo = &cfile.cinfo;\n    column_info user_cinfo;\n\n    if (tok_column)\n    {\n        memset(&user_cinfo, 0, sizeof(user_cinfo));\n        cinfo = sharkd_session_create_columns(&user_cinfo, buf, tokens, count);\n        if (!cinfo)\n        {\n            sharkd_json_error(\n                    rpcid, -13001, NULL,\n                    \"Column definition invalid - note column 6 requires a custom definition\"\n                    );\n            return;\n        }\n    }\n\n    if (tok_filter)\n    {\n        const struct sharkd_filter_item *filter_item;\n\n        filter_item = sharkd_session_filter_data(tok_filter);\n        if (!filter_item)\n        {\n            sharkd_json_error(\n                    rpcid, -13002, NULL,\n                    \"Filter expression invalid\"\n                    );\n            return;\n        }\n\n        filter_data = filter_item->filtered;\n    }\n\n    skip = 0;\n    if (tok_skip)\n    {\n        if (!ws_strtou32(tok_skip, NULL, &skip))\n            return;\n    }\n\n    limit = 0;\n    if (tok_limit)\n    {\n        if (!ws_strtou32(tok_limit, NULL, &limit))\n            return;\n    }\n\n    if (tok_refs)\n    {\n        if (!ws_strtou32(tok_refs, &tok_refs, &next_ref_frame))\n            return;\n    }\n\n    sharkd_json_result_array_prologue(rpcid);\n\n    wtap_rec_init(&rec, 1514);\n\n    for (uint32_t framenum = 1; framenum <= cfile.count; framenum++)\n    {\n        frame_data *fdata;\n        uint32_t ref_frame = (framenum != 1) ? 1 : 0;\n        enum dissect_request_status status;\n        int err;\n        char *err_info;\n\n        if (filter_data && !(filter_data[framenum / 8] & (1 << (framenum % 8))))\n            continue;\n\n        if (skip)\n        {\n            skip--;\n            prev_dis_num = framenum;\n            continue;\n        }\n\n        if (tok_refs)\n        {\n            if (framenum >= next_ref_frame)\n            {\n                current_ref_frame = next_ref_frame;\n\n                if (*tok_refs != ',')\n                    next_ref_frame = UINT32_MAX;\n\n                while (*tok_refs == ',' && framenum >= next_ref_frame)\n                {\n                    current_ref_frame = next_ref_frame;\n\n                    if (!ws_strtou32(tok_refs + 1, &tok_refs, &next_ref_frame))\n                    {\n                        fprintf(stderr, \"sharkd_session_process_frames() wrong format for refs: %s\\n\", tok_refs);\n                        break;\n                    }\n                }\n\n                if (*tok_refs == '\\0' && framenum >= next_ref_frame)\n                {\n                    current_ref_frame = next_ref_frame;\n                    next_ref_frame = UINT32_MAX;\n                }\n            }\n\n            if (current_ref_frame)\n                ref_frame = current_ref_frame;\n        }\n\n        fdata = sharkd_get_frame(framenum);\n        status = sharkd_dissect_request(framenum,\n                ref_frame, prev_dis_num,\n                &rec, cinfo,\n                (fdata->color_filter == NULL) ? SHARKD_DISSECT_FLAG_COLOR : SHARKD_DISSECT_FLAG_NULL,\n                &sharkd_session_process_frames_cb, NULL,\n                &err, &err_info);\n        switch (status) {\n\n            case DISSECT_REQUEST_SUCCESS:\n                break;\n\n            case DISSECT_REQUEST_NO_SUCH_FRAME:\n                /* XXX - report the error. */\n                break;\n\n            case DISSECT_REQUEST_READ_ERROR:\n                /*\n                 * Free up the error string.\n                 * XXX - report the error.\n                 */\n                g_free(err_info);\n                break;\n        }\n\n        prev_dis_num = framenum;\n\n        if (limit && --limit == 0)\n            break;\n    }\n    sharkd_json_result_array_epilogue();\n\n    if (cinfo != &cfile.cinfo)\n        col_cleanup(cinfo);\n\n    wtap_rec_cleanup(&rec);\n}\n\nstatic void\nsharkd_session_process_tap_stats_node_cb(const char *key, const stat_node *n)\n{\n    stat_node *node;\n\n    sharkd_json_array_open(key);\n    for (node = n->children; node; node = node->next)\n    {\n        json_dumper_begin_object(&dumper);\n\n        /* code based on stats_tree_get_values_from_node() */\n        sharkd_json_value_string(\"name\", node->name);\n        sharkd_json_value_anyf(\"count\", \"%d\", node->counter);\n        if (node->counter && ((node->st_flags & ST_FLG_AVERAGE) || node->rng))\n        {\n            switch(node->datatype)\n            {\n                case STAT_DT_INT:\n                    sharkd_json_value_anyf(\"avg\", \"%.2f\", ((float)node->total.int_total) / node->counter);\n                    sharkd_json_value_anyf(\"min\", \"%d\", node->minvalue.int_min);\n                    sharkd_json_value_anyf(\"max\", \"%d\", node->maxvalue.int_max);\n                    break;\n                case STAT_DT_FLOAT:\n                    sharkd_json_value_anyf(\"avg\", \"%.2f\", node->total.float_total / node->counter);\n                    sharkd_json_value_anyf(\"min\", \"%f\", node->minvalue.float_min);\n                    sharkd_json_value_anyf(\"max\", \"%f\", node->maxvalue.float_max);\n                    break;\n            }\n        }\n\n        if (node->st->elapsed)\n            sharkd_json_value_anyf(\"rate\", \"%.4f\", ((float)node->counter) / node->st->elapsed);\n\n        if (node->parent && node->parent->counter)\n            sharkd_json_value_anyf(\"perc\", \"%.2f\", (node->counter * 100.0) / node->parent->counter);\n        else if (node->parent == &(node->st->root))\n            sharkd_json_value_anyf(\"perc\", \"100\");\n\n        if (prefs.st_enable_burstinfo && node->max_burst)\n        {\n            if (prefs.st_burst_showcount)\n                sharkd_json_value_anyf(\"burstcount\", \"%d\", node->max_burst);\n            else\n                sharkd_json_value_anyf(\"burstrate\", \"%.4f\", ((double)node->max_burst) / prefs.st_burst_windowlen);\n\n            sharkd_json_value_anyf(\"bursttime\", \"%.3f\", (node->burst_time / 1000.0));\n        }\n\n        if (node->children)\n        {\n            sharkd_session_process_tap_stats_node_cb(\"sub\", node);\n        }\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n}\n\n/**\n * sharkd_session_process_tap_stats_cb()\n *\n * Output stats tap:\n *\n *   (m) tap        - tap name\n *   (m) type:stats - tap output type\n *   (m) name       - stat name\n *   (m) stats      - array of object with attributes:\n *                  (m) name       - stat item name\n *                  (m) count      - stat item counter\n *                  (o) avg        - stat item averange value\n *                  (o) min        - stat item min value\n *                  (o) max        - stat item max value\n *                  (o) rate       - stat item rate value (ms)\n *                  (o) perc       - stat item percentage\n *                  (o) burstrate  - stat item burst rate\n *                  (o) burstcount - stat item burst count\n *                  (o) burstttme  - stat item burst start\n *                  (o) sub        - array of object with attributes like in stats node.\n */\nstatic void\nsharkd_session_process_tap_stats_cb(void *psp)\n{\n    stats_tree *st = (stats_tree *) psp;\n\n    json_dumper_begin_object(&dumper);\n\n    sharkd_json_value_stringf(\"tap\", \"stats:%s\", st->cfg->abbr);\n    sharkd_json_value_string(\"type\", \"stats\");\n    sharkd_json_value_string(\"name\", st->cfg->path);\n\n    sharkd_session_process_tap_stats_node_cb(\"stats\", &st->root);\n\n    json_dumper_end_object(&dumper);\n}\n\nstatic void\nsharkd_session_free_tap_stats_cb(void *psp)\n{\n    stats_tree *st = (stats_tree *) psp;\n\n    stats_tree_free(st);\n}\n\nstruct sharkd_expert_tap\n{\n    GSList *details;\n    GStringChunk *text;\n};\n\n/**\n * sharkd_session_process_tap_expert_cb()\n *\n * Output expert tap:\n *\n *   (m) tap         - tap name\n *   (m) type:expert - tap output type\n *   (m) details     - array of object with attributes:\n *                  (m) f - frame number, which generated expert information\n *                  (o) s - severity\n *                  (o) g - group\n *                  (m) m - expert message\n *                  (o) p - protocol\n */\nstatic void\nsharkd_session_process_tap_expert_cb(void *tapdata)\n{\n    struct sharkd_expert_tap *etd = (struct sharkd_expert_tap *) tapdata;\n    GSList *list;\n\n    json_dumper_begin_object(&dumper);\n\n    sharkd_json_value_string(\"tap\", \"expert\");\n    sharkd_json_value_string(\"type\", \"expert\");\n\n    sharkd_json_array_open(\"details\");\n    for (list = etd->details; list; list = list->next)\n    {\n        expert_info_t *ei = (expert_info_t *) list->data;\n        const char *tmp;\n\n        json_dumper_begin_object(&dumper);\n\n        sharkd_json_value_anyf(\"f\", \"%u\", ei->packet_num);\n\n        tmp = try_val_to_str(ei->severity, expert_severity_vals);\n        if (tmp)\n            sharkd_json_value_string(\"s\", tmp);\n\n        tmp = try_val_to_str(ei->group, expert_group_vals);\n        if (tmp)\n            sharkd_json_value_string(\"g\", tmp);\n\n        sharkd_json_value_string(\"m\", ei->summary);\n\n        if (ei->protocol)\n            sharkd_json_value_string(\"p\", ei->protocol);\n\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n\n    json_dumper_end_object(&dumper);\n}\n\nstatic tap_packet_status\nsharkd_session_packet_tap_expert_cb(void *tapdata, packet_info *pinfo _U_, epan_dissect_t *edt _U_, const void *pointer, tap_flags_t flags _U_)\n{\n    struct sharkd_expert_tap *etd = (struct sharkd_expert_tap *) tapdata;\n    const expert_info_t *ei       = (const expert_info_t *) pointer;\n    expert_info_t *ei_copy;\n\n    if (ei == NULL)\n        return TAP_PACKET_DONT_REDRAW;\n\n    ei_copy = g_new(expert_info_t, 1);\n    /* Note: this is a shallow copy */\n    *ei_copy = *ei;\n\n    /* ei->protocol, ei->summary might be allocated in packet scope, make a copy. */\n    ei_copy->protocol = g_string_chunk_insert_const(etd->text, ei_copy->protocol);\n    ei_copy->summary  = g_string_chunk_insert_const(etd->text, ei_copy->summary);\n\n    etd->details = g_slist_prepend(etd->details, ei_copy);\n\n    return TAP_PACKET_REDRAW;\n}\n\nstatic void\nsharkd_session_free_tap_expert_cb(void *tapdata)\n{\n    struct sharkd_expert_tap *etd = (struct sharkd_expert_tap *) tapdata;\n\n    g_slist_free_full(etd->details, g_free);\n    g_string_chunk_free(etd->text);\n    g_free(etd);\n}\n\n/**\n * sharkd_session_process_tap_flow_cb()\n *\n * Output flow tap:\n *   (m) tap         - tap name\n *   (m) type:flow   - tap output type\n *   (m) nodes       - array of strings with node address\n *   (m) flows       - array of object with attributes:\n *                  (m) t  - frame time string\n *                  (m) n  - array of two numbers with source node index and destination node index\n *                  (m) pn - array of two numbers with source and destination port\n *                  (o) c  - comment\n */\nstatic void\nsharkd_session_process_tap_flow_cb(void *tapdata)\n{\n    seq_analysis_info_t *graph_analysis = (seq_analysis_info_t *) tapdata;\n    GList *flow_list;\n    unsigned i;\n\n    sequence_analysis_get_nodes(graph_analysis);\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_stringf(\"tap\", \"seqa:%s\", graph_analysis->name);\n    sharkd_json_value_string(\"type\", \"flow\");\n\n    sharkd_json_array_open(\"nodes\");\n    for (i = 0; i < graph_analysis->num_nodes; i++)\n    {\n        char *addr_str;\n\n        addr_str = address_to_display(NULL, &(graph_analysis->nodes[i]));\n        sharkd_json_value_string(NULL, addr_str);\n        wmem_free(NULL, addr_str);\n    }\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"flows\");\n    flow_list = g_queue_peek_nth_link(graph_analysis->items, 0);\n    while (flow_list)\n    {\n        seq_analysis_item_t *sai = (seq_analysis_item_t *) flow_list->data;\n\n        flow_list = g_list_next(flow_list);\n\n        if (!sai->display)\n            continue;\n\n        json_dumper_begin_object(&dumper);\n\n        sharkd_json_value_string(\"t\", sai->time_str);\n        sharkd_json_value_anyf(\"n\", \"[%u,%u]\", sai->src_node, sai->dst_node);\n        sharkd_json_value_anyf(\"pn\", \"[%u,%u]\", sai->port_src, sai->port_dst);\n\n        if (sai->comment)\n            sharkd_json_value_string(\"c\", sai->comment);\n\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n\n    json_dumper_end_object(&dumper);\n}\n\nstatic void\nsharkd_session_free_tap_flow_cb(void *tapdata)\n{\n    seq_analysis_info_t *graph_analysis = (seq_analysis_info_t *) tapdata;\n\n    sequence_analysis_info_free(graph_analysis);\n}\n\nstruct sharkd_conv_tap_data\n{\n    const char *type;\n    conv_hash_t hash;\n    bool resolve_name;\n    bool resolve_port;\n};\n\nstatic bool\nsharkd_session_geoip_addr(address *addr, const char *suffix)\n{\n    const mmdb_lookup_t *lookup = NULL;\n    bool with_geoip = false;\n    char json_key[64];\n\n    if (addr->type == AT_IPv4)\n    {\n        const ws_in4_addr *ip4 = (const ws_in4_addr *) addr->data;\n\n        lookup = maxmind_db_lookup_ipv4(ip4);\n    }\n    else if (addr->type == AT_IPv6)\n    {\n        const ws_in6_addr *ip6 = (const ws_in6_addr *) addr->data;\n\n        lookup = maxmind_db_lookup_ipv6(ip6);\n    }\n\n    if (!lookup || !lookup->found)\n        return false;\n\n    if (lookup->country)\n    {\n        snprintf(json_key, sizeof(json_key), \"geoip_country%s\", suffix);\n        sharkd_json_value_string(json_key, lookup->country);\n        with_geoip = true;\n    }\n\n    if (lookup->country_iso)\n    {\n        snprintf(json_key, sizeof(json_key), \"geoip_country_iso%s\", suffix);\n        sharkd_json_value_string(json_key, lookup->country_iso);\n        with_geoip = true;\n    }\n\n    if (lookup->city)\n    {\n        snprintf(json_key, sizeof(json_key), \"geoip_city%s\", suffix);\n        sharkd_json_value_string(json_key, lookup->city);\n        with_geoip = true;\n    }\n\n    if (lookup->as_org)\n    {\n        snprintf(json_key, sizeof(json_key), \"geoip_as_org%s\", suffix);\n        sharkd_json_value_string(json_key, lookup->as_org);\n        with_geoip = true;\n    }\n\n    if (lookup->as_number > 0)\n    {\n        snprintf(json_key, sizeof(json_key), \"geoip_as%s\", suffix);\n        sharkd_json_value_anyf(json_key, \"%u\", lookup->as_number);\n        with_geoip = true;\n    }\n\n    if (lookup->latitude >= -90.0 && lookup->latitude <= 90.0)\n    {\n        snprintf(json_key, sizeof(json_key), \"geoip_lat%s\", suffix);\n        sharkd_json_value_anyf(json_key, \"%f\", lookup->latitude);\n        with_geoip = true;\n    }\n\n    if (lookup->longitude >= -180.0 && lookup->longitude <= 180.0)\n    {\n        snprintf(json_key, sizeof(json_key), \"geoip_lon%s\", suffix);\n        sharkd_json_value_anyf(json_key, \"%f\", lookup->longitude);\n        with_geoip = true;\n    }\n\n    return with_geoip;\n}\n\nstruct sharkd_analyse_rtp_items\n{\n    uint32_t frame_num;\n    uint32_t sequence_num;\n\n    double delta;\n    double jitter;\n    double skew;\n    double bandwidth;\n    bool marker;\n\n    double arrive_offset;\n\n    /* from tap_rtp_stat_t */\n    uint32_t flags;\n    uint16_t pt;\n};\n\nstruct sharkd_analyse_rtp\n{\n    const char *tap_name;\n    rtpstream_id_t id;\n\n    GSList *packets;\n    double start_time;\n    tap_rtp_stat_t statinfo;\n};\n\nstatic void\nsharkd_session_process_tap_rtp_free_cb(void *tapdata)\n{\n    struct sharkd_analyse_rtp *rtp_req = (struct sharkd_analyse_rtp *) tapdata;\n\n    g_slist_free_full(rtp_req->packets, g_free);\n    g_free(rtp_req);\n}\n\nstatic tap_packet_status\nsharkd_session_packet_tap_rtp_analyse_cb(void *tapdata, packet_info *pinfo, epan_dissect_t *edt _U_, const void *pointer, tap_flags_t flags _U_)\n{\n    struct sharkd_analyse_rtp *rtp_req = (struct sharkd_analyse_rtp *) tapdata;\n    const struct _rtp_info *rtp_info = (const struct _rtp_info *) pointer;\n\n    if (rtpstream_id_equal_pinfo_rtp_info(&rtp_req->id, pinfo, rtp_info))\n    {\n        tap_rtp_stat_t *statinfo = &(rtp_req->statinfo);\n        struct sharkd_analyse_rtp_items *item;\n\n        rtppacket_analyse(statinfo, pinfo, rtp_info);\n\n        item = g_new(struct sharkd_analyse_rtp_items, 1);\n\n        if (!rtp_req->packets)\n            rtp_req->start_time = nstime_to_sec(&pinfo->abs_ts);\n\n        item->frame_num    = pinfo->num;\n        item->sequence_num = rtp_info->info_seq_num;\n        item->delta        = (statinfo->flags & STAT_FLAG_FIRST) ? 0.0 : statinfo->delta;\n        item->jitter       = (statinfo->flags & STAT_FLAG_FIRST) ? 0.0 : statinfo->jitter;\n        item->skew         = (statinfo->flags & STAT_FLAG_FIRST) ? 0.0 : statinfo->skew;\n        item->bandwidth    = statinfo->bandwidth;\n        item->marker       = rtp_info->info_marker_set ? true : false;\n        item->arrive_offset= nstime_to_sec(&pinfo->abs_ts) - rtp_req->start_time;\n\n        item->flags = statinfo->flags;\n        item->pt    = statinfo->pt;\n\n        /* XXX, O(n) optimize */\n        rtp_req->packets = g_slist_append(rtp_req->packets, item);\n    }\n\n    return TAP_PACKET_REDRAW;\n}\n\n/**\n * sharkd_session_process_tap_rtp_analyse_cb()\n *\n * Output rtp analyse tap:\n *   (m) tap   - tap name\n *   (m) type  - tap output type\n *   (m) ssrc         - RTP SSRC\n *   (m) max_delta    - Max delta (ms)\n *   (m) max_delta_nr - Max delta packet #\n *   (m) max_jitter   - Max jitter (ms)\n *   (m) mean_jitter  - Mean jitter (ms)\n *   (m) max_skew     - Max skew (ms)\n *   (m) total_nr     - Total number of RTP packets\n *   (m) seq_err      - Number of sequence errors\n *   (m) duration     - Duration (ms)\n *   (m) items      - array of object with attributes:\n *                  (m) f    - frame number\n *                  (m) o    - arrive offset\n *                  (m) sn   - sequence number\n *                  (m) d    - delta\n *                  (m) j    - jitter\n *                  (m) sk   - skew\n *                  (m) bw   - bandwidth\n *                  (o) s    - status string\n *                  (o) t    - status type\n *                  (o) mark - rtp mark\n */\nstatic void\nsharkd_session_process_tap_rtp_analyse_cb(void *tapdata)\n{\n    const int RTP_TYPE_CN       = 1;\n    const int RTP_TYPE_ERROR    = 2;\n    const int RTP_TYPE_WARN     = 3;\n    const int RTP_TYPE_PT_EVENT = 4;\n\n    const struct sharkd_analyse_rtp *rtp_req = (struct sharkd_analyse_rtp *) tapdata;\n    const tap_rtp_stat_t *statinfo = &rtp_req->statinfo;\n\n    GSList *l;\n\n    json_dumper_begin_object(&dumper);\n\n    sharkd_json_value_string(\"tap\", rtp_req->tap_name);\n    sharkd_json_value_string(\"type\", \"rtp-analyse\");\n    sharkd_json_value_stringf(\"ssrc\", \"0x%x\", rtp_req->id.ssrc);\n\n    sharkd_json_value_anyf(\"max_delta\", \"%f\", statinfo->max_delta);\n    sharkd_json_value_anyf(\"max_delta_nr\", \"%u\", statinfo->max_nr);\n    sharkd_json_value_anyf(\"max_jitter\", \"%f\", statinfo->max_jitter);\n    sharkd_json_value_anyf(\"mean_jitter\", \"%f\", statinfo->mean_jitter);\n    sharkd_json_value_anyf(\"max_skew\", \"%f\", statinfo->max_skew);\n    sharkd_json_value_anyf(\"total_nr\", \"%u\", statinfo->total_nr);\n    sharkd_json_value_anyf(\"seq_err\", \"%u\", statinfo->sequence);\n    sharkd_json_value_anyf(\"duration\", \"%f\", statinfo->time - statinfo->start_time);\n\n    sharkd_json_array_open(\"items\");\n    for (l = rtp_req->packets; l; l = l->next)\n    {\n        struct sharkd_analyse_rtp_items *item = (struct sharkd_analyse_rtp_items *) l->data;\n\n        json_dumper_begin_object(&dumper);\n\n        sharkd_json_value_anyf(\"f\", \"%u\", item->frame_num);\n        sharkd_json_value_anyf(\"o\", \"%.9f\", item->arrive_offset);\n        sharkd_json_value_anyf(\"sn\", \"%u\", item->sequence_num);\n        sharkd_json_value_anyf(\"d\", \"%.2f\", item->delta);\n        sharkd_json_value_anyf(\"j\", \"%.2f\", item->jitter);\n        sharkd_json_value_anyf(\"sk\", \"%.2f\", item->skew);\n        sharkd_json_value_anyf(\"bw\", \"%.2f\", item->bandwidth);\n\n        if (item->pt == PT_CN)\n        {\n            sharkd_json_value_string(\"s\", \"Comfort noise (PT=13, RFC 3389)\");\n            sharkd_json_value_anyf(\"t\", \"%d\", RTP_TYPE_CN);\n        }\n        else if (item->pt == PT_CN_OLD)\n        {\n            sharkd_json_value_string(\"s\", \"Comfort noise (PT=19, reserved)\");\n            sharkd_json_value_anyf(\"t\", \"%d\", RTP_TYPE_CN);\n        }\n        else if (item->flags & STAT_FLAG_WRONG_SEQ)\n        {\n            sharkd_json_value_string(\"s\", \"Wrong sequence number\");\n            sharkd_json_value_anyf(\"t\", \"%d\", RTP_TYPE_ERROR);\n        }\n        else if (item->flags & STAT_FLAG_DUP_PKT)\n        {\n            sharkd_json_value_string(\"s\", \"Suspected duplicate (MAC address) only delta time calculated\");\n            sharkd_json_value_anyf(\"t\", \"%d\", RTP_TYPE_WARN);\n        }\n        else if (item->flags & STAT_FLAG_REG_PT_CHANGE)\n        {\n            sharkd_json_value_stringf(\"s\", \"Payload changed to PT=%u%s\",\n                    item->pt,\n                    (item->flags & STAT_FLAG_PT_T_EVENT) ? \" telephone/event\" : \"\");\n            sharkd_json_value_anyf(\"t\", \"%d\", RTP_TYPE_WARN);\n        }\n        else if (item->flags & STAT_FLAG_WRONG_TIMESTAMP)\n        {\n            sharkd_json_value_string(\"s\", \"Incorrect timestamp\");\n            sharkd_json_value_anyf(\"t\", \"%d\", RTP_TYPE_WARN);\n        }\n        else if ((item->flags & STAT_FLAG_PT_CHANGE)\n                &&  !(item->flags & STAT_FLAG_FIRST)\n                &&  !(item->flags & STAT_FLAG_PT_CN)\n                &&  (item->flags & STAT_FLAG_FOLLOW_PT_CN)\n                &&  !(item->flags & STAT_FLAG_MARKER))\n        {\n            sharkd_json_value_string(\"s\", \"Marker missing?\");\n            sharkd_json_value_anyf(\"t\", \"%d\", RTP_TYPE_WARN);\n        }\n        else if (item->flags & STAT_FLAG_PT_T_EVENT)\n        {\n            sharkd_json_value_stringf(\"s\", \"PT=%u telephone/event\", item->pt);\n            sharkd_json_value_anyf(\"t\", \"%d\", RTP_TYPE_PT_EVENT);\n        }\n        else if (item->flags & STAT_FLAG_MARKER)\n        {\n            sharkd_json_value_anyf(\"t\", \"%d\", RTP_TYPE_WARN);\n        }\n\n        if (item->marker)\n            sharkd_json_value_anyf(\"mark\", \"1\");\n\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n\n    json_dumper_end_object(&dumper);\n}\n\n/**\n * sharkd_session_process_tap_conv_cb()\n *\n * Output conv tap:\n *   (m) tap        - tap name\n *   (m) type       - tap output type\n *   (m) proto      - protocol short name\n *   (o) filter     - filter string\n *   (o) geoip      - whether GeoIP information is available, boolean\n *\n *   (o) convs      - array of object with attributes:\n *                  (m) saddr - source address\n *                  (m) daddr - destination address\n *                  (o) sport - source port\n *                  (o) dport - destination port\n *                  (m) txf   - TX frame count\n *                  (m) txb   - TX bytes\n *                  (m) rxf   - RX frame count\n *                  (m) rxb   - RX bytes\n *                  (m) start - (relative) first packet time\n *                  (m) stop  - (relative) last packet time\n *                  (o) filter - conversation filter\n *\n *   (o) hosts      - array of object with attributes:\n *                  (m) host - host address\n *                  (o) port - host port\n *                  (m) txf  - TX frame count\n *                  (m) txb  - TX bytes\n *                  (m) rxf  - RX frame count\n *                  (m) rxb  - RX bytes\n */\nstatic void\nsharkd_session_process_tap_conv_cb(void *arg)\n{\n    conv_hash_t *hash = (conv_hash_t *) arg;\n    const struct sharkd_conv_tap_data *iu = (struct sharkd_conv_tap_data *) hash->user_data;\n    const char *proto;\n    int proto_with_port;\n    unsigned i;\n\n    int with_geoip = 0;\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_string(\"tap\", iu->type);\n\n    if (!strncmp(iu->type, \"conv:\", 5))\n    {\n        sharkd_json_value_string(\"type\", \"conv\");\n        sharkd_json_array_open(\"convs\");\n        proto = iu->type + 5;\n    }\n    else if (!strncmp(iu->type, \"endpt:\", 6))\n    {\n        sharkd_json_value_string(\"type\", \"host\");\n        sharkd_json_array_open(\"hosts\");\n        proto = iu->type + 6;\n    }\n    else\n    {\n        sharkd_json_value_string(\"type\", \"err\");\n        proto = \"\";\n    }\n\n    proto_with_port = (!strcmp(proto, \"TCP\") || !strcmp(proto, \"UDP\") || !strcmp(proto, \"SCTP\"));\n\n    if (iu->hash.conv_array != NULL && !strncmp(iu->type, \"conv:\", 5))\n    {\n        for (i = 0; i < iu->hash.conv_array->len; i++)\n        {\n            conv_item_t *iui = &g_array_index(iu->hash.conv_array, conv_item_t, i);\n            char *src_addr, *dst_addr;\n            char *src_port, *dst_port;\n            char *filter_str;\n\n            json_dumper_begin_object(&dumper);\n\n            sharkd_json_value_string(\"saddr\", (src_addr = get_conversation_address(NULL, &iui->src_address, iu->resolve_name)));\n            sharkd_json_value_string(\"daddr\", (dst_addr = get_conversation_address(NULL, &iui->dst_address, iu->resolve_name)));\n\n            if (proto_with_port)\n            {\n                sharkd_json_value_string(\"sport\", (src_port = get_conversation_port(NULL, iui->src_port, iui->ctype, iu->resolve_port)));\n                sharkd_json_value_string(\"dport\", (dst_port = get_conversation_port(NULL, iui->dst_port, iui->ctype, iu->resolve_port)));\n\n                wmem_free(NULL, src_port);\n                wmem_free(NULL, dst_port);\n            }\n\n            sharkd_json_value_anyf(\"rxf\", \"%\" PRIu64, iui->rx_frames);\n            sharkd_json_value_anyf(\"rxb\", \"%\" PRIu64, iui->rx_bytes);\n\n            sharkd_json_value_anyf(\"txf\", \"%\" PRIu64, iui->tx_frames);\n            sharkd_json_value_anyf(\"txb\", \"%\" PRIu64, iui->tx_bytes);\n\n            sharkd_json_value_anyf(\"start\", \"%.9f\", nstime_to_sec(&iui->start_time));\n            sharkd_json_value_anyf(\"stop\", \"%.9f\", nstime_to_sec(&iui->stop_time));\n\n            filter_str = get_conversation_filter(iui, CONV_DIR_A_TO_FROM_B);\n            if (filter_str)\n            {\n                sharkd_json_value_string(\"filter\", filter_str);\n                g_free(filter_str);\n            }\n\n            wmem_free(NULL, src_addr);\n            wmem_free(NULL, dst_addr);\n\n            if (sharkd_session_geoip_addr(&(iui->src_address), \"1\"))\n                with_geoip = 1;\n            if (sharkd_session_geoip_addr(&(iui->dst_address), \"2\"))\n                with_geoip = 1;\n\n            json_dumper_end_object(&dumper);\n        }\n    }\n    else if (iu->hash.conv_array != NULL && !strncmp(iu->type, \"endpt:\", 6))\n    {\n        for (i = 0; i < iu->hash.conv_array->len; i++)\n        {\n            endpoint_item_t *endpoint = &g_array_index(iu->hash.conv_array, endpoint_item_t, i);\n            char *host_str, *port_str;\n            char *filter_str;\n\n            json_dumper_begin_object(&dumper);\n\n            sharkd_json_value_string(\"host\", (host_str = get_conversation_address(NULL, &endpoint->myaddress, iu->resolve_name)));\n\n            if (proto_with_port)\n            {\n                sharkd_json_value_string(\"port\", (port_str = get_endpoint_port(NULL, endpoint, iu->resolve_port)));\n\n                wmem_free(NULL, port_str);\n            }\n\n            sharkd_json_value_anyf(\"rxf\", \"%\" PRIu64, endpoint->rx_frames);\n            sharkd_json_value_anyf(\"rxb\", \"%\" PRIu64, endpoint->rx_bytes);\n\n            sharkd_json_value_anyf(\"txf\", \"%\" PRIu64, endpoint->tx_frames);\n            sharkd_json_value_anyf(\"txb\", \"%\" PRIu64, endpoint->tx_bytes);\n\n            filter_str = get_endpoint_filter(endpoint);\n            if (filter_str)\n            {\n                sharkd_json_value_string(\"filter\", filter_str);\n                g_free(filter_str);\n            }\n\n            wmem_free(NULL, host_str);\n\n            if (sharkd_session_geoip_addr(&(endpoint->myaddress), \"\"))\n                with_geoip = 1;\n            json_dumper_end_object(&dumper);\n        }\n    }\n    sharkd_json_array_close();\n\n    sharkd_json_value_string(\"proto\", proto);\n    sharkd_json_value_anyf(\"geoip\", with_geoip ? \"true\" : \"false\");\n\n    json_dumper_end_object(&dumper);\n}\n\nstatic void\nsharkd_session_free_tap_conv_cb(void *arg)\n{\n    conv_hash_t *hash = (conv_hash_t *) arg;\n    struct sharkd_conv_tap_data *iu = (struct sharkd_conv_tap_data *) hash->user_data;\n\n    if (!strncmp(iu->type, \"conv:\", 5))\n    {\n        reset_conversation_table_data(hash);\n    }\n    else if (!strncmp(iu->type, \"endpt:\", 6))\n    {\n        reset_endpoint_table_data(hash);\n    }\n\n    g_free(iu);\n}\n\n/**\n * sharkd_session_process_tap_nstat_cb()\n *\n * Output nstat tap:\n *   (m) tap        - tap name\n *   (m) type       - tap output type\n *   (m) fields: array of objects with attributes:\n *                  (m) c - name\n *\n *   (m) tables: array of object with attributes:\n *                  (m) t - table title\n *                  (m) i - array of items\n */\nstatic void\nsharkd_session_process_tap_nstat_cb(void *arg)\n{\n    stat_data_t *stat_data = (stat_data_t *) arg;\n    unsigned i, j, k;\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_stringf(\"tap\", \"nstat:%s\", stat_data->stat_tap_data->cli_string);\n    sharkd_json_value_string(\"type\", \"nstat\");\n\n    sharkd_json_array_open(\"fields\");\n    for (i = 0; i < stat_data->stat_tap_data->nfields; i++)\n    {\n        stat_tap_table_item *field = &(stat_data->stat_tap_data->fields[i]);\n\n        json_dumper_begin_object(&dumper);\n        sharkd_json_value_string(\"c\", field->column_name);\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"tables\");\n    for (i = 0; i < stat_data->stat_tap_data->tables->len; i++)\n    {\n        stat_tap_table *table = g_array_index(stat_data->stat_tap_data->tables, stat_tap_table *, i);\n\n        json_dumper_begin_object(&dumper);\n\n        sharkd_json_value_string(\"t\", table->title);\n\n        sharkd_json_array_open(\"i\");\n        for (j = 0; j < table->num_elements; j++)\n        {\n            stat_tap_table_item_type *field_data;\n\n            field_data = stat_tap_get_field_data(table, j, 0);\n            if (field_data == NULL || field_data->type == TABLE_ITEM_NONE) /* Nothing for us here */\n                continue;\n\n            sharkd_json_array_open(NULL);\n            for (k = 0; k < table->num_fields; k++)\n            {\n                field_data = stat_tap_get_field_data(table, j, k);\n\n                switch (field_data->type)\n                {\n                    case TABLE_ITEM_UINT:\n                        sharkd_json_value_anyf(NULL, \"%u\", field_data->value.uint_value);\n                        break;\n\n                    case TABLE_ITEM_INT:\n                        sharkd_json_value_anyf(NULL, \"%d\", field_data->value.int_value);\n                        break;\n\n                    case TABLE_ITEM_STRING:\n                        sharkd_json_value_string(NULL, field_data->value.string_value);\n                        break;\n\n                    case TABLE_ITEM_FLOAT:\n                        sharkd_json_value_anyf(NULL, \"%f\", field_data->value.float_value);\n                        break;\n\n                    case TABLE_ITEM_ENUM:\n                        sharkd_json_value_anyf(NULL, \"%d\", field_data->value.enum_value);\n                        break;\n\n                    case TABLE_ITEM_NONE:\n                        sharkd_json_value_anyf(NULL, \"null\");\n                        break;\n                }\n            }\n\n            sharkd_json_array_close();\n        }\n        sharkd_json_array_close();\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n\n    json_dumper_end_object(&dumper);\n}\n\nstatic void\nsharkd_session_free_tap_nstat_cb(void *arg)\n{\n    stat_data_t *stat_data = (stat_data_t *) arg;\n\n    free_stat_tables(stat_data->stat_tap_data);\n}\n\n/**\n * sharkd_session_process_tap_rtd_cb()\n *\n * Output rtd tap:\n *   (m) tap        - tap name\n *   (m) type       - tap output type\n *   (m) stats - statistics rows - array object with attributes:\n *                  (m) type - statistic name\n *                  (m) num - number of messages\n *                  (m) min - minimum SRT time\n *                  (m) max - maximum SRT time\n *                  (m) tot - total SRT time\n *                  (m) min_frame - minimal SRT\n *                  (m) max_frame - maximum SRT\n *                  (o) open_req - Open Requests\n *                  (o) disc_rsp - Discarded Responses\n *                  (o) req_dup  - Duplicated Requests\n *                  (o) rsp_dup  - Duplicated Responses\n *   (o) open_req   - Open Requests\n *   (o) disc_rsp   - Discarded Responses\n *   (o) req_dup    - Duplicated Requests\n *   (o) rsp_dup    - Duplicated Responses\n */\nstatic void\nsharkd_session_process_tap_rtd_cb(void *arg)\n{\n    rtd_data_t *rtd_data = (rtd_data_t *) arg;\n    register_rtd_t *rtd  = (register_rtd_t *) rtd_data->user_data;\n\n    unsigned i, j;\n\n    const char *filter = proto_get_protocol_filter_name(get_rtd_proto_id(rtd));\n\n    /* XXX, some dissectors are having single table and multiple timestats (mgcp, megaco),\n     *      some multiple table and single timestat (radius, h225)\n     *      and it seems that value_string is used one for timestamp-ID, other one for table-ID\n     *      I wonder how it will gonna work with multiple timestats and multiple tables...\n     * (for usage grep for: register_rtd_table)\n     */\n    const value_string *vs = get_rtd_value_string(rtd);\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_stringf(\"tap\", \"rtd:%s\", filter);\n    sharkd_json_value_string(\"type\", \"rtd\");\n\n    if (rtd_data->stat_table.num_rtds == 1)\n    {\n        const rtd_timestat *ms = &rtd_data->stat_table.time_stats[0];\n\n        sharkd_json_value_anyf(\"open_req\", \"%u\", ms->open_req_num);\n        sharkd_json_value_anyf(\"disc_rsp\", \"%u\", ms->disc_rsp_num);\n        sharkd_json_value_anyf(\"req_dup\", \"%u\", ms->req_dup_num);\n        sharkd_json_value_anyf(\"rsp_dup\", \"%u\", ms->rsp_dup_num);\n    }\n\n    sharkd_json_array_open(\"stats\");\n    for (i = 0; i < rtd_data->stat_table.num_rtds; i++)\n    {\n        const rtd_timestat *ms = &rtd_data->stat_table.time_stats[i];\n\n        for (j = 0; j < ms->num_timestat; j++)\n        {\n            const char *type_str;\n\n            if (ms->rtd[j].num == 0)\n                continue;\n\n            json_dumper_begin_object(&dumper);\n\n            if (rtd_data->stat_table.num_rtds == 1)\n                type_str = val_to_str_const(j, vs, \"Other\"); /* 1 table - description per row */\n            else\n                type_str = val_to_str_const(i, vs, \"Other\"); /* multiple table - description per table */\n            sharkd_json_value_string(\"type\", type_str);\n\n            sharkd_json_value_anyf(\"num\", \"%u\", ms->rtd[j].num);\n            sharkd_json_value_anyf(\"min\", \"%.9f\", nstime_to_sec(&(ms->rtd[j].min)));\n            sharkd_json_value_anyf(\"max\", \"%.9f\", nstime_to_sec(&(ms->rtd[j].max)));\n            sharkd_json_value_anyf(\"tot\", \"%.9f\", nstime_to_sec(&(ms->rtd[j].tot)));\n            sharkd_json_value_anyf(\"min_frame\", \"%u\", ms->rtd[j].min_num);\n            sharkd_json_value_anyf(\"max_frame\", \"%u\", ms->rtd[j].max_num);\n\n            if (rtd_data->stat_table.num_rtds != 1)\n            {\n                /* like in tshark, display it on every row */\n                sharkd_json_value_anyf(\"open_req\", \"%u\", ms->open_req_num);\n                sharkd_json_value_anyf(\"disc_rsp\", \"%u\", ms->disc_rsp_num);\n                sharkd_json_value_anyf(\"req_dup\", \"%u\", ms->req_dup_num);\n                sharkd_json_value_anyf(\"rsp_dup\", \"%u\", ms->rsp_dup_num);\n            }\n\n            json_dumper_end_object(&dumper);\n        }\n    }\n    sharkd_json_array_close();\n\n    json_dumper_end_object(&dumper);\n}\n\nstatic void\nsharkd_session_free_tap_rtd_cb(void *arg)\n{\n    rtd_data_t *rtd_data = (rtd_data_t *) arg;\n\n    free_rtd_table(&rtd_data->stat_table);\n    g_free(rtd_data);\n}\n\n/**\n * sharkd_session_process_tap_srt_cb()\n *\n * Output srt tap:\n *   (m) tap        - tap name\n *   (m) type       - tap output type\n *\n *   (m) tables - array of object with attributes:\n *                  (m) n - table name\n *                  (m) f - table filter\n *                  (o) c - table column name\n *                  (m) r - table rows - array object with attributes:\n *                            (m) n   - row name\n *                            (m) idx - procedure index\n *                            (m) num - number of events\n *                            (m) min - minimum SRT time\n *                            (m) max - maximum SRT time\n *                            (m) tot - total SRT time\n */\nstatic void\nsharkd_session_process_tap_srt_cb(void *arg)\n{\n    srt_data_t *srt_data = (srt_data_t *) arg;\n    register_srt_t *srt = (register_srt_t *) srt_data->user_data;\n\n    const char *filter = proto_get_protocol_filter_name(get_srt_proto_id(srt));\n\n    unsigned i;\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_stringf(\"tap\", \"srt:%s\", filter);\n    sharkd_json_value_string(\"type\", \"srt\");\n\n    sharkd_json_array_open(\"tables\");\n    for (i = 0; i < srt_data->srt_array->len; i++)\n    {\n        /* SRT table */\n        srt_stat_table *rst = g_array_index(srt_data->srt_array, srt_stat_table *, i);\n\n        int j;\n\n        json_dumper_begin_object(&dumper);\n\n        if (rst->name)\n            sharkd_json_value_string(\"n\", rst->name);\n        else if (rst->short_name)\n            sharkd_json_value_string(\"n\", rst->short_name);\n        else\n            sharkd_json_value_stringf(\"n\", \"table%u\", i);\n\n        if (rst->filter_string)\n            sharkd_json_value_string(\"f\", rst->filter_string);\n\n        if (rst->proc_column_name)\n            sharkd_json_value_string(\"c\", rst->proc_column_name);\n\n        sharkd_json_array_open(\"r\");\n        for (j = 0; j < rst->num_procs; j++)\n        {\n            /* SRT row */\n            srt_procedure_t *proc = &rst->procedures[j];\n\n            if (proc->stats.num == 0)\n                continue;\n\n            json_dumper_begin_object(&dumper);\n\n            sharkd_json_value_string(\"n\", proc->procedure);\n\n            if (rst->filter_string)\n                sharkd_json_value_anyf(\"idx\", \"%d\", proc->proc_index);\n\n            sharkd_json_value_anyf(\"num\", \"%u\", proc->stats.num);\n\n            sharkd_json_value_anyf(\"min\", \"%.9f\", nstime_to_sec(&proc->stats.min));\n            sharkd_json_value_anyf(\"max\", \"%.9f\", nstime_to_sec(&proc->stats.max));\n            sharkd_json_value_anyf(\"tot\", \"%.9f\", nstime_to_sec(&proc->stats.tot));\n\n            json_dumper_end_object(&dumper);\n        }\n        sharkd_json_array_close();\n\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n\n    json_dumper_end_object(&dumper);\n}\n\nstatic void\nsharkd_session_free_tap_srt_cb(void *arg)\n{\n    srt_data_t *srt_data = (srt_data_t *) arg;\n    register_srt_t *srt = (register_srt_t *) srt_data->user_data;\n\n    free_srt_table(srt, srt_data->srt_array);\n    g_array_free(srt_data->srt_array, TRUE);\n    g_free(srt_data);\n}\n\nstatic void\nsharkd_session_process_tap_phs_cb_aux(phs_t *rs)\n{\n    for (; rs; rs = rs->sibling) {\n        if (rs->protocol == -1) {\n            return;\n        }\n        sharkd_json_object_open(NULL);\n        sharkd_json_value_string(\"proto\", rs->proto_name);\n        sharkd_json_value_anyf(\"frames\", \"%\"PRIu32, rs->frames);\n        sharkd_json_value_anyf(\"bytes\", \"%\"PRIu64, rs->bytes);\n        if (rs->child != NULL && rs->child->protocol != -1) {\n            sharkd_json_array_open(\"protos\");\n            sharkd_session_process_tap_phs_cb_aux(rs->child);\n            sharkd_json_array_close();\n        }\n        sharkd_json_object_close();\n    }\n}\n\n/**\n * sharkd_session_process_tap_phs_cb()\n *\n * Output phs tap:\n *   (m) tap        - tap name\n *   (m) type       - tap output type\n *   (m) filter     - tap filter argument\n *   (m) protos     - array of proto objects\n *\n *   proto object:\n *   (m) proto      - protocol name\n *   (m) frames     - frame count\n *   (m) bytes      - bytes count\n *   (o) protos     - array of proto objects\n */\nstatic void\nsharkd_session_process_tap_phs_cb(void *arg)\n{\n    phs_t *rs = (phs_t *)arg;\n    sharkd_json_object_open(NULL);\n    sharkd_json_value_string(\"tap\", \"phs\");\n    sharkd_json_value_string(\"type\", \"phs\");\n    sharkd_json_value_string(\"filter\", rs->filter ? rs->filter : \"\");\n    sharkd_json_array_open(\"protos\");\n    sharkd_session_process_tap_phs_cb_aux(rs);\n    sharkd_json_array_close();\n    sharkd_json_object_close();\n}\n\nstatic void\nsharkd_session_free_tap_phs_cb(void *arg)\n{\n    phs_t *rs = (phs_t *)arg;\n    free_phs(rs);\n}\n\nstruct sharkd_export_object_list\n{\n    struct sharkd_export_object_list *next;\n\n    char *type;\n    const char *proto;\n    GSList *entries;\n};\n\nstatic struct sharkd_export_object_list *sharkd_eo_list;\n\n/**\n * sharkd_session_process_tap_eo_cb()\n *\n * Output eo tap:\n *   (m) tap        - tap name\n *   (m) type       - tap output type\n *   (m) proto      - protocol short name\n *   (m) objects    - array of object with attributes:\n *                  (m) pkt - packet number\n *                  (o) hostname - hostname\n *                  (o) type - content type\n *                  (o) filename - filename\n *                  (m) len - object length\n *                  (m) sha1 - object's sha1 sum\n */\nstatic void\nsharkd_session_process_tap_eo_cb(void *tapdata)\n{\n    export_object_list_t *tap_object = (export_object_list_t *) tapdata;\n    struct sharkd_export_object_list *object_list = (struct sharkd_export_object_list *) tap_object->gui_data;\n    GSList *slist;\n    int i = 0;\n    char sha1sum_bytes[HASH_SHA1_LENGTH], *sha1sum_str;\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_string(\"tap\", object_list->type);\n    sharkd_json_value_string(\"type\", \"eo\");\n\n    sharkd_json_value_string(\"proto\", object_list->proto);\n\n    sharkd_json_array_open(\"objects\");\n    for (slist = object_list->entries; slist; slist = slist->next)\n    {\n        const export_object_entry_t *eo_entry = (export_object_entry_t *) slist->data;\n\n        json_dumper_begin_object(&dumper);\n\n        sharkd_json_value_anyf(\"pkt\", \"%u\", eo_entry->pkt_num);\n\n        if (eo_entry->hostname)\n            sharkd_json_value_string(\"hostname\", eo_entry->hostname);\n\n        if (eo_entry->content_type)\n            sharkd_json_value_string(\"type\", eo_entry->content_type);\n\n        if (eo_entry->filename)\n            sharkd_json_value_string(\"filename\", eo_entry->filename);\n\n        sharkd_json_value_stringf(\"_download\", \"%s_%d\", object_list->type, i);\n\n        sharkd_json_value_anyf(\"len\", \"%zu\", eo_entry->payload_len);\n\n        gcry_md_hash_buffer(GCRY_MD_SHA1, sha1sum_bytes, eo_entry->payload_data, eo_entry->payload_len);\n        sha1sum_str = bytes_to_str(NULL, sha1sum_bytes, HASH_SHA1_LENGTH);\n        sharkd_json_value_string(\"sha1\", sha1sum_str);\n        g_free(sha1sum_str);\n\n        json_dumper_end_object(&dumper);\n\n        i++;\n    }\n    sharkd_json_array_close();\n\n    json_dumper_end_object(&dumper);\n}\n\nstatic void\nsharkd_eo_object_list_add_entry(void *gui_data, export_object_entry_t *entry)\n{\n    struct sharkd_export_object_list *object_list = (struct sharkd_export_object_list *) gui_data;\n\n    object_list->entries = g_slist_append(object_list->entries, entry);\n}\n\nstatic export_object_entry_t *\nsharkd_eo_object_list_get_entry(void *gui_data, int row)\n{\n    struct sharkd_export_object_list *object_list = (struct sharkd_export_object_list *) gui_data;\n\n    return (export_object_entry_t *) g_slist_nth_data(object_list->entries, row);\n}\n\nstatic struct sharkd_export_object_list *\nsharkd_eo_object_list_get_entry_by_type(void *gui_data, const char *tap_type)\n{\n    struct sharkd_export_object_list *object_list = (struct sharkd_export_object_list *) gui_data;\n    for (; object_list; object_list = object_list->next)\n    {\n        if (!strcmp(object_list->type, tap_type))\n            return object_list;\n    }\n    return NULL;\n}\n\n\n/**\n * sharkd_session_process_tap_rtp_cb()\n *\n * Output RTP streams tap:\n *   (m) tap        - tap name\n *   (m) type       - tap output type\n *   (m) streams    - array of object with attributes:\n *                  (m) ssrc        - RTP synchronization source identifier\n *                  (m) payload     - stream payload\n *                  (m) saddr       - source address\n *                  (m) sport       - source port\n *                  (m) daddr       - destination address\n *                  (m) dport       - destination port\n *                  (m) pkts        - packets count\n *                  (m) max_delta   - max delta (ms)\n *                  (m) max_jitter  - max jitter (ms)\n *                  (m) mean_jitter - mean jitter (ms)\n *                  (m) expectednr  -\n *                  (m) totalnr     -\n *                  (m) problem     - if analyser found the problem\n *                  (m) ipver       - address IP version (4 or 6)\n */\nstatic void\nsharkd_session_process_tap_rtp_cb(void *arg)\n{\n    rtpstream_tapinfo_t *rtp_tapinfo = (rtpstream_tapinfo_t *) arg;\n\n    GList *listx;\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_string(\"tap\", \"rtp-streams\");\n    sharkd_json_value_string(\"type\", \"rtp-streams\");\n\n    sharkd_json_array_open(\"streams\");\n    for (listx = g_list_first(rtp_tapinfo->strinfo_list); listx; listx = listx->next)\n    {\n        rtpstream_info_t *streaminfo = (rtpstream_info_t *) listx->data;\n        rtpstream_info_calc_t calc;\n\n        rtpstream_info_calculate(streaminfo, &calc);\n\n        json_dumper_begin_object(&dumper);\n\n        sharkd_json_value_stringf(\"ssrc\", \"0x%x\", calc.ssrc);\n        sharkd_json_value_string(\"payload\", calc.all_payload_type_names);\n\n        sharkd_json_value_string(\"saddr\", calc.src_addr_str);\n        sharkd_json_value_anyf(\"sport\", \"%u\", calc.src_port);\n        sharkd_json_value_string(\"daddr\", calc.dst_addr_str);\n        sharkd_json_value_anyf(\"dport\", \"%u\", calc.dst_port);\n\n        sharkd_json_value_anyf(\"start_time\", \"%f\", calc.start_time_ms);\n        sharkd_json_value_anyf(\"duration\", \"%f\", calc.duration_ms);\n\n        sharkd_json_value_anyf(\"pkts\", \"%u\", calc.packet_count);\n        sharkd_json_value_anyf(\"lost\", \"%u\", calc.lost_num);\n        sharkd_json_value_anyf(\"lost_percent\", \"%f\", calc.lost_perc);\n\n        sharkd_json_value_anyf(\"max_delta\", \"%f\",calc.max_delta);\n        sharkd_json_value_anyf(\"min_delta\", \"%f\",calc.min_delta);\n        sharkd_json_value_anyf(\"mean_delta\", \"%f\",calc.mean_delta);\n        sharkd_json_value_anyf(\"min_jitter\", \"%f\", calc.min_jitter);\n        sharkd_json_value_anyf(\"max_jitter\", \"%f\", calc.max_jitter);\n        sharkd_json_value_anyf(\"mean_jitter\", \"%f\", calc.mean_jitter);\n\n        sharkd_json_value_anyf(\"expectednr\", \"%u\", calc.packet_expected);\n        sharkd_json_value_anyf(\"totalnr\", \"%u\", calc.total_nr);\n\n        sharkd_json_value_anyf(\"problem\", calc.problem ? \"true\" : \"false\");\n\n        /* for filter */\n        sharkd_json_value_anyf(\"ipver\", \"%d\", (streaminfo->id.src_addr.type == AT_IPv6) ? 6 : 4);\n\n        rtpstream_info_calc_free(&calc);\n\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n\n    json_dumper_end_object(&dumper);\n}\n\n/**\n* sharkd_session_process_tap_multicast_cb()\n*\n* Output UDP Multicast streams tap:\n*   (m) tap                     - tap name\n*   (m) type                    - tap output type\n*   (m) bufferThresholdBytes    - byte count for a stream where a buffer alarm should be reported\n*   (m) burstIntervalMs         - analysis interval in milliseconds\n*   (m) burstThresholdPackets   - count of packets in an interval that should trigger an alarm\n*   (m) streams                 - array of streams with metrics:\n*           (m) saddr       - source address\n*           (m) sport       - source port\n*           (m) daddr       - destination address\n*           (m) dport       - destination port\n*           (m) packets     - object group for packet metrics with attributes:\n*                (m) number     - count of packets in the stream\n*                (m) perSecond  - average number of packets per seconds in the stream\n*           (m) bandwidth     - object group for bandwidth metrics with attributes:\n*                (m) average    - average measured bitrate in the stream\n*                (m) max        - max measured bitrate in the stream\n*           (m) buffer       - object group for buffer metrics with attributes:\n*                (m) alarms     - number of times the stream exceeded the buffer threshold\n*                (m) max        - highest stream buffer utilization\n*           (m) burst        - object group for burst metrics with attributes:\n*                (m) alarms     - number of times the stream exceeded the burst threshold\n*                (m) max        - most stream packets measured in a burst interval\n*/\nstatic void\nsharkd_session_process_tap_multicast_cb(void *arg)\n{\n    mcaststream_tapinfo_t *tapinfo = (mcaststream_tapinfo_t *)arg;\n    GList *list_item;\n    char *addr_str;\n\n    json_dumper_begin_object(&dumper);\n\n    sharkd_json_value_string(\"tap\", \"multicast\");\n    sharkd_json_value_string(\"type\", \"multicast\");\n\n    sharkd_json_value_anyf(\"bufferThresholdBytes\", \"%u\", mcast_stream_bufferalarm);\n    sharkd_json_value_anyf(\"burstIntervalMs\", \"%u\", mcast_stream_burstint);\n    sharkd_json_value_anyf(\"burstThresholdPackets\", \"%u\", mcast_stream_trigger);\n\n    sharkd_json_array_open(\"streams\");\n    for (list_item = g_list_first(tapinfo->strinfo_list); list_item; list_item = list_item->next) {\n        mcast_stream_info_t *stream_info = (mcast_stream_info_t *) list_item->data;\n        sharkd_json_object_open(NULL);\n        {\n            addr_str = address_to_display(NULL, &stream_info->src_addr);\n            sharkd_json_value_string(\"saddr\", addr_str);\n            wmem_free(NULL, addr_str);\n            sharkd_json_value_anyf(\"sport\", \"%u\", stream_info->src_port);\n            addr_str = address_to_display(NULL, &stream_info->dest_addr);\n            sharkd_json_value_string(\"daddr\", addr_str);\n            wmem_free(NULL, addr_str);\n            sharkd_json_value_anyf(\"dport\", \"%u\", stream_info->dest_port);\n            sharkd_json_object_open(\"packets\");\n            {\n                sharkd_json_value_anyf(\"number\", \"%u\", stream_info->npackets);\n                sharkd_json_value_anyf(\"perSecond\", \"%f\", stream_info->apackets);\n            }\n            sharkd_json_object_close();\n            sharkd_json_object_open(\"bandwidth\");\n            {\n                sharkd_json_value_anyf(\"average\", \"%f\", stream_info->average_bw);\n                sharkd_json_value_anyf(\"max\", \"%f\", stream_info->element.maxbw);\n            }\n            sharkd_json_object_close();\n            sharkd_json_object_open(\"buffer\");\n            {\n                sharkd_json_value_anyf(\"alarms\", \"%u\", stream_info->element.numbuffalarms);\n                sharkd_json_value_anyf(\"max\", \"%u\", stream_info->element.topbuffusage);\n            }\n            sharkd_json_object_close();\n            sharkd_json_object_open(\"burst\");\n            {\n                sharkd_json_value_anyf(\"alarms\", \"%u\", stream_info->element.numbursts);\n                sharkd_json_value_anyf(\"max\", \"%u\", stream_info->element.topburstsize);\n            }\n            sharkd_json_object_close();\n        }\n        sharkd_json_object_close();\n    }\n    sharkd_json_array_close();\n\n    json_dumper_end_object(&dumper);\n}\n\nstatic void\nsharkd_session_process_free_tap_multicast_cb(void *tapdata)\n{\n    mcaststream_tapinfo_t *tapinfo = (mcaststream_tapinfo_t *)tapdata;\n\n    mcaststream_reset(tapinfo);\n\n    g_free(tapinfo);\n}\n\n/**\n * sharkd_session_process_tap_voip_calls_cb()\n *\n * Output VoIP Calls tap:\n *   (m) tap                    - tap name\n *   (m) type                   - tap output type\n *   (m) calls                  - array of objects with attributes:\n *                              (m) call            - call number\n *                              (m) start_time      - start timestamp\n *                              (m) stop_time       - stop timestamp\n *                              (m) initial_speaker - address of initial speaker\n *                              (m) from            - from address\n *                              (m) to              - to address\n *                              (m) protocol        - protocol name\n *                              (m) packets         - packet count\n *                              (m) state           - state string\n *                              (m) comment         - comment string\n */\nstatic void\nsharkd_session_process_tap_voip_calls_cb(void *arg)\n{\n    voip_calls_tapinfo_t *tapinfo = (voip_calls_tapinfo_t *)arg;\n    char *addr_str;\n    GList *cur_call = g_queue_peek_nth_link(tapinfo->callsinfos, 0);\n    sharkd_json_object_open(NULL);\n    sharkd_json_value_string(\"tap\", \"voip-calls\");\n    sharkd_json_value_string(\"type\", \"voip-calls\");\n    sharkd_json_array_open(\"calls\");\n    while (cur_call && cur_call->data) {\n        voip_calls_info_t *call_info_ = (voip_calls_info_t*) cur_call->data;\n        sharkd_json_object_open(NULL);\n        sharkd_json_value_anyf(\"call\", \"%hu\", call_info_->call_num);\n        sharkd_json_value_anyf(\"start_time\", \"%.6f\", nstime_to_sec(&(call_info_->start_rel_ts)));\n        sharkd_json_value_anyf(\"stop_time\", \"%.6f\", nstime_to_sec(&(call_info_->stop_rel_ts)));\n        addr_str = address_to_display(NULL, &(call_info_->initial_speaker));\n        sharkd_json_value_string(\"initial_speaker\", addr_str);\n        wmem_free(NULL, addr_str);\n        sharkd_json_value_string(\"from\", call_info_->from_identity);\n        sharkd_json_value_string(\"to\", call_info_->to_identity);\n        sharkd_json_value_string(\"protocol\", ((call_info_->protocol == VOIP_COMMON) && call_info_->protocol_name) ?\n            call_info_->protocol_name : voip_protocol_name[call_info_->protocol]);\n        sharkd_json_value_anyf(\"packets\", \"%u\", call_info_->npackets);\n        sharkd_json_value_string(\"state\", voip_call_state_name[call_info_->call_state]);\n        sharkd_json_value_string(\"comment\", call_info_->call_comment);\n        sharkd_json_object_close();\n        cur_call = g_list_next(cur_call);\n    }\n    sharkd_json_array_close();\n    sharkd_json_object_close();\n}\n\nstatic void\nsharkd_session_free_tap_voip_calls_cb(void *tapdata)\n{\n    voip_calls_tapinfo_t *tapinfo = (voip_calls_tapinfo_t *)tapdata;\n    voip_calls_remove_all_tap_listeners(tapinfo);\n    if (tapinfo->callsinfos != NULL) {\n        g_queue_free(tapinfo->callsinfos);\n    }\n    if (tapinfo->graph_analysis != NULL) {\n        sequence_analysis_info_free(tapinfo->graph_analysis);\n    }\n    memset(tapinfo, 0, sizeof(*tapinfo));\n}\n\n\nstruct sharkd_voip_convs_req {\n    voip_calls_tapinfo_t *tapinfo;\n    const char *tap_name;\n};\n\n/**\n * sharkd_session_process_tap_voip_convs_cb()\n *\n * Output VoIP Conversations tap:\n *   (m) tap                    - tap name\n *   (m) type                   - tap output type\n *   (m) convs                  - array of objects with attributes:\n *                              (m) frame    - frame number\n *                              (m) call     - call number\n *                              (m) time     - timestamp\n *                              (m) dst_addr - destination address\n *                              (m) dst_port - destination port\n *                              (m) src_addr - source address\n *                              (m) src_port - source port\n *                              (m) label    - label string\n *                              (m) comment  - comment string\n */\nstatic void\nsharkd_session_process_tap_voip_convs_cb(void *arg)\n{\n    struct sharkd_voip_convs_req *voip_convs_req = (struct sharkd_voip_convs_req *)arg;\n    voip_calls_tapinfo_t *tapinfo = voip_convs_req->tapinfo;\n    seq_analysis_info_t *sainfo = tapinfo->graph_analysis;\n    char *addr_str;\n    sequence_analysis_list_sort(sainfo);\n    sharkd_json_object_open(NULL);\n    sharkd_json_value_string(\"tap\", voip_convs_req->tap_name);\n    sharkd_json_value_string(\"type\", \"voip-convs\");\n    sharkd_json_array_open(\"convs\");\n    for (GList *cur = g_queue_peek_nth_link(sainfo->items, 0); cur; cur = g_list_next(cur)) {\n        seq_analysis_item_t *sai = (seq_analysis_item_t *) cur->data;\n        if ((voip_conv_sel[sai->conv_num / VOIP_CONV_BITS] & (1 << (sai->conv_num % VOIP_CONV_BITS))) == 0)\n            continue;\n        sharkd_json_object_open(NULL);\n        sharkd_json_value_anyf(\"frame\", \"%d\", sai->frame_number);\n        sharkd_json_value_anyf(\"call\", \"%d\", sai->conv_num);\n        sharkd_json_value_string(\"time\", sai->time_str);\n        addr_str = address_to_display(NULL, &(sai->dst_addr));\n        sharkd_json_value_string(\"dst_addr\", addr_str);\n        wmem_free(NULL, addr_str);\n        sharkd_json_value_anyf(\"dst_port\", \"%d\", sai->port_dst);\n        addr_str = address_to_display(NULL, &(sai->src_addr));\n        sharkd_json_value_string(\"src_addr\", addr_str);\n        wmem_free(NULL, addr_str);\n        sharkd_json_value_anyf(\"src_port\", \"%d\", sai->port_src);\n        sharkd_json_value_string(\"label\", sai->frame_label);\n        sharkd_json_value_string(\"comment\", sai->comment);\n        sharkd_json_object_close();\n    }\n    sharkd_json_array_close();\n    sharkd_json_object_close();\n}\n\nstatic void\nsharkd_session_free_tap_voip_convs_cb(void *tapdata)\n{\n    struct sharkd_voip_convs_req *voip_convs_req = (struct sharkd_voip_convs_req *)tapdata;\n    voip_calls_tapinfo_t *tapinfo = voip_convs_req->tapinfo;\n    voip_calls_remove_all_tap_listeners(tapinfo);\n    if (tapinfo->callsinfos != NULL) {\n        g_queue_free(tapinfo->callsinfos);\n    }\n    if (tapinfo->graph_analysis != NULL) {\n        sequence_analysis_info_free(tapinfo->graph_analysis);\n    }\n    memset(tapinfo, 0, sizeof(*tapinfo));\n    g_free(voip_convs_req);\n}\n\nstruct sharkd_hosts_req {\n    const char *tap_name;\n    bool dump_v4;\n    bool dump_v6;\n};\n\nstatic int\nsharkd_session_tap_ipv4_host_compare(const void *a, const void *b)\n{\n    return ws_ascii_strnatcmp(((const hashipv4_t *)a)->name,\n                              ((const hashipv4_t *)b)->name);\n}\n\nstatic int\nsharkd_session_tap_ipv6_host_compare(const void *a, const void *b)\n{\n    return ws_ascii_strnatcmp(((const hashipv6_t *)a)->name,\n                              ((const hashipv6_t *)b)->name);\n}\n\nstatic void\nsharkd_session_tap_ipv4_host_print(void *data, void *user_data _U_)\n{\n    hashipv4_t *ipv4_hash_table_entry = (hashipv4_t *)data;\n    sharkd_json_object_open(NULL);\n    sharkd_json_value_string(\"name\", ipv4_hash_table_entry->name);\n    sharkd_json_value_string(\"addr\", ipv4_hash_table_entry->ip);\n    sharkd_json_object_close();\n}\n\nstatic void\nsharkd_session_tap_ipv6_host_print(void *data, void *user_data _U_)\n{\n    hashipv6_t *ipv6_hash_table_entry = (hashipv6_t *)data;\n    sharkd_json_object_open(NULL);\n    sharkd_json_value_string(\"name\", ipv6_hash_table_entry->name);\n    sharkd_json_value_string(\"addr\", ipv6_hash_table_entry->ip6);\n    sharkd_json_object_close();\n}\n\nstatic void\nsharkd_session_tap_ipv4_host_insert_sorted(void *key _U_, void *value, void *user_data)\n{\n    hashipv4_t *ipv4_hash_table_entry = (hashipv4_t *)value;\n    GSList **list = (GSList **)user_data;\n    if ((ipv4_hash_table_entry->flags & NAME_RESOLVED)) {\n        *list = g_slist_insert_sorted(*list, ipv4_hash_table_entry, sharkd_session_tap_ipv4_host_compare);\n    }\n}\n\nstatic void\nsharkd_session_tap_ipv6_host_insert_sorted(void *key _U_, void *value, void *user_data)\n{\n    hashipv6_t *ipv6_hash_table_entry = (hashipv6_t *)value;\n    GSList **list = (GSList **) user_data;\n    if ((ipv6_hash_table_entry->flags & NAME_RESOLVED)) {\n        *list = g_slist_insert_sorted(*list, ipv6_hash_table_entry, sharkd_session_tap_ipv6_host_compare);\n    }\n}\n\nstatic void\nsharkd_session_tap_ipv4_hosts_print(void)\n{\n    wmem_map_t *ipv4_hash_table = get_ipv4_hash_table();\n    if (!ipv4_hash_table)\n        return;\n    GSList *list = NULL;\n    wmem_map_foreach(ipv4_hash_table, sharkd_session_tap_ipv4_host_insert_sorted, &list);\n    g_slist_foreach(list, sharkd_session_tap_ipv4_host_print, NULL);\n    g_slist_free(list);\n}\n\nstatic void\nsharkd_session_tap_ipv6_hosts_print(void)\n{\n    wmem_map_t *ipv6_hash_table = get_ipv6_hash_table();\n    if (!ipv6_hash_table)\n        return;\n    GSList *list = NULL;\n    wmem_map_foreach(ipv6_hash_table, sharkd_session_tap_ipv6_host_insert_sorted, &list);\n    g_slist_foreach(list, sharkd_session_tap_ipv6_host_print, NULL);\n    g_slist_free(list);\n}\n\n/**\n * sharkd_session_process_tap_hosts_cb()\n *\n * Output Hosts tap:\n *   (m) tap                    - tap name\n *   (m) type                   - tap output type\n *   (o) ipv4_hosts             - array of objects with attributes:\n *                              (m) addr - ipv4 address\n *                              (m) name - resolved name of address\n *   (o) ipv6_hosts             - array of objects with attributes:\n *                              (m) addr - ipv6 address\n *                              (m) name - resolved name of address\n */\nstatic void\nsharkd_session_process_tap_hosts_cb(void *arg)\n{\n    struct sharkd_hosts_req *hosts_req = (struct sharkd_hosts_req *)arg;\n    sharkd_json_object_open(NULL);\n    sharkd_json_value_string(\"tap\", hosts_req->tap_name);\n    sharkd_json_value_string(\"type\", \"hosts\");\n    if (hosts_req->dump_v4) {\n        sharkd_json_array_open(\"ipv4_hosts\");\n        sharkd_session_tap_ipv4_hosts_print();\n        sharkd_json_array_close();\n    }\n    if (hosts_req->dump_v6) {\n        sharkd_json_array_open(\"ipv6_hosts\");\n        sharkd_session_tap_ipv6_hosts_print();\n        sharkd_json_array_close();\n    }\n    sharkd_json_object_close();\n}\n\nstatic void\nsharkd_session_free_tap_hosts_cb(void *tapdata)\n{\n    struct sharkd_hosts_req *hosts_req = (struct sharkd_hosts_req *)tapdata;\n    g_free(hosts_req);\n}\n\nstatic GString*\nsharkd_session_eo_register_tap_listener(register_eo_t *eo, const char *tap_type, const char *tap_filter, tap_draw_cb tap_draw, void **ptap_data, GFreeFunc* ptap_free)\n{\n    export_object_list_t *eo_object;\n    struct sharkd_export_object_list *object_list;\n\n    object_list = sharkd_eo_object_list_get_entry_by_type(sharkd_eo_list, tap_type);\n    if (object_list)\n    {\n        g_slist_free_full(object_list->entries, (GDestroyNotify) eo_free_entry);\n        object_list->entries = NULL;\n    }\n    else\n    {\n        object_list = g_new(struct sharkd_export_object_list, 1);\n        object_list->type = g_strdup(tap_type);\n        object_list->proto = proto_get_protocol_short_name(find_protocol_by_id(get_eo_proto_id(eo)));\n        object_list->entries = NULL;\n        object_list->next = sharkd_eo_list;\n        sharkd_eo_list = object_list;\n    }\n\n    eo_object  = g_new0(export_object_list_t, 1);\n    eo_object->add_entry = sharkd_eo_object_list_add_entry;\n    eo_object->get_entry = sharkd_eo_object_list_get_entry;\n    eo_object->gui_data = (void *) object_list;\n\n    *ptap_data = eo_object;\n    *ptap_free = g_free; /* need to free only eo_object, object_list need to be kept for potential download */\n\n    return register_tap_listener(get_eo_tap_listener_name(eo), eo_object, tap_filter, 0, NULL, get_eo_packet_func(eo), tap_draw, NULL);\n}\n\n/**\n * sharkd_session_process_tap()\n *\n * Process tap request\n *\n * Input:\n *   (m) tap0         - First tap request\n *   (o) tap1...tap15 - Other tap requests\n *\n * Output object with attributes:\n *   (m) taps  - array of object with attributes:\n *                  (m) tap  - tap name\n *                  (m) type - tap output type\n *                  ...\n *                  for type:stats see sharkd_session_process_tap_stats_cb()\n *                  for type:nstat see sharkd_session_process_tap_nstat_cb()\n *                  for type:conv see sharkd_session_process_tap_conv_cb()\n *                  for type:host see sharkd_session_process_tap_conv_cb()\n *                  for type:rtp-streams see sharkd_session_process_tap_rtp_cb()\n *                  for type:rtp-analyse see sharkd_session_process_tap_rtp_analyse_cb()\n *                  for type:eo see sharkd_session_process_tap_eo_cb()\n *                  for type:expert see sharkd_session_process_tap_expert_cb()\n *                  for type:rtd see sharkd_session_process_tap_rtd_cb()\n *                  for type:srt see sharkd_session_process_tap_srt_cb()\n *                  for type:flow see sharkd_session_process_tap_flow_cb()\n *\n *   (m) err   - error code\n */\nstatic void\nsharkd_session_process_tap(char *buf, const jsmntok_t *tokens, int count)\n{\n    void *taps_data[16];\n    GFreeFunc taps_free[16];\n    int taps_count = 0;\n    int i;\n    const char *tap_filter = json_find_attr(buf, tokens, count, \"filter\");\n\n    rtpstream_tapinfo_t rtp_tapinfo =\n    { NULL, NULL, NULL, NULL, 0, NULL, NULL, 0, TAP_ANALYSE, NULL, NULL, NULL, false, false};\n\n    for (i = 0; i < 16; i++)\n    {\n        char tapbuf[32];\n        const char *tok_tap;\n\n        void *tap_data = NULL;\n        GFreeFunc tap_free = NULL;\n        GString *tap_error = NULL;\n\n        snprintf(tapbuf, sizeof(tapbuf), \"tap%d\", i);\n        tok_tap = json_find_attr(buf, tokens, count, tapbuf);\n        if (!tok_tap)\n            break;\n\n        if (!strncmp(tok_tap, \"stat:\", 5))\n        {\n            stats_tree_cfg *cfg = stats_tree_get_cfg_by_abbr(tok_tap + 5);\n            stats_tree *st;\n\n            if (!cfg)\n            {\n                sharkd_json_error(\n                        rpcid, -11001, NULL,\n                        \"sharkd_session_process_tap() stat %s not found\", tok_tap + 5\n                        );\n                return;\n            }\n\n            st = stats_tree_new(cfg, NULL, tap_filter);\n\n            tap_error = register_tap_listener(st->cfg->tapname, st, st->filter, st->cfg->flags, stats_tree_reset, stats_tree_packet, sharkd_session_process_tap_stats_cb, NULL);\n\n            if (!tap_error && cfg->init)\n                cfg->init(st);\n\n            tap_data = st;\n            tap_free = sharkd_session_free_tap_stats_cb;\n        }\n        else if (!strcmp(tok_tap, \"expert\"))\n        {\n            struct sharkd_expert_tap *expert_tap;\n\n            expert_tap = g_new0(struct sharkd_expert_tap, 1);\n            expert_tap->text = g_string_chunk_new(100);\n\n            tap_error = register_tap_listener(\"expert\", expert_tap, tap_filter, 0, NULL, sharkd_session_packet_tap_expert_cb, sharkd_session_process_tap_expert_cb, NULL);\n\n            tap_data = expert_tap;\n            tap_free = sharkd_session_free_tap_expert_cb;\n        }\n        else if (!strncmp(tok_tap, \"seqa:\", 5))\n        {\n            seq_analysis_info_t *graph_analysis;\n            register_analysis_t *analysis;\n            const char *tap_name;\n            tap_packet_cb tap_func;\n            unsigned tap_flags;\n\n            analysis = sequence_analysis_find_by_name(tok_tap + 5);\n            if (!analysis)\n            {\n                sharkd_json_error(\n                        rpcid, -11002, NULL,\n                        \"sharkd_session_process_tap() seq analysis %s not found\", tok_tap + 5\n                        );\n                return;\n            }\n\n            graph_analysis = sequence_analysis_info_new();\n            graph_analysis->name = tok_tap + 5;\n            /* TODO, make configurable */\n            graph_analysis->any_addr = false;\n\n            tap_name  = sequence_analysis_get_tap_listener_name(analysis);\n            tap_flags = sequence_analysis_get_tap_flags(analysis);\n            tap_func  = sequence_analysis_get_packet_func(analysis);\n\n            tap_error = register_tap_listener(tap_name, graph_analysis, tap_filter, tap_flags, NULL, tap_func, sharkd_session_process_tap_flow_cb, NULL);\n\n            tap_data = graph_analysis;\n            tap_free = sharkd_session_free_tap_flow_cb;\n        }\n        else if (!strncmp(tok_tap, \"conv:\", 5) || !strncmp(tok_tap, \"endpt:\", 6))\n        {\n            struct register_ct *ct = NULL;\n            const char *ct_tapname;\n            struct sharkd_conv_tap_data *ct_data;\n            tap_packet_cb tap_func = NULL;\n\n            if (!strncmp(tok_tap, \"conv:\", 5))\n            {\n                ct = get_conversation_by_proto_id(proto_get_id_by_short_name(tok_tap + 5));\n\n                if (!ct || !(tap_func = get_conversation_packet_func(ct)))\n                {\n                    sharkd_json_error(\n                            rpcid, -11003, NULL,\n                            \"sharkd_session_process_tap() conv %s not found\", tok_tap + 5\n                            );\n                    return;\n                }\n            }\n            else if (!strncmp(tok_tap, \"endpt:\", 6))\n            {\n                ct = get_conversation_by_proto_id(proto_get_id_by_short_name(tok_tap + 6));\n\n                if (!ct || !(tap_func = get_endpoint_packet_func(ct)))\n                {\n                    sharkd_json_error(\n                            rpcid, -11004, NULL,\n                            \"sharkd_session_process_tap() endpt %s not found\", tok_tap + 6\n                            );\n                    return;\n                }\n            }\n            else\n            {\n                sharkd_json_error(\n                        rpcid, -11005, NULL,\n                        \"sharkd_session_process_tap() conv/endpt(?): %s not found\", tok_tap\n                        );\n                return;\n            }\n\n            ct_tapname = proto_get_protocol_filter_name(get_conversation_proto_id(ct));\n\n            ct_data = g_new0(struct sharkd_conv_tap_data, 1);\n            ct_data->type = tok_tap;\n            ct_data->hash.user_data = ct_data;\n\n            /* XXX: make configurable */\n            ct_data->resolve_name = true;\n            ct_data->resolve_port = true;\n\n            tap_error = register_tap_listener(ct_tapname, &ct_data->hash, tap_filter, 0, NULL, tap_func, sharkd_session_process_tap_conv_cb, NULL);\n\n            tap_data = &ct_data->hash;\n            tap_free = sharkd_session_free_tap_conv_cb;\n        }\n        else if (!strncmp(tok_tap, \"nstat:\", 6))\n        {\n            stat_tap_table_ui *stat_tap = stat_tap_by_name(tok_tap + 6);\n            stat_data_t *stat_data;\n\n            if (!stat_tap)\n            {\n                sharkd_json_error(\n                        rpcid, -11006, NULL,\n                        \"sharkd_session_process_tap() nstat=%s not found\", tok_tap + 6\n                        );\n                return;\n            }\n\n            stat_tap->stat_tap_init_cb(stat_tap);\n\n            stat_data = g_new0(stat_data_t, 1);\n            stat_data->stat_tap_data = stat_tap;\n            stat_data->user_data = NULL;\n\n            tap_error = register_tap_listener(stat_tap->tap_name, stat_data, tap_filter, 0, NULL, stat_tap->packet_func, sharkd_session_process_tap_nstat_cb, NULL);\n\n            tap_data = stat_data;\n            tap_free = sharkd_session_free_tap_nstat_cb;\n        }\n        else if (!strncmp(tok_tap, \"rtd:\", 4))\n        {\n            register_rtd_t *rtd = get_rtd_table_by_name(tok_tap + 4);\n            rtd_data_t *rtd_data;\n            char *err;\n\n            if (!rtd)\n            {\n                sharkd_json_error(\n                        rpcid, -11007, NULL,\n                        \"sharkd_session_process_tap() rtd=%s not found\", tok_tap + 4\n                        );\n                return;\n            }\n\n            rtd_table_get_filter(rtd, \"\", &tap_filter, &err);\n            if (err != NULL)\n            {\n                sharkd_json_error(\n                        rpcid, -11008, NULL,\n                        \"sharkd_session_process_tap() rtd=%s err=%s\", tok_tap + 4, err\n                        );\n                g_free(err);\n                return;\n            }\n\n            rtd_data = g_new0(rtd_data_t, 1);\n            rtd_data->user_data = rtd;\n            rtd_table_dissector_init(rtd, &rtd_data->stat_table, NULL, NULL);\n\n            tap_error = register_tap_listener(get_rtd_tap_listener_name(rtd), rtd_data, tap_filter, 0, NULL, get_rtd_packet_func(rtd), sharkd_session_process_tap_rtd_cb, NULL);\n\n            tap_data = rtd_data;\n            tap_free = sharkd_session_free_tap_rtd_cb;\n        }\n        else if (!strncmp(tok_tap, \"srt:\", 4))\n        {\n            register_srt_t *srt = get_srt_table_by_name(tok_tap + 4);\n            srt_data_t *srt_data;\n            char *err;\n\n            if (!srt)\n            {\n                sharkd_json_error(\n                        rpcid, -11009, NULL,\n                        \"sharkd_session_process_tap() srt=%s not found\", tok_tap + 4\n                        );\n                return;\n            }\n\n            srt_table_get_filter(srt, \"\", &tap_filter, &err);\n            if (err != NULL)\n            {\n                sharkd_json_error(\n                        rpcid, -11010, NULL,\n                        \"sharkd_session_process_tap() srt=%s err=%s\", tok_tap + 4, err\n                        );\n                g_free(err);\n                return;\n            }\n\n            srt_data = g_new0(srt_data_t, 1);\n            srt_data->srt_array = g_array_new(FALSE, TRUE, sizeof(srt_stat_table *));\n            srt_data->user_data = srt;\n            srt_table_dissector_init(srt, srt_data->srt_array);\n\n            tap_error = register_tap_listener(get_srt_tap_listener_name(srt), srt_data, tap_filter, 0, NULL, get_srt_packet_func(srt), sharkd_session_process_tap_srt_cb, NULL);\n\n            tap_data = srt_data;\n            tap_free = sharkd_session_free_tap_srt_cb;\n        }\n        else if (!strncmp(tok_tap, \"eo:\", 3))\n        {\n            register_eo_t *eo = get_eo_by_name(tok_tap + 3);\n\n            if (!eo)\n            {\n                sharkd_json_error(\n                        rpcid, -11011, NULL,\n                        \"sharkd_session_process_tap() eo=%s not found\", tok_tap + 3\n                        );\n                return;\n            }\n\n            tap_error = sharkd_session_eo_register_tap_listener(eo, tok_tap, tap_filter, sharkd_session_process_tap_eo_cb, &tap_data, &tap_free);\n\n            /* tap_data & tap_free assigned by sharkd_session_eo_register_tap_listener */\n        }\n        else if (!strcmp(tok_tap, \"rtp-streams\"))\n        {\n            tap_error = register_tap_listener(\"rtp\", &rtp_tapinfo, tap_filter, 0, rtpstream_reset_cb, rtpstream_packet_cb, sharkd_session_process_tap_rtp_cb, NULL);\n\n            tap_data = &rtp_tapinfo;\n            tap_free = rtpstream_reset_cb;\n        }\n        else if (!strncmp(tok_tap, \"rtp-analyse:\", 12))\n        {\n            struct sharkd_analyse_rtp *rtp_req;\n\n            rtp_req = (struct sharkd_analyse_rtp *) g_malloc0(sizeof(*rtp_req));\n            if (!sharkd_rtp_match_init(&rtp_req->id, tok_tap + 12))\n            {\n                rtpstream_id_free(&rtp_req->id);\n                g_free(rtp_req);\n                continue;\n            }\n\n            rtp_req->tap_name = tok_tap;\n            rtp_req->statinfo.first_packet = true;\n            rtp_req->statinfo.reg_pt = PT_UNDEFINED;\n\n            tap_error = register_tap_listener(\"rtp\", rtp_req, tap_filter, 0, NULL, sharkd_session_packet_tap_rtp_analyse_cb, sharkd_session_process_tap_rtp_analyse_cb, NULL);\n\n            tap_data = rtp_req;\n            tap_free = sharkd_session_process_tap_rtp_free_cb;\n        }\n        else if (!strcmp(tok_tap, \"multicast\"))\n        {\n            mcaststream_tapinfo_t *mcaststream_tapinfo;\n            mcaststream_tapinfo = (mcaststream_tapinfo_t *) g_malloc0(sizeof(*mcaststream_tapinfo));\n\n            tap_error = register_tap_listener(\"udp\", mcaststream_tapinfo, tap_filter, 0, NULL, mcaststream_packet, sharkd_session_process_tap_multicast_cb, NULL);\n            tap_data = mcaststream_tapinfo;\n            tap_free = sharkd_session_process_free_tap_multicast_cb;\n        }\n        else if (!strcmp(tok_tap, \"phs\"))\n        {\n            phs_t *rs;\n\n            pc_proto_id = proto_registrar_get_id_byname(\"pkt_comment\");\n\n            rs = new_phs_t(NULL, tap_filter);\n\n            tap_error = register_tap_listener(\"frame\", rs, tap_filter,\n                                              TL_REQUIRES_PROTO_TREE|TL_REQUIRES_PROTOCOLS,\n                                              NULL, protohierstat_packet,\n                                              sharkd_session_process_tap_phs_cb, NULL);\n\n            tap_data = rs;\n            tap_free = sharkd_session_free_tap_phs_cb;\n        }\n        else if (!strcmp(tok_tap, \"voip-calls\"))\n        {\n            voip_stat_init_tapinfo();\n\n            tap_error = register_tap_listener(\"frame\", &tapinfo_, tap_filter, 0, NULL, NULL, sharkd_session_process_tap_voip_calls_cb, NULL);\n\n            tapinfo_.session = cfile.epan;\n            voip_calls_init_all_taps(&tapinfo_);\n\n            tap_data = &tapinfo_;\n            tap_free = sharkd_session_free_tap_voip_calls_cb;\n        }\n        else if (!strncmp(tok_tap, \"voip-convs:\", 11))\n        {\n            int len;\n            unsigned int min, max;\n            struct sharkd_voip_convs_req *voip_convs_req;\n            const char *conv_arg = tok_tap + 11;\n\n            // parse tok_tap to get which call we are asking for\n            if (*conv_arg == 0) {\n                // set all bits of voip_conv_sel (-1 in binary is all 1's)\n                memset(voip_conv_sel, -1, sizeof(voip_conv_sel));\n            } else {\n                memset(voip_conv_sel, 0, sizeof(voip_conv_sel));\n\n                while (*conv_arg != 0) {\n                    if (*conv_arg == ',') {\n                        conv_arg++;\n                    }\n                    if (sscanf(conv_arg, \"%u-%u%n\", &min, &max, &len) == 2) {\n                        conv_arg += len;\n                    } else if (sscanf(conv_arg, \"%u%n\", &min, &len) == 1) {\n                        max = min;\n                        conv_arg += len;\n                    } else {\n                        sharkd_json_error(\n                                rpcid, -11014, NULL,\n                                \"sharkd_session_process_tap() voip-convs=%s invalid 'convs' parameter\", tok_tap\n                        );\n                        return;\n                    }\n                    if (min > max || min >= VOIP_CONV_MAX || max >= VOIP_CONV_MAX) {\n                        sharkd_json_error(\n                                rpcid, -11012, NULL,\n                                \"sharkd_session_process_tap() voip-convs=%s invalid 'convs' number range\", tok_tap\n                        );\n                        return;\n                    }\n                    for(; min <= max; min++) {\n                        voip_conv_sel[min / VOIP_CONV_BITS] |= 1 << (min % VOIP_CONV_BITS);\n                    }\n                }\n            }\n\n            voip_stat_init_tapinfo();\n\n            voip_convs_req = (struct sharkd_voip_convs_req *) g_malloc0(sizeof(*voip_convs_req));\n            voip_convs_req->tapinfo = &tapinfo_;\n            voip_convs_req->tap_name = tok_tap;\n\n            tap_error = register_tap_listener(\"frame\", voip_convs_req, tap_filter, 0, NULL, NULL, sharkd_session_process_tap_voip_convs_cb, NULL);\n\n            tapinfo_.session = cfile.epan;\n            voip_calls_init_all_taps(&tapinfo_);\n\n            tap_data = voip_convs_req;\n            tap_free = sharkd_session_free_tap_voip_convs_cb;\n        }\n        else if (!strncmp(tok_tap, \"hosts:\", 6))\n        {\n            bool dump_v4;\n            bool dump_v6;\n            struct sharkd_hosts_req *hosts_req;\n            const char *proto_arg;\n            char **proto_tokens;\n            int proto_count;\n\n            proto_arg = tok_tap + 6;\n\n            if (strlen(proto_arg) == 0) {\n                dump_v4 = true;\n                dump_v6 = true;\n            } else {\n                dump_v4 = false;\n                dump_v6 = false;\n\n                proto_tokens = g_strsplit(proto_arg, \",\", 0);\n                proto_count = 0;\n                while (proto_tokens[proto_count]) {\n                    if (!strcmp(\"ip\", proto_tokens[proto_count]) ||\n                        !strcmp(\"ipv4\", proto_tokens[proto_count])) {\n                        dump_v4 = true;\n                    } else if (!strcmp(\"ipv6\", proto_tokens[proto_count])) {\n                        dump_v6 = true;\n                    } else {\n                        g_strfreev(proto_tokens);\n                        sharkd_json_error(\n                                rpcid, -11015, NULL,\n                                \"sharkd_session_process_tap() hosts=%s invalid 'protos' parameter\", tok_tap\n                        );\n                        return;\n                    }\n                    proto_count++;\n                }\n                g_strfreev(proto_tokens);\n            }\n\n            hosts_req = (struct sharkd_hosts_req *)g_malloc0(sizeof(*hosts_req));\n            hosts_req->dump_v4 = dump_v4;\n            hosts_req->dump_v6 = dump_v6;\n            hosts_req->tap_name = tok_tap;\n\n            tap_error = register_tap_listener(\"frame\", hosts_req, tap_filter, TL_REQUIRES_PROTO_TREE, NULL, NULL, sharkd_session_process_tap_hosts_cb, NULL);\n\n            tap_data = hosts_req;\n            tap_free = sharkd_session_free_tap_hosts_cb;\n        }\n        else\n        {\n            sharkd_json_error(\n                    rpcid, -11012, NULL,\n                    \"sharkd_session_process_tap() %s not recognized\", tok_tap\n                    );\n            return;\n        }\n\n        if (tap_error)\n        {\n            sharkd_json_error(\n                    rpcid, -11013, NULL,\n                    \"sharkd_session_process_tap() name=%s error=%s\", tok_tap, tap_error->str\n                    );\n            g_string_free(tap_error, TRUE);\n            if (tap_free)\n                tap_free(tap_data);\n            return;\n        }\n\n        taps_data[taps_count] = tap_data;\n        taps_free[taps_count] = tap_free;\n        taps_count++;\n    }\n\n    fprintf(stderr, \"sharkd_session_process_tap() count=%d\\n\", taps_count);\n    if (taps_count == 0)\n    {\n        sharkd_json_result_prologue(rpcid);\n        sharkd_json_array_open(\"taps\");\n        sharkd_json_array_close();\n        sharkd_json_result_epilogue();\n        return;\n    }\n\n    sharkd_json_result_prologue(rpcid);\n    sharkd_json_array_open(\"taps\");\n    sharkd_retap();\n    sharkd_json_array_close();\n    sharkd_json_result_epilogue();\n\n    for (i = 0; i < taps_count; i++)\n    {\n        if (taps_data[i])\n            remove_tap_listener(taps_data[i]);\n\n        if (taps_free[i])\n            taps_free[i](taps_data[i]);\n    }\n}\n\n/**\n * sharkd_session_process_follow()\n *\n * Process follow request\n *\n * Input:\n *   (m) follow     - follow protocol request (e.g. HTTP)\n *   (m) filter     - filter request (e.g. tcp.stream == 1)\n *   (m) stream     - stream index number\n *   (o) sub_stream - follow sub-stream index number (e.g. for HTTP/2 and QUIC streams)\n *\n * Output object with attributes:\n *\n *   (m) err    - error code\n *   (m) shost  - server host\n *   (m) sport  - server port\n *   (m) sbytes - server send bytes count\n *   (m) chost  - client host\n *   (m) cport  - client port\n *   (m) cbytes - client send bytes count\n *   (o) payloads - array of object with attributes:\n *                  (o) s - set if server sent, else client\n *                  (m) n - packet number\n *                  (m) d - data base64 encoded\n */\nstatic void\nsharkd_session_process_follow(char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_follow = json_find_attr(buf, tokens, count, \"follow\");\n    const char *tok_filter = json_find_attr(buf, tokens, count, \"filter\");\n    const char *tok_sub_stream = json_find_attr(buf, tokens, count, \"sub_stream\");\n\n    register_follow_t *follower;\n    GString *tap_error;\n\n    follow_info_t *follow_info;\n    const char *host;\n    char *port;\n\n    follower = get_follow_by_name(tok_follow);\n    if (!follower)\n    {\n        sharkd_json_error(\n                rpcid, -12001, NULL,\n                \"sharkd_session_process_follow() follower=%s not found\", tok_follow\n                );\n        return;\n    }\n\n    uint64_t substream_id = SUBSTREAM_UNUSED;\n    if (tok_sub_stream)\n    {\n        ws_strtou64(tok_sub_stream, NULL, &substream_id);\n    }\n\n    /* follow_reset_stream ? */\n    follow_info = g_new0(follow_info_t, 1);\n    follow_info->substream_id = substream_id;\n    /* gui_data, filter_out_filter not set, but not used by dissector */\n\n    tap_error = register_tap_listener(get_follow_tap_string(follower), follow_info, tok_filter, 0, NULL, get_follow_tap_handler(follower), NULL, NULL);\n    if (tap_error)\n    {\n        sharkd_json_error(\n                rpcid, -12002, NULL,\n                \"sharkd_session_process_follow() name=%s error=%s\", tok_follow, tap_error->str\n                );\n        g_string_free(tap_error, TRUE);\n        g_free(follow_info);\n        return;\n    }\n\n    sharkd_retap();\n\n    sharkd_json_result_prologue(rpcid);\n\n    /* Server information: hostname, port, bytes sent */\n    host = address_to_name(&follow_info->server_ip);\n    sharkd_json_value_string(\"shost\", host);\n\n    port = get_follow_port_to_display(follower)(NULL, follow_info->server_port);\n    sharkd_json_value_string(\"sport\", port);\n    wmem_free(NULL, port);\n\n    sharkd_json_value_anyf(\"sbytes\", \"%u\", follow_info->bytes_written[0]);\n\n    /* Client information: hostname, port, bytes sent */\n    host = address_to_name(&follow_info->client_ip);\n    sharkd_json_value_string(\"chost\", host);\n\n    port = get_follow_port_to_display(follower)(NULL, follow_info->client_port);\n    sharkd_json_value_string(\"cport\", port);\n    wmem_free(NULL, port);\n\n    sharkd_json_value_anyf(\"cbytes\", \"%u\", follow_info->bytes_written[1]);\n\n    if (follow_info->payload)\n    {\n        follow_record_t *follow_record;\n        GList *cur;\n\n        sharkd_json_array_open(\"payloads\");\n        for (cur = g_list_last(follow_info->payload); cur; cur = g_list_previous(cur))\n        {\n            follow_record = (follow_record_t *) cur->data;\n\n            json_dumper_begin_object(&dumper);\n\n            sharkd_json_value_anyf(\"n\", \"%u\", follow_record->packet_num);\n            sharkd_json_value_base64(\"d\", follow_record->data->data, follow_record->data->len);\n\n            if (follow_record->is_server)\n                sharkd_json_value_anyf(\"s\", \"%d\", 1);\n\n            json_dumper_end_object(&dumper);\n        }\n        sharkd_json_array_close();\n    }\n\n    sharkd_json_result_epilogue();\n\n    remove_tap_listener(follow_info);\n    follow_info_free(follow_info);\n}\n\nstatic void\nsharkd_session_process_frame_cb_tree(const char *key, epan_dissect_t *edt, proto_tree *tree, tvbuff_t **tvbs, bool display_hidden)\n{\n    proto_node *node;\n\n    sharkd_json_array_open(key);\n    for (node = tree->first_child; node; node = node->next)\n    {\n        field_info *finfo = PNODE_FINFO(node);\n\n        if (!finfo)\n            continue;\n\n        if (!display_hidden && FI_GET_FLAG(finfo, FI_HIDDEN))\n            continue;\n\n        json_dumper_begin_object(&dumper);\n\n        if (!finfo->rep)\n        {\n            char label_str[ITEM_LABEL_LENGTH];\n\n            label_str[0] = '\\0';\n            proto_item_fill_label(finfo, label_str, NULL);\n            sharkd_json_value_string(\"l\", label_str);\n        }\n        else\n        {\n            sharkd_json_value_string(\"l\", finfo->rep->representation);\n        }\n\n        if (finfo->ds_tvb && tvbs && tvbs[0] != finfo->ds_tvb)\n        {\n            int idx;\n\n            for (idx = 1; tvbs[idx]; idx++)\n            {\n                if (tvbs[idx] == finfo->ds_tvb)\n                {\n                    sharkd_json_value_anyf(\"ds\", \"%d\", idx);\n                    break;\n                }\n            }\n        }\n\n        if (finfo->start >= 0 && finfo->length > 0)\n            sharkd_json_value_anyf(\"h\", \"[%d,%d]\", finfo->start, finfo->length);\n\n        if (finfo->appendix_start >= 0 && finfo->appendix_length > 0)\n            sharkd_json_value_anyf(\"i\", \"[%d,%d]\", finfo->appendix_start, finfo->appendix_length);\n\n\n        if (finfo->hfinfo)\n        {\n            char *filter;\n\n            if (finfo->hfinfo->type == FT_PROTOCOL)\n            {\n                sharkd_json_value_string(\"t\", \"proto\");\n            }\n            else if (finfo->hfinfo->type == FT_FRAMENUM)\n            {\n                sharkd_json_value_string(\"t\", \"framenum\");\n                sharkd_json_value_anyf(\"fnum\", \"%u\", fvalue_get_uinteger(finfo->value));\n            }\n            else if (FI_GET_FLAG(finfo, FI_URL) && FT_IS_STRING(finfo->hfinfo->type))\n            {\n                char *url = fvalue_to_string_repr(NULL, finfo->value, FTREPR_DISPLAY, finfo->hfinfo->display);\n\n                sharkd_json_value_string(\"t\", \"url\");\n                sharkd_json_value_string(\"url\", url);\n                wmem_free(NULL, url);\n            }\n\n            filter = proto_construct_match_selected_string(finfo, edt);\n            if (filter)\n            {\n                sharkd_json_value_string(\"f\", filter);\n                wmem_free(NULL, filter);\n            }\n\n            if (finfo->hfinfo->abbrev)\n                    sharkd_json_value_string(\"fn\", finfo->hfinfo->abbrev);\n        }\n\n        if (FI_GET_FLAG(finfo, FI_GENERATED))\n            sharkd_json_value_anyf(\"g\", \"true\");\n\n        if (FI_GET_FLAG(finfo, FI_HIDDEN))\n            sharkd_json_value_anyf(\"v\", \"true\");\n\n        if (FI_GET_FLAG(finfo, PI_SEVERITY_MASK))\n        {\n            const char *severity = try_val_to_str(FI_GET_FLAG(finfo, PI_SEVERITY_MASK), expert_severity_vals);\n\n            ws_assert(severity != NULL);\n\n            sharkd_json_value_string(\"s\", severity);\n        }\n\n        if (((proto_tree *) node)->first_child)\n        {\n            if (finfo->tree_type != -1)\n                sharkd_json_value_anyf(\"e\", \"%d\", finfo->tree_type);\n\n            sharkd_session_process_frame_cb_tree(\"n\", edt, (proto_tree *) node, tvbs, display_hidden);\n        }\n\n        json_dumper_end_object(&dumper);\n    }\n    sharkd_json_array_close();\n}\n\nstatic bool\nsharkd_follower_visit_layers_cb(const void *key _U_, void *value, void *user_data)\n{\n    register_follow_t *follower = (register_follow_t *) value;\n    epan_dissect_t *edt = (epan_dissect_t *) user_data;\n    packet_info *pi = &edt->pi;\n\n    const int proto_id = get_follow_proto_id(follower);\n\n    uint32_t ignore_stream;\n    uint32_t ignore_sub_stream;\n\n    if (proto_is_frame_protocol(pi->layers, proto_get_protocol_filter_name(proto_id)))\n    {\n        const char *layer_proto = proto_get_protocol_short_name(find_protocol_by_id(proto_id));\n        char *follow_filter;\n\n        follow_filter = get_follow_conv_func(follower)(edt, pi, &ignore_stream, &ignore_sub_stream);\n\n        json_dumper_begin_array(&dumper);\n        json_dumper_value_string(&dumper, layer_proto);\n        json_dumper_value_string(&dumper, follow_filter);\n        json_dumper_end_array(&dumper);\n\n        g_free(follow_filter);\n    }\n\n    return false;\n}\n\nstatic bool\nsharkd_followers_visit_layers_cb(const void *key _U_, void *value, void *user_data)\n{\n    register_follow_t *follower = (register_follow_t *) value;\n    epan_dissect_t *edt = (epan_dissect_t *) user_data;\n    packet_info *pi = &edt->pi;\n\n    const int proto_id = get_follow_proto_id(follower);\n\n    unsigned stream;\n    unsigned sub_stream;\n\n    if (proto_is_frame_protocol(pi->layers, proto_get_protocol_filter_name(proto_id)))\n    {\n        const char *layer_proto = proto_get_protocol_short_name(find_protocol_by_id(proto_id));\n        char *follow_filter;\n\n        follow_filter = get_follow_conv_func(follower)(edt, pi, &stream, &sub_stream);\n\n        sharkd_json_object_open(NULL);\n        sharkd_json_value_string(\"protocol\", layer_proto);\n        sharkd_json_value_string(\"filter\", follow_filter);\n        if (get_follow_stream_count_func(follower) != NULL)\n        {\n            sharkd_json_value_anyf(\"stream\", \"%u\", stream);\n        }\n        if (get_follow_sub_stream_id_func(follower) != NULL)\n        {\n            sharkd_json_value_anyf(\"sub_stream\", \"%u\", sub_stream);\n        }\n        sharkd_json_object_close();\n\n        g_free(follow_filter);\n    }\n\n    return false;\n}\n\nstruct sharkd_frame_request_data\n{\n    bool display_hidden;\n};\n\nstatic void\nsharkd_session_process_frame_cb(epan_dissect_t *edt, proto_tree *tree, struct epan_column_info *cinfo, const GSList *data_src, void *data)\n{\n    packet_info *pi = &edt->pi;\n    frame_data *fdata = pi->fd;\n    wtap_block_t pkt_block = NULL;\n\n    const struct sharkd_frame_request_data * const req_data = (const struct sharkd_frame_request_data * const) data;\n    const bool display_hidden = (req_data) ? req_data->display_hidden : false;\n\n    sharkd_json_result_prologue(rpcid);\n\n    if (fdata->has_modified_block)\n        pkt_block = sharkd_get_modified_block(fdata);\n    else\n        pkt_block = pi->rec->block;\n\n    if (pkt_block)\n    {\n        unsigned i;\n        unsigned n;\n        char *comment;\n\n        n = wtap_block_count_option(pkt_block, OPT_COMMENT);\n\n        sharkd_json_array_open(\"comment\");\n        for (i = 0; i < n; i++) {\n            if (WTAP_OPTTYPE_SUCCESS == wtap_block_get_nth_string_option_value(pkt_block, OPT_COMMENT, i, &comment)) {\n                sharkd_json_value_string(NULL, comment);\n            }\n        }\n        sharkd_json_array_close();\n    }\n\n    if (tree)\n    {\n        tvbuff_t **tvbs = NULL;\n\n        /* arrayize data src, to speedup searching for ds_tvb index */\n        if (data_src && data_src->next /* only needed if there are more than one data source */)\n        {\n            unsigned count = g_slist_length((GSList *) data_src);\n            unsigned i;\n\n            tvbs = (tvbuff_t **) g_malloc0((count + 1) * sizeof(*tvbs));\n\n            for (i = 0; i < count; i++)\n            {\n                const struct data_source *src = (const struct data_source *) g_slist_nth_data((GSList *) data_src, i);\n\n                tvbs[i] = get_data_source_tvb(src);\n            }\n\n            tvbs[count] = NULL;\n        }\n\n        sharkd_session_process_frame_cb_tree(\"tree\", edt, tree, tvbs, display_hidden);\n\n        g_free(tvbs);\n    }\n\n    if (cinfo)\n    {\n        int col;\n\n        sharkd_json_array_open(\"col\");\n        for (col = 0; col < cinfo->num_cols; ++col)\n        {\n            sharkd_json_value_string(NULL, get_column_text(cinfo, col));\n        }\n        sharkd_json_array_close();\n    }\n\n    if (fdata->ignored)\n        sharkd_json_value_anyf(\"i\", \"true\");\n\n    if (fdata->marked)\n        sharkd_json_value_anyf(\"m\", \"true\");\n\n    if (fdata->color_filter)\n    {\n        sharkd_json_value_stringf(\"bg\", \"%06x\", color_t_to_rgb(&fdata->color_filter->bg_color));\n        sharkd_json_value_stringf(\"fg\", \"%06x\", color_t_to_rgb(&fdata->color_filter->fg_color));\n    }\n\n    if (data_src)\n    {\n        struct data_source *src = (struct data_source *) data_src->data;\n        bool ds_open = false;\n\n        tvbuff_t *tvb;\n        unsigned length;\n\n        tvb = get_data_source_tvb(src);\n        length = tvb_captured_length(tvb);\n\n        if (length != 0)\n        {\n            const unsigned char *cp = tvb_get_ptr(tvb, 0, length);\n\n            /* XXX pi.fd->encoding */\n            sharkd_json_value_base64(\"bytes\", cp, length);\n        }\n        else\n        {\n            sharkd_json_value_base64(\"bytes\", \"\", 0);\n        }\n\n        data_src = data_src->next;\n        if (data_src)\n        {\n            sharkd_json_array_open(\"ds\");\n            ds_open = true;\n        }\n\n        while (data_src)\n        {\n            src = (struct data_source *) data_src->data;\n\n            json_dumper_begin_object(&dumper);\n\n            {\n                char *src_name = get_data_source_name(src);\n\n                sharkd_json_value_string(\"name\", src_name);\n                wmem_free(NULL, src_name);\n            }\n\n            tvb = get_data_source_tvb(src);\n            length = tvb_captured_length(tvb);\n\n            if (length != 0)\n            {\n                const unsigned char *cp = tvb_get_ptr(tvb, 0, length);\n\n                /* XXX pi.fd->encoding */\n                sharkd_json_value_base64(\"bytes\", cp, length);\n            }\n            else\n            {\n                sharkd_json_value_base64(\"bytes\", \"\", 0);\n            }\n\n            json_dumper_end_object(&dumper);\n\n            data_src = data_src->next;\n        }\n\n        /* close ds, only if was opened */\n        if (ds_open)\n            sharkd_json_array_close();\n    }\n\n    sharkd_json_array_open(\"fol\");\n    follow_iterate_followers(sharkd_follower_visit_layers_cb, edt);\n    sharkd_json_array_close();\n\n    sharkd_json_array_open(\"followers\");\n    follow_iterate_followers(sharkd_followers_visit_layers_cb, edt);\n    sharkd_json_array_close();\n\n    sharkd_json_result_epilogue();\n}\n\n#define SHARKD_IOGRAPH_MAX_ITEMS 1 << 25 /* 33,554,432 limit of items, same as max_io_items_ in ui/qt/io_graph_dialog.h */\n\nstruct sharkd_iograph\n{\n    /* config */\n    int hf_index;\n    io_graph_item_unit_t calc_type;\n    uint32_t interval;\n    bool aot;\n\n    /* result */\n    int space_items;\n    int num_items;\n    io_graph_item_t *items;\n    GString *error;\n};\n\nstatic tap_packet_status\nsharkd_iograph_packet(void *g, packet_info *pinfo, epan_dissect_t *edt, const void *dummy _U_, tap_flags_t flags _U_)\n{\n    struct sharkd_iograph *graph = (struct sharkd_iograph *) g;\n    int idx;\n    bool update_succeeded;\n\n    int64_t tmp_idx = get_io_graph_index(pinfo, graph->interval);\n    if (tmp_idx < 0 || tmp_idx >= SHARKD_IOGRAPH_MAX_ITEMS)\n        return TAP_PACKET_DONT_REDRAW;\n\n    idx = (int)tmp_idx;\n\n    if (idx + 1 > graph->num_items)\n    {\n        if (idx + 1 > graph->space_items)\n        {\n            int new_size = idx + 1024;\n\n            graph->items = (io_graph_item_t *) g_realloc(graph->items, sizeof(io_graph_item_t) * new_size);\n            reset_io_graph_items(&graph->items[graph->space_items], new_size - graph->space_items, graph->hf_index);\n\n            graph->space_items = new_size;\n        }\n        else if (graph->items == NULL)\n        {\n            graph->items = g_new(io_graph_item_t, graph->space_items);\n            reset_io_graph_items(graph->items, graph->space_items, graph->hf_index);\n        }\n\n        graph->num_items = idx + 1;\n    }\n\n    update_succeeded = update_io_graph_item(graph->items, idx, pinfo, edt, graph->hf_index, graph->calc_type, graph->interval);\n    /* XXX - TAP_PACKET_FAILED if the item couldn't be updated, with an error message? */\n    return update_succeeded ? TAP_PACKET_REDRAW : TAP_PACKET_DONT_REDRAW;\n}\n\n/**\n * sharkd_session_process_iograph()\n *\n * Process iograph request\n *\n * Input:\n *   (o) interval           - interval time, if not specified: 1000\n *   (o) interval_units     - units for interval time, must be 's', 'ms' or 'us', if not specified: ms\n *   (m) graph0             - First graph request\n *   (o) graph1...graph9    - Other graph requests\n *   (o) filter0            - First graph filter\n *   (o) filter1...filter9  - Other graph filters\n *\n * Graph requests can be one of: \"packets\", \"bytes\", \"bits\", \"sum:<field>\", \"frames:<field>\", \"max:<field>\", \"min:<field>\", \"avg:<field>\", \"load:<field>\",\n * if you use variant with <field>, you need to pass field name in filter request.\n *\n * Output object with attributes:\n *   (m) iograph - array of graph results with attributes:\n *                  errmsg - graph cannot be constructed\n *                  items  - graph values, zeros are skipped, if value is not a number it's next index encoded as hex string\n */\nstatic void\nsharkd_session_process_iograph(char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_interval = json_find_attr(buf, tokens, count, \"interval\");\n    const char *tok_interval_units = json_find_attr(buf, tokens, count, \"interval_units\");\n    struct sharkd_iograph graphs[10];\n    bool is_any_ok = false;\n    int graph_count;\n\n    int i;\n\n    /* default: 1000ms = one per second */\n    uint32_t interval = 1000;\n    const char *interval_units = \"ms\";\n\n    if (tok_interval)\n        ws_strtou32(tok_interval, NULL, &interval);\n\n    if (tok_interval_units)\n    {\n        if (strcmp(tok_interval_units, \"us\") != 0 &&\n            strcmp(tok_interval_units, \"ms\") != 0 &&\n            strcmp(tok_interval_units, \"s\") != 0)\n        {\n            sharkd_json_error(\n                    rpcid, -7003, NULL,\n                    \"Invalid interval_units parameter: '%s', must be 's', 'ms' or 'us'\", tok_interval_units\n            );\n            return;\n        }\n        interval_units = tok_interval_units;\n    }\n\n    uint32_t interval_us = 0;\n    if (strcmp(interval_units, \"us\") == 0)\n    {\n        interval_us = interval;\n    }\n    else if (strcmp(interval_units, \"ms\") == 0)\n    {\n        interval_us = 1000 * interval;\n    }\n    else if (strcmp(interval_units, \"s\") == 0)\n    {\n        interval_us = 1000000 * interval;\n    }\n\n    for (i = graph_count = 0; i < (int) G_N_ELEMENTS(graphs); i++)\n    {\n        struct sharkd_iograph *graph = &graphs[graph_count];\n\n        const char *tok_graph;\n        const char *tok_filter;\n        char tok_format_buf[32];\n        const char *field_name;\n        const char *tok_aot;\n\n        snprintf(tok_format_buf, sizeof(tok_format_buf), \"graph%d\", i);\n        tok_graph = json_find_attr(buf, tokens, count, tok_format_buf);\n        if (!tok_graph)\n            break;\n\n        snprintf(tok_format_buf, sizeof(tok_format_buf), \"filter%d\", i);\n        tok_filter = json_find_attr(buf, tokens, count, tok_format_buf);\n\n        if (!strcmp(tok_graph, \"packets\"))\n            graph->calc_type = IOG_ITEM_UNIT_PACKETS;\n        else if (!strcmp(tok_graph, \"bytes\"))\n            graph->calc_type = IOG_ITEM_UNIT_BYTES;\n        else if (!strcmp(tok_graph, \"bits\"))\n            graph->calc_type = IOG_ITEM_UNIT_BITS;\n        else if (g_str_has_prefix(tok_graph, \"sum:\"))\n            graph->calc_type = IOG_ITEM_UNIT_CALC_SUM;\n        else if (g_str_has_prefix(tok_graph, \"frames:\"))\n            graph->calc_type = IOG_ITEM_UNIT_CALC_FRAMES;\n        else if (g_str_has_prefix(tok_graph, \"fields:\"))\n            graph->calc_type = IOG_ITEM_UNIT_CALC_FIELDS;\n        else if (g_str_has_prefix(tok_graph, \"max:\"))\n            graph->calc_type = IOG_ITEM_UNIT_CALC_MAX;\n        else if (g_str_has_prefix(tok_graph, \"min:\"))\n            graph->calc_type = IOG_ITEM_UNIT_CALC_MIN;\n        else if (g_str_has_prefix(tok_graph, \"avg:\"))\n            graph->calc_type = IOG_ITEM_UNIT_CALC_AVERAGE;\n        else if (g_str_has_prefix(tok_graph, \"load:\"))\n            graph->calc_type = IOG_ITEM_UNIT_CALC_LOAD;\n        else if (g_str_has_prefix(tok_graph, \"throughput:\"))\n            graph->calc_type = IOG_ITEM_UNIT_CALC_THROUGHPUT;\n        else\n            break;\n\n        field_name = strchr(tok_graph, ':');\n        if (field_name)\n            field_name = field_name + 1;\n\n        /* io_graph_item now supports microseconds (and this parameter\n         * is expected to be in microseconds.) */\n        graph->interval = interval_us;\n\n        graph->hf_index = -1;\n        graph->error = check_field_unit(field_name, &graph->hf_index, graph->calc_type);\n\n        graph->space_items = 0; /* TODO, can avoid realloc()s in sharkd_iograph_packet() by calculating: capture_time / interval */\n        graph->num_items = 0;\n        graph->items = NULL;\n\n        snprintf(tok_format_buf, sizeof(tok_format_buf), \"aot%d\", i);\n        tok_aot = json_find_attr(buf, tokens, count, tok_format_buf);\n        if (tok_aot!=NULL) {\n            graph->aot = (!strcmp(tok_aot, \"true\")) ? true : false;\n        }\n        else {\n            graph->aot = false;\n        }\n\n        if (!graph->error)\n            graph->error = register_tap_listener(\"frame\", graph, tok_filter, TL_REQUIRES_PROTO_TREE, NULL, sharkd_iograph_packet, NULL, NULL);\n\n        graph_count++;\n\n        if (graph->error)\n        {\n            sharkd_json_error(\n                    rpcid, -6001, NULL,\n                    \"%s\", graph->error->str\n                    );\n            g_string_free(graph->error, TRUE);\n            return;\n        }\n\n        if (graph->error == NULL)\n            is_any_ok = true;\n    }\n\n    /* retap only if we have at least one ok */\n    if (is_any_ok)\n        sharkd_retap();\n\n    sharkd_json_result_prologue(rpcid);\n\n    sharkd_json_array_open(\"iograph\");\n    for (i = 0; i < graph_count; i++)\n    {\n        struct sharkd_iograph *graph = &graphs[i];\n\n        json_dumper_begin_object(&dumper);\n\n        if (graph->error)\n        {\n            fprintf(stderr, \"SNAP 6002 - we should never get to here.\\n\");\n            g_string_free(graph->error, TRUE);\n            exit(-1);\n        }\n        else\n        {\n            int idx;\n            int next_idx = 0;\n\n            sharkd_json_array_open(\"items\");\n            for (idx = 0; idx < graph->num_items; idx++)\n            {\n                double val;\n\n                val = get_io_graph_item(graph->items, graph->calc_type, idx, graph->hf_index, &cfile, graph->interval, graph->num_items, graph->aot);\n\n                /* if it's zero, don't display */\n                if (val == 0.0)\n                    continue;\n\n                /* cause zeros are not printed, need to output index */\n                if (next_idx != idx)\n                    sharkd_json_value_stringf(NULL, \"%x\", idx);\n\n                sharkd_json_value_anyf(NULL, \"%f\", val);\n                next_idx = idx + 1;\n            }\n            sharkd_json_array_close();\n        }\n        json_dumper_end_object(&dumper);\n\n        remove_tap_listener(graph);\n        g_free(graph->items);\n    }\n    sharkd_json_array_close();\n\n    sharkd_json_result_epilogue();\n}\n\n/**\n * sharkd_session_process_intervals()\n *\n * Process intervals request - generate basic capture file statistics per requested interval.\n *\n * Input:\n *   (o) interval - interval time in ms, if not specified: 1000ms\n *   (o) filter   - filter for generating interval request\n *\n * Output object with attributes:\n *   (m) intervals - array of intervals, with indexes:\n *             [0] - index of interval,\n *             [1] - number of frames during interval,\n *             [2] - number of bytes during interval.\n *\n *   (m) last   - last interval number.\n *   (m) frames - total number of frames\n *   (m) bytes  - total number of bytes\n *\n * NOTE: If frames are not in order, there might be items with same interval index, or even negative one.\n */\nstatic void\nsharkd_session_process_intervals(char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_interval = json_find_attr(buf, tokens, count, \"interval\");\n    const char *tok_filter = json_find_attr(buf, tokens, count, \"filter\");\n\n    const uint8_t *filter_data = NULL;\n\n    struct\n    {\n        unsigned int frames;\n        uint64_t bytes;\n    } st, st_total;\n\n    nstime_t *start_ts;\n\n    uint32_t interval_ms = 1000; /* default: one per second */\n\n    int64_t idx;\n    int64_t max_idx = 0;\n\n    if (tok_interval)\n        ws_strtou32(tok_interval, NULL, &interval_ms);  // already validated\n\n    if (tok_filter)\n    {\n        const struct sharkd_filter_item *filter_item;\n\n        filter_item = sharkd_session_filter_data(tok_filter);\n        if (!filter_item)\n        {\n            sharkd_json_error(\n                    rpcid, -7001, NULL,\n                    \"Invalid filter parameter: %s\", tok_filter\n                    );\n            return;\n        }\n        filter_data = filter_item->filtered;\n    }\n\n    st_total.frames = 0;\n    st_total.bytes  = 0;\n\n    st.frames = 0;\n    st.bytes  = 0;\n\n    idx = 0;\n\n    sharkd_json_result_prologue(rpcid);\n    sharkd_json_array_open(\"intervals\");\n\n    start_ts = (cfile.count >= 1) ? &(sharkd_get_frame(1)->abs_ts) : NULL;\n\n    for (uint32_t framenum = 1; framenum <= cfile.count; framenum++)\n    {\n        frame_data *fdata;\n        int64_t msec_rel;\n        int64_t new_idx;\n\n        if (filter_data && !(filter_data[framenum / 8] & (1 << (framenum % 8))))\n            continue;\n\n        fdata = sharkd_get_frame(framenum);\n\n        msec_rel = (fdata->abs_ts.secs - start_ts->secs) * (int64_t) 1000 + (fdata->abs_ts.nsecs - start_ts->nsecs) / 1000000;\n        new_idx  = msec_rel / interval_ms;\n\n        if (idx != new_idx)\n        {\n            if (st.frames != 0)\n            {\n                sharkd_json_value_anyf(NULL, \"[%\" PRId64 \",%u,%\" PRIu64 \"]\", idx, st.frames, st.bytes);\n            }\n\n            idx = new_idx;\n            if (idx > max_idx)\n                max_idx = idx;\n\n            st.frames = 0;\n            st.bytes  = 0;\n        }\n\n        st.frames += 1;\n        st.bytes  += fdata->pkt_len;\n\n        st_total.frames += 1;\n        st_total.bytes  += fdata->pkt_len;\n    }\n\n    if (st.frames != 0)\n    {\n        sharkd_json_value_anyf(NULL, \"[%\" PRId64 \",%u,%\" PRIu64 \"]\", idx, st.frames, st.bytes);\n    }\n    sharkd_json_array_close();\n\n    sharkd_json_value_anyf(\"last\", \"%\" PRId64, max_idx);\n    sharkd_json_value_anyf(\"frames\", \"%u\", st_total.frames);\n    sharkd_json_value_anyf(\"bytes\", \"%\" PRIu64, st_total.bytes);\n\n    sharkd_json_result_epilogue();\n}\n\n/**\n * sharkd_session_process_frame()\n *\n * Process frame request\n *\n * Input:\n *   (m) frame - requested frame number\n *   (o) ref_frame - time reference frame number\n *   (o) prev_frame - previously displayed frame number\n *   (o) proto - set if output frame tree\n *   (o) columns - set if output frame columns\n *   (o) color - set if output color-filter bg/fg\n *   (o) bytes - set if output frame bytes\n *   (o) hidden - set if output hidden tree fields\n *\n * Output object with attributes:\n *   (m) err   - 0 if succeed\n *   (o) tree  - array of frame nodes with attributes:\n *                  l - label\n *                  t: 'proto', 'framenum', 'url' - type of node\n *                  f - filter string\n *                  fn - field name\n *                  s - severity\n *                  e - subtree ett index\n *                  n - array of subtree nodes\n *                  h - two item array: (item start, item length)\n *                  i - two item array: (appendix start, appendix length)\n *                  p - [RESERVED] two item array: (protocol start, protocol length)\n *                  ds- data src index\n *                  url  - only for t:'url', url\n *                  fnum - only for t:'framenum', frame number\n *                  g - if field is generated by Wireshark\n *                  v - if field is hidden\n *\n *   (o) col   - array of column data\n *   (o) bytes - base64 of frame bytes\n *   (o) ds    - array of other data srcs\n *   (o) comment - frame comment\n *   (o) fol   - array of follow filters:\n *                  [0] - protocol\n *                  [1] - filter string\n *   (o) followers - array of followers with attributes:\n *                      protocol - protocol string\n *                      filter - filter string\n *                      stream - stream index number\n *                      sub_stream - sub-stream index number (optional, e.g. for HTTP/2 and QUIC streams)\n *   (o) i   - if frame is ignored\n *   (o) m   - if frame is marked\n *   (o) bg  - color filter - background color in hex\n *   (o) fg  - color filter - foreground color in hex\n */\nstatic void\nsharkd_session_process_frame(char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_frame = json_find_attr(buf, tokens, count, \"frame\");\n    const char *tok_ref_frame = json_find_attr(buf, tokens, count, \"ref_frame\");\n    const char *tok_prev_frame = json_find_attr(buf, tokens, count, \"prev_frame\");\n    column_info *cinfo = NULL;\n\n    uint32_t framenum, ref_frame_num, prev_dis_num;\n    uint32_t dissect_flags = SHARKD_DISSECT_FLAG_NULL;\n    struct sharkd_frame_request_data req_data;\n    wtap_rec rec; /* Record information */\n    enum dissect_request_status status;\n    int err;\n    char *err_info;\n\n    ws_strtou32(tok_frame, NULL, &framenum);  // we have already validated this\n\n    ref_frame_num = (framenum != 1) ? 1 : 0;\n    if (tok_ref_frame)\n    {\n        ws_strtou32(tok_ref_frame, NULL, &ref_frame_num);\n        if (ref_frame_num > framenum)\n        {\n            sharkd_json_error(\n                    rpcid, -8001, NULL,\n                    \"Invalid ref_frame - The ref_frame occurs after the frame specified\"\n                    );\n            return;\n        }\n    }\n\n    prev_dis_num = framenum - 1;\n    if (tok_prev_frame)\n    {\n        ws_strtou32(tok_prev_frame, NULL, &prev_dis_num);\n        if (prev_dis_num >= framenum)\n        {\n            sharkd_json_error(\n                    rpcid, -8002, NULL,\n                    \"Invalid prev_frame - The prev_frame occurs on or after the frame specified\"\n                    );\n            return;\n        }\n    }\n\n    if (json_find_attr(buf, tokens, count, \"proto\") != NULL)\n        dissect_flags |= SHARKD_DISSECT_FLAG_PROTO_TREE;\n    if (json_find_attr(buf, tokens, count, \"bytes\") != NULL)\n        dissect_flags |= SHARKD_DISSECT_FLAG_BYTES;\n    if (json_find_attr(buf, tokens, count, \"columns\") != NULL) {\n        dissect_flags |= SHARKD_DISSECT_FLAG_COLUMNS;\n        cinfo = &cfile.cinfo;\n    }\n    if (json_find_attr(buf, tokens, count, \"color\") != NULL)\n        dissect_flags |= SHARKD_DISSECT_FLAG_COLOR;\n\n    req_data.display_hidden = (json_find_attr(buf, tokens, count, \"v\") != NULL);\n\n    wtap_rec_init(&rec, 1514);\n\n    status = sharkd_dissect_request(framenum, ref_frame_num, prev_dis_num,\n            &rec, cinfo, dissect_flags,\n            &sharkd_session_process_frame_cb, &req_data, &err, &err_info);\n    switch (status) {\n\n        case DISSECT_REQUEST_SUCCESS:\n            /* success */\n            break;\n\n        case DISSECT_REQUEST_NO_SUCH_FRAME:\n            sharkd_json_error(\n                    rpcid, -8003, NULL,\n                    \"Invalid frame - The frame number requested is out of range\"\n                    );\n            break;\n\n        case DISSECT_REQUEST_READ_ERROR:\n            sharkd_json_error(\n                    rpcid, -8003, NULL,\n                    /* XXX - show the error details */\n                    \"Read error - The frame could not be read from the file\"\n                    );\n            g_free(err_info);\n            break;\n    }\n\n    wtap_rec_cleanup(&rec);\n}\n\n/**\n * sharkd_session_process_check()\n *\n * Process check request.\n *\n * Input:\n *   (o) filter - filter to be checked\n *   (o) field - field to be checked\n *\n * Output object with attributes:\n *   (m) err - always 0\n *   (o) filter - 'ok', 'warn' or error message\n *   (o) field - 'ok', or 'notfound'\n */\nstatic int\nsharkd_session_process_check(char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_filter = json_find_attr(buf, tokens, count, \"filter\");\n    const char *tok_field = json_find_attr(buf, tokens, count, \"field\");\n\n    if (tok_filter != NULL)\n    {\n        dfilter_t *dfp;\n        df_error_t *df_err = NULL;\n\n        if (dfilter_compile(tok_filter, &dfp, &df_err))\n        {\n            if (dfp && dfilter_deprecated_tokens(dfp))\n                sharkd_json_warning(rpcid, \"Filter contains deprecated tokens\");\n            else\n                sharkd_json_simple_ok(rpcid);\n\n            dfilter_free(dfp);\n            df_error_free(&df_err);\n            return 0;\n        }\n        else\n        {\n            sharkd_json_error(\n                    rpcid, -5001, NULL,\n                    \"Filter invalid - %s\", df_err->msg\n                    );\n            df_error_free(&df_err);\n            return -5001;\n        }\n    }\n\n    if (tok_field != NULL)\n    {\n        header_field_info *hfi = proto_registrar_get_byname(tok_field);\n\n        if (!hfi)\n        {\n            sharkd_json_error(\n                    rpcid, -5002, NULL,\n                    \"Field %s not found\", tok_field\n                    );\n            return -5002;\n        }\n        else\n        {\n            sharkd_json_simple_ok(rpcid);\n            return 0;\n        }\n    }\n\n    sharkd_json_simple_ok(rpcid);\n    return 0;\n}\n\nstruct sharkd_session_process_complete_pref_data\n{\n    const char *module;\n    const char *pref;\n};\n\nstatic unsigned\nsharkd_session_process_complete_pref_cb(module_t *module, void *d)\n{\n    struct sharkd_session_process_complete_pref_data *data = (struct sharkd_session_process_complete_pref_data *) d;\n\n    if (strncmp(data->pref, module->name, strlen(data->pref)) != 0)\n        return 0;\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_string(\"f\", module->name);\n    sharkd_json_value_string(\"d\", module->title);\n    json_dumper_end_object(&dumper);\n\n    return 0;\n}\n\nstatic unsigned\nsharkd_session_process_complete_pref_option_cb(pref_t *pref, void *d)\n{\n    struct sharkd_session_process_complete_pref_data *data = (struct sharkd_session_process_complete_pref_data *) d;\n    const char *pref_name = prefs_get_name(pref);\n    const char *pref_title = prefs_get_title(pref);\n\n    if (strncmp(data->pref, pref_name, strlen(data->pref)) != 0)\n        return 0;\n\n    json_dumper_begin_object(&dumper);\n    sharkd_json_value_stringf(\"f\", \"%s.%s\", data->module, pref_name);\n    sharkd_json_value_string(\"d\", pref_title);\n    json_dumper_end_object(&dumper);\n\n    return 0; /* continue */\n}\n\n/**\n * sharkd_session_process_complete()\n *\n * Process complete request\n *\n * Input:\n *   (o) field - field to be completed\n *   (o) pref  - preference to be completed\n *\n * Output object with attributes:\n *   (m) err - always 0\n *   (o) field - array of object with attributes:\n *                  (m) f - field text\n *                  (o) t - field type (FT_ number)\n *                  (o) n - field name\n *   (o) pref  - array of object with attributes:\n *                  (m) f - pref name\n *                  (o) d - pref description\n */\nstatic int\nsharkd_session_process_complete(char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_field = json_find_attr(buf, tokens, count, \"field\");\n    const char *tok_pref  = json_find_attr(buf, tokens, count, \"pref\");\n\n    sharkd_json_result_prologue(rpcid);\n\n    if (tok_field != NULL && tok_field[0])\n    {\n        const size_t filter_length = strlen(tok_field);\n        const int filter_with_dot = !!strchr(tok_field, '.');\n\n        void *proto_cookie;\n        void *field_cookie;\n        int proto_id;\n\n        sharkd_json_array_open(\"field\");\n\n        for (proto_id = proto_get_first_protocol(&proto_cookie); proto_id != -1; proto_id = proto_get_next_protocol(&proto_cookie))\n        {\n            protocol_t *protocol = find_protocol_by_id(proto_id);\n            const char *protocol_filter;\n            const char *protocol_name;\n            header_field_info *hfinfo;\n\n            if (!proto_is_protocol_enabled(protocol))\n                continue;\n\n            protocol_name   = proto_get_protocol_long_name(protocol);\n            protocol_filter = proto_get_protocol_filter_name(proto_id);\n\n            if (strlen(protocol_filter) >= filter_length && !g_ascii_strncasecmp(tok_field, protocol_filter, filter_length))\n            {\n                json_dumper_begin_object(&dumper);\n                {\n                    sharkd_json_value_string(\"f\", protocol_filter);\n                    sharkd_json_value_anyf(\"t\", \"%d\", FT_PROTOCOL);\n                    sharkd_json_value_string(\"n\", protocol_name);\n                }\n                json_dumper_end_object(&dumper);\n            }\n\n            if (!filter_with_dot)\n                continue;\n\n            for (hfinfo = proto_get_first_protocol_field(proto_id, &field_cookie); hfinfo != NULL; hfinfo = proto_get_next_protocol_field(proto_id, &field_cookie))\n            {\n                if (hfinfo->same_name_prev_id != -1) /* ignore duplicate names */\n                    continue;\n\n                if (strlen(hfinfo->abbrev) >= filter_length && !g_ascii_strncasecmp(tok_field, hfinfo->abbrev, filter_length))\n                {\n                    json_dumper_begin_object(&dumper);\n                    {\n                        sharkd_json_value_string(\"f\", hfinfo->abbrev);\n\n                        /* XXX, skip displaying name, if there are multiple (to not confuse user) */\n                        if (hfinfo->same_name_next == NULL)\n                        {\n                            sharkd_json_value_anyf(\"t\", \"%d\", hfinfo->type);\n                            sharkd_json_value_string(\"n\", hfinfo->name);\n                        }\n                    }\n                    json_dumper_end_object(&dumper);\n                }\n            }\n        }\n\n        sharkd_json_array_close();\n    }\n\n    if (tok_pref != NULL && tok_pref[0])\n    {\n        struct sharkd_session_process_complete_pref_data data;\n        char *dot_sepa;\n\n        data.module = tok_pref;\n        data.pref = tok_pref;\n\n        sharkd_json_array_open(\"pref\");\n        if ((dot_sepa = strchr(tok_pref, '.')))\n        {\n            module_t *pref_mod;\n\n            *dot_sepa = '\\0'; /* XXX, C abuse: discarding-const */\n            data.pref = dot_sepa + 1;\n\n            pref_mod = prefs_find_module(data.module);\n            if (pref_mod)\n                prefs_pref_foreach(pref_mod, sharkd_session_process_complete_pref_option_cb, &data);\n\n            *dot_sepa = '.';\n        }\n        else\n        {\n            prefs_modules_foreach(sharkd_session_process_complete_pref_cb, &data);\n        }\n        sharkd_json_array_close();\n    }\n\n    sharkd_json_result_epilogue();\n\n    return 0;\n}\n\n/**\n * sharkd_session_process_setcomment()\n *\n * Process setcomment request\n *\n * Input:\n *   (m) frame - frame number\n *   (o) comment - user comment\n *\n * Output object with attributes:\n *   (m) err   - error code: 0 succeed\n *\n * Note:\n *   For now, adds comments, doesn't remove or replace them.\n */\nstatic void\nsharkd_session_process_setcomment(char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_frame   = json_find_attr(buf, tokens, count, \"frame\");\n    const char *tok_comment = json_find_attr(buf, tokens, count, \"comment\");\n\n    uint32_t framenum;\n    frame_data *fdata;\n    wtap_opttype_return_val ret;\n    wtap_block_t pkt_block = NULL;\n\n    if (!tok_frame || !ws_strtou32(tok_frame, NULL, &framenum) || framenum == 0)\n    {\n        sharkd_json_error(\n                rpcid, -3001, NULL,\n                \"Frame number must be a positive integer\"\n                );\n        return;\n    }\n\n    fdata = sharkd_get_frame(framenum);  // BUG HERE - If no file loaded you get a crash\n    if (!fdata)\n    {\n        sharkd_json_error(\n                rpcid, -3002, NULL,\n                \"Frame number is out of range\"\n                );\n        return;\n    }\n\n    pkt_block = sharkd_get_packet_block(fdata);\n\n    ret = wtap_block_add_string_option(pkt_block, OPT_COMMENT, tok_comment, strlen(tok_comment));\n\n    if (ret != WTAP_OPTTYPE_SUCCESS)\n    {\n        sharkd_json_error(\n                rpcid, -3003, NULL,\n                \"Unable to set the comment\"\n                );\n    }\n    else\n    {\n        sharkd_set_modified_block(fdata, pkt_block);\n        sharkd_json_simple_ok(rpcid);\n    }\n}\n\n/**\n * sharkd_session_process_setconf()\n *\n * Process setconf request\n *\n * Input:\n *   (m) name  - preference name\n *   (m) value - preference value\n *\n * Output object with attributes:\n *   (m) err   - error code: 0 succeed\n */\nstatic void\nsharkd_session_process_setconf(char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_name = json_find_attr(buf, tokens, count, \"name\");\n    const char *tok_value = json_find_attr(buf, tokens, count, \"value\");\n    char pref[4096];\n    char *errmsg = NULL;\n\n    prefs_set_pref_e ret;\n\n    if (!tok_name || tok_name[0] == '\\0')\n    {\n        sharkd_json_error(\n                rpcid, -4001, NULL,\n                \"Preference name missing\"\n                );\n        return;\n    }\n\n    if (!tok_value)\n    {\n        sharkd_json_error(\n                rpcid, -4002, NULL,\n                \"Preference value missing\"\n                );\n        return;\n    }\n\n    snprintf(pref, sizeof(pref), \"%s:%s\", tok_name, tok_value);\n\n    ret = prefs_set_pref(pref, &errmsg);\n\n    switch (ret)\n    {\n        case PREFS_SET_OK:\n            sharkd_json_simple_ok(rpcid);\n            break;\n\n        case PREFS_SET_OBSOLETE:\n            sharkd_json_error(\n                    rpcid, -4003, NULL,\n                    \"The preference specified is obsolete\"\n                    );\n            break;\n\n        case PREFS_SET_NO_SUCH_PREF:\n            sharkd_json_error(\n                    rpcid, -4004, NULL,\n                    \"No such preference exists\"\n                    );\n            break;\n\n        default:\n            sharkd_json_error(\n                    rpcid, -4005, NULL,\n                    \"Unable to set the preference%s%s\",\n                    errmsg ? \": \" : \"\", errmsg ? errmsg : \"\"\n                    );\n    }\n\n    g_free(errmsg);\n}\n\nstruct sharkd_session_process_dumpconf_data\n{\n    module_t *module;\n};\n\nstatic unsigned\nsharkd_session_process_dumpconf_cb(pref_t *pref, void *d)\n{\n    struct sharkd_session_process_dumpconf_data *data = (struct sharkd_session_process_dumpconf_data *) d;\n    const char *pref_name = prefs_get_name(pref);\n\n    char json_pref_key[512];\n\n    snprintf(json_pref_key, sizeof(json_pref_key), \"%s.%s\", data->module->name, pref_name);\n    sharkd_json_object_open(json_pref_key);\n\n    switch (prefs_get_type(pref))\n    {\n        case PREF_UINT:\n            sharkd_json_value_anyf(\"u\", \"%u\", prefs_get_uint_value(pref, pref_current));\n            if (prefs_get_uint_base(pref) != 10)\n                sharkd_json_value_anyf(\"ub\", \"%u\", prefs_get_uint_base(pref));\n            break;\n\n        case PREF_BOOL:\n            sharkd_json_value_anyf(\"b\", prefs_get_bool_value(pref, pref_current) ? \"1\" : \"0\");\n            break;\n\n        case PREF_STRING:\n        case PREF_SAVE_FILENAME:\n        case PREF_OPEN_FILENAME:\n        case PREF_DIRNAME:\n        case PREF_PASSWORD:\n        case PREF_DISSECTOR:\n            sharkd_json_value_string(\"s\", prefs_get_string_value(pref, pref_current));\n            break;\n\n        case PREF_ENUM:\n            {\n                const enum_val_t *enums;\n\n                sharkd_json_array_open(\"e\");\n                for (enums = prefs_get_enumvals(pref); enums->name; enums++)\n                {\n                    json_dumper_begin_object(&dumper);\n\n                    sharkd_json_value_anyf(\"v\", \"%d\", enums->value);\n\n                    if (enums->value == prefs_get_enum_value(pref, pref_current))\n                        sharkd_json_value_anyf(\"s\", \"1\");\n\n                    sharkd_json_value_string(\"d\", enums->description);\n\n                    json_dumper_end_object(&dumper);\n                }\n                sharkd_json_array_close();\n                break;\n            }\n\n        case PREF_RANGE:\n        case PREF_DECODE_AS_RANGE:\n            {\n                char *range_str = range_convert_range(NULL, prefs_get_range_value_real(pref, pref_current));\n                sharkd_json_value_string(\"r\", range_str);\n                wmem_free(NULL, range_str);\n                break;\n            }\n\n        case PREF_UAT:\n            {\n                uat_t *uat = prefs_get_uat_value(pref);\n                unsigned idx;\n\n                sharkd_json_array_open(\"t\");\n                for (idx = 0; idx < uat->raw_data->len; idx++)\n                {\n                    void *rec = UAT_INDEX_PTR(uat, idx);\n                    unsigned colnum;\n\n                    sharkd_json_array_open(NULL);\n                    for (colnum = 0; colnum < uat->ncols; colnum++)\n                    {\n                        char *str = uat_fld_tostr(rec, &(uat->fields[colnum]));\n\n                        sharkd_json_value_string(NULL, str);\n                        g_free(str);\n                    }\n\n                    sharkd_json_array_close();\n                }\n\n                sharkd_json_array_close();\n                break;\n            }\n\n        case PREF_COLOR:\n        case PREF_CUSTOM:\n        case PREF_STATIC_TEXT:\n        case PREF_OBSOLETE:\n            /* TODO */\n            break;\n    }\n\n#if 0\n    sharkd_json_value_string(\"t\", prefs_get_title(pref));\n#endif\n\n    sharkd_json_object_close();\n\n    return 0; /* continue */\n}\n\nstatic unsigned\nsharkd_session_process_dumpconf_mod_cb(module_t *module, void *d)\n{\n    struct sharkd_session_process_dumpconf_data *data = (struct sharkd_session_process_dumpconf_data *) d;\n\n    data->module = module;\n    prefs_pref_foreach(module, sharkd_session_process_dumpconf_cb, data);\n\n    return 0;\n}\n\n/**\n * sharkd_session_process_dumpconf()\n *\n * Process dumpconf request\n *\n * Input:\n *   (o) pref - module, or preference, NULL for all\n *\n * Output object with attributes:\n *   (o) prefs   - object with module preferences\n *                  (m) [KEY] - preference name\n *                  (o) u - preference value (for PREF_UINT)\n *                  (o) ub - preference value suggested base for display (for PREF_UINT) and if different than 10\n *                  (o) b - preference value (only for PREF_BOOL) (1 true, 0 false)\n *                  (o) s - preference value (for PREF_STRING, PREF_SAVE_FILENAME, PREF_OPEN_FILENAME, PREF_DIRNAME, PREF_PASSWORD, PREF_DISSECTOR)\n *                  (o) e - preference possible values (only for PREF_ENUM)\n *                  (o) r - preference value (for PREF_RANGE, PREF_DECODE_AS_RANGE)\n *                  (o) t - preference value (only for PREF_UAT)\n */\nstatic void\nsharkd_session_process_dumpconf(char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_pref = json_find_attr(buf, tokens, count, \"pref\");\n    module_t *pref_mod;\n    char *dot_sepa;\n\n    if (!tok_pref)\n    {\n        struct sharkd_session_process_dumpconf_data data;\n\n        data.module = NULL;\n\n        sharkd_json_result_prologue(rpcid);\n\n        sharkd_json_object_open(\"prefs\");\n        prefs_modules_foreach(sharkd_session_process_dumpconf_mod_cb, &data);\n        sharkd_json_object_close();\n\n        sharkd_json_result_epilogue();\n        return;\n    }\n\n    if ((dot_sepa = strchr(tok_pref, '.')))\n    {\n        pref_t *pref = NULL;\n\n        *dot_sepa = '\\0'; /* XXX, C abuse: discarding-const */\n        pref_mod = prefs_find_module(tok_pref);\n        if (pref_mod)\n            pref = prefs_find_preference(pref_mod, dot_sepa + 1);\n        *dot_sepa = '.';\n\n        if (pref)\n        {\n            struct sharkd_session_process_dumpconf_data data;\n\n            data.module = pref_mod;\n\n            sharkd_json_result_prologue(rpcid);\n\n            sharkd_json_object_open(\"prefs\");\n            sharkd_session_process_dumpconf_cb(pref, &data);\n            sharkd_json_object_close();\n\n            sharkd_json_result_epilogue();\n            return;\n        }\n        else\n        {\n            sharkd_json_error(\n                    rpcid, -9001, NULL,\n                    \"Invalid pref %s.\", tok_pref\n                    );\n            return;\n        }\n\n    }\n\n    pref_mod = prefs_find_module(tok_pref);\n    if (pref_mod)\n    {\n        struct sharkd_session_process_dumpconf_data data;\n\n        data.module = pref_mod;\n\n        sharkd_json_result_prologue(rpcid);\n\n        sharkd_json_object_open(\"prefs\");\n        prefs_pref_foreach(pref_mod, sharkd_session_process_dumpconf_cb, &data);\n        sharkd_json_object_close();\n\n        sharkd_json_result_epilogue();\n    }\n    else\n    {\n        sharkd_json_error(\n                rpcid, -9002, NULL,\n                \"Invalid pref %s.\", tok_pref\n                );\n    }\n}\n\nstruct sharkd_download_rtp\n{\n    rtpstream_id_t id;\n    GSList *packets;\n    double start_time;\n};\n\nstatic void\nsharkd_rtp_download_free_items(void *ptr)\n{\n    rtp_packet_t *rtp_packet = (rtp_packet_t *) ptr;\n\n    g_free(rtp_packet->info);\n    g_free(rtp_packet->payload_data);\n    g_free(rtp_packet);\n}\n\nstatic void\nsharkd_rtp_download_decode(struct sharkd_download_rtp *req)\n{\n    /* based on RtpAudioStream::decode() 6e29d874f8b5e6ebc59f661a0bb0dab8e56f122a */\n    /* TODO, for now only without silence (timing_mode_ = Uninterrupted) */\n\n    static const int sample_bytes_ = sizeof(SAMPLE) / sizeof(char);\n\n    uint32_t audio_out_rate_ = 0;\n    struct _GHashTable *decoders_hash_ = rtp_decoder_hash_table_new();\n    struct SpeexResamplerState_ *audio_resampler_ = NULL;\n\n    size_t resample_buff_len = 0x1000;\n    SAMPLE *resample_buff = (SAMPLE *) g_malloc(resample_buff_len);\n    spx_uint32_t cur_in_rate = 0;\n    char *write_buff = NULL;\n    size_t write_bytes = 0;\n    unsigned channels = 0;\n    unsigned sample_rate = 0;\n\n    GSList *l;\n\n    for (l = req->packets; l; l = l->next)\n    {\n        rtp_packet_t *rtp_packet = (rtp_packet_t *) l->data;\n\n        SAMPLE *decode_buff = NULL;\n        size_t decoded_bytes;\n\n        decoded_bytes = decode_rtp_packet(rtp_packet, &decode_buff, decoders_hash_, &channels, &sample_rate);\n        if (decoded_bytes == 0 || sample_rate == 0)\n        {\n            /* We didn't decode anything. Clean up and prep for the next packet. */\n            g_free(decode_buff);\n            continue;\n        }\n\n        if (audio_out_rate_ == 0)\n        {\n            uint32_t tmp32;\n            uint16_t tmp16;\n            char wav_hdr[44];\n\n            /* First non-zero wins */\n            audio_out_rate_ = sample_rate;\n\n            RTP_STREAM_DEBUG(\"Audio sample rate is %u\", audio_out_rate_);\n\n            /* write WAVE header */\n            memset(&wav_hdr, 0, sizeof(wav_hdr));\n            memcpy(&wav_hdr[0], \"RIFF\", 4);\n            memcpy(&wav_hdr[4], \"\\xFF\\xFF\\xFF\\xFF\", 4); /* XXX, unknown */\n            memcpy(&wav_hdr[8], \"WAVE\", 4);\n\n            memcpy(&wav_hdr[12], \"fmt \", 4);\n            memcpy(&wav_hdr[16], \"\\x10\\x00\\x00\\x00\", 4); /* PCM */\n            memcpy(&wav_hdr[20], \"\\x01\\x00\", 2);         /* PCM */\n            /* # channels */\n            tmp16 = channels;\n            memcpy(&wav_hdr[22], &tmp16, 2);\n            /* sample rate */\n            tmp32 = sample_rate;\n            memcpy(&wav_hdr[24], &tmp32, 4);\n            /* byte rate */\n            tmp32 = sample_rate * channels * sample_bytes_;\n            memcpy(&wav_hdr[28], &tmp32, 4);\n            /* block align */\n            tmp16 = channels * sample_bytes_;\n            memcpy(&wav_hdr[32], &tmp16, 2);\n            /* bits per sample */\n            tmp16 = 8 * sample_bytes_;\n            memcpy(&wav_hdr[34], &tmp16, 2);\n\n            memcpy(&wav_hdr[36], \"data\", 4);\n            memcpy(&wav_hdr[40], \"\\xFF\\xFF\\xFF\\xFF\", 4); /* XXX, unknown */\n\n            json_dumper_write_base64(&dumper, wav_hdr, sizeof(wav_hdr));\n        }\n\n        // Write samples to our file.\n        write_buff = (char *) decode_buff;\n        write_bytes = decoded_bytes;\n\n        if (audio_out_rate_ != sample_rate)\n        {\n            spx_uint32_t in_len, out_len;\n\n            /* Resample the audio to match our previous output rate. */\n            if (!audio_resampler_)\n            {\n                audio_resampler_ = speex_resampler_init(1, sample_rate, audio_out_rate_, 10, NULL);\n                speex_resampler_skip_zeros(audio_resampler_);\n                RTP_STREAM_DEBUG(\"Started resampling from %u to (out) %u Hz.\", sample_rate, audio_out_rate_);\n            }\n            else\n            {\n                spx_uint32_t audio_out_rate;\n                speex_resampler_get_rate(audio_resampler_, &cur_in_rate, &audio_out_rate);\n\n                if (sample_rate != cur_in_rate)\n                {\n                    speex_resampler_set_rate(audio_resampler_, sample_rate, audio_out_rate);\n                    RTP_STREAM_DEBUG(\"Changed input rate from %u to %u Hz. Out is %u.\", cur_in_rate, sample_rate, audio_out_rate_);\n                }\n            }\n            in_len = (spx_uint32_t)rtp_packet->info->info_payload_len;\n            out_len = (audio_out_rate_ * (spx_uint32_t)rtp_packet->info->info_payload_len / sample_rate) + (audio_out_rate_ % sample_rate != 0);\n            if (out_len * sample_bytes_ > resample_buff_len)\n            {\n                while ((out_len * sample_bytes_ > resample_buff_len))\n                    resample_buff_len *= 2;\n                resample_buff = (SAMPLE *) g_realloc(resample_buff, resample_buff_len);\n            }\n\n            speex_resampler_process_int(audio_resampler_, 0, decode_buff, &in_len, resample_buff, &out_len);\n            write_buff = (char *) resample_buff;\n            write_bytes = out_len * sample_bytes_;\n        }\n\n        /* Write the decoded, possibly-resampled audio */\n        json_dumper_write_base64(&dumper, write_buff, write_bytes);\n\n        g_free(decode_buff);\n    }\n\n    g_free(resample_buff);\n    g_hash_table_destroy(decoders_hash_);\n}\n\nstatic tap_packet_status\nsharkd_session_packet_download_tap_rtp_cb(void *tapdata, packet_info *pinfo, epan_dissect_t *edt _U_, const void *data, tap_flags_t flags _U_)\n{\n    const struct _rtp_info *rtp_info = (const struct _rtp_info *) data;\n    struct sharkd_download_rtp *req_rtp = (struct sharkd_download_rtp *) tapdata;\n\n    /* do not consider RTP packets without a setup frame */\n    if (rtp_info->info_setup_frame_num == 0)\n        return TAP_PACKET_DONT_REDRAW;\n\n    if (rtpstream_id_equal_pinfo_rtp_info(&req_rtp->id, pinfo, rtp_info))\n    {\n        rtp_packet_t *rtp_packet;\n\n        rtp_packet = g_new0(rtp_packet_t, 1);\n        rtp_packet->info = (struct _rtp_info *) g_memdup2(rtp_info, sizeof(struct _rtp_info));\n\n        if (rtp_info->info_all_data_present && rtp_info->info_payload_len != 0)\n            rtp_packet->payload_data = (uint8_t *) g_memdup2(&(rtp_info->info_data[rtp_info->info_payload_offset]), rtp_info->info_payload_len);\n\n        if (!req_rtp->packets)\n            req_rtp->start_time = nstime_to_sec(&pinfo->abs_ts);\n\n        rtp_packet->frame_num = pinfo->num;\n        rtp_packet->arrive_offset = nstime_to_sec(&pinfo->abs_ts) - req_rtp->start_time;\n\n        /* XXX, O(n) optimize */\n        req_rtp->packets = g_slist_append(req_rtp->packets, rtp_packet);\n    }\n\n    return TAP_PACKET_DONT_REDRAW;\n}\n\nstatic bool\nsharkd_session_eo_retap_listener(const char *tap_type) {\n    bool ok = true;\n    register_eo_t *eo = NULL;\n    GString *tap_error = NULL;\n    void *tap_data = NULL;\n    GFreeFunc tap_free = NULL;\n\n    // get <name> from eo:<name>, get_eo_by_name only needs the name (http etc.)\n    eo = get_eo_by_name(tap_type + 3);\n    if (!eo)\n    {\n        ok = false;\n        sharkd_json_error(\n                rpcid, -11011, NULL,\n                \"sharkd_session_eo_retap_listener() eo=%s not found\", tap_type + 3\n        );\n    }\n\n    if (ok)\n    {\n        tap_error = sharkd_session_eo_register_tap_listener(eo, tap_type, NULL, NULL, &tap_data, &tap_free);\n        if (tap_error)\n        {\n            ok = false;\n            sharkd_json_error(\n                    rpcid, -10002, NULL,\n                    \"sharkd_session_eo_retap_listener() sharkd_session_eo_register_tap_listener error %s\",\n                    tap_error->str);\n            g_string_free(tap_error, TRUE);\n        }\n    }\n\n    if (ok)\n        sharkd_retap();\n\n    if (!tap_error)\n        remove_tap_listener(tap_data);\n\n    if (tap_free)\n        tap_free(tap_data);\n\n    return ok;\n}\n\n/**\n * sharkd_session_process_download()\n *\n * Process download request\n *\n * Input:\n *   (m) token  - token to download\n *\n * Output object with attributes:\n *   (o) file - suggested name of file\n *   (o) mime - suggested content type\n *   (o) data - payload base64 encoded\n */\nstatic void\nsharkd_session_process_download(char *buf, const jsmntok_t *tokens, int count)\n{\n    const char *tok_token      = json_find_attr(buf, tokens, count, \"token\");\n\n    if (!tok_token)\n    {\n        sharkd_json_error(\n            rpcid, -10005, NULL,\n            \"missing token\"\n        );\n        return;\n    }\n\n    if (!strncmp(tok_token, \"eo:\", 3))\n    {\n        // get eo:<name> from eo:<name>_<row>\n        char *tap_type = g_strdup(tok_token);\n        char *tmp = strrchr(tap_type, '_');\n        if (tmp)\n            *tmp = '\\0';\n\n        // if eo:<name> not in sharkd_eo_list, retap\n        if (!sharkd_eo_object_list_get_entry_by_type(sharkd_eo_list, tap_type) &&\n            !sharkd_session_eo_retap_listener(tap_type))\n        {\n            g_free(tap_type);\n            // sharkd_json_error called in sharkd_session_eo_retap_listener\n            return;\n        }\n\n        g_free(tap_type);\n\n        struct sharkd_export_object_list *object_list;\n        const export_object_entry_t *eo_entry = NULL;\n\n        for (object_list = sharkd_eo_list; object_list; object_list = object_list->next)\n        {\n            size_t eo_type_len = strlen(object_list->type);\n\n            if (!strncmp(tok_token, object_list->type, eo_type_len) && tok_token[eo_type_len] == '_')\n            {\n                int row;\n\n                if (sscanf(&tok_token[eo_type_len + 1], \"%d\", &row) != 1)\n                    break;\n\n                eo_entry = (export_object_entry_t *) g_slist_nth_data(object_list->entries, row);\n                break;\n            }\n        }\n\n        if (eo_entry)\n        {\n            const char *mime     = (eo_entry->content_type) ? eo_entry->content_type : \"application/octet-stream\";\n            const char *filename = (eo_entry->filename) ? eo_entry->filename : tok_token;\n\n            sharkd_json_result_prologue(rpcid);\n            sharkd_json_value_string(\"file\", filename);\n            sharkd_json_value_string(\"mime\", mime);\n            sharkd_json_value_base64(\"data\", eo_entry->payload_data, eo_entry->payload_len);\n            sharkd_json_result_epilogue();\n        }\n        else\n        {\n            sharkd_json_result_prologue(rpcid);\n            sharkd_json_result_epilogue();\n        }\n    }\n    else if (!strcmp(tok_token, \"ssl-secrets\"))\n    {\n        size_t str_len;\n        char *str = ssl_export_sessions(&str_len);\n\n        if (str)\n        {\n            const char *mime     = \"text/plain\";\n            const char *filename = \"keylog.txt\";\n\n            sharkd_json_result_prologue(rpcid);\n            sharkd_json_value_string(\"file\", filename);\n            sharkd_json_value_string(\"mime\", mime);\n            sharkd_json_value_base64(\"data\", str, str_len);\n            sharkd_json_result_epilogue();\n        }\n        g_free(str);\n    }\n    else if (!strncmp(tok_token, \"rtp:\", 4))\n    {\n        struct sharkd_download_rtp rtp_req;\n        GString *tap_error;\n\n        memset(&rtp_req, 0, sizeof(rtp_req));\n        if (!sharkd_rtp_match_init(&rtp_req.id, tok_token + 4))\n        {\n            sharkd_json_error(\n                    rpcid, -10001, NULL,\n                    \"sharkd_session_process_download() rtp tokenizing error %s\", tok_token\n                    );\n            return;\n        }\n\n        tap_error = register_tap_listener(\"rtp\", &rtp_req, NULL, 0, NULL, sharkd_session_packet_download_tap_rtp_cb, NULL, NULL);\n        if (tap_error)\n        {\n            sharkd_json_error(\n                    rpcid, -10002, NULL,\n                    \"sharkd_session_process_download() rtp error %s\", tap_error->str\n                    );\n            g_string_free(tap_error, TRUE);\n            return;\n        }\n\n        sharkd_retap();\n        remove_tap_listener(&rtp_req);\n\n        if (rtp_req.packets)\n        {\n            const char *mime     = \"audio/x-wav\";\n            const char *filename = tok_token;\n\n            sharkd_json_result_prologue(rpcid);\n            sharkd_json_value_string(\"file\", filename);\n            sharkd_json_value_string(\"mime\", mime);\n\n            json_dumper_set_member_name(&dumper, \"data\");\n            json_dumper_begin_base64(&dumper);\n            sharkd_rtp_download_decode(&rtp_req);\n            json_dumper_end_base64(&dumper);\n\n            sharkd_json_result_epilogue();\n\n            g_slist_free_full(rtp_req.packets, sharkd_rtp_download_free_items);\n        }\n        else\n        {\n            sharkd_json_error(\n                rpcid, -10003, NULL,\n                \"no rtp data available\"\n            );\n        }\n    }\n    else\n    {\n        sharkd_json_error(\n            rpcid, -10004, NULL,\n            \"unrecognized token\"\n        );\n    }\n}\n\nstatic void\nsharkd_session_process(char *buf, const jsmntok_t *tokens, int count)\n{\n    if (json_prep(buf, tokens, count))\n    {\n        /* don't need [0] token */\n        tokens++;\n        count--;\n\n        const char* tok_method = json_find_attr(buf, tokens, count, \"method\");\n\n        if (!tok_method) {\n            sharkd_json_error(\n                    rpcid, -32601, NULL,\n                    \"No method found\");\n            return;\n        }\n        if (!strcmp(tok_method, \"load\"))\n            sharkd_session_process_load(buf, tokens, count);\n        else if (!strcmp(tok_method, \"status\"))\n            sharkd_session_process_status();\n        else if (!strcmp(tok_method, \"analyse\"))\n            sharkd_session_process_analyse();\n        else if (!strcmp(tok_method, \"info\"))\n            sharkd_session_process_info();\n        else if (!strcmp(tok_method, \"check\"))\n            sharkd_session_process_check(buf, tokens, count);\n        else if (!strcmp(tok_method, \"complete\"))\n            sharkd_session_process_complete(buf, tokens, count);\n        else if (!strcmp(tok_method, \"frames\"))\n            sharkd_session_process_frames(buf, tokens, count);\n        else if (!strcmp(tok_method, \"tap\"))\n            sharkd_session_process_tap(buf, tokens, count);\n        else if (!strcmp(tok_method, \"follow\"))\n            sharkd_session_process_follow(buf, tokens, count);\n        else if (!strcmp(tok_method, \"iograph\"))\n            sharkd_session_process_iograph(buf, tokens, count);\n        else if (!strcmp(tok_method, \"intervals\"))\n            sharkd_session_process_intervals(buf, tokens, count);\n        else if (!strcmp(tok_method, \"frame\"))\n            sharkd_session_process_frame(buf, tokens, count);\n        else if (!strcmp(tok_method, \"setcomment\"))\n            sharkd_session_process_setcomment(buf, tokens, count);\n        else if (!strcmp(tok_method, \"setconf\"))\n            sharkd_session_process_setconf(buf, tokens, count);\n        else if (!strcmp(tok_method, \"dumpconf\"))\n            sharkd_session_process_dumpconf(buf, tokens, count);\n        else if (!strcmp(tok_method, \"download\"))\n            sharkd_session_process_download(buf, tokens, count);\n        else if (!strcmp(tok_method, \"bye\"))\n        {\n            sharkd_json_simple_ok(rpcid);\n            exit(0);\n        }\n        else\n        {\n            sharkd_json_error(\n                    rpcid, -32601, NULL,\n                    \"The method \\\"%s\\\" is unknown\", tok_method\n                    );\n        }\n    }\n}\n\nint\nsharkd_session_main(int mode_setting)\n{\n    char buf[8 * 1024];\n    jsmntok_t *tokens = NULL;\n    int tokens_max = -1;\n\n    mode = mode_setting;\n\n    fprintf(stderr, \"Hello in child.\\n\");\n\n    dumper.output_file = stdout;\n\n    filter_table = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, sharkd_session_filter_free);\n\n#ifdef HAVE_MAXMINDDB\n    /* mmdbresolve was stopped before fork(), force starting it */\n    uat_get_table_by_name(\"MaxMind Database Paths\")->post_update_cb();\n#endif\n\n    set_resolution_synchrony(true);\n\n    while (fgets(buf, sizeof(buf), stdin))\n    {\n        /* every command is line separated JSON */\n        int ret;\n\n        ret = json_parse(buf, NULL, 0);\n        if (ret <= 0)\n        {\n            sharkd_json_error(\n                    rpcid, -32600, NULL,\n                    \"Invalid JSON(1)\"\n                    );\n            continue;\n        }\n\n        /* fprintf(stderr, \"JSON: %d tokens\\n\", ret); */\n        ret += 1;\n\n        if (tokens == NULL || tokens_max < ret)\n        {\n            tokens_max = ret;\n            tokens = (jsmntok_t *) g_realloc(tokens, sizeof(jsmntok_t) * tokens_max);\n        }\n\n        memset(tokens, 0, ret * sizeof(jsmntok_t));\n\n        ret = json_parse(buf, tokens, ret);\n        if (ret <= 0)\n        {\n            sharkd_json_error(\n                    rpcid, -32600, NULL,\n                    \"Invalid JSON(2)\"\n                    );\n            continue;\n        }\n\n        host_name_lookup_process();\n\n        sharkd_session_process(buf, tokens, ret);\n    }\n\n    g_hash_table_destroy(filter_table);\n    g_free(tokens);\n\n    return 0;\n}\n"
        },
        {
          "name": "sync_pipe.h",
          "type": "blob",
          "size": 3.615234375,
          "content": "/* sync_pipe.h\n * Low-level synchronization pipe routines for use by Wireshark/TShark\n * and dumpcap\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n\n/** @file\n *\n *  Low-level sync pipe interfaces.\n */\n\n#ifndef __SYNC_PIPE_H__\n#define __SYNC_PIPE_H__\n\n#include <ws_posix_compat.h>\n\n/*\n * Maximum length of sync pipe message data.  Must be < 2^24, as the\n * message length is 3 bytes.\n * XXX - this must be large enough to handle a Really Big Filter\n * Expression, as the error message for an incorrect filter expression\n * is a bit larger than the filter expression, and large enough to\n * handle a large interface list.\n * 4096 is a typical PIPE_BUF size for atomic writes, but we should have\n * only one writer and one reader so that shouldn't be an issue.\n */\n#define SP_MAX_MSG_LEN  (512 * 1000)\n\n/*\n * Indications sent out on the sync pipe (from child to parent).\n * We might want to switch to something like Thrift\n * (http://thrift.apache.org/) or Protocol Buffers\n * (http://code.google.com/p/protobuf-c/) if we ever need to use more\n * complex messages.\n */\n#define SP_EXEC_FAILED  'X'     /* errno value for the exec failing */\n#define SP_FILE         'F'     /* the name of the recently opened file */\n#define SP_ERROR_MSG    'E'     /* error message */\n#define SP_LOG_MSG      'L'     /* log message */\n#define SP_BAD_FILTER   'B'     /* error message for bad capture filter */\n#define SP_PACKET_COUNT 'P'     /* count of packets captured since last message */\n#define SP_DROPS        'D'     /* count of packets dropped in capture */\n#define SP_SUCCESS      'S'     /* success indication, no extra data */\n#define SP_TOOLBAR_CTRL 'T'     /* interface toolbar control packet */\n#define SP_IFACE_LIST   'I'     /* interface list */\n/*\n * Win32 only: Indications sent out on the signal pipe (from parent to child)\n * (UNIX-like sends signals for this)\n */\n#define SP_QUIT         'Q'     /* \"gracefully\" capture quit message (SIGUSR1) */\n\n/* Write a message, with a string body, to the recipient pipe in the\n   standard format (1-byte message indicator, 3-byte message length\n   (excluding length and indicator field), and the string.\n   If msg is NULL, the message has only a length and indicator. */\nextern void\nsync_pipe_write_string_msg(int pipe_fd, char indicator, const char *msg);\n\n/* Write a message, with an unsigned integer body, to the recipient\n   pipe in the standard format (1-byte message indicator, 3-byte\n   message length (excluding length and indicator field), and the\n   unsigned integer, as a string. */\nextern void\nsync_pipe_write_uint_msg(int pipe_fd, char indicator, unsigned int num);\n\n/* Write a message, with an integer body, to the recipient pipe in the\n   standard format (1-byte message indicator, 3-byte message length\n   (excluding length and indicator field), and the integer, as a string. */\nextern void\nsync_pipe_write_int_msg(int pipe_fd, char indicator, int num);\n\n/** the child encountered an error, notify the parent */\nextern void\nsync_pipe_write_errmsgs_to_parent(int pipe_fd, const char *error_msg,\n                                  const char *secondary_error_msg);\n\n/** Has the parent signalled the child to stop? */\n#define SIGNAL_PIPE_CTRL_ID_NONE \"none\"\n#ifdef _WIN32\n#define SIGNAL_PIPE_FORMAT \"\\\\\\\\.\\\\pipe\\\\wireshark.%s.signal\"\n#endif\n\n#endif /* sync_pipe.h */\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "sync_pipe_write.c",
          "type": "blob",
          "size": 4.2158203125,
          "content": "/* sync_pipe_write.c\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n\n#include <string.h>\n\n#include <glib.h>\n\n#include <wsutil/file_util.h>\n#include <wsutil/ws_assert.h>\n\n#include \"sync_pipe.h\"\n\n/****************************************************************************************************************/\n/* sync_pipe handling */\n\n\n/* write a single message header to the recipient pipe */\nstatic ssize_t\nsync_pipe_write_header(int pipe_fd, char indicator, unsigned int length)\n{\n    unsigned char header[1+3]; /* indicator + 3-byte len */\n\n    ws_assert(length <= SP_MAX_MSG_LEN);\n\n    /* write header (indicator + 3-byte len) */\n    header[0] = indicator;\n    header[1] = (length >> 16) & 0xFF;\n    header[2] = (length >> 8) & 0xFF;\n    header[3] = (length >> 0) & 0xFF;\n\n    /* write header */\n    return ws_write(pipe_fd, header, sizeof header);\n}\n\n\n/* Write a message, with a string body, to the recipient pipe in the\n   standard format (1-byte message indicator, 3-byte message length\n   (excluding length and indicator field), and the string.\n   If msg is NULL, the message has only a length and indicator. */\nvoid\nsync_pipe_write_string_msg(int pipe_fd, char indicator, const char *msg)\n{\n    ssize_t ret;\n    int len;\n\n    /*ws_warning(\"write %d enter\", pipe_fd);*/\n\n    if(msg != NULL) {\n        len = (int) strlen(msg) + 1;    /* including the terminating '\\0'! */\n    } else {\n        len = 0;\n    }\n\n    /* write header (indicator + 3-byte len) */\n    ret = sync_pipe_write_header(pipe_fd, indicator, len);\n    if(ret == -1) {\n        return;\n    }\n\n    /* write value (if we have one) */\n    if(len) {\n        /*ws_warning(\"write %d indicator: %c value len: %u msg: %s\", pipe_fd, indicator, len, msg);*/\n        ret = ws_write(pipe_fd, msg, len);\n        if(ret == -1) {\n            return;\n        }\n    } else {\n        /*ws_warning(\"write %d indicator: %c no value\", pipe_fd, indicator);*/\n    }\n\n    /*ws_warning(\"write %d leave\", pipe_fd);*/\n}\n\n\n/* Size of buffer to hold decimal representation of\n   signed/unsigned 64-bit int */\n#define SP_DECISIZE 20\n\n/* Write a message, with an unsigned integer body, to the recipient\n   pipe in the standard format (1-byte message indicator, 3-byte\n   message length (excluding length and indicator field), and the\n   unsigned integer, as a string. */\nvoid\nsync_pipe_write_uint_msg(int pipe_fd, char indicator, unsigned int num)\n{\n    char count_str[SP_DECISIZE+1+1];\n\n    snprintf(count_str, sizeof(count_str), \"%u\", num);\n    sync_pipe_write_string_msg(pipe_fd, indicator, count_str);\n}\n\n/* Write a message, with an integer body, to the recipient pipe in the\n   standard format (1-byte message indicator, 3-byte message length\n   (excluding length and indicator field), and the unsigned integer,\n   as a string. */\nvoid\nsync_pipe_write_int_msg(int pipe_fd, char indicator, int num)\n{\n    char count_str[SP_DECISIZE+1+1];\n\n    snprintf(count_str, sizeof(count_str), \"%d\", num);\n    sync_pipe_write_string_msg(pipe_fd, indicator, count_str);\n}\n\n/* Write a message, with a primary and secondary error message as the body,\n   to the recipient pipe.  The header is an SP_ERROR_MSG header, with the\n   length being the length of two string submessages; the submessages\n   are the body of the message, with each submessage being a message\n   with an indicator of SP_ERROR_MSG, the first message having the\n   primary error message string and the second message having the secondary\n   error message string. */\nvoid\nsync_pipe_write_errmsgs_to_parent(int pipe_fd, const char *error_msg,\n                                  const char *secondary_error_msg)\n{\n    sync_pipe_write_header(pipe_fd, SP_ERROR_MSG,\n                           (unsigned int) (strlen(error_msg) + 1 + 4 + strlen(secondary_error_msg) + 1 + 4));\n    sync_pipe_write_string_msg(pipe_fd, SP_ERROR_MSG, error_msg);\n    sync_pipe_write_string_msg(pipe_fd, SP_ERROR_MSG, secondary_error_msg);\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "text2pcap.c",
          "type": "blob",
          "size": 42.8310546875,
          "content": "/**-*-C-*-**********************************************************************\n *\n * text2pcap.c\n *\n * Utility to convert an ASCII hexdump into a libpcap-format capture file\n *\n * (c) Copyright 2001 Ashok Narayanan <ashokn@cisco.com>\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n *\n *******************************************************************************/\n\n/*******************************************************************************\n *\n * This utility reads in an ASCII hexdump of this common format:\n *\n * 00000000  00 E0 1E A7 05 6F 00 10 5A A0 B9 12 08 00 46 00 .....o..Z.....F.\n * 00000010  03 68 00 00 00 00 0A 2E EE 33 0F 19 08 7F 0F 19 .h.......3......\n * 00000020  03 80 94 04 00 00 10 01 16 A2 0A 00 03 50 00 0C .............P..\n * 00000030  01 01 0F 19 03 80 11 01 1E 61 00 0C 03 01 0F 19 .........a......\n *\n * Each bytestring line consists of an offset, one or more bytes, and\n * text at the end. An offset is defined as a hex string of more than\n * two characters. A byte is defined as a hex string of exactly two\n * characters. The text at the end is ignored, as is any text before\n * the offset. Bytes read from a bytestring line are added to the\n * current packet only if all the following conditions are satisfied:\n *\n * - No text appears between the offset and the bytes (any bytes appearing after\n *   such text would be ignored)\n *\n * - The offset must be arithmetically correct, i.e. if the offset is 00000020,\n *   then exactly 32 bytes must have been read into this packet before this.\n *   If the offset is wrong, the packet is immediately terminated\n *\n * A packet start is signaled by a zero offset.\n *\n * Lines starting with #TEXT2PCAP are directives. These allow the user\n * to embed instructions into the capture file which allows text2pcap\n * to take some actions (e.g. specifying the encapsulation\n * etc.). Currently no directives are implemented.\n *\n * Lines beginning with # which are not directives are ignored as\n * comments. Currently all non-hexdump text is ignored by text2pcap;\n * in the future, text processing may be added, but lines prefixed\n * with '#' will still be ignored.\n *\n * The output is a libpcap packet containing Ethernet frames by\n * default. This program takes options which allow the user to add\n * dummy Ethernet, IP and UDP, TCP or SCTP headers to the packets in order\n * to allow dumps of L3 or higher protocols to be decoded.\n *\n * Considerable flexibility is built into this code to read hexdumps\n * of slightly different formats. For example, any text prefixing the\n * hexdump line is dropped (including mail forwarding '>'). The offset\n * can be any hex number of four digits or greater.\n *\n * This converter cannot read a single packet greater than\n * WTAP_MAX_PACKET_SIZE_STANDARD.  The snapshot length is automatically\n * set to WTAP_MAX_PACKET_SIZE_STANDARD.\n */\n\n#include <config.h>\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <wsutil/file_util.h>\n#include <cli_main.h>\n#include <wsutil/cmdarg_err.h>\n#include <ui/text_import.h>\n#include <wsutil/version_info.h>\n#include <ui/failure_message.h>\n#include <wsutil/clopts_common.h>\n#include <wsutil/inet_addr.h>\n#include <wsutil/cpu_info.h>\n#include <wsutil/os_version_info.h>\n#include <wsutil/privileges.h>\n#include <wsutil/strtoi.h>\n\n#include <glib.h>\n\n#include <ws_exit_codes.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/str_util.h>\n#include <wsutil/strnatcmp.h>\n#include <wsutil/wslog.h>\n#include <wsutil/ws_getopt.h>\n\n#include <errno.h>\n\n#include \"text2pcap.h\"\n\n#include \"wiretap/wtap.h\"\n#include \"wiretap/pcap-encap.h\"\n\n#define LONGOPT_COMPRESS                LONGOPT_BASE_APPLICATION+1\n#define LONGOPT_LITTLE_ENDIAN           LONGOPT_BASE_APPLICATION+2\n\n/*--- Options --------------------------------------------------------------------*/\n\n\n/* Be quiet */\nstatic bool quiet;\n\n/* Dummy Ethernet header */\nstatic bool hdr_ethernet;\n#if 0\n/* XXX: Maybe add custom Ethernet Address options? */\nstatic uint8_t hdr_eth_dest_addr[6] = {0x0a, 0x02, 0x02, 0x02, 0x02, 0x02};\nstatic uint8_t hdr_eth_src_addr[6]  = {0x0a, 0x02, 0x02, 0x02, 0x02, 0x01};\n#endif\nstatic uint32_t hdr_ethernet_proto;\n\n/* Dummy IP header */\nstatic bool hdr_ip;\nstatic bool hdr_ipv6;\nstatic bool have_hdr_ip_proto;\nstatic uint8_t hdr_ip_proto;\n\n/* Destination and source addresses for IP header */\nstatic uint32_t hdr_ip_dest_addr;\nstatic uint32_t hdr_ip_src_addr;\nstatic ws_in6_addr hdr_ipv6_dest_addr = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};\nstatic ws_in6_addr hdr_ipv6_src_addr  = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};\n\n/* Dummy UDP header */\nstatic bool hdr_udp;\nstatic uint32_t hdr_dest_port;\nstatic uint32_t hdr_src_port;\n\n/* Dummy TCP header */\nstatic bool hdr_tcp;\n\n/* Dummy SCTP header */\nstatic bool hdr_sctp;\nstatic uint32_t hdr_sctp_src;\nstatic uint32_t hdr_sctp_dest;\nstatic uint32_t hdr_sctp_tag;\n\n/* Dummy DATA chunk header */\nstatic bool hdr_data_chunk;\nstatic uint32_t hdr_data_chunk_tsn;\nstatic uint16_t hdr_data_chunk_sid;\nstatic uint16_t hdr_data_chunk_ssn;\nstatic uint32_t hdr_data_chunk_ppid;\n\n/* Export PDU */\nstatic bool hdr_export_pdu;\n\n/*--- Local data -----------------------------------------------------------------*/\n\n/* This is where we store the packet currently being built */\nstatic uint32_t max_offset = WTAP_MAX_PACKET_SIZE_STANDARD;\n\n/* Time code of packet, derived from packet_preamble */\nstatic int      ts_fmt_iso;\n\n/* Input file */\nstatic char *input_filename;\nstatic FILE       *input_file;\n/* Output file */\nstatic char *output_filename;\n\nstatic wtap_dumper* wdh;\n\n/*----------------------------------------------------------------------\n * Print usage string and exit\n */\nstatic void\nprint_usage (FILE *output)\n{\n    fprintf(output,\n            \"\\n\"\n            \"Usage: text2pcap [options] <infile> <outfile>\\n\"\n            \"\\n\"\n            \"where  <infile> specifies input  filename (use - for standard input)\\n\"\n            \"      <outfile> specifies output filename (use - for standard output)\\n\"\n            \"\\n\"\n            \"Input:\\n\"\n            \"  -o hex|oct|dec|none    parse offsets as (h)ex, (o)ctal, (d)ecimal, or (n)one;\\n\"\n            \"                         default is hex.\\n\"\n            \"  -t <timefmt>           treat the text before the packet as a date/time code;\\n\"\n            \"                         <timefmt> is a format string supported by strptime,\\n\"\n            \"                         with an optional %%f descriptor for fractional seconds.\\n\"\n            \"                         Example: The time \\\"10:15:14.5476\\\" has the format code\\n\"\n            \"                         \\\"%%H:%%M:%%S.%%f\\\"\\n\"\n            \"                         The special format string ISO supports ISO-8601 times.\\n\"\n            \"                         NOTE: Date/time fields from the current date/time are\\n\"\n            \"                         used as the default for unspecified fields.\\n\"\n            \"  -D                     the text before the packet starts with an I or an O,\\n\"\n            \"                         indicating that the packet is inbound or outbound.\\n\"\n            \"                         This is used when generating dummy headers if the\\n\"\n            \"                         output format supports it (e.g. pcapng).\\n\"\n            \"  -a                     enable ASCII text dump identification.\\n\"\n            \"                         The start of the ASCII text dump can be identified\\n\"\n            \"                         and excluded from the packet data, even if it looks\\n\"\n            \"                         like a HEX dump.\\n\"\n            \"                         NOTE: Do not enable it if the input file does not\\n\"\n            \"                         contain the ASCII text dump.\\n\"\n            \"  -r <regex>             enable regex mode. Scan the input using <regex>, a Perl\\n\"\n            \"                         compatible regular expression matching a single packet.\\n\"\n            \"                         Named capturing subgroups are used to identify fields:\\n\"\n            \"                         <data> (mand.), and <time>, <dir>, and <seqno> (opt.)\\n\"\n            \"                         The time field format is taken from the -t option\\n\"\n            \"                         Example: -r '^(?<dir>[<>])\\\\s(?<time>\\\\d+:\\\\d\\\\d:\\\\d\\\\d.\\\\d+)\\\\s(?<data>[0-9a-fA-F]+)$'\\n\"\n            \"                         could match a file with lines like\\n\"\n            \"                         > 0:00:00.265620 a130368b000000080060\\n\"\n            \"                         < 0:00:00.295459 a2010800000000000000000800000000\\n\"\n            \"  -b 2|8|16|64           encoding base (radix) of the packet data in regex mode\\n\"\n            \"                         (def: 16: hexadecimal) No effect in hexdump mode.\\n\"\n            \"\\n\"\n            \"Output:\\n\"\n            \"                         if the output file(s) have the .gz extension, then\\n\"\n            \"                         gzip compression will be used.\\n\"\n            \"  -F <capture type>      set the output file type; default is pcapng.\\n\"\n            \"                         an empty \\\"-F\\\" option will list the file types.\\n\"\n            \"  -E <encap type>        set the output file encapsulation type; default is\\n\"\n            \"                         ether (Ethernet). An empty \\\"-E\\\" option will list\\n\"\n            \"                         the encapsulation types.\\n\"\n            \"  -l <typenum>           set the output file encapsulation type via link-layer\\n\"\n            \"                         type number; default is 1 (Ethernet). See\\n\"\n            \"                         https://www.tcpdump.org/linktypes.html for a list of\\n\"\n            \"                         numbers.\\n\"\n            \"                         Example: -l 7 for ARCNet packets.\\n\"\n            \"  -m <max-packet>        max packet length in output; default is %u\\n\"\n            \"  -N <intf-name>         assign name to the interface in the pcapng file.\\n\"\n            \"  --compress <type>      Compress the output file using the type compression format.\\n\"\n            \"                         \"\n            \"\\n\"\n            \"Prepend dummy header:\\n\"\n            \"  -e <ethertype>         prepend dummy Ethernet II header with specified EtherType\\n\"\n            \"                         (in HEX).\\n\"\n            \"                         Example: -e 0x806 to specify an ARP packet.\\n\"\n            \"  -i <proto>             prepend dummy IP header with specified IP protocol\\n\"\n            \"                         (in DECIMAL).\\n\"\n            \"                         Automatically prepends Ethernet header as well if\\n\"\n            \"                         link-layer type is Ethernet.\\n\"\n            \"                         Example: -i 46\\n\"\n            \"  -4 <srcip>,<destip>    prepend dummy IPv4 header with specified\\n\"\n            \"                         source and destination addresses.\\n\"\n            \"                         Example: -4 10.0.0.1,10.0.0.2\\n\"\n            \"  -6 <srcip>,<destip>    prepend dummy IPv6 header with specified\\n\"\n            \"                         source and destination addresses.\\n\"\n            \"                         Example: -6 2001:db8::b3ff:fe1e:8329,2001:0db8:85a3::8a2e:0370:7334\\n\"\n            \"  -u <srcp>,<destp>      prepend dummy UDP header with specified\\n\"\n            \"                         source and destination ports (in DECIMAL).\\n\"\n            \"                         Automatically prepends Ethernet & IP headers as well.\\n\"\n            \"                         Example: -u 1000,69 to make the packets look like\\n\"\n            \"                         TFTP/UDP packets.\\n\"\n            \"  -T <srcp>,<destp>      prepend dummy TCP header with specified\\n\"\n            \"                         source and destination ports (in DECIMAL).\\n\"\n            \"                         Automatically prepends Ethernet & IP headers as well.\\n\"\n            \"                         Example: -T 50,60\\n\"\n            \"  -s <srcp>,<dstp>,<tag> prepend dummy SCTP header with specified\\n\"\n            \"                         source/destination ports and verification tag (in DECIMAL).\\n\"\n            \"                         Automatically prepends Ethernet & IP headers as well.\\n\"\n            \"                         Example: -s 30,40,34\\n\"\n            \"  -S <srcp>,<dstp>,<ppi> prepend dummy SCTP header with specified\\n\"\n            \"                         source/destination ports and verification tag 0.\\n\"\n            \"                         Automatically prepends a dummy SCTP DATA\\n\"\n            \"                         chunk header with payload protocol identifier ppi.\\n\"\n            \"                         Example: -S 30,40,34\\n\"\n            \"  -P <dissector>         prepend EXPORTED_PDU header with specified dissector\\n\"\n            \"                         as the payload DISSECTOR_NAME tag.\\n\"\n            \"                         Automatically sets link type to Upper PDU Export.\\n\"\n            \"                         EXPORTED_PDU payload defaults to \\\"data\\\" otherwise.\\n\"\n            \"\\n\",\n            WTAP_MAX_PACKET_SIZE_STANDARD);\n\n    ws_log_print_usage(output);\n\n    fprintf(output, \"\\n\"\n            \"Miscellaneous:\\n\"\n            \"  -h, --help             display this help and exit\\n\"\n            \"  -v, --version          print version information and exit\\n\"\n            \"  -q                     don't report processed packet counts\\n\"\n            \"\");\n}\n\n/*\n * Set the hdr_ip_proto parameter, and set the flag indicate that the\n * parameter has been specified.\n *\n * XXX - catch the case where two different options set it differently?\n */\nstatic void\nset_hdr_ip_proto(uint8_t ip_proto)\n{\n    have_hdr_ip_proto = true;\n    hdr_ip_proto = ip_proto;\n}\n\nstatic void\nlist_capture_types(void) {\n    GArray *writable_type_subtypes;\n\n    cmdarg_err(\"The available capture file types for the \\\"-F\\\" flag are:\\n\");\n    writable_type_subtypes = wtap_get_writable_file_types_subtypes(FT_SORT_BY_NAME);\n    for (unsigned i = 0; i < writable_type_subtypes->len; i++) {\n        int ft = g_array_index(writable_type_subtypes, int, i);\n        fprintf(stderr, \"    %s - %s\\n\", wtap_file_type_subtype_name(ft),\n            wtap_file_type_subtype_description(ft));\n    }\n    g_array_free(writable_type_subtypes, TRUE);\n}\n\nstatic void\nlist_output_compression_types(void) {\n    GSList *output_compression_types;\n\n    cmdarg_err(\"The available output compression type(s) for the \\\"--compress\\\" flag are:\\n\");\n    output_compression_types = wtap_get_all_output_compression_type_names_list();\n    for (GSList *compression_type = output_compression_types;\n        compression_type != NULL;\n        compression_type = g_slist_next(compression_type)) {\n            fprintf(stderr, \"   %s\\n\", (const char *)compression_type->data);\n        }\n\n    g_slist_free(output_compression_types);\n}\n\nstruct string_elem {\n    const char *sstr;   /* The short string */\n    const char *lstr;   /* The long string */\n};\n\nstatic int\nstring_nat_compare(const void *a, const void *b)\n{\n    return ws_ascii_strnatcmp(((const struct string_elem *)a)->sstr,\n        ((const struct string_elem *)b)->sstr);\n}\n\nstatic void\nstring_elem_print(void *data, void *stream_ptr)\n{\n    fprintf((FILE *) stream_ptr, \"    %s - %s\\n\",\n        ((struct string_elem *)data)->sstr,\n        ((struct string_elem *)data)->lstr);\n}\n\nstatic void\nlist_encap_types(void) {\n    int i;\n    struct string_elem *encaps;\n    GSList *list = NULL;\n\n    encaps = g_new(struct string_elem, wtap_get_num_encap_types());\n    cmdarg_err(\"The available encapsulation types for the \\\"-E\\\" flag are:\\n\");\n    for (i = 0; i < wtap_get_num_encap_types(); i++) {\n        /* Exclude wtap encapsulations that require a pseudo header,\n         * because we won't setup one from the text we import and\n         * wiretap doesn't allow us to write 'raw' frames\n         */\n        if (!wtap_encap_requires_phdr(i)) {\n            encaps[i].sstr = wtap_encap_name(i);\n            if (encaps[i].sstr != NULL) {\n                encaps[i].lstr = wtap_encap_description(i);\n                list = g_slist_insert_sorted(list, &encaps[i], string_nat_compare);\n            }\n        }\n    }\n    g_slist_foreach(list, string_elem_print, stderr);\n    g_slist_free(list);\n    g_free(encaps);\n}\n\nstatic void\ncleanup_dump_params(wtap_dump_params *params)\n{\n    wtap_free_idb_info(params->idb_inf);\n    wtap_dump_params_cleanup(params);\n}\n\n/*----------------------------------------------------------------------\n * Parse CLI options\n */\nstatic int\nparse_options(int argc, char *argv[], text_import_info_t * const info, wtap_dump_params * const params)\n{\n    int   ret;\n    int   c;\n    char *p;\n    static const struct ws_option long_options[] = {\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        {\"compress\", ws_required_argument, NULL, LONGOPT_COMPRESS},\n        {\"little-endian\", ws_no_argument, NULL, LONGOPT_LITTLE_ENDIAN},\n        {0, 0, 0, 0 }\n    };\n    const char *interface_name = NULL;\n    /* Link-layer type; see https://www.tcpdump.org/linktypes.html for details */\n    uint32_t pcap_link_type = 1;   /* Default is LINKTYPE_ETHERNET */\n    int file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_UNKNOWN;\n    int wtap_encap_type = WTAP_ENCAP_ETHERNET;\n    int err;\n    char* err_info;\n    wtap_compression_type compression_type = WTAP_UNKNOWN_COMPRESSION;\n    GError* gerror = NULL;\n    GRegex* regex = NULL;\n\n    info->mode = TEXT_IMPORT_HEXDUMP;\n    info->hexdump.offset_type = OFFSET_HEX;\n    info->regex.encoding = ENCODING_PLAIN_HEX;\n    info->payload = \"data\";\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"Text2pcap\", NULL, NULL);\n\n    /* Scan CLI parameters */\n    while ((c = ws_getopt_long(argc, argv, \"hqab:De:E:F:i:l:m:nN:o:u:P:r:s:S:t:T:v4:6:\", long_options, NULL)) != -1) {\n        switch (c) {\n        case 'h':\n            show_help_header(\"Generate a capture file from an ASCII hexdump of packets.\");\n            print_usage(stdout);\n            exit(0);\n            break;\n        case 'q': quiet = true; break;\n        case 'a': info->hexdump.identify_ascii = true; break;\n        case 'D': info->hexdump.has_direction = true; break;\n        case 'l':\n            pcap_link_type = (uint32_t)strtol(ws_optarg, NULL, 0);\n            wtap_encap_type = wtap_pcap_encap_to_wtap_encap(pcap_link_type);\n            break;\n        case 'm': max_offset = (uint32_t)strtol(ws_optarg, NULL, 0); break;\n        case 'n': cmdarg_err(\"'-n' is deprecated; the output format already defaults to pcapng.\"); break;\n        case 'N': interface_name = ws_optarg; break;\n        case 'b':\n        {\n            uint8_t radix;\n            if (!ws_strtou8(ws_optarg, NULL, &radix)) {\n                cmdarg_err(\"Bad argument for '-b': %s\", ws_optarg);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            switch (radix) {\n            case  2: info->regex.encoding = ENCODING_PLAIN_BIN; break;\n            case  8: info->regex.encoding = ENCODING_PLAIN_OCT; break;\n            case 16: info->regex.encoding = ENCODING_PLAIN_HEX; break;\n            case 64: info->regex.encoding = ENCODING_BASE64; break;\n            default:\n                cmdarg_err(\"Bad argument for '-b': %s\", ws_optarg);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            break;\n        }\n\n        case 'o':\n            if (ws_optarg[0] != 'h' && ws_optarg[0] != 'o' && ws_optarg[0] != 'd' && ws_optarg[0] != 'n') {\n                cmdarg_err(\"Bad argument for '-o': %s\", ws_optarg);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            switch (ws_optarg[0]) {\n            case 'o': info->hexdump.offset_type = OFFSET_OCT; break;\n            case 'h': info->hexdump.offset_type = OFFSET_HEX; break;\n            case 'd': info->hexdump.offset_type = OFFSET_DEC; break;\n            case 'n': info->hexdump.offset_type = OFFSET_NONE; break;\n            }\n            break;\n\n        case 'e':\n            hdr_ethernet = true;\n            if (sscanf(ws_optarg, \"%x\", &hdr_ethernet_proto) < 1) {\n                cmdarg_err(\"Bad argument for '-e': %s\", ws_optarg);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            break;\n\n        case 'E':\n            wtap_encap_type = wtap_name_to_encap(ws_optarg);\n            if (wtap_encap_type < 0) {\n                cmdarg_err(\"\\\"%s\\\" isn't a valid encapsulation type\", ws_optarg);\n                list_encap_types();\n                return WS_EXIT_INVALID_OPTION;\n            }\n            break;\n\n        case 'F':\n            file_type_subtype = wtap_name_to_file_type_subtype(ws_optarg);\n            if  (file_type_subtype < 0) {\n                cmdarg_err(\"\\\"%s\\\" isn't a valid capture file type\", ws_optarg);\n                list_capture_types();\n                return WS_EXIT_INVALID_OPTION;\n            }\n            break;\n\n        case 'i':\n        {\n            uint8_t ip_proto;\n            if (!ws_strtou8(ws_optarg, NULL, &ip_proto)) {\n                cmdarg_err(\"Bad argument for '-i': %s\", ws_optarg);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            set_hdr_ip_proto(ip_proto);\n            break;\n        }\n\n        case 'P':\n            hdr_export_pdu = true;\n            wtap_encap_type = WTAP_ENCAP_WIRESHARK_UPPER_PDU;\n            info->payload = ws_optarg;\n            break;\n\n        case 'r':\n            info->mode = TEXT_IMPORT_REGEX;\n            if (regex != NULL) {\n                /* XXX: Used the option twice. Should we warn? */\n                g_regex_unref(regex);\n            }\n            regex = g_regex_new(ws_optarg, G_REGEX_DUPNAMES | G_REGEX_OPTIMIZE | G_REGEX_MULTILINE, G_REGEX_MATCH_NOTEMPTY, &gerror);\n            if (gerror) {\n                cmdarg_err(\"%s\", gerror->message);\n                g_error_free(gerror);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            } else {\n                if (g_regex_get_string_number(regex, \"data\") == -1) {\n                    cmdarg_err(\"Regex missing capturing group data (use (?<data>(...)) )\");\n                    g_regex_unref(regex);\n                    print_usage(stderr);\n                    return WS_EXIT_INVALID_OPTION;\n                }\n            }\n            break;\n\n        case 's':\n            hdr_sctp = true;\n            hdr_data_chunk = false;\n            hdr_tcp = false;\n            hdr_udp = false;\n            hdr_sctp_src   = (uint32_t)strtol(ws_optarg, &p, 10);\n            if (p == ws_optarg || (*p != ',' && *p != '\\0')) {\n                cmdarg_err(\"Bad src port for '-%c'\", c);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            if (*p == '\\0') {\n                cmdarg_err(\"No dest port specified for '-%c'\", c);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            p++;\n            ws_optarg = p;\n            hdr_sctp_dest = (uint32_t)strtol(ws_optarg, &p, 10);\n            if (p == ws_optarg || (*p != ',' && *p != '\\0')) {\n                cmdarg_err(\"Bad dest port for '-s'\");\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            if (*p == '\\0') {\n                cmdarg_err(\"No tag specified for '-%c'\", c);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            p++;\n            ws_optarg = p;\n            hdr_sctp_tag = (uint32_t)strtol(ws_optarg, &p, 10);\n            if (p == ws_optarg || *p != '\\0') {\n                cmdarg_err(\"Bad tag for '-%c'\", c);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n\n            set_hdr_ip_proto(132);\n            break;\n\n        case 'S':\n            hdr_sctp = true;\n            hdr_data_chunk = true;\n            hdr_tcp = false;\n            hdr_udp = false;\n            hdr_sctp_src   = (uint32_t)strtol(ws_optarg, &p, 10);\n            if (p == ws_optarg || (*p != ',' && *p != '\\0')) {\n                cmdarg_err(\"Bad src port for '-%c'\", c);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            if (*p == '\\0') {\n                cmdarg_err(\"No dest port specified for '-%c'\", c);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            p++;\n            ws_optarg = p;\n            hdr_sctp_dest = (uint32_t)strtol(ws_optarg, &p, 10);\n            if (p == ws_optarg || (*p != ',' && *p != '\\0')) {\n                cmdarg_err(\"Bad dest port for '-s'\");\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            if (*p == '\\0') {\n                cmdarg_err(\"No ppi specified for '-%c'\", c);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            p++;\n            ws_optarg = p;\n            hdr_data_chunk_ppid = (uint32_t)strtoul(ws_optarg, &p, 10);\n            if (p == ws_optarg || *p != '\\0') {\n                cmdarg_err(\"Bad ppi for '-%c'\", c);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n\n            set_hdr_ip_proto(132);\n            break;\n\n        case 't':\n            info->timestamp_format = ws_optarg;\n            if (!strcmp(ws_optarg, \"ISO\"))\n              ts_fmt_iso = 1;\n            break;\n\n        case 'u':\n            hdr_udp = true;\n            hdr_tcp = false;\n            hdr_sctp = false;\n            hdr_data_chunk = false;\n            hdr_src_port = (uint32_t)strtol(ws_optarg, &p, 10);\n            if (p == ws_optarg || (*p != ',' && *p != '\\0')) {\n                cmdarg_err(\"Bad src port for '-u'\");\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            if (*p == '\\0') {\n                cmdarg_err(\"No dest port specified for '-u'\");\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            p++;\n            ws_optarg = p;\n            hdr_dest_port = (uint32_t)strtol(ws_optarg, &p, 10);\n            if (p == ws_optarg || *p != '\\0') {\n                cmdarg_err(\"Bad dest port for '-u'\");\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            set_hdr_ip_proto(17);\n            break;\n\n        case 'T':\n            hdr_tcp = true;\n            hdr_udp = false;\n            hdr_sctp = false;\n            hdr_data_chunk = false;\n            hdr_src_port = (uint32_t)strtol(ws_optarg, &p, 10);\n            if (p == ws_optarg || (*p != ',' && *p != '\\0')) {\n                cmdarg_err(\"Bad src port for '-T'\");\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            if (*p == '\\0') {\n                cmdarg_err(\"No dest port specified for '-u'\");\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            p++;\n            ws_optarg = p;\n            hdr_dest_port = (uint32_t)strtol(ws_optarg, &p, 10);\n            if (p == ws_optarg || *p != '\\0') {\n                cmdarg_err(\"Bad dest port for '-T'\");\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n            set_hdr_ip_proto(6);\n            break;\n\n        case 'v':\n            show_version();\n            exit(0);\n            break;\n\n        case '4':\n        case '6':\n            p = strchr(ws_optarg, ',');\n\n            if (!p) {\n                cmdarg_err(\"Bad source param addr for '-%c'\", c);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n\n            *p = '\\0';\n            if (c == '6')\n            {\n                hdr_ipv6 = true;\n                hdr_ip   = false;\n            }\n            else\n            {\n                hdr_ip   = true;\n                hdr_ipv6 = false;\n            }\n            hdr_ethernet = true;\n\n            if (hdr_ipv6 == true) {\n                if (!ws_inet_pton6(ws_optarg, &hdr_ipv6_src_addr)) {\n                        cmdarg_err(\"Bad src addr -%c '%s'\", c, p);\n                        print_usage(stderr);\n                        return WS_EXIT_INVALID_OPTION;\n                }\n            } else {\n                if (!ws_inet_pton4(ws_optarg, &hdr_ip_src_addr)) {\n                        cmdarg_err(\"Bad src addr -%c '%s'\", c, p);\n                        print_usage(stderr);\n                        return WS_EXIT_INVALID_OPTION;\n                }\n            }\n\n            p++;\n            if (*p == '\\0') {\n                cmdarg_err(\"No dest addr specified for '-%c'\", c);\n                print_usage(stderr);\n                return WS_EXIT_INVALID_OPTION;\n            }\n\n            if (hdr_ipv6 == true) {\n                if (!ws_inet_pton6(p, &hdr_ipv6_dest_addr)) {\n                        cmdarg_err(\"Bad dest addr for -%c '%s'\", c, p);\n                        print_usage(stderr);\n                        return WS_EXIT_INVALID_OPTION;\n                }\n            } else {\n                if (!ws_inet_pton4(p, &hdr_ip_dest_addr)) {\n                        cmdarg_err(\"Bad dest addr for -%c '%s'\", c, p);\n                        print_usage(stderr);\n                        return WS_EXIT_INVALID_OPTION;\n                }\n            }\n            break;\n\n        case LONGOPT_COMPRESS:\n            compression_type = wtap_name_to_compression_type(ws_optarg);\n            if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n                cmdarg_err(\"\\\"%s\\\" isn't a valid output compression mode\",\n                            ws_optarg);\n                list_output_compression_types();\n                return WS_EXIT_INVALID_OPTION;\n            }\n            break;\n\n        case LONGOPT_LITTLE_ENDIAN:\n            info->hexdump.little_endian = true;\n            break;\n\n        case '?':\n            switch(ws_optopt) {\n            case 'E':\n                list_encap_types();\n                return WS_EXIT_INVALID_OPTION;\n            case 'F':\n                list_capture_types();\n                return WS_EXIT_INVALID_OPTION;\n            case LONGOPT_COMPRESS:\n                list_output_compression_types();\n                return WS_EXIT_INVALID_OPTION;\n            }\n            /* FALLTHROUGH */\n\n        default:\n            print_usage(stderr);\n            return WS_EXIT_INVALID_OPTION;\n        }\n    }\n\n    if (ws_optind >= argc || argc-ws_optind < 2) {\n        cmdarg_err(\"Must specify input and output filename\");\n        print_usage(stderr);\n        return WS_EXIT_INVALID_OPTION;\n    }\n\n    if (max_offset > WTAP_MAX_PACKET_SIZE_STANDARD) {\n        cmdarg_err(\"Maximum packet length cannot be more than %d bytes\",\n                WTAP_MAX_PACKET_SIZE_STANDARD);\n        return WS_EXIT_INVALID_OPTION;\n    }\n\n    /* Some validation */\n\n    if (info->mode == TEXT_IMPORT_REGEX) {\n        info->regex.format = regex;\n        /* need option for data encoding */\n        if (g_regex_get_string_number(regex, \"dir\") > -1) {\n            /* XXX: Add parameter(s?) to specify these? */\n            info->regex.in_indication = \"iI<\";\n            info->regex.out_indication = \"oO>\";\n        }\n        if (g_regex_get_string_number(regex, \"time\") > -1 && info->timestamp_format == NULL) {\n            cmdarg_err(\"Regex with <time> capturing group requires time format (-t)\");\n            return WS_EXIT_INVALID_OPTION;\n        }\n    }\n\n    if (have_hdr_ip_proto && !(hdr_ip || hdr_ipv6)) {\n        /*\n         * If we have an IP protocol to add to the header, but neither an\n         * IPv4 nor an IPv6 header was specified,  add an IPv4 header.\n         */\n        hdr_ip = true;\n    }\n\n    if (!have_hdr_ip_proto && (hdr_ip || hdr_ipv6)) {\n        /* if -4 or -6 option is specified without an IP protocol then fail */\n        cmdarg_err(\"IP protocol requires a next layer protocol number\");\n        return WS_EXIT_INVALID_OPTION;\n    }\n\n    if ((hdr_tcp || hdr_udp || hdr_sctp) && !(hdr_ip || hdr_ipv6)) {\n        /*\n         * If TCP (-T), UDP (-u) or SCTP (-s/-S) header options are specified\n         * but none of IPv4 (-4) or IPv6 (-6) options then add an IPv4 header\n         */\n        hdr_ip = true;\n    }\n\n    if (hdr_export_pdu && wtap_encap_type != WTAP_ENCAP_WIRESHARK_UPPER_PDU) {\n        cmdarg_err(\"Export PDU (-P) requires WIRESHARK_UPPER_PDU link type (252)\");\n        return WS_EXIT_INVALID_OPTION;\n    }\n\n    /* The other dummy headers require a IPv4 or IPv6 header. Allow\n     * encapsulation types of Ethernet (and add a Ethernet header in that\n     * case if we haven't already), or the appropriate raw IP types.\n     */\n    if (hdr_ip) {\n        switch (wtap_encap_type) {\n\n        case (WTAP_ENCAP_ETHERNET):\n            hdr_ethernet = true;\n            hdr_ethernet_proto = 0x0800;\n            break;\n\n        case (WTAP_ENCAP_RAW_IP):\n        case (WTAP_ENCAP_RAW_IP4):\n            break;\n\n        default:\n            cmdarg_err(\"Dummy IPv4 header not supported with encapsulation %s (%s)\", wtap_encap_description(wtap_encap_type), wtap_encap_name(wtap_encap_type));\n            return WS_EXIT_INVALID_OPTION;\n        }\n    } else if (hdr_ipv6) {\n        switch (wtap_encap_type) {\n\n        case (WTAP_ENCAP_ETHERNET):\n            hdr_ethernet = true;\n            hdr_ethernet_proto = 0x86DD;\n            break;\n\n        case (WTAP_ENCAP_RAW_IP):\n        case (WTAP_ENCAP_RAW_IP6):\n            break;\n\n        default:\n            cmdarg_err(\"Dummy IPv6 header not supported with encapsulation %s (%s)\", wtap_encap_description(wtap_encap_type), wtap_encap_name(wtap_encap_type));\n            return WS_EXIT_INVALID_OPTION;\n        }\n    }\n\n    if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n        /* An explicitly specified compression type overrides filename\n         * magic. (Should we allow specifying \"no\" compression with, e.g.\n         * a \".gz\" extension?) */\n        const char *sfx = strrchr(argv[ws_optind+1], '.');\n        if (sfx) {\n            compression_type = wtap_extension_to_compression_type(sfx + 1);\n        }\n    }\n\n    if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n        compression_type = WTAP_UNCOMPRESSED;\n    }\n\n    if (!wtap_can_write_compression_type(compression_type)) {\n        cmdarg_err(\"Output files can't be written as %s\",\n                wtap_compression_type_description(compression_type));\n        return WS_EXIT_INVALID_OPTION;\n    }\n\n    if (compression_type != WTAP_UNCOMPRESSED && !wtap_dump_can_compress(file_type_subtype)) {\n        cmdarg_err(\"The file format %s can't be written to output compressed format\",\n            wtap_file_type_subtype_name(file_type_subtype));\n        return WS_EXIT_INVALID_OPTION;\n    }\n\n    if (strcmp(argv[ws_optind], \"-\") != 0) {\n        input_filename = argv[ws_optind];\n        if (info->mode == TEXT_IMPORT_REGEX) {\n            info->regex.import_text_GMappedFile = g_mapped_file_new(input_filename, TRUE, &gerror);\n            if (gerror) {\n                cmdarg_err(\"%s\", gerror->message);\n                g_error_free(gerror);\n                return WS_EXIT_OPEN_ERROR;\n            }\n        } else {\n            input_file = ws_fopen(input_filename, \"rb\");\n            if (!input_file) {\n                open_failure_message(input_filename, errno, false);\n                return WS_EXIT_OPEN_ERROR;\n            }\n        }\n    } else {\n        if (info->mode == TEXT_IMPORT_REGEX) {\n            /* text_import_regex requires a memory mapped file, so this likely\n             * won't work, unless the user has redirected a file (not a FIFO)\n             * to stdin, though that's pretty silly and unnecessary.\n             * XXX: We could read until EOF, write it to a temp file, and then\n             * mmap that (ugh)?\n             */\n            info->regex.import_text_GMappedFile = g_mapped_file_new_from_fd(0, TRUE, &gerror);\n            if (gerror) {\n                cmdarg_err(\"%s\", gerror->message);\n                cmdarg_err(\"regex import requires memory-mapped I/O and cannot be used with terminals or pipes\");\n                g_error_free(gerror);\n                return WS_EXIT_INVALID_OPTION;\n            }\n        }\n        input_filename = \"Standard input\";\n        input_file = stdin;\n    }\n\n    params->encap = wtap_encap_type;\n    params->snaplen = max_offset;\n    if (file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_UNKNOWN) {\n        file_type_subtype = wtap_pcapng_file_type_subtype();\n    }\n    /* Request nanosecond precision. Most file formats only support one time\n     * precision and ignore this parameter (and the related options in the\n     * generated IDB), but it affects pcapng.\n     */\n    params->tsprec = WTAP_TSPREC_NSEC;\n    if ((ret = text_import_pre_open(params, file_type_subtype, input_filename, interface_name)) != EXIT_SUCCESS) {\n        cleanup_dump_params(params);\n        return ret;\n    }\n\n    if (strcmp(argv[ws_optind+1], \"-\") != 0) {\n        /* Write to a file.  Open the file. */\n        output_filename = argv[ws_optind+1];\n        wdh = wtap_dump_open(output_filename, file_type_subtype, compression_type, params, &err, &err_info);\n    } else {\n        /* Write to the standard output. */\n        output_filename = \"Standard output\";\n        wdh = wtap_dump_open_stdout(file_type_subtype, compression_type, params, &err, &err_info);\n    }\n\n    if (!wdh) {\n        cfile_dump_open_failure_message(output_filename, err, err_info,\n                                        file_type_subtype);\n        cleanup_dump_params(params);\n        return WS_EXIT_OPEN_ERROR;\n    }\n\n    info->import_text_filename = input_filename;\n    info->output_filename = output_filename;\n    info->hexdump.import_text_FILE = input_file;\n\n    info->encapsulation = wtap_encap_type;\n    info->wdh = wdh;\n\n    if (hdr_export_pdu) {\n        info->dummy_header_type = HEADER_EXPORT_PDU;\n    } else if (hdr_data_chunk) {\n        info->dummy_header_type = HEADER_SCTP_DATA;\n    } else if (hdr_sctp) {\n        info->dummy_header_type = HEADER_SCTP;\n    } else if (hdr_tcp) {\n        info->dummy_header_type = HEADER_TCP;\n    } else if (hdr_udp) {\n        info->dummy_header_type = HEADER_UDP;\n    } else if (hdr_ip) {\n        info->dummy_header_type = HEADER_IPV4;\n    } else if (hdr_ipv6) {\n        info->dummy_header_type = HEADER_IPV4;\n    } else if (hdr_ethernet) {\n        info->dummy_header_type = HEADER_ETH;\n    } else {\n        info->dummy_header_type = HEADER_NONE;\n    }\n    info->pid = hdr_ethernet_proto;\n    if (hdr_ip) {\n        info->ip_src_addr.ipv4 = hdr_ip_src_addr;\n        info->ip_dest_addr.ipv4 = hdr_ip_dest_addr;\n    } else if (hdr_ipv6) {\n        info->ipv6 = true;\n        info->ip_src_addr.ipv6 = hdr_ipv6_src_addr;\n        info->ip_dest_addr.ipv6 = hdr_ipv6_dest_addr;\n    }\n    info->protocol = hdr_ip_proto;\n    if (hdr_sctp) {\n        info->src_port = hdr_sctp_src;\n        info->dst_port = hdr_sctp_dest;\n    } else {\n        info->src_port = hdr_src_port;\n        info->dst_port = hdr_dest_port;\n    }\n    info->tag = hdr_sctp_tag;\n    info->ppi = hdr_data_chunk_ppid;\n\n    info->max_frame_length = max_offset;\n\n    /* Display summary of our state */\n    if (!quiet) {\n        fprintf(stderr, \"Input from: %s\\n\", input_filename);\n        fprintf(stderr, \"Output to: %s\\n\",  output_filename);\n        fprintf(stderr, \"Output format: %s\\n\", wtap_file_type_subtype_name(file_type_subtype));\n        if (hdr_ethernet) fprintf(stderr, \"Generate dummy Ethernet header: Protocol: 0x%0X\\n\",\n                                  hdr_ethernet_proto);\n        if (hdr_ip) fprintf(stderr, \"Generate dummy IP header: Protocol: %u\\n\",\n                            hdr_ip_proto);\n        if (hdr_ipv6) fprintf(stderr, \"Generate dummy IPv6 header: Protocol: %u\\n\",\n                            hdr_ip_proto);\n        if (hdr_udp) fprintf(stderr, \"Generate dummy UDP header: Source port: %u. Dest port: %u\\n\",\n                             hdr_src_port, hdr_dest_port);\n        if (hdr_tcp) fprintf(stderr, \"Generate dummy TCP header: Source port: %u. Dest port: %u\\n\",\n                             hdr_src_port, hdr_dest_port);\n        if (hdr_sctp) fprintf(stderr, \"Generate dummy SCTP header: Source port: %u. Dest port: %u. Tag: %u\\n\",\n                              hdr_sctp_src, hdr_sctp_dest, hdr_sctp_tag);\n        if (hdr_data_chunk) fprintf(stderr, \"Generate dummy DATA chunk header: TSN: %u. SID: %u. SSN: %u. PPID: %u\\n\",\n                                    hdr_data_chunk_tsn, hdr_data_chunk_sid, hdr_data_chunk_ssn, hdr_data_chunk_ppid);\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char  *configuration_init_error;\n    int ret = EXIT_SUCCESS;\n    text_import_info_t info;\n    wtap_dump_params params;\n    uint64_t bytes_written;\n\n    /* Set the program name. */\n    g_set_prgname(\"text2pcap\");\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, WS_EXIT_INVALID_OPTION);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n#ifdef _WIN32\n    create_app_running_mutex();\n#endif /* _WIN32 */\n\n    init_process_policies();\n\n    /*\n     * Make sure our plugin path is initialized for wtap_init.\n     */\n    configuration_init_error = configuration_init(argv[0]);\n    if (configuration_init_error != NULL) {\n        cmdarg_err(\"Can't get pathname of directory containing the text2pcap program: %s.\",\n                configuration_init_error);\n        g_free(configuration_init_error);\n    }\n\n    init_report_failure_message(\"text2pcap\");\n    wtap_init(true);\n\n    memset(&info, 0, sizeof(info));\n    wtap_dump_params_init(&params, NULL);\n    if ((ret = parse_options(argc, argv, &info, &params)) != EXIT_SUCCESS) {\n        goto clean_exit;\n    }\n\n    ws_assert(input_file != NULL || info.regex.import_text_GMappedFile != NULL);\n    ws_assert(wdh != NULL);\n\n    ret = text_import(&info);\n\n    if (ws_log_get_level() >= LOG_LEVEL_DEBUG)\n        fprintf(stderr, \"\\n-------------------------\\n\");\n    if (!quiet) {\n        bytes_written = wtap_get_bytes_dumped(wdh);\n        fprintf(stderr, \"Read %u potential packet%s, wrote %u packet%s (%\" PRIu64 \" byte%s including overhead).\\n\",\n                info.num_packets_read, plurality(info.num_packets_read, \"\", \"s\"),\n                info.num_packets_written, plurality(info.num_packets_written, \"\", \"s\"),\n                bytes_written, plurality(bytes_written, \"\", \"s\"));\n    }\nclean_exit:\n    if (input_file) {\n        fclose(input_file);\n    }\n    if (info.regex.import_text_GMappedFile) {\n        g_mapped_file_unref(info.regex.import_text_GMappedFile);\n    }\n    if (info.regex.format) {\n        g_regex_unref(info.regex.format);\n    }\n    if (wdh) {\n        int err;\n        char *err_info;\n        if (!wtap_dump_close(wdh, NULL, &err, &err_info)) {\n            cfile_close_failure_message(output_filename, err, err_info);\n            ret = 2;\n        }\n    }\n    cleanup_dump_params(&params);\n    return ret;\n}\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "text2pcap.h",
          "type": "blob",
          "size": 0.7734375,
          "content": "/** @file\n *\n * Utility to convert an ASCII hexdump into a libpcap-format capture file\n *\n * (c) Copyright 2001 Ashok Narayanan <ashokn@cisco.com>\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n\n#ifndef TEXT2PCAP_H\n#define TEXT2PCAP_H\n\ntypedef enum {\n    T_BYTE = 1,\n    T_OFFSET,\n    T_DIRECTIVE,\n    T_TEXT,\n    T_EOL\n} token_t;\n\nint parse_token(token_t token, char *str);\n\nint text2pcap_scan(void);\n\n#endif\n\n/*\n * Editor modelines  -  https://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
        },
        {
          "name": "tfshark.c",
          "type": "blob",
          "size": 71.2333984375,
          "content": "/* tfshark.c\n *\n * Text-mode variant of Fileshark, based off of TShark,\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n#include <limits.h>\n\n#include <ws_exit_codes.h>\n#include <wsutil/ws_getopt.h>\n\n#include <errno.h>\n\n#include <glib.h>\n\n#include <epan/exceptions.h>\n#include <epan/epan.h>\n\n#include <wsutil/clopts_common.h>\n#include <wsutil/cmdarg_err.h>\n#include <ui/urls.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/file_util.h>\n#include <wsutil/privileges.h>\n#include <wsutil/wslog.h>\n#include <wsutil/ws_assert.h>\n#include <cli_main.h>\n#include <wsutil/version_info.h>\n\n#include \"globals.h\"\n#include <epan/timestamp.h>\n#include <epan/packet.h>\n#ifdef HAVE_LUA\n#include <epan/wslua/init_wslua.h>\n#endif\n#include \"file.h\"\n#include <epan/disabled_protos.h>\n#include <epan/prefs.h>\n#include <epan/column.h>\n#include <epan/print.h>\n#include <epan/addr_resolv.h>\n#include \"ui/util.h\"\n#include \"ui/decode_as_utils.h\"\n#include \"ui/dissect_opts.h\"\n#include \"ui/failure_message.h\"\n#include <epan/epan_dissect.h>\n#include <epan/tap.h>\n#include <epan/stat_tap_ui.h>\n#include <epan/ex-opt.h>\n\n#include <wiretap/wtap-int.h>\n#include <wiretap/file_wrappers.h>\n\n#include <epan/funnel.h>\n\n#ifdef HAVE_PLUGINS\n#include <wsutil/plugins.h>\n#endif\n\n/* Additional exit codes */\n#define NO_FILE_SPECIFIED 1\n\ncapture_file cfile;\n\nstatic uint32_t cum_bytes;\nstatic frame_data ref_frame;\nstatic frame_data prev_dis_frame;\nstatic frame_data prev_cap_frame;\n\nstatic bool prefs_loaded;\n\nstatic bool perform_two_pass_analysis;\n\n/*\n * The way the packet decode is to be written.\n */\ntypedef enum {\n    WRITE_TEXT,   /* summary or detail text */\n    WRITE_XML,    /* PDML or PSML */\n    WRITE_FIELDS  /* User defined list of fields */\n    /* Add CSV and the like here */\n} output_action_e;\n\nstatic output_action_e output_action;\nstatic bool do_dissection;     /* true if we have to dissect each packet */\nstatic bool print_packet_info; /* true if we're to print packet information */\nstatic int print_summary = -1;    /* true if we're to print packet summary information */\nstatic bool print_details;     /* true if we're to print packet details information */\nstatic bool print_hex;         /* true if we're to print hex/ascii information */\nstatic bool line_buffered;\nstatic bool really_quiet;\n\nstatic print_format_e print_format = PR_FMT_TEXT;\nstatic print_stream_t *print_stream;\n\nstatic output_fields_t* output_fields;\n\n/* The line separator used between packets, changeable via the -S option */\nstatic const char *separator = \"\";\n\nstatic bool process_file(capture_file *);\nstatic bool process_packet_single_pass(capture_file *cf,\n        epan_dissect_t *edt, int64_t offset, wtap_rec *rec);\nstatic void show_print_file_io_error(int err);\nstatic bool write_preamble(capture_file *cf);\nstatic bool print_packet(capture_file *cf, epan_dissect_t *edt);\nstatic bool write_finale(void);\n\nstatic GHashTable *output_only_tables;\n\n#if 0\nstruct string_elem {\n    const char *sstr;   /* The short string */\n    const char *lstr;   /* The long string */\n};\n\nstatic int\nstring_compare(const void *a, const void *b)\n{\n    return strcmp(((const struct string_elem *)a)->sstr,\n            ((const struct string_elem *)b)->sstr);\n}\n\nstatic void\nstring_elem_print(void *data, void *not_used _U_)\n{\n    fprintf(stderr, \"    %s - %s\\n\",\n            ((struct string_elem *)data)->sstr,\n            ((struct string_elem *)data)->lstr);\n}\n#endif\n\nstatic void\nprint_usage(FILE *output)\n{\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: tfshark [options] ...\\n\");\n    fprintf(output, \"\\n\");\n\n    /*fprintf(output, \"\\n\");*/\n    fprintf(output, \"Input file:\\n\");\n    fprintf(output, \"  -r <infile>              set the filename to read from (no pipes or stdin)\\n\");\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Processing:\\n\");\n    fprintf(output, \"  -2                       perform a two-pass analysis\\n\");\n    fprintf(output, \"  -R <read filter>         packet Read filter in Wireshark display filter syntax\\n\");\n    fprintf(output, \"                           (requires -2)\\n\");\n    fprintf(output, \"  -Y <display filter>      packet displaY filter in Wireshark display filter\\n\");\n    fprintf(output, \"                           syntax\\n\");\n    fprintf(output, \"  -d %s ...\\n\", DECODE_AS_ARG_TEMPLATE);\n    fprintf(output, \"                           \\\"Decode As\\\", see the man page for details\\n\");\n    fprintf(output, \"                           Example: tcp.port==8888,http\\n\");\n\n    /*fprintf(output, \"\\n\");*/\n    fprintf(output, \"Output:\\n\");\n    fprintf(output, \"  -C <config profile>      start with specified configuration profile\\n\");\n    fprintf(output, \"  -V                       add output of packet tree        (Packet Details)\\n\");\n    fprintf(output, \"  -O <protocols>           Only show packet details of these protocols, comma\\n\");\n    fprintf(output, \"                           separated\\n\");\n    fprintf(output, \"  -S <separator>           the line separator to print between packets\\n\");\n    fprintf(output, \"  -x                       add output of hex and ASCII dump (Packet Bytes)\\n\");\n    fprintf(output, \"  -T pdml|ps|psml|text|fields\\n\");\n    fprintf(output, \"                           format of text output (def: text)\\n\");\n    fprintf(output, \"  -e <field>               field to print if -Tfields selected (e.g. tcp.port,\\n\");\n    fprintf(output, \"                           _ws.col.info)\\n\");\n    fprintf(output, \"                           this option can be repeated to print multiple fields\\n\");\n    fprintf(output, \"  -E<fieldsoption>=<value> set options for output when -Tfields selected:\\n\");\n    fprintf(output, \"     header=y|n            switch headers on and off\\n\");\n    fprintf(output, \"     separator=/t|/s|<char> select tab, space, printable character as separator\\n\");\n    fprintf(output, \"     occurrence=f|l|a      print first, last or all occurrences of each field\\n\");\n    fprintf(output, \"     aggregator=,|/s|<char> select comma, space, printable character as\\n\");\n    fprintf(output, \"                           aggregator\\n\");\n    fprintf(output, \"     quote=d|s|n           select double, single, no quotes for values\\n\");\n    fprintf(output, \"  -t a|ad|d|dd|e|r|u|ud    output format of time stamps (def: r: rel. to first)\\n\");\n    fprintf(output, \"  -u s|hms                 output format of seconds (def: s: seconds)\\n\");\n    fprintf(output, \"  -l                       flush standard output after each packet\\n\");\n    fprintf(output, \"  -q                       be more quiet on stdout (e.g. when using statistics)\\n\");\n    fprintf(output, \"  -Q                       only log true errors to stderr (quieter than -q)\\n\");\n    fprintf(output, \"  -X <key>:<value>         eXtension options, see the man page for details\\n\");\n    fprintf(output, \"  -z <statistics>          various statistics, see the man page for details\\n\");\n    fprintf(output, \"\\n\");\n\n    ws_log_print_usage(output);\n    fprintf(output, \"\\n\");\n\n    fprintf(output, \"Miscellaneous:\\n\");\n    fprintf(output, \"  -h                       display this help and exit\\n\");\n    fprintf(output, \"  -v                       display version info and exit\\n\");\n    fprintf(output, \"  -o <name>:<value> ...    override preference setting\\n\");\n    fprintf(output, \"  -K <keytab>              keytab file to use for kerberos decryption\\n\");\n    fprintf(output, \"  -G [report]              dump one of several available reports and exit\\n\");\n    fprintf(output, \"                           default report=\\\"fields\\\"\\n\");\n    fprintf(output, \"                           use \\\"-G ?\\\" for more help\\n\");\n}\n\nstatic void\nglossary_option_help(void)\n{\n    FILE *output;\n\n    output = stdout;\n\n    fprintf(output, \"%s\\n\", get_appname_and_version());\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: tfshark -G [report]\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Glossary table reports:\\n\");\n    fprintf(output, \"  -G column-formats        dump column format codes and exit\\n\");\n    fprintf(output, \"  -G decodes               dump \\\"layer type\\\"/\\\"decode as\\\" associations and exit\\n\");\n    fprintf(output, \"  -G dissector-tables      dump dissector table names, types, and properties\\n\");\n    fprintf(output, \"  -G fields                dump fields glossary and exit\\n\");\n    fprintf(output, \"  -G ftypes                dump field type basic and descriptive names\\n\");\n    fprintf(output, \"  -G heuristic-decodes     dump heuristic dissector tables\\n\");\n    fprintf(output, \"  -G plugins               dump installed plugins and exit\\n\");\n    fprintf(output, \"  -G protocols             dump protocols in registration database and exit\\n\");\n    fprintf(output, \"  -G values                dump value, range, true/false strings and exit\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Preference reports:\\n\");\n    fprintf(output, \"  -G currentprefs          dump current preferences and exit\\n\");\n    fprintf(output, \"  -G defaultprefs          dump default preferences and exit\\n\");\n    fprintf(output, \"\\n\");\n}\n\nstatic void\nprint_current_user(void)\n{\n    char *cur_user, *cur_group;\n\n    if (started_with_special_privs()) {\n        cur_user = get_cur_username();\n        cur_group = get_cur_groupname();\n        fprintf(stderr, \"Running as user \\\"%s\\\" and group \\\"%s\\\".\",\n                cur_user, cur_group);\n        g_free(cur_user);\n        g_free(cur_group);\n        if (running_with_special_privs()) {\n            fprintf(stderr, \" This could be dangerous.\");\n        }\n        fprintf(stderr, \"\\n\");\n    }\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char                *configuration_init_error;\n    int                  opt;\n    static const struct ws_option long_options[] = {\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        {0, 0, 0, 0 }\n    };\n    bool                 arg_error = false;\n\n    int                  err;\n    volatile bool        success;\n    volatile int         exit_status = 0;\n    bool                 quiet = false;\n    char                *volatile cf_name = NULL;\n    char                *rfilter = NULL;\n    char                *dfilter = NULL;\n    dfilter_t           *rfcode = NULL;\n    dfilter_t           *dfcode = NULL;\n    df_error_t          *df_err;\n    e_prefs             *prefs_p;\n    char                *output_only = NULL;\n\n    /*\n     * The leading + ensures that getopt_long() does not permute the argv[]\n     * entries.\n     *\n     * We have to make sure that the first getopt_long() preserves the content\n     * of argv[] for the subsequent getopt_long() call.\n     *\n     * We use getopt_long() in both cases to ensure that we're using a routine\n     * whose permutation behavior we can control in the same fashion on all\n     * platforms, and so that, if we ever need to process a long argument before\n     * doing further initialization, we can do so.\n     *\n     * Glibc and Solaris libc document that a leading + disables permutation\n     * of options, regardless of whether POSIXLY_CORRECT is set or not; *BSD\n     * and macOS don't document it, but do so anyway.\n     *\n     * We do *not* use a leading - because the behavior of a leading - is\n     * platform-dependent.\n     */\n#define OPTSTRING \"+2C:d:e:E:hK:lo:O:qQr:R:S:t:T:u:vVxX:Y:z:\"\n\n    static const char    optstring[] = OPTSTRING;\n\n    /* Set the program name. */\n    g_set_prgname(\"tfshark\");\n\n    /*\n     * Set the C-language locale to the native environment and set the\n     * code page to UTF-8 on Windows.\n     */\n#ifdef _WIN32\n    setlocale(LC_ALL, \".UTF-8\");\n#else\n    setlocale(LC_ALL, \"\");\n#endif\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, WS_EXIT_INVALID_OPTION);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n\n#ifdef _WIN32\n    create_app_running_mutex();\n#endif /* _WIN32 */\n\n    /*\n     * Get credential information for later use, and drop privileges\n     * before doing anything else.\n     * Let the user know if anything happened.\n     */\n    init_process_policies();\n    relinquish_special_privs_perm();\n    print_current_user();\n\n    /*\n     * Attempt to get the pathname of the directory containing the\n     * executable file.\n     */\n    configuration_init_error = configuration_init(argv[0]);\n    if (configuration_init_error != NULL) {\n        fprintf(stderr,\n                \"tfshark: Can't get pathname of directory containing the tfshark program: %s.\\n\",\n                configuration_init_error);\n        g_free(configuration_init_error);\n    }\n\n    initialize_funnel_ops();\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"TFShark\",\n                         epan_gather_compile_info,\n                         epan_gather_runtime_info);\n    /*\n     * In order to have the -X opts assigned before the wslua machine starts\n     * we need to call getopts before epan_init() gets called.\n     *\n     * In order to handle, for example, -o options, we also need to call it\n     * *after* epan_init() gets called, so that the dissectors have had a\n     * chance to register their preferences.\n     *\n     * XXX - can we do this all with one getopt_long() call, saving the\n     * arguments we can't handle until after initializing libwireshark,\n     * and then process them after initializing libwireshark?\n     */\n    ws_opterr = 0;\n\n    while ((opt = ws_getopt_long(argc, argv, optstring, long_options, NULL)) != -1) {\n        switch (opt) {\n            case 'C':        /* Configuration Profile */\n                if (profile_exists (ws_optarg, false)) {\n                    set_profile_name (ws_optarg);\n                } else if (profile_exists (ws_optarg, true)) {\n                    char  *pf_dir_path, *pf_dir_path2, *pf_filename;\n                    /* Copy from global profile */\n                    if (create_persconffile_profile(ws_optarg, &pf_dir_path) == -1) {\n                        cmdarg_err(\"Can't create directory\\n\\\"%s\\\":\\n%s.\",\n                            pf_dir_path, g_strerror(errno));\n\n                        g_free(pf_dir_path);\n                        exit_status = WS_EXIT_INVALID_FILE;\n                        goto clean_exit;\n                    }\n                    if (copy_persconffile_profile(ws_optarg, ws_optarg, true, &pf_filename,\n                            &pf_dir_path, &pf_dir_path2) == -1) {\n                        cmdarg_err(\"Can't copy file \\\"%s\\\" in directory\\n\\\"%s\\\" to\\n\\\"%s\\\":\\n%s.\",\n                            pf_filename, pf_dir_path2, pf_dir_path, g_strerror(errno));\n\n                        g_free(pf_filename);\n                        g_free(pf_dir_path);\n                        g_free(pf_dir_path2);\n                        exit_status = WS_EXIT_INVALID_FILE;\n                        goto clean_exit;\n                    }\n                    set_profile_name (ws_optarg);\n                } else {\n                    cmdarg_err(\"Configuration Profile \\\"%s\\\" does not exist\", ws_optarg);\n                    return 1;\n                }\n                break;\n            case 'O':        /* Only output these protocols */\n                output_only = g_strdup(ws_optarg);\n                /* FALLTHROUGH */\n            case 'V':        /* Verbose */\n                print_details = true;\n                print_packet_info = true;\n                break;\n            case 'x':        /* Print packet data in hex (and ASCII) */\n                print_hex = true;\n                /*  The user asked for hex output, so let's ensure they get it,\n                 *  even if they're writing to a file.\n                 */\n                print_packet_info = true;\n                break;\n            case 'X':\n                ex_opt_add(ws_optarg);\n                break;\n            default:\n                break;\n        }\n    }\n\n    /*\n     * Print packet summary information is the default, unless either -V or -x\n     * were specified.  Note that this is new behavior, which\n     * allows for the possibility of printing only hex/ascii output without\n     * necessarily requiring that either the summary or details be printed too.\n     */\n    if (print_summary == -1)\n        print_summary = (print_details || print_hex) ? false : true;\n\n    init_report_failure_message(\"tfshark\");\n\n    timestamp_set_type(TS_RELATIVE);\n    timestamp_set_precision(TS_PREC_AUTO);\n    timestamp_set_seconds_type(TS_SECONDS_DEFAULT);\n\n    /*\n     * Libwiretap must be initialized before libwireshark is, so that\n     * dissection-time handlers for file-type-dependent blocks can\n     * register using the file type/subtype value for the file type.\n     *\n     * XXX - TFShark shouldn't use libwiretap, as it's a file dissector\n     * and should read all files as raw bytes and then try to dissect them.\n     * It needs to handle file types its own way, because we would want\n     * to support dissecting file-type-specific blocks when dissecting\n     * capture files, but that mechanism should support plugins for\n     * other files, too, if *their* formats are extensible.\n     */\n    wtap_init(true);\n\n    /* Register all dissectors; we must do this before checking for the\n       \"-G\" flag, as the \"-G\" flag dumps information registered by the\n       dissectors, and we must do it before we read the preferences, in\n       case any dissectors register preferences. */\n    if (!epan_init(NULL, NULL, true)) {\n        exit_status = WS_EXIT_INIT_FAILED;\n        goto clean_exit;\n    }\n\n    /* Register all tap listeners; we do this before we parse the arguments,\n       as the \"-z\" argument can specify a registered tap. */\n\n    /* we register the plugin taps before the other taps because\n       stats_tree taps plugins will be registered as tap listeners\n       by stats_tree_stat.c and need to registered before that */\n\n    /* XXX Disable tap registration for now until we can get tfshark set up with\n     * its own set of taps and the necessary registration function etc.\n     register_all_tap_listeners();\n     */\n\n    /* If invoked with the \"-G\" flag, we dump out information based on\n       the argument to the \"-G\" flag; if no argument is specified,\n       for backwards compatibility we dump out a glossary of display\n       filter symbols.\n\n       XXX - we do this here, for now, to support \"-G\" with no arguments.\n       If none of our build or other processes uses \"-G\" with no arguments,\n       we can just process it with the other arguments. */\n    if (argc >= 2 && strcmp(argv[1], \"-G\") == 0) {\n        proto_initialize_all_prefixes();\n\n        if (argc == 2)\n            proto_registrar_dump_fields();\n        else {\n            if (strcmp(argv[2], \"column-formats\") == 0)\n                column_dump_column_formats();\n            else if (strcmp(argv[2], \"currentprefs\") == 0) {\n                epan_load_settings();\n                write_prefs(NULL);\n            }\n            else if (strcmp(argv[2], \"decodes\") == 0)\n                dissector_dump_decodes();\n            else if (strcmp(argv[2], \"defaultprefs\") == 0)\n                write_prefs(NULL);\n            else if (strcmp(argv[2], \"dissector-tables\") == 0)\n                dissector_dump_dissector_tables();\n            else if (strcmp(argv[2], \"fields\") == 0)\n                proto_registrar_dump_fields();\n            else if (strcmp(argv[2], \"ftypes\") == 0)\n                proto_registrar_dump_ftypes();\n            else if (strcmp(argv[2], \"heuristic-decodes\") == 0)\n                dissector_dump_heur_decodes();\n            else if (strcmp(argv[2], \"plugins\") == 0) {\n#ifdef HAVE_PLUGINS\n                plugins_dump_all();\n#endif\n#ifdef HAVE_LUA\n                wslua_plugins_dump_all();\n#endif\n            }\n            else if (strcmp(argv[2], \"protocols\") == 0)\n                proto_registrar_dump_protocols();\n            else if (strcmp(argv[2], \"values\") == 0)\n                proto_registrar_dump_values();\n            else if (strcmp(argv[2], \"?\") == 0)\n                glossary_option_help();\n            else if (strcmp(argv[2], \"-?\") == 0)\n                glossary_option_help();\n            else {\n                cmdarg_err(\"Invalid \\\"%s\\\" option for -G flag, enter -G ? for more help.\", argv[2]);\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n        }\n        goto clean_exit;\n    }\n\n    /* Load libwireshark settings from the current profile. */\n    prefs_p = epan_load_settings();\n    prefs_loaded = true;\n\n    cap_file_init(&cfile);\n\n    /* Print format defaults to this. */\n    print_format = PR_FMT_TEXT;\n\n    output_fields = output_fields_new();\n\n    /*\n     * To reset the options parser, set ws_optreset to 1 and set ws_optind to 1.\n     *\n     * Also reset ws_opterr to 1, so that error messages are printed by\n     * getopt_long().\n     */\n    ws_optreset = 1;\n    ws_optind = 1;\n    ws_opterr = 1;\n\n    /* Now get our args */\n    while ((opt = ws_getopt_long(argc, argv, optstring, long_options, NULL)) != -1) {\n        switch (opt) {\n            case '2':        /* Perform two-pass analysis */\n                perform_two_pass_analysis = true;\n                break;\n            case 'C':\n                /* already processed; just ignore it now */\n                break;\n            case 'e':\n                /* Field entry */\n                output_fields_add(output_fields, ws_optarg);\n                break;\n            case 'E':\n                /* Field option */\n                if (!output_fields_set_option(output_fields, ws_optarg)) {\n                    cmdarg_err(\"\\\"%s\\\" is not a valid field output option=value pair.\", ws_optarg);\n                    output_fields_list_options(stderr);\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n\n            case 'h':        /* Print help and exit */\n                show_help_header(\"Analyze file structure.\");\n                print_usage(stdout);\n                goto clean_exit;\n                break;\n            case 'l':        /* \"Line-buffer\" standard output */\n                /* The ANSI C standard does not appear to *require* that a\n                   line-buffered stream be flushed to the host environment\n                   whenever a newline is written, it just says that, on such a\n                   stream, characters \"are intended to be transmitted to or\n                   from the host environment as a block when a new-line\n                   character is encountered\".\n\n                   The Visual C++ 6.0 C implementation doesn't do what is\n                   intended; even if you set a stream to be line-buffered, it\n                   still doesn't flush the buffer at the end of every line.\n\n                   The whole reason for the \"-l\" flag in either tcpdump or\n                   TShark is to allow the output of a live capture to be piped\n                   to a program or script and to have that script see the\n                   information for the packet as soon as it's printed, rather\n                   than having to wait until a standard I/O buffer fills up.\n\n                   So, if the \"-l\" flag is specified, we flush the standard\n                   output at the end of a packet.  This will do the right thing\n                   if we're printing packet summary lines, and, as we print the\n                   entire protocol tree for a single packet without waiting for\n                   anything to happen, it should be as good as line-buffered\n                   mode if we're printing protocol trees - arguably even\n                   better, as it may do fewer writes. */\n                line_buffered = true;\n                break;\n            case 'o':        /* Override preference from command line */\n                {\n                    char *errmsg = NULL;\n\n                    switch (prefs_set_pref(ws_optarg, &errmsg)) {\n\n                        case PREFS_SET_OK:\n                            break;\n\n                        case PREFS_SET_SYNTAX_ERR:\n                            cmdarg_err(\"Invalid -o flag \\\"%s\\\"%s%s\", ws_optarg,\n                                    errmsg ? \": \" : \"\", errmsg ? errmsg : \"\");\n                            g_free(errmsg);\n                            exit_status = WS_EXIT_INVALID_OPTION;\n                            goto clean_exit;\n                            break;\n\n                        case PREFS_SET_NO_SUCH_PREF:\n                            cmdarg_err(\"-o flag \\\"%s\\\" specifies unknown preference\", ws_optarg);\n                            exit_status = WS_EXIT_INVALID_OPTION;\n                            goto clean_exit;\n                            break;\n\n                        case PREFS_SET_OBSOLETE:\n                            cmdarg_err(\"-o flag \\\"%s\\\" specifies obsolete preference\", ws_optarg);\n                            exit_status = WS_EXIT_INVALID_OPTION;\n                            goto clean_exit;\n                            break;\n                    }\n                    break;\n                }\n            case 'q':        /* Quiet */\n                quiet = true;\n                break;\n            case 'Q':        /* Really quiet */\n                quiet = true;\n                really_quiet = true;\n                break;\n            case 'r':        /* Read capture file x */\n                cf_name = g_strdup(ws_optarg);\n                break;\n            case 'R':        /* Read file filter */\n                rfilter = ws_optarg;\n                break;\n            case 'S':        /* Set the line Separator to be printed between packets */\n                separator = g_strdup(ws_optarg);\n                break;\n            case 'T':        /* printing Type */\n                if (strcmp(ws_optarg, \"text\") == 0) {\n                    output_action = WRITE_TEXT;\n                    print_format = PR_FMT_TEXT;\n                } else if (strcmp(ws_optarg, \"ps\") == 0) {\n                    output_action = WRITE_TEXT;\n                    print_format = PR_FMT_PS;\n                } else if (strcmp(ws_optarg, \"pdml\") == 0) {\n                    output_action = WRITE_XML;\n                    print_details = true;   /* Need details */\n                    print_summary = false;  /* Don't allow summary */\n                } else if (strcmp(ws_optarg, \"psml\") == 0) {\n                    output_action = WRITE_XML;\n                    print_details = false;  /* Don't allow details */\n                    print_summary = true;   /* Need summary */\n                } else if (strcmp(ws_optarg, \"fields\") == 0) {\n                    output_action = WRITE_FIELDS;\n                    print_details = true;   /* Need full tree info */\n                    print_summary = false;  /* Don't allow summary */\n                } else {\n                    cmdarg_err(\"Invalid -T parameter \\\"%s\\\"; it must be one of:\", ws_optarg);                   /* x */\n                    cmdarg_err_cont(\"\\t\\\"fields\\\" The values of fields specified with the -e option, in a form\\n\"\n                                    \"\\t         specified by the -E option.\\n\"\n                                    \"\\t\\\"pdml\\\"   Packet Details Markup Language, an XML-based format for the\\n\"\n                                    \"\\t         details of a decoded packet. This information is equivalent to\\n\"\n                                    \"\\t         the packet details printed with the -V flag.\\n\"\n                                    \"\\t\\\"ps\\\"     PostScript for a human-readable one-line summary of each of\\n\"\n                                    \"\\t         the packets, or a multi-line view of the details of each of\\n\"\n                                    \"\\t         the packets, depending on whether the -V flag was specified.\\n\"\n                                    \"\\t\\\"psml\\\"   Packet Summary Markup Language, an XML-based format for the\\n\"\n                                    \"\\t         summary information of a decoded packet. This information is\\n\"\n                                    \"\\t         equivalent to the information shown in the one-line summary\\n\"\n                                    \"\\t         printed by default.\\n\"\n                                    \"\\t\\\"text\\\"   Text of a human-readable one-line summary of each of the\\n\"\n                                    \"\\t         packets, or a multi-line view of the details of each of the\\n\"\n                                    \"\\t         packets, depending on whether the -V flag was specified.\\n\"\n                                    \"\\t         This is the default.\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'v':         /* Show version and exit */\n                show_version();\n                goto clean_exit;\n            case 'O':        /* Only output these protocols */\n                /* already processed; just ignore it now */\n                break;\n            case 'V':        /* Verbose */\n                /* already processed; just ignore it now */\n                break;\n            case 'x':        /* Print packet data in hex (and ASCII) */\n                /* already processed; just ignore it now */\n                break;\n            case 'X':\n                /* already processed; just ignore it now */\n                break;\n            case 'Y':\n                dfilter = ws_optarg;\n                break;\n            case 'z':\n                /* We won't call the init function for the stat this soon\n                   as it would disallow MATE's fields (which are registered\n                   by the preferences set callback) from being used as\n                   part of a tap filter.  Instead, we just add the argument\n                   to a list of stat arguments. */\n                if (strcmp(\"help\", ws_optarg) == 0) {\n                    fprintf(stderr, \"tfshark: The available statistics for the \\\"-z\\\" option are:\\n\");\n                    list_stat_cmd_args();\n                    goto clean_exit;\n                }\n                if (!process_stat_cmd_arg(ws_optarg)) {\n                    cmdarg_err(\"Invalid -z argument \\\"%s\\\"; it must be one of:\", ws_optarg);\n                    list_stat_cmd_args();\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'd':        /* Decode as rule */\n            case 'K':        /* Kerberos keytab file */\n            case 't':        /* Time stamp type */\n            case 'u':        /* Seconds type */\n            case LONGOPT_DISABLE_PROTOCOL: /* disable dissection of protocol */\n            case LONGOPT_ENABLE_HEURISTIC: /* enable heuristic dissection of protocol */\n            case LONGOPT_DISABLE_HEURISTIC: /* disable heuristic dissection of protocol */\n            case LONGOPT_ENABLE_PROTOCOL: /* enable dissection of protocol (that is disabled by default) */\n                if (!dissect_opts_handle_opt(opt, ws_optarg)) {\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            default:\n            case '?':        /* Bad flag - print usage message */\n                print_usage(stderr);\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n                break;\n        }\n    }\n\n    /* If we specified output fields, but not the output field type... */\n    if (WRITE_FIELDS != output_action && 0 != output_fields_num_fields(output_fields)) {\n        cmdarg_err(\"Output fields were specified with \\\"-e\\\", \"\n                \"but \\\"-Tfields\\\" was not specified.\");\n        return 1;\n    } else if (WRITE_FIELDS == output_action && 0 == output_fields_num_fields(output_fields)) {\n        cmdarg_err(\"\\\"-Tfields\\\" was specified, but no fields were \"\n                \"specified with \\\"-e\\\".\");\n\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    /* We require a -r flag specifying a file to read. */\n    if (cf_name == NULL) {\n        cmdarg_err(\"A file to read must be specified with \\\"-r\\\".\");\n        exit_status = NO_FILE_SPECIFIED;\n        goto clean_exit;\n    }\n\n    /* If no display filter has been specified, and there are still command-\n       line arguments, treat them as the tokens of a display filter. */\n    if (ws_optind < argc) {\n        if (dfilter != NULL) {\n            cmdarg_err(\"Display filters were specified both with \\\"-Y\\\" \"\n                    \"and with additional command-line arguments.\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n        dfilter = get_args_as_string(argc, argv, ws_optind);\n    }\n\n    /* if \"-q\" wasn't specified, we should print packet information */\n    if (!quiet)\n        print_packet_info = true;\n\n    if (arg_error) {\n        print_usage(stderr);\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (print_hex) {\n        if (output_action != WRITE_TEXT) {\n            cmdarg_err(\"Raw packet hex data can only be printed as text or PostScript\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n    }\n\n    if (output_only != NULL) {\n        char *ps;\n\n        if (!print_details) {\n            cmdarg_err(\"-O requires -V\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n\n        output_only_tables = g_hash_table_new (g_str_hash, g_str_equal);\n        for (ps = strtok (output_only, \",\"); ps; ps = strtok (NULL, \",\")) {\n            g_hash_table_insert(output_only_tables, (void *)ps, (void *)ps);\n        }\n    }\n\n    if (rfilter != NULL && !perform_two_pass_analysis) {\n        cmdarg_err(\"-R without -2 is deprecated. For single-pass filtering use -Y.\");\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    /* Notify all registered modules that have had any of their preferences\n       changed either from one of the preferences file or from the command\n       line that their preferences have changed. */\n    prefs_apply_all();\n\n    /*\n     * Enabled and disabled protocols and heuristic dissectors as per\n     * command-line options.\n     */\n    if (!setup_enabled_and_disabled_protocols()) {\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    /* Build the column format array */\n    build_column_format_array(&cfile.cinfo, prefs_p->num_cols, true);\n\n    if (rfilter != NULL) {\n        if (!dfilter_compile(rfilter, &rfcode, &df_err)) {\n            cmdarg_err(\"%s\", df_err->msg);\n            df_error_free(&df_err);\n            exit_status = WS_EXIT_INVALID_FILTER;\n            goto clean_exit;\n        }\n    }\n    cfile.rfcode = rfcode;\n\n    if (dfilter != NULL) {\n        if (!dfilter_compile(dfilter, &dfcode, &df_err)) {\n            cmdarg_err(\"%s\", df_err->msg);\n            df_error_free(&df_err);\n            exit_status = WS_EXIT_INVALID_FILTER;\n            goto clean_exit;\n        }\n    }\n    cfile.dfcode = dfcode;\n\n    if (print_packet_info) {\n        /* If we're printing as text or PostScript, we have\n           to create a print stream. */\n        if (output_action == WRITE_TEXT) {\n            switch (print_format) {\n\n                case PR_FMT_TEXT:\n                    print_stream = print_stream_text_stdio_new(stdout);\n                    break;\n\n                case PR_FMT_PS:\n                    print_stream = print_stream_ps_stdio_new(stdout);\n                    break;\n\n                default:\n                    ws_assert_not_reached();\n            }\n        }\n    }\n\n    /* We have to dissect each packet if:\n\n       we're printing information about each packet;\n\n       we're using a read filter on the packets;\n\n       we're using a display filter on the packets;\n\n       we're using any taps that need dissection. */\n    do_dissection = print_packet_info || rfcode || dfcode || tap_listeners_require_dissection();\n\n    /*\n     * Read the file.\n     */\n\n    /* TODO: if tfshark is ever changed to give the user a choice of which\n       open_routine reader to use, then the following needs to change. */\n    if (cf_open(&cfile, cf_name, WTAP_TYPE_AUTO, false, &err) != CF_OK) {\n        exit_status = WS_EXIT_OPEN_ERROR;\n        goto clean_exit;\n    }\n\n    /* Start statistics taps; we do so after successfully opening the\n       capture file, so we know we have something to compute stats\n       on, and after registering all dissectors, so that MATE will\n       have registered its field array so we can have a tap filter\n       with one of MATE's late-registered fields as part of the\n       filter. */\n    start_requested_stats();\n\n    /* Process the packets in the file */\n    TRY {\n        /* XXX - for now there is only 1 packet */\n        success = process_file(&cfile);\n    }\n    CATCH(OutOfMemoryError) {\n        fprintf(stderr,\n                \"Out Of Memory.\\n\"\n                \"\\n\"\n                \"Sorry, but TFShark has to terminate now.\\n\"\n                \"\\n\"\n                \"Some infos / workarounds can be found at:\\n\"\n                WS_WIKI_URL(\"KnownBugs/OutOfMemory\") \"\\n\");\n        success = false;\n    }\n    ENDTRY;\n\n    if (!success) {\n        /* We still dump out the results of taps, etc., as we might have\n           read some packets; however, we exit with an error status. */\n        exit_status = 2;\n    }\n\n    g_free(cf_name);\n\n    if (cfile.provider.frames != NULL) {\n        free_frame_data_sequence(cfile.provider.frames);\n        cfile.provider.frames = NULL;\n    }\n\n    draw_tap_listeners(true);\n    funnel_dump_all_text_windows();\n\nclean_exit:\n    destroy_print_stream(print_stream);\n    epan_free(cfile.epan);\n    epan_cleanup();\n\n    output_fields_free(output_fields);\n    output_fields = NULL;\n\n    col_cleanup(&cfile.cinfo);\n    wtap_cleanup();\n    return exit_status;\n}\n\nstatic const char *\nno_interface_name(struct packet_provider_data *prov _U_, uint32_t interface_id _U_, unsigned section_number _U_)\n{\n    return \"\";\n}\n\nstatic epan_t *\ntfshark_epan_new(capture_file *cf)\n{\n    static const struct packet_provider_funcs funcs = {\n        /* XXX - there should be no need for time stamps */\n        cap_file_provider_get_frame_ts,\n        no_interface_name,\n        NULL,\n        NULL,\n    };\n\n    return epan_new(&cf->provider, &funcs);\n}\n\nstatic bool\nprocess_packet_first_pass(capture_file *cf, epan_dissect_t *edt,\n        int64_t offset, wtap_rec *rec)\n{\n    frame_data     fdlocal;\n    uint32_t       framenum;\n    bool           passed;\n\n    /* The frame number of this packet is one more than the count of\n       frames in this packet. */\n    framenum = cf->count + 1;\n\n    /* If we're not running a display filter and we're not printing any\n       packet information, we don't need to do a dissection. This means\n       that all packets can be marked as 'passed'. */\n    passed = true;\n\n    frame_data_init(&fdlocal, framenum, rec, offset, cum_bytes);\n\n    /* If we're going to print packet information, or we're going to\n       run a read filter, or display filter, or we're going to process taps, set up to\n       do a dissection and do so. */\n    if (edt) {\n        /* If we're running a read filter, prime the epan_dissect_t with that\n           filter. */\n        if (cf->rfcode)\n            epan_dissect_prime_with_dfilter(edt, cf->rfcode);\n\n        /* This is the first pass, so prime the epan_dissect_t with the\n           hfids postdissectors want on the first pass. */\n        prime_epan_dissect_with_postdissector_wanted_hfids(edt);\n\n        frame_data_set_before_dissect(&fdlocal, &cf->elapsed_time,\n                &cf->provider.ref, cf->provider.prev_dis);\n        if (cf->provider.ref == &fdlocal) {\n            ref_frame = fdlocal;\n            cf->provider.ref = &ref_frame;\n        }\n\n        epan_dissect_file_run(edt, rec,  &fdlocal, NULL);\n\n        /* Run the read filter if we have one. */\n        if (cf->rfcode)\n            passed = dfilter_apply_edt(cf->rfcode, edt);\n    }\n\n    if (passed) {\n        frame_data_set_after_dissect(&fdlocal, &cum_bytes);\n        cf->provider.prev_cap = cf->provider.prev_dis = frame_data_sequence_add(cf->provider.frames, &fdlocal);\n\n        /* If we're not doing dissection then there won't be any dependent frames.\n         * More importantly, edt.pi.fd.dependent_frames won't be initialized because\n         * epan hasn't been initialized.\n         */\n        if (edt && edt->pi.fd->dependent_frames) {\n            g_hash_table_foreach(edt->pi.fd->dependent_frames, find_and_mark_frame_depended_upon, cf->provider.frames);\n        }\n\n        cf->count++;\n    } else {\n        /* if we don't add it to the frame_data_sequence, clean it up right now\n         * to avoid leaks */\n        frame_data_destroy(&fdlocal);\n    }\n\n    if (edt)\n        epan_dissect_reset(edt);\n\n    return passed;\n}\n\nstatic bool\nprocess_packet_second_pass(capture_file *cf, epan_dissect_t *edt,\n        frame_data *fdata, wtap_rec *rec)\n{\n    column_info    *cinfo;\n    bool            passed;\n\n    /* If we're not running a display filter and we're not printing any\n       packet information, we don't need to do a dissection. This means\n       that all packets can be marked as 'passed'. */\n    passed = true;\n\n    /* If we're going to print packet information, or we're going to\n       run a read filter, or we're going to process taps, set up to\n       do a dissection and do so. */\n    if (edt) {\n\n        /* If we're running a display filter, prime the epan_dissect_t with that\n           filter. */\n        if (cf->dfcode)\n            epan_dissect_prime_with_dfilter(edt, cf->dfcode);\n\n        /* This is the first and only pass, so prime the epan_dissect_t\n           with the hfids postdissectors want on the first pass. */\n        prime_epan_dissect_with_postdissector_wanted_hfids(edt);\n\n        col_custom_prime_edt(edt, &cf->cinfo);\n\n        /* We only need the columns if either\n           1) some tap needs the columns\n           or\n           2) we're printing packet info but we're *not* verbose; in verbose\n           mode, we print the protocol tree, not the protocol summary.\n           */\n        if ((tap_listeners_require_columns()) || (print_packet_info && print_summary))\n            cinfo = &cf->cinfo;\n        else\n            cinfo = NULL;\n\n        frame_data_set_before_dissect(fdata, &cf->elapsed_time,\n                &cf->provider.ref, cf->provider.prev_dis);\n        if (cf->provider.ref == fdata) {\n            ref_frame = *fdata;\n            cf->provider.ref = &ref_frame;\n        }\n\n        epan_dissect_file_run_with_taps(edt, rec, fdata, cinfo);\n\n        /* Run the read/display filter if we have one. */\n        if (cf->dfcode)\n            passed = dfilter_apply_edt(cf->dfcode, edt);\n    }\n\n    if (passed) {\n        frame_data_set_after_dissect(fdata, &cum_bytes);\n        /* Process this packet. */\n        if (print_packet_info) {\n            /* We're printing packet information; print the information for\n               this packet. */\n            print_packet(cf, edt);\n\n            /* If we're doing \"line-buffering\", flush the standard output\n               after every packet.  See the comment above, for the \"-l\"\n               option, for an explanation of why we do that. */\n            if (line_buffered)\n                fflush(stdout);\n\n            if (ferror(stdout)) {\n                show_print_file_io_error(errno);\n                return false;\n            }\n        }\n        cf->provider.prev_dis = fdata;\n    }\n    cf->provider.prev_cap = fdata;\n\n    if (edt) {\n        epan_dissect_reset(edt);\n    }\n    return passed || fdata->dependent_of_displayed;\n}\n\n/*\n * XXX - this routine doesn't read in files larger than UINT_MAX bytes;\n * it would need to loop over the file.\n *\n * But if we read the entire file in, that might, for sufficiently\n * large files, eat up address space or other resources (especially\n * on 32-bit platforms).\n */\nstatic bool\nfull_file_read(capture_file *cf, wtap_rec *rec, int *err, char **err_info)\n{\n    int64_t file_size;\n    int packet_size = 0;\n    const int block_size = 1024 * 1024;\n\n    if ((file_size = wtap_file_size(cf->provider.wth, err)) == -1)\n        return false;\n\n    if (file_size > INT_MAX) {\n        /*\n         * Avoid allocating space for an immensely-large file.\n         */\n        *err = WTAP_ERR_BAD_FILE;\n        *err_info = ws_strdup_printf(\"File is %\" PRId64 \" bytes in size, bigger than maximum of %u\",\n                file_size, INT_MAX);\n        return false;\n    }\n\n    /*\n     * Compressed files might expand to a larger size than the actual file\n     * size. Try to read the full size and then read in smaller increments\n     * to avoid frequent memory reallocations.\n     */\n    int buffer_size = block_size * (1 + (int)file_size / block_size);\n    for (;;) {\n        if (buffer_size <= 0) {\n            *err = WTAP_ERR_BAD_FILE;\n            *err_info = ws_strdup_printf(\"%s: Uncompressed file is bigger than maximum of %u\",\n                    wtap_encap_name(cf->provider.wth->file_encap), INT_MAX);\n            return false;\n        }\n        ws_buffer_assure_space(&rec->data, buffer_size);\n        int nread = file_read(ws_buffer_start_ptr(&rec->data) + packet_size, buffer_size - packet_size, cf->provider.wth->fh);\n        if (nread < 0) {\n            *err = file_error(cf->provider.wth->fh, err_info);\n            if (*err == 0)\n                *err = WTAP_ERR_BAD_FILE;\n            return false;\n        }\n        packet_size += nread;\n        if (packet_size != buffer_size) {\n            /* EOF */\n            break;\n        }\n        buffer_size += block_size;\n    }\n\n    rec->rec_type = REC_TYPE_PACKET;\n    rec->presence_flags = 0; /* yes, we have no bananas^Wtime stamp */\n    rec->ts.secs = 0;\n    rec->ts.nsecs = 0;\n    rec->rec_header.packet_header.caplen = packet_size;\n    rec->rec_header.packet_header.len = packet_size;\n\n    return true;\n}\n\nstatic bool\nprocess_file(capture_file *cf)\n{\n    uint32_t     framenum;\n    int          err;\n    char        *err_info = NULL;\n    bool         filtering_tap_listeners;\n    unsigned     tap_flags;\n    epan_dissect_t *edt = NULL;\n    wtap_rec     file_rec;\n\n    if (print_packet_info) {\n        if (!write_preamble(cf)) {\n            err = errno;\n            show_print_file_io_error(err);\n            goto out;\n        }\n    }\n\n    /* Do we have any tap listeners with filters? */\n    filtering_tap_listeners = have_filtering_tap_listeners();\n\n    /* Get the union of the flags for all tap listeners. */\n    tap_flags = union_of_tap_listener_flags();\n\n    wtap_rec_init(&file_rec, 1514);\n\n    /* XXX - TEMPORARY HACK TO ELF DISSECTOR */\n    file_rec.rec_header.packet_header.pkt_encap = 1234;\n\n    if (perform_two_pass_analysis) {\n        frame_data *fdata;\n\n        /* Allocate a frame_data_sequence for all the frames. */\n        cf->provider.frames = new_frame_data_sequence();\n\n        if (do_dissection) {\n            bool create_proto_tree;\n\n            /*\n             * Determine whether we need to create a protocol tree.\n             * We do if:\n             *\n             *    we're going to apply a read filter;\n             *\n             *    a postdissector wants field values or protocols\n             *    on the first pass.\n             */\n            create_proto_tree =\n                (cf->rfcode != NULL || postdissectors_want_hfids());\n\n            /* We're not going to display the protocol tree on this pass,\n               so it's not going to be \"visible\". */\n            edt = epan_dissect_new(cf->epan, create_proto_tree, false);\n        }\n\n        /* XXX - check for failure and report it */\n        full_file_read(cf, &file_rec, &err, &err_info);\n        /* XXX - check return value? */\n        process_packet_first_pass(cf, edt, 0, &file_rec);\n\n        if (edt) {\n            epan_dissect_free(edt);\n            edt = NULL;\n        }\n\n#if 0\n        /* Close the sequential I/O side, to free up memory it requires. */\n        wtap_sequential_close(cf->provider.wth);\n#endif\n\n        /* Allow the protocol dissectors to free up memory that they\n         * don't need after the sequential run-through of the packets. */\n        postseq_cleanup_all_protocols();\n\n        cf->provider.prev_dis = NULL;\n        cf->provider.prev_cap = NULL;\n\n        if (do_dissection) {\n            bool create_proto_tree;\n\n            /*\n             * Determine whether we need to create a protocol tree.\n             * We do if:\n             *\n             *    we're going to apply a display filter;\n             *\n             *    we're going to print the protocol tree;\n             *\n             *    one of the tap listeners requires a protocol tree;\n             *\n             *    we have custom columns (which require field values, which\n             *    currently requires that we build a protocol tree).\n             */\n            create_proto_tree =\n                (cf->dfcode || print_details || filtering_tap_listeners ||\n                 (tap_flags & TL_REQUIRES_PROTO_TREE) || have_custom_cols(&cf->cinfo));\n\n            /* The protocol tree will be \"visible\", i.e., printed, only if we're\n               printing packet details, which is true if we're printing stuff\n               (\"print_packet_info\" is true) and we're in verbose mode\n               (\"packet_details\" is true). */\n            edt = epan_dissect_new(cf->epan, create_proto_tree, print_packet_info && print_details);\n        }\n\n        for (framenum = 1; err == 0 && framenum <= cf->count; framenum++) {\n            fdata = frame_data_sequence_find(cf->provider.frames, framenum);\n            if (!process_packet_second_pass(cf, edt, fdata, &file_rec))\n                return false;\n        }\n\n        if (edt) {\n            epan_dissect_free(edt);\n            edt = NULL;\n        }\n    }\n    else {\n        framenum = 0;\n\n        if (do_dissection) {\n            bool create_proto_tree;\n\n            /*\n             * Determine whether we need to create a protocol tree.\n             * We do if:\n             *\n             *    we're going to apply a read filter;\n             *\n             *    we're going to apply a display filter;\n             *\n             *    we're going to print the protocol tree;\n             *\n             *    one of the tap listeners is going to apply a filter;\n             *\n             *    one of the tap listeners requires a protocol tree;\n             *\n             *    a postdissector wants field values or protocols\n             *    on the first pass;\n             *\n             *    we have custom columns (which require field values, which\n             *    currently requires that we build a protocol tree).\n             */\n            create_proto_tree =\n                (cf->rfcode || cf->dfcode || print_details || filtering_tap_listeners ||\n                 (tap_flags & TL_REQUIRES_PROTO_TREE) || postdissectors_want_hfids() ||\n                 have_custom_cols(&cf->cinfo));\n\n            /* The protocol tree will be \"visible\", i.e., printed, only if we're\n               printing packet details, which is true if we're printing stuff\n               (\"print_packet_info\" is true) and we're in verbose mode\n               (\"packet_details\" is true). */\n            edt = epan_dissect_new(cf->epan, create_proto_tree, print_packet_info && print_details);\n        }\n\n        /* XXX - check for failure and report it */\n        if (full_file_read(cf, &file_rec, &err, &err_info)) {\n            if (!process_packet_single_pass(cf, edt, 0, &file_rec))\n                return false;\n        }\n\n        if (edt) {\n            epan_dissect_free(edt);\n            edt = NULL;\n        }\n    }\n\n    wtap_rec_cleanup(&file_rec);\n\n    if (err != 0) {\n        /*\n         * Print a message noting that the read failed somewhere along the line.\n         *\n         * If we're printing packet data, and the standard output and error are\n         * going to the same place, flush the standard output, so everything\n         * buffered up is written, and then print a newline to the standard error\n         * before printing the error message, to separate it from the packet\n         * data.  (Alas, that only works on UN*X; st_dev is meaningless, and\n         * the _fstat() documentation at Microsoft doesn't indicate whether\n         * st_ino is even supported.)\n         */\n#ifndef _WIN32\n        if (print_packet_info) {\n            ws_statb64 stat_stdout, stat_stderr;\n\n            if (ws_fstat64(1, &stat_stdout) == 0 && ws_fstat64(2, &stat_stderr) == 0) {\n                if (stat_stdout.st_dev == stat_stderr.st_dev &&\n                        stat_stdout.st_ino == stat_stderr.st_ino) {\n                    fflush(stdout);\n                    fprintf(stderr, \"\\n\");\n                }\n            }\n        }\n#endif\n#if 0\n        switch (err) {\n\n            case FTAP_ERR_UNSUPPORTED:\n                cmdarg_err(\"The file \\\"%s\\\" contains record data that TFShark doesn't support.\\n(%s)\",\n                        cf->filename, err_info);\n                g_free(err_info);\n                break;\n\n            case FTAP_ERR_UNSUPPORTED_ENCAP:\n                cmdarg_err(\"The file \\\"%s\\\" has a packet with a network type that TFShark doesn't support.\\n(%s)\",\n                        cf->filename, err_info);\n                g_free(err_info);\n                break;\n\n            case FTAP_ERR_CANT_READ:\n                cmdarg_err(\"An attempt to read from the file \\\"%s\\\" failed for some unknown reason.\",\n                        cf->filename);\n                break;\n\n            case FTAP_ERR_SHORT_READ:\n                cmdarg_err(\"The file \\\"%s\\\" appears to have been cut short in the middle of a packet.\",\n                        cf->filename);\n                break;\n\n            case FTAP_ERR_BAD_FILE:\n                cmdarg_err(\"The file \\\"%s\\\" appears to be damaged or corrupt.\\n(%s)\",\n                        cf->filename, err_info);\n                g_free(err_info);\n                break;\n\n            case FTAP_ERR_DECOMPRESS:\n                cmdarg_err(\"The compressed file \\\"%s\\\" appears to be damaged or corrupt.\\n\"\n                        \"(%s)\", cf->filename, err_info);\n                break;\n\n            default:\n                cmdarg_err(\"An error occurred while reading the file \\\"%s\\\": %s.\",\n                        cf->filename, ftap_strerror(err));\n                break;\n        }\n#endif\n    } else {\n        if (print_packet_info) {\n            if (!write_finale()) {\n                err = errno;\n                show_print_file_io_error(err);\n            }\n        }\n    }\n\nout:\n    wtap_close(cf->provider.wth);\n    cf->provider.wth = NULL;\n\n    return (err != 0);\n}\n\nstatic bool\nprocess_packet_single_pass(capture_file *cf, epan_dissect_t *edt, int64_t offset,\n        wtap_rec *rec)\n{\n    frame_data      fdata;\n    column_info    *cinfo;\n    bool            passed;\n\n    /* Count this packet. */\n    cf->count++;\n\n    /* If we're not running a display filter and we're not printing any\n       packet information, we don't need to do a dissection. This means\n       that all packets can be marked as 'passed'. */\n    passed = true;\n\n    frame_data_init(&fdata, cf->count, rec, offset, cum_bytes);\n\n    /* If we're going to print packet information, or we're going to\n       run a read filter, or we're going to process taps, set up to\n       do a dissection and do so. */\n    if (edt) {\n        /* If we're running a filter, prime the epan_dissect_t with that\n           filter. */\n        if (cf->dfcode)\n            epan_dissect_prime_with_dfilter(edt, cf->dfcode);\n\n        col_custom_prime_edt(edt, &cf->cinfo);\n\n        /* We only need the columns if either\n           1) some tap needs the columns\n           or\n           2) we're printing packet info but we're *not* verbose; in verbose\n           mode, we print the protocol tree, not the protocol summary.\n           or\n           3) there is a column mapped as an individual field */\n        if ((tap_listeners_require_columns()) || (print_packet_info && print_summary) || output_fields_has_cols(output_fields))\n            cinfo = &cf->cinfo;\n        else\n            cinfo = NULL;\n\n        frame_data_set_before_dissect(&fdata, &cf->elapsed_time,\n                &cf->provider.ref, cf->provider.prev_dis);\n        if (cf->provider.ref == &fdata) {\n            ref_frame = fdata;\n            cf->provider.ref = &ref_frame;\n        }\n\n        epan_dissect_file_run_with_taps(edt, rec, &fdata, cinfo);\n\n        /* Run the filter if we have it. */\n        if (cf->dfcode)\n            passed = dfilter_apply_edt(cf->dfcode, edt);\n    }\n\n    if (passed) {\n        frame_data_set_after_dissect(&fdata, &cum_bytes);\n\n        /* Process this packet. */\n        if (print_packet_info) {\n            /* We're printing packet information; print the information for\n               this packet. */\n            print_packet(cf, edt);\n\n            /* If we're doing \"line-buffering\", flush the standard output\n               after every packet.  See the comment above, for the \"-l\"\n               option, for an explanation of why we do that. */\n            if (line_buffered)\n                fflush(stdout);\n\n            if (ferror(stdout)) {\n                show_print_file_io_error(errno);\n                return false;\n            }\n        }\n\n        /* this must be set after print_packet() [bug #8160] */\n        prev_dis_frame = fdata;\n        cf->provider.prev_dis = &prev_dis_frame;\n    }\n\n    prev_cap_frame = fdata;\n    cf->provider.prev_cap = &prev_cap_frame;\n\n    if (edt) {\n        epan_dissect_reset(edt);\n        frame_data_destroy(&fdata);\n    }\n    return passed;\n}\n\nstatic bool\nwrite_preamble(capture_file *cf)\n{\n    switch (output_action) {\n\n        case WRITE_TEXT:\n            return print_preamble(print_stream, cf->filename, get_ws_vcs_version_info());\n\n        case WRITE_XML:\n            if (print_details)\n                write_pdml_preamble(stdout, cf->filename);\n            else\n                write_psml_preamble(&cf->cinfo, stdout);\n            return !ferror(stdout);\n\n        case WRITE_FIELDS:\n            write_fields_preamble(output_fields, stdout);\n            return !ferror(stdout);\n\n        default:\n            ws_assert_not_reached();\n            return false;\n    }\n}\n\nstatic char *\nget_line_buf(size_t len)\n{\n    static char   *line_bufp    = NULL;\n    static size_t  line_buf_len = 256;\n    size_t         new_line_buf_len;\n\n    for (new_line_buf_len = line_buf_len; len > new_line_buf_len;\n            new_line_buf_len *= 2)\n        ;\n    if (line_bufp == NULL) {\n        line_buf_len = new_line_buf_len;\n        line_bufp = (char *)g_malloc(line_buf_len + 1);\n    } else {\n        if (new_line_buf_len > line_buf_len) {\n            line_buf_len = new_line_buf_len;\n            line_bufp = (char *)g_realloc(line_bufp, line_buf_len + 1);\n        }\n    }\n    return line_bufp;\n}\n\nstatic inline void\nput_string(char *dest, const char *str, size_t str_len)\n{\n    memcpy(dest, str, str_len);\n    dest[str_len] = '\\0';\n}\n\nstatic inline void\nput_spaces_string(char *dest, const char *str, size_t str_len, size_t str_with_spaces)\n{\n    size_t i;\n\n    for (i = str_len; i < str_with_spaces; i++)\n        *dest++ = ' ';\n\n    put_string(dest, str, str_len);\n}\n\nstatic inline void\nput_string_spaces(char *dest, const char *str, size_t str_len, size_t str_with_spaces)\n{\n    size_t i;\n\n    memcpy(dest, str, str_len);\n    for (i = str_len; i < str_with_spaces; i++)\n        dest[i] = ' ';\n\n    dest[str_with_spaces] = '\\0';\n}\n\nstatic bool\nprint_columns(capture_file *cf)\n{\n    char   *line_bufp;\n    int     i;\n    size_t  buf_offset;\n    size_t  column_len;\n    size_t  col_len;\n    col_item_t* col_item;\n\n    line_bufp = get_line_buf(256);\n    buf_offset = 0;\n    *line_bufp = '\\0';\n    for (i = 0; i < cf->cinfo.num_cols; i++) {\n        col_item = &cf->cinfo.columns[i];\n        /* Skip columns not marked as visible. */\n        if (!get_column_visible(i))\n            continue;\n        const char* col_text = get_column_text(&cf->cinfo, i);\n        switch (col_item->col_fmt) {\n            case COL_NUMBER:\n            case COL_NUMBER_DIS:\n                column_len = col_len = strlen(col_text);\n                if (column_len < 3)\n                    column_len = 3;\n                line_bufp = get_line_buf(buf_offset + column_len);\n                put_spaces_string(line_bufp + buf_offset, col_text, col_len, column_len);\n                break;\n\n            case COL_CLS_TIME:\n            case COL_REL_TIME:\n            case COL_ABS_TIME:\n            case COL_ABS_YMD_TIME:  /* XXX - wider */\n            case COL_ABS_YDOY_TIME: /* XXX - wider */\n            case COL_UTC_TIME:\n            case COL_UTC_YMD_TIME:  /* XXX - wider */\n            case COL_UTC_YDOY_TIME: /* XXX - wider */\n                column_len = col_len = strlen(col_text);\n                if (column_len < 10)\n                    column_len = 10;\n                line_bufp = get_line_buf(buf_offset + column_len);\n                put_spaces_string(line_bufp + buf_offset, col_text, col_len, column_len);\n                break;\n\n            case COL_DEF_SRC:\n            case COL_RES_SRC:\n            case COL_UNRES_SRC:\n            case COL_DEF_DL_SRC:\n            case COL_RES_DL_SRC:\n            case COL_UNRES_DL_SRC:\n            case COL_DEF_NET_SRC:\n            case COL_RES_NET_SRC:\n            case COL_UNRES_NET_SRC:\n                column_len = col_len = strlen(col_text);\n                if (column_len < 12)\n                    column_len = 12;\n                line_bufp = get_line_buf(buf_offset + column_len);\n                put_spaces_string(line_bufp + buf_offset, col_text, col_len, column_len);\n                break;\n\n            case COL_DEF_DST:\n            case COL_RES_DST:\n            case COL_UNRES_DST:\n            case COL_DEF_DL_DST:\n            case COL_RES_DL_DST:\n            case COL_UNRES_DL_DST:\n            case COL_DEF_NET_DST:\n            case COL_RES_NET_DST:\n            case COL_UNRES_NET_DST:\n                column_len = col_len = strlen(col_text);\n                if (column_len < 12)\n                    column_len = 12;\n                line_bufp = get_line_buf(buf_offset + column_len);\n                put_string_spaces(line_bufp + buf_offset, col_text, col_len, column_len);\n                break;\n\n            default:\n                column_len = strlen(col_text);\n                line_bufp = get_line_buf(buf_offset + column_len);\n                put_string(line_bufp + buf_offset, col_text, column_len);\n                break;\n        }\n        buf_offset += column_len;\n        if (i != cf->cinfo.num_cols - 1) {\n            /*\n             * This isn't the last column, so we need to print a\n             * separator between this column and the next.\n             *\n             * If we printed a network source and are printing a\n             * network destination of the same type next, separate\n             * them with \" -> \"; if we printed a network destination\n             * and are printing a network source of the same type\n             * next, separate them with \" <- \"; otherwise separate them\n             * with a space.\n             *\n             * We add enough space to the buffer for \" <- \" or \" -> \",\n             * even if we're only adding \" \".\n             */\n            line_bufp = get_line_buf(buf_offset + 4);\n            switch (col_item->col_fmt) {\n\n                case COL_DEF_SRC:\n                case COL_RES_SRC:\n                case COL_UNRES_SRC:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_DST:\n                        case COL_RES_DST:\n                        case COL_UNRES_DST:\n                            put_string(line_bufp + buf_offset, \" -> \", 4);\n                            buf_offset += 4;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, \" \", 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                case COL_DEF_DL_SRC:\n                case COL_RES_DL_SRC:\n                case COL_UNRES_DL_SRC:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_DL_DST:\n                        case COL_RES_DL_DST:\n                        case COL_UNRES_DL_DST:\n                            put_string(line_bufp + buf_offset, \" -> \", 4);\n                            buf_offset += 4;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, \" \", 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                case COL_DEF_NET_SRC:\n                case COL_RES_NET_SRC:\n                case COL_UNRES_NET_SRC:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_NET_DST:\n                        case COL_RES_NET_DST:\n                        case COL_UNRES_NET_DST:\n                            put_string(line_bufp + buf_offset, \" -> \", 4);\n                            buf_offset += 4;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, \" \", 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                case COL_DEF_DST:\n                case COL_RES_DST:\n                case COL_UNRES_DST:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_SRC:\n                        case COL_RES_SRC:\n                        case COL_UNRES_SRC:\n                            put_string(line_bufp + buf_offset, \" <- \", 4);\n                            buf_offset += 4;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, \" \", 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                case COL_DEF_DL_DST:\n                case COL_RES_DL_DST:\n                case COL_UNRES_DL_DST:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_DL_SRC:\n                        case COL_RES_DL_SRC:\n                        case COL_UNRES_DL_SRC:\n                            put_string(line_bufp + buf_offset, \" <- \", 4);\n                            buf_offset += 4;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, \" \", 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                case COL_DEF_NET_DST:\n                case COL_RES_NET_DST:\n                case COL_UNRES_NET_DST:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_NET_SRC:\n                        case COL_RES_NET_SRC:\n                        case COL_UNRES_NET_SRC:\n                            put_string(line_bufp + buf_offset, \" <- \", 4);\n                            buf_offset += 4;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, \" \", 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                default:\n                    put_string(line_bufp + buf_offset, \" \", 1);\n                    buf_offset += 1;\n                    break;\n            }\n        }\n    }\n    return print_line(print_stream, 0, line_bufp);\n}\n\nstatic bool\nprint_packet(capture_file *cf, epan_dissect_t *edt)\n{\n    if (print_summary || output_fields_has_cols(output_fields)) {\n        /* Just fill in the columns. */\n        epan_dissect_fill_in_columns(edt, false, true);\n\n        if (print_summary) {\n            /* Now print them. */\n            switch (output_action) {\n\n                case WRITE_TEXT:\n                    if (!print_columns(cf))\n                        return false;\n                    break;\n\n                case WRITE_XML:\n                    write_psml_columns(edt, stdout, false);\n                    return !ferror(stdout);\n                case WRITE_FIELDS: /*No non-verbose \"fields\" format */\n                    ws_assert_not_reached();\n                    break;\n            }\n        }\n    }\n    if (print_details) {\n        /* Print the information in the protocol tree. */\n        switch (output_action) {\n\n            case WRITE_TEXT:\n                if (!proto_tree_print(print_details ? print_dissections_expanded : print_dissections_none,\n                            print_hex, edt, output_only_tables, print_stream))\n                    return false;\n                if (!print_hex) {\n                    if (!print_line(print_stream, 0, separator))\n                        return false;\n                }\n                break;\n\n            case WRITE_XML:\n                write_pdml_proto_tree(NULL, edt, &cf->cinfo, stdout, false);\n                printf(\"\\n\");\n                return !ferror(stdout);\n            case WRITE_FIELDS:\n                write_fields_proto_tree(output_fields, edt, &cf->cinfo, stdout);\n                printf(\"\\n\");\n                return !ferror(stdout);\n        }\n    }\n    if (print_hex) {\n        if (print_summary || print_details) {\n            if (!print_line(print_stream, 0, \"\"))\n                return false;\n        }\n        if (!print_hex_data(print_stream, edt, HEXDUMP_SOURCE_MULTI | HEXDUMP_ASCII_INCLUDE))\n            return false;\n        if (!print_line(print_stream, 0, separator))\n            return false;\n    }\n    return true;\n}\n\nstatic bool\nwrite_finale(void)\n{\n    switch (output_action) {\n\n        case WRITE_TEXT:\n            return print_finale(print_stream);\n\n        case WRITE_XML:\n            if (print_details)\n                write_pdml_finale(stdout);\n            else\n                write_psml_finale(stdout);\n            return !ferror(stdout);\n\n        case WRITE_FIELDS:\n            write_fields_finale(output_fields, stdout);\n            return !ferror(stdout);\n\n        default:\n            ws_assert_not_reached();\n            return false;\n    }\n}\n\ncf_status_t\ncf_open(capture_file *cf, const char *fname, unsigned int type, bool is_tempfile, int *err _U_)\n{\n    /* The open isn't implemented yet.  Fill in the information for this file. */\n\n    /* Create new epan session for dissection. */\n    epan_free(cf->epan);\n    cf->epan = tfshark_epan_new(cf);\n\n    cf->provider.wth = NULL; /**** XXX - DOESN'T WORK RIGHT NOW!!!! */\n    cf->f_datalen = 0; /* not used, but set it anyway */\n\n    /* Set the file name because we need it to set the follow stream filter.\n       XXX - is that still true?  We need it for other reasons, though,\n       in any case. */\n    cf->filename = g_strdup(fname);\n\n    /* Indicate whether it's a permanent or temporary file. */\n    cf->is_tempfile = is_tempfile;\n\n    /* No user changes yet. */\n    cf->unsaved_changes = false;\n\n    cf->cd_t      = 0; /**** XXX - DOESN'T WORK RIGHT NOW!!!! */\n    cf->open_type = type;\n    cf->count     = 0;\n    cf->drops_known = false;\n    cf->drops     = 0;\n    cf->snap      = 0; /**** XXX - DOESN'T WORK RIGHT NOW!!!! */\n    nstime_set_zero(&cf->elapsed_time);\n    cf->provider.ref = NULL;\n    cf->provider.prev_dis = NULL;\n    cf->provider.prev_cap = NULL;\n\n    cf->state = FILE_READ_IN_PROGRESS;\n\n    return CF_OK;\n\n/* fail: */\n/*\n    char *err_info;\n    char   err_msg[2048+1];\n    snprintf(err_msg, sizeof err_msg,\n            cf_open_error_message(*err, err_info, false, cf->cd_t), fname);\n    cmdarg_err(\"%s\", err_msg);\n    return CF_ERROR;\n*/\n}\n\nstatic void\nshow_print_file_io_error(int err)\n{\n    switch (err) {\n\n        case ENOSPC:\n            cmdarg_err(\"Not all the packets could be printed because there is \"\n                    \"no space left on the file system.\");\n            break;\n\n#ifdef EDQUOT\n        case EDQUOT:\n            cmdarg_err(\"Not all the packets could be printed because you are \"\n                    \"too close to, or over your disk quota.\");\n            break;\n#endif\n\n        default:\n            cmdarg_err(\"An error occurred while printing packets: %s.\",\n                    g_strerror(err));\n            break;\n    }\n}\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "tshark.c",
          "type": "blob",
          "size": 196.685546875,
          "content": "/* tshark.c\n *\n * Text-mode variant of Wireshark, along the lines of tcpdump and snoop,\n * by Gilbert Ramirez <gram@alumni.rice.edu> and Guy Harris <guy@alum.mit.edu>.\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * SPDX-License-Identifier: GPL-2.0-or-later\n */\n\n#include <config.h>\n\n#define WS_LOG_DOMAIN  LOG_DOMAIN_MAIN\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n#include <limits.h>\n\n#include <wsutil/ws_getopt.h>\n\n#include <errno.h>\n\n#ifdef _WIN32\n# include <winsock2.h>\n#endif\n\n#ifndef _WIN32\n#include <signal.h>\n#endif\n\n#include <glib.h>\n\n#include <epan/exceptions.h>\n#include <epan/epan.h>\n\n#include <ws_exit_codes.h>\n#include <wsutil/clopts_common.h>\n#include <wsutil/cmdarg_err.h>\n#include <ui/urls.h>\n#include <wsutil/filesystem.h>\n#include <wsutil/file_util.h>\n#include <wsutil/time_util.h>\n#include <wsutil/socket.h>\n#include <wsutil/privileges.h>\n#include <wsutil/please_report_bug.h>\n#include <wsutil/wslog.h>\n#include <wsutil/ws_assert.h>\n#include <wsutil/strtoi.h>\n#include <cli_main.h>\n#include <wsutil/version_info.h>\n#include <wiretap/wtap_opttypes.h>\n\n#include \"globals.h\"\n#include <epan/timestamp.h>\n#include <epan/packet.h>\n#ifdef HAVE_LUA\n#include <epan/wslua/init_wslua.h>\n#endif\n#include <epan/disabled_protos.h>\n#include <epan/prefs.h>\n#include <epan/column.h>\n#include <epan/decode_as.h>\n#include <epan/print.h>\n#include <epan/addr_resolv.h>\n#include <epan/enterprises.h>\n#include <epan/manuf.h>\n#include <epan/services.h>\n#ifdef HAVE_LIBPCAP\n#include \"ui/capture_ui_utils.h\"\n#endif\n#include \"ui/taps.h\"\n#include \"ui/util.h\"\n#include \"ui/ws_ui_util.h\"\n#include \"ui/decode_as_utils.h\"\n#include \"wsutil/filter_files.h\"\n#include \"ui/cli/tshark-tap.h\"\n#include \"ui/cli/tap-exportobject.h\"\n#include \"ui/tap_export_pdu.h\"\n#include \"ui/dissect_opts.h\"\n#include \"ui/ssl_key_export.h\"\n#include \"ui/failure_message.h\"\n#include \"ui/capture_opts.h\"\n#if defined(HAVE_LIBSMI)\n#include \"epan/oids.h\"\n#endif\n#include \"epan/maxmind_db.h\"\n#include <epan/epan_dissect.h>\n#include <epan/tap.h>\n#include <epan/stat_tap_ui.h>\n#include <epan/conversation_table.h>\n#include <epan/srt_table.h>\n#include <epan/rtd_table.h>\n#include <epan/ex-opt.h>\n#include <epan/exported_pdu.h>\n#include <epan/secrets.h>\n\n#include \"capture/capture-pcap-util.h\"\n\n#ifdef HAVE_LIBPCAP\n#include \"capture/capture_ifinfo.h\"\n#ifdef _WIN32\n#include \"capture/capture-wpcap.h\"\n#endif /* _WIN32 */\n#include <capture/capture_session.h>\n#include <capture/capture_sync.h>\n#include <ui/capture_info.h>\n#endif /* HAVE_LIBPCAP */\n#include <epan/funnel.h>\n\n#include <wsutil/str_util.h>\n#include <wsutil/utf8_entities.h>\n#include <wsutil/json_dumper.h>\n#include <wsutil/wslog.h>\n#ifdef _WIN32\n#include <wsutil/win32-utils.h>\n#endif\n\n#include \"extcap.h\"\n\n#ifdef HAVE_PLUGINS\n#include <wsutil/codecs.h>\n#include <wsutil/plugins.h>\n#endif\n\n/* Additional exit codes */\n#define INVALID_EXPORT          2\n#define INVALID_TAP             2\n#define INVALID_CAPTURE         2\n\n#define LONGOPT_EXPORT_OBJECTS          LONGOPT_BASE_APPLICATION+1\n#define LONGOPT_COLOR                   LONGOPT_BASE_APPLICATION+2\n#define LONGOPT_NO_DUPLICATE_KEYS       LONGOPT_BASE_APPLICATION+3\n#define LONGOPT_ELASTIC_MAPPING_FILTER  LONGOPT_BASE_APPLICATION+4\n#define LONGOPT_EXPORT_TLS_SESSION_KEYS LONGOPT_BASE_APPLICATION+5\n#define LONGOPT_CAPTURE_COMMENT         LONGOPT_BASE_APPLICATION+6\n#define LONGOPT_HEXDUMP                 LONGOPT_BASE_APPLICATION+7\n#define LONGOPT_SELECTED_FRAME          LONGOPT_BASE_APPLICATION+8\n#define LONGOPT_PRINT_TIMERS            LONGOPT_BASE_APPLICATION+9\n#define LONGOPT_GLOBAL_PROFILE          LONGOPT_BASE_APPLICATION+10\n#define LONGOPT_COMPRESS                LONGOPT_BASE_APPLICATION+11\n\ncapture_file cfile;\n\nstatic uint32_t cum_bytes;\nstatic frame_data ref_frame;\nstatic frame_data prev_dis_frame;\nstatic frame_data prev_cap_frame;\n\nstatic bool perform_two_pass_analysis;\nstatic uint32_t epan_auto_reset_count;\nstatic bool epan_auto_reset;\n\nstatic uint32_t selected_frame_number;\n\n/*\n * The way the packet decode is to be written.\n */\ntypedef enum {\n    WRITE_NONE,     /* dummy initial state */\n    WRITE_TEXT,     /* summary or detail text */\n    WRITE_XML,      /* PDML or PSML */\n    WRITE_FIELDS,   /* User defined list of fields */\n    WRITE_JSON,     /* JSON */\n    WRITE_JSON_RAW, /* JSON only raw hex */\n    WRITE_EK        /* JSON bulk insert to Elasticsearch */\n        /* Add CSV and the like here */\n} output_action_e;\n\nstatic output_action_e output_action;\nstatic bool do_dissection;     /* true if we have to dissect each packet */\nstatic bool print_packet_info; /* true if we're to print packet information */\nstatic bool print_summary;     /* true if we're to print packet summary information */\nstatic bool print_details;     /* true if we're to print packet details information */\nstatic bool print_hex;         /* true if we're to print hex/ascii information */\nstatic bool line_buffered;\nstatic bool quiet;\nstatic bool really_quiet;\nstatic char* delimiter_char = \" \";\nstatic bool dissect_color;\nstatic unsigned hexdump_source_option = HEXDUMP_SOURCE_MULTI; /* Default - Enable legacy multi-source mode */\nstatic unsigned hexdump_ascii_option = HEXDUMP_ASCII_INCLUDE; /* Default - Enable legacy undelimited ASCII dump */\nstatic unsigned hexdump_timestamp_option = HEXDUMP_TIMESTAMP_NONE; /* Default - no timestamp preamble */\n\nstatic print_format_e print_format = PR_FMT_TEXT;\nstatic print_stream_t *print_stream;\n\nstatic char *output_file_name;\n\nstatic output_fields_t* output_fields;\n\nstatic bool no_duplicate_keys;\nstatic proto_node_children_grouper_func node_children_grouper = proto_node_group_children_by_unique;\n\nstatic json_dumper jdumper;\n\n/* The line separator used between packets, changeable via the -S option */\nstatic const char *separator = \"\";\n\n/* Per-file comments to be added to the output file. */\nstatic GPtrArray *capture_comments;\n\nstatic bool prefs_loaded;\n\n#ifdef HAVE_LIBPCAP\n/*\n * true if we're to print packet counts to keep track of captured packets.\n */\nstatic bool print_packet_counts;\n\nstatic capture_options global_capture_opts;\nstatic capture_session global_capture_session;\nstatic info_data_t global_info_data;\n\n#ifdef SIGINFO\nstatic bool infodelay;      /* if true, don't print capture info in SIGINFO handler */\nstatic bool infoprint;      /* if true, print capture info after clearing infodelay */\n#endif /* SIGINFO */\n\nstatic bool capture(void);\nstatic bool capture_input_new_file(capture_session *cap_session,\n        char *new_file);\nstatic void capture_input_new_packets(capture_session *cap_session,\n        int to_read);\nstatic void capture_input_drops(capture_session *cap_session, uint32_t dropped,\n        const char* interface_name);\nstatic void capture_input_error(capture_session *cap_session,\n        char *error_msg, char *secondary_error_msg);\nstatic void capture_input_cfilter_error(capture_session *cap_session,\n        unsigned i, const char *error_message);\nstatic void capture_input_closed(capture_session *cap_session, char *msg);\n\nstatic void report_counts(void);\n#ifdef _WIN32\nstatic BOOL WINAPI capture_cleanup(DWORD);\n#else /* _WIN32 */\nstatic void capture_cleanup(int);\n#ifdef SIGINFO\nstatic void report_counts_siginfo(int);\n#endif /* SIGINFO */\n#endif /* _WIN32 */\n#endif /* HAVE_LIBPCAP */\n\nstatic void reset_epan_mem(capture_file *cf, epan_dissect_t *edt, bool tree, bool visual);\n\ntypedef enum {\n    PROCESS_FILE_SUCCEEDED,\n    PROCESS_FILE_NO_FILE_PROCESSED,\n    PROCESS_FILE_ERROR,\n    PROCESS_FILE_INTERRUPTED\n} process_file_status_t;\nstatic process_file_status_t process_cap_file(capture_file *, char *, int, bool, int, int64_t, int, wtap_compression_type);\n\nstatic bool process_packet_single_pass(capture_file *cf,\n        epan_dissect_t *edt, int64_t offset, wtap_rec *rec, unsigned tap_flags);\nstatic void show_print_file_io_error(void);\nstatic bool write_preamble(capture_file *cf);\nstatic bool print_packet(capture_file *cf, epan_dissect_t *edt);\nstatic bool write_finale(void);\n\nstatic GHashTable *output_only_tables;\n\nstatic bool opt_print_timers;\nstruct elapsed_pass_s {\n    int64_t dissect;\n    int64_t dfilter_read;\n    int64_t dfilter_filter;\n};\nstatic struct {\n    int64_t                dfilter_expand;\n    int64_t                dfilter_compile;\n    struct elapsed_pass_s  first_pass;\n    int64_t                elapsed_first_pass;\n    struct elapsed_pass_s  second_pass;\n    int64_t                elapsed_second_pass;\n}\ntshark_elapsed;\n\nstatic void\nprint_elapsed_json(const char *cf_name, const char *dfilter)\n{\n    json_dumper dumper = {\n        .output_file = stderr,\n        .flags = JSON_DUMPER_FLAGS_PRETTY_PRINT,\n    };\n\n    if (tshark_elapsed.elapsed_first_pass == 0) {\n        // Should not happen\n        ws_warning(\"Print timers requested but no timing info provided\");\n        return;\n    }\n\n#define DUMP(name, val) \\\n        json_dumper_set_member_name(&dumper, name); \\\n        json_dumper_value_anyf(&dumper, \"%\"PRId64, val)\n\n    json_dumper_begin_object(&dumper);\n    json_dumper_set_member_name(&dumper, \"version\");\n    json_dumper_value_string(&dumper, get_ws_vcs_version_info_short());\n    if (cf_name) {\n        json_dumper_set_member_name(&dumper, \"path\");\n        json_dumper_value_string(&dumper, cf_name);\n    }\n    if (dfilter) {\n        json_dumper_set_member_name(&dumper, \"filter\");\n        json_dumper_value_string(&dumper, dfilter);\n    }\n    json_dumper_set_member_name(&dumper, \"time_unit\");\n    json_dumper_value_string(&dumper, \"microseconds\");\n    DUMP(\"elapsed\", tshark_elapsed.elapsed_first_pass +\n                        tshark_elapsed.elapsed_second_pass);\n    DUMP(\"dfilter_expand\", tshark_elapsed.dfilter_expand);\n    DUMP(\"dfilter_compile\", tshark_elapsed.dfilter_compile);\n    json_dumper_begin_array(&dumper);\n    json_dumper_begin_object(&dumper);\n    DUMP(\"elapsed\", tshark_elapsed.elapsed_first_pass);\n    DUMP(\"dissect\", tshark_elapsed.first_pass.dissect);\n    DUMP(\"display_filter\", tshark_elapsed.first_pass.dfilter_filter);\n    DUMP(\"read_filter\", tshark_elapsed.first_pass.dfilter_read);\n    json_dumper_end_object(&dumper);\n    if (tshark_elapsed.elapsed_second_pass) {\n        json_dumper_begin_object(&dumper);\n        DUMP(\"elapsed\", tshark_elapsed.elapsed_second_pass);\n        DUMP(\"dissect\", tshark_elapsed.second_pass.dissect);\n        DUMP(\"display_filter\", tshark_elapsed.second_pass.dfilter_filter);\n        DUMP(\"read_filter\", tshark_elapsed.second_pass.dfilter_read);\n        json_dumper_end_object(&dumper);\n    }\n    json_dumper_end_array(&dumper);\n    json_dumper_end_object(&dumper);\n    json_dumper_finish(&dumper);\n}\n\nstatic void\nlist_capture_types(void)\n{\n    GArray *writable_type_subtypes;\n\n    fprintf(stderr, \"tshark: The available capture file types for the \\\"-F\\\" flag are:\\n\");\n    writable_type_subtypes = wtap_get_writable_file_types_subtypes(FT_SORT_BY_NAME);\n    for (unsigned i = 0; i < writable_type_subtypes->len; i++) {\n        int ft = g_array_index(writable_type_subtypes, int, i);\n        fprintf(stderr, \"    %s - %s\\n\", wtap_file_type_subtype_name(ft),\n                wtap_file_type_subtype_description(ft));\n    }\n    g_array_free(writable_type_subtypes, TRUE);\n}\n\nstatic void\nlist_output_compression_types(void) {\n    GSList *output_compression_types;\n\n    fprintf(stderr, \"tshark: The available output compression type(s) for the \\\"--compress\\\" flag are:\\n\");\n    output_compression_types = wtap_get_all_output_compression_type_names_list();\n    for (GSList *compression_type = output_compression_types;\n        compression_type != NULL;\n        compression_type = g_slist_next(compression_type)) {\n            fprintf(stderr, \"   %s\\n\", (const char *)compression_type->data);\n        }\n\n    g_slist_free(output_compression_types);\n}\n\nstruct string_elem {\n    const char *sstr;   /* The short string */\n    const char *lstr;   /* The long string */\n};\n\nstatic int\nstring_compare(const void *a, const void *b)\n{\n    return strcmp(((const struct string_elem *)a)->sstr,\n            ((const struct string_elem *)b)->sstr);\n}\n\nstatic void\nstring_elem_print(void *data)\n{\n    fprintf(stderr, \"    %s - %s\\n\",\n            ((struct string_elem *)data)->sstr,\n            ((struct string_elem *)data)->lstr);\n}\n\nstatic void\nlist_read_capture_types(void)\n{\n    unsigned            i;\n    size_t              num_file_types;\n    struct string_elem *captypes;\n    GSList             *list = NULL;\n    const char *magic = \"Magic-value-based\";\n    const char *heuristic = \"Heuristics-based\";\n\n    /* How many readable file types are there? */\n    num_file_types = 0;\n    for (i = 0; open_routines[i].name != NULL; i++)\n        num_file_types++;\n    captypes = g_new(struct string_elem, num_file_types);\n\n    fprintf(stderr, \"tshark: The available read file types for the \\\"-X read_format:\\\" option are:\\n\");\n    for (i = 0; i < num_file_types && open_routines[i].name != NULL; i++) {\n        captypes[i].sstr = open_routines[i].name;\n        captypes[i].lstr = (open_routines[i].type == OPEN_INFO_MAGIC) ? magic : heuristic;\n        list = g_slist_insert_sorted(list, &captypes[i], string_compare);\n    }\n    g_slist_free_full(list, string_elem_print);\n    g_free(captypes);\n}\n\nstatic void\nlist_export_pdu_taps(void)\n{\n    fprintf(stderr, \"tshark: The available export tap names and the encapsulation types they produce for the \\\"-U tap_name\\\" option are:\\n\");\n    for (GSList *export_pdu_tap_name_list = get_export_pdu_tap_list();\n            export_pdu_tap_name_list != NULL;\n            export_pdu_tap_name_list = g_slist_next(export_pdu_tap_name_list)) {\n        fprintf(stderr, \"    %s - %s\\n\", (const char*)(export_pdu_tap_name_list->data), wtap_encap_description(export_pdu_tap_get_encap((const char*)export_pdu_tap_name_list->data)));\n    }\n}\n\nstatic void\nprint_usage(FILE *output)\n{\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: tshark [options] ...\\n\");\n    fprintf(output, \"\\n\");\n\n#ifdef HAVE_LIBPCAP\n    fprintf(output, \"Capture interface:\\n\");\n    fprintf(output, \"  -i <interface>, --interface <interface>\\n\");\n    fprintf(output, \"                           name or idx of interface (def: first non-loopback)\\n\");\n    fprintf(output, \"  -f <capture filter>      packet filter in libpcap filter syntax\\n\");\n    fprintf(output, \"  -s <snaplen>, --snapshot-length <snaplen>\\n\");\n    fprintf(output, \"                           packet snapshot length (def: appropriate maximum)\\n\");\n    fprintf(output, \"  -p, --no-promiscuous-mode\\n\");\n    fprintf(output, \"                           don't capture in promiscuous mode\\n\");\n    fprintf(output, \"  -I, --monitor-mode       capture in monitor mode, if available\\n\");\n    fprintf(output, \"  -B <buffer size>, --buffer-size <buffer size>\\n\");\n    fprintf(output, \"                           size of kernel buffer in MiB (def: %dMiB)\\n\", DEFAULT_CAPTURE_BUFFER_SIZE);\n    fprintf(output, \"  -y <link type>, --linktype <link type>\\n\");\n    fprintf(output, \"                           link layer type (def: first appropriate)\\n\");\n    fprintf(output, \"  --time-stamp-type <type> timestamp method for interface\\n\");\n    fprintf(output, \"  -D, --list-interfaces    print list of interfaces and exit\\n\");\n    fprintf(output, \"  -L, --list-data-link-types\\n\");\n    fprintf(output, \"                           print list of link-layer types of iface and exit\\n\");\n    fprintf(output, \"  --list-time-stamp-types  print list of timestamp types for iface and exit\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Capture display:\\n\");\n    fprintf(output, \"  --update-interval        interval between updates with new packets, in milliseconds (def: %dms)\\n\", DEFAULT_UPDATE_INTERVAL);\n    fprintf(output, \"Capture stop conditions:\\n\");\n    fprintf(output, \"  -c <packet count>        stop after n packets (def: infinite)\\n\");\n    fprintf(output, \"  -a <autostop cond.> ..., --autostop <autostop cond.> ...\\n\");\n    fprintf(output, \"                           duration:NUM - stop after NUM seconds\\n\");\n    fprintf(output, \"                           filesize:NUM - stop this file after NUM KB\\n\");\n    fprintf(output, \"                              files:NUM - stop after NUM files\\n\");\n    fprintf(output, \"                            packets:NUM - stop after NUM packets\\n\");\n    /*fprintf(output, \"\\n\");*/\n    fprintf(output, \"Capture output:\\n\");\n    fprintf(output, \"  -b <ringbuffer opt.> ..., --ring-buffer <ringbuffer opt.>\\n\");\n    fprintf(output, \"                           duration:NUM - switch to next file after NUM secs\\n\");\n    fprintf(output, \"                           filesize:NUM - switch to next file after NUM KB\\n\");\n    fprintf(output, \"                              files:NUM - ringbuffer: replace after NUM files\\n\");\n    fprintf(output, \"                            packets:NUM - switch to next file after NUM packets\\n\");\n    fprintf(output, \"                           interval:NUM - switch to next file when the time is\\n\");\n    fprintf(output, \"                                          an exact multiple of NUM secs\\n\");\n    fprintf(output, \"                         printname:FILE - print filename to FILE when written\\n\");\n    fprintf(output, \"                                          (can use 'stdout' or 'stderr')\\n\");\n#endif  /* HAVE_LIBPCAP */\n#ifdef HAVE_PCAP_REMOTE\n    fprintf(output, \"RPCAP options:\\n\");\n    fprintf(output, \"  -A <user>:<password>     use RPCAP password authentication\\n\");\n#endif\n    /*fprintf(output, \"\\n\");*/\n    fprintf(output, \"Input file:\\n\");\n    fprintf(output, \"  -r <infile>, --read-file <infile>\\n\");\n    fprintf(output, \"                           set the filename to read from (or '-' for stdin)\\n\");\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Processing:\\n\");\n    fprintf(output, \"  -2                       perform a two-pass analysis\\n\");\n    fprintf(output, \"  -M <packet count>        perform session auto reset\\n\");\n    fprintf(output, \"  -R <read filter>, --read-filter <read filter>\\n\");\n    fprintf(output, \"                           packet Read filter in Wireshark display filter syntax\\n\");\n    fprintf(output, \"                           (requires -2)\\n\");\n    fprintf(output, \"  -Y <display filter>, --display-filter <display filter>\\n\");\n    fprintf(output, \"                           packet displaY filter in Wireshark display filter\\n\");\n    fprintf(output, \"                           syntax\\n\");\n    fprintf(output, \"  -n                       disable all name resolutions (def: \\\"mNd\\\" enabled, or\\n\");\n    fprintf(output, \"                           as set in preferences)\\n\");\n    // Note: the order of the flags here matches the options in the settings dialog e.g. \"dsN\" only have an effect if \"n\" is set\n    fprintf(output, \"  -N <name resolve flags>  enable specific name resolution(s): \\\"mtndsNvg\\\"\\n\");\n    fprintf(output, \"  -d %s ...\\n\", DECODE_AS_ARG_TEMPLATE);\n    fprintf(output, \"                           \\\"Decode As\\\", see the man page for details\\n\");\n    fprintf(output, \"                           Example: tcp.port==8888,http\\n\");\n    fprintf(output, \"  -H <hosts file>          read a list of entries from a hosts file, which will\\n\");\n    fprintf(output, \"                           then be written to a capture file. (Implies -W n)\\n\");\n    fprintf(output, \"  --enable-protocol <proto_name>\\n\");\n    fprintf(output, \"                           enable dissection of proto_name\\n\");\n    fprintf(output, \"  --disable-protocol <proto_name>\\n\");\n    fprintf(output, \"                           disable dissection of proto_name\\n\");\n    fprintf(output, \"  --only-protocols <protocols>\\n\");\n    fprintf(output, \"                           Only enable dissection of these protocols, comma\\n\");\n    fprintf(output, \"                           separated. Disable everything else\\n\");\n    fprintf(output, \"  --disable-all-protocols\\n\");\n    fprintf(output, \"                           Disable dissection of all protocols\\n\");\n    fprintf(output, \"  --enable-heuristic <short_name>\\n\");\n    fprintf(output, \"                           enable dissection of heuristic protocol\\n\");\n    fprintf(output, \"  --disable-heuristic <short_name>\\n\");\n    fprintf(output, \"                           disable dissection of heuristic protocol\\n\");\n\n    /*fprintf(output, \"\\n\");*/\n    fprintf(output, \"Output:\\n\");\n    fprintf(output, \"  -w <outfile|->           write packets to a pcapng-format file named \\\"outfile\\\"\\n\");\n    fprintf(output, \"                           (or '-' for stdout). If the output filename has the\\n\");\n    fprintf(output, \"                           .gz extension, it will be compressed to a gzip archive\\n\");\n    fprintf(output, \"  --capture-comment <comment>\\n\");\n    fprintf(output, \"                           add a capture file comment, if supported\\n\");\n    fprintf(output, \"  -C <config profile>      start with specified configuration profile\\n\");\n    fprintf(output, \"  --global-profile         use the global profile instead of personal profile\\n\");\n    fprintf(output, \"  -F <output file type>    set the output file type; default is pcapng.\\n\");\n    fprintf(output, \"                           an empty \\\"-F\\\" option will list the file types\\n\");\n    fprintf(output, \"  -V                       add output of packet tree        (Packet Details)\\n\");\n    fprintf(output, \"  -O <protocols>           Only show packet details of these protocols, comma\\n\");\n    fprintf(output, \"                           separated\\n\");\n    fprintf(output, \"  -P, --print              print packet summary even when writing to a file\\n\");\n    fprintf(output, \"  -S <separator>           the line separator to print between packets\\n\");\n    fprintf(output, \"  -x                       add output of hex and ASCII dump (Packet Bytes)\\n\");\n    fprintf(output, \"  --hexdump <hexoption>    add hexdump, set options for data source and ASCII dump\\n\");\n    fprintf(output, \"     all                   dump all data sources (-x default)\\n\");\n    fprintf(output, \"     frames                dump only frame data source\\n\");\n    fprintf(output, \"     ascii                 include ASCII dump text (-x default)\\n\");\n    fprintf(output, \"     delimit               delimit ASCII dump text with '|' characters\\n\");\n    fprintf(output, \"     noascii               exclude ASCII dump text\\n\");\n    fprintf(output, \"     time                  include frame timestamp preamble\\n\");\n    fprintf(output, \"     notime                do not include frame timestamp preamble (-x default)\\n\");\n    fprintf(output, \"     help                  display help for --hexdump and exit\\n\");\n    fprintf(output, \"  -T pdml|ps|psml|json|jsonraw|ek|tabs|text|fields|?\\n\");\n    fprintf(output, \"                           format of text output (def: text)\\n\");\n    fprintf(output, \"  -j <protocolfilter>      protocols layers filter if -T ek|pdml|json selected\\n\");\n    fprintf(output, \"                           (e.g. \\\"ip ip.flags text\\\", filter does not expand child\\n\");\n    fprintf(output, \"                           nodes, unless child is specified also in the filter)\\n\");\n    fprintf(output, \"  -J <protocolfilter>      top level protocol filter if -T ek|pdml|json selected\\n\");\n    fprintf(output, \"                           (e.g. \\\"http tcp\\\", filter which expands all child nodes)\\n\");\n    fprintf(output, \"  -e <field>               field to print if -Tfields selected (e.g. tcp.port,\\n\");\n    fprintf(output, \"                           _ws.col.info)\\n\");\n    fprintf(output, \"                           this option can be repeated to print multiple fields\\n\");\n    fprintf(output, \"  -E<fieldsoption>=<value> set options for output when -Tfields selected:\\n\");\n    fprintf(output, \"     bom=y|n               print a UTF-8 BOM\\n\");\n    fprintf(output, \"     header=y|n            switch headers on and off\\n\");\n    fprintf(output, \"     separator=/t|/s|<char> select tab, space, printable character as separator\\n\");\n    fprintf(output, \"     occurrence=f|l|a      print first, last or all occurrences of each field\\n\");\n    fprintf(output, \"     aggregator=,|/s|<char> select comma, space, printable character as\\n\");\n    fprintf(output, \"                           aggregator\\n\");\n    fprintf(output, \"     quote=d|s|n           select double, single, no quotes for values\\n\");\n    fprintf(output, \"  -t (a|ad|adoy|d|dd|e|r|u|ud|udoy)[.[N]]|.[N]\\n\");\n    fprintf(output, \"                           output format of time stamps (def: r: rel. to first)\\n\");\n    fprintf(output, \"  -u s|hms                 output format of seconds (def: s: seconds)\\n\");\n    fprintf(output, \"  -l                       flush standard output after each packet\\n\");\n    fprintf(output, \"                           (implies --update-interval 0)\\n\");\n    fprintf(output, \"  -q                       be more quiet on stdout (e.g. when using statistics)\\n\");\n    fprintf(output, \"  -Q                       only log true errors to stderr (quieter than -q)\\n\");\n    fprintf(output, \"  -g                       enable group read access on the output file(s)\\n\");\n    fprintf(output, \"  -W n                     Save extra information in the file, if supported.\\n\");\n    fprintf(output, \"                           n = write network address resolution information\\n\");\n    fprintf(output, \"  -X <key>:<value>         eXtension options, see the man page for details\\n\");\n    fprintf(output, \"  -U tap_name              PDUs export mode, see the man page for details\\n\");\n    fprintf(output, \"  -z <statistics>          various statistics, see the man page for details\\n\");\n    fprintf(output, \"  --export-objects <protocol>,<destdir>\\n\");\n    fprintf(output, \"                           save exported objects for a protocol to a directory\\n\");\n    fprintf(output, \"                           named \\\"destdir\\\"\\n\");\n    fprintf(output, \"  --export-tls-session-keys <keyfile>\\n\");\n    fprintf(output, \"                           export TLS Session Keys to a file named \\\"keyfile\\\"\\n\");\n    fprintf(output, \"  --color                  color output text similarly to the Wireshark GUI,\\n\");\n    fprintf(output, \"                           requires a terminal with 24-bit color support\\n\");\n    fprintf(output, \"                           Also supplies color attributes to pdml and psml formats\\n\");\n    fprintf(output, \"                           (Note that attributes are nonstandard)\\n\");\n    fprintf(output, \"  --no-duplicate-keys      If -T json is specified, merge duplicate keys in an object\\n\");\n    fprintf(output, \"                           into a single key with as value a json array containing all\\n\");\n    fprintf(output, \"                           values\\n\");\n    fprintf(output, \"  --elastic-mapping-filter <protocols> If -G elastic-mapping is specified, put only the\\n\");\n    fprintf(output, \"                           specified protocols within the mapping file\\n\");\n    fprintf(output, \"  --temp-dir <directory>   write temporary files to this directory\\n\");\n    fprintf(output, \"                           (default: %s)\\n\", g_get_tmp_dir());\n    fprintf(output, \"  --compress <type>        compress the output file using the type compression format\\n\");\n    fprintf(output, \"\\n\");\n\n    ws_log_print_usage(output);\n    fprintf(output, \"\\n\");\n\n    fprintf(output, \"Miscellaneous:\\n\");\n    fprintf(output, \"  -h, --help               display this help and exit\\n\");\n    fprintf(output, \"  -v, --version            display version info and exit\\n\");\n    fprintf(output, \"  -o <name>:<value> ...    override preference setting\\n\");\n    fprintf(output, \"  -K <keytab>              keytab file to use for kerberos decryption\\n\");\n    fprintf(output, \"  -G [report]              dump one of several available reports and exit\\n\");\n    fprintf(output, \"                           default report=\\\"fields\\\"\\n\");\n    fprintf(output, \"                           use \\\"-G help\\\" for more help\\n\");\n#ifdef __linux__\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Dumpcap can benefit from an enabled BPF JIT compiler if available.\\n\");\n    fprintf(output, \"You might want to enable it by executing:\\n\");\n    fprintf(output, \" \\\"echo 1 > /proc/sys/net/core/bpf_jit_enable\\\"\\n\");\n    fprintf(output, \"Note that this can make your system less secure!\\n\");\n#endif\n\n}\n\nstatic void\nglossary_option_help(void)\n{\n    FILE *output;\n\n    output = stdout;\n\n    fprintf(output, \"%s\\n\", get_appname_and_version());\n\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Usage: tshark -G [report]\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Glossary table reports:\\n\");\n    fprintf(output, \"  -G column-formats        dump column format codes and exit\\n\");\n    fprintf(output, \"  -G decodes               dump \\\"layer type\\\"/\\\"decode as\\\" associations and exit\\n\");\n    fprintf(output, \"  -G dissector-tables      dump dissector table names, types, and properties\\n\");\n    fprintf(output, \"  -G dissectors            dump registered dissector names\\n\");\n    fprintf(output, \"  -G elastic-mapping       dump ElasticSearch mapping file\\n\");\n    fprintf(output, \"  -G enterprises           dump IANA Private Enterprise Number (PEN) table\\n\");\n    fprintf(output, \"  -G fieldcount            dump count of header fields and exit\\n\");\n    fprintf(output, \"  -G fields,[prefix]       dump fields glossary and exit\\n\");\n    fprintf(output, \"  -G ftypes                dump field type basic and descriptive names\\n\");\n    fprintf(output, \"  -G heuristic-decodes     dump heuristic dissector tables\\n\");\n    fprintf(output, \"  -G manuf                 dump ethernet manufacturer tables\\n\");\n    fprintf(output, \"  -G plugins               dump installed plugins and exit\\n\");\n    fprintf(output, \"  -G protocols             dump protocols in registration database and exit\\n\");\n    fprintf(output, \"  -G services              dump transport service (port) names\\n\");\n    fprintf(output, \"  -G values                dump value, range, true/false strings and exit\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Preference reports:\\n\");\n    fprintf(output, \"  -G currentprefs          dump current preferences and exit\\n\");\n    fprintf(output, \"  -G defaultprefs          dump default preferences and exit\\n\");\n    fprintf(output, \"  -G folders               dump about:folders\\n\");\n    fprintf(output, \"\\n\");\n}\n\nstatic void\nhexdump_option_help(FILE *output)\n{\n    fprintf(output, \"%s\\n\", get_appname_and_version());\n    fprintf(output, \"\\n\");\n    fprintf(output, \"tshark: Valid --hexdump <hexoption> values include:\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Data source options:\\n\");\n    fprintf(output, \"  all                      add hexdump, dump all data sources (-x default)\\n\");\n    fprintf(output, \"  frames                   add hexdump, dump only frame data source\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"ASCII options:\\n\");\n    fprintf(output, \"  ascii                    add hexdump, include ASCII dump text (-x default)\\n\");\n    fprintf(output, \"  delimit                  add hexdump, delimit ASCII dump text with '|' characters\\n\");\n    fprintf(output, \"  noascii                  add hexdump, exclude ASCII dump text\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Timestamp options:\\n\");\n    fprintf(output, \"  time                     add hexdump, include frame timestamp preamble (uses the format from -t)\\n\");\n    fprintf(output, \"  notime                   add hexdump, do not include frame timestamp preamble (-x default)\\n\");\n    fprintf(output, \"Miscellaneous:\\n\");\n    fprintf(output, \"  help                     display this help and exit\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"Example:\\n\");\n    fprintf(output, \"\\n\");\n    fprintf(output, \"    $ tshark ... --hexdump frames --hexdump delimit ...\\n\");\n    fprintf(output, \"\\n\");\n}\n\nstatic void\nprint_current_user(void)\n{\n    char *cur_user, *cur_group;\n\n    if (started_with_special_privs()) {\n        cur_user = get_cur_username();\n        cur_group = get_cur_groupname();\n        fprintf(stderr, \"Running as user \\\"%s\\\" and group \\\"%s\\\".\",\n                cur_user, cur_group);\n        g_free(cur_user);\n        g_free(cur_group);\n        if (running_with_special_privs()) {\n            fprintf(stderr, \" This could be dangerous.\");\n        }\n        fprintf(stderr, \"\\n\");\n    }\n}\n\nstatic void\ngather_tshark_compile_info(feature_list l)\n{\n    /* Capture libraries */\n    gather_caplibs_compile_info(l);\n    epan_gather_compile_info(l);\n}\n\nstatic void\ngather_tshark_runtime_info(feature_list l)\n{\n#ifdef HAVE_LIBPCAP\n    gather_caplibs_runtime_info(l);\n#endif\n\n    /* stuff used by libwireshark */\n    epan_gather_runtime_info(l);\n}\n\nstatic bool\n_compile_dfilter(const char *text, dfilter_t **dfp, const char *caller)\n{\n    bool ok;\n    df_error_t *df_err;\n    char *err_off;\n    char *expanded;\n    int64_t elapsed_start;\n\n    elapsed_start = g_get_monotonic_time();\n    expanded = dfilter_expand(text, &df_err);\n    if (expanded == NULL) {\n        cmdarg_err(\"%s\", df_err->msg);\n        df_error_free(&df_err);\n        return false;\n    }\n    tshark_elapsed.dfilter_expand = g_get_monotonic_time() - elapsed_start;\n\n    elapsed_start = g_get_monotonic_time();\n    ok = dfilter_compile_full(expanded, dfp, &df_err, DF_OPTIMIZE, caller);\n    if (!ok ) {\n        cmdarg_err(\"%s\", df_err->msg);\n\n        if (df_err->loc.col_start >= 0) {\n            err_off = ws_strdup_underline(NULL, df_err->loc.col_start, df_err->loc.col_len);\n            cmdarg_err_cont(\"    %s\", expanded);\n            cmdarg_err_cont(\"    %s\", err_off);\n            g_free(err_off);\n        }\n        df_error_free(&df_err);\n    }\n    tshark_elapsed.dfilter_compile = g_get_monotonic_time() - elapsed_start;\n\n    g_free(expanded);\n    return ok;\n}\n\n#define compile_dfilter(text, dfp)      _compile_dfilter(text, dfp, __func__)\n\nstatic bool\nprotocolfilter_add_opt(const char* arg, pf_flags filter_flags)\n{\n    char **newfilter = NULL;\n    for (newfilter = wmem_strsplit(wmem_epan_scope(), arg, \" \", -1); *newfilter; newfilter++) {\n        if (strcmp(*newfilter, \"\") == 0) {\n            /* Don't treat the empty string as an intended field abbreviation\n             * to output, consecutive spaces on the command line probably\n             * aren't intentional.\n             */\n            continue;\n        }\n        if (!output_fields_add_protocolfilter(output_fields, *newfilter, filter_flags)) {\n            cmdarg_err(\"%s was already specified with different filter flags. Overwriting previous protocol filter.\", *newfilter);\n        }\n    }\n    return true;\n}\n\nstatic void\nabout_folders(void)\n{\n    const char           *constpath;\n    char                 *path;\n    int                   i;\n    char                **resultArray;\n\n    /* \"file open\" */\n\n    /*\n     * Fetching the \"File\" dialogs folder not implemented.\n     * This is arguably just a pwd for a ui/cli .\n     */\n\n    /* temp */\n    constpath = g_get_tmp_dir();\n#ifdef HAVE_LIBPCAP\n    /* global_capture_opts only exists in this case */\n    if (global_capture_opts.temp_dir)\n        constpath = global_capture_opts.temp_dir;\n#endif\n    printf(\"%-21s\\t%s\\n\", \"Temp:\", constpath);\n\n    /* pers conf */\n    path = get_persconffile_path(\"\", false);\n    printf(\"%-21s\\t%s\\n\", \"Personal configuration:\", path);\n    g_free(path);\n\n    /* global conf */\n    constpath = get_datafile_dir();\n    if (constpath != NULL) {\n        printf(\"%-21s\\t%s\\n\", \"Global configuration:\", constpath);\n    }\n\n    /* system */\n    constpath = get_systemfile_dir();\n    printf(\"%-21s\\t%s\\n\", \"System:\", constpath);\n\n    /* program */\n    constpath = get_progfile_dir();\n    printf(\"%-21s\\t%s\\n\", \"Program:\", constpath);\n\n#ifdef HAVE_PLUGINS\n    /* pers plugins */\n    printf(\"%-21s\\t%s\\n\", \"Personal Plugins:\", get_plugins_pers_dir_with_version());\n\n    /* global plugins */\n    printf(\"%-21s\\t%s\\n\", \"Global Plugins:\", get_plugins_dir_with_version());\n#endif\n\n#ifdef HAVE_LUA\n    /* pers lua plugins */\n    printf(\"%-21s\\t%s\\n\", \"Personal Lua Plugins:\", get_plugins_pers_dir());\n\n    /* global lua plugins */\n    printf(\"%-21s\\t%s\\n\", \"Global Lua Plugins:\", get_plugins_dir());\n#endif\n\n    /* Personal Extcap */\n    constpath = get_extcap_pers_dir();\n\n    resultArray = g_strsplit(constpath, G_SEARCHPATH_SEPARATOR_S, 10);\n    for(i = 0; resultArray[i]; i++)\n        printf(\"%-21s\\t%s\\n\", \"Personal Extcap path:\", g_strstrip(resultArray[i]));\n\n    g_strfreev(resultArray);\n\n    /* Global Extcap */\n    constpath = get_extcap_dir();\n\n    resultArray = g_strsplit(constpath, G_SEARCHPATH_SEPARATOR_S, 10);\n    for(i = 0; resultArray[i]; i++)\n        printf(\"%-21s\\t%s\\n\", \"Global Extcap path:\", g_strstrip(resultArray[i]));\n\n    g_strfreev(resultArray);\n\n    /* MaxMindDB */\n    path = maxmind_db_get_paths();\n\n    resultArray = g_strsplit(path, G_SEARCHPATH_SEPARATOR_S, 10);\n\n    for(i = 0; resultArray[i]; i++)\n        printf(\"%-21s\\t%s\\n\", \"MaxMind database path:\", g_strstrip(resultArray[i]));\n\n    g_strfreev(resultArray);\n    g_free(path);\n\n#ifdef HAVE_LIBSMI\n    /* SMI MIBs/PIBs */\n    path = oid_get_default_mib_path();\n\n    resultArray = g_strsplit(path, G_SEARCHPATH_SEPARATOR_S, 20);\n\n    for(i = 0; resultArray[i]; i++)\n        printf(\"%-21s\\t%s\\n\", \"MIB/PIB path:\", g_strstrip(resultArray[i]));\n\n    g_strfreev(resultArray);\n    g_free(path);\n#endif\n\n}\n\nstatic int\ndump_glossary(const char* glossary, const char* elastic_mapping_filter)\n{\n    int exit_status = EXIT_SUCCESS;\n    /* If invoked with the \"-G\" flag, we dump out information based on\n       the argument to the \"-G\" flag.\n     */\n\n    /* This is now called after the preferences are loaded and all\n     * the command line options are handled, including -o, -d,\n     * --[enable|disable]-[protocol|heuristic].\n     * Some UATs can register new fields (e.g. HTTP/2), so for most\n     * cases load everything.\n     *\n     * prefs_reset() is used for defaultprefs to get the default values.\n     * Note that makes it difficult to use defaultprefs in concert with\n     * any other glossary (we could do it last.)\n     */\n    proto_initialize_all_prefixes();\n\n    if (strcmp(glossary, \"column-formats\") == 0)\n        column_dump_column_formats();\n    else if (strcmp(glossary, \"currentprefs\") == 0) {\n        write_prefs(NULL);\n    }\n    else if (strcmp(glossary, \"decodes\") == 0) {\n        dissector_dump_decodes();\n    } else if (strcmp(glossary, \"defaultprefs\") == 0) {\n        prefs_reset();\n        write_prefs(NULL);\n    } else if (strcmp(glossary, \"dissector-tables\") == 0)\n        dissector_dump_dissector_tables();\n    else if (strcmp(glossary, \"dissectors\") == 0)\n        dissector_dump_dissectors();\n    else if (strcmp(glossary, \"elastic-mapping\") == 0)\n        proto_registrar_dump_elastic(elastic_mapping_filter);\n    else if (strncmp(glossary, \"elastic-mapping,\", strlen(\"elastic-mapping,\")) == 0) {\n        elastic_mapping_filter = glossary + strlen(\"elastic-mapping,\");\n        proto_registrar_dump_elastic(elastic_mapping_filter);\n    }\n    else if (strcmp(glossary, \"fieldcount\") == 0) {\n        /* return value for the test suite */\n        exit_status = proto_registrar_dump_fieldcount();\n    }\n    else if (strcmp(glossary, \"fields\") == 0) {\n        proto_registrar_dump_fields();\n    }\n    else if (strncmp(glossary, \"fields,\", strlen(\"fields,\")) == 0) {\n        const char* prefix = glossary + strlen(\"fields,\");\n        bool matched = proto_registrar_dump_field_completions(prefix);\n        if (!matched) {\n            cmdarg_err(\"No field or protocol begins with \\\"%s\\\"\", prefix);\n            exit_status = EXIT_FAILURE;\n        }\n    }\n    else if (strcmp(glossary, \"folders\") == 0) {\n        about_folders();\n    } else if (strcmp(glossary, \"ftypes\") == 0)\n        proto_registrar_dump_ftypes();\n    else if (strcmp(glossary, \"heuristic-decodes\") == 0) {\n        dissector_dump_heur_decodes();\n    } else if (strcmp(glossary, \"manuf\") == 0)\n        ws_manuf_dump(stdout);\n    else if (strcmp(glossary, \"enterprises\") == 0)\n        global_enterprises_dump(stdout);\n    else if (strcmp(glossary, \"services\") == 0)\n        global_services_dump(stdout);\n    else if (strcmp(glossary, \"plugins\") == 0) {\n#ifdef HAVE_PLUGINS\n        codecs_init();\n        plugins_dump_all();\n#endif\n#ifdef HAVE_LUA\n        wslua_plugins_dump_all();\n#endif\n        extcap_dump_all();\n    }\n    else if (strcmp(glossary, \"protocols\") == 0) {\n        proto_registrar_dump_protocols();\n    } else if (strcmp(glossary, \"values\") == 0)\n        proto_registrar_dump_values();\n    else if (strcmp(glossary, \"help\") == 0)\n        glossary_option_help();\n    /* These are supported only for backwards compatibility and may or may not work\n     * for a given user in a given directory on a given operating system with a given\n     * command-line interpreter.\n     */\n    else if (strcmp(glossary, \"?\") == 0)\n        glossary_option_help();\n    else if (strcmp(glossary, \"-?\") == 0)\n        glossary_option_help();\n    else {\n        cmdarg_err(\"Invalid \\\"%s\\\" option for -G flag, enter -G help for more help.\", glossary);\n        exit_status = WS_EXIT_INVALID_OPTION;\n    }\n\n    return exit_status;\n}\n\nstatic bool\nmust_do_dissection(dfilter_t *rfcode, dfilter_t *dfcode,\n        char *volatile pdu_export_arg)\n{\n    /* We have to dissect each packet if:\n\n       we're printing information about each packet;\n\n       we're using a read filter on the packets;\n\n       we're using a display filter on the packets;\n\n       we're exporting PDUs;\n\n       we're using any taps that need dissection. */\n    return print_packet_info || rfcode || dfcode || pdu_export_arg ||\n        tap_listeners_require_dissection();\n}\n\n#ifdef HAVE_LIBPCAP\n/*\n * Check whether a purported *shark packet-matching expression (display\n * or read filter) looks like a capture filter and, if so, print a\n * warning.\n *\n * Used, for example, if the string in question isn't a valid packet-\n * matching expression.\n */\nstatic void\nwarn_about_capture_filter(const char *rfilter)\n{\n    struct bpf_program   fcode;\n    pcap_t *pc;\n\n    pc = pcap_open_dead(DLT_EN10MB, MIN_PACKET_SIZE);\n    if (pc != NULL) {\n        if (pcap_compile(pc, &fcode, rfilter, 0, 0) != -1) {\n            pcap_freecode(&fcode);\n            cmdarg_err_cont(\n                    \"  Note: That read filter code looks like a valid capture filter;\\n\"\n                    \"        maybe you mixed them up?\");\n        }\n        pcap_close(pc);\n    }\n}\n#endif\n\n#ifdef HAVE_LIBPCAP\nstatic GList *cached_if_list;\n\nstatic GList *\ncapture_opts_get_interface_list(int *err, char **err_str)\n{\n    if (cached_if_list == NULL) {\n        /*\n         * This isn't a GUI tool, so no need for a callback.\n         */\n        cached_if_list = capture_interface_list(err, err_str, NULL);\n    }\n    /*\n     * Routines expect to free the returned interface list, so return\n     * a deep copy.\n     */\n    return interface_list_copy(cached_if_list);\n}\n#endif\n\nint\nmain(int argc, char *argv[])\n{\n    char                *err_msg;\n    int                  opt;\n    static const struct ws_option long_options[] = {\n        {\"help\", ws_no_argument, NULL, 'h'},\n        {\"version\", ws_no_argument, NULL, 'v'},\n        LONGOPT_CAPTURE_COMMON\n        LONGOPT_DISSECT_COMMON\n        LONGOPT_READ_CAPTURE_COMMON\n        {\"print\", ws_no_argument, NULL, 'P'},\n        {\"export-objects\", ws_required_argument, NULL, LONGOPT_EXPORT_OBJECTS},\n        {\"export-tls-session-keys\", ws_required_argument, NULL, LONGOPT_EXPORT_TLS_SESSION_KEYS},\n        {\"color\", ws_no_argument, NULL, LONGOPT_COLOR},\n        {\"no-duplicate-keys\", ws_no_argument, NULL, LONGOPT_NO_DUPLICATE_KEYS},\n        {\"elastic-mapping-filter\", ws_required_argument, NULL, LONGOPT_ELASTIC_MAPPING_FILTER},\n        {\"capture-comment\", ws_required_argument, NULL, LONGOPT_CAPTURE_COMMENT},\n        {\"hexdump\", ws_required_argument, NULL, LONGOPT_HEXDUMP},\n        {\"selected-frame\", ws_required_argument, NULL, LONGOPT_SELECTED_FRAME},\n        {\"print-timers\", ws_no_argument, NULL, LONGOPT_PRINT_TIMERS},\n        {\"global-profile\", ws_no_argument, NULL, LONGOPT_GLOBAL_PROFILE},\n        {\"compress\", ws_required_argument, NULL, LONGOPT_COMPRESS},\n        {0, 0, 0, 0}\n    };\n    bool                 arg_error = false;\n    bool                 has_extcap_options = false;\n    volatile bool        is_capturing = true;\n\n    int                  err;\n    char                *err_info;\n    bool                 exp_pdu_status;\n    volatile process_file_status_t status;\n    volatile bool        draw_taps = false;\n    volatile int         exit_status = EXIT_SUCCESS;\n#ifdef HAVE_LIBPCAP\n    int                  caps_queries = 0;\n    GList               *if_list;\n    char                *err_str, *err_str_secondary;\n#else\n    bool                 capture_option_specified = false;\n    volatile int         max_packet_count = 0;\n#endif\n    volatile int          out_file_type = WTAP_FILE_TYPE_SUBTYPE_UNKNOWN;\n    volatile bool         out_file_name_res = false;\n    volatile int          in_file_type = WTAP_TYPE_AUTO;\n    char                 *volatile cf_name = NULL;\n    char                 *rfilter = NULL;\n    char                 *volatile dfilter = NULL;\n    dfilter_t            *rfcode = NULL;\n    dfilter_t            *dfcode = NULL;\n    e_prefs              *prefs_p;\n    char                 *output_only = NULL;\n    char                 *volatile pdu_export_arg = NULL;\n    char                 *volatile exp_pdu_filename = NULL;\n    const char           *volatile tls_session_keys_file = NULL;\n    exp_pdu_t             exp_pdu_tap_data;\n    const char*           glossary = NULL;\n    const char*           elastic_mapping_filter = NULL;\n    wtap_compression_type volatile compression_type = WTAP_UNKNOWN_COMPRESSION;\n\n    /*\n     * The leading + ensures that getopt_long() does not permute the argv[]\n     * entries.\n     *\n     * We have to make sure that the first getopt_long() preserves the content\n     * of argv[] for the subsequent getopt_long() call.\n     *\n     * We use getopt_long() in both cases to ensure that we're using a routine\n     * whose permutation behavior we can control in the same fashion on all\n     * platforms, and so that, if we ever need to process a long argument before\n     * doing further initialization, we can do so.\n     *\n     * Glibc and Solaris libc document that a leading + disables permutation\n     * of options, regardless of whether POSIXLY_CORRECT is set or not; *BSD\n     * and macOS don't document it, but do so anyway.\n     *\n     * We do *not* use a leading - because the behavior of a leading - is\n     * platform-dependent.\n     */\n#define OPTSTRING \"+2\" OPTSTRING_CAPTURE_COMMON OPTSTRING_DISSECT_COMMON OPTSTRING_READ_CAPTURE_COMMON \"M:C:e:E:F:gG:hH:j:J:lo:O:PqQS:T:U:vVw:W:xX:z:\"\n\n    static const char    optstring[] = OPTSTRING;\n\n    /* Set the program name. */\n    g_set_prgname(\"tshark\");\n\n    /*\n     * Set the C-language locale to the native environment and set the\n     * code page to UTF-8 on Windows.\n     */\n#ifdef _WIN32\n    setlocale(LC_ALL, \".UTF-8\");\n#else\n    setlocale(LC_ALL, \"\");\n#endif\n\n    ws_tzset();\n\n    cmdarg_err_init(stderr_cmdarg_err, stderr_cmdarg_err_cont);\n\n    /* Initialize log handler early so we can have proper logging during startup. */\n    ws_log_init(vcmdarg_err);\n\n    /* Early logging command-line initialization. */\n    ws_log_parse_args(&argc, argv, vcmdarg_err, WS_EXIT_INVALID_OPTION);\n\n    ws_noisy(\"Finished log init and parsing command line log arguments\");\n    ws_debug(\"tshark started with %d args\", argc);\n\n#ifdef _WIN32\n    create_app_running_mutex();\n#endif /* _WIN32 */\n\n    /*\n     * Get credential information for later use, and drop privileges\n     * before doing anything else.\n     * Let the user know if anything happened.\n     */\n    init_process_policies();\n    relinquish_special_privs_perm();\n    print_current_user();\n\n    /*\n     * Attempt to get the pathname of the directory containing the\n     * executable file.\n     */\n    err_msg = configuration_init(argv[0]);\n    if (err_msg != NULL) {\n        fprintf(stderr,\n                \"tshark: Can't get pathname of directory containing the tshark program: %s.\\n\"\n                \"It won't be possible to capture traffic.\\n\"\n                \"Report this to the Wireshark developers.\",\n                err_msg);\n        g_free(err_msg);\n    }\n\n    initialize_funnel_ops();\n\n#ifdef _WIN32\n    ws_init_dll_search_path();\n#ifdef HAVE_LIBPCAP\n    /* Load wpcap if possible. Do this before collecting the run-time version information */\n    load_wpcap();\n#endif /* HAVE_LIBPCAP */\n#endif /* _WIN32 */\n\n    /* Initialize the version information. */\n    ws_init_version_info(\"TShark\",\n            gather_tshark_compile_info, gather_tshark_runtime_info);\n\n    /* Fail sometimes. Useful for testing fuzz scripts. */\n    /* if (g_random_int_range(0, 100) < 5) abort(); */\n\n    /*\n     * In order to have the -X opts assigned before the wslua machine starts\n     * we need to call getopt_long before epan_init() gets called.\n     *\n     * In order to handle, for example, -o options, we also need to call it\n     * *after* epan_init() gets called, so that the dissectors have had a\n     * chance to register their preferences.\n     *\n     * Spawning a bunch of extcap processes can delay program startup,\n     * particularly on Windows. Check to see if we have any options that\n     * might require extcap and set has_extcap_options = true if that's\n     * the case.\n     *\n     * XXX - can we do this all with one getopt_long() call, saving the\n     * arguments we can't handle until after initializing libwireshark,\n     * and then process them after initializing libwireshark?\n     *\n     * We set ws_opterr to 0 so that ws_getopt_long doesn't print error\n     * messages for bad long options. We'll do that once, in the final\n     * call where all the error handling happens.\n     */\n    ws_opterr = 0;\n\n    /*  We should check at first if we should use a global profile before\n        parsing the profile name\n        XXX - We could check this in the next ws_getopt_long, and save the\n        profile name and only apply it after finishing the loop.  */\n    while ((opt = ws_getopt_long(argc, argv, optstring, long_options, NULL)) != -1) {\n        switch (opt) {\n            case LONGOPT_GLOBAL_PROFILE:\n                    set_persconffile_dir(get_datafile_dir());\n                    break;\n            default:\n                break;\n        }\n    }\n\n    /*\n     * Reset the options parser, set ws_optreset to 1 and set ws_optind to 1.\n     * We still don't want to print error messages, though.\n     */\n    ws_optreset = 1;\n    ws_optind = 1;\n\n    while ((opt = ws_getopt_long(argc, argv, optstring, long_options, NULL)) != -1) {\n        switch (opt) {\n            case 'C':        /* Configuration Profile */\n                if (profile_exists (ws_optarg, false)) {\n                    set_profile_name (ws_optarg);\n                } else if (profile_exists (ws_optarg, true)) {\n                    char  *pf_dir_path, *pf_dir_path2, *pf_filename;\n                    /* Copy from global profile */\n                    if (create_persconffile_profile(ws_optarg, &pf_dir_path) == -1) {\n                        cmdarg_err(\"Can't create directory\\n\\\"%s\\\":\\n%s.\",\n                            pf_dir_path, g_strerror(errno));\n\n                        g_free(pf_dir_path);\n                        exit_status = WS_EXIT_INVALID_FILE;\n                        goto clean_exit;\n                    }\n                    if (copy_persconffile_profile(ws_optarg, ws_optarg, true, &pf_filename,\n                            &pf_dir_path, &pf_dir_path2) == -1) {\n                        cmdarg_err(\"Can't copy file \\\"%s\\\" in directory\\n\\\"%s\\\" to\\n\\\"%s\\\":\\n%s.\",\n                            pf_filename, pf_dir_path2, pf_dir_path, g_strerror(errno));\n\n                        g_free(pf_filename);\n                        g_free(pf_dir_path);\n                        g_free(pf_dir_path2);\n                        exit_status = WS_EXIT_INVALID_FILE;\n                        goto clean_exit;\n                    }\n                    set_profile_name (ws_optarg);\n                } else {\n                    cmdarg_err(\"Configuration Profile \\\"%s\\\" does not exist\", ws_optarg);\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'G':\n                if (glossary != NULL) {\n                    /* Multiple glossaries are difficult especially due to defaultprefs */\n                    cmdarg_err(\"Multiple glossary reports (-G) are unsupported\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                } else {\n                    glossary = ws_optarg;\n                }\n                if (g_str_has_suffix(ws_optarg, \"prefs\")) {\n                    has_extcap_options = true;\n                }\n                is_capturing = false;\n                break;\n            case 'i':\n                has_extcap_options = true;\n                break;\n            case 'o':\n                if (g_str_has_prefix(ws_optarg, \"extcap.\")) {\n                    has_extcap_options = true;\n                }\n                break;\n            case 'P':        /* Print packet summary info even when writing to a file */\n                print_packet_info = true;\n                print_summary = true;\n                break;\n            case 'r':        /* Read capture file x */\n                cf_name = g_strdup(ws_optarg);\n                is_capturing = false;\n                break;\n            case 'O':        /* Only output these protocols */\n                output_only = g_strdup(ws_optarg);\n                /* FALLTHROUGH */\n            case 'V':        /* Verbose */\n                print_details = true;\n                print_packet_info = true;\n                break;\n            case 'x':        /* Print packet data in hex (and ASCII) */\n                print_hex = true;\n                /*  The user asked for hex output, so let's ensure they get it,\n                 *  even if they're writing to a file.\n                 */\n                print_packet_info = true;\n                break;\n            case 'X':\n                ex_opt_add(ws_optarg);\n                break;\n            case 'h':\n            case 'v':\n                is_capturing = false;\n                break;\n            default:\n                break;\n        }\n    }\n\n#ifndef HAVE_LUA\n    if (ex_opt_count(\"lua_script\") > 0) {\n        cmdarg_err(\"This version of TShark was not built with support for Lua scripting.\");\n        exit_status = WS_EXIT_INIT_FAILED;\n        goto clean_exit;\n    }\n#endif /* HAVE_LUA */\n\n    init_report_failure_message(\"TShark\");\n\n#ifdef HAVE_LIBPCAP\n    capture_opts_init(&global_capture_opts, capture_opts_get_interface_list);\n    capture_session_init(&global_capture_session, &cfile,\n            capture_input_new_file, capture_input_new_packets,\n            capture_input_drops, capture_input_error,\n            capture_input_cfilter_error, capture_input_closed);\n#endif\n\n    timestamp_set_type(TS_RELATIVE);\n    timestamp_set_precision(TS_PREC_AUTO);\n    timestamp_set_seconds_type(TS_SECONDS_DEFAULT);\n\n    /*\n     * Libwiretap must be initialized before libwireshark is, so that\n     * dissection-time handlers for file-type-dependent blocks can\n     * register using the file type/subtype value for the file type.\n     */\n    wtap_init(true);\n\n    /* Register all dissectors; we must do this before checking for the\n       \"-G\" flag, as the \"-G\" flag dumps information registered by the\n       dissectors, and we must do it before we read the preferences, in\n       case any dissectors register preferences. */\n    if (!epan_init(NULL, NULL, true)) {\n        exit_status = WS_EXIT_INIT_FAILED;\n        goto clean_exit;\n    }\n\n    /* Register all tap listeners; we do this before we parse the arguments,\n       as the \"-z\" argument can specify a registered tap. */\n\n    register_all_tap_listeners(tap_reg_listener);\n\n    /* Register extcap preferences only when needed. */\n    if (has_extcap_options || is_capturing) {\n        /*\n         * XXX - We don't properly handle the capture_no_extcap preference.\n         * To make it work, before registering the extcap preferences we'd\n         * have to read at least that preference for the chosen profile, and\n         * also check to make sure an \"-o\" option didn't override it.\n         * Then, after registering the extcap preferences, we'd have to\n         * set the extcap preferences from the preferences file and \"-o\"\n         * options on the command line.\n         */\n        extcap_register_preferences();\n    }\n\n    conversation_table_set_gui_info(init_iousers);\n    endpoint_table_set_gui_info(init_endpoints);\n    srt_table_iterate_tables(register_srt_tables, NULL);\n    rtd_table_iterate_tables(register_rtd_tables, NULL);\n    stat_tap_iterate_tables(register_simple_stat_tables, NULL);\n\n    ws_debug(\"tshark reading settings\");\n\n    /* Load libwireshark settings from the current profile. */\n    prefs_p = epan_load_settings();\n    prefs_loaded = true;\n\n    cap_file_init(&cfile);\n\n    /* Print format defaults to this. */\n    print_format = PR_FMT_TEXT;\n    delimiter_char = \" \";\n\n    output_fields = output_fields_new();\n\n    /*\n     * To reset the options parser, set ws_optreset to 1 and set ws_optind to 1.\n     *\n     * Also reset ws_opterr to 1, so that error messages are printed by\n     * getopt_long().\n     */\n    ws_optreset = 1;\n    ws_optind = 1;\n    ws_opterr = 1;\n\n    /* Now get our args */\n    while ((opt = ws_getopt_long(argc, argv, optstring, long_options, NULL)) != -1) {\n        switch (opt) {\n            case '2':        /* Perform two-pass analysis */\n                if(epan_auto_reset){\n                    cmdarg_err(\"-2 does not support auto session reset.\");\n                    arg_error=true;\n                }\n                perform_two_pass_analysis = true;\n                break;\n            case 'M':\n                if(perform_two_pass_analysis){\n                    cmdarg_err(\"-M does not support two-pass analysis.\");\n                    arg_error=true;\n                }\n                epan_auto_reset_count = get_positive_int(ws_optarg, \"epan reset count\");\n                epan_auto_reset = true;\n                break;\n            case 'a':        /* autostop criteria */\n            case 'b':        /* Ringbuffer option */\n            case 'f':        /* capture filter */\n            case 'g':        /* enable group read access on file(s) */\n            case 'i':        /* Use interface x */\n            case LONGOPT_SET_TSTAMP_TYPE: /* Set capture timestamp type */\n            case 'p':        /* Don't capture in promiscuous mode */\n#ifdef HAVE_PCAP_REMOTE\n            case 'A':        /* Authentication */\n#endif\n            case 'I':        /* Capture in monitor mode, if available */\n            case 's':        /* Set the snapshot (capture) length */\n            case 'y':        /* Set the pcap data link type */\n            case 'B':        /* Buffer size */\n            case LONGOPT_COMPRESS_TYPE:        /* compress type */\n            case LONGOPT_CAPTURE_TMPDIR:       /* capture temp directory */\n            case LONGOPT_UPDATE_INTERVAL:      /* sync pipe update interval */\n                /* These are options only for packet capture. */\n#ifdef HAVE_LIBPCAP\n                exit_status = capture_opts_add_opt(&global_capture_opts, opt, ws_optarg);\n                if (exit_status != 0) {\n                    goto clean_exit;\n                }\n#else\n                capture_option_specified = true;\n                arg_error = true;\n#endif\n                break;\n            case 'c':        /* Stop after x packets */\n#ifdef HAVE_LIBPCAP\n                exit_status = capture_opts_add_opt(&global_capture_opts, opt, ws_optarg);\n                if (exit_status != 0) {\n                    goto clean_exit;\n                }\n#else\n                max_packet_count = get_positive_int(ws_optarg, \"packet count\");\n#endif\n                break;\n            case 'w':        /* Write to file x */\n                output_file_name = g_strdup(ws_optarg);\n#ifdef HAVE_LIBPCAP\n                exit_status = capture_opts_add_opt(&global_capture_opts, opt, ws_optarg);\n                if (exit_status != 0) {\n                    goto clean_exit;\n                }\n#endif\n                break;\n            case 'C':\n                /* already processed; just ignore it now */\n                break;\n            case 'D':        /* Print a list of capture devices and exit */\n#ifdef HAVE_LIBPCAP\n                exit_status = EXIT_SUCCESS;\n                if_list = capture_interface_list(&err, &err_str,NULL);\n                if (err != 0) {\n                    /*\n                     * An error occurred when fetching the local\n                     * interfaces.  Report it.\n                     */\n                    cmdarg_err(\"%s\", err_str);\n                    g_free(err_str);\n                    exit_status = WS_EXIT_PCAP_ERROR;\n                }\n                if (if_list == NULL) {\n                    /*\n                     * No interfaces were found.  If that's not the\n                     * result of an error when fetching the local\n                     * interfaces, let the user know.\n                     */\n                    if (err == 0) {\n                        cmdarg_err(\"There are no interfaces on which a capture can be done\");\n                        exit_status = WS_EXIT_NO_INTERFACES;\n                    }\n                    goto clean_exit;\n                }\n                capture_opts_print_interfaces(if_list);\n                free_interface_list(if_list);\n                goto clean_exit;\n#else\n                capture_option_specified = true;\n                arg_error = true;\n#endif\n                break;\n            case 'e':\n                /* Field entry */\n                {\n                    const char* col_field = try_convert_to_column_field(ws_optarg);\n                    if (col_field) {\n                        output_fields_add(output_fields, col_field);\n                    } else {\n                        header_field_info *hfi = proto_registrar_get_byalias(ws_optarg);\n                        if (hfi)\n                            output_fields_add(output_fields, hfi->abbrev);\n                        else\n                            output_fields_add(output_fields, ws_optarg);\n                    }\n                }\n                break;\n            case 'E':\n                /* Field option */\n                if (!output_fields_set_option(output_fields, ws_optarg)) {\n                    cmdarg_err(\"\\\"%s\\\" is not a valid field output option=value pair.\", ws_optarg);\n                    output_fields_list_options(stderr);\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'F':\n                out_file_type = wtap_name_to_file_type_subtype(ws_optarg);\n                if (out_file_type < 0) {\n                    cmdarg_err(\"\\\"%s\\\" isn't a valid capture file type\", ws_optarg);\n                    list_capture_types();\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'G':\n                /* already processed; just ignore it now */\n                break;\n            case 'j':\n                if (!protocolfilter_add_opt(ws_optarg, PF_NONE)) {\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'J':\n                if (!protocolfilter_add_opt(ws_optarg, PF_INCLUDE_CHILDREN)) {\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'W':        /* Select extra information to save in our capture file */\n                /* This is patterned after the -N flag which may not be the best idea. */\n                if (strchr(ws_optarg, 'n')) {\n                    out_file_name_res = true;\n                } else {\n                    cmdarg_err(\"Invalid -W argument \\\"%s\\\"; it must be one of:\", ws_optarg);\n                    cmdarg_err_cont(\"\\t'n' write network address resolution information (pcapng only)\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'H':        /* Read address to name mappings from a hosts file */\n                if (! add_hosts_file(ws_optarg))\n                {\n                    cmdarg_err(\"Can't read host entries from \\\"%s\\\"\", ws_optarg);\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                out_file_name_res = true;\n                break;\n\n            case 'h':        /* Print help and exit */\n                show_help_header(\"Dump and analyze network traffic.\");\n                print_usage(stdout);\n                exit_status = EXIT_SUCCESS;\n                goto clean_exit;\n                break;\n            case 'l':        /* \"Line-buffer\" standard output */\n                /* The ANSI C standard does not appear to *require* that a line-buffered\n                   stream be flushed to the host environment whenever a newline is\n                   written, it just says that, on such a stream, characters \"are\n                   intended to be transmitted to or from the host environment as a\n                   block when a new-line character is encountered\".\n\n                   The Visual C++ 6.0 C implementation doesn't do what is intended;\n                   even if you set a stream to be line-buffered, it still doesn't\n                   flush the buffer at the end of every line.\n\n                   The whole reason for the \"-l\" flag in either tcpdump or TShark\n                   is to allow the output of a live capture to be piped to a program\n                   or script and to have that script see the information for the\n                   packet as soon as it's printed, rather than having to wait until\n                   a standard I/O buffer fills up.\n\n                   So, if the \"-l\" flag is specified, we flush the standard output\n                   at the end of a packet.  This will do the right thing if we're\n                   printing packet summary lines, and, as we print the entire protocol\n                   tree for a single packet without waiting for anything to happen,\n                   it should be as good as line-buffered mode if we're printing\n                   protocol trees - arguably even better, as it may do fewer\n                   writes. */\n                line_buffered = true;\n#ifdef HAVE_LIBPCAP\n                /* Set the update-interval to 0 so that dumpcap reports packets\n                 * as soon as available instead of buffering them.\n                 */\n                exit_status = capture_opts_add_opt(&global_capture_opts, opt, ws_optarg);\n                if (exit_status != 0) {\n                    goto clean_exit;\n                }\n#endif\n                break;\n            case 'L':        /* Print list of link-layer types and exit */\n#ifdef HAVE_LIBPCAP\n                caps_queries |= CAPS_QUERY_LINK_TYPES;\n#else\n                capture_option_specified = true;\n                arg_error = true;\n#endif\n                break;\n            case LONGOPT_LIST_TSTAMP_TYPES: /* List possible timestamp types */\n#ifdef HAVE_LIBPCAP\n                caps_queries |= CAPS_QUERY_TIMESTAMP_TYPES;\n#else\n                capture_option_specified = true;\n                arg_error = true;\n#endif\n                break;\n            case 'o':        /* Override preference from command line */\n                {\n                    char *errmsg = NULL;\n\n                    switch (prefs_set_pref(ws_optarg, &errmsg)) {\n\n                        case PREFS_SET_OK:\n                            break;\n\n                        case PREFS_SET_SYNTAX_ERR:\n                            cmdarg_err(\"Invalid -o flag \\\"%s\\\"%s%s\", ws_optarg,\n                                    errmsg ? \": \" : \"\", errmsg ? errmsg : \"\");\n                            g_free(errmsg);\n                            exit_status = WS_EXIT_INVALID_OPTION;\n                            goto clean_exit;\n                            break;\n\n                        case PREFS_SET_NO_SUCH_PREF:\n                            cmdarg_err(\"-o flag \\\"%s\\\" specifies unknown preference\", ws_optarg);\n                            exit_status = WS_EXIT_INVALID_OPTION;\n                            goto clean_exit;\n                            break;\n\n                        case PREFS_SET_OBSOLETE:\n                            cmdarg_err(\"-o flag \\\"%s\\\" specifies obsolete preference\", ws_optarg);\n                            exit_status = WS_EXIT_INVALID_OPTION;\n                            goto clean_exit;\n                            break;\n                    }\n                    break;\n                }\n            case 'q':        /* Quiet */\n                quiet = true;\n                break;\n            case 'Q':        /* Really quiet */\n                quiet = true;\n                really_quiet = true;\n                break;\n            case 'r':\n                /* already processed; just ignore it now */\n                break;\n            case 'R':        /* Read file filter */\n                rfilter = ws_optarg;\n                break;\n            case 'P':\n                /* already processed; just ignore it now */\n                break;\n            case 'S':        /* Set the line Separator to be printed between packets */\n                separator = ws_optarg;\n                break;\n            case 'T':        /* printing Type */\n                /* output_action has been already set. It means multiple -T. */\n                if (output_action > WRITE_NONE) {\n                    cmdarg_err(\"Multiple -T parameters are unsupported\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                print_packet_info = true;\n                if (strcmp(ws_optarg, \"text\") == 0) {\n                    output_action = WRITE_TEXT;\n                    print_format = PR_FMT_TEXT;\n                } else if (strcmp(ws_optarg, \"tabs\") == 0) {\n                    output_action = WRITE_TEXT;\n                    print_format = PR_FMT_TEXT;\n                    delimiter_char = \"\\t\";\n                } else if (strcmp(ws_optarg, \"ps\") == 0) {\n                    output_action = WRITE_TEXT;\n                    print_format = PR_FMT_PS;\n                } else if (strcmp(ws_optarg, \"pdml\") == 0) {\n                    output_action = WRITE_XML;\n                    print_details = true;   /* Need details */\n                    print_summary = false;  /* Don't allow summary */\n                } else if (strcmp(ws_optarg, \"psml\") == 0) {\n                    output_action = WRITE_XML;\n                    print_details = false;  /* Don't allow details */\n                    print_summary = true;   /* Need summary */\n                } else if (strcmp(ws_optarg, \"fields\") == 0) {\n                    output_action = WRITE_FIELDS;\n                    print_details = true;   /* Need full tree info */\n                    print_summary = false;  /* Don't allow summary */\n                } else if (strcmp(ws_optarg, \"json\") == 0) {\n                    output_action = WRITE_JSON;\n                    print_details = true;   /* Need details */\n                    print_summary = false;  /* Don't allow summary */\n                } else if (strcmp(ws_optarg, \"ek\") == 0) {\n                    output_action = WRITE_EK;\n                    if (!print_summary)\n                        print_details = true;\n                } else if (strcmp(ws_optarg, \"jsonraw\") == 0) {\n                    output_action = WRITE_JSON_RAW;\n                    print_details = true;   /* Need details */\n                    print_summary = false;  /* Don't allow summary */\n                }\n                else {\n                    cmdarg_err(\"Invalid -T parameter \\\"%s\\\"; it must be one of:\", ws_optarg);                   /* x */\n                    cmdarg_err_cont(\"\\t\\\"fields\\\"  The values of fields specified with the -e option, in a form\\n\"\n                            \"\\t          specified by the -E option.\\n\"\n                            \"\\t\\\"pdml\\\"    Packet Details Markup Language, an XML-based format for the\\n\"\n                            \"\\t          details of a decoded packet. This information is equivalent to\\n\"\n                            \"\\t          the packet details printed with the -V flag.\\n\"\n                            \"\\t\\\"ps\\\"      PostScript for a human-readable one-line summary of each of\\n\"\n                            \"\\t          the packets, or a multi-line view of the details of each of\\n\"\n                            \"\\t          the packets, depending on whether the -V flag was specified.\\n\"\n                            \"\\t\\\"psml\\\"    Packet Summary Markup Language, an XML-based format for the\\n\"\n                            \"\\t          summary information of a decoded packet. This information is\\n\"\n                            \"\\t          equivalent to the information shown in the one-line summary\\n\"\n                            \"\\t          printed by default.\\n\"\n                            \"\\t\\\"json\\\"    Packet Summary, an JSON-based format for the details\\n\"\n                            \"\\t          summary information of a decoded packet. This information is \\n\"\n                            \"\\t          equivalent to the packet details printed with the -V flag.\\n\"\n                            \"\\t\\\"jsonraw\\\" Packet Details, a JSON-based format for machine parsing\\n\"\n                            \"\\t          including only raw hex decoded fields (same as -T json -x but\\n\"\n                            \"\\t          without text decoding, only raw fields included). \\n\"\n                            \"\\t\\\"ek\\\"      Packet Details, an EK JSON-based format for the bulk insert \\n\"\n                            \"\\t          into elastic search cluster. This information is \\n\"\n                            \"\\t          equivalent to the packet details printed with the -V flag.\\n\"\n                            \"\\t\\\"text\\\"    Text of a human-readable one-line summary of each of the\\n\"\n                            \"\\t          packets, or a multi-line view of the details of each of the\\n\"\n                            \"\\t          packets, depending on whether the -V flag was specified.\\n\"\n                            \"\\t          This is the default.\\n\"\n                            \"\\t\\\"tabs\\\"    Similar to the text report except that each column of the\\n\"\n                            \"\\t          human-readable one-line summary is delimited with an ASCII\\n\"\n                            \"\\t          horizontal tab character.\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'U':        /* Export PDUs to file */\n                if (strcmp(ws_optarg, \"\") == 0 || strcmp(ws_optarg, \"?\") == 0) {\n                    list_export_pdu_taps();\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                pdu_export_arg = g_strdup(ws_optarg);\n                break;\n            case 'v':         /* Show version and exit */\n#ifdef ENABLE_CHECK_FILTER\n                /* If we're testing start-up of the epan library, go ahead and\n                 * load all the delayed initialization prefixes (e.g. Diameter)\n                 * so that they are reported on.\n                 */\n                proto_initialize_all_prefixes();\n#endif\n                show_version();\n                /* We don't really have to cleanup here, but it's a convenient way to test\n                 * start-up and shut-down of the epan library without any UI-specific\n                 * cruft getting in the way. Makes the results of running\n                 * $ ./tools/valgrind-wireshark -n\n                 * much more useful. */\n                epan_cleanup();\n                extcap_cleanup();\n                exit_status = EXIT_SUCCESS;\n                goto clean_exit;\n            case 'O':        /* Only output these protocols */\n                /* already processed; just ignore it now */\n                break;\n            case 'V':        /* Verbose */\n                /* already processed; just ignore it now */\n                break;\n            case 'x':        /* Print packet data in hex (and ASCII) */\n                /* already processed; just ignore it now */\n                break;\n            case 'X':\n                /* already processed; just ignore it now */\n                break;\n            case 'Y':\n                dfilter = g_strdup(ws_optarg);\n                break;\n            case 'z':\n                /* We won't call the init function for the stat this soon\n                   as it would disallow MATE's fields (which are registered\n                   by the preferences set callback) from being used as\n                   part of a tap filter.  Instead, we just add the argument\n                   to a list of stat arguments. */\n                if (strcmp(\"help\", ws_optarg) == 0) {\n                    fprintf(stderr, \"tshark: The available statistics for the \\\"-z\\\" option are:\\n\");\n                    list_stat_cmd_args();\n                    exit_status = EXIT_SUCCESS;\n                    goto clean_exit;\n                }\n                if (!process_stat_cmd_arg(ws_optarg)) {\n                    cmdarg_err(\"Invalid -z argument \\\"%s\\\"; it must be one of:\", ws_optarg);\n                    list_stat_cmd_args();\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case 'd':        /* Decode as rule */\n            case 'K':        /* Kerberos keytab file */\n            case 'n':        /* No name resolution */\n            case 'N':        /* Select what types of addresses/port #s to resolve */\n            case 't':        /* Time stamp type */\n            case 'u':        /* Seconds type */\n            case LONGOPT_DISABLE_PROTOCOL: /* disable dissection of protocol */\n            case LONGOPT_ENABLE_HEURISTIC: /* enable heuristic dissection of protocol */\n            case LONGOPT_DISABLE_HEURISTIC: /* disable heuristic dissection of protocol */\n            case LONGOPT_ENABLE_PROTOCOL: /* enable dissection of protocol (that is disabled by default) */\n            case LONGOPT_ONLY_PROTOCOLS: /* enable dissection of only this comma separated list of protocols */\n            case LONGOPT_DISABLE_ALL_PROTOCOLS: /* enable dissection of protocol (that is disabled by default) */\n                if (!dissect_opts_handle_opt(opt, ws_optarg)) {\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case LONGOPT_EXPORT_OBJECTS:   /* --export-objects */\n                if (strcmp(\"help\", ws_optarg) == 0) {\n                    fprintf(stderr, \"tshark: The available export object types for the \\\"--export-objects\\\" option are:\\n\");\n                    eo_list_object_types();\n                    exit_status = EXIT_SUCCESS;\n                    goto clean_exit;\n                }\n                if (!eo_tap_opt_add(ws_optarg)) {\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case LONGOPT_EXPORT_TLS_SESSION_KEYS:   /* --export-tls-session-keys */\n                tls_session_keys_file = ws_optarg;\n                break;\n            case LONGOPT_COLOR: /* print in color where appropriate */\n                dissect_color = true;\n                /* This has no effect if we don't print packet info or filter\n                   (we can filter on the coloring rules). Should we warn or\n                   error later if so, instead of silently ignoring it? */\n                break;\n            case LONGOPT_NO_DUPLICATE_KEYS:\n                no_duplicate_keys = true;\n                node_children_grouper = proto_node_group_children_by_json_key;\n                break;\n            case LONGOPT_ELASTIC_MAPPING_FILTER:\n                /*\n                 * XXX - A long option that exists to alter one other option\n                 * (-G elastic-mapping) and for no other reason seems verbose.\n                 * Deprecate in favor of -G elastic-mapping,<filter> ?\n                 */\n                elastic_mapping_filter = ws_optarg;\n                break;\n            case LONGOPT_CAPTURE_COMMENT:  /* capture comment */\n                if (capture_comments == NULL) {\n                    capture_comments = g_ptr_array_new_with_free_func(g_free);\n                }\n                g_ptr_array_add(capture_comments, g_strdup(ws_optarg));\n                break;\n            case LONGOPT_HEXDUMP:\n                print_hex = true;\n                print_packet_info = true;\n                if (strcmp(ws_optarg, \"all\") == 0)\n                    hexdump_source_option = HEXDUMP_SOURCE_MULTI;\n                else if (strcmp(ws_optarg, \"frames\") == 0)\n                    hexdump_source_option = HEXDUMP_SOURCE_PRIMARY;\n                else if (strcmp(ws_optarg, \"ascii\") == 0)\n                    hexdump_ascii_option = HEXDUMP_ASCII_INCLUDE;\n                else if (strcmp(ws_optarg, \"delimit\") == 0)\n                    hexdump_ascii_option = HEXDUMP_ASCII_DELIMIT;\n                else if (strcmp(ws_optarg, \"noascii\") == 0)\n                    hexdump_ascii_option = HEXDUMP_ASCII_EXCLUDE;\n                else if (strcmp(ws_optarg, \"time\") == 0)\n                    hexdump_timestamp_option = HEXDUMP_TIMESTAMP;\n                else if (strcmp(ws_optarg, \"notime\") == 0)\n                    hexdump_timestamp_option = HEXDUMP_TIMESTAMP_NONE;\n                else if (strcmp(\"help\", ws_optarg) == 0) {\n                    hexdump_option_help(stdout);\n                    exit_status = EXIT_SUCCESS;\n                    goto clean_exit;\n                } else {\n                    fprintf(stderr, \"tshark: \\\"%s\\\" is an invalid value for --hexdump <hexoption>\\n\", ws_optarg);\n                    fprintf(stderr, \"For valid <hexoption> values enter: tshark --hexdump help\\n\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case LONGOPT_SELECTED_FRAME:\n                /* Hidden option to mark a frame as \"selected\". Used for testing and debugging.\n                 * Only active in two-pass mode. */\n                if (!ws_strtou32(ws_optarg, NULL, &selected_frame_number)) {\n                    fprintf(stderr, \"tshark: \\\"%s\\\" is not a valid frame number\\n\", ws_optarg);\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                break;\n            case LONGOPT_PRINT_TIMERS:\n                opt_print_timers = true;\n                break;\n            case LONGOPT_GLOBAL_PROFILE:\n                /* already processed; just ignore it now */\n                break;\n            case LONGOPT_COMPRESS:        /* compress type */\n                compression_type = wtap_name_to_compression_type(ws_optarg);\n                if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n                    cmdarg_err(\"\\\"%s\\\" isn't a valid output compression mode\",\n                               ws_optarg);\n                    list_output_compression_types();\n                    goto clean_exit;\n                }\n                break;\n            default:\n            case '?':        /* Bad flag - print usage message */\n                switch(ws_optopt) {\n                    case 'F':\n                        list_capture_types();\n                        break;\n                    case LONGOPT_COMPRESS:\n                        list_output_compression_types();\n                        break;\n                    default:\n                        print_usage(stderr);\n                }\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n                break;\n        }\n    }\n\n    /* set the default output action to TEXT */\n    if (output_action == WRITE_NONE)\n        output_action = WRITE_TEXT;\n\n    /* set the default file type to pcapng */\n    if (out_file_type == WTAP_FILE_TYPE_SUBTYPE_UNKNOWN)\n        out_file_type = wtap_pcapng_file_type_subtype();\n\n    /*\n     * Print packet summary information is the default if neither -V or -x\n     * were specified. Note that this is new behavior, which allows for the\n     * possibility of printing only hex/ascii output without necessarily\n     * requiring that either the summary or details be printed too.\n     */\n    if (!print_summary && !print_details && !print_hex)\n        print_summary = true;\n\n    if (no_duplicate_keys && output_action != WRITE_JSON && output_action != WRITE_JSON_RAW) {\n        cmdarg_err(\"--no-duplicate-keys can only be used with \\\"-T json\\\" and \\\"-T jsonraw\\\"\");\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    /* If we specified output fields, but not the output field type... */\n    /* XXX: If we specfied both output fields with -e *and* protocol filters\n     * with -j/-J, only the former are used. Should we warn or abort?\n     * This also doesn't distinguish PDML from PSML, but shouldn't allow the\n     * latter.\n     */\n    if ((WRITE_FIELDS != output_action && WRITE_XML != output_action && WRITE_JSON != output_action && WRITE_EK != output_action) && 0 != output_fields_num_fields(output_fields)) {\n        cmdarg_err(\"Output fields were specified with \\\"-e\\\", \"\n                \"but \\\"-Tek, -Tfields, -Tjson or -Tpdml\\\" was not specified.\");\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    } else if (WRITE_FIELDS == output_action && 0 == output_fields_num_fields(output_fields)) {\n        cmdarg_err(\"\\\"-Tfields\\\" was specified, but no fields were \"\n                \"specified with \\\"-e\\\".\");\n\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (dissect_color) {\n        if (!color_filters_init(&err_msg, NULL)) {\n            fprintf(stderr, \"%s\\n\", err_msg);\n            g_free(err_msg);\n        }\n    }\n\n    /* If no capture filter or display filter has been specified, and there are\n       still command-line arguments, treat them as the tokens of a capture\n       filter (if no \"-r\" flag was specified) or a display filter (if a \"-r\"\n       flag was specified. */\n    if (ws_optind < argc) {\n        if (cf_name != NULL) {\n            if (dfilter != NULL) {\n                cmdarg_err(\"Display filters were specified both with \\\"-Y\\\" \"\n                        \"and with additional command-line arguments.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            dfilter = get_args_as_string(argc, argv, ws_optind);\n        } else {\n#ifdef HAVE_LIBPCAP\n            unsigned i;\n\n            if (global_capture_opts.default_options.cfilter) {\n                cmdarg_err(\"A default capture filter was specified both with \\\"-f\\\"\"\n                        \" and with additional command-line arguments.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            for (i = 0; i < global_capture_opts.ifaces->len; i++) {\n                interface_options *interface_opts;\n                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, i);\n                if (interface_opts->cfilter == NULL) {\n                    interface_opts->cfilter = get_args_as_string(argc, argv, ws_optind);\n                } else {\n                    cmdarg_err(\"A capture filter was specified both with \\\"-f\\\"\"\n                            \" and with additional command-line arguments.\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n            }\n            global_capture_opts.default_options.cfilter = get_args_as_string(argc, argv, ws_optind);\n#else\n            capture_option_specified = true;\n#endif\n        }\n    }\n\n    if (!output_file_name) {\n        /* We're not saving the capture to a file; if \"-q\" wasn't specified,\n           we should print packet information */\n        if (!quiet)\n            print_packet_info = true;\n    } else {\n        const char *save_file = output_file_name;\n        /* We're saving to a file; if we're writing to the standard output.\n           and we'll also be writing dissected packets to the standard\n           output, reject the request.  At best, we could redirect that\n           to the standard error; we *can't* write both to the standard\n           output and have either of them be useful. */\n        if (strcmp(save_file, \"-\") == 0 && print_packet_info) {\n            cmdarg_err(\"You can't write both raw packet data and dissected packets\"\n                    \" to the standard output.\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n        if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n            /* An explicitly specified compression type overrides filename\n             * magic. (Should we allow a way to specify \"no\" compression\n             * with, e.g. a \".gz\" extension?) */\n            const char *sfx = strrchr(save_file, '.');\n            if (sfx) {\n                compression_type = wtap_extension_to_compression_type(sfx + 1);\n            }\n        }\n    }\n\n    if (compression_type == WTAP_UNKNOWN_COMPRESSION) {\n        compression_type = WTAP_UNCOMPRESSED;\n    }\n\n    if (!wtap_can_write_compression_type(compression_type)) {\n        cmdarg_err(\"Output files can't be written as %s\",\n                wtap_compression_type_description(compression_type));\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (compression_type != WTAP_UNCOMPRESSED && !wtap_dump_can_compress(out_file_type)) {\n        cmdarg_err(\"The file format %s can't be written to output compressed format\",\n                wtap_file_type_subtype_name(out_file_type));\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (compression_type != WTAP_UNCOMPRESSED && is_capturing) {\n        cmdarg_err(\"Writing to compressed output is not supported for live captures\");\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n#ifndef HAVE_LIBPCAP\n    if (capture_option_specified)\n        cmdarg_err(\"This version of TShark was not built with support for capturing packets.\");\n#endif\n    if (arg_error) {\n        print_usage(stderr);\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    if (print_hex) {\n        if (output_action != WRITE_TEXT && output_action != WRITE_JSON && output_action != WRITE_JSON_RAW && output_action != WRITE_EK) {\n            cmdarg_err(\"Raw packet hex data can only be printed as text, PostScript, JSON, JSONRAW or EK JSON\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n    }\n\n    if (output_only != NULL) {\n        char *ps;\n\n        if (!print_details) {\n            cmdarg_err(\"-O requires -V\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n\n        output_only_tables = g_hash_table_new (g_str_hash, g_str_equal);\n        for (ps = strtok (output_only, \",\"); ps; ps = strtok (NULL, \",\")) {\n            const char *name = ps;\n            header_field_info *hfi = proto_registrar_get_byalias(name);\n            if (hfi) {\n                name = hfi->abbrev;\n            }\n            g_hash_table_insert(output_only_tables, (void *)name, (void *)name);\n        }\n    }\n\n    if (rfilter != NULL && !perform_two_pass_analysis) {\n        cmdarg_err(\"-R without -2 is deprecated. For single-pass filtering use -Y.\");\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n#ifdef HAVE_LIBPCAP\n    if (caps_queries) {\n        /* We're supposed to list the link-layer/timestamp types for an interface;\n           did the user also specify a capture file to be read? */\n        if (cf_name) {\n            /* Yes - that's bogus. */\n            cmdarg_err(\"You can't specify %s and a capture file to be read.\",\n                    caps_queries & CAPS_QUERY_LINK_TYPES ? \"-L\" : \"--list-time-stamp-types\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n        /* No - did they specify a ring buffer option? */\n        if (global_capture_opts.multi_files_on) {\n            cmdarg_err(\"Ring buffer requested, but a capture isn't being done.\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n    } else {\n        if (cf_name) {\n            /*\n             * \"-r\" was specified, so we're reading a capture file.\n             * Capture options don't apply here.\n             */\n\n            /* We don't support capture filters when reading from a capture file\n               (the BPF compiler doesn't support all link-layer types that we\n               support in capture files we read). */\n            if (global_capture_opts.default_options.cfilter) {\n                cmdarg_err(\"Only read filters, not capture filters, \"\n                        \"can be specified when reading a capture file.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            if (global_capture_opts.multi_files_on) {\n                cmdarg_err(\"Multiple capture files requested, but \"\n                        \"a capture isn't being done.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            if (global_capture_opts.has_file_duration) {\n                cmdarg_err(\"Switching capture files after a time period was specified, but \"\n                        \"a capture isn't being done.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            if (global_capture_opts.has_file_interval) {\n                cmdarg_err(\"Switching capture files after a time interval was specified, but \"\n                        \"a capture isn't being done.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            if (global_capture_opts.has_ring_num_files) {\n                cmdarg_err(\"A ring buffer of capture files was specified, but \"\n                        \"a capture isn't being done.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            if (global_capture_opts.has_autostop_files) {\n                cmdarg_err(\"A maximum number of capture files was specified, but \"\n                        \"a capture isn't being done.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n\n            /* Note: TShark now allows the restriction of a _read_ file by packet count\n             * and byte count as well as a write file. Other autostop options remain valid\n             * only for a write file.\n             */\n            if (global_capture_opts.has_autostop_duration) {\n                cmdarg_err(\"A maximum capture time was specified, but \"\n                        \"a capture isn't being done.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n        } else {\n            /*\n             * \"-r\" wasn't specified, so we're doing a live capture.\n             */\n            bool                 use_pcapng = true;\n\n            if (perform_two_pass_analysis) {\n                /* Two-pass analysis doesn't work with live capture since it requires us\n                 * to buffer packets until we've read all of them, but a live capture\n                 * has no useful/meaningful definition of \"all\" */\n                cmdarg_err(\"Live captures do not support two-pass analysis.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n\n            if (global_capture_opts.saving_to_file) {\n                /* They specified a \"-w\" flag, so we'll be saving to a capture file. */\n\n                /* When capturing, we only support writing pcap or pcapng format. */\n                if (out_file_type == wtap_pcapng_file_type_subtype()) {\n                    use_pcapng = true;\n                } else if (out_file_type == wtap_pcap_file_type_subtype()) {\n                    use_pcapng = false;\n                } else if (out_file_type == wtap_pcap_nsec_file_type_subtype()) {\n                    /* XXX - We request nanosecond time resolution regardless.\n                     * In the future wiretap might treat the two pcap subtypes\n                     * the same.\n                     */\n                    use_pcapng = false;\n                } else {\n                    cmdarg_err(\"Live captures can only be saved in pcap or pcapng format.\");\n                    capture_opts_list_file_types();\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                if (capture_comments != NULL && !use_pcapng) {\n                    cmdarg_err(\"Capture comments can only be written to a pcapng file.\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                if (global_capture_opts.multi_files_on) {\n                    /* Multiple-file mode doesn't work under certain conditions:\n                       a) it doesn't work if you're writing to the standard output;\n                       b) it doesn't work if you're writing to a pipe;\n                       */\n                    if (strcmp(global_capture_opts.save_file, \"-\") == 0) {\n                        cmdarg_err(\"Multiple capture files requested, but \"\n                                \"the capture is being written to the standard output.\");\n                        exit_status = WS_EXIT_INVALID_OPTION;\n                        goto clean_exit;\n                    }\n                    if (global_capture_opts.output_to_pipe) {\n                        cmdarg_err(\"Multiple capture files requested, but \"\n                                \"the capture file is a pipe.\");\n                        exit_status = WS_EXIT_INVALID_OPTION;\n                        goto clean_exit;\n                    }\n                    if (!global_capture_opts.has_autostop_filesize &&\n                            !global_capture_opts.has_file_duration &&\n                            !global_capture_opts.has_file_interval &&\n                            !global_capture_opts.has_file_packets) {\n                        cmdarg_err(\"Multiple capture files requested, but \"\n                                \"no maximum capture file size, duration, interval or packets were specified.\");\n                        exit_status = WS_EXIT_INVALID_OPTION;\n                        goto clean_exit;\n                    }\n                }\n                /* Currently, we don't support read or display filters when capturing\n                   and saving the packets. */\n                if (rfilter != NULL) {\n                    cmdarg_err(\"Read filters aren't supported when capturing and saving the captured packets.\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                if (dfilter != NULL) {\n                    cmdarg_err(\"Display filters aren't supported when capturing and saving the captured packets.\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                global_capture_opts.use_pcapng = use_pcapng;\n            } else {\n                /* They didn't specify a \"-w\" flag, so we won't be saving to a\n                   capture file.  Check for options that only make sense if\n                   we're saving to a file. */\n                if (global_capture_opts.has_autostop_filesize) {\n                    cmdarg_err(\"Maximum capture file size specified, but \"\n                            \"capture isn't being saved to a file.\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                if (global_capture_opts.multi_files_on) {\n                    cmdarg_err(\"Multiple capture files requested, but \"\n                            \"the capture isn't being saved to a file.\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n                if (capture_comments != NULL) {\n                    cmdarg_err(\"Capture comments were specified, but \"\n                            \"the capture isn't being saved to a file.\");\n                    exit_status = WS_EXIT_INVALID_OPTION;\n                    goto clean_exit;\n                }\n            }\n        }\n    }\n#endif\n\n    /*\n     * If capture comments were specified, -w also has to have been specified.\n     */\n    if (capture_comments != NULL) {\n        if (output_file_name) {\n            /* They specified a \"-w\" flag, so we'll be saving to a capture file.\n             * This is fine if they're writing in a format that supports\n             * section block comments.\n             */\n            if (wtap_file_type_subtype_supports_option(out_file_type,\n                        WTAP_BLOCK_SECTION,\n                        OPT_COMMENT) == OPTION_NOT_SUPPORTED) {\n                GArray *writable_type_subtypes;\n\n                cmdarg_err(\"Capture comments can only be written to files of the following types:\");\n                writable_type_subtypes = wtap_get_writable_file_types_subtypes(FT_SORT_BY_NAME);\n                for (unsigned i = 0; i < writable_type_subtypes->len; i++) {\n                    int ft = g_array_index(writable_type_subtypes, int, i);\n\n                    if (wtap_file_type_subtype_supports_option(ft, WTAP_BLOCK_SECTION,\n                                OPT_COMMENT) != OPTION_NOT_SUPPORTED)\n                        cmdarg_err_cont(\"    %s - %s\", wtap_file_type_subtype_name(ft),\n                                wtap_file_type_subtype_description(ft));\n                }\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n        }\n        else {\n            cmdarg_err(\"Capture comments were specified, but you aren't writing a capture file.\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n    }\n\n    err_msg = ws_init_sockets();\n    if (err_msg != NULL)\n    {\n        cmdarg_err(\"%s\", err_msg);\n        g_free(err_msg);\n        cmdarg_err_cont(\"%s\", please_report_bug());\n        exit_status = WS_EXIT_INIT_FAILED;\n        goto clean_exit;\n    }\n\n    /* Notify all registered modules that have had any of their preferences\n       changed either from one of the preferences file or from the command\n       line that their preferences have changed. */\n    prefs_apply_all();\n\n    /* We can also enable specified taps for export object */\n    start_exportobjects();\n\n    /* At this point MATE will have registered its field array so we can\n       check if the fields specified by the user are all good.\n       */\n    {\n        GSList* it = NULL;\n        GSList *invalid_fields = output_fields_valid(output_fields);\n        if (invalid_fields != NULL) {\n\n            cmdarg_err(\"Some fields aren't valid:\");\n            for (it=invalid_fields; it != NULL; it = g_slist_next(it)) {\n                cmdarg_err_cont(\"\\t%s\", (char *)it->data);\n            }\n            g_slist_free(invalid_fields);\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n    }\n\n    if (ex_opt_count(\"read_format\") > 0) {\n        const char* name = ex_opt_get_next(\"read_format\");\n        in_file_type = open_info_name_to_type(name);\n        if (in_file_type == WTAP_TYPE_AUTO) {\n            cmdarg_err(\"\\\"%s\\\" isn't a valid read file format type\", name? name : \"\");\n            list_read_capture_types();\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n    }\n\n    if (global_dissect_options.time_format != TS_NOT_SET)\n        timestamp_set_type(global_dissect_options.time_format);\n    if (global_dissect_options.time_precision != TS_PREC_NOT_SET)\n        timestamp_set_precision(global_dissect_options.time_precision);\n\n    /*\n     * Enabled and disabled protocols and heuristic dissectors as per\n     * command-line options.\n     */\n    if (!setup_enabled_and_disabled_protocols()) {\n        exit_status = WS_EXIT_INVALID_OPTION;\n        goto clean_exit;\n    }\n\n    /* Build the column format array */\n    build_column_format_array(&cfile.cinfo, prefs_p->num_cols, true);\n\n    /* Everything is setup, dump glossaries now if that's what we're doing.\n     * We want to do this after protocols and heuristic dissectors are\n     * enabled and disabled. Doing it after building the column format\n     * array might make it easier to add a report that describes the\n     * current list of columns and how to add a new one (#17332).\n     */\n    if (glossary != NULL) {\n        exit_status = dump_glossary(glossary, elastic_mapping_filter);\n        goto clean_exit;\n    }\n\n#ifdef HAVE_LIBPCAP\n    capture_opts_trim_snaplen(&global_capture_opts, MIN_PACKET_SIZE);\n    capture_opts_trim_ring_num_files(&global_capture_opts);\n#endif\n\n    if (rfilter != NULL) {\n        ws_debug(\"Compiling read filter: '%s'\", rfilter);\n        if (!compile_dfilter(rfilter, &rfcode)) {\n            epan_cleanup();\n            extcap_cleanup();\n\n#ifdef HAVE_LIBPCAP\n            warn_about_capture_filter(rfilter);\n#endif\n\n            exit_status = WS_EXIT_INVALID_INTERFACE;\n            goto clean_exit;\n        }\n    }\n    cfile.rfcode = rfcode;\n\n    if (dfilter != NULL) {\n        ws_debug(\"Compiling display filter: '%s'\", dfilter);\n        if (!compile_dfilter(dfilter, &dfcode)) {\n            epan_cleanup();\n            extcap_cleanup();\n\n#ifdef HAVE_LIBPCAP\n            warn_about_capture_filter(dfilter);\n#endif\n\n            exit_status = WS_EXIT_INVALID_FILTER;\n            goto clean_exit;\n        }\n    }\n    cfile.dfcode = dfcode;\n\n    if (print_packet_info) {\n        /* If we're printing as text or PostScript, we have\n           to create a print stream. */\n        if (output_action == WRITE_TEXT) {\n            switch (print_format) {\n\n                case PR_FMT_TEXT:\n                    print_stream = print_stream_text_stdio_new(stdout);\n                    break;\n\n                case PR_FMT_PS:\n                    print_stream = print_stream_ps_stdio_new(stdout);\n                    break;\n\n                default:\n                    ws_assert_not_reached();\n            }\n        }\n    }\n\n    /* PDU export requested. Take the ownership of the '-w' file, apply tap\n     * filters and start tapping. */\n    if (pdu_export_arg) {\n        const char *exp_pdu_tap_name = pdu_export_arg;\n        const char *exp_pdu_filter = dfilter; /* may be NULL to disable filter */\n        char       *exp_pdu_error;\n        int         exp_fd;\n        char       *comment;\n\n        if (!cf_name) {\n            cmdarg_err(\"PDUs export requires a capture file (specify with -r).\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n        /* Take ownership of the '-w' output file. */\n        exp_pdu_filename = output_file_name;\n        output_file_name = NULL;\n#ifdef HAVE_LIBPCAP\n        global_capture_opts.save_file = NULL;\n#endif\n        if (exp_pdu_filename == NULL) {\n            cmdarg_err(\"PDUs export requires an output file (-w).\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n\n        exp_pdu_error = exp_pdu_pre_open(exp_pdu_tap_name, exp_pdu_filter,\n                &exp_pdu_tap_data);\n        if (exp_pdu_error) {\n            cmdarg_err(\"Cannot register tap: %s\", exp_pdu_error);\n            g_free(exp_pdu_error);\n            list_export_pdu_taps();\n            exit_status = INVALID_TAP;\n            goto clean_exit;\n        }\n\n        if (strcmp(exp_pdu_filename, \"-\") == 0) {\n            /* Write to the standard output. */\n            exp_fd = 1;\n        } else {\n            exp_fd = ws_open(exp_pdu_filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0644);\n            if (exp_fd == -1) {\n                cmdarg_err(\"%s: %s\", exp_pdu_filename, file_open_error_message(errno, true));\n                exit_status = WS_EXIT_INVALID_FILE;\n                goto clean_exit;\n            }\n        }\n\n        /* Activate the export PDU tap */\n        /* Write to our output file with this comment (if the type supports it,\n         * otherwise exp_pdu_open() will ignore the comment) */\n        comment = ws_strdup_printf(\"Dump of PDUs from %s\", cf_name);\n        exp_pdu_status = exp_pdu_open(&exp_pdu_tap_data, exp_pdu_filename,\n                out_file_type, exp_fd, comment,\n                &err, &err_info);\n        g_free(comment);\n        if (!exp_pdu_status) {\n            cfile_dump_open_failure_message(exp_pdu_filename, err, err_info,\n                    out_file_type);\n            exit_status = INVALID_EXPORT;\n            goto clean_exit;\n        }\n    }\n\n    if (cf_name) {\n        ws_debug(\"tshark: Opening capture file: %s\", cf_name);\n        /*\n         * We're reading a capture file.\n         */\n        if (cf_open(&cfile, cf_name, in_file_type, false, &err) != CF_OK) {\n            epan_cleanup();\n            extcap_cleanup();\n            exit_status = WS_EXIT_INVALID_FILE;\n            goto clean_exit;\n        }\n\n        /* Start statistics taps; we do so after successfully opening the\n           capture file, so we know we have something to compute stats\n           on, and after registering all dissectors, so that MATE will\n           have registered its field array so we can have a tap filter\n           with one of MATE's late-registered fields as part of the\n           filter. */\n        start_requested_stats();\n\n        /* Do we need to do dissection of packets?  That depends on, among\n           other things, what taps are listening, so determine that after\n           starting the statistics taps. */\n        do_dissection = must_do_dissection(rfcode, dfcode, pdu_export_arg);\n        ws_debug(\"tshark: do_dissection = %s\", do_dissection ? \"TRUE\" : \"FALSE\");\n\n        /* Process the packets in the file */\n        ws_debug(\"tshark: invoking process_cap_file() to process the packets\");\n        TRY {\n            status = process_cap_file(&cfile, output_file_name, out_file_type, out_file_name_res,\n#ifdef HAVE_LIBPCAP\n                    global_capture_opts.has_autostop_packets ? global_capture_opts.autostop_packets : 0,\n                    global_capture_opts.has_autostop_filesize ? global_capture_opts.autostop_filesize : 0,\n                    global_capture_opts.has_autostop_written_packets ? global_capture_opts.autostop_written_packets : 0,\n                    compression_type);\n#else\n            max_packet_count,\n                0,\n                0,\n                WTAP_UNCOMPRESSED);\n#endif\n        }\n        CATCH(OutOfMemoryError) {\n            fprintf(stderr,\n                    \"Out Of Memory.\\n\"\n                    \"\\n\"\n                    \"Sorry, but TShark has to terminate now.\\n\"\n                    \"\\n\"\n                    \"More information and workarounds can be found at\\n\"\n                    WS_WIKI_URL(\"KnownBugs/OutOfMemory\") \"\\n\");\n            status = PROCESS_FILE_ERROR;\n        }\n        ENDTRY;\n\n        switch (status) {\n\n            case PROCESS_FILE_SUCCEEDED:\n                /* Everything worked OK; draw the taps. */\n                draw_taps = true;\n                break;\n\n            case PROCESS_FILE_NO_FILE_PROCESSED:\n                /* We never got to try to read the file, so there are no tap\n                   results to dump.  Exit with an error status. */\n                exit_status = 2;\n                break;\n\n            case PROCESS_FILE_ERROR:\n                /* We still dump out the results of taps, etc., as we might have\n                   read some packets; however, we exit with an error status. */\n                draw_taps = true;\n                exit_status = 2;\n                break;\n\n            case PROCESS_FILE_INTERRUPTED:\n                /* The user interrupted the read process; Don't dump out the\n                   result of taps, etc., and exit with an error status. */\n                exit_status = 2;\n                break;\n        }\n\n        if (pdu_export_arg) {\n            if (!exp_pdu_close(&exp_pdu_tap_data, &err, &err_info)) {\n                cfile_close_failure_message(exp_pdu_filename, err, err_info);\n                exit_status = 2;\n            }\n            g_free(pdu_export_arg);\n            g_free(exp_pdu_filename);\n        }\n    } else {\n        ws_debug(\"tshark: no capture file specified\");\n        /* No capture file specified, so we're supposed to do a live capture\n           or get a list of link-layer types for a live capture device;\n           do we have support for live captures? */\n#ifdef HAVE_LIBPCAP\n#ifdef _WIN32\n        /* Warn the user if npf.sys isn't loaded. */\n        if (!npf_sys_is_running()) {\n            fprintf(stderr, \"The NPF driver isn't running.  You may have trouble \"\n                    \"capturing or\\nlisting interfaces.\\n\");\n        }\n#endif /* _WIN32 */\n\n        /* if no interface was specified, pick a default */\n        exit_status = capture_opts_default_iface_if_necessary(&global_capture_opts,\n                ((prefs_p->capture_device) && (*prefs_p->capture_device != '\\0')) ? get_if_name(prefs_p->capture_device) : NULL);\n        if (exit_status != 0) {\n            goto clean_exit;\n        }\n\n        /*\n         * If requested, list the link layer types and/or time stamp types\n         * and exit.\n         */\n        if (caps_queries) {\n            unsigned i;\n\n            /* Get the list of link-layer types for the capture devices. */\n            exit_status = EXIT_SUCCESS;\n            GList *if_cap_queries = NULL;\n            if_cap_query_t *if_cap_query;\n            GHashTable *capability_hash;\n            for (i = 0; i < global_capture_opts.ifaces->len; i++) {\n                interface_options *interface_opts;\n                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, i);\n                if_cap_query = g_new(if_cap_query_t, 1);\n                if_cap_query->name = interface_opts->name;\n                if_cap_query->monitor_mode = interface_opts->monitor_mode;\n                if_cap_query->auth_username = NULL;\n                if_cap_query->auth_password = NULL;\n#ifdef HAVE_PCAP_REMOTE\n                if (interface_opts->auth_type == CAPTURE_AUTH_PWD) {\n                    if_cap_query->auth_username = interface_opts->auth_username;\n                    if_cap_query->auth_password = interface_opts->auth_password;\n                }\n#endif\n                if_cap_queries = g_list_prepend(if_cap_queries, if_cap_query);\n            }\n            if_cap_queries = g_list_reverse(if_cap_queries);\n            capability_hash = capture_get_if_list_capabilities(if_cap_queries, &err_str, &err_str_secondary, NULL);\n            g_list_free_full(if_cap_queries, g_free);\n            for (i = 0; i < global_capture_opts.ifaces->len; i++) {\n                interface_options *interface_opts;\n                interface_opts = &g_array_index(global_capture_opts.ifaces, interface_options, i);\n                if_capabilities_t *caps;\n                caps = g_hash_table_lookup(capability_hash, interface_opts->name);\n                if (caps == NULL) {\n                    cmdarg_err(\"%s%s%s\", err_str, err_str_secondary ? \"\\n\" : \"\", err_str_secondary ? err_str_secondary : \"\");\n                    g_free(err_str);\n                    g_free(err_str_secondary);\n                    exit_status = WS_EXIT_INVALID_CAPABILITY;\n                    break;\n                }\n                exit_status = capture_opts_print_if_capabilities(caps, interface_opts,\n                        caps_queries);\n                if (exit_status != EXIT_SUCCESS) {\n                    break;\n                }\n            }\n            g_hash_table_destroy(capability_hash);\n            goto clean_exit;\n        }\n\n        /*\n         * If the standard error isn't a terminal, don't print packet counts,\n         * as they won't show up on the user's terminal and they'll get in\n         * the way of error messages in the file (to which we assume the\n         * standard error was redirected; if it's redirected to the null\n         * device, there's no point in printing packet counts anyway).\n         *\n         * Otherwise, if we're printing packet information and the standard\n         * output is a terminal (which we assume means the standard output and\n         * error are going to the same terminal), don't print packet counts,\n         * as they'll get in the way of the packet information.\n         *\n         * Otherwise, if the user specified -q, don't print packet counts.\n         *\n         * Otherwise, print packet counts.\n         *\n         * XXX - what if the user wants to do a live capture, doesn't want\n         * to save it to a file, doesn't want information printed for each\n         * packet, does want some \"-z\" statistic, and wants packet counts\n         * so they know whether they're seeing any packets?  -q will\n         * suppress the information printed for each packet, but it'll\n         * also suppress the packet counts.\n         */\n        if (!ws_isatty(ws_fileno(stderr)))\n            print_packet_counts = false;\n        else if (print_packet_info && ws_isatty(ws_fileno(stdout)))\n            print_packet_counts = false;\n        else if (quiet)\n            print_packet_counts = false;\n        else\n            print_packet_counts = true;\n\n        ws_debug(\"tshark: performing live capture\");\n\n        /* Start statistics taps; we should only do so after the capture\n           started successfully, so we know we have something to compute\n           stats, but we currently don't check for that - see below.\n\n           We do so after registering all dissectors, so that MATE will\n           have registered its field array so we can have a tap filter\n           with one of MATE's late-registered fields as part of the\n           filter. */\n        start_requested_stats();\n\n        /* Do we need to do dissection of packets?  That depends on, among\n           other things, what taps are listening, so determine that after\n           starting the statistics taps. */\n        do_dissection = must_do_dissection(rfcode, dfcode, pdu_export_arg);\n        ws_debug(\"tshark: do_dissection = %s\", do_dissection ? \"TRUE\" : \"FALSE\");\n\n        /* We're doing live capture; if the capture child is writing to a pipe,\n           we can't do dissection, because that would mean two readers for\n           the pipe, tshark and whatever else. */\n        if (do_dissection && global_capture_opts.output_to_pipe) {\n            if (tap_listeners_require_dissection()) {\n                cmdarg_err(\"Taps aren't supported when capturing and saving to a pipe.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            if (print_packet_info) {\n                cmdarg_err(\"Printing dissected packets isn't supported when capturing and saving to a pipe.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            /* We already checked the next three reasons for supersets of\n               capturing and saving to a pipe, but this doesn't hurt. */\n            if (pdu_export_arg) {\n                cmdarg_err(\"PDUs export isn't supported when capturing and saving to a pipe.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            if (rfcode != NULL) {\n                cmdarg_err(\"Read filters aren't supported when capturing and saving to a pipe.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            if (dfcode != NULL) {\n                cmdarg_err(\"Display filters aren't supported when capturing and saving to a pipe.\");\n                exit_status = WS_EXIT_INVALID_OPTION;\n                goto clean_exit;\n            }\n            /* There's some other reason we're dissecting. */\n            cmdarg_err(\"Dissection isn't supported when capturing and saving to a pipe.\");\n            exit_status = WS_EXIT_INVALID_OPTION;\n            goto clean_exit;\n        }\n\n        /* Write a preamble if we're printing one. Do this after all checking\n         * for invalid options, so we don't print just a preamble and quit. */\n        if (print_packet_info) {\n            if (!write_preamble(&cfile)) {\n                show_print_file_io_error();\n                exit_status = WS_EXIT_INVALID_FILE;\n                goto clean_exit;\n            }\n        }\n\n        /*\n         * XXX - this returns false if an error occurred, but it also\n         * returns false if the capture stops because a time limit\n         * was reached (and possibly other limits), so we can't assume\n         * it means an error.\n         *\n         * The capture code is a bit twisty, so it doesn't appear to\n         * be an easy fix.  We just ignore the return value for now.\n         * Instead, pass on the exit status from the capture child.\n         */\n        capture();\n        exit_status = global_capture_session.fork_child_status;\n\n        if (print_packet_info) {\n            if (!write_finale()) {\n                show_print_file_io_error();\n            }\n        }\n\n        /*\n         * If we never got a capture file, don't draw the taps; we not only\n         * didn't capture any packets, we never even did any capturing.\n         */\n        if (cfile.filename != NULL)\n            draw_taps = true;\n#else\n        /* No - complain. */\n        cmdarg_err(\"This version of TShark was not built with support for capturing packets.\");\n        exit_status = INVALID_CAPTURE;\n        goto clean_exit;\n#endif\n    }\n\n    if (cfile.provider.frames != NULL) {\n        free_frame_data_sequence(cfile.provider.frames);\n        cfile.provider.frames = NULL;\n    }\n\n    if (draw_taps)\n        draw_tap_listeners(true);\n\n    if (tls_session_keys_file) {\n        size_t keylist_length;\n        char *keylist = ssl_export_sessions(&keylist_length);\n        write_file_binary_mode(tls_session_keys_file, keylist, keylist_length);\n        g_free(keylist);\n    }\n\n    if (opt_print_timers) {\n        if (cf_name == NULL) {\n            /* We're doind a live capture. That isn't currently supported\n             * with timers. */\n            ws_message(\"Ignoring option --print-timers because we are doing a live capture\");\n        }\n        else {\n            print_elapsed_json(cf_name, dfilter);\n        }\n    }\n\n    /* Memory cleanup */\n    reset_tap_listeners();\n    funnel_dump_all_text_windows();\n    epan_free(cfile.epan);\n    epan_cleanup();\n    extcap_cleanup();\n\n    output_fields_free(output_fields);\n    output_fields = NULL;\n\nclean_exit:\n    cf_close(&cfile);\n    g_free(cf_name);\n    destroy_print_stream(print_stream);\n    g_free(output_file_name);\n#ifdef HAVE_LIBPCAP\n    capture_opts_cleanup(&global_capture_opts);\n    if (cached_if_list) {\n        free_interface_list(cached_if_list);\n    }\n#endif\n    col_cleanup(&cfile.cinfo);\n    wtap_cleanup();\n    free_progdirs();\n    dfilter_free(dfcode);\n    g_free(dfilter);\n    return exit_status;\n}\n\nbool loop_running;\nuint32_t packet_count;\n\nstatic epan_t *\ntshark_epan_new(capture_file *cf)\n{\n    static const struct packet_provider_funcs funcs = {\n        cap_file_provider_get_frame_ts,\n        cap_file_provider_get_interface_name,\n        cap_file_provider_get_interface_description,\n        NULL,\n    };\n\n    return epan_new(&cf->provider, &funcs);\n}\n\n#ifdef HAVE_LIBPCAP\nstatic bool\ncapture(void)\n{\n    volatile bool ret = true;\n    GString          *str;\n    GMainContext     *ctx;\n#ifndef _WIN32\n    struct sigaction  action, oldaction;\n#endif\n\n    /* Create new dissection section. */\n    epan_free(cfile.epan);\n    cfile.epan = tshark_epan_new(&cfile);\n\n#ifdef _WIN32\n    /* Catch a CTRL+C event and, if we get it, clean up and exit. */\n    SetConsoleCtrlHandler(capture_cleanup, true);\n#else /* _WIN32 */\n    /* Catch SIGINT and SIGTERM and, if we get either of them,\n       clean up and exit.  If SIGHUP isn't being ignored, catch\n       it too and, if we get it, clean up and exit.\n\n       We restart any read that was in progress, so that it doesn't\n       disrupt reading from the sync pipe.  The signal handler tells\n       the capture child to finish; it will report that it finished,\n       or will exit abnormally, so  we'll stop reading from the sync\n       pipe, pick up the exit status, and quit. */\n    memset(&action, 0, sizeof(action));\n    action.sa_handler = capture_cleanup;\n    action.sa_flags = SA_RESTART;\n    sigemptyset(&action.sa_mask);\n    sigaction(SIGTERM, &action, NULL);\n    sigaction(SIGINT, &action, NULL);\n    sigaction(SIGHUP, NULL, &oldaction);\n    if (oldaction.sa_handler == SIG_DFL)\n        sigaction(SIGHUP, &action, NULL);\n\n#ifdef SIGINFO\n    /* Catch SIGINFO and, if we get it and we're capturing to a file in\n       quiet mode, report the number of packets we've captured.\n\n       Again, restart any read that was in progress, so that it doesn't\n       disrupt reading from the sync pipe. */\n    action.sa_handler = report_counts_siginfo;\n    action.sa_flags = SA_RESTART;\n    sigemptyset(&action.sa_mask);\n    sigaction(SIGINFO, &action, NULL);\n#endif /* SIGINFO */\n#endif /* _WIN32 */\n\n    global_capture_session.state = CAPTURE_PREPARING;\n\n    /* Let the user know which interfaces were chosen. */\n    str = get_iface_list_string(&global_capture_opts, IFLIST_QUOTE_IF_DESCRIPTION);\n    if (really_quiet == false)\n        fprintf(stderr, \"Capturing on %s\\n\", str->str);\n    fflush(stderr);\n    g_string_free(str, TRUE);\n\n    ret = sync_pipe_start(&global_capture_opts, capture_comments,\n            &global_capture_session, &global_info_data, NULL);\n\n    if (!ret)\n        return false;\n\n    /*\n     * Force synchronous resolution of IP addresses; we're doing only\n     * one pass, so we can't do it in the background and fix up past\n     * dissections.\n     */\n    set_resolution_synchrony(true);\n\n    /* the actual capture loop */\n    ctx = g_main_context_default();\n    loop_running = true;\n\n    TRY\n    {\n        while (loop_running)\n        {\n            g_main_context_iteration(ctx, true);\n        }\n    }\n    CATCH(OutOfMemoryError) {\n        fprintf(stderr,\n                \"Out Of Memory.\\n\"\n                \"\\n\"\n                \"Sorry, but TShark has to terminate now.\\n\"\n                \"\\n\"\n                \"More information and workarounds can be found at\\n\"\n                WS_WIKI_URL(\"KnownBugs/OutOfMemory\") \"\\n\");\n        abort();\n    }\n    ENDTRY;\n    return ret;\n}\n\n/* capture child detected an error */\nstatic void\ncapture_input_error(capture_session *cap_session _U_, char *error_msg, char *secondary_error_msg)\n{\n    /* The primary message might be an empty string, e.g. when the error was\n     * from extcap. (The extcap stderr is gathered when the session closes\n     * and printed in capture_input_closed below.) */\n    if (*error_msg != '\\0') {\n        cmdarg_err(\"%s\", error_msg);\n        if (secondary_error_msg != NULL && *secondary_error_msg != '\\0') {\n            /* We have both primary and secondary messages. */\n            cmdarg_err_cont(\"%s\", secondary_error_msg);\n        }\n    }\n}\n\n\n/* capture child detected an capture filter related error */\nstatic void\ncapture_input_cfilter_error(capture_session *cap_session, unsigned i, const char *error_message)\n{\n    capture_options *capture_opts = cap_session->capture_opts;\n    dfilter_t         *rfcode = NULL;\n    interface_options *interface_opts;\n\n    ws_assert(i < capture_opts->ifaces->len);\n    interface_opts = &g_array_index(capture_opts->ifaces, interface_options, i);\n\n    if (dfilter_compile(interface_opts->cfilter, &rfcode, NULL) && rfcode != NULL) {\n        cmdarg_err(\n                \"Invalid capture filter \\\"%s\\\" for interface '%s'.\\n\"\n                \"\\n\"\n                \"That string looks like a valid display filter; however, it isn't a valid\\n\"\n                \"capture filter (%s).\\n\"\n                \"\\n\"\n                \"Note that display filters and capture filters don't have the same syntax,\\n\"\n                \"so you can't use most display filter expressions as capture filters.\\n\"\n                \"\\n\"\n                \"See the User's Guide for a description of the capture filter syntax.\",\n                interface_opts->cfilter, interface_opts->descr, error_message);\n        dfilter_free(rfcode);\n    } else {\n        cmdarg_err(\n                \"Invalid capture filter \\\"%s\\\" for interface '%s'.\\n\"\n                \"\\n\"\n                \"That string isn't a valid capture filter (%s).\\n\"\n                \"See the User's Guide for a description of the capture filter syntax.\",\n                interface_opts->cfilter, interface_opts->descr, error_message);\n    }\n}\n\n\n/* capture child tells us we have a new (or the first) capture file */\nstatic bool\ncapture_input_new_file(capture_session *cap_session, char *new_file)\n{\n    capture_options *capture_opts = cap_session->capture_opts;\n    capture_file *cf = cap_session->cf;\n    bool is_tempfile;\n    int      err;\n\n    if (really_quiet == false) {\n        if (cap_session->state == CAPTURE_PREPARING) {\n            ws_info(\"Capture started.\");\n        }\n        ws_info(\"File: \\\"%s\\\"\", new_file);\n    }\n\n    ws_assert(cap_session->state == CAPTURE_PREPARING || cap_session->state == CAPTURE_RUNNING);\n\n    /* free the old filename */\n    if (capture_opts->save_file != NULL) {\n\n        /* we start a new capture file, close the old one (if we had one before) */\n        if (cf->state != FILE_CLOSED) {\n            cf_close(cf);\n        }\n\n        g_free(capture_opts->save_file);\n        is_tempfile = false;\n\n        epan_free(cf->epan);\n        cf->epan = tshark_epan_new(cf);\n    } else {\n        /* we didn't had a save_file before, must be a tempfile */\n        is_tempfile = true;\n    }\n\n    /* save the new filename */\n    capture_opts->save_file = g_strdup(new_file);\n\n    /* if we are in real-time mode, open the new file now */\n    if (do_dissection) {\n        /* this is probably unnecessary, but better safe than sorry */\n        cap_session->cf->open_type = WTAP_TYPE_AUTO;\n        /* Attempt to open the capture file and set up to read from it. */\n        switch(cf_open(cap_session->cf, capture_opts->save_file, WTAP_TYPE_AUTO, is_tempfile, &err)) {\n            case CF_OK:\n                break;\n            case CF_ERROR:\n                /* Don't unlink (delete) the save file - leave it around,\n                   for debugging purposes. */\n                g_free(capture_opts->save_file);\n                capture_opts->save_file = NULL;\n                return false;\n        }\n    } else if (quiet && is_tempfile) {\n        cf->state = FILE_READ_ABORTED;\n        cf->filename = g_strdup(new_file);\n        cf->is_tempfile = is_tempfile;\n    }\n\n    cap_session->state = CAPTURE_RUNNING;\n\n    return true;\n}\n\n\n/* capture child tells us we have new packets to read */\nstatic void\ncapture_input_new_packets(capture_session *cap_session, int to_read)\n{\n    bool          ret;\n    int           err;\n    char         *err_info;\n    int64_t       data_offset;\n    capture_file *cf = cap_session->cf;\n    bool          filtering_tap_listeners;\n    unsigned      tap_flags;\n\n#ifdef SIGINFO\n    /*\n     * Prevent a SIGINFO handler from writing to the standard error while\n     * we're doing so or writing to the standard output; instead, have it\n     * just set a flag telling us to print that information when we're done.\n     */\n    infodelay = true;\n#endif /* SIGINFO */\n\n    /* Do we have any tap listeners with filters? */\n    filtering_tap_listeners = have_filtering_tap_listeners();\n\n    /* Get the union of the flags for all tap listeners. */\n    tap_flags = union_of_tap_listener_flags();\n\n    if (do_dissection) {\n        bool create_proto_tree;\n        epan_dissect_t *edt;\n        wtap_rec rec;\n\n        /*\n         * Determine whether we need to create a protocol tree.\n         * We do if:\n         *\n         *    we're going to apply a read filter;\n         *\n         *    we're going to apply a display filter;\n         *\n         *    we're going to print the protocol tree;\n         *\n         *    one of the tap listeners is going to apply a filter;\n         *\n         *    one of the tap listeners requires a protocol tree;\n         *\n         *    a postdissector wants field values or protocols\n         *    on the first pass;\n         *\n         *    we have custom columns (which require field values, which\n         *    currently requires that we build a protocol tree).\n         */\n        create_proto_tree =\n            (cf->rfcode || cf->dfcode || print_details || filtering_tap_listeners ||\n             (tap_flags & TL_REQUIRES_PROTO_TREE) || postdissectors_want_hfids() ||\n             have_custom_cols(&cf->cinfo) || dissect_color);\n\n        /* The protocol tree will be \"visible\", i.e., nothing faked, only if\n           we're printing packet details, which is true if we're printing stuff\n           (\"print_packet_info\" is true) and we're in verbose mode\n           (\"packet_details\" is true). But if we specified certain fields with\n           \"-e\", we'll prime those directly later. */\n        bool visible = print_packet_info && print_details && output_fields_num_fields(output_fields) == 0;\n        edt = epan_dissect_new(cf->epan, create_proto_tree, visible);\n\n        wtap_rec_init(&rec, 1514);\n\n        while (to_read-- && cf->provider.wth) {\n            wtap_cleareof(cf->provider.wth);\n            ret = wtap_read(cf->provider.wth, &rec, &err, &err_info, &data_offset);\n            reset_epan_mem(cf, edt, create_proto_tree, print_packet_info && print_details);\n            if (ret == false) {\n                /* read from file failed, tell the capture child to stop */\n                sync_pipe_stop(cap_session);\n                wtap_close(cf->provider.wth);\n                cf->provider.wth = NULL;\n            } else {\n                ret = process_packet_single_pass(cf, edt, data_offset, &rec,\n                        tap_flags);\n            }\n            if (ret != false) {\n                /* packet successfully read and gone through the \"Read Filter\" */\n                packet_count++;\n            }\n            wtap_rec_reset(&rec);\n        }\n\n        epan_dissect_free(edt);\n\n        wtap_rec_cleanup(&rec);\n\n    } else {\n        /*\n         * Dumpcap's doing all the work; we're not doing any dissection.\n         * Count all the packets it wrote.\n         */\n        packet_count += to_read;\n    }\n\n    if (print_packet_counts) {\n        /* We're printing packet counts. */\n        if (packet_count != 0) {\n            fprintf(stderr, \"\\r%u \", packet_count);\n            /* stderr could be line buffered */\n            fflush(stderr);\n        }\n    }\n\n#ifdef SIGINFO\n    /*\n     * Allow SIGINFO handlers to write.\n     */\n    infodelay = false;\n\n    /*\n     * If a SIGINFO handler asked us to write out capture counts, do so.\n     */\n    if (infoprint)\n        report_counts();\n#endif /* SIGINFO */\n}\n\nstatic void\nreport_counts(void)\n{\n    if ((print_packet_counts == false) && (really_quiet == false)) {\n        /* Report the count only if we aren't printing a packet count\n           as packets arrive. */\n        fprintf(stderr, \"%u packet%s captured\\n\", packet_count,\n                plurality(packet_count, \"\", \"s\"));\n    }\n#ifdef SIGINFO\n    infoprint = false; /* we just reported it */\n#endif /* SIGINFO */\n}\n\n#ifdef SIGINFO\nstatic void\nreport_counts_siginfo(int signum _U_)\n{\n    int sav_errno = errno;\n    /* If we've been told to delay printing, just set a flag asking\n       that we print counts (if we're supposed to), otherwise print\n       the count of packets captured (if we're supposed to). */\n    if (infodelay)\n        infoprint = true;\n    else\n        report_counts();\n    errno = sav_errno;\n}\n#endif /* SIGINFO */\n\n\n/* capture child detected any packet drops? */\nstatic void\ncapture_input_drops(capture_session *cap_session _U_, uint32_t dropped, const char* interface_name)\n{\n    if (print_packet_counts) {\n        /* We're printing packet counts to stderr.\n           Send a newline so that we move to the line after the packet count. */\n        fprintf(stderr, \"\\n\");\n    }\n\n    if (dropped != 0) {\n        /* We're printing packet counts to stderr.\n           Send a newline so that we move to the line after the packet count. */\n        if (interface_name != NULL) {\n            fprintf(stderr, \"%u packet%s dropped from %s\\n\", dropped, plurality(dropped, \"\", \"s\"), interface_name);\n        } else {\n            fprintf(stderr, \"%u packet%s dropped\\n\", dropped, plurality(dropped, \"\", \"s\"));\n        }\n    }\n}\n\n\n/*\n * Capture child closed its side of the pipe, report any error and\n * do the required cleanup.\n */\nstatic void\ncapture_input_closed(capture_session *cap_session _U_, char *msg)\n{\n    if (msg != NULL && *msg != '\\0')\n        fprintf(stderr, \"tshark: %s\\n\", msg);\n\n    report_counts();\n\n    loop_running = false;\n}\n\n#ifdef _WIN32\nstatic BOOL WINAPI\ncapture_cleanup(DWORD ctrltype _U_)\n{\n    /* CTRL_C_EVENT is sort of like SIGINT, CTRL_BREAK_EVENT is unique to\n       Windows, CTRL_CLOSE_EVENT is sort of like SIGHUP, CTRL_LOGOFF_EVENT\n       is also sort of like SIGHUP, and CTRL_SHUTDOWN_EVENT is sort of\n       like SIGTERM at least when the machine's shutting down.\n\n       For now, we handle them all as indications that we should clean up\n       and quit, just as we handle SIGINT, SIGHUP, and SIGTERM in that\n       way on UNIX.\n\n       We must return true so that no other handler - such as one that would\n       terminate the process - gets called.\n\n       XXX - for some reason, typing ^C to TShark, if you run this in\n       a Cygwin console window in at least some versions of Cygwin,\n       causes TShark to terminate immediately; this routine gets\n       called, but the main loop doesn't get a chance to run and\n       exit cleanly, at least if this is compiled with Microsoft Visual\n       C++ (i.e., it's a property of the Cygwin console window or Bash;\n       it happens if TShark is not built with Cygwin - for all I know,\n       building it with Cygwin may make the problem go away). */\n\n    /* tell the capture child to stop */\n    sync_pipe_stop(&global_capture_session);\n\n    /* don't stop our own loop already here, otherwise status messages and\n     * cleanup wouldn't be done properly. The child will indicate the stop of\n     * everything by calling capture_input_closed() later */\n\n    return true;\n}\n#else\nstatic void\ncapture_cleanup(int signum _U_)\n{\n    /* tell the capture child to stop */\n    sync_pipe_stop(&global_capture_session);\n\n    /* don't stop our own loop already here, otherwise status messages and\n     * cleanup wouldn't be done properly. The child will indicate the stop of\n     * everything by calling capture_input_closed() later */\n}\n#endif /* _WIN32 */\n#endif /* HAVE_LIBPCAP */\n\nstatic bool\nprocess_packet_first_pass(capture_file *cf, epan_dissect_t *edt,\n        int64_t offset, wtap_rec *rec)\n{\n    frame_data     fdlocal;\n    uint32_t       framenum;\n    bool           passed;\n    int64_t        elapsed_start;\n\n    /* The frame number of this packet is one more than the count of\n       frames in this packet. */\n    framenum = cf->count + 1;\n\n    /* If we're not running a display filter and we're not printing any\n       packet information, we don't need to do a dissection. This means\n       that all packets can be marked as 'passed'. */\n    passed = true;\n\n    frame_data_init(&fdlocal, framenum, rec, offset, cum_bytes);\n\n    /* If we're going to run a read filter or a display filter, set up to\n       do a dissection and do so.  (This is the first pass of two passes\n       over the packets, so we will not be printing any information\n       from the dissection or running taps on the packet; if we're doing\n       any of that, we'll do it in the second pass.) */\n    if (edt) {\n        if (gbl_resolv_flags.network_name || gbl_resolv_flags.maxmind_geoip) {\n            /* If we're doing async lookups, send any that are queued and\n             * retrieve results.\n             *\n             * Ideally we'd force any lookups that need to happen on the second pass\n             * to be sent asynchronously on this pass so the results would be ready.\n             * That will happen if they're involved in a filter (because we prime the\n             * tree below), but not currently for taps, if we're printing packet\n             * summaries or details, etc.\n             *\n             * XXX - If we're running a read filter that depends on a resolved\n             * name, we should be doing synchronous lookups in that case. Also\n             * marking the dependent frames below might not work with a display\n             * filter that depends on a resolved name.\n             */\n            host_name_lookup_process();\n        }\n\n        column_info *cinfo = NULL;\n\n        /* If we're running a read filter, prime the epan_dissect_t with that\n           filter. */\n        if (cf->rfcode)\n            epan_dissect_prime_with_dfilter(edt, cf->rfcode);\n\n        if (cf->dfcode)\n            epan_dissect_prime_with_dfilter(edt, cf->dfcode);\n\n        /* This is the first pass, so prime the epan_dissect_t with the\n           hfids postdissectors want on the first pass. */\n        prime_epan_dissect_with_postdissector_wanted_hfids(edt);\n\n        frame_data_set_before_dissect(&fdlocal, &cf->elapsed_time,\n                &cf->provider.ref, cf->provider.prev_dis);\n        if (cf->provider.ref == &fdlocal) {\n            ref_frame = fdlocal;\n            cf->provider.ref = &ref_frame;\n        }\n\n        /* If we're applying a filter that needs the columns, construct them. */\n        if (dfilter_requires_columns(cf->rfcode) || dfilter_requires_columns(cf->dfcode)) {\n            cinfo = &cf->cinfo;\n        }\n\n        elapsed_start = g_get_monotonic_time();\n        epan_dissect_run(edt, cf->cd_t, rec, &fdlocal, cinfo);\n        tshark_elapsed.first_pass.dissect += g_get_monotonic_time() - elapsed_start;\n\n        /* Run the read filter if we have one. */\n        if (cf->rfcode) {\n            elapsed_start = g_get_monotonic_time();\n            passed = dfilter_apply_edt(cf->rfcode, edt);\n            tshark_elapsed.first_pass.dfilter_read += g_get_monotonic_time() - elapsed_start;\n        }\n    }\n\n    if (passed) {\n        frame_data_set_after_dissect(&fdlocal, &cum_bytes);\n        cf->provider.prev_cap = cf->provider.prev_dis = frame_data_sequence_add(cf->provider.frames, &fdlocal);\n\n        /* If we're not doing dissection then there won't be any dependent frames.\n         * More importantly, edt.pi.fd.dependent_frames won't be initialized because\n         * epan hasn't been initialized.\n         * if we *are* doing dissection, then mark the dependent frames, but only\n         * if a display filter was given and it matches this packet.\n         */\n        if (edt && cf->dfcode) {\n            elapsed_start = g_get_monotonic_time();\n            if (dfilter_apply_edt(cf->dfcode, edt) && edt->pi.fd->dependent_frames) {\n                g_hash_table_foreach(edt->pi.fd->dependent_frames, find_and_mark_frame_depended_upon, cf->provider.frames);\n            }\n\n            if (selected_frame_number != 0 && selected_frame_number == cf->count + 1) {\n                /* If we are doing dissection and we have a \"selected frame\"\n                 * then load that frame's references (if any) onto the compiled\n                 * display filter. Selected frame number is ordinal, count is cardinal. */\n                dfilter_load_field_references(cf->dfcode, edt->tree);\n            }\n            tshark_elapsed.first_pass.dfilter_filter += g_get_monotonic_time() - elapsed_start;\n        }\n\n        cf->count++;\n    } else {\n        /* if we don't add it to the frame_data_sequence, clean it up right now\n         * to avoid leaks */\n        frame_data_destroy(&fdlocal);\n    }\n\n    if (edt)\n        epan_dissect_reset(edt);\n\n    return passed;\n}\n\n/*\n * Set if reading a file was interrupted by a CTRL_ event on Windows or\n * a signal on UN*X.\n */\nstatic bool read_interrupted;\n\n#ifdef _WIN32\nstatic BOOL WINAPI\nread_cleanup(DWORD ctrltype _U_)\n{\n    /* CTRL_C_EVENT is sort of like SIGINT, CTRL_BREAK_EVENT is unique to\n       Windows, CTRL_CLOSE_EVENT is sort of like SIGHUP, CTRL_LOGOFF_EVENT\n       is also sort of like SIGHUP, and CTRL_SHUTDOWN_EVENT is sort of\n       like SIGTERM at least when the machine's shutting down.\n\n       For now, we handle them all as indications that we should clean up\n       and quit, just as we handle SIGINT, SIGHUP, and SIGTERM in that\n       way on UNIX.\n\n       We must return true so that no other handler - such as one that would\n       terminate the process - gets called.\n\n       XXX - for some reason, typing ^C to TShark, if you run this in\n       a Cygwin console window in at least some versions of Cygwin,\n       causes TShark to terminate immediately; this routine gets\n       called, but the main loop doesn't get a chance to run and\n       exit cleanly, at least if this is compiled with Microsoft Visual\n       C++ (i.e., it's a property of the Cygwin console window or Bash;\n       it happens if TShark is not built with Cygwin - for all I know,\n       building it with Cygwin may make the problem go away). */\n\n    /* tell the read to stop */\n    read_interrupted = true;\n\n    return true;\n}\n#else\nstatic void\nread_cleanup(int signum _U_)\n{\n    /* tell the read to stop */\n    read_interrupted = true;\n}\n#endif /* _WIN32 */\n\ntypedef enum {\n    PASS_SUCCEEDED,\n    PASS_READ_ERROR,\n    PASS_WRITE_ERROR,\n    PASS_INTERRUPTED\n} pass_status_t;\n\nstatic pass_status_t\nprocess_cap_file_first_pass(capture_file *cf, int max_packet_count,\n        int64_t max_byte_count, int *err, char **err_info)\n{\n    wtap_rec        rec;\n    epan_dissect_t *edt = NULL;\n    int64_t         data_offset;\n    pass_status_t   status = PASS_SUCCEEDED;\n    int             framenum = 0;\n\n    wtap_rec_init(&rec, 1514);\n\n    /* Allocate a frame_data_sequence for all the frames. */\n    cf->provider.frames = new_frame_data_sequence();\n\n    if (do_dissection) {\n        bool create_proto_tree;\n\n        /*\n         * Determine whether we need to create a protocol tree.\n         * We do if:\n         *\n         *    we're going to apply a read filter;\n         *\n         *    we're going to apply a display filter;\n         *\n         *    a postdissector wants field values or protocols\n         *    on the first pass.\n         */\n        create_proto_tree =\n            (cf->rfcode != NULL || cf->dfcode != NULL || postdissectors_want_hfids() || dissect_color);\n\n        ws_debug(\"tshark: create_proto_tree = %s\", create_proto_tree ? \"TRUE\" : \"FALSE\");\n\n        /* We're not going to display the protocol tree on this pass,\n           so it's not going to be \"visible\". */\n        edt = epan_dissect_new(cf->epan, create_proto_tree, false);\n    }\n\n    ws_debug(\"tshark: reading records for first pass\");\n    *err = 0;\n    while (wtap_read(cf->provider.wth, &rec, err, err_info, &data_offset)) {\n        if (read_interrupted) {\n            status = PASS_INTERRUPTED;\n            break;\n        }\n        framenum++;\n\n        if (process_packet_first_pass(cf, edt, data_offset, &rec)) {\n            /* Stop reading if we hit a stop condition */\n            if (max_packet_count > 0 && framenum >= max_packet_count) {\n                ws_debug(\"tshark: max_packet_count (%d) reached\", max_packet_count);\n                *err = 0; /* This is not an error */\n                break;\n            }\n            if (max_byte_count != 0 && data_offset >= max_byte_count) {\n                ws_debug(\"tshark: max_byte_count (%\" PRId64 \"/%\" PRId64 \") reached\",\n                        data_offset, max_byte_count);\n                *err = 0; /* This is not an error */\n                break;\n            }\n        }\n        wtap_rec_reset(&rec);\n    }\n    if (*err != 0)\n        status = PASS_READ_ERROR;\n\n    if (edt)\n        epan_dissect_free(edt);\n\n    /* Close the sequential I/O side, to free up memory it requires. */\n    wtap_sequential_close(cf->provider.wth);\n\n    /* Allow the protocol dissectors to free up memory that they\n     * don't need after the sequential run-through of the packets. */\n    postseq_cleanup_all_protocols();\n\n    cf->provider.prev_dis = NULL;\n    cf->provider.prev_cap = NULL;\n\n    return status;\n}\n\nstatic bool\nprocess_packet_second_pass(capture_file *cf, epan_dissect_t *edt,\n        frame_data *fdata, wtap_rec *rec, unsigned tap_flags _U_)\n{\n    column_info    *cinfo;\n    bool            passed;\n    wtap_block_t    block = NULL;\n    int64_t         elapsed_start;\n\n    /* If we're not running a display filter and we're not printing any\n       packet information, we don't need to do a dissection. This means\n       that all packets can be marked as 'passed'. */\n    passed = true;\n\n    /* If we're going to print packet information, or we're going to\n       run a read filter, or we're going to process taps, set up to\n       do a dissection and do so.  (This is the second pass of two\n       passes over the packets; that's the pass where we print\n       packet information or run taps.) */\n    if (edt) {\n        /* If we're running a display filter, prime the epan_dissect_t with that\n           filter. */\n        if (cf->dfcode)\n            epan_dissect_prime_with_dfilter(edt, cf->dfcode);\n\n        col_custom_prime_edt(edt, &cf->cinfo);\n\n        output_fields_prime_edt(edt, output_fields);\n        /* The PDML spec requires a 'geninfo' pseudo-protocol that needs\n         * information from our 'frame' protocol.\n         */\n        if (output_fields_num_fields(output_fields) != 0 &&\n                output_action == WRITE_XML) {\n            epan_dissect_prime_with_hfid(edt, proto_registrar_get_id_byname(\"frame\"));\n        }\n\n        /* We only need the columns if either\n           1) some tap or filter needs the columns\n           or\n           2) we're printing packet info but we're *not* verbose; in verbose\n           mode, we print the protocol tree, not the protocol summary.\n           or\n           3) there is a column mapped to an individual field\n           */\n        if ((tap_listeners_require_columns()) || (print_packet_info && print_summary) || output_fields_has_cols(output_fields) || dfilter_requires_columns(cf->dfcode))\n            cinfo = &cf->cinfo;\n        else\n            cinfo = NULL;\n\n        frame_data_set_before_dissect(fdata, &cf->elapsed_time,\n                &cf->provider.ref, cf->provider.prev_dis);\n        if (cf->provider.ref == fdata) {\n            ref_frame = *fdata;\n            cf->provider.ref = &ref_frame;\n        }\n\n        if (dissect_color) {\n            color_filters_prime_edt(edt);\n            fdata->need_colorize = 1;\n        }\n\n        /* epan_dissect_run (and epan_dissect_reset) unref the block.\n         * We need it later, e.g. in order to copy the options. */\n        block = wtap_block_ref(rec->block);\n        elapsed_start = g_get_monotonic_time();\n        epan_dissect_run_with_taps(edt, cf->cd_t, rec, fdata, cinfo);\n        tshark_elapsed.second_pass.dissect += g_get_monotonic_time() - elapsed_start;\n\n        /* Run the display filter if we have one. */\n        if (cf->dfcode) {\n            elapsed_start = g_get_monotonic_time();\n            passed = dfilter_apply_edt(cf->dfcode, edt);\n            tshark_elapsed.second_pass.dfilter_filter += g_get_monotonic_time() - elapsed_start;\n        }\n    }\n\n    if (passed) {\n        frame_data_set_after_dissect(fdata, &cum_bytes);\n        /* Process this packet. */\n        if (print_packet_info) {\n            /* We're printing packet information; print the information for\n               this packet. */\n            print_packet(cf, edt);\n\n            /* If we're doing \"line-buffering\", flush the standard output\n               after every packet.  See the comment above, for the \"-l\"\n               option, for an explanation of why we do that. */\n            if (line_buffered)\n                fflush(stdout);\n\n            if (ferror(stdout)) {\n                show_print_file_io_error();\n                exit(2);\n            }\n        }\n        cf->provider.prev_dis = fdata;\n    }\n    cf->provider.prev_cap = fdata;\n\n    if (edt) {\n        epan_dissect_reset(edt);\n        rec->block = block;\n    }\n    return passed || fdata->dependent_of_displayed;\n}\n\nstatic bool\nprocess_new_idbs(wtap *wth, wtap_dumper *pdh, int *err, char **err_info)\n{\n    wtap_block_t if_data;\n\n    while ((if_data = wtap_get_next_interface_description(wth)) != NULL) {\n        /*\n         * Only add interface blocks if the output file supports (meaning\n         * *requires*) them.\n         *\n         * That mean that the abstract interface provided by libwiretap\n         * involves WTAP_BLOCK_IF_ID_AND_INFO blocks.\n         */\n        if (pdh != NULL) {\n            if (wtap_file_type_subtype_supports_block(wtap_dump_file_type_subtype(pdh), WTAP_BLOCK_IF_ID_AND_INFO) != BLOCK_NOT_SUPPORTED) {\n                if (!wtap_dump_add_idb(pdh, if_data, err, err_info))\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n\nstatic pass_status_t\nprocess_cap_file_second_pass(capture_file *cf, wtap_dumper *pdh,\n        int *err, char **err_info,\n        volatile uint32_t *err_framenum,\n        int max_write_packet_count)\n{\n    wtap_rec        rec;\n    int             framenum = 0;\n    int             write_framenum = 0;\n    frame_data     *fdata;\n    bool            filtering_tap_listeners;\n    unsigned        tap_flags;\n    epan_dissect_t *edt = NULL;\n    pass_status_t   status = PASS_SUCCEEDED;\n\n    /*\n     * Process whatever IDBs we haven't seen yet.  This will be all\n     * the IDBs in the file, as we've finished reading it; they'll\n     * all be at the beginning of the output file.\n     */\n    if (!process_new_idbs(cf->provider.wth, pdh, err, err_info)) {\n        *err_framenum = 0;\n        return PASS_WRITE_ERROR;\n    }\n\n    wtap_rec_init(&rec, 1514);\n\n    /* Do we have any tap listeners with filters? */\n    filtering_tap_listeners = have_filtering_tap_listeners();\n\n    /* Get the union of the flags for all tap listeners. */\n    tap_flags = union_of_tap_listener_flags();\n\n    if (do_dissection) {\n        bool create_proto_tree;\n\n        /*\n         * Determine whether we need to create a protocol tree.\n         * We do if:\n         *\n         *    we're going to apply a display filter;\n         *\n         *    we're going to print the protocol tree;\n         *\n         *    one of the tap listeners requires a protocol tree;\n         *\n         *    we have custom columns (which require field values, which\n         *    currently requires that we build a protocol tree).\n         */\n        create_proto_tree =\n            (cf->dfcode || print_details || filtering_tap_listeners ||\n             (tap_flags & TL_REQUIRES_PROTO_TREE) || have_custom_cols(&cf->cinfo) || dissect_color);\n\n        ws_debug(\"tshark: create_proto_tree = %s\", create_proto_tree ? \"TRUE\" : \"FALSE\");\n\n        /* The protocol tree will be \"visible\", i.e., nothing faked, only if\n           we're printing packet details, which is true if we're printing stuff\n           (\"print_packet_info\" is true) and we're in verbose mode\n           (\"packet_details\" is true). But if we specified certain fields with\n           \"-e\", we'll prime those directly later. */\n        bool visible = print_packet_info && print_details && output_fields_num_fields(output_fields) == 0;\n        edt = epan_dissect_new(cf->epan, create_proto_tree, visible);\n    }\n\n    /*\n     * Force synchronous resolution of IP addresses; in this pass, we\n     * can't do it in the background and fix up past dissections.\n     */\n    set_resolution_synchrony(true);\n\n    for (framenum = 1; framenum <= (int)cf->count; framenum++) {\n        if (read_interrupted) {\n            status = PASS_INTERRUPTED;\n            break;\n        }\n        fdata = frame_data_sequence_find(cf->provider.frames, framenum);\n        if (!wtap_seek_read(cf->provider.wth, fdata->file_off, &rec, err,\n                    err_info)) {\n            /* Error reading from the input file. */\n            status = PASS_READ_ERROR;\n            break;\n        }\n        ws_debug(\"tshark: invoking process_packet_second_pass() for frame #%d\", framenum);\n        if (process_packet_second_pass(cf, edt, fdata, &rec, tap_flags)) {\n            /* Either there's no read filtering or this packet passed the\n               filter, so, if we're writing to a capture file, write\n               this packet out. */\n            write_framenum++;\n            if (pdh != NULL) {\n                ws_debug(\"tshark: writing packet #%d to outfile packet #%d\", framenum, write_framenum);\n                if (!wtap_dump(pdh, &rec, ws_buffer_start_ptr(&rec.data), err, err_info)) {\n                    /* Error writing to the output file. */\n                    ws_debug(\"tshark: error writing to a capture file (%d)\", *err);\n                    *err_framenum = framenum;\n                    status = PASS_WRITE_ERROR;\n                    break;\n                }\n                /* Stop reading if we hit a stop condition */\n                if (max_write_packet_count > 0 && write_framenum >= max_write_packet_count) {\n                    ws_debug(\"tshark: max_write_packet_count (%d) reached\", max_write_packet_count);\n                    *err = 0; /* This is not an error */\n                    break;\n                }\n            }\n        }\n        wtap_rec_reset(&rec);\n    }\n\n    if (edt)\n        epan_dissect_free(edt);\n\n    wtap_rec_cleanup(&rec);\n\n    return status;\n}\n\nstatic pass_status_t\nprocess_cap_file_single_pass(capture_file *cf, wtap_dumper *pdh,\n        int max_packet_count, int64_t max_byte_count,\n        int max_write_packet_count,\n        int *err, char **err_info,\n        volatile uint32_t *err_framenum)\n{\n    wtap_rec        rec;\n    bool create_proto_tree = false;\n    bool            filtering_tap_listeners;\n    unsigned        tap_flags;\n    int             framenum = 0;\n    int             write_framenum = 0;\n    epan_dissect_t *edt = NULL;\n    int64_t         data_offset;\n    pass_status_t   status = PASS_SUCCEEDED;\n\n    wtap_rec_init(&rec, 1514);\n\n    /* Do we have any tap listeners with filters? */\n    filtering_tap_listeners = have_filtering_tap_listeners();\n\n    /* Get the union of the flags for all tap listeners. */\n    tap_flags = union_of_tap_listener_flags();\n\n    if (do_dissection) {\n        /*\n         * Determine whether we need to create a protocol tree.\n         * We do if:\n         *\n         *    we're going to apply a read filter;\n         *\n         *    we're going to apply a display filter;\n         *\n         *    we're going to print the protocol tree;\n         *\n         *    one of the tap listeners is going to apply a filter;\n         *\n         *    one of the tap listeners requires a protocol tree;\n         *\n         *    a postdissector wants field values or protocols\n         *    on the first pass;\n         *\n         *    we have custom columns (which require field values, which\n         *    currently requires that we build a protocol tree).\n         */\n        create_proto_tree =\n            (cf->rfcode || cf->dfcode || print_details || filtering_tap_listeners ||\n             (tap_flags & TL_REQUIRES_PROTO_TREE) || postdissectors_want_hfids() ||\n             have_custom_cols(&cf->cinfo) || dissect_color);\n\n        ws_debug(\"tshark: create_proto_tree = %s\", create_proto_tree ? \"TRUE\" : \"FALSE\");\n\n        /* The protocol tree will be \"visible\", i.e., nothing faked, only if\n           we're printing packet details, which is true if we're printing stuff\n           (\"print_packet_info\" is true) and we're in verbose mode\n           (\"packet_details\" is true). But if we specified certain fields with\n           \"-e\", we'll prime those directly later. */\n        bool visible = print_packet_info && print_details && output_fields_num_fields(output_fields) == 0;\n        edt = epan_dissect_new(cf->epan, create_proto_tree, visible);\n    }\n\n    /*\n     * Force synchronous resolution of IP addresses; we're doing only\n     * one pass, so we can't do it in the background and fix up past\n     * dissections.\n     */\n    set_resolution_synchrony(true);\n\n    *err = 0;\n    while (wtap_read(cf->provider.wth, &rec, err, err_info, &data_offset)) {\n        if (read_interrupted) {\n            status = PASS_INTERRUPTED;\n            break;\n        }\n        framenum++;\n\n        /*\n         * Process whatever IDBs we haven't seen yet.\n         */\n        if (!process_new_idbs(cf->provider.wth, pdh, err, err_info)) {\n            *err_framenum = framenum;\n            status = PASS_WRITE_ERROR;\n            break;\n        }\n\n        ws_debug(\"tshark: processing packet #%d\", framenum);\n\n        reset_epan_mem(cf, edt, create_proto_tree, print_packet_info && print_details);\n\n        if (process_packet_single_pass(cf, edt, data_offset, &rec, tap_flags)) {\n            /* Either there's no read filtering or this packet passed the\n               filter, so, if we're writing to a capture file, write\n               this packet out. */\n            write_framenum++;\n            if (pdh != NULL) {\n                ws_debug(\"tshark: writing packet #%d to outfile as #%d\",\n                        framenum, write_framenum);\n                if (!wtap_dump(pdh, &rec, ws_buffer_start_ptr(&rec.data), err, err_info)) {\n                    /* Error writing to the output file. */\n                    ws_debug(\"tshark: error writing to a capture file (%d)\", *err);\n                    *err_framenum = framenum;\n                    status = PASS_WRITE_ERROR;\n                    break;\n                }\n            }\n        }\n        /* Stop reading if we hit a stop condition */\n        if (max_packet_count > 0 && framenum >= max_packet_count) {\n            ws_debug(\"tshark: max_packet_count (%d) reached\", max_packet_count);\n            *err = 0; /* This is not an error */\n            break;\n        }\n        if (max_write_packet_count > 0 && write_framenum >= max_write_packet_count) {\n            ws_debug(\"tshark: max_write_packet_count (%d) reached\", max_write_packet_count);\n            *err = 0; /* This is not an error */\n            break;\n        }\n        if (max_byte_count != 0 && data_offset >= max_byte_count) {\n            ws_debug(\"tshark: max_byte_count (%\" PRId64 \"/%\" PRId64 \") reached\",\n                    data_offset, max_byte_count);\n            *err = 0; /* This is not an error */\n            break;\n        }\n        wtap_rec_reset(&rec);\n    }\n    if (status == PASS_SUCCEEDED) {\n        if (*err != 0) {\n            /* Error reading from the input file. */\n            status = PASS_READ_ERROR;\n        } else {\n            /*\n             * Process whatever IDBs we haven't seen yet.\n             */\n            if (!process_new_idbs(cf->provider.wth, pdh, err, err_info)) {\n                *err_framenum = framenum;\n                status = PASS_WRITE_ERROR;\n            }\n        }\n    }\n\n    if (edt)\n        epan_dissect_free(edt);\n\n    wtap_rec_cleanup(&rec);\n\n    return status;\n}\n\nstatic process_file_status_t\nprocess_cap_file(capture_file *cf, char *save_file, int out_file_type,\n        bool out_file_name_res, int max_packet_count, int64_t max_byte_count,\n        int max_write_packet_count, wtap_compression_type compression_type)\n{\n    process_file_status_t status = PROCESS_FILE_SUCCEEDED;\n    wtap_dumper *pdh;\n#ifndef _WIN32\n    struct sigaction  action, oldaction;\n#endif\n    int          err = 0, err_pass1 = 0;\n    char        *err_info = NULL, *err_info_pass1 = NULL;\n    volatile uint32_t err_framenum;\n    wtap_dump_params params = WTAP_DUMP_PARAMS_INIT;\n    char        *shb_user_appl;\n    pass_status_t first_pass_status, second_pass_status;\n    int64_t elapsed_start;\n\n    if (save_file != NULL) {\n        /* Set up to write to the capture file. */\n        wtap_dump_params_init_no_idbs(&params, cf->provider.wth);\n\n        /* If we don't have an application name add TShark */\n        if (wtap_block_get_string_option_value(g_array_index(params.shb_hdrs, wtap_block_t, 0), OPT_SHB_USERAPPL, &shb_user_appl) != WTAP_OPTTYPE_SUCCESS) {\n            /* this is free'd by wtap_block_unref() later */\n            wtap_block_add_string_option_format(g_array_index(params.shb_hdrs, wtap_block_t, 0), OPT_SHB_USERAPPL, \"%s\", get_appname_and_version());\n        }\n        if (capture_comments != NULL) {\n            for (unsigned i = 0; i < capture_comments->len; i++) {\n                wtap_block_add_string_option_format(g_array_index(params.shb_hdrs, wtap_block_t, 0),\n                        OPT_COMMENT, \"%s\",\n                        (char *)g_ptr_array_index(capture_comments, i));\n            }\n        }\n\n        ws_debug(\"tshark: writing format type %d, to %s\", out_file_type, save_file);\n        if (strcmp(save_file, \"-\") == 0) {\n            /* Write to the standard output. */\n            pdh = wtap_dump_open_stdout(out_file_type, compression_type, &params,\n                    &err, &err_info);\n        } else {\n            pdh = wtap_dump_open(save_file, out_file_type, compression_type, &params,\n                    &err, &err_info);\n        }\n\n        g_free(params.idb_inf);\n        params.idb_inf = NULL;\n\n        if (pdh == NULL) {\n            /* We couldn't set up to write to the capture file. */\n            cfile_dump_open_failure_message(save_file, err, err_info,\n                    out_file_type);\n            status = PROCESS_FILE_NO_FILE_PROCESSED;\n            goto out;\n        }\n    } else {\n        /* Set up to print packet information. */\n        if (print_packet_info) {\n            if (!write_preamble(cf)) {\n                show_print_file_io_error();\n                status = PROCESS_FILE_NO_FILE_PROCESSED;\n                goto out;\n            }\n        }\n        pdh = NULL;\n    }\n\n#ifdef _WIN32\n    /* Catch a CTRL+C event and, if we get it, clean up and exit. */\n    SetConsoleCtrlHandler(read_cleanup, true);\n#else /* _WIN32 */\n    /* Catch SIGINT and SIGTERM and, if we get either of them,\n       clean up and exit.  If SIGHUP isn't being ignored, catch\n       it too and, if we get it, clean up and exit.\n\n       We restart any read that was in progress, so that it doesn't\n       disrupt reading from the sync pipe.  The signal handler tells\n       the capture child to finish; it will report that it finished,\n       or will exit abnormally, so  we'll stop reading from the sync\n       pipe, pick up the exit status, and quit. */\n    memset(&action, 0, sizeof(action));\n    action.sa_handler = read_cleanup;\n    action.sa_flags = SA_RESTART;\n    sigemptyset(&action.sa_mask);\n    sigaction(SIGTERM, &action, NULL);\n    sigaction(SIGINT, &action, NULL);\n    sigaction(SIGHUP, NULL, &oldaction);\n    if (oldaction.sa_handler == SIG_DFL)\n        sigaction(SIGHUP, &action, NULL);\n#endif /* _WIN32 */\n\n    if (perform_two_pass_analysis) {\n        ws_debug(\"tshark: perform_two_pass_analysis, do_dissection=%s\", do_dissection ? \"TRUE\" : \"FALSE\");\n\n        elapsed_start = g_get_monotonic_time();\n        first_pass_status = process_cap_file_first_pass(cf, max_packet_count,\n                max_byte_count,\n                &err_pass1,\n                &err_info_pass1);\n        tshark_elapsed.elapsed_first_pass = g_get_monotonic_time() - elapsed_start;\n\n        ws_debug(\"tshark: done with first pass\");\n\n        if (first_pass_status == PASS_INTERRUPTED) {\n            /* The first pass was interrupted; skip the second pass.\n               It won't be run, so it won't get an error. */\n            second_pass_status = PASS_SUCCEEDED;\n        } else {\n            /*\n             * If we got a read error on the first pass, we still do the second\n             * pass, so we can at least process the packets we read, and then\n             * report the first-pass error after the second pass (and before\n             * we report any second-pass errors), so all the errors show up\n             * at the end.\n             */\n            elapsed_start = g_get_monotonic_time();\n            second_pass_status = process_cap_file_second_pass(cf, pdh, &err, &err_info,\n                    &err_framenum,\n                    max_write_packet_count);\n            tshark_elapsed.elapsed_second_pass = g_get_monotonic_time() - elapsed_start;\n\n            ws_debug(\"tshark: done with second pass\");\n        }\n    }\n    else {\n        /* !perform_two_pass_analysis */\n        ws_debug(\"tshark: perform one pass analysis, do_dissection=%s\", do_dissection ? \"TRUE\" : \"FALSE\");\n\n        first_pass_status = PASS_SUCCEEDED; /* There is no first pass */\n\n        elapsed_start = g_get_monotonic_time();\n        second_pass_status = process_cap_file_single_pass(cf, pdh,\n                max_packet_count,\n                max_byte_count,\n                max_write_packet_count,\n                &err, &err_info,\n                &err_framenum);\n        tshark_elapsed.elapsed_first_pass = g_get_monotonic_time() - elapsed_start;\n\n        ws_debug(\"tshark: done with single pass\");\n    }\n\n    if (first_pass_status != PASS_SUCCEEDED ||\n            second_pass_status != PASS_SUCCEEDED) {\n        /*\n         * At least one of the passes didn't succeed; either it got a failure\n         * or it was interrupted.\n         */\n        if (first_pass_status != PASS_INTERRUPTED ||\n                second_pass_status != PASS_INTERRUPTED) {\n            /* At least one of the passes got an error. */\n            ws_debug(\"tshark: something failed along the line (%d)\", err);\n            /*\n             * If we're printing packet data, and the standard output and error\n             * are going to the same place, flush the standard output, so everything\n             * buffered up is written, and then print a newline to the standard\n             * error before printing the error message, to separate it from the\n             * packet data.  (Alas, that only works on UN*X; st_dev is meaningless,\n             * and the _fstat() documentation at Microsoft doesn't indicate whether\n             * st_ino is even supported.)\n             */\n#ifndef _WIN32\n            if (print_packet_info) {\n                ws_statb64 stat_stdout, stat_stderr;\n\n                if (ws_fstat64(1, &stat_stdout) == 0 && ws_fstat64(2, &stat_stderr) == 0) {\n                    if (stat_stdout.st_dev == stat_stderr.st_dev &&\n                            stat_stdout.st_ino == stat_stderr.st_ino) {\n                        fflush(stdout);\n                        fprintf(stderr, \"\\n\");\n                    }\n                }\n            }\n#endif\n        }\n        /* Report status of pass 1 of two-pass processing. */\n        switch (first_pass_status) {\n\n            case PASS_SUCCEEDED:\n                /* No problem. */\n                break;\n\n            case PASS_READ_ERROR:\n                /* Read error. */\n                cfile_read_failure_message(cf->filename, err_pass1, err_info_pass1);\n                status = PROCESS_FILE_ERROR;\n                break;\n\n            case PASS_WRITE_ERROR:\n                /* Won't happen on the first pass. */\n                break;\n\n            case PASS_INTERRUPTED:\n                /* Not an error, so nothing to report. */\n                status = PROCESS_FILE_INTERRUPTED;\n                break;\n        }\n\n        /* Report status of pass 2 of two-pass processing or the only pass\n           of one-pass processing. */\n        switch (second_pass_status) {\n\n            case PASS_SUCCEEDED:\n                /* No problem. */\n                break;\n\n            case PASS_READ_ERROR:\n                /* Read error. */\n                cfile_read_failure_message(cf->filename, err, err_info);\n                status = PROCESS_FILE_ERROR;\n                break;\n\n            case PASS_WRITE_ERROR:\n                /* Write error.\n                   XXX - framenum is not necessarily the frame number in\n                   the input file if there was a read filter. */\n                cfile_write_failure_message(cf->filename, save_file, err, err_info,\n                        err_framenum, out_file_type);\n                status = PROCESS_FILE_ERROR;\n                break;\n\n            case PASS_INTERRUPTED:\n                /* Not an error, so nothing to report. */\n                status = PROCESS_FILE_INTERRUPTED;\n                break;\n        }\n    }\n    if (save_file != NULL) {\n        if (second_pass_status != PASS_WRITE_ERROR) {\n            if (pdh && out_file_name_res) {\n                /* XXX: This doesn't work as expected. First, it should be\n                 * moved to between the first and second passes (if doing\n                 * two-pass mode), so that the new NRB appears before packets,\n                 * which is better for subsequent one-pass mode. It never works\n                 * well in one-pass mode.\n                 *\n                 * Second, it only writes hosts that we've done lookups for,\n                 * which means unless packet details are printed (or there's\n                 * a display filter that matches something that will do a host\n                 * lookup, e.g. -Y \"ip\") it doesn't actually have anything\n                 * in the list to save. Notably, that includes the case of\n                 * \"tshark [-2] -H hosts.txt -r <infile> -w <outfile>\",\n                 * which a user would certainly expect to dissect packets,\n                 * lookup hostnames, and add them to an NRB for later use.\n                 * A workaround is if \"-V > /dev/null\" is added, but who\n                 * expects that?\n                 *\n                 * A third issue is that name resolution blocks aren't\n                 * written for live captures.\n                 */\n                if (!wtap_dump_set_addrinfo_list(pdh, get_addrinfo_list())) {\n                    cmdarg_err(\"The file format \\\"%s\\\" doesn't support name resolution information.\",\n                            wtap_file_type_subtype_name(out_file_type));\n                }\n            }\n            /* Now close the capture file. */\n            if (!wtap_dump_close(pdh, NULL, &err, &err_info)) {\n                cfile_close_failure_message(save_file, err, err_info);\n                status = PROCESS_FILE_ERROR;\n            }\n        } else {\n            /* We got a write error; it was reported, so just close the dump file\n               without bothering to check for further errors. */\n            wtap_dump_close(pdh, NULL, &err, &err_info);\n            g_free(err_info);\n            status = PROCESS_FILE_ERROR;\n        }\n    } else {\n        if (print_packet_info) {\n            if (!write_finale()) {\n                show_print_file_io_error();\n                status = PROCESS_FILE_ERROR;\n            }\n        }\n    }\n\nout:\n    wtap_close(cf->provider.wth);\n    cf->provider.wth = NULL;\n\n    wtap_dump_params_cleanup(&params);\n\n    return status;\n}\n\nstatic bool\nprocess_packet_single_pass(capture_file *cf, epan_dissect_t *edt, int64_t offset,\n        wtap_rec *rec, unsigned tap_flags _U_)\n{\n    frame_data      fdata;\n    column_info    *cinfo;\n    bool            passed;\n    wtap_block_t    block = NULL;\n    int64_t         elapsed_start;\n\n    /* Count this packet. */\n    cf->count++;\n\n    /* If we're not running a display filter and we're not printing any\n       packet information, we don't need to do a dissection. This means\n       that all packets can be marked as 'passed'. */\n    passed = true;\n\n    frame_data_init(&fdata, cf->count, rec, offset, cum_bytes);\n\n    /* If we're going to print packet information, or we're going to\n       run a read filter, or we're going to process taps, set up to\n       do a dissection and do so.  (This is the one and only pass\n       over the packets, so, if we'll be printing packet information\n       or running taps, we'll be doing it here.) */\n    if (edt) {\n        /* If we're running a filter, prime the epan_dissect_t with that\n           filter. */\n        if (cf->dfcode)\n            epan_dissect_prime_with_dfilter(edt, cf->dfcode);\n\n        /* This is the first and only pass, so prime the epan_dissect_t\n           with the hfids postdissectors want on the first pass. */\n        prime_epan_dissect_with_postdissector_wanted_hfids(edt);\n\n        col_custom_prime_edt(edt, &cf->cinfo);\n\n        output_fields_prime_edt(edt, output_fields);\n        /* The PDML spec requires a 'geninfo' pseudo-protocol that needs\n         * information from our 'frame' protocol.\n         */\n        if (output_fields_num_fields(output_fields) != 0 &&\n                output_action == WRITE_XML) {\n            epan_dissect_prime_with_hfid(edt, proto_registrar_get_id_byname(\"frame\"));\n        }\n\n        /* We only need the columns if either\n           1) some tap or filter needs the columns\n           or\n           2) we're printing packet info but we're *not* verbose; in verbose\n           mode, we print the protocol tree, not the protocol summary.\n           or\n           3) there is a column mapped as an individual field */\n        if ((tap_listeners_require_columns()) || (print_packet_info && print_summary) || output_fields_has_cols(output_fields) || dfilter_requires_columns(cf->dfcode))\n            cinfo = &cf->cinfo;\n        else\n            cinfo = NULL;\n\n        frame_data_set_before_dissect(&fdata, &cf->elapsed_time,\n                &cf->provider.ref, cf->provider.prev_dis);\n        if (cf->provider.ref == &fdata) {\n            ref_frame = fdata;\n            cf->provider.ref = &ref_frame;\n        }\n\n        if (dissect_color) {\n            color_filters_prime_edt(edt);\n            fdata.need_colorize = 1;\n        }\n\n        /* epan_dissect_run (and epan_dissect_reset) unref the block.\n         * We need it later, e.g. in order to copy the options. */\n        block = wtap_block_ref(rec->block);\n        elapsed_start = g_get_monotonic_time();\n        epan_dissect_run_with_taps(edt, cf->cd_t, rec, &fdata, cinfo);\n        tshark_elapsed.first_pass.dissect += g_get_monotonic_time() - elapsed_start;\n\n        /* Run the filter if we have it. */\n        if (cf->dfcode) {\n            elapsed_start = g_get_monotonic_time();\n            passed = dfilter_apply_edt(cf->dfcode, edt);\n            tshark_elapsed.first_pass.dfilter_filter += g_get_monotonic_time() - elapsed_start;\n        }\n    }\n\n    if (passed) {\n        frame_data_set_after_dissect(&fdata, &cum_bytes);\n\n        /* Process this packet. */\n        if (print_packet_info) {\n            /* We're printing packet information; print the information for\n               this packet. */\n            ws_assert(edt);\n            print_packet(cf, edt);\n\n            /* If we're doing \"line-buffering\", flush the standard output\n               after every packet.  See the comment above, for the \"-l\"\n               option, for an explanation of why we do that. */\n            if (line_buffered)\n                fflush(stdout);\n\n            if (ferror(stdout)) {\n                show_print_file_io_error();\n                exit(2);\n            }\n        }\n\n        /* this must be set after print_packet() [bug #8160] */\n        prev_dis_frame = fdata;\n        cf->provider.prev_dis = &prev_dis_frame;\n    }\n\n    prev_cap_frame = fdata;\n    cf->provider.prev_cap = &prev_cap_frame;\n\n    if (edt) {\n        epan_dissect_reset(edt);\n        frame_data_destroy(&fdata);\n        rec->block = block;\n    }\n    return passed;\n}\n\nstatic bool\nwrite_preamble(capture_file *cf)\n{\n    switch (output_action) {\n\n        case WRITE_TEXT:\n            return print_preamble(print_stream, cf->filename, get_ws_vcs_version_info());\n\n        case WRITE_XML:\n            if (print_details)\n                write_pdml_preamble(stdout, cf->filename);\n            else\n                write_psml_preamble(&cf->cinfo, stdout);\n            return !ferror(stdout);\n\n        case WRITE_FIELDS:\n            write_fields_preamble(output_fields, stdout);\n            return !ferror(stdout);\n\n        case WRITE_JSON:\n        case WRITE_JSON_RAW:\n            jdumper = write_json_preamble(stdout);\n            return !ferror(stdout);\n\n        case WRITE_EK:\n            return true;\n\n        default:\n            ws_assert_not_reached();\n            return false;\n    }\n}\n\nstatic char *\nget_line_buf(size_t len)\n{\n    static char   *line_bufp    = NULL;\n    static size_t  line_buf_len = 256;\n    size_t         new_line_buf_len;\n\n    for (new_line_buf_len = line_buf_len; len > new_line_buf_len;\n            new_line_buf_len *= 2)\n        ;\n    if (line_bufp == NULL) {\n        line_buf_len = new_line_buf_len;\n        line_bufp = (char *)g_malloc(line_buf_len + 1);\n    } else {\n        if (new_line_buf_len > line_buf_len) {\n            line_buf_len = new_line_buf_len;\n            line_bufp = (char *)g_realloc(line_bufp, line_buf_len + 1);\n        }\n    }\n    return line_bufp;\n}\n\nstatic inline void\nput_string(char *dest, const char *str, size_t str_len)\n{\n    memcpy(dest, str, str_len);\n    dest[str_len] = '\\0';\n}\n\nstatic inline void\nput_spaces_string(char *dest, const char *str, size_t str_len, size_t str_with_spaces)\n{\n    size_t i;\n\n    for (i = str_len; i < str_with_spaces; i++)\n        *dest++ = ' ';\n\n    put_string(dest, str, str_len);\n}\n\nstatic inline void\nput_string_spaces(char *dest, const char *str, size_t str_len, size_t str_with_spaces)\n{\n    size_t i;\n\n    memcpy(dest, str, str_len);\n    for (i = str_len; i < str_with_spaces; i++)\n        dest[i] = ' ';\n\n    dest[str_with_spaces] = '\\0';\n}\n\nstatic bool\nprint_columns(capture_file *cf, const epan_dissect_t *edt)\n{\n    char   *line_bufp;\n    int     i;\n    size_t  buf_offset;\n    size_t  column_len;\n    size_t  col_len;\n    col_item_t* col_item;\n    char str_format[11];\n    const color_filter_t *color_filter = NULL;\n\n    line_bufp = get_line_buf(256);\n    buf_offset = 0;\n    *line_bufp = '\\0';\n\n    if (dissect_color)\n        color_filter = edt->pi.fd->color_filter;\n\n    for (i = 0; i < cf->cinfo.num_cols; i++) {\n        col_item = &cf->cinfo.columns[i];\n        /* Skip columns not marked as visible. */\n        if (!get_column_visible(i))\n            continue;\n        const char* col_text = get_column_text(&cf->cinfo, i);\n        switch (col_item->col_fmt) {\n            case COL_NUMBER:\n            case COL_NUMBER_DIS:\n                column_len = col_len = strlen(col_text);\n                if (column_len < 5)\n                    column_len = 5;\n                line_bufp = get_line_buf(buf_offset + column_len);\n                put_spaces_string(line_bufp + buf_offset, col_text, col_len, column_len);\n                break;\n\n            case COL_CLS_TIME:\n            case COL_REL_TIME:\n            case COL_ABS_TIME:\n            case COL_ABS_YMD_TIME:  /* XXX - wider */\n            case COL_ABS_YDOY_TIME: /* XXX - wider */\n            case COL_UTC_TIME:\n            case COL_UTC_YMD_TIME:  /* XXX - wider */\n            case COL_UTC_YDOY_TIME: /* XXX - wider */\n                column_len = col_len = strlen(col_text);\n                if (column_len < 10)\n                    column_len = 10;\n                line_bufp = get_line_buf(buf_offset + column_len);\n                put_spaces_string(line_bufp + buf_offset, col_text, col_len, column_len);\n                break;\n\n            case COL_DEF_SRC:\n            case COL_RES_SRC:\n            case COL_UNRES_SRC:\n            case COL_DEF_DL_SRC:\n            case COL_RES_DL_SRC:\n            case COL_UNRES_DL_SRC:\n            case COL_DEF_NET_SRC:\n            case COL_RES_NET_SRC:\n            case COL_UNRES_NET_SRC:\n                column_len = col_len = strlen(col_text);\n                if (column_len < 12)\n                    column_len = 12;\n                line_bufp = get_line_buf(buf_offset + column_len);\n                put_spaces_string(line_bufp + buf_offset, col_text, col_len, column_len);\n                break;\n\n            case COL_DEF_DST:\n            case COL_RES_DST:\n            case COL_UNRES_DST:\n            case COL_DEF_DL_DST:\n            case COL_RES_DL_DST:\n            case COL_UNRES_DL_DST:\n            case COL_DEF_NET_DST:\n            case COL_RES_NET_DST:\n            case COL_UNRES_NET_DST:\n                column_len = col_len = strlen(col_text);\n                if (column_len < 12)\n                    column_len = 12;\n                line_bufp = get_line_buf(buf_offset + column_len);\n                put_string_spaces(line_bufp + buf_offset, col_text, col_len, column_len);\n                break;\n\n            default:\n                column_len = strlen(col_text);\n                line_bufp = get_line_buf(buf_offset + column_len);\n                put_string(line_bufp + buf_offset, col_text, column_len);\n                break;\n        }\n        buf_offset += column_len;\n        if (i != cf->cinfo.num_cols - 1) {\n            /*\n             * This isn't the last column, so we need to print a\n             * separator between this column and the next.\n             *\n             * If we printed a network source and are printing a\n             * network destination of the same type next, separate\n             * them with a UTF-8 right arrow; if we printed a network\n             * destination and are printing a network source of the same\n             * type next, separate them with a UTF-8 left arrow;\n             * otherwise separate them with a space.\n             *\n             * We add enough space to the buffer for \" \\xe2\\x86\\x90 \"\n             * or \" \\xe2\\x86\\x92 \", even if we're only adding \" \".\n             */\n            line_bufp = get_line_buf(buf_offset + 5);\n            switch (col_item->col_fmt) {\n\n                case COL_DEF_SRC:\n                case COL_RES_SRC:\n                case COL_UNRES_SRC:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_DST:\n                        case COL_RES_DST:\n                        case COL_UNRES_DST:\n                            snprintf(str_format, sizeof(str_format), \"%s%s%s\", delimiter_char, UTF8_RIGHTWARDS_ARROW, delimiter_char);\n                            put_string(line_bufp + buf_offset, str_format, 5);\n                            buf_offset += 5;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, delimiter_char, 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                case COL_DEF_DL_SRC:\n                case COL_RES_DL_SRC:\n                case COL_UNRES_DL_SRC:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_DL_DST:\n                        case COL_RES_DL_DST:\n                        case COL_UNRES_DL_DST:\n                            snprintf(str_format, sizeof(str_format), \"%s%s%s\", delimiter_char, UTF8_RIGHTWARDS_ARROW, delimiter_char);\n                            put_string(line_bufp + buf_offset, str_format, 5);\n                            buf_offset += 5;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, delimiter_char, 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                case COL_DEF_NET_SRC:\n                case COL_RES_NET_SRC:\n                case COL_UNRES_NET_SRC:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_NET_DST:\n                        case COL_RES_NET_DST:\n                        case COL_UNRES_NET_DST:\n                            snprintf(str_format, sizeof(str_format), \"%s%s%s\", delimiter_char, UTF8_RIGHTWARDS_ARROW, delimiter_char);\n                            put_string(line_bufp + buf_offset, str_format, 5);\n                            buf_offset += 5;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, delimiter_char, 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                case COL_DEF_DST:\n                case COL_RES_DST:\n                case COL_UNRES_DST:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_SRC:\n                        case COL_RES_SRC:\n                        case COL_UNRES_SRC:\n                            snprintf(str_format, sizeof(str_format), \"%s%s%s\", delimiter_char, UTF8_LEFTWARDS_ARROW, delimiter_char);\n                            put_string(line_bufp + buf_offset, str_format, 5);\n                            buf_offset += 5;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, delimiter_char, 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                case COL_DEF_DL_DST:\n                case COL_RES_DL_DST:\n                case COL_UNRES_DL_DST:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_DL_SRC:\n                        case COL_RES_DL_SRC:\n                        case COL_UNRES_DL_SRC:\n                            snprintf(str_format, sizeof(str_format), \"%s%s%s\", delimiter_char, UTF8_LEFTWARDS_ARROW, delimiter_char);\n                            put_string(line_bufp + buf_offset, str_format, 5);\n                            buf_offset += 5;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, delimiter_char, 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                case COL_DEF_NET_DST:\n                case COL_RES_NET_DST:\n                case COL_UNRES_NET_DST:\n                    switch (cf->cinfo.columns[i+1].col_fmt) {\n\n                        case COL_DEF_NET_SRC:\n                        case COL_RES_NET_SRC:\n                        case COL_UNRES_NET_SRC:\n                            snprintf(str_format, sizeof(str_format), \"%s%s%s\", delimiter_char, UTF8_LEFTWARDS_ARROW, delimiter_char);\n                            put_string(line_bufp + buf_offset, str_format, 5);\n                            buf_offset += 5;\n                            break;\n\n                        default:\n                            put_string(line_bufp + buf_offset, delimiter_char, 1);\n                            buf_offset += 1;\n                            break;\n                    }\n                    break;\n\n                default:\n                    put_string(line_bufp + buf_offset, delimiter_char, 1);\n                    buf_offset += 1;\n                    break;\n            }\n        }\n    }\n\n    if (dissect_color && color_filter != NULL)\n        return print_line_color(print_stream, 0, line_bufp, &color_filter->fg_color, &color_filter->bg_color);\n    else\n        return print_line(print_stream, 0, line_bufp);\n}\n\nstatic bool\nprint_packet(capture_file *cf, epan_dissect_t *edt)\n{\n    if (print_summary || output_fields_has_cols(output_fields))\n        /* Just fill in the columns. */\n        epan_dissect_fill_in_columns(edt, false, true);\n\n    /* Print summary columns and/or protocol tree */\n    switch (output_action) {\n\n        case WRITE_TEXT:\n            if (print_summary && !print_columns(cf, edt))\n                return false;\n            if (print_details) {\n                if (!proto_tree_print(print_details ? print_dissections_expanded : print_dissections_none,\n                            print_hex, edt, output_only_tables, print_stream))\n                    return false;\n                if (!print_hex) {\n                    if (!print_line(print_stream, 0, separator))\n                        return false;\n                }\n            }\n            break;\n\n        case WRITE_XML:\n            if (print_summary) {\n                write_psml_columns(edt, stdout, dissect_color);\n                return !ferror(stdout);\n            }\n            if (print_details) {\n                write_pdml_proto_tree(output_fields, edt, &cf->cinfo, stdout, dissect_color);\n                printf(\"\\n\");\n                return !ferror(stdout);\n            }\n            break;\n\n        case WRITE_FIELDS:\n            if (print_summary) {\n                /*No non-verbose \"fields\" format */\n                ws_assert_not_reached();\n            }\n            if (print_details) {\n                write_fields_proto_tree(output_fields, edt, &cf->cinfo, stdout);\n                printf(\"\\n\");\n                return !ferror(stdout);\n            }\n            break;\n\n        case WRITE_JSON:\n            if (print_summary)\n                ws_assert_not_reached();\n            if (print_details) {\n                write_json_proto_tree(output_fields, print_dissections_expanded,\n                        print_hex, edt, &cf->cinfo, node_children_grouper, &jdumper);\n                return !ferror(stdout);\n            }\n            break;\n\n        case WRITE_JSON_RAW:\n            if (print_summary)\n                ws_assert_not_reached();\n            if (print_details) {\n                write_json_proto_tree(output_fields, print_dissections_none,\n                        true, edt, &cf->cinfo, node_children_grouper, &jdumper);\n                return !ferror(stdout);\n            }\n            break;\n\n        case WRITE_EK:\n            write_ek_proto_tree(output_fields, print_summary, print_hex,\n                    edt, &cf->cinfo, stdout);\n            return !ferror(stdout);\n\n        default:\n            ws_assert_not_reached();\n    }\n\n    if (print_hex) {\n        if (print_summary || print_details) {\n            if (!print_line(print_stream, 0, \"\"))\n                return false;\n        }\n        if (!print_hex_data(print_stream, edt, hexdump_source_option | hexdump_ascii_option | hexdump_timestamp_option))\n            return false;\n        if (!print_line(print_stream, 0, separator))\n            return false;\n    }\n    return true;\n}\n\nstatic bool\nwrite_finale(void)\n{\n    switch (output_action) {\n\n        case WRITE_TEXT:\n            return print_finale(print_stream);\n\n        case WRITE_XML:\n            if (print_details)\n                write_pdml_finale(stdout);\n            else\n                write_psml_finale(stdout);\n            return !ferror(stdout);\n\n        case WRITE_FIELDS:\n            write_fields_finale(output_fields, stdout);\n            return !ferror(stdout);\n\n        case WRITE_JSON:\n        case WRITE_JSON_RAW:\n            write_json_finale(&jdumper);\n            return !ferror(stdout);\n\n        case WRITE_EK:\n            return true;\n\n        default:\n            ws_assert_not_reached();\n            return false;\n    }\n}\n\nvoid\ncf_close(capture_file *cf)\n{\n    if (cf->state == FILE_CLOSED)\n        return; /* Nothing to do */\n\n    if (cf->provider.wth != NULL) {\n        wtap_close(cf->provider.wth);\n        cf->provider.wth = NULL;\n    }\n    /* We have no file open... */\n    if (cf->filename != NULL) {\n        /* If it's a temporary file, remove it. */\n        if (cf->is_tempfile)\n            ws_unlink(cf->filename);\n        g_free(cf->filename);\n        cf->filename = NULL;\n    }\n\n    /* We have no file open. */\n    cf->state = FILE_CLOSED;\n}\n\ncf_status_t\ncf_open(capture_file *cf, const char *fname, unsigned int type, bool is_tempfile, int *err)\n{\n    wtap  *wth;\n    char *err_info;\n\n    wth = wtap_open_offline(fname, type, err, &err_info, perform_two_pass_analysis);\n    if (wth == NULL)\n        goto fail;\n\n    /* The open succeeded.  Fill in the information for this file. */\n\n    cf->provider.wth = wth;\n    cf->f_datalen = 0; /* not used, but set it anyway */\n\n    /* Set the file name because we need it to set the follow stream filter.\n       XXX - is that still true?  We need it for other reasons, though,\n       in any case. */\n    cf->filename = g_strdup(fname);\n\n    /* Indicate whether it's a permanent or temporary file. */\n    cf->is_tempfile = is_tempfile;\n\n    /* No user changes yet. */\n    cf->unsaved_changes = false;\n\n    cf->cd_t      = wtap_file_type_subtype(cf->provider.wth);\n    cf->open_type = type;\n    cf->count     = 0;\n    cf->drops_known = false;\n    cf->drops     = 0;\n    cf->snap      = wtap_snapshot_length(cf->provider.wth);\n    nstime_set_zero(&cf->elapsed_time);\n    cf->provider.ref = NULL;\n    cf->provider.prev_dis = NULL;\n    cf->provider.prev_cap = NULL;\n\n    cf->state = FILE_READ_IN_PROGRESS;\n\n    /* Create new epan session for dissection. */\n    epan_free(cf->epan);\n    cf->epan = tshark_epan_new(cf);\n\n    wtap_set_cb_new_ipv4(cf->provider.wth, add_ipv4_name);\n    wtap_set_cb_new_ipv6(cf->provider.wth, (wtap_new_ipv6_callback_t) add_ipv6_name);\n    wtap_set_cb_new_secrets(cf->provider.wth, secrets_wtap_callback);\n\n    return CF_OK;\n\nfail:\n    cfile_open_failure_message(fname, *err, err_info);\n    return CF_ERROR;\n}\n\nstatic void\nshow_print_file_io_error(void)\n{\n    switch (errno) {\n\n        case ENOSPC:\n            cmdarg_err(\"Not all the packets could be printed because there is \"\n                    \"no space left on the file system.\");\n            break;\n\n#ifdef EDQUOT\n        case EDQUOT:\n            cmdarg_err(\"Not all the packets could be printed because you are \"\n                    \"too close to, or over your disk quota.\");\n            break;\n#endif\n\n        case EPIPE:\n            /*\n             * This almost certainly means \"the next program after us in\n             * the pipeline exited before we were finished writing\", so\n             * this isn't a real error, it just means we're done.  (We\n             * don't get SIGPIPE because libwireshark ignores SIGPIPE\n             * to avoid getting killed if writing to the MaxMind process\n             * gets SIGPIPE because that process died.)\n             *\n             * Presumably either that program exited deliberately (for\n             * example, \"head -N\" read N lines and printed them), in\n             * which case there's no error to report, or it terminated\n             * due to an error or a signal, in which case *that's* the\n             * error and that error has been reported.\n             */\n            break;\n\n        default:\n#ifdef _WIN32\n            if (errno == EINVAL && _doserrno == ERROR_NO_DATA) {\n                /*\n                 * XXX - on Windows, a write to a pipe where the read side\n                 * has been closed apparently may return the Windows error\n                 * ERROR_BROKEN_PIPE, which the Visual Studio C library maps\n                 * to EPIPE, or may return the Windows error ERROR_NO_DATA,\n                 * which the Visual Studio C library maps to EINVAL.\n                 *\n                 * Either of those almost certainly means \"the next program\n                 * after us in the pipeline exited before we were finished\n                 * writing\", so, if _doserrno is ERROR_NO_DATA, this isn't\n                 * a real error, it just means we're done.  (Windows doesn't\n                 * SIGPIPE.)\n                 *\n                 * Presumably either that program exited deliberately (for\n                 * example, \"head -N\" read N lines and printed them), in\n                 * which case there's no error to report, or it terminated\n                 * due to an error or a signal, in which case *that's* the\n                 * error and that error has been reported.\n                 */\n                break;\n            }\n\n            /*\n             * It's a different error; report it, but with the error\n             * message for _doserrno, which will give more detail\n             * than just \"Invalid argument\".\n             */\n            cmdarg_err(\"An error occurred while printing packets: %s.\",\n                    win32strerror(_doserrno));\n#else\n            cmdarg_err(\"An error occurred while printing packets: %s.\",\n                    g_strerror(errno));\n#endif\n            break;\n    }\n}\n\nstatic void\nreset_epan_mem(capture_file *cf,epan_dissect_t *edt, bool tree, bool visual)\n{\n    if (!epan_auto_reset || (cf->count < epan_auto_reset_count))\n        return;\n\n    fprintf(stderr, \"resetting session.\\n\");\n\n    epan_dissect_cleanup(edt);\n    epan_free(cf->epan);\n\n    cf->epan = tshark_epan_new(cf);\n    epan_dissect_init(edt, cf->epan, tree, visual);\n    cf->count = 0;\n}\n"
        },
        {
          "name": "ui",
          "type": "tree",
          "content": null
        },
        {
          "name": "vagrant_build.sh",
          "type": "blob",
          "size": 0.53515625,
          "content": "#!/bin/bash\n#\n# Copyright 2015 Evan Huus <eapache@gmail.com>\n#\n# Wireshark - Network traffic analyzer\n# By Gerald Combs <gerald@wireshark.org>\n# Copyright 1998 Gerald Combs\n#\n# SPDX-License-Identifier: GPL-2.0-or-later\n\nset -e\n\ngrep -q WIRESHARK_RUN_FROM_BUILD_DIRECTORY ~/.profile || echo \"export WIRESHARK_RUN_FROM_BUILD_DIRECTORY=1\" >> ~/.profile\ngrep -q WIRESHARK_BIN_DIR ~/.profile || echo \"export WIRESHARK_BIN_DIR=~/build/run\" >> ~/.profile\nmkdir -p build\ncd build\ncmake -DENABLE_CCACHE=ON ../wireshark\nmake -j4\nmake test-programs\nmake test\n"
        },
        {
          "name": "wireshark.dox",
          "type": "blob",
          "size": 0.111328125,
          "content": "/**\n\n\\mainpage Wireshark API Reference\n\n\\section intro_sec Introduction\n\nThis is the Wireshark documentation.\n\n*/\n"
        },
        {
          "name": "wiretap",
          "type": "tree",
          "content": null
        },
        {
          "name": "wka",
          "type": "blob",
          "size": 10.9580078125,
          "content": "#\n# Well-known addresses.\n#\n# Wireshark - Network traffic analyzer\n# By Gerald Combs <gerald [AT] wireshark.org>\n# Copyright 1998 Gerald Combs\n#\n# SPDX-License-Identifier: GPL-2.0-or-later\n#\n# The data below has been assembled from the following sources:\n#\n# Michael Patton's \"Ethernet Codes Master Page\" available from:\n# <http://www.cavebear.com/CaveBear/Ethernet/>\n# <ftp://ftp.cavebear.com/pub/Ethernet.txt>\n#\n# Microsoft Windows 2000 Server\n# Operating System\n# Network Load Balancing Technical Overview\n# White Paper\n#\n00-00-00-00-FE-21\tCheckpoint-Uninitialized-Cluster-Member\n00-00-0C-07-AC/40\tAll-HSRP-routers\n00-00-5E-00-01/40\tIETF-VRRP-VRID\n00-0C-0C-0C-0C-0C\tCisco-ACI-Gleaning-Leaf\n00-0D-0D-0D-0D-0D\tCisco-ACI-Gleaning-Spine\n00-BF-00-00-00-00/16\tMS-NLB-VirtServer\n00-E0-2B-00-00-00\tExtreme-EDP\n# Extreme Encapsulation Protocol (basically EDP renamed)\n00-E0-2B-00-00-01\tExtreme-EEP\n00-E0-2B-00-00-02\tExtreme-ESRP-Client\n00-E0-2B-00-00-04\tExtreme-EAPS\n00-E0-2B-00-00-06\tExtreme-EAPS-SL\n00-E0-2B-00-00-08\tExtreme-ESRP-Master\n01-00-0C-00-00/40\tISL-Frame\n01-00-0C-CC-CC-CC\tCDP/VTP/DTP/PAgP/UDLD\n01-00-0C-CC-CC-CD\tPVST+\n01-00-0C-CD-CD-CD\tSTP-UplinkFast\n01-00-0C-CD-CD-CE\tVLAN-bridge\n01-00-0C-CD-CD-D0\tGBPT\n01-00-0C-DD-DD-DD\tCGMP\n01-00-10-00-00-20\tHughes-Lan-Systems-Terminal-Server-S/W-download\n01-00-10-FF-FF-20\tHughes-Lan-Systems-Terminal-Server-S/W-request\n01-00-1D-00-00-00\tCabletron-PC-OV-PC-discover-(on-demand)\n01-00-1D-00-00-05\tCabletron-PVST-BPDU\n01-00-1D-00-00-06\tCabletron-QCSTP-BPDU\n01-00-1D-42-00-00\tCabletron-PC-OV-Bridge-discover-(on-demand)\n01-00-1D-52-00-00\tCabletron-PC-OV-MMAC-discover-(on-demand)\n01-00-3C\t\tAuspex-Systems-(Serverguard)\n01-00-5E/25\t\tIPv4mcast\n01-00-81-00-00-00\tNortel-Network-Management\n01-00-81-00-00-02\tNortel-Network-Management\n01-00-81-00-01-00\tNortel-autodiscovery\n01-00-81-00-01-01\tNortel-autodiscovery\n# Cisco Fabric Path\n01-0F-FF-C1-01-C0\tFP-Flood-to-all-VLANs\n01-0F-FF-C1-02-C0\tFP-Flood-to-all-Fabrics\n#\n# As per\n#\n#\thttp://www.t11.org/ftp/t11/pub/fc/bb-5/08-334v0.pdf\n#\n# Broadcom \"donated\" one of their OUIs, 00-10-18, for use for\n# Fibre Channel over Ethernet, so we add entries for the\n# addresses in that document and a group of addresses for all\n# otherwise unlisted 01-10-18-XX-XX-XX addresses.\n#\n01-10-18-01-00-00\tAll-FCoE-MACs\n01-10-18-01-00-01\tAll-ENode-MACs\n01-10-18-01-00-02\tAll-FCF-MACs\n01-10-18-00-00-00/24\tFCoE-group\n01-11-1E-00-00-01\tEPLv2_SoC\n01-11-1E-00-00-02\tEPLv2_PRes\n01-11-1E-00-00-03\tEPLv2_SoA\n01-11-1E-00-00-04\tEPLv2_ASnd\n01-11-1E-00-00-05\tEPLv2_AMNI\n01-20-25/25\t\tControl-Technology-Inc's-Industrial-Ctrl-Proto.\n01-80-24-00-00-00\tKalpana-Etherswitch-every-60-seconds\n# IEEE 802.1Q-2018 Table 8-1, C-VLAN and MAC Bridge component Reserved addresses\n01-80-C2-00-00-00/44\tSpanning-tree-(for-bridges)\n# 01-80-C2-00-00-00\talso: Nearest customer bridge\n01-80-C2-00-00-01\tMAC-specific-ctrl-proto-01\n01-80-C2-00-00-02\tSlow-Protocols\n01-80-C2-00-00-03\tNearest-non-TPMR-bridge\n01-80-C2-00-00-04\tMAC-specific-ctrl-proto-04\n01-80-C2-00-00-05\tReserved-future-std-05\n01-80-C2-00-00-06\tReserved-future-std-06\n01-80-C2-00-00-07\tMEF-Forum-ELMI-proto\n01-80-C2-00-00-08\tProvider-Bridge\n01-80-C2-00-00-09\tReserved-future-std-09\n01-80-C2-00-00-0A\tReserved-future-std-0a\n01-80-C2-00-00-0B\tEDE-SS-PEP\n01-80-C2-00-00-0C\tReserved-future-std-0c\n01-80-C2-00-00-0D\tProvider-Bridge-MVRP\n01-80-C2-00-00-0E\tLLDP_Multicast\n01-80-C2-00-00-0F\tReserved-future-std-0f\n01-80-C2-00-00-10\tBridge-Management\n01-80-C2-00-00-11\tLoad-Server\n01-80-C2-00-00-12\tLoadable-Device\n01-80-C2-00-00-13\tIEEE-1905.1-Control\n01-80-C2-00-00-14\tISIS-all-level-1-IS's\n01-80-C2-00-00-15\tISIS-all-level-2-IS's\n01-80-C2-00-00-18\tIEEE-802.1B-All-Manager-Stations\n01-80-C2-00-00-19\tIEEE-802.11aa-groupcast-with-retries\n01-80-C2-00-00-1A\tIEEE-802.1B-All-Agent-Stations\n01-80-C2-00-00-1B\tESIS-all-multicast-capable-ES's\n01-80-C2-00-00-1C\tESIS-all-multicast-announcements\n01-80-C2-00-00-1D\tESIS-all-multicast-capable-IS's\n01-80-C2-00-00-1E\tToken-Ring-all-DTR-Concentrators\n01-80-C2-00-00-30/45\tOAM-Multicast-DA-Class-1\n01-80-C2-00-00-38/45\tOAM-Multicast-DA-Class-2\n01-80-C2-00-00-40\tAll-RBridges\n01-80-C2-00-00-41\tAll-IS-IS-RBridges\n01-80-C2-00-00-42\tAll-Egress-RBridges\n01-80-C2-00-00-45\tTRILL-End-Stations\n01-80-C2-00-00-46\tAll-Edge-RBridges\n01-80-C2-00-01-00\tFDDI-RMT-Directed-Beacon\n01-80-C2-00-01-10\tFDDI-status-report-frame\n01-DD-00-FF-FF-FF\tUngermann-Bass-boot-me-requests\n01-DD-01-00-00-00\tUngermann-Bass-Spanning-Tree\n01-E0-52-CC-CC-CC\tFoundry-DP\n# DOCSIS, defined in ANSI SCTE 22-1 2012\n01-E0-2F-00-00-01\tDOCSIS-CM\n01-E0-2F-00-00-02\tDOCSIS-CMTS\n01-E0-2F-00-00-03\tDOCSIS-STP\n\n# Extremenetworks in their infinite wisdom seems to use 02-04-94 (Vendor MAC XOR 02-00-00)\n# for their base mac address, thus colliding with MS-NLB 02-04/16 which Microsoft in their\n# infinite wisdom decided to use for MS-NLB.\n02-04-96-00-00-00/24\tExtremeNetworks\n\n# Microsoft Network Load Balancing (NLB)\n# Actually, 02-01-virtualip to 02-20-virtualip will be used from server to rest-of-world\n# 02-bf-virtualip will be used from rest-of-world to server\n02-BF-00-00-00-00/16\tMS-NLB-VirtServer\n02-01-00-00-00-00/16\tMS-NLB-PhysServer-01\n02-02-00-00-00-00/16\tMS-NLB-PhysServer-02\n02-03-00-00-00-00/16\tMS-NLB-PhysServer-03\n02-04-00-00-00-00/16\tMS-NLB-PhysServer-04\n02-05-00-00-00-00/16\tMS-NLB-PhysServer-05\n02-06-00-00-00-00/16\tMS-NLB-PhysServer-06\n02-07-00-00-00-00/16\tMS-NLB-PhysServer-07\n02-08-00-00-00-00/16\tMS-NLB-PhysServer-08\n02-09-00-00-00-00/16\tMS-NLB-PhysServer-09\n02-0a-00-00-00-00/16\tMS-NLB-PhysServer-10\n02-0b-00-00-00-00/16\tMS-NLB-PhysServer-11\n02-0c-00-00-00-00/16\tMS-NLB-PhysServer-12\n02-0d-00-00-00-00/16\tMS-NLB-PhysServer-13\n02-0e-00-00-00-00/16\tMS-NLB-PhysServer-14\n02-0f-00-00-00-00/16\tMS-NLB-PhysServer-15\n02-10-00-00-00-00/16\tMS-NLB-PhysServer-16\n02-11-00-00-00-00/16\tMS-NLB-PhysServer-17\n02-12-00-00-00-00/16\tMS-NLB-PhysServer-18\n02-13-00-00-00-00/16\tMS-NLB-PhysServer-19\n02-14-00-00-00-00/16\tMS-NLB-PhysServer-20\n02-15-00-00-00-00/16\tMS-NLB-PhysServer-21\n02-16-00-00-00-00/16\tMS-NLB-PhysServer-22\n02-17-00-00-00-00/16\tMS-NLB-PhysServer-23\n02-18-00-00-00-00/16\tMS-NLB-PhysServer-24\n02-19-00-00-00-00/16\tMS-NLB-PhysServer-25\n02-1a-00-00-00-00/16\tMS-NLB-PhysServer-26\n02-1b-00-00-00-00/16\tMS-NLB-PhysServer-27\n02-1c-00-00-00-00/16\tMS-NLB-PhysServer-28\n02-1d-00-00-00-00/16\tMS-NLB-PhysServer-29\n02-1e-00-00-00-00/16\tMS-NLB-PhysServer-30\n02-1f-00-00-00-00/16\tMS-NLB-PhysServer-31\n02-20-00-00-00-00/16\tMS-NLB-PhysServer-32\n\n#       [ The following block of addresses (03-...) are used by various ]\n#       [ standards.  Some (marked [TR?]) are suspected of only being   ]\n#       [ used on Token Ring for group addresses of Token Ring specific ]\n#       [ functions, reference ISO 8802-5:1995 aka. IEEE 802.5:1995 for ]\n#       [ some info.  These in the Ethernet order for this list.  On    ]\n#       [ Token Ring they appear reversed.  They should never appear on ]\n#       [ Ethernet.  Others, not so marked, are normal reports (may be  ]\n#       [ seen on either).\n03-00-00-00-00-01\tNETBIOS-# [TR?]\n03-00-00-00-00-02\tLocate-Directory-Server # [TR?]\n03-00-00-00-00-04\tSynchronous-Bandwidth-Manager-# [TR?]\n03-00-00-00-00-08\tConfiguration-Report-Server-# [TR?]\n03-00-00-00-00-10\tRing-Error-Monitor-# [TR?]\n03-00-00-00-00-10\t(OS/2-1.3-EE+Communications-Manager)\n03-00-00-00-00-20\tNetwork-Server-Heartbeat-# [TR?]\n03-00-00-00-00-40\t(OS/2-1.3-EE+Communications-Manager)\n03-00-00-00-00-80\tActive-Monitor # [TR?]\n03-00-00-00-01-00\tOSI-All-IS-Token-Ring-Multicast\n03-00-00-00-02-00\tOSI-All-ES-Token-Ring-Multicast\n03-00-00-00-04-00\tLAN-Manager # [TR?]\n03-00-00-00-08-00\tRing-Wiring-Concentrator # [TR?]\n03-00-00-00-10-00\tLAN-Gateway # [TR?]\n03-00-00-00-20-00\tRing-Authorization-Server # [TR?]\n03-00-00-00-40-00\tIMPL-Server # [TR?]\n03-00-00-00-80-00\tBridge # [TR?]\n03-00-00-20-00-00\tIP-Token-Ring-Multicast (RFC1469)\n03-00-00-80-00-00\tDiscovery-Client\n03-00-0C-00-00/40\tISL-Frame [TR?]\n03-00-C7-00-00-EE\tHP (Compaq) ProLiant NIC teaming\n03-00-FF-FF-FF-FF\tAll-Stations-Address\n03-BF-00-00-00-00/16\tMS-NLB-VirtServer-Multicast\n09-00-07-00-00-00/40\tAppleTalk-Zone-multicast-addresses\n\t\t\t# only goes through 09-00-07-00-00-FC?\n09-00-07-FF-FF-FF\tAppleTalk-broadcast-address\n09-00-09-00-00-01\tHP-Probe\n09-00-09-00-00-04\tHP-DTC\n09-00-0D-00-00-00/24\tICL-Oslan-Multicast\n09-00-0D-02-00-00\tICL-Oslan-Service-discover-only-on-boot\n09-00-0D-02-0A-38\tICL-Oslan-Service-discover-only-on-boot\n09-00-0D-02-0A-39\tICL-Oslan-Service-discover-only-on-boot\n09-00-0D-02-0A-3C\tICL-Oslan-Service-discover-only-on-boot\n09-00-0D-02-FF-FF\tICL-Oslan-Service-discover-only-on-boot\n09-00-0D-09-00-00\tICL-Oslan-Service-discover-as-required\n09-00-1E-00-00-00\tApollo-DOMAIN\n09-00-2B-00-00-00\tDEC-MUMPS?\n09-00-2B-00-00-01\tDEC-DSM/DDP\n09-00-2B-00-00-02\tDEC-VAXELN?\n09-00-2B-00-00-03\tDEC-Lanbridge-Traffic-Monitor-(LTM)\n09-00-2B-00-00-04\tDEC-MAP-(or-OSI?)-End-System-Hello?\n09-00-2B-00-00-05\tDEC-MAP-(or-OSI?)-Intermediate-System-Hello?\n09-00-2B-00-00-06\tDEC-CSMA/CD-Encryption?\n09-00-2B-00-00-07\tDEC-NetBios-Emulator?\n09-00-2B-00-00-0F\tDEC-Local-Area-Transport-(LAT)\n09-00-2B-00-00-10/44\tDEC-Experimental\n09-00-2B-01-00-00\tDEC-LanBridge-Copy-packets-(All-bridges)\n09-00-2B-01-00-01\tDEC-LanBridge-Hello-packets-(All-local-bridges)\n09-00-2B-02-00-00\tDEC-DNA-Level-2-Routing-Layer-routers?\n09-00-2B-02-01-00\tDEC-DNA-Naming-Service-Advertisement?\n09-00-2B-02-01-01\tDEC-DNA-Naming-Service-Solicitation?\n09-00-2B-02-01-09\tDEC-Availability-Manager-for-Distributed-Systems-DECamds\n09-00-2B-02-01-02\tDEC-Distributed-Time-Service\n09-00-2B-03-00-00/32\tDEC-default-filtering-by-bridges?\n09-00-2B-04-00-00\tDEC-Local-Area-System-Transport-(LAST)?\n09-00-2B-23-00-00\tDEC-Argonaut-Console?\n09-00-4C-00-00-00\tBICC-802.1-management\n09-00-4C-00-00-02\tBICC-802.1-management\n09-00-4C-00-00-06\tBICC-Local-bridge-STA-802.1(D)-Rev6\n09-00-4C-00-00-0C\tBICC-Remote-bridge-STA-802.1(D)-Rev8\n09-00-4C-00-00-0F\tBICC-Remote-bridge-ADAPTIVE-ROUTING\n09-00-56-FF-00-00/32\tStanford-V-Kernel,-version-6.0\n09-00-6A-00-01-00\tTOP-NetBIOS.\n09-00-77-00-00-00\tRetix-Bridge-Local-Management-System\n09-00-77-00-00-01\tRetix-spanning-tree-bridges\n09-00-77-00-00-02\tRetix-Bridge-Adaptive-routing\n09-00-7C-01-00-01\tVitalink-DLS-Multicast\n09-00-7C-01-00-03\tVitalink-DLS-Inlink\n09-00-7C-01-00-04\tVitalink-DLS-and-non-DLS-Multicast\n09-00-7C-02-00-05\tVitalink-diagnostics\n09-00-7C-05-00-01\tVitalink-gateway?\n09-00-7C-05-00-02\tVitalink-Network-Validation-Message\n09-00-87-80-FF-FF\tXyplex-Terminal-Servers\n09-00-87-90-FF-FF\tXyplex-Terminal-Servers\n0C-00-0C-00-00/40\tISL-Frame\n0D-1E-15-BA-DD-06\tHP\n20-52-45-43-56-00/40\tReceive\n20-53-45-4E-44-00/40\tSend\n33-33-00-00-00-00\tIPv6-Neighbor-Discovery\n33-33-00-00-00-00/16\tIPv6mcast\nAA-00-03-00-00-00/32\tDEC-UNA\nAA-00-03-01-00-00/32\tDEC-PROM-AA\nAA-00-03-03-00-00/32\tDEC-NI20\nAB-00-00-01-00-00\tDEC-MOP-Dump/Load-Assistance\nAB-00-00-02-00-00\tDEC-MOP-Remote-Console\nAB-00-00-03-00-00\tDECNET-Phase-IV-end-node-Hello-packets\nAB-00-00-04-00-00\tDECNET-Phase-IV-Router-Hello-packets\nAB-00-03-00-00-00\tDEC-Local-Area-Transport-(LAT)-old\nAB-00-04-01-00-00/32\tDEC-Local-Area-VAX-Cluster-groups-SCA\nCF-00-00-00-00-00\tEthernet-Configuration-Test-protocol-(Loopback)\nFF-FF-00-60-00-04\tLantastic\nFF-FF-00-40-00-01\tLantastic\nFF-FF-01-E0-00-04\tLantastic\n\nFF-FF-FF-FF-FF-FF\tBroadcast\n"
        },
        {
          "name": "writecap",
          "type": "tree",
          "content": null
        },
        {
          "name": "ws_version.h.in",
          "type": "blob",
          "size": 0.2666015625,
          "content": "/* ws_version.h.in */\n\n#ifndef __WS_VERSION_H__\n#define __WS_VERSION_H__\n\n#define WIRESHARK_VERSION_MAJOR @PROJECT_MAJOR_VERSION@\n#define WIRESHARK_VERSION_MINOR @PROJECT_MINOR_VERSION@\n#define WIRESHARK_VERSION_MICRO @PROJECT_PATCH_VERSION@\n\n#endif /* __WS_VERSION_H__ */\n"
        },
        {
          "name": "wsutil",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}