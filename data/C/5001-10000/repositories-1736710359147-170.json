{
  "metadata": {
    "timestamp": 1736710359147,
    "page": 170,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mozilla/mozjpeg",
      "stars": 5499,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.1279296875,
          "content": "/appveyor.yml export-ignore\n/.gitattributes export-ignore\n/.github export-ignore\n*.ppm binary\n/ChangeLog.md conflict-marker-size=8\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5283203125,
          "content": ".DS_Store\nMakefile.in\nMakefile\n/CMakeFiles\n/autom4te.cache\n/aclocal.m4\n/compile\n/configure\n/depcomp\n/install-sh\n/libtool\n/missing\n/stamp-h*\n/java/classnoinst.stamp\n/pkgscripts/\n/jconfig.h\n/jconfigint.h\n/config.guess\n/config.h\n/config.h.in\n/config.log\n/config.status\n/config.sub\n/ltmain.sh\n/ar-lib\n/libjpeg.map\n/.libs/\n/simd/.libs/\n/simd/jsimdcfg.inc\n*.o\n*.lo\n*.la\n/cjpeg\n/djpeg\n/jcstest\n/jpegtran\n/jpegyuv\n/md5/md5cmp\n/rdjpgcom\n/test_enc_*\n/tjbench\n/tjbenchtest\n/tjunittest\n/wrjpgcom\n/yuvjpeg\ntest_yuv*.jpg\nCMakeCache.txt\nCTestTestfile.cmake"
        },
        {
          "name": "BUILDING.md",
          "type": "blob",
          "size": 24.962890625,
          "content": "Building libjpeg-turbo\n======================\n\n\nBuild Requirements\n------------------\n\n\n### All Systems\n\n- [CMake](https://cmake.org) v2.8.12 or later\n\n- [NASM](https://nasm.us) or [Yasm](https://yasm.tortall.net)\n  (if building x86 or x86-64 SIMD extensions)\n  * If using NASM, 2.13 or later is required.\n  * If using Yasm, 1.2.0 or later is required.\n  * NASM 2.15 or later is required if building libjpeg-turbo with Intel\n    Control-flow Enforcement Technology (CET) support.\n  * If building on macOS, NASM or Yasm can be obtained from\n    [MacPorts](https://macports.org) or [Homebrew](https://brew.sh).\n     - NOTE: Currently, if it is desirable to hide the SIMD function symbols in\n       Mac executables or shared libraries that statically link with\n       libjpeg-turbo, then NASM 2.14 or later or Yasm must be used when\n       building libjpeg-turbo.\n  * If NASM or Yasm is not in your `PATH`, then you can specify the full path\n    to the assembler by using either the `CMAKE_ASM_NASM_COMPILER` CMake\n    variable or the `ASM_NASM` environment variable.  On Windows, use forward\n    slashes rather than backslashes in the path (for example,\n    **c:/nasm/nasm.exe**).\n  * NASM and Yasm are located in the CRB (Code Ready Builder) or PowerTools\n    repository on Red Hat Enterprise Linux 8+ and derivatives, which is not\n    enabled by default.\n\n### Un*x Platforms (including Linux, Mac, FreeBSD, Solaris, and Cygwin)\n\n- GCC v4.1 (or later) or Clang recommended for best performance\n\n- If building the TurboJPEG Java wrapper, JDK or OpenJDK 1.5 or later is\n  required.  Most modern Linux distributions, as well as Solaris 10 and later,\n  include JDK or OpenJDK.  For other systems, you can obtain the Oracle Java\n  Development Kit from\n  <https://oracle.com/java/technologies/downloads>.\n\n  * If using JDK 11 or later, CMake 3.10.x or later must also be used.\n\n### Windows\n\n- Microsoft Visual C++ 2005 or later\n\n  If you don't already have Visual C++, then the easiest way to get it is by\n  installing\n  [Visual Studio Community Edition](https://visualstudio.microsoft.com),\n  which includes everything necessary to build libjpeg-turbo.\n\n  * You can also download and install the standalone Windows SDK (for Windows 7\n    or later), which includes command-line versions of the 32-bit and 64-bit\n    Visual C++ compilers.\n  * If you intend to build libjpeg-turbo from the command line, then add the\n    appropriate compiler and SDK directories to the `INCLUDE`, `LIB`, and\n    `PATH` environment variables.  This is generally accomplished by\n    executing `vcvars32.bat` or `vcvars64.bat`, which are located in the same\n    directory as the compiler.\n  * If built with Visual C++ 2015 or later, the libjpeg-turbo static libraries\n    cannot be used with earlier versions of Visual C++, and vice versa.\n  * The libjpeg API DLL (**jpeg{version}.dll**) will depend on the C run-time\n    DLLs corresponding to the version of Visual C++ that was used to build it.\n    \n- Vcpkg\n  \n  You need to download and install libpng using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\n\n      git clone https://github.com/Microsoft/vcpkg.git\n      cd vcpkg\n      ./bootstrap-vcpkg.bat\n      ./vcpkg integrate install\n      ./vcpkg install libpng:x64-windows\n      ./vcpkg install libpng:x64-windows-static\n      \n  Actually, you can just download and install MozJPEG using vcpkg dependency manager:\n      \n      ./vcpkg install mozjpeg\n  \n  The mozjpeg port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n\n   ... OR ...\n\n\n- MinGW\n\n  [MSYS2](https://msys2.org) or [tdm-gcc](https://jmeubank.github.io/tdm-gcc)\n  recommended if building on a Windows machine.  Both distributions install a\n  Start Menu link that can be used to launch a command prompt with the\n  appropriate compiler paths automatically set.\n\n- If building the TurboJPEG Java wrapper, JDK 1.5 or later is required.  This\n  can be downloaded from\n  <https://oracle.com/java/technologies/downloads>.\n\n  * If using JDK 11 or later, CMake 3.10.x or later must also be used.\n\n\nSub-Project Builds\n------------------\n\nThe libjpeg-turbo build system does not support being included as a sub-project\nusing the CMake `add_subdirectory()` function.  Use the CMake\n`ExternalProject_Add()` function instead.\n\n\nOut-of-Tree Builds\n------------------\n\nBinary objects, libraries, and executables are generated in the directory from\nwhich CMake is executed (the \"binary directory\"), and this directory need not\nnecessarily be the same as the libjpeg-turbo source directory.  You can create\nmultiple independent binary directories, in which different versions of\nlibjpeg-turbo can be built from the same source tree using different compilers\nor settings.  In the sections below, *{build_directory}* refers to the binary\ndirectory, whereas *{source_directory}* refers to the libjpeg-turbo source\ndirectory.  For in-tree builds, these directories are the same.\n\n\nNinja\n-----\n\nIf using Ninja, then replace `make` or `nmake` with `ninja`, and replace the\nCMake generator (specified with the `-G` option) with `Ninja`, in all of the\nprocedures and recipes below.\n\n\nBuild Procedure\n---------------\n\nNOTE: The build procedures below assume that CMake is invoked from the command\nline, but all of these procedures can be adapted to the CMake GUI as\nwell.\n\n\n### Un*x\n\nThe following procedure will build libjpeg-turbo on Unix and Unix-like systems.\n(On Solaris, this generates a 32-bit build.  See \"Build Recipes\" below for\n64-bit build instructions.)\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" [additional CMake flags] {source_directory}\n    make\n\nThis will generate the following files under *{build_directory}*:\n\n**libjpeg.a**<br>\nStatic link library for the libjpeg API\n\n**libjpeg.so.{version}** (Linux, Unix)<br>\n**libjpeg.{version}.dylib** (Mac)<br>\n**cygjpeg-{version}.dll** (Cygwin)<br>\nShared library for the libjpeg API\n\nBy default, *{version}* is 62.2.0, 7.2.0, or 8.1.2, depending on whether\nlibjpeg v6b (default), v7, or v8 emulation is enabled.  If using Cygwin,\n*{version}* is 62, 7, or 8.\n\n**libjpeg.so** (Linux, Unix)<br>\n**libjpeg.dylib** (Mac)<br>\nDevelopment symlink for the libjpeg API\n\n**libjpeg.dll.a** (Cygwin)<br>\nImport library for the libjpeg API\n\n**libturbojpeg.a**<br>\nStatic link library for the TurboJPEG API\n\n**libturbojpeg.so.0.2.0** (Linux, Unix)<br>\n**libturbojpeg.0.2.0.dylib** (Mac)<br>\n**cygturbojpeg-0.dll** (Cygwin)<br>\nShared library for the TurboJPEG API\n\n**libturbojpeg.so** (Linux, Unix)<br>\n**libturbojpeg.dylib** (Mac)<br>\nDevelopment symlink for the TurboJPEG API\n\n**libturbojpeg.dll.a** (Cygwin)<br>\nImport library for the TurboJPEG API\n\n\n### Visual C++ (Command Line)\n\n    cd {build_directory}\n    cmake -G\"NMake Makefiles\" -DCMAKE_BUILD_TYPE=Release [additional CMake flags] {source_directory}\n    nmake\n\nThis will build either a 32-bit or a 64-bit version of libjpeg-turbo, depending\non which version of **cl.exe** is in the `PATH`.\n\nThe following files will be generated under *{build_directory}*:\n\n**jpeg-static.lib**<br>\nStatic link library for the libjpeg API\n\n**jpeg{version}.dll**<br>\nDLL for the libjpeg API\n\n**jpeg.lib**<br>\nImport library for the libjpeg API\n\n**turbojpeg-static.lib**<br>\nStatic link library for the TurboJPEG API\n\n**turbojpeg.dll**<br>\nDLL for the TurboJPEG API\n\n**turbojpeg.lib**<br>\nImport library for the TurboJPEG API\n\n*{version}* is 62, 7, or 8, depending on whether libjpeg v6b (default), v7, or\nv8 emulation is enabled.\n\n\n### Visual C++ (IDE)\n\nChoose the appropriate CMake generator option for your version of Visual Studio\n(run `cmake` with no arguments for a list of available generators.)  For\ninstance:\n\n    cd {build_directory}\n    cmake -G\"Visual Studio 10\" [additional CMake flags] {source_directory}\n\nNOTE: Add \"Win64\" to the generator name (for example, \"Visual Studio 10 Win64\")\nto build a 64-bit version of libjpeg-turbo.  A separate build directory must be\nused for 32-bit and 64-bit builds.\n\nYou can then open **ALL_BUILD.vcproj** in Visual Studio and build one of the\nconfigurations in that project (\"Debug\", \"Release\", etc.) to generate a full\nbuild of libjpeg-turbo.\n\nThis will generate the following files under *{build_directory}*:\n\n**{configuration}/jpeg-static.lib**<br>\nStatic link library for the libjpeg API\n\n**{configuration}/jpeg{version}.dll**<br>\nDLL for the libjpeg API\n\n**{configuration}/jpeg.lib**<br>\nImport library for the libjpeg API\n\n**{configuration}/turbojpeg-static.lib**<br>\nStatic link library for the TurboJPEG API\n\n**{configuration}/turbojpeg.dll**<br>\nDLL for the TurboJPEG API\n\n**{configuration}/turbojpeg.lib**<br>\nImport library for the TurboJPEG API\n\n*{configuration}* is Debug, Release, RelWithDebInfo, or MinSizeRel, depending\non the configuration you built in the IDE, and *{version}* is 62, 7, or 8,\ndepending on whether libjpeg v6b (default), v7, or v8 emulation is enabled.\n\n\n### MinGW\n\nNOTE: This assumes that you are building on a Windows machine using the MSYS\nenvironment.  If you are cross-compiling on a Un*x platform (including Mac and\nCygwin), then see \"Build Recipes\" below.\n\n    cd {build_directory}\n    cmake -G\"MSYS Makefiles\" [additional CMake flags] {source_directory}\n    make\n\nThis will generate the following files under *{build_directory}*:\n\n**libjpeg.a**<br>\nStatic link library for the libjpeg API\n\n**libjpeg-{version}.dll**<br>\nDLL for the libjpeg API\n\n**libjpeg.dll.a**<br>\nImport library for the libjpeg API\n\n**libturbojpeg.a**<br>\nStatic link library for the TurboJPEG API\n\n**libturbojpeg.dll**<br>\nDLL for the TurboJPEG API\n\n**libturbojpeg.dll.a**<br>\nImport library for the TurboJPEG API\n\n*{version}* is 62, 7, or 8, depending on whether libjpeg v6b (default), v7, or\nv8 emulation is enabled.\n\n\n### Debug Build\n\nAdd `-DCMAKE_BUILD_TYPE=Debug` to the CMake command line.  Or, if building\nwith NMake, remove `-DCMAKE_BUILD_TYPE=Release` (Debug builds are the default\nwith NMake.)\n\n\n### libjpeg v7 or v8 API/ABI Emulation\n\nAdd `-DWITH_JPEG7=1` to the CMake command line to build a version of\nlibjpeg-turbo that is API/ABI-compatible with libjpeg v7.  Add `-DWITH_JPEG8=1`\nto the CMake command line to build a version of libjpeg-turbo that is\nAPI/ABI-compatible with libjpeg v8.  See [README.md](README.md) for more\ninformation about libjpeg v7 and v8 emulation.\n\n\n### Arithmetic Coding Support\n\nSince the patent on arithmetic coding has expired, this functionality has been\nincluded in this release of libjpeg-turbo.  libjpeg-turbo's implementation is\nbased on the implementation in libjpeg v8, but it works when emulating libjpeg\nv7 or v6b as well.  The default is to enable both arithmetic encoding and\ndecoding, but those who have philosophical objections to arithmetic coding can\nadd `-DWITH_ARITH_ENC=0` or `-DWITH_ARITH_DEC=0` to the CMake command line to\ndisable encoding or decoding (respectively.)\n\n\n### TurboJPEG Java Wrapper\n\nAdd `-DWITH_JAVA=1` to the CMake command line to incorporate an optional Java\nNative Interface (JNI) wrapper into the TurboJPEG shared library and build the\nJava front-end classes to support it.  This allows the TurboJPEG shared library\nto be used directly from Java applications.  See [java/README](java/README) for\nmore details.\n\nIf Java is not in your `PATH`, or if you wish to use an alternate JDK to\nbuild/test libjpeg-turbo, then (prior to running CMake) set the `JAVA_HOME`\nenvironment variable to the location of the JDK that you wish to use.  The\n`Java_JAVAC_EXECUTABLE`, `Java_JAVA_EXECUTABLE`, and `Java_JAR_EXECUTABLE`\nCMake variables can also be used to specify alternate commands or locations for\njavac, jar, and java (respectively.)  You can also set the\n`CMAKE_JAVA_COMPILE_FLAGS` CMake variable or the `JAVAFLAGS` environment\nvariable to specify arguments that should be passed to the Java compiler when\nbuilding the TurboJPEG classes, and the `JAVAARGS` CMake variable to specify\narguments that should be passed to the JRE when running the TurboJPEG Java unit\ntests.\n\n\nBuild Recipes\n-------------\n\n\n### 32-bit Build on 64-bit Linux/Unix\n\nUse export/setenv to set the following environment variables before running\nCMake:\n\n    CFLAGS=-m32\n    LDFLAGS=-m32\n\n\n### 64-bit Build on Solaris\n\nUse export/setenv to set the following environment variables before running\nCMake:\n\n    CFLAGS=-m64\n    LDFLAGS=-m64\n\n\n### Other Compilers\n\nOn Un*x systems, prior to running CMake, you can set the `CC` environment\nvariable to the command used to invoke the C compiler.\n\n\n### 32-bit MinGW Build on Un*x (including Mac and Cygwin)\n\nCreate a file called **toolchain.cmake** under *{build_directory}*, with the\nfollowing contents:\n\n    set(CMAKE_SYSTEM_NAME Windows)\n    set(CMAKE_SYSTEM_PROCESSOR X86)\n    set(CMAKE_C_COMPILER {mingw_binary_path}/i686-w64-mingw32-gcc)\n    set(CMAKE_RC_COMPILER {mingw_binary_path}/i686-w64-mingw32-windres)\n\n*{mingw\\_binary\\_path}* is the directory under which the MinGW binaries are\nlocated (usually **/usr/bin**.)  Next, execute the following commands:\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \\\n      -DCMAKE_INSTALL_PREFIX={install_path} \\\n      [additional CMake flags] {source_directory}\n    make\n\n*{install\\_path}* is the path under which the libjpeg-turbo binaries should be\ninstalled.\n\n\n### 64-bit MinGW Build on Un*x (including Mac and Cygwin)\n\nCreate a file called **toolchain.cmake** under *{build_directory}*, with the\nfollowing contents:\n\n    set(CMAKE_SYSTEM_NAME Windows)\n    set(CMAKE_SYSTEM_PROCESSOR AMD64)\n    set(CMAKE_C_COMPILER {mingw_binary_path}/x86_64-w64-mingw32-gcc)\n    set(CMAKE_RC_COMPILER {mingw_binary_path}/x86_64-w64-mingw32-windres)\n\n*{mingw\\_binary\\_path}* is the directory under which the MinGW binaries are\nlocated (usually **/usr/bin**.)  Next, execute the following commands:\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \\\n      -DCMAKE_INSTALL_PREFIX={install_path} \\\n      [additional CMake flags] {source_directory}\n    make\n\n*{install\\_path}* is the path under which the libjpeg-turbo binaries should be\ninstalled.\n\n\nBuilding libjpeg-turbo for iOS\n------------------------------\n\niOS platforms, such as the iPhone and iPad, use Arm processors, and all\ncurrently supported models include Neon instructions.  Thus, they can take\nadvantage of libjpeg-turbo's SIMD extensions to significantly accelerate JPEG\ncompression/decompression.  This section describes how to build libjpeg-turbo\nfor these platforms.\n\n\n### Armv8 (64-bit)\n\n**Xcode 5 or later required, Xcode 6.3.x or later recommended**\n\nThe following script demonstrates how to build libjpeg-turbo to run on the\niPhone 5S/iPad Mini 2/iPad Air and newer.\n\n    IOS_PLATFORMDIR=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform\n    IOS_SYSROOT=($IOS_PLATFORMDIR/Developer/SDKs/iPhoneOS*.sdk)\n    export CFLAGS=\"-Wall -miphoneos-version-min=8.0 -funwind-tables\"\n\n    cd {build_directory}\n\n    cmake -G\"Unix Makefiles\" \\\n      -DCMAKE_C_COMPILER=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang \\\n      -DCMAKE_OSX_ARCHITECTURES=arm64 \\\n      -DCMAKE_OSX_SYSROOT=${IOS_SYSROOT[0]} \\\n      [additional CMake flags] {source_directory}\n    make\n\nReplace `iPhoneOS` with `iPhoneSimulator` and `-miphoneos-version-min` with\n`-miphonesimulator-version-min` to build libjpeg-turbo for the iOS simulator on\nMacs with Apple silicon CPUs.\n\n\nBuilding libjpeg-turbo for Android\n----------------------------------\n\nBuilding libjpeg-turbo for Android platforms requires v13b or later of the\n[Android NDK](https://developer.android.com/ndk).\n\n\n### Armv7 (32-bit)\n\n**NDK r19 or later with Clang recommended**\n\nThe following is a general recipe script that can be modified for your specific\nneeds.\n\n    # Set these variables to suit your needs\n    NDK_PATH={full path to the NDK directory-- for example,\n      /opt/android/android-ndk-r16b}\n    TOOLCHAIN={\"gcc\" or \"clang\"-- \"gcc\" must be used with NDK r16b and earlier,\n      and \"clang\" must be used with NDK r17c and later}\n    ANDROID_VERSION={the minimum version of Android to support-- for example,\n      \"16\", \"19\", etc.}\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" \\\n      -DANDROID_ABI=armeabi-v7a \\\n      -DANDROID_ARM_MODE=arm \\\n      -DANDROID_PLATFORM=android-${ANDROID_VERSION} \\\n      -DANDROID_TOOLCHAIN=${TOOLCHAIN} \\\n      -DCMAKE_ASM_FLAGS=\"--target=arm-linux-androideabi${ANDROID_VERSION}\" \\\n      -DCMAKE_TOOLCHAIN_FILE=${NDK_PATH}/build/cmake/android.toolchain.cmake \\\n      [additional CMake flags] {source_directory}\n    make\n\n\n### Armv8 (64-bit)\n\n**Clang recommended**\n\nThe following is a general recipe script that can be modified for your specific\nneeds.\n\n    # Set these variables to suit your needs\n    NDK_PATH={full path to the NDK directory-- for example,\n      /opt/android/android-ndk-r16b}\n    TOOLCHAIN={\"gcc\" or \"clang\"-- \"gcc\" must be used with NDK r14b and earlier,\n      and \"clang\" must be used with NDK r17c and later}\n    ANDROID_VERSION={the minimum version of Android to support.  \"21\" or later\n      is required for a 64-bit build.}\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" \\\n      -DANDROID_ABI=arm64-v8a \\\n      -DANDROID_ARM_MODE=arm \\\n      -DANDROID_PLATFORM=android-${ANDROID_VERSION} \\\n      -DANDROID_TOOLCHAIN=${TOOLCHAIN} \\\n      -DCMAKE_ASM_FLAGS=\"--target=aarch64-linux-android${ANDROID_VERSION}\" \\\n      -DCMAKE_TOOLCHAIN_FILE=${NDK_PATH}/build/cmake/android.toolchain.cmake \\\n      [additional CMake flags] {source_directory}\n    make\n\n\n### x86 (32-bit)\n\nThe following is a general recipe script that can be modified for your specific\nneeds.\n\n    # Set these variables to suit your needs\n    NDK_PATH={full path to the NDK directory-- for example,\n      /opt/android/android-ndk-r16b}\n    TOOLCHAIN={\"gcc\" or \"clang\"-- \"gcc\" must be used with NDK r14b and earlier,\n      and \"clang\" must be used with NDK r17c and later}\n    ANDROID_VERSION={The minimum version of Android to support-- for example,\n      \"16\", \"19\", etc.}\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" \\\n      -DANDROID_ABI=x86 \\\n      -DANDROID_PLATFORM=android-${ANDROID_VERSION} \\\n      -DANDROID_TOOLCHAIN=${TOOLCHAIN} \\\n      -DCMAKE_TOOLCHAIN_FILE=${NDK_PATH}/build/cmake/android.toolchain.cmake \\\n      [additional CMake flags] {source_directory}\n    make\n\n\n### x86-64 (64-bit)\n\nThe following is a general recipe script that can be modified for your specific\nneeds.\n\n    # Set these variables to suit your needs\n    NDK_PATH={full path to the NDK directory-- for example,\n      /opt/android/android-ndk-r16b}\n    TOOLCHAIN={\"gcc\" or \"clang\"-- \"gcc\" must be used with NDK r14b and earlier,\n      and \"clang\" must be used with NDK r17c and later}\n    ANDROID_VERSION={the minimum version of Android to support.  \"21\" or later\n      is required for a 64-bit build.}\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" \\\n      -DANDROID_ABI=x86_64 \\\n      -DANDROID_PLATFORM=android-${ANDROID_VERSION} \\\n      -DANDROID_TOOLCHAIN=${TOOLCHAIN} \\\n      -DCMAKE_TOOLCHAIN_FILE=${NDK_PATH}/build/cmake/android.toolchain.cmake \\\n      [additional CMake flags] {source_directory}\n    make\n\n\nAdvanced CMake Options\n----------------------\n\nTo list and configure other CMake options not specifically mentioned in this\nguide, run\n\n    ccmake {source_directory}\n\nor\n\n    cmake-gui {source_directory}\n\nfrom the build directory after initially configuring the build.  CCMake is a\ntext-based interactive version of CMake, and CMake-GUI is a GUI version.  Both\nwill display all variables that are relevant to the libjpeg-turbo build, their\ncurrent values, and a help string describing what they do.\n\n\nInstalling libjpeg-turbo\n========================\n\nYou can use the build system to install libjpeg-turbo (as opposed to creating\nan installer package.)  To do this, run `make install` or `nmake install`\n(or build the \"install\" target in the Visual Studio IDE.)  Running\n`make uninstall` or `nmake uninstall` (or building the \"uninstall\" target in\nthe Visual Studio IDE) will uninstall libjpeg-turbo.\n\nThe `CMAKE_INSTALL_PREFIX` CMake variable can be modified in order to install\nlibjpeg-turbo into a directory of your choosing.  If you don't specify\n`CMAKE_INSTALL_PREFIX`, then the default is:\n\n**c:\\libjpeg-turbo**<br>\nVisual Studio 32-bit build\n\n**c:\\libjpeg-turbo64**<br>\nVisual Studio 64-bit build\n\n**c:\\libjpeg-turbo-gcc**<br>\nMinGW 32-bit build\n\n**c:\\libjpeg-turbo-gcc64**<br>\nMinGW 64-bit build\n\n**/opt/libjpeg-turbo**<br>\nUn*x\n\nThe default value of `CMAKE_INSTALL_PREFIX` causes the libjpeg-turbo files to\nbe installed with a directory structure resembling that of the official\nlibjpeg-turbo binary packages.  Changing the value of `CMAKE_INSTALL_PREFIX`\n(for instance, to **/usr/local**) causes the libjpeg-turbo files to be\ninstalled with a directory structure that conforms to GNU standards.\n\nThe `CMAKE_INSTALL_BINDIR`, `CMAKE_INSTALL_DATAROOTDIR`,\n`CMAKE_INSTALL_DOCDIR`, `CMAKE_INSTALL_INCLUDEDIR`, `CMAKE_INSTALL_JAVADIR`,\n`CMAKE_INSTALL_LIBDIR`, and `CMAKE_INSTALL_MANDIR` CMake variables allow a\nfiner degree of control over where specific files in the libjpeg-turbo\ndistribution should be installed.  These directory variables can either be\nspecified as absolute paths or as paths relative to `CMAKE_INSTALL_PREFIX` (for\ninstance, setting `CMAKE_INSTALL_DOCDIR` to **doc** would cause the\ndocumentation to be installed in **${CMAKE\\_INSTALL\\_PREFIX}/doc**.)  If a\ndirectory variable contains the name of another directory variable in angle\nbrackets, then its final value will depend on the final value of that other\nvariable.  For instance, the default value of `CMAKE_INSTALL_MANDIR` is\n**\\<CMAKE\\_INSTALL\\_DATAROOTDIR\\>/man**.\n\n\nCreating Distribution Packages\n==============================\n\nThe following commands can be used to create various types of distribution\npackages:\n\n\nLinux\n-----\n\n    make rpm\n\nCreate Red Hat-style binary RPM package.  Requires RPM v4 or later.\n\n    make srpm\n\nThis runs `make dist` to create a pristine source tarball, then creates a\nRed Hat-style source RPM package from the tarball.  Requires RPM v4 or later.\n\n    make deb\n\nCreate Debian-style binary package.  Requires dpkg.\n\n\nMac\n---\n\n    make dmg\n\nCreate Mac package/disk image.  This requires pkgbuild and productbuild, which\nare installed by default on OS X/macOS 10.7 and later.\n\nIn order to create a Mac package/disk image that contains universal\nx86-64/Arm binaries, set the following CMake variable:\n\n* `SECONDARY_BUILD`: Directory containing a cross-compiled x86-64 or Armv8\n  (64-bit) iOS or macOS build of libjpeg-turbo to include in the universal\n  binaries\n\nYou should first use CMake to configure the cross-compiled x86-64 or Armv8\nsecondary build of libjpeg-turbo (see \"Building libjpeg-turbo for iOS\" above,\nif applicable) in a build directory that matches the one specified in the\naforementioned CMake variable.  Next, configure the primary (native) build of\nlibjpeg-turbo as an out-of-tree build, specifying the aforementioned CMake\nvariable, and build it.  Once the primary build has been built, run `make dmg`\nfrom the build directory.  The packaging system will build the secondary build,\nuse lipo to combine it with the primary build into a single set of universal\nbinaries, then package the universal binaries.\n\n\nWindows\n-------\n\nIf using NMake:\n\n    cd {build_directory}\n    nmake installer\n\nIf using MinGW:\n\n    cd {build_directory}\n    make installer\n\nIf using the Visual Studio IDE, build the \"installer\" target.\n\nThe installer package (libjpeg-turbo-*{version}*[-gcc|-vc][64].exe) will be\nlocated under *{build_directory}*.  If building using the Visual Studio IDE,\nthen the installer package will be located in a subdirectory with the same name\nas the configuration you built (such as *{build_directory}*\\Debug\\ or\n*{build_directory}*\\Release\\).\n\nBuilding a Windows installer requires the\n[Nullsoft Install System](https://nsis.sourceforge.io).  makensis.exe should\nbe in your `PATH`.\n\n\nRegression testing\n==================\n\nThe most common way to test libjpeg-turbo is by invoking `make test` (Un*x) or\n`nmake test` (Windows command line) or by building the \"RUN_TESTS\" target\n(Visual Studio IDE), once the build has completed.  This runs a series of tests\nto ensure that mathematical compatibility has been maintained between\nlibjpeg-turbo and libjpeg v6b.  This also invokes the TurboJPEG unit tests,\nwhich ensure that the colorspace extensions, YUV encoding, decompression\nscaling, and other features of the TurboJPEG C and Java APIs are working\nproperly (and, by extension, that the equivalent features of the underlying\nlibjpeg API are also working.)\n\nInvoking `make testclean` (Un*x) or `nmake testclean` (Windows command line) or\nbuilding the \"testclean\" target (Visual Studio IDE) will clean up the output\nimages generated by the tests.\n\nOn Un*x platforms, more extensive tests of the TurboJPEG C and Java wrappers\ncan be run by invoking `make tjtest`.  These extended TurboJPEG tests\nessentially iterate through all of the available features of the TurboJPEG APIs\nthat are not covered by the TurboJPEG unit tests (including the lossless\ntransform options) and compare the images generated by each feature to images\ngenerated using the equivalent feature in the libjpeg API.  The extended\nTurboJPEG tests are meant to test for regressions in the TurboJPEG wrappers,\nnot in the underlying libjpeg API library.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 78.4453125,
          "content": "cmake_minimum_required(VERSION 2.8.12...3.28)\n\nif(CMAKE_EXECUTABLE_SUFFIX)\n  set(CMAKE_EXECUTABLE_SUFFIX_TMP ${CMAKE_EXECUTABLE_SUFFIX})\nendif()\n\nproject(mozjpeg C)\nset(VERSION 5.0.0)\nset(COPYRIGHT_YEAR \"1991-2024\")\nstring(REPLACE \".\" \";\" VERSION_TRIPLET ${VERSION})\nlist(GET VERSION_TRIPLET 0 VERSION_MAJOR)\nlist(GET VERSION_TRIPLET 1 VERSION_MINOR)\nlist(GET VERSION_TRIPLET 2 VERSION_REVISION)\nfunction(pad_number NUMBER OUTPUT_LEN)\n  string(LENGTH \"${${NUMBER}}\" INPUT_LEN)\n  if(INPUT_LEN LESS OUTPUT_LEN)\n    math(EXPR ZEROES \"${OUTPUT_LEN} - ${INPUT_LEN} - 1\")\n    set(NUM ${${NUMBER}})\n    foreach(C RANGE ${ZEROES})\n      set(NUM \"0${NUM}\")\n    endforeach()\n    set(${NUMBER} ${NUM} PARENT_SCOPE)\n  endif()\nendfunction()\nset(TMP_VERSION_MINOR ${VERSION_MINOR})\nset(TMP_VERSION_REVISION ${VERSION_REVISION})\npad_number(TMP_VERSION_MINOR 3)\npad_number(TMP_VERSION_REVISION 3)\nset(LIBJPEG_TURBO_VERSION_NUMBER\n  ${VERSION_MAJOR}${TMP_VERSION_MINOR}${TMP_VERSION_REVISION})\nset(MSVC_LIKE 0)\nif(MSVC OR CMAKE_C_SIMULATE_ID STREQUAL \"MSVC\")\n  set(MSVC_LIKE 1)\nendif()\n\n# The libjpeg-turbo build system has never supported and will never support\n# being integrated into another build system using add_subdirectory(), because\n# doing so would require that we (minimally):\n#\n# 1. avoid using certain CMake variables, such as CMAKE_SOURCE_DIR,\n#    CMAKE_BINARY_DIR, and CMAKE_PROJECT_NAME;\n# 2. avoid using implicit include directories and relative paths;\n# 3. optionally provide a way to skip the installation of libjpeg-turbo\n#    components when the 'install' target is built;\n# 4. optionally provide a way to postfix target names, to avoid namespace\n#    conflicts;\n# 5. restructure the top-level CMakeLists.txt so that it properly sets the\n#    PROJECT_VERSION variable; and\n# 6. design automated regression tests to ensure that new commits don't break\n#    any of the above.\n#\n# Even if we did all of that, issues would still arise, because it is\n# impossible for an upstream build system to anticipate the widely varying\n# needs of every downstream build system.  That's why the CMake\n# ExternalProject_Add() function exists.  Downstream projects that wish to\n# integrate libjpeg-turbo as a subdirectory should either use\n# ExternalProject_Add() or make downstream modifications to the libjpeg-turbo\n# build system to suit their specific needs.  Please do not file bug reports,\n# feature requests, or pull requests regarding this.\nif(NOT CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)\n  message(FATAL_ERROR \"The libjpeg-turbo build system cannot be integrated into another build system using add_subdirectory().  Use ExternalProject_Add() instead.\")\nendif()\n\n# CMake 3.14 and later sets CMAKE_MACOSX_BUNDLE to TRUE by default when\n# CMAKE_SYSTEM_NAME is iOS, tvOS, or watchOS, which breaks the libjpeg-turbo\n# build.  (Specifically, when CMAKE_MACOSX_BUNDLE is TRUE, executables for\n# Apple platforms are built as application bundles, which causes CMake to\n# complain that our install() directives for executables do not specify a\n# BUNDLE DESTINATION.  Even if CMake did not complain, building executables as\n# application bundles would break our iOS packages.)\nset(CMAKE_MACOSX_BUNDLE FALSE)\n\nget_property(GENERATOR_IS_MULTI_CONFIG GLOBAL PROPERTY\n  GENERATOR_IS_MULTI_CONFIG)\n# If the GENERATOR_IS_MULTI_CONFIG property doesn't exist (CMake < 3.9), then\n# set the GENERATOR_IS_MULTI_CONFIG variable manually if the generator is\n# Visual Studio or Xcode (the only multi-config generators in CMake < 3.9).\nif(NOT GENERATOR_IS_MULTI_CONFIG AND (MSVC_IDE OR XCODE))\n  set(GENERATOR_IS_MULTI_CONFIG TRUE)\nendif()\n\nstring(TIMESTAMP DEFAULT_BUILD \"%Y%m%d\")\nset(BUILD ${DEFAULT_BUILD} CACHE STRING \"Build string (default: ${DEFAULT_BUILD})\")\n\n# NOTE: On Windows, this does nothing except when using MinGW or Cygwin.\n# CMAKE_BUILD_TYPE has no meaning in Visual Studio, and it always defaults to\n# Debug when using NMake.\nif(NOT CMAKE_BUILD_TYPE)\n  set(CMAKE_BUILD_TYPE Release)\nendif()\nmessage(STATUS \"CMAKE_BUILD_TYPE = ${CMAKE_BUILD_TYPE}\")\n\nmessage(STATUS \"VERSION = ${VERSION}, BUILD = ${BUILD}\")\n\ninclude(cmakescripts/PackageInfo.cmake)\n\n# Detect CPU type and whether we're building 64-bit or 32-bit code\nmath(EXPR BITS \"${CMAKE_SIZEOF_VOID_P} * 8\")\nstring(TOLOWER ${CMAKE_SYSTEM_PROCESSOR} CMAKE_SYSTEM_PROCESSOR_LC)\nset(COUNT 1)\nforeach(ARCH ${CMAKE_OSX_ARCHITECTURES})\n  if(COUNT GREATER 1)\n    message(FATAL_ERROR \"libjpeg-turbo contains assembly code, so it cannot be built with multiple values in CMAKE_OSX_ARCHITECTURES.\")\n  endif()\n  math(EXPR COUNT \"${COUNT}+1\")\nendforeach()\nif(CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"x86_64\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"amd64\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"i[0-9]86\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"x86\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"ia32\")\n  if(BITS EQUAL 64 OR CMAKE_C_COMPILER_ABI MATCHES \"ELF X32\")\n    set(CPU_TYPE x86_64)\n  else()\n    set(CPU_TYPE i386)\n  endif()\n  if(NOT CMAKE_SYSTEM_PROCESSOR STREQUAL ${CPU_TYPE})\n    set(CMAKE_SYSTEM_PROCESSOR ${CPU_TYPE})\n  endif()\nelseif(CMAKE_SYSTEM_PROCESSOR_LC STREQUAL \"aarch64\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"^arm\")\n  if(BITS EQUAL 64)\n    set(CPU_TYPE arm64)\n  else()\n    set(CPU_TYPE arm)\n  endif()\nelseif(CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"^ppc\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"^powerpc\")\n  set(CPU_TYPE powerpc)\nelse()\n  set(CPU_TYPE ${CMAKE_SYSTEM_PROCESSOR_LC})\nendif()\nif(CMAKE_OSX_ARCHITECTURES MATCHES \"x86_64\" OR\n  CMAKE_OSX_ARCHITECTURES MATCHES \"arm64\" OR\n  CMAKE_OSX_ARCHITECTURES MATCHES \"i386\")\n  set(CPU_TYPE ${CMAKE_OSX_ARCHITECTURES})\nendif()\nif(CMAKE_OSX_ARCHITECTURES MATCHES \"ppc\")\n  set(CPU_TYPE powerpc)\nendif()\nif(MSVC_IDE AND CMAKE_GENERATOR_PLATFORM MATCHES \"arm64\")\n  set(CPU_TYPE arm64)\nendif()\n\nmessage(STATUS \"${BITS}-bit build (${CPU_TYPE})\")\n\n\n###############################################################################\n# INSTALL DIRECTORIES\n###############################################################################\n\nif(WIN32)\n  if(MSVC_LIKE)\n    set(CMAKE_INSTALL_DEFAULT_PREFIX \"c:/${CMAKE_PROJECT_NAME}\")\n  else()\n    set(CMAKE_INSTALL_DEFAULT_PREFIX \"c:/${CMAKE_PROJECT_NAME}-gcc\")\n  endif()\n  if(BITS EQUAL 64)\n    set(CMAKE_INSTALL_DEFAULT_PREFIX \"${CMAKE_INSTALL_DEFAULT_PREFIX}64\")\n  endif()\nelse()\n  if(NOT CMAKE_INSTALL_DEFAULT_PREFIX)\n    set(CMAKE_INSTALL_DEFAULT_PREFIX /opt/${CMAKE_PROJECT_NAME})\n  endif()\nendif()\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${CMAKE_INSTALL_DEFAULT_PREFIX}\" CACHE PATH\n    \"Directory into which to install ${CMAKE_PROJECT_NAME} (default: ${CMAKE_INSTALL_DEFAULT_PREFIX})\"\n    FORCE)\nendif()\nmessage(STATUS \"CMAKE_INSTALL_PREFIX = ${CMAKE_INSTALL_PREFIX}\")\n\n# When the prefix is /opt/${CMAKE_PROJECT_NAME}, we assume that an \"official\"\n# build is being created, and thus we install things into specific locations.\n\nif(CMAKE_INSTALL_PREFIX STREQUAL \"${CMAKE_INSTALL_DEFAULT_PREFIX}\")\n  set(CMAKE_INSTALL_DEFAULT_DATAROOTDIR \"\")\n  set(CMAKE_INSTALL_DEFAULT_DOCDIR \"<CMAKE_INSTALL_DATAROOTDIR>/doc\")\n  set(CMAKE_INSTALL_DEFAULT_JAVADIR \"<CMAKE_INSTALL_DATAROOTDIR>/classes\")\n  if(UNIX AND NOT APPLE)\n    if(BITS EQUAL 64)\n      set(CMAKE_INSTALL_DEFAULT_LIBDIR \"lib64\")\n    elseif(CMAKE_C_COMPILER_ABI MATCHES \"ELF X32\")\n      set(CMAKE_INSTALL_DEFAULT_LIBDIR \"libx32\")\n    else()\n      set(CMAKE_INSTALL_DEFAULT_LIBDIR \"lib32\")\n    endif()\n  endif()\nendif()\n\ninclude(cmakescripts/GNUInstallDirs.cmake)\n\nmacro(report_directory var)\n  if(CMAKE_INSTALL_${var} STREQUAL CMAKE_INSTALL_FULL_${var})\n    message(STATUS \"CMAKE_INSTALL_${var} = ${CMAKE_INSTALL_${var}}\")\n  else()\n    message(STATUS \"CMAKE_INSTALL_${var} = ${CMAKE_INSTALL_${var}} (${CMAKE_INSTALL_FULL_${var}})\")\n  endif()\n  mark_as_advanced(CLEAR CMAKE_INSTALL_${var})\nendmacro()\n\nset(DIRLIST \"BINDIR;DATAROOTDIR;DOCDIR;INCLUDEDIR;LIBDIR\")\nif(UNIX)\n  list(APPEND DIRLIST \"MANDIR\")\nendif()\nforeach(dir ${DIRLIST})\n  report_directory(${dir})\nendforeach()\n\n\n###############################################################################\n# CONFIGURATION OPTIONS\n###############################################################################\n\nmacro(boolean_number var)\n  if(${var})\n    set(${var} 1 ${ARGN})\n  else()\n    set(${var} 0 ${ARGN})\n  endif()\nendmacro()\n\noption(BUILD_SHARED_LIBS \"Build shared libraries\" TRUE)\nboolean_number(BUILD_SHARED_LIBS)\noption(REQUIRE_SIMD\n  \"Generate a fatal error if SIMD extensions are not available for this platform (default is to fall back to a non-SIMD build)\"\n  FALSE)\nboolean_number(REQUIRE_SIMD)\noption(PNG_SUPPORTED \"Enable PNG support (requires libpng)\" TRUE)\nboolean_number(PNG_SUPPORTED)\noption(WITH_ARITH_DEC\n  \"Include arithmetic decoding support when emulating the libjpeg v6b API/ABI\"\n  FALSE)\nboolean_number(WITH_ARITH_DEC)\noption(WITH_ARITH_ENC\n  \"Include arithmetic encoding support when emulating the libjpeg v6b API/ABI\"\n  FALSE)\nboolean_number(WITH_ARITH_ENC)\nif(CMAKE_C_COMPILER_ABI MATCHES \"ELF X32\")\n  set(WITH_JAVA 0)\nelse()\n  option(WITH_JAVA\n    \"Build Java wrapper for the TurboJPEG API library (implies BUILD_SHARED_LIBS=1)\"\n    FALSE)\n  boolean_number(WITH_JAVA)\nendif()\noption(WITH_JPEG7\n  \"Emulate libjpeg v7 API/ABI (this makes ${CMAKE_PROJECT_NAME} backward-incompatible with libjpeg v6b)\"\n  FALSE)\nboolean_number(WITH_JPEG7)\noption(WITH_JPEG8\n  \"Emulate libjpeg v8 API/ABI (this makes ${CMAKE_PROJECT_NAME} backward-incompatible with libjpeg v6b)\"\n  FALSE)\nboolean_number(WITH_JPEG8)\noption(WITH_SIMD \"Include SIMD extensions, if available for this platform\" TRUE)\nboolean_number(WITH_SIMD)\noption(WITH_TURBOJPEG\n  \"Include the TurboJPEG API library and associated test programs\" TRUE)\nboolean_number(WITH_TURBOJPEG)\noption(WITH_FUZZ \"Build fuzz targets\" FALSE)\n\nmacro(report_option var desc)\n  if(${var})\n    message(STATUS \"${desc} enabled (${var} = ${${var}})\")\n  else()\n    message(STATUS \"${desc} disabled (${var} = ${${var}})\")\n  endif()\nendmacro()\n\nif(WITH_JAVA)\n  set(BUILD_SHARED_LIBS 1)\nendif()\n\n# Explicitly setting CMAKE_POSITION_INDEPENDENT_CODE=FALSE disables PIC for all\n# targets, which will cause the shared library builds to fail.  Thus, if shared\n# libraries are enabled and CMAKE_POSITION_INDEPENDENT_CODE is explicitly set\n# to FALSE, we need to unset it, thus restoring the default behavior\n# (automatically using PIC for shared library targets.)\nif(DEFINED CMAKE_POSITION_INDEPENDENT_CODE AND\n  NOT CMAKE_POSITION_INDEPENDENT_CODE AND BUILD_SHARED_LIBS)\n  unset(CMAKE_POSITION_INDEPENDENT_CODE CACHE)\nendif()\n\nreport_option(BUILD_SHARED_LIBS \"Shared libraries\")\n\nif(BUILD_SHARED_LIBS)\n  set(CMAKE_INSTALL_RPATH ${CMAKE_INSTALL_FULL_LIBDIR})\nendif()\n\nif(WITH_JPEG8 OR WITH_JPEG7)\n  set(WITH_ARITH_ENC 1)\n  set(WITH_ARITH_DEC 1)\nendif()\n\nif(WITH_ARITH_DEC)\n  set(D_ARITH_CODING_SUPPORTED 1)\nendif()\nreport_option(WITH_ARITH_DEC \"Arithmetic decoding support\")\n\nif(WITH_ARITH_ENC)\n  set(C_ARITH_CODING_SUPPORTED 1)\nendif()\nreport_option(WITH_ARITH_ENC \"Arithmetic encoding support\")\n\nreport_option(WITH_TURBOJPEG \"TurboJPEG API library\")\nreport_option(WITH_JAVA \"TurboJPEG Java wrapper\")\n\nif(NOT WITH_JPEG8)\n  set(MEM_SRCDST_FUNCTIONS \"global:  jpeg_mem_dest;  jpeg_mem_src;\")\nendif()\n\n# 0: Original libjpeg v6b/v7/v8 API/ABI\n#\n# libjpeg v6b/v7 API/ABI emulation:\n# 1: + In-memory source/destination managers (libjpeg-turbo 1.3.x)\n# 2: + Partial image decompression functions (libjpeg-turbo 1.5.x)\n# 3: + ICC functions (libjpeg-turbo 2.0.x)\n# 4: + 12-bit-per-sample and lossless functions (libjpeg-turbo 3.0.x)\n#\n# libjpeg v8 API/ABI emulation:\n# 1: + Partial image decompression functions (libjpeg-turbo 1.5.x)\n# 2: + ICC functions (libjpeg-turbo 2.0.x)\n# 3: + 12-bit-per-sample and lossless functions (libjpeg-turbo 3.0.x)\nset(SO_AGE 3)\nif(NOT WITH_JPEG8)\n  set(SO_AGE 4)\nendif()\n\nif(WITH_JPEG8)\n  set(JPEG_LIB_VERSION 80)\nelseif(WITH_JPEG7)\n  set(JPEG_LIB_VERSION 70)\nelse()\n  set(JPEG_LIB_VERSION 62)\nendif()\n\nmath(EXPR JPEG_LIB_VERSION_DIV10 \"${JPEG_LIB_VERSION} / 10\")\nmath(EXPR JPEG_LIB_VERSION_MOD10 \"${JPEG_LIB_VERSION} % 10\")\nif(JPEG_LIB_VERSION STREQUAL \"62\")\n  set(DEFAULT_SO_MAJOR_VERSION ${JPEG_LIB_VERSION})\nelse()\n  set(DEFAULT_SO_MAJOR_VERSION ${JPEG_LIB_VERSION_DIV10})\nendif()\nif(JPEG_LIB_VERSION STREQUAL \"80\")\n  set(DEFAULT_SO_MINOR_VERSION 2)\nelse()\n  set(DEFAULT_SO_MINOR_VERSION 0)\nendif()\n\n# This causes SO_MAJOR_VERSION/SO_MINOR_VERSION to reset to defaults if\n# WITH_JPEG7 or WITH_JPEG8 has changed.\nif((DEFINED WITH_JPEG7_INT AND NOT WITH_JPEG7 EQUAL WITH_JPEG7_INT) OR\n  (DEFINED WITH_JPEG8_INT AND NOT WITH_JPEG8 EQUAL WITH_JPEG8_INT))\n  set(FORCE_SO_VERSION \"FORCE\")\nendif()\nset(WITH_JPEG7_INT ${WITH_JPEG7} CACHE INTERNAL \"\")\nset(WITH_JPEG8_INT ${WITH_JPEG8} CACHE INTERNAL \"\")\n\nset(SO_MAJOR_VERSION ${DEFAULT_SO_MAJOR_VERSION} CACHE STRING\n  \"Major version of the libjpeg API shared library (default: ${DEFAULT_SO_MAJOR_VERSION})\"\n  ${FORCE_SO_VERSION})\nset(SO_MINOR_VERSION ${DEFAULT_SO_MINOR_VERSION} CACHE STRING\n  \"Minor version of the libjpeg API shared library (default: ${DEFAULT_SO_MINOR_VERSION})\"\n  ${FORCE_SO_VERSION})\n\nset(JPEG_LIB_VERSION_DECIMAL \"${JPEG_LIB_VERSION_DIV10}.${JPEG_LIB_VERSION_MOD10}\")\nmessage(STATUS \"Emulating libjpeg API/ABI v${JPEG_LIB_VERSION_DECIMAL} (WITH_JPEG7 = ${WITH_JPEG7}, WITH_JPEG8 = ${WITH_JPEG8})\")\nmessage(STATUS \"libjpeg API shared library version = ${SO_MAJOR_VERSION}.${SO_AGE}.${SO_MINOR_VERSION}\")\n\n# Because the TurboJPEG API library uses versioned symbols and changes the\n# names of functions whenever they are modified in a backward-incompatible\n# manner, it is always backward-ABI-compatible with itself, so the major and\n# minor SO versions don't change.  However, we increase the middle number (the\n# SO \"age\") whenever functions are added to the API, because adding functions\n# affects forward API/ABI compatibility.\nset(TURBOJPEG_SO_MAJOR_VERSION 0)\n# 0: TurboJPEG 1.3.x API\n# 1: TurboJPEG 1.4.x API\n#    The TurboJPEG 1.5.x API modified some of the function prototypes, adding\n#    the const keyword in front of pointers to unmodified buffers, but that did\n#    not affect forward API/ABI compatibility.\n# 2: TurboJPEG 2.0.x API\n#    The TurboJPEG 2.1.x API modified the behavior of the tjDecompressHeader3()\n#    function so that it accepts \"abbreviated table specification\" (AKA\n#    \"tables-only\") datastreams as well as JPEG images, but that did not affect\n#    forward API/ABI compatibility.\n# 3: TurboJPEG 3 API\nset(TURBOJPEG_SO_AGE 3)\nset(TURBOJPEG_SO_VERSION 0.${TURBOJPEG_SO_AGE}.0)\n\n\n###############################################################################\n# COMPILER SETTINGS\n###############################################################################\n\nstring(TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE_UC)\n\nif(MSVC_LIKE)\n  option(WITH_CRT_DLL\n    \"Link all ${CMAKE_PROJECT_NAME} libraries and executables with the C run-time DLL (msvcr*.dll) instead of the static C run-time library (libcmt*.lib.)  The default is to use the C run-time DLL only with the libraries and executables that need it.\"\n    FALSE)\n  boolean_number(WITH_CRT_DLL)\n  if(NOT WITH_CRT_DLL)\n    # Use the static C library for all build types\n    if(CMAKE_VERSION VERSION_EQUAL \"3.15\" OR\n      CMAKE_VERSION VERSION_GREATER \"3.15\")\n      if(CMAKE_BUILD_TYPE_UC STREQUAL \"DEBUG\")\n        set(CMAKE_MSVC_RUNTIME_LIBRARY MultiThreadedDebug)\n      elseif(MSVC_IDE)\n        set(CMAKE_MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\n      else()\n        set(CMAKE_MSVC_RUNTIME_LIBRARY MultiThreaded)\n      endif()\n      message(STATUS \"Visual C++ run-time library: ${CMAKE_MSVC_RUNTIME_LIBRARY} (WITH_CRT_DLL = ${WITH_CRT_DLL})\")\n    elseif(MSVC)\n      foreach(var CMAKE_C_FLAGS CMAKE_C_FLAGS_DEBUG CMAKE_C_FLAGS_RELEASE\n        CMAKE_C_FLAGS_MINSIZEREL CMAKE_C_FLAGS_RELWITHDEBINFO)\n        if(${var} MATCHES \"/MD\")\n          string(REGEX REPLACE \"/MD\" \"/MT\" ${var} \"${${var}}\")\n        endif()\n      endforeach()\n    endif()\n  endif()\n  add_definitions(-D_CRT_NONSTDC_NO_WARNINGS)\nendif()\n\nif(CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n  # Use the maximum optimization level for release builds\n  foreach(var CMAKE_C_FLAGS_RELEASE CMAKE_C_FLAGS_RELWITHDEBINFO)\n    if(${var} MATCHES \"-O2\")\n      string(REGEX REPLACE \"-O2\" \"-O3\" ${var} \"${${var}}\")\n    endif()\n  endforeach()\nendif()\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\")\n  if(CMAKE_C_COMPILER_ID MATCHES \"SunPro\")\n    # Use the maximum optimization level for release builds\n    foreach(var CMAKE_C_FLAGS_RELEASE CMAKE_C_FLAGS_RELWITHDEBINFO)\n      if(${var} MATCHES \"-xO3\")\n        string(REGEX REPLACE \"-xO3\" \"-xO5\" ${var} \"${${var}}\")\n      endif()\n      if(${var} MATCHES \"-xO2\")\n        string(REGEX REPLACE \"-xO2\" \"-xO5\" ${var} \"${${var}}\")\n      endif()\n    endforeach()\n  endif()\nendif()\n\nset(EFFECTIVE_C_FLAGS \"${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE_UC}}\")\nmessage(STATUS \"Compiler flags = ${EFFECTIVE_C_FLAGS}\")\n\nset(EFFECTIVE_LD_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ${CMAKE_EXE_LINKER_FLAGS_${CMAKE_BUILD_TYPE_UC}}\")\nmessage(STATUS \"Linker flags = ${EFFECTIVE_LD_FLAGS}\")\n\ninclude(CheckCSourceCompiles)\ninclude(CheckIncludeFiles)\ninclude(CheckTypeSize)\n\ncheck_type_size(\"size_t\" SIZE_T)\ncheck_type_size(\"unsigned long\" UNSIGNED_LONG)\n\nif(SIZE_T EQUAL UNSIGNED_LONG)\n  check_c_source_compiles(\"int main(int argc, char **argv) { unsigned long a = argc;  return __builtin_ctzl(a); }\"\n    HAVE_BUILTIN_CTZL)\nendif()\nif(MSVC_LIKE)\n  check_include_files(\"intrin.h\" HAVE_INTRIN_H)\nendif()\n\nif(UNIX)\n  if(CMAKE_CROSSCOMPILING)\n    set(RIGHT_SHIFT_IS_UNSIGNED 0)\n  else()\n    include(CheckCSourceRuns)\n    check_c_source_runs(\"\n      #include <stdio.h>\n      #include <stdlib.h>\n      static int is_shifting_signed (long arg) {\n        long res = arg >> 4;\n        if (res == -0x7F7E80CL)\n          return 1; /* right shift is signed */\n        /* see if unsigned-shift hack will fix it. */\n        /* we can't just test exact value since it depends on width of long... */\n        res |= 0xFFFFFFFFL << (32-4);\n        if (res == -0x7F7E80CL)\n          return 0; /* right shift is unsigned */\n        printf(\\\"Right shift isn't acting as I expect it to.\\\\\\\\n\\\");\n        printf(\\\"I fear the JPEG software will not work at all.\\\\\\\\n\\\\\\\\n\\\");\n        return 0; /* try it with unsigned anyway */\n      }\n      int main (void) {\n        exit(is_shifting_signed(-0x7F7E80B1L));\n      }\" RIGHT_SHIFT_IS_UNSIGNED)\n  endif()\nendif()\n\nif(NOT MSVC OR CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n  check_c_source_compiles(\"extern const int table[1]; const int __attribute__((visibility(\\\"hidden\\\"))) table[1] = { 0 }; int main(void) { return table[0]; }\"\n    HIDDEN_WORKS)\n  if(HIDDEN_WORKS)\n    set(HIDDEN \"__attribute__((visibility(\\\"hidden\\\")))\")\n    message(STATUS \"HIDDEN = ${HIDDEN}\")\n  endif()\nendif()\n\nif(MSVC)\n  set(INLINE_OPTIONS \"__inline;inline\")\nelse()\n  set(INLINE_OPTIONS \"__inline__;inline\")\nendif()\noption(FORCE_INLINE \"Force function inlining\" TRUE)\nboolean_number(FORCE_INLINE)\nif(FORCE_INLINE)\n  if(MSVC)\n    list(INSERT INLINE_OPTIONS 0 \"__forceinline\")\n  else()\n    list(INSERT INLINE_OPTIONS 0 \"inline __attribute__((always_inline))\")\n    list(INSERT INLINE_OPTIONS 0 \"__inline__ __attribute__((always_inline))\")\n  endif()\nendif()\nforeach(inline ${INLINE_OPTIONS})\n  check_c_source_compiles(\"${inline} static int foo(void) { return 0; } int main(void) { return foo(); }\"\n    INLINE_WORKS)\n  if(INLINE_WORKS)\n    set(INLINE ${inline})\n    break()\n  endif()\nendforeach()\nif(NOT INLINE_WORKS)\n  message(FATAL_ERROR \"Could not determine how to inline functions.\")\nendif()\nmessage(STATUS \"INLINE = ${INLINE} (FORCE_INLINE = ${FORCE_INLINE})\")\n\nif(MSVC)\n  set(THREAD_LOCAL \"__declspec(thread)\")\nelse()\n  set(THREAD_LOCAL \"__thread\")\nendif()\ncheck_c_source_compiles(\"static ${THREAD_LOCAL} int i;  int main(void) { i = 0;  return i; }\"\n  HAVE_THREAD_LOCAL)\nif(HAVE_THREAD_LOCAL)\n  message(STATUS \"THREAD_LOCAL = ${THREAD_LOCAL}\")\nelse()\n  message(WARNING \"Thread-local storage is not available.  The TurboJPEG API library's global error handler will not be thread-safe.\")\n  unset(THREAD_LOCAL)\nendif()\n\nif(UNIX AND NOT APPLE)\n  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map \"VERS_1 { global: *; };\")\n  set(CMAKE_REQUIRED_FLAGS\n    \"-Wl,--version-script,${CMAKE_CURRENT_BINARY_DIR}/conftest.map\")\n  check_c_source_compiles(\"int main(void) { return 0; }\" HAVE_VERSION_SCRIPT)\n  set(CMAKE_REQUIRED_FLAGS)\n  file(REMOVE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map)\n  if(HAVE_VERSION_SCRIPT)\n    message(STATUS \"Linker supports GNU-style version scripts\")\n    set(MAPFLAG \"-Wl,--version-script,\")\n    set(TJMAPFLAG \"-Wl,--version-script,\")\n  else()\n    message(STATUS \"Linker does not support GNU-style version scripts\")\n    if(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\")\n      # The Solaris linker doesn't like our version script for the libjpeg API\n      # library, but the version script for the TurboJPEG API library should\n      # still work.\n      file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map\n        \"VERS_1 { global: foo;  local: *; }; VERS_2 { global: foo2; } VERS_1;\")\n      set(CMAKE_REQUIRED_FLAGS \"-Wl,-M,${CMAKE_CURRENT_BINARY_DIR}/conftest.map -shared\")\n      check_c_source_compiles(\"int foo() { return 0; } int foo2() { return 2; }\"\n        HAVE_MAPFILE)\n      set(CMAKE_REQUIRED_FLAGS)\n      file(REMOVE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map)\n      if(HAVE_MAPFILE)\n        message(STATUS \"Linker supports mapfiles\")\n        set(TJMAPFLAG \"-Wl,-M,\")\n      else()\n        message(STATUS \"Linker does not support mapfiles\")\n      endif()\n    endif()\n  endif()\nendif()\n\n# Generate files\nconfigure_file(jversion.h.in jversion.h)\nif(UNIX)\n  configure_file(libjpeg.map.in libjpeg.map)\nendif()\n\n# Include directories and compiler definitions\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR})\n\n\n###############################################################################\n# TARGETS\n###############################################################################\n\nif(CMAKE_EXECUTABLE_SUFFIX_TMP)\n  set(CMAKE_EXECUTABLE_SUFFIX ${CMAKE_EXECUTABLE_SUFFIX_TMP})\nendif()\nmessage(STATUS \"CMAKE_EXECUTABLE_SUFFIX = ${CMAKE_EXECUTABLE_SUFFIX}\")\n\nset(JPEG16_SOURCES jcapistd.c jccolor.c jcdiffct.c jclossls.c jcmainct.c\n  jcprepct.c jcsample.c jdapistd.c jdcolor.c jddiffct.c jdlossls.c jdmainct.c\n  jdpostct.c jdsample.c jutils.c)\nset(JPEG12_SOURCES ${JPEG16_SOURCES} jccoefct.c jcdctmgr.c jdcoefct.c\n  jddctmgr.c jdmerge.c jfdctfst.c jfdctint.c jidctflt.c jidctfst.c jidctint.c\n  jidctred.c jquant1.c jquant2.c)\nset(JPEG_SOURCES ${JPEG12_SOURCES} jcapimin.c jchuff.c jcicc.c jcinit.c\n  jcext.c\n  jclhuff.c jcmarker.c jcmaster.c jcomapi.c jcparam.c jcphuff.c jctrans.c\n  jdapimin.c jdatadst.c jdatasrc.c jdhuff.c jdicc.c jdinput.c jdlhuff.c\n  jdmarker.c jdmaster.c jdphuff.c jdtrans.c jerror.c jfdctflt.c jmemmgr.c\n  jmemnobs.c jpeg_nbits.c)\n\nif(WITH_ARITH_ENC OR WITH_ARITH_DEC)\n  set(JPEG_SOURCES ${JPEG_SOURCES} jaricom.c)\nendif()\n\nif(WITH_ARITH_ENC)\n  set(JPEG_SOURCES ${JPEG_SOURCES} jcarith.c)\nendif()\n\nif(WITH_ARITH_DEC)\n  set(JPEG_SOURCES ${JPEG_SOURCES} jdarith.c)\nendif()\n\nif(WITH_SIMD)\n  add_subdirectory(simd)\n  if(NEON_INTRINSICS)\n    add_definitions(-DNEON_INTRINSICS)\n  endif()\nelse()\n  message(STATUS \"SIMD extensions: None (WITH_SIMD = ${WITH_SIMD})\")\nendif()\n\n# We have to generate these here, because if the build system tries and fails\n# to enable the SIMD extensions, the value of WITH_SIMD will have changed.\nconfigure_file(jconfig.h.in jconfig.h)\nconfigure_file(jconfigint.h.in jconfigint.h)\n\nif(WITH_SIMD)\n  message(STATUS \"SIMD extensions: ${CPU_TYPE} (WITH_SIMD = ${WITH_SIMD})\")\n  if(MSVC_IDE OR XCODE)\n    set_source_files_properties(${SIMD_OBJS} PROPERTIES GENERATED 1)\n  endif()\n  set(SIMD_TARGET_OBJECTS $<TARGET_OBJECTS:simd>)\nendif()\n\nif(WITH_JAVA)\n  add_subdirectory(java)\nendif()\n\nif(BUILD_SHARED_LIBS)\n  # Compile a separate version of these source files with 12-bit and 16-bit\n  # data precision.\n  add_library(jpeg12 OBJECT ${JPEG12_SOURCES})\n  set_property(TARGET jpeg12 PROPERTY COMPILE_FLAGS \"-DBITS_IN_JSAMPLE=12\")\n  set_target_properties(jpeg12 PROPERTIES POSITION_INDEPENDENT_CODE 1)\n  add_library(jpeg16 OBJECT ${JPEG16_SOURCES})\n  set_property(TARGET jpeg16 PROPERTY COMPILE_FLAGS \"-DBITS_IN_JSAMPLE=16\")\n  set_target_properties(jpeg16 PROPERTIES POSITION_INDEPENDENT_CODE 1)\n  add_subdirectory(sharedlib)\nendif()\n\nif(NOT BUILD_SHARED_LIBS)\n  # Compile a separate version of these source files with 12-bit and 16-bit\n  # data precision.\n  add_library(jpeg12-static OBJECT ${JPEG12_SOURCES})\n  set_property(TARGET jpeg12-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=12\")\n  add_library(jpeg16-static OBJECT ${JPEG16_SOURCES})\n  set_property(TARGET jpeg16-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=16\")\n  add_library(jpeg-static STATIC ${JPEG_SOURCES} ${SIMD_TARGET_OBJECTS}\n    ${SIMD_OBJS} $<TARGET_OBJECTS:jpeg12-static>\n    $<TARGET_OBJECTS:jpeg16-static>)\n  if(NOT MSVC_LIKE)\n    set_target_properties(jpeg-static PROPERTIES OUTPUT_NAME jpeg)\n  endif()\nendif()\n\nif(WITH_TURBOJPEG)\n  if(BUILD_SHARED_LIBS)\n    set(TURBOJPEG_SOURCES ${JPEG_SOURCES} ${SIMD_TARGET_OBJECTS} ${SIMD_OBJS}\n      turbojpeg.c transupp.c jdatadst-tj.c jdatasrc-tj.c rdbmp.c rdppm.c\n      wrbmp.c wrppm.c $<TARGET_OBJECTS:jpeg12> $<TARGET_OBJECTS:jpeg16>)\n    set(TJMAPFILE ${CMAKE_CURRENT_SOURCE_DIR}/turbojpeg-mapfile)\n    if(WITH_JAVA)\n      set(TURBOJPEG_SOURCES ${TURBOJPEG_SOURCES} turbojpeg-jni.c)\n      include_directories(${JAVA_INCLUDE_PATH} ${JAVA_INCLUDE_PATH2})\n      set(TJMAPFILE ${CMAKE_CURRENT_SOURCE_DIR}/turbojpeg-mapfile.jni)\n    endif()\n    if(MSVC_LIKE)\n      configure_file(${CMAKE_SOURCE_DIR}/win/turbojpeg.rc.in\n        ${CMAKE_BINARY_DIR}/win/turbojpeg.rc)\n      set(TURBOJPEG_SOURCES ${TURBOJPEG_SOURCES}\n        ${CMAKE_BINARY_DIR}/win/turbojpeg.rc)\n    endif()\n    add_library(turbojpeg12 OBJECT rdppm.c wrppm.c)\n    set_property(TARGET turbojpeg12 PROPERTY COMPILE_FLAGS\n      \"-DBITS_IN_JSAMPLE=12 -DPPM_SUPPORTED\")\n    set_target_properties(turbojpeg12 PROPERTIES POSITION_INDEPENDENT_CODE 1)\n    add_library(turbojpeg16 OBJECT rdppm.c wrppm.c)\n    set_property(TARGET turbojpeg16 PROPERTY COMPILE_FLAGS\n      \"-DBITS_IN_JSAMPLE=16 -DPPM_SUPPORTED\")\n    set_target_properties(turbojpeg16 PROPERTIES POSITION_INDEPENDENT_CODE 1)\n    add_library(turbojpeg SHARED ${TURBOJPEG_SOURCES}\n      $<TARGET_OBJECTS:turbojpeg12> $<TARGET_OBJECTS:turbojpeg16>)\n    set_property(TARGET turbojpeg PROPERTY COMPILE_FLAGS\n      \"-DBMP_SUPPORTED -DPPM_SUPPORTED\")\n    if(WIN32)\n      set_target_properties(turbojpeg PROPERTIES DEFINE_SYMBOL DLLDEFINE)\n    endif()\n    if(MINGW)\n      set_target_properties(turbojpeg PROPERTIES LINK_FLAGS -Wl,--kill-at)\n    endif()\n    if(APPLE AND (NOT CMAKE_OSX_DEPLOYMENT_TARGET OR\n                  CMAKE_OSX_DEPLOYMENT_TARGET VERSION_GREATER 10.4))\n      if(NOT CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG)\n        set(CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG \"-Wl,-rpath,\")\n      endif()\n      set_target_properties(turbojpeg PROPERTIES MACOSX_RPATH 1)\n    endif()\n    set_target_properties(turbojpeg PROPERTIES\n      SOVERSION ${TURBOJPEG_SO_MAJOR_VERSION} VERSION ${TURBOJPEG_SO_VERSION})\n    if(TJMAPFLAG)\n      set_target_properties(turbojpeg PROPERTIES\n        LINK_FLAGS \"${TJMAPFLAG}${TJMAPFILE}\")\n    endif()\n\n    add_executable(tjunittest tjunittest.c tjutil.c md5/md5.c md5/md5hl.c)\n    target_link_libraries(tjunittest turbojpeg)\n    if(UNIX)\n      target_link_libraries(tjunittest m)\n    endif()\n\n    add_executable(tjbench tjbench.c tjutil.c)\n    target_link_libraries(tjbench turbojpeg)\n    if(UNIX)\n      target_link_libraries(tjbench m)\n    endif()\n\n    add_executable(tjexample tjexample.c)\n    target_link_libraries(tjexample turbojpeg)\n\n    add_custom_target(tjdoc COMMAND doxygen -s doxygen.config\n      WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})\n\n    if(UNIX)\n      target_link_libraries(tjexample m)\n    endif()\n  endif()\n\n  if(NOT BUILD_SHARED_LIBS)\n    add_library(turbojpeg12-static OBJECT rdppm.c wrppm.c)\n    set_property(TARGET turbojpeg12-static PROPERTY COMPILE_FLAGS\n      \"-DBITS_IN_JSAMPLE=12 -DPPM_SUPPORTED\")\n    add_library(turbojpeg16-static OBJECT rdppm.c wrppm.c)\n    set_property(TARGET turbojpeg16-static PROPERTY COMPILE_FLAGS\n      \"-DBITS_IN_JSAMPLE=16 -DPPM_SUPPORTED\")\n    add_library(turbojpeg-static STATIC ${JPEG_SOURCES} ${SIMD_TARGET_OBJECTS}\n      ${SIMD_OBJS} turbojpeg.c transupp.c jdatadst-tj.c jdatasrc-tj.c rdbmp.c\n      rdppm.c wrbmp.c wrppm.c $<TARGET_OBJECTS:jpeg12-static>\n      $<TARGET_OBJECTS:jpeg16-static> $<TARGET_OBJECTS:turbojpeg12-static>\n      $<TARGET_OBJECTS:turbojpeg16-static>)\n    set_property(TARGET turbojpeg-static PROPERTY COMPILE_FLAGS\n      \"-DBMP_SUPPORTED -DPPM_SUPPORTED\")\n    if(NOT MSVC_LIKE)\n      set_target_properties(turbojpeg-static PROPERTIES OUTPUT_NAME turbojpeg)\n    endif()\n\n    add_executable(tjunittest-static tjunittest.c tjutil.c md5/md5.c\n      md5/md5hl.c)\n    target_link_libraries(tjunittest-static turbojpeg-static)\n    if(UNIX)\n      target_link_libraries(tjunittest-static m)\n    endif()\n\n    add_executable(tjbench-static tjbench.c tjutil.c)\n    target_link_libraries(tjbench-static turbojpeg-static)\n    if(UNIX)\n      target_link_libraries(tjbench-static m)\n    endif()\n  endif()\nendif()\n\nif(WIN32)\n  set(USE_SETMODE \"-DUSE_SETMODE\")\nendif()\nset(CDJPEG_COMPILE_FLAGS\n  \"-DBMP_SUPPORTED -DGIF_SUPPORTED -DPPM_SUPPORTED -DTARGA_SUPPORTED ${USE_SETMODE}\")\n\nif(PNG_SUPPORTED)\n  report_option(PNG_SUPPORTED \"PNG reading support\")\n  set(COMPILE_FLAGS \"${COMPILE_FLAGS} -DPNG_SUPPORTED\")\n  set(CJPEG_BMP_SOURCES ${CJPEG_BMP_SOURCES} rdpng.c)\nendif()\n\nif(NOT BUILD_SHARED_LIBS)\n  # Compile a separate version of these source files with 12-bit and 16-bit\n  # data precision.\n  add_library(cjpeg12-static OBJECT rdgif.c rdppm.c)\n  set_property(TARGET cjpeg12-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=12 -DGIF_SUPPORTED -DPPM_SUPPORTED\")\n  add_library(cjpeg16-static OBJECT rdgif.c rdppm.c)\n  set_property(TARGET cjpeg16-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=16 -DGIF_SUPPORTED -DPPM_SUPPORTED\")\n  add_executable(cjpeg-static cjpeg.c cdjpeg.c rdbmp.c rdgif.c rdppm.c\n    rdjpeg.c\n    rdswitch.c rdtarga.c $<TARGET_OBJECTS:cjpeg12-static>\n    $<TARGET_OBJECTS:cjpeg16-static>)\n  set_property(TARGET cjpeg-static PROPERTY COMPILE_FLAGS\n    ${CDJPEG_COMPILE_FLAGS})\n  target_link_libraries(cjpeg-static jpeg-static)\n  if(UNIX)\n    target_link_libraries(cjpeg-static m)\n  endif()\n\n  if(PNG_SUPPORTED)\n    # to avoid finding shared library from CMake cache\n    unset(PNG_LIBRARY CACHE)\n    unset(PNG_LIBRARY_RELEASE CACHE)\n    unset(PNG_LIBRARY_DEBUG CACHE)\n    unset(ZLIB_LIBRARY CACHE)\n    unset(ZLIB_LIBRARY_RELEASE CACHE)\n    unset(ZLIB_LIBRARY_DEBUG CACHE)\n\n    if (APPLE)\n      find_package(ZLIB REQUIRED) # macos doesn't have static zlib\n    endif()\n    set(CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_STATIC_LIBRARY_SUFFIX})\n    find_package(PNG 1.6 REQUIRED)\n    if (NOT APPLE)\n      find_package(ZLIB REQUIRED)\n    endif()\n    target_include_directories(cjpeg-static PUBLIC ${PNG_INCLUDE_DIR} ${ZLIB_INCLUDE_DIR})\n    target_link_libraries(cjpeg-static ${PNG_LIBRARY} ${ZLIB_LIBRARY})\n  endif()\n\n  # Compile a separate version of these source files with 12-bit and 16-bit\n  # data precision.\n  add_library(djpeg12-static OBJECT rdcolmap.c wrgif.c wrppm.c)\n  set_property(TARGET djpeg12-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=12 -DGIF_SUPPORTED -DPPM_SUPPORTED\")\n  add_library(djpeg16-static OBJECT wrppm.c)\n  set_property(TARGET djpeg16-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=16 -DPPM_SUPPORTED\")\n  add_executable(djpeg-static djpeg.c cdjpeg.c rdcolmap.c rdswitch.c wrbmp.c\n    wrgif.c wrppm.c wrtarga.c $<TARGET_OBJECTS:djpeg12-static>\n    $<TARGET_OBJECTS:djpeg16-static>)\n  set_property(TARGET djpeg-static PROPERTY COMPILE_FLAGS\n    ${CDJPEG_COMPILE_FLAGS})\n  target_link_libraries(djpeg-static jpeg-static)\n  if(UNIX)\n    target_link_libraries(djpeg-static m)\n  endif()\n\n  add_executable(jpegtran-static jpegtran.c cdjpeg.c rdswitch.c transupp.c)\n  target_link_libraries(jpegtran-static jpeg-static)\n  if(UNIX)\n    target_link_libraries(jpegtran-static m)\n  endif()\n\n  set_property(TARGET jpegtran-static PROPERTY COMPILE_FLAGS \"${USE_SETMODE}\")\n\n  add_executable(example-static example.c)\n  target_link_libraries(example-static jpeg-static)\n  if(UNIX)\n    target_link_libraries(example-static m)\n  endif()\n\nendif()\n\nadd_executable(rdjpgcom rdjpgcom.c)\n\nadd_executable(wrjpgcom wrjpgcom.c)\n\n\n###############################################################################\n# TESTS\n###############################################################################\n\nif(WITH_FUZZ)\n  add_subdirectory(fuzz)\nendif()\n\nadd_executable(strtest strtest.c)\n\nadd_subdirectory(md5)\n\nif(GENERATOR_IS_MULTI_CONFIG)\n  set(OBJDIR \"\\${CTEST_CONFIGURATION_TYPE}/\")\nelse()\n  set(OBJDIR \"\")\nendif()\n\nenable_testing()\n\nif(WITH_JAVA)\n  add_test(TJUnitTest\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest)\n  add_test(TJUnitTest-yuv\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -yuv)\n  add_test(TJUnitTest-yuv-nopad\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -yuv -noyuvpad)\n  add_test(TJUnitTest-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -lossless)\n  add_test(TJUnitTest-bi\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -bi)\n  add_test(TJUnitTest-bi-yuv\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -bi -yuv)\n  add_test(TJUnitTest-bi-yuv-nopad\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -bi -yuv -noyuvpad)\n  add_test(TJUnitTest-bi-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -bi -lossless)\n  add_test(TJUnitTest12\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 12)\n  add_test(TJUnitTest12-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 12 -lossless)\n  add_test(TJUnitTest16-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 16)\nendif()\n\nset(TEST_LIBTYPES \"\")\nif(BUILD_SHARED_LIBS)\n  set(TEST_LIBTYPES ${TEST_LIBTYPES} shared)\nendif()\nif(NOT BUILD_SHARED_LIBS)\n  set(TEST_LIBTYPES ${TEST_LIBTYPES} static)\nendif()\n\nset(TESTIMAGES ${CMAKE_CURRENT_SOURCE_DIR}/testimages)\nif(CMAKE_CROSSCOMPILING)\n  file(RELATIVE_PATH TESTIMAGES ${CMAKE_CURRENT_BINARY_DIR} ${TESTIMAGES})\nendif()\n\n# The output of the floating point DCT/IDCT algorithms differs depending on the\n# type of floating point math used, so the FLOATTEST8 and FLOATTEST12 CMake\n# variables must be set in order to tell the testing system which floating\n# point results it should expect:\n#\n# sse = validate against the expected results from the libjpeg-turbo SSE SIMD\n#       extensions\n# no-fp-contract = validate against the expected results from the C code when\n#                  floating point expression contraction is disabled (the\n#                  default with Clang 13 and earlier, when building for\n#                  platforms that lack fused multiply-add [FMA] instructions,\n#                  or when passing -ffp-contract=off to GCC or Clang)\n# fp-contract = validate against the expected results from the C code when\n#               floating point expression contraction is enabled (the default\n#               with Clang 14 and later, with GCC when building for platforms\n#               that have fused multiply-add [FMA] instructions, or when\n#               passing -ffp-contract=fast to GCC or -ffp-contract=on to Clang)\n# 387 = validate against the expected results from the C code when the 387 FPU\n#       is being used for floating point math (which is generally the default\n#       with x86 compilers)\n# msvc = validate against the expected results from the C code when compiled\n#        with a 32-bit version of Visual C++\n\nif(CPU_TYPE STREQUAL \"x86_64\" OR CPU_TYPE STREQUAL \"i386\")\n  if(WITH_SIMD)\n    set(DEFAULT_FLOATTEST8 sse)\n  elseif(CPU_TYPE STREQUAL \"x86_64\")\n    set(DEFAULT_FLOATTEST8 no-fp-contract)\n  endif()\nelseif(CPU_TYPE STREQUAL \"powerpc\" OR CPU_TYPE STREQUAL \"arm64\")\n  if(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n    if(CMAKE_C_COMPILER_ID MATCHES \"AppleClang\")\n      # Xcode 14.3 and later\n      set(MIN_FP_CONTRACT_VERSION 14.0.1)\n    else()\n      set(MIN_FP_CONTRACT_VERSION 14.0.0)\n    endif()\n    if(CMAKE_C_COMPILER_VERSION VERSION_EQUAL ${MIN_FP_CONTRACT_VERSION} OR\n      CMAKE_C_COMPILER_VERSION VERSION_GREATER ${MIN_FP_CONTRACT_VERSION})\n      set(DEFAULT_FLOATTEST8 fp-contract)\n    else()\n      set(DEFAULT_FLOATTEST8 no-fp-contract)\n    endif()\n  elseif(CMAKE_COMPILER_IS_GNUCC)\n    set(DEFAULT_FLOATTEST8 fp-contract)\n  endif()\n# else we can't really set an intelligent default for FLOATTEST8.  The\n# appropriate value could be no-fp-contract, fp-contract, 387, or msvc,\n# depending on the compiler and compiler options.  We leave it to the user to\n# set FLOATTEST8 manually.\nendif()\n\n# This causes FLOATTEST8 to reset to the default value if WITH_SIMD has\n# changed.\nif(DEFINED WITH_SIMD_INT AND NOT WITH_SIMD EQUAL WITH_SIMD_INT)\n  set(FORCE_FLOATTEST8 \"FORCE\")\nendif()\nset(WITH_SIMD_INT ${WITH_SIMD} CACHE INTERNAL \"\")\nset(FLOATTEST8 ${DEFAULT_FLOATTEST8} CACHE STRING\n  \"The type of floating point math used by the 8-bit-per-sample floating point DCT/IDCT algorithms.  This tells the testing system which numerical results it should expect from those tests.  [sse = libjpeg-turbo x86/x86-64 SIMD extensions, no-fp-contract = generic FPU with floating point expression contraction disabled, fp-contract = generic FPU with floating point expression contraction enabled, 387 = 387 FPU, msvc = 32-bit Visual Studio] (default = ${DEFAULT_FLOATTEST8})\"\n  ${FORCE_FLOATTEST8})\nmessage(STATUS \"FLOATTEST8 = ${FLOATTEST8}\")\n\nif(FLOATTEST8)\n  string(TOUPPER ${FLOATTEST8} FLOATTEST8_UC)\n  string(REGEX REPLACE \"-\" \"_\" FLOATTEST8_UC ${FLOATTEST8_UC})\n  string(TOLOWER ${FLOATTEST8} FLOATTEST8)\n  if(NOT FLOATTEST8 STREQUAL \"sse\" AND\n    NOT FLOATTEST8 STREQUAL \"no-fp-contract\" AND\n    NOT FLOATTEST8 STREQUAL \"fp-contract\" AND NOT FLOATTEST8 STREQUAL \"387\" AND\n    NOT FLOATTEST8 STREQUAL \"msvc\")\n    message(FATAL_ERROR \"\\\"${FLOATTEST8}\\\" is not a valid value for FLOATTEST8.\")\n  endif()\nendif()\n\nif(CPU_TYPE STREQUAL \"x86_64\")\n  set(DEFAULT_FLOATTEST12 no-fp-contract)\nelseif(CPU_TYPE STREQUAL \"powerpc\" OR CPU_TYPE STREQUAL \"arm64\")\n  if(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n    if(CMAKE_C_COMPILER_ID MATCHES \"AppleClang\")\n      # Xcode 14.3 and later\n      set(MIN_FP_CONTRACT_VERSION 14.0.1)\n    else()\n      set(MIN_FP_CONTRACT_VERSION 14.0.0)\n    endif()\n    if(CMAKE_C_COMPILER_VERSION VERSION_EQUAL ${MIN_FP_CONTRACT_VERSION} OR\n      CMAKE_C_COMPILER_VERSION VERSION_GREATER ${MIN_FP_CONTRACT_VERSION})\n      set(DEFAULT_FLOATTEST12 fp-contract)\n    else()\n      set(DEFAULT_FLOATTEST12 no-fp-contract)\n    endif()\n  elseif(CMAKE_COMPILER_IS_GNUCC)\n    set(DEFAULT_FLOATTEST12 fp-contract)\n  endif()\n# else we can't really set an intelligent default for FLOATTEST12.  The\n# appropriate value could be no-fp-contract, fp-contract, or something else,\n# depending on the compiler and compiler options.  We leave it to the user to\n# set FLOATTEST12 manually.\nendif()\n\nset(FLOATTEST12 ${DEFAULT_FLOATTEST12} CACHE STRING\n  \"The type of floating point math used by the 12-bit-per-sample floating point DCT/IDCT algorithms.  This tells the testing system which numerical results it should expect from those tests.  [sse = libjpeg-turbo x86/x86-64 SIMD extensions, no-fp-contract = generic FPU with floating point expression contraction disabled, fp-contract = generic FPU with floating point expression contraction enabled, 387 = 387 FPU, msvc = 32-bit Visual Studio] (default = ${DEFAULT_FLOATTEST12})\")\nmessage(STATUS \"FLOATTEST12 = ${FLOATTEST12}\")\n\nif(FLOATTEST12)\n  string(TOUPPER ${FLOATTEST12} FLOATTEST12_UC)\n  string(REGEX REPLACE \"-\" \"_\" FLOATTEST12_UC ${FLOATTEST12_UC})\n  string(TOLOWER ${FLOATTEST12} FLOATTEST12)\n  if(NOT FLOATTEST12 STREQUAL \"sse\" AND\n    NOT FLOATTEST12 STREQUAL \"no-fp-contract\" AND\n    NOT FLOATTEST12 STREQUAL \"fp-contract\" AND\n    NOT FLOATTEST12 STREQUAL \"387\" AND\n    NOT FLOATTEST12 STREQUAL \"msvc\")\n    message(FATAL_ERROR \"\\\"${FLOATTEST12}\\\" is not a valid value for FLOATTEST12.\")\n  endif()\nendif()\n\nforeach(libtype ${TEST_LIBTYPES})\n  if(libtype STREQUAL \"static\")\n    set(suffix -static)\n  endif()\n  if(WITH_TURBOJPEG)\n    add_test(NAME tjunittest-${libtype}\n      COMMAND tjunittest${suffix})\n    add_test(NAME tjunittest-${libtype}-alloc\n      COMMAND tjunittest${suffix} -alloc)\n    add_test(NAME tjunittest-${libtype}-yuv\n      COMMAND tjunittest${suffix} -yuv)\n    add_test(NAME tjunittest-${libtype}-yuv-alloc\n      COMMAND tjunittest${suffix} -yuv -alloc)\n    add_test(NAME tjunittest-${libtype}-yuv-nopad\n      COMMAND tjunittest${suffix} -yuv -noyuvpad)\n    add_test(NAME tjunittest-${libtype}-lossless\n      COMMAND tjunittest${suffix} -lossless)\n    add_test(NAME tjunittest-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -lossless -alloc)\n    add_test(NAME tjunittest-${libtype}-bmp\n      COMMAND tjunittest${suffix} -bmp)\n    add_test(NAME tjunittest12-${libtype}\n      COMMAND tjunittest${suffix} -precision 12)\n    add_test(NAME tjunittest12-${libtype}-alloc\n      COMMAND tjunittest${suffix} -precision 12 -alloc)\n    add_test(NAME tjunittest12-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 12 -lossless)\n    add_test(NAME tjunittest12-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 12 -lossless -alloc)\n    add_test(NAME tjunittest12-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 12 -bmp)\n    add_test(NAME tjunittest16-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 16)\n    add_test(NAME tjunittest16-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 16 -alloc)\n    add_test(NAME tjunittest16-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 16 -bmp)\n\n    foreach(sample_bits 8 12)\n\n      if(sample_bits EQUAL 12)\n        set(tjbench tjbench12)\n        set(testout testout12${suffix})\n\n        set(MD5_PPM_GRAY_TILE 2f799249148b1a9d0e61fa4408f6c397)\n        set(MD5_PPM_420_8x8_TILE b25684e1af37be504ee3fd137757353f)\n        set(MD5_PPM_420_16x16_TILE 2c1af444a63d19167eb3f4c1fa7f1b67)\n        set(MD5_PPM_420_32x32_TILE cce091fe18688f39bc0b5ba29238e1e2)\n        set(MD5_PPM_420_64x64_TILE f770ec8f710a014606dee662bc88606d)\n        set(MD5_PPM_420_128x128_TILE a841bc82e9eda34cbdefe53f808b339c)\n        set(MD5_PPM_420M_8x8_TILE 9de845a8d805affb9ae3a7b2712eaa46)\n        set(MD5_PPM_420M_TILE 455d273be0e229b9c8aabb16481bce5b)\n        set(MD5_PPM_422_8x8_TILE 5e9f784a98a7eae2789ea1458ed43748)\n        set(MD5_PPM_422_16x16_TILE c8df65a792d371a30c8fb7352f320314)\n        set(MD5_PPM_422_32x32_TILE b523b630237e3305a5c4d353ff4ee19b)\n        set(MD5_PPM_422_64x64_TILE eb30bdd20337079745b039e24e613bfd)\n        set(MD5_PPM_422_128x128_TILE 7997458635973b004da46863e2da55ea)\n        set(MD5_PPM_422M_8x8_TILE f8443fffd32cce7681dd36010ce43c07)\n        set(MD5_PPM_422M_TILE a0d45368343a63ca2c8ee87cc4ef9ded)\n        set(MD5_PPM_444_TILE 2f571a032e4dbc8ef40f75219d336b0b)\n      else()\n        set(tjbench tjbench)\n        set(testout testout${suffix})\n\n        set(MD5_PPM_GRAY_TILE 2c3b567086e6ca0c5e6d34ad8d6f6fe8)\n        set(MD5_PPM_420_8x8_TILE efca1bdf0226df01777137778cf986ec)\n        set(MD5_PPM_420_16x16_TILE 8c92c7453870d9e11c6d1dec3a8c9101)\n        set(MD5_PPM_420_32x32_TILE 3f7651872a95e469d1c7115f1b11ecef)\n        set(MD5_PPM_420_64x64_TILE f64c71af03fdea12363b62f1a3096aab)\n        set(MD5_PPM_420_128x128_TILE 5a5ef57517558c671bf5e75793588d69)\n        set(MD5_PPM_420M_8x8_TILE 66bd869b315a32a00fef1a025661ce72)\n        set(MD5_PPM_420M_TILE bf9ec2ab4875abb2efcce8f876fe2c2a)\n        set(MD5_PPM_422_8x8_TILE c300553ce1b3b90fd414ec96b62fe988)\n        set(MD5_PPM_422_16x16_TILE 6559ddb1191f5b2d3eb41081b254c4e0)\n        set(MD5_PPM_422_32x32_TILE 58691797f4584c4c5ed5965a6bb9aec0)\n        set(MD5_PPM_422_64x64_TILE 7f9e34942ae46af7b784f459ec133f5e)\n        set(MD5_PPM_422_128x128_TILE 6afcb77580d85dd3eacb04b3c2bc7710)\n        set(MD5_PPM_422M_8x8_TILE 55df1f96bcfb631aedeb940cf3f011f5)\n        set(MD5_PPM_422M_TILE 6502031018c2d2f69bc6353347f8df4d)\n        set(MD5_PPM_444_TILE 87bd58005eec73f0f313c8e38d0d793c)\n      endif()\n\n      # Test compressing from/decompressing to an arbitrary subregion of a\n      # larger image buffer\n      add_test(NAME ${tjbench}-${libtype}-tile-cp\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n          ${TESTIMAGES}/testorig.ppm ${testout}_tile.ppm)\n      add_test(NAME ${tjbench}-${libtype}-tile\n        COMMAND tjbench${suffix} ${testout}_tile.ppm 95\n          -precision ${sample_bits} -rgb -quiet -tile -benchtime 0.01\n          -warmup 0)\n      set_tests_properties(${tjbench}-${libtype}-tile\n        PROPERTIES DEPENDS ${tjbench}-${libtype}-tile-cp)\n\n      foreach(tile 8 16 32 64 128)\n        add_test(NAME ${tjbench}-${libtype}-tile-gray-${tile}x${tile}-cmp\n          COMMAND md5cmp ${MD5_PPM_GRAY_TILE}\n            ${testout}_tile_GRAY_Q95_${tile}x${tile}.ppm)\n        foreach(subsamp 420 422)\n          add_test(NAME ${tjbench}-${libtype}-tile-${subsamp}-${tile}x${tile}-cmp\n            COMMAND md5cmp ${MD5_PPM_${subsamp}_${tile}x${tile}_TILE}\n              ${testout}_tile_${subsamp}_Q95_${tile}x${tile}.ppm)\n        endforeach()\n        add_test(NAME ${tjbench}-${libtype}-tile-444-${tile}x${tile}-cmp\n          COMMAND md5cmp ${MD5_PPM_444_TILE}\n            ${testout}_tile_444_Q95_${tile}x${tile}.ppm)\n        foreach(subsamp gray 420 422 444)\n          set_tests_properties(\n            ${tjbench}-${libtype}-tile-${subsamp}-${tile}x${tile}-cmp\n            PROPERTIES DEPENDS ${tjbench}-${libtype}-tile)\n        endforeach()\n      endforeach()\n\n      add_test(NAME ${tjbench}-${libtype}-tilem-cp\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n          ${TESTIMAGES}/testorig.ppm ${testout}_tilem.ppm)\n      add_test(NAME ${tjbench}-${libtype}-tilem\n        COMMAND tjbench${suffix} ${testout}_tilem.ppm 95\n          -precision ${sample_bits} -rgb -fastupsample -quiet -tile\n          -benchtime 0.01 -warmup 0)\n      set_tests_properties(${tjbench}-${libtype}-tilem\n        PROPERTIES DEPENDS ${tjbench}-${libtype}-tilem-cp)\n\n      add_test(NAME ${tjbench}-${libtype}-tile-420m-8x8-cmp\n        COMMAND md5cmp ${MD5_PPM_420M_8x8_TILE}\n          ${testout}_tilem_420_Q95_8x8.ppm)\n      add_test(NAME ${tjbench}-${libtype}-tile-422m-8x8-cmp\n        COMMAND md5cmp ${MD5_PPM_422M_8x8_TILE}\n          ${testout}_tilem_422_Q95_8x8.ppm)\n      foreach(tile 16 32 64 128)\n        foreach(subsamp 420 422)\n          add_test(NAME ${tjbench}-${libtype}-tile-${subsamp}m-${tile}x${tile}-cmp\n            COMMAND md5cmp ${MD5_PPM_${subsamp}M_TILE}\n              ${testout}_tilem_${subsamp}_Q95_${tile}x${tile}.ppm)\n        endforeach()\n      endforeach()\n      foreach(tile 8 16 32 64 128)\n        foreach(subsamp 420 422)\n          set_tests_properties(\n            ${tjbench}-${libtype}-tile-${subsamp}m-${tile}x${tile}-cmp\n            PROPERTIES DEPENDS ${tjbench}-${libtype}-tilem)\n        endforeach()\n      endforeach()\n\n    endforeach()\n\n  endif()\n\n  # These tests are carefully crafted to provide full coverage of as many of\n  # the underlying algorithms as possible (including all of the\n  # SIMD-accelerated ones.)\n\n  macro(add_bittest PROG NAME ARGS OUTFILE INFILE MD5SUM)\n    if(${PROG} STREQUAL \"cjpeg16\")\n      set(ACTUAL_ARGS \"${ARGS};-precision;16\")\n    elseif(${PROG} STREQUAL \"cjpeg12\")\n      set(ACTUAL_ARGS \"${ARGS};-precision;12\")\n    else()\n      set(ACTUAL_ARGS ${ARGS})\n    endif()\n    string(REGEX REPLACE \"16\" \"\" ACTUAL_PROG ${PROG})\n    string(REGEX REPLACE \"12\" \"\" ACTUAL_PROG ${ACTUAL_PROG})\n    add_test(NAME ${PROG}-${libtype}-${NAME}\n      COMMAND ${ACTUAL_PROG}${suffix} ${ACTUAL_ARGS} -outfile ${OUTFILE}\n        ${INFILE})\n    add_test(NAME ${PROG}-${libtype}-${NAME}-cmp\n      COMMAND md5cmp ${MD5SUM} ${OUTFILE})\n    set_tests_properties(${PROG}-${libtype}-${NAME}-cmp PROPERTIES\n      DEPENDS ${PROG}-${libtype}-${NAME})\n    if(${ARGC} GREATER 6)\n      set(DEPENDS ${ARGN})\n      set_tests_properties(${PROG}-${libtype}-${NAME} PROPERTIES\n        DEPENDS ${DEPENDS})\n    endif()\n  endmacro()\n\n  set(MD5_JPEG_LOSSLESS fe99437df4e9976fe5e841969242b208)\n  set(MD5_PPM_LOSSLESS 01d9642a2b8723fefebbe9cb074ccd02)\n\n  # Lossless (all arguments other than -lossless and -restart should have no\n  # effect)\n  add_bittest(cjpeg16 lossless\n    \"-revert;-lossless;4;-restart;1;-quality;1;-grayscale;-optimize;-dct;float;-smooth;100;-baseline;-qslots;1,0,0;-sample;1x2,3x4,2x1\"\n    testout16_lossless.jpg ${TESTIMAGES}/testorig.ppm\n    ${MD5_JPEG_LOSSLESS})\n  add_bittest(djpeg16 lossless\n    \"-fast;-scale;1/8;-dct;float;-dither;none;-nosmooth;-onepass\"\n    testout16_lossless.ppm testout16_lossless.jpg\n    ${MD5_PPM_LOSSLESS} cjpeg16-${libtype}-lossless)\n\n  foreach(sample_bits 8 12)\n\n    if(sample_bits EQUAL 12)\n      set(cjpeg cjpeg12)\n      set(djpeg djpeg12)\n      set(jpegtran jpegtran12)\n      set(testout testout12${suffix})\n\n      set(TESTORIG testorig12.jpg)\n      set(MD5_JPEG_RGB_ISLOW 9d7369207c520d37f2c1cbfcb82b2964)\n      set(MD5_JPEG_RGB_ISLOW2 e619791332a99813bdca9f56fd60f9f9)\n      set(MD5_PPM_RGB_ISLOW f3301d2219783b8b3d942b7239fa50c0)\n      set(MD5_JPEG_422_IFAST_OPT 7322e3bd2f127f7de4b40d4480ce60e4)\n      set(MD5_PPM_422_IFAST 79807fa552899e66a04708f533e16950)\n      set(MD5_JPEG_440_ISLOW e25c1912e38367be505a89c410c1c2d2)\n      set(MD5_PPM_440_ISLOW e7d2e26288870cfcb30f3114ad01e380)\n      set(MD5_PPM_422M_IFAST 07737bfe8a7c1c87aaa393a0098d16b0)\n      set(MD5_JPEG_420_IFAST_Q100_PROG 9447cef4803d9b0f74bcf333cc710a29)\n      set(MD5_PPM_420_Q100_IFAST 1b3730122709f53d007255e8dfd3305e)\n      set(MD5_PPM_420M_Q100_IFAST 980a1a3c5bf9510022869d30b7d26566)\n      set(MD5_JPEG_GRAY_ISLOW 235c90707b16e2e069f37c888b2636d9)\n      set(MD5_PPM_GRAY_ISLOW 7213c10af507ad467da5578ca5ee1fca)\n      set(MD5_PPM_GRAY_ISLOW_RGB e96ee81c30a6ed422d466338bd3de65d)\n      set(MD5_JPEG_420S_IFAST_OPT 7af8e60be4d9c227ec63ac9b6630855e)\n\n      set(MD5_JPEG_3x2_FLOAT_PROG_SSE a8c17daf77b457725ec929e215b603f8)\n      set(MD5_PPM_3x2_FLOAT_SSE 42876ab9e5c2f76a87d08db5fbd57956)\n      set(MD5_JPEG_3x2_FLOAT_PROG_NO_FP_CONTRACT\n        a8c17daf77b457725ec929e215b603f8)\n      set(MD5_PPM_3x2_FLOAT_NO_FP_CONTRACT ${MD5_PPM_3x2_FLOAT_SSE})\n      set(MD5_JPEG_3x2_FLOAT_PROG_FP_CONTRACT\n        ${MD5_JPEG_3x2_FLOAT_PROG_NO_FP_CONTRACT})\n      if(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n        set(MD5_PPM_3x2_FLOAT_FP_CONTRACT 2da9de6ae869e88b8372de815d366b03)\n      else()\n        set(MD5_PPM_3x2_FLOAT_FP_CONTRACT ${MD5_PPM_3x2_FLOAT_SSE})\n      endif()\n      set(MD5_JPEG_3x2_FLOAT_PROG_387 bc6dbbefac2872f6b9d6c4a0ae60c3c0)\n      set(MD5_PPM_3x2_FLOAT_387 bcc5723c61560463ac60f772e742d092)\n      set(MD5_JPEG_3x2_FLOAT_PROG_MSVC e27840755870fa849872e58aa0cd1400)\n      set(MD5_PPM_3x2_FLOAT_MSVC 6c2880b83bb1aa41dfe330e7a9768690)\n\n      set(MD5_JPEG_3x2_IFAST_PROG 1396cc2b7185cfe943d408c9d305339e)\n      set(MD5_PPM_3x2_IFAST 3975985ef6eeb0a2cdc58daa651ccc00)\n      set(MD5_PPM_420M_ISLOW_2_1 4ca6be2a6f326ff9eaab63e70a8259c0)\n      set(MD5_PPM_420M_ISLOW_15_8 12aa9f9534c1b3d7ba047322226365eb)\n      set(MD5_PPM_420M_ISLOW_13_8 f7e22817c7b25e1393e4ec101e9d4e96)\n      set(MD5_PPM_420M_ISLOW_11_8 800a16f9f4dc9b293197bfe11be10a82)\n      set(MD5_PPM_420M_ISLOW_9_8 06b7a92a9bc69f4dc36ec40f1937d55c)\n      set(MD5_PPM_420M_ISLOW_7_8 3ec444a14a4ab4eab88ffc49c48eca43)\n      set(MD5_PPM_420M_ISLOW_3_4 3e726b7ea872445b19437d1c1d4f0d93)\n      set(MD5_PPM_420M_ISLOW_5_8 a8a771abdc94301d20ffac119b2caccd)\n      set(MD5_PPM_420M_ISLOW_1_2 b419124dd5568b085787234866102866)\n      set(MD5_PPM_420M_ISLOW_3_8 343d19015531b7bbe746124127244fa8)\n      set(MD5_PPM_420M_ISLOW_1_4 35fd59d866e44659edfa3c18db2a3edb)\n      set(MD5_PPM_420M_ISLOW_1_8 ccaed48ac0aedefda5d4abe4013f4ad7)\n      set(MD5_JPEG_LOSSLESS 8473501f5bb7c826524472c858bf4fcd)\n      set(MD5_PPM_LOSSLESS 1da3fb2620e5a4e258e0fcb891bc67e8)\n      set(MD5_PPM_420_ISLOW_SKIP15_31 86664cd9dc956536409e44e244d20a97)\n      set(MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71\n        452a21656115a163029cfba5c04fa76a)\n      set(MD5_PPM_444_ISLOW_SKIP1_6 ef63901f71ef7a75cd78253fc0914f84)\n      set(MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13\n        15b173fb5872d9575572fbcc1b05956f)\n      set(MD5_JPEG_CROP cdb35ff4b4519392690ea040c56ea99c)\n\n      set(MD5_JPEG_EXAMPLE_COMPRESS 5e502da0c3c0f957a58c536f31e973dc)\n      set(MD5_PPM_EXAMPLE_DECOMPRESS 70194fdcb73370ee7ba0db868d0c6fc8)\n    else()\n      set(cjpeg cjpeg)\n      set(djpeg djpeg)\n      set(jpegtran jpegtran)\n      set(testout testout${suffix})\n\n      set(TESTORIG testorig.jpg)\n      set(MD5_JPEG_RGB_ISLOW 1d44a406f61da743b5fd31c0a9abdca3)\n      set(MD5_JPEG_RGB_ISLOW2 b811e5ad807beb9384e51ef6a47f715d)\n      set(MD5_PPM_RGB_ISLOW 00a257f5393fef8821f2b88ac7421291)\n      set(MD5_BMP_RGB_ISLOW_565 f07d2e75073e4bb10f6c6f4d36e2e3be)\n      set(MD5_BMP_RGB_ISLOW_565D 4cfa0928ef3e6bb626d7728c924cfda4)\n      set(MD5_JPEG_422_IFAST_OPT 2540287b79d913f91665e660303ab2c8)\n      set(MD5_PPM_422_IFAST 35bd6b3f833bad23de82acea847129fa)\n      set(MD5_JPEG_440_ISLOW 538bc02bd4b4658fd85de6ece6cbeda6)\n      set(MD5_PPM_440_ISLOW 11e7eab7ef7ef3276934bb7e7b6bb377)\n      set(MD5_PPM_422M_IFAST 8dbc65323d62cca7c91ba02dd1cfa81d)\n      set(MD5_BMP_422M_IFAST_565 3294bd4d9a1f2b3d08ea6020d0db7065)\n      set(MD5_BMP_422M_IFAST_565D da98c9c7b6039511be4a79a878a9abc1)\n      set(MD5_JPEG_420_IFAST_Q100_PROG 0ba15f9dab81a703505f835f9dbbac6d)\n      set(MD5_PPM_420_Q100_IFAST 5a732542015c278ff43635e473a8a294)\n      set(MD5_PPM_420M_Q100_IFAST ff692ee9323a3b424894862557c092f1)\n      set(MD5_JPEG_GRAY_ISLOW 72b51f894b8f4a10b3ee3066770aa38d)\n      set(MD5_PPM_GRAY_ISLOW 8d3596c56eace32f205deccc229aa5ed)\n      set(MD5_PPM_GRAY_ISLOW_RGB 116424ac07b79e5e801f00508eab48ec)\n      set(MD5_BMP_GRAY_ISLOW_565 12f78118e56a2f48b966f792fedf23cc)\n      set(MD5_BMP_GRAY_ISLOW_565D bdbbd616441a24354c98553df5dc82db)\n      set(MD5_JPEG_420S_IFAST_OPT 388708217ac46273ca33086b22827ed8)\n\n      set(MD5_JPEG_3x2_FLOAT_PROG_SSE 343e3f8caf8af5986ebaf0bdc13b5c71)\n      set(MD5_PPM_3x2_FLOAT_SSE 1a75f36e5904d6fc3a85a43da9ad89bb)\n      set(MD5_JPEG_3x2_FLOAT_PROG_NO_FP_CONTRACT\n        9bca803d2042bd1eb03819e2bf92b3e5)\n      set(MD5_PPM_3x2_FLOAT_NO_FP_CONTRACT f6bfab038438ed8f5522fbd33595dcdc)\n      set(MD5_JPEG_3x2_FLOAT_PROG_FP_CONTRACT\n        ${MD5_JPEG_3x2_FLOAT_PROG_NO_FP_CONTRACT})\n      if(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n        set(MD5_PPM_3x2_FLOAT_FP_CONTRACT ${MD5_PPM_3x2_FLOAT_NO_FP_CONTRACT})\n      else()\n        set(MD5_PPM_3x2_FLOAT_FP_CONTRACT 0e917a34193ef976b679a6b069b1be26)\n      endif()\n      set(MD5_JPEG_3x2_FLOAT_PROG_387 1657664a410e0822c924b54f6f65e6e9)\n      set(MD5_PPM_3x2_FLOAT_387 cb0a1f027f3d2917c902b5640214e025)\n      set(MD5_JPEG_3x2_FLOAT_PROG_MSVC 7999ce9cd0ee9b6c7043b7351ab7639d)\n      set(MD5_PPM_3x2_FLOAT_MSVC 28cdc448a6b75e97892f0e0f8d4b21f3)\n\n      set(MD5_JPEG_3x2_IFAST_PROG 1ee5d2c1a77f2da495f993c8c7cceca5)\n      set(MD5_PPM_3x2_IFAST fd283664b3b49127984af0a7f118fccd)\n      set(MD5_JPEG_420_ISLOW_ARI e986fb0a637a8d833d96e8a6d6d84ea1)\n      set(MD5_JPEG_444_ISLOW_PROGARI 0a8f1c8f66e113c3cf635df0a475a617)\n      set(MD5_PPM_420M_IFAST_ARI 57251da28a35b46eecb7177d82d10e0e)\n      set(MD5_JPEG_420_ISLOW 9a68f56bc76e466aa7e52f415d0f4a5f)\n      set(MD5_PPM_420M_ISLOW_2_1 9f9de8c0612f8d06869b960b05abf9c9)\n      set(MD5_PPM_420M_ISLOW_15_8 b6875bc070720b899566cc06459b63b7)\n      set(MD5_PPM_420M_ISLOW_13_8 bc3452573c8152f6ae552939ee19f82f)\n      set(MD5_PPM_420M_ISLOW_11_8 d8cc73c0aaacd4556569b59437ba00a5)\n      set(MD5_PPM_420M_ISLOW_9_8 d25e61bc7eac0002f5b393aa223747b6)\n      set(MD5_PPM_420M_ISLOW_7_8 ddb564b7c74a09494016d6cd7502a946)\n      set(MD5_PPM_420M_ISLOW_3_4 8ed8e68808c3fbc4ea764fc9d2968646)\n      set(MD5_PPM_420M_ISLOW_5_8 a3363274999da2366a024efae6d16c9b)\n      set(MD5_PPM_420M_ISLOW_1_2 e692a315cea26b988c8e8b29a5dbcd81)\n      set(MD5_PPM_420M_ISLOW_3_8 79eca9175652ced755155c90e785a996)\n      set(MD5_PPM_420M_ISLOW_1_4 79cd778f8bf1a117690052cacdd54eca)\n      set(MD5_PPM_420M_ISLOW_1_8 391b3d4aca640c8567d6f8745eb2142f)\n      set(MD5_BMP_420_ISLOW_256 4980185e3776e89bd931736e1cddeee6)\n      set(MD5_BMP_420_ISLOW_565 bf9d13e16c4923b92e1faa604d7922cb)\n      set(MD5_BMP_420_ISLOW_565D 6bde71526acc44bcff76f696df8638d2)\n      set(MD5_BMP_420M_ISLOW_565 8dc0185245353cfa32ad97027342216f)\n      set(MD5_BMP_420M_ISLOW_565D ce034037d212bc403330df6f915c161b)\n      set(MD5_JPEG_LOSSLESS fc777b82d42d835ae1282ba1ee87c209)\n      set(MD5_PPM_LOSSLESS 64072f1dbdc5b3a187777788604971a5)\n      set(MD5_PPM_420_ISLOW_SKIP15_31 c4c65c1e43d7275cd50328a61e6534f0)\n      set(MD5_PPM_420_ISLOW_ARI_SKIP16_139 087c6b123db16ac00cb88c5b590bb74a)\n      set(MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71\n        26eb36ccc7d1f0cb80cdabb0ac8b5d99)\n      set(MD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 886c6775af22370257122f8b16207e6d)\n      set(MD5_PPM_444_ISLOW_SKIP1_6 5606f86874cf26b8fcee1117a0a436a6)\n      set(MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13\n        db87dc7ce26bcdc7a6b56239ce2b9d6c)\n      set(MD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 cb57b32bd6d03e35432362f7bf184b6d)\n      set(MD5_JPEG_CROP b4197f377e621c4e9b1d20471432610d)\n\n      set(MD5_JPEG_EXAMPLE_COMPRESS 95d4d72e2ef127332654c2599afb47bf)\n      set(MD5_PPM_EXAMPLE_DECOMPRESS dea1d7bbc37e39adf628342c86096641)\n    endif()\n\n    # CC: null  SAMP: fullsize  FDCT: islow  ENT: huff\n    add_bittest(${cjpeg} rgb-islow \"-revert;-rgb;-dct;int;-icc;${TESTIMAGES}/test1.icc\"\n      ${testout}_rgb_islow.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_RGB_ISLOW})\n\n    # CC: null  SAMP: fullsize  IDCT: islow  ENT: huff\n    add_bittest(${djpeg} rgb-islow\n      \"-dct;int;-ppm;-icc;${testout}_rgb_islow.icc\"\n      ${testout}_rgb_islow.ppm ${testout}_rgb_islow.jpg\n      ${MD5_PPM_RGB_ISLOW} ${cjpeg}-${libtype}-rgb-islow)\n\n    add_test(NAME ${djpeg}-${libtype}-rgb-islow-icc-cmp\n      COMMAND md5cmp b06a39d730129122e85c1363ed1bbc9e ${testout}_rgb_islow.icc)\n    set_tests_properties(${djpeg}-${libtype}-rgb-islow-icc-cmp PROPERTIES\n      DEPENDS ${djpeg}-${libtype}-rgb-islow)\n\n    add_bittest(${jpegtran} icc \"-revert;-copy;all;-icc;${TESTIMAGES}/test3.icc\"\n      ${testout}_rgb_islow2.jpg ${testout}_rgb_islow.jpg\n      ${MD5_JPEG_RGB_ISLOW2} ${cjpeg}-${libtype}-rgb-islow)\n\n    if(sample_bits EQUAL 8)\n      # CC: RGB->RGB565  SAMP: fullsize  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} rgb-islow-565 \"-dct;int;-rgb565;-dither;none;-bmp\"\n        ${testout}_rgb_islow_565.bmp ${testout}_rgb_islow.jpg\n        ${MD5_BMP_RGB_ISLOW_565} ${cjpeg}-${libtype}-rgb-islow)\n\n      # CC: RGB->RGB565 (dithered)  SAMP: fullsize  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} rgb-islow-565D \"-dct;int;-rgb565;-bmp\"\n        ${testout}_rgb_islow_565D.bmp ${testout}_rgb_islow.jpg\n        ${MD5_BMP_RGB_ISLOW_565D} ${cjpeg}-${libtype}-rgb-islow)\n    endif()\n\n    # CC: RGB->YCC  SAMP: fullsize/h2v1  FDCT: ifast  ENT: 2-pass huff\n    add_bittest(${cjpeg} 422-ifast-opt \"-revert;-sample;2x1;-dct;fast;-opt\"\n      ${testout}_422_ifast_opt.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_422_IFAST_OPT})\n\n    # CC: YCC->RGB  SAMP: fullsize/h2v1 fancy  IDCT: ifast  ENT: huff\n    add_bittest(${djpeg} 422-ifast \"-dct;fast\"\n      ${testout}_422_ifast.ppm ${testout}_422_ifast_opt.jpg\n      ${MD5_PPM_422_IFAST} ${cjpeg}-${libtype}-422-ifast-opt)\n\n    # CC: RGB->YCC  SAMP: fullsize/h1v2  FDCT: islow  ENT: huff\n    add_bittest(${cjpeg} 440-islow \"-revert;-sample;1x2;-dct;int\"\n      ${testout}_440_islow.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_440_ISLOW})\n\n    # CC: YCC->RGB  SAMP: fullsize/h1v2 fancy  IDCT: islow  ENT: huff\n    add_bittest(${djpeg} 440-islow \"-dct;int\"\n      ${testout}_440_islow.ppm ${testout}_440_islow.jpg\n      ${MD5_PPM_440_ISLOW} ${cjpeg}-${libtype}-440-islow)\n\n    # CC: YCC->RGB  SAMP: h2v1 merged  IDCT: ifast  ENT: huff\n    add_bittest(${djpeg} 422m-ifast \"-dct;fast;-nosmooth\"\n      ${testout}_422m_ifast.ppm ${testout}_422_ifast_opt.jpg\n      ${MD5_PPM_422M_IFAST} ${cjpeg}-${libtype}-422-ifast-opt)\n\n    if(sample_bits EQUAL 8)\n      # CC: YCC->RGB565  SAMP: h2v1 merged  IDCT: ifast  ENT: huff\n      add_bittest(${djpeg} 422m-ifast-565\n        \"-dct;int;-nosmooth;-rgb565;-dither;none;-bmp\"\n        ${testout}_422m_ifast_565.bmp ${testout}_422_ifast_opt.jpg\n        ${MD5_BMP_422M_IFAST_565} ${cjpeg}-${libtype}-422-ifast-opt)\n\n      # CC: YCC->RGB565 (dithered)  SAMP: h2v1 merged  IDCT: ifast  ENT: huff\n      add_bittest(${djpeg} 422m-ifast-565D \"-dct;int;-nosmooth;-rgb565;-bmp\"\n        ${testout}_422m_ifast_565D.bmp ${testout}_422_ifast_opt.jpg\n        ${MD5_BMP_422M_IFAST_565D} ${cjpeg}-${libtype}-422-ifast-opt)\n    endif()\n\n    # CC: RGB->YCC  SAMP: fullsize/h2v2  FDCT: ifast  ENT: prog huff\n    add_bittest(${cjpeg} 420-q100-ifast-prog\n      \"-revert;-sample;2x2;-quality;100;-dct;fast;-scans;${TESTIMAGES}/test.scan\"\n      ${testout}_420_q100_ifast_prog.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_420_IFAST_Q100_PROG})\n\n    # CC: YCC->RGB  SAMP: fullsize/h2v2 fancy  IDCT: ifast  ENT: prog huff\n    add_bittest(${djpeg} 420-q100-ifast-prog \"-dct;fast\"\n      ${testout}_420_q100_ifast.ppm ${testout}_420_q100_ifast_prog.jpg\n      ${MD5_PPM_420_Q100_IFAST} ${cjpeg}-${libtype}-420-q100-ifast-prog)\n\n    # CC: YCC->RGB  SAMP: h2v2 merged  IDCT: ifast  ENT: prog huff\n    add_bittest(${djpeg} 420m-q100-ifast-prog \"-dct;fast;-nosmooth\"\n      ${testout}_420m_q100_ifast.ppm ${testout}_420_q100_ifast_prog.jpg\n      ${MD5_PPM_420M_Q100_IFAST} ${cjpeg}-${libtype}-420-q100-ifast-prog)\n\n    # CC: RGB->Gray  SAMP: fullsize  FDCT: islow  ENT: huff\n    add_bittest(${cjpeg} gray-islow \"-revert;-gray;-dct;int\"\n      ${testout}_gray_islow.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_GRAY_ISLOW})\n\n    # CC: Gray->Gray  SAMP: fullsize  IDCT: islow  ENT: huff\n    add_bittest(${djpeg} gray-islow \"-dct;int\"\n      ${testout}_gray_islow.ppm ${testout}_gray_islow.jpg\n      ${MD5_PPM_GRAY_ISLOW} ${cjpeg}-${libtype}-gray-islow)\n\n    # CC: Gray->RGB  SAMP: fullsize  IDCT: islow  ENT: huff\n    add_bittest(${djpeg} gray-islow-rgb \"-dct;int;-rgb\"\n      ${testout}_gray_islow_rgb.ppm ${testout}_gray_islow.jpg\n      ${MD5_PPM_GRAY_ISLOW_RGB} ${cjpeg}-${libtype}-gray-islow)\n\n    if(sample_bits EQUAL 8)\n      # CC: Gray->RGB565  SAMP: fullsize  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} gray-islow-565 \"-dct;int;-rgb565;-dither;none;-bmp\"\n        ${testout}_gray_islow_565.bmp ${testout}_gray_islow.jpg\n        ${MD5_BMP_GRAY_ISLOW_565} ${cjpeg}-${libtype}-gray-islow)\n\n      # CC: Gray->RGB565 (dithered)  SAMP: fullsize  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} gray-islow-565D \"-dct;int;-rgb565;-bmp\"\n        ${testout}_gray_islow_565D.bmp ${testout}_gray_islow.jpg\n        ${MD5_BMP_GRAY_ISLOW_565D} ${cjpeg}-${libtype}-gray-islow)\n    endif()\n\n    # CC: RGB->YCC  SAMP: fullsize smooth/h2v2 smooth  FDCT: islow\n    # ENT: 2-pass huff\n    add_bittest(${cjpeg} 420s-ifast-opt \"-revert;-sample;2x2;-smooth;1;-dct;int;-opt\"\n      ${testout}_420s_ifast_opt.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_420S_IFAST_OPT})\n\n    if(FLOATTEST${sample_bits})\n      # CC: RGB->YCC  SAMP: fullsize/int  FDCT: float  ENT: prog huff\n      add_bittest(${cjpeg} 3x2-float-prog \"-revert;-sample;3x2;-dct;float;-prog\"\n        ${testout}_3x2_float_prog.jpg ${TESTIMAGES}/testorig.ppm\n        ${MD5_JPEG_3x2_FLOAT_PROG_${FLOATTEST${sample_bits}_UC}})\n\n      # CC: YCC->RGB  SAMP: fullsize/int  IDCT: float  ENT: prog huff\n      add_bittest(${djpeg} 3x2-float-prog \"-dct;float\"\n        ${testout}_3x2_float.ppm ${testout}_3x2_float_prog.jpg\n        ${MD5_PPM_3x2_FLOAT_${FLOATTEST${sample_bits}_UC}}\n        ${cjpeg}-${libtype}-3x2-float-prog)\n    endif()\n\n    # CC: RGB->YCC  SAMP: fullsize/int  FDCT: ifast  ENT: prog huff\n    add_bittest(${cjpeg} 3x2-ifast-prog \"-revert;-sample;3x2;-dct;fast;-prog\"\n      ${testout}_3x2_ifast_prog.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_3x2_IFAST_PROG})\n\n    # CC: YCC->RGB  SAMP: fullsize/int  IDCT: ifast  ENT: prog huff\n    add_bittest(${djpeg} 3x2-ifast-prog \"-dct;fast\"\n      ${testout}_3x2_ifast.ppm ${testout}_3x2_ifast_prog.jpg\n      ${MD5_PPM_3x2_IFAST} ${cjpeg}-${libtype}-3x2-ifast-prog)\n\n    if(WITH_ARITH_ENC AND sample_bits EQUAL 8)\n      # CC: YCC->RGB  SAMP: fullsize/h2v2  FDCT: islow  ENT: arith\n      add_bittest(${cjpeg} 420-islow-ari \"-revert;-dct;int;-arithmetic\"\n        ${testout}_420_islow_ari.jpg ${TESTIMAGES}/testorig.ppm\n        ${MD5_JPEG_420_ISLOW_ARI})\n\n      add_bittest(${jpegtran} 420-islow-ari \"-arithmetic\"\n        ${testout}_420_islow_ari2.jpg ${TESTIMAGES}/testimgint.jpg\n        ${MD5_JPEG_420_ISLOW_ARI})\n\n      # CC: YCC->RGB  SAMP: fullsize  FDCT: islow  ENT: prog arith\n      add_bittest(${cjpeg} 444-islow-progari\n        \"-revert;-sample;1x1;-dct;int;-prog;-arithmetic\"\n        ${testout}_444_islow_progari.jpg ${TESTIMAGES}/testorig.ppm\n        ${MD5_JPEG_444_ISLOW_PROGARI})\n    endif()\n\n    if(WITH_ARITH_DEC AND sample_bits EQUAL 8)\n      # CC: RGB->YCC  SAMP: h2v2 merged  IDCT: ifast  ENT: arith\n      add_bittest(${djpeg} 420m-ifast-ari \"-fast;-skip;1,20;-ppm\"\n        ${testout}_420m_ifast_ari.ppm ${TESTIMAGES}/testimgari.jpg\n        ${MD5_PPM_420M_IFAST_ARI})\n\n      add_bittest(${jpegtran} 420-islow \"\"\n        ${testout}_420_islow.jpg ${TESTIMAGES}/testimgari.jpg\n        ${MD5_JPEG_420_ISLOW})\n    endif()\n\n    # 2/1--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 16x16 islow  ENT: huff\n    # 15/8--  CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 15x15 islow  ENT: huff\n    # 13/8--  CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 13x13 islow  ENT: huff\n    # 11/8--  CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 11x11 islow  ENT: huff\n    # 9/8--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 9x9 islow  ENT: huff\n    # 7/8--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 7x7 islow/14x14 islow\n    #         ENT: huff\n    # 3/4--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 6x6 islow/12x12 islow\n    #         ENT: huff\n    # 5/8--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 5x5 islow/10x10 islow\n    #         ENT: huff\n    # 1/2--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 4x4 islow/8x8 islow\n    #         ENT: huff\n    # 3/8--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 3x3 islow/6x6 islow\n    #         ENT: huff\n    # 1/4--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 2x2 islow/4x4 islow\n    #         ENT: huff\n    # 1/8--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 1x1 islow/2x2 islow\n    #         ENT: huff\n    foreach(scale 2_1 15_8 13_8 11_8 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8)\n      string(REGEX REPLACE \"_\" \"/\" scalearg ${scale})\n      add_bittest(${djpeg} 420m-islow-${scale}\n        \"-dct;int;-scale;${scalearg};-nosmooth;-ppm\"\n        ${testout}_420m_islow_${scale}.ppm ${TESTIMAGES}/${TESTORIG}\n        ${MD5_PPM_420M_ISLOW_${scale}})\n    endforeach()\n\n    if(sample_bits EQUAL 8)\n      # CC: YCC->RGB (dithered)  SAMP: h2v2 fancy  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} 420-islow-256 \"-dct;int;-colors;256;-bmp\"\n        ${testout}_420_islow_256.bmp ${TESTIMAGES}/${TESTORIG}\n        ${MD5_BMP_420_ISLOW_256})\n\n      # CC: YCC->RGB565  SAMP: h2v2 fancy  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} 420-islow-565 \"-dct;int;-rgb565;-dither;none;-bmp\"\n        ${testout}_420_islow_565.bmp ${TESTIMAGES}/${TESTORIG}\n        ${MD5_BMP_420_ISLOW_565})\n\n      # CC: YCC->RGB565 (dithered)  SAMP: h2v2 fancy  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} 420-islow-565D \"-dct;int;-rgb565;-bmp\"\n        ${testout}_420_islow_565D.bmp ${TESTIMAGES}/${TESTORIG}\n        ${MD5_BMP_420_ISLOW_565D})\n\n      # CC: YCC->RGB565  SAMP: h2v2 merged  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} 420m-islow-565\n        \"-dct;int;-nosmooth;-rgb565;-dither;none;-bmp\"\n        ${testout}_420m_islow_565.bmp ${TESTIMAGES}/${TESTORIG}\n        ${MD5_BMP_420M_ISLOW_565})\n\n      # CC: YCC->RGB565 (dithered)  SAMP: h2v2 merged  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} 420m-islow-565D \"-dct;int;-nosmooth;-rgb565;-bmp\"\n        ${testout}_420m_islow_565D.bmp ${TESTIMAGES}/${TESTORIG}\n        ${MD5_BMP_420M_ISLOW_565D})\n    endif()\n\n    # Lossless (all arguments other than -lossless and -restart should have no\n    # effect)\n    add_bittest(${cjpeg} lossless\n      \"-revert;-lossless;4;-restart;1;-quality;1;-grayscale;-optimize;-dct;float;-smooth;100;-baseline;-qslots;1,0,0;-sample;1x2,3x4,2x1\"\n      ${testout}_lossless.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_LOSSLESS})\n    add_bittest(${djpeg} lossless\n      \"-fast;-scale;1/8;-dct;float;-dither;none;-nosmooth;-onepass\"\n      ${testout}_lossless.ppm ${testout}_lossless.jpg\n      ${MD5_PPM_LOSSLESS} ${cjpeg}-${libtype}-lossless)\n\n    # Partial decode tests.  These tests are designed to cover all of the\n    # possible code paths in jpeg_skip_scanlines().\n\n    # Context rows: Yes  Intra-iMCU row: Yes  iMCU row prefetch: No\n    # ENT: huff\n    add_bittest(${djpeg} 420-islow-skip15_31 \"-dct;int;-skip;15,31;-ppm\"\n      ${testout}_420_islow_skip15,31.ppm ${TESTIMAGES}/${TESTORIG}\n      ${MD5_PPM_420_ISLOW_SKIP15_31})\n\n    # Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: Yes\n    # ENT: arith\n    if(WITH_ARITH_DEC AND sample_bits EQUAL 8)\n      add_bittest(${djpeg} 420-islow-ari-skip16_139\n        \"-dct;int;-skip;16,139;-ppm\"\n        ${testout}_420_islow_ari_skip16,139.ppm ${TESTIMAGES}/testimgari.jpg\n        ${MD5_PPM_420_ISLOW_ARI_SKIP16_139})\n    endif()\n\n    # Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: No\n    # ENT: prog huff\n    add_test(NAME ${cjpeg}-${libtype}-420-islow-prog\n      COMMAND cjpeg${suffix} -revert -dct int -prog -precision ${sample_bits}\n        -outfile ${testout}_420_islow_prog.jpg ${TESTIMAGES}/testorig.ppm)\n    add_bittest(${djpeg} 420-islow-prog-crop62x62_71_71\n      \"-dct;int;-crop;62x62+71+71;-ppm\"\n      ${testout}_420_islow_prog_crop62x62,71,71.ppm\n      ${testout}_420_islow_prog.jpg ${MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71}\n      ${cjpeg}-${libtype}-420-islow-prog)\n\n    # Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: No\n    # ENT: arith\n    if(WITH_ARITH_DEC AND sample_bits EQUAL 8)\n      add_bittest(${djpeg} 420-islow-ari-crop53x53_4_4\n        \"-dct;int;-crop;53x53+4+4;-ppm\"\n        ${testout}_420_islow_ari_crop53x53,4,4.ppm ${TESTIMAGES}/testimgari.jpg\n        ${MD5_PPM_420_ISLOW_ARI_CROP53x53_4_4})\n    endif()\n\n    # Context rows: No   Intra-iMCU row: Yes  ENT: huff\n    add_test(NAME ${cjpeg}-${libtype}-444-islow\n      COMMAND cjpeg${suffix} -revert -dct int -sample 1x1 -precision ${sample_bits}\n        -outfile ${testout}_444_islow.jpg ${TESTIMAGES}/testorig.ppm)\n    add_bittest(${djpeg} 444-islow-skip1_6 \"-dct;int;-skip;1,6;-ppm\"\n      ${testout}_444_islow_skip1,6.ppm ${testout}_444_islow.jpg\n      ${MD5_PPM_444_ISLOW_SKIP1_6} ${cjpeg}-${libtype}-444-islow)\n\n    # Context rows: No   Intra-iMCU row: No   ENT: prog huff\n    add_test(NAME ${cjpeg}-${libtype}-444-islow-prog\n      COMMAND cjpeg${suffix} -revert -dct int -prog -precision ${sample_bits}\n        -sample 1x1 -outfile ${testout}_444_islow_prog.jpg\n        ${TESTIMAGES}/testorig.ppm)\n    add_bittest(${djpeg} 444-islow-prog-crop98x98_13_13\n      \"-dct;int;-crop;98x98+13+13;-ppm\"\n      ${testout}_444_islow_prog_crop98x98,13,13.ppm\n      ${testout}_444_islow_prog.jpg ${MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13}\n      ${cjpeg}-${libtype}-444-islow-prog)\n\n    # Context rows: No   Intra-iMCU row: No   ENT: arith\n    if(WITH_ARITH_ENC AND sample_bits EQUAL 8)\n      add_test(NAME ${cjpeg}-${libtype}-444-islow-ari\n        COMMAND cjpeg${suffix} -revert -dct int -arithmetic -sample 1x1\n          -precision ${sample_bits} -outfile ${testout}_444_islow_ari.jpg\n          ${TESTIMAGES}/testorig.ppm)\n      if(WITH_ARITH_DEC)\n        add_bittest(${djpeg} 444-islow-ari-crop37x37_0_0\n          \"-dct;int;-crop;37x37+0+0;-ppm\"\n          ${testout}_444_islow_ari_crop37x37,0,0.ppm\n          ${testout}_444_islow_ari.jpg ${MD5_PPM_444_ISLOW_ARI_CROP37x37_0_0}\n          ${cjpeg}-${libtype}-444-islow-ari)\n      endif()\n    endif()\n\n    add_bittest(${jpegtran} crop \"-revert;-crop;120x90+20+50;-transpose;-perfect\"\n      ${testout}_crop.jpg ${TESTIMAGES}/${TESTORIG}\n      ${MD5_JPEG_CROP})\n\n    unset(EXAMPLE_12BIT_ARG)\n    if(sample_bits EQUAL 12)\n      set(EXAMPLE_12BIT_ARG \"-precision;12\")\n    endif()\n\n    add_test(NAME example-${sample_bits}bit-${libtype}-compress\n      COMMAND example${suffix} compress -q 95 ${EXAMPLE_12BIT_ARG}\n        ${testout}-example.jpg)\n    add_test(NAME example-${sample_bits}bit-${libtype}-compress-cmp\n      COMMAND md5cmp ${MD5_JPEG_EXAMPLE_COMPRESS} ${testout}-example.jpg)\n    set_tests_properties(example-${sample_bits}bit-${libtype}-compress-cmp\n      PROPERTIES DEPENDS example-${sample_bits}bit-${libtype}-compress)\n\n    add_test(NAME example-${sample_bits}bit-${libtype}-decompress\n      COMMAND example${suffix} decompress ${EXAMPLE_12BIT_ARG}\n        ${TESTIMAGES}/${TESTORIG} ${testout}-example.ppm)\n    add_test(NAME example-${sample_bits}bit-${libtype}-decompress-cmp\n      COMMAND md5cmp ${MD5_PPM_EXAMPLE_DECOMPRESS} ${testout}-example.ppm)\n    set_tests_properties(example-${sample_bits}bit-${libtype}-decompress-cmp\n      PROPERTIES DEPENDS example-${sample_bits}bit-${libtype}-decompress)\n\n  endforeach()\n\nendforeach()\n\nadd_custom_target(testclean COMMAND ${CMAKE_COMMAND} -P\n  ${CMAKE_CURRENT_SOURCE_DIR}/cmakescripts/testclean.cmake)\n\nconfigure_file(croptest.in croptest @ONLY)\nadd_custom_target(croptest\n  COMMAND echo croptest\n  COMMAND ${BASH} ${CMAKE_CURRENT_BINARY_DIR}/croptest)\n\nif(WITH_TURBOJPEG)\n  configure_file(tjbenchtest.in tjbenchtest @ONLY)\n  configure_file(tjexampletest.in tjexampletest @ONLY)\n  if(WIN32)\n    set(BASH bash)\n  endif()\n  add_custom_target(tjtest COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=8 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    DEPENDS ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n      ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest\n      ${CMAKE_CURRENT_BINARY_DIR}/tjexampletest)\n  add_custom_target(tjtest12 COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=12 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    DEPENDS ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n      ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest\n      ${CMAKE_CURRENT_BINARY_DIR}/tjexampletest)\n  add_custom_target(tjtest16 COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=16 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    DEPENDS ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n      ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest\n      ${CMAKE_CURRENT_BINARY_DIR}/tjexampletest)\nendif()\n\n\n###############################################################################\n# INSTALLATION\n###############################################################################\n\nset(EXE ${CMAKE_EXECUTABLE_SUFFIX})\n\nif(WITH_TURBOJPEG)\n  if(BUILD_SHARED_LIBS)\n    install(TARGETS turbojpeg EXPORT ${CMAKE_PROJECT_NAME}Targets\n      INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n      ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT lib\n      LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT lib\n      RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin)\n    install(TARGETS tjbench\n      RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin)\n    if(NOT CMAKE_VERSION VERSION_LESS \"3.1\" AND MSVC_LIKE AND\n      CMAKE_C_LINKER_SUPPORTS_PDB)\n      install(FILES \"$<TARGET_PDB_FILE:turbojpeg>\"\n        DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin OPTIONAL)\n    endif()\n  endif()\n  if(NOT BUILD_SHARED_LIBS)\n    install(TARGETS turbojpeg-static EXPORT ${CMAKE_PROJECT_NAME}Targets\n      INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n      ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT lib)\n    if(NOT BUILD_SHARED_LIBS)\n      if(GENERATOR_IS_MULTI_CONFIG)\n        set(DIR \"${CMAKE_CURRENT_BINARY_DIR}/\\${CMAKE_INSTALL_CONFIG_NAME}\")\n      else()\n        set(DIR ${CMAKE_CURRENT_BINARY_DIR})\n      endif()\n      install(PROGRAMS ${DIR}/tjbench-static${EXE}\n        DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin RENAME tjbench${EXE})\n    endif()\n  endif()\n  install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/turbojpeg.h\n    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} COMPONENT include)\nendif()\n\nif(NOT BUILD_SHARED_LIBS)\n  install(TARGETS jpeg-static EXPORT ${CMAKE_PROJECT_NAME}Targets\n    INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT lib)\n  if(NOT BUILD_SHARED_LIBS)\n    if(GENERATOR_IS_MULTI_CONFIG)\n      set(DIR \"${CMAKE_CURRENT_BINARY_DIR}/\\${CMAKE_INSTALL_CONFIG_NAME}\")\n    else()\n      set(DIR ${CMAKE_CURRENT_BINARY_DIR})\n    endif()\n    install(PROGRAMS ${DIR}/cjpeg-static${EXE}\n      DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin RENAME cjpeg${EXE})\n    install(PROGRAMS ${DIR}/djpeg-static${EXE}\n      DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin RENAME djpeg${EXE})\n    install(PROGRAMS ${DIR}/jpegtran-static${EXE}\n      DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin RENAME jpegtran${EXE})\n  endif()\nendif()\n\ninstall(TARGETS rdjpgcom wrjpgcom\n  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin)\n\ninstall(FILES ${CMAKE_CURRENT_SOURCE_DIR}/README.ijg\n  ${CMAKE_CURRENT_SOURCE_DIR}/README.md ${CMAKE_CURRENT_SOURCE_DIR}/example.c\n  ${CMAKE_CURRENT_SOURCE_DIR}/tjexample.c\n  ${CMAKE_CURRENT_SOURCE_DIR}/libjpeg.txt\n  ${CMAKE_CURRENT_SOURCE_DIR}/structure.txt\n  ${CMAKE_CURRENT_SOURCE_DIR}/usage.txt ${CMAKE_CURRENT_SOURCE_DIR}/wizard.txt\n  ${CMAKE_CURRENT_SOURCE_DIR}/LICENSE.md DESTINATION ${CMAKE_INSTALL_DOCDIR}\n  COMPONENT doc)\nif(WITH_JAVA)\n  install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/java/TJExample.java\n    DESTINATION ${CMAKE_INSTALL_DOCDIR} COMPONENT doc)\nendif()\n\nif(UNIX OR MINGW)\n  install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/cjpeg.1\n    ${CMAKE_CURRENT_SOURCE_DIR}/djpeg.1 ${CMAKE_CURRENT_SOURCE_DIR}/jpegtran.1\n    ${CMAKE_CURRENT_SOURCE_DIR}/rdjpgcom.1\n    ${CMAKE_CURRENT_SOURCE_DIR}/wrjpgcom.1\n    DESTINATION ${CMAKE_INSTALL_MANDIR}/man1 COMPONENT man)\nendif()\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/pkgscripts/libjpeg.pc\n  DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig COMPONENT lib)\nif(WITH_TURBOJPEG)\n  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/pkgscripts/libturbojpeg.pc\n    DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig COMPONENT lib)\nendif()\ninstall(FILES\n  ${CMAKE_CURRENT_BINARY_DIR}/pkgscripts/${CMAKE_PROJECT_NAME}Config.cmake\n  ${CMAKE_CURRENT_BINARY_DIR}/pkgscripts/${CMAKE_PROJECT_NAME}ConfigVersion.cmake\n  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${CMAKE_PROJECT_NAME}\n  COMPONENT lib)\ninstall(EXPORT ${CMAKE_PROJECT_NAME}Targets\n  NAMESPACE ${CMAKE_PROJECT_NAME}::\n  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${CMAKE_PROJECT_NAME}\n  COMPONENT lib)\n\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/jconfig.h\n  ${CMAKE_CURRENT_SOURCE_DIR}/jerror.h ${CMAKE_CURRENT_SOURCE_DIR}/jmorecfg.h\n  ${CMAKE_CURRENT_SOURCE_DIR}/jpeglib.h\n  DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} COMPONENT include)\n\ninclude(cmakescripts/BuildPackages.cmake)\n\nconfigure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/cmakescripts/cmake_uninstall.cmake.in\"\n  \"cmake_uninstall.cmake\" IMMEDIATE @ONLY)\n\nadd_custom_target(uninstall COMMAND ${CMAKE_COMMAND} -P cmake_uninstall.cmake)\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.6748046875,
          "content": "# Community Participation Guidelines\n\nThis repository is governed by Mozilla's code of conduct and etiquette guidelines. \nFor more details, please read the\n[Mozilla Community Participation Guidelines](https://www.mozilla.org/about/governance/policies/participation/). \n\n## How to Report\nFor more information on how to report violations of the Community Participation Guidelines, please read our '[How to Report](https://www.mozilla.org/about/governance/policies/participation/reporting/)' page.\n\n<!--\n## Project Specific Etiquette\n\nIn some cases, there will be additional project etiquette i.e.: (https://bugzilla.mozilla.org/page.cgi?id=etiquette.html).\nPlease update for your project.\n-->\n"
        },
        {
          "name": "ChangeLog.md",
          "type": "blob",
          "size": 112.5390625,
          "content": "3.0.5\n=====\n\n### Significant changes relative to 3.0.4:\n\n1. Fixed an issue in the TurboJPEG API whereby, when generating a\n12-bit-per-sample or 16-bit-per-sample lossless JPEG image, specifying a point\ntransform value greater than 7 resulted in an error (\"Parameter value out of\nrange\".)\n\n2. Fixed a regression introduced by 1.4 beta1[3] that prevented\n`jpeg_set_defaults()` from resetting the Huffman tables to default (baseline)\nvalues if Huffman table optimization or progressive mode was previously enabled\nin the same libjpeg instance.\n\n3. Fixed an issue whereby lossless JPEG compression could not be disabled if it\nwas previously enabled in a libjpeg or TurboJPEG instance.\n`jpeg_set_defaults()` now disables lossless JPEG compression in a libjpeg\ninstance, and setting `TJPARAM_LOSSLESS`/`TJ.PARAM_LOSSLESS` to `0` now\ndisables lossless JPEG compression in a TurboJPEG instance.\n\n4. Hardened the libjpeg API against hypothetical calling applications that may\nerroneously change the value of the `data_precision` field in\n`jpeg_compress_struct` or `jpeg_decompress_struct` after calling\n`jpeg_start_compress()` or `jpeg_start_decompress()`.\n\n\n3.0.4\n=====\n\n### Significant changes relative to 3.0.3:\n\n1. Fixed an issue whereby the CPU usage of the default marker processor in the\ndecompressor grew exponentially with the number of markers.  This caused an\nunreasonable slow-down in `jpeg_read_header()` if an application called\n`jpeg_save_markers()` to save markers of a particular type and then attempted\nto decompress a JPEG image containing an excessive number of markers of that\ntype.\n\n2. Hardened the default marker processor in the decompressor to guard against\nan issue (exposed by 3.0 beta2[6]) whereby attempting to decompress a\nspecially-crafted malformed JPEG image (specifically an image with a complete\n12-bit-per-sample Start Of Frame segment followed by an incomplete\n8-bit-per-sample Start Of Frame segment) using buffered-image mode and input\nprefetching caused a segfault if the `fill_input_buffer()` method in the\ncalling application's custom source manager incorrectly returned `FALSE` in\nresponse to a prematurely-terminated JPEG data stream.\n\n3. Fixed an issue in cjpeg whereby, when generating a 12-bit-per-sample or\n16-bit-per-sample lossless JPEG image, specifying a point transform value\ngreater than 7 resulted in an error (\"Invalid progressive/lossless parameters\")\nunless the `-precision` option was specified before the `-lossless` option.\n\n4. Fixed a regression introduced by 3.0.3[3] that made it impossible for\ncalling applications to generate 12-bit-per-sample arithmetic-coded lossy JPEG\nimages using the TurboJPEG API.\n\n5. Fixed an error (\"Destination buffer is not large enough\") that occurred when\nattempting to generate a full-color lossless JPEG image using the TurboJPEG\nJava API's `byte[] TJCompressor.compress()` method if the value of\n`TJ.PARAM_SUBSAMP` was not `TJ.SAMP_444`.\n\n6. Fixed a segfault in djpeg that occurred if a negative width was specified\nwith the `-crop` option.  Since the cropping region width was read into an\nunsigned 32-bit integer, a negative width was interpreted as a very large\nvalue.  With certain negative width and positive left boundary values, the\nbounds checks in djpeg and `jpeg_crop_scanline()` overflowed and did not detect\nthe out-of-bounds width, which caused a buffer overrun in the upsampling or\ncolor conversion routine.  Both bounds checks now use 64-bit integers to guard\nagainst overflow, and djpeg now checks for negative numbers when it parses the\ncrop specification from the command line.\n\n7. Fixed an issue whereby the TurboJPEG lossless transformation function and\nmethods checked the specified cropping region against the source image\ndimensions and level of chrominance subsampling rather than the destination\nimage dimensions and level of chrominance subsampling, which caused some\ncropping regions to be unduly rejected when performing 90-degree rotation,\n270-degree rotation, transposition, transverse transposition, or grayscale\nconversion.\n\n8. Fixed a regression, introduced by 3.0 beta2[4], that prevented the\n`tjTransform()` backward compatibility function from copying extra markers from\nthe source image to the destination image.\n\n9. Fixed an issue whereby the TurboJPEG lossless transformation function and\nmethods did not honor `TJXOPT_COPYNONE`/`TJTransform.OPT_COPYNONE` unless it\nwas specified for all lossless transforms.\n\n\n3.0.3\n=====\n\n### Significant changes relative to 3.0.2:\n\n1. Fixed an issue in the build system, introduced in 3.0.2, that caused all\nlibjpeg-turbo components to depend on the Visual C++ run-time DLL when built\nwith Visual C++ and CMake 3.15 or later, regardless of value of the\n`WITH_CRT_DLL` CMake variable.\n\n2. The x86-64 SIMD extensions now include support for Intel Control-flow\nEnforcement Technology (CET), which is enabled automatically if CET is enabled\nin the C compiler.\n\n3. Fixed a regression introduced by 3.0 beta2[6] that made it impossible for\ncalling applications to supply custom Huffman tables when generating\n12-bit-per-component lossy JPEG images using the libjpeg API.\n\n4. Fixed a segfault that occurred when attempting to use the jpegtran `-drop`\noption with a specially-crafted malformed input image or drop image\n(specifically an image in which all of the scans contain fewer components than\nthe number of components specified in the Start Of Frame segment.)\n\n\n3.0.2\n=====\n\n### Significant changes relative to 3.0.1:\n\n1. Fixed a signed integer overflow in the `tj3CompressFromYUV8()`,\n`tj3DecodeYUV8()`, `tj3DecompressToYUV8()`, and `tj3EncodeYUV8()` functions,\ndetected by the Clang and GCC undefined behavior sanitizers, that could be\ntriggered by setting the `align` parameter to an unreasonably large value.\nThis issue did not pose a security threat, but removing the warning made it\neasier to detect actual security issues, should they arise in the future.\n\n2. Introduced a new parameter (`TJPARAM_MAXMEMORY` in the TurboJPEG C API and\n`TJ.PARAM_MAXMEMORY` in the TurboJPEG Java API) and a corresponding TJBench\noption (`-maxmemory`) for specifying the maximum amount of memory (in\nmegabytes) that will be allocated for intermediate buffers, which are used with\nprogressive JPEG compression and decompression, Huffman table optimization,\nlossless JPEG compression, and lossless transformation.  The new parameter and\noption serve the same purpose as the `max_memory_to_use` field in the\n`jpeg_memory_mgr` struct in the libjpeg API, the `JPEGMEM` environment\nvariable, and the cjpeg/djpeg/jpegtran `-maxmemory` option.\n\n3. Introduced a new parameter (`TJPARAM_MAXPIXELS` in the TurboJPEG C API and\n`TJ.PARAM_MAXPIXELS` in the TurboJPEG Java API) and a corresponding TJBench\noption (`-maxpixels`) for specifying the maximum number of pixels that the\ndecompression, lossless transformation, and packed-pixel image loading\nfunctions/methods will process.\n\n4. Fixed an error (\"Unsupported color conversion request\") that occurred when\nattempting to decompress a 3-component lossless JPEG image without an Adobe\nAPP14 marker.  The decompressor now assumes that a 3-component lossless JPEG\nimage without an Adobe APP14 marker uses the RGB colorspace if its component\nIDs are 1, 2, and 3.\n\n\n3.0.1\n=====\n\n### Significant changes relative to 3.0.0:\n\n1. The x86-64 SIMD functions now use a standard stack frame, prologue, and\nepilogue so that debuggers and profilers can reliably capture backtraces from\nwithin the functions.\n\n2. Fixed two minor issues in the interblock smoothing algorithm that caused\nmathematical (but not necessarily perceptible) edge block errors when\ndecompressing progressive JPEG images exactly two DCT blocks in width or that\nuse vertical chrominance subsampling.\n\n3. Fixed a regression introduced by 3.0 beta2[6] that, in rare cases, caused\nthe C Huffman encoder (which is not used by default on x86 and Arm CPUs) to\ngenerate incorrect results if the Neon SIMD extensions were explicitly disabled\nat build time (by setting the `WITH_SIMD` CMake variable to `0`) in an AArch64\nbuild of libjpeg-turbo.\n\n\n3.0.0\n=====\n\n### Significant changes relative to 3.0 beta2:\n\n1. The TurboJPEG API now supports 4:4:1 (transposed 4:1:1) chrominance\nsubsampling, which allows losslessly transposed or rotated 4:1:1 JPEG images to\nbe losslessly cropped, partially decompressed, or decompressed to planar YUV\nimages.\n\n2. Fixed various segfaults and buffer overruns (CVE-2023-2804) that occurred\nwhen attempting to decompress various specially-crafted malformed\n12-bit-per-component and 16-bit-per-component lossless JPEG images using color\nquantization or merged chroma upsampling/color conversion.  The underlying\ncause of these issues was that the color quantization and merged chroma\nupsampling/color conversion algorithms were not designed with lossless\ndecompression in mind.  Since libjpeg-turbo explicitly does not support color\nconversion when compressing or decompressing lossless JPEG images, merged\nchroma upsampling/color conversion never should have been enabled for such\nimages.  Color quantization is a legacy feature that serves little or no\npurpose with lossless JPEG images, so it is also now disabled when\ndecompressing such images.  (As a result, djpeg can no longer decompress a\nlossless JPEG image into a GIF image.)\n\n3. Fixed an oversight in 1.4 beta1[8] that caused various segfaults and buffer\noverruns when attempting to decompress various specially-crafted malformed\n12-bit-per-component JPEG images using djpeg with both color quantization and\nRGB565 color conversion enabled.\n\n4. Fixed an issue whereby `jpeg_crop_scanline()` sometimes miscalculated the\ndownsampled width for components with 4x2 or 2x4 subsampling factors if\ndecompression scaling was enabled.  This caused the components to be upsampled\nincompletely, which caused the color converter to read from uninitialized\nmemory.  With 12-bit data precision, this caused a buffer overrun or underrun\nand subsequent segfault if the sample value read from uninitialized memory was\noutside of the valid sample range.\n\n5. Fixed a long-standing issue whereby the `tj3Transform()` function, when used\nwith the `TJXOP_TRANSPOSE`, `TJXOP_TRANSVERSE`, `TJXOP_ROT90`, or\n`TJXOP_ROT270` transform operation and without automatic JPEG destination\nbuffer (re)allocation or lossless cropping, computed the worst-case transformed\nJPEG image size based on the source image dimensions rather than the\ntransformed image dimensions.  If a calling program allocated the JPEG\ndestination buffer based on the transformed image dimensions, as the API\ndocumentation instructs, and attempted to transform a specially-crafted 4:2:2,\n4:4:0, 4:1:1, or 4:4:1 JPEG source image containing a large amount of metadata,\nthe issue caused `tj3Transform()` to overflow the JPEG destination buffer\nrather than fail gracefully.  The issue could be worked around by setting\n`TJXOPT_COPYNONE`.  Note that, irrespective of this issue, `tj3Transform()`\ncannot reliably transform JPEG source images that contain a large amount of\nmetadata unless automatic JPEG destination buffer (re)allocation is used or\n`TJXOPT_COPYNONE` is set.\n\n6. Fixed a regression introduced by 3.0 beta2[6] that prevented the djpeg\n`-map` option from working when decompressing 12-bit-per-component lossy JPEG\nimages.\n\n7. Fixed an issue that caused the C Huffman encoder (which is not used by\ndefault on x86 and Arm CPUs) to read from uninitialized memory when attempting\nto transform a specially-crafted malformed arithmetic-coded JPEG source image\ninto a baseline Huffman-coded JPEG destination image.\n\n\n2.1.91 (3.0 beta2)\n==================\n\n### Significant changes relative to 2.1.5.1:\n\n1. Significantly sped up the computation of optimal Huffman tables.  This\nspeeds up the compression of tiny images by as much as 2x and provides a\nnoticeable speedup for images as large as 256x256 when using optimal Huffman\ntables.\n\n2. All deprecated fields, constructors, and methods in the TurboJPEG Java API\nhave been removed.\n\n3. Arithmetic entropy coding is now supported with 12-bit-per-component JPEG\nimages.\n\n4. Overhauled the TurboJPEG API to address long-standing limitations and to\nmake the API more extensible and intuitive:\n\n     - All C function names are now prefixed with `tj3`, and all version\nsuffixes have been removed from the function names.  Future API overhauls will\nincrement the prefix to `tj4`, etc., thus retaining backward API/ABI\ncompatibility without versioning each individual function.\n     - Stateless boolean flags have been replaced with stateful integer API\nparameters, the values of which persist between function calls.  New\nfunctions/methods (`tj3Set()`/`TJCompressor.set()`/`TJDecompressor.set()` and\n`tj3Get()`/`TJCompressor.get()`/`TJDecompressor.get()`) can be used to set and\nquery the value of a particular API parameter.\n     - The JPEG quality and subsampling are now implemented using API\nparameters rather than stateless function arguments (C) or dedicated set/get\nmethods (Java.)\n     - `tj3DecompressHeader()` now stores all relevant information about the\nJPEG image, including the width, height, subsampling type, entropy coding\nalgorithm, etc., in API parameters rather than returning that information\nthrough pointer arguments.\n     - `TJFLAG_LIMITSCANS`/`TJ.FLAG_LIMITSCANS` has been reimplemented as an\nAPI parameter (`TJPARAM_SCANLIMIT`/`TJ.PARAM_SCANLIMIT`) that allows the number\nof scans to be specified.\n     - Huffman table optimization can now be specified using a new API\nparameter (`TJPARAM_OPTIMIZE`/`TJ.PARAM_OPTIMIZE`), a new transform option\n(`TJXOPT_OPTIMIZE`/`TJTransform.OPT_OPTIMIZE`), and a new TJBench option\n(`-optimize`.)\n     - Arithmetic entropy coding can now be specified or queried, using a new\nAPI parameter (`TJPARAM_ARITHMETIC`/`TJ.PARAM_ARITHMETIC`), a new transform\noption (`TJXOPT_ARITHMETIC`/`TJTransform.OPT_ARITHMETIC`), and a new TJBench\noption (`-arithmetic`.)\n     - The restart marker interval can now be specified, using new API\nparameters (`TJPARAM_RESTARTROWS`/`TJ.PARAM_RESTARTROWS` and\n`TJPARAM_RESTARTBLOCKS`/`TJ.PARAM_RESTARTBLOCKS`) and a new TJBench option\n(`-restart`.)\n     - Pixel density can now be specified or queried, using new API parameters\n(`TJPARAM_XDENSITY`/`TJ.PARAM_XDENSITY`,\n`TJPARAM_YDENSITY`/`TJ.PARAM_YDENSITY`, and\n`TJPARAM_DENSITYUNITS`/`TJ.PARAM_DENSITYUNITS`.)\n     - The accurate DCT/IDCT algorithms are now the default for both\ncompression and decompression, since the \"fast\" algorithms are considered to be\na legacy feature.  (The \"fast\" algorithms do not pass the ISO compliance tests,\nand those algorithms are not any faster than the accurate algorithms on modern\nx86 CPUs.)\n     - All C initialization functions have been combined into a single function\n(`tj3Init()`) that accepts an integer argument specifying the subsystems to\ninitialize.\n     - All C functions now use the `const` keyword for pointer arguments that\npoint to unmodified buffers (and for both dimensions of pointer arguments that\npoint to sets of unmodified buffers.)\n     - All C functions now use `size_t` rather than `unsigned long` to\nrepresent buffer sizes, for compatibility with `malloc()` and to avoid\ndisparities in the size of `unsigned long` between LP64 (Un*x) and LLP64\n(Windows) operating systems.\n     - All C buffer size functions now return 0 if an error occurs, rather than\ntrying to awkwardly return -1 in an unsigned data type (which could easily be\nmisinterpreted as a very large value.)\n     - Decompression scaling is now enabled explicitly, using a new\nfunction/method (`tj3SetScalingFactor()`/`TJDecompressor.setScalingFactor()`),\nrather than implicitly using awkward \"desired width\"/\"desired height\"\narguments.\n     - Partial image decompression has been implemented, using a new\nfunction/method (`tj3SetCroppingRegion()`/`TJDecompressor.setCroppingRegion()`)\nand a new TJBench option (`-crop`.)\n     - The JPEG colorspace can now be specified explicitly when compressing,\nusing a new API parameter (`TJPARAM_COLORSPACE`/`TJ.PARAM_COLORSPACE`.)  This\nallows JPEG images with the RGB and CMYK colorspaces to be created.\n     - TJBench no longer generates error/difference images, since identical\nfunctionality is already available in ImageMagick.\n     - JPEG images with unknown subsampling configurations can now be\nfully decompressed into packed-pixel images or losslessly transformed (with the\nexception of lossless cropping.)  They cannot currently be partially\ndecompressed or decompressed into planar YUV images.\n     - `tj3Destroy()` now silently accepts a NULL handle.\n     - `tj3Alloc()` and `tj3Free()` now return/accept void pointers, as\n`malloc()` and `free()` do.\n     - The C image I/O functions now accept a TurboJPEG instance handle, which\nis used to transmit/receive API parameter values and to receive error\ninformation.\n\n5. Added support for 8-bit-per-component, 12-bit-per-component, and\n16-bit-per-component lossless JPEG images.  A new libjpeg API function\n(`jpeg_enable_lossless()`), TurboJPEG API parameters\n(`TJPARAM_LOSSLESS`/`TJ.PARAM_LOSSLESS`,\n`TJPARAM_LOSSLESSPSV`/`TJ.PARAM_LOSSLESSPSV`, and\n`TJPARAM_LOSSLESSPT`/`TJ.PARAM_LOSSLESSPT`), and a cjpeg/TJBench option\n(`-lossless`) can be used to create a lossless JPEG image.  (Decompression of\nlossless JPEG images is handled automatically.)  Refer to\n[libjpeg.txt](libjpeg.txt), [usage.txt](usage.txt), and the TurboJPEG API\ndocumentation for more details.\n\n6. Added support for 12-bit-per-component (lossy and lossless) and\n16-bit-per-component (lossless) JPEG images to the libjpeg and TurboJPEG APIs:\n\n     - The existing `data_precision` field in `jpeg_compress_struct` and\n`jpeg_decompress_struct` has been repurposed to enable the creation of\n12-bit-per-component and 16-bit-per-component JPEG images or to detect whether\na 12-bit-per-component or 16-bit-per-component JPEG image is being\ndecompressed.\n     - New 12-bit-per-component and 16-bit-per-component versions of\n`jpeg_write_scanlines()` and `jpeg_read_scanlines()`, as well as new\n12-bit-per-component versions of `jpeg_write_raw_data()`,\n`jpeg_skip_scanlines()`, `jpeg_crop_scanline()`, and `jpeg_read_raw_data()`,\nprovide interfaces for compressing from/decompressing to 12-bit-per-component\nand 16-bit-per-component packed-pixel and planar YUV image buffers.\n     - New 12-bit-per-component and 16-bit-per-component compression,\ndecompression, and image I/O functions/methods have been added to the TurboJPEG\nAPI, and a new API parameter (`TJPARAM_PRECISION`/`TJ.PARAM_PRECISION`) can be\nused to query the data precision of a JPEG image.  (YUV functions are currently\nlimited to 8-bit data precision but can be expanded to accommodate 12-bit data\nprecision in the future, if such is deemed beneficial.)\n     - A new cjpeg and TJBench command-line argument (`-precision`) can be used\nto create a 12-bit-per-component or 16-bit-per-component JPEG image.\n(Decompression and transformation of 12-bit-per-component and\n16-bit-per-component JPEG images is handled automatically.)\n\n    Refer to [libjpeg.txt](libjpeg.txt), [usage.txt](usage.txt), and the\nTurboJPEG API documentation for more details.\n\n\n2.1.5.1\n=======\n\n### Significant changes relative to 2.1.5:\n\n1. The SIMD dispatchers in libjpeg-turbo 2.1.4 and prior stored the list of\nsupported SIMD instruction sets in a global variable, which caused an innocuous\nrace condition whereby the variable could have been initialized multiple times\nif `jpeg_start_*compress()` was called simultaneously in multiple threads.\nlibjpeg-turbo 2.1.5 included an undocumented attempt to fix this race condition\nby making the SIMD support variable thread-local.  However, that caused another\nissue whereby, if `jpeg_start_*compress()` was called in one thread and\n`jpeg_read_*()` or `jpeg_write_*()` was called in a second thread, the SIMD\nsupport variable was never initialized in the second thread.  On x86 systems,\nthis led the second thread to incorrectly assume that AVX2 instructions were\nalways available, and when it attempted to use those instructions on older x86\nCPUs that do not support them, an illegal instruction error occurred.  The SIMD\ndispatchers now ensure that the SIMD support variable is initialized before\ndispatching based on its value.\n\n\n2.1.5\n=====\n\n### Significant changes relative to 2.1.4:\n\n1. Fixed issues in the build system whereby, when using the Ninja Multi-Config\nCMake generator, a static build of libjpeg-turbo (a build in which\n`ENABLE_SHARED` is `0`) could not be installed, a Windows installer could not\nbe built, and the Java regression tests failed.\n\n2. Fixed a regression introduced by 2.0 beta1[15] that caused a buffer overrun\nin the progressive Huffman encoder when attempting to transform a\nspecially-crafted malformed 12-bit-per-component JPEG image into a progressive\n12-bit-per-component JPEG image using a 12-bit-per-component build of\nlibjpeg-turbo (`-DWITH_12BIT=1`.)  Given that the buffer overrun was fully\ncontained within the progressive Huffman encoder structure and did not cause a\nsegfault or other user-visible errant behavior, given that the lossless\ntransformer (unlike the decompressor) is not generally exposed to arbitrary\ndata exploits, and given that 12-bit-per-component builds of libjpeg-turbo are\nuncommon, this issue did not likely pose a security risk.\n\n3. Fixed an issue whereby, when using a 12-bit-per-component build of\nlibjpeg-turbo (`-DWITH_12BIT=1`), passing samples with values greater than 4095\nor less than 0 to `jpeg_write_scanlines()` caused a buffer overrun or underrun\nin the RGB-to-YCbCr color converter.\n\n4. Fixed a floating point exception that occurred when attempting to use the\njpegtran `-drop` and `-trim` options to losslessly transform a\nspecially-crafted malformed JPEG image.\n\n5. Fixed an issue in `tjBufSizeYUV2()` whereby it returned a bogus result,\nrather than throwing an error, if the `align` parameter was not a power of 2.\nFixed a similar issue in `tjCompressFromYUV()` whereby it generated a corrupt\nJPEG image in certain cases, rather than throwing an error, if the `align`\nparameter was not a power of 2.\n\n6. Fixed an issue whereby `tjDecompressToYUV2()`, which is a wrapper for\n`tjDecompressToYUVPlanes()`, used the desired YUV image dimensions rather than\nthe actual scaled image dimensions when computing the plane pointers and\nstrides to pass to `tjDecompressToYUVPlanes()`.  This caused a buffer overrun\nand subsequent segfault if the desired image dimensions exceeded the scaled\nimage dimensions.\n\n7. Fixed an issue whereby, when decompressing a 12-bit-per-component JPEG image\n(`-DWITH_12BIT=1`) using an alpha-enabled output color space such as\n`JCS_EXT_RGBA`, the alpha channel was set to 255 rather than 4095.\n\n8. Fixed an issue whereby the Java version of TJBench did not accept a range of\nquality values.\n\n9. Fixed an issue whereby, when `-progressive` was passed to TJBench, the JPEG\ninput image was not transformed into a progressive JPEG image prior to\ndecompression.\n\n\n2.1.4\n=====\n\n### Significant changes relative to 2.1.3:\n\n1. Fixed a regression introduced in 2.1.3 that caused build failures with\nVisual Studio 2010.\n\n2. The `tjDecompressHeader3()` function in the TurboJPEG C API and the\n`TJDecompressor.setSourceImage()` method in the TurboJPEG Java API now accept\n\"abbreviated table specification\" (AKA \"tables-only\") datastreams, which can be\nused to prime the decompressor with quantization and Huffman tables that can be\nused when decompressing subsequent \"abbreviated image\" datastreams.\n\n3. libjpeg-turbo now performs run-time detection of AltiVec instructions on\nOS X/PowerPC systems if AltiVec instructions are not enabled at compile time.\nThis allows both AltiVec-equipped (PowerPC G4 and G5) and non-AltiVec-equipped\n(PowerPC G3) CPUs to be supported using the same build of libjpeg-turbo.\n\n4. Fixed an error (\"Bogus virtual array access\") that occurred when attempting\nto decompress a progressive JPEG image with a height less than or equal to one\niMCU (8 * the vertical sampling factor) using buffered-image mode with\ninterblock smoothing enabled.  This was a regression introduced by\n2.1 beta1[6(b)].\n\n5. Fixed two issues that prevented partial image decompression from working\nproperly with buffered-image mode:\n\n     - Attempting to call `jpeg_crop_scanline()` after\n`jpeg_start_decompress()` but before `jpeg_start_output()` resulted in an error\n(\"Improper call to JPEG library in state 207\".)\n     - Attempting to use `jpeg_skip_scanlines()` resulted in an error (\"Bogus\nvirtual array access\") under certain circumstances.\n\n\n2.1.3\n=====\n\n### Significant changes relative to 2.1.2:\n\n1. Fixed a regression introduced by 2.0 beta1[7] whereby cjpeg compressed PGM\ninput files into full-color JPEG images unless the `-grayscale` option was\nused.\n\n2. cjpeg now automatically compresses GIF and 8-bit BMP input files into\ngrayscale JPEG images if the input files contain only shades of gray.\n\n3. The build system now enables the intrinsics implementation of the AArch64\n(Arm 64-bit) Neon SIMD extensions by default when using GCC 12 or later.\n\n4. Fixed a segfault that occurred while decompressing a 4:2:0 JPEG image using\nthe merged (non-fancy) upsampling algorithms (that is, with\n`cinfo.do_fancy_upsampling` set to `FALSE`) along with `jpeg_crop_scanline()`.\nSpecifically, the segfault occurred if the number of bytes remaining in the\noutput buffer was less than the number of bytes required to represent one\nuncropped scanline of the output image.  For that reason, the issue could only\nbe reproduced using the libjpeg API, not using djpeg.\n\n\n2.1.2\n=====\n\n### Significant changes relative to 2.1.1:\n\n1. Fixed a regression introduced by 2.1 beta1[13] that caused the remaining\nGAS implementations of AArch64 (Arm 64-bit) Neon SIMD functions (which are used\nby default with GCC for performance reasons) to be placed in the `.rodata`\nsection rather than in the `.text` section.  This caused the GNU linker to\nautomatically place the `.rodata` section in an executable segment, which\nprevented libjpeg-turbo from working properly with other linkers and also\nrepresented a potential security risk.\n\n2. Fixed an issue whereby the `tjTransform()` function incorrectly computed the\niMCU size for 4:4:4 JPEG images with non-unary sampling factors and thus unduly\nrejected some cropping regions, even though those regions aligned with 8x8 iMCU\nboundaries.\n\n3. Fixed a regression introduced by 2.1 beta1[13] that caused the build system\nto enable the Arm Neon SIMD extensions when targetting Armv6 and other legacy\narchitectures that do not support Neon instructions.\n\n4. libjpeg-turbo now performs run-time detection of AltiVec instructions on\nFreeBSD/PowerPC systems if AltiVec instructions are not enabled at compile\ntime.  This allows both AltiVec-equipped and non-AltiVec-equipped CPUs to be\nsupported using the same build of libjpeg-turbo.\n\n5. cjpeg now accepts a `-strict` argument similar to that of djpeg and\njpegtran, which causes the compressor to abort if an LZW-compressed GIF input\nimage contains incomplete or corrupt image data.\n\n\n2.1.1\n=====\n\n### Significant changes relative to 2.1.0:\n\n1. Fixed a regression introduced in 2.1.0 that caused build failures with\nnon-GCC-compatible compilers for Un*x/Arm platforms.\n\n2. Fixed a regression introduced by 2.1 beta1[13] that prevented the Arm 32-bit\n(AArch32) Neon SIMD extensions from building unless the C compiler flags\nincluded `-mfloat-abi=softfp` or `-mfloat-abi=hard`.\n\n3. Fixed an issue in the AArch32 Neon SIMD Huffman encoder whereby reliance on\nundefined C compiler behavior led to crashes (\"SIGBUS: illegal alignment\") on\nAndroid systems when running AArch32/Thumb builds of libjpeg-turbo built with\nrecent versions of Clang.\n\n4. Added a command-line argument (`-copy icc`) to jpegtran that causes it to\ncopy only the ICC profile markers from the source file and discard any other\nmetadata.\n\n5. libjpeg-turbo should now build and run on CHERI-enabled architectures, which\nuse capability pointers that are larger than the size of `size_t`.\n\n6. Fixed a regression (CVE-2021-37972) introduced by 2.1 beta1[5] that caused a\nsegfault in the 64-bit SSE2 Huffman encoder when attempting to losslessly\ntransform a specially-crafted malformed JPEG image.\n\n\n2.1.0\n=====\n\n### Significant changes relative to 2.1 beta1:\n\n1. Fixed a regression (CVE-2021-29390) introduced by 2.1 beta1[6(b)] whereby\nattempting to decompress certain progressive JPEG images with one or more\ncomponent planes of width 8 or less caused a buffer overrun.\n\n2. Fixed a regression introduced by 2.1 beta1[6(b)] whereby attempting to\ndecompress a specially-crafted malformed progressive JPEG image caused the\nblock smoothing algorithm to read from uninitialized memory.\n\n3. Fixed an issue in the Arm Neon SIMD Huffman encoders that caused the\nencoders to generate incorrect results when using the Clang compiler with\nVisual Studio.\n\n4. Fixed a floating point exception (CVE-2021-20205) that occurred when\nattempting to compress a specially-crafted malformed GIF image with a specified\nimage width of 0 using cjpeg.\n\n5. Fixed a regression introduced by 2.0 beta1[15] whereby attempting to\ngenerate a progressive JPEG image on an SSE2-capable CPU using a scan script\ncontaining one or more scans with lengths divisible by 32 and non-zero\nsuccessive approximation low bit positions would, under certain circumstances,\nresult in an error (\"Missing Huffman code table entry\") and an invalid JPEG\nimage.\n\n6. Introduced a new flag (`TJFLAG_LIMITSCANS` in the TurboJPEG C API and\n`TJ.FLAG_LIMIT_SCANS` in the TurboJPEG Java API) and a corresponding TJBench\ncommand-line argument (`-limitscans`) that causes the TurboJPEG decompression\nand transform functions/operations to return/throw an error if a progressive\nJPEG image contains an unreasonably large number of scans.  This allows\napplications that use the TurboJPEG API to guard against an exploit of the\nprogressive JPEG format described in the report\n[\"Two Issues with the JPEG Standard\"](https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).\n\n7. The PPM reader now throws an error, rather than segfaulting (due to a buffer\noverrun, CVE-2021-46822) or generating incorrect pixels, if an application\nattempts to use the `tjLoadImage()` function to load a 16-bit binary PPM file\n(a binary PPM file with a maximum value greater than 255) into a grayscale\nimage buffer or to load a 16-bit binary PGM file into an RGB image buffer.\n\n8. Fixed an issue in the PPM reader that caused incorrect pixels to be\ngenerated when using the `tjLoadImage()` function to load a 16-bit binary PPM\nfile into an extended RGB image buffer.\n\n9. Fixed an issue whereby, if a JPEG buffer was automatically re-allocated by\none of the TurboJPEG compression or transform functions and an error\nsubsequently occurred during compression or transformation, the JPEG buffer\npointer passed by the application was not updated when the function returned.\n\n\n2.0.90 (2.1 beta1)\n==================\n\n### Significant changes relative to 2.0.6:\n\n1. The build system, x86-64 SIMD extensions, and accelerated Huffman codec now\nsupport the x32 ABI on Linux, which allows for using x86-64 instructions with\n32-bit pointers.  The x32 ABI is generally enabled by adding `-mx32` to the\ncompiler flags.\n\n     Caveats:\n     - CMake 3.9.0 or later is required in order for the build system to\nautomatically detect an x32 build.\n     - Java does not support the x32 ABI, and thus the TurboJPEG Java API will\nautomatically be disabled with x32 builds.\n\n2. Added Loongson MMI SIMD implementations of the RGB-to-grayscale, 4:2:2 fancy\nchroma upsampling, 4:2:2 and 4:2:0 merged chroma upsampling/color conversion,\nand fast integer DCT/IDCT algorithms.  Relative to libjpeg-turbo 2.0.x, this\nspeeds up:\n\n     - the compression of RGB source images into grayscale JPEG images by\napproximately 20%\n     - the decompression of 4:2:2 JPEG images by approximately 40-60% when\nusing fancy upsampling\n     - the decompression of 4:2:2 and 4:2:0 JPEG images by approximately\n15-20% when using merged upsampling\n     - the compression of RGB source images by approximately 30-45% when using\nthe fast integer DCT\n     - the decompression of JPEG images into RGB destination images by\napproximately 2x when using the fast integer IDCT\n\n    The overall decompression speedup for RGB images is now approximately\n2.3-3.7x (compared to 2-3.5x with libjpeg-turbo 2.0.x.)\n\n3. 32-bit (Armv7 or Armv7s) iOS builds of libjpeg-turbo are no longer\nsupported, and the libjpeg-turbo build system can no longer be used to package\nsuch builds.  32-bit iOS apps cannot run in iOS 11 and later, and the App Store\nno longer allows them.\n\n4. 32-bit (i386) OS X/macOS builds of libjpeg-turbo are no longer supported,\nand the libjpeg-turbo build system can no longer be used to package such\nbuilds.  32-bit Mac applications cannot run in macOS 10.15 \"Catalina\" and\nlater, and the App Store no longer allows them.\n\n5. The SSE2 (x86 SIMD) and C Huffman encoding algorithms have been\nsignificantly optimized, resulting in a measured average overall compression\nspeedup of 12-28% for 64-bit code and 22-52% for 32-bit code on various Intel\nand AMD CPUs, as well as a measured average overall compression speedup of\n0-23% on platforms that do not have a SIMD-accelerated Huffman encoding\nimplementation.\n\n6. The block smoothing algorithm that is applied by default when decompressing\nprogressive Huffman-encoded JPEG images has been improved in the following\nways:\n\n     - The algorithm is now more fault-tolerant.  Previously, if a particular\nscan was incomplete, then the smoothing parameters for the incomplete scan\nwould be applied to the entire output image, including the parts of the image\nthat were generated by the prior (complete) scan.  Visually, this had the\neffect of removing block smoothing from lower-frequency scans if they were\nfollowed by an incomplete higher-frequency scan.  libjpeg-turbo now applies\nblock smoothing parameters to each iMCU row based on which scan generated the\npixels in that row, rather than always using the block smoothing parameters for\nthe most recent scan.\n     - When applying block smoothing to DC scans, a Gaussian-like kernel with a\n5x5 window is used to reduce the \"blocky\" appearance.\n\n7. Added SIMD acceleration for progressive Huffman encoding on Arm platforms.\nThis speeds up the compression of full-color progressive JPEGs by about 30-40%\non average (relative to libjpeg-turbo 2.0.x) when using modern Arm CPUs.\n\n8. Added configure-time and run-time auto-detection of Loongson MMI SIMD\ninstructions, so that the Loongson MMI SIMD extensions can be included in any\nMIPS64 libjpeg-turbo build.\n\n9. Added fault tolerance features to djpeg and jpegtran, mainly to demonstrate\nmethods by which applications can guard against the exploits of the JPEG format\ndescribed in the report\n[\"Two Issues with the JPEG Standard\"](https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).\n\n     - Both programs now accept a `-maxscans` argument, which can be used to\nlimit the number of allowable scans in the input file.\n     - Both programs now accept a `-strict` argument, which can be used to\ntreat all warnings as fatal.\n\n10. CMake package config files are now included for both the libjpeg and\nTurboJPEG API libraries.  This facilitates using libjpeg-turbo with CMake's\n`find_package()` function.  For example:\n\n        find_package(libjpeg-turbo CONFIG REQUIRED)\n\n        add_executable(libjpeg_program libjpeg_program.c)\n        target_link_libraries(libjpeg_program PUBLIC libjpeg-turbo::jpeg)\n\n        add_executable(libjpeg_program_static libjpeg_program.c)\n        target_link_libraries(libjpeg_program_static PUBLIC\n          libjpeg-turbo::jpeg-static)\n\n        add_executable(turbojpeg_program turbojpeg_program.c)\n        target_link_libraries(turbojpeg_program PUBLIC\n          libjpeg-turbo::turbojpeg)\n\n        add_executable(turbojpeg_program_static turbojpeg_program.c)\n        target_link_libraries(turbojpeg_program_static PUBLIC\n          libjpeg-turbo::turbojpeg-static)\n\n11. Since the Unisys LZW patent has long expired, cjpeg and djpeg can now\nread/write both LZW-compressed and uncompressed GIF files (feature ported from\njpeg-6a and jpeg-9d.)\n\n12. jpegtran now includes the `-wipe` and `-drop` options from jpeg-9a and\njpeg-9d, as well as the ability to expand the image size using the `-crop`\noption.  Refer to jpegtran.1 or usage.txt for more details.\n\n13. Added a complete intrinsics implementation of the Arm Neon SIMD extensions,\nthus providing SIMD acceleration on Arm platforms for all of the algorithms\nthat are SIMD-accelerated on x86 platforms.  This new implementation is\nsignificantly faster in some cases than the old GAS implementation--\ndepending on the algorithms used, the type of CPU core, and the compiler.  GCC,\nas of this writing, does not provide a full or optimal set of Neon intrinsics,\nso for performance reasons, the default when building libjpeg-turbo with GCC is\nto continue using the GAS implementation of the following algorithms:\n\n     - 32-bit RGB-to-YCbCr color conversion\n     - 32-bit fast and accurate inverse DCT\n     - 64-bit RGB-to-YCbCr and YCbCr-to-RGB color conversion\n     - 64-bit accurate forward and inverse DCT\n     - 64-bit Huffman encoding\n\n    A new CMake variable (`NEON_INTRINSICS`) can be used to override this\ndefault.\n\n    Since the new intrinsics implementation includes SIMD acceleration\nfor merged upsampling/color conversion, 1.5.1[5] is no longer necessary and has\nbeen reverted.\n\n14. The Arm Neon SIMD extensions can now be built using Visual Studio.\n\n15. The build system can now be used to generate a universal x86-64 + Armv8\nlibjpeg-turbo SDK package for both iOS and macOS.\n\n\n2.0.6\n=====\n\n### Significant changes relative to 2.0.5:\n\n1. Fixed \"using JNI after critical get\" errors that occurred on Android\nplatforms when using any of the YUV encoding/compression/decompression/decoding\nmethods in the TurboJPEG Java API.\n\n2. Fixed or worked around multiple issues with `jpeg_skip_scanlines()`:\n\n     - Fixed segfaults (CVE-2020-35538) or \"Corrupt JPEG data: premature end of\ndata segment\" errors in `jpeg_skip_scanlines()` that occurred when\ndecompressing 4:2:2 or 4:2:0 JPEG images using merged (non-fancy)\nupsampling/color conversion (that is, when setting `cinfo.do_fancy_upsampling`\nto `FALSE`.)  2.0.0[6] was a similar fix, but it did not cover all cases.\n     - `jpeg_skip_scanlines()` now throws an error if two-pass color\nquantization is enabled.  Two-pass color quantization never worked properly\nwith `jpeg_skip_scanlines()`, and the issues could not readily be fixed.\n     - Fixed an issue whereby `jpeg_skip_scanlines()` always returned 0 when\nskipping past the end of an image.\n\n3. The Arm 64-bit (Armv8) Neon SIMD extensions can now be built using MinGW\ntoolchains targetting Arm64 (AArch64) Windows binaries.\n\n4. Fixed unexpected visual artifacts that occurred when using\n`jpeg_crop_scanline()` and interblock smoothing while decompressing only the DC\nscan of a progressive JPEG image.\n\n5. Fixed an issue whereby libjpeg-turbo would not build if 12-bit-per-component\nJPEG support (`WITH_12BIT`) was enabled along with libjpeg v7 or libjpeg v8\nAPI/ABI emulation (`WITH_JPEG7` or `WITH_JPEG8`.)\n\n\n2.0.5\n=====\n\n### Significant changes relative to 2.0.4:\n\n1. Worked around issues in the MIPS DSPr2 SIMD extensions that caused failures\nin the libjpeg-turbo regression tests.  Specifically, the\n`jsimd_h2v1_downsample_dspr2()` and `jsimd_h2v2_downsample_dspr2()` functions\nin the MIPS DSPr2 SIMD extensions are now disabled until/unless they can be\nfixed, and other functions that are incompatible with big endian MIPS CPUs are\ndisabled when building libjpeg-turbo for such CPUs.\n\n2. Fixed an oversight in the `TJCompressor.compress(int)` method in the\nTurboJPEG Java API that caused an error (\"java.lang.IllegalStateException: No\nsource image is associated with this instance\") when attempting to use that\nmethod to compress a YUV image.\n\n3. Fixed an issue (CVE-2020-13790) in the PPM reader that caused a buffer\noverrun in cjpeg, TJBench, or the `tjLoadImage()` function if one of the values\nin a binary PPM/PGM input file exceeded the maximum value defined in the file's\nheader and that maximum value was less than 255.  libjpeg-turbo 1.5.0 already\nincluded a similar fix for binary PPM/PGM files with maximum values greater\nthan 255.\n\n4. The TurboJPEG API library's global error handler, which is used in functions\nsuch as `tjBufSize()` and `tjLoadImage()` that do not require a TurboJPEG\ninstance handle, is now thread-safe on platforms that support thread-local\nstorage.\n\n\n2.0.4\n=====\n\n### Significant changes relative to 2.0.3:\n\n1. Fixed a regression in the Windows packaging system (introduced by\n2.0 beta1[2]) whereby, if both the 64-bit libjpeg-turbo SDK for GCC and the\n64-bit libjpeg-turbo SDK for Visual C++ were installed on the same system, only\none of them could be uninstalled.\n\n2. Fixed a signed integer overflow and subsequent segfault that occurred when\nattempting to decompress images with more than 715827882 pixels using the\n64-bit C version of TJBench.\n\n3. Fixed out-of-bounds write in `tjDecompressToYUV2()` and\n`tjDecompressToYUVPlanes()` (sometimes manifesting as a double free) that\noccurred when attempting to decompress grayscale JPEG images that were\ncompressed with a sampling factor other than 1 (for instance, with\n`cjpeg -grayscale -sample 2x2`).\n\n4. Fixed a regression introduced by 2.0.2[5] that caused the TurboJPEG API to\nincorrectly identify some JPEG images with unusual sampling factors as 4:4:4\nJPEG images.  This was known to cause a buffer overflow when attempting to\ndecompress some such images using `tjDecompressToYUV2()` or\n`tjDecompressToYUVPlanes()`.\n\n5. Fixed an issue (CVE-2020-17541), detected by ASan, whereby attempting to\nlosslessly transform a specially-crafted malformed JPEG image containing an\nextremely-high-frequency coefficient block (junk image data that could never be\ngenerated by a legitimate JPEG compressor) could cause the Huffman encoder's\nlocal buffer to be overrun. (Refer to 1.4.0[9] and 1.4beta1[15].)  Given that\nthe buffer overrun was fully contained within the stack and did not cause a\nsegfault or other user-visible errant behavior, and given that the lossless\ntransformer (unlike the decompressor) is not generally exposed to arbitrary\ndata exploits, this issue did not likely pose a security risk.\n\n6. The Arm 64-bit (Armv8) Neon SIMD assembly code now stores constants in a\nseparate read-only data section rather than in the text section, to support\nexecute-only memory layouts.\n\n\n2.0.3\n=====\n\n### Significant changes relative to 2.0.2:\n\n1. Fixed \"using JNI after critical get\" errors that occurred on Android\nplatforms when passing invalid arguments to certain methods in the TurboJPEG\nJava API.\n\n2. Fixed a regression in the SIMD feature detection code, introduced by\nthe AVX2 SIMD extensions (2.0 beta1[1]), that was known to cause an illegal\ninstruction exception, in rare cases, on CPUs that lack support for CPUID leaf\n07H (or on which the maximum CPUID leaf has been limited by way of a BIOS\nsetting.)\n\n3. The 4:4:0 (h1v2) fancy (smooth) chroma upsampling algorithm in the\ndecompressor now uses a similar bias pattern to that of the 4:2:2 (h2v1) fancy\nchroma upsampling algorithm, rounding up or down the upsampled result for\nalternate pixels rather than always rounding down.  This ensures that,\nregardless of whether a 4:2:2 JPEG image is rotated or transposed prior to\ndecompression (in the frequency domain) or after decompression (in the spatial\ndomain), the final image will be similar.\n\n4. Fixed an integer overflow and subsequent segfault that occurred when\nattempting to compress or decompress images with more than 1 billion pixels\nusing the TurboJPEG API.\n\n5. Fixed a regression introduced by 2.0 beta1[15] whereby attempting to\ngenerate a progressive JPEG image on an SSE2-capable CPU using a scan script\ncontaining one or more scans with lengths divisible by 16 would result in an\nerror (\"Missing Huffman code table entry\") and an invalid JPEG image.\n\n6. Fixed an issue whereby `tjDecodeYUV()` and `tjDecodeYUVPlanes()` would throw\nan error (\"Invalid progressive parameters\") or a warning (\"Inconsistent\nprogression sequence\") if passed a TurboJPEG instance that was previously used\nto decompress a progressive JPEG image.\n\n\n2.0.2\n=====\n\n### Significant changes relative to 2.0.1:\n\n1. Fixed a regression introduced by 2.0.1[5] that prevented a runtime search\npath (rpath) from being embedded in the libjpeg-turbo shared libraries and\nexecutables for macOS and iOS.  This caused a fatal error of the form\n\"dyld: Library not loaded\" when attempting to use one of the executables,\nunless `DYLD_LIBRARY_PATH` was explicitly set to the location of the\nlibjpeg-turbo shared libraries.\n\n2. Fixed an integer overflow and subsequent segfault (CVE-2018-20330) that\noccurred when attempting to load a BMP file with more than 1 billion pixels\nusing the `tjLoadImage()` function.\n\n3. Fixed a buffer overrun (CVE-2018-19664) that occurred when attempting to\ndecompress a specially-crafted malformed JPEG image to a 256-color BMP using\ndjpeg.\n\n4. Fixed a floating point exception that occurred when attempting to\ndecompress a specially-crafted malformed JPEG image with a specified image\nwidth or height of 0 using the C version of TJBench.\n\n5. The TurboJPEG API will now decompress 4:4:4 JPEG images with 2x1, 1x2, 3x1,\nor 1x3 luminance and chrominance sampling factors.  This is a non-standard way\nof specifying 1x subsampling (normally 4:4:4 JPEGs have 1x1 luminance and\nchrominance sampling factors), but the JPEG format and the libjpeg API both\nallow it.\n\n6. Fixed a regression introduced by 2.0 beta1[7] that caused djpeg to generate\nincorrect PPM images when used with the `-colors` option.\n\n7. Fixed an issue whereby a static build of libjpeg-turbo (a build in which\n`ENABLE_SHARED` is `0`) could not be installed using the Visual Studio IDE.\n\n8. Fixed a severe performance issue in the Loongson MMI SIMD extensions that\noccurred when compressing RGB images whose image rows were not 64-bit-aligned.\n\n\n2.0.1\n=====\n\n### Significant changes relative to 2.0.0:\n\n1. Fixed a regression introduced with the new CMake-based Un*x build system,\nwhereby jconfig.h could cause compiler warnings of the form\n`\"HAVE_*_H\" redefined` if it was included by downstream Autotools-based\nprojects that used `AC_CHECK_HEADERS()` to check for the existence of locale.h,\nstddef.h, or stdlib.h.\n\n2. The `jsimd_quantize_float_dspr2()` and `jsimd_convsamp_float_dspr2()`\nfunctions in the MIPS DSPr2 SIMD extensions are now disabled at compile time\nif the soft float ABI is enabled.  Those functions use instructions that are\nincompatible with the soft float ABI.\n\n3. Fixed a regression in the SIMD feature detection code, introduced by\nthe AVX2 SIMD extensions (2.0 beta1[1]), that caused libjpeg-turbo to crash on\nWindows 7 if Service Pack 1 was not installed.\n\n4. Fixed out-of-bounds read in cjpeg that occurred when attempting to compress\na specially-crafted malformed color-index (8-bit-per-sample) Targa file in\nwhich some of the samples (color indices) exceeded the bounds of the Targa\nfile's color table.\n\n5. Fixed an issue whereby installing a fully static build of libjpeg-turbo\n(a build in which `CFLAGS` contains `-static` and `ENABLE_SHARED` is `0`) would\nfail with \"No valid ELF RPATH or RUNPATH entry exists in the file.\"\n\n\n2.0.0\n=====\n\n### Significant changes relative to 2.0 beta1:\n\n1. The TurboJPEG API can now decompress CMYK JPEG images that have subsampled M\nand Y components (not to be confused with YCCK JPEG images, in which the C/M/Y\ncomponents have been transformed into luma and chroma.)   Previously, an error\nwas generated (\"Could not determine subsampling type for JPEG image\") when such\nan image was passed to `tjDecompressHeader3()`, `tjTransform()`,\n`tjDecompressToYUVPlanes()`, `tjDecompressToYUV2()`, or the equivalent Java\nmethods.\n\n2. Fixed an issue (CVE-2018-11813) whereby a specially-crafted malformed input\nfile (specifically, a file with a valid Targa header but incomplete pixel data)\nwould cause cjpeg to generate a JPEG file that was potentially thousands of\ntimes larger than the input file.  The Targa reader in cjpeg was not properly\ndetecting that the end of the input file had been reached prematurely, so after\nall valid pixels had been read from the input, the reader injected dummy pixels\nwith values of 255 into the JPEG compressor until the number of pixels\nspecified in the Targa header had been compressed.  The Targa reader in cjpeg\nnow behaves like the PPM reader and aborts compression if the end of the input\nfile is reached prematurely.  Because this issue only affected cjpeg and not\nthe underlying library, and because it did not involve any out-of-bounds reads\nor other exploitable behaviors, it was not believed to represent a security\nthreat.\n\n3. Fixed an issue whereby the `tjLoadImage()` and `tjSaveImage()` functions\nwould produce a \"Bogus message code\" error message if the underlying bitmap and\nPPM readers/writers threw an error that was specific to the readers/writers\n(as opposed to a general libjpeg API error.)\n\n4. Fixed an issue (CVE-2018-1152) whereby a specially-crafted malformed BMP\nfile, one in which the header specified an image width of 1073741824 pixels,\nwould trigger a floating point exception (division by zero) in the\n`tjLoadImage()` function when attempting to load the BMP file into a\n4-component image buffer.\n\n5. Fixed an issue whereby certain combinations of calls to\n`jpeg_skip_scanlines()` and `jpeg_read_scanlines()` could trigger an infinite\nloop when decompressing progressive JPEG images that use vertical chroma\nsubsampling (for instance, 4:2:0 or 4:4:0.)\n\n6. Fixed a segfault in `jpeg_skip_scanlines()` that occurred when decompressing\na 4:2:2 or 4:2:0 JPEG image using the merged (non-fancy) upsampling algorithms\n(that is, when setting `cinfo.do_fancy_upsampling` to `FALSE`.)\n\n7. The new CMake-based build system will now disable the MIPS DSPr2 SIMD\nextensions if it detects that the compiler does not support DSPr2 instructions.\n\n8. Fixed out-of-bounds read in cjpeg (CVE-2018-14498) that occurred when\nattempting to compress a specially-crafted malformed color-index\n(8-bit-per-sample) BMP file in which some of the samples (color indices)\nexceeded the bounds of the BMP file's color table.\n\n9. Fixed a signed integer overflow in the progressive Huffman decoder, detected\nby the Clang and GCC undefined behavior sanitizers, that could be triggered by\nattempting to decompress a specially-crafted malformed JPEG image.  This issue\ndid not pose a security threat, but removing the warning made it easier to\ndetect actual security issues, should they arise in the future.\n\n\n1.5.90 (2.0 beta1)\n==================\n\n### Significant changes relative to 1.5.3:\n\n1. Added AVX2 SIMD implementations of the colorspace conversion, chroma\ndownsampling and upsampling, integer quantization and sample conversion, and\naccurate integer DCT/IDCT algorithms.  When using the accurate integer DCT/IDCT\nalgorithms on AVX2-equipped CPUs, the compression of RGB images is\napproximately 13-36% (avg. 22%) faster (relative to libjpeg-turbo 1.5.x) with\n64-bit code and 11-21% (avg. 17%) faster with 32-bit code, and the\ndecompression of RGB images is approximately 9-35% (avg. 17%) faster with\n64-bit code and 7-17% (avg. 12%) faster with 32-bit code.  (As tested on a\n3 GHz Intel Core i7.  Actual mileage may vary.)\n\n2. Overhauled the build system to use CMake on all platforms, and removed the\nautotools-based build system.  This decision resulted from extensive\ndiscussions within the libjpeg-turbo community.  libjpeg-turbo traditionally\nused CMake only for Windows builds, but there was an increasing amount of\ndemand to extend CMake support to other platforms.  However, because of the\nunique nature of our code base (the need to support different assemblers on\neach platform, the need for Java support, etc.), providing dual build systems\nas other OSS imaging libraries do (including libpng and libtiff) would have\ncreated a maintenance burden.  The use of CMake greatly simplifies some aspects\nof our build system, owing to CMake's built-in support for various assemblers,\nJava, and unit testing, as well as generally fewer quirks that have to be\nworked around in order to implement our packaging system.  Eliminating\nautotools puts our project slightly at odds with the traditional practices of\nthe OSS community, since most \"system libraries\" tend to be built with\nautotools, but it is believed that the benefits of this move outweigh the\nrisks.  In addition to providing a unified build environment, switching to\nCMake allows for the use of various build tools and IDEs that aren't supported\nunder autotools, including XCode, Ninja, and Eclipse.  It also eliminates the\nneed to install autotools via MacPorts/Homebrew on OS X and allows\nlibjpeg-turbo to be configured without the use of a terminal/command prompt.\nExtensive testing was conducted to ensure that all features provided by the\nautotools-based build system are provided by the new build system.\n\n3. The libjpeg API in this version of libjpeg-turbo now includes two additional\nfunctions, `jpeg_read_icc_profile()` and `jpeg_write_icc_profile()`, that can\nbe used to extract ICC profile data from a JPEG file while decompressing or to\nembed ICC profile data in a JPEG file while compressing or transforming.  This\neliminates the need for downstream projects, such as color management libraries\nand browsers, to include their own glueware for accomplishing this.\n\n4. Improved error handling in the TurboJPEG API library:\n\n     - Introduced a new function (`tjGetErrorStr2()`) in the TurboJPEG C API\nthat allows compression/decompression/transform error messages to be retrieved\nin a thread-safe manner.  Retrieving error messages from global functions, such\nas `tjInitCompress()` or `tjBufSize()`, is still thread-unsafe, but since those\nfunctions will only throw errors if passed an invalid argument or if a memory\nallocation failure occurs, thread safety is not as much of a concern.\n     - Introduced a new function (`tjGetErrorCode()`) in the TurboJPEG C API\nand a new method (`TJException.getErrorCode()`) in the TurboJPEG Java API that\ncan be used to determine the severity of the last\ncompression/decompression/transform error.  This allows applications to\nchoose whether to ignore warnings (non-fatal errors) from the underlying\nlibjpeg API or to treat them as fatal.\n     - Introduced a new flag (`TJFLAG_STOPONWARNING` in the TurboJPEG C API and\n`TJ.FLAG_STOPONWARNING` in the TurboJPEG Java API) that causes the library to\nimmediately halt a compression/decompression/transform operation if it\nencounters a warning from the underlying libjpeg API (the default behavior is\nto allow the operation to complete unless a fatal error is encountered.)\n\n5. Introduced a new flag in the TurboJPEG C and Java APIs (`TJFLAG_PROGRESSIVE`\nand `TJ.FLAG_PROGRESSIVE`, respectively) that causes compression and transform\noperations to generate progressive JPEG images.  Additionally, a new transform\noption (`TJXOPT_PROGRESSIVE` in the C API and `TJTransform.OPT_PROGRESSIVE` in\nthe Java API) has been introduced, allowing progressive JPEG images to be\ngenerated by selected transforms in a multi-transform operation.\n\n6. Introduced a new transform option in the TurboJPEG API (`TJXOPT_COPYNONE` in\nthe C API and `TJTransform.OPT_COPYNONE` in the Java API) that allows the\ncopying of markers (including Exif and ICC profile data) to be disabled for a\nparticular transform.\n\n7. Added two functions to the TurboJPEG C API (`tjLoadImage()` and\n`tjSaveImage()`) that can be used to load/save a BMP or PPM/PGM image to/from a\nmemory buffer with a specified pixel format and layout.  These functions\nreplace the project-private (and slow) bmp API, which was previously used by\nTJBench, and they also provide a convenient way for first-time users of\nlibjpeg-turbo to quickly develop a complete JPEG compression/decompression\nprogram.\n\n8. The TurboJPEG C API now includes a new convenience array (`tjAlphaOffset[]`)\nthat contains the alpha component index for each pixel format (or -1 if the\npixel format lacks an alpha component.)  The TurboJPEG Java API now includes a\nnew method (`TJ.getAlphaOffset()`) that returns the same value.  In addition,\nthe `tjRedOffset[]`, `tjGreenOffset[]`, and `tjBlueOffset[]` arrays-- and the\ncorresponding `TJ.getRedOffset()`, `TJ.getGreenOffset()`, and\n`TJ.getBlueOffset()` methods-- now return -1 for `TJPF_GRAY`/`TJ.PF_GRAY`\nrather than 0.  This allows programs to easily determine whether a pixel format\nhas red, green, blue, and alpha components.\n\n9. Added a new example (tjexample.c) that demonstrates the basic usage of the\nTurboJPEG C API.  This example mirrors the functionality of TJExample.java.\nBoth files are now included in the libjpeg-turbo documentation.\n\n10. Fixed two signed integer overflows in the arithmetic decoder, detected by\nthe Clang undefined behavior sanitizer, that could be triggered by attempting\nto decompress a specially-crafted malformed JPEG image.  These issues did not\npose a security threat, but removing the warnings makes it easier to detect\nactual security issues, should they arise in the future.\n\n11. Fixed a bug in the merged 4:2:0 upsampling/dithered RGB565 color conversion\nalgorithm that caused incorrect dithering in the output image.  This algorithm\nnow produces bitwise-identical results to the unmerged algorithms.\n\n12. The SIMD function symbols for x86[-64]/ELF, MIPS/ELF, macOS/x86[-64] (if\nlibjpeg-turbo is built with Yasm), and iOS/Arm[64] builds are now private.\nThis prevents those symbols from being exposed in applications or shared\nlibraries that link statically with libjpeg-turbo.\n\n13. Added Loongson MMI SIMD implementations of the RGB-to-YCbCr and\nYCbCr-to-RGB colorspace conversion, 4:2:0 chroma downsampling, 4:2:0 fancy\nchroma upsampling, integer quantization, and accurate integer DCT/IDCT\nalgorithms.  When using the accurate integer DCT/IDCT, this speeds up the\ncompression of RGB images by approximately 70-100% and the decompression of RGB\nimages by approximately 2-3.5x.\n\n14. Fixed a build error when building with older MinGW releases (regression\ncaused by 1.5.1[7].)\n\n15. Added SIMD acceleration for progressive Huffman encoding on SSE2-capable\nx86 and x86-64 platforms.  This speeds up the compression of full-color\nprogressive JPEGs by about 85-90% on average (relative to libjpeg-turbo 1.5.x)\nwhen using modern Intel and AMD CPUs.\n\n\n1.5.3\n=====\n\n### Significant changes relative to 1.5.2:\n\n1. Fixed a NullPointerException in the TurboJPEG Java wrapper that occurred\nwhen using the YUVImage constructor that creates an instance backed by separate\nimage planes and allocates memory for the image planes.\n\n2. Fixed an issue whereby the Java version of TJUnitTest would fail when\ntesting BufferedImage encoding/decoding on big endian systems.\n\n3. Fixed a segfault in djpeg that would occur if an output format other than\nPPM/PGM was selected along with the `-crop` option.  The `-crop` option now\nworks with the GIF and Targa formats as well (unfortunately, it cannot be made\nto work with the BMP and RLE formats due to the fact that those output engines\nwrite scanlines in bottom-up order.)  djpeg will now exit gracefully if an\noutput format other than PPM/PGM, GIF, or Targa is selected along with the\n`-crop` option.\n\n4. Fixed an issue (CVE-2017-15232) whereby `jpeg_skip_scanlines()` would\nsegfault if color quantization was enabled.\n\n5. TJBench (both C and Java versions) will now display usage information if any\ncommand-line argument is unrecognized.  This prevents the program from silently\nignoring typos.\n\n6. Fixed an access violation in tjbench.exe (Windows) that occurred when the\nprogram was used to decompress an existing JPEG image.\n\n7. Fixed an ArrayIndexOutOfBoundsException in the TJExample Java program that\noccurred when attempting to decompress a JPEG image that had been compressed\nwith 4:1:1 chrominance subsampling.\n\n8. Fixed an issue whereby, when using `jpeg_skip_scanlines()` to skip to the\nend of a single-scan (non-progressive) image, subsequent calls to\n`jpeg_consume_input()` would return `JPEG_SUSPENDED` rather than\n`JPEG_REACHED_EOI`.\n\n9. `jpeg_crop_scanline()` now works correctly when decompressing grayscale JPEG\nimages that were compressed with a sampling factor other than 1 (for instance,\nwith `cjpeg -grayscale -sample 2x2`).\n\n\n1.5.2\n=====\n\n### Significant changes relative to 1.5.1:\n\n1. Fixed a regression introduced by 1.5.1[7] that prevented libjpeg-turbo from\nbuilding with Android NDK platforms prior to android-21 (5.0).\n\n2. Fixed a regression introduced by 1.5.1[1] that prevented the MIPS DSPR2 SIMD\ncode in libjpeg-turbo from building.\n\n3. Fixed a regression introduced by 1.5 beta1[11] that prevented the Java\nversion of TJBench from outputting any reference images (the `-nowrite` switch\nwas accidentally enabled by default.)\n\n4. libjpeg-turbo should now build and run with full AltiVec SIMD acceleration\non PowerPC-based AmigaOS 4 and OpenBSD systems.\n\n5. Fixed build and runtime errors on Windows that occurred when building\nlibjpeg-turbo with libjpeg v7 API/ABI emulation and the in-memory\nsource/destination managers.  Due to an oversight, the `jpeg_skip_scanlines()`\nand `jpeg_crop_scanline()` functions were not being included in jpeg7.dll when\nlibjpeg-turbo was built with `-DWITH_JPEG7=1` and `-DWITH_MEMSRCDST=1`.\n\n6. Fixed \"Bogus virtual array access\" error that occurred when using the\nlossless crop feature in jpegtran or the TurboJPEG API, if libjpeg-turbo was\nbuilt with libjpeg v7 API/ABI emulation.  This was apparently a long-standing\nbug that has existed since the introduction of libjpeg v7/v8 API/ABI emulation\nin libjpeg-turbo v1.1.\n\n7. The lossless transform features in jpegtran and the TurboJPEG API will now\nalways attempt to adjust the Exif image width and height tags if the image size\nchanged as a result of the transform.  This behavior has always existed when\nusing libjpeg v8 API/ABI emulation.  It was supposed to be available with\nlibjpeg v7 API/ABI emulation as well but did not work properly due to a bug.\nFurthermore, there was never any good reason not to enable it with libjpeg v6b\nAPI/ABI emulation, since the behavior is entirely internal.  Note that\n`-copy all` must be passed to jpegtran in order to transfer the Exif tags from\nthe source image to the destination image.\n\n8. Fixed several memory leaks in the TurboJPEG API library that could occur\nif the library was built with certain compilers and optimization levels\n(known to occur with GCC 4.x and clang with `-O1` and higher but not with\nGCC 5.x or 6.x) and one of the underlying libjpeg API functions threw an error\nafter a TurboJPEG API function allocated a local buffer.\n\n9. The libjpeg-turbo memory manager will now honor the `max_memory_to_use`\nstructure member in jpeg\\_memory\\_mgr, which can be set to the maximum amount\nof memory (in bytes) that libjpeg-turbo should use during decompression or\nmulti-pass (including progressive) compression.  This limit can also be set\nusing the `JPEGMEM` environment variable or using the `-maxmemory` switch in\ncjpeg/djpeg/jpegtran (refer to the respective man pages for more details.)\nThis has been a documented feature of libjpeg since v5, but the\n`malloc()`/`free()` implementation of the memory manager (jmemnobs.c) never\nimplemented the feature.  Restricting libjpeg-turbo's memory usage is useful\nfor two reasons:  it allows testers to more easily work around the 2 GB limit\nin libFuzzer, and it allows developers of security-sensitive applications to\nmore easily defend against one of the progressive JPEG exploits (LJT-01-004)\nidentified in\n[this report](https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).\n\n10. TJBench will now run each benchmark for 1 second prior to starting the\ntimer, in order to improve the consistency of the results.  Furthermore, the\n`-warmup` option is now used to specify the amount of warmup time rather than\nthe number of warmup iterations.\n\n11. Fixed an error (`short jump is out of range`) that occurred when assembling\nthe 32-bit x86 SIMD extensions with NASM versions prior to 2.04.  This was a\nregression introduced by 1.5 beta1[12].\n\n\n1.5.1\n=====\n\n### Significant changes relative to 1.5.0:\n\n1. Previously, the undocumented `JSIMD_FORCE*` environment variables could be\nused to force-enable a particular SIMD instruction set if multiple instruction\nsets were available on a particular platform.  On x86 platforms, where CPU\nfeature detection is bulletproof and multiple SIMD instruction sets are\navailable, it makes sense for those environment variables to allow forcing the\nuse of an instruction set only if that instruction set is available.  However,\nsince the ARM implementations of libjpeg-turbo can only use one SIMD\ninstruction set, and since their feature detection code is less bulletproof\n(parsing /proc/cpuinfo), it makes sense for the `JSIMD_FORCENEON` environment\nvariable to bypass the feature detection code and really force the use of NEON\ninstructions.  A new environment variable (`JSIMD_FORCEDSPR2`) was introduced\nin the MIPS implementation for the same reasons, and the existing\n`JSIMD_FORCENONE` environment variable was extended to that implementation.\nThese environment variables provide a workaround for those attempting to test\nARM and MIPS builds of libjpeg-turbo in QEMU, which passes through\n/proc/cpuinfo from the host system.\n\n2. libjpeg-turbo previously assumed that AltiVec instructions were always\navailable on PowerPC platforms, which led to \"illegal instruction\" errors when\nrunning on PowerPC chips that lack AltiVec support (such as the older 7xx/G3\nand newer e5500 series.)  libjpeg-turbo now examines /proc/cpuinfo on\nLinux/Android systems and enables AltiVec instructions only if the CPU supports\nthem.  It also now provides two environment variables, `JSIMD_FORCEALTIVEC` and\n`JSIMD_FORCENONE`, to force-enable and force-disable AltiVec instructions in\nenvironments where /proc/cpuinfo is an unreliable means of CPU feature\ndetection (such as when running in QEMU.)  On OS X, libjpeg-turbo continues to\nassume that AltiVec support is always available, which means that libjpeg-turbo\ncannot be used with G3 Macs unless you set the environment variable\n`JSIMD_FORCENONE` to `1`.\n\n3. Fixed an issue whereby 64-bit ARM (AArch64) builds of libjpeg-turbo would\ncrash when built with recent releases of the Clang/LLVM compiler.  This was\ncaused by an ABI conformance issue in some of libjpeg-turbo's 64-bit NEON SIMD\nroutines.  Those routines were incorrectly using 64-bit instructions to\ntransfer a 32-bit JDIMENSION argument, whereas the ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fancy upsampling is now supported when decompressing JPEG images that use\n4:4:0 (h1v2) chroma subsampling.  These images are generated when losslessly\nrotating or transposing JPEG images that use 4:2:2 (h2v1) chroma subsampling.\nThe h1v2 fancy upsampling algorithm is not currently SIMD-accelerated.\n\n5. If merged upsampling isn't SIMD-accelerated but YCbCr-to-RGB conversion is,\nthen libjpeg-turbo will now disable merged upsampling when decompressing YCbCr\nJPEG images into RGB or extended RGB output images.  This significantly speeds\nup the decompression of 4:2:0 and 4:2:2 JPEGs on ARM platforms if fancy\nupsampling is not used (for example, if the `-nosmooth` option to djpeg is\nspecified.)\n\n6. The TurboJPEG API will now decompress 4:2:2 and 4:4:0 JPEG images with\n2x2 luminance sampling factors and 2x1 or 1x2 chrominance sampling factors.\nThis is a non-standard way of specifying 2x subsampling (normally 4:2:2 JPEGs\nhave 2x1 luminance and 1x1 chrominance sampling factors, and 4:4:0 JPEGs have\n1x2 luminance and 1x1 chrominance sampling factors), but the JPEG format and\nthe libjpeg API both allow it.\n\n7. Fixed an unsigned integer overflow in the libjpeg memory manager, detected\nby the Clang undefined behavior sanitizer, that could be triggered by\nattempting to decompress a specially-crafted malformed JPEG image.  This issue\naffected only 32-bit code and did not pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n8. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers when attempting to decompress\nspecially-crafted malformed JPEG images.  None of these issues posed a security\nthreat, but removing the warnings makes it easier to detect actual security\nissues, should they arise in the future.\n\n9. Fixed an out-of-bounds array reference, introduced by 1.4.90[2] (partial\nimage decompression) and detected by the Clang undefined behavior sanitizer,\nthat could be triggered by a specially-crafted malformed JPEG image with more\nthan four components.  Because the out-of-bounds reference was still within the\nsame structure, it was not known to pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n10. Fixed another ABI conformance issue in the 64-bit ARM (AArch64) NEON SIMD\ncode.  Some of the routines were incorrectly reading and storing data below the\nstack pointer, which caused segfaults in certain applications under specific\ncircumstances.\n\n\n1.5.0\n=====\n\n### Significant changes relative to 1.5 beta1:\n\n1. Fixed an issue whereby a malformed motion-JPEG frame could cause the \"fast\npath\" of libjpeg-turbo's Huffman decoder to read from uninitialized memory.\n\n2. Added libjpeg-turbo version and build information to the global string table\nof the libjpeg and TurboJPEG API libraries.  This is a common practice in other\ninfrastructure libraries, such as OpenSSL and libpng, because it makes it easy\nto examine an application binary and determine which version of the library the\napplication was linked against.\n\n3. Fixed a couple of issues in the PPM reader that would cause buffer overruns\nin cjpeg if one of the values in a binary PPM/PGM input file exceeded the\nmaximum value defined in the file's header and that maximum value was greater\nthan 255.  libjpeg-turbo 1.4.2 already included a similar fix for ASCII PPM/PGM\nfiles.  Note that these issues were not security bugs, since they were confined\nto the cjpeg program and did not affect any of the libjpeg-turbo libraries.\n\n4. Fixed an issue whereby attempting to decompress a JPEG file with a corrupt\nheader using the `tjDecompressToYUV2()` function would cause the function to\nabort without returning an error and, under certain circumstances, corrupt the\nstack.  This only occurred if `tjDecompressToYUV2()` was called prior to\ncalling `tjDecompressHeader3()`, or if the return value from\n`tjDecompressHeader3()` was ignored (both cases represent incorrect usage of\nthe TurboJPEG API.)\n\n5. Fixed an issue in the ARM 32-bit SIMD-accelerated Huffman encoder that\nprevented the code from assembling properly with clang.\n\n6. The `jpeg_stdio_src()`, `jpeg_mem_src()`, `jpeg_stdio_dest()`, and\n`jpeg_mem_dest()` functions in the libjpeg API will now throw an error if a\nsource/destination manager has already been assigned to the compress or\ndecompress object by a different function or by the calling program.  This\nprevents these functions from attempting to reuse a source/destination manager\nstructure that was allocated elsewhere, because there is no way to ensure that\nit would be big enough to accommodate the new source/destination manager.\n\n\n1.4.90 (1.5 beta1)\n==================\n\n### Significant changes relative to 1.4.2:\n\n1. Added full SIMD acceleration for PowerPC platforms using AltiVec VMX\n(128-bit SIMD) instructions.  Although the performance of libjpeg-turbo on\nPowerPC was already good, due to the increased number of registers available\nto the compiler vs. x86, it was still possible to speed up compression by about\n3-4x and decompression by about 2-2.5x (relative to libjpeg v6b) through the\nuse of AltiVec instructions.\n\n2. Added two new libjpeg API functions (`jpeg_skip_scanlines()` and\n`jpeg_crop_scanline()`) that can be used to partially decode a JPEG image.  See\n[libjpeg.txt](libjpeg.txt) for more details.\n\n3. The TJCompressor and TJDecompressor classes in the TurboJPEG Java API now\nimplement the Closeable interface, so those classes can be used with a\ntry-with-resources statement.\n\n4. The TurboJPEG Java classes now throw unchecked idiomatic exceptions\n(IllegalArgumentException, IllegalStateException) for unrecoverable errors\ncaused by incorrect API usage, and those classes throw a new checked exception\ntype (TJException) for errors that are passed through from the C library.\n\n5. Source buffers for the TurboJPEG C API functions, as well as the\n`jpeg_mem_src()` function in the libjpeg API, are now declared as const\npointers.  This facilitates passing read-only buffers to those functions and\nensures the caller that the source buffer will not be modified.  This should\nnot create any backward API or ABI incompatibilities with prior libjpeg-turbo\nreleases.\n\n6. The MIPS DSPr2 SIMD code can now be compiled to support either FR=0 or FR=1\nFPUs.\n\n7. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers.  Most of these issues affected only\n32-bit code, and none of them was known to pose a security threat, but removing\nthe warnings makes it easier to detect actual security issues, should they\narise in the future.\n\n8. Removed the unnecessary `.arch` directive from the ARM64 NEON SIMD code.\nThis directive was preventing the code from assembling using the clang\nintegrated assembler.\n\n9. Fixed a regression caused by 1.4.1[6] that prevented 32-bit and 64-bit\nlibjpeg-turbo RPMs from being installed simultaneously on recent Red Hat/Fedora\ndistributions.  This was due to the addition of a macro in jconfig.h that\nallows the Huffman codec to determine the word size at compile time.  Since\nthat macro differs between 32-bit and 64-bit builds, this caused a conflict\nbetween the i386 and x86_64 RPMs (any differing files, other than executables,\nare not allowed when 32-bit and 64-bit RPMs are installed simultaneously.)\nSince the macro is used only internally, it has been moved into jconfigint.h.\n\n10. The x86-64 SIMD code can now be disabled at run time by setting the\n`JSIMD_FORCENONE` environment variable to `1` (the other SIMD implementations\nalready had this capability.)\n\n11. Added a new command-line argument to TJBench (`-nowrite`) that prevents the\nbenchmark from outputting any images.  This removes any potential operating\nsystem overhead that might be caused by lazy writes to disk and thus improves\nthe consistency of the performance measurements.\n\n12. Added SIMD acceleration for Huffman encoding on SSE2-capable x86 and x86-64\nplatforms.  This speeds up the compression of full-color JPEGs by about 10-15%\non average (relative to libjpeg-turbo 1.4.x) when using modern Intel and AMD\nCPUs.  Additionally, this works around an issue in the clang optimizer that\nprevents it (as of this writing) from achieving the same performance as GCC\nwhen compiling the C version of the Huffman encoder\n(<https://llvm.org/bugs/show_bug.cgi?id=16035>).  For the purposes of\nbenchmarking or regression testing, SIMD-accelerated Huffman encoding can be\ndisabled by setting the `JSIMD_NOHUFFENC` environment variable to `1`.\n\n13. Added ARM 64-bit (ARMv8) NEON SIMD implementations of the commonly-used\ncompression algorithms (including the accurate integer forward DCT and h2v2 &\nh2v1 downsampling algorithms, which are not accelerated in the 32-bit NEON\nimplementation.)  This speeds up the compression of full-color JPEGs by about\n75% on average on a Cavium ThunderX processor and by about 2-2.5x on average on\nCortex-A53 and Cortex-A57 cores.\n\n14. Added SIMD acceleration for Huffman encoding on NEON-capable ARM 32-bit\nand 64-bit platforms.\n\n    For 32-bit code, this speeds up the compression of full-color JPEGs by\nabout 30% on average on a typical iOS device (iPhone 4S, Cortex-A9) and by\nabout 6-7% on average on a typical Android device (Nexus 5X, Cortex-A53 and\nCortex-A57), relative to libjpeg-turbo 1.4.x.  Note that the larger speedup\nunder iOS is due to the fact that iOS builds use LLVM, which does not optimize\nthe C Huffman encoder as well as GCC does.\n\n    For 64-bit code, NEON-accelerated Huffman encoding speeds up the\ncompression of full-color JPEGs by about 40% on average on a typical iOS device\n(iPhone 5S, Apple A7) and by about 7-8% on average on a typical Android device\n(Nexus 5X, Cortex-A53 and Cortex-A57), in addition to the speedup described in\n[13] above.\n\n    For the purposes of benchmarking or regression testing, SIMD-accelerated\nHuffman encoding can be disabled by setting the `JSIMD_NOHUFFENC` environment\nvariable to `1`.\n\n15. pkg-config (.pc) scripts are now included for both the libjpeg and\nTurboJPEG API libraries on Un*x systems.  Note that if a project's build system\nrelies on these scripts, then it will not be possible to build that project\nwith libjpeg or with a prior version of libjpeg-turbo.\n\n16. Optimized the ARM 64-bit (ARMv8) NEON SIMD decompression routines to\nimprove performance on CPUs with in-order pipelines.  This speeds up the\ndecompression of full-color JPEGs by nearly 2x on average on a Cavium ThunderX\nprocessor and by about 15% on average on a Cortex-A53 core.\n\n17. Fixed an issue in the accelerated Huffman decoder that could have caused\nthe decoder to read past the end of the input buffer when a malformed,\nspecially-crafted JPEG image was being decompressed.  In prior versions of\nlibjpeg-turbo, the accelerated Huffman decoder was invoked (in most cases) only\nif there were > 128 bytes of data in the input buffer.  However, it is possible\nto construct a JPEG image in which a single Huffman block is over 430 bytes\nlong, so this version of libjpeg-turbo activates the accelerated Huffman\ndecoder only if there are > 512 bytes of data in the input buffer.\n\n18. Fixed a memory leak in tjunittest encountered when running the program\nwith the `-yuv` option.\n\n\n1.4.2\n=====\n\n### Significant changes relative to 1.4.1:\n\n1. Fixed an issue whereby cjpeg would segfault if a Windows bitmap with a\nnegative width or height was used as an input image (Windows bitmaps can have\na negative height if they are stored in top-down order, but such files are\nrare and not supported by libjpeg-turbo.)\n\n2. Fixed an issue whereby, under certain circumstances, libjpeg-turbo would\nincorrectly encode certain JPEG images when quality=100 and the fast integer\nforward DCT were used.  This was known to cause `make test` to fail when the\nlibrary was built with `-march=haswell` on x86 systems.\n\n3. Fixed an issue whereby libjpeg-turbo would crash when built with the latest\n& greatest development version of the Clang/LLVM compiler.  This was caused by\nan x86-64 ABI conformance issue in some of libjpeg-turbo's 64-bit SSE2 SIMD\nroutines.  Those routines were incorrectly using a 64-bit `mov` instruction to\ntransfer a 32-bit JDIMENSION argument, whereas the x86-64 ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fixed a bug in the MIPS DSPr2 4:2:0 \"plain\" (non-fancy and non-merged)\nupsampling routine that caused a buffer overflow (and subsequent segfault) when\ndecompressing a 4:2:0 JPEG image whose scaled output width was less than 16\npixels.  The \"plain\" upsampling routines are normally only used when\ndecompressing a non-YCbCr JPEG image, but they are also used when decompressing\na JPEG image whose scaled output height is 1.\n\n5. Fixed various negative left shifts and other issues reported by the GCC and\nClang undefined behavior sanitizers.  None of these was known to pose a\nsecurity threat, but removing the warnings makes it easier to detect actual\nsecurity issues, should they arise in the future.\n\n\n1.4.1\n=====\n\n### Significant changes relative to 1.4.0:\n\n1. tjbench now properly handles CMYK/YCCK JPEG files.  Passing an argument of\n`-cmyk` (instead of, for instance, `-rgb`) will cause tjbench to internally\nconvert the source bitmap to CMYK prior to compression, to generate YCCK JPEG\nfiles, and to internally convert the decompressed CMYK pixels back to RGB after\ndecompression (the latter is done automatically if a CMYK or YCCK JPEG is\npassed to tjbench as a source image.)  The CMYK<->RGB conversion operation is\nnot benchmarked.  NOTE: The quick & dirty CMYK<->RGB conversions that tjbench\nuses are suitable for testing only.  Proper conversion between CMYK and RGB\nrequires a color management system.\n\n2. `make test` now performs additional bitwise regression tests using tjbench,\nmainly for the purpose of testing compression from/decompression to a subregion\nof a larger image buffer.\n\n3. `make test` no longer tests the regression of the floating point DCT/IDCT\nby default, since the results of those tests can vary if the algorithms in\nquestion are not implemented using SIMD instructions on a particular platform.\nSee the comments in [Makefile.am](Makefile.am) for information on how to\nre-enable the tests and to specify an expected result for them based on the\nparticulars of your platform.\n\n4. The NULL color conversion routines have been significantly optimized,\nwhich speeds up the compression of RGB and CMYK JPEGs by 5-20% when using\n64-bit code and 0-3% when using 32-bit code, and the decompression of those\nimages by 10-30% when using 64-bit code and 3-12% when using 32-bit code.\n\n5. Fixed an \"illegal instruction\" error that occurred when djpeg from a\nSIMD-enabled libjpeg-turbo MIPS build was executed with the `-nosmooth` option\non a MIPS machine that lacked DSPr2 support.  The MIPS SIMD routines for h2v1\nand h2v2 merged upsampling were not properly checking for the existence of\nDSPr2.\n\n6. Performance has been improved significantly on 64-bit non-Linux and\nnon-Windows platforms (generally 10-20% faster compression and 5-10% faster\ndecompression.)  Due to an oversight, the 64-bit version of the accelerated\nHuffman codec was not being compiled in when libjpeg-turbo was built on\nplatforms other than Windows or Linux.  Oops.\n\n7. Fixed an extremely rare bug in the Huffman encoder that caused 64-bit\nbuilds of libjpeg-turbo to incorrectly encode a few specific test images when\nquality=98, an optimized Huffman table, and the accurate integer forward DCT\nwere used.\n\n8. The Windows (CMake) build system now supports building only static or only\nshared libraries.  This is accomplished by adding either `-DENABLE_STATIC=0` or\n`-DENABLE_SHARED=0` to the CMake command line.\n\n9. TurboJPEG API functions will now return an error code if a warning is\ntriggered in the underlying libjpeg API.  For instance, if a JPEG file is\ncorrupt, the TurboJPEG decompression functions will attempt to decompress\nas much of the image as possible, but those functions will now return -1 to\nindicate that the decompression was not entirely successful.\n\n10. Fixed a bug in the MIPS DSPr2 4:2:2 fancy upsampling routine that caused a\nbuffer overflow (and subsequent segfault) when decompressing a 4:2:2 JPEG image\nin which the right-most MCU was 5 or 6 pixels wide.\n\n\n1.4.0\n=====\n\n### Significant changes relative to 1.4 beta1:\n\n1. Fixed a build issue on OS X PowerPC platforms (md5cmp failed to build\nbecause OS X does not provide the `le32toh()` and `htole32()` functions.)\n\n2. The non-SIMD RGB565 color conversion code did not work correctly on big\nendian machines.  This has been fixed.\n\n3. Fixed an issue in `tjPlaneSizeYUV()` whereby it would erroneously return 1\ninstead of -1 if `componentID` was > 0 and `subsamp` was `TJSAMP_GRAY`.\n\n3. Fixed an issue in `tjBufSizeYUV2()` whereby it would erroneously return 0\ninstead of -1 if `width` was < 1.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM64 platforms (see 1.4 beta1[5].)\n\n6. The `close()` method in the TJCompressor and TJDecompressor Java classes is\nnow idempotent.  Previously, that method would call the native `tjDestroy()`\nfunction even if the TurboJPEG instance had already been destroyed.  This\ncaused an exception to be thrown during finalization, if the `close()` method\nhad already been called.  The exception was caught, but it was still an\nexpensive operation.\n\n7. The TurboJPEG API previously generated an error (`Could not determine\nsubsampling type for JPEG image`) when attempting to decompress grayscale JPEG\nimages that were compressed with a sampling factor other than 1 (for instance,\nwith `cjpeg -grayscale -sample 2x2`).  Subsampling technically has no meaning\nwith grayscale JPEGs, and thus the horizontal and vertical sampling factors\nfor such images are ignored by the decompressor.  However, the TurboJPEG API\nwas being too rigid and was expecting the sampling factors to be equal to 1\nbefore it treated the image as a grayscale JPEG.\n\n8. cjpeg, djpeg, and jpegtran now accept an argument of `-version`, which will\nprint the library version and exit.\n\n9. Referring to 1.4 beta1[15], another extremely rare circumstance was\ndiscovered under which the Huffman encoder's local buffer can be overrun\nwhen a buffered destination manager is being used and an\nextremely-high-frequency block (basically junk image data) is being encoded.\nEven though the Huffman local buffer was increased from 128 bytes to 136 bytes\nto address the previous issue, the new issue caused even the larger buffer to\nbe overrun.  Further analysis reveals that, in the absolute worst case (such as\nsetting alternating AC coefficients to 32767 and -32768 in the JPEG scanning\norder), the Huffman encoder can produce encoded blocks that approach double the\nsize of the unencoded blocks.  Thus, the Huffman local buffer was increased to\n256 bytes, which should prevent any such issue from re-occurring in the future.\n\n10. The new `tjPlaneSizeYUV()`, `tjPlaneWidth()`, and `tjPlaneHeight()`\nfunctions were not actually usable on any platform except OS X and Windows,\nbecause those functions were not included in the libturbojpeg mapfile.  This\nhas been fixed.\n\n11. Restored the `JPP()`, `JMETHOD()`, and `FAR` macros in the libjpeg-turbo\nheader files.  The `JPP()` and `JMETHOD()` macros were originally implemented\nin libjpeg as a way of supporting non-ANSI compilers that lacked support for\nprototype parameters.  libjpeg-turbo has never supported such compilers, but\nsome software packages still use the macros to define their own prototypes.\nSimilarly, libjpeg-turbo has never supported MS-DOS and other platforms that\nhave far symbols, but some software packages still use the `FAR` macro.  A\npretty good argument can be made that this is a bad practice on the part of the\nsoftware in question, but since this affects more than one package, it's just\neasier to fix it here.\n\n12. Fixed issues that were preventing the ARM 64-bit SIMD code from compiling\nfor iOS, and included an ARMv8 architecture in all of the binaries installed by\nthe \"official\" libjpeg-turbo SDK for OS X.\n\n\n1.3.90 (1.4 beta1)\n==================\n\n### Significant changes relative to 1.3.1:\n\n1. New features in the TurboJPEG API:\n\n     - YUV planar images can now be generated with an arbitrary line padding\n(previously only 4-byte padding, which was compatible with X Video, was\nsupported.)\n     - The decompress-to-YUV function has been extended to support image\nscaling.\n     - JPEG images can now be compressed from YUV planar source images.\n     - YUV planar images can now be decoded into RGB or grayscale images.\n     - 4:1:1 subsampling is now supported.  This is mainly included for\ncompatibility, since 4:1:1 is not fully accelerated in libjpeg-turbo and has no\nsignificant advantages relative to 4:2:0.\n     - CMYK images are now supported.  This feature allows CMYK source images\nto be compressed to YCCK JPEGs and YCCK or CMYK JPEGs to be decompressed to\nCMYK destination images.  Conversion between CMYK/YCCK and RGB or YUV images is\nnot supported.  Such conversion requires a color management system and is thus\nout of scope for a codec library.\n     - The handling of YUV images in the Java API has been significantly\nrefactored and should now be much more intuitive.\n     - The Java API now supports encoding a YUV image from an arbitrary\nposition in a large image buffer.\n     - All of the YUV functions now have a corresponding function that operates\non separate image planes instead of a unified image buffer.  This allows for\ncompressing/decoding from or decompressing/encoding to a subregion of a larger\nYUV image.  It also allows for handling YUV formats that swap the order of the\nU and V planes.\n\n2. Added SIMD acceleration for DSPr2-capable MIPS platforms.  This speeds up\nthe compression of full-color JPEGs by 70-80% on such platforms and\ndecompression by 25-35%.\n\n3. If an application attempts to decompress a Huffman-coded JPEG image whose\nheader does not contain Huffman tables, libjpeg-turbo will now insert the\ndefault Huffman tables.  In order to save space, many motion JPEG video frames\nare encoded without the default Huffman tables, so these frames can now be\nsuccessfully decompressed by libjpeg-turbo without additional work on the part\nof the application.  An application can still override the Huffman tables, for\ninstance to re-use tables from a previous frame of the same video.\n\n4. The Mac packaging system now uses pkgbuild and productbuild rather than\nPackageMaker (which is obsolete and no longer supported.)  This means that\nOS X 10.6 \"Snow Leopard\" or later must be used when packaging libjpeg-turbo,\nalthough the packages produced can be installed on OS X 10.5 \"Leopard\" or\nlater.  OS X 10.4 \"Tiger\" is no longer supported.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM platforms rather than a lookup table.  This reduces the memory footprint\nby 64k, which may be important for some mobile applications.  Out of four\nAndroid devices that were tested, two demonstrated a small overall performance\nloss (~3-4% on average) with ARMv6 code and a small gain (also ~3-4%) with\nARMv7 code when enabling this new feature, but the other two devices\ndemonstrated a significant overall performance gain with both ARMv6 and ARMv7\ncode (~10-20%) when enabling the feature.  Actual mileage may vary.\n\n6. Worked around an issue with Visual C++ 2010 and later that caused incorrect\npixels to be generated when decompressing a JPEG image to a 256-color bitmap,\nif compiler optimization was enabled when libjpeg-turbo was built.  This caused\nthe regression tests to fail when doing a release build under Visual C++ 2010\nand later.\n\n7. Improved the accuracy and performance of the non-SIMD implementation of the\nfloating point inverse DCT (using code borrowed from libjpeg v8a and later.)\nThe accuracy of this implementation now matches the accuracy of the SSE/SSE2\nimplementation.  Note, however, that the floating point DCT/IDCT algorithms are\nmainly a legacy feature.  They generally do not produce significantly better\naccuracy than the accurate integer DCT/IDCT algorithms, and they are quite a\nbit slower.\n\n8. Added a new output colorspace (`JCS_RGB565`) to the libjpeg API that allows\nfor decompressing JPEG images into RGB565 (16-bit) pixels.  If dithering is not\nused, then this code path is SIMD-accelerated on ARM platforms.\n\n9. Numerous obsolete features, such as support for non-ANSI compilers and\nsupport for the MS-DOS memory model, were removed from the libjpeg code,\ngreatly improving its readability and making it easier to maintain and extend.\n\n10. Fixed a segfault that occurred when calling `output_message()` with\n`msg_code` set to `JMSG_COPYRIGHT`.\n\n11. Fixed an issue whereby wrjpgcom was allowing comments longer than 65k\ncharacters to be passed on the command line, which was causing it to generate\nincorrect JPEG files.\n\n12. Fixed a bug in the build system that was causing the Windows version of\nwrjpgcom to be built using the rdjpgcom source code.\n\n13. Restored 12-bit-per-component JPEG support.  A 12-bit version of\nlibjpeg-turbo can now be built by passing an argument of `--with-12bit` to\nconfigure (Unix) or `-DWITH_12BIT=1` to cmake (Windows.)  12-bit JPEG support\nis included only for convenience.  Enabling this feature disables all of the\nperformance features in libjpeg-turbo, as well as arithmetic coding and the\nTurboJPEG API.  The resulting library still contains the other libjpeg-turbo\nfeatures (such as the colorspace extensions), but in general, it performs no\nfaster than libjpeg v6b.\n\n14. Added ARM 64-bit SIMD acceleration for the YCC-to-RGB color conversion\nand IDCT algorithms (both are used during JPEG decompression.)  For\nreasons (probably related to clang), this code cannot currently be compiled for\niOS.\n\n15. Fixed an extremely rare bug (CVE-2014-9092) that could cause the Huffman\nencoder's local buffer to overrun when a very high-frequency MCU is compressed\nusing quality 100 and no subsampling, and when the JPEG output buffer is being\ndynamically resized by the destination manager.  This issue was so rare that,\neven with a test program specifically designed to make the bug occur (by\ninjecting random high-frequency YUV data into the compressor), it was\nreproducible only once in about every 25 million iterations.\n\n16. Fixed an oversight in the TurboJPEG C wrapper:  if any of the JPEG\ncompression functions was called repeatedly with the same\nautomatically-allocated destination buffer, then TurboJPEG would erroneously\nassume that the `jpegSize` parameter was equal to the size of the buffer, when\nin fact that parameter was probably equal to the size of the most recently\ncompressed JPEG image.  If the size of the previous JPEG image was not as large\nas the current JPEG image, then TurboJPEG would unnecessarily reallocate the\ndestination buffer.\n\n\n1.3.1\n=====\n\n### Significant changes relative to 1.3.0:\n\n1. On Un*x systems, `make install` now installs the libjpeg-turbo libraries\ninto /opt/libjpeg-turbo/lib32 by default on any 32-bit system, not just x86,\nand into /opt/libjpeg-turbo/lib64 by default on any 64-bit system, not just\nx86-64.  You can override this by overriding either the `prefix` or `libdir`\nconfigure variables.\n\n2. The Windows installer now places a copy of the TurboJPEG DLLs in the same\ndirectory as the rest of the libjpeg-turbo binaries.  This was mainly done\nto support TurboVNC 1.3, which bundles the DLLs in its Windows installation.\nWhen using a 32-bit version of CMake on 64-bit Windows, it is impossible to\naccess the c:\\WINDOWS\\system32 directory, which made it impossible for the\nTurboVNC build scripts to bundle the 64-bit TurboJPEG DLL.\n\n3. Fixed a bug whereby attempting to encode a progressive JPEG with arithmetic\nentropy coding (by passing arguments of `-progressive -arithmetic` to cjpeg or\njpegtran, for instance) would result in an error, `Requested feature was\nomitted at compile time`.\n\n4. Fixed a couple of issues (CVE-2013-6629 and CVE-2013-6630) whereby malformed\nJPEG images would cause libjpeg-turbo to use uninitialized memory during\ndecompression.\n\n5. Fixed an error (`Buffer passed to JPEG library is too small`) that occurred\nwhen calling the TurboJPEG YUV encoding function with a very small (< 5x5)\nsource image, and added a unit test to check for this error.\n\n6. The Java classes should now build properly under Visual Studio 2010 and\nlater.\n\n7. Fixed an issue that prevented SRPMs generated using the in-tree packaging\ntools from being rebuilt on certain newer Linux distributions.\n\n8. Numerous minor fixes to eliminate compilation and build/packaging system\nwarnings, fix cosmetic issues, improve documentation clarity, and other general\nsource cleanup.\n\n\n1.3.0\n=====\n\n### Significant changes relative to 1.3 beta1:\n\n1. `make test` now works properly on FreeBSD, and it no longer requires the\nmd5sum executable to be present on other Un*x platforms.\n\n2. Overhauled the packaging system:\n\n     - To avoid conflict with vendor-supplied libjpeg-turbo packages, the\nofficial RPMs and DEBs for libjpeg-turbo have been renamed to\n\"libjpeg-turbo-official\".\n     - The TurboJPEG libraries are now located under /opt/libjpeg-turbo in the\nofficial Linux and Mac packages, to avoid conflict with vendor-supplied\npackages and also to streamline the packaging system.\n     - Release packages are now created with the directory structure defined\nby the configure variables `prefix`, `bindir`, `libdir`, etc. (Un\\*x) or by the\n`CMAKE_INSTALL_PREFIX` variable (Windows.)  The exception is that the docs are\nalways located under the system default documentation directory on Un\\*x and\nMac systems, and on Windows, the TurboJPEG DLL is always located in the Windows\nsystem directory.\n     - To avoid confusion, official libjpeg-turbo packages on Linux/Unix\nplatforms (except for Mac) will always install the 32-bit libraries in\n/opt/libjpeg-turbo/lib32 and the 64-bit libraries in /opt/libjpeg-turbo/lib64.\n     - Fixed an issue whereby, in some cases, the libjpeg-turbo executables on\nUn*x systems were not properly linking with the shared libraries installed by\nthe same package.\n     - Fixed an issue whereby building the \"installer\" target on Windows when\n`WITH_JAVA=1` would fail if the TurboJPEG JAR had not been previously built.\n     - Building the \"install\" target on Windows now installs files into the\nsame places that the installer does.\n\n3. Fixed a Huffman encoder bug that prevented I/O suspension from working\nproperly.\n\n\n1.2.90 (1.3 beta1)\n==================\n\n### Significant changes relative to 1.2.1:\n\n1. Added support for additional scaling factors (3/8, 5/8, 3/4, 7/8, 9/8, 5/4,\n11/8, 3/2, 13/8, 7/4, 15/8, and 2) when decompressing.  Note that the IDCT will\nnot be SIMD-accelerated when using any of these new scaling factors.\n\n2. The TurboJPEG dynamic library is now versioned.  It was not strictly\nnecessary to do so, because TurboJPEG uses versioned symbols, and if a function\nchanges in an ABI-incompatible way, that function is renamed and a legacy\nfunction is provided to maintain backward compatibility.  However, certain\nLinux distro maintainers have a policy against accepting any library that isn't\nversioned.\n\n3. Extended the TurboJPEG Java API so that it can be used to compress a JPEG\nimage from and decompress a JPEG image to an arbitrary position in a large\nimage buffer.\n\n4. The `tjDecompressToYUV()` function now supports the `TJFLAG_FASTDCT` flag.\n\n5. The 32-bit supplementary package for amd64 Debian systems now provides\nsymlinks in /usr/lib/i386-linux-gnu for the TurboJPEG libraries in /usr/lib32.\nThis allows those libraries to be used on MultiArch-compatible systems (such as\nUbuntu 11 and later) without setting the linker path.\n\n6. The TurboJPEG Java wrapper should now find the JNI library on Mac systems\nwithout having to pass `-Djava.library.path=/usr/lib` to java.\n\n7. TJBench has been ported to Java to provide a convenient way of validating\nthe performance of the TurboJPEG Java API.  It can be run with\n`java -cp turbojpeg.jar TJBench`.\n\n8. cjpeg can now be used to generate JPEG files with the RGB colorspace\n(feature ported from jpeg-8d.)\n\n9. The width and height in the `-crop` argument passed to jpegtran can now be\nsuffixed with `f` to indicate that, when the upper left corner of the cropping\nregion is automatically moved to the nearest iMCU boundary, the bottom right\ncorner should be moved by the same amount.  In other words, this feature causes\njpegtran to strictly honor the specified width/height rather than the specified\nbottom right corner (feature ported from jpeg-8d.)\n\n10. JPEG files using the RGB colorspace can now be decompressed into grayscale\nimages (feature ported from jpeg-8d.)\n\n11. Fixed a regression caused by 1.2.1[7] whereby the build would fail with\nmultiple \"Mismatch in operand sizes\" errors when attempting to build the x86\nSIMD code with NASM 0.98.\n\n12. The in-memory source/destination managers (`jpeg_mem_src()` and\n`jpeg_mem_dest()`) are now included by default when building libjpeg-turbo with\nlibjpeg v6b or v7 emulation, so that programs can take advantage of these\nfunctions without requiring the use of the backward-incompatible libjpeg v8\nABI.  The \"age number\" of the libjpeg-turbo library on Un*x systems has been\nincremented by 1 to reflect this.  You can disable this feature with a\nconfigure/CMake switch in order to retain strict API/ABI compatibility with the\nlibjpeg v6b or v7 API/ABI (or with previous versions of libjpeg-turbo.)  See\n[README.md](README.md) for more details.\n\n13. Added ARMv7s architecture to libjpeg.a and libturbojpeg.a in the official\nlibjpeg-turbo binary package for OS X, so that those libraries can be used to\nbuild applications that leverage the faster CPUs in the iPhone 5 and iPad 4.\n\n\n1.2.1\n=====\n\n### Significant changes relative to 1.2.0:\n\n1. Creating or decoding a JPEG file that uses the RGB colorspace should now\nproperly work when the input or output colorspace is one of the libjpeg-turbo\ncolorspace extensions.\n\n2. When libjpeg-turbo was built without SIMD support and merged (non-fancy)\nupsampling was used along with an alpha-enabled colorspace during\ndecompression, the unused byte of the decompressed pixels was not being set to\n0xFF.  This has been fixed.  TJUnitTest has also been extended to test for the\ncorrect behavior of the colorspace extensions when merged upsampling is used.\n\n3. Fixed a bug whereby the libjpeg-turbo SSE2 SIMD code would not preserve the\nupper 64 bits of xmm6 and xmm7 on Win64 platforms, which violated the Win64\ncalling conventions.\n\n4. Fixed a regression (CVE-2012-2806) caused by 1.2.0[6] whereby decompressing\ncorrupt JPEG images (specifically, images in which the component count was\nerroneously set to a large value) would cause libjpeg-turbo to segfault.\n\n5. Worked around a severe performance issue with \"Bobcat\" (AMD Embedded APU)\nprocessors.  The `MASKMOVDQU` instruction, which was used by the libjpeg-turbo\nSSE2 SIMD code, is apparently implemented in microcode on AMD processors, and\nit is painfully slow on Bobcat processors in particular.  Eliminating the use\nof this instruction improved performance by an order of magnitude on Bobcat\nprocessors and by a small amount (typically 5%) on AMD desktop processors.\n\n6. Added SIMD acceleration for performing 4:2:2 upsampling on NEON-capable ARM\nplatforms.  This speeds up the decompression of 4:2:2 JPEGs by 20-25% on such\nplatforms.\n\n7. Fixed a regression caused by 1.2.0[2] whereby, on Linux/x86 platforms\nrunning the 32-bit SSE2 SIMD code in libjpeg-turbo, decompressing a 4:2:0 or\n4:2:2 JPEG image into a 32-bit (RGBX, BGRX, etc.) buffer without using fancy\nupsampling would produce several incorrect columns of pixels at the right-hand\nside of the output image if each row in the output image was not evenly\ndivisible by 16 bytes.\n\n8. Fixed an issue whereby attempting to build the SIMD extensions with Xcode\n4.3 on OS X platforms would cause NASM to return numerous errors of the form\n\"'%define' expects a macro identifier\".\n\n9. Added flags to the TurboJPEG API that allow the caller to force the use of\neither the fast or the accurate DCT/IDCT algorithms in the underlying codec.\n\n\n1.2.0\n=====\n\n### Significant changes relative to 1.2 beta1:\n\n1. Fixed build issue with Yasm on Unix systems (the libjpeg-turbo build system\nwas not adding the current directory to the assembler include path, so Yasm\nwas not able to find jsimdcfg.inc.)\n\n2. Fixed out-of-bounds read in SSE2 SIMD code that occurred when decompressing\na JPEG image to a bitmap buffer whose size was not a multiple of 16 bytes.\nThis was more of an annoyance than an actual bug, since it did not cause any\nactual run-time problems, but the issue showed up when running libjpeg-turbo in\nvalgrind.  See <http://crbug.com/72399> for more information.\n\n3. Added a compile-time macro (`LIBJPEG_TURBO_VERSION`) that can be used to\ncheck the version of libjpeg-turbo against which an application was compiled.\n\n4. Added new RGBA/BGRA/ABGR/ARGB colorspace extension constants (libjpeg API)\nand pixel formats (TurboJPEG API), which allow applications to specify that,\nwhen decompressing to a 4-component RGB buffer, the unused byte should be set\nto 0xFF so that it can be interpreted as an opaque alpha channel.\n\n5. Fixed regression issue whereby DevIL failed to build against libjpeg-turbo\nbecause libjpeg-turbo's distributed version of jconfig.h contained an `INLINE`\nmacro, which conflicted with a similar macro in DevIL.  This macro is used only\ninternally when building libjpeg-turbo, so it was moved into config.h.\n\n6. libjpeg-turbo will now correctly decompress erroneous CMYK/YCCK JPEGs whose\nK component is assigned a component ID of 1 instead of 4.  Although these files\nare in violation of the spec, other JPEG implementations handle them\ncorrectly.\n\n7. Added ARMv6 and ARMv7 architectures to libjpeg.a and libturbojpeg.a in\nthe official libjpeg-turbo binary package for OS X, so that those libraries can\nbe used to build both OS X and iOS applications.\n\n\n1.1.90 (1.2 beta1)\n==================\n\n### Significant changes relative to 1.1.1:\n\n1. Added a Java wrapper for the TurboJPEG API.  See [java/README](java/README)\nfor more details.\n\n2. The TurboJPEG API can now be used to scale down images during\ndecompression.\n\n3. Added SIMD routines for RGB-to-grayscale color conversion, which\nsignificantly improves the performance of grayscale JPEG compression from an\nRGB source image.\n\n4. Improved the performance of the C color conversion routines, which are used\non platforms for which SIMD acceleration is not available.\n\n5. Added a function to the TurboJPEG API that performs lossless transforms.\nThis function is implemented using the same back end as jpegtran, but it\nperforms transcoding entirely in memory and allows multiple transforms and/or\ncrop operations to be batched together, so the source coefficients only need to\nbe read once.  This is useful when generating image tiles from a single source\nJPEG.\n\n6. Added tests for the new TurboJPEG scaled decompression and lossless\ntransform features to tjbench (the TurboJPEG benchmark, formerly called\n\"jpgtest\".)\n\n7. Added support for 4:4:0 (transposed 4:2:2) subsampling in TurboJPEG, which\nwas necessary in order for it to read 4:2:2 JPEG files that had been losslessly\ntransposed or rotated 90 degrees.\n\n8. All legacy VirtualGL code has been re-factored, and this has allowed\nlibjpeg-turbo, in its entirety, to be re-licensed under a BSD-style license.\n\n9. libjpeg-turbo can now be built with Yasm.\n\n10. Added SIMD acceleration for ARM Linux and iOS platforms that support\nNEON instructions.\n\n11. Refactored the TurboJPEG C API and documented it using Doxygen.  The\nTurboJPEG 1.2 API uses pixel formats to define the size and component order of\nthe uncompressed source/destination images, and it includes a more efficient\nversion of `TJBUFSIZE()` that computes a worst-case JPEG size based on the\nlevel of chrominance subsampling.  The refactored implementation of the\nTurboJPEG API now uses the libjpeg memory source and destination managers,\nwhich allows the TurboJPEG compressor to grow the JPEG buffer as necessary.\n\n12. Eliminated errors in the output of jpegtran on Windows that occurred when\nthe application was invoked using I/O redirection\n(`jpegtran <input.jpg >output.jpg`.)\n\n13. The inclusion of libjpeg v7 and v8 emulation as well as arithmetic coding\nsupport in libjpeg-turbo v1.1.0 introduced several new error constants in\njerror.h, and these were mistakenly enabled for all emulation modes, causing\nthe error enum in libjpeg-turbo to sometimes have different values than the\nsame enum in libjpeg.  This represents an ABI incompatibility, and it caused\nproblems with rare applications that took specific action based on a particular\nerror value.  The fix was to include the new error constants conditionally\nbased on whether libjpeg v7 or v8 emulation was enabled.\n\n14. Fixed an issue whereby Windows applications that used libjpeg-turbo would\nfail to compile if the Windows system headers were included before jpeglib.h.\nThis issue was caused by a conflict in the definition of the INT32 type.\n\n15. Fixed 32-bit supplementary package for amd64 Debian systems, which was\nbroken by enhancements to the packaging system in 1.1.\n\n16. When decompressing a JPEG image using an output colorspace of\n`JCS_EXT_RGBX`, `JCS_EXT_BGRX`, `JCS_EXT_XBGR`, or `JCS_EXT_XRGB`,\nlibjpeg-turbo will now set the unused byte to 0xFF, which allows applications\nto interpret that byte as an alpha channel (0xFF = opaque).\n\n\n1.1.1\n=====\n\n### Significant changes relative to 1.1.0:\n\n1. Fixed a 1-pixel error in row 0, column 21 of the luminance plane generated\nby `tjEncodeYUV()`.\n\n2. libjpeg-turbo's accelerated Huffman decoder previously ignored unexpected\nmarkers found in the middle of the JPEG data stream during decompression.  It\nwill now hand off decoding of a particular block to the unaccelerated Huffman\ndecoder if an unexpected marker is found, so that the unaccelerated Huffman\ndecoder can generate an appropriate warning.\n\n3. Older versions of MinGW64 prefixed symbol names with underscores by\ndefault, which differed from the behavior of 64-bit Visual C++.  MinGW64 1.0\nhas adopted the behavior of 64-bit Visual C++ as the default, so to accommodate\nthis, the libjpeg-turbo SIMD function names are no longer prefixed with an\nunderscore when building with MinGW64.  This means that, when building\nlibjpeg-turbo with older versions of MinGW64, you will now have to add\n`-fno-leading-underscore` to the `CFLAGS`.\n\n4. Fixed a regression bug in the NSIS script that caused the Windows installer\nbuild to fail when using the Visual Studio IDE.\n\n5. Fixed a bug in `jpeg_read_coefficients()` whereby it would not initialize\n`cinfo->image_width` and `cinfo->image_height` if libjpeg v7 or v8 emulation\nwas enabled.  This specifically caused the jpegoptim program to fail if it was\nlinked against a version of libjpeg-turbo that was built with libjpeg v7 or v8\nemulation.\n\n6. Eliminated excessive I/O overhead that occurred when reading BMP files in\ncjpeg.\n\n7. Eliminated errors in the output of cjpeg on Windows that occurred when the\napplication was invoked using I/O redirection (`cjpeg <inputfile >output.jpg`.)\n\n\n1.1.0\n=====\n\n### Significant changes relative to 1.1 beta1:\n\n1. The algorithm used by the SIMD quantization function cannot produce correct\nresults when the JPEG quality is >= 98 and the fast integer forward DCT is\nused.  Thus, the non-SIMD quantization function is now used for those cases,\nand libjpeg-turbo should now produce identical output to libjpeg v6b in all\ncases.\n\n2. Despite the above, the fast integer forward DCT still degrades somewhat for\nJPEG qualities greater than 95, so the TurboJPEG wrapper will now automatically\nuse the accurate integer forward DCT when generating JPEG images of quality 96\nor greater.  This reduces compression performance by as much as 15% for these\nhigh-quality images but is necessary to ensure that the images are perceptually\nlossless.  It also ensures that the library can avoid the performance pitfall\ncreated by [1].\n\n3. Ported jpgtest.cxx to pure C to avoid the need for a C++ compiler.\n\n4. Fixed visual artifacts in grayscale JPEG compression caused by a typo in\nthe RGB-to-luminance lookup tables.\n\n5. The Windows distribution packages now include the libjpeg run-time programs\n(cjpeg, etc.)\n\n6. All packages now include jpgtest.\n\n7. The TurboJPEG dynamic library now uses versioned symbols.\n\n8. Added two new TurboJPEG API functions, `tjEncodeYUV()` and\n`tjDecompressToYUV()`, to replace the somewhat hackish `TJ_YUV` flag.\n\n\n1.0.90 (1.1 beta1)\n==================\n\n### Significant changes relative to 1.0.1:\n\n1. Added emulation of the libjpeg v7 and v8 APIs and ABIs.  See\n[README.md](README.md) for more details.  This feature was sponsored by\nCamTrace SAS.\n\n2. Created a new CMake-based build system for the Visual C++ and MinGW builds.\n\n3. Grayscale bitmaps can now be compressed from/decompressed to using the\nTurboJPEG API.\n\n4. jpgtest can now be used to test decompression performance with existing\nJPEG images.\n\n5. If the default install prefix (/opt/libjpeg-turbo) is used, then\n`make install` now creates /opt/libjpeg-turbo/lib32 and\n/opt/libjpeg-turbo/lib64 sym links to duplicate the behavior of the binary\npackages.\n\n6. All symbols in the libjpeg-turbo dynamic library are now versioned, even\nwhen the library is built with libjpeg v6b emulation.\n\n7. Added arithmetic encoding and decoding support (can be disabled with\nconfigure or CMake options)\n\n8. Added a `TJ_YUV` flag to the TurboJPEG API, which causes both the compressor\nand decompressor to output planar YUV images.\n\n9. Added an extended version of `tjDecompressHeader()` to the TurboJPEG API,\nwhich allows the caller to determine the type of subsampling used in a JPEG\nimage.\n\n10. Added further protections against invalid Huffman codes.\n\n\n1.0.1\n=====\n\n### Significant changes relative to 1.0.0:\n\n1. The Huffman decoder will now handle erroneous Huffman codes (for instance,\nfrom a corrupt JPEG image.)  Previously, these would cause libjpeg-turbo to\ncrash under certain circumstances.\n\n2. Fixed typo in SIMD dispatch routines that was causing 4:2:2 upsampling to\nbe used instead of 4:2:0 when decompressing JPEG images using SSE2 code.\n\n3. The configure script will now automatically determine whether the\n`INCOMPLETE_TYPES_BROKEN` macro should be defined.\n\n\n1.0.0\n=====\n\n### Significant changes relative to 0.0.93:\n\n1. 2983700: Further FreeBSD build tweaks (no longer necessary to specify\n`--host` when configuring on a 64-bit system)\n\n2. Created symlinks in the Unix/Linux packages so that the TurboJPEG\ninclude file can always be found in /opt/libjpeg-turbo/include, the 32-bit\nstatic libraries can always be found in /opt/libjpeg-turbo/lib32, and the\n64-bit static libraries can always be found in /opt/libjpeg-turbo/lib64.\n\n3. The Unix/Linux distribution packages now include the libjpeg run-time\nprograms (cjpeg, etc.) and man pages.\n\n4. Created a 32-bit supplementary package for amd64 Debian systems, which\ncontains just the 32-bit libjpeg-turbo libraries.\n\n5. Moved the libraries from */lib32 to */lib in the i386 Debian package.\n\n6. Include distribution package for Cygwin\n\n7. No longer necessary to specify `--without-simd` on non-x86 architectures,\nand unit tests now work on those architectures.\n\n\n0.0.93\n======\n\n### Significant changes relative to 0.0.91:\n\n1. 2982659: Fixed x86-64 build on FreeBSD systems\n\n2. 2988188: Added support for Windows 64-bit systems\n\n\n0.0.91\n======\n\n### Significant changes relative to 0.0.90:\n\n1. Added documentation to .deb packages\n\n2. 2968313: Fixed data corruption issues when decompressing large JPEG images\nand/or using buffered I/O with the libjpeg-turbo decompressor\n\n\n0.0.90\n======\n\nInitial release\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 5.48828125,
          "content": "libjpeg-turbo Licenses\n======================\n\nlibjpeg-turbo is covered by two compatible BSD-style open source licenses:\n\n- The IJG (Independent JPEG Group) License, which is listed in\n  [README.ijg](README.ijg)\n\n  This license applies to the libjpeg API library and associated programs,\n  including any code inherited from libjpeg and any modifications to that\n  code.  Note that the libjpeg-turbo SIMD source code bears the\n  [zlib License](https://opensource.org/licenses/Zlib), but in the context of\n  the overall libjpeg API library, the terms of the zlib License are subsumed\n  by the terms of the IJG License.\n\n- The Modified (3-clause) BSD License, which is listed below\n\n  This license applies to the TurboJPEG API library and associated programs, as\n  well as the build system.  Note that the TurboJPEG API library wraps the\n  libjpeg API library, so in the context of the overall TurboJPEG API library,\n  both the terms of the IJG License and the terms of the Modified (3-clause)\n  BSD License apply.\n\n\nComplying with the libjpeg-turbo Licenses\n=========================================\n\nThis section provides a roll-up of the libjpeg-turbo licensing terms, to the\nbest of our understanding.  This is not a license in and of itself.  It is\nintended solely for clarification.\n\n1.  If you are distributing a modified version of the libjpeg-turbo source,\n    then:\n\n    1.  You cannot alter or remove any existing copyright or license notices\n        from the source.\n\n        **Origin**\n        - Clause 1 of the IJG License\n        - Clause 1 of the Modified BSD License\n        - Clauses 1 and 3 of the zlib License\n\n    2.  You must add your own copyright notice to the header of each source\n        file you modified, so others can tell that you modified that file.  (If\n        there is not an existing copyright header in that file, then you can\n        simply add a notice stating that you modified the file.)\n\n        **Origin**\n        - Clause 1 of the IJG License\n        - Clause 2 of the zlib License\n\n    3.  You must include the IJG README file, and you must not alter any of the\n        copyright or license text in that file.\n\n        **Origin**\n        - Clause 1 of the IJG License\n\n2.  If you are distributing only libjpeg-turbo binaries without the source, or\n    if you are distributing an application that statically links with\n    libjpeg-turbo, then:\n\n    1.  Your product documentation must include a message stating:\n\n        This software is based in part on the work of the Independent JPEG\n        Group.\n\n        **Origin**\n        - Clause 2 of the IJG license\n\n    2.  If your binary distribution includes or uses the TurboJPEG API, then\n        your product documentation must include the text of the Modified BSD\n        License (see below.)\n\n        **Origin**\n        - Clause 2 of the Modified BSD License\n\n3.  You cannot use the name of the IJG or The libjpeg-turbo Project or the\n    contributors thereof in advertising, publicity, etc.\n\n    **Origin**\n    - IJG License\n    - Clause 3 of the Modified BSD License\n\n4.  The IJG and The libjpeg-turbo Project do not warrant libjpeg-turbo to be\n    free of defects, nor do we accept any liability for undesirable\n    consequences resulting from your use of the software.\n\n    **Origin**\n    - IJG License\n    - Modified BSD License\n    - zlib License\n\n\nThe Modified (3-clause) BSD License\n===================================\n\nCopyright (C)2009-2024 D. R. Commander.  All Rights Reserved.<br>\nCopyright (C)2015 Viktor Szathmry.  All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n- Neither the name of the libjpeg-turbo Project nor the names of its\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n\nWhy Two Licenses?\n=================\n\nThe zlib License could have been used instead of the Modified (3-clause) BSD\nLicense, and since the IJG License effectively subsumes the distribution\nconditions of the zlib License, this would have effectively placed\nlibjpeg-turbo binary distributions under the IJG License.  However, the IJG\nLicense specifically refers to the Independent JPEG Group and does not extend\nattribution and endorsement protections to other entities.  Thus, it was\ndesirable to choose a license that granted us the same protections for new code\nthat were granted to the IJG for code derived from their software.\n"
        },
        {
          "name": "README-mozilla.txt",
          "type": "blob",
          "size": 8.8408203125,
          "content": "Mozilla JPEG Encoder Project\n============================\n\nmozjpeg is a fork of libjpeg-turbo that aims to speed up load times of web\npages by reducing the size (and, by extension, the transmission time) of JPEG\nfiles.  It accomplishes this by enabling optimized Huffman trees and\nprogressive entropy coding by default in the JPEG compressor, as well as\nsplitting the spectrum of DCT coefficients into separate scans and using\nTrellis quantisation.\n\nAlthough it is based on libjpeg-turbo, mozjpeg is not intended to be a\ngeneral-purpose or high-performance JPEG library.  Its performance is highly\n\"asymmetric\".  That is, the JPEG files it generates require much more time to\ncompress than to decompress.  When the default settings are used, mozjpeg is\nconsiderably slower than libjpeg-turbo or even libjpeg at compressing images.\nThus, it is not generally suitable for real-time compression.  It is best used\nas part of a web encoding workflow.\n\n\nlibjpeg API Extensibility Framework\n===================================\n\nmozjpeg's implementation of the libjpeg API includes an extensibility framework\nthat allows new features to be added without modifying the transparent libjpeg\ncompress/decompress structures (which would break backward ABI compatibility.)\nExtension parameters are placed into the opaque jpeg_comp_master structure, and\na set of accessor functions and globally unique tokens allows for\ngetting/setting those parameters without directly accessing the structure.\n\nCurrently, only the accessor functions necessary to support the mozjpeg\nextensions are implemented, but the framework can be easily extended in the\nfuture to accommodate additional simple parameter types, complex or\nmulti-valued parameters, or decompressor extensions.\n\n\nThe currently-implemented accessor functions are as follows:\n\nboolean jpeg_c_bool_param_supported (j_compress_ptr cinfo,\n                                     J_BOOLEAN_PARAM param)\n        Returns TRUE if the given boolean extension parameter is supported by\n        this implementation of the libjpeg API, or FALSE otherwise.\n\nvoid jpeg_c_set_bool_param (j_compress_ptr cinfo,\n                            J_BOOLEAN_PARAM param, boolean value);\n        Set the given boolean extension parameter to the given value (TRUE or\n        FALSE.)\n\nboolean jpeg_c_get_bool_param (j_compress_ptr cinfo, J_BOOLEAN_PARAM param)\n        Get the value of the given boolean extension parameter (TRUE or FALSE.)\n\nboolean jpeg_c_float_param_supported (j_compress_ptr cinfo,\n                                      J_FLOAT_PARAM param)\n        Returns TRUE if the given floating point extension parameter is\n        supported by this implementation of the libjpeg API, or FALSE\n        otherwise.\n\nvoid jpeg_c_set_float_param (j_compress_ptr cinfo, J_FLOAT_PARAM param,\n                             float value)\n        Set the given floating point extension parameter to the given value.\n\nfloat jpeg_c_get_float_param (j_compress_ptr cinfo, J_FLOAT_PARAM param);\n        Get the value of the given floating point extension parameter.\n\nboolean jpeg_c_int_param_supported (j_compress_ptr cinfo,\n                                    J_INT_PARAM param)\n        Returns TRUE if the given integer extension parameter is supported by\n        this implementation of the libjpeg API, or FALSE otherwise.\n\nvoid jpeg_c_set_int_param (j_compress_ptr cinfo, J_INT_PARAM param,\n                          int value)\n        Set the given integer extension parameter to the given value.\n\nint jpeg_c_get_int_param (j_compress_ptr cinfo, J_INT_PARAM param)\n        Get the value of the given integer extension parameter.\n\n\nBoolean Extension Parameters Supported by mozjpeg\n-------------------------------------------------\n\n* JBOOLEAN_OPTIMIZE_SCANS (default: TRUE)\n  Specifies whether scan parameters should be optimized.  Parameter\n  optimization is done as in jpgcrush. jpeg_simple_progression() should be called\n  after setting JBOOLEAN_OPTIMIZE_SCANS.\n  When disabling JBOOLEAN_OPTIMIZE_SCANS, cinfo.scan_info should additionally be\n  set to NULL to disable use of the progressive coding mode, if so desired.\n\n* JBOOLEAN_TRELLIS_QUANT (default: TRUE)\n  Specifies whether to apply trellis quantization.  For each 8x8 block, trellis\n  quantization determines the best tradeoff between rate and distortion.\n\n* JBOOLEAN_TRELLIS_QUANT_DC (default: TRUE)\n  Specifies whether to apply trellis quantization to DC coefficients.\n\n* JBOOLEAN_TRELLIS_EOB_OPT (default: FALSE)\n  Specifies whether to optimize runs of zero blocks in trellis quantization.\n  This is applicable only when JBOOLEAN_USE_SCANS_IN_TRELLIS is enabled.\n\n* JBOOLEAN_USE_LAMBDA_WEIGHT_TBL currently has no effect.\n\n* JBOOLEAN_USE_SCANS_IN_TRELLIS (default: FALSE)\n  Specifies whether multiple scans should be considered during trellis\n  quantization.\n\n* JBOOLEAN_TRELLIS_Q_OPT (default: FALSE)\n  Specifies whether to optimize the quantization table after trellis\n  quantization.  If enabled, then a revised quantization table is derived so\n  as to minimize the reconstruction error of the quantized coefficients.\n\n* JBOOLEAN_OVERSHOOT_DERINGING (default: TRUE)\n  Specifies whether overshooting is applied to samples with extreme values\n  (for example, 0 and 255 for 8-bit samples).  Overshooting may reduce ringing\n  artifacts from compression, in particular in areas where black text appears\n  on a white background.\n\n\nFloating Point Extension Parameters Supported by mozjpeg\n--------------------------------------------------------\n\n* JFLOAT_LAMBDA_LOG_SCALE1 (default: 14.75)\n  JFLOAT_LAMBDA_LOG_SCALE2 (default: 16.5)\n  These parameters specify the lambda value used in trellis quantization.  The\n  lambda value (Lagrange multiplier) in the\n    R + lambda * D\n  equation is derived from\n    lambda = 2^s1 / ((2^s2 + n) * q^2),\n  where s1 and s2 are the values of JFLOAT_LAMBDA_LOG_SCALE1 and\n  JFLOAT_LAMBDA_LOG_SCALE2, n is the average of the squared unquantized AC\n  coefficients within the current 8x8 block, and q is the quantization table\n  entry associated with the current coefficient frequency.  If\n  JFLOAT_LAMBDA_LOG_SCALE2 is 0, then an alternate form is used that does not\n  rely on n:\n    lambda = 2^(s1-12) / q^2.\n\n* JFLOAT_TRELLIS_DELTA_DC_WEIGHT (default: 0.0)\n  This parameter controls how distortion is calculated in DC trellis quantization\n  (enabled with JBOOLEAN_TRELLIS_QUANT_DC). It defines weighting between distortion\n  of the DC coefficient and distortion of the vertical gradient of DC coefficients.\n  The value of the parameter corresponds to the weight applied to the distortion\n  of the vertical gradient.\n\n\nInteger Extension Parameters Supported by mozjpeg\n-------------------------------------------------\n\n* JINT_COMPRESS_PROFILE (default: JCP_MAX_COMPRESSION)\n  Select a compression profile, which is a set of default parameters that will\n  achieve a desired compression goal.  This parameter controls the behavior of\n  the jpeg_set_defaults() function.  Thus, setting JINT_COMPRESS_PROFILE does\n  not cause any other parameters to be modified until jpeg_set_defaults() is\n  called.  The following compression profiles are supported:\n\n  - JCP_MAX_COMPRESSION (default)\n    Increase the compression ratio as much as possible, at the expense of\n    increased encoding time.  This enables progressive entropy coding and all\n    mozjpeg extensions.\n\n  - JCP_FASTEST\n    Use the libjpeg[-turbo] defaults (baseline entropy coding, no mozjpeg\n    extensions enabled.)\n\n* JINT_TRELLIS_FREQ_SPLIT (default: 8)\n  Specifies the position within the zigzag scan at which the split between\n  scans is positioned in the context of trellis quantization.\n  JBOOLEAN_USE_SCANS_IN_TRELLIS must be enabled for this parameter to have any\n  effect.\n\n* JINT_TRELLIS_NUM_LOOPS (default: 1)\n  Specifies the number of trellis quantization passes.  Huffman tables are\n  updated between passes.\n\n* JINT_BASE_QUANT_TBL_IDX (default: 3)\n  Specifies which quantization table set to use.  The following options are\n  available:\n  0 = Tables from JPEG Annex K\n  1 = Flat table\n  2 = Table tuned for MSSIM on Kodak image set\n  3 = Table from http://www.imagemagick.org/discourse-server/viewtopic.php?f=22&t=20333&p=98008#p98008\n  4 = Table tuned for PSNR-HVS-M on Kodak image set\n  5 = Table from:  Relevance of Human Vision to JPEG-DCT Compression\n      (1992) Klein, Silverstein and Carney\n  6 = Table from:  DCTune Perceptual Optimization of Compressed Dental X-Rays\n      (1997) Watson, Taylor, Borthwick\n  7 = Table from:  A Visual Detection Model for DCT Coefficient Quantization\n      (12/9/93) Ahumada, Watson, Peterson\n  8 = Table from:  An Improved Detection Model for DCT Coefficient Quantization\n      (1993) Peterson, Ahumada and Watson\n\n* JINT_DC_SCAN_OPT_MODE (default: 0)\n  Specifies the DC scan optimization mode.  The following options are\n  available:\n  0 = One scan for all components\n  1 = One scan per component\n  2 = Optimize between one scan for all components and one scan for the first\n      component plus one scan for the remaining components\n"
        },
        {
          "name": "README-turbo.txt",
          "type": "blob",
          "size": 17.2294921875,
          "content": "Background\n==========\n\nlibjpeg-turbo is a JPEG image codec that uses SIMD instructions to accelerate\nbaseline JPEG compression and decompression on x86, x86-64, Arm, PowerPC, and\nMIPS systems, as well as progressive JPEG compression on x86, x86-64, and Arm\nsystems.  On such systems, libjpeg-turbo is generally 2-6x as fast as libjpeg,\nall else being equal.  On other types of systems, libjpeg-turbo can still\noutperform libjpeg by a significant amount, by virtue of its highly-optimized\nHuffman coding routines.  In many cases, the performance of libjpeg-turbo\nrivals that of proprietary high-speed JPEG codecs.\n\nlibjpeg-turbo implements both the traditional libjpeg API as well as the less\npowerful but more straightforward TurboJPEG API.  libjpeg-turbo also features\ncolorspace extensions that allow it to compress from/decompress to 32-bit and\nbig-endian pixel buffers (RGBX, XBGR, etc.), as well as a full-featured Java\ninterface.\n\nlibjpeg-turbo was originally based on libjpeg/SIMD, an MMX-accelerated\nderivative of libjpeg v6b developed by Miyasaka Masaru.  The TigerVNC and\nVirtualGL projects made numerous enhancements to the codec in 2009, and in\nearly 2010, libjpeg-turbo spun off into an independent project, with the goal\nof making high-speed JPEG compression/decompression technology available to a\nbroader range of users and developers.  libjpeg-turbo is an ISO/IEC and ITU-T\nreference implementation of the JPEG standard.\n\nMore information about libjpeg-turbo can be found at\n<https://libjpeg-turbo.org>.\n\n\nFunding\n=======\n\nlibjpeg-turbo is an independent open source project, but we rely on patronage\nand funded development in order to maintain that independence.  The easiest way\nto ensure that libjpeg-turbo remains community-focused and free of any one\norganization's agenda is to\n[sponsor our project through GitHub](https://github.com/sponsors/libjpeg-turbo).\nAll sponsorship money goes directly toward funding the labor necessary to\nmaintain libjpeg-turbo, support the user community, and implement bug fixes and\nstrategically important features.\n\n[![Sponsor libjpeg-turbo](https://img.shields.io/github/sponsors/libjpeg-turbo?label=Sponsor&logo=GitHub)](https://github.com/sponsors/libjpeg-turbo)\n\n\nLicense\n=======\n\nlibjpeg-turbo is covered by three compatible BSD-style open source licenses.\nRefer to [LICENSE.md](LICENSE.md) for a roll-up of license terms.\n\n\nBuilding libjpeg-turbo\n======================\n\nRefer to [BUILDING.md](BUILDING.md) for complete instructions.\n\n\nUsing libjpeg-turbo\n===================\n\nlibjpeg-turbo includes two APIs that can be used to compress and decompress\nJPEG images:\n\n- **TurboJPEG API**<br>\n  This API provides an easy-to-use interface for compressing and decompressing\n  JPEG images in memory.  It also provides some functionality that would not be\n  straightforward to achieve using the underlying libjpeg API, such as\n  generating planar YUV images and performing multiple simultaneous lossless\n  transforms on an image.  The Java interface for libjpeg-turbo is written on\n  top of the TurboJPEG API.  The TurboJPEG API is recommended for first-time\n  users of libjpeg-turbo.  Refer to [tjexample.c](tjexample.c) and\n  [TJExample.java](java/TJExample.java) for examples of its usage and to\n  <https://libjpeg-turbo.org/Documentation/Documentation> for API\n  documentation.\n\n- **libjpeg API**<br>\n  This is the de facto industry-standard API for compressing and decompressing\n  JPEG images.  It is more difficult to use than the TurboJPEG API but also\n  more powerful.  The libjpeg API implementation in libjpeg-turbo is both\n  API/ABI-compatible and mathematically compatible with libjpeg v6b.  It can\n  also optionally be configured to be API/ABI-compatible with libjpeg v7 and v8\n  (see below.)  Refer to [cjpeg.c](cjpeg.c) and [djpeg.c](djpeg.c) for examples\n  of its usage and to [libjpeg.txt](libjpeg.txt) for API documentation.\n\nThere is no significant performance advantage to either API when both are used\nto perform similar operations.\n\nColorspace Extensions\n---------------------\n\nlibjpeg-turbo includes extensions that allow JPEG images to be compressed\ndirectly from (and decompressed directly to) buffers that use BGR, BGRX,\nRGBX, XBGR, and XRGB pixel ordering.  This is implemented with ten new\ncolorspace constants:\n\n    JCS_EXT_RGB   /* red/green/blue */\n    JCS_EXT_RGBX  /* red/green/blue/x */\n    JCS_EXT_BGR   /* blue/green/red */\n    JCS_EXT_BGRX  /* blue/green/red/x */\n    JCS_EXT_XBGR  /* x/blue/green/red */\n    JCS_EXT_XRGB  /* x/red/green/blue */\n    JCS_EXT_RGBA  /* red/green/blue/alpha */\n    JCS_EXT_BGRA  /* blue/green/red/alpha */\n    JCS_EXT_ABGR  /* alpha/blue/green/red */\n    JCS_EXT_ARGB  /* alpha/red/green/blue */\n\nSetting `cinfo.in_color_space` (compression) or `cinfo.out_color_space`\n(decompression) to one of these values will cause libjpeg-turbo to read the\nred, green, and blue values from (or write them to) the appropriate position in\nthe pixel when compressing from/decompressing to an RGB buffer.\n\nYour application can check for the existence of these extensions at compile\ntime with:\n\n    #ifdef JCS_EXTENSIONS\n\nAt run time, attempting to use these extensions with a libjpeg implementation\nthat does not support them will result in a \"Bogus input colorspace\" error.\nApplications can trap this error in order to test whether run-time support is\navailable for the colorspace extensions.\n\nWhen using the RGBX, BGRX, XBGR, and XRGB colorspaces during decompression, the\nX byte is undefined, and in order to ensure the best performance, libjpeg-turbo\ncan set that byte to whatever value it wishes.  If an application expects the X\nbyte to be used as an alpha channel, then it should specify `JCS_EXT_RGBA`,\n`JCS_EXT_BGRA`, `JCS_EXT_ABGR`, or `JCS_EXT_ARGB`.  When these colorspace\nconstants are used, the X byte is guaranteed to be 0xFF, which is interpreted\nas opaque.\n\nYour application can check for the existence of the alpha channel colorspace\nextensions at compile time with:\n\n    #ifdef JCS_ALPHA_EXTENSIONS\n\n[jcstest.c](jcstest.c), located in the libjpeg-turbo source tree, demonstrates\nhow to check for the existence of the colorspace extensions at compile time and\nrun time.\n\nlibjpeg v7 and v8 API/ABI Emulation\n-----------------------------------\n\nWith libjpeg v7 and v8, new features were added that necessitated extending the\ncompression and decompression structures.  Unfortunately, due to the exposed\nnature of those structures, extending them also necessitated breaking backward\nABI compatibility with previous libjpeg releases.  Thus, programs that were\nbuilt to use libjpeg v7 or v8 did not work with libjpeg-turbo, since it is\nbased on the libjpeg v6b code base.  Although libjpeg v7 and v8 are not\nas widely used as v6b, enough programs (including a few Linux distros) made\nthe switch that there was a demand to emulate the libjpeg v7 and v8 ABIs\nin libjpeg-turbo.  It should be noted, however, that this feature was added\nprimarily so that applications that had already been compiled to use libjpeg\nv7+ could take advantage of accelerated baseline JPEG encoding/decoding\nwithout recompiling.  libjpeg-turbo does not claim to support all of the\nlibjpeg v7+ features, nor to produce identical output to libjpeg v7+ in all\ncases (see below.)\n\nBy passing an argument of `-DWITH_JPEG7=1` or `-DWITH_JPEG8=1` to `cmake`, you\ncan build a version of libjpeg-turbo that emulates the libjpeg v7 or v8 ABI, so\nthat programs that are built against libjpeg v7 or v8 can be run with\nlibjpeg-turbo.  The following section describes which libjpeg v7+ features are\nsupported and which aren't.\n\n### Support for libjpeg v7 and v8 Features\n\n#### Fully supported\n\n- **libjpeg API: IDCT scaling extensions in decompressor**<br>\n  libjpeg-turbo supports IDCT scaling with scaling factors of 1/8, 1/4, 3/8,\n  1/2, 5/8, 3/4, 7/8, 9/8, 5/4, 11/8, 3/2, 13/8, 7/4, 15/8, and 2/1 (only 1/4\n  and 1/2 are SIMD-accelerated.)\n\n- **libjpeg API: Arithmetic coding**\n\n- **libjpeg API: In-memory source and destination managers**<br>\n  See notes below.\n\n- **cjpeg: Separate quality settings for luminance and chrominance**<br>\n  Note that the libpjeg v7+ API was extended to accommodate this feature only\n  for convenience purposes.  It has always been possible to implement this\n  feature with libjpeg v6b (see rdswitch.c for an example.)\n\n- **cjpeg: 32-bit BMP support**\n\n- **cjpeg: `-rgb` option**\n\n- **jpegtran: Lossless cropping**\n\n- **jpegtran: `-perfect` option**\n\n- **jpegtran: Forcing width/height when performing lossless crop**\n\n- **rdjpgcom: `-raw` option**\n\n- **rdjpgcom: Locale awareness**\n\n\n#### Not supported\n\nNOTE:  As of this writing, extensive research has been conducted into the\nusefulness of DCT scaling as a means of data reduction and SmartScale as a\nmeans of quality improvement.  Readers are invited to peruse the research at\n<https://libjpeg-turbo.org/About/SmartScale> and draw their own conclusions,\nbut it is the general belief of our project that these features have not\ndemonstrated sufficient usefulness to justify inclusion in libjpeg-turbo.\n\n- **libjpeg API: DCT scaling in compressor**<br>\n  `cinfo.scale_num` and `cinfo.scale_denom` are silently ignored.\n  There is no technical reason why DCT scaling could not be supported when\n  emulating the libjpeg v7+ API/ABI, but without the SmartScale extension (see\n  below), only scaling factors of 1/2, 8/15, 4/7, 8/13, 2/3, 8/11, 4/5, and\n  8/9 would be available, which is of limited usefulness.\n\n- **libjpeg API: SmartScale**<br>\n  `cinfo.block_size` is silently ignored.\n  SmartScale is an extension to the JPEG format that allows for DCT block\n  sizes other than 8x8.  Providing support for this new format would be\n  feasible (particularly without full acceleration.)  However, until/unless\n  the format becomes either an official industry standard or, at minimum, an\n  accepted solution in the community, we are hesitant to implement it, as\n  there is no sense of whether or how it might change in the future.  It is\n  our belief that SmartScale has not demonstrated sufficient usefulness as a\n  lossless format nor as a means of quality enhancement, and thus our primary\n  interest in providing this feature would be as a means of supporting\n  additional DCT scaling factors.\n\n- **libjpeg API: Fancy downsampling in compressor**<br>\n  `cinfo.do_fancy_downsampling` is silently ignored.\n  This requires the DCT scaling feature, which is not supported.\n\n- **jpegtran: Scaling**<br>\n  This requires both the DCT scaling and SmartScale features, which are not\n  supported.\n\n- **Lossless RGB JPEG files**<br>\n  This requires the SmartScale feature, which is not supported.\n\n### What About libjpeg v9?\n\nlibjpeg v9 introduced yet another field to the JPEG compression structure\n(`color_transform`), thus making the ABI backward incompatible with that of\nlibjpeg v8.  This new field was introduced solely for the purpose of supporting\nlossless SmartScale encoding.  Furthermore, there was actually no reason to\nextend the API in this manner, as the color transform could have just as easily\nbeen activated by way of a new JPEG colorspace constant, thus preserving\nbackward ABI compatibility.\n\nOur research (see link above) has shown that lossless SmartScale does not\ngenerally accomplish anything that can't already be accomplished better with\nexisting, standard lossless formats.  Therefore, at this time it is our belief\nthat there is not sufficient technical justification for software projects to\nupgrade from libjpeg v8 to libjpeg v9, and thus there is not sufficient\ntechnical justification for us to emulate the libjpeg v9 ABI.\n\nIn-Memory Source/Destination Managers\n-------------------------------------\n\nBy default, libjpeg-turbo 1.3 and later includes the `jpeg_mem_src()` and\n`jpeg_mem_dest()` functions, even when not emulating the libjpeg v8 API/ABI.\nPreviously, it was necessary to build libjpeg-turbo from source with libjpeg v8\nAPI/ABI emulation in order to use the in-memory source/destination managers,\nbut several projects requested that those functions be included when emulating\nthe libjpeg v6b API/ABI as well.  This allows the use of those functions by\nprograms that need them, without breaking ABI compatibility for programs that\ndon't, and it allows those functions to be provided in the \"official\"\nlibjpeg-turbo binaries.\n\nNote that, on most Un*x systems, the dynamic linker will not look for a\nfunction in a library until that function is actually used.  Thus, if a program\nis built against libjpeg-turbo 1.3+ and uses `jpeg_mem_src()` or\n`jpeg_mem_dest()`, that program will not fail if run against an older version\nof libjpeg-turbo or against libjpeg v7- until the program actually tries to\ncall `jpeg_mem_src()` or `jpeg_mem_dest()`.  Such is not the case on Windows.\nIf a program is built against the libjpeg-turbo 1.3+ DLL and uses\n`jpeg_mem_src()` or `jpeg_mem_dest()`, then it must use the libjpeg-turbo 1.3+\nDLL at run time.\n\nBoth cjpeg and djpeg have been extended to allow testing the in-memory\nsource/destination manager functions.  See their respective man pages for more\ndetails.\n\n\nMathematical Compatibility\n==========================\n\nFor the most part, libjpeg-turbo should produce identical output to libjpeg\nv6b.  There are two exceptions:\n\n1. When decompressing a JPEG image that uses 4:4:0 chrominance subsampling, the\noutputs of libjpeg v6b and libjpeg-turbo can differ because libjpeg-turbo\nimplements a \"fancy\" (smooth) 4:4:0 upsampling algorithm and libjpeg did not.\n\n2. When using the floating point DCT/IDCT, the outputs of libjpeg v6b and\nlibjpeg-turbo can differ for the following reasons:\n\n    - The SSE/SSE2 floating point DCT implementation in libjpeg-turbo is ever\n      so slightly more accurate than the implementation in libjpeg v6b, but not\n      by any amount perceptible to human vision (generally in the range of 0.01\n      to 0.08 dB gain in PNSR.)\n\n    - When not using the SIMD extensions, libjpeg-turbo uses the more accurate\n      (and slightly faster) floating point IDCT algorithm introduced in libjpeg\n      v8a as opposed to the algorithm used in libjpeg v6b.  It should be noted,\n      however, that this algorithm basically brings the accuracy of the\n      floating point IDCT in line with the accuracy of the accurate integer\n      IDCT.  The floating point DCT/IDCT algorithms are mainly a legacy\n      feature, and they do not produce significantly more accuracy than the\n      accurate integer algorithms.  (To put numbers on this, the typical\n      difference in PNSR between the two algorithms is less than 0.10 dB,\n      whereas changing the quality level by 1 in the upper range of the quality\n      scale is typically more like a 1.0 dB difference.)\n\n    - If the floating point algorithms in libjpeg-turbo are not implemented\n      using SIMD instructions on a particular platform, then the accuracy of\n      the floating point DCT/IDCT can depend on the compiler settings.\n\nWhile libjpeg-turbo does emulate the libjpeg v8 API/ABI, under the hood it is\nstill using the same algorithms as libjpeg v6b, so there are several specific\ncases in which libjpeg-turbo cannot be expected to produce the same output as\nlibjpeg v8:\n\n- When decompressing using scaling factors of 1/2 and 1/4, because libjpeg v8\n  implements those scaling algorithms differently than libjpeg v6b does, and\n  libjpeg-turbo's SIMD extensions are based on the libjpeg v6b behavior.\n\n- When using chrominance subsampling, because libjpeg v8 implements this\n  with its DCT/IDCT scaling algorithms rather than with a separate\n  downsampling/upsampling algorithm.  In our testing, the subsampled/upsampled\n  output of libjpeg v8 is less accurate than that of libjpeg v6b for this\n  reason.\n\n- When decompressing using a scaling factor > 1 and merged (AKA \"non-fancy\" or\n  \"non-smooth\") chrominance upsampling, because libjpeg v8 does not support\n  merged upsampling with scaling factors > 1.\n\n\nPerformance Pitfalls\n====================\n\nRestart Markers\n---------------\n\nThe optimized Huffman decoder in libjpeg-turbo does not handle restart markers\nin a way that makes the rest of the libjpeg infrastructure happy, so it is\nnecessary to use the slow Huffman decoder when decompressing a JPEG image that\nhas restart markers.  This can cause the decompression performance to drop by\nas much as 20%, but the performance will still be much greater than that of\nlibjpeg.  Many consumer packages, such as Photoshop, use restart markers when\ngenerating JPEG images, so images generated by those programs will experience\nthis issue.\n\nFast Integer Forward DCT at High Quality Levels\n-----------------------------------------------\n\nThe algorithm used by the SIMD-accelerated quantization function cannot produce\ncorrect results whenever the fast integer forward DCT is used along with a JPEG\nquality of 98-100.  Thus, libjpeg-turbo must use the non-SIMD quantization\nfunction in those cases.  This causes performance to drop by as much as 40%.\nIt is therefore strongly advised that you use the accurate integer forward DCT\nwhenever encoding images with a JPEG quality of 98 or higher.\n\n\nMemory Debugger Pitfalls\n========================\n\nValgrind and Memory Sanitizer (MSan) can generate false positives\n(specifically, incorrect reports of uninitialized memory accesses) when used\nwith libjpeg-turbo's SIMD extensions.  It is generally recommended that the\nSIMD extensions be disabled, either by passing an argument of `-DWITH_SIMD=0`\nto `cmake` when configuring the build or by setting the environment variable\n`JSIMD_FORCENONE` to `1` at run time, when testing libjpeg-turbo with Valgrind,\nMSan, or other memory debuggers.\n"
        },
        {
          "name": "README.ijg",
          "type": "blob",
          "size": 12.4169921875,
          "content": "libjpeg-turbo note:  This file has been modified by The libjpeg-turbo Project\nto include only information relevant to libjpeg-turbo, to wordsmith certain\nsections, and to remove impolitic language that existed in the libjpeg v8\nREADME.  It is included only for reference.  Please see README.md for\ninformation specific to libjpeg-turbo.\n\n\nThe Independent JPEG Group's JPEG software\n==========================================\n\nThis distribution contains a release of the Independent JPEG Group's free JPEG\nsoftware.  You are welcome to redistribute this software and to use it for any\npurpose, subject to the conditions under LEGAL ISSUES, below.\n\nThis software is the work of Tom Lane, Guido Vollbeding, Philip Gladstone,\nBill Allombert, Jim Boucher, Lee Crocker, Bob Friesenhahn, Ben Jackson,\nJulian Minguillon, Luis Ortiz, George Phillips, Davide Rossi, Ge' Weijers,\nand other members of the Independent JPEG Group.\n\nIJG is not affiliated with the ISO/IEC JTC1/SC29/WG1 standards committee\n(also known as JPEG, together with ITU-T SG16).\n\n\nDOCUMENTATION ROADMAP\n=====================\n\nThis file contains the following sections:\n\nOVERVIEW            General description of JPEG and the IJG software.\nLEGAL ISSUES        Copyright, lack of warranty, terms of distribution.\nREFERENCES          Where to learn more about JPEG.\nARCHIVE LOCATIONS   Where to find newer versions of this software.\nFILE FORMAT WARS    Software *not* to get.\nTO DO               Plans for future IJG releases.\n\nOther documentation files in the distribution are:\n\nUser documentation:\n  usage.txt         Usage instructions for cjpeg, djpeg, jpegtran,\n                    rdjpgcom, and wrjpgcom.\n  *.1               Unix-style man pages for programs (same info as usage.txt).\n  wizard.txt        Advanced usage instructions for JPEG wizards only.\n  change.log        Version-to-version change highlights.\nProgrammer and internal documentation:\n  libjpeg.txt       How to use the JPEG library in your own programs.\n  example.c         Sample code for calling the JPEG library.\n  structure.txt     Overview of the JPEG library's internal structure.\n  coderules.txt     Coding style rules --- please read if you contribute code.\n\nPlease read at least usage.txt.  Some information can also be found in the JPEG\nFAQ (Frequently Asked Questions) article.  See ARCHIVE LOCATIONS below to find\nout where to obtain the FAQ article.\n\nIf you want to understand how the JPEG code works, we suggest reading one or\nmore of the REFERENCES, then looking at the documentation files (in roughly\nthe order listed) before diving into the code.\n\n\nOVERVIEW\n========\n\nThis package contains C software to implement JPEG image encoding, decoding,\nand transcoding.  JPEG (pronounced \"jay-peg\") is a standardized compression\nmethod for full-color and grayscale images.  JPEG's strong suit is compressing\nphotographic images or other types of images that have smooth color and\nbrightness transitions between neighboring pixels.  Images with sharp lines or\nother abrupt features may not compress well with JPEG, and a higher JPEG\nquality may have to be used to avoid visible compression artifacts with such\nimages.\n\nJPEG is normally lossy, meaning that the output pixels are not necessarily\nidentical to the input pixels.  However, on photographic content and other\n\"smooth\" images, very good compression ratios can be obtained with no visible\ncompression artifacts, and extremely high compression ratios are possible if\nyou are willing to sacrifice image quality (by reducing the \"quality\" setting\nin the compressor.)\n\nThis software implements JPEG baseline, extended-sequential, progressive, and\nlossless compression processes.  Provision is made for supporting all variants\nof these processes, although some uncommon parameter settings aren't\nimplemented yet.  We have made no provision for supporting the hierarchical\nprocesses defined in the standard.\n\nWe provide a set of library routines for reading and writing JPEG image files,\nplus two sample applications \"cjpeg\" and \"djpeg\", which use the library to\nperform conversion between JPEG and some other popular image file formats.\nThe library is intended to be reused in other applications.\n\nIn order to support file conversion and viewing software, we have included\nconsiderable functionality beyond the bare JPEG coding/decoding capability;\nfor example, the color quantization modules are not strictly part of JPEG\ndecoding, but they are essential for output to colormapped file formats.  These\nextra functions can be compiled out of the library if not required for a\nparticular application.\n\nWe have also included \"jpegtran\", a utility for lossless transcoding between\ndifferent JPEG processes, and \"rdjpgcom\" and \"wrjpgcom\", two simple\napplications for inserting and extracting textual comments in JFIF files.\n\nThe emphasis in designing this software has been on achieving portability and\nflexibility, while also making it fast enough to be useful.  In particular,\nthe software is not intended to be read as a tutorial on JPEG.  (See the\nREFERENCES section for introductory material.)  Rather, it is intended to\nbe reliable, portable, industrial-strength code.  We do not claim to have\nachieved that goal in every aspect of the software, but we strive for it.\n\nWe welcome the use of this software as a component of commercial products.\nNo royalty is required, but we do ask for an acknowledgement in product\ndocumentation, as described under LEGAL ISSUES.\n\n\nLEGAL ISSUES\n============\n\nIn plain English:\n\n1. We don't promise that this software works.  (But if you find any bugs,\n   please let us know!)\n2. You can use this software for whatever you want.  You don't have to pay us.\n3. You may not pretend that you wrote this software.  If you use it in a\n   program, you must acknowledge somewhere in your documentation that\n   you've used the IJG code.\n\nIn legalese:\n\nThe authors make NO WARRANTY or representation, either express or implied,\nwith respect to this software, its quality, accuracy, merchantability, or\nfitness for a particular purpose.  This software is provided \"AS IS\", and you,\nits user, assume the entire risk as to its quality and accuracy.\n\nThis software is copyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.\nAll Rights Reserved except as specified below.\n\nPermission is hereby granted to use, copy, modify, and distribute this\nsoftware (or portions thereof) for any purpose, without fee, subject to these\nconditions:\n(1) If any part of the source code for this software is distributed, then this\nREADME file must be included, with this copyright and no-warranty notice\nunaltered; and any additions, deletions, or changes to the original files\nmust be clearly indicated in accompanying documentation.\n(2) If only executable code is distributed, then the accompanying\ndocumentation must state that \"this software is based in part on the work of\nthe Independent JPEG Group\".\n(3) Permission for use of this software is granted only if the user accepts\nfull responsibility for any undesirable consequences; the authors accept\nNO LIABILITY for damages of any kind.\n\nThese conditions apply to any software derived from or based on the IJG code,\nnot just to the unmodified library.  If you use our work, you ought to\nacknowledge us.\n\nPermission is NOT granted for the use of any IJG author's name or company name\nin advertising or publicity relating to this software or products derived from\nit.  This software may be referred to only as \"the Independent JPEG Group's\nsoftware\".\n\nWe specifically permit and encourage the use of this software as the basis of\ncommercial products, provided that all warranty or liability claims are\nassumed by the product vendor.\n\n\nREFERENCES\n==========\n\nWe recommend reading one or more of these references before trying to\nunderstand the innards of the JPEG software.\n\nThe best short technical introduction to the JPEG compression algorithm is\n        Wallace, Gregory K.  \"The JPEG Still Picture Compression Standard\",\n        Communications of the ACM, April 1991 (vol. 34 no. 4), pp. 30-44.\n(Adjacent articles in that issue discuss MPEG motion picture compression,\napplications of JPEG, and related topics.)  If you don't have the CACM issue\nhandy, a PDF file containing a revised version of Wallace's article is\navailable at http://www.ijg.org/files/Wallace.JPEG.pdf.  The file (actually\na preprint for an article that appeared in IEEE Trans. Consumer Electronics)\nomits the sample images that appeared in CACM, but it includes corrections\nand some added material.  Note: the Wallace article is copyright ACM and IEEE,\nand it may not be used for commercial purposes.\n\nA somewhat less technical, more leisurely introduction to JPEG can be found in\n\"The Data Compression Book\" by Mark Nelson and Jean-loup Gailly, published by\nM&T Books (New York), 2nd ed. 1996, ISBN 1-55851-434-1.  This book provides\ngood explanations and example C code for a multitude of compression methods\nincluding JPEG.  It is an excellent source if you are comfortable reading C\ncode but don't know much about data compression in general.  The book's JPEG\nsample code is far from industrial-strength, but when you are ready to look\nat a full implementation, you've got one here...\n\nThe best currently available description of JPEG is the textbook \"JPEG Still\nImage Data Compression Standard\" by William B. Pennebaker and Joan L.\nMitchell, published by Van Nostrand Reinhold, 1993, ISBN 0-442-01272-1.\nPrice US$59.95, 638 pp.  The book includes the complete text of the ISO JPEG\nstandards (DIS 10918-1 and draft DIS 10918-2).\n\nThe original JPEG standard is divided into two parts, Part 1 being the actual\nspecification, while Part 2 covers compliance testing methods.  Part 1 is\ntitled \"Digital Compression and Coding of Continuous-tone Still Images,\nPart 1: Requirements and guidelines\" and has document numbers ISO/IEC IS\n10918-1, ITU-T T.81.  Part 2 is titled \"Digital Compression and Coding of\nContinuous-tone Still Images, Part 2: Compliance testing\" and has document\nnumbers ISO/IEC IS 10918-2, ITU-T T.83.\n\nThe JPEG standard does not specify all details of an interchangeable file\nformat.  For the omitted details, we follow the \"JFIF\" conventions, revision\n1.02.  JFIF version 1 has been adopted as ISO/IEC 10918-5 (05/2013) and\nRecommendation ITU-T T.871 (05/2011): Information technology - Digital\ncompression and coding of continuous-tone still images: JPEG File Interchange\nFormat (JFIF).  It is available as a free download in PDF file format from\nhttps://www.iso.org/standard/54989.html and http://www.itu.int/rec/T-REC-T.871.\nA PDF file of the older JFIF 1.02 specification is available at\nhttp://www.w3.org/Graphics/JPEG/jfif3.pdf.\n\nThe TIFF 6.0 file format specification can be obtained from\nhttp://mirrors.ctan.org/graphics/tiff/TIFF6.ps.gz.  The JPEG incorporation\nscheme found in the TIFF 6.0 spec of 3-June-92 has a number of serious\nproblems.  IJG does not recommend use of the TIFF 6.0 design (TIFF Compression\ntag 6).  Instead, we recommend the JPEG design proposed by TIFF Technical Note\n#2 (Compression tag 7).  Copies of this Note can be obtained from\nhttp://www.ijg.org/files/.  It is expected that the next revision\nof the TIFF spec will replace the 6.0 JPEG design with the Note's design.\nAlthough IJG's own code does not support TIFF/JPEG, the free libtiff library\nuses our library to implement TIFF/JPEG per the Note.\n\n\nARCHIVE LOCATIONS\n=================\n\nThe \"official\" archive site for this software is www.ijg.org.\nThe most recent released version can always be found there in\ndirectory \"files\".\n\nThe JPEG FAQ (Frequently Asked Questions) article is a source of some\ngeneral information about JPEG.  It is available at\nhttp://www.faqs.org/faqs/jpeg-faq.\n\n\nFILE FORMAT COMPATIBILITY\n=========================\n\nThis software implements ITU T.81 | ISO/IEC 10918 with some extensions from\nITU T.871 | ISO/IEC 10918-5 (JPEG File Interchange Format-- see REFERENCES).\nInformally, the term \"JPEG image\" or \"JPEG file\" most often refers to JFIF or\na subset thereof, but there are other formats containing the name \"JPEG\" that\nare incompatible with the original JPEG standard or with JFIF (for instance,\nJPEG 2000 and JPEG XR).  This software therefore does not support these\nformats.  Indeed, one of the original reasons for developing this free software\nwas to help force convergence on a common, interoperable format standard for\nJPEG files.\n\nJFIF is a minimal or \"low end\" representation.  TIFF/JPEG (TIFF revision 6.0 as\nmodified by TIFF Technical Note #2) can be used for \"high end\" applications\nthat need to record a lot of additional data about an image.\n\n\nTO DO\n=====\n\nPlease send bug reports, offers of help, etc. to jpeg-info@jpegclub.org.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.4521484375,
          "content": "Mozilla JPEG Encoder Project [![Build Status](https://ci.appveyor.com/api/projects/status/github/mozilla/mozjpeg?branch=master&svg=true)](https://ci.appveyor.com/project/kornel/mozjpeg-4ekrx)\n============================\n\nMozJPEG improves JPEG compression efficiency achieving higher visual quality and smaller file sizes at the same time. It is compatible with the JPEG standard, and the vast majority of the world's deployed JPEG decoders.\n\nMozJPEG is a patch for [libjpeg-turbo](https://github.com/libjpeg-turbo/libjpeg-turbo). **Please send pull requests to libjpeg-turbo** if the changes aren't specific to newly-added MozJPEG-only compression code. This project aims to keep differences with libjpeg-turbo minimal, so whenever possible, improvements and bug fixes should go there first.\n\nMozJPEG is compatible with the libjpeg API and ABI. It is intended to be a drop-in replacement for libjpeg. MozJPEG is a strict superset of libjpeg-turbo's functionality. All MozJPEG's improvements can be disabled at run time, and in that case it behaves exactly like libjpeg-turbo.\n\nMozJPEG is meant to be used as a library in graphics programs and image processing tools. We include a demo `cjpeg` command-line tool, but it's not intended for serious use. We encourage authors of graphics programs to use libjpeg's [C API](libjpeg.txt) and link with MozJPEG library instead.\n\n## Features\n\n* Progressive encoding with \"jpegrescan\" optimization. It can be applied to any JPEG file (with `jpegtran`) to losslessly reduce file size.\n* Trellis quantization. When converting other formats to JPEG it maximizes quality/filesize ratio.\n* Comes with new quantization table presets, e.g. tuned for high-resolution displays.\n* Fully compatible with all web browsers.\n* Can be seamlessly integrated into any program that uses the industry-standard libjpeg API. There's no need to write any MozJPEG-specific integration code.\n\n## Releases\n\n* [Latest release](https://github.com/mozilla/mozjpeg/releases/latest)\n* [Overview of 3.0 features](https://calendar.perfplanet.com/2014/mozjpeg-3-0/)\n* [Version 2.0 Announcement](https://blog.mozilla.org/research/2014/07/15/mozilla-advances-jpeg-encoding-with-mozjpeg-2-0/)\n* [Version 1.0 Announcement](https://blog.mozilla.org/research/2014/03/05/introducing-the-mozjpeg-project/)\n\n## Compiling\n\nSee [BUILDING](BUILDING.md). MozJPEG is built exactly the same way as libjpeg-turbo, so if you need additional help please consult [libjpeg-turbo documentation](https://libjpeg-turbo.org/).\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 1.6171875,
          "content": "image: Visual Studio 2019\nconfiguration: Release\nplatform:\n  - Win32\n  - x64\n\ninstall:\n  - if %PLATFORM% == Win32 (set ARCH=x86)\n  - if %PLATFORM% == x64 (set ARCH=x64)\n  ## Set up nasm\n  - choco install nasm\n  - set PATH=%PATH%;C:\\Program Files\\NASM\n  ## Set up libpng\n  - cd C:\\Tools\\vcpkg\n  - vcpkg install libpng:%ARCH%-windows\n  - vcpkg install libpng:%ARCH%-windows-static\n\nbefore_build:\n  - cd %APPVEYOR_BUILD_FOLDER%\n  - nasm -v\n  - cmake --version\n  - git describe --always --tags --dirty\n  - FOR /F %%a in ('git describe --always --tags --dirty') do set GIT_VERSION=%%a\n\nbuild_script:\n  ## Build shared\n  - cmake -B shared -A %PLATFORM%\n          -DENABLE_SHARED=1 -DENABLE_STATIC=0\n          -DREQUIRE_SIMD=1\n          -DCMAKE_TOOLCHAIN_FILE=C:/tools/vcpkg/scripts/buildsystems/vcpkg.cmake\n\n  - cmake --build shared --config Release\n\n  ## Build static\n  - cmake -B static -A %PLATFORM%\n          -DENABLE_SHARED=0 -DENABLE_STATIC=1\n          -DREQUIRE_SIMD=1\n          -DCMAKE_TOOLCHAIN_FILE=C:/tools/vcpkg/scripts/buildsystems/vcpkg.cmake\n          -DVCPKG_TARGET_TRIPLET=%ARCH%-windows-static\n\n  - cmake --build static --config Release\n\nafter_build:\n  - 7z a mozjpeg-%GIT_VERSION%-win-%ARCH%.zip shared/Release static/Release\n\nartifacts:\n  - path: '*.zip'\n\ncache:\n  - C:\\ProgramData\\chocolatey\\bin\n  - C:\\ProgramData\\chocolatey\\lib\n  - C:\\Program Files\\NASM\n  - C:\\tools\\vcpkg\\installed\n\ndeploy:\n  description: 'Automated build using Appveyor'\n  provider: GitHub\n  auth_token:\n    secure: 2Jj47Q5HnaPob9U4yX2t4q4TYTw4JWU6cS56mM12aoRLgfYkZ4gRZPySIzfmTPqC\n  artifact: /.*\\.zip/\n  on:\n    APPVEYOR_REPO_TAG: true        # deploy on tag push only\n"
        },
        {
          "name": "cderror.h",
          "type": "blob",
          "size": 4.7392578125,
          "content": "/*\n * cderror.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * Modified 2009-2017 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2021, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file defines the error and message codes for the cjpeg/djpeg\n * applications.  These strings are not needed as part of the JPEG library\n * proper.\n * Edit this file to add new codes, or to translate the message strings to\n * some other language.\n */\n\n/*\n * To define the enum list of message codes, include this file without\n * defining macro JMESSAGE.  To create a message string table, include it\n * again with a suitable JMESSAGE definition (see jerror.c for an example).\n */\n#ifndef JMESSAGE\n#ifndef CDERROR_H\n#define CDERROR_H\n/* First time through, define the enum list */\n#define JMAKE_ENUM_LIST\n#else\n/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */\n#define JMESSAGE(code, string)\n#endif /* CDERROR_H */\n#endif /* JMESSAGE */\n\n#ifdef JMAKE_ENUM_LIST\n\ntypedef enum {\n\n#define JMESSAGE(code, string)  code,\n\n#endif /* JMAKE_ENUM_LIST */\n\nJMESSAGE(JMSG_FIRSTADDONCODE = 1000, NULL) /* Must be first entry! */\n\nJMESSAGE(JERR_BMP_BADCMAP, \"Unsupported BMP colormap format\")\nJMESSAGE(JERR_BMP_BADDEPTH, \"Only 8-, 24-, and 32-bit BMP files are supported\")\nJMESSAGE(JERR_BMP_BADHEADER, \"Invalid BMP file: bad header length\")\nJMESSAGE(JERR_BMP_BADPLANES, \"Invalid BMP file: biPlanes not equal to 1\")\nJMESSAGE(JERR_BMP_COLORSPACE, \"BMP output must be grayscale or RGB\")\nJMESSAGE(JERR_BMP_COMPRESSED, \"Sorry, compressed BMPs not yet supported\")\nJMESSAGE(JERR_BMP_EMPTY, \"Empty BMP image\")\nJMESSAGE(JERR_BMP_NOT, \"Not a BMP file - does not start with BM\")\nJMESSAGE(JERR_BMP_OUTOFRANGE, \"Numeric value out of range in BMP file\")\nJMESSAGE(JTRC_BMP, \"%ux%u %d-bit BMP image\")\nJMESSAGE(JTRC_BMP_MAPPED, \"%ux%u 8-bit colormapped BMP image\")\nJMESSAGE(JTRC_BMP_OS2, \"%ux%u %d-bit OS2 BMP image\")\nJMESSAGE(JTRC_BMP_OS2_MAPPED, \"%ux%u 8-bit colormapped OS2 BMP image\")\n\nJMESSAGE(JERR_GIF_BUG, \"GIF output got confused\")\nJMESSAGE(JERR_GIF_CODESIZE, \"Bogus GIF codesize %d\")\nJMESSAGE(JERR_GIF_COLORSPACE, \"GIF output must be grayscale or RGB\")\nJMESSAGE(JERR_GIF_EMPTY, \"Empty GIF image\")\nJMESSAGE(JERR_GIF_IMAGENOTFOUND, \"Too few images in GIF file\")\nJMESSAGE(JERR_GIF_NOT, \"Not a GIF file\")\nJMESSAGE(JTRC_GIF, \"%ux%ux%d GIF image\")\nJMESSAGE(JTRC_GIF_BADVERSION,\n         \"Warning: unexpected GIF version number '%c%c%c'\")\nJMESSAGE(JTRC_GIF_EXTENSION, \"Ignoring GIF extension block of type 0x%02x\")\nJMESSAGE(JTRC_GIF_NONSQUARE, \"Caution: nonsquare pixels in input\")\nJMESSAGE(JWRN_GIF_BADDATA, \"Corrupt data in GIF file\")\nJMESSAGE(JWRN_GIF_CHAR, \"Bogus char 0x%02x in GIF file, ignoring\")\nJMESSAGE(JWRN_GIF_ENDCODE, \"Premature end of GIF image\")\nJMESSAGE(JWRN_GIF_NOMOREDATA, \"Ran out of GIF bits\")\n\nJMESSAGE(JERR_PPM_COLORSPACE, \"PPM output must be grayscale or RGB\")\nJMESSAGE(JERR_PPM_NONNUMERIC, \"Nonnumeric data in PPM file\")\nJMESSAGE(JERR_PPM_NOT, \"Not a PPM/PGM file\")\nJMESSAGE(JERR_PPM_OUTOFRANGE, \"Numeric value out of range in PPM file\")\nJMESSAGE(JTRC_PGM, \"%ux%u PGM image (maximum color value = %u)\")\nJMESSAGE(JTRC_PGM_TEXT, \"%ux%u text PGM image (maximum color value = %u)\")\nJMESSAGE(JTRC_PPM, \"%ux%u PPM image (maximum color value = %u)\")\nJMESSAGE(JTRC_PPM_TEXT, \"%ux%u text PPM image (maximum color value = %u)\")\n\nJMESSAGE(JERR_TGA_BADCMAP, \"Unsupported Targa colormap format\")\nJMESSAGE(JERR_TGA_BADPARMS, \"Invalid or unsupported Targa file\")\nJMESSAGE(JERR_TGA_COLORSPACE, \"Targa output must be grayscale or RGB\")\nJMESSAGE(JTRC_TGA, \"%ux%u RGB Targa image\")\nJMESSAGE(JTRC_TGA_GRAY, \"%ux%u grayscale Targa image\")\nJMESSAGE(JTRC_TGA_MAPPED, \"%ux%u colormapped Targa image\")\nJMESSAGE(JERR_TGA_NOTCOMP, \"Targa support was not compiled\")\n\nJMESSAGE(JERR_BAD_CMAP_FILE,\n         \"Color map file is invalid or of unsupported format\")\nJMESSAGE(JERR_TOO_MANY_COLORS,\n         \"Output file format cannot handle %d colormap entries\")\nJMESSAGE(JERR_UNGETC_FAILED, \"ungetc failed\")\n#ifdef PNG_SUPPORTED\nJMESSAGE(JERR_UNKNOWN_FORMAT,\n         \"MozJPEG can't read the image (JPEG, PNG and old BMP and Targa are supported)\")\n#else\nJMESSAGE(JERR_UNKNOWN_FORMAT, \"MozJPEG can't read the image (PNG support is disabled in this build)\")\n#endif\nJMESSAGE(JERR_UNSUPPORTED_FORMAT, \"Unsupported output file format\")\n\n#ifdef PNG_SUPPORTED\nJMESSAGE(JERR_PNG_ERROR, \"Unable to read PNG file: %s\")\nJMESSAGE(JERR_PNG_PROFILETOOLARGE, \"Embedded profile was too large for this tool - dropped.\")\n#endif\n\n#ifdef JMAKE_ENUM_LIST\n\n  JMSG_LASTADDONCODE\n} ADDON_MESSAGE_CODE;\n\n#undef JMAKE_ENUM_LIST\n#endif /* JMAKE_ENUM_LIST */\n\n/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */\n#undef JMESSAGE\n"
        },
        {
          "name": "cdjpeg.c",
          "type": "blob",
          "size": 4.2724609375,
          "content": "/*\n * cdjpeg.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2019, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains common support routines used by the IJG application\n * programs (cjpeg, djpeg, jpegtran).\n */\n\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n#include <ctype.h>              /* to declare isupper(), tolower() */\n#ifdef USE_SETMODE\n#include <fcntl.h>              /* to declare setmode()'s parameter macros */\n/* If you have setmode() but not <io.h>, just delete this line: */\n#include <io.h>                 /* to declare setmode() */\n#endif\n\n\n/*\n * Optional progress monitor: display a percent-done figure on stderr.\n */\n\nMETHODDEF(void)\nprogress_monitor(j_common_ptr cinfo)\n{\n  cd_progress_ptr prog = (cd_progress_ptr)cinfo->progress;\n\n  if (prog->max_scans != 0 && cinfo->is_decompressor) {\n    int scan_no = ((j_decompress_ptr)cinfo)->input_scan_number;\n\n    if (scan_no > (int)prog->max_scans) {\n      fprintf(stderr, \"Scan number %d exceeds maximum scans (%u)\\n\", scan_no,\n              prog->max_scans);\n      exit(EXIT_FAILURE);\n    }\n  }\n\n  if (prog->report) {\n    int total_passes = prog->pub.total_passes + prog->total_extra_passes;\n    int percent_done =\n      (int)(prog->pub.pass_counter * 100L / prog->pub.pass_limit);\n\n    if (percent_done != prog->percent_done) {\n      prog->percent_done = percent_done;\n      if (total_passes > 1) {\n        fprintf(stderr, \"\\rPass %d/%d: %3d%% \",\n                prog->pub.completed_passes + prog->completed_extra_passes + 1,\n                total_passes, percent_done);\n      } else {\n        fprintf(stderr, \"\\r %3d%% \", percent_done);\n      }\n      fflush(stderr);\n    }\n  }\n}\n\n\nGLOBAL(void)\nstart_progress_monitor(j_common_ptr cinfo, cd_progress_ptr progress)\n{\n  /* Enable progress display, unless trace output is on */\n  if (cinfo->err->trace_level == 0) {\n    progress->pub.progress_monitor = progress_monitor;\n    progress->completed_extra_passes = 0;\n    progress->total_extra_passes = 0;\n    progress->max_scans = 0;\n    progress->report = FALSE;\n    progress->percent_done = -1;\n    cinfo->progress = &progress->pub;\n  }\n}\n\n\nGLOBAL(void)\nend_progress_monitor(j_common_ptr cinfo)\n{\n  /* Clear away progress display */\n  if (cinfo->err->trace_level == 0) {\n    fprintf(stderr, \"\\r                \\r\");\n    fflush(stderr);\n  }\n}\n\n\n/*\n * Case-insensitive matching of possibly-abbreviated keyword switches.\n * keyword is the constant keyword (must be lower case already),\n * minchars is length of minimum legal abbreviation.\n */\n\nGLOBAL(boolean)\nkeymatch(char *arg, const char *keyword, int minchars)\n{\n  register int ca, ck;\n  register int nmatched = 0;\n\n  while ((ca = *arg++) != '\\0') {\n    if ((ck = *keyword++) == '\\0')\n      return FALSE;             /* arg longer than keyword, no good */\n    if (isupper(ca))            /* force arg to lcase (assume ck is already) */\n      ca = tolower(ca);\n    if (ca != ck)\n      return FALSE;             /* no good */\n    nmatched++;                 /* count matched characters */\n  }\n  /* reached end of argument; fail if it's too short for unique abbrev */\n  if (nmatched < minchars)\n    return FALSE;\n  return TRUE;                  /* A-OK */\n}\n\n\n/*\n * Routines to establish binary I/O mode for stdin and stdout.\n * Non-Unix systems often require some hacking to get out of text mode.\n */\n\nGLOBAL(FILE *)\nread_stdin(void)\n{\n  FILE *input_file = stdin;\n\n#ifdef USE_SETMODE              /* need to hack file mode? */\n  setmode(fileno(stdin), O_BINARY);\n#endif\n#ifdef USE_FDOPEN               /* need to re-open in binary mode? */\n  if ((input_file = fdopen(fileno(stdin), READ_BINARY)) == NULL) {\n    fprintf(stderr, \"Cannot reopen stdin\\n\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n  return input_file;\n}\n\n\nGLOBAL(FILE *)\nwrite_stdout(void)\n{\n  FILE *output_file = stdout;\n\n#ifdef USE_SETMODE              /* need to hack file mode? */\n  setmode(fileno(stdout), O_BINARY);\n#endif\n#ifdef USE_FDOPEN               /* need to re-open in binary mode? */\n  if ((output_file = fdopen(fileno(stdout), WRITE_BINARY)) == NULL) {\n    fprintf(stderr, \"Cannot reopen stdout\\n\");\n    exit(EXIT_FAILURE);\n  }\n#endif\n  return output_file;\n}\n"
        },
        {
          "name": "cdjpeg.h",
          "type": "blob",
          "size": 6.8076171875,
          "content": "/*\n * cdjpeg.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * Modified 2019 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2017, 2019, 2021-2022, D. R. Commander.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains common declarations for the sample applications\n * cjpeg and djpeg.  It is NOT used by the core JPEG library.\n */\n\n#define JPEG_CJPEG_DJPEG        /* define proper options in jconfig.h */\n#define JPEG_INTERNAL_OPTIONS   /* cjpeg.c,djpeg.c need to see xxx_SUPPORTED */\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jerror.h\"             /* get library error codes too */\n#include \"cderror.h\"            /* get application-specific error codes */\n\n#define JPEG_RAW_READER 0\n\n/*\n * Object interface for cjpeg's source file decoding modules\n */\n\ntypedef struct cjpeg_source_struct *cjpeg_source_ptr;\n\nstruct cjpeg_source_struct {\n  void (*start_input) (j_compress_ptr cinfo, cjpeg_source_ptr sinfo);\n  JDIMENSION (*get_pixel_rows) (j_compress_ptr cinfo, cjpeg_source_ptr sinfo);\n  void (*finish_input) (j_compress_ptr cinfo, cjpeg_source_ptr sinfo);\n\n  FILE *input_file;\n\n  JSAMPARRAY buffer;\n  J12SAMPARRAY buffer12;\n#ifdef C_LOSSLESS_SUPPORTED\n  J16SAMPARRAY buffer16;\n#endif\n  JDIMENSION buffer_height;\n  JDIMENSION max_pixels;\n#if JPEG_RAW_READER\n  // For reading JPEG\n  JSAMPARRAY plane_pointer[4];\n#endif\n  \n  jpeg_saved_marker_ptr marker_list;\n};\n\n\n/*\n * Object interface for djpeg's output file encoding modules\n */\n\ntypedef struct djpeg_dest_struct *djpeg_dest_ptr;\n\nstruct djpeg_dest_struct {\n  /* start_output is called after jpeg_start_decompress finishes.\n   * The color map will be ready at this time, if one is needed.\n   */\n  void (*start_output) (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo);\n  /* Emit the specified number of pixel rows from the buffer. */\n  void (*put_pixel_rows) (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n                          JDIMENSION rows_supplied);\n  /* Finish up at the end of the image. */\n  void (*finish_output) (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo);\n  /* Re-calculate buffer dimensions based on output dimensions (for use with\n     partial image decompression.)  If this is NULL, then the output format\n     does not support partial image decompression (BMP, in particular, cannot\n     support partial decompression because it uses an inversion buffer to write\n     the image in bottom-up order.) */\n  void (*calc_buffer_dimensions) (j_decompress_ptr cinfo,\n                                  djpeg_dest_ptr dinfo);\n\n\n  /* Target file spec; filled in by djpeg.c after object is created. */\n  FILE *output_file;\n\n  /* Output pixel-row buffer.  Created by module init or start_output.\n   * Width is cinfo->output_width * cinfo->output_components;\n   * height is buffer_height.\n   */\n  JSAMPARRAY buffer;\n  J12SAMPARRAY buffer12;\n#ifdef D_LOSSLESS_SUPPORTED\n  J16SAMPARRAY buffer16;\n#endif\n  JDIMENSION buffer_height;\n};\n\n\n/*\n * cjpeg/djpeg may need to perform extra passes to convert to or from\n * the source/destination file format.  The JPEG library does not know\n * about these passes, but we'd like them to be counted by the progress\n * monitor.  We use an expanded progress monitor object to hold the\n * additional pass count.\n */\n\nstruct cdjpeg_progress_mgr {\n  struct jpeg_progress_mgr pub; /* fields known to JPEG library */\n  int completed_extra_passes;   /* extra passes completed */\n  int total_extra_passes;       /* total extra */\n  JDIMENSION max_scans;         /* abort if the number of scans exceeds this\n                                   value and the value is non-zero */\n  boolean report;               /* whether or not to report progress */\n  /* last printed percentage stored here to avoid multiple printouts */\n  int percent_done;\n};\n\ntypedef struct cdjpeg_progress_mgr *cd_progress_ptr;\n\n\n/* Module selection routines for I/O modules. */\n\nEXTERN(cjpeg_source_ptr) jinit_read_jpeg (j_compress_ptr cinfo);\nEXTERN(cjpeg_source_ptr) jinit_read_png (j_compress_ptr cinfo);\nEXTERN(cjpeg_source_ptr) jinit_read_bmp(j_compress_ptr cinfo,\n                                        boolean use_inversion_array);\nEXTERN(djpeg_dest_ptr) jinit_write_bmp(j_decompress_ptr cinfo, boolean is_os2,\n                                       boolean use_inversion_array);\nEXTERN(cjpeg_source_ptr) jinit_read_gif(j_compress_ptr cinfo);\nEXTERN(cjpeg_source_ptr) j12init_read_gif(j_compress_ptr cinfo);\n#ifdef C_LOSSLESS_SUPPORTED\nEXTERN(cjpeg_source_ptr) j16init_read_gif(j_compress_ptr cinfo);\n#endif\nEXTERN(djpeg_dest_ptr) jinit_write_gif(j_decompress_ptr cinfo, boolean is_lzw);\nEXTERN(djpeg_dest_ptr) j12init_write_gif(j_decompress_ptr cinfo,\n                                         boolean is_lzw);\nEXTERN(cjpeg_source_ptr) jinit_read_ppm(j_compress_ptr cinfo);\nEXTERN(cjpeg_source_ptr) j12init_read_ppm(j_compress_ptr cinfo);\n#ifdef C_LOSSLESS_SUPPORTED\nEXTERN(cjpeg_source_ptr) j16init_read_ppm(j_compress_ptr cinfo);\n#endif\nEXTERN(djpeg_dest_ptr) jinit_write_ppm(j_decompress_ptr cinfo);\nEXTERN(djpeg_dest_ptr) j12init_write_ppm(j_decompress_ptr cinfo);\n#ifdef D_LOSSLESS_SUPPORTED\nEXTERN(djpeg_dest_ptr) j16init_write_ppm(j_decompress_ptr cinfo);\n#endif\nEXTERN(cjpeg_source_ptr) jinit_read_targa(j_compress_ptr cinfo);\nEXTERN(djpeg_dest_ptr) jinit_write_targa(j_decompress_ptr cinfo);\n\n/* cjpeg support routines (in rdswitch.c) */\n\nEXTERN(boolean) read_quant_tables(j_compress_ptr cinfo, char *filename,\n                                  boolean force_baseline);\nEXTERN(boolean) read_scan_script(j_compress_ptr cinfo, char *filename);\nEXTERN(boolean) set_quality_ratings(j_compress_ptr cinfo, char *arg,\n                                    boolean force_baseline);\nEXTERN(boolean) set_quant_slots(j_compress_ptr cinfo, char *arg);\nEXTERN(boolean) set_sample_factors(j_compress_ptr cinfo, char *arg);\n\n/* djpeg support routines (in rdcolmap.c) */\n\nEXTERN(void) read_color_map(j_decompress_ptr cinfo, FILE *infile);\nEXTERN(void) read_color_map_12(j_decompress_ptr cinfo, FILE *infile);\n\n/* common support routines (in cdjpeg.c) */\n\nEXTERN(void) start_progress_monitor(j_common_ptr cinfo,\n                                    cd_progress_ptr progress);\nEXTERN(void) end_progress_monitor(j_common_ptr cinfo);\nEXTERN(boolean) keymatch(char *arg, const char *keyword, int minchars);\nEXTERN(FILE *) read_stdin(void);\nEXTERN(FILE *) write_stdout(void);\n\n/* miscellaneous useful macros */\n\n#ifdef DONT_USE_B_MODE          /* define mode parameters for fopen() */\n#define READ_BINARY     \"r\"\n#define WRITE_BINARY    \"w\"\n#else\n#define READ_BINARY     \"rb\"\n#define WRITE_BINARY    \"wb\"\n#endif\n\n#ifndef EXIT_FAILURE            /* define exit() codes if not provided */\n#define EXIT_FAILURE  1\n#endif\n#ifndef EXIT_SUCCESS\n#define EXIT_SUCCESS  0\n#endif\n#ifndef EXIT_WARNING\n#define EXIT_WARNING  2\n#endif\n"
        },
        {
          "name": "change.log",
          "type": "blob",
          "size": 12.5771484375,
          "content": "libjpeg-turbo note:  This file has been modified by The libjpeg-turbo Project\nto include only information relevant to libjpeg-turbo.  It is included only for\nreference.  Please see ChangeLog.md for information specific to libjpeg-turbo.\n\n\nCHANGE LOG for Independent JPEG Group's JPEG software\n\n\nVersion 9d  12-Jan-2020\n-----------------------\n\nRestore GIF read and write support from libjpeg version 6a.\nThank to Wolfgang Werner (W.W.) Heinz for suggestion.\n\nAdd jpegtran -drop option; add options to the crop extension and wipe\nto fill the extra area with content from the source image region,\ninstead of gray out.\n\n\nVersion 9c  14-Jan-2018\n-----------------------\n\njpegtran: add an option to the -wipe switch to fill the region\nwith the average of adjacent blocks, instead of gray out.\nThank to Caitlyn Feddock and Maddie Ziegler for inspiration.\n\n\nVersion 9b  17-Jan-2016\n-----------------------\n\nDocument 'f' specifier for jpegtran -crop specification.\nThank to Michele Martone for suggestion.\n\n\nVersion 9a  19-Jan-2014\n-----------------------\n\nAdd jpegtran -wipe option and extension for -crop.\nThank to Andrew Senior, David Clunie, and Josef Schmid for suggestion.\n\n\nVersion 9  13-Jan-2013\n----------------------\n\nAdd remark for jpeg_mem_dest() in jdatadst.c.\nThank to Elie-Gregoire Khoury for the hint.\n\nCorrect argument type in format string, avoid compiler warnings.\nThank to Vincent Torri for hint.\n\n\nVersion 8d  15-Jan-2012\n-----------------------\n\nAdd cjpeg -rgb option to create RGB JPEG files.\nUsing this switch suppresses the conversion from RGB\ncolorspace input to the default YCbCr JPEG colorspace.\nThank to Michael Koch for the initial suggestion.\n\nAdd option to disable the region adjustment in the transupp crop code.\nThank to Jeffrey Friedl for the suggestion.\n\n\nVersion 8b  16-May-2010\n-----------------------\n\nRepair problem in new memory source manager with corrupt JPEG data.\nThank to Ted Campbell and Samuel Chun for the report.\n\n\nVersion 8a  28-Feb-2010\n-----------------------\n\nWriting tables-only datastreams via jpeg_write_tables works again.\n\nSupport 32-bit BMPs (RGB image with Alpha channel) for read in cjpeg.\nThank to Brett Blackham for the suggestion.\n\n\nVersion 8  10-Jan-2010\n----------------------\n\nAdd sanity check in BMP reader module to avoid cjpeg crash for empty input\nimage (thank to Isaev Ildar of ISP RAS, Moscow, RU for reporting this error).\n\nAdd data source and destination managers for read from and write to\nmemory buffers.  New API functions jpeg_mem_src and jpeg_mem_dest.\nThank to Roberto Boni from Italy for the suggestion.\n\n\nVersion 7  27-Jun-2009\n----------------------\n\nNew scaled DCTs implemented.\ndjpeg now supports scalings N/8 with all N from 1 to 16.\n\ncjpeg -quality option has been extended for support of separate quality\nsettings for luminance and chrominance (or in general, for every provided\nquantization table slot).\nNew API function jpeg_default_qtables() and q_scale_factor array in library.\n\nSupport arithmetic entropy encoding and decoding.\nAdded files jaricom.c, jcarith.c, jdarith.c.\n\njpegtran has a new \"lossless\" cropping feature.\n\nImplement -perfect option in jpegtran, new API function\njtransform_perfect_transform() in transupp. (DP 204_perfect.dpatch)\n\nBetter error messages for jpegtran fopen failure.\n(DP 203_jpegtran_errmsg.dpatch)\n\nFix byte order issue with 16bit PPM/PGM files in rdppm.c/wrppm.c:\naccording to Netpbm, the de facto standard implementation of the PNM formats,\nthe most significant byte is first. (DP 203_rdppm.dpatch)\n\nAdd -raw option to rdjpgcom not to mangle the output.\n(DP 205_rdjpgcom_raw.dpatch)\n\nMake rdjpgcom locale aware. (DP 201_rdjpgcom_locale.dpatch)\n\nAdd extern \"C\" to jpeglib.h.\nThis avoids the need to put extern \"C\" { ... } around #include \"jpeglib.h\"\nin your C++ application.  Defining the symbol DONT_USE_EXTERN_C in the\nconfiguration prevents this. (DP 202_jpeglib.h_c++.dpatch)\n\n\nVersion 6b  27-Mar-1998\n-----------------------\n\njpegtran has new features for lossless image transformations (rotation\nand flipping) as well as \"lossless\" reduction to grayscale.\n\njpegtran now copies comments by default; it has a -copy switch to enable\ncopying all APPn blocks as well, or to suppress comments.  (Formerly it\nalways suppressed comments and APPn blocks.)  jpegtran now also preserves\nJFIF version and resolution information.\n\nNew decompressor library feature: COM and APPn markers found in the input\nfile can be saved in memory for later use by the application.  (Before,\nyou had to code this up yourself with a custom marker processor.)\n\nThere is an unused field \"void * client_data\" now in compress and decompress\nparameter structs; this may be useful in some applications.\n\nJFIF version number information is now saved by the decoder and accepted by\nthe encoder.  jpegtran uses this to copy the source file's version number,\nto ensure \"jpegtran -copy all\" won't create bogus files that contain JFXX\nextensions but claim to be version 1.01.  Applications that generate their\nown JFXX extension markers also (finally) have a supported way to cause the\nencoder to emit JFIF version number 1.02.\n\ndjpeg's trace mode reports JFIF 1.02 thumbnail images as such, rather\nthan as unknown APP0 markers.\n\nIn -verbose mode, djpeg and rdjpgcom will try to print the contents of\nAPP12 markers as text.  Some digital cameras store useful text information\nin APP12 markers.\n\nHandling of truncated data streams is more robust: blocks beyond the one in\nwhich the error occurs will be output as uniform gray, or left unchanged\nif decoding a progressive JPEG.  The appearance no longer depends on the\nHuffman tables being used.\n\nHuffman tables are checked for validity much more carefully than before.\n\nThe configure script now supports building libjpeg as a shared library\non many flavors of Unix (all the ones that GNU libtool knows how to\nbuild shared libraries for).  Use \"./configure --enable-shared\" to\ntry this out.\n\nNew jconfig file and makefiles for Microsoft Visual C++ and Developer Studio.\nAlso, a jconfig file and a build script for Metrowerks CodeWarrior\non Apple Macintosh.  makefile.dj has been updated for DJGPP v2, and there\nare miscellaneous other minor improvements in the makefiles.\n\njmemmac.c now knows how to create temporary files following Mac System 7\nconventions.\n\ndjpeg's -map switch is now able to read raw-format PPM files reliably.\n\ncjpeg -progressive -restart no longer generates any unnecessary DRI markers.\n\nMultiple calls to jpeg_simple_progression for a single JPEG object\nno longer leak memory.\n\n\nVersion 6a  7-Feb-96\n--------------------\n\nLibrary initialization sequence modified to detect version mismatches\nand struct field packing mismatches between library and calling application.\nThis change requires applications to be recompiled, but does not require\nany application source code change.\n\nAll routine declarations changed to the style \"GLOBAL(type) name ...\",\nthat is, GLOBAL, LOCAL, METHODDEF, EXTERN are now macros taking the\nroutine's return type as an argument.  This makes it possible to add\nMicrosoft-style linkage keywords to all the routines by changing just\nthese macros.  Note that any application code that was using these macros\nwill have to be changed.\n\nDCT coefficient quantization tables are now stored in normal array order\nrather than zigzag order.  Application code that calls jpeg_add_quant_table,\nor otherwise manipulates quantization tables directly, will need to be\nchanged.  If you need to make such code work with either older or newer\nversions of the library, a test like \"#if JPEG_LIB_VERSION >= 61\" is\nrecommended.\n\ndjpeg's trace capability now dumps DQT tables in natural order, not zigzag\norder.  This allows the trace output to be made into a \"-qtables\" file\nmore easily.\n\nNew system-dependent memory manager module for use on Apple Macintosh.\n\nFix bug in cjpeg's -smooth option: last one or two scanlines would be\nduplicates of the prior line unless the image height mod 16 was 1 or 2.\n\nRepair minor problems in VMS, BCC, MC6 makefiles.\n\nNew configure script based on latest GNU Autoconf.\n\nCorrect the list of include files needed by MetroWerks C for ccommand().\n\nNumerous small documentation updates.\n\n\nVersion 6  2-Aug-95\n-------------------\n\nProgressive JPEG support: library can read and write full progressive JPEG\nfiles.  A \"buffered image\" mode supports incremental decoding for on-the-fly\ndisplay of progressive images.  Simply recompiling an existing IJG-v5-based\ndecoder with v6 should allow it to read progressive files, though of course\nwithout any special progressive display.\n\nNew \"jpegtran\" application performs lossless transcoding between different\nJPEG formats; primarily, it can be used to convert baseline to progressive\nJPEG and vice versa.  In support of jpegtran, the library now allows lossless\nreading and writing of JPEG files as DCT coefficient arrays.  This ability\nmay be of use in other applications.\n\nNotes for programmers:\n* We changed jpeg_start_decompress() to be able to suspend; this makes all\ndecoding modes available to suspending-input applications.  However,\nexisting applications that use suspending input will need to be changed\nto check the return value from jpeg_start_decompress().  You don't need to\ndo anything if you don't use a suspending data source.\n* We changed the interface to the virtual array routines: access_virt_array\nroutines now take a count of the number of rows to access this time.  The\nlast parameter to request_virt_array routines is now interpreted as the\nmaximum number of rows that may be accessed at once, but not necessarily\nthe height of every access.\n\n\nVersion 5b  15-Mar-95\n---------------------\n\nCorrect bugs with grayscale images having v_samp_factor > 1.\n\njpeg_write_raw_data() now supports output suspension.\n\nCorrect bugs in \"configure\" script for case of compiling in\na directory other than the one containing the source files.\n\nRepair bug in jquant1.c: sometimes didn't use as many colors as it could.\n\nBorland C makefile and jconfig file work under either MS-DOS or OS/2.\n\nMiscellaneous improvements to documentation.\n\n\nVersion 5a  7-Dec-94\n--------------------\n\nChanged color conversion roundoff behavior so that grayscale values are\nrepresented exactly.  (This causes test image files to change.)\n\nMake ordered dither use 16x16 instead of 4x4 pattern for a small quality\nimprovement.\n\nNew configure script based on latest GNU Autoconf.\nFix configure script to handle CFLAGS correctly.\nRename *.auto files to *.cfg, so that configure script still works if\nfile names have been truncated for DOS.\n\nFix bug in rdbmp.c: didn't allow for extra data between header and image.\n\nModify rdppm.c/wrppm.c to handle 2-byte raw PPM/PGM formats for 12-bit data.\n\nFix several bugs in rdrle.c.\n\nNEED_SHORT_EXTERNAL_NAMES option was broken.\n\nRevise jerror.h/jerror.c for more flexibility in message table.\n\nRepair oversight in jmemname.c NO_MKTEMP case: file could be there\nbut unreadable.\n\n\nVersion 5  24-Sep-94\n--------------------\n\nVersion 5 represents a nearly complete redesign and rewrite of the IJG\nsoftware.  Major user-visible changes include:\n  * Automatic configuration simplifies installation for most Unix systems.\n  * A range of speed vs. image quality tradeoffs are supported.\n    This includes resizing of an image during decompression: scaling down\n    by a factor of 1/2, 1/4, or 1/8 is handled very efficiently.\n  * New programs rdjpgcom and wrjpgcom allow insertion and extraction\n    of text comments in a JPEG file.\n\nThe application programmer's interface to the library has changed completely.\nNotable improvements include:\n  * We have eliminated the use of callback routines for handling the\n    uncompressed image data.  The application now sees the library as a\n    set of routines that it calls to read or write image data on a\n    scanline-by-scanline basis.\n  * The application image data is represented in a conventional interleaved-\n    pixel format, rather than as a separate array for each color channel.\n    This can save a copying step in many programs.\n  * The handling of compressed data has been cleaned up: the application can\n    supply routines to source or sink the compressed data.  It is possible to\n    suspend processing on source/sink buffer overrun, although this is not\n    supported in all operating modes.\n  * All static state has been eliminated from the library, so that multiple\n    instances of compression or decompression can be active concurrently.\n  * JPEG abbreviated datastream formats are supported, ie, quantization and\n    Huffman tables can be stored separately from the image data.\n  * And not only that, but the documentation of the library has improved\n    considerably!\n\n\nThe last widely used release before the version 5 rewrite was version 4A of\n18-Feb-93.  Change logs before that point have been discarded, since they\nare not of much interest after the rewrite.\n"
        },
        {
          "name": "cjpeg.1",
          "type": "blob",
          "size": 16.3408203125,
          "content": ".TH CJPEG 1 \"30 August 2024\"\n.SH NAME\ncjpeg \\- compress an image file to a JPEG file\n.SH SYNOPSIS\n.B cjpeg\n[\n.I options\n]\n[\n.I filename\n]\n.LP\n.SH DESCRIPTION\n.LP\n.B cjpeg\ncompresses the named image file, or the standard input if no file is\nnamed, and produces a JPEG/JFIF file on the standard output.\nThe currently supported input file formats are: PPM (PBMPLUS color\nformat), PGM (PBMPLUS grayscale format), BMP, GIF [legacy feature], and Targa\n[legacy feature].\n.SH OPTIONS\nAll switch names may be abbreviated; for example,\n.B \\-grayscale\nmay be written\n.B \\-gray\nor\n.BR \\-gr .\nMost of the \"basic\" switches can be abbreviated to as little as one letter.\nUpper and lower case are equivalent (thus\n.B \\-BMP\nis the same as\n.BR \\-bmp ).\nBritish spellings are also accepted (e.g.\n.BR \\-greyscale ),\nthough for brevity these are not mentioned below.\n.PP\nThe basic switches are:\n.TP\n.BI \\-quality \" N[,...]\"\nScale quantization tables to adjust image quality.  Quality is 0 (worst) to\n100 (best); default is 75.  (See below for more info.)\n.TP\n.B \\-grayscale\nCreate monochrome JPEG file from color input.  By specifying\n.BR \\-grayscale,\nyou'll get a smaller JPEG file that takes less time to process.\n.TP\n.B \\-rgb\nCreate RGB JPEG file.  Using this switch suppresses the conversion from RGB\ncolorspace input to the default YCbCr JPEG colorspace.\n.TP\n.B \\-optimize\nPerform optimization of entropy encoding parameters.  Without this, default\nencoding parameters are used.\n.B \\-optimize\nusually makes the JPEG file a little smaller, but\n.B cjpeg\nruns somewhat slower and needs much more memory.  Image quality and speed of\ndecompression are unaffected by\n.BR \\-optimize .\n.TP\n.B \\-progressive\nCreate progressive JPEG file (see below).  Implies\n.B \\-optimize\nunless\n.B \\-arithmetic\nis also specified.\n.TP\n.B \\-targa\nInput file is Targa format [legacy feature].  Targa files that contain an\n\"identification\" field will not be automatically recognized by\n.BR cjpeg .\nFor such files, you must specify\n.B \\-targa\nto make\n.B cjpeg\ntreat the input as Targa format.  For most Targa files, you won't need this\nswitch.\n.PP\nThe\n.B \\-quality\nswitch lets you trade off compressed file size against quality of the\nreconstructed image: the higher the quality setting, the larger the JPEG file,\nand the closer the output image will be to the original input.  Normally you\nwant to use the lowest quality setting (smallest file) that decompresses into\nsomething visually indistinguishable from the original image.  For this\npurpose the quality setting should generally be between 50 and 95 (the default\nis 75) for photographic images.  If you see defects at\n.B \\-quality\n75, then go up 5 or 10 counts at a time until you are happy with the output\nimage.  (The optimal setting will vary from one image to another.)\n.PP\n.B \\-quality\n100 will generate a quantization table of all 1's, minimizing loss in the\nquantization step (but there is still information loss in subsampling, as well\nas roundoff error.)  For most images, specifying a quality value above\nabout 95 will increase the size of the compressed file dramatically, and while\nthe quality gain from these higher quality values is measurable (using metrics\nsuch as PSNR or SSIM), it is rarely perceivable by human vision.\n.PP\nIn the other direction, quality values below 50 will produce very small files\nof low image quality.  Settings around 5 to 10 might be useful in preparing an\nindex of a large image library, for example.  Try\n.B \\-quality\n2 (or so) for some amusing Cubist effects.  (Note: quality\nvalues below about 25 generate 2-byte quantization tables, which are\nconsidered optional in the JPEG standard.\n.B cjpeg\nemits a warning message when you give such a quality value, because some\nother JPEG programs may be unable to decode the resulting file.  Use\n.B \\-baseline\nif you need to ensure compatibility at low quality values.)\n.PP\nThe \\fB-quality\\fR option has been extended in this version of \\fBcjpeg\\fR to\nsupport separate quality settings for luminance and chrominance (or, in\ngeneral, separate settings for every quantization table slot.)  The principle\nis the same as chrominance subsampling:  since the human eye is more sensitive\nto spatial changes in brightness than spatial changes in color, the chrominance\ncomponents can be quantized more than the luminance components without\nincurring any visible image quality loss.  However, unlike subsampling, this\nfeature reduces data in the frequency domain instead of the spatial domain,\nwhich allows for more fine-grained control.  This option is useful in\nquality-sensitive applications, for which the artifacts generated by\nsubsampling may be unacceptable.\n.PP\nThe \\fB-quality\\fR option accepts a comma-separated list of parameters, which\nrespectively refer to the quality levels that should be assigned to the\nquantization table slots.  If there are more q-table slots than parameters,\nthen the last parameter is replicated.  Thus, if only one quality parameter is\ngiven, this is used for both luminance and chrominance (slots 0 and 1,\nrespectively), preserving the legacy behavior of cjpeg v6b and prior.\nMore (or customized) quantization tables can be set with the \\fB-qtables\\fR\noption and assigned to components with the \\fB-qslots\\fR option (see the\n\"wizard\" switches below.)\n.PP\nJPEG files generated with separate luminance and chrominance quality are fully\ncompliant with standard JPEG decoders.\n.PP\n.BR CAUTION:\nFor this setting to be useful, be sure to pass an argument of \\fB-sample 1x1\\fR\nto \\fBcjpeg\\fR to disable chrominance subsampling.  Otherwise, the default\nsubsampling level (2x2, AKA \"4:2:0\") will be used.\n.PP\nThe\n.B \\-progressive\nswitch creates a \"progressive JPEG\" file.  In this type of JPEG file, the data\nis stored in multiple scans of increasing quality.  If the file is being\ntransmitted over a slow communications link, the decoder can use the first\nscan to display a low-quality image very quickly, and can then improve the\ndisplay with each subsequent scan.  The final image is exactly equivalent to a\nstandard JPEG file of the same quality setting, and the total file size is\nabout the same --- often a little smaller.\n.PP\nSwitches for advanced users:\n.TP\n.BI \\-precision \" N\"\nCreate JPEG file with N-bit data precision.  N is 8, 12, or 16; default is 8.\nIf N is 16, then\n.B -lossless\nmust also be specified.  Note that only the PBMPLUS input file format supports\ndata precisions other than 8.  (For historical reasons,\n.B cjpeg\nallows GIF input files to be converted into 12-bit-per-sample JPEG files, but\nthis is not a useful conversion.)  Note also that PBMPLUS input files are\nsilently scaled to the target data precision, even if it is lower than the\nprecision of the input file.  Passing an argument of\n.B \\-verbose\nto\n.B cjpeg\nwill cause it to print information about the precision of the input file.\n.B Caution:\n12-bit and 16-bit data precision is not yet widely implemented, so many\ndecoders will be unable to handle a 12-bit-per-sample or 16-bit-per-sample JPEG\nfile at all.\n.IP\n.B \\-precision\\ 12\nimplies\n.B \\-optimize\nunless\n.B \\-arithmetic\nis also specified.\n.TP\n.BI \\-lossless \" psv[,Pt]\"\nCreate a lossless JPEG file using the specified predictor selection value\n(1 through 7) and optional point transform (0 through\n.nh\n.I precision\n.hy\n- 1, where\n.nh\n.I precision\n.hy\nis the JPEG data precision in bits).  A point transform value of 0 (the\ndefault) is necessary in order to create a fully lossless JPEG file.  (A\nnon-zero point transform value right-shifts the input samples by the specified\nnumber of bits, which is effectively a form of lossy color quantization.)\n.B Caution:\nlossless JPEG is not yet widely implemented, so many decoders will be unable to\nhandle a lossless JPEG file at all.  In most cases, compressing and\ndecompressing a lossless JPEG file is considerably slower than compressing and\ndecompressing a lossy JPEG file, and lossless JPEG files are much larger than\nlossy JPEG files.  Also note that the following features will be unavailable\nwhen compressing or decompressing a lossless JPEG file:\n.IP\n- Quality/quantization table selection\n.IP\n- Color space conversion (the JPEG image will use the same color space as the\ninput image)\n.IP\n- Color quantization\n.IP\n- DCT/IDCT algorithm selection\n.IP\n- Smoothing\n.IP\n- Downsampling/upsampling\n.IP\n- IDCT scaling\n.IP\n- Partial image decompression\n.IP\n- Transformations using\n.B jpegtran\n.IP\nAny switches used to enable or configure those features will be ignored.\n.TP\n.B \\-arithmetic\nUse arithmetic coding.\n.B Caution:\narithmetic-coded JPEG is not yet widely implemented, so many decoders will be\nunable to handle an arithmetic-coded JPEG file at all.\n.TP\n.B \\-dct int\nUse accurate integer DCT method (default).\n.TP\n.B \\-dct fast\nUse less accurate integer DCT method [legacy feature].\nWhen the Independent JPEG Group's software was first released in 1991, the\ncompression time for a 1-megapixel JPEG image on a mainstream PC was measured\nin minutes.  Thus, the \\fBfast\\fR integer DCT algorithm provided noticeable\nperformance benefits.  On modern CPUs running libjpeg-turbo, however, the\ncompression time for a 1-megapixel JPEG image is measured in milliseconds, and\nthus the performance benefits of the \\fBfast\\fR algorithm are much less\nnoticeable.  On modern x86/x86-64 CPUs that support AVX2 instructions, the\n\\fBfast\\fR and \\fBint\\fR methods have similar performance.  On other types of\nCPUs, the \\fBfast\\fR method is generally about 5-15% faster than the \\fBint\\fR\nmethod.\n\nFor quality levels of 90 and below, there should be little or no perceptible\nquality difference between the two algorithms.  For quality levels above 90,\nhowever, the difference between the \\fBfast\\fR and \\fBint\\fR methods becomes\nmore pronounced.  With quality=97, for instance, the \\fBfast\\fR method incurs\ngenerally about a 1-3 dB loss in PSNR relative to the \\fBint\\fR method, but\nthis can be larger for some images.  Do not use the \\fBfast\\fR method with\nquality levels above 97.  The algorithm often degenerates at quality=98 and\nabove and can actually produce a more lossy image than if lower quality levels\nhad been used.  Also, in libjpeg-turbo, the \\fBfast\\fR method is not fully\naccelerated for quality levels above 97, so it will be slower than the\n\\fBint\\fR method.\n.TP\n.B \\-dct float\nUse floating-point DCT method [legacy feature].\nThe \\fBfloat\\fR method does not produce significantly more accurate results\nthan the \\fBint\\fR method, and it is much slower.  The \\fBfloat\\fR method may\nalso give different results on different machines due to varying roundoff\nbehavior, whereas the integer methods should give the same results on all\nmachines.\n.TP\n.BI \\-icc \" file\"\nEmbed ICC color management profile contained in the specified file.\n.TP\n.BI \\-restart \" N\"\nEmit a JPEG restart marker every N MCU rows, or every N MCUs if \"B\" is attached\nto the number.\n.IP\nIn typical JPEG images, an MCU (Minimum Coded Unit) is the minimum set of\ninterleaved \"data units\" (8x8 DCT blocks if the image is lossy or samples if\nthe image is lossless) necessary to represent at least one data unit per\ncomponent.  (For example, an MCU in an interleaved lossy JPEG image that uses\n4:2:2 subsampling consists of two luminance blocks followed by one block for\neach chrominance component.)  In single-component or non-interleaved JPEG\nimages, an MCU is the same as a data unit.  An MCU row is a row of MCUs\nspanning the entire width of the image.\n.IP\n.B \\-restart 0\n(the default) means no restart markers.\n.TP\n.BI \\-smooth \" N\"\nSmooth the input image to eliminate dithering noise.  N, ranging from 1 to\n100, indicates the strength of smoothing.  0 (the default) means no smoothing.\n.TP\n.BI \\-maxmemory \" N\"\nSet limit for amount of memory to use in processing large images.  Value is\nin thousands of bytes, or millions of bytes if \"M\" is attached to the\nnumber.  For example,\n.B \\-max 4m\nselects 4000000 bytes.  If more space is needed, an error will occur.\n.TP\n.BI \\-outfile \" name\"\nSend output image to the named file, not to standard output.\n.TP\n.BI \\-memdst\nCompress to memory instead of a file.  This feature was implemented mainly as a\nway of testing the in-memory destination manager (jpeg_mem_dest()), but it is\nalso useful for benchmarking, since it reduces the I/O overhead.\n.TP\n.BI \\-report\nReport compression progress.\n.TP\n.BI \\-strict\nTreat all warnings as fatal.  Enabling this option will cause the compressor to\nabort if an LZW-compressed GIF input image contains incomplete or corrupt image\ndata.\n.TP\n.B \\-verbose\nEnable debug printout.  More\n.BR \\-v 's\ngive more output.  Also, version information is printed at startup.\n.TP\n.B \\-debug\nSame as\n.BR \\-verbose .\n.TP\n.B \\-version\nPrint version information and exit.\n.PP\nThe\n.B \\-restart\noption inserts extra markers that allow a JPEG decoder to resynchronize after\na transmission error.  Without restart markers, any damage to a compressed\nfile will usually ruin the image from the point of the error to the end of the\nimage; with restart markers, the damage is usually confined to the portion of\nthe image up to the next restart marker.  Of course, the restart markers\noccupy extra space.  We recommend\n.B \\-restart 1\nfor images that will be transmitted across unreliable networks such as Usenet.\n.PP\nThe\n.B \\-smooth\noption filters the input to eliminate fine-scale noise.  This is often useful\nwhen converting dithered images to JPEG: a moderate smoothing factor of 10 to\n50 gets rid of dithering patterns in the input file, resulting in a smaller\nJPEG file and a better-looking image.  Too large a smoothing factor will\nvisibly blur the image, however.\n.PP\nSwitches for wizards:\n.TP\n.B \\-baseline\nForce baseline-compatible quantization tables to be generated.  This clamps\nquantization values to 8 bits even at low quality settings.  (This switch is\npoorly named, since it does not ensure that the output is actually baseline\nJPEG.  For example, you can use\n.B \\-baseline\nand\n.B \\-progressive\ntogether.)\n.TP\n.BI \\-qtables \" file\"\nUse the quantization tables given in the specified text file.\n.TP\n.BI \\-qslots \" N[,...]\"\nSelect which quantization table to use for each color component.\n.TP\n.BI \\-sample \" HxV[,...]\"\nSet JPEG sampling factors for each color component.\n.TP\n.BI \\-scans \" file\"\nUse the scan script given in the specified text file.\n.PP\nThe \"wizard\" switches are intended for experimentation with JPEG.  If you\ndon't know what you are doing, \\fBdon't use them\\fR.  These switches are\ndocumented further in the file wizard.txt.\n.SH EXAMPLES\n.LP\nThis example compresses the PPM file foo.ppm with a quality factor of\n60 and saves the output as foo.jpg:\n.IP\n.B cjpeg \\-quality\n.I 60 foo.ppm\n.B >\n.I foo.jpg\n.SH HINTS\nColor GIF files are not the ideal input for JPEG; JPEG is really intended for\ncompressing full-color (24-bit through 48-bit) images.  In particular, don't\ntry to convert cartoons, line drawings, and other images that have only a few\ndistinct colors.  GIF works great on these; JPEG does not.  If you want to\nconvert a GIF to JPEG, you should experiment with\n.BR cjpeg 's\n.B \\-quality\nand\n.B \\-smooth\noptions to get a satisfactory conversion.\n.B \\-smooth 10\nor so is often helpful.\n.PP\nAvoid running an image through a series of JPEG compression/decompression\ncycles.  Image quality loss will accumulate; after ten or so cycles the image\nmay be noticeably worse than it was after one cycle.  It's best to use a\nlossless format while manipulating an image, then convert to JPEG format when\nyou are ready to file the image away.\n.PP\nThe\n.B \\-optimize\noption to\n.B cjpeg\nis worth using when you are making a \"final\" version for posting or archiving.\nIt's also a win when you are using low quality settings to make very small\nJPEG files; the percentage improvement is often a lot more than it is on\nlarger files.  (At present,\n.B \\-optimize\nmode is always selected when generating progressive JPEG files.)\n.SH ENVIRONMENT\n.TP\n.B JPEGMEM\nIf this environment variable is set, its value is the default memory limit.\nThe value is specified as described for the\n.B \\-maxmemory\nswitch.\n.B JPEGMEM\noverrides the default value specified when the program was compiled, and\nitself is overridden by an explicit\n.BR \\-maxmemory .\n.SH SEE ALSO\n.BR djpeg (1),\n.BR jpegtran (1),\n.BR rdjpgcom (1),\n.BR wrjpgcom (1)\n.br\n.BR ppm (5),\n.BR pgm (5)\n.br\nWallace, Gregory K.  \"The JPEG Still Picture Compression Standard\",\nCommunications of the ACM, April 1991 (vol. 34, no. 4), pp. 30-44.\n.SH AUTHOR\nIndependent JPEG Group\n.PP\nThis file was modified by The libjpeg-turbo Project to include only information\nrelevant to libjpeg-turbo, to wordsmith certain sections, and to describe\nfeatures not present in libjpeg.\n.SH ISSUES\nNot all variants of BMP and Targa file formats are supported.\n"
        },
        {
          "name": "cjpeg.c",
          "type": "blob",
          "size": 36.1513671875,
          "content": "/*\n * cjpeg.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1998, Thomas G. Lane.\n * Modified 2003-2011 by Guido Vollbeding.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010, 2013-2014, 2017, 2019-2022, 2024, D. R. Commander.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a command-line user interface for the JPEG compressor.\n * It should work on any system with Unix- or MS-DOS-style command lines.\n *\n * Two different command line styles are permitted, depending on the\n * compile-time switch TWO_FILE_COMMANDLINE:\n *      cjpeg [options]  inputfile outputfile\n *      cjpeg [options]  [inputfile]\n * In the second style, output is always to standard output, which you'd\n * normally redirect to a file or pipe to some other program.  Input is\n * either from a named file or from standard input (typically redirected).\n * The second style is convenient on Unix but is unhelpful on systems that\n * don't support pipes.  Also, you MUST use the first style if your system\n * doesn't do binary I/O to stdin/stdout.\n * To simplify script writing, the \"-outfile\" switch is provided.  The syntax\n *      cjpeg [options]  -outfile outputfile  inputfile\n * works regardless of which command line style is used.\n */\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#ifdef CJPEG_FUZZER\n#define JPEG_INTERNALS\n#endif\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n#include \"jversion.h\"           /* for version message */\n#include \"jconfigint.h\"\n\n\n/* Create the add-on message string table. */\n\n#define JMESSAGE(code, string)  string,\n\nstatic const char * const cdjpeg_message_table[] = {\n#include \"cderror.h\"\n  NULL\n};\n\n\n/*\n * This routine determines what format the input file is,\n * and selects the appropriate input-reading module.\n *\n * To determine which family of input formats the file belongs to,\n * we may look only at the first byte of the file, since C does not\n * guarantee that more than one character can be pushed back with ungetc.\n * Looking at additional bytes would require one of these approaches:\n *     1) assume we can fseek() the input file (fails for piped input);\n *     2) assume we can push back more than one character (works in\n *        some C implementations, but unportable);\n *     3) provide our own buffering (breaks input readers that want to use\n *        stdio directly);\n * or  4) don't put back the data, and modify the input_init methods to assume\n *        they start reading after the start of file.\n * #1 is attractive for MS-DOS but is untenable on Unix.\n *\n * The most portable solution for file types that can't be identified by their\n * first byte is to make the user tell us what they are.  This is also the\n * only approach for \"raw\" file types that contain only arbitrary values.\n * We presently apply this method for Targa files.  Most of the time Targa\n * files start with 0x00, so we recognize that case.  Potentially, however,\n * a Targa file could start with any byte value (byte 0 is the length of the\n * seldom-used ID field), so we provide a switch to force Targa input mode.\n */\n\nstatic boolean is_targa;        /* records user -targa switch */\nstatic boolean is_jpeg;\nstatic boolean copy_markers;\n\nLOCAL(cjpeg_source_ptr)\nselect_file_type(j_compress_ptr cinfo, FILE *infile)\n{\n  int c;\n\n  if (is_targa) {\n#ifdef TARGA_SUPPORTED\n    return jinit_read_targa(cinfo);\n#else\n    ERREXIT(cinfo, JERR_TGA_NOTCOMP);\n#endif\n  }\n\n  if ((c = getc(infile)) == EOF)\n    ERREXIT(cinfo, JERR_INPUT_EMPTY);\n  if (ungetc(c, infile) == EOF)\n    ERREXIT(cinfo, JERR_UNGETC_FAILED);\n\n  switch (c) {\n#ifdef BMP_SUPPORTED\n  case 'B':\n    return jinit_read_bmp(cinfo, TRUE);\n#endif\n#ifdef GIF_SUPPORTED\n  case 'G':\n    if (cinfo->data_precision == 16) {\n#ifdef C_LOSSLESS_SUPPORTED\n      return j16init_read_gif(cinfo);\n#else\n      ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n      break;\n#endif\n    } else if (cinfo->data_precision == 12)\n      return j12init_read_gif(cinfo);\n    else\n      return jinit_read_gif(cinfo);\n#endif\n#ifdef PPM_SUPPORTED\n  case 'P':\n    if (cinfo->data_precision == 16) {\n#ifdef C_LOSSLESS_SUPPORTED\n      return j16init_read_ppm(cinfo);\n#else\n      ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n      break;\n#endif\n    } else if (cinfo->data_precision == 12)\n      return j12init_read_ppm(cinfo);\n    else\n      return jinit_read_ppm(cinfo);\n#endif\n#ifdef PNG_SUPPORTED\n  case 0x89:\n    copy_markers = TRUE;\n    return jinit_read_png(cinfo);\n#endif\n#ifdef TARGA_SUPPORTED\n  case 0x00:\n    return jinit_read_targa(cinfo);\n#endif\n  case 0xff:\n    is_jpeg = TRUE;\n    copy_markers = TRUE;\n    return jinit_read_jpeg(cinfo);\n  default:\n    ERREXIT(cinfo, JERR_UNKNOWN_FORMAT);\n    break;\n  }\n\n  return NULL;                  /* suppress compiler warnings */\n}\n\n\n/*\n * Argument-parsing code.\n * The switch parser is designed to be useful with DOS-style command line\n * syntax, ie, intermixed switches and file names, where only the switches\n * to the left of a given file name affect processing of that file.\n * The main program in this file doesn't actually use this capability...\n */\n\n\nstatic const char *progname;    /* program name for error messages */\nstatic char *icc_filename;      /* for -icc switch */\nstatic char *outfilename;       /* for -outfile switch */\nstatic boolean memdst;          /* for -memdst switch */\nstatic boolean report;          /* for -report switch */\nstatic boolean strict;          /* for -strict switch */\n\n\n#ifdef CJPEG_FUZZER\n\n#include <setjmp.h>\n\nstruct my_error_mgr {\n  struct jpeg_error_mgr pub;\n  jmp_buf setjmp_buffer;\n};\n\nvoid my_error_exit(j_common_ptr cinfo)\n{\n  struct my_error_mgr *myerr = (struct my_error_mgr *)cinfo->err;\n\n  longjmp(myerr->setjmp_buffer, 1);\n}\n\nstatic void my_emit_message_fuzzer(j_common_ptr cinfo, int msg_level)\n{\n  if (msg_level < 0)\n    cinfo->err->num_warnings++;\n}\n\n#define HANDLE_ERROR() { \\\n  if (cinfo.global_state > CSTATE_START) { \\\n    if (memdst && outbuffer) \\\n      (*cinfo.dest->term_destination) (&cinfo); \\\n    jpeg_abort_compress(&cinfo); \\\n  } \\\n  jpeg_destroy_compress(&cinfo); \\\n  if (input_file != stdin && input_file != NULL) \\\n    fclose(input_file); \\\n  if (memdst) \\\n    free(outbuffer); \\\n  return EXIT_FAILURE; \\\n}\n\n#endif\n\n\nLOCAL(void)\nusage(void)\n/* complain about bad command line */\n{\n  fprintf(stderr, \"usage: %s [switches] \", progname);\n#ifdef TWO_FILE_COMMANDLINE\n  fprintf(stderr, \"inputfile outputfile\\n\");\n#else\n  fprintf(stderr, \"[inputfile]\\n\");\n#endif\n\n  fprintf(stderr, \"Switches (names may be abbreviated):\\n\");\n  fprintf(stderr, \"  -quality N[,...]   Compression quality (0..100; 5-95 is most useful range,\\n\");\n  fprintf(stderr, \"                     default is 75)\\n\");\n  fprintf(stderr, \"  -grayscale     Create monochrome JPEG file\\n\");\n  fprintf(stderr, \"  -rgb           Create RGB JPEG file\\n\");\n#ifdef ENTROPY_OPT_SUPPORTED\n  fprintf(stderr, \"  -optimize      Optimize Huffman table (smaller file, but slow compression)\\n\");\n#endif\n#ifdef C_PROGRESSIVE_SUPPORTED\n  fprintf(stderr, \"  -progressive   Create progressive JPEG file\\n\");\n#endif\n  fprintf(stderr, \"  -baseline      Create baseline JPEG file (disable progressive coding)\\n\");\n#ifdef TARGA_SUPPORTED\n  fprintf(stderr, \"  -targa         Input file is Targa format (usually not needed)\\n\");\n#endif\n  fprintf(stderr, \"  -revert        Revert to standard defaults (instead of mozjpeg defaults)\\n\");\n  fprintf(stderr, \"  -fastcrush     Disable progressive scan optimization\\n\");\n  fprintf(stderr, \"  -dc-scan-opt   DC scan optimization mode\\n\");\n  fprintf(stderr, \"                 - 0 One scan for all components\\n\");\n  fprintf(stderr, \"                 - 1 One scan per component (default)\\n\");\n  fprintf(stderr, \"                 - 2 Optimize between one scan for all components and one scan for 1st component\\n\");\n  fprintf(stderr, \"                     plus one scan for remaining components\\n\");\n  fprintf(stderr, \"  -notrellis     Disable trellis optimization\\n\");\n  fprintf(stderr, \"  -trellis-dc    Enable trellis optimization of DC coefficients (default)\\n\");\n  fprintf(stderr, \"  -notrellis-dc  Disable trellis optimization of DC coefficients\\n\");\n  fprintf(stderr, \"  -tune-psnr     Tune trellis optimization for PSNR\\n\");\n  fprintf(stderr, \"  -tune-hvs-psnr Tune trellis optimization for PSNR-HVS (default)\\n\");\n  fprintf(stderr, \"  -tune-ssim     Tune trellis optimization for SSIM\\n\");\n  fprintf(stderr, \"  -tune-ms-ssim  Tune trellis optimization for MS-SSIM\\n\");\n  fprintf(stderr, \"Switches for advanced users:\\n\");\n  fprintf(stderr, \"  -noovershoot   Disable black-on-white deringing via overshoot\\n\");\n  fprintf(stderr, \"  -nojfif        Do not write JFIF (reduces size by 18 bytes but breaks standards; no known problems in Web browsers)\\n\");\n  fprintf(stderr, \"  -precision N   Create JPEG file with N-bit data precision\\n\");\n#ifdef C_LOSSLESS_SUPPORTED\n  fprintf(stderr, \"                 (N is 8, 12, or 16; default is 8; if N is 16, then -lossless\\n\");\n  fprintf(stderr, \"                 must also be specified)\\n\");\n#else\n  fprintf(stderr, \"                 (N is 8 or 12; default is 8)\\n\");\n#endif\n#ifdef C_LOSSLESS_SUPPORTED\n  fprintf(stderr, \"  -lossless psv[,Pt]  Create lossless JPEG file\\n\");\n#endif\n#ifdef C_ARITH_CODING_SUPPORTED\n  fprintf(stderr, \"  -arithmetic    Use arithmetic coding\\n\");\n#endif\n#ifdef DCT_ISLOW_SUPPORTED\n  fprintf(stderr, \"  -dct int       Use accurate integer DCT method%s\\n\",\n          (JDCT_DEFAULT == JDCT_ISLOW ? \" (default)\" : \"\"));\n#endif\n#ifdef DCT_IFAST_SUPPORTED\n  fprintf(stderr, \"  -dct fast      Use less accurate integer DCT method [legacy feature]%s\\n\",\n          (JDCT_DEFAULT == JDCT_IFAST ? \" (default)\" : \"\"));\n#endif\n#ifdef DCT_FLOAT_SUPPORTED\n  fprintf(stderr, \"  -dct float     Use floating-point DCT method [legacy feature]%s\\n\",\n          (JDCT_DEFAULT == JDCT_FLOAT ? \" (default)\" : \"\"));\n#endif\n  fprintf(stderr, \"  -quant-baseline Use 8-bit quantization table entries for baseline JPEG compatibility\\n\");\n  fprintf(stderr, \"  -quant-table N Use predefined quantization table N:\\n\");\n  fprintf(stderr, \"                 - 0 JPEG Annex K\\n\");\n  fprintf(stderr, \"                 - 1 Flat\\n\");\n  fprintf(stderr, \"                 - 2 Tuned for MS-SSIM on Kodak image set\\n\");\n  fprintf(stderr, \"                 - 3 ImageMagick table by N. Robidoux (default)\\n\");\n  fprintf(stderr, \"                 - 4 Tuned for PSNR-HVS on Kodak image set\\n\");\n  fprintf(stderr, \"                 - 5 Table from paper by Klein, Silverstein and Carney\\n\");\n  fprintf(stderr, \"                 - 6 Table from paper by Watson, Taylor and Borthwick\\n\");\n  fprintf(stderr, \"                 - 7 Table from paper by Ahumada, Watson, Peterson\\n\");\n  fprintf(stderr, \"                 - 8 Table from paper by Peterson, Ahumada and Watson\\n\");\n  fprintf(stderr, \"  -icc FILE      Embed ICC profile contained in FILE\\n\");\n  fprintf(stderr, \"  -restart N     Set restart interval in rows, or in blocks with B\\n\");\n#ifdef INPUT_SMOOTHING_SUPPORTED\n  fprintf(stderr, \"  -smooth N      Smooth dithered input (N=1..100 is strength)\\n\");\n#endif\n  fprintf(stderr, \"  -maxmemory N   Maximum memory to use (in kbytes)\\n\");\n  fprintf(stderr, \"  -outfile name  Specify name for output file\\n\");\n  fprintf(stderr, \"  -memdst        Compress to memory instead of file (useful for benchmarking)\\n\");\n  fprintf(stderr, \"  -report        Report compression progress\\n\");\n  fprintf(stderr, \"  -strict        Treat all warnings as fatal\\n\");\n  fprintf(stderr, \"  -verbose  or  -debug   Emit debug output\\n\");\n  fprintf(stderr, \"  -version       Print version information and exit\\n\");\n  fprintf(stderr, \"Switches for wizards:\\n\");\n  fprintf(stderr, \"  -qtables FILE  Use quantization tables given in FILE\\n\");\n  fprintf(stderr, \"  -qslots N[,...]    Set component quantization tables\\n\");\n  fprintf(stderr, \"  -sample HxV[,...]  Set component sampling factors\\n\");\n#ifdef C_MULTISCAN_FILES_SUPPORTED\n  fprintf(stderr, \"  -scans FILE    Create multi-scan JPEG per script FILE\\n\");\n#endif\n  exit(EXIT_FAILURE);\n}\n\n\nLOCAL(int)\nparse_switches(j_compress_ptr cinfo, int argc, char **argv,\n               int last_file_arg_seen, boolean for_real)\n/* Parse optional switches.\n * Returns argv[] index of first file-name argument (== argc if none).\n * Any file names with indexes <= last_file_arg_seen are ignored;\n * they have presumably been processed in a previous iteration.\n * (Pass 0 for last_file_arg_seen on the first or only iteration.)\n * for_real is FALSE on the first (dummy) pass; we may skip any expensive\n * processing.\n */\n{\n  int argn;\n  char *arg;\n#ifdef C_LOSSLESS_SUPPORTED\n  int psv = 0, pt = 0;\n#endif\n  boolean force_baseline;\n  boolean simple_progressive;\n  char *qualityarg = NULL;      /* saves -quality parm if any */\n  char *qtablefile = NULL;      /* saves -qtables filename if any */\n  char *qslotsarg = NULL;       /* saves -qslots parm if any */\n  char *samplearg = NULL;       /* saves -sample parm if any */\n  char *scansarg = NULL;        /* saves -scans parm if any */\n\n  /* Set up default JPEG parameters. */\n\n  force_baseline = FALSE;       /* by default, allow 16-bit quantizers */\n#ifdef C_PROGRESSIVE_SUPPORTED\n  simple_progressive = cinfo->num_scans == 0 ? FALSE : TRUE;\n#else\n  simple_progressive = FALSE;\n#endif\n  is_targa = FALSE;\n  icc_filename = NULL;\n  outfilename = NULL;\n  memdst = FALSE;\n  report = FALSE;\n  strict = FALSE;\n  cinfo->err->trace_level = 0;\n\n  /* Scan command line options, adjust parameters */\n\n  for (argn = 1; argn < argc; argn++) {\n    arg = argv[argn];\n    if (*arg != '-') {\n      /* Not a switch, must be a file name argument */\n      if (argn <= last_file_arg_seen) {\n        outfilename = NULL;     /* -outfile applies to just one input file */\n        continue;               /* ignore this name if previously processed */\n      }\n      break;                    /* else done parsing switches */\n    }\n    arg++;                      /* advance past switch marker character */\n\n    if (keymatch(arg, \"arithmetic\", 1)) {\n      /* Use arithmetic coding. */\n#ifdef C_ARITH_CODING_SUPPORTED\n      cinfo->arith_code = TRUE;\n      \n      /* No table optimization required for AC */\n      cinfo->optimize_coding = FALSE;\n#else\n      fprintf(stderr, \"%s: sorry, arithmetic coding not supported\\n\",\n              progname);\n      exit(EXIT_FAILURE);\n#endif\n\n    } else if (keymatch(arg, \"baseline\", 1)) {\n      /* Force baseline-compatible output (8-bit quantizer values). */\n      force_baseline = TRUE;\n      /* Disable multiple scans */\n      simple_progressive = FALSE;\n      cinfo->num_scans = 0;\n      cinfo->scan_info = NULL;\n\n    } else if (keymatch(arg, \"dct\", 2)) {\n      /* Select DCT algorithm. */\n      if (++argn >= argc) {      /* advance to next argument */\n        fprintf(stderr, \"%s: missing argument for dct\\n\", progname);\n        usage();\n      }\n      if (keymatch(argv[argn], \"int\", 1)) {\n        cinfo->dct_method = JDCT_ISLOW;\n      } else if (keymatch(argv[argn], \"fast\", 2)) {\n        cinfo->dct_method = JDCT_IFAST;\n      } else if (keymatch(argv[argn], \"float\", 2)) {\n        cinfo->dct_method = JDCT_FLOAT;\n      } else {\n        fprintf(stderr, \"%s: invalid argument for dct\\n\", progname);\n        usage();\n      }\n\n    } else if (keymatch(arg, \"debug\", 1) || keymatch(arg, \"verbose\", 1)) {\n      /* Enable debug printouts. */\n      /* On first -d, print version identification */\n      static boolean printed_version = FALSE;\n\n      if (!printed_version) {\n        fprintf(stderr, \"%s version %s (build %s)\\n\",\n                PACKAGE_NAME, VERSION, BUILD);\n        fprintf(stderr, JCOPYRIGHT1);\n        fprintf(stderr, JCOPYRIGHT2 \"\\n\");\n        fprintf(stderr, \"Emulating The Independent JPEG Group's software, version %s\\n\\n\",\n                JVERSION);\n        printed_version = TRUE;\n      }\n      cinfo->err->trace_level++;\n\n    } else if (keymatch(arg, \"version\", 4)) {\n      fprintf(stderr, \"%s version %s (build %s)\\n\",\n              PACKAGE_NAME, VERSION, BUILD);\n      exit(EXIT_SUCCESS);\n\n    } else if (keymatch(arg, \"fastcrush\", 4)) {\n      jpeg_c_set_bool_param(cinfo, JBOOLEAN_OPTIMIZE_SCANS, FALSE);\n\n    } else if (keymatch(arg, \"grayscale\", 2) || keymatch(arg, \"greyscale\",2)) {\n      /* Force a monochrome JPEG file to be generated. */\n      jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);\n\n    } else if (keymatch(arg, \"rgb\", 3)) {\n      /* Force an RGB JPEG file to be generated. */\n      jpeg_set_colorspace(cinfo, JCS_RGB);\n\n    } else if (keymatch(arg, \"lambda1\", 7)) {\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      jpeg_c_set_float_param(cinfo, JFLOAT_LAMBDA_LOG_SCALE1,\n                             atof(argv[argn]));\n\n    } else if (keymatch(arg, \"lambda2\", 7)) {\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      jpeg_c_set_float_param(cinfo, JFLOAT_LAMBDA_LOG_SCALE2,\n                             atof(argv[argn]));\n\n    } else if (keymatch(arg, \"icc\", 1)) {\n      /* Set ICC filename. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      icc_filename = argv[argn];\n\n    } else if (keymatch(arg, \"lossless\", 1)) {\n      /* Enable lossless mode. */\n#ifdef C_LOSSLESS_SUPPORTED\n      char ch = ',', *ptr;\n\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%d%c\", &psv, &ch) < 1 || ch != ',')\n        usage();\n      ptr = argv[argn];\n      while (*ptr && *ptr++ != ','); /* advance to next segment of arg\n                                        string */\n      if (*ptr)\n        sscanf(ptr, \"%d\", &pt);\n\n      /* We must postpone execution until data_precision is known. */\n#else\n      fprintf(stderr, \"%s: sorry, lossless output was not compiled\\n\",\n              progname);\n      exit(EXIT_FAILURE);\n#endif\n\n    } else if (keymatch(arg, \"maxmemory\", 3)) {\n      /* Maximum memory in Kb (or Mb with 'm'). */\n      long lval;\n      char ch = 'x';\n\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%ld%c\", &lval, &ch) < 1)\n        usage();\n      if (ch == 'm' || ch == 'M')\n        lval *= 1000L;\n      cinfo->mem->max_memory_to_use = lval * 1000L;\n\n    } else if (keymatch(arg, \"dc-scan-opt\", 3)) {\n      if (++argn >= argc) {      /* advance to next argument */\n        fprintf(stderr, \"%s: missing argument for dc-scan-opt\\n\", progname);\n        usage();\n      }\n      jpeg_c_set_int_param(cinfo, JINT_DC_SCAN_OPT_MODE, atoi(argv[argn]));\n\n    } else if (keymatch(arg, \"optimize\", 1) || keymatch(arg, \"optimise\", 1)) {\n      /* Enable entropy parm optimization. */\n#ifdef ENTROPY_OPT_SUPPORTED\n      cinfo->optimize_coding = TRUE;\n#else\n      fprintf(stderr, \"%s: sorry, entropy optimization was not compiled in\\n\",\n              progname);\n      exit(EXIT_FAILURE);\n#endif\n\n    } else if (keymatch(arg, \"outfile\", 4)) {\n      /* Set output file name. */\n      if (++argn >= argc) {      /* advance to next argument */\n        fprintf(stderr, \"%s: missing argument for outfile\\n\", progname);\n        usage();\n      }\n      outfilename = argv[argn]; /* save it away for later use */\n\n    } else if (keymatch(arg, \"precision\", 3)) {\n      /* Set data precision. */\n      int val;\n\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%d\", &val) != 1)\n        usage();\n#ifdef C_LOSSLESS_SUPPORTED\n      if (val != 8 && val != 12 && val != 16)\n#else\n      if (val != 8 && val != 12)\n#endif\n        usage();\n      cinfo->data_precision = val;\n\n    } else if (keymatch(arg, \"progressive\", 1)) {\n      /* Select simple progressive mode. */\n#ifdef C_PROGRESSIVE_SUPPORTED\n      simple_progressive = TRUE;\n      /* We must postpone execution until num_components is known. */\n#else\n      fprintf(stderr, \"%s: sorry, progressive output was not compiled in\\n\",\n              progname);\n      exit(EXIT_FAILURE);\n#endif\n\n    } else if (keymatch(arg, \"memdst\", 2)) {\n      /* Use in-memory destination manager */\n      memdst = TRUE;\n\n    } else if (keymatch(arg, \"quality\", 1)) {\n      /* Quality ratings (quantization table scaling factors). */\n      if (++argn >= argc) {      /* advance to next argument */\n        fprintf(stderr, \"%s: missing argument for quality\\n\", progname);\n        usage();\n      }\n      qualityarg = argv[argn];\n\n    } else if (keymatch(arg, \"qslots\", 2)) {\n      /* Quantization table slot numbers. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      qslotsarg = argv[argn];\n      /* Must delay setting qslots until after we have processed any\n       * colorspace-determining switches, since jpeg_set_colorspace sets\n       * default quant table numbers.\n       */\n\n    } else if (keymatch(arg, \"qtables\", 2)) {\n      /* Quantization tables fetched from file. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      qtablefile = argv[argn];\n      /* We postpone actually reading the file in case -quality comes later. */\n\n    } else if (keymatch(arg, \"report\", 3)) {\n      report = TRUE;\n    } else if (keymatch(arg, \"quant-table\", 7)) {\n      int val;\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      val = atoi(argv[argn]);\n      jpeg_c_set_int_param(cinfo, JINT_BASE_QUANT_TBL_IDX, val);\n      if (jpeg_c_get_int_param(cinfo, JINT_BASE_QUANT_TBL_IDX) != val) {\n        fprintf(stderr, \"%s: %d is invalid argument for quant-table\\n\", progname, val);\n        usage();\n      }\n      jpeg_set_quality(cinfo, 75, TRUE);\n\n    } else if (keymatch(arg, \"quant-baseline\", 7)) {\n      /* Force quantization table to meet baseline requirements */\n      force_baseline = TRUE;\n\n    } else if (keymatch(arg, \"restart\", 1)) {\n      /* Restart interval in MCU rows (or in MCUs with 'b'). */\n      long lval;\n      char ch = 'x';\n\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%ld%c\", &lval, &ch) < 1)\n        usage();\n      if (lval < 0 || lval > 65535L)\n        usage();\n      if (ch == 'b' || ch == 'B') {\n        cinfo->restart_interval = (unsigned int)lval;\n        cinfo->restart_in_rows = 0; /* else prior '-restart n' overrides me */\n      } else {\n        cinfo->restart_in_rows = (int)lval;\n        /* restart_interval will be computed during startup */\n      }\n\n    } else if (keymatch(arg, \"revert\", 3)) {\n      /* revert to old JPEG default */\n      jpeg_c_set_int_param(cinfo, JINT_COMPRESS_PROFILE, JCP_FASTEST);\n      jpeg_set_defaults(cinfo);\n\n    } else if (keymatch(arg, \"sample\", 2)) {\n      /* Set sampling factors. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      samplearg = argv[argn];\n      /* Must delay setting sample factors until after we have processed any\n       * colorspace-determining switches, since jpeg_set_colorspace sets\n       * default sampling factors.\n       */\n\n    } else if (keymatch(arg, \"scans\", 2)) {\n      /* Set scan script. */\n#ifdef C_MULTISCAN_FILES_SUPPORTED\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      scansarg = argv[argn];\n      /* We must postpone reading the file in case -progressive appears. */\n#else\n      fprintf(stderr, \"%s: sorry, multi-scan output was not compiled in\\n\",\n              progname);\n      exit(EXIT_FAILURE);\n#endif\n\n    } else if (keymatch(arg, \"smooth\", 2)) {\n      /* Set input smoothing factor. */\n      int val;\n\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%d\", &val) != 1)\n        usage();\n      if (val < 0 || val > 100)\n        usage();\n      cinfo->smoothing_factor = val;\n\n    } else if (keymatch(arg, \"strict\", 2)) {\n      strict = TRUE;\n\n    } else if (keymatch(arg, \"targa\", 1)) {\n      /* Input file is Targa format. */\n      is_targa = TRUE;\n\n    } else if (keymatch(arg, \"notrellis-dc\", 11)) {\n      /* disable trellis quantization */\n      jpeg_c_set_bool_param(cinfo, JBOOLEAN_TRELLIS_QUANT_DC, FALSE);\n      \n    } else if (keymatch(arg, \"notrellis\", 1)) {\n      /* disable trellis quantization */\n      jpeg_c_set_bool_param(cinfo, JBOOLEAN_TRELLIS_QUANT, FALSE);\n      \n    } else if (keymatch(arg, \"trellis-dc-ver-weight\", 12)) {\n      if (++argn >= argc) {      /* advance to next argument */\n        fprintf(stderr, \"%s: missing argument for trellis-dc-ver-weight\\n\", progname);\n        usage();\n      }\n      jpeg_c_set_float_param(cinfo, JFLOAT_TRELLIS_DELTA_DC_WEIGHT, atof(argv[argn]));\n      \n    } else if (keymatch(arg, \"trellis-dc\", 9)) {\n      /* enable DC trellis quantization */\n      jpeg_c_set_bool_param(cinfo, JBOOLEAN_TRELLIS_QUANT_DC, TRUE);\n      \n    } else if (keymatch(arg, \"tune-psnr\", 6)) {\n      jpeg_c_set_int_param(cinfo, JINT_BASE_QUANT_TBL_IDX, 1);\n      jpeg_c_set_float_param(cinfo, JFLOAT_LAMBDA_LOG_SCALE1, 9.0);\n      jpeg_c_set_float_param(cinfo, JFLOAT_LAMBDA_LOG_SCALE2, 0.0);\n      jpeg_c_set_bool_param(cinfo, JBOOLEAN_USE_LAMBDA_WEIGHT_TBL, FALSE);\n      jpeg_set_quality(cinfo, 75, TRUE);\n      \n    } else if (keymatch(arg, \"tune-ssim\", 6)) {\n      jpeg_c_set_int_param(cinfo, JINT_BASE_QUANT_TBL_IDX, 1);\n      jpeg_c_set_float_param(cinfo, JFLOAT_LAMBDA_LOG_SCALE1, 11.5);\n      jpeg_c_set_float_param(cinfo, JFLOAT_LAMBDA_LOG_SCALE2, 12.75);\n      jpeg_c_set_bool_param(cinfo, JBOOLEAN_USE_LAMBDA_WEIGHT_TBL, FALSE);\n      jpeg_set_quality(cinfo, 75, TRUE);\n      \n    } else if (keymatch(arg, \"tune-ms-ssim\", 6)) {\n      jpeg_c_set_int_param(cinfo, JINT_BASE_QUANT_TBL_IDX, 3);\n      jpeg_c_set_float_param(cinfo, JFLOAT_LAMBDA_LOG_SCALE1, 12.0);\n      jpeg_c_set_float_param(cinfo, JFLOAT_LAMBDA_LOG_SCALE2, 13.0);\n      jpeg_c_set_bool_param(cinfo, JBOOLEAN_USE_LAMBDA_WEIGHT_TBL, TRUE);\n      jpeg_set_quality(cinfo, 75, TRUE);\n      \n    } else if (keymatch(arg, \"tune-hvs-psnr\", 6)) {\n      jpeg_c_set_int_param(cinfo, JINT_BASE_QUANT_TBL_IDX, 3);\n      jpeg_c_set_float_param(cinfo, JFLOAT_LAMBDA_LOG_SCALE1, 14.75);\n      jpeg_c_set_float_param(cinfo, JFLOAT_LAMBDA_LOG_SCALE2, 16.5);\n      jpeg_c_set_bool_param(cinfo, JBOOLEAN_USE_LAMBDA_WEIGHT_TBL, TRUE);\n      jpeg_set_quality(cinfo, 75, TRUE);\n\n    } else if (keymatch(arg, \"noovershoot\", 11)) {\n      jpeg_c_set_bool_param(cinfo, JBOOLEAN_OVERSHOOT_DERINGING, FALSE);\n\n\t} else if (keymatch(arg, \"nojfif\", 6)) {\n      cinfo->write_JFIF_header = 0;\n    } else {\n      fprintf(stderr, \"%s: unknown option '%s'\\n\", progname, arg);\n      usage();                  /* bogus switch */\n    }\n  }\n\n  /* Post-switch-scanning cleanup */\n\n  if (for_real) {\n\n    /* Set quantization tables for selected quality. */\n    /* Some or all may be overridden if -qtables is present. */\n    if (qualityarg != NULL)     /* process -quality if it was present */\n      if (! set_quality_ratings(cinfo, qualityarg, force_baseline)) {\n        fprintf(stderr, \"%s: can't set quality ratings\\n\", progname);\n        usage();\n      }\n\n    if (qtablefile != NULL)     /* process -qtables if it was present */\n      if (! read_quant_tables(cinfo, qtablefile, force_baseline)) {\n        fprintf(stderr, \"%s: can't read qtable file\\n\", progname);\n        usage();\n      }\n\n    if (qslotsarg != NULL)      /* process -qslots if it was present */\n      if (!set_quant_slots(cinfo, qslotsarg))\n        usage();\n\n    /* set_quality_ratings sets default subsampling, so the explicit\n       subsampling must be set after it */\n    if (samplearg != NULL)      /* process -sample if it was present */\n      if (! set_sample_factors(cinfo, samplearg)) {\n        fprintf(stderr, \"%s: can't set sample factors\\n\", progname);\n        usage();\n      }\n\n#ifdef C_PROGRESSIVE_SUPPORTED\n    if (simple_progressive)     /* process -progressive; -scans can override */\n      jpeg_simple_progression(cinfo);\n#endif\n\n#ifdef C_LOSSLESS_SUPPORTED\n    if (psv != 0)               /* process -lossless */\n      jpeg_enable_lossless(cinfo, psv, pt);\n#endif\n\n#ifdef C_MULTISCAN_FILES_SUPPORTED\n    if (scansarg != NULL)       /* process -scans if it was present */\n      if (!read_scan_script(cinfo, scansarg))\n        usage();\n#endif\n  }\n\n  return argn;                  /* return index of next arg (file name) */\n}\n\n\nMETHODDEF(void)\nmy_emit_message(j_common_ptr cinfo, int msg_level)\n{\n  if (msg_level < 0) {\n    /* Treat warning as fatal */\n    cinfo->err->error_exit(cinfo);\n  } else {\n    if (cinfo->err->trace_level >= msg_level)\n      cinfo->err->output_message(cinfo);\n  }\n}\n\n\n/*\n * The main program.\n */\n\nint\nmain(int argc, char **argv)\n{\n  struct jpeg_compress_struct cinfo;\n#ifdef CJPEG_FUZZER\n  struct my_error_mgr myerr;\n  struct jpeg_error_mgr &jerr = myerr.pub;\n#else\n  struct jpeg_error_mgr jerr;\n#endif\n  struct cdjpeg_progress_mgr progress;\n  int file_index;\n  cjpeg_source_ptr src_mgr;\n  FILE *input_file = NULL;\n  FILE *icc_file;\n  JOCTET *icc_profile = NULL;\n  long icc_len = 0;\n  FILE *output_file = NULL;\n  unsigned char *outbuffer = NULL;\n  unsigned long outsize = 0;\n  JDIMENSION num_scanlines;\n\n  progname = argv[0];\n  if (progname == NULL || progname[0] == 0)\n    progname = \"cjpeg\";         /* in case C library doesn't provide it */\n\n  /* Initialize the JPEG compression object with default error handling. */\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_compress(&cinfo);\n  /* Add some application-specific error messages (from cderror.h) */\n  jerr.addon_message_table = cdjpeg_message_table;\n  jerr.first_addon_message = JMSG_FIRSTADDONCODE;\n  jerr.last_addon_message = JMSG_LASTADDONCODE;\n\n  /* Initialize JPEG parameters.\n   * Much of this may be overridden later.\n   * In particular, we don't yet know the input file's color space,\n   * but we need to provide some value for jpeg_set_defaults() to work.\n   */\n\n  cinfo.in_color_space = JCS_RGB; /* arbitrary guess */\n  jpeg_set_defaults(&cinfo);\n\n  /* Scan command line to find file names.\n   * It is convenient to use just one switch-parsing routine, but the switch\n   * values read here are ignored; we will rescan the switches after opening\n   * the input file.\n   */\n\n  file_index = parse_switches(&cinfo, argc, argv, 0, FALSE);\n\n  if (strict)\n    jerr.emit_message = my_emit_message;\n\n#ifdef TWO_FILE_COMMANDLINE\n  if (!memdst) {\n    /* Must have either -outfile switch or explicit output file name */\n    if (outfilename == NULL) {\n      if (file_index != argc - 2) {\n        fprintf(stderr, \"%s: must name one input and one output file\\n\",\n                progname);\n        usage();\n      }\n      outfilename = argv[file_index + 1];\n    } else {\n      if (file_index != argc - 1) {\n        fprintf(stderr, \"%s: must name one input and one output file\\n\",\n                progname);\n        usage();\n      }\n    }\n  }\n#else\n  /* Unix style: expect zero or one file name */\n  if (file_index < argc - 1) {\n    fprintf(stderr, \"%s: only one input file\\n\", progname);\n    usage();\n  }\n#endif /* TWO_FILE_COMMANDLINE */\n\n  /* Open the input file. */\n  if (file_index < argc) {\n    if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, argv[file_index]);\n      exit(EXIT_FAILURE);\n    }\n  } else {\n    /* default input file is stdin */\n    input_file = read_stdin();\n  }\n\n  /* Open the output file. */\n  if (outfilename != NULL) {\n    if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, outfilename);\n      exit(EXIT_FAILURE);\n    }\n  } else if (!memdst) {\n    /* default output file is stdout */\n    output_file = write_stdout();\n  }\n\n  if (icc_filename != NULL) {\n    if ((icc_file = fopen(icc_filename, READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, icc_filename);\n      exit(EXIT_FAILURE);\n    }\n    if (fseek(icc_file, 0, SEEK_END) < 0 ||\n        (icc_len = ftell(icc_file)) < 1 ||\n        fseek(icc_file, 0, SEEK_SET) < 0) {\n      fprintf(stderr, \"%s: can't determine size of %s\\n\", progname,\n              icc_filename);\n      exit(EXIT_FAILURE);\n    }\n    if ((icc_profile = (JOCTET *)malloc(icc_len)) == NULL) {\n      fprintf(stderr, \"%s: can't allocate memory for ICC profile\\n\", progname);\n      fclose(icc_file);\n      exit(EXIT_FAILURE);\n    }\n    if (fread(icc_profile, icc_len, 1, icc_file) < 1) {\n      fprintf(stderr, \"%s: can't read ICC profile from %s\\n\", progname,\n              icc_filename);\n      free(icc_profile);\n      fclose(icc_file);\n      exit(EXIT_FAILURE);\n    }\n    fclose(icc_file);\n  }\n\n#ifdef CJPEG_FUZZER\n  jerr.error_exit = my_error_exit;\n  jerr.emit_message = my_emit_message_fuzzer;\n  if (setjmp(myerr.setjmp_buffer))\n    HANDLE_ERROR()\n#endif\n\n  if (report) {\n    start_progress_monitor((j_common_ptr)&cinfo, &progress);\n    progress.report = report;\n  }\n\n  /* Figure out the input file format, and set up to read it. */\n  src_mgr = select_file_type(&cinfo, input_file);\n  src_mgr->input_file = input_file;\n#ifdef CJPEG_FUZZER\n  src_mgr->max_pixels = 1048576;\n#endif\n\n  /* Read the input file header to obtain file size & colorspace. */\n  (*src_mgr->start_input) (&cinfo, src_mgr);\n\n  /* Now that we know input colorspace, fix colorspace-dependent defaults */\n#if JPEG_RAW_READER\n  if (!is_jpeg)\n#endif\n  jpeg_default_colorspace(&cinfo);\n\n  /* Adjust default compression parameters by re-parsing the options */\n  file_index = parse_switches(&cinfo, argc, argv, 0, TRUE);\n\n  /* Specify data destination for compression */\n  if (memdst)\n    jpeg_mem_dest(&cinfo, &outbuffer, &outsize);\n  else\n    jpeg_stdio_dest(&cinfo, output_file);\n\n#ifdef CJPEG_FUZZER\n  if (setjmp(myerr.setjmp_buffer))\n    HANDLE_ERROR()\n#endif\n\n  /* Start compressor */\n  jpeg_start_compress(&cinfo, TRUE);\n\n  /* Copy metadata */\n  if (copy_markers) {\n    jpeg_saved_marker_ptr marker;\n    \n    /* In the current implementation, we don't actually need to examine the\n     * option flag here; we just copy everything that got saved.\n     * But to avoid confusion, we do not output JFIF and Adobe APP14 markers\n     * if the encoder library already wrote one.\n     */\n    for (marker = src_mgr->marker_list; marker != NULL; marker = marker->next) {\n      if (cinfo.write_JFIF_header &&\n          marker->marker == JPEG_APP0 &&\n          marker->data_length >= 5 &&\n          GETJOCTET(marker->data[0]) == 0x4A &&\n          GETJOCTET(marker->data[1]) == 0x46 &&\n          GETJOCTET(marker->data[2]) == 0x49 &&\n          GETJOCTET(marker->data[3]) == 0x46 &&\n          GETJOCTET(marker->data[4]) == 0)\n        continue;                       /* reject duplicate JFIF */\n      if (cinfo.write_Adobe_marker &&\n          marker->marker == JPEG_APP0+14 &&\n          marker->data_length >= 5 &&\n          GETJOCTET(marker->data[0]) == 0x41 &&\n          GETJOCTET(marker->data[1]) == 0x64 &&\n          GETJOCTET(marker->data[2]) == 0x6F &&\n          GETJOCTET(marker->data[3]) == 0x62 &&\n          GETJOCTET(marker->data[4]) == 0x65)\n        continue;                       /* reject duplicate Adobe */\n      jpeg_write_marker(&cinfo, marker->marker, marker->data,\n                        marker->data_length);\n    }\n  }\n  if (icc_profile != NULL)\n    jpeg_write_icc_profile(&cinfo, icc_profile, (unsigned int)icc_len);\n\n  /* Process data */\n  if (cinfo.data_precision == 16) {\n#ifdef C_LOSSLESS_SUPPORTED\n    while (cinfo.next_scanline < cinfo.image_height) {\n      num_scanlines = (*src_mgr->get_pixel_rows) (&cinfo, src_mgr);\n      (void)jpeg16_write_scanlines(&cinfo, src_mgr->buffer16, num_scanlines);\n    }\n#else\n    ERREXIT1(&cinfo, JERR_BAD_PRECISION, cinfo.data_precision);\n#endif\n  } else if (cinfo.data_precision == 12) {\n    while (cinfo.next_scanline < cinfo.image_height) {\n      num_scanlines = (*src_mgr->get_pixel_rows) (&cinfo, src_mgr);\n      (void)jpeg12_write_scanlines(&cinfo, src_mgr->buffer12, num_scanlines);\n    }\n  } else {\n  while (cinfo.next_scanline < cinfo.image_height) {\n    num_scanlines = (*src_mgr->get_pixel_rows) (&cinfo, src_mgr);\n#if JPEG_RAW_READER\n    if (is_jpeg)\n      (void) jpeg_write_raw_data(&cinfo, src_mgr->plane_pointer, num_scanlines);\n    else\n#endif\n      (void)jpeg_write_scanlines(&cinfo, src_mgr->buffer, num_scanlines);\n    }\n  }\n\n  /* Finish compression and release memory */\n  (*src_mgr->finish_input) (&cinfo, src_mgr);\n  jpeg_finish_compress(&cinfo);\n  jpeg_destroy_compress(&cinfo);\n\n  /* Close files, if we opened them */\n  if (input_file != stdin)\n    fclose(input_file);\n  if (output_file != stdout && output_file != NULL)\n    fclose(output_file);\n\n  if (report)\n    end_progress_monitor((j_common_ptr)&cinfo);\n\n  if (memdst) {\n#ifndef CJPEG_FUZZER\n    fprintf(stderr, \"Compressed size:  %lu bytes\\n\", outsize);\n#endif\n    free(outbuffer);\n  }\n\n  free(icc_profile);\n\n  /* All done. */\n  return (jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);\n}\n"
        },
        {
          "name": "cmakescripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmyk.h",
          "type": "blob",
          "size": 1.779296875,
          "content": "/*\n * cmyk.h\n *\n * Copyright (C) 2017-2018, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains convenience functions for performing quick & dirty\n * CMYK<->RGB conversion.  This algorithm is suitable for testing purposes\n * only.  Properly converting between CMYK and RGB requires a color management\n * system.\n */\n\n#ifndef CMYK_H\n#define CMYK_H\n\n#include <jinclude.h>\n#define JPEG_INTERNALS\n#include <jpeglib.h>\n#include \"jsamplecomp.h\"\n\n\n/* Fully reversible */\n\nINLINE\nLOCAL(void)\nrgb_to_cmyk(_JSAMPLE r, _JSAMPLE g, _JSAMPLE b,\n            _JSAMPLE *c, _JSAMPLE *m, _JSAMPLE *y, _JSAMPLE *k)\n{\n  double ctmp = 1.0 - ((double)r / (double)_MAXJSAMPLE);\n  double mtmp = 1.0 - ((double)g / (double)_MAXJSAMPLE);\n  double ytmp = 1.0 - ((double)b / (double)_MAXJSAMPLE);\n  double ktmp = MIN(MIN(ctmp, mtmp), ytmp);\n\n  if (ktmp == 1.0) ctmp = mtmp = ytmp = 0.0;\n  else {\n    ctmp = (ctmp - ktmp) / (1.0 - ktmp);\n    mtmp = (mtmp - ktmp) / (1.0 - ktmp);\n    ytmp = (ytmp - ktmp) / (1.0 - ktmp);\n  }\n  *c = (_JSAMPLE)((double)_MAXJSAMPLE - ctmp * (double)_MAXJSAMPLE + 0.5);\n  *m = (_JSAMPLE)((double)_MAXJSAMPLE - mtmp * (double)_MAXJSAMPLE + 0.5);\n  *y = (_JSAMPLE)((double)_MAXJSAMPLE - ytmp * (double)_MAXJSAMPLE + 0.5);\n  *k = (_JSAMPLE)((double)_MAXJSAMPLE - ktmp * (double)_MAXJSAMPLE + 0.5);\n}\n\n\n/* Fully reversible only for C/M/Y/K values generated with rgb_to_cmyk() */\n\nINLINE\nLOCAL(void)\ncmyk_to_rgb(_JSAMPLE c, _JSAMPLE m, _JSAMPLE y, _JSAMPLE k,\n            _JSAMPLE *r, _JSAMPLE *g, _JSAMPLE *b)\n{\n  *r = (_JSAMPLE)((double)c * (double)k / (double)_MAXJSAMPLE + 0.5);\n  *g = (_JSAMPLE)((double)m * (double)k / (double)_MAXJSAMPLE + 0.5);\n  *b = (_JSAMPLE)((double)y * (double)k / (double)_MAXJSAMPLE + 0.5);\n}\n\n\n#endif /* CMYK_H */\n"
        },
        {
          "name": "coderules.txt",
          "type": "blob",
          "size": 3.3857421875,
          "content": "IJG JPEG LIBRARY:  CODING RULES\n\nThis file was part of the Independent JPEG Group's software:\nCopyright (C) 1991-1996, Thomas G. Lane.\nIt was modified by The libjpeg-turbo Project to include only information\nrelevant to libjpeg-turbo.\nFor conditions of distribution and use, see the accompanying README.ijg file.\n\n\nSince numerous people will be contributing code and bug fixes, it's important\nto establish a common coding style.  The goal of using similar coding styles\nis much more important than the details of just what that style is.\n\nIn general we follow the recommendations of \"Recommended C Style and Coding\nStandards\" revision 6.1 (Cannon et al. as modified by Spencer, Keppel and\nBrader).  This document is available in the IJG FTP archive (see\njpeg/doc/cstyle.ms.tbl.Z, or cstyle.txt.Z for those without nroff/tbl).\n\nBlock comments should be laid out thusly:\n\n/*\n *  Block comments in this style.\n */\n\nWe indent statements in K&R style, e.g.,\n        if (test) {\n          then-part;\n        } else {\n          else-part;\n        }\nwith two spaces per indentation level.  (This indentation convention is\nhandled automatically by GNU Emacs and many other text editors.)\n\nMulti-word names should be written in lower case with underscores, e.g.,\nmulti_word_name (not multiWordName).  Preprocessor symbols and enum constants\nare similar but upper case (MULTI_WORD_NAME).  Names should be unique within\nthe first fifteen characters.\n\nNote that each function definition must begin with GLOBAL(type), LOCAL(type),\nor METHODDEF(type).  These macros expand to \"static type\" or just \"type\" as\nappropriate.  They provide a readable indication of the routine's usage and\ncan readily be changed for special needs.  (For instance, special linkage\nkeywords can be inserted for use in Windows DLLs.)\n\nA similar solution is used for external function declarations (see the EXTERN\nmacro.)\n\n\nThe JPEG library is intended to be used within larger programs.  Furthermore,\nwe want it to be reentrant so that it can be used by applications that process\nmultiple images concurrently.  The following rules support these requirements:\n\n1. Avoid direct use of file I/O, \"malloc\", error report printouts, etc;\npass these through the common routines provided.\n\n2. Minimize global namespace pollution.  Functions should be declared static\nwherever possible.  (Note that our method-based calling conventions help this\na lot: in many modules only the initialization function will ever need to be\ncalled directly, so only that function need be externally visible.)  All\nglobal function names should begin with \"jpeg_\".\n\n3. Don't use global variables; anything that must be used in another module\nshould be in the common data structures.\n\n4. Don't use static variables except for read-only constant tables.  Variables\nthat should be private to a module can be placed into private structures (see\nthe system architecture document, structure.txt).\n\n5. Source file names should begin with \"j\" for files that are part of the\nlibrary proper; source files that are not part of the library, such as cjpeg.c\nand djpeg.c, do not begin with \"j\".  Keep compression and decompression code in\nseparate source files --- some applications may want only one half of the\nlibrary.\n\nNote: these rules (particularly #4) are not followed religiously in the\nmodules that are used in cjpeg/djpeg but are not part of the JPEG library\nproper.  Those modules are not really intended to be used in other\napplications.\n"
        },
        {
          "name": "croptest.in",
          "type": "blob",
          "size": 2.4580078125,
          "content": "#!/bin/bash\n\nset -u\nset -e\ntrap onexit INT\ntrap onexit TERM\ntrap onexit EXIT\n\nonexit()\n{\n\tif [ -d $OUTDIR ]; then\n\t\trm -rf $OUTDIR\n\tfi\n}\n\nrunme()\n{\n\techo \\*\\*\\* $*\n\t$*\n}\n\nIMAGE=vgl_6548_0026a.bmp\nWIDTH=128\nHEIGHT=95\nIMGDIR=@CMAKE_CURRENT_SOURCE_DIR@/testimages\nOUTDIR=`mktemp -d /tmp/__croptest_output.XXXXXX`\nEXEDIR=@CMAKE_CURRENT_BINARY_DIR@\n\nif [ -d $OUTDIR ]; then\n\trm -rf $OUTDIR\nfi\nmkdir -p $OUTDIR\n\nexec >$EXEDIR/croptest.log\n\necho \"============================================================\"\necho \"$IMAGE ($WIDTH x $HEIGHT)\"\necho \"============================================================\"\necho\n\nfor PROGARG in \"\" -progressive; do\n\n\tcp $IMGDIR/$IMAGE $OUTDIR\n\tbasename=`basename $IMAGE .bmp`\n\techo \"------------------------------------------------------------\"\n\techo \"Generating test images\"\n\techo \"------------------------------------------------------------\"\n\techo\n\trunme $EXEDIR/cjpeg $PROGARG -grayscale -outfile $OUTDIR/${basename}_GRAY.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg $PROGARG -sample 2x2 -outfile $OUTDIR/${basename}_420.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg $PROGARG -sample 2x1 -outfile $OUTDIR/${basename}_422.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg $PROGARG -sample 1x2 -outfile $OUTDIR/${basename}_440.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg $PROGARG -sample 1x1 -outfile $OUTDIR/${basename}_444.jpg $IMGDIR/${basename}.bmp\n\techo\n\n\tfor NSARG in \"\" -nosmooth; do\n\n\t\tfor COLORSARG in \"\" \"-colors 256 -dither none -onepass\"; do\n\n\t\t\tfor Y in {0..16}; do\n\n\t\t\t\tfor H in {1..16}; do\n\n\t\t\t\t\tX=$(( (Y*16)%128 ))\n\t\t\t\t\tW=$(( WIDTH-X-7 ))\n\t\t\t\t\tif [ $Y -le 15 ]; then\n\t\t\t\t\t\tCROPSPEC=\"${W}x${H}+${X}+${Y}\"\n\t\t\t\t\telse\n\t\t\t\t\t\tY2=$(( HEIGHT-H ));\n\t\t\t\t\t\tCROPSPEC=\"${W}x${H}+${X}+${Y2}\"\n\t\t\t\t\tfi\n\n\t\t\t\t\techo \"------------------------------------------------------------\"\n\t\t\t\t\techo $PROGARG $NSARG $COLORSARG -crop $CROPSPEC\n\t\t\t\t\techo \"------------------------------------------------------------\"\n\t\t\t\t\techo\n\t\t\t\t\tfor samp in GRAY 420 422 440 444; do\n\t\t\t\t\t\t$EXEDIR/djpeg $NSARG $COLORSARG -rgb -outfile $OUTDIR/${basename}_${samp}_full.ppm $OUTDIR/${basename}_${samp}.jpg\n\t\t\t\t\t\tconvert -crop $CROPSPEC $OUTDIR/${basename}_${samp}_full.ppm $OUTDIR/${basename}_${samp}_ref.ppm\n\t\t\t\t\t\trunme $EXEDIR/djpeg $NSARG $COLORSARG -crop $CROPSPEC -rgb -outfile $OUTDIR/${basename}_${samp}.ppm $OUTDIR/${basename}_${samp}.jpg\n\t\t\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}.ppm $OUTDIR/${basename}_${samp}_ref.ppm\n\t\t\t\t\tdone\n\t\t\t\t\techo\n\n\t\t\t\tdone\n\n\t\t\tdone\n\n\t\tdone\n\n\tdone\n\ndone\n\necho SUCCESS!\n"
        },
        {
          "name": "djpeg.1",
          "type": "blob",
          "size": 10.7841796875,
          "content": ".TH DJPEG 1 \"17 June 2024\"\n.SH NAME\ndjpeg \\- decompress a JPEG file to an image file\n.SH SYNOPSIS\n.B djpeg\n[\n.I options\n]\n[\n.I filename\n]\n.LP\n.SH DESCRIPTION\n.LP\n.B djpeg\ndecompresses the named JPEG file, or the standard input if no file is named,\nand produces an image file on the standard output.  PBMPLUS (PPM/PGM), BMP,\nGIF, or Targa output format can be selected.\n.SH OPTIONS\nAll switch names may be abbreviated; for example,\n.B \\-grayscale\nmay be written\n.B \\-gray\nor\n.BR \\-gr .\nMost of the \"basic\" switches can be abbreviated to as little as one letter.\nUpper and lower case are equivalent (thus\n.B \\-BMP\nis the same as\n.BR \\-bmp ).\nBritish spellings are also accepted (e.g.\n.BR \\-greyscale ),\nthough for brevity these are not mentioned below.\n.PP\nThe basic switches are:\n.TP\n.BI \\-colors \" N\"\nReduce image to at most N colors [legacy feature].  This reduces the number of\ncolors used in the output image so that it can be stored in a colormapped file\nformat.  This feature cannot be used when decompressing lossless JPEG images.\n.TP\n.BI \\-quantize \" N\"\nSame as\n.BR \\-colors .\n.B \\-colors\nis the recommended name.\n.B \\-quantize\nis provided only for backward compatibility.\n.TP\n.B \\-fast\nSelect recommended processing options for low-quality output [legacy feature].\n(The default options are chosen for highest-quality output.)  Currently, this\nis equivalent to \\fB\\-dct fast \\-nosmooth \\-onepass \\-dither ordered\\fR.  On\nmodern CPUs, these settings have little or no performance benefit and are\nretained solely for backward compatibility.\n.TP\n.B \\-grayscale\nForce grayscale output even if JPEG file is full-color.  This feature cannot be\nused when decompressing full-color lossless JPEG images.\n.TP\n.B \\-rgb\nForce RGB output even if JPEG file is grayscale.  This feature cannot be used\nwhen decompressing grayscale lossless JPEG images.\n.TP\n.BI \\-scale \" M/N\"\nScale the output image by a factor M/N.  Currently the scale factor must be\nM/8, where M is an integer between 1 and 16 inclusive, or any reduced fraction\nthereof (such as 1/2, 3/4, etc.)  Scaling is handy if the image is larger than\nyour screen.  This feature cannot be used when decompressing lossless JPEG\nimages.\n.TP\n.B \\-bmp\nSelect BMP output format (Windows flavor).  8-bit colormapped format is\nemitted if\n.B \\-colors\nor\n.B \\-grayscale\nis specified, or if the JPEG file is grayscale; otherwise, 24-bit full-color\nformat is emitted.  This format can only be used when decompressing\n8-bit-per-sample JPEG images.\n.TP\n.B \\-gif\nSelect GIF output format (LZW-compressed) [legacy feature].  Since GIF does not\nsupport more than 256 colors,\n.B \\-colors 256\nis assumed (unless you specify a smaller number of colors).  If you specify\n.BR \\-fast,\nthe default number of colors is 216.  This format can only be used when\ndecompressing 8-bit-per-sample or 12-bit-per-sample lossy JPEG images.\n.TP\n.B \\-gif0\nSelect GIF output format (uncompressed) [legacy feature].  Since GIF does not\nsupport more than 256 colors,\n.B \\-colors 256\nis assumed (unless you specify a smaller number of colors).  If you specify\n.BR \\-fast,\nthe default number of colors is 216.  This format can only be used when\ndecompressing 8-bit-per-sample or 12-bit-per-sample lossy JPEG images.\n.TP\n.B \\-os2\nSelect BMP output format (OS/2 1.x flavor) [legacy feature].  8-bit colormapped\nformat is emitted if\n.B \\-colors\nor\n.B \\-grayscale\nis specified, or if the JPEG file is grayscale; otherwise, 24-bit full-color\nformat is emitted.  This format can only be used when decompressing\n8-bit-per-sample JPEG images.\n.TP\n.B \\-pnm\nSelect PBMPLUS (PPM/PGM) output format (this is the default format).\nPGM is emitted if the JPEG file is grayscale or if\n.B \\-grayscale\nis specified; otherwise PPM is emitted.\n.TP\n.B \\-targa\nSelect Targa output format [legacy feature].  Grayscale format is emitted if\nthe JPEG file is grayscale or if\n.B \\-grayscale\nis specified; otherwise, colormapped format is emitted if\n.B \\-colors\nis specified; otherwise, 24-bit full-color format is emitted.  This format can\nonly be used when decompressing 8-bit-per-sample JPEG images.\n.PP\nSwitches for advanced users:\n.TP\n.B \\-dct int\nUse accurate integer DCT method (default).\n.TP\n.B \\-dct fast\nUse less accurate integer DCT method [legacy feature].\nWhen the Independent JPEG Group's software was first released in 1991, the\ndecompression time for a 1-megapixel JPEG image on a mainstream PC was measured\nin minutes.  Thus, the \\fBfast\\fR integer DCT algorithm provided noticeable\nperformance benefits.  On modern CPUs running libjpeg-turbo, however, the\ndecompression time for a 1-megapixel JPEG image is measured in milliseconds,\nand thus the performance benefits of the \\fBfast\\fR algorithm are much less\nnoticeable.  On modern x86/x86-64 CPUs that support AVX2 instructions, the\n\\fBfast\\fR and \\fBint\\fR methods have similar performance.  On other types of\nCPUs, the \\fBfast\\fR method is generally about 5-15% faster than the \\fBint\\fR\nmethod.\n\nIf the JPEG image was compressed using a quality level of 85 or below, then\nthere should be little or no perceptible quality difference between the two\nalgorithms.  When decompressing images that were compressed using quality\nlevels above 85, however, the difference between the \\fBfast\\fR and \\fBint\\fR\nmethods becomes more pronounced.  With images compressed using quality=97, for\ninstance, the \\fBfast\\fR method incurs generally about a 4-6 dB loss in PSNR\nrelative to the \\fBint\\fR method, but this can be larger for some images.  If\nyou can avoid it, do not use the \\fBfast\\fR method when decompressing images\nthat were compressed using quality levels above 97.  The algorithm often\ndegenerates for such images and can actually produce a more lossy output image\nthan if the JPEG image had been compressed using lower quality levels.\n.TP\n.B \\-dct float\nUse floating-point DCT method [legacy feature].\nThe \\fBfloat\\fR method does not produce significantly more accurate results\nthan the \\fBint\\fR method, and it is much slower.  The \\fBfloat\\fR method may\nalso give different results on different machines due to varying roundoff\nbehavior, whereas the integer methods should give the same results on all\nmachines.\n.TP\n.B \\-dither fs\nUse Floyd-Steinberg dithering when quantizing colors [legacy feature].\n.TP\n.B \\-dither ordered\nUse ordered dithering when quantizing colors [legacy feature].\n.TP\n.B \\-dither none\nDo not use dithering when quantizing colors [legacy feature].  By default,\nFloyd-Steinberg dithering is applied when quantizing colors.  This is slower\nbut usually produces the best results.  Ordered dithering is a compromise\nbetween speed and quality.  No dithering is faster but usually looks awful.\nNote that these switches have no effect unless color quantization is being\ndone.  Ordered dithering is only available in\n.B \\-onepass\nmode.\n.TP\n.BI \\-icc \" file\"\nExtract ICC color management profile to the specified file.\n.TP\n.BI \\-map \" file\"\nQuantize to the colors used in the specified image file [legacy feature].  This\nis useful for producing multiple files with identical color maps, or for\nforcing a predefined set of colors to be used.  The\n.I file\nmust be a GIF or PPM file. This option overrides\n.B \\-colors\nand\n.BR \\-onepass .\n.TP\n.B \\-nosmooth\nUse a faster, lower-quality upsampling routine.\n.TP\n.B \\-onepass\nUse one-pass instead of two-pass color quantization [legacy feature].  The\none-pass method needs less memory, but it produces a lower-quality image.\n.B \\-onepass\nis ignored unless you also specify\n.B \\-colors\n.IR N .\nAlso, the one-pass method is always used for grayscale output.  (The two-pass\nmethod has no improvement in that case.)\n.TP\n.BI \\-maxmemory \" N\"\nSet limit for amount of memory to use in processing large images.  Value is\nin thousands of bytes, or millions of bytes if \"M\" is attached to the\nnumber.  For example,\n.B \\-max 4m\nselects 4000000 bytes.  If more space is needed, an error will occur.\n.TP\n.BI \\-maxscans \" N\"\nAbort if the JPEG image contains more than\n.I N\nscans.  This feature demonstrates a method by which applications can guard\nagainst denial-of-service attacks instigated by specially-crafted malformed\nJPEG images containing numerous scans with missing image data or image data\nconsisting only of \"EOB runs\" (a feature of progressive JPEG images that allows\npotentially hundreds of thousands of adjoining zero-value pixels to be\nrepresented using only a few bytes.)  Attempting to decompress such malformed\nJPEG images can cause excessive CPU activity, since the decompressor must fully\nprocess each scan (even if the scan is corrupt) before it can proceed to the\nnext scan.\n.TP\n.BI \\-outfile \" name\"\nSend output image to the named file, not to standard output.\n.TP\n.BI \\-memsrc\nLoad input file into memory before decompressing.  This feature was implemented\nmainly as a way of testing the in-memory source manager (jpeg_mem_src().)\n.TP\n.BI \\-report\nReport decompression progress.\n.TP\n.BI \\-skip \" Y0,Y1\"\nDecompress all rows of the JPEG image except those between Y0 and Y1\n(inclusive.)  Note that if decompression scaling is being used, then Y0 and Y1\nare relative to the scaled image dimensions.\n.TP\n.BI \\-crop \" WxH+X+Y\"\nDecompress only a rectangular subregion of the image, starting at point X,Y\nwith width W and height H.  If necessary, X will be shifted left to the nearest\niMCU boundary, and the width will be increased accordingly.  Note that if\ndecompression scaling is being used, then X, Y, W, and H are relative to the\nscaled image dimensions.  Currently this option only works with the\nPBMPLUS (PPM/PGM), GIF, and Targa output formats.\n.TP\n.BI \\-strict\nTreat all warnings as fatal.  This feature also demonstrates a method by which\napplications can guard against attacks instigated by specially-crafted\nmalformed JPEG images.  Enabling this option will cause the decompressor to\nabort if the JPEG image contains incomplete or corrupt image data.\n.TP\n.B \\-verbose\nEnable debug printout.  More\n.BR \\-v 's\ngive more output.  Also, version information is printed at startup.\n.TP\n.B \\-debug\nSame as\n.BR \\-verbose .\n.TP\n.B \\-version\nPrint version information and exit.\n.SH EXAMPLES\n.LP\nThis example decompresses the JPEG file foo.jpg and saves the output in 8-bit\nBMP format in foo.bmp:\n.IP\n.B djpeg \\-bmp\n.I foo.jpg\n.B >\n.I foo.bmp\n.SH ENVIRONMENT\n.TP\n.B JPEGMEM\nIf this environment variable is set, its value is the default memory limit.\nThe value is specified as described for the\n.B \\-maxmemory\nswitch.\n.B JPEGMEM\noverrides the default value specified when the program was compiled, and\nitself is overridden by an explicit\n.BR \\-maxmemory .\n.SH SEE ALSO\n.BR cjpeg (1),\n.BR jpegtran (1),\n.BR rdjpgcom (1),\n.BR wrjpgcom (1)\n.br\n.BR ppm (5),\n.BR pgm (5)\n.br\nWallace, Gregory K.  \"The JPEG Still Picture Compression Standard\",\nCommunications of the ACM, April 1991 (vol. 34, no. 4), pp. 30-44.\n.SH AUTHOR\nIndependent JPEG Group\n.PP\nThis file was modified by The libjpeg-turbo Project to include only information\nrelevant to libjpeg-turbo, to wordsmith certain sections, and to describe\nfeatures not present in libjpeg.\n"
        },
        {
          "name": "djpeg.c",
          "type": "blob",
          "size": 32.697265625,
          "content": "/*\n * djpeg.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 2013-2019 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010-2011, 2013-2017, 2019-2020, 2022-2024, D. R. Commander.\n * Copyright (C) 2015, Google, Inc.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a command-line user interface for the JPEG decompressor.\n * It should work on any system with Unix- or MS-DOS-style command lines.\n *\n * Two different command line styles are permitted, depending on the\n * compile-time switch TWO_FILE_COMMANDLINE:\n *      djpeg [options]  inputfile outputfile\n *      djpeg [options]  [inputfile]\n * In the second style, output is always to standard output, which you'd\n * normally redirect to a file or pipe to some other program.  Input is\n * either from a named file or from standard input (typically redirected).\n * The second style is convenient on Unix but is unhelpful on systems that\n * don't support pipes.  Also, you MUST use the first style if your system\n * doesn't do binary I/O to stdin/stdout.\n * To simplify script writing, the \"-outfile\" switch is provided.  The syntax\n *      djpeg [options]  -outfile outputfile  inputfile\n * works regardless of which command line style is used.\n */\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n#include \"jversion.h\"           /* for version message */\n#include \"jconfigint.h\"\n\n#include <ctype.h>              /* to declare isprint() */\n\n\n/* Create the add-on message string table. */\n\n#define JMESSAGE(code, string)  string,\n\nstatic const char * const cdjpeg_message_table[] = {\n#include \"cderror.h\"\n  NULL\n};\n\n\n/*\n * This list defines the known output image formats\n * (not all of which need be supported by a given version).\n * You can change the default output format by defining DEFAULT_FMT;\n * indeed, you had better do so if you undefine PPM_SUPPORTED.\n */\n\ntypedef enum {\n  FMT_BMP,                      /* BMP format (Windows flavor) */\n  FMT_GIF,                      /* GIF format (LZW-compressed) */\n  FMT_GIF0,                     /* GIF format (uncompressed) */\n  FMT_OS2,                      /* BMP format (OS/2 flavor) */\n  FMT_PPM,                      /* PPM/PGM (PBMPLUS formats) */\n  FMT_TARGA,                    /* Targa format */\n  FMT_TIFF                      /* TIFF format */\n} IMAGE_FORMATS;\n\n#ifndef DEFAULT_FMT             /* so can override from CFLAGS in Makefile */\n#define DEFAULT_FMT     FMT_PPM\n#endif\n\nstatic IMAGE_FORMATS requested_fmt;\n\n\n/*\n * Argument-parsing code.\n * The switch parser is designed to be useful with DOS-style command line\n * syntax, ie, intermixed switches and file names, where only the switches\n * to the left of a given file name affect processing of that file.\n * The main program in this file doesn't actually use this capability...\n */\n\n\nstatic const char *progname;    /* program name for error messages */\nstatic char *icc_filename;      /* for -icc switch */\nstatic JDIMENSION max_scans;    /* for -maxscans switch */\nstatic char *outfilename;       /* for -outfile switch */\nstatic boolean memsrc;          /* for -memsrc switch */\nstatic boolean report;          /* for -report switch */\nstatic boolean skip, crop;\nstatic JDIMENSION skip_start, skip_end;\nstatic JDIMENSION crop_x, crop_y, crop_width, crop_height;\nstatic boolean strict;          /* for -strict switch */\n#define INPUT_BUF_SIZE  4096\n\n\nLOCAL(void)\nusage(void)\n/* complain about bad command line */\n{\n  fprintf(stderr, \"usage: %s [switches] \", progname);\n#ifdef TWO_FILE_COMMANDLINE\n  fprintf(stderr, \"inputfile outputfile\\n\");\n#else\n  fprintf(stderr, \"[inputfile]\\n\");\n#endif\n\n  fprintf(stderr, \"Switches (names may be abbreviated):\\n\");\n  fprintf(stderr, \"  -colors N      Reduce image to no more than N colors [legacy feature]\\n\");\n  fprintf(stderr, \"  -fast          Low-quality processing [legacy feature]\\n\");\n  fprintf(stderr, \"  -grayscale     Force grayscale output\\n\");\n  fprintf(stderr, \"  -rgb           Force RGB output\\n\");\n  fprintf(stderr, \"  -rgb565        Force RGB565 output\\n\");\n#ifdef IDCT_SCALING_SUPPORTED\n  fprintf(stderr, \"  -scale M/N     Scale output image by fraction M/N, eg, 1/8\\n\");\n#endif\n#ifdef BMP_SUPPORTED\n  fprintf(stderr, \"  -bmp           Select BMP output format (Windows style)%s\\n\",\n          (DEFAULT_FMT == FMT_BMP ? \" (default)\" : \"\"));\n#endif\n#ifdef GIF_SUPPORTED\n  fprintf(stderr, \"  -gif           Select GIF output format (LZW-compressed)%s [legacy feature]\\n\",\n          (DEFAULT_FMT == FMT_GIF ? \" (default)\" : \"\"));\n  fprintf(stderr, \"  -gif0          Select GIF output format (uncompressed)%s [legacy feature]\\n\",\n          (DEFAULT_FMT == FMT_GIF0 ? \" (default)\" : \"\"));\n#endif\n#ifdef BMP_SUPPORTED\n  fprintf(stderr, \"  -os2           Select BMP output format (OS/2 style)%s [legacy feature]\\n\",\n          (DEFAULT_FMT == FMT_OS2 ? \" (default)\" : \"\"));\n#endif\n#ifdef PPM_SUPPORTED\n  fprintf(stderr, \"  -pnm           Select PBMPLUS (PPM/PGM) output format%s\\n\",\n          (DEFAULT_FMT == FMT_PPM ? \" (default)\" : \"\"));\n#endif\n#ifdef TARGA_SUPPORTED\n  fprintf(stderr, \"  -targa         Select Targa output format%s [legacy feature]\\n\",\n          (DEFAULT_FMT == FMT_TARGA ? \" (default)\" : \"\"));\n#endif\n  fprintf(stderr, \"Switches for advanced users:\\n\");\n#ifdef DCT_ISLOW_SUPPORTED\n  fprintf(stderr, \"  -dct int       Use accurate integer DCT method%s\\n\",\n          (JDCT_DEFAULT == JDCT_ISLOW ? \" (default)\" : \"\"));\n#endif\n#ifdef DCT_IFAST_SUPPORTED\n  fprintf(stderr, \"  -dct fast      Use less accurate integer DCT method [legacy feature]%s\\n\",\n          (JDCT_DEFAULT == JDCT_IFAST ? \" (default)\" : \"\"));\n#endif\n#ifdef DCT_FLOAT_SUPPORTED\n  fprintf(stderr, \"  -dct float     Use floating-point DCT method [legacy feature]%s\\n\",\n          (JDCT_DEFAULT == JDCT_FLOAT ? \" (default)\" : \"\"));\n#endif\n  fprintf(stderr, \"  -dither fs     Use Floyd-Steinberg dithering when quantizing colors (default)\\n\");\n  fprintf(stderr, \"                 [legacy feature]\\n\");\n  fprintf(stderr, \"  -dither none   Don't use dithering when quantizing colors [legacy feature]\\n\");\n  fprintf(stderr, \"  -dither ordered  Use ordered dithering when quantizing colors\\n\");\n  fprintf(stderr, \"                   [legacy feature]\\n\");\n  fprintf(stderr, \"  -icc FILE      Extract ICC profile to FILE\\n\");\n#ifdef QUANT_2PASS_SUPPORTED\n  fprintf(stderr, \"  -map FILE      Quantize to colors used in named image file [legacy feature]\\n\");\n#endif\n  fprintf(stderr, \"  -nosmooth      Use faster, lower-quality upsampling\\n\");\n#ifdef QUANT_1PASS_SUPPORTED\n  fprintf(stderr, \"  -onepass       Use 1-pass color quantization (low quality) [legacy feature]\\n\");\n#endif\n  fprintf(stderr, \"  -maxmemory N   Maximum memory to use (in kbytes)\\n\");\n  fprintf(stderr, \"  -maxscans N    Maximum number of scans to allow in input file\\n\");\n  fprintf(stderr, \"  -outfile name  Specify name for output file\\n\");\n  fprintf(stderr, \"  -memsrc        Load input file into memory before decompressing\\n\");\n  fprintf(stderr, \"  -report        Report decompression progress\\n\");\n  fprintf(stderr, \"  -skip Y0,Y1    Decompress all rows except those between Y0 and Y1 (inclusive)\\n\");\n  fprintf(stderr, \"  -crop WxH+X+Y  Decompress only a rectangular subregion of the image\\n\");\n  fprintf(stderr, \"                 [requires PBMPLUS (PPM/PGM), GIF, or Targa output format]\\n\");\n  fprintf(stderr, \"  -strict        Treat all warnings as fatal\\n\");\n  fprintf(stderr, \"  -verbose  or  -debug   Emit debug output\\n\");\n  fprintf(stderr, \"  -version       Print version information and exit\\n\");\n  exit(EXIT_FAILURE);\n}\n\n\nLOCAL(int)\nparse_switches(j_decompress_ptr cinfo, int argc, char **argv,\n               int last_file_arg_seen, boolean for_real)\n/* Parse optional switches.\n * Returns argv[] index of first file-name argument (== argc if none).\n * Any file names with indexes <= last_file_arg_seen are ignored;\n * they have presumably been processed in a previous iteration.\n * (Pass 0 for last_file_arg_seen on the first or only iteration.)\n * for_real is FALSE on the first (dummy) pass; we may skip any expensive\n * processing.\n */\n{\n  int argn;\n  char *arg;\n\n  /* Set up default JPEG parameters. */\n  requested_fmt = DEFAULT_FMT;  /* set default output file format */\n  icc_filename = NULL;\n  max_scans = 0;\n  outfilename = NULL;\n  memsrc = FALSE;\n  report = FALSE;\n  skip = FALSE;\n  crop = FALSE;\n  strict = FALSE;\n  cinfo->err->trace_level = 0;\n\n  /* Scan command line options, adjust parameters */\n\n  for (argn = 1; argn < argc; argn++) {\n    arg = argv[argn];\n    if (*arg != '-') {\n      /* Not a switch, must be a file name argument */\n      if (argn <= last_file_arg_seen) {\n        outfilename = NULL;     /* -outfile applies to just one input file */\n        continue;               /* ignore this name if previously processed */\n      }\n      break;                    /* else done parsing switches */\n    }\n    arg++;                      /* advance past switch marker character */\n\n    if (keymatch(arg, \"bmp\", 1)) {\n      /* BMP output format (Windows flavor). */\n      requested_fmt = FMT_BMP;\n\n    } else if (keymatch(arg, \"colors\", 1) || keymatch(arg, \"colours\", 1) ||\n               keymatch(arg, \"quantize\", 1) || keymatch(arg, \"quantise\", 1)) {\n      /* Do color quantization. */\n      int val;\n\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%d\", &val) != 1)\n        usage();\n      cinfo->desired_number_of_colors = val;\n      cinfo->quantize_colors = TRUE;\n\n    } else if (keymatch(arg, \"dct\", 2)) {\n      /* Select IDCT algorithm. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (keymatch(argv[argn], \"int\", 1)) {\n        cinfo->dct_method = JDCT_ISLOW;\n      } else if (keymatch(argv[argn], \"fast\", 2)) {\n        cinfo->dct_method = JDCT_IFAST;\n      } else if (keymatch(argv[argn], \"float\", 2)) {\n        cinfo->dct_method = JDCT_FLOAT;\n      } else\n        usage();\n\n    } else if (keymatch(arg, \"dither\", 2)) {\n      /* Select dithering algorithm. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (keymatch(argv[argn], \"fs\", 2)) {\n        cinfo->dither_mode = JDITHER_FS;\n      } else if (keymatch(argv[argn], \"none\", 2)) {\n        cinfo->dither_mode = JDITHER_NONE;\n      } else if (keymatch(argv[argn], \"ordered\", 2)) {\n        cinfo->dither_mode = JDITHER_ORDERED;\n      } else\n        usage();\n\n    } else if (keymatch(arg, \"debug\", 1) || keymatch(arg, \"verbose\", 1)) {\n      /* Enable debug printouts. */\n      /* On first -d, print version identification */\n      static boolean printed_version = FALSE;\n\n      if (!printed_version) {\n        fprintf(stderr, \"%s version %s (build %s)\\n\",\n                PACKAGE_NAME, VERSION, BUILD);\n        fprintf(stderr, JCOPYRIGHT1);\n        fprintf(stderr, JCOPYRIGHT2 \"\\n\");\n        fprintf(stderr, \"Emulating The Independent JPEG Group's software, version %s\\n\\n\",\n                JVERSION);\n        printed_version = TRUE;\n      }\n      cinfo->err->trace_level++;\n\n    } else if (keymatch(arg, \"version\", 4)) {\n      fprintf(stderr, \"%s version %s (build %s)\\n\",\n              PACKAGE_NAME, VERSION, BUILD);\n      exit(EXIT_SUCCESS);\n\n    } else if (keymatch(arg, \"fast\", 1)) {\n      /* Select recommended processing options for quick-and-dirty output. */\n      cinfo->two_pass_quantize = FALSE;\n      cinfo->dither_mode = JDITHER_ORDERED;\n      if (!cinfo->quantize_colors) /* don't override an earlier -colors */\n        cinfo->desired_number_of_colors = 216;\n      cinfo->dct_method = JDCT_FASTEST;\n      cinfo->do_fancy_upsampling = FALSE;\n\n    } else if (keymatch(arg, \"gif\", 1)) {\n      /* GIF output format (LZW-compressed). */\n      requested_fmt = FMT_GIF;\n\n    } else if (keymatch(arg, \"gif0\", 4)) {\n      /* GIF output format (uncompressed). */\n      requested_fmt = FMT_GIF0;\n\n    } else if (keymatch(arg, \"grayscale\", 2) ||\n               keymatch(arg, \"greyscale\", 2)) {\n      /* Force monochrome output. */\n      cinfo->out_color_space = JCS_GRAYSCALE;\n\n    } else if (keymatch(arg, \"rgb\", 2)) {\n      /* Force RGB output. */\n      cinfo->out_color_space = JCS_RGB;\n\n    } else if (keymatch(arg, \"rgb565\", 2)) {\n      /* Force RGB565 output. */\n      cinfo->out_color_space = JCS_RGB565;\n\n    } else if (keymatch(arg, \"icc\", 1)) {\n      /* Set ICC filename. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      icc_filename = argv[argn];\n#ifdef SAVE_MARKERS_SUPPORTED\n      jpeg_save_markers(cinfo, JPEG_APP0 + 2, 0xFFFF);\n#endif\n\n    } else if (keymatch(arg, \"map\", 3)) {\n      /* Quantize to a color map taken from an input file. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (for_real) {           /* too expensive to do twice! */\n#ifdef QUANT_2PASS_SUPPORTED    /* otherwise can't quantize to supplied map */\n        FILE *mapfile;\n\n        if ((mapfile = fopen(argv[argn], READ_BINARY)) == NULL) {\n          fprintf(stderr, \"%s: can't open %s\\n\", progname, argv[argn]);\n          exit(EXIT_FAILURE);\n        }\n        if (cinfo->data_precision == 12)\n          read_color_map_12(cinfo, mapfile);\n        else\n          read_color_map(cinfo, mapfile);\n        fclose(mapfile);\n        cinfo->quantize_colors = TRUE;\n#else\n        ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n      }\n\n    } else if (keymatch(arg, \"maxmemory\", 3)) {\n      /* Maximum memory in Kb (or Mb with 'm'). */\n      long lval;\n      char ch = 'x';\n\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%ld%c\", &lval, &ch) < 1)\n        usage();\n      if (ch == 'm' || ch == 'M')\n        lval *= 1000L;\n      cinfo->mem->max_memory_to_use = lval * 1000L;\n\n    } else if (keymatch(arg, \"maxscans\", 4)) {\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%u\", &max_scans) != 1)\n        usage();\n\n    } else if (keymatch(arg, \"nosmooth\", 3)) {\n      /* Suppress fancy upsampling */\n      cinfo->do_fancy_upsampling = FALSE;\n\n    } else if (keymatch(arg, \"onepass\", 3)) {\n      /* Use fast one-pass quantization. */\n      cinfo->two_pass_quantize = FALSE;\n\n    } else if (keymatch(arg, \"os2\", 3)) {\n      /* BMP output format (OS/2 flavor). */\n      requested_fmt = FMT_OS2;\n\n    } else if (keymatch(arg, \"outfile\", 4)) {\n      /* Set output file name. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      outfilename = argv[argn]; /* save it away for later use */\n\n    } else if (keymatch(arg, \"memsrc\", 2)) {\n      /* Use in-memory source manager */\n      memsrc = TRUE;\n\n    } else if (keymatch(arg, \"pnm\", 1) || keymatch(arg, \"ppm\", 1)) {\n      /* PPM/PGM output format. */\n      requested_fmt = FMT_PPM;\n\n    } else if (keymatch(arg, \"report\", 2)) {\n      report = TRUE;\n\n    } else if (keymatch(arg, \"scale\", 1)) {\n      /* Scale the output image by a fraction M/N. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%u/%u\",\n                 &cinfo->scale_num, &cinfo->scale_denom) != 2)\n        usage();\n\n    } else if (keymatch(arg, \"skip\", 2)) {\n      int temp_start = -1, temp_end = -1;\n      if (++argn >= argc)\n        usage();\n      if (sscanf(argv[argn], \"%d,%d\", &temp_start, &temp_end) != 2 ||\n          temp_start < 0 || temp_end < 0 || temp_start > temp_end)\n        usage();\n      skip = TRUE;\n      skip_start = temp_start;\n      skip_end = temp_end;\n\n    } else if (keymatch(arg, \"crop\", 2)) {\n      int temp_width = -1, temp_height = -1, temp_x = -1, temp_y = -1;\n      char c;\n      if (++argn >= argc)\n        usage();\n      if (sscanf(argv[argn], \"%d%c%d+%d+%d\", &temp_width, &c, &temp_height,\n                 &temp_x, &temp_y) != 5 ||\n          (c != 'X' && c != 'x') || temp_width < 1 || temp_height < 1 ||\n          temp_x < 0 || temp_y < 0)\n        usage();\n      crop = TRUE;\n      crop_width = temp_width;\n      crop_height = temp_height;\n      crop_x = temp_x;\n      crop_y = temp_y;\n\n    } else if (keymatch(arg, \"strict\", 2)) {\n      strict = TRUE;\n\n    } else if (keymatch(arg, \"targa\", 1)) {\n      /* Targa output format. */\n      requested_fmt = FMT_TARGA;\n\n    } else {\n      usage();                  /* bogus switch */\n    }\n  }\n\n  return argn;                  /* return index of next arg (file name) */\n}\n\n\n/*\n * Marker processor for COM and interesting APPn markers.\n * This replaces the library's built-in processor, which just skips the marker.\n * We want to print out the marker as text, to the extent possible.\n * Note this code relies on a non-suspending data source.\n */\n\nLOCAL(unsigned int)\njpeg_getc(j_decompress_ptr cinfo)\n/* Read next byte */\n{\n  struct jpeg_source_mgr *datasrc = cinfo->src;\n\n  if (datasrc->bytes_in_buffer == 0) {\n    if (!(*datasrc->fill_input_buffer) (cinfo))\n      ERREXIT(cinfo, JERR_CANT_SUSPEND);\n  }\n  datasrc->bytes_in_buffer--;\n  return *datasrc->next_input_byte++;\n}\n\n\nMETHODDEF(boolean)\nprint_text_marker(j_decompress_ptr cinfo)\n{\n  boolean traceit = (cinfo->err->trace_level >= 1);\n  long length;\n  unsigned int ch;\n  unsigned int lastch = 0;\n\n  length = jpeg_getc(cinfo) << 8;\n  length += jpeg_getc(cinfo);\n  length -= 2;                  /* discount the length word itself */\n\n  if (traceit) {\n    if (cinfo->unread_marker == JPEG_COM)\n      fprintf(stderr, \"Comment, length %ld:\\n\", (long)length);\n    else                        /* assume it is an APPn otherwise */\n      fprintf(stderr, \"APP%d, length %ld:\\n\",\n              cinfo->unread_marker - JPEG_APP0, (long)length);\n  }\n\n  while (--length >= 0) {\n    ch = jpeg_getc(cinfo);\n    if (traceit) {\n      /* Emit the character in a readable form.\n       * Nonprintables are converted to \\nnn form,\n       * while \\ is converted to \\\\.\n       * Newlines in CR, CR/LF, or LF form will be printed as one newline.\n       */\n      if (ch == '\\r') {\n        fprintf(stderr, \"\\n\");\n      } else if (ch == '\\n') {\n        if (lastch != '\\r')\n          fprintf(stderr, \"\\n\");\n      } else if (ch == '\\\\') {\n        fprintf(stderr, \"\\\\\\\\\");\n      } else if (isprint(ch)) {\n        putc(ch, stderr);\n      } else {\n        fprintf(stderr, \"\\\\%03o\", ch);\n      }\n      lastch = ch;\n    }\n  }\n\n  if (traceit)\n    fprintf(stderr, \"\\n\");\n\n  return TRUE;\n}\n\n\nMETHODDEF(void)\nmy_emit_message(j_common_ptr cinfo, int msg_level)\n{\n  if (msg_level < 0) {\n    /* Treat warning as fatal */\n    cinfo->err->error_exit(cinfo);\n  } else {\n    if (cinfo->err->trace_level >= msg_level)\n      cinfo->err->output_message(cinfo);\n  }\n}\n\n\n/*\n * The main program.\n */\n\nint\nmain(int argc, char **argv)\n{\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  struct cdjpeg_progress_mgr progress;\n  int file_index;\n  djpeg_dest_ptr dest_mgr = NULL;\n  FILE *input_file;\n  FILE *output_file;\n  unsigned char *inbuffer = NULL;\n  unsigned long insize = 0;\n  JDIMENSION num_scanlines;\n\n  progname = argv[0];\n  if (progname == NULL || progname[0] == 0)\n    progname = \"djpeg\";         /* in case C library doesn't provide it */\n\n  /* Initialize the JPEG decompression object with default error handling. */\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n  /* Add some application-specific error messages (from cderror.h) */\n  jerr.addon_message_table = cdjpeg_message_table;\n  jerr.first_addon_message = JMSG_FIRSTADDONCODE;\n  jerr.last_addon_message = JMSG_LASTADDONCODE;\n\n  /* Insert custom marker processor for COM and APP12.\n   * APP12 is used by some digital camera makers for textual info,\n   * so we provide the ability to display it as text.\n   * If you like, additional APPn marker types can be selected for display,\n   * but don't try to override APP0 or APP14 this way (see libjpeg.txt).\n   */\n  jpeg_set_marker_processor(&cinfo, JPEG_COM, print_text_marker);\n  jpeg_set_marker_processor(&cinfo, JPEG_APP0 + 12, print_text_marker);\n\n  /* Scan command line to find file names. */\n  /* It is convenient to use just one switch-parsing routine, but the switch\n   * values read here are ignored; we will rescan the switches after opening\n   * the input file.\n   * (Exception: tracing level set here controls verbosity for COM markers\n   * found during jpeg_read_header...)\n   */\n\n  file_index = parse_switches(&cinfo, argc, argv, 0, FALSE);\n\n  if (strict)\n    jerr.emit_message = my_emit_message;\n\n#ifdef TWO_FILE_COMMANDLINE\n  /* Must have either -outfile switch or explicit output file name */\n  if (outfilename == NULL) {\n    if (file_index != argc - 2) {\n      fprintf(stderr, \"%s: must name one input and one output file\\n\",\n              progname);\n      usage();\n    }\n    outfilename = argv[file_index + 1];\n  } else {\n    if (file_index != argc - 1) {\n      fprintf(stderr, \"%s: must name one input and one output file\\n\",\n              progname);\n      usage();\n    }\n  }\n#else\n  /* Unix style: expect zero or one file name */\n  if (file_index < argc - 1) {\n    fprintf(stderr, \"%s: only one input file\\n\", progname);\n    usage();\n  }\n#endif /* TWO_FILE_COMMANDLINE */\n\n  /* Open the input file. */\n  if (file_index < argc) {\n    if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, argv[file_index]);\n      exit(EXIT_FAILURE);\n    }\n  } else {\n    /* default input file is stdin */\n    input_file = read_stdin();\n  }\n\n  /* Open the output file. */\n  if (outfilename != NULL) {\n    if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, outfilename);\n      exit(EXIT_FAILURE);\n    }\n  } else {\n    /* default output file is stdout */\n    output_file = write_stdout();\n  }\n\n  if (report || max_scans != 0) {\n    start_progress_monitor((j_common_ptr)&cinfo, &progress);\n    progress.report = report;\n    progress.max_scans = max_scans;\n  }\n\n  /* Specify data source for decompression */\n  if (memsrc) {\n    size_t nbytes;\n    do {\n      inbuffer = (unsigned char *)realloc(inbuffer, insize + INPUT_BUF_SIZE);\n      if (inbuffer == NULL) {\n        fprintf(stderr, \"%s: memory allocation failure\\n\", progname);\n        exit(EXIT_FAILURE);\n      }\n      nbytes = fread(&inbuffer[insize], 1, INPUT_BUF_SIZE, input_file);\n      if (nbytes < INPUT_BUF_SIZE && ferror(input_file)) {\n        if (file_index < argc)\n          fprintf(stderr, \"%s: can't read from %s\\n\", progname,\n                  argv[file_index]);\n        else\n          fprintf(stderr, \"%s: can't read from stdin\\n\", progname);\n      }\n      insize += (unsigned long)nbytes;\n    } while (nbytes == INPUT_BUF_SIZE);\n    fprintf(stderr, \"Compressed size:  %lu bytes\\n\", insize);\n    jpeg_mem_src(&cinfo, inbuffer, insize);\n  } else\n    jpeg_stdio_src(&cinfo, input_file);\n\n  /* Read file header, set default decompression parameters */\n  (void)jpeg_read_header(&cinfo, TRUE);\n\n  /* Adjust default decompression parameters by re-parsing the options */\n  file_index = parse_switches(&cinfo, argc, argv, 0, TRUE);\n\n  /* Initialize the output module now to let it override any crucial\n   * option settings (for instance, GIF wants to force color quantization).\n   */\n  switch (requested_fmt) {\n#ifdef BMP_SUPPORTED\n  case FMT_BMP:\n    dest_mgr = jinit_write_bmp(&cinfo, FALSE, TRUE);\n    break;\n  case FMT_OS2:\n    dest_mgr = jinit_write_bmp(&cinfo, TRUE, TRUE);\n    break;\n#endif\n#ifdef GIF_SUPPORTED\n  case FMT_GIF:\n    if (cinfo.data_precision == 16)\n      ERREXIT1(&cinfo, JERR_BAD_PRECISION, cinfo.data_precision);\n    else if (cinfo.data_precision == 12)\n      dest_mgr = j12init_write_gif(&cinfo, TRUE);\n    else\n      dest_mgr = jinit_write_gif(&cinfo, TRUE);\n    break;\n  case FMT_GIF0:\n    dest_mgr = jinit_write_gif(&cinfo, FALSE);\n    break;\n#endif\n#ifdef PPM_SUPPORTED\n  case FMT_PPM:\n    if (cinfo.data_precision == 16)\n#ifdef D_LOSSLESS_SUPPORTED\n      dest_mgr = j16init_write_ppm(&cinfo);\n#else\n      ERREXIT1(&cinfo, JERR_BAD_PRECISION, cinfo.data_precision);\n#endif\n    else if (cinfo.data_precision == 12)\n      dest_mgr = j12init_write_ppm(&cinfo);\n    else\n      dest_mgr = jinit_write_ppm(&cinfo);\n    break;\n#endif\n#ifdef TARGA_SUPPORTED\n  case FMT_TARGA:\n    dest_mgr = jinit_write_targa(&cinfo);\n    break;\n#endif\n  default:\n    ERREXIT(&cinfo, JERR_UNSUPPORTED_FORMAT);\n    break;\n  }\n  dest_mgr->output_file = output_file;\n\n  /* Start decompressor */\n  (void)jpeg_start_decompress(&cinfo);\n\n  /* Skip rows */\n  if (skip) {\n    JDIMENSION tmp;\n\n    /* Check for valid skip_end.  We cannot check this value until after\n     * jpeg_start_decompress() is called.  Note that we have already verified\n     * that skip_start <= skip_end.\n     */\n    if (skip_end > cinfo.output_height - 1) {\n      fprintf(stderr, \"%s: skip region exceeds image height %u\\n\", progname,\n              cinfo.output_height);\n      exit(EXIT_FAILURE);\n    }\n\n    /* Write output file header.  This is a hack to ensure that the destination\n     * manager creates an output image of the proper size.\n     */\n    tmp = cinfo.output_height;\n    cinfo.output_height -= (skip_end - skip_start + 1);\n    (*dest_mgr->start_output) (&cinfo, dest_mgr);\n    cinfo.output_height = tmp;\n\n    if (cinfo.data_precision == 16)\n      ERREXIT(&cinfo, JERR_NOTIMPL);\n    else if (cinfo.data_precision == 12) {\n      /* Process data */\n      while (cinfo.output_scanline < skip_start) {\n        num_scanlines = jpeg12_read_scanlines(&cinfo, dest_mgr->buffer12,\n                                              dest_mgr->buffer_height);\n        (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);\n      }\n      if ((tmp = jpeg12_skip_scanlines(&cinfo, skip_end - skip_start + 1)) !=\n          skip_end - skip_start + 1) {\n        fprintf(stderr, \"%s: jpeg12_skip_scanlines() returned %u rather than %u\\n\",\n                progname, tmp, skip_end - skip_start + 1);\n        exit(EXIT_FAILURE);\n      }\n      while (cinfo.output_scanline < cinfo.output_height) {\n        num_scanlines = jpeg12_read_scanlines(&cinfo, dest_mgr->buffer12,\n                                              dest_mgr->buffer_height);\n        (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);\n      }\n    } else {\n      /* Process data */\n      while (cinfo.output_scanline < skip_start) {\n        num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,\n                                            dest_mgr->buffer_height);\n        (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);\n      }\n      if ((tmp = jpeg_skip_scanlines(&cinfo, skip_end - skip_start + 1)) !=\n          skip_end - skip_start + 1) {\n        fprintf(stderr, \"%s: jpeg_skip_scanlines() returned %u rather than %u\\n\",\n                progname, tmp, skip_end - skip_start + 1);\n        exit(EXIT_FAILURE);\n      }\n      while (cinfo.output_scanline < cinfo.output_height) {\n        num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,\n                                            dest_mgr->buffer_height);\n        (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);\n      }\n    }\n\n  /* Decompress a subregion */\n  } else if (crop) {\n    JDIMENSION tmp;\n\n    /* Check for valid crop dimensions.  We cannot check these values until\n     * after jpeg_start_decompress() is called.\n     */\n    if ((unsigned long long)crop_x + crop_width > cinfo.output_width ||\n        (unsigned long long)crop_y + crop_height > cinfo.output_height) {\n      fprintf(stderr, \"%s: crop dimensions exceed image dimensions %u x %u\\n\",\n              progname, cinfo.output_width, cinfo.output_height);\n      exit(EXIT_FAILURE);\n    }\n\n    if (cinfo.data_precision == 16)\n      ERREXIT(&cinfo, JERR_NOTIMPL);\n    else if (cinfo.data_precision == 12)\n      jpeg12_crop_scanline(&cinfo, &crop_x, &crop_width);\n    else\n      jpeg_crop_scanline(&cinfo, &crop_x, &crop_width);\n    if (dest_mgr->calc_buffer_dimensions)\n      (*dest_mgr->calc_buffer_dimensions) (&cinfo, dest_mgr);\n    else\n      ERREXIT(&cinfo, JERR_UNSUPPORTED_FORMAT);\n\n    /* Write output file header.  This is a hack to ensure that the destination\n     * manager creates an output image of the proper size.\n     */\n    tmp = cinfo.output_height;\n    cinfo.output_height = crop_height;\n    (*dest_mgr->start_output) (&cinfo, dest_mgr);\n    cinfo.output_height = tmp;\n\n    if (cinfo.data_precision == 16)\n      ERREXIT(&cinfo, JERR_NOTIMPL);\n    else if (cinfo.data_precision == 12) {\n      /* Process data */\n      if ((tmp = jpeg12_skip_scanlines(&cinfo, crop_y)) != crop_y) {\n        fprintf(stderr, \"%s: jpeg12_skip_scanlines() returned %u rather than %u\\n\",\n                progname, tmp, crop_y);\n        exit(EXIT_FAILURE);\n      }\n      while (cinfo.output_scanline < crop_y + crop_height) {\n        num_scanlines = jpeg12_read_scanlines(&cinfo, dest_mgr->buffer12,\n                                              dest_mgr->buffer_height);\n        (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);\n      }\n      if ((tmp =\n           jpeg12_skip_scanlines(&cinfo, cinfo.output_height - crop_y -\n                                         crop_height)) !=\n          cinfo.output_height - crop_y - crop_height) {\n        fprintf(stderr, \"%s: jpeg12_skip_scanlines() returned %u rather than %u\\n\",\n                progname, tmp, cinfo.output_height - crop_y - crop_height);\n        exit(EXIT_FAILURE);\n      }\n    } else {\n      /* Process data */\n      if ((tmp = jpeg_skip_scanlines(&cinfo, crop_y)) != crop_y) {\n        fprintf(stderr, \"%s: jpeg_skip_scanlines() returned %u rather than %u\\n\",\n                progname, tmp, crop_y);\n        exit(EXIT_FAILURE);\n      }\n      while (cinfo.output_scanline < crop_y + crop_height) {\n        num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,\n                                            dest_mgr->buffer_height);\n        (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);\n      }\n      if ((tmp =\n           jpeg_skip_scanlines(&cinfo,\n                               cinfo.output_height - crop_y - crop_height)) !=\n          cinfo.output_height - crop_y - crop_height) {\n        fprintf(stderr, \"%s: jpeg_skip_scanlines() returned %u rather than %u\\n\",\n                progname, tmp, cinfo.output_height - crop_y - crop_height);\n        exit(EXIT_FAILURE);\n      }\n    }\n\n  /* Normal full-image decompress */\n  } else {\n    /* Write output file header */\n    (*dest_mgr->start_output) (&cinfo, dest_mgr);\n\n    if (cinfo.data_precision == 16) {\n#ifdef D_LOSSLESS_SUPPORTED\n      /* Process data */\n      while (cinfo.output_scanline < cinfo.output_height) {\n        num_scanlines = jpeg16_read_scanlines(&cinfo, dest_mgr->buffer16,\n                                              dest_mgr->buffer_height);\n        (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);\n      }\n#else\n      ERREXIT1(&cinfo, JERR_BAD_PRECISION, cinfo.data_precision);\n#endif\n    } else if (cinfo.data_precision == 12) {\n      /* Process data */\n      while (cinfo.output_scanline < cinfo.output_height) {\n        num_scanlines = jpeg12_read_scanlines(&cinfo, dest_mgr->buffer12,\n                                              dest_mgr->buffer_height);\n        (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);\n      }\n    } else {\n      /* Process data */\n      while (cinfo.output_scanline < cinfo.output_height) {\n        num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,\n                                            dest_mgr->buffer_height);\n        (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);\n      }\n    }\n  }\n\n  /* Hack: count final pass as done in case finish_output does an extra pass.\n   * The library won't have updated completed_passes.\n   */\n  if (report || max_scans != 0)\n    progress.pub.completed_passes = progress.pub.total_passes;\n\n  if (icc_filename != NULL) {\n    FILE *icc_file;\n    JOCTET *icc_profile;\n    unsigned int icc_len;\n\n    if ((icc_file = fopen(icc_filename, WRITE_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, icc_filename);\n      exit(EXIT_FAILURE);\n    }\n    if (jpeg_read_icc_profile(&cinfo, &icc_profile, &icc_len)) {\n      if (fwrite(icc_profile, icc_len, 1, icc_file) < 1) {\n        fprintf(stderr, \"%s: can't read ICC profile from %s\\n\", progname,\n                icc_filename);\n        free(icc_profile);\n        fclose(icc_file);\n        exit(EXIT_FAILURE);\n      }\n      free(icc_profile);\n      fclose(icc_file);\n    } else if (cinfo.err->msg_code != JWRN_BOGUS_ICC)\n      fprintf(stderr, \"%s: no ICC profile data in JPEG file\\n\", progname);\n  }\n\n  /* Finish decompression and release memory.\n   * I must do it in this order because output module has allocated memory\n   * of lifespan JPOOL_IMAGE; it needs to finish before releasing memory.\n   */\n  (*dest_mgr->finish_output) (&cinfo, dest_mgr);\n  (void)jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n\n  /* Close files, if we opened them */\n  if (input_file != stdin)\n    fclose(input_file);\n  if (output_file != stdout)\n    fclose(output_file);\n\n  if (report || max_scans != 0)\n    end_progress_monitor((j_common_ptr)&cinfo);\n\n  if (memsrc)\n    free(inbuffer);\n\n  /* All done. */\n  exit(jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);\n  return 0;                     /* suppress no-return-value warnings */\n}\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "doxygen-extra.css",
          "type": "blob",
          "size": 0.0693359375,
          "content": "code {\n\tcolor: #4665A2;\n}\n\nth.markdownTableHeadNone {\n\tcolor: black;\n}\n"
        },
        {
          "name": "doxygen.config",
          "type": "blob",
          "size": 0.3935546875,
          "content": "PROJECT_NAME = TurboJPEG\nPROJECT_NUMBER = 3.0.1\nOUTPUT_DIRECTORY = doc/\nUSE_WINDOWS_ENCODING = NO\nOPTIMIZE_OUTPUT_FOR_C = YES\nWARN_NO_PARAMDOC = YES\nGENERATE_LATEX = NO\nFILE_PATTERNS = turbojpeg.h\nHIDE_UNDOC_MEMBERS = YES\nVERBATIM_HEADERS = NO\nEXTRACT_STATIC = YES\nJAVADOC_AUTOBRIEF = YES\nMAX_INITIALIZER_LINES = 0\nALWAYS_DETAILED_SEC = YES\nHTML_TIMESTAMP = NO\nHTML_EXTRA_STYLESHEET = doxygen-extra.css\n"
        },
        {
          "name": "example.c",
          "type": "blob",
          "size": 23.6396484375,
          "content": "/*\n * example.c\n *\n * This file was part of the Independent JPEG Group's software.\n * Copyright (C) 1992-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2017, 2019, 2022-2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file illustrates how to use the IJG code as a subroutine library\n * to read or write JPEG image files with 8-bit or 12-bit data precision.  You\n * should look at this code in conjunction with the documentation file\n * libjpeg.txt.\n *\n * We present these routines in the same coding style used in the JPEG code\n * (ANSI function definitions, etc); but you are of course free to code your\n * routines in a different style if you prefer.\n */\n\n/* First-time users of libjpeg-turbo might be better served by looking at\n * tjexample.c, which uses the more straightforward TurboJPEG API.  Note that\n * this example, like cjpeg and djpeg, interleaves disk I/O with JPEG\n * compression/decompression, so it is not suitable for benchmarking purposes.\n */\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#define strcasecmp  stricmp\n#define strncasecmp  strnicmp\n#endif\n\n/*\n * Include file for users of JPEG library.\n * You will need to have included system headers that define at least\n * the typedefs FILE and size_t before you can include jpeglib.h.\n * (stdio.h is sufficient on ANSI-conforming systems.)\n * You may also wish to include \"jerror.h\".\n */\n\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n\n/*\n * <setjmp.h> is used for the optional error recovery mechanism shown in\n * the second part of the example.\n */\n\n#include <setjmp.h>\n\n\n\n/******************** JPEG COMPRESSION SAMPLE INTERFACE *******************/\n\n/* This half of the example shows how to feed data into the JPEG compressor.\n * We present a minimal version that does not worry about refinements such\n * as error recovery (the JPEG code will just exit() if it gets an error).\n */\n\n\n/*\n * IMAGE DATA FORMATS:\n *\n * The standard input image format is a rectangular array of pixels, with\n * each pixel having the same number of \"component\" values (color channels).\n * Each pixel row is an array of JSAMPLEs (which typically are unsigned chars)\n * or J12SAMPLEs (which typically are shorts).  If you are working with color\n * data, then the color values for each pixel must be adjacent in the row; for\n * example, R,G,B,R,G,B,R,G,B,... for 24-bit RGB color.\n *\n * For this example, we'll assume that this data structure matches the way\n * our application has stored the image in memory, so we can just pass a\n * pointer to our image buffer.  In particular, let's say that the image is\n * RGB color and is described by:\n */\n\n#define WIDTH  640              /* Number of columns in image */\n#define HEIGHT  480             /* Number of rows in image */\n\n\n/*\n * Sample routine for JPEG compression.  We assume that the target file name,\n * a compression quality factor, and a data precision are passed in.\n */\n\nMETHODDEF(void)\nwrite_JPEG_file(char *filename, int quality, int data_precision)\n{\n  /* This struct contains the JPEG compression parameters and pointers to\n   * working space (which is allocated as needed by the JPEG library).\n   * It is possible to have several such structures, representing multiple\n   * compression/decompression processes, in existence at once.  We refer\n   * to any one struct (and its associated working data) as a \"JPEG object\".\n   */\n  struct jpeg_compress_struct cinfo;\n  /* This struct represents a JPEG error handler.  It is declared separately\n   * because applications often want to supply a specialized error handler\n   * (see the second half of this file for an example).  But here we just\n   * take the easy way out and use the standard error handler, which will\n   * print a message on stderr and call exit() if compression fails.\n   * Note that this struct must live as long as the main JPEG parameter\n   * struct, to avoid dangling-pointer problems.\n   */\n  struct jpeg_error_mgr jerr;\n  /* More stuff */\n  FILE *outfile;                /* target file */\n  JSAMPARRAY image_buffer = NULL;\n                                /* Points to large array of R,G,B-order data */\n  JSAMPROW row_pointer[1];      /* pointer to JSAMPLE row[s] */\n  J12SAMPARRAY image_buffer12 = NULL;\n                                /* Points to large array of R,G,B-order 12-bit\n                                   data */\n  J12SAMPROW row_pointer12[1];  /* pointer to J12SAMPLE row[s] */\n  int row_stride;               /* physical row width in image buffer */\n  int row, col;\n\n  /* Step 1: allocate and initialize JPEG compression object */\n\n  /* We have to set up the error handler first, in case the initialization\n   * step fails.  (Unlikely, but it could happen if you are out of memory.)\n   * This routine fills in the contents of struct jerr, and returns jerr's\n   * address which we place into the link field in cinfo.\n   */\n  cinfo.err = jpeg_std_error(&jerr);\n  /* Now we can initialize the JPEG compression object. */\n  jpeg_create_compress(&cinfo);\n  jpeg_c_set_int_param(&cinfo, JINT_COMPRESS_PROFILE, JCP_FASTEST);\n\n  /* Step 2: specify data destination (eg, a file) */\n  /* Note: steps 2 and 3 can be done in either order. */\n\n  /* Here we use the library-supplied code to send compressed data to a\n   * stdio stream.  You can also write your own code to do something else.\n   * VERY IMPORTANT: use \"b\" option to fopen() if you are on a machine that\n   * requires it in order to write binary files.\n   */\n  if ((outfile = fopen(filename, \"wb\")) == NULL)\n    ERREXIT(&cinfo, JERR_FILE_WRITE);\n  jpeg_stdio_dest(&cinfo, outfile);\n\n  /* Step 3: set parameters for compression */\n\n  /* First we supply a description of the input image.\n   * Four fields of the cinfo struct must be filled in:\n   */\n  cinfo.image_width = WIDTH;            /* image width and height, in pixels */\n  cinfo.image_height = HEIGHT;\n  cinfo.input_components = 3;           /* # of color components per pixel */\n  cinfo.in_color_space = JCS_RGB;       /* colorspace of input image */\n  cinfo.data_precision = data_precision; /* data precision of input image */\n  /* Now use the library's routine to set default compression parameters.\n   * (You must set at least cinfo.in_color_space before calling this,\n   * since the defaults depend on the source color space.)\n   */\n  jpeg_set_defaults(&cinfo);\n  /* Now you can set any non-default parameters you wish to.\n   * Here we just illustrate the use of quality (quantization table) scaling:\n   */\n  jpeg_set_quality(&cinfo, quality, TRUE /* limit to baseline-JPEG values */);\n  /* Use 4:4:4 subsampling (default is 4:2:0) */\n  cinfo.comp_info[0].h_samp_factor = cinfo.comp_info[0].v_samp_factor = 1;\n\n  /* Step 4: Start compressor */\n\n  /* TRUE ensures that we will write a complete interchange-JPEG file.\n   * Pass TRUE unless you are very sure of what you're doing.\n   */\n  jpeg_start_compress(&cinfo, TRUE);\n\n  /* Step 5: allocate and initialize image buffer */\n\n  row_stride = WIDTH * 3;       /* J[12]SAMPLEs per row in image_buffer */\n  /* Make a sample array that will go away when done with image.  Note that,\n   * for the purposes of this example, we could also create a one-row-high\n   * sample array and initialize it for each successive scanline written in the\n   * scanline loop below.\n   */\n  if (cinfo.data_precision == 12) {\n    image_buffer12 = (J12SAMPARRAY)(*cinfo.mem->alloc_sarray)\n      ((j_common_ptr)&cinfo, JPOOL_IMAGE, row_stride, HEIGHT);\n\n    /* Initialize image buffer with a repeating pattern */\n    for (row = 0; row < HEIGHT; row++) {\n      for (col = 0; col < WIDTH; col++) {\n        image_buffer12[row][col * 3] =\n          (col * (MAXJ12SAMPLE + 1) / WIDTH) % (MAXJ12SAMPLE + 1);\n        image_buffer12[row][col * 3 + 1] =\n          (row * (MAXJ12SAMPLE + 1) / HEIGHT) % (MAXJ12SAMPLE + 1);\n        image_buffer12[row][col * 3 + 2] =\n          (row * (MAXJ12SAMPLE + 1) / HEIGHT +\n           col * (MAXJ12SAMPLE + 1) / WIDTH) % (MAXJ12SAMPLE + 1);\n      }\n    }\n  } else {\n    image_buffer = (*cinfo.mem->alloc_sarray)\n      ((j_common_ptr)&cinfo, JPOOL_IMAGE, row_stride, HEIGHT);\n\n    for (row = 0; row < HEIGHT; row++) {\n      for (col = 0; col < WIDTH; col++) {\n        image_buffer[row][col * 3] =\n          (col * (MAXJSAMPLE + 1) / WIDTH) % (MAXJSAMPLE + 1);\n        image_buffer[row][col * 3 + 1] =\n          (row * (MAXJSAMPLE + 1) / HEIGHT) % (MAXJSAMPLE + 1);\n        image_buffer[row][col * 3 + 2] =\n          (row * (MAXJSAMPLE + 1) / HEIGHT + col * (MAXJSAMPLE + 1) / WIDTH) %\n          (MAXJSAMPLE + 1);\n      }\n    }\n  }\n\n  /* Step 6: while (scan lines remain to be written) */\n  /*           jpeg_write_scanlines(...); */\n\n  /* Here we use the library's state variable cinfo.next_scanline as the\n   * loop counter, so that we don't have to keep track ourselves.\n   * To keep things simple, we pass one scanline per call; you can pass\n   * more if you wish, though.\n   */\n  if (cinfo.data_precision == 12) {\n    while (cinfo.next_scanline < cinfo.image_height) {\n      /* jpeg12_write_scanlines expects an array of pointers to scanlines.\n       * Here the array is only one element long, but you could pass\n       * more than one scanline at a time if that's more convenient.\n       */\n      row_pointer12[0] = image_buffer12[cinfo.next_scanline];\n      (void)jpeg12_write_scanlines(&cinfo, row_pointer12, 1);\n    }\n  } else {\n    while (cinfo.next_scanline < cinfo.image_height) {\n      /* jpeg_write_scanlines expects an array of pointers to scanlines.\n       * Here the array is only one element long, but you could pass\n       * more than one scanline at a time if that's more convenient.\n       */\n      row_pointer[0] = image_buffer[cinfo.next_scanline];\n      (void)jpeg_write_scanlines(&cinfo, row_pointer, 1);\n    }\n  }\n\n  /* Step 7: Finish compression */\n\n  jpeg_finish_compress(&cinfo);\n  /* After finish_compress, we can close the output file. */\n  fclose(outfile);\n\n  /* Step 8: release JPEG compression object */\n\n  /* This is an important step since it will release a good deal of memory. */\n  jpeg_destroy_compress(&cinfo);\n\n  /* And we're done! */\n}\n\n\n/*\n * SOME FINE POINTS:\n *\n * In the above loop, we ignored the return value of jpeg_write_scanlines,\n * which is the number of scanlines actually written.  We could get away\n * with this because we were only relying on the value of cinfo.next_scanline,\n * which will be incremented correctly.  If you maintain additional loop\n * variables then you should be careful to increment them properly.\n * Actually, for output to a stdio stream you needn't worry, because\n * then jpeg_write_scanlines will write all the lines passed (or else exit\n * with a fatal error).  Partial writes can only occur if you use a data\n * destination module that can demand suspension of the compressor.\n * (If you don't know what that's for, you don't need it.)\n *\n * Scanlines MUST be supplied in top-to-bottom order if you want your JPEG\n * files to be compatible with everyone else's.  If you cannot readily read\n * your data in that order, you'll need an intermediate array to hold the\n * image.  See rdtarga.c or rdbmp.c for examples of handling bottom-to-top\n * source data using the JPEG code's internal virtual-array mechanisms.\n */\n\n\n\n/******************** JPEG DECOMPRESSION SAMPLE INTERFACE *******************/\n\n/* This half of the example shows how to read data from the JPEG decompressor.\n * It's a bit more refined than the above, in that we show:\n *   (a) how to modify the JPEG library's standard error-reporting behavior;\n *   (b) how to allocate workspace using the library's memory manager.\n *\n * Just to make this example a little different from the first one, we'll\n * assume that we do not intend to put the whole image into an in-memory\n * buffer, but to send it line-by-line someplace else.  We need a one-\n * scanline-high JSAMPLE or J12SAMPLE array as a work buffer, and we will let\n * the JPEG memory manager allocate it for us.  This approach is actually quite\n * useful because we don't need to remember to deallocate the buffer\n * separately: it will go away automatically when the JPEG object is cleaned\n * up.\n */\n\n\n/*\n * ERROR HANDLING:\n *\n * The JPEG library's standard error handler (jerror.c) is divided into\n * several \"methods\" which you can override individually.  This lets you\n * adjust the behavior without duplicating a lot of code, which you might\n * have to update with each future release.\n *\n * Our example here shows how to override the \"error_exit\" method so that\n * control is returned to the library's caller when a fatal error occurs,\n * rather than calling exit() as the standard error_exit method does.\n *\n * We use C's setjmp/longjmp facility to return control.  This means that the\n * routine which calls the JPEG library must first execute a setjmp() call to\n * establish the return point.  We want the replacement error_exit to do a\n * longjmp().  But we need to make the setjmp buffer accessible to the\n * error_exit routine.  To do this, we make a private extension of the\n * standard JPEG error handler object.  (If we were using C++, we'd say we\n * were making a subclass of the regular error handler.)\n *\n * Here's the extended error handler struct:\n */\n\nstruct my_error_mgr {\n  struct jpeg_error_mgr pub;    /* \"public\" fields */\n\n  jmp_buf setjmp_buffer;        /* for return to caller */\n};\n\ntypedef struct my_error_mgr *my_error_ptr;\n\n/*\n * Here's the routine that will replace the standard error_exit method:\n */\n\nMETHODDEF(void)\nmy_error_exit(j_common_ptr cinfo)\n{\n  /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */\n  my_error_ptr myerr = (my_error_ptr)cinfo->err;\n\n  /* Always display the message. */\n  /* We could postpone this until after returning, if we chose. */\n  (*cinfo->err->output_message) (cinfo);\n\n  /* Return control to the setjmp point */\n  longjmp(myerr->setjmp_buffer, 1);\n}\n\n\nMETHODDEF(int) do_read_JPEG_file(struct jpeg_decompress_struct *cinfo,\n                                 char *infilename, char *outfilename);\n\n/*\n * Sample routine for JPEG decompression.  We assume that the source file name\n * is passed in.  We want to return 1 on success, 0 on error.\n */\n\nMETHODDEF(int)\nread_JPEG_file(char *infilename, char *outfilename)\n{\n  /* This struct contains the JPEG decompression parameters and pointers to\n   * working space (which is allocated as needed by the JPEG library).\n   */\n  struct jpeg_decompress_struct cinfo;\n\n  return do_read_JPEG_file(&cinfo, infilename, outfilename);\n}\n\n/*\n * We call the libjpeg API from within a separate function, because modifying\n * the local non-volatile jpeg_decompress_struct instance below the setjmp()\n * return point and then accessing the instance after setjmp() returns would\n * result in undefined behavior that may potentially overwrite all or part of\n * the structure.\n */\n\nMETHODDEF(int)\ndo_read_JPEG_file(struct jpeg_decompress_struct *cinfo, char *infilename,\n                  char *outfilename)\n{\n  /* We use our private extension JPEG error handler.\n   * Note that this struct must live as long as the main JPEG parameter\n   * struct, to avoid dangling-pointer problems.\n   */\n  struct my_error_mgr jerr;\n  /* More stuff */\n  FILE *infile;                 /* source file */\n  FILE *outfile;                /* output file */\n  JSAMPARRAY buffer = NULL;     /* Output row buffer */\n  J12SAMPARRAY buffer12 = NULL; /* 12-bit output row buffer */\n  int col;\n  int row_stride;               /* physical row width in output buffer */\n  int little_endian = 1;\n\n  /* In this example we want to open the input and output files before doing\n   * anything else, so that the setjmp() error recovery below can assume the\n   * files are open.\n   *\n   * VERY IMPORTANT: use \"b\" option to fopen() if you are on a machine that\n   * requires it in order to read/write binary files.\n   */\n\n  if ((infile = fopen(infilename, \"rb\")) == NULL) {\n    fprintf(stderr, \"can't open %s\\n\", infilename);\n    return 0;\n  }\n  if ((outfile = fopen(outfilename, \"wb\")) == NULL) {\n    fprintf(stderr, \"can't open %s\\n\", outfilename);\n    fclose(infile);\n    return 0;\n  }\n\n  /* Step 1: allocate and initialize JPEG decompression object */\n\n  /* We set up the normal JPEG error routines, then override error_exit. */\n  cinfo->err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = my_error_exit;\n  /* Establish the setjmp return context for my_error_exit to use. */\n  if (setjmp(jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error.\n     * We need to clean up the JPEG object, close the input file, and return.\n     */\n    jpeg_destroy_decompress(cinfo);\n    fclose(infile);\n    fclose(outfile);\n    return 0;\n  }\n  /* Now we can initialize the JPEG decompression object. */\n  jpeg_create_decompress(cinfo);\n\n  /* Step 2: specify data source (eg, a file) */\n\n  jpeg_stdio_src(cinfo, infile);\n\n  /* Step 3: read file parameters with jpeg_read_header() */\n\n  (void)jpeg_read_header(cinfo, TRUE);\n  /* We can ignore the return value from jpeg_read_header since\n   *   (a) suspension is not possible with the stdio data source, and\n   *   (b) we passed TRUE to reject a tables-only JPEG file as an error.\n   * See libjpeg.txt for more info.\n   */\n\n  /* emit header for raw PPM format */\n  fprintf(outfile, \"P6\\n%u %u\\n%d\\n\", cinfo->image_width, cinfo->image_height,\n          cinfo->data_precision == 12 ? MAXJ12SAMPLE : MAXJSAMPLE);\n\n  /* Step 4: set parameters for decompression */\n\n  /* In this example, we don't need to change any of the defaults set by\n   * jpeg_read_header(), so we do nothing here.\n   */\n\n  /* Step 5: Start decompressor */\n\n  (void)jpeg_start_decompress(cinfo);\n  /* We can ignore the return value since suspension is not possible\n   * with the stdio data source.\n   */\n\n  /* We may need to do some setup of our own at this point before reading\n   * the data.  After jpeg_start_decompress() we have the correct scaled\n   * output image dimensions available, as well as the output colormap\n   * if we asked for color quantization.\n   * In this example, we need to make an output work buffer of the right size.\n   */\n  /* Samples per row in output buffer */\n  row_stride = cinfo->output_width * cinfo->output_components;\n  /* Make a one-row-high sample array that will go away when done with image */\n  if (cinfo->data_precision == 12)\n    buffer12 = (J12SAMPARRAY)(*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, row_stride, 1);\n  else\n    buffer = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, row_stride, 1);\n\n  /* Step 6: while (scan lines remain to be read) */\n  /*           jpeg_read_scanlines(...); */\n\n  /* Here we use the library's state variable cinfo->output_scanline as the\n   * loop counter, so that we don't have to keep track ourselves.\n   */\n  if (cinfo->data_precision == 12) {\n    while (cinfo->output_scanline < cinfo->output_height) {\n      /* jpeg12_read_scanlines expects an array of pointers to scanlines.\n       * Here the array is only one element long, but you could ask for\n       * more than one scanline at a time if that's more convenient.\n       */\n      (void)jpeg12_read_scanlines(cinfo, buffer12, 1);\n      if (*(char *)&little_endian == 1) {\n        /* Swap MSB and LSB in each sample */\n        for (col = 0; col < row_stride; col++)\n          buffer12[0][col] = ((buffer12[0][col] & 0xFF) << 8) |\n                             ((buffer12[0][col] >> 8) & 0xFF);\n      }\n      fwrite(buffer12[0], 1, row_stride * sizeof(J12SAMPLE), outfile);\n    }\n  } else {\n    while (cinfo->output_scanline < cinfo->output_height) {\n      /* jpeg_read_scanlines expects an array of pointers to scanlines.\n       * Here the array is only one element long, but you could ask for\n       * more than one scanline at a time if that's more convenient.\n       */\n      (void)jpeg_read_scanlines(cinfo, buffer, 1);\n      fwrite(buffer[0], 1, row_stride, outfile);\n    }\n  }\n\n  /* Step 7: Finish decompression */\n\n  (void)jpeg_finish_decompress(cinfo);\n  /* We can ignore the return value since suspension is not possible\n   * with the stdio data source.\n   */\n\n  /* Step 8: Release JPEG decompression object */\n\n  /* This is an important step since it will release a good deal of memory. */\n  jpeg_destroy_decompress(cinfo);\n\n  /* After finish_decompress, we can close the input and output files.\n   * Here we postpone it until after no more JPEG errors are possible,\n   * so as to simplify the setjmp error logic above.  (Actually, I don't\n   * think that jpeg_destroy can do an error exit, but why assume anything...)\n   */\n  fclose(infile);\n  fclose(outfile);\n\n  /* At this point you may want to check to see whether any corrupt-data\n   * warnings occurred (test whether jerr.pub.num_warnings is nonzero).\n   */\n\n  /* And we're done! */\n  return 1;\n}\n\n\n/*\n * SOME FINE POINTS:\n *\n * In the above code, we ignored the return value of jpeg_read_scanlines,\n * which is the number of scanlines actually read.  We could get away with\n * this because we asked for only one line at a time and we weren't using\n * a suspending data source.  See libjpeg.txt for more info.\n *\n * We cheated a bit by calling alloc_sarray() after jpeg_start_decompress();\n * we should have done it beforehand to ensure that the space would be\n * counted against the JPEG max_memory setting.  In some systems the above\n * code would risk an out-of-memory error.  However, in general we don't\n * know the output image dimensions before jpeg_start_decompress(), unless we\n * call jpeg_calc_output_dimensions().  See libjpeg.txt for more about this.\n *\n * Scanlines are returned in the same order as they appear in the JPEG file,\n * which is standardly top-to-bottom.  If you must emit data bottom-to-top,\n * you can use one of the virtual arrays provided by the JPEG memory manager\n * to invert the data.  See wrbmp.c for an example.\n */\n\n\nLOCAL(void)\nusage(const char *progname)\n{\n  fprintf(stderr, \"usage: %s compress [switches] outputfile[.jpg]\\n\",\n          progname);\n  fprintf(stderr, \"       %s decompress inputfile[.jpg] outputfile[.ppm]\\n\",\n          progname);\n  fprintf(stderr, \"Switches (names may be abbreviated):\\n\");\n  fprintf(stderr, \"  -precision N   Create JPEG file with N-bit data precision\\n\");\n  fprintf(stderr, \"                 (N is 8 or 12; default is 8)\\n\");\n  fprintf(stderr, \"  -quality N     Compression quality (0..100; 5-95 is most useful range,\\n\");\n  fprintf(stderr, \"                 default is 75)\\n\");\n\n  exit(EXIT_FAILURE);\n}\n\n\ntypedef enum {\n  COMPRESS,\n  DECOMPRESS\n} EXAMPLE_MODE;\n\n\nint\nmain(int argc, char **argv)\n{\n  int argn, quality = 75;\n  int data_precision = 8;\n  EXAMPLE_MODE mode = -1;\n  char *arg, *filename = NULL;\n\n  if (argc < 3)\n    usage(argv[0]);\n\n  if (!strcasecmp(argv[1], \"compress\"))\n    mode = COMPRESS;\n  else if (!strcasecmp(argv[1], \"decompress\"))\n    mode = DECOMPRESS;\n  else\n    usage(argv[0]);\n\n  for (argn = 2; argn < argc; argn++) {\n    arg = argv[argn];\n    if (*arg != '-') {\n      filename = arg;\n      /* Not a switch, must be a file name argument */\n      break;                    /* done parsing switches */\n    }\n    arg++;                      /* advance past switch marker character */\n\n    if (!strncasecmp(arg, \"p\", 1)) {\n      /* Set data precision. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage(argv[0]);\n      if (sscanf(argv[argn], \"%d\", &data_precision) < 1 ||\n          (data_precision != 8 && data_precision != 12))\n        usage(argv[0]);\n    } else if (!strncasecmp(arg, \"q\", 1)) {\n      /* Quality rating (quantization table scaling factor). */\n      if (++argn >= argc)       /* advance to next argument */\n        usage(argv[0]);\n      if (sscanf(argv[argn], \"%d\", &quality) < 1 || quality < 0 ||\n          quality > 100)\n        usage(argv[0]);\n      if (quality < 1)\n        quality = 1;\n    }\n  }\n\n  if (!filename)\n    usage(argv[0]);\n\n  if (mode == COMPRESS)\n    write_JPEG_file(filename, quality, data_precision);\n  else if (mode == DECOMPRESS) {\n    if (argc - argn < 2)\n      usage(argv[0]);\n\n    read_JPEG_file(argv[argn], argv[argn + 1]);\n  }\n\n  return 0;\n}\n"
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "jaricom.c",
          "type": "blob",
          "size": 5.01171875,
          "content": "/*\n * jaricom.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Developed 1997-2009 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015, 2018, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains probability estimation tables for common use in\n * arithmetic entropy encoding and decoding routines.\n *\n * This data represents Table D.2 in\n * Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994 and Table 24 in\n * Recommendation ITU-T T.82 (1993) | ISO/IEC 11544:1993.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n\n/* The following #define specifies the packing of the four components\n * into the compact JLONG representation.\n * Note that this formula must match the actual arithmetic encoder\n * and decoder implementation.  The implementation has to be changed\n * if this formula is changed.\n * The current organization is leaned on Markus Kuhn's JBIG\n * implementation (jbig_tab.c).\n */\n\n#define V(i, a, b, c, d) \\\n  (((JLONG)a << 16) | ((JLONG)c << 8) | ((JLONG)d << 7) | b)\n\nconst JLONG jpeg_aritab[113 + 1] = {\n/*\n * Index, Qe_Value, Next_Index_LPS, Next_Index_MPS, Switch_MPS\n */\n  V(   0, 0x5a1d,   1,   1, 1 ),\n  V(   1, 0x2586,  14,   2, 0 ),\n  V(   2, 0x1114,  16,   3, 0 ),\n  V(   3, 0x080b,  18,   4, 0 ),\n  V(   4, 0x03d8,  20,   5, 0 ),\n  V(   5, 0x01da,  23,   6, 0 ),\n  V(   6, 0x00e5,  25,   7, 0 ),\n  V(   7, 0x006f,  28,   8, 0 ),\n  V(   8, 0x0036,  30,   9, 0 ),\n  V(   9, 0x001a,  33,  10, 0 ),\n  V(  10, 0x000d,  35,  11, 0 ),\n  V(  11, 0x0006,   9,  12, 0 ),\n  V(  12, 0x0003,  10,  13, 0 ),\n  V(  13, 0x0001,  12,  13, 0 ),\n  V(  14, 0x5a7f,  15,  15, 1 ),\n  V(  15, 0x3f25,  36,  16, 0 ),\n  V(  16, 0x2cf2,  38,  17, 0 ),\n  V(  17, 0x207c,  39,  18, 0 ),\n  V(  18, 0x17b9,  40,  19, 0 ),\n  V(  19, 0x1182,  42,  20, 0 ),\n  V(  20, 0x0cef,  43,  21, 0 ),\n  V(  21, 0x09a1,  45,  22, 0 ),\n  V(  22, 0x072f,  46,  23, 0 ),\n  V(  23, 0x055c,  48,  24, 0 ),\n  V(  24, 0x0406,  49,  25, 0 ),\n  V(  25, 0x0303,  51,  26, 0 ),\n  V(  26, 0x0240,  52,  27, 0 ),\n  V(  27, 0x01b1,  54,  28, 0 ),\n  V(  28, 0x0144,  56,  29, 0 ),\n  V(  29, 0x00f5,  57,  30, 0 ),\n  V(  30, 0x00b7,  59,  31, 0 ),\n  V(  31, 0x008a,  60,  32, 0 ),\n  V(  32, 0x0068,  62,  33, 0 ),\n  V(  33, 0x004e,  63,  34, 0 ),\n  V(  34, 0x003b,  32,  35, 0 ),\n  V(  35, 0x002c,  33,   9, 0 ),\n  V(  36, 0x5ae1,  37,  37, 1 ),\n  V(  37, 0x484c,  64,  38, 0 ),\n  V(  38, 0x3a0d,  65,  39, 0 ),\n  V(  39, 0x2ef1,  67,  40, 0 ),\n  V(  40, 0x261f,  68,  41, 0 ),\n  V(  41, 0x1f33,  69,  42, 0 ),\n  V(  42, 0x19a8,  70,  43, 0 ),\n  V(  43, 0x1518,  72,  44, 0 ),\n  V(  44, 0x1177,  73,  45, 0 ),\n  V(  45, 0x0e74,  74,  46, 0 ),\n  V(  46, 0x0bfb,  75,  47, 0 ),\n  V(  47, 0x09f8,  77,  48, 0 ),\n  V(  48, 0x0861,  78,  49, 0 ),\n  V(  49, 0x0706,  79,  50, 0 ),\n  V(  50, 0x05cd,  48,  51, 0 ),\n  V(  51, 0x04de,  50,  52, 0 ),\n  V(  52, 0x040f,  50,  53, 0 ),\n  V(  53, 0x0363,  51,  54, 0 ),\n  V(  54, 0x02d4,  52,  55, 0 ),\n  V(  55, 0x025c,  53,  56, 0 ),\n  V(  56, 0x01f8,  54,  57, 0 ),\n  V(  57, 0x01a4,  55,  58, 0 ),\n  V(  58, 0x0160,  56,  59, 0 ),\n  V(  59, 0x0125,  57,  60, 0 ),\n  V(  60, 0x00f6,  58,  61, 0 ),\n  V(  61, 0x00cb,  59,  62, 0 ),\n  V(  62, 0x00ab,  61,  63, 0 ),\n  V(  63, 0x008f,  61,  32, 0 ),\n  V(  64, 0x5b12,  65,  65, 1 ),\n  V(  65, 0x4d04,  80,  66, 0 ),\n  V(  66, 0x412c,  81,  67, 0 ),\n  V(  67, 0x37d8,  82,  68, 0 ),\n  V(  68, 0x2fe8,  83,  69, 0 ),\n  V(  69, 0x293c,  84,  70, 0 ),\n  V(  70, 0x2379,  86,  71, 0 ),\n  V(  71, 0x1edf,  87,  72, 0 ),\n  V(  72, 0x1aa9,  87,  73, 0 ),\n  V(  73, 0x174e,  72,  74, 0 ),\n  V(  74, 0x1424,  72,  75, 0 ),\n  V(  75, 0x119c,  74,  76, 0 ),\n  V(  76, 0x0f6b,  74,  77, 0 ),\n  V(  77, 0x0d51,  75,  78, 0 ),\n  V(  78, 0x0bb6,  77,  79, 0 ),\n  V(  79, 0x0a40,  77,  48, 0 ),\n  V(  80, 0x5832,  80,  81, 1 ),\n  V(  81, 0x4d1c,  88,  82, 0 ),\n  V(  82, 0x438e,  89,  83, 0 ),\n  V(  83, 0x3bdd,  90,  84, 0 ),\n  V(  84, 0x34ee,  91,  85, 0 ),\n  V(  85, 0x2eae,  92,  86, 0 ),\n  V(  86, 0x299a,  93,  87, 0 ),\n  V(  87, 0x2516,  86,  71, 0 ),\n  V(  88, 0x5570,  88,  89, 1 ),\n  V(  89, 0x4ca9,  95,  90, 0 ),\n  V(  90, 0x44d9,  96,  91, 0 ),\n  V(  91, 0x3e22,  97,  92, 0 ),\n  V(  92, 0x3824,  99,  93, 0 ),\n  V(  93, 0x32b4,  99,  94, 0 ),\n  V(  94, 0x2e17,  93,  86, 0 ),\n  V(  95, 0x56a8,  95,  96, 1 ),\n  V(  96, 0x4f46, 101,  97, 0 ),\n  V(  97, 0x47e5, 102,  98, 0 ),\n  V(  98, 0x41cf, 103,  99, 0 ),\n  V(  99, 0x3c3d, 104, 100, 0 ),\n  V( 100, 0x375e,  99,  93, 0 ),\n  V( 101, 0x5231, 105, 102, 0 ),\n  V( 102, 0x4c0f, 106, 103, 0 ),\n  V( 103, 0x4639, 107, 104, 0 ),\n  V( 104, 0x415e, 103,  99, 0 ),\n  V( 105, 0x5627, 105, 106, 1 ),\n  V( 106, 0x50e7, 108, 107, 0 ),\n  V( 107, 0x4b85, 109, 103, 0 ),\n  V( 108, 0x5597, 110, 109, 0 ),\n  V( 109, 0x504f, 111, 107, 0 ),\n  V( 110, 0x5a10, 110, 111, 1 ),\n  V( 111, 0x5522, 112, 109, 0 ),\n  V( 112, 0x59eb, 112, 111, 1 ),\n/*\n * This last entry is used for fixed probability estimate of 0.5\n * as recommended in Section 10.3 Table 5 of ITU-T Rec. T.851.\n */\n  V( 113, 0x5a1d, 113, 113, 0 )\n};\n"
        },
        {
          "name": "java",
          "type": "tree",
          "content": null
        },
        {
          "name": "jcapimin.c",
          "type": "blob",
          "size": 10.7197265625,
          "content": "/*\n * jcapimin.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1998, Thomas G. Lane.\n * Modified 2003-2010 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains application interface code for the compression half\n * of the JPEG library.  These are the \"minimum\" API routines that may be\n * needed in either the normal full-compression case or the transcoding-only\n * case.\n *\n * Most of the routines intended to be called directly by an application\n * are in this file or in jcapistd.c.  But also see jcparam.c for\n * parameter-setup helper routines, jcomapi.c for routines shared by\n * compression and decompression, and jctrans.c for the transcoding case.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jcmaster.h\"\n\n\n/*\n * Initialization of a JPEG compression object.\n * The error manager must already be set up (in case memory manager fails).\n */\n\nGLOBAL(void)\njpeg_CreateCompress(j_compress_ptr cinfo, int version, size_t structsize)\n{\n  int i;\n\n  /* Guard against version mismatches between library and caller. */\n  cinfo->mem = NULL;            /* so jpeg_destroy knows mem mgr not called */\n  if (version != JPEG_LIB_VERSION)\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\n  if (structsize != sizeof(struct jpeg_compress_struct))\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,\n             (int)sizeof(struct jpeg_compress_struct), (int)structsize);\n\n  /* For debugging purposes, we zero the whole master structure.\n   * But the application has already set the err pointer, and may have set\n   * client_data, so we have to save and restore those fields.\n   * Note: if application hasn't set client_data, tools like Purify may\n   * complain here.\n   */\n  {\n    struct jpeg_error_mgr *err = cinfo->err;\n    void *client_data = cinfo->client_data; /* ignore Purify complaint here */\n    memset(cinfo, 0, sizeof(struct jpeg_compress_struct));\n    cinfo->err = err;\n    cinfo->client_data = client_data;\n  }\n  cinfo->is_decompressor = FALSE;\n\n  /* Initialize a memory manager instance for this object */\n  jinit_memory_mgr((j_common_ptr)cinfo);\n\n  /* Zero out pointers to permanent structures. */\n  cinfo->progress = NULL;\n  cinfo->dest = NULL;\n\n  cinfo->comp_info = NULL;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    cinfo->quant_tbl_ptrs[i] = NULL;\n#if JPEG_LIB_VERSION >= 70\n    cinfo->q_scale_factor[i] = 100;\n#endif\n  }\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\n  }\n\n#if JPEG_LIB_VERSION >= 80\n  /* Must do it here for emit_dqt in case jpeg_write_tables is used */\n  cinfo->block_size = DCTSIZE;\n  cinfo->natural_order = jpeg_natural_order;\n  cinfo->lim_Se = DCTSIZE2 - 1;\n#endif\n\n  cinfo->script_space = NULL;\n\n  cinfo->input_gamma = 1.0;     /* in case application forgets */\n\n  cinfo->data_precision = BITS_IN_JSAMPLE;\n\n  /* OK, I'm ready */\n  cinfo->global_state = CSTATE_START;\n\n  /* The master struct is used to store extension parameters, so we allocate it\n   * here.\n   */\n  cinfo->master = (struct jpeg_comp_master *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(my_comp_master));\n  memset(cinfo->master, 0, sizeof(my_comp_master));\n\n  #if BITS_IN_JSAMPLE == 8\n  cinfo->master->compress_profile = JCP_MAX_COMPRESSION;\n  #endif\n}\n\n\n/*\n * Destruction of a JPEG compression object\n */\n\nGLOBAL(void)\njpeg_destroy_compress(j_compress_ptr cinfo)\n{\n  jpeg_destroy((j_common_ptr)cinfo); /* use common routine */\n}\n\n\n/*\n * Abort processing of a JPEG compression operation,\n * but don't destroy the object itself.\n */\n\nGLOBAL(void)\njpeg_abort_compress(j_compress_ptr cinfo)\n{\n  jpeg_abort((j_common_ptr)cinfo); /* use common routine */\n}\n\n\n/*\n * Forcibly suppress or un-suppress all quantization and Huffman tables.\n * Marks all currently defined tables as already written (if suppress)\n * or not written (if !suppress).  This will control whether they get emitted\n * by a subsequent jpeg_start_compress call.\n *\n * This routine is exported for use by applications that want to produce\n * abbreviated JPEG datastreams.  It logically belongs in jcparam.c, but\n * since it is called by jpeg_start_compress, we put it here --- otherwise\n * jcparam.o would be linked whether the application used it or not.\n */\n\nGLOBAL(void)\njpeg_suppress_tables(j_compress_ptr cinfo, boolean suppress)\n{\n  int i;\n  JQUANT_TBL *qtbl;\n  JHUFF_TBL *htbl;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    if ((qtbl = cinfo->quant_tbl_ptrs[i]) != NULL)\n      qtbl->sent_table = suppress;\n  }\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    if ((htbl = cinfo->dc_huff_tbl_ptrs[i]) != NULL)\n      htbl->sent_table = suppress;\n    if ((htbl = cinfo->ac_huff_tbl_ptrs[i]) != NULL)\n      htbl->sent_table = suppress;\n  }\n}\n\n\n/*\n * Finish JPEG compression.\n *\n * If a multipass operating mode was selected, this may do a great deal of\n * work including most of the actual output.\n */\n\nGLOBAL(void)\njpeg_finish_compress(j_compress_ptr cinfo)\n{\n  JDIMENSION iMCU_row;\n\n  if (cinfo->global_state == CSTATE_SCANNING ||\n      cinfo->global_state == CSTATE_RAW_OK) {\n    /* Terminate first pass */\n    if (cinfo->next_scanline < cinfo->image_height)\n      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);\n    (*cinfo->master->finish_pass) (cinfo);\n  } else if (cinfo->global_state != CSTATE_WRCOEFS)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  /* Perform any remaining passes */\n  while (!cinfo->master->is_last_pass) {\n    (*cinfo->master->prepare_for_pass) (cinfo);\n    for (iMCU_row = 0; iMCU_row < cinfo->total_iMCU_rows; iMCU_row++) {\n      if (cinfo->progress != NULL) {\n        cinfo->progress->pass_counter = (long)iMCU_row;\n        cinfo->progress->pass_limit = (long)cinfo->total_iMCU_rows;\n        (*cinfo->progress->progress_monitor) ((j_common_ptr)cinfo);\n      }\n      /* We bypass the main controller and invoke coef controller directly;\n       * all work is being done from the coefficient buffer.\n       */\n      if (cinfo->data_precision == 16) {\n#ifdef C_LOSSLESS_SUPPORTED\n        if (cinfo->coef->compress_data_16 == NULL)\n          ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n        if (!(*cinfo->coef->compress_data_16) (cinfo, (J16SAMPIMAGE)NULL))\n          ERREXIT(cinfo, JERR_CANT_SUSPEND);\n#else\n        ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n#endif\n      } else if (cinfo->data_precision == 12) {\n        if (cinfo->coef->compress_data_12 == NULL)\n          ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n        if (!(*cinfo->coef->compress_data_12) (cinfo, (J12SAMPIMAGE)NULL))\n          ERREXIT(cinfo, JERR_CANT_SUSPEND);\n      } else {\n        if (cinfo->coef->compress_data == NULL)\n          ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n        if (!(*cinfo->coef->compress_data) (cinfo, (JSAMPIMAGE)NULL))\n          ERREXIT(cinfo, JERR_CANT_SUSPEND);\n      }\n    }\n    (*cinfo->master->finish_pass) (cinfo);\n  }\n  /* Write EOI, do final cleanup */\n  (*cinfo->marker->write_file_trailer) (cinfo);\n  (*cinfo->dest->term_destination) (cinfo);\n  /* We can use jpeg_abort to release memory and reset global_state */\n  jpeg_abort((j_common_ptr)cinfo);\n}\n\n\n/*\n * Write a special marker.\n * This is only recommended for writing COM or APPn markers.\n * Must be called after jpeg_start_compress() and before\n * first call to jpeg_write_scanlines() or jpeg_write_raw_data().\n */\n\nGLOBAL(void)\njpeg_write_marker(j_compress_ptr cinfo, int marker, const JOCTET *dataptr,\n                  unsigned int datalen)\n{\n  void (*write_marker_byte) (j_compress_ptr info, int val);\n\n  if (cinfo->next_scanline != 0 ||\n      (cinfo->global_state != CSTATE_SCANNING &&\n       cinfo->global_state != CSTATE_RAW_OK &&\n       cinfo->global_state != CSTATE_WRCOEFS))\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);\n  write_marker_byte = cinfo->marker->write_marker_byte; /* copy for speed */\n  while (datalen--) {\n    (*write_marker_byte) (cinfo, *dataptr);\n    dataptr++;\n  }\n}\n\n/* Same, but piecemeal. */\n\nGLOBAL(void)\njpeg_write_m_header(j_compress_ptr cinfo, int marker, unsigned int datalen)\n{\n  if (cinfo->next_scanline != 0 ||\n      (cinfo->global_state != CSTATE_SCANNING &&\n       cinfo->global_state != CSTATE_RAW_OK &&\n       cinfo->global_state != CSTATE_WRCOEFS))\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);\n}\n\nGLOBAL(void)\njpeg_write_m_byte(j_compress_ptr cinfo, int val)\n{\n  (*cinfo->marker->write_marker_byte) (cinfo, val);\n}\n\n\n/*\n * Alternate compression function: just write an abbreviated table file.\n * Before calling this, all parameters and a data destination must be set up.\n *\n * To produce a pair of files containing abbreviated tables and abbreviated\n * image data, one would proceed as follows:\n *\n *              initialize JPEG object\n *              set JPEG parameters\n *              set destination to table file\n *              jpeg_write_tables(cinfo);\n *              set destination to image file\n *              jpeg_start_compress(cinfo, FALSE);\n *              write data...\n *              jpeg_finish_compress(cinfo);\n *\n * jpeg_write_tables has the side effect of marking all tables written\n * (same as jpeg_suppress_tables(..., TRUE)).  Thus a subsequent start_compress\n * will not re-emit the tables unless it is passed write_all_tables=TRUE.\n */\n\nGLOBAL(void)\njpeg_write_tables(j_compress_ptr cinfo)\n{\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* (Re)initialize error mgr and destination modules */\n  (*cinfo->err->reset_error_mgr) ((j_common_ptr)cinfo);\n  (*cinfo->dest->init_destination) (cinfo);\n  /* Initialize the marker writer ... bit of a crock to do it here. */\n  jinit_marker_writer(cinfo);\n  /* Write them tables! */\n  (*cinfo->marker->write_tables_only) (cinfo);\n  /* And clean up. */\n  (*cinfo->dest->term_destination) (cinfo);\n  /*\n   * In library releases up through v6a, we called jpeg_abort() here to free\n   * any working memory allocated by the destination manager and marker\n   * writer.  Some applications had a problem with that: they allocated space\n   * of their own from the library memory manager, and didn't want it to go\n   * away during write_tables.  So now we do nothing.  This will cause a\n   * memory leak if an app calls write_tables repeatedly without doing a full\n   * compression cycle or otherwise resetting the JPEG object.  However, that\n   * seems less bad than unexpectedly freeing memory in the normal case.\n   * An app that prefers the old behavior can call jpeg_abort for itself after\n   * each call to jpeg_write_tables().\n   */\n}\n"
        },
        {
          "name": "jcapistd.c",
          "type": "blob",
          "size": 6.875,
          "content": "/*\n * jcapistd.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n * Copyright (C) 2014, Mozilla Corporation.\n *\n * This file contains application interface code for the compression half\n * of the JPEG library.  These are the \"standard\" API routines that are\n * used in the normal full-compression case.  They are not used by a\n * transcoding-only application.  Note that if an application links in\n * jpeg_start_compress, it will end up linking in the entire compressor.\n * We thus must separate this file from jcapimin.c to avoid linking the\n * whole compression library into a transcoder.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n\n\n#if BITS_IN_JSAMPLE == 8\n\n/*\n * Compression initialization.\n * Before calling this, all parameters and a data destination must be set up.\n *\n * We require a write_all_tables parameter as a failsafe check when writing\n * multiple datastreams from the same compression object.  Since prior runs\n * will have left all the tables marked sent_table=TRUE, a subsequent run\n * would emit an abbreviated stream (no tables) by default.  This may be what\n * is wanted, but for safety's sake it should not be the default behavior:\n * programmers should have to make a deliberate choice to emit abbreviated\n * images.  Therefore the documentation and examples should encourage people\n * to pass write_all_tables=TRUE; then it will take active thought to do the\n * wrong thing.\n */\n\nGLOBAL(void)\njpeg_start_compress(j_compress_ptr cinfo, boolean write_all_tables)\n{\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  if (write_all_tables)\n    jpeg_suppress_tables(cinfo, FALSE); /* mark all tables to be written */\n\n  /* setting up scan optimisation pattern failed, disable scan optimisation */\n  if (cinfo->master->num_scans_luma == 0 || cinfo->scan_info == NULL ||\n      cinfo->num_scans == 0)\n    cinfo->master->optimize_scans = FALSE;\n  \n  /* (Re)initialize error mgr and destination modules */\n  (*cinfo->err->reset_error_mgr) ((j_common_ptr)cinfo);\n  (*cinfo->dest->init_destination) (cinfo);\n  /* Perform master selection of active modules */\n  jinit_compress_master(cinfo);\n  /* Set up for the first pass */\n  (*cinfo->master->prepare_for_pass) (cinfo);\n  /* Ready for application to drive first pass through _jpeg_write_scanlines\n   * or _jpeg_write_raw_data.\n   */\n  cinfo->next_scanline = 0;\n  cinfo->global_state = (cinfo->raw_data_in ? CSTATE_RAW_OK : CSTATE_SCANNING);\n}\n\n#endif\n\n\n/*\n * Write some scanlines of data to the JPEG compressor.\n *\n * The return value will be the number of lines actually written.\n * This should be less than the supplied num_lines only in case that\n * the data destination module has requested suspension of the compressor,\n * or if more than image_height scanlines are passed in.\n *\n * Note: we warn about excess calls to _jpeg_write_scanlines() since\n * this likely signals an application programmer error.  However,\n * excess scanlines passed in the last valid call are *silently* ignored,\n * so that the application need not adjust num_lines for end-of-image\n * when using a multiple-scanline buffer.\n */\n\nGLOBAL(JDIMENSION)\n_jpeg_write_scanlines(j_compress_ptr cinfo, _JSAMPARRAY scanlines,\n                      JDIMENSION num_lines)\n{\n#if BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED)\n  JDIMENSION row_ctr, rows_left;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  if (cinfo->global_state != CSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  if (cinfo->next_scanline >= cinfo->image_height)\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\n\n  /* Call progress monitor hook if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->pass_counter = (long)cinfo->next_scanline;\n    cinfo->progress->pass_limit = (long)cinfo->image_height;\n    (*cinfo->progress->progress_monitor) ((j_common_ptr)cinfo);\n  }\n\n  /* Give master control module another chance if this is first call to\n   * _jpeg_write_scanlines.  This lets output of the frame/scan headers be\n   * delayed so that application can write COM, etc, markers between\n   * jpeg_start_compress and _jpeg_write_scanlines.\n   */\n  if (cinfo->master->call_pass_startup)\n    (*cinfo->master->pass_startup) (cinfo);\n\n  /* Ignore any extra scanlines at bottom of image. */\n  rows_left = cinfo->image_height - cinfo->next_scanline;\n  if (num_lines > rows_left)\n    num_lines = rows_left;\n\n  row_ctr = 0;\n  if (cinfo->main->_process_data == NULL)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n  (*cinfo->main->_process_data) (cinfo, scanlines, &row_ctr, num_lines);\n  cinfo->next_scanline += row_ctr;\n  return row_ctr;\n#else\n  ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n  return 0;\n#endif\n}\n\n\n#if BITS_IN_JSAMPLE != 16\n\n/*\n * Alternate entry point to write raw data.\n * Processes exactly one iMCU row per call, unless suspended.\n */\n\nGLOBAL(JDIMENSION)\n_jpeg_write_raw_data(j_compress_ptr cinfo, _JSAMPIMAGE data,\n                     JDIMENSION num_lines)\n{\n  JDIMENSION lines_per_iMCU_row;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  if (cinfo->master->lossless)\n    ERREXIT(cinfo, JERR_NOTIMPL);\n\n  if (cinfo->global_state != CSTATE_RAW_OK)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  if (cinfo->next_scanline >= cinfo->image_height) {\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\n    return 0;\n  }\n\n  /* Call progress monitor hook if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->pass_counter = (long)cinfo->next_scanline;\n    cinfo->progress->pass_limit = (long)cinfo->image_height;\n    (*cinfo->progress->progress_monitor) ((j_common_ptr)cinfo);\n  }\n\n  /* Give master control module another chance if this is first call to\n   * _jpeg_write_raw_data.  This lets output of the frame/scan headers be\n   * delayed so that application can write COM, etc, markers between\n   * jpeg_start_compress and _jpeg_write_raw_data.\n   */\n  if (cinfo->master->call_pass_startup)\n    (*cinfo->master->pass_startup) (cinfo);\n\n  /* Verify that at least one iMCU row has been passed. */\n  lines_per_iMCU_row = cinfo->max_v_samp_factor * DCTSIZE;\n  if (num_lines < lines_per_iMCU_row)\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n\n  /* Directly compress the row. */\n  if (cinfo->coef->_compress_data == NULL)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n  if (!(*cinfo->coef->_compress_data) (cinfo, data)) {\n    /* If compressor did not consume the whole row, suspend processing. */\n    return 0;\n  }\n\n  /* OK, we processed one iMCU row. */\n  cinfo->next_scanline += lines_per_iMCU_row;\n  return lines_per_iMCU_row;\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 */\n"
        },
        {
          "name": "jcarith.c",
          "type": "blob",
          "size": 30.3857421875,
          "content": "/*\n * jcarith.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Developed 1997-2009 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015, 2018, 2021-2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains portable arithmetic entropy encoding routines for JPEG\n * (implementing Recommendation ITU-T T.81 | ISO/IEC 10918-1).\n *\n * Both sequential and progressive modes are supported in this single module.\n *\n * Suspension is not currently supported in this module.\n *\n * NOTE: All referenced figures are from\n * Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include <math.h>\n\n/* Expanded entropy encoder object for arithmetic encoding. */\n\ntypedef struct {\n  struct jpeg_entropy_encoder pub; /* public fields */\n\n  JLONG c; /* C register, base of coding interval, layout as in sec. D.1.3 */\n  JLONG a;               /* A register, normalized size of coding interval */\n  JLONG sc;        /* counter for stacked 0xFF values which might overflow */\n  JLONG zc;          /* counter for pending 0x00 output values which might *\n                          * be discarded at the end (\"Pacman\" termination) */\n  int ct;  /* bit shift counter, determines when next byte will be written */\n  int buffer;                /* buffer for most recent output byte != 0xFF */\n\n  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */\n  int dc_context[MAX_COMPS_IN_SCAN]; /* context index for DC conditioning */\n\n  unsigned int restarts_to_go;  /* MCUs left in this restart interval */\n  int next_restart_num;         /* next restart number to write (0-7) */\n\n  /* Pointers to statistics areas (these workspaces have image lifespan) */\n  unsigned char *dc_stats[NUM_ARITH_TBLS];\n  unsigned char *ac_stats[NUM_ARITH_TBLS];\n\n  /* Statistics bin for coding with fixed probability 0.5 */\n  unsigned char fixed_bin[4];\n} arith_entropy_encoder;\n\ntypedef arith_entropy_encoder *arith_entropy_ptr;\n\n/* The following two definitions specify the allocation chunk size\n * for the statistics area.\n * According to sections F.1.4.4.1.3 and F.1.4.4.2, we need at least\n * 49 statistics bins for DC, and 245 statistics bins for AC coding.\n *\n * We use a compact representation with 1 byte per statistics bin,\n * thus the numbers directly represent byte sizes.\n * This 1 byte per statistics bin contains the meaning of the MPS\n * (more probable symbol) in the highest bit (mask 0x80), and the\n * index into the probability estimation state machine table\n * in the lower bits (mask 0x7F).\n */\n\n#define DC_STAT_BINS  64\n#define AC_STAT_BINS  256\n\n/* NOTE: Uncomment the following #define if you want to use the\n * given formula for calculating the AC conditioning parameter Kx\n * for spectral selection progressive coding in section G.1.3.2\n * of the spec (Kx = Kmin + SRL (8 + Se - Kmin) 4).\n * Although the spec and P&M authors claim that this \"has proven\n * to give good results for 8 bit precision samples\", I'm not\n * convinced yet that this is really beneficial.\n * Early tests gave only very marginal compression enhancements\n * (a few - around 5 or so - bytes even for very large files),\n * which would turn out rather negative if we'd suppress the\n * DAC (Define Arithmetic Conditioning) marker segments for\n * the default parameters in the future.\n * Note that currently the marker writing module emits 12-byte\n * DAC segments for a full-component scan in a color image.\n * This is not worth worrying about IMHO. However, since the\n * spec defines the default values to be used if the tables\n * are omitted (unlike Huffman tables, which are required\n * anyway), one might optimize this behaviour in the future,\n * and then it would be disadvantageous to use custom tables if\n * they don't provide sufficient gain to exceed the DAC size.\n *\n * On the other hand, I'd consider it as a reasonable result\n * that the conditioning has no significant influence on the\n * compression performance. This means that the basic\n * statistical model is already rather stable.\n *\n * Thus, at the moment, we use the default conditioning values\n * anyway, and do not use the custom formula.\n *\n#define CALCULATE_SPECTRAL_CONDITIONING\n */\n\n/* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than JLONG.\n * We assume that int right shift is unsigned if JLONG right shift is,\n * which should be safe.\n */\n\n#ifdef RIGHT_SHIFT_IS_UNSIGNED\n#define ISHIFT_TEMPS    int ishift_temp;\n#define IRIGHT_SHIFT(x, shft) \\\n  ((ishift_temp = (x)) < 0 ? \\\n   (ishift_temp >> (shft)) | ((~0) << (16 - (shft))) : \\\n   (ishift_temp >> (shft)))\n#else\n#define ISHIFT_TEMPS\n#define IRIGHT_SHIFT(x, shft)   ((x) >> (shft))\n#endif\n\n\nLOCAL(void)\nemit_byte(int val, j_compress_ptr cinfo)\n/* Write next output byte; we do not support suspension in this module. */\n{\n  struct jpeg_destination_mgr *dest = cinfo->dest;\n\n  /* Do not emit bytes during trellis passes */\n  if (cinfo->master->trellis_passes)\n    return;\n  \n  *dest->next_output_byte++ = (JOCTET)val;\n  if (--dest->free_in_buffer == 0)\n    if (!(*dest->empty_output_buffer) (cinfo))\n      ERREXIT(cinfo, JERR_CANT_SUSPEND);\n}\n\n\n/*\n * Finish up at the end of an arithmetic-compressed scan.\n */\n\nMETHODDEF(void)\nfinish_pass(j_compress_ptr cinfo)\n{\n  arith_entropy_ptr e = (arith_entropy_ptr)cinfo->entropy;\n  JLONG temp;\n\n  /* Section D.1.8: Termination of encoding */\n\n  /* Find the e->c in the coding interval with the largest\n   * number of trailing zero bits */\n  if ((temp = (e->a - 1 + e->c) & 0xFFFF0000UL) < e->c)\n    e->c = temp + 0x8000L;\n  else\n    e->c = temp;\n  /* Send remaining bytes to output */\n  e->c <<= e->ct;\n  if (e->c & 0xF8000000UL) {\n    /* One final overflow has to be handled */\n    if (e->buffer >= 0) {\n      if (e->zc)\n        do emit_byte(0x00, cinfo);\n        while (--e->zc);\n      emit_byte(e->buffer + 1, cinfo);\n      if (e->buffer + 1 == 0xFF)\n        emit_byte(0x00, cinfo);\n    }\n    e->zc += e->sc;  /* carry-over converts stacked 0xFF bytes to 0x00 */\n    e->sc = 0;\n  } else {\n    if (e->buffer == 0)\n      ++e->zc;\n    else if (e->buffer >= 0) {\n      if (e->zc)\n        do emit_byte(0x00, cinfo);\n        while (--e->zc);\n      emit_byte(e->buffer, cinfo);\n    }\n    if (e->sc) {\n      if (e->zc)\n        do emit_byte(0x00, cinfo);\n        while (--e->zc);\n      do {\n        emit_byte(0xFF, cinfo);\n        emit_byte(0x00, cinfo);\n      } while (--e->sc);\n    }\n  }\n  /* Output final bytes only if they are not 0x00 */\n  if (e->c & 0x7FFF800L) {\n    if (e->zc)  /* output final pending zero bytes */\n      do emit_byte(0x00, cinfo);\n      while (--e->zc);\n    emit_byte((e->c >> 19) & 0xFF, cinfo);\n    if (((e->c >> 19) & 0xFF) == 0xFF)\n      emit_byte(0x00, cinfo);\n    if (e->c & 0x7F800L) {\n      emit_byte((e->c >> 11) & 0xFF, cinfo);\n      if (((e->c >> 11) & 0xFF) == 0xFF)\n        emit_byte(0x00, cinfo);\n    }\n  }\n}\n\n\n/*\n * The core arithmetic encoding routine (common in JPEG and JBIG).\n * This needs to go as fast as possible.\n * Machine-dependent optimization facilities\n * are not utilized in this portable implementation.\n * However, this code should be fairly efficient and\n * may be a good base for further optimizations anyway.\n *\n * Parameter 'val' to be encoded may be 0 or 1 (binary decision).\n *\n * Note: I've added full \"Pacman\" termination support to the\n * byte output routines, which is equivalent to the optional\n * Discard_final_zeros procedure (Figure D.15) in the spec.\n * Thus, we always produce the shortest possible output\n * stream compliant to the spec (no trailing zero bytes,\n * except for FF stuffing).\n *\n * I've also introduced a new scheme for accessing\n * the probability estimation state machine table,\n * derived from Markus Kuhn's JBIG implementation.\n */\n\nLOCAL(void)\narith_encode(j_compress_ptr cinfo, unsigned char *st, int val)\n{\n  register arith_entropy_ptr e = (arith_entropy_ptr)cinfo->entropy;\n  register unsigned char nl, nm;\n  register JLONG qe, temp;\n  register int sv;\n\n  /* Fetch values from our compact representation of Table D.2:\n   * Qe values and probability estimation state machine\n   */\n  sv = *st;\n  qe = jpeg_aritab[sv & 0x7F];  /* => Qe_Value */\n  nl = qe & 0xFF;  qe >>= 8;    /* Next_Index_LPS + Switch_MPS */\n  nm = qe & 0xFF;  qe >>= 8;    /* Next_Index_MPS */\n\n  /* Encode & estimation procedures per sections D.1.4 & D.1.5 */\n  e->a -= qe;\n  if (val != (sv >> 7)) {\n    /* Encode the less probable symbol */\n    if (e->a >= qe) {\n      /* If the interval size (qe) for the less probable symbol (LPS)\n       * is larger than the interval size for the MPS, then exchange\n       * the two symbols for coding efficiency, otherwise code the LPS\n       * as usual: */\n      e->c += e->a;\n      e->a = qe;\n    }\n    *st = (sv & 0x80) ^ nl;     /* Estimate_after_LPS */\n  } else {\n    /* Encode the more probable symbol */\n    if (e->a >= 0x8000L)\n      return;  /* A >= 0x8000 -> ready, no renormalization required */\n    if (e->a < qe) {\n      /* If the interval size (qe) for the less probable symbol (LPS)\n       * is larger than the interval size for the MPS, then exchange\n       * the two symbols for coding efficiency: */\n      e->c += e->a;\n      e->a = qe;\n    }\n    *st = (sv & 0x80) ^ nm;     /* Estimate_after_MPS */\n  }\n\n  /* Renormalization & data output per section D.1.6 */\n  do {\n    e->a <<= 1;\n    e->c <<= 1;\n    if (--e->ct == 0) {\n      /* Another byte is ready for output */\n      temp = e->c >> 19;\n      if (temp > 0xFF) {\n        /* Handle overflow over all stacked 0xFF bytes */\n        if (e->buffer >= 0) {\n          if (e->zc)\n            do emit_byte(0x00, cinfo);\n            while (--e->zc);\n          emit_byte(e->buffer + 1, cinfo);\n          if (e->buffer + 1 == 0xFF)\n            emit_byte(0x00, cinfo);\n        }\n        e->zc += e->sc;  /* carry-over converts stacked 0xFF bytes to 0x00 */\n        e->sc = 0;\n        /* Note: The 3 spacer bits in the C register guarantee\n         * that the new buffer byte can't be 0xFF here\n         * (see page 160 in the P&M JPEG book). */\n        e->buffer = temp & 0xFF;  /* new output byte, might overflow later */\n      } else if (temp == 0xFF) {\n        ++e->sc;  /* stack 0xFF byte (which might overflow later) */\n      } else {\n        /* Output all stacked 0xFF bytes, they will not overflow any more */\n        if (e->buffer == 0)\n          ++e->zc;\n        else if (e->buffer >= 0) {\n          if (e->zc)\n            do emit_byte(0x00, cinfo);\n            while (--e->zc);\n          emit_byte(e->buffer, cinfo);\n        }\n        if (e->sc) {\n          if (e->zc)\n            do emit_byte(0x00, cinfo);\n            while (--e->zc);\n          do {\n            emit_byte(0xFF, cinfo);\n            emit_byte(0x00, cinfo);\n          } while (--e->sc);\n        }\n        e->buffer = temp & 0xFF;  /* new output byte (can still overflow) */\n      }\n      e->c &= 0x7FFFFL;\n      e->ct += 8;\n    }\n  } while (e->a < 0x8000L);\n}\n\n\n/*\n * Emit a restart marker & resynchronize predictions.\n */\n\nLOCAL(void)\nemit_restart(j_compress_ptr cinfo, int restart_num)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  int ci;\n  jpeg_component_info *compptr;\n\n  finish_pass(cinfo);\n\n  emit_byte(0xFF, cinfo);\n  emit_byte(JPEG_RST0 + restart_num, cinfo);\n\n  /* Re-initialize statistics areas */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    /* DC needs no table for refinement scan */\n    if (cinfo->progressive_mode == 0 || (cinfo->Ss == 0 && cinfo->Ah == 0)) {\n      memset(entropy->dc_stats[compptr->dc_tbl_no], 0, DC_STAT_BINS);\n      /* Reset DC predictions to 0 */\n      entropy->last_dc_val[ci] = 0;\n      entropy->dc_context[ci] = 0;\n    }\n    /* AC needs no table when not present */\n    if (cinfo->progressive_mode == 0 || cinfo->Se) {\n      memset(entropy->ac_stats[compptr->ac_tbl_no], 0, AC_STAT_BINS);\n    }\n  }\n\n  /* Reset arithmetic encoding variables */\n  entropy->c = 0;\n  entropy->a = 0x10000L;\n  entropy->sc = 0;\n  entropy->zc = 0;\n  entropy->ct = 11;\n  entropy->buffer = -1;  /* empty */\n}\n\n\n/*\n * MCU encoding for DC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n\nMETHODDEF(boolean)\nencode_mcu_DC_first(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  JBLOCKROW block;\n  unsigned char *st;\n  int blkn, ci, tbl;\n  int v, v2, m;\n  ISHIFT_TEMPS\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      emit_restart(cinfo, entropy->next_restart_num);\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  /* Encode the MCU data blocks */\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    block = MCU_data[blkn];\n    ci = cinfo->MCU_membership[blkn];\n    tbl = cinfo->cur_comp_info[ci]->dc_tbl_no;\n\n    /* Compute the DC value after the required point transform by Al.\n     * This is simply an arithmetic right shift.\n     */\n    m = IRIGHT_SHIFT((int)((*block)[0]), cinfo->Al);\n\n    /* Sections F.1.4.1 & F.1.4.4.1: Encoding of DC coefficients */\n\n    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */\n    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];\n\n    /* Figure F.4: Encode_DC_DIFF */\n    if ((v = m - entropy->last_dc_val[ci]) == 0) {\n      arith_encode(cinfo, st, 0);\n      entropy->dc_context[ci] = 0;      /* zero diff category */\n    } else {\n      entropy->last_dc_val[ci] = m;\n      arith_encode(cinfo, st, 1);\n      /* Figure F.6: Encoding nonzero value v */\n      /* Figure F.7: Encoding the sign of v */\n      if (v > 0) {\n        arith_encode(cinfo, st + 1, 0); /* Table F.4: SS = S0 + 1 */\n        st += 2;                        /* Table F.4: SP = S0 + 2 */\n        entropy->dc_context[ci] = 4;    /* small positive diff category */\n      } else {\n        v = -v;\n        arith_encode(cinfo, st + 1, 1); /* Table F.4: SS = S0 + 1 */\n        st += 3;                        /* Table F.4: SN = S0 + 3 */\n        entropy->dc_context[ci] = 8;    /* small negative diff category */\n      }\n      /* Figure F.8: Encoding the magnitude category of v */\n      m = 0;\n      if (v -= 1) {\n        arith_encode(cinfo, st, 1);\n        m = 1;\n        v2 = v;\n        st = entropy->dc_stats[tbl] + 20; /* Table F.4: X1 = 20 */\n        while (v2 >>= 1) {\n          arith_encode(cinfo, st, 1);\n          m <<= 1;\n          st += 1;\n        }\n      }\n      arith_encode(cinfo, st, 0);\n      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */\n      if (m < (int)((1L << cinfo->arith_dc_L[tbl]) >> 1))\n        entropy->dc_context[ci] = 0;    /* zero diff category */\n      else if (m > (int)((1L << cinfo->arith_dc_U[tbl]) >> 1))\n        entropy->dc_context[ci] += 8;   /* large diff category */\n      /* Figure F.9: Encoding the magnitude bit pattern of v */\n      st += 14;\n      while (m >>= 1)\n        arith_encode(cinfo, st, (m & v) ? 1 : 0);\n    }\n  }\n\n  return TRUE;\n}\n\n\n/*\n * MCU encoding for AC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n\nMETHODDEF(boolean)\nencode_mcu_AC_first(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  JBLOCKROW block;\n  unsigned char *st;\n  int tbl, k, ke;\n  int v, v2, m;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      emit_restart(cinfo, entropy->next_restart_num);\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  /* Encode the MCU data block */\n  block = MCU_data[0];\n  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;\n\n  /* Sections F.1.4.2 & F.1.4.4.2: Encoding of AC coefficients */\n\n  /* Establish EOB (end-of-block) index */\n  for (ke = cinfo->Se; ke > 0; ke--)\n    /* We must apply the point transform by Al.  For AC coefficients this\n     * is an integer division with rounding towards 0.  To do this portably\n     * in C, we shift after obtaining the absolute value.\n     */\n    if ((v = (*block)[jpeg_natural_order[ke]]) >= 0) {\n      if (v >>= cinfo->Al) break;\n    } else {\n      v = -v;\n      if (v >>= cinfo->Al) break;\n    }\n\n  /* Figure F.5: Encode_AC_Coefficients */\n  for (k = cinfo->Ss; k <= ke; k++) {\n    st = entropy->ac_stats[tbl] + 3 * (k - 1);\n    arith_encode(cinfo, st, 0);         /* EOB decision */\n    for (;;) {\n      if ((v = (*block)[jpeg_natural_order[k]]) >= 0) {\n        if (v >>= cinfo->Al) {\n          arith_encode(cinfo, st + 1, 1);\n          arith_encode(cinfo, entropy->fixed_bin, 0);\n          break;\n        }\n      } else {\n        v = -v;\n        if (v >>= cinfo->Al) {\n          arith_encode(cinfo, st + 1, 1);\n          arith_encode(cinfo, entropy->fixed_bin, 1);\n          break;\n        }\n      }\n      arith_encode(cinfo, st + 1, 0);  st += 3;  k++;\n    }\n    st += 2;\n    /* Figure F.8: Encoding the magnitude category of v */\n    m = 0;\n    if (v -= 1) {\n      arith_encode(cinfo, st, 1);\n      m = 1;\n      v2 = v;\n      if (v2 >>= 1) {\n        arith_encode(cinfo, st, 1);\n        m <<= 1;\n        st = entropy->ac_stats[tbl] +\n             (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);\n        while (v2 >>= 1) {\n          arith_encode(cinfo, st, 1);\n          m <<= 1;\n          st += 1;\n        }\n      }\n    }\n    arith_encode(cinfo, st, 0);\n    /* Figure F.9: Encoding the magnitude bit pattern of v */\n    st += 14;\n    while (m >>= 1)\n      arith_encode(cinfo, st, (m & v) ? 1 : 0);\n  }\n  /* Encode EOB decision only if k <= cinfo->Se */\n  if (k <= cinfo->Se) {\n    st = entropy->ac_stats[tbl] + 3 * (k - 1);\n    arith_encode(cinfo, st, 1);\n  }\n\n  return TRUE;\n}\n\n\n/*\n * MCU encoding for DC successive approximation refinement scan.\n */\n\nMETHODDEF(boolean)\nencode_mcu_DC_refine(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  unsigned char *st;\n  int Al, blkn;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      emit_restart(cinfo, entropy->next_restart_num);\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  st = entropy->fixed_bin;      /* use fixed probability estimation */\n  Al = cinfo->Al;\n\n  /* Encode the MCU data blocks */\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    /* We simply emit the Al'th bit of the DC coefficient value. */\n    arith_encode(cinfo, st, (MCU_data[blkn][0][0] >> Al) & 1);\n  }\n\n  return TRUE;\n}\n\n\n/*\n * MCU encoding for AC successive approximation refinement scan.\n */\n\nMETHODDEF(boolean)\nencode_mcu_AC_refine(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  JBLOCKROW block;\n  unsigned char *st;\n  int tbl, k, ke, kex;\n  int v;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      emit_restart(cinfo, entropy->next_restart_num);\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  /* Encode the MCU data block */\n  block = MCU_data[0];\n  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;\n\n  /* Section G.1.3.3: Encoding of AC coefficients */\n\n  /* Establish EOB (end-of-block) index */\n  for (ke = cinfo->Se; ke > 0; ke--)\n    /* We must apply the point transform by Al.  For AC coefficients this\n     * is an integer division with rounding towards 0.  To do this portably\n     * in C, we shift after obtaining the absolute value.\n     */\n    if ((v = (*block)[jpeg_natural_order[ke]]) >= 0) {\n      if (v >>= cinfo->Al) break;\n    } else {\n      v = -v;\n      if (v >>= cinfo->Al) break;\n    }\n\n  /* Establish EOBx (previous stage end-of-block) index */\n  for (kex = ke; kex > 0; kex--)\n    if ((v = (*block)[jpeg_natural_order[kex]]) >= 0) {\n      if (v >>= cinfo->Ah) break;\n    } else {\n      v = -v;\n      if (v >>= cinfo->Ah) break;\n    }\n\n  /* Figure G.10: Encode_AC_Coefficients_SA */\n  for (k = cinfo->Ss; k <= ke; k++) {\n    st = entropy->ac_stats[tbl] + 3 * (k - 1);\n    if (k > kex)\n      arith_encode(cinfo, st, 0);       /* EOB decision */\n    for (;;) {\n      if ((v = (*block)[jpeg_natural_order[k]]) >= 0) {\n        if (v >>= cinfo->Al) {\n          if (v >> 1)                   /* previously nonzero coef */\n            arith_encode(cinfo, st + 2, (v & 1));\n          else {                        /* newly nonzero coef */\n            arith_encode(cinfo, st + 1, 1);\n            arith_encode(cinfo, entropy->fixed_bin, 0);\n          }\n          break;\n        }\n      } else {\n        v = -v;\n        if (v >>= cinfo->Al) {\n          if (v >> 1)                   /* previously nonzero coef */\n            arith_encode(cinfo, st + 2, (v & 1));\n          else {                        /* newly nonzero coef */\n            arith_encode(cinfo, st + 1, 1);\n            arith_encode(cinfo, entropy->fixed_bin, 1);\n          }\n          break;\n        }\n      }\n      arith_encode(cinfo, st + 1, 0);  st += 3;  k++;\n    }\n  }\n  /* Encode EOB decision only if k <= cinfo->Se */\n  if (k <= cinfo->Se) {\n    st = entropy->ac_stats[tbl] + 3 * (k - 1);\n    arith_encode(cinfo, st, 1);\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Encode and output one MCU's worth of arithmetic-compressed coefficients.\n */\n\nMETHODDEF(boolean)\nencode_mcu(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  jpeg_component_info *compptr;\n  JBLOCKROW block;\n  unsigned char *st;\n  int blkn, ci, tbl, k, ke;\n  int v, v2, m;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      emit_restart(cinfo, entropy->next_restart_num);\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  /* Encode the MCU data blocks */\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    block = MCU_data[blkn];\n    ci = cinfo->MCU_membership[blkn];\n    compptr = cinfo->cur_comp_info[ci];\n\n    /* Sections F.1.4.1 & F.1.4.4.1: Encoding of DC coefficients */\n\n    tbl = compptr->dc_tbl_no;\n\n    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */\n    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];\n\n    /* Figure F.4: Encode_DC_DIFF */\n    if ((v = (*block)[0] - entropy->last_dc_val[ci]) == 0) {\n      arith_encode(cinfo, st, 0);\n      entropy->dc_context[ci] = 0;      /* zero diff category */\n    } else {\n      entropy->last_dc_val[ci] = (*block)[0];\n      arith_encode(cinfo, st, 1);\n      /* Figure F.6: Encoding nonzero value v */\n      /* Figure F.7: Encoding the sign of v */\n      if (v > 0) {\n        arith_encode(cinfo, st + 1, 0); /* Table F.4: SS = S0 + 1 */\n        st += 2;                        /* Table F.4: SP = S0 + 2 */\n        entropy->dc_context[ci] = 4;    /* small positive diff category */\n      } else {\n        v = -v;\n        arith_encode(cinfo, st + 1, 1); /* Table F.4: SS = S0 + 1 */\n        st += 3;                        /* Table F.4: SN = S0 + 3 */\n        entropy->dc_context[ci] = 8;    /* small negative diff category */\n      }\n      /* Figure F.8: Encoding the magnitude category of v */\n      m = 0;\n      if (v -= 1) {\n        arith_encode(cinfo, st, 1);\n        m = 1;\n        v2 = v;\n        st = entropy->dc_stats[tbl] + 20; /* Table F.4: X1 = 20 */\n        while (v2 >>= 1) {\n          arith_encode(cinfo, st, 1);\n          m <<= 1;\n          st += 1;\n        }\n      }\n      arith_encode(cinfo, st, 0);\n      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */\n      if (m < (int)((1L << cinfo->arith_dc_L[tbl]) >> 1))\n        entropy->dc_context[ci] = 0;    /* zero diff category */\n      else if (m > (int)((1L << cinfo->arith_dc_U[tbl]) >> 1))\n        entropy->dc_context[ci] += 8;   /* large diff category */\n      /* Figure F.9: Encoding the magnitude bit pattern of v */\n      st += 14;\n      while (m >>= 1)\n        arith_encode(cinfo, st, (m & v) ? 1 : 0);\n    }\n\n    /* Sections F.1.4.2 & F.1.4.4.2: Encoding of AC coefficients */\n\n    tbl = compptr->ac_tbl_no;\n\n    /* Establish EOB (end-of-block) index */\n    for (ke = DCTSIZE2 - 1; ke > 0; ke--)\n      if ((*block)[jpeg_natural_order[ke]]) break;\n\n    /* Figure F.5: Encode_AC_Coefficients */\n    for (k = 1; k <= ke; k++) {\n      st = entropy->ac_stats[tbl] + 3 * (k - 1);\n      arith_encode(cinfo, st, 0);       /* EOB decision */\n      while ((v = (*block)[jpeg_natural_order[k]]) == 0) {\n        arith_encode(cinfo, st + 1, 0);  st += 3;  k++;\n      }\n      arith_encode(cinfo, st + 1, 1);\n      /* Figure F.6: Encoding nonzero value v */\n      /* Figure F.7: Encoding the sign of v */\n      if (v > 0) {\n        arith_encode(cinfo, entropy->fixed_bin, 0);\n      } else {\n        v = -v;\n        arith_encode(cinfo, entropy->fixed_bin, 1);\n      }\n      st += 2;\n      /* Figure F.8: Encoding the magnitude category of v */\n      m = 0;\n      if (v -= 1) {\n        arith_encode(cinfo, st, 1);\n        m = 1;\n        v2 = v;\n        if (v2 >>= 1) {\n          arith_encode(cinfo, st, 1);\n          m <<= 1;\n          st = entropy->ac_stats[tbl] +\n               (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);\n          while (v2 >>= 1) {\n            arith_encode(cinfo, st, 1);\n            m <<= 1;\n            st += 1;\n          }\n        }\n      }\n      arith_encode(cinfo, st, 0);\n      /* Figure F.9: Encoding the magnitude bit pattern of v */\n      st += 14;\n      while (m >>= 1)\n        arith_encode(cinfo, st, (m & v) ? 1 : 0);\n    }\n    /* Encode EOB decision only if k <= DCTSIZE2 - 1 */\n    if (k <= DCTSIZE2 - 1) {\n      st = entropy->ac_stats[tbl] + 3 * (k - 1);\n      arith_encode(cinfo, st, 1);\n    }\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Initialize for an arithmetic-compressed scan.\n */\n\nMETHODDEF(void)\nstart_pass(j_compress_ptr cinfo, boolean gather_statistics)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  int ci, tbl;\n  jpeg_component_info *compptr;\n  boolean progressive_mode;\n\n  if (gather_statistics)\n    /* Make sure to avoid that in the master control logic!\n     * We are fully adaptive here and need no extra\n     * statistics gathering pass!\n     */\n    ERREXIT(cinfo, JERR_NOTIMPL);\n\n  /* We assume jcmaster.c already validated the progressive scan parameters. */\n\n  /* Trellis optimization does DC and AC in same pass and without refinement\n   * so consider progressive mode to be off in such case */\n  progressive_mode = (cinfo->master->trellis_passes) ? FALSE : cinfo->progressive_mode;\n  \n  /* Select execution routines */\n  if (progressive_mode) {\n    if (cinfo->Ah == 0) {\n      if (cinfo->Ss == 0)\n        entropy->pub.encode_mcu = encode_mcu_DC_first;\n      else\n        entropy->pub.encode_mcu = encode_mcu_AC_first;\n    } else {\n      if (cinfo->Ss == 0)\n        entropy->pub.encode_mcu = encode_mcu_DC_refine;\n      else\n        entropy->pub.encode_mcu = encode_mcu_AC_refine;\n    }\n  } else\n    entropy->pub.encode_mcu = encode_mcu;\n\n  /* Allocate & initialize requested statistics areas */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    /* DC needs no table for refinement scan */\n    if (progressive_mode == 0 || (cinfo->Ss == 0 && cinfo->Ah == 0)) {\n      tbl = compptr->dc_tbl_no;\n      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)\n        ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);\n      if (entropy->dc_stats[tbl] == NULL)\n        entropy->dc_stats[tbl] = (unsigned char *)(*cinfo->mem->alloc_small)\n          ((j_common_ptr)cinfo, JPOOL_IMAGE, DC_STAT_BINS);\n      memset(entropy->dc_stats[tbl], 0, DC_STAT_BINS);\n      /* Initialize DC predictions to 0 */\n      entropy->last_dc_val[ci] = 0;\n      entropy->dc_context[ci] = 0;\n    }\n    /* AC needs no table when not present */\n    if (progressive_mode == 0 || cinfo->Se) {\n      tbl = compptr->ac_tbl_no;\n      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)\n        ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);\n      if (entropy->ac_stats[tbl] == NULL)\n        entropy->ac_stats[tbl] = (unsigned char *)(*cinfo->mem->alloc_small)\n          ((j_common_ptr)cinfo, JPOOL_IMAGE, AC_STAT_BINS);\n      memset(entropy->ac_stats[tbl], 0, AC_STAT_BINS);\n#ifdef CALCULATE_SPECTRAL_CONDITIONING\n      if (progressive_mode)\n        /* Section G.1.3.2: Set appropriate arithmetic conditioning value Kx */\n        cinfo->arith_ac_K[tbl] = cinfo->Ss +\n                                 ((8 + cinfo->Se - cinfo->Ss) >> 4);\n#endif\n    }\n  }\n\n  /* Initialize arithmetic encoding variables */\n  entropy->c = 0;\n  entropy->a = 0x10000L;\n  entropy->sc = 0;\n  entropy->zc = 0;\n  entropy->ct = 11;\n  entropy->buffer = -1;  /* empty */\n\n  /* Initialize restart stuff */\n  entropy->restarts_to_go = cinfo->restart_interval;\n  entropy->next_restart_num = 0;\n}\n\n\n/*\n * Module initialization routine for arithmetic entropy encoding.\n */\n\nGLOBAL(void)\njinit_arith_encoder(j_compress_ptr cinfo)\n{\n  arith_entropy_ptr entropy;\n  int i;\n\n  entropy = (arith_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(arith_entropy_encoder));\n  cinfo->entropy = (struct jpeg_entropy_encoder *)entropy;\n  entropy->pub.start_pass = start_pass;\n  entropy->pub.finish_pass = finish_pass;\n\n  /* Mark tables unallocated */\n  for (i = 0; i < NUM_ARITH_TBLS; i++) {\n    entropy->dc_stats[i] = NULL;\n    entropy->ac_stats[i] = NULL;\n  }\n\n  /* Initialize index for fixed probability estimation */\n  entropy->fixed_bin[0] = 113;\n}\n\nGLOBAL(void)\njget_arith_rates (j_compress_ptr cinfo, int dc_tbl_no, int ac_tbl_no, arith_rates *r)\n{\n  int i;\n  arith_entropy_ptr entropy = (arith_entropy_ptr) cinfo->entropy;\n  \n  r->arith_dc_L = cinfo->arith_dc_L[dc_tbl_no];\n  r->arith_dc_U = cinfo->arith_dc_U[dc_tbl_no];\n  r->arith_ac_K = cinfo->arith_ac_K[ac_tbl_no];\n  \n  for (i = 0; i < DC_STAT_BINS; i++) {\n    int state = entropy->dc_stats[dc_tbl_no][i];\n    int mps_val = state >> 7;\n    float prob_lps = (jpeg_aritab[state & 0x7f] >> 16) / 46340.95; /* 32768*sqrt(2) */\n    float prob_0 = (mps_val) ? prob_lps : 1.0 - prob_lps;\n    float prob_1 = 1.0 - prob_0;\n    r->rate_dc[i][0] = -log(prob_0) / log(2.0);\n    r->rate_dc[i][1] = -log(prob_1) / log(2.0);\n  }\n\n  for (i = 0; i < AC_STAT_BINS; i++) {\n    int state = entropy->ac_stats[ac_tbl_no][i];\n    int mps_val = state >> 7;\n    float prob_lps = (jpeg_aritab[state & 0x7f] >> 16) / 46340.95;\n    float prob_0 = (mps_val) ? prob_lps : 1.0 - prob_lps;\n    float prob_1 = 1.0 - prob_0;\n    r->rate_ac[i][0] = -log(prob_0) / log(2.0);\n    r->rate_ac[i][1] = -log(prob_1) / log(2.0);\n  }\n}\n"
        },
        {
          "name": "jccoefct.c",
          "type": "blob",
          "size": 23.5380859375,
          "content": "/*\n * jccoefct.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, 2024, D. R. Commander.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the coefficient buffer controller for compression.\n * This controller is the top level of the lossy JPEG compressor proper.\n * The coefficient buffer lies between forward-DCT and entropy encoding steps.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n#include \"jchuff.h\"\n\n/* We use a full-image coefficient buffer when doing Huffman optimization,\n * and also for writing multiple-scan JPEG files.  In all cases, the DCT\n * step is run during the first pass, and subsequent passes need only read\n * the buffered coefficients.\n */\n#ifdef ENTROPY_OPT_SUPPORTED\n#define FULL_COEF_BUFFER_SUPPORTED\n#else\n#ifdef C_MULTISCAN_FILES_SUPPORTED\n#define FULL_COEF_BUFFER_SUPPORTED\n#endif\n#endif\n\n\n/* Private buffer controller object */\n\ntypedef struct {\n  struct jpeg_c_coef_controller pub; /* public fields */\n\n  JDIMENSION iMCU_row_num;      /* iMCU row # within image */\n  JDIMENSION mcu_ctr;           /* counts MCUs processed in current row */\n  int MCU_vert_offset;          /* counts MCU rows within iMCU row */\n  int MCU_rows_per_iMCU_row;    /* number of such rows needed */\n\n  /* For single-pass compression, it's sufficient to buffer just one MCU\n   * (although this may prove a bit slow in practice).  We allocate a\n   * workspace of C_MAX_BLOCKS_IN_MCU coefficient blocks, and reuse it for each\n   * MCU constructed and sent.  In multi-pass modes, this array points to the\n   * current MCU's blocks within the virtual arrays.\n   */\n  JBLOCKROW MCU_buffer[C_MAX_BLOCKS_IN_MCU];\n\n  /* In multi-pass modes, we need a virtual block array for each component. */\n  jvirt_barray_ptr whole_image[MAX_COMPONENTS];\n\n  /* when using trellis quantization, need to keep a copy of all unquantized coefficients */\n  jvirt_barray_ptr whole_image_uq[MAX_COMPONENTS];\n\n} my_coef_controller;\n\ntypedef my_coef_controller *my_coef_ptr;\n\n\n/* Forward declarations */\nMETHODDEF(boolean) compress_data(j_compress_ptr cinfo, _JSAMPIMAGE input_buf);\n#ifdef FULL_COEF_BUFFER_SUPPORTED\nMETHODDEF(boolean) compress_first_pass(j_compress_ptr cinfo,\n                                       _JSAMPIMAGE input_buf);\nMETHODDEF(boolean) compress_output(j_compress_ptr cinfo,\n                                   _JSAMPIMAGE input_buf);\n#endif\nMETHODDEF(boolean) compress_trellis_pass\n        (j_compress_ptr cinfo, JSAMPIMAGE input_buf);\n\n\nLOCAL(void)\nstart_iMCU_row(j_compress_ptr cinfo)\n/* Reset within-iMCU-row counters for a new row */\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n\n  /* In an interleaved scan, an MCU row is the same as an iMCU row.\n   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.\n   * But at the bottom of the image, process only what's left.\n   */\n  if (cinfo->comps_in_scan > 1) {\n    coef->MCU_rows_per_iMCU_row = 1;\n  } else {\n    if (coef->iMCU_row_num < (cinfo->total_iMCU_rows - 1))\n      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;\n    else\n      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;\n  }\n\n  coef->mcu_ctr = 0;\n  coef->MCU_vert_offset = 0;\n}\n\n\n/*\n * Initialize for a processing pass.\n */\n\nMETHODDEF(void)\nstart_pass_coef(j_compress_ptr cinfo, J_BUF_MODE pass_mode)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n\n  coef->iMCU_row_num = 0;\n  start_iMCU_row(cinfo);\n\n  switch (pass_mode) {\n  case JBUF_PASS_THRU:\n    if (coef->whole_image[0] != NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    coef->pub._compress_data = compress_data;\n    break;\n#ifdef FULL_COEF_BUFFER_SUPPORTED\n  case JBUF_SAVE_AND_PASS:\n    if (coef->whole_image[0] == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    coef->pub._compress_data = compress_first_pass;\n    break;\n  case JBUF_CRANK_DEST:\n    if (coef->whole_image[0] == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    coef->pub._compress_data = compress_output;\n    break;\n#endif\n#if BITS_IN_JSAMPLE == 8\n  case JBUF_REQUANT:\n    if (coef->whole_image[0] == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    coef->pub.compress_data = compress_trellis_pass;\n    break;\n#endif\n      \n  default:\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    break;\n  }\n}\n\n\n/*\n * Process some data in the single-pass case.\n * We process the equivalent of one fully interleaved MCU row (\"iMCU\" row)\n * per call, ie, v_samp_factor block rows for each component in the image.\n * Returns TRUE if the iMCU row is completed, FALSE if suspended.\n *\n * NB: input_buf contains a plane for each component in image,\n * which we index according to the component's SOF position.\n */\n\nMETHODDEF(boolean)\ncompress_data(j_compress_ptr cinfo, _JSAMPIMAGE input_buf)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  JDIMENSION MCU_col_num;       /* index of current MCU within row */\n  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  int blkn, bi, ci, yindex, yoffset, blockcnt;\n  JDIMENSION ypos, xpos;\n  jpeg_component_info *compptr;\n\n  /* Loop to write as much as one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->mcu_ctr; MCU_col_num <= last_MCU_col;\n         MCU_col_num++) {\n      /* Determine where data comes from in input_buf and do the DCT thing.\n       * Each call on forward_DCT processes a horizontal row of DCT blocks\n       * as wide as an MCU; we rely on having allocated the MCU_buffer[] blocks\n       * sequentially.  Dummy blocks at the right or bottom edge are filled in\n       * specially.  The data in them does not matter for image reconstruction,\n       * so we fill them with values that will encode to the smallest amount of\n       * data, viz: all zeroes in the AC entries, DC entries equal to previous\n       * block's DC value.  (Thanks to Thomas Kinsman for this idea.)\n       */\n      blkn = 0;\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n        compptr = cinfo->cur_comp_info[ci];\n        blockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width :\n                                                  compptr->last_col_width;\n        xpos = MCU_col_num * compptr->MCU_sample_width;\n        ypos = yoffset * DCTSIZE; /* ypos == (yoffset+yindex) * DCTSIZE */\n        for (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n          if (coef->iMCU_row_num < last_iMCU_row ||\n              yoffset + yindex < compptr->last_row_height) {\n            (*cinfo->fdct->_forward_DCT) (cinfo, compptr,\n                                          input_buf[compptr->component_index],\n                                          coef->MCU_buffer[blkn],\n                                          ypos, xpos, (JDIMENSION)blockcnt,\n                                          NULL);\n            if (blockcnt < compptr->MCU_width) {\n              /* Create some dummy blocks at the right edge of the image. */\n              jzero_far((void *)coef->MCU_buffer[blkn + blockcnt],\n                        (compptr->MCU_width - blockcnt) * sizeof(JBLOCK));\n              for (bi = blockcnt; bi < compptr->MCU_width; bi++) {\n                coef->MCU_buffer[blkn + bi][0][0] =\n                  coef->MCU_buffer[blkn + bi - 1][0][0];\n              }\n            }\n          } else {\n            /* Create a row of dummy blocks at the bottom of the image. */\n            jzero_far((void *)coef->MCU_buffer[blkn],\n                      compptr->MCU_width * sizeof(JBLOCK));\n            for (bi = 0; bi < compptr->MCU_width; bi++) {\n              coef->MCU_buffer[blkn + bi][0][0] =\n                coef->MCU_buffer[blkn - 1][0][0];\n            }\n          }\n          blkn += compptr->MCU_width;\n          ypos += DCTSIZE;\n        }\n      }\n      /* Try to write the MCU.  In event of a suspension failure, we will\n       * re-DCT the MCU on restart (a bit inefficient, could be fixed...)\n       */\n      if (!(*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {\n        /* Suspension forced; update state counters and exit */\n        coef->MCU_vert_offset = yoffset;\n        coef->mcu_ctr = MCU_col_num;\n        return FALSE;\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->mcu_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  coef->iMCU_row_num++;\n  start_iMCU_row(cinfo);\n  return TRUE;\n}\n\n\n#ifdef FULL_COEF_BUFFER_SUPPORTED\n\n/*\n * Process some data in the first pass of a multi-pass case.\n * We process the equivalent of one fully interleaved MCU row (\"iMCU\" row)\n * per call, ie, v_samp_factor block rows for each component in the image.\n * This amount of data is read from the source buffer, DCT'd and quantized,\n * and saved into the virtual arrays.  We also generate suitable dummy blocks\n * as needed at the right and lower edges.  (The dummy blocks are constructed\n * in the virtual arrays, which have been padded appropriately.)  This makes\n * it possible for subsequent passes not to worry about real vs. dummy blocks.\n *\n * We must also emit the data to the entropy encoder.  This is conveniently\n * done by calling compress_output() after we've loaded the current strip\n * of the virtual arrays.\n *\n * NB: input_buf contains a plane for each component in image.  All\n * components are DCT'd and loaded into the virtual arrays in this pass.\n * However, it may be that only a subset of the components are emitted to\n * the entropy encoder during this first pass; be careful about looking\n * at the scan-dependent variables (MCU dimensions, etc).\n */\n\nMETHODDEF(boolean)\ncompress_first_pass(j_compress_ptr cinfo, _JSAMPIMAGE input_buf)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  JDIMENSION blocks_across, MCUs_across, MCUindex;\n  int bi, ci, h_samp_factor, block_row, block_rows, ndummy;\n  JCOEF lastDC;\n  jpeg_component_info *compptr;\n  JBLOCKARRAY buffer;\n  JBLOCKROW thisblockrow, lastblockrow;\n  JBLOCKARRAY buffer_dst;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Align the virtual buffer for this component. */\n    buffer = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr)cinfo, coef->whole_image[ci],\n       coef->iMCU_row_num * compptr->v_samp_factor,\n       (JDIMENSION)compptr->v_samp_factor, TRUE);\n    \n    buffer_dst = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr) cinfo, coef->whole_image_uq[ci],\n       coef->iMCU_row_num * compptr->v_samp_factor,\n       (JDIMENSION)compptr->v_samp_factor, TRUE);\n    \n    /* Count non-dummy DCT block rows in this iMCU row. */\n    if (coef->iMCU_row_num < last_iMCU_row)\n      block_rows = compptr->v_samp_factor;\n    else {\n      /* NB: can't use last_row_height here, since may not be set! */\n      block_rows = (int)(compptr->height_in_blocks % compptr->v_samp_factor);\n      if (block_rows == 0) block_rows = compptr->v_samp_factor;\n    }\n    blocks_across = compptr->width_in_blocks;\n    h_samp_factor = compptr->h_samp_factor;\n    /* Count number of dummy blocks to be added at the right margin. */\n    ndummy = (int)(blocks_across % h_samp_factor);\n    if (ndummy > 0)\n      ndummy = h_samp_factor - ndummy;\n    /* Perform DCT for all non-dummy blocks in this iMCU row.  Each call\n     * on forward_DCT processes a complete horizontal row of DCT blocks.\n     */\n    for (block_row = 0; block_row < block_rows; block_row++) {\n      thisblockrow = buffer[block_row];\n      (*cinfo->fdct->_forward_DCT) (cinfo, compptr,\n                                    input_buf[ci], thisblockrow,\n                                    (JDIMENSION)(block_row * DCTSIZE),\n                                    (JDIMENSION)0, blocks_across,\n                                    buffer_dst[block_row]);\n      if (ndummy > 0) {\n        /* Create dummy blocks at the right edge of the image. */\n        thisblockrow += blocks_across; /* => first dummy block */\n        jzero_far((void *)thisblockrow, ndummy * sizeof(JBLOCK));\n        lastDC = thisblockrow[-1][0];\n        for (bi = 0; bi < ndummy; bi++) {\n          thisblockrow[bi][0] = lastDC;\n        }\n      }\n    }\n    /* If at end of image, create dummy block rows as needed.\n     * The tricky part here is that within each MCU, we want the DC values\n     * of the dummy blocks to match the last real block's DC value.\n     * This squeezes a few more bytes out of the resulting file...\n     */\n    if (coef->iMCU_row_num == last_iMCU_row) {\n      blocks_across += ndummy;  /* include lower right corner */\n      MCUs_across = blocks_across / h_samp_factor;\n      for (block_row = block_rows; block_row < compptr->v_samp_factor;\n           block_row++) {\n        thisblockrow = buffer[block_row];\n        lastblockrow = buffer[block_row - 1];\n        jzero_far((void *)thisblockrow,\n                  (size_t)(blocks_across * sizeof(JBLOCK)));\n        for (MCUindex = 0; MCUindex < MCUs_across; MCUindex++) {\n          lastDC = lastblockrow[h_samp_factor - 1][0];\n          for (bi = 0; bi < h_samp_factor; bi++) {\n            thisblockrow[bi][0] = lastDC;\n          }\n          thisblockrow += h_samp_factor; /* advance to next MCU in row */\n          lastblockrow += h_samp_factor;\n        }\n      }\n    }\n  }\n  /* NB: compress_output will increment iMCU_row_num if successful.\n   * A suspension return will result in redoing all the work above next time.\n   */\n\n  /* Emit data to the entropy encoder, sharing code with subsequent passes */\n  return compress_output(cinfo, input_buf);\n}\n\n#if BITS_IN_JSAMPLE == 8\nMETHODDEF(boolean)\ncompress_trellis_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)\n{\n  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  JDIMENSION blocks_across, MCUs_across, MCUindex;\n  int bi, ci, h_samp_factor, block_row, block_rows, ndummy;\n  JCOEF lastDC;\n  jpeg_component_info *compptr;\n  JBLOCKARRAY buffer;\n  JBLOCKROW thisblockrow, lastblockrow;\n  JBLOCKARRAY buffer_dst;\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    c_derived_tbl dctbl_data;\n    c_derived_tbl *dctbl = &dctbl_data;\n    c_derived_tbl actbl_data;\n    c_derived_tbl *actbl = &actbl_data;\n    \n#ifdef C_ARITH_CODING_SUPPORTED\n    arith_rates arith_r_data;\n    arith_rates *arith_r = &arith_r_data;\n#endif\n    \n    compptr = cinfo->cur_comp_info[ci];\n\n#ifdef C_ARITH_CODING_SUPPORTED\n    if (cinfo->arith_code)\n      jget_arith_rates(cinfo, compptr->dc_tbl_no, compptr->ac_tbl_no, arith_r);\n    else\n#endif\n    {\n      jpeg_make_c_derived_tbl(cinfo, TRUE, compptr->dc_tbl_no, &dctbl);\n      jpeg_make_c_derived_tbl(cinfo, FALSE, compptr->ac_tbl_no, &actbl);\n    }\n\n    /* Align the virtual buffer for this component. */\n    buffer = (*cinfo->mem->access_virt_barray)\n    ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],\n     coef->iMCU_row_num * compptr->v_samp_factor,\n     (JDIMENSION)compptr->v_samp_factor, TRUE);\n    \n    buffer_dst = (*cinfo->mem->access_virt_barray)\n    ((j_common_ptr) cinfo, coef->whole_image_uq[compptr->component_index],\n     coef->iMCU_row_num * compptr->v_samp_factor,\n     (JDIMENSION)compptr->v_samp_factor, TRUE);\n    \n    /* Count non-dummy DCT block rows in this iMCU row. */\n    if (coef->iMCU_row_num < last_iMCU_row)\n      block_rows = compptr->v_samp_factor;\n    else {\n      /* NB: can't use last_row_height here, since may not be set! */\n      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);\n      if (block_rows == 0) block_rows = compptr->v_samp_factor;\n    }\n    blocks_across = compptr->width_in_blocks;\n    h_samp_factor = compptr->h_samp_factor;\n    /* Count number of dummy blocks to be added at the right margin. */\n    ndummy = (int) (blocks_across % h_samp_factor);\n    if (ndummy > 0)\n      ndummy = h_samp_factor - ndummy;\n    \n    lastDC = 0;\n\n    /* Perform DCT for all non-dummy blocks in this iMCU row.  Each call\n     * on forward_DCT processes a complete horizontal row of DCT blocks.\n     */\n    for (block_row = 0; block_row < block_rows; block_row++) {\n      thisblockrow = buffer[block_row];\n      lastblockrow = (block_row > 0) ? buffer[block_row-1] : NULL;\n#ifdef C_ARITH_CODING_SUPPORTED\n      if (cinfo->arith_code)\n        quantize_trellis_arith(cinfo, arith_r, thisblockrow,\n                               buffer_dst[block_row], blocks_across,\n                               cinfo->quant_tbl_ptrs[compptr->quant_tbl_no],\n                               cinfo->master->norm_src[compptr->quant_tbl_no],\n                               cinfo->master->norm_coef[compptr->quant_tbl_no],\n                               &lastDC, lastblockrow, buffer_dst[block_row-1]);\n      else\n#endif\n        quantize_trellis(cinfo, dctbl, actbl, thisblockrow,\n                         buffer_dst[block_row], blocks_across,\n                         cinfo->quant_tbl_ptrs[compptr->quant_tbl_no],\n                         cinfo->master->norm_src[compptr->quant_tbl_no],\n                         cinfo->master->norm_coef[compptr->quant_tbl_no],\n                         &lastDC, lastblockrow, buffer_dst[block_row-1]);\n      \n      if (ndummy > 0) {\n        /* Create dummy blocks at the right edge of the image. */\n        thisblockrow += blocks_across; /* => first dummy block */\n        jzero_far((void *) thisblockrow, ndummy * sizeof(JBLOCK));\n        lastDC = thisblockrow[-1][0];\n        for (bi = 0; bi < ndummy; bi++) {\n          thisblockrow[bi][0] = lastDC;\n        }\n      }\n    }\n    /* If at end of image, create dummy block rows as needed.\n     * The tricky part here is that within each MCU, we want the DC values\n     * of the dummy blocks to match the last real block's DC value.\n     * This squeezes a few more bytes out of the resulting file...\n     */\n    if (coef->iMCU_row_num == last_iMCU_row) {\n      blocks_across += ndummy;  /* include lower right corner */\n      MCUs_across = blocks_across / h_samp_factor;\n      for (block_row = block_rows; block_row < compptr->v_samp_factor;\n           block_row++) {\n        thisblockrow = buffer[block_row];\n        lastblockrow = buffer[block_row-1];\n        jzero_far((void *) thisblockrow,\n                  (size_t) (blocks_across * sizeof(JBLOCK)));\n        for (MCUindex = 0; MCUindex < MCUs_across; MCUindex++) {\n          lastDC = lastblockrow[h_samp_factor-1][0];\n          for (bi = 0; bi < h_samp_factor; bi++) {\n            thisblockrow[bi][0] = lastDC;\n          }\n          thisblockrow += h_samp_factor; /* advance to next MCU in row */\n          lastblockrow += h_samp_factor;\n        }\n      }\n    }\n  }\n\n  /* NB: compress_output will increment iMCU_row_num if successful.\n   * A suspension return will result in redoing all the work above next time.\n   */\n  \n  /* Emit data to the entropy encoder, sharing code with subsequent passes */\n  return compress_output(cinfo, input_buf);\n}\n#endif\n\n/*\n * Process some data in subsequent passes of a multi-pass case.\n * We process the equivalent of one fully interleaved MCU row (\"iMCU\" row)\n * per call, ie, v_samp_factor block rows for each component in the scan.\n * The data is obtained from the virtual arrays and fed to the entropy coder.\n * Returns TRUE if the iMCU row is completed, FALSE if suspended.\n *\n * NB: input_buf is ignored; it is likely to be a NULL pointer.\n */\n\nMETHODDEF(boolean)\ncompress_output(j_compress_ptr cinfo, _JSAMPIMAGE input_buf)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  JDIMENSION MCU_col_num;       /* index of current MCU within row */\n  int blkn, ci, xindex, yindex, yoffset;\n  JDIMENSION start_col;\n  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];\n  JBLOCKROW buffer_ptr;\n  jpeg_component_info *compptr;\n\n  /* Align the virtual buffers for the components used in this scan.\n   * NB: during first pass, this is safe only because the buffers will\n   * already be aligned properly, so jmemmgr.c won't need to do any I/O.\n   */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    buffer[ci] = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr)cinfo, coef->whole_image[compptr->component_index],\n       coef->iMCU_row_num * compptr->v_samp_factor,\n       (JDIMENSION)compptr->v_samp_factor, FALSE);\n  }\n\n  /* Loop to process one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;\n         MCU_col_num++) {\n      /* Construct list of pointers to DCT blocks belonging to this MCU */\n      blkn = 0;                 /* index of current DCT block within MCU */\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n        compptr = cinfo->cur_comp_info[ci];\n        start_col = MCU_col_num * compptr->MCU_width;\n        for (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n          buffer_ptr = buffer[ci][yindex + yoffset] + start_col;\n          for (xindex = 0; xindex < compptr->MCU_width; xindex++) {\n            coef->MCU_buffer[blkn++] = buffer_ptr++;\n          }\n        }\n      }\n      /* Try to write the MCU. */\n      if (!(*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {\n        /* Suspension forced; update state counters and exit */\n        coef->MCU_vert_offset = yoffset;\n        coef->mcu_ctr = MCU_col_num;\n        return FALSE;\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->mcu_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  coef->iMCU_row_num++;\n  start_iMCU_row(cinfo);\n  return TRUE;\n}\n\n#endif /* FULL_COEF_BUFFER_SUPPORTED */\n\n\n/*\n * Initialize coefficient buffer controller.\n */\n\nGLOBAL(void)\n_jinit_c_coef_controller(j_compress_ptr cinfo, boolean need_full_buffer)\n{\n  my_coef_ptr coef;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  coef = (my_coef_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_coef_controller));\n  memset(coef, 0, sizeof(my_coef_controller));\n  cinfo->coef = (struct jpeg_c_coef_controller *)coef;\n  coef->pub.start_pass = start_pass_coef;\n\n  /* Create the coefficient buffer. */\n  if (need_full_buffer) {\n#ifdef FULL_COEF_BUFFER_SUPPORTED\n    /* Allocate a full-image virtual array for each component, */\n    /* padded to a multiple of samp_factor DCT blocks in each direction. */\n    int ci;\n    jpeg_component_info *compptr;\n\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)\n        ((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,\n         (JDIMENSION)jround_up((long) compptr->width_in_blocks,\n                                (long) compptr->h_samp_factor),\n         (JDIMENSION)jround_up((long) compptr->height_in_blocks,\n                                (long) compptr->v_samp_factor),\n         (JDIMENSION)compptr->v_samp_factor);\n      \n      coef->whole_image_uq[ci] = (*cinfo->mem->request_virt_barray)\n        ((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,\n         (JDIMENSION)jround_up((long) compptr->width_in_blocks,\n                                (long) compptr->h_samp_factor),\n         (JDIMENSION)jround_up((long) compptr->height_in_blocks,\n                                (long) compptr->v_samp_factor),\n         (JDIMENSION)compptr->v_samp_factor);\n    }\n#else\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n#endif\n  } else {\n    /* We only need a single-MCU buffer. */\n    JBLOCKROW buffer;\n    int i;\n\n    buffer = (JBLOCKROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  C_MAX_BLOCKS_IN_MCU * sizeof(JBLOCK));\n    for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {\n      coef->MCU_buffer[i] = buffer + i;\n    }\n    coef->whole_image[0] = NULL; /* flag for no virtual arrays */\n  }\n}\n"
        },
        {
          "name": "jccolext.c",
          "type": "blob",
          "size": 4.677734375,
          "content": "/*\n * jccolext.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2009-2012, 2015, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains input colorspace conversion routines.\n */\n\n\n/* This file is included by jccolor.c */\n\n\n/*\n * Convert some rows of samples to the JPEG colorspace.\n *\n * Note that we change from the application's interleaved-pixel format\n * to our internal noninterleaved, one-plane-per-component format.\n * The input buffer is therefore three times as wide as the output buffer.\n *\n * A starting row offset is provided only for the output buffer.  The caller\n * can easily adjust the passed input_buf value to accommodate any row\n * offset required on that side.\n */\n\nINLINE\nLOCAL(void)\nrgb_ycc_convert_internal(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                         _JSAMPIMAGE output_buf, JDIMENSION output_row,\n                         int num_rows)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  register int r, g, b;\n  register JLONG *ctab = cconvert->rgb_ycc_tab;\n  register _JSAMPROW inptr;\n  register _JSAMPROW outptr0, outptr1, outptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr0 = output_buf[0][output_row];\n    outptr1 = output_buf[1][output_row];\n    outptr2 = output_buf[2][output_row];\n    output_row++;\n    for (col = 0; col < num_cols; col++) {\n      r = RANGE_LIMIT(inptr[RGB_RED]);\n      g = RANGE_LIMIT(inptr[RGB_GREEN]);\n      b = RANGE_LIMIT(inptr[RGB_BLUE]);\n      inptr += RGB_PIXELSIZE;\n      /* If the inputs are 0.._MAXJSAMPLE, the outputs of these equations\n       * must be too; we do not need an explicit range-limiting operation.\n       * Hence the value being shifted is never negative, and we don't\n       * need the general RIGHT_SHIFT macro.\n       */\n      /* Y */\n      outptr0[col] = (_JSAMPLE)((ctab[r + R_Y_OFF] + ctab[g + G_Y_OFF] +\n                                 ctab[b + B_Y_OFF]) >> SCALEBITS);\n      /* Cb */\n      outptr1[col] = (_JSAMPLE)((ctab[r + R_CB_OFF] + ctab[g + G_CB_OFF] +\n                                 ctab[b + B_CB_OFF]) >> SCALEBITS);\n      /* Cr */\n      outptr2[col] = (_JSAMPLE)((ctab[r + R_CR_OFF] + ctab[g + G_CR_OFF] +\n                                 ctab[b + B_CR_OFF]) >> SCALEBITS);\n    }\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\n/**************** Cases other than RGB -> YCbCr **************/\n\n\n/*\n * Convert some rows of samples to the JPEG colorspace.\n * This version handles RGB->grayscale conversion, which is the same\n * as the RGB->Y portion of RGB->YCbCr.\n * We assume rgb_ycc_start has been called (we only use the Y tables).\n */\n\nINLINE\nLOCAL(void)\nrgb_gray_convert_internal(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                          _JSAMPIMAGE output_buf, JDIMENSION output_row,\n                          int num_rows)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  register int r, g, b;\n  register JLONG *ctab = cconvert->rgb_ycc_tab;\n  register _JSAMPROW inptr;\n  register _JSAMPROW outptr;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr = output_buf[0][output_row];\n    output_row++;\n    for (col = 0; col < num_cols; col++) {\n      r = RANGE_LIMIT(inptr[RGB_RED]);\n      g = RANGE_LIMIT(inptr[RGB_GREEN]);\n      b = RANGE_LIMIT(inptr[RGB_BLUE]);\n      inptr += RGB_PIXELSIZE;\n      /* Y */\n      outptr[col] = (_JSAMPLE)((ctab[r + R_Y_OFF] + ctab[g + G_Y_OFF] +\n                                ctab[b + B_Y_OFF]) >> SCALEBITS);\n    }\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\n/*\n * Convert some rows of samples to the JPEG colorspace.\n * This version handles extended RGB->plain RGB conversion\n */\n\nINLINE\nLOCAL(void)\nrgb_rgb_convert_internal(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                         _JSAMPIMAGE output_buf, JDIMENSION output_row,\n                         int num_rows)\n{\n  register _JSAMPROW inptr;\n  register _JSAMPROW outptr0, outptr1, outptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr0 = output_buf[0][output_row];\n    outptr1 = output_buf[1][output_row];\n    outptr2 = output_buf[2][output_row];\n    output_row++;\n    for (col = 0; col < num_cols; col++) {\n      outptr0[col] = inptr[RGB_RED];\n      outptr1[col] = inptr[RGB_GREEN];\n      outptr2[col] = inptr[RGB_BLUE];\n      inptr += RGB_PIXELSIZE;\n    }\n  }\n}\n"
        },
        {
          "name": "jccolor.c",
          "type": "blob",
          "size": 23.486328125,
          "content": "/*\n * jccolor.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2009-2012, 2015, 2022, D. R. Commander.\n * Copyright (C) 2014, MIPS Technologies, Inc., California.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains input colorspace conversion routines.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsimd.h\"\n#include \"jsamplecomp.h\"\n\n\n#if BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED)\n\n/* Private subobject */\n\ntypedef struct {\n  struct jpeg_color_converter pub; /* public fields */\n\n#if BITS_IN_JSAMPLE != 16\n  /* Private state for RGB->YCC conversion */\n  JLONG *rgb_ycc_tab;           /* => table for RGB to YCbCr conversion */\n#endif\n} my_color_converter;\n\ntypedef my_color_converter *my_cconvert_ptr;\n\n\n/**************** RGB -> YCbCr conversion: most common case **************/\n\n/*\n * YCbCr is defined per CCIR 601-1, except that Cb and Cr are\n * normalized to the range 0.._MAXJSAMPLE rather than -0.5 .. 0.5.\n * The conversion equations to be implemented are therefore\n *      Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B\n *      Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + _CENTERJSAMPLE\n *      Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + _CENTERJSAMPLE\n * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)\n * Note: older versions of the IJG code used a zero offset of _MAXJSAMPLE/2,\n * rather than _CENTERJSAMPLE, for Cb and Cr.  This gave equal positive and\n * negative swings for Cb/Cr, but meant that grayscale values (Cb=Cr=0)\n * were not represented exactly.  Now we sacrifice exact representation of\n * maximum red and maximum blue in order to get exact grayscales.\n *\n * To avoid floating-point arithmetic, we represent the fractional constants\n * as integers scaled up by 2^16 (about 4 digits precision); we have to divide\n * the products by 2^16, with appropriate rounding, to get the correct answer.\n *\n * For even more speed, we avoid doing any multiplications in the inner loop\n * by precalculating the constants times R,G,B for all possible values.\n * For 8-bit samples this is very reasonable (only 256 entries per table);\n * for 12-bit samples it is still acceptable.  It's not very reasonable for\n * 16-bit samples, but if you want lossless storage you shouldn't be changing\n * colorspace anyway.\n * The _CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included\n * in the tables to save adding them separately in the inner loop.\n */\n\n#define SCALEBITS       16      /* speediest right-shift on some machines */\n#define CBCR_OFFSET     ((JLONG)_CENTERJSAMPLE << SCALEBITS)\n#define ONE_HALF        ((JLONG)1 << (SCALEBITS - 1))\n#define FIX(x)          ((JLONG)((x) * (1L << SCALEBITS) + 0.5))\n\n/* We allocate one big table and divide it up into eight parts, instead of\n * doing eight alloc_small requests.  This lets us use a single table base\n * address, which can be held in a register in the inner loops on many\n * machines (more than can hold all eight addresses, anyway).\n */\n\n#define R_Y_OFF         0                       /* offset to R => Y section */\n#define G_Y_OFF         (1 * (_MAXJSAMPLE + 1)) /* offset to G => Y section */\n#define B_Y_OFF         (2 * (_MAXJSAMPLE + 1)) /* etc. */\n#define R_CB_OFF        (3 * (_MAXJSAMPLE + 1))\n#define G_CB_OFF        (4 * (_MAXJSAMPLE + 1))\n#define B_CB_OFF        (5 * (_MAXJSAMPLE + 1))\n#define R_CR_OFF        B_CB_OFF                /* B=>Cb, R=>Cr are the same */\n#define G_CR_OFF        (6 * (_MAXJSAMPLE + 1))\n#define B_CR_OFF        (7 * (_MAXJSAMPLE + 1))\n#define TABLE_SIZE      (8 * (_MAXJSAMPLE + 1))\n\n/* 12-bit samples use a 16-bit data type, so it is possible to pass\n * out-of-range sample values (< 0 or > 4095) to jpeg_write_scanlines().\n * Thus, we mask the incoming 12-bit samples to guard against overrunning\n * or underrunning the conversion tables.\n */\n\n#if BITS_IN_JSAMPLE == 12\n#define RANGE_LIMIT(value)  ((value) & 0xFFF)\n#else\n#define RANGE_LIMIT(value)  (value)\n#endif\n\n\n/* Include inline routines for colorspace extensions */\n\n#include \"jccolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n\n#define RGB_RED  EXT_RGB_RED\n#define RGB_GREEN  EXT_RGB_GREEN\n#define RGB_BLUE  EXT_RGB_BLUE\n#define RGB_PIXELSIZE  EXT_RGB_PIXELSIZE\n#define rgb_ycc_convert_internal  extrgb_ycc_convert_internal\n#define rgb_gray_convert_internal  extrgb_gray_convert_internal\n#define rgb_rgb_convert_internal  extrgb_rgb_convert_internal\n#include \"jccolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n#undef rgb_ycc_convert_internal\n#undef rgb_gray_convert_internal\n#undef rgb_rgb_convert_internal\n\n#define RGB_RED  EXT_RGBX_RED\n#define RGB_GREEN  EXT_RGBX_GREEN\n#define RGB_BLUE  EXT_RGBX_BLUE\n#define RGB_PIXELSIZE  EXT_RGBX_PIXELSIZE\n#define rgb_ycc_convert_internal  extrgbx_ycc_convert_internal\n#define rgb_gray_convert_internal  extrgbx_gray_convert_internal\n#define rgb_rgb_convert_internal  extrgbx_rgb_convert_internal\n#include \"jccolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n#undef rgb_ycc_convert_internal\n#undef rgb_gray_convert_internal\n#undef rgb_rgb_convert_internal\n\n#define RGB_RED  EXT_BGR_RED\n#define RGB_GREEN  EXT_BGR_GREEN\n#define RGB_BLUE  EXT_BGR_BLUE\n#define RGB_PIXELSIZE  EXT_BGR_PIXELSIZE\n#define rgb_ycc_convert_internal  extbgr_ycc_convert_internal\n#define rgb_gray_convert_internal  extbgr_gray_convert_internal\n#define rgb_rgb_convert_internal  extbgr_rgb_convert_internal\n#include \"jccolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n#undef rgb_ycc_convert_internal\n#undef rgb_gray_convert_internal\n#undef rgb_rgb_convert_internal\n\n#define RGB_RED  EXT_BGRX_RED\n#define RGB_GREEN  EXT_BGRX_GREEN\n#define RGB_BLUE  EXT_BGRX_BLUE\n#define RGB_PIXELSIZE  EXT_BGRX_PIXELSIZE\n#define rgb_ycc_convert_internal  extbgrx_ycc_convert_internal\n#define rgb_gray_convert_internal  extbgrx_gray_convert_internal\n#define rgb_rgb_convert_internal  extbgrx_rgb_convert_internal\n#include \"jccolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n#undef rgb_ycc_convert_internal\n#undef rgb_gray_convert_internal\n#undef rgb_rgb_convert_internal\n\n#define RGB_RED  EXT_XBGR_RED\n#define RGB_GREEN  EXT_XBGR_GREEN\n#define RGB_BLUE  EXT_XBGR_BLUE\n#define RGB_PIXELSIZE  EXT_XBGR_PIXELSIZE\n#define rgb_ycc_convert_internal  extxbgr_ycc_convert_internal\n#define rgb_gray_convert_internal  extxbgr_gray_convert_internal\n#define rgb_rgb_convert_internal  extxbgr_rgb_convert_internal\n#include \"jccolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n#undef rgb_ycc_convert_internal\n#undef rgb_gray_convert_internal\n#undef rgb_rgb_convert_internal\n\n#define RGB_RED  EXT_XRGB_RED\n#define RGB_GREEN  EXT_XRGB_GREEN\n#define RGB_BLUE  EXT_XRGB_BLUE\n#define RGB_PIXELSIZE  EXT_XRGB_PIXELSIZE\n#define rgb_ycc_convert_internal  extxrgb_ycc_convert_internal\n#define rgb_gray_convert_internal  extxrgb_gray_convert_internal\n#define rgb_rgb_convert_internal  extxrgb_rgb_convert_internal\n#include \"jccolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n#undef rgb_ycc_convert_internal\n#undef rgb_gray_convert_internal\n#undef rgb_rgb_convert_internal\n\n\n/*\n * Initialize for RGB->YCC colorspace conversion.\n */\n\nMETHODDEF(void)\nrgb_ycc_start(j_compress_ptr cinfo)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  JLONG *rgb_ycc_tab;\n  JLONG i;\n\n  /* Allocate and fill in the conversion tables. */\n  cconvert->rgb_ycc_tab = rgb_ycc_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (TABLE_SIZE * sizeof(JLONG)));\n\n  for (i = 0; i <= _MAXJSAMPLE; i++) {\n    rgb_ycc_tab[i + R_Y_OFF] = FIX(0.29900) * i;\n    rgb_ycc_tab[i + G_Y_OFF] = FIX(0.58700) * i;\n    rgb_ycc_tab[i + B_Y_OFF] = FIX(0.11400) * i   + ONE_HALF;\n    rgb_ycc_tab[i + R_CB_OFF] = (-FIX(0.16874)) * i;\n    rgb_ycc_tab[i + G_CB_OFF] = (-FIX(0.33126)) * i;\n    /* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.\n     * This ensures that the maximum output will round to _MAXJSAMPLE\n     * not _MAXJSAMPLE+1, and thus that we don't have to range-limit.\n     */\n    rgb_ycc_tab[i + B_CB_OFF] = FIX(0.50000) * i  + CBCR_OFFSET + ONE_HALF - 1;\n/*  B=>Cb and R=>Cr tables are the same\n    rgb_ycc_tab[i + R_CR_OFF] = FIX(0.50000) * i  + CBCR_OFFSET + ONE_HALF - 1;\n*/\n    rgb_ycc_tab[i + G_CR_OFF] = (-FIX(0.41869)) * i;\n    rgb_ycc_tab[i + B_CR_OFF] = (-FIX(0.08131)) * i;\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\n/*\n * Convert some rows of samples to the JPEG colorspace.\n */\n\nMETHODDEF(void)\nrgb_ycc_convert(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                _JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)\n{\n  switch (cinfo->in_color_space) {\n  case JCS_EXT_RGB:\n    extrgb_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                num_rows);\n    break;\n  case JCS_EXT_RGBX:\n  case JCS_EXT_RGBA:\n    extrgbx_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                 num_rows);\n    break;\n  case JCS_EXT_BGR:\n    extbgr_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                num_rows);\n    break;\n  case JCS_EXT_BGRX:\n  case JCS_EXT_BGRA:\n    extbgrx_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                 num_rows);\n    break;\n  case JCS_EXT_XBGR:\n  case JCS_EXT_ABGR:\n    extxbgr_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                 num_rows);\n    break;\n  case JCS_EXT_XRGB:\n  case JCS_EXT_ARGB:\n    extxrgb_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                 num_rows);\n    break;\n  default:\n    rgb_ycc_convert_internal(cinfo, input_buf, output_buf, output_row,\n                             num_rows);\n    break;\n  }\n}\n\n\n/**************** Cases other than RGB -> YCbCr **************/\n\n\n/*\n * Convert some rows of samples to the JPEG colorspace.\n */\n\nMETHODDEF(void)\nrgb_gray_convert(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                 _JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)\n{\n  switch (cinfo->in_color_space) {\n  case JCS_EXT_RGB:\n    extrgb_gray_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                 num_rows);\n    break;\n  case JCS_EXT_RGBX:\n  case JCS_EXT_RGBA:\n    extrgbx_gray_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                  num_rows);\n    break;\n  case JCS_EXT_BGR:\n    extbgr_gray_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                 num_rows);\n    break;\n  case JCS_EXT_BGRX:\n  case JCS_EXT_BGRA:\n    extbgrx_gray_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                  num_rows);\n    break;\n  case JCS_EXT_XBGR:\n  case JCS_EXT_ABGR:\n    extxbgr_gray_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                  num_rows);\n    break;\n  case JCS_EXT_XRGB:\n  case JCS_EXT_ARGB:\n    extxrgb_gray_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                  num_rows);\n    break;\n  default:\n    rgb_gray_convert_internal(cinfo, input_buf, output_buf, output_row,\n                              num_rows);\n    break;\n  }\n}\n\n\n/*\n * Extended RGB to plain RGB conversion\n */\n\nMETHODDEF(void)\nrgb_rgb_convert(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                _JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)\n{\n  switch (cinfo->in_color_space) {\n  case JCS_EXT_RGB:\n    extrgb_rgb_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                num_rows);\n    break;\n  case JCS_EXT_RGBX:\n  case JCS_EXT_RGBA:\n    extrgbx_rgb_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                 num_rows);\n    break;\n  case JCS_EXT_BGR:\n    extbgr_rgb_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                num_rows);\n    break;\n  case JCS_EXT_BGRX:\n  case JCS_EXT_BGRA:\n    extbgrx_rgb_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                 num_rows);\n    break;\n  case JCS_EXT_XBGR:\n  case JCS_EXT_ABGR:\n    extxbgr_rgb_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                 num_rows);\n    break;\n  case JCS_EXT_XRGB:\n  case JCS_EXT_ARGB:\n    extxrgb_rgb_convert_internal(cinfo, input_buf, output_buf, output_row,\n                                 num_rows);\n    break;\n  default:\n    rgb_rgb_convert_internal(cinfo, input_buf, output_buf, output_row,\n                             num_rows);\n    break;\n  }\n}\n\n\n/*\n * Convert some rows of samples to the JPEG colorspace.\n * This version handles Adobe-style CMYK->YCCK conversion,\n * where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same\n * conversion as above, while passing K (black) unchanged.\n * We assume rgb_ycc_start has been called.\n */\n\nMETHODDEF(void)\ncmyk_ycck_convert(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                  _JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  register int r, g, b;\n  register JLONG *ctab = cconvert->rgb_ycc_tab;\n  register _JSAMPROW inptr;\n  register _JSAMPROW outptr0, outptr1, outptr2, outptr3;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr0 = output_buf[0][output_row];\n    outptr1 = output_buf[1][output_row];\n    outptr2 = output_buf[2][output_row];\n    outptr3 = output_buf[3][output_row];\n    output_row++;\n    for (col = 0; col < num_cols; col++) {\n      r = _MAXJSAMPLE - RANGE_LIMIT(inptr[0]);\n      g = _MAXJSAMPLE - RANGE_LIMIT(inptr[1]);\n      b = _MAXJSAMPLE - RANGE_LIMIT(inptr[2]);\n      /* K passes through as-is */\n      outptr3[col] = inptr[3];\n      inptr += 4;\n      /* If the inputs are 0.._MAXJSAMPLE, the outputs of these equations\n       * must be too; we do not need an explicit range-limiting operation.\n       * Hence the value being shifted is never negative, and we don't\n       * need the general RIGHT_SHIFT macro.\n       */\n      /* Y */\n      outptr0[col] = (_JSAMPLE)((ctab[r + R_Y_OFF] + ctab[g + G_Y_OFF] +\n                                 ctab[b + B_Y_OFF]) >> SCALEBITS);\n      /* Cb */\n      outptr1[col] = (_JSAMPLE)((ctab[r + R_CB_OFF] + ctab[g + G_CB_OFF] +\n                                 ctab[b + B_CB_OFF]) >> SCALEBITS);\n      /* Cr */\n      outptr2[col] = (_JSAMPLE)((ctab[r + R_CR_OFF] + ctab[g + G_CR_OFF] +\n                                 ctab[b + B_CR_OFF]) >> SCALEBITS);\n    }\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\n/*\n * Convert some rows of samples to the JPEG colorspace.\n * This version handles grayscale output with no conversion.\n * The source can be either plain grayscale or YCbCr (since Y == gray).\n */\n\nMETHODDEF(void)\ngrayscale_convert(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                  _JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)\n{\n  register _JSAMPROW inptr;\n  register _JSAMPROW outptr;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->image_width;\n  int instride = cinfo->input_components;\n\n  while (--num_rows >= 0) {\n    inptr = *input_buf++;\n    outptr = output_buf[0][output_row];\n    output_row++;\n    for (col = 0; col < num_cols; col++) {\n      outptr[col] = inptr[0];\n      inptr += instride;\n    }\n  }\n}\n\n\n/*\n * Convert some rows of samples to the JPEG colorspace.\n * This version handles multi-component colorspaces without conversion.\n * We assume input_components == num_components.\n */\n\nMETHODDEF(void)\nnull_convert(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n             _JSAMPIMAGE output_buf, JDIMENSION output_row, int num_rows)\n{\n  register _JSAMPROW inptr;\n  register _JSAMPROW outptr, outptr0, outptr1, outptr2, outptr3;\n  register JDIMENSION col;\n  register int ci;\n  int nc = cinfo->num_components;\n  JDIMENSION num_cols = cinfo->image_width;\n\n  if (nc == 3) {\n    while (--num_rows >= 0) {\n      inptr = *input_buf++;\n      outptr0 = output_buf[0][output_row];\n      outptr1 = output_buf[1][output_row];\n      outptr2 = output_buf[2][output_row];\n      output_row++;\n      for (col = 0; col < num_cols; col++) {\n        outptr0[col] = *inptr++;\n        outptr1[col] = *inptr++;\n        outptr2[col] = *inptr++;\n      }\n    }\n  } else if (nc == 4) {\n    while (--num_rows >= 0) {\n      inptr = *input_buf++;\n      outptr0 = output_buf[0][output_row];\n      outptr1 = output_buf[1][output_row];\n      outptr2 = output_buf[2][output_row];\n      outptr3 = output_buf[3][output_row];\n      output_row++;\n      for (col = 0; col < num_cols; col++) {\n        outptr0[col] = *inptr++;\n        outptr1[col] = *inptr++;\n        outptr2[col] = *inptr++;\n        outptr3[col] = *inptr++;\n      }\n    }\n  } else {\n    while (--num_rows >= 0) {\n      /* It seems fastest to make a separate pass for each component. */\n      for (ci = 0; ci < nc; ci++) {\n        inptr = *input_buf;\n        outptr = output_buf[ci][output_row];\n        for (col = 0; col < num_cols; col++) {\n          outptr[col] = inptr[ci];\n          inptr += nc;\n        }\n      }\n      input_buf++;\n      output_row++;\n    }\n  }\n}\n\n\n/*\n * Empty method for start_pass.\n */\n\nMETHODDEF(void)\nnull_method(j_compress_ptr cinfo)\n{\n  /* no work needed */\n}\n\n\n/*\n * Module initialization routine for input colorspace conversion.\n */\n\nGLOBAL(void)\n_jinit_color_converter(j_compress_ptr cinfo)\n{\n  my_cconvert_ptr cconvert;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  cconvert = (my_cconvert_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_color_converter));\n  cinfo->cconvert = (struct jpeg_color_converter *)cconvert;\n  /* set start_pass to null method until we find out differently */\n  cconvert->pub.start_pass = null_method;\n\n  /* Make sure input_components agrees with in_color_space */\n  switch (cinfo->in_color_space) {\n  case JCS_GRAYSCALE:\n    if (cinfo->input_components != 1)\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    break;\n\n  case JCS_RGB:\n  case JCS_EXT_RGB:\n  case JCS_EXT_RGBX:\n  case JCS_EXT_BGR:\n  case JCS_EXT_BGRX:\n  case JCS_EXT_XBGR:\n  case JCS_EXT_XRGB:\n  case JCS_EXT_RGBA:\n  case JCS_EXT_BGRA:\n  case JCS_EXT_ABGR:\n  case JCS_EXT_ARGB:\n    if (cinfo->input_components != rgb_pixelsize[cinfo->in_color_space])\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    break;\n\n  case JCS_YCbCr:\n    if (cinfo->input_components != 3)\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    break;\n\n  case JCS_CMYK:\n  case JCS_YCCK:\n    if (cinfo->input_components != 4)\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    break;\n\n  default:                      /* JCS_UNKNOWN can be anything */\n    if (cinfo->input_components < 1)\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    break;\n  }\n\n  /* Check num_components, set conversion method based on requested space.\n   * NOTE: We do not allow any lossy color conversion algorithms in lossless\n   * mode.\n   */\n  switch (cinfo->jpeg_color_space) {\n  case JCS_GRAYSCALE:\n#ifdef C_LOSSLESS_SUPPORTED\n    if (cinfo->master->lossless &&\n        cinfo->in_color_space != cinfo->jpeg_color_space)\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n    if (cinfo->num_components != 1)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    if (cinfo->in_color_space == JCS_GRAYSCALE)\n      cconvert->pub._color_convert = grayscale_convert;\n    else if (IsExtRGB(cinfo->in_color_space)) {\n#ifdef WITH_SIMD\n      if (jsimd_can_rgb_gray())\n        cconvert->pub._color_convert = jsimd_rgb_gray_convert;\n      else\n#endif\n      {\n        cconvert->pub.start_pass = rgb_ycc_start;\n        cconvert->pub._color_convert = rgb_gray_convert;\n      }\n    } else if (cinfo->in_color_space == JCS_YCbCr)\n      cconvert->pub._color_convert = grayscale_convert;\n    else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  case JCS_RGB:\n#ifdef C_LOSSLESS_SUPPORTED\n    if (cinfo->master->lossless && !IsExtRGB(cinfo->in_color_space))\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n    if (cinfo->num_components != 3)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    if (rgb_red[cinfo->in_color_space] == 0 &&\n        rgb_green[cinfo->in_color_space] == 1 &&\n        rgb_blue[cinfo->in_color_space] == 2 &&\n        rgb_pixelsize[cinfo->in_color_space] == 3) {\n#if defined(WITH_SIMD) && defined(__mips__)\n      if (jsimd_c_can_null_convert())\n        cconvert->pub._color_convert = jsimd_c_null_convert;\n      else\n#endif\n        cconvert->pub._color_convert = null_convert;\n    } else if (IsExtRGB(cinfo->in_color_space))\n      cconvert->pub._color_convert = rgb_rgb_convert;\n    else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  case JCS_YCbCr:\n#ifdef C_LOSSLESS_SUPPORTED\n    if (cinfo->master->lossless &&\n        cinfo->in_color_space != cinfo->jpeg_color_space)\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n    if (cinfo->num_components != 3)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    if (IsExtRGB(cinfo->in_color_space)) {\n#ifdef WITH_SIMD\n      if (jsimd_can_rgb_ycc())\n        cconvert->pub._color_convert = jsimd_rgb_ycc_convert;\n      else\n#endif\n      {\n        cconvert->pub.start_pass = rgb_ycc_start;\n        cconvert->pub._color_convert = rgb_ycc_convert;\n      }\n    } else if (cinfo->in_color_space == JCS_YCbCr) {\n#if defined(WITH_SIMD) && defined(__mips__)\n      if (jsimd_c_can_null_convert())\n        cconvert->pub._color_convert = jsimd_c_null_convert;\n      else\n#endif\n        cconvert->pub._color_convert = null_convert;\n    } else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  case JCS_CMYK:\n#ifdef C_LOSSLESS_SUPPORTED\n    if (cinfo->master->lossless &&\n        cinfo->in_color_space != cinfo->jpeg_color_space)\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n    if (cinfo->num_components != 4)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    if (cinfo->in_color_space == JCS_CMYK) {\n#if defined(WITH_SIMD) && defined(__mips__)\n      if (jsimd_c_can_null_convert())\n        cconvert->pub._color_convert = jsimd_c_null_convert;\n      else\n#endif\n        cconvert->pub._color_convert = null_convert;\n    } else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  case JCS_YCCK:\n#ifdef C_LOSSLESS_SUPPORTED\n    if (cinfo->master->lossless &&\n        cinfo->in_color_space != cinfo->jpeg_color_space)\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n    if (cinfo->num_components != 4)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    if (cinfo->in_color_space == JCS_CMYK) {\n      cconvert->pub.start_pass = rgb_ycc_start;\n      cconvert->pub._color_convert = cmyk_ycck_convert;\n    } else if (cinfo->in_color_space == JCS_YCCK) {\n#if defined(WITH_SIMD) && defined(__mips__)\n      if (jsimd_c_can_null_convert())\n        cconvert->pub._color_convert = jsimd_c_null_convert;\n      else\n#endif\n        cconvert->pub._color_convert = null_convert;\n    } else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  default:                      /* allow null conversion of JCS_UNKNOWN */\n    if (cinfo->jpeg_color_space != cinfo->in_color_space ||\n        cinfo->num_components != cinfo->input_components)\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#if defined(WITH_SIMD) && defined(__mips__)\n    if (jsimd_c_can_null_convert())\n      cconvert->pub._color_convert = jsimd_c_null_convert;\n    else\n#endif\n      cconvert->pub._color_convert = null_convert;\n    break;\n  }\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED) */\n"
        },
        {
          "name": "jcdctmgr.c",
          "type": "blob",
          "size": 55.0498046875,
          "content": "/*\n * jcdctmgr.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 1999-2006, MIYASAKA Masaru.\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2011, 2014-2015, 2022, 2024, D. R. Commander.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the forward-DCT management logic.\n * This code selects a particular DCT implementation to be used,\n * and it performs related housekeeping chores including coefficient\n * quantization.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdct.h\"               /* Private declarations for DCT subsystem */\n#include \"jsimddct.h\"\n#include \"jchuff.h\"\n#include \"jpeg_nbits.h\"\n#include <assert.h>\n#include <math.h>\n\n\n/* Private subobject for this module */\n\ntypedef void (*forward_DCT_method_ptr) (DCTELEM *data);\ntypedef void (*float_DCT_method_ptr) (FAST_FLOAT *data);\n\ntypedef void (*convsamp_method_ptr) (_JSAMPARRAY sample_data,\n                                     JDIMENSION start_col,\n                                     DCTELEM *workspace);\ntypedef void (*preprocess_method_ptr)(DCTELEM*, const JQUANT_TBL*);\ntypedef void (*float_preprocess_method_ptr)(FAST_FLOAT*, const JQUANT_TBL*);\ntypedef void (*float_convsamp_method_ptr) (_JSAMPARRAY sample_data,\n                                           JDIMENSION start_col,\n                                           FAST_FLOAT *workspace);\n\ntypedef void (*quantize_method_ptr) (JCOEFPTR coef_block, DCTELEM *divisors,\n                                     DCTELEM *workspace);\ntypedef void (*float_quantize_method_ptr) (JCOEFPTR coef_block,\n                                           FAST_FLOAT *divisors,\n                                           FAST_FLOAT *workspace);\n\nMETHODDEF(void) quantize(JCOEFPTR, DCTELEM *, DCTELEM *);\n\ntypedef struct {\n  struct jpeg_forward_dct pub;  /* public fields */\n\n  /* Pointer to the DCT routine actually in use */\n  forward_DCT_method_ptr dct;\n  convsamp_method_ptr convsamp;\n  preprocess_method_ptr preprocess;\n  quantize_method_ptr quantize;\n\n  /* The actual post-DCT divisors --- not identical to the quant table\n   * entries, because of scaling (especially for an unnormalized DCT).\n   * Each table is given in normal array order.\n   */\n  DCTELEM *divisors[NUM_QUANT_TBLS];\n\n  /* work area for FDCT subroutine */\n  DCTELEM *workspace;\n\n#ifdef DCT_FLOAT_SUPPORTED\n  /* Same as above for the floating-point case. */\n  float_DCT_method_ptr float_dct;\n  float_convsamp_method_ptr float_convsamp;\n  float_preprocess_method_ptr float_preprocess;\n  float_quantize_method_ptr float_quantize;\n  FAST_FLOAT *float_divisors[NUM_QUANT_TBLS];\n  FAST_FLOAT *float_workspace;\n#endif\n} my_fdct_controller;\n\ntypedef my_fdct_controller *my_fdct_ptr;\n\n\n#if BITS_IN_JSAMPLE == 8\n\n/*\n * Find the highest bit in an integer through binary search.\n */\n\nLOCAL(int)\nflss(UINT16 val)\n{\n  int bit;\n\n  bit = 16;\n\n  if (!val)\n    return 0;\n\n  if (!(val & 0xff00)) {\n    bit -= 8;\n    val <<= 8;\n  }\n  if (!(val & 0xf000)) {\n    bit -= 4;\n    val <<= 4;\n  }\n  if (!(val & 0xc000)) {\n    bit -= 2;\n    val <<= 2;\n  }\n  if (!(val & 0x8000)) {\n    bit -= 1;\n    val <<= 1;\n  }\n\n  return bit;\n}\n\n\n/*\n * Compute values to do a division using reciprocal.\n *\n * This implementation is based on an algorithm described in\n *   \"Optimizing subroutines in assembly language:\n *   An optimization guide for x86 platforms\" (https://agner.org/optimize).\n * More information about the basic algorithm can be found in\n * the paper \"Integer Division Using Reciprocals\" by Robert Alverson.\n *\n * The basic idea is to replace x/d by x * d^-1. In order to store\n * d^-1 with enough precision we shift it left a few places. It turns\n * out that this algoright gives just enough precision, and also fits\n * into DCTELEM:\n *\n *   b = (the number of significant bits in divisor) - 1\n *   r = (word size) + b\n *   f = 2^r / divisor\n *\n * f will not be an integer for most cases, so we need to compensate\n * for the rounding error introduced:\n *\n *   no fractional part:\n *\n *       result = input >> r\n *\n *   fractional part of f < 0.5:\n *\n *       round f down to nearest integer\n *       result = ((input + 1) * f) >> r\n *\n *   fractional part of f > 0.5:\n *\n *       round f up to nearest integer\n *       result = (input * f) >> r\n *\n * This is the original algorithm that gives truncated results. But we\n * want properly rounded results, so we replace \"input\" with\n * \"input + divisor/2\".\n *\n * In order to allow SIMD implementations we also tweak the values to\n * allow the same calculation to be made at all times:\n *\n *   dctbl[0] = f rounded to nearest integer\n *   dctbl[1] = divisor / 2 (+ 1 if fractional part of f < 0.5)\n *   dctbl[2] = 1 << ((word size) * 2 - r)\n *   dctbl[3] = r - (word size)\n *\n * dctbl[2] is for stupid instruction sets where the shift operation\n * isn't member wise (e.g. MMX).\n *\n * The reason dctbl[2] and dctbl[3] reduce the shift with (word size)\n * is that most SIMD implementations have a \"multiply and store top\n * half\" operation.\n *\n * Lastly, we store each of the values in their own table instead\n * of in a consecutive manner, yet again in order to allow SIMD\n * routines.\n */\n\nLOCAL(int)\ncompute_reciprocal(UINT16 divisor, DCTELEM *dtbl)\n{\n  UDCTELEM2 fq, fr;\n  UDCTELEM c;\n  int b, r;\n\n  if (divisor == 1) {\n    /* divisor == 1 means unquantized, so these reciprocal/correction/shift\n     * values will cause the C quantization algorithm to act like the\n     * identity function.  Since only the C quantization algorithm is used in\n     * these cases, the scale value is irrelevant.\n     */\n    dtbl[DCTSIZE2 * 0] = (DCTELEM)1;                        /* reciprocal */\n    dtbl[DCTSIZE2 * 1] = (DCTELEM)0;                        /* correction */\n    dtbl[DCTSIZE2 * 2] = (DCTELEM)1;                        /* scale */\n    dtbl[DCTSIZE2 * 3] = -(DCTELEM)(sizeof(DCTELEM) * 8);   /* shift */\n    return 0;\n  }\n\n  b = flss(divisor) - 1;\n  r  = sizeof(DCTELEM) * 8 + b;\n\n  fq = ((UDCTELEM2)1 << r) / divisor;\n  fr = ((UDCTELEM2)1 << r) % divisor;\n\n  c = divisor / 2;                      /* for rounding */\n\n  if (fr == 0) {                        /* divisor is power of two */\n    /* fq will be one bit too large to fit in DCTELEM, so adjust */\n    fq >>= 1;\n    r--;\n  } else if (fr <= (divisor / 2U)) {    /* fractional part is < 0.5 */\n    c++;\n  } else {                              /* fractional part is > 0.5 */\n    fq++;\n  }\n\n  dtbl[DCTSIZE2 * 0] = (DCTELEM)fq;     /* reciprocal */\n  dtbl[DCTSIZE2 * 1] = (DCTELEM)c;      /* correction + roundfactor */\n#ifdef WITH_SIMD\n  dtbl[DCTSIZE2 * 2] = (DCTELEM)(1 << (sizeof(DCTELEM) * 8 * 2 - r)); /* scale */\n#else\n  dtbl[DCTSIZE2 * 2] = 1;\n#endif\n  dtbl[DCTSIZE2 * 3] = (DCTELEM)r - sizeof(DCTELEM) * 8; /* shift */\n\n  if (r <= 16) return 0;\n  else return 1;\n}\n\n#endif\n\n\n/*\n * Initialize for a processing pass.\n * Verify that all referenced Q-tables are present, and set up\n * the divisor table for each one.\n * In the current implementation, DCT of all components is done during\n * the first pass, even if only some components will be output in the\n * first scan.  Hence all components should be examined here.\n */\n\nMETHODDEF(void)\nstart_pass_fdctmgr(j_compress_ptr cinfo)\n{\n  my_fdct_ptr fdct = (my_fdct_ptr)cinfo->fdct;\n  int ci, qtblno, i;\n  jpeg_component_info *compptr;\n  JQUANT_TBL *qtbl;\n  DCTELEM *dtbl;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    qtblno = compptr->quant_tbl_no;\n    /* Make sure specified quantization table is present */\n    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||\n        cinfo->quant_tbl_ptrs[qtblno] == NULL)\n      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);\n    qtbl = cinfo->quant_tbl_ptrs[qtblno];\n    /* Compute divisors for this quant table */\n    /* We may do this more than once for same table, but it's not a big deal */\n    switch (cinfo->dct_method) {\n#ifdef DCT_ISLOW_SUPPORTED\n    case JDCT_ISLOW:\n      /* For LL&M IDCT method, divisors are equal to raw quantization\n       * coefficients multiplied by 8 (to counteract scaling).\n       */\n      if (fdct->divisors[qtblno] == NULL) {\n        fdct->divisors[qtblno] = (DCTELEM *)\n          (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                      (DCTSIZE2 * 4) * sizeof(DCTELEM));\n      }\n      dtbl = fdct->divisors[qtblno];\n      for (i = 0; i < DCTSIZE2; i++) {\n#if BITS_IN_JSAMPLE == 8\n#ifdef WITH_SIMD\n        if (!compute_reciprocal(qtbl->quantval[i] << 3, &dtbl[i]) &&\n            fdct->quantize == jsimd_quantize)\n          fdct->quantize = quantize;\n#else\n        compute_reciprocal(qtbl->quantval[i] << 3, &dtbl[i]);\n#endif\n#else\n        dtbl[i] = ((DCTELEM)qtbl->quantval[i]) << 3;\n#endif\n      }\n      break;\n#endif\n#ifdef DCT_IFAST_SUPPORTED\n    case JDCT_IFAST:\n      {\n        /* For AA&N IDCT method, divisors are equal to quantization\n         * coefficients scaled by scalefactor[row]*scalefactor[col], where\n         *   scalefactor[0] = 1\n         *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7\n         * We apply a further scale factor of 8.\n         */\n#define CONST_BITS  14\n        static const INT16 aanscales[DCTSIZE2] = {\n          /* precomputed values scaled up by 14 bits */\n          16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,\n          22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,\n          21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,\n          19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,\n          16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,\n          12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,\n           8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,\n           4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247\n        };\n        SHIFT_TEMPS\n\n        if (fdct->divisors[qtblno] == NULL) {\n          fdct->divisors[qtblno] = (DCTELEM *)\n            (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                        (DCTSIZE2 * 4) * sizeof(DCTELEM));\n        }\n        dtbl = fdct->divisors[qtblno];\n        for (i = 0; i < DCTSIZE2; i++) {\n#if BITS_IN_JSAMPLE == 8\n#ifdef WITH_SIMD\n          if (!compute_reciprocal(\n                DESCALE(MULTIPLY16V16((JLONG)qtbl->quantval[i],\n                                      (JLONG)aanscales[i]),\n                        CONST_BITS - 3), &dtbl[i]) &&\n              fdct->quantize == jsimd_quantize)\n            fdct->quantize = quantize;\n#else\n          compute_reciprocal(\n            DESCALE(MULTIPLY16V16((JLONG)qtbl->quantval[i],\n                                  (JLONG)aanscales[i]),\n                    CONST_BITS-3), &dtbl[i]);\n#endif\n#else\n          dtbl[i] = (DCTELEM)\n            DESCALE(MULTIPLY16V16((JLONG)qtbl->quantval[i],\n                                  (JLONG)aanscales[i]),\n                    CONST_BITS - 3);\n#endif\n        }\n      }\n      break;\n#endif\n#ifdef DCT_FLOAT_SUPPORTED\n    case JDCT_FLOAT:\n      {\n        /* For float AA&N IDCT method, divisors are equal to quantization\n         * coefficients scaled by scalefactor[row]*scalefactor[col], where\n         *   scalefactor[0] = 1\n         *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7\n         * We apply a further scale factor of 8.\n         * What's actually stored is 1/divisor so that the inner loop can\n         * use a multiplication rather than a division.\n         */\n        FAST_FLOAT *fdtbl;\n        int row, col;\n        static const double aanscalefactor[DCTSIZE] = {\n          1.0, 1.387039845, 1.306562965, 1.175875602,\n          1.0, 0.785694958, 0.541196100, 0.275899379\n        };\n\n        if (fdct->float_divisors[qtblno] == NULL) {\n          fdct->float_divisors[qtblno] = (FAST_FLOAT *)\n            (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                        DCTSIZE2 * sizeof(FAST_FLOAT));\n        }\n        fdtbl = fdct->float_divisors[qtblno];\n        i = 0;\n        for (row = 0; row < DCTSIZE; row++) {\n          for (col = 0; col < DCTSIZE; col++) {\n            fdtbl[i] = (FAST_FLOAT)\n              (1.0 / (((double)qtbl->quantval[i] *\n                       aanscalefactor[row] * aanscalefactor[col] * 8.0)));\n            i++;\n          }\n        }\n      }\n      break;\n#endif\n    default:\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n      break;\n    }\n  }\n}\n\nMETHODDEF(float)\ncatmull_rom(const DCTELEM value1, const DCTELEM value2, const DCTELEM value3, const DCTELEM value4, const float t, int size)\n{\n  const int tan1 = (value3 - value1) * size;\n  const int tan2 = (value4 - value2) * size;\n\n  const float t2 = t * t;\n  const float t3 = t2 * t;\n\n  const float f1 = 2.f * t3 - 3.f * t2 + 1.f;\n  const float f2 = -2.f * t3 + 3.f * t2;\n  const float f3 = t3 - 2.f * t2 + t;\n  const float f4 = t3 - t2;\n\n  return value2 * f1 + tan1 * f3 +\n         value3 * f2 + tan2 * f4;\n}\n\n/** Prevents visible ringing artifacts near hard edges on white backgrounds.\n\n  1. JPEG can encode samples with higher values than it's possible to display (higher than 255 in RGB),\n     and the decoder will always clamp values to 0-255. To encode 255 you can use any value >= 255,\n     and distortions of the out-of-range values won't be visible as long as they decode to anything >= 255.\n\n  2. From DCT perspective pixels in a block are a waveform. Hard edges form square waves (bad).\n     Edges with white are similar to waveform clipping, and anti-clipping algorithms can turn square waves\n     into softer ones that compress better.\n\n */\nMETHODDEF(void)\npreprocess_deringing(DCTELEM *data, const JQUANT_TBL *quantization_table)\n{\n  const DCTELEM maxsample = 255 - CENTERJSAMPLE;\n  const int size = DCTSIZE * DCTSIZE;\n\n  /* Decoders don't handle overflow of DC very well, so calculate\n     maximum overflow that is safe to do without increasing DC out of range */\n  int sum = 0;\n  int maxsample_count = 0;\n  int i;\n  DCTELEM maxovershoot;\n  int n;\n  \n  for(i=0; i < size; i++) {\n    sum += data[i];\n    if (data[i] >= maxsample) {\n      maxsample_count++;\n    }\n  }\n\n  /* If nothing reaches max value there's nothing to overshoot\n     and if the block is completely flat, it's already the best case. */\n  if (!maxsample_count || maxsample_count == size) {\n    return;\n  }\n\n  /* Too much overshoot is not good: increased amplitude will cost bits, and the cost is proportional to quantization (here using DC quant as a rough guide). */\n  maxovershoot = maxsample + MIN(MIN(31, 2*quantization_table->quantval[0]), (maxsample * size - sum) / maxsample_count);\n\n  n = 0;\n  do {\n    int start, end, length;\n    DCTELEM f1, f2, l1, l2, fslope, lslope;\n    float step, position;\n    \n    /* Pixels are traversed in zig-zag order to process them as a line */\n    if (data[jpeg_natural_order[n]] < maxsample) {\n      n++;\n      continue;\n    }\n\n    /* Find a run of maxsample pixels. Start is the first pixel inside the range, end the first pixel outside. */\n    start = n;\n    while(++n < size && data[jpeg_natural_order[n]] >= maxsample) {}\n    end = n;\n\n    /* the run will be replaced with a catmull-rom interpolation of values from the edges */\n\n    /* Find suitable upward slope from pixels around edges of the run.\n       Just feeding nearby pixels as catmull rom points isn't good enough,\n       as slope with one sample before the edge may have been flattened by clipping,\n       and slope of two samples before the edge could be downward. */\n    f1 = data[jpeg_natural_order[start >= 1 ? start-1 : 0]];\n    f2 = data[jpeg_natural_order[start >= 2 ? start-2 : 0]];\n\n    l1 = data[jpeg_natural_order[end < size-1 ? end : size-1]];\n    l2 = data[jpeg_natural_order[end < size-2 ? end+1 : size-1]];\n\n    fslope = MAX(f1-f2, maxsample-f1);\n    lslope = MAX(l1-l2, maxsample-l1);\n\n    /* if slope at the start/end is unknown, just make the curve symmetric */\n    if (start == 0) {\n      fslope = lslope;\n    }\n    if (end == size) {\n      lslope = fslope;\n    }\n\n    /* The curve fits better if first and last pixel is omitted */\n    length = end - start;\n    step = 1.f/(float)(length + 1);\n    position = step;\n\n    for(i = start; i < end; i++, position += step) {\n      DCTELEM tmp = ceilf(catmull_rom(maxsample - fslope, maxsample, maxsample, maxsample - lslope, position, length));\n      data[jpeg_natural_order[i]] = MIN(tmp, maxovershoot);\n    }\n    n++;\n  }\n  while(n < size);\n}\n\n/*\n  Float version of preprocess_deringing()\n */\nMETHODDEF(void)\nfloat_preprocess_deringing(FAST_FLOAT *data, const JQUANT_TBL *quantization_table)\n{\n  const FAST_FLOAT maxsample = 255 - CENTERJSAMPLE;\n  const int size = DCTSIZE * DCTSIZE;\n\n  FAST_FLOAT sum = 0;\n  int maxsample_count = 0;\n  int i;\n  int n;\n  FAST_FLOAT maxovershoot;\n  \n  for(i=0; i < size; i++) {\n    sum += data[i];\n    if (data[i] >= maxsample) {\n      maxsample_count++;\n    }\n  }\n\n  if (!maxsample_count || maxsample_count == size) {\n    return;\n  }\n\n  maxovershoot = maxsample + MIN(MIN(31, 2*quantization_table->quantval[0]), (maxsample * size - sum) / maxsample_count);\n\n  n = 0;\n  do {\n    int start, end, length;\n    FAST_FLOAT f1, f2, l1, l2, fslope, lslope;\n    float step, position;\n    \n    if (data[jpeg_natural_order[n]] < maxsample) {\n      n++;\n      continue;\n    }\n\n    start = n;\n    while(++n < size && data[jpeg_natural_order[n]] >= maxsample) {}\n    end = n;\n\n    f1 = data[jpeg_natural_order[start >= 1 ? start-1 : 0]];\n    f2 = data[jpeg_natural_order[start >= 2 ? start-2 : 0]];\n\n    l1 = data[jpeg_natural_order[end < size-1 ? end : size-1]];\n    l2 = data[jpeg_natural_order[end < size-2 ? end+1 : size-1]];\n\n    fslope = MAX(f1-f2, maxsample-f1);\n    lslope = MAX(l1-l2, maxsample-l1);\n\n    if (start == 0) {\n      fslope = lslope;\n    }\n    if (end == size) {\n      lslope = fslope;\n    }\n\n    length = end - start;\n    step = 1.f/(float)(length + 1);\n    position = step;\n\n    for(i = start; i < end; i++, position += step) {\n      FAST_FLOAT tmp = catmull_rom(maxsample - fslope, maxsample, maxsample, maxsample - lslope, position, length);\n      data[jpeg_natural_order[i]] = MIN(tmp, maxovershoot);\n    }\n    n++;\n  }\n  while(n < size);\n}\n\n/*\n * Load data into workspace, applying unsigned->signed conversion.\n */\n\nMETHODDEF(void)\nconvsamp(_JSAMPARRAY sample_data, JDIMENSION start_col, DCTELEM *workspace)\n{\n  register DCTELEM *workspaceptr;\n  register _JSAMPROW elemptr;\n  register int elemr;\n\n  workspaceptr = workspace;\n  for (elemr = 0; elemr < DCTSIZE; elemr++) {\n    elemptr = sample_data[elemr] + start_col;\n\n#if DCTSIZE == 8                /* unroll the inner loop */\n    *workspaceptr++ = (*elemptr++) - _CENTERJSAMPLE;\n    *workspaceptr++ = (*elemptr++) - _CENTERJSAMPLE;\n    *workspaceptr++ = (*elemptr++) - _CENTERJSAMPLE;\n    *workspaceptr++ = (*elemptr++) - _CENTERJSAMPLE;\n    *workspaceptr++ = (*elemptr++) - _CENTERJSAMPLE;\n    *workspaceptr++ = (*elemptr++) - _CENTERJSAMPLE;\n    *workspaceptr++ = (*elemptr++) - _CENTERJSAMPLE;\n    *workspaceptr++ = (*elemptr++) - _CENTERJSAMPLE;\n#else\n    {\n      register int elemc;\n      for (elemc = DCTSIZE; elemc > 0; elemc--)\n        *workspaceptr++ = (*elemptr++) - _CENTERJSAMPLE;\n    }\n#endif\n  }\n}\n\n\n/*\n * Quantize/descale the coefficients, and store into coef_blocks[].\n */\n\nMETHODDEF(void)\nquantize(JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace)\n{\n  int i;\n  DCTELEM temp;\n  JCOEFPTR output_ptr = coef_block;\n\n#if BITS_IN_JSAMPLE == 8\n\n  UDCTELEM recip, corr;\n  int shift;\n  UDCTELEM2 product;\n\n  for (i = 0; i < DCTSIZE2; i++) {\n    temp = workspace[i];\n    recip = divisors[i + DCTSIZE2 * 0];\n    corr =  divisors[i + DCTSIZE2 * 1];\n    shift = divisors[i + DCTSIZE2 * 3];\n\n    if (temp < 0) {\n      temp = -temp;\n      product = (UDCTELEM2)(temp + corr) * recip;\n      product >>= shift + sizeof(DCTELEM) * 8;\n      temp = (DCTELEM)product;\n      temp = -temp;\n    } else {\n      product = (UDCTELEM2)(temp + corr) * recip;\n      product >>= shift + sizeof(DCTELEM) * 8;\n      temp = (DCTELEM)product;\n    }\n    output_ptr[i] = (JCOEF)temp;\n  }\n\n#else\n\n  register DCTELEM qval;\n\n  for (i = 0; i < DCTSIZE2; i++) {\n    qval = divisors[i];\n    temp = workspace[i];\n    /* Divide the coefficient value by qval, ensuring proper rounding.\n     * Since C does not specify the direction of rounding for negative\n     * quotients, we have to force the dividend positive for portability.\n     *\n     * In most files, at least half of the output values will be zero\n     * (at default quantization settings, more like three-quarters...)\n     * so we should ensure that this case is fast.  On many machines,\n     * a comparison is enough cheaper than a divide to make a special test\n     * a win.  Since both inputs will be nonnegative, we need only test\n     * for a < b to discover whether a/b is 0.\n     * If your machine's division is fast enough, define FAST_DIVIDE.\n     */\n#ifdef FAST_DIVIDE\n#define DIVIDE_BY(a, b)  a /= b\n#else\n#define DIVIDE_BY(a, b)  if (a >= b) a /= b;  else a = 0\n#endif\n    if (temp < 0) {\n      temp = -temp;\n      temp += qval >> 1;        /* for rounding */\n      DIVIDE_BY(temp, qval);\n      temp = -temp;\n    } else {\n      temp += qval >> 1;        /* for rounding */\n      DIVIDE_BY(temp, qval);\n    }\n    output_ptr[i] = (JCOEF)temp;\n  }\n\n#endif\n\n}\n\n\n/*\n * Perform forward DCT on one or more blocks of a component.\n *\n * The input samples are taken from the sample_data[] array starting at\n * position start_row/start_col, and moving to the right for any additional\n * blocks. The quantized coefficients are returned in coef_blocks[].\n */\n\nMETHODDEF(void)\nforward_DCT(j_compress_ptr cinfo, jpeg_component_info *compptr,\n            _JSAMPARRAY sample_data, JBLOCKROW coef_blocks,\n            JDIMENSION start_row, JDIMENSION start_col, JDIMENSION num_blocks,\n            JBLOCKROW dst)\n/* This version is used for integer DCT implementations. */\n{\n  /* This routine is heavily used, so it's worth coding it tightly. */\n  my_fdct_ptr fdct = (my_fdct_ptr)cinfo->fdct;\n  DCTELEM *divisors = fdct->divisors[compptr->quant_tbl_no];\n  JQUANT_TBL *qtbl = cinfo->quant_tbl_ptrs[compptr->quant_tbl_no];\n  DCTELEM *workspace;\n  JDIMENSION bi;\n  const int max_coef_bits = cinfo->data_precision + 2;\n\n  /* Make sure the compiler doesn't look up these every pass */\n  forward_DCT_method_ptr do_dct = fdct->dct;\n  convsamp_method_ptr do_convsamp = fdct->convsamp;\n  preprocess_method_ptr do_preprocess = fdct->preprocess;\n  quantize_method_ptr do_quantize = fdct->quantize;\n  workspace = fdct->workspace;\n\n  sample_data += start_row;     /* fold in the vertical offset once */\n\n  for (bi = 0; bi < num_blocks; bi++, start_col += DCTSIZE) {\n    /* Load data into workspace, applying unsigned->signed conversion */\n    (*do_convsamp) (sample_data, start_col, workspace);\n\n    if (do_preprocess) {\n      (*do_preprocess) (workspace, qtbl);\n    }\n\n    /* Perform the DCT */\n    (*do_dct) (workspace);\n\n    /* Save unquantized transform coefficients for later trellis quantization */\n    if (dst) {\n      int i;\n      if (cinfo->dct_method == JDCT_IFAST) {\n        static const INT16 aanscales[DCTSIZE2] = {\n          /* precomputed values scaled up by 14 bits */\n          16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,\n          22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,\n          21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,\n          19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,\n          16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,\n          12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,\n          8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,\n          4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247\n        };\n        \n        for (i = 0; i < DCTSIZE2; i++) {\n          int x = workspace[i];\n          int s = aanscales[i];\n          x = (x >= 0) ? (x * 32768 + s) / (2*s) : (x * 32768 - s) / (2*s);\n          dst[bi][i] = x;\n        }\n        \n      } else {\n        for (i = 0; i < DCTSIZE2; i++) {\n          dst[bi][i] = workspace[i];\n        }\n      }\n    }\n    \n    /* Quantize/descale the coefficients, and store into coef_blocks[] */\n    (*do_quantize) (coef_blocks[bi], divisors, workspace);\n\n    if (do_preprocess) {\n      int i;\n      int maxval = (1 << max_coef_bits) - 1;\n      for (i = 0; i < 64; i++) {\n        if (coef_blocks[bi][i] < -maxval)\n          coef_blocks[bi][i] = -maxval;\n        if (coef_blocks[bi][i] > maxval)\n          coef_blocks[bi][i] = maxval;\n  }\n  }\n  }\n}\n\n\n#ifdef DCT_FLOAT_SUPPORTED\n\nMETHODDEF(void)\nconvsamp_float(_JSAMPARRAY sample_data, JDIMENSION start_col,\n               FAST_FLOAT *workspace)\n{\n  register FAST_FLOAT *workspaceptr;\n  register _JSAMPROW elemptr;\n  register int elemr;\n\n  workspaceptr = workspace;\n  for (elemr = 0; elemr < DCTSIZE; elemr++) {\n    elemptr = sample_data[elemr] + start_col;\n#if DCTSIZE == 8                /* unroll the inner loop */\n    *workspaceptr++ = (FAST_FLOAT)((*elemptr++) - _CENTERJSAMPLE);\n    *workspaceptr++ = (FAST_FLOAT)((*elemptr++) - _CENTERJSAMPLE);\n    *workspaceptr++ = (FAST_FLOAT)((*elemptr++) - _CENTERJSAMPLE);\n    *workspaceptr++ = (FAST_FLOAT)((*elemptr++) - _CENTERJSAMPLE);\n    *workspaceptr++ = (FAST_FLOAT)((*elemptr++) - _CENTERJSAMPLE);\n    *workspaceptr++ = (FAST_FLOAT)((*elemptr++) - _CENTERJSAMPLE);\n    *workspaceptr++ = (FAST_FLOAT)((*elemptr++) - _CENTERJSAMPLE);\n    *workspaceptr++ = (FAST_FLOAT)((*elemptr++) - _CENTERJSAMPLE);\n#else\n    {\n      register int elemc;\n      for (elemc = DCTSIZE; elemc > 0; elemc--)\n        *workspaceptr++ = (FAST_FLOAT)((*elemptr++) - _CENTERJSAMPLE);\n    }\n#endif\n  }\n}\n\n\nMETHODDEF(void)\nquantize_float(JCOEFPTR coef_block, FAST_FLOAT *divisors,\n               FAST_FLOAT *workspace)\n{\n  register FAST_FLOAT temp;\n  register int i;\n  register JCOEFPTR output_ptr = coef_block;\n\n  for (i = 0; i < DCTSIZE2; i++) {\n    /* Apply the quantization and scaling factor */\n    temp = workspace[i] * divisors[i];\n\n    /* Round to nearest integer.\n     * Since C does not specify the direction of rounding for negative\n     * quotients, we have to force the dividend positive for portability.\n     * The maximum coefficient size is +-16K (for 12-bit data), so this\n     * code should work for either 16-bit or 32-bit ints.\n     */\n    output_ptr[i] = (JCOEF)((int)(temp + (FAST_FLOAT)16384.5) - 16384);\n  }\n}\n\n\nMETHODDEF(void)\nforward_DCT_float(j_compress_ptr cinfo, jpeg_component_info *compptr,\n                  _JSAMPARRAY sample_data, JBLOCKROW coef_blocks,\n                  JDIMENSION start_row, JDIMENSION start_col,\n                  JDIMENSION num_blocks, JBLOCKROW dst)\n/* This version is used for floating-point DCT implementations. */\n{\n  /* This routine is heavily used, so it's worth coding it tightly. */\n  my_fdct_ptr fdct = (my_fdct_ptr)cinfo->fdct;\n  FAST_FLOAT *divisors = fdct->float_divisors[compptr->quant_tbl_no];\n  JQUANT_TBL *qtbl = cinfo->quant_tbl_ptrs[compptr->quant_tbl_no];\n  FAST_FLOAT *workspace;\n  JDIMENSION bi;\n  float v;\n  int x;\n  const int max_coef_bits = cinfo->data_precision + 2;\n\n  /* Make sure the compiler doesn't look up these every pass */\n  float_DCT_method_ptr do_dct = fdct->float_dct;\n  float_convsamp_method_ptr do_convsamp = fdct->float_convsamp;\n  float_preprocess_method_ptr do_preprocess = fdct->float_preprocess;\n  float_quantize_method_ptr do_quantize = fdct->float_quantize;\n  workspace = fdct->float_workspace;\n\n  sample_data += start_row;     /* fold in the vertical offset once */\n\n  for (bi = 0; bi < num_blocks; bi++, start_col += DCTSIZE) {\n    /* Load data into workspace, applying unsigned->signed conversion */\n    (*do_convsamp) (sample_data, start_col, workspace);\n\n    if (do_preprocess) {\n      (*do_preprocess) (workspace, qtbl);\n    }\n\n    /* Perform the DCT */\n    (*do_dct) (workspace);\n\n    /* Save unquantized transform coefficients for later trellis quantization */\n    /* Currently save as integer values. Could save float values but would require */\n    /* modifications to memory allocation and trellis quantization */\n\n    if (dst) {\n      int i;\n      static const double aanscalefactor[DCTSIZE] = {\n        1.0, 1.387039845, 1.306562965, 1.175875602,\n        1.0, 0.785694958, 0.541196100, 0.275899379\n      };\n\n      for (i = 0; i < DCTSIZE2; i++) {\n        v = workspace[i];\n        v /= aanscalefactor[i%8];\n        v /= aanscalefactor[i/8];\n        x = (v >= 0.0) ? (int)(v + 0.5) : (int)(v - 0.5);\n        dst[bi][i] = x;\n      }\n    }\n\n    /* Quantize/descale the coefficients, and store into coef_blocks[] */\n    (*do_quantize) (coef_blocks[bi], divisors, workspace);\n    \n    if (do_preprocess) {\n      int i;\n      int maxval = (1 << max_coef_bits) - 1;\n      for (i = 0; i < 64; i++) {\n        if (coef_blocks[bi][i] < -maxval)\n          coef_blocks[bi][i] = -maxval;\n        if (coef_blocks[bi][i] > maxval)\n          coef_blocks[bi][i] = maxval;\n  }\n}\n  }\n}\n\n#endif /* DCT_FLOAT_SUPPORTED */\n\nstatic const float jpeg_lambda_weights_flat[64] = {\n  1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,\n  1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,\n  1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,\n  1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,\n  1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,\n  1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,\n  1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,\n  1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f\n};\n\nstatic const float jpeg_lambda_weights_csf_luma[64] = {\n  3.35630f, 3.59892f, 3.20921f, 2.28102f, 1.42378f, 0.88079f, 0.58190f, 0.43454f,\n  3.59893f, 3.21284f, 2.71282f, 1.98092f, 1.30506f, 0.83852f, 0.56346f, 0.42146f,\n  3.20921f, 2.71282f, 2.12574f, 1.48616f, 0.99660f, 0.66132f, 0.45610f, 0.34609f,\n  2.28102f, 1.98092f, 1.48616f, 0.97492f, 0.64622f, 0.43812f, 0.31074f, 0.24072f,\n  1.42378f, 1.30506f, 0.99660f, 0.64623f, 0.42051f, 0.28446f, 0.20380f, 0.15975f,\n  0.88079f, 0.83852f, 0.66132f, 0.43812f, 0.28446f, 0.19092f, 0.13635f, 0.10701f,\n  0.58190f, 0.56346f, 0.45610f, 0.31074f, 0.20380f, 0.13635f, 0.09674f, 0.07558f,\n  0.43454f, 0.42146f, 0.34609f, 0.24072f, 0.15975f, 0.10701f, 0.07558f, 0.05875f,\n};\n\n#define DC_TRELLIS_MAX_CANDIDATES 9\n\nLOCAL(int) get_num_dc_trellis_candidates(int dc_quantval) {\n  /* Higher qualities can tolerate higher DC distortion */\n  return MIN(DC_TRELLIS_MAX_CANDIDATES, (2 + 60 / dc_quantval)|1);\n}\n\n#if BITS_IN_JSAMPLE == 8\nGLOBAL(void)\nquantize_trellis(j_compress_ptr cinfo, c_derived_tbl *dctbl, c_derived_tbl *actbl, JBLOCKROW coef_blocks, JBLOCKROW src, JDIMENSION num_blocks,\n                 JQUANT_TBL * qtbl, double *norm_src, double *norm_coef, JCOEF *last_dc_val,\n                 JBLOCKROW coef_blocks_above, JBLOCKROW src_above)\n{\n  int i, j, k, l;\n  float accumulated_zero_dist[DCTSIZE2];\n  float accumulated_cost[DCTSIZE2];\n  int run_start[DCTSIZE2];\n  int bi;\n  float best_cost;\n  int last_coeff_idx; /* position of last nonzero coefficient */\n  const int max_coef_bits = cinfo->data_precision + 2;\n  float norm = 0.0;\n  float lambda_base;\n  float lambda;\n  float lambda_dc;\n  const float *lambda_tbl = (cinfo->master->use_lambda_weight_tbl) ?\n                            jpeg_lambda_weights_csf_luma :\n                            jpeg_lambda_weights_flat;\n  int Ss, Se;\n  float *accumulated_zero_block_cost = NULL;\n  float *accumulated_block_cost = NULL;\n  int *block_run_start = NULL;\n  int *requires_eob = NULL;\n  int has_eob;\n  float cost_all_zeros;\n  float best_cost_skip;\n  float cost;\n  int zero_run;\n  int run_bits;\n  int rate;\n  float *accumulated_dc_cost[DC_TRELLIS_MAX_CANDIDATES];\n  int *dc_cost_backtrack[DC_TRELLIS_MAX_CANDIDATES];\n  JCOEF *dc_candidate[DC_TRELLIS_MAX_CANDIDATES];\n  int mode = 1;\n  float lambda_table[DCTSIZE2];\n  const int dc_trellis_candidates = get_num_dc_trellis_candidates(qtbl->quantval[0]);\n  \n  Ss = cinfo->Ss;\n  Se = cinfo->Se;\n  if (Ss == 0)\n    Ss = 1;\n  if (Se < Ss)\n    return;\n  if (cinfo->master->trellis_eob_opt) {\n    accumulated_zero_block_cost = (float *)malloc((num_blocks + 1) * sizeof(float));\n    accumulated_block_cost = (float *)malloc((num_blocks + 1) * sizeof(float));\n    block_run_start = (int *)malloc(num_blocks * sizeof(int));\n    requires_eob = (int *)malloc((num_blocks + 1) * sizeof(int));\n    if (!accumulated_zero_block_cost ||\n        !accumulated_block_cost ||\n        !block_run_start ||\n        !requires_eob) {\n      ERREXIT(cinfo, JERR_OUT_OF_MEMORY);\n    }\n\n    accumulated_zero_block_cost[0] = 0;\n    accumulated_block_cost[0] = 0;\n    requires_eob[0] = 0;\n  }\n  \n  if (cinfo->master->trellis_quant_dc) {\n    for (i = 0; i < dc_trellis_candidates; i++) {\n      accumulated_dc_cost[i] = (float *)malloc(num_blocks * sizeof(float));\n      dc_cost_backtrack[i] = (int *)malloc(num_blocks * sizeof(int));\n      dc_candidate[i] = (JCOEF *)malloc(num_blocks * sizeof(JCOEF));\n      if (!accumulated_dc_cost[i] ||\n          !dc_cost_backtrack[i] ||\n          !dc_candidate[i]) {\n        ERREXIT(cinfo, JERR_OUT_OF_MEMORY);\n      }\n    }\n  }\n  \n  norm = 0.0;\n  for (i = 1; i < DCTSIZE2; i++) {\n    norm += qtbl->quantval[i] * qtbl->quantval[i];\n  }\n  norm /= 63.0;\n\n  if (mode == 1) {\n    lambda_base = 1.0;\n    lambda_tbl = lambda_table;\n    for (i = 0; i < DCTSIZE2; i++)\n      lambda_table[i] = 1.0 / (qtbl->quantval[i] * qtbl->quantval[i]);\n  } else\n    lambda_base = 1.0 / norm;\n  \n  for (bi = 0; bi < num_blocks; bi++) {\n    \n    norm = 0.0;\n    for (i = 1; i < DCTSIZE2; i++) {\n      norm += src[bi][i] * src[bi][i];\n    }\n    norm /= 63.0;\n    \n    if (cinfo->master->lambda_log_scale2 > 0.0)\n      lambda = pow(2.0, cinfo->master->lambda_log_scale1) * lambda_base /\n                   (pow(2.0, cinfo->master->lambda_log_scale2) + norm);\n    else\n      lambda = pow(2.0, cinfo->master->lambda_log_scale1 - 12.0) * lambda_base;\n    \n    lambda_dc = lambda * lambda_tbl[0];\n    \n    accumulated_zero_dist[Ss-1] = 0.0;\n    accumulated_cost[Ss-1] = 0.0;\n\n    /* Do DC coefficient */\n    if (cinfo->master->trellis_quant_dc) {\n      int sign = src[bi][0] >> 31;\n      int x = abs(src[bi][0]);\n      int q = 8 * qtbl->quantval[0];\n      int qval;\n      float dc_candidate_dist;\n\n      qval = (x + q/2) / q; /* quantized value (round nearest) */\n      for (k = 0; k < dc_trellis_candidates; k++) {\n        int delta;\n        int dc_delta;\n        int bits;\n\n        dc_candidate[k][bi] = qval - dc_trellis_candidates/2 + k;\n        if (dc_candidate[k][bi] >= (1<<max_coef_bits))\n          dc_candidate[k][bi] = (1<<max_coef_bits)-1;\n        if (dc_candidate[k][bi] <= -(1<<max_coef_bits))\n          dc_candidate[k][bi] = -(1<<max_coef_bits)+1;\n\n        delta = dc_candidate[k][bi] * q - x;\n        dc_candidate_dist = delta * delta * lambda_dc;\n        dc_candidate[k][bi] *= 1 + 2*sign;\n        \n        /* Take into account DC differences */\n        if (coef_blocks_above && src_above && cinfo->master->trellis_delta_dc_weight > 0.0) {\n          int dc_above_orig;\n          int dc_above_recon;\n          int dc_orig;\n          int dc_recon;\n          float vertical_dist;\n          \n          dc_above_orig = src_above[bi][0];\n          dc_above_recon = coef_blocks_above[bi][0] * q;\n          dc_orig = src[bi][0];\n          dc_recon = dc_candidate[k][bi] * q;\n          /* delta is difference of vertical gradients */\n          delta = (dc_above_orig - dc_orig) - (dc_above_recon - dc_recon);\n          vertical_dist = delta * delta * lambda_dc;\n          dc_candidate_dist +=  cinfo->master->trellis_delta_dc_weight * (vertical_dist - dc_candidate_dist);\n        }\n        \n        if (bi == 0) {\n          dc_delta = dc_candidate[k][bi] - *last_dc_val;\n\n          /* Derive number of suffix bits */\n          bits = 0;\n          dc_delta = abs(dc_delta);\n          while (dc_delta) {\n            dc_delta >>= 1;\n            bits++;\n          }\n          cost = bits + dctbl->ehufsi[bits] + dc_candidate_dist;\n          accumulated_dc_cost[k][0] = cost;\n          dc_cost_backtrack[k][0] = -1;\n        } else {\n          for (l = 0; l < dc_trellis_candidates; l++) {\n            dc_delta = dc_candidate[k][bi] - dc_candidate[l][bi-1];\n\n            /* Derive number of suffix bits */\n            bits = 0;\n            dc_delta = abs(dc_delta);\n            while (dc_delta) {\n              dc_delta >>= 1;\n              bits++;\n            }\n            cost = bits + dctbl->ehufsi[bits] + dc_candidate_dist + accumulated_dc_cost[l][bi-1];\n            if (l == 0 || cost < accumulated_dc_cost[k][bi]) {\n              accumulated_dc_cost[k][bi] = cost;\n              dc_cost_backtrack[k][bi] = l;\n            }\n          }\n        }\n      }\n    }\n\n    /* Do AC coefficients */\n    for (i = Ss; i <= Se; i++) {\n      int z = jpeg_natural_order[i];\n\n      int sign = src[bi][z] >> 31;\n      int x = abs(src[bi][z]);\n      int q = 8 * qtbl->quantval[z];\n      int candidate[16];\n      int candidate_bits[16];\n      float candidate_dist[16];\n      int num_candidates;\n      int qval;\n      \n      accumulated_zero_dist[i] = x * x * lambda * lambda_tbl[z] + accumulated_zero_dist[i-1];\n      \n      qval = (x + q/2) / q; /* quantized value (round nearest) */\n\n      if (qval == 0) {\n        coef_blocks[bi][z] = 0;\n        accumulated_cost[i] = 1e38; /* Shouldn't be needed */\n        continue;\n      }\n\n      if (qval >= (1<<max_coef_bits))\n        qval = (1<<max_coef_bits)-1;\n      \n      num_candidates = JPEG_NBITS(qval);\n      for (k = 0; k < num_candidates; k++) {\n        int delta;\n        candidate[k] = (k < num_candidates - 1) ? (2 << k) - 1 : qval;\n        delta = candidate[k] * q - x;\n        candidate_bits[k] = k+1;\n        candidate_dist[k] = delta * delta * lambda * lambda_tbl[z];\n      }\n      \n      accumulated_cost[i] = 1e38;\n      \n      for (j = Ss-1; j < i; j++) {\n        int zz = jpeg_natural_order[j];\n        if (j != Ss-1 && coef_blocks[bi][zz] == 0)\n          continue;\n        \n        zero_run = i - 1 - j;\n        if ((zero_run >> 4) && actbl->ehufsi[0xf0] == 0)\n          continue;\n        \n        run_bits = (zero_run >> 4) * actbl->ehufsi[0xf0];\n        zero_run &= 15;\n\n        for (k = 0; k < num_candidates; k++) {\n          int coef_bits = actbl->ehufsi[16 * zero_run + candidate_bits[k]];\n          if (coef_bits == 0)\n            continue;\n          \n          rate = coef_bits + candidate_bits[k] + run_bits;\n          cost = rate + candidate_dist[k];\n          cost += accumulated_zero_dist[i-1] - accumulated_zero_dist[j] + accumulated_cost[j];\n          \n          if (cost < accumulated_cost[i]) {\n            coef_blocks[bi][z] = (candidate[k] ^ sign) - sign;\n            accumulated_cost[i] = cost;\n            run_start[i] = j;\n          }\n        }\n      }\n    }\n    \n    last_coeff_idx = Ss-1;\n    best_cost = accumulated_zero_dist[Se] + actbl->ehufsi[0];\n    cost_all_zeros = accumulated_zero_dist[Se];\n    best_cost_skip = cost_all_zeros;\n    \n    for (i = Ss; i <= Se; i++) {\n      int z = jpeg_natural_order[i];\n      if (coef_blocks[bi][z] != 0) {\n        float cost = accumulated_cost[i] + accumulated_zero_dist[Se] - accumulated_zero_dist[i];\n        float cost_wo_eob = cost;\n        \n        if (i < Se)\n          cost += actbl->ehufsi[0];\n        \n        if (cost < best_cost) {\n          best_cost = cost;\n          last_coeff_idx = i;\n          best_cost_skip = cost_wo_eob;\n        }\n      }\n    }\n    \n    has_eob = (last_coeff_idx < Se) + (last_coeff_idx == Ss-1);\n    \n    /* Zero out coefficients that are part of runs */\n    i = Se;\n    while (i >= Ss)\n    {\n      while (i > last_coeff_idx) {\n        int z = jpeg_natural_order[i];\n        coef_blocks[bi][z] = 0;\n        i--;\n      }\n      last_coeff_idx = run_start[i];\n      i--;\n    }\n    \n    if (cinfo->master->trellis_eob_opt) {\n      accumulated_zero_block_cost[bi+1] = accumulated_zero_block_cost[bi];\n      accumulated_zero_block_cost[bi+1] += cost_all_zeros;\n      requires_eob[bi+1] = has_eob;\n      \n      best_cost = 1e38;\n      \n      if (has_eob != 2) {\n        for (i = 0; i <= bi; i++) {\n          int zero_block_run;\n          int nbits;\n          float cost;\n          \n          if (requires_eob[i] == 2)\n            continue;\n          \n          cost = best_cost_skip; /* cost of coding a nonzero block */\n          cost += accumulated_zero_block_cost[bi];\n          cost -= accumulated_zero_block_cost[i];\n          cost += accumulated_block_cost[i];\n          zero_block_run = bi - i + requires_eob[i];\n          nbits = JPEG_NBITS(zero_block_run);\n          cost += actbl->ehufsi[16*nbits] + nbits;\n          \n          if (cost < best_cost) {\n            block_run_start[bi] = i;\n            best_cost = cost;\n            accumulated_block_cost[bi+1] = cost;\n          }\n        }\n      }\n    }\n  }\n  \n  if (cinfo->master->trellis_eob_opt) {\n    int last_block = num_blocks;\n    best_cost = 1e38;\n    \n    for (i = 0; i <= num_blocks; i++) {\n      int zero_block_run;\n      int nbits;\n      float cost = 0.0;\n      \n      if (requires_eob[i] == 2)\n        continue;\n\n      cost += accumulated_zero_block_cost[num_blocks];\n      cost -= accumulated_zero_block_cost[i];\n      zero_block_run = num_blocks - i + requires_eob[i];\n      nbits = JPEG_NBITS(zero_block_run);\n      cost += actbl->ehufsi[16*nbits] + nbits;\n      if (cost < best_cost) {\n        best_cost = cost;\n        last_block = i;\n      }\n    }\n    last_block--;\n    bi = num_blocks - 1;\n    while (bi >= 0) {\n      while (bi > last_block) {\n        for (j = Ss; j <= Se; j++) {\n          int z = jpeg_natural_order[j];\n          coef_blocks[bi][z] = 0;\n        }\n        bi--;\n      }\n      last_block = block_run_start[bi]-1;\n      bi--;\n    }\n    free(accumulated_zero_block_cost);\n    free(accumulated_block_cost);\n    free(block_run_start);\n    free(requires_eob);\n  }\n  \n  if (cinfo->master->trellis_q_opt) {\n    for (bi = 0; bi < num_blocks; bi++) {\n      for (i = 1; i < DCTSIZE2; i++) {\n        norm_src[i] += src[bi][i] * coef_blocks[bi][i];\n        norm_coef[i] += 8 * coef_blocks[bi][i] * coef_blocks[bi][i];\n      }\n    }\n  }\n  \n  if (cinfo->master->trellis_quant_dc) {\n    j = 0;\n    for (i = 1; i < dc_trellis_candidates; i++) {\n      if (accumulated_dc_cost[i][num_blocks-1] < accumulated_dc_cost[j][num_blocks-1])\n        j = i;\n    }\n    for (bi = num_blocks-1; bi >= 0; bi--) {\n      coef_blocks[bi][0] = dc_candidate[j][bi];\n      j = dc_cost_backtrack[j][bi];\n    }\n\n    /* Save DC predictor */\n    *last_dc_val = coef_blocks[num_blocks-1][0];\n\n    for (i = 0; i < dc_trellis_candidates; i++) {\n      free(accumulated_dc_cost[i]);\n      free(dc_cost_backtrack[i]);\n      free(dc_candidate[i]);\n    }\n  }\n\n}\n#endif\n\n#ifdef C_ARITH_CODING_SUPPORTED\nGLOBAL(void)\nquantize_trellis_arith(j_compress_ptr cinfo, arith_rates *r, JBLOCKROW coef_blocks, JBLOCKROW src, JDIMENSION num_blocks,\n                 JQUANT_TBL * qtbl, double *norm_src, double *norm_coef, JCOEF *last_dc_val,\n                 JBLOCKROW coef_blocks_above, JBLOCKROW src_above)\n{\n  int i, j, k, l;\n  float accumulated_zero_dist[DCTSIZE2];\n  float accumulated_cost[DCTSIZE2];\n  int run_start[DCTSIZE2];\n  int bi;\n  float best_cost;\n  int last_coeff_idx; /* position of last nonzero coefficient */\n  float norm = 0.0;\n  float lambda_base;\n  float lambda;\n  float lambda_dc;\n  const float *lambda_tbl = (cinfo->master->use_lambda_weight_tbl) ?\n  jpeg_lambda_weights_csf_luma :\n  jpeg_lambda_weights_flat;\n  int Ss, Se;\n  float cost;\n  float run_bits;\n  int rate;\n  float *accumulated_dc_cost[DC_TRELLIS_MAX_CANDIDATES];\n  int *dc_cost_backtrack[DC_TRELLIS_MAX_CANDIDATES];\n  JCOEF *dc_candidate[DC_TRELLIS_MAX_CANDIDATES];\n  int *dc_context[DC_TRELLIS_MAX_CANDIDATES];\n  \n  int mode = 1;\n  float lambda_table[DCTSIZE2];\n  const int dc_trellis_candidates = get_num_dc_trellis_candidates(qtbl->quantval[0]);\n  \n  Ss = cinfo->Ss;\n  Se = cinfo->Se;\n  if (Ss == 0)\n    Ss = 1;\n  if (Se < Ss)\n    return;\n  \n  if (cinfo->master->trellis_quant_dc) {\n    for (i = 0; i < dc_trellis_candidates; i++) {\n      accumulated_dc_cost[i] = (float *)malloc(num_blocks * sizeof(float));\n      dc_cost_backtrack[i] = (int *)malloc(num_blocks * sizeof(int));\n      dc_candidate[i] = (JCOEF *)malloc(num_blocks * sizeof(JCOEF));\n      dc_context[i] = (int *)malloc(num_blocks * sizeof(int));\n      if (!accumulated_dc_cost[i] ||\n          !dc_cost_backtrack[i] ||\n          !dc_candidate[i] ||\n          !dc_context[i]) {\n        ERREXIT(cinfo, JERR_OUT_OF_MEMORY);\n      }\n    }\n  }\n  \n  norm = 0.0;\n  for (i = 1; i < DCTSIZE2; i++) {\n    norm += qtbl->quantval[i] * qtbl->quantval[i];\n  }\n  norm /= 63.0;\n  \n  if (mode == 1) {\n    lambda_base = 1.0;\n    lambda_tbl = lambda_table;\n    for (i = 0; i < DCTSIZE2; i++)\n      lambda_table[i] = 1.0 / (qtbl->quantval[i] * qtbl->quantval[i]);\n  } else\n    lambda_base = 1.0 / norm;\n  \n  for (bi = 0; bi < num_blocks; bi++) {\n    \n    norm = 0.0;\n    for (i = 1; i < DCTSIZE2; i++) {\n      norm += src[bi][i] * src[bi][i];\n    }\n    norm /= 63.0;\n    \n    if (cinfo->master->lambda_log_scale2 > 0.0)\n      lambda = pow(2.0, cinfo->master->lambda_log_scale1) * lambda_base /\n      (pow(2.0, cinfo->master->lambda_log_scale2) + norm);\n    else\n      lambda = pow(2.0, cinfo->master->lambda_log_scale1 - 12.0) * lambda_base;\n    \n    lambda_dc = lambda * lambda_tbl[0];\n    \n    accumulated_zero_dist[Ss-1] = 0.0;\n    accumulated_cost[Ss-1] = 0.0;\n    \n    /* Do DC coefficient */\n    if (cinfo->master->trellis_quant_dc) {\n      int sign = src[bi][0] >> 31;\n      int x = abs(src[bi][0]);\n      int q = 8 * qtbl->quantval[0];\n      int qval;\n      float dc_candidate_dist;\n      \n      qval = (x + q/2) / q; /* quantized value (round nearest) */\n      \n      /* loop over candidates in current block */\n      for (k = 0; k < dc_trellis_candidates; k++) {\n        int delta;\n        int dc_delta;\n        float bits;\n        int m;\n        int v2;\n        \n        dc_candidate[k][bi] = qval - dc_trellis_candidates/2 + k;\n        delta = dc_candidate[k][bi] * q - x;\n        dc_candidate_dist = delta * delta * lambda_dc;\n        dc_candidate[k][bi] *= 1 + 2*sign;\n        \n        /* Take into account DC differences */\n        if (coef_blocks_above && src_above && cinfo->master->trellis_delta_dc_weight > 0.0) {\n          int dc_above_orig;\n          int dc_above_recon;\n          int dc_orig;\n          int dc_recon;\n          float vertical_dist;\n          \n          dc_above_orig = src_above[bi][0];\n          dc_above_recon = coef_blocks_above[bi][0] * q;\n          dc_orig = src[bi][0];\n          dc_recon = dc_candidate[k][bi] * q;\n          /* delta is difference of vertical gradients */\n          delta = (dc_above_orig - dc_orig) - (dc_above_recon - dc_recon);\n          vertical_dist = delta * delta * lambda_dc;\n          dc_candidate_dist +=  cinfo->master->trellis_delta_dc_weight * (vertical_dist - dc_candidate_dist);\n        }\n        \n        /* loop of candidates from previous block */\n        for (l = 0; l < (bi == 0 ? 1 : dc_trellis_candidates); l++) {\n          int dc_pred = (bi == 0 ? *last_dc_val : dc_candidate[l][bi-1]);\n          int updated_dc_context = 0;\n          int st = (bi == 0) ? 0 : dc_context[l][bi-1];\n          dc_delta = dc_candidate[k][bi] - dc_pred;\n          \n          bits = r->rate_dc[st][dc_delta != 0];\n          \n          if (dc_delta != 0) {\n            bits += r->rate_dc[st+1][dc_delta < 0];\n            st += 2 + (dc_delta < 0);\n            updated_dc_context = (dc_delta < 0) ? 8 : 4;\n            \n            dc_delta = abs(dc_delta);\n            \n            m = 0;\n            if (dc_delta -= 1) {\n              bits += r->rate_dc[st][1];\n              st = 20;\n              m = 1;\n              v2 = dc_delta;\n              while (v2 >>= 1) {\n                bits += r->rate_dc[st][1];\n                m <<= 1;\n                st++;\n              }\n            }\n            bits += r->rate_dc[st][0];\n            \n            if (m < (int) ((1L << r->arith_dc_L) >> 1))\n              updated_dc_context = 0;    /* zero diff category */\n            else if (m > (int) ((1L << r->arith_dc_U) >> 1))\n              updated_dc_context += 8;   /* large diff category */\n\n            st += 14;\n            while (m >>= 1)\n              bits += r->rate_dc[st][(m & dc_delta) ? 1 : 0];\n          }\n          \n          cost = bits + dc_candidate_dist;\n          if (bi != 0)\n            cost += accumulated_dc_cost[l][bi-1];\n          \n          if (l == 0 || cost < accumulated_dc_cost[k][bi]) {\n            accumulated_dc_cost[k][bi] = cost;\n            dc_cost_backtrack[k][bi] = (bi == 0 ? -1 : l);\n            dc_context[k][bi] = updated_dc_context;\n          }\n        }\n      }\n    }\n    \n    /* Do AC coefficients */\n    for (i = Ss; i <= Se; i++) {\n      int z = jpeg_natural_order[i];\n      \n      int sign = src[bi][z] >> 31;\n      int x = abs(src[bi][z]);\n      int q = 8 * qtbl->quantval[z];\n      int candidate[16];\n      float candidate_dist[16];\n      int num_candidates;\n      int qval;\n      int delta;\n      \n      accumulated_zero_dist[i] = x * x * lambda * lambda_tbl[z] + accumulated_zero_dist[i-1];\n      \n      qval = (x + q/2) / q; /* quantized value (round nearest) */\n      \n      if (qval == 0) {\n        coef_blocks[bi][z] = 0;\n        accumulated_cost[i] = 1e38; /* Shouldn't be needed */\n        continue;\n      }\n      \n      k = 0;\n      candidate[k] = qval;\n      delta = candidate[k] * q - x;\n      candidate_dist[k] = delta * delta * lambda * lambda_tbl[z];\n      k++;\n      if (qval > 1) {\n        candidate[k] = qval - 1;\n        delta = candidate[k] * q - x;\n        candidate_dist[k] = delta * delta * lambda * lambda_tbl[z];\n        k++;\n      }\n      num_candidates = k;\n      \n      accumulated_cost[i] = 1e38;\n      \n      for (j = Ss-1; j < i; j++) {\n        int zz = jpeg_natural_order[j];\n        if (j != Ss-1 && coef_blocks[bi][zz] == 0)\n          continue;\n        \n        run_bits = r->rate_ac[3*j][0]; /* EOB */\n        for (k = j+1; k < i; k++)\n          run_bits += r->rate_ac[3*(k-1)+1][0];\n        run_bits += r->rate_ac[3*(i-1)+1][1];\n        \n        for (k = 0; k < num_candidates; k++) {\n          float coef_bits = 1.0; /* sign bit */\n          int v = candidate[k];\n          int v2;\n          int m;\n          int st;\n          \n          st = 3*(i-1)+2;\n          m = 0;\n          if (v -= 1) {\n            coef_bits += r->rate_ac[st][1];\n            m = 1;\n            v2 = v;\n            if (v2 >>= 1) {\n              coef_bits += r->rate_ac[st][1];\n              m <<= 1;\n              st = (i <= r->arith_ac_K) ? 189 : 217;\n              while (v2 >>= 1) {\n                coef_bits += r->rate_ac[st][1];\n                m <<= 1;\n                st++;\n              }\n            }\n          }\n          coef_bits += r->rate_ac[st][0];\n          st += 14;\n          while (m >>= 1)\n            coef_bits += r->rate_ac[st][(m & v) ? 1 : 0];\n          \n          rate = coef_bits + run_bits;\n          cost = rate + candidate_dist[k];\n          cost += accumulated_zero_dist[i-1] - accumulated_zero_dist[j] + accumulated_cost[j];\n          \n          if (cost < accumulated_cost[i]) {\n            coef_blocks[bi][z] = (candidate[k] ^ sign) - sign;\n            accumulated_cost[i] = cost;\n            run_start[i] = j;\n          }\n        }\n      }\n    }\n    \n    last_coeff_idx = Ss-1;\n    best_cost = accumulated_zero_dist[Se] + r->rate_ac[0][1];\n    \n    for (i = Ss; i <= Se; i++) {\n      int z = jpeg_natural_order[i];\n      if (coef_blocks[bi][z] != 0) {\n        float cost = accumulated_cost[i] + accumulated_zero_dist[Se] - accumulated_zero_dist[i];\n        \n        if (i < Se)\n          cost += r->rate_ac[3*(i-1)][1];\n        \n        if (cost < best_cost) {\n          best_cost = cost;\n          last_coeff_idx = i;\n        }\n      }\n    }\n    \n    /* Zero out coefficients that are part of runs */\n    i = Se;\n    while (i >= Ss)\n    {\n      while (i > last_coeff_idx) {\n        int z = jpeg_natural_order[i];\n        coef_blocks[bi][z] = 0;\n        i--;\n      }\n      last_coeff_idx = run_start[i];\n      i--;\n    }\n    \n  }\n  \n  if (cinfo->master->trellis_q_opt) {\n    for (bi = 0; bi < num_blocks; bi++) {\n      for (i = 1; i < DCTSIZE2; i++) {\n        norm_src[i] += src[bi][i] * coef_blocks[bi][i];\n        norm_coef[i] += 8 * coef_blocks[bi][i] * coef_blocks[bi][i];\n      }\n    }\n  }\n  \n  if (cinfo->master->trellis_quant_dc) {\n    j = 0;\n    for (i = 1; i < dc_trellis_candidates; i++) {\n      if (accumulated_dc_cost[i][num_blocks-1] < accumulated_dc_cost[j][num_blocks-1])\n        j = i;\n    }\n    for (bi = num_blocks-1; bi >= 0; bi--) {\n      coef_blocks[bi][0] = dc_candidate[j][bi];\n      j = dc_cost_backtrack[j][bi];\n    }\n    \n    /* Save DC predictor */\n    *last_dc_val = coef_blocks[num_blocks-1][0];\n    \n    for (i = 0; i < dc_trellis_candidates; i++) {\n      free(accumulated_dc_cost[i]);\n      free(dc_cost_backtrack[i]);\n      free(dc_candidate[i]);\n      free(dc_context[i]);\n    }\n  }\n}\n#endif\n\n/*\n * Initialize FDCT manager.\n */\n\nGLOBAL(void)\n_jinit_forward_dct(j_compress_ptr cinfo)\n{\n  my_fdct_ptr fdct;\n  int i;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  fdct = (my_fdct_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_fdct_controller));\n  cinfo->fdct = (struct jpeg_forward_dct *)fdct;\n  fdct->pub.start_pass = start_pass_fdctmgr;\n\n  /* First determine the DCT... */\n  switch (cinfo->dct_method) {\n#ifdef DCT_ISLOW_SUPPORTED\n  case JDCT_ISLOW:\n    fdct->pub._forward_DCT = forward_DCT;\n#ifdef WITH_SIMD\n    if (jsimd_can_fdct_islow())\n      fdct->dct = jsimd_fdct_islow;\n    else\n#endif\n      fdct->dct = _jpeg_fdct_islow;\n    break;\n#endif\n#ifdef DCT_IFAST_SUPPORTED\n  case JDCT_IFAST:\n    fdct->pub._forward_DCT = forward_DCT;\n#ifdef WITH_SIMD\n    if (jsimd_can_fdct_ifast())\n      fdct->dct = jsimd_fdct_ifast;\n    else\n#endif\n      fdct->dct = _jpeg_fdct_ifast;\n    break;\n#endif\n#ifdef DCT_FLOAT_SUPPORTED\n  case JDCT_FLOAT:\n    fdct->pub._forward_DCT = forward_DCT_float;\n#ifdef WITH_SIMD\n    if (jsimd_can_fdct_float())\n      fdct->float_dct = jsimd_fdct_float;\n    else\n#endif\n      fdct->float_dct = jpeg_fdct_float;\n    break;\n#endif\n  default:\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n    break;\n  }\n\n  /* ...then the supporting stages. */\n  switch (cinfo->dct_method) {\n#ifdef DCT_ISLOW_SUPPORTED\n  case JDCT_ISLOW:\n#endif\n#ifdef DCT_IFAST_SUPPORTED\n  case JDCT_IFAST:\n#endif\n#if defined(DCT_ISLOW_SUPPORTED) || defined(DCT_IFAST_SUPPORTED)\n#ifdef WITH_SIMD\n    if (jsimd_can_convsamp())\n      fdct->convsamp = jsimd_convsamp;\n    else\n#endif\n      fdct->convsamp = convsamp;\n\n    if (cinfo->master->overshoot_deringing) {\n      fdct->preprocess = preprocess_deringing;\n    } else {\n      fdct->preprocess = NULL;\n    }\n\n#ifdef WITH_SIMD\n    if (jsimd_can_quantize())\n      fdct->quantize = jsimd_quantize;\n    else\n#endif\n      fdct->quantize = quantize;\n    break;\n#endif\n#ifdef DCT_FLOAT_SUPPORTED\n  case JDCT_FLOAT:\n#ifdef WITH_SIMD\n    if (jsimd_can_convsamp_float())\n      fdct->float_convsamp = jsimd_convsamp_float;\n    else\n#endif\n      fdct->float_convsamp = convsamp_float;\n\n    if (cinfo->master->overshoot_deringing) {\n      fdct->float_preprocess = float_preprocess_deringing;\n    } else {\n      fdct->float_preprocess = NULL;\n    }\n\n#ifdef WITH_SIMD\n    if (jsimd_can_quantize_float())\n      fdct->float_quantize = jsimd_quantize_float;\n    else\n#endif\n      fdct->float_quantize = quantize_float;\n    break;\n#endif\n  default:\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n    break;\n  }\n\n  /* Allocate workspace memory */\n#ifdef DCT_FLOAT_SUPPORTED\n  if (cinfo->dct_method == JDCT_FLOAT)\n    fdct->float_workspace = (FAST_FLOAT *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  sizeof(FAST_FLOAT) * DCTSIZE2);\n  else\n#endif\n    fdct->workspace = (DCTELEM *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  sizeof(DCTELEM) * DCTSIZE2);\n\n  /* Mark divisor tables unallocated */\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    fdct->divisors[i] = NULL;\n#ifdef DCT_FLOAT_SUPPORTED\n    fdct->float_divisors[i] = NULL;\n#endif\n  }\n}\n"
        },
        {
          "name": "jcdiffct.c",
          "type": "blob",
          "size": 14.4921875,
          "content": "/*\n * jcdiffct.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the difference buffer controller for compression.\n * This controller is the top level of the lossless JPEG compressor proper.\n * The difference buffer lies between the prediction/differencing and entropy\n * encoding steps.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jlossls.h\"            /* Private declarations for lossless codec */\n\n\n#ifdef C_LOSSLESS_SUPPORTED\n\n/* We use a full-image sample buffer when doing Huffman optimization,\n * and also for writing multiple-scan JPEG files.  In all cases, the\n * full-image buffer is filled during the first pass, and the scaling,\n * prediction and differencing steps are run during subsequent passes.\n */\n#ifdef ENTROPY_OPT_SUPPORTED\n#define FULL_SAMP_BUFFER_SUPPORTED\n#else\n#ifdef C_MULTISCAN_FILES_SUPPORTED\n#define FULL_SAMP_BUFFER_SUPPORTED\n#endif\n#endif\n\n\n/* Private buffer controller object */\n\ntypedef struct {\n  struct jpeg_c_coef_controller pub; /* public fields */\n\n  JDIMENSION iMCU_row_num;      /* iMCU row # within image */\n  JDIMENSION mcu_ctr;           /* counts MCUs processed in current row */\n  int MCU_vert_offset;          /* counts MCU rows within iMCU row */\n  int MCU_rows_per_iMCU_row;    /* number of such rows needed */\n\n  _JSAMPROW cur_row[MAX_COMPONENTS];    /* row of point-transformed samples */\n  _JSAMPROW prev_row[MAX_COMPONENTS];   /* previous row of Pt'd samples */\n  JDIFFARRAY diff_buf[MAX_COMPONENTS];  /* iMCU row of differences */\n\n  /* In multi-pass modes, we need a virtual sample array for each component. */\n  jvirt_sarray_ptr whole_image[MAX_COMPONENTS];\n} my_diff_controller;\n\ntypedef my_diff_controller *my_diff_ptr;\n\n\n/* Forward declarations */\nMETHODDEF(boolean) compress_data(j_compress_ptr cinfo, _JSAMPIMAGE input_buf);\n#ifdef FULL_SAMP_BUFFER_SUPPORTED\nMETHODDEF(boolean) compress_first_pass(j_compress_ptr cinfo,\n                                       _JSAMPIMAGE input_buf);\nMETHODDEF(boolean) compress_output(j_compress_ptr cinfo,\n                                   _JSAMPIMAGE input_buf);\n#endif\n\n\nLOCAL(void)\nstart_iMCU_row(j_compress_ptr cinfo)\n/* Reset within-iMCU-row counters for a new row */\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n\n  /* In an interleaved scan, an MCU row is the same as an iMCU row.\n   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.\n   * But at the bottom of the image, process only what's left.\n   */\n  if (cinfo->comps_in_scan > 1) {\n    diff->MCU_rows_per_iMCU_row = 1;\n  } else {\n    if (diff->iMCU_row_num < (cinfo->total_iMCU_rows-1))\n      diff->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;\n    else\n      diff->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;\n  }\n\n  diff->mcu_ctr = 0;\n  diff->MCU_vert_offset = 0;\n}\n\n\n/*\n * Initialize for a processing pass.\n */\n\nMETHODDEF(void)\nstart_pass_diff(j_compress_ptr cinfo, J_BUF_MODE pass_mode)\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n\n  /* Because it is hitching a ride on the jpeg_forward_dct struct,\n   * start_pass_lossless() will be called at the start of the initial pass.\n   * This ensures that it will be called at the start of the Huffman\n   * optimization and output passes as well.\n   */\n  if (pass_mode == JBUF_CRANK_DEST)\n    (*cinfo->fdct->start_pass) (cinfo);\n\n  diff->iMCU_row_num = 0;\n  start_iMCU_row(cinfo);\n\n  switch (pass_mode) {\n  case JBUF_PASS_THRU:\n    if (diff->whole_image[0] != NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    diff->pub._compress_data = compress_data;\n    break;\n#ifdef FULL_SAMP_BUFFER_SUPPORTED\n  case JBUF_SAVE_AND_PASS:\n    if (diff->whole_image[0] == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    diff->pub._compress_data = compress_first_pass;\n    break;\n  case JBUF_CRANK_DEST:\n    if (diff->whole_image[0] == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    diff->pub._compress_data = compress_output;\n    break;\n#endif\n  default:\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    break;\n  }\n}\n\n\n#define SWAP_ROWS(rowa, rowb) { \\\n  _JSAMPROW temp = rowa; \\\n  rowa = rowb;  rowb = temp; \\\n}\n\n/*\n * Process some data in the single-pass case.\n * We process the equivalent of one fully interleaved MCU row (\"iMCU\" row)\n * per call, ie, v_samp_factor rows for each component in the image.\n * Returns TRUE if the iMCU row is completed, FALSE if suspended.\n *\n * NB: input_buf contains a plane for each component in image,\n * which we index according to the component's SOF position.\n */\n\nMETHODDEF(boolean)\ncompress_data(j_compress_ptr cinfo, _JSAMPIMAGE input_buf)\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n  lossless_comp_ptr losslessc = (lossless_comp_ptr)cinfo->fdct;\n  JDIMENSION MCU_col_num;       /* index of current MCU within row */\n  JDIMENSION MCU_count;         /* number of MCUs encoded */\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  int ci, compi, yoffset, samp_row, samp_rows, samps_across;\n  jpeg_component_info *compptr;\n\n  /* Loop to write as much as one whole iMCU row */\n  for (yoffset = diff->MCU_vert_offset; yoffset < diff->MCU_rows_per_iMCU_row;\n       yoffset++) {\n\n    MCU_col_num = diff->mcu_ctr;\n\n    /* Scale and predict each scanline of the MCU row separately.\n     *\n     * Note: We only do this if we are at the start of an MCU row, ie,\n     * we don't want to reprocess a row suspended by the output.\n     */\n    if (MCU_col_num == 0) {\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n        compptr = cinfo->cur_comp_info[ci];\n        compi = compptr->component_index;\n        if (diff->iMCU_row_num < last_iMCU_row)\n          samp_rows = compptr->v_samp_factor;\n        else {\n          /* NB: can't use last_row_height here, since may not be set! */\n          samp_rows =\n            (int)(compptr->height_in_blocks % compptr->v_samp_factor);\n          if (samp_rows == 0) samp_rows = compptr->v_samp_factor;\n          else {\n            /* Fill dummy difference rows at the bottom edge with zeros, which\n             * will encode to the smallest amount of data.\n             */\n            for (samp_row = samp_rows; samp_row < compptr->v_samp_factor;\n                 samp_row++)\n              memset(diff->diff_buf[compi][samp_row], 0,\n                     jround_up((long)compptr->width_in_blocks,\n                               (long)compptr->h_samp_factor) * sizeof(JDIFF));\n          }\n        }\n        samps_across = compptr->width_in_blocks;\n\n        for (samp_row = 0; samp_row < samp_rows; samp_row++) {\n          (*losslessc->scaler_scale) (cinfo,\n                                      input_buf[compi][samp_row],\n                                      diff->cur_row[compi],\n                                      samps_across);\n          (*losslessc->predict_difference[compi])\n            (cinfo, compi, diff->cur_row[compi], diff->prev_row[compi],\n             diff->diff_buf[compi][samp_row], samps_across);\n          SWAP_ROWS(diff->cur_row[compi], diff->prev_row[compi]);\n        }\n      }\n    }\n    /* Try to write the MCU row (or remaining portion of suspended MCU row). */\n    MCU_count =\n      (*cinfo->entropy->encode_mcus) (cinfo,\n                                      diff->diff_buf, yoffset, MCU_col_num,\n                                      cinfo->MCUs_per_row - MCU_col_num);\n    if (MCU_count != cinfo->MCUs_per_row - MCU_col_num) {\n      /* Suspension forced; update state counters and exit */\n      diff->MCU_vert_offset = yoffset;\n      diff->mcu_ctr += MCU_col_num;\n      return FALSE;\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    diff->mcu_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  diff->iMCU_row_num++;\n  start_iMCU_row(cinfo);\n  return TRUE;\n}\n\n\n#ifdef FULL_SAMP_BUFFER_SUPPORTED\n\n/*\n * Process some data in the first pass of a multi-pass case.\n * We process the equivalent of one fully interleaved MCU row (\"iMCU\" row)\n * per call, ie, v_samp_factor rows for each component in the image.\n * This amount of data is read from the source buffer and saved into the\n * virtual arrays.\n *\n * We must also emit the data to the compressor.  This is conveniently\n * done by calling compress_output() after we've loaded the current strip\n * of the virtual arrays.\n *\n * NB: input_buf contains a plane for each component in image.  All components\n * are loaded into the virtual arrays in this pass.  However, it may be that\n * only a subset of the components are emitted to the compressor during\n * this first pass; be careful about looking at the scan-dependent variables\n * (MCU dimensions, etc).\n */\n\nMETHODDEF(boolean)\ncompress_first_pass(j_compress_ptr cinfo, _JSAMPIMAGE input_buf)\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  JDIMENSION samps_across;\n  int ci, samp_row, samp_rows;\n  _JSAMPARRAY buffer;\n  jpeg_component_info *compptr;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Align the virtual buffer for this component. */\n    buffer = (_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, diff->whole_image[ci],\n       diff->iMCU_row_num * compptr->v_samp_factor,\n       (JDIMENSION)compptr->v_samp_factor, TRUE);\n\n    /* Count non-dummy sample rows in this iMCU row. */\n    if (diff->iMCU_row_num < last_iMCU_row)\n      samp_rows = compptr->v_samp_factor;\n    else {\n      /* NB: can't use last_row_height here, since may not be set! */\n      samp_rows = (int)(compptr->height_in_blocks % compptr->v_samp_factor);\n      if (samp_rows == 0) samp_rows = compptr->v_samp_factor;\n    }\n    samps_across = compptr->width_in_blocks;\n\n    /* Perform point transform scaling and prediction/differencing for all\n     * non-dummy rows in this iMCU row.  Each call on these functions\n     * processes a complete row of samples.\n     */\n    for (samp_row = 0; samp_row < samp_rows; samp_row++) {\n      memcpy(buffer[samp_row], input_buf[ci][samp_row],\n             samps_across * sizeof(_JSAMPLE));\n    }\n  }\n  /* NB: compress_output will increment iMCU_row_num if successful.\n   * A suspension return will result in redoing all the work above next time.\n   */\n\n  /* Emit data to the compressor, sharing code with subsequent passes */\n  return compress_output(cinfo, input_buf);\n}\n\n\n/*\n * Process some data in subsequent passes of a multi-pass case.\n * We process the equivalent of one fully interleaved MCU row (\"iMCU\" row)\n * per call, ie, v_samp_factor rows for each component in the scan.\n * The data is obtained from the virtual arrays and fed to the compressor.\n * Returns TRUE if the iMCU row is completed, FALSE if suspended.\n *\n * NB: input_buf is ignored; it is likely to be a NULL pointer.\n */\n\nMETHODDEF(boolean)\ncompress_output(j_compress_ptr cinfo, _JSAMPIMAGE input_buf)\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n  int ci, compi;\n  _JSAMPARRAY buffer[MAX_COMPS_IN_SCAN];\n  jpeg_component_info *compptr;\n\n  /* Align the virtual buffers for the components used in this scan.\n   * NB: during first pass, this is safe only because the buffers will\n   * already be aligned properly, so jmemmgr.c won't need to do any I/O.\n   */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    compi = compptr->component_index;\n    buffer[compi] = (_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, diff->whole_image[compi],\n       diff->iMCU_row_num * compptr->v_samp_factor,\n       (JDIMENSION)compptr->v_samp_factor, FALSE);\n  }\n\n  return compress_data(cinfo, buffer);\n}\n\n#endif /* FULL_SAMP_BUFFER_SUPPORTED */\n\n\n/*\n * Initialize difference buffer controller.\n */\n\nGLOBAL(void)\n_jinit_c_diff_controller(j_compress_ptr cinfo, boolean need_full_buffer)\n{\n  my_diff_ptr diff;\n  int ci, row;\n  jpeg_component_info *compptr;\n\n  diff = (my_diff_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_diff_controller));\n  cinfo->coef = (struct jpeg_c_coef_controller *)diff;\n  diff->pub.start_pass = start_pass_diff;\n\n  /* Create the prediction row buffers. */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    diff->cur_row[ci] = *(_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       (JDIMENSION)jround_up((long)compptr->width_in_blocks,\n                             (long)compptr->h_samp_factor),\n       (JDIMENSION)1);\n    diff->prev_row[ci] = *(_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       (JDIMENSION)jround_up((long)compptr->width_in_blocks,\n                             (long)compptr->h_samp_factor),\n       (JDIMENSION)1);\n  }\n\n  /* Create the difference buffer. */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    diff->diff_buf[ci] =\n      ALLOC_DARRAY(JPOOL_IMAGE,\n                   (JDIMENSION)jround_up((long)compptr->width_in_blocks,\n                                         (long)compptr->h_samp_factor),\n                   (JDIMENSION)compptr->v_samp_factor);\n    /* Prefill difference rows with zeros.  We do this because only actual\n     * data is placed in the buffers during prediction/differencing, leaving\n     * any dummy differences at the right edge as zeros, which will encode\n     * to the smallest amount of data.\n     */\n    for (row = 0; row < compptr->v_samp_factor; row++)\n      memset(diff->diff_buf[ci][row], 0,\n             jround_up((long)compptr->width_in_blocks,\n                       (long)compptr->h_samp_factor) * sizeof(JDIFF));\n  }\n\n  /* Create the sample buffer. */\n  if (need_full_buffer) {\n#ifdef FULL_SAMP_BUFFER_SUPPORTED\n    /* Allocate a full-image virtual array for each component, */\n    /* padded to a multiple of samp_factor differences in each direction. */\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      diff->whole_image[ci] = (*cinfo->mem->request_virt_sarray)\n        ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n         (JDIMENSION)jround_up((long)compptr->width_in_blocks,\n                               (long)compptr->h_samp_factor),\n         (JDIMENSION)jround_up((long)compptr->height_in_blocks,\n                               (long)compptr->v_samp_factor),\n         (JDIMENSION)compptr->v_samp_factor);\n    }\n#else\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n#endif\n  } else\n    diff->whole_image[0] = NULL; /* flag for no virtual arrays */\n}\n\n#endif /* C_LOSSLESS_SUPPORTED */\n"
        },
        {
          "name": "jcext.c",
          "type": "blob",
          "size": 5.2646484375,
          "content": "/*\n * jcext.c\n *\n * Copyright (C) 2014, D. R. Commander.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README file.\n *\n * This file contains accessor functions for extension parameters.  These\n * allow for extending the functionality of the libjpeg API without breaking\n * backward ABI compatibility.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n\n\nGLOBAL(boolean)\njpeg_c_bool_param_supported (const j_compress_ptr cinfo, J_BOOLEAN_PARAM param)\n{\n  switch (param) {\n  case JBOOLEAN_OPTIMIZE_SCANS:\n  case JBOOLEAN_TRELLIS_QUANT:\n  case JBOOLEAN_TRELLIS_QUANT_DC:\n  case JBOOLEAN_TRELLIS_EOB_OPT:\n  case JBOOLEAN_USE_LAMBDA_WEIGHT_TBL:\n  case JBOOLEAN_USE_SCANS_IN_TRELLIS:\n  case JBOOLEAN_TRELLIS_Q_OPT:\n  case JBOOLEAN_OVERSHOOT_DERINGING:\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nGLOBAL(void)\njpeg_c_set_bool_param (j_compress_ptr cinfo, J_BOOLEAN_PARAM param,\n                       boolean value)\n{\n  switch(param) {\n  case JBOOLEAN_OPTIMIZE_SCANS:\n    cinfo->master->optimize_scans = value;\n    break;\n  case JBOOLEAN_TRELLIS_QUANT:\n    cinfo->master->trellis_quant = value;\n    break;\n  case JBOOLEAN_TRELLIS_QUANT_DC:\n    cinfo->master->trellis_quant_dc = value;\n    break;\n  case JBOOLEAN_TRELLIS_EOB_OPT:\n    cinfo->master->trellis_eob_opt = value;\n    break;\n  case JBOOLEAN_USE_LAMBDA_WEIGHT_TBL:\n    cinfo->master->use_lambda_weight_tbl = value;\n    break;\n  case JBOOLEAN_USE_SCANS_IN_TRELLIS:\n    cinfo->master->use_scans_in_trellis = value;\n    break;\n  case JBOOLEAN_TRELLIS_Q_OPT:\n    cinfo->master->trellis_q_opt = value;\n    break;\n  case JBOOLEAN_OVERSHOOT_DERINGING:\n    cinfo->master->overshoot_deringing = value;\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BAD_PARAM);\n  }\n}\n\n\nGLOBAL(boolean)\njpeg_c_get_bool_param (const j_compress_ptr cinfo, J_BOOLEAN_PARAM param)\n{\n  switch(param) {\n  case JBOOLEAN_OPTIMIZE_SCANS:\n    return cinfo->master->optimize_scans;\n  case JBOOLEAN_TRELLIS_QUANT:\n    return cinfo->master->trellis_quant;\n  case JBOOLEAN_TRELLIS_QUANT_DC:\n    return cinfo->master->trellis_quant_dc;\n  case JBOOLEAN_TRELLIS_EOB_OPT:\n    return cinfo->master->trellis_eob_opt;\n  case JBOOLEAN_USE_LAMBDA_WEIGHT_TBL:\n    return cinfo->master->use_lambda_weight_tbl;\n  case JBOOLEAN_USE_SCANS_IN_TRELLIS:\n    return cinfo->master->use_scans_in_trellis;\n  case JBOOLEAN_TRELLIS_Q_OPT:\n    return cinfo->master->trellis_q_opt;\n  case JBOOLEAN_OVERSHOOT_DERINGING:\n    return cinfo->master->overshoot_deringing;\n  default:\n    ERREXIT(cinfo, JERR_BAD_PARAM);\n  }\n\n  return FALSE;\n}\n\n\nGLOBAL(boolean)\njpeg_c_float_param_supported (const j_compress_ptr cinfo, J_FLOAT_PARAM param)\n{\n  switch (param) {\n  case JFLOAT_LAMBDA_LOG_SCALE1:\n  case JFLOAT_LAMBDA_LOG_SCALE2:\n  case JFLOAT_TRELLIS_DELTA_DC_WEIGHT:\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nGLOBAL(void)\njpeg_c_set_float_param (j_compress_ptr cinfo, J_FLOAT_PARAM param, float value)\n{\n  switch (param) {\n  case JFLOAT_LAMBDA_LOG_SCALE1:\n    cinfo->master->lambda_log_scale1 = value;\n    break;\n  case JFLOAT_LAMBDA_LOG_SCALE2:\n    cinfo->master->lambda_log_scale2 = value;\n    break;\n  case JFLOAT_TRELLIS_DELTA_DC_WEIGHT:\n    cinfo->master->trellis_delta_dc_weight = value;\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BAD_PARAM);\n  }\n}\n\n\nGLOBAL(float)\njpeg_c_get_float_param (const j_compress_ptr cinfo, J_FLOAT_PARAM param)\n{\n  switch (param) {\n  case JFLOAT_LAMBDA_LOG_SCALE1:\n    return cinfo->master->lambda_log_scale1;\n  case JFLOAT_LAMBDA_LOG_SCALE2:\n    return cinfo->master->lambda_log_scale2;\n  case JFLOAT_TRELLIS_DELTA_DC_WEIGHT:\n    return cinfo->master->trellis_delta_dc_weight;\n  default:\n    ERREXIT(cinfo, JERR_BAD_PARAM);\n  }\n\n  return -1;\n}\n\n\nGLOBAL(boolean)\njpeg_c_int_param_supported (const j_compress_ptr cinfo, J_INT_PARAM param)\n{\n  switch (param) {\n  case JINT_COMPRESS_PROFILE:\n  case JINT_TRELLIS_FREQ_SPLIT:\n  case JINT_TRELLIS_NUM_LOOPS:\n  case JINT_BASE_QUANT_TBL_IDX:\n  case JINT_DC_SCAN_OPT_MODE:\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nGLOBAL(void)\njpeg_c_set_int_param (j_compress_ptr cinfo, J_INT_PARAM param, int value)\n{\n  switch (param) {\n  case JINT_COMPRESS_PROFILE:\n    switch (value) {\n    case JCP_MAX_COMPRESSION:\n    case JCP_FASTEST:\n      cinfo->master->compress_profile = value;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BAD_PARAM_VALUE);\n    }\n    break;\n  case JINT_TRELLIS_FREQ_SPLIT:\n    cinfo->master->trellis_freq_split = value;\n    break;\n  case JINT_TRELLIS_NUM_LOOPS:\n    cinfo->master->trellis_num_loops = value;\n    break;\n  case JINT_BASE_QUANT_TBL_IDX:\n    if (value >= 0 && value <= 8)\n      cinfo->master->quant_tbl_master_idx = value;\n    break;\n  case JINT_DC_SCAN_OPT_MODE:\n    cinfo->master->dc_scan_opt_mode = value;\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BAD_PARAM);\n  }\n}\n\n\nGLOBAL(int)\njpeg_c_get_int_param (const j_compress_ptr cinfo, J_INT_PARAM param)\n{\n  switch (param) {\n  case JINT_COMPRESS_PROFILE:\n    return cinfo->master->compress_profile;\n  case JINT_TRELLIS_FREQ_SPLIT:\n    return cinfo->master->trellis_freq_split;\n  case JINT_TRELLIS_NUM_LOOPS:\n    return cinfo->master->trellis_num_loops;\n  case JINT_BASE_QUANT_TBL_IDX:\n    return cinfo->master->quant_tbl_master_idx;\n  case JINT_DC_SCAN_OPT_MODE:\n    return cinfo->master->dc_scan_opt_mode;\n  default:\n    ERREXIT(cinfo, JERR_BAD_PARAM);\n  }\n\n  return -1;\n}\n"
        },
        {
          "name": "jchuff.c",
          "type": "blob",
          "size": 36.45703125,
          "content": "/*\n * jchuff.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2009-2011, 2014-2016, 2018-2024, D. R. Commander.\n * Copyright (C) 2015, Matthieu Darbois.\n * Copyright (C) 2018, Matthias Rncker.\n * Copyright (C) 2020, Arm Limited.\n * Copyright (C) 2022, Felix Hanau.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains Huffman entropy encoding routines.\n *\n * Much of the complexity here has to do with supporting output suspension.\n * If the data destination module demands suspension, we want to be able to\n * back up to the start of the current MCU.  To do this, we copy state\n * variables into local working storage, and update them back to the\n * permanent JPEG objects only upon successful completion of an MCU.\n *\n * NOTE: All referenced figures are from\n * Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#ifdef WITH_SIMD\n#include \"jsimd.h\"\n#else\n#include \"jchuff.h\"             /* Declarations shared with jc*huff.c */\n#endif\n#include <limits.h>\n#include \"jpeg_nbits.h\"\n\n\n/* Expanded entropy encoder object for Huffman encoding.\n *\n * The savable_state subrecord contains fields that change within an MCU,\n * but must not be updated permanently until we complete the MCU.\n */\n\n#if defined(__x86_64__) && defined(__ILP32__)\ntypedef unsigned long long bit_buf_type;\n#else\ntypedef size_t bit_buf_type;\n#endif\n\n/* NOTE: The more optimal Huffman encoding algorithm is only used by the\n * intrinsics implementation of the Arm Neon SIMD extensions, which is why we\n * retain the old Huffman encoder behavior when using the GAS implementation.\n */\n#if defined(WITH_SIMD) && !(defined(__arm__) || defined(__aarch64__) || \\\n                            defined(_M_ARM) || defined(_M_ARM64))\ntypedef unsigned long long simd_bit_buf_type;\n#else\ntypedef bit_buf_type simd_bit_buf_type;\n#endif\n\n#if (defined(SIZEOF_SIZE_T) && SIZEOF_SIZE_T == 8) || defined(_WIN64) || \\\n    (defined(__x86_64__) && defined(__ILP32__))\n#define BIT_BUF_SIZE  64\n#elif (defined(SIZEOF_SIZE_T) && SIZEOF_SIZE_T == 4) || defined(_WIN32)\n#define BIT_BUF_SIZE  32\n#else\n#error Cannot determine word size\n#endif\n#define SIMD_BIT_BUF_SIZE  (sizeof(simd_bit_buf_type) * 8)\n\ntypedef struct {\n  union {\n    bit_buf_type c;\n#ifdef WITH_SIMD\n    simd_bit_buf_type simd;\n#endif\n  } put_buffer;                         /* current bit accumulation buffer */\n  int free_bits;                        /* # of bits available in it */\n                                        /* (Neon GAS: # of bits now in it) */\n  int last_dc_val[MAX_COMPS_IN_SCAN];   /* last DC coef for each component */\n} savable_state;\n\ntypedef struct {\n  struct jpeg_entropy_encoder pub; /* public fields */\n\n  savable_state saved;          /* Bit buffer & DC state at start of MCU */\n\n  /* These fields are NOT loaded into local working state. */\n  unsigned int restarts_to_go;  /* MCUs left in this restart interval */\n  int next_restart_num;         /* next restart number to write (0-7) */\n\n  /* Pointers to derived tables (these workspaces have image lifespan) */\n  c_derived_tbl *dc_derived_tbls[NUM_HUFF_TBLS];\n  c_derived_tbl *ac_derived_tbls[NUM_HUFF_TBLS];\n\n#ifdef ENTROPY_OPT_SUPPORTED    /* Statistics tables for optimization */\n  long *dc_count_ptrs[NUM_HUFF_TBLS];\n  long *ac_count_ptrs[NUM_HUFF_TBLS];\n#endif\n\n#ifdef WITH_SIMD\n  int simd;\n#endif\n} huff_entropy_encoder;\n\ntypedef huff_entropy_encoder *huff_entropy_ptr;\n\n/* Working state while writing an MCU.\n * This struct contains all the fields that are needed by subroutines.\n */\n\ntypedef struct {\n  JOCTET *next_output_byte;     /* => next byte to write in buffer */\n  size_t free_in_buffer;        /* # of byte spaces remaining in buffer */\n  savable_state cur;            /* Current bit buffer & DC state */\n  j_compress_ptr cinfo;         /* dump_buffer needs access to this */\n#ifdef WITH_SIMD\n  int simd;\n#endif\n} working_state;\n\n\n/* Forward declarations */\nMETHODDEF(boolean) encode_mcu_huff(j_compress_ptr cinfo, JBLOCKROW *MCU_data);\nMETHODDEF(void) finish_pass_huff(j_compress_ptr cinfo);\n#ifdef ENTROPY_OPT_SUPPORTED\nMETHODDEF(boolean) encode_mcu_gather(j_compress_ptr cinfo,\n                                     JBLOCKROW *MCU_data);\nMETHODDEF(void) finish_pass_gather(j_compress_ptr cinfo);\n#endif\n\n\n/*\n * Initialize for a Huffman-compressed scan.\n * If gather_statistics is TRUE, we do not output anything during the scan,\n * just count the Huffman symbols used and generate Huffman code tables.\n */\n\nMETHODDEF(void)\nstart_pass_huff(j_compress_ptr cinfo, boolean gather_statistics)\n{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  int ci, dctbl, actbl;\n  jpeg_component_info *compptr;\n\n  if (gather_statistics) {\n#ifdef ENTROPY_OPT_SUPPORTED\n    entropy->pub.encode_mcu = encode_mcu_gather;\n    entropy->pub.finish_pass = finish_pass_gather;\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    entropy->pub.encode_mcu = encode_mcu_huff;\n    entropy->pub.finish_pass = finish_pass_huff;\n  }\n\n#ifdef WITH_SIMD\n  entropy->simd = jsimd_can_huff_encode_one_block();\n#endif\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    dctbl = compptr->dc_tbl_no;\n    actbl = compptr->ac_tbl_no;\n    if (gather_statistics) {\n#ifdef ENTROPY_OPT_SUPPORTED\n      /* Check for invalid table indexes */\n      /* (make_c_derived_tbl does this in the other path) */\n      if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS)\n        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);\n      if (actbl < 0 || actbl >= NUM_HUFF_TBLS)\n        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, actbl);\n      /* Allocate and zero the statistics tables */\n      /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */\n      if (entropy->dc_count_ptrs[dctbl] == NULL)\n        entropy->dc_count_ptrs[dctbl] = (long *)\n          (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                      257 * sizeof(long));\n      memset(entropy->dc_count_ptrs[dctbl], 0, 257 * sizeof(long));\n      if (entropy->ac_count_ptrs[actbl] == NULL)\n        entropy->ac_count_ptrs[actbl] = (long *)\n          (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                      257 * sizeof(long));\n      memset(entropy->ac_count_ptrs[actbl], 0, 257 * sizeof(long));\n#endif\n    } else {\n      /* Compute derived values for Huffman tables */\n      /* We may do this more than once for a table, but it's not expensive */\n      jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,\n                              &entropy->dc_derived_tbls[dctbl]);\n      jpeg_make_c_derived_tbl(cinfo, FALSE, actbl,\n                              &entropy->ac_derived_tbls[actbl]);\n    }\n    /* Initialize DC predictions to 0 */\n    entropy->saved.last_dc_val[ci] = 0;\n  }\n\n  /* Initialize bit buffer to empty */\n#ifdef WITH_SIMD\n  if (entropy->simd) {\n    entropy->saved.put_buffer.simd = 0;\n#if defined(__aarch64__) && !defined(NEON_INTRINSICS)\n    entropy->saved.free_bits = 0;\n#else\n    entropy->saved.free_bits = SIMD_BIT_BUF_SIZE;\n#endif\n  } else\n#endif\n  {\n    entropy->saved.put_buffer.c = 0;\n    entropy->saved.free_bits = BIT_BUF_SIZE;\n  }\n\n  /* Initialize restart stuff */\n  entropy->restarts_to_go = cinfo->restart_interval;\n  entropy->next_restart_num = 0;\n}\n\n\n/*\n * Compute the derived values for a Huffman table.\n * This routine also performs some validation checks on the table.\n *\n * Note this is also used by jcphuff.c and jclhuff.c.\n */\n\nGLOBAL(void)\njpeg_make_c_derived_tbl(j_compress_ptr cinfo, boolean isDC, int tblno,\n                        c_derived_tbl **pdtbl)\n{\n  JHUFF_TBL *htbl;\n  c_derived_tbl *dtbl;\n  int p, i, l, lastp, si, maxsymbol;\n  char huffsize[257];\n  unsigned int huffcode[257];\n  unsigned int code;\n\n  /* Note that huffsize[] and huffcode[] are filled in code-length order,\n   * paralleling the order of the symbols themselves in htbl->huffval[].\n   */\n\n  /* Find the input Huffman table */\n  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);\n  htbl =\n    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];\n  if (htbl == NULL)\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);\n\n  /* Allocate a workspace if we haven't already done so. */\n  if (*pdtbl == NULL)\n    *pdtbl = (c_derived_tbl *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  sizeof(c_derived_tbl));\n  dtbl = *pdtbl;\n\n  /* Figure C.1: make table of Huffman code length for each symbol */\n\n  p = 0;\n  for (l = 1; l <= 16; l++) {\n    i = (int)htbl->bits[l];\n    if (i < 0 || p + i > 256)   /* protect against table overrun */\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    while (i--)\n      huffsize[p++] = (char)l;\n  }\n  huffsize[p] = 0;\n  lastp = p;\n\n  /* Figure C.2: generate the codes themselves */\n  /* We also validate that the counts represent a legal Huffman code tree. */\n\n  code = 0;\n  si = huffsize[0];\n  p = 0;\n  while (huffsize[p]) {\n    while (((int)huffsize[p]) == si) {\n      huffcode[p++] = code;\n      code++;\n    }\n    /* code is now 1 more than the last code used for codelength si; but\n     * it must still fit in si bits, since no code is allowed to be all ones.\n     */\n    if (((JLONG)code) >= (((JLONG)1) << si))\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    code <<= 1;\n    si++;\n  }\n\n  /* Figure C.3: generate encoding tables */\n  /* These are code and size indexed by symbol value */\n\n  /* Set all codeless symbols to have code length 0;\n   * this lets us detect duplicate VAL entries here, and later\n   * allows emit_bits to detect any attempt to emit such symbols.\n   */\n  memset(dtbl->ehufco, 0, sizeof(dtbl->ehufco));\n  memset(dtbl->ehufsi, 0, sizeof(dtbl->ehufsi));\n\n  /* This is also a convenient place to check for out-of-range and duplicated\n   * VAL entries.  We allow 0..255 for AC symbols but only 0..15 for DC in\n   * lossy mode and 0..16 for DC in lossless mode.  (We could constrain them\n   * further based on data depth and mode, but this seems enough.)\n   */\n  maxsymbol = isDC ? (cinfo->master->lossless ? 16 : 15) : 255;\n\n  for (p = 0; p < lastp; p++) {\n    i = htbl->huffval[p];\n    if (i < 0 || i > maxsymbol || dtbl->ehufsi[i])\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    dtbl->ehufco[i] = huffcode[p];\n    dtbl->ehufsi[i] = huffsize[p];\n  }\n}\n\n\n/* Outputting bytes to the file */\n\n/* Emit a byte, taking 'action' if must suspend. */\n#define emit_byte(state, val, action) { \\\n  *(state)->next_output_byte++ = (JOCTET)(val); \\\n  if (--(state)->free_in_buffer == 0) \\\n    if (!dump_buffer(state)) \\\n      { action; } \\\n}\n\n\nLOCAL(boolean)\ndump_buffer(working_state *state)\n/* Empty the output buffer; return TRUE if successful, FALSE if must suspend */\n{\n  struct jpeg_destination_mgr *dest = state->cinfo->dest;\n\n  if (!(*dest->empty_output_buffer) (state->cinfo))\n    return FALSE;\n  /* After a successful buffer dump, must reset buffer pointers */\n  state->next_output_byte = dest->next_output_byte;\n  state->free_in_buffer = dest->free_in_buffer;\n  return TRUE;\n}\n\n\n/* Outputting bits to the file */\n\n/* Output byte b and, speculatively, an additional 0 byte.  0xFF must be\n * encoded as 0xFF 0x00, so the output buffer pointer is advanced by 2 if the\n * byte is 0xFF.  Otherwise, the output buffer pointer is advanced by 1, and\n * the speculative 0 byte will be overwritten by the next byte.\n */\n#define EMIT_BYTE(b) { \\\n  buffer[0] = (JOCTET)(b); \\\n  buffer[1] = 0; \\\n  buffer -= -2 + ((JOCTET)(b) < 0xFF); \\\n}\n\n/* Output the entire bit buffer.  If there are no 0xFF bytes in it, then write\n * directly to the output buffer.  Otherwise, use the EMIT_BYTE() macro to\n * encode 0xFF as 0xFF 0x00.\n */\n#if BIT_BUF_SIZE == 64\n\n#define FLUSH() { \\\n  if (put_buffer & 0x8080808080808080 & ~(put_buffer + 0x0101010101010101)) { \\\n    EMIT_BYTE(put_buffer >> 56) \\\n    EMIT_BYTE(put_buffer >> 48) \\\n    EMIT_BYTE(put_buffer >> 40) \\\n    EMIT_BYTE(put_buffer >> 32) \\\n    EMIT_BYTE(put_buffer >> 24) \\\n    EMIT_BYTE(put_buffer >> 16) \\\n    EMIT_BYTE(put_buffer >>  8) \\\n    EMIT_BYTE(put_buffer      ) \\\n  } else { \\\n    buffer[0] = (JOCTET)(put_buffer >> 56); \\\n    buffer[1] = (JOCTET)(put_buffer >> 48); \\\n    buffer[2] = (JOCTET)(put_buffer >> 40); \\\n    buffer[3] = (JOCTET)(put_buffer >> 32); \\\n    buffer[4] = (JOCTET)(put_buffer >> 24); \\\n    buffer[5] = (JOCTET)(put_buffer >> 16); \\\n    buffer[6] = (JOCTET)(put_buffer >> 8); \\\n    buffer[7] = (JOCTET)(put_buffer); \\\n    buffer += 8; \\\n  } \\\n}\n\n#else\n\n#define FLUSH() { \\\n  if (put_buffer & 0x80808080 & ~(put_buffer + 0x01010101)) { \\\n    EMIT_BYTE(put_buffer >> 24) \\\n    EMIT_BYTE(put_buffer >> 16) \\\n    EMIT_BYTE(put_buffer >>  8) \\\n    EMIT_BYTE(put_buffer      ) \\\n  } else { \\\n    buffer[0] = (JOCTET)(put_buffer >> 24); \\\n    buffer[1] = (JOCTET)(put_buffer >> 16); \\\n    buffer[2] = (JOCTET)(put_buffer >> 8); \\\n    buffer[3] = (JOCTET)(put_buffer); \\\n    buffer += 4; \\\n  } \\\n}\n\n#endif\n\n/* Fill the bit buffer to capacity with the leading bits from code, then output\n * the bit buffer and put the remaining bits from code into the bit buffer.\n */\n#define PUT_AND_FLUSH(code, size) { \\\n  put_buffer = (put_buffer << (size + free_bits)) | (code >> -free_bits); \\\n  FLUSH() \\\n  free_bits += BIT_BUF_SIZE; \\\n  put_buffer = code; \\\n}\n\n/* Insert code into the bit buffer and output the bit buffer if needed.\n * NOTE: We can't flush with free_bits == 0, since the left shift in\n * PUT_AND_FLUSH() would have undefined behavior.\n */\n#define PUT_BITS(code, size) { \\\n  free_bits -= size; \\\n  if (free_bits < 0) \\\n    PUT_AND_FLUSH(code, size) \\\n  else \\\n    put_buffer = (put_buffer << size) | code; \\\n}\n\n#define PUT_CODE(code, size) { \\\n  temp &= (((JLONG)1) << nbits) - 1; \\\n  temp |= code << nbits; \\\n  nbits += size; \\\n  PUT_BITS(temp, nbits) \\\n}\n\n\n/* Although it is exceedingly rare, it is possible for a Huffman-encoded\n * coefficient block to be larger than the 128-byte unencoded block.  For each\n * of the 64 coefficients, PUT_BITS is invoked twice, and each invocation can\n * theoretically store 16 bits (for a maximum of 2048 bits or 256 bytes per\n * encoded block.)  If, for instance, one artificially sets the AC\n * coefficients to alternating values of 32767 and -32768 (using the JPEG\n * scanning order-- 1, 8, 16, etc.), then this will produce an encoded block\n * larger than 200 bytes.\n */\n#define BUFSIZE  (DCTSIZE2 * 8)\n\n#define LOAD_BUFFER() { \\\n  if (state->free_in_buffer < BUFSIZE) { \\\n    localbuf = 1; \\\n    buffer = _buffer; \\\n  } else \\\n    buffer = state->next_output_byte; \\\n}\n\n#define STORE_BUFFER() { \\\n  if (localbuf) { \\\n    size_t bytes, bytestocopy; \\\n    bytes = buffer - _buffer; \\\n    buffer = _buffer; \\\n    while (bytes > 0) { \\\n      bytestocopy = MIN(bytes, state->free_in_buffer); \\\n      memcpy(state->next_output_byte, buffer, bytestocopy); \\\n      state->next_output_byte += bytestocopy; \\\n      buffer += bytestocopy; \\\n      state->free_in_buffer -= bytestocopy; \\\n      if (state->free_in_buffer == 0) \\\n        if (!dump_buffer(state)) return FALSE; \\\n      bytes -= bytestocopy; \\\n    } \\\n  } else { \\\n    state->free_in_buffer -= (buffer - state->next_output_byte); \\\n    state->next_output_byte = buffer; \\\n  } \\\n}\n\n\nLOCAL(boolean)\nflush_bits(working_state *state)\n{\n  JOCTET _buffer[BUFSIZE], *buffer, temp;\n  simd_bit_buf_type put_buffer;  int put_bits;\n  int localbuf = 0;\n\n#ifdef WITH_SIMD\n  if (state->simd) {\n    if (state->cur.free_bits < 0)\n      ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);\n#if defined(__aarch64__) && !defined(NEON_INTRINSICS)\n    put_bits = state->cur.free_bits;\n#else\n    put_bits = SIMD_BIT_BUF_SIZE - state->cur.free_bits;\n#endif\n    put_buffer = state->cur.put_buffer.simd;\n  } else\n#endif\n  {\n    put_bits = BIT_BUF_SIZE - state->cur.free_bits;\n    put_buffer = state->cur.put_buffer.c;\n  }\n\n  LOAD_BUFFER()\n\n  while (put_bits >= 8) {\n    put_bits -= 8;\n    temp = (JOCTET)(put_buffer >> put_bits);\n    EMIT_BYTE(temp)\n  }\n  if (put_bits > 0) {\n    /* fill partial byte with ones */\n    temp = (JOCTET)((put_buffer << (8 - put_bits)) | (0xFF >> put_bits));\n    EMIT_BYTE(temp)\n  }\n\n#ifdef WITH_SIMD\n  if (state->simd) {                    /* and reset bit buffer to empty */\n    state->cur.put_buffer.simd = 0;\n#if defined(__aarch64__) && !defined(NEON_INTRINSICS)\n    state->cur.free_bits = 0;\n#else\n    state->cur.free_bits = SIMD_BIT_BUF_SIZE;\n#endif\n  } else\n#endif\n  {\n    state->cur.put_buffer.c = 0;\n    state->cur.free_bits = BIT_BUF_SIZE;\n  }\n  STORE_BUFFER()\n\n  return TRUE;\n}\n\n\n#ifdef WITH_SIMD\n\n/* Encode a single block's worth of coefficients */\n\nLOCAL(boolean)\nencode_one_block_simd(working_state *state, JCOEFPTR block, int last_dc_val,\n                      c_derived_tbl *dctbl, c_derived_tbl *actbl)\n{\n  JOCTET _buffer[BUFSIZE], *buffer;\n  int localbuf = 0;\n\n#ifdef ZERO_BUFFERS\n  memset(_buffer, 0, sizeof(_buffer));\n#endif\n\n  LOAD_BUFFER()\n\n  buffer = jsimd_huff_encode_one_block(state, buffer, block, last_dc_val,\n                                       dctbl, actbl);\n\n  STORE_BUFFER()\n\n  return TRUE;\n}\n\n#endif\n\nLOCAL(boolean)\nencode_one_block(working_state *state, JCOEFPTR block, int last_dc_val,\n                 c_derived_tbl *dctbl, c_derived_tbl *actbl)\n{\n  int temp, nbits, free_bits;\n  bit_buf_type put_buffer;\n  JOCTET _buffer[BUFSIZE], *buffer;\n  int localbuf = 0;\n  int max_coef_bits = state->cinfo->data_precision + 2;\n\n  free_bits = state->cur.free_bits;\n  put_buffer = state->cur.put_buffer.c;\n  LOAD_BUFFER()\n\n  /* Encode the DC coefficient difference per section F.1.2.1 */\n\n  temp = block[0] - last_dc_val;\n\n  /* This is a well-known technique for obtaining the absolute value without a\n   * branch.  It is derived from an assembly language technique presented in\n   * \"How to Optimize for the Pentium Processors\", Copyright (c) 1996, 1997 by\n   * Agner Fog.  This code assumes we are on a two's complement machine.\n   */\n  nbits = temp >> (CHAR_BIT * sizeof(int) - 1);\n  temp += nbits;\n  nbits ^= temp;\n\n  /* Find the number of bits needed for the magnitude of the coefficient */\n  nbits = JPEG_NBITS(nbits);\n  /* Check for out-of-range coefficient values.\n   * Since we're encoding a difference, the range limit is twice as much.\n   */\n  if (nbits > max_coef_bits + 1)\n    ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);\n\n  /* Emit the Huffman-coded symbol for the number of bits.\n   * Emit that number of bits of the value, if positive,\n   * or the complement of its magnitude, if negative.\n   */\n  PUT_CODE(dctbl->ehufco[nbits], dctbl->ehufsi[nbits])\n\n  /* Encode the AC coefficients per section F.1.2.2 */\n\n  {\n    int r = 0;                  /* r = run length of zeros */\n\n/* Manually unroll the k loop to eliminate the counter variable.  This\n * improves performance greatly on systems with a limited number of\n * registers (such as x86.)\n */\n#define kloop(jpeg_natural_order_of_k) { \\\n  if ((temp = block[jpeg_natural_order_of_k]) == 0) { \\\n    r += 16; \\\n  } else { \\\n    /* Branch-less absolute value, bitwise complement, etc., same as above */ \\\n    nbits = temp >> (CHAR_BIT * sizeof(int) - 1); \\\n    temp += nbits; \\\n    nbits ^= temp; \\\n    nbits = JPEG_NBITS_NONZERO(nbits); \\\n    /* Check for out-of-range coefficient values */ \\\n    if (nbits > max_coef_bits) \\\n      ERREXIT(state->cinfo, JERR_BAD_DCT_COEF); \\\n    /* if run length > 15, must emit special run-length-16 codes (0xF0) */ \\\n    while (r >= 16 * 16) { \\\n      r -= 16 * 16; \\\n      PUT_BITS(actbl->ehufco[0xf0], actbl->ehufsi[0xf0]) \\\n    } \\\n    /* Emit Huffman symbol for run length / number of bits */ \\\n    r += nbits; \\\n    PUT_CODE(actbl->ehufco[r], actbl->ehufsi[r]) \\\n    r = 0; \\\n  } \\\n}\n\n    /* One iteration for each value in jpeg_natural_order[] */\n    kloop(1);   kloop(8);   kloop(16);  kloop(9);   kloop(2);   kloop(3);\n    kloop(10);  kloop(17);  kloop(24);  kloop(32);  kloop(25);  kloop(18);\n    kloop(11);  kloop(4);   kloop(5);   kloop(12);  kloop(19);  kloop(26);\n    kloop(33);  kloop(40);  kloop(48);  kloop(41);  kloop(34);  kloop(27);\n    kloop(20);  kloop(13);  kloop(6);   kloop(7);   kloop(14);  kloop(21);\n    kloop(28);  kloop(35);  kloop(42);  kloop(49);  kloop(56);  kloop(57);\n    kloop(50);  kloop(43);  kloop(36);  kloop(29);  kloop(22);  kloop(15);\n    kloop(23);  kloop(30);  kloop(37);  kloop(44);  kloop(51);  kloop(58);\n    kloop(59);  kloop(52);  kloop(45);  kloop(38);  kloop(31);  kloop(39);\n    kloop(46);  kloop(53);  kloop(60);  kloop(61);  kloop(54);  kloop(47);\n    kloop(55);  kloop(62);  kloop(63);\n\n    /* If the last coef(s) were zero, emit an end-of-block code */\n    if (r > 0) {\n      PUT_BITS(actbl->ehufco[0], actbl->ehufsi[0])\n    }\n  }\n\n  state->cur.put_buffer.c = put_buffer;\n  state->cur.free_bits = free_bits;\n  STORE_BUFFER()\n\n  return TRUE;\n}\n\n\n/*\n * Emit a restart marker & resynchronize predictions.\n */\n\nLOCAL(boolean)\nemit_restart(working_state *state, int restart_num)\n{\n  int ci;\n\n  if (!flush_bits(state))\n    return FALSE;\n\n  emit_byte(state, 0xFF, return FALSE);\n  emit_byte(state, JPEG_RST0 + restart_num, return FALSE);\n\n  /* Re-initialize DC predictions to 0 */\n  for (ci = 0; ci < state->cinfo->comps_in_scan; ci++)\n    state->cur.last_dc_val[ci] = 0;\n\n  /* The restart counter is not updated until we successfully write the MCU. */\n\n  return TRUE;\n}\n\n\n/*\n * Encode and output one MCU's worth of Huffman-compressed coefficients.\n */\n\nMETHODDEF(boolean)\nencode_mcu_huff(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  working_state state;\n  int blkn, ci;\n  jpeg_component_info *compptr;\n\n  /* Load up working state */\n  state.next_output_byte = cinfo->dest->next_output_byte;\n  state.free_in_buffer = cinfo->dest->free_in_buffer;\n  state.cur = entropy->saved;\n  state.cinfo = cinfo;\n#ifdef WITH_SIMD\n  state.simd = entropy->simd;\n#endif\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (!emit_restart(&state, entropy->next_restart_num))\n        return FALSE;\n  }\n\n  /* Encode the MCU data blocks */\n#ifdef WITH_SIMD\n  if (entropy->simd) {\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n      ci = cinfo->MCU_membership[blkn];\n      compptr = cinfo->cur_comp_info[ci];\n      if (!encode_one_block_simd(&state,\n                                 MCU_data[blkn][0], state.cur.last_dc_val[ci],\n                                 entropy->dc_derived_tbls[compptr->dc_tbl_no],\n                                 entropy->ac_derived_tbls[compptr->ac_tbl_no]))\n        return FALSE;\n      /* Update last_dc_val */\n      state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];\n    }\n  } else\n#endif\n  {\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n      ci = cinfo->MCU_membership[blkn];\n      compptr = cinfo->cur_comp_info[ci];\n      if (!encode_one_block(&state,\n                            MCU_data[blkn][0], state.cur.last_dc_val[ci],\n                            entropy->dc_derived_tbls[compptr->dc_tbl_no],\n                            entropy->ac_derived_tbls[compptr->ac_tbl_no]))\n        return FALSE;\n      /* Update last_dc_val */\n      state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];\n    }\n  }\n\n  /* Completed MCU, so update state */\n  cinfo->dest->next_output_byte = state.next_output_byte;\n  cinfo->dest->free_in_buffer = state.free_in_buffer;\n  entropy->saved = state.cur;\n\n  /* Update restart-interval state too */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Finish up at the end of a Huffman-compressed scan.\n */\n\nMETHODDEF(void)\nfinish_pass_huff(j_compress_ptr cinfo)\n{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  working_state state;\n\n  /* Load up working state ... flush_bits needs it */\n  state.next_output_byte = cinfo->dest->next_output_byte;\n  state.free_in_buffer = cinfo->dest->free_in_buffer;\n  state.cur = entropy->saved;\n  state.cinfo = cinfo;\n#ifdef WITH_SIMD\n  state.simd = entropy->simd;\n#endif\n\n  /* Flush out the last data */\n  if (!flush_bits(&state))\n    ERREXIT(cinfo, JERR_CANT_SUSPEND);\n\n  /* Update state */\n  cinfo->dest->next_output_byte = state.next_output_byte;\n  cinfo->dest->free_in_buffer = state.free_in_buffer;\n  entropy->saved = state.cur;\n}\n\n\n/*\n * Huffman coding optimization.\n *\n * We first scan the supplied data and count the number of uses of each symbol\n * that is to be Huffman-coded. (This process MUST agree with the code above.)\n * Then we build a Huffman coding tree for the observed counts.\n * Symbols which are not needed at all for the particular image are not\n * assigned any code, which saves space in the DHT marker as well as in\n * the compressed data.\n */\n\n#ifdef ENTROPY_OPT_SUPPORTED\n\n\n/* Process a single block's worth of coefficients */\n\nLOCAL(void)\nhtest_one_block(j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,\n                long dc_counts[], long ac_counts[])\n{\n  register int temp;\n  register int nbits;\n  register int k, r;\n  int max_coef_bits = cinfo->data_precision + 2;\n\n  /* Encode the DC coefficient difference per section F.1.2.1 */\n\n  temp = block[0] - last_dc_val;\n  if (temp < 0)\n    temp = -temp;\n\n  /* Find the number of bits needed for the magnitude of the coefficient */\n  nbits = 0;\n  while (temp) {\n    nbits++;\n    temp >>= 1;\n  }\n  /* Check for out-of-range coefficient values.\n   * Since we're encoding a difference, the range limit is twice as much.\n   */\n  if (nbits > max_coef_bits + 1)\n    ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n\n  /* Count the Huffman symbol for the number of bits */\n  dc_counts[nbits]++;\n\n  /* Encode the AC coefficients per section F.1.2.2 */\n\n  r = 0;                        /* r = run length of zeros */\n\n  for (k = 1; k < DCTSIZE2; k++) {\n    if ((temp = block[jpeg_natural_order[k]]) == 0) {\n      r++;\n    } else {\n      /* if run length > 15, must emit special run-length-16 codes (0xF0) */\n      while (r > 15) {\n        ac_counts[0xF0]++;\n        r -= 16;\n      }\n\n      /* Find the number of bits needed for the magnitude of the coefficient */\n      if (temp < 0)\n        temp = -temp;\n\n      /* Find the number of bits needed for the magnitude of the coefficient */\n      nbits = 1;                /* there must be at least one 1 bit */\n      while ((temp >>= 1))\n        nbits++;\n      /* Check for out-of-range coefficient values */\n      if (nbits > max_coef_bits)\n        ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n\n      /* Count Huffman symbol for run length / number of bits */\n      ac_counts[(r << 4) + nbits]++;\n\n      r = 0;\n    }\n  }\n\n  /* If the last coef(s) were zero, emit an end-of-block code */\n  if (r > 0)\n    ac_counts[0]++;\n}\n\n\n/*\n * Trial-encode one MCU's worth of Huffman-compressed coefficients.\n * No data is actually output, so no suspension return is possible.\n */\n\nMETHODDEF(boolean)\nencode_mcu_gather(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  int blkn, ci;\n  jpeg_component_info *compptr;\n\n  /* Take care of restart intervals if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      /* Re-initialize DC predictions to 0 */\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++)\n        entropy->saved.last_dc_val[ci] = 0;\n      /* Update restart state */\n      entropy->restarts_to_go = cinfo->restart_interval;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    ci = cinfo->MCU_membership[blkn];\n    compptr = cinfo->cur_comp_info[ci];\n    htest_one_block(cinfo, MCU_data[blkn][0], entropy->saved.last_dc_val[ci],\n                    entropy->dc_count_ptrs[compptr->dc_tbl_no],\n                    entropy->ac_count_ptrs[compptr->ac_tbl_no]);\n    entropy->saved.last_dc_val[ci] = MCU_data[blkn][0][0];\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Generate the best Huffman code table for the given counts, fill htbl.\n * Note this is also used by jcphuff.c and jclhuff.c.\n *\n * The JPEG standard requires that no symbol be assigned a codeword of all\n * one bits (so that padding bits added at the end of a compressed segment\n * can't look like a valid code).  Because of the canonical ordering of\n * codewords, this just means that there must be an unused slot in the\n * longest codeword length category.  Annex K (Clause K.2) of\n * Rec. ITU-T T.81 (1992) | ISO/IEC 10918-1:1994 suggests reserving such a slot\n * by pretending that symbol 256 is a valid symbol with count 1.  In theory\n * that's not optimal; giving it count zero but including it in the symbol set\n * anyway should give a better Huffman code.  But the theoretically better code\n * actually seems to come out worse in practice, because it produces more\n * all-ones bytes (which incur stuffed zero bytes in the final file).  In any\n * case the difference is tiny.\n *\n * The JPEG standard requires Huffman codes to be no more than 16 bits long.\n * If some symbols have a very small but nonzero probability, the Huffman tree\n * must be adjusted to meet the code length restriction.  We currently use\n * the adjustment method suggested in JPEG section K.2.  This method is *not*\n * optimal; it may not choose the best possible limited-length code.  But\n * typically only very-low-frequency symbols will be given less-than-optimal\n * lengths, so the code is almost optimal.  Experimental comparisons against\n * an optimal limited-length-code algorithm indicate that the difference is\n * microscopic --- usually less than a hundredth of a percent of total size.\n * So the extra complexity of an optimal algorithm doesn't seem worthwhile.\n */\n\nGLOBAL(void)\njpeg_gen_optimal_table(j_compress_ptr cinfo, JHUFF_TBL *htbl, long freq[])\n{\n#define MAX_CLEN  32            /* assumed maximum initial code length */\n  UINT8 bits[MAX_CLEN + 1];     /* bits[k] = # of symbols with code length k */\n  int bit_pos[MAX_CLEN + 1];    /* # of symbols with smaller code length */\n  int codesize[257];            /* codesize[k] = code length of symbol k */\n  int nz_index[257];            /* index of nonzero symbol in the original freq\n                                   array */\n  int others[257];              /* next symbol in current branch of tree */\n  int c1, c2;\n  int p, i, j;\n  int num_nz_symbols;\n  long v, v2;\n\n  /* This algorithm is explained in section K.2 of the JPEG standard */\n\n  memset(bits, 0, sizeof(bits));\n  memset(codesize, 0, sizeof(codesize));\n  for (i = 0; i < 257; i++)\n    others[i] = -1;             /* init links to empty */\n\n  freq[256] = 1;                /* make sure 256 has a nonzero count */\n  /* Including the pseudo-symbol 256 in the Huffman procedure guarantees\n   * that no real symbol is given code-value of all ones, because 256\n   * will be placed last in the largest codeword category.\n   */\n\n  /* Group nonzero frequencies together so we can more easily find the\n   * smallest.\n   */\n  num_nz_symbols = 0;\n  for (i = 0; i < 257; i++) {\n    if (freq[i]) {\n      nz_index[num_nz_symbols] = i;\n      freq[num_nz_symbols] = freq[i];\n      num_nz_symbols++;\n    }\n  }\n\n  /* Huffman's basic algorithm to assign optimal code lengths to symbols */\n\n  for (;;) {\n    /* Find the two smallest nonzero frequencies; set c1, c2 = their symbols */\n    /* In case of ties, take the larger symbol number.  Since we have grouped\n     * the nonzero symbols together, checking for zero symbols is not\n     * necessary.\n     */\n    c1 = -1;\n    c2 = -1;\n    v = 1000000000L;\n    v2 = 1000000000L;\n    for (i = 0; i < num_nz_symbols; i++) {\n      if (freq[i] <= v2) {\n        if (freq[i] <= v) {\n          c2 = c1;\n          v2 = v;\n          v = freq[i];\n          c1 = i;\n        } else {\n          v2 = freq[i];\n          c2 = i;\n        }\n      }\n    }\n\n    /* Done if we've merged everything into one frequency */\n    if (c2 < 0)\n      break;\n\n    /* Else merge the two counts/trees */\n    freq[c1] += freq[c2];\n    /* Set the frequency to a very high value instead of zero, so we don't have\n     * to check for zero values.\n     */\n    freq[c2] = 1000000001L;\n\n    /* Increment the codesize of everything in c1's tree branch */\n    codesize[c1]++;\n    while (others[c1] >= 0) {\n      c1 = others[c1];\n      codesize[c1]++;\n    }\n\n    others[c1] = c2;            /* chain c2 onto c1's tree branch */\n\n    /* Increment the codesize of everything in c2's tree branch */\n    codesize[c2]++;\n    while (others[c2] >= 0) {\n      c2 = others[c2];\n      codesize[c2]++;\n    }\n  }\n\n  /* Now count the number of symbols of each code length */\n  for (i = 0; i < num_nz_symbols; i++) {\n    /* The JPEG standard seems to think that this can't happen, */\n    /* but I'm paranoid... */\n    if (codesize[i] > MAX_CLEN)\n      ERREXIT(cinfo, JERR_HUFF_CLEN_OVERFLOW);\n\n    bits[codesize[i]]++;\n  }\n\n  /* Count the number of symbols with a length smaller than i bits, so we can\n   * construct the symbol table more efficiently.  Note that this includes the\n   * pseudo-symbol 256, but since it is the last symbol, it will not affect the\n   * table.\n   */\n  p = 0;\n  for (i = 1; i <= MAX_CLEN; i++) {\n    bit_pos[i] = p;\n    p += bits[i];\n  }\n\n  /* JPEG doesn't allow symbols with code lengths over 16 bits, so if the pure\n   * Huffman procedure assigned any such lengths, we must adjust the coding.\n   * Here is what Rec. ITU-T T.81 | ISO/IEC 10918-1 says about how this next\n   * bit works: Since symbols are paired for the longest Huffman code, the\n   * symbols are removed from this length category two at a time.  The prefix\n   * for the pair (which is one bit shorter) is allocated to one of the pair;\n   * then, skipping the BITS entry for that prefix length, a code word from the\n   * next shortest nonzero BITS entry is converted into a prefix for two code\n   * words one bit longer.\n   */\n\n  for (i = MAX_CLEN; i > 16; i--) {\n    while (bits[i] > 0) {\n      j = i - 2;                /* find length of new prefix to be used */\n      while (bits[j] == 0)\n        j--;\n\n      bits[i] -= 2;             /* remove two symbols */\n      bits[i - 1]++;            /* one goes in this length */\n      bits[j + 1] += 2;         /* two new symbols in this length */\n      bits[j]--;                /* symbol of this length is now a prefix */\n    }\n  }\n\n  /* Remove the count for the pseudo-symbol 256 from the largest codelength */\n  while (bits[i] == 0)          /* find largest codelength still in use */\n    i--;\n  bits[i]--;\n\n  /* Return final symbol counts (only for lengths 0..16) */\n  memcpy(htbl->bits, bits, sizeof(htbl->bits));\n\n  /* Return a list of the symbols sorted by code length */\n  /* It's not real clear to me why we don't need to consider the codelength\n   * changes made above, but Rec. ITU-T T.81 | ISO/IEC 10918-1 seems to think\n   * this works.\n   */\n  for (i = 0; i < num_nz_symbols - 1; i++) {\n    htbl->huffval[bit_pos[codesize[i]]] = (UINT8)nz_index[i];\n    bit_pos[codesize[i]]++;\n  }\n\n  /* Set sent_table FALSE so updated table will be written to JPEG file. */\n  htbl->sent_table = FALSE;\n}\n\n\n/*\n * Finish up a statistics-gathering pass and create the new Huffman tables.\n */\n\nMETHODDEF(void)\nfinish_pass_gather(j_compress_ptr cinfo)\n{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  int ci, dctbl, actbl;\n  jpeg_component_info *compptr;\n  JHUFF_TBL **htblptr;\n  boolean did_dc[NUM_HUFF_TBLS];\n  boolean did_ac[NUM_HUFF_TBLS];\n\n  /* It's important not to apply jpeg_gen_optimal_table more than once\n   * per table, because it clobbers the input frequency counts!\n   */\n  memset(did_dc, 0, sizeof(did_dc));\n  memset(did_ac, 0, sizeof(did_ac));\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    dctbl = compptr->dc_tbl_no;\n    actbl = compptr->ac_tbl_no;\n    if (!did_dc[dctbl]) {\n      htblptr = &cinfo->dc_huff_tbl_ptrs[dctbl];\n      if (*htblptr == NULL)\n        *htblptr = jpeg_alloc_huff_table((j_common_ptr)cinfo);\n      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);\n      did_dc[dctbl] = TRUE;\n    }\n    if (!did_ac[actbl]) {\n      htblptr = &cinfo->ac_huff_tbl_ptrs[actbl];\n      if (*htblptr == NULL)\n        *htblptr = jpeg_alloc_huff_table((j_common_ptr)cinfo);\n      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);\n      did_ac[actbl] = TRUE;\n    }\n  }\n}\n\n\n#endif /* ENTROPY_OPT_SUPPORTED */\n\n\n/*\n * Module initialization routine for Huffman entropy encoding.\n */\n\nGLOBAL(void)\njinit_huff_encoder(j_compress_ptr cinfo)\n{\n  huff_entropy_ptr entropy;\n  int i;\n\n  entropy = (huff_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(huff_entropy_encoder));\n  cinfo->entropy = (struct jpeg_entropy_encoder *)entropy;\n  entropy->pub.start_pass = start_pass_huff;\n\n  /* Mark tables unallocated */\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;\n#ifdef ENTROPY_OPT_SUPPORTED\n    entropy->dc_count_ptrs[i] = entropy->ac_count_ptrs[i] = NULL;\n#endif\n  }\n}\n"
        },
        {
          "name": "jchuff.h",
          "type": "blob",
          "size": 2.0791015625,
          "content": "/*\n * jchuff.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n * Copyright (C) 2014, Mozilla Corporation.\n *\n * This file contains declarations for Huffman entropy encoding routines\n * that are shared between the sequential encoder (jchuff.c) and the\n * progressive encoder (jcphuff.c).  No other modules need to see these.\n */\n\n/* The legal range of a DCT coefficient is\n *  -1024 .. +1023  for 8-bit data;\n * -16384 .. +16383 for 12-bit data.\n * Hence the magnitude should always fit in 10 or 14 bits respectively.\n */\n\n/* The progressive Huffman encoder uses an unsigned 16-bit data type to store\n * absolute values of coefficients, because it is possible to inject a\n * coefficient value of -32768 into the encoder by attempting to transform a\n * malformed 12-bit JPEG image, and the absolute value of -32768 would overflow\n * a signed 16-bit integer.\n */\ntypedef unsigned short UJCOEF;\n\n/* Derived data constructed for each Huffman table */\n\ntypedef struct {\n  unsigned int ehufco[256];     /* code for each symbol */\n  char ehufsi[256];             /* length of code for each symbol */\n  /* If no code has been allocated for a symbol S, ehufsi[S] contains 0 */\n} c_derived_tbl;\n\n/* Expand a Huffman table definition into the derived format */\nEXTERN(void) jpeg_make_c_derived_tbl(j_compress_ptr cinfo, boolean isDC,\n                                     int tblno, c_derived_tbl **pdtbl);\n\n/* Generate an optimal table definition given the specified counts */\nEXTERN(void) quantize_trellis\n        (j_compress_ptr cinfo, c_derived_tbl *dctbl, c_derived_tbl *actbl, JBLOCKROW coef_blocks, JBLOCKROW src, JDIMENSION num_blocks,\n                 JQUANT_TBL * qtbl, double *norm_src, double *norm_coef, JCOEF *last_dc_val,\n         JBLOCKROW coef_blocks_above, JBLOCKROW src_above);\nEXTERN(void) jpeg_gen_optimal_table(j_compress_ptr cinfo, JHUFF_TBL *htbl,\n                                    long freq[]);\n"
        },
        {
          "name": "jcicc.c",
          "type": "blob",
          "size": 3.9765625,
          "content": "/*\n * jcicc.c\n *\n * Copyright (C) 1997-1998, Thomas G. Lane, Todd Newman.\n * Copyright (C) 2017, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file provides code to write International Color Consortium (ICC) device\n * profiles embedded in JFIF JPEG image files.  The ICC has defined a standard\n * for including such data in JPEG \"APP2\" markers.  The code given here does\n * not know anything about the internal structure of the ICC profile data; it\n * just knows how to embed the profile data in a JPEG file while writing it.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n\n\n/*\n * Since an ICC profile can be larger than the maximum size of a JPEG marker\n * (64K), we need provisions to split it into multiple markers.  The format\n * defined by the ICC specifies one or more APP2 markers containing the\n * following data:\n *      Identifying string      ASCII \"ICC_PROFILE\\0\"  (12 bytes)\n *      Marker sequence number  1 for first APP2, 2 for next, etc (1 byte)\n *      Number of markers       Total number of APP2's used (1 byte)\n *      Profile data            (remainder of APP2 data)\n * Decoders should use the marker sequence numbers to reassemble the profile,\n * rather than assuming that the APP2 markers appear in the correct sequence.\n */\n\n#define ICC_MARKER  (JPEG_APP0 + 2)     /* JPEG marker code for ICC */\n#define ICC_OVERHEAD_LEN  14            /* size of non-profile data in APP2 */\n#define MAX_BYTES_IN_MARKER  65533      /* maximum data len of a JPEG marker */\n#define MAX_DATA_BYTES_IN_MARKER  (MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN)\n\n\n/*\n * This routine writes the given ICC profile data into a JPEG file.  It *must*\n * be called AFTER calling jpeg_start_compress() and BEFORE the first call to\n * jpeg_write_scanlines().  (This ordering ensures that the APP2 marker(s) will\n * appear after the SOI and JFIF or Adobe markers, but before all else.)\n */\n\nGLOBAL(void)\njpeg_write_icc_profile(j_compress_ptr cinfo, const JOCTET *icc_data_ptr,\n                       unsigned int icc_data_len)\n{\n  unsigned int num_markers;     /* total number of markers we'll write */\n  int cur_marker = 1;           /* per spec, counting starts at 1 */\n  unsigned int length;          /* number of bytes to write in this marker */\n\n  if (icc_data_ptr == NULL || icc_data_len == 0)\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  if (cinfo->global_state < CSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Calculate the number of markers we'll need, rounding up of course */\n  num_markers = icc_data_len / MAX_DATA_BYTES_IN_MARKER;\n  if (num_markers * MAX_DATA_BYTES_IN_MARKER != icc_data_len)\n    num_markers++;\n\n  while (icc_data_len > 0) {\n    /* length of profile to put in this marker */\n    length = icc_data_len;\n    if (length > MAX_DATA_BYTES_IN_MARKER)\n      length = MAX_DATA_BYTES_IN_MARKER;\n    icc_data_len -= length;\n\n    /* Write the JPEG marker header (APP2 code and marker length) */\n    jpeg_write_m_header(cinfo, ICC_MARKER,\n                        (unsigned int)(length + ICC_OVERHEAD_LEN));\n\n    /* Write the marker identifying string \"ICC_PROFILE\" (null-terminated).  We\n     * code it in this less-than-transparent way so that the code works even if\n     * the local character set is not ASCII.\n     */\n    jpeg_write_m_byte(cinfo, 0x49);\n    jpeg_write_m_byte(cinfo, 0x43);\n    jpeg_write_m_byte(cinfo, 0x43);\n    jpeg_write_m_byte(cinfo, 0x5F);\n    jpeg_write_m_byte(cinfo, 0x50);\n    jpeg_write_m_byte(cinfo, 0x52);\n    jpeg_write_m_byte(cinfo, 0x4F);\n    jpeg_write_m_byte(cinfo, 0x46);\n    jpeg_write_m_byte(cinfo, 0x49);\n    jpeg_write_m_byte(cinfo, 0x4C);\n    jpeg_write_m_byte(cinfo, 0x45);\n    jpeg_write_m_byte(cinfo, 0x0);\n\n    /* Add the sequencing info */\n    jpeg_write_m_byte(cinfo, cur_marker);\n    jpeg_write_m_byte(cinfo, (int)num_markers);\n\n    /* Add the profile data */\n    while (length--) {\n      jpeg_write_m_byte(cinfo, *icc_data_ptr);\n      icc_data_ptr++;\n    }\n    cur_marker++;\n  }\n}\n"
        },
        {
          "name": "jcinit.c",
          "type": "blob",
          "size": 5.1396484375,
          "content": "/*\n * jcinit.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2020, 2022, D. R. Commander.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains initialization logic for the JPEG compressor.\n * This routine is in charge of selecting the modules to be executed and\n * making an initialization call to each one.\n *\n * Logically, this code belongs in jcmaster.c.  It's split out because\n * linking this routine implies linking the entire compression library.\n * For a transcoding-only application, we want to be able to use jcmaster.c\n * without linking in the whole library.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jpegapicomp.h\"\n\n\n/*\n * Master selection of compression modules.\n * This is done once at the start of processing an image.  We determine\n * which modules will be used and give them appropriate initialization calls.\n */\n\nGLOBAL(void)\njinit_compress_master(j_compress_ptr cinfo)\n{\n  /* Initialize master control (includes parameter checking/processing) */\n  jinit_c_master_control(cinfo, FALSE /* full compression */);\n\n  /* Preprocessing */\n  if (!cinfo->raw_data_in) {\n    if (cinfo->data_precision == 16) {\n#ifdef C_LOSSLESS_SUPPORTED\n      j16init_color_converter(cinfo);\n      j16init_downsampler(cinfo);\n      j16init_c_prep_controller(cinfo,\n                                FALSE /* never need full buffer here */);\n#else\n      ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n#endif\n    } else if (cinfo->data_precision == 12) {\n      j12init_color_converter(cinfo);\n      j12init_downsampler(cinfo);\n      j12init_c_prep_controller(cinfo,\n                                FALSE /* never need full buffer here */);\n    } else {\n      jinit_color_converter(cinfo);\n      jinit_downsampler(cinfo);\n      jinit_c_prep_controller(cinfo, FALSE /* never need full buffer here */);\n    }\n  }\n\n  if (cinfo->master->lossless) {\n#ifdef C_LOSSLESS_SUPPORTED\n    /* Prediction, sample differencing, and point transform */\n    if (cinfo->data_precision == 16)\n      j16init_lossless_compressor(cinfo);\n    else if (cinfo->data_precision == 12)\n      j12init_lossless_compressor(cinfo);\n    else\n      jinit_lossless_compressor(cinfo);\n    /* Entropy encoding: either Huffman or arithmetic coding. */\n    if (cinfo->arith_code) {\n      ERREXIT(cinfo, JERR_ARITH_NOTIMPL);\n    } else {\n      jinit_lhuff_encoder(cinfo);\n    }\n\n    /* Need a full-image difference buffer in any multi-pass mode. */\n    if (cinfo->data_precision == 16)\n      j16init_c_diff_controller(cinfo, (boolean)(cinfo->num_scans > 1 ||\n                                                 cinfo->optimize_coding));\n    else if (cinfo->data_precision == 12)\n      j12init_c_diff_controller(cinfo, (boolean)(cinfo->num_scans > 1 ||\n                                                 cinfo->optimize_coding));\n    else\n      jinit_c_diff_controller(cinfo, (boolean)(cinfo->num_scans > 1 ||\n                                               cinfo->optimize_coding));\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    if (cinfo->data_precision == 16)\n      ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n    /* Forward DCT */\n    if (cinfo->data_precision == 12)\n      j12init_forward_dct(cinfo);\n    else\n      jinit_forward_dct(cinfo);\n    /* Entropy encoding: either Huffman or arithmetic coding. */\n    if (cinfo->arith_code) {\n#ifdef C_ARITH_CODING_SUPPORTED\n      jinit_arith_encoder(cinfo);\n#else\n      ERREXIT(cinfo, JERR_ARITH_NOTIMPL);\n#endif\n    } else {\n      if (cinfo->progressive_mode) {\n#ifdef C_PROGRESSIVE_SUPPORTED\n        jinit_phuff_encoder(cinfo);\n#else\n        ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n      } else\n        jinit_huff_encoder(cinfo);\n    }\n\n    /* Need a full-image coefficient buffer in any multi-pass mode. */\n    if (cinfo->data_precision == 12)\n      j12init_c_coef_controller(cinfo, (boolean)(cinfo->num_scans > 1 ||\n                                                 cinfo->optimize_coding));\n    else\n      jinit_c_coef_controller(cinfo, (boolean)(cinfo->num_scans > 1 || cinfo->optimize_coding ||\n               cinfo->master->optimize_scans || cinfo->master->trellis_quant));\n  }\n\n  if (cinfo->data_precision == 16)\n#ifdef C_LOSSLESS_SUPPORTED\n    j16init_c_main_controller(cinfo, FALSE /* never need full buffer here */);\n#else\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n#endif\n  else if (cinfo->data_precision == 12)\n    j12init_c_main_controller(cinfo, FALSE /* never need full buffer here */);\n  else\n    jinit_c_main_controller(cinfo, FALSE /* never need full buffer here */);\n\n  jinit_marker_writer(cinfo);\n\n  /* We can now tell the memory manager to allocate virtual arrays. */\n  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr)cinfo);\n\n  /* Write the datastream header (SOI) immediately.\n   * Frame and scan headers are postponed till later.\n   * This lets application insert special markers after the SOI.\n   */\n  (*cinfo->marker->write_file_header) (cinfo);\n}\n"
        },
        {
          "name": "jclhuff.c",
          "type": "blob",
          "size": 18.1982421875,
          "content": "/*\n * jclhuff.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains Huffman entropy encoding routines for lossless JPEG.\n *\n * Much of the complexity here has to do with supporting output suspension.\n * If the data destination module demands suspension, we want to be able to\n * back up to the start of the current MCU.  To do this, we copy state\n * variables into local working storage, and update them back to the\n * permanent JPEG objects only upon successful completion of an MCU.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jlossls.h\"            /* Private declarations for lossless codec */\n#include \"jchuff.h\"             /* Declarations shared with jc*huff.c */\n\n\n#ifdef C_LOSSLESS_SUPPORTED\n\n/* The legal range of a spatial difference is\n * -32767 .. +32768.\n * Hence the magnitude should always fit in 16 bits.\n */\n\n#define MAX_DIFF_BITS  16\n\n\n/* Expanded entropy encoder object for Huffman encoding in lossless mode.\n *\n * The savable_state subrecord contains fields that change within an MCU,\n * but must not be updated permanently until we complete the MCU.\n */\n\ntypedef struct {\n  size_t put_buffer;            /* current bit-accumulation buffer */\n  int put_bits;                 /* # of bits now in it */\n} savable_state;\n\n\ntypedef struct {\n  int ci, yoffset, MCU_width;\n} lhe_input_ptr_info;\n\n\ntypedef struct {\n  struct jpeg_entropy_encoder pub; /* public fields */\n\n  savable_state saved;          /* Bit buffer at start of MCU */\n\n  /* These fields are NOT loaded into local working state. */\n  unsigned int restarts_to_go;  /* MCUs left in this restart interval */\n  int next_restart_num;         /* next restart number to write (0-7) */\n\n  /* Pointers to derived tables (these workspaces have image lifespan) */\n  c_derived_tbl *derived_tbls[NUM_HUFF_TBLS];\n\n  /* Pointers to derived tables to be used for each data unit within an MCU */\n  c_derived_tbl *cur_tbls[C_MAX_BLOCKS_IN_MCU];\n\n#ifdef ENTROPY_OPT_SUPPORTED    /* Statistics tables for optimization */\n  long *count_ptrs[NUM_HUFF_TBLS];\n\n  /* Pointers to stats tables to be used for each data unit within an MCU */\n  long *cur_counts[C_MAX_BLOCKS_IN_MCU];\n#endif\n\n  /* Pointers to the proper input difference row for each group of data units\n   * within an MCU.  For each component, there are Vi groups of Hi data units.\n   */\n  JDIFFROW input_ptr[C_MAX_BLOCKS_IN_MCU];\n\n  /* Number of input pointers in use for the current MCU.  This is the sum\n   * of all Vi in the MCU.\n   */\n  int num_input_ptrs;\n\n  /* Information used for positioning the input pointers within the input\n   * difference rows.\n   */\n  lhe_input_ptr_info input_ptr_info[C_MAX_BLOCKS_IN_MCU];\n\n  /* Index of the proper input pointer for each data unit within an MCU */\n  int input_ptr_index[C_MAX_BLOCKS_IN_MCU];\n\n} lhuff_entropy_encoder;\n\ntypedef lhuff_entropy_encoder *lhuff_entropy_ptr;\n\n/* Working state while writing an MCU.\n * This struct contains all the fields that are needed by subroutines.\n */\n\ntypedef struct {\n  JOCTET *next_output_byte;     /* => next byte to write in buffer */\n  size_t free_in_buffer;        /* # of byte spaces remaining in buffer */\n  savable_state cur;            /* Current bit buffer & DC state */\n  j_compress_ptr cinfo;         /* dump_buffer needs access to this */\n} working_state;\n\n\n/* Forward declarations */\nMETHODDEF(JDIMENSION) encode_mcus_huff(j_compress_ptr cinfo,\n                                       JDIFFIMAGE diff_buf,\n                                       JDIMENSION MCU_row_num,\n                                       JDIMENSION MCU_col_num,\n                                       JDIMENSION nMCU);\nMETHODDEF(void) finish_pass_huff(j_compress_ptr cinfo);\n#ifdef ENTROPY_OPT_SUPPORTED\nMETHODDEF(JDIMENSION) encode_mcus_gather(j_compress_ptr cinfo,\n                                         JDIFFIMAGE diff_buf,\n                                         JDIMENSION MCU_row_num,\n                                         JDIMENSION MCU_col_num,\n                                         JDIMENSION nMCU);\nMETHODDEF(void) finish_pass_gather(j_compress_ptr cinfo);\n#endif\n\n\n/*\n * Initialize for a Huffman-compressed scan.\n * If gather_statistics is TRUE, we do not output anything during the scan,\n * just count the Huffman symbols used and generate Huffman code tables.\n */\n\nMETHODDEF(void)\nstart_pass_lhuff(j_compress_ptr cinfo, boolean gather_statistics)\n{\n  lhuff_entropy_ptr entropy = (lhuff_entropy_ptr)cinfo->entropy;\n  int ci, dctbl, sampn, ptrn, yoffset, xoffset;\n  jpeg_component_info *compptr;\n\n  if (gather_statistics) {\n#ifdef ENTROPY_OPT_SUPPORTED\n    entropy->pub.encode_mcus = encode_mcus_gather;\n    entropy->pub.finish_pass = finish_pass_gather;\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    entropy->pub.encode_mcus = encode_mcus_huff;\n    entropy->pub.finish_pass = finish_pass_huff;\n  }\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    dctbl = compptr->dc_tbl_no;\n    if (gather_statistics) {\n#ifdef ENTROPY_OPT_SUPPORTED\n      /* Check for invalid table indexes */\n      /* (make_c_derived_tbl does this in the other path) */\n      if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS)\n        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);\n      /* Allocate and zero the statistics tables */\n      /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */\n      if (entropy->count_ptrs[dctbl] == NULL)\n        entropy->count_ptrs[dctbl] = (long *)\n          (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                      257 * sizeof(long));\n      memset(entropy->count_ptrs[dctbl], 0, 257 * sizeof(long));\n#endif\n    } else {\n      /* Compute derived values for Huffman tables */\n      /* We may do this more than once for a table, but it's not expensive */\n      jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,\n                              &entropy->derived_tbls[dctbl]);\n    }\n  }\n\n  /* Precalculate encoding info for each sample in an MCU of this scan */\n  for (sampn = 0, ptrn = 0; sampn < cinfo->blocks_in_MCU;) {\n    compptr = cinfo->cur_comp_info[cinfo->MCU_membership[sampn]];\n    ci = compptr->component_index;\n    for (yoffset = 0; yoffset < compptr->MCU_height; yoffset++, ptrn++) {\n      /* Precalculate the setup info for each input pointer */\n      entropy->input_ptr_info[ptrn].ci = ci;\n      entropy->input_ptr_info[ptrn].yoffset = yoffset;\n      entropy->input_ptr_info[ptrn].MCU_width = compptr->MCU_width;\n      for (xoffset = 0; xoffset < compptr->MCU_width; xoffset++, sampn++) {\n        /* Precalculate the input pointer index for each sample */\n        entropy->input_ptr_index[sampn] = ptrn;\n        /* Precalculate which tables to use for each sample */\n        entropy->cur_tbls[sampn] = entropy->derived_tbls[compptr->dc_tbl_no];\n        entropy->cur_counts[sampn] = entropy->count_ptrs[compptr->dc_tbl_no];\n      }\n    }\n  }\n  entropy->num_input_ptrs = ptrn;\n\n  /* Initialize bit buffer to empty */\n  entropy->saved.put_buffer = 0;\n  entropy->saved.put_bits = 0;\n\n  /* Initialize restart stuff */\n  entropy->restarts_to_go = cinfo->restart_interval;\n  entropy->next_restart_num = 0;\n}\n\n\n/* Outputting bytes to the file */\n\n/* Emit a byte, taking 'action' if must suspend. */\n#define emit_byte(state, val, action) { \\\n  *(state)->next_output_byte++ = (JOCTET)(val); \\\n  if (--(state)->free_in_buffer == 0) \\\n    if (!dump_buffer(state)) \\\n      { action; } \\\n}\n\n\nLOCAL(boolean)\ndump_buffer(working_state *state)\n/* Empty the output buffer; return TRUE if successful, FALSE if must suspend */\n{\n  struct jpeg_destination_mgr *dest = state->cinfo->dest;\n\n  if (!(*dest->empty_output_buffer) (state->cinfo))\n    return FALSE;\n  /* After a successful buffer dump, must reset buffer pointers */\n  state->next_output_byte = dest->next_output_byte;\n  state->free_in_buffer = dest->free_in_buffer;\n  return TRUE;\n}\n\n\n/* Outputting bits to the file */\n\n/* Only the right 24 bits of put_buffer are used; the valid bits are\n * left-justified in this part.  At most 16 bits can be passed to emit_bits\n * in one call, and we never retain more than 7 bits in put_buffer\n * between calls, so 24 bits are sufficient.\n */\n\nINLINE\nLOCAL(boolean)\nemit_bits(working_state *state, unsigned int code, int size)\n/* Emit some bits; return TRUE if successful, FALSE if must suspend */\n{\n  /* This routine is heavily used, so it's worth coding tightly. */\n  register size_t put_buffer = (size_t)code;\n  register int put_bits = state->cur.put_bits;\n\n  /* if size is 0, caller used an invalid Huffman table entry */\n  if (size == 0)\n    ERREXIT(state->cinfo, JERR_HUFF_MISSING_CODE);\n\n  put_buffer &= (((size_t)1) << size) - 1; /* mask off any extra bits in code */\n\n  put_bits += size;             /* new number of bits in buffer */\n\n  put_buffer <<= 24 - put_bits; /* align incoming bits */\n\n  put_buffer |= state->cur.put_buffer; /* and merge with old buffer contents */\n\n  while (put_bits >= 8) {\n    int c = (int)((put_buffer >> 16) & 0xFF);\n\n    emit_byte(state, c, return FALSE);\n    if (c == 0xFF) {            /* need to stuff a zero byte? */\n      emit_byte(state, 0, return FALSE);\n    }\n    put_buffer <<= 8;\n    put_bits -= 8;\n  }\n\n  state->cur.put_buffer = put_buffer; /* update state variables */\n  state->cur.put_bits = put_bits;\n\n  return TRUE;\n}\n\n\nLOCAL(boolean)\nflush_bits(working_state *state)\n{\n  if (!emit_bits(state, 0x7F, 7)) /* fill any partial byte with ones */\n    return FALSE;\n  state->cur.put_buffer = 0;    /* and reset bit-buffer to empty */\n  state->cur.put_bits = 0;\n  return TRUE;\n}\n\n\n/*\n * Emit a restart marker & resynchronize predictions.\n */\n\nLOCAL(boolean)\nemit_restart(working_state *state, int restart_num)\n{\n  if (!flush_bits(state))\n    return FALSE;\n\n  emit_byte(state, 0xFF, return FALSE);\n  emit_byte(state, JPEG_RST0 + restart_num, return FALSE);\n\n  /* The restart counter is not updated until we successfully write the MCU. */\n\n  return TRUE;\n}\n\n\n/*\n * Encode and output nMCU MCUs' worth of Huffman-compressed differences.\n */\n\nMETHODDEF(JDIMENSION)\nencode_mcus_huff(j_compress_ptr cinfo, JDIFFIMAGE diff_buf,\n                 JDIMENSION MCU_row_num, JDIMENSION MCU_col_num,\n                 JDIMENSION nMCU)\n{\n  lhuff_entropy_ptr entropy = (lhuff_entropy_ptr)cinfo->entropy;\n  working_state state;\n  int sampn, ci, yoffset, MCU_width, ptrn;\n  JDIMENSION mcu_num;\n\n  /* Load up working state */\n  state.next_output_byte = cinfo->dest->next_output_byte;\n  state.free_in_buffer = cinfo->dest->free_in_buffer;\n  state.cur = entropy->saved;\n  state.cinfo = cinfo;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (!emit_restart(&state, entropy->next_restart_num))\n        return 0;\n  }\n\n  /* Set input pointer locations based on MCU_col_num */\n  for (ptrn = 0; ptrn < entropy->num_input_ptrs; ptrn++) {\n    ci = entropy->input_ptr_info[ptrn].ci;\n    yoffset = entropy->input_ptr_info[ptrn].yoffset;\n    MCU_width = entropy->input_ptr_info[ptrn].MCU_width;\n    entropy->input_ptr[ptrn] =\n      diff_buf[ci][MCU_row_num + yoffset] + (MCU_col_num * MCU_width);\n  }\n\n  for (mcu_num = 0; mcu_num < nMCU; mcu_num++) {\n\n    /* Inner loop handles the samples in the MCU */\n    for (sampn = 0; sampn < cinfo->blocks_in_MCU; sampn++) {\n      register int temp, temp2;\n      register int nbits;\n      c_derived_tbl *dctbl = entropy->cur_tbls[sampn];\n\n      /* Encode the difference per section H.1.2.2 */\n\n      /* Input the sample difference */\n      temp = *entropy->input_ptr[entropy->input_ptr_index[sampn]]++;\n\n      if (temp & 0x8000) {      /* instead of temp < 0 */\n        temp = (-temp) & 0x7FFF; /* absolute value, mod 2^16 */\n        if (temp == 0)          /* special case: magnitude = 32768 */\n          temp2 = temp = 0x8000;\n        temp2 = ~temp;          /* one's complement of magnitude */\n      } else {\n        temp &= 0x7FFF;         /* abs value mod 2^16 */\n        temp2 = temp;           /* magnitude */\n      }\n\n      /* Find the number of bits needed for the magnitude of the difference */\n      nbits = 0;\n      while (temp) {\n        nbits++;\n        temp >>= 1;\n      }\n      /* Check for out-of-range difference values.\n       */\n      if (nbits > MAX_DIFF_BITS)\n        ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n\n      /* Emit the Huffman-coded symbol for the number of bits */\n      if (!emit_bits(&state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))\n        return mcu_num;\n\n      /* Emit that number of bits of the value, if positive, */\n      /* or the complement of its magnitude, if negative. */\n      if (nbits &&              /* emit_bits rejects calls with size 0 */\n          nbits != 16)          /* special case: no bits should be emitted */\n        if (!emit_bits(&state, (unsigned int)temp2, nbits))\n          return mcu_num;\n    }\n\n    /* Completed MCU, so update state */\n    cinfo->dest->next_output_byte = state.next_output_byte;\n    cinfo->dest->free_in_buffer = state.free_in_buffer;\n    entropy->saved = state.cur;\n\n    /* Update restart-interval state too */\n    if (cinfo->restart_interval) {\n      if (entropy->restarts_to_go == 0) {\n        entropy->restarts_to_go = cinfo->restart_interval;\n        entropy->next_restart_num++;\n        entropy->next_restart_num &= 7;\n      }\n      entropy->restarts_to_go--;\n    }\n\n  }\n\n  return nMCU;\n}\n\n\n/*\n * Finish up at the end of a Huffman-compressed scan.\n */\n\nMETHODDEF(void)\nfinish_pass_huff(j_compress_ptr cinfo)\n{\n  lhuff_entropy_ptr entropy = (lhuff_entropy_ptr)cinfo->entropy;\n  working_state state;\n\n  /* Load up working state ... flush_bits needs it */\n  state.next_output_byte = cinfo->dest->next_output_byte;\n  state.free_in_buffer = cinfo->dest->free_in_buffer;\n  state.cur = entropy->saved;\n  state.cinfo = cinfo;\n\n  /* Flush out the last data */\n  if (!flush_bits(&state))\n    ERREXIT(cinfo, JERR_CANT_SUSPEND);\n\n  /* Update state */\n  cinfo->dest->next_output_byte = state.next_output_byte;\n  cinfo->dest->free_in_buffer = state.free_in_buffer;\n  entropy->saved = state.cur;\n}\n\n\n/*\n * Huffman coding optimization.\n *\n * We first scan the supplied data and count the number of uses of each symbol\n * that is to be Huffman-coded. (This process MUST agree with the code above.)\n * Then we build a Huffman coding tree for the observed counts.\n * Symbols which are not needed at all for the particular image are not\n * assigned any code, which saves space in the DHT marker as well as in\n * the compressed data.\n */\n\n#ifdef ENTROPY_OPT_SUPPORTED\n\n/*\n * Trial-encode nMCU MCUs' worth of Huffman-compressed differences.\n * No data is actually output, so no suspension return is possible.\n */\n\nMETHODDEF(JDIMENSION)\nencode_mcus_gather(j_compress_ptr cinfo, JDIFFIMAGE diff_buf,\n                   JDIMENSION MCU_row_num, JDIMENSION MCU_col_num,\n                   JDIMENSION nMCU)\n{\n  lhuff_entropy_ptr entropy = (lhuff_entropy_ptr)cinfo->entropy;\n  int sampn, ci, yoffset, MCU_width, ptrn;\n  JDIMENSION mcu_num;\n\n  /* Take care of restart intervals if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      /* Update restart state */\n      entropy->restarts_to_go = cinfo->restart_interval;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  /* Set input pointer locations based on MCU_col_num */\n  for (ptrn = 0; ptrn < entropy->num_input_ptrs; ptrn++) {\n    ci = entropy->input_ptr_info[ptrn].ci;\n    yoffset = entropy->input_ptr_info[ptrn].yoffset;\n    MCU_width = entropy->input_ptr_info[ptrn].MCU_width;\n    entropy->input_ptr[ptrn] =\n      diff_buf[ci][MCU_row_num + yoffset] + (MCU_col_num * MCU_width);\n  }\n\n  for (mcu_num = 0; mcu_num < nMCU; mcu_num++) {\n\n    /* Inner loop handles the samples in the MCU */\n    for (sampn = 0; sampn < cinfo->blocks_in_MCU; sampn++) {\n      register int temp;\n      register int nbits;\n      long *counts = entropy->cur_counts[sampn];\n\n      /* Encode the difference per section H.1.2.2 */\n\n      /* Input the sample difference */\n      temp = *entropy->input_ptr[entropy->input_ptr_index[sampn]]++;\n\n      if (temp & 0x8000) {      /* instead of temp < 0 */\n        temp = (-temp) & 0x7FFF; /* absolute value, mod 2^16 */\n        if (temp == 0)          /* special case: magnitude = 32768 */\n          temp = 0x8000;\n      } else\n        temp &= 0x7FFF;         /* abs value mod 2^16 */\n\n      /* Find the number of bits needed for the magnitude of the difference */\n      nbits = 0;\n      while (temp) {\n        nbits++;\n        temp >>= 1;\n      }\n      /* Check for out-of-range difference values.\n       */\n      if (nbits > MAX_DIFF_BITS)\n        ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n\n      /* Count the Huffman symbol for the number of bits */\n      counts[nbits]++;\n    }\n  }\n\n  return nMCU;\n}\n\n\n/*\n * Finish up a statistics-gathering pass and create the new Huffman tables.\n */\n\nMETHODDEF(void)\nfinish_pass_gather(j_compress_ptr cinfo)\n{\n  lhuff_entropy_ptr entropy = (lhuff_entropy_ptr)cinfo->entropy;\n  int ci, dctbl;\n  jpeg_component_info *compptr;\n  JHUFF_TBL **htblptr;\n  boolean did_dc[NUM_HUFF_TBLS];\n\n  /* It's important not to apply jpeg_gen_optimal_table more than once\n   * per table, because it clobbers the input frequency counts!\n   */\n  memset(did_dc, 0, sizeof(did_dc));\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    dctbl = compptr->dc_tbl_no;\n    if (!did_dc[dctbl]) {\n      htblptr = &cinfo->dc_huff_tbl_ptrs[dctbl];\n      if (*htblptr == NULL)\n        *htblptr = jpeg_alloc_huff_table((j_common_ptr)cinfo);\n      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->count_ptrs[dctbl]);\n      did_dc[dctbl] = TRUE;\n    }\n  }\n}\n\n\n#endif /* ENTROPY_OPT_SUPPORTED */\n\n\n/*\n * Module initialization routine for Huffman entropy encoding.\n */\n\nGLOBAL(void)\njinit_lhuff_encoder(j_compress_ptr cinfo)\n{\n  lhuff_entropy_ptr entropy;\n  int i;\n\n  entropy = (lhuff_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(lhuff_entropy_encoder));\n  cinfo->entropy = (struct jpeg_entropy_encoder *)entropy;\n  entropy->pub.start_pass = start_pass_lhuff;\n\n  /* Mark tables unallocated */\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    entropy->derived_tbls[i] = NULL;\n#ifdef ENTROPY_OPT_SUPPORTED\n    entropy->count_ptrs[i] = NULL;\n#endif\n  }\n}\n\n#endif /* C_LOSSLESS_SUPPORTED */\n"
        },
        {
          "name": "jclossls.c",
          "type": "blob",
          "size": 8.6865234375,
          "content": "/*\n * jclossls.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1998, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains prediction, sample differencing, and point transform\n * routines for the lossless JPEG compressor.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jlossls.h\"\n\n#ifdef C_LOSSLESS_SUPPORTED\n\n\n/************************** Sample differencing **************************/\n\n/*\n * In order to avoid a performance penalty for checking which predictor is\n * being used and which row is being processed for each call of the\n * undifferencer, and to promote optimization, we have separate differencing\n * functions for each predictor selection value.\n *\n * We are able to avoid duplicating source code by implementing the predictors\n * and differencers as macros.  Each of the differencing functions is simply a\n * wrapper around a DIFFERENCE macro with the appropriate PREDICTOR macro\n * passed as an argument.\n */\n\n/* Forward declarations */\nLOCAL(void) reset_predictor(j_compress_ptr cinfo, int ci);\n\n\n/* Predictor for the first column of the first row: 2^(P-Pt-1) */\n#define INITIAL_PREDICTORx  (1 << (cinfo->data_precision - cinfo->Al - 1))\n\n/* Predictor for the first column of the remaining rows: Rb */\n#define INITIAL_PREDICTOR2  prev_row[0]\n\n\n/*\n * 1-Dimensional differencer routine.\n *\n * This macro implements the 1-D horizontal predictor (1).  INITIAL_PREDICTOR\n * is used as the special case predictor for the first column, which must be\n * either INITIAL_PREDICTOR2 or INITIAL_PREDICTORx.  The remaining samples\n * use PREDICTOR1.\n */\n\n#define DIFFERENCE_1D(INITIAL_PREDICTOR) \\\n  lossless_comp_ptr losslessc = (lossless_comp_ptr)cinfo->fdct; \\\n  boolean restart = FALSE; \\\n  int samp, Ra; \\\n  \\\n  samp = *input_buf++; \\\n  *diff_buf++ = samp - INITIAL_PREDICTOR; \\\n  \\\n  while (--width) { \\\n    Ra = samp; \\\n    samp = *input_buf++; \\\n    *diff_buf++ = samp - PREDICTOR1; \\\n  } \\\n  \\\n  /* Account for restart interval (no-op if not using restarts) */ \\\n  if (cinfo->restart_interval) { \\\n    if (--(losslessc->restart_rows_to_go[ci]) == 0) { \\\n      reset_predictor(cinfo, ci); \\\n      restart = TRUE; \\\n    } \\\n  }\n\n\n/*\n * 2-Dimensional differencer routine.\n *\n * This macro implements the 2-D horizontal predictors (#2-7).  PREDICTOR2 is\n * used as the special case predictor for the first column.  The remaining\n * samples use PREDICTOR, which is a function of Ra, Rb, and Rc.\n *\n * Because prev_row and output_buf may point to the same storage area (in an\n * interleaved image with Vi=1, for example), we must take care to buffer Rb/Rc\n * before writing the current reconstructed sample value into output_buf.\n */\n\n#define DIFFERENCE_2D(PREDICTOR) \\\n  lossless_comp_ptr losslessc = (lossless_comp_ptr)cinfo->fdct; \\\n  int samp, Ra, Rb, Rc; \\\n  \\\n  Rb = *prev_row++; \\\n  samp = *input_buf++; \\\n  *diff_buf++ = samp - PREDICTOR2; \\\n  \\\n  while (--width) { \\\n    Rc = Rb; \\\n    Rb = *prev_row++; \\\n    Ra = samp; \\\n    samp = *input_buf++; \\\n    *diff_buf++ = samp - PREDICTOR; \\\n  } \\\n  \\\n  /* Account for restart interval (no-op if not using restarts) */ \\\n  if (cinfo->restart_interval) { \\\n    if (--losslessc->restart_rows_to_go[ci] == 0) \\\n      reset_predictor(cinfo, ci); \\\n  }\n\n\n/*\n * Differencers for the second and subsequent rows in a scan or restart\n * interval.  The first sample in the row is differenced using the vertical\n * predictor (2).  The rest of the samples are differenced using the predictor\n * specified in the scan header.\n */\n\nMETHODDEF(void)\njpeg_difference1(j_compress_ptr cinfo, int ci,\n                 _JSAMPROW input_buf, _JSAMPROW prev_row,\n                 JDIFFROW diff_buf, JDIMENSION width)\n{\n  DIFFERENCE_1D(INITIAL_PREDICTOR2);\n  (void)(restart);\n}\n\nMETHODDEF(void)\njpeg_difference2(j_compress_ptr cinfo, int ci,\n                 _JSAMPROW input_buf, _JSAMPROW prev_row,\n                 JDIFFROW diff_buf, JDIMENSION width)\n{\n  DIFFERENCE_2D(PREDICTOR2);\n  (void)(Ra);\n  (void)(Rc);\n}\n\nMETHODDEF(void)\njpeg_difference3(j_compress_ptr cinfo, int ci,\n                 _JSAMPROW input_buf, _JSAMPROW prev_row,\n                 JDIFFROW diff_buf, JDIMENSION width)\n{\n  DIFFERENCE_2D(PREDICTOR3);\n  (void)(Ra);\n}\n\nMETHODDEF(void)\njpeg_difference4(j_compress_ptr cinfo, int ci,\n                 _JSAMPROW input_buf, _JSAMPROW prev_row,\n                 JDIFFROW diff_buf, JDIMENSION width)\n{\n  DIFFERENCE_2D(PREDICTOR4);\n}\n\nMETHODDEF(void)\njpeg_difference5(j_compress_ptr cinfo, int ci,\n                 _JSAMPROW input_buf, _JSAMPROW prev_row,\n                 JDIFFROW diff_buf, JDIMENSION width)\n{\n  DIFFERENCE_2D(PREDICTOR5);\n}\n\nMETHODDEF(void)\njpeg_difference6(j_compress_ptr cinfo, int ci,\n                 _JSAMPROW input_buf, _JSAMPROW prev_row,\n                 JDIFFROW diff_buf, JDIMENSION width)\n{\n  DIFFERENCE_2D(PREDICTOR6);\n}\n\nMETHODDEF(void)\njpeg_difference7(j_compress_ptr cinfo, int ci,\n                 _JSAMPROW input_buf, _JSAMPROW prev_row,\n                 JDIFFROW diff_buf, JDIMENSION width)\n{\n  DIFFERENCE_2D(PREDICTOR7);\n  (void)(Rc);\n}\n\n\n/*\n * Differencer for the first row in a scan or restart interval.  The first\n * sample in the row is differenced using the special predictor constant\n * x = 2 ^ (P-Pt-1).  The rest of the samples are differenced using the\n * 1-D horizontal predictor (1).\n */\n\nMETHODDEF(void)\njpeg_difference_first_row(j_compress_ptr cinfo, int ci,\n                          _JSAMPROW input_buf, _JSAMPROW prev_row,\n                          JDIFFROW diff_buf, JDIMENSION width)\n{\n  DIFFERENCE_1D(INITIAL_PREDICTORx);\n\n  /*\n   * Now that we have differenced the first row, we want to use the\n   * differencer that corresponds to the predictor specified in the\n   * scan header.\n   *\n   * Note that we don't do this if we have just reset the predictor\n   * for a new restart interval.\n   */\n  if (!restart) {\n    switch (cinfo->Ss) {\n    case 1:\n      losslessc->predict_difference[ci] = jpeg_difference1;\n      break;\n    case 2:\n      losslessc->predict_difference[ci] = jpeg_difference2;\n      break;\n    case 3:\n      losslessc->predict_difference[ci] = jpeg_difference3;\n      break;\n    case 4:\n      losslessc->predict_difference[ci] = jpeg_difference4;\n      break;\n    case 5:\n      losslessc->predict_difference[ci] = jpeg_difference5;\n      break;\n    case 6:\n      losslessc->predict_difference[ci] = jpeg_difference6;\n      break;\n    case 7:\n      losslessc->predict_difference[ci] = jpeg_difference7;\n      break;\n    }\n  }\n}\n\n/*\n * Reset predictor at the start of a pass or restart interval.\n */\n\nLOCAL(void)\nreset_predictor(j_compress_ptr cinfo, int ci)\n{\n  lossless_comp_ptr losslessc = (lossless_comp_ptr)cinfo->fdct;\n\n  /* Initialize restart counter */\n  losslessc->restart_rows_to_go[ci] =\n    cinfo->restart_interval / cinfo->MCUs_per_row;\n\n  /* Set difference function to first row function */\n  losslessc->predict_difference[ci] = jpeg_difference_first_row;\n}\n\n\n/********************** Sample downscaling by 2^Pt ***********************/\n\nMETHODDEF(void)\nsimple_downscale(j_compress_ptr cinfo,\n                 _JSAMPROW input_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  do {\n    *output_buf++ = (_JSAMPLE)RIGHT_SHIFT(*input_buf++, cinfo->Al);\n  } while (--width);\n}\n\n\nMETHODDEF(void)\nnoscale(j_compress_ptr cinfo,\n        _JSAMPROW input_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  memcpy(output_buf, input_buf, width * sizeof(_JSAMPLE));\n}\n\n\n/*\n * Initialize for a processing pass.\n */\n\nMETHODDEF(void)\nstart_pass_lossless(j_compress_ptr cinfo)\n{\n  lossless_comp_ptr losslessc = (lossless_comp_ptr)cinfo->fdct;\n  int ci;\n\n  /* Set scaler function based on Pt */\n  if (cinfo->Al)\n    losslessc->scaler_scale = simple_downscale;\n  else\n    losslessc->scaler_scale = noscale;\n\n  /* Check that the restart interval is an integer multiple of the number\n   * of MCUs in an MCU row.\n   */\n  if (cinfo->restart_interval % cinfo->MCUs_per_row != 0)\n    ERREXIT2(cinfo, JERR_BAD_RESTART,\n             cinfo->restart_interval, cinfo->MCUs_per_row);\n\n  /* Set predictors for start of pass */\n  for (ci = 0; ci < cinfo->num_components; ci++)\n    reset_predictor(cinfo, ci);\n}\n\n\n/*\n * Initialize the lossless compressor.\n */\n\nGLOBAL(void)\n_jinit_lossless_compressor(j_compress_ptr cinfo)\n{\n  lossless_comp_ptr losslessc;\n\n  /* Create subobject in permanent pool */\n  losslessc = (lossless_comp_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(jpeg_lossless_compressor));\n  cinfo->fdct = (struct jpeg_forward_dct *)losslessc;\n  losslessc->pub.start_pass = start_pass_lossless;\n}\n\n#endif /* C_LOSSLESS_SUPPORTED */\n"
        },
        {
          "name": "jcmainct.c",
          "type": "blob",
          "size": 5.5556640625,
          "content": "/*\n * jcmainct.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the main buffer controller for compression.\n * The main buffer lies between the pre-processor and the JPEG\n * compressor proper; it holds downsampled data in the JPEG colorspace.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n\n\n#if BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED)\n\n/* Private buffer controller object */\n\ntypedef struct {\n  struct jpeg_c_main_controller pub; /* public fields */\n\n  JDIMENSION cur_iMCU_row;      /* number of current iMCU row */\n  JDIMENSION rowgroup_ctr;      /* counts row groups received in iMCU row */\n  boolean suspended;            /* remember if we suspended output */\n  J_BUF_MODE pass_mode;         /* current operating mode */\n\n  /* If using just a strip buffer, this points to the entire set of buffers\n   * (we allocate one for each component).  In the full-image case, this\n   * points to the currently accessible strips of the virtual arrays.\n   */\n  _JSAMPARRAY buffer[MAX_COMPONENTS];\n} my_main_controller;\n\ntypedef my_main_controller *my_main_ptr;\n\n\n/* Forward declarations */\nMETHODDEF(void) process_data_simple_main(j_compress_ptr cinfo,\n                                         _JSAMPARRAY input_buf,\n                                         JDIMENSION *in_row_ctr,\n                                         JDIMENSION in_rows_avail);\n\n\n/*\n * Initialize for a processing pass.\n */\n\nMETHODDEF(void)\nstart_pass_main(j_compress_ptr cinfo, J_BUF_MODE pass_mode)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n\n  /* Do nothing in raw-data mode. */\n  if (cinfo->raw_data_in)\n    return;\n\n  if (pass_mode != JBUF_PASS_THRU)\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n\n  main_ptr->cur_iMCU_row = 0;   /* initialize counters */\n  main_ptr->rowgroup_ctr = 0;\n  main_ptr->suspended = FALSE;\n  main_ptr->pass_mode = pass_mode;      /* save mode for use by process_data */\n  main_ptr->pub._process_data = process_data_simple_main;\n}\n\n\n/*\n * Process some data.\n * This routine handles the simple pass-through mode,\n * where we have only a strip buffer.\n */\n\nMETHODDEF(void)\nprocess_data_simple_main(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                         JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  JDIMENSION data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n  while (main_ptr->cur_iMCU_row < cinfo->total_iMCU_rows) {\n    /* Read input data if we haven't filled the main buffer yet */\n    if (main_ptr->rowgroup_ctr < data_unit)\n      (*cinfo->prep->_pre_process_data) (cinfo, input_buf, in_row_ctr,\n                                         in_rows_avail, main_ptr->buffer,\n                                         &main_ptr->rowgroup_ctr, data_unit);\n\n    /* If we don't have a full iMCU row buffered, return to application for\n     * more data.  Note that preprocessor will always pad to fill the iMCU row\n     * at the bottom of the image.\n     */\n    if (main_ptr->rowgroup_ctr != data_unit)\n      return;\n\n    /* Send the completed row to the compressor */\n    if (!(*cinfo->coef->_compress_data) (cinfo, main_ptr->buffer)) {\n      /* If compressor did not consume the whole row, then we must need to\n       * suspend processing and return to the application.  In this situation\n       * we pretend we didn't yet consume the last input row; otherwise, if\n       * it happened to be the last row of the image, the application would\n       * think we were done.\n       */\n      if (!main_ptr->suspended) {\n        (*in_row_ctr)--;\n        main_ptr->suspended = TRUE;\n      }\n      return;\n    }\n    /* We did finish the row.  Undo our little suspension hack if a previous\n     * call suspended; then mark the main buffer empty.\n     */\n    if (main_ptr->suspended) {\n      (*in_row_ctr)++;\n      main_ptr->suspended = FALSE;\n    }\n    main_ptr->rowgroup_ctr = 0;\n    main_ptr->cur_iMCU_row++;\n  }\n}\n\n\n/*\n * Initialize main buffer controller.\n */\n\nGLOBAL(void)\n_jinit_c_main_controller(j_compress_ptr cinfo, boolean need_full_buffer)\n{\n  my_main_ptr main_ptr;\n  int ci;\n  jpeg_component_info *compptr;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  main_ptr = (my_main_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_main_controller));\n  memset(main_ptr, 0, sizeof(my_main_controller));\n  cinfo->main = (struct jpeg_c_main_controller *)main_ptr;\n  main_ptr->pub.start_pass = start_pass_main;\n\n  /* We don't need to create a buffer in raw-data mode. */\n  if (cinfo->raw_data_in)\n    return;\n\n  /* Create the buffer.  It holds downsampled data, so each component\n   * may be of a different size.\n   */\n  if (need_full_buffer) {\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n  } else {\n    /* Allocate a strip buffer for each component */\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      main_ptr->buffer[ci] = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n        ((j_common_ptr)cinfo, JPOOL_IMAGE,\n         compptr->width_in_blocks * data_unit,\n         (JDIMENSION)(compptr->v_samp_factor * data_unit));\n    }\n  }\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED) */\n"
        },
        {
          "name": "jcmarker.c",
          "type": "blob",
          "size": 21.9287109375,
          "content": "/*\n * jcmarker.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1998, Thomas G. Lane.\n * Modified 2003-2010 by Guido Vollbeding.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to write JPEG datastream markers.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jpegapicomp.h\"\n\n\ntypedef enum {                  /* JPEG marker codes */\n  M_SOF0  = 0xc0,\n  M_SOF1  = 0xc1,\n  M_SOF2  = 0xc2,\n  M_SOF3  = 0xc3,\n\n  M_SOF5  = 0xc5,\n  M_SOF6  = 0xc6,\n  M_SOF7  = 0xc7,\n\n  M_JPG   = 0xc8,\n  M_SOF9  = 0xc9,\n  M_SOF10 = 0xca,\n  M_SOF11 = 0xcb,\n\n  M_SOF13 = 0xcd,\n  M_SOF14 = 0xce,\n  M_SOF15 = 0xcf,\n\n  M_DHT   = 0xc4,\n\n  M_DAC   = 0xcc,\n\n  M_RST0  = 0xd0,\n  M_RST1  = 0xd1,\n  M_RST2  = 0xd2,\n  M_RST3  = 0xd3,\n  M_RST4  = 0xd4,\n  M_RST5  = 0xd5,\n  M_RST6  = 0xd6,\n  M_RST7  = 0xd7,\n\n  M_SOI   = 0xd8,\n  M_EOI   = 0xd9,\n  M_SOS   = 0xda,\n  M_DQT   = 0xdb,\n  M_DNL   = 0xdc,\n  M_DRI   = 0xdd,\n  M_DHP   = 0xde,\n  M_EXP   = 0xdf,\n\n  M_APP0  = 0xe0,\n  M_APP1  = 0xe1,\n  M_APP2  = 0xe2,\n  M_APP3  = 0xe3,\n  M_APP4  = 0xe4,\n  M_APP5  = 0xe5,\n  M_APP6  = 0xe6,\n  M_APP7  = 0xe7,\n  M_APP8  = 0xe8,\n  M_APP9  = 0xe9,\n  M_APP10 = 0xea,\n  M_APP11 = 0xeb,\n  M_APP12 = 0xec,\n  M_APP13 = 0xed,\n  M_APP14 = 0xee,\n  M_APP15 = 0xef,\n\n  M_JPG0  = 0xf0,\n  M_JPG13 = 0xfd,\n  M_COM   = 0xfe,\n\n  M_TEM   = 0x01,\n\n  M_ERROR = 0x100\n} JPEG_MARKER;\n\n\n/* Private state */\n\ntypedef struct {\n  struct jpeg_marker_writer pub; /* public fields */\n\n  unsigned int last_restart_interval; /* last DRI value emitted; 0 after SOI */\n} my_marker_writer;\n\ntypedef my_marker_writer *my_marker_ptr;\n\n\n/*\n * Basic output routines.\n *\n * Note that we do not support suspension while writing a marker.\n * Therefore, an application using suspension must ensure that there is\n * enough buffer space for the initial markers (typ. 600-700 bytes) before\n * calling jpeg_start_compress, and enough space to write the trailing EOI\n * (a few bytes) before calling jpeg_finish_compress.  Multipass compression\n * modes are not supported at all with suspension, so those two are the only\n * points where markers will be written.\n */\n\nLOCAL(void)\nemit_byte(j_compress_ptr cinfo, int val)\n/* Emit a byte */\n{\n  struct jpeg_destination_mgr *dest = cinfo->dest;\n\n  *(dest->next_output_byte)++ = (JOCTET)val;\n  if (--dest->free_in_buffer == 0) {\n    if (!(*dest->empty_output_buffer) (cinfo))\n      ERREXIT(cinfo, JERR_CANT_SUSPEND);\n  }\n}\n\n\nLOCAL(void)\nemit_marker(j_compress_ptr cinfo, JPEG_MARKER mark)\n/* Emit a marker code */\n{\n  emit_byte(cinfo, 0xFF);\n  emit_byte(cinfo, (int)mark);\n}\n\n\nLOCAL(void)\nemit_2bytes(j_compress_ptr cinfo, int value)\n/* Emit a 2-byte integer; these are always MSB first in JPEG files */\n{\n  emit_byte(cinfo, (value >> 8) & 0xFF);\n  emit_byte(cinfo, value & 0xFF);\n}\n\n\n/*\n * Routines to write specific marker types.\n */\n\nLOCAL(int)\nemit_dqt(j_compress_ptr cinfo, int index)\n/* Emit a DQT marker */\n/* Returns the precision used (0 = 8bits, 1 = 16bits) for baseline checking */\n{\n  JQUANT_TBL *qtbl = cinfo->quant_tbl_ptrs[index];\n  int prec;\n  int i;\n\n  if (qtbl == NULL)\n    ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, index);\n\n  prec = 0;\n  for (i = 0; i < DCTSIZE2; i++) {\n    if (qtbl->quantval[i] > 255)\n      prec = 1;\n  }\n\n  if (!qtbl->sent_table) {\n    emit_marker(cinfo, M_DQT);\n\n    emit_2bytes(cinfo, prec ? DCTSIZE2 * 2 + 1 + 2 : DCTSIZE2 + 1 + 2);\n\n    emit_byte(cinfo, index + (prec << 4));\n\n    for (i = 0; i < DCTSIZE2; i++) {\n      /* The table entries must be emitted in zigzag order. */\n      unsigned int qval = qtbl->quantval[jpeg_natural_order[i]];\n      if (prec)\n        emit_byte(cinfo, (int)(qval >> 8));\n      emit_byte(cinfo, (int)(qval & 0xFF));\n    }\n\n    qtbl->sent_table = TRUE;\n  }\n\n  return prec;\n}\n\nLOCAL(int)\nemit_multi_dqt (j_compress_ptr cinfo)\n/* Emits a DQT marker containing all quantization tables */\n/* Returns number of emitted 16-bit tables, or -1 for failed for baseline checking. */\n{\n  int prec[MAX_COMPONENTS];\n  int seen[MAX_COMPONENTS] = { 0 };\n  int fin_prec = 0;\n  int ci;\n  int size = 0;\n\n  if (cinfo->master->compress_profile == JCP_FASTEST)\n    return -1;\n\n  for (ci = 0; ci < cinfo->num_components; ci++) {\n    int tbl_num = cinfo->comp_info[ci].quant_tbl_no;\n    int i;\n    JQUANT_TBL * qtbl = cinfo->quant_tbl_ptrs[tbl_num];\n\n    if (qtbl == NULL || qtbl->sent_table == TRUE)\n      return -1;\n\n    prec[ci] = 0;\n    for (i = 0; i < DCTSIZE2; i++)\n      prec[ci] = !!(prec[ci] + (qtbl->quantval[i] > 255));\n\n    fin_prec += prec[ci];\n  }\n\n  emit_marker(cinfo, M_DQT);\n\n  for (ci = 0; ci < cinfo->num_components; ci++) {\n    int tbl_num = cinfo->comp_info[ci].quant_tbl_no;\n\n    if (!seen[tbl_num]) {\n      size += DCTSIZE2 * (prec[ci] + 1) + 1;\n      seen[tbl_num] = 1;\n    }\n  }\n  size += 2;\n\n  emit_2bytes(cinfo, size);\n\n  for (ci = 0; ci < cinfo->num_components; ci++) {\n    int tbl_num = cinfo->comp_info[ci].quant_tbl_no;\n    int i;\n    JQUANT_TBL * qtbl = cinfo->quant_tbl_ptrs[tbl_num];\n\n    if (qtbl->sent_table == TRUE)\n        continue;\n\n    emit_byte(cinfo, tbl_num + (prec[ci] << 4));\n\n    for (i = 0; i < DCTSIZE2; i++) {\n      unsigned int qval = qtbl->quantval[jpeg_natural_order[i]];\n\n      if (prec[ci])\n        emit_byte(cinfo, (int) (qval >> 8));\n      emit_byte(cinfo, (int) (qval & 0xFF));\n    }\n\n    qtbl->sent_table = TRUE;\n  }\n\n  return fin_prec;\n}\n\nLOCAL(void)\nemit_dht(j_compress_ptr cinfo, int index, boolean is_ac)\n/* Emit a DHT marker */\n{\n  JHUFF_TBL *htbl;\n  int length, i;\n\n  if (is_ac) {\n    htbl = cinfo->ac_huff_tbl_ptrs[index];\n    index += 0x10;              /* output index has AC bit set */\n  } else {\n    htbl = cinfo->dc_huff_tbl_ptrs[index];\n  }\n\n  if (htbl == NULL)\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, index);\n\n  if (!htbl->sent_table) {\n    emit_marker(cinfo, M_DHT);\n\n    length = 0;\n    for (i = 1; i <= 16; i++)\n      length += htbl->bits[i];\n\n    emit_2bytes(cinfo, length + 2 + 1 + 16);\n    emit_byte(cinfo, index);\n\n    for (i = 1; i <= 16; i++)\n      emit_byte(cinfo, htbl->bits[i]);\n\n    for (i = 0; i < length; i++)\n      emit_byte(cinfo, htbl->huffval[i]);\n\n    htbl->sent_table = TRUE;\n  }\n}\n\nLOCAL(boolean)\nemit_multi_dht (j_compress_ptr cinfo)\n/* Emit all DHT markers */\n/* Returns FALSE on failure, TRUE otherwise. */\n{\n  int i, j;\n  int length = 2;\n  int dclens[NUM_HUFF_TBLS] = { 0 };\n  int aclens[NUM_HUFF_TBLS] = { 0 };\n  JHUFF_TBL *dcseen[NUM_HUFF_TBLS] = { NULL };\n  JHUFF_TBL *acseen[NUM_HUFF_TBLS] = { NULL };\n\n  if (cinfo->master->compress_profile == JCP_FASTEST)\n    return 0;\n\n  /* Calclate the total length. */\n  for (i = 0; i < cinfo->comps_in_scan; i++) {\n    jpeg_component_info *compptr = cinfo->cur_comp_info[i];\n    int dcidx = compptr->dc_tbl_no;\n    int acidx = compptr->ac_tbl_no;\n    JHUFF_TBL *dctbl = cinfo->dc_huff_tbl_ptrs[dcidx];\n    JHUFF_TBL *actbl = cinfo->ac_huff_tbl_ptrs[acidx];\n    int seen = 0;\n\n    /* Handle DC table lenghts */\n    if (cinfo->Ss == 0 && cinfo->Ah == 0) {\n      if (dctbl == NULL)\n        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dcidx);\n\n      if (dctbl->sent_table)\n          continue;\n\n      for (j = 0; j < NUM_HUFF_TBLS; j++)\n          seen += (dctbl == dcseen[j]);\n      if (seen)\n          continue;\n      dcseen[i] = dctbl;\n\n      for (j = 1; j <= 16; j++)\n        dclens[i] += dctbl->bits[j];\n      length += dclens[i] + 16 + 1;\n    }\n\n    /* Handle AC table lengths */\n    if (cinfo->Se) {\n      if (actbl == NULL)\n        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, acidx + 0x10);\n\n      if (actbl->sent_table)\n          continue;\n\n      seen = 0;\n      for (j = 0; j < NUM_HUFF_TBLS; j++)\n          seen += (actbl == acseen[j]);\n      if (seen)\n          continue;\n      acseen[i] = actbl;\n\n      for (j = 1; j <= 16; j++)\n        aclens[i] += actbl->bits[j];\n      length += aclens[i] + 16 + 1;\n\n    }\n  }\n\n  /* Make sure we can fit it all into one DHT marker */\n  if (length > (1 << 16) - 1)\n    return FALSE;\n\n  emit_marker(cinfo, M_DHT);\n  emit_2bytes(cinfo, length);\n\n  for (i = 0; i < cinfo->comps_in_scan; i++) {\n    jpeg_component_info *compptr = cinfo->cur_comp_info[i];\n    int dcidx = compptr->dc_tbl_no;\n    int acidx = compptr->ac_tbl_no;\n    JHUFF_TBL *dctbl = cinfo->dc_huff_tbl_ptrs[dcidx];\n    JHUFF_TBL *actbl = cinfo->ac_huff_tbl_ptrs[acidx];\n\n    acidx += 0x10;\n\n    /* DC */\n    if (cinfo->Ss == 0 && cinfo->Ah == 0 && !dctbl->sent_table) {\n      emit_byte(cinfo, dcidx);\n\n      for (j = 1; j <= 16; j++)\n        emit_byte(cinfo, dctbl->bits[j]);\n\n      for (j = 0; j < dclens[i]; j++)\n        emit_byte(cinfo, dctbl->huffval[j]);\n\n      dctbl->sent_table = TRUE;\n    }\n\n    if (cinfo->Se && !actbl->sent_table) {\n      emit_byte(cinfo, acidx);\n\n      for (j = 1; j <= 16; j++)\n        emit_byte(cinfo, actbl->bits[j]);\n\n      for (j = 0; j < aclens[i]; j++)\n        emit_byte(cinfo, actbl->huffval[j]);\n\n      actbl->sent_table = TRUE;\n    }\n  }\n\n  return TRUE;\n}\n\nLOCAL(void)\nemit_dac(j_compress_ptr cinfo)\n/* Emit a DAC marker */\n/* Since the useful info is so small, we want to emit all the tables in */\n/* one DAC marker.  Therefore this routine does its own scan of the table. */\n{\n#ifdef C_ARITH_CODING_SUPPORTED\n  char dc_in_use[NUM_ARITH_TBLS];\n  char ac_in_use[NUM_ARITH_TBLS];\n  int length, i;\n  jpeg_component_info *compptr;\n\n  for (i = 0; i < NUM_ARITH_TBLS; i++)\n    dc_in_use[i] = ac_in_use[i] = 0;\n\n  for (i = 0; i < cinfo->comps_in_scan; i++) {\n    compptr = cinfo->cur_comp_info[i];\n    /* DC needs no table for refinement scan */\n    if (cinfo->Ss == 0 && cinfo->Ah == 0)\n      dc_in_use[compptr->dc_tbl_no] = 1;\n    /* AC needs no table when not present */\n    if (cinfo->Se)\n      ac_in_use[compptr->ac_tbl_no] = 1;\n  }\n\n  length = 0;\n  for (i = 0; i < NUM_ARITH_TBLS; i++)\n    length += dc_in_use[i] + ac_in_use[i];\n\n  if (length) {\n    emit_marker(cinfo, M_DAC);\n\n    emit_2bytes(cinfo, length * 2 + 2);\n\n    for (i = 0; i < NUM_ARITH_TBLS; i++) {\n      if (dc_in_use[i]) {\n        emit_byte(cinfo, i);\n        emit_byte(cinfo, cinfo->arith_dc_L[i] + (cinfo->arith_dc_U[i] << 4));\n      }\n      if (ac_in_use[i]) {\n        emit_byte(cinfo, i + 0x10);\n        emit_byte(cinfo, cinfo->arith_ac_K[i]);\n      }\n    }\n  }\n#endif /* C_ARITH_CODING_SUPPORTED */\n}\n\n\nLOCAL(void)\nemit_dri(j_compress_ptr cinfo)\n/* Emit a DRI marker */\n{\n  emit_marker(cinfo, M_DRI);\n\n  emit_2bytes(cinfo, 4);        /* fixed length */\n\n  emit_2bytes(cinfo, (int)cinfo->restart_interval);\n}\n\n\nLOCAL(void)\nemit_sof(j_compress_ptr cinfo, JPEG_MARKER code)\n/* Emit a SOF marker */\n{\n  int ci;\n  jpeg_component_info *compptr;\n\n  emit_marker(cinfo, code);\n\n  emit_2bytes(cinfo, 3 * cinfo->num_components + 2 + 5 + 1); /* length */\n\n  /* Make sure image isn't bigger than SOF field can handle */\n  if ((long)cinfo->_jpeg_height > 65535L || (long)cinfo->_jpeg_width > 65535L)\n    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int)65535);\n\n  emit_byte(cinfo, cinfo->data_precision);\n  emit_2bytes(cinfo, (int)cinfo->_jpeg_height);\n  emit_2bytes(cinfo, (int)cinfo->_jpeg_width);\n\n  emit_byte(cinfo, cinfo->num_components);\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    emit_byte(cinfo, compptr->component_id);\n    emit_byte(cinfo, (compptr->h_samp_factor << 4) + compptr->v_samp_factor);\n    emit_byte(cinfo, compptr->quant_tbl_no);\n  }\n}\n\n\nLOCAL(void)\nemit_sos(j_compress_ptr cinfo)\n/* Emit a SOS marker */\n{\n  int i, td, ta;\n  jpeg_component_info *compptr;\n\n  emit_marker(cinfo, M_SOS);\n\n  emit_2bytes(cinfo, 2 * cinfo->comps_in_scan + 2 + 1 + 3); /* length */\n\n  emit_byte(cinfo, cinfo->comps_in_scan);\n\n  for (i = 0; i < cinfo->comps_in_scan; i++) {\n    compptr = cinfo->cur_comp_info[i];\n    emit_byte(cinfo, compptr->component_id);\n\n    /* We emit 0 for unused field(s); this is recommended by the P&M text\n     * but does not seem to be specified in the standard.\n     */\n\n    /* DC needs no table for refinement scan */\n    td = cinfo->Ss == 0 && cinfo->Ah == 0 ? compptr->dc_tbl_no : 0;\n    /* AC needs no table when not present */\n    ta = cinfo->Se ? compptr->ac_tbl_no : 0;\n\n    emit_byte(cinfo, (td << 4) + ta);\n  }\n\n  emit_byte(cinfo, cinfo->Ss);\n  emit_byte(cinfo, cinfo->Se);\n  emit_byte(cinfo, (cinfo->Ah << 4) + cinfo->Al);\n}\n\n\nLOCAL(void)\nemit_jfif_app0(j_compress_ptr cinfo)\n/* Emit a JFIF-compliant APP0 marker */\n{\n  /*\n   * Length of APP0 block       (2 bytes)\n   * Block ID                   (4 bytes - ASCII \"JFIF\")\n   * Zero byte                  (1 byte to terminate the ID string)\n   * Version Major, Minor       (2 bytes - major first)\n   * Units                      (1 byte - 0x00 = none, 0x01 = inch, 0x02 = cm)\n   * Xdpu                       (2 bytes - dots per unit horizontal)\n   * Ydpu                       (2 bytes - dots per unit vertical)\n   * Thumbnail X size           (1 byte)\n   * Thumbnail Y size           (1 byte)\n   */\n\n  emit_marker(cinfo, M_APP0);\n\n  emit_2bytes(cinfo, 2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1); /* length */\n\n  emit_byte(cinfo, 0x4A);       /* Identifier: ASCII \"JFIF\" */\n  emit_byte(cinfo, 0x46);\n  emit_byte(cinfo, 0x49);\n  emit_byte(cinfo, 0x46);\n  emit_byte(cinfo, 0);\n  emit_byte(cinfo, cinfo->JFIF_major_version); /* Version fields */\n  emit_byte(cinfo, cinfo->JFIF_minor_version);\n  emit_byte(cinfo, cinfo->density_unit); /* Pixel size information */\n  emit_2bytes(cinfo, (int)cinfo->X_density);\n  emit_2bytes(cinfo, (int)cinfo->Y_density);\n  emit_byte(cinfo, 0);          /* No thumbnail image */\n  emit_byte(cinfo, 0);\n}\n\n\nLOCAL(void)\nemit_adobe_app14(j_compress_ptr cinfo)\n/* Emit an Adobe APP14 marker */\n{\n  /*\n   * Length of APP14 block      (2 bytes)\n   * Block ID                   (5 bytes - ASCII \"Adobe\")\n   * Version Number             (2 bytes - currently 100)\n   * Flags0                     (2 bytes - currently 0)\n   * Flags1                     (2 bytes - currently 0)\n   * Color transform            (1 byte)\n   *\n   * Although Adobe TN 5116 mentions Version = 101, all the Adobe files\n   * now in circulation seem to use Version = 100, so that's what we write.\n   *\n   * We write the color transform byte as 1 if the JPEG color space is\n   * YCbCr, 2 if it's YCCK, 0 otherwise.  Adobe's definition has to do with\n   * whether the encoder performed a transformation, which is pretty useless.\n   */\n\n  emit_marker(cinfo, M_APP14);\n\n  emit_2bytes(cinfo, 2 + 5 + 2 + 2 + 2 + 1); /* length */\n\n  emit_byte(cinfo, 0x41);       /* Identifier: ASCII \"Adobe\" */\n  emit_byte(cinfo, 0x64);\n  emit_byte(cinfo, 0x6F);\n  emit_byte(cinfo, 0x62);\n  emit_byte(cinfo, 0x65);\n  emit_2bytes(cinfo, 100);      /* Version */\n  emit_2bytes(cinfo, 0);        /* Flags0 */\n  emit_2bytes(cinfo, 0);        /* Flags1 */\n  switch (cinfo->jpeg_color_space) {\n  case JCS_YCbCr:\n    emit_byte(cinfo, 1);        /* Color transform = 1 */\n    break;\n  case JCS_YCCK:\n    emit_byte(cinfo, 2);        /* Color transform = 2 */\n    break;\n  default:\n    emit_byte(cinfo, 0);        /* Color transform = 0 */\n    break;\n  }\n}\n\n\n/*\n * These routines allow writing an arbitrary marker with parameters.\n * The only intended use is to emit COM or APPn markers after calling\n * write_file_header and before calling write_frame_header.\n * Other uses are not guaranteed to produce desirable results.\n * Counting the parameter bytes properly is the caller's responsibility.\n */\n\nMETHODDEF(void)\nwrite_marker_header(j_compress_ptr cinfo, int marker, unsigned int datalen)\n/* Emit an arbitrary marker header */\n{\n  if (datalen > (unsigned int)65533)            /* safety check */\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\n\n  emit_marker(cinfo, (JPEG_MARKER)marker);\n\n  emit_2bytes(cinfo, (int)(datalen + 2));       /* total length */\n}\n\nMETHODDEF(void)\nwrite_marker_byte(j_compress_ptr cinfo, int val)\n/* Emit one byte of marker parameters following write_marker_header */\n{\n  emit_byte(cinfo, val);\n}\n\n\n/*\n * Write datastream header.\n * This consists of an SOI and optional APPn markers.\n * We recommend use of the JFIF marker, but not the Adobe marker,\n * when using YCbCr or grayscale data.  The JFIF marker should NOT\n * be used for any other JPEG colorspace.  The Adobe marker is helpful\n * to distinguish RGB, CMYK, and YCCK colorspaces.\n * Note that an application can write additional header markers after\n * jpeg_start_compress returns.\n */\n\nMETHODDEF(void)\nwrite_file_header(j_compress_ptr cinfo)\n{\n  my_marker_ptr marker = (my_marker_ptr)cinfo->marker;\n\n  emit_marker(cinfo, M_SOI);    /* first the SOI */\n\n  /* SOI is defined to reset restart interval to 0 */\n  marker->last_restart_interval = 0;\n\n  if (cinfo->write_JFIF_header) /* next an optional JFIF APP0 */\n    emit_jfif_app0(cinfo);\n  if (cinfo->write_Adobe_marker) /* next an optional Adobe APP14 */\n    emit_adobe_app14(cinfo);\n}\n\n\n/*\n * Write frame header.\n * This consists of DQT and SOFn markers.\n * Note that we do not emit the SOF until we have emitted the DQT(s).\n * This avoids compatibility problems with incorrect implementations that\n * try to error-check the quant table numbers as soon as they see the SOF.\n */\n\nMETHODDEF(void)\nwrite_frame_header(j_compress_ptr cinfo)\n{\n  int ci, prec = 0;\n  boolean is_baseline;\n  jpeg_component_info *compptr;\n\n  /* Emit DQT for each quantization table.\n   * Note that emit_dqt() suppresses any duplicate tables.\n   */\n  prec = emit_multi_dqt(cinfo);\n  if (prec == -1) {\n  prec = 0;\n  if (!cinfo->master->lossless) {\n    /* Emit DQT for each quantization table.\n     * Note that emit_dqt() suppresses any duplicate tables.\n     */\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      prec += emit_dqt(cinfo, compptr->quant_tbl_no);\n    }\n    /* now prec is nonzero iff there are any 16-bit quant tables. */\n  }\n  }\n\n  /* Check for a non-baseline specification.\n   * Note we assume that Huffman table numbers won't be changed later.\n   */\n  if (cinfo->arith_code || cinfo->progressive_mode ||\n      cinfo->master->lossless || cinfo->data_precision != 8) {\n    is_baseline = FALSE;\n  } else {\n    is_baseline = TRUE;\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      if (compptr->dc_tbl_no > 1 || compptr->ac_tbl_no > 1)\n        is_baseline = FALSE;\n    }\n    if (prec && is_baseline) {\n      is_baseline = FALSE;\n      /* If it's baseline except for quantizer size, warn the user */\n      TRACEMS(cinfo, 0, JTRC_16BIT_TABLES);\n    }\n  }\n\n  /* Emit the proper SOF marker */\n  if (cinfo->arith_code) {\n    if (cinfo->progressive_mode)\n      emit_sof(cinfo, M_SOF10); /* SOF code for progressive arithmetic */\n    else\n      emit_sof(cinfo, M_SOF9);  /* SOF code for sequential arithmetic */\n  } else {\n    if (cinfo->progressive_mode)\n      emit_sof(cinfo, M_SOF2);  /* SOF code for progressive Huffman */\n    else if (cinfo->master->lossless)\n      emit_sof(cinfo, M_SOF3);  /* SOF code for lossless Huffman */\n    else if (is_baseline)\n      emit_sof(cinfo, M_SOF0);  /* SOF code for baseline implementation */\n    else\n      emit_sof(cinfo, M_SOF1);  /* SOF code for non-baseline Huffman file */\n  }\n}\n\n\n/*\n * Write scan header.\n * This consists of DHT or DAC markers, optional DRI, and SOS.\n * Compressed data will be written following the SOS.\n */\n\nMETHODDEF(void)\nwrite_scan_header(j_compress_ptr cinfo)\n{\n  my_marker_ptr marker = (my_marker_ptr)cinfo->marker;\n  int i;\n  jpeg_component_info *compptr;\n\n  if (cinfo->arith_code) {\n    /* Emit arith conditioning info.  We may have some duplication\n     * if the file has multiple scans, but it's so small it's hardly\n     * worth worrying about.\n     */\n    emit_dac(cinfo);\n  } else {\n    /* Emit Huffman tables.\n     * Note that emit_dht() suppresses any duplicate tables.\n     */\n    if (!emit_multi_dht(cinfo)) {\n    for (i = 0; i < cinfo->comps_in_scan; i++) {\n      compptr = cinfo->cur_comp_info[i];\n      /* DC needs no table for refinement scan */\n      if ((cinfo->Ss == 0 && cinfo->Ah == 0) || cinfo->master->lossless)\n        emit_dht(cinfo, compptr->dc_tbl_no, FALSE);\n      /* AC needs no table when not present, and lossless mode uses only DC\n         tables. */\n      if (cinfo->Se && !cinfo->master->lossless)\n        emit_dht(cinfo, compptr->ac_tbl_no, TRUE);\n    }\n  }\n  }\n\n  /* Emit DRI if required --- note that DRI value could change for each scan.\n   * We avoid wasting space with unnecessary DRIs, however.\n   */\n  if (cinfo->restart_interval != marker->last_restart_interval) {\n    emit_dri(cinfo);\n    marker->last_restart_interval = cinfo->restart_interval;\n  }\n\n  emit_sos(cinfo);\n}\n\n\n/*\n * Write datastream trailer.\n */\n\nMETHODDEF(void)\nwrite_file_trailer(j_compress_ptr cinfo)\n{\n  emit_marker(cinfo, M_EOI);\n}\n\n\n/*\n * Write an abbreviated table-specification datastream.\n * This consists of SOI, DQT and DHT tables, and EOI.\n * Any table that is defined and not marked sent_table = TRUE will be\n * emitted.  Note that all tables will be marked sent_table = TRUE at exit.\n */\n\nMETHODDEF(void)\nwrite_tables_only(j_compress_ptr cinfo)\n{\n  int i;\n\n  emit_marker(cinfo, M_SOI);\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++) {\n    if (cinfo->quant_tbl_ptrs[i] != NULL)\n      (void)emit_dqt(cinfo, i);\n  }\n\n  if (!cinfo->arith_code) {\n    for (i = 0; i < NUM_HUFF_TBLS; i++) {\n      if (cinfo->dc_huff_tbl_ptrs[i] != NULL)\n        emit_dht(cinfo, i, FALSE);\n      if (cinfo->ac_huff_tbl_ptrs[i] != NULL)\n        emit_dht(cinfo, i, TRUE);\n    }\n  }\n\n  emit_marker(cinfo, M_EOI);\n}\n\n\n/*\n * Initialize the marker writer module.\n */\n\nGLOBAL(void)\njinit_marker_writer(j_compress_ptr cinfo)\n{\n  my_marker_ptr marker;\n\n  /* Create the subobject */\n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_marker_writer));\n  cinfo->marker = (struct jpeg_marker_writer *)marker;\n  /* Initialize method pointers */\n  marker->pub.write_file_header = write_file_header;\n  marker->pub.write_frame_header = write_frame_header;\n  marker->pub.write_scan_header = write_scan_header;\n  marker->pub.write_file_trailer = write_file_trailer;\n  marker->pub.write_tables_only = write_tables_only;\n  marker->pub.write_marker_header = write_marker_header;\n  marker->pub.write_marker_byte = write_marker_byte;\n  /* Initialize private state */\n  marker->last_restart_interval = 0;\n}\n"
        },
        {
          "name": "jcmaster.c",
          "type": "blob",
          "size": 41.380859375,
          "content": "/*\n * jcmaster.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 2003-2010 by Guido Vollbeding.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010, 2016, 2018, 2022-2024, D. R. Commander.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains master control logic for the JPEG compressor.\n * These routines are concerned with parameter validation, initial setup,\n * and inter-pass control (determining the number of passes and the work\n * to be done in each pass).\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jpegapicomp.h\"\n#include \"jcmaster.h\"\n#include \"jmemsys.h\"\n#include \"jconfigint.h\"\n\n\n/*\n * Support routines that do various essential calculations.\n */\n\n#if JPEG_LIB_VERSION >= 70\n/*\n * Compute JPEG image dimensions and related values.\n * NOTE: this is exported for possible use by application.\n * Hence it mustn't do anything that can't be done twice.\n */\n\nGLOBAL(void)\njpeg_calc_jpeg_dimensions(j_compress_ptr cinfo)\n/* Do computations that are needed before master selection phase */\n{\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n  /* Hardwire it to \"no scaling\" */\n  cinfo->jpeg_width = cinfo->image_width;\n  cinfo->jpeg_height = cinfo->image_height;\n  cinfo->min_DCT_h_scaled_size = data_unit;\n  cinfo->min_DCT_v_scaled_size = data_unit;\n}\n#endif\n\n\nLOCAL(boolean)\nusing_std_huff_tables(j_compress_ptr cinfo)\n{\n  int i;\n\n  static const UINT8 bits_dc_luminance[17] = {\n    /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0\n  };\n  static const UINT8 val_dc_luminance[] = {\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n  };\n\n  static const UINT8 bits_dc_chrominance[17] = {\n    /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0\n  };\n  static const UINT8 val_dc_chrominance[] = {\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n  };\n\n  static const UINT8 bits_ac_luminance[17] = {\n    /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d\n  };\n  static const UINT8 val_ac_luminance[] = {\n    0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,\n    0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,\n    0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,\n    0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,\n    0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,\n    0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,\n    0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,\n    0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n    0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\n    0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,\n    0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\n    0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,\n    0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,\n    0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,\n    0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,\n    0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,\n    0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,\n    0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,\n    0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n    0xf9, 0xfa\n  };\n\n  static const UINT8 bits_ac_chrominance[17] = {\n    /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77\n  };\n  static const UINT8 val_ac_chrominance[] = {\n    0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,\n    0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,\n    0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,\n    0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,\n    0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,\n    0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,\n    0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,\n    0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n    0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n    0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,\n    0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n    0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,\n    0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,\n    0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,\n    0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,\n    0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,\n    0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,\n    0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n    0xf9, 0xfa\n  };\n\n  if (cinfo->dc_huff_tbl_ptrs[0] == NULL ||\n      cinfo->ac_huff_tbl_ptrs[0] == NULL ||\n      cinfo->dc_huff_tbl_ptrs[1] == NULL ||\n      cinfo->ac_huff_tbl_ptrs[1] == NULL)\n    return FALSE;\n\n  for (i = 2; i < NUM_HUFF_TBLS; i++) {\n    if (cinfo->dc_huff_tbl_ptrs[i] != NULL ||\n        cinfo->ac_huff_tbl_ptrs[i] != NULL)\n      return FALSE;\n  }\n\n  if (memcmp(cinfo->dc_huff_tbl_ptrs[0]->bits, bits_dc_luminance,\n             sizeof(bits_dc_luminance)) ||\n      memcmp(cinfo->dc_huff_tbl_ptrs[0]->huffval, val_dc_luminance,\n             sizeof(val_dc_luminance)) ||\n      memcmp(cinfo->ac_huff_tbl_ptrs[0]->bits, bits_ac_luminance,\n             sizeof(bits_ac_luminance)) ||\n      memcmp(cinfo->ac_huff_tbl_ptrs[0]->huffval, val_ac_luminance,\n             sizeof(val_ac_luminance)) ||\n      memcmp(cinfo->dc_huff_tbl_ptrs[1]->bits, bits_dc_chrominance,\n             sizeof(bits_dc_chrominance)) ||\n      memcmp(cinfo->dc_huff_tbl_ptrs[1]->huffval, val_dc_chrominance,\n             sizeof(val_dc_chrominance)) ||\n      memcmp(cinfo->ac_huff_tbl_ptrs[1]->bits, bits_ac_chrominance,\n             sizeof(bits_ac_chrominance)) ||\n      memcmp(cinfo->ac_huff_tbl_ptrs[1]->huffval, val_ac_chrominance,\n             sizeof(val_ac_chrominance)))\n    return FALSE;\n\n  return TRUE;\n}\n\n\nLOCAL(void)\ninitial_setup(j_compress_ptr cinfo, boolean transcode_only)\n/* Do computations that are needed before master selection phase */\n{\n  int ci;\n  jpeg_component_info *compptr;\n  long samplesperrow;\n  JDIMENSION jd_samplesperrow;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n#if JPEG_LIB_VERSION >= 70\n#if JPEG_LIB_VERSION >= 80\n  if (!transcode_only)\n#endif\n    jpeg_calc_jpeg_dimensions(cinfo);\n#endif\n\n  /* Sanity check on image dimensions */\n  if (cinfo->_jpeg_height <= 0 || cinfo->_jpeg_width <= 0 ||\n      cinfo->num_components <= 0 || cinfo->input_components <= 0)\n    ERREXIT(cinfo, JERR_EMPTY_IMAGE);\n\n  /* Make sure image isn't bigger than I can handle */\n  if ((long)cinfo->_jpeg_height > (long)JPEG_MAX_DIMENSION ||\n      (long)cinfo->_jpeg_width > (long)JPEG_MAX_DIMENSION)\n    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int)JPEG_MAX_DIMENSION);\n\n  /* Width of an input scanline must be representable as JDIMENSION. */\n  samplesperrow = (long)cinfo->image_width * (long)cinfo->input_components;\n  jd_samplesperrow = (JDIMENSION)samplesperrow;\n  if ((long)jd_samplesperrow != samplesperrow)\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n\n#ifdef C_LOSSLESS_SUPPORTED\n  if (cinfo->data_precision != 8 && cinfo->data_precision != 12 &&\n      cinfo->data_precision != 16)\n#else\n  if (cinfo->data_precision != 8 && cinfo->data_precision != 12)\n#endif\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Check that number of components won't exceed internal array sizes */\n  if (cinfo->num_components > MAX_COMPONENTS)\n    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,\n             MAX_COMPONENTS);\n\n  /* Compute maximum sampling factors; check factor validity */\n  cinfo->max_h_samp_factor = 1;\n  cinfo->max_v_samp_factor = 1;\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    if (compptr->h_samp_factor <= 0 ||\n        compptr->h_samp_factor > MAX_SAMP_FACTOR ||\n        compptr->v_samp_factor <= 0 ||\n        compptr->v_samp_factor > MAX_SAMP_FACTOR)\n      ERREXIT(cinfo, JERR_BAD_SAMPLING);\n    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,\n                                   compptr->h_samp_factor);\n    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,\n                                   compptr->v_samp_factor);\n  }\n\n  /* Compute dimensions of components */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Fill in the correct component_index value; don't rely on application */\n    compptr->component_index = ci;\n    /* For compression, we never do DCT scaling. */\n#if JPEG_LIB_VERSION >= 70\n    compptr->DCT_h_scaled_size = compptr->DCT_v_scaled_size = data_unit;\n#else\n    compptr->DCT_scaled_size = data_unit;\n#endif\n    /* Size in data units */\n    compptr->width_in_blocks = (JDIMENSION)\n      jdiv_round_up((long)cinfo->_jpeg_width * (long)compptr->h_samp_factor,\n                    (long)(cinfo->max_h_samp_factor * data_unit));\n    compptr->height_in_blocks = (JDIMENSION)\n      jdiv_round_up((long)cinfo->_jpeg_height * (long)compptr->v_samp_factor,\n                    (long)(cinfo->max_v_samp_factor * data_unit));\n    /* Size in samples */\n    compptr->downsampled_width = (JDIMENSION)\n      jdiv_round_up((long)cinfo->_jpeg_width * (long)compptr->h_samp_factor,\n                    (long)cinfo->max_h_samp_factor);\n    compptr->downsampled_height = (JDIMENSION)\n      jdiv_round_up((long)cinfo->_jpeg_height * (long)compptr->v_samp_factor,\n                    (long)cinfo->max_v_samp_factor);\n    /* Mark component needed (this flag isn't actually used for compression) */\n    compptr->component_needed = TRUE;\n  }\n\n  /* Compute number of fully interleaved MCU rows (number of times that\n   * main controller will call coefficient or difference controller).\n   */\n  cinfo->total_iMCU_rows = (JDIMENSION)\n    jdiv_round_up((long)cinfo->_jpeg_height,\n                  (long)(cinfo->max_v_samp_factor * data_unit));\n}\n\n\n#if defined(C_MULTISCAN_FILES_SUPPORTED) || defined(C_LOSSLESS_SUPPORTED)\n#define NEED_SCAN_SCRIPT\n#endif\n\n#ifdef NEED_SCAN_SCRIPT\n\nLOCAL(void)\nvalidate_script(j_compress_ptr cinfo)\n/* Verify that the scan script in cinfo->scan_info[] is valid; also\n * determine whether it uses progressive JPEG, and set cinfo->progressive_mode.\n */\n{\n  const jpeg_scan_info *scanptr;\n  int scanno, ncomps, ci, coefi, thisi;\n  int Ss, Se, Ah, Al;\n  boolean component_sent[MAX_COMPONENTS];\n#ifdef C_PROGRESSIVE_SUPPORTED\n  int *last_bitpos_ptr;\n  int last_bitpos[MAX_COMPONENTS][DCTSIZE2];\n  /* -1 until that coefficient has been seen; then last Al for it */\n#endif\n\n  if (cinfo->master->optimize_scans) {\n    cinfo->progressive_mode = TRUE;\n    /* When we optimize scans, there is redundancy in the scan list\n     * and this function will fail. Therefore skip all this checking\n     */\n    return;\n  }\n  \n  if (cinfo->num_scans <= 0)\n    ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, 0);\n\n#ifndef C_MULTISCAN_FILES_SUPPORTED\n  if (cinfo->num_scans > 1)\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n\n  scanptr = cinfo->scan_info;\n  if (scanptr->Ss != 0 && scanptr->Se == 0) {\n#ifdef C_LOSSLESS_SUPPORTED\n    cinfo->master->lossless = TRUE;\n    cinfo->progressive_mode = FALSE;\n    for (ci = 0; ci < cinfo->num_components; ci++)\n      component_sent[ci] = FALSE;\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  }\n  /* For sequential JPEG, all scans must have Ss=0, Se=DCTSIZE2-1;\n   * for progressive JPEG, no scan can have this.\n   */\n  else if (scanptr->Ss != 0 || scanptr->Se != DCTSIZE2 - 1) {\n#ifdef C_PROGRESSIVE_SUPPORTED\n    cinfo->progressive_mode = TRUE;\n    cinfo->master->lossless = FALSE;\n    last_bitpos_ptr = &last_bitpos[0][0];\n    for (ci = 0; ci < cinfo->num_components; ci++)\n      for (coefi = 0; coefi < DCTSIZE2; coefi++)\n        *last_bitpos_ptr++ = -1;\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    cinfo->progressive_mode = cinfo->master->lossless = FALSE;\n    for (ci = 0; ci < cinfo->num_components; ci++)\n      component_sent[ci] = FALSE;\n  }\n\n  for (scanno = 1; scanno <= cinfo->num_scans; scanptr++, scanno++) {\n    /* Validate component indexes */\n    ncomps = scanptr->comps_in_scan;\n    if (ncomps <= 0 || ncomps > MAX_COMPS_IN_SCAN)\n      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, ncomps, MAX_COMPS_IN_SCAN);\n    for (ci = 0; ci < ncomps; ci++) {\n      thisi = scanptr->component_index[ci];\n      if (thisi < 0 || thisi >= cinfo->num_components)\n        ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, scanno);\n      /* Components must appear in SOF order within each scan */\n      if (ci > 0 && thisi <= scanptr->component_index[ci - 1])\n        ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, scanno);\n    }\n    /* Validate progression parameters */\n    Ss = scanptr->Ss;\n    Se = scanptr->Se;\n    Ah = scanptr->Ah;\n    Al = scanptr->Al;\n    if (cinfo->progressive_mode) {\n#ifdef C_PROGRESSIVE_SUPPORTED\n      /* Rec. ITU-T T.81 | ISO/IEC 10918-1 simply gives the ranges 0..13 for Ah\n       * and Al, but that seems wrong: the upper bound ought to depend on data\n       * precision.  Perhaps they really meant 0..N+1 for N-bit precision.\n       * Here we allow 0..10 for 8-bit data; Al larger than 10 results in\n       * out-of-range reconstructed DC values during the first DC scan,\n       * which might cause problems for some decoders.\n       */\n      int max_Ah_Al = cinfo->data_precision == 12 ? 13 : 10;\n\n      if (Ss < 0 || Ss >= DCTSIZE2 || Se < Ss || Se >= DCTSIZE2 ||\n          Ah < 0 || Ah > max_Ah_Al || Al < 0 || Al > max_Ah_Al)\n        ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);\n      if (Ss == 0) {\n        if (Se != 0)            /* DC and AC together not OK */\n          ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);\n      } else {\n        if (ncomps != 1)        /* AC scans must be for only one component */\n          ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);\n      }\n      for (ci = 0; ci < ncomps; ci++) {\n        last_bitpos_ptr = &last_bitpos[scanptr->component_index[ci]][0];\n        if (Ss != 0 && last_bitpos_ptr[0] < 0) /* AC without prior DC scan */\n          ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);\n        for (coefi = Ss; coefi <= Se; coefi++) {\n          if (last_bitpos_ptr[coefi] < 0) {\n            /* first scan of this coefficient */\n            if (Ah != 0)\n              ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);\n          } else {\n            /* not first scan */\n            if (Ah != last_bitpos_ptr[coefi] || Al != Ah - 1)\n              ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);\n          }\n          last_bitpos_ptr[coefi] = Al;\n        }\n      }\n#endif\n    } else {\n#ifdef C_LOSSLESS_SUPPORTED\n      if (cinfo->master->lossless) {\n        /* The JPEG spec simply gives the range 0..15 for Al (Pt), but that\n         * seems wrong: the upper bound ought to depend on data precision.\n         * Perhaps they really meant 0..N-1 for N-bit precision, which is what\n         * we allow here.  Values greater than or equal to the data precision\n         * will result in a blank image.\n         */\n        if (Ss < 1 || Ss > 7 ||         /* predictor selection value */\n            Se != 0 || Ah != 0 ||\n            Al < 0 || Al >= cinfo->data_precision) /* point transform */\n          ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);\n      } else\n#endif\n      {\n        /* For sequential JPEG, all progression parameters must be these: */\n        if (Ss != 0 || Se != DCTSIZE2 - 1 || Ah != 0 || Al != 0)\n          ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);\n      }\n      /* Make sure components are not sent twice */\n      for (ci = 0; ci < ncomps; ci++) {\n        thisi = scanptr->component_index[ci];\n        if (component_sent[thisi])\n          ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, scanno);\n        component_sent[thisi] = TRUE;\n      }\n    }\n  }\n\n  /* Now verify that everything got sent. */\n  if (cinfo->progressive_mode) {\n#ifdef C_PROGRESSIVE_SUPPORTED\n    /* For progressive mode, we only check that at least some DC data\n     * got sent for each component; the spec does not require that all bits\n     * of all coefficients be transmitted.  Would it be wiser to enforce\n     * transmission of all coefficient bits??\n     */\n    for (ci = 0; ci < cinfo->num_components; ci++) {\n      if (last_bitpos[ci][0] < 0)\n        ERREXIT(cinfo, JERR_MISSING_DATA);\n    }\n#endif\n  } else {\n    for (ci = 0; ci < cinfo->num_components; ci++) {\n      if (!component_sent[ci])\n        ERREXIT(cinfo, JERR_MISSING_DATA);\n    }\n  }\n}\n\n#endif /* NEED_SCAN_SCRIPT */\n\n\nLOCAL(void)\nselect_scan_parameters(j_compress_ptr cinfo)\n/* Set up the scan parameters for the current scan */\n{\n  int ci;\n\n#ifdef NEED_SCAN_SCRIPT\n  my_master_ptr master = (my_master_ptr) cinfo->master;\n  if (master->pass_number < master->pass_number_scan_opt_base) {\n    cinfo->comps_in_scan = 1;\n    if (cinfo->master->use_scans_in_trellis) {\n      cinfo->cur_comp_info[0] =\n        &cinfo->comp_info[master->pass_number / \n                          (4 * cinfo->master->trellis_num_loops)];\n      cinfo->Ss = (master->pass_number % 4 < 2) ?\n                  1 : cinfo->master->trellis_freq_split + 1;\n      cinfo->Se = (master->pass_number % 4 < 2) ?\n                  cinfo->master->trellis_freq_split : DCTSIZE2 - 1;\n    } else {\n      cinfo->cur_comp_info[0] =\n        &cinfo->comp_info[master->pass_number /\n                          (2 * cinfo->master->trellis_num_loops)];\n      cinfo->Ss = 1;\n      cinfo->Se = DCTSIZE2-1;\n    }\n  }\n  else if (cinfo->scan_info != NULL) {\n    /* Prepare for current scan --- the script is already validated */\n    const jpeg_scan_info *scanptr = cinfo->scan_info + master->scan_number;\n\n    cinfo->comps_in_scan = scanptr->comps_in_scan;\n    for (ci = 0; ci < scanptr->comps_in_scan; ci++) {\n      cinfo->cur_comp_info[ci] =\n        &cinfo->comp_info[scanptr->component_index[ci]];\n    }\n    cinfo->Ss = scanptr->Ss;\n    cinfo->Se = scanptr->Se;\n    cinfo->Ah = scanptr->Ah;\n    cinfo->Al = scanptr->Al;\n    if (cinfo->master->optimize_scans) {\n      /* luma frequency split passes */\n      if (master->scan_number >= cinfo->master->num_scans_luma_dc +\n                                 3 * cinfo->master->Al_max_luma + 2 &&\n          master->scan_number < cinfo->master->num_scans_luma)\n        cinfo->Al = master->best_Al_luma;\n      /* chroma frequency split passes */\n      if (master->scan_number >= cinfo->master->num_scans_luma +\n                                 cinfo->master->num_scans_chroma_dc +\n                                 (6 * cinfo->master->Al_max_chroma + 4) &&\n          master->scan_number < cinfo->num_scans)\n        cinfo->Al = master->best_Al_chroma;\n  }\n    /* save value for later retrieval during printout of scans */\n    master->actual_Al[master->scan_number] = cinfo->Al;\n  } else\n#endif\n  {\n    /* Prepare for single sequential-JPEG scan containing all components */\n    if (cinfo->num_components > MAX_COMPS_IN_SCAN)\n      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,\n               MAX_COMPS_IN_SCAN);\n    cinfo->comps_in_scan = cinfo->num_components;\n    for (ci = 0; ci < cinfo->num_components; ci++) {\n      cinfo->cur_comp_info[ci] = &cinfo->comp_info[ci];\n    }\n    if (!cinfo->master->lossless) {\n      cinfo->Ss = 0;\n      cinfo->Se = DCTSIZE2 - 1;\n      cinfo->Ah = 0;\n      cinfo->Al = 0;\n    }\n  }\n}\n\n\nLOCAL(void)\nper_scan_setup(j_compress_ptr cinfo)\n/* Do computations that are needed before processing a JPEG scan */\n/* cinfo->comps_in_scan and cinfo->cur_comp_info[] are already set */\n{\n  int ci, mcublks, tmp;\n  jpeg_component_info *compptr;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n  if (cinfo->comps_in_scan == 1) {\n\n    /* Noninterleaved (single-component) scan */\n    compptr = cinfo->cur_comp_info[0];\n\n    /* Overall image size in MCUs */\n    cinfo->MCUs_per_row = compptr->width_in_blocks;\n    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;\n\n    /* For noninterleaved scan, always one block per MCU */\n    compptr->MCU_width = 1;\n    compptr->MCU_height = 1;\n    compptr->MCU_blocks = 1;\n    compptr->MCU_sample_width = data_unit;\n    compptr->last_col_width = 1;\n    /* For noninterleaved scans, it is convenient to define last_row_height\n     * as the number of block rows present in the last iMCU row.\n     */\n    tmp = (int)(compptr->height_in_blocks % compptr->v_samp_factor);\n    if (tmp == 0) tmp = compptr->v_samp_factor;\n    compptr->last_row_height = tmp;\n\n    /* Prepare array describing MCU composition */\n    cinfo->blocks_in_MCU = 1;\n    cinfo->MCU_membership[0] = 0;\n\n  } else {\n\n    /* Interleaved (multi-component) scan */\n    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)\n      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,\n               MAX_COMPS_IN_SCAN);\n\n    /* Overall image size in MCUs */\n    cinfo->MCUs_per_row = (JDIMENSION)\n      jdiv_round_up((long)cinfo->_jpeg_width,\n                    (long)(cinfo->max_h_samp_factor * data_unit));\n    cinfo->MCU_rows_in_scan = (JDIMENSION)\n      jdiv_round_up((long)cinfo->_jpeg_height,\n                    (long)(cinfo->max_v_samp_factor * data_unit));\n\n    cinfo->blocks_in_MCU = 0;\n\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n      compptr = cinfo->cur_comp_info[ci];\n      /* Sampling factors give # of blocks of component in each MCU */\n      compptr->MCU_width = compptr->h_samp_factor;\n      compptr->MCU_height = compptr->v_samp_factor;\n      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;\n      compptr->MCU_sample_width = compptr->MCU_width * data_unit;\n      /* Figure number of non-dummy blocks in last MCU column & row */\n      tmp = (int)(compptr->width_in_blocks % compptr->MCU_width);\n      if (tmp == 0) tmp = compptr->MCU_width;\n      compptr->last_col_width = tmp;\n      tmp = (int)(compptr->height_in_blocks % compptr->MCU_height);\n      if (tmp == 0) tmp = compptr->MCU_height;\n      compptr->last_row_height = tmp;\n      /* Prepare array describing MCU composition */\n      mcublks = compptr->MCU_blocks;\n      if (cinfo->blocks_in_MCU + mcublks > C_MAX_BLOCKS_IN_MCU)\n        ERREXIT(cinfo, JERR_BAD_MCU_SIZE);\n      while (mcublks-- > 0) {\n        cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;\n      }\n    }\n\n  }\n\n  /* Convert restart specified in rows to actual MCU count. */\n  /* Note that count must fit in 16 bits, so we provide limiting. */\n  if (cinfo->restart_in_rows > 0) {\n    long nominal = (long)cinfo->restart_in_rows * (long)cinfo->MCUs_per_row;\n    cinfo->restart_interval = (unsigned int)MIN(nominal, 65535L);\n  }\n}\n\n\n/*\n * Per-pass setup.\n * This is called at the beginning of each pass.  We determine which modules\n * will be active during this pass and give them appropriate start_pass calls.\n * We also set is_last_pass to indicate whether any more passes will be\n * required.\n */\n\nMETHODDEF(void)\nprepare_for_pass(j_compress_ptr cinfo)\n{\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  cinfo->master->trellis_passes =\n    master->pass_number < master->pass_number_scan_opt_base;\n\n  switch (master->pass_type) {\n  case main_pass:\n    /* Initial pass: will collect input data, and do either Huffman\n     * optimization or data output for the first scan.\n     */\n    select_scan_parameters(cinfo);\n    per_scan_setup(cinfo);\n    if (!cinfo->raw_data_in) {\n      (*cinfo->cconvert->start_pass) (cinfo);\n      (*cinfo->downsample->start_pass) (cinfo);\n      (*cinfo->prep->start_pass) (cinfo, JBUF_PASS_THRU);\n    }\n    (*cinfo->fdct->start_pass) (cinfo);\n    (*cinfo->entropy->start_pass) (cinfo, (cinfo->optimize_coding || cinfo->master->trellis_quant) && !cinfo->arith_code);\n    (*cinfo->coef->start_pass) (cinfo,\n                                (master->total_passes > 1 ?\n                                 JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));\n    (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);\n    if (cinfo->optimize_coding || cinfo->master->trellis_quant) {\n      /* No immediate data output; postpone writing frame/scan headers */\n      master->pub.call_pass_startup = FALSE;\n    } else {\n      /* Will write frame/scan headers at first jpeg_write_scanlines call */\n      master->pub.call_pass_startup = TRUE;\n    }\n    break;\n#ifdef ENTROPY_OPT_SUPPORTED\n  case huff_opt_pass:\n    /* Do Huffman optimization for a scan after the first one. */\n    select_scan_parameters(cinfo);\n    per_scan_setup(cinfo);\n    if (cinfo->Ss != 0 || cinfo->Ah == 0 || cinfo->arith_code ||\n        cinfo->master->lossless) {\n      (*cinfo->entropy->start_pass) (cinfo, TRUE);\n      (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);\n      master->pub.call_pass_startup = FALSE;\n      break;\n    }\n    /* Special case: Huffman DC refinement scans need no Huffman table\n     * and therefore we can skip the optimization pass for them.\n     */\n    master->pass_type = output_pass;\n    master->pass_number++;\n#endif\n    FALLTHROUGH                 /*FALLTHROUGH*/\n  case output_pass:\n    /* Do a data-output pass. */\n    /* We need not repeat per-scan setup if prior optimization pass did it. */\n    if (!cinfo->optimize_coding) {\n      select_scan_parameters(cinfo);\n      per_scan_setup(cinfo);\n    }\n    if (cinfo->master->optimize_scans) {\n      master->saved_dest = cinfo->dest;\n      cinfo->dest = NULL;\n      master->scan_size[master->scan_number] = 0;\n      jpeg_mem_dest_internal(cinfo, &master->scan_buffer[master->scan_number], &master->scan_size[master->scan_number], JPOOL_IMAGE);\n      (*cinfo->dest->init_destination)(cinfo);\n    }\n    (*cinfo->entropy->start_pass) (cinfo, FALSE);\n    (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);\n    /* We emit frame/scan headers now */\n    if (master->scan_number == 0)\n      (*cinfo->marker->write_frame_header) (cinfo);\n    (*cinfo->marker->write_scan_header) (cinfo);\n    master->pub.call_pass_startup = FALSE;\n    break;\n  case trellis_pass:\n    if (master->pass_number %\n        (cinfo->num_components * (cinfo->master->use_scans_in_trellis ? 4 : 2)) == 1 &&\n        cinfo->master->trellis_q_opt) {\n      int i, j;\n\n      for (i = 0; i < NUM_QUANT_TBLS; i++) {\n        for (j = 1; j < DCTSIZE2; j++) {\n          cinfo->master->norm_src[i][j] = 0.0;\n          cinfo->master->norm_coef[i][j] = 0.0;\n        }\n      }\n    }\n    (*cinfo->entropy->start_pass) (cinfo, !cinfo->arith_code);\n    (*cinfo->coef->start_pass) (cinfo, JBUF_REQUANT);\n    master->pub.call_pass_startup = FALSE;\n    break;\n      \n  default:\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n  }\n\n  master->pub.is_last_pass = (master->pass_number == master->total_passes - 1);\n\n  /* Set up progress monitor's pass info if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->completed_passes = master->pass_number;\n    cinfo->progress->total_passes = master->total_passes;\n  }\n}\n\n\n/*\n * Special start-of-pass hook.\n * This is called by jpeg_write_scanlines if call_pass_startup is TRUE.\n * In single-pass processing, we need this hook because we don't want to\n * write frame/scan headers during jpeg_start_compress; we want to let the\n * application write COM markers etc. between jpeg_start_compress and the\n * jpeg_write_scanlines loop.\n * In multi-pass processing, this routine is not used.\n */\n\nMETHODDEF(void)\npass_startup(j_compress_ptr cinfo)\n{\n  cinfo->master->call_pass_startup = FALSE; /* reset flag so call only once */\n\n  (*cinfo->marker->write_frame_header) (cinfo);\n  (*cinfo->marker->write_scan_header) (cinfo);\n}\n\n\nLOCAL(void)\ncopy_buffer (j_compress_ptr cinfo, int scan_idx)\n{\n  my_master_ptr master = (my_master_ptr) cinfo->master;\n  \n  unsigned long size = master->scan_size[scan_idx];\n  unsigned char * src = master->scan_buffer[scan_idx];\n  int i;\n  \n  if (cinfo->err->trace_level > 0) {\n    fprintf(stderr, \"SCAN \");\n    for (i = 0; i < cinfo->scan_info[scan_idx].comps_in_scan; i++)\n      fprintf(stderr, \"%s%d\", (i==0)?\"\":\",\", cinfo->scan_info[scan_idx].component_index[i]);\n    fprintf(stderr, \": %d %d\", cinfo->scan_info[scan_idx].Ss, cinfo->scan_info[scan_idx].Se);\n    fprintf(stderr, \" %d %d\", cinfo->scan_info[scan_idx].Ah, master->actual_Al[scan_idx]);\n    fprintf(stderr, \"\\n\");\n  }\n  \n  while (size >= cinfo->dest->free_in_buffer)\n  {\n    memcpy(cinfo->dest->next_output_byte, src, cinfo->dest->free_in_buffer);\n    src += cinfo->dest->free_in_buffer;\n    size -= cinfo->dest->free_in_buffer;\n    cinfo->dest->next_output_byte += cinfo->dest->free_in_buffer;\n    cinfo->dest->free_in_buffer = 0;\n    \n    if (!(*cinfo->dest->empty_output_buffer)(cinfo))\n      ERREXIT(cinfo, JERR_UNSUPPORTED_SUSPEND);\n  }\n\n  memcpy(cinfo->dest->next_output_byte, src, size);\n  cinfo->dest->next_output_byte += size;\n  cinfo->dest->free_in_buffer -= size;\n}\n\nLOCAL(void)\nselect_scans (j_compress_ptr cinfo, int next_scan_number)\n{\n  my_master_ptr master = (my_master_ptr) cinfo->master;\n  \n  int base_scan_idx = 0;\n  int luma_freq_split_scan_start = cinfo->master->num_scans_luma_dc +\n                                   3 * cinfo->master->Al_max_luma + 2;\n  int chroma_freq_split_scan_start = cinfo->master->num_scans_luma +\n                                     cinfo->master->num_scans_chroma_dc +\n                                     (6 * cinfo->master->Al_max_chroma + 4);\n  int passes_per_scan = cinfo->optimize_coding ? 2 : 1;\n  \n  if (next_scan_number > 1 && next_scan_number <= luma_freq_split_scan_start) {\n    if ((next_scan_number - 1) % 3 == 2) {\n      int Al = (next_scan_number - 1) / 3;\n      int i;\n      unsigned long cost = 0;\n      cost += master->scan_size[next_scan_number-2];\n      cost += master->scan_size[next_scan_number-1];\n      for (i = 0; i < Al; i++)\n        cost += master->scan_size[3 + 3*i];\n      \n      if (Al == 0 || cost < master->best_cost) {\n        master->best_cost = cost;\n        master->best_Al_luma = Al;\n      } else {\n        master->scan_number = luma_freq_split_scan_start - 1;\n        master->pass_number = passes_per_scan * (master->scan_number + 1) - 1 + master->pass_number_scan_opt_base;\n      }\n    }\n  \n  } else if (next_scan_number > luma_freq_split_scan_start &&\n             next_scan_number <= cinfo->master->num_scans_luma) {\n    if (next_scan_number == luma_freq_split_scan_start + 1) {\n      master->best_freq_split_idx_luma = 0;\n      master->best_cost = master->scan_size[next_scan_number-1];\n      \n    } else if ((next_scan_number - luma_freq_split_scan_start) % 2 == 1) {\n      int idx = (next_scan_number - luma_freq_split_scan_start) >> 1;\n      unsigned long cost = 0;\n      cost += master->scan_size[next_scan_number-2];\n      cost += master->scan_size[next_scan_number-1];\n      \n      if (cost < master->best_cost) {\n        master->best_cost = cost;\n        master->best_freq_split_idx_luma = idx;\n      }\n      \n      /* if after testing first 3, no split is the best, don't search further */\n      if ((idx == 2 && master->best_freq_split_idx_luma == 0) ||\n          (idx == 3 && master->best_freq_split_idx_luma != 2) ||\n          (idx == 4 && master->best_freq_split_idx_luma != 4)) {\n        master->scan_number = cinfo->master->num_scans_luma - 1;\n        master->pass_number = passes_per_scan * (master->scan_number + 1) - 1 + master->pass_number_scan_opt_base;\n        master->pub.is_last_pass = (master->pass_number == master->total_passes - 1);\n      }\n    }\n    \n  } else if (cinfo->num_scans > cinfo->master->num_scans_luma) {\n\n    if (next_scan_number == cinfo->master->num_scans_luma + \n                            cinfo->master->num_scans_chroma_dc) {\n      base_scan_idx = cinfo->master->num_scans_luma;\n\n      master->interleave_chroma_dc = master->scan_size[base_scan_idx] <= master->scan_size[base_scan_idx+1] + master->scan_size[base_scan_idx+2];\n      \n    } else if (next_scan_number > cinfo->master->num_scans_luma +\n                                  cinfo->master->num_scans_chroma_dc &&\n               next_scan_number <= chroma_freq_split_scan_start) {\n      base_scan_idx = cinfo->master->num_scans_luma +\n                      cinfo->master->num_scans_chroma_dc;\n      if ((next_scan_number - base_scan_idx) % 6 == 4) {\n        int Al = (next_scan_number - base_scan_idx) / 6;\n        int i;\n        unsigned long cost = 0;\n        cost += master->scan_size[next_scan_number-4];\n        cost += master->scan_size[next_scan_number-3];\n        cost += master->scan_size[next_scan_number-2];\n        cost += master->scan_size[next_scan_number-1];\n        for (i = 0; i < Al; i++) {\n          cost += master->scan_size[base_scan_idx + 4 + 6*i];\n          cost += master->scan_size[base_scan_idx + 5 + 6*i];\n        }\n        \n        if (Al == 0 || cost < master->best_cost) {\n          master->best_cost = cost;\n          master->best_Al_chroma = Al;\n        } else {\n          master->scan_number = chroma_freq_split_scan_start - 1;\n          master->pass_number = passes_per_scan * (master->scan_number + 1) - 1 + master->pass_number_scan_opt_base;\n        }\n      }\n\n    } else if (next_scan_number > chroma_freq_split_scan_start && next_scan_number <= cinfo->num_scans) {\n      if (next_scan_number == chroma_freq_split_scan_start + 2) {\n        master->best_freq_split_idx_chroma = 0;\n        master->best_cost  = master->scan_size[next_scan_number-2];\n        master->best_cost += master->scan_size[next_scan_number-1];\n        \n      } else if ((next_scan_number - chroma_freq_split_scan_start) % 4 == 2) {\n        int idx = (next_scan_number - chroma_freq_split_scan_start) >> 2;\n        unsigned long cost = 0;\n        cost += master->scan_size[next_scan_number-4];\n        cost += master->scan_size[next_scan_number-3];\n        cost += master->scan_size[next_scan_number-2];\n        cost += master->scan_size[next_scan_number-1];\n        \n        if (cost < master->best_cost) {\n          master->best_cost = cost;\n          master->best_freq_split_idx_chroma = idx;\n        }\n        \n        /* if after testing first 3, no split is the best, don't search further */\n        if ((idx == 2 && master->best_freq_split_idx_chroma == 0) ||\n            (idx == 3 && master->best_freq_split_idx_chroma != 2) ||\n            (idx == 4 && master->best_freq_split_idx_chroma != 4)) {\n          master->scan_number = cinfo->num_scans - 1;\n          master->pass_number = passes_per_scan * (master->scan_number + 1) - 1 + master->pass_number_scan_opt_base;\n          master->pub.is_last_pass = (master->pass_number == master->total_passes - 1);\n        }\n      }\n    }\n  }\n  \n  if (master->scan_number == cinfo->num_scans - 1) {\n    int i, Al;\n    int min_Al = MIN(master->best_Al_luma, master->best_Al_chroma);\n    \n    copy_buffer(cinfo, 0);\n\n    if (cinfo->num_scans > cinfo->master->num_scans_luma &&\n        cinfo->master->dc_scan_opt_mode != 0) {\n      base_scan_idx = cinfo->master->num_scans_luma;\n      \n      if (master->interleave_chroma_dc && cinfo->master->dc_scan_opt_mode != 1)\n        copy_buffer(cinfo, base_scan_idx);\n      else {\n        copy_buffer(cinfo, base_scan_idx+1);\n        copy_buffer(cinfo, base_scan_idx+2);\n      }\n    }\n    \n    if (master->best_freq_split_idx_luma == 0)\n      copy_buffer(cinfo, luma_freq_split_scan_start);\n    else {\n      copy_buffer(cinfo, luma_freq_split_scan_start+2*(master->best_freq_split_idx_luma-1)+1);\n      copy_buffer(cinfo, luma_freq_split_scan_start+2*(master->best_freq_split_idx_luma-1)+2);\n    }\n    \n    /* copy the LSB refinements as well */\n    for (Al = master->best_Al_luma-1; Al >= min_Al; Al--)\n      copy_buffer(cinfo, 3 + 3*Al);\n\n    if (cinfo->num_scans > cinfo->master->num_scans_luma) {\n      if (master->best_freq_split_idx_chroma == 0) {\n        copy_buffer(cinfo, chroma_freq_split_scan_start);\n        copy_buffer(cinfo, chroma_freq_split_scan_start+1);\n      }\n      else {\n        copy_buffer(cinfo, chroma_freq_split_scan_start+4*(master->best_freq_split_idx_chroma-1)+2);\n        copy_buffer(cinfo, chroma_freq_split_scan_start+4*(master->best_freq_split_idx_chroma-1)+3);\n        copy_buffer(cinfo, chroma_freq_split_scan_start+4*(master->best_freq_split_idx_chroma-1)+4);\n        copy_buffer(cinfo, chroma_freq_split_scan_start+4*(master->best_freq_split_idx_chroma-1)+5);\n      }\n      \n      base_scan_idx = cinfo->master->num_scans_luma +\n                      cinfo->master->num_scans_chroma_dc;\n      \n      for (Al = master->best_Al_chroma-1; Al >= min_Al; Al--) {\n        copy_buffer(cinfo, base_scan_idx + 6*Al + 4);\n        copy_buffer(cinfo, base_scan_idx + 6*Al + 5);\n      }\n    }\n    \n    for (Al = min_Al-1; Al >= 0; Al--) {\n      copy_buffer(cinfo, 3 + 3*Al);\n      \n      if (cinfo->num_scans > cinfo->master->num_scans_luma) {\n        copy_buffer(cinfo, base_scan_idx + 6*Al + 4);\n        copy_buffer(cinfo, base_scan_idx + 6*Al + 5);\n      }\n    }\n    \n    /* free the memory allocated for buffers */\n    for (i = 0; i < cinfo->num_scans; i++)\n      if (master->scan_buffer[i])\n        free(master->scan_buffer[i]);\n  }\n}\n\n/*\n * Finish up at end of pass.\n */\n\nMETHODDEF(void)\nfinish_pass_master(j_compress_ptr cinfo)\n{\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n\n  /* The entropy coder always needs an end-of-pass call,\n   * either to analyze statistics or to flush its output buffer.\n   */\n  (*cinfo->entropy->finish_pass) (cinfo);\n\n  /* Update state for next pass */\n  switch (master->pass_type) {\n  case main_pass:\n    /* next pass is either output of scan 0 (after optimization)\n     * or output of scan 1 (if no optimization).\n     */\n    if (cinfo->master->trellis_quant)\n      master->pass_type = trellis_pass;\n    else {\n    master->pass_type = output_pass;\n    if (!cinfo->optimize_coding)\n      master->scan_number++;\n    }\n    break;\n  case huff_opt_pass:\n    /* next pass is always output of current scan */\n    master->pass_type = (master->pass_number < master->pass_number_scan_opt_base-1) ? trellis_pass : output_pass;\n    break;\n  case output_pass:\n    /* next pass is either optimization or output of next scan */\n    if (cinfo->optimize_coding)\n      master->pass_type = huff_opt_pass;\n    if (cinfo->master->optimize_scans) {\n      (*cinfo->dest->term_destination)(cinfo);\n      cinfo->dest = master->saved_dest;\n      select_scans(cinfo, master->scan_number + 1);\n    }\n\n    master->scan_number++;\n    break;\n  case trellis_pass:\n    if (cinfo->optimize_coding)\n      master->pass_type = huff_opt_pass;\n    else\n      master->pass_type = (master->pass_number < master->pass_number_scan_opt_base-1) ? trellis_pass : output_pass;\n      \n    if ((master->pass_number + 1) %\n        (cinfo->num_components * (cinfo->master->use_scans_in_trellis ? 4 : 2)) == 0 &&\n        cinfo->master->trellis_q_opt) {\n      int i, j;\n\n      for (i = 0; i < NUM_QUANT_TBLS; i++) {\n        for (j = 1; j < DCTSIZE2; j++) {\n          if (cinfo->master->norm_coef[i][j] != 0.0) {\n            int q = (int)(cinfo->master->norm_src[i][j] /\n                          cinfo->master->norm_coef[i][j] + 0.5);\n            if (q > 254) q = 254;\n            if (q < 1) q = 1;\n            cinfo->quant_tbl_ptrs[i]->quantval[j] = q;\n  }\n  }\n      }\n    }\n    break;\n  }\n\n  master->pass_number++;\n}\n\n\n/*\n * Initialize master compression control.\n */\n\nGLOBAL(void)\njinit_c_master_control(j_compress_ptr cinfo, boolean transcode_only)\n{\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  boolean empty_huff_tables = TRUE;\n  int i;\n\n  master->pub.prepare_for_pass = prepare_for_pass;\n  master->pub.pass_startup = pass_startup;\n  master->pub.finish_pass = finish_pass_master;\n  master->pub.is_last_pass = FALSE;\n  master->pub.call_pass_startup = FALSE;\n\n  if (cinfo->scan_info != NULL) {\n#ifdef NEED_SCAN_SCRIPT\n    validate_script(cinfo);\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    cinfo->progressive_mode = FALSE;\n    cinfo->num_scans = 1;\n  }\n\n#ifdef C_LOSSLESS_SUPPORTED\n  /* Disable smoothing and subsampling in lossless mode, since those are lossy\n   * algorithms.  Set the JPEG colorspace to the input colorspace.  Disable raw\n   * (downsampled) data input, because it isn't particularly useful without\n   * subsampling and has not been tested in lossless mode.\n   */\n  if (cinfo->master->lossless) {\n    int ci;\n    jpeg_component_info *compptr;\n\n    cinfo->raw_data_in = FALSE;\n    cinfo->smoothing_factor = 0;\n    jpeg_default_colorspace(cinfo);\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++)\n      compptr->h_samp_factor = compptr->v_samp_factor = 1;\n  }\n#endif\n\n  /* Validate parameters, determine derived values */\n  initial_setup(cinfo, transcode_only);\n\n  if (cinfo->arith_code)\n    cinfo->optimize_coding = FALSE;\n  else {\n    if (cinfo->master->lossless ||      /*  TEMPORARY HACK ??? */\n        cinfo->progressive_mode)\n      cinfo->optimize_coding = TRUE; /* assume default tables no good for\n                                        progressive mode or lossless mode */\n    for (i = 0; i < NUM_HUFF_TBLS; i++) {\n      if (cinfo->dc_huff_tbl_ptrs[i] != NULL ||\n          cinfo->ac_huff_tbl_ptrs[i] != NULL) {\n        empty_huff_tables = FALSE;\n        break;\n      }\n    }\n    if (cinfo->data_precision == 12 && !cinfo->optimize_coding &&\n        (empty_huff_tables || using_std_huff_tables(cinfo)))\n      cinfo->optimize_coding = TRUE; /* assume default tables no good for\n                                        12-bit data precision */\n  }\n\n  /* Initialize my private state */\n  if (transcode_only) {\n    /* no main pass in transcoding */\n    if (cinfo->optimize_coding)\n      master->pass_type = huff_opt_pass;\n    else\n      master->pass_type = output_pass;\n  } else {\n    /* for normal compression, first pass is always this type: */\n    master->pass_type = main_pass;\n  }\n  master->scan_number = 0;\n  master->pass_number = 0;\n  if (cinfo->optimize_coding)\n    master->total_passes = cinfo->num_scans * 2;\n  else\n    master->total_passes = cinfo->num_scans;\n\n  master->jpeg_version = PACKAGE_NAME \" version \" VERSION \" (build \" BUILD \")\";\n  \n  master->pass_number_scan_opt_base = 0;\n  if (cinfo->master->trellis_quant) {\n    if (cinfo->optimize_coding)\n      master->pass_number_scan_opt_base =\n        ((cinfo->master->use_scans_in_trellis) ? 4 : 2) * cinfo->num_components *\n        cinfo->master->trellis_num_loops;\n    else\n      master->pass_number_scan_opt_base =\n        ((cinfo->master->use_scans_in_trellis) ? 2 : 1) * cinfo->num_components *\n        cinfo->master->trellis_num_loops + 1;\n    master->total_passes += master->pass_number_scan_opt_base;\n}\n  \n  if (cinfo->master->optimize_scans) {\n    int i;\n    master->best_Al_chroma = 0;\n    \n    for (i = 0; i < cinfo->num_scans; i++)\n      master->scan_buffer[i] = NULL;\n  }\n}\n"
        },
        {
          "name": "jcmaster.h",
          "type": "blob",
          "size": 2.2607421875,
          "content": "/*\n * jcmaster.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1995, Thomas G. Lane.\n * Copyright (C) 2014, Mozilla Corporation.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2016, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains master control structure for the JPEG compressor.\n */\n\n/* Private state */\n\ntypedef enum {\n  main_pass,                    /* input data, also do first output step */\n  huff_opt_pass,                /* Huffman code optimization pass */\n  output_pass,                  /* data output pass */\n  trellis_pass            /* trellis quantization pass */\n} c_pass_type;\n\ntypedef struct {\n  struct jpeg_comp_master pub;  /* public fields */\n\n  c_pass_type pass_type;        /* the type of the current pass */\n\n  int pass_number;              /* # of passes completed */\n  int total_passes;             /* total # of passes needed */\n\n  int scan_number;              /* current index in scan_info[] */\n\n  /* fields for scan optimisation */\n  int pass_number_scan_opt_base; /* pass number where scan optimization begins */\n  unsigned char * scan_buffer[64]; /* buffer for a given scan */\n  unsigned long scan_size[64]; /* size for a given scan */\n  int actual_Al[64]; /* actual value of Al used for a scan */\n  unsigned long best_cost; /* bit count for best frequency split */\n  int best_freq_split_idx_luma; /* index for best frequency split (luma) */\n  int best_freq_split_idx_chroma; /* index for best frequency split (chroma) */\n  int best_Al_luma; /* best value for Al found in scan search (luma) */\n  int best_Al_chroma; /* best value for Al found in scan search (luma) */\n  boolean interleave_chroma_dc; /* indicate whether to interleave chroma DC scans */\n  struct jpeg_destination_mgr * saved_dest; /* saved value of cinfo->dest */\n\n  /*\n   * This is here so we can add libjpeg-turbo version/build information to the\n   * global string table without introducing a new global symbol.  Adding this\n   * information to the global string table allows one to examine a binary\n   * object and determine which version of libjpeg-turbo it was built from or\n   * linked against.\n   */\n  const char *jpeg_version;\n} my_comp_master;\n\ntypedef my_comp_master *my_master_ptr;\n"
        },
        {
          "name": "jcomapi.c",
          "type": "blob",
          "size": 3.1982421875,
          "content": "/*\n * jcomapi.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains application interface routines that are used for both\n * compression and decompression.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n\n\n/*\n * Abort processing of a JPEG compression or decompression operation,\n * but don't destroy the object itself.\n *\n * For this, we merely clean up all the nonpermanent memory pools.\n * Note that temp files (virtual arrays) are not allowed to belong to\n * the permanent pool, so we will be able to close all temp files here.\n * Closing a data source or destination, if necessary, is the application's\n * responsibility.\n */\n\nGLOBAL(void)\njpeg_abort(j_common_ptr cinfo)\n{\n  int pool;\n\n  /* Do nothing if called on a not-initialized or destroyed JPEG object. */\n  if (cinfo->mem == NULL)\n    return;\n\n  /* Releasing pools in reverse order might help avoid fragmentation\n   * with some (brain-damaged) malloc libraries.\n   */\n  for (pool = JPOOL_NUMPOOLS - 1; pool > JPOOL_PERMANENT; pool--) {\n    (*cinfo->mem->free_pool) (cinfo, pool);\n  }\n\n  /* Reset overall state for possible reuse of object */\n  if (cinfo->is_decompressor) {\n    cinfo->global_state = DSTATE_START;\n    /* Try to keep application from accessing now-deleted marker list.\n     * A bit kludgy to do it here, but this is the most central place.\n     */\n    ((j_decompress_ptr)cinfo)->marker_list = NULL;\n    ((j_decompress_ptr)cinfo)->master->marker_list_end = NULL;\n  } else {\n    cinfo->global_state = CSTATE_START;\n  }\n}\n\n\n/*\n * Destruction of a JPEG object.\n *\n * Everything gets deallocated except the master jpeg_compress_struct itself\n * and the error manager struct.  Both of these are supplied by the application\n * and must be freed, if necessary, by the application.  (Often they are on\n * the stack and so don't need to be freed anyway.)\n * Closing a data source or destination, if necessary, is the application's\n * responsibility.\n */\n\nGLOBAL(void)\njpeg_destroy(j_common_ptr cinfo)\n{\n  /* We need only tell the memory manager to release everything. */\n  /* NB: mem pointer is NULL if memory mgr failed to initialize. */\n  if (cinfo->mem != NULL)\n    (*cinfo->mem->self_destruct) (cinfo);\n  cinfo->mem = NULL;            /* be safe if jpeg_destroy is called twice */\n  cinfo->global_state = 0;      /* mark it destroyed */\n}\n\n\n/*\n * Convenience routines for allocating quantization and Huffman tables.\n * (Would jutils.c be a more reasonable place to put these?)\n */\n\nGLOBAL(JQUANT_TBL *)\njpeg_alloc_quant_table(j_common_ptr cinfo)\n{\n  JQUANT_TBL *tbl;\n\n  tbl = (JQUANT_TBL *)\n    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, sizeof(JQUANT_TBL));\n  tbl->sent_table = FALSE;      /* make sure this is false in any new table */\n  return tbl;\n}\n\n\nGLOBAL(JHUFF_TBL *)\njpeg_alloc_huff_table(j_common_ptr cinfo)\n{\n  JHUFF_TBL *tbl;\n\n  tbl = (JHUFF_TBL *)\n    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, sizeof(JHUFF_TBL));\n  tbl->sent_table = FALSE;      /* make sure this is false in any new table */\n  return tbl;\n}\n"
        },
        {
          "name": "jconfig.h.in",
          "type": "blob",
          "size": 2.0751953125,
          "content": "/* Version ID for the JPEG library.\n * Might be useful for tests like \"#if JPEG_LIB_VERSION >= 60\".\n */\n#define JPEG_LIB_VERSION  @JPEG_LIB_VERSION@\n\n/* libjpeg-turbo version */\n#define LIBJPEG_TURBO_VERSION  @VERSION@\n\n/* libjpeg-turbo version in integer form */\n#define LIBJPEG_TURBO_VERSION_NUMBER  @LIBJPEG_TURBO_VERSION_NUMBER@\n\n/* Support arithmetic encoding when using 8-bit samples */\n#cmakedefine C_ARITH_CODING_SUPPORTED 1\n\n/* Support arithmetic decoding when using 8-bit samples */\n#cmakedefine D_ARITH_CODING_SUPPORTED 1\n\n/* Support in-memory source/destination managers */\n#define MEM_SRCDST_SUPPORTED  1\n\n/* Use accelerated SIMD routines when using 8-bit samples */\n#cmakedefine WITH_SIMD 1\n\n/* This version of libjpeg-turbo supports run-time selection of data precision,\n * so BITS_IN_JSAMPLE is no longer used to specify the data precision at build\n * time.  However, some downstream software expects the macro to be defined.\n * Since 12-bit data precision is an opt-in feature that requires explicitly\n * calling 12-bit-specific libjpeg API functions and using 12-bit-specific data\n * types, the unmodified portion of the libjpeg API still behaves as if it were\n * built for 8-bit precision, and JSAMPLE is still literally an 8-bit data\n * type.  Thus, it is correct to define BITS_IN_JSAMPLE to 8 here.\n */\n#ifndef BITS_IN_JSAMPLE\n#define BITS_IN_JSAMPLE  8\n#endif\n\n#ifdef _WIN32\n\n#undef RIGHT_SHIFT_IS_UNSIGNED\n\n/* Define \"boolean\" as unsigned char, not int, per Windows custom */\n#ifndef __RPCNDR_H__            /* don't conflict if rpcndr.h already read */\ntypedef unsigned char boolean;\n#endif\n#define HAVE_BOOLEAN            /* prevent jmorecfg.h from redefining it */\n\n/* Define \"INT32\" as int, not long, per Windows custom */\n#if !(defined(_BASETSD_H_) || defined(_BASETSD_H))   /* don't conflict if basetsd.h already read */\ntypedef short INT16;\ntypedef signed int INT32;\n#endif\n#define XMD_H                   /* prevent jmorecfg.h from redefining it */\n\n#else\n\n/* Define if your (broken) compiler shifts signed values as if they were\n   unsigned. */\n#cmakedefine RIGHT_SHIFT_IS_UNSIGNED 1\n\n#endif\n"
        },
        {
          "name": "jconfig.txt",
          "type": "blob",
          "size": 3.1123046875,
          "content": "/*\n * jconfig.txt\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1994, Thomas G. Lane.\n * It was modified by The libjpeg-turbo Project to include only code relevant\n * to libjpeg-turbo.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file documents the configuration options that are required to\n * customize the JPEG software for a particular system.\n *\n * The actual configuration options for a particular installation are stored\n * in jconfig.h.  On many machines, jconfig.h can be generated automatically\n * or copied from one of the \"canned\" jconfig files that we supply.  But if\n * you need to generate a jconfig.h file by hand, this file tells you how.\n *\n * DO NOT EDIT THIS FILE --- IT WON'T ACCOMPLISH ANYTHING.\n * EDIT A COPY NAMED JCONFIG.H.\n */\n\n\n/*\n * These symbols indicate the properties of your machine or compiler.\n * #define the symbol if yes, #undef it if no.\n */\n\n/* Define \"boolean\" as unsigned char, not int, on Windows systems.\n */\n#ifdef _WIN32\n#ifndef __RPCNDR_H__            /* don't conflict if rpcndr.h already read */\ntypedef unsigned char boolean;\n#endif\n#define HAVE_BOOLEAN            /* prevent jmorecfg.h from redefining it */\n#endif\n\n\n/*\n * The following options affect code selection within the JPEG library,\n * but they don't need to be visible to applications using the library.\n * To minimize application namespace pollution, the symbols won't be\n * defined unless JPEG_INTERNALS has been defined.\n */\n\n#ifdef JPEG_INTERNALS\n\n/* Define this if your compiler implements \">>\" on signed values as a logical\n * (unsigned) shift; leave it undefined if \">>\" is a signed (arithmetic) shift,\n * which is the normal and rational definition.\n */\n#undef RIGHT_SHIFT_IS_UNSIGNED\n\n\n#endif /* JPEG_INTERNALS */\n\n\n/*\n * The remaining options do not affect the JPEG library proper,\n * but only the sample applications cjpeg/djpeg (see cjpeg.c, djpeg.c).\n * Other applications can ignore these.\n */\n\n#ifdef JPEG_CJPEG_DJPEG\n\n/* These defines indicate which image (non-JPEG) file formats are allowed. */\n\n#define PNG_SUPPORTED           /* PNG image file format */\n#define BMP_SUPPORTED           /* BMP image file format */\n#define GIF_SUPPORTED           /* GIF image file format */\n#define PPM_SUPPORTED           /* PBMPLUS PPM/PGM image file format */\n#define TARGA_SUPPORTED         /* Targa image file format */\n\n/* Define this if you want to name both input and output files on the command\n * line, rather than using stdout and optionally stdin.  You MUST do this if\n * your system can't cope with binary I/O to stdin/stdout.  See comments at\n * head of cjpeg.c or djpeg.c.\n */\n#undef TWO_FILE_COMMANDLINE\n\n/* By default, we open image files with fopen(..., \"rb\") or fopen(..., \"wb\").\n * This is necessary on systems that distinguish text files from binary files,\n * and is harmless on most systems that don't.  If you have one of the rare\n * systems that complains about the \"b\" spec, define this symbol.\n */\n#undef DONT_USE_B_MODE\n\n/* Define this if you want percent-done progress reports from cjpeg/djpeg.\n */\n#undef PROGRESS_REPORT\n\n\n#endif /* JPEG_CJPEG_DJPEG */\n"
        },
        {
          "name": "jconfigint.h.in",
          "type": "blob",
          "size": 1.7568359375,
          "content": "/* libjpeg-turbo build number */\n#define BUILD  \"@BUILD@\"\n\n/* How to hide global symbols. */\n#define HIDDEN  @HIDDEN@\n\n/* Compiler's inline keyword */\n#undef inline\n\n/* How to obtain function inlining. */\n#define INLINE  @INLINE@\n\n/* How to obtain thread-local storage */\n#define THREAD_LOCAL  @THREAD_LOCAL@\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME  \"@CMAKE_PROJECT_NAME@\"\n\n/* Version number of package */\n#define VERSION  \"@VERSION@\"\n\n/* The size of `size_t', as computed by sizeof. */\n#define SIZEOF_SIZE_T  @SIZE_T@\n\n/* Define if your compiler has __builtin_ctzl() and sizeof(unsigned long) == sizeof(size_t). */\n#cmakedefine HAVE_BUILTIN_CTZL\n\n/* Define to 1 if you have the <intrin.h> header file. */\n#cmakedefine HAVE_INTRIN_H\n\n#if defined(_MSC_VER) && defined(HAVE_INTRIN_H)\n#if (SIZEOF_SIZE_T == 8)\n#define HAVE_BITSCANFORWARD64\n#elif (SIZEOF_SIZE_T == 4)\n#define HAVE_BITSCANFORWARD\n#endif\n#endif\n\n#if defined(__has_attribute)\n#if __has_attribute(fallthrough)\n#define FALLTHROUGH  __attribute__((fallthrough));\n#else\n#define FALLTHROUGH\n#endif\n#else\n#define FALLTHROUGH\n#endif\n\n/*\n * Define BITS_IN_JSAMPLE as either\n *   8   for 8-bit sample values (the usual setting)\n *   12  for 12-bit sample values\n * Only 8 and 12 are legal data precisions for lossy JPEG according to the\n * JPEG standard, and the IJG code does not support anything else!\n */\n\n#ifndef BITS_IN_JSAMPLE\n#define BITS_IN_JSAMPLE  8      /* use 8 or 12 */\n#endif\n\n#undef C_ARITH_CODING_SUPPORTED\n#undef D_ARITH_CODING_SUPPORTED\n#undef WITH_SIMD\n\n#if BITS_IN_JSAMPLE == 8\n\n/* Support arithmetic encoding */\n#cmakedefine C_ARITH_CODING_SUPPORTED 1\n\n/* Support arithmetic decoding */\n#cmakedefine D_ARITH_CODING_SUPPORTED 1\n\n/* Use accelerated SIMD routines. */\n#cmakedefine WITH_SIMD 1\n\n#endif\n"
        },
        {
          "name": "jcparam.c",
          "type": "blob",
          "size": 34.6083984375,
          "content": "/*\n * jcparam.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1998, Thomas G. Lane.\n * Modified 2003-2008 by Guido Vollbeding.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2009-2011, 2018, 2023-2024, D. R. Commander.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains optional default-setting code for the JPEG compressor.\n * Applications do not have to use this file, but those that don't use it\n * must know a lot more about the innards of the JPEG code.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jstdhuff.c\"\n\n\n/*\n * Quantization table setup routines\n */\n\nGLOBAL(void)\njpeg_add_quant_table(j_compress_ptr cinfo, int which_tbl,\n                     const unsigned int *basic_table, int scale_factor,\n                     boolean force_baseline)\n/* Define a quantization table equal to the basic_table times\n * a scale factor (given as a percentage).\n * If force_baseline is TRUE, the computed quantization table entries\n * are limited to 1..255 for JPEG baseline compatibility.\n */\n{\n  JQUANT_TBL **qtblptr;\n  int i;\n  long temp;\n\n  /* Safety check to ensure start_compress not called yet. */\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  if (which_tbl < 0 || which_tbl >= NUM_QUANT_TBLS)\n    ERREXIT1(cinfo, JERR_DQT_INDEX, which_tbl);\n\n  qtblptr = &cinfo->quant_tbl_ptrs[which_tbl];\n\n  if (*qtblptr == NULL)\n    *qtblptr = jpeg_alloc_quant_table((j_common_ptr)cinfo);\n\n  for (i = 0; i < DCTSIZE2; i++) {\n    temp = ((long)basic_table[i] * scale_factor + 50L) / 100L;\n    /* limit the values to the valid range */\n    if (temp <= 0L) temp = 1L;\n    if (temp > 32767L) temp = 32767L; /* max quantizer needed for 12 bits */\n    if (force_baseline && temp > 255L)\n      temp = 255L;              /* limit to baseline range if requested */\n    (*qtblptr)->quantval[i] = (UINT16)temp;\n  }\n\n  /* Initialize sent_table FALSE so table will be written to JPEG file. */\n  (*qtblptr)->sent_table = FALSE;\n}\n\n\n/* These are the sample quantization tables given in Annex K (Clause K.1) of\n * Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994.\n * The spec says that the values given produce \"good\" quality, and\n * when divided by 2, \"very good\" quality.\n */\nstatic const unsigned int std_luminance_quant_tbl[9][DCTSIZE2] = {\n  {\n    /* JPEG Annex K\n     */\n  16,  11,  10,  16,  24,  40,  51,  61,\n  12,  12,  14,  19,  26,  58,  60,  55,\n  14,  13,  16,  24,  40,  57,  69,  56,\n  14,  17,  22,  29,  51,  87,  80,  62,\n  18,  22,  37,  56,  68, 109, 103,  77,\n  24,  35,  55,  64,  81, 104, 113,  92,\n  49,  64,  78,  87, 103, 121, 120, 101,\n  72,  92,  95,  98, 112, 100, 103,  99\n  },\n  {\n    /* flat\n     */\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16\n  },\n  {\n    12, 17, 20, 21, 30, 34, 56, 63,\n    18, 20, 20, 26, 28, 51, 61, 55,\n    19, 20, 21, 26, 33, 58, 69, 55,\n    26, 26, 26, 30, 46, 87, 86, 66,\n    31, 33, 36, 40, 46, 96, 100, 73,\n    40, 35, 46, 62, 81, 100, 111, 91,\n    46, 66, 76, 86, 102, 121, 120, 101,\n    68, 90, 90, 96, 113, 102, 105, 103\n  },\n  {\n    /* From http://www.imagemagick.org/discourse-server/viewtopic.php?f=22&t=20333&p=98008#p98008\n     */\n    16,  16,  16,  18,  25,  37,  56,  85,\n    16,  17,  20,  27,  34,  40,  53,  75,\n    16,  20,  24,  31,  43,  62,  91,  135,\n    18,  27,  31,  40,  53,  74,  106, 156,\n    25,  34,  43,  53,  69,  94,  131, 189,\n    37,  40,  62,  74,  94,  124, 169, 238,\n    56,  53,  91,  106, 131, 169, 226, 311,\n    85,  75,  135, 156, 189, 238, 311, 418\n  },\n  {\n    9, 10, 12, 14, 27, 32, 51, 62,\n    11, 12, 14, 19, 27, 44, 59, 73,\n    12, 14, 18, 25, 42, 59, 79, 78,\n    17, 18, 25, 42, 61, 92, 87, 92,\n    23, 28, 42, 75, 79, 112, 112, 99,\n    40, 42, 59, 84, 88, 124, 132, 111,\n    42, 64, 78, 95, 105, 126, 125, 99,\n    70, 75, 100, 102, 116, 100, 107, 98\n  },\n  {\n    /* Relevance of human vision to JPEG-DCT compression (1992) Klein, Silverstein and Carney.\n     */\n    10, 12, 14, 19, 26, 38, 57, 86,\n    12, 18, 21, 28, 35, 41, 54, 76,\n    14, 21, 25, 32, 44, 63, 92, 136,\n    19, 28, 32, 41, 54, 75, 107, 157,\n    26, 35, 44, 54, 70, 95, 132, 190,\n    38, 41, 63, 75, 95, 125, 170, 239,\n    57, 54, 92, 107, 132, 170, 227, 312,\n    86, 76, 136, 157, 190, 239, 312, 419\n  },\n  {\n    /* DCTune perceptual optimization of compressed dental X-Rays (1997) Watson, Taylor, Borthwick\n     */\n    7, 8, 10, 14, 23, 44, 95, 241,\n    8, 8, 11, 15, 25, 47, 102, 255,\n    10, 11, 13, 19, 31, 58, 127, 255,\n    14, 15, 19, 27, 44, 83, 181, 255,\n    23, 25, 31, 44, 72, 136, 255, 255,\n    44, 47, 58, 83, 136, 255, 255, 255,\n    95, 102, 127, 181, 255, 255, 255, 255,\n    241, 255, 255, 255, 255, 255, 255, 255\n  },\n  {\n    /* A visual detection model for DCT coefficient quantization (12/9/93) Ahumada, Watson, Peterson\n     */\n    15, 11, 11, 12, 15, 19, 25, 32,\n    11, 13, 10, 10, 12, 15, 19, 24,\n    11, 10, 14, 14, 16, 18, 22, 27,\n    12, 10, 14, 18, 21, 24, 28, 33,\n    15, 12, 16, 21, 26, 31, 36, 42,\n    19, 15, 18, 24, 31, 38, 45, 53,\n    25, 19, 22, 28, 36, 45, 55, 65,\n    32, 24, 27, 33, 42, 53, 65, 77\n  },\n  {\n    /* An improved detection model for DCT coefficient quantization (1993) Peterson, Ahumada and Watson\n     */\n    14, 10, 11, 14, 19, 25, 34, 45,\n    10, 11, 11, 12, 15, 20, 26, 33,\n    11, 11, 15, 18, 21, 25, 31, 38,\n    14, 12, 18, 24, 28, 33, 39, 47,\n    19, 15, 21, 28, 36, 43, 51, 59,\n    25, 20, 25, 33, 43, 54, 64, 74,\n    34, 26, 31, 39, 51, 64, 77, 91,\n    45, 33, 38, 47, 59, 74, 91, 108\n  }\n};\n\nstatic const unsigned int std_chrominance_quant_tbl[9][DCTSIZE2] = {\n  {\n    /* JPEG Annex K\n     */\n  17,  18,  24,  47,  99,  99,  99,  99,\n  18,  21,  26,  66,  99,  99,  99,  99,\n  24,  26,  56,  99,  99,  99,  99,  99,\n  47,  66,  99,  99,  99,  99,  99,  99,\n  99,  99,  99,  99,  99,  99,  99,  99,\n  99,  99,  99,  99,  99,  99,  99,  99,\n  99,  99,  99,  99,  99,  99,  99,  99,\n  99,  99,  99,  99,  99,  99,  99,  99\n  },\n  {\n    /* flat\n     */\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16\n  },\n  {\n    8, 12, 15, 15, 86, 96, 96, 98,\n    13, 13, 15, 26, 90, 96, 99, 98,\n    12, 15, 18, 96, 99, 99, 99, 99,\n    17, 16, 90, 96, 99, 99, 99, 99,\n    96, 96, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99\n  },\n  {\n    /* From http://www.imagemagick.org/discourse-server/viewtopic.php?f=22&t=20333&p=98008#p98008\n     */\n    16,  16,  16,  18,  25,  37,  56,  85,\n    16,  17,  20,  27,  34,  40,  53,  75,\n    16,  20,  24,  31,  43,  62,  91,  135,\n    18,  27,  31,  40,  53,  74,  106, 156,\n    25,  34,  43,  53,  69,  94,  131, 189,\n    37,  40,  62,  74,  94,  124, 169, 238,\n    56,  53,  91,  106, 131, 169, 226, 311,\n    85,  75,  135, 156, 189, 238, 311, 418\n  },\n  {\n    9, 10, 17, 19, 62, 89, 91, 97,\n    12, 13, 18, 29, 84, 91, 88, 98,\n    14, 19, 29, 93, 95, 95, 98, 97,\n    20, 26, 84, 88, 95, 95, 98, 94,\n    26, 86, 91, 93, 97, 99, 98, 99,\n    99, 100, 98, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    97, 97, 99, 99, 99, 99, 97, 99\n  },\n  {\n    /* Relevance of human vision to JPEG-DCT compression (1992) Klein, Silverstein and Carney.\n     * Copied from luma\n     */\n    10, 12, 14, 19, 26, 38, 57, 86,\n    12, 18, 21, 28, 35, 41, 54, 76,\n    14, 21, 25, 32, 44, 63, 92, 136,\n    19, 28, 32, 41, 54, 75, 107, 157,\n    26, 35, 44, 54, 70, 95, 132, 190,\n    38, 41, 63, 75, 95, 125, 170, 239,\n    57, 54, 92, 107, 132, 170, 227, 312,\n    86, 76, 136, 157, 190, 239, 312, 419\n  },\n  {\n    /* DCTune perceptual optimization of compressed dental X-Rays (1997) Watson, Taylor, Borthwick\n     * Copied from luma\n     */\n    7, 8, 10, 14, 23, 44, 95, 241,\n    8, 8, 11, 15, 25, 47, 102, 255,\n    10, 11, 13, 19, 31, 58, 127, 255,\n    14, 15, 19, 27, 44, 83, 181, 255,\n    23, 25, 31, 44, 72, 136, 255, 255,\n    44, 47, 58, 83, 136, 255, 255, 255,\n    95, 102, 127, 181, 255, 255, 255, 255,\n    241, 255, 255, 255, 255, 255, 255, 255\n  },\n  {\n    /* A visual detection model for DCT coefficient quantization (12/9/93) Ahumada, Watson, Peterson\n     * Copied from luma\n     */\n    15, 11, 11, 12, 15, 19, 25, 32,\n    11, 13, 10, 10, 12, 15, 19, 24,\n    11, 10, 14, 14, 16, 18, 22, 27,\n    12, 10, 14, 18, 21, 24, 28, 33,\n    15, 12, 16, 21, 26, 31, 36, 42,\n    19, 15, 18, 24, 31, 38, 45, 53,\n    25, 19, 22, 28, 36, 45, 55, 65,\n    32, 24, 27, 33, 42, 53, 65, 77\n  },\n  {\n    /* An improved detection model for DCT coefficient quantization (1993) Peterson, Ahumada and Watson\n     * Copied from luma\n     */\n    14, 10, 11, 14, 19, 25, 34, 45,\n    10, 11, 11, 12, 15, 20, 26, 33,\n    11, 11, 15, 18, 21, 25, 31, 38,\n    14, 12, 18, 24, 28, 33, 39, 47,\n    19, 15, 21, 28, 36, 43, 51, 59,\n    25, 20, 25, 33, 43, 54, 64, 74,\n    34, 26, 31, 39, 51, 64, 77, 91,\n    45, 33, 38, 47, 59, 74, 91, 108\n  }\n};\n\n#if JPEG_LIB_VERSION >= 70\nGLOBAL(void)\njpeg_default_qtables(j_compress_ptr cinfo, boolean force_baseline)\n/* Set or change the 'quality' (quantization) setting, using default tables\n * and straight percentage-scaling quality scales.\n * This entry point allows different scalings for luminance and chrominance.\n */\n{\n  /* Set up two quantization tables using the specified scaling */\n  jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl[cinfo->master->quant_tbl_master_idx],\n                       cinfo->q_scale_factor[0], force_baseline);\n  jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl[cinfo->master->quant_tbl_master_idx],\n                       cinfo->q_scale_factor[1], force_baseline);\n}\n#endif\n\n\nGLOBAL(void)\njpeg_set_linear_quality(j_compress_ptr cinfo, int scale_factor,\n                        boolean force_baseline)\n/* Set or change the 'quality' (quantization) setting, using default tables\n * and a straight percentage-scaling quality scale.  In most cases it's better\n * to use jpeg_set_quality (below); this entry point is provided for\n * applications that insist on a linear percentage scaling.\n */\n{\n  /* Set up two quantization tables using the specified scaling */\n  jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl[cinfo->master->quant_tbl_master_idx],\n                       scale_factor, force_baseline);\n  jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl[cinfo->master->quant_tbl_master_idx],\n                       scale_factor, force_baseline);\n}\n\n\nGLOBAL(int)\njpeg_quality_scaling(int quality)\n{\n  return jpeg_float_quality_scaling(quality);\n}\n\nGLOBAL(float)\njpeg_float_quality_scaling(float quality)\n/* Convert a user-specified quality rating to a percentage scaling factor\n * for an underlying quantization table, using our recommended scaling curve.\n * The input 'quality' factor should be 0 (terrible) to 100 (very good).\n */\n{\n  /* Safety limit on quality factor.  Convert 0 to 1 to avoid zero divide. */\n  if (quality <= 0.f) quality = 1.f;\n  if (quality > 100.f) quality = 100.f;\n\n  /* The basic table is used as-is (scaling 100) for a quality of 50.\n   * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;\n   * note that at Q=100 the scaling is 0, which will cause jpeg_add_quant_table\n   * to make all the table entries 1 (hence, minimum quantization loss).\n   * Qualities 1..50 are converted to scaling percentage 5000/Q.\n   */\n  if (quality < 50.f)\n    quality = 5000.f / quality;\n  else\n    quality = 200.f - quality*2.f;\n\n  return quality;\n}\n\n\nGLOBAL(void)\njpeg_set_quality(j_compress_ptr cinfo, int quality, boolean force_baseline)\n/* Set or change the 'quality' (quantization) setting, using default tables.\n * This is the standard quality-adjusting entry point for typical user\n * interfaces; only those who want detailed control over quantization tables\n * would use the preceding three routines directly.\n */\n{\n  /* Convert user 0-100 rating to percentage scaling */\n  quality = jpeg_quality_scaling(quality);\n\n  /* Set up standard quality tables */\n  jpeg_set_linear_quality(cinfo, quality, force_baseline);\n}\n\n\n/*\n * Default parameter setup for compression.\n *\n * Applications that don't choose to use this routine must do their\n * own setup of all these parameters.  Alternately, you can call this\n * to establish defaults and then alter parameters selectively.  This\n * is the recommended approach since, if we add any new parameters,\n * your code will still work (they'll be set to reasonable defaults).\n */\n\nGLOBAL(void)\njpeg_set_defaults(j_compress_ptr cinfo)\n{\n  int i;\n\n  /* Safety check to ensure start_compress not called yet. */\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Allocate comp_info array large enough for maximum component count.\n   * Array is made permanent in case application wants to compress\n   * multiple images at same param settings.\n   */\n  if (cinfo->comp_info == NULL)\n    cinfo->comp_info = (jpeg_component_info *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  MAX_COMPONENTS * sizeof(jpeg_component_info));\n\n  /* Initialize everything not dependent on the color space */\n\n#if JPEG_LIB_VERSION >= 70\n  cinfo->scale_num = 1;         /* 1:1 scaling */\n  cinfo->scale_denom = 1;\n#endif\n  /* Set up two quantization tables using default quality of 75 */\n  jpeg_set_quality(cinfo, 75, TRUE);\n  /* Set up two Huffman tables */\n  std_huff_tables((j_common_ptr)cinfo);\n\n  /* Initialize default arithmetic coding conditioning */\n  for (i = 0; i < NUM_ARITH_TBLS; i++) {\n    cinfo->arith_dc_L[i] = 0;\n    cinfo->arith_dc_U[i] = 1;\n    cinfo->arith_ac_K[i] = 5;\n  }\n\n  /* Default is no multiple-scan output */\n  cinfo->scan_info = NULL;\n  cinfo->num_scans = 0;\n\n  /* Default is lossy output */\n  cinfo->master->lossless = FALSE;\n\n  /* Expect normal source image, not raw downsampled data */\n  cinfo->raw_data_in = FALSE;\n\n  /* Use Huffman coding, not arithmetic coding, by default */\n  cinfo->arith_code = FALSE;\n\n#ifdef ENTROPY_OPT_SUPPORTED\n  if (cinfo->master->compress_profile == JCP_MAX_COMPRESSION)\n    /* By default, do extra passes to optimize entropy coding */\n    cinfo->optimize_coding = TRUE;\n  else\n  /* By default, don't do extra passes to optimize entropy coding */\n  cinfo->optimize_coding = FALSE;\n#else\n  /* By default, don't do extra passes to optimize entropy coding */\n  cinfo->optimize_coding = FALSE;\n#endif\n  \n  /* The standard Huffman tables are only valid for 8-bit data precision.\n   * If the precision is higher, force optimization on so that usable\n   * tables will be computed.  This test can be removed if default tables\n   * are supplied that are valid for the desired precision.\n   */\n  if (cinfo->data_precision == 12)\n    cinfo->optimize_coding = TRUE;\n\n  /* By default, use the simpler non-cosited sampling alignment */\n  cinfo->CCIR601_sampling = FALSE;\n\n#if JPEG_LIB_VERSION >= 70\n  /* By default, apply fancy downsampling */\n  cinfo->do_fancy_downsampling = TRUE;\n#endif\n\n  cinfo->master->overshoot_deringing =\n    cinfo->master->compress_profile == JCP_MAX_COMPRESSION;\n\n  /* No input smoothing */\n  cinfo->smoothing_factor = 0;\n\n  /* DCT algorithm preference */\n  cinfo->dct_method = JDCT_DEFAULT;\n\n  /* No restart markers */\n  cinfo->restart_interval = 0;\n  cinfo->restart_in_rows = 0;\n\n  /* Fill in default JFIF marker parameters.  Note that whether the marker\n   * will actually be written is determined by jpeg_set_colorspace.\n   *\n   * By default, the library emits JFIF version code 1.01.\n   * An application that wants to emit JFIF 1.02 extension markers should set\n   * JFIF_minor_version to 2.  We could probably get away with just defaulting\n   * to 1.02, but there may still be some decoders in use that will complain\n   * about that; saying 1.01 should minimize compatibility problems.\n   */\n  cinfo->JFIF_major_version = 1; /* Default JFIF version = 1.01 */\n  cinfo->JFIF_minor_version = 1;\n  cinfo->density_unit = 0;      /* Pixel size is unknown by default */\n  cinfo->X_density = 1;         /* Pixel aspect ratio is square by default */\n  cinfo->Y_density = 1;\n\n  /* Choose JPEG colorspace based on input space, set defaults accordingly */\n\n  jpeg_default_colorspace(cinfo);\n\n  cinfo->master->dc_scan_opt_mode = 0;\n\n#ifdef C_PROGRESSIVE_SUPPORTED\n  if (cinfo->master->compress_profile == JCP_MAX_COMPRESSION) {\n    cinfo->master->optimize_scans = TRUE;\n    jpeg_simple_progression(cinfo);\n  } else\n    cinfo->master->optimize_scans = FALSE;\n#endif\n  \n  cinfo->master->trellis_quant =\n    cinfo->master->compress_profile == JCP_MAX_COMPRESSION;\n  cinfo->master->lambda_log_scale1 = 14.75;\n  cinfo->master->lambda_log_scale2 = 16.5;\n  cinfo->master->quant_tbl_master_idx =\n    cinfo->master->compress_profile == JCP_MAX_COMPRESSION ? 3 : 0;\n  \n  cinfo->master->use_lambda_weight_tbl = TRUE;\n  cinfo->master->use_scans_in_trellis = FALSE;\n  cinfo->master->trellis_freq_split = 8;\n  cinfo->master->trellis_num_loops = 1;\n  cinfo->master->trellis_q_opt = FALSE;\n  cinfo->master->trellis_quant_dc = TRUE;\n  cinfo->master->trellis_delta_dc_weight = 0.0;\n}\n\n\n/*\n * Select an appropriate JPEG colorspace for in_color_space.\n */\n\nGLOBAL(void)\njpeg_default_colorspace(j_compress_ptr cinfo)\n{\n  switch (cinfo->in_color_space) {\n  case JCS_GRAYSCALE:\n    jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);\n    break;\n  case JCS_RGB:\n  case JCS_EXT_RGB:\n  case JCS_EXT_RGBX:\n  case JCS_EXT_BGR:\n  case JCS_EXT_BGRX:\n  case JCS_EXT_XBGR:\n  case JCS_EXT_XRGB:\n  case JCS_EXT_RGBA:\n  case JCS_EXT_BGRA:\n  case JCS_EXT_ABGR:\n  case JCS_EXT_ARGB:\n#ifdef C_LOSSLESS_SUPPORTED\n    if (cinfo->master->lossless)\n      jpeg_set_colorspace(cinfo, JCS_RGB);\n    else\n#endif\n      jpeg_set_colorspace(cinfo, JCS_YCbCr);\n    break;\n  case JCS_YCbCr:\n    jpeg_set_colorspace(cinfo, JCS_YCbCr);\n    break;\n  case JCS_CMYK:\n    jpeg_set_colorspace(cinfo, JCS_CMYK); /* By default, no translation */\n    break;\n  case JCS_YCCK:\n    jpeg_set_colorspace(cinfo, JCS_YCCK);\n    break;\n  case JCS_UNKNOWN:\n    jpeg_set_colorspace(cinfo, JCS_UNKNOWN);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n  }\n}\n\n\n/*\n * Set the JPEG colorspace, and choose colorspace-dependent default values.\n */\n\nGLOBAL(void)\njpeg_set_colorspace(j_compress_ptr cinfo, J_COLOR_SPACE colorspace)\n{\n  jpeg_component_info *compptr;\n  int ci;\n\n#define SET_COMP(index, id, hsamp, vsamp, quant, dctbl, actbl) \\\n  (compptr = &cinfo->comp_info[index], \\\n   compptr->component_id = (id), \\\n   compptr->h_samp_factor = (hsamp), \\\n   compptr->v_samp_factor = (vsamp), \\\n   compptr->quant_tbl_no = (quant), \\\n   compptr->dc_tbl_no = (dctbl), \\\n   compptr->ac_tbl_no = (actbl) )\n\n  /* Safety check to ensure start_compress not called yet. */\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* For all colorspaces, we use Q and Huff tables 0 for luminance components,\n   * tables 1 for chrominance components.\n   */\n\n  cinfo->jpeg_color_space = colorspace;\n\n  cinfo->write_JFIF_header = FALSE; /* No marker for non-JFIF colorspaces */\n  cinfo->write_Adobe_marker = FALSE; /* write no Adobe marker by default */\n\n  switch (colorspace) {\n  case JCS_GRAYSCALE:\n    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */\n    cinfo->num_components = 1;\n    /* JFIF specifies component ID 1 */\n    SET_COMP(0, 1, 1, 1, 0, 0, 0);\n    break;\n  case JCS_RGB:\n    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag RGB */\n    cinfo->num_components = 3;\n    SET_COMP(0, 0x52 /* 'R' */, 1, 1, 0, 0, 0);\n    SET_COMP(1, 0x47 /* 'G' */, 1, 1, 0, 0, 0);\n    SET_COMP(2, 0x42 /* 'B' */, 1, 1, 0, 0, 0);\n    break;\n  case JCS_YCbCr:\n    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */\n    cinfo->num_components = 3;\n    /* JFIF specifies component IDs 1,2,3 */\n    /* We default to 2x2 subsamples of chrominance */\n    SET_COMP(0, 1, 2, 2, 0, 0, 0);\n    SET_COMP(1, 2, 1, 1, 1, 1, 1);\n    SET_COMP(2, 3, 1, 1, 1, 1, 1);\n    break;\n  case JCS_CMYK:\n    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag CMYK */\n    cinfo->num_components = 4;\n    SET_COMP(0, 0x43 /* 'C' */, 1, 1, 0, 0, 0);\n    SET_COMP(1, 0x4D /* 'M' */, 1, 1, 0, 0, 0);\n    SET_COMP(2, 0x59 /* 'Y' */, 1, 1, 0, 0, 0);\n    SET_COMP(3, 0x4B /* 'K' */, 1, 1, 0, 0, 0);\n    break;\n  case JCS_YCCK:\n    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag YCCK */\n    cinfo->num_components = 4;\n    SET_COMP(0, 1, 2, 2, 0, 0, 0);\n    SET_COMP(1, 2, 1, 1, 1, 1, 1);\n    SET_COMP(2, 3, 1, 1, 1, 1, 1);\n    SET_COMP(3, 4, 2, 2, 0, 0, 0);\n    break;\n  case JCS_UNKNOWN:\n    cinfo->num_components = cinfo->input_components;\n    if (cinfo->num_components < 1 || cinfo->num_components > MAX_COMPONENTS)\n      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,\n               MAX_COMPONENTS);\n    for (ci = 0; ci < cinfo->num_components; ci++) {\n      SET_COMP(ci, ci, 1, 1, 0, 0, 0);\n    }\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n  }\n}\n\n\n#ifdef C_PROGRESSIVE_SUPPORTED\n\nLOCAL(jpeg_scan_info *)\nfill_a_scan(jpeg_scan_info *scanptr, int ci, int Ss, int Se, int Ah, int Al)\n/* Support routine: generate one scan for specified component */\n{\n  scanptr->comps_in_scan = 1;\n  scanptr->component_index[0] = ci;\n  scanptr->Ss = Ss;\n  scanptr->Se = Se;\n  scanptr->Ah = Ah;\n  scanptr->Al = Al;\n  scanptr++;\n  return scanptr;\n}\n\nLOCAL(jpeg_scan_info *)\nfill_a_scan_pair (jpeg_scan_info * scanptr, int ci,\n                  int Ss, int Se, int Ah, int Al)\n/* Support routine: generate one scan for pair of components */\n{\n  scanptr->comps_in_scan = 2;\n  scanptr->component_index[0] = ci;\n  scanptr->component_index[1] = ci + 1;\n  scanptr->Ss = Ss;\n  scanptr->Se = Se;\n  scanptr->Ah = Ah;\n  scanptr->Al = Al;\n  scanptr++;\n  return scanptr;\n}\n\nLOCAL(jpeg_scan_info *)\nfill_scans(jpeg_scan_info *scanptr, int ncomps, int Ss, int Se, int Ah, int Al)\n/* Support routine: generate one scan for each component */\n{\n  int ci;\n\n  for (ci = 0; ci < ncomps; ci++) {\n    scanptr->comps_in_scan = 1;\n    scanptr->component_index[0] = ci;\n    scanptr->Ss = Ss;\n    scanptr->Se = Se;\n    scanptr->Ah = Ah;\n    scanptr->Al = Al;\n    scanptr++;\n  }\n  return scanptr;\n}\n\nLOCAL(jpeg_scan_info *)\nfill_dc_scans(jpeg_scan_info *scanptr, int ncomps, int Ah, int Al)\n/* Support routine: generate interleaved DC scan if possible, else N scans */\n{\n  int ci;\n\n  if (ncomps <= MAX_COMPS_IN_SCAN) {\n    /* Single interleaved DC scan */\n    scanptr->comps_in_scan = ncomps;\n    for (ci = 0; ci < ncomps; ci++)\n      scanptr->component_index[ci] = ci;\n    scanptr->Ss = scanptr->Se = 0;\n    scanptr->Ah = Ah;\n    scanptr->Al = Al;\n    scanptr++;\n  } else {\n    /* Noninterleaved DC scan for each component */\n    scanptr = fill_scans(scanptr, ncomps, 0, 0, Ah, Al);\n  }\n  return scanptr;\n}\n\n\n/*\n * List of scans to be tested\n * cinfo->num_components and cinfo->jpeg_color_space must be correct.\n */\n\nLOCAL(boolean)\njpeg_search_progression (j_compress_ptr cinfo)\n{\n  int ncomps = cinfo->num_components;\n  int nscans;\n  jpeg_scan_info * scanptr;\n  int Al;\n  int frequency_split[] = { 2, 8, 5, 12, 18 };\n  int i;\n  \n  /* Safety check to ensure start_compress not called yet. */\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  \n  /* Figure space needed for script.  Calculation must match code below! */\n  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {\n    /* Custom script for YCbCr color images. */\n    nscans = 64;\n  } else if (ncomps == 1) {\n    nscans = 23;\n  } else {\n    cinfo->master->num_scans_luma = 0;\n    return FALSE;\n  }\n  \n  /* Allocate space for script.\n   * We need to put it in the permanent pool in case the application performs\n   * multiple compressions without changing the settings.  To avoid a memory\n   * leak if jpeg_simple_progression is called repeatedly for the same JPEG\n   * object, we try to re-use previously allocated space, and we allocate\n   * enough space to handle YCbCr even if initially asked for grayscale.\n   */\n  if (cinfo->script_space == NULL || cinfo->script_space_size < nscans) {\n    cinfo->script_space_size = MAX(nscans, 64);\n    cinfo->script_space = (jpeg_scan_info *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,\n                                cinfo->script_space_size * sizeof(jpeg_scan_info));\n  }\n  scanptr = cinfo->script_space;\n  cinfo->scan_info = scanptr;\n  cinfo->num_scans = nscans;\n  \n  cinfo->master->Al_max_luma = 3;\n  cinfo->master->num_scans_luma_dc = 1;\n  cinfo->master->num_frequency_splits = 5;\n  cinfo->master->num_scans_luma =\n    cinfo->master->num_scans_luma_dc + (3 * cinfo->master->Al_max_luma + 2) +\n    (2 * cinfo->master->num_frequency_splits + 1);\n  \n  /* 23 scans for luma */\n  /* 1 scan for DC */\n  /* 11 scans to determine successive approximation */\n  /* 11 scans to determine frequency approximation */\n  /* after 12 scans need to update following 11 */\n  /* after 23 scans need to determine which to keep */\n  /* last 4 done conditionally */\n  \n  /* luma DC by itself */\n  if (cinfo->master->dc_scan_opt_mode == 0)\n    scanptr = fill_dc_scans(scanptr, ncomps, 0, 0);\n  else\n    scanptr = fill_dc_scans(scanptr, 1, 0, 0);\n  \n  scanptr = fill_a_scan(scanptr, 0, 1, 8, 0, 0);\n  scanptr = fill_a_scan(scanptr, 0, 9, 63, 0, 0);\n  \n  for (Al = 0; Al < cinfo->master->Al_max_luma; Al++) {\n    scanptr = fill_a_scan(scanptr, 0, 1, 63, Al+1, Al);\n    scanptr = fill_a_scan(scanptr, 0, 1, 8, 0, Al+1);\n    scanptr = fill_a_scan(scanptr, 0, 9, 63, 0, Al+1);\n  }\n  \n  scanptr = fill_a_scan(scanptr, 0, 1, 63, 0, 0);\n  \n  for (i = 0; i < cinfo->master->num_frequency_splits; i++) {\n    scanptr = fill_a_scan(scanptr, 0, 1, frequency_split[i], 0, 0);\n    scanptr = fill_a_scan(scanptr, 0, frequency_split[i]+1, 63, 0, 0);\n  }\n  \n  if (ncomps == 1) {\n    cinfo->master->Al_max_chroma = 0;\n    cinfo->master->num_scans_chroma_dc = 0;\n  } else {\n    cinfo->master->Al_max_chroma = 2;\n    cinfo->master->num_scans_chroma_dc = 3;\n    /* 41 scans for chroma */\n    \n    /* chroma DC combined */\n    scanptr = fill_a_scan_pair(scanptr, 1, 0, 0, 0, 0);\n    /* chroma DC separate */\n    scanptr = fill_a_scan(scanptr, 1, 0, 0, 0, 0);\n    scanptr = fill_a_scan(scanptr, 2, 0, 0, 0, 0);\n    \n    scanptr = fill_a_scan(scanptr, 1, 1, 8, 0, 0);\n    scanptr = fill_a_scan(scanptr, 1, 9, 63, 0, 0);\n    scanptr = fill_a_scan(scanptr, 2, 1, 8, 0, 0);\n    scanptr = fill_a_scan(scanptr, 2, 9, 63, 0, 0);\n\n    for (Al = 0; Al < cinfo->master->Al_max_chroma; Al++) {\n      scanptr = fill_a_scan(scanptr, 1, 1, 63, Al+1, Al);\n      scanptr = fill_a_scan(scanptr, 2, 1, 63, Al+1, Al);\n      scanptr = fill_a_scan(scanptr, 1, 1, 8, 0, Al+1);\n      scanptr = fill_a_scan(scanptr, 1, 9, 63, 0, Al+1);\n      scanptr = fill_a_scan(scanptr, 2, 1, 8, 0, Al+1);\n      scanptr = fill_a_scan(scanptr, 2, 9, 63, 0, Al+1);\n    }\n    \n    scanptr = fill_a_scan(scanptr, 1, 1, 63, 0, 0);\n    scanptr = fill_a_scan(scanptr, 2, 1, 63, 0, 0);\n\n    for (i = 0; i < cinfo->master->num_frequency_splits; i++) {\n      scanptr = fill_a_scan(scanptr, 1, 1, frequency_split[i], 0, 0);\n      scanptr = fill_a_scan(scanptr, 1, frequency_split[i]+1, 63, 0, 0);\n      scanptr = fill_a_scan(scanptr, 2, 1, frequency_split[i], 0, 0);\n      scanptr = fill_a_scan(scanptr, 2, frequency_split[i]+1, 63, 0, 0);\n    }\n  }\n  \n  return TRUE;\n}\n\n/*\n * Create a recommended progressive-JPEG script.\n * cinfo->num_components and cinfo->jpeg_color_space must be correct.\n */\n\nGLOBAL(void)\njpeg_simple_progression(j_compress_ptr cinfo)\n{\n  int ncomps;\n  int nscans;\n  jpeg_scan_info *scanptr;\n\n  if (cinfo->master->optimize_scans) {\n    if (jpeg_search_progression(cinfo) == TRUE)\n      return;\n  }\n\n  /* Safety check to ensure start_compress not called yet. */\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n#ifdef C_LOSSLESS_SUPPORTED\n  if (cinfo->master->lossless) {\n    cinfo->master->lossless = FALSE;\n    jpeg_default_colorspace(cinfo);\n  }\n#endif\n\n  /* Figure space needed for script.  Calculation must match code below! */\n  ncomps = cinfo->num_components;\n  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {\n    /* Custom script for YCbCr color images. */\n    if (cinfo->master->compress_profile == JCP_MAX_COMPRESSION) {\n      if (cinfo->master->dc_scan_opt_mode == 0) {\n        nscans = 9;  /* 1 DC scan for all components */\n      } else if (cinfo->master->dc_scan_opt_mode == 1) {\n        nscans = 11; /* 1 DC scan for each component */\n      } else {\n        nscans = 10; /* 1 DC scan for luminance and 1 DC scan for chroma */\n      }\n    } else {\n      nscans = 10;   /* 2 DC scans and 8 AC scans */\n    }\n  } else {\n    /* All-purpose script for other color spaces. */\n    if (cinfo->master->compress_profile == JCP_MAX_COMPRESSION) {\n    if (ncomps > MAX_COMPS_IN_SCAN)\n        nscans = 5 * ncomps;      /* 2 DC + 4 AC scans per component */\n      else\n        nscans = 1 + 4 * ncomps;  /* 2 DC scans; 4 AC scans per component */\n    } else {\n    if (ncomps > MAX_COMPS_IN_SCAN)\n      nscans = 6 * ncomps;      /* 2 DC + 4 AC scans per component */\n    else\n      nscans = 2 + 4 * ncomps;  /* 2 DC scans; 4 AC scans per component */\n  }\n  }\n\n  /* Allocate space for script.\n   * We need to put it in the permanent pool in case the application performs\n   * multiple compressions without changing the settings.  To avoid a memory\n   * leak if jpeg_simple_progression is called repeatedly for the same JPEG\n   * object, we try to re-use previously allocated space, and we allocate\n   * enough space to handle YCbCr even if initially asked for grayscale.\n   */\n  if (cinfo->script_space == NULL || cinfo->script_space_size < nscans) {\n    cinfo->script_space_size = MAX(nscans, 10);\n    cinfo->script_space = (jpeg_scan_info *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                        cinfo->script_space_size * sizeof(jpeg_scan_info));\n  }\n  scanptr = cinfo->script_space;\n  cinfo->scan_info = scanptr;\n  cinfo->num_scans = nscans;\n\n  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {\n    /* Custom script for YCbCr color images. */\n    if (cinfo->master->compress_profile == JCP_MAX_COMPRESSION) {\n      /* scan defined in jpeg_scan_rgb.txt in jpgcrush */\n    /* Initial DC scan */\n      if (cinfo->master->dc_scan_opt_mode == 0) {\n        /* 1 DC scan for all components */\n        scanptr = fill_dc_scans(scanptr, ncomps, 0, 0);\n      } else if (cinfo->master->dc_scan_opt_mode == 1) {\n        /* 1 DC scan for each component */\n        scanptr = fill_a_scan(scanptr, 0, 0, 0, 0, 0);\n        scanptr = fill_a_scan(scanptr, 1, 0, 0, 0, 0);\n        scanptr = fill_a_scan(scanptr, 2, 0, 0, 0, 0);\n      } else {\n        /* 1 DC scan for luminance and 1 DC scan for chroma */\n        scanptr = fill_dc_scans(scanptr, 1, 0, 0);\n        scanptr = fill_a_scan_pair(scanptr, 1, 0, 0, 0, 0);\n      }\n      /* Low frequency AC scans */\n      scanptr = fill_a_scan(scanptr, 0, 1, 8, 0, 2);\n      scanptr = fill_a_scan(scanptr, 1, 1, 8, 0, 0);\n      scanptr = fill_a_scan(scanptr, 2, 1, 8, 0, 0);\n      /* Complete spectral selection for luma AC */\n      scanptr = fill_a_scan(scanptr, 0, 9, 63, 0, 2);\n      /* Finish luma AC successive approximation */\n      scanptr = fill_a_scan(scanptr, 0, 1, 63, 2, 1);\n      scanptr = fill_a_scan(scanptr, 0, 1, 63, 1, 0);\n      /* Complete spectral selection for chroma AC */\n      scanptr = fill_a_scan(scanptr, 1, 9, 63, 0, 0);\n      scanptr = fill_a_scan(scanptr, 2, 9, 63, 0, 0);\n    } else {\n    /* Initial DC scan */\n    scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);\n    /* Initial AC scan: get some luma data out in a hurry */\n    scanptr = fill_a_scan(scanptr, 0, 1, 5, 0, 2);\n    /* Chroma data is too small to be worth expending many scans on */\n    scanptr = fill_a_scan(scanptr, 2, 1, 63, 0, 1);\n    scanptr = fill_a_scan(scanptr, 1, 1, 63, 0, 1);\n    /* Complete spectral selection for luma AC */\n    scanptr = fill_a_scan(scanptr, 0, 6, 63, 0, 2);\n    /* Refine next bit of luma AC */\n    scanptr = fill_a_scan(scanptr, 0, 1, 63, 2, 1);\n    /* Finish DC successive approximation */\n    scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);\n    /* Finish AC successive approximation */\n    scanptr = fill_a_scan(scanptr, 2, 1, 63, 1, 0);\n    scanptr = fill_a_scan(scanptr, 1, 1, 63, 1, 0);\n    /* Luma bottom bit comes last since it's usually largest scan */\n    scanptr = fill_a_scan(scanptr, 0, 1, 63, 1, 0);\n    }\n  } else {\n    /* All-purpose script for other color spaces. */\n    if (cinfo->master->compress_profile == JCP_MAX_COMPRESSION) {\n      /* scan defined in jpeg_scan_bw.txt in jpgcrush */\n      /* DC component, no successive approximation */\n      scanptr = fill_dc_scans(scanptr, ncomps, 0, 0);\n    /* Successive approximation first pass */\n      scanptr = fill_scans(scanptr, ncomps, 1, 8, 0, 2);\n      scanptr = fill_scans(scanptr, ncomps, 9, 63, 0, 2);\n      /* Successive approximation second pass */\n      scanptr = fill_scans(scanptr, ncomps, 1, 63, 2, 1);\n      /* Successive approximation final pass */\n      scanptr = fill_scans(scanptr, ncomps, 1, 63, 1, 0);\n    } else {\n    /* Successive approximation first pass */\n    scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);\n    scanptr = fill_scans(scanptr, ncomps, 1, 5, 0, 2);\n    scanptr = fill_scans(scanptr, ncomps, 6, 63, 0, 2);\n    /* Successive approximation second pass */\n    scanptr = fill_scans(scanptr, ncomps, 1, 63, 2, 1);\n    /* Successive approximation final pass */\n    scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);\n    scanptr = fill_scans(scanptr, ncomps, 1, 63, 1, 0);\n  }\n}\n}\n\n#endif /* C_PROGRESSIVE_SUPPORTED */\n\n\n#ifdef C_LOSSLESS_SUPPORTED\n\n/*\n * Enable lossless mode.\n */\n\nGLOBAL(void)\njpeg_enable_lossless(j_compress_ptr cinfo, int predictor_selection_value,\n                     int point_transform)\n{\n  /* Safety check to ensure start_compress not called yet. */\n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  cinfo->master->lossless = TRUE;\n  cinfo->Ss = predictor_selection_value;\n  cinfo->Se = 0;\n  cinfo->Ah = 0;\n  cinfo->Al = point_transform;\n\n  /* The JPEG spec simply gives the range 0..15 for Al (Pt), but that seems\n   * wrong: the upper bound ought to depend on data precision.  Perhaps they\n   * really meant 0..N-1 for N-bit precision, which is what we allow here.\n   * Values greater than or equal to the data precision will result in a blank\n   * image.\n   */\n  if (cinfo->Ss < 1 || cinfo->Ss > 7 ||\n      cinfo->Al < 0 || cinfo->Al >= cinfo->data_precision)\n    ERREXIT4(cinfo, JERR_BAD_PROGRESSION,\n             cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);\n}\n\n#endif /* C_LOSSLESS_SUPPORTED */\n"
        },
        {
          "name": "jcphuff.c",
          "type": "blob",
          "size": 32.373046875,
          "content": "/*\n * jcphuff.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1995-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2011, 2015, 2018, 2021-2022, 2024, D. R. Commander.\n * Copyright (C) 2016, 2018, 2022, Matthieu Darbois.\n * Copyright (C) 2020, Arm Limited.\n * Copyright (C) 2021, Alex Richardson.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains Huffman entropy encoding routines for progressive JPEG.\n *\n * We do not support output suspension in this module, since the library\n * currently does not allow multiple-scan files to be written with output\n * suspension.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#ifdef WITH_SIMD\n#include \"jsimd.h\"\n#else\n#include \"jchuff.h\"             /* Declarations shared with jc*huff.c */\n#endif\n#include <limits.h>\n\n#ifdef HAVE_INTRIN_H\n#include <intrin.h>\n#ifdef _MSC_VER\n#ifdef HAVE_BITSCANFORWARD64\n#pragma intrinsic(_BitScanForward64)\n#endif\n#ifdef HAVE_BITSCANFORWARD\n#pragma intrinsic(_BitScanForward)\n#endif\n#endif\n#endif\n\n#ifdef C_PROGRESSIVE_SUPPORTED\n\n#include \"jpeg_nbits.h\"\n\n\n/* Expanded entropy encoder object for progressive Huffman encoding. */\n\ntypedef struct {\n  struct jpeg_entropy_encoder pub; /* public fields */\n\n  /* Pointer to routine to prepare data for encode_mcu_AC_first() */\n  void (*AC_first_prepare) (const JCOEF *block,\n                            const int *jpeg_natural_order_start, int Sl,\n                            int Al, UJCOEF *values, size_t *zerobits);\n  /* Pointer to routine to prepare data for encode_mcu_AC_refine() */\n  int (*AC_refine_prepare) (const JCOEF *block,\n                            const int *jpeg_natural_order_start, int Sl,\n                            int Al, UJCOEF *absvalues, size_t *bits);\n\n  /* Mode flag: TRUE for optimization, FALSE for actual data output */\n  boolean gather_statistics;\n\n  /* Bit-level coding status.\n   * next_output_byte/free_in_buffer are local copies of cinfo->dest fields.\n   */\n  JOCTET *next_output_byte;     /* => next byte to write in buffer */\n  size_t free_in_buffer;        /* # of byte spaces remaining in buffer */\n  size_t put_buffer;            /* current bit-accumulation buffer */\n  int put_bits;                 /* # of bits now in it */\n  j_compress_ptr cinfo;         /* link to cinfo (needed for dump_buffer) */\n\n  /* Coding status for DC components */\n  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */\n\n  /* Coding status for AC components */\n  int ac_tbl_no;                /* the table number of the single component */\n  unsigned int EOBRUN;          /* run length of EOBs */\n  unsigned int BE;              /* # of buffered correction bits before MCU */\n  char *bit_buffer;             /* buffer for correction bits (1 per char) */\n  /* packing correction bits tightly would save some space but cost time... */\n\n  unsigned int restarts_to_go;  /* MCUs left in this restart interval */\n  int next_restart_num;         /* next restart number to write (0-7) */\n\n  /* Pointers to derived tables (these workspaces have image lifespan).\n   * Since any one scan codes only DC or only AC, we only need one set\n   * of tables, not one for DC and one for AC.\n   */\n  c_derived_tbl *derived_tbls[NUM_HUFF_TBLS];\n\n  /* Statistics tables for optimization; again, one set is enough */\n  long *count_ptrs[NUM_HUFF_TBLS];\n} phuff_entropy_encoder;\n\ntypedef phuff_entropy_encoder *phuff_entropy_ptr;\n\n/* MAX_CORR_BITS is the number of bits the AC refinement correction-bit\n * buffer can hold.  Larger sizes may slightly improve compression, but\n * 1000 is already well into the realm of overkill.\n * The minimum safe size is 64 bits.\n */\n\n#define MAX_CORR_BITS  1000     /* Max # of correction bits I can buffer */\n\n/* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than JLONG.\n * We assume that int right shift is unsigned if JLONG right shift is,\n * which should be safe.\n */\n\n#ifdef RIGHT_SHIFT_IS_UNSIGNED\n#define ISHIFT_TEMPS    int ishift_temp;\n#define IRIGHT_SHIFT(x, shft) \\\n  ((ishift_temp = (x)) < 0 ? \\\n   (ishift_temp >> (shft)) | ((~0) << (16 - (shft))) : \\\n   (ishift_temp >> (shft)))\n#else\n#define ISHIFT_TEMPS\n#define IRIGHT_SHIFT(x, shft)   ((x) >> (shft))\n#endif\n\n#define PAD(v, p)  ((v + (p) - 1) & (~((p) - 1)))\n\n/* Forward declarations */\nMETHODDEF(boolean) encode_mcu_DC_first(j_compress_ptr cinfo,\n                                       JBLOCKROW *MCU_data);\nMETHODDEF(void) encode_mcu_AC_first_prepare\n  (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,\n   UJCOEF *values, size_t *zerobits);\nMETHODDEF(boolean) encode_mcu_AC_first(j_compress_ptr cinfo,\n                                       JBLOCKROW *MCU_data);\nMETHODDEF(boolean) encode_mcu_DC_refine(j_compress_ptr cinfo,\n                                        JBLOCKROW *MCU_data);\nMETHODDEF(int) encode_mcu_AC_refine_prepare\n  (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,\n   UJCOEF *absvalues, size_t *bits);\nMETHODDEF(boolean) encode_mcu_AC_refine(j_compress_ptr cinfo,\n                                        JBLOCKROW *MCU_data);\nMETHODDEF(void) finish_pass_phuff(j_compress_ptr cinfo);\nMETHODDEF(void) finish_pass_gather_phuff(j_compress_ptr cinfo);\n\n\n/* Count bit loop zeroes */\nINLINE\nMETHODDEF(int)\ncount_zeroes(size_t *x)\n{\n#if defined(HAVE_BUILTIN_CTZL)\n  int result;\n  result = __builtin_ctzl(*x);\n  *x >>= result;\n#elif defined(HAVE_BITSCANFORWARD64)\n  unsigned long result;\n  _BitScanForward64(&result, *x);\n  *x >>= result;\n#elif defined(HAVE_BITSCANFORWARD)\n  unsigned long result;\n  _BitScanForward(&result, *x);\n  *x >>= result;\n#else\n  int result = 0;\n  while ((*x & 1) == 0) {\n    ++result;\n    *x >>= 1;\n  }\n#endif\n  return (int)result;\n}\n\n\n/*\n * Initialize for a Huffman-compressed scan using progressive JPEG.\n */\n\nMETHODDEF(void)\nstart_pass_phuff(j_compress_ptr cinfo, boolean gather_statistics)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  boolean is_DC_band;\n  int ci, tbl;\n  jpeg_component_info *compptr;\n\n  entropy->cinfo = cinfo;\n  entropy->gather_statistics = gather_statistics;\n\n  is_DC_band = (cinfo->Ss == 0);\n\n  /* We assume jcmaster.c already validated the scan parameters. */\n\n  /* Select execution routines */\n  if (cinfo->Ah == 0) {\n    if (is_DC_band)\n      entropy->pub.encode_mcu = encode_mcu_DC_first;\n    else\n      entropy->pub.encode_mcu = encode_mcu_AC_first;\n#ifdef WITH_SIMD\n    if (jsimd_can_encode_mcu_AC_first_prepare())\n      entropy->AC_first_prepare = jsimd_encode_mcu_AC_first_prepare;\n    else\n#endif\n      entropy->AC_first_prepare = encode_mcu_AC_first_prepare;\n  } else {\n    if (is_DC_band)\n      entropy->pub.encode_mcu = encode_mcu_DC_refine;\n    else {\n      entropy->pub.encode_mcu = encode_mcu_AC_refine;\n#ifdef WITH_SIMD\n      if (jsimd_can_encode_mcu_AC_refine_prepare())\n        entropy->AC_refine_prepare = jsimd_encode_mcu_AC_refine_prepare;\n      else\n#endif\n        entropy->AC_refine_prepare = encode_mcu_AC_refine_prepare;\n      /* AC refinement needs a correction bit buffer */\n      if (entropy->bit_buffer == NULL)\n        entropy->bit_buffer = (char *)\n          (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                      MAX_CORR_BITS * sizeof(char));\n    }\n  }\n  if (gather_statistics)\n    entropy->pub.finish_pass = finish_pass_gather_phuff;\n  else\n    entropy->pub.finish_pass = finish_pass_phuff;\n\n  /* Only DC coefficients may be interleaved, so cinfo->comps_in_scan = 1\n   * for AC coefficients.\n   */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    /* Initialize DC predictions to 0 */\n    entropy->last_dc_val[ci] = 0;\n    /* Get table index */\n    if (is_DC_band) {\n      if (cinfo->Ah != 0)       /* DC refinement needs no table */\n        continue;\n      tbl = compptr->dc_tbl_no;\n    } else {\n      entropy->ac_tbl_no = tbl = compptr->ac_tbl_no;\n    }\n    if (gather_statistics) {\n      /* Check for invalid table index */\n      /* (make_c_derived_tbl does this in the other path) */\n      if (tbl < 0 || tbl >= NUM_HUFF_TBLS)\n        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);\n      /* Allocate and zero the statistics tables */\n      /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */\n      if (entropy->count_ptrs[tbl] == NULL)\n        entropy->count_ptrs[tbl] = (long *)\n          (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                      257 * sizeof(long));\n      memset(entropy->count_ptrs[tbl], 0, 257 * sizeof(long));\n\n      if (cinfo->master->trellis_passes) {\n        /* When generating tables for trellis passes, make sure that all */\n        /* codewords have an assigned length */\n        int i, j;\n        for (i = 0; i < 16; i++)\n          for (j = 0; j < 12; j++)\n            entropy->count_ptrs[tbl][16 * i + j] = 1;\n      }\n    } else {\n      /* Compute derived values for Huffman table */\n      /* We may do this more than once for a table, but it's not expensive */\n      jpeg_make_c_derived_tbl(cinfo, is_DC_band, tbl,\n                              &entropy->derived_tbls[tbl]);\n    }\n  }\n\n  /* Initialize AC stuff */\n  entropy->EOBRUN = 0;\n  entropy->BE = 0;\n\n  /* Initialize bit buffer to empty */\n  entropy->put_buffer = 0;\n  entropy->put_bits = 0;\n\n  /* Initialize restart stuff */\n  entropy->restarts_to_go = cinfo->restart_interval;\n  entropy->next_restart_num = 0;\n}\n\n\n/* Outputting bytes to the file.\n * NB: these must be called only when actually outputting,\n * that is, entropy->gather_statistics == FALSE.\n */\n\n/* Emit a byte */\n#define emit_byte(entropy, val) { \\\n  *(entropy)->next_output_byte++ = (JOCTET)(val); \\\n  if (--(entropy)->free_in_buffer == 0) \\\n    dump_buffer(entropy); \\\n}\n\n\nLOCAL(void)\ndump_buffer(phuff_entropy_ptr entropy)\n/* Empty the output buffer; we do not support suspension in this module. */\n{\n  struct jpeg_destination_mgr *dest = entropy->cinfo->dest;\n\n  if (!(*dest->empty_output_buffer) (entropy->cinfo))\n    ERREXIT(entropy->cinfo, JERR_CANT_SUSPEND);\n  /* After a successful buffer dump, must reset buffer pointers */\n  entropy->next_output_byte = dest->next_output_byte;\n  entropy->free_in_buffer = dest->free_in_buffer;\n}\n\n\n/* Outputting bits to the file */\n\n/* Only the right 24 bits of put_buffer are used; the valid bits are\n * left-justified in this part.  At most 16 bits can be passed to emit_bits\n * in one call, and we never retain more than 7 bits in put_buffer\n * between calls, so 24 bits are sufficient.\n */\n\nLOCAL(void)\nemit_bits(phuff_entropy_ptr entropy, unsigned int code, int size)\n/* Emit some bits, unless we are in gather mode */\n{\n  /* This routine is heavily used, so it's worth coding tightly. */\n  register size_t put_buffer = (size_t)code;\n  register int put_bits = entropy->put_bits;\n\n  /* if size is 0, caller used an invalid Huffman table entry */\n  if (size == 0)\n    ERREXIT(entropy->cinfo, JERR_HUFF_MISSING_CODE);\n\n  if (entropy->gather_statistics)\n    return;                     /* do nothing if we're only getting stats */\n\n  put_buffer &= (((size_t)1) << size) - 1; /* mask off any extra bits in code */\n\n  put_bits += size;             /* new number of bits in buffer */\n\n  put_buffer <<= 24 - put_bits; /* align incoming bits */\n\n  put_buffer |= entropy->put_buffer; /* and merge with old buffer contents */\n\n  while (put_bits >= 8) {\n    int c = (int)((put_buffer >> 16) & 0xFF);\n\n    emit_byte(entropy, c);\n    if (c == 0xFF) {            /* need to stuff a zero byte? */\n      emit_byte(entropy, 0);\n    }\n    put_buffer <<= 8;\n    put_bits -= 8;\n  }\n\n  entropy->put_buffer = put_buffer; /* update variables */\n  entropy->put_bits = put_bits;\n}\n\n\nLOCAL(void)\nflush_bits(phuff_entropy_ptr entropy)\n{\n  emit_bits(entropy, 0x7F, 7); /* fill any partial byte with ones */\n  entropy->put_buffer = 0;     /* and reset bit-buffer to empty */\n  entropy->put_bits = 0;\n}\n\n\n/*\n * Emit (or just count) a Huffman symbol.\n */\n\nLOCAL(void)\nemit_symbol(phuff_entropy_ptr entropy, int tbl_no, int symbol)\n{\n  if (entropy->gather_statistics)\n    entropy->count_ptrs[tbl_no][symbol]++;\n  else {\n    c_derived_tbl *tbl = entropy->derived_tbls[tbl_no];\n    emit_bits(entropy, tbl->ehufco[symbol], tbl->ehufsi[symbol]);\n  }\n}\n\n\n/*\n * Emit bits from a correction bit buffer.\n */\n\nLOCAL(void)\nemit_buffered_bits(phuff_entropy_ptr entropy, char *bufstart,\n                   unsigned int nbits)\n{\n  if (entropy->gather_statistics)\n    return;                     /* no real work */\n\n  while (nbits > 0) {\n    emit_bits(entropy, (unsigned int)(*bufstart), 1);\n    bufstart++;\n    nbits--;\n  }\n}\n\n\n/*\n * Emit any pending EOBRUN symbol.\n */\n\nLOCAL(void)\nemit_eobrun(phuff_entropy_ptr entropy)\n{\n  register int temp, nbits;\n\n  if (entropy->EOBRUN > 0) {    /* if there is any pending EOBRUN */\n    temp = entropy->EOBRUN;\n    nbits = JPEG_NBITS_NONZERO(temp) - 1;\n    /* safety check: shouldn't happen given limited correction-bit buffer */\n    if (nbits > 14)\n      ERREXIT(entropy->cinfo, JERR_HUFF_MISSING_CODE);\n\n    emit_symbol(entropy, entropy->ac_tbl_no, nbits << 4);\n    if (nbits)\n      emit_bits(entropy, entropy->EOBRUN, nbits);\n\n    entropy->EOBRUN = 0;\n\n    /* Emit any buffered correction bits */\n    emit_buffered_bits(entropy, entropy->bit_buffer, entropy->BE);\n    entropy->BE = 0;\n  }\n}\n\n\n/*\n * Emit a restart marker & resynchronize predictions.\n */\n\nLOCAL(void)\nemit_restart(phuff_entropy_ptr entropy, int restart_num)\n{\n  int ci;\n\n  emit_eobrun(entropy);\n\n  if (!entropy->gather_statistics) {\n    flush_bits(entropy);\n    emit_byte(entropy, 0xFF);\n    emit_byte(entropy, JPEG_RST0 + restart_num);\n  }\n\n  if (entropy->cinfo->Ss == 0) {\n    /* Re-initialize DC predictions to 0 */\n    for (ci = 0; ci < entropy->cinfo->comps_in_scan; ci++)\n      entropy->last_dc_val[ci] = 0;\n  } else {\n    /* Re-initialize all AC-related fields to 0 */\n    entropy->EOBRUN = 0;\n    entropy->BE = 0;\n  }\n}\n\n\n/*\n * MCU encoding for DC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n\nMETHODDEF(boolean)\nencode_mcu_DC_first(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  register int temp, temp2, temp3;\n  register int nbits;\n  int blkn, ci;\n  int Al = cinfo->Al;\n  JBLOCKROW block;\n  jpeg_component_info *compptr;\n  ISHIFT_TEMPS\n  int max_coef_bits = cinfo->data_precision + 2;\n\n  entropy->next_output_byte = cinfo->dest->next_output_byte;\n  entropy->free_in_buffer = cinfo->dest->free_in_buffer;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval)\n    if (entropy->restarts_to_go == 0)\n      emit_restart(entropy, entropy->next_restart_num);\n\n  /* Encode the MCU data blocks */\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    block = MCU_data[blkn];\n    ci = cinfo->MCU_membership[blkn];\n    compptr = cinfo->cur_comp_info[ci];\n\n    /* Compute the DC value after the required point transform by Al.\n     * This is simply an arithmetic right shift.\n     */\n    temp2 = IRIGHT_SHIFT((int)((*block)[0]), Al);\n\n    /* DC differences are figured on the point-transformed values. */\n    temp = temp2 - entropy->last_dc_val[ci];\n    entropy->last_dc_val[ci] = temp2;\n\n    /* Encode the DC coefficient difference per section G.1.2.1 */\n\n    /* This is a well-known technique for obtaining the absolute value without\n     * a branch.  It is derived from an assembly language technique presented\n     * in \"How to Optimize for the Pentium Processors\", Copyright (c) 1996,\n     * 1997 by Agner Fog.\n     */\n    temp3 = temp >> (CHAR_BIT * sizeof(int) - 1);\n    temp ^= temp3;\n    temp -= temp3;              /* temp is abs value of input */\n    /* For a negative input, want temp2 = bitwise complement of abs(input) */\n    temp2 = temp ^ temp3;\n\n    /* Find the number of bits needed for the magnitude of the coefficient */\n    nbits = JPEG_NBITS(temp);\n    /* Check for out-of-range coefficient values.\n     * Since we're encoding a difference, the range limit is twice as much.\n     */\n    if (nbits > max_coef_bits + 1)\n      ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n\n    /* Count/emit the Huffman-coded symbol for the number of bits */\n    emit_symbol(entropy, compptr->dc_tbl_no, nbits);\n\n    /* Emit that number of bits of the value, if positive, */\n    /* or the complement of its magnitude, if negative. */\n    if (nbits)                  /* emit_bits rejects calls with size 0 */\n      emit_bits(entropy, (unsigned int)temp2, nbits);\n  }\n\n  cinfo->dest->next_output_byte = entropy->next_output_byte;\n  cinfo->dest->free_in_buffer = entropy->free_in_buffer;\n\n  /* Update restart-interval state too */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Data preparation for encode_mcu_AC_first().\n */\n\n#define COMPUTE_ABSVALUES_AC_FIRST(Sl) { \\\n  for (k = 0; k < Sl; k++) { \\\n    temp = block[jpeg_natural_order_start[k]]; \\\n    if (temp == 0) \\\n      continue; \\\n    /* We must apply the point transform by Al.  For AC coefficients this \\\n     * is an integer division with rounding towards 0.  To do this portably \\\n     * in C, we shift after obtaining the absolute value; so the code is \\\n     * interwoven with finding the abs value (temp) and output bits (temp2). \\\n     */ \\\n    temp2 = temp >> (CHAR_BIT * sizeof(int) - 1); \\\n    temp ^= temp2; \\\n    temp -= temp2;              /* temp is abs value of input */ \\\n    temp >>= Al;                /* apply the point transform */ \\\n    /* Watch out for case that nonzero coef is zero after point transform */ \\\n    if (temp == 0) \\\n      continue; \\\n    /* For a negative coef, want temp2 = bitwise complement of abs(coef) */ \\\n    temp2 ^= temp; \\\n    values[k] = (UJCOEF)temp; \\\n    values[k + DCTSIZE2] = (UJCOEF)temp2; \\\n    zerobits |= ((size_t)1U) << k; \\\n  } \\\n}\n\nMETHODDEF(void)\nencode_mcu_AC_first_prepare(const JCOEF *block,\n                            const int *jpeg_natural_order_start, int Sl,\n                            int Al, UJCOEF *values, size_t *bits)\n{\n  register int k, temp, temp2;\n  size_t zerobits = 0U;\n  int Sl0 = Sl;\n\n#if SIZEOF_SIZE_T == 4\n  if (Sl0 > 32)\n    Sl0 = 32;\n#endif\n\n  COMPUTE_ABSVALUES_AC_FIRST(Sl0);\n\n  bits[0] = zerobits;\n#if SIZEOF_SIZE_T == 4\n  zerobits = 0U;\n\n  if (Sl > 32) {\n    Sl -= 32;\n    jpeg_natural_order_start += 32;\n    values += 32;\n\n    COMPUTE_ABSVALUES_AC_FIRST(Sl);\n  }\n  bits[1] = zerobits;\n#endif\n}\n\n/*\n * MCU encoding for AC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n\n#define ENCODE_COEFS_AC_FIRST(label) { \\\n  while (zerobits) { \\\n    r = count_zeroes(&zerobits); \\\n    cvalue += r; \\\nlabel \\\n    temp  = cvalue[0]; \\\n    temp2 = cvalue[DCTSIZE2]; \\\n    \\\n    /* if run length > 15, must emit special run-length-16 codes (0xF0) */ \\\n    while (r > 15) { \\\n      emit_symbol(entropy, entropy->ac_tbl_no, 0xF0); \\\n      r -= 16; \\\n    } \\\n    \\\n    /* Find the number of bits needed for the magnitude of the coefficient */ \\\n    nbits = JPEG_NBITS_NONZERO(temp);  /* there must be at least one 1 bit */ \\\n    /* Check for out-of-range coefficient values */ \\\n    if (nbits > max_coef_bits) \\\n      ERREXIT(cinfo, JERR_BAD_DCT_COEF); \\\n    \\\n    /* Count/emit Huffman symbol for run length / number of bits */ \\\n    emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + nbits); \\\n    \\\n    /* Emit that number of bits of the value, if positive, */ \\\n    /* or the complement of its magnitude, if negative. */ \\\n    emit_bits(entropy, (unsigned int)temp2, nbits); \\\n    \\\n    cvalue++; \\\n    zerobits >>= 1; \\\n  } \\\n}\n\nMETHODDEF(boolean)\nencode_mcu_AC_first(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  register int temp, temp2;\n  register int nbits, r;\n  int Sl = cinfo->Se - cinfo->Ss + 1;\n  int Al = cinfo->Al;\n  UJCOEF values_unaligned[2 * DCTSIZE2 + 15];\n  UJCOEF *values;\n  const UJCOEF *cvalue;\n  size_t zerobits;\n  size_t bits[8 / SIZEOF_SIZE_T];\n  int max_coef_bits = cinfo->data_precision + 2;\n\n#ifdef ZERO_BUFFERS\n  memset(values_unaligned, 0, sizeof(values_unaligned));\n  memset(bits, 0, sizeof(bits));\n#endif\n\n  entropy->next_output_byte = cinfo->dest->next_output_byte;\n  entropy->free_in_buffer = cinfo->dest->free_in_buffer;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval)\n    if (entropy->restarts_to_go == 0)\n      emit_restart(entropy, entropy->next_restart_num);\n\n#ifdef WITH_SIMD\n  cvalue = values = (UJCOEF *)PAD((JUINTPTR)values_unaligned, 16);\n#else\n  /* Not using SIMD, so alignment is not needed */\n  cvalue = values = values_unaligned;\n#endif\n\n  /* Prepare data */\n  entropy->AC_first_prepare(MCU_data[0][0], jpeg_natural_order + cinfo->Ss,\n                            Sl, Al, values, bits);\n\n  zerobits = bits[0];\n#if SIZEOF_SIZE_T == 4\n  zerobits |= bits[1];\n#endif\n\n  /* Emit any pending EOBRUN */\n  if (zerobits && (entropy->EOBRUN > 0))\n    emit_eobrun(entropy);\n\n#if SIZEOF_SIZE_T == 4\n  zerobits = bits[0];\n#endif\n\n  /* Encode the AC coefficients per section G.1.2.2, fig. G.3 */\n\n  ENCODE_COEFS_AC_FIRST((void)0;);\n\n#if SIZEOF_SIZE_T == 4\n  zerobits = bits[1];\n  if (zerobits) {\n    int diff = ((values + DCTSIZE2 / 2) - cvalue);\n    r = count_zeroes(&zerobits);\n    r += diff;\n    cvalue += r;\n    goto first_iter_ac_first;\n  }\n\n  ENCODE_COEFS_AC_FIRST(first_iter_ac_first:);\n#endif\n\n  if (cvalue < (values + Sl)) { /* If there are trailing zeroes, */\n    entropy->EOBRUN++;          /* count an EOB */\n    if (entropy->EOBRUN == 0x7FFF)\n      emit_eobrun(entropy);     /* force it out to avoid overflow */\n  }\n\n  cinfo->dest->next_output_byte = entropy->next_output_byte;\n  cinfo->dest->free_in_buffer = entropy->free_in_buffer;\n\n  /* Update restart-interval state too */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  return TRUE;\n}\n\n\n/*\n * MCU encoding for DC successive approximation refinement scan.\n * Note: we assume such scans can be multi-component, although the spec\n * is not very clear on the point.\n */\n\nMETHODDEF(boolean)\nencode_mcu_DC_refine(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  register int temp;\n  int blkn;\n  int Al = cinfo->Al;\n  JBLOCKROW block;\n\n  entropy->next_output_byte = cinfo->dest->next_output_byte;\n  entropy->free_in_buffer = cinfo->dest->free_in_buffer;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval)\n    if (entropy->restarts_to_go == 0)\n      emit_restart(entropy, entropy->next_restart_num);\n\n  /* Encode the MCU data blocks */\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    block = MCU_data[blkn];\n\n    /* We simply emit the Al'th bit of the DC coefficient value. */\n    temp = (*block)[0];\n    emit_bits(entropy, (unsigned int)(temp >> Al), 1);\n  }\n\n  cinfo->dest->next_output_byte = entropy->next_output_byte;\n  cinfo->dest->free_in_buffer = entropy->free_in_buffer;\n\n  /* Update restart-interval state too */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Data preparation for encode_mcu_AC_refine().\n */\n\n#define COMPUTE_ABSVALUES_AC_REFINE(Sl, koffset) { \\\n  /* It is convenient to make a pre-pass to determine the transformed \\\n   * coefficients' absolute values and the EOB position. \\\n   */ \\\n  for (k = 0; k < Sl; k++) { \\\n    temp = block[jpeg_natural_order_start[k]]; \\\n    /* We must apply the point transform by Al.  For AC coefficients this \\\n     * is an integer division with rounding towards 0.  To do this portably \\\n     * in C, we shift after obtaining the absolute value. \\\n     */ \\\n    temp2 = temp >> (CHAR_BIT * sizeof(int) - 1); \\\n    temp ^= temp2; \\\n    temp -= temp2;              /* temp is abs value of input */ \\\n    temp >>= Al;                /* apply the point transform */ \\\n    if (temp != 0) { \\\n      zerobits |= ((size_t)1U) << k; \\\n      signbits |= ((size_t)(temp2 + 1)) << k; \\\n    } \\\n    absvalues[k] = (UJCOEF)temp; /* save abs value for main pass */ \\\n    if (temp == 1) \\\n      EOB = k + koffset;        /* EOB = index of last newly-nonzero coef */ \\\n  } \\\n}\n\nMETHODDEF(int)\nencode_mcu_AC_refine_prepare(const JCOEF *block,\n                             const int *jpeg_natural_order_start, int Sl,\n                             int Al, UJCOEF *absvalues, size_t *bits)\n{\n  register int k, temp, temp2;\n  int EOB = 0;\n  size_t zerobits = 0U, signbits = 0U;\n  int Sl0 = Sl;\n\n#if SIZEOF_SIZE_T == 4\n  if (Sl0 > 32)\n    Sl0 = 32;\n#endif\n\n  COMPUTE_ABSVALUES_AC_REFINE(Sl0, 0);\n\n  bits[0] = zerobits;\n#if SIZEOF_SIZE_T == 8\n  bits[1] = signbits;\n#else\n  bits[2] = signbits;\n\n  zerobits = 0U;\n  signbits = 0U;\n\n  if (Sl > 32) {\n    Sl -= 32;\n    jpeg_natural_order_start += 32;\n    absvalues += 32;\n\n    COMPUTE_ABSVALUES_AC_REFINE(Sl, 32);\n  }\n\n  bits[1] = zerobits;\n  bits[3] = signbits;\n#endif\n\n  return EOB;\n}\n\n\n/*\n * MCU encoding for AC successive approximation refinement scan.\n */\n\n#define ENCODE_COEFS_AC_REFINE(label) { \\\n  while (zerobits) { \\\n    idx = count_zeroes(&zerobits); \\\n    r += idx; \\\n    cabsvalue += idx; \\\n    signbits >>= idx; \\\nlabel \\\n    /* Emit any required ZRLs, but not if they can be folded into EOB */ \\\n    while (r > 15 && (cabsvalue <= EOBPTR)) { \\\n      /* emit any pending EOBRUN and the BE correction bits */ \\\n      emit_eobrun(entropy); \\\n      /* Emit ZRL */ \\\n      emit_symbol(entropy, entropy->ac_tbl_no, 0xF0); \\\n      r -= 16; \\\n      /* Emit buffered correction bits that must be associated with ZRL */ \\\n      emit_buffered_bits(entropy, BR_buffer, BR); \\\n      BR_buffer = entropy->bit_buffer; /* BE bits are gone now */ \\\n      BR = 0; \\\n    } \\\n    \\\n    temp = *cabsvalue++; \\\n    \\\n    /* If the coef was previously nonzero, it only needs a correction bit. \\\n     * NOTE: a straight translation of the spec's figure G.7 would suggest \\\n     * that we also need to test r > 15.  But if r > 15, we can only get here \\\n     * if k > EOB, which implies that this coefficient is not 1. \\\n     */ \\\n    if (temp > 1) { \\\n      /* The correction bit is the next bit of the absolute value. */ \\\n      BR_buffer[BR++] = (char)(temp & 1); \\\n      signbits >>= 1; \\\n      zerobits >>= 1; \\\n      continue; \\\n    } \\\n    \\\n    /* Emit any pending EOBRUN and the BE correction bits */ \\\n    emit_eobrun(entropy); \\\n    \\\n    /* Count/emit Huffman symbol for run length / number of bits */ \\\n    emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + 1); \\\n    \\\n    /* Emit output bit for newly-nonzero coef */ \\\n    temp = signbits & 1; /* ((*block)[jpeg_natural_order_start[k]] < 0) ? 0 : 1 */ \\\n    emit_bits(entropy, (unsigned int)temp, 1); \\\n    \\\n    /* Emit buffered correction bits that must be associated with this code */ \\\n    emit_buffered_bits(entropy, BR_buffer, BR); \\\n    BR_buffer = entropy->bit_buffer; /* BE bits are gone now */ \\\n    BR = 0; \\\n    r = 0;                      /* reset zero run length */ \\\n    signbits >>= 1; \\\n    zerobits >>= 1; \\\n  } \\\n}\n\nMETHODDEF(boolean)\nencode_mcu_AC_refine(j_compress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  register int temp, r, idx;\n  char *BR_buffer;\n  unsigned int BR;\n  int Sl = cinfo->Se - cinfo->Ss + 1;\n  int Al = cinfo->Al;\n  UJCOEF absvalues_unaligned[DCTSIZE2 + 15];\n  UJCOEF *absvalues;\n  const UJCOEF *cabsvalue, *EOBPTR;\n  size_t zerobits, signbits;\n  size_t bits[16 / SIZEOF_SIZE_T];\n\n#ifdef ZERO_BUFFERS\n  memset(absvalues_unaligned, 0, sizeof(absvalues_unaligned));\n  memset(bits, 0, sizeof(bits));\n#endif\n\n  entropy->next_output_byte = cinfo->dest->next_output_byte;\n  entropy->free_in_buffer = cinfo->dest->free_in_buffer;\n\n  /* Emit restart marker if needed */\n  if (cinfo->restart_interval)\n    if (entropy->restarts_to_go == 0)\n      emit_restart(entropy, entropy->next_restart_num);\n\n#ifdef WITH_SIMD\n  cabsvalue = absvalues = (UJCOEF *)PAD((JUINTPTR)absvalues_unaligned, 16);\n#else\n  /* Not using SIMD, so alignment is not needed */\n  cabsvalue = absvalues = absvalues_unaligned;\n#endif\n\n  /* Prepare data */\n  EOBPTR = absvalues +\n    entropy->AC_refine_prepare(MCU_data[0][0], jpeg_natural_order + cinfo->Ss,\n                               Sl, Al, absvalues, bits);\n\n  /* Encode the AC coefficients per section G.1.2.3, fig. G.7 */\n\n  r = 0;                        /* r = run length of zeros */\n  BR = 0;                       /* BR = count of buffered bits added now */\n  BR_buffer = entropy->bit_buffer + entropy->BE; /* Append bits to buffer */\n\n  zerobits = bits[0];\n#if SIZEOF_SIZE_T == 8\n  signbits = bits[1];\n#else\n  signbits = bits[2];\n#endif\n  ENCODE_COEFS_AC_REFINE((void)0;);\n\n#if SIZEOF_SIZE_T == 4\n  zerobits = bits[1];\n  signbits = bits[3];\n\n  if (zerobits) {\n    int diff = ((absvalues + DCTSIZE2 / 2) - cabsvalue);\n    idx = count_zeroes(&zerobits);\n    signbits >>= idx;\n    idx += diff;\n    r += idx;\n    cabsvalue += idx;\n    goto first_iter_ac_refine;\n  }\n\n  ENCODE_COEFS_AC_REFINE(first_iter_ac_refine:);\n#endif\n\n  r |= (int)((absvalues + Sl) - cabsvalue);\n\n  if (r > 0 || BR > 0) {        /* If there are trailing zeroes, */\n    entropy->EOBRUN++;          /* count an EOB */\n    entropy->BE += BR;          /* concat my correction bits to older ones */\n    /* We force out the EOB if we risk either:\n     * 1. overflow of the EOB counter;\n     * 2. overflow of the correction bit buffer during the next MCU.\n     */\n    if (entropy->EOBRUN == 0x7FFF ||\n        entropy->BE > (MAX_CORR_BITS - DCTSIZE2 + 1))\n      emit_eobrun(entropy);\n  }\n\n  cinfo->dest->next_output_byte = entropy->next_output_byte;\n  cinfo->dest->free_in_buffer = entropy->free_in_buffer;\n\n  /* Update restart-interval state too */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0) {\n      entropy->restarts_to_go = cinfo->restart_interval;\n      entropy->next_restart_num++;\n      entropy->next_restart_num &= 7;\n    }\n    entropy->restarts_to_go--;\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Finish up at the end of a Huffman-compressed progressive scan.\n */\n\nMETHODDEF(void)\nfinish_pass_phuff(j_compress_ptr cinfo)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n\n  entropy->next_output_byte = cinfo->dest->next_output_byte;\n  entropy->free_in_buffer = cinfo->dest->free_in_buffer;\n\n  /* Flush out any buffered data */\n  emit_eobrun(entropy);\n  flush_bits(entropy);\n\n  cinfo->dest->next_output_byte = entropy->next_output_byte;\n  cinfo->dest->free_in_buffer = entropy->free_in_buffer;\n}\n\n\n/*\n * Finish up a statistics-gathering pass and create the new Huffman tables.\n */\n\nMETHODDEF(void)\nfinish_pass_gather_phuff(j_compress_ptr cinfo)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  boolean is_DC_band;\n  int ci, tbl;\n  jpeg_component_info *compptr;\n  JHUFF_TBL **htblptr;\n  boolean did[NUM_HUFF_TBLS];\n\n  /* Flush out buffered data (all we care about is counting the EOB symbol) */\n  emit_eobrun(entropy);\n\n  is_DC_band = (cinfo->Ss == 0);\n\n  /* It's important not to apply jpeg_gen_optimal_table more than once\n   * per table, because it clobbers the input frequency counts!\n   */\n  memset(did, 0, sizeof(did));\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    if (is_DC_band) {\n      if (cinfo->Ah != 0)       /* DC refinement needs no table */\n        continue;\n      tbl = compptr->dc_tbl_no;\n    } else {\n      tbl = compptr->ac_tbl_no;\n    }\n    if (!did[tbl]) {\n      if (is_DC_band)\n        htblptr = &cinfo->dc_huff_tbl_ptrs[tbl];\n      else\n        htblptr = &cinfo->ac_huff_tbl_ptrs[tbl];\n      if (*htblptr == NULL)\n        *htblptr = jpeg_alloc_huff_table((j_common_ptr)cinfo);\n      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->count_ptrs[tbl]);\n      did[tbl] = TRUE;\n    }\n  }\n}\n\n\n/*\n * Module initialization routine for progressive Huffman entropy encoding.\n */\n\nGLOBAL(void)\njinit_phuff_encoder(j_compress_ptr cinfo)\n{\n  phuff_entropy_ptr entropy;\n  int i;\n\n  entropy = (phuff_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(phuff_entropy_encoder));\n  cinfo->entropy = (struct jpeg_entropy_encoder *)entropy;\n  entropy->pub.start_pass = start_pass_phuff;\n\n  /* Mark tables unallocated */\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    entropy->derived_tbls[i] = NULL;\n    entropy->count_ptrs[i] = NULL;\n  }\n  entropy->bit_buffer = NULL;   /* needed only in AC refinement scan */\n}\n\n#endif /* C_PROGRESSIVE_SUPPORTED */\n"
        },
        {
          "name": "jcprepct.c",
          "type": "blob",
          "size": 13.24609375,
          "content": "/*\n * jcprepct.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the compression preprocessing controller.\n * This controller manages the color conversion, downsampling,\n * and edge expansion steps.\n *\n * Most of the complexity here is associated with buffering input rows\n * as required by the downsampler.  See the comments at the head of\n * jcsample.c for the downsampler's needs.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n\n\n#if BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED)\n\n/* At present, jcsample.c can request context rows only for smoothing.\n * In the future, we might also need context rows for CCIR601 sampling\n * or other more-complex downsampling procedures.  The code to support\n * context rows should be compiled only if needed.\n */\n#ifdef INPUT_SMOOTHING_SUPPORTED\n#define CONTEXT_ROWS_SUPPORTED\n#endif\n\n\n/*\n * For the simple (no-context-row) case, we just need to buffer one\n * row group's worth of pixels for the downsampling step.  At the bottom of\n * the image, we pad to a full row group by replicating the last pixel row.\n * The downsampler's last output row is then replicated if needed to pad\n * out to a full iMCU row.\n *\n * When providing context rows, we must buffer three row groups' worth of\n * pixels.  Three row groups are physically allocated, but the row pointer\n * arrays are made five row groups high, with the extra pointers above and\n * below \"wrapping around\" to point to the last and first real row groups.\n * This allows the downsampler to access the proper context rows.\n * At the top and bottom of the image, we create dummy context rows by\n * copying the first or last real pixel row.  This copying could be avoided\n * by pointer hacking as is done in jdmainct.c, but it doesn't seem worth the\n * trouble on the compression side.\n */\n\n\n/* Private buffer controller object */\n\ntypedef struct {\n  struct jpeg_c_prep_controller pub; /* public fields */\n\n  /* Downsampling input buffer.  This buffer holds color-converted data\n   * until we have enough to do a downsample step.\n   */\n  _JSAMPARRAY color_buf[MAX_COMPONENTS];\n\n  JDIMENSION rows_to_go;        /* counts rows remaining in source image */\n  int next_buf_row;             /* index of next row to store in color_buf */\n\n#ifdef CONTEXT_ROWS_SUPPORTED   /* only needed for context case */\n  int this_row_group;           /* starting row index of group to process */\n  int next_buf_stop;            /* downsample when we reach this index */\n#endif\n} my_prep_controller;\n\ntypedef my_prep_controller *my_prep_ptr;\n\n\n/*\n * Initialize for a processing pass.\n */\n\nMETHODDEF(void)\nstart_pass_prep(j_compress_ptr cinfo, J_BUF_MODE pass_mode)\n{\n  my_prep_ptr prep = (my_prep_ptr)cinfo->prep;\n\n  if (pass_mode != JBUF_PASS_THRU)\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n\n  /* Initialize total-height counter for detecting bottom of image */\n  prep->rows_to_go = cinfo->image_height;\n  /* Mark the conversion buffer empty */\n  prep->next_buf_row = 0;\n#ifdef CONTEXT_ROWS_SUPPORTED\n  /* Preset additional state variables for context mode.\n   * These aren't used in non-context mode, so we needn't test which mode.\n   */\n  prep->this_row_group = 0;\n  /* Set next_buf_stop to stop after two row groups have been read in. */\n  prep->next_buf_stop = 2 * cinfo->max_v_samp_factor;\n#endif\n}\n\n\n/*\n * Expand an image vertically from height input_rows to height output_rows,\n * by duplicating the bottom row.\n */\n\nLOCAL(void)\nexpand_bottom_edge(_JSAMPARRAY image_data, JDIMENSION num_cols, int input_rows,\n                   int output_rows)\n{\n  register int row;\n\n  for (row = input_rows; row < output_rows; row++) {\n    _jcopy_sample_rows(image_data, input_rows - 1, image_data, row, 1,\n                       num_cols);\n  }\n}\n\n\n/*\n * Process some data in the simple no-context case.\n *\n * Preprocessor output data is counted in \"row groups\".  A row group\n * is defined to be v_samp_factor sample rows of each component.\n * Downsampling will produce this much data from each max_v_samp_factor\n * input rows.\n */\n\nMETHODDEF(void)\npre_process_data(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                 JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail,\n                 _JSAMPIMAGE output_buf, JDIMENSION *out_row_group_ctr,\n                 JDIMENSION out_row_groups_avail)\n{\n  my_prep_ptr prep = (my_prep_ptr)cinfo->prep;\n  int numrows, ci;\n  JDIMENSION inrows;\n  jpeg_component_info *compptr;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n  while (*in_row_ctr < in_rows_avail &&\n         *out_row_group_ctr < out_row_groups_avail) {\n    /* Do color conversion to fill the conversion buffer. */\n    inrows = in_rows_avail - *in_row_ctr;\n    numrows = cinfo->max_v_samp_factor - prep->next_buf_row;\n    numrows = (int)MIN((JDIMENSION)numrows, inrows);\n    (*cinfo->cconvert->_color_convert) (cinfo, input_buf + *in_row_ctr,\n                                        prep->color_buf,\n                                        (JDIMENSION)prep->next_buf_row,\n                                        numrows);\n    *in_row_ctr += numrows;\n    prep->next_buf_row += numrows;\n    prep->rows_to_go -= numrows;\n    /* If at bottom of image, pad to fill the conversion buffer. */\n    if (prep->rows_to_go == 0 &&\n        prep->next_buf_row < cinfo->max_v_samp_factor) {\n      for (ci = 0; ci < cinfo->num_components; ci++) {\n        expand_bottom_edge(prep->color_buf[ci], cinfo->image_width,\n                           prep->next_buf_row, cinfo->max_v_samp_factor);\n      }\n      prep->next_buf_row = cinfo->max_v_samp_factor;\n    }\n    /* If we've filled the conversion buffer, empty it. */\n    if (prep->next_buf_row == cinfo->max_v_samp_factor) {\n      (*cinfo->downsample->_downsample) (cinfo,\n                                         prep->color_buf, (JDIMENSION)0,\n                                         output_buf, *out_row_group_ctr);\n      prep->next_buf_row = 0;\n      (*out_row_group_ctr)++;\n    }\n    /* If at bottom of image, pad the output to a full iMCU height.\n     * Note we assume the caller is providing a one-iMCU-height output buffer!\n     */\n    if (prep->rows_to_go == 0 && *out_row_group_ctr < out_row_groups_avail) {\n      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n           ci++, compptr++) {\n        expand_bottom_edge(output_buf[ci],\n                           compptr->width_in_blocks * data_unit,\n                           (int)(*out_row_group_ctr * compptr->v_samp_factor),\n                           (int)(out_row_groups_avail * compptr->v_samp_factor));\n      }\n      *out_row_group_ctr = out_row_groups_avail;\n      break;                    /* can exit outer loop without test */\n    }\n  }\n}\n\n\n#ifdef CONTEXT_ROWS_SUPPORTED\n\n/*\n * Process some data in the context case.\n */\n\nMETHODDEF(void)\npre_process_context(j_compress_ptr cinfo, _JSAMPARRAY input_buf,\n                    JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail,\n                    _JSAMPIMAGE output_buf, JDIMENSION *out_row_group_ctr,\n                    JDIMENSION out_row_groups_avail)\n{\n  my_prep_ptr prep = (my_prep_ptr)cinfo->prep;\n  int numrows, ci;\n  int buf_height = cinfo->max_v_samp_factor * 3;\n  JDIMENSION inrows;\n\n  while (*out_row_group_ctr < out_row_groups_avail) {\n    if (*in_row_ctr < in_rows_avail) {\n      /* Do color conversion to fill the conversion buffer. */\n      inrows = in_rows_avail - *in_row_ctr;\n      numrows = prep->next_buf_stop - prep->next_buf_row;\n      numrows = (int)MIN((JDIMENSION)numrows, inrows);\n      (*cinfo->cconvert->_color_convert) (cinfo, input_buf + *in_row_ctr,\n                                          prep->color_buf,\n                                          (JDIMENSION)prep->next_buf_row,\n                                          numrows);\n      /* Pad at top of image, if first time through */\n      if (prep->rows_to_go == cinfo->image_height) {\n        for (ci = 0; ci < cinfo->num_components; ci++) {\n          int row;\n          for (row = 1; row <= cinfo->max_v_samp_factor; row++) {\n            _jcopy_sample_rows(prep->color_buf[ci], 0, prep->color_buf[ci],\n                               -row, 1, cinfo->image_width);\n          }\n        }\n      }\n      *in_row_ctr += numrows;\n      prep->next_buf_row += numrows;\n      prep->rows_to_go -= numrows;\n    } else {\n      /* Return for more data, unless we are at the bottom of the image. */\n      if (prep->rows_to_go != 0)\n        break;\n      /* When at bottom of image, pad to fill the conversion buffer. */\n      if (prep->next_buf_row < prep->next_buf_stop) {\n        for (ci = 0; ci < cinfo->num_components; ci++) {\n          expand_bottom_edge(prep->color_buf[ci], cinfo->image_width,\n                             prep->next_buf_row, prep->next_buf_stop);\n        }\n        prep->next_buf_row = prep->next_buf_stop;\n      }\n    }\n    /* If we've gotten enough data, downsample a row group. */\n    if (prep->next_buf_row == prep->next_buf_stop) {\n      (*cinfo->downsample->_downsample) (cinfo, prep->color_buf,\n                                         (JDIMENSION)prep->this_row_group,\n                                         output_buf, *out_row_group_ctr);\n      (*out_row_group_ctr)++;\n      /* Advance pointers with wraparound as necessary. */\n      prep->this_row_group += cinfo->max_v_samp_factor;\n      if (prep->this_row_group >= buf_height)\n        prep->this_row_group = 0;\n      if (prep->next_buf_row >= buf_height)\n        prep->next_buf_row = 0;\n      prep->next_buf_stop = prep->next_buf_row + cinfo->max_v_samp_factor;\n    }\n  }\n}\n\n\n/*\n * Create the wrapped-around downsampling input buffer needed for context mode.\n */\n\nLOCAL(void)\ncreate_context_buffer(j_compress_ptr cinfo)\n{\n  my_prep_ptr prep = (my_prep_ptr)cinfo->prep;\n  int rgroup_height = cinfo->max_v_samp_factor;\n  int ci, i;\n  jpeg_component_info *compptr;\n  _JSAMPARRAY true_buffer, fake_buffer;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n  /* Grab enough space for fake row pointers for all the components;\n   * we need five row groups' worth of pointers for each component.\n   */\n  fake_buffer = (_JSAMPARRAY)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (cinfo->num_components * 5 * rgroup_height) *\n                                sizeof(_JSAMPROW));\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Allocate the actual buffer space (3 row groups) for this component.\n     * We make the buffer wide enough to allow the downsampler to edge-expand\n     * horizontally within the buffer, if it so chooses.\n     */\n    true_buffer = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       (JDIMENSION)(((long)compptr->width_in_blocks * data_unit *\n                     cinfo->max_h_samp_factor) / compptr->h_samp_factor),\n       (JDIMENSION)(3 * rgroup_height));\n    /* Copy true buffer row pointers into the middle of the fake row array */\n    memcpy(fake_buffer + rgroup_height, true_buffer,\n           3 * rgroup_height * sizeof(_JSAMPROW));\n    /* Fill in the above and below wraparound pointers */\n    for (i = 0; i < rgroup_height; i++) {\n      fake_buffer[i] = true_buffer[2 * rgroup_height + i];\n      fake_buffer[4 * rgroup_height + i] = true_buffer[i];\n    }\n    prep->color_buf[ci] = fake_buffer + rgroup_height;\n    fake_buffer += 5 * rgroup_height; /* point to space for next component */\n  }\n}\n\n#endif /* CONTEXT_ROWS_SUPPORTED */\n\n\n/*\n * Initialize preprocessing controller.\n */\n\nGLOBAL(void)\n_jinit_c_prep_controller(j_compress_ptr cinfo, boolean need_full_buffer)\n{\n  my_prep_ptr prep;\n  int ci;\n  jpeg_component_info *compptr;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  if (need_full_buffer)         /* safety check */\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n\n  prep = (my_prep_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_prep_controller));\n  cinfo->prep = (struct jpeg_c_prep_controller *)prep;\n  prep->pub.start_pass = start_pass_prep;\n\n  /* Allocate the color conversion buffer.\n   * We make the buffer wide enough to allow the downsampler to edge-expand\n   * horizontally within the buffer, if it so chooses.\n   */\n  if (cinfo->downsample->need_context_rows) {\n    /* Set up to provide context rows */\n#ifdef CONTEXT_ROWS_SUPPORTED\n    prep->pub._pre_process_data = pre_process_context;\n    create_context_buffer(cinfo);\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    /* No context, just make it tall enough for one row group */\n    prep->pub._pre_process_data = pre_process_data;\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      prep->color_buf[ci] = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n        ((j_common_ptr)cinfo, JPOOL_IMAGE,\n         (JDIMENSION)(((long)compptr->width_in_blocks * data_unit *\n                       cinfo->max_h_samp_factor) / compptr->h_samp_factor),\n         (JDIMENSION)cinfo->max_v_samp_factor);\n    }\n  }\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED) */\n"
        },
        {
          "name": "jcsample.c",
          "type": "blob",
          "size": 19.4951171875,
          "content": "/*\n * jcsample.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2014, MIPS Technologies, Inc., California.\n * Copyright (C) 2015, 2019, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains downsampling routines.\n *\n * Downsampling input data is counted in \"row groups\".  A row group\n * is defined to be max_v_samp_factor pixel rows of each component,\n * from which the downsampler produces v_samp_factor sample rows.\n * A single row group is processed in each call to the downsampler module.\n *\n * The downsampler is responsible for edge-expansion of its output data\n * to fill an integral number of DCT blocks horizontally.  The source buffer\n * may be modified if it is helpful for this purpose (the source buffer is\n * allocated wide enough to correspond to the desired output width).\n * The caller (the prep controller) is responsible for vertical padding.\n *\n * The downsampler may request \"context rows\" by setting need_context_rows\n * during startup.  In this case, the input arrays will contain at least\n * one row group's worth of pixels above and below the passed-in data;\n * the caller will create dummy rows at image top and bottom by replicating\n * the first or last real pixel row.\n *\n * An excellent reference for image resampling is\n *   Digital Image Warping, George Wolberg, 1990.\n *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.\n *\n * The downsampling algorithm used here is a simple average of the source\n * pixels covered by the output pixel.  The hi-falutin sampling literature\n * refers to this as a \"box filter\".  In general the characteristics of a box\n * filter are not very good, but for the specific cases we normally use (1:1\n * and 2:1 ratios) the box is equivalent to a \"triangle filter\" which is not\n * nearly so bad.  If you intend to use other sampling ratios, you'd be well\n * advised to improve this code.\n *\n * A simple input-smoothing capability is provided.  This is mainly intended\n * for cleaning up color-dithered GIF input files (if you find it inadequate,\n * we suggest using an external filtering program such as pnmconvol).  When\n * enabled, each input pixel P is replaced by a weighted sum of itself and its\n * eight neighbors.  P's weight is 1-8*SF and each neighbor's weight is SF,\n * where SF = (smoothing_factor / 1024).\n * Currently, smoothing is only supported for 2h2v sampling factors.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsimd.h\"\n#include \"jsamplecomp.h\"\n\n\n#if BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED)\n\n/* Pointer to routine to downsample a single component */\ntypedef void (*downsample1_ptr) (j_compress_ptr cinfo,\n                                 jpeg_component_info *compptr,\n                                 _JSAMPARRAY input_data,\n                                 _JSAMPARRAY output_data);\n\n/* Private subobject */\n\ntypedef struct {\n  struct jpeg_downsampler pub;  /* public fields */\n\n  /* Downsampling method pointers, one per component */\n  downsample1_ptr methods[MAX_COMPONENTS];\n} my_downsampler;\n\ntypedef my_downsampler *my_downsample_ptr;\n\n\n/*\n * Initialize for a downsampling pass.\n */\n\nMETHODDEF(void)\nstart_pass_downsample(j_compress_ptr cinfo)\n{\n  /* no work for now */\n}\n\n\n/*\n * Expand a component horizontally from width input_cols to width output_cols,\n * by duplicating the rightmost samples.\n */\n\nLOCAL(void)\nexpand_right_edge(_JSAMPARRAY image_data, int num_rows, JDIMENSION input_cols,\n                  JDIMENSION output_cols)\n{\n  register _JSAMPROW ptr;\n  register _JSAMPLE pixval;\n  register int count;\n  int row;\n  int numcols = (int)(output_cols - input_cols);\n\n  if (numcols > 0) {\n    for (row = 0; row < num_rows; row++) {\n      ptr = image_data[row] + input_cols;\n      pixval = ptr[-1];\n      for (count = numcols; count > 0; count--)\n        *ptr++ = pixval;\n    }\n  }\n}\n\n\n/*\n * Do downsampling for a whole row group (all components).\n *\n * In this version we simply downsample each component independently.\n */\n\nMETHODDEF(void)\nsep_downsample(j_compress_ptr cinfo, _JSAMPIMAGE input_buf,\n               JDIMENSION in_row_index, _JSAMPIMAGE output_buf,\n               JDIMENSION out_row_group_index)\n{\n  my_downsample_ptr downsample = (my_downsample_ptr)cinfo->downsample;\n  int ci;\n  jpeg_component_info *compptr;\n  _JSAMPARRAY in_ptr, out_ptr;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    in_ptr = input_buf[ci] + in_row_index;\n    out_ptr = output_buf[ci] + (out_row_group_index * compptr->v_samp_factor);\n    (*downsample->methods[ci]) (cinfo, compptr, in_ptr, out_ptr);\n  }\n}\n\n\n/*\n * Downsample pixel values of a single component.\n * One row group is processed per call.\n * This version handles arbitrary integral sampling ratios, without smoothing.\n * Note that this version is not actually used for customary sampling ratios.\n */\n\nMETHODDEF(void)\nint_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,\n               _JSAMPARRAY input_data, _JSAMPARRAY output_data)\n{\n  int inrow, outrow, h_expand, v_expand, numpix, numpix2, h, v;\n  JDIMENSION outcol, outcol_h;  /* outcol_h == outcol*h_expand */\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n  JDIMENSION output_cols = compptr->width_in_blocks * data_unit;\n  _JSAMPROW inptr, outptr;\n  JLONG outvalue;\n\n  h_expand = cinfo->max_h_samp_factor / compptr->h_samp_factor;\n  v_expand = cinfo->max_v_samp_factor / compptr->v_samp_factor;\n  numpix = h_expand * v_expand;\n  numpix2 = numpix / 2;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data, cinfo->max_v_samp_factor, cinfo->image_width,\n                    output_cols * h_expand);\n\n  inrow = 0;\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    for (outcol = 0, outcol_h = 0; outcol < output_cols;\n         outcol++, outcol_h += h_expand) {\n      outvalue = 0;\n      for (v = 0; v < v_expand; v++) {\n        inptr = input_data[inrow + v] + outcol_h;\n        for (h = 0; h < h_expand; h++) {\n          outvalue += (JLONG)(*inptr++);\n        }\n      }\n      *outptr++ = (_JSAMPLE)((outvalue + numpix2) / numpix);\n    }\n    inrow += v_expand;\n  }\n}\n\n\n/*\n * Downsample pixel values of a single component.\n * This version handles the special case of a full-size component,\n * without smoothing.\n */\n\nMETHODDEF(void)\nfullsize_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,\n                    _JSAMPARRAY input_data, _JSAMPARRAY output_data)\n{\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n  /* Copy the data */\n  _jcopy_sample_rows(input_data, 0, output_data, 0, cinfo->max_v_samp_factor,\n                     cinfo->image_width);\n  /* Edge-expand */\n  expand_right_edge(output_data, cinfo->max_v_samp_factor, cinfo->image_width,\n                    compptr->width_in_blocks * data_unit);\n}\n\n\n/*\n * Downsample pixel values of a single component.\n * This version handles the common case of 2:1 horizontal and 1:1 vertical,\n * without smoothing.\n *\n * A note about the \"bias\" calculations: when rounding fractional values to\n * integer, we do not want to always round 0.5 up to the next integer.\n * If we did that, we'd introduce a noticeable bias towards larger values.\n * Instead, this code is arranged so that 0.5 will be rounded up or down at\n * alternate pixel locations (a simple ordered dither pattern).\n */\n\nMETHODDEF(void)\nh2v1_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,\n                _JSAMPARRAY input_data, _JSAMPARRAY output_data)\n{\n  int outrow;\n  JDIMENSION outcol;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n  JDIMENSION output_cols = compptr->width_in_blocks * data_unit;\n  register _JSAMPROW inptr, outptr;\n  register int bias;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data, cinfo->max_v_samp_factor, cinfo->image_width,\n                    output_cols * 2);\n\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    inptr = input_data[outrow];\n    bias = 0;                   /* bias = 0,1,0,1,... for successive samples */\n    for (outcol = 0; outcol < output_cols; outcol++) {\n      *outptr++ = (_JSAMPLE)((inptr[0] + inptr[1] + bias) >> 1);\n      bias ^= 1;                /* 0=>1, 1=>0 */\n      inptr += 2;\n    }\n  }\n}\n\n\n/*\n * Downsample pixel values of a single component.\n * This version handles the standard case of 2:1 horizontal and 2:1 vertical,\n * without smoothing.\n */\n\nMETHODDEF(void)\nh2v2_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,\n                _JSAMPARRAY input_data, _JSAMPARRAY output_data)\n{\n  int inrow, outrow;\n  JDIMENSION outcol;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n  JDIMENSION output_cols = compptr->width_in_blocks * data_unit;\n  register _JSAMPROW inptr0, inptr1, outptr;\n  register int bias;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data, cinfo->max_v_samp_factor, cinfo->image_width,\n                    output_cols * 2);\n\n  inrow = 0;\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    inptr0 = input_data[inrow];\n    inptr1 = input_data[inrow + 1];\n    bias = 1;                   /* bias = 1,2,1,2,... for successive samples */\n    for (outcol = 0; outcol < output_cols; outcol++) {\n      *outptr++ = (_JSAMPLE)\n        ((inptr0[0] + inptr0[1] + inptr1[0] + inptr1[1] + bias) >> 2);\n      bias ^= 3;                /* 1=>2, 2=>1 */\n      inptr0 += 2;  inptr1 += 2;\n    }\n    inrow += 2;\n  }\n}\n\n\n#ifdef INPUT_SMOOTHING_SUPPORTED\n\n/*\n * Downsample pixel values of a single component.\n * This version handles the standard case of 2:1 horizontal and 2:1 vertical,\n * with smoothing.  One row of context is required.\n */\n\nMETHODDEF(void)\nh2v2_smooth_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,\n                       _JSAMPARRAY input_data, _JSAMPARRAY output_data)\n{\n  int inrow, outrow;\n  JDIMENSION colctr;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n  JDIMENSION output_cols = compptr->width_in_blocks * data_unit;\n  register _JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;\n  JLONG membersum, neighsum, memberscale, neighscale;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,\n                    cinfo->image_width, output_cols * 2);\n\n  /* We don't bother to form the individual \"smoothed\" input pixel values;\n   * we can directly compute the output which is the average of the four\n   * smoothed values.  Each of the four member pixels contributes a fraction\n   * (1-8*SF) to its own smoothed image and a fraction SF to each of the three\n   * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final\n   * output.  The four corner-adjacent neighbor pixels contribute a fraction\n   * SF to just one smoothed pixel, or SF/4 to the final output; while the\n   * eight edge-adjacent neighbors contribute SF to each of two smoothed\n   * pixels, or SF/2 overall.  In order to use integer arithmetic, these\n   * factors are scaled by 2^16 = 65536.\n   * Also recall that SF = smoothing_factor / 1024.\n   */\n\n  memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */\n  neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */\n\n  inrow = 0;\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    inptr0 = input_data[inrow];\n    inptr1 = input_data[inrow + 1];\n    above_ptr = input_data[inrow - 1];\n    below_ptr = input_data[inrow + 2];\n\n    /* Special case for first column: pretend column -1 is same as column 0 */\n    membersum = inptr0[0] + inptr0[1] + inptr1[0] + inptr1[1];\n    neighsum = above_ptr[0] + above_ptr[1] + below_ptr[0] + below_ptr[1] +\n               inptr0[0] + inptr0[2] + inptr1[0] + inptr1[2];\n    neighsum += neighsum;\n    neighsum += above_ptr[0] + above_ptr[2] + below_ptr[0] + below_ptr[2];\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr++ = (_JSAMPLE)((membersum + 32768) >> 16);\n    inptr0 += 2;  inptr1 += 2;  above_ptr += 2;  below_ptr += 2;\n\n    for (colctr = output_cols - 2; colctr > 0; colctr--) {\n      /* sum of pixels directly mapped to this output element */\n      membersum = inptr0[0] + inptr0[1] + inptr1[0] + inptr1[1];\n      /* sum of edge-neighbor pixels */\n      neighsum = above_ptr[0] + above_ptr[1] + below_ptr[0] + below_ptr[1] +\n                 inptr0[-1] + inptr0[2] + inptr1[-1] + inptr1[2];\n      /* The edge-neighbors count twice as much as corner-neighbors */\n      neighsum += neighsum;\n      /* Add in the corner-neighbors */\n      neighsum += above_ptr[-1] + above_ptr[2] + below_ptr[-1] + below_ptr[2];\n      /* form final output scaled up by 2^16 */\n      membersum = membersum * memberscale + neighsum * neighscale;\n      /* round, descale and output it */\n      *outptr++ = (_JSAMPLE)((membersum + 32768) >> 16);\n      inptr0 += 2;  inptr1 += 2;  above_ptr += 2;  below_ptr += 2;\n    }\n\n    /* Special case for last column */\n    membersum = inptr0[0] + inptr0[1] + inptr1[0] + inptr1[1];\n    neighsum = above_ptr[0] + above_ptr[1] + below_ptr[0] + below_ptr[1] +\n               inptr0[-1] + inptr0[1] + inptr1[-1] + inptr1[1];\n    neighsum += neighsum;\n    neighsum += above_ptr[-1] + above_ptr[1] + below_ptr[-1] + below_ptr[1];\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr = (_JSAMPLE)((membersum + 32768) >> 16);\n\n    inrow += 2;\n  }\n}\n\n\n/*\n * Downsample pixel values of a single component.\n * This version handles the special case of a full-size component,\n * with smoothing.  One row of context is required.\n */\n\nMETHODDEF(void)\nfullsize_smooth_downsample(j_compress_ptr cinfo, jpeg_component_info *compptr,\n                           _JSAMPARRAY input_data, _JSAMPARRAY output_data)\n{\n  int outrow;\n  JDIMENSION colctr;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n  JDIMENSION output_cols = compptr->width_in_blocks * data_unit;\n  register _JSAMPROW inptr, above_ptr, below_ptr, outptr;\n  JLONG membersum, neighsum, memberscale, neighscale;\n  int colsum, lastcolsum, nextcolsum;\n\n  /* Expand input data enough to let all the output samples be generated\n   * by the standard loop.  Special-casing padded output would be more\n   * efficient.\n   */\n  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,\n                    cinfo->image_width, output_cols);\n\n  /* Each of the eight neighbor pixels contributes a fraction SF to the\n   * smoothed pixel, while the main pixel contributes (1-8*SF).  In order\n   * to use integer arithmetic, these factors are multiplied by 2^16 = 65536.\n   * Also recall that SF = smoothing_factor / 1024.\n   */\n\n  memberscale = 65536L - cinfo->smoothing_factor * 512L; /* scaled 1-8*SF */\n  neighscale = cinfo->smoothing_factor * 64; /* scaled SF */\n\n  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {\n    outptr = output_data[outrow];\n    inptr = input_data[outrow];\n    above_ptr = input_data[outrow - 1];\n    below_ptr = input_data[outrow + 1];\n\n    /* Special case for first column */\n    colsum = (*above_ptr++) + (*below_ptr++) + inptr[0];\n    membersum = *inptr++;\n    nextcolsum = above_ptr[0] + below_ptr[0] + inptr[0];\n    neighsum = colsum + (colsum - membersum) + nextcolsum;\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr++ = (_JSAMPLE)((membersum + 32768) >> 16);\n    lastcolsum = colsum;  colsum = nextcolsum;\n\n    for (colctr = output_cols - 2; colctr > 0; colctr--) {\n      membersum = *inptr++;\n      above_ptr++;  below_ptr++;\n      nextcolsum = above_ptr[0] + below_ptr[0] + inptr[0];\n      neighsum = lastcolsum + (colsum - membersum) + nextcolsum;\n      membersum = membersum * memberscale + neighsum * neighscale;\n      *outptr++ = (_JSAMPLE)((membersum + 32768) >> 16);\n      lastcolsum = colsum;  colsum = nextcolsum;\n    }\n\n    /* Special case for last column */\n    membersum = *inptr;\n    neighsum = lastcolsum + (colsum - membersum) + colsum;\n    membersum = membersum * memberscale + neighsum * neighscale;\n    *outptr = (_JSAMPLE)((membersum + 32768) >> 16);\n\n  }\n}\n\n#endif /* INPUT_SMOOTHING_SUPPORTED */\n\n\n/*\n * Module initialization routine for downsampling.\n * Note that we must select a routine for each component.\n */\n\nGLOBAL(void)\n_jinit_downsampler(j_compress_ptr cinfo)\n{\n  my_downsample_ptr downsample;\n  int ci;\n  jpeg_component_info *compptr;\n  boolean smoothok = TRUE;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  downsample = (my_downsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_downsampler));\n  cinfo->downsample = (struct jpeg_downsampler *)downsample;\n  downsample->pub.start_pass = start_pass_downsample;\n  downsample->pub._downsample = sep_downsample;\n  downsample->pub.need_context_rows = FALSE;\n\n  if (cinfo->CCIR601_sampling)\n    ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);\n\n  /* Verify we can handle the sampling factors, and set up method pointers */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    if (compptr->h_samp_factor == cinfo->max_h_samp_factor &&\n        compptr->v_samp_factor == cinfo->max_v_samp_factor) {\n#ifdef INPUT_SMOOTHING_SUPPORTED\n      if (cinfo->smoothing_factor) {\n        downsample->methods[ci] = fullsize_smooth_downsample;\n        downsample->pub.need_context_rows = TRUE;\n      } else\n#endif\n        downsample->methods[ci] = fullsize_downsample;\n    } else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&\n               compptr->v_samp_factor == cinfo->max_v_samp_factor) {\n      smoothok = FALSE;\n#ifdef WITH_SIMD\n      if (jsimd_can_h2v1_downsample())\n        downsample->methods[ci] = jsimd_h2v1_downsample;\n      else\n#endif\n        downsample->methods[ci] = h2v1_downsample;\n    } else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&\n               compptr->v_samp_factor * 2 == cinfo->max_v_samp_factor) {\n#ifdef INPUT_SMOOTHING_SUPPORTED\n      if (cinfo->smoothing_factor) {\n#if defined(WITH_SIMD) && defined(__mips__)\n        if (jsimd_can_h2v2_smooth_downsample())\n          downsample->methods[ci] = jsimd_h2v2_smooth_downsample;\n        else\n#endif\n          downsample->methods[ci] = h2v2_smooth_downsample;\n        downsample->pub.need_context_rows = TRUE;\n      } else\n#endif\n      {\n#ifdef WITH_SIMD\n        if (jsimd_can_h2v2_downsample())\n          downsample->methods[ci] = jsimd_h2v2_downsample;\n        else\n#endif\n          downsample->methods[ci] = h2v2_downsample;\n      }\n    } else if ((cinfo->max_h_samp_factor % compptr->h_samp_factor) == 0 &&\n               (cinfo->max_v_samp_factor % compptr->v_samp_factor) == 0) {\n      smoothok = FALSE;\n      downsample->methods[ci] = int_downsample;\n    } else\n      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);\n  }\n\n#ifdef INPUT_SMOOTHING_SUPPORTED\n  if (cinfo->smoothing_factor && !smoothok)\n    TRACEMS(cinfo, 0, JTRC_SMOOTH_NOTIMPL);\n#endif\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED) */\n"
        },
        {
          "name": "jcstest.c",
          "type": "blob",
          "size": 3.7607421875,
          "content": "/*\n * Copyright (C)2011 D. R. Commander.  All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* This program demonstrates how to check for the colorspace extension\n   capabilities of libjpeg-turbo at both compile time and run time. */\n\n#include <stdio.h>\n#include <jpeglib.h>\n#include <jerror.h>\n#include <setjmp.h>\n\n#ifndef JCS_EXTENSIONS\n#define JCS_EXT_RGB  6\n#endif\n#if !defined(JCS_EXTENSIONS) || !defined(JCS_ALPHA_EXTENSIONS)\n#define JCS_EXT_RGBA  12\n#endif\n\nstatic char lasterror[JMSG_LENGTH_MAX] = \"No error\";\n\ntypedef struct _error_mgr {\n  struct jpeg_error_mgr pub;\n  jmp_buf jb;\n} error_mgr;\n\nstatic void my_error_exit(j_common_ptr cinfo)\n{\n  error_mgr *myerr = (error_mgr *)cinfo->err;\n  (*cinfo->err->output_message) (cinfo);\n  longjmp(myerr->jb, 1);\n}\n\nstatic void my_output_message(j_common_ptr cinfo)\n{\n  (*cinfo->err->format_message) (cinfo, lasterror);\n}\n\nint main(void)\n{\n  int jcs_valid = -1, jcs_alpha_valid = -1;\n  struct jpeg_compress_struct cinfo;\n  error_mgr jerr;\n\n  printf(\"libjpeg-turbo colorspace extensions:\\n\");\n#if JCS_EXTENSIONS\n  printf(\"  Present at compile time\\n\");\n#else\n  printf(\"  Not present at compile time\\n\");\n#endif\n\n  cinfo.err = jpeg_std_error(&jerr.pub);\n  jerr.pub.error_exit = my_error_exit;\n  jerr.pub.output_message = my_output_message;\n\n  if (setjmp(jerr.jb)) {\n    /* this will execute if libjpeg has an error */\n    jcs_valid = 0;\n    goto done;\n  }\n\n  jpeg_create_compress(&cinfo);\n  cinfo.input_components = 3;\n  jpeg_set_defaults(&cinfo);\n  cinfo.in_color_space = JCS_EXT_RGB;\n  jpeg_default_colorspace(&cinfo);\n  jcs_valid = 1;\n\ndone:\n  if (jcs_valid)\n    printf(\"  Working properly\\n\");\n  else\n    printf(\"  Not working properly.  Error returned was:\\n    %s\\n\",\n           lasterror);\n\n  printf(\"libjpeg-turbo alpha colorspace extensions:\\n\");\n#if JCS_ALPHA_EXTENSIONS\n  printf(\"  Present at compile time\\n\");\n#else\n  printf(\"  Not present at compile time\\n\");\n#endif\n\n  if (setjmp(jerr.jb)) {\n    /* this will execute if libjpeg has an error */\n    jcs_alpha_valid = 0;\n    goto done2;\n  }\n\n  cinfo.in_color_space = JCS_EXT_RGBA;\n  jpeg_default_colorspace(&cinfo);\n  jcs_alpha_valid = 1;\n\ndone2:\n  if (jcs_alpha_valid)\n    printf(\"  Working properly\\n\");\n  else\n    printf(\"  Not working properly.  Error returned was:\\n    %s\\n\",\n           lasterror);\n\n  jpeg_destroy_compress(&cinfo);\n  return 0;\n}\n"
        },
        {
          "name": "jctrans.c",
          "type": "blob",
          "size": 15.1748046875,
          "content": "/*\n * jctrans.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1995-1998, Thomas G. Lane.\n * Modified 2000-2009 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2020, 2022, D. R. Commander.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains library routines for transcoding compression,\n * that is, writing raw DCT coefficient arrays to an output JPEG file.\n * The routines in jcapimin.c will also be needed by a transcoder.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jpegapicomp.h\"\n\n\n/* Forward declarations */\nLOCAL(void) transencode_master_selection(j_compress_ptr cinfo,\n                                         jvirt_barray_ptr *coef_arrays);\nLOCAL(void) transencode_coef_controller(j_compress_ptr cinfo,\n                                        jvirt_barray_ptr *coef_arrays);\n\n\n/*\n * Compression initialization for writing raw-coefficient data.\n * Before calling this, all parameters and a data destination must be set up.\n * Call jpeg_finish_compress() to actually write the data.\n *\n * The number of passed virtual arrays must match cinfo->num_components.\n * Note that the virtual arrays need not be filled or even realized at\n * the time write_coefficients is called; indeed, if the virtual arrays\n * were requested from this compression object's memory manager, they\n * typically will be realized during this routine and filled afterwards.\n */\n\nGLOBAL(void)\njpeg_write_coefficients(j_compress_ptr cinfo, jvirt_barray_ptr *coef_arrays)\n{\n  if (cinfo->master->lossless)\n    ERREXIT(cinfo, JERR_NOTIMPL);\n\n  /* setting up scan optimisation pattern failed, disable scan optimisation */\n  if (cinfo->master->num_scans_luma == 0)\n    cinfo->master->optimize_scans = FALSE;\n  \n  if (cinfo->global_state != CSTATE_START)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  /* Mark all tables to be written */\n  jpeg_suppress_tables(cinfo, FALSE);\n  /* (Re)initialize error mgr and destination modules */\n  (*cinfo->err->reset_error_mgr) ((j_common_ptr)cinfo);\n  (*cinfo->dest->init_destination) (cinfo);\n  /* Perform master selection of active modules */\n  transencode_master_selection(cinfo, coef_arrays);\n  /* Wait for jpeg_finish_compress() call */\n  cinfo->next_scanline = 0;     /* so jpeg_write_marker works */\n  cinfo->global_state = CSTATE_WRCOEFS;\n}\n\n\n/*\n * Initialize the compression object with default parameters,\n * then copy from the source object all parameters needed for lossless\n * transcoding.  Parameters that can be varied without loss (such as\n * scan script and Huffman optimization) are left in their default states.\n */\n\nGLOBAL(void)\njpeg_copy_critical_parameters (const j_decompress_ptr srcinfo, j_compress_ptr dstinfo)\n{\n  JQUANT_TBL **qtblptr;\n  jpeg_component_info *incomp, *outcomp;\n  JQUANT_TBL *c_quant, *slot_quant;\n  int tblno, ci, coefi;\n\n  if (srcinfo->master->lossless)\n    ERREXIT(dstinfo, JERR_NOTIMPL);\n\n  /* Safety check to ensure start_compress not called yet. */\n  if (dstinfo->global_state != CSTATE_START)\n    ERREXIT1(dstinfo, JERR_BAD_STATE, dstinfo->global_state);\n  /* Copy fundamental image dimensions */\n  dstinfo->image_width = srcinfo->image_width;\n  dstinfo->image_height = srcinfo->image_height;\n  dstinfo->input_components = srcinfo->num_components;\n  dstinfo->in_color_space = srcinfo->jpeg_color_space;\n#if JPEG_LIB_VERSION >= 70\n  dstinfo->jpeg_width = srcinfo->output_width;\n  dstinfo->jpeg_height = srcinfo->output_height;\n  dstinfo->min_DCT_h_scaled_size = srcinfo->min_DCT_h_scaled_size;\n  dstinfo->min_DCT_v_scaled_size = srcinfo->min_DCT_v_scaled_size;\n#endif\n  /* Initialize all parameters to default values */\n  jpeg_set_defaults(dstinfo);\n  dstinfo->master->trellis_quant = FALSE;\n  \n  /* jpeg_set_defaults may choose wrong colorspace, eg YCbCr if input is RGB.\n   * Fix it to get the right header markers for the image colorspace.\n   */\n  jpeg_set_colorspace(dstinfo, srcinfo->jpeg_color_space);\n  dstinfo->data_precision = srcinfo->data_precision;\n  dstinfo->CCIR601_sampling = srcinfo->CCIR601_sampling;\n  /* Copy the source's quantization tables. */\n  for (tblno = 0; tblno < NUM_QUANT_TBLS; tblno++) {\n    if (srcinfo->quant_tbl_ptrs[tblno] != NULL) {\n      qtblptr = &dstinfo->quant_tbl_ptrs[tblno];\n      if (*qtblptr == NULL)\n        *qtblptr = jpeg_alloc_quant_table((j_common_ptr)dstinfo);\n      memcpy((*qtblptr)->quantval, srcinfo->quant_tbl_ptrs[tblno]->quantval,\n             sizeof((*qtblptr)->quantval));\n      (*qtblptr)->sent_table = FALSE;\n    }\n  }\n  /* Copy the source's per-component info.\n   * Note we assume jpeg_set_defaults has allocated the dest comp_info array.\n   */\n  dstinfo->num_components = srcinfo->num_components;\n  if (dstinfo->num_components < 1 || dstinfo->num_components > MAX_COMPONENTS)\n    ERREXIT2(dstinfo, JERR_COMPONENT_COUNT, dstinfo->num_components,\n             MAX_COMPONENTS);\n  for (ci = 0, incomp = srcinfo->comp_info, outcomp = dstinfo->comp_info;\n       ci < dstinfo->num_components; ci++, incomp++, outcomp++) {\n    outcomp->component_id = incomp->component_id;\n    outcomp->h_samp_factor = incomp->h_samp_factor;\n    outcomp->v_samp_factor = incomp->v_samp_factor;\n    outcomp->quant_tbl_no = incomp->quant_tbl_no;\n    /* Make sure saved quantization table for component matches the qtable\n     * slot.  If not, the input file re-used this qtable slot.\n     * IJG encoder currently cannot duplicate this.\n     */\n    tblno = outcomp->quant_tbl_no;\n    if (tblno < 0 || tblno >= NUM_QUANT_TBLS ||\n        srcinfo->quant_tbl_ptrs[tblno] == NULL)\n      ERREXIT1(dstinfo, JERR_NO_QUANT_TABLE, tblno);\n    slot_quant = srcinfo->quant_tbl_ptrs[tblno];\n    c_quant = incomp->quant_table;\n    if (c_quant != NULL) {\n      for (coefi = 0; coefi < DCTSIZE2; coefi++) {\n        if (c_quant->quantval[coefi] != slot_quant->quantval[coefi])\n          ERREXIT1(dstinfo, JERR_MISMATCHED_QUANT_TABLE, tblno);\n      }\n    }\n    /* Note: we do not copy the source's Huffman table assignments;\n     * instead we rely on jpeg_set_colorspace to have made a suitable choice.\n     */\n  }\n  /* Also copy JFIF version and resolution information, if available.\n   * Strictly speaking this isn't \"critical\" info, but it's nearly\n   * always appropriate to copy it if available.  In particular,\n   * if the application chooses to copy JFIF 1.02 extension markers from\n   * the source file, we need to copy the version to make sure we don't\n   * emit a file that has 1.02 extensions but a claimed version of 1.01.\n   * We will *not*, however, copy version info from mislabeled \"2.01\" files.\n   */\n  if (srcinfo->saw_JFIF_marker) {\n    if (srcinfo->JFIF_major_version == 1) {\n      dstinfo->JFIF_major_version = srcinfo->JFIF_major_version;\n      dstinfo->JFIF_minor_version = srcinfo->JFIF_minor_version;\n    }\n    dstinfo->density_unit = srcinfo->density_unit;\n    dstinfo->X_density = srcinfo->X_density;\n    dstinfo->Y_density = srcinfo->Y_density;\n  }\n}\n\n\n/*\n * Master selection of compression modules for transcoding.\n * This substitutes for jcinit.c's initialization of the full compressor.\n */\n\nLOCAL(void)\ntransencode_master_selection(j_compress_ptr cinfo,\n                             jvirt_barray_ptr *coef_arrays)\n{\n  /* Although we don't actually use input_components for transcoding,\n   * jcmaster.c's initial_setup will complain if input_components is 0.\n   */\n  cinfo->input_components = 1;\n  /* Initialize master control (includes parameter checking/processing) */\n  jinit_c_master_control(cinfo, TRUE /* transcode only */);\n\n  /* Entropy encoding: either Huffman or arithmetic coding. */\n  if (cinfo->arith_code) {\n#ifdef C_ARITH_CODING_SUPPORTED\n    jinit_arith_encoder(cinfo);\n#else\n    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);\n#endif\n  } else {\n    if (cinfo->progressive_mode) {\n#ifdef C_PROGRESSIVE_SUPPORTED\n      jinit_phuff_encoder(cinfo);\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n    } else\n      jinit_huff_encoder(cinfo);\n  }\n\n  /* We need a special coefficient buffer controller. */\n  transencode_coef_controller(cinfo, coef_arrays);\n\n  jinit_marker_writer(cinfo);\n\n  /* We can now tell the memory manager to allocate virtual arrays. */\n  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr)cinfo);\n\n  /* Write the datastream header (SOI, JFIF) immediately.\n   * Frame and scan headers are postponed till later.\n   * This lets application insert special markers after the SOI.\n   */\n  (*cinfo->marker->write_file_header) (cinfo);\n}\n\n\n/*\n * The rest of this file is a special implementation of the coefficient\n * buffer controller.  This is similar to jccoefct.c, but it handles only\n * output from presupplied virtual arrays.  Furthermore, we generate any\n * dummy padding blocks on-the-fly rather than expecting them to be present\n * in the arrays.\n */\n\n/* Private buffer controller object */\n\ntypedef struct {\n  struct jpeg_c_coef_controller pub; /* public fields */\n\n  JDIMENSION iMCU_row_num;      /* iMCU row # within image */\n  JDIMENSION mcu_ctr;           /* counts MCUs processed in current row */\n  int MCU_vert_offset;          /* counts MCU rows within iMCU row */\n  int MCU_rows_per_iMCU_row;    /* number of such rows needed */\n\n  /* Virtual block array for each component. */\n  jvirt_barray_ptr *whole_image;\n\n  /* Workspace for constructing dummy blocks at right/bottom edges. */\n  JBLOCKROW dummy_buffer[C_MAX_BLOCKS_IN_MCU];\n} my_coef_controller;\n\ntypedef my_coef_controller *my_coef_ptr;\n\n\nLOCAL(void)\nstart_iMCU_row(j_compress_ptr cinfo)\n/* Reset within-iMCU-row counters for a new row */\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n\n  /* In an interleaved scan, an MCU row is the same as an iMCU row.\n   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.\n   * But at the bottom of the image, process only what's left.\n   */\n  if (cinfo->comps_in_scan > 1) {\n    coef->MCU_rows_per_iMCU_row = 1;\n  } else {\n    if (coef->iMCU_row_num < (cinfo->total_iMCU_rows - 1))\n      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;\n    else\n      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;\n  }\n\n  coef->mcu_ctr = 0;\n  coef->MCU_vert_offset = 0;\n}\n\n\n/*\n * Initialize for a processing pass.\n */\n\nMETHODDEF(void)\nstart_pass_coef(j_compress_ptr cinfo, J_BUF_MODE pass_mode)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n\n  if (pass_mode != JBUF_CRANK_DEST)\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n\n  coef->iMCU_row_num = 0;\n  start_iMCU_row(cinfo);\n}\n\n\n/*\n * Process some data.\n * We process the equivalent of one fully interleaved MCU row (\"iMCU\" row)\n * per call, ie, v_samp_factor block rows for each component in the scan.\n * The data is obtained from the virtual arrays and fed to the entropy coder.\n * Returns TRUE if the iMCU row is completed, FALSE if suspended.\n *\n * NB: input_buf is ignored; it is likely to be a NULL pointer.\n */\n\nMETHODDEF(boolean)\ncompress_output(j_compress_ptr cinfo, JSAMPIMAGE input_buf)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  JDIMENSION MCU_col_num;       /* index of current MCU within row */\n  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  int blkn, ci, xindex, yindex, yoffset, blockcnt;\n  JDIMENSION start_col;\n  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];\n  JBLOCKROW MCU_buffer[C_MAX_BLOCKS_IN_MCU];\n  JBLOCKROW buffer_ptr;\n  jpeg_component_info *compptr;\n\n  /* Align the virtual buffers for the components used in this scan. */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    buffer[ci] = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr)cinfo, coef->whole_image[compptr->component_index],\n       coef->iMCU_row_num * compptr->v_samp_factor,\n       (JDIMENSION)compptr->v_samp_factor, FALSE);\n  }\n\n  /* Loop to process one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;\n         MCU_col_num++) {\n      /* Construct list of pointers to DCT blocks belonging to this MCU */\n      blkn = 0;                 /* index of current DCT block within MCU */\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n        compptr = cinfo->cur_comp_info[ci];\n        start_col = MCU_col_num * compptr->MCU_width;\n        blockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width :\n                                                  compptr->last_col_width;\n        for (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n          if (coef->iMCU_row_num < last_iMCU_row ||\n              yindex + yoffset < compptr->last_row_height) {\n            /* Fill in pointers to real blocks in this row */\n            buffer_ptr = buffer[ci][yindex + yoffset] + start_col;\n            for (xindex = 0; xindex < blockcnt; xindex++)\n              MCU_buffer[blkn++] = buffer_ptr++;\n          } else {\n            /* At bottom of image, need a whole row of dummy blocks */\n            xindex = 0;\n          }\n          /* Fill in any dummy blocks needed in this row.\n           * Dummy blocks are filled in the same way as in jccoefct.c:\n           * all zeroes in the AC entries, DC entries equal to previous\n           * block's DC value.  The init routine has already zeroed the\n           * AC entries, so we need only set the DC entries correctly.\n           */\n          for (; xindex < compptr->MCU_width; xindex++) {\n            MCU_buffer[blkn] = coef->dummy_buffer[blkn];\n            MCU_buffer[blkn][0][0] = MCU_buffer[blkn - 1][0][0];\n            blkn++;\n          }\n        }\n      }\n      /* Try to write the MCU. */\n      if (!(*cinfo->entropy->encode_mcu) (cinfo, MCU_buffer)) {\n        /* Suspension forced; update state counters and exit */\n        coef->MCU_vert_offset = yoffset;\n        coef->mcu_ctr = MCU_col_num;\n        return FALSE;\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->mcu_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  coef->iMCU_row_num++;\n  start_iMCU_row(cinfo);\n  return TRUE;\n}\n\n\nMETHODDEF(boolean)\ncompress_output_12(j_compress_ptr cinfo, J12SAMPIMAGE input_buf)\n{\n  return compress_output(cinfo, (JSAMPIMAGE)input_buf);\n}\n\n\n/*\n * Initialize coefficient buffer controller.\n *\n * Each passed coefficient array must be the right size for that\n * coefficient: width_in_blocks wide and height_in_blocks high,\n * with unitheight at least v_samp_factor.\n */\n\nLOCAL(void)\ntransencode_coef_controller(j_compress_ptr cinfo,\n                            jvirt_barray_ptr *coef_arrays)\n{\n  my_coef_ptr coef;\n  JBLOCKROW buffer;\n  int i;\n\n  coef = (my_coef_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_coef_controller));\n  cinfo->coef = (struct jpeg_c_coef_controller *)coef;\n  coef->pub.start_pass = start_pass_coef;\n  coef->pub.compress_data = compress_output;\n  coef->pub.compress_data_12 = compress_output_12;\n\n  /* Save pointer to virtual arrays */\n  coef->whole_image = coef_arrays;\n\n  /* Allocate and pre-zero space for dummy DCT blocks. */\n  buffer = (JBLOCKROW)\n    (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                C_MAX_BLOCKS_IN_MCU * sizeof(JBLOCK));\n  jzero_far((void *)buffer, C_MAX_BLOCKS_IN_MCU * sizeof(JBLOCK));\n  for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {\n    coef->dummy_buffer[i] = buffer + i;\n  }\n}\n"
        },
        {
          "name": "jdapimin.c",
          "type": "blob",
          "size": 13.373046875,
          "content": "/*\n * jdapimin.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1998, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2016, 2022, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains application interface code for the decompression half\n * of the JPEG library.  These are the \"minimum\" API routines that may be\n * needed in either the normal full-decompression case or the\n * transcoding-only case.\n *\n * Most of the routines intended to be called directly by an application\n * are in this file or in jdapistd.c.  But also see jcomapi.c for routines\n * shared by compression and decompression, and jdtrans.c for the transcoding\n * case.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdmaster.h\"\n\n\n/*\n * Initialization of a JPEG decompression object.\n * The error manager must already be set up (in case memory manager fails).\n */\n\nGLOBAL(void)\njpeg_CreateDecompress(j_decompress_ptr cinfo, int version, size_t structsize)\n{\n  int i;\n\n  /* Guard against version mismatches between library and caller. */\n  cinfo->mem = NULL;            /* so jpeg_destroy knows mem mgr not called */\n  if (version != JPEG_LIB_VERSION)\n    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);\n  if (structsize != sizeof(struct jpeg_decompress_struct))\n    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE,\n             (int)sizeof(struct jpeg_decompress_struct), (int)structsize);\n\n  /* For debugging purposes, we zero the whole master structure.\n   * But the application has already set the err pointer, and may have set\n   * client_data, so we have to save and restore those fields.\n   * Note: if application hasn't set client_data, tools like Purify may\n   * complain here.\n   */\n  {\n    struct jpeg_error_mgr *err = cinfo->err;\n    void *client_data = cinfo->client_data; /* ignore Purify complaint here */\n    memset(cinfo, 0, sizeof(struct jpeg_decompress_struct));\n    cinfo->err = err;\n    cinfo->client_data = client_data;\n  }\n  cinfo->is_decompressor = TRUE;\n\n  /* Initialize a memory manager instance for this object */\n  jinit_memory_mgr((j_common_ptr)cinfo);\n\n  /* Zero out pointers to permanent structures. */\n  cinfo->progress = NULL;\n  cinfo->src = NULL;\n\n  for (i = 0; i < NUM_QUANT_TBLS; i++)\n    cinfo->quant_tbl_ptrs[i] = NULL;\n\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    cinfo->dc_huff_tbl_ptrs[i] = NULL;\n    cinfo->ac_huff_tbl_ptrs[i] = NULL;\n  }\n\n  /* Initialize marker processor so application can override methods\n   * for COM, APPn markers before calling jpeg_read_header.\n   */\n  cinfo->marker_list = NULL;\n  jinit_marker_reader(cinfo);\n\n  /* And initialize the overall input controller. */\n  jinit_input_controller(cinfo);\n\n  cinfo->data_precision = BITS_IN_JSAMPLE;\n\n  /* OK, I'm ready */\n  cinfo->global_state = DSTATE_START;\n\n  /* The master struct is used to store extension parameters, so we allocate it\n   * here.\n   */\n  cinfo->master = (struct jpeg_decomp_master *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_decomp_master));\n  memset(cinfo->master, 0, sizeof(my_decomp_master));\n}\n\n\n/*\n * Destruction of a JPEG decompression object\n */\n\nGLOBAL(void)\njpeg_destroy_decompress(j_decompress_ptr cinfo)\n{\n  jpeg_destroy((j_common_ptr)cinfo); /* use common routine */\n}\n\n\n/*\n * Abort processing of a JPEG decompression operation,\n * but don't destroy the object itself.\n */\n\nGLOBAL(void)\njpeg_abort_decompress(j_decompress_ptr cinfo)\n{\n  jpeg_abort((j_common_ptr)cinfo); /* use common routine */\n}\n\n\n/*\n * Set default decompression parameters.\n */\n\nLOCAL(void)\ndefault_decompress_parms(j_decompress_ptr cinfo)\n{\n  /* Guess the input colorspace, and set output colorspace accordingly. */\n  /* (Wish JPEG committee had provided a real way to specify this...) */\n  /* Note application may override our guesses. */\n  switch (cinfo->num_components) {\n  case 1:\n    cinfo->jpeg_color_space = JCS_GRAYSCALE;\n    cinfo->out_color_space = JCS_GRAYSCALE;\n    break;\n\n  case 3:\n    if (cinfo->saw_JFIF_marker) {\n      cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */\n    } else if (cinfo->saw_Adobe_marker) {\n      switch (cinfo->Adobe_transform) {\n      case 0:\n        cinfo->jpeg_color_space = JCS_RGB;\n        break;\n      case 1:\n        cinfo->jpeg_color_space = JCS_YCbCr;\n        break;\n      default:\n        WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);\n        cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */\n        break;\n      }\n    } else {\n      /* Saw no special markers, try to guess from the component IDs */\n      int cid0 = cinfo->comp_info[0].component_id;\n      int cid1 = cinfo->comp_info[1].component_id;\n      int cid2 = cinfo->comp_info[2].component_id;\n\n      if (cid0 == 1 && cid1 == 2 && cid2 == 3) {\n#ifdef D_LOSSLESS_SUPPORTED\n        if (cinfo->master->lossless)\n          cinfo->jpeg_color_space = JCS_RGB; /* assume RGB w/out marker */\n        else\n#endif\n          cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */\n      } else if (cid0 == 82 && cid1 == 71 && cid2 == 66)\n        cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */\n      else {\n        TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);\n#ifdef D_LOSSLESS_SUPPORTED\n        if (cinfo->master->lossless)\n          cinfo->jpeg_color_space = JCS_RGB; /* assume it's RGB */\n        else\n#endif\n          cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */\n      }\n    }\n    /* Always guess RGB is proper output colorspace. */\n    cinfo->out_color_space = JCS_RGB;\n    break;\n\n  case 4:\n    if (cinfo->saw_Adobe_marker) {\n      switch (cinfo->Adobe_transform) {\n      case 0:\n        cinfo->jpeg_color_space = JCS_CMYK;\n        break;\n      case 2:\n        cinfo->jpeg_color_space = JCS_YCCK;\n        break;\n      default:\n        WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);\n        cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */\n        break;\n      }\n    } else {\n      /* No special markers, assume straight CMYK. */\n      cinfo->jpeg_color_space = JCS_CMYK;\n    }\n    cinfo->out_color_space = JCS_CMYK;\n    break;\n\n  default:\n    cinfo->jpeg_color_space = JCS_UNKNOWN;\n    cinfo->out_color_space = JCS_UNKNOWN;\n    break;\n  }\n\n  /* Set defaults for other decompression parameters. */\n  cinfo->scale_num = 1;         /* 1:1 scaling */\n  cinfo->scale_denom = 1;\n  cinfo->output_gamma = 1.0;\n  cinfo->buffered_image = FALSE;\n  cinfo->raw_data_out = FALSE;\n  cinfo->dct_method = JDCT_DEFAULT;\n  cinfo->do_fancy_upsampling = TRUE;\n  cinfo->do_block_smoothing = TRUE;\n  cinfo->quantize_colors = FALSE;\n  /* We set these in case application only sets quantize_colors. */\n  cinfo->dither_mode = JDITHER_FS;\n#ifdef QUANT_2PASS_SUPPORTED\n  cinfo->two_pass_quantize = TRUE;\n#else\n  cinfo->two_pass_quantize = FALSE;\n#endif\n  cinfo->desired_number_of_colors = 256;\n  cinfo->colormap = NULL;\n  /* Initialize for no mode change in buffered-image mode. */\n  cinfo->enable_1pass_quant = FALSE;\n  cinfo->enable_external_quant = FALSE;\n  cinfo->enable_2pass_quant = FALSE;\n}\n\n\n/*\n * Decompression startup: read start of JPEG datastream to see what's there.\n * Need only initialize JPEG object and supply a data source before calling.\n *\n * This routine will read as far as the first SOS marker (ie, actual start of\n * compressed data), and will save all tables and parameters in the JPEG\n * object.  It will also initialize the decompression parameters to default\n * values, and finally return JPEG_HEADER_OK.  On return, the application may\n * adjust the decompression parameters and then call jpeg_start_decompress.\n * (Or, if the application only wanted to determine the image parameters,\n * the data need not be decompressed.  In that case, call jpeg_abort or\n * jpeg_destroy to release any temporary space.)\n * If an abbreviated (tables only) datastream is presented, the routine will\n * return JPEG_HEADER_TABLES_ONLY upon reaching EOI.  The application may then\n * re-use the JPEG object to read the abbreviated image datastream(s).\n * It is unnecessary (but OK) to call jpeg_abort in this case.\n * The JPEG_SUSPENDED return code only occurs if the data source module\n * requests suspension of the decompressor.  In this case the application\n * should load more source data and then re-call jpeg_read_header to resume\n * processing.\n * If a non-suspending data source is used and require_image is TRUE, then the\n * return code need not be inspected since only JPEG_HEADER_OK is possible.\n *\n * This routine is now just a front end to jpeg_consume_input, with some\n * extra error checking.\n */\n\nGLOBAL(int)\njpeg_read_header(j_decompress_ptr cinfo, boolean require_image)\n{\n  int retcode;\n\n  if (cinfo->global_state != DSTATE_START &&\n      cinfo->global_state != DSTATE_INHEADER)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  retcode = jpeg_consume_input(cinfo);\n\n  switch (retcode) {\n  case JPEG_REACHED_SOS:\n    retcode = JPEG_HEADER_OK;\n    break;\n  case JPEG_REACHED_EOI:\n    if (require_image)          /* Complain if application wanted an image */\n      ERREXIT(cinfo, JERR_NO_IMAGE);\n    /* Reset to start state; it would be safer to require the application to\n     * call jpeg_abort, but we can't change it now for compatibility reasons.\n     * A side effect is to free any temporary memory (there shouldn't be any).\n     */\n    jpeg_abort((j_common_ptr)cinfo); /* sets state = DSTATE_START */\n    retcode = JPEG_HEADER_TABLES_ONLY;\n    break;\n  case JPEG_SUSPENDED:\n    /* no work */\n    break;\n  }\n\n  return retcode;\n}\n\n\n/*\n * Consume data in advance of what the decompressor requires.\n * This can be called at any time once the decompressor object has\n * been created and a data source has been set up.\n *\n * This routine is essentially a state machine that handles a couple\n * of critical state-transition actions, namely initial setup and\n * transition from header scanning to ready-for-start_decompress.\n * All the actual input is done via the input controller's consume_input\n * method.\n */\n\nGLOBAL(int)\njpeg_consume_input(j_decompress_ptr cinfo)\n{\n  int retcode = JPEG_SUSPENDED;\n\n  /* NB: every possible DSTATE value should be listed in this switch */\n  switch (cinfo->global_state) {\n  case DSTATE_START:\n    /* Start-of-datastream actions: reset appropriate modules */\n    (*cinfo->inputctl->reset_input_controller) (cinfo);\n    /* Initialize application's data source module */\n    (*cinfo->src->init_source) (cinfo);\n    cinfo->global_state = DSTATE_INHEADER;\n    FALLTHROUGH                 /*FALLTHROUGH*/\n  case DSTATE_INHEADER:\n    retcode = (*cinfo->inputctl->consume_input) (cinfo);\n    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */\n      /* Set up default parameters based on header data */\n      default_decompress_parms(cinfo);\n      /* Set global state: ready for start_decompress */\n      cinfo->global_state = DSTATE_READY;\n    }\n    break;\n  case DSTATE_READY:\n    /* Can't advance past first SOS until start_decompress is called */\n    retcode = JPEG_REACHED_SOS;\n    break;\n  case DSTATE_PRELOAD:\n  case DSTATE_PRESCAN:\n  case DSTATE_SCANNING:\n  case DSTATE_RAW_OK:\n  case DSTATE_BUFIMAGE:\n  case DSTATE_BUFPOST:\n  case DSTATE_STOPPING:\n    retcode = (*cinfo->inputctl->consume_input) (cinfo);\n    break;\n  default:\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  }\n  return retcode;\n}\n\n\n/*\n * Have we finished reading the input file?\n */\n\nGLOBAL(boolean)\njpeg_input_complete (const j_decompress_ptr cinfo)\n{\n  /* Check for valid jpeg object */\n  if (cinfo->global_state < DSTATE_START ||\n      cinfo->global_state > DSTATE_STOPPING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  return cinfo->inputctl->eoi_reached;\n}\n\n\n/*\n * Is there more than one scan?\n */\n\nGLOBAL(boolean)\njpeg_has_multiple_scans (const j_decompress_ptr cinfo)\n{\n  /* Only valid after jpeg_read_header completes */\n  if (cinfo->global_state < DSTATE_READY ||\n      cinfo->global_state > DSTATE_STOPPING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  return cinfo->inputctl->has_multiple_scans;\n}\n\n\n/*\n * Finish JPEG decompression.\n *\n * This will normally just verify the file trailer and release temp storage.\n *\n * Returns FALSE if suspended.  The return value need be inspected only if\n * a suspending data source is used.\n */\n\nGLOBAL(boolean)\njpeg_finish_decompress(j_decompress_ptr cinfo)\n{\n  if ((cinfo->global_state == DSTATE_SCANNING ||\n       cinfo->global_state == DSTATE_RAW_OK) && !cinfo->buffered_image) {\n    /* Terminate final pass of non-buffered mode */\n    if (cinfo->output_scanline < cinfo->output_height)\n      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);\n    (*cinfo->master->finish_output_pass) (cinfo);\n    cinfo->global_state = DSTATE_STOPPING;\n  } else if (cinfo->global_state == DSTATE_BUFIMAGE) {\n    /* Finishing after a buffered-image operation */\n    cinfo->global_state = DSTATE_STOPPING;\n  } else if (cinfo->global_state != DSTATE_STOPPING) {\n    /* STOPPING = repeat call after a suspension, anything else is error */\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  }\n  /* Read until EOI */\n  while (!cinfo->inputctl->eoi_reached) {\n    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)\n      return FALSE;             /* Suspend, come back later */\n  }\n  /* Do final cleanup */\n  (*cinfo->src->term_source) (cinfo);\n  /* We can use jpeg_abort to release memory and reset global_state */\n  jpeg_abort((j_common_ptr)cinfo);\n  return TRUE;\n}\n"
        },
        {
          "name": "jdapistd.c",
          "type": "blob",
          "size": 27.435546875,
          "content": "/*\n * jdapistd.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010, 2015-2020, 2022-2024, D. R. Commander.\n * Copyright (C) 2015, Google, Inc.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains application interface code for the decompression half\n * of the JPEG library.  These are the \"standard\" API routines that are\n * used in the normal full-decompression case.  They are not used by a\n * transcoding-only application.  Note that if an application links in\n * jpeg_start_decompress, it will end up linking in the entire decompressor.\n * We thus must separate this file from jdapimin.c to avoid linking the\n * whole decompression library into a transcoder.\n */\n\n#include \"jinclude.h\"\n#if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)\n#include \"jdmainct.h\"\n#include \"jdcoefct.h\"\n#else\n#define JPEG_INTERNALS\n#include \"jpeglib.h\"\n#endif\n#include \"jdmaster.h\"\n#include \"jdmerge.h\"\n#include \"jdsample.h\"\n#include \"jmemsys.h\"\n\n#if BITS_IN_JSAMPLE == 8\n\n/* Forward declarations */\nLOCAL(boolean) output_pass_setup(j_decompress_ptr cinfo);\n\n\n/*\n * Decompression initialization.\n * jpeg_read_header must be completed before calling this.\n *\n * If a multipass operating mode was selected, this will do all but the\n * last pass, and thus may take a great deal of time.\n *\n * Returns FALSE if suspended.  The return value need be inspected only if\n * a suspending data source is used.\n */\n\nGLOBAL(boolean)\njpeg_start_decompress(j_decompress_ptr cinfo)\n{\n  if (cinfo->global_state == DSTATE_READY) {\n    /* First call: initialize master control, select active modules */\n    jinit_master_decompress(cinfo);\n    if (cinfo->buffered_image) {\n      /* No more work here; expecting jpeg_start_output next */\n      cinfo->global_state = DSTATE_BUFIMAGE;\n      return TRUE;\n    }\n    cinfo->global_state = DSTATE_PRELOAD;\n  }\n  if (cinfo->global_state == DSTATE_PRELOAD) {\n    /* If file has multiple scans, absorb them all into the coef buffer */\n    if (cinfo->inputctl->has_multiple_scans) {\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n      for (;;) {\n        int retcode;\n        /* Call progress monitor hook if present */\n        if (cinfo->progress != NULL)\n          (*cinfo->progress->progress_monitor) ((j_common_ptr)cinfo);\n        /* Absorb some more input */\n        retcode = (*cinfo->inputctl->consume_input) (cinfo);\n        if (retcode == JPEG_SUSPENDED)\n          return FALSE;\n        if (retcode == JPEG_REACHED_EOI)\n          break;\n        /* Advance progress counter if appropriate */\n        if (cinfo->progress != NULL &&\n            (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {\n          if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {\n            /* jdmaster underestimated number of scans; ratchet up one scan */\n            cinfo->progress->pass_limit += (long)cinfo->total_iMCU_rows;\n          }\n        }\n      }\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\n    }\n    cinfo->output_scan_number = cinfo->input_scan_number;\n  } else if (cinfo->global_state != DSTATE_PRESCAN)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  /* Perform any dummy output passes, and set up for the final pass */\n  return output_pass_setup(cinfo);\n}\n\n\n/*\n * Set up for an output pass, and perform any dummy pass(es) needed.\n * Common subroutine for jpeg_start_decompress and jpeg_start_output.\n * Entry: global_state = DSTATE_PRESCAN only if previously suspended.\n * Exit: If done, returns TRUE and sets global_state for proper output mode.\n *       If suspended, returns FALSE and sets global_state = DSTATE_PRESCAN.\n */\n\nLOCAL(boolean)\noutput_pass_setup(j_decompress_ptr cinfo)\n{\n  if (cinfo->global_state != DSTATE_PRESCAN) {\n    /* First call: do pass setup */\n    (*cinfo->master->prepare_for_output_pass) (cinfo);\n    cinfo->output_scanline = 0;\n    cinfo->global_state = DSTATE_PRESCAN;\n  }\n  /* Loop over any required dummy passes */\n  while (cinfo->master->is_dummy_pass) {\n#ifdef QUANT_2PASS_SUPPORTED\n    /* Crank through the dummy pass */\n    while (cinfo->output_scanline < cinfo->output_height) {\n      JDIMENSION last_scanline;\n      /* Call progress monitor hook if present */\n      if (cinfo->progress != NULL) {\n        cinfo->progress->pass_counter = (long)cinfo->output_scanline;\n        cinfo->progress->pass_limit = (long)cinfo->output_height;\n        (*cinfo->progress->progress_monitor) ((j_common_ptr)cinfo);\n      }\n      /* Process some data */\n      last_scanline = cinfo->output_scanline;\n      if (cinfo->data_precision == 16) {\n#ifdef D_LOSSLESS_SUPPORTED\n        if (cinfo->main->process_data_16 == NULL)\n          ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n        (*cinfo->main->process_data_16) (cinfo, (J16SAMPARRAY)NULL,\n                                         &cinfo->output_scanline,\n                                         (JDIMENSION)0);\n#else\n        ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n#endif\n      } else if (cinfo->data_precision == 12) {\n        if (cinfo->main->process_data_12 == NULL)\n          ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n        (*cinfo->main->process_data_12) (cinfo, (J12SAMPARRAY)NULL,\n                                         &cinfo->output_scanline,\n                                         (JDIMENSION)0);\n      } else {\n        if (cinfo->main->process_data == NULL)\n          ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n        (*cinfo->main->process_data) (cinfo, (JSAMPARRAY)NULL,\n                                      &cinfo->output_scanline, (JDIMENSION)0);\n      }\n      if (cinfo->output_scanline == last_scanline)\n        return FALSE;           /* No progress made, must suspend */\n    }\n    /* Finish up dummy pass, and set up for another one */\n    (*cinfo->master->finish_output_pass) (cinfo);\n    (*cinfo->master->prepare_for_output_pass) (cinfo);\n    cinfo->output_scanline = 0;\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif /* QUANT_2PASS_SUPPORTED */\n  }\n  /* Ready for application to drive output pass through\n   * _jpeg_read_scanlines or _jpeg_read_raw_data.\n   */\n  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;\n  return TRUE;\n}\n\n#endif /* BITS_IN_JSAMPLE == 8 */\n\n\n#if BITS_IN_JSAMPLE != 16\n\n/*\n * Enable partial scanline decompression\n *\n * Must be called after jpeg_start_decompress() and before any calls to\n * _jpeg_read_scanlines() or _jpeg_skip_scanlines().\n *\n * Refer to libjpeg.txt for more information.\n */\n\nGLOBAL(void)\n_jpeg_crop_scanline(j_decompress_ptr cinfo, JDIMENSION *xoffset,\n                    JDIMENSION *width)\n{\n  int ci, align, orig_downsampled_width;\n  JDIMENSION input_xoffset;\n  boolean reinit_upsampler = FALSE;\n  jpeg_component_info *compptr;\n#ifdef UPSAMPLE_MERGING_SUPPORTED\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n#endif\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  if (cinfo->master->lossless)\n    ERREXIT(cinfo, JERR_NOTIMPL);\n\n  if ((cinfo->global_state != DSTATE_SCANNING &&\n       cinfo->global_state != DSTATE_BUFIMAGE) || cinfo->output_scanline != 0)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  if (!xoffset || !width)\n    ERREXIT(cinfo, JERR_BAD_CROP_SPEC);\n\n  /* xoffset and width must fall within the output image dimensions. */\n  if (*width == 0 ||\n      (unsigned long long)(*xoffset) + *width > cinfo->output_width)\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n\n  /* No need to do anything if the caller wants the entire width. */\n  if (*width == cinfo->output_width)\n    return;\n\n  /* Ensuring the proper alignment of xoffset is tricky.  At minimum, it\n   * must align with an MCU boundary, because:\n   *\n   *   (1) The IDCT is performed in blocks, and it is not feasible to modify\n   *       the algorithm so that it can transform partial blocks.\n   *   (2) Because of the SIMD extensions, any input buffer passed to the\n   *       upsampling and color conversion routines must be aligned to the\n   *       SIMD word size (for instance, 128-bit in the case of SSE2.)  The\n   *       easiest way to accomplish this without copying data is to ensure\n   *       that upsampling and color conversion begin at the start of the\n   *       first MCU column that will be inverse transformed.\n   *\n   * In practice, we actually impose a stricter alignment requirement.  We\n   * require that xoffset be a multiple of the maximum MCU column width of all\n   * of the components (the \"iMCU column width.\")  This is to simplify the\n   * single-pass decompression case, allowing us to use the same MCU column\n   * width for all of the components.\n   */\n  if (cinfo->comps_in_scan == 1 && cinfo->num_components == 1)\n    align = cinfo->_min_DCT_scaled_size;\n  else\n    align = cinfo->_min_DCT_scaled_size * cinfo->max_h_samp_factor;\n\n  /* Adjust xoffset to the nearest iMCU boundary <= the requested value */\n  input_xoffset = *xoffset;\n  *xoffset = (input_xoffset / align) * align;\n\n  /* Adjust the width so that the right edge of the output image is as\n   * requested (only the left edge is altered.)  It is important that calling\n   * programs check this value after this function returns, so that they can\n   * allocate an output buffer with the appropriate size.\n   */\n  *width = *width + input_xoffset - *xoffset;\n  cinfo->output_width = *width;\n#ifdef UPSAMPLE_MERGING_SUPPORTED\n  if (master->using_merged_upsample && cinfo->max_v_samp_factor == 2) {\n    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n    upsample->out_row_width =\n      cinfo->output_width * cinfo->out_color_components;\n  }\n#endif\n\n  /* Set the first and last iMCU columns that we must decompress.  These values\n   * will be used in single-scan decompressions.\n   */\n  cinfo->master->first_iMCU_col = (JDIMENSION)(long)(*xoffset) / (long)align;\n  cinfo->master->last_iMCU_col =\n    (JDIMENSION)jdiv_round_up((long)(*xoffset + cinfo->output_width),\n                              (long)align) - 1;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    int hsf = (cinfo->comps_in_scan == 1 && cinfo->num_components == 1) ?\n              1 : compptr->h_samp_factor;\n\n    /* Set downsampled_width to the new output width. */\n    orig_downsampled_width = compptr->downsampled_width;\n    compptr->downsampled_width =\n      (JDIMENSION)jdiv_round_up((long)cinfo->output_width *\n                                (long)(compptr->h_samp_factor *\n                                       compptr->_DCT_scaled_size),\n                                (long)(cinfo->max_h_samp_factor *\n                                       cinfo->_min_DCT_scaled_size));\n    if (compptr->downsampled_width < 2 && orig_downsampled_width >= 2)\n      reinit_upsampler = TRUE;\n\n    /* Set the first and last iMCU columns that we must decompress.  These\n     * values will be used in multi-scan decompressions.\n     */\n    cinfo->master->first_MCU_col[ci] =\n      (JDIMENSION)(long)(*xoffset * hsf) / (long)align;\n    cinfo->master->last_MCU_col[ci] =\n      (JDIMENSION)jdiv_round_up((long)((*xoffset + cinfo->output_width) * hsf),\n                                (long)align) - 1;\n  }\n\n  if (reinit_upsampler) {\n    cinfo->master->jinit_upsampler_no_alloc = TRUE;\n    _jinit_upsampler(cinfo);\n    cinfo->master->jinit_upsampler_no_alloc = FALSE;\n  }\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 */\n\n\n/*\n * Read some scanlines of data from the JPEG decompressor.\n *\n * The return value will be the number of lines actually read.\n * This may be less than the number requested in several cases,\n * including bottom of image, data source suspension, and operating\n * modes that emit multiple scanlines at a time.\n *\n * Note: we warn about excess calls to _jpeg_read_scanlines() since\n * this likely signals an application programmer error.  However,\n * an oversize buffer (max_lines > scanlines remaining) is not an error.\n */\n\nGLOBAL(JDIMENSION)\n_jpeg_read_scanlines(j_decompress_ptr cinfo, _JSAMPARRAY scanlines,\n                     JDIMENSION max_lines)\n{\n#if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)\n  JDIMENSION row_ctr;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  if (cinfo->output_scanline >= cinfo->output_height) {\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\n    return 0;\n  }\n\n  /* Call progress monitor hook if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->pass_counter = (long)cinfo->output_scanline;\n    cinfo->progress->pass_limit = (long)cinfo->output_height;\n    (*cinfo->progress->progress_monitor) ((j_common_ptr)cinfo);\n  }\n\n  /* Process some data */\n  row_ctr = 0;\n  if (cinfo->main->_process_data == NULL)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n  (*cinfo->main->_process_data) (cinfo, scanlines, &row_ctr, max_lines);\n  cinfo->output_scanline += row_ctr;\n  return row_ctr;\n#else\n  ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n  return 0;\n#endif\n}\n\n\n#if BITS_IN_JSAMPLE != 16\n\n/* Dummy color convert function used by _jpeg_skip_scanlines() */\nLOCAL(void)\nnoop_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n             JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n}\n\n\n/* Dummy quantize function used by _jpeg_skip_scanlines() */\nLOCAL(void)\nnoop_quantize(j_decompress_ptr cinfo, _JSAMPARRAY input_buf,\n              _JSAMPARRAY output_buf, int num_rows)\n{\n}\n\n\n/*\n * In some cases, it is best to call _jpeg_read_scanlines() and discard the\n * output, rather than skipping the scanlines, because this allows us to\n * maintain the internal state of the context-based upsampler.  In these cases,\n * we set up and tear down a dummy color converter in order to avoid valgrind\n * errors and to achieve the best possible performance.\n */\n\nLOCAL(void)\nread_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  JDIMENSION n;\n#ifdef UPSAMPLE_MERGING_SUPPORTED\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n#endif\n  _JSAMPLE dummy_sample[1] = { 0 };\n  _JSAMPROW dummy_row = dummy_sample;\n  _JSAMPARRAY scanlines = NULL;\n  void (*color_convert) (j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                         JDIMENSION input_row, _JSAMPARRAY output_buf,\n                         int num_rows) = NULL;\n  void (*color_quantize) (j_decompress_ptr cinfo, _JSAMPARRAY input_buf,\n                          _JSAMPARRAY output_buf, int num_rows) = NULL;\n\n  if (cinfo->cconvert && cinfo->cconvert->_color_convert) {\n    color_convert = cinfo->cconvert->_color_convert;\n    cinfo->cconvert->_color_convert = noop_convert;\n    /* This just prevents UBSan from complaining about adding 0 to a NULL\n     * pointer.  The pointer isn't actually used.\n     */\n    scanlines = &dummy_row;\n  }\n\n  if (cinfo->cquantize && cinfo->cquantize->_color_quantize) {\n    color_quantize = cinfo->cquantize->_color_quantize;\n    cinfo->cquantize->_color_quantize = noop_quantize;\n  }\n\n#ifdef UPSAMPLE_MERGING_SUPPORTED\n  if (master->using_merged_upsample && cinfo->max_v_samp_factor == 2) {\n    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n    scanlines = &upsample->spare_row;\n  }\n#endif\n\n  for (n = 0; n < num_lines; n++)\n    _jpeg_read_scanlines(cinfo, scanlines, 1);\n\n  if (color_convert)\n    cinfo->cconvert->_color_convert = color_convert;\n\n  if (color_quantize)\n    cinfo->cquantize->_color_quantize = color_quantize;\n}\n\n\n/*\n * Called by _jpeg_skip_scanlines().  This partially skips a decompress block\n * by incrementing the rowgroup counter.\n */\n\nLOCAL(void)\nincrement_simple_rowgroup_ctr(j_decompress_ptr cinfo, JDIMENSION rows)\n{\n  JDIMENSION rows_left;\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n\n  if (master->using_merged_upsample && cinfo->max_v_samp_factor == 2) {\n    read_and_discard_scanlines(cinfo, rows);\n    return;\n  }\n\n  /* Increment the counter to the next row group after the skipped rows. */\n  main_ptr->rowgroup_ctr += rows / cinfo->max_v_samp_factor;\n\n  /* Partially skipping a row group would involve modifying the internal state\n   * of the upsampler, so read the remaining rows into a dummy buffer instead.\n   */\n  rows_left = rows % cinfo->max_v_samp_factor;\n  cinfo->output_scanline += rows - rows_left;\n\n  read_and_discard_scanlines(cinfo, rows_left);\n}\n\n/*\n * Skips some scanlines of data from the JPEG decompressor.\n *\n * The return value will be the number of lines actually skipped.  If skipping\n * num_lines would move beyond the end of the image, then the actual number of\n * lines remaining in the image is returned.  Otherwise, the return value will\n * be equal to num_lines.\n *\n * Refer to libjpeg.txt for more information.\n */\n\nGLOBAL(JDIMENSION)\n_jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JDIMENSION i, x;\n  int y;\n  JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;\n  JDIMENSION lines_to_skip, lines_to_read;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  if (cinfo->master->lossless)\n    ERREXIT(cinfo, JERR_NOTIMPL);\n\n  /* Two-pass color quantization is not supported. */\n  if (cinfo->quantize_colors && cinfo->two_pass_quantize)\n    ERREXIT(cinfo, JERR_NOTIMPL);\n\n  if (cinfo->global_state != DSTATE_SCANNING)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Do not skip past the bottom of the image. */\n  if ((unsigned long long)cinfo->output_scanline + num_lines >=\n      cinfo->output_height) {\n    num_lines = cinfo->output_height - cinfo->output_scanline;\n    cinfo->output_scanline = cinfo->output_height;\n    (*cinfo->inputctl->finish_input_pass) (cinfo);\n    cinfo->inputctl->eoi_reached = TRUE;\n    return num_lines;\n  }\n\n  if (num_lines == 0)\n    return 0;\n\n  lines_per_iMCU_row = cinfo->_min_DCT_scaled_size * cinfo->max_v_samp_factor;\n  lines_left_in_iMCU_row =\n    (lines_per_iMCU_row - (cinfo->output_scanline % lines_per_iMCU_row)) %\n    lines_per_iMCU_row;\n  lines_after_iMCU_row = num_lines - lines_left_in_iMCU_row;\n\n  /* Skip the lines remaining in the current iMCU row.  When upsampling\n   * requires context rows, we need the previous and next rows in order to read\n   * the current row.  This adds some complexity.\n   */\n  if (cinfo->upsample->need_context_rows) {\n    /* If the skipped lines would not move us past the current iMCU row, we\n     * read the lines and ignore them.  There might be a faster way of doing\n     * this, but we are facing increasing complexity for diminishing returns.\n     * The increasing complexity would be a by-product of meddling with the\n     * state machine used to skip context rows.  Near the end of an iMCU row,\n     * the next iMCU row may have already been entropy-decoded.  In this unique\n     * case, we will read the next iMCU row if we cannot skip past it as well.\n     */\n    if ((num_lines < lines_left_in_iMCU_row + 1) ||\n        (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full &&\n         lines_after_iMCU_row < lines_per_iMCU_row + 1)) {\n      read_and_discard_scanlines(cinfo, num_lines);\n      return num_lines;\n    }\n\n    /* If the next iMCU row has already been entropy-decoded, make sure that\n     * we do not skip too far.\n     */\n    if (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full) {\n      cinfo->output_scanline += lines_left_in_iMCU_row + lines_per_iMCU_row;\n      lines_after_iMCU_row -= lines_per_iMCU_row;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n    }\n\n    /* If we have just completed the first block, adjust the buffer pointers */\n    if (main_ptr->iMCU_row_ctr == 0 ||\n        (main_ptr->iMCU_row_ctr == 1 && lines_left_in_iMCU_row > 2))\n      set_wraparound_pointers(cinfo);\n    main_ptr->buffer_full = FALSE;\n    main_ptr->rowgroup_ctr = 0;\n    main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n    if (!master->using_merged_upsample) {\n      upsample->next_row_out = cinfo->max_v_samp_factor;\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    }\n  }\n\n  /* Skipping is much simpler when context rows are not required. */\n  else {\n    if (num_lines < lines_left_in_iMCU_row) {\n      increment_simple_rowgroup_ctr(cinfo, num_lines);\n      return num_lines;\n    } else {\n      cinfo->output_scanline += lines_left_in_iMCU_row;\n      main_ptr->buffer_full = FALSE;\n      main_ptr->rowgroup_ctr = 0;\n      if (!master->using_merged_upsample) {\n        upsample->next_row_out = cinfo->max_v_samp_factor;\n        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n      }\n    }\n  }\n\n  /* Calculate how many full iMCU rows we can skip. */\n  if (cinfo->upsample->need_context_rows)\n    lines_to_skip = ((lines_after_iMCU_row - 1) / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  else\n    lines_to_skip = (lines_after_iMCU_row / lines_per_iMCU_row) *\n                    lines_per_iMCU_row;\n  /* Calculate the number of lines that remain to be skipped after skipping all\n   * of the full iMCU rows that we can.  We will not read these lines unless we\n   * have to.\n   */\n  lines_to_read = lines_after_iMCU_row - lines_to_skip;\n\n  /* For images requiring multiple scans (progressive, non-interleaved, etc.),\n   * all of the entropy decoding occurs in jpeg_start_decompress(), assuming\n   * that the input data source is non-suspending.  This makes skipping easy.\n   */\n  if (cinfo->inputctl->has_multiple_scans || cinfo->buffered_image) {\n    if (cinfo->upsample->need_context_rows) {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n      /* It is complex to properly move to the middle of a context block, so\n       * read the remaining lines instead of skipping them.\n       */\n      read_and_discard_scanlines(cinfo, lines_to_read);\n    } else {\n      cinfo->output_scanline += lines_to_skip;\n      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;\n      increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n    }\n    if (!master->using_merged_upsample)\n      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n    return num_lines;\n  }\n\n  /* Skip the iMCU rows that we can safely skip. */\n  for (i = 0; i < lines_to_skip; i += lines_per_iMCU_row) {\n    for (y = 0; y < coef->MCU_rows_per_iMCU_row; y++) {\n      for (x = 0; x < cinfo->MCUs_per_row; x++) {\n        /* Calling decode_mcu() with a NULL pointer causes it to discard the\n         * decoded coefficients.  This is ~5% faster for large subsets, but\n         * it's tough to tell a difference for smaller images.\n         */\n        if (!cinfo->entropy->insufficient_data)\n          cinfo->master->last_good_iMCU_row = cinfo->input_iMCU_row;\n        (*cinfo->entropy->decode_mcu) (cinfo, NULL);\n      }\n    }\n    cinfo->input_iMCU_row++;\n    cinfo->output_iMCU_row++;\n    if (cinfo->input_iMCU_row < cinfo->total_iMCU_rows)\n      start_iMCU_row(cinfo);\n    else\n      (*cinfo->inputctl->finish_input_pass) (cinfo);\n  }\n  cinfo->output_scanline += lines_to_skip;\n\n  if (cinfo->upsample->need_context_rows) {\n    /* Context-based upsampling keeps track of iMCU rows. */\n    main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;\n\n    /* It is complex to properly move to the middle of a context block, so\n     * read the remaining lines instead of skipping them.\n     */\n    read_and_discard_scanlines(cinfo, lines_to_read);\n  } else {\n    increment_simple_rowgroup_ctr(cinfo, lines_to_read);\n  }\n\n  /* Since skipping lines involves skipping the upsampling step, the value of\n   * \"rows_to_go\" will become invalid unless we set it here.  NOTE: This is a\n   * bit odd, since \"rows_to_go\" seems to be redundantly keeping track of\n   * output_scanline.\n   */\n  if (!master->using_merged_upsample)\n    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;\n\n  /* Always skip the requested number of lines. */\n  return num_lines;\n}\n\n/*\n * Alternate entry point to read raw data.\n * Processes exactly one iMCU row per call, unless suspended.\n */\n\nGLOBAL(JDIMENSION)\n_jpeg_read_raw_data(j_decompress_ptr cinfo, _JSAMPIMAGE data,\n                    JDIMENSION max_lines)\n{\n  JDIMENSION lines_per_iMCU_row;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  if (cinfo->master->lossless)\n    ERREXIT(cinfo, JERR_NOTIMPL);\n\n  if (cinfo->global_state != DSTATE_RAW_OK)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  if (cinfo->output_scanline >= cinfo->output_height) {\n    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);\n    return 0;\n  }\n\n  /* Call progress monitor hook if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->pass_counter = (long)cinfo->output_scanline;\n    cinfo->progress->pass_limit = (long)cinfo->output_height;\n    (*cinfo->progress->progress_monitor) ((j_common_ptr)cinfo);\n  }\n\n  /* Verify that at least one iMCU row can be returned. */\n  lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->_min_DCT_scaled_size;\n  if (max_lines < lines_per_iMCU_row)\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n\n  /* Decompress directly into user's buffer. */\n  if (cinfo->coef->_decompress_data == NULL)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n  if (!(*cinfo->coef->_decompress_data) (cinfo, data))\n    return 0;                   /* suspension forced, can do nothing more */\n\n  /* OK, we processed one iMCU row. */\n  cinfo->output_scanline += lines_per_iMCU_row;\n  return lines_per_iMCU_row;\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 */\n\n\n#if BITS_IN_JSAMPLE == 8\n\n/* Additional entry points for buffered-image mode. */\n\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n\n/*\n * Initialize for an output pass in buffered-image mode.\n */\n\nGLOBAL(boolean)\njpeg_start_output(j_decompress_ptr cinfo, int scan_number)\n{\n  if (cinfo->global_state != DSTATE_BUFIMAGE &&\n      cinfo->global_state != DSTATE_PRESCAN)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  /* Limit scan number to valid range */\n  if (scan_number <= 0)\n    scan_number = 1;\n  if (cinfo->inputctl->eoi_reached && scan_number > cinfo->input_scan_number)\n    scan_number = cinfo->input_scan_number;\n  cinfo->output_scan_number = scan_number;\n  /* Perform any dummy output passes, and set up for the real pass */\n  return output_pass_setup(cinfo);\n}\n\n\n/*\n * Finish up after an output pass in buffered-image mode.\n *\n * Returns FALSE if suspended.  The return value need be inspected only if\n * a suspending data source is used.\n */\n\nGLOBAL(boolean)\njpeg_finish_output(j_decompress_ptr cinfo)\n{\n  if ((cinfo->global_state == DSTATE_SCANNING ||\n       cinfo->global_state == DSTATE_RAW_OK) && cinfo->buffered_image) {\n    /* Terminate this pass. */\n    /* We do not require the whole pass to have been completed. */\n    (*cinfo->master->finish_output_pass) (cinfo);\n    cinfo->global_state = DSTATE_BUFPOST;\n  } else if (cinfo->global_state != DSTATE_BUFPOST) {\n    /* BUFPOST = repeat call after a suspension, anything else is error */\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  }\n  /* Read markers looking for SOS or EOI */\n  while (cinfo->input_scan_number <= cinfo->output_scan_number &&\n         !cinfo->inputctl->eoi_reached) {\n    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)\n      return FALSE;             /* Suspend, come back later */\n  }\n  cinfo->global_state = DSTATE_BUFIMAGE;\n  return TRUE;\n}\n\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\n\n#endif /* BITS_IN_JSAMPLE == 8 */\n"
        },
        {
          "name": "jdarith.c",
          "type": "blob",
          "size": 24.9404296875,
          "content": "/*\n * jdarith.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Developed 1997-2015 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015-2020, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains portable arithmetic entropy encoding routines for JPEG\n * (implementing Recommendation ITU-T T.81 | ISO/IEC 10918-1).\n *\n * Both sequential and progressive modes are supported in this single module.\n *\n * Suspension is not currently supported in this module.\n *\n * NOTE: All referenced figures are from\n * Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n\n\n#define NEG_1  ((unsigned int)-1)\n\n\n/* Expanded entropy decoder object for arithmetic decoding. */\n\ntypedef struct {\n  struct jpeg_entropy_decoder pub; /* public fields */\n\n  JLONG c;       /* C register, base of coding interval + input bit buffer */\n  JLONG a;               /* A register, normalized size of coding interval */\n  int ct;     /* bit shift counter, # of bits left in bit buffer part of C */\n                                                         /* init: ct = -16 */\n                                                         /* run: ct = 0..7 */\n                                                         /* error: ct = -1 */\n  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */\n  int dc_context[MAX_COMPS_IN_SCAN]; /* context index for DC conditioning */\n\n  unsigned int restarts_to_go;  /* MCUs left in this restart interval */\n\n  /* Pointers to statistics areas (these workspaces have image lifespan) */\n  unsigned char *dc_stats[NUM_ARITH_TBLS];\n  unsigned char *ac_stats[NUM_ARITH_TBLS];\n\n  /* Statistics bin for coding with fixed probability 0.5 */\n  unsigned char fixed_bin[4];\n} arith_entropy_decoder;\n\ntypedef arith_entropy_decoder *arith_entropy_ptr;\n\n/* The following two definitions specify the allocation chunk size\n * for the statistics area.\n * According to sections F.1.4.4.1.3 and F.1.4.4.2, we need at least\n * 49 statistics bins for DC, and 245 statistics bins for AC coding.\n *\n * We use a compact representation with 1 byte per statistics bin,\n * thus the numbers directly represent byte sizes.\n * This 1 byte per statistics bin contains the meaning of the MPS\n * (more probable symbol) in the highest bit (mask 0x80), and the\n * index into the probability estimation state machine table\n * in the lower bits (mask 0x7F).\n */\n\n#define DC_STAT_BINS  64\n#define AC_STAT_BINS  256\n\n\nLOCAL(int)\nget_byte(j_decompress_ptr cinfo)\n/* Read next input byte; we do not support suspension in this module. */\n{\n  struct jpeg_source_mgr *src = cinfo->src;\n\n  if (src->bytes_in_buffer == 0)\n    if (!(*src->fill_input_buffer) (cinfo))\n      ERREXIT(cinfo, JERR_CANT_SUSPEND);\n  src->bytes_in_buffer--;\n  return *src->next_input_byte++;\n}\n\n\n/*\n * The core arithmetic decoding routine (common in JPEG and JBIG).\n * This needs to go as fast as possible.\n * Machine-dependent optimization facilities\n * are not utilized in this portable implementation.\n * However, this code should be fairly efficient and\n * may be a good base for further optimizations anyway.\n *\n * Return value is 0 or 1 (binary decision).\n *\n * Note: I've changed the handling of the code base & bit\n * buffer register C compared to other implementations\n * based on the standards layout & procedures.\n * While it also contains both the actual base of the\n * coding interval (16 bits) and the next-bits buffer,\n * the cut-point between these two parts is floating\n * (instead of fixed) with the bit shift counter CT.\n * Thus, we also need only one (variable instead of\n * fixed size) shift for the LPS/MPS decision, and\n * we can do away with any renormalization update\n * of C (except for new data insertion, of course).\n *\n * I've also introduced a new scheme for accessing\n * the probability estimation state machine table,\n * derived from Markus Kuhn's JBIG implementation.\n */\n\nLOCAL(int)\narith_decode(j_decompress_ptr cinfo, unsigned char *st)\n{\n  register arith_entropy_ptr e = (arith_entropy_ptr)cinfo->entropy;\n  register unsigned char nl, nm;\n  register JLONG qe, temp;\n  register int sv, data;\n\n  /* Renormalization & data input per section D.2.6 */\n  while (e->a < 0x8000L) {\n    if (--e->ct < 0) {\n      /* Need to fetch next data byte */\n      if (cinfo->unread_marker)\n        data = 0;               /* stuff zero data */\n      else {\n        data = get_byte(cinfo); /* read next input byte */\n        if (data == 0xFF) {     /* zero stuff or marker code */\n          do data = get_byte(cinfo);\n          while (data == 0xFF); /* swallow extra 0xFF bytes */\n          if (data == 0)\n            data = 0xFF;        /* discard stuffed zero byte */\n          else {\n            /* Note: Different from the Huffman decoder, hitting\n             * a marker while processing the compressed data\n             * segment is legal in arithmetic coding.\n             * The convention is to supply zero data\n             * then until decoding is complete.\n             */\n            cinfo->unread_marker = data;\n            data = 0;\n          }\n        }\n      }\n      e->c = (e->c << 8) | data; /* insert data into C register */\n      if ((e->ct += 8) < 0)      /* update bit shift counter */\n        /* Need more initial bytes */\n        if (++e->ct == 0)\n          /* Got 2 initial bytes -> re-init A and exit loop */\n          e->a = 0x8000L; /* => e->a = 0x10000L after loop exit */\n    }\n    e->a <<= 1;\n  }\n\n  /* Fetch values from our compact representation of Table D.2:\n   * Qe values and probability estimation state machine\n   */\n  sv = *st;\n  qe = jpeg_aritab[sv & 0x7F];  /* => Qe_Value */\n  nl = qe & 0xFF;  qe >>= 8;    /* Next_Index_LPS + Switch_MPS */\n  nm = qe & 0xFF;  qe >>= 8;    /* Next_Index_MPS */\n\n  /* Decode & estimation procedures per sections D.2.4 & D.2.5 */\n  temp = e->a - qe;\n  e->a = temp;\n  temp <<= e->ct;\n  if (e->c >= temp) {\n    e->c -= temp;\n    /* Conditional LPS (less probable symbol) exchange */\n    if (e->a < qe) {\n      e->a = qe;\n      *st = (sv & 0x80) ^ nm;   /* Estimate_after_MPS */\n    } else {\n      e->a = qe;\n      *st = (sv & 0x80) ^ nl;   /* Estimate_after_LPS */\n      sv ^= 0x80;               /* Exchange LPS/MPS */\n    }\n  } else if (e->a < 0x8000L) {\n    /* Conditional MPS (more probable symbol) exchange */\n    if (e->a < qe) {\n      *st = (sv & 0x80) ^ nl;   /* Estimate_after_LPS */\n      sv ^= 0x80;               /* Exchange LPS/MPS */\n    } else {\n      *st = (sv & 0x80) ^ nm;   /* Estimate_after_MPS */\n    }\n  }\n\n  return sv >> 7;\n}\n\n\n/*\n * Check for a restart marker & resynchronize decoder.\n */\n\nLOCAL(void)\nprocess_restart(j_decompress_ptr cinfo)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  int ci;\n  jpeg_component_info *compptr;\n\n  /* Advance past the RSTn marker */\n  if (!(*cinfo->marker->read_restart_marker) (cinfo))\n    ERREXIT(cinfo, JERR_CANT_SUSPEND);\n\n  /* Re-initialize statistics areas */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    if (!cinfo->progressive_mode || (cinfo->Ss == 0 && cinfo->Ah == 0)) {\n      memset(entropy->dc_stats[compptr->dc_tbl_no], 0, DC_STAT_BINS);\n      /* Reset DC predictions to 0 */\n      entropy->last_dc_val[ci] = 0;\n      entropy->dc_context[ci] = 0;\n    }\n    if (!cinfo->progressive_mode || cinfo->Ss) {\n      memset(entropy->ac_stats[compptr->ac_tbl_no], 0, AC_STAT_BINS);\n    }\n  }\n\n  /* Reset arithmetic decoding variables */\n  entropy->c = 0;\n  entropy->a = 0;\n  entropy->ct = -16;    /* force reading 2 initial bytes to fill C */\n\n  /* Reset restart counter */\n  entropy->restarts_to_go = cinfo->restart_interval;\n}\n\n\n/*\n * Arithmetic MCU decoding.\n * Each of these routines decodes and returns one MCU's worth of\n * arithmetic-compressed coefficients.\n * The coefficients are reordered from zigzag order into natural array order,\n * but are not dequantized.\n *\n * The i'th block of the MCU is stored into the block pointed to by\n * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.\n */\n\n/*\n * MCU decoding for DC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n\nMETHODDEF(boolean)\ndecode_mcu_DC_first(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  JBLOCKROW block;\n  unsigned char *st;\n  int blkn, ci, tbl, sign;\n  int v, m;\n\n  /* Process restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      process_restart(cinfo);\n    entropy->restarts_to_go--;\n  }\n\n  if (entropy->ct == -1) return TRUE;   /* if error do nothing */\n\n  /* Outer loop handles each block in the MCU */\n\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    block = MCU_data[blkn];\n    ci = cinfo->MCU_membership[blkn];\n    tbl = cinfo->cur_comp_info[ci]->dc_tbl_no;\n\n    /* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */\n\n    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */\n    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];\n\n    /* Figure F.19: Decode_DC_DIFF */\n    if (arith_decode(cinfo, st) == 0)\n      entropy->dc_context[ci] = 0;\n    else {\n      /* Figure F.21: Decoding nonzero value v */\n      /* Figure F.22: Decoding the sign of v */\n      sign = arith_decode(cinfo, st + 1);\n      st += 2;  st += sign;\n      /* Figure F.23: Decoding the magnitude category of v */\n      if ((m = arith_decode(cinfo, st)) != 0) {\n        st = entropy->dc_stats[tbl] + 20;       /* Table F.4: X1 = 20 */\n        while (arith_decode(cinfo, st)) {\n          if ((m <<= 1) == 0x8000) {\n            WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\n            entropy->ct = -1;                   /* magnitude overflow */\n            return TRUE;\n          }\n          st += 1;\n        }\n      }\n      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */\n      if (m < (int)((1L << cinfo->arith_dc_L[tbl]) >> 1))\n        entropy->dc_context[ci] = 0;               /* zero diff category */\n      else if (m > (int)((1L << cinfo->arith_dc_U[tbl]) >> 1))\n        entropy->dc_context[ci] = 12 + (sign * 4); /* large diff category */\n      else\n        entropy->dc_context[ci] = 4 + (sign * 4);  /* small diff category */\n      v = m;\n      /* Figure F.24: Decoding the magnitude bit pattern of v */\n      st += 14;\n      while (m >>= 1)\n        if (arith_decode(cinfo, st)) v |= m;\n      v += 1;  if (sign) v = -v;\n      entropy->last_dc_val[ci] = (entropy->last_dc_val[ci] + v) & 0xffff;\n    }\n\n    /* Scale and output the DC coefficient (assumes jpeg_natural_order[0]=0) */\n    (*block)[0] = (JCOEF)LEFT_SHIFT(entropy->last_dc_val[ci], cinfo->Al);\n  }\n\n  return TRUE;\n}\n\n\n/*\n * MCU decoding for AC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n\nMETHODDEF(boolean)\ndecode_mcu_AC_first(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  JBLOCKROW block;\n  unsigned char *st;\n  int tbl, sign, k;\n  int v, m;\n\n  /* Process restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      process_restart(cinfo);\n    entropy->restarts_to_go--;\n  }\n\n  if (entropy->ct == -1) return TRUE;   /* if error do nothing */\n\n  /* There is always only one block per MCU */\n  block = MCU_data[0];\n  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;\n\n  /* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */\n\n  /* Figure F.20: Decode_AC_coefficients */\n  for (k = cinfo->Ss; k <= cinfo->Se; k++) {\n    st = entropy->ac_stats[tbl] + 3 * (k - 1);\n    if (arith_decode(cinfo, st)) break;         /* EOB flag */\n    while (arith_decode(cinfo, st + 1) == 0) {\n      st += 3;  k++;\n      if (k > cinfo->Se) {\n        WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\n        entropy->ct = -1;                       /* spectral overflow */\n        return TRUE;\n      }\n    }\n    /* Figure F.21: Decoding nonzero value v */\n    /* Figure F.22: Decoding the sign of v */\n    sign = arith_decode(cinfo, entropy->fixed_bin);\n    st += 2;\n    /* Figure F.23: Decoding the magnitude category of v */\n    if ((m = arith_decode(cinfo, st)) != 0) {\n      if (arith_decode(cinfo, st)) {\n        m <<= 1;\n        st = entropy->ac_stats[tbl] +\n             (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);\n        while (arith_decode(cinfo, st)) {\n          if ((m <<= 1) == 0x8000) {\n            WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\n            entropy->ct = -1;                   /* magnitude overflow */\n            return TRUE;\n          }\n          st += 1;\n        }\n      }\n    }\n    v = m;\n    /* Figure F.24: Decoding the magnitude bit pattern of v */\n    st += 14;\n    while (m >>= 1)\n      if (arith_decode(cinfo, st)) v |= m;\n    v += 1;  if (sign) v = -v;\n    /* Scale and output coefficient in natural (dezigzagged) order */\n    (*block)[jpeg_natural_order[k]] = (JCOEF)((unsigned)v << cinfo->Al);\n  }\n\n  return TRUE;\n}\n\n\n/*\n * MCU decoding for DC successive approximation refinement scan.\n */\n\nMETHODDEF(boolean)\ndecode_mcu_DC_refine(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  unsigned char *st;\n  int p1, blkn;\n\n  /* Process restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      process_restart(cinfo);\n    entropy->restarts_to_go--;\n  }\n\n  st = entropy->fixed_bin;      /* use fixed probability estimation */\n  p1 = 1 << cinfo->Al;          /* 1 in the bit position being coded */\n\n  /* Outer loop handles each block in the MCU */\n\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    /* Encoded data is simply the next bit of the two's-complement DC value */\n    if (arith_decode(cinfo, st))\n      MCU_data[blkn][0][0] |= p1;\n  }\n\n  return TRUE;\n}\n\n\n/*\n * MCU decoding for AC successive approximation refinement scan.\n */\n\nMETHODDEF(boolean)\ndecode_mcu_AC_refine(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  JBLOCKROW block;\n  JCOEFPTR thiscoef;\n  unsigned char *st;\n  int tbl, k, kex;\n  int p1, m1;\n\n  /* Process restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      process_restart(cinfo);\n    entropy->restarts_to_go--;\n  }\n\n  if (entropy->ct == -1) return TRUE;   /* if error do nothing */\n\n  /* There is always only one block per MCU */\n  block = MCU_data[0];\n  tbl = cinfo->cur_comp_info[0]->ac_tbl_no;\n\n  p1 = 1 << cinfo->Al;          /* 1 in the bit position being coded */\n  m1 = (NEG_1) << cinfo->Al;    /* -1 in the bit position being coded */\n\n  /* Establish EOBx (previous stage end-of-block) index */\n  for (kex = cinfo->Se; kex > 0; kex--)\n    if ((*block)[jpeg_natural_order[kex]]) break;\n\n  for (k = cinfo->Ss; k <= cinfo->Se; k++) {\n    st = entropy->ac_stats[tbl] + 3 * (k - 1);\n    if (k > kex)\n      if (arith_decode(cinfo, st)) break;       /* EOB flag */\n    for (;;) {\n      thiscoef = *block + jpeg_natural_order[k];\n      if (*thiscoef) {                          /* previously nonzero coef */\n        if (arith_decode(cinfo, st + 2)) {\n          if (*thiscoef < 0)\n            *thiscoef += (JCOEF)m1;\n          else\n            *thiscoef += (JCOEF)p1;\n        }\n        break;\n      }\n      if (arith_decode(cinfo, st + 1)) {        /* newly nonzero coef */\n        if (arith_decode(cinfo, entropy->fixed_bin))\n          *thiscoef = (JCOEF)m1;\n        else\n          *thiscoef = (JCOEF)p1;\n        break;\n      }\n      st += 3;  k++;\n      if (k > cinfo->Se) {\n        WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\n        entropy->ct = -1;                       /* spectral overflow */\n        return TRUE;\n      }\n    }\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Decode one MCU's worth of arithmetic-compressed coefficients.\n */\n\nMETHODDEF(boolean)\ndecode_mcu(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  jpeg_component_info *compptr;\n  JBLOCKROW block;\n  unsigned char *st;\n  int blkn, ci, tbl, sign, k;\n  int v, m;\n\n  /* Process restart marker if needed */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      process_restart(cinfo);\n    entropy->restarts_to_go--;\n  }\n\n  if (entropy->ct == -1) return TRUE;   /* if error do nothing */\n\n  /* Outer loop handles each block in the MCU */\n\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    block = MCU_data ? MCU_data[blkn] : NULL;\n    ci = cinfo->MCU_membership[blkn];\n    compptr = cinfo->cur_comp_info[ci];\n\n    /* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */\n\n    tbl = compptr->dc_tbl_no;\n\n    /* Table F.4: Point to statistics bin S0 for DC coefficient coding */\n    st = entropy->dc_stats[tbl] + entropy->dc_context[ci];\n\n    /* Figure F.19: Decode_DC_DIFF */\n    if (arith_decode(cinfo, st) == 0)\n      entropy->dc_context[ci] = 0;\n    else {\n      /* Figure F.21: Decoding nonzero value v */\n      /* Figure F.22: Decoding the sign of v */\n      sign = arith_decode(cinfo, st + 1);\n      st += 2;  st += sign;\n      /* Figure F.23: Decoding the magnitude category of v */\n      if ((m = arith_decode(cinfo, st)) != 0) {\n        st = entropy->dc_stats[tbl] + 20;       /* Table F.4: X1 = 20 */\n        while (arith_decode(cinfo, st)) {\n          if ((m <<= 1) == 0x8000) {\n            WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\n            entropy->ct = -1;                   /* magnitude overflow */\n            return TRUE;\n          }\n          st += 1;\n        }\n      }\n      /* Section F.1.4.4.1.2: Establish dc_context conditioning category */\n      if (m < (int)((1L << cinfo->arith_dc_L[tbl]) >> 1))\n        entropy->dc_context[ci] = 0;               /* zero diff category */\n      else if (m > (int)((1L << cinfo->arith_dc_U[tbl]) >> 1))\n        entropy->dc_context[ci] = 12 + (sign * 4); /* large diff category */\n      else\n        entropy->dc_context[ci] = 4 + (sign * 4);  /* small diff category */\n      v = m;\n      /* Figure F.24: Decoding the magnitude bit pattern of v */\n      st += 14;\n      while (m >>= 1)\n        if (arith_decode(cinfo, st)) v |= m;\n      v += 1;  if (sign) v = -v;\n      entropy->last_dc_val[ci] = (entropy->last_dc_val[ci] + v) & 0xffff;\n    }\n\n    if (block)\n      (*block)[0] = (JCOEF)entropy->last_dc_val[ci];\n\n    /* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */\n\n    tbl = compptr->ac_tbl_no;\n\n    /* Figure F.20: Decode_AC_coefficients */\n    for (k = 1; k <= DCTSIZE2 - 1; k++) {\n      st = entropy->ac_stats[tbl] + 3 * (k - 1);\n      if (arith_decode(cinfo, st)) break;       /* EOB flag */\n      while (arith_decode(cinfo, st + 1) == 0) {\n        st += 3;  k++;\n        if (k > DCTSIZE2 - 1) {\n          WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\n          entropy->ct = -1;                     /* spectral overflow */\n          return TRUE;\n        }\n      }\n      /* Figure F.21: Decoding nonzero value v */\n      /* Figure F.22: Decoding the sign of v */\n      sign = arith_decode(cinfo, entropy->fixed_bin);\n      st += 2;\n      /* Figure F.23: Decoding the magnitude category of v */\n      if ((m = arith_decode(cinfo, st)) != 0) {\n        if (arith_decode(cinfo, st)) {\n          m <<= 1;\n          st = entropy->ac_stats[tbl] +\n               (k <= cinfo->arith_ac_K[tbl] ? 189 : 217);\n          while (arith_decode(cinfo, st)) {\n            if ((m <<= 1) == 0x8000) {\n              WARNMS(cinfo, JWRN_ARITH_BAD_CODE);\n              entropy->ct = -1;                 /* magnitude overflow */\n              return TRUE;\n            }\n            st += 1;\n          }\n        }\n      }\n      v = m;\n      /* Figure F.24: Decoding the magnitude bit pattern of v */\n      st += 14;\n      while (m >>= 1)\n        if (arith_decode(cinfo, st)) v |= m;\n      v += 1;  if (sign) v = -v;\n      if (block)\n        (*block)[jpeg_natural_order[k]] = (JCOEF)v;\n    }\n  }\n\n  return TRUE;\n}\n\n\n/*\n * Initialize for an arithmetic-compressed scan.\n */\n\nMETHODDEF(void)\nstart_pass(j_decompress_ptr cinfo)\n{\n  arith_entropy_ptr entropy = (arith_entropy_ptr)cinfo->entropy;\n  int ci, tbl;\n  jpeg_component_info *compptr;\n\n  if (cinfo->progressive_mode) {\n    /* Validate progressive scan parameters */\n    if (cinfo->Ss == 0) {\n      if (cinfo->Se != 0)\n        goto bad;\n    } else {\n      /* need not check Ss/Se < 0 since they came from unsigned bytes */\n      if (cinfo->Se < cinfo->Ss || cinfo->Se > DCTSIZE2 - 1)\n        goto bad;\n      /* AC scans may have only one component */\n      if (cinfo->comps_in_scan != 1)\n        goto bad;\n    }\n    if (cinfo->Ah != 0) {\n      /* Successive approximation refinement scan: must have Al = Ah-1. */\n      if (cinfo->Ah - 1 != cinfo->Al)\n        goto bad;\n    }\n    if (cinfo->Al > 13) {       /* need not check for < 0 */\nbad:\n      ERREXIT4(cinfo, JERR_BAD_PROGRESSION,\n               cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);\n    }\n    /* Update progression status, and verify that scan order is legal.\n     * Note that inter-scan inconsistencies are treated as warnings\n     * not fatal errors ... not clear if this is right way to behave.\n     */\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n      int coefi, cindex = cinfo->cur_comp_info[ci]->component_index;\n      int *coef_bit_ptr = &cinfo->coef_bits[cindex][0];\n      int *prev_coef_bit_ptr =\n        &cinfo->coef_bits[cindex + cinfo->num_components][0];\n      if (cinfo->Ss && coef_bit_ptr[0] < 0) /* AC without prior DC scan */\n        WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);\n      for (coefi = MIN(cinfo->Ss, 1); coefi <= MAX(cinfo->Se, 9); coefi++) {\n        if (cinfo->input_scan_number > 1)\n          prev_coef_bit_ptr[coefi] = coef_bit_ptr[coefi];\n        else\n          prev_coef_bit_ptr[coefi] = 0;\n      }\n      for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {\n        int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];\n        if (cinfo->Ah != expected)\n          WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);\n        coef_bit_ptr[coefi] = cinfo->Al;\n      }\n    }\n    /* Select MCU decoding routine */\n    if (cinfo->Ah == 0) {\n      if (cinfo->Ss == 0)\n        entropy->pub.decode_mcu = decode_mcu_DC_first;\n      else\n        entropy->pub.decode_mcu = decode_mcu_AC_first;\n    } else {\n      if (cinfo->Ss == 0)\n        entropy->pub.decode_mcu = decode_mcu_DC_refine;\n      else\n        entropy->pub.decode_mcu = decode_mcu_AC_refine;\n    }\n  } else {\n    /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.\n     * This ought to be an error condition, but we make it a warning.\n     */\n    if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2 - 1 ||\n        cinfo->Ah != 0 || cinfo->Al != 0)\n      WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);\n    /* Select MCU decoding routine */\n    entropy->pub.decode_mcu = decode_mcu;\n  }\n\n  /* Allocate & initialize requested statistics areas */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    if (!cinfo->progressive_mode || (cinfo->Ss == 0 && cinfo->Ah == 0)) {\n      tbl = compptr->dc_tbl_no;\n      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)\n        ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);\n      if (entropy->dc_stats[tbl] == NULL)\n        entropy->dc_stats[tbl] = (unsigned char *)(*cinfo->mem->alloc_small)\n          ((j_common_ptr)cinfo, JPOOL_IMAGE, DC_STAT_BINS);\n      memset(entropy->dc_stats[tbl], 0, DC_STAT_BINS);\n      /* Initialize DC predictions to 0 */\n      entropy->last_dc_val[ci] = 0;\n      entropy->dc_context[ci] = 0;\n    }\n    if (!cinfo->progressive_mode || cinfo->Ss) {\n      tbl = compptr->ac_tbl_no;\n      if (tbl < 0 || tbl >= NUM_ARITH_TBLS)\n        ERREXIT1(cinfo, JERR_NO_ARITH_TABLE, tbl);\n      if (entropy->ac_stats[tbl] == NULL)\n        entropy->ac_stats[tbl] = (unsigned char *)(*cinfo->mem->alloc_small)\n          ((j_common_ptr)cinfo, JPOOL_IMAGE, AC_STAT_BINS);\n      memset(entropy->ac_stats[tbl], 0, AC_STAT_BINS);\n    }\n  }\n\n  /* Initialize arithmetic decoding variables */\n  entropy->c = 0;\n  entropy->a = 0;\n  entropy->ct = -16;    /* force reading 2 initial bytes to fill C */\n  entropy->pub.insufficient_data = FALSE;\n\n  /* Initialize restart counter */\n  entropy->restarts_to_go = cinfo->restart_interval;\n}\n\n\n/*\n * Module initialization routine for arithmetic entropy decoding.\n */\n\nGLOBAL(void)\njinit_arith_decoder(j_decompress_ptr cinfo)\n{\n  arith_entropy_ptr entropy;\n  int i;\n\n  entropy = (arith_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(arith_entropy_decoder));\n  cinfo->entropy = (struct jpeg_entropy_decoder *)entropy;\n  entropy->pub.start_pass = start_pass;\n\n  /* Mark tables unallocated */\n  for (i = 0; i < NUM_ARITH_TBLS; i++) {\n    entropy->dc_stats[i] = NULL;\n    entropy->ac_stats[i] = NULL;\n  }\n\n  /* Initialize index for fixed probability estimation */\n  entropy->fixed_bin[0] = 113;\n\n  if (cinfo->progressive_mode) {\n    /* Create progression status table */\n    int *coef_bit_ptr, ci;\n    cinfo->coef_bits = (int (*)[DCTSIZE2])\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  cinfo->num_components * 2 * DCTSIZE2 *\n                                  sizeof(int));\n    coef_bit_ptr = &cinfo->coef_bits[0][0];\n    for (ci = 0; ci < cinfo->num_components; ci++)\n      for (i = 0; i < DCTSIZE2; i++)\n        *coef_bit_ptr++ = -1;\n  }\n}\n"
        },
        {
          "name": "jdatadst-tj.c",
          "type": "blob",
          "size": 6.5166015625,
          "content": "/*\n * jdatadst-tj.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * Modified 2009-2012 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2011, 2014, 2016, 2019, 2022-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains compression data destination routines for the case of\n * emitting JPEG data to memory or to a file (or any stdio stream).\n * While these routines are sufficient for most applications,\n * some will want to use a different destination manager.\n * IMPORTANT: we assume that fwrite() will correctly transcribe an array of\n * JOCTETs into 8-bit-wide elements on external storage.  If char is wider\n * than 8 bits on your machine, you may need to do some tweaking.\n */\n\n/* this is not a core library module, so it doesn't define JPEG_INTERNALS */\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n\nvoid jpeg_mem_dest_tj(j_compress_ptr cinfo, unsigned char **outbuffer,\n                      size_t *outsize, boolean alloc);\n\n\n#define OUTPUT_BUF_SIZE  4096   /* choose an efficiently fwrite'able size */\n\n\n/* Expanded data destination object for memory output */\n\ntypedef struct {\n  struct jpeg_destination_mgr pub; /* public fields */\n\n  unsigned char **outbuffer;    /* target buffer */\n  size_t *outsize;\n  unsigned char *newbuffer;     /* newly allocated buffer */\n  JOCTET *buffer;               /* start of buffer */\n  size_t bufsize;\n  boolean alloc;\n} my_mem_destination_mgr;\n\ntypedef my_mem_destination_mgr *my_mem_dest_ptr;\n\n\n/*\n * Initialize destination --- called by jpeg_start_compress\n * before any data is actually written.\n */\n\nMETHODDEF(void)\ninit_mem_destination(j_compress_ptr cinfo)\n{\n  /* no work necessary here */\n}\n\n\n/*\n * Empty the output buffer --- called whenever buffer fills up.\n *\n * In typical applications, this should write the entire output buffer\n * (ignoring the current state of next_output_byte & free_in_buffer),\n * reset the pointer & count to the start of the buffer, and return TRUE\n * indicating that the buffer has been dumped.\n *\n * In applications that need to be able to suspend compression due to output\n * overrun, a FALSE return indicates that the buffer cannot be emptied now.\n * In this situation, the compressor will return to its caller (possibly with\n * an indication that it has not accepted all the supplied scanlines).  The\n * application should resume compression after it has made more room in the\n * output buffer.  Note that there are substantial restrictions on the use of\n * suspension --- see the documentation.\n *\n * When suspending, the compressor will back up to a convenient restart point\n * (typically the start of the current MCU). next_output_byte & free_in_buffer\n * indicate where the restart point will be if the current call returns FALSE.\n * Data beyond this point will be regenerated after resumption, so do not\n * write it out when emptying the buffer externally.\n */\n\nMETHODDEF(boolean)\nempty_mem_output_buffer(j_compress_ptr cinfo)\n{\n  size_t nextsize;\n  JOCTET *nextbuffer;\n  my_mem_dest_ptr dest = (my_mem_dest_ptr)cinfo->dest;\n\n  if (!dest->alloc) ERREXIT(cinfo, JERR_BUFFER_SIZE);\n\n  /* Try to allocate new buffer with double size */\n  nextsize = dest->bufsize * 2;\n  nextbuffer = (JOCTET *)MALLOC(nextsize);\n\n  if (nextbuffer == NULL)\n    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 10);\n\n  memcpy(nextbuffer, dest->buffer, dest->bufsize);\n\n  free(dest->newbuffer);\n\n  dest->newbuffer = nextbuffer;\n\n  dest->pub.next_output_byte = nextbuffer + dest->bufsize;\n  dest->pub.free_in_buffer = dest->bufsize;\n\n  dest->buffer = nextbuffer;\n  dest->bufsize = nextsize;\n\n  return TRUE;\n}\n\n\n/*\n * Terminate destination --- called by jpeg_finish_compress\n * after all data has been written.  Usually needs to flush buffer.\n *\n * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding\n * application must deal with any cleanup that should happen even\n * for error exit.\n */\n\nMETHODDEF(void)\nterm_mem_destination(j_compress_ptr cinfo)\n{\n  my_mem_dest_ptr dest = (my_mem_dest_ptr)cinfo->dest;\n\n  if (dest->alloc) *dest->outbuffer = dest->buffer;\n  *dest->outsize = dest->bufsize - dest->pub.free_in_buffer;\n}\n\n\n/*\n * Prepare for output to a memory buffer.\n * The caller may supply an own initial buffer with appropriate size.\n * Otherwise, or when the actual data output exceeds the given size,\n * the library adapts the buffer size as necessary.\n * The standard library functions malloc/free are used for allocating\n * larger memory, so the buffer is available to the application after\n * finishing compression, and then the application is responsible for\n * freeing the requested memory.\n */\n\nGLOBAL(void)\njpeg_mem_dest_tj(j_compress_ptr cinfo, unsigned char **outbuffer,\n                 size_t *outsize, boolean alloc)\n{\n  boolean reused = FALSE;\n  my_mem_dest_ptr dest;\n\n  if (outbuffer == NULL || outsize == NULL)     /* sanity check */\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n\n  /* The destination object is made permanent so that multiple JPEG images\n   * can be written to the same buffer without re-executing jpeg_mem_dest.\n   */\n  if (cinfo->dest == NULL) {    /* first time for this JPEG object? */\n    cinfo->dest = (struct jpeg_destination_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(my_mem_destination_mgr));\n    dest = (my_mem_dest_ptr)cinfo->dest;\n    dest->newbuffer = NULL;\n    dest->buffer = NULL;\n  } else if (cinfo->dest->init_destination != init_mem_destination) {\n    /* It is unsafe to reuse the existing destination manager unless it was\n     * created by this function.\n     */\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  dest = (my_mem_dest_ptr)cinfo->dest;\n  dest->pub.init_destination = init_mem_destination;\n  dest->pub.empty_output_buffer = empty_mem_output_buffer;\n  dest->pub.term_destination = term_mem_destination;\n  if (dest->buffer == *outbuffer && *outbuffer != NULL && alloc)\n    reused = TRUE;\n  dest->outbuffer = outbuffer;\n  dest->outsize = outsize;\n  dest->alloc = alloc;\n\n  if (*outbuffer == NULL || *outsize == 0) {\n    if (alloc) {\n      /* Allocate initial buffer */\n      dest->newbuffer = *outbuffer = (unsigned char *)MALLOC(OUTPUT_BUF_SIZE);\n      if (dest->newbuffer == NULL)\n        ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 10);\n      *outsize = OUTPUT_BUF_SIZE;\n    } else\n      ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  dest->pub.next_output_byte = dest->buffer = *outbuffer;\n  if (!reused)\n    dest->bufsize = *outsize;\n  dest->pub.free_in_buffer = dest->bufsize;\n}\n"
        },
        {
          "name": "jdatadst.c",
          "type": "blob",
          "size": 9.3828125,
          "content": "/*\n * jdatadst.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * Modified 2009-2012 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2013, 2016, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains compression data destination routines for the case of\n * emitting JPEG data to memory or to a file (or any stdio stream).\n * While these routines are sufficient for most applications,\n * some will want to use a different destination manager.\n * IMPORTANT: we assume that fwrite() will correctly transcribe an array of\n * JOCTETs into 8-bit-wide elements on external storage.  If char is wider\n * than 8 bits on your machine, you may need to do some tweaking.\n */\n\n/* this is not a core library module, so it doesn't define JPEG_INTERNALS */\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n#include \"jpegint.h\"\n\n\n/* Expanded data destination object for stdio output */\n\ntypedef struct {\n  struct jpeg_destination_mgr pub; /* public fields */\n\n  FILE *outfile;                /* target stream */\n  JOCTET *buffer;               /* start of buffer */\n} my_destination_mgr;\n\ntypedef my_destination_mgr *my_dest_ptr;\n\n#define OUTPUT_BUF_SIZE  4096   /* choose an efficiently fwrite'able size */\n\n\n/* Expanded data destination object for memory output */\n\ntypedef struct {\n  struct jpeg_destination_mgr pub; /* public fields */\n\n  unsigned char **outbuffer;    /* target buffer */\n  unsigned long *outsize;\n  unsigned char *newbuffer;     /* newly allocated buffer */\n  JOCTET *buffer;               /* start of buffer */\n  size_t bufsize;\n} my_mem_destination_mgr;\n\ntypedef my_mem_destination_mgr *my_mem_dest_ptr;\n\n\n/*\n * Initialize destination --- called by jpeg_start_compress\n * before any data is actually written.\n */\n\nMETHODDEF(void)\ninit_destination(j_compress_ptr cinfo)\n{\n  my_dest_ptr dest = (my_dest_ptr)cinfo->dest;\n\n  /* Allocate the output buffer --- it will be released when done with image */\n  dest->buffer = (JOCTET *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                OUTPUT_BUF_SIZE * sizeof(JOCTET));\n\n  dest->pub.next_output_byte = dest->buffer;\n  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;\n}\n\nMETHODDEF(void)\ninit_mem_destination(j_compress_ptr cinfo)\n{\n  /* no work necessary here */\n}\n\n\n/*\n * Empty the output buffer --- called whenever buffer fills up.\n *\n * In typical applications, this should write the entire output buffer\n * (ignoring the current state of next_output_byte & free_in_buffer),\n * reset the pointer & count to the start of the buffer, and return TRUE\n * indicating that the buffer has been dumped.\n *\n * In applications that need to be able to suspend compression due to output\n * overrun, a FALSE return indicates that the buffer cannot be emptied now.\n * In this situation, the compressor will return to its caller (possibly with\n * an indication that it has not accepted all the supplied scanlines).  The\n * application should resume compression after it has made more room in the\n * output buffer.  Note that there are substantial restrictions on the use of\n * suspension --- see the documentation.\n *\n * When suspending, the compressor will back up to a convenient restart point\n * (typically the start of the current MCU). next_output_byte & free_in_buffer\n * indicate where the restart point will be if the current call returns FALSE.\n * Data beyond this point will be regenerated after resumption, so do not\n * write it out when emptying the buffer externally.\n */\n\nMETHODDEF(boolean)\nempty_output_buffer(j_compress_ptr cinfo)\n{\n  my_dest_ptr dest = (my_dest_ptr)cinfo->dest;\n\n  if (fwrite(dest->buffer, 1, OUTPUT_BUF_SIZE, dest->outfile) !=\n      (size_t)OUTPUT_BUF_SIZE)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n\n  dest->pub.next_output_byte = dest->buffer;\n  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;\n\n  return TRUE;\n}\n\nMETHODDEF(boolean)\nempty_mem_output_buffer(j_compress_ptr cinfo)\n{\n  size_t nextsize;\n  JOCTET *nextbuffer;\n  my_mem_dest_ptr dest = (my_mem_dest_ptr)cinfo->dest;\n\n  /* Try to allocate new buffer with double size */\n  nextsize = dest->bufsize * 2;\n  nextbuffer = (JOCTET *)malloc(nextsize);\n\n  if (nextbuffer == NULL)\n    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 10);\n\n  memcpy(nextbuffer, dest->buffer, dest->bufsize);\n\n  free(dest->newbuffer);\n\n  dest->newbuffer = nextbuffer;\n\n  dest->pub.next_output_byte = nextbuffer + dest->bufsize;\n  dest->pub.free_in_buffer = dest->bufsize;\n\n  dest->buffer = nextbuffer;\n  dest->bufsize = nextsize;\n\n  return TRUE;\n}\n\n\n/*\n * Terminate destination --- called by jpeg_finish_compress\n * after all data has been written.  Usually needs to flush buffer.\n *\n * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding\n * application must deal with any cleanup that should happen even\n * for error exit.\n */\n\nMETHODDEF(void)\nterm_destination(j_compress_ptr cinfo)\n{\n  my_dest_ptr dest = (my_dest_ptr)cinfo->dest;\n  size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;\n\n  /* Write any data remaining in the buffer */\n  if (datacount > 0) {\n    if (fwrite(dest->buffer, 1, datacount, dest->outfile) != datacount)\n      ERREXIT(cinfo, JERR_FILE_WRITE);\n  }\n  fflush(dest->outfile);\n  /* Make sure we wrote the output file OK */\n  if (ferror(dest->outfile))\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n}\n\nMETHODDEF(void)\nterm_mem_destination(j_compress_ptr cinfo)\n{\n  my_mem_dest_ptr dest = (my_mem_dest_ptr)cinfo->dest;\n\n  *dest->outbuffer = dest->buffer;\n  *dest->outsize = (unsigned long)(dest->bufsize - dest->pub.free_in_buffer);\n}\n\n\n/*\n * Prepare for output to a stdio stream.\n * The caller must have already opened the stream, and is responsible\n * for closing it after finishing compression.\n */\n\nGLOBAL(void)\njpeg_stdio_dest(j_compress_ptr cinfo, FILE *outfile)\n{\n  my_dest_ptr dest;\n\n  /* The destination object is made permanent so that multiple JPEG images\n   * can be written to the same file without re-executing jpeg_stdio_dest.\n   */\n  if (cinfo->dest == NULL) {    /* first time for this JPEG object? */\n    cinfo->dest = (struct jpeg_destination_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(my_destination_mgr));\n  } else if (cinfo->dest->init_destination != init_destination) {\n    /* It is unsafe to reuse the existing destination manager unless it was\n     * created by this function.  Otherwise, there is no guarantee that the\n     * opaque structure is the right size.  Note that we could just create a\n     * new structure, but the old structure would not be freed until\n     * jpeg_destroy_compress() was called.\n     */\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  dest = (my_dest_ptr)cinfo->dest;\n  dest->pub.init_destination = init_destination;\n  dest->pub.empty_output_buffer = empty_output_buffer;\n  dest->pub.term_destination = term_destination;\n  dest->outfile = outfile;\n}\n\n\n/*\n * Prepare for output to a memory buffer.\n * The caller may supply an own initial buffer with appropriate size.\n * Otherwise, or when the actual data output exceeds the given size,\n * the library adapts the buffer size as necessary.\n * The standard library functions malloc/free are used for allocating\n * larger memory, so the buffer is available to the application after\n * finishing compression, and then the application is responsible for\n * freeing the requested memory.\n * Note:  An initial buffer supplied by the caller is expected to be\n * managed by the application.  The library does not free such buffer\n * when allocating a larger buffer.\n */\n\nGLOBAL(void)\njpeg_mem_dest_internal (j_compress_ptr cinfo,\n               unsigned char **outbuffer, unsigned long *outsize, int pool_id)\n{\n  my_mem_dest_ptr dest;\n\n  if (outbuffer == NULL || outsize == NULL)     /* sanity check */\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n\n  /* The destination object is made permanent so that multiple JPEG images\n   * can be written to the same buffer without re-executing jpeg_mem_dest.\n   */\n  if (cinfo->dest == NULL) {    /* first time for this JPEG object? */\n    cinfo->dest = (struct jpeg_destination_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, pool_id,\n                                  sizeof(my_mem_destination_mgr));\n  } else if (cinfo->dest->init_destination != init_mem_destination) {\n    /* It is unsafe to reuse the existing destination manager unless it was\n     * created by this function.\n     */\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  dest = (my_mem_dest_ptr)cinfo->dest;\n  dest->pub.init_destination = init_mem_destination;\n  dest->pub.empty_output_buffer = empty_mem_output_buffer;\n  dest->pub.term_destination = term_mem_destination;\n  dest->outbuffer = outbuffer;\n  dest->outsize = outsize;\n  dest->newbuffer = NULL;\n\n  if (*outbuffer == NULL || *outsize == 0) {\n    /* Allocate initial buffer */\n    dest->newbuffer = *outbuffer = (unsigned char *)malloc(OUTPUT_BUF_SIZE);\n    if (dest->newbuffer == NULL)\n      ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 10);\n    *outsize = OUTPUT_BUF_SIZE;\n  }\n\n  dest->pub.next_output_byte = dest->buffer = *outbuffer;\n  dest->pub.free_in_buffer = dest->bufsize = *outsize;\n}\n\nGLOBAL(void)\njpeg_mem_dest (j_compress_ptr cinfo,\n               unsigned char **outbuffer, unsigned long *outsize)\n{\n  /* The destination object is made permanent so that multiple JPEG images\n   * can be written to the same file without re-executing jpeg_stdio_dest.\n   */\n  jpeg_mem_dest_internal(cinfo, outbuffer, outsize, JPOOL_PERMANENT);\n}\n\n"
        },
        {
          "name": "jdatasrc-tj.c",
          "type": "blob",
          "size": 6.7900390625,
          "content": "/*\n * jdatasrc-tj.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * Modified 2009-2011 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2011, 2016, 2019, 2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains decompression data source routines for the case of\n * reading JPEG data from memory or from a file (or any stdio stream).\n * While these routines are sufficient for most applications,\n * some will want to use a different source manager.\n * IMPORTANT: we assume that fread() will correctly transcribe an array of\n * JOCTETs from 8-bit-wide elements on external storage.  If char is wider\n * than 8 bits on your machine, you may need to do some tweaking.\n */\n\n/* this is not a core library module, so it doesn't define JPEG_INTERNALS */\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n\nvoid jpeg_mem_src_tj(j_decompress_ptr cinfo, const unsigned char *inbuffer,\n                     size_t insize);\n\n\n/*\n * Initialize source --- called by jpeg_read_header\n * before any data is actually read.\n */\n\nMETHODDEF(void)\ninit_mem_source(j_decompress_ptr cinfo)\n{\n  /* no work necessary here */\n}\n\n\n/*\n * Fill the input buffer --- called whenever buffer is emptied.\n *\n * In typical applications, this should read fresh data into the buffer\n * (ignoring the current state of next_input_byte & bytes_in_buffer),\n * reset the pointer & count to the start of the buffer, and return TRUE\n * indicating that the buffer has been reloaded.  It is not necessary to\n * fill the buffer entirely, only to obtain at least one more byte.\n *\n * There is no such thing as an EOF return.  If the end of the file has been\n * reached, the routine has a choice of ERREXIT() or inserting fake data into\n * the buffer.  In most cases, generating a warning message and inserting a\n * fake EOI marker is the best course of action --- this will allow the\n * decompressor to output however much of the image is there.  However,\n * the resulting error message is misleading if the real problem is an empty\n * input file, so we handle that case specially.\n *\n * In applications that need to be able to suspend compression due to input\n * not being available yet, a FALSE return indicates that no more data can be\n * obtained right now, but more may be forthcoming later.  In this situation,\n * the decompressor will return to its caller (with an indication of the\n * number of scanlines it has read, if any).  The application should resume\n * decompression after it has loaded more data into the input buffer.  Note\n * that there are substantial restrictions on the use of suspension --- see\n * the documentation.\n *\n * When suspending, the decompressor will back up to a convenient restart point\n * (typically the start of the current MCU). next_input_byte & bytes_in_buffer\n * indicate where the restart point will be if the current call returns FALSE.\n * Data beyond this point must be rescanned after resumption, so move it to\n * the front of the buffer rather than discarding it.\n */\n\nMETHODDEF(boolean)\nfill_mem_input_buffer(j_decompress_ptr cinfo)\n{\n  static const JOCTET mybuffer[4] = {\n    (JOCTET)0xFF, (JOCTET)JPEG_EOI, 0, 0\n  };\n\n  /* The whole JPEG data is expected to reside in the supplied memory\n   * buffer, so any request for more data beyond the given buffer size\n   * is treated as an error.\n   */\n  WARNMS(cinfo, JWRN_JPEG_EOF);\n\n  /* Insert a fake EOI marker */\n\n  cinfo->src->next_input_byte = mybuffer;\n  cinfo->src->bytes_in_buffer = 2;\n\n  return TRUE;\n}\n\n\n/*\n * Skip data --- used to skip over a potentially large amount of\n * uninteresting data (such as an APPn marker).\n *\n * Writers of suspendable-input applications must note that skip_input_data\n * is not granted the right to give a suspension return.  If the skip extends\n * beyond the data currently in the buffer, the buffer can be marked empty so\n * that the next read will cause a fill_input_buffer call that can suspend.\n * Arranging for additional bytes to be discarded before reloading the input\n * buffer is the application writer's problem.\n */\n\nMETHODDEF(void)\nskip_input_data(j_decompress_ptr cinfo, long num_bytes)\n{\n  struct jpeg_source_mgr *src = cinfo->src;\n\n  /* Just a dumb implementation for now.  Could use fseek() except\n   * it doesn't work on pipes.  Not clear that being smart is worth\n   * any trouble anyway --- large skips are infrequent.\n   */\n  if (num_bytes > 0) {\n    while (num_bytes > (long)src->bytes_in_buffer) {\n      num_bytes -= (long)src->bytes_in_buffer;\n      (void)(*src->fill_input_buffer) (cinfo);\n      /* note we assume that fill_input_buffer will never return FALSE,\n       * so suspension need not be handled.\n       */\n    }\n    src->next_input_byte += (size_t)num_bytes;\n    src->bytes_in_buffer -= (size_t)num_bytes;\n  }\n}\n\n\n/*\n * An additional method that can be provided by data source modules is the\n * resync_to_restart method for error recovery in the presence of RST markers.\n * For the moment, this source module just uses the default resync method\n * provided by the JPEG library.  That method assumes that no backtracking\n * is possible.\n */\n\n\n/*\n * Terminate source --- called by jpeg_finish_decompress\n * after all data has been read.  Often a no-op.\n *\n * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding\n * application must deal with any cleanup that should happen even\n * for error exit.\n */\n\nMETHODDEF(void)\nterm_source(j_decompress_ptr cinfo)\n{\n  /* no work necessary here */\n}\n\n\n/*\n * Prepare for input from a supplied memory buffer.\n * The buffer must contain the whole JPEG data.\n */\n\nGLOBAL(void)\njpeg_mem_src_tj(j_decompress_ptr cinfo, const unsigned char *inbuffer,\n                size_t insize)\n{\n  struct jpeg_source_mgr *src;\n\n  if (inbuffer == NULL || insize == 0)  /* Treat empty input as fatal error */\n    ERREXIT(cinfo, JERR_INPUT_EMPTY);\n\n  /* The source object is made permanent so that a series of JPEG images\n   * can be read from the same buffer by calling jpeg_mem_src only before\n   * the first one.\n   */\n  if (cinfo->src == NULL) {     /* first time for this JPEG object? */\n    cinfo->src = (struct jpeg_source_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(struct jpeg_source_mgr));\n  } else if (cinfo->src->init_source != init_mem_source) {\n    /* It is unsafe to reuse the existing source manager unless it was created\n     * by this function.\n     */\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  src = cinfo->src;\n  src->init_source = init_mem_source;\n  src->fill_input_buffer = fill_mem_input_buffer;\n  src->skip_input_data = skip_input_data;\n  src->resync_to_restart = jpeg_resync_to_restart; /* use default method */\n  src->term_source = term_source;\n  src->bytes_in_buffer = insize;\n  src->next_input_byte = (const JOCTET *)inbuffer;\n}\n"
        },
        {
          "name": "jdatasrc.c",
          "type": "blob",
          "size": 9.8505859375,
          "content": "/*\n * jdatasrc.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * Modified 2009-2011 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2013, 2016, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains decompression data source routines for the case of\n * reading JPEG data from memory or from a file (or any stdio stream).\n * While these routines are sufficient for most applications,\n * some will want to use a different source manager.\n * IMPORTANT: we assume that fread() will correctly transcribe an array of\n * JOCTETs from 8-bit-wide elements on external storage.  If char is wider\n * than 8 bits on your machine, you may need to do some tweaking.\n */\n\n/* this is not a core library module, so it doesn't define JPEG_INTERNALS */\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n\n\n/* Expanded data source object for stdio input */\n\ntypedef struct {\n  struct jpeg_source_mgr pub;   /* public fields */\n\n  FILE *infile;                 /* source stream */\n  JOCTET *buffer;               /* start of buffer */\n  boolean start_of_file;        /* have we gotten any data yet? */\n} my_source_mgr;\n\ntypedef my_source_mgr *my_src_ptr;\n\n#define INPUT_BUF_SIZE  4096    /* choose an efficiently fread'able size */\n\n\n/*\n * Initialize source --- called by jpeg_read_header\n * before any data is actually read.\n */\n\nMETHODDEF(void)\ninit_source(j_decompress_ptr cinfo)\n{\n  my_src_ptr src = (my_src_ptr)cinfo->src;\n\n  /* We reset the empty-input-file flag for each image,\n   * but we don't clear the input buffer.\n   * This is correct behavior for reading a series of images from one source.\n   */\n  src->start_of_file = TRUE;\n}\n\nMETHODDEF(void)\ninit_mem_source(j_decompress_ptr cinfo)\n{\n  /* no work necessary here */\n}\n\n\n/*\n * Fill the input buffer --- called whenever buffer is emptied.\n *\n * In typical applications, this should read fresh data into the buffer\n * (ignoring the current state of next_input_byte & bytes_in_buffer),\n * reset the pointer & count to the start of the buffer, and return TRUE\n * indicating that the buffer has been reloaded.  It is not necessary to\n * fill the buffer entirely, only to obtain at least one more byte.\n *\n * There is no such thing as an EOF return.  If the end of the file has been\n * reached, the routine has a choice of ERREXIT() or inserting fake data into\n * the buffer.  In most cases, generating a warning message and inserting a\n * fake EOI marker is the best course of action --- this will allow the\n * decompressor to output however much of the image is there.  However,\n * the resulting error message is misleading if the real problem is an empty\n * input file, so we handle that case specially.\n *\n * In applications that need to be able to suspend compression due to input\n * not being available yet, a FALSE return indicates that no more data can be\n * obtained right now, but more may be forthcoming later.  In this situation,\n * the decompressor will return to its caller (with an indication of the\n * number of scanlines it has read, if any).  The application should resume\n * decompression after it has loaded more data into the input buffer.  Note\n * that there are substantial restrictions on the use of suspension --- see\n * the documentation.\n *\n * When suspending, the decompressor will back up to a convenient restart point\n * (typically the start of the current MCU). next_input_byte & bytes_in_buffer\n * indicate where the restart point will be if the current call returns FALSE.\n * Data beyond this point must be rescanned after resumption, so move it to\n * the front of the buffer rather than discarding it.\n */\n\nMETHODDEF(boolean)\nfill_input_buffer(j_decompress_ptr cinfo)\n{\n  my_src_ptr src = (my_src_ptr)cinfo->src;\n  size_t nbytes;\n\n  nbytes = fread(src->buffer, 1, INPUT_BUF_SIZE, src->infile);\n\n  if (nbytes <= 0) {\n    if (src->start_of_file)     /* Treat empty input file as fatal error */\n      ERREXIT(cinfo, JERR_INPUT_EMPTY);\n    WARNMS(cinfo, JWRN_JPEG_EOF);\n    /* Insert a fake EOI marker */\n    src->buffer[0] = (JOCTET)0xFF;\n    src->buffer[1] = (JOCTET)JPEG_EOI;\n    nbytes = 2;\n  }\n\n  src->pub.next_input_byte = src->buffer;\n  src->pub.bytes_in_buffer = nbytes;\n  src->start_of_file = FALSE;\n\n  return TRUE;\n}\n\nMETHODDEF(boolean)\nfill_mem_input_buffer(j_decompress_ptr cinfo)\n{\n  static const JOCTET mybuffer[4] = {\n    (JOCTET)0xFF, (JOCTET)JPEG_EOI, 0, 0\n  };\n\n  /* The whole JPEG data is expected to reside in the supplied memory\n   * buffer, so any request for more data beyond the given buffer size\n   * is treated as an error.\n   */\n  WARNMS(cinfo, JWRN_JPEG_EOF);\n\n  /* Insert a fake EOI marker */\n\n  cinfo->src->next_input_byte = mybuffer;\n  cinfo->src->bytes_in_buffer = 2;\n\n  return TRUE;\n}\n\n\n/*\n * Skip data --- used to skip over a potentially large amount of\n * uninteresting data (such as an APPn marker).\n *\n * Writers of suspendable-input applications must note that skip_input_data\n * is not granted the right to give a suspension return.  If the skip extends\n * beyond the data currently in the buffer, the buffer can be marked empty so\n * that the next read will cause a fill_input_buffer call that can suspend.\n * Arranging for additional bytes to be discarded before reloading the input\n * buffer is the application writer's problem.\n */\n\nMETHODDEF(void)\nskip_input_data(j_decompress_ptr cinfo, long num_bytes)\n{\n  struct jpeg_source_mgr *src = cinfo->src;\n\n  /* Just a dumb implementation for now.  Could use fseek() except\n   * it doesn't work on pipes.  Not clear that being smart is worth\n   * any trouble anyway --- large skips are infrequent.\n   */\n  if (num_bytes > 0) {\n    while (num_bytes > (long)src->bytes_in_buffer) {\n      num_bytes -= (long)src->bytes_in_buffer;\n      (void)(*src->fill_input_buffer) (cinfo);\n      /* note we assume that fill_input_buffer will never return FALSE,\n       * so suspension need not be handled.\n       */\n    }\n    src->next_input_byte += (size_t)num_bytes;\n    src->bytes_in_buffer -= (size_t)num_bytes;\n  }\n}\n\n\n/*\n * An additional method that can be provided by data source modules is the\n * resync_to_restart method for error recovery in the presence of RST markers.\n * For the moment, this source module just uses the default resync method\n * provided by the JPEG library.  That method assumes that no backtracking\n * is possible.\n */\n\n\n/*\n * Terminate source --- called by jpeg_finish_decompress\n * after all data has been read.  Often a no-op.\n *\n * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding\n * application must deal with any cleanup that should happen even\n * for error exit.\n */\n\nMETHODDEF(void)\nterm_source(j_decompress_ptr cinfo)\n{\n  /* no work necessary here */\n}\n\n\n/*\n * Prepare for input from a stdio stream.\n * The caller must have already opened the stream, and is responsible\n * for closing it after finishing decompression.\n */\n\nGLOBAL(void)\njpeg_stdio_src(j_decompress_ptr cinfo, FILE *infile)\n{\n  my_src_ptr src;\n\n  /* The source object and input buffer are made permanent so that a series\n   * of JPEG images can be read from the same file by calling jpeg_stdio_src\n   * only before the first one.  (If we discarded the buffer at the end of\n   * one image, we'd likely lose the start of the next one.)\n   */\n  if (cinfo->src == NULL) {     /* first time for this JPEG object? */\n    cinfo->src = (struct jpeg_source_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(my_source_mgr));\n    src = (my_src_ptr)cinfo->src;\n    src->buffer = (JOCTET *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  INPUT_BUF_SIZE * sizeof(JOCTET));\n  } else if (cinfo->src->init_source != init_source) {\n    /* It is unsafe to reuse the existing source manager unless it was created\n     * by this function.  Otherwise, there is no guarantee that the opaque\n     * structure is the right size.  Note that we could just create a new\n     * structure, but the old structure would not be freed until\n     * jpeg_destroy_decompress() was called.\n     */\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  src = (my_src_ptr)cinfo->src;\n  src->pub.init_source = init_source;\n  src->pub.fill_input_buffer = fill_input_buffer;\n  src->pub.skip_input_data = skip_input_data;\n  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */\n  src->pub.term_source = term_source;\n  src->infile = infile;\n  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */\n  src->pub.next_input_byte = NULL; /* until buffer loaded */\n}\n\n\n/*\n * Prepare for input from a supplied memory buffer.\n * The buffer must contain the whole JPEG data.\n */\n\nGLOBAL(void)\njpeg_mem_src(j_decompress_ptr cinfo, const unsigned char *inbuffer,\n             unsigned long insize)\n{\n  struct jpeg_source_mgr *src;\n\n  if (inbuffer == NULL || insize == 0)  /* Treat empty input as fatal error */\n    ERREXIT(cinfo, JERR_INPUT_EMPTY);\n\n  /* The source object is made permanent so that a series of JPEG images\n   * can be read from the same buffer by calling jpeg_mem_src only before\n   * the first one.\n   */\n  if (cinfo->src == NULL) {     /* first time for this JPEG object? */\n    cinfo->src = (struct jpeg_source_mgr *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                  sizeof(struct jpeg_source_mgr));\n  } else if (cinfo->src->init_source != init_mem_source) {\n    /* It is unsafe to reuse the existing source manager unless it was created\n     * by this function.\n     */\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  }\n\n  src = cinfo->src;\n  src->init_source = init_mem_source;\n  src->fill_input_buffer = fill_mem_input_buffer;\n  src->skip_input_data = skip_input_data;\n  src->resync_to_restart = jpeg_resync_to_restart; /* use default method */\n  src->term_source = term_source;\n  src->bytes_in_buffer = (size_t)insize;\n  src->next_input_byte = (const JOCTET *)inbuffer;\n}\n"
        },
        {
          "name": "jdcoefct.c",
          "type": "blob",
          "size": 33.6005859375,
          "content": "/*\n * jdcoefct.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2010, 2015-2016, 2019-2020, 2022-2024, D. R. Commander.\n * Copyright (C) 2015, 2020, Google, Inc.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the coefficient buffer controller for decompression.\n * This controller is the top level of the lossy JPEG decompressor proper.\n * The coefficient buffer lies between entropy decoding and inverse-DCT steps.\n *\n * In buffered-image mode, this controller is the interface between\n * input-oriented processing and output-oriented processing.\n * Also, the input side (only) is used when reading a file for transcoding.\n */\n\n#include \"jinclude.h\"\n#include \"jdcoefct.h\"\n#include \"jpegapicomp.h\"\n#include \"jsamplecomp.h\"\n\n\n/* Forward declarations */\nMETHODDEF(int) decompress_onepass(j_decompress_ptr cinfo,\n                                  _JSAMPIMAGE output_buf);\n#ifdef D_MULTISCAN_FILES_SUPPORTED\nMETHODDEF(int) decompress_data(j_decompress_ptr cinfo, _JSAMPIMAGE output_buf);\n#endif\n#ifdef BLOCK_SMOOTHING_SUPPORTED\nLOCAL(boolean) smoothing_ok(j_decompress_ptr cinfo);\nMETHODDEF(int) decompress_smooth_data(j_decompress_ptr cinfo,\n                                      _JSAMPIMAGE output_buf);\n#endif\n\n\n/*\n * Initialize for an input processing pass.\n */\n\nMETHODDEF(void)\nstart_input_pass(j_decompress_ptr cinfo)\n{\n  cinfo->input_iMCU_row = 0;\n  start_iMCU_row(cinfo);\n}\n\n\n/*\n * Initialize for an output processing pass.\n */\n\nMETHODDEF(void)\nstart_output_pass(j_decompress_ptr cinfo)\n{\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n\n  /* If multipass, check to see whether to use block smoothing on this pass */\n  if (coef->pub.coef_arrays != NULL) {\n    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))\n      coef->pub._decompress_data = decompress_smooth_data;\n    else\n      coef->pub._decompress_data = decompress_data;\n  }\n#endif\n  cinfo->output_iMCU_row = 0;\n}\n\n\n/*\n * Decompress and return some data in the single-pass case.\n * Always attempts to emit one fully interleaved MCU row (\"iMCU\" row).\n * Input and output must run in lockstep since we have only a one-MCU buffer.\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n *\n * NB: output_buf contains a plane for each component in image,\n * which we index according to the component's SOF position.\n */\n\nMETHODDEF(int)\ndecompress_onepass(j_decompress_ptr cinfo, _JSAMPIMAGE output_buf)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  JDIMENSION MCU_col_num;       /* index of current MCU within row */\n  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  int blkn, ci, xindex, yindex, yoffset, useful_width;\n  _JSAMPARRAY output_ptr;\n  JDIMENSION start_col, output_col;\n  jpeg_component_info *compptr;\n  _inverse_DCT_method_ptr inverse_DCT;\n\n  /* Loop to process as much as one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;\n         MCU_col_num++) {\n      /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */\n      jzero_far((void *)coef->MCU_buffer[0],\n                (size_t)(cinfo->blocks_in_MCU * sizeof(JBLOCK)));\n      if (!cinfo->entropy->insufficient_data)\n        cinfo->master->last_good_iMCU_row = cinfo->input_iMCU_row;\n      if (!(*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {\n        /* Suspension forced; update state counters and exit */\n        coef->MCU_vert_offset = yoffset;\n        coef->MCU_ctr = MCU_col_num;\n        return JPEG_SUSPENDED;\n      }\n\n      /* Only perform the IDCT on blocks that are contained within the desired\n       * cropping region.\n       */\n      if (MCU_col_num >= cinfo->master->first_iMCU_col &&\n          MCU_col_num <= cinfo->master->last_iMCU_col) {\n        /* Determine where data should go in output_buf and do the IDCT thing.\n         * We skip dummy blocks at the right and bottom edges (but blkn gets\n         * incremented past them!).  Note the inner loop relies on having\n         * allocated the MCU_buffer[] blocks sequentially.\n         */\n        blkn = 0;               /* index of current DCT block within MCU */\n        for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n          compptr = cinfo->cur_comp_info[ci];\n          /* Don't bother to IDCT an uninteresting component. */\n          if (!compptr->component_needed) {\n            blkn += compptr->MCU_blocks;\n            continue;\n          }\n          inverse_DCT = cinfo->idct->_inverse_DCT[compptr->component_index];\n          useful_width = (MCU_col_num < last_MCU_col) ?\n                         compptr->MCU_width : compptr->last_col_width;\n          output_ptr = output_buf[compptr->component_index] +\n                       yoffset * compptr->_DCT_scaled_size;\n          start_col = (MCU_col_num - cinfo->master->first_iMCU_col) *\n                      compptr->MCU_sample_width;\n          for (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n            if (cinfo->input_iMCU_row < last_iMCU_row ||\n                yoffset + yindex < compptr->last_row_height) {\n              output_col = start_col;\n              for (xindex = 0; xindex < useful_width; xindex++) {\n                (*inverse_DCT) (cinfo, compptr,\n                                (JCOEFPTR)coef->MCU_buffer[blkn + xindex],\n                                output_ptr, output_col);\n                output_col += compptr->_DCT_scaled_size;\n              }\n            }\n            blkn += compptr->MCU_width;\n            output_ptr += compptr->_DCT_scaled_size;\n          }\n        }\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->MCU_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  cinfo->output_iMCU_row++;\n  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {\n    start_iMCU_row(cinfo);\n    return JPEG_ROW_COMPLETED;\n  }\n  /* Completed the scan */\n  (*cinfo->inputctl->finish_input_pass) (cinfo);\n  return JPEG_SCAN_COMPLETED;\n}\n\n\n/*\n * Dummy consume-input routine for single-pass operation.\n */\n\nMETHODDEF(int)\ndummy_consume_data(j_decompress_ptr cinfo)\n{\n  return JPEG_SUSPENDED;        /* Always indicate nothing was done */\n}\n\n\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n\n/*\n * Consume input data and store it in the full-image coefficient buffer.\n * We read as much as one fully interleaved MCU row (\"iMCU\" row) per call,\n * ie, v_samp_factor block rows for each component in the scan.\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n */\n\nMETHODDEF(int)\nconsume_data(j_decompress_ptr cinfo)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  JDIMENSION MCU_col_num;       /* index of current MCU within row */\n  int blkn, ci, xindex, yindex, yoffset;\n  JDIMENSION start_col;\n  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];\n  JBLOCKROW buffer_ptr;\n  jpeg_component_info *compptr;\n\n  /* Align the virtual buffers for the components used in this scan. */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    buffer[ci] = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr)cinfo, coef->whole_image[compptr->component_index],\n       cinfo->input_iMCU_row * compptr->v_samp_factor,\n       (JDIMENSION)compptr->v_samp_factor, TRUE);\n    /* Note: entropy decoder expects buffer to be zeroed,\n     * but this is handled automatically by the memory manager\n     * because we requested a pre-zeroed array.\n     */\n  }\n\n  /* Loop to process one whole iMCU row */\n  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;\n       yoffset++) {\n    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;\n         MCU_col_num++) {\n      /* Construct list of pointers to DCT blocks belonging to this MCU */\n      blkn = 0;                 /* index of current DCT block within MCU */\n      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n        compptr = cinfo->cur_comp_info[ci];\n        start_col = MCU_col_num * compptr->MCU_width;\n        for (yindex = 0; yindex < compptr->MCU_height; yindex++) {\n          buffer_ptr = buffer[ci][yindex + yoffset] + start_col;\n          for (xindex = 0; xindex < compptr->MCU_width; xindex++) {\n            coef->MCU_buffer[blkn++] = buffer_ptr++;\n          }\n        }\n      }\n      if (!cinfo->entropy->insufficient_data)\n        cinfo->master->last_good_iMCU_row = cinfo->input_iMCU_row;\n      /* Try to fetch the MCU. */\n      if (!(*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {\n        /* Suspension forced; update state counters and exit */\n        coef->MCU_vert_offset = yoffset;\n        coef->MCU_ctr = MCU_col_num;\n        return JPEG_SUSPENDED;\n      }\n    }\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    coef->MCU_ctr = 0;\n  }\n  /* Completed the iMCU row, advance counters for next one */\n  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {\n    start_iMCU_row(cinfo);\n    return JPEG_ROW_COMPLETED;\n  }\n  /* Completed the scan */\n  (*cinfo->inputctl->finish_input_pass) (cinfo);\n  return JPEG_SCAN_COMPLETED;\n}\n\n\n/*\n * Decompress and return some data in the multi-pass case.\n * Always attempts to emit one fully interleaved MCU row (\"iMCU\" row).\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n *\n * NB: output_buf contains a plane for each component in image.\n */\n\nMETHODDEF(int)\ndecompress_data(j_decompress_ptr cinfo, _JSAMPIMAGE output_buf)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  JDIMENSION block_num;\n  int ci, block_row, block_rows;\n  JBLOCKARRAY buffer;\n  JBLOCKROW buffer_ptr;\n  _JSAMPARRAY output_ptr;\n  JDIMENSION output_col;\n  jpeg_component_info *compptr;\n  _inverse_DCT_method_ptr inverse_DCT;\n\n  /* Force some input to be done if we are getting ahead of the input. */\n  while (cinfo->input_scan_number < cinfo->output_scan_number ||\n         (cinfo->input_scan_number == cinfo->output_scan_number &&\n          cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {\n    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)\n      return JPEG_SUSPENDED;\n  }\n\n  /* OK, output from the virtual arrays. */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Don't bother to IDCT an uninteresting component. */\n    if (!compptr->component_needed)\n      continue;\n    /* Align the virtual buffer for this component. */\n    buffer = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr)cinfo, coef->whole_image[ci],\n       cinfo->output_iMCU_row * compptr->v_samp_factor,\n       (JDIMENSION)compptr->v_samp_factor, FALSE);\n    /* Count non-dummy DCT block rows in this iMCU row. */\n    if (cinfo->output_iMCU_row < last_iMCU_row)\n      block_rows = compptr->v_samp_factor;\n    else {\n      /* NB: can't use last_row_height here; it is input-side-dependent! */\n      block_rows = (int)(compptr->height_in_blocks % compptr->v_samp_factor);\n      if (block_rows == 0) block_rows = compptr->v_samp_factor;\n    }\n    inverse_DCT = cinfo->idct->_inverse_DCT[ci];\n    output_ptr = output_buf[ci];\n    /* Loop over all DCT blocks to be processed. */\n    for (block_row = 0; block_row < block_rows; block_row++) {\n      buffer_ptr = buffer[block_row] + cinfo->master->first_MCU_col[ci];\n      output_col = 0;\n      for (block_num = cinfo->master->first_MCU_col[ci];\n           block_num <= cinfo->master->last_MCU_col[ci]; block_num++) {\n        (*inverse_DCT) (cinfo, compptr, (JCOEFPTR)buffer_ptr, output_ptr,\n                        output_col);\n        buffer_ptr++;\n        output_col += compptr->_DCT_scaled_size;\n      }\n      output_ptr += compptr->_DCT_scaled_size;\n    }\n  }\n\n  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)\n    return JPEG_ROW_COMPLETED;\n  return JPEG_SCAN_COMPLETED;\n}\n\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\n\n\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n\n/*\n * This code applies interblock smoothing; the first 9 AC coefficients are\n * estimated from the DC values of a DCT block and its 24 neighboring blocks.\n * We apply smoothing only for progressive JPEG decoding, and only if\n * the coefficients it can estimate are not yet known to full precision.\n */\n\n/* Natural-order array positions of the first 9 zigzag-order coefficients */\n#define Q01_POS  1\n#define Q10_POS  8\n#define Q20_POS  16\n#define Q11_POS  9\n#define Q02_POS  2\n#define Q03_POS  3\n#define Q12_POS  10\n#define Q21_POS  17\n#define Q30_POS  24\n\n/*\n * Determine whether block smoothing is applicable and safe.\n * We also latch the current states of the coef_bits[] entries for the\n * AC coefficients; otherwise, if the input side of the decompressor\n * advances into a new scan, we might think the coefficients are known\n * more accurately than they really are.\n */\n\nLOCAL(boolean)\nsmoothing_ok(j_decompress_ptr cinfo)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  boolean smoothing_useful = FALSE;\n  int ci, coefi;\n  jpeg_component_info *compptr;\n  JQUANT_TBL *qtable;\n  int *coef_bits, *prev_coef_bits;\n  int *coef_bits_latch, *prev_coef_bits_latch;\n\n  if (!cinfo->progressive_mode || cinfo->coef_bits == NULL)\n    return FALSE;\n\n  /* Allocate latch area if not already done */\n  if (coef->coef_bits_latch == NULL)\n    coef->coef_bits_latch = (int *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  cinfo->num_components * 2 *\n                                  (SAVED_COEFS * sizeof(int)));\n  coef_bits_latch = coef->coef_bits_latch;\n  prev_coef_bits_latch =\n    &coef->coef_bits_latch[cinfo->num_components * SAVED_COEFS];\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* All components' quantization values must already be latched. */\n    if ((qtable = compptr->quant_table) == NULL)\n      return FALSE;\n    /* Verify DC & first 9 AC quantizers are nonzero to avoid zero-divide. */\n    if (qtable->quantval[0] == 0 ||\n        qtable->quantval[Q01_POS] == 0 ||\n        qtable->quantval[Q10_POS] == 0 ||\n        qtable->quantval[Q20_POS] == 0 ||\n        qtable->quantval[Q11_POS] == 0 ||\n        qtable->quantval[Q02_POS] == 0 ||\n        qtable->quantval[Q03_POS] == 0 ||\n        qtable->quantval[Q12_POS] == 0 ||\n        qtable->quantval[Q21_POS] == 0 ||\n        qtable->quantval[Q30_POS] == 0)\n      return FALSE;\n    /* DC values must be at least partly known for all components. */\n    coef_bits = cinfo->coef_bits[ci];\n    prev_coef_bits = cinfo->coef_bits[ci + cinfo->num_components];\n    if (coef_bits[0] < 0)\n      return FALSE;\n    coef_bits_latch[0] = coef_bits[0];\n    /* Block smoothing is helpful if some AC coefficients remain inaccurate. */\n    for (coefi = 1; coefi < SAVED_COEFS; coefi++) {\n      if (cinfo->input_scan_number > 1)\n        prev_coef_bits_latch[coefi] = prev_coef_bits[coefi];\n      else\n        prev_coef_bits_latch[coefi] = -1;\n      coef_bits_latch[coefi] = coef_bits[coefi];\n      if (coef_bits[coefi] != 0)\n        smoothing_useful = TRUE;\n    }\n    coef_bits_latch += SAVED_COEFS;\n    prev_coef_bits_latch += SAVED_COEFS;\n  }\n\n  return smoothing_useful;\n}\n\n\n/*\n * Variant of decompress_data for use when doing block smoothing.\n */\n\nMETHODDEF(int)\ndecompress_smooth_data(j_decompress_ptr cinfo, _JSAMPIMAGE output_buf)\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  JDIMENSION block_num, last_block_column;\n  int ci, block_row, block_rows, access_rows, image_block_row,\n    image_block_rows;\n  JBLOCKARRAY buffer;\n  JBLOCKROW buffer_ptr, prev_prev_block_row, prev_block_row;\n  JBLOCKROW next_block_row, next_next_block_row;\n  _JSAMPARRAY output_ptr;\n  JDIMENSION output_col;\n  jpeg_component_info *compptr;\n  _inverse_DCT_method_ptr inverse_DCT;\n  boolean change_dc;\n  JCOEF *workspace;\n  int *coef_bits;\n  JQUANT_TBL *quanttbl;\n  JLONG Q00, Q01, Q02, Q03 = 0, Q10, Q11, Q12 = 0, Q20, Q21 = 0, Q30 = 0, num;\n  int DC01, DC02, DC03, DC04, DC05, DC06, DC07, DC08, DC09, DC10, DC11, DC12,\n      DC13, DC14, DC15, DC16, DC17, DC18, DC19, DC20, DC21, DC22, DC23, DC24,\n      DC25;\n  int Al, pred;\n\n  /* Keep a local variable to avoid looking it up more than once */\n  workspace = coef->workspace;\n\n  /* Force some input to be done if we are getting ahead of the input. */\n  while (cinfo->input_scan_number <= cinfo->output_scan_number &&\n         !cinfo->inputctl->eoi_reached) {\n    if (cinfo->input_scan_number == cinfo->output_scan_number) {\n      /* If input is working on current scan, we ordinarily want it to\n       * have completed the current row.  But if input scan is DC,\n       * we want it to keep two rows ahead so that next two block rows' DC\n       * values are up to date.\n       */\n      JDIMENSION delta = (cinfo->Ss == 0) ? 2 : 0;\n      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row + delta)\n        break;\n    }\n    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)\n      return JPEG_SUSPENDED;\n  }\n\n  /* OK, output from the virtual arrays. */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Don't bother to IDCT an uninteresting component. */\n    if (!compptr->component_needed)\n      continue;\n    /* Count non-dummy DCT block rows in this iMCU row. */\n    if (cinfo->output_iMCU_row + 1 < last_iMCU_row) {\n      block_rows = compptr->v_samp_factor;\n      access_rows = block_rows * 3; /* this and next two iMCU rows */\n    } else if (cinfo->output_iMCU_row < last_iMCU_row) {\n      block_rows = compptr->v_samp_factor;\n      access_rows = block_rows * 2; /* this and next iMCU row */\n    } else {\n      /* NB: can't use last_row_height here; it is input-side-dependent! */\n      block_rows = (int)(compptr->height_in_blocks % compptr->v_samp_factor);\n      if (block_rows == 0) block_rows = compptr->v_samp_factor;\n      access_rows = block_rows; /* this iMCU row only */\n    }\n    /* Align the virtual buffer for this component. */\n    if (cinfo->output_iMCU_row > 1) {\n      access_rows += 2 * compptr->v_samp_factor; /* prior two iMCU rows too */\n      buffer = (*cinfo->mem->access_virt_barray)\n        ((j_common_ptr)cinfo, coef->whole_image[ci],\n         (cinfo->output_iMCU_row - 2) * compptr->v_samp_factor,\n         (JDIMENSION)access_rows, FALSE);\n      buffer += 2 * compptr->v_samp_factor; /* point to current iMCU row */\n    } else if (cinfo->output_iMCU_row > 0) {\n      access_rows += compptr->v_samp_factor; /* prior iMCU row too */\n      buffer = (*cinfo->mem->access_virt_barray)\n        ((j_common_ptr)cinfo, coef->whole_image[ci],\n         (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,\n         (JDIMENSION)access_rows, FALSE);\n      buffer += compptr->v_samp_factor; /* point to current iMCU row */\n    } else {\n      buffer = (*cinfo->mem->access_virt_barray)\n        ((j_common_ptr)cinfo, coef->whole_image[ci],\n         (JDIMENSION)0, (JDIMENSION)access_rows, FALSE);\n    }\n    /* Fetch component-dependent info.\n     * If the current scan is incomplete, then we use the component-dependent\n     * info from the previous scan.\n     */\n    if (cinfo->output_iMCU_row > cinfo->master->last_good_iMCU_row)\n      coef_bits =\n        coef->coef_bits_latch + ((ci + cinfo->num_components) * SAVED_COEFS);\n    else\n      coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);\n\n    /* We only do DC interpolation if no AC coefficient data is available. */\n    change_dc =\n      coef_bits[1] == -1 && coef_bits[2] == -1 && coef_bits[3] == -1 &&\n      coef_bits[4] == -1 && coef_bits[5] == -1 && coef_bits[6] == -1 &&\n      coef_bits[7] == -1 && coef_bits[8] == -1 && coef_bits[9] == -1;\n\n    quanttbl = compptr->quant_table;\n    Q00 = quanttbl->quantval[0];\n    Q01 = quanttbl->quantval[Q01_POS];\n    Q10 = quanttbl->quantval[Q10_POS];\n    Q20 = quanttbl->quantval[Q20_POS];\n    Q11 = quanttbl->quantval[Q11_POS];\n    Q02 = quanttbl->quantval[Q02_POS];\n    if (change_dc) {\n      Q03 = quanttbl->quantval[Q03_POS];\n      Q12 = quanttbl->quantval[Q12_POS];\n      Q21 = quanttbl->quantval[Q21_POS];\n      Q30 = quanttbl->quantval[Q30_POS];\n    }\n    inverse_DCT = cinfo->idct->_inverse_DCT[ci];\n    output_ptr = output_buf[ci];\n    /* Loop over all DCT blocks to be processed. */\n    image_block_rows = block_rows * cinfo->total_iMCU_rows;\n    for (block_row = 0; block_row < block_rows; block_row++) {\n      image_block_row = cinfo->output_iMCU_row * block_rows + block_row;\n      buffer_ptr = buffer[block_row] + cinfo->master->first_MCU_col[ci];\n\n      if (image_block_row > 0)\n        prev_block_row =\n          buffer[block_row - 1] + cinfo->master->first_MCU_col[ci];\n      else\n        prev_block_row = buffer_ptr;\n\n      if (image_block_row > 1)\n        prev_prev_block_row =\n          buffer[block_row - 2] + cinfo->master->first_MCU_col[ci];\n      else\n        prev_prev_block_row = prev_block_row;\n\n      if (image_block_row < image_block_rows - 1)\n        next_block_row =\n          buffer[block_row + 1] + cinfo->master->first_MCU_col[ci];\n      else\n        next_block_row = buffer_ptr;\n\n      if (image_block_row < image_block_rows - 2)\n        next_next_block_row =\n          buffer[block_row + 2] + cinfo->master->first_MCU_col[ci];\n      else\n        next_next_block_row = next_block_row;\n\n      /* We fetch the surrounding DC values using a sliding-register approach.\n       * Initialize all 25 here so as to do the right thing on narrow pics.\n       */\n      DC01 = DC02 = DC03 = DC04 = DC05 = (int)prev_prev_block_row[0][0];\n      DC06 = DC07 = DC08 = DC09 = DC10 = (int)prev_block_row[0][0];\n      DC11 = DC12 = DC13 = DC14 = DC15 = (int)buffer_ptr[0][0];\n      DC16 = DC17 = DC18 = DC19 = DC20 = (int)next_block_row[0][0];\n      DC21 = DC22 = DC23 = DC24 = DC25 = (int)next_next_block_row[0][0];\n      output_col = 0;\n      last_block_column = compptr->width_in_blocks - 1;\n      for (block_num = cinfo->master->first_MCU_col[ci];\n           block_num <= cinfo->master->last_MCU_col[ci]; block_num++) {\n        /* Fetch current DCT block into workspace so we can modify it. */\n        jcopy_block_row(buffer_ptr, (JBLOCKROW)workspace, (JDIMENSION)1);\n        /* Update DC values */\n        if (block_num == cinfo->master->first_MCU_col[ci] &&\n            block_num < last_block_column) {\n          DC04 = DC05 = (int)prev_prev_block_row[1][0];\n          DC09 = DC10 = (int)prev_block_row[1][0];\n          DC14 = DC15 = (int)buffer_ptr[1][0];\n          DC19 = DC20 = (int)next_block_row[1][0];\n          DC24 = DC25 = (int)next_next_block_row[1][0];\n        }\n        if (block_num + 1 < last_block_column) {\n          DC05 = (int)prev_prev_block_row[2][0];\n          DC10 = (int)prev_block_row[2][0];\n          DC15 = (int)buffer_ptr[2][0];\n          DC20 = (int)next_block_row[2][0];\n          DC25 = (int)next_next_block_row[2][0];\n        }\n        /* If DC interpolation is enabled, compute coefficient estimates using\n         * a Gaussian-like kernel, keeping the averages of the DC values.\n         *\n         * If DC interpolation is disabled, compute coefficient estimates using\n         * an algorithm similar to the one described in Section K.8 of the JPEG\n         * standard, except applied to a 5x5 window rather than a 3x3 window.\n         *\n         * An estimate is applied only if the coefficient is still zero and is\n         * not known to be fully accurate.\n         */\n        /* AC01 */\n        if ((Al = coef_bits[1]) != 0 && workspace[1] == 0) {\n          num = Q00 * (change_dc ?\n                (-DC01 - DC02 + DC04 + DC05 - 3 * DC06 + 13 * DC07 -\n                 13 * DC09 + 3 * DC10 - 3 * DC11 + 38 * DC12 - 38 * DC14 +\n                 3 * DC15 - 3 * DC16 + 13 * DC17 - 13 * DC19 + 3 * DC20 -\n                 DC21 - DC22 + DC24 + DC25) :\n                (-7 * DC11 + 50 * DC12 - 50 * DC14 + 7 * DC15));\n          if (num >= 0) {\n            pred = (int)(((Q01 << 7) + num) / (Q01 << 8));\n            if (Al > 0 && pred >= (1 << Al))\n              pred = (1 << Al) - 1;\n          } else {\n            pred = (int)(((Q01 << 7) - num) / (Q01 << 8));\n            if (Al > 0 && pred >= (1 << Al))\n              pred = (1 << Al) - 1;\n            pred = -pred;\n          }\n          workspace[1] = (JCOEF)pred;\n        }\n        /* AC10 */\n        if ((Al = coef_bits[2]) != 0 && workspace[8] == 0) {\n          num = Q00 * (change_dc ?\n                (-DC01 - 3 * DC02 - 3 * DC03 - 3 * DC04 - DC05 - DC06 +\n                 13 * DC07 + 38 * DC08 + 13 * DC09 - DC10 + DC16 -\n                 13 * DC17 - 38 * DC18 - 13 * DC19 + DC20 + DC21 +\n                 3 * DC22 + 3 * DC23 + 3 * DC24 + DC25) :\n                (-7 * DC03 + 50 * DC08 - 50 * DC18 + 7 * DC23));\n          if (num >= 0) {\n            pred = (int)(((Q10 << 7) + num) / (Q10 << 8));\n            if (Al > 0 && pred >= (1 << Al))\n              pred = (1 << Al) - 1;\n          } else {\n            pred = (int)(((Q10 << 7) - num) / (Q10 << 8));\n            if (Al > 0 && pred >= (1 << Al))\n              pred = (1 << Al) - 1;\n            pred = -pred;\n          }\n          workspace[8] = (JCOEF)pred;\n        }\n        /* AC20 */\n        if ((Al = coef_bits[3]) != 0 && workspace[16] == 0) {\n          num = Q00 * (change_dc ?\n                (DC03 + 2 * DC07 + 7 * DC08 + 2 * DC09 - 5 * DC12 - 14 * DC13 -\n                 5 * DC14 + 2 * DC17 + 7 * DC18 + 2 * DC19 + DC23) :\n                (-DC03 + 13 * DC08 - 24 * DC13 + 13 * DC18 - DC23));\n          if (num >= 0) {\n            pred = (int)(((Q20 << 7) + num) / (Q20 << 8));\n            if (Al > 0 && pred >= (1 << Al))\n              pred = (1 << Al) - 1;\n          } else {\n            pred = (int)(((Q20 << 7) - num) / (Q20 << 8));\n            if (Al > 0 && pred >= (1 << Al))\n              pred = (1 << Al) - 1;\n            pred = -pred;\n          }\n          workspace[16] = (JCOEF)pred;\n        }\n        /* AC11 */\n        if ((Al = coef_bits[4]) != 0 && workspace[9] == 0) {\n          num = Q00 * (change_dc ?\n                (-DC01 + DC05 + 9 * DC07 - 9 * DC09 - 9 * DC17 +\n                 9 * DC19 + DC21 - DC25) :\n                (DC10 + DC16 - 10 * DC17 + 10 * DC19 - DC02 - DC20 + DC22 -\n                 DC24 + DC04 - DC06 + 10 * DC07 - 10 * DC09));\n          if (num >= 0) {\n            pred = (int)(((Q11 << 7) + num) / (Q11 << 8));\n            if (Al > 0 && pred >= (1 << Al))\n              pred = (1 << Al) - 1;\n          } else {\n            pred = (int)(((Q11 << 7) - num) / (Q11 << 8));\n            if (Al > 0 && pred >= (1 << Al))\n              pred = (1 << Al) - 1;\n            pred = -pred;\n          }\n          workspace[9] = (JCOEF)pred;\n        }\n        /* AC02 */\n        if ((Al = coef_bits[5]) != 0 && workspace[2] == 0) {\n          num = Q00 * (change_dc ?\n                (2 * DC07 - 5 * DC08 + 2 * DC09 + DC11 + 7 * DC12 - 14 * DC13 +\n                 7 * DC14 + DC15 + 2 * DC17 - 5 * DC18 + 2 * DC19) :\n                (-DC11 + 13 * DC12 - 24 * DC13 + 13 * DC14 - DC15));\n          if (num >= 0) {\n            pred = (int)(((Q02 << 7) + num) / (Q02 << 8));\n            if (Al > 0 && pred >= (1 << Al))\n              pred = (1 << Al) - 1;\n          } else {\n            pred = (int)(((Q02 << 7) - num) / (Q02 << 8));\n            if (Al > 0 && pred >= (1 << Al))\n              pred = (1 << Al) - 1;\n            pred = -pred;\n          }\n          workspace[2] = (JCOEF)pred;\n        }\n        if (change_dc) {\n          /* AC03 */\n          if ((Al = coef_bits[6]) != 0 && workspace[3] == 0) {\n            num = Q00 * (DC07 - DC09 + 2 * DC12 - 2 * DC14 + DC17 - DC19);\n            if (num >= 0) {\n              pred = (int)(((Q03 << 7) + num) / (Q03 << 8));\n              if (Al > 0 && pred >= (1 << Al))\n                pred = (1 << Al) - 1;\n            } else {\n              pred = (int)(((Q03 << 7) - num) / (Q03 << 8));\n              if (Al > 0 && pred >= (1 << Al))\n                pred = (1 << Al) - 1;\n              pred = -pred;\n            }\n            workspace[3] = (JCOEF)pred;\n          }\n          /* AC12 */\n          if ((Al = coef_bits[7]) != 0 && workspace[10] == 0) {\n            num = Q00 * (DC07 - 3 * DC08 + DC09 - DC17 + 3 * DC18 - DC19);\n            if (num >= 0) {\n              pred = (int)(((Q12 << 7) + num) / (Q12 << 8));\n              if (Al > 0 && pred >= (1 << Al))\n                pred = (1 << Al) - 1;\n            } else {\n              pred = (int)(((Q12 << 7) - num) / (Q12 << 8));\n              if (Al > 0 && pred >= (1 << Al))\n                pred = (1 << Al) - 1;\n              pred = -pred;\n            }\n            workspace[10] = (JCOEF)pred;\n          }\n          /* AC21 */\n          if ((Al = coef_bits[8]) != 0 && workspace[17] == 0) {\n            num = Q00 * (DC07 - DC09 - 3 * DC12 + 3 * DC14 + DC17 - DC19);\n            if (num >= 0) {\n              pred = (int)(((Q21 << 7) + num) / (Q21 << 8));\n              if (Al > 0 && pred >= (1 << Al))\n                pred = (1 << Al) - 1;\n            } else {\n              pred = (int)(((Q21 << 7) - num) / (Q21 << 8));\n              if (Al > 0 && pred >= (1 << Al))\n                pred = (1 << Al) - 1;\n              pred = -pred;\n            }\n            workspace[17] = (JCOEF)pred;\n          }\n          /* AC30 */\n          if ((Al = coef_bits[9]) != 0 && workspace[24] == 0) {\n            num = Q00 * (DC07 + 2 * DC08 + DC09 - DC17 - 2 * DC18 - DC19);\n            if (num >= 0) {\n              pred = (int)(((Q30 << 7) + num) / (Q30 << 8));\n              if (Al > 0 && pred >= (1 << Al))\n                pred = (1 << Al) - 1;\n            } else {\n              pred = (int)(((Q30 << 7) - num) / (Q30 << 8));\n              if (Al > 0 && pred >= (1 << Al))\n                pred = (1 << Al) - 1;\n              pred = -pred;\n            }\n            workspace[24] = (JCOEF)pred;\n          }\n          /* coef_bits[0] is non-negative.  Otherwise this function would not\n           * be called.\n           */\n          num = Q00 *\n                (-2 * DC01 - 6 * DC02 - 8 * DC03 - 6 * DC04 - 2 * DC05 -\n                 6 * DC06 + 6 * DC07 + 42 * DC08 + 6 * DC09 - 6 * DC10 -\n                 8 * DC11 + 42 * DC12 + 152 * DC13 + 42 * DC14 - 8 * DC15 -\n                 6 * DC16 + 6 * DC17 + 42 * DC18 + 6 * DC19 - 6 * DC20 -\n                 2 * DC21 - 6 * DC22 - 8 * DC23 - 6 * DC24 - 2 * DC25);\n          if (num >= 0) {\n            pred = (int)(((Q00 << 7) + num) / (Q00 << 8));\n          } else {\n            pred = (int)(((Q00 << 7) - num) / (Q00 << 8));\n            pred = -pred;\n          }\n          workspace[0] = (JCOEF)pred;\n        }  /* change_dc */\n\n        /* OK, do the IDCT */\n        (*inverse_DCT) (cinfo, compptr, (JCOEFPTR)workspace, output_ptr,\n                        output_col);\n        /* Advance for next column */\n        DC01 = DC02;  DC02 = DC03;  DC03 = DC04;  DC04 = DC05;\n        DC06 = DC07;  DC07 = DC08;  DC08 = DC09;  DC09 = DC10;\n        DC11 = DC12;  DC12 = DC13;  DC13 = DC14;  DC14 = DC15;\n        DC16 = DC17;  DC17 = DC18;  DC18 = DC19;  DC19 = DC20;\n        DC21 = DC22;  DC22 = DC23;  DC23 = DC24;  DC24 = DC25;\n        buffer_ptr++, prev_block_row++, next_block_row++,\n          prev_prev_block_row++, next_next_block_row++;\n        output_col += compptr->_DCT_scaled_size;\n      }\n      output_ptr += compptr->_DCT_scaled_size;\n    }\n  }\n\n  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)\n    return JPEG_ROW_COMPLETED;\n  return JPEG_SCAN_COMPLETED;\n}\n\n#endif /* BLOCK_SMOOTHING_SUPPORTED */\n\n\n/*\n * Initialize coefficient buffer controller.\n */\n\nGLOBAL(void)\n_jinit_d_coef_controller(j_decompress_ptr cinfo, boolean need_full_buffer)\n{\n  my_coef_ptr coef;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  coef = (my_coef_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_coef_controller));\n  memset(coef, 0, sizeof(my_coef_controller));\n  cinfo->coef = (struct jpeg_d_coef_controller *)coef;\n  coef->pub.start_input_pass = start_input_pass;\n  coef->pub.start_output_pass = start_output_pass;\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n  coef->coef_bits_latch = NULL;\n#endif\n\n  /* Create the coefficient buffer. */\n  if (need_full_buffer) {\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n    /* Allocate a full-image virtual array for each component, */\n    /* padded to a multiple of samp_factor DCT blocks in each direction. */\n    /* Note we ask for a pre-zeroed array. */\n    int ci, access_rows;\n    jpeg_component_info *compptr;\n\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      access_rows = compptr->v_samp_factor;\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n      /* If block smoothing could be used, need a bigger window */\n      if (cinfo->progressive_mode)\n        access_rows *= 5;\n#endif\n      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)\n        ((j_common_ptr)cinfo, JPOOL_IMAGE, TRUE,\n         (JDIMENSION)jround_up((long)compptr->width_in_blocks,\n                               (long)compptr->h_samp_factor),\n         (JDIMENSION)jround_up((long)compptr->height_in_blocks,\n                               (long)compptr->v_samp_factor),\n         (JDIMENSION)access_rows);\n    }\n    coef->pub.consume_data = consume_data;\n    coef->pub._decompress_data = decompress_data;\n    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    /* We only need a single-MCU buffer. */\n    JBLOCKROW buffer;\n    int i;\n\n    buffer = (JBLOCKROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  D_MAX_BLOCKS_IN_MCU * sizeof(JBLOCK));\n    for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {\n      coef->MCU_buffer[i] = buffer + i;\n    }\n    coef->pub.consume_data = dummy_consume_data;\n    coef->pub._decompress_data = decompress_onepass;\n    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */\n  }\n\n  /* Allocate the workspace buffer */\n  coef->workspace = (JCOEF *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(JCOEF) * DCTSIZE2);\n}\n"
        },
        {
          "name": "jdcoefct.h",
          "type": "blob",
          "size": 2.8056640625,
          "content": "/*\n * jdcoefct.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2020, Google, Inc.\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n */\n\n#define JPEG_INTERNALS\n#include \"jpeglib.h\"\n\n\n#if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)\n\n/* Block smoothing is only applicable for progressive JPEG, so: */\n#ifndef D_PROGRESSIVE_SUPPORTED\n#undef BLOCK_SMOOTHING_SUPPORTED\n#endif\n\n\n/* Private buffer controller object */\n\ntypedef struct {\n  struct jpeg_d_coef_controller pub; /* public fields */\n\n  /* These variables keep track of the current location of the input side. */\n  /* cinfo->input_iMCU_row is also used for this. */\n  JDIMENSION MCU_ctr;           /* counts MCUs processed in current row */\n  int MCU_vert_offset;          /* counts MCU rows within iMCU row */\n  int MCU_rows_per_iMCU_row;    /* number of such rows needed */\n\n  /* The output side's location is represented by cinfo->output_iMCU_row. */\n\n  /* In single-pass modes, it's sufficient to buffer just one MCU.\n   * We allocate a workspace of D_MAX_BLOCKS_IN_MCU coefficient blocks,\n   * and let the entropy decoder write into that workspace each time.\n   * In multi-pass modes, this array points to the current MCU's blocks\n   * within the virtual arrays; it is used only by the input side.\n   */\n  JBLOCKROW MCU_buffer[D_MAX_BLOCKS_IN_MCU];\n\n  /* Temporary workspace for one MCU */\n  JCOEF *workspace;\n\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n  /* In multi-pass modes, we need a virtual block array for each component. */\n  jvirt_barray_ptr whole_image[MAX_COMPONENTS];\n#endif\n\n#ifdef BLOCK_SMOOTHING_SUPPORTED\n  /* When doing block smoothing, we latch coefficient Al values here */\n  int *coef_bits_latch;\n#define SAVED_COEFS  10         /* we save coef_bits[0..9] */\n#endif\n} my_coef_controller;\n\ntypedef my_coef_controller *my_coef_ptr;\n\n\nLOCAL(void)\nstart_iMCU_row(j_decompress_ptr cinfo)\n/* Reset within-iMCU-row counters for a new row (input side) */\n{\n  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;\n\n  /* In an interleaved scan, an MCU row is the same as an iMCU row.\n   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.\n   * But at the bottom of the image, process only what's left.\n   */\n  if (cinfo->comps_in_scan > 1) {\n    coef->MCU_rows_per_iMCU_row = 1;\n  } else {\n    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows - 1))\n      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;\n    else\n      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;\n  }\n\n  coef->MCU_ctr = 0;\n  coef->MCU_vert_offset = 0;\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED) */\n"
        },
        {
          "name": "jdcol565.c",
          "type": "blob",
          "size": 11.6298828125,
          "content": "/*\n * jdcol565.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modifications:\n * Copyright (C) 2013, Linaro Limited.\n * Copyright (C) 2014-2015, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains output colorspace conversion routines.\n */\n\n/* This file is included by jdcolor.c */\n\n\nINLINE\nLOCAL(void)\nycc_rgb565_convert_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                            JDIMENSION input_row, _JSAMPARRAY output_buf,\n                            int num_rows)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  register int y, cb, cr;\n  register _JSAMPROW outptr;\n  register _JSAMPROW inptr0, inptr1, inptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n  /* copy these pointers into registers if possible */\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  register int *Crrtab = cconvert->Cr_r_tab;\n  register int *Cbbtab = cconvert->Cb_b_tab;\n  register JLONG *Crgtab = cconvert->Cr_g_tab;\n  register JLONG *Cbgtab = cconvert->Cb_g_tab;\n  SHIFT_TEMPS\n\n  while (--num_rows >= 0) {\n    JLONG rgb;\n    unsigned int r, g, b;\n    inptr0 = input_buf[0][input_row];\n    inptr1 = input_buf[1][input_row];\n    inptr2 = input_buf[2][input_row];\n    input_row++;\n    outptr = *output_buf++;\n\n    if (PACK_NEED_ALIGNMENT(outptr)) {\n      y  = *inptr0++;\n      cb = *inptr1++;\n      cr = *inptr2++;\n      r = range_limit[y + Crrtab[cr]];\n      g = range_limit[y + ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n                                            SCALEBITS))];\n      b = range_limit[y + Cbbtab[cb]];\n      rgb = PACK_SHORT_565(r, g, b);\n      *(INT16 *)outptr = (INT16)rgb;\n      outptr += 2;\n      num_cols--;\n    }\n    for (col = 0; col < (num_cols >> 1); col++) {\n      y  = *inptr0++;\n      cb = *inptr1++;\n      cr = *inptr2++;\n      r = range_limit[y + Crrtab[cr]];\n      g = range_limit[y + ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n                                            SCALEBITS))];\n      b = range_limit[y + Cbbtab[cb]];\n      rgb = PACK_SHORT_565(r, g, b);\n\n      y  = *inptr0++;\n      cb = *inptr1++;\n      cr = *inptr2++;\n      r = range_limit[y + Crrtab[cr]];\n      g = range_limit[y + ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n                                            SCALEBITS))];\n      b = range_limit[y + Cbbtab[cb]];\n      rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n      WRITE_TWO_ALIGNED_PIXELS(outptr, rgb);\n      outptr += 4;\n    }\n    if (num_cols & 1) {\n      y  = *inptr0;\n      cb = *inptr1;\n      cr = *inptr2;\n      r = range_limit[y + Crrtab[cr]];\n      g = range_limit[y + ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n                                            SCALEBITS))];\n      b = range_limit[y + Cbbtab[cb]];\n      rgb = PACK_SHORT_565(r, g, b);\n      *(INT16 *)outptr = (INT16)rgb;\n    }\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\nINLINE\nLOCAL(void)\nycc_rgb565D_convert_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                             JDIMENSION input_row, _JSAMPARRAY output_buf,\n                             int num_rows)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  register int y, cb, cr;\n  register _JSAMPROW outptr;\n  register _JSAMPROW inptr0, inptr1, inptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n  /* copy these pointers into registers if possible */\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  register int *Crrtab = cconvert->Cr_r_tab;\n  register int *Cbbtab = cconvert->Cb_b_tab;\n  register JLONG *Crgtab = cconvert->Cr_g_tab;\n  register JLONG *Cbgtab = cconvert->Cb_g_tab;\n  JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];\n  SHIFT_TEMPS\n\n  while (--num_rows >= 0) {\n    JLONG rgb;\n    unsigned int r, g, b;\n\n    inptr0 = input_buf[0][input_row];\n    inptr1 = input_buf[1][input_row];\n    inptr2 = input_buf[2][input_row];\n    input_row++;\n    outptr = *output_buf++;\n    if (PACK_NEED_ALIGNMENT(outptr)) {\n      y  = *inptr0++;\n      cb = *inptr1++;\n      cr = *inptr2++;\n      r = range_limit[DITHER_565_R(y + Crrtab[cr], d0)];\n      g = range_limit[DITHER_565_G(y +\n                                   ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n                                                     SCALEBITS)), d0)];\n      b = range_limit[DITHER_565_B(y + Cbbtab[cb], d0)];\n      rgb = PACK_SHORT_565(r, g, b);\n      *(INT16 *)outptr = (INT16)rgb;\n      outptr += 2;\n      num_cols--;\n    }\n    for (col = 0; col < (num_cols >> 1); col++) {\n      y  = *inptr0++;\n      cb = *inptr1++;\n      cr = *inptr2++;\n      r = range_limit[DITHER_565_R(y + Crrtab[cr], d0)];\n      g = range_limit[DITHER_565_G(y +\n                                   ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n                                                     SCALEBITS)), d0)];\n      b = range_limit[DITHER_565_B(y + Cbbtab[cb], d0)];\n      d0 = DITHER_ROTATE(d0);\n      rgb = PACK_SHORT_565(r, g, b);\n\n      y  = *inptr0++;\n      cb = *inptr1++;\n      cr = *inptr2++;\n      r = range_limit[DITHER_565_R(y + Crrtab[cr], d0)];\n      g = range_limit[DITHER_565_G(y +\n                                   ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n                                                     SCALEBITS)), d0)];\n      b = range_limit[DITHER_565_B(y + Cbbtab[cb], d0)];\n      d0 = DITHER_ROTATE(d0);\n      rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n      WRITE_TWO_ALIGNED_PIXELS(outptr, rgb);\n      outptr += 4;\n    }\n    if (num_cols & 1) {\n      y  = *inptr0;\n      cb = *inptr1;\n      cr = *inptr2;\n      r = range_limit[DITHER_565_R(y + Crrtab[cr], d0)];\n      g = range_limit[DITHER_565_G(y +\n                                   ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n                                                     SCALEBITS)), d0)];\n      b = range_limit[DITHER_565_B(y + Cbbtab[cb], d0)];\n      rgb = PACK_SHORT_565(r, g, b);\n      *(INT16 *)outptr = (INT16)rgb;\n    }\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\nINLINE\nLOCAL(void)\nrgb_rgb565_convert_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                            JDIMENSION input_row, _JSAMPARRAY output_buf,\n                            int num_rows)\n{\n  register _JSAMPROW outptr;\n  register _JSAMPROW inptr0, inptr1, inptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n  SHIFT_TEMPS\n\n  while (--num_rows >= 0) {\n    JLONG rgb;\n    unsigned int r, g, b;\n\n    inptr0 = input_buf[0][input_row];\n    inptr1 = input_buf[1][input_row];\n    inptr2 = input_buf[2][input_row];\n    input_row++;\n    outptr = *output_buf++;\n    if (PACK_NEED_ALIGNMENT(outptr)) {\n      r = *inptr0++;\n      g = *inptr1++;\n      b = *inptr2++;\n      rgb = PACK_SHORT_565(r, g, b);\n      *(INT16 *)outptr = (INT16)rgb;\n      outptr += 2;\n      num_cols--;\n    }\n    for (col = 0; col < (num_cols >> 1); col++) {\n      r = *inptr0++;\n      g = *inptr1++;\n      b = *inptr2++;\n      rgb = PACK_SHORT_565(r, g, b);\n\n      r = *inptr0++;\n      g = *inptr1++;\n      b = *inptr2++;\n      rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n      WRITE_TWO_ALIGNED_PIXELS(outptr, rgb);\n      outptr += 4;\n    }\n    if (num_cols & 1) {\n      r = *inptr0;\n      g = *inptr1;\n      b = *inptr2;\n      rgb = PACK_SHORT_565(r, g, b);\n      *(INT16 *)outptr = (INT16)rgb;\n    }\n  }\n}\n\n\nINLINE\nLOCAL(void)\nrgb_rgb565D_convert_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                             JDIMENSION input_row, _JSAMPARRAY output_buf,\n                             int num_rows)\n{\n  register _JSAMPROW outptr;\n  register _JSAMPROW inptr0, inptr1, inptr2;\n  register JDIMENSION col;\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  JDIMENSION num_cols = cinfo->output_width;\n  JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];\n  SHIFT_TEMPS\n\n  while (--num_rows >= 0) {\n    JLONG rgb;\n    unsigned int r, g, b;\n\n    inptr0 = input_buf[0][input_row];\n    inptr1 = input_buf[1][input_row];\n    inptr2 = input_buf[2][input_row];\n    input_row++;\n    outptr = *output_buf++;\n    if (PACK_NEED_ALIGNMENT(outptr)) {\n      r = range_limit[DITHER_565_R(*inptr0++, d0)];\n      g = range_limit[DITHER_565_G(*inptr1++, d0)];\n      b = range_limit[DITHER_565_B(*inptr2++, d0)];\n      rgb = PACK_SHORT_565(r, g, b);\n      *(INT16 *)outptr = (INT16)rgb;\n      outptr += 2;\n      num_cols--;\n    }\n    for (col = 0; col < (num_cols >> 1); col++) {\n      r = range_limit[DITHER_565_R(*inptr0++, d0)];\n      g = range_limit[DITHER_565_G(*inptr1++, d0)];\n      b = range_limit[DITHER_565_B(*inptr2++, d0)];\n      d0 = DITHER_ROTATE(d0);\n      rgb = PACK_SHORT_565(r, g, b);\n\n      r = range_limit[DITHER_565_R(*inptr0++, d0)];\n      g = range_limit[DITHER_565_G(*inptr1++, d0)];\n      b = range_limit[DITHER_565_B(*inptr2++, d0)];\n      d0 = DITHER_ROTATE(d0);\n      rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n      WRITE_TWO_ALIGNED_PIXELS(outptr, rgb);\n      outptr += 4;\n    }\n    if (num_cols & 1) {\n      r = range_limit[DITHER_565_R(*inptr0, d0)];\n      g = range_limit[DITHER_565_G(*inptr1, d0)];\n      b = range_limit[DITHER_565_B(*inptr2, d0)];\n      rgb = PACK_SHORT_565(r, g, b);\n      *(INT16 *)outptr = (INT16)rgb;\n    }\n  }\n}\n\n\nINLINE\nLOCAL(void)\ngray_rgb565_convert_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                             JDIMENSION input_row, _JSAMPARRAY output_buf,\n                             int num_rows)\n{\n  register _JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n\n  while (--num_rows >= 0) {\n    JLONG rgb;\n    unsigned int g;\n\n    inptr = input_buf[0][input_row++];\n    outptr = *output_buf++;\n    if (PACK_NEED_ALIGNMENT(outptr)) {\n      g = *inptr++;\n      rgb = PACK_SHORT_565(g, g, g);\n      *(INT16 *)outptr = (INT16)rgb;\n      outptr += 2;\n      num_cols--;\n    }\n    for (col = 0; col < (num_cols >> 1); col++) {\n      g = *inptr++;\n      rgb = PACK_SHORT_565(g, g, g);\n      g = *inptr++;\n      rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(g, g, g));\n      WRITE_TWO_ALIGNED_PIXELS(outptr, rgb);\n      outptr += 4;\n    }\n    if (num_cols & 1) {\n      g = *inptr;\n      rgb = PACK_SHORT_565(g, g, g);\n      *(INT16 *)outptr = (INT16)rgb;\n    }\n  }\n}\n\n\nINLINE\nLOCAL(void)\ngray_rgb565D_convert_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                              JDIMENSION input_row, _JSAMPARRAY output_buf,\n                              int num_rows)\n{\n  register _JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  JDIMENSION num_cols = cinfo->output_width;\n  JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];\n\n  while (--num_rows >= 0) {\n    JLONG rgb;\n    unsigned int g;\n\n    inptr = input_buf[0][input_row++];\n    outptr = *output_buf++;\n    if (PACK_NEED_ALIGNMENT(outptr)) {\n      g = *inptr++;\n      g = range_limit[DITHER_565_R(g, d0)];\n      rgb = PACK_SHORT_565(g, g, g);\n      *(INT16 *)outptr = (INT16)rgb;\n      outptr += 2;\n      num_cols--;\n    }\n    for (col = 0; col < (num_cols >> 1); col++) {\n      g = *inptr++;\n      g = range_limit[DITHER_565_R(g, d0)];\n      rgb = PACK_SHORT_565(g, g, g);\n      d0 = DITHER_ROTATE(d0);\n\n      g = *inptr++;\n      g = range_limit[DITHER_565_R(g, d0)];\n      rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(g, g, g));\n      d0 = DITHER_ROTATE(d0);\n\n      WRITE_TWO_ALIGNED_PIXELS(outptr, rgb);\n      outptr += 4;\n    }\n    if (num_cols & 1) {\n      g = *inptr;\n      g = range_limit[DITHER_565_R(g, d0)];\n      rgb = PACK_SHORT_565(g, g, g);\n      *(INT16 *)outptr = (INT16)rgb;\n    }\n  }\n}\n"
        },
        {
          "name": "jdcolext.c",
          "type": "blob",
          "size": 4.408203125,
          "content": "/*\n * jdcolext.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2009, 2011, 2015, 2022-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains output colorspace conversion routines.\n */\n\n\n/* This file is included by jdcolor.c */\n\n\n/*\n * Convert some rows of samples to the output colorspace.\n *\n * Note that we change from noninterleaved, one-plane-per-component format\n * to interleaved-pixel format.  The output buffer is therefore three times\n * as wide as the input buffer.\n * A starting row offset is provided only for the input buffer.  The caller\n * can easily adjust the passed output_buf value to accommodate any row\n * offset required on that side.\n */\n\nINLINE\nLOCAL(void)\nycc_rgb_convert_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                         JDIMENSION input_row, _JSAMPARRAY output_buf,\n                         int num_rows)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  register int y, cb, cr;\n  register _JSAMPROW outptr;\n  register _JSAMPROW inptr0, inptr1, inptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n  /* copy these pointers into registers if possible */\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  register int *Crrtab = cconvert->Cr_r_tab;\n  register int *Cbbtab = cconvert->Cb_b_tab;\n  register JLONG *Crgtab = cconvert->Cr_g_tab;\n  register JLONG *Cbgtab = cconvert->Cb_g_tab;\n  SHIFT_TEMPS\n\n  while (--num_rows >= 0) {\n    inptr0 = input_buf[0][input_row];\n    inptr1 = input_buf[1][input_row];\n    inptr2 = input_buf[2][input_row];\n    input_row++;\n    outptr = *output_buf++;\n    for (col = 0; col < num_cols; col++) {\n      y  = inptr0[col];\n      cb = inptr1[col];\n      cr = inptr2[col];\n      /* Range-limiting is essential due to noise introduced by DCT losses. */\n      outptr[RGB_RED] =   range_limit[y + Crrtab[cr]];\n      outptr[RGB_GREEN] = range_limit[y +\n                              ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n                                                SCALEBITS))];\n      outptr[RGB_BLUE] =  range_limit[y + Cbbtab[cb]];\n      /* Set unused byte to _MAXJSAMPLE so it can be interpreted as an */\n      /* opaque alpha channel value */\n#ifdef RGB_ALPHA\n      outptr[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n      outptr += RGB_PIXELSIZE;\n    }\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\n/*\n * Convert grayscale to RGB: just duplicate the graylevel three times.\n * This is provided to support applications that don't want to cope\n * with grayscale as a separate case.\n */\n\nINLINE\nLOCAL(void)\ngray_rgb_convert_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                          JDIMENSION input_row, _JSAMPARRAY output_buf,\n                          int num_rows)\n{\n  register _JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n\n  while (--num_rows >= 0) {\n    inptr = input_buf[0][input_row++];\n    outptr = *output_buf++;\n    for (col = 0; col < num_cols; col++) {\n      outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];\n      /* Set unused byte to _MAXJSAMPLE so it can be interpreted as an */\n      /* opaque alpha channel value */\n#ifdef RGB_ALPHA\n      outptr[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n      outptr += RGB_PIXELSIZE;\n    }\n  }\n}\n\n\n/*\n * Convert RGB to extended RGB: just swap the order of source pixels\n */\n\nINLINE\nLOCAL(void)\nrgb_rgb_convert_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                         JDIMENSION input_row, _JSAMPARRAY output_buf,\n                         int num_rows)\n{\n  register _JSAMPROW inptr0, inptr1, inptr2;\n  register _JSAMPROW outptr;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n\n  while (--num_rows >= 0) {\n    inptr0 = input_buf[0][input_row];\n    inptr1 = input_buf[1][input_row];\n    inptr2 = input_buf[2][input_row];\n    input_row++;\n    outptr = *output_buf++;\n    for (col = 0; col < num_cols; col++) {\n      outptr[RGB_RED] = inptr0[col];\n      outptr[RGB_GREEN] = inptr1[col];\n      outptr[RGB_BLUE] = inptr2[col];\n      /* Set unused byte to _MAXJSAMPLE so it can be interpreted as an */\n      /* opaque alpha channel value */\n#ifdef RGB_ALPHA\n      outptr[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n      outptr += RGB_PIXELSIZE;\n    }\n  }\n}\n"
        },
        {
          "name": "jdcolor.c",
          "type": "blob",
          "size": 29.302734375,
          "content": "/*\n * jdcolor.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 2011 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2009, 2011-2012, 2014-2015, 2022, D. R. Commander.\n * Copyright (C) 2013, Linaro Limited.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains output colorspace conversion routines.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsimd.h\"\n#include \"jsamplecomp.h\"\n\n\n#if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)\n\n/* Private subobject */\n\ntypedef struct {\n  struct jpeg_color_deconverter pub; /* public fields */\n\n#if BITS_IN_JSAMPLE != 16\n  /* Private state for YCC->RGB conversion */\n  int *Cr_r_tab;                /* => table for Cr to R conversion */\n  int *Cb_b_tab;                /* => table for Cb to B conversion */\n  JLONG *Cr_g_tab;              /* => table for Cr to G conversion */\n  JLONG *Cb_g_tab;              /* => table for Cb to G conversion */\n\n  /* Private state for RGB->Y conversion */\n  JLONG *rgb_y_tab;             /* => table for RGB to Y conversion */\n#endif\n} my_color_deconverter;\n\ntypedef my_color_deconverter *my_cconvert_ptr;\n\n\n/**************** YCbCr -> RGB conversion: most common case **************/\n/****************   RGB -> Y   conversion: less common case **************/\n\n/*\n * YCbCr is defined per CCIR 601-1, except that Cb and Cr are\n * normalized to the range 0.._MAXJSAMPLE rather than -0.5 .. 0.5.\n * The conversion equations to be implemented are therefore\n *\n *      R = Y                + 1.40200 * Cr\n *      G = Y - 0.34414 * Cb - 0.71414 * Cr\n *      B = Y + 1.77200 * Cb\n *\n *      Y = 0.29900 * R + 0.58700 * G + 0.11400 * B\n *\n * where Cb and Cr represent the incoming values less _CENTERJSAMPLE.\n * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)\n *\n * To avoid floating-point arithmetic, we represent the fractional constants\n * as integers scaled up by 2^16 (about 4 digits precision); we have to divide\n * the products by 2^16, with appropriate rounding, to get the correct answer.\n * Notice that Y, being an integral input, does not contribute any fraction\n * so it need not participate in the rounding.\n *\n * For even more speed, we avoid doing any multiplications in the inner loop\n * by precalculating the constants times Cb and Cr for all possible values.\n * For 8-bit samples this is very reasonable (only 256 entries per table);\n * for 12-bit samples it is still acceptable.  It's not very reasonable for\n * 16-bit samples, but if you want lossless storage you shouldn't be changing\n * colorspace anyway.\n * The Cr=>R and Cb=>B values can be rounded to integers in advance; the\n * values for the G calculation are left scaled up, since we must add them\n * together before rounding.\n */\n\n#define SCALEBITS       16      /* speediest right-shift on some machines */\n#define ONE_HALF        ((JLONG)1 << (SCALEBITS - 1))\n#define FIX(x)          ((JLONG)((x) * (1L << SCALEBITS) + 0.5))\n\n/* We allocate one big table for RGB->Y conversion and divide it up into\n * three parts, instead of doing three alloc_small requests.  This lets us\n * use a single table base address, which can be held in a register in the\n * inner loops on many machines (more than can hold all three addresses,\n * anyway).\n */\n\n#define R_Y_OFF         0                       /* offset to R => Y section */\n#define G_Y_OFF         (1 * (_MAXJSAMPLE + 1)) /* offset to G => Y section */\n#define B_Y_OFF         (2 * (_MAXJSAMPLE + 1)) /* etc. */\n#define TABLE_SIZE      (3 * (_MAXJSAMPLE + 1))\n\n\n/* Include inline routines for colorspace extensions */\n\n#include \"jdcolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n\n#define RGB_RED  EXT_RGB_RED\n#define RGB_GREEN  EXT_RGB_GREEN\n#define RGB_BLUE  EXT_RGB_BLUE\n#define RGB_PIXELSIZE  EXT_RGB_PIXELSIZE\n#define ycc_rgb_convert_internal  ycc_extrgb_convert_internal\n#define gray_rgb_convert_internal  gray_extrgb_convert_internal\n#define rgb_rgb_convert_internal  rgb_extrgb_convert_internal\n#include \"jdcolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n#undef ycc_rgb_convert_internal\n#undef gray_rgb_convert_internal\n#undef rgb_rgb_convert_internal\n\n#define RGB_RED  EXT_RGBX_RED\n#define RGB_GREEN  EXT_RGBX_GREEN\n#define RGB_BLUE  EXT_RGBX_BLUE\n#define RGB_ALPHA  3\n#define RGB_PIXELSIZE  EXT_RGBX_PIXELSIZE\n#define ycc_rgb_convert_internal  ycc_extrgbx_convert_internal\n#define gray_rgb_convert_internal  gray_extrgbx_convert_internal\n#define rgb_rgb_convert_internal  rgb_extrgbx_convert_internal\n#include \"jdcolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_ALPHA\n#undef RGB_PIXELSIZE\n#undef ycc_rgb_convert_internal\n#undef gray_rgb_convert_internal\n#undef rgb_rgb_convert_internal\n\n#define RGB_RED  EXT_BGR_RED\n#define RGB_GREEN  EXT_BGR_GREEN\n#define RGB_BLUE  EXT_BGR_BLUE\n#define RGB_PIXELSIZE  EXT_BGR_PIXELSIZE\n#define ycc_rgb_convert_internal  ycc_extbgr_convert_internal\n#define gray_rgb_convert_internal  gray_extbgr_convert_internal\n#define rgb_rgb_convert_internal  rgb_extbgr_convert_internal\n#include \"jdcolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n#undef ycc_rgb_convert_internal\n#undef gray_rgb_convert_internal\n#undef rgb_rgb_convert_internal\n\n#define RGB_RED  EXT_BGRX_RED\n#define RGB_GREEN  EXT_BGRX_GREEN\n#define RGB_BLUE  EXT_BGRX_BLUE\n#define RGB_ALPHA  3\n#define RGB_PIXELSIZE  EXT_BGRX_PIXELSIZE\n#define ycc_rgb_convert_internal  ycc_extbgrx_convert_internal\n#define gray_rgb_convert_internal  gray_extbgrx_convert_internal\n#define rgb_rgb_convert_internal  rgb_extbgrx_convert_internal\n#include \"jdcolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_ALPHA\n#undef RGB_PIXELSIZE\n#undef ycc_rgb_convert_internal\n#undef gray_rgb_convert_internal\n#undef rgb_rgb_convert_internal\n\n#define RGB_RED  EXT_XBGR_RED\n#define RGB_GREEN  EXT_XBGR_GREEN\n#define RGB_BLUE  EXT_XBGR_BLUE\n#define RGB_ALPHA  0\n#define RGB_PIXELSIZE  EXT_XBGR_PIXELSIZE\n#define ycc_rgb_convert_internal  ycc_extxbgr_convert_internal\n#define gray_rgb_convert_internal  gray_extxbgr_convert_internal\n#define rgb_rgb_convert_internal  rgb_extxbgr_convert_internal\n#include \"jdcolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_ALPHA\n#undef RGB_PIXELSIZE\n#undef ycc_rgb_convert_internal\n#undef gray_rgb_convert_internal\n#undef rgb_rgb_convert_internal\n\n#define RGB_RED  EXT_XRGB_RED\n#define RGB_GREEN  EXT_XRGB_GREEN\n#define RGB_BLUE  EXT_XRGB_BLUE\n#define RGB_ALPHA  0\n#define RGB_PIXELSIZE  EXT_XRGB_PIXELSIZE\n#define ycc_rgb_convert_internal  ycc_extxrgb_convert_internal\n#define gray_rgb_convert_internal  gray_extxrgb_convert_internal\n#define rgb_rgb_convert_internal  rgb_extxrgb_convert_internal\n#include \"jdcolext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_ALPHA\n#undef RGB_PIXELSIZE\n#undef ycc_rgb_convert_internal\n#undef gray_rgb_convert_internal\n#undef rgb_rgb_convert_internal\n\n\n/*\n * Initialize tables for YCC->RGB colorspace conversion.\n */\n\nLOCAL(void)\nbuild_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n\n  cconvert->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (_MAXJSAMPLE + 1) * sizeof(int));\n  cconvert->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (_MAXJSAMPLE + 1) * sizeof(int));\n  cconvert->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (_MAXJSAMPLE + 1) * sizeof(JLONG));\n  cconvert->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (_MAXJSAMPLE + 1) * sizeof(JLONG));\n\n  for (i = 0, x = -_CENTERJSAMPLE; i <= _MAXJSAMPLE; i++, x++) {\n    /* i is the actual input pixel value, in the range 0.._MAXJSAMPLE */\n    /* The Cb or Cr value we are thinking of is x = i - _CENTERJSAMPLE */\n    /* Cr=>R value is nearest int to 1.40200 * x */\n    cconvert->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    /* Cb=>B value is nearest int to 1.77200 * x */\n    cconvert->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    /* Cr=>G value is scaled-up -0.71414 * x */\n    cconvert->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    /* Cb=>G value is scaled-up -0.34414 * x */\n    /* We also add in ONE_HALF so that need not do it in inner loop */\n    cconvert->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\n/*\n * Convert some rows of samples to the output colorspace.\n */\n\nMETHODDEF(void)\nycc_rgb_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  switch (cinfo->out_color_space) {\n  case JCS_EXT_RGB:\n    ycc_extrgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                num_rows);\n    break;\n  case JCS_EXT_RGBX:\n  case JCS_EXT_RGBA:\n    ycc_extrgbx_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_BGR:\n    ycc_extbgr_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                num_rows);\n    break;\n  case JCS_EXT_BGRX:\n  case JCS_EXT_BGRA:\n    ycc_extbgrx_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_XBGR:\n  case JCS_EXT_ABGR:\n    ycc_extxbgr_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_XRGB:\n  case JCS_EXT_ARGB:\n    ycc_extxrgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  default:\n    ycc_rgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                             num_rows);\n    break;\n  }\n}\n\n\n/**************** Cases other than YCbCr -> RGB **************/\n\n\n/*\n * Initialize for RGB->grayscale colorspace conversion.\n */\n\nLOCAL(void)\nbuild_rgb_y_table(j_decompress_ptr cinfo)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  JLONG *rgb_y_tab;\n  JLONG i;\n\n  /* Allocate and fill in the conversion tables. */\n  cconvert->rgb_y_tab = rgb_y_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (TABLE_SIZE * sizeof(JLONG)));\n\n  for (i = 0; i <= _MAXJSAMPLE; i++) {\n    rgb_y_tab[i + R_Y_OFF] = FIX(0.29900) * i;\n    rgb_y_tab[i + G_Y_OFF] = FIX(0.58700) * i;\n    rgb_y_tab[i + B_Y_OFF] = FIX(0.11400) * i + ONE_HALF;\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\n/*\n * Convert RGB to grayscale.\n */\n\nMETHODDEF(void)\nrgb_gray_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                 JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  register int r, g, b;\n  register JLONG *ctab = cconvert->rgb_y_tab;\n  register _JSAMPROW outptr;\n  register _JSAMPROW inptr0, inptr1, inptr2;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n\n  while (--num_rows >= 0) {\n    inptr0 = input_buf[0][input_row];\n    inptr1 = input_buf[1][input_row];\n    inptr2 = input_buf[2][input_row];\n    input_row++;\n    outptr = *output_buf++;\n    for (col = 0; col < num_cols; col++) {\n      r = inptr0[col];\n      g = inptr1[col];\n      b = inptr2[col];\n      /* Y */\n      outptr[col] = (_JSAMPLE)((ctab[r + R_Y_OFF] + ctab[g + G_Y_OFF] +\n                                ctab[b + B_Y_OFF]) >> SCALEBITS);\n    }\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\n/*\n * Color conversion for no colorspace change: just copy the data,\n * converting from separate-planes to interleaved representation.\n */\n\nMETHODDEF(void)\nnull_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n             JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  register _JSAMPROW inptr, inptr0, inptr1, inptr2, inptr3, outptr;\n  register JDIMENSION col;\n  register int num_components = cinfo->num_components;\n  JDIMENSION num_cols = cinfo->output_width;\n  int ci;\n\n  if (num_components == 3) {\n    while (--num_rows >= 0) {\n      inptr0 = input_buf[0][input_row];\n      inptr1 = input_buf[1][input_row];\n      inptr2 = input_buf[2][input_row];\n      input_row++;\n      outptr = *output_buf++;\n      for (col = 0; col < num_cols; col++) {\n        *outptr++ = inptr0[col];\n        *outptr++ = inptr1[col];\n        *outptr++ = inptr2[col];\n      }\n    }\n  } else if (num_components == 4) {\n    while (--num_rows >= 0) {\n      inptr0 = input_buf[0][input_row];\n      inptr1 = input_buf[1][input_row];\n      inptr2 = input_buf[2][input_row];\n      inptr3 = input_buf[3][input_row];\n      input_row++;\n      outptr = *output_buf++;\n      for (col = 0; col < num_cols; col++) {\n        *outptr++ = inptr0[col];\n        *outptr++ = inptr1[col];\n        *outptr++ = inptr2[col];\n        *outptr++ = inptr3[col];\n      }\n    }\n  } else {\n    while (--num_rows >= 0) {\n      for (ci = 0; ci < num_components; ci++) {\n        inptr = input_buf[ci][input_row];\n        outptr = *output_buf;\n        for (col = 0; col < num_cols; col++) {\n          outptr[ci] = inptr[col];\n          outptr += num_components;\n        }\n      }\n      output_buf++;\n      input_row++;\n    }\n  }\n}\n\n\n/*\n * Color conversion for grayscale: just copy the data.\n * This also works for YCbCr -> grayscale conversion, in which\n * we just copy the Y (luminance) component and ignore chrominance.\n */\n\nMETHODDEF(void)\ngrayscale_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                  JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  _jcopy_sample_rows(input_buf[0], (int)input_row, output_buf, 0, num_rows,\n                     cinfo->output_width);\n}\n\n\n/*\n * Convert grayscale to RGB\n */\n\nMETHODDEF(void)\ngray_rgb_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                 JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  switch (cinfo->out_color_space) {\n  case JCS_EXT_RGB:\n    gray_extrgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_RGBX:\n  case JCS_EXT_RGBA:\n    gray_extrgbx_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                  num_rows);\n    break;\n  case JCS_EXT_BGR:\n    gray_extbgr_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_BGRX:\n  case JCS_EXT_BGRA:\n    gray_extbgrx_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                  num_rows);\n    break;\n  case JCS_EXT_XBGR:\n  case JCS_EXT_ABGR:\n    gray_extxbgr_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                  num_rows);\n    break;\n  case JCS_EXT_XRGB:\n  case JCS_EXT_ARGB:\n    gray_extxrgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                  num_rows);\n    break;\n  default:\n    gray_rgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                              num_rows);\n    break;\n  }\n}\n\n\n/*\n * Convert plain RGB to extended RGB\n */\n\nMETHODDEF(void)\nrgb_rgb_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  switch (cinfo->out_color_space) {\n  case JCS_EXT_RGB:\n    rgb_extrgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                num_rows);\n    break;\n  case JCS_EXT_RGBX:\n  case JCS_EXT_RGBA:\n    rgb_extrgbx_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_BGR:\n    rgb_extbgr_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                num_rows);\n    break;\n  case JCS_EXT_BGRX:\n  case JCS_EXT_BGRA:\n    rgb_extbgrx_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_XBGR:\n  case JCS_EXT_ABGR:\n    rgb_extxbgr_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  case JCS_EXT_XRGB:\n  case JCS_EXT_ARGB:\n    rgb_extxrgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                                 num_rows);\n    break;\n  default:\n    rgb_rgb_convert_internal(cinfo, input_buf, input_row, output_buf,\n                             num_rows);\n    break;\n  }\n}\n\n\n/*\n * Adobe-style YCCK->CMYK conversion.\n * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same\n * conversion as above, while passing K (black) unchanged.\n * We assume build_ycc_rgb_table has been called.\n */\n\nMETHODDEF(void)\nycck_cmyk_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                  JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n#if BITS_IN_JSAMPLE != 16\n  my_cconvert_ptr cconvert = (my_cconvert_ptr)cinfo->cconvert;\n  register int y, cb, cr;\n  register _JSAMPROW outptr;\n  register _JSAMPROW inptr0, inptr1, inptr2, inptr3;\n  register JDIMENSION col;\n  JDIMENSION num_cols = cinfo->output_width;\n  /* copy these pointers into registers if possible */\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  register int *Crrtab = cconvert->Cr_r_tab;\n  register int *Cbbtab = cconvert->Cb_b_tab;\n  register JLONG *Crgtab = cconvert->Cr_g_tab;\n  register JLONG *Cbgtab = cconvert->Cb_g_tab;\n  SHIFT_TEMPS\n\n  while (--num_rows >= 0) {\n    inptr0 = input_buf[0][input_row];\n    inptr1 = input_buf[1][input_row];\n    inptr2 = input_buf[2][input_row];\n    inptr3 = input_buf[3][input_row];\n    input_row++;\n    outptr = *output_buf++;\n    for (col = 0; col < num_cols; col++) {\n      y  = inptr0[col];\n      cb = inptr1[col];\n      cr = inptr2[col];\n      /* Range-limiting is essential due to noise introduced by DCT losses. */\n      outptr[0] = range_limit[_MAXJSAMPLE - (y + Crrtab[cr])];  /* red */\n      outptr[1] = range_limit[_MAXJSAMPLE - (y +                /* green */\n                              ((int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n                                                 SCALEBITS)))];\n      outptr[2] = range_limit[_MAXJSAMPLE - (y + Cbbtab[cb])];  /* blue */\n      /* K passes through unchanged */\n      outptr[3] = inptr3[col];\n      outptr += 4;\n    }\n  }\n#else\n  ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n}\n\n\n/*\n * RGB565 conversion\n */\n\n#define PACK_SHORT_565_LE(r, g, b) \\\n  ((((r) << 8) & 0xF800) | (((g) << 3) & 0x7E0) | ((b) >> 3))\n#define PACK_SHORT_565_BE(r, g, b) \\\n  (((r) & 0xF8) | ((g) >> 5) | (((g) << 11) & 0xE000) | (((b) << 5) & 0x1F00))\n\n#define PACK_TWO_PIXELS_LE(l, r)    ((r << 16) | l)\n#define PACK_TWO_PIXELS_BE(l, r)    ((l << 16) | r)\n\n#define PACK_NEED_ALIGNMENT(ptr)    (((size_t)(ptr)) & 3)\n\n#define WRITE_TWO_ALIGNED_PIXELS(addr, pixels)  ((*(int *)(addr)) = pixels)\n\n#define DITHER_565_R(r, dither)  ((r) + ((dither) & 0xFF))\n#define DITHER_565_G(g, dither)  ((g) + (((dither) & 0xFF) >> 1))\n#define DITHER_565_B(b, dither)  ((b) + ((dither) & 0xFF))\n\n\n/* Declarations for ordered dithering\n *\n * We use a 4x4 ordered dither array packed into 32 bits.  This array is\n * sufficient for dithering RGB888 to RGB565.\n */\n\n#define DITHER_MASK       0x3\n#define DITHER_ROTATE(x)  ((((x) & 0xFF) << 24) | (((x) >> 8) & 0x00FFFFFF))\nstatic const JLONG dither_matrix[4] = {\n  0x0008020A,\n  0x0C040E06,\n  0x030B0109,\n  0x0F070D05\n};\n\n\nstatic INLINE boolean is_big_endian(void)\n{\n  int test_value = 1;\n  if (*(char *)&test_value != 1)\n    return TRUE;\n  return FALSE;\n}\n\n\n/* Include inline routines for RGB565 conversion */\n\n#define PACK_SHORT_565  PACK_SHORT_565_LE\n#define PACK_TWO_PIXELS  PACK_TWO_PIXELS_LE\n#define ycc_rgb565_convert_internal  ycc_rgb565_convert_le\n#define ycc_rgb565D_convert_internal  ycc_rgb565D_convert_le\n#define rgb_rgb565_convert_internal  rgb_rgb565_convert_le\n#define rgb_rgb565D_convert_internal  rgb_rgb565D_convert_le\n#define gray_rgb565_convert_internal  gray_rgb565_convert_le\n#define gray_rgb565D_convert_internal  gray_rgb565D_convert_le\n#include \"jdcol565.c\"\n#undef PACK_SHORT_565\n#undef PACK_TWO_PIXELS\n#undef ycc_rgb565_convert_internal\n#undef ycc_rgb565D_convert_internal\n#undef rgb_rgb565_convert_internal\n#undef rgb_rgb565D_convert_internal\n#undef gray_rgb565_convert_internal\n#undef gray_rgb565D_convert_internal\n\n#define PACK_SHORT_565  PACK_SHORT_565_BE\n#define PACK_TWO_PIXELS  PACK_TWO_PIXELS_BE\n#define ycc_rgb565_convert_internal  ycc_rgb565_convert_be\n#define ycc_rgb565D_convert_internal  ycc_rgb565D_convert_be\n#define rgb_rgb565_convert_internal  rgb_rgb565_convert_be\n#define rgb_rgb565D_convert_internal  rgb_rgb565D_convert_be\n#define gray_rgb565_convert_internal  gray_rgb565_convert_be\n#define gray_rgb565D_convert_internal  gray_rgb565D_convert_be\n#include \"jdcol565.c\"\n#undef PACK_SHORT_565\n#undef PACK_TWO_PIXELS\n#undef ycc_rgb565_convert_internal\n#undef ycc_rgb565D_convert_internal\n#undef rgb_rgb565_convert_internal\n#undef rgb_rgb565D_convert_internal\n#undef gray_rgb565_convert_internal\n#undef gray_rgb565D_convert_internal\n\n\nMETHODDEF(void)\nycc_rgb565_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                   JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  if (is_big_endian())\n    ycc_rgb565_convert_be(cinfo, input_buf, input_row, output_buf, num_rows);\n  else\n    ycc_rgb565_convert_le(cinfo, input_buf, input_row, output_buf, num_rows);\n}\n\n\nMETHODDEF(void)\nycc_rgb565D_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                    JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  if (is_big_endian())\n    ycc_rgb565D_convert_be(cinfo, input_buf, input_row, output_buf, num_rows);\n  else\n    ycc_rgb565D_convert_le(cinfo, input_buf, input_row, output_buf, num_rows);\n}\n\n\nMETHODDEF(void)\nrgb_rgb565_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                   JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  if (is_big_endian())\n    rgb_rgb565_convert_be(cinfo, input_buf, input_row, output_buf, num_rows);\n  else\n    rgb_rgb565_convert_le(cinfo, input_buf, input_row, output_buf, num_rows);\n}\n\n\nMETHODDEF(void)\nrgb_rgb565D_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                    JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  if (is_big_endian())\n    rgb_rgb565D_convert_be(cinfo, input_buf, input_row, output_buf, num_rows);\n  else\n    rgb_rgb565D_convert_le(cinfo, input_buf, input_row, output_buf, num_rows);\n}\n\n\nMETHODDEF(void)\ngray_rgb565_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                    JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  if (is_big_endian())\n    gray_rgb565_convert_be(cinfo, input_buf, input_row, output_buf, num_rows);\n  else\n    gray_rgb565_convert_le(cinfo, input_buf, input_row, output_buf, num_rows);\n}\n\n\nMETHODDEF(void)\ngray_rgb565D_convert(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                     JDIMENSION input_row, _JSAMPARRAY output_buf, int num_rows)\n{\n  if (is_big_endian())\n    gray_rgb565D_convert_be(cinfo, input_buf, input_row, output_buf, num_rows);\n  else\n    gray_rgb565D_convert_le(cinfo, input_buf, input_row, output_buf, num_rows);\n}\n\n\n/*\n * Empty method for start_pass.\n */\n\nMETHODDEF(void)\nstart_pass_dcolor(j_decompress_ptr cinfo)\n{\n  /* no work needed */\n}\n\n\n/*\n * Module initialization routine for output colorspace conversion.\n */\n\nGLOBAL(void)\n_jinit_color_deconverter(j_decompress_ptr cinfo)\n{\n  my_cconvert_ptr cconvert;\n  int ci;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  cconvert = (my_cconvert_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_color_deconverter));\n  cinfo->cconvert = (struct jpeg_color_deconverter *)cconvert;\n  cconvert->pub.start_pass = start_pass_dcolor;\n\n  /* Make sure num_components agrees with jpeg_color_space */\n  switch (cinfo->jpeg_color_space) {\n  case JCS_GRAYSCALE:\n    if (cinfo->num_components != 1)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    break;\n\n  case JCS_RGB:\n  case JCS_YCbCr:\n    if (cinfo->num_components != 3)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    break;\n\n  case JCS_CMYK:\n  case JCS_YCCK:\n    if (cinfo->num_components != 4)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    break;\n\n  default:                      /* JCS_UNKNOWN can be anything */\n    if (cinfo->num_components < 1)\n      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);\n    break;\n  }\n\n  /* Set out_color_components and conversion method based on requested space.\n   * Also clear the component_needed flags for any unused components,\n   * so that earlier pipeline stages can avoid useless computation.\n   * NOTE: We do not allow any lossy color conversion algorithms in lossless\n   * mode.\n   */\n\n  switch (cinfo->out_color_space) {\n  case JCS_GRAYSCALE:\n#ifdef D_LOSSLESS_SUPPORTED\n    if (cinfo->master->lossless &&\n        cinfo->jpeg_color_space != cinfo->out_color_space)\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n    cinfo->out_color_components = 1;\n    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||\n        cinfo->jpeg_color_space == JCS_YCbCr) {\n      cconvert->pub._color_convert = grayscale_convert;\n      /* For color->grayscale conversion, only the Y (0) component is needed */\n      for (ci = 1; ci < cinfo->num_components; ci++)\n        cinfo->comp_info[ci].component_needed = FALSE;\n    } else if (cinfo->jpeg_color_space == JCS_RGB) {\n      cconvert->pub._color_convert = rgb_gray_convert;\n      build_rgb_y_table(cinfo);\n    } else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  case JCS_RGB:\n  case JCS_EXT_RGB:\n  case JCS_EXT_RGBX:\n  case JCS_EXT_BGR:\n  case JCS_EXT_BGRX:\n  case JCS_EXT_XBGR:\n  case JCS_EXT_XRGB:\n  case JCS_EXT_RGBA:\n  case JCS_EXT_BGRA:\n  case JCS_EXT_ABGR:\n  case JCS_EXT_ARGB:\n#ifdef D_LOSSLESS_SUPPORTED\n    if (cinfo->master->lossless && cinfo->jpeg_color_space != JCS_RGB)\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n    cinfo->out_color_components = rgb_pixelsize[cinfo->out_color_space];\n    if (cinfo->jpeg_color_space == JCS_YCbCr) {\n#ifdef WITH_SIMD\n      if (jsimd_can_ycc_rgb())\n        cconvert->pub._color_convert = jsimd_ycc_rgb_convert;\n      else\n#endif\n      {\n        cconvert->pub._color_convert = ycc_rgb_convert;\n        build_ycc_rgb_table(cinfo);\n      }\n    } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {\n      cconvert->pub._color_convert = gray_rgb_convert;\n    } else if (cinfo->jpeg_color_space == JCS_RGB) {\n      if (rgb_red[cinfo->out_color_space] == 0 &&\n          rgb_green[cinfo->out_color_space] == 1 &&\n          rgb_blue[cinfo->out_color_space] == 2 &&\n          rgb_pixelsize[cinfo->out_color_space] == 3)\n        cconvert->pub._color_convert = null_convert;\n      else\n        cconvert->pub._color_convert = rgb_rgb_convert;\n    } else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  case JCS_RGB565:\n#ifdef D_LOSSLESS_SUPPORTED\n    if (cinfo->master->lossless)\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n    cinfo->out_color_components = 3;\n    if (cinfo->dither_mode == JDITHER_NONE) {\n      if (cinfo->jpeg_color_space == JCS_YCbCr) {\n#ifdef WITH_SIMD\n        if (jsimd_can_ycc_rgb565())\n          cconvert->pub._color_convert = jsimd_ycc_rgb565_convert;\n        else\n#endif\n        {\n          cconvert->pub._color_convert = ycc_rgb565_convert;\n          build_ycc_rgb_table(cinfo);\n        }\n      } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {\n        cconvert->pub._color_convert = gray_rgb565_convert;\n      } else if (cinfo->jpeg_color_space == JCS_RGB) {\n        cconvert->pub._color_convert = rgb_rgb565_convert;\n      } else\n        ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    } else {\n      /* only ordered dithering is supported */\n      if (cinfo->jpeg_color_space == JCS_YCbCr) {\n        cconvert->pub._color_convert = ycc_rgb565D_convert;\n        build_ycc_rgb_table(cinfo);\n      } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {\n        cconvert->pub._color_convert = gray_rgb565D_convert;\n      } else if (cinfo->jpeg_color_space == JCS_RGB) {\n        cconvert->pub._color_convert = rgb_rgb565D_convert;\n      } else\n        ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    }\n    break;\n\n  case JCS_CMYK:\n#ifdef D_LOSSLESS_SUPPORTED\n    if (cinfo->master->lossless &&\n        cinfo->jpeg_color_space != cinfo->out_color_space)\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n#endif\n    cinfo->out_color_components = 4;\n    if (cinfo->jpeg_color_space == JCS_YCCK) {\n      cconvert->pub._color_convert = ycck_cmyk_convert;\n      build_ycc_rgb_table(cinfo);\n    } else if (cinfo->jpeg_color_space == JCS_CMYK) {\n      cconvert->pub._color_convert = null_convert;\n    } else\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n\n  default:\n    /* Permit null conversion to same output space */\n    if (cinfo->out_color_space == cinfo->jpeg_color_space) {\n      cinfo->out_color_components = cinfo->num_components;\n      cconvert->pub._color_convert = null_convert;\n    } else                      /* unsupported non-null conversion */\n      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);\n    break;\n  }\n\n  if (cinfo->quantize_colors)\n    cinfo->output_components = 1; /* single colormapped output component */\n  else\n    cinfo->output_components = cinfo->out_color_components;\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED) */\n"
        },
        {
          "name": "jdct.h",
          "type": "blob",
          "size": 9.8974609375,
          "content": "/*\n * jdct.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This include file contains common declarations for the forward and\n * inverse DCT modules.  These declarations are private to the DCT managers\n * (jcdctmgr.c, jddctmgr.c) and the individual DCT algorithms.\n * The individual DCT algorithms are kept in separate files to ease\n * machine-dependent tuning (e.g., assembly coding).\n */\n\n#include \"jsamplecomp.h\"\n\n\n/*\n * A forward DCT routine is given a pointer to a work area of type DCTELEM[];\n * the DCT is to be performed in-place in that buffer.  Type DCTELEM is int\n * for 8-bit samples, JLONG for 12-bit samples.  (NOTE: Floating-point DCT\n * implementations use an array of type FAST_FLOAT, instead.)\n * The DCT inputs are expected to be signed (range +-_CENTERJSAMPLE).\n * The DCT outputs are returned scaled up by a factor of 8; they therefore\n * have a range of +-8K for 8-bit data, +-128K for 12-bit data.  This\n * convention improves accuracy in integer implementations and saves some\n * work in floating-point ones.\n * Quantization of the output coefficients is done by jcdctmgr.c. This\n * step requires an unsigned type and also one with twice the bits.\n */\n\n#if BITS_IN_JSAMPLE == 8\n#ifndef WITH_SIMD\ntypedef int DCTELEM;            /* 16 or 32 bits is fine */\ntypedef unsigned int UDCTELEM;\ntypedef unsigned long long UDCTELEM2;\n#else\ntypedef short DCTELEM;          /* prefer 16 bit with SIMD for parellelism */\ntypedef unsigned short UDCTELEM;\ntypedef unsigned int UDCTELEM2;\n#endif\n#else\ntypedef JLONG DCTELEM;          /* must have 32 bits */\ntypedef unsigned long long UDCTELEM2;\n#endif\n\n\n/*\n * An inverse DCT routine is given a pointer to the input JBLOCK and a pointer\n * to an output sample array.  The routine must dequantize the input data as\n * well as perform the IDCT; for dequantization, it uses the multiplier table\n * pointed to by compptr->dct_table.  The output data is to be placed into the\n * sample array starting at a specified column.  (Any row offset needed will\n * be applied to the array pointer before it is passed to the IDCT code.)\n * Note that the number of samples emitted by the IDCT routine is\n * DCT_scaled_size * DCT_scaled_size.\n */\n\n/* typedef inverse_DCT_method_ptr is declared in jpegint.h */\n\n/*\n * Each IDCT routine has its own ideas about the best dct_table element type.\n */\n\ntypedef MULTIPLIER ISLOW_MULT_TYPE;  /* short or int, whichever is faster */\n#if BITS_IN_JSAMPLE == 8\ntypedef MULTIPLIER IFAST_MULT_TYPE;  /* 16 bits is OK, use short if faster */\n#define IFAST_SCALE_BITS  2          /* fractional bits in scale factors */\n#else\ntypedef JLONG IFAST_MULT_TYPE;       /* need 32 bits for scaled quantizers */\n#define IFAST_SCALE_BITS  13         /* fractional bits in scale factors */\n#endif\ntypedef FAST_FLOAT FLOAT_MULT_TYPE;  /* preferred floating type */\n\n\n/*\n * Each IDCT routine is responsible for range-limiting its results and\n * converting them to unsigned form (0.._MAXJSAMPLE).  The raw outputs could\n * be quite far out of range if the input data is corrupt, so a bulletproof\n * range-limiting step is required.  We use a mask-and-table-lookup method\n * to do the combined operations quickly.  See the comments with\n * prepare_range_limit_table (in jdmaster.c) for more info.\n */\n\n#define IDCT_range_limit(cinfo) \\\n  ((_JSAMPLE *)((cinfo)->sample_range_limit) + _CENTERJSAMPLE)\n\n#define RANGE_MASK  (_MAXJSAMPLE * 4 + 3) /* 2 bits wider than legal samples */\n\n\n/* Extern declarations for the forward and inverse DCT routines. */\n\nEXTERN(void) _jpeg_fdct_islow(DCTELEM *data);\nEXTERN(void) _jpeg_fdct_ifast(DCTELEM *data);\nEXTERN(void) jpeg_fdct_float(FAST_FLOAT *data);\n\nEXTERN(void) _jpeg_idct_islow(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_ifast(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_float(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_7x7(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            _JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_6x6(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            _JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_5x5(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            _JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_4x4(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            _JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_3x3(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            _JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_2x2(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            _JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_1x1(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            _JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_9x9(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            _JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_10x10(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_11x11(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_12x12(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_13x13(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_14x14(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_15x15(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) _jpeg_idct_16x16(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\n\n\n/*\n * Macros for handling fixed-point arithmetic; these are used by many\n * but not all of the DCT/IDCT modules.\n *\n * All values are expected to be of type JLONG.\n * Fractional constants are scaled left by CONST_BITS bits.\n * CONST_BITS is defined within each module using these macros,\n * and may differ from one module to the next.\n */\n\n#define ONE          ((JLONG)1)\n#define CONST_SCALE  (ONE << CONST_BITS)\n\n/* Convert a positive real constant to an integer scaled by CONST_SCALE.\n * Caution: some C compilers fail to reduce \"FIX(constant)\" at compile time,\n * thus causing a lot of useless floating-point operations at run time.\n */\n\n#define FIX(x)  ((JLONG)((x) * CONST_SCALE + 0.5))\n\n/* Descale and correctly round a JLONG value that's scaled by N bits.\n * We assume RIGHT_SHIFT rounds towards minus infinity, so adding\n * the fudge factor is correct for either sign of X.\n */\n\n#define DESCALE(x, n)  RIGHT_SHIFT((x) + (ONE << ((n) - 1)), n)\n\n/* Multiply a JLONG variable by a JLONG constant to yield a JLONG result.\n * This macro is used only when the two inputs will actually be no more than\n * 16 bits wide, so that a 16x16->32 bit multiply can be used instead of a\n * full 32x32 multiply.  This provides a useful speedup on many machines.\n * Unfortunately there is no way to specify a 16x16->32 multiply portably\n * in C, but some C compilers will do the right thing if you provide the\n * correct combination of casts.\n */\n\n#ifdef SHORTxSHORT_32           /* may work if 'int' is 32 bits */\n#define MULTIPLY16C16(var, const)  (((INT16)(var)) * ((INT16)(const)))\n#endif\n#ifdef SHORTxLCONST_32          /* known to work with Microsoft C 6.0 */\n#define MULTIPLY16C16(var, const)  (((INT16)(var)) * ((JLONG)(const)))\n#endif\n\n#ifndef MULTIPLY16C16           /* default definition */\n#define MULTIPLY16C16(var, const)  ((var) * (const))\n#endif\n\n/* Same except both inputs are variables. */\n\n#ifdef SHORTxSHORT_32           /* may work if 'int' is 32 bits */\n#define MULTIPLY16V16(var1, var2)  (((INT16)(var1)) * ((INT16)(var2)))\n#endif\n\n#ifndef MULTIPLY16V16           /* default definition */\n#define MULTIPLY16V16(var1, var2)  ((var1) * (var2))\n#endif\n"
        },
        {
          "name": "jddctmgr.c",
          "type": "blob",
          "size": 11.9912109375,
          "content": "/*\n * jddctmgr.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * Modified 2002-2010 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2010, 2015, 2022, D. R. Commander.\n * Copyright (C) 2013, MIPS Technologies, Inc., California.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the inverse-DCT management logic.\n * This code selects a particular IDCT implementation to be used,\n * and it performs related housekeeping chores.  No code in this file\n * is executed per IDCT step, only during output pass setup.\n *\n * Note that the IDCT routines are responsible for performing coefficient\n * dequantization as well as the IDCT proper.  This module sets up the\n * dequantization multiplier table needed by the IDCT routine.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdct.h\"               /* Private declarations for DCT subsystem */\n#include \"jsimddct.h\"\n#include \"jpegapicomp.h\"\n#include \"jdmaster.h\"\n\n\n/*\n * The decompressor input side (jdinput.c) saves away the appropriate\n * quantization table for each component at the start of the first scan\n * involving that component.  (This is necessary in order to correctly\n * decode files that reuse Q-table slots.)\n * When we are ready to make an output pass, the saved Q-table is converted\n * to a multiplier table that will actually be used by the IDCT routine.\n * The multiplier table contents are IDCT-method-dependent.  To support\n * application changes in IDCT method between scans, we can remake the\n * multiplier tables if necessary.\n * In buffered-image mode, the first output pass may occur before any data\n * has been seen for some components, and thus before their Q-tables have\n * been saved away.  To handle this case, multiplier tables are preset\n * to zeroes; the result of the IDCT will be a neutral gray level.\n */\n\n\n/* Private subobject for this module */\n\ntypedef struct {\n  struct jpeg_inverse_dct pub;  /* public fields */\n\n  /* This array contains the IDCT method code that each multiplier table\n   * is currently set up for, or -1 if it's not yet set up.\n   * The actual multiplier tables are pointed to by dct_table in the\n   * per-component comp_info structures.\n   */\n  int cur_method[MAX_COMPONENTS];\n} my_idct_controller;\n\ntypedef my_idct_controller *my_idct_ptr;\n\n\n/* Allocated multiplier tables: big enough for any supported variant */\n\ntypedef union {\n  ISLOW_MULT_TYPE islow_array[DCTSIZE2];\n#ifdef DCT_IFAST_SUPPORTED\n  IFAST_MULT_TYPE ifast_array[DCTSIZE2];\n#endif\n#ifdef DCT_FLOAT_SUPPORTED\n  FLOAT_MULT_TYPE float_array[DCTSIZE2];\n#endif\n} multiplier_table;\n\n\n/* The current scaled-IDCT routines require ISLOW-style multiplier tables,\n * so be sure to compile that code if either ISLOW or SCALING is requested.\n */\n#ifdef DCT_ISLOW_SUPPORTED\n#define PROVIDE_ISLOW_TABLES\n#else\n#ifdef IDCT_SCALING_SUPPORTED\n#define PROVIDE_ISLOW_TABLES\n#endif\n#endif\n\n#if BITS_IN_JSAMPLE == 8\nEXTERN(void) jpeg_set_idct_method_selector (j_decompress_ptr cinfo, jpeg_idct_method_selector selector){\n  my_master_ptr master = (my_master_ptr) cinfo->master;\n  master->custom_idct_selector = selector;\n}\n#endif\n\n/*\n * Prepare for an output pass.\n * Here we select the proper IDCT routine for each component and build\n * a matching multiplier table.\n */\n\nMETHODDEF(void)\nstart_pass(j_decompress_ptr cinfo)\n{\n  my_idct_ptr idct = (my_idct_ptr)cinfo->idct;\n  int ci, i;\n  jpeg_component_info *compptr;\n  int method = 0;\n  _inverse_DCT_method_ptr method_ptr = NULL;\n  JQUANT_TBL *qtbl;\n  my_master_ptr master;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Select the proper IDCT routine for this component's scaling */\n    switch (compptr->_DCT_scaled_size) {\n#ifdef IDCT_SCALING_SUPPORTED\n    case 1:\n      method_ptr = _jpeg_idct_1x1;\n      method = JDCT_ISLOW;      /* jidctred uses islow-style table */\n      break;\n    case 2:\n#ifdef WITH_SIMD\n      if (jsimd_can_idct_2x2())\n        method_ptr = jsimd_idct_2x2;\n      else\n#endif\n        method_ptr = _jpeg_idct_2x2;\n      method = JDCT_ISLOW;      /* jidctred uses islow-style table */\n      break;\n    case 3:\n      method_ptr = _jpeg_idct_3x3;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n    case 4:\n#ifdef WITH_SIMD\n      if (jsimd_can_idct_4x4())\n        method_ptr = jsimd_idct_4x4;\n      else\n#endif\n        method_ptr = _jpeg_idct_4x4;\n      method = JDCT_ISLOW;      /* jidctred uses islow-style table */\n      break;\n    case 5:\n      method_ptr = _jpeg_idct_5x5;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n    case 6:\n#if defined(WITH_SIMD) && defined(__mips__)\n      if (jsimd_can_idct_6x6())\n        method_ptr = jsimd_idct_6x6;\n      else\n#endif\n      method_ptr = _jpeg_idct_6x6;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n    case 7:\n      method_ptr = _jpeg_idct_7x7;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n#endif\n    case DCTSIZE:\n      switch (cinfo->dct_method) {\n#ifdef DCT_ISLOW_SUPPORTED\n      case JDCT_ISLOW:\n#ifdef WITH_SIMD\n        if (jsimd_can_idct_islow())\n          method_ptr = jsimd_idct_islow;\n        else\n#endif\n          method_ptr = _jpeg_idct_islow;\n        method = JDCT_ISLOW;\n        break;\n#endif\n#ifdef DCT_IFAST_SUPPORTED\n      case JDCT_IFAST:\n#ifdef WITH_SIMD\n        if (jsimd_can_idct_ifast())\n          method_ptr = jsimd_idct_ifast;\n        else\n#endif\n          method_ptr = _jpeg_idct_ifast;\n        method = JDCT_IFAST;\n        break;\n#endif\n#ifdef DCT_FLOAT_SUPPORTED\n      case JDCT_FLOAT:\n#ifdef WITH_SIMD\n        if (jsimd_can_idct_float())\n          method_ptr = jsimd_idct_float;\n        else\n#endif\n          method_ptr = _jpeg_idct_float;\n        method = JDCT_FLOAT;\n        break;\n#endif\n      default:\n        ERREXIT(cinfo, JERR_NOT_COMPILED);\n        break;\n      }\n      break;\n#ifdef IDCT_SCALING_SUPPORTED\n    case 9:\n      method_ptr = _jpeg_idct_9x9;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n    case 10:\n      method_ptr = _jpeg_idct_10x10;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n    case 11:\n      method_ptr = _jpeg_idct_11x11;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n    case 12:\n#if defined(WITH_SIMD) && defined(__mips__)\n      if (jsimd_can_idct_12x12())\n        method_ptr = jsimd_idct_12x12;\n      else\n#endif\n      method_ptr = _jpeg_idct_12x12;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n    case 13:\n      method_ptr = _jpeg_idct_13x13;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n    case 14:\n      method_ptr = _jpeg_idct_14x14;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n    case 15:\n      method_ptr = _jpeg_idct_15x15;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n    case 16:\n      method_ptr = _jpeg_idct_16x16;\n      method = JDCT_ISLOW;      /* jidctint uses islow-style table */\n      break;\n#endif\n    default:\n      ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->_DCT_scaled_size);\n      break;\n    }\n\n    // Allow custom idct function to be set dynamically\n    master = (my_master_ptr) cinfo->master;\n\n    #if BITS_IN_JSAMPLE == 8\n    if (master->custom_idct_selector != NULL) {\n      master->custom_idct_selector(cinfo, compptr, &method_ptr, &method);\n    }\n    #endif\n\n    idct->pub._inverse_DCT[ci] = method_ptr;\n    /* Create multiplier table from quant table.\n     * However, we can skip this if the component is uninteresting\n     * or if we already built the table.  Also, if no quant table\n     * has yet been saved for the component, we leave the\n     * multiplier table all-zero; we'll be reading zeroes from the\n     * coefficient controller's buffer anyway.\n     */\n    if (!compptr->component_needed || idct->cur_method[ci] == method)\n      continue;\n    qtbl = compptr->quant_table;\n    if (qtbl == NULL)           /* happens if no data yet for component */\n      continue;\n    idct->cur_method[ci] = method;\n    switch (method) {\n#ifdef PROVIDE_ISLOW_TABLES\n    case JDCT_ISLOW:\n      {\n        /* For LL&M IDCT method, multipliers are equal to raw quantization\n         * coefficients, but are stored as ints to ensure access efficiency.\n         */\n        ISLOW_MULT_TYPE *ismtbl = (ISLOW_MULT_TYPE *)compptr->dct_table;\n        for (i = 0; i < DCTSIZE2; i++) {\n          ismtbl[i] = (ISLOW_MULT_TYPE)qtbl->quantval[i];\n        }\n      }\n      break;\n#endif\n#ifdef DCT_IFAST_SUPPORTED\n    case JDCT_IFAST:\n      {\n        /* For AA&N IDCT method, multipliers are equal to quantization\n         * coefficients scaled by scalefactor[row]*scalefactor[col], where\n         *   scalefactor[0] = 1\n         *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7\n         * For integer operation, the multiplier table is to be scaled by\n         * IFAST_SCALE_BITS.\n         */\n        IFAST_MULT_TYPE *ifmtbl = (IFAST_MULT_TYPE *)compptr->dct_table;\n#define CONST_BITS  14\n        static const INT16 aanscales[DCTSIZE2] = {\n          /* precomputed values scaled up by 14 bits */\n          16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,\n          22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,\n          21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,\n          19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,\n          16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,\n          12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,\n           8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,\n           4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247\n        };\n        SHIFT_TEMPS\n\n        for (i = 0; i < DCTSIZE2; i++) {\n          ifmtbl[i] = (IFAST_MULT_TYPE)\n            DESCALE(MULTIPLY16V16((JLONG)qtbl->quantval[i],\n                                  (JLONG)aanscales[i]),\n                    CONST_BITS - IFAST_SCALE_BITS);\n        }\n      }\n      break;\n#endif\n#ifdef DCT_FLOAT_SUPPORTED\n    case JDCT_FLOAT:\n      {\n        /* For float AA&N IDCT method, multipliers are equal to quantization\n         * coefficients scaled by scalefactor[row]*scalefactor[col], where\n         *   scalefactor[0] = 1\n         *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7\n         */\n        FLOAT_MULT_TYPE *fmtbl = (FLOAT_MULT_TYPE *)compptr->dct_table;\n        int row, col;\n        static const double aanscalefactor[DCTSIZE] = {\n          1.0, 1.387039845, 1.306562965, 1.175875602,\n          1.0, 0.785694958, 0.541196100, 0.275899379\n        };\n\n        i = 0;\n        for (row = 0; row < DCTSIZE; row++) {\n          for (col = 0; col < DCTSIZE; col++) {\n            fmtbl[i] = (FLOAT_MULT_TYPE)\n              ((double)qtbl->quantval[i] *\n               aanscalefactor[row] * aanscalefactor[col]);\n            i++;\n          }\n        }\n      }\n      break;\n#endif\n    default:\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n      break;\n    }\n  }\n}\n\n\n/*\n * Initialize IDCT manager.\n */\n\nGLOBAL(void)\n_jinit_inverse_dct(j_decompress_ptr cinfo)\n{\n  my_idct_ptr idct;\n  int ci;\n  jpeg_component_info *compptr;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  idct = (my_idct_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_idct_controller));\n  cinfo->idct = (struct jpeg_inverse_dct *)idct;\n  idct->pub.start_pass = start_pass;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Allocate and pre-zero a multiplier table for each component */\n    compptr->dct_table =\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  sizeof(multiplier_table));\n    memset(compptr->dct_table, 0, sizeof(multiplier_table));\n    /* Mark multiplier table not yet set up for any method */\n    idct->cur_method[ci] = -1;\n  }\n}\n"
        },
        {
          "name": "jddiffct.c",
          "type": "blob",
          "size": 13.08203125,
          "content": "/*\n * jddiffct.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the [un]difference buffer controller for decompression.\n * This controller is the top level of the lossless JPEG decompressor proper.\n * The difference buffer lies between the entropy decoding and\n * prediction/undifferencing steps.  The undifference buffer lies between the\n * prediction/undifferencing and scaling steps.\n *\n * In buffered-image mode, this controller is the interface between\n * input-oriented processing and output-oriented processing.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jlossls.h\"            /* Private declarations for lossless codec */\n\n\n#ifdef D_LOSSLESS_SUPPORTED\n\n/* Private buffer controller object */\n\ntypedef struct {\n  struct jpeg_d_coef_controller pub; /* public fields */\n\n  /* These variables keep track of the current location of the input side. */\n  /* cinfo->input_iMCU_row is also used for this. */\n  JDIMENSION MCU_ctr;           /* counts MCUs processed in current row */\n  unsigned int restart_rows_to_go;      /* MCU rows left in this restart\n                                           interval */\n  unsigned int MCU_vert_offset;         /* counts MCU rows within iMCU row */\n  unsigned int MCU_rows_per_iMCU_row;   /* number of such rows needed */\n\n  /* The output side's location is represented by cinfo->output_iMCU_row. */\n\n  JDIFFARRAY diff_buf[MAX_COMPONENTS];  /* iMCU row of differences */\n  JDIFFARRAY undiff_buf[MAX_COMPONENTS]; /* iMCU row of undiff'd samples */\n\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n  /* In multi-pass modes, we need a virtual sample array for each component. */\n  jvirt_sarray_ptr whole_image[MAX_COMPONENTS];\n#endif\n} my_diff_controller;\n\ntypedef my_diff_controller *my_diff_ptr;\n\n/* Forward declarations */\nMETHODDEF(int) decompress_data(j_decompress_ptr cinfo, _JSAMPIMAGE output_buf);\n#ifdef D_MULTISCAN_FILES_SUPPORTED\nMETHODDEF(int) output_data(j_decompress_ptr cinfo, _JSAMPIMAGE output_buf);\n#endif\n\n\nLOCAL(void)\nstart_iMCU_row(j_decompress_ptr cinfo)\n/* Reset within-iMCU-row counters for a new row (input side) */\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n\n  /* In an interleaved scan, an MCU row is the same as an iMCU row.\n   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.\n   * But at the bottom of the image, process only what's left.\n   */\n  if (cinfo->comps_in_scan > 1) {\n    diff->MCU_rows_per_iMCU_row = 1;\n  } else {\n    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))\n      diff->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;\n    else\n      diff->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;\n  }\n\n  diff->MCU_ctr = 0;\n  diff->MCU_vert_offset = 0;\n}\n\n\n/*\n * Initialize for an input processing pass.\n */\n\nMETHODDEF(void)\nstart_input_pass(j_decompress_ptr cinfo)\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n\n  /* Because it is hitching a ride on the jpeg_inverse_dct struct,\n   * start_pass_lossless() will be called at the start of the output pass.\n   * This ensures that it will be called at the start of the input pass as\n   * well.\n   */\n  (*cinfo->idct->start_pass) (cinfo);\n\n  /* Check that the restart interval is an integer multiple of the number\n   * of MCUs in an MCU row.\n   */\n  if (cinfo->restart_interval % cinfo->MCUs_per_row != 0)\n    ERREXIT2(cinfo, JERR_BAD_RESTART,\n             cinfo->restart_interval, cinfo->MCUs_per_row);\n\n  /* Initialize restart counter */\n  diff->restart_rows_to_go = cinfo->restart_interval / cinfo->MCUs_per_row;\n\n  cinfo->input_iMCU_row = 0;\n  start_iMCU_row(cinfo);\n}\n\n\n/*\n * Check for a restart marker & resynchronize decoder, undifferencer.\n * Returns FALSE if must suspend.\n */\n\nMETHODDEF(boolean)\nprocess_restart(j_decompress_ptr cinfo)\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n\n  if (!(*cinfo->entropy->process_restart) (cinfo))\n    return FALSE;\n\n  (*cinfo->idct->start_pass) (cinfo);\n\n  /* Reset restart counter */\n  diff->restart_rows_to_go = cinfo->restart_interval / cinfo->MCUs_per_row;\n\n  return TRUE;\n}\n\n\n/*\n * Initialize for an output processing pass.\n */\n\nMETHODDEF(void)\nstart_output_pass(j_decompress_ptr cinfo)\n{\n  cinfo->output_iMCU_row = 0;\n}\n\n\n/*\n * Decompress and return some data in the supplied buffer.\n * Always attempts to emit one fully interleaved MCU row (\"iMCU\" row).\n * Input and output must run in lockstep since we have only a one-MCU buffer.\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n *\n * NB: output_buf contains a plane for each component in image,\n * which we index according to the component's SOF position.\n */\n\nMETHODDEF(int)\ndecompress_data(j_decompress_ptr cinfo, _JSAMPIMAGE output_buf)\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n  lossless_decomp_ptr losslessd = (lossless_decomp_ptr)cinfo->idct;\n  JDIMENSION MCU_col_num;       /* index of current MCU within row */\n  JDIMENSION MCU_count;         /* number of MCUs decoded */\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  int ci, compi, row, prev_row;\n  unsigned int yoffset;\n  jpeg_component_info *compptr;\n\n  /* Loop to process as much as one whole iMCU row */\n  for (yoffset = diff->MCU_vert_offset; yoffset < diff->MCU_rows_per_iMCU_row;\n       yoffset++) {\n\n    /* Process restart marker if needed; may have to suspend */\n    if (cinfo->restart_interval) {\n      if (diff->restart_rows_to_go == 0)\n        if (!process_restart(cinfo))\n          return JPEG_SUSPENDED;\n    }\n\n    MCU_col_num = diff->MCU_ctr;\n    /* Try to fetch an MCU row (or remaining portion of suspended MCU row). */\n    MCU_count =\n      (*cinfo->entropy->decode_mcus) (cinfo,\n                                      diff->diff_buf, yoffset, MCU_col_num,\n                                      cinfo->MCUs_per_row - MCU_col_num);\n    if (MCU_count != cinfo->MCUs_per_row - MCU_col_num) {\n      /* Suspension forced; update state counters and exit */\n      diff->MCU_vert_offset = yoffset;\n      diff->MCU_ctr += MCU_count;\n      return JPEG_SUSPENDED;\n    }\n\n    /* Account for restart interval (no-op if not using restarts) */\n    if (cinfo->restart_interval)\n      diff->restart_rows_to_go--;\n\n    /* Completed an MCU row, but perhaps not an iMCU row */\n    diff->MCU_ctr = 0;\n  }\n\n  /*\n   * Undifference and scale each scanline of the disassembled MCU row\n   * separately.  We do not process dummy samples at the end of a scanline\n   * or dummy rows at the end of the image.\n   */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    compi = compptr->component_index;\n    for (row = 0, prev_row = compptr->v_samp_factor - 1;\n         row < (cinfo->input_iMCU_row == last_iMCU_row ?\n                compptr->last_row_height : compptr->v_samp_factor);\n         prev_row = row, row++) {\n      (*losslessd->predict_undifference[compi])\n        (cinfo, compi, diff->diff_buf[compi][row],\n          diff->undiff_buf[compi][prev_row], diff->undiff_buf[compi][row],\n          compptr->width_in_blocks);\n      (*losslessd->scaler_scale) (cinfo, diff->undiff_buf[compi][row],\n                                  output_buf[compi][row],\n                                  compptr->width_in_blocks);\n    }\n  }\n\n  /* Completed the iMCU row, advance counters for next one.\n   *\n   * NB: output_data will increment output_iMCU_row.\n   * This counter is not needed for the single-pass case\n   * or the input side of the multi-pass case.\n   */\n  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {\n    start_iMCU_row(cinfo);\n    return JPEG_ROW_COMPLETED;\n  }\n  /* Completed the scan */\n  (*cinfo->inputctl->finish_input_pass) (cinfo);\n  return JPEG_SCAN_COMPLETED;\n}\n\n\n/*\n * Dummy consume-input routine for single-pass operation.\n */\n\nMETHODDEF(int)\ndummy_consume_data(j_decompress_ptr cinfo)\n{\n  return JPEG_SUSPENDED;        /* Always indicate nothing was done */\n}\n\n\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n\n/*\n * Consume input data and store it in the full-image sample buffer.\n * We read as much as one fully interleaved MCU row (\"iMCU\" row) per call,\n * ie, v_samp_factor rows for each component in the scan.\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n */\n\nMETHODDEF(int)\nconsume_data(j_decompress_ptr cinfo)\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n  int ci, compi;\n  _JSAMPARRAY buffer[MAX_COMPS_IN_SCAN];\n  jpeg_component_info *compptr;\n\n  /* Align the virtual buffers for the components used in this scan. */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    compi = compptr->component_index;\n    buffer[compi] = (_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, diff->whole_image[compi],\n       cinfo->input_iMCU_row * compptr->v_samp_factor,\n       (JDIMENSION)compptr->v_samp_factor, TRUE);\n  }\n\n  return decompress_data(cinfo, buffer);\n}\n\n\n/*\n * Output some data from the full-image sample buffer in the multi-pass case.\n * Always attempts to emit one fully interleaved MCU row (\"iMCU\" row).\n * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.\n *\n * NB: output_buf contains a plane for each component in image.\n */\n\nMETHODDEF(int)\noutput_data(j_decompress_ptr cinfo, _JSAMPIMAGE output_buf)\n{\n  my_diff_ptr diff = (my_diff_ptr)cinfo->coef;\n  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;\n  int ci, samp_rows, row;\n  _JSAMPARRAY buffer;\n  jpeg_component_info *compptr;\n\n  /* Force some input to be done if we are getting ahead of the input. */\n  while (cinfo->input_scan_number < cinfo->output_scan_number ||\n         (cinfo->input_scan_number == cinfo->output_scan_number &&\n          cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {\n    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)\n      return JPEG_SUSPENDED;\n  }\n\n  /* OK, output from the virtual arrays. */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Align the virtual buffer for this component. */\n    buffer = (_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, diff->whole_image[ci],\n       cinfo->output_iMCU_row * compptr->v_samp_factor,\n       (JDIMENSION)compptr->v_samp_factor, FALSE);\n\n    if (cinfo->output_iMCU_row < last_iMCU_row)\n      samp_rows = compptr->v_samp_factor;\n    else {\n      /* NB: can't use last_row_height here; it is input-side-dependent! */\n      samp_rows = (int)(compptr->height_in_blocks % compptr->v_samp_factor);\n      if (samp_rows == 0) samp_rows = compptr->v_samp_factor;\n    }\n\n    for (row = 0; row < samp_rows; row++) {\n      memcpy(output_buf[ci][row], buffer[row],\n             compptr->width_in_blocks * sizeof(_JSAMPLE));\n    }\n  }\n\n  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)\n    return JPEG_ROW_COMPLETED;\n  return JPEG_SCAN_COMPLETED;\n}\n\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\n\n\n/*\n * Initialize difference buffer controller.\n */\n\nGLOBAL(void)\n_jinit_d_diff_controller(j_decompress_ptr cinfo, boolean need_full_buffer)\n{\n  my_diff_ptr diff;\n  int ci;\n  jpeg_component_info *compptr;\n\n  diff = (my_diff_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_diff_controller));\n  cinfo->coef = (struct jpeg_d_coef_controller *)diff;\n  diff->pub.start_input_pass = start_input_pass;\n  diff->pub.start_output_pass = start_output_pass;\n\n  /* Create the [un]difference buffers. */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    diff->diff_buf[ci] =\n      ALLOC_DARRAY(JPOOL_IMAGE,\n                   (JDIMENSION)jround_up((long)compptr->width_in_blocks,\n                                         (long)compptr->h_samp_factor),\n                   (JDIMENSION)compptr->v_samp_factor);\n    diff->undiff_buf[ci] =\n      ALLOC_DARRAY(JPOOL_IMAGE,\n                   (JDIMENSION)jround_up((long)compptr->width_in_blocks,\n                                         (long)compptr->h_samp_factor),\n                   (JDIMENSION)compptr->v_samp_factor);\n  }\n\n  if (need_full_buffer) {\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n    /* Allocate a full-image virtual array for each component. */\n    int access_rows;\n\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      access_rows = compptr->v_samp_factor;\n      diff->whole_image[ci] = (*cinfo->mem->request_virt_sarray)\n        ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n         (JDIMENSION)jround_up((long)compptr->width_in_blocks,\n                               (long)compptr->h_samp_factor),\n         (JDIMENSION)jround_up((long)compptr->height_in_blocks,\n                               (long)compptr->v_samp_factor),\n         (JDIMENSION)access_rows);\n    }\n    diff->pub.consume_data = consume_data;\n    diff->pub._decompress_data = output_data;\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    diff->pub.consume_data = dummy_consume_data;\n    diff->pub._decompress_data = decompress_data;\n    diff->whole_image[0] = NULL; /* flag for no virtual arrays */\n  }\n}\n\n#endif /* D_LOSSLESS_SUPPORTED */\n"
        },
        {
          "name": "jdhuff.c",
          "type": "blob",
          "size": 26.197265625,
          "content": "/*\n * jdhuff.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2009-2011, 2016, 2018-2019, 2022, D. R. Commander.\n * Copyright (C) 2018, Matthias Rncker.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains Huffman entropy decoding routines.\n *\n * Much of the complexity here has to do with supporting input suspension.\n * If the data source module demands suspension, we want to be able to back\n * up to the start of the current MCU.  To do this, we copy state variables\n * into local working storage, and update them back to the permanent\n * storage only upon successful completion of an MCU.\n *\n * NOTE: All referenced figures are from\n * Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdhuff.h\"             /* Declarations shared with jd*huff.c */\n#include \"jpegapicomp.h\"\n#include \"jstdhuff.c\"\n\n\n/*\n * Expanded entropy decoder object for Huffman decoding.\n *\n * The savable_state subrecord contains fields that change within an MCU,\n * but must not be updated permanently until we complete the MCU.\n */\n\ntypedef struct {\n  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */\n} savable_state;\n\ntypedef struct {\n  struct jpeg_entropy_decoder pub; /* public fields */\n\n  /* These fields are loaded into local variables at start of each MCU.\n   * In case of suspension, we exit WITHOUT updating them.\n   */\n  bitread_perm_state bitstate;  /* Bit buffer at start of MCU */\n  savable_state saved;          /* Other state at start of MCU */\n\n  /* These fields are NOT loaded into local working state. */\n  unsigned int restarts_to_go;  /* MCUs left in this restart interval */\n\n  /* Pointers to derived tables (these workspaces have image lifespan) */\n  d_derived_tbl *dc_derived_tbls[NUM_HUFF_TBLS];\n  d_derived_tbl *ac_derived_tbls[NUM_HUFF_TBLS];\n\n  /* Precalculated info set up by start_pass for use in decode_mcu: */\n\n  /* Pointers to derived tables to be used for each block within an MCU */\n  d_derived_tbl *dc_cur_tbls[D_MAX_BLOCKS_IN_MCU];\n  d_derived_tbl *ac_cur_tbls[D_MAX_BLOCKS_IN_MCU];\n  /* Whether we care about the DC and AC coefficient values for each block */\n  boolean dc_needed[D_MAX_BLOCKS_IN_MCU];\n  boolean ac_needed[D_MAX_BLOCKS_IN_MCU];\n} huff_entropy_decoder;\n\ntypedef huff_entropy_decoder *huff_entropy_ptr;\n\n\n/*\n * Initialize for a Huffman-compressed scan.\n */\n\nMETHODDEF(void)\nstart_pass_huff_decoder(j_decompress_ptr cinfo)\n{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  int ci, blkn, dctbl, actbl;\n  d_derived_tbl **pdtbl;\n  jpeg_component_info *compptr;\n\n  /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.\n   * This ought to be an error condition, but we make it a warning because\n   * there are some baseline files out there with all zeroes in these bytes.\n   */\n  if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2 - 1 ||\n      cinfo->Ah != 0 || cinfo->Al != 0)\n    WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    dctbl = compptr->dc_tbl_no;\n    actbl = compptr->ac_tbl_no;\n    /* Compute derived values for Huffman tables */\n    /* We may do this more than once for a table, but it's not expensive */\n    pdtbl = (d_derived_tbl **)(entropy->dc_derived_tbls) + dctbl;\n    jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl, pdtbl);\n    pdtbl = (d_derived_tbl **)(entropy->ac_derived_tbls) + actbl;\n    jpeg_make_d_derived_tbl(cinfo, FALSE, actbl, pdtbl);\n    /* Initialize DC predictions to 0 */\n    entropy->saved.last_dc_val[ci] = 0;\n  }\n\n  /* Precalculate decoding info for each block in an MCU of this scan */\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    ci = cinfo->MCU_membership[blkn];\n    compptr = cinfo->cur_comp_info[ci];\n    /* Precalculate which table to use for each block */\n    entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];\n    entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];\n    /* Decide whether we really care about the coefficient values */\n    if (compptr->component_needed) {\n      entropy->dc_needed[blkn] = TRUE;\n      /* we don't need the ACs if producing a 1/8th-size image */\n      entropy->ac_needed[blkn] = (compptr->_DCT_scaled_size > 1);\n    } else {\n      entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;\n    }\n  }\n\n  /* Initialize bitread state variables */\n  entropy->bitstate.bits_left = 0;\n  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */\n  entropy->pub.insufficient_data = FALSE;\n\n  /* Initialize restart counter */\n  entropy->restarts_to_go = cinfo->restart_interval;\n}\n\n\n/*\n * Compute the derived values for a Huffman table.\n * This routine also performs some validation checks on the table.\n *\n * Note this is also used by jdphuff.c and jdlhuff.c.\n */\n\nGLOBAL(void)\njpeg_make_d_derived_tbl(j_decompress_ptr cinfo, boolean isDC, int tblno,\n                        d_derived_tbl **pdtbl)\n{\n  JHUFF_TBL *htbl;\n  d_derived_tbl *dtbl;\n  int p, i, l, si, numsymbols;\n  int lookbits, ctr;\n  char huffsize[257];\n  unsigned int huffcode[257];\n  unsigned int code;\n\n  /* Note that huffsize[] and huffcode[] are filled in code-length order,\n   * paralleling the order of the symbols themselves in htbl->huffval[].\n   */\n\n  /* Find the input Huffman table */\n  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);\n  htbl =\n    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];\n  if (htbl == NULL)\n    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);\n\n  /* Allocate a workspace if we haven't already done so. */\n  if (*pdtbl == NULL)\n    *pdtbl = (d_derived_tbl *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  sizeof(d_derived_tbl));\n  dtbl = *pdtbl;\n  dtbl->pub = htbl;             /* fill in back link */\n\n  /* Figure C.1: make table of Huffman code length for each symbol */\n\n  p = 0;\n  for (l = 1; l <= 16; l++) {\n    i = (int)htbl->bits[l];\n    if (i < 0 || p + i > 256)   /* protect against table overrun */\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    while (i--)\n      huffsize[p++] = (char)l;\n  }\n  huffsize[p] = 0;\n  numsymbols = p;\n\n  /* Figure C.2: generate the codes themselves */\n  /* We also validate that the counts represent a legal Huffman code tree. */\n\n  code = 0;\n  si = huffsize[0];\n  p = 0;\n  while (huffsize[p]) {\n    while (((int)huffsize[p]) == si) {\n      huffcode[p++] = code;\n      code++;\n    }\n    /* code is now 1 more than the last code used for codelength si; but\n     * it must still fit in si bits, since no code is allowed to be all ones.\n     */\n    if (((JLONG)code) >= (((JLONG)1) << si))\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    code <<= 1;\n    si++;\n  }\n\n  /* Figure F.15: generate decoding tables for bit-sequential decoding */\n\n  p = 0;\n  for (l = 1; l <= 16; l++) {\n    if (htbl->bits[l]) {\n      /* valoffset[l] = huffval[] index of 1st symbol of code length l,\n       * minus the minimum code of length l\n       */\n      dtbl->valoffset[l] = (JLONG)p - (JLONG)huffcode[p];\n      p += htbl->bits[l];\n      dtbl->maxcode[l] = huffcode[p - 1]; /* maximum code of length l */\n    } else {\n      dtbl->maxcode[l] = -1;    /* -1 if no codes of this length */\n    }\n  }\n  dtbl->valoffset[17] = 0;\n  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */\n\n  /* Compute lookahead tables to speed up decoding.\n   * First we set all the table entries to 0, indicating \"too long\";\n   * then we iterate through the Huffman codes that are short enough and\n   * fill in all the entries that correspond to bit sequences starting\n   * with that code.\n   */\n\n  for (i = 0; i < (1 << HUFF_LOOKAHEAD); i++)\n    dtbl->lookup[i] = (HUFF_LOOKAHEAD + 1) << HUFF_LOOKAHEAD;\n\n  p = 0;\n  for (l = 1; l <= HUFF_LOOKAHEAD; l++) {\n    for (i = 1; i <= (int)htbl->bits[l]; i++, p++) {\n      /* l = current code's length, p = its index in huffcode[] & huffval[]. */\n      /* Generate left-justified code followed by all possible bit sequences */\n      lookbits = huffcode[p] << (HUFF_LOOKAHEAD - l);\n      for (ctr = 1 << (HUFF_LOOKAHEAD - l); ctr > 0; ctr--) {\n        dtbl->lookup[lookbits] = (l << HUFF_LOOKAHEAD) | htbl->huffval[p];\n        lookbits++;\n      }\n    }\n  }\n\n  /* Validate symbols as being reasonable.\n   * For AC tables, we make no check, but accept all byte values 0..255.\n   * For DC tables, we require the symbols to be in range 0..15 in lossy mode\n   * and 0..16 in lossless mode.  (Tighter bounds could be applied depending on\n   * the data depth and mode, but this is sufficient to ensure safe decoding.)\n   */\n  if (isDC) {\n    for (i = 0; i < numsymbols; i++) {\n      int sym = htbl->huffval[i];\n      if (sym < 0 || sym > (cinfo->master->lossless ? 16 : 15))\n        ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n    }\n  }\n}\n\n\n/*\n * Out-of-line code for bit fetching (shared with jdphuff.c and jdlhuff.c).\n * See jdhuff.h for info about usage.\n * Note: current values of get_buffer and bits_left are passed as parameters,\n * but are returned in the corresponding fields of the state struct.\n *\n * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width\n * of get_buffer to be used.  (On machines with wider words, an even larger\n * buffer could be used.)  However, on some machines 32-bit shifts are\n * quite slow and take time proportional to the number of places shifted.\n * (This is true with most PC compilers, for instance.)  In this case it may\n * be a win to set MIN_GET_BITS to the minimum value of 15.  This reduces the\n * average shift distance at the cost of more calls to jpeg_fill_bit_buffer.\n */\n\n#ifdef SLOW_SHIFT_32\n#define MIN_GET_BITS  15        /* minimum allowable value */\n#else\n#define MIN_GET_BITS  (BIT_BUF_SIZE - 7)\n#endif\n\n\nGLOBAL(boolean)\njpeg_fill_bit_buffer(bitread_working_state *state,\n                     register bit_buf_type get_buffer, register int bits_left,\n                     int nbits)\n/* Load up the bit buffer to a depth of at least nbits */\n{\n  /* Copy heavily used state fields into locals (hopefully registers) */\n  register const JOCTET *next_input_byte = state->next_input_byte;\n  register size_t bytes_in_buffer = state->bytes_in_buffer;\n  j_decompress_ptr cinfo = state->cinfo;\n\n  /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */\n  /* (It is assumed that no request will be for more than that many bits.) */\n  /* We fail to do so only if we hit a marker or are forced to suspend. */\n\n  if (cinfo->unread_marker == 0) {      /* cannot advance past a marker */\n    while (bits_left < MIN_GET_BITS) {\n      register int c;\n\n      /* Attempt to read a byte */\n      if (bytes_in_buffer == 0) {\n        if (!(*cinfo->src->fill_input_buffer) (cinfo))\n          return FALSE;\n        next_input_byte = cinfo->src->next_input_byte;\n        bytes_in_buffer = cinfo->src->bytes_in_buffer;\n      }\n      bytes_in_buffer--;\n      c = *next_input_byte++;\n\n      /* If it's 0xFF, check and discard stuffed zero byte */\n      if (c == 0xFF) {\n        /* Loop here to discard any padding FF's on terminating marker,\n         * so that we can save a valid unread_marker value.  NOTE: we will\n         * accept multiple FF's followed by a 0 as meaning a single FF data\n         * byte.  This data pattern is not valid according to the standard.\n         */\n        do {\n          if (bytes_in_buffer == 0) {\n            if (!(*cinfo->src->fill_input_buffer) (cinfo))\n              return FALSE;\n            next_input_byte = cinfo->src->next_input_byte;\n            bytes_in_buffer = cinfo->src->bytes_in_buffer;\n          }\n          bytes_in_buffer--;\n          c = *next_input_byte++;\n        } while (c == 0xFF);\n\n        if (c == 0) {\n          /* Found FF/00, which represents an FF data byte */\n          c = 0xFF;\n        } else {\n          /* Oops, it's actually a marker indicating end of compressed data.\n           * Save the marker code for later use.\n           * Fine point: it might appear that we should save the marker into\n           * bitread working state, not straight into permanent state.  But\n           * once we have hit a marker, we cannot need to suspend within the\n           * current MCU, because we will read no more bytes from the data\n           * source.  So it is OK to update permanent state right away.\n           */\n          cinfo->unread_marker = c;\n          /* See if we need to insert some fake zero bits. */\n          goto no_more_bytes;\n        }\n      }\n\n      /* OK, load c into get_buffer */\n      get_buffer = (get_buffer << 8) | c;\n      bits_left += 8;\n    } /* end while */\n  } else {\nno_more_bytes:\n    /* We get here if we've read the marker that terminates the compressed\n     * data segment.  There should be enough bits in the buffer register\n     * to satisfy the request; if so, no problem.\n     */\n    if (nbits > bits_left) {\n      /* Uh-oh.  Report corrupted data to user and stuff zeroes into\n       * the data stream, so that we can produce some kind of image.\n       * We use a nonvolatile flag to ensure that only one warning message\n       * appears per data segment.\n       */\n      if (!cinfo->entropy->insufficient_data) {\n        WARNMS(cinfo, JWRN_HIT_MARKER);\n        cinfo->entropy->insufficient_data = TRUE;\n      }\n      /* Fill the buffer with zero bits */\n      get_buffer <<= MIN_GET_BITS - bits_left;\n      bits_left = MIN_GET_BITS;\n    }\n  }\n\n  /* Unload the local registers */\n  state->next_input_byte = next_input_byte;\n  state->bytes_in_buffer = bytes_in_buffer;\n  state->get_buffer = get_buffer;\n  state->bits_left = bits_left;\n\n  return TRUE;\n}\n\n\n/* Macro version of the above, which performs much better but does not\n   handle markers.  We have to hand off any blocks with markers to the\n   slower routines. */\n\n#define GET_BYTE { \\\n  register int c0, c1; \\\n  c0 = *buffer++; \\\n  c1 = *buffer; \\\n  /* Pre-execute most common case */ \\\n  get_buffer = (get_buffer << 8) | c0; \\\n  bits_left += 8; \\\n  if (c0 == 0xFF) { \\\n    /* Pre-execute case of FF/00, which represents an FF data byte */ \\\n    buffer++; \\\n    if (c1 != 0) { \\\n      /* Oops, it's actually a marker indicating end of compressed data. */ \\\n      cinfo->unread_marker = c1; \\\n      /* Back out pre-execution and fill the buffer with zero bits */ \\\n      buffer -= 2; \\\n      get_buffer &= ~0xFF; \\\n    } \\\n  } \\\n}\n\n#if SIZEOF_SIZE_T == 8 || defined(_WIN64) || (defined(__x86_64__) && defined(__ILP32__))\n\n/* Pre-fetch 48 bytes, because the holding register is 64-bit */\n#define FILL_BIT_BUFFER_FAST \\\n  if (bits_left <= 16) { \\\n    GET_BYTE GET_BYTE GET_BYTE GET_BYTE GET_BYTE GET_BYTE \\\n  }\n\n#else\n\n/* Pre-fetch 16 bytes, because the holding register is 32-bit */\n#define FILL_BIT_BUFFER_FAST \\\n  if (bits_left <= 16) { \\\n    GET_BYTE GET_BYTE \\\n  }\n\n#endif\n\n\n/*\n * Out-of-line code for Huffman code decoding.\n * See jdhuff.h for info about usage.\n */\n\nGLOBAL(int)\njpeg_huff_decode(bitread_working_state *state,\n                 register bit_buf_type get_buffer, register int bits_left,\n                 d_derived_tbl *htbl, int min_bits)\n{\n  register int l = min_bits;\n  register JLONG code;\n\n  /* HUFF_DECODE has determined that the code is at least min_bits */\n  /* bits long, so fetch that many bits in one swoop. */\n\n  CHECK_BIT_BUFFER(*state, l, return -1);\n  code = GET_BITS(l);\n\n  /* Collect the rest of the Huffman code one bit at a time. */\n  /* This is per Figure F.16. */\n\n  while (code > htbl->maxcode[l]) {\n    code <<= 1;\n    CHECK_BIT_BUFFER(*state, 1, return -1);\n    code |= GET_BITS(1);\n    l++;\n  }\n\n  /* Unload the local registers */\n  state->get_buffer = get_buffer;\n  state->bits_left = bits_left;\n\n  /* With garbage input we may reach the sentinel value l = 17. */\n\n  if (l > 16) {\n    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);\n    return 0;                   /* fake a zero as the safest result */\n  }\n\n  return htbl->pub->huffval[(int)(code + htbl->valoffset[l])];\n}\n\n\n/*\n * Figure F.12: extend sign bit.\n * On some machines, a shift and add will be faster than a table lookup.\n */\n\n#define AVOID_TABLES\n#ifdef AVOID_TABLES\n\n#define NEG_1  ((unsigned int)-1)\n#define HUFF_EXTEND(x, s) \\\n  ((x) + ((((x) - (1 << ((s) - 1))) >> 31) & (((NEG_1) << (s)) + 1)))\n\n#else\n\n#define HUFF_EXTEND(x, s) \\\n  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))\n\nstatic const int extend_test[16] = {   /* entry n is 2**(n-1) */\n  0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,\n  0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000\n};\n\nstatic const int extend_offset[16] = { /* entry n is (-1 << n) + 1 */\n  0, ((-1) << 1) + 1, ((-1) << 2) + 1, ((-1) << 3) + 1, ((-1) << 4) + 1,\n  ((-1) << 5) + 1, ((-1) << 6) + 1, ((-1) << 7) + 1, ((-1) << 8) + 1,\n  ((-1) << 9) + 1, ((-1) << 10) + 1, ((-1) << 11) + 1, ((-1) << 12) + 1,\n  ((-1) << 13) + 1, ((-1) << 14) + 1, ((-1) << 15) + 1\n};\n\n#endif /* AVOID_TABLES */\n\n\n/*\n * Check for a restart marker & resynchronize decoder.\n * Returns FALSE if must suspend.\n */\n\nLOCAL(boolean)\nprocess_restart(j_decompress_ptr cinfo)\n{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  int ci;\n\n  /* Throw away any unused bits remaining in bit buffer; */\n  /* include any full bytes in next_marker's count of discarded bytes */\n  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;\n  entropy->bitstate.bits_left = 0;\n\n  /* Advance past the RSTn marker */\n  if (!(*cinfo->marker->read_restart_marker) (cinfo))\n    return FALSE;\n\n  /* Re-initialize DC predictions to 0 */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++)\n    entropy->saved.last_dc_val[ci] = 0;\n\n  /* Reset restart counter */\n  entropy->restarts_to_go = cinfo->restart_interval;\n\n  /* Reset out-of-data flag, unless read_restart_marker left us smack up\n   * against a marker.  In that case we will end up treating the next data\n   * segment as empty, and we can avoid producing bogus output pixels by\n   * leaving the flag set.\n   */\n  if (cinfo->unread_marker == 0)\n    entropy->pub.insufficient_data = FALSE;\n\n  return TRUE;\n}\n\n\n#if defined(__has_feature)\n#if __has_feature(undefined_behavior_sanitizer)\n__attribute__((no_sanitize(\"signed-integer-overflow\"),\n               no_sanitize(\"unsigned-integer-overflow\")))\n#endif\n#endif\nLOCAL(boolean)\ndecode_mcu_slow(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  BITREAD_STATE_VARS;\n  int blkn;\n  savable_state state;\n  /* Outer loop handles each block in the MCU */\n\n  /* Load up working state */\n  BITREAD_LOAD_STATE(cinfo, entropy->bitstate);\n  state = entropy->saved;\n\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    JBLOCKROW block = MCU_data ? MCU_data[blkn] : NULL;\n    d_derived_tbl *dctbl = entropy->dc_cur_tbls[blkn];\n    d_derived_tbl *actbl = entropy->ac_cur_tbls[blkn];\n    register int s, k, r;\n\n    /* Decode a single block's worth of coefficients */\n\n    /* Section F.2.2.1: decode the DC coefficient difference */\n    HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);\n    if (s) {\n      CHECK_BIT_BUFFER(br_state, s, return FALSE);\n      r = GET_BITS(s);\n      s = HUFF_EXTEND(r, s);\n    }\n\n    if (entropy->dc_needed[blkn]) {\n      /* Convert DC difference to actual value, update last_dc_val */\n      int ci = cinfo->MCU_membership[blkn];\n      /* Certain malformed JPEG images produce repeated DC coefficient\n       * differences of 2047 or -2047, which causes state.last_dc_val[ci] to\n       * grow until it overflows or underflows a 32-bit signed integer.  This\n       * behavior is, to the best of our understanding, innocuous, and it is\n       * unclear how to work around it without potentially affecting\n       * performance.  Thus, we (hopefully temporarily) suppress UBSan integer\n       * overflow errors for this function and decode_mcu_fast().\n       */\n      s += state.last_dc_val[ci];\n      state.last_dc_val[ci] = s;\n      if (block) {\n        /* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */\n        (*block)[0] = (JCOEF)s;\n      }\n    }\n\n    if (entropy->ac_needed[blkn] && block) {\n\n      /* Section F.2.2.2: decode the AC coefficients */\n      /* Since zeroes are skipped, output area must be cleared beforehand */\n      for (k = 1; k < DCTSIZE2; k++) {\n        HUFF_DECODE(s, br_state, actbl, return FALSE, label2);\n\n        r = s >> 4;\n        s &= 15;\n\n        if (s) {\n          k += r;\n          CHECK_BIT_BUFFER(br_state, s, return FALSE);\n          r = GET_BITS(s);\n          s = HUFF_EXTEND(r, s);\n          /* Output coefficient in natural (dezigzagged) order.\n           * Note: the extra entries in jpeg_natural_order[] will save us\n           * if k >= DCTSIZE2, which could happen if the data is corrupted.\n           */\n          (*block)[jpeg_natural_order[k]] = (JCOEF)s;\n        } else {\n          if (r != 15)\n            break;\n          k += 15;\n        }\n      }\n\n    } else {\n\n      /* Section F.2.2.2: decode the AC coefficients */\n      /* In this path we just discard the values */\n      for (k = 1; k < DCTSIZE2; k++) {\n        HUFF_DECODE(s, br_state, actbl, return FALSE, label3);\n\n        r = s >> 4;\n        s &= 15;\n\n        if (s) {\n          k += r;\n          CHECK_BIT_BUFFER(br_state, s, return FALSE);\n          DROP_BITS(s);\n        } else {\n          if (r != 15)\n            break;\n          k += 15;\n        }\n      }\n    }\n  }\n\n  /* Completed MCU, so update state */\n  BITREAD_SAVE_STATE(cinfo, entropy->bitstate);\n  entropy->saved = state;\n  return TRUE;\n}\n\n\n#if defined(__has_feature)\n#if __has_feature(undefined_behavior_sanitizer)\n__attribute__((no_sanitize(\"signed-integer-overflow\"),\n               no_sanitize(\"unsigned-integer-overflow\")))\n#endif\n#endif\nLOCAL(boolean)\ndecode_mcu_fast(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  BITREAD_STATE_VARS;\n  JOCTET *buffer;\n  int blkn;\n  savable_state state;\n  /* Outer loop handles each block in the MCU */\n\n  /* Load up working state */\n  BITREAD_LOAD_STATE(cinfo, entropy->bitstate);\n  buffer = (JOCTET *)br_state.next_input_byte;\n  state = entropy->saved;\n\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    JBLOCKROW block = MCU_data ? MCU_data[blkn] : NULL;\n    d_derived_tbl *dctbl = entropy->dc_cur_tbls[blkn];\n    d_derived_tbl *actbl = entropy->ac_cur_tbls[blkn];\n    register int s, k, r, l;\n\n    HUFF_DECODE_FAST(s, l, dctbl);\n    if (s) {\n      FILL_BIT_BUFFER_FAST\n      r = GET_BITS(s);\n      s = HUFF_EXTEND(r, s);\n    }\n\n    if (entropy->dc_needed[blkn]) {\n      int ci = cinfo->MCU_membership[blkn];\n      /* Refer to the comment in decode_mcu_slow() regarding the supression of\n       * a UBSan integer overflow error in this line of code.\n       */\n      s += state.last_dc_val[ci];\n      state.last_dc_val[ci] = s;\n      if (block)\n        (*block)[0] = (JCOEF)s;\n    }\n\n    if (entropy->ac_needed[blkn] && block) {\n\n      for (k = 1; k < DCTSIZE2; k++) {\n        HUFF_DECODE_FAST(s, l, actbl);\n        r = s >> 4;\n        s &= 15;\n\n        if (s) {\n          k += r;\n          FILL_BIT_BUFFER_FAST\n          r = GET_BITS(s);\n          s = HUFF_EXTEND(r, s);\n          (*block)[jpeg_natural_order[k]] = (JCOEF)s;\n        } else {\n          if (r != 15) break;\n          k += 15;\n        }\n      }\n\n    } else {\n\n      for (k = 1; k < DCTSIZE2; k++) {\n        HUFF_DECODE_FAST(s, l, actbl);\n        r = s >> 4;\n        s &= 15;\n\n        if (s) {\n          k += r;\n          FILL_BIT_BUFFER_FAST\n          DROP_BITS(s);\n        } else {\n          if (r != 15) break;\n          k += 15;\n        }\n      }\n    }\n  }\n\n  if (cinfo->unread_marker != 0) {\n    cinfo->unread_marker = 0;\n    return FALSE;\n  }\n\n  br_state.bytes_in_buffer -= (buffer - br_state.next_input_byte);\n  br_state.next_input_byte = buffer;\n  BITREAD_SAVE_STATE(cinfo, entropy->bitstate);\n  entropy->saved = state;\n  return TRUE;\n}\n\n\n/*\n * Decode and return one MCU's worth of Huffman-compressed coefficients.\n * The coefficients are reordered from zigzag order into natural array order,\n * but are not dequantized.\n *\n * The i'th block of the MCU is stored into the block pointed to by\n * MCU_data[i].  WE ASSUME THIS AREA HAS BEEN ZEROED BY THE CALLER.\n * (Wholesale zeroing is usually a little faster than retail...)\n *\n * Returns FALSE if data source requested suspension.  In that case no\n * changes have been made to permanent state.  (Exception: some output\n * coefficients may already have been assigned.  This is harmless for\n * this module, since we'll just re-assign them on the next call.)\n */\n\n#define BUFSIZE  (DCTSIZE2 * 8)\n\nMETHODDEF(boolean)\ndecode_mcu(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  huff_entropy_ptr entropy = (huff_entropy_ptr)cinfo->entropy;\n  int usefast = 1;\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (!process_restart(cinfo))\n        return FALSE;\n    usefast = 0;\n  }\n\n  if (cinfo->src->bytes_in_buffer < BUFSIZE * (size_t)cinfo->blocks_in_MCU ||\n      cinfo->unread_marker != 0)\n    usefast = 0;\n\n  /* If we've run out of data, just leave the MCU set to zeroes.\n   * This way, we return uniform gray for the remainder of the segment.\n   */\n  if (!entropy->pub.insufficient_data) {\n\n    if (usefast) {\n      if (!decode_mcu_fast(cinfo, MCU_data)) goto use_slow;\n    } else {\nuse_slow:\n      if (!decode_mcu_slow(cinfo, MCU_data)) return FALSE;\n    }\n\n  }\n\n  /* Account for restart interval (no-op if not using restarts) */\n  if (cinfo->restart_interval)\n    entropy->restarts_to_go--;\n\n  return TRUE;\n}\n\n\n/*\n * Module initialization routine for Huffman entropy decoding.\n */\n\nGLOBAL(void)\njinit_huff_decoder(j_decompress_ptr cinfo)\n{\n  huff_entropy_ptr entropy;\n  int i;\n\n  /* Motion JPEG frames typically do not include the Huffman tables if they\n     are the default tables.  Thus, if the tables are not set by the time\n     the Huffman decoder is initialized (usually within the body of\n     jpeg_start_decompress()), we set them to default values. */\n  std_huff_tables((j_common_ptr)cinfo);\n\n  entropy = (huff_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(huff_entropy_decoder));\n  cinfo->entropy = (struct jpeg_entropy_decoder *)entropy;\n  entropy->pub.start_pass = start_pass_huff_decoder;\n  entropy->pub.decode_mcu = decode_mcu;\n\n  /* Mark tables unallocated */\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;\n  }\n}\n"
        },
        {
          "name": "jdhuff.h",
          "type": "blob",
          "size": 9.6708984375,
          "content": "/*\n * jdhuff.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010-2011, 2015-2016, 2021, D. R. Commander.\n * Copyright (C) 2018, Matthias Rncker.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains declarations for Huffman entropy decoding routines\n * that are shared between the sequential decoder (jdhuff.c), the progressive\n * decoder (jdphuff.c), and the lossless decoder (jdlhuff.c).  No other modules\n * need to see these.\n */\n\n#include \"jconfigint.h\"\n\n\n/* Derived data constructed for each Huffman table */\n\n#define HUFF_LOOKAHEAD  8       /* # of bits of lookahead */\n\ntypedef struct {\n  /* Basic tables: (element [0] of each array is unused) */\n  JLONG maxcode[18];            /* largest code of length k (-1 if none) */\n  /* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */\n  JLONG valoffset[18];          /* huffval[] offset for codes of length k */\n  /* valoffset[k] = huffval[] index of 1st symbol of code length k, less\n   * the smallest code of length k; so given a code of length k, the\n   * corresponding symbol is huffval[code + valoffset[k]]\n   */\n\n  /* Link to public Huffman table (needed only in jpeg_huff_decode) */\n  JHUFF_TBL *pub;\n\n  /* Lookahead table: indexed by the next HUFF_LOOKAHEAD bits of\n   * the input data stream.  If the next Huffman code is no more\n   * than HUFF_LOOKAHEAD bits long, we can obtain its length and\n   * the corresponding symbol directly from this tables.\n   *\n   * The lower 8 bits of each table entry contain the number of\n   * bits in the corresponding Huffman code, or HUFF_LOOKAHEAD + 1\n   * if too long.  The next 8 bits of each entry contain the\n   * symbol.\n   */\n  int lookup[1 << HUFF_LOOKAHEAD];\n} d_derived_tbl;\n\n/* Expand a Huffman table definition into the derived format */\nEXTERN(void) jpeg_make_d_derived_tbl(j_decompress_ptr cinfo, boolean isDC,\n                                     int tblno, d_derived_tbl **pdtbl);\n\n\n/*\n * Fetching the next N bits from the input stream is a time-critical operation\n * for the Huffman decoders.  We implement it with a combination of inline\n * macros and out-of-line subroutines.  Note that N (the number of bits\n * demanded at one time) never exceeds 15 for JPEG use.\n *\n * We read source bytes into get_buffer and dole out bits as needed.\n * If get_buffer already contains enough bits, they are fetched in-line\n * by the macros CHECK_BIT_BUFFER and GET_BITS.  When there aren't enough\n * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer\n * as full as possible (not just to the number of bits needed; this\n * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).\n * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.\n * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains\n * at least the requested number of bits --- dummy zeroes are inserted if\n * necessary.\n */\n\n#if !defined(_WIN32) && !defined(SIZEOF_SIZE_T)\n#error Cannot determine word size\n#endif\n\n#if SIZEOF_SIZE_T == 8 || defined(_WIN64)\n\ntypedef size_t bit_buf_type;            /* type of bit-extraction buffer */\n#define BIT_BUF_SIZE  64                /* size of buffer in bits */\n\n#elif defined(__x86_64__) && defined(__ILP32__)\n\ntypedef unsigned long long bit_buf_type; /* type of bit-extraction buffer */\n#define BIT_BUF_SIZE  64                 /* size of buffer in bits */\n\n#else\n\ntypedef unsigned long bit_buf_type;     /* type of bit-extraction buffer */\n#define BIT_BUF_SIZE  32                /* size of buffer in bits */\n\n#endif\n\n/* If long is > 32 bits on your machine, and shifting/masking longs is\n * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE\n * appropriately should be a win.  Unfortunately we can't define the size\n * with something like  #define BIT_BUF_SIZE (sizeof(bit_buf_type)*8)\n * because not all machines measure sizeof in 8-bit bytes.\n */\n\ntypedef struct {                /* Bitreading state saved across MCUs */\n  bit_buf_type get_buffer;      /* current bit-extraction buffer */\n  int bits_left;                /* # of unused bits in it */\n} bitread_perm_state;\n\ntypedef struct {                /* Bitreading working state within an MCU */\n  /* Current data source location */\n  /* We need a copy, rather than munging the original, in case of suspension */\n  const JOCTET *next_input_byte; /* => next byte to read from source */\n  size_t bytes_in_buffer;       /* # of bytes remaining in source buffer */\n  /* Bit input buffer --- note these values are kept in register variables,\n   * not in this struct, inside the inner loops.\n   */\n  bit_buf_type get_buffer;      /* current bit-extraction buffer */\n  int bits_left;                /* # of unused bits in it */\n  /* Pointer needed by jpeg_fill_bit_buffer. */\n  j_decompress_ptr cinfo;       /* back link to decompress master record */\n} bitread_working_state;\n\n/* Macros to declare and load/save bitread local variables. */\n#define BITREAD_STATE_VARS \\\n  register bit_buf_type get_buffer; \\\n  register int bits_left; \\\n  bitread_working_state br_state\n\n#define BITREAD_LOAD_STATE(cinfop, permstate) \\\n  br_state.cinfo = cinfop; \\\n  br_state.next_input_byte = cinfop->src->next_input_byte; \\\n  br_state.bytes_in_buffer = cinfop->src->bytes_in_buffer; \\\n  get_buffer = permstate.get_buffer; \\\n  bits_left = permstate.bits_left;\n\n#define BITREAD_SAVE_STATE(cinfop, permstate) \\\n  cinfop->src->next_input_byte = br_state.next_input_byte; \\\n  cinfop->src->bytes_in_buffer = br_state.bytes_in_buffer; \\\n  permstate.get_buffer = get_buffer; \\\n  permstate.bits_left = bits_left\n\n/*\n * These macros provide the in-line portion of bit fetching.\n * Use CHECK_BIT_BUFFER to ensure there are N bits in get_buffer\n * before using GET_BITS, PEEK_BITS, or DROP_BITS.\n * The variables get_buffer and bits_left are assumed to be locals,\n * but the state struct might not be (jpeg_huff_decode needs this).\n *      CHECK_BIT_BUFFER(state, n, action);\n *              Ensure there are N bits in get_buffer; if suspend, take action.\n *      val = GET_BITS(n);\n *              Fetch next N bits.\n *      val = PEEK_BITS(n);\n *              Fetch next N bits without removing them from the buffer.\n *      DROP_BITS(n);\n *              Discard next N bits.\n * The value N should be a simple variable, not an expression, because it\n * is evaluated multiple times.\n */\n\n#define CHECK_BIT_BUFFER(state, nbits, action) { \\\n  if (bits_left < (nbits)) { \\\n    if (!jpeg_fill_bit_buffer(&(state), get_buffer, bits_left, nbits)) \\\n      { action; } \\\n    get_buffer = (state).get_buffer;  bits_left = (state).bits_left; \\\n  } \\\n}\n\n#define GET_BITS(nbits) \\\n  (((int)(get_buffer >> (bits_left -= (nbits)))) & ((1 << (nbits)) - 1))\n\n#define PEEK_BITS(nbits) \\\n  (((int)(get_buffer >> (bits_left -  (nbits)))) & ((1 << (nbits)) - 1))\n\n#define DROP_BITS(nbits) \\\n  (bits_left -= (nbits))\n\n/* Load up the bit buffer to a depth of at least nbits */\nEXTERN(boolean) jpeg_fill_bit_buffer(bitread_working_state *state,\n                                     register bit_buf_type get_buffer,\n                                     register int bits_left, int nbits);\n\n\n/*\n * Code for extracting next Huffman-coded symbol from input bit stream.\n * Again, this is time-critical and we make the main paths be macros.\n *\n * We use a lookahead table to process codes of up to HUFF_LOOKAHEAD bits\n * without looping.  Usually, more than 95% of the Huffman codes will be 8\n * or fewer bits long.  The few overlength codes are handled with a loop,\n * which need not be inline code.\n *\n * Notes about the HUFF_DECODE macro:\n * 1. Near the end of the data segment, we may fail to get enough bits\n *    for a lookahead.  In that case, we do it the hard way.\n * 2. If the lookahead table contains no entry, the next code must be\n *    more than HUFF_LOOKAHEAD bits long.\n * 3. jpeg_huff_decode returns -1 if forced to suspend.\n */\n\n#define HUFF_DECODE(result, state, htbl, failaction, slowlabel) { \\\n  register int nb, look; \\\n  if (bits_left < HUFF_LOOKAHEAD) { \\\n    if (!jpeg_fill_bit_buffer(&state, get_buffer, bits_left, 0)) \\\n      { failaction; } \\\n    get_buffer = state.get_buffer;  bits_left = state.bits_left; \\\n    if (bits_left < HUFF_LOOKAHEAD) { \\\n      nb = 1;  goto slowlabel; \\\n    } \\\n  } \\\n  look = PEEK_BITS(HUFF_LOOKAHEAD); \\\n  if ((nb = (htbl->lookup[look] >> HUFF_LOOKAHEAD)) <= HUFF_LOOKAHEAD) { \\\n    DROP_BITS(nb); \\\n    result = htbl->lookup[look] & ((1 << HUFF_LOOKAHEAD) - 1); \\\n  } else { \\\nslowlabel: \\\n    if ((result = \\\n         jpeg_huff_decode(&state, get_buffer, bits_left, htbl, nb)) < 0) \\\n      { failaction; } \\\n    get_buffer = state.get_buffer;  bits_left = state.bits_left; \\\n  } \\\n}\n\n#define HUFF_DECODE_FAST(s, nb, htbl) \\\n  FILL_BIT_BUFFER_FAST; \\\n  s = PEEK_BITS(HUFF_LOOKAHEAD); \\\n  s = htbl->lookup[s]; \\\n  nb = s >> HUFF_LOOKAHEAD; \\\n  /* Pre-execute the common case of nb <= HUFF_LOOKAHEAD */ \\\n  DROP_BITS(nb); \\\n  s = s & ((1 << HUFF_LOOKAHEAD) - 1); \\\n  if (nb > HUFF_LOOKAHEAD) { \\\n    /* Equivalent of jpeg_huff_decode() */ \\\n    /* Don't use GET_BITS() here because we don't want to modify bits_left */ \\\n    s = (get_buffer >> bits_left) & ((1 << (nb)) - 1); \\\n    while (s > htbl->maxcode[nb]) { \\\n      s <<= 1; \\\n      s |= GET_BITS(1); \\\n      nb++; \\\n    } \\\n    if (nb > 16) \\\n      s = 0; \\\n    else \\\n      s = htbl->pub->huffval[(int)(s + htbl->valoffset[nb]) & 0xFF]; \\\n  }\n\n/* Out-of-line case for Huffman code fetching */\nEXTERN(int) jpeg_huff_decode(bitread_working_state *state,\n                             register bit_buf_type get_buffer,\n                             register int bits_left, d_derived_tbl *htbl,\n                             int min_bits);\n"
        },
        {
          "name": "jdicc.c",
          "type": "blob",
          "size": 5.2822265625,
          "content": "/*\n * jdicc.c\n *\n * Copyright (C) 1997-1998, Thomas G. Lane, Todd Newman.\n * Copyright (C) 2017, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file provides code to read International Color Consortium (ICC) device\n * profiles embedded in JFIF JPEG image files.  The ICC has defined a standard\n * for including such data in JPEG \"APP2\" markers.  The code given here does\n * not know anything about the internal structure of the ICC profile data; it\n * just knows how to get the profile data from a JPEG file while reading it.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jerror.h\"\n\n\n#define ICC_MARKER  (JPEG_APP0 + 2)     /* JPEG marker code for ICC */\n#define ICC_OVERHEAD_LEN  14            /* size of non-profile data in APP2 */\n\n\n/*\n * Handy subroutine to test whether a saved marker is an ICC profile marker.\n */\n\nLOCAL(boolean)\nmarker_is_icc(jpeg_saved_marker_ptr marker)\n{\n  return\n    marker->marker == ICC_MARKER &&\n    marker->data_length >= ICC_OVERHEAD_LEN &&\n    /* verify the identifying string */\n    marker->data[0] == 0x49 &&\n    marker->data[1] == 0x43 &&\n    marker->data[2] == 0x43 &&\n    marker->data[3] == 0x5F &&\n    marker->data[4] == 0x50 &&\n    marker->data[5] == 0x52 &&\n    marker->data[6] == 0x4F &&\n    marker->data[7] == 0x46 &&\n    marker->data[8] == 0x49 &&\n    marker->data[9] == 0x4C &&\n    marker->data[10] == 0x45 &&\n    marker->data[11] == 0x0;\n}\n\n\n/*\n * See if there was an ICC profile in the JPEG file being read; if so,\n * reassemble and return the profile data.\n *\n * TRUE is returned if an ICC profile was found, FALSE if not.  If TRUE is\n * returned, *icc_data_ptr is set to point to the returned data, and\n * *icc_data_len is set to its length.\n *\n * IMPORTANT: the data at *icc_data_ptr is allocated with malloc() and must be\n * freed by the caller with free() when the caller no longer needs it.\n * (Alternatively, we could write this routine to use the IJG library's memory\n * allocator, so that the data would be freed implicitly when\n * jpeg_finish_decompress() is called.  But it seems likely that many\n * applications will prefer to have the data stick around after decompression\n * finishes.)\n */\n\nGLOBAL(boolean)\njpeg_read_icc_profile(j_decompress_ptr cinfo, JOCTET **icc_data_ptr,\n                      unsigned int *icc_data_len)\n{\n  jpeg_saved_marker_ptr marker;\n  int num_markers = 0;\n  int seq_no;\n  JOCTET *icc_data;\n  unsigned int total_length;\n#define MAX_SEQ_NO  255         /* sufficient since marker numbers are bytes */\n  char marker_present[MAX_SEQ_NO + 1];      /* 1 if marker found */\n  unsigned int data_length[MAX_SEQ_NO + 1]; /* size of profile data in marker */\n  unsigned int data_offset[MAX_SEQ_NO + 1]; /* offset for data in marker */\n\n  if (icc_data_ptr == NULL || icc_data_len == NULL)\n    ERREXIT(cinfo, JERR_BUFFER_SIZE);\n  if (cinfo->global_state < DSTATE_READY)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  *icc_data_ptr = NULL;         /* avoid confusion if FALSE return */\n  *icc_data_len = 0;\n\n  /* This first pass over the saved markers discovers whether there are\n   * any ICC markers and verifies the consistency of the marker numbering.\n   */\n\n  for (seq_no = 1; seq_no <= MAX_SEQ_NO; seq_no++)\n    marker_present[seq_no] = 0;\n\n  for (marker = cinfo->marker_list; marker != NULL; marker = marker->next) {\n    if (marker_is_icc(marker)) {\n      if (num_markers == 0)\n        num_markers = marker->data[13];\n      else if (num_markers != marker->data[13]) {\n        WARNMS(cinfo, JWRN_BOGUS_ICC);  /* inconsistent num_markers fields */\n        return FALSE;\n      }\n      seq_no = marker->data[12];\n      if (seq_no <= 0 || seq_no > num_markers) {\n        WARNMS(cinfo, JWRN_BOGUS_ICC);  /* bogus sequence number */\n        return FALSE;\n      }\n      if (marker_present[seq_no]) {\n        WARNMS(cinfo, JWRN_BOGUS_ICC);  /* duplicate sequence numbers */\n        return FALSE;\n      }\n      marker_present[seq_no] = 1;\n      data_length[seq_no] = marker->data_length - ICC_OVERHEAD_LEN;\n    }\n  }\n\n  if (num_markers == 0)\n    return FALSE;\n\n  /* Check for missing markers, count total space needed,\n   * compute offset of each marker's part of the data.\n   */\n\n  total_length = 0;\n  for (seq_no = 1; seq_no <= num_markers; seq_no++) {\n    if (marker_present[seq_no] == 0) {\n      WARNMS(cinfo, JWRN_BOGUS_ICC);  /* missing sequence number */\n      return FALSE;\n    }\n    data_offset[seq_no] = total_length;\n    total_length += data_length[seq_no];\n  }\n\n  if (total_length == 0) {\n    WARNMS(cinfo, JWRN_BOGUS_ICC);  /* found only empty markers? */\n    return FALSE;\n  }\n\n  /* Allocate space for assembled data */\n  icc_data = (JOCTET *)malloc(total_length * sizeof(JOCTET));\n  if (icc_data == NULL)\n    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 11);  /* oops, out of memory */\n\n  /* and fill it in */\n  for (marker = cinfo->marker_list; marker != NULL; marker = marker->next) {\n    if (marker_is_icc(marker)) {\n      JOCTET FAR *src_ptr;\n      JOCTET *dst_ptr;\n      unsigned int length;\n      seq_no = marker->data[12];\n      dst_ptr = icc_data + data_offset[seq_no];\n      src_ptr = marker->data + ICC_OVERHEAD_LEN;\n      length = data_length[seq_no];\n      while (length--) {\n        *dst_ptr++ = *src_ptr++;\n      }\n    }\n  }\n\n  *icc_data_ptr = icc_data;\n  *icc_data_len = total_length;\n\n  return TRUE;\n}\n"
        },
        {
          "name": "jdinput.c",
          "type": "blob",
          "size": 14.7158203125,
          "content": "/*\n * jdinput.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010, 2016, 2018, 2022, D. R. Commander.\n * Copyright (C) 2015, Google, Inc.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains input control logic for the JPEG decompressor.\n * These routines are concerned with controlling the decompressor's input\n * processing (marker reading and coefficient/difference decoding).\n * The actual input reading is done in jdmarker.c, jdhuff.c, jdphuff.c,\n * and jdlhuff.c.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jpegapicomp.h\"\n\n\n/* Private state */\n\ntypedef struct {\n  struct jpeg_input_controller pub; /* public fields */\n\n  boolean inheaders;            /* TRUE until first SOS is reached */\n} my_input_controller;\n\ntypedef my_input_controller *my_inputctl_ptr;\n\n\n/* Forward declarations */\nMETHODDEF(int) consume_markers(j_decompress_ptr cinfo);\n\n\n/*\n * Routines to calculate various quantities related to the size of the image.\n */\n\nLOCAL(void)\ninitial_setup(j_decompress_ptr cinfo)\n/* Called once, when first SOS marker is reached */\n{\n  int ci;\n  jpeg_component_info *compptr;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n  /* Make sure image isn't bigger than I can handle */\n  if ((long)cinfo->image_height > (long)JPEG_MAX_DIMENSION ||\n      (long)cinfo->image_width > (long)JPEG_MAX_DIMENSION)\n    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int)JPEG_MAX_DIMENSION);\n\n  /* For now, precision must match compiled-in value... */\n#ifdef D_LOSSLESS_SUPPORTED\n  if (cinfo->data_precision != 8 && cinfo->data_precision != 12 &&\n      cinfo->data_precision != 16)\n#else\n  if (cinfo->data_precision != 8 && cinfo->data_precision != 12)\n#endif\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Check that number of components won't exceed internal array sizes */\n  if (cinfo->num_components > MAX_COMPONENTS)\n    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,\n             MAX_COMPONENTS);\n\n  /* Compute maximum sampling factors; check factor validity */\n  cinfo->max_h_samp_factor = 1;\n  cinfo->max_v_samp_factor = 1;\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    if (compptr->h_samp_factor <= 0 ||\n        compptr->h_samp_factor > MAX_SAMP_FACTOR ||\n        compptr->v_samp_factor <= 0 ||\n        compptr->v_samp_factor > MAX_SAMP_FACTOR)\n      ERREXIT(cinfo, JERR_BAD_SAMPLING);\n    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,\n                                   compptr->h_samp_factor);\n    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,\n                                   compptr->v_samp_factor);\n  }\n\n#if JPEG_LIB_VERSION >= 80\n  cinfo->block_size = data_unit;\n  cinfo->natural_order = jpeg_natural_order;\n  cinfo->lim_Se = DCTSIZE2 - 1;\n#endif\n\n  /* We initialize DCT_scaled_size and min_DCT_scaled_size to DCTSIZE in lossy\n   * mode.  In the full decompressor, this will be overridden by jdmaster.c;\n   * but in the transcoder, jdmaster.c is not used, so we must do it here.\n   */\n#if JPEG_LIB_VERSION >= 70\n  cinfo->min_DCT_h_scaled_size = cinfo->min_DCT_v_scaled_size = data_unit;\n#else\n  cinfo->min_DCT_scaled_size = data_unit;\n#endif\n\n  /* Compute dimensions of components */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n#if JPEG_LIB_VERSION >= 70\n    compptr->DCT_h_scaled_size = compptr->DCT_v_scaled_size = data_unit;\n#else\n    compptr->DCT_scaled_size = data_unit;\n#endif\n    /* Size in data units */\n    compptr->width_in_blocks = (JDIMENSION)\n      jdiv_round_up((long)cinfo->image_width * (long)compptr->h_samp_factor,\n                    (long)(cinfo->max_h_samp_factor * data_unit));\n    compptr->height_in_blocks = (JDIMENSION)\n      jdiv_round_up((long)cinfo->image_height * (long)compptr->v_samp_factor,\n                    (long)(cinfo->max_v_samp_factor * data_unit));\n    /* Set the first and last MCU columns to decompress from multi-scan images.\n     * By default, decompress all of the MCU columns.\n     */\n    cinfo->master->first_MCU_col[ci] = 0;\n    cinfo->master->last_MCU_col[ci] = compptr->width_in_blocks - 1;\n    /* downsampled_width and downsampled_height will also be overridden by\n     * jdmaster.c if we are doing full decompression.  The transcoder library\n     * doesn't use these values, but the calling application might.\n     */\n    /* Size in samples */\n    compptr->downsampled_width = (JDIMENSION)\n      jdiv_round_up((long)cinfo->image_width * (long)compptr->h_samp_factor,\n                    (long)cinfo->max_h_samp_factor);\n    compptr->downsampled_height = (JDIMENSION)\n      jdiv_round_up((long)cinfo->image_height * (long)compptr->v_samp_factor,\n                    (long)cinfo->max_v_samp_factor);\n    /* Mark component needed, until color conversion says otherwise */\n    compptr->component_needed = TRUE;\n    /* Mark no quantization table yet saved for component */\n    compptr->quant_table = NULL;\n  }\n\n  /* Compute number of fully interleaved MCU rows. */\n  cinfo->total_iMCU_rows = (JDIMENSION)\n    jdiv_round_up((long)cinfo->image_height,\n                  (long)(cinfo->max_v_samp_factor * data_unit));\n\n  /* Decide whether file contains multiple scans */\n  if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)\n    cinfo->inputctl->has_multiple_scans = TRUE;\n  else\n    cinfo->inputctl->has_multiple_scans = FALSE;\n}\n\n\nLOCAL(void)\nper_scan_setup(j_decompress_ptr cinfo)\n/* Do computations that are needed before processing a JPEG scan */\n/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */\n{\n  int ci, mcublks, tmp;\n  jpeg_component_info *compptr;\n  int data_unit = cinfo->master->lossless ? 1 : DCTSIZE;\n\n  if (cinfo->comps_in_scan == 1) {\n\n    /* Noninterleaved (single-component) scan */\n    compptr = cinfo->cur_comp_info[0];\n\n    /* Overall image size in MCUs */\n    cinfo->MCUs_per_row = compptr->width_in_blocks;\n    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;\n\n    /* For noninterleaved scan, always one data unit per MCU */\n    compptr->MCU_width = 1;\n    compptr->MCU_height = 1;\n    compptr->MCU_blocks = 1;\n    compptr->MCU_sample_width = compptr->_DCT_scaled_size;\n    compptr->last_col_width = 1;\n    /* For noninterleaved scans, it is convenient to define last_row_height\n     * as the number of data unit rows present in the last iMCU row.\n     */\n    tmp = (int)(compptr->height_in_blocks % compptr->v_samp_factor);\n    if (tmp == 0) tmp = compptr->v_samp_factor;\n    compptr->last_row_height = tmp;\n\n    /* Prepare array describing MCU composition */\n    cinfo->blocks_in_MCU = 1;\n    cinfo->MCU_membership[0] = 0;\n\n  } else {\n\n    /* Interleaved (multi-component) scan */\n    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)\n      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,\n               MAX_COMPS_IN_SCAN);\n\n    /* Overall image size in MCUs */\n    cinfo->MCUs_per_row = (JDIMENSION)\n      jdiv_round_up((long)cinfo->image_width,\n                    (long)(cinfo->max_h_samp_factor * data_unit));\n    cinfo->MCU_rows_in_scan = (JDIMENSION)\n      jdiv_round_up((long)cinfo->image_height,\n                    (long)(cinfo->max_v_samp_factor * data_unit));\n\n    cinfo->blocks_in_MCU = 0;\n\n    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n      compptr = cinfo->cur_comp_info[ci];\n      /* Sampling factors give # of data units of component in each MCU */\n      compptr->MCU_width = compptr->h_samp_factor;\n      compptr->MCU_height = compptr->v_samp_factor;\n      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;\n      compptr->MCU_sample_width = compptr->MCU_width *\n                                  compptr->_DCT_scaled_size;\n      /* Figure number of non-dummy data units in last MCU column & row */\n      tmp = (int)(compptr->width_in_blocks % compptr->MCU_width);\n      if (tmp == 0) tmp = compptr->MCU_width;\n      compptr->last_col_width = tmp;\n      tmp = (int)(compptr->height_in_blocks % compptr->MCU_height);\n      if (tmp == 0) tmp = compptr->MCU_height;\n      compptr->last_row_height = tmp;\n      /* Prepare array describing MCU composition */\n      mcublks = compptr->MCU_blocks;\n      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)\n        ERREXIT(cinfo, JERR_BAD_MCU_SIZE);\n      while (mcublks-- > 0) {\n        cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;\n      }\n    }\n\n  }\n}\n\n\n/*\n * Save away a copy of the Q-table referenced by each component present\n * in the current scan, unless already saved during a prior scan.\n *\n * In a multiple-scan JPEG file, the encoder could assign different components\n * the same Q-table slot number, but change table definitions between scans\n * so that each component uses a different Q-table.  (The IJG encoder is not\n * currently capable of doing this, but other encoders might.)  Since we want\n * to be able to dequantize all the components at the end of the file, this\n * means that we have to save away the table actually used for each component.\n * We do this by copying the table at the start of the first scan containing\n * the component.\n * Rec. ITU-T T.81 | ISO/IEC 10918-1 prohibits the encoder from changing the\n * contents of a Q-table slot between scans of a component using that slot.  If\n * the encoder does so anyway, this decoder will simply use the Q-table values\n * that were current at the start of the first scan for the component.\n *\n * The decompressor output side looks only at the saved quant tables,\n * not at the current Q-table slots.\n */\n\nLOCAL(void)\nlatch_quant_tables(j_decompress_ptr cinfo)\n{\n  int ci, qtblno;\n  jpeg_component_info *compptr;\n  JQUANT_TBL *qtbl;\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    /* No work if we already saved Q-table for this component */\n    if (compptr->quant_table != NULL)\n      continue;\n    /* Make sure specified quantization table is present */\n    qtblno = compptr->quant_tbl_no;\n    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||\n        cinfo->quant_tbl_ptrs[qtblno] == NULL)\n      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);\n    /* OK, save away the quantization table */\n    qtbl = (JQUANT_TBL *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  sizeof(JQUANT_TBL));\n    memcpy(qtbl, cinfo->quant_tbl_ptrs[qtblno], sizeof(JQUANT_TBL));\n    compptr->quant_table = qtbl;\n  }\n}\n\n\n/*\n * Initialize the input modules to read a scan of compressed data.\n * The first call to this is done by jdmaster.c after initializing\n * the entire decompressor (during jpeg_start_decompress).\n * Subsequent calls come from consume_markers, below.\n */\n\nMETHODDEF(void)\nstart_input_pass(j_decompress_ptr cinfo)\n{\n  per_scan_setup(cinfo);\n  if (!cinfo->master->lossless)\n    latch_quant_tables(cinfo);\n  (*cinfo->entropy->start_pass) (cinfo);\n  (*cinfo->coef->start_input_pass) (cinfo);\n  cinfo->inputctl->consume_input = cinfo->coef->consume_data;\n}\n\n\n/*\n * Finish up after inputting a compressed-data scan.\n * This is called by the coefficient or difference controller after it's read\n * all the expected data of the scan.\n */\n\nMETHODDEF(void)\nfinish_input_pass(j_decompress_ptr cinfo)\n{\n  cinfo->inputctl->consume_input = consume_markers;\n}\n\n\n/*\n * Read JPEG markers before, between, or after compressed-data scans.\n * Change state as necessary when a new scan is reached.\n * Return value is JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.\n *\n * The consume_input method pointer points either here or to the\n * coefficient or difference controller's consume_data routine, depending on\n * whether we are reading a compressed data segment or inter-segment markers.\n */\n\nMETHODDEF(int)\nconsume_markers(j_decompress_ptr cinfo)\n{\n  my_inputctl_ptr inputctl = (my_inputctl_ptr)cinfo->inputctl;\n  int val;\n\n  if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */\n    return JPEG_REACHED_EOI;\n\n  val = (*cinfo->marker->read_markers) (cinfo);\n\n  switch (val) {\n  case JPEG_REACHED_SOS:        /* Found SOS */\n    if (inputctl->inheaders) {  /* 1st SOS */\n      initial_setup(cinfo);\n      inputctl->inheaders = FALSE;\n      /* Note: start_input_pass must be called by jdmaster.c\n       * before any more input can be consumed.  jdapimin.c is\n       * responsible for enforcing this sequencing.\n       */\n    } else {                    /* 2nd or later SOS marker */\n      if (!inputctl->pub.has_multiple_scans)\n        ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */\n      start_input_pass(cinfo);\n    }\n    break;\n  case JPEG_REACHED_EOI:        /* Found EOI */\n    inputctl->pub.eoi_reached = TRUE;\n    if (inputctl->inheaders) {  /* Tables-only datastream, apparently */\n      if (cinfo->marker->saw_SOF)\n        ERREXIT(cinfo, JERR_SOF_NO_SOS);\n    } else {\n      /* Prevent infinite loop in coef ctlr's decompress_data routine\n       * if user set output_scan_number larger than number of scans.\n       */\n      if (cinfo->output_scan_number > cinfo->input_scan_number)\n        cinfo->output_scan_number = cinfo->input_scan_number;\n    }\n    break;\n  case JPEG_SUSPENDED:\n    break;\n  }\n\n  return val;\n}\n\n\n/*\n * Reset state to begin a fresh datastream.\n */\n\nMETHODDEF(void)\nreset_input_controller(j_decompress_ptr cinfo)\n{\n  my_inputctl_ptr inputctl = (my_inputctl_ptr)cinfo->inputctl;\n\n  inputctl->pub.consume_input = consume_markers;\n  inputctl->pub.has_multiple_scans = FALSE; /* \"unknown\" would be better */\n  inputctl->pub.eoi_reached = FALSE;\n  inputctl->inheaders = TRUE;\n  /* Reset other modules */\n  (*cinfo->err->reset_error_mgr) ((j_common_ptr)cinfo);\n  (*cinfo->marker->reset_marker_reader) (cinfo);\n  /* Reset progression state -- would be cleaner if entropy decoder did this */\n  cinfo->coef_bits = NULL;\n}\n\n\n/*\n * Initialize the input controller module.\n * This is called only once, when the decompression object is created.\n */\n\nGLOBAL(void)\njinit_input_controller(j_decompress_ptr cinfo)\n{\n  my_inputctl_ptr inputctl;\n\n  /* Create subobject in permanent pool */\n  inputctl = (my_inputctl_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_input_controller));\n  cinfo->inputctl = (struct jpeg_input_controller *)inputctl;\n  /* Initialize method pointers */\n  inputctl->pub.consume_input = consume_markers;\n  inputctl->pub.reset_input_controller = reset_input_controller;\n  inputctl->pub.start_input_pass = start_input_pass;\n  inputctl->pub.finish_input_pass = finish_input_pass;\n  /* Initialize state: can't use reset_input_controller since we don't\n   * want to try to reset other modules yet.\n   */\n  inputctl->pub.has_multiple_scans = FALSE; /* \"unknown\" would be better */\n  inputctl->pub.eoi_reached = FALSE;\n  inputctl->inheaders = TRUE;\n}\n"
        },
        {
          "name": "jdlhuff.c",
          "type": "blob",
          "size": 9.794921875,
          "content": "/*\n * jdlhuff.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains Huffman entropy decoding routines for lossless JPEG.\n *\n * Much of the complexity here has to do with supporting input suspension.\n * If the data source module demands suspension, we want to be able to back\n * up to the start of the current MCU.  To do this, we copy state variables\n * into local working storage, and update them back to the permanent\n * storage only upon successful completion of an MCU.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jlossls.h\"            /* Private declarations for lossless codec */\n#include \"jdhuff.h\"             /* Declarations shared with jd*huff.c */\n\n\n#ifdef D_LOSSLESS_SUPPORTED\n\ntypedef struct {\n  int ci, yoffset, MCU_width;\n} lhd_output_ptr_info;\n\n/*\n * Expanded entropy decoder object for Huffman decoding in lossless mode.\n */\n\ntypedef struct {\n  struct jpeg_entropy_decoder pub; /* public fields */\n\n  /* These fields are loaded into local variables at start of each MCU.\n   * In case of suspension, we exit WITHOUT updating them.\n   */\n  bitread_perm_state bitstate;  /* Bit buffer at start of MCU */\n\n  /* Pointers to derived tables (these workspaces have image lifespan) */\n  d_derived_tbl *derived_tbls[NUM_HUFF_TBLS];\n\n  /* Precalculated info set up by start_pass for use in decode_mcus: */\n\n  /* Pointers to derived tables to be used for each data unit within an MCU */\n  d_derived_tbl *cur_tbls[D_MAX_BLOCKS_IN_MCU];\n\n  /* Pointers to the proper output difference row for each group of data units\n   * within an MCU.  For each component, there are Vi groups of Hi data units.\n   */\n  JDIFFROW output_ptr[D_MAX_BLOCKS_IN_MCU];\n\n  /* Number of output pointers in use for the current MCU.  This is the sum\n   * of all Vi in the MCU.\n   */\n  int num_output_ptrs;\n\n  /* Information used for positioning the output pointers within the output\n   * difference rows.\n   */\n  lhd_output_ptr_info output_ptr_info[D_MAX_BLOCKS_IN_MCU];\n\n  /* Index of the proper output pointer for each data unit within an MCU */\n  int output_ptr_index[D_MAX_BLOCKS_IN_MCU];\n\n} lhuff_entropy_decoder;\n\ntypedef lhuff_entropy_decoder *lhuff_entropy_ptr;\n\n\n/*\n * Initialize for a Huffman-compressed scan.\n */\n\nMETHODDEF(void)\nstart_pass_lhuff_decoder(j_decompress_ptr cinfo)\n{\n  lhuff_entropy_ptr entropy = (lhuff_entropy_ptr)cinfo->entropy;\n  int ci, dctbl, sampn, ptrn, yoffset, xoffset;\n  jpeg_component_info *compptr;\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    dctbl = compptr->dc_tbl_no;\n    /* Make sure requested tables are present */\n    if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS ||\n        cinfo->dc_huff_tbl_ptrs[dctbl] == NULL)\n      ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);\n    /* Compute derived values for Huffman tables */\n    /* We may do this more than once for a table, but it's not expensive */\n    jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,\n                            &entropy->derived_tbls[dctbl]);\n  }\n\n  /* Precalculate decoding info for each sample in an MCU of this scan */\n  for (sampn = 0, ptrn = 0; sampn < cinfo->blocks_in_MCU;) {\n    compptr = cinfo->cur_comp_info[cinfo->MCU_membership[sampn]];\n    ci = compptr->component_index;\n    for (yoffset = 0; yoffset < compptr->MCU_height; yoffset++, ptrn++) {\n      /* Precalculate the setup info for each output pointer */\n      entropy->output_ptr_info[ptrn].ci = ci;\n      entropy->output_ptr_info[ptrn].yoffset = yoffset;\n      entropy->output_ptr_info[ptrn].MCU_width = compptr->MCU_width;\n      for (xoffset = 0; xoffset < compptr->MCU_width; xoffset++, sampn++) {\n        /* Precalculate the output pointer index for each sample */\n        entropy->output_ptr_index[sampn] = ptrn;\n        /* Precalculate which table to use for each sample */\n        entropy->cur_tbls[sampn] = entropy->derived_tbls[compptr->dc_tbl_no];\n      }\n    }\n  }\n  entropy->num_output_ptrs = ptrn;\n\n  /* Initialize bitread state variables */\n  entropy->bitstate.bits_left = 0;\n  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */\n  entropy->pub.insufficient_data = FALSE;\n}\n\n\n/*\n * Figure F.12: extend sign bit.\n * On some machines, a shift and add will be faster than a table lookup.\n */\n\n#define AVOID_TABLES\n#ifdef AVOID_TABLES\n\n#define NEG_1  ((unsigned int)-1)\n#define HUFF_EXTEND(x, s) \\\n  ((x) + ((((x) - (1 << ((s) - 1))) >> 31) & (((NEG_1) << (s)) + 1)))\n\n#else\n\n#define HUFF_EXTEND(x, s) \\\n  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))\n\nstatic const int extend_test[16] = {   /* entry n is 2**(n-1) */\n  0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,\n  0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000\n};\n\nstatic const int extend_offset[16] = { /* entry n is (-1 << n) + 1 */\n  0, ((-1) << 1) + 1, ((-1) << 2) + 1, ((-1) << 3) + 1, ((-1) << 4) + 1,\n  ((-1) << 5) + 1, ((-1) << 6) + 1, ((-1) << 7) + 1, ((-1) << 8) + 1,\n  ((-1) << 9) + 1, ((-1) << 10) + 1, ((-1) << 11) + 1, ((-1) << 12) + 1,\n  ((-1) << 13) + 1, ((-1) << 14) + 1, ((-1) << 15) + 1\n};\n\n#endif /* AVOID_TABLES */\n\n\n/*\n * Check for a restart marker & resynchronize decoder.\n * Returns FALSE if must suspend.\n */\n\nLOCAL(boolean)\nprocess_restart(j_decompress_ptr cinfo)\n{\n  lhuff_entropy_ptr entropy = (lhuff_entropy_ptr)cinfo->entropy;\n\n  /* Throw away any unused bits remaining in bit buffer; */\n  /* include any full bytes in next_marker's count of discarded bytes */\n  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;\n  entropy->bitstate.bits_left = 0;\n\n  /* Advance past the RSTn marker */\n  if (!(*cinfo->marker->read_restart_marker) (cinfo))\n    return FALSE;\n\n  /* Reset out-of-data flag, unless read_restart_marker left us smack up\n   * against a marker.  In that case we will end up treating the next data\n   * segment as empty, and we can avoid producing bogus output pixels by\n   * leaving the flag set.\n   */\n  if (cinfo->unread_marker == 0)\n    entropy->pub.insufficient_data = FALSE;\n\n  return TRUE;\n}\n\n\n/*\n * Decode and return nMCU MCUs' worth of Huffman-compressed differences.\n * Each MCU is also disassembled and placed accordingly in diff_buf.\n *\n * MCU_col_num specifies the column of the first MCU being requested within\n * the MCU row.  This tells us where to position the output row pointers in\n * diff_buf.\n *\n * Returns the number of MCUs decoded.  This may be less than nMCU MCUs if\n * data source requested suspension.  In that case no changes have been made\n * to permanent state.  (Exception: some output differences may already have\n * been assigned.  This is harmless for this module, since we'll just\n * re-assign them on the next call.)\n */\n\nMETHODDEF(JDIMENSION)\ndecode_mcus(j_decompress_ptr cinfo, JDIFFIMAGE diff_buf,\n            JDIMENSION MCU_row_num, JDIMENSION MCU_col_num, JDIMENSION nMCU)\n{\n  lhuff_entropy_ptr entropy = (lhuff_entropy_ptr)cinfo->entropy;\n  int sampn, ci, yoffset, MCU_width, ptrn;\n  JDIMENSION mcu_num;\n  BITREAD_STATE_VARS;\n\n  /* Set output pointer locations based on MCU_col_num */\n  for (ptrn = 0; ptrn < entropy->num_output_ptrs; ptrn++) {\n    ci = entropy->output_ptr_info[ptrn].ci;\n    yoffset = entropy->output_ptr_info[ptrn].yoffset;\n    MCU_width = entropy->output_ptr_info[ptrn].MCU_width;\n    entropy->output_ptr[ptrn] =\n      diff_buf[ci][MCU_row_num + yoffset] + (MCU_col_num * MCU_width);\n  }\n\n  /*\n   * If we've run out of data, zero out the buffers and return.\n   * By resetting the undifferencer, the output samples will be CENTERJSAMPLE.\n   *\n   * NB: We should find a way to do this without interacting with the\n   * undifferencer module directly.\n   */\n  if (entropy->pub.insufficient_data) {\n    for (ptrn = 0; ptrn < entropy->num_output_ptrs; ptrn++)\n      jzero_far((void FAR *)entropy->output_ptr[ptrn],\n                nMCU * entropy->output_ptr_info[ptrn].MCU_width *\n                sizeof(JDIFF));\n\n    (*cinfo->idct->start_pass) (cinfo);\n\n  } else {\n\n    /* Load up working state */\n    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);\n\n    /* Outer loop handles the number of MCUs requested */\n\n    for (mcu_num = 0; mcu_num < nMCU; mcu_num++) {\n\n      /* Inner loop handles the samples in the MCU */\n      for (sampn = 0; sampn < cinfo->blocks_in_MCU; sampn++) {\n        d_derived_tbl *dctbl = entropy->cur_tbls[sampn];\n        register int s, r;\n\n        /* Section H.2.2: decode the sample difference */\n        HUFF_DECODE(s, br_state, dctbl, return mcu_num, label1);\n        if (s) {\n          if (s == 16)  /* special case: always output 32768 */\n            s = 32768;\n          else {        /* normal case: fetch subsequent bits */\n            CHECK_BIT_BUFFER(br_state, s, return mcu_num);\n            r = GET_BITS(s);\n            s = HUFF_EXTEND(r, s);\n          }\n        }\n\n        /* Output the sample difference */\n        *entropy->output_ptr[entropy->output_ptr_index[sampn]]++ = (JDIFF)s;\n      }\n\n      /* Completed MCU, so update state */\n      BITREAD_SAVE_STATE(cinfo, entropy->bitstate);\n    }\n  }\n\n return nMCU;\n}\n\n\n/*\n * Module initialization routine for lossless mode Huffman entropy decoding.\n */\n\nGLOBAL(void)\njinit_lhuff_decoder(j_decompress_ptr cinfo)\n{\n  lhuff_entropy_ptr entropy;\n  int i;\n\n  entropy = (lhuff_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(lhuff_entropy_decoder));\n  cinfo->entropy = (struct jpeg_entropy_decoder *)entropy;\n  entropy->pub.start_pass = start_pass_lhuff_decoder;\n  entropy->pub.decode_mcus = decode_mcus;\n  entropy->pub.process_restart = process_restart;\n\n  /* Mark tables unallocated */\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    entropy->derived_tbls[i] = NULL;\n  }\n}\n\n#endif /* D_LOSSLESS_SUPPORTED */\n"
        },
        {
          "name": "jdlossls.c",
          "type": "blob",
          "size": 8.322265625,
          "content": "/*\n * jdlossls.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1998, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains prediction, sample undifferencing, point transform, and\n * sample scaling routines for the lossless JPEG decompressor.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jlossls.h\"\n\n#ifdef D_LOSSLESS_SUPPORTED\n\n\n/**************** Sample undifferencing (reconstruction) *****************/\n\n/*\n * In order to avoid a performance penalty for checking which predictor is\n * being used and which row is being processed for each call of the\n * undifferencer, and to promote optimization, we have separate undifferencing\n * functions for each predictor selection value.\n *\n * We are able to avoid duplicating source code by implementing the predictors\n * and undifferencers as macros.  Each of the undifferencing functions is\n * simply a wrapper around an UNDIFFERENCE macro with the appropriate PREDICTOR\n * macro passed as an argument.\n */\n\n/* Predictor for the first column of the first row: 2^(P-Pt-1) */\n#define INITIAL_PREDICTORx  (1 << (cinfo->data_precision - cinfo->Al - 1))\n\n/* Predictor for the first column of the remaining rows: Rb */\n#define INITIAL_PREDICTOR2  prev_row[0]\n\n\n/*\n * 1-Dimensional undifferencer routine.\n *\n * This macro implements the 1-D horizontal predictor (1).  INITIAL_PREDICTOR\n * is used as the special case predictor for the first column, which must be\n * either INITIAL_PREDICTOR2 or INITIAL_PREDICTORx.  The remaining samples\n * use PREDICTOR1.\n *\n * The reconstructed sample is supposed to be calculated modulo 2^16, so we\n * logically AND the result with 0xFFFF.\n */\n\n#define UNDIFFERENCE_1D(INITIAL_PREDICTOR) \\\n  int Ra; \\\n  \\\n  Ra = (*diff_buf++ + INITIAL_PREDICTOR) & 0xFFFF; \\\n  *undiff_buf++ = Ra; \\\n  \\\n  while (--width) { \\\n    Ra = (*diff_buf++ + PREDICTOR1) & 0xFFFF; \\\n    *undiff_buf++ = Ra; \\\n  }\n\n\n/*\n * 2-Dimensional undifferencer routine.\n *\n * This macro implements the 2-D horizontal predictors (#2-7).  PREDICTOR2 is\n * used as the special case predictor for the first column.  The remaining\n * samples use PREDICTOR, which is a function of Ra, Rb, and Rc.\n *\n * Because prev_row and output_buf may point to the same storage area (in an\n * interleaved image with Vi=1, for example), we must take care to buffer Rb/Rc\n * before writing the current reconstructed sample value into output_buf.\n *\n * The reconstructed sample is supposed to be calculated modulo 2^16, so we\n * logically AND the result with 0xFFFF.\n */\n\n#define UNDIFFERENCE_2D(PREDICTOR) \\\n  int Ra, Rb, Rc; \\\n  \\\n  Rb = *prev_row++; \\\n  Ra = (*diff_buf++ + PREDICTOR2) & 0xFFFF; \\\n  *undiff_buf++ = Ra; \\\n  \\\n  while (--width) { \\\n    Rc = Rb; \\\n    Rb = *prev_row++; \\\n    Ra = (*diff_buf++ + PREDICTOR) & 0xFFFF; \\\n    *undiff_buf++ = Ra; \\\n  }\n\n\n/*\n * Undifferencers for the second and subsequent rows in a scan or restart\n * interval.  The first sample in the row is undifferenced using the vertical\n * predictor (2).  The rest of the samples are undifferenced using the\n * predictor specified in the scan header.\n */\n\nMETHODDEF(void)\njpeg_undifference1(j_decompress_ptr cinfo, int comp_index,\n                   JDIFFROW diff_buf, JDIFFROW prev_row,\n                   JDIFFROW undiff_buf, JDIMENSION width)\n{\n  UNDIFFERENCE_1D(INITIAL_PREDICTOR2);\n}\n\nMETHODDEF(void)\njpeg_undifference2(j_decompress_ptr cinfo, int comp_index,\n                   JDIFFROW diff_buf, JDIFFROW prev_row,\n                   JDIFFROW undiff_buf, JDIMENSION width)\n{\n  UNDIFFERENCE_2D(PREDICTOR2);\n  (void)(Rc);\n}\n\nMETHODDEF(void)\njpeg_undifference3(j_decompress_ptr cinfo, int comp_index,\n                   JDIFFROW diff_buf, JDIFFROW prev_row,\n                   JDIFFROW undiff_buf, JDIMENSION width)\n{\n  UNDIFFERENCE_2D(PREDICTOR3);\n}\n\nMETHODDEF(void)\njpeg_undifference4(j_decompress_ptr cinfo, int comp_index,\n                   JDIFFROW diff_buf, JDIFFROW prev_row,\n                   JDIFFROW undiff_buf, JDIMENSION width)\n{\n  UNDIFFERENCE_2D(PREDICTOR4);\n}\n\nMETHODDEF(void)\njpeg_undifference5(j_decompress_ptr cinfo, int comp_index,\n                   JDIFFROW diff_buf, JDIFFROW prev_row,\n                   JDIFFROW undiff_buf, JDIMENSION width)\n{\n  UNDIFFERENCE_2D(PREDICTOR5);\n}\n\nMETHODDEF(void)\njpeg_undifference6(j_decompress_ptr cinfo, int comp_index,\n                   JDIFFROW diff_buf, JDIFFROW prev_row,\n                   JDIFFROW undiff_buf, JDIMENSION width)\n{\n  UNDIFFERENCE_2D(PREDICTOR6);\n}\n\nMETHODDEF(void)\njpeg_undifference7(j_decompress_ptr cinfo, int comp_index,\n                   JDIFFROW diff_buf, JDIFFROW prev_row,\n                   JDIFFROW undiff_buf, JDIMENSION width)\n{\n  UNDIFFERENCE_2D(PREDICTOR7);\n  (void)(Rc);\n}\n\n\n/*\n * Undifferencer for the first row in a scan or restart interval.  The first\n * sample in the row is undifferenced using the special predictor constant\n * x=2^(P-Pt-1).  The rest of the samples are undifferenced using the\n * 1-D horizontal predictor (1).\n */\n\nMETHODDEF(void)\njpeg_undifference_first_row(j_decompress_ptr cinfo, int comp_index,\n                            JDIFFROW diff_buf, JDIFFROW prev_row,\n                            JDIFFROW undiff_buf, JDIMENSION width)\n{\n  lossless_decomp_ptr losslessd = (lossless_decomp_ptr)cinfo->idct;\n\n  UNDIFFERENCE_1D(INITIAL_PREDICTORx);\n\n  /*\n   * Now that we have undifferenced the first row, we want to use the\n   * undifferencer that corresponds to the predictor specified in the\n   * scan header.\n   */\n  switch (cinfo->Ss) {\n  case 1:\n    losslessd->predict_undifference[comp_index] = jpeg_undifference1;\n    break;\n  case 2:\n    losslessd->predict_undifference[comp_index] = jpeg_undifference2;\n    break;\n  case 3:\n    losslessd->predict_undifference[comp_index] = jpeg_undifference3;\n    break;\n  case 4:\n    losslessd->predict_undifference[comp_index] = jpeg_undifference4;\n    break;\n  case 5:\n    losslessd->predict_undifference[comp_index] = jpeg_undifference5;\n    break;\n  case 6:\n    losslessd->predict_undifference[comp_index] = jpeg_undifference6;\n    break;\n  case 7:\n    losslessd->predict_undifference[comp_index] = jpeg_undifference7;\n    break;\n  }\n}\n\n\n/*********************** Sample upscaling by 2^Pt ************************/\n\nMETHODDEF(void)\nsimple_upscale(j_decompress_ptr cinfo,\n               JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  do {\n    *output_buf++ = (_JSAMPLE)(*diff_buf++ << cinfo->Al);\n  } while (--width);\n}\n\nMETHODDEF(void)\nnoscale(j_decompress_ptr cinfo,\n        JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  do {\n    *output_buf++ = (_JSAMPLE)(*diff_buf++);\n  } while (--width);\n}\n\n\n/*\n * Initialize for an input processing pass.\n */\n\nMETHODDEF(void)\nstart_pass_lossless(j_decompress_ptr cinfo)\n{\n  lossless_decomp_ptr losslessd = (lossless_decomp_ptr)cinfo->idct;\n  int ci;\n\n  /* Check that the scan parameters Ss, Se, Ah, Al are OK for lossless JPEG.\n   *\n   * Ss is the predictor selection value (psv).  Legal values for sequential\n   * lossless JPEG are: 1 <= psv <= 7.\n   *\n   * Se and Ah are not used and should be zero.\n   *\n   * Al specifies the point transform (Pt).\n   * Legal values are: 0 <= Pt <= (data precision - 1).\n   */\n  if (cinfo->Ss < 1 || cinfo->Ss > 7 ||\n      cinfo->Se != 0 || cinfo->Ah != 0 ||\n      cinfo->Al < 0 || cinfo->Al >= cinfo->data_precision)\n    ERREXIT4(cinfo, JERR_BAD_PROGRESSION,\n             cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);\n\n  /* Set undifference functions to first row function */\n  for (ci = 0; ci < cinfo->num_components; ci++)\n    losslessd->predict_undifference[ci] = jpeg_undifference_first_row;\n\n  /* Set scaler function based on Pt */\n  if (cinfo->Al)\n    losslessd->scaler_scale = simple_upscale;\n  else\n    losslessd->scaler_scale = noscale;\n}\n\n\n/*\n * Initialize the lossless decompressor.\n */\n\nGLOBAL(void)\n_jinit_lossless_decompressor(j_decompress_ptr cinfo)\n{\n  lossless_decomp_ptr losslessd;\n\n  /* Create subobject in permanent pool */\n  losslessd = (lossless_decomp_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(jpeg_lossless_decompressor));\n  cinfo->idct = (struct jpeg_inverse_dct *)losslessd;\n  losslessd->pub.start_pass = start_pass_lossless;\n}\n\n#endif /* D_LOSSLESS_SUPPORTED */\n"
        },
        {
          "name": "jdmainct.c",
          "type": "blob",
          "size": 19.7529296875,
          "content": "/*\n * jdmainct.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010, 2016, 2022, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the main buffer controller for decompression.\n * The main buffer lies between the JPEG decompressor proper and the\n * post-processor; it holds downsampled data in the JPEG colorspace.\n *\n * Note that this code is bypassed in raw-data mode, since the application\n * supplies the equivalent of the main buffer in that case.\n */\n\n#include \"jinclude.h\"\n#include \"jdmainct.h\"\n\n\n#if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)\n\n/*\n * In the current system design, the main buffer need never be a full-image\n * buffer; any full-height buffers will be found inside the coefficient,\n * difference, or postprocessing controllers.  Nonetheless, the main controller\n * is not trivial.  Its responsibility is to provide context rows for\n * upsampling/rescaling, and doing this in an efficient fashion is a bit\n * tricky.\n *\n * Postprocessor input data is counted in \"row groups\".  A row group\n * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)\n * sample rows of each component.  (We require DCT_scaled_size values to be\n * chosen such that these numbers are integers.  In practice DCT_scaled_size\n * values will likely be powers of two, so we actually have the stronger\n * condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)\n * Upsampling will typically produce max_v_samp_factor pixel rows from each\n * row group (times any additional scale factor that the upsampler is\n * applying).\n *\n * The coefficient or difference controller will deliver data to us one iMCU\n * row at a time; each iMCU row contains v_samp_factor * DCT_scaled_size sample\n * rows, or exactly min_DCT_scaled_size row groups.  (This amount of data\n * corresponds to one row of MCUs when the image is fully interleaved.)  Note\n * that the number of sample rows varies across components, but the number of\n * row groups does not.  Some garbage sample rows may be included in the last\n * iMCU row at the bottom of the image.\n *\n * Depending on the vertical scaling algorithm used, the upsampler may need\n * access to the sample row(s) above and below its current input row group.\n * The upsampler is required to set need_context_rows TRUE at global selection\n * time if so.  When need_context_rows is FALSE, this controller can simply\n * obtain one iMCU row at a time from the coefficient or difference controller\n * and dole it out as row groups to the postprocessor.\n *\n * When need_context_rows is TRUE, this controller guarantees that the buffer\n * passed to postprocessing contains at least one row group's worth of samples\n * above and below the row group(s) being processed.  Note that the context\n * rows \"above\" the first passed row group appear at negative row offsets in\n * the passed buffer.  At the top and bottom of the image, the required\n * context rows are manufactured by duplicating the first or last real sample\n * row; this avoids having special cases in the upsampling inner loops.\n *\n * The amount of context is fixed at one row group just because that's a\n * convenient number for this controller to work with.  The existing\n * upsamplers really only need one sample row of context.  An upsampler\n * supporting arbitrary output rescaling might wish for more than one row\n * group of context when shrinking the image; tough, we don't handle that.\n * (This is justified by the assumption that downsizing will be handled mostly\n * by adjusting the DCT_scaled_size values, so that the actual scale factor at\n * the upsample step needn't be much less than one.)\n *\n * To provide the desired context, we have to retain the last two row groups\n * of one iMCU row while reading in the next iMCU row.  (The last row group\n * can't be processed until we have another row group for its below-context,\n * and so we have to save the next-to-last group too for its above-context.)\n * We could do this most simply by copying data around in our buffer, but\n * that'd be very slow.  We can avoid copying any data by creating a rather\n * strange pointer structure.  Here's how it works.  We allocate a workspace\n * consisting of M+2 row groups (where M = min_DCT_scaled_size is the number\n * of row groups per iMCU row).  We create two sets of redundant pointers to\n * the workspace.  Labeling the physical row groups 0 to M+1, the synthesized\n * pointer lists look like this:\n *                   M+1                          M-1\n * master pointer --> 0         master pointer --> 0\n *                    1                            1\n *                   ...                          ...\n *                   M-3                          M-3\n *                   M-2                           M\n *                   M-1                          M+1\n *                    M                           M-2\n *                   M+1                          M-1\n *                    0                            0\n * We read alternate iMCU rows using each master pointer; thus the last two\n * row groups of the previous iMCU row remain un-overwritten in the workspace.\n * The pointer lists are set up so that the required context rows appear to\n * be adjacent to the proper places when we pass the pointer lists to the\n * upsampler.\n *\n * The above pictures describe the normal state of the pointer lists.\n * At top and bottom of the image, we diddle the pointer lists to duplicate\n * the first or last sample row as necessary (this is cheaper than copying\n * sample rows around).\n *\n * This scheme breaks down if M < 2, ie, min_DCT_scaled_size is 1.  In that\n * situation each iMCU row provides only one row group so the buffering logic\n * must be different (eg, we must read two iMCU rows before we can emit the\n * first row group).  For now, we simply do not support providing context\n * rows when min_DCT_scaled_size is 1.  That combination seems unlikely to\n * be worth providing --- if someone wants a 1/8th-size preview, they probably\n * want it quick and dirty, so a context-free upsampler is sufficient.\n */\n\n\n/* Forward declarations */\nMETHODDEF(void) process_data_simple_main(j_decompress_ptr cinfo,\n                                         _JSAMPARRAY output_buf,\n                                         JDIMENSION *out_row_ctr,\n                                         JDIMENSION out_rows_avail);\nMETHODDEF(void) process_data_context_main(j_decompress_ptr cinfo,\n                                          _JSAMPARRAY output_buf,\n                                          JDIMENSION *out_row_ctr,\n                                          JDIMENSION out_rows_avail);\n#ifdef QUANT_2PASS_SUPPORTED\nMETHODDEF(void) process_data_crank_post(j_decompress_ptr cinfo,\n                                        _JSAMPARRAY output_buf,\n                                        JDIMENSION *out_row_ctr,\n                                        JDIMENSION out_rows_avail);\n#endif\n\n\nLOCAL(void)\nalloc_funny_pointers(j_decompress_ptr cinfo)\n/* Allocate space for the funny pointer lists.\n * This is done only once, not once per pass.\n */\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  int ci, rgroup;\n  int M = cinfo->_min_DCT_scaled_size;\n  jpeg_component_info *compptr;\n  _JSAMPARRAY xbuf;\n\n  /* Get top-level space for component array pointers.\n   * We alloc both arrays with one call to save a few cycles.\n   */\n  main_ptr->xbuffer[0] = (_JSAMPIMAGE)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                cinfo->num_components * 2 *\n                                sizeof(_JSAMPARRAY));\n  main_ptr->xbuffer[1] = main_ptr->xbuffer[0] + cinfo->num_components;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    rgroup = (compptr->v_samp_factor * compptr->_DCT_scaled_size) /\n      cinfo->_min_DCT_scaled_size; /* height of a row group of component */\n    /* Get space for pointer lists --- M+4 row groups in each list.\n     * We alloc both pointer lists with one call to save a few cycles.\n     */\n    xbuf = (_JSAMPARRAY)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  2 * (rgroup * (M + 4)) * sizeof(_JSAMPROW));\n    xbuf += rgroup;             /* want one row group at negative offsets */\n    main_ptr->xbuffer[0][ci] = xbuf;\n    xbuf += rgroup * (M + 4);\n    main_ptr->xbuffer[1][ci] = xbuf;\n  }\n}\n\n\nLOCAL(void)\nmake_funny_pointers(j_decompress_ptr cinfo)\n/* Create the funny pointer lists discussed in the comments above.\n * The actual workspace is already allocated (in main_ptr->buffer),\n * and the space for the pointer lists is allocated too.\n * This routine just fills in the curiously ordered lists.\n * This will be repeated at the beginning of each pass.\n */\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  int ci, i, rgroup;\n  int M = cinfo->_min_DCT_scaled_size;\n  jpeg_component_info *compptr;\n  _JSAMPARRAY buf, xbuf0, xbuf1;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    rgroup = (compptr->v_samp_factor * compptr->_DCT_scaled_size) /\n      cinfo->_min_DCT_scaled_size; /* height of a row group of component */\n    xbuf0 = main_ptr->xbuffer[0][ci];\n    xbuf1 = main_ptr->xbuffer[1][ci];\n    /* First copy the workspace pointers as-is */\n    buf = main_ptr->buffer[ci];\n    for (i = 0; i < rgroup * (M + 2); i++) {\n      xbuf0[i] = xbuf1[i] = buf[i];\n    }\n    /* In the second list, put the last four row groups in swapped order */\n    for (i = 0; i < rgroup * 2; i++) {\n      xbuf1[rgroup * (M - 2) + i] = buf[rgroup * M + i];\n      xbuf1[rgroup * M + i] = buf[rgroup * (M - 2) + i];\n    }\n    /* The wraparound pointers at top and bottom will be filled later\n     * (see set_wraparound_pointers, below).  Initially we want the \"above\"\n     * pointers to duplicate the first actual data line.  This only needs\n     * to happen in xbuffer[0].\n     */\n    for (i = 0; i < rgroup; i++) {\n      xbuf0[i - rgroup] = xbuf0[0];\n    }\n  }\n}\n\n\nLOCAL(void)\nset_bottom_pointers(j_decompress_ptr cinfo)\n/* Change the pointer lists to duplicate the last sample row at the bottom\n * of the image.  whichptr indicates which xbuffer holds the final iMCU row.\n * Also sets rowgroups_avail to indicate number of nondummy row groups in row.\n */\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  int ci, i, rgroup, iMCUheight, rows_left;\n  jpeg_component_info *compptr;\n  _JSAMPARRAY xbuf;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Count sample rows in one iMCU row and in one row group */\n    iMCUheight = compptr->v_samp_factor * compptr->_DCT_scaled_size;\n    rgroup = iMCUheight / cinfo->_min_DCT_scaled_size;\n    /* Count nondummy sample rows remaining for this component */\n    rows_left = (int)(compptr->downsampled_height % (JDIMENSION)iMCUheight);\n    if (rows_left == 0) rows_left = iMCUheight;\n    /* Count nondummy row groups.  Should get same answer for each component,\n     * so we need only do it once.\n     */\n    if (ci == 0) {\n      main_ptr->rowgroups_avail = (JDIMENSION)((rows_left - 1) / rgroup + 1);\n    }\n    /* Duplicate the last real sample row rgroup*2 times; this pads out the\n     * last partial rowgroup and ensures at least one full rowgroup of context.\n     */\n    xbuf = main_ptr->xbuffer[main_ptr->whichptr][ci];\n    for (i = 0; i < rgroup * 2; i++) {\n      xbuf[rows_left + i] = xbuf[rows_left - 1];\n    }\n  }\n}\n\n\n/*\n * Initialize for a processing pass.\n */\n\nMETHODDEF(void)\nstart_pass_main(j_decompress_ptr cinfo, J_BUF_MODE pass_mode)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n\n  switch (pass_mode) {\n  case JBUF_PASS_THRU:\n    if (cinfo->upsample->need_context_rows) {\n      main_ptr->pub._process_data = process_data_context_main;\n      make_funny_pointers(cinfo); /* Create the xbuffer[] lists */\n      main_ptr->whichptr = 0;   /* Read first iMCU row into xbuffer[0] */\n      main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n      main_ptr->iMCU_row_ctr = 0;\n    } else {\n      /* Simple case with no context needed */\n      main_ptr->pub._process_data = process_data_simple_main;\n    }\n    main_ptr->buffer_full = FALSE;      /* Mark buffer empty */\n    main_ptr->rowgroup_ctr = 0;\n    break;\n#ifdef QUANT_2PASS_SUPPORTED\n  case JBUF_CRANK_DEST:\n    /* For last pass of 2-pass quantization, just crank the postprocessor */\n    main_ptr->pub._process_data = process_data_crank_post;\n    break;\n#endif\n  default:\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    break;\n  }\n}\n\n\n/*\n * Process some data.\n * This handles the simple case where no context is required.\n */\n\nMETHODDEF(void)\nprocess_data_simple_main(j_decompress_ptr cinfo, _JSAMPARRAY output_buf,\n                         JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  JDIMENSION rowgroups_avail;\n\n  /* Read input data if we haven't filled the main buffer yet */\n  if (!main_ptr->buffer_full) {\n    if (!(*cinfo->coef->_decompress_data) (cinfo, main_ptr->buffer))\n      return;                   /* suspension forced, can do nothing more */\n    main_ptr->buffer_full = TRUE;       /* OK, we have an iMCU row to work with */\n  }\n\n  /* There are always min_DCT_scaled_size row groups in an iMCU row. */\n  rowgroups_avail = (JDIMENSION)cinfo->_min_DCT_scaled_size;\n  /* Note: at the bottom of the image, we may pass extra garbage row groups\n   * to the postprocessor.  The postprocessor has to check for bottom\n   * of image anyway (at row resolution), so no point in us doing it too.\n   */\n\n  /* Feed the postprocessor */\n  (*cinfo->post->_post_process_data) (cinfo, main_ptr->buffer,\n                                      &main_ptr->rowgroup_ctr, rowgroups_avail,\n                                      output_buf, out_row_ctr, out_rows_avail);\n\n  /* Has postprocessor consumed all the data yet? If so, mark buffer empty */\n  if (main_ptr->rowgroup_ctr >= rowgroups_avail) {\n    main_ptr->buffer_full = FALSE;\n    main_ptr->rowgroup_ctr = 0;\n  }\n}\n\n\n/*\n * Process some data.\n * This handles the case where context rows must be provided.\n */\n\nMETHODDEF(void)\nprocess_data_context_main(j_decompress_ptr cinfo, _JSAMPARRAY output_buf,\n                          JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n\n  /* Read input data if we haven't filled the main buffer yet */\n  if (!main_ptr->buffer_full) {\n    if (!(*cinfo->coef->_decompress_data) (cinfo,\n                                           main_ptr->xbuffer[main_ptr->whichptr]))\n      return;                   /* suspension forced, can do nothing more */\n    main_ptr->buffer_full = TRUE;       /* OK, we have an iMCU row to work with */\n    main_ptr->iMCU_row_ctr++;   /* count rows received */\n  }\n\n  /* Postprocessor typically will not swallow all the input data it is handed\n   * in one call (due to filling the output buffer first).  Must be prepared\n   * to exit and restart.  This switch lets us keep track of how far we got.\n   * Note that each case falls through to the next on successful completion.\n   */\n  switch (main_ptr->context_state) {\n  case CTX_POSTPONED_ROW:\n    /* Call postprocessor using previously set pointers for postponed row */\n    (*cinfo->post->_post_process_data) (cinfo,\n                                        main_ptr->xbuffer[main_ptr->whichptr],\n                                        &main_ptr->rowgroup_ctr,\n                                        main_ptr->rowgroups_avail, output_buf,\n                                        out_row_ctr, out_rows_avail);\n    if (main_ptr->rowgroup_ctr < main_ptr->rowgroups_avail)\n      return;                   /* Need to suspend */\n    main_ptr->context_state = CTX_PREPARE_FOR_IMCU;\n    if (*out_row_ctr >= out_rows_avail)\n      return;                   /* Postprocessor exactly filled output buf */\n    FALLTHROUGH                 /*FALLTHROUGH*/\n  case CTX_PREPARE_FOR_IMCU:\n    /* Prepare to process first M-1 row groups of this iMCU row */\n    main_ptr->rowgroup_ctr = 0;\n    main_ptr->rowgroups_avail = (JDIMENSION)(cinfo->_min_DCT_scaled_size - 1);\n    /* Check for bottom of image: if so, tweak pointers to \"duplicate\"\n     * the last sample row, and adjust rowgroups_avail to ignore padding rows.\n     */\n    if (main_ptr->iMCU_row_ctr == cinfo->total_iMCU_rows)\n      set_bottom_pointers(cinfo);\n    main_ptr->context_state = CTX_PROCESS_IMCU;\n    FALLTHROUGH                 /*FALLTHROUGH*/\n  case CTX_PROCESS_IMCU:\n    /* Call postprocessor using previously set pointers */\n    (*cinfo->post->_post_process_data) (cinfo,\n                                        main_ptr->xbuffer[main_ptr->whichptr],\n                                        &main_ptr->rowgroup_ctr,\n                                        main_ptr->rowgroups_avail, output_buf,\n                                        out_row_ctr, out_rows_avail);\n    if (main_ptr->rowgroup_ctr < main_ptr->rowgroups_avail)\n      return;                   /* Need to suspend */\n    /* After the first iMCU, change wraparound pointers to normal state */\n    if (main_ptr->iMCU_row_ctr == 1)\n      set_wraparound_pointers(cinfo);\n    /* Prepare to load new iMCU row using other xbuffer list */\n    main_ptr->whichptr ^= 1;    /* 0=>1 or 1=>0 */\n    main_ptr->buffer_full = FALSE;\n    /* Still need to process last row group of this iMCU row, */\n    /* which is saved at index M+1 of the other xbuffer */\n    main_ptr->rowgroup_ctr = (JDIMENSION)(cinfo->_min_DCT_scaled_size + 1);\n    main_ptr->rowgroups_avail = (JDIMENSION)(cinfo->_min_DCT_scaled_size + 2);\n    main_ptr->context_state = CTX_POSTPONED_ROW;\n  }\n}\n\n\n/*\n * Process some data.\n * Final pass of two-pass quantization: just call the postprocessor.\n * Source data will be the postprocessor controller's internal buffer.\n */\n\n#ifdef QUANT_2PASS_SUPPORTED\n\nMETHODDEF(void)\nprocess_data_crank_post(j_decompress_ptr cinfo, _JSAMPARRAY output_buf,\n                        JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  (*cinfo->post->_post_process_data) (cinfo, (_JSAMPIMAGE)NULL,\n                                      (JDIMENSION *)NULL, (JDIMENSION)0,\n                                      output_buf, out_row_ctr, out_rows_avail);\n}\n\n#endif /* QUANT_2PASS_SUPPORTED */\n\n\n/*\n * Initialize main buffer controller.\n */\n\nGLOBAL(void)\n_jinit_d_main_controller(j_decompress_ptr cinfo, boolean need_full_buffer)\n{\n  my_main_ptr main_ptr;\n  int ci, rgroup, ngroups;\n  jpeg_component_info *compptr;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  main_ptr = (my_main_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_main_controller));\n  memset(main_ptr, 0, sizeof(my_main_controller));\n  cinfo->main = (struct jpeg_d_main_controller *)main_ptr;\n  main_ptr->pub.start_pass = start_pass_main;\n\n  if (need_full_buffer)         /* shouldn't happen */\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n\n  /* Allocate the workspace.\n   * ngroups is the number of row groups we need.\n   */\n  if (cinfo->upsample->need_context_rows) {\n    if (cinfo->_min_DCT_scaled_size < 2) /* unsupported, see comments above */\n      ERREXIT(cinfo, JERR_NOTIMPL);\n    alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */\n    ngroups = cinfo->_min_DCT_scaled_size + 2;\n  } else {\n    ngroups = cinfo->_min_DCT_scaled_size;\n  }\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    rgroup = (compptr->v_samp_factor * compptr->_DCT_scaled_size) /\n      cinfo->_min_DCT_scaled_size; /* height of a row group of component */\n    main_ptr->buffer[ci] = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n                        ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                         compptr->width_in_blocks * compptr->_DCT_scaled_size,\n                         (JDIMENSION)(rgroup * ngroups));\n  }\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED) */\n"
        },
        {
          "name": "jdmainct.h",
          "type": "blob",
          "size": 2.6162109375,
          "content": "/*\n * jdmainct.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n */\n\n#define JPEG_INTERNALS\n#include \"jpeglib.h\"\n#include \"jpegapicomp.h\"\n#include \"jsamplecomp.h\"\n\n\n#if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)\n\n/* Private buffer controller object */\n\ntypedef struct {\n  struct jpeg_d_main_controller pub; /* public fields */\n\n  /* Pointer to allocated workspace (M or M+2 row groups). */\n  _JSAMPARRAY buffer[MAX_COMPONENTS];\n\n  boolean buffer_full;          /* Have we gotten an iMCU row from decoder? */\n  JDIMENSION rowgroup_ctr;      /* counts row groups output to postprocessor */\n\n  /* Remaining fields are only used in the context case. */\n\n  /* These are the master pointers to the funny-order pointer lists. */\n  _JSAMPIMAGE xbuffer[2];       /* pointers to weird pointer lists */\n\n  int whichptr;                 /* indicates which pointer set is now in use */\n  int context_state;            /* process_data state machine status */\n  JDIMENSION rowgroups_avail;   /* row groups available to postprocessor */\n  JDIMENSION iMCU_row_ctr;      /* counts iMCU rows to detect image top/bot */\n} my_main_controller;\n\ntypedef my_main_controller *my_main_ptr;\n\n\n/* context_state values: */\n#define CTX_PREPARE_FOR_IMCU    0       /* need to prepare for MCU row */\n#define CTX_PROCESS_IMCU        1       /* feeding iMCU to postprocessor */\n#define CTX_POSTPONED_ROW       2       /* feeding postponed row group */\n\n\nLOCAL(void)\nset_wraparound_pointers(j_decompress_ptr cinfo)\n/* Set up the \"wraparound\" pointers at top and bottom of the pointer lists.\n * This changes the pointer list state from top-of-image to the normal state.\n */\n{\n  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;\n  int ci, i, rgroup;\n  int M = cinfo->_min_DCT_scaled_size;\n  jpeg_component_info *compptr;\n  _JSAMPARRAY xbuf0, xbuf1;\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    rgroup = (compptr->v_samp_factor * compptr->_DCT_scaled_size) /\n      cinfo->_min_DCT_scaled_size; /* height of a row group of component */\n    xbuf0 = main_ptr->xbuffer[0][ci];\n    xbuf1 = main_ptr->xbuffer[1][ci];\n    for (i = 0; i < rgroup; i++) {\n      xbuf0[i - rgroup] = xbuf0[rgroup * (M + 1) + i];\n      xbuf1[i - rgroup] = xbuf1[rgroup * (M + 1) + i];\n      xbuf0[rgroup * (M + 2) + i] = xbuf0[i];\n      xbuf1[rgroup * (M + 2) + i] = xbuf1[i];\n    }\n  }\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED) */\n"
        },
        {
          "name": "jdmarker.c",
          "type": "blob",
          "size": 41.611328125,
          "content": "/*\n * jdmarker.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1998, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2012, 2015, 2022, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to decode JPEG datastream markers.\n * Most of the complexity arises from our desire to support input\n * suspension: if not all of the data for a marker is available,\n * we must exit back to the application.  On resumption, we reprocess\n * the marker.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n\n\ntypedef enum {                  /* JPEG marker codes */\n  M_SOF0  = 0xc0,\n  M_SOF1  = 0xc1,\n  M_SOF2  = 0xc2,\n  M_SOF3  = 0xc3,\n\n  M_SOF5  = 0xc5,\n  M_SOF6  = 0xc6,\n  M_SOF7  = 0xc7,\n\n  M_JPG   = 0xc8,\n  M_SOF9  = 0xc9,\n  M_SOF10 = 0xca,\n  M_SOF11 = 0xcb,\n\n  M_SOF13 = 0xcd,\n  M_SOF14 = 0xce,\n  M_SOF15 = 0xcf,\n\n  M_DHT   = 0xc4,\n\n  M_DAC   = 0xcc,\n\n  M_RST0  = 0xd0,\n  M_RST1  = 0xd1,\n  M_RST2  = 0xd2,\n  M_RST3  = 0xd3,\n  M_RST4  = 0xd4,\n  M_RST5  = 0xd5,\n  M_RST6  = 0xd6,\n  M_RST7  = 0xd7,\n\n  M_SOI   = 0xd8,\n  M_EOI   = 0xd9,\n  M_SOS   = 0xda,\n  M_DQT   = 0xdb,\n  M_DNL   = 0xdc,\n  M_DRI   = 0xdd,\n  M_DHP   = 0xde,\n  M_EXP   = 0xdf,\n\n  M_APP0  = 0xe0,\n  M_APP1  = 0xe1,\n  M_APP2  = 0xe2,\n  M_APP3  = 0xe3,\n  M_APP4  = 0xe4,\n  M_APP5  = 0xe5,\n  M_APP6  = 0xe6,\n  M_APP7  = 0xe7,\n  M_APP8  = 0xe8,\n  M_APP9  = 0xe9,\n  M_APP10 = 0xea,\n  M_APP11 = 0xeb,\n  M_APP12 = 0xec,\n  M_APP13 = 0xed,\n  M_APP14 = 0xee,\n  M_APP15 = 0xef,\n\n  M_JPG0  = 0xf0,\n  M_JPG13 = 0xfd,\n  M_COM   = 0xfe,\n\n  M_TEM   = 0x01,\n\n  M_ERROR = 0x100\n} JPEG_MARKER;\n\n\n/* Private state */\n\ntypedef struct {\n  struct jpeg_marker_reader pub; /* public fields */\n\n  /* Application-overridable marker processing methods */\n  jpeg_marker_parser_method process_COM;\n  jpeg_marker_parser_method process_APPn[16];\n\n  /* Limit on marker data length to save for each marker type */\n  unsigned int length_limit_COM;\n  unsigned int length_limit_APPn[16];\n\n  /* Status of COM/APPn marker saving */\n  jpeg_saved_marker_ptr cur_marker;     /* NULL if not processing a marker */\n  unsigned int bytes_read;              /* data bytes read so far in marker */\n  /* Note: cur_marker is not linked into marker_list until it's all read. */\n} my_marker_reader;\n\ntypedef my_marker_reader *my_marker_ptr;\n\n\n/*\n * Macros for fetching data from the data source module.\n *\n * At all times, cinfo->src->next_input_byte and ->bytes_in_buffer reflect\n * the current restart point; we update them only when we have reached a\n * suitable place to restart if a suspension occurs.\n */\n\n/* Declare and initialize local copies of input pointer/count */\n#define INPUT_VARS(cinfo) \\\n  struct jpeg_source_mgr *datasrc = (cinfo)->src; \\\n  const JOCTET *next_input_byte = datasrc->next_input_byte; \\\n  size_t bytes_in_buffer = datasrc->bytes_in_buffer\n\n/* Unload the local copies --- do this only at a restart boundary */\n#define INPUT_SYNC(cinfo) \\\n  ( datasrc->next_input_byte = next_input_byte, \\\n    datasrc->bytes_in_buffer = bytes_in_buffer )\n\n/* Reload the local copies --- used only in MAKE_BYTE_AVAIL */\n#define INPUT_RELOAD(cinfo) \\\n  ( next_input_byte = datasrc->next_input_byte, \\\n    bytes_in_buffer = datasrc->bytes_in_buffer )\n\n/* Internal macro for INPUT_BYTE and INPUT_2BYTES: make a byte available.\n * Note we do *not* do INPUT_SYNC before calling fill_input_buffer,\n * but we must reload the local copies after a successful fill.\n */\n#define MAKE_BYTE_AVAIL(cinfo, action) \\\n  if (bytes_in_buffer == 0) { \\\n    if (!(*datasrc->fill_input_buffer) (cinfo)) \\\n      { action; } \\\n    INPUT_RELOAD(cinfo); \\\n  }\n\n/* Read a byte into variable V.\n * If must suspend, take the specified action (typically \"return FALSE\").\n */\n#define INPUT_BYTE(cinfo, V, action) \\\n  MAKESTMT( MAKE_BYTE_AVAIL(cinfo, action); \\\n            bytes_in_buffer--; \\\n            V = *next_input_byte++; )\n\n/* As above, but read two bytes interpreted as an unsigned 16-bit integer.\n * V should be declared unsigned int or perhaps JLONG.\n */\n#define INPUT_2BYTES(cinfo, V, action) \\\n  MAKESTMT( MAKE_BYTE_AVAIL(cinfo, action); \\\n            bytes_in_buffer--; \\\n            V = ((unsigned int)(*next_input_byte++)) << 8; \\\n            MAKE_BYTE_AVAIL(cinfo, action); \\\n            bytes_in_buffer--; \\\n            V += *next_input_byte++; )\n\n\n/*\n * Routines to process JPEG markers.\n *\n * Entry condition: JPEG marker itself has been read and its code saved\n *   in cinfo->unread_marker; input restart point is just after the marker.\n *\n * Exit: if return TRUE, have read and processed any parameters, and have\n *   updated the restart point to point after the parameters.\n *   If return FALSE, was forced to suspend before reaching end of\n *   marker parameters; restart point has not been moved.  Same routine\n *   will be called again after application supplies more input data.\n *\n * This approach to suspension assumes that all of a marker's parameters\n * can fit into a single input bufferload.  This should hold for \"normal\"\n * markers.  Some COM/APPn markers might have large parameter segments\n * that might not fit.  If we are simply dropping such a marker, we use\n * skip_input_data to get past it, and thereby put the problem on the\n * source manager's shoulders.  If we are saving the marker's contents\n * into memory, we use a slightly different convention: when forced to\n * suspend, the marker processor updates the restart point to the end of\n * what it's consumed (ie, the end of the buffer) before returning FALSE.\n * On resumption, cinfo->unread_marker still contains the marker code,\n * but the data source will point to the next chunk of marker data.\n * The marker processor must retain internal state to deal with this.\n *\n * Note that we don't bother to avoid duplicate trace messages if a\n * suspension occurs within marker parameters.  Other side effects\n * require more care.\n */\n\n\nLOCAL(boolean)\nget_soi(j_decompress_ptr cinfo)\n/* Process an SOI marker */\n{\n  int i;\n\n  TRACEMS(cinfo, 1, JTRC_SOI);\n\n  if (cinfo->marker->saw_SOI)\n    ERREXIT(cinfo, JERR_SOI_DUPLICATE);\n\n  /* Reset all parameters that are defined to be reset by SOI */\n\n  for (i = 0; i < NUM_ARITH_TBLS; i++) {\n    cinfo->arith_dc_L[i] = 0;\n    cinfo->arith_dc_U[i] = 1;\n    cinfo->arith_ac_K[i] = 5;\n  }\n  cinfo->restart_interval = 0;\n\n  /* Set initial assumptions for colorspace etc */\n\n  cinfo->jpeg_color_space = JCS_UNKNOWN;\n  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */\n\n  cinfo->saw_JFIF_marker = FALSE;\n  cinfo->JFIF_major_version = 1; /* set default JFIF APP0 values */\n  cinfo->JFIF_minor_version = 1;\n  cinfo->density_unit = 0;\n  cinfo->X_density = 1;\n  cinfo->Y_density = 1;\n  cinfo->saw_Adobe_marker = FALSE;\n  cinfo->Adobe_transform = 0;\n\n  cinfo->marker->saw_SOI = TRUE;\n\n  return TRUE;\n}\n\n\nLOCAL(boolean)\nget_sof(j_decompress_ptr cinfo, boolean is_prog, boolean is_lossless,\n        boolean is_arith)\n/* Process a SOFn marker */\n{\n  JLONG length;\n  int c, ci;\n  jpeg_component_info *compptr;\n  INPUT_VARS(cinfo);\n\n  if (cinfo->marker->saw_SOF)\n    ERREXIT(cinfo, JERR_SOF_DUPLICATE);\n\n  cinfo->progressive_mode = is_prog;\n  cinfo->master->lossless = is_lossless;\n  cinfo->arith_code = is_arith;\n\n  INPUT_2BYTES(cinfo, length, return FALSE);\n\n  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);\n  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);\n  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);\n  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);\n\n  length -= 8;\n\n  TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,\n           (int)cinfo->image_width, (int)cinfo->image_height,\n           cinfo->num_components);\n\n  /* We don't support files in which the image height is initially specified */\n  /* as 0 and is later redefined by DNL.  As long as we have to check that,  */\n  /* might as well have a general sanity check. */\n  if (cinfo->image_height <= 0 || cinfo->image_width <= 0 ||\n      cinfo->num_components <= 0)\n    ERREXIT(cinfo, JERR_EMPTY_IMAGE);\n\n  if (length != (cinfo->num_components * 3))\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\n\n  if (cinfo->comp_info == NULL) /* do only once, even if suspend */\n    cinfo->comp_info = (jpeg_component_info *)(*cinfo->mem->alloc_small)\n                        ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                         cinfo->num_components * sizeof(jpeg_component_info));\n\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    compptr->component_index = ci;\n    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);\n    INPUT_BYTE(cinfo, c, return FALSE);\n    compptr->h_samp_factor = (c >> 4) & 15;\n    compptr->v_samp_factor = (c     ) & 15;\n    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);\n\n    TRACEMS4(cinfo, 1, JTRC_SOF_COMPONENT,\n             compptr->component_id, compptr->h_samp_factor,\n             compptr->v_samp_factor, compptr->quant_tbl_no);\n  }\n\n  cinfo->marker->saw_SOF = TRUE;\n\n  INPUT_SYNC(cinfo);\n  return TRUE;\n}\n\n\nLOCAL(boolean)\nget_sos(j_decompress_ptr cinfo)\n/* Process a SOS marker */\n{\n  JLONG length;\n  int i, ci, n, c, cc, pi;\n  jpeg_component_info *compptr;\n  INPUT_VARS(cinfo);\n\n  if (!cinfo->marker->saw_SOF)\n    ERREXIT(cinfo, JERR_SOS_NO_SOF);\n\n  INPUT_2BYTES(cinfo, length, return FALSE);\n\n  INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */\n\n  TRACEMS1(cinfo, 1, JTRC_SOS, n);\n\n  if (length != (n * 2 + 6) || n < 1 || n > MAX_COMPS_IN_SCAN)\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\n\n  cinfo->comps_in_scan = n;\n\n  /* Collect the component-spec parameters */\n\n  for (i = 0; i < MAX_COMPS_IN_SCAN; i++)\n    cinfo->cur_comp_info[i] = NULL;\n\n  for (i = 0; i < n; i++) {\n    INPUT_BYTE(cinfo, cc, return FALSE);\n    INPUT_BYTE(cinfo, c, return FALSE);\n\n    for (ci = 0, compptr = cinfo->comp_info;\n         ci < cinfo->num_components && ci < MAX_COMPS_IN_SCAN;\n         ci++, compptr++) {\n      if (cc == compptr->component_id && !cinfo->cur_comp_info[ci])\n        goto id_found;\n    }\n\n    ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);\n\nid_found:\n\n    cinfo->cur_comp_info[i] = compptr;\n    compptr->dc_tbl_no = (c >> 4) & 15;\n    compptr->ac_tbl_no = (c     ) & 15;\n\n    TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,\n             compptr->dc_tbl_no, compptr->ac_tbl_no);\n\n    /* This CSi (cc) should differ from the previous CSi */\n    for (pi = 0; pi < i; pi++) {\n      if (cinfo->cur_comp_info[pi] == compptr) {\n        ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);\n      }\n    }\n  }\n\n  /* Collect the additional scan parameters Ss, Se, Ah/Al. */\n  INPUT_BYTE(cinfo, c, return FALSE);\n  cinfo->Ss = c;\n  INPUT_BYTE(cinfo, c, return FALSE);\n  cinfo->Se = c;\n  INPUT_BYTE(cinfo, c, return FALSE);\n  cinfo->Ah = (c >> 4) & 15;\n  cinfo->Al = (c     ) & 15;\n\n  TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,\n           cinfo->Ah, cinfo->Al);\n\n  /* Prepare to scan data & restart markers */\n  cinfo->marker->next_restart_num = 0;\n\n  /* Count another SOS marker */\n  cinfo->input_scan_number++;\n\n  INPUT_SYNC(cinfo);\n  return TRUE;\n}\n\n\n#ifdef D_ARITH_CODING_SUPPORTED\n\nLOCAL(boolean)\nget_dac(j_decompress_ptr cinfo)\n/* Process a DAC marker */\n{\n  JLONG length;\n  int index, val;\n  INPUT_VARS(cinfo);\n\n  INPUT_2BYTES(cinfo, length, return FALSE);\n  length -= 2;\n\n  while (length > 0) {\n    INPUT_BYTE(cinfo, index, return FALSE);\n    INPUT_BYTE(cinfo, val, return FALSE);\n\n    length -= 2;\n\n    TRACEMS2(cinfo, 1, JTRC_DAC, index, val);\n\n    if (index < 0 || index >= (2 * NUM_ARITH_TBLS))\n      ERREXIT1(cinfo, JERR_DAC_INDEX, index);\n\n    if (index >= NUM_ARITH_TBLS) { /* define AC table */\n      cinfo->arith_ac_K[index - NUM_ARITH_TBLS] = (UINT8)val;\n    } else {                    /* define DC table */\n      cinfo->arith_dc_L[index] = (UINT8)(val & 0x0F);\n      cinfo->arith_dc_U[index] = (UINT8)(val >> 4);\n      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])\n        ERREXIT1(cinfo, JERR_DAC_VALUE, val);\n    }\n  }\n\n  if (length != 0)\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\n\n  INPUT_SYNC(cinfo);\n  return TRUE;\n}\n\n#else /* !D_ARITH_CODING_SUPPORTED */\n\n#define get_dac(cinfo)  skip_variable(cinfo)\n\n#endif /* D_ARITH_CODING_SUPPORTED */\n\n\nLOCAL(boolean)\nget_dht(j_decompress_ptr cinfo)\n/* Process a DHT marker */\n{\n  JLONG length;\n  UINT8 bits[17];\n  UINT8 huffval[256];\n  int i, index, count;\n  JHUFF_TBL **htblptr;\n  INPUT_VARS(cinfo);\n\n  INPUT_2BYTES(cinfo, length, return FALSE);\n  length -= 2;\n\n  while (length > 16) {\n    INPUT_BYTE(cinfo, index, return FALSE);\n\n    TRACEMS1(cinfo, 1, JTRC_DHT, index);\n\n    bits[0] = 0;\n    count = 0;\n    for (i = 1; i <= 16; i++) {\n      INPUT_BYTE(cinfo, bits[i], return FALSE);\n      count += bits[i];\n    }\n\n    length -= 1 + 16;\n\n    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,\n             bits[1], bits[2], bits[3], bits[4],\n             bits[5], bits[6], bits[7], bits[8]);\n    TRACEMS8(cinfo, 2, JTRC_HUFFBITS,\n             bits[9], bits[10], bits[11], bits[12],\n             bits[13], bits[14], bits[15], bits[16]);\n\n    /* Here we just do minimal validation of the counts to avoid walking\n     * off the end of our table space.  jdhuff.c will check more carefully.\n     */\n    if (count > 256 || ((JLONG)count) > length)\n      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n\n    for (i = 0; i < count; i++)\n      INPUT_BYTE(cinfo, huffval[i], return FALSE);\n\n    memset(&huffval[count], 0, (256 - count) * sizeof(UINT8));\n\n    length -= count;\n\n    if (index & 0x10) {         /* AC table definition */\n      index -= 0x10;\n      if (index < 0 || index >= NUM_HUFF_TBLS)\n        ERREXIT1(cinfo, JERR_DHT_INDEX, index);\n      htblptr = &cinfo->ac_huff_tbl_ptrs[index];\n    } else {                    /* DC table definition */\n      if (index < 0 || index >= NUM_HUFF_TBLS)\n        ERREXIT1(cinfo, JERR_DHT_INDEX, index);\n      htblptr = &cinfo->dc_huff_tbl_ptrs[index];\n    }\n\n    if (*htblptr == NULL)\n      *htblptr = jpeg_alloc_huff_table((j_common_ptr)cinfo);\n\n    memcpy((*htblptr)->bits, bits, sizeof((*htblptr)->bits));\n    memcpy((*htblptr)->huffval, huffval, sizeof((*htblptr)->huffval));\n  }\n\n  if (length != 0)\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\n\n  INPUT_SYNC(cinfo);\n  return TRUE;\n}\n\n\nLOCAL(boolean)\nget_dqt(j_decompress_ptr cinfo)\n/* Process a DQT marker */\n{\n  JLONG length;\n  int n, i, prec;\n  unsigned int tmp;\n  JQUANT_TBL *quant_ptr;\n  INPUT_VARS(cinfo);\n\n  INPUT_2BYTES(cinfo, length, return FALSE);\n  length -= 2;\n\n  while (length > 0) {\n    INPUT_BYTE(cinfo, n, return FALSE);\n    prec = n >> 4;\n    n &= 0x0F;\n\n    TRACEMS2(cinfo, 1, JTRC_DQT, n, prec);\n\n    if (n >= NUM_QUANT_TBLS)\n      ERREXIT1(cinfo, JERR_DQT_INDEX, n);\n\n    if (cinfo->quant_tbl_ptrs[n] == NULL)\n      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr)cinfo);\n    quant_ptr = cinfo->quant_tbl_ptrs[n];\n\n    for (i = 0; i < DCTSIZE2; i++) {\n      if (prec)\n        INPUT_2BYTES(cinfo, tmp, return FALSE);\n      else\n        INPUT_BYTE(cinfo, tmp, return FALSE);\n      /* We convert the zigzag-order table to natural array order. */\n      quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16)tmp;\n    }\n\n    if (cinfo->err->trace_level >= 2) {\n      for (i = 0; i < DCTSIZE2; i += 8) {\n        TRACEMS8(cinfo, 2, JTRC_QUANTVALS,\n                 quant_ptr->quantval[i],     quant_ptr->quantval[i + 1],\n                 quant_ptr->quantval[i + 2], quant_ptr->quantval[i + 3],\n                 quant_ptr->quantval[i + 4], quant_ptr->quantval[i + 5],\n                 quant_ptr->quantval[i + 6], quant_ptr->quantval[i + 7]);\n      }\n    }\n\n    length -= DCTSIZE2 + 1;\n    if (prec) length -= DCTSIZE2;\n  }\n\n  if (length != 0)\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\n\n  INPUT_SYNC(cinfo);\n  return TRUE;\n}\n\n\nLOCAL(boolean)\nget_dri(j_decompress_ptr cinfo)\n/* Process a DRI marker */\n{\n  JLONG length;\n  unsigned int tmp;\n  INPUT_VARS(cinfo);\n\n  INPUT_2BYTES(cinfo, length, return FALSE);\n\n  if (length != 4)\n    ERREXIT(cinfo, JERR_BAD_LENGTH);\n\n  INPUT_2BYTES(cinfo, tmp, return FALSE);\n\n  TRACEMS1(cinfo, 1, JTRC_DRI, tmp);\n\n  cinfo->restart_interval = tmp;\n\n  INPUT_SYNC(cinfo);\n  return TRUE;\n}\n\n\n/*\n * Routines for processing APPn and COM markers.\n * These are either saved in memory or discarded, per application request.\n * APP0 and APP14 are specially checked to see if they are\n * JFIF and Adobe markers, respectively.\n */\n\n#define APP0_DATA_LEN   14      /* Length of interesting data in APP0 */\n#define APP14_DATA_LEN  12      /* Length of interesting data in APP14 */\n#define APPN_DATA_LEN   14      /* Must be the largest of the above!! */\n\n\nLOCAL(void)\nexamine_app0(j_decompress_ptr cinfo, JOCTET *data, unsigned int datalen,\n             JLONG remaining)\n/* Examine first few bytes from an APP0.\n * Take appropriate action if it is a JFIF marker.\n * datalen is # of bytes at data[], remaining is length of rest of marker data.\n */\n{\n  JLONG totallen = (JLONG)datalen + remaining;\n\n  if (datalen >= APP0_DATA_LEN &&\n      data[0] == 0x4A &&\n      data[1] == 0x46 &&\n      data[2] == 0x49 &&\n      data[3] == 0x46 &&\n      data[4] == 0) {\n    /* Found JFIF APP0 marker: save info */\n    cinfo->saw_JFIF_marker = TRUE;\n    cinfo->JFIF_major_version = data[5];\n    cinfo->JFIF_minor_version = data[6];\n    cinfo->density_unit = data[7];\n    cinfo->X_density = (data[8] << 8) + data[9];\n    cinfo->Y_density = (data[10] << 8) + data[11];\n    /* Check version.\n     * Major version must be 1, anything else signals an incompatible change.\n     * (We used to treat this as an error, but now it's a nonfatal warning,\n     * because some bozo at Hijaak couldn't read the spec.)\n     * Minor version should be 0..2, but process anyway if newer.\n     */\n    if (cinfo->JFIF_major_version != 1)\n      WARNMS2(cinfo, JWRN_JFIF_MAJOR,\n              cinfo->JFIF_major_version, cinfo->JFIF_minor_version);\n    /* Generate trace messages */\n    TRACEMS5(cinfo, 1, JTRC_JFIF,\n             cinfo->JFIF_major_version, cinfo->JFIF_minor_version,\n             cinfo->X_density, cinfo->Y_density, cinfo->density_unit);\n    /* Validate thumbnail dimensions and issue appropriate messages */\n    if (data[12] | data[13])\n      TRACEMS2(cinfo, 1, JTRC_JFIF_THUMBNAIL, data[12], data[13]);\n    totallen -= APP0_DATA_LEN;\n    if (totallen != ((JLONG)data[12] * (JLONG)data[13] * (JLONG)3))\n      TRACEMS1(cinfo, 1, JTRC_JFIF_BADTHUMBNAILSIZE, (int)totallen);\n  } else if (datalen >= 6 &&\n             data[0] == 0x4A &&\n             data[1] == 0x46 &&\n             data[2] == 0x58 &&\n             data[3] == 0x58 &&\n             data[4] == 0) {\n    /* Found JFIF \"JFXX\" extension APP0 marker */\n    /* The library doesn't actually do anything with these,\n     * but we try to produce a helpful trace message.\n     */\n    switch (data[5]) {\n    case 0x10:\n      TRACEMS1(cinfo, 1, JTRC_THUMB_JPEG, (int)totallen);\n      break;\n    case 0x11:\n      TRACEMS1(cinfo, 1, JTRC_THUMB_PALETTE, (int)totallen);\n      break;\n    case 0x13:\n      TRACEMS1(cinfo, 1, JTRC_THUMB_RGB, (int)totallen);\n      break;\n    default:\n      TRACEMS2(cinfo, 1, JTRC_JFIF_EXTENSION, data[5], (int)totallen);\n      break;\n    }\n  } else {\n    /* Start of APP0 does not match \"JFIF\" or \"JFXX\", or too short */\n    TRACEMS1(cinfo, 1, JTRC_APP0, (int)totallen);\n  }\n}\n\n\nLOCAL(void)\nexamine_app14(j_decompress_ptr cinfo, JOCTET *data, unsigned int datalen,\n              JLONG remaining)\n/* Examine first few bytes from an APP14.\n * Take appropriate action if it is an Adobe marker.\n * datalen is # of bytes at data[], remaining is length of rest of marker data.\n */\n{\n  unsigned int version, flags0, flags1, transform;\n\n  if (datalen >= APP14_DATA_LEN &&\n      data[0] == 0x41 &&\n      data[1] == 0x64 &&\n      data[2] == 0x6F &&\n      data[3] == 0x62 &&\n      data[4] == 0x65) {\n    /* Found Adobe APP14 marker */\n    version = (data[5] << 8) + data[6];\n    flags0 = (data[7] << 8) + data[8];\n    flags1 = (data[9] << 8) + data[10];\n    transform = data[11];\n    TRACEMS4(cinfo, 1, JTRC_ADOBE, version, flags0, flags1, transform);\n    cinfo->saw_Adobe_marker = TRUE;\n    cinfo->Adobe_transform = (UINT8)transform;\n  } else {\n    /* Start of APP14 does not match \"Adobe\", or too short */\n    TRACEMS1(cinfo, 1, JTRC_APP14, (int)(datalen + remaining));\n  }\n}\n\n\nMETHODDEF(boolean)\nget_interesting_appn(j_decompress_ptr cinfo)\n/* Process an APP0 or APP14 marker without saving it */\n{\n  JLONG length;\n  JOCTET b[APPN_DATA_LEN];\n  unsigned int i, numtoread;\n  INPUT_VARS(cinfo);\n\n  INPUT_2BYTES(cinfo, length, return FALSE);\n  length -= 2;\n\n  /* get the interesting part of the marker data */\n  if (length >= APPN_DATA_LEN)\n    numtoread = APPN_DATA_LEN;\n  else if (length > 0)\n    numtoread = (unsigned int)length;\n  else\n    numtoread = 0;\n  for (i = 0; i < numtoread; i++)\n    INPUT_BYTE(cinfo, b[i], return FALSE);\n  length -= numtoread;\n\n  /* process it */\n  switch (cinfo->unread_marker) {\n  case M_APP0:\n    examine_app0(cinfo, (JOCTET *)b, numtoread, length);\n    break;\n  case M_APP14:\n    examine_app14(cinfo, (JOCTET *)b, numtoread, length);\n    break;\n  default:\n    /* can't get here unless jpeg_save_markers chooses wrong processor */\n    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);\n    break;\n  }\n\n  /* skip any remaining data -- could be lots */\n  INPUT_SYNC(cinfo);\n  if (length > 0)\n    (*cinfo->src->skip_input_data) (cinfo, (long)length);\n\n  return TRUE;\n}\n\n\n#ifdef SAVE_MARKERS_SUPPORTED\n\nMETHODDEF(boolean)\nsave_marker(j_decompress_ptr cinfo)\n/* Save an APPn or COM marker into the marker list */\n{\n  my_marker_ptr marker = (my_marker_ptr)cinfo->marker;\n  jpeg_saved_marker_ptr cur_marker = marker->cur_marker;\n  unsigned int bytes_read, data_length;\n  JOCTET *data;\n  JLONG length = 0;\n  INPUT_VARS(cinfo);\n\n  if (cur_marker == NULL) {\n    /* begin reading a marker */\n    INPUT_2BYTES(cinfo, length, return FALSE);\n    length -= 2;\n    if (length >= 0) {          /* watch out for bogus length word */\n      /* figure out how much we want to save */\n      unsigned int limit;\n      if (cinfo->unread_marker == (int)M_COM)\n        limit = marker->length_limit_COM;\n      else\n        limit = marker->length_limit_APPn[cinfo->unread_marker - (int)M_APP0];\n      if ((unsigned int)length < limit)\n        limit = (unsigned int)length;\n      /* allocate and initialize the marker item */\n      cur_marker = (jpeg_saved_marker_ptr)\n        (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                    sizeof(struct jpeg_marker_struct) + limit);\n      cur_marker->next = NULL;\n      cur_marker->marker = (UINT8)cinfo->unread_marker;\n      cur_marker->original_length = (unsigned int)length;\n      cur_marker->data_length = limit;\n      /* data area is just beyond the jpeg_marker_struct */\n      data = cur_marker->data = (JOCTET *)(cur_marker + 1);\n      marker->cur_marker = cur_marker;\n      marker->bytes_read = 0;\n      bytes_read = 0;\n      data_length = limit;\n    } else {\n      /* deal with bogus length word */\n      bytes_read = data_length = 0;\n      data = NULL;\n    }\n  } else {\n    /* resume reading a marker */\n    bytes_read = marker->bytes_read;\n    data_length = cur_marker->data_length;\n    data = cur_marker->data + bytes_read;\n  }\n\n  while (bytes_read < data_length) {\n    INPUT_SYNC(cinfo);          /* move the restart point to here */\n    marker->bytes_read = bytes_read;\n    /* If there's not at least one byte in buffer, suspend */\n    MAKE_BYTE_AVAIL(cinfo, return FALSE);\n    /* Copy bytes with reasonable rapidity */\n    while (bytes_read < data_length && bytes_in_buffer > 0) {\n      *data++ = *next_input_byte++;\n      bytes_in_buffer--;\n      bytes_read++;\n    }\n  }\n\n  /* Done reading what we want to read */\n  if (cur_marker != NULL) {     /* will be NULL if bogus length word */\n    /* Add new marker to end of list */\n    if (cinfo->marker_list == NULL || cinfo->master->marker_list_end == NULL) {\n      cinfo->marker_list = cinfo->master->marker_list_end = cur_marker;\n    } else {\n      cinfo->master->marker_list_end->next = cur_marker;\n      cinfo->master->marker_list_end = cur_marker;\n    }\n    /* Reset pointer & calc remaining data length */\n    data = cur_marker->data;\n    length = cur_marker->original_length - data_length;\n  }\n  /* Reset to initial state for next marker */\n  marker->cur_marker = NULL;\n\n  /* Process the marker if interesting; else just make a generic trace msg */\n  switch (cinfo->unread_marker) {\n  case M_APP0:\n    examine_app0(cinfo, data, data_length, length);\n    break;\n  case M_APP14:\n    examine_app14(cinfo, data, data_length, length);\n    break;\n  default:\n    TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker,\n             (int)(data_length + length));\n    break;\n  }\n\n  /* skip any remaining data -- could be lots */\n  INPUT_SYNC(cinfo);            /* do before skip_input_data */\n  if (length > 0)\n    (*cinfo->src->skip_input_data) (cinfo, (long)length);\n\n  return TRUE;\n}\n\n#endif /* SAVE_MARKERS_SUPPORTED */\n\n\nMETHODDEF(boolean)\nskip_variable(j_decompress_ptr cinfo)\n/* Skip over an unknown or uninteresting variable-length marker */\n{\n  JLONG length;\n  INPUT_VARS(cinfo);\n\n  INPUT_2BYTES(cinfo, length, return FALSE);\n  length -= 2;\n\n  TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int)length);\n\n  INPUT_SYNC(cinfo);            /* do before skip_input_data */\n  if (length > 0)\n    (*cinfo->src->skip_input_data) (cinfo, (long)length);\n\n  return TRUE;\n}\n\n\n/*\n * Find the next JPEG marker, save it in cinfo->unread_marker.\n * Returns FALSE if had to suspend before reaching a marker;\n * in that case cinfo->unread_marker is unchanged.\n *\n * Note that the result might not be a valid marker code,\n * but it will never be 0 or FF.\n */\n\nLOCAL(boolean)\nnext_marker(j_decompress_ptr cinfo)\n{\n  int c;\n  INPUT_VARS(cinfo);\n\n  for (;;) {\n    INPUT_BYTE(cinfo, c, return FALSE);\n    /* Skip any non-FF bytes.\n     * This may look a bit inefficient, but it will not occur in a valid file.\n     * We sync after each discarded byte so that a suspending data source\n     * can discard the byte from its buffer.\n     */\n    while (c != 0xFF) {\n      cinfo->marker->discarded_bytes++;\n      INPUT_SYNC(cinfo);\n      INPUT_BYTE(cinfo, c, return FALSE);\n    }\n    /* This loop swallows any duplicate FF bytes.  Extra FFs are legal as\n     * pad bytes, so don't count them in discarded_bytes.  We assume there\n     * will not be so many consecutive FF bytes as to overflow a suspending\n     * data source's input buffer.\n     */\n    do {\n      INPUT_BYTE(cinfo, c, return FALSE);\n    } while (c == 0xFF);\n    if (c != 0)\n      break;                    /* found a valid marker, exit loop */\n    /* Reach here if we found a stuffed-zero data sequence (FF/00).\n     * Discard it and loop back to try again.\n     */\n    cinfo->marker->discarded_bytes += 2;\n    INPUT_SYNC(cinfo);\n  }\n\n  if (cinfo->marker->discarded_bytes != 0) {\n    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);\n    cinfo->marker->discarded_bytes = 0;\n  }\n\n  cinfo->unread_marker = c;\n\n  INPUT_SYNC(cinfo);\n  return TRUE;\n}\n\n\nLOCAL(boolean)\nfirst_marker(j_decompress_ptr cinfo)\n/* Like next_marker, but used to obtain the initial SOI marker. */\n/* For this marker, we do not allow preceding garbage or fill; otherwise,\n * we might well scan an entire input file before realizing it ain't JPEG.\n * If an application wants to process non-JFIF files, it must seek to the\n * SOI before calling the JPEG library.\n */\n{\n  int c, c2;\n  INPUT_VARS(cinfo);\n\n  INPUT_BYTE(cinfo, c, return FALSE);\n  INPUT_BYTE(cinfo, c2, return FALSE);\n  if (c != 0xFF || c2 != (int)M_SOI)\n    ERREXIT2(cinfo, JERR_NO_SOI, c, c2);\n\n  cinfo->unread_marker = c2;\n\n  INPUT_SYNC(cinfo);\n  return TRUE;\n}\n\n\n/*\n * Read markers until SOS or EOI.\n *\n * Returns same codes as are defined for jpeg_consume_input:\n * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.\n */\n\nMETHODDEF(int)\nread_markers(j_decompress_ptr cinfo)\n{\n  /* Outer loop repeats once for each marker. */\n  for (;;) {\n    /* Collect the marker proper, unless we already did. */\n    /* NB: first_marker() enforces the requirement that SOI appear first. */\n    if (cinfo->unread_marker == 0) {\n      if (!cinfo->marker->saw_SOI) {\n        if (!first_marker(cinfo))\n          return JPEG_SUSPENDED;\n      } else {\n        if (!next_marker(cinfo))\n          return JPEG_SUSPENDED;\n      }\n    }\n    /* At this point cinfo->unread_marker contains the marker code and the\n     * input point is just past the marker proper, but before any parameters.\n     * A suspension will cause us to return with this state still true.\n     */\n    switch (cinfo->unread_marker) {\n    case M_SOI:\n      if (!get_soi(cinfo))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_SOF0:                /* Baseline */\n    case M_SOF1:                /* Extended sequential, Huffman */\n      if (!get_sof(cinfo, FALSE, FALSE, FALSE))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_SOF2:                /* Progressive, Huffman */\n      if (!get_sof(cinfo, TRUE, FALSE, FALSE))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_SOF3:                /* Lossless, Huffman */\n      if (!get_sof(cinfo, FALSE, TRUE, FALSE))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_SOF9:                /* Extended sequential, arithmetic */\n      if (!get_sof(cinfo, FALSE, FALSE, TRUE))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_SOF10:               /* Progressive, arithmetic */\n      if (!get_sof(cinfo, TRUE, FALSE, TRUE))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_SOF11:               /* Lossless, arithmetic */\n      if (!get_sof(cinfo, FALSE, TRUE, TRUE))\n        return JPEG_SUSPENDED;\n      break;\n\n    /* Currently unsupported SOFn types */\n    case M_SOF5:                /* Differential sequential, Huffman */\n    case M_SOF6:                /* Differential progressive, Huffman */\n    case M_SOF7:                /* Differential lossless, Huffman */\n    case M_JPG:                 /* Reserved for JPEG extensions */\n    case M_SOF13:               /* Differential sequential, arithmetic */\n    case M_SOF14:               /* Differential progressive, arithmetic */\n    case M_SOF15:               /* Differential lossless, arithmetic */\n      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);\n      break;\n\n    case M_SOS:\n      if (!get_sos(cinfo))\n        return JPEG_SUSPENDED;\n      cinfo->unread_marker = 0; /* processed the marker */\n      return JPEG_REACHED_SOS;\n\n    case M_EOI:\n      TRACEMS(cinfo, 1, JTRC_EOI);\n      cinfo->unread_marker = 0; /* processed the marker */\n      return JPEG_REACHED_EOI;\n\n    case M_DAC:\n      if (!get_dac(cinfo))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_DHT:\n      if (!get_dht(cinfo))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_DQT:\n      if (!get_dqt(cinfo))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_DRI:\n      if (!get_dri(cinfo))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_APP0:\n    case M_APP1:\n    case M_APP2:\n    case M_APP3:\n    case M_APP4:\n    case M_APP5:\n    case M_APP6:\n    case M_APP7:\n    case M_APP8:\n    case M_APP9:\n    case M_APP10:\n    case M_APP11:\n    case M_APP12:\n    case M_APP13:\n    case M_APP14:\n    case M_APP15:\n      if (!(*((my_marker_ptr)cinfo->marker)->process_APPn[\n               cinfo->unread_marker - (int)M_APP0]) (cinfo))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_COM:\n      if (!(*((my_marker_ptr)cinfo->marker)->process_COM) (cinfo))\n        return JPEG_SUSPENDED;\n      break;\n\n    case M_RST0:                /* these are all parameterless */\n    case M_RST1:\n    case M_RST2:\n    case M_RST3:\n    case M_RST4:\n    case M_RST5:\n    case M_RST6:\n    case M_RST7:\n    case M_TEM:\n      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);\n      break;\n\n    case M_DNL:                 /* Ignore DNL ... perhaps the wrong thing */\n      if (!skip_variable(cinfo))\n        return JPEG_SUSPENDED;\n      break;\n\n    default:                    /* must be DHP, EXP, JPGn, or RESn */\n      /* For now, we treat the reserved markers as fatal errors since they are\n       * likely to be used to signal incompatible JPEG Part 3 extensions.\n       * Once the JPEG 3 version-number marker is well defined, this code\n       * ought to change!\n       */\n      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);\n      break;\n    }\n    /* Successfully processed marker, so reset state variable */\n    cinfo->unread_marker = 0;\n  } /* end loop */\n}\n\n\n/*\n * Read a restart marker, which is expected to appear next in the datastream;\n * if the marker is not there, take appropriate recovery action.\n * Returns FALSE if suspension is required.\n *\n * This is called by the entropy decoder after it has read an appropriate\n * number of MCUs.  cinfo->unread_marker may be nonzero if the entropy decoder\n * has already read a marker from the data source.  Under normal conditions\n * cinfo->unread_marker will be reset to 0 before returning; if not reset,\n * it holds a marker which the decoder will be unable to read past.\n */\n\nMETHODDEF(boolean)\nread_restart_marker(j_decompress_ptr cinfo)\n{\n  /* Obtain a marker unless we already did. */\n  /* Note that next_marker will complain if it skips any data. */\n  if (cinfo->unread_marker == 0) {\n    if (!next_marker(cinfo))\n      return FALSE;\n  }\n\n  if (cinfo->unread_marker ==\n      ((int)M_RST0 + cinfo->marker->next_restart_num)) {\n    /* Normal case --- swallow the marker and let entropy decoder continue */\n    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);\n    cinfo->unread_marker = 0;\n  } else {\n    /* Uh-oh, the restart markers have been messed up. */\n    /* Let the data source manager determine how to resync. */\n    if (!(*cinfo->src->resync_to_restart) (cinfo,\n                                           cinfo->marker->next_restart_num))\n      return FALSE;\n  }\n\n  /* Update next-restart state */\n  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;\n\n  return TRUE;\n}\n\n\n/*\n * This is the default resync_to_restart method for data source managers\n * to use if they don't have any better approach.  Some data source managers\n * may be able to back up, or may have additional knowledge about the data\n * which permits a more intelligent recovery strategy; such managers would\n * presumably supply their own resync method.\n *\n * read_restart_marker calls resync_to_restart if it finds a marker other than\n * the restart marker it was expecting.  (This code is *not* used unless\n * a nonzero restart interval has been declared.)  cinfo->unread_marker is\n * the marker code actually found (might be anything, except 0 or FF).\n * The desired restart marker number (0..7) is passed as a parameter.\n * This routine is supposed to apply whatever error recovery strategy seems\n * appropriate in order to position the input stream to the next data segment.\n * Note that cinfo->unread_marker is treated as a marker appearing before\n * the current data-source input point; usually it should be reset to zero\n * before returning.\n * Returns FALSE if suspension is required.\n *\n * This implementation is substantially constrained by wanting to treat the\n * input as a data stream; this means we can't back up.  Therefore, we have\n * only the following actions to work with:\n *   1. Simply discard the marker and let the entropy decoder resume at next\n *      byte of file.\n *   2. Read forward until we find another marker, discarding intervening\n *      data.  (In theory we could look ahead within the current bufferload,\n *      without having to discard data if we don't find the desired marker.\n *      This idea is not implemented here, in part because it makes behavior\n *      dependent on buffer size and chance buffer-boundary positions.)\n *   3. Leave the marker unread (by failing to zero cinfo->unread_marker).\n *      This will cause the entropy decoder to process an empty data segment,\n *      inserting dummy zeroes, and then we will reprocess the marker.\n *\n * #2 is appropriate if we think the desired marker lies ahead, while #3 is\n * appropriate if the found marker is a future restart marker (indicating\n * that we have missed the desired restart marker, probably because it got\n * corrupted).\n * We apply #2 or #3 if the found marker is a restart marker no more than\n * two counts behind or ahead of the expected one.  We also apply #2 if the\n * found marker is not a legal JPEG marker code (it's certainly bogus data).\n * If the found marker is a restart marker more than 2 counts away, we do #1\n * (too much risk that the marker is erroneous; with luck we will be able to\n * resync at some future point).\n * For any valid non-restart JPEG marker, we apply #3.  This keeps us from\n * overrunning the end of a scan.  An implementation limited to single-scan\n * files might find it better to apply #2 for markers other than EOI, since\n * any other marker would have to be bogus data in that case.\n */\n\nGLOBAL(boolean)\njpeg_resync_to_restart(j_decompress_ptr cinfo, int desired)\n{\n  int marker = cinfo->unread_marker;\n  int action = 1;\n\n  /* Always put up a warning. */\n  WARNMS2(cinfo, JWRN_MUST_RESYNC, marker, desired);\n\n  /* Outer loop handles repeated decision after scanning forward. */\n  for (;;) {\n    if (marker < (int)M_SOF0)\n      action = 2;               /* invalid marker */\n    else if (marker < (int)M_RST0 || marker > (int)M_RST7)\n      action = 3;               /* valid non-restart marker */\n    else {\n      if (marker == ((int)M_RST0 + ((desired + 1) & 7)) ||\n          marker == ((int)M_RST0 + ((desired + 2) & 7)))\n        action = 3;             /* one of the next two expected restarts */\n      else if (marker == ((int)M_RST0 + ((desired - 1) & 7)) ||\n               marker == ((int)M_RST0 + ((desired - 2) & 7)))\n        action = 2;             /* a prior restart, so advance */\n      else\n        action = 1;             /* desired restart or too far away */\n    }\n    TRACEMS2(cinfo, 4, JTRC_RECOVERY_ACTION, marker, action);\n    switch (action) {\n    case 1:\n      /* Discard marker and let entropy decoder resume processing. */\n      cinfo->unread_marker = 0;\n      return TRUE;\n    case 2:\n      /* Scan to the next marker, and repeat the decision loop. */\n      if (!next_marker(cinfo))\n        return FALSE;\n      marker = cinfo->unread_marker;\n      break;\n    case 3:\n      /* Return without advancing past this marker. */\n      /* Entropy decoder will be forced to process an empty segment. */\n      return TRUE;\n    }\n  } /* end loop */\n}\n\n\n/*\n * Reset marker processing state to begin a fresh datastream.\n */\n\nMETHODDEF(void)\nreset_marker_reader(j_decompress_ptr cinfo)\n{\n  my_marker_ptr marker = (my_marker_ptr)cinfo->marker;\n\n  cinfo->comp_info = NULL;              /* until allocated by get_sof */\n  cinfo->input_scan_number = 0;         /* no SOS seen yet */\n  cinfo->unread_marker = 0;             /* no pending marker */\n  marker->pub.saw_SOI = FALSE;          /* set internal state too */\n  marker->pub.saw_SOF = FALSE;\n  marker->pub.discarded_bytes = 0;\n  marker->cur_marker = NULL;\n}\n\n\n/*\n * Initialize the marker reader module.\n * This is called only once, when the decompression object is created.\n */\n\nGLOBAL(void)\njinit_marker_reader(j_decompress_ptr cinfo)\n{\n  my_marker_ptr marker;\n  int i;\n\n  /* Create subobject in permanent pool */\n  marker = (my_marker_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_PERMANENT,\n                                sizeof(my_marker_reader));\n  cinfo->marker = (struct jpeg_marker_reader *)marker;\n  /* Initialize public method pointers */\n  marker->pub.reset_marker_reader = reset_marker_reader;\n  marker->pub.read_markers = read_markers;\n  marker->pub.read_restart_marker = read_restart_marker;\n  /* Initialize COM/APPn processing.\n   * By default, we examine and then discard APP0 and APP14,\n   * but simply discard COM and all other APPn.\n   */\n  marker->process_COM = skip_variable;\n  marker->length_limit_COM = 0;\n  for (i = 0; i < 16; i++) {\n    marker->process_APPn[i] = skip_variable;\n    marker->length_limit_APPn[i] = 0;\n  }\n  marker->process_APPn[0] = get_interesting_appn;\n  marker->process_APPn[14] = get_interesting_appn;\n  /* Reset marker processing state */\n  reset_marker_reader(cinfo);\n}\n\n\n/*\n * Control saving of COM and APPn markers into marker_list.\n */\n\n#ifdef SAVE_MARKERS_SUPPORTED\n\nGLOBAL(void)\njpeg_save_markers(j_decompress_ptr cinfo, int marker_code,\n                  unsigned int length_limit)\n{\n  my_marker_ptr marker = (my_marker_ptr)cinfo->marker;\n  long maxlength;\n  jpeg_marker_parser_method processor;\n\n  /* Length limit mustn't be larger than what we can allocate\n   * (should only be a concern in a 16-bit environment).\n   */\n  maxlength = cinfo->mem->max_alloc_chunk - sizeof(struct jpeg_marker_struct);\n  if (((long)length_limit) > maxlength)\n    length_limit = (unsigned int)maxlength;\n\n  /* Choose processor routine to use.\n   * APP0/APP14 have special requirements.\n   */\n  if (length_limit) {\n    processor = save_marker;\n    /* If saving APP0/APP14, save at least enough for our internal use. */\n    if (marker_code == (int)M_APP0 && length_limit < APP0_DATA_LEN)\n      length_limit = APP0_DATA_LEN;\n    else if (marker_code == (int)M_APP14 && length_limit < APP14_DATA_LEN)\n      length_limit = APP14_DATA_LEN;\n  } else {\n    processor = skip_variable;\n    /* If discarding APP0/APP14, use our regular on-the-fly processor. */\n    if (marker_code == (int)M_APP0 || marker_code == (int)M_APP14)\n      processor = get_interesting_appn;\n  }\n\n  if (marker_code == (int)M_COM) {\n    marker->process_COM = processor;\n    marker->length_limit_COM = length_limit;\n  } else if (marker_code >= (int)M_APP0 && marker_code <= (int)M_APP15) {\n    marker->process_APPn[marker_code - (int)M_APP0] = processor;\n    marker->length_limit_APPn[marker_code - (int)M_APP0] = length_limit;\n  } else\n    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, marker_code);\n}\n\n#endif /* SAVE_MARKERS_SUPPORTED */\n\n\n/*\n * Install a special processing method for COM or APPn markers.\n */\n\nGLOBAL(void)\njpeg_set_marker_processor(j_decompress_ptr cinfo, int marker_code,\n                          jpeg_marker_parser_method routine)\n{\n  my_marker_ptr marker = (my_marker_ptr)cinfo->marker;\n\n  if (marker_code == (int)M_COM)\n    marker->process_COM = routine;\n  else if (marker_code >= (int)M_APP0 && marker_code <= (int)M_APP15)\n    marker->process_APPn[marker_code - (int)M_APP0] = routine;\n  else\n    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, marker_code);\n}\n"
        },
        {
          "name": "jdmaster.c",
          "type": "blob",
          "size": 33.712890625,
          "content": "/*\n * jdmaster.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 2002-2009 by Guido Vollbeding.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2009-2011, 2016, 2019, 2022-2023, D. R. Commander.\n * Copyright (C) 2013, Linaro Limited.\n * Copyright (C) 2015, Google, Inc.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains master control logic for the JPEG decompressor.\n * These routines are concerned with selecting the modules to be executed\n * and with determining the number of passes and the work to be done in each\n * pass.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jpegapicomp.h\"\n#include \"jdmaster.h\"\n\n\n/*\n * Determine whether merged upsample/color conversion should be used.\n * CRUCIAL: this must match the actual capabilities of jdmerge.c!\n */\n\nLOCAL(boolean)\nuse_merged_upsample(j_decompress_ptr cinfo)\n{\n#ifdef UPSAMPLE_MERGING_SUPPORTED\n  /* Colorspace conversion is not supported with lossless JPEG images */\n  if (cinfo->master->lossless)\n    return FALSE;\n  /* Merging is the equivalent of plain box-filter upsampling */\n  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)\n    return FALSE;\n  /* jdmerge.c only supports YCC=>RGB and YCC=>RGB565 color conversion */\n  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||\n      (cinfo->out_color_space != JCS_RGB &&\n       cinfo->out_color_space != JCS_RGB565 &&\n       cinfo->out_color_space != JCS_EXT_RGB &&\n       cinfo->out_color_space != JCS_EXT_RGBX &&\n       cinfo->out_color_space != JCS_EXT_BGR &&\n       cinfo->out_color_space != JCS_EXT_BGRX &&\n       cinfo->out_color_space != JCS_EXT_XBGR &&\n       cinfo->out_color_space != JCS_EXT_XRGB &&\n       cinfo->out_color_space != JCS_EXT_RGBA &&\n       cinfo->out_color_space != JCS_EXT_BGRA &&\n       cinfo->out_color_space != JCS_EXT_ABGR &&\n       cinfo->out_color_space != JCS_EXT_ARGB))\n    return FALSE;\n  if ((cinfo->out_color_space == JCS_RGB565 &&\n       cinfo->out_color_components != 3) ||\n      (cinfo->out_color_space != JCS_RGB565 &&\n       cinfo->out_color_components != rgb_pixelsize[cinfo->out_color_space]))\n    return FALSE;\n  /* and it only handles 2h1v or 2h2v sampling ratios */\n  if (cinfo->comp_info[0].h_samp_factor != 2 ||\n      cinfo->comp_info[1].h_samp_factor != 1 ||\n      cinfo->comp_info[2].h_samp_factor != 1 ||\n      cinfo->comp_info[0].v_samp_factor >  2 ||\n      cinfo->comp_info[1].v_samp_factor != 1 ||\n      cinfo->comp_info[2].v_samp_factor != 1)\n    return FALSE;\n  /* furthermore, it doesn't work if we've scaled the IDCTs differently */\n  if (cinfo->comp_info[0]._DCT_scaled_size != cinfo->_min_DCT_scaled_size ||\n      cinfo->comp_info[1]._DCT_scaled_size != cinfo->_min_DCT_scaled_size ||\n      cinfo->comp_info[2]._DCT_scaled_size != cinfo->_min_DCT_scaled_size)\n    return FALSE;\n  /* ??? also need to test for upsample-time rescaling, when & if supported */\n  return TRUE;                  /* by golly, it'll work... */\n#else\n  return FALSE;\n#endif\n}\n\n\n/*\n * Compute output image dimensions and related values.\n * NOTE: this is exported for possible use by application.\n * Hence it mustn't do anything that can't be done twice.\n */\n\n#if JPEG_LIB_VERSION >= 80\nGLOBAL(void)\n#else\nLOCAL(void)\n#endif\njpeg_core_output_dimensions(j_decompress_ptr cinfo)\n/* Do computations that are needed before master selection phase.\n * This function is used for transcoding and full decompression.\n */\n{\n#ifdef IDCT_SCALING_SUPPORTED\n  int ci;\n  jpeg_component_info *compptr;\n\n  if (!cinfo->master->lossless) {\n    /* Compute actual output image dimensions and DCT scaling choices. */\n    if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom) {\n      /* Provide 1/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 1;\n      cinfo->_min_DCT_v_scaled_size = 1;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 2) {\n      /* Provide 2/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 2L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 2L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 2;\n      cinfo->_min_DCT_v_scaled_size = 2;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 3) {\n      /* Provide 3/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 3L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 3L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 3;\n      cinfo->_min_DCT_v_scaled_size = 3;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 4) {\n      /* Provide 4/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 4L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 4L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 4;\n      cinfo->_min_DCT_v_scaled_size = 4;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 5) {\n      /* Provide 5/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 5L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 5L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 5;\n      cinfo->_min_DCT_v_scaled_size = 5;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 6) {\n      /* Provide 6/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 6L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 6L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 6;\n      cinfo->_min_DCT_v_scaled_size = 6;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 7) {\n      /* Provide 7/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 7L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 7L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 7;\n      cinfo->_min_DCT_v_scaled_size = 7;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 8) {\n      /* Provide 8/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 8L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 8L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 8;\n      cinfo->_min_DCT_v_scaled_size = 8;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 9) {\n      /* Provide 9/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 9L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 9L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 9;\n      cinfo->_min_DCT_v_scaled_size = 9;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 10) {\n      /* Provide 10/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 10L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 10L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 10;\n      cinfo->_min_DCT_v_scaled_size = 10;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 11) {\n      /* Provide 11/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 11L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 11L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 11;\n      cinfo->_min_DCT_v_scaled_size = 11;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 12) {\n      /* Provide 12/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 12L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 12L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 12;\n      cinfo->_min_DCT_v_scaled_size = 12;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 13) {\n      /* Provide 13/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 13L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 13L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 13;\n      cinfo->_min_DCT_v_scaled_size = 13;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 14) {\n      /* Provide 14/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 14L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 14L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 14;\n      cinfo->_min_DCT_v_scaled_size = 14;\n    } else if (cinfo->scale_num * DCTSIZE <= cinfo->scale_denom * 15) {\n      /* Provide 15/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 15L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 15L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 15;\n      cinfo->_min_DCT_v_scaled_size = 15;\n    } else {\n      /* Provide 16/block_size scaling */\n      cinfo->output_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width * 16L, (long)DCTSIZE);\n      cinfo->output_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height * 16L, (long)DCTSIZE);\n      cinfo->_min_DCT_h_scaled_size = 16;\n      cinfo->_min_DCT_v_scaled_size = 16;\n    }\n\n    /* Recompute dimensions of components */\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      compptr->_DCT_h_scaled_size = cinfo->_min_DCT_h_scaled_size;\n      compptr->_DCT_v_scaled_size = cinfo->_min_DCT_v_scaled_size;\n    }\n  } else\n#endif /* !IDCT_SCALING_SUPPORTED */\n  {\n    /* Hardwire it to \"no scaling\" */\n    cinfo->output_width = cinfo->image_width;\n    cinfo->output_height = cinfo->image_height;\n    /* jdinput.c has already initialized DCT_scaled_size,\n     * and has computed unscaled downsampled_width and downsampled_height.\n     */\n  }\n}\n\n\n/*\n * Compute output image dimensions and related values.\n * NOTE: this is exported for possible use by application.\n * Hence it mustn't do anything that can't be done twice.\n * Also note that it may be called before the master module is initialized!\n */\n\nGLOBAL(void)\njpeg_calc_output_dimensions(j_decompress_ptr cinfo)\n/* Do computations that are needed before master selection phase */\n{\n#ifdef IDCT_SCALING_SUPPORTED\n  int ci;\n  jpeg_component_info *compptr;\n#endif\n\n  /* Prevent application from calling me at wrong times */\n  if (cinfo->global_state != DSTATE_READY)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  /* Compute core output image dimensions and DCT scaling choices. */\n  jpeg_core_output_dimensions(cinfo);\n\n#ifdef IDCT_SCALING_SUPPORTED\n\n  if (!cinfo->master->lossless) {\n    /* In selecting the actual DCT scaling for each component, we try to\n     * scale up the chroma components via IDCT scaling rather than upsampling.\n     * This saves time if the upsampler gets to use 1:1 scaling.\n     * Note this code adapts subsampling ratios which are powers of 2.\n     */\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      int ssize = cinfo->_min_DCT_scaled_size;\n      while (ssize < DCTSIZE &&\n             ((cinfo->max_h_samp_factor * cinfo->_min_DCT_scaled_size) %\n              (compptr->h_samp_factor * ssize * 2) == 0) &&\n             ((cinfo->max_v_samp_factor * cinfo->_min_DCT_scaled_size) %\n              (compptr->v_samp_factor * ssize * 2) == 0)) {\n        ssize = ssize * 2;\n      }\n#if JPEG_LIB_VERSION >= 70\n      compptr->DCT_h_scaled_size = compptr->DCT_v_scaled_size = ssize;\n#else\n      compptr->DCT_scaled_size = ssize;\n#endif\n    }\n\n    /* Recompute downsampled dimensions of components;\n     * application needs to know these if using raw downsampled data.\n     */\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      /* Size in samples, after IDCT scaling */\n      compptr->downsampled_width = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_width *\n                      (long)(compptr->h_samp_factor *\n                             compptr->_DCT_scaled_size),\n                      (long)(cinfo->max_h_samp_factor * DCTSIZE));\n      compptr->downsampled_height = (JDIMENSION)\n        jdiv_round_up((long)cinfo->image_height *\n                      (long)(compptr->v_samp_factor *\n                             compptr->_DCT_scaled_size),\n                      (long)(cinfo->max_v_samp_factor * DCTSIZE));\n    }\n  } else\n#endif /* IDCT_SCALING_SUPPORTED */\n  {\n    /* Hardwire it to \"no scaling\" */\n    cinfo->output_width = cinfo->image_width;\n    cinfo->output_height = cinfo->image_height;\n    /* jdinput.c has already initialized DCT_scaled_size to DCTSIZE,\n     * and has computed unscaled downsampled_width and downsampled_height.\n     */\n  }\n\n  /* Report number of components in selected colorspace. */\n  /* Probably this should be in the color conversion module... */\n  switch (cinfo->out_color_space) {\n  case JCS_GRAYSCALE:\n    cinfo->out_color_components = 1;\n    break;\n  case JCS_RGB:\n  case JCS_EXT_RGB:\n  case JCS_EXT_RGBX:\n  case JCS_EXT_BGR:\n  case JCS_EXT_BGRX:\n  case JCS_EXT_XBGR:\n  case JCS_EXT_XRGB:\n  case JCS_EXT_RGBA:\n  case JCS_EXT_BGRA:\n  case JCS_EXT_ABGR:\n  case JCS_EXT_ARGB:\n    cinfo->out_color_components = rgb_pixelsize[cinfo->out_color_space];\n    break;\n  case JCS_YCbCr:\n  case JCS_RGB565:\n    cinfo->out_color_components = 3;\n    break;\n  case JCS_CMYK:\n  case JCS_YCCK:\n    cinfo->out_color_components = 4;\n    break;\n  default:                      /* else must be same colorspace as in file */\n    cinfo->out_color_components = cinfo->num_components;\n    break;\n  }\n  cinfo->output_components = (cinfo->quantize_colors ? 1 :\n                              cinfo->out_color_components);\n\n  /* See if upsampler will want to emit more than one row at a time */\n  if (use_merged_upsample(cinfo))\n    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;\n  else\n    cinfo->rec_outbuf_height = 1;\n}\n\n\n/*\n * Several decompression processes need to range-limit values to the range\n * 0..MAXJSAMPLE; the input value may fall somewhat outside this range\n * due to noise introduced by quantization, roundoff error, etc.  These\n * processes are inner loops and need to be as fast as possible.  On most\n * machines, particularly CPUs with pipelines or instruction prefetch,\n * a (subscript-check-less) C table lookup\n *              x = sample_range_limit[x];\n * is faster than explicit tests\n *              if (x < 0)  x = 0;\n *              else if (x > MAXJSAMPLE)  x = MAXJSAMPLE;\n * These processes all use a common table prepared by the routine below.\n *\n * For most steps we can mathematically guarantee that the initial value\n * of x is within MAXJSAMPLE+1 of the legal range, so a table running from\n * -(MAXJSAMPLE+1) to 2*MAXJSAMPLE+1 is sufficient.  But for the initial\n * limiting step (just after the IDCT), a wildly out-of-range value is\n * possible if the input data is corrupt.  To avoid any chance of indexing\n * off the end of memory and getting a bad-pointer trap, we perform the\n * post-IDCT limiting thus:\n *              x = range_limit[x & MASK];\n * where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit\n * samples.  Under normal circumstances this is more than enough range and\n * a correct output will be generated; with bogus input data the mask will\n * cause wraparound, and we will safely generate a bogus-but-in-range output.\n * For the post-IDCT step, we want to convert the data from signed to unsigned\n * representation by adding CENTERJSAMPLE at the same time that we limit it.\n * So the post-IDCT limiting table ends up looking like this:\n *   CENTERJSAMPLE,CENTERJSAMPLE+1,...,MAXJSAMPLE,\n *   MAXJSAMPLE (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),\n *   0          (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),\n *   0,1,...,CENTERJSAMPLE-1\n * Negative inputs select values from the upper half of the table after\n * masking.\n *\n * We can save some space by overlapping the start of the post-IDCT table\n * with the simpler range limiting table.  The post-IDCT table begins at\n * sample_range_limit + CENTERJSAMPLE.\n */\n\nLOCAL(void)\nprepare_range_limit_table(j_decompress_ptr cinfo)\n/* Allocate and fill in the sample_range_limit table */\n{\n  JSAMPLE *table;\n  J12SAMPLE *table12;\n#ifdef D_LOSSLESS_SUPPORTED\n  J16SAMPLE *table16;\n#endif\n  int i;\n\n  if (cinfo->data_precision == 16) {\n#ifdef D_LOSSLESS_SUPPORTED\n    table16 = (J16SAMPLE *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                  (5 * (MAXJ16SAMPLE + 1) + CENTERJ16SAMPLE) *\n                  sizeof(J16SAMPLE));\n    table16 += (MAXJ16SAMPLE + 1);  /* allow negative subscripts of simple\n                                       table */\n    cinfo->sample_range_limit = (JSAMPLE *)table16;\n    /* First segment of \"simple\" table: limit[x] = 0 for x < 0 */\n    memset(table16 - (MAXJ16SAMPLE + 1), 0,\n           (MAXJ16SAMPLE + 1) * sizeof(J16SAMPLE));\n    /* Main part of \"simple\" table: limit[x] = x */\n    for (i = 0; i <= MAXJ16SAMPLE; i++)\n      table16[i] = (J16SAMPLE)i;\n    table16 += CENTERJ16SAMPLE; /* Point to where post-IDCT table starts */\n    /* End of simple table, rest of first half of post-IDCT table */\n    for (i = CENTERJ16SAMPLE; i < 2 * (MAXJ16SAMPLE + 1); i++)\n      table16[i] = MAXJ16SAMPLE;\n    /* Second half of post-IDCT table */\n    memset(table16 + (2 * (MAXJ16SAMPLE + 1)), 0,\n           (2 * (MAXJ16SAMPLE + 1) - CENTERJ16SAMPLE) * sizeof(J16SAMPLE));\n    memcpy(table16 + (4 * (MAXJ16SAMPLE + 1) - CENTERJ16SAMPLE),\n           cinfo->sample_range_limit, CENTERJ16SAMPLE * sizeof(J16SAMPLE));\n#else\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n#endif\n  } else if (cinfo->data_precision == 12) {\n    table12 = (J12SAMPLE *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                  (5 * (MAXJ12SAMPLE + 1) + CENTERJ12SAMPLE) *\n                  sizeof(J12SAMPLE));\n    table12 += (MAXJ12SAMPLE + 1);  /* allow negative subscripts of simple\n                                       table */\n    cinfo->sample_range_limit = (JSAMPLE *)table12;\n    /* First segment of \"simple\" table: limit[x] = 0 for x < 0 */\n    memset(table12 - (MAXJ12SAMPLE + 1), 0,\n           (MAXJ12SAMPLE + 1) * sizeof(J12SAMPLE));\n    /* Main part of \"simple\" table: limit[x] = x */\n    for (i = 0; i <= MAXJ12SAMPLE; i++)\n      table12[i] = (J12SAMPLE)i;\n    table12 += CENTERJ12SAMPLE; /* Point to where post-IDCT table starts */\n    /* End of simple table, rest of first half of post-IDCT table */\n    for (i = CENTERJ12SAMPLE; i < 2 * (MAXJ12SAMPLE + 1); i++)\n      table12[i] = MAXJ12SAMPLE;\n    /* Second half of post-IDCT table */\n    memset(table12 + (2 * (MAXJ12SAMPLE + 1)), 0,\n           (2 * (MAXJ12SAMPLE + 1) - CENTERJ12SAMPLE) * sizeof(J12SAMPLE));\n    memcpy(table12 + (4 * (MAXJ12SAMPLE + 1) - CENTERJ12SAMPLE),\n           cinfo->sample_range_limit, CENTERJ12SAMPLE * sizeof(J12SAMPLE));\n  } else {\n    table = (JSAMPLE *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                  (5 * (MAXJSAMPLE + 1) + CENTERJSAMPLE) * sizeof(JSAMPLE));\n    table += (MAXJSAMPLE + 1);  /* allow negative subscripts of simple table */\n    cinfo->sample_range_limit = table;\n    /* First segment of \"simple\" table: limit[x] = 0 for x < 0 */\n    memset(table - (MAXJSAMPLE + 1), 0, (MAXJSAMPLE + 1) * sizeof(JSAMPLE));\n    /* Main part of \"simple\" table: limit[x] = x */\n    for (i = 0; i <= MAXJSAMPLE; i++)\n      table[i] = (JSAMPLE)i;\n    table += CENTERJSAMPLE;     /* Point to where post-IDCT table starts */\n    /* End of simple table, rest of first half of post-IDCT table */\n    for (i = CENTERJSAMPLE; i < 2 * (MAXJSAMPLE + 1); i++)\n      table[i] = MAXJSAMPLE;\n    /* Second half of post-IDCT table */\n    memset(table + (2 * (MAXJSAMPLE + 1)), 0,\n           (2 * (MAXJSAMPLE + 1) - CENTERJSAMPLE) * sizeof(JSAMPLE));\n    memcpy(table + (4 * (MAXJSAMPLE + 1) - CENTERJSAMPLE),\n           cinfo->sample_range_limit, CENTERJSAMPLE * sizeof(JSAMPLE));\n  }\n}\n\n\n/*\n * Master selection of decompression modules.\n * This is done once at jpeg_start_decompress time.  We determine\n * which modules will be used and give them appropriate initialization calls.\n * We also initialize the decompressor input side to begin consuming data.\n *\n * Since jpeg_read_header has finished, we know what is in the SOF\n * and (first) SOS markers.  We also have all the application parameter\n * settings.\n */\n\nLOCAL(void)\nmaster_selection(j_decompress_ptr cinfo)\n{\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  boolean use_c_buffer;\n  long samplesperrow;\n  JDIMENSION jd_samplesperrow;\n\n  /* Disable IDCT scaling and raw (downsampled) data output in lossless mode.\n   * IDCT scaling is not useful in lossless mode, and it must be disabled in\n   * order to properly calculate the output dimensions.  Raw data output isn't\n   * particularly useful without subsampling and has not been tested in\n   * lossless mode.\n   */\n#ifdef D_LOSSLESS_SUPPORTED\n  if (cinfo->master->lossless) {\n    cinfo->raw_data_out = FALSE;\n    cinfo->scale_num = cinfo->scale_denom = 1;\n  }\n#endif\n\n  /* Initialize dimensions and other stuff */\n  jpeg_calc_output_dimensions(cinfo);\n  prepare_range_limit_table(cinfo);\n\n  /* Width of an output scanline must be representable as JDIMENSION. */\n  samplesperrow = (long)cinfo->output_width *\n                  (long)cinfo->out_color_components;\n  jd_samplesperrow = (JDIMENSION)samplesperrow;\n  if ((long)jd_samplesperrow != samplesperrow)\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n\n  /* Initialize my private state */\n  master->pass_number = 0;\n  master->using_merged_upsample = use_merged_upsample(cinfo);\n\n  /* Color quantizer selection */\n  master->quantizer_1pass = NULL;\n  master->quantizer_2pass = NULL;\n  /* No mode changes if not using buffered-image mode. */\n  if (!cinfo->quantize_colors || !cinfo->buffered_image) {\n    cinfo->enable_1pass_quant = FALSE;\n    cinfo->enable_external_quant = FALSE;\n    cinfo->enable_2pass_quant = FALSE;\n  }\n  if (cinfo->quantize_colors) {\n    if (cinfo->raw_data_out)\n      ERREXIT(cinfo, JERR_NOTIMPL);\n    /* 2-pass quantizer only works in 3-component color space. */\n    if (cinfo->out_color_components != 3 ||\n        cinfo->out_color_space == JCS_RGB565) {\n      cinfo->enable_1pass_quant = TRUE;\n      cinfo->enable_external_quant = FALSE;\n      cinfo->enable_2pass_quant = FALSE;\n      cinfo->colormap = NULL;\n    } else if (cinfo->colormap != NULL) {\n      cinfo->enable_external_quant = TRUE;\n    } else if (cinfo->two_pass_quantize) {\n      cinfo->enable_2pass_quant = TRUE;\n    } else {\n      cinfo->enable_1pass_quant = TRUE;\n    }\n\n    if (cinfo->enable_1pass_quant) {\n#ifdef QUANT_1PASS_SUPPORTED\n      if (cinfo->data_precision == 16)\n        ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n      else if (cinfo->data_precision == 12)\n        j12init_1pass_quantizer(cinfo);\n      else\n        jinit_1pass_quantizer(cinfo);\n      master->quantizer_1pass = cinfo->cquantize;\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n    }\n\n    /* We use the 2-pass code to map to external colormaps. */\n    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {\n#ifdef QUANT_2PASS_SUPPORTED\n      if (cinfo->data_precision == 16)\n        ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n      else if (cinfo->data_precision == 12)\n        j12init_2pass_quantizer(cinfo);\n      else\n        jinit_2pass_quantizer(cinfo);\n      master->quantizer_2pass = cinfo->cquantize;\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n    }\n    /* If both quantizers are initialized, the 2-pass one is left active;\n     * this is necessary for starting with quantization to an external map.\n     */\n  }\n\n  /* Post-processing: in particular, color conversion first */\n  if (!cinfo->raw_data_out) {\n    if (master->using_merged_upsample) {\n#ifdef UPSAMPLE_MERGING_SUPPORTED\n      if (cinfo->data_precision == 16)\n        ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n      else if (cinfo->data_precision == 12)\n        j12init_merged_upsampler(cinfo); /* does color conversion too */\n      else\n        jinit_merged_upsampler(cinfo); /* does color conversion too */\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n    } else {\n      if (cinfo->data_precision == 16) {\n#ifdef D_LOSSLESS_SUPPORTED\n        j16init_color_deconverter(cinfo);\n        j16init_upsampler(cinfo);\n#else\n        ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n#endif\n      } else if (cinfo->data_precision == 12) {\n        j12init_color_deconverter(cinfo);\n        j12init_upsampler(cinfo);\n      } else {\n        jinit_color_deconverter(cinfo);\n        jinit_upsampler(cinfo);\n      }\n    }\n    if (cinfo->data_precision == 16)\n#ifdef D_LOSSLESS_SUPPORTED\n      j16init_d_post_controller(cinfo, cinfo->enable_2pass_quant);\n#else\n      ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n#endif\n    else if (cinfo->data_precision == 12)\n      j12init_d_post_controller(cinfo, cinfo->enable_2pass_quant);\n    else\n      jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);\n  }\n\n  if (cinfo->master->lossless) {\n#ifdef D_LOSSLESS_SUPPORTED\n    /* Prediction, sample undifferencing, point transform, and sample size\n     * scaling\n     */\n    if (cinfo->data_precision == 16)\n      j16init_lossless_decompressor(cinfo);\n    else if (cinfo->data_precision == 12)\n      j12init_lossless_decompressor(cinfo);\n    else\n      jinit_lossless_decompressor(cinfo);\n    /* Entropy decoding: either Huffman or arithmetic coding. */\n    if (cinfo->arith_code) {\n      ERREXIT(cinfo, JERR_ARITH_NOTIMPL);\n    } else {\n      jinit_lhuff_decoder(cinfo);\n    }\n\n    /* Initialize principal buffer controllers. */\n    use_c_buffer = cinfo->inputctl->has_multiple_scans ||\n                   cinfo->buffered_image;\n    if (cinfo->data_precision == 16)\n      j16init_d_diff_controller(cinfo, use_c_buffer);\n    else if (cinfo->data_precision == 12)\n      j12init_d_diff_controller(cinfo, use_c_buffer);\n    else\n      jinit_d_diff_controller(cinfo, use_c_buffer);\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n  } else {\n    if (cinfo->data_precision == 16)\n      ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n    /* Inverse DCT */\n    if (cinfo->data_precision == 12)\n      j12init_inverse_dct(cinfo);\n    else\n      jinit_inverse_dct(cinfo);\n    /* Entropy decoding: either Huffman or arithmetic coding. */\n    if (cinfo->arith_code) {\n#ifdef D_ARITH_CODING_SUPPORTED\n      jinit_arith_decoder(cinfo);\n#else\n      ERREXIT(cinfo, JERR_ARITH_NOTIMPL);\n#endif\n    } else {\n      if (cinfo->progressive_mode) {\n#ifdef D_PROGRESSIVE_SUPPORTED\n        jinit_phuff_decoder(cinfo);\n#else\n        ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n      } else\n        jinit_huff_decoder(cinfo);\n    }\n\n    /* Initialize principal buffer controllers. */\n    use_c_buffer = cinfo->inputctl->has_multiple_scans ||\n                   cinfo->buffered_image;\n    if (cinfo->data_precision == 12)\n      j12init_d_coef_controller(cinfo, use_c_buffer);\n    else\n      jinit_d_coef_controller(cinfo, use_c_buffer);\n  }\n\n  if (!cinfo->raw_data_out) {\n    if (cinfo->data_precision == 16)\n#ifdef D_LOSSLESS_SUPPORTED\n      j16init_d_main_controller(cinfo,\n                                FALSE /* never need full buffer here */);\n#else\n      ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n#endif\n    else if (cinfo->data_precision == 12)\n      j12init_d_main_controller(cinfo,\n                                FALSE /* never need full buffer here */);\n    else\n      jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);\n  }\n\n  /* We can now tell the memory manager to allocate virtual arrays. */\n  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr)cinfo);\n\n  /* Initialize input side of decompressor to consume first scan. */\n  (*cinfo->inputctl->start_input_pass) (cinfo);\n\n  /* Set the first and last iMCU columns to decompress from single-scan images.\n   * By default, decompress all of the iMCU columns.\n   */\n  cinfo->master->first_iMCU_col = 0;\n  cinfo->master->last_iMCU_col = cinfo->MCUs_per_row - 1;\n  cinfo->master->last_good_iMCU_row = 0;\n\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n  /* If jpeg_start_decompress will read the whole file, initialize\n   * progress monitoring appropriately.  The input step is counted\n   * as one pass.\n   */\n  if (cinfo->progress != NULL && !cinfo->buffered_image &&\n      cinfo->inputctl->has_multiple_scans) {\n    int nscans;\n    /* Estimate number of scans to set pass_limit. */\n    if (cinfo->progressive_mode) {\n      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */\n      nscans = 2 + 3 * cinfo->num_components;\n    } else {\n      /* For a nonprogressive multiscan file, estimate 1 scan per component. */\n      nscans = cinfo->num_components;\n    }\n    cinfo->progress->pass_counter = 0L;\n    cinfo->progress->pass_limit = (long)cinfo->total_iMCU_rows * nscans;\n    cinfo->progress->completed_passes = 0;\n    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);\n    /* Count the input pass as done */\n    master->pass_number++;\n  }\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\n}\n\n\n/*\n * Per-pass setup.\n * This is called at the beginning of each output pass.  We determine which\n * modules will be active during this pass and give them appropriate\n * start_pass calls.  We also set is_dummy_pass to indicate whether this\n * is a \"real\" output pass or a dummy pass for color quantization.\n * (In the latter case, jdapistd.c will crank the pass to completion.)\n */\n\nMETHODDEF(void)\nprepare_for_output_pass(j_decompress_ptr cinfo)\n{\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n\n  if (master->pub.is_dummy_pass) {\n#ifdef QUANT_2PASS_SUPPORTED\n    /* Final pass of 2-pass quantization */\n    master->pub.is_dummy_pass = FALSE;\n    (*cinfo->cquantize->start_pass) (cinfo, FALSE);\n    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);\n    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);\n#else\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif /* QUANT_2PASS_SUPPORTED */\n  } else {\n    if (cinfo->quantize_colors && cinfo->colormap == NULL) {\n      /* Select new quantization method */\n      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {\n        cinfo->cquantize = master->quantizer_2pass;\n        master->pub.is_dummy_pass = TRUE;\n      } else if (cinfo->enable_1pass_quant) {\n        cinfo->cquantize = master->quantizer_1pass;\n      } else {\n        ERREXIT(cinfo, JERR_MODE_CHANGE);\n      }\n    }\n    (*cinfo->idct->start_pass) (cinfo);\n    (*cinfo->coef->start_output_pass) (cinfo);\n    if (!cinfo->raw_data_out) {\n      if (!master->using_merged_upsample)\n        (*cinfo->cconvert->start_pass) (cinfo);\n      (*cinfo->upsample->start_pass) (cinfo);\n      if (cinfo->quantize_colors)\n        (*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);\n      (*cinfo->post->start_pass) (cinfo,\n            (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));\n      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);\n    }\n  }\n\n  /* Set up progress monitor's pass info if present */\n  if (cinfo->progress != NULL) {\n    cinfo->progress->completed_passes = master->pass_number;\n    cinfo->progress->total_passes = master->pass_number +\n                                    (master->pub.is_dummy_pass ? 2 : 1);\n    /* In buffered-image mode, we assume one more output pass if EOI not\n     * yet reached, but no more passes if EOI has been reached.\n     */\n    if (cinfo->buffered_image && !cinfo->inputctl->eoi_reached) {\n      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);\n    }\n  }\n}\n\n\n/*\n * Finish up at end of an output pass.\n */\n\nMETHODDEF(void)\nfinish_output_pass(j_decompress_ptr cinfo)\n{\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n\n  if (cinfo->quantize_colors)\n    (*cinfo->cquantize->finish_pass) (cinfo);\n  master->pass_number++;\n}\n\n\n#ifdef D_MULTISCAN_FILES_SUPPORTED\n\n/*\n * Switch to a new external colormap between output passes.\n */\n\nGLOBAL(void)\njpeg_new_colormap(j_decompress_ptr cinfo)\n{\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n\n  /* Prevent application from calling me at wrong times */\n  if (cinfo->global_state != DSTATE_BUFIMAGE)\n    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n\n  if (cinfo->quantize_colors && cinfo->enable_external_quant &&\n      cinfo->colormap != NULL) {\n    /* Select 2-pass quantizer for external colormap use */\n    cinfo->cquantize = master->quantizer_2pass;\n    /* Notify quantizer of colormap change */\n    (*cinfo->cquantize->new_color_map) (cinfo);\n    master->pub.is_dummy_pass = FALSE; /* just in case */\n  } else\n    ERREXIT(cinfo, JERR_MODE_CHANGE);\n}\n\n#endif /* D_MULTISCAN_FILES_SUPPORTED */\n\n\n/*\n * Initialize master decompression control and select active modules.\n * This is performed at the start of jpeg_start_decompress.\n */\n\nGLOBAL(void)\njinit_master_decompress(j_decompress_ptr cinfo)\n{\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n\n  master->pub.prepare_for_output_pass = prepare_for_output_pass;\n  master->pub.finish_output_pass = finish_output_pass;\n\n  master->pub.is_dummy_pass = FALSE;\n  master->pub.jinit_upsampler_no_alloc = FALSE;\n\n  master_selection(cinfo);\n}\n"
        },
        {
          "name": "jdmaster.h",
          "type": "blob",
          "size": 0.873046875,
          "content": "/*\n * jdmaster.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1995, Thomas G. Lane.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the master control structure for the JPEG decompressor.\n */\n\n/* Private state */\n\ntypedef struct {\n  struct jpeg_decomp_master pub; /* public fields */\n\n  int pass_number;              /* # of passes completed */\n\n  boolean using_merged_upsample; /* TRUE if using merged upsample/cconvert */\n\n  /* Saved references to initialized quantizer modules,\n   * in case we need to switch modes.\n   */\n  struct jpeg_color_quantizer *quantizer_1pass;\n  struct jpeg_color_quantizer *quantizer_2pass;\n\n  /*\n   * Permit users to replace the IDCT method\n  */\n  jpeg_idct_method_selector custom_idct_selector;\n} my_decomp_master;\n\ntypedef my_decomp_master *my_master_ptr;\n"
        },
        {
          "name": "jdmerge.c",
          "type": "blob",
          "size": 19.5107421875,
          "content": "/*\n * jdmerge.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2009, 2011, 2014-2015, 2020, 2022, D. R. Commander.\n * Copyright (C) 2013, Linaro Limited.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains code for merged upsampling/color conversion.\n *\n * This file combines functions from jdsample.c and jdcolor.c;\n * read those files first to understand what's going on.\n *\n * When the chroma components are to be upsampled by simple replication\n * (ie, box filtering), we can save some work in color conversion by\n * calculating all the output pixels corresponding to a pair of chroma\n * samples at one time.  In the conversion equations\n *      R = Y           + K1 * Cr\n *      G = Y + K2 * Cb + K3 * Cr\n *      B = Y + K4 * Cb\n * only the Y term varies among the group of pixels corresponding to a pair\n * of chroma samples, so the rest of the terms can be calculated just once.\n * At typical sampling ratios, this eliminates half or three-quarters of the\n * multiplications needed for color conversion.\n *\n * This file currently provides implementations for the following cases:\n *      YCbCr => RGB color conversion only.\n *      Sampling ratios of 2h1v or 2h2v.\n *      No scaling needed at upsample time.\n *      Corner-aligned (non-CCIR601) sampling alignment.\n * Other special cases could be added, but in most applications these are\n * the only common cases.  (For uncommon cases we fall back on the more\n * general code in jdsample.c and jdcolor.c.)\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdmerge.h\"\n#include \"jsimd.h\"\n\n#ifdef UPSAMPLE_MERGING_SUPPORTED\n\n\n#define SCALEBITS       16      /* speediest right-shift on some machines */\n#define ONE_HALF        ((JLONG)1 << (SCALEBITS - 1))\n#define FIX(x)          ((JLONG)((x) * (1L << SCALEBITS) + 0.5))\n\n\n/* Include inline routines for colorspace extensions */\n\n#include \"jdmrgext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n\n#define RGB_RED  EXT_RGB_RED\n#define RGB_GREEN  EXT_RGB_GREEN\n#define RGB_BLUE  EXT_RGB_BLUE\n#define RGB_PIXELSIZE  EXT_RGB_PIXELSIZE\n#define h2v1_merged_upsample_internal  extrgb_h2v1_merged_upsample_internal\n#define h2v2_merged_upsample_internal  extrgb_h2v2_merged_upsample_internal\n#include \"jdmrgext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n#undef h2v1_merged_upsample_internal\n#undef h2v2_merged_upsample_internal\n\n#define RGB_RED  EXT_RGBX_RED\n#define RGB_GREEN  EXT_RGBX_GREEN\n#define RGB_BLUE  EXT_RGBX_BLUE\n#define RGB_ALPHA  3\n#define RGB_PIXELSIZE  EXT_RGBX_PIXELSIZE\n#define h2v1_merged_upsample_internal  extrgbx_h2v1_merged_upsample_internal\n#define h2v2_merged_upsample_internal  extrgbx_h2v2_merged_upsample_internal\n#include \"jdmrgext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_ALPHA\n#undef RGB_PIXELSIZE\n#undef h2v1_merged_upsample_internal\n#undef h2v2_merged_upsample_internal\n\n#define RGB_RED  EXT_BGR_RED\n#define RGB_GREEN  EXT_BGR_GREEN\n#define RGB_BLUE  EXT_BGR_BLUE\n#define RGB_PIXELSIZE  EXT_BGR_PIXELSIZE\n#define h2v1_merged_upsample_internal  extbgr_h2v1_merged_upsample_internal\n#define h2v2_merged_upsample_internal  extbgr_h2v2_merged_upsample_internal\n#include \"jdmrgext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_PIXELSIZE\n#undef h2v1_merged_upsample_internal\n#undef h2v2_merged_upsample_internal\n\n#define RGB_RED  EXT_BGRX_RED\n#define RGB_GREEN  EXT_BGRX_GREEN\n#define RGB_BLUE  EXT_BGRX_BLUE\n#define RGB_ALPHA  3\n#define RGB_PIXELSIZE  EXT_BGRX_PIXELSIZE\n#define h2v1_merged_upsample_internal  extbgrx_h2v1_merged_upsample_internal\n#define h2v2_merged_upsample_internal  extbgrx_h2v2_merged_upsample_internal\n#include \"jdmrgext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_ALPHA\n#undef RGB_PIXELSIZE\n#undef h2v1_merged_upsample_internal\n#undef h2v2_merged_upsample_internal\n\n#define RGB_RED  EXT_XBGR_RED\n#define RGB_GREEN  EXT_XBGR_GREEN\n#define RGB_BLUE  EXT_XBGR_BLUE\n#define RGB_ALPHA  0\n#define RGB_PIXELSIZE  EXT_XBGR_PIXELSIZE\n#define h2v1_merged_upsample_internal  extxbgr_h2v1_merged_upsample_internal\n#define h2v2_merged_upsample_internal  extxbgr_h2v2_merged_upsample_internal\n#include \"jdmrgext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_ALPHA\n#undef RGB_PIXELSIZE\n#undef h2v1_merged_upsample_internal\n#undef h2v2_merged_upsample_internal\n\n#define RGB_RED  EXT_XRGB_RED\n#define RGB_GREEN  EXT_XRGB_GREEN\n#define RGB_BLUE  EXT_XRGB_BLUE\n#define RGB_ALPHA  0\n#define RGB_PIXELSIZE  EXT_XRGB_PIXELSIZE\n#define h2v1_merged_upsample_internal  extxrgb_h2v1_merged_upsample_internal\n#define h2v2_merged_upsample_internal  extxrgb_h2v2_merged_upsample_internal\n#include \"jdmrgext.c\"\n#undef RGB_RED\n#undef RGB_GREEN\n#undef RGB_BLUE\n#undef RGB_ALPHA\n#undef RGB_PIXELSIZE\n#undef h2v1_merged_upsample_internal\n#undef h2v2_merged_upsample_internal\n\n\n/*\n * Initialize tables for YCC->RGB colorspace conversion.\n * This is taken directly from jdcolor.c; see that file for more info.\n */\n\nLOCAL(void)\nbuild_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (_MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (_MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (_MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (_MAXJSAMPLE + 1) * sizeof(JLONG));\n\n  for (i = 0, x = -_CENTERJSAMPLE; i <= _MAXJSAMPLE; i++, x++) {\n    /* i is the actual input pixel value, in the range 0.._MAXJSAMPLE */\n    /* The Cb or Cr value we are thinking of is x = i - _CENTERJSAMPLE */\n    /* Cr=>R value is nearest int to 1.40200 * x */\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    /* Cb=>B value is nearest int to 1.77200 * x */\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    /* Cr=>G value is scaled-up -0.71414 * x */\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    /* Cb=>G value is scaled-up -0.34414 * x */\n    /* We also add in ONE_HALF so that need not do it in inner loop */\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}\n\n\n/*\n * Initialize for an upsampling pass.\n */\n\nMETHODDEF(void)\nstart_pass_merged_upsample(j_decompress_ptr cinfo)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n\n  /* Mark the spare buffer empty */\n  upsample->spare_full = FALSE;\n  /* Initialize total-height counter for detecting bottom of image */\n  upsample->rows_to_go = cinfo->output_height;\n}\n\n\n/*\n * Control routine to do upsampling (and color conversion).\n *\n * The control routine just handles the row buffering considerations.\n */\n\nMETHODDEF(void)\nmerged_2v_upsample(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, _JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n/* 2:1 vertical sampling case: may need a spare row. */\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  _JSAMPROW work_ptrs[2];\n  JDIMENSION num_rows;          /* number of rows returned to caller */\n\n  if (upsample->spare_full) {\n    /* If we have a spare row saved from a previous cycle, just return it. */\n    JDIMENSION size = upsample->out_row_width;\n    if (cinfo->out_color_space == JCS_RGB565)\n      size = cinfo->output_width * 2;\n    _jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0,\n                       1, size);\n    num_rows = 1;\n    upsample->spare_full = FALSE;\n  } else {\n    /* Figure number of rows to return to caller. */\n    num_rows = 2;\n    /* Not more than the distance to the end of the image. */\n    if (num_rows > upsample->rows_to_go)\n      num_rows = upsample->rows_to_go;\n    /* And not more than what the client can accept: */\n    out_rows_avail -= *out_row_ctr;\n    if (num_rows > out_rows_avail)\n      num_rows = out_rows_avail;\n    /* Create output pointer array for upsampler. */\n    work_ptrs[0] = output_buf[*out_row_ctr];\n    if (num_rows > 1) {\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\n    } else {\n      work_ptrs[1] = upsample->spare_row;\n      upsample->spare_full = TRUE;\n    }\n    /* Now do the upsampling. */\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\n  }\n\n  /* Adjust counts */\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  /* When the buffer is emptied, declare this input row group consumed */\n  if (!upsample->spare_full)\n    (*in_row_group_ctr)++;\n}\n\n\nMETHODDEF(void)\nmerged_1v_upsample(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, _JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n/* 1:1 vertical sampling case: much easier, never need a spare row. */\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n\n  /* Just do the upsampling. */\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  /* Adjust counts */\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}\n\n\n/*\n * These are the routines invoked by the control routines to do\n * the actual upsampling/conversion.  One row group is processed per call.\n *\n * Note: since we may be writing directly into application-supplied buffers,\n * we have to be honest about the output width; we can't assume the buffer\n * has been rounded up to an even width.\n */\n\n\n/*\n * Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.\n */\n\nMETHODDEF(void)\nh2v1_merged_upsample(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                     JDIMENSION in_row_group_ctr, _JSAMPARRAY output_buf)\n{\n  switch (cinfo->out_color_space) {\n  case JCS_EXT_RGB:\n    extrgb_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                         output_buf);\n    break;\n  case JCS_EXT_RGBX:\n  case JCS_EXT_RGBA:\n    extrgbx_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                          output_buf);\n    break;\n  case JCS_EXT_BGR:\n    extbgr_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                         output_buf);\n    break;\n  case JCS_EXT_BGRX:\n  case JCS_EXT_BGRA:\n    extbgrx_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                          output_buf);\n    break;\n  case JCS_EXT_XBGR:\n  case JCS_EXT_ABGR:\n    extxbgr_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                          output_buf);\n    break;\n  case JCS_EXT_XRGB:\n  case JCS_EXT_ARGB:\n    extxrgb_h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                          output_buf);\n    break;\n  default:\n    h2v1_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                  output_buf);\n    break;\n  }\n}\n\n\n/*\n * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.\n */\n\nMETHODDEF(void)\nh2v2_merged_upsample(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                     JDIMENSION in_row_group_ctr, _JSAMPARRAY output_buf)\n{\n  switch (cinfo->out_color_space) {\n  case JCS_EXT_RGB:\n    extrgb_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                         output_buf);\n    break;\n  case JCS_EXT_RGBX:\n  case JCS_EXT_RGBA:\n    extrgbx_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                          output_buf);\n    break;\n  case JCS_EXT_BGR:\n    extbgr_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                         output_buf);\n    break;\n  case JCS_EXT_BGRX:\n  case JCS_EXT_BGRA:\n    extbgrx_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                          output_buf);\n    break;\n  case JCS_EXT_XBGR:\n  case JCS_EXT_ABGR:\n    extxbgr_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                          output_buf);\n    break;\n  case JCS_EXT_XRGB:\n  case JCS_EXT_ARGB:\n    extxrgb_h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                          output_buf);\n    break;\n  default:\n    h2v2_merged_upsample_internal(cinfo, input_buf, in_row_group_ctr,\n                                  output_buf);\n    break;\n  }\n}\n\n\n/*\n * RGB565 conversion\n */\n\n#define PACK_SHORT_565_LE(r, g, b) \\\n  ((((r) << 8) & 0xF800) | (((g) << 3) & 0x7E0) | ((b) >> 3))\n#define PACK_SHORT_565_BE(r, g, b) \\\n  (((r) & 0xF8) | ((g) >> 5) | (((g) << 11) & 0xE000) | (((b) << 5) & 0x1F00))\n\n#define PACK_TWO_PIXELS_LE(l, r)    ((r << 16) | l)\n#define PACK_TWO_PIXELS_BE(l, r)    ((l << 16) | r)\n\n#define WRITE_TWO_PIXELS_LE(addr, pixels) { \\\n  ((INT16 *)(addr))[0] = (INT16)(pixels); \\\n  ((INT16 *)(addr))[1] = (INT16)((pixels) >> 16); \\\n}\n#define WRITE_TWO_PIXELS_BE(addr, pixels) { \\\n  ((INT16 *)(addr))[1] = (INT16)(pixels); \\\n  ((INT16 *)(addr))[0] = (INT16)((pixels) >> 16); \\\n}\n\n#define DITHER_565_R(r, dither)  ((r) + ((dither) & 0xFF))\n#define DITHER_565_G(g, dither)  ((g) + (((dither) & 0xFF) >> 1))\n#define DITHER_565_B(b, dither)  ((b) + ((dither) & 0xFF))\n\n\n/* Declarations for ordered dithering\n *\n * We use a 4x4 ordered dither array packed into 32 bits.  This array is\n * sufficient for dithering RGB888 to RGB565.\n */\n\n#define DITHER_MASK       0x3\n#define DITHER_ROTATE(x)  ((((x) & 0xFF) << 24) | (((x) >> 8) & 0x00FFFFFF))\nstatic const JLONG dither_matrix[4] = {\n  0x0008020A,\n  0x0C040E06,\n  0x030B0109,\n  0x0F070D05\n};\n\n\n/* Include inline routines for RGB565 conversion */\n\n#define PACK_SHORT_565  PACK_SHORT_565_LE\n#define PACK_TWO_PIXELS  PACK_TWO_PIXELS_LE\n#define WRITE_TWO_PIXELS  WRITE_TWO_PIXELS_LE\n#define h2v1_merged_upsample_565_internal  h2v1_merged_upsample_565_le\n#define h2v1_merged_upsample_565D_internal  h2v1_merged_upsample_565D_le\n#define h2v2_merged_upsample_565_internal  h2v2_merged_upsample_565_le\n#define h2v2_merged_upsample_565D_internal  h2v2_merged_upsample_565D_le\n#include \"jdmrg565.c\"\n#undef PACK_SHORT_565\n#undef PACK_TWO_PIXELS\n#undef WRITE_TWO_PIXELS\n#undef h2v1_merged_upsample_565_internal\n#undef h2v1_merged_upsample_565D_internal\n#undef h2v2_merged_upsample_565_internal\n#undef h2v2_merged_upsample_565D_internal\n\n#define PACK_SHORT_565  PACK_SHORT_565_BE\n#define PACK_TWO_PIXELS  PACK_TWO_PIXELS_BE\n#define WRITE_TWO_PIXELS  WRITE_TWO_PIXELS_BE\n#define h2v1_merged_upsample_565_internal  h2v1_merged_upsample_565_be\n#define h2v1_merged_upsample_565D_internal  h2v1_merged_upsample_565D_be\n#define h2v2_merged_upsample_565_internal  h2v2_merged_upsample_565_be\n#define h2v2_merged_upsample_565D_internal  h2v2_merged_upsample_565D_be\n#include \"jdmrg565.c\"\n#undef PACK_SHORT_565\n#undef PACK_TWO_PIXELS\n#undef WRITE_TWO_PIXELS\n#undef h2v1_merged_upsample_565_internal\n#undef h2v1_merged_upsample_565D_internal\n#undef h2v2_merged_upsample_565_internal\n#undef h2v2_merged_upsample_565D_internal\n\n\nstatic INLINE boolean is_big_endian(void)\n{\n  int test_value = 1;\n  if (*(char *)&test_value != 1)\n    return TRUE;\n  return FALSE;\n}\n\n\nMETHODDEF(void)\nh2v1_merged_upsample_565(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                         JDIMENSION in_row_group_ctr, _JSAMPARRAY output_buf)\n{\n  if (is_big_endian())\n    h2v1_merged_upsample_565_be(cinfo, input_buf, in_row_group_ctr,\n                                output_buf);\n  else\n    h2v1_merged_upsample_565_le(cinfo, input_buf, in_row_group_ctr,\n                                output_buf);\n}\n\n\nMETHODDEF(void)\nh2v1_merged_upsample_565D(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                          JDIMENSION in_row_group_ctr, _JSAMPARRAY output_buf)\n{\n  if (is_big_endian())\n    h2v1_merged_upsample_565D_be(cinfo, input_buf, in_row_group_ctr,\n                                 output_buf);\n  else\n    h2v1_merged_upsample_565D_le(cinfo, input_buf, in_row_group_ctr,\n                                 output_buf);\n}\n\n\nMETHODDEF(void)\nh2v2_merged_upsample_565(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                         JDIMENSION in_row_group_ctr, _JSAMPARRAY output_buf)\n{\n  if (is_big_endian())\n    h2v2_merged_upsample_565_be(cinfo, input_buf, in_row_group_ctr,\n                                output_buf);\n  else\n    h2v2_merged_upsample_565_le(cinfo, input_buf, in_row_group_ctr,\n                                output_buf);\n}\n\n\nMETHODDEF(void)\nh2v2_merged_upsample_565D(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                          JDIMENSION in_row_group_ctr, _JSAMPARRAY output_buf)\n{\n  if (is_big_endian())\n    h2v2_merged_upsample_565D_be(cinfo, input_buf, in_row_group_ctr,\n                                 output_buf);\n  else\n    h2v2_merged_upsample_565D_le(cinfo, input_buf, in_row_group_ctr,\n                                 output_buf);\n}\n\n\n/*\n * Module initialization routine for merged upsampling/color conversion.\n *\n * NB: this is called under the conditions determined by use_merged_upsample()\n * in jdmaster.c.  That routine MUST correspond to the actual capabilities\n * of this module; no safety checks are made here.\n */\n\nGLOBAL(void)\n_jinit_merged_upsampler(j_decompress_ptr cinfo)\n{\n  my_merged_upsample_ptr upsample;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  upsample = (my_merged_upsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_merged_upsampler));\n  cinfo->upsample = (struct jpeg_upsampler *)upsample;\n  upsample->pub.start_pass = start_pass_merged_upsample;\n  upsample->pub.need_context_rows = FALSE;\n\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\n\n  if (cinfo->max_v_samp_factor == 2) {\n    upsample->pub._upsample = merged_2v_upsample;\n#ifdef WITH_SIMD\n    if (jsimd_can_h2v2_merged_upsample())\n      upsample->upmethod = jsimd_h2v2_merged_upsample;\n    else\n#endif\n      upsample->upmethod = h2v2_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v2_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v2_merged_upsample_565;\n      }\n    }\n    /* Allocate a spare row buffer */\n    upsample->spare_row = (_JSAMPROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                (size_t)(upsample->out_row_width * sizeof(_JSAMPLE)));\n  } else {\n    upsample->pub._upsample = merged_1v_upsample;\n#ifdef WITH_SIMD\n    if (jsimd_can_h2v1_merged_upsample())\n      upsample->upmethod = jsimd_h2v1_merged_upsample;\n    else\n#endif\n      upsample->upmethod = h2v1_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v1_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v1_merged_upsample_565;\n      }\n    }\n    /* No spare row needed */\n    upsample->spare_row = NULL;\n  }\n\n  build_ycc_rgb_table(cinfo);\n}\n\n#endif /* UPSAMPLE_MERGING_SUPPORTED */\n"
        },
        {
          "name": "jdmerge.h",
          "type": "blob",
          "size": 1.625,
          "content": "/*\n * jdmerge.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2020, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n */\n\n#define JPEG_INTERNALS\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n\n#ifdef UPSAMPLE_MERGING_SUPPORTED\n\n\n/* Private subobject */\n\ntypedef struct {\n  struct jpeg_upsampler pub;    /* public fields */\n\n  /* Pointer to routine to do actual upsampling/conversion of one row group */\n  void (*upmethod) (j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                    JDIMENSION in_row_group_ctr, _JSAMPARRAY output_buf);\n\n  /* Private state for YCC->RGB conversion */\n  int *Cr_r_tab;                /* => table for Cr to R conversion */\n  int *Cb_b_tab;                /* => table for Cb to B conversion */\n  JLONG *Cr_g_tab;              /* => table for Cr to G conversion */\n  JLONG *Cb_g_tab;              /* => table for Cb to G conversion */\n\n  /* For 2:1 vertical sampling, we produce two output rows at a time.\n   * We need a \"spare\" row buffer to hold the second output row if the\n   * application provides just a one-row buffer; we also use the spare\n   * to discard the dummy last row if the image height is odd.\n   */\n  _JSAMPROW spare_row;\n  boolean spare_full;           /* T if spare buffer is occupied */\n\n  JDIMENSION out_row_width;     /* samples per output row */\n  JDIMENSION rows_to_go;        /* counts rows remaining in image */\n} my_merged_upsampler;\n\ntypedef my_merged_upsampler *my_merged_upsample_ptr;\n\n#endif /* UPSAMPLE_MERGING_SUPPORTED */\n"
        },
        {
          "name": "jdmrg565.c",
          "type": "blob",
          "size": 10.876953125,
          "content": "/*\n * jdmrg565.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2013, Linaro Limited.\n * Copyright (C) 2014-2015, 2018, 2020, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains code for merged upsampling/color conversion.\n */\n\n\nINLINE\nLOCAL(void)\nh2v1_merged_upsample_565_internal(j_decompress_ptr cinfo,\n                                  _JSAMPIMAGE input_buf,\n                                  JDIMENSION in_row_group_ctr,\n                                  _JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register _JSAMPROW outptr;\n  _JSAMPROW inptr0, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  unsigned int r, g, b;\n  JLONG rgb;\n  SHIFT_TEMPS\n\n  inptr0 = input_buf[0][in_row_group_ctr];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr = output_buf[0];\n\n  /* Loop for each pair of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = *inptr1++;\n    cr = *inptr2++;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    /* Fetch 2 Y values and emit 2 pixels */\n    y  = *inptr0++;\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = *inptr0++;\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr, rgb);\n    outptr += 4;\n  }\n\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = *inptr1;\n    cr = *inptr2;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = *inptr0;\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr = (INT16)rgb;\n  }\n}\n\n\nINLINE\nLOCAL(void)\nh2v1_merged_upsample_565D_internal(j_decompress_ptr cinfo,\n                                   _JSAMPIMAGE input_buf,\n                                   JDIMENSION in_row_group_ctr,\n                                   _JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register _JSAMPROW outptr;\n  _JSAMPROW inptr0, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];\n  unsigned int r, g, b;\n  JLONG rgb;\n  SHIFT_TEMPS\n\n  inptr0 = input_buf[0][in_row_group_ctr];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr = output_buf[0];\n\n  /* Loop for each pair of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = *inptr1++;\n    cr = *inptr2++;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    /* Fetch 2 Y values and emit 2 pixels */\n    y  = *inptr0++;\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    d0 = DITHER_ROTATE(d0);\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = *inptr0++;\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    d0 = DITHER_ROTATE(d0);\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr, rgb);\n    outptr += 4;\n  }\n\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = *inptr1;\n    cr = *inptr2;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = *inptr0;\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr = (INT16)rgb;\n  }\n}\n\n\nINLINE\nLOCAL(void)\nh2v2_merged_upsample_565_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                                  JDIMENSION in_row_group_ctr,\n                                  _JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register _JSAMPROW outptr0, outptr1;\n  _JSAMPROW inptr00, inptr01, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  unsigned int r, g, b;\n  JLONG rgb;\n  SHIFT_TEMPS\n\n  inptr00 = input_buf[0][in_row_group_ctr * 2];\n  inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr0 = output_buf[0];\n  outptr1 = output_buf[1];\n\n  /* Loop for each group of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = *inptr1++;\n    cr = *inptr2++;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    /* Fetch 4 Y values and emit 4 pixels */\n    y  = *inptr00++;\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = *inptr00++;\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr0, rgb);\n    outptr0 += 4;\n\n    y  = *inptr01++;\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = *inptr01++;\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr1, rgb);\n    outptr1 += 4;\n  }\n\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = *inptr1;\n    cr = *inptr2;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    y  = *inptr00;\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr0 = (INT16)rgb;\n\n    y  = *inptr01;\n    r = range_limit[y + cred];\n    g = range_limit[y + cgreen];\n    b = range_limit[y + cblue];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr1 = (INT16)rgb;\n  }\n}\n\n\nINLINE\nLOCAL(void)\nh2v2_merged_upsample_565D_internal(j_decompress_ptr cinfo,\n                                   _JSAMPIMAGE input_buf,\n                                   JDIMENSION in_row_group_ctr,\n                                   _JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register _JSAMPROW outptr0, outptr1;\n  _JSAMPROW inptr00, inptr01, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];\n  JLONG d1 = dither_matrix[(cinfo->output_scanline + 1) & DITHER_MASK];\n  unsigned int r, g, b;\n  JLONG rgb;\n  SHIFT_TEMPS\n\n  inptr00 = input_buf[0][in_row_group_ctr * 2];\n  inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr0 = output_buf[0];\n  outptr1 = output_buf[1];\n\n  /* Loop for each group of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = *inptr1++;\n    cr = *inptr2++;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    /* Fetch 4 Y values and emit 4 pixels */\n    y  = *inptr00++;\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    d0 = DITHER_ROTATE(d0);\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = *inptr00++;\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    d0 = DITHER_ROTATE(d0);\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr0, rgb);\n    outptr0 += 4;\n\n    y  = *inptr01++;\n    r = range_limit[DITHER_565_R(y + cred, d1)];\n    g = range_limit[DITHER_565_G(y + cgreen, d1)];\n    b = range_limit[DITHER_565_B(y + cblue, d1)];\n    d1 = DITHER_ROTATE(d1);\n    rgb = PACK_SHORT_565(r, g, b);\n\n    y  = *inptr01++;\n    r = range_limit[DITHER_565_R(y + cred, d1)];\n    g = range_limit[DITHER_565_G(y + cgreen, d1)];\n    b = range_limit[DITHER_565_B(y + cblue, d1)];\n    d1 = DITHER_ROTATE(d1);\n    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));\n\n    WRITE_TWO_PIXELS(outptr1, rgb);\n    outptr1 += 4;\n  }\n\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = *inptr1;\n    cr = *inptr2;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n\n    y  = *inptr00;\n    r = range_limit[DITHER_565_R(y + cred, d0)];\n    g = range_limit[DITHER_565_G(y + cgreen, d0)];\n    b = range_limit[DITHER_565_B(y + cblue, d0)];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr0 = (INT16)rgb;\n\n    y  = *inptr01;\n    r = range_limit[DITHER_565_R(y + cred, d1)];\n    g = range_limit[DITHER_565_G(y + cgreen, d1)];\n    b = range_limit[DITHER_565_B(y + cblue, d1)];\n    rgb = PACK_SHORT_565(r, g, b);\n    *(INT16 *)outptr1 = (INT16)rgb;\n  }\n}\n"
        },
        {
          "name": "jdmrgext.c",
          "type": "blob",
          "size": 5.7568359375,
          "content": "/*\n * jdmrgext.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2011, 2015, 2020, 2022-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains code for merged upsampling/color conversion.\n */\n\n\n/* This file is included by jdmerge.c */\n\n\n/*\n * Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.\n */\n\nINLINE\nLOCAL(void)\nh2v1_merged_upsample_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                              JDIMENSION in_row_group_ctr,\n                              _JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register _JSAMPROW outptr;\n  _JSAMPROW inptr0, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  SHIFT_TEMPS\n\n  inptr0 = input_buf[0][in_row_group_ctr];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr = output_buf[0];\n  /* Loop for each pair of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = *inptr1++;\n    cr = *inptr2++;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    /* Fetch 2 Y values and emit 2 pixels */\n    y  = *inptr0++;\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n    outptr += RGB_PIXELSIZE;\n    y  = *inptr0++;\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n    outptr += RGB_PIXELSIZE;\n  }\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = *inptr1;\n    cr = *inptr2;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = *inptr0;\n    outptr[RGB_RED] =   range_limit[y + cred];\n    outptr[RGB_GREEN] = range_limit[y + cgreen];\n    outptr[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n  }\n}\n\n\n/*\n * Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.\n */\n\nINLINE\nLOCAL(void)\nh2v2_merged_upsample_internal(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                              JDIMENSION in_row_group_ctr,\n                              _JSAMPARRAY output_buf)\n{\n  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n  register int y, cred, cgreen, cblue;\n  int cb, cr;\n  register _JSAMPROW outptr0, outptr1;\n  _JSAMPROW inptr00, inptr01, inptr1, inptr2;\n  JDIMENSION col;\n  /* copy these pointers into registers if possible */\n  register _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  int *Crrtab = upsample->Cr_r_tab;\n  int *Cbbtab = upsample->Cb_b_tab;\n  JLONG *Crgtab = upsample->Cr_g_tab;\n  JLONG *Cbgtab = upsample->Cb_g_tab;\n  SHIFT_TEMPS\n\n  inptr00 = input_buf[0][in_row_group_ctr * 2];\n  inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];\n  inptr1 = input_buf[1][in_row_group_ctr];\n  inptr2 = input_buf[2][in_row_group_ctr];\n  outptr0 = output_buf[0];\n  outptr1 = output_buf[1];\n  /* Loop for each group of output pixels */\n  for (col = cinfo->output_width >> 1; col > 0; col--) {\n    /* Do the chroma part of the calculation */\n    cb = *inptr1++;\n    cr = *inptr2++;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    /* Fetch 4 Y values and emit 4 pixels */\n    y  = *inptr00++;\n    outptr0[RGB_RED] =   range_limit[y + cred];\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr0[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n    outptr0 += RGB_PIXELSIZE;\n    y  = *inptr00++;\n    outptr0[RGB_RED] =   range_limit[y + cred];\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr0[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n    outptr0 += RGB_PIXELSIZE;\n    y  = *inptr01++;\n    outptr1[RGB_RED] =   range_limit[y + cred];\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr1[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n    outptr1 += RGB_PIXELSIZE;\n    y  = *inptr01++;\n    outptr1[RGB_RED] =   range_limit[y + cred];\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr1[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n    outptr1 += RGB_PIXELSIZE;\n  }\n  /* If image width is odd, do the last output column separately */\n  if (cinfo->output_width & 1) {\n    cb = *inptr1;\n    cr = *inptr2;\n    cred = Crrtab[cr];\n    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n    cblue = Cbbtab[cb];\n    y  = *inptr00;\n    outptr0[RGB_RED] =   range_limit[y + cred];\n    outptr0[RGB_GREEN] = range_limit[y + cgreen];\n    outptr0[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr0[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n    y  = *inptr01;\n    outptr1[RGB_RED] =   range_limit[y + cred];\n    outptr1[RGB_GREEN] = range_limit[y + cgreen];\n    outptr1[RGB_BLUE] =  range_limit[y + cblue];\n#ifdef RGB_ALPHA\n    outptr1[RGB_ALPHA] = _MAXJSAMPLE;\n#endif\n  }\n}\n"
        },
        {
          "name": "jdphuff.c",
          "type": "blob",
          "size": 21.72265625,
          "content": "/*\n * jdphuff.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1995-1997, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015-2016, 2018-2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains Huffman entropy decoding routines for progressive JPEG.\n *\n * Much of the complexity here has to do with supporting input suspension.\n * If the data source module demands suspension, we want to be able to back\n * up to the start of the current MCU.  To do this, we copy state variables\n * into local working storage, and update them back to the permanent\n * storage only upon successful completion of an MCU.\n *\n * NOTE: All referenced figures are from\n * Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdhuff.h\"             /* Declarations shared with jd*huff.c */\n#include <limits.h>\n\n\n#ifdef D_PROGRESSIVE_SUPPORTED\n\n/*\n * Expanded entropy decoder object for progressive Huffman decoding.\n *\n * The savable_state subrecord contains fields that change within an MCU,\n * but must not be updated permanently until we complete the MCU.\n */\n\ntypedef struct {\n  unsigned int EOBRUN;                  /* remaining EOBs in EOBRUN */\n  int last_dc_val[MAX_COMPS_IN_SCAN];   /* last DC coef for each component */\n} savable_state;\n\ntypedef struct {\n  struct jpeg_entropy_decoder pub; /* public fields */\n\n  /* These fields are loaded into local variables at start of each MCU.\n   * In case of suspension, we exit WITHOUT updating them.\n   */\n  bitread_perm_state bitstate;  /* Bit buffer at start of MCU */\n  savable_state saved;          /* Other state at start of MCU */\n\n  /* These fields are NOT loaded into local working state. */\n  unsigned int restarts_to_go;  /* MCUs left in this restart interval */\n\n  /* Pointers to derived tables (these workspaces have image lifespan) */\n  d_derived_tbl *derived_tbls[NUM_HUFF_TBLS];\n\n  d_derived_tbl *ac_derived_tbl; /* active table during an AC scan */\n} phuff_entropy_decoder;\n\ntypedef phuff_entropy_decoder *phuff_entropy_ptr;\n\n/* Forward declarations */\nMETHODDEF(boolean) decode_mcu_DC_first(j_decompress_ptr cinfo,\n                                       JBLOCKROW *MCU_data);\nMETHODDEF(boolean) decode_mcu_AC_first(j_decompress_ptr cinfo,\n                                       JBLOCKROW *MCU_data);\nMETHODDEF(boolean) decode_mcu_DC_refine(j_decompress_ptr cinfo,\n                                        JBLOCKROW *MCU_data);\nMETHODDEF(boolean) decode_mcu_AC_refine(j_decompress_ptr cinfo,\n                                        JBLOCKROW *MCU_data);\n\n\n/*\n * Initialize for a Huffman-compressed scan.\n */\n\nMETHODDEF(void)\nstart_pass_phuff_decoder(j_decompress_ptr cinfo)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  boolean is_DC_band, bad;\n  int ci, coefi, tbl;\n  d_derived_tbl **pdtbl;\n  int *coef_bit_ptr, *prev_coef_bit_ptr;\n  jpeg_component_info *compptr;\n\n  is_DC_band = (cinfo->Ss == 0);\n\n  /* Validate scan parameters */\n  bad = FALSE;\n  if (is_DC_band) {\n    if (cinfo->Se != 0)\n      bad = TRUE;\n  } else {\n    /* need not check Ss/Se < 0 since they came from unsigned bytes */\n    if (cinfo->Ss > cinfo->Se || cinfo->Se >= DCTSIZE2)\n      bad = TRUE;\n    /* AC scans may have only one component */\n    if (cinfo->comps_in_scan != 1)\n      bad = TRUE;\n  }\n  if (cinfo->Ah != 0) {\n    /* Successive approximation refinement scan: must have Al = Ah-1. */\n    if (cinfo->Al != cinfo->Ah - 1)\n      bad = TRUE;\n  }\n  if (cinfo->Al > 13)           /* need not check for < 0 */\n    bad = TRUE;\n  /* Arguably the maximum Al value should be less than 13 for 8-bit precision,\n   * but the spec doesn't say so, and we try to be liberal about what we\n   * accept.  Note: large Al values could result in out-of-range DC\n   * coefficients during early scans, leading to bizarre displays due to\n   * overflows in the IDCT math.  But we won't crash.\n   */\n  if (bad)\n    ERREXIT4(cinfo, JERR_BAD_PROGRESSION,\n             cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);\n  /* Update progression status, and verify that scan order is legal.\n   * Note that inter-scan inconsistencies are treated as warnings\n   * not fatal errors ... not clear if this is right way to behave.\n   */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    int cindex = cinfo->cur_comp_info[ci]->component_index;\n    coef_bit_ptr = &cinfo->coef_bits[cindex][0];\n    prev_coef_bit_ptr = &cinfo->coef_bits[cindex + cinfo->num_components][0];\n    if (!is_DC_band && coef_bit_ptr[0] < 0) /* AC without prior DC scan */\n      WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);\n    for (coefi = MIN(cinfo->Ss, 1); coefi <= MAX(cinfo->Se, 9); coefi++) {\n      if (cinfo->input_scan_number > 1)\n        prev_coef_bit_ptr[coefi] = coef_bit_ptr[coefi];\n      else\n        prev_coef_bit_ptr[coefi] = 0;\n    }\n    for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {\n      int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];\n      if (cinfo->Ah != expected)\n        WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);\n      coef_bit_ptr[coefi] = cinfo->Al;\n    }\n  }\n\n  /* Select MCU decoding routine */\n  if (cinfo->Ah == 0) {\n    if (is_DC_band)\n      entropy->pub.decode_mcu = decode_mcu_DC_first;\n    else\n      entropy->pub.decode_mcu = decode_mcu_AC_first;\n  } else {\n    if (is_DC_band)\n      entropy->pub.decode_mcu = decode_mcu_DC_refine;\n    else\n      entropy->pub.decode_mcu = decode_mcu_AC_refine;\n  }\n\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {\n    compptr = cinfo->cur_comp_info[ci];\n    /* Make sure requested tables are present, and compute derived tables.\n     * We may build same derived table more than once, but it's not expensive.\n     */\n    if (is_DC_band) {\n      if (cinfo->Ah == 0) {     /* DC refinement needs no table */\n        tbl = compptr->dc_tbl_no;\n        pdtbl = (d_derived_tbl **)(entropy->derived_tbls) + tbl;\n        jpeg_make_d_derived_tbl(cinfo, TRUE, tbl, pdtbl);\n      }\n    } else {\n      tbl = compptr->ac_tbl_no;\n      pdtbl = (d_derived_tbl **)(entropy->derived_tbls) + tbl;\n      jpeg_make_d_derived_tbl(cinfo, FALSE, tbl, pdtbl);\n      /* remember the single active table */\n      entropy->ac_derived_tbl = entropy->derived_tbls[tbl];\n    }\n    /* Initialize DC predictions to 0 */\n    entropy->saved.last_dc_val[ci] = 0;\n  }\n\n  /* Initialize bitread state variables */\n  entropy->bitstate.bits_left = 0;\n  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */\n  entropy->pub.insufficient_data = FALSE;\n\n  /* Initialize private state variables */\n  entropy->saved.EOBRUN = 0;\n\n  /* Initialize restart counter */\n  entropy->restarts_to_go = cinfo->restart_interval;\n}\n\n\n/*\n * Figure F.12: extend sign bit.\n * On some machines, a shift and add will be faster than a table lookup.\n */\n\n#define AVOID_TABLES\n#ifdef AVOID_TABLES\n\n#define NEG_1  ((unsigned)-1)\n#define HUFF_EXTEND(x, s) \\\n  ((x) < (1 << ((s) - 1)) ? (x) + (((NEG_1) << (s)) + 1) : (x))\n\n#else\n\n#define HUFF_EXTEND(x, s) \\\n  ((x) < extend_test[s] ? (x) + extend_offset[s] : (x))\n\nstatic const int extend_test[16] = {   /* entry n is 2**(n-1) */\n  0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,\n  0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000\n};\n\nstatic const int extend_offset[16] = { /* entry n is (-1 << n) + 1 */\n  0, ((-1) << 1) + 1, ((-1) << 2) + 1, ((-1) << 3) + 1, ((-1) << 4) + 1,\n  ((-1) << 5) + 1, ((-1) << 6) + 1, ((-1) << 7) + 1, ((-1) << 8) + 1,\n  ((-1) << 9) + 1, ((-1) << 10) + 1, ((-1) << 11) + 1, ((-1) << 12) + 1,\n  ((-1) << 13) + 1, ((-1) << 14) + 1, ((-1) << 15) + 1\n};\n\n#endif /* AVOID_TABLES */\n\n\n/*\n * Check for a restart marker & resynchronize decoder.\n * Returns FALSE if must suspend.\n */\n\nLOCAL(boolean)\nprocess_restart(j_decompress_ptr cinfo)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  int ci;\n\n  /* Throw away any unused bits remaining in bit buffer; */\n  /* include any full bytes in next_marker's count of discarded bytes */\n  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;\n  entropy->bitstate.bits_left = 0;\n\n  /* Advance past the RSTn marker */\n  if (!(*cinfo->marker->read_restart_marker) (cinfo))\n    return FALSE;\n\n  /* Re-initialize DC predictions to 0 */\n  for (ci = 0; ci < cinfo->comps_in_scan; ci++)\n    entropy->saved.last_dc_val[ci] = 0;\n  /* Re-init EOB run count, too */\n  entropy->saved.EOBRUN = 0;\n\n  /* Reset restart counter */\n  entropy->restarts_to_go = cinfo->restart_interval;\n\n  /* Reset out-of-data flag, unless read_restart_marker left us smack up\n   * against a marker.  In that case we will end up treating the next data\n   * segment as empty, and we can avoid producing bogus output pixels by\n   * leaving the flag set.\n   */\n  if (cinfo->unread_marker == 0)\n    entropy->pub.insufficient_data = FALSE;\n\n  return TRUE;\n}\n\n\n/*\n * Huffman MCU decoding.\n * Each of these routines decodes and returns one MCU's worth of\n * Huffman-compressed coefficients.\n * The coefficients are reordered from zigzag order into natural array order,\n * but are not dequantized.\n *\n * The i'th block of the MCU is stored into the block pointed to by\n * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.\n *\n * We return FALSE if data source requested suspension.  In that case no\n * changes have been made to permanent state.  (Exception: some output\n * coefficients may already have been assigned.  This is harmless for\n * spectral selection, since we'll just re-assign them on the next call.\n * Successive approximation AC refinement has to be more careful, however.)\n */\n\n/*\n * MCU decoding for DC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n\nMETHODDEF(boolean)\ndecode_mcu_DC_first(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  int Al = cinfo->Al;\n  register int s, r;\n  int blkn, ci;\n  JBLOCKROW block;\n  BITREAD_STATE_VARS;\n  savable_state state;\n  d_derived_tbl *tbl;\n  jpeg_component_info *compptr;\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (!process_restart(cinfo))\n        return FALSE;\n  }\n\n  /* If we've run out of data, just leave the MCU set to zeroes.\n   * This way, we return uniform gray for the remainder of the segment.\n   */\n  if (!entropy->pub.insufficient_data) {\n\n    /* Load up working state */\n    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);\n    state = entropy->saved;\n\n    /* Outer loop handles each block in the MCU */\n\n    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n      block = MCU_data[blkn];\n      ci = cinfo->MCU_membership[blkn];\n      compptr = cinfo->cur_comp_info[ci];\n      tbl = entropy->derived_tbls[compptr->dc_tbl_no];\n\n      /* Decode a single block's worth of coefficients */\n\n      /* Section F.2.2.1: decode the DC coefficient difference */\n      HUFF_DECODE(s, br_state, tbl, return FALSE, label1);\n      if (s) {\n        CHECK_BIT_BUFFER(br_state, s, return FALSE);\n        r = GET_BITS(s);\n        s = HUFF_EXTEND(r, s);\n      }\n\n      /* Convert DC difference to actual value, update last_dc_val */\n      if ((state.last_dc_val[ci] >= 0 &&\n           s > INT_MAX - state.last_dc_val[ci]) ||\n          (state.last_dc_val[ci] < 0 && s < INT_MIN - state.last_dc_val[ci]))\n        ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n      s += state.last_dc_val[ci];\n      state.last_dc_val[ci] = s;\n      /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */\n      (*block)[0] = (JCOEF)LEFT_SHIFT(s, Al);\n    }\n\n    /* Completed MCU, so update state */\n    BITREAD_SAVE_STATE(cinfo, entropy->bitstate);\n    entropy->saved = state;\n  }\n\n  /* Account for restart interval (no-op if not using restarts) */\n  if (cinfo->restart_interval)\n    entropy->restarts_to_go--;\n\n  return TRUE;\n}\n\n\n/*\n * MCU decoding for AC initial scan (either spectral selection,\n * or first pass of successive approximation).\n */\n\nMETHODDEF(boolean)\ndecode_mcu_AC_first(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  int Se = cinfo->Se;\n  int Al = cinfo->Al;\n  register int s, k, r;\n  unsigned int EOBRUN;\n  JBLOCKROW block;\n  BITREAD_STATE_VARS;\n  d_derived_tbl *tbl;\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (!process_restart(cinfo))\n        return FALSE;\n  }\n\n  /* If we've run out of data, just leave the MCU set to zeroes.\n   * This way, we return uniform gray for the remainder of the segment.\n   */\n  if (!entropy->pub.insufficient_data) {\n\n    /* Load up working state.\n     * We can avoid loading/saving bitread state if in an EOB run.\n     */\n    EOBRUN = entropy->saved.EOBRUN;     /* only part of saved state we need */\n\n    /* There is always only one block per MCU */\n\n    if (EOBRUN > 0)             /* if it's a band of zeroes... */\n      EOBRUN--;                 /* ...process it now (we do nothing) */\n    else {\n      BITREAD_LOAD_STATE(cinfo, entropy->bitstate);\n      block = MCU_data[0];\n      tbl = entropy->ac_derived_tbl;\n\n      for (k = cinfo->Ss; k <= Se; k++) {\n        HUFF_DECODE(s, br_state, tbl, return FALSE, label2);\n        r = s >> 4;\n        s &= 15;\n        if (s) {\n          k += r;\n          CHECK_BIT_BUFFER(br_state, s, return FALSE);\n          r = GET_BITS(s);\n          s = HUFF_EXTEND(r, s);\n          /* Scale and output coefficient in natural (dezigzagged) order */\n          (*block)[jpeg_natural_order[k]] = (JCOEF)LEFT_SHIFT(s, Al);\n        } else {\n          if (r == 15) {        /* ZRL */\n            k += 15;            /* skip 15 zeroes in band */\n          } else {              /* EOBr, run length is 2^r + appended bits */\n            EOBRUN = 1 << r;\n            if (r) {            /* EOBr, r > 0 */\n              CHECK_BIT_BUFFER(br_state, r, return FALSE);\n              r = GET_BITS(r);\n              EOBRUN += r;\n            }\n            EOBRUN--;           /* this band is processed at this moment */\n            break;              /* force end-of-band */\n          }\n        }\n      }\n\n      BITREAD_SAVE_STATE(cinfo, entropy->bitstate);\n    }\n\n    /* Completed MCU, so update state */\n    entropy->saved.EOBRUN = EOBRUN;     /* only part of saved state we need */\n  }\n\n  /* Account for restart interval (no-op if not using restarts) */\n  if (cinfo->restart_interval)\n    entropy->restarts_to_go--;\n\n  return TRUE;\n}\n\n\n/*\n * MCU decoding for DC successive approximation refinement scan.\n * Note: we assume such scans can be multi-component, although the spec\n * is not very clear on the point.\n */\n\nMETHODDEF(boolean)\ndecode_mcu_DC_refine(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  int p1 = 1 << cinfo->Al;      /* 1 in the bit position being coded */\n  int blkn;\n  JBLOCKROW block;\n  BITREAD_STATE_VARS;\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (!process_restart(cinfo))\n        return FALSE;\n  }\n\n  /* Not worth the cycles to check insufficient_data here,\n   * since we will not change the data anyway if we read zeroes.\n   */\n\n  /* Load up working state */\n  BITREAD_LOAD_STATE(cinfo, entropy->bitstate);\n\n  /* Outer loop handles each block in the MCU */\n\n  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {\n    block = MCU_data[blkn];\n\n    /* Encoded data is simply the next bit of the two's-complement DC value */\n    CHECK_BIT_BUFFER(br_state, 1, return FALSE);\n    if (GET_BITS(1))\n      (*block)[0] |= p1;\n    /* Note: since we use |=, repeating the assignment later is safe */\n  }\n\n  /* Completed MCU, so update state */\n  BITREAD_SAVE_STATE(cinfo, entropy->bitstate);\n\n  /* Account for restart interval (no-op if not using restarts) */\n  if (cinfo->restart_interval)\n    entropy->restarts_to_go--;\n\n  return TRUE;\n}\n\n\n/*\n * MCU decoding for AC successive approximation refinement scan.\n */\n\nMETHODDEF(boolean)\ndecode_mcu_AC_refine(j_decompress_ptr cinfo, JBLOCKROW *MCU_data)\n{\n  phuff_entropy_ptr entropy = (phuff_entropy_ptr)cinfo->entropy;\n  int Se = cinfo->Se;\n  int p1 = 1 << cinfo->Al;        /* 1 in the bit position being coded */\n  int m1 = (NEG_1) << cinfo->Al;  /* -1 in the bit position being coded */\n  register int s, k, r;\n  unsigned int EOBRUN;\n  JBLOCKROW block;\n  JCOEFPTR thiscoef;\n  BITREAD_STATE_VARS;\n  d_derived_tbl *tbl;\n  int num_newnz;\n  int newnz_pos[DCTSIZE2];\n\n  /* Process restart marker if needed; may have to suspend */\n  if (cinfo->restart_interval) {\n    if (entropy->restarts_to_go == 0)\n      if (!process_restart(cinfo))\n        return FALSE;\n  }\n\n  /* If we've run out of data, don't modify the MCU.\n   */\n  if (!entropy->pub.insufficient_data) {\n\n    /* Load up working state */\n    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);\n    EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */\n\n    /* There is always only one block per MCU */\n    block = MCU_data[0];\n    tbl = entropy->ac_derived_tbl;\n\n    /* If we are forced to suspend, we must undo the assignments to any newly\n     * nonzero coefficients in the block, because otherwise we'd get confused\n     * next time about which coefficients were already nonzero.\n     * But we need not undo addition of bits to already-nonzero coefficients;\n     * instead, we can test the current bit to see if we already did it.\n     */\n    num_newnz = 0;\n\n    /* initialize coefficient loop counter to start of band */\n    k = cinfo->Ss;\n\n    if (EOBRUN == 0) {\n      for (; k <= Se; k++) {\n        HUFF_DECODE(s, br_state, tbl, goto undoit, label3);\n        r = s >> 4;\n        s &= 15;\n        if (s) {\n          if (s != 1)           /* size of new coef should always be 1 */\n            WARNMS(cinfo, JWRN_HUFF_BAD_CODE);\n          CHECK_BIT_BUFFER(br_state, 1, goto undoit);\n          if (GET_BITS(1))\n            s = p1;             /* newly nonzero coef is positive */\n          else\n            s = m1;             /* newly nonzero coef is negative */\n        } else {\n          if (r != 15) {\n            EOBRUN = 1 << r;    /* EOBr, run length is 2^r + appended bits */\n            if (r) {\n              CHECK_BIT_BUFFER(br_state, r, goto undoit);\n              r = GET_BITS(r);\n              EOBRUN += r;\n            }\n            break;              /* rest of block is handled by EOB logic */\n          }\n          /* note s = 0 for processing ZRL */\n        }\n        /* Advance over already-nonzero coefs and r still-zero coefs,\n         * appending correction bits to the nonzeroes.  A correction bit is 1\n         * if the absolute value of the coefficient must be increased.\n         */\n        do {\n          thiscoef = *block + jpeg_natural_order[k];\n          if (*thiscoef != 0) {\n            CHECK_BIT_BUFFER(br_state, 1, goto undoit);\n            if (GET_BITS(1)) {\n              if ((*thiscoef & p1) == 0) { /* do nothing if already set it */\n                if (*thiscoef >= 0)\n                  *thiscoef += (JCOEF)p1;\n                else\n                  *thiscoef += (JCOEF)m1;\n              }\n            }\n          } else {\n            if (--r < 0)\n              break;            /* reached target zero coefficient */\n          }\n          k++;\n        } while (k <= Se);\n        if (s) {\n          int pos = jpeg_natural_order[k];\n          /* Output newly nonzero coefficient */\n          (*block)[pos] = (JCOEF)s;\n          /* Remember its position in case we have to suspend */\n          newnz_pos[num_newnz++] = pos;\n        }\n      }\n    }\n\n    if (EOBRUN > 0) {\n      /* Scan any remaining coefficient positions after the end-of-band\n       * (the last newly nonzero coefficient, if any).  Append a correction\n       * bit to each already-nonzero coefficient.  A correction bit is 1\n       * if the absolute value of the coefficient must be increased.\n       */\n      for (; k <= Se; k++) {\n        thiscoef = *block + jpeg_natural_order[k];\n        if (*thiscoef != 0) {\n          CHECK_BIT_BUFFER(br_state, 1, goto undoit);\n          if (GET_BITS(1)) {\n            if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */\n              if (*thiscoef >= 0)\n                *thiscoef += (JCOEF)p1;\n              else\n                *thiscoef += (JCOEF)m1;\n            }\n          }\n        }\n      }\n      /* Count one block completed in EOB run */\n      EOBRUN--;\n    }\n\n    /* Completed MCU, so update state */\n    BITREAD_SAVE_STATE(cinfo, entropy->bitstate);\n    entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */\n  }\n\n  /* Account for restart interval (no-op if not using restarts) */\n  if (cinfo->restart_interval)\n    entropy->restarts_to_go--;\n\n  return TRUE;\n\nundoit:\n  /* Re-zero any output coefficients that we made newly nonzero */\n  while (num_newnz > 0)\n    (*block)[newnz_pos[--num_newnz]] = 0;\n\n  return FALSE;\n}\n\n\n/*\n * Module initialization routine for progressive Huffman entropy decoding.\n */\n\nGLOBAL(void)\njinit_phuff_decoder(j_decompress_ptr cinfo)\n{\n  phuff_entropy_ptr entropy;\n  int *coef_bit_ptr;\n  int ci, i;\n\n  entropy = (phuff_entropy_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(phuff_entropy_decoder));\n  cinfo->entropy = (struct jpeg_entropy_decoder *)entropy;\n  entropy->pub.start_pass = start_pass_phuff_decoder;\n\n  /* Mark derived tables unallocated */\n  for (i = 0; i < NUM_HUFF_TBLS; i++) {\n    entropy->derived_tbls[i] = NULL;\n  }\n\n  /* Create progression status table */\n  cinfo->coef_bits = (int (*)[DCTSIZE2])\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                cinfo->num_components * 2 * DCTSIZE2 *\n                                sizeof(int));\n  coef_bit_ptr = &cinfo->coef_bits[0][0];\n  for (ci = 0; ci < cinfo->num_components; ci++)\n    for (i = 0; i < DCTSIZE2; i++)\n      *coef_bit_ptr++ = -1;\n}\n\n#endif /* D_PROGRESSIVE_SUPPORTED */\n"
        },
        {
          "name": "jdpostct.c",
          "type": "blob",
          "size": 11.3447265625,
          "content": "/*\n * jdpostct.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the decompression postprocessing controller.\n * This controller manages the upsampling, color conversion, and color\n * quantization/reduction steps; specifically, it controls the buffering\n * between upsample/color conversion and color quantization/reduction.\n *\n * If no color quantization/reduction is required, then this module has no\n * work to do, and it just hands off to the upsample/color conversion code.\n * An integrated upsample/convert/quantize process would replace this module\n * entirely.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n\n\n#if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)\n\n/* Private buffer controller object */\n\ntypedef struct {\n  struct jpeg_d_post_controller pub; /* public fields */\n\n  /* Color quantization source buffer: this holds output data from\n   * the upsample/color conversion step to be passed to the quantizer.\n   * For two-pass color quantization, we need a full-image buffer;\n   * for one-pass operation, a strip buffer is sufficient.\n   */\n  jvirt_sarray_ptr whole_image; /* virtual array, or NULL if one-pass */\n  _JSAMPARRAY buffer;           /* strip buffer, or current strip of virtual */\n  JDIMENSION strip_height;      /* buffer size in rows */\n  /* for two-pass mode only: */\n  JDIMENSION starting_row;      /* row # of first row in current strip */\n  JDIMENSION next_row;          /* index of next row to fill/empty in strip */\n} my_post_controller;\n\ntypedef my_post_controller *my_post_ptr;\n\n\n/* Forward declarations */\n#if BITS_IN_JSAMPLE != 16\nMETHODDEF(void) post_process_1pass(j_decompress_ptr cinfo,\n                                   _JSAMPIMAGE input_buf,\n                                   JDIMENSION *in_row_group_ctr,\n                                   JDIMENSION in_row_groups_avail,\n                                   _JSAMPARRAY output_buf,\n                                   JDIMENSION *out_row_ctr,\n                                   JDIMENSION out_rows_avail);\n#endif\n#if defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16\nMETHODDEF(void) post_process_prepass(j_decompress_ptr cinfo,\n                                     _JSAMPIMAGE input_buf,\n                                     JDIMENSION *in_row_group_ctr,\n                                     JDIMENSION in_row_groups_avail,\n                                     _JSAMPARRAY output_buf,\n                                     JDIMENSION *out_row_ctr,\n                                     JDIMENSION out_rows_avail);\nMETHODDEF(void) post_process_2pass(j_decompress_ptr cinfo,\n                                   _JSAMPIMAGE input_buf,\n                                   JDIMENSION *in_row_group_ctr,\n                                   JDIMENSION in_row_groups_avail,\n                                   _JSAMPARRAY output_buf,\n                                   JDIMENSION *out_row_ctr,\n                                   JDIMENSION out_rows_avail);\n#endif\n\n\n/*\n * Initialize for a processing pass.\n */\n\nMETHODDEF(void)\nstart_pass_dpost(j_decompress_ptr cinfo, J_BUF_MODE pass_mode)\n{\n  my_post_ptr post = (my_post_ptr)cinfo->post;\n\n  switch (pass_mode) {\n  case JBUF_PASS_THRU:\n#if BITS_IN_JSAMPLE != 16\n    if (cinfo->quantize_colors) {\n      /* Single-pass processing with color quantization. */\n      post->pub._post_process_data = post_process_1pass;\n      /* We could be doing buffered-image output before starting a 2-pass\n       * color quantization; in that case, jinit_d_post_controller did not\n       * allocate a strip buffer.  Use the virtual-array buffer as workspace.\n       */\n      if (post->buffer == NULL) {\n        post->buffer = (_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)\n          ((j_common_ptr)cinfo, post->whole_image,\n           (JDIMENSION)0, post->strip_height, TRUE);\n      }\n    } else\n#endif\n    {\n      /* For single-pass processing without color quantization,\n       * I have no work to do; just call the upsampler directly.\n       */\n      post->pub._post_process_data = cinfo->upsample->_upsample;\n    }\n    break;\n#if defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16\n  case JBUF_SAVE_AND_PASS:\n    /* First pass of 2-pass quantization */\n    if (post->whole_image == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    post->pub._post_process_data = post_process_prepass;\n    break;\n  case JBUF_CRANK_DEST:\n    /* Second pass of 2-pass quantization */\n    if (post->whole_image == NULL)\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    post->pub._post_process_data = post_process_2pass;\n    break;\n#endif /* defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16 */\n  default:\n    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n    break;\n  }\n  post->starting_row = post->next_row = 0;\n}\n\n\n/*\n * Process some data in the one-pass (strip buffer) case.\n * This is used for color precision reduction as well as one-pass quantization.\n */\n\n#if BITS_IN_JSAMPLE != 16\n\nMETHODDEF(void)\npost_process_1pass(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, _JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_post_ptr post = (my_post_ptr)cinfo->post;\n  JDIMENSION num_rows, max_rows;\n\n  /* Fill the buffer, but not more than what we can dump out in one go. */\n  /* Note we rely on the upsampler to detect bottom of image. */\n  max_rows = out_rows_avail - *out_row_ctr;\n  if (max_rows > post->strip_height)\n    max_rows = post->strip_height;\n  num_rows = 0;\n  (*cinfo->upsample->_upsample) (cinfo, input_buf, in_row_group_ctr,\n                                 in_row_groups_avail, post->buffer, &num_rows,\n                                 max_rows);\n  /* Quantize and emit data. */\n  (*cinfo->cquantize->_color_quantize) (cinfo, post->buffer,\n                                        output_buf + *out_row_ctr,\n                                        (int)num_rows);\n  *out_row_ctr += num_rows;\n}\n\n#endif\n\n\n#if defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16\n\n/*\n * Process some data in the first pass of 2-pass quantization.\n */\n\nMETHODDEF(void)\npost_process_prepass(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                     JDIMENSION *in_row_group_ctr,\n                     JDIMENSION in_row_groups_avail, _JSAMPARRAY output_buf,\n                     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_post_ptr post = (my_post_ptr)cinfo->post;\n  JDIMENSION old_next_row, num_rows;\n\n  /* Reposition virtual buffer if at start of strip. */\n  if (post->next_row == 0) {\n    post->buffer = (_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)\n        ((j_common_ptr)cinfo, post->whole_image,\n         post->starting_row, post->strip_height, TRUE);\n  }\n\n  /* Upsample some data (up to a strip height's worth). */\n  old_next_row = post->next_row;\n  (*cinfo->upsample->_upsample) (cinfo, input_buf, in_row_group_ctr,\n                                 in_row_groups_avail, post->buffer,\n                                 &post->next_row, post->strip_height);\n\n  /* Allow quantizer to scan new data.  No data is emitted, */\n  /* but we advance out_row_ctr so outer loop can tell when we're done. */\n  if (post->next_row > old_next_row) {\n    num_rows = post->next_row - old_next_row;\n    (*cinfo->cquantize->_color_quantize) (cinfo, post->buffer + old_next_row,\n                                          (_JSAMPARRAY)NULL, (int)num_rows);\n    *out_row_ctr += num_rows;\n  }\n\n  /* Advance if we filled the strip. */\n  if (post->next_row >= post->strip_height) {\n    post->starting_row += post->strip_height;\n    post->next_row = 0;\n  }\n}\n\n\n/*\n * Process some data in the second pass of 2-pass quantization.\n */\n\nMETHODDEF(void)\npost_process_2pass(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, _JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_post_ptr post = (my_post_ptr)cinfo->post;\n  JDIMENSION num_rows, max_rows;\n\n  /* Reposition virtual buffer if at start of strip. */\n  if (post->next_row == 0) {\n    post->buffer = (_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)\n        ((j_common_ptr)cinfo, post->whole_image,\n         post->starting_row, post->strip_height, FALSE);\n  }\n\n  /* Determine number of rows to emit. */\n  num_rows = post->strip_height - post->next_row; /* available in strip */\n  max_rows = out_rows_avail - *out_row_ctr; /* available in output area */\n  if (num_rows > max_rows)\n    num_rows = max_rows;\n  /* We have to check bottom of image here, can't depend on upsampler. */\n  max_rows = cinfo->output_height - post->starting_row;\n  if (num_rows > max_rows)\n    num_rows = max_rows;\n\n  /* Quantize and emit data. */\n  (*cinfo->cquantize->_color_quantize) (cinfo, post->buffer + post->next_row,\n                                        output_buf + *out_row_ctr,\n                                        (int)num_rows);\n  *out_row_ctr += num_rows;\n\n  /* Advance if we filled the strip. */\n  post->next_row += num_rows;\n  if (post->next_row >= post->strip_height) {\n    post->starting_row += post->strip_height;\n    post->next_row = 0;\n  }\n}\n\n#endif /* defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16 */\n\n\n/*\n * Initialize postprocessing controller.\n */\n\nGLOBAL(void)\n_jinit_d_post_controller(j_decompress_ptr cinfo, boolean need_full_buffer)\n{\n  my_post_ptr post;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  post = (my_post_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_post_controller));\n  cinfo->post = (struct jpeg_d_post_controller *)post;\n  post->pub.start_pass = start_pass_dpost;\n  post->whole_image = NULL;     /* flag for no virtual arrays */\n  post->buffer = NULL;          /* flag for no strip buffer */\n\n  /* Create the quantization buffer, if needed */\n  if (cinfo->quantize_colors) {\n#if BITS_IN_JSAMPLE != 16\n    /* The buffer strip height is max_v_samp_factor, which is typically\n     * an efficient number of rows for upsampling to return.\n     * (In the presence of output rescaling, we might want to be smarter?)\n     */\n    post->strip_height = (JDIMENSION)cinfo->max_v_samp_factor;\n    if (need_full_buffer) {\n      /* Two-pass color quantization: need full-image storage. */\n      /* We round up the number of rows to a multiple of the strip height. */\n#ifdef QUANT_2PASS_SUPPORTED\n      post->whole_image = (*cinfo->mem->request_virt_sarray)\n        ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n         cinfo->output_width * cinfo->out_color_components,\n         (JDIMENSION)jround_up((long)cinfo->output_height,\n                               (long)post->strip_height),\n         post->strip_height);\n#else\n      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);\n#endif /* QUANT_2PASS_SUPPORTED */\n    } else {\n      /* One-pass color quantization: just make a strip buffer. */\n      post->buffer = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n        ((j_common_ptr)cinfo, JPOOL_IMAGE,\n         cinfo->output_width * cinfo->out_color_components,\n         post->strip_height);\n    }\n#else\n    ERREXIT(cinfo, JERR_NOTIMPL);\n#endif\n  }\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED) */\n"
        },
        {
          "name": "jdsample.c",
          "type": "blob",
          "size": 18.1474609375,
          "content": "/*\n * jdsample.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2010, 2015-2016, 2022, D. R. Commander.\n * Copyright (C) 2014, MIPS Technologies, Inc., California.\n * Copyright (C) 2015, Google, Inc.\n * Copyright (C) 2019-2020, Arm Limited.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains upsampling routines.\n *\n * Upsampling input data is counted in \"row groups\".  A row group\n * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)\n * sample rows of each component.  Upsampling will normally produce\n * max_v_samp_factor pixel rows from each row group (but this could vary\n * if the upsampler is applying a scale factor of its own).\n *\n * An excellent reference for image resampling is\n *   Digital Image Warping, George Wolberg, 1990.\n *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.\n */\n\n#include \"jinclude.h\"\n#include \"jdsample.h\"\n#include \"jsimd.h\"\n#include \"jpegapicomp.h\"\n\n\n\n#if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)\n\n/*\n * Initialize for an upsampling pass.\n */\n\nMETHODDEF(void)\nstart_pass_upsample(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n\n  /* Mark the conversion buffer empty */\n  upsample->next_row_out = cinfo->max_v_samp_factor;\n  /* Initialize total-height counter for detecting bottom of image */\n  upsample->rows_to_go = cinfo->output_height;\n}\n\n\n/*\n * Control routine to do upsampling (and color conversion).\n *\n * In this version we upsample each component independently.\n * We upsample one row group into the conversion buffer, then apply\n * color conversion a row at a time.\n */\n\nMETHODDEF(void)\nsep_upsample(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,\n             JDIMENSION *in_row_group_ctr, JDIMENSION in_row_groups_avail,\n             _JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n             JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int ci;\n  jpeg_component_info *compptr;\n  JDIMENSION num_rows;\n\n  /* Fill the conversion buffer, if it's empty */\n  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {\n    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n         ci++, compptr++) {\n      /* Invoke per-component upsample method.  Notice we pass a POINTER\n       * to color_buf[ci], so that fullsize_upsample can change it.\n       */\n      (*upsample->methods[ci]) (cinfo, compptr,\n        input_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),\n        upsample->color_buf + ci);\n    }\n    upsample->next_row_out = 0;\n  }\n\n  /* Color-convert and emit rows */\n\n  /* How many we have in the buffer: */\n  num_rows = (JDIMENSION)(cinfo->max_v_samp_factor - upsample->next_row_out);\n  /* Not more than the distance to the end of the image.  Need this test\n   * in case the image height is not a multiple of max_v_samp_factor:\n   */\n  if (num_rows > upsample->rows_to_go)\n    num_rows = upsample->rows_to_go;\n  /* And not more than what the client can accept: */\n  out_rows_avail -= *out_row_ctr;\n  if (num_rows > out_rows_avail)\n    num_rows = out_rows_avail;\n\n  (*cinfo->cconvert->_color_convert) (cinfo, upsample->color_buf,\n                                      (JDIMENSION)upsample->next_row_out,\n                                      output_buf + *out_row_ctr,\n                                      (int)num_rows);\n\n  /* Adjust counts */\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  upsample->next_row_out += num_rows;\n  /* When the buffer is emptied, declare this input row group consumed */\n  if (upsample->next_row_out >= cinfo->max_v_samp_factor)\n    (*in_row_group_ctr)++;\n}\n\n\n/*\n * These are the routines invoked by sep_upsample to upsample pixel values\n * of a single component.  One row group is processed per call.\n */\n\n\n/*\n * For full-size components, we just make color_buf[ci] point at the\n * input buffer, and thus avoid copying any data.  Note that this is\n * safe only because sep_upsample doesn't declare the input row group\n * \"consumed\" until we are done color converting and emitting it.\n */\n\nMETHODDEF(void)\nfullsize_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                  _JSAMPARRAY input_data, _JSAMPARRAY *output_data_ptr)\n{\n  *output_data_ptr = input_data;\n}\n\n\n/*\n * This is a no-op version used for \"uninteresting\" components.\n * These components will not be referenced by color conversion.\n */\n\nMETHODDEF(void)\nnoop_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n              _JSAMPARRAY input_data, _JSAMPARRAY *output_data_ptr)\n{\n  *output_data_ptr = NULL;      /* safety check */\n}\n\n\n/*\n * This version handles any integral sampling ratios.\n * This is not used for typical JPEG files, so it need not be fast.\n * Nor, for that matter, is it particularly accurate: the algorithm is\n * simple replication of the input pixel onto the corresponding output\n * pixels.  The hi-falutin sampling literature refers to this as a\n * \"box filter\".  A box filter tends to introduce visible artifacts,\n * so if you are actually going to use 3:1 or 4:1 sampling ratios\n * you would be well advised to improve this code.\n */\n\nMETHODDEF(void)\nint_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n             _JSAMPARRAY input_data, _JSAMPARRAY *output_data_ptr)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  _JSAMPARRAY output_data = *output_data_ptr;\n  register _JSAMPROW inptr, outptr;\n  register _JSAMPLE invalue;\n  register int h;\n  _JSAMPROW outend;\n  int h_expand, v_expand;\n  int inrow, outrow;\n\n  h_expand = upsample->h_expand[compptr->component_index];\n  v_expand = upsample->v_expand[compptr->component_index];\n\n  inrow = outrow = 0;\n  while (outrow < cinfo->max_v_samp_factor) {\n    /* Generate one output row with proper horizontal expansion */\n    inptr = input_data[inrow];\n    outptr = output_data[outrow];\n    outend = outptr + cinfo->output_width;\n    while (outptr < outend) {\n      invalue = *inptr++;\n      for (h = h_expand; h > 0; h--) {\n        *outptr++ = invalue;\n      }\n    }\n    /* Generate any additional output rows by duplicating the first one */\n    if (v_expand > 1) {\n      _jcopy_sample_rows(output_data, outrow, output_data, outrow + 1,\n                         v_expand - 1, cinfo->output_width);\n    }\n    inrow++;\n    outrow += v_expand;\n  }\n}\n\n\n/*\n * Fast processing for the common case of 2:1 horizontal and 1:1 vertical.\n * It's still a box filter.\n */\n\nMETHODDEF(void)\nh2v1_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n              _JSAMPARRAY input_data, _JSAMPARRAY *output_data_ptr)\n{\n  _JSAMPARRAY output_data = *output_data_ptr;\n  register _JSAMPROW inptr, outptr;\n  register _JSAMPLE invalue;\n  _JSAMPROW outend;\n  int inrow;\n\n  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {\n    inptr = input_data[inrow];\n    outptr = output_data[inrow];\n    outend = outptr + cinfo->output_width;\n    while (outptr < outend) {\n      invalue = *inptr++;\n      *outptr++ = invalue;\n      *outptr++ = invalue;\n    }\n  }\n}\n\n\n/*\n * Fast processing for the common case of 2:1 horizontal and 2:1 vertical.\n * It's still a box filter.\n */\n\nMETHODDEF(void)\nh2v2_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n              _JSAMPARRAY input_data, _JSAMPARRAY *output_data_ptr)\n{\n  _JSAMPARRAY output_data = *output_data_ptr;\n  register _JSAMPROW inptr, outptr;\n  register _JSAMPLE invalue;\n  _JSAMPROW outend;\n  int inrow, outrow;\n\n  inrow = outrow = 0;\n  while (outrow < cinfo->max_v_samp_factor) {\n    inptr = input_data[inrow];\n    outptr = output_data[outrow];\n    outend = outptr + cinfo->output_width;\n    while (outptr < outend) {\n      invalue = *inptr++;\n      *outptr++ = invalue;\n      *outptr++ = invalue;\n    }\n    _jcopy_sample_rows(output_data, outrow, output_data, outrow + 1, 1,\n                       cinfo->output_width);\n    inrow++;\n    outrow += 2;\n  }\n}\n\n\n/*\n * Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.\n *\n * The upsampling algorithm is linear interpolation between pixel centers,\n * also known as a \"triangle filter\".  This is a good compromise between\n * speed and visual quality.  The centers of the output pixels are 1/4 and 3/4\n * of the way between input pixel centers.\n *\n * A note about the \"bias\" calculations: when rounding fractional values to\n * integer, we do not want to always round 0.5 up to the next integer.\n * If we did that, we'd introduce a noticeable bias towards larger values.\n * Instead, this code is arranged so that 0.5 will be rounded up or down at\n * alternate pixel locations (a simple ordered dither pattern).\n */\n\nMETHODDEF(void)\nh2v1_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                    _JSAMPARRAY input_data, _JSAMPARRAY *output_data_ptr)\n{\n  _JSAMPARRAY output_data = *output_data_ptr;\n  register _JSAMPROW inptr, outptr;\n  register int invalue;\n  register JDIMENSION colctr;\n  int inrow;\n\n  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {\n    inptr = input_data[inrow];\n    outptr = output_data[inrow];\n    /* Special case for first column */\n    invalue = *inptr++;\n    *outptr++ = (_JSAMPLE)invalue;\n    *outptr++ = (_JSAMPLE)((invalue * 3 + inptr[0] + 2) >> 2);\n\n    for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {\n      /* General case: 3/4 * nearer pixel + 1/4 * further pixel */\n      invalue = (*inptr++) * 3;\n      *outptr++ = (_JSAMPLE)((invalue + inptr[-2] + 1) >> 2);\n      *outptr++ = (_JSAMPLE)((invalue + inptr[0] + 2) >> 2);\n    }\n\n    /* Special case for last column */\n    invalue = *inptr;\n    *outptr++ = (_JSAMPLE)((invalue * 3 + inptr[-1] + 1) >> 2);\n    *outptr++ = (_JSAMPLE)invalue;\n  }\n}\n\n\n/*\n * Fancy processing for 1:1 horizontal and 2:1 vertical (4:4:0 subsampling).\n *\n * This is a less common case, but it can be encountered when losslessly\n * rotating/transposing a JPEG file that uses 4:2:2 chroma subsampling.\n */\n\nMETHODDEF(void)\nh1v2_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                    _JSAMPARRAY input_data, _JSAMPARRAY *output_data_ptr)\n{\n  _JSAMPARRAY output_data = *output_data_ptr;\n  _JSAMPROW inptr0, inptr1, outptr;\n#if BITS_IN_JSAMPLE == 8\n  int thiscolsum, bias;\n#else\n  JLONG thiscolsum, bias;\n#endif\n  JDIMENSION colctr;\n  int inrow, outrow, v;\n\n  inrow = outrow = 0;\n  while (outrow < cinfo->max_v_samp_factor) {\n    for (v = 0; v < 2; v++) {\n      /* inptr0 points to nearest input row, inptr1 points to next nearest */\n      inptr0 = input_data[inrow];\n      if (v == 0) {             /* next nearest is row above */\n        inptr1 = input_data[inrow - 1];\n        bias = 1;\n      } else {                  /* next nearest is row below */\n        inptr1 = input_data[inrow + 1];\n        bias = 2;\n      }\n      outptr = output_data[outrow++];\n\n      for (colctr = 0; colctr < compptr->downsampled_width; colctr++) {\n        thiscolsum = (*inptr0++) * 3 + (*inptr1++);\n        *outptr++ = (_JSAMPLE)((thiscolsum + bias) >> 2);\n      }\n    }\n    inrow++;\n  }\n}\n\n\n/*\n * Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.\n * Again a triangle filter; see comments for h2v1 case, above.\n *\n * It is OK for us to reference the adjacent input rows because we demanded\n * context from the main buffer controller (see initialization code).\n */\n\nMETHODDEF(void)\nh2v2_fancy_upsample(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                    _JSAMPARRAY input_data, _JSAMPARRAY *output_data_ptr)\n{\n  _JSAMPARRAY output_data = *output_data_ptr;\n  register _JSAMPROW inptr0, inptr1, outptr;\n#if BITS_IN_JSAMPLE == 8\n  register int thiscolsum, lastcolsum, nextcolsum;\n#else\n  register JLONG thiscolsum, lastcolsum, nextcolsum;\n#endif\n  register JDIMENSION colctr;\n  int inrow, outrow, v;\n\n  inrow = outrow = 0;\n  while (outrow < cinfo->max_v_samp_factor) {\n    for (v = 0; v < 2; v++) {\n      /* inptr0 points to nearest input row, inptr1 points to next nearest */\n      inptr0 = input_data[inrow];\n      if (v == 0)               /* next nearest is row above */\n        inptr1 = input_data[inrow - 1];\n      else                      /* next nearest is row below */\n        inptr1 = input_data[inrow + 1];\n      outptr = output_data[outrow++];\n\n      /* Special case for first column */\n      thiscolsum = (*inptr0++) * 3 + (*inptr1++);\n      nextcolsum = (*inptr0++) * 3 + (*inptr1++);\n      *outptr++ = (_JSAMPLE)((thiscolsum * 4 + 8) >> 4);\n      *outptr++ = (_JSAMPLE)((thiscolsum * 3 + nextcolsum + 7) >> 4);\n      lastcolsum = thiscolsum;  thiscolsum = nextcolsum;\n\n      for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {\n        /* General case: 3/4 * nearer pixel + 1/4 * further pixel in each */\n        /* dimension, thus 9/16, 3/16, 3/16, 1/16 overall */\n        nextcolsum = (*inptr0++) * 3 + (*inptr1++);\n        *outptr++ = (_JSAMPLE)((thiscolsum * 3 + lastcolsum + 8) >> 4);\n        *outptr++ = (_JSAMPLE)((thiscolsum * 3 + nextcolsum + 7) >> 4);\n        lastcolsum = thiscolsum;  thiscolsum = nextcolsum;\n      }\n\n      /* Special case for last column */\n      *outptr++ = (_JSAMPLE)((thiscolsum * 3 + lastcolsum + 8) >> 4);\n      *outptr++ = (_JSAMPLE)((thiscolsum * 4 + 7) >> 4);\n    }\n    inrow++;\n  }\n}\n\n\n/*\n * Module initialization routine for upsampling.\n */\n\nGLOBAL(void)\n_jinit_upsampler(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample;\n  int ci;\n  jpeg_component_info *compptr;\n  boolean need_buffer, do_fancy;\n  int h_in_group, v_in_group, h_out_group, v_out_group;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  if (!cinfo->master->jinit_upsampler_no_alloc) {\n    upsample = (my_upsample_ptr)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  sizeof(my_upsampler));\n    cinfo->upsample = (struct jpeg_upsampler *)upsample;\n    upsample->pub.start_pass = start_pass_upsample;\n    upsample->pub._upsample = sep_upsample;\n    upsample->pub.need_context_rows = FALSE; /* until we find out differently */\n  } else\n    upsample = (my_upsample_ptr)cinfo->upsample;\n\n  if (cinfo->CCIR601_sampling)  /* this isn't supported */\n    ERREXIT(cinfo, JERR_CCIR601_NOTIMPL);\n\n  /* jdmainct.c doesn't support context rows when min_DCT_scaled_size = 1,\n   * so don't ask for it.\n   */\n  do_fancy = cinfo->do_fancy_upsampling && cinfo->_min_DCT_scaled_size > 1;\n\n  /* Verify we can handle the sampling factors, select per-component methods,\n   * and create storage as needed.\n   */\n  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;\n       ci++, compptr++) {\n    /* Compute size of an \"input group\" after IDCT scaling.  This many samples\n     * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.\n     */\n    h_in_group = (compptr->h_samp_factor * compptr->_DCT_scaled_size) /\n                 cinfo->_min_DCT_scaled_size;\n    v_in_group = (compptr->v_samp_factor * compptr->_DCT_scaled_size) /\n                 cinfo->_min_DCT_scaled_size;\n    h_out_group = cinfo->max_h_samp_factor;\n    v_out_group = cinfo->max_v_samp_factor;\n    upsample->rowgroup_height[ci] = v_in_group; /* save for use later */\n    need_buffer = TRUE;\n    if (!compptr->component_needed) {\n      /* Don't bother to upsample an uninteresting component. */\n      upsample->methods[ci] = noop_upsample;\n      need_buffer = FALSE;\n    } else if (h_in_group == h_out_group && v_in_group == v_out_group) {\n      /* Fullsize components can be processed without any work. */\n      upsample->methods[ci] = fullsize_upsample;\n      need_buffer = FALSE;\n    } else if (h_in_group * 2 == h_out_group && v_in_group == v_out_group) {\n      /* Special cases for 2h1v upsampling */\n      if (do_fancy && compptr->downsampled_width > 2) {\n#ifdef WITH_SIMD\n        if (jsimd_can_h2v1_fancy_upsample())\n          upsample->methods[ci] = jsimd_h2v1_fancy_upsample;\n        else\n#endif\n          upsample->methods[ci] = h2v1_fancy_upsample;\n      } else {\n#ifdef WITH_SIMD\n        if (jsimd_can_h2v1_upsample())\n          upsample->methods[ci] = jsimd_h2v1_upsample;\n        else\n#endif\n          upsample->methods[ci] = h2v1_upsample;\n      }\n    } else if (h_in_group == h_out_group &&\n               v_in_group * 2 == v_out_group && do_fancy) {\n      /* Non-fancy upsampling is handled by the generic method */\n#if defined(WITH_SIMD) && (defined(__arm__) || defined(__aarch64__) || \\\n                           defined(_M_ARM) || defined(_M_ARM64))\n      if (jsimd_can_h1v2_fancy_upsample())\n        upsample->methods[ci] = jsimd_h1v2_fancy_upsample;\n      else\n#endif\n        upsample->methods[ci] = h1v2_fancy_upsample;\n      upsample->pub.need_context_rows = TRUE;\n    } else if (h_in_group * 2 == h_out_group &&\n               v_in_group * 2 == v_out_group) {\n      /* Special cases for 2h2v upsampling */\n      if (do_fancy && compptr->downsampled_width > 2) {\n#ifdef WITH_SIMD\n        if (jsimd_can_h2v2_fancy_upsample())\n          upsample->methods[ci] = jsimd_h2v2_fancy_upsample;\n        else\n#endif\n          upsample->methods[ci] = h2v2_fancy_upsample;\n        upsample->pub.need_context_rows = TRUE;\n      } else {\n#ifdef WITH_SIMD\n        if (jsimd_can_h2v2_upsample())\n          upsample->methods[ci] = jsimd_h2v2_upsample;\n        else\n#endif\n          upsample->methods[ci] = h2v2_upsample;\n      }\n    } else if ((h_out_group % h_in_group) == 0 &&\n               (v_out_group % v_in_group) == 0) {\n      /* Generic integral-factors upsampling method */\n#if defined(WITH_SIMD) && defined(__mips__)\n      if (jsimd_can_int_upsample())\n        upsample->methods[ci] = jsimd_int_upsample;\n      else\n#endif\n        upsample->methods[ci] = int_upsample;\n      upsample->h_expand[ci] = (UINT8)(h_out_group / h_in_group);\n      upsample->v_expand[ci] = (UINT8)(v_out_group / v_in_group);\n    } else\n      ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);\n    if (need_buffer && !cinfo->master->jinit_upsampler_no_alloc) {\n      upsample->color_buf[ci] = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n        ((j_common_ptr)cinfo, JPOOL_IMAGE,\n         (JDIMENSION)jround_up((long)cinfo->output_width,\n                               (long)cinfo->max_h_samp_factor),\n         (JDIMENSION)cinfo->max_v_samp_factor);\n    }\n  }\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED) */\n"
        },
        {
          "name": "jdsample.h",
          "type": "blob",
          "size": 1.7822265625,
          "content": "/*\n * jdsample.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n */\n\n#define JPEG_INTERNALS\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n\n\n/* Pointer to routine to upsample a single component */\ntypedef void (*upsample1_ptr) (j_decompress_ptr cinfo,\n                               jpeg_component_info *compptr,\n                               _JSAMPARRAY input_data,\n                               _JSAMPARRAY *output_data_ptr);\n\n/* Private subobject */\n\ntypedef struct {\n  struct jpeg_upsampler pub;    /* public fields */\n\n  /* Color conversion buffer.  When using separate upsampling and color\n   * conversion steps, this buffer holds one upsampled row group until it\n   * has been color converted and output.\n   * Note: we do not allocate any storage for component(s) which are full-size,\n   * ie do not need rescaling.  The corresponding entry of color_buf[] is\n   * simply set to point to the input data array, thereby avoiding copying.\n   */\n  _JSAMPARRAY color_buf[MAX_COMPONENTS];\n\n  /* Per-component upsampling method pointers */\n  upsample1_ptr methods[MAX_COMPONENTS];\n\n  int next_row_out;             /* counts rows emitted from color_buf */\n  JDIMENSION rows_to_go;        /* counts rows remaining in image */\n\n  /* Height of an input row group for each component. */\n  int rowgroup_height[MAX_COMPONENTS];\n\n  /* These arrays save pixel expansion factors so that int_expand need not\n   * recompute them each time.  They are unused for other upsampling methods.\n   */\n  UINT8 h_expand[MAX_COMPONENTS];\n  UINT8 v_expand[MAX_COMPONENTS];\n} my_upsampler;\n\ntypedef my_upsampler *my_upsample_ptr;\n"
        },
        {
          "name": "jdtrans.c",
          "type": "blob",
          "size": 5.4921875,
          "content": "/*\n * jdtrans.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1995-1997, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2020, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains library routines for transcoding decompression,\n * that is, reading raw DCT coefficient arrays from an input JPEG file.\n * The routines in jdapimin.c will also be needed by a transcoder.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jpegapicomp.h\"\n\n\n/* Forward declarations */\nLOCAL(void) transdecode_master_selection(j_decompress_ptr cinfo);\n\n\n/*\n * Read the coefficient arrays from a JPEG file.\n * jpeg_read_header must be completed before calling this.\n *\n * The entire image is read into a set of virtual coefficient-block arrays,\n * one per component.  The return value is a pointer to the array of\n * virtual-array descriptors.  These can be manipulated directly via the\n * JPEG memory manager, or handed off to jpeg_write_coefficients().\n * To release the memory occupied by the virtual arrays, call\n * jpeg_finish_decompress() when done with the data.\n *\n * An alternative usage is to simply obtain access to the coefficient arrays\n * during a buffered-image-mode decompression operation.  This is allowed\n * after any jpeg_finish_output() call.  The arrays can be accessed until\n * jpeg_finish_decompress() is called.  (Note that any call to the library\n * may reposition the arrays, so don't rely on access_virt_barray() results\n * to stay valid across library calls.)\n *\n * Returns NULL if suspended.  This case need be checked only if\n * a suspending data source is used.\n */\n\nGLOBAL(jvirt_barray_ptr *)\njpeg_read_coefficients(j_decompress_ptr cinfo)\n{\n  if (cinfo->master->lossless)\n    ERREXIT(cinfo, JERR_NOTIMPL);\n\n  if (cinfo->global_state == DSTATE_READY) {\n    /* First call: initialize active modules */\n    transdecode_master_selection(cinfo);\n    cinfo->global_state = DSTATE_RDCOEFS;\n  }\n  if (cinfo->global_state == DSTATE_RDCOEFS) {\n    /* Absorb whole file into the coef buffer */\n    for (;;) {\n      int retcode;\n      /* Call progress monitor hook if present */\n      if (cinfo->progress != NULL)\n        (*cinfo->progress->progress_monitor) ((j_common_ptr)cinfo);\n      /* Absorb some more input */\n      retcode = (*cinfo->inputctl->consume_input) (cinfo);\n      if (retcode == JPEG_SUSPENDED)\n        return NULL;\n      if (retcode == JPEG_REACHED_EOI)\n        break;\n      /* Advance progress counter if appropriate */\n      if (cinfo->progress != NULL &&\n          (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {\n        if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {\n          /* startup underestimated number of scans; ratchet up one scan */\n          cinfo->progress->pass_limit += (long)cinfo->total_iMCU_rows;\n        }\n      }\n    }\n    /* Set state so that jpeg_finish_decompress does the right thing */\n    cinfo->global_state = DSTATE_STOPPING;\n  }\n  /* At this point we should be in state DSTATE_STOPPING if being used\n   * standalone, or in state DSTATE_BUFIMAGE if being invoked to get access\n   * to the coefficients during a full buffered-image-mode decompression.\n   */\n  if ((cinfo->global_state == DSTATE_STOPPING ||\n       cinfo->global_state == DSTATE_BUFIMAGE) && cinfo->buffered_image) {\n    return cinfo->coef->coef_arrays;\n  }\n  /* Oops, improper usage */\n  ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);\n  return NULL;                  /* keep compiler happy */\n}\n\n\n/*\n * Master selection of decompression modules for transcoding.\n * This substitutes for jdmaster.c's initialization of the full decompressor.\n */\n\nLOCAL(void)\ntransdecode_master_selection(j_decompress_ptr cinfo)\n{\n  /* This is effectively a buffered-image operation. */\n  cinfo->buffered_image = TRUE;\n\n#if JPEG_LIB_VERSION >= 80\n  /* Compute output image dimensions and related values. */\n  jpeg_core_output_dimensions(cinfo);\n#endif\n\n  /* Entropy decoding: either Huffman or arithmetic coding. */\n  if (cinfo->arith_code) {\n#ifdef D_ARITH_CODING_SUPPORTED\n    jinit_arith_decoder(cinfo);\n#else\n    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);\n#endif\n  } else {\n    if (cinfo->progressive_mode) {\n#ifdef D_PROGRESSIVE_SUPPORTED\n      jinit_phuff_decoder(cinfo);\n#else\n      ERREXIT(cinfo, JERR_NOT_COMPILED);\n#endif\n    } else\n      jinit_huff_decoder(cinfo);\n  }\n\n  /* Always get a full-image coefficient buffer. */\n  if (cinfo->data_precision == 12)\n    j12init_d_coef_controller(cinfo, TRUE);\n  else\n    jinit_d_coef_controller(cinfo, TRUE);\n\n  /* We can now tell the memory manager to allocate virtual arrays. */\n  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr)cinfo);\n\n  /* Initialize input side of decompressor to consume first scan. */\n  (*cinfo->inputctl->start_input_pass) (cinfo);\n\n  /* Initialize progress monitoring. */\n  if (cinfo->progress != NULL) {\n    int nscans;\n    /* Estimate number of scans to set pass_limit. */\n    if (cinfo->progressive_mode) {\n      /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */\n      nscans = 2 + 3 * cinfo->num_components;\n    } else if (cinfo->inputctl->has_multiple_scans) {\n      /* For a nonprogressive multiscan file, estimate 1 scan per component. */\n      nscans = cinfo->num_components;\n    } else {\n      nscans = 1;\n    }\n    cinfo->progress->pass_counter = 0L;\n    cinfo->progress->pass_limit = (long)cinfo->total_iMCU_rows * nscans;\n    cinfo->progress->completed_passes = 0;\n    cinfo->progress->total_passes = 1;\n  }\n}\n"
        },
        {
          "name": "jerror.c",
          "type": "blob",
          "size": 7.388671875,
          "content": "/*\n * jerror.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1998, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains simple error-reporting and trace-message routines.\n * These are suitable for Unix-like systems and others where writing to\n * stderr is the right thing to do.  Many applications will want to replace\n * some or all of these routines.\n *\n * If you define USE_WINDOWS_MESSAGEBOX in jconfig.h or in the makefile,\n * you get a Windows-specific hack to display error messages in a dialog box.\n * It ain't much, but it beats dropping error messages into the bit bucket,\n * which is what happens to output to stderr under most Windows C compilers.\n *\n * These routines are used by both the compression and decompression code.\n */\n\n/* this is not a core library module, so it doesn't define JPEG_INTERNALS */\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jversion.h\"\n#include \"jerror.h\"\n\n#ifdef USE_WINDOWS_MESSAGEBOX\n#include <windows.h>\n#endif\n\n#ifndef EXIT_FAILURE            /* define exit() codes if not provided */\n#define EXIT_FAILURE  1\n#endif\n\n\n/*\n * Create the message string table.\n * We do this from the master message list in jerror.h by re-reading\n * jerror.h with a suitable definition for macro JMESSAGE.\n */\n\n#define JMESSAGE(code, string)  string,\n\nstatic const char * const jpeg_std_message_table[] = {\n#include \"jerror.h\"\n  NULL\n};\n\n\n/*\n * Error exit handler: must not return to caller.\n *\n * Applications may override this if they want to get control back after\n * an error.  Typically one would longjmp somewhere instead of exiting.\n * The setjmp buffer can be made a private field within an expanded error\n * handler object.  Note that the info needed to generate an error message\n * is stored in the error object, so you can generate the message now or\n * later, at your convenience.\n * You should make sure that the JPEG object is cleaned up (with jpeg_abort\n * or jpeg_destroy) at some point.\n */\n\nMETHODDEF(void)\nerror_exit(j_common_ptr cinfo)\n{\n  /* Always display the message */\n  (*cinfo->err->output_message) (cinfo);\n\n  /* Let the memory manager delete any temp files before we die */\n  jpeg_destroy(cinfo);\n\n  exit(EXIT_FAILURE);\n}\n\n\n/*\n * Actual output of an error or trace message.\n * Applications may override this method to send JPEG messages somewhere\n * other than stderr.\n *\n * On Windows, printing to stderr is generally completely useless,\n * so we provide optional code to produce an error-dialog popup.\n * Most Windows applications will still prefer to override this routine,\n * but if they don't, it'll do something at least marginally useful.\n *\n * NOTE: to use the library in an environment that doesn't support the\n * C stdio library, you may have to delete the call to fprintf() entirely,\n * not just not use this routine.\n */\n\nMETHODDEF(void)\noutput_message(j_common_ptr cinfo)\n{\n  char buffer[JMSG_LENGTH_MAX];\n\n  /* Create the message */\n  (*cinfo->err->format_message) (cinfo, buffer);\n\n#ifdef USE_WINDOWS_MESSAGEBOX\n  /* Display it in a message dialog box */\n  MessageBox(GetActiveWindow(), buffer, \"JPEG Library Error\",\n             MB_OK | MB_ICONERROR);\n#else\n  /* Send it to stderr, adding a newline */\n  fprintf(stderr, \"%s\\n\", buffer);\n#endif\n}\n\n\n/*\n * Decide whether to emit a trace or warning message.\n * msg_level is one of:\n *   -1: recoverable corrupt-data warning, may want to abort.\n *    0: important advisory messages (always display to user).\n *    1: first level of tracing detail.\n *    2,3,...: successively more detailed tracing messages.\n * An application might override this method if it wanted to abort on warnings\n * or change the policy about which messages to display.\n */\n\nMETHODDEF(void)\nemit_message(j_common_ptr cinfo, int msg_level)\n{\n  struct jpeg_error_mgr *err = cinfo->err;\n\n  if (msg_level < 0) {\n    /* It's a warning message.  Since corrupt files may generate many warnings,\n     * the policy implemented here is to show only the first warning,\n     * unless trace_level >= 3.\n     */\n    if (err->num_warnings == 0 || err->trace_level >= 3)\n      (*err->output_message) (cinfo);\n    /* Always count warnings in num_warnings. */\n    err->num_warnings++;\n  } else {\n    /* It's a trace message.  Show it if trace_level >= msg_level. */\n    if (err->trace_level >= msg_level)\n      (*err->output_message) (cinfo);\n  }\n}\n\n\n/*\n * Format a message string for the most recent JPEG error or message.\n * The message is stored into buffer, which should be at least JMSG_LENGTH_MAX\n * characters.  Note that no '\\n' character is added to the string.\n * Few applications should need to override this method.\n */\n\nMETHODDEF(void)\nformat_message(j_common_ptr cinfo, char *buffer)\n{\n  struct jpeg_error_mgr *err = cinfo->err;\n  int msg_code = err->msg_code;\n  const char *msgtext = NULL;\n  const char *msgptr;\n  char ch;\n  boolean isstring;\n\n  /* Look up message string in proper table */\n  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {\n    msgtext = err->jpeg_message_table[msg_code];\n  } else if (err->addon_message_table != NULL &&\n             msg_code >= err->first_addon_message &&\n             msg_code <= err->last_addon_message) {\n    msgtext = err->addon_message_table[msg_code - err->first_addon_message];\n  }\n\n  /* Defend against bogus message number */\n  if (msgtext == NULL) {\n    err->msg_parm.i[0] = msg_code;\n    msgtext = err->jpeg_message_table[0];\n  }\n\n  /* Check for string parameter, as indicated by %s in the message text */\n  isstring = FALSE;\n  msgptr = msgtext;\n  while ((ch = *msgptr++) != '\\0') {\n    if (ch == '%') {\n      if (*msgptr == 's') isstring = TRUE;\n      break;\n    }\n  }\n\n  /* Format the message into the passed buffer */\n  if (isstring)\n    SNPRINTF(buffer, JMSG_LENGTH_MAX, msgtext, err->msg_parm.s);\n  else\n    SNPRINTF(buffer, JMSG_LENGTH_MAX, msgtext,\n             err->msg_parm.i[0], err->msg_parm.i[1],\n             err->msg_parm.i[2], err->msg_parm.i[3],\n             err->msg_parm.i[4], err->msg_parm.i[5],\n             err->msg_parm.i[6], err->msg_parm.i[7]);\n}\n\n\n/*\n * Reset error state variables at start of a new image.\n * This is called during compression startup to reset trace/error\n * processing to default state, without losing any application-specific\n * method pointers.  An application might possibly want to override\n * this method if it has additional error processing state.\n */\n\nMETHODDEF(void)\nreset_error_mgr(j_common_ptr cinfo)\n{\n  cinfo->err->num_warnings = 0;\n  /* trace_level is not reset since it is an application-supplied parameter */\n  cinfo->err->msg_code = 0;     /* may be useful as a flag for \"no error\" */\n}\n\n\n/*\n * Fill in the standard error-handling methods in a jpeg_error_mgr object.\n * Typical call is:\n *      struct jpeg_compress_struct cinfo;\n *      struct jpeg_error_mgr err;\n *\n *      cinfo.err = jpeg_std_error(&err);\n * after which the application may override some of the methods.\n */\n\nGLOBAL(struct jpeg_error_mgr *)\njpeg_std_error(struct jpeg_error_mgr *err)\n{\n  memset(err, 0, sizeof(struct jpeg_error_mgr));\n\n  err->error_exit = error_exit;\n  err->emit_message = emit_message;\n  err->output_message = output_message;\n  err->format_message = format_message;\n  err->reset_error_mgr = reset_error_mgr;\n\n  /* Initialize message table pointers */\n  err->jpeg_message_table = jpeg_std_message_table;\n  err->last_jpeg_message = (int)JMSG_LASTMSGCODE - 1;\n\n  return err;\n}\n"
        },
        {
          "name": "jerror.h",
          "type": "blob",
          "size": 15.966796875,
          "content": "/*\n * jerror.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * Modified 1997-2009 by Guido Vollbeding.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2014, 2017, 2021-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file defines the error and message codes for the JPEG library.\n * Edit this file to add new codes, or to translate the message strings to\n * some other language.\n * A set of error-reporting macros are defined too.  Some applications using\n * the JPEG library may wish to include this file to get the error codes\n * and/or the macros.\n */\n\n/*\n * To define the enum list of message codes, include this file without\n * defining macro JMESSAGE.  To create a message string table, include it\n * again with a suitable JMESSAGE definition (see jerror.c for an example).\n */\n#ifndef JMESSAGE\n#ifndef JERROR_H\n/* First time through, define the enum list */\n#define JMAKE_ENUM_LIST\n#else\n/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */\n#define JMESSAGE(code, string)\n#endif /* JERROR_H */\n#endif /* JMESSAGE */\n\n#ifdef JMAKE_ENUM_LIST\n\ntypedef enum {\n\n#define JMESSAGE(code, string)  code,\n\n#endif /* JMAKE_ENUM_LIST */\n\nJMESSAGE(JMSG_NOMESSAGE, \"Bogus message code %d\") /* Must be first entry! */\n\n/* For maintenance convenience, list is alphabetical by message code name */\n#if JPEG_LIB_VERSION < 70\nJMESSAGE(JERR_ARITH_NOTIMPL, \"Sorry, arithmetic coding is not implemented\")\n#endif\nJMESSAGE(JERR_BAD_ALIGN_TYPE, \"ALIGN_TYPE is wrong, please fix\")\nJMESSAGE(JERR_BAD_ALLOC_CHUNK, \"MAX_ALLOC_CHUNK is wrong, please fix\")\nJMESSAGE(JERR_BAD_BUFFER_MODE, \"Bogus buffer control mode\")\nJMESSAGE(JERR_BAD_COMPONENT_ID, \"Invalid component ID %d in SOS\")\n#if JPEG_LIB_VERSION >= 70\nJMESSAGE(JERR_BAD_CROP_SPEC, \"Invalid crop request\")\n#endif\nJMESSAGE(JERR_BAD_DCT_COEF,\n         \"DCT coefficient (lossy) or spatial difference (lossless) out of range\")\nJMESSAGE(JERR_BAD_DCTSIZE, \"IDCT output block size %d not supported\")\n#if JPEG_LIB_VERSION >= 70\nJMESSAGE(JERR_BAD_DROP_SAMPLING,\n         \"Component index %d: mismatching sampling ratio %d:%d, %d:%d, %c\")\n#endif\nJMESSAGE(JERR_BAD_HUFF_TABLE, \"Bogus Huffman table definition\")\nJMESSAGE(JERR_BAD_IN_COLORSPACE, \"Bogus input colorspace\")\nJMESSAGE(JERR_BAD_J_COLORSPACE, \"Bogus JPEG colorspace\")\nJMESSAGE(JERR_BAD_LENGTH, \"Bogus marker length\")\nJMESSAGE(JERR_BAD_LIB_VERSION,\n         \"Wrong JPEG library version: library is %d, caller expects %d\")\nJMESSAGE(JERR_BAD_MCU_SIZE, \"Sampling factors too large for interleaved scan\")\nJMESSAGE(JERR_BAD_POOL_ID, \"Invalid memory pool code %d\")\nJMESSAGE(JERR_BAD_PRECISION, \"Unsupported JPEG data precision %d\")\nJMESSAGE(JERR_BAD_PROGRESSION,\n         \"Invalid progressive/lossless parameters Ss=%d Se=%d Ah=%d Al=%d\")\nJMESSAGE(JERR_BAD_PROG_SCRIPT,\n         \"Invalid progressive/lossless parameters at scan script entry %d\")\nJMESSAGE(JERR_BAD_SAMPLING, \"Bogus sampling factors\")\nJMESSAGE(JERR_BAD_SCAN_SCRIPT, \"Invalid scan script at entry %d\")\nJMESSAGE(JERR_BAD_STATE, \"Improper call to JPEG library in state %d\")\nJMESSAGE(JERR_BAD_STRUCT_SIZE,\n         \"JPEG parameter struct mismatch: library thinks size is %u, caller expects %u\")\nJMESSAGE(JERR_BAD_VIRTUAL_ACCESS, \"Bogus virtual array access\")\nJMESSAGE(JERR_BUFFER_SIZE, \"Buffer passed to JPEG library is too small\")\nJMESSAGE(JERR_CANT_SUSPEND, \"Suspension not allowed here\")\nJMESSAGE(JERR_CCIR601_NOTIMPL, \"CCIR601 sampling not implemented yet\")\nJMESSAGE(JERR_COMPONENT_COUNT, \"Too many color components: %d, max %d\")\nJMESSAGE(JERR_CONVERSION_NOTIMPL, \"Unsupported color conversion request\")\nJMESSAGE(JERR_DAC_INDEX, \"Bogus DAC index %d\")\nJMESSAGE(JERR_DAC_VALUE, \"Bogus DAC value 0x%x\")\nJMESSAGE(JERR_DHT_INDEX, \"Bogus DHT index %d\")\nJMESSAGE(JERR_DQT_INDEX, \"Bogus DQT index %d\")\nJMESSAGE(JERR_EMPTY_IMAGE, \"Empty JPEG image (DNL not supported)\")\nJMESSAGE(JERR_EMS_READ, \"Read from EMS failed\")\nJMESSAGE(JERR_EMS_WRITE, \"Write to EMS failed\")\nJMESSAGE(JERR_EOI_EXPECTED, \"Didn't expect more than one scan\")\nJMESSAGE(JERR_FILE_READ, \"Input file read error\")\nJMESSAGE(JERR_FILE_WRITE, \"Output file write error --- out of disk space?\")\nJMESSAGE(JERR_FRACT_SAMPLE_NOTIMPL, \"Fractional sampling not implemented yet\")\nJMESSAGE(JERR_HUFF_CLEN_OVERFLOW, \"Huffman code size table overflow\")\nJMESSAGE(JERR_HUFF_MISSING_CODE, \"Missing Huffman code table entry\")\nJMESSAGE(JERR_IMAGE_TOO_BIG, \"Maximum supported image dimension is %u pixels\")\nJMESSAGE(JERR_INPUT_EMPTY, \"Empty input file\")\nJMESSAGE(JERR_INPUT_EOF, \"Premature end of input file\")\nJMESSAGE(JERR_MISMATCHED_QUANT_TABLE,\n         \"Cannot transcode due to multiple use of quantization table %d\")\nJMESSAGE(JERR_MISSING_DATA, \"Scan script does not transmit all data\")\nJMESSAGE(JERR_MODE_CHANGE, \"Invalid color quantization mode change\")\nJMESSAGE(JERR_NOTIMPL, \"Requested features are incompatible\")\nJMESSAGE(JERR_NOT_COMPILED, \"Requested feature was omitted at compile time\")\n#if JPEG_LIB_VERSION >= 70\nJMESSAGE(JERR_NO_ARITH_TABLE, \"Arithmetic table 0x%02x was not defined\")\n#endif\nJMESSAGE(JERR_NO_BACKING_STORE, \"Memory limit exceeded\")\nJMESSAGE(JERR_NO_HUFF_TABLE, \"Huffman table 0x%02x was not defined\")\nJMESSAGE(JERR_NO_IMAGE, \"JPEG datastream contains no image\")\nJMESSAGE(JERR_NO_QUANT_TABLE, \"Quantization table 0x%02x was not defined\")\nJMESSAGE(JERR_NO_SOI, \"Not a JPEG file: starts with 0x%02x 0x%02x\")\nJMESSAGE(JERR_OUT_OF_MEMORY, \"Insufficient memory (case %d)\")\nJMESSAGE(JERR_QUANT_COMPONENTS,\n         \"Cannot quantize more than %d color components\")\nJMESSAGE(JERR_QUANT_FEW_COLORS, \"Cannot quantize to fewer than %d colors\")\nJMESSAGE(JERR_QUANT_MANY_COLORS, \"Cannot quantize to more than %d colors\")\nJMESSAGE(JERR_SOF_DUPLICATE, \"Invalid JPEG file structure: two SOF markers\")\nJMESSAGE(JERR_SOF_NO_SOS, \"Invalid JPEG file structure: missing SOS marker\")\nJMESSAGE(JERR_SOF_UNSUPPORTED, \"Unsupported JPEG process: SOF type 0x%02x\")\nJMESSAGE(JERR_SOI_DUPLICATE, \"Invalid JPEG file structure: two SOI markers\")\nJMESSAGE(JERR_SOS_NO_SOF, \"Invalid JPEG file structure: SOS before SOF\")\nJMESSAGE(JERR_TFILE_CREATE, \"Failed to create temporary file %s\")\nJMESSAGE(JERR_TFILE_READ, \"Read failed on temporary file\")\nJMESSAGE(JERR_TFILE_SEEK, \"Seek failed on temporary file\")\nJMESSAGE(JERR_TFILE_WRITE,\n         \"Write failed on temporary file --- out of disk space?\")\nJMESSAGE(JERR_TOO_LITTLE_DATA, \"Application transferred too few scanlines\")\nJMESSAGE(JERR_UNKNOWN_MARKER, \"Unsupported marker type 0x%02x\")\nJMESSAGE(JERR_VIRTUAL_BUG, \"Virtual array controller messed up\")\nJMESSAGE(JERR_WIDTH_OVERFLOW, \"Image too wide for this implementation\")\nJMESSAGE(JERR_XMS_READ, \"Read from XMS failed\")\nJMESSAGE(JERR_XMS_WRITE, \"Write to XMS failed\")\nJMESSAGE(JMSG_COPYRIGHT, JCOPYRIGHT_SHORT)\nJMESSAGE(JMSG_VERSION, JVERSION)\nJMESSAGE(JTRC_16BIT_TABLES,\n         \"Caution: quantization tables are too coarse for baseline JPEG\")\nJMESSAGE(JTRC_ADOBE,\n         \"Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d\")\nJMESSAGE(JTRC_APP0, \"Unknown APP0 marker (not JFIF), length %u\")\nJMESSAGE(JTRC_APP14, \"Unknown APP14 marker (not Adobe), length %u\")\nJMESSAGE(JTRC_DAC, \"Define Arithmetic Table 0x%02x: 0x%02x\")\nJMESSAGE(JTRC_DHT, \"Define Huffman Table 0x%02x\")\nJMESSAGE(JTRC_DQT, \"Define Quantization Table %d  precision %d\")\nJMESSAGE(JTRC_DRI, \"Define Restart Interval %u\")\nJMESSAGE(JTRC_EMS_CLOSE, \"Freed EMS handle %u\")\nJMESSAGE(JTRC_EMS_OPEN, \"Obtained EMS handle %u\")\nJMESSAGE(JTRC_EOI, \"End Of Image\")\nJMESSAGE(JTRC_HUFFBITS, \"        %3d %3d %3d %3d %3d %3d %3d %3d\")\nJMESSAGE(JTRC_JFIF, \"JFIF APP0 marker: version %d.%02d, density %dx%d  %d\")\nJMESSAGE(JTRC_JFIF_BADTHUMBNAILSIZE,\n         \"Warning: thumbnail image size does not match data length %u\")\nJMESSAGE(JTRC_JFIF_EXTENSION, \"JFIF extension marker: type 0x%02x, length %u\")\nJMESSAGE(JTRC_JFIF_THUMBNAIL, \"    with %d x %d thumbnail image\")\nJMESSAGE(JTRC_MISC_MARKER, \"Miscellaneous marker 0x%02x, length %u\")\nJMESSAGE(JTRC_PARMLESS_MARKER, \"Unexpected marker 0x%02x\")\nJMESSAGE(JTRC_QUANTVALS, \"        %4u %4u %4u %4u %4u %4u %4u %4u\")\nJMESSAGE(JTRC_QUANT_3_NCOLORS, \"Quantizing to %d = %d*%d*%d colors\")\nJMESSAGE(JTRC_QUANT_NCOLORS, \"Quantizing to %d colors\")\nJMESSAGE(JTRC_QUANT_SELECTED, \"Selected %d colors for quantization\")\nJMESSAGE(JTRC_RECOVERY_ACTION, \"At marker 0x%02x, recovery action %d\")\nJMESSAGE(JTRC_RST, \"RST%d\")\nJMESSAGE(JTRC_SMOOTH_NOTIMPL,\n         \"Smoothing not supported with nonstandard sampling ratios\")\nJMESSAGE(JTRC_SOF, \"Start Of Frame 0x%02x: width=%u, height=%u, components=%d\")\nJMESSAGE(JTRC_SOF_COMPONENT, \"    Component %d: %dhx%dv q=%d\")\nJMESSAGE(JTRC_SOI, \"Start of Image\")\nJMESSAGE(JTRC_SOS, \"Start Of Scan: %d components\")\nJMESSAGE(JTRC_SOS_COMPONENT, \"    Component %d: dc=%d ac=%d\")\nJMESSAGE(JTRC_SOS_PARAMS, \"  Ss=%d, Se=%d, Ah=%d, Al=%d\")\nJMESSAGE(JTRC_TFILE_CLOSE, \"Closed temporary file %s\")\nJMESSAGE(JTRC_TFILE_OPEN, \"Opened temporary file %s\")\nJMESSAGE(JTRC_THUMB_JPEG,\n         \"JFIF extension marker: JPEG-compressed thumbnail image, length %u\")\nJMESSAGE(JTRC_THUMB_PALETTE,\n         \"JFIF extension marker: palette thumbnail image, length %u\")\nJMESSAGE(JTRC_THUMB_RGB,\n         \"JFIF extension marker: RGB thumbnail image, length %u\")\nJMESSAGE(JTRC_UNKNOWN_IDS,\n         \"Unrecognized component IDs %d %d %d, assuming YCbCr (lossy) or RGB (lossless)\")\nJMESSAGE(JTRC_XMS_CLOSE, \"Freed XMS handle %u\")\nJMESSAGE(JTRC_XMS_OPEN, \"Obtained XMS handle %u\")\nJMESSAGE(JWRN_ADOBE_XFORM, \"Unknown Adobe color transform code %d\")\n#if JPEG_LIB_VERSION >= 70\nJMESSAGE(JWRN_ARITH_BAD_CODE, \"Corrupt JPEG data: bad arithmetic code\")\n#endif\nJMESSAGE(JWRN_BOGUS_PROGRESSION,\n         \"Inconsistent progression sequence for component %d coefficient %d\")\nJMESSAGE(JWRN_EXTRANEOUS_DATA,\n         \"Corrupt JPEG data: %u extraneous bytes before marker 0x%02x\")\nJMESSAGE(JWRN_HIT_MARKER, \"Corrupt JPEG data: premature end of data segment\")\nJMESSAGE(JWRN_HUFF_BAD_CODE, \"Corrupt JPEG data: bad Huffman code\")\nJMESSAGE(JWRN_JFIF_MAJOR, \"Warning: unknown JFIF revision number %d.%02d\")\nJMESSAGE(JWRN_JPEG_EOF, \"Premature end of JPEG file\")\nJMESSAGE(JWRN_MUST_RESYNC,\n         \"Corrupt JPEG data: found marker 0x%02x instead of RST%d\")\nJMESSAGE(JWRN_NOT_SEQUENTIAL, \"Invalid SOS parameters for sequential JPEG\")\nJMESSAGE(JWRN_TOO_MUCH_DATA, \"Application transferred too many scanlines\")\n#if JPEG_LIB_VERSION < 70\nJMESSAGE(JERR_BAD_CROP_SPEC, \"Invalid crop request\")\n#if defined(C_ARITH_CODING_SUPPORTED) || defined(D_ARITH_CODING_SUPPORTED)\nJMESSAGE(JERR_NO_ARITH_TABLE, \"Arithmetic table 0x%02x was not defined\")\nJMESSAGE(JWRN_ARITH_BAD_CODE, \"Corrupt JPEG data: bad arithmetic code\")\n#endif\n#endif\nJMESSAGE(JERR_BAD_PARAM, \"Bogus parameter\")\nJMESSAGE(JERR_BAD_PARAM_VALUE, \"Bogus parameter value\")\n\nJMESSAGE(JERR_UNSUPPORTED_SUSPEND, \"I/O suspension not supported in scan optimization\")  \nJMESSAGE(JWRN_BOGUS_ICC, \"Corrupt JPEG data: bad ICC marker\")\n#if JPEG_LIB_VERSION < 70\nJMESSAGE(JERR_BAD_DROP_SAMPLING,\n         \"Component index %d: mismatching sampling ratio %d:%d, %d:%d, %c\")\n#endif\nJMESSAGE(JERR_BAD_RESTART,\n         \"Invalid restart interval %d; must be an integer multiple of the number of MCUs in an MCU row (%d)\")\n\n#ifdef JMAKE_ENUM_LIST\n\n  JMSG_LASTMSGCODE\n} J_MESSAGE_CODE;\n\n#undef JMAKE_ENUM_LIST\n#endif /* JMAKE_ENUM_LIST */\n\n/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */\n#undef JMESSAGE\n\n\n#ifndef JERROR_H\n#define JERROR_H\n\n/* Macros to simplify using the error and trace message stuff */\n/* The first parameter is either type of cinfo pointer */\n\n/* Fatal errors (print message and exit) */\n#define ERREXIT(cinfo, code) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))\n#define ERREXIT1(cinfo, code, p1) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (cinfo)->err->msg_parm.i[0] = (p1), \\\n   (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))\n#define ERREXIT2(cinfo, code, p1, p2) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (cinfo)->err->msg_parm.i[0] = (p1), \\\n   (cinfo)->err->msg_parm.i[1] = (p2), \\\n   (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))\n#define ERREXIT3(cinfo, code, p1, p2, p3) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (cinfo)->err->msg_parm.i[0] = (p1), \\\n   (cinfo)->err->msg_parm.i[1] = (p2), \\\n   (cinfo)->err->msg_parm.i[2] = (p3), \\\n   (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))\n#define ERREXIT4(cinfo, code, p1, p2, p3, p4) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (cinfo)->err->msg_parm.i[0] = (p1), \\\n   (cinfo)->err->msg_parm.i[1] = (p2), \\\n   (cinfo)->err->msg_parm.i[2] = (p3), \\\n   (cinfo)->err->msg_parm.i[3] = (p4), \\\n   (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))\n#define ERREXIT6(cinfo, code, p1, p2, p3, p4, p5, p6) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (cinfo)->err->msg_parm.i[0] = (p1), \\\n   (cinfo)->err->msg_parm.i[1] = (p2), \\\n   (cinfo)->err->msg_parm.i[2] = (p3), \\\n   (cinfo)->err->msg_parm.i[3] = (p4), \\\n   (cinfo)->err->msg_parm.i[4] = (p5), \\\n   (cinfo)->err->msg_parm.i[5] = (p6), \\\n   (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))\n#define ERREXITS(cinfo, code, str) \\\n  ((cinfo)->err->msg_code = (code), \\\n   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \\\n   (cinfo)->err->msg_parm.s[JMSG_STR_PARM_MAX - 1] = '\\0', \\\n   (*(cinfo)->err->error_exit) ((j_common_ptr)(cinfo)))\n\n#define MAKESTMT(stuff)         do { stuff } while (0)\n\n/* Nonfatal errors (we can keep going, but the data is probably corrupt) */\n#define WARNMS(cinfo, code) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), -1))\n#define WARNMS1(cinfo, code, p1) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (cinfo)->err->msg_parm.i[0] = (p1), \\\n   (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), -1))\n#define WARNMS2(cinfo, code, p1, p2) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (cinfo)->err->msg_parm.i[0] = (p1), \\\n   (cinfo)->err->msg_parm.i[1] = (p2), \\\n   (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), -1))\n\n/* Informational/debugging messages */\n#define TRACEMS(cinfo, lvl, code) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), (lvl)))\n#define TRACEMS1(cinfo, lvl, code, p1) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (cinfo)->err->msg_parm.i[0] = (p1), \\\n   (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), (lvl)))\n#define TRACEMS2(cinfo, lvl, code, p1, p2) \\\n  ((cinfo)->err->msg_code = (code), \\\n   (cinfo)->err->msg_parm.i[0] = (p1), \\\n   (cinfo)->err->msg_parm.i[1] = (p2), \\\n   (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), (lvl)))\n#define TRACEMS3(cinfo, lvl, code, p1, p2, p3) \\\n  MAKESTMT(int *_mp = (cinfo)->err->msg_parm.i; \\\n           _mp[0] = (p1);  _mp[1] = (p2);  _mp[2] = (p3); \\\n           (cinfo)->err->msg_code = (code); \\\n           (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), (lvl)); )\n#define TRACEMS4(cinfo, lvl, code, p1, p2, p3, p4) \\\n  MAKESTMT(int *_mp = (cinfo)->err->msg_parm.i; \\\n           _mp[0] = (p1);  _mp[1] = (p2);  _mp[2] = (p3);  _mp[3] = (p4); \\\n           (cinfo)->err->msg_code = (code); \\\n           (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), (lvl)); )\n#define TRACEMS5(cinfo, lvl, code, p1, p2, p3, p4, p5) \\\n  MAKESTMT(int *_mp = (cinfo)->err->msg_parm.i; \\\n           _mp[0] = (p1);  _mp[1] = (p2);  _mp[2] = (p3);  _mp[3] = (p4); \\\n           _mp[4] = (p5); \\\n           (cinfo)->err->msg_code = (code); \\\n           (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), (lvl)); )\n#define TRACEMS8(cinfo, lvl, code, p1, p2, p3, p4, p5, p6, p7, p8) \\\n  MAKESTMT(int *_mp = (cinfo)->err->msg_parm.i; \\\n           _mp[0] = (p1);  _mp[1] = (p2);  _mp[2] = (p3);  _mp[3] = (p4); \\\n           _mp[4] = (p5);  _mp[5] = (p6);  _mp[6] = (p7);  _mp[7] = (p8); \\\n           (cinfo)->err->msg_code = (code); \\\n           (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), (lvl)); )\n#define TRACEMSS(cinfo, lvl, code, str) \\\n  ((cinfo)->err->msg_code = (code), \\\n   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \\\n   (cinfo)->err->msg_parm.s[JMSG_STR_PARM_MAX - 1] = '\\0', \\\n   (*(cinfo)->err->emit_message) ((j_common_ptr)(cinfo), (lvl)))\n\n#endif /* JERROR_H */\n"
        },
        {
          "name": "jfdctflt.c",
          "type": "blob",
          "size": 5.45703125,
          "content": "/*\n * jfdctflt.c\n *\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * This file is part of the Independent JPEG Group's software.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a floating-point implementation of the\n * forward DCT (Discrete Cosine Transform).\n *\n * This implementation should be more accurate than either of the integer\n * DCT implementations.  However, it may not give the same results on all\n * machines because of differences in roundoff behavior.  Speed will depend\n * on the hardware's floating point capacity.\n *\n * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT\n * on each column.  Direct algorithms are also available, but they are\n * much more complex and seem not to be any faster when reduced to code.\n *\n * This implementation is based on Arai, Agui, and Nakajima's algorithm for\n * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in\n * Japanese, but the algorithm is described in the Pennebaker & Mitchell\n * JPEG textbook (see REFERENCES section in file README.ijg).  The following\n * code is based directly on figure 4-8 in P&M.\n * While an 8-point DCT cannot be done in less than 11 multiplies, it is\n * possible to arrange the computation so that many of the multiplies are\n * simple scalings of the final outputs.  These multiplies can then be\n * folded into the multiplications or divisions by the JPEG quantization\n * table entries.  The AA&N method leaves only 5 multiplies and 29 adds\n * to be done in the DCT itself.\n * The primary disadvantage of this method is that with a fixed-point\n * implementation, accuracy is lost due to imprecise representation of the\n * scaled quantization values.  However, that problem does not arise if\n * we use floating point arithmetic.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdct.h\"               /* Private declarations for DCT subsystem */\n\n#ifdef DCT_FLOAT_SUPPORTED\n\n\n/*\n * This module is specialized to the case DCTSIZE = 8.\n */\n\n#if DCTSIZE != 8\n  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */\n#endif\n\n\n/*\n * Perform the forward DCT on one block of samples.\n */\n\nGLOBAL(void)\njpeg_fdct_float(FAST_FLOAT *data)\n{\n  FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  FAST_FLOAT tmp10, tmp11, tmp12, tmp13;\n  FAST_FLOAT z1, z2, z3, z4, z5, z11, z13;\n  FAST_FLOAT *dataptr;\n  int ctr;\n\n  /* Pass 1: process rows. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE - 1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[0] + dataptr[7];\n    tmp7 = dataptr[0] - dataptr[7];\n    tmp1 = dataptr[1] + dataptr[6];\n    tmp6 = dataptr[1] - dataptr[6];\n    tmp2 = dataptr[2] + dataptr[5];\n    tmp5 = dataptr[2] - dataptr[5];\n    tmp3 = dataptr[3] + dataptr[4];\n    tmp4 = dataptr[3] - dataptr[4];\n\n    /* Even part */\n\n    tmp10 = tmp0 + tmp3;        /* phase 2 */\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    dataptr[0] = tmp10 + tmp11; /* phase 3 */\n    dataptr[4] = tmp10 - tmp11;\n\n    z1 = (tmp12 + tmp13) * ((FAST_FLOAT)0.707106781); /* c4 */\n    dataptr[2] = tmp13 + z1;    /* phase 5 */\n    dataptr[6] = tmp13 - z1;\n\n    /* Odd part */\n\n    tmp10 = tmp4 + tmp5;        /* phase 2 */\n    tmp11 = tmp5 + tmp6;\n    tmp12 = tmp6 + tmp7;\n\n    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n    z5 = (tmp10 - tmp12) * ((FAST_FLOAT)0.382683433); /* c6 */\n    z2 = ((FAST_FLOAT)0.541196100) * tmp10 + z5; /* c2-c6 */\n    z4 = ((FAST_FLOAT)1.306562965) * tmp12 + z5; /* c2+c6 */\n    z3 = tmp11 * ((FAST_FLOAT)0.707106781); /* c4 */\n\n    z11 = tmp7 + z3;            /* phase 5 */\n    z13 = tmp7 - z3;\n\n    dataptr[5] = z13 + z2;      /* phase 6 */\n    dataptr[3] = z13 - z2;\n    dataptr[1] = z11 + z4;\n    dataptr[7] = z11 - z4;\n\n    dataptr += DCTSIZE;         /* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE - 1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[DCTSIZE * 0] + dataptr[DCTSIZE * 7];\n    tmp7 = dataptr[DCTSIZE * 0] - dataptr[DCTSIZE * 7];\n    tmp1 = dataptr[DCTSIZE * 1] + dataptr[DCTSIZE * 6];\n    tmp6 = dataptr[DCTSIZE * 1] - dataptr[DCTSIZE * 6];\n    tmp2 = dataptr[DCTSIZE * 2] + dataptr[DCTSIZE * 5];\n    tmp5 = dataptr[DCTSIZE * 2] - dataptr[DCTSIZE * 5];\n    tmp3 = dataptr[DCTSIZE * 3] + dataptr[DCTSIZE * 4];\n    tmp4 = dataptr[DCTSIZE * 3] - dataptr[DCTSIZE * 4];\n\n    /* Even part */\n\n    tmp10 = tmp0 + tmp3;        /* phase 2 */\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    dataptr[DCTSIZE * 0] = tmp10 + tmp11; /* phase 3 */\n    dataptr[DCTSIZE * 4] = tmp10 - tmp11;\n\n    z1 = (tmp12 + tmp13) * ((FAST_FLOAT)0.707106781); /* c4 */\n    dataptr[DCTSIZE * 2] = tmp13 + z1; /* phase 5 */\n    dataptr[DCTSIZE * 6] = tmp13 - z1;\n\n    /* Odd part */\n\n    tmp10 = tmp4 + tmp5;        /* phase 2 */\n    tmp11 = tmp5 + tmp6;\n    tmp12 = tmp6 + tmp7;\n\n    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n    z5 = (tmp10 - tmp12) * ((FAST_FLOAT)0.382683433); /* c6 */\n    z2 = ((FAST_FLOAT)0.541196100) * tmp10 + z5; /* c2-c6 */\n    z4 = ((FAST_FLOAT)1.306562965) * tmp12 + z5; /* c2+c6 */\n    z3 = tmp11 * ((FAST_FLOAT)0.707106781); /* c4 */\n\n    z11 = tmp7 + z3;            /* phase 5 */\n    z13 = tmp7 - z3;\n\n    dataptr[DCTSIZE * 5] = z13 + z2; /* phase 6 */\n    dataptr[DCTSIZE * 3] = z13 - z2;\n    dataptr[DCTSIZE * 1] = z11 + z4;\n    dataptr[DCTSIZE * 7] = z11 - z4;\n\n    dataptr++;                  /* advance pointer to next column */\n  }\n}\n\n#endif /* DCT_FLOAT_SUPPORTED */\n"
        },
        {
          "name": "jfdctfst.c",
          "type": "blob",
          "size": 7.6103515625,
          "content": "/*\n * jfdctfst.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a fast, not so accurate integer implementation of the\n * forward DCT (Discrete Cosine Transform).\n *\n * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT\n * on each column.  Direct algorithms are also available, but they are\n * much more complex and seem not to be any faster when reduced to code.\n *\n * This implementation is based on Arai, Agui, and Nakajima's algorithm for\n * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in\n * Japanese, but the algorithm is described in the Pennebaker & Mitchell\n * JPEG textbook (see REFERENCES section in file README.ijg).  The following\n * code is based directly on figure 4-8 in P&M.\n * While an 8-point DCT cannot be done in less than 11 multiplies, it is\n * possible to arrange the computation so that many of the multiplies are\n * simple scalings of the final outputs.  These multiplies can then be\n * folded into the multiplications or divisions by the JPEG quantization\n * table entries.  The AA&N method leaves only 5 multiplies and 29 adds\n * to be done in the DCT itself.\n * The primary disadvantage of this method is that with fixed-point math,\n * accuracy is lost due to imprecise representation of the scaled\n * quantization values.  The smaller the quantization table entry, the less\n * precise the scaled value, so this implementation does worse with high-\n * quality-setting files than with low-quality ones.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdct.h\"               /* Private declarations for DCT subsystem */\n\n#ifdef DCT_IFAST_SUPPORTED\n\n\n/*\n * This module is specialized to the case DCTSIZE = 8.\n */\n\n#if DCTSIZE != 8\n  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */\n#endif\n\n\n/* Scaling decisions are generally the same as in the LL&M algorithm;\n * see jfdctint.c for more details.  However, we choose to descale\n * (right shift) multiplication products as soon as they are formed,\n * rather than carrying additional fractional bits into subsequent additions.\n * This compromises accuracy slightly, but it lets us save a few shifts.\n * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)\n * everywhere except in the multiplications proper; this saves a good deal\n * of work on 16-bit-int machines.\n *\n * Again to save a few shifts, the intermediate results between pass 1 and\n * pass 2 are not upscaled, but are represented only to integral precision.\n *\n * A final compromise is to represent the multiplicative constants to only\n * 8 fractional bits, rather than 13.  This saves some shifting work on some\n * machines, and may also reduce the cost of multiplication (since there\n * are fewer one-bits in the constants).\n */\n\n#define CONST_BITS  8\n\n\n/* Some C compilers fail to reduce \"FIX(constant)\" at compile time, thus\n * causing a lot of useless floating-point operations at run time.\n * To get around this we use the following pre-calculated constants.\n * If you change CONST_BITS you may want to add appropriate values.\n * (With a reasonable C compiler, you can just rely on the FIX() macro...)\n */\n\n#if CONST_BITS == 8\n#define FIX_0_382683433  ((JLONG)98)            /* FIX(0.382683433) */\n#define FIX_0_541196100  ((JLONG)139)           /* FIX(0.541196100) */\n#define FIX_0_707106781  ((JLONG)181)           /* FIX(0.707106781) */\n#define FIX_1_306562965  ((JLONG)334)           /* FIX(1.306562965) */\n#else\n#define FIX_0_382683433  FIX(0.382683433)\n#define FIX_0_541196100  FIX(0.541196100)\n#define FIX_0_707106781  FIX(0.707106781)\n#define FIX_1_306562965  FIX(1.306562965)\n#endif\n\n\n/* We can gain a little more speed, with a further compromise in accuracy,\n * by omitting the addition in a descaling shift.  This yields an incorrectly\n * rounded result half the time...\n */\n\n#ifndef USE_ACCURATE_ROUNDING\n#undef DESCALE\n#define DESCALE(x, n)  RIGHT_SHIFT(x, n)\n#endif\n\n\n/* Multiply a DCTELEM variable by an JLONG constant, and immediately\n * descale to yield a DCTELEM result.\n */\n\n#define MULTIPLY(var, const)  ((DCTELEM)DESCALE((var) * (const), CONST_BITS))\n\n\n/*\n * Perform the forward DCT on one block of samples.\n */\n\nGLOBAL(void)\n_jpeg_fdct_ifast(DCTELEM *data)\n{\n  DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  DCTELEM tmp10, tmp11, tmp12, tmp13;\n  DCTELEM z1, z2, z3, z4, z5, z11, z13;\n  DCTELEM *dataptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pass 1: process rows. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE - 1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[0] + dataptr[7];\n    tmp7 = dataptr[0] - dataptr[7];\n    tmp1 = dataptr[1] + dataptr[6];\n    tmp6 = dataptr[1] - dataptr[6];\n    tmp2 = dataptr[2] + dataptr[5];\n    tmp5 = dataptr[2] - dataptr[5];\n    tmp3 = dataptr[3] + dataptr[4];\n    tmp4 = dataptr[3] - dataptr[4];\n\n    /* Even part */\n\n    tmp10 = tmp0 + tmp3;        /* phase 2 */\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    dataptr[0] = tmp10 + tmp11; /* phase 3 */\n    dataptr[4] = tmp10 - tmp11;\n\n    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_707106781); /* c4 */\n    dataptr[2] = tmp13 + z1;    /* phase 5 */\n    dataptr[6] = tmp13 - z1;\n\n    /* Odd part */\n\n    tmp10 = tmp4 + tmp5;        /* phase 2 */\n    tmp11 = tmp5 + tmp6;\n    tmp12 = tmp6 + tmp7;\n\n    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n    z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433); /* c6 */\n    z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5; /* c2-c6 */\n    z4 = MULTIPLY(tmp12, FIX_1_306562965) + z5; /* c2+c6 */\n    z3 = MULTIPLY(tmp11, FIX_0_707106781); /* c4 */\n\n    z11 = tmp7 + z3;            /* phase 5 */\n    z13 = tmp7 - z3;\n\n    dataptr[5] = z13 + z2;      /* phase 6 */\n    dataptr[3] = z13 - z2;\n    dataptr[1] = z11 + z4;\n    dataptr[7] = z11 - z4;\n\n    dataptr += DCTSIZE;         /* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE - 1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[DCTSIZE * 0] + dataptr[DCTSIZE * 7];\n    tmp7 = dataptr[DCTSIZE * 0] - dataptr[DCTSIZE * 7];\n    tmp1 = dataptr[DCTSIZE * 1] + dataptr[DCTSIZE * 6];\n    tmp6 = dataptr[DCTSIZE * 1] - dataptr[DCTSIZE * 6];\n    tmp2 = dataptr[DCTSIZE * 2] + dataptr[DCTSIZE * 5];\n    tmp5 = dataptr[DCTSIZE * 2] - dataptr[DCTSIZE * 5];\n    tmp3 = dataptr[DCTSIZE * 3] + dataptr[DCTSIZE * 4];\n    tmp4 = dataptr[DCTSIZE * 3] - dataptr[DCTSIZE * 4];\n\n    /* Even part */\n\n    tmp10 = tmp0 + tmp3;        /* phase 2 */\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    dataptr[DCTSIZE * 0] = tmp10 + tmp11; /* phase 3 */\n    dataptr[DCTSIZE * 4] = tmp10 - tmp11;\n\n    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_707106781); /* c4 */\n    dataptr[DCTSIZE * 2] = tmp13 + z1; /* phase 5 */\n    dataptr[DCTSIZE * 6] = tmp13 - z1;\n\n    /* Odd part */\n\n    tmp10 = tmp4 + tmp5;        /* phase 2 */\n    tmp11 = tmp5 + tmp6;\n    tmp12 = tmp6 + tmp7;\n\n    /* The rotator is modified from fig 4-8 to avoid extra negations. */\n    z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433); /* c6 */\n    z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5; /* c2-c6 */\n    z4 = MULTIPLY(tmp12, FIX_1_306562965) + z5; /* c2+c6 */\n    z3 = MULTIPLY(tmp11, FIX_0_707106781); /* c4 */\n\n    z11 = tmp7 + z3;            /* phase 5 */\n    z13 = tmp7 - z3;\n\n    dataptr[DCTSIZE * 5] = z13 + z2; /* phase 6 */\n    dataptr[DCTSIZE * 3] = z13 - z2;\n    dataptr[DCTSIZE * 1] = z11 + z4;\n    dataptr[DCTSIZE * 7] = z11 - z4;\n\n    dataptr++;                  /* advance pointer to next column */\n  }\n}\n\n#endif /* DCT_IFAST_SUPPORTED */\n"
        },
        {
          "name": "jfdctint.c",
          "type": "blob",
          "size": 11.2451171875,
          "content": "/*\n * jfdctint.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015, 2020, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a slower but more accurate integer implementation of the\n * forward DCT (Discrete Cosine Transform).\n *\n * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT\n * on each column.  Direct algorithms are also available, but they are\n * much more complex and seem not to be any faster when reduced to code.\n *\n * This implementation is based on an algorithm described in\n *   C. Loeffler, A. Ligtenberg and G. Moschytz, \"Practical Fast 1-D DCT\n *   Algorithms with 11 Multiplications\", Proc. Int'l. Conf. on Acoustics,\n *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.\n * The primary algorithm described there uses 11 multiplies and 29 adds.\n * We use their alternate method with 12 multiplies and 32 adds.\n * The advantage of this method is that no data path contains more than one\n * multiplication; this allows a very simple and accurate implementation in\n * scaled fixed-point arithmetic, with a minimal number of shifts.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdct.h\"               /* Private declarations for DCT subsystem */\n\n#ifdef DCT_ISLOW_SUPPORTED\n\n\n/*\n * This module is specialized to the case DCTSIZE = 8.\n */\n\n#if DCTSIZE != 8\n  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */\n#endif\n\n\n/*\n * The poop on this scaling stuff is as follows:\n *\n * Each 1-D DCT step produces outputs which are a factor of sqrt(N)\n * larger than the true DCT outputs.  The final outputs are therefore\n * a factor of N larger than desired; since N=8 this can be cured by\n * a simple right shift at the end of the algorithm.  The advantage of\n * this arrangement is that we save two multiplications per 1-D DCT,\n * because the y0 and y4 outputs need not be divided by sqrt(N).\n * In the IJG code, this factor of 8 is removed by the quantization step\n * (in jcdctmgr.c), NOT in this module.\n *\n * We have to do addition and subtraction of the integer inputs, which\n * is no problem, and multiplication by fractional constants, which is\n * a problem to do in integer arithmetic.  We multiply all the constants\n * by CONST_SCALE and convert them to integer constants (thus retaining\n * CONST_BITS bits of precision in the constants).  After doing a\n * multiplication we have to divide the product by CONST_SCALE, with proper\n * rounding, to produce the correct output.  This division can be done\n * cheaply as a right shift of CONST_BITS bits.  We postpone shifting\n * as long as possible so that partial sums can be added together with\n * full fractional precision.\n *\n * The outputs of the first pass are scaled up by PASS1_BITS bits so that\n * they are represented to better-than-integral precision.  These outputs\n * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word\n * with the recommended scaling.  (For 12-bit sample data, the intermediate\n * array is JLONG anyway.)\n *\n * To avoid overflow of the 32-bit intermediate results in pass 2, we must\n * have BITS_IN_JSAMPLE + CONST_BITS + PASS1_BITS <= 26.  Error analysis\n * shows that the values given below are the most effective.\n */\n\n#if BITS_IN_JSAMPLE == 8\n#define CONST_BITS  13\n#define PASS1_BITS  2\n#else\n#define CONST_BITS  13\n#define PASS1_BITS  1           /* lose a little precision to avoid overflow */\n#endif\n\n/* Some C compilers fail to reduce \"FIX(constant)\" at compile time, thus\n * causing a lot of useless floating-point operations at run time.\n * To get around this we use the following pre-calculated constants.\n * If you change CONST_BITS you may want to add appropriate values.\n * (With a reasonable C compiler, you can just rely on the FIX() macro...)\n */\n\n#if CONST_BITS == 13\n#define FIX_0_298631336  ((JLONG)2446)          /* FIX(0.298631336) */\n#define FIX_0_390180644  ((JLONG)3196)          /* FIX(0.390180644) */\n#define FIX_0_541196100  ((JLONG)4433)          /* FIX(0.541196100) */\n#define FIX_0_765366865  ((JLONG)6270)          /* FIX(0.765366865) */\n#define FIX_0_899976223  ((JLONG)7373)          /* FIX(0.899976223) */\n#define FIX_1_175875602  ((JLONG)9633)          /* FIX(1.175875602) */\n#define FIX_1_501321110  ((JLONG)12299)         /* FIX(1.501321110) */\n#define FIX_1_847759065  ((JLONG)15137)         /* FIX(1.847759065) */\n#define FIX_1_961570560  ((JLONG)16069)         /* FIX(1.961570560) */\n#define FIX_2_053119869  ((JLONG)16819)         /* FIX(2.053119869) */\n#define FIX_2_562915447  ((JLONG)20995)         /* FIX(2.562915447) */\n#define FIX_3_072711026  ((JLONG)25172)         /* FIX(3.072711026) */\n#else\n#define FIX_0_298631336  FIX(0.298631336)\n#define FIX_0_390180644  FIX(0.390180644)\n#define FIX_0_541196100  FIX(0.541196100)\n#define FIX_0_765366865  FIX(0.765366865)\n#define FIX_0_899976223  FIX(0.899976223)\n#define FIX_1_175875602  FIX(1.175875602)\n#define FIX_1_501321110  FIX(1.501321110)\n#define FIX_1_847759065  FIX(1.847759065)\n#define FIX_1_961570560  FIX(1.961570560)\n#define FIX_2_053119869  FIX(2.053119869)\n#define FIX_2_562915447  FIX(2.562915447)\n#define FIX_3_072711026  FIX(3.072711026)\n#endif\n\n\n/* Multiply an JLONG variable by an JLONG constant to yield an JLONG result.\n * For 8-bit samples with the recommended scaling, all the variable\n * and constant values involved are no more than 16 bits wide, so a\n * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.\n * For 12-bit samples, a full 32-bit multiplication will be needed.\n */\n\n#if BITS_IN_JSAMPLE == 8\n#define MULTIPLY(var, const)  MULTIPLY16C16(var, const)\n#else\n#define MULTIPLY(var, const)  ((var) * (const))\n#endif\n\n\n/*\n * Perform the forward DCT on one block of samples.\n */\n\nGLOBAL(void)\n_jpeg_fdct_islow(DCTELEM *data)\n{\n  JLONG tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  JLONG tmp10, tmp11, tmp12, tmp13;\n  JLONG z1, z2, z3, z4, z5;\n  DCTELEM *dataptr;\n  int ctr;\n  SHIFT_TEMPS\n\n  /* Pass 1: process rows. */\n  /* Note results are scaled up by sqrt(8) compared to a true DCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n\n  dataptr = data;\n  for (ctr = DCTSIZE - 1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[0] + dataptr[7];\n    tmp7 = dataptr[0] - dataptr[7];\n    tmp1 = dataptr[1] + dataptr[6];\n    tmp6 = dataptr[1] - dataptr[6];\n    tmp2 = dataptr[2] + dataptr[5];\n    tmp5 = dataptr[2] - dataptr[5];\n    tmp3 = dataptr[3] + dataptr[4];\n    tmp4 = dataptr[3] - dataptr[4];\n\n    /* Even part per LL&M figure 1 --- note that published figure is faulty;\n     * rotator \"sqrt(2)*c1\" should be \"sqrt(2)*c6\".\n     */\n\n    tmp10 = tmp0 + tmp3;\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    dataptr[0] = (DCTELEM)LEFT_SHIFT(tmp10 + tmp11, PASS1_BITS);\n    dataptr[4] = (DCTELEM)LEFT_SHIFT(tmp10 - tmp11, PASS1_BITS);\n\n    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n    dataptr[2] = (DCTELEM)DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),\n                                  CONST_BITS - PASS1_BITS);\n    dataptr[6] = (DCTELEM)DESCALE(z1 + MULTIPLY(tmp12, -FIX_1_847759065),\n                                  CONST_BITS - PASS1_BITS);\n\n    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).\n     * cK represents cos(K*pi/16).\n     * i0..i3 in the paper are tmp4..tmp7 here.\n     */\n\n    z1 = tmp4 + tmp7;\n    z2 = tmp5 + tmp6;\n    z3 = tmp4 + tmp6;\n    z4 = tmp5 + tmp7;\n    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */\n\n    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */\n    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */\n    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */\n    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */\n    z1 = MULTIPLY(z1, -FIX_0_899976223); /* sqrt(2) * ( c7-c3) */\n    z2 = MULTIPLY(z2, -FIX_2_562915447); /* sqrt(2) * (-c1-c3) */\n    z3 = MULTIPLY(z3, -FIX_1_961570560); /* sqrt(2) * (-c3-c5) */\n    z4 = MULTIPLY(z4, -FIX_0_390180644); /* sqrt(2) * ( c5-c3) */\n\n    z3 += z5;\n    z4 += z5;\n\n    dataptr[7] = (DCTELEM)DESCALE(tmp4 + z1 + z3, CONST_BITS - PASS1_BITS);\n    dataptr[5] = (DCTELEM)DESCALE(tmp5 + z2 + z4, CONST_BITS - PASS1_BITS);\n    dataptr[3] = (DCTELEM)DESCALE(tmp6 + z2 + z3, CONST_BITS - PASS1_BITS);\n    dataptr[1] = (DCTELEM)DESCALE(tmp7 + z1 + z4, CONST_BITS - PASS1_BITS);\n\n    dataptr += DCTSIZE;         /* advance pointer to next row */\n  }\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   */\n\n  dataptr = data;\n  for (ctr = DCTSIZE - 1; ctr >= 0; ctr--) {\n    tmp0 = dataptr[DCTSIZE * 0] + dataptr[DCTSIZE * 7];\n    tmp7 = dataptr[DCTSIZE * 0] - dataptr[DCTSIZE * 7];\n    tmp1 = dataptr[DCTSIZE * 1] + dataptr[DCTSIZE * 6];\n    tmp6 = dataptr[DCTSIZE * 1] - dataptr[DCTSIZE * 6];\n    tmp2 = dataptr[DCTSIZE * 2] + dataptr[DCTSIZE * 5];\n    tmp5 = dataptr[DCTSIZE * 2] - dataptr[DCTSIZE * 5];\n    tmp3 = dataptr[DCTSIZE * 3] + dataptr[DCTSIZE * 4];\n    tmp4 = dataptr[DCTSIZE * 3] - dataptr[DCTSIZE * 4];\n\n    /* Even part per LL&M figure 1 --- note that published figure is faulty;\n     * rotator \"sqrt(2)*c1\" should be \"sqrt(2)*c6\".\n     */\n\n    tmp10 = tmp0 + tmp3;\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    dataptr[DCTSIZE * 0] = (DCTELEM)DESCALE(tmp10 + tmp11, PASS1_BITS);\n    dataptr[DCTSIZE * 4] = (DCTELEM)DESCALE(tmp10 - tmp11, PASS1_BITS);\n\n    z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n    dataptr[DCTSIZE * 2] =\n      (DCTELEM)DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),\n                       CONST_BITS + PASS1_BITS);\n    dataptr[DCTSIZE * 6] =\n      (DCTELEM)DESCALE(z1 + MULTIPLY(tmp12, -FIX_1_847759065),\n                       CONST_BITS + PASS1_BITS);\n\n    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).\n     * cK represents cos(K*pi/16).\n     * i0..i3 in the paper are tmp4..tmp7 here.\n     */\n\n    z1 = tmp4 + tmp7;\n    z2 = tmp5 + tmp6;\n    z3 = tmp4 + tmp6;\n    z4 = tmp5 + tmp7;\n    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */\n\n    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */\n    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */\n    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */\n    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */\n    z1 = MULTIPLY(z1, -FIX_0_899976223); /* sqrt(2) * ( c7-c3) */\n    z2 = MULTIPLY(z2, -FIX_2_562915447); /* sqrt(2) * (-c1-c3) */\n    z3 = MULTIPLY(z3, -FIX_1_961570560); /* sqrt(2) * (-c3-c5) */\n    z4 = MULTIPLY(z4, -FIX_0_390180644); /* sqrt(2) * ( c5-c3) */\n\n    z3 += z5;\n    z4 += z5;\n\n    dataptr[DCTSIZE * 7] = (DCTELEM)DESCALE(tmp4 + z1 + z3,\n                                            CONST_BITS + PASS1_BITS);\n    dataptr[DCTSIZE * 5] = (DCTELEM)DESCALE(tmp5 + z2 + z4,\n                                            CONST_BITS + PASS1_BITS);\n    dataptr[DCTSIZE * 3] = (DCTELEM)DESCALE(tmp6 + z2 + z3,\n                                            CONST_BITS + PASS1_BITS);\n    dataptr[DCTSIZE * 1] = (DCTELEM)DESCALE(tmp7 + z1 + z4,\n                                            CONST_BITS + PASS1_BITS);\n\n    dataptr++;                  /* advance pointer to next column */\n  }\n}\n\n#endif /* DCT_ISLOW_SUPPORTED */\n"
        },
        {
          "name": "jidctflt.c",
          "type": "blob",
          "size": 8.548828125,
          "content": "/*\n * jidctflt.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1998, Thomas G. Lane.\n * Modified 2010 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2014, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a floating-point implementation of the\n * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine\n * must also perform dequantization of the input coefficients.\n *\n * This implementation should be more accurate than either of the integer\n * IDCT implementations.  However, it may not give the same results on all\n * machines because of differences in roundoff behavior.  Speed will depend\n * on the hardware's floating point capacity.\n *\n * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT\n * on each row (or vice versa, but it's more convenient to emit a row at\n * a time).  Direct algorithms are also available, but they are much more\n * complex and seem not to be any faster when reduced to code.\n *\n * This implementation is based on Arai, Agui, and Nakajima's algorithm for\n * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in\n * Japanese, but the algorithm is described in the Pennebaker & Mitchell\n * JPEG textbook (see REFERENCES section in file README.ijg).  The following\n * code is based directly on figure 4-8 in P&M.\n * While an 8-point DCT cannot be done in less than 11 multiplies, it is\n * possible to arrange the computation so that many of the multiplies are\n * simple scalings of the final outputs.  These multiplies can then be\n * folded into the multiplications or divisions by the JPEG quantization\n * table entries.  The AA&N method leaves only 5 multiplies and 29 adds\n * to be done in the DCT itself.\n * The primary disadvantage of this method is that with a fixed-point\n * implementation, accuracy is lost due to imprecise representation of the\n * scaled quantization values.  However, that problem does not arise if\n * we use floating point arithmetic.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdct.h\"               /* Private declarations for DCT subsystem */\n\n#ifdef DCT_FLOAT_SUPPORTED\n\n\n/*\n * This module is specialized to the case DCTSIZE = 8.\n */\n\n#if DCTSIZE != 8\n  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */\n#endif\n\n\n/* Dequantize a coefficient by multiplying it by the multiplier-table\n * entry; produce a float result.\n */\n\n#define DEQUANTIZE(coef, quantval)  (((FAST_FLOAT)(coef)) * (quantval))\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients.\n */\n\nGLOBAL(void)\n_jpeg_idct_float(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                 JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                 JDIMENSION output_col)\n{\n  FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  FAST_FLOAT tmp10, tmp11, tmp12, tmp13;\n  FAST_FLOAT z5, z10, z11, z12, z13;\n  JCOEFPTR inptr;\n  FLOAT_MULT_TYPE *quantptr;\n  FAST_FLOAT *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  int ctr;\n  FAST_FLOAT workspace[DCTSIZE2]; /* buffers data between passes */\n#define _0_125  ((FLOAT_MULT_TYPE)0.125)\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (FLOAT_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\n    /* Due to quantization, we will usually find that many of the input\n     * coefficients are zero, especially the AC terms.  We can exploit this\n     * by short-circuiting the IDCT calculation for any column in which all\n     * the AC terms are zero.  In that case each output is equal to the\n     * DC coefficient (with scale factor as needed).\n     * With typical images and quantization tables, half or more of the\n     * column DCT calculations can be simplified this way.\n     */\n\n    if (inptr[DCTSIZE * 1] == 0 && inptr[DCTSIZE * 2] == 0 &&\n        inptr[DCTSIZE * 3] == 0 && inptr[DCTSIZE * 4] == 0 &&\n        inptr[DCTSIZE * 5] == 0 && inptr[DCTSIZE * 6] == 0 &&\n        inptr[DCTSIZE * 7] == 0) {\n      /* AC terms all zero */\n      FAST_FLOAT dcval = DEQUANTIZE(inptr[DCTSIZE * 0],\n                                    quantptr[DCTSIZE * 0] * _0_125);\n\n      wsptr[DCTSIZE * 0] = dcval;\n      wsptr[DCTSIZE * 1] = dcval;\n      wsptr[DCTSIZE * 2] = dcval;\n      wsptr[DCTSIZE * 3] = dcval;\n      wsptr[DCTSIZE * 4] = dcval;\n      wsptr[DCTSIZE * 5] = dcval;\n      wsptr[DCTSIZE * 6] = dcval;\n      wsptr[DCTSIZE * 7] = dcval;\n\n      inptr++;                  /* advance pointers to next column */\n      quantptr++;\n      wsptr++;\n      continue;\n    }\n\n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0] * _0_125);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2] * _0_125);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4] * _0_125);\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6] * _0_125);\n\n    tmp10 = tmp0 + tmp2;        /* phase 3 */\n    tmp11 = tmp0 - tmp2;\n\n    tmp13 = tmp1 + tmp3;        /* phases 5-3 */\n    tmp12 = (tmp1 - tmp3) * ((FAST_FLOAT)1.414213562) - tmp13; /* 2*c4 */\n\n    tmp0 = tmp10 + tmp13;       /* phase 2 */\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    tmp4 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1] * _0_125);\n    tmp5 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3] * _0_125);\n    tmp6 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5] * _0_125);\n    tmp7 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7] * _0_125);\n\n    z13 = tmp6 + tmp5;          /* phase 6 */\n    z10 = tmp6 - tmp5;\n    z11 = tmp4 + tmp7;\n    z12 = tmp4 - tmp7;\n\n    tmp7 = z11 + z13;           /* phase 5 */\n    tmp11 = (z11 - z13) * ((FAST_FLOAT)1.414213562); /* 2*c4 */\n\n    z5 = (z10 + z12) * ((FAST_FLOAT)1.847759065); /* 2*c2 */\n    tmp10 = z5 - z12 * ((FAST_FLOAT)1.082392200); /* 2*(c2-c6) */\n    tmp12 = z5 - z10 * ((FAST_FLOAT)2.613125930); /* 2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;        /* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 - tmp5;\n\n    wsptr[DCTSIZE * 0] = tmp0 + tmp7;\n    wsptr[DCTSIZE * 7] = tmp0 - tmp7;\n    wsptr[DCTSIZE * 1] = tmp1 + tmp6;\n    wsptr[DCTSIZE * 6] = tmp1 - tmp6;\n    wsptr[DCTSIZE * 2] = tmp2 + tmp5;\n    wsptr[DCTSIZE * 5] = tmp2 - tmp5;\n    wsptr[DCTSIZE * 3] = tmp3 + tmp4;\n    wsptr[DCTSIZE * 4] = tmp3 - tmp4;\n\n    inptr++;                    /* advance pointers to next column */\n    quantptr++;\n    wsptr++;\n  }\n\n  /* Pass 2: process rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\n     * However, the column calculation has created many nonzero AC terms, so\n     * the simplification applies less often (typically 5% to 10% of the time).\n     * And testing floats for zero is relatively expensive, so we don't bother.\n     */\n\n    /* Even part */\n\n    /* Apply signed->unsigned and prepare float->int conversion */\n    z5 = wsptr[0] + ((FAST_FLOAT)_CENTERJSAMPLE + (FAST_FLOAT)0.5);\n    tmp10 = z5 + wsptr[4];\n    tmp11 = z5 - wsptr[4];\n\n    tmp13 = wsptr[2] + wsptr[6];\n    tmp12 = (wsptr[2] - wsptr[6]) * ((FAST_FLOAT)1.414213562) - tmp13;\n\n    tmp0 = tmp10 + tmp13;\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z13 = wsptr[5] + wsptr[3];\n    z10 = wsptr[5] - wsptr[3];\n    z11 = wsptr[1] + wsptr[7];\n    z12 = wsptr[1] - wsptr[7];\n\n    tmp7 = z11 + z13;\n    tmp11 = (z11 - z13) * ((FAST_FLOAT)1.414213562);\n\n    z5 = (z10 + z12) * ((FAST_FLOAT)1.847759065); /* 2*c2 */\n    tmp10 = z5 - z12 * ((FAST_FLOAT)1.082392200); /* 2*(c2-c6) */\n    tmp12 = z5 - z10 * ((FAST_FLOAT)2.613125930); /* 2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 - tmp5;\n\n    /* Final output stage: float->int conversion and range-limit */\n\n    outptr[0] = range_limit[((int)(tmp0 + tmp7)) & RANGE_MASK];\n    outptr[7] = range_limit[((int)(tmp0 - tmp7)) & RANGE_MASK];\n    outptr[1] = range_limit[((int)(tmp1 + tmp6)) & RANGE_MASK];\n    outptr[6] = range_limit[((int)(tmp1 - tmp6)) & RANGE_MASK];\n    outptr[2] = range_limit[((int)(tmp2 + tmp5)) & RANGE_MASK];\n    outptr[5] = range_limit[((int)(tmp2 - tmp5)) & RANGE_MASK];\n    outptr[3] = range_limit[((int)(tmp3 + tmp4)) & RANGE_MASK];\n    outptr[4] = range_limit[((int)(tmp3 - tmp4)) & RANGE_MASK];\n\n    wsptr += DCTSIZE;           /* advance pointer to next row */\n  }\n}\n\n#endif /* DCT_FLOAT_SUPPORTED */\n"
        },
        {
          "name": "jidctfst.c",
          "type": "blob",
          "size": 13.2470703125,
          "content": "/*\n * jidctfst.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1998, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a fast, not so accurate integer implementation of the\n * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine\n * must also perform dequantization of the input coefficients.\n *\n * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT\n * on each row (or vice versa, but it's more convenient to emit a row at\n * a time).  Direct algorithms are also available, but they are much more\n * complex and seem not to be any faster when reduced to code.\n *\n * This implementation is based on Arai, Agui, and Nakajima's algorithm for\n * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in\n * Japanese, but the algorithm is described in the Pennebaker & Mitchell\n * JPEG textbook (see REFERENCES section in file README.ijg).  The following\n * code is based directly on figure 4-8 in P&M.\n * While an 8-point DCT cannot be done in less than 11 multiplies, it is\n * possible to arrange the computation so that many of the multiplies are\n * simple scalings of the final outputs.  These multiplies can then be\n * folded into the multiplications or divisions by the JPEG quantization\n * table entries.  The AA&N method leaves only 5 multiplies and 29 adds\n * to be done in the DCT itself.\n * The primary disadvantage of this method is that with fixed-point math,\n * accuracy is lost due to imprecise representation of the scaled\n * quantization values.  The smaller the quantization table entry, the less\n * precise the scaled value, so this implementation does worse with high-\n * quality-setting files than with low-quality ones.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdct.h\"               /* Private declarations for DCT subsystem */\n\n#ifdef DCT_IFAST_SUPPORTED\n\n\n/*\n * This module is specialized to the case DCTSIZE = 8.\n */\n\n#if DCTSIZE != 8\n  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */\n#endif\n\n\n/* Scaling decisions are generally the same as in the LL&M algorithm;\n * see jidctint.c for more details.  However, we choose to descale\n * (right shift) multiplication products as soon as they are formed,\n * rather than carrying additional fractional bits into subsequent additions.\n * This compromises accuracy slightly, but it lets us save a few shifts.\n * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)\n * everywhere except in the multiplications proper; this saves a good deal\n * of work on 16-bit-int machines.\n *\n * The dequantized coefficients are not integers because the AA&N scaling\n * factors have been incorporated.  We represent them scaled up by PASS1_BITS,\n * so that the first and second IDCT rounds have the same input scaling.\n * For 8-bit samples, we choose IFAST_SCALE_BITS = PASS1_BITS so as to\n * avoid a descaling shift; this compromises accuracy rather drastically\n * for small quantization table entries, but it saves a lot of shifts.\n * For 12-bit samples, there's no hope of using 16x16 multiplies anyway,\n * so we use a much larger scaling factor to preserve accuracy.\n *\n * A final compromise is to represent the multiplicative constants to only\n * 8 fractional bits, rather than 13.  This saves some shifting work on some\n * machines, and may also reduce the cost of multiplication (since there\n * are fewer one-bits in the constants).\n */\n\n#if BITS_IN_JSAMPLE == 8\n#define CONST_BITS  8\n#define PASS1_BITS  2\n#else\n#define CONST_BITS  8\n#define PASS1_BITS  1           /* lose a little precision to avoid overflow */\n#endif\n\n/* Some C compilers fail to reduce \"FIX(constant)\" at compile time, thus\n * causing a lot of useless floating-point operations at run time.\n * To get around this we use the following pre-calculated constants.\n * If you change CONST_BITS you may want to add appropriate values.\n * (With a reasonable C compiler, you can just rely on the FIX() macro...)\n */\n\n#if CONST_BITS == 8\n#define FIX_1_082392200  ((JLONG)277)           /* FIX(1.082392200) */\n#define FIX_1_414213562  ((JLONG)362)           /* FIX(1.414213562) */\n#define FIX_1_847759065  ((JLONG)473)           /* FIX(1.847759065) */\n#define FIX_2_613125930  ((JLONG)669)           /* FIX(2.613125930) */\n#else\n#define FIX_1_082392200  FIX(1.082392200)\n#define FIX_1_414213562  FIX(1.414213562)\n#define FIX_1_847759065  FIX(1.847759065)\n#define FIX_2_613125930  FIX(2.613125930)\n#endif\n\n\n/* We can gain a little more speed, with a further compromise in accuracy,\n * by omitting the addition in a descaling shift.  This yields an incorrectly\n * rounded result half the time...\n */\n\n#ifndef USE_ACCURATE_ROUNDING\n#undef DESCALE\n#define DESCALE(x, n)  RIGHT_SHIFT(x, n)\n#endif\n\n\n/* Multiply a DCTELEM variable by an JLONG constant, and immediately\n * descale to yield a DCTELEM result.\n */\n\n#define MULTIPLY(var, const)  ((DCTELEM)DESCALE((var) * (const), CONST_BITS))\n\n\n/* Dequantize a coefficient by multiplying it by the multiplier-table\n * entry; produce a DCTELEM result.  For 8-bit data a 16x16->16\n * multiplication will do.  For 12-bit data, the multiplier table is\n * declared JLONG, so a 32-bit multiply will be used.\n */\n\n#if BITS_IN_JSAMPLE == 8\n#define DEQUANTIZE(coef, quantval)  (((IFAST_MULT_TYPE)(coef)) * (quantval))\n#else\n#define DEQUANTIZE(coef, quantval) \\\n  DESCALE((coef) * (quantval), IFAST_SCALE_BITS - PASS1_BITS)\n#endif\n\n\n/* Like DESCALE, but applies to a DCTELEM and produces an int.\n * We assume that int right shift is unsigned if JLONG right shift is.\n */\n\n#ifdef RIGHT_SHIFT_IS_UNSIGNED\n#define ISHIFT_TEMPS    DCTELEM ishift_temp;\n#if BITS_IN_JSAMPLE == 8\n#define DCTELEMBITS  16         /* DCTELEM may be 16 or 32 bits */\n#else\n#define DCTELEMBITS  32         /* DCTELEM must be 32 bits */\n#endif\n#define IRIGHT_SHIFT(x, shft) \\\n  ((ishift_temp = (x)) < 0 ? \\\n   (ishift_temp >> (shft)) | ((~((DCTELEM)0)) << (DCTELEMBITS - (shft))) : \\\n   (ishift_temp >> (shft)))\n#else\n#define ISHIFT_TEMPS\n#define IRIGHT_SHIFT(x, shft)   ((x) >> (shft))\n#endif\n\n#ifdef USE_ACCURATE_ROUNDING\n#define IDESCALE(x, n)  ((int)IRIGHT_SHIFT((x) + (1 << ((n) - 1)), n))\n#else\n#define IDESCALE(x, n)  ((int)IRIGHT_SHIFT(x, n))\n#endif\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients.\n */\n\nGLOBAL(void)\n_jpeg_idct_ifast(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                 JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                 JDIMENSION output_col)\n{\n  DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  DCTELEM tmp10, tmp11, tmp12, tmp13;\n  DCTELEM z5, z10, z11, z12, z13;\n  JCOEFPTR inptr;\n  IFAST_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE2];      /* buffers data between passes */\n  SHIFT_TEMPS                   /* for DESCALE */\n  ISHIFT_TEMPS                  /* for IDESCALE */\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (IFAST_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\n    /* Due to quantization, we will usually find that many of the input\n     * coefficients are zero, especially the AC terms.  We can exploit this\n     * by short-circuiting the IDCT calculation for any column in which all\n     * the AC terms are zero.  In that case each output is equal to the\n     * DC coefficient (with scale factor as needed).\n     * With typical images and quantization tables, half or more of the\n     * column DCT calculations can be simplified this way.\n     */\n\n    if (inptr[DCTSIZE * 1] == 0 && inptr[DCTSIZE * 2] == 0 &&\n        inptr[DCTSIZE * 3] == 0 && inptr[DCTSIZE * 4] == 0 &&\n        inptr[DCTSIZE * 5] == 0 && inptr[DCTSIZE * 6] == 0 &&\n        inptr[DCTSIZE * 7] == 0) {\n      /* AC terms all zero */\n      int dcval = (int)DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n\n      wsptr[DCTSIZE * 0] = dcval;\n      wsptr[DCTSIZE * 1] = dcval;\n      wsptr[DCTSIZE * 2] = dcval;\n      wsptr[DCTSIZE * 3] = dcval;\n      wsptr[DCTSIZE * 4] = dcval;\n      wsptr[DCTSIZE * 5] = dcval;\n      wsptr[DCTSIZE * 6] = dcval;\n      wsptr[DCTSIZE * 7] = dcval;\n\n      inptr++;                  /* advance pointers to next column */\n      quantptr++;\n      wsptr++;\n      continue;\n    }\n\n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp10 = tmp0 + tmp2;        /* phase 3 */\n    tmp11 = tmp0 - tmp2;\n\n    tmp13 = tmp1 + tmp3;        /* phases 5-3 */\n    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */\n\n    tmp0 = tmp10 + tmp13;       /* phase 2 */\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    tmp4 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    tmp5 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    tmp6 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    tmp7 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    z13 = tmp6 + tmp5;          /* phase 6 */\n    z10 = tmp6 - tmp5;\n    z11 = tmp4 + tmp7;\n    z12 = tmp4 - tmp7;\n\n    tmp7 = z11 + z13;           /* phase 5 */\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\n\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\n    tmp12 = MULTIPLY(z10, -FIX_2_613125930) + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;        /* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    wsptr[DCTSIZE * 0] = (int)(tmp0 + tmp7);\n    wsptr[DCTSIZE * 7] = (int)(tmp0 - tmp7);\n    wsptr[DCTSIZE * 1] = (int)(tmp1 + tmp6);\n    wsptr[DCTSIZE * 6] = (int)(tmp1 - tmp6);\n    wsptr[DCTSIZE * 2] = (int)(tmp2 + tmp5);\n    wsptr[DCTSIZE * 5] = (int)(tmp2 - tmp5);\n    wsptr[DCTSIZE * 4] = (int)(tmp3 + tmp4);\n    wsptr[DCTSIZE * 3] = (int)(tmp3 - tmp4);\n\n    inptr++;                    /* advance pointers to next column */\n    quantptr++;\n    wsptr++;\n  }\n\n  /* Pass 2: process rows from work array, store into output array. */\n  /* Note that we must descale the results by a factor of 8 == 2**3, */\n  /* and also undo the PASS1_BITS scaling. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\n     * However, the column calculation has created many nonzero AC terms, so\n     * the simplification applies less often (typically 5% to 10% of the time).\n     * On machines with very fast multiplication, it's possible that the\n     * test takes more time than it's worth.  In that case this section\n     * may be commented out.\n     */\n\n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\n        wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      _JSAMPLE dcval =\n        range_limit[IDESCALE(wsptr[0], PASS1_BITS + 3) & RANGE_MASK];\n\n      outptr[0] = dcval;\n      outptr[1] = dcval;\n      outptr[2] = dcval;\n      outptr[3] = dcval;\n      outptr[4] = dcval;\n      outptr[5] = dcval;\n      outptr[6] = dcval;\n      outptr[7] = dcval;\n\n      wsptr += DCTSIZE;         /* advance pointer to next row */\n      continue;\n    }\n#endif\n\n    /* Even part */\n\n    tmp10 = ((DCTELEM)wsptr[0] + (DCTELEM)wsptr[4]);\n    tmp11 = ((DCTELEM)wsptr[0] - (DCTELEM)wsptr[4]);\n\n    tmp13 = ((DCTELEM)wsptr[2] + (DCTELEM)wsptr[6]);\n    tmp12 =\n      MULTIPLY((DCTELEM)wsptr[2] - (DCTELEM)wsptr[6], FIX_1_414213562) - tmp13;\n\n    tmp0 = tmp10 + tmp13;\n    tmp3 = tmp10 - tmp13;\n    tmp1 = tmp11 + tmp12;\n    tmp2 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z13 = (DCTELEM)wsptr[5] + (DCTELEM)wsptr[3];\n    z10 = (DCTELEM)wsptr[5] - (DCTELEM)wsptr[3];\n    z11 = (DCTELEM)wsptr[1] + (DCTELEM)wsptr[7];\n    z12 = (DCTELEM)wsptr[1] - (DCTELEM)wsptr[7];\n\n    tmp7 = z11 + z13;           /* phase 5 */\n    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */\n\n    z5 = MULTIPLY(z10 + z12, FIX_1_847759065); /* 2*c2 */\n    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */\n    tmp12 = MULTIPLY(z10, -FIX_2_613125930) + z5; /* -2*(c2+c6) */\n\n    tmp6 = tmp12 - tmp7;        /* phase 2 */\n    tmp5 = tmp11 - tmp6;\n    tmp4 = tmp10 + tmp5;\n\n    /* Final output stage: scale down by a factor of 8 and range-limit */\n\n    outptr[0] =\n      range_limit[IDESCALE(tmp0 + tmp7, PASS1_BITS + 3) & RANGE_MASK];\n    outptr[7] =\n      range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS + 3) & RANGE_MASK];\n    outptr[1] =\n      range_limit[IDESCALE(tmp1 + tmp6, PASS1_BITS + 3) & RANGE_MASK];\n    outptr[6] =\n      range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS + 3) & RANGE_MASK];\n    outptr[2] =\n      range_limit[IDESCALE(tmp2 + tmp5, PASS1_BITS + 3) & RANGE_MASK];\n    outptr[5] =\n      range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS + 3) & RANGE_MASK];\n    outptr[4] =\n      range_limit[IDESCALE(tmp3 + tmp4, PASS1_BITS + 3) & RANGE_MASK];\n    outptr[3] =\n      range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS + 3) & RANGE_MASK];\n\n    wsptr += DCTSIZE;           /* advance pointer to next row */\n  }\n}\n\n#endif /* DCT_IFAST_SUPPORTED */\n"
        },
        {
          "name": "jidctint.c",
          "type": "blob",
          "size": 103.84765625,
          "content": "/*\n * jidctint.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1998, Thomas G. Lane.\n * Modification developed 2002-2018 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015, 2020, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a slower but more accurate integer implementation of the\n * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine\n * must also perform dequantization of the input coefficients.\n *\n * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT\n * on each row (or vice versa, but it's more convenient to emit a row at\n * a time).  Direct algorithms are also available, but they are much more\n * complex and seem not to be any faster when reduced to code.\n *\n * This implementation is based on an algorithm described in\n *   C. Loeffler, A. Ligtenberg and G. Moschytz, \"Practical Fast 1-D DCT\n *   Algorithms with 11 Multiplications\", Proc. Int'l. Conf. on Acoustics,\n *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.\n * The primary algorithm described there uses 11 multiplies and 29 adds.\n * We use their alternate method with 12 multiplies and 32 adds.\n * The advantage of this method is that no data path contains more than one\n * multiplication; this allows a very simple and accurate implementation in\n * scaled fixed-point arithmetic, with a minimal number of shifts.\n *\n * We also provide IDCT routines with various output sample block sizes for\n * direct resolution reduction or enlargement without additional resampling:\n * NxN (N=1...16) pixels for one 8x8 input DCT block.\n *\n * For N<8 we simply take the corresponding low-frequency coefficients of\n * the 8x8 input DCT block and apply an NxN point IDCT on the sub-block\n * to yield the downscaled outputs.\n * This can be seen as direct low-pass downsampling from the DCT domain\n * point of view rather than the usual spatial domain point of view,\n * yielding significant computational savings and results at least\n * as good as common bilinear (averaging) spatial downsampling.\n *\n * For N>8 we apply a partial NxN IDCT on the 8 input coefficients as\n * lower frequencies and higher frequencies assumed to be zero.\n * It turns out that the computational effort is similar to the 8x8 IDCT\n * regarding the output size.\n * Furthermore, the scaling and descaling is the same for all IDCT sizes.\n *\n * CAUTION: We rely on the FIX() macro except for the N=1,2,4,8 cases\n * since there would be too many additional constants to pre-calculate.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdct.h\"               /* Private declarations for DCT subsystem */\n\n#ifdef DCT_ISLOW_SUPPORTED\n\n\n/*\n * This module is specialized to the case DCTSIZE = 8.\n */\n\n#if DCTSIZE != 8\n  Sorry, this code only copes with 8x8 DCT blocks. /* deliberate syntax err */\n#endif\n\n\n/*\n * The poop on this scaling stuff is as follows:\n *\n * Each 1-D IDCT step produces outputs which are a factor of sqrt(N)\n * larger than the true IDCT outputs.  The final outputs are therefore\n * a factor of N larger than desired; since N=8 this can be cured by\n * a simple right shift at the end of the algorithm.  The advantage of\n * this arrangement is that we save two multiplications per 1-D IDCT,\n * because the y0 and y4 inputs need not be divided by sqrt(N).\n *\n * We have to do addition and subtraction of the integer inputs, which\n * is no problem, and multiplication by fractional constants, which is\n * a problem to do in integer arithmetic.  We multiply all the constants\n * by CONST_SCALE and convert them to integer constants (thus retaining\n * CONST_BITS bits of precision in the constants).  After doing a\n * multiplication we have to divide the product by CONST_SCALE, with proper\n * rounding, to produce the correct output.  This division can be done\n * cheaply as a right shift of CONST_BITS bits.  We postpone shifting\n * as long as possible so that partial sums can be added together with\n * full fractional precision.\n *\n * The outputs of the first pass are scaled up by PASS1_BITS bits so that\n * they are represented to better-than-integral precision.  These outputs\n * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word\n * with the recommended scaling.  (To scale up 12-bit sample data further, an\n * intermediate JLONG array would be needed.)\n *\n * To avoid overflow of the 32-bit intermediate results in pass 2, we must\n * have BITS_IN_JSAMPLE + CONST_BITS + PASS1_BITS <= 26.  Error analysis\n * shows that the values given below are the most effective.\n */\n\n#if BITS_IN_JSAMPLE == 8\n#define CONST_BITS  13\n#define PASS1_BITS  2\n#else\n#define CONST_BITS  13\n#define PASS1_BITS  1           /* lose a little precision to avoid overflow */\n#endif\n\n/* Some C compilers fail to reduce \"FIX(constant)\" at compile time, thus\n * causing a lot of useless floating-point operations at run time.\n * To get around this we use the following pre-calculated constants.\n * If you change CONST_BITS you may want to add appropriate values.\n * (With a reasonable C compiler, you can just rely on the FIX() macro...)\n */\n\n#if CONST_BITS == 13\n#define FIX_0_298631336  ((JLONG)2446)          /* FIX(0.298631336) */\n#define FIX_0_390180644  ((JLONG)3196)          /* FIX(0.390180644) */\n#define FIX_0_541196100  ((JLONG)4433)          /* FIX(0.541196100) */\n#define FIX_0_765366865  ((JLONG)6270)          /* FIX(0.765366865) */\n#define FIX_0_899976223  ((JLONG)7373)          /* FIX(0.899976223) */\n#define FIX_1_175875602  ((JLONG)9633)          /* FIX(1.175875602) */\n#define FIX_1_501321110  ((JLONG)12299)         /* FIX(1.501321110) */\n#define FIX_1_847759065  ((JLONG)15137)         /* FIX(1.847759065) */\n#define FIX_1_961570560  ((JLONG)16069)         /* FIX(1.961570560) */\n#define FIX_2_053119869  ((JLONG)16819)         /* FIX(2.053119869) */\n#define FIX_2_562915447  ((JLONG)20995)         /* FIX(2.562915447) */\n#define FIX_3_072711026  ((JLONG)25172)         /* FIX(3.072711026) */\n#else\n#define FIX_0_298631336  FIX(0.298631336)\n#define FIX_0_390180644  FIX(0.390180644)\n#define FIX_0_541196100  FIX(0.541196100)\n#define FIX_0_765366865  FIX(0.765366865)\n#define FIX_0_899976223  FIX(0.899976223)\n#define FIX_1_175875602  FIX(1.175875602)\n#define FIX_1_501321110  FIX(1.501321110)\n#define FIX_1_847759065  FIX(1.847759065)\n#define FIX_1_961570560  FIX(1.961570560)\n#define FIX_2_053119869  FIX(2.053119869)\n#define FIX_2_562915447  FIX(2.562915447)\n#define FIX_3_072711026  FIX(3.072711026)\n#endif\n\n\n/* Multiply an JLONG variable by an JLONG constant to yield an JLONG result.\n * For 8-bit samples with the recommended scaling, all the variable\n * and constant values involved are no more than 16 bits wide, so a\n * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.\n * For 12-bit samples, a full 32-bit multiplication will be needed.\n */\n\n#if BITS_IN_JSAMPLE == 8\n#define MULTIPLY(var, const)  MULTIPLY16C16(var, const)\n#else\n#define MULTIPLY(var, const)  ((var) * (const))\n#endif\n\n\n/* Dequantize a coefficient by multiplying it by the multiplier-table\n * entry; produce an int result.  In this module, both inputs and result\n * are 16 bits or less, so either int or short multiply will work.\n */\n\n#define DEQUANTIZE(coef, quantval)  (((ISLOW_MULT_TYPE)(coef)) * (quantval))\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients.\n */\n\nGLOBAL(void)\n_jpeg_idct_islow(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                 JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                 JDIMENSION output_col)\n{\n  JLONG tmp0, tmp1, tmp2, tmp3;\n  JLONG tmp10, tmp11, tmp12, tmp13;\n  JLONG z1, z2, z3, z4, z5;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE2];      /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n  /* Note results are scaled up by sqrt(8) compared to a true IDCT; */\n  /* furthermore, we scale the results by 2**PASS1_BITS. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; ctr--) {\n    /* Due to quantization, we will usually find that many of the input\n     * coefficients are zero, especially the AC terms.  We can exploit this\n     * by short-circuiting the IDCT calculation for any column in which all\n     * the AC terms are zero.  In that case each output is equal to the\n     * DC coefficient (with scale factor as needed).\n     * With typical images and quantization tables, half or more of the\n     * column DCT calculations can be simplified this way.\n     */\n\n    if (inptr[DCTSIZE * 1] == 0 && inptr[DCTSIZE * 2] == 0 &&\n        inptr[DCTSIZE * 3] == 0 && inptr[DCTSIZE * 4] == 0 &&\n        inptr[DCTSIZE * 5] == 0 && inptr[DCTSIZE * 6] == 0 &&\n        inptr[DCTSIZE * 7] == 0) {\n      /* AC terms all zero */\n      int dcval = LEFT_SHIFT(DEQUANTIZE(inptr[DCTSIZE * 0],\n                             quantptr[DCTSIZE * 0]), PASS1_BITS);\n\n      wsptr[DCTSIZE * 0] = dcval;\n      wsptr[DCTSIZE * 1] = dcval;\n      wsptr[DCTSIZE * 2] = dcval;\n      wsptr[DCTSIZE * 3] = dcval;\n      wsptr[DCTSIZE * 4] = dcval;\n      wsptr[DCTSIZE * 5] = dcval;\n      wsptr[DCTSIZE * 6] = dcval;\n      wsptr[DCTSIZE * 7] = dcval;\n\n      inptr++;                  /* advance pointers to next column */\n      quantptr++;\n      wsptr++;\n      continue;\n    }\n\n    /* Even part: reverse the even part of the forward DCT. */\n    /* The rotator is sqrt(2)*c(-6). */\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);\n    tmp2 = z1 + MULTIPLY(z3, -FIX_1_847759065);\n    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n\n    tmp0 = LEFT_SHIFT(z2 + z3, CONST_BITS);\n    tmp1 = LEFT_SHIFT(z2 - z3, CONST_BITS);\n\n    tmp10 = tmp0 + tmp3;\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    /* Odd part per figure 8; the matrix is unitary and hence its\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\n     */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    tmp3 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n\n    z1 = tmp0 + tmp3;\n    z2 = tmp1 + tmp2;\n    z3 = tmp0 + tmp2;\n    z4 = tmp1 + tmp3;\n    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */\n\n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */\n    z1 = MULTIPLY(z1, -FIX_0_899976223); /* sqrt(2) * ( c7-c3) */\n    z2 = MULTIPLY(z2, -FIX_2_562915447); /* sqrt(2) * (-c1-c3) */\n    z3 = MULTIPLY(z3, -FIX_1_961570560); /* sqrt(2) * (-c3-c5) */\n    z4 = MULTIPLY(z4, -FIX_0_390180644); /* sqrt(2) * ( c5-c3) */\n\n    z3 += z5;\n    z4 += z5;\n\n    tmp0 += z1 + z3;\n    tmp1 += z2 + z4;\n    tmp2 += z2 + z3;\n    tmp3 += z1 + z4;\n\n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\n\n    wsptr[DCTSIZE * 0] = (int)DESCALE(tmp10 + tmp3, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 7] = (int)DESCALE(tmp10 - tmp3, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 1] = (int)DESCALE(tmp11 + tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 6] = (int)DESCALE(tmp11 - tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 2] = (int)DESCALE(tmp12 + tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 5] = (int)DESCALE(tmp12 - tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 3] = (int)DESCALE(tmp13 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[DCTSIZE * 4] = (int)DESCALE(tmp13 - tmp0, CONST_BITS - PASS1_BITS);\n\n    inptr++;                    /* advance pointers to next column */\n    quantptr++;\n    wsptr++;\n  }\n\n  /* Pass 2: process rows from work array, store into output array. */\n  /* Note that we must descale the results by a factor of 8 == 2**3, */\n  /* and also undo the PASS1_BITS scaling. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < DCTSIZE; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* Rows of zeroes can be exploited in the same way as we did with columns.\n     * However, the column calculation has created many nonzero AC terms, so\n     * the simplification applies less often (typically 5% to 10% of the time).\n     * On machines with very fast multiplication, it's possible that the\n     * test takes more time than it's worth.  In that case this section\n     * may be commented out.\n     */\n\n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&\n        wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      _JSAMPLE dcval = range_limit[(int)DESCALE((JLONG)wsptr[0],\n                                                PASS1_BITS + 3) & RANGE_MASK];\n\n      outptr[0] = dcval;\n      outptr[1] = dcval;\n      outptr[2] = dcval;\n      outptr[3] = dcval;\n      outptr[4] = dcval;\n      outptr[5] = dcval;\n      outptr[6] = dcval;\n      outptr[7] = dcval;\n\n      wsptr += DCTSIZE;         /* advance pointer to next row */\n      continue;\n    }\n#endif\n\n    /* Even part: reverse the even part of the forward DCT. */\n    /* The rotator is sqrt(2)*c(-6). */\n\n    z2 = (JLONG)wsptr[2];\n    z3 = (JLONG)wsptr[6];\n\n    z1 = MULTIPLY(z2 + z3, FIX_0_541196100);\n    tmp2 = z1 + MULTIPLY(z3, -FIX_1_847759065);\n    tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);\n\n    tmp0 = LEFT_SHIFT((JLONG)wsptr[0] + (JLONG)wsptr[4], CONST_BITS);\n    tmp1 = LEFT_SHIFT((JLONG)wsptr[0] - (JLONG)wsptr[4], CONST_BITS);\n\n    tmp10 = tmp0 + tmp3;\n    tmp13 = tmp0 - tmp3;\n    tmp11 = tmp1 + tmp2;\n    tmp12 = tmp1 - tmp2;\n\n    /* Odd part per figure 8; the matrix is unitary and hence its\n     * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.\n     */\n\n    tmp0 = (JLONG)wsptr[7];\n    tmp1 = (JLONG)wsptr[5];\n    tmp2 = (JLONG)wsptr[3];\n    tmp3 = (JLONG)wsptr[1];\n\n    z1 = tmp0 + tmp3;\n    z2 = tmp1 + tmp2;\n    z3 = tmp0 + tmp2;\n    z4 = tmp1 + tmp3;\n    z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */\n\n    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */\n    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */\n    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */\n    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */\n    z1 = MULTIPLY(z1, -FIX_0_899976223); /* sqrt(2) * ( c7-c3) */\n    z2 = MULTIPLY(z2, -FIX_2_562915447); /* sqrt(2) * (-c1-c3) */\n    z3 = MULTIPLY(z3, -FIX_1_961570560); /* sqrt(2) * (-c3-c5) */\n    z4 = MULTIPLY(z4, -FIX_0_390180644); /* sqrt(2) * ( c5-c3) */\n\n    z3 += z5;\n    z4 += z5;\n\n    tmp0 += z1 + z3;\n    tmp1 += z2 + z4;\n    tmp2 += z2 + z3;\n    tmp3 += z1 + z4;\n\n    /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\n\n    outptr[0] = range_limit[(int)DESCALE(tmp10 + tmp3,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[7] = range_limit[(int)DESCALE(tmp10 - tmp3,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)DESCALE(tmp11 + tmp2,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[6] = range_limit[(int)DESCALE(tmp11 - tmp2,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)DESCALE(tmp12 + tmp1,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[5] = range_limit[(int)DESCALE(tmp12 - tmp1,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)DESCALE(tmp13 + tmp0,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)DESCALE(tmp13 - tmp0,\n                                         CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += DCTSIZE;           /* advance pointer to next row */\n  }\n}\n\n#ifdef IDCT_SCALING_SUPPORTED\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 7x7 output block.\n *\n * Optimized algorithm with 12 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/14).\n */\n\nGLOBAL(void)\n_jpeg_idct_7x7(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n               JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n               JDIMENSION output_col)\n{\n  JLONG tmp0, tmp1, tmp2, tmp10, tmp11, tmp12, tmp13;\n  JLONG z1, z2, z3;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[7 * 7];         /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 7; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp13 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp13 = LEFT_SHIFT(tmp13, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp13 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */\n    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */\n    tmp0 = z1 + z3;\n    z2 -= tmp0;\n    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */\n    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */\n    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */\n    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n\n    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */\n    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */\n    tmp0 = tmp1 - tmp2;\n    tmp1 += tmp2;\n    tmp2 = MULTIPLY(z2 + z3, -FIX(1.378756276));     /* -c1 */\n    tmp1 += tmp2;\n    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */\n    tmp0 += z2;\n    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */\n\n    /* Final output stage */\n\n    wsptr[7 * 0] = (int)RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 6] = (int)RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 1] = (int)RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 5] = (int)RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 2] = (int)RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 4] = (int)RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[7 * 3] = (int)RIGHT_SHIFT(tmp13, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 7 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 7; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp13 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp13 = LEFT_SHIFT(tmp13, CONST_BITS);\n\n    z1 = (JLONG)wsptr[2];\n    z2 = (JLONG)wsptr[4];\n    z3 = (JLONG)wsptr[6];\n\n    tmp10 = MULTIPLY(z2 - z3, FIX(0.881747734));     /* c4 */\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.314692123));     /* c6 */\n    tmp11 = tmp10 + tmp12 + tmp13 - MULTIPLY(z2, FIX(1.841218003)); /* c2+c4-c6 */\n    tmp0 = z1 + z3;\n    z2 -= tmp0;\n    tmp0 = MULTIPLY(tmp0, FIX(1.274162392)) + tmp13; /* c2 */\n    tmp10 += tmp0 - MULTIPLY(z3, FIX(0.077722536));  /* c2-c4-c6 */\n    tmp12 += tmp0 - MULTIPLY(z1, FIX(2.470602249));  /* c2+c4+c6 */\n    tmp13 += MULTIPLY(z2, FIX(1.414213562));         /* c0 */\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n\n    tmp1 = MULTIPLY(z1 + z2, FIX(0.935414347));      /* (c3+c1-c5)/2 */\n    tmp2 = MULTIPLY(z1 - z2, FIX(0.170262339));      /* (c3+c5-c1)/2 */\n    tmp0 = tmp1 - tmp2;\n    tmp1 += tmp2;\n    tmp2 = MULTIPLY(z2 + z3, -FIX(1.378756276));     /* -c1 */\n    tmp1 += tmp2;\n    z2 = MULTIPLY(z1 + z3, FIX(0.613604268));        /* c5 */\n    tmp0 += z2;\n    tmp2 += z2 + MULTIPLY(z3, FIX(1.870828693));     /* c3+c1-c5 */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp10 + tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[6] = range_limit[(int)RIGHT_SHIFT(tmp10 - tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp11 + tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[5] = range_limit[(int)RIGHT_SHIFT(tmp11 - tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp12 + tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)RIGHT_SHIFT(tmp12 - tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)RIGHT_SHIFT(tmp13,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 7;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 6x6 output block.\n *\n * Optimized algorithm with 3 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/12).\n */\n\nGLOBAL(void)\n_jpeg_idct_6x6(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n               JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n               JDIMENSION output_col)\n{\n  JLONG tmp0, tmp1, tmp2, tmp10, tmp11, tmp12;\n  JLONG z1, z2, z3;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[6 * 6];         /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 6; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS - PASS1_BITS - 1);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */\n    tmp1 = tmp0 + tmp10;\n    tmp11 = RIGHT_SHIFT(tmp0 - tmp10 - tmp10, CONST_BITS - PASS1_BITS);\n    tmp10 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */\n    tmp10 = tmp1 + tmp0;\n    tmp12 = tmp1 - tmp0;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */\n    tmp0 = tmp1 + LEFT_SHIFT(z1 + z2, CONST_BITS);\n    tmp2 = tmp1 + LEFT_SHIFT(z3 - z2, CONST_BITS);\n    tmp1 = LEFT_SHIFT(z1 - z2 - z3, PASS1_BITS);\n\n    /* Final output stage */\n\n    wsptr[6 * 0] = (int)RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[6 * 5] = (int)RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[6 * 1] = (int)(tmp11 + tmp1);\n    wsptr[6 * 4] = (int)(tmp11 - tmp1);\n    wsptr[6 * 2] = (int)RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[6 * 3] = (int)RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 6 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 6; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp0 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n    tmp2 = (JLONG)wsptr[4];\n    tmp10 = MULTIPLY(tmp2, FIX(0.707106781));   /* c4 */\n    tmp1 = tmp0 + tmp10;\n    tmp11 = tmp0 - tmp10 - tmp10;\n    tmp10 = (JLONG)wsptr[2];\n    tmp0 = MULTIPLY(tmp10, FIX(1.224744871));   /* c2 */\n    tmp10 = tmp1 + tmp0;\n    tmp12 = tmp1 - tmp0;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    tmp1 = MULTIPLY(z1 + z3, FIX(0.366025404)); /* c5 */\n    tmp0 = tmp1 + LEFT_SHIFT(z1 + z2, CONST_BITS);\n    tmp2 = tmp1 + LEFT_SHIFT(z3 - z2, CONST_BITS);\n    tmp1 = LEFT_SHIFT(z1 - z2 - z3, CONST_BITS);\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp10 + tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[5] = range_limit[(int)RIGHT_SHIFT(tmp10 - tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp11 + tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)RIGHT_SHIFT(tmp11 - tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp12 + tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)RIGHT_SHIFT(tmp12 - tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 6;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 5x5 output block.\n *\n * Optimized algorithm with 5 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/10).\n */\n\nGLOBAL(void)\n_jpeg_idct_5x5(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n               JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n               JDIMENSION output_col)\n{\n  JLONG tmp0, tmp1, tmp10, tmp11, tmp12;\n  JLONG z1, z2, z3;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[5 * 5];         /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 5; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp12 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp12 = LEFT_SHIFT(tmp12, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp12 += ONE << (CONST_BITS - PASS1_BITS - 1);\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    tmp1 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */\n    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */\n    z3 = tmp12 + z2;\n    tmp10 = z3 + z1;\n    tmp11 = z3 - z1;\n    tmp12 -= LEFT_SHIFT(z2, 2);\n\n    /* Odd part */\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */\n    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */\n    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */\n\n    /* Final output stage */\n\n    wsptr[5 * 0] = (int)RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[5 * 4] = (int)RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[5 * 1] = (int)RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[5 * 3] = (int)RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[5 * 2] = (int)RIGHT_SHIFT(tmp12, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 5 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 5; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp12 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp12 = LEFT_SHIFT(tmp12, CONST_BITS);\n    tmp0 = (JLONG)wsptr[2];\n    tmp1 = (JLONG)wsptr[4];\n    z1 = MULTIPLY(tmp0 + tmp1, FIX(0.790569415)); /* (c2+c4)/2 */\n    z2 = MULTIPLY(tmp0 - tmp1, FIX(0.353553391)); /* (c2-c4)/2 */\n    z3 = tmp12 + z2;\n    tmp10 = z3 + z1;\n    tmp11 = z3 - z1;\n    tmp12 -= LEFT_SHIFT(z2, 2);\n\n    /* Odd part */\n\n    z2 = (JLONG)wsptr[1];\n    z3 = (JLONG)wsptr[3];\n\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));     /* c3 */\n    tmp0 = z1 + MULTIPLY(z2, FIX(0.513743148));   /* c1-c3 */\n    tmp1 = z1 - MULTIPLY(z3, FIX(2.176250899));   /* c1+c3 */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp10 + tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)RIGHT_SHIFT(tmp10 - tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp11 + tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)RIGHT_SHIFT(tmp11 - tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp12,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 5;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 3x3 output block.\n *\n * Optimized algorithm with 2 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/6).\n */\n\nGLOBAL(void)\n_jpeg_idct_3x3(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n               JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n               JDIMENSION output_col)\n{\n  JLONG tmp0, tmp2, tmp10, tmp12;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[3 * 3];         /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 3; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS - PASS1_BITS - 1);\n    tmp2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */\n    tmp10 = tmp0 + tmp12;\n    tmp2 = tmp0 - tmp12 - tmp12;\n\n    /* Odd part */\n\n    tmp12 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */\n\n    /* Final output stage */\n\n    wsptr[3 * 0] = (int)RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[3 * 2] = (int)RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[3 * 1] = (int)RIGHT_SHIFT(tmp2, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 3 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 3; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp0 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n    tmp2 = (JLONG)wsptr[2];\n    tmp12 = MULTIPLY(tmp2, FIX(0.707106781)); /* c2 */\n    tmp10 = tmp0 + tmp12;\n    tmp2 = tmp0 - tmp12 - tmp12;\n\n    /* Odd part */\n\n    tmp12 = (JLONG)wsptr[1];\n    tmp0 = MULTIPLY(tmp12, FIX(1.224744871)); /* c1 */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp10 + tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp10 - tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 3;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 9x9 output block.\n *\n * Optimized algorithm with 10 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/18).\n */\n\nGLOBAL(void)\n_jpeg_idct_9x9(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n               JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n               JDIMENSION output_col)\n{\n  JLONG tmp0, tmp1, tmp2, tmp3, tmp10, tmp11, tmp12, tmp13, tmp14;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 9];         /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */\n    tmp1 = tmp0 + tmp3;\n    tmp2 = tmp0 - tmp3 - tmp3;\n\n    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */\n    tmp11 = tmp2 + tmp0;\n    tmp14 = tmp2 - tmp0 - tmp0;\n\n    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */\n    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */\n    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */\n\n    tmp10 = tmp1 + tmp0 - tmp3;\n    tmp12 = tmp1 - tmp0 + tmp2;\n    tmp13 = tmp1 - tmp2 + tmp3;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    z2 = MULTIPLY(z2, -FIX(1.224744871));            /* -c3 */\n\n    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */\n    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */\n    tmp0 = tmp2 + tmp3 - z2;\n    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */\n    tmp2 += z2 - tmp1;\n    tmp3 += z2 + tmp1;\n    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0] = (int)RIGHT_SHIFT(tmp10 + tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8] = (int)RIGHT_SHIFT(tmp10 - tmp0, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1] = (int)RIGHT_SHIFT(tmp11 + tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7] = (int)RIGHT_SHIFT(tmp11 - tmp1, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2] = (int)RIGHT_SHIFT(tmp12 + tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6] = (int)RIGHT_SHIFT(tmp12 - tmp2, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3] = (int)RIGHT_SHIFT(tmp13 + tmp3, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5] = (int)RIGHT_SHIFT(tmp13 - tmp3, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4] = (int)RIGHT_SHIFT(tmp14, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 9 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 9; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp0 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n\n    z1 = (JLONG)wsptr[2];\n    z2 = (JLONG)wsptr[4];\n    z3 = (JLONG)wsptr[6];\n\n    tmp3 = MULTIPLY(z3, FIX(0.707106781));      /* c6 */\n    tmp1 = tmp0 + tmp3;\n    tmp2 = tmp0 - tmp3 - tmp3;\n\n    tmp0 = MULTIPLY(z1 - z2, FIX(0.707106781)); /* c6 */\n    tmp11 = tmp2 + tmp0;\n    tmp14 = tmp2 - tmp0 - tmp0;\n\n    tmp0 = MULTIPLY(z1 + z2, FIX(1.328926049)); /* c2 */\n    tmp2 = MULTIPLY(z1, FIX(1.083350441));      /* c4 */\n    tmp3 = MULTIPLY(z2, FIX(0.245575608));      /* c8 */\n\n    tmp10 = tmp1 + tmp0 - tmp3;\n    tmp12 = tmp1 - tmp0 + tmp2;\n    tmp13 = tmp1 - tmp2 + tmp3;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n\n    z2 = MULTIPLY(z2, -FIX(1.224744871));            /* -c3 */\n\n    tmp2 = MULTIPLY(z1 + z3, FIX(0.909038955));      /* c5 */\n    tmp3 = MULTIPLY(z1 + z4, FIX(0.483689525));      /* c7 */\n    tmp0 = tmp2 + tmp3 - z2;\n    tmp1 = MULTIPLY(z3 - z4, FIX(1.392728481));      /* c1 */\n    tmp2 += z2 - tmp1;\n    tmp3 += z2 + tmp1;\n    tmp1 = MULTIPLY(z1 - z3 - z4, FIX(1.224744871)); /* c3 */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp10 + tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[8] = range_limit[(int)RIGHT_SHIFT(tmp10 - tmp0,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp11 + tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[7] = range_limit[(int)RIGHT_SHIFT(tmp11 - tmp1,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp12 + tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[6] = range_limit[(int)RIGHT_SHIFT(tmp12 - tmp2,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)RIGHT_SHIFT(tmp13 + tmp3,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[5] = range_limit[(int)RIGHT_SHIFT(tmp13 - tmp3,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)RIGHT_SHIFT(tmp14,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 10x10 output block.\n *\n * Optimized algorithm with 12 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/20).\n */\n\nGLOBAL(void)\n_jpeg_idct_10x10(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                 JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                 JDIMENSION output_col)\n{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24;\n  JLONG z1, z2, z3, z4, z5;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 10];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z3 = LEFT_SHIFT(z3, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    z3 += ONE << (CONST_BITS - PASS1_BITS - 1);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */\n    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */\n    tmp10 = z3 + z1;\n    tmp11 = z3 - z2;\n\n    tmp22 = RIGHT_SHIFT(z3 - LEFT_SHIFT(z1 - z2, 1),\n                        CONST_BITS - PASS1_BITS); /* c0 = (c4-c8)*2 */\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */\n    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */\n    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */\n\n    tmp20 = tmp10 + tmp12;\n    tmp24 = tmp10 - tmp12;\n    tmp21 = tmp11 + tmp13;\n    tmp23 = tmp11 - tmp13;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp11 = z2 + z4;\n    tmp13 = z2 - z4;\n\n    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */\n    z5 = LEFT_SHIFT(z3, CONST_BITS);\n\n    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */\n    z4 = z5 + tmp12;\n\n    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */\n    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */\n\n    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */\n    z4 = z5 - tmp12 - LEFT_SHIFT(tmp13, CONST_BITS - 1);\n\n    tmp12 = LEFT_SHIFT(z1 - tmp13 - z3, PASS1_BITS);\n\n    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */\n    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0] = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1] = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8] = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2] = (int)(tmp22 + tmp12);\n    wsptr[8 * 7] = (int)(tmp22 - tmp12);\n    wsptr[8 * 3] = (int)RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6] = (int)RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4] = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5] = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 10 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 10; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    z3 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    z3 = LEFT_SHIFT(z3, CONST_BITS);\n    z4 = (JLONG)wsptr[4];\n    z1 = MULTIPLY(z4, FIX(1.144122806));         /* c4 */\n    z2 = MULTIPLY(z4, FIX(0.437016024));         /* c8 */\n    tmp10 = z3 + z1;\n    tmp11 = z3 - z2;\n\n    tmp22 = z3 - LEFT_SHIFT(z1 - z2, 1);         /* c0 = (c4-c8)*2 */\n\n    z2 = (JLONG)wsptr[2];\n    z3 = (JLONG)wsptr[6];\n\n    z1 = MULTIPLY(z2 + z3, FIX(0.831253876));    /* c6 */\n    tmp12 = z1 + MULTIPLY(z2, FIX(0.513743148)); /* c2-c6 */\n    tmp13 = z1 - MULTIPLY(z3, FIX(2.176250899)); /* c2+c6 */\n\n    tmp20 = tmp10 + tmp12;\n    tmp24 = tmp10 - tmp12;\n    tmp21 = tmp11 + tmp13;\n    tmp23 = tmp11 - tmp13;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z3 = LEFT_SHIFT(z3, CONST_BITS);\n    z4 = (JLONG)wsptr[7];\n\n    tmp11 = z2 + z4;\n    tmp13 = z2 - z4;\n\n    tmp12 = MULTIPLY(tmp13, FIX(0.309016994));        /* (c3-c7)/2 */\n\n    z2 = MULTIPLY(tmp11, FIX(0.951056516));           /* (c3+c7)/2 */\n    z4 = z3 + tmp12;\n\n    tmp10 = MULTIPLY(z1, FIX(1.396802247)) + z2 + z4; /* c1 */\n    tmp14 = MULTIPLY(z1, FIX(0.221231742)) - z2 + z4; /* c9 */\n\n    z2 = MULTIPLY(tmp11, FIX(0.587785252));           /* (c1-c9)/2 */\n    z4 = z3 - tmp12 - LEFT_SHIFT(tmp13, CONST_BITS - 1);\n\n    tmp12 = LEFT_SHIFT(z1 - tmp13, CONST_BITS) - z3;\n\n    tmp11 = MULTIPLY(z1, FIX(1.260073511)) - z2 - z4; /* c3 */\n    tmp13 = MULTIPLY(z1, FIX(0.642039522)) - z2 + z4; /* c7 */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[9] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[8] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[7] = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[6] = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[4] = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n    outptr[5] = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                             CONST_BITS + PASS1_BITS + 3) &\n                            RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing an 11x11 output block.\n *\n * Optimized algorithm with 24 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/22).\n */\n\nGLOBAL(void)\n_jpeg_idct_11x11(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                 JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                 JDIMENSION output_col)\n{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 11];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp10 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp10 = LEFT_SHIFT(tmp10, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp10 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */\n    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */\n    z4 = z1 + z3;\n    tmp24 = MULTIPLY(z4, -FIX(1.155664402));         /* -(c2-c10) */\n    z4 -= z2;\n    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */\n    tmp21 = tmp20 + tmp23 + tmp25 -\n            MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */\n    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */\n    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */\n    tmp24 += tmp25;\n    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */\n    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */\n             MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */\n    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp11 = z1 + z2;\n    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */\n    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */\n    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */\n    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */\n    tmp10 = tmp11 + tmp12 + tmp13 -\n            MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */\n    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */\n    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */\n    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */\n    z1    = MULTIPLY(z2 + z4, -FIX(1.798248910));        /* -(c1+c9) */\n    tmp11 += z1;\n    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */\n    tmp14 += MULTIPLY(z2, -FIX(1.467221301)) +           /* -(c5+c9) */\n             MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */\n             MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 10] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 11 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 11; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp10 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp10 = LEFT_SHIFT(tmp10, CONST_BITS);\n\n    z1 = (JLONG)wsptr[2];\n    z2 = (JLONG)wsptr[4];\n    z3 = (JLONG)wsptr[6];\n\n    tmp20 = MULTIPLY(z2 - z3, FIX(2.546640132));     /* c2+c4 */\n    tmp23 = MULTIPLY(z2 - z1, FIX(0.430815045));     /* c2-c6 */\n    z4 = z1 + z3;\n    tmp24 = MULTIPLY(z4, -FIX(1.155664402));         /* -(c2-c10) */\n    z4 -= z2;\n    tmp25 = tmp10 + MULTIPLY(z4, FIX(1.356927976));  /* c2 */\n    tmp21 = tmp20 + tmp23 + tmp25 -\n            MULTIPLY(z2, FIX(1.821790775));          /* c2+c4+c10-c6 */\n    tmp20 += tmp25 + MULTIPLY(z3, FIX(2.115825087)); /* c4+c6 */\n    tmp23 += tmp25 - MULTIPLY(z1, FIX(1.513598477)); /* c6+c8 */\n    tmp24 += tmp25;\n    tmp22 = tmp24 - MULTIPLY(z3, FIX(0.788749120));  /* c8+c10 */\n    tmp24 += MULTIPLY(z2, FIX(1.944413522)) -        /* c2+c8 */\n             MULTIPLY(z1, FIX(1.390975730));         /* c4+c10 */\n    tmp25 = tmp10 - MULTIPLY(z4, FIX(1.414213562));  /* c0 */\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n\n    tmp11 = z1 + z2;\n    tmp14 = MULTIPLY(tmp11 + z3 + z4, FIX(0.398430003)); /* c9 */\n    tmp11 = MULTIPLY(tmp11, FIX(0.887983902));           /* c3-c9 */\n    tmp12 = MULTIPLY(z1 + z3, FIX(0.670361295));         /* c5-c9 */\n    tmp13 = tmp14 + MULTIPLY(z1 + z4, FIX(0.366151574)); /* c7-c9 */\n    tmp10 = tmp11 + tmp12 + tmp13 -\n            MULTIPLY(z1, FIX(0.923107866));              /* c7+c5+c3-c1-2*c9 */\n    z1    = tmp14 - MULTIPLY(z2 + z3, FIX(1.163011579)); /* c7+c9 */\n    tmp11 += z1 + MULTIPLY(z2, FIX(2.073276588));        /* c1+c7+3*c9-c3 */\n    tmp12 += z1 - MULTIPLY(z3, FIX(1.192193623));        /* c3+c5-c7-c9 */\n    z1    = MULTIPLY(z2 + z4, -FIX(1.798248910));        /* -(c1+c9) */\n    tmp11 += z1;\n    tmp13 += z1 + MULTIPLY(z4, FIX(2.102458632));        /* c1+c5+c9-c7 */\n    tmp14 += MULTIPLY(z2, -FIX(1.467221301)) +           /* -(c5+c9) */\n             MULTIPLY(z3, FIX(1.001388905)) -            /* c1-c9 */\n             MULTIPLY(z4, FIX(1.684843907));             /* c3+c9 */\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 12x12 output block.\n *\n * Optimized algorithm with 15 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/24).\n */\n\nGLOBAL(void)\n_jpeg_idct_12x12(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                 JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                 JDIMENSION output_col)\n{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 12];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z3 = LEFT_SHIFT(z3, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    z3 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */\n\n    tmp10 = z3 + z4;\n    tmp11 = z3 - z4;\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n    z2 = LEFT_SHIFT(z2, CONST_BITS);\n\n    tmp12 = z1 - z2;\n\n    tmp21 = z3 + tmp12;\n    tmp24 = z3 - tmp12;\n\n    tmp12 = z4 + z2;\n\n    tmp20 = tmp10 + tmp12;\n    tmp25 = tmp10 - tmp12;\n\n    tmp12 = z4 - z1 - z2;\n\n    tmp22 = tmp11 + tmp12;\n    tmp23 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */\n    tmp14 = MULTIPLY(z2, -FIX_0_541196100);                  /* -c9 */\n\n    tmp10 = z1 + z3;\n    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */\n    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */\n    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */\n    tmp13 = MULTIPLY(z3 + z4, -FIX(1.045510580));            /* -(c7+c11) */\n    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */\n    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */\n    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */\n             MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */\n\n    z1 -= z4;\n    z2 -= z3;\n    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */\n    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */\n    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 11] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 10] = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 12 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 12; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    z3 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    z3 = LEFT_SHIFT(z3, CONST_BITS);\n\n    z4 = (JLONG)wsptr[4];\n    z4 = MULTIPLY(z4, FIX(1.224744871)); /* c4 */\n\n    tmp10 = z3 + z4;\n    tmp11 = z3 - z4;\n\n    z1 = (JLONG)wsptr[2];\n    z4 = MULTIPLY(z1, FIX(1.366025404)); /* c2 */\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    z2 = (JLONG)wsptr[6];\n    z2 = LEFT_SHIFT(z2, CONST_BITS);\n\n    tmp12 = z1 - z2;\n\n    tmp21 = z3 + tmp12;\n    tmp24 = z3 - tmp12;\n\n    tmp12 = z4 + z2;\n\n    tmp20 = tmp10 + tmp12;\n    tmp25 = tmp10 - tmp12;\n\n    tmp12 = z4 - z1 - z2;\n\n    tmp22 = tmp11 + tmp12;\n    tmp23 = tmp11 - tmp12;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n\n    tmp11 = MULTIPLY(z2, FIX(1.306562965));                  /* c3 */\n    tmp14 = MULTIPLY(z2, -FIX_0_541196100);                  /* -c9 */\n\n    tmp10 = z1 + z3;\n    tmp15 = MULTIPLY(tmp10 + z4, FIX(0.860918669));          /* c7 */\n    tmp12 = tmp15 + MULTIPLY(tmp10, FIX(0.261052384));       /* c5-c7 */\n    tmp10 = tmp12 + tmp11 + MULTIPLY(z1, FIX(0.280143716));  /* c1-c5 */\n    tmp13 = MULTIPLY(z3 + z4, -FIX(1.045510580));            /* -(c7+c11) */\n    tmp12 += tmp13 + tmp14 - MULTIPLY(z3, FIX(1.478575242)); /* c1+c5-c7-c11 */\n    tmp13 += tmp15 - tmp11 + MULTIPLY(z4, FIX(1.586706681)); /* c1+c11 */\n    tmp15 += tmp14 - MULTIPLY(z1, FIX(0.676326758)) -        /* c7-c11 */\n             MULTIPLY(z4, FIX(1.982889723));                 /* c5+c7 */\n\n    z1 -= z4;\n    z2 -= z3;\n    z3 = MULTIPLY(z1 + z2, FIX_0_541196100);                 /* c9 */\n    tmp11 = z3 + MULTIPLY(z1, FIX_0_765366865);              /* c3-c9 */\n    tmp14 = z3 - MULTIPLY(z2, FIX_1_847759065);              /* c3+c9 */\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[11] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25 + tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp25 - tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 13x13 output block.\n *\n * Optimized algorithm with 29 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/26).\n */\n\nGLOBAL(void)\n_jpeg_idct_13x13(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                 JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                 JDIMENSION output_col)\n{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14, tmp15;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 13];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    z1 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp10 = z3 + z4;\n    tmp11 = z3 - z4;\n\n    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */\n\n    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */\n    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */\n\n    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */\n\n    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */\n    tmp25 = MULTIPLY(z2, -FIX(1.252223920)) + tmp12 + tmp13;  /* c4 */\n\n    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */\n\n    tmp23 = MULTIPLY(z2, -FIX(0.170464608)) - tmp12 - tmp13;  /* c12 */\n    tmp24 = MULTIPLY(z2, -FIX(0.803364869)) + tmp12 - tmp13;  /* c8 */\n\n    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */\n    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */\n    tmp15 = z1 + z4;\n    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */\n    tmp10 = tmp11 + tmp12 + tmp13 -\n            MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */\n    tmp14 = MULTIPLY(z2 + z3, -FIX(0.338443458));    /* -c11 */\n    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */\n    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */\n    tmp14 = MULTIPLY(z2 + z4, -FIX(1.163874945));    /* -c5 */\n    tmp11 += tmp14;\n    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */\n    tmp14 = MULTIPLY(z3 + z4, -FIX(0.657217813));    /* -c9 */\n    tmp12 += tmp14;\n    tmp13 += tmp14;\n    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */\n    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */\n            MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */\n    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */\n    tmp14 += z1;\n    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */\n             MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 12] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 11] = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 10] = (int)RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp26, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 13 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 13; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    z1 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n\n    z2 = (JLONG)wsptr[2];\n    z3 = (JLONG)wsptr[4];\n    z4 = (JLONG)wsptr[6];\n\n    tmp10 = z3 + z4;\n    tmp11 = z3 - z4;\n\n    tmp12 = MULTIPLY(tmp10, FIX(1.155388986));                /* (c4+c6)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.096834934)) + z1;           /* (c4-c6)/2 */\n\n    tmp20 = MULTIPLY(z2, FIX(1.373119086)) + tmp12 + tmp13;   /* c2 */\n    tmp22 = MULTIPLY(z2, FIX(0.501487041)) - tmp12 + tmp13;   /* c10 */\n\n    tmp12 = MULTIPLY(tmp10, FIX(0.316450131));                /* (c8-c12)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.486914739)) + z1;           /* (c8+c12)/2 */\n\n    tmp21 = MULTIPLY(z2, FIX(1.058554052)) - tmp12 + tmp13;   /* c6 */\n    tmp25 = MULTIPLY(z2, -FIX(1.252223920)) + tmp12 + tmp13;  /* c4 */\n\n    tmp12 = MULTIPLY(tmp10, FIX(0.435816023));                /* (c2-c10)/2 */\n    tmp13 = MULTIPLY(tmp11, FIX(0.937303064)) - z1;           /* (c2+c10)/2 */\n\n    tmp23 = MULTIPLY(z2, -FIX(0.170464608)) - tmp12 - tmp13;  /* c12 */\n    tmp24 = MULTIPLY(z2, -FIX(0.803364869)) + tmp12 - tmp13;  /* c8 */\n\n    tmp26 = MULTIPLY(tmp11 - z2, FIX(1.414213562)) + z1;      /* c0 */\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.322312651));     /* c3 */\n    tmp12 = MULTIPLY(z1 + z3, FIX(1.163874945));     /* c5 */\n    tmp15 = z1 + z4;\n    tmp13 = MULTIPLY(tmp15, FIX(0.937797057));       /* c7 */\n    tmp10 = tmp11 + tmp12 + tmp13 -\n            MULTIPLY(z1, FIX(2.020082300));          /* c7+c5+c3-c1 */\n    tmp14 = MULTIPLY(z2 + z3, -FIX(0.338443458));    /* -c11 */\n    tmp11 += tmp14 + MULTIPLY(z2, FIX(0.837223564)); /* c5+c9+c11-c3 */\n    tmp12 += tmp14 - MULTIPLY(z3, FIX(1.572116027)); /* c1+c5-c9-c11 */\n    tmp14 = MULTIPLY(z2 + z4, -FIX(1.163874945));    /* -c5 */\n    tmp11 += tmp14;\n    tmp13 += tmp14 + MULTIPLY(z4, FIX(2.205608352)); /* c3+c5+c9-c7 */\n    tmp14 = MULTIPLY(z3 + z4, -FIX(0.657217813));    /* -c9 */\n    tmp12 += tmp14;\n    tmp13 += tmp14;\n    tmp15 = MULTIPLY(tmp15, FIX(0.338443458));       /* c11 */\n    tmp14 = tmp15 + MULTIPLY(z1, FIX(0.318774355)) - /* c9-c11 */\n            MULTIPLY(z2, FIX(0.466105296));          /* c1-c7 */\n    z1    = MULTIPLY(z3 - z2, FIX(0.937797057));     /* c7 */\n    tmp14 += z1;\n    tmp15 += z1 + MULTIPLY(z3, FIX(0.384515595)) -   /* c3-c7 */\n             MULTIPLY(z4, FIX(1.742345811));         /* c1+c11 */\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[12] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[11] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25 + tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp25 - tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp26,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 14x14 output block.\n *\n * Optimized algorithm with 20 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/28).\n */\n\nGLOBAL(void)\n_jpeg_idct_14x14(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                 JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                 JDIMENSION output_col)\n{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 14];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    z1 += ONE << (CONST_BITS - PASS1_BITS - 1);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */\n    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */\n    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */\n\n    tmp10 = z1 + z2;\n    tmp11 = z1 + z3;\n    tmp12 = z1 - z4;\n\n    tmp23 = RIGHT_SHIFT(z1 - LEFT_SHIFT(z2 + z3 - z4, 1),\n                        CONST_BITS - PASS1_BITS); /* c0 = (c4+c12-c8)*2 */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */\n\n    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */\n    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */\n    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */\n            MULTIPLY(z2, FIX(1.378756276));      /* c2 */\n\n    tmp20 = tmp10 + tmp13;\n    tmp26 = tmp10 - tmp13;\n    tmp21 = tmp11 + tmp14;\n    tmp25 = tmp11 - tmp14;\n    tmp22 = tmp12 + tmp15;\n    tmp24 = tmp12 - tmp15;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n    tmp13 = LEFT_SHIFT(z4, CONST_BITS);\n\n    tmp14 = z1 + z3;\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */\n    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */\n    tmp10 = tmp11 + tmp12 + tmp13 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */\n    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */\n    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */\n    z1    -= z2;\n    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - tmp13;        /* c11 */\n    tmp16 += tmp15;\n    z1    += z4;\n    z4    = MULTIPLY(z2 + z3, -FIX(0.158341681)) - tmp13;  /* -c13 */\n    tmp11 += z4 - MULTIPLY(z2, FIX(0.424103948));          /* c3-c9-c13 */\n    tmp12 += z4 - MULTIPLY(z3, FIX(2.373959773));          /* c3+c5-c13 */\n    z4    = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */\n    tmp14 += z4 + tmp13 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */\n    tmp15 += z4 + MULTIPLY(z2, FIX(0.674957567));          /* c1+c11-c5 */\n\n    tmp13 = LEFT_SHIFT(z1 - z3, PASS1_BITS);\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 13] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 12] = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 11] = (int)RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)(tmp23 + tmp13);\n    wsptr[8 * 10] = (int)(tmp23 - tmp13);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 14 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 14; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    z1 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    z4 = (JLONG)wsptr[4];\n    z2 = MULTIPLY(z4, FIX(1.274162392));         /* c4 */\n    z3 = MULTIPLY(z4, FIX(0.314692123));         /* c12 */\n    z4 = MULTIPLY(z4, FIX(0.881747734));         /* c8 */\n\n    tmp10 = z1 + z2;\n    tmp11 = z1 + z3;\n    tmp12 = z1 - z4;\n\n    tmp23 = z1 - LEFT_SHIFT(z2 + z3 - z4, 1);    /* c0 = (c4+c12-c8)*2 */\n\n    z1 = (JLONG)wsptr[2];\n    z2 = (JLONG)wsptr[6];\n\n    z3 = MULTIPLY(z1 + z2, FIX(1.105676686));    /* c6 */\n\n    tmp13 = z3 + MULTIPLY(z1, FIX(0.273079590)); /* c2-c6 */\n    tmp14 = z3 - MULTIPLY(z2, FIX(1.719280954)); /* c6+c10 */\n    tmp15 = MULTIPLY(z1, FIX(0.613604268)) -     /* c10 */\n            MULTIPLY(z2, FIX(1.378756276));      /* c2 */\n\n    tmp20 = tmp10 + tmp13;\n    tmp26 = tmp10 - tmp13;\n    tmp21 = tmp11 + tmp14;\n    tmp25 = tmp11 - tmp14;\n    tmp22 = tmp12 + tmp15;\n    tmp24 = tmp12 - tmp15;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n    z4 = LEFT_SHIFT(z4, CONST_BITS);\n\n    tmp14 = z1 + z3;\n    tmp11 = MULTIPLY(z1 + z2, FIX(1.334852607));           /* c3 */\n    tmp12 = MULTIPLY(tmp14, FIX(1.197448846));             /* c5 */\n    tmp10 = tmp11 + tmp12 + z4 - MULTIPLY(z1, FIX(1.126980169)); /* c3+c5-c1 */\n    tmp14 = MULTIPLY(tmp14, FIX(0.752406978));             /* c9 */\n    tmp16 = tmp14 - MULTIPLY(z1, FIX(1.061150426));        /* c9+c11-c13 */\n    z1    -= z2;\n    tmp15 = MULTIPLY(z1, FIX(0.467085129)) - z4;           /* c11 */\n    tmp16 += tmp15;\n    tmp13 = MULTIPLY(z2 + z3, -FIX(0.158341681)) - z4;     /* -c13 */\n    tmp11 += tmp13 - MULTIPLY(z2, FIX(0.424103948));       /* c3-c9-c13 */\n    tmp12 += tmp13 - MULTIPLY(z3, FIX(2.373959773));       /* c3+c5-c13 */\n    tmp13 = MULTIPLY(z3 - z2, FIX(1.405321284));           /* c1 */\n    tmp14 += tmp13 + z4 - MULTIPLY(z3, FIX(1.6906431334)); /* c1+c9-c11 */\n    tmp15 += tmp13 + MULTIPLY(z2, FIX(0.674957567));       /* c1+c11-c5 */\n\n    tmp13 = LEFT_SHIFT(z1 - z3, CONST_BITS) + z4;\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[13] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[12] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[11] = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25 + tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp25 - tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp26 + tmp16,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp26 - tmp16,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 15x15 output block.\n *\n * Optimized algorithm with 22 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/30).\n */\n\nGLOBAL(void)\n_jpeg_idct_15x15(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                 JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                 JDIMENSION output_col)\n{\n  JLONG tmp10, tmp11, tmp12, tmp13, tmp14, tmp15, tmp16;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 15];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    z1 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */\n    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */\n\n    tmp12 = z1 - tmp10;\n    tmp13 = z1 + tmp11;\n    z1 -= LEFT_SHIFT(tmp11 - tmp10, 1);     /* c0 = (c6-c12)*2 */\n\n    z4 = z2 - z3;\n    z3 += z2;\n    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */\n    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */\n\n    tmp20 = tmp13 + tmp10 + tmp11;\n    tmp23 = tmp12 - tmp10 + tmp11 + z2;\n\n    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */\n\n    tmp25 = tmp13 - tmp10 - tmp11;\n    tmp26 = tmp12 + tmp10 - tmp11 - z2;\n\n    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */\n\n    tmp21 = tmp12 + tmp10 + tmp11;\n    tmp24 = tmp13 - tmp10 + tmp11;\n    tmp11 += tmp11;\n    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */\n    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp13 = z2 - z4;\n    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */\n    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */\n    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */\n\n    tmp13 = MULTIPLY(z2, -FIX(0.831253876));                /* -c9 */\n    tmp15 = MULTIPLY(z2, -FIX(1.344997024));                /* -c3 */\n    z2 = z1 - z4;\n    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */\n\n    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */\n    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */\n    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */\n    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */\n    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */\n    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 14] = (int)RIGHT_SHIFT(tmp20 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 13] = (int)RIGHT_SHIFT(tmp21 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 12] = (int)RIGHT_SHIFT(tmp22 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)RIGHT_SHIFT(tmp23 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 11] = (int)RIGHT_SHIFT(tmp23 - tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 10] = (int)RIGHT_SHIFT(tmp24 - tmp14, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25 + tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp25 - tmp15, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp26 + tmp16, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp26 - tmp16, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp27, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 15 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 15; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    z1 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    z1 = LEFT_SHIFT(z1, CONST_BITS);\n\n    z2 = (JLONG)wsptr[2];\n    z3 = (JLONG)wsptr[4];\n    z4 = (JLONG)wsptr[6];\n\n    tmp10 = MULTIPLY(z4, FIX(0.437016024)); /* c12 */\n    tmp11 = MULTIPLY(z4, FIX(1.144122806)); /* c6 */\n\n    tmp12 = z1 - tmp10;\n    tmp13 = z1 + tmp11;\n    z1 -= LEFT_SHIFT(tmp11 - tmp10, 1);     /* c0 = (c6-c12)*2 */\n\n    z4 = z2 - z3;\n    z3 += z2;\n    tmp10 = MULTIPLY(z3, FIX(1.337628990)); /* (c2+c4)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.045680613)); /* (c2-c4)/2 */\n    z2 = MULTIPLY(z2, FIX(1.439773946));    /* c4+c14 */\n\n    tmp20 = tmp13 + tmp10 + tmp11;\n    tmp23 = tmp12 - tmp10 + tmp11 + z2;\n\n    tmp10 = MULTIPLY(z3, FIX(0.547059574)); /* (c8+c14)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.399234004)); /* (c8-c14)/2 */\n\n    tmp25 = tmp13 - tmp10 - tmp11;\n    tmp26 = tmp12 + tmp10 - tmp11 - z2;\n\n    tmp10 = MULTIPLY(z3, FIX(0.790569415)); /* (c6+c12)/2 */\n    tmp11 = MULTIPLY(z4, FIX(0.353553391)); /* (c6-c12)/2 */\n\n    tmp21 = tmp12 + tmp10 + tmp11;\n    tmp24 = tmp13 - tmp10 + tmp11;\n    tmp11 += tmp11;\n    tmp22 = z1 + tmp11;                     /* c10 = c6-c12 */\n    tmp27 = z1 - tmp11 - tmp11;             /* c0 = (c6-c12)*2 */\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z4 = (JLONG)wsptr[5];\n    z3 = MULTIPLY(z4, FIX(1.224744871));                    /* c5 */\n    z4 = (JLONG)wsptr[7];\n\n    tmp13 = z2 - z4;\n    tmp15 = MULTIPLY(z1 + tmp13, FIX(0.831253876));         /* c9 */\n    tmp11 = tmp15 + MULTIPLY(z1, FIX(0.513743148));         /* c3-c9 */\n    tmp14 = tmp15 - MULTIPLY(tmp13, FIX(2.176250899));      /* c3+c9 */\n\n    tmp13 = MULTIPLY(z2, -FIX(0.831253876));                /* -c9 */\n    tmp15 = MULTIPLY(z2, -FIX(1.344997024));                /* -c3 */\n    z2 = z1 - z4;\n    tmp12 = z3 + MULTIPLY(z2, FIX(1.406466353));            /* c1 */\n\n    tmp10 = tmp12 + MULTIPLY(z4, FIX(2.457431844)) - tmp15; /* c1+c7 */\n    tmp16 = tmp12 - MULTIPLY(z1, FIX(1.112434820)) + tmp13; /* c1-c13 */\n    tmp12 = MULTIPLY(z2, FIX(1.224744871)) - z3;            /* c5 */\n    z2 = MULTIPLY(z1 + z4, FIX(0.575212477));               /* c11 */\n    tmp13 += z2 + MULTIPLY(z1, FIX(0.475753014)) - z3;      /* c7-c11 */\n    tmp15 += z2 - MULTIPLY(z4, FIX(0.869244010)) + z3;      /* c11+c13 */\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[14] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[13] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[12] = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[11] = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp14,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25 + tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp25 - tmp15,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp26 + tmp16,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp26 - tmp16,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp27,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a 16x16 output block.\n *\n * Optimized algorithm with 28 multiplications in the 1-D kernel.\n * cK represents sqrt(2) * cos(K*pi/32).\n */\n\nGLOBAL(void)\n_jpeg_idct_16x16(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n                 JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n                 JDIMENSION output_col)\n{\n  JLONG tmp0, tmp1, tmp2, tmp3, tmp10, tmp11, tmp12, tmp13;\n  JLONG tmp20, tmp21, tmp22, tmp23, tmp24, tmp25, tmp26, tmp27;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[8 * 16];        /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = 0; ctr < 8; ctr++, inptr++, quantptr++, wsptr++) {\n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n    /* Add fudge factor here for final descale. */\n    tmp0 += ONE << (CONST_BITS - PASS1_BITS - 1);\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 4], quantptr[DCTSIZE * 4]);\n    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */\n    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */\n\n    tmp10 = tmp0 + tmp1;\n    tmp11 = tmp0 - tmp1;\n    tmp12 = tmp0 + tmp2;\n    tmp13 = tmp0 - tmp2;\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n    z3 = z1 - z2;\n    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */\n    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */\n\n    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */\n    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */\n    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */\n    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */\n\n    tmp20 = tmp10 + tmp0;\n    tmp27 = tmp10 - tmp0;\n    tmp21 = tmp12 + tmp1;\n    tmp26 = tmp12 - tmp1;\n    tmp22 = tmp13 + tmp2;\n    tmp25 = tmp13 - tmp2;\n    tmp23 = tmp11 + tmp3;\n    tmp24 = tmp11 - tmp3;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n\n    tmp11 = z1 + z3;\n\n    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */\n    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */\n    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */\n    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */\n    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */\n    tmp0  = tmp1 + tmp2 + tmp3 -\n            MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */\n    tmp13 = tmp10 + tmp11 + tmp12 -\n            MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */\n    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */\n    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */\n    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */\n    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */\n    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */\n    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */\n    z2    += z4;\n    z1    = MULTIPLY(z2, -FIX(0.666655658));       /* -c11 */\n    tmp1  += z1;\n    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */\n    z2    = MULTIPLY(z2, -FIX(1.247225013));       /* -c5 */\n    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */\n    tmp12 += z2;\n    z2    = MULTIPLY(z3 + z4, -FIX(1.353318001));  /* -c3 */\n    tmp2  += z2;\n    tmp3  += z2;\n    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */\n    tmp10 += z2;\n    tmp11 += z2;\n\n    /* Final output stage */\n\n    wsptr[8 * 0]  = (int)RIGHT_SHIFT(tmp20 + tmp0,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 15] = (int)RIGHT_SHIFT(tmp20 - tmp0,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 1]  = (int)RIGHT_SHIFT(tmp21 + tmp1,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 14] = (int)RIGHT_SHIFT(tmp21 - tmp1,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 2]  = (int)RIGHT_SHIFT(tmp22 + tmp2,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 13] = (int)RIGHT_SHIFT(tmp22 - tmp2,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 3]  = (int)RIGHT_SHIFT(tmp23 + tmp3,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 12] = (int)RIGHT_SHIFT(tmp23 - tmp3,  CONST_BITS - PASS1_BITS);\n    wsptr[8 * 4]  = (int)RIGHT_SHIFT(tmp24 + tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 11] = (int)RIGHT_SHIFT(tmp24 - tmp10, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 5]  = (int)RIGHT_SHIFT(tmp25 + tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 10] = (int)RIGHT_SHIFT(tmp25 - tmp11, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 6]  = (int)RIGHT_SHIFT(tmp26 + tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 9]  = (int)RIGHT_SHIFT(tmp26 - tmp12, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 7]  = (int)RIGHT_SHIFT(tmp27 + tmp13, CONST_BITS - PASS1_BITS);\n    wsptr[8 * 8]  = (int)RIGHT_SHIFT(tmp27 - tmp13, CONST_BITS - PASS1_BITS);\n  }\n\n  /* Pass 2: process 16 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 16; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n\n    /* Even part */\n\n    /* Add fudge factor here for final descale. */\n    tmp0 = (JLONG)wsptr[0] + (ONE << (PASS1_BITS + 2));\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS);\n\n    z1 = (JLONG)wsptr[4];\n    tmp1 = MULTIPLY(z1, FIX(1.306562965));      /* c4[16] = c2[8] */\n    tmp2 = MULTIPLY(z1, FIX_0_541196100);       /* c12[16] = c6[8] */\n\n    tmp10 = tmp0 + tmp1;\n    tmp11 = tmp0 - tmp1;\n    tmp12 = tmp0 + tmp2;\n    tmp13 = tmp0 - tmp2;\n\n    z1 = (JLONG)wsptr[2];\n    z2 = (JLONG)wsptr[6];\n    z3 = z1 - z2;\n    z4 = MULTIPLY(z3, FIX(0.275899379));        /* c14[16] = c7[8] */\n    z3 = MULTIPLY(z3, FIX(1.387039845));        /* c2[16] = c1[8] */\n\n    tmp0 = z3 + MULTIPLY(z2, FIX_2_562915447);  /* (c6+c2)[16] = (c3+c1)[8] */\n    tmp1 = z4 + MULTIPLY(z1, FIX_0_899976223);  /* (c6-c14)[16] = (c3-c7)[8] */\n    tmp2 = z3 - MULTIPLY(z1, FIX(0.601344887)); /* (c2-c10)[16] = (c1-c5)[8] */\n    tmp3 = z4 - MULTIPLY(z2, FIX(0.509795579)); /* (c10-c14)[16] = (c5-c7)[8] */\n\n    tmp20 = tmp10 + tmp0;\n    tmp27 = tmp10 - tmp0;\n    tmp21 = tmp12 + tmp1;\n    tmp26 = tmp12 - tmp1;\n    tmp22 = tmp13 + tmp2;\n    tmp25 = tmp13 - tmp2;\n    tmp23 = tmp11 + tmp3;\n    tmp24 = tmp11 - tmp3;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[1];\n    z2 = (JLONG)wsptr[3];\n    z3 = (JLONG)wsptr[5];\n    z4 = (JLONG)wsptr[7];\n\n    tmp11 = z1 + z3;\n\n    tmp1  = MULTIPLY(z1 + z2, FIX(1.353318001));   /* c3 */\n    tmp2  = MULTIPLY(tmp11,   FIX(1.247225013));   /* c5 */\n    tmp3  = MULTIPLY(z1 + z4, FIX(1.093201867));   /* c7 */\n    tmp10 = MULTIPLY(z1 - z4, FIX(0.897167586));   /* c9 */\n    tmp11 = MULTIPLY(tmp11,   FIX(0.666655658));   /* c11 */\n    tmp12 = MULTIPLY(z1 - z2, FIX(0.410524528));   /* c13 */\n    tmp0  = tmp1 + tmp2 + tmp3 -\n            MULTIPLY(z1, FIX(2.286341144));        /* c7+c5+c3-c1 */\n    tmp13 = tmp10 + tmp11 + tmp12 -\n            MULTIPLY(z1, FIX(1.835730603));        /* c9+c11+c13-c15 */\n    z1    = MULTIPLY(z2 + z3, FIX(0.138617169));   /* c15 */\n    tmp1  += z1 + MULTIPLY(z2, FIX(0.071888074));  /* c9+c11-c3-c15 */\n    tmp2  += z1 - MULTIPLY(z3, FIX(1.125726048));  /* c5+c7+c15-c3 */\n    z1    = MULTIPLY(z3 - z2, FIX(1.407403738));   /* c1 */\n    tmp11 += z1 - MULTIPLY(z3, FIX(0.766367282));  /* c1+c11-c9-c13 */\n    tmp12 += z1 + MULTIPLY(z2, FIX(1.971951411));  /* c1+c5+c13-c7 */\n    z2    += z4;\n    z1    = MULTIPLY(z2, -FIX(0.666655658));       /* -c11 */\n    tmp1  += z1;\n    tmp3  += z1 + MULTIPLY(z4, FIX(1.065388962));  /* c3+c11+c15-c7 */\n    z2    = MULTIPLY(z2, -FIX(1.247225013));       /* -c5 */\n    tmp10 += z2 + MULTIPLY(z4, FIX(3.141271809));  /* c1+c5+c9-c13 */\n    tmp12 += z2;\n    z2    = MULTIPLY(z3 + z4, -FIX(1.353318001));  /* -c3 */\n    tmp2  += z2;\n    tmp3  += z2;\n    z2    = MULTIPLY(z4 - z3, FIX(0.410524528));   /* c13 */\n    tmp10 += z2;\n    tmp11 += z2;\n\n    /* Final output stage */\n\n    outptr[0]  = range_limit[(int)RIGHT_SHIFT(tmp20 + tmp0,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[15] = range_limit[(int)RIGHT_SHIFT(tmp20 - tmp0,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[1]  = range_limit[(int)RIGHT_SHIFT(tmp21 + tmp1,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[14] = range_limit[(int)RIGHT_SHIFT(tmp21 - tmp1,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[2]  = range_limit[(int)RIGHT_SHIFT(tmp22 + tmp2,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[13] = range_limit[(int)RIGHT_SHIFT(tmp22 - tmp2,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[3]  = range_limit[(int)RIGHT_SHIFT(tmp23 + tmp3,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[12] = range_limit[(int)RIGHT_SHIFT(tmp23 - tmp3,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[4]  = range_limit[(int)RIGHT_SHIFT(tmp24 + tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[11] = range_limit[(int)RIGHT_SHIFT(tmp24 - tmp10,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[5]  = range_limit[(int)RIGHT_SHIFT(tmp25 + tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[10] = range_limit[(int)RIGHT_SHIFT(tmp25 - tmp11,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[6]  = range_limit[(int)RIGHT_SHIFT(tmp26 + tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[9]  = range_limit[(int)RIGHT_SHIFT(tmp26 - tmp12,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[7]  = range_limit[(int)RIGHT_SHIFT(tmp27 + tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n    outptr[8]  = range_limit[(int)RIGHT_SHIFT(tmp27 - tmp13,\n                                              CONST_BITS + PASS1_BITS + 3) &\n                             RANGE_MASK];\n\n    wsptr += 8;         /* advance pointer to next row */\n  }\n}\n\n#endif /* IDCT_SCALING_SUPPORTED */\n#endif /* DCT_ISLOW_SUPPORTED */\n"
        },
        {
          "name": "jidctred.c",
          "type": "blob",
          "size": 14.2138671875,
          "content": "/*\n * jidctred.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1998, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains inverse-DCT routines that produce reduced-size output:\n * either 4x4, 2x2, or 1x1 pixels from an 8x8 DCT block.\n *\n * The implementation is based on the Loeffler, Ligtenberg and Moschytz (LL&M)\n * algorithm used in jidctint.c.  We simply replace each 8-to-8 1-D IDCT step\n * with an 8-to-4 step that produces the four averages of two adjacent outputs\n * (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).\n * These steps were derived by computing the corresponding values at the end\n * of the normal LL&M code, then simplifying as much as possible.\n *\n * 1x1 is trivial: just take the DC coefficient divided by 8.\n *\n * See jidctint.c for additional comments.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jdct.h\"               /* Private declarations for DCT subsystem */\n\n#ifdef IDCT_SCALING_SUPPORTED\n\n\n/*\n * This module is specialized to the case DCTSIZE = 8.\n */\n\n#if DCTSIZE != 8\n  Sorry, this code only copes with 8x8 DCTs. /* deliberate syntax err */\n#endif\n\n\n/* Scaling is the same as in jidctint.c. */\n\n#if BITS_IN_JSAMPLE == 8\n#define CONST_BITS  13\n#define PASS1_BITS  2\n#else\n#define CONST_BITS  13\n#define PASS1_BITS  1           /* lose a little precision to avoid overflow */\n#endif\n\n/* Some C compilers fail to reduce \"FIX(constant)\" at compile time, thus\n * causing a lot of useless floating-point operations at run time.\n * To get around this we use the following pre-calculated constants.\n * If you change CONST_BITS you may want to add appropriate values.\n * (With a reasonable C compiler, you can just rely on the FIX() macro...)\n */\n\n#if CONST_BITS == 13\n#define FIX_0_211164243  ((JLONG)1730)          /* FIX(0.211164243) */\n#define FIX_0_509795579  ((JLONG)4176)          /* FIX(0.509795579) */\n#define FIX_0_601344887  ((JLONG)4926)          /* FIX(0.601344887) */\n#define FIX_0_720959822  ((JLONG)5906)          /* FIX(0.720959822) */\n#define FIX_0_765366865  ((JLONG)6270)          /* FIX(0.765366865) */\n#define FIX_0_850430095  ((JLONG)6967)          /* FIX(0.850430095) */\n#define FIX_0_899976223  ((JLONG)7373)          /* FIX(0.899976223) */\n#define FIX_1_061594337  ((JLONG)8697)          /* FIX(1.061594337) */\n#define FIX_1_272758580  ((JLONG)10426)         /* FIX(1.272758580) */\n#define FIX_1_451774981  ((JLONG)11893)         /* FIX(1.451774981) */\n#define FIX_1_847759065  ((JLONG)15137)         /* FIX(1.847759065) */\n#define FIX_2_172734803  ((JLONG)17799)         /* FIX(2.172734803) */\n#define FIX_2_562915447  ((JLONG)20995)         /* FIX(2.562915447) */\n#define FIX_3_624509785  ((JLONG)29692)         /* FIX(3.624509785) */\n#else\n#define FIX_0_211164243  FIX(0.211164243)\n#define FIX_0_509795579  FIX(0.509795579)\n#define FIX_0_601344887  FIX(0.601344887)\n#define FIX_0_720959822  FIX(0.720959822)\n#define FIX_0_765366865  FIX(0.765366865)\n#define FIX_0_850430095  FIX(0.850430095)\n#define FIX_0_899976223  FIX(0.899976223)\n#define FIX_1_061594337  FIX(1.061594337)\n#define FIX_1_272758580  FIX(1.272758580)\n#define FIX_1_451774981  FIX(1.451774981)\n#define FIX_1_847759065  FIX(1.847759065)\n#define FIX_2_172734803  FIX(2.172734803)\n#define FIX_2_562915447  FIX(2.562915447)\n#define FIX_3_624509785  FIX(3.624509785)\n#endif\n\n\n/* Multiply a JLONG variable by a JLONG constant to yield a JLONG result.\n * For 8-bit samples with the recommended scaling, all the variable\n * and constant values involved are no more than 16 bits wide, so a\n * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.\n * For 12-bit samples, a full 32-bit multiplication will be needed.\n */\n\n#if BITS_IN_JSAMPLE == 8\n#define MULTIPLY(var, const)  MULTIPLY16C16(var, const)\n#else\n#define MULTIPLY(var, const)  ((var) * (const))\n#endif\n\n\n/* Dequantize a coefficient by multiplying it by the multiplier-table\n * entry; produce an int result.  In this module, both inputs and result\n * are 16 bits or less, so either int or short multiply will work.\n */\n\n#define DEQUANTIZE(coef, quantval)  (((ISLOW_MULT_TYPE)(coef)) * (quantval))\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 4x4 output block.\n */\n\nGLOBAL(void)\n_jpeg_idct_4x4(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n               JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n               JDIMENSION output_col)\n{\n  JLONG tmp0, tmp2, tmp10, tmp12;\n  JLONG z1, z2, z3, z4;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE * 4];   /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {\n    /* Don't bother to process column 4, because second pass won't use it */\n    if (ctr == DCTSIZE - 4)\n      continue;\n    if (inptr[DCTSIZE * 1] == 0 && inptr[DCTSIZE * 2] == 0 &&\n        inptr[DCTSIZE * 3] == 0 && inptr[DCTSIZE * 5] == 0 &&\n        inptr[DCTSIZE * 6] == 0 && inptr[DCTSIZE * 7] == 0) {\n      /* AC terms all zero; we need not examine term 4 for 4x4 output */\n      int dcval = LEFT_SHIFT(DEQUANTIZE(inptr[DCTSIZE * 0],\n                                        quantptr[DCTSIZE * 0]), PASS1_BITS);\n\n      wsptr[DCTSIZE * 0] = dcval;\n      wsptr[DCTSIZE * 1] = dcval;\n      wsptr[DCTSIZE * 2] = dcval;\n      wsptr[DCTSIZE * 3] = dcval;\n\n      continue;\n    }\n\n    /* Even part */\n\n    tmp0 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp0 = LEFT_SHIFT(tmp0, CONST_BITS + 1);\n\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 2], quantptr[DCTSIZE * 2]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 6], quantptr[DCTSIZE * 6]);\n\n    tmp2 = MULTIPLY(z2, FIX_1_847759065) + MULTIPLY(z3, -FIX_0_765366865);\n\n    tmp10 = tmp0 + tmp2;\n    tmp12 = tmp0 - tmp2;\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n    z2 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    z3 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    z4 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n\n    tmp0 = MULTIPLY(z1, -FIX_0_211164243) + /* sqrt(2) * ( c3-c1) */\n           MULTIPLY(z2,  FIX_1_451774981) + /* sqrt(2) * ( c3+c7) */\n           MULTIPLY(z3, -FIX_2_172734803) + /* sqrt(2) * (-c1-c5) */\n           MULTIPLY(z4,  FIX_1_061594337);  /* sqrt(2) * ( c5+c7) */\n\n    tmp2 = MULTIPLY(z1, -FIX_0_509795579) + /* sqrt(2) * (c7-c5) */\n           MULTIPLY(z2, -FIX_0_601344887) + /* sqrt(2) * (c5-c1) */\n           MULTIPLY(z3,  FIX_0_899976223) + /* sqrt(2) * (c3-c7) */\n           MULTIPLY(z4,  FIX_2_562915447);  /* sqrt(2) * (c1+c3) */\n\n    /* Final output stage */\n\n    wsptr[DCTSIZE * 0] =\n      (int)DESCALE(tmp10 + tmp2, CONST_BITS - PASS1_BITS + 1);\n    wsptr[DCTSIZE * 3] =\n      (int)DESCALE(tmp10 - tmp2, CONST_BITS - PASS1_BITS + 1);\n    wsptr[DCTSIZE * 1] =\n      (int)DESCALE(tmp12 + tmp0, CONST_BITS - PASS1_BITS + 1);\n    wsptr[DCTSIZE * 2] =\n      (int)DESCALE(tmp12 - tmp0, CONST_BITS - PASS1_BITS + 1);\n  }\n\n  /* Pass 2: process 4 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 4; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* It's not clear whether a zero row test is worthwhile here ... */\n\n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 &&\n        wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      _JSAMPLE dcval = range_limit[(int)DESCALE((JLONG)wsptr[0],\n                                                PASS1_BITS + 3) & RANGE_MASK];\n\n      outptr[0] = dcval;\n      outptr[1] = dcval;\n      outptr[2] = dcval;\n      outptr[3] = dcval;\n\n      wsptr += DCTSIZE;         /* advance pointer to next row */\n      continue;\n    }\n#endif\n\n    /* Even part */\n\n    tmp0 = LEFT_SHIFT((JLONG)wsptr[0], CONST_BITS + 1);\n\n    tmp2 = MULTIPLY((JLONG)wsptr[2],  FIX_1_847759065) +\n           MULTIPLY((JLONG)wsptr[6], -FIX_0_765366865);\n\n    tmp10 = tmp0 + tmp2;\n    tmp12 = tmp0 - tmp2;\n\n    /* Odd part */\n\n    z1 = (JLONG)wsptr[7];\n    z2 = (JLONG)wsptr[5];\n    z3 = (JLONG)wsptr[3];\n    z4 = (JLONG)wsptr[1];\n\n    tmp0 = MULTIPLY(z1, -FIX_0_211164243) + /* sqrt(2) * ( c3-c1) */\n           MULTIPLY(z2,  FIX_1_451774981) + /* sqrt(2) * ( c3+c7) */\n           MULTIPLY(z3, -FIX_2_172734803) + /* sqrt(2) * (-c1-c5) */\n           MULTIPLY(z4,  FIX_1_061594337);  /* sqrt(2) * ( c5+c7) */\n\n    tmp2 = MULTIPLY(z1, -FIX_0_509795579) + /* sqrt(2) * (c7-c5) */\n           MULTIPLY(z2, -FIX_0_601344887) + /* sqrt(2) * (c5-c1) */\n           MULTIPLY(z3, FIX_0_899976223) +  /* sqrt(2) * (c3-c7) */\n           MULTIPLY(z4, FIX_2_562915447);   /* sqrt(2) * (c1+c3) */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)DESCALE(tmp10 + tmp2,\n                                         CONST_BITS + PASS1_BITS + 3 + 1) &\n                            RANGE_MASK];\n    outptr[3] = range_limit[(int)DESCALE(tmp10 - tmp2,\n                                         CONST_BITS + PASS1_BITS + 3 + 1) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)DESCALE(tmp12 + tmp0,\n                                         CONST_BITS + PASS1_BITS + 3 + 1) &\n                            RANGE_MASK];\n    outptr[2] = range_limit[(int)DESCALE(tmp12 - tmp0,\n                                         CONST_BITS + PASS1_BITS + 3 + 1) &\n                            RANGE_MASK];\n\n    wsptr += DCTSIZE;           /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 2x2 output block.\n */\n\nGLOBAL(void)\n_jpeg_idct_2x2(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n               JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n               JDIMENSION output_col)\n{\n  JLONG tmp0, tmp10, z1;\n  JCOEFPTR inptr;\n  ISLOW_MULT_TYPE *quantptr;\n  int *wsptr;\n  _JSAMPROW outptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  int ctr;\n  int workspace[DCTSIZE * 2];   /* buffers data between passes */\n  SHIFT_TEMPS\n\n  /* Pass 1: process columns from input, store into work array. */\n\n  inptr = coef_block;\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  wsptr = workspace;\n  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {\n    /* Don't bother to process columns 2,4,6 */\n    if (ctr == DCTSIZE - 2 || ctr == DCTSIZE - 4 || ctr == DCTSIZE - 6)\n      continue;\n    if (inptr[DCTSIZE * 1] == 0 && inptr[DCTSIZE * 3] == 0 &&\n        inptr[DCTSIZE * 5] == 0 && inptr[DCTSIZE * 7] == 0) {\n      /* AC terms all zero; we need not examine terms 2,4,6 for 2x2 output */\n      int dcval = LEFT_SHIFT(DEQUANTIZE(inptr[DCTSIZE * 0],\n                             quantptr[DCTSIZE * 0]), PASS1_BITS);\n\n      wsptr[DCTSIZE * 0] = dcval;\n      wsptr[DCTSIZE * 1] = dcval;\n\n      continue;\n    }\n\n    /* Even part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 0], quantptr[DCTSIZE * 0]);\n    tmp10 = LEFT_SHIFT(z1, CONST_BITS + 2);\n\n    /* Odd part */\n\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 7], quantptr[DCTSIZE * 7]);\n    tmp0 = MULTIPLY(z1, -FIX_0_720959822);  /* sqrt(2) * ( c7-c5+c3-c1) */\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 5], quantptr[DCTSIZE * 5]);\n    tmp0 += MULTIPLY(z1, FIX_0_850430095);  /* sqrt(2) * (-c1+c3+c5+c7) */\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 3], quantptr[DCTSIZE * 3]);\n    tmp0 += MULTIPLY(z1, -FIX_1_272758580); /* sqrt(2) * (-c1+c3-c5-c7) */\n    z1 = DEQUANTIZE(inptr[DCTSIZE * 1], quantptr[DCTSIZE * 1]);\n    tmp0 += MULTIPLY(z1, FIX_3_624509785);  /* sqrt(2) * ( c1+c3+c5+c7) */\n\n    /* Final output stage */\n\n    wsptr[DCTSIZE * 0] =\n      (int)DESCALE(tmp10 + tmp0, CONST_BITS - PASS1_BITS + 2);\n    wsptr[DCTSIZE * 1] =\n      (int)DESCALE(tmp10 - tmp0, CONST_BITS - PASS1_BITS + 2);\n  }\n\n  /* Pass 2: process 2 rows from work array, store into output array. */\n\n  wsptr = workspace;\n  for (ctr = 0; ctr < 2; ctr++) {\n    outptr = output_buf[ctr] + output_col;\n    /* It's not clear whether a zero row test is worthwhile here ... */\n\n#ifndef NO_ZERO_ROW_TEST\n    if (wsptr[1] == 0 && wsptr[3] == 0 && wsptr[5] == 0 && wsptr[7] == 0) {\n      /* AC terms all zero */\n      _JSAMPLE dcval = range_limit[(int)DESCALE((JLONG)wsptr[0],\n                                                PASS1_BITS + 3) & RANGE_MASK];\n\n      outptr[0] = dcval;\n      outptr[1] = dcval;\n\n      wsptr += DCTSIZE;         /* advance pointer to next row */\n      continue;\n    }\n#endif\n\n    /* Even part */\n\n    tmp10 = LEFT_SHIFT((JLONG)wsptr[0], CONST_BITS + 2);\n\n    /* Odd part */\n\n    tmp0 = MULTIPLY((JLONG)wsptr[7], -FIX_0_720959822) + /* sqrt(2) * ( c7-c5+c3-c1) */\n           MULTIPLY((JLONG)wsptr[5],  FIX_0_850430095) + /* sqrt(2) * (-c1+c3+c5+c7) */\n           MULTIPLY((JLONG)wsptr[3], -FIX_1_272758580) + /* sqrt(2) * (-c1+c3-c5-c7) */\n           MULTIPLY((JLONG)wsptr[1],  FIX_3_624509785);  /* sqrt(2) * ( c1+c3+c5+c7) */\n\n    /* Final output stage */\n\n    outptr[0] = range_limit[(int)DESCALE(tmp10 + tmp0,\n                                         CONST_BITS + PASS1_BITS + 3 + 2) &\n                            RANGE_MASK];\n    outptr[1] = range_limit[(int)DESCALE(tmp10 - tmp0,\n                                         CONST_BITS + PASS1_BITS + 3 + 2) &\n                            RANGE_MASK];\n\n    wsptr += DCTSIZE;           /* advance pointer to next row */\n  }\n}\n\n\n/*\n * Perform dequantization and inverse DCT on one block of coefficients,\n * producing a reduced-size 1x1 output block.\n */\n\nGLOBAL(void)\n_jpeg_idct_1x1(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n               JCOEFPTR coef_block, _JSAMPARRAY output_buf,\n               JDIMENSION output_col)\n{\n  int dcval;\n  ISLOW_MULT_TYPE *quantptr;\n  _JSAMPLE *range_limit = IDCT_range_limit(cinfo);\n  SHIFT_TEMPS\n\n  /* We hardly need an inverse DCT routine for this: just take the\n   * average pixel value, which is one-eighth of the DC coefficient.\n   */\n  quantptr = (ISLOW_MULT_TYPE *)compptr->dct_table;\n  dcval = DEQUANTIZE(coef_block[0], quantptr[0]);\n  dcval = (int)DESCALE((JLONG)dcval, 3);\n\n  output_buf[0][output_col] = range_limit[dcval & RANGE_MASK];\n}\n\n#endif /* IDCT_SCALING_SUPPORTED */\n"
        },
        {
          "name": "jinclude.h",
          "type": "blob",
          "size": 3.11328125,
          "content": "/*\n * jinclude.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1994, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file exists to provide a single place to fix any problems with\n * including the wrong system include files.  (Common problems are taken\n * care of by the standard jconfig symbols, but on really weird systems\n * you may have to edit this file.)\n *\n * NOTE: this file is NOT intended to be included by applications using the\n * JPEG library.  Most applications need only include jpeglib.h.\n */\n\n#ifndef __JINCLUDE_H__\n#define __JINCLUDE_H__\n\n/* Include auto-config file to find out which system include files we need. */\n\n#include \"jconfig.h\"            /* auto configuration options */\n#include \"jconfigint.h\"\n#define JCONFIG_INCLUDED        /* so that jpeglib.h doesn't do it again */\n\n/*\n * Note that the core JPEG library does not require <stdio.h>;\n * only the default error handler and data source/destination modules do.\n * But we must pull it in because of the references to FILE in jpeglib.h.\n * You can remove those references if you want to compile without <stdio.h>.\n */\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n/*\n * These macros/inline functions facilitate using Microsoft's \"safe string\"\n * functions with Visual Studio builds without the need to scatter #ifdefs\n * throughout the code base.\n */\n\n\n#ifdef _MSC_VER\n\n#define SNPRINTF(str, n, format, ...) \\\n  _snprintf_s(str, n, _TRUNCATE, format, ##__VA_ARGS__)\n\n#else\n\n#define SNPRINTF  snprintf\n\n#endif\n\n\n#ifndef NO_GETENV\n\n#ifdef _MSC_VER\n\nstatic INLINE int GETENV_S(char *buffer, size_t buffer_size, const char *name)\n{\n  size_t required_size;\n\n  return (int)getenv_s(&required_size, buffer, buffer_size, name);\n}\n\n#else /* _MSC_VER */\n\n#include <errno.h>\n\n/* This provides a similar interface to the Microsoft/C11 getenv_s() function,\n * but other than parameter validation, it has no advantages over getenv().\n */\n\nstatic INLINE int GETENV_S(char *buffer, size_t buffer_size, const char *name)\n{\n  char *env;\n\n  if (!buffer) {\n    if (buffer_size == 0)\n      return 0;\n    else\n      return (errno = EINVAL);\n  }\n  if (buffer_size == 0)\n    return (errno = EINVAL);\n  if (!name) {\n    *buffer = 0;\n    return 0;\n  }\n\n  env = getenv(name);\n  if (!env)\n  {\n    *buffer = 0;\n    return 0;\n  }\n\n  if (strlen(env) + 1 > buffer_size) {\n    *buffer = 0;\n    return ERANGE;\n  }\n\n  strncpy(buffer, env, buffer_size);\n\n  return 0;\n}\n\n#endif /* _MSC_VER */\n\n#endif /* NO_GETENV */\n\n\n#ifndef NO_PUTENV\n\n#ifdef _WIN32\n\n#define PUTENV_S(name, value)  _putenv_s(name, value)\n\n#else\n\n#include <errno.h>\n\n/* This provides a similar interface to the Microsoft _putenv_s() function, but\n * other than parameter validation, it has no advantages over setenv().\n */\n\nstatic INLINE int PUTENV_S(const char *name, const char *value)\n{\n  if (!name || !value)\n    return (errno = EINVAL);\n\n  setenv(name, value, 1);\n\n  return errno;\n}\n\n#endif /* _WIN32 */\n\n#endif /* NO_PUTENV */\n\n\n#endif /* JINCLUDE_H */\n"
        },
        {
          "name": "jlossls.h",
          "type": "blob",
          "size": 3.1591796875,
          "content": "/*\n * jlossls.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1998, Thomas G. Lane.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This include file contains common declarations for the lossless JPEG\n * codec modules.\n */\n\n#ifndef JLOSSLS_H\n#define JLOSSLS_H\n\n#if defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED)\n\n#define JPEG_INTERNALS\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n\n\n#define ALLOC_DARRAY(pool_id, diffsperrow, numrows) \\\n  (JDIFFARRAY)(*cinfo->mem->alloc_sarray) \\\n    ((j_common_ptr)cinfo, pool_id, \\\n     (diffsperrow) * sizeof(JDIFF) / sizeof(_JSAMPLE), numrows)\n\n\n/*\n * Table H.1: Predictors for lossless coding.\n */\n\n#define PREDICTOR1  Ra\n#define PREDICTOR2  Rb\n#define PREDICTOR3  Rc\n#define PREDICTOR4  (int)((JLONG)Ra + (JLONG)Rb - (JLONG)Rc)\n#define PREDICTOR5  (int)((JLONG)Ra + RIGHT_SHIFT((JLONG)Rb - (JLONG)Rc, 1))\n#define PREDICTOR6  (int)((JLONG)Rb + RIGHT_SHIFT((JLONG)Ra - (JLONG)Rc, 1))\n#define PREDICTOR7  (int)RIGHT_SHIFT((JLONG)Ra + (JLONG)Rb, 1)\n\n#endif\n\n\n#ifdef C_LOSSLESS_SUPPORTED\n\ntypedef void (*predict_difference_method_ptr) (j_compress_ptr cinfo, int ci,\n                                               _JSAMPROW input_buf,\n                                               _JSAMPROW prev_row,\n                                               JDIFFROW diff_buf,\n                                               JDIMENSION width);\n\n/* Lossless compressor */\ntypedef struct {\n  struct jpeg_forward_dct pub;  /* public fields */\n\n  /* It is useful to allow each component to have a separate diff method. */\n  predict_difference_method_ptr predict_difference[MAX_COMPONENTS];\n\n  /* MCU rows left in the restart interval for each component */\n  unsigned int restart_rows_to_go[MAX_COMPONENTS];\n\n  /* Sample scaling */\n  void (*scaler_scale) (j_compress_ptr cinfo, _JSAMPROW input_buf,\n                        _JSAMPROW output_buf, JDIMENSION width);\n} jpeg_lossless_compressor;\n\ntypedef jpeg_lossless_compressor *lossless_comp_ptr;\n\n#endif /* C_LOSSLESS_SUPPORTED */\n\n\n#ifdef D_LOSSLESS_SUPPORTED\n\ntypedef void (*predict_undifference_method_ptr) (j_decompress_ptr cinfo,\n                                                 int comp_index,\n                                                 JDIFFROW diff_buf,\n                                                 JDIFFROW prev_row,\n                                                 JDIFFROW undiff_buf,\n                                                 JDIMENSION width);\n\n/* Lossless decompressor */\ntypedef struct {\n  struct jpeg_inverse_dct pub;  /* public fields */\n\n  /* It is useful to allow each component to have a separate undiff method. */\n  predict_undifference_method_ptr predict_undifference[MAX_COMPONENTS];\n\n  /* Sample scaling */\n  void (*scaler_scale) (j_decompress_ptr cinfo, JDIFFROW diff_buf,\n                        _JSAMPROW output_buf, JDIMENSION width);\n} jpeg_lossless_decompressor;\n\ntypedef jpeg_lossless_decompressor *lossless_decomp_ptr;\n\n#endif /* D_LOSSLESS_SUPPORTED */\n\n#endif /* JLOSSLS_H */\n"
        },
        {
          "name": "jmemmgr.c",
          "type": "blob",
          "size": 48.8359375,
          "content": "/*\n * jmemmgr.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2016, 2021-2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains the JPEG system-independent memory management\n * routines.  This code is usable across a wide variety of machines; most\n * of the system dependencies have been isolated in a separate file.\n * The major functions provided here are:\n *   * pool-based allocation and freeing of memory;\n *   * policy decisions about how to divide available memory among the\n *     virtual arrays;\n *   * control logic for swapping virtual arrays between main memory and\n *     backing storage.\n * The separate system-dependent file provides the actual backing-storage\n * access code, and it contains the policy decision about how much total\n * main memory to use.\n * This file is system-dependent in the sense that some of its functions\n * are unnecessary in some systems.  For example, if there is enough virtual\n * memory so that backing storage will never be used, much of the virtual\n * array control logic could be removed.  (Of course, if you have that much\n * memory then you shouldn't care about a little bit of unused code...)\n */\n\n#define JPEG_INTERNALS\n#define AM_MEMORY_MANAGER       /* we define jvirt_Xarray_control structs */\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jmemsys.h\"            /* import the system-dependent declarations */\n#if !defined(_MSC_VER) || _MSC_VER > 1600\n#include <stdint.h>\n#endif\n#include <limits.h>\n\n\nLOCAL(size_t)\nround_up_pow2(size_t a, size_t b)\n/* a rounded up to the next multiple of b, i.e. ceil(a/b)*b */\n/* Assumes a >= 0, b > 0, and b is a power of 2 */\n{\n  return ((a + b - 1) & (~(b - 1)));\n}\n\n\n/*\n * Some important notes:\n *   The allocation routines provided here must never return NULL.\n *   They should exit to error_exit if unsuccessful.\n *\n *   It's not a good idea to try to merge the sarray and barray routines,\n *   even though they are textually almost the same, because samples are\n *   usually stored as bytes while coefficients are shorts or ints.  Thus,\n *   in machines where byte pointers have a different representation from\n *   word pointers, the resulting machine code could not be the same.\n */\n\n\n/*\n * Many machines require storage alignment: longs must start on 4-byte\n * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()\n * always returns pointers that are multiples of the worst-case alignment\n * requirement, and we had better do so too.\n * There isn't any really portable way to determine the worst-case alignment\n * requirement.  This module assumes that the alignment requirement is\n * multiples of ALIGN_SIZE.\n * By default, we define ALIGN_SIZE as the maximum of sizeof(double) and\n * sizeof(void *).  This is necessary on some workstations (where doubles\n * really do need 8-byte alignment) and will work fine on nearly everything.\n * We use the maximum of sizeof(double) and sizeof(void *) since sizeof(double)\n * may be insufficient, for example, on CHERI-enabled platforms with 16-byte\n * pointers and a 16-byte alignment requirement.  If your machine has lesser\n * alignment needs, you can save a few bytes by making ALIGN_SIZE smaller.\n * The only place I know of where this will NOT work is certain Macintosh\n * 680x0 compilers that define double as a 10-byte IEEE extended float.\n * Doing 10-byte alignment is counterproductive because longwords won't be\n * aligned well.  Put \"#define ALIGN_SIZE 4\" in jconfig.h if you have\n * such a compiler.\n */\n\n#ifndef ALIGN_SIZE              /* so can override from jconfig.h */\n#ifndef WITH_SIMD\n#define ALIGN_SIZE  MAX(sizeof(void *), sizeof(double))\n#else\n#define ALIGN_SIZE  32 /* Most of the SIMD instructions we support require\n                          16-byte (128-bit) alignment, but AVX2 requires\n                          32-byte alignment. */\n#endif\n#endif\n\n/*\n * We allocate objects from \"pools\", where each pool is gotten with a single\n * request to jpeg_get_small() or jpeg_get_large().  There is no per-object\n * overhead within a pool, except for alignment padding.  Each pool has a\n * header with a link to the next pool of the same class.\n * Small and large pool headers are identical.\n */\n\ntypedef struct small_pool_struct *small_pool_ptr;\n\ntypedef struct small_pool_struct {\n  small_pool_ptr next;          /* next in list of pools */\n  size_t bytes_used;            /* how many bytes already used within pool */\n  size_t bytes_left;            /* bytes still available in this pool */\n} small_pool_hdr;\n\ntypedef struct large_pool_struct *large_pool_ptr;\n\ntypedef struct large_pool_struct {\n  large_pool_ptr next;          /* next in list of pools */\n  size_t bytes_used;            /* how many bytes already used within pool */\n  size_t bytes_left;            /* bytes still available in this pool */\n} large_pool_hdr;\n\n/*\n * Here is the full definition of a memory manager object.\n */\n\ntypedef struct {\n  struct jpeg_memory_mgr pub;   /* public fields */\n\n  /* Each pool identifier (lifetime class) names a linked list of pools. */\n  small_pool_ptr small_list[JPOOL_NUMPOOLS];\n  large_pool_ptr large_list[JPOOL_NUMPOOLS];\n\n  /* Since we only have one lifetime class of virtual arrays, only one\n   * linked list is necessary (for each datatype).  Note that the virtual\n   * array control blocks being linked together are actually stored somewhere\n   * in the small-pool list.\n   */\n  jvirt_sarray_ptr virt_sarray_list;\n  jvirt_barray_ptr virt_barray_list;\n\n  /* This counts total space obtained from jpeg_get_small/large */\n  size_t total_space_allocated;\n\n  /* alloc_sarray and alloc_barray set this value for use by virtual\n   * array routines.\n   */\n  JDIMENSION last_rowsperchunk; /* from most recent alloc_sarray/barray */\n} my_memory_mgr;\n\ntypedef my_memory_mgr *my_mem_ptr;\n\n\n/*\n * The control blocks for virtual arrays.\n * Note that these blocks are allocated in the \"small\" pool area.\n * System-dependent info for the associated backing store (if any) is hidden\n * inside the backing_store_info struct.\n */\n\nstruct jvirt_sarray_control {\n  JSAMPARRAY mem_buffer;        /* => the in-memory buffer (if\n                                   cinfo->data_precision is 12, then this is\n                                   actually a J12SAMPARRAY) */\n  JDIMENSION rows_in_array;     /* total virtual array height */\n  JDIMENSION samplesperrow;     /* width of array (and of memory buffer) */\n  JDIMENSION maxaccess;         /* max rows accessed by access_virt_sarray */\n  JDIMENSION rows_in_mem;       /* height of memory buffer */\n  JDIMENSION rowsperchunk;      /* allocation chunk size in mem_buffer */\n  JDIMENSION cur_start_row;     /* first logical row # in the buffer */\n  JDIMENSION first_undef_row;   /* row # of first uninitialized row */\n  boolean pre_zero;             /* pre-zero mode requested? */\n  boolean dirty;                /* do current buffer contents need written? */\n  boolean b_s_open;             /* is backing-store data valid? */\n  jvirt_sarray_ptr next;        /* link to next virtual sarray control block */\n  backing_store_info b_s_info;  /* System-dependent control info */\n};\n\nstruct jvirt_barray_control {\n  JBLOCKARRAY mem_buffer;       /* => the in-memory buffer */\n  JDIMENSION rows_in_array;     /* total virtual array height */\n  JDIMENSION blocksperrow;      /* width of array (and of memory buffer) */\n  JDIMENSION maxaccess;         /* max rows accessed by access_virt_barray */\n  JDIMENSION rows_in_mem;       /* height of memory buffer */\n  JDIMENSION rowsperchunk;      /* allocation chunk size in mem_buffer */\n  JDIMENSION cur_start_row;     /* first logical row # in the buffer */\n  JDIMENSION first_undef_row;   /* row # of first uninitialized row */\n  boolean pre_zero;             /* pre-zero mode requested? */\n  boolean dirty;                /* do current buffer contents need written? */\n  boolean b_s_open;             /* is backing-store data valid? */\n  jvirt_barray_ptr next;        /* link to next virtual barray control block */\n  backing_store_info b_s_info;  /* System-dependent control info */\n};\n\n\n#ifdef MEM_STATS                /* optional extra stuff for statistics */\n\nLOCAL(void)\nprint_mem_stats(j_common_ptr cinfo, int pool_id)\n{\n  my_mem_ptr mem = (my_mem_ptr)cinfo->mem;\n  small_pool_ptr shdr_ptr;\n  large_pool_ptr lhdr_ptr;\n\n  /* Since this is only a debugging stub, we can cheat a little by using\n   * fprintf directly rather than going through the trace message code.\n   * This is helpful because message parm array can't handle longs.\n   */\n  fprintf(stderr, \"Freeing pool %d, total space = %ld\\n\",\n          pool_id, mem->total_space_allocated);\n\n  for (lhdr_ptr = mem->large_list[pool_id]; lhdr_ptr != NULL;\n       lhdr_ptr = lhdr_ptr->next) {\n    fprintf(stderr, \"  Large chunk used %ld\\n\", (long)lhdr_ptr->bytes_used);\n  }\n\n  for (shdr_ptr = mem->small_list[pool_id]; shdr_ptr != NULL;\n       shdr_ptr = shdr_ptr->next) {\n    fprintf(stderr, \"  Small chunk used %ld free %ld\\n\",\n            (long)shdr_ptr->bytes_used, (long)shdr_ptr->bytes_left);\n  }\n}\n\n#endif /* MEM_STATS */\n\n\nLOCAL(void)\nout_of_memory(j_common_ptr cinfo, int which)\n/* Report an out-of-memory error and stop execution */\n/* If we compiled MEM_STATS support, report alloc requests before dying */\n{\n#ifdef MEM_STATS\n  cinfo->err->trace_level = 2;  /* force self_destruct to report stats */\n#endif\n  ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);\n}\n\n\n/*\n * Allocation of \"small\" objects.\n *\n * For these, we use pooled storage.  When a new pool must be created,\n * we try to get enough space for the current request plus a \"slop\" factor,\n * where the slop will be the amount of leftover space in the new pool.\n * The speed vs. space tradeoff is largely determined by the slop values.\n * A different slop value is provided for each pool class (lifetime),\n * and we also distinguish the first pool of a class from later ones.\n * NOTE: the values given work fairly well on both 16- and 32-bit-int\n * machines, but may be too small if longs are 64 bits or more.\n *\n * Since we do not know what alignment malloc() gives us, we have to\n * allocate ALIGN_SIZE-1 extra space per pool to have room for alignment\n * adjustment.\n */\n\nstatic const size_t first_pool_slop[JPOOL_NUMPOOLS] = {\n  1600,                         /* first PERMANENT pool */\n  16000                         /* first IMAGE pool */\n};\n\nstatic const size_t extra_pool_slop[JPOOL_NUMPOOLS] = {\n  0,                            /* additional PERMANENT pools */\n  5000                          /* additional IMAGE pools */\n};\n\n#define MIN_SLOP  50            /* greater than 0 to avoid futile looping */\n\n\nMETHODDEF(void *)\nalloc_small(j_common_ptr cinfo, int pool_id, size_t sizeofobject)\n/* Allocate a \"small\" object */\n{\n  my_mem_ptr mem = (my_mem_ptr)cinfo->mem;\n  small_pool_ptr hdr_ptr, prev_hdr_ptr;\n  char *data_ptr;\n  size_t min_request, slop;\n\n  /*\n   * Round up the requested size to a multiple of ALIGN_SIZE in order\n   * to assure alignment for the next object allocated in the same pool\n   * and so that algorithms can straddle outside the proper area up\n   * to the next alignment.\n   */\n  if (sizeofobject > MAX_ALLOC_CHUNK) {\n    /* This prevents overflow/wrap-around in round_up_pow2() if sizeofobject\n       is close to SIZE_MAX. */\n    out_of_memory(cinfo, 7);\n  }\n  sizeofobject = round_up_pow2(sizeofobject, ALIGN_SIZE);\n\n  /* Check for unsatisfiable request (do now to ensure no overflow below) */\n  if ((sizeof(small_pool_hdr) + sizeofobject + ALIGN_SIZE - 1) >\n      MAX_ALLOC_CHUNK)\n    out_of_memory(cinfo, 1);    /* request exceeds malloc's ability */\n\n  /* See if space is available in any existing pool */\n  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)\n    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id); /* safety check */\n  prev_hdr_ptr = NULL;\n  hdr_ptr = mem->small_list[pool_id];\n  while (hdr_ptr != NULL) {\n    if (hdr_ptr->bytes_left >= sizeofobject)\n      break;                    /* found pool with enough space */\n    prev_hdr_ptr = hdr_ptr;\n    hdr_ptr = hdr_ptr->next;\n  }\n\n  /* Time to make a new pool? */\n  if (hdr_ptr == NULL) {\n    /* min_request is what we need now, slop is what will be leftover */\n    min_request = sizeof(small_pool_hdr) + sizeofobject + ALIGN_SIZE - 1;\n    if (prev_hdr_ptr == NULL)   /* first pool in class? */\n      slop = first_pool_slop[pool_id];\n    else\n      slop = extra_pool_slop[pool_id];\n    /* Don't ask for more than MAX_ALLOC_CHUNK */\n    if (slop > (size_t)(MAX_ALLOC_CHUNK - min_request))\n      slop = (size_t)(MAX_ALLOC_CHUNK - min_request);\n    /* Try to get space, if fail reduce slop and try again */\n    for (;;) {\n      hdr_ptr = (small_pool_ptr)jpeg_get_small(cinfo, min_request + slop);\n      if (hdr_ptr != NULL)\n        break;\n      slop /= 2;\n      if (slop < MIN_SLOP)      /* give up when it gets real small */\n        out_of_memory(cinfo, 2); /* jpeg_get_small failed */\n    }\n    mem->total_space_allocated += min_request + slop;\n    /* Success, initialize the new pool header and add to end of list */\n    hdr_ptr->next = NULL;\n    hdr_ptr->bytes_used = 0;\n    hdr_ptr->bytes_left = sizeofobject + slop;\n    if (prev_hdr_ptr == NULL)   /* first pool in class? */\n      mem->small_list[pool_id] = hdr_ptr;\n    else\n      prev_hdr_ptr->next = hdr_ptr;\n  }\n\n  /* OK, allocate the object from the current pool */\n  data_ptr = (char *)hdr_ptr; /* point to first data byte in pool... */\n  data_ptr += sizeof(small_pool_hdr); /* ...by skipping the header... */\n  if ((size_t)data_ptr % ALIGN_SIZE) /* ...and adjust for alignment */\n    data_ptr += ALIGN_SIZE - (size_t)data_ptr % ALIGN_SIZE;\n  data_ptr += hdr_ptr->bytes_used; /* point to place for object */\n  hdr_ptr->bytes_used += sizeofobject;\n  hdr_ptr->bytes_left -= sizeofobject;\n\n  return (void *)data_ptr;\n}\n\n\n/*\n * Allocation of \"large\" objects.\n *\n * The external semantics of these are the same as \"small\" objects.  However,\n * the pool management heuristics are quite different.  We assume that each\n * request is large enough that it may as well be passed directly to\n * jpeg_get_large; the pool management just links everything together\n * so that we can free it all on demand.\n * Note: the major use of \"large\" objects is in\n * JSAMPARRAY/J12SAMPARRAY/J16SAMPARRAY and JBLOCKARRAY structures.  The\n * routines that create these structures (see below) deliberately bunch rows\n * together to ensure a large request size.\n */\n\nMETHODDEF(void *)\nalloc_large(j_common_ptr cinfo, int pool_id, size_t sizeofobject)\n/* Allocate a \"large\" object */\n{\n  my_mem_ptr mem = (my_mem_ptr)cinfo->mem;\n  large_pool_ptr hdr_ptr;\n  char *data_ptr;\n\n  /*\n   * Round up the requested size to a multiple of ALIGN_SIZE so that\n   * algorithms can straddle outside the proper area up to the next\n   * alignment.\n   */\n  if (sizeofobject > MAX_ALLOC_CHUNK) {\n    /* This prevents overflow/wrap-around in round_up_pow2() if sizeofobject\n       is close to SIZE_MAX. */\n    out_of_memory(cinfo, 8);\n  }\n  sizeofobject = round_up_pow2(sizeofobject, ALIGN_SIZE);\n\n  /* Check for unsatisfiable request (do now to ensure no overflow below) */\n  if ((sizeof(large_pool_hdr) + sizeofobject + ALIGN_SIZE - 1) >\n      MAX_ALLOC_CHUNK)\n    out_of_memory(cinfo, 3);    /* request exceeds malloc's ability */\n\n  /* Always make a new pool */\n  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)\n    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id); /* safety check */\n\n  hdr_ptr = (large_pool_ptr)jpeg_get_large(cinfo, sizeofobject +\n                                           sizeof(large_pool_hdr) +\n                                           ALIGN_SIZE - 1);\n  if (hdr_ptr == NULL)\n    out_of_memory(cinfo, 4);    /* jpeg_get_large failed */\n  mem->total_space_allocated += sizeofobject + sizeof(large_pool_hdr) +\n                                ALIGN_SIZE - 1;\n\n  /* Success, initialize the new pool header and add to list */\n  hdr_ptr->next = mem->large_list[pool_id];\n  /* We maintain space counts in each pool header for statistical purposes,\n   * even though they are not needed for allocation.\n   */\n  hdr_ptr->bytes_used = sizeofobject;\n  hdr_ptr->bytes_left = 0;\n  mem->large_list[pool_id] = hdr_ptr;\n\n  data_ptr = (char *)hdr_ptr; /* point to first data byte in pool... */\n  data_ptr += sizeof(small_pool_hdr); /* ...by skipping the header... */\n  if ((size_t)data_ptr % ALIGN_SIZE) /* ...and adjust for alignment */\n    data_ptr += ALIGN_SIZE - (size_t)data_ptr % ALIGN_SIZE;\n\n  return (void *)data_ptr;\n}\n\n\n/*\n * Creation of 2-D sample arrays.\n *\n * To minimize allocation overhead and to allow I/O of large contiguous\n * blocks, we allocate the sample rows in groups of as many rows as possible\n * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.\n * NB: the virtual array control routines, later in this file, know about\n * this chunking of rows.  The rowsperchunk value is left in the mem manager\n * object so that it can be saved away if this sarray is the workspace for\n * a virtual array.\n *\n * Since we are often upsampling with a factor 2, we align the size (not\n * the start) to 2 * ALIGN_SIZE so that the upsampling routines don't have\n * to be as careful about size.\n */\n\nMETHODDEF(JSAMPARRAY)\nalloc_sarray(j_common_ptr cinfo, int pool_id, JDIMENSION samplesperrow,\n             JDIMENSION numrows)\n/* Allocate a 2-D sample array */\n{\n  my_mem_ptr mem = (my_mem_ptr)cinfo->mem;\n  JSAMPARRAY result;\n  JSAMPROW workspace;\n  JDIMENSION rowsperchunk, currow, i;\n  long ltemp;\n  J12SAMPARRAY result12;\n  J12SAMPROW workspace12;\n#if defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED)\n  J16SAMPARRAY result16;\n  J16SAMPROW workspace16;\n#endif\n  int data_precision = cinfo->is_decompressor ?\n                        ((j_decompress_ptr)cinfo)->data_precision :\n                        ((j_compress_ptr)cinfo)->data_precision;\n  size_t sample_size = data_precision == 16 ?\n                       sizeof(J16SAMPLE) : (data_precision == 12 ?\n                                            sizeof(J12SAMPLE) :\n                                            sizeof(JSAMPLE));\n\n  /* Make sure each row is properly aligned */\n  if ((ALIGN_SIZE % sample_size) != 0)\n    out_of_memory(cinfo, 5);    /* safety check */\n\n  if (samplesperrow > MAX_ALLOC_CHUNK) {\n    /* This prevents overflow/wrap-around in round_up_pow2() if sizeofobject\n       is close to SIZE_MAX. */\n    out_of_memory(cinfo, 9);\n  }\n  samplesperrow = (JDIMENSION)round_up_pow2(samplesperrow, (2 * ALIGN_SIZE) /\n                                                           sample_size);\n\n  /* Calculate max # of rows allowed in one allocation chunk */\n  ltemp = (MAX_ALLOC_CHUNK - sizeof(large_pool_hdr)) /\n          ((long)samplesperrow * (long)sample_size);\n  if (ltemp <= 0)\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n  if (ltemp < (long)numrows)\n    rowsperchunk = (JDIMENSION)ltemp;\n  else\n    rowsperchunk = numrows;\n  mem->last_rowsperchunk = rowsperchunk;\n\n  if (data_precision == 16) {\n#if defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED)\n    /* Get space for row pointers (small object) */\n    result16 = (J16SAMPARRAY)alloc_small(cinfo, pool_id,\n                                         (size_t)(numrows *\n                                                  sizeof(J16SAMPROW)));\n\n    /* Get the rows themselves (large objects) */\n    currow = 0;\n    while (currow < numrows) {\n      rowsperchunk = MIN(rowsperchunk, numrows - currow);\n      workspace16 = (J16SAMPROW)alloc_large(cinfo, pool_id,\n        (size_t)((size_t)rowsperchunk * (size_t)samplesperrow * sample_size));\n      for (i = rowsperchunk; i > 0; i--) {\n        result16[currow++] = workspace16;\n        workspace16 += samplesperrow;\n      }\n    }\n\n    return (JSAMPARRAY)result16;\n#else\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, data_precision);\n    return NULL;\n#endif\n  } else if (data_precision == 12) {\n    /* Get space for row pointers (small object) */\n    result12 = (J12SAMPARRAY)alloc_small(cinfo, pool_id,\n                                         (size_t)(numrows *\n                                                  sizeof(J12SAMPROW)));\n\n    /* Get the rows themselves (large objects) */\n    currow = 0;\n    while (currow < numrows) {\n      rowsperchunk = MIN(rowsperchunk, numrows - currow);\n      workspace12 = (J12SAMPROW)alloc_large(cinfo, pool_id,\n        (size_t)((size_t)rowsperchunk * (size_t)samplesperrow * sample_size));\n      for (i = rowsperchunk; i > 0; i--) {\n        result12[currow++] = workspace12;\n        workspace12 += samplesperrow;\n      }\n    }\n\n    return (JSAMPARRAY)result12;\n  } else {\n    /* Get space for row pointers (small object) */\n    result = (JSAMPARRAY)alloc_small(cinfo, pool_id,\n                                     (size_t)(numrows * sizeof(JSAMPROW)));\n\n    /* Get the rows themselves (large objects) */\n    currow = 0;\n    while (currow < numrows) {\n      rowsperchunk = MIN(rowsperchunk, numrows - currow);\n      workspace = (JSAMPROW)alloc_large(cinfo, pool_id,\n        (size_t)((size_t)rowsperchunk * (size_t)samplesperrow * sample_size));\n      for (i = rowsperchunk; i > 0; i--) {\n        result[currow++] = workspace;\n        workspace += samplesperrow;\n      }\n    }\n\n    return result;\n  }\n}\n\n\n/*\n * Creation of 2-D coefficient-block arrays.\n * This is essentially the same as the code for sample arrays, above.\n */\n\nMETHODDEF(JBLOCKARRAY)\nalloc_barray(j_common_ptr cinfo, int pool_id, JDIMENSION blocksperrow,\n             JDIMENSION numrows)\n/* Allocate a 2-D coefficient-block array */\n{\n  my_mem_ptr mem = (my_mem_ptr)cinfo->mem;\n  JBLOCKARRAY result;\n  JBLOCKROW workspace;\n  JDIMENSION rowsperchunk, currow, i;\n  long ltemp;\n\n  /* Make sure each row is properly aligned */\n  if ((sizeof(JBLOCK) % ALIGN_SIZE) != 0)\n    out_of_memory(cinfo, 6);    /* safety check */\n\n  /* Calculate max # of rows allowed in one allocation chunk */\n  ltemp = (MAX_ALLOC_CHUNK - sizeof(large_pool_hdr)) /\n          ((long)blocksperrow * sizeof(JBLOCK));\n  if (ltemp <= 0)\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n  if (ltemp < (long)numrows)\n    rowsperchunk = (JDIMENSION)ltemp;\n  else\n    rowsperchunk = numrows;\n  mem->last_rowsperchunk = rowsperchunk;\n\n  /* Get space for row pointers (small object) */\n  result = (JBLOCKARRAY)alloc_small(cinfo, pool_id,\n                                    (size_t)(numrows * sizeof(JBLOCKROW)));\n\n  /* Get the rows themselves (large objects) */\n  currow = 0;\n  while (currow < numrows) {\n    rowsperchunk = MIN(rowsperchunk, numrows - currow);\n    workspace = (JBLOCKROW)alloc_large(cinfo, pool_id,\n        (size_t)((size_t)rowsperchunk * (size_t)blocksperrow *\n                  sizeof(JBLOCK)));\n    for (i = rowsperchunk; i > 0; i--) {\n      result[currow++] = workspace;\n      workspace += blocksperrow;\n    }\n  }\n\n  return result;\n}\n\n\n/*\n * About virtual array management:\n *\n * The above \"normal\" array routines are only used to allocate strip buffers\n * (as wide as the image, but just a few rows high).  Full-image-sized buffers\n * are handled as \"virtual\" arrays.  The array is still accessed a strip at a\n * time, but the memory manager must save the whole array for repeated\n * accesses.  The intended implementation is that there is a strip buffer in\n * memory (as high as is possible given the desired memory limit), plus a\n * backing file that holds the rest of the array.\n *\n * The request_virt_array routines are told the total size of the image and\n * the maximum number of rows that will be accessed at once.  The in-memory\n * buffer must be at least as large as the maxaccess value.\n *\n * The request routines create control blocks but not the in-memory buffers.\n * That is postponed until realize_virt_arrays is called.  At that time the\n * total amount of space needed is known (approximately, anyway), so free\n * memory can be divided up fairly.\n *\n * The access_virt_array routines are responsible for making a specific strip\n * area accessible (after reading or writing the backing file, if necessary).\n * Note that the access routines are told whether the caller intends to modify\n * the accessed strip; during a read-only pass this saves having to rewrite\n * data to disk.  The access routines are also responsible for pre-zeroing\n * any newly accessed rows, if pre-zeroing was requested.\n *\n * In current usage, the access requests are usually for nonoverlapping\n * strips; that is, successive access start_row numbers differ by exactly\n * num_rows = maxaccess.  This means we can get good performance with simple\n * buffer dump/reload logic, by making the in-memory buffer be a multiple\n * of the access height; then there will never be accesses across bufferload\n * boundaries.  The code will still work with overlapping access requests,\n * but it doesn't handle bufferload overlaps very efficiently.\n */\n\n\nMETHODDEF(jvirt_sarray_ptr)\nrequest_virt_sarray(j_common_ptr cinfo, int pool_id, boolean pre_zero,\n                    JDIMENSION samplesperrow, JDIMENSION numrows,\n                    JDIMENSION maxaccess)\n/* Request a virtual 2-D sample array */\n{\n  my_mem_ptr mem = (my_mem_ptr)cinfo->mem;\n  jvirt_sarray_ptr result;\n\n  /* Only IMAGE-lifetime virtual arrays are currently supported */\n  if (pool_id != JPOOL_IMAGE)\n    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id); /* safety check */\n\n  /* get control block */\n  result = (jvirt_sarray_ptr)alloc_small(cinfo, pool_id,\n                                         sizeof(struct jvirt_sarray_control));\n\n  result->mem_buffer = NULL;    /* marks array not yet realized */\n  result->rows_in_array = numrows;\n  result->samplesperrow = samplesperrow;\n  result->maxaccess = maxaccess;\n  result->pre_zero = pre_zero;\n  result->b_s_open = FALSE;     /* no associated backing-store object */\n  result->next = mem->virt_sarray_list; /* add to list of virtual arrays */\n  mem->virt_sarray_list = result;\n\n  return result;\n}\n\n\nMETHODDEF(jvirt_barray_ptr)\nrequest_virt_barray(j_common_ptr cinfo, int pool_id, boolean pre_zero,\n                    JDIMENSION blocksperrow, JDIMENSION numrows,\n                    JDIMENSION maxaccess)\n/* Request a virtual 2-D coefficient-block array */\n{\n  my_mem_ptr mem = (my_mem_ptr)cinfo->mem;\n  jvirt_barray_ptr result;\n\n  /* Only IMAGE-lifetime virtual arrays are currently supported */\n  if (pool_id != JPOOL_IMAGE)\n    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id); /* safety check */\n\n  /* get control block */\n  result = (jvirt_barray_ptr)alloc_small(cinfo, pool_id,\n                                         sizeof(struct jvirt_barray_control));\n\n  result->mem_buffer = NULL;    /* marks array not yet realized */\n  result->rows_in_array = numrows;\n  result->blocksperrow = blocksperrow;\n  result->maxaccess = maxaccess;\n  result->pre_zero = pre_zero;\n  result->b_s_open = FALSE;     /* no associated backing-store object */\n  result->next = mem->virt_barray_list; /* add to list of virtual arrays */\n  mem->virt_barray_list = result;\n\n  return result;\n}\n\n\nMETHODDEF(void)\nrealize_virt_arrays(j_common_ptr cinfo)\n/* Allocate the in-memory buffers for any unrealized virtual arrays */\n{\n  my_mem_ptr mem = (my_mem_ptr)cinfo->mem;\n  size_t space_per_minheight, maximum_space, avail_mem;\n  size_t minheights, max_minheights;\n  jvirt_sarray_ptr sptr;\n  jvirt_barray_ptr bptr;\n  int data_precision = cinfo->is_decompressor ?\n                        ((j_decompress_ptr)cinfo)->data_precision :\n                        ((j_compress_ptr)cinfo)->data_precision;\n  size_t sample_size = data_precision == 16 ?\n                       sizeof(J16SAMPLE) : (data_precision == 12 ?\n                                            sizeof(J12SAMPLE) :\n                                            sizeof(JSAMPLE));\n\n  /* Compute the minimum space needed (maxaccess rows in each buffer)\n   * and the maximum space needed (full image height in each buffer).\n   * These may be of use to the system-dependent jpeg_mem_available routine.\n   */\n  space_per_minheight = 0;\n  maximum_space = 0;\n  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {\n    if (sptr->mem_buffer == NULL) { /* if not realized yet */\n      size_t new_space = (long)sptr->rows_in_array *\n                         (long)sptr->samplesperrow * sample_size;\n\n      space_per_minheight += (long)sptr->maxaccess *\n                             (long)sptr->samplesperrow * sample_size;\n      if (SIZE_MAX - maximum_space < new_space)\n        out_of_memory(cinfo, 10);\n      maximum_space += new_space;\n    }\n  }\n  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {\n    if (bptr->mem_buffer == NULL) { /* if not realized yet */\n      size_t new_space = (long)bptr->rows_in_array *\n                         (long)bptr->blocksperrow * sizeof(JBLOCK);\n\n      space_per_minheight += (long)bptr->maxaccess *\n                             (long)bptr->blocksperrow * sizeof(JBLOCK);\n      if (SIZE_MAX - maximum_space < new_space)\n        out_of_memory(cinfo, 11);\n      maximum_space += new_space;\n    }\n  }\n\n  if (space_per_minheight <= 0)\n    return;                     /* no unrealized arrays, no work */\n\n  /* Determine amount of memory to actually use; this is system-dependent. */\n  avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,\n                                 mem->total_space_allocated);\n\n  /* If the maximum space needed is available, make all the buffers full\n   * height; otherwise parcel it out with the same number of minheights\n   * in each buffer.\n   */\n  if (avail_mem >= maximum_space)\n    max_minheights = 1000000000L;\n  else {\n    max_minheights = avail_mem / space_per_minheight;\n    /* If there doesn't seem to be enough space, try to get the minimum\n     * anyway.  This allows a \"stub\" implementation of jpeg_mem_available().\n     */\n    if (max_minheights <= 0)\n      max_minheights = 1;\n  }\n\n  /* Allocate the in-memory buffers and initialize backing store as needed. */\n\n  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {\n    if (sptr->mem_buffer == NULL) { /* if not realized yet */\n      minheights = ((long)sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;\n      if (minheights <= max_minheights) {\n        /* This buffer fits in memory */\n        sptr->rows_in_mem = sptr->rows_in_array;\n      } else {\n        /* It doesn't fit in memory, create backing store. */\n        sptr->rows_in_mem = (JDIMENSION)(max_minheights * sptr->maxaccess);\n        jpeg_open_backing_store(cinfo, &sptr->b_s_info,\n                                (long)sptr->rows_in_array *\n                                (long)sptr->samplesperrow *\n                                (long)sample_size);\n        sptr->b_s_open = TRUE;\n      }\n      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,\n                                      sptr->samplesperrow, sptr->rows_in_mem);\n      sptr->rowsperchunk = mem->last_rowsperchunk;\n      sptr->cur_start_row = 0;\n      sptr->first_undef_row = 0;\n      sptr->dirty = FALSE;\n    }\n  }\n\n  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {\n    if (bptr->mem_buffer == NULL) { /* if not realized yet */\n      minheights = ((long)bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;\n      if (minheights <= max_minheights) {\n        /* This buffer fits in memory */\n        bptr->rows_in_mem = bptr->rows_in_array;\n      } else {\n        /* It doesn't fit in memory, create backing store. */\n        bptr->rows_in_mem = (JDIMENSION)(max_minheights * bptr->maxaccess);\n        jpeg_open_backing_store(cinfo, &bptr->b_s_info,\n                                (long)bptr->rows_in_array *\n                                (long)bptr->blocksperrow *\n                                (long)sizeof(JBLOCK));\n        bptr->b_s_open = TRUE;\n      }\n      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,\n                                      bptr->blocksperrow, bptr->rows_in_mem);\n      bptr->rowsperchunk = mem->last_rowsperchunk;\n      bptr->cur_start_row = 0;\n      bptr->first_undef_row = 0;\n      bptr->dirty = FALSE;\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_sarray_io(j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)\n/* Do backing store read or write of a virtual sample array */\n{\n  long bytesperrow, file_offset, byte_count, rows, thisrow, i;\n  int data_precision = cinfo->is_decompressor ?\n                        ((j_decompress_ptr)cinfo)->data_precision :\n                        ((j_compress_ptr)cinfo)->data_precision;\n  size_t sample_size = data_precision == 16 ?\n                       sizeof(J16SAMPLE) : (data_precision == 12 ?\n                                            sizeof(J12SAMPLE) :\n                                            sizeof(JSAMPLE));\n\n  bytesperrow = (long)ptr->samplesperrow * (long)sample_size;\n  file_offset = ptr->cur_start_row * bytesperrow;\n  /* Loop to read or write each allocation chunk in mem_buffer */\n  for (i = 0; i < (long)ptr->rows_in_mem; i += ptr->rowsperchunk) {\n    /* One chunk, but check for short chunk at end of buffer */\n    rows = MIN((long)ptr->rowsperchunk, (long)ptr->rows_in_mem - i);\n    /* Transfer no more than is currently defined */\n    thisrow = (long)ptr->cur_start_row + i;\n    rows = MIN(rows, (long)ptr->first_undef_row - thisrow);\n    /* Transfer no more than fits in file */\n    rows = MIN(rows, (long)ptr->rows_in_array - thisrow);\n    if (rows <= 0)              /* this chunk might be past end of file! */\n      break;\n    byte_count = rows * bytesperrow;\n    if (data_precision == 16) {\n#if defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED)\n      J16SAMPARRAY mem_buffer16 = (J16SAMPARRAY)ptr->mem_buffer;\n\n      if (writing)\n        (*ptr->b_s_info.write_backing_store) (cinfo, &ptr->b_s_info,\n                                              (void *)mem_buffer16[i],\n                                              file_offset, byte_count);\n      else\n        (*ptr->b_s_info.read_backing_store) (cinfo, &ptr->b_s_info,\n                                             (void *)mem_buffer16[i],\n                                             file_offset, byte_count);\n#else\n      ERREXIT1(cinfo, JERR_BAD_PRECISION, data_precision);\n#endif\n    } else if (data_precision == 12) {\n      J12SAMPARRAY mem_buffer12 = (J12SAMPARRAY)ptr->mem_buffer;\n\n      if (writing)\n        (*ptr->b_s_info.write_backing_store) (cinfo, &ptr->b_s_info,\n                                              (void *)mem_buffer12[i],\n                                              file_offset, byte_count);\n      else\n        (*ptr->b_s_info.read_backing_store) (cinfo, &ptr->b_s_info,\n                                             (void *)mem_buffer12[i],\n                                             file_offset, byte_count);\n    } else {\n      if (writing)\n        (*ptr->b_s_info.write_backing_store) (cinfo, &ptr->b_s_info,\n                                              (void *)ptr->mem_buffer[i],\n                                              file_offset, byte_count);\n      else\n        (*ptr->b_s_info.read_backing_store) (cinfo, &ptr->b_s_info,\n                                             (void *)ptr->mem_buffer[i],\n                                             file_offset, byte_count);\n    }\n    file_offset += byte_count;\n  }\n}\n\n\nLOCAL(void)\ndo_barray_io(j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)\n/* Do backing store read or write of a virtual coefficient-block array */\n{\n  long bytesperrow, file_offset, byte_count, rows, thisrow, i;\n\n  bytesperrow = (long)ptr->blocksperrow * sizeof(JBLOCK);\n  file_offset = ptr->cur_start_row * bytesperrow;\n  /* Loop to read or write each allocation chunk in mem_buffer */\n  for (i = 0; i < (long)ptr->rows_in_mem; i += ptr->rowsperchunk) {\n    /* One chunk, but check for short chunk at end of buffer */\n    rows = MIN((long)ptr->rowsperchunk, (long)ptr->rows_in_mem - i);\n    /* Transfer no more than is currently defined */\n    thisrow = (long)ptr->cur_start_row + i;\n    rows = MIN(rows, (long)ptr->first_undef_row - thisrow);\n    /* Transfer no more than fits in file */\n    rows = MIN(rows, (long)ptr->rows_in_array - thisrow);\n    if (rows <= 0)              /* this chunk might be past end of file! */\n      break;\n    byte_count = rows * bytesperrow;\n    if (writing)\n      (*ptr->b_s_info.write_backing_store) (cinfo, &ptr->b_s_info,\n                                            (void *)ptr->mem_buffer[i],\n                                            file_offset, byte_count);\n    else\n      (*ptr->b_s_info.read_backing_store) (cinfo, &ptr->b_s_info,\n                                           (void *)ptr->mem_buffer[i],\n                                           file_offset, byte_count);\n    file_offset += byte_count;\n  }\n}\n\n\nMETHODDEF(JSAMPARRAY)\naccess_virt_sarray(j_common_ptr cinfo, jvirt_sarray_ptr ptr,\n                   JDIMENSION start_row, JDIMENSION num_rows, boolean writable)\n/* Access the part of a virtual sample array starting at start_row */\n/* and extending for num_rows rows.  writable is true if  */\n/* caller intends to modify the accessed area. */\n{\n  JDIMENSION end_row = start_row + num_rows;\n  JDIMENSION undef_row;\n  int data_precision = cinfo->is_decompressor ?\n                        ((j_decompress_ptr)cinfo)->data_precision :\n                        ((j_compress_ptr)cinfo)->data_precision;\n  size_t sample_size = data_precision == 16 ?\n                       sizeof(J16SAMPLE) : (data_precision == 12 ?\n                                            sizeof(J12SAMPLE) :\n                                            sizeof(JSAMPLE));\n\n  /* debugging check */\n  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||\n      ptr->mem_buffer == NULL)\n    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\n\n  /* Make the desired part of the virtual array accessible */\n  if (start_row < ptr->cur_start_row ||\n      end_row > ptr->cur_start_row + ptr->rows_in_mem) {\n    if (!ptr->b_s_open)\n      ERREXIT(cinfo, JERR_VIRTUAL_BUG);\n    /* Flush old buffer contents if necessary */\n    if (ptr->dirty) {\n      do_sarray_io(cinfo, ptr, TRUE);\n      ptr->dirty = FALSE;\n    }\n    /* Decide what part of virtual array to access.\n     * Algorithm: if target address > current window, assume forward scan,\n     * load starting at target address.  If target address < current window,\n     * assume backward scan, load so that target area is top of window.\n     * Note that when switching from forward write to forward read, will have\n     * start_row = 0, so the limiting case applies and we load from 0 anyway.\n     */\n    if (start_row > ptr->cur_start_row) {\n      ptr->cur_start_row = start_row;\n    } else {\n      /* use long arithmetic here to avoid overflow & unsigned problems */\n      long ltemp;\n\n      ltemp = (long)end_row - (long)ptr->rows_in_mem;\n      if (ltemp < 0)\n        ltemp = 0;              /* don't fall off front end of file */\n      ptr->cur_start_row = (JDIMENSION)ltemp;\n    }\n    /* Read in the selected part of the array.\n     * During the initial write pass, we will do no actual read\n     * because the selected part is all undefined.\n     */\n    do_sarray_io(cinfo, ptr, FALSE);\n  }\n  /* Ensure the accessed part of the array is defined; prezero if needed.\n   * To improve locality of access, we only prezero the part of the array\n   * that the caller is about to access, not the entire in-memory array.\n   */\n  if (ptr->first_undef_row < end_row) {\n    if (ptr->first_undef_row < start_row) {\n      if (writable)             /* writer skipped over a section of array */\n        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\n      undef_row = start_row;    /* but reader is allowed to read ahead */\n    } else {\n      undef_row = ptr->first_undef_row;\n    }\n    if (writable)\n      ptr->first_undef_row = end_row;\n    if (ptr->pre_zero) {\n      size_t bytesperrow = (size_t)ptr->samplesperrow * sample_size;\n      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */\n      end_row -= ptr->cur_start_row;\n      while (undef_row < end_row) {\n        jzero_far((void *)ptr->mem_buffer[undef_row], bytesperrow);\n        undef_row++;\n      }\n    } else {\n      if (!writable)            /* reader looking at undefined data */\n        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\n    }\n  }\n  /* Flag the buffer dirty if caller will write in it */\n  if (writable)\n    ptr->dirty = TRUE;\n  /* Return address of proper part of the buffer */\n  return ptr->mem_buffer + (start_row - ptr->cur_start_row);\n}\n\n\nMETHODDEF(JBLOCKARRAY)\naccess_virt_barray(j_common_ptr cinfo, jvirt_barray_ptr ptr,\n                   JDIMENSION start_row, JDIMENSION num_rows, boolean writable)\n/* Access the part of a virtual block array starting at start_row */\n/* and extending for num_rows rows.  writable is true if  */\n/* caller intends to modify the accessed area. */\n{\n  JDIMENSION end_row = start_row + num_rows;\n  JDIMENSION undef_row;\n\n  /* debugging check */\n  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||\n      ptr->mem_buffer == NULL)\n    ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\n\n  /* Make the desired part of the virtual array accessible */\n  if (start_row < ptr->cur_start_row ||\n      end_row > ptr->cur_start_row + ptr->rows_in_mem) {\n    if (!ptr->b_s_open)\n      ERREXIT(cinfo, JERR_VIRTUAL_BUG);\n    /* Flush old buffer contents if necessary */\n    if (ptr->dirty) {\n      do_barray_io(cinfo, ptr, TRUE);\n      ptr->dirty = FALSE;\n    }\n    /* Decide what part of virtual array to access.\n     * Algorithm: if target address > current window, assume forward scan,\n     * load starting at target address.  If target address < current window,\n     * assume backward scan, load so that target area is top of window.\n     * Note that when switching from forward write to forward read, will have\n     * start_row = 0, so the limiting case applies and we load from 0 anyway.\n     */\n    if (start_row > ptr->cur_start_row) {\n      ptr->cur_start_row = start_row;\n    } else {\n      /* use long arithmetic here to avoid overflow & unsigned problems */\n      long ltemp;\n\n      ltemp = (long)end_row - (long)ptr->rows_in_mem;\n      if (ltemp < 0)\n        ltemp = 0;              /* don't fall off front end of file */\n      ptr->cur_start_row = (JDIMENSION)ltemp;\n    }\n    /* Read in the selected part of the array.\n     * During the initial write pass, we will do no actual read\n     * because the selected part is all undefined.\n     */\n    do_barray_io(cinfo, ptr, FALSE);\n  }\n  /* Ensure the accessed part of the array is defined; prezero if needed.\n   * To improve locality of access, we only prezero the part of the array\n   * that the caller is about to access, not the entire in-memory array.\n   */\n  if (ptr->first_undef_row < end_row) {\n    if (ptr->first_undef_row < start_row) {\n      if (writable)             /* writer skipped over a section of array */\n        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\n      undef_row = start_row;    /* but reader is allowed to read ahead */\n    } else {\n      undef_row = ptr->first_undef_row;\n    }\n    if (writable)\n      ptr->first_undef_row = end_row;\n    if (ptr->pre_zero) {\n      size_t bytesperrow = (size_t)ptr->blocksperrow * sizeof(JBLOCK);\n      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */\n      end_row -= ptr->cur_start_row;\n      while (undef_row < end_row) {\n        jzero_far((void *)ptr->mem_buffer[undef_row], bytesperrow);\n        undef_row++;\n      }\n    } else {\n      if (!writable)            /* reader looking at undefined data */\n        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);\n    }\n  }\n  /* Flag the buffer dirty if caller will write in it */\n  if (writable)\n    ptr->dirty = TRUE;\n  /* Return address of proper part of the buffer */\n  return ptr->mem_buffer + (start_row - ptr->cur_start_row);\n}\n\n\n/*\n * Release all objects belonging to a specified pool.\n */\n\nMETHODDEF(void)\nfree_pool(j_common_ptr cinfo, int pool_id)\n{\n  my_mem_ptr mem = (my_mem_ptr)cinfo->mem;\n  small_pool_ptr shdr_ptr;\n  large_pool_ptr lhdr_ptr;\n  size_t space_freed;\n\n  if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)\n    ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id); /* safety check */\n\n#ifdef MEM_STATS\n  if (cinfo->err->trace_level > 1)\n    print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */\n#endif\n\n  /* If freeing IMAGE pool, close any virtual arrays first */\n  if (pool_id == JPOOL_IMAGE) {\n    jvirt_sarray_ptr sptr;\n    jvirt_barray_ptr bptr;\n\n    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {\n      if (sptr->b_s_open) {     /* there may be no backing store */\n        sptr->b_s_open = FALSE; /* prevent recursive close if error */\n        (*sptr->b_s_info.close_backing_store) (cinfo, &sptr->b_s_info);\n      }\n    }\n    mem->virt_sarray_list = NULL;\n    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {\n      if (bptr->b_s_open) {     /* there may be no backing store */\n        bptr->b_s_open = FALSE; /* prevent recursive close if error */\n        (*bptr->b_s_info.close_backing_store) (cinfo, &bptr->b_s_info);\n      }\n    }\n    mem->virt_barray_list = NULL;\n  }\n\n  /* Release large objects */\n  lhdr_ptr = mem->large_list[pool_id];\n  mem->large_list[pool_id] = NULL;\n\n  while (lhdr_ptr != NULL) {\n    large_pool_ptr next_lhdr_ptr = lhdr_ptr->next;\n    space_freed = lhdr_ptr->bytes_used +\n                  lhdr_ptr->bytes_left +\n                  sizeof(large_pool_hdr) + ALIGN_SIZE - 1;\n    jpeg_free_large(cinfo, (void *)lhdr_ptr, space_freed);\n    mem->total_space_allocated -= space_freed;\n    lhdr_ptr = next_lhdr_ptr;\n  }\n\n  /* Release small objects */\n  shdr_ptr = mem->small_list[pool_id];\n  mem->small_list[pool_id] = NULL;\n\n  while (shdr_ptr != NULL) {\n    small_pool_ptr next_shdr_ptr = shdr_ptr->next;\n    space_freed = shdr_ptr->bytes_used + shdr_ptr->bytes_left +\n                  sizeof(small_pool_hdr) + ALIGN_SIZE - 1;\n    jpeg_free_small(cinfo, (void *)shdr_ptr, space_freed);\n    mem->total_space_allocated -= space_freed;\n    shdr_ptr = next_shdr_ptr;\n  }\n}\n\n\n/*\n * Close up shop entirely.\n * Note that this cannot be called unless cinfo->mem is non-NULL.\n */\n\nMETHODDEF(void)\nself_destruct(j_common_ptr cinfo)\n{\n  int pool;\n\n  /* Close all backing store, release all memory.\n   * Releasing pools in reverse order might help avoid fragmentation\n   * with some (brain-damaged) malloc libraries.\n   */\n  for (pool = JPOOL_NUMPOOLS - 1; pool >= JPOOL_PERMANENT; pool--) {\n    free_pool(cinfo, pool);\n  }\n\n  /* Release the memory manager control block too. */\n  jpeg_free_small(cinfo, (void *)cinfo->mem, sizeof(my_memory_mgr));\n  cinfo->mem = NULL;            /* ensures I will be called only once */\n\n  jpeg_mem_term(cinfo);         /* system-dependent cleanup */\n}\n\n\n/*\n * Memory manager initialization.\n * When this is called, only the error manager pointer is valid in cinfo!\n */\n\nGLOBAL(void)\njinit_memory_mgr(j_common_ptr cinfo)\n{\n  my_mem_ptr mem;\n  long max_to_use;\n  int pool;\n  size_t test_mac;\n\n  cinfo->mem = NULL;            /* for safety if init fails */\n\n  /* Check for configuration errors.\n   * sizeof(ALIGN_TYPE) should be a power of 2; otherwise, it probably\n   * doesn't reflect any real hardware alignment requirement.\n   * The test is a little tricky: for X>0, X and X-1 have no one-bits\n   * in common if and only if X is a power of 2, ie has only one one-bit.\n   * Some compilers may give an \"unreachable code\" warning here; ignore it.\n   */\n  if ((ALIGN_SIZE & (ALIGN_SIZE - 1)) != 0)\n    ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);\n  /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be\n   * a multiple of ALIGN_SIZE.\n   * Again, an \"unreachable code\" warning may be ignored here.\n   * But a \"constant too large\" warning means you need to fix MAX_ALLOC_CHUNK.\n   */\n  test_mac = (size_t)MAX_ALLOC_CHUNK;\n  if ((long)test_mac != MAX_ALLOC_CHUNK ||\n      (MAX_ALLOC_CHUNK % ALIGN_SIZE) != 0)\n    ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);\n\n  max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */\n\n  /* Attempt to allocate memory manager's control block */\n  mem = (my_mem_ptr)jpeg_get_small(cinfo, sizeof(my_memory_mgr));\n\n  if (mem == NULL) {\n    jpeg_mem_term(cinfo);       /* system-dependent cleanup */\n    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);\n  }\n\n  /* OK, fill in the method pointers */\n  mem->pub.alloc_small = alloc_small;\n  mem->pub.alloc_large = alloc_large;\n  mem->pub.alloc_sarray = alloc_sarray;\n  mem->pub.alloc_barray = alloc_barray;\n  mem->pub.request_virt_sarray = request_virt_sarray;\n  mem->pub.request_virt_barray = request_virt_barray;\n  mem->pub.realize_virt_arrays = realize_virt_arrays;\n  mem->pub.access_virt_sarray = access_virt_sarray;\n  mem->pub.access_virt_barray = access_virt_barray;\n  mem->pub.free_pool = free_pool;\n  mem->pub.self_destruct = self_destruct;\n\n  /* Make MAX_ALLOC_CHUNK accessible to other modules */\n  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;\n\n  /* Initialize working state */\n  mem->pub.max_memory_to_use = max_to_use;\n\n  for (pool = JPOOL_NUMPOOLS - 1; pool >= JPOOL_PERMANENT; pool--) {\n    mem->small_list[pool] = NULL;\n    mem->large_list[pool] = NULL;\n  }\n  mem->virt_sarray_list = NULL;\n  mem->virt_barray_list = NULL;\n\n  mem->total_space_allocated = sizeof(my_memory_mgr);\n\n  /* Declare ourselves open for business */\n  cinfo->mem = &mem->pub;\n\n  /* Check for an environment variable JPEGMEM; if found, override the\n   * default max_memory setting from jpeg_mem_init.  Note that the\n   * surrounding application may again override this value.\n   * If your system doesn't support getenv(), define NO_GETENV to disable\n   * this feature.\n   */\n#ifndef NO_GETENV\n  {\n    char memenv[30] = { 0 };\n\n    if (!GETENV_S(memenv, 30, \"JPEGMEM\") && strlen(memenv) > 0) {\n      char ch = 'x';\n\n#ifdef _MSC_VER\n      if (sscanf_s(memenv, \"%ld%c\", &max_to_use, &ch, 1) > 0) {\n#else\n      if (sscanf(memenv, \"%ld%c\", &max_to_use, &ch) > 0) {\n#endif\n        if (ch == 'm' || ch == 'M')\n          max_to_use *= 1000L;\n        mem->pub.max_memory_to_use = max_to_use * 1000L;\n      }\n    }\n  }\n#endif\n\n}\n"
        },
        {
          "name": "jmemnobs.c",
          "type": "blob",
          "size": 2.6171875,
          "content": "/*\n * jmemnobs.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1992-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2017-2018, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file provides a really simple implementation of the system-\n * dependent portion of the JPEG memory manager.  This implementation\n * assumes that no backing-store files are needed: all required space\n * can be obtained from malloc().\n * This is very portable in the sense that it'll compile on almost anything,\n * but you'd better have lots of main memory (or virtual memory) if you want\n * to process big images.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jmemsys.h\"            /* import the system-dependent declarations */\n\n\n/*\n * Memory allocation and freeing are controlled by the regular library\n * routines malloc() and free().\n */\n\nGLOBAL(void *)\njpeg_get_small(j_common_ptr cinfo, size_t sizeofobject)\n{\n  return (void *)MALLOC(sizeofobject);\n}\n\nGLOBAL(void)\njpeg_free_small(j_common_ptr cinfo, void *object, size_t sizeofobject)\n{\n  free(object);\n}\n\n\n/*\n * \"Large\" objects are treated the same as \"small\" ones.\n */\n\nGLOBAL(void *)\njpeg_get_large(j_common_ptr cinfo, size_t sizeofobject)\n{\n  return (void *)MALLOC(sizeofobject);\n}\n\nGLOBAL(void)\njpeg_free_large(j_common_ptr cinfo, void *object, size_t sizeofobject)\n{\n  free(object);\n}\n\n\n/*\n * This routine computes the total memory space available for allocation.\n */\n\nGLOBAL(size_t)\njpeg_mem_available(j_common_ptr cinfo, size_t min_bytes_needed,\n                   size_t max_bytes_needed, size_t already_allocated)\n{\n  if (cinfo->mem->max_memory_to_use) {\n    if ((size_t)cinfo->mem->max_memory_to_use > already_allocated)\n      return cinfo->mem->max_memory_to_use - already_allocated;\n    else\n      return 0;\n  } else {\n    /* Here we always say, \"we got all you want bud!\" */\n    return max_bytes_needed;\n  }\n}\n\n\n/*\n * Backing store (temporary file) management.\n * Since jpeg_mem_available always promised the moon,\n * this should never be called and we can just error out.\n */\n\nGLOBAL(void)\njpeg_open_backing_store(j_common_ptr cinfo, backing_store_ptr info,\n                        long total_bytes_needed)\n{\n  ERREXIT(cinfo, JERR_NO_BACKING_STORE);\n}\n\n\n/*\n * These routines take care of any system-dependent initialization and\n * cleanup required.  Here, there isn't any.\n */\n\nGLOBAL(long)\njpeg_mem_init(j_common_ptr cinfo)\n{\n  return 0;                     /* just set max_memory_to_use to 0 */\n}\n\nGLOBAL(void)\njpeg_mem_term(j_common_ptr cinfo)\n{\n  /* no work */\n}\n"
        },
        {
          "name": "jmemsys.h",
          "type": "blob",
          "size": 6.53515625,
          "content": "/*\n * jmemsys.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1992-1997, Thomas G. Lane.\n * It was modified by The libjpeg-turbo Project to include only code and\n * information relevant to libjpeg-turbo.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This include file defines the interface between the system-independent\n * and system-dependent portions of the JPEG memory manager.  No other\n * modules need include it.  (The system-independent portion is jmemmgr.c;\n * there are several different versions of the system-dependent portion.)\n *\n * This file works as-is for the system-dependent memory managers supplied\n * in the IJG distribution.  You may need to modify it if you write a\n * custom memory manager.  If system-dependent changes are needed in\n * this file, the best method is to #ifdef them based on a configuration\n * symbol supplied in jconfig.h.\n */\n\n\n/*\n * These two functions are used to allocate and release small chunks of\n * memory.  (Typically the total amount requested through jpeg_get_small is\n * no more than 20K or so; this will be requested in chunks of a few K each.)\n * Behavior should be the same as for the standard library functions malloc\n * and free; in particular, jpeg_get_small must return NULL on failure.\n * On most systems, these ARE malloc and free.  jpeg_free_small is passed the\n * size of the object being freed, just in case it's needed.\n */\n\nEXTERN(void *) jpeg_get_small(j_common_ptr cinfo, size_t sizeofobject);\nEXTERN(void) jpeg_free_small(j_common_ptr cinfo, void *object,\n                             size_t sizeofobject);\n\n/*\n * These two functions are used to allocate and release large chunks of\n * memory (up to the total free space designated by jpeg_mem_available).\n * These are identical to the jpeg_get/free_small routines; but we keep them\n * separate anyway, in case a different allocation strategy is desirable for\n * large chunks.\n */\n\nEXTERN(void *) jpeg_get_large(j_common_ptr cinfo, size_t sizeofobject);\nEXTERN(void) jpeg_free_large(j_common_ptr cinfo, void *object,\n                             size_t sizeofobject);\n\n/*\n * The macro MAX_ALLOC_CHUNK designates the maximum number of bytes that may\n * be requested in a single call to jpeg_get_large (and jpeg_get_small for that\n * matter, but that case should never come into play).  This macro was needed\n * to model the 64Kb-segment-size limit of far addressing on 80x86 machines.\n * On machines with flat address spaces, any large constant may be used.\n *\n * NB: jmemmgr.c expects that MAX_ALLOC_CHUNK will be representable as type\n * size_t and will be a multiple of sizeof(align_type).\n */\n\n#ifndef MAX_ALLOC_CHUNK         /* may be overridden in jconfig.h */\n#define MAX_ALLOC_CHUNK  1000000000L\n#endif\n\n/*\n * This routine computes the total space still available for allocation by\n * jpeg_get_large.  If more space than this is needed, backing store will be\n * used.  NOTE: any memory already allocated must not be counted.\n *\n * There is a minimum space requirement, corresponding to the minimum\n * feasible buffer sizes; jmemmgr.c will request that much space even if\n * jpeg_mem_available returns zero.  The maximum space needed, enough to hold\n * all working storage in memory, is also passed in case it is useful.\n * Finally, the total space already allocated is passed.  If no better\n * method is available, cinfo->mem->max_memory_to_use - already_allocated\n * is often a suitable calculation.\n *\n * It is OK for jpeg_mem_available to underestimate the space available\n * (that'll just lead to more backing-store access than is really necessary).\n * However, an overestimate will lead to failure.  Hence it's wise to subtract\n * a slop factor from the true available space.  5% should be enough.\n *\n * On machines with lots of virtual memory, any large constant may be returned.\n * Conversely, zero may be returned to always use the minimum amount of memory.\n */\n\nEXTERN(size_t) jpeg_mem_available(j_common_ptr cinfo, size_t min_bytes_needed,\n                                  size_t max_bytes_needed,\n                                  size_t already_allocated);\n\n\n/*\n * This structure holds whatever state is needed to access a single\n * backing-store object.  The read/write/close method pointers are called\n * by jmemmgr.c to manipulate the backing-store object; all other fields\n * are private to the system-dependent backing store routines.\n */\n\n#define TEMP_NAME_LENGTH   64   /* max length of a temporary file's name */\n\n\ntypedef struct backing_store_struct *backing_store_ptr;\n\ntypedef struct backing_store_struct {\n  /* Methods for reading/writing/closing this backing-store object */\n  void (*read_backing_store) (j_common_ptr cinfo, backing_store_ptr info,\n                              void *buffer_address, long file_offset,\n                              long byte_count);\n  void (*write_backing_store) (j_common_ptr cinfo, backing_store_ptr info,\n                               void *buffer_address, long file_offset,\n                               long byte_count);\n  void (*close_backing_store) (j_common_ptr cinfo, backing_store_ptr info);\n\n  /* Private fields for system-dependent backing-store management */\n  /* For a typical implementation with temp files, we need: */\n  FILE *temp_file;              /* stdio reference to temp file */\n  char temp_name[TEMP_NAME_LENGTH]; /* name of temp file */\n} backing_store_info;\n\n\n/*\n * Initial opening of a backing-store object.  This must fill in the\n * read/write/close pointers in the object.  The read/write routines\n * may take an error exit if the specified maximum file size is exceeded.\n * (If jpeg_mem_available always returns a large value, this routine can\n * just take an error exit.)\n */\n\nEXTERN(void) jpeg_open_backing_store(j_common_ptr cinfo,\n                                     backing_store_ptr info,\n                                     long total_bytes_needed);\n\n\n/*\n * These routines take care of any system-dependent initialization and\n * cleanup required.  jpeg_mem_init will be called before anything is\n * allocated (and, therefore, nothing in cinfo is of use except the error\n * manager pointer).  It should return a suitable default value for\n * max_memory_to_use; this may subsequently be overridden by the surrounding\n * application.  (Note that max_memory_to_use is only important if\n * jpeg_mem_available chooses to consult it ... no one else will.)\n * jpeg_mem_term may assume that all requested memory has been freed and that\n * all opened backing-store objects have been closed.\n */\n\nEXTERN(long) jpeg_mem_init(j_common_ptr cinfo);\nEXTERN(void) jpeg_mem_term(j_common_ptr cinfo);\n"
        },
        {
          "name": "jmorecfg.h",
          "type": "blob",
          "size": 14.048828125,
          "content": "/*\n * jmorecfg.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 1997-2009 by Guido Vollbeding.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2009, 2011, 2014-2015, 2018, 2020, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains additional configuration options that customize the\n * JPEG software for special applications or support machine-dependent\n * optimizations.  Most users will not need to touch this file.\n */\n\n\n/*\n * Maximum number of components (color channels) allowed in JPEG image.\n * To meet the letter of Rec. ITU-T T.81 | ISO/IEC 10918-1, set this to 255.\n * However, darn few applications need more than 4 channels (maybe 5 for CMYK +\n * alpha mask).  We recommend 10 as a reasonable compromise; use 4 if you are\n * really short on memory.  (Each allowed component costs a hundred or so\n * bytes of storage, whether actually used in an image or not.)\n */\n\n#define MAX_COMPONENTS  10      /* maximum number of image components */\n\n\n/*\n * Basic data types.\n * You may need to change these if you have a machine with unusual data\n * type sizes; for example, \"char\" not 8 bits, \"short\" not 16 bits,\n * or \"long\" not 32 bits.  We don't care whether \"int\" is 16 or 32 bits,\n * but it had better be at least 16.\n */\n\n/* Representation of a single sample (pixel element value).\n * We frequently allocate large arrays of these, so it's important to keep\n * them small.  But if you have memory to burn and access to char or short\n * arrays is very slow on your hardware, you might want to change these.\n */\n\n/* JSAMPLE should be the smallest type that will hold the values 0..255. */\n\ntypedef unsigned char JSAMPLE;\n#define GETJSAMPLE(value)  ((int)(value))\n\n#define MAXJSAMPLE       255\n#define CENTERJSAMPLE    128\n\n\n/* J12SAMPLE should be the smallest type that will hold the values 0..4095. */\n\ntypedef short J12SAMPLE;\n\n#define MAXJ12SAMPLE     4095\n#define CENTERJ12SAMPLE  2048\n\n\n/* J16SAMPLE should be the smallest type that will hold the values 0..65535. */\n\ntypedef unsigned short J16SAMPLE;\n\n#define MAXJ16SAMPLE     65535\n#define CENTERJ16SAMPLE  32768\n\n\n/* Representation of a DCT frequency coefficient.\n * This should be a signed value of at least 16 bits; \"short\" is usually OK.\n * Again, we allocate large arrays of these, but you can change to int\n * if you have memory to burn and \"short\" is really slow.\n */\n\ntypedef short JCOEF;\n\n\n/* Compressed datastreams are represented as arrays of JOCTET.\n * These must be EXACTLY 8 bits wide, at least once they are written to\n * external storage.  Note that when using the stdio data source/destination\n * managers, this is also the data type passed to fread/fwrite.\n */\n\ntypedef unsigned char JOCTET;\n#define GETJOCTET(value)  (value)\n\n\n/* These typedefs are used for various table entries and so forth.\n * They must be at least as wide as specified; but making them too big\n * won't cost a huge amount of memory, so we don't provide special\n * extraction code like we did for JSAMPLE.  (In other words, these\n * typedefs live at a different point on the speed/space tradeoff curve.)\n */\n\n/* UINT8 must hold at least the values 0..255. */\n\ntypedef unsigned char UINT8;\n\n/* UINT16 must hold at least the values 0..65535. */\n\ntypedef unsigned short UINT16;\n\n/* INT16 must hold at least the values -32768..32767. */\n\n#ifndef XMD_H                   /* X11/xmd.h correctly defines INT16 */\ntypedef short INT16;\n#endif\n\n/* INT32 must hold at least signed 32-bit values.\n *\n * NOTE: The INT32 typedef dates back to libjpeg v5 (1994.)  Integers were\n * sometimes 16-bit back then (MS-DOS), which is why INT32 is typedef'd to\n * long.  It also wasn't common (or at least as common) in 1994 for INT32 to be\n * defined by platform headers.  Since then, however, INT32 is defined in\n * several other common places:\n *\n * Xmd.h (X11 header) typedefs INT32 to int on 64-bit platforms and long on\n * 32-bit platforms (i.e always a 32-bit signed type.)\n *\n * basetsd.h (Win32 header) typedefs INT32 to int (always a 32-bit signed type\n * on modern platforms.)\n *\n * qglobal.h (Qt header) typedefs INT32 to int (always a 32-bit signed type on\n * modern platforms.)\n *\n * This is a recipe for conflict, since \"long\" and \"int\" aren't always\n * compatible types.  Since the definition of INT32 has technically been part\n * of the libjpeg API for more than 20 years, we can't remove it, but we do not\n * use it internally any longer.  We instead define a separate type (JLONG)\n * for internal use, which ensures that internal behavior will always be the\n * same regardless of any external headers that may be included.\n */\n\n#ifndef XMD_H                   /* X11/xmd.h correctly defines INT32 */\n#ifndef _BASETSD_H_             /* Microsoft defines it in basetsd.h */\n#ifndef _BASETSD_H              /* MinGW is slightly different */\n#ifndef QGLOBAL_H               /* Qt defines it in qglobal.h */\ntypedef long INT32;\n#endif\n#endif\n#endif\n#endif\n\n/* Datatype used for image dimensions.  The JPEG standard only supports\n * images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore\n * \"unsigned int\" is sufficient on all machines.  However, if you need to\n * handle larger images and you don't mind deviating from the spec, you\n * can change this datatype.  (Note that changing this datatype will\n * potentially require modifying the SIMD code.  The x86-64 SIMD extensions,\n * in particular, assume a 32-bit JDIMENSION.)\n */\n\ntypedef unsigned int JDIMENSION;\n\n#define JPEG_MAX_DIMENSION  65500L  /* a tad under 64K to prevent overflows */\n\n\n/* These macros are used in all function definitions and extern declarations.\n * You could modify them if you need to change function linkage conventions;\n * in particular, you'll need to do that to make the library a Windows DLL.\n * Another application is to make all functions global for use with debuggers\n * or code profilers that require it.\n */\n\n/* a function called through method pointers: */\n#define METHODDEF(type)         static type\n/* a function used only in its module: */\n#define LOCAL(type)             static type\n/* a function referenced thru EXTERNs: */\n#define GLOBAL(type)            type\n/* a reference to a GLOBAL function: */\n#define EXTERN(type)            extern type\n\n\n/* Originally, this macro was used as a way of defining function prototypes\n * for both modern compilers as well as older compilers that did not support\n * prototype parameters.  libjpeg-turbo has never supported these older,\n * non-ANSI compilers, but the macro is still included because there is some\n * software out there that uses it.\n */\n\n#define JMETHOD(type, methodname, arglist)  type (*methodname) arglist\n\n\n/* libjpeg-turbo no longer supports platforms that have far symbols (MS-DOS),\n * but again, some software relies on this macro.\n */\n\n#undef FAR\n#define FAR\n\n\n/*\n * On a few systems, type boolean and/or its values FALSE, TRUE may appear\n * in standard header files.  Or you may have conflicts with application-\n * specific header files that you want to include together with these files.\n * Defining HAVE_BOOLEAN before including jpeglib.h should make it work.\n */\n\n#ifndef HAVE_BOOLEAN\ntypedef int boolean;\n#endif\n#ifndef FALSE                   /* in case these macros already exist */\n#define FALSE   0               /* values of boolean */\n#endif\n#ifndef TRUE\n#define TRUE    1\n#endif\n\n\n/*\n * The remaining options affect code selection within the JPEG library,\n * but they don't need to be visible to most applications using the library.\n * To minimize application namespace pollution, the symbols won't be\n * defined unless JPEG_INTERNALS or JPEG_INTERNAL_OPTIONS has been defined.\n */\n\n#ifdef JPEG_INTERNALS\n#define JPEG_INTERNAL_OPTIONS\n#endif\n\n#ifdef JPEG_INTERNAL_OPTIONS\n\n\n/*\n * These defines indicate whether to include various optional functions.\n * Undefining some of these symbols will produce a smaller but less capable\n * library.  Note that you can leave certain source files out of the\n * compilation/linking process if you've #undef'd the corresponding symbols.\n * (You may HAVE to do that if your compiler doesn't like null source files.)\n */\n\n/* Capability options common to encoder and decoder: */\n\n#define DCT_ISLOW_SUPPORTED     /* accurate integer method */\n#define DCT_IFAST_SUPPORTED     /* less accurate int method [legacy feature] */\n#define DCT_FLOAT_SUPPORTED     /* floating-point method [legacy feature] */\n\n/* Encoder capability options: */\n\n#define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */\n#define C_PROGRESSIVE_SUPPORTED     /* Progressive JPEG? (Requires MULTISCAN)*/\n#define C_LOSSLESS_SUPPORTED        /* Lossless JPEG? */\n#define ENTROPY_OPT_SUPPORTED       /* Optimization of entropy coding parms? */\n/* Note: if you selected 12-bit data precision, it is dangerous to turn off\n * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit\n * precision, so jchuff.c normally uses entropy optimization to compute\n * usable tables for higher precision.  If you don't want to do optimization,\n * you'll have to supply different default Huffman tables.\n * The exact same statements apply for progressive and lossless JPEG:\n * the default tables don't work for progressive mode or lossless mode.\n * (This may get fixed, however.)\n */\n#define INPUT_SMOOTHING_SUPPORTED   /* Input image smoothing option? */\n\n/* Decoder capability options: */\n\n#define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */\n#define D_PROGRESSIVE_SUPPORTED     /* Progressive JPEG? (Requires MULTISCAN)*/\n#define D_LOSSLESS_SUPPORTED        /* Lossless JPEG? */\n#define SAVE_MARKERS_SUPPORTED      /* jpeg_save_markers() needed? */\n#define BLOCK_SMOOTHING_SUPPORTED   /* Block smoothing? (Progressive only) */\n#define IDCT_SCALING_SUPPORTED      /* Output rescaling via IDCT? */\n#undef  UPSAMPLE_SCALING_SUPPORTED  /* Output rescaling at upsample stage? */\n#define UPSAMPLE_MERGING_SUPPORTED  /* Fast path for sloppy upsampling? */\n#define QUANT_1PASS_SUPPORTED       /* 1-pass color quantization? */\n#define QUANT_2PASS_SUPPORTED       /* 2-pass color quantization? */\n\n/* more capability options later, no doubt */\n\n\n/*\n * The RGB_RED, RGB_GREEN, RGB_BLUE, and RGB_PIXELSIZE macros are a vestigial\n * feature of libjpeg.  The idea was that, if an application developer needed\n * to compress from/decompress to a BGR/BGRX/RGBX/XBGR/XRGB buffer, they could\n * change these macros, rebuild libjpeg, and link their application statically\n * with it.  In reality, few people ever did this, because there were some\n * severe restrictions involved (cjpeg and djpeg no longer worked properly,\n * compressing/decompressing RGB JPEGs no longer worked properly, and the color\n * quantizer wouldn't work with pixel sizes other than 3.)  Furthermore, since\n * all of the O/S-supplied versions of libjpeg were built with the default\n * values of RGB_RED, RGB_GREEN, RGB_BLUE, and RGB_PIXELSIZE, many applications\n * have come to regard these values as immutable.\n *\n * The libjpeg-turbo colorspace extensions provide a much cleaner way of\n * compressing from/decompressing to buffers with arbitrary component orders\n * and pixel sizes.  Thus, we do not support changing the values of RGB_RED,\n * RGB_GREEN, RGB_BLUE, or RGB_PIXELSIZE.  In addition to the restrictions\n * listed above, changing these values will also break the SIMD extensions and\n * the regression tests.\n */\n\n#define RGB_RED         0       /* Offset of Red in an RGB scanline element */\n#define RGB_GREEN       1       /* Offset of Green */\n#define RGB_BLUE        2       /* Offset of Blue */\n#define RGB_PIXELSIZE   3       /* JSAMPLEs per RGB scanline element */\n\n#define JPEG_NUMCS  17\n\n#define EXT_RGB_RED         0\n#define EXT_RGB_GREEN       1\n#define EXT_RGB_BLUE        2\n#define EXT_RGB_PIXELSIZE   3\n\n#define EXT_RGBX_RED        0\n#define EXT_RGBX_GREEN      1\n#define EXT_RGBX_BLUE       2\n#define EXT_RGBX_PIXELSIZE  4\n\n#define EXT_BGR_RED         2\n#define EXT_BGR_GREEN       1\n#define EXT_BGR_BLUE        0\n#define EXT_BGR_PIXELSIZE   3\n\n#define EXT_BGRX_RED        2\n#define EXT_BGRX_GREEN      1\n#define EXT_BGRX_BLUE       0\n#define EXT_BGRX_PIXELSIZE  4\n\n#define EXT_XBGR_RED        3\n#define EXT_XBGR_GREEN      2\n#define EXT_XBGR_BLUE       1\n#define EXT_XBGR_PIXELSIZE  4\n\n#define EXT_XRGB_RED        1\n#define EXT_XRGB_GREEN      2\n#define EXT_XRGB_BLUE       3\n#define EXT_XRGB_PIXELSIZE  4\n\nstatic const int rgb_red[JPEG_NUMCS] = {\n  -1, -1, RGB_RED, -1, -1, -1, EXT_RGB_RED, EXT_RGBX_RED,\n  EXT_BGR_RED, EXT_BGRX_RED, EXT_XBGR_RED, EXT_XRGB_RED,\n  EXT_RGBX_RED, EXT_BGRX_RED, EXT_XBGR_RED, EXT_XRGB_RED,\n  -1\n};\n\nstatic const int rgb_green[JPEG_NUMCS] = {\n  -1, -1, RGB_GREEN, -1, -1, -1, EXT_RGB_GREEN, EXT_RGBX_GREEN,\n  EXT_BGR_GREEN, EXT_BGRX_GREEN, EXT_XBGR_GREEN, EXT_XRGB_GREEN,\n  EXT_RGBX_GREEN, EXT_BGRX_GREEN, EXT_XBGR_GREEN, EXT_XRGB_GREEN,\n  -1\n};\n\nstatic const int rgb_blue[JPEG_NUMCS] = {\n  -1, -1, RGB_BLUE, -1, -1, -1, EXT_RGB_BLUE, EXT_RGBX_BLUE,\n  EXT_BGR_BLUE, EXT_BGRX_BLUE, EXT_XBGR_BLUE, EXT_XRGB_BLUE,\n  EXT_RGBX_BLUE, EXT_BGRX_BLUE, EXT_XBGR_BLUE, EXT_XRGB_BLUE,\n  -1\n};\n\nstatic const int rgb_pixelsize[JPEG_NUMCS] = {\n  -1, -1, RGB_PIXELSIZE, -1, -1, -1, EXT_RGB_PIXELSIZE, EXT_RGBX_PIXELSIZE,\n  EXT_BGR_PIXELSIZE, EXT_BGRX_PIXELSIZE, EXT_XBGR_PIXELSIZE, EXT_XRGB_PIXELSIZE,\n  EXT_RGBX_PIXELSIZE, EXT_BGRX_PIXELSIZE, EXT_XBGR_PIXELSIZE, EXT_XRGB_PIXELSIZE,\n  -1\n};\n\n/* Definitions for speed-related optimizations. */\n\n/* On some machines (notably 68000 series) \"int\" is 32 bits, but multiplying\n * two 16-bit shorts is faster than multiplying two ints.  Define MULTIPLIER\n * as short on such a machine.  MULTIPLIER must be at least 16 bits wide.\n */\n\n#ifndef MULTIPLIER\n#ifndef WITH_SIMD\n#define MULTIPLIER  int         /* type for fastest integer multiply */\n#else\n#define MULTIPLIER  short       /* prefer 16-bit with SIMD for parellelism */\n#endif\n#endif\n\n\n/* FAST_FLOAT should be either float or double, whichever is done faster\n * by your compiler.  (Note that this type is only used in the floating point\n * DCT routines, so it only matters if you've defined DCT_FLOAT_SUPPORTED.)\n */\n\n#ifndef FAST_FLOAT\n#define FAST_FLOAT  float\n#endif\n\n#endif /* JPEG_INTERNAL_OPTIONS */\n"
        },
        {
          "name": "jpeg_nbits.c",
          "type": "blob",
          "size": 264.7587890625,
          "content": "/*\n * Copyright (C) 2024, D. R. Commander.\n *\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n */\n\n#include \"jpeg_nbits.h\"\n#include \"jconfigint.h\"\n\n\n#ifndef USE_CLZ_INTRINSIC\n\n#define INCLUDE_JPEG_NBITS_TABLE\n\n/* When building for x86[-64] with the SIMD extensions enabled, the C Huffman\n * encoders can reuse jpeg_nbits_table from the SSE2 baseline Huffman encoder.\n */\n#if (defined(__x86_64__) || defined(__i386__) || defined(_M_IX86) || \\\n     defined(_M_X64)) && defined(WITH_SIMD)\n#undef INCLUDE_JPEG_NBITS_TABLE\n#endif\n\n#endif\n\n\n#ifdef INCLUDE_JPEG_NBITS_TABLE\n\nconst unsigned char HIDDEN jpeg_nbits_table[65536] = {\n   0,  1,  2,  2,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,\n   5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n   6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n   6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n   7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n   7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n   7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n   7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n   8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n   8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n   8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n   8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n   8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n   8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n   8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n   8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16\n};\n\n#else\n\n/* Suppress compiler warnings about empty translation unit. */\n\ntypedef int dummy_jpeg_nbits_table;\n\n#endif\n"
        },
        {
          "name": "jpeg_nbits.h",
          "type": "blob",
          "size": 1.6611328125,
          "content": "/*\n * Copyright (C) 2014, 2021, 2024, D. R. Commander.\n * Copyright (C) 2014, Olle Liljenzin.\n * Copyright (C) 2020, Arm Limited.\n *\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n */\n\n/*\n * NOTE: If USE_CLZ_INTRINSIC is defined, then clz/bsr instructions will be\n * used for bit counting rather than the lookup table.  This will reduce the\n * memory footprint by 64k, which is important for some mobile applications\n * that create many isolated instances of libjpeg-turbo (web browsers, for\n * instance.)  This may improve performance on some mobile platforms as well.\n * This feature is enabled by default only on Arm processors, because some x86\n * chips have a slow implementation of bsr, and the use of clz/bsr cannot be\n * shown to have a significant performance impact even on the x86 chips that\n * have a fast implementation of it.  When building for Armv6, you can\n * explicitly disable the use of clz/bsr by adding -mthumb to the compiler\n * flags (this defines __thumb__).\n */\n\n/* NOTE: Both GCC and Clang define __GNUC__ */\n#if (defined(__GNUC__) && (defined(__arm__) || defined(__aarch64__))) || \\\n    defined(_M_ARM) || defined(_M_ARM64)\n#if !defined(__thumb__) || defined(__thumb2__)\n#define USE_CLZ_INTRINSIC\n#endif\n#endif\n\n#ifdef USE_CLZ_INTRINSIC\n#if defined(_MSC_VER) && !defined(__clang__)\n#define JPEG_NBITS_NONZERO(x)  (32 - _CountLeadingZeros(x))\n#else\n#define JPEG_NBITS_NONZERO(x)  (32 - __builtin_clz(x))\n#endif\n#define JPEG_NBITS(x)          (x ? JPEG_NBITS_NONZERO(x) : 0)\n#else\nextern const unsigned char jpeg_nbits_table[65536];\n#define JPEG_NBITS(x)          (jpeg_nbits_table[x])\n#define JPEG_NBITS_NONZERO(x)  JPEG_NBITS(x)\n#endif\n"
        },
        {
          "name": "jpegapicomp.h",
          "type": "blob",
          "size": 1.1064453125,
          "content": "/*\n * jpegapicomp.h\n *\n * Copyright (C) 2010, 2020, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * JPEG compatibility macros\n * These declarations are considered internal to the JPEG library; most\n * applications using the library shouldn't need to include this file.\n */\n\n#if JPEG_LIB_VERSION >= 70\n#define _DCT_scaled_size  DCT_h_scaled_size\n#define _DCT_h_scaled_size  DCT_h_scaled_size\n#define _DCT_v_scaled_size  DCT_v_scaled_size\n#define _min_DCT_scaled_size  min_DCT_h_scaled_size\n#define _min_DCT_h_scaled_size  min_DCT_h_scaled_size\n#define _min_DCT_v_scaled_size  min_DCT_v_scaled_size\n#define _jpeg_width  jpeg_width\n#define _jpeg_height  jpeg_height\n#define JERR_ARITH_NOTIMPL  JERR_NOT_COMPILED\n#else\n#define _DCT_scaled_size  DCT_scaled_size\n#define _DCT_h_scaled_size  DCT_scaled_size\n#define _DCT_v_scaled_size  DCT_scaled_size\n#define _min_DCT_scaled_size  min_DCT_scaled_size\n#define _min_DCT_h_scaled_size  min_DCT_scaled_size\n#define _min_DCT_v_scaled_size  min_DCT_scaled_size\n#define _jpeg_width  image_width\n#define _jpeg_height  image_height\n#endif\n"
        },
        {
          "name": "jpegint.h",
          "type": "blob",
          "size": 29.65625,
          "content": "/*\n * jpegint.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 1997-2009 by Guido Vollbeding.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015-2017, 2019, 2021-2022, 2024, D. R. Commander.\n * Copyright (C) 2015, Google, Inc.\n * Copyright (C) 2021, Alex Richardson.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file provides common declarations for the various JPEG modules.\n * These declarations are considered internal to the JPEG library; most\n * applications using the library shouldn't need to include this file.\n */\n\n\n/* Representation of a spatial difference value.\n * This should be a signed value of at least 16 bits; int is usually OK.\n */\n\ntypedef int JDIFF;\n\ntypedef JDIFF FAR *JDIFFROW;    /* pointer to one row of difference values */\ntypedef JDIFFROW *JDIFFARRAY;   /* ptr to some rows (a 2-D diff array) */\ntypedef JDIFFARRAY *JDIFFIMAGE; /* a 3-D diff array: top index is color */\n\n\n/* Declarations for both compression & decompression */\n\ntypedef enum {            /* Operating modes for buffer controllers */\n  JBUF_PASS_THRU,         /* Plain stripwise operation */\n  /* Remaining modes require a full-image buffer to have been created */\n  JBUF_SAVE_SOURCE,       /* Run source subobject only, save output */\n  JBUF_CRANK_DEST,        /* Run dest subobject only, using saved data */\n  JBUF_SAVE_AND_PASS,     /* Run both subobjects, save output */\n  JBUF_REQUANT            /* Requantize */\n} J_BUF_MODE;\n\n/* Values of global_state field (jdapi.c has some dependencies on ordering!) */\n#define CSTATE_START     100    /* after create_compress */\n#define CSTATE_SCANNING  101    /* start_compress done, write_scanlines OK */\n#define CSTATE_RAW_OK    102    /* start_compress done, write_raw_data OK */\n#define CSTATE_WRCOEFS   103    /* jpeg_write_coefficients done */\n#define DSTATE_START     200    /* after create_decompress */\n#define DSTATE_INHEADER  201    /* reading header markers, no SOS yet */\n#define DSTATE_READY     202    /* found SOS, ready for start_decompress */\n#define DSTATE_PRELOAD   203    /* reading multiscan file in start_decompress*/\n#define DSTATE_PRESCAN   204    /* performing dummy pass for 2-pass quant */\n#define DSTATE_SCANNING  205    /* start_decompress done, read_scanlines OK */\n#define DSTATE_RAW_OK    206    /* start_decompress done, read_raw_data OK */\n#define DSTATE_BUFIMAGE  207    /* expecting jpeg_start_output */\n#define DSTATE_BUFPOST   208    /* looking for SOS/EOI in jpeg_finish_output */\n#define DSTATE_RDCOEFS   209    /* reading file in jpeg_read_coefficients */\n#define DSTATE_STOPPING  210    /* looking for EOI in jpeg_finish_decompress */\n\n\n/* JLONG must hold at least signed 32-bit values. */\ntypedef long JLONG;\n\n/* JUINTPTR must hold pointer values. */\n#ifdef __UINTPTR_TYPE__\n/*\n * __UINTPTR_TYPE__ is GNU-specific and available in GCC 4.6+ and Clang 3.0+.\n * Fortunately, that is sufficient to support the few architectures for which\n * sizeof(void *) != sizeof(size_t).  The only other options would require C99\n * or Clang-specific builtins.\n */\ntypedef __UINTPTR_TYPE__ JUINTPTR;\n#else\ntypedef size_t JUINTPTR;\n#endif\n\n#define IsExtRGB(cs) \\\n  (cs == JCS_RGB || (cs >= JCS_EXT_RGB && cs <= JCS_EXT_ARGB))\n\n/*\n * Left shift macro that handles a negative operand without causing any\n * sanitizer warnings\n */\n\n#define LEFT_SHIFT(a, b)  ((JLONG)((unsigned long)(a) << (b)))\n\n\n/* Declarations for compression modules */\n\n/* Master control module */\nstruct jpeg_comp_master {\n  void (*prepare_for_pass) (j_compress_ptr cinfo);\n  void (*pass_startup) (j_compress_ptr cinfo);\n  void (*finish_pass) (j_compress_ptr cinfo);\n\n  /* State variables made visible to other modules */\n  boolean call_pass_startup;    /* True if pass_startup must be called */\n  boolean is_last_pass;         /* True during last pass */\n\n  /* Extension parameters */\n  boolean optimize_scans; /* TRUE=optimize progressive coding scans */\n  boolean trellis_quant; /* TRUE=use trellis quantization */\n  boolean trellis_quant_dc; /* TRUE=use trellis quant for DC coefficient */\n  boolean trellis_eob_opt; /* TRUE=optimize for sequences of EOB */\n  boolean use_lambda_weight_tbl; /* TRUE=use lambda weighting table */\n  boolean use_scans_in_trellis; /* TRUE=use scans in trellis optimization */\n  boolean trellis_passes; /* TRUE=currently doing trellis-related passes [not exposed] */\n  boolean trellis_q_opt; /* TRUE=optimize quant table in trellis loop */\n  boolean overshoot_deringing; /* TRUE=preprocess input to reduce ringing of edges on white background */\n\n  double norm_src[NUM_QUANT_TBLS][DCTSIZE2];\n  double norm_coef[NUM_QUANT_TBLS][DCTSIZE2];\n\n  int compress_profile; /* compression profile */\n  int dc_scan_opt_mode; /* DC scan optimization mode */\n  int quant_tbl_master_idx; /* Quantization table master index */\n  int trellis_freq_split; /* splitting point for frequency in trellis quantization */\n  int trellis_num_loops; /* number of trellis loops */\n\n  int num_scans_luma; /* # of entries in scan_info array pertaining to luma (used when optimize_scans is TRUE */\n  int num_scans_luma_dc;\n  int num_scans_chroma_dc;\n  int num_frequency_splits;\n\n  int Al_max_luma; /* maximum value of Al tested when optimizing scans (luma) */\n  int Al_max_chroma; /* maximum value of Al tested when optimizing scans (chroma) */\n\n  float lambda_log_scale1;\n  float lambda_log_scale2;\n  \n  float trellis_delta_dc_weight;\n  boolean lossless;             /* True if lossless mode is enabled */\n};\n\n#ifdef C_ARITH_CODING_SUPPORTED\n/* The following two definitions specify the allocation chunk size\n * for the statistics area.\n * According to sections F.1.4.4.1.3 and F.1.4.4.2, we need at least\n * 49 statistics bins for DC, and 245 statistics bins for AC coding.\n *\n * We use a compact representation with 1 byte per statistics bin,\n * thus the numbers directly represent byte sizes.\n * This 1 byte per statistics bin contains the meaning of the MPS\n * (more probable symbol) in the highest bit (mask 0x80), and the\n * index into the probability estimation state machine table\n * in the lower bits (mask 0x7F).\n */\n\n#define DC_STAT_BINS 64\n#define AC_STAT_BINS 256\n\ntypedef struct {\n  float rate_dc[DC_STAT_BINS][2];\n  float rate_ac[AC_STAT_BINS][2];\n  int arith_dc_L;\n  int arith_dc_U;\n  int arith_ac_K;\n} arith_rates;\n#endif\n\n/* Main buffer control (downsampled-data buffer) */\nstruct jpeg_c_main_controller {\n  void (*start_pass) (j_compress_ptr cinfo, J_BUF_MODE pass_mode);\n  void (*process_data) (j_compress_ptr cinfo, JSAMPARRAY input_buf,\n                        JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail);\n  void (*process_data_12) (j_compress_ptr cinfo, J12SAMPARRAY input_buf,\n                           JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail);\n#ifdef C_LOSSLESS_SUPPORTED\n  void (*process_data_16) (j_compress_ptr cinfo, J16SAMPARRAY input_buf,\n                           JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail);\n#endif\n};\n\n/* Compression preprocessing (downsampling input buffer control) */\nstruct jpeg_c_prep_controller {\n  void (*start_pass) (j_compress_ptr cinfo, J_BUF_MODE pass_mode);\n  void (*pre_process_data) (j_compress_ptr cinfo, JSAMPARRAY input_buf,\n                            JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail,\n                            JSAMPIMAGE output_buf,\n                            JDIMENSION *out_row_group_ctr,\n                            JDIMENSION out_row_groups_avail);\n  void (*pre_process_data_12) (j_compress_ptr cinfo, J12SAMPARRAY input_buf,\n                               JDIMENSION *in_row_ctr,\n                               JDIMENSION in_rows_avail,\n                               J12SAMPIMAGE output_buf,\n                               JDIMENSION *out_row_group_ctr,\n                               JDIMENSION out_row_groups_avail);\n#ifdef C_LOSSLESS_SUPPORTED\n  void (*pre_process_data_16) (j_compress_ptr cinfo, J16SAMPARRAY input_buf,\n                               JDIMENSION *in_row_ctr,\n                               JDIMENSION in_rows_avail,\n                               J16SAMPIMAGE output_buf,\n                               JDIMENSION *out_row_group_ctr,\n                               JDIMENSION out_row_groups_avail);\n#endif\n};\n\n/* Lossy mode: Coefficient buffer control\n * Lossless mode: Difference buffer control\n */\nstruct jpeg_c_coef_controller {\n  void (*start_pass) (j_compress_ptr cinfo, J_BUF_MODE pass_mode);\n  boolean (*compress_data) (j_compress_ptr cinfo, JSAMPIMAGE input_buf);\n  boolean (*compress_data_12) (j_compress_ptr cinfo, J12SAMPIMAGE input_buf);\n#ifdef C_LOSSLESS_SUPPORTED\n  boolean (*compress_data_16) (j_compress_ptr cinfo, J16SAMPIMAGE input_buf);\n#endif\n};\n\n/* Colorspace conversion */\nstruct jpeg_color_converter {\n  void (*start_pass) (j_compress_ptr cinfo);\n  void (*color_convert) (j_compress_ptr cinfo, JSAMPARRAY input_buf,\n                         JSAMPIMAGE output_buf, JDIMENSION output_row,\n                         int num_rows);\n  void (*color_convert_12) (j_compress_ptr cinfo, J12SAMPARRAY input_buf,\n                            J12SAMPIMAGE output_buf, JDIMENSION output_row,\n                            int num_rows);\n#ifdef C_LOSSLESS_SUPPORTED\n  void (*color_convert_16) (j_compress_ptr cinfo, J16SAMPARRAY input_buf,\n                            J16SAMPIMAGE output_buf, JDIMENSION output_row,\n                            int num_rows);\n#endif\n};\n\n/* Downsampling */\nstruct jpeg_downsampler {\n  void (*start_pass) (j_compress_ptr cinfo);\n  void (*downsample) (j_compress_ptr cinfo, JSAMPIMAGE input_buf,\n                      JDIMENSION in_row_index, JSAMPIMAGE output_buf,\n                      JDIMENSION out_row_group_index);\n  void (*downsample_12) (j_compress_ptr cinfo, J12SAMPIMAGE input_buf,\n                         JDIMENSION in_row_index, J12SAMPIMAGE output_buf,\n                         JDIMENSION out_row_group_index);\n#ifdef C_LOSSLESS_SUPPORTED\n  void (*downsample_16) (j_compress_ptr cinfo, J16SAMPIMAGE input_buf,\n                         JDIMENSION in_row_index, J16SAMPIMAGE output_buf,\n                         JDIMENSION out_row_group_index);\n#endif\n\n  boolean need_context_rows;    /* TRUE if need rows above & below */\n};\n\n/* Lossy mode: Forward DCT (also controls coefficient quantization)\n * Lossless mode: Prediction, sample differencing, and point transform\n */\nstruct jpeg_forward_dct {\n  void (*start_pass) (j_compress_ptr cinfo);\n\n  /* Lossy mode */\n  /* perhaps this should be an array??? */\n  void (*forward_DCT) (j_compress_ptr cinfo, jpeg_component_info *compptr,\n                       JSAMPARRAY sample_data, JBLOCKROW coef_blocks,\n                       JDIMENSION start_row, JDIMENSION start_col,\n                       JDIMENSION num_blocks, JBLOCKROW dst);\n  void (*forward_DCT_12) (j_compress_ptr cinfo, jpeg_component_info *compptr,\n                          J12SAMPARRAY sample_data, JBLOCKROW coef_blocks,\n                          JDIMENSION start_row, JDIMENSION start_col,\n                          JDIMENSION num_blocks, JBLOCKROW dst);\n};\n\n/* Entropy encoding */\nstruct jpeg_entropy_encoder {\n  void (*start_pass) (j_compress_ptr cinfo, boolean gather_statistics);\n\n  /* Lossy mode */\n  boolean (*encode_mcu) (j_compress_ptr cinfo, JBLOCKROW *MCU_data);\n  /* Lossless mode */\n  JDIMENSION (*encode_mcus) (j_compress_ptr cinfo, JDIFFIMAGE diff_buf,\n                             JDIMENSION MCU_row_num, JDIMENSION MCU_col_num,\n                             JDIMENSION nMCU);\n\n  void (*finish_pass) (j_compress_ptr cinfo);\n};\n\n/* Marker writing */\nstruct jpeg_marker_writer {\n  void (*write_file_header) (j_compress_ptr cinfo);\n  void (*write_frame_header) (j_compress_ptr cinfo);\n  void (*write_scan_header) (j_compress_ptr cinfo);\n  void (*write_file_trailer) (j_compress_ptr cinfo);\n  void (*write_tables_only) (j_compress_ptr cinfo);\n  /* These routines are exported to allow insertion of extra markers */\n  /* Probably only COM and APPn markers should be written this way */\n  void (*write_marker_header) (j_compress_ptr cinfo, int marker,\n                               unsigned int datalen);\n  void (*write_marker_byte) (j_compress_ptr cinfo, int val);\n};\n\n\n/* Declarations for decompression modules */\n\n/* Master control module */\nstruct jpeg_decomp_master {\n  void (*prepare_for_output_pass) (j_decompress_ptr cinfo);\n  void (*finish_output_pass) (j_decompress_ptr cinfo);\n\n  /* State variables made visible to other modules */\n  boolean is_dummy_pass;        /* True during 1st pass for 2-pass quant */\n  boolean lossless;             /* True if decompressing a lossless image */\n\n  /* Partial decompression variables */\n  JDIMENSION first_iMCU_col;\n  JDIMENSION last_iMCU_col;\n  JDIMENSION first_MCU_col[MAX_COMPONENTS];\n  JDIMENSION last_MCU_col[MAX_COMPONENTS];\n  boolean jinit_upsampler_no_alloc;\n\n  /* Last iMCU row that was successfully decoded */\n  JDIMENSION last_good_iMCU_row;\n\n  /* Tail of list of saved markers */\n  jpeg_saved_marker_ptr marker_list_end;\n};\n\n/* Input control module */\nstruct jpeg_input_controller {\n  int (*consume_input) (j_decompress_ptr cinfo);\n  void (*reset_input_controller) (j_decompress_ptr cinfo);\n  void (*start_input_pass) (j_decompress_ptr cinfo);\n  void (*finish_input_pass) (j_decompress_ptr cinfo);\n\n  /* State variables made visible to other modules */\n  boolean has_multiple_scans;   /* True if file has multiple scans */\n  boolean eoi_reached;          /* True when EOI has been consumed */\n};\n\n/* Main buffer control (downsampled-data buffer) */\nstruct jpeg_d_main_controller {\n  void (*start_pass) (j_decompress_ptr cinfo, J_BUF_MODE pass_mode);\n  void (*process_data) (j_decompress_ptr cinfo, JSAMPARRAY output_buf,\n                        JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);\n  void (*process_data_12) (j_decompress_ptr cinfo, J12SAMPARRAY output_buf,\n                           JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);\n#ifdef D_LOSSLESS_SUPPORTED\n  void (*process_data_16) (j_decompress_ptr cinfo, J16SAMPARRAY output_buf,\n                           JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);\n#endif\n};\n\n/* Lossy mode: Coefficient buffer control\n * Lossless mode: Difference buffer control\n */\nstruct jpeg_d_coef_controller {\n  void (*start_input_pass) (j_decompress_ptr cinfo);\n  int (*consume_data) (j_decompress_ptr cinfo);\n  void (*start_output_pass) (j_decompress_ptr cinfo);\n  int (*decompress_data) (j_decompress_ptr cinfo, JSAMPIMAGE output_buf);\n  int (*decompress_data_12) (j_decompress_ptr cinfo, J12SAMPIMAGE output_buf);\n#ifdef D_LOSSLESS_SUPPORTED\n  int (*decompress_data_16) (j_decompress_ptr cinfo, J16SAMPIMAGE output_buf);\n#endif\n\n  /* These variables keep track of the current location of the input side. */\n  /* cinfo->input_iMCU_row is also used for this. */\n  JDIMENSION MCU_ctr;           /* counts MCUs processed in current row */\n  int MCU_vert_offset;          /* counts MCU rows within iMCU row */\n  int MCU_rows_per_iMCU_row;    /* number of such rows needed */\n\n  /* The output side's location is represented by cinfo->output_iMCU_row. */\n\n  /* Lossy mode */\n  /* Pointer to array of coefficient virtual arrays, or NULL if none */\n  jvirt_barray_ptr *coef_arrays;\n};\n\n/* Decompression postprocessing (color quantization buffer control) */\nstruct jpeg_d_post_controller {\n  void (*start_pass) (j_decompress_ptr cinfo, J_BUF_MODE pass_mode);\n  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                             JDIMENSION *in_row_group_ctr,\n                             JDIMENSION in_row_groups_avail,\n                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n                             JDIMENSION out_rows_avail);\n  void (*post_process_data_12) (j_decompress_ptr cinfo, J12SAMPIMAGE input_buf,\n                                JDIMENSION *in_row_group_ctr,\n                                JDIMENSION in_row_groups_avail,\n                                J12SAMPARRAY output_buf,\n                                JDIMENSION *out_row_ctr,\n                                JDIMENSION out_rows_avail);\n#ifdef D_LOSSLESS_SUPPORTED\n  void (*post_process_data_16) (j_decompress_ptr cinfo, J16SAMPIMAGE input_buf,\n                                JDIMENSION *in_row_group_ctr,\n                                JDIMENSION in_row_groups_avail,\n                                J16SAMPARRAY output_buf,\n                                JDIMENSION *out_row_ctr,\n                                JDIMENSION out_rows_avail);\n#endif\n};\n\n/* Marker reading & parsing */\nstruct jpeg_marker_reader {\n  void (*reset_marker_reader) (j_decompress_ptr cinfo);\n  /* Read markers until SOS or EOI.\n   * Returns same codes as are defined for jpeg_consume_input:\n   * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.\n   */\n  int (*read_markers) (j_decompress_ptr cinfo);\n  /* Read a restart marker --- exported for use by entropy decoder only */\n  jpeg_marker_parser_method read_restart_marker;\n\n  /* State of marker reader --- nominally internal, but applications\n   * supplying COM or APPn handlers might like to know the state.\n   */\n  boolean saw_SOI;              /* found SOI? */\n  boolean saw_SOF;              /* found SOF? */\n  int next_restart_num;         /* next restart number expected (0-7) */\n  unsigned int discarded_bytes; /* # of bytes skipped looking for a marker */\n};\n\n/* Entropy decoding */\nstruct jpeg_entropy_decoder {\n  void (*start_pass) (j_decompress_ptr cinfo);\n\n  /* Lossy mode */\n  boolean (*decode_mcu) (j_decompress_ptr cinfo, JBLOCKROW *MCU_data);\n  /* Lossless mode */\n  JDIMENSION (*decode_mcus) (j_decompress_ptr cinfo, JDIFFIMAGE diff_buf,\n                             JDIMENSION MCU_row_num, JDIMENSION MCU_col_num,\n                             JDIMENSION nMCU);\n  boolean (*process_restart) (j_decompress_ptr cinfo);\n\n  /* This is here to share code between baseline and progressive decoders; */\n  /* other modules probably should not use it */\n  boolean insufficient_data;    /* set TRUE after emitting warning */\n};\n\n/* Lossy mode: Inverse DCT (also performs dequantization)\n * Lossless mode: Prediction, sample undifferencing, point transform, and\n * sample size scaling\n */\ntypedef void (*inverse_DCT_method_ptr) (j_decompress_ptr cinfo,\n                                        jpeg_component_info *compptr,\n                                        JCOEFPTR coef_block,\n                                        JSAMPARRAY output_buf,\n                                        JDIMENSION output_col);\ntypedef void (*inverse_DCT_12_method_ptr) (j_decompress_ptr cinfo,\n                                           jpeg_component_info *compptr,\n                                           JCOEFPTR coef_block,\n                                           J12SAMPARRAY output_buf,\n                                           JDIMENSION output_col);\n\nstruct jpeg_inverse_dct {\n  void (*start_pass) (j_decompress_ptr cinfo);\n\n  /* Lossy mode */\n  /* It is useful to allow each component to have a separate IDCT method. */\n  inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];\n  inverse_DCT_12_method_ptr inverse_DCT_12[MAX_COMPONENTS];\n};\n\n/* Upsampling (note that upsampler must also call color converter) */\nstruct jpeg_upsampler {\n  void (*start_pass) (j_decompress_ptr cinfo);\n  void (*upsample) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                    JDIMENSION *in_row_group_ctr,\n                    JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                    JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);\n  void (*upsample_12) (j_decompress_ptr cinfo, J12SAMPIMAGE input_buf,\n                       JDIMENSION *in_row_group_ctr,\n                       JDIMENSION in_row_groups_avail, J12SAMPARRAY output_buf,\n                       JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);\n#ifdef D_LOSSLESS_SUPPORTED\n  void (*upsample_16) (j_decompress_ptr cinfo, J16SAMPIMAGE input_buf,\n                       JDIMENSION *in_row_group_ctr,\n                       JDIMENSION in_row_groups_avail, J16SAMPARRAY output_buf,\n                       JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);\n#endif\n\n  boolean need_context_rows;    /* TRUE if need rows above & below */\n};\n\n/* Colorspace conversion */\nstruct jpeg_color_deconverter {\n  void (*start_pass) (j_decompress_ptr cinfo);\n  void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                         JDIMENSION input_row, JSAMPARRAY output_buf,\n                         int num_rows);\n  void (*color_convert_12) (j_decompress_ptr cinfo, J12SAMPIMAGE input_buf,\n                            JDIMENSION input_row, J12SAMPARRAY output_buf,\n                            int num_rows);\n#ifdef D_LOSSLESS_SUPPORTED\n  void (*color_convert_16) (j_decompress_ptr cinfo, J16SAMPIMAGE input_buf,\n                            JDIMENSION input_row, J16SAMPARRAY output_buf,\n                            int num_rows);\n#endif\n};\n\n/* Color quantization or color precision reduction */\nstruct jpeg_color_quantizer {\n  void (*start_pass) (j_decompress_ptr cinfo, boolean is_pre_scan);\n  void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\n                          JSAMPARRAY output_buf, int num_rows);\n  void (*color_quantize_12) (j_decompress_ptr cinfo, J12SAMPARRAY input_buf,\n                             J12SAMPARRAY output_buf, int num_rows);\n  void (*finish_pass) (j_decompress_ptr cinfo);\n  void (*new_color_map) (j_decompress_ptr cinfo);\n};\n\n\n/* Miscellaneous useful macros */\n\n#undef MAX\n#define MAX(a, b)       ((a) > (b) ? (a) : (b))\n#undef MIN\n#define MIN(a, b)       ((a) < (b) ? (a) : (b))\n\n#ifdef ZERO_BUFFERS\n#define MALLOC(size)  calloc(1, size)\n#else\n#define MALLOC(size)  malloc(size)\n#endif\n\n\n/* We assume that right shift corresponds to signed division by 2 with\n * rounding towards minus infinity.  This is correct for typical \"arithmetic\n * shift\" instructions that shift in copies of the sign bit.  But some\n * C compilers implement >> with an unsigned shift.  For these machines you\n * must define RIGHT_SHIFT_IS_UNSIGNED.\n * RIGHT_SHIFT provides a proper signed right shift of a JLONG quantity.\n * It is only applied with constant shift counts.  SHIFT_TEMPS must be\n * included in the variables of any routine using RIGHT_SHIFT.\n */\n\n#ifdef RIGHT_SHIFT_IS_UNSIGNED\n#define SHIFT_TEMPS     JLONG shift_temp;\n#define RIGHT_SHIFT(x, shft) \\\n  ((shift_temp = (x)) < 0 ? \\\n   (shift_temp >> (shft)) | ((~((JLONG)0)) << (32 - (shft))) : \\\n   (shift_temp >> (shft)))\n#else\n#define SHIFT_TEMPS\n#define RIGHT_SHIFT(x, shft)    ((x) >> (shft))\n#endif\n\n\n/* Compression module initialization routines */\nEXTERN(void) jinit_compress_master(j_compress_ptr cinfo);\nEXTERN(void) jinit_c_master_control(j_compress_ptr cinfo,\n                                    boolean transcode_only);\nEXTERN(void) jinit_c_main_controller(j_compress_ptr cinfo,\n                                     boolean need_full_buffer);\nEXTERN(void) j12init_c_main_controller(j_compress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) jinit_c_prep_controller(j_compress_ptr cinfo,\n                                     boolean need_full_buffer);\nEXTERN(void) j12init_c_prep_controller(j_compress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) jinit_c_coef_controller(j_compress_ptr cinfo,\n                                     boolean need_full_buffer);\nEXTERN(void) j12init_c_coef_controller(j_compress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) jinit_color_converter(j_compress_ptr cinfo);\nEXTERN(void) j12init_color_converter(j_compress_ptr cinfo);\nEXTERN(void) jinit_downsampler(j_compress_ptr cinfo);\nEXTERN(void) j12init_downsampler(j_compress_ptr cinfo);\nEXTERN(void) jinit_forward_dct(j_compress_ptr cinfo);\nEXTERN(void) j12init_forward_dct(j_compress_ptr cinfo);\nEXTERN(void) jinit_huff_encoder(j_compress_ptr cinfo);\nEXTERN(void) jinit_phuff_encoder(j_compress_ptr cinfo);\nEXTERN(void) jinit_arith_encoder(j_compress_ptr cinfo);\nEXTERN(void) jinit_marker_writer(j_compress_ptr cinfo);\n#ifdef C_LOSSLESS_SUPPORTED\nEXTERN(void) j16init_c_main_controller(j_compress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) j16init_c_prep_controller(j_compress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) j16init_color_converter(j_compress_ptr cinfo);\nEXTERN(void) j16init_downsampler(j_compress_ptr cinfo);\nEXTERN(void) jinit_c_diff_controller(j_compress_ptr cinfo,\n                                     boolean need_full_buffer);\nEXTERN(void) j12init_c_diff_controller(j_compress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) j16init_c_diff_controller(j_compress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) jinit_lhuff_encoder(j_compress_ptr cinfo);\nEXTERN(void) jinit_lossless_compressor(j_compress_ptr cinfo);\nEXTERN(void) j12init_lossless_compressor(j_compress_ptr cinfo);\nEXTERN(void) j16init_lossless_compressor(j_compress_ptr cinfo);\n#endif\n\n/* Decompression module initialization routines */\nEXTERN(void) jinit_master_decompress(j_decompress_ptr cinfo);\nEXTERN(void) jinit_d_main_controller(j_decompress_ptr cinfo,\n                                     boolean need_full_buffer);\nEXTERN(void) j12init_d_main_controller(j_decompress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) jinit_d_coef_controller(j_decompress_ptr cinfo,\n                                     boolean need_full_buffer);\nEXTERN(void) j12init_d_coef_controller(j_decompress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) jinit_d_post_controller(j_decompress_ptr cinfo,\n                                     boolean need_full_buffer);\nEXTERN(void) j12init_d_post_controller(j_decompress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) jinit_input_controller(j_decompress_ptr cinfo);\nEXTERN(void) jinit_marker_reader(j_decompress_ptr cinfo);\nEXTERN(void) jinit_huff_decoder(j_decompress_ptr cinfo);\nEXTERN(void) jinit_phuff_decoder(j_decompress_ptr cinfo);\nEXTERN(void) jinit_arith_decoder(j_decompress_ptr cinfo);\nEXTERN(void) jinit_inverse_dct(j_decompress_ptr cinfo);\nEXTERN(void) j12init_inverse_dct(j_decompress_ptr cinfo);\nEXTERN(void) jinit_upsampler(j_decompress_ptr cinfo);\nEXTERN(void) j12init_upsampler(j_decompress_ptr cinfo);\nEXTERN(void) jinit_color_deconverter(j_decompress_ptr cinfo);\nEXTERN(void) j12init_color_deconverter(j_decompress_ptr cinfo);\nEXTERN(void) jinit_1pass_quantizer(j_decompress_ptr cinfo);\nEXTERN(void) j12init_1pass_quantizer(j_decompress_ptr cinfo);\nEXTERN(void) jinit_2pass_quantizer(j_decompress_ptr cinfo);\nEXTERN(void) j12init_2pass_quantizer(j_decompress_ptr cinfo);\nEXTERN(void) jinit_merged_upsampler(j_decompress_ptr cinfo);\nEXTERN(void) j12init_merged_upsampler(j_decompress_ptr cinfo);\n#ifdef D_LOSSLESS_SUPPORTED\nEXTERN(void) j16init_d_main_controller(j_decompress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) j16init_d_post_controller(j_decompress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) j16init_upsampler(j_decompress_ptr cinfo);\nEXTERN(void) j16init_color_deconverter(j_decompress_ptr cinfo);\nEXTERN(void) jinit_d_diff_controller(j_decompress_ptr cinfo,\n                                     boolean need_full_buffer);\nEXTERN(void) j12init_d_diff_controller(j_decompress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) j16init_d_diff_controller(j_decompress_ptr cinfo,\n                                       boolean need_full_buffer);\nEXTERN(void) jinit_lhuff_decoder(j_decompress_ptr cinfo);\nEXTERN(void) jinit_lossless_decompressor(j_decompress_ptr cinfo);\nEXTERN(void) j12init_lossless_decompressor(j_decompress_ptr cinfo);\nEXTERN(void) j16init_lossless_decompressor(j_decompress_ptr cinfo);\n#endif\n\n/* Memory manager initialization */\nEXTERN(void) jinit_memory_mgr(j_common_ptr cinfo);\n\n#if JPEG_LIB_VERSION >= 80 || defined(MEM_SRCDST_SUPPORTED)\nEXTERN(void)\njpeg_mem_dest_internal (j_compress_ptr cinfo,\n               unsigned char **outbuffer, unsigned long *outsize, int pool_id);\n#endif\n\n/* Utility routines in jutils.c */\nEXTERN(long) jdiv_round_up(long a, long b);\nEXTERN(long) jround_up(long a, long b);\nEXTERN(void) jcopy_sample_rows(JSAMPARRAY input_array, int source_row,\n                               JSAMPARRAY output_array, int dest_row,\n                               int num_rows, JDIMENSION num_cols);\nEXTERN(void) j12copy_sample_rows(J12SAMPARRAY input_array, int source_row,\n                                 J12SAMPARRAY output_array, int dest_row,\n                                 int num_rows, JDIMENSION num_cols);\n#if defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED)\nEXTERN(void) j16copy_sample_rows(J16SAMPARRAY input_array, int source_row,\n                                 J16SAMPARRAY output_array, int dest_row,\n                                 int num_rows, JDIMENSION num_cols);\n#endif\nEXTERN(void) jcopy_block_row(JBLOCKROW input_row, JBLOCKROW output_row,\n                             JDIMENSION num_blocks);\nEXTERN(void) jzero_far(void *target, size_t bytestozero);\n\n#ifdef C_ARITH_CODING_SUPPORTED\nEXTERN(void) jget_arith_rates (j_compress_ptr cinfo, int dc_tbl_no, int ac_tbl_no, arith_rates *r);\n\nEXTERN(void) quantize_trellis_arith\n(j_compress_ptr cinfo, arith_rates *r, JBLOCKROW coef_blocks, JBLOCKROW src, JDIMENSION num_blocks,\n JQUANT_TBL * qtbl, double *norm_src, double *norm_coef, JCOEF *last_dc_val,\n JBLOCKROW coef_blocks_above, JBLOCKROW src_above);\n#endif\n\n/* Constant tables in jutils.c */\n#if 0                           /* This table is not actually needed in v6a */\nextern const int jpeg_zigzag_order[]; /* natural coef order to zigzag order */\n#endif\nextern const int jpeg_natural_order[]; /* zigzag coef order to natural order */\n\n/* Arithmetic coding probability estimation tables in jaricom.c */\nextern const JLONG jpeg_aritab[];\n"
        },
        {
          "name": "jpeglib.h",
          "type": "blob",
          "size": 58.01953125,
          "content": "/*\n * jpeglib.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1998, Thomas G. Lane.\n * Modified 2002-2009 by Guido Vollbeding.\n * Lossless JPEG Modifications:\n * Copyright (C) 1999, Ken Murchison.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2009-2011, 2013-2014, 2016-2017, 2020, 2022-2024,\n             D. R. Commander.\n * Copyright (C) 2015, Google, Inc.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file defines the application interface for the JPEG library.\n * Most applications using the library need only include this file,\n * and perhaps jerror.h if they want to know the exact error codes.\n */\n\n/* NOTE: This header file does not include stdio.h, despite the fact that it\n * uses FILE and size_t.  That is by design, since the libjpeg API predates the\n * widespread adoption of ANSI/ISO C.  Referring to libjpeg.txt, it is a\n * documented requirement that calling programs \"include system headers that\n * define at least the typedefs FILE and size_t\" before including jpeglib.h.\n * Technically speaking, changing that requirement by including stdio.h here\n * would break backward API compatibility.  Please do not file bug reports,\n * feature requests, or pull requests regarding this.\n */\n\n#ifndef JPEGLIB_H\n#define JPEGLIB_H\n\n/*\n * First we include the configuration files that record how this\n * installation of the JPEG library is set up.  jconfig.h can be\n * generated automatically for many systems.  jmorecfg.h contains\n * manual configuration options that most people need not worry about.\n */\n\n#ifndef JCONFIG_INCLUDED        /* in case jinclude.h already did */\n#include \"jconfig.h\"            /* widely used configuration options */\n#endif\n#include \"jmorecfg.h\"           /* seldom changed options */\n\n\n#ifdef __cplusplus\n#ifndef DONT_USE_EXTERN_C\nextern \"C\" {\n#endif\n#endif\n\n\n/* Various constants determining the sizes of things.\n * All of these are specified by the JPEG standard, so don't change them\n * if you want to be compatible.\n */\n\n/* NOTE: In lossless mode, an MCU contains one or more samples rather than one\n * or more 8x8 DCT blocks, so the term \"data unit\" is used to generically\n * describe a sample in lossless mode or an 8x8 DCT block in lossy mode.  To\n * preserve backward API/ABI compatibility, the field and macro names retain\n * the \"block\" terminology.\n */\n\n#define DCTSIZE             8   /* The basic DCT block is 8x8 samples */\n#define DCTSIZE2            64  /* DCTSIZE squared; # of elements in a block */\n#define NUM_QUANT_TBLS      4   /* Quantization tables are numbered 0..3 */\n#define NUM_HUFF_TBLS       4   /* Huffman tables are numbered 0..3 */\n#define NUM_ARITH_TBLS      16  /* Arith-coding tables are numbered 0..15 */\n#define MAX_COMPS_IN_SCAN   4   /* JPEG limit on # of components in one scan */\n#define MAX_SAMP_FACTOR     4   /* JPEG limit on sampling factors */\n/* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;\n * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.\n * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU\n * to handle it.  We even let you do this from the jconfig.h file.  However,\n * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe\n * sometimes emits noncompliant files doesn't mean you should too.\n */\n#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on data units/MCU */\n#ifndef D_MAX_BLOCKS_IN_MCU\n#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on data units/MCU */\n#endif\n\n\n/* Data structures for images (arrays of samples and of DCT coefficients).\n */\n\ntypedef JSAMPLE *JSAMPROW;      /* ptr to one image row of pixel samples. */\ntypedef JSAMPROW *JSAMPARRAY;   /* ptr to some rows (a 2-D sample array) */\ntypedef JSAMPARRAY *JSAMPIMAGE; /* a 3-D sample array: top index is color */\n\ntypedef J12SAMPLE *J12SAMPROW;      /* ptr to one image row of 12-bit pixel\n                                       samples. */\ntypedef J12SAMPROW *J12SAMPARRAY;   /* ptr to some 12-bit sample rows (a 2-D\n                                       12-bit sample array) */\ntypedef J12SAMPARRAY *J12SAMPIMAGE; /* a 3-D 12-bit sample array: top index is\n                                       color */\n\ntypedef J16SAMPLE *J16SAMPROW;      /* ptr to one image row of 16-bit pixel\n                                       samples. */\ntypedef J16SAMPROW *J16SAMPARRAY;   /* ptr to some 16-bit sample rows (a 2-D\n                                       16-bit sample array) */\ntypedef J16SAMPARRAY *J16SAMPIMAGE; /* a 3-D 16-bit sample array: top index is\n                                       color */\n\ntypedef JCOEF JBLOCK[DCTSIZE2]; /* one block of coefficients */\ntypedef JBLOCK *JBLOCKROW;      /* pointer to one row of coefficient blocks */\ntypedef JBLOCKROW *JBLOCKARRAY;         /* a 2-D array of coefficient blocks */\ntypedef JBLOCKARRAY *JBLOCKIMAGE;       /* a 3-D array of coefficient blocks */\n\ntypedef JCOEF *JCOEFPTR;        /* useful in a couple of places */\n\n\n/* Types for JPEG compression parameters and working tables. */\n\n\n/* DCT coefficient quantization tables. */\n\ntypedef struct {\n  /* This array gives the coefficient quantizers in natural array order\n   * (not the zigzag order in which they are stored in a JPEG DQT marker).\n   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.\n   */\n  UINT16 quantval[DCTSIZE2];    /* quantization step for each coefficient */\n  /* This field is used only during compression.  It's initialized FALSE when\n   * the table is created, and set TRUE when it's been output to the file.\n   * You could suppress output of a table by setting this to TRUE.\n   * (See jpeg_suppress_tables for an example.)\n   */\n  boolean sent_table;           /* TRUE when table has been output */\n} JQUANT_TBL;\n\n\n/* Huffman coding tables. */\n\ntypedef struct {\n  /* These two fields directly represent the contents of a JPEG DHT marker */\n  UINT8 bits[17];               /* bits[k] = # of symbols with codes of */\n                                /* length k bits; bits[0] is unused */\n  UINT8 huffval[256];           /* The symbols, in order of incr code length */\n  /* This field is used only during compression.  It's initialized FALSE when\n   * the table is created, and set TRUE when it's been output to the file.\n   * You could suppress output of a table by setting this to TRUE.\n   * (See jpeg_suppress_tables for an example.)\n   */\n  boolean sent_table;           /* TRUE when table has been output */\n} JHUFF_TBL;\n\n\n/* Basic info about one component (color channel). */\n\ntypedef struct {\n  /* These values are fixed over the whole image. */\n  /* For compression, they must be supplied by parameter setup; */\n  /* for decompression, they are read from the SOF marker. */\n  int component_id;             /* identifier for this component (0..255) */\n  int component_index;          /* its index in SOF or cinfo->comp_info[] */\n  int h_samp_factor;            /* horizontal sampling factor (1..4) */\n  int v_samp_factor;            /* vertical sampling factor (1..4) */\n  int quant_tbl_no;             /* quantization table selector (0..3) */\n  /* These values may vary between scans. */\n  /* For compression, they must be supplied by parameter setup; */\n  /* for decompression, they are read from the SOS marker. */\n  /* The decompressor output side may not use these variables. */\n  int dc_tbl_no;                /* DC entropy table selector (0..3) */\n  int ac_tbl_no;                /* AC entropy table selector (0..3) */\n\n  /* Remaining fields should be treated as private by applications. */\n\n  /* These values are computed during compression or decompression startup: */\n  /* Component's size in data units.\n   * In lossy mode, any dummy blocks added to complete an MCU are not counted;\n   * therefore these values do not depend on whether a scan is interleaved or\n   * not.  In lossless mode, these are always equal to the image width and\n   * height.\n   */\n  JDIMENSION width_in_blocks;\n  JDIMENSION height_in_blocks;\n  /* Size of a data unit in samples.  Always DCTSIZE for lossy compression.\n   * For lossy decompression this is the size of the output from one DCT block,\n   * reflecting any scaling we choose to apply during the IDCT step.\n   * Values from 1 to 16 are supported.  Note that different components may\n   * receive different IDCT scalings.  In lossless mode, this is always equal\n   * to 1.\n   */\n#if JPEG_LIB_VERSION >= 70\n  int DCT_h_scaled_size;\n  int DCT_v_scaled_size;\n#else\n  int DCT_scaled_size;\n#endif\n  /* The downsampled dimensions are the component's actual, unpadded number\n   * of samples at the main buffer (preprocessing/compression interface), thus\n   * downsampled_width = ceil(image_width * Hi/Hmax)\n   * and similarly for height.  For lossy decompression, IDCT scaling is\n   * included, so\n   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_[h_]scaled_size/DCTSIZE)\n   * In lossless mode, these are always equal to the image width and height.\n   */\n  JDIMENSION downsampled_width;  /* actual width in samples */\n  JDIMENSION downsampled_height; /* actual height in samples */\n  /* This flag is used only for decompression.  In cases where some of the\n   * components will be ignored (eg grayscale output from YCbCr image),\n   * we can skip most computations for the unused components.\n   */\n  boolean component_needed;     /* do we need the value of this component? */\n\n  /* These values are computed before starting a scan of the component. */\n  /* The decompressor output side may not use these variables. */\n  int MCU_width;                /* number of data units per MCU, horizontally */\n  int MCU_height;               /* number of data units per MCU, vertically */\n  int MCU_blocks;               /* MCU_width * MCU_height */\n  int MCU_sample_width;         /* MCU width in samples, MCU_width*DCT_[h_]scaled_size */\n  int last_col_width;           /* # of non-dummy data units across in last MCU */\n  int last_row_height;          /* # of non-dummy data units down in last MCU */\n\n  /* Saved quantization table for component; NULL if none yet saved.\n   * See jdinput.c comments about the need for this information.\n   * This field is currently used only for decompression.\n   */\n  JQUANT_TBL *quant_table;\n\n  /* Private per-component storage for DCT or IDCT subsystem. */\n  void *dct_table;\n} jpeg_component_info;\n\n\n/* The script for encoding a multiple-scan file is an array of these: */\n\ntypedef struct {\n  int comps_in_scan;            /* number of components encoded in this scan */\n  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */\n  int Ss, Se;                   /* progressive JPEG spectral selection parms\n                                   (Ss is the predictor selection value in\n                                   lossless mode) */\n  int Ah, Al;                   /* progressive JPEG successive approx. parms\n                                   (Al is the point transform value in lossless\n                                   mode) */\n} jpeg_scan_info;\n\n/* The decompressor can save APPn and COM markers in a list of these: */\n\ntypedef struct jpeg_marker_struct *jpeg_saved_marker_ptr;\n\nstruct jpeg_marker_struct {\n  jpeg_saved_marker_ptr next;   /* next in list, or NULL */\n  UINT8 marker;                 /* marker code: JPEG_COM, or JPEG_APP0+n */\n  unsigned int original_length; /* # bytes of data in the file */\n  unsigned int data_length;     /* # bytes of data saved at data[] */\n  JOCTET *data;                 /* the data contained in the marker */\n  /* the marker length word is not counted in data_length or original_length */\n};\n\n/* Known color spaces. */\n\n#define JCS_EXTENSIONS  1\n#define JCS_ALPHA_EXTENSIONS  1\n\ntypedef enum {\n  JCS_UNKNOWN,            /* error/unspecified */\n  JCS_GRAYSCALE,          /* monochrome */\n  JCS_RGB,                /* red/green/blue as specified by the RGB_RED,\n                             RGB_GREEN, RGB_BLUE, and RGB_PIXELSIZE macros */\n  JCS_YCbCr,              /* Y/Cb/Cr (also known as YUV) */\n  JCS_CMYK,               /* C/M/Y/K */\n  JCS_YCCK,               /* Y/Cb/Cr/K */\n  JCS_EXT_RGB,            /* red/green/blue */\n  JCS_EXT_RGBX,           /* red/green/blue/x */\n  JCS_EXT_BGR,            /* blue/green/red */\n  JCS_EXT_BGRX,           /* blue/green/red/x */\n  JCS_EXT_XBGR,           /* x/blue/green/red */\n  JCS_EXT_XRGB,           /* x/red/green/blue */\n  /* When out_color_space it set to JCS_EXT_RGBX, JCS_EXT_BGRX, JCS_EXT_XBGR,\n     or JCS_EXT_XRGB during decompression, the X byte is undefined, and in\n     order to ensure the best performance, libjpeg-turbo can set that byte to\n     whatever value it wishes.  Use the following colorspace constants to\n     ensure that the X byte is set to 0xFF, so that it can be interpreted as an\n     opaque alpha channel. */\n  JCS_EXT_RGBA,           /* red/green/blue/alpha */\n  JCS_EXT_BGRA,           /* blue/green/red/alpha */\n  JCS_EXT_ABGR,           /* alpha/blue/green/red */\n  JCS_EXT_ARGB,           /* alpha/red/green/blue */\n  JCS_RGB565              /* 5-bit red/6-bit green/5-bit blue\n                             [decompression only] */\n} J_COLOR_SPACE;\n\n/* DCT/IDCT algorithm options. */\n\ntypedef enum {\n  JDCT_ISLOW,             /* accurate integer method */\n  JDCT_IFAST,             /* less accurate integer method [legacy feature] */\n  JDCT_FLOAT              /* floating-point method [legacy feature] */\n} J_DCT_METHOD;\n\n#ifndef JDCT_DEFAULT            /* may be overridden in jconfig.h */\n#define JDCT_DEFAULT  JDCT_ISLOW\n#endif\n#ifndef JDCT_FASTEST            /* may be overridden in jconfig.h */\n#define JDCT_FASTEST  JDCT_IFAST\n#endif\n\n/* Dithering options for decompression. */\n\ntypedef enum {\n  JDITHER_NONE,           /* no dithering */\n  JDITHER_ORDERED,        /* simple ordered dither */\n  JDITHER_FS              /* Floyd-Steinberg error diffusion dither */\n} J_DITHER_MODE;\n\n\n/* These 32-bit GUIDs and the corresponding jpeg_*_get_*_param()/\n * jpeg_*_set_*_param() functions allow for extending the libjpeg API without\n * breaking backward ABI compatibility.  The actual parameters are stored in\n * the opaque jpeg_comp_master and jpeg_decomp_master structs.\n */\n\n/* Boolean extension parameters */\n\ntypedef enum {\n  JBOOLEAN_OPTIMIZE_SCANS = 0x680C061E, /* TRUE=optimize progressive coding scans */\n  JBOOLEAN_TRELLIS_QUANT = 0xC5122033, /* TRUE=use trellis quantization */\n  JBOOLEAN_TRELLIS_QUANT_DC = 0x339D4C0C, /* TRUE=use trellis quant for DC coefficient */\n  JBOOLEAN_TRELLIS_EOB_OPT = 0xD7F73780, /* TRUE=optimize for sequences of EOB */\n  JBOOLEAN_USE_LAMBDA_WEIGHT_TBL = 0x339DB65F, /* TRUE=use lambda weighting table */\n  JBOOLEAN_USE_SCANS_IN_TRELLIS = 0xFD841435, /* TRUE=use scans in trellis optimization */\n  JBOOLEAN_TRELLIS_Q_OPT = 0xE12AE269, /* TRUE=optimize quant table in trellis loop */\n  JBOOLEAN_OVERSHOOT_DERINGING = 0x3F4BBBF9 /* TRUE=preprocess input to reduce ringing of edges on white background */\n} J_BOOLEAN_PARAM;\n\n/* Floating point parameters */\n\ntypedef enum {\n  JFLOAT_LAMBDA_LOG_SCALE1 = 0x5B61A599,\n  JFLOAT_LAMBDA_LOG_SCALE2 = 0xB9BBAE03,\n  JFLOAT_TRELLIS_DELTA_DC_WEIGHT = 0x13775453\n} J_FLOAT_PARAM;\n\n/* Integer parameters */\n\ntypedef enum {\n  JINT_COMPRESS_PROFILE = 0xE9918625, /* compression profile */\n  JINT_TRELLIS_FREQ_SPLIT = 0x6FAFF127, /* splitting point for frequency in trellis quantization */\n  JINT_TRELLIS_NUM_LOOPS = 0xB63EBF39, /* number of trellis loops */\n  JINT_BASE_QUANT_TBL_IDX = 0x44492AB1, /* base quantization table index */\n  JINT_DC_SCAN_OPT_MODE = 0x0BE7AD3C /* DC scan optimization mode */\n} J_INT_PARAM;\n\n\n/* Values for the JINT_COMPRESS_PROFILE parameter (32-bit GUIDs) */\n\nenum {\n  JCP_MAX_COMPRESSION = 0x5D083AAD, /* best compression ratio (progressive, all mozjpeg extensions) */\n  JCP_FASTEST = 0x2AEA5CB4 /* libjpeg[-turbo] defaults (baseline, no mozjpeg extensions) */\n};\n\n\n/* Common fields between JPEG compression and decompression master structs. */\n\n#define jpeg_common_fields \\\n  struct jpeg_error_mgr *err;   /* Error handler module */ \\\n  struct jpeg_memory_mgr *mem;  /* Memory manager module */ \\\n  struct jpeg_progress_mgr *progress; /* Progress monitor, or NULL if none */ \\\n  void *client_data;            /* Available for use by application */ \\\n  boolean is_decompressor;      /* So common code can tell which is which */ \\\n  int global_state              /* For checking call sequence validity */\n\n/* Routines that are to be used by both halves of the library are declared\n * to receive a pointer to this structure.  There are no actual instances of\n * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.\n */\nstruct jpeg_common_struct {\n  jpeg_common_fields;           /* Fields common to both master struct types */\n  /* Additional fields follow in an actual jpeg_compress_struct or\n   * jpeg_decompress_struct.  All three structs must agree on these\n   * initial fields!  (This would be a lot cleaner in C++.)\n   */\n};\n\ntypedef struct jpeg_common_struct *j_common_ptr;\ntypedef struct jpeg_compress_struct *j_compress_ptr;\ntypedef struct jpeg_decompress_struct *j_decompress_ptr;\n\n\n/* Master record for a compression instance */\n\nstruct jpeg_compress_struct {\n  jpeg_common_fields;           /* Fields shared with jpeg_decompress_struct */\n\n  /* Destination for compressed data */\n  struct jpeg_destination_mgr *dest;\n\n  /* Description of source image --- these fields must be filled in by\n   * outer application before starting compression.  in_color_space must\n   * be correct before you can even call jpeg_set_defaults().\n   */\n\n  JDIMENSION image_width;       /* input image width */\n  JDIMENSION image_height;      /* input image height */\n  int input_components;         /* # of color components in input image */\n  J_COLOR_SPACE in_color_space; /* colorspace of input image */\n\n  double input_gamma;           /* image gamma of input image */\n\n  /* Compression parameters --- these fields must be set before calling\n   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to\n   * initialize everything to reasonable defaults, then changing anything\n   * the application specifically wants to change.  That way you won't get\n   * burnt when new parameters are added.  Also note that there are several\n   * helper routines to simplify changing parameters.\n   */\n\n#if JPEG_LIB_VERSION >= 70\n  unsigned int scale_num, scale_denom; /* fraction by which to scale image */\n\n  JDIMENSION jpeg_width;        /* scaled JPEG image width */\n  JDIMENSION jpeg_height;       /* scaled JPEG image height */\n  /* Dimensions of actual JPEG image that will be written to file,\n   * derived from input dimensions by scaling factors above.\n   * These fields are computed by jpeg_start_compress().\n   * You can also use jpeg_calc_jpeg_dimensions() to determine these values\n   * in advance of calling jpeg_start_compress().\n   */\n#endif\n\n  int data_precision;           /* bits of precision in image data */\n\n  int num_components;           /* # of color components in JPEG image */\n  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */\n\n  jpeg_component_info *comp_info;\n  /* comp_info[i] describes component that appears i'th in SOF */\n\n  JQUANT_TBL *quant_tbl_ptrs[NUM_QUANT_TBLS];\n#if JPEG_LIB_VERSION >= 70\n  int q_scale_factor[NUM_QUANT_TBLS];\n#endif\n  /* ptrs to coefficient quantization tables, or NULL if not defined,\n   * and corresponding scale factors (percentage, initialized 100).\n   */\n\n  JHUFF_TBL *dc_huff_tbl_ptrs[NUM_HUFF_TBLS];\n  JHUFF_TBL *ac_huff_tbl_ptrs[NUM_HUFF_TBLS];\n  /* ptrs to Huffman coding tables, or NULL if not defined */\n\n  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */\n  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */\n  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */\n\n  int num_scans;                /* # of entries in scan_info array */\n  const jpeg_scan_info *scan_info; /* script for multi-scan file, or NULL */\n  /* The default value of scan_info is NULL, which causes a single-scan\n   * sequential JPEG file to be emitted.  To create a multi-scan file,\n   * set num_scans and scan_info to point to an array of scan definitions.\n   */\n\n  boolean raw_data_in;          /* TRUE=caller supplies downsampled data */\n  boolean arith_code;           /* TRUE=arithmetic coding, FALSE=Huffman */\n  boolean optimize_coding;      /* TRUE=optimize entropy encoding parms */\n  boolean CCIR601_sampling;     /* TRUE=first samples are cosited */\n#if JPEG_LIB_VERSION >= 70\n  boolean do_fancy_downsampling; /* TRUE=apply fancy downsampling */\n#endif\n  int smoothing_factor;         /* 1..100, or 0 for no input smoothing */\n  J_DCT_METHOD dct_method;      /* DCT algorithm selector */\n\n  /* The restart interval can be specified in absolute MCUs by setting\n   * restart_interval, or in MCU rows by setting restart_in_rows\n   * (in which case the correct restart_interval will be figured\n   * for each scan).\n   */\n  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */\n  int restart_in_rows;          /* if > 0, MCU rows per restart interval */\n\n  /* Parameters controlling emission of special markers. */\n\n  boolean write_JFIF_header;    /* should a JFIF marker be written? */\n  UINT8 JFIF_major_version;     /* What to write for the JFIF version number */\n  UINT8 JFIF_minor_version;\n  /* These three values are not used by the JPEG code, merely copied */\n  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */\n  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */\n  /* ratio is defined by X_density/Y_density even when density_unit=0. */\n  UINT8 density_unit;           /* JFIF code for pixel size units */\n  UINT16 X_density;             /* Horizontal pixel density */\n  UINT16 Y_density;             /* Vertical pixel density */\n  boolean write_Adobe_marker;   /* should an Adobe marker be written? */\n\n  /* State variable: index of next scanline to be written to\n   * jpeg_write_scanlines().  Application may use this to control its\n   * processing loop, e.g., \"while (next_scanline < image_height)\".\n   */\n\n  JDIMENSION next_scanline;     /* 0 .. image_height-1  */\n\n  /* Remaining fields are known throughout compressor, but generally\n   * should not be touched by a surrounding application.\n   */\n\n  /*\n   * These fields are computed during compression startup\n   */\n  boolean progressive_mode;     /* TRUE if scan script uses progressive mode */\n  int max_h_samp_factor;        /* largest h_samp_factor */\n  int max_v_samp_factor;        /* largest v_samp_factor */\n\n#if JPEG_LIB_VERSION >= 70\n  int min_DCT_h_scaled_size;    /* smallest DCT_h_scaled_size of any component */\n  int min_DCT_v_scaled_size;    /* smallest DCT_v_scaled_size of any component */\n#endif\n\n  JDIMENSION total_iMCU_rows;   /* # of iMCU rows to be input to coefficient or\n                                   difference controller */\n  /* The coefficient or difference controller receives data in units of MCU\n   * rows as defined for fully interleaved scans (whether the JPEG file is\n   * interleaved or not).  In lossy mode, there are v_samp_factor * DCTSIZE\n   * sample rows of each component in an \"iMCU\" (interleaved MCU) row.  In\n   * lossless mode, total_iMCU_rows is always equal to the image height.\n   */\n\n  /*\n   * These fields are valid during any one scan.\n   * They describe the components and MCUs actually appearing in the scan.\n   */\n  int comps_in_scan;            /* # of JPEG components in this scan */\n  jpeg_component_info *cur_comp_info[MAX_COMPS_IN_SCAN];\n  /* *cur_comp_info[i] describes component that appears i'th in SOS */\n\n  JDIMENSION MCUs_per_row;      /* # of MCUs across the image */\n  JDIMENSION MCU_rows_in_scan;  /* # of MCU rows in the image */\n\n  int blocks_in_MCU;            /* # of data units per MCU */\n  int MCU_membership[C_MAX_BLOCKS_IN_MCU];\n  /* MCU_membership[i] is index in cur_comp_info of component owning */\n  /* i'th data unit in an MCU */\n\n  int Ss, Se, Ah, Al;           /* progressive/lossless JPEG parameters for\n                                   scan */\n\n#if JPEG_LIB_VERSION >= 80\n  int block_size;               /* the basic DCT block size: 1..16 */\n  const int *natural_order;     /* natural-order position array */\n  int lim_Se;                   /* min( Se, DCTSIZE2-1 ) */\n#endif\n\n  /*\n   * Links to compression subobjects (methods and private variables of modules)\n   */\n  struct jpeg_comp_master *master;\n  struct jpeg_c_main_controller *main;\n  struct jpeg_c_prep_controller *prep;\n  struct jpeg_c_coef_controller *coef;\n  struct jpeg_marker_writer *marker;\n  struct jpeg_color_converter *cconvert;\n  struct jpeg_downsampler *downsample;\n  struct jpeg_forward_dct *fdct;\n  struct jpeg_entropy_encoder *entropy;\n  jpeg_scan_info *script_space; /* workspace for jpeg_simple_progression */\n  int script_space_size;\n};\n\ntypedef void (*jpeg_idct_method) (j_decompress_ptr cinfo, jpeg_component_info *compptr, JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col);\ntypedef void (*jpeg_idct_method_selector) (j_decompress_ptr cinfo, jpeg_component_info *compptr, jpeg_idct_method * set_idct_method, int * set_idct_category);\n\n/* Master record for a decompression instance */\n\nstruct jpeg_decompress_struct {\n  jpeg_common_fields;           /* Fields shared with jpeg_compress_struct */\n\n  /* Source of compressed data */\n  struct jpeg_source_mgr *src;\n\n  /* Basic description of image --- filled in by jpeg_read_header(). */\n  /* Application may inspect these values to decide how to process image. */\n\n  JDIMENSION image_width;       /* nominal image width (from SOF marker) */\n  JDIMENSION image_height;      /* nominal image height */\n  int num_components;           /* # of color components in JPEG image */\n  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */\n\n  /* Decompression processing parameters --- these fields must be set before\n   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes\n   * them to default values.\n   */\n\n  J_COLOR_SPACE out_color_space; /* colorspace for output */\n\n  unsigned int scale_num, scale_denom; /* fraction by which to scale image */\n\n  double output_gamma;          /* image gamma wanted in output */\n\n  boolean buffered_image;       /* TRUE=multiple output passes */\n  boolean raw_data_out;         /* TRUE=downsampled data wanted */\n\n  J_DCT_METHOD dct_method;      /* IDCT algorithm selector */\n  boolean do_fancy_upsampling;  /* TRUE=apply fancy upsampling */\n  boolean do_block_smoothing;   /* TRUE=apply interblock smoothing */\n\n  boolean quantize_colors;      /* TRUE=colormapped output wanted */\n  /* the following are ignored if not quantize_colors: */\n  J_DITHER_MODE dither_mode;    /* type of color dithering to use */\n  boolean two_pass_quantize;    /* TRUE=use two-pass color quantization */\n  int desired_number_of_colors; /* max # colors to use in created colormap */\n  /* these are significant only in buffered-image mode: */\n  boolean enable_1pass_quant;   /* enable future use of 1-pass quantizer */\n  boolean enable_external_quant;/* enable future use of external colormap */\n  boolean enable_2pass_quant;   /* enable future use of 2-pass quantizer */\n\n  /* Description of actual output image that will be returned to application.\n   * These fields are computed by jpeg_start_decompress().\n   * You can also use jpeg_calc_output_dimensions() to determine these values\n   * in advance of calling jpeg_start_decompress().\n   */\n\n  JDIMENSION output_width;      /* scaled image width */\n  JDIMENSION output_height;     /* scaled image height */\n  int out_color_components;     /* # of color components in out_color_space */\n  int output_components;        /* # of color components returned */\n  /* output_components is 1 (a colormap index) when quantizing colors;\n   * otherwise it equals out_color_components.\n   */\n  int rec_outbuf_height;        /* min recommended height of scanline buffer */\n  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows\n   * high, space and time will be wasted due to unnecessary data copying.\n   * Usually rec_outbuf_height will be 1 or 2, at most 4.\n   */\n\n  /* When quantizing colors, the output colormap is described by these fields.\n   * The application can supply a colormap by setting colormap non-NULL before\n   * calling jpeg_start_decompress; otherwise a colormap is created during\n   * jpeg_start_decompress or jpeg_start_output.\n   * The map has out_color_components rows and actual_number_of_colors columns.\n   */\n  int actual_number_of_colors;  /* number of entries in use */\n  JSAMPARRAY colormap;          /* The color map as a 2-D pixel array\n                                   If data_precision is 12, then this is\n                                   actually a J12SAMPARRAY, so callers must\n                                   type-cast it in order to read/write 12-bit\n                                   samples from/to the array. */\n\n  /* State variables: these variables indicate the progress of decompression.\n   * The application may examine these but must not modify them.\n   */\n\n  /* Row index of next scanline to be read from jpeg_read_scanlines().\n   * Application may use this to control its processing loop, e.g.,\n   * \"while (output_scanline < output_height)\".\n   */\n  JDIMENSION output_scanline;   /* 0 .. output_height-1  */\n\n  /* Current input scan number and number of iMCU rows completed in scan.\n   * These indicate the progress of the decompressor input side.\n   */\n  int input_scan_number;        /* Number of SOS markers seen so far */\n  JDIMENSION input_iMCU_row;    /* Number of iMCU rows completed */\n\n  /* The \"output scan number\" is the notional scan being displayed by the\n   * output side.  The decompressor will not allow output scan/row number\n   * to get ahead of input scan/row, but it can fall arbitrarily far behind.\n   */\n  int output_scan_number;       /* Nominal scan number being displayed */\n  JDIMENSION output_iMCU_row;   /* Number of iMCU rows read */\n\n  /* Current progression status.  coef_bits[c][i] indicates the precision\n   * with which component c's DCT coefficient i (in zigzag order) is known.\n   * It is -1 when no data has yet been received, otherwise it is the point\n   * transform (shift) value for the most recent scan of the coefficient\n   * (thus, 0 at completion of the progression).\n   * This pointer is NULL when reading a non-progressive file.\n   */\n  int (*coef_bits)[DCTSIZE2];   /* -1 or current Al value for each coef */\n\n  /* Internal JPEG parameters --- the application usually need not look at\n   * these fields.  Note that the decompressor output side may not use\n   * any parameters that can change between scans.\n   */\n\n  /* Quantization and Huffman tables are carried forward across input\n   * datastreams when processing abbreviated JPEG datastreams.\n   */\n\n  JQUANT_TBL *quant_tbl_ptrs[NUM_QUANT_TBLS];\n  /* ptrs to coefficient quantization tables, or NULL if not defined */\n\n  JHUFF_TBL *dc_huff_tbl_ptrs[NUM_HUFF_TBLS];\n  JHUFF_TBL *ac_huff_tbl_ptrs[NUM_HUFF_TBLS];\n  /* ptrs to Huffman coding tables, or NULL if not defined */\n\n  /* These parameters are never carried across datastreams, since they\n   * are given in SOF/SOS markers or defined to be reset by SOI.\n   */\n\n  int data_precision;           /* bits of precision in image data */\n\n  jpeg_component_info *comp_info;\n  /* comp_info[i] describes component that appears i'th in SOF */\n\n#if JPEG_LIB_VERSION >= 80\n  boolean is_baseline;          /* TRUE if Baseline SOF0 encountered */\n#endif\n  boolean progressive_mode;     /* TRUE if SOFn specifies progressive mode */\n  boolean arith_code;           /* TRUE=arithmetic coding, FALSE=Huffman */\n\n  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */\n  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */\n  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */\n\n  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */\n\n  /* These fields record data obtained from optional markers recognized by\n   * the JPEG library.\n   */\n  boolean saw_JFIF_marker;      /* TRUE iff a JFIF APP0 marker was found */\n  /* Data copied from JFIF marker; only valid if saw_JFIF_marker is TRUE: */\n  UINT8 JFIF_major_version;     /* JFIF version number */\n  UINT8 JFIF_minor_version;\n  UINT8 density_unit;           /* JFIF code for pixel size units */\n  UINT16 X_density;             /* Horizontal pixel density */\n  UINT16 Y_density;             /* Vertical pixel density */\n  boolean saw_Adobe_marker;     /* TRUE iff an Adobe APP14 marker was found */\n  UINT8 Adobe_transform;        /* Color transform code from Adobe marker */\n\n  boolean CCIR601_sampling;     /* TRUE=first samples are cosited */\n\n  /* Aside from the specific data retained from APPn markers known to the\n   * library, the uninterpreted contents of any or all APPn and COM markers\n   * can be saved in a list for examination by the application.\n   */\n  jpeg_saved_marker_ptr marker_list; /* Head of list of saved markers */\n\n  /* Remaining fields are known throughout decompressor, but generally\n   * should not be touched by a surrounding application.\n   */\n\n  /*\n   * These fields are computed during decompression startup\n   */\n  int max_h_samp_factor;        /* largest h_samp_factor */\n  int max_v_samp_factor;        /* largest v_samp_factor */\n\n#if JPEG_LIB_VERSION >= 70\n  int min_DCT_h_scaled_size;    /* smallest DCT_h_scaled_size of any component */\n  int min_DCT_v_scaled_size;    /* smallest DCT_v_scaled_size of any component */\n#else\n  int min_DCT_scaled_size;      /* smallest DCT_scaled_size of any component */\n#endif\n\n  JDIMENSION total_iMCU_rows;   /* # of iMCU rows in image */\n  /* The coefficient or difference controller's input and output progress is\n   * measured in units of \"iMCU\" (interleaved MCU) rows.  These are the same as\n   * MCU rows in fully interleaved JPEG scans, but are used whether the scan is\n   * interleaved or not.  In lossy mode, we define an iMCU row as v_samp_factor\n   * DCT block rows of each component.  Therefore, the IDCT output contains\n   * v_samp_factor*DCT_[v_]scaled_size sample rows of a component per iMCU row.\n   * In lossless mode, total_iMCU_rows is always equal to the image height.\n   */\n\n  JSAMPLE *sample_range_limit;  /* table for fast range-limiting\n                                   If data_precision is 12 or 16, then this is\n                                   actually a J12SAMPLE pointer or a J16SAMPLE\n                                   pointer, so callers must type-cast it in\n                                   order to read 12-bit or 16-bit samples from\n                                   the array. */\n\n  /*\n   * These fields are valid during any one scan.\n   * They describe the components and MCUs actually appearing in the scan.\n   * Note that the decompressor output side must not use these fields.\n   */\n  int comps_in_scan;            /* # of JPEG components in this scan */\n  jpeg_component_info *cur_comp_info[MAX_COMPS_IN_SCAN];\n  /* *cur_comp_info[i] describes component that appears i'th in SOS */\n\n  JDIMENSION MCUs_per_row;      /* # of MCUs across the image */\n  JDIMENSION MCU_rows_in_scan;  /* # of MCU rows in the image */\n\n  int blocks_in_MCU;            /* # of data units per MCU */\n  int MCU_membership[D_MAX_BLOCKS_IN_MCU];\n  /* MCU_membership[i] is index in cur_comp_info of component owning */\n  /* i'th data unit in an MCU */\n\n  int Ss, Se, Ah, Al;           /* progressive/lossless JPEG parameters for\n                                   scan */\n\n#if JPEG_LIB_VERSION >= 80\n  /* These fields are derived from Se of first SOS marker.\n   */\n  int block_size;               /* the basic DCT block size: 1..16 */\n  const int *natural_order; /* natural-order position array for entropy decode */\n  int lim_Se;                   /* min( Se, DCTSIZE2-1 ) for entropy decode */\n#endif\n\n  /* This field is shared between entropy decoder and marker parser.\n   * It is either zero or the code of a JPEG marker that has been\n   * read from the data source, but has not yet been processed.\n   */\n  int unread_marker;\n\n  /*\n   * Links to decompression subobjects (methods, private variables of modules)\n   */\n  struct jpeg_decomp_master *master;\n  struct jpeg_d_main_controller *main;\n  struct jpeg_d_coef_controller *coef;\n  struct jpeg_d_post_controller *post;\n  struct jpeg_input_controller *inputctl;\n  struct jpeg_marker_reader *marker;\n  struct jpeg_entropy_decoder *entropy;\n  struct jpeg_inverse_dct *idct;\n  struct jpeg_upsampler *upsample;\n  struct jpeg_color_deconverter *cconvert;\n  struct jpeg_color_quantizer *cquantize;\n};\n\n\n/* \"Object\" declarations for JPEG modules that may be supplied or called\n * directly by the surrounding application.\n * As with all objects in the JPEG library, these structs only define the\n * publicly visible methods and state variables of a module.  Additional\n * private fields may exist after the public ones.\n */\n\n\n/* Error handler object */\n\nstruct jpeg_error_mgr {\n  /* Error exit handler: does not return to caller */\n  void (*error_exit) (j_common_ptr cinfo);\n  /* Conditionally emit a trace or warning message */\n  void (*emit_message) (j_common_ptr cinfo, int msg_level);\n  /* Routine that actually outputs a trace or error message */\n  void (*output_message) (j_common_ptr cinfo);\n  /* Format a message string for the most recent JPEG error or message */\n  void (*format_message) (j_common_ptr cinfo, char *buffer);\n#define JMSG_LENGTH_MAX  200    /* recommended size of format_message buffer */\n  /* Reset error state variables at start of a new image */\n  void (*reset_error_mgr) (j_common_ptr cinfo);\n\n  /* The message ID code and any parameters are saved here.\n   * A message can have one string parameter or up to 8 int parameters.\n   */\n  int msg_code;\n#define JMSG_STR_PARM_MAX  80\n  union {\n    int i[8];\n    char s[JMSG_STR_PARM_MAX];\n  } msg_parm;\n\n  /* Standard state variables for error facility */\n\n  int trace_level;              /* max msg_level that will be displayed */\n\n  /* For recoverable corrupt-data errors, we emit a warning message,\n   * but keep going unless emit_message chooses to abort.  emit_message\n   * should count warnings in num_warnings.  The surrounding application\n   * can check for bad data by seeing if num_warnings is nonzero at the\n   * end of processing.\n   */\n  long num_warnings;            /* number of corrupt-data warnings */\n\n  /* These fields point to the table(s) of error message strings.\n   * An application can change the table pointer to switch to a different\n   * message list (typically, to change the language in which errors are\n   * reported).  Some applications may wish to add additional error codes\n   * that will be handled by the JPEG library error mechanism; the second\n   * table pointer is used for this purpose.\n   *\n   * First table includes all errors generated by JPEG library itself.\n   * Error code 0 is reserved for a \"no such error string\" message.\n   */\n  const char * const *jpeg_message_table; /* Library errors */\n  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */\n  /* Second table can be added by application (see cjpeg/djpeg for example).\n   * It contains strings numbered first_addon_message..last_addon_message.\n   */\n  const char * const *addon_message_table; /* Non-library errors */\n  int first_addon_message;      /* code for first string in addon table */\n  int last_addon_message;       /* code for last string in addon table */\n};\n\n\n/* Progress monitor object */\n\nstruct jpeg_progress_mgr {\n  void (*progress_monitor) (j_common_ptr cinfo);\n\n  long pass_counter;            /* work units completed in this pass */\n  long pass_limit;              /* total number of work units in this pass */\n  int completed_passes;         /* passes completed so far */\n  int total_passes;             /* total number of passes expected */\n};\n\n\n/* Data destination object for compression */\n\nstruct jpeg_destination_mgr {\n  JOCTET *next_output_byte;     /* => next byte to write in buffer */\n  size_t free_in_buffer;        /* # of byte spaces remaining in buffer */\n\n  void (*init_destination) (j_compress_ptr cinfo);\n  boolean (*empty_output_buffer) (j_compress_ptr cinfo);\n  void (*term_destination) (j_compress_ptr cinfo);\n};\n\n\n/* Data source object for decompression */\n\nstruct jpeg_source_mgr {\n  const JOCTET *next_input_byte; /* => next byte to read from buffer */\n  size_t bytes_in_buffer;       /* # of bytes remaining in buffer */\n\n  void (*init_source) (j_decompress_ptr cinfo);\n  boolean (*fill_input_buffer) (j_decompress_ptr cinfo);\n  void (*skip_input_data) (j_decompress_ptr cinfo, long num_bytes);\n  boolean (*resync_to_restart) (j_decompress_ptr cinfo, int desired);\n  void (*term_source) (j_decompress_ptr cinfo);\n};\n\n\n/* Memory manager object.\n * Allocates \"small\" objects (a few K total), \"large\" objects (tens of K),\n * and \"really big\" objects (virtual arrays with backing store if needed).\n * The memory manager does not allow individual objects to be freed; rather,\n * each created object is assigned to a pool, and whole pools can be freed\n * at once.  This is faster and more convenient than remembering exactly what\n * to free, especially where malloc()/free() are not too speedy.\n * NB: alloc routines never return NULL.  They exit to error_exit if not\n * successful.\n */\n\n#define JPOOL_PERMANENT  0      /* lasts until master record is destroyed */\n#define JPOOL_IMAGE      1      /* lasts until done with image/datastream */\n#define JPOOL_NUMPOOLS   2\n\ntypedef struct jvirt_sarray_control *jvirt_sarray_ptr;\ntypedef struct jvirt_barray_control *jvirt_barray_ptr;\n\n\nstruct jpeg_memory_mgr {\n  /* Method pointers */\n  void *(*alloc_small) (j_common_ptr cinfo, int pool_id, size_t sizeofobject);\n  void *(*alloc_large) (j_common_ptr cinfo, int pool_id,\n                        size_t sizeofobject);\n  /* If cinfo->data_precision is 12 or 16, then this method and the\n   * access_virt_sarray method actually return a J12SAMPARRAY or a\n   * J16SAMPARRAY, so callers must type-cast the return value in order to\n   * read/write 12-bit or 16-bit samples from/to the array.\n   */\n  JSAMPARRAY (*alloc_sarray) (j_common_ptr cinfo, int pool_id,\n                              JDIMENSION samplesperrow, JDIMENSION numrows);\n  JBLOCKARRAY (*alloc_barray) (j_common_ptr cinfo, int pool_id,\n                               JDIMENSION blocksperrow, JDIMENSION numrows);\n  jvirt_sarray_ptr (*request_virt_sarray) (j_common_ptr cinfo, int pool_id,\n                                           boolean pre_zero,\n                                           JDIMENSION samplesperrow,\n                                           JDIMENSION numrows,\n                                           JDIMENSION maxaccess);\n  jvirt_barray_ptr (*request_virt_barray) (j_common_ptr cinfo, int pool_id,\n                                           boolean pre_zero,\n                                           JDIMENSION blocksperrow,\n                                           JDIMENSION numrows,\n                                           JDIMENSION maxaccess);\n  void (*realize_virt_arrays) (j_common_ptr cinfo);\n  JSAMPARRAY (*access_virt_sarray) (j_common_ptr cinfo, jvirt_sarray_ptr ptr,\n                                    JDIMENSION start_row, JDIMENSION num_rows,\n                                    boolean writable);\n  JBLOCKARRAY (*access_virt_barray) (j_common_ptr cinfo, jvirt_barray_ptr ptr,\n                                     JDIMENSION start_row, JDIMENSION num_rows,\n                                     boolean writable);\n  void (*free_pool) (j_common_ptr cinfo, int pool_id);\n  void (*self_destruct) (j_common_ptr cinfo);\n\n  /* Limit on memory allocation for this JPEG object.  (Note that this is\n   * merely advisory, not a guaranteed maximum; it only affects the space\n   * used for virtual-array buffers.)  May be changed by outer application\n   * after creating the JPEG object.\n   */\n  long max_memory_to_use;\n\n  /* Maximum allocation request accepted by alloc_large. */\n  long max_alloc_chunk;\n};\n\n\n/* Routine signature for application-supplied marker processing methods.\n * Need not pass marker code since it is stored in cinfo->unread_marker.\n */\ntypedef boolean (*jpeg_marker_parser_method) (j_decompress_ptr cinfo);\n\n\n/* Originally, this macro was used as a way of defining function prototypes\n * for both modern compilers as well as older compilers that did not support\n * prototype parameters.  libjpeg-turbo has never supported these older,\n * non-ANSI compilers, but the macro is still included because there is some\n * software out there that uses it.\n */\n\n#define JPP(arglist)    arglist\n\n\n/* Default error-management setup */\nEXTERN(struct jpeg_error_mgr *) jpeg_std_error(struct jpeg_error_mgr *err);\n\n/* Initialization of JPEG compression objects.\n * jpeg_create_compress() and jpeg_create_decompress() are the exported\n * names that applications should call.  These expand to calls on\n * jpeg_CreateCompress and jpeg_CreateDecompress with additional information\n * passed for version mismatch checking.\n * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.\n */\n#define jpeg_create_compress(cinfo) \\\n  jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \\\n                      (size_t)sizeof(struct jpeg_compress_struct))\n#define jpeg_create_decompress(cinfo) \\\n  jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \\\n                        (size_t)sizeof(struct jpeg_decompress_struct))\nEXTERN(void) jpeg_CreateCompress(j_compress_ptr cinfo, int version,\n                                 size_t structsize);\nEXTERN(void) jpeg_CreateDecompress(j_decompress_ptr cinfo, int version,\n                                   size_t structsize);\n/* Destruction of JPEG compression objects */\nEXTERN(void) jpeg_destroy_compress(j_compress_ptr cinfo);\nEXTERN(void) jpeg_destroy_decompress(j_decompress_ptr cinfo);\n\n/* Standard data source and destination managers: stdio streams. */\n/* Caller is responsible for opening the file before and closing after. */\nEXTERN(void) jpeg_stdio_dest(j_compress_ptr cinfo, FILE *outfile);\nEXTERN(void) jpeg_stdio_src(j_decompress_ptr cinfo, FILE *infile);\n\n/* Data source and destination managers: memory buffers. */\nEXTERN(void) jpeg_mem_dest(j_compress_ptr cinfo, unsigned char **outbuffer,\n                           unsigned long *outsize);\nEXTERN(void) jpeg_mem_src(j_decompress_ptr cinfo,\n                          const unsigned char *inbuffer, unsigned long insize);\n\n/* Default parameter setup for compression */\nEXTERN(void) jpeg_set_defaults(j_compress_ptr cinfo);\n/* Compression parameter setup aids */\nEXTERN(void) jpeg_set_colorspace(j_compress_ptr cinfo,\n                                 J_COLOR_SPACE colorspace);\nEXTERN(void) jpeg_default_colorspace(j_compress_ptr cinfo);\nEXTERN(void) jpeg_set_quality(j_compress_ptr cinfo, int quality,\n                              boolean force_baseline);\nEXTERN(void) jpeg_set_linear_quality(j_compress_ptr cinfo, int scale_factor,\n                                     boolean force_baseline);\n#if JPEG_LIB_VERSION >= 70\nEXTERN(void) jpeg_default_qtables(j_compress_ptr cinfo,\n                                  boolean force_baseline);\n#endif\nEXTERN(void) jpeg_add_quant_table(j_compress_ptr cinfo, int which_tbl,\n                                  const unsigned int *basic_table,\n                                  int scale_factor, boolean force_baseline);\nEXTERN(int) jpeg_quality_scaling(int quality);\nEXTERN(float) jpeg_float_quality_scaling (float quality);\nEXTERN(void) jpeg_enable_lossless(j_compress_ptr cinfo,\n                                  int predictor_selection_value,\n                                  int point_transform);\nEXTERN(void) jpeg_simple_progression(j_compress_ptr cinfo);\nEXTERN(void) jpeg_suppress_tables(j_compress_ptr cinfo, boolean suppress);\nEXTERN(JQUANT_TBL *) jpeg_alloc_quant_table(j_common_ptr cinfo);\nEXTERN(JHUFF_TBL *) jpeg_alloc_huff_table(j_common_ptr cinfo);\n\n/* Main entry points for compression */\nEXTERN(void) jpeg_start_compress(j_compress_ptr cinfo,\n                                 boolean write_all_tables);\nEXTERN(JDIMENSION) jpeg_write_scanlines(j_compress_ptr cinfo,\n                                        JSAMPARRAY scanlines,\n                                        JDIMENSION num_lines);\nEXTERN(JDIMENSION) jpeg12_write_scanlines(j_compress_ptr cinfo,\n                                          J12SAMPARRAY scanlines,\n                                          JDIMENSION num_lines);\nEXTERN(JDIMENSION) jpeg16_write_scanlines(j_compress_ptr cinfo,\n                                          J16SAMPARRAY scanlines,\n                                          JDIMENSION num_lines);\nEXTERN(void) jpeg_finish_compress(j_compress_ptr cinfo);\n\n#if JPEG_LIB_VERSION >= 70\n/* Precalculate JPEG dimensions for current compression parameters. */\nEXTERN(void) jpeg_calc_jpeg_dimensions(j_compress_ptr cinfo);\n#endif\n\n/* Replaces jpeg_write_scanlines when writing raw downsampled data. */\nEXTERN(JDIMENSION) jpeg_write_raw_data(j_compress_ptr cinfo, JSAMPIMAGE data,\n                                       JDIMENSION num_lines);\nEXTERN(JDIMENSION) jpeg12_write_raw_data(j_compress_ptr cinfo,\n                                         J12SAMPIMAGE data,\n                                         JDIMENSION num_lines);\n\n/* Write a special marker.  See libjpeg.txt concerning safe usage. */\nEXTERN(void) jpeg_write_marker(j_compress_ptr cinfo, int marker,\n                               const JOCTET *dataptr, unsigned int datalen);\n/* Same, but piecemeal. */\nEXTERN(void) jpeg_write_m_header(j_compress_ptr cinfo, int marker,\n                                 unsigned int datalen);\nEXTERN(void) jpeg_write_m_byte(j_compress_ptr cinfo, int val);\n\n/* Alternate compression function: just write an abbreviated table file */\nEXTERN(void) jpeg_write_tables(j_compress_ptr cinfo);\n\n/* Write ICC profile.  See libjpeg.txt for usage information. */\nEXTERN(void) jpeg_write_icc_profile(j_compress_ptr cinfo,\n                                    const JOCTET *icc_data_ptr,\n                                    unsigned int icc_data_len);\n\n\n/* Decompression startup: read start of JPEG datastream to see what's there */\nEXTERN(int) jpeg_read_header(j_decompress_ptr cinfo, boolean require_image);\n/* Return value is one of: */\n#define JPEG_SUSPENDED           0 /* Suspended due to lack of input data */\n#define JPEG_HEADER_OK           1 /* Found valid image datastream */\n#define JPEG_HEADER_TABLES_ONLY  2 /* Found valid table-specs-only datastream */\n/* If you pass require_image = TRUE (normal case), you need not check for\n * a TABLES_ONLY return code; an abbreviated file will cause an error exit.\n * JPEG_SUSPENDED is only possible if you use a data source module that can\n * give a suspension return (the stdio source module doesn't).\n */\n\n/* Main entry points for decompression */\nEXTERN(boolean) jpeg_start_decompress(j_decompress_ptr cinfo);\nEXTERN(JDIMENSION) jpeg_read_scanlines(j_decompress_ptr cinfo,\n                                       JSAMPARRAY scanlines,\n                                       JDIMENSION max_lines);\nEXTERN(JDIMENSION) jpeg12_read_scanlines(j_decompress_ptr cinfo,\n                                         J12SAMPARRAY scanlines,\n                                         JDIMENSION max_lines);\nEXTERN(JDIMENSION) jpeg16_read_scanlines(j_decompress_ptr cinfo,\n                                         J16SAMPARRAY scanlines,\n                                         JDIMENSION max_lines);\nEXTERN(JDIMENSION) jpeg_skip_scanlines(j_decompress_ptr cinfo,\n                                       JDIMENSION num_lines);\nEXTERN(JDIMENSION) jpeg12_skip_scanlines(j_decompress_ptr cinfo,\n                                         JDIMENSION num_lines);\nEXTERN(void) jpeg_crop_scanline(j_decompress_ptr cinfo, JDIMENSION *xoffset,\n                                JDIMENSION *width);\nEXTERN(void) jpeg12_crop_scanline(j_decompress_ptr cinfo, JDIMENSION *xoffset,\n                                  JDIMENSION *width);\nEXTERN(boolean) jpeg_finish_decompress(j_decompress_ptr cinfo);\n\n/* Replaces jpeg_read_scanlines when reading raw downsampled data. */\nEXTERN(JDIMENSION) jpeg_read_raw_data(j_decompress_ptr cinfo, JSAMPIMAGE data,\n                                      JDIMENSION max_lines);\nEXTERN(JDIMENSION) jpeg12_read_raw_data(j_decompress_ptr cinfo,\n                                        J12SAMPIMAGE data,\n                                        JDIMENSION max_lines);\n\n/* Additional entry points for buffered-image mode. */\nEXTERN(boolean) jpeg_has_multiple_scans (const j_decompress_ptr cinfo);\nEXTERN(boolean) jpeg_start_output(j_decompress_ptr cinfo, int scan_number);\nEXTERN(boolean) jpeg_finish_output(j_decompress_ptr cinfo);\nEXTERN(boolean) jpeg_input_complete (const j_decompress_ptr cinfo);\nEXTERN(void) jpeg_new_colormap(j_decompress_ptr cinfo);\nEXTERN(int) jpeg_consume_input(j_decompress_ptr cinfo);\n/* Return value is one of: */\n/* #define JPEG_SUSPENDED       0    Suspended due to lack of input data */\n#define JPEG_REACHED_SOS        1 /* Reached start of new scan */\n#define JPEG_REACHED_EOI        2 /* Reached end of image */\n#define JPEG_ROW_COMPLETED      3 /* Completed one iMCU row */\n#define JPEG_SCAN_COMPLETED     4 /* Completed last iMCU row of a scan */\n\n/* Precalculate output dimensions for current decompression parameters. */\n#if JPEG_LIB_VERSION >= 80\nEXTERN(void) jpeg_core_output_dimensions(j_decompress_ptr cinfo);\n#endif\nEXTERN(void) jpeg_calc_output_dimensions(j_decompress_ptr cinfo);\n\n/* Control saving of COM and APPn markers into marker_list. */\nEXTERN(void) jpeg_save_markers(j_decompress_ptr cinfo, int marker_code,\n                               unsigned int length_limit);\n\n/* Install a special processing method for COM or APPn markers. */\nEXTERN(void) jpeg_set_marker_processor(j_decompress_ptr cinfo,\n                                       int marker_code,\n                                       jpeg_marker_parser_method routine);\n\n/* Read or write raw DCT coefficients --- useful for lossless transcoding. */\nEXTERN(jvirt_barray_ptr *) jpeg_read_coefficients(j_decompress_ptr cinfo);\nEXTERN(void) jpeg_write_coefficients(j_compress_ptr cinfo,\n                                     jvirt_barray_ptr *coef_arrays);\nEXTERN(void) jpeg_copy_critical_parameters (const j_decompress_ptr srcinfo,\n                                           j_compress_ptr dstinfo);\n\n/* If you choose to abort compression or decompression before completing\n * jpeg_finish_(de)compress, then you need to clean up to release memory,\n * temporary files, etc.  You can just call jpeg_destroy_(de)compress\n * if you're done with the JPEG object, but if you want to clean it up and\n * reuse it, call this:\n */\nEXTERN(void) jpeg_abort_compress(j_compress_ptr cinfo);\nEXTERN(void) jpeg_abort_decompress(j_decompress_ptr cinfo);\n\n/* Generic versions of jpeg_abort and jpeg_destroy that work on either\n * flavor of JPEG object.  These may be more convenient in some places.\n */\nEXTERN(void) jpeg_abort(j_common_ptr cinfo);\nEXTERN(void) jpeg_destroy(j_common_ptr cinfo);\n\n/* Default restart-marker-resync procedure for use by data source modules */\nEXTERN(boolean) jpeg_resync_to_restart(j_decompress_ptr cinfo, int desired);\n\n/* Accessor functions for extension parameters */\n#define JPEG_C_PARAM_SUPPORTED 1\nEXTERN(boolean) jpeg_c_bool_param_supported (const j_compress_ptr cinfo,\n                                             J_BOOLEAN_PARAM param);\nEXTERN(void) jpeg_c_set_bool_param (j_compress_ptr cinfo,\n                                    J_BOOLEAN_PARAM param, boolean value);\nEXTERN(boolean) jpeg_c_get_bool_param (const j_compress_ptr cinfo,\n                                       J_BOOLEAN_PARAM param);\n\nEXTERN(boolean) jpeg_c_float_param_supported (const j_compress_ptr cinfo,\n                                              J_FLOAT_PARAM param);\nEXTERN(void) jpeg_c_set_float_param (j_compress_ptr cinfo, J_FLOAT_PARAM param,\n                                     float value);\nEXTERN(float) jpeg_c_get_float_param (const j_compress_ptr cinfo,\n                                      J_FLOAT_PARAM param);\n\nEXTERN(boolean) jpeg_c_int_param_supported (const j_compress_ptr cinfo,\n                                            J_INT_PARAM param);\nEXTERN(void) jpeg_c_set_int_param (j_compress_ptr cinfo, J_INT_PARAM param,\n                                   int value);\nEXTERN(int) jpeg_c_get_int_param (const j_compress_ptr cinfo, J_INT_PARAM param);\n/* Read ICC profile.  See libjpeg.txt for usage information. */\nEXTERN(boolean) jpeg_read_icc_profile(j_decompress_ptr cinfo,\n                                      JOCTET **icc_data_ptr,\n                                      unsigned int *icc_data_len);\n\n/*\n * Permit users to replace the IDCT method dynamically.\n * The selector callback is called after the default idct implementation was choosen,\n * and is able to override it.\n */\nEXTERN(void) jpeg_set_idct_method_selector (j_decompress_ptr cinfo, jpeg_idct_method_selector selector);\n\n/* These marker codes are exported since applications and data source modules\n * are likely to want to use them.\n */\n\n#define JPEG_RST0       0xD0    /* RST0 marker code */\n#define JPEG_EOI        0xD9    /* EOI marker code */\n#define JPEG_APP0       0xE0    /* APP0 marker code */\n#define JPEG_COM        0xFE    /* COM marker code */\n\n\n/* If we have a brain-damaged compiler that emits warnings (or worse, errors)\n * for structure definitions that are never filled in, keep it quiet by\n * supplying dummy definitions for the various substructures.\n */\n\n#ifdef INCOMPLETE_TYPES_BROKEN\n#ifndef JPEG_INTERNALS          /* will be defined in jpegint.h */\nstruct jvirt_sarray_control { long dummy; };\nstruct jvirt_barray_control { long dummy; };\nstruct jpeg_comp_master { long dummy; };\nstruct jpeg_c_main_controller { long dummy; };\nstruct jpeg_c_prep_controller { long dummy; };\nstruct jpeg_c_coef_controller { long dummy; };\nstruct jpeg_marker_writer { long dummy; };\nstruct jpeg_color_converter { long dummy; };\nstruct jpeg_downsampler { long dummy; };\nstruct jpeg_forward_dct { long dummy; };\nstruct jpeg_entropy_encoder { long dummy; };\nstruct jpeg_decomp_master { long dummy; };\nstruct jpeg_d_main_controller { long dummy; };\nstruct jpeg_d_coef_controller { long dummy; };\nstruct jpeg_d_post_controller { long dummy; };\nstruct jpeg_input_controller { long dummy; };\nstruct jpeg_marker_reader { long dummy; };\nstruct jpeg_entropy_decoder { long dummy; };\nstruct jpeg_inverse_dct { long dummy; };\nstruct jpeg_upsampler { long dummy; };\nstruct jpeg_color_deconverter { long dummy; };\nstruct jpeg_color_quantizer { long dummy; };\n#endif /* JPEG_INTERNALS */\n#endif /* INCOMPLETE_TYPES_BROKEN */\n\n\n/*\n * The JPEG library modules define JPEG_INTERNALS before including this file.\n * The internal structure declarations are read only when that is true.\n * Applications using the library should not include jpegint.h, but may wish\n * to include jerror.h.\n */\n\n#ifdef JPEG_INTERNALS\n#include \"jpegint.h\"            /* fetch private declarations */\n#include \"jerror.h\"             /* fetch error codes too */\n#endif\n\n#ifdef __cplusplus\n#ifndef DONT_USE_EXTERN_C\n}\n#endif\n#endif\n\n#endif /* JPEGLIB_H */\n"
        },
        {
          "name": "jpegtran.1",
          "type": "blob",
          "size": 12.98828125,
          "content": ".TH JPEGTRAN 1 \"30 August 2024\"\n.SH NAME\njpegtran \\- lossless transformation of JPEG files\n.SH SYNOPSIS\n.B jpegtran\n[\n.I options\n]\n[\n.I filename\n]\n.LP\n.SH DESCRIPTION\n.LP\n.B jpegtran\nperforms various useful transformations of lossy (DCT-based) JPEG files.\nIt can translate the coded representation from one variant of JPEG to another,\nfor example from baseline JPEG to progressive JPEG or vice versa.  It can also\nperform some rearrangements of the image data, for example turning an image\nfrom landscape to portrait format by rotation.\n.PP\nFor EXIF files and JPEG files containing Exif data, you may prefer to use\n.B exiftran\ninstead.\n.PP\n.B jpegtran\nworks by rearranging the compressed data (DCT coefficients), without\never fully decoding the image.  Therefore, its transformations are lossless:\nthere is no image degradation at all, which would not be true if you used\n.B djpeg\nfollowed by\n.B cjpeg\nto accomplish the same conversion.  But by the same token,\n.B jpegtran\ncannot perform lossy operations such as changing the image quality.  However,\nwhile the image data is losslessly transformed, metadata can be removed.  See\nthe\n.B \\-copy\noption for specifics.\n.PP\n.B jpegtran\nreads the named JPEG/JFIF file, or the standard input if no file is\nnamed, and produces a JPEG/JFIF file on the standard output.\n.SH OPTIONS\nAll switch names may be abbreviated; for example,\n.B \\-optimize\nmay be written\n.B \\-opt\nor\n.BR \\-o .\nUpper and lower case are equivalent.\nBritish spellings are also accepted (e.g.,\n.BR \\-optimise ),\nthough for brevity these are not mentioned below.\n.PP\nTo specify the coded JPEG representation used in the output file,\n.B jpegtran\naccepts a subset of the switches recognized by\n.BR cjpeg :\n.TP\n.B \\-optimize\nPerform optimization of entropy encoding parameters.\n.TP\n.B \\-progressive\nCreate progressive JPEG file.\n.TP\n.B \\-arithmetic\nUse arithmetic coding.\n.TP\n.BI \\-restart \" N\"\nEmit a JPEG restart marker every N MCU rows, or every N MCUs if \"B\" is attached\nto the number.\n.TP\n.BI \\-scans \" file\"\nUse the scan script given in the specified text file.\n.PP\nSee\n.BR cjpeg (1)\nfor more details about these switches.\nIf you specify none of these switches, you get a plain baseline-JPEG output\nfile.  The quality setting and so forth are determined by the input file.\n.PP\nThe image can be losslessly transformed by giving one of these switches:\n.TP\n.B \\-flip horizontal\nMirror image horizontally (left-right).\n.TP\n.B \\-flip vertical\nMirror image vertically (top-bottom).\n.TP\n.B \\-rotate 90\nRotate image 90 degrees clockwise.\n.TP\n.B \\-rotate 180\nRotate image 180 degrees.\n.TP\n.B \\-rotate 270\nRotate image 270 degrees clockwise (or 90 ccw).\n.TP\n.B \\-transpose\nTranspose image (across UL-to-LR axis).\n.TP\n.B \\-transverse\nTransverse transpose (across UR-to-LL axis).\n.PP\nThe transpose transformation has no restrictions regarding image dimensions.\nThe other transformations operate rather oddly if the image dimensions are not\na multiple of the iMCU size (usually 8 or 16 pixels), because they can only\ntransform complete blocks of DCT coefficient data in the desired way.\n.PP\n.BR jpegtran 's\ndefault behavior when transforming an odd-size image is designed\nto preserve exact reversibility and mathematical consistency of the\ntransformation set.  As stated, transpose is able to flip the entire image\narea.  Horizontal mirroring leaves any partial iMCU column at the right edge\nuntouched, but is able to flip all rows of the image.  Similarly, vertical\nmirroring leaves any partial iMCU row at the bottom edge untouched, but is\nable to flip all columns.  The other transforms can be built up as sequences\nof transpose and flip operations; for consistency, their actions on edge\npixels are defined to be the same as the end result of the corresponding\ntranspose-and-flip sequence.\n.PP\nFor practical use, you may prefer to discard any untransformable edge pixels\nrather than having a strange-looking strip along the right and/or bottom edges\nof a transformed image.  To do this, add the\n.B \\-trim\nswitch:\n.TP\n.B \\-trim\nDrop non-transformable edge blocks.\n.IP\nObviously, a transformation with\n.B \\-trim\nis not reversible, so strictly speaking\n.B jpegtran\nwith this switch is not lossless.  Also, the expected mathematical\nequivalences between the transformations no longer hold.  For example,\n.B \\-rot 270 -trim\ntrims only the bottom edge, but\n.B \\-rot 90 -trim\nfollowed by\n.B \\-rot 180 -trim\ntrims both edges.\n.TP\n.B \\-perfect\nIf you are only interested in perfect transformations, add the\n.B \\-perfect\nswitch.  This causes\n.B jpegtran\nto fail with an error if the transformation is not perfect.\n.IP\nFor example, you may want to do\n.IP\n.B (jpegtran \\-rot 90 -perfect\n.I foo.jpg\n.B || djpeg\n.I foo.jpg\n.B | pnmflip \\-r90 | cjpeg)\n.IP\nto do a perfect rotation, if available, or an approximated one if not.\n.PP\nThis version of \\fBjpegtran\\fR also offers a lossless crop option, which\ndiscards data outside of a given image region but losslessly preserves what is\ninside.  Like the rotate and flip transforms, lossless crop is restricted by\nthe current JPEG format; the upper left corner of the selected region must fall\non an iMCU boundary.  If it doesn't, then it is silently moved up and/or left\nto the nearest iMCU boundary (the lower right corner is unchanged.)  Thus, the\noutput image covers at least the requested region, but it may cover more.  The\nadjustment of the region dimensions may be optionally disabled by attaching\nan 'f' character (\"force\") to the width or height number.\n\nThe image can be losslessly cropped by giving the switch:\n.TP\n.B \\-crop WxH+X+Y\nCrop the image to a rectangular region of width W and height H, starting at\npoint X,Y.  The lossless crop feature discards data outside of a given image\nregion but losslessly preserves what is inside.  Like the rotate and flip\ntransforms, lossless crop is restricted by the current JPEG format; the upper\nleft corner of the selected region must fall on an iMCU boundary.  If it\ndoesn't, then it is silently moved up and/or left to the nearest iMCU boundary\n(the lower right corner is unchanged.)\n.PP\nIf W or H is larger than the width/height of the input image, then the output\nimage is expanded in size, and the expanded region is filled in with zeros\n(neutral gray).  Attaching an 'f' character (\"flatten\") to the width number\nwill cause each block in the expanded region to be filled in with the DC\ncoefficient of the nearest block in the input image rather than grayed out.\nAttaching an 'r' character (\"reflect\") to the width number will cause the\nexpanded region to be filled in with repeated reflections of the input image\nrather than grayed out.\n.PP\nA complementary lossless wipe option is provided to discard (gray out) data\ninside a given image region while losslessly preserving what is outside:\n.TP\n.B \\-wipe WxH+X+Y\nWipe (gray out) a rectangular region of width W and height H from the input\nimage, starting at point X,Y.\n.PP\nAttaching an 'f' character (\"flatten\") to the width number will cause the\nregion to be filled with the average of adjacent blocks rather than grayed out.\nIf the wipe region and the region outside the wipe region, when adjusted to the\nnearest iMCU boundary, form two horizontally adjacent rectangles, then\nattaching an 'r' character (\"reflect\") to the width number will cause the wipe\nregion to be filled with repeated reflections of the outside region rather than\ngrayed out.\n.PP\nA lossless drop option is also provided, which allows another JPEG image to be\ninserted (\"dropped\") into the input image data at a given position, replacing\nthe existing image data at that position:\n.TP\n.B \\-drop +X+Y filename\nDrop (insert) another image at point X,Y\n.PP\nBoth the input image and the drop image must have the same subsampling level.\nIt is best if they also have the same quantization (quality.)  Otherwise, the\nquantization of the output image will be adapted to accommodate the higher of\nthe input image quality and the drop image quality.  The trim option can be\nused with the drop option to requantize the drop image to match the input\nimage.  Note that a grayscale image can be dropped into a full-color image or\nvice versa, as long as the full-color image has no vertical subsampling.  If\nthe input image is grayscale and the drop image is full-color, then the\nchrominance channels from the drop image will be discarded.\n.PP\nOther not-strictly-lossless transformation switches are:\n.TP\n.B \\-grayscale\nForce grayscale output.\n.IP\nThis option discards the chrominance channels if the input image is YCbCr\n(ie, a standard color JPEG), resulting in a grayscale JPEG file.  The\nluminance channel is preserved exactly, so this is a better method of reducing\nto grayscale than decompression, conversion, and recompression.  This switch\nis particularly handy for fixing a monochrome picture that was mistakenly\nencoded as a color JPEG.  (In such a case, the space savings from getting rid\nof the near-empty chroma channels won't be large; but the decoding time for\na grayscale JPEG is substantially less than that for a color JPEG.)\n.PP\n.B jpegtran\nalso recognizes these switches that control what to do with \"extra\" markers,\nsuch as comment blocks:\n.TP\n.B \\-copy none\nCopy no extra markers from source file.  This setting suppresses all\ncomments and other metadata in the source file.\n.TP\n.B \\-copy comments\nCopy only comment markers.  This setting copies comments from the source file\nbut discards any other metadata.\n.TP\n.B \\-copy icc\nCopy only ICC profile markers.  This setting copies the ICC profile from the\nsource file but discards any other metadata.\n.TP\n.B \\-copy all\nCopy all extra markers.  This setting preserves miscellaneous markers\nfound in the source file, such as JFIF thumbnails, Exif data, and Photoshop\nsettings.  In some files, these extra markers can be sizable.  Note that this\noption will copy thumbnails as-is; they will not be transformed.\n.PP\nThe default behavior is \\fB-copy comments\\fR.  (Note: in IJG releases v6 and\nv6a, \\fBjpegtran\\fR always did the equivalent of \\fB-copy none\\fR.)\n.PP\nAdditional switches recognized by jpegtran are:\n.TP\n.BI \\-icc \" file\"\nEmbed ICC color management profile contained in the specified file.  Note that\nthis will cause \\fBjpegtran\\fR to ignore any APP2 markers in the input file,\neven if \\fB-copy all\\fR or \\fB-copy icc\\fR is specified.\n.TP\n.BI \\-maxmemory \" N\"\nSet limit for amount of memory to use in processing large images.  Value is\nin thousands of bytes, or millions of bytes if \"M\" is attached to the\nnumber.  For example,\n.B \\-max 4m\nselects 4000000 bytes.  If more space is needed, an error will occur.\n.TP\n.BI \\-maxscans \" N\"\nAbort if the input image contains more than\n.I N\nscans.  This feature demonstrates a method by which applications can guard\nagainst denial-of-service attacks instigated by specially-crafted malformed\nJPEG images containing numerous scans with missing image data or image data\nconsisting only of \"EOB runs\" (a feature of progressive JPEG images that allows\npotentially hundreds of thousands of adjoining zero-value pixels to be\nrepresented using only a few bytes.)  Attempting to transform such malformed\nJPEG images can cause excessive CPU activity, since the decompressor must fully\nprocess each scan (even if the scan is corrupt) before it can proceed to the\nnext scan.\n.TP\n.BI \\-outfile \" name\"\nSend output image to the named file, not to standard output.\n.TP\n.BI \\-report\nReport transformation progress.\n.TP\n.BI \\-strict\nTreat all warnings as fatal.  This feature also demonstrates a method by which\napplications can guard against attacks instigated by specially-crafted\nmalformed JPEG images.  Enabling this option will cause the decompressor to\nabort if the input image contains incomplete or corrupt image data.\n.TP\n.B \\-verbose\nEnable debug printout.  More\n.BR \\-v 's\ngive more output.  Also, version information is printed at startup.\n.TP\n.B \\-debug\nSame as\n.BR \\-verbose .\n.TP\n.B \\-version\nPrint version information and exit.\n.SH EXAMPLES\n.LP\nThis example converts a baseline JPEG file to progressive form:\n.IP\n.B jpegtran \\-progressive\n.I foo.jpg\n.B >\n.I fooprog.jpg\n.PP\nThis example rotates an image 90 degrees clockwise, discarding any\nunrotatable edge pixels:\n.IP\n.B jpegtran \\-rot 90 -trim\n.I foo.jpg\n.B >\n.I foo90.jpg\n.SH ENVIRONMENT\n.TP\n.B JPEGMEM\nIf this environment variable is set, its value is the default memory limit.\nThe value is specified as described for the\n.B \\-maxmemory\nswitch.\n.B JPEGMEM\noverrides the default value specified when the program was compiled, and\nitself is overridden by an explicit\n.BR \\-maxmemory .\n.SH SEE ALSO\n.BR cjpeg (1),\n.BR djpeg (1),\n.BR rdjpgcom (1),\n.BR wrjpgcom (1)\n.br\nWallace, Gregory K.  \"The JPEG Still Picture Compression Standard\",\nCommunications of the ACM, April 1991 (vol. 34, no. 4), pp. 30-44.\n.SH AUTHOR\nIndependent JPEG Group\n.PP\nThis file was modified by The libjpeg-turbo Project to include only information\nrelevant to libjpeg-turbo and to wordsmith certain sections.\n.SH BUGS\nThe transform options can't transform odd-size images perfectly.  Use\n.B \\-trim\nor\n.B \\-perfect\nif you don't like the results.\n.PP\nThe entire image is read into memory and then written out again, even in\ncases where this isn't really necessary.  Expect swapping on large images,\nespecially when using the more complex transform options.\n"
        },
        {
          "name": "jpegtran.c",
          "type": "blob",
          "size": 27.6123046875,
          "content": "/*\n * jpegtran.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1995-2019, Thomas G. Lane, Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010, 2014, 2017, 2019-2022, 2024, D. R. Commander.\n * Copyright (C) 2014, Mozilla Corporation.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a command-line user interface for JPEG transcoding.\n * It is very similar to cjpeg.c, and partly to djpeg.c, but provides\n * lossless transcoding between different JPEG file formats.  It also\n * provides some lossless and sort-of-lossless transformations of JPEG data.\n */\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n#include \"transupp.h\"           /* Support routines for jpegtran */\n#include \"jversion.h\"           /* for version message */\n#include \"jconfigint.h\"\n\n\n/*\n * Argument-parsing code.\n * The switch parser is designed to be useful with DOS-style command line\n * syntax, ie, intermixed switches and file names, where only the switches\n * to the left of a given file name affect processing of that file.\n * The main program in this file doesn't actually use this capability...\n */\n\n\nstatic const char *progname;    /* program name for error messages */\nstatic char *icc_filename;      /* for -icc switch */\nstatic JDIMENSION max_scans;    /* for -maxscans switch */\nstatic char *outfilename;       /* for -outfile switch */\nstatic char *dropfilename;      /* for -drop switch */\nstatic boolean report;          /* for -report switch */\nstatic boolean strict;          /* for -strict switch */\nstatic boolean prefer_smallest;  /* use smallest of input or result file (if no image-changing options supplied) */\nstatic JCOPY_OPTION copyoption; /* -copy switch */\nstatic jpeg_transform_info transformoption; /* image transformation options */\nboolean memsrc = FALSE;  /* for -memsrc switch */\n#define INPUT_BUF_SIZE  4096\n\n\nLOCAL(void)\nusage(void)\n/* complain about bad command line */\n{\n  fprintf(stderr, \"usage: %s [switches] \", progname);\n#ifdef TWO_FILE_COMMANDLINE\n  fprintf(stderr, \"inputfile outputfile\\n\");\n#else\n  fprintf(stderr, \"[inputfile]\\n\");\n#endif\n\n  fprintf(stderr, \"Switches (names may be abbreviated):\\n\");\n  fprintf(stderr, \"  -copy none     Copy no extra markers from source file\\n\");\n  fprintf(stderr, \"  -copy comments Copy only comment markers (default)\\n\");\n  fprintf(stderr, \"  -copy icc      Copy only ICC profile markers\\n\");\n  fprintf(stderr, \"  -copy all      Copy all extra markers\\n\");\n#ifdef ENTROPY_OPT_SUPPORTED\n  fprintf(stderr, \"  -optimize      Optimize Huffman table (smaller file, but slow compression)\\n\");\n#endif\n#ifdef C_PROGRESSIVE_SUPPORTED\n  fprintf(stderr, \"  -progressive   Create progressive JPEG file\\n\");\n#endif\n  fprintf(stderr, \"  -revert        Revert to standard defaults (instead of mozjpeg defaults)\\n\");\n  fprintf(stderr, \"  -fastcrush     Disable progressive scan optimization\\n\");\n  fprintf(stderr, \"Switches for modifying the image:\\n\");\n#if TRANSFORMS_SUPPORTED\n  fprintf(stderr, \"  -crop WxH+X+Y  Crop to a rectangular region\\n\");\n  fprintf(stderr, \"  -drop +X+Y filename          Drop (insert) another image\\n\");\n  fprintf(stderr, \"  -flip [horizontal|vertical]  Mirror image (left-right or top-bottom)\\n\");\n  fprintf(stderr, \"  -grayscale     Reduce to grayscale (omit color data)\\n\");\n  fprintf(stderr, \"  -perfect       Fail if there is non-transformable edge blocks\\n\");\n  fprintf(stderr, \"  -rotate [90|180|270]         Rotate image (degrees clockwise)\\n\");\n#endif\n#if TRANSFORMS_SUPPORTED\n  fprintf(stderr, \"  -transpose     Transpose image\\n\");\n  fprintf(stderr, \"  -transverse    Transverse transpose image\\n\");\n  fprintf(stderr, \"  -trim          Drop non-transformable edge blocks\\n\");\n  fprintf(stderr, \"                 with -drop: Requantize drop file to match source file\\n\");\n  fprintf(stderr, \"  -wipe WxH+X+Y  Wipe (gray out) a rectangular region\\n\");\n#endif\n  fprintf(stderr, \"Switches for advanced users:\\n\");\n#ifdef C_ARITH_CODING_SUPPORTED\n  fprintf(stderr, \"  -arithmetic    Use arithmetic coding\\n\");\n#endif\n  fprintf(stderr, \"  -icc FILE      Embed ICC profile contained in FILE\\n\");\n  fprintf(stderr, \"  -restart N     Set restart interval in rows, or in blocks with B\\n\");\n  fprintf(stderr, \"  -maxmemory N   Maximum memory to use (in kbytes)\\n\");\n  fprintf(stderr, \"  -maxscans N    Maximum number of scans to allow in input file\\n\");\n  fprintf(stderr, \"  -outfile name  Specify name for output file\\n\");\n  fprintf(stderr, \"  -report        Report transformation progress\\n\");\n  fprintf(stderr, \"  -strict        Treat all warnings as fatal\\n\");\n  fprintf(stderr, \"  -verbose  or  -debug   Emit debug output\\n\");\n  fprintf(stderr, \"  -version       Print version information and exit\\n\");\n  fprintf(stderr, \"Switches for wizards:\\n\");\n#ifdef C_MULTISCAN_FILES_SUPPORTED\n  fprintf(stderr, \"  -scans FILE    Create multi-scan JPEG per script FILE\\n\");\n#endif\n  exit(EXIT_FAILURE);\n}\n\n\nLOCAL(void)\nselect_transform(JXFORM_CODE transform)\n/* Silly little routine to detect multiple transform options,\n * which we can't handle.\n */\n{\n#if TRANSFORMS_SUPPORTED\n  if (transformoption.transform == JXFORM_NONE ||\n      transformoption.transform == transform) {\n    transformoption.transform = transform;\n  } else {\n    fprintf(stderr, \"%s: can only do one image transformation at a time\\n\",\n            progname);\n    usage();\n  }\n#else\n  fprintf(stderr, \"%s: sorry, image transformation was not compiled\\n\",\n          progname);\n  exit(EXIT_FAILURE);\n#endif\n}\n\n\nLOCAL(int)\nparse_switches(j_compress_ptr cinfo, int argc, char **argv,\n               int last_file_arg_seen, boolean for_real)\n/* Parse optional switches.\n * Returns argv[] index of first file-name argument (== argc if none).\n * Any file names with indexes <= last_file_arg_seen are ignored;\n * they have presumably been processed in a previous iteration.\n * (Pass 0 for last_file_arg_seen on the first or only iteration.)\n * for_real is FALSE on the first (dummy) pass; we may skip any expensive\n * processing.\n */\n{\n  int argn;\n  char *arg;\n  boolean simple_progressive;\n  char *scansarg = NULL;        /* saves -scans parm if any */\n\n  /* Set up default JPEG parameters. */\n#ifdef C_PROGRESSIVE_SUPPORTED\n  simple_progressive = cinfo->num_scans == 0 ? FALSE : TRUE;\n#else\n  simple_progressive = FALSE;\n#endif\n  icc_filename = NULL;\n  max_scans = 0;\n  outfilename = NULL;\n  report = FALSE;\n  strict = FALSE;\n  copyoption = JCOPYOPT_DEFAULT;\n  transformoption.transform = JXFORM_NONE;\n  transformoption.perfect = FALSE;\n  transformoption.trim = FALSE;\n  transformoption.force_grayscale = FALSE;\n  transformoption.crop = FALSE;\n  transformoption.slow_hflip = FALSE;\n  cinfo->err->trace_level = 0;\n  prefer_smallest = TRUE;\n\n  /* Scan command line options, adjust parameters */\n\n  for (argn = 1; argn < argc; argn++) {\n    arg = argv[argn];\n    if (*arg != '-') {\n      /* Not a switch, must be a file name argument */\n      if (argn <= last_file_arg_seen) {\n        outfilename = NULL;     /* -outfile applies to just one input file */\n        continue;               /* ignore this name if previously processed */\n      }\n      break;                    /* else done parsing switches */\n    }\n    arg++;                      /* advance past switch marker character */\n\n    if (keymatch(arg, \"arithmetic\", 1)) {\n      /* Use arithmetic coding. */\n#ifdef C_ARITH_CODING_SUPPORTED\n      cinfo->arith_code = TRUE;\n\n      /* No table optimization required for AC */\n      cinfo->optimize_coding = FALSE;\n      prefer_smallest = FALSE;\n#else\n      fprintf(stderr, \"%s: sorry, arithmetic coding not supported\\n\",\n              progname);\n      exit(EXIT_FAILURE);\n#endif\n\n    } else if (keymatch(arg, \"copy\", 1)) {\n      /* Select which extra markers to copy. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (keymatch(argv[argn], \"none\", 1)) {\n        copyoption = JCOPYOPT_NONE;\n      } else if (keymatch(argv[argn], \"comments\", 1)) {\n        copyoption = JCOPYOPT_COMMENTS;\n      } else if (keymatch(argv[argn], \"icc\", 1)) {\n        copyoption = JCOPYOPT_ICC;\n      } else if (keymatch(argv[argn], \"all\", 1)) {\n        copyoption = JCOPYOPT_ALL;\n      } else\n        usage();\n\n    } else if (keymatch(arg, \"crop\", 2)) {\n      /* Perform lossless cropping. */\n#if TRANSFORMS_SUPPORTED\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (transformoption.crop /* reject multiple crop/drop/wipe requests */ ||\n          !jtransform_parse_crop_spec(&transformoption, argv[argn])) {\n        fprintf(stderr, \"%s: bogus -crop argument '%s'\\n\",\n                progname, argv[argn]);\n        exit(EXIT_FAILURE);\n      }\n      prefer_smallest = FALSE;\n#else\n      select_transform(JXFORM_NONE);    /* force an error */\n#endif\n\n    } else if (keymatch(arg, \"drop\", 2)) {\n#if TRANSFORMS_SUPPORTED\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (transformoption.crop /* reject multiple crop/drop/wipe requests */ ||\n          !jtransform_parse_crop_spec(&transformoption, argv[argn]) ||\n          transformoption.crop_width_set != JCROP_UNSET ||\n          transformoption.crop_height_set != JCROP_UNSET) {\n        fprintf(stderr, \"%s: bogus -drop argument '%s'\\n\",\n                progname, argv[argn]);\n        exit(EXIT_FAILURE);\n      }\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      dropfilename = argv[argn];\n      select_transform(JXFORM_DROP);\n#else\n      select_transform(JXFORM_NONE);    /* force an error */\n#endif\n\n    } else if (keymatch(arg, \"debug\", 1) || keymatch(arg, \"verbose\", 1)) {\n      /* Enable debug printouts. */\n      /* On first -d, print version identification */\n      static boolean printed_version = FALSE;\n\n      if (!printed_version) {\n        fprintf(stderr, \"%s version %s (build %s)\\n\",\n                PACKAGE_NAME, VERSION, BUILD);\n        fprintf(stderr, JCOPYRIGHT1);\n        fprintf(stderr, JCOPYRIGHT2 \"\\n\");\n        fprintf(stderr, \"Emulating The Independent JPEG Group's software, version %s\\n\\n\",\n                JVERSION);\n        printed_version = TRUE;\n      }\n      cinfo->err->trace_level++;\n\n    } else if (keymatch(arg, \"version\", 4)) {\n      fprintf(stderr, \"%s version %s (build %s)\\n\",\n              PACKAGE_NAME, VERSION, BUILD);\n      exit(EXIT_SUCCESS);\n\n    } else if (keymatch(arg, \"flip\", 1)) {\n      /* Mirror left-right or top-bottom. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (keymatch(argv[argn], \"horizontal\", 1))\n        select_transform(JXFORM_FLIP_H);\n      else if (keymatch(argv[argn], \"vertical\", 1))\n        select_transform(JXFORM_FLIP_V);\n      else\n        usage();\n\n      prefer_smallest = FALSE;\n\n    } else if (keymatch(arg, \"fastcrush\", 4)) {\n      jpeg_c_set_bool_param(cinfo, JBOOLEAN_OPTIMIZE_SCANS, FALSE);\n      \n    } else if (keymatch(arg, \"grayscale\", 1) || keymatch(arg, \"greyscale\",1)) {\n      /* Force to grayscale. */\n#if TRANSFORMS_SUPPORTED\n      transformoption.force_grayscale = TRUE;\n      prefer_smallest = FALSE;\n#else\n      select_transform(JXFORM_NONE);    /* force an error */\n#endif\n\n    } else if (keymatch(arg, \"icc\", 1)) {\n      /* Set ICC filename. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      icc_filename = argv[argn];\n\n    } else if (keymatch(arg, \"maxmemory\", 3)) {\n      /* Maximum memory in Kb (or Mb with 'm'). */\n      long lval;\n      char ch = 'x';\n\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%ld%c\", &lval, &ch) < 1)\n        usage();\n      if (ch == 'm' || ch == 'M')\n        lval *= 1000L;\n      cinfo->mem->max_memory_to_use = lval * 1000L;\n\n    } else if (keymatch(arg, \"maxscans\", 4)) {\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%u\", &max_scans) != 1)\n        usage();\n\n    } else if (keymatch(arg, \"optimize\", 1) || keymatch(arg, \"optimise\", 1)) {\n      /* Enable entropy parm optimization. */\n#ifdef ENTROPY_OPT_SUPPORTED\n      cinfo->optimize_coding = TRUE;\n#else\n      fprintf(stderr, \"%s: sorry, entropy optimization was not compiled\\n\",\n              progname);\n      exit(EXIT_FAILURE);\n#endif\n\n    } else if (keymatch(arg, \"outfile\", 4)) {\n      /* Set output file name. */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      outfilename = argv[argn]; /* save it away for later use */\n\n    } else if (keymatch(arg, \"perfect\", 2)) {\n      /* Fail if there is any partial edge MCUs that the transform can't\n       * handle. */\n      transformoption.perfect = TRUE;\n\n    } else if (keymatch(arg, \"progressive\", 1)) {\n      /* Select simple progressive mode. */\n#ifdef C_PROGRESSIVE_SUPPORTED\n      simple_progressive = TRUE;\n      prefer_smallest = FALSE;\n      /* We must postpone execution until num_components is known. */\n#else\n      fprintf(stderr, \"%s: sorry, progressive output was not compiled\\n\",\n              progname);\n      exit(EXIT_FAILURE);\n#endif\n\n    } else if (keymatch(arg, \"report\", 3)) {\n      report = TRUE;\n\n    } else if (keymatch(arg, \"restart\", 1)) {\n      /* Restart interval in MCU rows (or in MCUs with 'b'). */\n      long lval;\n      char ch = 'x';\n\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (sscanf(argv[argn], \"%ld%c\", &lval, &ch) < 1)\n        usage();\n      if (lval < 0 || lval > 65535L)\n        usage();\n      if (ch == 'b' || ch == 'B') {\n        cinfo->restart_interval = (unsigned int)lval;\n        cinfo->restart_in_rows = 0; /* else prior '-restart n' overrides me */\n      } else {\n        cinfo->restart_in_rows = (int)lval;\n        /* restart_interval will be computed during startup */\n      }\n\n    } else if (keymatch(arg, \"revert\", 3)) {\n      /* revert to old JPEG default */\n      jpeg_c_set_int_param(cinfo, JINT_COMPRESS_PROFILE, JCP_FASTEST);\n      prefer_smallest = FALSE;\n      \n    } else if (keymatch(arg, \"rotate\", 2)) {\n      /* Rotate 90, 180, or 270 degrees (measured clockwise). */\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (keymatch(argv[argn], \"90\", 2))\n        select_transform(JXFORM_ROT_90);\n      else if (keymatch(argv[argn], \"180\", 3))\n        select_transform(JXFORM_ROT_180);\n      else if (keymatch(argv[argn], \"270\", 3))\n        select_transform(JXFORM_ROT_270);\n      else\n        usage();\n\n      prefer_smallest = FALSE;\n\n    } else if (keymatch(arg, \"scans\", 1)) {\n      /* Set scan script. */\n#ifdef C_MULTISCAN_FILES_SUPPORTED\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      prefer_smallest = FALSE;\n      scansarg = argv[argn];\n      /* We must postpone reading the file in case -progressive appears. */\n#else\n      fprintf(stderr, \"%s: sorry, multi-scan output was not compiled\\n\",\n              progname);\n      exit(EXIT_FAILURE);\n#endif\n\n    } else if (keymatch(arg, \"strict\", 2)) {\n      strict = TRUE;\n\n    } else if (keymatch(arg, \"transpose\", 1)) {\n      /* Transpose (across UL-to-LR axis). */\n      select_transform(JXFORM_TRANSPOSE);\n      prefer_smallest = FALSE;\n\n    } else if (keymatch(arg, \"transverse\", 6)) {\n      /* Transverse transpose (across UR-to-LL axis). */\n      select_transform(JXFORM_TRANSVERSE);\n      prefer_smallest = FALSE;\n\n    } else if (keymatch(arg, \"trim\", 3)) {\n      /* Trim off any partial edge MCUs that the transform can't handle. */\n      transformoption.trim = TRUE;\n      prefer_smallest = FALSE;\n\n    } else if (keymatch(arg, \"wipe\", 1)) {\n#if TRANSFORMS_SUPPORTED\n      if (++argn >= argc)       /* advance to next argument */\n        usage();\n      if (transformoption.crop /* reject multiple crop/drop/wipe requests */ ||\n          !jtransform_parse_crop_spec(&transformoption, argv[argn])) {\n        fprintf(stderr, \"%s: bogus -wipe argument '%s'\\n\",\n                progname, argv[argn]);\n        exit(EXIT_FAILURE);\n      }\n      select_transform(JXFORM_WIPE);\n#else\n      select_transform(JXFORM_NONE);    /* force an error */\n#endif\n\n    } else {\n      usage();                  /* bogus switch */\n    }\n  }\n\n  /* Post-switch-scanning cleanup */\n\n  if (for_real) {\n\n#ifdef C_PROGRESSIVE_SUPPORTED\n    if (simple_progressive)     /* process -progressive; -scans can override */\n      jpeg_simple_progression(cinfo);\n#endif\n\n#ifdef C_MULTISCAN_FILES_SUPPORTED\n    if (scansarg != NULL)       /* process -scans if it was present */\n      if (!read_scan_script(cinfo, scansarg))\n        usage();\n#endif\n  }\n\n  return argn;                  /* return index of next arg (file name) */\n}\n\n\nMETHODDEF(void)\nmy_emit_message(j_common_ptr cinfo, int msg_level)\n{\n  if (msg_level < 0) {\n    /* Treat warning as fatal */\n    cinfo->err->error_exit(cinfo);\n  } else {\n    if (cinfo->err->trace_level >= msg_level)\n      cinfo->err->output_message(cinfo);\n  }\n}\n\n\n/*\n * The main program.\n */\n\nint\nmain(int argc, char **argv)\n{\n  struct jpeg_decompress_struct srcinfo;\n#if TRANSFORMS_SUPPORTED\n  struct jpeg_decompress_struct dropinfo;\n  struct jpeg_error_mgr jdroperr;\n  FILE *drop_file;\n#endif\n  struct jpeg_compress_struct dstinfo;\n  struct jpeg_error_mgr jsrcerr, jdsterr;\n  struct cdjpeg_progress_mgr src_progress, dst_progress;\n  jvirt_barray_ptr *src_coef_arrays;\n  jvirt_barray_ptr *dst_coef_arrays;\n  int file_index;\n  /* We assume all-in-memory processing and can therefore use only a\n   * single file pointer for sequential input and output operation.\n   */\n  FILE *fp;\n  unsigned char *inbuffer = NULL;\n  unsigned long insize = 0;\n  unsigned char *outbuffer = NULL;\n  unsigned long outsize = 0;\n  FILE *icc_file;\n  JOCTET *icc_profile = NULL;\n  long icc_len = 0;\n\n  progname = argv[0];\n  if (progname == NULL || progname[0] == 0)\n    progname = \"jpegtran\";      /* in case C library doesn't provide it */\n\n  /* Initialize the JPEG decompression object with default error handling. */\n  srcinfo.err = jpeg_std_error(&jsrcerr);\n  jpeg_create_decompress(&srcinfo);\n  /* Initialize the JPEG compression object with default error handling. */\n  dstinfo.err = jpeg_std_error(&jdsterr);\n  jpeg_create_compress(&dstinfo);\n\n  /* Scan command line to find file names.\n   * It is convenient to use just one switch-parsing routine, but the switch\n   * values read here are mostly ignored; we will rescan the switches after\n   * opening the input file.  Also note that most of the switches affect the\n   * destination JPEG object, so we parse into that and then copy over what\n   * needs to affect the source too.\n   */\n\n  file_index = parse_switches(&dstinfo, argc, argv, 0, FALSE);\n  jsrcerr.trace_level = jdsterr.trace_level;\n  srcinfo.mem->max_memory_to_use = dstinfo.mem->max_memory_to_use;\n\n  if (strict)\n    jsrcerr.emit_message = my_emit_message;\n\n#ifdef TWO_FILE_COMMANDLINE\n  /* Must have either -outfile switch or explicit output file name */\n  if (outfilename == NULL) {\n    if (file_index != argc - 2) {\n      fprintf(stderr, \"%s: must name one input and one output file\\n\",\n              progname);\n      usage();\n    }\n    outfilename = argv[file_index + 1];\n  } else {\n    if (file_index != argc - 1) {\n      fprintf(stderr, \"%s: must name one input and one output file\\n\",\n              progname);\n      usage();\n    }\n  }\n#else\n  /* Unix style: expect zero or one file name */\n  if (file_index < argc - 1) {\n    fprintf(stderr, \"%s: only one input file\\n\", progname);\n    usage();\n  }\n#endif /* TWO_FILE_COMMANDLINE */\n\n  /* Open the input file. */\n  if (file_index < argc) {\n    if ((fp = fopen(argv[file_index], READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s for reading\\n\", progname,\n              argv[file_index]);\n      exit(EXIT_FAILURE);\n    }\n  } else {\n    /* default input file is stdin */\n    fp = read_stdin();\n  }\n\n  if (icc_filename != NULL) {\n    if ((icc_file = fopen(icc_filename, READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, icc_filename);\n      exit(EXIT_FAILURE);\n    }\n    if (fseek(icc_file, 0, SEEK_END) < 0 ||\n        (icc_len = ftell(icc_file)) < 1 ||\n        fseek(icc_file, 0, SEEK_SET) < 0) {\n      fprintf(stderr, \"%s: can't determine size of %s\\n\", progname,\n              icc_filename);\n      exit(EXIT_FAILURE);\n    }\n    if ((icc_profile = (JOCTET *)malloc(icc_len)) == NULL) {\n      fprintf(stderr, \"%s: can't allocate memory for ICC profile\\n\", progname);\n      fclose(icc_file);\n      exit(EXIT_FAILURE);\n    }\n    if (fread(icc_profile, icc_len, 1, icc_file) < 1) {\n      fprintf(stderr, \"%s: can't read ICC profile from %s\\n\", progname,\n              icc_filename);\n      free(icc_profile);\n      fclose(icc_file);\n      exit(EXIT_FAILURE);\n    }\n    fclose(icc_file);\n    if (copyoption == JCOPYOPT_ALL)\n      copyoption = JCOPYOPT_ALL_EXCEPT_ICC;\n    if (copyoption == JCOPYOPT_ICC)\n      copyoption = JCOPYOPT_NONE;\n  }\n\n  if (report) {\n    start_progress_monitor((j_common_ptr)&dstinfo, &dst_progress);\n    dst_progress.report = report;\n  }\n  if (report || max_scans != 0) {\n    start_progress_monitor((j_common_ptr)&srcinfo, &src_progress);\n    src_progress.report = report;\n    src_progress.max_scans = max_scans;\n  }\n#if TRANSFORMS_SUPPORTED\n  /* Open the drop file. */\n  if (dropfilename != NULL) {\n    if ((drop_file = fopen(dropfilename, READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s for reading\\n\", progname,\n              dropfilename);\n      exit(EXIT_FAILURE);\n    }\n    dropinfo.err = jpeg_std_error(&jdroperr);\n    jpeg_create_decompress(&dropinfo);\n    jpeg_stdio_src(&dropinfo, drop_file);\n  } else {\n    drop_file = NULL;\n  }\n#endif\n\n  /* Specify data source for decompression */\n  if (jpeg_c_int_param_supported(&dstinfo, JINT_COMPRESS_PROFILE) &&\n      jpeg_c_get_int_param(&dstinfo, JINT_COMPRESS_PROFILE)\n        == JCP_MAX_COMPRESSION)\n    memsrc = TRUE; /* needed to revert to original */\n#if JPEG_LIB_VERSION >= 80 || defined(MEM_SRCDST_SUPPORTED)\n  if (memsrc) {\n    size_t nbytes;\n    do {\n      inbuffer = (unsigned char *)realloc(inbuffer, insize + INPUT_BUF_SIZE);\n      if (inbuffer == NULL) {\n        fprintf(stderr, \"%s: memory allocation failure\\n\", progname);\n        exit(EXIT_FAILURE);\n      }\n      nbytes = fread(&inbuffer[insize], 1, INPUT_BUF_SIZE, fp);\n      if (nbytes < INPUT_BUF_SIZE && ferror(fp)) {\n        if (file_index < argc)\n          fprintf(stderr, \"%s: can't read from %s\\n\", progname,\n                  argv[file_index]);\n        else\n          fprintf(stderr, \"%s: can't read from stdin\\n\", progname);\n      }\n      insize += (unsigned long)nbytes;\n    } while (nbytes == INPUT_BUF_SIZE);\n    jpeg_mem_src(&srcinfo, inbuffer, insize);\n  } else\n#endif\n  jpeg_stdio_src(&srcinfo, fp);\n\n  /* Enable saving of extra markers that we want to copy */\n  jcopy_markers_setup(&srcinfo, copyoption);\n\n  /* Read file header */\n  (void)jpeg_read_header(&srcinfo, TRUE);\n\n#if TRANSFORMS_SUPPORTED\n  if (dropfilename != NULL) {\n    (void)jpeg_read_header(&dropinfo, TRUE);\n    transformoption.crop_width = dropinfo.image_width;\n    transformoption.crop_width_set = JCROP_POS;\n    transformoption.crop_height = dropinfo.image_height;\n    transformoption.crop_height_set = JCROP_POS;\n    transformoption.drop_ptr = &dropinfo;\n  }\n#endif\n\n  /* Any space needed by a transform option must be requested before\n   * jpeg_read_coefficients so that memory allocation will be done right.\n   */\n#if TRANSFORMS_SUPPORTED\n  /* Fail right away if -perfect is given and transformation is not perfect.\n   */\n  if (!jtransform_request_workspace(&srcinfo, &transformoption)) {\n    fprintf(stderr, \"%s: transformation is not perfect\\n\", progname);\n    exit(EXIT_FAILURE);\n  }\n#endif\n\n  /* Read source file as DCT coefficients */\n  src_coef_arrays = jpeg_read_coefficients(&srcinfo);\n\n#if TRANSFORMS_SUPPORTED\n  if (dropfilename != NULL) {\n    transformoption.drop_coef_arrays = jpeg_read_coefficients(&dropinfo);\n  }\n#endif\n\n  /* Initialize destination compression parameters from source values */\n  jpeg_copy_critical_parameters(&srcinfo, &dstinfo);\n\n  /* Adjust destination parameters if required by transform options;\n   * also find out which set of coefficient arrays will hold the output.\n   */\n#if TRANSFORMS_SUPPORTED\n  dst_coef_arrays = jtransform_adjust_parameters(&srcinfo, &dstinfo,\n                                                 src_coef_arrays,\n                                                 &transformoption);\n#else\n  dst_coef_arrays = src_coef_arrays;\n#endif\n\n  /* Close input file, if we opened it.\n   * Note: we assume that jpeg_read_coefficients consumed all input\n   * until JPEG_REACHED_EOI, and that jpeg_finish_decompress will\n   * only consume more while (!cinfo->inputctl->eoi_reached).\n   * We cannot call jpeg_finish_decompress here since we still need the\n   * virtual arrays allocated from the source object for processing.\n   */\n  if (fp != stdin)\n    fclose(fp);\n\n  /* Open the output file. */\n  if (outfilename != NULL) {\n    if ((fp = fopen(outfilename, WRITE_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s for writing\\n\", progname,\n              outfilename);\n      exit(EXIT_FAILURE);\n    }\n  } else {\n    /* default output file is stdout */\n    fp = write_stdout();\n  }\n\n  /* Adjust default compression parameters by re-parsing the options */\n  file_index = parse_switches(&dstinfo, argc, argv, 0, TRUE);\n\n  /* Specify data destination for compression */\n#if JPEG_LIB_VERSION >= 80 || defined(MEM_SRCDST_SUPPORTED)\n  if (jpeg_c_int_param_supported(&dstinfo, JINT_COMPRESS_PROFILE) &&\n      jpeg_c_get_int_param(&dstinfo, JINT_COMPRESS_PROFILE)\n        == JCP_MAX_COMPRESSION)\n    jpeg_mem_dest(&dstinfo, &outbuffer, &outsize);\n  else\n#endif\n  jpeg_stdio_dest(&dstinfo, fp);\n\n  /* Start compressor (note no image data is actually written here) */\n  jpeg_write_coefficients(&dstinfo, dst_coef_arrays);\n\n  /* Copy to the output file any extra markers that we want to preserve */\n  jcopy_markers_execute(&srcinfo, &dstinfo, copyoption);\n\n  if (icc_profile != NULL)\n    jpeg_write_icc_profile(&dstinfo, icc_profile, (unsigned int)icc_len);\n\n  /* Execute image transformation, if any */\n#if TRANSFORMS_SUPPORTED\n  jtransform_execute_transformation(&srcinfo, &dstinfo, src_coef_arrays,\n                                    &transformoption);\n#endif\n\n  /* Finish compression and release memory */\n  jpeg_finish_compress(&dstinfo);\n\n#if JPEG_LIB_VERSION >= 80 || defined(MEM_SRCDST_SUPPORTED)\n  if (jpeg_c_int_param_supported(&dstinfo, JINT_COMPRESS_PROFILE) &&\n      jpeg_c_get_int_param(&dstinfo, JINT_COMPRESS_PROFILE)\n        == JCP_MAX_COMPRESSION) {\n    size_t nbytes;\n    \n    unsigned char *buffer = outbuffer;\n    unsigned long size = outsize;\n    if (prefer_smallest && insize < size) {\n      size = insize;\n      buffer = inbuffer;\n    }\n\n    nbytes = fwrite(buffer, 1, size, fp);\n    if (nbytes < size && ferror(fp)) {\n      if (file_index < argc)\n        fprintf(stderr, \"%s: can't write to %s\\n\", progname,\n                argv[file_index]);\n      else\n        fprintf(stderr, \"%s: can't write to stdout\\n\", progname);\n    }\n  }\n#endif\n\n  jpeg_destroy_compress(&dstinfo);\n  (void)jpeg_finish_decompress(&srcinfo);\n  jpeg_destroy_decompress(&srcinfo);\n\n#if TRANSFORMS_SUPPORTED\n  if (dropfilename != NULL) {\n    (void)jpeg_finish_decompress(&dropinfo);\n    jpeg_destroy_decompress(&dropinfo);\n  }\n#endif\n\n  /* Close output file, if we opened it */\n  if (fp != stdout)\n    fclose(fp);\n#if TRANSFORMS_SUPPORTED\n  if (drop_file != NULL)\n    fclose(drop_file);\n#endif\n\n  if (report)\n    end_progress_monitor((j_common_ptr)&dstinfo);\n  if (report || max_scans != 0)\n    end_progress_monitor((j_common_ptr)&srcinfo);\n\n  free(inbuffer);\n  free(outbuffer);\n\n  free(icc_profile);\n\n  /* All done. */\n#if TRANSFORMS_SUPPORTED\n  if (dropfilename != NULL)\n    exit(jsrcerr.num_warnings + jdroperr.num_warnings +\n         jdsterr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);\n#endif\n  exit(jsrcerr.num_warnings + jdsterr.num_warnings ?\n       EXIT_WARNING : EXIT_SUCCESS);\n  return 0;                     /* suppress no-return-value warnings */\n}\n"
        },
        {
          "name": "jpegyuv.c",
          "type": "blob",
          "size": 5.1123046875,
          "content": "/*\n * Written by Josh Aas and Tim Terriberry\n * Copyright (c) 2013, Mozilla Corporation\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n * 3. Neither the name of the Mozilla Corporation nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Input: JPEG YUV 4:2:0 */\n/* Output: YUV 4:2:0 */\n\n/* gcc -std=c99 jpegyuv.c -I/opt/local/include/ -L/opt/local/lib/ -ljpeg -o jpegyuv */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"jpeglib.h\"\n\nint main(int argc, char *argv[]) {\n  const char *jpg_path;\n  const char *yuv_path;\n  struct jpeg_decompress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  FILE *jpg_fd;\n  int luma_width;\n  int luma_height;\n  int chroma_width;\n  int chroma_height;\n  int frame_width;\n  int yuv_size;\n  JSAMPLE *jpg_buffer;\n  JSAMPROW yrow_pointer[16];\n  JSAMPROW cbrow_pointer[8];\n  JSAMPROW crrow_pointer[8];\n  JSAMPROW *plane_pointer[3];\n  unsigned char *yuv_buffer;\n  int x;\n  int y;\n  FILE *yuv_fd;\n\n  if (argc != 3) {\n    fprintf(stderr, \"Required arguments:\\n\");\n    fprintf(stderr, \"1. Path to JPG input file\\n\");\n    fprintf(stderr, \"2. Path to YUV output file\\n\");\n    return 1;\n  }\n\n  /* Will check these for validity when opening via 'fopen'. */\n  jpg_path = argv[1];\n  yuv_path = argv[2];\n\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_decompress(&cinfo);\n\n  jpg_fd = fopen(jpg_path, \"rb\");\n  if (!jpg_fd) {\n    fprintf(stderr, \"Invalid path to JPEG file!\\n\");\n    return 1;\n  }\n\n  jpeg_stdio_src(&cinfo, jpg_fd);\n\n  jpeg_read_header(&cinfo, TRUE);\n\n  cinfo.raw_data_out = TRUE;\n  cinfo.do_fancy_upsampling = FALSE;\n\n  jpeg_start_decompress(&cinfo);\n\n  luma_width = cinfo.output_width;\n  luma_height = cinfo.output_height;\n\n  chroma_width = (luma_width + 1) >> 1;\n  chroma_height = (luma_height + 1) >> 1;\n\n  yuv_size = luma_width*luma_height + 2*chroma_width*chroma_height;\n  yuv_buffer = malloc(yuv_size);\n  if (!yuv_buffer) {\n    fclose(jpg_fd);\n    fprintf(stderr, \"Memory allocation failure!\\n\");\n    return 1;\n  }\n\n  frame_width = (cinfo.output_width + (16 - 1)) & ~(16 - 1);\n\n  jpg_buffer = malloc(frame_width*16 + 2*(frame_width/2)*8);\n  if (!jpg_buffer) {\n    fclose(jpg_fd);\n    free(yuv_buffer);\n    fprintf(stderr, \"Memory allocation failure!\\n\");\n    return 1;\n  }\n\n  plane_pointer[0] = yrow_pointer;\n  plane_pointer[1] = cbrow_pointer;\n  plane_pointer[2] = crrow_pointer;\n\n  for (y = 0; y < 16; y++) {\n    yrow_pointer[y] = &jpg_buffer[frame_width*y];\n  }\n  for (y = 0; y < 8; y++) {\n    cbrow_pointer[y] = &jpg_buffer[frame_width*16 + (frame_width/2)*y];\n    crrow_pointer[y] = &jpg_buffer[frame_width*16 + (frame_width/2)*(8 + y)];\n  }\n\n  while (cinfo.output_scanline < cinfo.output_height) {\n    int luma_scanline;\n    int chroma_scanline;\n\n    luma_scanline = cinfo.output_scanline;\n    chroma_scanline = (luma_scanline + 1) >> 1;\n\n    jpeg_read_raw_data(&cinfo, plane_pointer, 16);\n\n    for (y = 0; y < 16 && luma_scanline + y < luma_height; y++) {\n      for (x = 0; x < luma_width; x++) {\n        yuv_buffer[luma_width*(luma_scanline + y) + x] = yrow_pointer[y][x];\n      }\n    }\n    for (y = 0; y < 8 && chroma_scanline + y < chroma_height; y++) {\n      for (x = 0; x < chroma_width; x++) {\n        yuv_buffer[luma_width*luma_height +\n         chroma_width*(chroma_scanline + y) + x] = cbrow_pointer[y][x];\n        yuv_buffer[luma_width*luma_height + chroma_width*chroma_height +\n         chroma_width*(chroma_scanline + y) + x] = crrow_pointer[y][x];\n      }\n    }\n  }\n\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n\n  fclose(jpg_fd);\n  free(jpg_buffer);\n\n  yuv_fd = fopen(yuv_path, \"wb\");\n  if (!yuv_fd) {\n    fprintf(stderr, \"Invalid path to YUV file!\");\n    free(yuv_buffer);\n    return 1;\n  }\n  if (fwrite(yuv_buffer, yuv_size, 1, yuv_fd) != 1) {\n    fprintf(stderr, \"Error writing yuv file\\n\");\n  }\n\n  fclose(yuv_fd);\n  free(yuv_buffer);\n\n  return 0;\n}\n"
        },
        {
          "name": "jquant1.c",
          "type": "blob",
          "size": 32.1162109375,
          "content": "/*\n * jquant1.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2009, 2015, 2022-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains 1-pass color quantization (color mapping) routines.\n * These routines provide mapping to a fixed color map using equally spaced\n * color values.  Optional Floyd-Steinberg or ordered dithering is available.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n\n#if defined(QUANT_1PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16\n\n\n/*\n * The main purpose of 1-pass quantization is to provide a fast, if not very\n * high quality, colormapped output capability.  A 2-pass quantizer usually\n * gives better visual quality; however, for quantized grayscale output this\n * quantizer is perfectly adequate.  Dithering is highly recommended with this\n * quantizer, though you can turn it off if you really want to.\n *\n * In 1-pass quantization the colormap must be chosen in advance of seeing the\n * image.  We use a map consisting of all combinations of Ncolors[i] color\n * values for the i'th component.  The Ncolors[] values are chosen so that\n * their product, the total number of colors, is no more than that requested.\n * (In most cases, the product will be somewhat less.)\n *\n * Since the colormap is orthogonal, the representative value for each color\n * component can be determined without considering the other components;\n * then these indexes can be combined into a colormap index by a standard\n * N-dimensional-array-subscript calculation.  Most of the arithmetic involved\n * can be precalculated and stored in the lookup table colorindex[].\n * colorindex[i][j] maps pixel value j in component i to the nearest\n * representative value (grid plane) for that component; this index is\n * multiplied by the array stride for component i, so that the\n * index of the colormap entry closest to a given pixel value is just\n *    sum( colorindex[component-number][pixel-component-value] )\n * Aside from being fast, this scheme allows for variable spacing between\n * representative values with no additional lookup cost.\n *\n * If gamma correction has been applied in color conversion, it might be wise\n * to adjust the color grid spacing so that the representative colors are\n * equidistant in linear space.  At this writing, gamma correction is not\n * implemented by jdcolor, so nothing is done here.\n */\n\n\n/* Declarations for ordered dithering.\n *\n * We use a standard 16x16 ordered dither array.  The basic concept of ordered\n * dithering is described in many references, for instance Dale Schumacher's\n * chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).\n * In place of Schumacher's comparisons against a \"threshold\" value, we add a\n * \"dither\" value to the input pixel and then round the result to the nearest\n * output value.  The dither value is equivalent to (0.5 - threshold) times\n * the distance between output values.  For ordered dithering, we assume that\n * the output colors are equally spaced; if not, results will probably be\n * worse, since the dither may be too much or too little at a given point.\n *\n * The normal calculation would be to form pixel value + dither, range-limit\n * this to 0.._MAXJSAMPLE, and then index into the colorindex table as usual.\n * We can skip the separate range-limiting step by extending the colorindex\n * table in both directions.\n */\n\n#define ODITHER_SIZE  16        /* dimension of dither matrix */\n/* NB: if ODITHER_SIZE is not a power of 2, ODITHER_MASK uses will break */\n#define ODITHER_CELLS  (ODITHER_SIZE * ODITHER_SIZE) /* # cells in matrix */\n#define ODITHER_MASK  (ODITHER_SIZE - 1) /* mask for wrapping around\n                                            counters */\n\ntypedef int ODITHER_MATRIX[ODITHER_SIZE][ODITHER_SIZE];\ntypedef int (*ODITHER_MATRIX_PTR)[ODITHER_SIZE];\n\nstatic const UINT8 base_dither_matrix[ODITHER_SIZE][ODITHER_SIZE] = {\n  /* Bayer's order-4 dither array.  Generated by the code given in\n   * Stephen Hawley's article \"Ordered Dithering\" in Graphics Gems I.\n   * The values in this array must range from 0 to ODITHER_CELLS-1.\n   */\n  {   0, 192,  48, 240,  12, 204,  60, 252,   3, 195,  51, 243,  15, 207,  63, 255 },\n  { 128,  64, 176, 112, 140,  76, 188, 124, 131,  67, 179, 115, 143,  79, 191, 127 },\n  {  32, 224,  16, 208,  44, 236,  28, 220,  35, 227,  19, 211,  47, 239,  31, 223 },\n  { 160,  96, 144,  80, 172, 108, 156,  92, 163,  99, 147,  83, 175, 111, 159,  95 },\n  {   8, 200,  56, 248,   4, 196,  52, 244,  11, 203,  59, 251,   7, 199,  55, 247 },\n  { 136,  72, 184, 120, 132,  68, 180, 116, 139,  75, 187, 123, 135,  71, 183, 119 },\n  {  40, 232,  24, 216,  36, 228,  20, 212,  43, 235,  27, 219,  39, 231,  23, 215 },\n  { 168, 104, 152,  88, 164, 100, 148,  84, 171, 107, 155,  91, 167, 103, 151,  87 },\n  {   2, 194,  50, 242,  14, 206,  62, 254,   1, 193,  49, 241,  13, 205,  61, 253 },\n  { 130,  66, 178, 114, 142,  78, 190, 126, 129,  65, 177, 113, 141,  77, 189, 125 },\n  {  34, 226,  18, 210,  46, 238,  30, 222,  33, 225,  17, 209,  45, 237,  29, 221 },\n  { 162,  98, 146,  82, 174, 110, 158,  94, 161,  97, 145,  81, 173, 109, 157,  93 },\n  {  10, 202,  58, 250,   6, 198,  54, 246,   9, 201,  57, 249,   5, 197,  53, 245 },\n  { 138,  74, 186, 122, 134,  70, 182, 118, 137,  73, 185, 121, 133,  69, 181, 117 },\n  {  42, 234,  26, 218,  38, 230,  22, 214,  41, 233,  25, 217,  37, 229,  21, 213 },\n  { 170, 106, 154,  90, 166, 102, 150,  86, 169, 105, 153,  89, 165, 101, 149,  85 }\n};\n\n\n/* Declarations for Floyd-Steinberg dithering.\n *\n * Errors are accumulated into the array fserrors[], at a resolution of\n * 1/16th of a pixel count.  The error at a given pixel is propagated\n * to its not-yet-processed neighbors using the standard F-S fractions,\n *              ...     (here)  7/16\n *              3/16    5/16    1/16\n * We work left-to-right on even rows, right-to-left on odd rows.\n *\n * We can get away with a single array (holding one row's worth of errors)\n * by using it to store the current row's errors at pixel columns not yet\n * processed, but the next row's errors at columns already processed.  We\n * need only a few extra variables to hold the errors immediately around the\n * current column.  (If we are lucky, those variables are in registers, but\n * even if not, they're probably cheaper to access than array elements are.)\n *\n * The fserrors[] array is indexed [component#][position].\n * We provide (#columns + 2) entries per component; the extra entry at each\n * end saves us from special-casing the first and last pixels.\n */\n\n#if BITS_IN_JSAMPLE == 8\ntypedef INT16 FSERROR;          /* 16 bits should be enough */\ntypedef int LOCFSERROR;         /* use 'int' for calculation temps */\n#else\ntypedef JLONG FSERROR;          /* may need more than 16 bits */\ntypedef JLONG LOCFSERROR;       /* be sure calculation temps are big enough */\n#endif\n\ntypedef FSERROR *FSERRPTR;      /* pointer to error array */\n\n\n/* Private subobject */\n\n#define MAX_Q_COMPS  4          /* max components I can handle */\n\ntypedef struct {\n  struct jpeg_color_quantizer pub; /* public fields */\n\n  /* Initially allocated colormap is saved here */\n  _JSAMPARRAY sv_colormap;      /* The color map as a 2-D pixel array */\n  int sv_actual;                /* number of entries in use */\n\n  _JSAMPARRAY colorindex;       /* Precomputed mapping for speed */\n  /* colorindex[i][j] = index of color closest to pixel value j in component i,\n   * premultiplied as described above.  Since colormap indexes must fit into\n   * _JSAMPLEs, the entries of this array will too.\n   */\n  boolean is_padded;            /* is the colorindex padded for odither? */\n\n  int Ncolors[MAX_Q_COMPS];     /* # of values allocated to each component */\n\n  /* Variables for ordered dithering */\n  int row_index;                /* cur row's vertical index in dither matrix */\n  ODITHER_MATRIX_PTR odither[MAX_Q_COMPS]; /* one dither array per component */\n\n  /* Variables for Floyd-Steinberg dithering */\n  FSERRPTR fserrors[MAX_Q_COMPS]; /* accumulated errors */\n  boolean on_odd_row;           /* flag to remember which row we are on */\n} my_cquantizer;\n\ntypedef my_cquantizer *my_cquantize_ptr;\n\n\n/*\n * Policy-making subroutines for create_colormap and create_colorindex.\n * These routines determine the colormap to be used.  The rest of the module\n * only assumes that the colormap is orthogonal.\n *\n *  * select_ncolors decides how to divvy up the available colors\n *    among the components.\n *  * output_value defines the set of representative values for a component.\n *  * largest_input_value defines the mapping from input values to\n *    representative values for a component.\n * Note that the latter two routines may impose different policies for\n * different components, though this is not currently done.\n */\n\n\nLOCAL(int)\nselect_ncolors(j_decompress_ptr cinfo, int Ncolors[])\n/* Determine allocation of desired colors to components, */\n/* and fill in Ncolors[] array to indicate choice. */\n/* Return value is total number of colors (product of Ncolors[] values). */\n{\n  int nc = cinfo->out_color_components; /* number of color components */\n  int max_colors = cinfo->desired_number_of_colors;\n  int total_colors, iroot, i, j;\n  boolean changed;\n  long temp;\n  int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };\n  RGB_order[0] = rgb_green[cinfo->out_color_space];\n  RGB_order[1] = rgb_red[cinfo->out_color_space];\n  RGB_order[2] = rgb_blue[cinfo->out_color_space];\n\n  /* We can allocate at least the nc'th root of max_colors per component. */\n  /* Compute floor(nc'th root of max_colors). */\n  iroot = 1;\n  do {\n    iroot++;\n    temp = iroot;               /* set temp = iroot ** nc */\n    for (i = 1; i < nc; i++)\n      temp *= iroot;\n  } while (temp <= (long)max_colors); /* repeat till iroot exceeds root */\n  iroot--;                      /* now iroot = floor(root) */\n\n  /* Must have at least 2 color values per component */\n  if (iroot < 2)\n    ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int)temp);\n\n  /* Initialize to iroot color values for each component */\n  total_colors = 1;\n  for (i = 0; i < nc; i++) {\n    Ncolors[i] = iroot;\n    total_colors *= iroot;\n  }\n  /* We may be able to increment the count for one or more components without\n   * exceeding max_colors, though we know not all can be incremented.\n   * Sometimes, the first component can be incremented more than once!\n   * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)\n   * In RGB colorspace, try to increment G first, then R, then B.\n   */\n  do {\n    changed = FALSE;\n    for (i = 0; i < nc; i++) {\n      j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);\n      /* calculate new total_colors if Ncolors[j] is incremented */\n      temp = total_colors / Ncolors[j];\n      temp *= Ncolors[j] + 1;   /* done in long arith to avoid oflo */\n      if (temp > (long)max_colors)\n        break;                  /* won't fit, done with this pass */\n      Ncolors[j]++;             /* OK, apply the increment */\n      total_colors = (int)temp;\n      changed = TRUE;\n    }\n  } while (changed);\n\n  return total_colors;\n}\n\n\nLOCAL(int)\noutput_value(j_decompress_ptr cinfo, int ci, int j, int maxj)\n/* Return j'th output value, where j will range from 0 to maxj */\n/* The output values must fall in 0.._MAXJSAMPLE in increasing order */\n{\n  /* We always provide values 0 and _MAXJSAMPLE for each component;\n   * any additional values are equally spaced between these limits.\n   * (Forcing the upper and lower values to the limits ensures that\n   * dithering can't produce a color outside the selected gamut.)\n   */\n  return (int)(((JLONG)j * _MAXJSAMPLE + maxj / 2) / maxj);\n}\n\n\nLOCAL(int)\nlargest_input_value(j_decompress_ptr cinfo, int ci, int j, int maxj)\n/* Return largest input value that should map to j'th output value */\n/* Must have largest(j=0) >= 0, and largest(j=maxj) >= _MAXJSAMPLE */\n{\n  /* Breakpoints are halfway between values returned by output_value */\n  return (int)(((JLONG)(2 * j + 1) * _MAXJSAMPLE + maxj) / (2 * maxj));\n}\n\n\n/*\n * Create the colormap.\n */\n\nLOCAL(void)\ncreate_colormap(j_decompress_ptr cinfo)\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  _JSAMPARRAY colormap;         /* Created colormap */\n  int total_colors;             /* Number of distinct output colors */\n  int i, j, k, nci, blksize, blkdist, ptr, val;\n\n  /* Select number of colors for each component */\n  total_colors = select_ncolors(cinfo, cquantize->Ncolors);\n\n  /* Report selected color counts */\n  if (cinfo->out_color_components == 3)\n    TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS, total_colors,\n             cquantize->Ncolors[0], cquantize->Ncolors[1],\n             cquantize->Ncolors[2]);\n  else\n    TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);\n\n  /* Allocate and fill in the colormap. */\n  /* The colors are ordered in the map in standard row-major order, */\n  /* i.e. rightmost (highest-indexed) color changes most rapidly. */\n\n  colormap = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE,\n     (JDIMENSION)total_colors, (JDIMENSION)cinfo->out_color_components);\n\n  /* blksize is number of adjacent repeated entries for a component */\n  /* blkdist is distance between groups of identical entries for a component */\n  blkdist = total_colors;\n\n  for (i = 0; i < cinfo->out_color_components; i++) {\n    /* fill in colormap entries for i'th color component */\n    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */\n    blksize = blkdist / nci;\n    for (j = 0; j < nci; j++) {\n      /* Compute j'th output value (out of nci) for component */\n      val = output_value(cinfo, i, j, nci - 1);\n      /* Fill in all colormap entries that have this value of this component */\n      for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {\n        /* fill in blksize entries beginning at ptr */\n        for (k = 0; k < blksize; k++)\n          colormap[i][ptr + k] = (_JSAMPLE)val;\n      }\n    }\n    blkdist = blksize;          /* blksize of this color is blkdist of next */\n  }\n\n  /* Save the colormap in private storage,\n   * where it will survive color quantization mode changes.\n   */\n  cquantize->sv_colormap = colormap;\n  cquantize->sv_actual = total_colors;\n}\n\n\n/*\n * Create the color index table.\n */\n\nLOCAL(void)\ncreate_colorindex(j_decompress_ptr cinfo)\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  _JSAMPROW indexptr;\n  int i, j, k, nci, blksize, val, pad;\n\n  /* For ordered dither, we pad the color index tables by _MAXJSAMPLE in\n   * each direction (input index values can be -_MAXJSAMPLE .. 2*_MAXJSAMPLE).\n   * This is not necessary in the other dithering modes.  However, we\n   * flag whether it was done in case user changes dithering mode.\n   */\n  if (cinfo->dither_mode == JDITHER_ORDERED) {\n    pad = _MAXJSAMPLE * 2;\n    cquantize->is_padded = TRUE;\n  } else {\n    pad = 0;\n    cquantize->is_padded = FALSE;\n  }\n\n  cquantize->colorindex = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE,\n     (JDIMENSION)(_MAXJSAMPLE + 1 + pad),\n     (JDIMENSION)cinfo->out_color_components);\n\n  /* blksize is number of adjacent repeated entries for a component */\n  blksize = cquantize->sv_actual;\n\n  for (i = 0; i < cinfo->out_color_components; i++) {\n    /* fill in colorindex entries for i'th color component */\n    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */\n    blksize = blksize / nci;\n\n    /* adjust colorindex pointers to provide padding at negative indexes. */\n    if (pad)\n      cquantize->colorindex[i] += _MAXJSAMPLE;\n\n    /* in loop, val = index of current output value, */\n    /* and k = largest j that maps to current val */\n    indexptr = cquantize->colorindex[i];\n    val = 0;\n    k = largest_input_value(cinfo, i, 0, nci - 1);\n    for (j = 0; j <= _MAXJSAMPLE; j++) {\n      while (j > k)             /* advance val if past boundary */\n        k = largest_input_value(cinfo, i, ++val, nci - 1);\n      /* premultiply so that no multiplication needed in main processing */\n      indexptr[j] = (_JSAMPLE)(val * blksize);\n    }\n    /* Pad at both ends if necessary */\n    if (pad)\n      for (j = 1; j <= _MAXJSAMPLE; j++) {\n        indexptr[-j] = indexptr[0];\n        indexptr[_MAXJSAMPLE + j] = indexptr[_MAXJSAMPLE];\n      }\n  }\n}\n\n\n/*\n * Create an ordered-dither array for a component having ncolors\n * distinct output values.\n */\n\nLOCAL(ODITHER_MATRIX_PTR)\nmake_odither_array(j_decompress_ptr cinfo, int ncolors)\n{\n  ODITHER_MATRIX_PTR odither;\n  int j, k;\n  JLONG num, den;\n\n  odither = (ODITHER_MATRIX_PTR)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(ODITHER_MATRIX));\n  /* The inter-value distance for this color is _MAXJSAMPLE/(ncolors-1).\n   * Hence the dither value for the matrix cell with fill order f\n   * (f=0..N-1) should be (N-1-2*f)/(2*N) * _MAXJSAMPLE/(ncolors-1).\n   * On 16-bit-int machine, be careful to avoid overflow.\n   */\n  den = 2 * ODITHER_CELLS * ((JLONG)(ncolors - 1));\n  for (j = 0; j < ODITHER_SIZE; j++) {\n    for (k = 0; k < ODITHER_SIZE; k++) {\n      num = ((JLONG)(ODITHER_CELLS - 1 -\n                     2 * ((int)base_dither_matrix[j][k]))) * _MAXJSAMPLE;\n      /* Ensure round towards zero despite C's lack of consistency\n       * about rounding negative values in integer division...\n       */\n      odither[j][k] = (int)(num < 0 ? -((-num) / den) : num / den);\n    }\n  }\n  return odither;\n}\n\n\n/*\n * Create the ordered-dither tables.\n * Components having the same number of representative colors may\n * share a dither table.\n */\n\nLOCAL(void)\ncreate_odither_tables(j_decompress_ptr cinfo)\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  ODITHER_MATRIX_PTR odither;\n  int i, j, nci;\n\n  for (i = 0; i < cinfo->out_color_components; i++) {\n    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */\n    odither = NULL;             /* search for matching prior component */\n    for (j = 0; j < i; j++) {\n      if (nci == cquantize->Ncolors[j]) {\n        odither = cquantize->odither[j];\n        break;\n      }\n    }\n    if (odither == NULL)        /* need a new table? */\n      odither = make_odither_array(cinfo, nci);\n    cquantize->odither[i] = odither;\n  }\n}\n\n\n/*\n * Map some rows of pixels to the output colormapped representation.\n */\n\nMETHODDEF(void)\ncolor_quantize(j_decompress_ptr cinfo, _JSAMPARRAY input_buf,\n               _JSAMPARRAY output_buf, int num_rows)\n/* General case, no dithering */\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  _JSAMPARRAY colorindex = cquantize->colorindex;\n  register int pixcode, ci;\n  register _JSAMPROW ptrin, ptrout;\n  int row;\n  JDIMENSION col;\n  JDIMENSION width = cinfo->output_width;\n  register int nc = cinfo->out_color_components;\n\n  for (row = 0; row < num_rows; row++) {\n    ptrin = input_buf[row];\n    ptrout = output_buf[row];\n    for (col = width; col > 0; col--) {\n      pixcode = 0;\n      for (ci = 0; ci < nc; ci++) {\n        pixcode += colorindex[ci][*ptrin++];\n      }\n      *ptrout++ = (_JSAMPLE)pixcode;\n    }\n  }\n}\n\n\nMETHODDEF(void)\ncolor_quantize3(j_decompress_ptr cinfo, _JSAMPARRAY input_buf,\n                _JSAMPARRAY output_buf, int num_rows)\n/* Fast path for out_color_components==3, no dithering */\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  register int pixcode;\n  register _JSAMPROW ptrin, ptrout;\n  _JSAMPROW colorindex0 = cquantize->colorindex[0];\n  _JSAMPROW colorindex1 = cquantize->colorindex[1];\n  _JSAMPROW colorindex2 = cquantize->colorindex[2];\n  int row;\n  JDIMENSION col;\n  JDIMENSION width = cinfo->output_width;\n\n  for (row = 0; row < num_rows; row++) {\n    ptrin = input_buf[row];\n    ptrout = output_buf[row];\n    for (col = width; col > 0; col--) {\n      pixcode  = colorindex0[*ptrin++];\n      pixcode += colorindex1[*ptrin++];\n      pixcode += colorindex2[*ptrin++];\n      *ptrout++ = (_JSAMPLE)pixcode;\n    }\n  }\n}\n\n\nMETHODDEF(void)\nquantize_ord_dither(j_decompress_ptr cinfo, _JSAMPARRAY input_buf,\n                    _JSAMPARRAY output_buf, int num_rows)\n/* General case, with ordered dithering */\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  register _JSAMPROW input_ptr;\n  register _JSAMPROW output_ptr;\n  _JSAMPROW colorindex_ci;\n  int *dither;                  /* points to active row of dither matrix */\n  int row_index, col_index;     /* current indexes into dither matrix */\n  int nc = cinfo->out_color_components;\n  int ci;\n  int row;\n  JDIMENSION col;\n  JDIMENSION width = cinfo->output_width;\n\n  for (row = 0; row < num_rows; row++) {\n    /* Initialize output values to 0 so can process components separately */\n    jzero_far((void *)output_buf[row], (size_t)(width * sizeof(_JSAMPLE)));\n    row_index = cquantize->row_index;\n    for (ci = 0; ci < nc; ci++) {\n      input_ptr = input_buf[row] + ci;\n      output_ptr = output_buf[row];\n      colorindex_ci = cquantize->colorindex[ci];\n      dither = cquantize->odither[ci][row_index];\n      col_index = 0;\n\n      for (col = width; col > 0; col--) {\n        /* Form pixel value + dither, range-limit to 0.._MAXJSAMPLE,\n         * select output value, accumulate into output code for this pixel.\n         * Range-limiting need not be done explicitly, as we have extended\n         * the colorindex table to produce the right answers for out-of-range\n         * inputs.  The maximum dither is +- _MAXJSAMPLE; this sets the\n         * required amount of padding.\n         */\n        *output_ptr +=\n          colorindex_ci[*input_ptr + dither[col_index]];\n        input_ptr += nc;\n        output_ptr++;\n        col_index = (col_index + 1) & ODITHER_MASK;\n      }\n    }\n    /* Advance row index for next row */\n    row_index = (row_index + 1) & ODITHER_MASK;\n    cquantize->row_index = row_index;\n  }\n}\n\n\nMETHODDEF(void)\nquantize3_ord_dither(j_decompress_ptr cinfo, _JSAMPARRAY input_buf,\n                     _JSAMPARRAY output_buf, int num_rows)\n/* Fast path for out_color_components==3, with ordered dithering */\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  register int pixcode;\n  register _JSAMPROW input_ptr;\n  register _JSAMPROW output_ptr;\n  _JSAMPROW colorindex0 = cquantize->colorindex[0];\n  _JSAMPROW colorindex1 = cquantize->colorindex[1];\n  _JSAMPROW colorindex2 = cquantize->colorindex[2];\n  int *dither0;                 /* points to active row of dither matrix */\n  int *dither1;\n  int *dither2;\n  int row_index, col_index;     /* current indexes into dither matrix */\n  int row;\n  JDIMENSION col;\n  JDIMENSION width = cinfo->output_width;\n\n  for (row = 0; row < num_rows; row++) {\n    row_index = cquantize->row_index;\n    input_ptr = input_buf[row];\n    output_ptr = output_buf[row];\n    dither0 = cquantize->odither[0][row_index];\n    dither1 = cquantize->odither[1][row_index];\n    dither2 = cquantize->odither[2][row_index];\n    col_index = 0;\n\n    for (col = width; col > 0; col--) {\n      pixcode  = colorindex0[(*input_ptr++) + dither0[col_index]];\n      pixcode += colorindex1[(*input_ptr++) + dither1[col_index]];\n      pixcode += colorindex2[(*input_ptr++) + dither2[col_index]];\n      *output_ptr++ = (_JSAMPLE)pixcode;\n      col_index = (col_index + 1) & ODITHER_MASK;\n    }\n    row_index = (row_index + 1) & ODITHER_MASK;\n    cquantize->row_index = row_index;\n  }\n}\n\n\nMETHODDEF(void)\nquantize_fs_dither(j_decompress_ptr cinfo, _JSAMPARRAY input_buf,\n                   _JSAMPARRAY output_buf, int num_rows)\n/* General case, with Floyd-Steinberg dithering */\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  register LOCFSERROR cur;      /* current error or pixel value */\n  LOCFSERROR belowerr;          /* error for pixel below cur */\n  LOCFSERROR bpreverr;          /* error for below/prev col */\n  LOCFSERROR bnexterr;          /* error for below/next col */\n  LOCFSERROR delta;\n  register FSERRPTR errorptr;   /* => fserrors[] at column before current */\n  register _JSAMPROW input_ptr;\n  register _JSAMPROW output_ptr;\n  _JSAMPROW colorindex_ci;\n  _JSAMPROW colormap_ci;\n  int pixcode;\n  int nc = cinfo->out_color_components;\n  int dir;                      /* 1 for left-to-right, -1 for right-to-left */\n  int dirnc;                    /* dir * nc */\n  int ci;\n  int row;\n  JDIMENSION col;\n  JDIMENSION width = cinfo->output_width;\n  _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  SHIFT_TEMPS\n\n  for (row = 0; row < num_rows; row++) {\n    /* Initialize output values to 0 so can process components separately */\n    jzero_far((void *)output_buf[row], (size_t)(width * sizeof(_JSAMPLE)));\n    for (ci = 0; ci < nc; ci++) {\n      input_ptr = input_buf[row] + ci;\n      output_ptr = output_buf[row];\n      if (cquantize->on_odd_row) {\n        /* work right to left in this row */\n        input_ptr += (width - 1) * nc; /* so point to rightmost pixel */\n        output_ptr += width - 1;\n        dir = -1;\n        dirnc = -nc;\n        errorptr = cquantize->fserrors[ci] + (width + 1); /* => entry after last column */\n      } else {\n        /* work left to right in this row */\n        dir = 1;\n        dirnc = nc;\n        errorptr = cquantize->fserrors[ci]; /* => entry before first column */\n      }\n      colorindex_ci = cquantize->colorindex[ci];\n      colormap_ci = cquantize->sv_colormap[ci];\n      /* Preset error values: no error propagated to first pixel from left */\n      cur = 0;\n      /* and no error propagated to row below yet */\n      belowerr = bpreverr = 0;\n\n      for (col = width; col > 0; col--) {\n        /* cur holds the error propagated from the previous pixel on the\n         * current line.  Add the error propagated from the previous line\n         * to form the complete error correction term for this pixel, and\n         * round the error term (which is expressed * 16) to an integer.\n         * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct\n         * for either sign of the error value.\n         * Note: errorptr points to *previous* column's array entry.\n         */\n        cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);\n        /* Form pixel value + error, and range-limit to 0.._MAXJSAMPLE.\n         * The maximum error is +- _MAXJSAMPLE; this sets the required size\n         * of the range_limit array.\n         */\n        cur += *input_ptr;\n        cur = range_limit[cur];\n        /* Select output value, accumulate into output code for this pixel */\n        pixcode = colorindex_ci[cur];\n        *output_ptr += (_JSAMPLE)pixcode;\n        /* Compute actual representation error at this pixel */\n        /* Note: we can do this even though we don't have the final */\n        /* pixel code, because the colormap is orthogonal. */\n        cur -= colormap_ci[pixcode];\n        /* Compute error fractions to be propagated to adjacent pixels.\n         * Add these into the running sums, and simultaneously shift the\n         * next-line error sums left by 1 column.\n         */\n        bnexterr = cur;\n        delta = cur * 2;\n        cur += delta;           /* form error * 3 */\n        errorptr[0] = (FSERROR)(bpreverr + cur);\n        cur += delta;           /* form error * 5 */\n        bpreverr = belowerr + cur;\n        belowerr = bnexterr;\n        cur += delta;           /* form error * 7 */\n        /* At this point cur contains the 7/16 error value to be propagated\n         * to the next pixel on the current line, and all the errors for the\n         * next line have been shifted over. We are therefore ready to move on.\n         */\n        input_ptr += dirnc;     /* advance input ptr to next column */\n        output_ptr += dir;      /* advance output ptr to next column */\n        errorptr += dir;        /* advance errorptr to current column */\n      }\n      /* Post-loop cleanup: we must unload the final error value into the\n       * final fserrors[] entry.  Note we need not unload belowerr because\n       * it is for the dummy column before or after the actual array.\n       */\n      errorptr[0] = (FSERROR)bpreverr; /* unload prev err into array */\n    }\n    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);\n  }\n}\n\n\n/*\n * Allocate workspace for Floyd-Steinberg errors.\n */\n\nLOCAL(void)\nalloc_fs_workspace(j_decompress_ptr cinfo)\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  size_t arraysize;\n  int i;\n\n  arraysize = (size_t)((cinfo->output_width + 2) * sizeof(FSERROR));\n  for (i = 0; i < cinfo->out_color_components; i++) {\n    cquantize->fserrors[i] = (FSERRPTR)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE, arraysize);\n  }\n}\n\n\n/*\n * Initialize for one-pass color quantization.\n */\n\nMETHODDEF(void)\nstart_pass_1_quant(j_decompress_ptr cinfo, boolean is_pre_scan)\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  size_t arraysize;\n  int i;\n\n  /* Install my colormap. */\n  cinfo->colormap = (JSAMPARRAY)cquantize->sv_colormap;\n  cinfo->actual_number_of_colors = cquantize->sv_actual;\n\n  /* Initialize for desired dithering mode. */\n  switch (cinfo->dither_mode) {\n  case JDITHER_NONE:\n    if (cinfo->out_color_components == 3)\n      cquantize->pub._color_quantize = color_quantize3;\n    else\n      cquantize->pub._color_quantize = color_quantize;\n    break;\n  case JDITHER_ORDERED:\n    if (cinfo->out_color_components == 3)\n      cquantize->pub._color_quantize = quantize3_ord_dither;\n    else\n      cquantize->pub._color_quantize = quantize_ord_dither;\n    cquantize->row_index = 0;   /* initialize state for ordered dither */\n    /* If user changed to ordered dither from another mode,\n     * we must recreate the color index table with padding.\n     * This will cost extra space, but probably isn't very likely.\n     */\n    if (!cquantize->is_padded)\n      create_colorindex(cinfo);\n    /* Create ordered-dither tables if we didn't already. */\n    if (cquantize->odither[0] == NULL)\n      create_odither_tables(cinfo);\n    break;\n  case JDITHER_FS:\n    cquantize->pub._color_quantize = quantize_fs_dither;\n    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */\n    /* Allocate Floyd-Steinberg workspace if didn't already. */\n    if (cquantize->fserrors[0] == NULL)\n      alloc_fs_workspace(cinfo);\n    /* Initialize the propagated errors to zero. */\n    arraysize = (size_t)((cinfo->output_width + 2) * sizeof(FSERROR));\n    for (i = 0; i < cinfo->out_color_components; i++)\n      jzero_far((void *)cquantize->fserrors[i], arraysize);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_NOT_COMPILED);\n    break;\n  }\n}\n\n\n/*\n * Finish up at the end of the pass.\n */\n\nMETHODDEF(void)\nfinish_pass_1_quant(j_decompress_ptr cinfo)\n{\n  /* no work in 1-pass case */\n}\n\n\n/*\n * Switch to a new external colormap between output passes.\n * Shouldn't get to this module!\n */\n\nMETHODDEF(void)\nnew_color_map_1_quant(j_decompress_ptr cinfo)\n{\n  ERREXIT(cinfo, JERR_MODE_CHANGE);\n}\n\n\n/*\n * Module initialization routine for 1-pass color quantization.\n */\n\nGLOBAL(void)\n_jinit_1pass_quantizer(j_decompress_ptr cinfo)\n{\n  my_cquantize_ptr cquantize;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Color quantization is not supported with lossless JPEG images */\n  if (cinfo->master->lossless)\n    ERREXIT(cinfo, JERR_NOTIMPL);\n\n  cquantize = (my_cquantize_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_cquantizer));\n  cinfo->cquantize = (struct jpeg_color_quantizer *)cquantize;\n  cquantize->pub.start_pass = start_pass_1_quant;\n  cquantize->pub.finish_pass = finish_pass_1_quant;\n  cquantize->pub.new_color_map = new_color_map_1_quant;\n  cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */\n  cquantize->odither[0] = NULL; /* Also flag odither arrays not allocated */\n\n  /* Make sure my internal arrays won't overflow */\n  if (cinfo->out_color_components > MAX_Q_COMPS)\n    ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);\n  /* Make sure colormap indexes can be represented by _JSAMPLEs */\n  if (cinfo->desired_number_of_colors > (_MAXJSAMPLE + 1))\n    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, _MAXJSAMPLE + 1);\n\n  /* Create the colormap and color index table. */\n  create_colormap(cinfo);\n  create_colorindex(cinfo);\n\n  /* Allocate Floyd-Steinberg workspace now if requested.\n   * We do this now since it may affect the memory manager's space\n   * calculations.  If the user changes to FS dither mode in a later pass, we\n   * will allocate the space then, and will possibly overrun the\n   * max_memory_to_use setting.\n   */\n  if (cinfo->dither_mode == JDITHER_FS)\n    alloc_fs_workspace(cinfo);\n}\n\n#endif /* defined(QUANT_1PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16 */\n"
        },
        {
          "name": "jquant2.c",
          "type": "blob",
          "size": 48.1171875,
          "content": "/*\n * jquant2.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2009, 2014-2015, 2020, 2022-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains 2-pass color quantization (color mapping) routines.\n * These routines provide selection of a custom color map for an image,\n * followed by mapping of the image to that color map, with optional\n * Floyd-Steinberg dithering.\n * It is also possible to use just the second pass to map to an arbitrary\n * externally-given color map.\n *\n * Note: ordered dithering is not supported, since there isn't any fast\n * way to compute intercolor distances; it's unclear that ordered dither's\n * fundamental assumptions even hold with an irregularly spaced color map.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n\n#if defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16\n\n\n/*\n * This module implements the well-known Heckbert paradigm for color\n * quantization.  Most of the ideas used here can be traced back to\n * Heckbert's seminal paper\n *   Heckbert, Paul.  \"Color Image Quantization for Frame Buffer Display\",\n *   Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.\n *\n * In the first pass over the image, we accumulate a histogram showing the\n * usage count of each possible color.  To keep the histogram to a reasonable\n * size, we reduce the precision of the input; typical practice is to retain\n * 5 or 6 bits per color, so that 8 or 4 different input values are counted\n * in the same histogram cell.\n *\n * Next, the color-selection step begins with a box representing the whole\n * color space, and repeatedly splits the \"largest\" remaining box until we\n * have as many boxes as desired colors.  Then the mean color in each\n * remaining box becomes one of the possible output colors.\n *\n * The second pass over the image maps each input pixel to the closest output\n * color (optionally after applying a Floyd-Steinberg dithering correction).\n * This mapping is logically trivial, but making it go fast enough requires\n * considerable care.\n *\n * Heckbert-style quantizers vary a good deal in their policies for choosing\n * the \"largest\" box and deciding where to cut it.  The particular policies\n * used here have proved out well in experimental comparisons, but better ones\n * may yet be found.\n *\n * In earlier versions of the IJG code, this module quantized in YCbCr color\n * space, processing the raw upsampled data without a color conversion step.\n * This allowed the color conversion math to be done only once per colormap\n * entry, not once per pixel.  However, that optimization precluded other\n * useful optimizations (such as merging color conversion with upsampling)\n * and it also interfered with desired capabilities such as quantizing to an\n * externally-supplied colormap.  We have therefore abandoned that approach.\n * The present code works in the post-conversion color space, typically RGB.\n *\n * To improve the visual quality of the results, we actually work in scaled\n * RGB space, giving G distances more weight than R, and R in turn more than\n * B.  To do everything in integer math, we must use integer scale factors.\n * The 2/3/1 scale factors used here correspond loosely to the relative\n * weights of the colors in the NTSC grayscale equation.\n * If you want to use this code to quantize a non-RGB color space, you'll\n * probably need to change these scale factors.\n */\n\n#define R_SCALE  2              /* scale R distances by this much */\n#define G_SCALE  3              /* scale G distances by this much */\n#define B_SCALE  1              /* and B by this much */\n\nstatic const int c_scales[3] = { R_SCALE, G_SCALE, B_SCALE };\n#define C0_SCALE  c_scales[rgb_red[cinfo->out_color_space]]\n#define C1_SCALE  c_scales[rgb_green[cinfo->out_color_space]]\n#define C2_SCALE  c_scales[rgb_blue[cinfo->out_color_space]]\n\n/*\n * First we have the histogram data structure and routines for creating it.\n *\n * The number of bits of precision can be adjusted by changing these symbols.\n * We recommend keeping 6 bits for G and 5 each for R and B.\n * If you have plenty of memory and cycles, 6 bits all around gives marginally\n * better results; if you are short of memory, 5 bits all around will save\n * some space but degrade the results.\n * To maintain a fully accurate histogram, we'd need to allocate a \"long\"\n * (preferably unsigned long) for each cell.  In practice this is overkill;\n * we can get by with 16 bits per cell.  Few of the cell counts will overflow,\n * and clamping those that do overflow to the maximum value will give close-\n * enough results.  This reduces the recommended histogram size from 256Kb\n * to 128Kb, which is a useful savings on PC-class machines.\n * (In the second pass the histogram space is re-used for pixel mapping data;\n * in that capacity, each cell must be able to store zero to the number of\n * desired colors.  16 bits/cell is plenty for that too.)\n * Since the JPEG code is intended to run in small memory model on 80x86\n * machines, we can't just allocate the histogram in one chunk.  Instead\n * of a true 3-D array, we use a row of pointers to 2-D arrays.  Each\n * pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and\n * each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.\n */\n\n#define MAXNUMCOLORS  (_MAXJSAMPLE + 1) /* maximum size of colormap */\n\n/* These will do the right thing for either R,G,B or B,G,R color order,\n * but you may not like the results for other color orders.\n */\n#define HIST_C0_BITS  5         /* bits of precision in R/B histogram */\n#define HIST_C1_BITS  6         /* bits of precision in G histogram */\n#define HIST_C2_BITS  5         /* bits of precision in B/R histogram */\n\n/* Number of elements along histogram axes. */\n#define HIST_C0_ELEMS  (1 << HIST_C0_BITS)\n#define HIST_C1_ELEMS  (1 << HIST_C1_BITS)\n#define HIST_C2_ELEMS  (1 << HIST_C2_BITS)\n\n/* These are the amounts to shift an input value to get a histogram index. */\n#define C0_SHIFT  (BITS_IN_JSAMPLE - HIST_C0_BITS)\n#define C1_SHIFT  (BITS_IN_JSAMPLE - HIST_C1_BITS)\n#define C2_SHIFT  (BITS_IN_JSAMPLE - HIST_C2_BITS)\n\n\ntypedef UINT16 histcell;        /* histogram cell; prefer an unsigned type */\n\ntypedef histcell *histptr;      /* for pointers to histogram cells */\n\ntypedef histcell hist1d[HIST_C2_ELEMS]; /* typedefs for the array */\ntypedef hist1d *hist2d;         /* type for the 2nd-level pointers */\ntypedef hist2d *hist3d;         /* type for top-level pointer */\n\n\n/* Declarations for Floyd-Steinberg dithering.\n *\n * Errors are accumulated into the array fserrors[], at a resolution of\n * 1/16th of a pixel count.  The error at a given pixel is propagated\n * to its not-yet-processed neighbors using the standard F-S fractions,\n *              ...     (here)  7/16\n *              3/16    5/16    1/16\n * We work left-to-right on even rows, right-to-left on odd rows.\n *\n * We can get away with a single array (holding one row's worth of errors)\n * by using it to store the current row's errors at pixel columns not yet\n * processed, but the next row's errors at columns already processed.  We\n * need only a few extra variables to hold the errors immediately around the\n * current column.  (If we are lucky, those variables are in registers, but\n * even if not, they're probably cheaper to access than array elements are.)\n *\n * The fserrors[] array has (#columns + 2) entries; the extra entry at\n * each end saves us from special-casing the first and last pixels.\n * Each entry is three values long, one value for each color component.\n */\n\n#if BITS_IN_JSAMPLE == 8\ntypedef INT16 FSERROR;          /* 16 bits should be enough */\ntypedef int LOCFSERROR;         /* use 'int' for calculation temps */\n#else\ntypedef JLONG FSERROR;          /* may need more than 16 bits */\ntypedef JLONG LOCFSERROR;       /* be sure calculation temps are big enough */\n#endif\n\ntypedef FSERROR *FSERRPTR;      /* pointer to error array */\n\n\n/* Private subobject */\n\ntypedef struct {\n  struct jpeg_color_quantizer pub; /* public fields */\n\n  /* Space for the eventually created colormap is stashed here */\n  _JSAMPARRAY sv_colormap;      /* colormap allocated at init time */\n  int desired;                  /* desired # of colors = size of colormap */\n\n  /* Variables for accumulating image statistics */\n  hist3d histogram;             /* pointer to the histogram */\n\n  boolean needs_zeroed;         /* TRUE if next pass must zero histogram */\n\n  /* Variables for Floyd-Steinberg dithering */\n  FSERRPTR fserrors;            /* accumulated errors */\n  boolean on_odd_row;           /* flag to remember which row we are on */\n  int *error_limiter;           /* table for clamping the applied error */\n} my_cquantizer;\n\ntypedef my_cquantizer *my_cquantize_ptr;\n\n\n/*\n * Prescan some rows of pixels.\n * In this module the prescan simply updates the histogram, which has been\n * initialized to zeroes by start_pass.\n * An output_buf parameter is required by the method signature, but no data\n * is actually output (in fact the buffer controller is probably passing a\n * NULL pointer).\n */\n\nMETHODDEF(void)\nprescan_quantize(j_decompress_ptr cinfo, _JSAMPARRAY input_buf,\n                 _JSAMPARRAY output_buf, int num_rows)\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  register _JSAMPROW ptr;\n  register histptr histp;\n  register hist3d histogram = cquantize->histogram;\n  int row;\n  JDIMENSION col;\n  JDIMENSION width = cinfo->output_width;\n\n  for (row = 0; row < num_rows; row++) {\n    ptr = input_buf[row];\n    for (col = width; col > 0; col--) {\n      /* get pixel value and index into the histogram */\n      histp = &histogram[ptr[0] >> C0_SHIFT]\n                        [ptr[1] >> C1_SHIFT]\n                        [ptr[2] >> C2_SHIFT];\n      /* increment, check for overflow and undo increment if so. */\n      if (++(*histp) <= 0)\n        (*histp)--;\n      ptr += 3;\n    }\n  }\n}\n\n\n/*\n * Next we have the really interesting routines: selection of a colormap\n * given the completed histogram.\n * These routines work with a list of \"boxes\", each representing a rectangular\n * subset of the input color space (to histogram precision).\n */\n\ntypedef struct {\n  /* The bounds of the box (inclusive); expressed as histogram indexes */\n  int c0min, c0max;\n  int c1min, c1max;\n  int c2min, c2max;\n  /* The volume (actually 2-norm) of the box */\n  JLONG volume;\n  /* The number of nonzero histogram cells within this box */\n  long colorcount;\n} box;\n\ntypedef box *boxptr;\n\n\nLOCAL(boxptr)\nfind_biggest_color_pop(boxptr boxlist, int numboxes)\n/* Find the splittable box with the largest color population */\n/* Returns NULL if no splittable boxes remain */\n{\n  register boxptr boxp;\n  register int i;\n  register long maxc = 0;\n  boxptr which = NULL;\n\n  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {\n    if (boxp->colorcount > maxc && boxp->volume > 0) {\n      which = boxp;\n      maxc = boxp->colorcount;\n    }\n  }\n  return which;\n}\n\n\nLOCAL(boxptr)\nfind_biggest_volume(boxptr boxlist, int numboxes)\n/* Find the splittable box with the largest (scaled) volume */\n/* Returns NULL if no splittable boxes remain */\n{\n  register boxptr boxp;\n  register int i;\n  register JLONG maxv = 0;\n  boxptr which = NULL;\n\n  for (i = 0, boxp = boxlist; i < numboxes; i++, boxp++) {\n    if (boxp->volume > maxv) {\n      which = boxp;\n      maxv = boxp->volume;\n    }\n  }\n  return which;\n}\n\n\nLOCAL(void)\nupdate_box(j_decompress_ptr cinfo, boxptr boxp)\n/* Shrink the min/max bounds of a box to enclose only nonzero elements, */\n/* and recompute its volume and population */\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  hist3d histogram = cquantize->histogram;\n  histptr histp;\n  int c0, c1, c2;\n  int c0min, c0max, c1min, c1max, c2min, c2max;\n  JLONG dist0, dist1, dist2;\n  long ccount;\n\n  c0min = boxp->c0min;  c0max = boxp->c0max;\n  c1min = boxp->c1min;  c1max = boxp->c1max;\n  c2min = boxp->c2min;  c2max = boxp->c2max;\n\n  if (c0max > c0min)\n    for (c0 = c0min; c0 <= c0max; c0++)\n      for (c1 = c1min; c1 <= c1max; c1++) {\n        histp = &histogram[c0][c1][c2min];\n        for (c2 = c2min; c2 <= c2max; c2++)\n          if (*histp++ != 0) {\n            boxp->c0min = c0min = c0;\n            goto have_c0min;\n          }\n      }\nhave_c0min:\n  if (c0max > c0min)\n    for (c0 = c0max; c0 >= c0min; c0--)\n      for (c1 = c1min; c1 <= c1max; c1++) {\n        histp = &histogram[c0][c1][c2min];\n        for (c2 = c2min; c2 <= c2max; c2++)\n          if (*histp++ != 0) {\n            boxp->c0max = c0max = c0;\n            goto have_c0max;\n          }\n      }\nhave_c0max:\n  if (c1max > c1min)\n    for (c1 = c1min; c1 <= c1max; c1++)\n      for (c0 = c0min; c0 <= c0max; c0++) {\n        histp = &histogram[c0][c1][c2min];\n        for (c2 = c2min; c2 <= c2max; c2++)\n          if (*histp++ != 0) {\n            boxp->c1min = c1min = c1;\n            goto have_c1min;\n          }\n      }\nhave_c1min:\n  if (c1max > c1min)\n    for (c1 = c1max; c1 >= c1min; c1--)\n      for (c0 = c0min; c0 <= c0max; c0++) {\n        histp = &histogram[c0][c1][c2min];\n        for (c2 = c2min; c2 <= c2max; c2++)\n          if (*histp++ != 0) {\n            boxp->c1max = c1max = c1;\n            goto have_c1max;\n          }\n      }\nhave_c1max:\n  if (c2max > c2min)\n    for (c2 = c2min; c2 <= c2max; c2++)\n      for (c0 = c0min; c0 <= c0max; c0++) {\n        histp = &histogram[c0][c1min][c2];\n        for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)\n          if (*histp != 0) {\n            boxp->c2min = c2min = c2;\n            goto have_c2min;\n          }\n      }\nhave_c2min:\n  if (c2max > c2min)\n    for (c2 = c2max; c2 >= c2min; c2--)\n      for (c0 = c0min; c0 <= c0max; c0++) {\n        histp = &histogram[c0][c1min][c2];\n        for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)\n          if (*histp != 0) {\n            boxp->c2max = c2max = c2;\n            goto have_c2max;\n          }\n      }\nhave_c2max:\n\n  /* Update box volume.\n   * We use 2-norm rather than real volume here; this biases the method\n   * against making long narrow boxes, and it has the side benefit that\n   * a box is splittable iff norm > 0.\n   * Since the differences are expressed in histogram-cell units,\n   * we have to shift back to _JSAMPLE units to get consistent distances;\n   * after which, we scale according to the selected distance scale factors.\n   */\n  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;\n  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;\n  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;\n  boxp->volume = dist0 * dist0 + dist1 * dist1 + dist2 * dist2;\n\n  /* Now scan remaining volume of box and compute population */\n  ccount = 0;\n  for (c0 = c0min; c0 <= c0max; c0++)\n    for (c1 = c1min; c1 <= c1max; c1++) {\n      histp = &histogram[c0][c1][c2min];\n      for (c2 = c2min; c2 <= c2max; c2++, histp++)\n        if (*histp != 0) {\n          ccount++;\n        }\n    }\n  boxp->colorcount = ccount;\n}\n\n\nLOCAL(int)\nmedian_cut(j_decompress_ptr cinfo, boxptr boxlist, int numboxes,\n           int desired_colors)\n/* Repeatedly select and split the largest box until we have enough boxes */\n{\n  int n, lb;\n  int c0, c1, c2, cmax;\n  register boxptr b1, b2;\n\n  while (numboxes < desired_colors) {\n    /* Select box to split.\n     * Current algorithm: by population for first half, then by volume.\n     */\n    if (numboxes * 2 <= desired_colors) {\n      b1 = find_biggest_color_pop(boxlist, numboxes);\n    } else {\n      b1 = find_biggest_volume(boxlist, numboxes);\n    }\n    if (b1 == NULL)             /* no splittable boxes left! */\n      break;\n    b2 = &boxlist[numboxes];    /* where new box will go */\n    /* Copy the color bounds to the new box. */\n    b2->c0max = b1->c0max;  b2->c1max = b1->c1max;  b2->c2max = b1->c2max;\n    b2->c0min = b1->c0min;  b2->c1min = b1->c1min;  b2->c2min = b1->c2min;\n    /* Choose which axis to split the box on.\n     * Current algorithm: longest scaled axis.\n     * See notes in update_box about scaling distances.\n     */\n    c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;\n    c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;\n    c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;\n    /* We want to break any ties in favor of green, then red, blue last.\n     * This code does the right thing for R,G,B or B,G,R color orders only.\n     */\n    if (rgb_red[cinfo->out_color_space] == 0) {\n      cmax = c1;  n = 1;\n      if (c0 > cmax) { cmax = c0;  n = 0; }\n      if (c2 > cmax) { n = 2; }\n    } else {\n      cmax = c1;  n = 1;\n      if (c2 > cmax) { cmax = c2;  n = 2; }\n      if (c0 > cmax) { n = 0; }\n    }\n    /* Choose split point along selected axis, and update box bounds.\n     * Current algorithm: split at halfway point.\n     * (Since the box has been shrunk to minimum volume,\n     * any split will produce two nonempty subboxes.)\n     * Note that lb value is max for lower box, so must be < old max.\n     */\n    switch (n) {\n    case 0:\n      lb = (b1->c0max + b1->c0min) / 2;\n      b1->c0max = lb;\n      b2->c0min = lb + 1;\n      break;\n    case 1:\n      lb = (b1->c1max + b1->c1min) / 2;\n      b1->c1max = lb;\n      b2->c1min = lb + 1;\n      break;\n    case 2:\n      lb = (b1->c2max + b1->c2min) / 2;\n      b1->c2max = lb;\n      b2->c2min = lb + 1;\n      break;\n    }\n    /* Update stats for boxes */\n    update_box(cinfo, b1);\n    update_box(cinfo, b2);\n    numboxes++;\n  }\n  return numboxes;\n}\n\n\nLOCAL(void)\ncompute_color(j_decompress_ptr cinfo, boxptr boxp, int icolor)\n/* Compute representative color for a box, put it in colormap[icolor] */\n{\n  /* Current algorithm: mean weighted by pixels (not colors) */\n  /* Note it is important to get the rounding correct! */\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  hist3d histogram = cquantize->histogram;\n  histptr histp;\n  int c0, c1, c2;\n  int c0min, c0max, c1min, c1max, c2min, c2max;\n  long count;\n  long total = 0;\n  long c0total = 0;\n  long c1total = 0;\n  long c2total = 0;\n\n  c0min = boxp->c0min;  c0max = boxp->c0max;\n  c1min = boxp->c1min;  c1max = boxp->c1max;\n  c2min = boxp->c2min;  c2max = boxp->c2max;\n\n  for (c0 = c0min; c0 <= c0max; c0++)\n    for (c1 = c1min; c1 <= c1max; c1++) {\n      histp = &histogram[c0][c1][c2min];\n      for (c2 = c2min; c2 <= c2max; c2++) {\n        if ((count = *histp++) != 0) {\n          total += count;\n          c0total += ((c0 << C0_SHIFT) + ((1 << C0_SHIFT) >> 1)) * count;\n          c1total += ((c1 << C1_SHIFT) + ((1 << C1_SHIFT) >> 1)) * count;\n          c2total += ((c2 << C2_SHIFT) + ((1 << C2_SHIFT) >> 1)) * count;\n        }\n      }\n    }\n\n  ((_JSAMPARRAY)cinfo->colormap)[0][icolor] =\n    (_JSAMPLE)((c0total + (total >> 1)) / total);\n  ((_JSAMPARRAY)cinfo->colormap)[1][icolor] =\n    (_JSAMPLE)((c1total + (total >> 1)) / total);\n  ((_JSAMPARRAY)cinfo->colormap)[2][icolor] =\n    (_JSAMPLE)((c2total + (total >> 1)) / total);\n}\n\n\nLOCAL(void)\nselect_colors(j_decompress_ptr cinfo, int desired_colors)\n/* Master routine for color selection */\n{\n  boxptr boxlist;\n  int numboxes;\n  int i;\n\n  /* Allocate workspace for box list */\n  boxlist = (boxptr)(*cinfo->mem->alloc_small)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE, desired_colors * sizeof(box));\n  /* Initialize one box containing whole space */\n  numboxes = 1;\n  boxlist[0].c0min = 0;\n  boxlist[0].c0max = _MAXJSAMPLE >> C0_SHIFT;\n  boxlist[0].c1min = 0;\n  boxlist[0].c1max = _MAXJSAMPLE >> C1_SHIFT;\n  boxlist[0].c2min = 0;\n  boxlist[0].c2max = _MAXJSAMPLE >> C2_SHIFT;\n  /* Shrink it to actually-used volume and set its statistics */\n  update_box(cinfo, &boxlist[0]);\n  /* Perform median-cut to produce final box list */\n  numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);\n  /* Compute the representative color for each box, fill colormap */\n  for (i = 0; i < numboxes; i++)\n    compute_color(cinfo, &boxlist[i], i);\n  cinfo->actual_number_of_colors = numboxes;\n  TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);\n}\n\n\n/*\n * These routines are concerned with the time-critical task of mapping input\n * colors to the nearest color in the selected colormap.\n *\n * We re-use the histogram space as an \"inverse color map\", essentially a\n * cache for the results of nearest-color searches.  All colors within a\n * histogram cell will be mapped to the same colormap entry, namely the one\n * closest to the cell's center.  This may not be quite the closest entry to\n * the actual input color, but it's almost as good.  A zero in the cache\n * indicates we haven't found the nearest color for that cell yet; the array\n * is cleared to zeroes before starting the mapping pass.  When we find the\n * nearest color for a cell, its colormap index plus one is recorded in the\n * cache for future use.  The pass2 scanning routines call fill_inverse_cmap\n * when they need to use an unfilled entry in the cache.\n *\n * Our method of efficiently finding nearest colors is based on the \"locally\n * sorted search\" idea described by Heckbert and on the incremental distance\n * calculation described by Spencer W. Thomas in chapter III.1 of Graphics\n * Gems II (James Arvo, ed.  Academic Press, 1991).  Thomas points out that\n * the distances from a given colormap entry to each cell of the histogram can\n * be computed quickly using an incremental method: the differences between\n * distances to adjacent cells themselves differ by a constant.  This allows a\n * fairly fast implementation of the \"brute force\" approach of computing the\n * distance from every colormap entry to every histogram cell.  Unfortunately,\n * it needs a work array to hold the best-distance-so-far for each histogram\n * cell (because the inner loop has to be over cells, not colormap entries).\n * The work array elements have to be JLONGs, so the work array would need\n * 256Kb at our recommended precision.  This is not feasible in DOS machines.\n *\n * To get around these problems, we apply Thomas' method to compute the\n * nearest colors for only the cells within a small subbox of the histogram.\n * The work array need be only as big as the subbox, so the memory usage\n * problem is solved.  Furthermore, we need not fill subboxes that are never\n * referenced in pass2; many images use only part of the color gamut, so a\n * fair amount of work is saved.  An additional advantage of this\n * approach is that we can apply Heckbert's locality criterion to quickly\n * eliminate colormap entries that are far away from the subbox; typically\n * three-fourths of the colormap entries are rejected by Heckbert's criterion,\n * and we need not compute their distances to individual cells in the subbox.\n * The speed of this approach is heavily influenced by the subbox size: too\n * small means too much overhead, too big loses because Heckbert's criterion\n * can't eliminate as many colormap entries.  Empirically the best subbox\n * size seems to be about 1/512th of the histogram (1/8th in each direction).\n *\n * Thomas' article also describes a refined method which is asymptotically\n * faster than the brute-force method, but it is also far more complex and\n * cannot efficiently be applied to small subboxes.  It is therefore not\n * useful for programs intended to be portable to DOS machines.  On machines\n * with plenty of memory, filling the whole histogram in one shot with Thomas'\n * refined method might be faster than the present code --- but then again,\n * it might not be any faster, and it's certainly more complicated.\n */\n\n\n/* log2(histogram cells in update box) for each axis; this can be adjusted */\n#define BOX_C0_LOG  (HIST_C0_BITS - 3)\n#define BOX_C1_LOG  (HIST_C1_BITS - 3)\n#define BOX_C2_LOG  (HIST_C2_BITS - 3)\n\n#define BOX_C0_ELEMS  (1 << BOX_C0_LOG) /* # of hist cells in update box */\n#define BOX_C1_ELEMS  (1 << BOX_C1_LOG)\n#define BOX_C2_ELEMS  (1 << BOX_C2_LOG)\n\n#define BOX_C0_SHIFT  (C0_SHIFT + BOX_C0_LOG)\n#define BOX_C1_SHIFT  (C1_SHIFT + BOX_C1_LOG)\n#define BOX_C2_SHIFT  (C2_SHIFT + BOX_C2_LOG)\n\n\n/*\n * The next three routines implement inverse colormap filling.  They could\n * all be folded into one big routine, but splitting them up this way saves\n * some stack space (the mindist[] and bestdist[] arrays need not coexist)\n * and may allow some compilers to produce better code by registerizing more\n * inner-loop variables.\n */\n\nLOCAL(int)\nfind_nearby_colors(j_decompress_ptr cinfo, int minc0, int minc1, int minc2,\n                   _JSAMPLE colorlist[])\n/* Locate the colormap entries close enough to an update box to be candidates\n * for the nearest entry to some cell(s) in the update box.  The update box\n * is specified by the center coordinates of its first cell.  The number of\n * candidate colormap entries is returned, and their colormap indexes are\n * placed in colorlist[].\n * This routine uses Heckbert's \"locally sorted search\" criterion to select\n * the colors that need further consideration.\n */\n{\n  int numcolors = cinfo->actual_number_of_colors;\n  int maxc0, maxc1, maxc2;\n  int centerc0, centerc1, centerc2;\n  int i, x, ncolors;\n  JLONG minmaxdist, min_dist, max_dist, tdist;\n  JLONG mindist[MAXNUMCOLORS];  /* min distance to colormap entry i */\n\n  /* Compute true coordinates of update box's upper corner and center.\n   * Actually we compute the coordinates of the center of the upper-corner\n   * histogram cell, which are the upper bounds of the volume we care about.\n   * Note that since \">>\" rounds down, the \"center\" values may be closer to\n   * min than to max; hence comparisons to them must be \"<=\", not \"<\".\n   */\n  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));\n  centerc0 = (minc0 + maxc0) >> 1;\n  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));\n  centerc1 = (minc1 + maxc1) >> 1;\n  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));\n  centerc2 = (minc2 + maxc2) >> 1;\n\n  /* For each color in colormap, find:\n   *  1. its minimum squared-distance to any point in the update box\n   *     (zero if color is within update box);\n   *  2. its maximum squared-distance to any point in the update box.\n   * Both of these can be found by considering only the corners of the box.\n   * We save the minimum distance for each color in mindist[];\n   * only the smallest maximum distance is of interest.\n   */\n  minmaxdist = 0x7FFFFFFFL;\n\n  for (i = 0; i < numcolors; i++) {\n    /* We compute the squared-c0-distance term, then add in the other two. */\n    x = ((_JSAMPARRAY)cinfo->colormap)[0][i];\n    if (x < minc0) {\n      tdist = (x - minc0) * C0_SCALE;\n      min_dist = tdist * tdist;\n      tdist = (x - maxc0) * C0_SCALE;\n      max_dist = tdist * tdist;\n    } else if (x > maxc0) {\n      tdist = (x - maxc0) * C0_SCALE;\n      min_dist = tdist * tdist;\n      tdist = (x - minc0) * C0_SCALE;\n      max_dist = tdist * tdist;\n    } else {\n      /* within cell range so no contribution to min_dist */\n      min_dist = 0;\n      if (x <= centerc0) {\n        tdist = (x - maxc0) * C0_SCALE;\n        max_dist = tdist * tdist;\n      } else {\n        tdist = (x - minc0) * C0_SCALE;\n        max_dist = tdist * tdist;\n      }\n    }\n\n    x = ((_JSAMPARRAY)cinfo->colormap)[1][i];\n    if (x < minc1) {\n      tdist = (x - minc1) * C1_SCALE;\n      min_dist += tdist * tdist;\n      tdist = (x - maxc1) * C1_SCALE;\n      max_dist += tdist * tdist;\n    } else if (x > maxc1) {\n      tdist = (x - maxc1) * C1_SCALE;\n      min_dist += tdist * tdist;\n      tdist = (x - minc1) * C1_SCALE;\n      max_dist += tdist * tdist;\n    } else {\n      /* within cell range so no contribution to min_dist */\n      if (x <= centerc1) {\n        tdist = (x - maxc1) * C1_SCALE;\n        max_dist += tdist * tdist;\n      } else {\n        tdist = (x - minc1) * C1_SCALE;\n        max_dist += tdist * tdist;\n      }\n    }\n\n    x = ((_JSAMPARRAY)cinfo->colormap)[2][i];\n    if (x < minc2) {\n      tdist = (x - minc2) * C2_SCALE;\n      min_dist += tdist * tdist;\n      tdist = (x - maxc2) * C2_SCALE;\n      max_dist += tdist * tdist;\n    } else if (x > maxc2) {\n      tdist = (x - maxc2) * C2_SCALE;\n      min_dist += tdist * tdist;\n      tdist = (x - minc2) * C2_SCALE;\n      max_dist += tdist * tdist;\n    } else {\n      /* within cell range so no contribution to min_dist */\n      if (x <= centerc2) {\n        tdist = (x - maxc2) * C2_SCALE;\n        max_dist += tdist * tdist;\n      } else {\n        tdist = (x - minc2) * C2_SCALE;\n        max_dist += tdist * tdist;\n      }\n    }\n\n    mindist[i] = min_dist;      /* save away the results */\n    if (max_dist < minmaxdist)\n      minmaxdist = max_dist;\n  }\n\n  /* Now we know that no cell in the update box is more than minmaxdist\n   * away from some colormap entry.  Therefore, only colors that are\n   * within minmaxdist of some part of the box need be considered.\n   */\n  ncolors = 0;\n  for (i = 0; i < numcolors; i++) {\n    if (mindist[i] <= minmaxdist)\n      colorlist[ncolors++] = (_JSAMPLE)i;\n  }\n  return ncolors;\n}\n\n\nLOCAL(void)\nfind_best_colors(j_decompress_ptr cinfo, int minc0, int minc1, int minc2,\n                 int numcolors, _JSAMPLE colorlist[], _JSAMPLE bestcolor[])\n/* Find the closest colormap entry for each cell in the update box,\n * given the list of candidate colors prepared by find_nearby_colors.\n * Return the indexes of the closest entries in the bestcolor[] array.\n * This routine uses Thomas' incremental distance calculation method to\n * find the distance from a colormap entry to successive cells in the box.\n */\n{\n  int ic0, ic1, ic2;\n  int i, icolor;\n  register JLONG *bptr;         /* pointer into bestdist[] array */\n  _JSAMPLE *cptr;               /* pointer into bestcolor[] array */\n  JLONG dist0, dist1;           /* initial distance values */\n  register JLONG dist2;         /* current distance in inner loop */\n  JLONG xx0, xx1;               /* distance increments */\n  register JLONG xx2;\n  JLONG inc0, inc1, inc2;       /* initial values for increments */\n  /* This array holds the distance to the nearest-so-far color for each cell */\n  JLONG bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];\n\n  /* Initialize best-distance for each cell of the update box */\n  bptr = bestdist;\n  for (i = BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS - 1; i >= 0; i--)\n    *bptr++ = 0x7FFFFFFFL;\n\n  /* For each color selected by find_nearby_colors,\n   * compute its distance to the center of each cell in the box.\n   * If that's less than best-so-far, update best distance and color number.\n   */\n\n  /* Nominal steps between cell centers (\"x\" in Thomas article) */\n#define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)\n#define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)\n#define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)\n\n  for (i = 0; i < numcolors; i++) {\n    icolor = colorlist[i];\n    /* Compute (square of) distance from minc0/c1/c2 to this color */\n    inc0 = (minc0 - ((_JSAMPARRAY)cinfo->colormap)[0][icolor]) * C0_SCALE;\n    dist0 = inc0 * inc0;\n    inc1 = (minc1 - ((_JSAMPARRAY)cinfo->colormap)[1][icolor]) * C1_SCALE;\n    dist0 += inc1 * inc1;\n    inc2 = (minc2 - ((_JSAMPARRAY)cinfo->colormap)[2][icolor]) * C2_SCALE;\n    dist0 += inc2 * inc2;\n    /* Form the initial difference increments */\n    inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;\n    inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;\n    inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;\n    /* Now loop over all cells in box, updating distance per Thomas method */\n    bptr = bestdist;\n    cptr = bestcolor;\n    xx0 = inc0;\n    for (ic0 = BOX_C0_ELEMS - 1; ic0 >= 0; ic0--) {\n      dist1 = dist0;\n      xx1 = inc1;\n      for (ic1 = BOX_C1_ELEMS - 1; ic1 >= 0; ic1--) {\n        dist2 = dist1;\n        xx2 = inc2;\n        for (ic2 = BOX_C2_ELEMS - 1; ic2 >= 0; ic2--) {\n          if (dist2 < *bptr) {\n            *bptr = dist2;\n            *cptr = (_JSAMPLE)icolor;\n          }\n          dist2 += xx2;\n          xx2 += 2 * STEP_C2 * STEP_C2;\n          bptr++;\n          cptr++;\n        }\n        dist1 += xx1;\n        xx1 += 2 * STEP_C1 * STEP_C1;\n      }\n      dist0 += xx0;\n      xx0 += 2 * STEP_C0 * STEP_C0;\n    }\n  }\n}\n\n\nLOCAL(void)\nfill_inverse_cmap(j_decompress_ptr cinfo, int c0, int c1, int c2)\n/* Fill the inverse-colormap entries in the update box that contains */\n/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */\n/* we can fill as many others as we wish.) */\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  hist3d histogram = cquantize->histogram;\n  int minc0, minc1, minc2;      /* lower left corner of update box */\n  int ic0, ic1, ic2;\n  register _JSAMPLE *cptr;      /* pointer into bestcolor[] array */\n  register histptr cachep;      /* pointer into main cache array */\n  /* This array lists the candidate colormap indexes. */\n  _JSAMPLE colorlist[MAXNUMCOLORS];\n  int numcolors;                /* number of candidate colors */\n  /* This array holds the actually closest colormap index for each cell. */\n  _JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];\n\n  /* Convert cell coordinates to update box ID */\n  c0 >>= BOX_C0_LOG;\n  c1 >>= BOX_C1_LOG;\n  c2 >>= BOX_C2_LOG;\n\n  /* Compute true coordinates of update box's origin corner.\n   * Actually we compute the coordinates of the center of the corner\n   * histogram cell, which are the lower bounds of the volume we care about.\n   */\n  minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);\n  minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);\n  minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);\n\n  /* Determine which colormap entries are close enough to be candidates\n   * for the nearest entry to some cell in the update box.\n   */\n  numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);\n\n  /* Determine the actually nearest colors. */\n  find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,\n                   bestcolor);\n\n  /* Save the best color numbers (plus 1) in the main cache array */\n  c0 <<= BOX_C0_LOG;            /* convert ID back to base cell indexes */\n  c1 <<= BOX_C1_LOG;\n  c2 <<= BOX_C2_LOG;\n  cptr = bestcolor;\n  for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {\n    for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {\n      cachep = &histogram[c0 + ic0][c1 + ic1][c2];\n      for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {\n        *cachep++ = (histcell)((*cptr++) + 1);\n      }\n    }\n  }\n}\n\n\n/*\n * Map some rows of pixels to the output colormapped representation.\n */\n\nMETHODDEF(void)\npass2_no_dither(j_decompress_ptr cinfo, _JSAMPARRAY input_buf,\n                _JSAMPARRAY output_buf, int num_rows)\n/* This version performs no dithering */\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  hist3d histogram = cquantize->histogram;\n  register _JSAMPROW inptr, outptr;\n  register histptr cachep;\n  register int c0, c1, c2;\n  int row;\n  JDIMENSION col;\n  JDIMENSION width = cinfo->output_width;\n\n  for (row = 0; row < num_rows; row++) {\n    inptr = input_buf[row];\n    outptr = output_buf[row];\n    for (col = width; col > 0; col--) {\n      /* get pixel value and index into the cache */\n      c0 = (*inptr++) >> C0_SHIFT;\n      c1 = (*inptr++) >> C1_SHIFT;\n      c2 = (*inptr++) >> C2_SHIFT;\n      cachep = &histogram[c0][c1][c2];\n      /* If we have not seen this color before, find nearest colormap entry */\n      /* and update the cache */\n      if (*cachep == 0)\n        fill_inverse_cmap(cinfo, c0, c1, c2);\n      /* Now emit the colormap index for this cell */\n      *outptr++ = (_JSAMPLE)(*cachep - 1);\n    }\n  }\n}\n\n\nMETHODDEF(void)\npass2_fs_dither(j_decompress_ptr cinfo, _JSAMPARRAY input_buf,\n                _JSAMPARRAY output_buf, int num_rows)\n/* This version performs Floyd-Steinberg dithering */\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  hist3d histogram = cquantize->histogram;\n  register LOCFSERROR cur0, cur1, cur2; /* current error or pixel value */\n  LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */\n  LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */\n  register FSERRPTR errorptr;   /* => fserrors[] at column before current */\n  _JSAMPROW inptr;              /* => current input pixel */\n  _JSAMPROW outptr;             /* => current output pixel */\n  histptr cachep;\n  int dir;                      /* +1 or -1 depending on direction */\n  int dir3;                     /* 3*dir, for advancing inptr & errorptr */\n  int row;\n  JDIMENSION col;\n  JDIMENSION width = cinfo->output_width;\n  _JSAMPLE *range_limit = (_JSAMPLE *)cinfo->sample_range_limit;\n  int *error_limit = cquantize->error_limiter;\n  _JSAMPROW colormap0 = ((_JSAMPARRAY)cinfo->colormap)[0];\n  _JSAMPROW colormap1 = ((_JSAMPARRAY)cinfo->colormap)[1];\n  _JSAMPROW colormap2 = ((_JSAMPARRAY)cinfo->colormap)[2];\n  SHIFT_TEMPS\n\n  for (row = 0; row < num_rows; row++) {\n    inptr = input_buf[row];\n    outptr = output_buf[row];\n    if (cquantize->on_odd_row) {\n      /* work right to left in this row */\n      inptr += (width - 1) * 3; /* so point to rightmost pixel */\n      outptr += width - 1;\n      dir = -1;\n      dir3 = -3;\n      errorptr = cquantize->fserrors + (width + 1) * 3; /* => entry after last column */\n      cquantize->on_odd_row = FALSE; /* flip for next time */\n    } else {\n      /* work left to right in this row */\n      dir = 1;\n      dir3 = 3;\n      errorptr = cquantize->fserrors; /* => entry before first real column */\n      cquantize->on_odd_row = TRUE; /* flip for next time */\n    }\n    /* Preset error values: no error propagated to first pixel from left */\n    cur0 = cur1 = cur2 = 0;\n    /* and no error propagated to row below yet */\n    belowerr0 = belowerr1 = belowerr2 = 0;\n    bpreverr0 = bpreverr1 = bpreverr2 = 0;\n\n    for (col = width; col > 0; col--) {\n      /* curN holds the error propagated from the previous pixel on the\n       * current line.  Add the error propagated from the previous line\n       * to form the complete error correction term for this pixel, and\n       * round the error term (which is expressed * 16) to an integer.\n       * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct\n       * for either sign of the error value.\n       * Note: errorptr points to *previous* column's array entry.\n       */\n      cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3 + 0] + 8, 4);\n      cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3 + 1] + 8, 4);\n      cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3 + 2] + 8, 4);\n      /* Limit the error using transfer function set by init_error_limit.\n       * See comments with init_error_limit for rationale.\n       */\n      cur0 = error_limit[cur0];\n      cur1 = error_limit[cur1];\n      cur2 = error_limit[cur2];\n      /* Form pixel value + error, and range-limit to 0.._MAXJSAMPLE.\n       * The maximum error is +- _MAXJSAMPLE (or less with error limiting);\n       * this sets the required size of the range_limit array.\n       */\n      cur0 += inptr[0];\n      cur1 += inptr[1];\n      cur2 += inptr[2];\n      cur0 = range_limit[cur0];\n      cur1 = range_limit[cur1];\n      cur2 = range_limit[cur2];\n      /* Index into the cache with adjusted pixel value */\n      cachep =\n        &histogram[cur0 >> C0_SHIFT][cur1 >> C1_SHIFT][cur2 >> C2_SHIFT];\n      /* If we have not seen this color before, find nearest colormap */\n      /* entry and update the cache */\n      if (*cachep == 0)\n        fill_inverse_cmap(cinfo, cur0 >> C0_SHIFT, cur1 >> C1_SHIFT,\n                          cur2 >> C2_SHIFT);\n      /* Now emit the colormap index for this cell */\n      {\n        register int pixcode = *cachep - 1;\n        *outptr = (_JSAMPLE)pixcode;\n        /* Compute representation error for this pixel */\n        cur0 -= colormap0[pixcode];\n        cur1 -= colormap1[pixcode];\n        cur2 -= colormap2[pixcode];\n      }\n      /* Compute error fractions to be propagated to adjacent pixels.\n       * Add these into the running sums, and simultaneously shift the\n       * next-line error sums left by 1 column.\n       */\n      {\n        register LOCFSERROR bnexterr;\n\n        bnexterr = cur0;        /* Process component 0 */\n        errorptr[0] = (FSERROR)(bpreverr0 + cur0 * 3);\n        bpreverr0 = belowerr0 + cur0 * 5;\n        belowerr0 = bnexterr;\n        cur0 *= 7;\n        bnexterr = cur1;        /* Process component 1 */\n        errorptr[1] = (FSERROR)(bpreverr1 + cur1 * 3);\n        bpreverr1 = belowerr1 + cur1 * 5;\n        belowerr1 = bnexterr;\n        cur1 *= 7;\n        bnexterr = cur2;        /* Process component 2 */\n        errorptr[2] = (FSERROR)(bpreverr2 + cur2 * 3);\n        bpreverr2 = belowerr2 + cur2 * 5;\n        belowerr2 = bnexterr;\n        cur2 *= 7;\n      }\n      /* At this point curN contains the 7/16 error value to be propagated\n       * to the next pixel on the current line, and all the errors for the\n       * next line have been shifted over.  We are therefore ready to move on.\n       */\n      inptr += dir3;            /* Advance pixel pointers to next column */\n      outptr += dir;\n      errorptr += dir3;         /* advance errorptr to current column */\n    }\n    /* Post-loop cleanup: we must unload the final error values into the\n     * final fserrors[] entry.  Note we need not unload belowerrN because\n     * it is for the dummy column before or after the actual array.\n     */\n    errorptr[0] = (FSERROR)bpreverr0; /* unload prev errs into array */\n    errorptr[1] = (FSERROR)bpreverr1;\n    errorptr[2] = (FSERROR)bpreverr2;\n  }\n}\n\n\n/*\n * Initialize the error-limiting transfer function (lookup table).\n * The raw F-S error computation can potentially compute error values of up to\n * +- _MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be\n * much less, otherwise obviously wrong pixels will be created.  (Typical\n * effects include weird fringes at color-area boundaries, isolated bright\n * pixels in a dark area, etc.)  The standard advice for avoiding this problem\n * is to ensure that the \"corners\" of the color cube are allocated as output\n * colors; then repeated errors in the same direction cannot cause cascading\n * error buildup.  However, that only prevents the error from getting\n * completely out of hand; Aaron Giles reports that error limiting improves\n * the results even with corner colors allocated.\n * A simple clamping of the error values to about +- _MAXJSAMPLE/8 works pretty\n * well, but the smoother transfer function used below is even better.  Thanks\n * to Aaron Giles for this idea.\n */\n\nLOCAL(void)\ninit_error_limit(j_decompress_ptr cinfo)\n/* Allocate and fill in the error_limiter table */\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  int *table;\n  int in, out;\n\n  table = (int *)(*cinfo->mem->alloc_small)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE, (_MAXJSAMPLE * 2 + 1) * sizeof(int));\n  table += _MAXJSAMPLE;         /* so can index -_MAXJSAMPLE .. +_MAXJSAMPLE */\n  cquantize->error_limiter = table;\n\n#define STEPSIZE  ((_MAXJSAMPLE + 1) / 16)\n  /* Map errors 1:1 up to +- _MAXJSAMPLE/16 */\n  out = 0;\n  for (in = 0; in < STEPSIZE; in++, out++) {\n    table[in] = out;  table[-in] = -out;\n  }\n  /* Map errors 1:2 up to +- 3*_MAXJSAMPLE/16 */\n  for (; in < STEPSIZE * 3; in++, out += (in & 1) ? 0 : 1) {\n    table[in] = out;  table[-in] = -out;\n  }\n  /* Clamp the rest to final out value (which is (_MAXJSAMPLE+1)/8) */\n  for (; in <= _MAXJSAMPLE; in++) {\n    table[in] = out;  table[-in] = -out;\n  }\n#undef STEPSIZE\n}\n\n\n/*\n * Finish up at the end of each pass.\n */\n\nMETHODDEF(void)\nfinish_pass1(j_decompress_ptr cinfo)\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n\n  /* Select the representative colors and fill in cinfo->colormap */\n  cinfo->colormap = (JSAMPARRAY)cquantize->sv_colormap;\n  select_colors(cinfo, cquantize->desired);\n  /* Force next pass to zero the color index table */\n  cquantize->needs_zeroed = TRUE;\n}\n\n\nMETHODDEF(void)\nfinish_pass2(j_decompress_ptr cinfo)\n{\n  /* no work */\n}\n\n\n/*\n * Initialize for each processing pass.\n */\n\nMETHODDEF(void)\nstart_pass_2_quant(j_decompress_ptr cinfo, boolean is_pre_scan)\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n  hist3d histogram = cquantize->histogram;\n  int i;\n\n  /* Only F-S dithering or no dithering is supported. */\n  /* If user asks for ordered dither, give them F-S. */\n  if (cinfo->dither_mode != JDITHER_NONE)\n    cinfo->dither_mode = JDITHER_FS;\n\n  if (is_pre_scan) {\n    /* Set up method pointers */\n    cquantize->pub._color_quantize = prescan_quantize;\n    cquantize->pub.finish_pass = finish_pass1;\n    cquantize->needs_zeroed = TRUE; /* Always zero histogram */\n  } else {\n    /* Set up method pointers */\n    if (cinfo->dither_mode == JDITHER_FS)\n      cquantize->pub._color_quantize = pass2_fs_dither;\n    else\n      cquantize->pub._color_quantize = pass2_no_dither;\n    cquantize->pub.finish_pass = finish_pass2;\n\n    /* Make sure color count is acceptable */\n    i = cinfo->actual_number_of_colors;\n    if (i < 1)\n      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);\n    if (i > MAXNUMCOLORS)\n      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);\n\n    if (cinfo->dither_mode == JDITHER_FS) {\n      size_t arraysize =\n        (size_t)((cinfo->output_width + 2) * (3 * sizeof(FSERROR)));\n      /* Allocate Floyd-Steinberg workspace if we didn't already. */\n      if (cquantize->fserrors == NULL)\n        cquantize->fserrors = (FSERRPTR)(*cinfo->mem->alloc_large)\n          ((j_common_ptr)cinfo, JPOOL_IMAGE, arraysize);\n      /* Initialize the propagated errors to zero. */\n      jzero_far((void *)cquantize->fserrors, arraysize);\n      /* Make the error-limit table if we didn't already. */\n      if (cquantize->error_limiter == NULL)\n        init_error_limit(cinfo);\n      cquantize->on_odd_row = FALSE;\n    }\n\n  }\n  /* Zero the histogram or inverse color map, if necessary */\n  if (cquantize->needs_zeroed) {\n    for (i = 0; i < HIST_C0_ELEMS; i++) {\n      jzero_far((void *)histogram[i],\n                HIST_C1_ELEMS * HIST_C2_ELEMS * sizeof(histcell));\n    }\n    cquantize->needs_zeroed = FALSE;\n  }\n}\n\n\n/*\n * Switch to a new external colormap between output passes.\n */\n\nMETHODDEF(void)\nnew_color_map_2_quant(j_decompress_ptr cinfo)\n{\n  my_cquantize_ptr cquantize = (my_cquantize_ptr)cinfo->cquantize;\n\n  /* Reset the inverse color map */\n  cquantize->needs_zeroed = TRUE;\n}\n\n\n/*\n * Module initialization routine for 2-pass color quantization.\n */\n\nGLOBAL(void)\n_jinit_2pass_quantizer(j_decompress_ptr cinfo)\n{\n  my_cquantize_ptr cquantize;\n  int i;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  cquantize = (my_cquantize_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_cquantizer));\n  cinfo->cquantize = (struct jpeg_color_quantizer *)cquantize;\n  cquantize->pub.start_pass = start_pass_2_quant;\n  cquantize->pub.new_color_map = new_color_map_2_quant;\n  cquantize->fserrors = NULL;   /* flag optional arrays not allocated */\n  cquantize->error_limiter = NULL;\n\n  /* Make sure jdmaster didn't give me a case I can't handle */\n  if (cinfo->out_color_components != 3 ||\n      cinfo->out_color_space == JCS_RGB565 || cinfo->master->lossless)\n    ERREXIT(cinfo, JERR_NOTIMPL);\n\n  /* Allocate the histogram/inverse colormap storage */\n  cquantize->histogram = (hist3d)(*cinfo->mem->alloc_small)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * sizeof(hist2d));\n  for (i = 0; i < HIST_C0_ELEMS; i++) {\n    cquantize->histogram[i] = (hist2d)(*cinfo->mem->alloc_large)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       HIST_C1_ELEMS * HIST_C2_ELEMS * sizeof(histcell));\n  }\n  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */\n\n  /* Allocate storage for the completed colormap, if required.\n   * We do this now since it may affect the memory manager's space\n   * calculations.\n   */\n  if (cinfo->enable_2pass_quant) {\n    /* Make sure color count is acceptable */\n    int desired = cinfo->desired_number_of_colors;\n    /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */\n    if (desired < 8)\n      ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);\n    /* Make sure colormap indexes can be represented by _JSAMPLEs */\n    if (desired > MAXNUMCOLORS)\n      ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);\n    cquantize->sv_colormap = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)desired, (JDIMENSION)3);\n    cquantize->desired = desired;\n  } else\n    cquantize->sv_colormap = NULL;\n\n  /* Only F-S dithering or no dithering is supported. */\n  /* If user asks for ordered dither, give them F-S. */\n  if (cinfo->dither_mode != JDITHER_NONE)\n    cinfo->dither_mode = JDITHER_FS;\n\n  /* Allocate Floyd-Steinberg workspace if necessary.\n   * This isn't really needed until pass 2, but again it may affect the memory\n   * manager's space calculations.  Although we will cope with a later change\n   * in dither_mode, we do not promise to honor max_memory_to_use if\n   * dither_mode changes.\n   */\n  if (cinfo->dither_mode == JDITHER_FS) {\n    cquantize->fserrors = (FSERRPTR)(*cinfo->mem->alloc_large)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       (size_t)((cinfo->output_width + 2) * (3 * sizeof(FSERROR))));\n    /* Might as well create the error-limiting table too. */\n    init_error_limit(cinfo);\n  }\n}\n\n#endif /* defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16 */\n"
        },
        {
          "name": "jsamplecomp.h",
          "type": "blob",
          "size": 12.525390625,
          "content": "/*\n * jsamplecomp.h\n *\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n */\n\n/* In source files that must be compiled for multiple data precisions, we\n * prefix all precision-dependent data types, macros, methods, fields, and\n * function names with an underscore.  Including this file replaces those\n * precision-independent tokens with their precision-dependent equivalents,\n * based on the value of BITS_IN_JSAMPLE.\n */\n\n#ifndef JSAMPLECOMP_H\n#define JSAMPLECOMP_H\n\n#if BITS_IN_JSAMPLE == 16\n\n/* Sample data types and macros (jmorecfg.h) */\n#define _JSAMPLE  J16SAMPLE\n\n#define _MAXJSAMPLE  MAXJ16SAMPLE\n#define _CENTERJSAMPLE   CENTERJ16SAMPLE\n\n#define _JSAMPROW  J16SAMPROW\n#define _JSAMPARRAY  J16SAMPARRAY\n#define _JSAMPIMAGE  J16SAMPIMAGE\n\n/* External functions (jpeglib.h) */\n#define _jpeg_write_scanlines  jpeg16_write_scanlines\n#define _jpeg_read_scanlines  jpeg16_read_scanlines\n\n/* Internal methods (jpegint.h) */\n\n#ifdef C_LOSSLESS_SUPPORTED\n/* Use the 16-bit method in the jpeg_c_main_controller structure. */\n#define _process_data  process_data_16\n/* Use the 16-bit method in the jpeg_c_prep_controller structure. */\n#define _pre_process_data  pre_process_data_16\n/* Use the 16-bit method in the jpeg_c_coef_controller structure. */\n#define _compress_data  compress_data_16\n/* Use the 16-bit method in the jpeg_color_converter structure. */\n#define _color_convert  color_convert_16\n/* Use the 16-bit method in the jpeg_downsampler structure. */\n#define _downsample  downsample_16\n#endif\n#ifdef D_LOSSLESS_SUPPORTED\n/* Use the 16-bit method in the jpeg_d_main_controller structure. */\n#define _process_data  process_data_16\n/* Use the 16-bit method in the jpeg_d_coef_controller structure. */\n#define _decompress_data  decompress_data_16\n/* Use the 16-bit method in the jpeg_d_post_controller structure. */\n#define _post_process_data  post_process_data_16\n/* Use the 16-bit method in the jpeg_upsampler structure. */\n#define _upsample  upsample_16\n/* Use the 16-bit method in the jpeg_color_converter structure. */\n#define _color_convert  color_convert_16\n#endif\n\n/* Global internal functions (jpegint.h) */\n#ifdef C_LOSSLESS_SUPPORTED\n#define _jinit_c_main_controller  j16init_c_main_controller\n#define _jinit_c_prep_controller  j16init_c_prep_controller\n#define _jinit_color_converter  j16init_color_converter\n#define _jinit_downsampler  j16init_downsampler\n#define _jinit_c_diff_controller  j16init_c_diff_controller\n#define _jinit_lossless_compressor  j16init_lossless_compressor\n#endif\n\n#ifdef D_LOSSLESS_SUPPORTED\n#define _jinit_d_main_controller  j16init_d_main_controller\n#define _jinit_d_post_controller  j16init_d_post_controller\n#define _jinit_upsampler  j16init_upsampler\n#define _jinit_color_deconverter  j16init_color_deconverter\n#define _jinit_merged_upsampler  j16init_merged_upsampler\n#define _jinit_d_diff_controller  j16init_d_diff_controller\n#define _jinit_lossless_decompressor  j16init_lossless_decompressor\n#endif\n\n#if defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED)\n#define _jcopy_sample_rows  j16copy_sample_rows\n#endif\n\n/* Internal fields (cdjpeg.h) */\n\n#if defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED)\n/* Use the 16-bit buffer in the cjpeg_source_struct and djpeg_dest_struct\n   structures. */\n#define _buffer  buffer16\n#endif\n\n/* Image I/O functions (cdjpeg.h) */\n#ifdef C_LOSSLESS_SUPPORTED\n#define _jinit_read_gif  j16init_read_gif\n#define _jinit_read_ppm  j16init_read_ppm\n#endif\n\n#ifdef D_LOSSLESS_SUPPORTED\n#define _jinit_write_ppm  j16init_write_ppm\n#endif\n\n#elif BITS_IN_JSAMPLE == 12\n\n/* Sample data types and macros (jmorecfg.h) */\n#define _JSAMPLE  J12SAMPLE\n\n#define _MAXJSAMPLE  MAXJ12SAMPLE\n#define _CENTERJSAMPLE   CENTERJ12SAMPLE\n\n#define _JSAMPROW  J12SAMPROW\n#define _JSAMPARRAY  J12SAMPARRAY\n#define _JSAMPIMAGE  J12SAMPIMAGE\n\n/* External functions (jpeglib.h) */\n#define _jpeg_write_scanlines  jpeg12_write_scanlines\n#define _jpeg_write_raw_data  jpeg12_write_raw_data\n#define _jpeg_read_scanlines  jpeg12_read_scanlines\n#define _jpeg_skip_scanlines  jpeg12_skip_scanlines\n#define _jpeg_crop_scanline  jpeg12_crop_scanline\n#define _jpeg_read_raw_data  jpeg12_read_raw_data\n\n/* Internal methods (jpegint.h) */\n\n/* Use the 12-bit method in the jpeg_c_main_controller structure. */\n#define _process_data  process_data_12\n/* Use the 12-bit method in the jpeg_c_prep_controller structure. */\n#define _pre_process_data  pre_process_data_12\n/* Use the 12-bit method in the jpeg_c_coef_controller structure. */\n#define _compress_data  compress_data_12\n/* Use the 12-bit method in the jpeg_color_converter structure. */\n#define _color_convert  color_convert_12\n/* Use the 12-bit method in the jpeg_downsampler structure. */\n#define _downsample  downsample_12\n/* Use the 12-bit method in the jpeg_forward_dct structure. */\n#define _forward_DCT  forward_DCT_12\n/* Use the 12-bit method in the jpeg_d_main_controller structure. */\n#define _process_data  process_data_12\n/* Use the 12-bit method in the jpeg_d_coef_controller structure. */\n#define _decompress_data  decompress_data_12\n/* Use the 12-bit method in the jpeg_d_post_controller structure. */\n#define _post_process_data  post_process_data_12\n/* Use the 12-bit method in the jpeg_inverse_dct structure. */\n#define _inverse_DCT_method_ptr  inverse_DCT_12_method_ptr\n#define _inverse_DCT  inverse_DCT_12\n/* Use the 12-bit method in the jpeg_upsampler structure. */\n#define _upsample  upsample_12\n/* Use the 12-bit method in the jpeg_color_converter structure. */\n#define _color_convert  color_convert_12\n/* Use the 12-bit method in the jpeg_color_quantizer structure. */\n#define _color_quantize  color_quantize_12\n\n/* Global internal functions (jpegint.h) */\n#define _jinit_c_main_controller  j12init_c_main_controller\n#define _jinit_c_prep_controller  j12init_c_prep_controller\n#define _jinit_c_coef_controller  j12init_c_coef_controller\n#define _jinit_color_converter  j12init_color_converter\n#define _jinit_downsampler  j12init_downsampler\n#define _jinit_forward_dct  j12init_forward_dct\n#ifdef C_LOSSLESS_SUPPORTED\n#define _jinit_c_diff_controller  j12init_c_diff_controller\n#define _jinit_lossless_compressor  j12init_lossless_compressor\n#endif\n\n#define _jinit_d_main_controller  j12init_d_main_controller\n#define _jinit_d_coef_controller  j12init_d_coef_controller\n#define _jinit_d_post_controller  j12init_d_post_controller\n#define _jinit_inverse_dct  j12init_inverse_dct\n#define _jinit_upsampler  j12init_upsampler\n#define _jinit_color_deconverter  j12init_color_deconverter\n#define _jinit_1pass_quantizer  j12init_1pass_quantizer\n#define _jinit_2pass_quantizer  j12init_2pass_quantizer\n#define _jinit_merged_upsampler  j12init_merged_upsampler\n#ifdef D_LOSSLESS_SUPPORTED\n#define _jinit_d_diff_controller  j12init_d_diff_controller\n#define _jinit_lossless_decompressor  j12init_lossless_decompressor\n#endif\n\n#define _jcopy_sample_rows  j12copy_sample_rows\n\n/* Global internal functions (jdct.h) */\n#define _jpeg_fdct_islow  jpeg12_fdct_islow\n#define _jpeg_fdct_ifast  jpeg12_fdct_ifast\n\n#define _jpeg_idct_islow  jpeg12_idct_islow\n#define _jpeg_idct_ifast  jpeg12_idct_ifast\n#define _jpeg_idct_float  jpeg12_idct_float\n#define _jpeg_idct_7x7  jpeg12_idct_7x7\n#define _jpeg_idct_6x6  jpeg12_idct_6x6\n#define _jpeg_idct_5x5  jpeg12_idct_5x5\n#define _jpeg_idct_4x4  jpeg12_idct_4x4\n#define _jpeg_idct_3x3  jpeg12_idct_3x3\n#define _jpeg_idct_2x2  jpeg12_idct_2x2\n#define _jpeg_idct_1x1  jpeg12_idct_1x1\n#define _jpeg_idct_9x9  jpeg12_idct_9x9\n#define _jpeg_idct_10x10  jpeg12_idct_10x10\n#define _jpeg_idct_11x11  jpeg12_idct_11x11\n#define _jpeg_idct_12x12  jpeg12_idct_12x12\n#define _jpeg_idct_13x13  jpeg12_idct_13x13\n#define _jpeg_idct_14x14  jpeg12_idct_14x14\n#define _jpeg_idct_15x15  jpeg12_idct_15x15\n#define _jpeg_idct_16x16  jpeg12_idct_16x16\n\n/* Internal fields (cdjpeg.h) */\n\n/* Use the 12-bit buffer in the cjpeg_source_struct and djpeg_dest_struct\n   structures. */\n#define _buffer  buffer12\n\n/* Image I/O functions (cdjpeg.h) */\n#define _jinit_read_gif  j12init_read_gif\n#define _jinit_write_gif  j12init_write_gif\n#define _jinit_read_ppm  j12init_read_ppm\n#define _jinit_write_ppm  j12init_write_ppm\n\n#define _read_color_map  read_color_map_12\n\n#else /* BITS_IN_JSAMPLE */\n\n/* Sample data types and macros (jmorecfg.h) */\n#define _JSAMPLE  JSAMPLE\n\n#define _MAXJSAMPLE  MAXJSAMPLE\n#define _CENTERJSAMPLE   CENTERJSAMPLE\n\n#define _JSAMPROW  JSAMPROW\n#define _JSAMPARRAY  JSAMPARRAY\n#define _JSAMPIMAGE  JSAMPIMAGE\n\n/* External functions (jpeglib.h) */\n#define _jpeg_write_scanlines  jpeg_write_scanlines\n#define _jpeg_write_raw_data  jpeg_write_raw_data\n#define _jpeg_read_scanlines  jpeg_read_scanlines\n#define _jpeg_skip_scanlines  jpeg_skip_scanlines\n#define _jpeg_crop_scanline  jpeg_crop_scanline\n#define _jpeg_read_raw_data  jpeg_read_raw_data\n\n/* Internal methods (jpegint.h) */\n\n/* Use the 8-bit method in the jpeg_c_main_controller structure. */\n#define _process_data  process_data\n/* Use the 8-bit method in the jpeg_c_prep_controller structure. */\n#define _pre_process_data  pre_process_data\n/* Use the 8-bit method in the jpeg_c_coef_controller structure. */\n#define _compress_data  compress_data\n/* Use the 8-bit method in the jpeg_color_converter structure. */\n#define _color_convert  color_convert\n/* Use the 8-bit method in the jpeg_downsampler structure. */\n#define _downsample  downsample\n/* Use the 8-bit method in the jpeg_forward_dct structure. */\n#define _forward_DCT  forward_DCT\n/* Use the 8-bit method in the jpeg_d_main_controller structure. */\n#define _process_data  process_data\n/* Use the 8-bit method in the jpeg_d_coef_controller structure. */\n#define _decompress_data  decompress_data\n/* Use the 8-bit method in the jpeg_d_post_controller structure. */\n#define _post_process_data  post_process_data\n/* Use the 8-bit method in the jpeg_inverse_dct structure. */\n#define _inverse_DCT_method_ptr  inverse_DCT_method_ptr\n#define _inverse_DCT  inverse_DCT\n/* Use the 8-bit method in the jpeg_upsampler structure. */\n#define _upsample  upsample\n/* Use the 8-bit method in the jpeg_color_converter structure. */\n#define _color_convert  color_convert\n/* Use the 8-bit method in the jpeg_color_quantizer structure. */\n#define _color_quantize  color_quantize\n\n/* Global internal functions (jpegint.h) */\n#define _jinit_c_main_controller  jinit_c_main_controller\n#define _jinit_c_prep_controller  jinit_c_prep_controller\n#define _jinit_c_coef_controller  jinit_c_coef_controller\n#define _jinit_color_converter  jinit_color_converter\n#define _jinit_downsampler  jinit_downsampler\n#define _jinit_forward_dct  jinit_forward_dct\n#ifdef C_LOSSLESS_SUPPORTED\n#define _jinit_c_diff_controller  jinit_c_diff_controller\n#define _jinit_lossless_compressor  jinit_lossless_compressor\n#endif\n\n#define _jinit_d_main_controller  jinit_d_main_controller\n#define _jinit_d_coef_controller  jinit_d_coef_controller\n#define _jinit_d_post_controller  jinit_d_post_controller\n#define _jinit_inverse_dct  jinit_inverse_dct\n#define _jinit_upsampler  jinit_upsampler\n#define _jinit_color_deconverter  jinit_color_deconverter\n#define _jinit_1pass_quantizer  jinit_1pass_quantizer\n#define _jinit_2pass_quantizer  jinit_2pass_quantizer\n#define _jinit_merged_upsampler  jinit_merged_upsampler\n#ifdef D_LOSSLESS_SUPPORTED\n#define _jinit_d_diff_controller  jinit_d_diff_controller\n#define _jinit_lossless_decompressor  jinit_lossless_decompressor\n#endif\n\n#define _jcopy_sample_rows  jcopy_sample_rows\n\n/* Global internal functions (jdct.h) */\n#define _jpeg_fdct_islow  jpeg_fdct_islow\n#define _jpeg_fdct_ifast  jpeg_fdct_ifast\n\n#define _jpeg_idct_islow  jpeg_idct_islow\n#define _jpeg_idct_ifast  jpeg_idct_ifast\n#define _jpeg_idct_float  jpeg_idct_float\n#define _jpeg_idct_7x7  jpeg_idct_7x7\n#define _jpeg_idct_6x6  jpeg_idct_6x6\n#define _jpeg_idct_5x5  jpeg_idct_5x5\n#define _jpeg_idct_4x4  jpeg_idct_4x4\n#define _jpeg_idct_3x3  jpeg_idct_3x3\n#define _jpeg_idct_2x2  jpeg_idct_2x2\n#define _jpeg_idct_1x1  jpeg_idct_1x1\n#define _jpeg_idct_9x9  jpeg_idct_9x9\n#define _jpeg_idct_10x10  jpeg_idct_10x10\n#define _jpeg_idct_11x11  jpeg_idct_11x11\n#define _jpeg_idct_12x12  jpeg_idct_12x12\n#define _jpeg_idct_13x13  jpeg_idct_13x13\n#define _jpeg_idct_14x14  jpeg_idct_14x14\n#define _jpeg_idct_15x15  jpeg_idct_15x15\n#define _jpeg_idct_16x16  jpeg_idct_16x16\n\n/* Internal fields (cdjpeg.h) */\n\n/* Use the 8-bit buffer in the cjpeg_source_struct and djpeg_dest_struct\n   structures. */\n#define _buffer  buffer\n\n/* Image I/O functions (cdjpeg.h) */\n#define _jinit_read_gif  jinit_read_gif\n#define _jinit_write_gif  jinit_write_gif\n#define _jinit_read_ppm  jinit_read_ppm\n#define _jinit_write_ppm  jinit_write_ppm\n\n#define _read_color_map  read_color_map\n\n#endif /* BITS_IN_JSAMPLE */\n\n#endif /* JSAMPLECOMP_H */\n"
        },
        {
          "name": "jsimd.h",
          "type": "blob",
          "size": 5.7705078125,
          "content": "/*\n * jsimd.h\n *\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n * Copyright (C) 2011, 2014, 2022, D. R. Commander.\n * Copyright (C) 2015-2016, 2018, 2022, Matthieu Darbois.\n * Copyright (C) 2020, Arm Limited.\n *\n * Based on the x86 SIMD extension for IJG JPEG library,\n * Copyright (C) 1999-2006, MIYASAKA Masaru.\n * For conditions of distribution and use, see copyright notice in jsimdext.inc\n *\n */\n\n#ifdef WITH_SIMD\n\n#include \"jchuff.h\"             /* Declarations shared with jcphuff.c */\n\nEXTERN(int) jsimd_can_rgb_ycc(void);\nEXTERN(int) jsimd_can_rgb_gray(void);\nEXTERN(int) jsimd_can_ycc_rgb(void);\nEXTERN(int) jsimd_can_ycc_rgb565(void);\nEXTERN(int) jsimd_c_can_null_convert(void);\n\nEXTERN(void) jsimd_rgb_ycc_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,\n                                   JSAMPIMAGE output_buf,\n                                   JDIMENSION output_row, int num_rows);\nEXTERN(void) jsimd_rgb_gray_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,\n                                    JSAMPIMAGE output_buf,\n                                    JDIMENSION output_row, int num_rows);\nEXTERN(void) jsimd_ycc_rgb_convert(j_decompress_ptr cinfo,\n                                   JSAMPIMAGE input_buf, JDIMENSION input_row,\n                                   JSAMPARRAY output_buf, int num_rows);\nEXTERN(void) jsimd_ycc_rgb565_convert(j_decompress_ptr cinfo,\n                                      JSAMPIMAGE input_buf,\n                                      JDIMENSION input_row,\n                                      JSAMPARRAY output_buf, int num_rows);\nEXTERN(void) jsimd_c_null_convert(j_compress_ptr cinfo, JSAMPARRAY input_buf,\n                                  JSAMPIMAGE output_buf, JDIMENSION output_row,\n                                  int num_rows);\n\nEXTERN(int) jsimd_can_h2v2_downsample(void);\nEXTERN(int) jsimd_can_h2v1_downsample(void);\n\nEXTERN(void) jsimd_h2v2_downsample(j_compress_ptr cinfo,\n                                   jpeg_component_info *compptr,\n                                   JSAMPARRAY input_data,\n                                   JSAMPARRAY output_data);\n\nEXTERN(int) jsimd_can_h2v2_smooth_downsample(void);\n\nEXTERN(void) jsimd_h2v2_smooth_downsample(j_compress_ptr cinfo,\n                                          jpeg_component_info *compptr,\n                                          JSAMPARRAY input_data,\n                                          JSAMPARRAY output_data);\n\nEXTERN(void) jsimd_h2v1_downsample(j_compress_ptr cinfo,\n                                   jpeg_component_info *compptr,\n                                   JSAMPARRAY input_data,\n                                   JSAMPARRAY output_data);\n\nEXTERN(int) jsimd_can_h2v2_upsample(void);\nEXTERN(int) jsimd_can_h2v1_upsample(void);\nEXTERN(int) jsimd_can_int_upsample(void);\n\nEXTERN(void) jsimd_h2v2_upsample(j_decompress_ptr cinfo,\n                                 jpeg_component_info *compptr,\n                                 JSAMPARRAY input_data,\n                                 JSAMPARRAY *output_data_ptr);\nEXTERN(void) jsimd_h2v1_upsample(j_decompress_ptr cinfo,\n                                 jpeg_component_info *compptr,\n                                 JSAMPARRAY input_data,\n                                 JSAMPARRAY *output_data_ptr);\nEXTERN(void) jsimd_int_upsample(j_decompress_ptr cinfo,\n                                jpeg_component_info *compptr,\n                                JSAMPARRAY input_data,\n                                JSAMPARRAY *output_data_ptr);\n\nEXTERN(int) jsimd_can_h2v2_fancy_upsample(void);\nEXTERN(int) jsimd_can_h2v1_fancy_upsample(void);\nEXTERN(int) jsimd_can_h1v2_fancy_upsample(void);\n\nEXTERN(void) jsimd_h2v2_fancy_upsample(j_decompress_ptr cinfo,\n                                       jpeg_component_info *compptr,\n                                       JSAMPARRAY input_data,\n                                       JSAMPARRAY *output_data_ptr);\nEXTERN(void) jsimd_h2v1_fancy_upsample(j_decompress_ptr cinfo,\n                                       jpeg_component_info *compptr,\n                                       JSAMPARRAY input_data,\n                                       JSAMPARRAY *output_data_ptr);\nEXTERN(void) jsimd_h1v2_fancy_upsample(j_decompress_ptr cinfo,\n                                       jpeg_component_info *compptr,\n                                       JSAMPARRAY input_data,\n                                       JSAMPARRAY *output_data_ptr);\n\nEXTERN(int) jsimd_can_h2v2_merged_upsample(void);\nEXTERN(int) jsimd_can_h2v1_merged_upsample(void);\n\nEXTERN(void) jsimd_h2v2_merged_upsample(j_decompress_ptr cinfo,\n                                        JSAMPIMAGE input_buf,\n                                        JDIMENSION in_row_group_ctr,\n                                        JSAMPARRAY output_buf);\nEXTERN(void) jsimd_h2v1_merged_upsample(j_decompress_ptr cinfo,\n                                        JSAMPIMAGE input_buf,\n                                        JDIMENSION in_row_group_ctr,\n                                        JSAMPARRAY output_buf);\n\nEXTERN(int) jsimd_can_huff_encode_one_block(void);\n\nEXTERN(JOCTET *) jsimd_huff_encode_one_block(void *state, JOCTET *buffer,\n                                             JCOEFPTR block, int last_dc_val,\n                                             c_derived_tbl *dctbl,\n                                             c_derived_tbl *actbl);\n\nEXTERN(int) jsimd_can_encode_mcu_AC_first_prepare(void);\n\nEXTERN(void) jsimd_encode_mcu_AC_first_prepare\n  (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,\n   UJCOEF *values, size_t *zerobits);\n\nEXTERN(int) jsimd_can_encode_mcu_AC_refine_prepare(void);\n\nEXTERN(int) jsimd_encode_mcu_AC_refine_prepare\n  (const JCOEF *block, const int *jpeg_natural_order_start, int Sl, int Al,\n   UJCOEF *absvalues, size_t *bits);\n\n#endif /* WITH_SIMD */\n"
        },
        {
          "name": "jsimddct.h",
          "type": "blob",
          "size": 3.0126953125,
          "content": "/*\n * jsimddct.h\n *\n * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB\n *\n * Based on the x86 SIMD extension for IJG JPEG library,\n * Copyright (C) 1999-2006, MIYASAKA Masaru.\n * For conditions of distribution and use, see copyright notice in jsimdext.inc\n *\n */\n\nEXTERN(int) jsimd_can_convsamp(void);\nEXTERN(int) jsimd_can_convsamp_float(void);\n\nEXTERN(void) jsimd_convsamp(JSAMPARRAY sample_data, JDIMENSION start_col,\n                            DCTELEM *workspace);\nEXTERN(void) jsimd_convsamp_float(JSAMPARRAY sample_data, JDIMENSION start_col,\n                                  FAST_FLOAT *workspace);\n\nEXTERN(int) jsimd_can_fdct_islow(void);\nEXTERN(int) jsimd_can_fdct_ifast(void);\nEXTERN(int) jsimd_can_fdct_float(void);\n\nEXTERN(void) jsimd_fdct_islow(DCTELEM *data);\nEXTERN(void) jsimd_fdct_ifast(DCTELEM *data);\nEXTERN(void) jsimd_fdct_float(FAST_FLOAT *data);\n\nEXTERN(int) jsimd_can_quantize(void);\nEXTERN(int) jsimd_can_quantize_float(void);\n\nEXTERN(void) jsimd_quantize(JCOEFPTR coef_block, DCTELEM *divisors,\n                            DCTELEM *workspace);\nEXTERN(void) jsimd_quantize_float(JCOEFPTR coef_block, FAST_FLOAT *divisors,\n                                  FAST_FLOAT *workspace);\n\nEXTERN(int) jsimd_can_idct_2x2(void);\nEXTERN(int) jsimd_can_idct_4x4(void);\nEXTERN(int) jsimd_can_idct_6x6(void);\nEXTERN(int) jsimd_can_idct_12x12(void);\n\nEXTERN(void) jsimd_idct_2x2(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) jsimd_idct_4x4(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) jsimd_idct_6x6(j_decompress_ptr cinfo,\n                            jpeg_component_info *compptr, JCOEFPTR coef_block,\n                            JSAMPARRAY output_buf, JDIMENSION output_col);\nEXTERN(void) jsimd_idct_12x12(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\n\nEXTERN(int) jsimd_can_idct_islow(void);\nEXTERN(int) jsimd_can_idct_ifast(void);\nEXTERN(int) jsimd_can_idct_float(void);\n\nEXTERN(void) jsimd_idct_islow(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) jsimd_idct_ifast(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\nEXTERN(void) jsimd_idct_float(j_decompress_ptr cinfo,\n                              jpeg_component_info *compptr,\n                              JCOEFPTR coef_block, JSAMPARRAY output_buf,\n                              JDIMENSION output_col);\n"
        },
        {
          "name": "jstdhuff.c",
          "type": "blob",
          "size": 5.2294921875,
          "content": "/*\n * jstdhuff.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1998, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2013, 2022, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to set the default Huffman tables, if they are\n * not already set.\n */\n\n/*\n * Huffman table setup routines\n */\n\nLOCAL(void)\nadd_huff_table(j_common_ptr cinfo, JHUFF_TBL **htblptr, const UINT8 *bits,\n               const UINT8 *val)\n/* Define a Huffman table */\n{\n  int nsymbols, len;\n\n  if (*htblptr == NULL)\n    *htblptr = jpeg_alloc_huff_table(cinfo);\n  else if (cinfo->is_decompressor)\n    return;\n\n  /* Copy the number-of-symbols-of-each-code-length counts */\n  memcpy((*htblptr)->bits, bits, sizeof((*htblptr)->bits));\n\n  /* Validate the counts.  We do this here mainly so we can copy the right\n   * number of symbols from the val[] array, without risking marching off\n   * the end of memory.  jchuff.c will do a more thorough test later.\n   */\n  nsymbols = 0;\n  for (len = 1; len <= 16; len++)\n    nsymbols += bits[len];\n  if (nsymbols < 1 || nsymbols > 256)\n    ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);\n\n  memcpy((*htblptr)->huffval, val, nsymbols * sizeof(UINT8));\n  memset(&((*htblptr)->huffval[nsymbols]), 0,\n         (256 - nsymbols) * sizeof(UINT8));\n\n  /* Initialize sent_table FALSE so table will be written to JPEG file. */\n  (*htblptr)->sent_table = FALSE;\n}\n\n\nLOCAL(void)\nstd_huff_tables(j_common_ptr cinfo)\n/* Set up the standard Huffman tables (cf. JPEG standard section K.3) */\n/* IMPORTANT: these are only valid for 8-bit data precision! */\n{\n  JHUFF_TBL **dc_huff_tbl_ptrs, **ac_huff_tbl_ptrs;\n\n  static const UINT8 bits_dc_luminance[17] = {\n    /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0\n  };\n  static const UINT8 val_dc_luminance[] = {\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n  };\n\n  static const UINT8 bits_dc_chrominance[17] = {\n    /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0\n  };\n  static const UINT8 val_dc_chrominance[] = {\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n  };\n\n  static const UINT8 bits_ac_luminance[17] = {\n    /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d\n  };\n  static const UINT8 val_ac_luminance[] = {\n    0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,\n    0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,\n    0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,\n    0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,\n    0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,\n    0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,\n    0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,\n    0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n    0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\n    0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,\n    0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\n    0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,\n    0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,\n    0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,\n    0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,\n    0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,\n    0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,\n    0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,\n    0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n    0xf9, 0xfa\n  };\n\n  static const UINT8 bits_ac_chrominance[17] = {\n    /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77\n  };\n  static const UINT8 val_ac_chrominance[] = {\n    0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,\n    0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,\n    0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,\n    0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,\n    0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,\n    0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,\n    0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,\n    0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n    0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n    0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,\n    0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n    0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n    0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,\n    0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,\n    0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,\n    0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,\n    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,\n    0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,\n    0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,\n    0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n    0xf9, 0xfa\n  };\n\n  if (cinfo->is_decompressor) {\n    dc_huff_tbl_ptrs = ((j_decompress_ptr)cinfo)->dc_huff_tbl_ptrs;\n    ac_huff_tbl_ptrs = ((j_decompress_ptr)cinfo)->ac_huff_tbl_ptrs;\n  } else {\n    dc_huff_tbl_ptrs = ((j_compress_ptr)cinfo)->dc_huff_tbl_ptrs;\n    ac_huff_tbl_ptrs = ((j_compress_ptr)cinfo)->ac_huff_tbl_ptrs;\n  }\n\n  add_huff_table(cinfo, &dc_huff_tbl_ptrs[0], bits_dc_luminance,\n                 val_dc_luminance);\n  add_huff_table(cinfo, &ac_huff_tbl_ptrs[0], bits_ac_luminance,\n                 val_ac_luminance);\n  add_huff_table(cinfo, &dc_huff_tbl_ptrs[1], bits_dc_chrominance,\n                 val_dc_chrominance);\n  add_huff_table(cinfo, &ac_huff_tbl_ptrs[1], bits_ac_chrominance,\n                 val_ac_chrominance);\n}\n"
        },
        {
          "name": "jutils.c",
          "type": "blob",
          "size": 4.0322265625,
          "content": "/*\n * jutils.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains tables and miscellaneous utility routines needed\n * for both compression and decompression.\n * Note we prefix all global names with \"j\" to minimize conflicts with\n * a surrounding application.\n */\n\n#define JPEG_INTERNALS\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"jsamplecomp.h\"\n\n\n#if BITS_IN_JSAMPLE == 8\n\n/*\n * jpeg_zigzag_order[i] is the zigzag-order position of the i'th element\n * of a DCT block read in natural order (left to right, top to bottom).\n */\n\n#if 0                           /* This table is not actually needed in v6a */\n\nconst int jpeg_zigzag_order[DCTSIZE2] = {\n   0,  1,  5,  6, 14, 15, 27, 28,\n   2,  4,  7, 13, 16, 26, 29, 42,\n   3,  8, 12, 17, 25, 30, 41, 43,\n   9, 11, 18, 24, 31, 40, 44, 53,\n  10, 19, 23, 32, 39, 45, 52, 54,\n  20, 22, 33, 38, 46, 51, 55, 60,\n  21, 34, 37, 47, 50, 56, 59, 61,\n  35, 36, 48, 49, 57, 58, 62, 63\n};\n\n#endif\n\n/*\n * jpeg_natural_order[i] is the natural-order position of the i'th element\n * of zigzag order.\n *\n * When reading corrupted data, the Huffman decoders could attempt\n * to reference an entry beyond the end of this array (if the decoded\n * zero run length reaches past the end of the block).  To prevent\n * wild stores without adding an inner-loop test, we put some extra\n * \"63\"s after the real entries.  This will cause the extra coefficient\n * to be stored in location 63 of the block, not somewhere random.\n * The worst case would be a run-length of 15, which means we need 16\n * fake entries.\n */\n\nconst int jpeg_natural_order[DCTSIZE2 + 16] = {\n  0,  1,  8, 16,  9,  2,  3, 10,\n 17, 24, 32, 25, 18, 11,  4,  5,\n 12, 19, 26, 33, 40, 48, 41, 34,\n 27, 20, 13,  6,  7, 14, 21, 28,\n 35, 42, 49, 56, 57, 50, 43, 36,\n 29, 22, 15, 23, 30, 37, 44, 51,\n 58, 59, 52, 45, 38, 31, 39, 46,\n 53, 60, 61, 54, 47, 55, 62, 63,\n 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */\n 63, 63, 63, 63, 63, 63, 63, 63\n};\n\n\n/*\n * Arithmetic utilities\n */\n\nGLOBAL(long)\njdiv_round_up(long a, long b)\n/* Compute a/b rounded up to next integer, ie, ceil(a/b) */\n/* Assumes a >= 0, b > 0 */\n{\n  return (a + b - 1L) / b;\n}\n\n\nGLOBAL(long)\njround_up(long a, long b)\n/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */\n/* Assumes a >= 0, b > 0 */\n{\n  a += b - 1L;\n  return a - (a % b);\n}\n\n#endif /* BITS_IN_JSAMPLE == 8 */\n\n\n#if BITS_IN_JSAMPLE != 16 || \\\n    defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED)\n\nGLOBAL(void)\n_jcopy_sample_rows(_JSAMPARRAY input_array, int source_row,\n                   _JSAMPARRAY output_array, int dest_row, int num_rows,\n                   JDIMENSION num_cols)\n/* Copy some rows of samples from one place to another.\n * num_rows rows are copied from input_array[source_row++]\n * to output_array[dest_row++]; these areas may overlap for duplication.\n * The source and destination arrays must be at least as wide as num_cols.\n */\n{\n  register _JSAMPROW inptr, outptr;\n  register size_t count = (size_t)(num_cols * sizeof(_JSAMPLE));\n  register int row;\n\n  input_array += source_row;\n  output_array += dest_row;\n\n  for (row = num_rows; row > 0; row--) {\n    inptr = *input_array++;\n    outptr = *output_array++;\n    memcpy(outptr, inptr, count);\n  }\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 ||\n          defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED) */\n\n\n#if BITS_IN_JSAMPLE == 8\n\nGLOBAL(void)\njcopy_block_row(JBLOCKROW input_row, JBLOCKROW output_row,\n                JDIMENSION num_blocks)\n/* Copy a row of coefficient blocks from one place to another. */\n{\n  memcpy(output_row, input_row, num_blocks * (DCTSIZE2 * sizeof(JCOEF)));\n}\n\n\nGLOBAL(void)\njzero_far(void *target, size_t bytestozero)\n/* Zero out a chunk of memory. */\n/* This might be sample-array data, block-array data, or alloc_large data. */\n{\n  memset(target, 0, bytestozero);\n}\n\n#endif /* BITS_IN_JSAMPLE == 8 */\n"
        },
        {
          "name": "jversion.h.in",
          "type": "blob",
          "size": 1.8251953125,
          "content": "/*\n * jversion.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010, 2012-2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n * Copyright (C) 2014, Mozilla Corporation.\n *\n * This file contains software version identification.\n */\n\n\n#if JPEG_LIB_VERSION >= 80\n\n#define JVERSION        \"8d  15-Jan-2012\"\n\n#elif JPEG_LIB_VERSION >= 70\n\n#define JVERSION        \"7  27-Jun-2009\"\n\n#else\n\n#define JVERSION        \"6b  27-Mar-1998\"\n\n#endif\n\n/*\n * NOTE: It is our convention to place the authors in the following order:\n * - libjpeg-turbo authors (2009-) in descending order of the date of their\n *   most recent contribution to the project, then in ascending order of the\n *   date of their first contribution to the project, then in alphabetical\n *   order\n * - Upstream authors in descending order of the date of the first inclusion of\n *   their code\n */\n\n#define JCOPYRIGHT1 \\\n  \"Copyright (C) 2009-2024 D. R. Commander\\n\" \\\n  \"Copyright (C) 2015, 2020 Google, Inc.\\n\" \\\n  \"Copyright (C) 2019-2020 Arm Limited\\n\" \\\n  \"Copyright (C) 2015-2016, 2018 Matthieu Darbois\\n\" \\\n  \"Copyright (C) 2011-2016 Siarhei Siamashka\\n\" \\\n  \"Copyright (C) 2015 Intel Corporation\\n\"\n#define JCOPYRIGHT2 \\\n  \"Copyright (C) 2013-2014 Linaro Limited\\n\" \\\n  \"Copyright (C) 2013-2014 MIPS Technologies, Inc.\\n\" \\\n  \"Copyright (C) 2009, 2012 Pierre Ossman for Cendio AB\\n\" \\\n  \"Copyright (C) 2009-2011 Nokia Corporation and/or its subsidiary(-ies)\\n\" \\\n  \"Copyright (C) 1999-2006 MIYASAKA Masaru\\n\" \\\n  \"Copyright (C) 1999 Ken Murchison\\n\" \\\n  \"Copyright (C) 1991-2020 Thomas G. Lane, Guido Vollbeding\\n\"\n\n#define JCOPYRIGHT_SHORT \\\n  \"Copyright (C) @COPYRIGHT_YEAR@ The libjpeg-turbo Project and many others\"\n"
        },
        {
          "name": "libjpeg.map.in",
          "type": "blob",
          "size": 0.16015625,
          "content": "LIBJPEGTURBO_@JPEG_LIB_VERSION_DECIMAL@ {\n  @MEM_SRCDST_FUNCTIONS@\n  local:\n    jsimd_*;\n    jconst_*;\n};\n\nLIBJPEG_@JPEG_LIB_VERSION_DECIMAL@ {\n  global:\n    *;\n};\n"
        },
        {
          "name": "libjpeg.txt",
          "type": "blob",
          "size": 172.7177734375,
          "content": "USING THE IJG JPEG LIBRARY\n\nThis file was part of the Independent JPEG Group's software:\nCopyright (C) 1994-2013, Thomas G. Lane, Guido Vollbeding.\nLossless JPEG Modifications:\nCopyright (C) 1999, Ken Murchison.\nlibjpeg-turbo Modifications:\nCopyright (C) 2010, 2014-2018, 2020, 2022-2024, D. R. Commander.\nCopyright (C) 2015, Google, Inc.\nFor conditions of distribution and use, see the accompanying README.ijg file.\n\n\nThis file describes how to use the IJG JPEG library within an application\nprogram.  Read it if you want to write a program that uses the library.\n\nThe file example.c provides heavily commented code for calling the JPEG\nlibrary.  Also see jpeglib.h (the include file to be used by application\nprograms) for full details about data structures and function parameter lists.\nThe library source code, of course, is the ultimate reference.\n\nNote that there have been *major* changes from the application interface\npresented by IJG version 4 and earlier versions.  The old design had several\ninherent limitations, and it had accumulated a lot of cruft as we added\nfeatures while trying to minimize application-interface changes.  We have\nsacrificed backward compatibility in the version 5 rewrite, but we think the\nimprovements justify this.\n\n\nTABLE OF CONTENTS\n-----------------\n\nOverview:\n        Functions provided by the library\n        12-bit and 16-bit Data Precision\n        Outline of typical usage\nBasic library usage:\n        Data formats\n        Compression details\n        Decompression details\n        Partial image decompression\n        Mechanics of usage: include files, linking, etc\nAdvanced features:\n        Compression parameter selection\n        Decompression parameter selection\n        Special color spaces\n        Error handling\n        Compressed data handling (source and destination managers)\n        I/O suspension\n        Progressive JPEG support\n        Buffered-image mode\n        Abbreviated datastreams and multiple images\n        Special markers\n        ICC profiles\n        Raw (downsampled) image data\n        Really raw data: DCT coefficients\n        Progress monitoring\n        Memory management\n        Memory usage\n        Library compile-time options\n        Portability considerations\n\nYou should read at least the overview and basic usage sections before trying\nto program with the library.  The sections on advanced features can be read\nif and when you need them.\n\n\nOVERVIEW\n========\n\nFunctions provided by the library\n---------------------------------\n\nThe IJG JPEG library provides C code to read and write JPEG-compressed image\nfiles.  The surrounding application program receives or supplies image data a\nscanline at a time, using a straightforward uncompressed image format.  All\ndetails of color conversion and other preprocessing/postprocessing can be\nhandled by the library.\n\nThe library includes a substantial amount of code that is not covered by the\nJPEG standard but is necessary for typical applications of JPEG.  These\nfunctions preprocess the image before JPEG compression or postprocess it after\ndecompression.  They include colorspace conversion, downsampling/upsampling,\nand color quantization.  The application indirectly selects use of this code\nby specifying the format in which it wishes to supply or receive image data.\nFor example, if colormapped output is requested, then the decompression\nlibrary automatically invokes color quantization.\n\nA wide range of quality vs. speed tradeoffs are possible in JPEG processing,\nand even more so in decompression postprocessing.  The decompression library\nprovides multiple implementations that cover most of the useful tradeoffs,\nranging from very-high-quality down to fast-preview operation.  On the\ncompression side we have generally not provided low-quality choices, since\ncompression is normally less time-critical.  It should be understood that the\nlow-quality modes may not meet the JPEG standard's accuracy requirements;\nnonetheless, they are useful for viewers.\n\nA word about functions *not* provided by the library.  We handle a subset of\nthe ISO JPEG standard; most baseline, extended-sequential, and progressive\nJPEG processes are supported.  (Our subset includes all features now in common\nuse.)  Unsupported ISO options include:\n        * Hierarchical storage\n        * DNL marker\n        * Nonintegral subsampling ratios\nWe support 8-bit (lossy and lossless), 12-bit (lossy and lossless), and 16-bit\n(lossless) data precision.\n\nBy itself, the library handles only interchange JPEG datastreams --- in\nparticular the widely used JFIF file format.  The library can be used by\nsurrounding code to process interchange or abbreviated JPEG datastreams that\nare embedded in more complex file formats.  (For example, this library is\nused by the free LIBTIFF library to support JPEG compression in TIFF.)\n\n\n12-bit and 16-bit Data Precision\n--------------------------------\n\nThe JPEG standard provides for baseline (8-bit-per-sample) and\n12-bit-per-sample DCT processes as well as 8-bit-per-sample, 12-bit-per-sample,\nand 16-bit-per-sample lossless (predictive) processes.  This code supports\n12-bit-per-sample lossy or lossless JPEG if you set cinfo->data_precision to 12\nand 16-bit-per-sample lossless JPEG if you set cinfo->data_precision to 16.\nNote that this causes the sample size to be larger than a char, so it affects\nthe surrounding application's image data.  The sample applications cjpeg and\ndjpeg can support 12-bit data precision only for PPM, PGM, and GIF file formats\nand 16-bit data precision only for PPM and PGM file formats.\n\nNote that, when 12-bit data precision is enabled in lossy mode, the library\ncompresses in Huffman optimization mode by default, in order to generate valid\nHuffman tables.  This is necessary because our default Huffman tables only\ncover 8-bit data.  If you need to output 12-bit-per-sample JPEG files in one\npass, you'll have to supply suitable default Huffman tables.  You may also want\nto supply your own DCT quantization tables; the existing quality-scaling code\nhas been developed for 8-bit data precision and probably doesn't generate\nespecially good tables for 12-bit data precision.\n\nFunctions that are specific to 12-bit data precision have a prefix of \"jpeg12_\"\ninstead of \"jpeg_\" and use the following data types and macros:\n\n  * J12SAMPLE instead of JSAMPLE\n  * J12SAMPROW instead of JSAMPROW\n  * J12SAMPARRAY instead of JSAMPARRAY\n  * J12SAMPIMAGE instead of JSAMPIMAGE\n  * MAXJ12SAMPLE instead of MAXJSAMPLE\n  * CENTERJ12SAMPLE instead of CENTERJSAMPLE\n\nFunctions that are specific to 16-bit data precision have a prefix of \"jpeg16_\"\ninstead of \"jpeg_\" and use the following data types and macros:\n\n  * J16SAMPLE instead of JSAMPLE\n  * J16SAMPROW instead of JSAMPROW\n  * J16SAMPARRAY instead of JSAMPARRAY\n  * J16SAMPIMAGE instead of JSAMPIMAGE\n  * MAXJ16SAMPLE instead of MAXJSAMPLE\n  * CENTERJ16SAMPLE instead of CENTERJSAMPLE\n\nThis allows 8-bit, 12-bit, and 16-bit data precision to be used in a single\napplication.  (Refer to example.c).  Arithmetic coding and SIMD acceleration\nare not currently implemented for 12-bit data precision, nor are they\nimplemented for lossless mode with any data precision.\n\nRefer to the descriptions of the data_precision compression and decompression\nparameters below for further information.\n\nThis documentation uses \"J*SAMPLE\", \"J*SAMPROW\", \"J*SAMPARRAY\", and\n\"J*SAMPIMAGE\" to generically refer to the 8-bit-per-sample, 12-bit-per-sample,\nor 16-bit-per-sample data types.\n\n\nOutline of typical usage\n------------------------\n\nThe rough outline of a JPEG compression operation is:\n\n        Allocate and initialize a JPEG compression object\n        Specify the destination for the compressed data (eg, a file)\n        Set parameters for compression, including image size & colorspace\n        jpeg_start_compress(...);\n        while (scan lines remain to be written)\n                jpeg_write_scanlines(...);  /* Use jpeg12_write_scanlines() for\n                                               12-bit data precision and\n                                               jpeg16_write_scanlines() for\n                                               16-bit data precision. */\n        jpeg_finish_compress(...);\n        Release the JPEG compression object\n\nA JPEG compression object holds parameters and working state for the JPEG\nlibrary.  We make creation/destruction of the object separate from starting\nor finishing compression of an image; the same object can be re-used for a\nseries of image compression operations.  This makes it easy to re-use the\nsame parameter settings for a sequence of images.  Re-use of a JPEG object\nalso has important implications for processing abbreviated JPEG datastreams,\nas discussed later.\n\nThe image data to be compressed is supplied to jpeg*_write_scanlines() from\nin-memory buffers.  If the application is doing file-to-file compression,\nreading image data from the source file is the application's responsibility.\nThe library emits compressed data by calling a \"data destination manager\",\nwhich typically will write the data into a file; but the application can\nprovide its own destination manager to do something else.\n\nSimilarly, the rough outline of a JPEG decompression operation is:\n\n        Allocate and initialize a JPEG decompression object\n        Specify the source of the compressed data (eg, a file)\n        Call jpeg_read_header() to obtain image info\n        Set parameters for decompression\n        jpeg_start_decompress(...);\n        while (scan lines remain to be read)\n                jpeg_read_scanlines(...);  /* Use jpeg12_read_scanlines() for\n                                              12-bit data precision and\n                                              jpeg16_read_scanlines() for\n                                              16-bit data precision. */\n        jpeg_finish_decompress(...);\n        Release the JPEG decompression object\n\nThis is comparable to the compression outline except that reading the\ndatastream header is a separate step.  This is helpful because information\nabout the image's size, colorspace, etc is available when the application\nselects decompression parameters.  For example, the application can choose an\noutput scaling ratio that will fit the image into the available screen size.\n\nThe decompression library obtains compressed data by calling a data source\nmanager, which typically will read the data from a file; but other behaviors\ncan be obtained with a custom source manager.  Decompressed data is delivered\ninto in-memory buffers passed to jpeg*_read_scanlines().\n\nIt is possible to abort an incomplete compression or decompression operation\nby calling jpeg_abort(); or, if you do not need to retain the JPEG object,\nsimply release it by calling jpeg_destroy().\n\nJPEG compression and decompression objects are two separate struct types.\nHowever, they share some common fields, and certain routines such as\njpeg_destroy() can work on either type of object.\n\nThe JPEG library has no static variables: all state is in the compression\nor decompression object.  Therefore it is possible to process multiple\ncompression and decompression operations concurrently, using multiple JPEG\nobjects.\n\nBoth compression and decompression can be done in an incremental memory-to-\nmemory fashion, if suitable source/destination managers are used.  See the\nsection on \"I/O suspension\" for more details.\n\n\nBASIC LIBRARY USAGE\n===================\n\nData formats\n------------\n\nBefore diving into procedural details, it is helpful to understand the\nimage data format that the JPEG library expects or returns.\n\nThe standard input image format is a rectangular array of pixels, with each\npixel having the same number of \"component\" or \"sample\" values (color\nchannels).  You must specify how many components there are and the colorspace\ninterpretation of the components.  Most applications will use RGB data\n(three components per pixel) or grayscale data (one component per pixel).\nPLEASE NOTE THAT RGB DATA IS THREE SAMPLES PER PIXEL, GRAYSCALE ONLY ONE.\nA remarkable number of people manage to miss this, only to find that their\nprograms don't work with grayscale JPEG files.\n\nThere is no provision for colormapped input.  JPEG files are always full-color\nor full grayscale (or sometimes another colorspace such as CMYK).  You can\nfeed in a colormapped image by expanding it to full-color format.  However\nJPEG often doesn't work very well with source data that has been colormapped,\nbecause of dithering noise.  This is discussed in more detail in the JPEG FAQ\nand the other references mentioned in the README.ijg file.\n\nPixels are stored by scanlines, with each scanline running from left to\nright.  The component values for each pixel are adjacent in the row; for\nexample, R,G,B,R,G,B,R,G,B,... for 24-bit RGB color.  Each scanline is an\narray of data type JSAMPLE, J12SAMPLE, or J16SAMPLE --- which is typically\n\"unsigned char\", \"short\", or \"unsigned short\" (respectively) unless you've\nchanged jmorecfg.h.\n\nA 2-D array of pixels is formed by making a list of pointers to the starts of\nscanlines; so the scanlines need not be physically adjacent in memory.  Even\nif you process just one scanline at a time, you must make a one-element\npointer array to conform to this structure.  Pointers to J*SAMPLE rows are of\ntype J*SAMPROW, and the pointer to the pointer array is of type J*SAMPARRAY.\n\nThe library accepts or supplies one or more complete scanlines per call.\nIt is not possible to process part of a row at a time.  Scanlines are always\nprocessed top-to-bottom.  You can process an entire image in one call if you\nhave it all in memory, but usually it's simplest to process one scanline at\na time.\n\nFor best results, source data values should have the precision specified by\ncinfo->data_precision (normally 8 bits per sample).  For instance, if you\nchoose to compress data that's only 6 bits/channel, you should left-justify\neach value in a byte before passing it to the compressor.  If you need to\ncompress data that has more than 8 bits/channel, set cinfo->data_precision = 12\nor 16.\n\n\nThe data format returned by the decompressor is the same in all details,\nexcept that colormapped output is supported.  (Again, a JPEG file is never\ncolormapped.  But you can ask the decompressor to perform on-the-fly color\nquantization to deliver colormapped output.)  If you request colormapped\noutput then the returned data array contains a single J*SAMPLE per pixel;\nits value is an index into a color map.  The color map is represented as\na 2-D J*SAMPARRAY in which each row holds the values of one color component,\nthat is, colormap[i][j] is the value of the i'th color component for pixel\nvalue (map index) j.  Note that since the colormap indexes are stored in\nJ*SAMPLEs, the maximum number of colors is limited by the size of J*SAMPLE\n(ie, at most 256 colors for 8-bit data precision and 4096 colors for 12-bit\ndata precision).\n\n\nCompression details\n-------------------\n\nHere we revisit the JPEG compression outline given in the overview.\n\n1. Allocate and initialize a JPEG compression object.\n\nA JPEG compression object is a \"struct jpeg_compress_struct\".  (It also has\na bunch of subsidiary structures which are allocated via malloc(), but the\napplication doesn't control those directly.)  This struct can be just a local\nvariable in the calling routine, if a single routine is going to execute the\nwhole JPEG compression sequence.  Otherwise it can be static or allocated\nfrom malloc().\n\nYou will also need a structure representing a JPEG error handler.  The part\nof this that the library cares about is a \"struct jpeg_error_mgr\".  If you\nare providing your own error handler, you'll typically want to embed the\njpeg_error_mgr struct in a larger structure; this is discussed later under\n\"Error handling\".  For now we'll assume you are just using the default error\nhandler.  The default error handler will print JPEG error/warning messages\non stderr, and it will call exit() if a fatal error occurs.\n\nYou must initialize the error handler structure, store a pointer to it into\nthe JPEG object's \"err\" field, and then call jpeg_create_compress() to\ninitialize the rest of the JPEG object.\n\nTypical code for this step, if you are using the default error handler, is\n\n        struct jpeg_compress_struct cinfo;\n        struct jpeg_error_mgr jerr;\n        ...\n        cinfo.err = jpeg_std_error(&jerr);\n        jpeg_create_compress(&cinfo);\n\njpeg_create_compress allocates a small amount of memory, so it could fail\nif you are out of memory.  In that case it will exit via the error handler;\nthat's why the error handler must be initialized first.\n\n\n2. Specify the destination for the compressed data (eg, a file).\n\nAs previously mentioned, the JPEG library delivers compressed data to a\n\"data destination\" module.  The library includes one data destination\nmodule which knows how to write to a stdio stream.  You can use your own\ndestination module if you want to do something else, as discussed later.\n\nIf you use the standard destination module, you must open the target stdio\nstream beforehand.  Typical code for this step looks like:\n\n        FILE *outfile;\n        ...\n        if ((outfile = fopen(filename, \"wb\")) == NULL) {\n            fprintf(stderr, \"can't open %s\\n\", filename);\n            exit(1);\n        }\n        jpeg_stdio_dest(&cinfo, outfile);\n\nwhere the last line invokes the standard destination module.\n\nWARNING: it is critical that the binary compressed data be delivered to the\noutput file unchanged.  On non-Unix systems the stdio library may perform\nnewline translation or otherwise corrupt binary data.  To suppress this\nbehavior, you may need to use a \"b\" option to fopen (as shown above), or use\nsetmode() or another routine to put the stdio stream in binary mode.  See\ncjpeg.c and djpeg.c for code that has been found to work on many systems.\n\nYou can select the data destination after setting other parameters (step 3),\nif that's more convenient.  You may not change the destination between\ncalling jpeg_start_compress() and jpeg_finish_compress().\n\n\n3. Set parameters for compression, including image size & colorspace.\n\nYou must supply information about the source image by setting the following\nfields in the JPEG object (cinfo structure):\n\n        image_width             Width of image, in pixels\n        image_height            Height of image, in pixels\n        input_components        Number of color channels (samples per pixel)\n        in_color_space          Color space of source image\n\nThe image dimensions are, hopefully, obvious.  JPEG supports image dimensions\nof 1 to 64K pixels in either direction.  The input color space is typically\nRGB or grayscale, and input_components is 3 or 1 accordingly.  (See \"Special\ncolor spaces\", later, for more info.)  The in_color_space field must be\nassigned one of the J_COLOR_SPACE enum constants, typically JCS_RGB or\nJCS_GRAYSCALE.\n\nJPEG has a large number of compression parameters that determine how the\nimage is encoded.  Most applications don't need or want to know about all\nthese parameters.  You can set all the parameters to reasonable defaults by\ncalling jpeg_set_defaults(); then, if there are particular values you want\nto change, you can do so after that.  The \"Compression parameter selection\"\nsection tells about all the parameters.\n\nYou must set in_color_space correctly before calling jpeg_set_defaults(),\nbecause the defaults depend on the source image colorspace.  However the\nother three source image parameters need not be valid until you call\njpeg_start_compress().  There's no harm in calling jpeg_set_defaults() more\nthan once, if that happens to be convenient.\n\nTypical code for a 24-bit RGB source image is\n\n        cinfo.image_width = Width;      /* image width and height, in pixels */\n        cinfo.image_height = Height;\n        cinfo.input_components = 3;     /* # of color components per pixel */\n        cinfo.in_color_space = JCS_RGB; /* colorspace of input image */\n\n        jpeg_set_defaults(&cinfo);\n        /* Make optional parameter settings here */\n\n\n4. jpeg_start_compress(...);\n\nAfter you have established the data destination and set all the necessary\nsource image info and other parameters, call jpeg_start_compress() to begin\na compression cycle.  This will initialize internal state, allocate working\nstorage, and emit the first few bytes of the JPEG datastream header.\n\nTypical code:\n\n        jpeg_start_compress(&cinfo, TRUE);\n\nThe \"TRUE\" parameter ensures that a complete JPEG interchange datastream\nwill be written.  This is appropriate in most cases.  If you think you might\nwant to use an abbreviated datastream, read the section on abbreviated\ndatastreams, below.\n\nOnce you have called jpeg_start_compress(), you may not alter any JPEG\nparameters or other fields of the JPEG object until you have completed\nthe compression cycle.\n\n\n5. while (scan lines remain to be written)\n        jpeg_write_scanlines(...);  /* Use jpeg12_write_scanlines() for 12-bit\n                                       data precision and\n                                       jpeg16_write_scanlines() for 16-bit data\n                                       precision. */\n\nNow write all the required image data by calling jpeg*_write_scanlines()\none or more times.  You can pass one or more scanlines in each call, up\nto the total image height.  In most applications it is convenient to pass\njust one or a few scanlines at a time.  The expected format for the passed\ndata is discussed under \"Data formats\", above.\n\nImage data should be written in top-to-bottom scanline order.\nRec. ITU-T T.81 | ISO/IEC 10918-1 says, \"Applications determine which edges of\na source image are defined as top, bottom, left, and right.\"  However, if you\nwant your files to be compatible with everyone else's, then top-to-bottom order\nmust be used.  If the source data must be read in bottom-to-top order, then you\ncan use the JPEG library's virtual array mechanism to invert the data\nefficiently.  Examples of this can be found in the sample application cjpeg.\n\nThe library maintains a count of the number of scanlines written so far\nin the next_scanline field of the JPEG object.  Usually you can just use\nthis variable as the loop counter, so that the loop test looks like\n\"while (cinfo.next_scanline < cinfo.image_height)\".\n\nCode for this step depends heavily on the way that you store the source data.\nexample.c shows the following code for the case of a full-size 2-D source\narray containing 3-byte RGB pixels:\n\n        JSAMPROW row_pointer[1];        /* pointer to a single row\n                                           Use J12SAMPROW for 12-bit data\n                                           precision and J16SAMPROW for 16-bit\n                                           data precision. */\n\n        while (cinfo.next_scanline < cinfo.image_height) {\n            row_pointer[0] = image_buffer[cinfo.next_scanline];\n            jpeg_write_scanlines(&cinfo, row_pointer, 1);\n                                        /* Use jpeg12_write_scanlines() for\n                                           12-bit data precision and\n                                           jpeg16_write_scanlines() for 16-bit\n                                           data precision. */\n        }\n\njpeg*_write_scanlines() returns the number of scanlines actually written.\nThis will normally be equal to the number passed in, so you can usually\nignore the return value.  It is different in just two cases:\n  * If you try to write more scanlines than the declared image height,\n    the additional scanlines are ignored.\n  * If you use a suspending data destination manager, output buffer overrun\n    will cause the compressor to return before accepting all the passed lines.\n    This feature is discussed under \"I/O suspension\", below.  The normal\n    stdio destination manager will NOT cause this to happen.\nIn any case, the return value is the same as the change in the value of\nnext_scanline.\n\n\n6. jpeg_finish_compress(...);\n\nAfter all the image data has been written, call jpeg_finish_compress() to\ncomplete the compression cycle.  This step is ESSENTIAL to ensure that the\nlast bufferload of data is written to the data destination.\njpeg_finish_compress() also releases working memory associated with the JPEG\nobject.\n\nTypical code:\n\n        jpeg_finish_compress(&cinfo);\n\nIf using the stdio destination manager, don't forget to close the output\nstdio stream (if necessary) afterwards.\n\nIf you have requested a multi-pass operating mode, such as Huffman code\noptimization, jpeg_finish_compress() will perform the additional passes using\ndata buffered by the first pass.  In this case jpeg_finish_compress() may take\nquite a while to complete.  With the default compression parameters, this will\nnot happen.\n\nIt is an error to call jpeg_finish_compress() before writing the necessary\ntotal number of scanlines.  If you wish to abort compression, call\njpeg_abort() as discussed below.\n\nAfter completing a compression cycle, you may dispose of the JPEG object\nas discussed next, or you may use it to compress another image.  In that case\nreturn to step 2, 3, or 4 as appropriate.  If you do not change the\ndestination manager, the new datastream will be written to the same target.\nIf you do not change any JPEG parameters, the new datastream will be written\nwith the same parameters as before.  Note that you can change the input image\ndimensions freely between cycles, but if you change the input colorspace, you\nshould call jpeg_set_defaults() to adjust for the new colorspace; and then\nyou'll need to repeat all of step 3.\n\n\n7. Release the JPEG compression object.\n\nWhen you are done with a JPEG compression object, destroy it by calling\njpeg_destroy_compress().  This will free all subsidiary memory (regardless of\nthe previous state of the object).  Or you can call jpeg_destroy(), which\nworks for either compression or decompression objects --- this may be more\nconvenient if you are sharing code between compression and decompression\ncases.  (Actually, these routines are equivalent except for the declared type\nof the passed pointer.  To avoid gripes from ANSI C compilers, jpeg_destroy()\nshould be passed a j_common_ptr.)\n\nIf you allocated the jpeg_compress_struct structure from malloc(), freeing\nit is your responsibility --- jpeg_destroy() won't.  Ditto for the error\nhandler structure.\n\nTypical code:\n\n        jpeg_destroy_compress(&cinfo);\n\n\n8. Aborting.\n\nIf you decide to abort a compression cycle before finishing, you can clean up\nin either of two ways:\n\n* If you don't need the JPEG object any more, just call\n  jpeg_destroy_compress() or jpeg_destroy() to release memory.  This is\n  legitimate at any point after calling jpeg_create_compress() --- in fact,\n  it's safe even if jpeg_create_compress() fails.\n\n* If you want to re-use the JPEG object, call jpeg_abort_compress(), or call\n  jpeg_abort() which works on both compression and decompression objects.\n  This will return the object to an idle state, releasing any working memory.\n  jpeg_abort() is allowed at any time after successful object creation.\n\nNote that cleaning up the data destination, if required, is your\nresponsibility; neither of these routines will call term_destination().\n(See \"Compressed data handling\", below, for more about that.)\n\njpeg_destroy() and jpeg_abort() are the only safe calls to make on a JPEG\nobject that has reported an error by calling error_exit (see \"Error handling\"\nfor more info).  The internal state of such an object is likely to be out of\nwhack.  Either of these two routines will return the object to a known state.\n\n\nDecompression details\n---------------------\n\nHere we revisit the JPEG decompression outline given in the overview.\n\n1. Allocate and initialize a JPEG decompression object.\n\nThis is just like initialization for compression, as discussed above,\nexcept that the object is a \"struct jpeg_decompress_struct\" and you\ncall jpeg_create_decompress().  Error handling is exactly the same.\n\nTypical code:\n\n        struct jpeg_decompress_struct cinfo;\n        struct jpeg_error_mgr jerr;\n        ...\n        cinfo.err = jpeg_std_error(&jerr);\n        jpeg_create_decompress(&cinfo);\n\n(Both here and in the IJG code, we usually use variable name \"cinfo\" for\nboth compression and decompression objects.)\n\n\n2. Specify the source of the compressed data (eg, a file).\n\nAs previously mentioned, the JPEG library reads compressed data from a \"data\nsource\" module.  The library includes one data source module which knows how\nto read from a stdio stream.  You can use your own source module if you want\nto do something else, as discussed later.\n\nIf you use the standard source module, you must open the source stdio stream\nbeforehand.  Typical code for this step looks like:\n\n        FILE *infile;\n        ...\n        if ((infile = fopen(filename, \"rb\")) == NULL) {\n            fprintf(stderr, \"can't open %s\\n\", filename);\n            exit(1);\n        }\n        jpeg_stdio_src(&cinfo, infile);\n\nwhere the last line invokes the standard source module.\n\nWARNING: it is critical that the binary compressed data be read unchanged.\nOn non-Unix systems the stdio library may perform newline translation or\notherwise corrupt binary data.  To suppress this behavior, you may need to use\na \"b\" option to fopen (as shown above), or use setmode() or another routine to\nput the stdio stream in binary mode.  See cjpeg.c and djpeg.c for code that\nhas been found to work on many systems.\n\nYou may not change the data source between calling jpeg_read_header() and\njpeg_finish_decompress().  If you wish to read a series of JPEG images from\na single source file, you should repeat the jpeg_read_header() to\njpeg_finish_decompress() sequence without reinitializing either the JPEG\nobject or the data source module; this prevents buffered input data from\nbeing discarded.\n\n\n3. Call jpeg_read_header() to obtain image info.\n\nTypical code for this step is just\n\n        jpeg_read_header(&cinfo, TRUE);\n\nThis will read the source datastream header markers, up to the beginning\nof the compressed data proper.  On return, the image dimensions and other\ninfo have been stored in the JPEG object.  The application may wish to\nconsult this information before selecting decompression parameters.\n\nMore complex code is necessary if\n  * A suspending data source is used --- in that case jpeg_read_header()\n    may return before it has read all the header data.  See \"I/O suspension\",\n    below.  The normal stdio source manager will NOT cause this to happen.\n  * Abbreviated JPEG files are to be processed --- see the section on\n    abbreviated datastreams.  Standard applications that deal only in\n    interchange JPEG files need not be concerned with this case either.\n\nIt is permissible to stop at this point if you just wanted to find out the\nimage dimensions and other header info for a JPEG file.  In that case,\ncall jpeg_destroy() when you are done with the JPEG object, or call\njpeg_abort() to return it to an idle state before selecting a new data\nsource and reading another header.\n\n\n4. Set parameters for decompression.\n\njpeg_read_header() sets appropriate default decompression parameters based on\nthe properties of the image (in particular, its colorspace).  However, you\nmay well want to alter these defaults before beginning the decompression.\nFor example, the default is to produce full color output from a color file.\nIf you want colormapped output you must ask for it.  Other options allow the\nreturned image to be scaled and allow various speed/quality tradeoffs to be\nselected.  \"Decompression parameter selection\", below, gives details.\n\nIf the defaults are appropriate, nothing need be done at this step.\n\nNote that all default values are set by each call to jpeg_read_header().\nIf you reuse a decompression object, you cannot expect your parameter\nsettings to be preserved across cycles, as you can for compression.\nYou must set desired parameter values each time.\n\n\n5. jpeg_start_decompress(...);\n\nOnce the parameter values are satisfactory, call jpeg_start_decompress() to\nbegin decompression.  This will initialize internal state, allocate working\nmemory, and prepare for returning data.\n\nTypical code is just\n\n        jpeg_start_decompress(&cinfo);\n\nIf you have requested a multi-pass operating mode, such as 2-pass color\nquantization, jpeg_start_decompress() will do everything needed before data\noutput can begin.  In this case jpeg_start_decompress() may take quite a while\nto complete.  With a single-scan (non progressive) JPEG file and default\ndecompression parameters, this will not happen; jpeg_start_decompress() will\nreturn quickly.\n\nAfter this call, the final output image dimensions, including any requested\nscaling, are available in the JPEG object; so is the selected colormap, if\ncolormapped output has been requested.  Useful fields include\n\n        output_width            image width and height, as scaled\n        output_height\n        out_color_components    # of color components in out_color_space\n        output_components       # of color components returned per pixel\n        colormap                the selected colormap, if any\n        actual_number_of_colors         number of entries in colormap\n\noutput_components is 1 (a colormap index) when quantizing colors; otherwise it\nequals out_color_components.  It is the number of J*SAMPLE values that will be\nemitted per pixel in the output arrays.\n\nTypically you will need to allocate data buffers to hold the incoming image.\nYou will need output_width * output_components J*SAMPLEs per scanline in your\noutput buffer, and a total of output_height scanlines will be returned.\n\nNote: if you are using the JPEG library's internal memory manager to allocate\ndata buffers (as djpeg does), then the manager's protocol requires that you\nrequest large buffers *before* calling jpeg_start_decompress().  This is a\nlittle tricky since the output_XXX fields are not normally valid then.  You\ncan make them valid by calling jpeg_calc_output_dimensions() after setting the\nrelevant parameters (scaling, output color space, and quantization flag).\n\n\n6. while (scan lines remain to be read)\n        jpeg_read_scanlines(...);  /* Use jpeg12_read_scanlines() for 12-bit\n                                      data precision and\n                                      jpeg16_read_scanlines() for 16-bit data\n                                      precision. */\n\nNow you can read the decompressed image data by calling jpeg*_read_scanlines()\none or more times.  At each call, you pass in the maximum number of scanlines\nto be read (ie, the height of your working buffer); jpeg*_read_scanlines()\nwill return up to that many lines.  The return value is the number of lines\nactually read.  The format of the returned data is discussed under \"Data\nformats\", above.  Don't forget that grayscale and color JPEGs will return\ndifferent data formats!\n\nImage data is returned in top-to-bottom scanline order.  If you must write\nout the image in bottom-to-top order, you can use the JPEG library's virtual\narray mechanism to invert the data efficiently.  Examples of this can be\nfound in the sample application djpeg.\n\nThe library maintains a count of the number of scanlines returned so far\nin the output_scanline field of the JPEG object.  Usually you can just use\nthis variable as the loop counter, so that the loop test looks like\n\"while (cinfo.output_scanline < cinfo.output_height)\".  (Note that the test\nshould NOT be against image_height, unless you never use scaling.  The\nimage_height field is the height of the original unscaled image.)\nThe return value always equals the change in the value of output_scanline.\n\nIf you don't use a suspending data source, it is safe to assume that\njpeg*_read_scanlines() reads at least one scanline per call, until the\nbottom of the image has been reached.\n\nIf you use a buffer larger than one scanline, it is NOT safe to assume that\njpeg*_read_scanlines() fills it.  (The current implementation returns only a\nfew scanlines per call, no matter how large a buffer you pass.)  So you must\nalways provide a loop that calls jpeg*_read_scanlines() repeatedly until the\nwhole image has been read.\n\n\n7. jpeg_finish_decompress(...);\n\nAfter all the image data has been read, call jpeg_finish_decompress() to\ncomplete the decompression cycle.  This causes working memory associated\nwith the JPEG object to be released.\n\nTypical code:\n\n        jpeg_finish_decompress(&cinfo);\n\nIf using the stdio source manager, don't forget to close the source stdio\nstream if necessary.\n\nIt is an error to call jpeg_finish_decompress() before reading the correct\ntotal number of scanlines.  If you wish to abort decompression, call\njpeg_abort() as discussed below.\n\nAfter completing a decompression cycle, you may dispose of the JPEG object as\ndiscussed next, or you may use it to decompress another image.  In that case\nreturn to step 2 or 3 as appropriate.  If you do not change the source\nmanager, the next image will be read from the same source.\n\n\n8. Release the JPEG decompression object.\n\nWhen you are done with a JPEG decompression object, destroy it by calling\njpeg_destroy_decompress() or jpeg_destroy().  The previous discussion of\ndestroying compression objects applies here too.\n\nTypical code:\n\n        jpeg_destroy_decompress(&cinfo);\n\n\n9. Aborting.\n\nYou can abort a decompression cycle by calling jpeg_destroy_decompress() or\njpeg_destroy() if you don't need the JPEG object any more, or\njpeg_abort_decompress() or jpeg_abort() if you want to reuse the object.\nThe previous discussion of aborting compression cycles applies here too.\n\n\nPartial image decompression\n---------------------------\n\nPartial image decompression is convenient for performance-critical applications\nthat wish to view only a portion of a large JPEG image without decompressing\nthe whole thing.  It it also useful in memory-constrained environments (such as\non mobile devices.)  This library provides the following functions to support\npartial image decompression:\n\n1. Skipping rows when decompressing\n\n        jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines);\n                /* Use jpeg12_skip_scanlines() for 12-bit data precision. */\n\nThis function provides application programmers with the ability to skip over\nmultiple rows in the JPEG image.\n\nSuspending data sources are not supported by this function.  Calling\njpeg*_skip_scanlines() with a suspending data source will result in undefined\nbehavior.  Two-pass color quantization is also not supported by this function.\nCalling jpeg*_skip_scanlines() with two-pass color quantization enabled will\nresult in an error.\n\njpeg*_skip_scanlines() will not allow skipping past the bottom of the image.\nIf the value of num_lines is large enough to skip past the bottom of the image,\nthen the function will skip to the end of the image instead.\n\nIf the value of num_lines is valid, then jpeg*_skip_scanlines() will always\nskip all of the input rows requested.  There is no need to inspect the return\nvalue of the function in that case.\n\nBest results will be achieved by calling jpeg*_skip_scanlines() for large\nchunks of rows.  The function should be viewed as a way to quickly jump to a\nparticular vertical offset in the JPEG image in order to decode a subset of the\nimage.  Used in this manner, it will provide significant performance\nimprovements.\n\nCalling jpeg*_skip_scanlines() for small values of num_lines has several\npotential drawbacks:\n    1) JPEG decompression occurs in blocks, so if jpeg*_skip_scanlines() is\n       called from the middle of a decompression block, then it is likely that\n       much of the decompression work has already been done for the first\n       couple of rows that need to be skipped.\n    2) When this function returns, it must leave the decompressor in a state\n       such that it is ready to read the next line.  This may involve\n       decompressing a block that must be partially skipped.\nThese issues are especially tricky for cases in which upsampling requires\ncontext rows.  In the worst case, jpeg*_skip_scanlines() will perform similarly\nto jpeg*_read_scanlines() (since it will actually call jpeg*_read_scanlines().)\n\n2. Decompressing partial scanlines\n\n        jpeg_crop_scanline (j_decompress_ptr cinfo, JDIMENSION *xoffset,\n                            JDIMENSION *width)\n                /* Use jpeg12_crop_scanline() for 12-bit data precision. */\n\nThis function provides application programmers with the ability to decompress\nonly a portion of each row in the JPEG image.  It must be called after\njpeg_start_decompress() and before any calls to jpeg*_read_scanlines() or\njpeg*_skip_scanlines().\n\nIf xoffset and width do not form a valid subset of the image row, then this\nfunction will generate an error.  Note that if the output image is scaled, then\nxoffset and width are relative to the scaled image dimensions.\n\nxoffset and width are passed by reference because xoffset must fall on an iMCU\nboundary.  If it doesn't, then it will be moved left to the nearest iMCU\nboundary, and width will be increased accordingly.  If the calling program does\nnot like the adjusted values of xoffset and width, then it can call\njpeg*_crop_scanline() again with new values (for instance, if it wants to move\nxoffset to the nearest iMCU boundary to the right instead of to the left.)\n\nAfter calling this function, cinfo->output_width will be set to the adjusted\nwidth.  This value should be used when allocating an output buffer to pass to\njpeg*_read_scanlines().\n\nThe output image from a partial-width decompression will be identical to the\ncorresponding image region from a full decode, with one exception:  The \"fancy\"\n(smooth) h2v2 (4:2:0) and h2v1 (4:2:2) upsampling algorithms fill in the\nmissing chroma components by averaging the chroma components from neighboring\npixels, except on the right and left edges of the image (where there are no\nneighboring pixels.)  When performing a partial-width decompression, these\n\"fancy\" upsampling algorithms may treat the left and right edges of the partial\nimage region as if they are the left and right edges of the image, meaning that\nthe upsampling algorithm may be simplified.  The result is that the pixels on\nthe left or right edge of the partial image may not be exactly identical to the\ncorresponding pixels in the original image.\n\n\nMechanics of usage: include files, linking, etc\n-----------------------------------------------\n\nApplications using the JPEG library should include the header file jpeglib.h\nto obtain declarations of data types and routines.  Before including\njpeglib.h, include system headers that define at least the typedefs FILE and\nsize_t.  On ANSI-conforming systems, including <stdio.h> is sufficient; on\nolder Unix systems, you may need <sys/types.h> to define size_t.\n\nIf the application needs to refer to individual JPEG library error codes, also\ninclude jerror.h to define those symbols.\n\njpeglib.h indirectly includes the files jconfig.h and jmorecfg.h.  If you are\ninstalling the JPEG header files in a system directory, you will want to\ninstall all four files: jpeglib.h, jerror.h, jconfig.h, jmorecfg.h.\n\nThe most convenient way to include the JPEG code into your executable program\nis to prepare a library file (\"libjpeg.a\", or a corresponding name on non-Unix\nmachines) and reference it at your link step.  If you use only half of the\nlibrary (only compression or only decompression), only that much code will be\nincluded from the library, unless your linker is hopelessly brain-damaged.\nThe supplied build system builds libjpeg.a automatically.\n\nIt may be worth pointing out that the core JPEG library does not actually\nrequire the stdio library: only the default source/destination managers and\nerror handler need it.  You can use the library in a stdio-less environment\nif you replace those modules and use jmemnobs.c (or another memory manager of\nyour own devising).  More info about the minimum system library requirements\nmay be found in jinclude.h.\n\n\nADVANCED FEATURES\n=================\n\nCompression parameter selection\n-------------------------------\n\nThis section describes all the optional parameters you can set for JPEG\ncompression, as well as the \"helper\" routines provided to assist in this\ntask.  Proper setting of some parameters requires detailed understanding\nof the JPEG standard; if you don't know what a parameter is for, it's best\nnot to mess with it!  See REFERENCES in the README.ijg file for pointers to\nmore info about JPEG.\n\nIt's a good idea to call jpeg_set_defaults() first, even if you plan to set\nall the parameters; that way your code is more likely to work with future JPEG\nlibraries that have additional parameters.  For the same reason, we recommend\nyou use a helper routine where one is provided, in preference to twiddling\ncinfo fields directly.\n\nThe helper routines are:\n\njpeg_set_defaults (j_compress_ptr cinfo)\n        This routine sets all JPEG parameters to reasonable defaults, using\n        only the input image's color space (field in_color_space, which must\n        already be set in cinfo).  Many applications will only need to use\n        this routine and perhaps jpeg_set_quality().\n\njpeg_set_colorspace (j_compress_ptr cinfo, J_COLOR_SPACE colorspace)\n        Sets the JPEG file's colorspace (field jpeg_color_space) as specified,\n        and sets other color-space-dependent parameters appropriately.  See\n        \"Special color spaces\", below, before using this.  A large number of\n        parameters, including all per-component parameters, are set by this\n        routine; if you want to twiddle individual parameters you should call\n        jpeg_set_colorspace() before rather than after.\n\njpeg_default_colorspace (j_compress_ptr cinfo)\n        Selects an appropriate JPEG colorspace based on cinfo->in_color_space,\n        and calls jpeg_set_colorspace().  This is actually a subroutine of\n        jpeg_set_defaults().  It's broken out in case you want to change\n        just the colorspace-dependent JPEG parameters.\n\njpeg_set_quality (j_compress_ptr cinfo, int quality, boolean force_baseline)\n        Constructs JPEG quantization tables appropriate for the indicated\n        quality setting.  The quality value is expressed on the 0..100 scale\n        recommended by IJG (cjpeg's \"-quality\" switch uses this routine).\n        Note that the exact mapping from quality values to tables may change\n        in future IJG releases as more is learned about DCT quantization.\n        If the force_baseline parameter is TRUE, then the quantization table\n        entries are constrained to the range 1..255 for full JPEG baseline\n        compatibility.  In the current implementation, this only makes a\n        difference for quality settings below 25, and it effectively prevents\n        very small/low-quality files from being generated.  The IJG decoder\n        is capable of reading the non-baseline files generated at low quality\n        settings when force_baseline is FALSE, but other decoders may not be.\n\njpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,\n                         boolean force_baseline)\n        Same as jpeg_set_quality() except that the generated tables are the\n        sample tables given in Annex K (Clause K.1) of\n        Rec. ITU-T T.81 (1992) | ISO/IEC 10918-1:1994, multiplied by the\n        specified scale factor (which is expressed as a percentage; thus\n        scale_factor = 100 reproduces the spec's tables).  Note that larger\n        scale factors give lower quality.  This entry point is useful for\n        conforming to the Adobe PostScript DCT conventions, but we do not\n        recommend linear scaling as a user-visible quality scale otherwise.\n        force_baseline again constrains the computed table entries to 1..255.\n\nint jpeg_quality_scaling (int quality)\n        Converts a value on the IJG-recommended quality scale to a linear\n        scaling percentage.  Note that this routine may change or go away\n        in future releases --- IJG may choose to adopt a scaling method that\n        can't be expressed as a simple scalar multiplier, in which case the\n        premise of this routine collapses.  Caveat user.\n\njpeg_default_qtables (j_compress_ptr cinfo, boolean force_baseline)\n        [libjpeg v7+ API/ABI emulation only]\n        Set default quantization tables with linear q_scale_factor[] values\n        (see below).\n\njpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl,\n                      const unsigned int *basic_table,\n                      int scale_factor, boolean force_baseline)\n        Allows an arbitrary quantization table to be created.  which_tbl\n        indicates which table slot to fill.  basic_table points to an array\n        of 64 unsigned ints given in normal array order.  These values are\n        multiplied by scale_factor/100 and then clamped to the range 1..65535\n        (or to 1..255 if force_baseline is TRUE).\n        CAUTION: prior to library version 6a, jpeg_add_quant_table expected\n        the basic table to be given in JPEG zigzag order.  If you need to\n        write code that works with either older or newer versions of this\n        routine, you must check the library version number.  Something like\n        \"#if JPEG_LIB_VERSION >= 61\" is the right test.\n\njpeg_simple_progression (j_compress_ptr cinfo)\n        Generates a default scan script for writing a progressive-JPEG file.\n        This is the recommended method of creating a progressive file,\n        unless you want to make a custom scan sequence.  You must ensure that\n        the JPEG color space is set correctly before calling this routine.\n\njpeg_enable_lossless (j_compress_ptr cinfo, int predictor_selection_value,\n                      int point_transform)\n        Enables lossless mode with the specified predictor selection value\n        (1 - 7) and optional point transform (0 - {precision}-1, where\n        {precision} is the JPEG data precision).  A point transform value of 0\n        is necessary in order to create a fully lossless JPEG image.  (A\n        non-zero point transform value right-shifts the input samples by the\n        specified number of bits, which is effectively a form of lossy color\n        quantization.)  In most cases, lossless mode is considerably slower\n        than, and does not compress as effectively as, lossy mode.  Thus, it is\n        typically used only for applications that require mathematically\n        lossless compression.  Note that the following features will be\n        unavailable when compressing or decompressing lossless JPEG images:\n          * Partial image decompression\n          * Quality/quantization table selection\n          * DCT/IDCT algorithm selection\n          * Smoothing\n          * Downsampling/upsampling\n          * Color space conversion (the JPEG image will use the same color\n            space as the input image)\n          * Color quantization\n          * IDCT scaling\n          * Raw (downsampled) data input/output\n          * Transcoding of DCT coefficients\n        Any parameters used to enable or configure those features will be\n        ignored.\n\n        Lossless mode shares no algorithms with lossy mode.  Instead, it uses\n        differential pulse-code modulation (DPCM), an algorithm whereby each\n        sample is encoded as the difference between the sample's value and a\n        \"predictor\", which is based on the values of neighboring samples.  If\n        Ra is the sample immediately to the left of the current sample, Rb is\n        the sample immediately above the current sample, and Rc is the sample\n        diagonally to the left and above the current sample, then the\n        relationship between the predictor selection value and the predictor is\n        as follows:\n\n        PSV  Predictor\n        --------------\n        1    Ra\n        2    Rb\n        3    Rc\n        4    Ra + Rb  Rc\n        5    Ra + (Rb  Rc) / 2\n        6    Rb + (Ra  Rc) / 2\n        7    (Ra + Rb) / 2\n\n        Predictors 1-3 are 1-dimensional predictors, whereas Predictors 4-7 are\n        2-dimensional predictors.  The best predictor for a particular image\n        depends on the image.\n\n\nCompression parameters (cinfo fields) include:\n\nboolean arith_code\n        If TRUE, use arithmetic coding.\n        If FALSE, use Huffman coding.\n\nint data_precision\n        To create a 12-bit-per-sample JPEG file, set data_precision to 12 prior\n        to calling jpeg_start_compress() or using the memory manager, then use\n        jpeg12_write_scanlines() or jpeg12_write_raw_data() instead of\n        jpeg_write_scanlines() or jpeg_write_raw_data().  To create a\n        16-bit-per-sample lossless JPEG file, set data_precision to 16 prior to\n        calling jpeg_start_compress() or using the memory manager, then use\n        jpeg16_write_scanlines() instead of jpeg_write_scanlines().  Note that\n        16-bit data precision requires lossless mode.  (See\n        jpeg_enable_lossless().)\n\nJ_DCT_METHOD dct_method\n        Selects the algorithm used for the DCT step.  Choices are:\n                JDCT_ISLOW: accurate integer method\n                JDCT_IFAST: less accurate integer method [legacy feature]\n                JDCT_FLOAT: floating-point method [legacy feature]\n                JDCT_DEFAULT: default method (normally JDCT_ISLOW)\n                JDCT_FASTEST: fastest method (normally JDCT_IFAST)\n        When the Independent JPEG Group's software was first released in 1991,\n        the compression time for a 1-megapixel JPEG image on a mainstream PC\n        was measured in minutes.  Thus, JDCT_IFAST provided noticeable\n        performance benefits.  On modern CPUs running libjpeg-turbo, however,\n        the compression time for a 1-megapixel JPEG image is measured in\n        milliseconds, and thus the performance benefits of JDCT_IFAST are much\n        less noticeable.  On modern x86/x86-64 CPUs that support AVX2\n        instructions, JDCT_IFAST and JDCT_ISLOW have similar performance.  On\n        other types of CPUs, JDCT_IFAST is generally about 5-15% faster than\n        JDCT_ISLOW.\n\n        For quality levels of 90 and below, there should be little or no\n        perceptible quality difference between the two algorithms.  For quality\n        levels above 90, however, the difference between JDCT_IFAST and\n        JDCT_ISLOW becomes more pronounced.  With quality=97, for instance,\n        JDCT_IFAST incurs generally about a 1-3 dB loss in PSNR relative to\n        JDCT_ISLOW, but this can be larger for some images.  Do not use\n        JDCT_IFAST with quality levels above 97.  The algorithm often\n        degenerates at quality=98 and above and can actually produce a more\n        lossy image than if lower quality levels had been used.  Also, in\n        libjpeg-turbo, JDCT_IFAST is not fully accelerated for quality levels\n        above 97, so it will be slower than JDCT_ISLOW.\n\n        JDCT_FLOAT does not produce significantly more accurate results than\n        JDCT_ISLOW, and it is much slower.  JDCT_FLOAT may also give different\n        results on different machines due to varying roundoff behavior, whereas\n        the integer methods should give the same results on all machines.\n\nJ_COLOR_SPACE jpeg_color_space\nint num_components\n        The JPEG color space and corresponding number of components; see\n        \"Special color spaces\", below, for more info.  We recommend using\n        jpeg_set_color_space() if you want to change these.\n\nboolean optimize_coding\n        TRUE causes the compressor to compute optimal Huffman coding tables\n        for the image.  This requires an extra pass over the data and\n        therefore costs a good deal of space and time.  The default is\n        FALSE, which tells the compressor to use the supplied or default\n        Huffman tables.  In most cases optimal tables save only a few percent\n        of file size compared to the default tables.  Note that when this is\n        TRUE, you need not supply Huffman tables at all, and any you do\n        supply will be overwritten.  Optimal Huffman tables are always\n        computed, and this parameter has no effect, in progressive mode or\n        lossless mode or with 12-bit data precision (unless Huffman tables have\n        been supplied.)  This parameter also has no effect when using\n        arithmetic coding.\n\nunsigned int restart_interval\nint restart_in_rows\n        To emit restart markers in the JPEG file, set one of these nonzero.\n        Set restart_interval to specify the exact interval in MCUs.  Set\n        restart_in_rows to specify the interval in MCU rows.  (If\n        restart_in_rows is not 0, then restart_interval is set after the image\n        width in MCUs is computed.)  Defaults are zero (no restarts).  One\n        restart marker per MCU row is often a good choice.  NOTE: the overhead\n        of restart markers is higher in grayscale JPEG files than in color\n        files, and MUCH higher in progressive JPEGs.  If you use restarts, you\n        may want to use larger intervals in those cases.\n\nconst jpeg_scan_info *scan_info\nint num_scans\n        By default, scan_info is NULL; this causes the compressor to write a\n        single-scan sequential JPEG file.  If not NULL, scan_info points to\n        an array of scan definition records of length num_scans.  The\n        compressor will then write a JPEG file having one scan for each scan\n        definition record.  This is used to generate noninterleaved or\n        progressive JPEG files.  The library checks that the scan array\n        defines a valid JPEG scan sequence.  (jpeg_simple_progression creates\n        a suitable scan definition array for progressive JPEG.)  This is\n        discussed further under \"Progressive JPEG support\".\n\nint smoothing_factor\n        If non-zero, the input image is smoothed; the value should be 1 for\n        minimal smoothing to 100 for maximum smoothing.  Consult jcsample.c\n        for details of the smoothing algorithm.  The default is zero.\n\nboolean write_JFIF_header\n        If TRUE, a JFIF APP0 marker is emitted.  jpeg_set_defaults() and\n        jpeg_set_colorspace() set this TRUE if a JFIF-legal JPEG color space\n        (ie, YCbCr or grayscale) is selected, otherwise FALSE.\n\nUINT8 JFIF_major_version\nUINT8 JFIF_minor_version\n        The version number to be written into the JFIF marker.\n        jpeg_set_defaults() initializes the version to 1.01 (major=minor=1).\n        You should set it to 1.02 (major=1, minor=2) if you plan to write\n        any JFIF 1.02 extension markers.\n\nUINT8 density_unit\nUINT16 X_density\nUINT16 Y_density\n        The resolution information to be written into the JFIF marker;\n        not used otherwise.  density_unit may be 0 for unknown,\n        1 for dots/inch, or 2 for dots/cm.  The default values are 0,1,1\n        indicating square pixels of unknown size.\n\nboolean write_Adobe_marker\n        If TRUE, an Adobe APP14 marker is emitted.  jpeg_set_defaults() and\n        jpeg_set_colorspace() set this TRUE if JPEG color space RGB, CMYK,\n        or YCCK is selected, otherwise FALSE.  It is generally a bad idea\n        to set both write_JFIF_header and write_Adobe_marker.  In fact,\n        you probably shouldn't change the default settings at all --- the\n        default behavior ensures that the JPEG file's color space can be\n        recognized by the decoder.\n\nJQUANT_TBL *quant_tbl_ptrs[NUM_QUANT_TBLS]\n        Pointers to coefficient quantization tables, one per table slot,\n        or NULL if no table is defined for a slot.  Usually these should\n        be set via one of the above helper routines; jpeg_add_quant_table()\n        is general enough to define any quantization table.  The other\n        routines will set up table slot 0 for luminance quality and table\n        slot 1 for chrominance.\n\nint q_scale_factor[NUM_QUANT_TBLS]\n        [libjpeg v7+ API/ABI emulation only]\n        Linear quantization scaling factors (0-100, default 100)\n        for use with jpeg_default_qtables().\n        See rdswitch.c and cjpeg.c for an example of usage.\n        Note that the q_scale_factor[] values use \"linear\" scales, so JPEG\n        quality levels chosen by the user must be converted to these scales\n        using jpeg_quality_scaling().  Here is an example that corresponds to\n        cjpeg -quality 90,70:\n\n                jpeg_set_defaults(cinfo);\n\n                /* Set luminance quality 90. */\n                cinfo->q_scale_factor[0] = jpeg_quality_scaling(90);\n                /* Set chrominance quality 70. */\n                cinfo->q_scale_factor[1] = jpeg_quality_scaling(70);\n\n                jpeg_default_qtables(cinfo, force_baseline);\n\n        CAUTION: Setting separate quality levels for chrominance and luminance\n        is mainly only useful if chrominance subsampling is disabled.  2x2\n        chrominance subsampling (AKA \"4:2:0\") is the default, but you can\n        explicitly disable subsampling as follows:\n\n                cinfo->comp_info[0].v_samp_factor = 1;\n                cinfo->comp_info[0].h_samp_factor = 1;\n\nJHUFF_TBL *dc_huff_tbl_ptrs[NUM_HUFF_TBLS]\nJHUFF_TBL *ac_huff_tbl_ptrs[NUM_HUFF_TBLS]\n        Pointers to Huffman coding tables, one per table slot, or NULL if\n        no table is defined for a slot.  Slots 0 and 1 are filled with the\n        JPEG sample tables by jpeg_set_defaults().  If you need to allocate\n        more table structures, jpeg_alloc_huff_table() may be used.\n        Note that optimal Huffman tables can be computed for an image\n        by setting optimize_coding, as discussed above; there's seldom\n        any need to mess with providing your own Huffman tables.\n\n\n[libjpeg v7+ API/ABI emulation only]\nThe actual dimensions of the JPEG image that will be written to the file are\ngiven by the following fields.  These are computed from the input image\ndimensions and the compression parameters by jpeg_start_compress().  You can\nalso call jpeg_calc_jpeg_dimensions() to obtain the values that will result\nfrom the current parameter settings.  This can be useful if you are trying\nto pick a scaling ratio that will get close to a desired target size.\n\nJDIMENSION jpeg_width           Actual dimensions of output image.\nJDIMENSION jpeg_height\n\n\nPer-component parameters are stored in the struct cinfo.comp_info[i] for\ncomponent number i.  Note that components here refer to components of the\nJPEG color space, *not* the source image color space.  A suitably large\ncomp_info[] array is allocated by jpeg_set_defaults(); if you choose not\nto use that routine, it's up to you to allocate the array.\n\nint component_id\n        The one-byte identifier code to be recorded in the JPEG file for\n        this component.  For the standard color spaces, we recommend you\n        leave the default values alone.\n\nint h_samp_factor\nint v_samp_factor\n        Horizontal and vertical sampling factors for the component; must\n        be 1..4 according to the JPEG standard.  Note that larger sampling\n        factors indicate a higher-resolution component; many people find\n        this behavior quite unintuitive.  The default values are 2,2 for\n        luminance components and 1,1 for chrominance components, except\n        for grayscale where 1,1 is used.\n\nint quant_tbl_no\n        Quantization table number for component.  The default value is\n        0 for luminance components and 1 for chrominance components.\n\nint dc_tbl_no\nint ac_tbl_no\n        DC and AC entropy coding table numbers.  The default values are\n        0 for luminance components and 1 for chrominance components.\n\nint component_index\n        Must equal the component's index in comp_info[].  (Beginning in\n        release v6, the compressor library will fill this in automatically;\n        you don't have to.)\n\n\nDecompression parameter selection\n---------------------------------\n\nDecompression parameter selection is somewhat simpler than compression\nparameter selection, since all of the JPEG internal parameters are\nrecorded in the source file and need not be supplied by the application.\n(Unless you are working with abbreviated files, in which case see\n\"Abbreviated datastreams\", below.)  Decompression parameters control\nthe postprocessing done on the image to deliver it in a format suitable\nfor the application's use.  Many of the parameters control speed/quality\ntradeoffs, in which faster decompression may be obtained at the price of\na poorer-quality image.  The defaults select the highest-quality (slowest)\nprocessing.\n\nThe following fields in the JPEG object are set by jpeg_read_header() and\nmay be useful to the application in choosing decompression parameters:\n\nint data_precision                      Data precision (bits per sample)\n        If data_precision is 12, then use jpeg12_read_scanlines(),\n        jpeg12_skip_scanlines(), jpeg12_crop_scanline(), and/or\n        jpeg12_read_raw_data() instead of jpeg_read_scanlines(),\n        jpeg_skip_scanlines(), jpeg_crop_scanline(), and/or\n        jpeg_read_raw_data().  If data_precision is 16, then use\n        jpeg16_read_scanlines() instead of jpeg_read_scanlines().\n\nJDIMENSION image_width                  Width and height of image\nJDIMENSION image_height\nint num_components                      Number of color components\nJ_COLOR_SPACE jpeg_color_space          Colorspace of image\nboolean saw_JFIF_marker                 TRUE if a JFIF APP0 marker was seen\n  UINT8 JFIF_major_version              Version information from JFIF marker\n  UINT8 JFIF_minor_version\n  UINT8 density_unit                    Resolution data from JFIF marker\n  UINT16 X_density\n  UINT16 Y_density\nboolean saw_Adobe_marker                TRUE if an Adobe APP14 marker was seen\n  UINT8 Adobe_transform                 Color transform code from Adobe marker\n\nThe JPEG color space, unfortunately, is something of a guess since the JPEG\nstandard proper does not provide a way to record it.  In practice most files\nadhere to the JFIF or Adobe conventions, and the decoder will recognize these\ncorrectly.  See \"Special color spaces\", below, for more info.\n\n\nThe decompression parameters that determine the basic properties of the\nreturned image are:\n\nJ_COLOR_SPACE out_color_space\n        Output color space.  jpeg_read_header() sets an appropriate default\n        based on jpeg_color_space; typically it will be RGB or grayscale.\n        The application can change this field to request output in a different\n        colorspace.  For example, set it to JCS_GRAYSCALE to get grayscale\n        output from a color file.  Note that not all possible color space\n        transforms are currently implemented.\n\nunsigned int scale_num, scale_denom\n        Scale the image by the fraction scale_num/scale_denom.  Default is\n        1/1, or no scaling.  Currently, the only supported scaling ratios\n        are M/8 with all M from 1 to 16, or any reduced fraction thereof (such\n        as 1/2, 3/4, etc.)  (The library design allows for arbitrary\n        scaling ratios but this is not likely to be implemented any time soon.)\n\nboolean quantize_colors\n        [legacy feature]\n        If set TRUE, colormapped output will be delivered.  Default is FALSE,\n        meaning that full-color output will be delivered.\n\nThe next three parameters are relevant only if quantize_colors is TRUE.\n\nint desired_number_of_colors\n        [legacy feature]\n        Maximum number of colors to use in generating a library-supplied color\n        map (the actual number of colors is returned in a different field).\n        Default 256.  Ignored when the application supplies its own color map.\n\nboolean two_pass_quantize\n        [legacy feature]\n        If TRUE, an extra pass over the image is made to select a custom color\n        map for the image.  This usually looks a lot better than the one-size-\n        fits-all colormap that is used otherwise.  Default is TRUE.  Ignored\n        when the application supplies its own color map.\n\nJ_DITHER_MODE dither_mode\n        [legacy feature]\n        Selects color dithering method.  Supported values are:\n                JDITHER_NONE    no dithering: faster, very low quality\n                JDITHER_ORDERED ordered dither: moderate speed and quality\n                JDITHER_FS      Floyd-Steinberg dither: slower, high quality\n        Default is JDITHER_FS.  (At present, ordered dither is implemented\n        only in the single-pass, standard-colormap case.  If you ask for\n        ordered dither when two_pass_quantize is TRUE or when you supply\n        an external color map, you'll get F-S dithering.)\n\nWhen quantize_colors is TRUE, the target color map is described by the next\ntwo fields.  colormap is set to NULL by jpeg_read_header().  The application\ncan supply a color map by setting colormap non-NULL and setting\nactual_number_of_colors to the map size.  Otherwise, jpeg_start_decompress()\nselects a suitable color map and sets these two fields itself.\n[Implementation restriction: at present, an externally supplied colormap is\nonly accepted for 3-component output color spaces.]\n\nJSAMPARRAY colormap\n        [legacy feature]\n        The color map, represented as a 2-D pixel array of out_color_components\n        rows and actual_number_of_colors columns.  Ignored if not quantizing.\n        CAUTION: if the JPEG library creates its own colormap, the storage\n        pointed to by this field is released by jpeg_finish_decompress().\n        Copy the colormap somewhere else first, if you want to save it.\n        CAUTION: if data_precision is 12, then this is actually a J12SAMPARRAY,\n        so it must be type-cast in order to read/write 12-bit samples from/to\n        the array.\n\nint actual_number_of_colors\n        [legacy feature]\n        The number of colors in the color map.\n\nAdditional decompression parameters that the application may set include:\n\nJ_DCT_METHOD dct_method\n        Selects the algorithm used for the DCT step.  Choices are:\n                JDCT_ISLOW: accurate integer method\n                JDCT_IFAST: less accurate integer method [legacy feature]\n                JDCT_FLOAT: floating-point method [legacy feature]\n                JDCT_DEFAULT: default method (normally JDCT_ISLOW)\n                JDCT_FASTEST: fastest method (normally JDCT_IFAST)\n        When the Independent JPEG Group's software was first released in 1991,\n        the decompression time for a 1-megapixel JPEG image on a mainstream PC\n        was measured in minutes.  Thus, JDCT_IFAST provided noticeable\n        performance benefits.  On modern CPUs running libjpeg-turbo, however,\n        the decompression time for a 1-megapixel JPEG image is measured in\n        milliseconds, and thus the performance benefits of JDCT_IFAST are much\n        less noticeable.  On modern x86/x86-64 CPUs that support AVX2\n        instructions, JDCT_IFAST and JDCT_ISLOW have similar performance.  On\n        other types of CPUs, JDCT_IFAST is generally about 5-15% faster than\n        JDCT_ISLOW.\n\n        If the JPEG image was compressed using a quality level of 85 or below,\n        then there should be little or no perceptible quality difference\n        between the two algorithms.  When decompressing images that were\n        compressed using quality levels above 85, however, the difference\n        between JDCT_IFAST and JDCT_ISLOW becomes more pronounced.  With images\n        compressed using quality=97, for instance, JDCT_IFAST incurs generally\n        about a 4-6 dB loss in PSNR relative to JDCT_ISLOW, but this can be\n        larger for some images.  If you can avoid it, do not use JDCT_IFAST\n        when decompressing images that were compressed using quality levels\n        above 97.  The algorithm often degenerates for such images and can\n        actually produce a more lossy output image than if the JPEG image had\n        been compressed using lower quality levels.\n\n        JDCT_FLOAT does not produce significantly more accurate results than\n        JDCT_ISLOW, and it is much slower.  JDCT_FLOAT may also give different\n        results on different machines due to varying roundoff behavior, whereas\n        the integer methods should give the same results on all machines.\n\nboolean do_fancy_upsampling\n        If TRUE, do careful upsampling of chroma components.  If FALSE,\n        a faster but sloppier method is used.  Default is TRUE.  The visual\n        impact of the sloppier method is often very small.\n\nboolean do_block_smoothing\n        If TRUE, interblock smoothing is applied in early stages of decoding\n        progressive JPEG files; if FALSE, not.  Default is TRUE.  Early\n        progression stages look \"fuzzy\" with smoothing, \"blocky\" without.\n        In any case, block smoothing ceases to be applied after the first few\n        AC coefficients are known to full accuracy, so it is relevant only\n        when using buffered-image mode for progressive images.\n\nboolean enable_1pass_quant\nboolean enable_external_quant\nboolean enable_2pass_quant\n        [legacy feature]\n        These are significant only in buffered-image mode, which is\n        described in its own section below.\n\n\nThe output image dimensions are given by the following fields.  These are\ncomputed from the source image dimensions and the decompression parameters\nby jpeg_start_decompress().  You can also call jpeg_calc_output_dimensions()\nto obtain the values that will result from the current parameter settings.\nThis can be useful if you are trying to pick a scaling ratio that will get\nclose to a desired target size.  It's also important if you are using the\nJPEG library's memory manager to allocate output buffer space, because you\nare supposed to request such buffers *before* jpeg_start_decompress().\n\nJDIMENSION output_width         Actual dimensions of output image.\nJDIMENSION output_height\nint out_color_components        Number of color components in out_color_space.\nint output_components           Number of color components returned.\nint rec_outbuf_height           Recommended height of scanline buffer.\n\nWhen quantizing colors, output_components is 1, indicating a single color map\nindex per pixel.  Otherwise it equals out_color_components.  The output arrays\nare required to be output_width * output_components J*SAMPLEs wide.\n\nrec_outbuf_height is the recommended minimum height (in scanlines) of the\nbuffer passed to jpeg*_read_scanlines().  If the buffer is smaller, the\nlibrary will still work, but time will be wasted due to unnecessary data\ncopying.  In high-quality modes, rec_outbuf_height is always 1, but some\nfaster, lower-quality modes set it to larger values (typically 2 to 4).\nIf you are going to ask for a high-speed processing mode, you may as well\ngo to the trouble of honoring rec_outbuf_height so as to avoid data copying.\n(An output buffer larger than rec_outbuf_height lines is OK, but won't\nprovide any material speed improvement over that height.)\n\n\nSpecial color spaces\n--------------------\n\nThe JPEG standard itself is \"color blind\" and doesn't specify any particular\ncolor space.  It is customary to convert color data to a luminance/chrominance\ncolor space before compressing, since this permits greater compression.  The\nexisting de-facto JPEG file format standards specify YCbCr or grayscale data\n(JFIF), or grayscale, RGB, YCbCr, CMYK, or YCCK (Adobe).  For special\napplications such as multispectral images, other color spaces can be used,\nbut it must be understood that such files will be unportable.\n\nThe JPEG library can handle the most common colorspace conversions (namely\nRGB <=> YCbCr and CMYK <=> YCCK).  It can also deal with data of an unknown\ncolor space, passing it through without conversion.  If you deal extensively\nwith an unusual color space, you can easily extend the library to understand\nadditional color spaces and perform appropriate conversions.\n\nFor compression, the source data's color space is specified by field\nin_color_space.  This is transformed to the JPEG file's color space given\nby jpeg_color_space.  jpeg_set_defaults() chooses a reasonable JPEG color\nspace depending on in_color_space, but you can override this by calling\njpeg_set_colorspace().  Of course you must select a supported transformation.\njccolor.c currently supports the following transformations:\n        RGB => YCbCr\n        RGB => GRAYSCALE\n        YCbCr => GRAYSCALE\n        CMYK => YCCK\nplus the null transforms: GRAYSCALE => GRAYSCALE, RGB => RGB,\nYCbCr => YCbCr, CMYK => CMYK, YCCK => YCCK, and UNKNOWN => UNKNOWN.\n\nThe de-facto file format standards (JFIF and Adobe) specify APPn markers that\nindicate the color space of the JPEG file.  It is important to ensure that\nthese are written correctly, or omitted if the JPEG file's color space is not\none of the ones supported by the de-facto standards.  jpeg_set_colorspace()\nwill set the compression parameters to include or omit the APPn markers\nproperly, so long as it is told the truth about the JPEG color space.\nFor example, if you are writing some random 3-component color space without\nconversion, don't try to fake out the library by setting in_color_space and\njpeg_color_space to JCS_YCbCr; use JCS_UNKNOWN.  You may want to write an\nAPPn marker of your own devising to identify the colorspace --- see \"Special\nmarkers\", below.\n\nWhen told that the color space is UNKNOWN, the library will default to using\nluminance-quality compression parameters for all color components.  You may\nwell want to change these parameters.  See the source code for\njpeg_set_colorspace(), in jcparam.c, for details.\n\nFor decompression, the JPEG file's color space is given in jpeg_color_space,\nand this is transformed to the output color space out_color_space.\njpeg_read_header's setting of jpeg_color_space can be relied on if the file\nconforms to JFIF or Adobe conventions, but otherwise it is no better than a\nguess.  If you know the JPEG file's color space for certain, you can override\njpeg_read_header's guess by setting jpeg_color_space.  jpeg_read_header also\nselects a default output color space based on (its guess of) jpeg_color_space;\nset out_color_space to override this.  Again, you must select a supported\ntransformation.  jdcolor.c currently supports\n        YCbCr => RGB\n        YCbCr => GRAYSCALE\n        RGB => GRAYSCALE\n        GRAYSCALE => RGB\n        YCCK => CMYK\nas well as the null transforms.  (Since GRAYSCALE=>RGB is provided, an\napplication can force grayscale JPEGs to look like color JPEGs if it only\nwants to handle one case.)\n\nThe two-pass color quantizer, jquant2.c, is specialized to handle RGB data\n(it weights distances appropriately for RGB colors).  You'll need to modify\nthe code if you want to use it for non-RGB output color spaces.  Note that\njquant2.c is used to map to an application-supplied colormap as well as for\nthe normal two-pass colormap selection process.\n\nCAUTION: it appears that Adobe Photoshop writes inverted data in CMYK JPEG\nfiles: 0 represents 100% ink coverage, rather than 0% ink as you'd expect.\nThis is arguably a bug in Photoshop, but if you need to work with Photoshop\nCMYK files, you will have to deal with it in your application.  We cannot\n\"fix\" this in the library by inverting the data during the CMYK<=>YCCK\ntransform, because that would break other applications, notably Ghostscript.\nPhotoshop versions prior to 3.0 write EPS files containing JPEG-encoded CMYK\ndata in the same inverted-YCCK representation used in bare JPEG files, but\nthe surrounding PostScript code performs an inversion using the PS image\noperator.  I am told that Photoshop 3.0 will write uninverted YCCK in\nEPS/JPEG files, and will omit the PS-level inversion.  (But the data\npolarity used in bare JPEG files will not change in 3.0.)  In either case,\nthe JPEG library must not invert the data itself, or else Ghostscript would\nread these EPS files incorrectly.\n\n\nError handling\n--------------\n\nWhen the default error handler is used, any error detected inside the JPEG\nroutines will cause a message to be printed on stderr, followed by exit().\nYou can supply your own error handling routines to override this behavior\nand to control the treatment of nonfatal warnings and trace/debug messages.\nThe file example.c illustrates the most common case, which is to have the\napplication regain control after an error rather than exiting.\n\nThe JPEG library never writes any message directly; it always goes through\nthe error handling routines.  Three classes of messages are recognized:\n  * Fatal errors: the library cannot continue.\n  * Warnings: the library can continue, but the data is corrupt, and a\n    damaged output image is likely to result.\n  * Trace/informational messages.  These come with a trace level indicating\n    the importance of the message; you can control the verbosity of the\n    program by adjusting the maximum trace level that will be displayed.\n\nYou may, if you wish, simply replace the entire JPEG error handling module\n(jerror.c) with your own code.  However, you can avoid code duplication by\nonly replacing some of the routines depending on the behavior you need.\nThis is accomplished by calling jpeg_std_error() as usual, but then overriding\nsome of the method pointers in the jpeg_error_mgr struct, as illustrated by\nexample.c.\n\nAll of the error handling routines will receive a pointer to the JPEG object\n(a j_common_ptr which points to either a jpeg_compress_struct or a\njpeg_decompress_struct; if you need to tell which, test the is_decompressor\nfield).  This struct includes a pointer to the error manager struct in its\n\"err\" field.  Frequently, custom error handler routines will need to access\nadditional data which is not known to the JPEG library or the standard error\nhandler.  The most convenient way to do this is to embed either the JPEG\nobject or the jpeg_error_mgr struct in a larger structure that contains\nadditional fields; then casting the passed pointer provides access to the\nadditional fields.  Again, see example.c for one way to do it.  (Beginning\nwith IJG version 6b, there is also a void pointer \"client_data\" in each\nJPEG object, which the application can also use to find related data.\nThe library does not touch client_data at all.)\n\nThe individual methods that you might wish to override are:\n\nerror_exit (j_common_ptr cinfo)\n        Receives control for a fatal error.  Information sufficient to\n        generate the error message has been stored in cinfo->err; call\n        output_message to display it.  Control must NOT return to the caller;\n        generally this routine will exit() or longjmp() somewhere.\n        Typically you would override this routine to get rid of the exit()\n        default behavior.  Note that if you continue processing, you should\n        clean up the JPEG object with jpeg_abort() or jpeg_destroy().\n\noutput_message (j_common_ptr cinfo)\n        Actual output of any JPEG message.  Override this to send messages\n        somewhere other than stderr.  Note that this method does not know\n        how to generate a message, only where to send it.\n\nformat_message (j_common_ptr cinfo, char *buffer)\n        Constructs a readable error message string based on the error info\n        stored in cinfo->err.  This method is called by output_message.  Few\n        applications should need to override this method.  One possible\n        reason for doing so is to implement dynamic switching of error message\n        language.\n\nemit_message (j_common_ptr cinfo, int msg_level)\n        Decide whether or not to emit a warning or trace message; if so,\n        calls output_message.  The main reason for overriding this method\n        would be to abort on warnings.  msg_level is -1 for warnings,\n        0 and up for trace messages.\n\nOnly error_exit() and emit_message() are called from the rest of the JPEG\nlibrary; the other two are internal to the error handler.\n\nThe actual message texts are stored in an array of strings which is pointed to\nby the field err->jpeg_message_table.  The messages are numbered from 0 to\nerr->last_jpeg_message, and it is these code numbers that are used in the\nJPEG library code.  You could replace the message texts (for instance, with\nmessages in French or German) by changing the message table pointer.  See\njerror.h for the default texts.  CAUTION: this table will almost certainly\nchange or grow from one library version to the next.\n\nIt may be useful for an application to add its own message texts that are\nhandled by the same mechanism.  The error handler supports a second \"add-on\"\nmessage table for this purpose.  To define an addon table, set the pointer\nerr->addon_message_table and the message numbers err->first_addon_message and\nerr->last_addon_message.  If you number the addon messages beginning at 1000\nor so, you won't have to worry about conflicts with the library's built-in\nmessages.  See the sample applications cjpeg/djpeg for an example of using\naddon messages (the addon messages are defined in cderror.h).\n\nActual invocation of the error handler is done via macros defined in jerror.h:\n        ERREXITn(...)   for fatal errors\n        WARNMSn(...)    for corrupt-data warnings\n        TRACEMSn(...)   for trace and informational messages.\nThese macros store the message code and any additional parameters into the\nerror handler struct, then invoke the error_exit() or emit_message() method.\nThe variants of each macro are for varying numbers of additional parameters.\nThe additional parameters are inserted into the generated message using\nstandard printf() format codes.\n\nSee jerror.h and jerror.c for further details.\n\n\nCompressed data handling (source and destination managers)\n----------------------------------------------------------\n\nThe JPEG compression library sends its compressed data to a \"destination\nmanager\" module.  The default destination manager just writes the data to a\nmemory buffer or to a stdio stream, but you can provide your own manager to\ndo something else.  Similarly, the decompression library calls a \"source\nmanager\" to obtain the compressed data; you can provide your own source\nmanager if you want the data to come from somewhere other than a memory\nbuffer or a stdio stream.\n\nIn both cases, compressed data is processed a bufferload at a time: the\ndestination or source manager provides a work buffer, and the library invokes\nthe manager only when the buffer is filled or emptied.  (You could define a\none-character buffer to force the manager to be invoked for each byte, but\nthat would be rather inefficient.)  The buffer's size and location are\ncontrolled by the manager, not by the library.  For example, the memory\nsource manager just makes the buffer pointer and length point to the original\ndata in memory.  In this case the buffer-reload procedure will be invoked\nonly if the decompressor ran off the end of the datastream, which would\nindicate an erroneous datastream.\n\nThe work buffer is defined as an array of datatype JOCTET, which is generally\n\"char\" or \"unsigned char\".  On a machine where char is not exactly 8 bits\nwide, you must define JOCTET as a wider data type and then modify the data\nsource and destination modules to transcribe the work arrays into 8-bit units\non external storage.\n\nA data destination manager struct contains a pointer and count defining the\nnext byte to write in the work buffer and the remaining free space:\n\n        JOCTET *next_output_byte;   /* => next byte to write in buffer */\n        size_t free_in_buffer;      /* # of byte spaces remaining in buffer */\n\nThe library increments the pointer and decrements the count until the buffer\nis filled.  The manager's empty_output_buffer method must reset the pointer\nand count.  The manager is expected to remember the buffer's starting address\nand total size in private fields not visible to the library.\n\nA data destination manager provides three methods:\n\ninit_destination (j_compress_ptr cinfo)\n        Initialize destination.  This is called by jpeg_start_compress()\n        before any data is actually written.  It must initialize\n        next_output_byte and free_in_buffer.  free_in_buffer must be\n        initialized to a positive value.\n\nempty_output_buffer (j_compress_ptr cinfo)\n        This is called whenever the buffer has filled (free_in_buffer\n        reaches zero).  In typical applications, it should write out the\n        *entire* buffer (use the saved start address and buffer length;\n        ignore the current state of next_output_byte and free_in_buffer).\n        Then reset the pointer & count to the start of the buffer, and\n        return TRUE indicating that the buffer has been dumped.\n        free_in_buffer must be set to a positive value when TRUE is\n        returned.  A FALSE return should only be used when I/O suspension is\n        desired (this operating mode is discussed in the next section).\n\nterm_destination (j_compress_ptr cinfo)\n        Terminate destination --- called by jpeg_finish_compress() after all\n        data has been written.  In most applications, this must flush any\n        data remaining in the buffer.  Use either next_output_byte or\n        free_in_buffer to determine how much data is in the buffer.\n\nterm_destination() is NOT called by jpeg_abort() or jpeg_destroy().  If you\nwant the destination manager to be cleaned up during an abort, you must do it\nyourself.\n\nYou will also need code to create a jpeg_destination_mgr struct, fill in its\nmethod pointers, and insert a pointer to the struct into the \"dest\" field of\nthe JPEG compression object.  This can be done in-line in your setup code if\nyou like, but it's probably cleaner to provide a separate routine similar to\nthe jpeg_stdio_dest() or jpeg_mem_dest() routines of the supplied destination\nmanagers.\n\nDecompression source managers follow a parallel design, but with some\nadditional frammishes.  The source manager struct contains a pointer and count\ndefining the next byte to read from the work buffer and the number of bytes\nremaining:\n\n        const JOCTET *next_input_byte;  /* => next byte to read from buffer */\n        size_t bytes_in_buffer;         /* # of bytes remaining in buffer */\n\nThe library increments the pointer and decrements the count until the buffer\nis emptied.  The manager's fill_input_buffer method must reset the pointer and\ncount.  In most applications, the manager must remember the buffer's starting\naddress and total size in private fields not visible to the library.\n\nA data source manager provides five methods:\n\ninit_source (j_decompress_ptr cinfo)\n        Initialize source.  This is called by jpeg_read_header() before any\n        data is actually read.  Unlike init_destination(), it may leave\n        bytes_in_buffer set to 0 (in which case a fill_input_buffer() call\n        will occur immediately).\n\nfill_input_buffer (j_decompress_ptr cinfo)\n        This is called whenever bytes_in_buffer has reached zero and more\n        data is wanted.  In typical applications, it should read fresh data\n        into the buffer (ignoring the current state of next_input_byte and\n        bytes_in_buffer), reset the pointer & count to the start of the\n        buffer, and return TRUE indicating that the buffer has been reloaded.\n        It is not necessary to fill the buffer entirely, only to obtain at\n        least one more byte.  bytes_in_buffer MUST be set to a positive value\n        if TRUE is returned.  A FALSE return should only be used when I/O\n        suspension is desired (this mode is discussed in the next section).\n\nskip_input_data (j_decompress_ptr cinfo, long num_bytes)\n        Skip num_bytes worth of data.  The buffer pointer and count should\n        be advanced over num_bytes input bytes, refilling the buffer as\n        needed.  This is used to skip over a potentially large amount of\n        uninteresting data (such as an APPn marker).  In some applications\n        it may be possible to optimize away the reading of the skipped data,\n        but it's not clear that being smart is worth much trouble; large\n        skips are uncommon.  bytes_in_buffer may be zero on return.\n        A zero or negative skip count should be treated as a no-op.\n\nresync_to_restart (j_decompress_ptr cinfo, int desired)\n        This routine is called only when the decompressor has failed to find\n        a restart (RSTn) marker where one is expected.  Its mission is to\n        find a suitable point for resuming decompression.  For most\n        applications, we recommend that you just use the default resync\n        procedure, jpeg_resync_to_restart().  However, if you are able to back\n        up in the input data stream, or if you have a-priori knowledge about\n        the likely location of restart markers, you may be able to do better.\n        Read the read_restart_marker() and jpeg_resync_to_restart() routines\n        in jdmarker.c if you think you'd like to implement your own resync\n        procedure.\n\nterm_source (j_decompress_ptr cinfo)\n        Terminate source --- called by jpeg_finish_decompress() after all\n        data has been read.  Often a no-op.\n\nFor both fill_input_buffer() and skip_input_data(), there is no such thing\nas an EOF return.  If the end of the file has been reached, the routine has\na choice of exiting via ERREXIT() or inserting fake data into the buffer.\nIn most cases, generating a warning message and inserting a fake EOI marker\nis the best course of action --- this will allow the decompressor to output\nhowever much of the image is there.  In pathological cases, the decompressor\nmay swallow the EOI and again demand data ... just keep feeding it fake EOIs.\njdatasrc.c illustrates the recommended error recovery behavior.\n\nterm_source() is NOT called by jpeg_abort() or jpeg_destroy().  If you want\nthe source manager to be cleaned up during an abort, you must do it yourself.\n\nYou will also need code to create a jpeg_source_mgr struct, fill in its method\npointers, and insert a pointer to the struct into the \"src\" field of the JPEG\ndecompression object.  This can be done in-line in your setup code if you\nlike, but it's probably cleaner to provide a separate routine similar to the\njpeg_stdio_src() or jpeg_mem_src() routines of the supplied source managers.\n\nFor more information, consult the memory and stdio source and destination\nmanagers in jdatasrc.c and jdatadst.c.\n\n\nI/O suspension\n--------------\n\nSome applications need to use the JPEG library as an incremental memory-to-\nmemory filter: when the compressed data buffer is filled or emptied, they want\ncontrol to return to the outer loop, rather than expecting that the buffer can\nbe emptied or reloaded within the data source/destination manager subroutine.\nThe library supports this need by providing an \"I/O suspension\" mode, which we\ndescribe in this section.\n\nThe I/O suspension mode is not a panacea: nothing is guaranteed about the\nmaximum amount of time spent in any one call to the library, so it will not\neliminate response-time problems in single-threaded applications.  If you\nneed guaranteed response time, we suggest you \"bite the bullet\" and implement\na real multi-tasking capability.\n\nTo use I/O suspension, cooperation is needed between the calling application\nand the data source or destination manager; you will always need a custom\nsource/destination manager.  (Please read the previous section if you haven't\nalready.)  The basic idea is that the empty_output_buffer() or\nfill_input_buffer() routine is a no-op, merely returning FALSE to indicate\nthat it has done nothing.  Upon seeing this, the JPEG library suspends\noperation and returns to its caller.  The surrounding application is\nresponsible for emptying or refilling the work buffer before calling the\nJPEG library again.\n\nCompression suspension:\n\nFor compression suspension, use an empty_output_buffer() routine that returns\nFALSE; typically it will not do anything else.  This will cause the\ncompressor to return to the caller of jpeg*_write_scanlines(), with the return\nvalue indicating that not all the supplied scanlines have been accepted.\nThe application must make more room in the output buffer, adjust the output\nbuffer pointer/count appropriately, and then call jpeg*_write_scanlines()\nagain, pointing to the first unconsumed scanline.\n\nWhen forced to suspend, the compressor will backtrack to a convenient stopping\npoint (usually the start of the current MCU); it will regenerate some output\ndata when restarted.  Therefore, although empty_output_buffer() is only\ncalled when the buffer is filled, you should NOT write out the entire buffer\nafter a suspension.  Write only the data up to the current position of\nnext_output_byte/free_in_buffer.  The data beyond that point will be\nregenerated after resumption.\n\nBecause of the backtracking behavior, a good-size output buffer is essential\nfor efficiency; you don't want the compressor to suspend often.  (In fact, an\noverly small buffer could lead to infinite looping, if a single MCU required\nmore data than would fit in the buffer.)  We recommend a buffer of at least\nseveral Kbytes.  You may want to insert explicit code to ensure that you don't\ncall jpeg*_write_scanlines() unless there is a reasonable amount of space in\nthe output buffer; in other words, flush the buffer before trying to compress\nmore data.\n\nThe compressor does not allow suspension while it is trying to write JPEG\nmarkers at the beginning and end of the file.  This means that:\n  * At the beginning of a compression operation, there must be enough free\n    space in the output buffer to hold the header markers (typically 600 or\n    so bytes).  The recommended buffer size is bigger than this anyway, so\n    this is not a problem as long as you start with an empty buffer.  However,\n    this restriction might catch you if you insert large special markers, such\n    as a JFIF thumbnail image, without flushing the buffer afterwards.\n  * When you call jpeg_finish_compress(), there must be enough space in the\n    output buffer to emit any buffered data and the final EOI marker.  In the\n    current implementation, half a dozen bytes should suffice for this, but\n    for safety's sake we recommend ensuring that at least 100 bytes are free\n    before calling jpeg_finish_compress().\n\nA more significant restriction is that jpeg_finish_compress() cannot suspend.\nThis means you cannot use suspension with multi-pass operating modes, namely\nHuffman code optimization and multiple-scan output.  Those modes write the\nwhole file during jpeg_finish_compress(), which will certainly result in\nbuffer overrun.  (Note that this restriction applies only to compression,\nnot decompression.  The decompressor supports input suspension in all of its\noperating modes.)\n\nDecompression suspension:\n\nFor decompression suspension, use a fill_input_buffer() routine that simply\nreturns FALSE (except perhaps during error recovery, as discussed below).\nThis will cause the decompressor to return to its caller with an indication\nthat suspension has occurred.  This can happen at four places:\n  * jpeg_read_header(): will return JPEG_SUSPENDED.\n  * jpeg_start_decompress(): will return FALSE, rather than its usual TRUE.\n  * jpeg*_read_scanlines(): will return the number of scanlines already\n        completed (possibly 0).\n  * jpeg_finish_decompress(): will return FALSE, rather than its usual TRUE.\nThe surrounding application must recognize these cases, load more data into\nthe input buffer, and repeat the call.  In the case of jpeg*_read_scanlines(),\nincrement the passed pointers past any scanlines successfully read.\n\nJust as with compression, the decompressor will typically backtrack to a\nconvenient restart point before suspending.  When fill_input_buffer() is\ncalled, next_input_byte/bytes_in_buffer point to the current restart point,\nwhich is where the decompressor will backtrack to if FALSE is returned.\nThe data beyond that position must NOT be discarded if you suspend; it needs\nto be re-read upon resumption.  In most implementations, you'll need to shift\nthis data down to the start of your work buffer and then load more data after\nit.  Again, this behavior means that a several-Kbyte work buffer is essential\nfor decent performance; furthermore, you should load a reasonable amount of\nnew data before resuming decompression.  (If you loaded, say, only one new\nbyte each time around, you could waste a LOT of cycles.)\n\nThe skip_input_data() source manager routine requires special care in a\nsuspension scenario.  This routine is NOT granted the ability to suspend the\ndecompressor; it can decrement bytes_in_buffer to zero, but no more.  If the\nrequested skip distance exceeds the amount of data currently in the input\nbuffer, then skip_input_data() must set bytes_in_buffer to zero and record the\nadditional skip distance somewhere else.  The decompressor will immediately\ncall fill_input_buffer(), which should return FALSE, which will cause a\nsuspension return.  The surrounding application must then arrange to discard\nthe recorded number of bytes before it resumes loading the input buffer.\n(Yes, this design is rather baroque, but it avoids complexity in the far more\ncommon case where a non-suspending source manager is used.)\n\nIf the input data has been exhausted, we recommend that you emit a warning\nand insert dummy EOI markers just as a non-suspending data source manager\nwould do.  This can be handled either in the surrounding application logic or\nwithin fill_input_buffer(); the latter is probably more efficient.  If\nfill_input_buffer() knows that no more data is available, it can set the\npointer/count to point to a dummy EOI marker and then return TRUE just as\nthough it had read more data in a non-suspending situation.\n\nThe decompressor does not attempt to suspend within standard JPEG markers;\ninstead it will backtrack to the start of the marker and reprocess the whole\nmarker next time.  Hence the input buffer must be large enough to hold the\nlongest standard marker in the file.  Standard JPEG markers should normally\nnot exceed a few hundred bytes each (DHT tables are typically the longest).\nWe recommend at least a 2K buffer for performance reasons, which is much\nlarger than any correct marker is likely to be.  For robustness against\ndamaged marker length counts, you may wish to insert a test in your\napplication for the case that the input buffer is completely full and yet\nthe decoder has suspended without consuming any data --- otherwise, if this\nsituation did occur, it would lead to an endless loop.  (The library can't\nprovide this test since it has no idea whether \"the buffer is full\", or\neven whether there is a fixed-size input buffer.)\n\nThe input buffer would need to be 64K to allow for arbitrary COM or APPn\nmarkers, but these are handled specially: they are either saved into allocated\nmemory, or skipped over by calling skip_input_data().  In the former case,\nsuspension is handled correctly, and in the latter case, the problem of\nbuffer overrun is placed on skip_input_data's shoulders, as explained above.\nNote that if you provide your own marker handling routine for large markers,\nyou should consider how to deal with buffer overflow.\n\nMultiple-buffer management:\n\nIn some applications it is desirable to store the compressed data in a linked\nlist of buffer areas, so as to avoid data copying.  This can be handled by\nhaving empty_output_buffer() or fill_input_buffer() set the pointer and count\nto reference the next available buffer; FALSE is returned only if no more\nbuffers are available.  Although seemingly straightforward, there is a\npitfall in this approach: the backtrack that occurs when FALSE is returned\ncould back up into an earlier buffer.  For example, when fill_input_buffer()\nis called, the current pointer & count indicate the backtrack restart point.\nSince fill_input_buffer() will set the pointer and count to refer to a new\nbuffer, the restart position must be saved somewhere else.  Suppose a second\ncall to fill_input_buffer() occurs in the same library call, and no\nadditional input data is available, so fill_input_buffer must return FALSE.\nIf the JPEG library has not moved the pointer/count forward in the current\nbuffer, then *the correct restart point is the saved position in the prior\nbuffer*.  Prior buffers may be discarded only after the library establishes\na restart point within a later buffer.  Similar remarks apply for output into\na chain of buffers.\n\nThe library will never attempt to backtrack over a skip_input_data() call,\nso any skipped data can be permanently discarded.  You still have to deal\nwith the case of skipping not-yet-received data, however.\n\nIt's much simpler to use only a single buffer; when fill_input_buffer() is\ncalled, move any unconsumed data (beyond the current pointer/count) down to\nthe beginning of this buffer and then load new data into the remaining buffer\nspace.  This approach requires a little more data copying but is far easier\nto get right.\n\n\nProgressive JPEG support\n------------------------\n\nProgressive JPEG rearranges the stored data into a series of scans of\nincreasing quality.  In situations where a JPEG file is transmitted across a\nslow communications link, a decoder can generate a low-quality image very\nquickly from the first scan, then gradually improve the displayed quality as\nmore scans are received.  The final image after all scans are complete is\nidentical to that of a regular (sequential) JPEG file of the same quality\nsetting.  Progressive JPEG files are often slightly smaller than equivalent\nsequential JPEG files, but the possibility of incremental display is the main\nreason for using progressive JPEG.\n\nThe IJG encoder library generates progressive JPEG files when given a\nsuitable \"scan script\" defining how to divide the data into scans.\nCreation of progressive JPEG files is otherwise transparent to the encoder.\nProgressive JPEG files can also be read transparently by the decoder library.\nIf the decoding application simply uses the library as defined above, it\nwill receive a final decoded image without any indication that the file was\nprogressive.  Of course, this approach does not allow incremental display.\nTo perform incremental display, an application needs to use the decoder\nlibrary's \"buffered-image\" mode, in which it receives a decoded image\nmultiple times.\n\nEach displayed scan requires about as much work to decode as a full JPEG\nimage of the same size, so the decoder must be fairly fast in relation to the\ndata transmission rate in order to make incremental display useful.  However,\nit is possible to skip displaying the image and simply add the incoming bits\nto the decoder's coefficient buffer.  This is fast because only Huffman\ndecoding need be done, not IDCT, upsampling, colorspace conversion, etc.\nThe IJG decoder library allows the application to switch dynamically between\ndisplaying the image and simply absorbing the incoming bits.  A properly\ncoded application can automatically adapt the number of display passes to\nsuit the time available as the image is received.  Also, a final\nhigher-quality display cycle can be performed from the buffered data after\nthe end of the file is reached.\n\nProgressive compression:\n\nTo create a progressive JPEG file (or a multiple-scan sequential JPEG file),\nset the scan_info cinfo field to point to an array of scan descriptors, and\nperform compression as usual.  Instead of constructing your own scan list,\nyou can call the jpeg_simple_progression() helper routine to create a\nrecommended progression sequence; this method should be used by all\napplications that don't want to get involved in the nitty-gritty of\nprogressive scan sequence design.  (If you want to provide user control of\nscan sequences, you may wish to borrow the scan script reading code found\nin rdswitch.c, so that you can read scan script files just like cjpeg's.)\nWhen scan_info is not NULL, the compression library will store DCT'd data\ninto a buffer array as jpeg*_write_scanlines() is called, and will emit all\nthe requested scans during jpeg_finish_compress().  This implies that\nmultiple-scan output cannot be created with a suspending data destination\nmanager, since jpeg_finish_compress() does not support suspension.  We\nshould also note that the compressor currently forces Huffman optimization\nmode when creating a progressive JPEG file, because the default Huffman\ntables are unsuitable for progressive files.\n\nProgressive decompression:\n\nWhen buffered-image mode is not used, the decoder library will read all of\na multi-scan file during jpeg_start_decompress(), so that it can provide a\nfinal decoded image.  (Here \"multi-scan\" means either progressive or\nmulti-scan sequential.)  This makes multi-scan files transparent to the\ndecoding application.  However, existing applications that used suspending\ninput with version 5 of the IJG library will need to be modified to check\nfor a suspension return from jpeg_start_decompress().\n\nTo perform incremental display, an application must use the library's\nbuffered-image mode.  This is described in the next section.\n\n\nBuffered-image mode\n-------------------\n\nIn buffered-image mode, the library stores the partially decoded image in a\ncoefficient buffer, from which it can be read out as many times as desired.\nThis mode is typically used for incremental display of progressive JPEG files,\nbut it can be used with any JPEG file.  Each scan of a progressive JPEG file\nadds more data (more detail) to the buffered image.  The application can\ndisplay in lockstep with the source file (one display pass per input scan),\nor it can allow input processing to outrun display processing.  By making\ninput and display processing run independently, it is possible for the\napplication to adapt progressive display to a wide range of data transmission\nrates.\n\nThe basic control flow for buffered-image decoding is\n\n        jpeg_create_decompress()\n        set data source\n        jpeg_read_header()\n        set overall decompression parameters\n        cinfo.buffered_image = TRUE;    /* select buffered-image mode */\n        jpeg_start_decompress()\n        for (each output pass) {\n            adjust output decompression parameters if required\n            jpeg_start_output()         /* start a new output pass */\n            for (all scanlines in image) {\n                jpeg_read_scanlines()   /* Use jpeg12_read_scanlines() for\n                                           12-bit data precision and\n                                           jpeg16_read_scanlines() for 16-bit\n                                           data precision. */\n                display scanlines\n            }\n            jpeg_finish_output()        /* terminate output pass */\n        }\n        jpeg_finish_decompress()\n        jpeg_destroy_decompress()\n\nThis differs from ordinary unbuffered decoding in that there is an additional\nlevel of looping.  The application can choose how many output passes to make\nand how to display each pass.\n\nThe simplest approach to displaying progressive images is to do one display\npass for each scan appearing in the input file.  In this case the outer loop\ncondition is typically\n        while (!jpeg_input_complete(&cinfo))\nand the start-output call should read\n        jpeg_start_output(&cinfo, cinfo.input_scan_number);\nThe second parameter to jpeg_start_output() indicates which scan of the input\nfile is to be displayed; the scans are numbered starting at 1 for this\npurpose.  (You can use a loop counter starting at 1 if you like, but using\nthe library's input scan counter is easier.)  The library automatically reads\ndata as necessary to complete each requested scan, and jpeg_finish_output()\nadvances to the next scan or end-of-image marker (hence input_scan_number\nwill be incremented by the time control arrives back at jpeg_start_output()).\nWith this technique, data is read from the input file only as needed, and\ninput and output processing run in lockstep.\n\nAfter reading the final scan and reaching the end of the input file, the\nbuffered image remains available; it can be read additional times by\nrepeating the jpeg_start_output()/jpeg*_read_scanlines()/jpeg_finish_output()\nsequence.  For example, a useful technique is to use fast one-pass color\nquantization for display passes made while the image is arriving, followed by\na final display pass using two-pass quantization for highest quality.  This\nis done by changing the library parameters before the final output pass.\nChanging parameters between passes is discussed in detail below.\n\nIn general the last scan of a progressive file cannot be recognized as such\nuntil after it is read, so a post-input display pass is the best approach if\nyou want special processing in the final pass.\n\nWhen done with the image, be sure to call jpeg_finish_decompress() to release\nthe buffered image (or just use jpeg_destroy_decompress()).\n\nIf input data arrives faster than it can be displayed, the application can\ncause the library to decode input data in advance of what's needed to produce\noutput.  This is done by calling the routine jpeg_consume_input().\nThe return value is one of the following:\n        JPEG_REACHED_SOS:    reached an SOS marker (the start of a new scan)\n        JPEG_REACHED_EOI:    reached the EOI marker (end of image)\n        JPEG_ROW_COMPLETED:  completed reading one MCU row of compressed data\n        JPEG_SCAN_COMPLETED: completed reading last MCU row of current scan\n        JPEG_SUSPENDED:      suspended before completing any of the above\n(JPEG_SUSPENDED can occur only if a suspending data source is used.)  This\nroutine can be called at any time after initializing the JPEG object.  It\nreads some additional data and returns when one of the indicated significant\nevents occurs.  (If called after the EOI marker is reached, it will\nimmediately return JPEG_REACHED_EOI without attempting to read more data.)\n\nThe library's output processing will automatically call jpeg_consume_input()\nwhenever the output processing overtakes the input; thus, simple lockstep\ndisplay requires no direct calls to jpeg_consume_input().  But by adding\ncalls to jpeg_consume_input(), you can absorb data in advance of what is\nbeing displayed.  This has two benefits:\n  * You can limit buildup of unprocessed data in your input buffer.\n  * You can eliminate extra display passes by paying attention to the\n    state of the library's input processing.\n\nThe first of these benefits only requires interspersing calls to\njpeg_consume_input() with your display operations and any other processing\nyou may be doing.  To avoid wasting cycles due to backtracking, it's best to\ncall jpeg_consume_input() only after a hundred or so new bytes have arrived.\nThis is discussed further under \"I/O suspension\", above.  (Note: the JPEG\nlibrary currently is not thread-safe.  You must not call jpeg_consume_input()\nfrom one thread of control if a different library routine is working on the\nsame JPEG object in another thread.)\n\nWhen input arrives fast enough that more than one new scan is available\nbefore you start a new output pass, you may as well skip the output pass\ncorresponding to the completed scan.  This occurs for free if you pass\ncinfo.input_scan_number as the target scan number to jpeg_start_output().\nThe input_scan_number field is simply the index of the scan currently being\nconsumed by the input processor.  You can ensure that this is up-to-date by\nemptying the input buffer just before calling jpeg_start_output(): call\njpeg_consume_input() repeatedly until it returns JPEG_SUSPENDED or\nJPEG_REACHED_EOI.\n\nThe target scan number passed to jpeg_start_output() is saved in the\ncinfo.output_scan_number field.  The library's output processing calls\njpeg_consume_input() whenever the current input scan number and row within\nthat scan is less than or equal to the current output scan number and row.\nThus, input processing can \"get ahead\" of the output processing but is not\nallowed to \"fall behind\".  You can achieve several different effects by\nmanipulating this interlock rule.  For example, if you pass a target scan\nnumber greater than the current input scan number, the output processor will\nwait until that scan starts to arrive before producing any output.  (To avoid\nan infinite loop, the target scan number is automatically reset to the last\nscan number when the end of image is reached.  Thus, if you specify a large\ntarget scan number, the library will just absorb the entire input file and\nthen perform an output pass.  This is effectively the same as what\njpeg_start_decompress() does when you don't select buffered-image mode.)\nWhen you pass a target scan number equal to the current input scan number,\nthe image is displayed no faster than the current input scan arrives.  The\nfinal possibility is to pass a target scan number less than the current input\nscan number; this disables the input/output interlock and causes the output\nprocessor to simply display whatever it finds in the image buffer, without\nwaiting for input.  (However, the library will not accept a target scan\nnumber less than one, so you can't avoid waiting for the first scan.)\n\nWhen data is arriving faster than the output display processing can advance\nthrough the image, jpeg_consume_input() will store data into the buffered\nimage beyond the point at which the output processing is reading data out\nagain.  If the input arrives fast enough, it may \"wrap around\" the buffer to\nthe point where the input is more than one whole scan ahead of the output.\nIf the output processing simply proceeds through its display pass without\npaying attention to the input, the effect seen on-screen is that the lower\npart of the image is one or more scans better in quality than the upper part.\nThen, when the next output scan is started, you have a choice of what target\nscan number to use.  The recommended choice is to use the current input scan\nnumber at that time, which implies that you've skipped the output scans\ncorresponding to the input scans that were completed while you processed the\nprevious output scan.  In this way, the decoder automatically adapts its\nspeed to the arriving data, by skipping output scans as necessary to keep up\nwith the arriving data.\n\nWhen using this strategy, you'll want to be sure that you perform a final\noutput pass after receiving all the data; otherwise your last display may not\nbe full quality across the whole screen.  So the right outer loop logic is\nsomething like this:\n        do {\n            absorb any waiting input by calling jpeg_consume_input()\n            final_pass = jpeg_input_complete(&cinfo);\n            adjust output decompression parameters if required\n            jpeg_start_output(&cinfo, cinfo.input_scan_number);\n            ...\n            jpeg_finish_output()\n        } while (!final_pass);\nrather than quitting as soon as jpeg_input_complete() returns TRUE.  This\narrangement makes it simple to use higher-quality decoding parameters\nfor the final pass.  But if you don't want to use special parameters for\nthe final pass, the right loop logic is like this:\n        for (;;) {\n            absorb any waiting input by calling jpeg_consume_input()\n            jpeg_start_output(&cinfo, cinfo.input_scan_number);\n            ...\n            jpeg_finish_output()\n            if (jpeg_input_complete(&cinfo) &&\n                cinfo.input_scan_number == cinfo.output_scan_number)\n              break;\n        }\nIn this case you don't need to know in advance whether an output pass is to\nbe the last one, so it's not necessary to have reached EOF before starting\nthe final output pass; rather, what you want to test is whether the output\npass was performed in sync with the final input scan.  This form of the loop\nwill avoid an extra output pass whenever the decoder is able (or nearly able)\nto keep up with the incoming data.\n\nWhen the data transmission speed is high, you might begin a display pass,\nthen find that much or all of the file has arrived before you can complete\nthe pass.  (You can detect this by noting the JPEG_REACHED_EOI return code\nfrom jpeg_consume_input(), or equivalently by testing jpeg_input_complete().)\nIn this situation you may wish to abort the current display pass and start a\nnew one using the newly arrived information.  To do so, just call\njpeg_finish_output() and then start a new pass with jpeg_start_output().\n\nA variant strategy is to abort and restart display if more than one complete\nscan arrives during an output pass; this can be detected by noting\nJPEG_REACHED_SOS returns and/or examining cinfo.input_scan_number.  This\nidea should be employed with caution, however, since the display process\nmight never get to the bottom of the image before being aborted, resulting\nin the lower part of the screen being several passes worse than the upper.\nIn most cases it's probably best to abort an output pass only if the whole\nfile has arrived and you want to begin the final output pass immediately.\n\nWhen receiving data across a communication link, we recommend always using\nthe current input scan number for the output target scan number; if a\nhigher-quality final pass is to be done, it should be started (aborting any\nincomplete output pass) as soon as the end of file is received.  However,\nmany other strategies are possible.  For example, the application can examine\nthe parameters of the current input scan and decide whether to display it or\nnot.  If the scan contains only chroma data, one might choose not to use it\nas the target scan, expecting that the scan will be small and will arrive\nquickly.  To skip to the next scan, call jpeg_consume_input() until it\nreturns JPEG_REACHED_SOS or JPEG_REACHED_EOI.  Or just use the next higher\nnumber as the target scan for jpeg_start_output(); but that method doesn't\nlet you inspect the next scan's parameters before deciding to display it.\n\n\nIn buffered-image mode, jpeg_start_decompress() never performs input and\nthus never suspends.  An application that uses input suspension with\nbuffered-image mode must be prepared for suspension returns from these\nroutines:\n* jpeg_start_output() performs input only if you request 2-pass quantization\n  and the target scan isn't fully read yet.  (This is discussed below.)\n* jpeg*_read_scanlines(), as always, returns the number of scanlines that it\n  was able to produce before suspending.\n* jpeg_finish_output() will read any markers following the target scan,\n  up to the end of the file or the SOS marker that begins another scan.\n  (But it reads no input if jpeg_consume_input() has already reached the\n  end of the file or a SOS marker beyond the target output scan.)\n* jpeg_finish_decompress() will read until the end of file, and thus can\n  suspend if the end hasn't already been reached (as can be tested by\n  calling jpeg_input_complete()).\njpeg_start_output(), jpeg_finish_output(), and jpeg_finish_decompress()\nall return TRUE if they completed their tasks, FALSE if they had to suspend.\nIn the event of a FALSE return, the application must load more input data\nand repeat the call.  Applications that use non-suspending data sources need\nnot check the return values of these three routines.\n\n\nIt is possible to change decoding parameters between output passes in the\nbuffered-image mode.  The decoder library currently supports only very\nlimited changes of parameters.  ONLY THE FOLLOWING parameter changes are\nallowed after jpeg_start_decompress() is called:\n* dct_method can be changed before each call to jpeg_start_output().\n  For example, one could use a fast DCT method for early scans, changing\n  to a higher-quality method for the final scan.\n* dither_mode can be changed before each call to jpeg_start_output();\n  of course this has no impact if not using color quantization.  Typically\n  one would use ordered dither for initial passes, then switch to\n  Floyd-Steinberg dither for the final pass.  Caution: changing dither mode\n  can cause more memory to be allocated by the library.  Although the amount\n  of memory involved is not large (a scanline or so), it may cause the\n  initial max_memory_to_use specification to be exceeded, which in the worst\n  case would result in an out-of-memory failure.\n* do_block_smoothing can be changed before each call to jpeg_start_output().\n  This setting is relevant only when decoding a progressive JPEG image.\n  During the first DC-only scan, block smoothing provides a very \"fuzzy\" look\n  instead of the very \"blocky\" look seen without it; which is better seems a\n  matter of personal taste.  But block smoothing is nearly always a win\n  during later stages, especially when decoding a successive-approximation\n  image: smoothing helps to hide the slight blockiness that otherwise shows\n  up on smooth gradients until the lowest coefficient bits are sent.\n* Color quantization mode can be changed under the rules described below.\n  You *cannot* change between full-color and quantized output (because that\n  would alter the required I/O buffer sizes), but you can change which\n  quantization method is used.\n\nWhen generating color-quantized output, changing quantization method is a\nvery useful way of switching between high-speed and high-quality display.\nThe library allows you to change among its three quantization methods:\n1. Single-pass quantization to a fixed color cube.\n   Selected by cinfo.two_pass_quantize = FALSE and cinfo.colormap = NULL.\n2. Single-pass quantization to an application-supplied colormap.\n   Selected by setting cinfo.colormap to point to the colormap (the value of\n   two_pass_quantize is ignored); also set cinfo.actual_number_of_colors.\n3. Two-pass quantization to a colormap chosen specifically for the image.\n   Selected by cinfo.two_pass_quantize = TRUE and cinfo.colormap = NULL.\n   (This is the default setting selected by jpeg_read_header, but it is\n   probably NOT what you want for the first pass of progressive display!)\nThese methods offer successively better quality and lesser speed.  However,\nonly the first method is available for quantizing in non-RGB color spaces.\n\nIMPORTANT: because the different quantizer methods have very different\nworking-storage requirements, the library requires you to indicate which\none(s) you intend to use before you call jpeg_start_decompress().  (If we did\nnot require this, the max_memory_to_use setting would be a complete fiction.)\nYou do this by setting one or more of these three cinfo fields to TRUE:\n        enable_1pass_quant              Fixed color cube colormap\n        enable_external_quant           Externally-supplied colormap\n        enable_2pass_quant              Two-pass custom colormap\nAll three are initialized FALSE by jpeg_read_header().  But\njpeg_start_decompress() automatically sets TRUE the one selected by the\ncurrent two_pass_quantize and colormap settings, so you only need to set the\nenable flags for any other quantization methods you plan to change to later.\n\nAfter setting the enable flags correctly at jpeg_start_decompress() time, you\ncan change to any enabled quantization method by setting two_pass_quantize\nand colormap properly just before calling jpeg_start_output().  The following\nspecial rules apply:\n1. You must explicitly set cinfo.colormap to NULL when switching to 1-pass\n   or 2-pass mode from a different mode, or when you want the 2-pass\n   quantizer to be re-run to generate a new colormap.\n2. To switch to an external colormap, or to change to a different external\n   colormap than was used on the prior pass, you must call\n   jpeg_new_colormap() after setting cinfo.colormap.\nNOTE: if you want to use the same colormap as was used in the prior pass,\nyou should not do either of these things.  This will save some nontrivial\nswitchover costs.\n(These requirements exist because cinfo.colormap will always be non-NULL\nafter completing a prior output pass, since both the 1-pass and 2-pass\nquantizers set it to point to their output colormaps.  Thus you have to\ndo one of these two things to notify the library that something has changed.\nYup, it's a bit klugy, but it's necessary to do it this way for backwards\ncompatibility.)\n\nNote that in buffered-image mode, the library generates any requested colormap\nduring jpeg_start_output(), not during jpeg_start_decompress().\n\nWhen using two-pass quantization, jpeg_start_output() makes a pass over the\nbuffered image to determine the optimum color map; it therefore may take a\nsignificant amount of time, whereas ordinarily it does little work.  The\nprogress monitor hook is called during this pass, if defined.  It is also\nimportant to realize that if the specified target scan number is greater than\nor equal to the current input scan number, jpeg_start_output() will attempt\nto consume input as it makes this pass.  If you use a suspending data source,\nyou need to check for a FALSE return from jpeg_start_output() under these\nconditions.  The combination of 2-pass quantization and a not-yet-fully-read\ntarget scan is the only case in which jpeg_start_output() will consume input.\n\n\nApplication authors who support buffered-image mode may be tempted to use it\nfor all JPEG images, even single-scan ones.  This will work, but it is\ninefficient: there is no need to create an image-sized coefficient buffer for\nsingle-scan images.  Requesting buffered-image mode for such an image wastes\nmemory.  Worse, it can cost time on large images, since the buffered data has\nto be swapped out or written to a temporary file.  If you are concerned about\nmaximum performance on baseline JPEG files, you should use buffered-image\nmode only when the incoming file actually has multiple scans.  This can be\ntested by calling jpeg_has_multiple_scans(), which will return a correct\nresult at any time after jpeg_read_header() completes.\n\nIt is also worth noting that when you use jpeg_consume_input() to let input\nprocessing get ahead of output processing, the resulting pattern of access to\nthe coefficient buffer is quite nonsequential.  It's best to use the memory\nmanager jmemnobs.c if you can (ie, if you have enough real or virtual main\nmemory).  If not, at least make sure that max_memory_to_use is set as high as\npossible.  If the JPEG memory manager has to use a temporary file, you will\nprobably see a lot of disk traffic and poor performance.  (This could be\nimproved with additional work on the memory manager, but we haven't gotten\naround to it yet.)\n\nIn some applications it may be convenient to use jpeg_consume_input() for all\ninput processing, including reading the initial markers; that is, you may\nwish to call jpeg_consume_input() instead of jpeg_read_header() during\nstartup.  This works, but note that you must check for JPEG_REACHED_SOS and\nJPEG_REACHED_EOI return codes as the equivalent of jpeg_read_header's codes.\nOnce the first SOS marker has been reached, you must call\njpeg_start_decompress() before jpeg_consume_input() will consume more input;\nit'll just keep returning JPEG_REACHED_SOS until you do.  If you read a\ntables-only file this way, jpeg_consume_input() will return JPEG_REACHED_EOI\nwithout ever returning JPEG_REACHED_SOS; be sure to check for this case.\nIf this happens, the decompressor will not read any more input until you call\njpeg_abort() to reset it.  It is OK to call jpeg_consume_input() even when not\nusing buffered-image mode, but in that case it's basically a no-op after the\ninitial markers have been read: it will just return JPEG_SUSPENDED.\n\n\nAbbreviated datastreams and multiple images\n-------------------------------------------\n\nA JPEG compression or decompression object can be reused to process multiple\nimages.  This saves a small amount of time per image by eliminating the\n\"create\" and \"destroy\" operations, but that isn't the real purpose of the\nfeature.  Rather, reuse of an object provides support for abbreviated JPEG\ndatastreams.  Object reuse can also simplify processing a series of images in\na single input or output file.  This section explains these features.\n\nA JPEG file normally contains several hundred bytes worth of quantization\nand Huffman tables.  In a situation where many images will be stored or\ntransmitted with identical tables, this may represent an annoying overhead.\nThe JPEG standard therefore permits tables to be omitted.  The standard\ndefines three classes of JPEG datastreams:\n  * \"Interchange\" datastreams contain an image and all tables needed to decode\n     the image.  These are the usual kind of JPEG file.\n  * \"Abbreviated image\" datastreams contain an image, but are missing some or\n    all of the tables needed to decode that image.\n  * \"Abbreviated table specification\" (henceforth \"tables-only\") datastreams\n    contain only table specifications.\nTo decode an abbreviated image, it is necessary to load the missing table(s)\ninto the decoder beforehand.  This can be accomplished by reading a separate\ntables-only file.  A variant scheme uses a series of images in which the first\nimage is an interchange (complete) datastream, while subsequent ones are\nabbreviated and rely on the tables loaded by the first image.  It is assumed\nthat once the decoder has read a table, it will remember that table until a\nnew definition for the same table number is encountered.\n\nIt is the application designer's responsibility to figure out how to associate\nthe correct tables with an abbreviated image.  While abbreviated datastreams\ncan be useful in a closed environment, their use is strongly discouraged in\nany situation where data exchange with other applications might be needed.\nCaveat designer.\n\nThe JPEG library provides support for reading and writing any combination of\ntables-only datastreams and abbreviated images.  In both compression and\ndecompression objects, a quantization or Huffman table will be retained for\nthe lifetime of the object, unless it is overwritten by a new table definition.\n\n\nTo create abbreviated image datastreams, it is only necessary to tell the\ncompressor not to emit some or all of the tables it is using.  Each\nquantization and Huffman table struct contains a boolean field \"sent_table\",\nwhich normally is initialized to FALSE.  For each table used by the image, the\nheader-writing process emits the table and sets sent_table = TRUE unless it is\nalready TRUE.  (In normal usage, this prevents outputting the same table\ndefinition multiple times, as would otherwise occur because the chroma\ncomponents typically share tables.)  Thus, setting this field to TRUE before\ncalling jpeg_start_compress() will prevent the table from being written at\nall.\n\nIf you want to create a \"pure\" abbreviated image file containing no tables,\njust call \"jpeg_suppress_tables(&cinfo, TRUE)\" after constructing all the\ntables.  If you want to emit some but not all tables, you'll need to set the\nindividual sent_table fields directly.\n\nTo create an abbreviated image, you must also call jpeg_start_compress()\nwith a second parameter of FALSE, not TRUE.  Otherwise jpeg_start_compress()\nwill force all the sent_table fields to FALSE.  (This is a safety feature to\nprevent abbreviated images from being created accidentally.)\n\nTo create a tables-only file, perform the same parameter setup that you\nnormally would, but instead of calling jpeg_start_compress() and so on, call\njpeg_write_tables(&cinfo).  This will write an abbreviated datastream\ncontaining only SOI, DQT and/or DHT markers, and EOI.  All the quantization\nand Huffman tables that are currently defined in the compression object will\nbe emitted unless their sent_tables flag is already TRUE, and then all the\nsent_tables flags will be set TRUE.\n\nA sure-fire way to create matching tables-only and abbreviated image files\nis to proceed as follows:\n\n        create JPEG compression object\n        set JPEG parameters\n        set destination to tables-only file\n        jpeg_write_tables(&cinfo);\n        set destination to image file\n        jpeg_start_compress(&cinfo, FALSE);\n        write data...\n        jpeg_finish_compress(&cinfo);\n\nSince the JPEG parameters are not altered between writing the table file and\nthe abbreviated image file, the same tables are sure to be used.  Of course,\nyou can repeat the jpeg_start_compress() ... jpeg_finish_compress() sequence\nmany times to produce many abbreviated image files matching the table file.\n\nYou cannot suppress output of the computed Huffman tables when Huffman\noptimization is selected.  (If you could, there'd be no way to decode the\nimage...)  Generally, you don't want to set optimize_coding = TRUE when\nyou are trying to produce abbreviated files.\n\nIn some cases you might want to compress an image using tables which are\nnot stored in the application, but are defined in an interchange or\ntables-only file readable by the application.  This can be done by setting up\na JPEG decompression object to read the specification file, then copying the\ntables into your compression object.  See jpeg_copy_critical_parameters()\nfor an example of copying quantization tables.\n\n\nTo read abbreviated image files, you simply need to load the proper tables\ninto the decompression object before trying to read the abbreviated image.\nIf the proper tables are stored in the application program, you can just\nallocate the table structs and fill in their contents directly.  For example,\nto load a fixed quantization table into table slot \"n\":\n\n    if (cinfo.quant_tbl_ptrs[n] == NULL)\n      cinfo.quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) &cinfo);\n    quant_ptr = cinfo.quant_tbl_ptrs[n];        /* quant_ptr is JQUANT_TBL* */\n    for (i = 0; i < 64; i++) {\n      /* Qtable[] is desired quantization table, in natural array order */\n      quant_ptr->quantval[i] = Qtable[i];\n    }\n\nCode to load a fixed Huffman table is typically (for AC table \"n\"):\n\n    if (cinfo.ac_huff_tbl_ptrs[n] == NULL)\n      cinfo.ac_huff_tbl_ptrs[n] = jpeg_alloc_huff_table((j_common_ptr) &cinfo);\n    huff_ptr = cinfo.ac_huff_tbl_ptrs[n];       /* huff_ptr is JHUFF_TBL* */\n    for (i = 1; i <= 16; i++) {\n      /* counts[i] is number of Huffman codes of length i bits, i=1..16 */\n      huff_ptr->bits[i] = counts[i];\n    }\n    for (i = 0; i < 256; i++) {\n      /* symbols[] is the list of Huffman symbols, in code-length order */\n      huff_ptr->huffval[i] = symbols[i];\n    }\n\n(Note that trying to set cinfo.quant_tbl_ptrs[n] to point directly at a\nconstant JQUANT_TBL object is not safe.  If the incoming file happened to\ncontain a quantization table definition, your master table would get\noverwritten!  Instead allocate a working table copy and copy the master table\ninto it, as illustrated above.  Ditto for Huffman tables, of course.)\n\nYou might want to read the tables from a tables-only file, rather than\nhard-wiring them into your application.  The jpeg_read_header() call is\nsufficient to read a tables-only file.  You must pass a second parameter of\nFALSE to indicate that you do not require an image to be present.  Thus, the\ntypical scenario is\n\n        create JPEG decompression object\n        set source to tables-only file\n        jpeg_read_header(&cinfo, FALSE);\n        set source to abbreviated image file\n        jpeg_read_header(&cinfo, TRUE);\n        set decompression parameters\n        jpeg_start_decompress(&cinfo);\n        read data...\n        jpeg_finish_decompress(&cinfo);\n\nIn some cases, you may want to read a file without knowing whether it contains\nan image or just tables.  In that case, pass FALSE and check the return value\nfrom jpeg_read_header(): it will be JPEG_HEADER_OK if an image was found,\nJPEG_HEADER_TABLES_ONLY if only tables were found.  (A third return value,\nJPEG_SUSPENDED, is possible when using a suspending data source manager.)\nNote that jpeg_read_header() will not complain if you read an abbreviated\nimage for which you haven't loaded the missing tables; the missing-table check\noccurs later, in jpeg_start_decompress().\n\n\nIt is possible to read a series of images from a single source file by\nrepeating the jpeg_read_header() ... jpeg_finish_decompress() sequence,\nwithout releasing/recreating the JPEG object or the data source module.\n(If you did reinitialize, any partial bufferload left in the data source\nbuffer at the end of one image would be discarded, causing you to lose the\nstart of the next image.)  When you use this method, stored tables are\nautomatically carried forward, so some of the images can be abbreviated images\nthat depend on tables from earlier images.\n\nIf you intend to write a series of images into a single destination file,\nyou might want to make a specialized data destination module that doesn't\nflush the output buffer at term_destination() time.  This would speed things\nup by some trifling amount.  Of course, you'd need to remember to flush the\nbuffer after the last image.  You can make the later images be abbreviated\nones by passing FALSE to jpeg_start_compress().\n\n\nSpecial markers\n---------------\n\nSome applications may need to insert or extract special data in the JPEG\ndatastream.  The JPEG standard provides marker types \"COM\" (comment) and\n\"APP0\" through \"APP15\" (application) to hold application-specific data.\nUnfortunately, the use of these markers is not specified by the standard.\nCOM markers are fairly widely used to hold user-supplied text.  The JFIF file\nformat spec uses APP0 markers with specified initial strings to hold certain\ndata.  Adobe applications use APP14 markers beginning with the string \"Adobe\"\nfor miscellaneous data.  Other APPn markers are rarely seen, but might\ncontain almost anything.\n\nIf you wish to store user-supplied text, we recommend you use COM markers\nand place readable 7-bit ASCII text in them.  Newline conventions are not\nstandardized --- expect to find LF (Unix style), CR/LF (DOS style), or CR\n(Mac style).  A robust COM reader should be able to cope with random binary\ngarbage, including nulls, since some applications generate COM markers\ncontaining non-ASCII junk.  (But yours should not be one of them.)\n\nFor program-supplied data, use an APPn marker, and be sure to begin it with an\nidentifying string so that you can tell whether the marker is actually yours.\nIt's probably best to avoid using APP0 or APP14 for any private markers.\n(NOTE: the upcoming SPIFF standard will use APP8 markers; we recommend you\nnot use APP8 markers for any private purposes, either.)\n\nKeep in mind that at most 65533 bytes can be put into one marker, but you\ncan have as many markers as you like.\n\nBy default, the IJG compression library will write a JFIF APP0 marker if the\nselected JPEG colorspace is grayscale or YCbCr, or an Adobe APP14 marker if\nthe selected colorspace is RGB, CMYK, or YCCK.  You can disable this, but\nwe don't recommend it.  The decompression library will recognize JFIF and\nAdobe markers and will set the JPEG colorspace properly when one is found.\n\n\nYou can write special markers immediately following the datastream header by\ncalling jpeg_write_marker() after jpeg_start_compress() and before the first\ncall to jpeg*_write_scanlines().  When you do this, the markers appear after\nthe SOI and the JFIF APP0 and Adobe APP14 markers (if written), but before\nall else.  Specify the marker type parameter as \"JPEG_COM\" for COM or\n\"JPEG_APP0 + n\" for APPn.  (Actually, jpeg_write_marker will let you write\nany marker type, but we don't recommend writing any other kinds of marker.)\nFor example, to write a user comment string pointed to by comment_text:\n        jpeg_write_marker(cinfo, JPEG_COM, comment_text, strlen(comment_text));\n\nIf it's not convenient to store all the marker data in memory at once,\nyou can instead call jpeg_write_m_header() followed by multiple calls to\njpeg_write_m_byte().  If you do it this way, it's your responsibility to\ncall jpeg_write_m_byte() exactly the number of times given in the length\nparameter to jpeg_write_m_header().  (This method lets you empty the\noutput buffer partway through a marker, which might be important when\nusing a suspending data destination module.  In any case, if you are using\na suspending destination, you should flush its buffer after inserting\nany special markers.  See \"I/O suspension\".)\n\nOr, if you prefer to synthesize the marker byte sequence yourself,\nyou can just cram it straight into the data destination module.\n\nIf you are writing JFIF 1.02 extension markers (thumbnail images), don't\nforget to set cinfo.JFIF_minor_version = 2 so that the encoder will write the\ncorrect JFIF version number in the JFIF header marker.  The library's default\nis to write version 1.01, but that's wrong if you insert any 1.02 extension\nmarkers.  (We could probably get away with just defaulting to 1.02, but there\nused to be broken decoders that would complain about unknown minor version\nnumbers.  To reduce compatibility risks it's safest not to write 1.02 unless\nyou are actually using 1.02 extensions.)\n\n\nWhen reading, two methods of handling special markers are available:\n1. You can ask the library to save the contents of COM and/or APPn markers\ninto memory, and then examine them at your leisure afterwards.\n2. You can supply your own routine to process COM and/or APPn markers\non-the-fly as they are read.\nThe first method is simpler to use, especially if you are using a suspending\ndata source; writing a marker processor that copes with input suspension is\nnot easy (consider what happens if the marker is longer than your available\ninput buffer).  However, the second method conserves memory since the marker\ndata need not be kept around after it's been processed.\n\nFor either method, you'd normally set up marker handling after creating a\ndecompression object and before calling jpeg_read_header(), because the\nmarkers of interest will typically be near the head of the file and so will\nbe scanned by jpeg_read_header.  Once you've established a marker handling\nmethod, it will be used for the life of that decompression object\n(potentially many datastreams), unless you change it.  Marker handling is\ndetermined separately for COM markers and for each APPn marker code.\n\n\nTo save the contents of special markers in memory, call\n        jpeg_save_markers(cinfo, marker_code, length_limit)\nwhere marker_code is the marker type to save, JPEG_COM or JPEG_APP0+n.\n(To arrange to save all the special marker types, you need to call this\nroutine 17 times, for COM and APP0-APP15.)  If the incoming marker is longer\nthan length_limit data bytes, only length_limit bytes will be saved; this\nparameter allows you to avoid chewing up memory when you only need to see the\nfirst few bytes of a potentially large marker.  If you want to save all the\ndata, set length_limit to 0xFFFF; that is enough since marker lengths are only\n16 bits.  As a special case, setting length_limit to 0 prevents that marker\ntype from being saved at all.  (That is the default behavior, in fact.)\n\nAfter jpeg_read_header() completes, you can examine the special markers by\nfollowing the cinfo->marker_list pointer chain.  All the special markers in\nthe file appear in this list, in order of their occurrence in the file (but\nomitting any markers of types you didn't ask for).  Both the original data\nlength and the saved data length are recorded for each list entry; the latter\nwill not exceed length_limit for the particular marker type.  Note that these\nlengths exclude the marker length word, whereas the stored representation\nwithin the JPEG file includes it.  (Hence the maximum data length is really\nonly 65533.)\n\nIt is possible that additional special markers appear in the file beyond the\nSOS marker at which jpeg_read_header stops; if so, the marker list will be\nextended during reading of the rest of the file.  This is not expected to be\ncommon, however.  If you are short on memory you may want to reset the length\nlimit to zero for all marker types after finishing jpeg_read_header, to\nensure that the max_memory_to_use setting cannot be exceeded due to addition\nof later markers.\n\nThe marker list remains stored until you call jpeg_finish_decompress or\njpeg_abort, at which point the memory is freed and the list is set to empty.\n(jpeg_destroy also releases the storage, of course.)\n\nNote that the library is internally interested in APP0 and APP14 markers;\nif you try to set a small nonzero length limit on these types, the library\nwill silently force the length up to the minimum it wants.  (But you can set\na zero length limit to prevent them from being saved at all.)  Also, in a\n16-bit environment, the maximum length limit may be constrained to less than\n65533 by malloc() limitations.  It is therefore best not to assume that the\neffective length limit is exactly what you set it to be.\n\n\nIf you want to supply your own marker-reading routine, you do it by calling\njpeg_set_marker_processor().  A marker processor routine must have the\nsignature\n        boolean jpeg_marker_parser_method (j_decompress_ptr cinfo)\nAlthough the marker code is not explicitly passed, the routine can find it\nin cinfo->unread_marker.  At the time of call, the marker proper has been\nread from the data source module.  The processor routine is responsible for\nreading the marker length word and the remaining parameter bytes, if any.\nReturn TRUE to indicate success.  (FALSE should be returned only if you are\nusing a suspending data source and it tells you to suspend.  See the standard\nmarker processors in jdmarker.c for appropriate coding methods if you need to\nuse a suspending data source.)\n\nIf you override the default APP0 or APP14 processors, it is up to you to\nrecognize JFIF and Adobe markers if you want colorspace recognition to occur\nproperly.  We recommend copying and extending the default processors if you\nwant to do that.  (A better idea is to save these marker types for later\nexamination by calling jpeg_save_markers(); that method doesn't interfere\nwith the library's own processing of these markers.)\n\njpeg_set_marker_processor() and jpeg_save_markers() are mutually exclusive\n--- if you call one it overrides any previous call to the other, for the\nparticular marker type specified.\n\nA simple example of an external COM processor can be found in djpeg.c.\nAlso, see jpegtran.c for an example of using jpeg_save_markers.\n\n\nICC profiles\n------------\n\nTwo functions are provided for writing and reading International Color\nConsortium (ICC) device profiles embedded in JFIF JPEG image files:\n\n        void jpeg_write_icc_profile (j_compress_ptr cinfo,\n                                     const JOCTET *icc_data_ptr,\n                                     unsigned int icc_data_len);\n        boolean jpeg_read_icc_profile (j_decompress_ptr cinfo,\n                                       JOCTET **icc_data_ptr,\n                                       unsigned int *icc_data_len);\n\nThe ICC has defined a standard for including such data in JPEG \"APP2\" markers.\nThe aforementioned functions do not know anything about the internal structure\nof the ICC profile data; they just know how to embed the profile data into a\nJPEG file while writing it, or to extract the profile data from a JPEG file\nwhile reading it.\n\njpeg_write_icc_profile() must be called after calling jpeg_start_compress() and\nbefore the first call to jpeg*_write_scanlines() or jpeg*_write_raw_data().\nThis ordering ensures that the APP2 marker(s) will appear after the SOI and\nJFIF or Adobe markers, but before all other data.\n\njpeg_read_icc_profile() returns TRUE if an ICC profile was found and FALSE\notherwise.  If an ICC profile was found, then the function will allocate a\nmemory region containing the profile and will return a pointer to that memory\nregion in *icc_data_ptr, as well as the length of the region in *icc_data_len.\nThis memory region is allocated by the library using malloc() and must be freed\nby the caller using free() when the memory region is no longer needed.  Callers\nwishing to use jpeg_read_icc_profile() must call\n\n        jpeg_save_markers(cinfo, JPEG_APP0 + 2, 0xFFFF);\n\nprior to calling jpeg_read_header().  jpeg_read_icc_profile() can be called at\nany point between jpeg_read_header() and jpeg_finish_decompress().\n\n\nRaw (downsampled) image data\n----------------------------\n\nSome applications need to supply already-downsampled image data to the JPEG\ncompressor, or to receive raw downsampled data from the decompressor.  The\nlibrary supports this requirement by allowing the application to write or\nread raw data, bypassing the normal preprocessing or postprocessing steps.\nThe interface is different from the standard one and is somewhat harder to\nuse.  If your interest is merely in bypassing color conversion, we recommend\nthat you use the standard interface and simply set jpeg_color_space =\nin_color_space (or jpeg_color_space = out_color_space for decompression).\nThe mechanism described in this section is necessary only to supply or\nreceive downsampled image data, in which not all components have the same\ndimensions.\n\n\nTo compress raw data, you must supply the data in the colorspace to be used\nin the JPEG file (please read the earlier section on Special color spaces)\nand downsampled to the sampling factors specified in the JPEG parameters.\nYou must supply the data in the format used internally by the JPEG library,\nnamely a J*SAMPIMAGE array.  This is an array of pointers to two-dimensional\narrays, each of type J*SAMPARRAY.  Each 2-D array holds the values for one\ncolor component.  This structure is necessary since the components are of\ndifferent sizes.  If the image dimensions are not a multiple of the MCU size,\nyou must also pad the data correctly (usually, this is done by replicating\nthe last column and/or row).  The data must be padded to a multiple of a DCT\nblock in each component: that is, each downsampled row must contain a\nmultiple of 8 valid samples, and there must be a multiple of 8 sample rows\nfor each component.  (For applications such as conversion of digital TV\nimages, the standard image size is usually a multiple of the DCT block size,\nso that no padding need actually be done.)\n\nThe procedure for compression of raw data is basically the same as normal\ncompression, except that you call jpeg_write_raw_data() or\njpeg12_write_raw_data() in place of jpeg_write_scanlines() or\njpeg12_write_scanlines().  Before calling jpeg_start_compress(), you must do\nthe following:\n  * Set cinfo->raw_data_in to TRUE.  (It is set FALSE by jpeg_set_defaults().)\n    This notifies the library that you will be supplying raw data.\n  * Ensure jpeg_color_space is correct --- an explicit jpeg_set_colorspace()\n    call is a good idea.  Note that since color conversion is bypassed,\n    in_color_space is ignored, except that jpeg_set_defaults() uses it to\n    choose the default jpeg_color_space setting.\n  * Ensure the sampling factors, cinfo->comp_info[i].h_samp_factor and\n    cinfo->comp_info[i].v_samp_factor, are correct.  Since these indicate the\n    dimensions of the data you are supplying, it's wise to set them\n    explicitly, rather than assuming the library's defaults are what you want.\n\nTo pass raw data to the library, call jpeg*_write_raw_data() in place of\njpeg*_write_scanlines().  The routines work similarly except that\njpeg*_write_raw_data takes a J*SAMPIMAGE data array rather than J*SAMPARRAY.\nThe scanlines count passed to and returned from jpeg*_write_raw_data is\nmeasured in terms of the component with the largest v_samp_factor.\n\njpeg*_write_raw_data() processes one MCU row per call, which is to say\nv_samp_factor*DCTSIZE sample rows of each component.  The passed num_lines\nvalue must be at least max_v_samp_factor*DCTSIZE, and the return value will\nbe exactly that amount (or possibly some multiple of that amount, in future\nlibrary versions).  This is true even on the last call at the bottom of the\nimage; don't forget to pad your data as necessary.\n\nThe required dimensions of the supplied data can be computed for each\ncomponent as\n        cinfo->comp_info[i].width_in_blocks*DCTSIZE  samples per row\n        cinfo->comp_info[i].height_in_blocks*DCTSIZE rows in image\nafter jpeg_start_compress() has initialized those fields.  If the valid data\nis smaller than this, it must be padded appropriately.  For some sampling\nfactors and image sizes, additional dummy DCT blocks are inserted to make\nthe image a multiple of the MCU dimensions.  The library creates such dummy\nblocks itself; it does not read them from your supplied data.  Therefore you\nneed never pad by more than DCTSIZE samples.  An example may help here.\nAssume 2h2v downsampling of YCbCr data, that is\n        cinfo->comp_info[0].h_samp_factor = 2           for Y\n        cinfo->comp_info[0].v_samp_factor = 2\n        cinfo->comp_info[1].h_samp_factor = 1           for Cb\n        cinfo->comp_info[1].v_samp_factor = 1\n        cinfo->comp_info[2].h_samp_factor = 1           for Cr\n        cinfo->comp_info[2].v_samp_factor = 1\nand suppose that the nominal image dimensions (cinfo->image_width and\ncinfo->image_height) are 101x101 pixels.  Then jpeg_start_compress() will\ncompute downsampled_width = 101 and width_in_blocks = 13 for Y,\ndownsampled_width = 51 and width_in_blocks = 7 for Cb and Cr (and the same\nfor the height fields).  You must pad the Y data to at least 13*8 = 104\ncolumns and rows, the Cb/Cr data to at least 7*8 = 56 columns and rows.  The\nMCU height is max_v_samp_factor = 2 DCT rows so you must pass at least 16\nscanlines on each call to jpeg*_write_raw_data(), which is to say 16 actual\nsample rows of Y and 8 each of Cb and Cr.  A total of 7 MCU rows are needed,\nso you must pass a total of 7*16 = 112 \"scanlines\".  The last DCT block row\nof Y data is dummy, so it doesn't matter what you pass for it in the data\narrays, but the scanlines count must total up to 112 so that all of the Cb\nand Cr data gets passed.\n\nOutput suspension is supported with raw-data compression: if the data\ndestination module suspends, jpeg*_write_raw_data() will return 0.\nIn this case the same data rows must be passed again on the next call.\n\n\nDecompression with raw data output implies bypassing all postprocessing:\nyou cannot ask for rescaling or color quantization, for instance.  More\nseriously, you must deal with the color space and sampling factors present in\nthe incoming file.  If your application only handles, say, 2h1v YCbCr data,\nyou must check for and fail on other color spaces or other sampling factors.\nThe library will not convert to a different color space for you.\n\nTo obtain raw data output, set cinfo->raw_data_out = TRUE before\njpeg_start_decompress() (it is set FALSE by jpeg_read_header()).  Be sure to\nverify that the color space and sampling factors are ones you can handle.\nThen call jpeg_read_raw_data() or jpeg12_read_raw_data() in place of\njpeg_read_scanlines() or jpeg12_read_scanlines().  The decompression process is\notherwise the same as usual.\n\njpeg*_read_raw_data() returns one MCU row per call, and thus you must pass a\nbuffer of at least max_v_samp_factor*DCTSIZE scanlines (scanline counting is\nthe same as for raw-data compression).  The buffer you pass must be large\nenough to hold the actual data plus padding to DCT-block boundaries.  As with\ncompression, any entirely dummy DCT blocks are not processed so you need not\nallocate space for them, but the total scanline count includes them.  The\nabove example of computing buffer dimensions for raw-data compression is\nequally valid for decompression.\n\nInput suspension is supported with raw-data decompression: if the data source\nmodule suspends, jpeg*_read_raw_data() will return 0.  You can also use\nbuffered-image mode to read raw data in multiple passes.\n\n\nReally raw data: DCT coefficients\n---------------------------------\n\nIt is possible to read or write the contents of a JPEG file as raw DCT\ncoefficients.  This facility is mainly intended for use in lossless\ntranscoding between different JPEG file formats.  Other possible applications\ninclude lossless cropping of a JPEG image, lossless reassembly of a\nmulti-strip or multi-tile TIFF/JPEG file into a single JPEG datastream, etc.\n\nTo read the contents of a JPEG file as DCT coefficients, open the file and do\njpeg_read_header() as usual.  But instead of calling jpeg_start_decompress()\nand jpeg*_read_scanlines(), call jpeg_read_coefficients().  This will read the\nentire image into a set of virtual coefficient-block arrays, one array per\ncomponent.  The return value is a pointer to an array of virtual-array\ndescriptors.  Each virtual array can be accessed directly using the JPEG\nmemory manager's access_virt_barray method (see Memory management, below,\nand also read structure.txt's discussion of virtual array handling).  Or,\nfor simple transcoding to a different JPEG file format, the array list can\njust be handed directly to jpeg_write_coefficients().\n\nEach block in the block arrays contains quantized coefficient values in\nnormal array order (not JPEG zigzag order).  The block arrays contain only\nDCT blocks containing real data; any entirely-dummy blocks added to fill out\ninterleaved MCUs at the right or bottom edges of the image are discarded\nduring reading and are not stored in the block arrays.  (The size of each\nblock array can be determined from the width_in_blocks and height_in_blocks\nfields of the component's comp_info entry.)  This is also the data format\nexpected by jpeg_write_coefficients().\n\nWhen you are done using the virtual arrays, call jpeg_finish_decompress()\nto release the array storage and return the decompression object to an idle\nstate; or just call jpeg_destroy() if you don't need to reuse the object.\n\nIf you use a suspending data source, jpeg_read_coefficients() will return\nNULL if it is forced to suspend; a non-NULL return value indicates successful\ncompletion.  You need not test for a NULL return value when using a\nnon-suspending data source.\n\nIt is also possible to call jpeg_read_coefficients() to obtain access to the\ndecoder's coefficient arrays during a normal decode cycle in buffered-image\nmode.  This frammish might be useful for progressively displaying an incoming\nimage and then re-encoding it without loss.  To do this, decode in buffered-\nimage mode as discussed previously, then call jpeg_read_coefficients() after\nthe last jpeg_finish_output() call.  The arrays will be available for your use\nuntil you call jpeg_finish_decompress().\n\n\nTo write the contents of a JPEG file as DCT coefficients, you must provide\nthe DCT coefficients stored in virtual block arrays.  You can either pass\nblock arrays read from an input JPEG file by jpeg_read_coefficients(), or\nallocate virtual arrays from the JPEG compression object and fill them\nyourself.  In either case, jpeg_write_coefficients() is substituted for\njpeg_start_compress() and jpeg*_write_scanlines().  Thus the sequence is\n  * Create compression object\n  * Set all compression parameters as necessary\n  * Request virtual arrays if needed\n  * jpeg_write_coefficients()\n  * jpeg_finish_compress()\n  * Destroy or re-use compression object\njpeg_write_coefficients() is passed a pointer to an array of virtual block\narray descriptors; the number of arrays is equal to cinfo.num_components.\n\nThe virtual arrays need only have been requested, not realized, before\njpeg_write_coefficients() is called.  A side-effect of\njpeg_write_coefficients() is to realize any virtual arrays that have been\nrequested from the compression object's memory manager.  Thus, when obtaining\nthe virtual arrays from the compression object, you should fill the arrays\nafter calling jpeg_write_coefficients().  The data is actually written out\nwhen you call jpeg_finish_compress(); jpeg_write_coefficients() only writes\nthe file header.\n\nWhen writing raw DCT coefficients, it is crucial that the JPEG quantization\ntables and sampling factors match the way the data was encoded, or the\nresulting file will be invalid.  For transcoding from an existing JPEG file,\nwe recommend using jpeg_copy_critical_parameters().  This routine initializes\nall the compression parameters to default values (like jpeg_set_defaults()),\nthen copies the critical information from a source decompression object.\nThe decompression object should have just been used to read the entire\nJPEG input file --- that is, it should be awaiting jpeg_finish_decompress().\n\njpeg_write_coefficients() marks all tables stored in the compression object\nas needing to be written to the output file (thus, it acts like\njpeg_start_compress(cinfo, TRUE)).  This is for safety's sake, to avoid\nemitting abbreviated JPEG files by accident.  If you really want to emit an\nabbreviated JPEG file, call jpeg_suppress_tables(), or set the tables'\nindividual sent_table flags, between calling jpeg_write_coefficients() and\njpeg_finish_compress().\n\n\nProgress monitoring\n-------------------\n\nSome applications may need to regain control from the JPEG library every so\noften.  The typical use of this feature is to produce a percent-done bar or\nother progress display.  (For a simple example, see cjpeg.c or djpeg.c.)\nAlthough you do get control back frequently during the data-transferring pass\n(the jpeg*_read_scanlines or jpeg*_write_scanlines loop), any additional passes\nwill occur inside jpeg_finish_compress or jpeg_start_decompress; those\nroutines may take a long time to execute, and you don't get control back\nuntil they are done.\n\nYou can define a progress-monitor routine which will be called periodically\nby the library.  No guarantees are made about how often this call will occur,\nso we don't recommend you use it for mouse tracking or anything like that.\nAt present, a call will occur once per MCU row, scanline, or sample row\ngroup, whichever unit is convenient for the current processing mode; so the\nwider the image, the longer the time between calls.  During the data\ntransferring pass, only one call occurs per call of jpeg*_read_scanlines or\njpeg*_write_scanlines, so don't pass a large number of scanlines at once if\nyou want fine resolution in the progress count.  (If you really need to use\nthe callback mechanism for time-critical tasks like mouse tracking, you could\ninsert additional calls inside some of the library's inner loops.)\n\nTo establish a progress-monitor callback, create a struct jpeg_progress_mgr,\nfill in its progress_monitor field with a pointer to your callback routine,\nand set cinfo->progress to point to the struct.  The callback will be called\nwhenever cinfo->progress is non-NULL.  (This pointer is set to NULL by\njpeg_create_compress or jpeg_create_decompress; the library will not change\nit thereafter.  So if you allocate dynamic storage for the progress struct,\nmake sure it will live as long as the JPEG object does.  Allocating from the\nJPEG memory manager with lifetime JPOOL_PERMANENT will work nicely.)  You\ncan use the same callback routine for both compression and decompression.\n\nThe jpeg_progress_mgr struct contains four fields which are set by the library:\n        long pass_counter;      /* work units completed in this pass */\n        long pass_limit;        /* total number of work units in this pass */\n        int completed_passes;   /* passes completed so far */\n        int total_passes;       /* total number of passes expected */\nDuring any one pass, pass_counter increases from 0 up to (not including)\npass_limit; the step size is usually but not necessarily 1.  The pass_limit\nvalue may change from one pass to another.  The expected total number of\npasses is in total_passes, and the number of passes already completed is in\ncompleted_passes.  Thus the fraction of work completed may be estimated as\n                completed_passes + (pass_counter/pass_limit)\n                --------------------------------------------\n                                total_passes\nignoring the fact that the passes may not be equal amounts of work.\n\nWhen decompressing, pass_limit can even change within a pass, because it\ndepends on the number of scans in the JPEG file, which isn't always known in\nadvance.  The computed fraction-of-work-done may jump suddenly (if the library\ndiscovers it has overestimated the number of scans) or even decrease (in the\nopposite case).  It is not wise to put great faith in the work estimate.\n\nWhen using the decompressor's buffered-image mode, the progress monitor work\nestimate is likely to be completely unhelpful, because the library has no way\nto know how many output passes will be demanded of it.  Currently, the library\nsets total_passes based on the assumption that there will be one more output\npass if the input file end hasn't yet been read (jpeg_input_complete() isn't\nTRUE), but no more output passes if the file end has been reached when the\noutput pass is started.  This means that total_passes will rise as additional\noutput passes are requested.  If you have a way of determining the input file\nsize, estimating progress based on the fraction of the file that's been read\nwill probably be more useful than using the library's value.\n\n\nMemory management\n-----------------\n\nThis section covers some key facts about the JPEG library's built-in memory\nmanager.  For more info, please read structure.txt's section about the memory\nmanager, and consult the source code if necessary.\n\nAll memory and temporary file allocation within the library is done via the\nmemory manager.  If necessary, you can replace the \"back end\" of the memory\nmanager to control allocation yourself (for example, if you don't want the\nlibrary to use malloc() and free() for some reason).\n\nSome data is allocated \"permanently\" and will not be freed until the JPEG\nobject is destroyed.  Most data is allocated \"per image\" and is freed by\njpeg_finish_compress, jpeg_finish_decompress, or jpeg_abort.  You can call the\nmemory manager yourself to allocate structures that will automatically be\nfreed at these times.  Typical code for this is\n  ptr = (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE, size);\nUse JPOOL_PERMANENT to get storage that lasts as long as the JPEG object.\nUse alloc_large instead of alloc_small for anything bigger than a few Kbytes.\nThere are also alloc_sarray and alloc_barray routines that automatically\nbuild 2-D sample or block arrays.\n\nThe library's minimum space requirements to process an image depend on the\nimage's width, but not on its height, because the library ordinarily works\nwith \"strip\" buffers that are as wide as the image but just a few rows high.\nSome operating modes (eg, two-pass color quantization) require full-image\nbuffers.  Such buffers are treated as \"virtual arrays\": only the current strip\nneed be in memory, and the rest can be swapped out to a temporary file.\n\nWhen using temporary files, the library will make the in-memory buffers for\nits virtual arrays just big enough to stay within a \"maximum memory\" setting.\nYour application can set this limit by setting cinfo->mem->max_memory_to_use\nafter creating the JPEG object.  (Of course, there is still a minimum size for\nthe buffers, so the max-memory setting is effective only if it is bigger than\nthe minimum space needed.)  If you allocate any large structures yourself, you\nmust allocate them before jpeg_start_compress() or jpeg_start_decompress() in\norder to have them counted against the max memory limit.  Also keep in mind\nthat space allocated with alloc_small() is ignored, on the assumption that\nit's too small to be worth worrying about; so a reasonable safety margin\nshould be left when setting max_memory_to_use.\n\nNOTE: Unless you develop your own memory manager back end, then temporary files\nwill never be used.  The back end provided in libjpeg-turbo (jmemnobs.c) simply\nmalloc()s and free()s virtual arrays, and an error occurs if the required\nmemory exceeds the limit specified in cinfo->mem->max_memory_to_use.\n\n\nMemory usage\n------------\n\nWorking memory requirements while performing compression or decompression\ndepend on image dimensions, image characteristics (such as colorspace and\nJPEG process), and operating mode (application-selected options).\n\nAs of v6b, the decompressor requires:\n 1. About 24K in more-or-less-fixed-size data.  This varies a bit depending\n    on operating mode and image characteristics (particularly color vs.\n    grayscale), but it doesn't depend on image dimensions.\n 2. Strip buffers (of size proportional to the image width) for IDCT and\n    upsampling results.  The worst case for commonly used sampling factors\n    is about 34 bytes * width in pixels for a color image.  A grayscale image\n    only needs about 8 bytes per pixel column.\n 3. A full-image DCT coefficient buffer is needed to decode a multi-scan JPEG\n    file (including progressive JPEGs), or whenever you select buffered-image\n    mode.  This takes 2 bytes/coefficient.  At typical 2x2 sampling, that's\n    3 bytes per pixel for a color image.  Worst case (1x1 sampling) requires\n    6 bytes/pixel.  For grayscale, figure 2 bytes/pixel.\n 4. To perform 2-pass color quantization, the decompressor also needs a\n    128K color lookup table and a full-image pixel buffer (3 bytes/pixel).\nThis does not count any memory allocated by the application, such as a\nbuffer to hold the final output image.\n\nThe above figures are valid for 8-bit JPEG data precision and a machine with\n32-bit ints.  For 12-bit-per-sample and 16-bit-per-sample JPEG data, double the\nsize of the strip buffers and quantization pixel buffer.  The \"fixed-size\" data\nwill be somewhat smaller with 16-bit ints, larger with 64-bit ints.  Also, CMYK\nor other unusual color spaces will require different amounts of space.\n\nThe full-image coefficient and pixel buffers, if needed at all, do not\nhave to be fully RAM resident; you can have the library use temporary\nfiles instead when the total memory usage would exceed a limit you set.\n(But if your OS supports virtual memory, it's probably better to just use\njmemnobs and let the OS do the swapping.)\n\nThe compressor's memory requirements are similar, except that it has no need\nfor color quantization.  Also, it needs a full-image DCT coefficient buffer\nif Huffman-table optimization is asked for, even if progressive mode is not\nrequested.\n\nIf you need more detailed information about memory usage in a particular\nsituation, you can enable the MEM_STATS code in jmemmgr.c.\n\n\nLibrary compile-time options\n----------------------------\n\nA number of compile-time options are available by modifying jmorecfg.h.\n\nThe maximum number of components (color channels) in the image is determined\nby MAX_COMPONENTS.  The JPEG standard allows up to 255 components, but we\nexpect that few applications will need more than four or so.\n\nYou can reduce the size of the library by compiling out various optional\nfunctions.  To do this, undefine xxx_SUPPORTED symbols as necessary.\n\nYou can also save a few K by not having text error messages in the library;\nthe standard error message table occupies about 5Kb.  This is particularly\nreasonable for embedded applications where there's no good way to display\na message anyway.  To do this, remove the creation of the message table\n(jpeg_std_message_table[]) from jerror.c, and alter format_message to do\nsomething reasonable without it.  You could output the numeric value of the\nmessage code number, for example.  If you do this, you can also save a couple\nmore K by modifying the TRACEMSn() macros in jerror.h to expand to nothing;\nyou don't need trace capability anyway, right?\n\n\nPortability considerations\n--------------------------\n\nThe JPEG library has been written to be extremely portable; the sample\napplications cjpeg and djpeg are slightly less so.  This section summarizes\nthe design goals in this area.  (If you encounter any bugs that cause the\nlibrary to be less portable than is claimed here, we'd appreciate hearing\nabout them.)\n\nThe code works fine on ANSI C and C++ compilers, using any of the popular\nsystem include file setups, and some not-so-popular ones too.\n\nThe code is not dependent on the exact sizes of the C data types.  As\ndistributed, we make the assumptions that\n        char    is at least 8 bits wide\n        short   is at least 16 bits wide\n        int     is at least 16 bits wide\n        long    is at least 32 bits wide\n(These are the minimum requirements of the ANSI C standard.)  Wider types will\nwork fine, although memory may be used inefficiently if char is much larger\nthan 8 bits or short is much bigger than 16 bits.  The code should work\nequally well with 16- or 32-bit ints.\n\nIn a system where these assumptions are not met, you may be able to make the\ncode work by modifying the typedefs in jmorecfg.h.\n\nchar can be either signed or unsigned, although the code runs faster if an\nunsigned char type is available.  If char is wider than 8 bits, you will need\nto redefine JOCTET and/or provide custom data source/destination managers so\nthat JOCTET represents exactly 8 bits of data on external storage.\n\nThe JPEG library proper does not assume ASCII representation of characters.\nBut some of the image file I/O modules in cjpeg/djpeg do have ASCII\ndependencies in file-header manipulation; so does cjpeg's select_file_type()\nroutine.\n\nThe JPEG library does not rely heavily on the C library.  In particular, C\nstdio is used only by the data source/destination modules and the error\nhandler, all of which are application-replaceable.  (cjpeg/djpeg are more\nheavily dependent on stdio.)  malloc and free are called only from the memory\nmanager \"back end\" module, so you can use a different memory allocator by\nreplacing that one file.\n\nMore info about porting the code may be gleaned by reading jconfig.txt,\njmorecfg.h, and jinclude.h.\n"
        },
        {
          "name": "md5",
          "type": "tree",
          "content": null
        },
        {
          "name": "mozjpeg.podspec",
          "type": "blob",
          "size": 5.4169921875,
          "content": "Pod::Spec.new do |spec|\n  spec.name = \"mozjpeg\"\n  spec.version = \"3.3.1\"\n  spec.license = { :type => \"BSD\" }\n  spec.homepage = \"https://github.com/mozilla/mozjpeg\"\n  spec.summary = \"Improved JPEG encoder.\"\n  spec.authors = \"Mozilla\"\n  spec.source = { :git => \"https://github.com/mozilla/mozjpeg.git\", :tag => \"v#{spec.version}\" }\n  spec.module_name = \"mozjpeg\"\n  spec.header_dir = \"mozjpeg\"\n  spec.platforms = { :ios => \"8.0\" }\n  spec.prepare_command = <<-CMD\n    cat << EOF > jconfig.h\n    #define JPEG_LIB_VERSION  80\t/* Version 6b */\n    #define LIBJPEG_TURBO_VERSION 3.1.m\n    #define LIBJPEG_TURBO_VERSION_NUMBER 1\n    #define C_ARITH_CODING_SUPPORTED 1\n    #define D_ARITH_CODING_SUPPORTED 1\n    #define BITS_IN_JSAMPLE  8\n    #define HAVE_LOCALE_H 1\n    #define HAVE_STDDEF_H 1\n    #define HAVE_STDLIB_H 1\n    #define HAVE_UNSIGNED_CHAR 1\n    #define HAVE_UNSIGNED_SHORT 1\n    #define NEED_SYS_TYPES_H 1\n    #define WITH_SIMD 0\n    EOF\n\n\n    cat << EOF > jconfigint.h\n    #define BUILD \"20180328\"\n    #define INLINE __attribute__((always_inline))\n    #define PACKAGE_NAME \"mozjpeg\"\n    #define VERSION \"#{spec.version}\"\n    #ifdef __SIZEOF_SIZE_T__\n      #define SIZEOF_SIZE_T __SIZEOF_SIZE_T__\n    #else\n      #error Cannot determine the size of size_t\n    #endif\n    EOF\n  CMD\n\n  spec.private_header_files = \"bmp.h\",\n                              \"cderror.h\",\n                              \"cdjpeg.h\",\n                              \"jchuff.h\",\n                              \"jcmaster.h\",\n                              \"jconfigint.h\",\n                              \"jdcoefct.h\",\n                              \"jdct.h\",\n                              \"jdhuff.h\",\n                              \"jdmainct.h\",\n                              \"jdmaster.h\",\n                              \"jdsample.h\",\n                              \"jmemsys.h\",\n                              \"jpeg_nbits_table.h\",\n                              \"jpegcomp.h\",\n                              \"jsimd.h\",\n                              \"jsimddct.h\",\n                              \"jversion.h\",\n                              \"wrppm.h\"\n\n  spec.public_header_files = \"jerror.h\",\n                             \"jinclude.h\",\n                             \"jconfig.h\",\n                             \"jmorecfg.h\",\n                             \"jpeglib.h\",\n                             \"jpegint.h\",\n                             \"transupp.h\"\n\n  spec.source_files = \"jcapimin.c\",\n                      \"jcapistd.c\",\n                      \"jccoefct.c\",\n                      \"jccolor.c\",\n                      \"jcdctmgr.c\",\n                      \"jcext.c\",\n                      \"jchuff.c\",\n                      \"jcinit.c\",\n                      \"jcmainct.c\",\n                      \"jcmarker.c\",\n                      \"jcmaster.c\",\n                      \"jcomapi.c\",\n                      \"jcparam.c\",\n                      \"jcphuff.c\",\n                      \"jcprepct.c\",\n                      \"jcsample.c\",\n                      \"jctrans.c\",\n                      \"jdapimin.c\",\n                      \"jdapistd.c\",\n                      \"jdatadst.c\",\n                      \"jdatasrc.c\",\n                      \"jdcoefct.c\",\n                      \"jdcolor.c\",\n                      \"jddctmgr.c\",\n                      \"jdhuff.c\",\n                      \"jdinput.c\",\n                      \"jdmainct.c\",\n                      \"jdmarker.c\",\n                      \"jdmaster.c\",\n                      \"jdmerge.c\",\n                      \"jdphuff.c\",\n                      \"jdpostct.c\",\n                      \"jdsample.c\",\n                      \"jdtrans.c\",\n                      \"jerror.c\",\n                      \"jfdctflt.c\",\n                      \"jfdctfst.c\",\n                      \"jfdctint.c\",\n                      \"jidctflt.c\",\n                      \"jidctfst.c\",\n                      \"jidctint.c\",\n                      \"jidctred.c\",\n                      \"jquant1.c\",\n                      \"jquant2.c\",\n                      \"jutils.c\",\n                      \"jmemmgr.c\",\n                      \"jaricom.c\",\n                      \"jcarith.c\",\n                      \"jdarith.c\",\n                      \"transupp.c\",\n                      \"jmemnobs.c\",\n                      \"jsimd_none.c\",\n                      \"jerror.h\",\n                      \"jinclude.h\",\n                      \"jconfig.h\",\n                      \"jmorecfg.h\",\n                      \"jpeglib.h\",\n                      \"jpegint.h\",\n                      \"transupp.h\",\n                      \"bmp.h\",\n                      \"cderror.h\",\n                      \"cdjpeg.h\",\n                      \"jchuff.h\",\n                      \"jcmaster.h\",\n                      \"jconfigint.h\",\n                      \"jdcoefct.h\",\n                      \"jdct.h\",\n                      \"jdhuff.h\",\n                      \"jdmainct.h\",\n                      \"jdmaster.h\",\n                      \"jdsample.h\",\n                      \"jmemsys.h\",\n                      \"jpeg_nbits_table.h\",\n                      \"jpegcomp.h\",\n                      \"jsimd.h\",\n                      \"jsimddct.h\",\n                      \"jversion.h\",\n                      \"wrppm.h\"\n\n  # Despite their extensions, these are header files that shouldn't be compiled\n  # on their own but should still be present for other files to include.\n  spec.preserve_path = \"jdcolext.c\",\n                       \"jstdhuff.c\",\n                       \"jdcol565.c\",\n                       \"jdmrgext.c\",\n                       \"jdmrg565.c\",\n                       \"jccolext.c\"\nend\n"
        },
        {
          "name": "rd_average.sh",
          "type": "blob",
          "size": 0.400390625,
          "content": "#!/bin/bash\nset -e\n\nif [ $# == 0 ]; then\n  echo \"usage: OUTPUT=<label> $0 *.out\"\n  exit 1\nfi\n\nTOTAL=total.out\n\nif [ -n \"$OUTPUT\" ]; then\n  TOTAL=\"$OUTPUT.out\"\nfi\n\nawk '{size[FNR]+=$2;bytes[FNR]+=$3;psnr[FNR]+=$2*$4;psnrhvs[FNR]+=$2*$5;ssim[FNR]+=$2*$6;fastssim[FNR]+=$2*$7;}END{for(i=1;i<=FNR;i++)print i-1,size[i],bytes[i],psnr[i]/size[i],psnrhvs[i]/size[i],ssim[i]/size[i],fastssim[i]/size[i];}' $@ > $TOTAL\n"
        },
        {
          "name": "rd_collect.sh",
          "type": "blob",
          "size": 2.3232421875,
          "content": "#!/bin/bash\nset -e\n\nif [ $# == 0 ]; then\n  echo \"usage: DAALA_ROOT=<daala_root> MOZJPEG_ROOT=<mozjpeg_root> $0 *.y4m\"\n  exit 1\nfi\n\nif [ -z $MOZJPEG_ROOT ]; then\n  MOZJPEG_ROOT=.\nfi\n\nif [ -z $DAALA_ROOT ]; then\n  echo \"DAALA_ROOT not set.\"\n  exit 1\nfi\n\nif [ -z \"$PLANE\" ]; then\n  export PLANE=0\nfi\n\nif [ $PLANE != 0 ] && [ $PLANE != 1 ] && [ $PLANE != 2 ]; then\n  echo \"Invalid plane $PLANE. Must be 0, 1 or 2.\"\n  exit 1\nfi\n\nif [ -z \"$YUVJPEG\" ]; then\n  export YUVJPEG=$MOZJPEG_ROOT/yuvjpeg\nfi\n\nif [ -z \"$JPEGYUV\" ]; then\n  export JPEGYUV=$MOZJPEG_ROOT/jpegyuv\nfi\n\nif [ ! -x \"$YUVJPEG\" ]; then\n  echo \"Executable not found YUVJPEG=$YUVJPEG\"\n  echo \"Do you have the right MOZJPEG_ROOT=$MOZJPEG_ROOT\"\n  exit 1\nfi\n\nif [ ! -x \"$JPEGYUV\" ]; then\n  echo \"Executable not found JPEGYUV=$JPEGYUV\"\n  echo \"Do you have the right MOZJPEG_ROOT=$MOZJPEG_ROOT\"\n  exit 1\nfi\n\n# TODO refactor these out of the daala project into a metrics project\n\nif [ -z \"$YUV2YUV4MPEG\" ]; then\n  export YUV2YUV4MPEG=$DAALA_ROOT/tools/yuv2yuv4mpeg\nfi\n\nif [ -z \"$DUMP_PSNR\" ]; then\n  export DUMP_PSNR=$DAALA_ROOT/tools/dump_psnr\nfi\n\nif [ -z \"$DUMP_PSNRHVS\" ]; then\n  export DUMP_PSNRHVS=$DAALA_ROOT/tools/dump_psnrhvs\nfi\n\nif [ -z \"$DUMP_SSIM\" ]; then\n  export DUMP_SSIM=$DAALA_ROOT/tools/dump_ssim\nfi\n\nif [ -z \"$DUMP_FASTSSIM\" ]; then\n  export DUMP_FASTSSIM=$DAALA_ROOT/tools/dump_fastssim\nfi\n\nif [ ! -x \"$YUV2YUV4MPEG\" ]; then\n  echo \"Executable not found YUV2YUV4MPEG=$YUV2YUV4MPEG\"\n  echo \"Do you have the right DAALA_ROOT=$DAALA_ROOT\"\n  exit 1\nfi\n\nif [ ! -x \"$DUMP_PSNR\" ]; then\n  echo \"Executable not found DUMP_PSNR=$DUMP_PSNR\"\n  echo \"Do you have the right DAALA_ROOT=$DAALA_ROOT\"\n  exit 1\nfi\n\nif [ ! -x \"$DUMP_PSNRHVS\" ]; then\n  echo \"Executable not found DUMP_PSNRHVS=$DUMP_PSNRHVS\"\n  echo \"Do you have the right DAALA_ROOT=$DAALA_ROOT\"\n  exit 1\nfi\n\nif [ ! -x \"$DUMP_SSIM\" ]; then\n  echo \"Executable not found DUMP_SSIM=$DUMP_SSIM\"\n  echo \"Do you have the right DAALA_ROOT=$DAALA_ROOT\"\n  exit 1\nfi\n\nif [ ! -x \"$DUMP_FASTSSIM\" ]; then\n  echo \"Executable not found DUMP_FASTSSIM=$DUMP_FASTSSIM\"\n  echo \"Do you have the right DAALA_ROOT=$DAALA_ROOT\"\n  exit 1\nfi\n\nRD_COLLECT_SUB=$(dirname \"$0\")/rd_collect_sub.sh\n\nif [ -z \"$CORES\" ]; then\n  CORES=`grep -i processor /proc/cpuinfo | wc -l`\n  #echo \"CORES not set, using $CORES\"\nfi\n\nfind $@ -type f -name \"*.y4m\" -print0 | xargs -0 -n1 -P$CORES $RD_COLLECT_SUB\n"
        },
        {
          "name": "rd_collect_sub.sh",
          "type": "blob",
          "size": 1.1171875,
          "content": "#!/bin/bash\nset -e\n\nFILE=$1\n\nBASENAME=$(basename $FILE)\nrm $BASENAME.out 2> /dev/null || true\necho $BASENAME\ntail -n+3 $FILE > $BASENAME-in.yuv\nWIDTH=$(head -1 $FILE | cut -d\\  -f 2 | tr -d 'W')\nHEIGHT=$(head -1 $FILE | cut -d\\  -f 3 | tr -d 'H')\n\nfor x in {0..100}; do\n  $YUVJPEG $x \"$WIDTH\"x$HEIGHT $BASENAME-in.yuv $BASENAME.jpeg\n  $JPEGYUV $BASENAME.jpeg $BASENAME.yuv\n  $YUV2YUV4MPEG $BASENAME -w$WIDTH -h$HEIGHT -an0 -ad0 -c420mpeg2\n  PIXELS=$(($WIDTH*$HEIGHT))\n  SIZE=$(wc -c $BASENAME.jpeg | awk '{ print $1 }')\n  PSNR=$($DUMP_PSNR $FILE $BASENAME.y4m 2> /dev/null | grep Total | tr -s ' ' | cut -d\\  -f $((4+$PLANE*2)))\n  PSNRHVS=$($DUMP_PSNRHVS $FILE $BASENAME.y4m 2> /dev/null | grep Total | tr -s ' ' | cut -d\\  -f $((4+$PLANE*2)))\n  SSIM=$($DUMP_SSIM $FILE $BASENAME.y4m 2> /dev/null | grep Total | tr -s ' ' | cut -d\\  -f $((4+$PLANE*2)))\n  FASTSSIM=$($DUMP_FASTSSIM -c $FILE $BASENAME.y4m 2> /dev/null | grep Total | tr -s ' ' | cut -d\\  -f $((4+$PLANE*2)))\n  rm $BASENAME.jpeg $BASENAME.yuv $BASENAME.y4m\n  echo $x $PIXELS $SIZE $PSNR $PSNRHVS $SSIM $FASTSSIM >> $BASENAME.out\n  #tail -1 $BASENAME.out\ndone\n\nrm $BASENAME-in.yuv\n"
        },
        {
          "name": "rd_plot.sh",
          "type": "blob",
          "size": 1.6796875,
          "content": "#!/bin/bash\nset -e\n\n# Use this to average data from multiple runs\n#awk '{size[FNR]+=$2;bytes[FNR]+=$3;psnr[FNR]+=$2*$4;psnrhvs[FNR]+=$2*$5;ssim[FNR]+=$2*$6;fastssim[FNR]+=$2*$7;}END{for(i=1;i<=FNR;i++)print i+1,size[i],bytes[i],psnr[i]/size[i],psnrhvs[i]/size[i],ssim[i]/size[i],fastssim[i]/size[i];}' *.out > total.out\n\nif [ -n \"$IMAGE\" ]; then\n  IMAGE=\"$IMAGE-\"\nfi\n\nif [ $# == 0 ]; then\n  echo \"usage: IMAGE=<prefix> $0 *.out\"\n  exit 1\nfi\n\nif [ -z \"$GNUPLOT\" -a -n \"`type -p gnuplot`\" ]; then\n  GNUPLOT=`type -p gnuplot`\nfi\nif [ ! -x \"$GNUPLOT\" ]; then\n  echo \"Executable not found GNUPLOT=$GNUPLOT\"\n  echo \"Please install it or set GNUPLOT to point to an installed copy\"\n  exit 1\nfi\n\nCMDS=\"$CMDS set term pngcairo dashed size 1024,768;\"\nCMDS=\"$CMDS set log x;\"\nCMDS=\"$CMDS set xlabel 'Bits/Pixel';\"\nCMDS=\"$CMDS set ylabel 'dB';\"\nCMDS=\"$CMDS set key bot right;\"\n\nfor FILE in \"$@\"; do\n  BASENAME=$(basename $FILE)\n  PSNR=\"$PSNR $PREFIX '$FILE' using (\\$3*8/\\$2):4 with lines title '${BASENAME%.*} (PSNR)'\"\n  PSNRHVS=\"$PSNRHVS $PREFIX '$FILE' using (\\$3*8/\\$2):5 with lines title '${BASENAME%.*} (PSNR-HVS)'\"\n  SSIM=\"$SSIM $PREFIX '$FILE' using (\\$3*8/\\$2):6 with lines title '${BASENAME%.*} (SSIM)'\"\n  FASTSSIM=\"$FASTSSIM $PREFIX '$FILE' using (\\$3*8/\\$2):7 with lines title '${BASENAME%.*} (FAST SSIM)'\"\n  PREFIX=\",\"\ndone\n\nSUFFIX=\"psnr.png\"\n$GNUPLOT -e \"$CMDS set output \\\"$IMAGE$SUFFIX\\\"; plot $PSNR;\"     2> /dev/null\nSUFFIX=\"psnrhvs.png\"\n$GNUPLOT -e \"$CMDS set output \\\"$IMAGE$SUFFIX\\\"; plot $PSNRHVS;\"  2> /dev/null\nSUFFIX=\"ssim.png\"\n$GNUPLOT -e \"$CMDS set output \\\"$IMAGE$SUFFIX\\\"; plot $SSIM;\"     2> /dev/null\nSUFFIX=\"fastssim.png\"\n$GNUPLOT -e \"$CMDS set output \\\"$IMAGE$SUFFIX\\\"; plot $FASTSSIM;\" 2> /dev/null\n"
        },
        {
          "name": "rdbmp.c",
          "type": "blob",
          "size": 22.6025390625,
          "content": "/*\n * rdbmp.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * Modified 2009-2017 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Modified 2011 by Siarhei Siamashka.\n * Copyright (C) 2015, 2017-2018, 2021-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to read input images in Microsoft \"BMP\"\n * format (MS Windows 3.x, OS/2 1.x, and OS/2 2.x flavors).\n * Currently, only 8-, 24-, and 32-bit images are supported, not 1-bit or\n * 4-bit (feeding such low-depth images into JPEG would be silly anyway).\n * Also, we don't support RLE-compressed files.\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume input from\n * an ordinary stdio stream.  They further assume that reading begins\n * at the start of the file; start_input may need work if the\n * user interface has already read some data (e.g., to determine that\n * the file is indeed BMP format).\n *\n * This code contributed by James Arthur Boucher.\n */\n\n#include \"cmyk.h\"\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n\n#ifdef BMP_SUPPORTED\n\n\n/* Macros to deal with unsigned chars as efficiently as compiler allows */\n\ntypedef unsigned char U_CHAR;\n#define UCH(x)  ((int)(x))\n\n\n#define ReadOK(file, buffer, len) \\\n  (fread(buffer, 1, len, file) == ((size_t)(len)))\n\nstatic int alpha_index[JPEG_NUMCS] = {\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1\n};\n\n\n/* Private version of data source object */\n\ntypedef struct _bmp_source_struct *bmp_source_ptr;\n\ntypedef struct _bmp_source_struct {\n  struct cjpeg_source_struct pub; /* public fields */\n\n  j_compress_ptr cinfo;         /* back link saves passing separate parm */\n\n  JSAMPARRAY colormap;          /* BMP colormap (converted to my format) */\n\n  jvirt_sarray_ptr whole_image; /* Needed to reverse row order */\n  JDIMENSION source_row;        /* Current source row number */\n  JDIMENSION row_width;         /* Physical width of scanlines in file */\n\n  int bits_per_pixel;           /* remembers 8-, 24-, or 32-bit format */\n  int cmap_length;              /* colormap length */\n\n  boolean use_inversion_array;  /* TRUE = preload the whole image, which is\n                                   stored in bottom-up order, and feed it to\n                                   the calling program in top-down order\n\n                                   FALSE = the calling program will maintain\n                                   its own image buffer and read the rows in\n                                   bottom-up order */\n\n  U_CHAR *iobuffer;             /* I/O buffer (used to buffer a single row from\n                                   disk if use_inversion_array == FALSE) */\n} bmp_source_struct;\n\n\nLOCAL(int)\nread_byte(bmp_source_ptr sinfo)\n/* Read next byte from BMP file */\n{\n  register FILE *infile = sinfo->pub.input_file;\n  register int c;\n\n  if ((c = getc(infile)) == EOF)\n    ERREXIT(sinfo->cinfo, JERR_INPUT_EOF);\n  return c;\n}\n\n\nLOCAL(void)\nread_colormap(bmp_source_ptr sinfo, int cmaplen, int mapentrysize)\n/* Read the colormap from a BMP file */\n{\n  int i, gray = 1;\n\n  switch (mapentrysize) {\n  case 3:\n    /* BGR format (occurs in OS/2 files) */\n    for (i = 0; i < cmaplen; i++) {\n      sinfo->colormap[2][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);\n      if (sinfo->colormap[2][i] != sinfo->colormap[1][i] ||\n          sinfo->colormap[1][i] != sinfo->colormap[0][i])\n        gray = 0;\n    }\n    break;\n  case 4:\n    /* BGR0 format (occurs in MS Windows files) */\n    for (i = 0; i < cmaplen; i++) {\n      sinfo->colormap[2][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);\n      (void)read_byte(sinfo);\n      if (sinfo->colormap[2][i] != sinfo->colormap[1][i] ||\n          sinfo->colormap[1][i] != sinfo->colormap[0][i])\n        gray = 0;\n    }\n    break;\n  default:\n    ERREXIT(sinfo->cinfo, JERR_BMP_BADCMAP);\n    break;\n  }\n\n  if ((sinfo->cinfo->in_color_space == JCS_UNKNOWN ||\n       sinfo->cinfo->in_color_space == JCS_RGB) && gray)\n    sinfo->cinfo->in_color_space = JCS_GRAYSCALE;\n\n  if (sinfo->cinfo->in_color_space == JCS_GRAYSCALE && !gray)\n    ERREXIT(sinfo->cinfo, JERR_BAD_IN_COLORSPACE);\n}\n\n\n/*\n * Read one row of pixels.\n * The image has been read into the whole_image array, but is otherwise\n * unprocessed.  We must read it out in top-to-bottom row order, and if\n * it is an 8-bit image, we must expand colormapped pixels to 24bit format.\n */\n\nMETHODDEF(JDIMENSION)\nget_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 8-bit colormap indexes */\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  register JSAMPARRAY colormap = source->colormap;\n  int cmaplen = source->cmap_length;\n  JSAMPARRAY image_ptr;\n  register int t;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n\n  if (source->use_inversion_array) {\n    /* Fetch next row from virtual array */\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n\n  /* Expand the colormap indexes to real data */\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_GRAYSCALE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      t = *inptr++;\n      if (t >= cmaplen)\n        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n      *outptr++ = colormap[0][t];\n    }\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      t = *inptr++;\n      if (t >= cmaplen)\n        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n      rgb_to_cmyk(colormap[0][t], colormap[1][t], colormap[2][t], outptr,\n                  outptr + 1, outptr + 2, outptr + 3);\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        t = *inptr++;\n        if (t >= cmaplen)\n          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n        outptr[rindex] = colormap[0][t];\n        outptr[gindex] = colormap[1][t];\n        outptr[bindex] = colormap[2][t];\n        outptr[aindex] = 0xFF;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        t = *inptr++;\n        if (t >= cmaplen)\n          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n        outptr[rindex] = colormap[0][t];\n        outptr[gindex] = colormap[1][t];\n        outptr[bindex] = colormap[2][t];\n        outptr += ps;\n      }\n    }\n  }\n\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_24bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 24-bit pixels */\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n\n  if (source->use_inversion_array) {\n    /* Fetch next row from virtual array */\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n\n  /* Transfer data.  Note source values are in BGR order\n   * (even though Microsoft's own documents say the opposite).\n   */\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGR) {\n    memcpy(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = 0xFF;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr += ps;\n      }\n    }\n  }\n\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_32bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 32-bit pixels */\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n\n  if (source->use_inversion_array) {\n    /* Fetch next row from virtual array */\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n\n  /* Transfer data.  Note source values are in BGR order\n   * (even though Microsoft's own documents say the opposite).\n   */\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGRX ||\n      cinfo->in_color_space == JCS_EXT_BGRA) {\n    memcpy(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      inptr++;                          /* skip the 4th byte (Alpha channel) */\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = *inptr++;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;\n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        inptr++;                        /* skip the 4th byte (Alpha channel) */\n        outptr += ps;\n      }\n    }\n  }\n\n  return 1;\n}\n\n\n/*\n * This method loads the image into whole_image during the first call on\n * get_pixel_rows.  The get_pixel_rows pointer is then adjusted to call\n * get_8bit_row, get_24bit_row, or get_32bit_row on subsequent calls.\n */\n\nMETHODDEF(JDIMENSION)\npreload_image(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  register FILE *infile = source->pub.input_file;\n  register JSAMPROW out_ptr;\n  JSAMPARRAY image_ptr;\n  JDIMENSION row;\n  cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n\n  /* Read the data into a virtual array in input-file row order. */\n  for (row = 0; row < cinfo->image_height; row++) {\n    if (progress != NULL) {\n      progress->pub.pass_counter = (long)row;\n      progress->pub.pass_limit = (long)cinfo->image_height;\n      (*progress->pub.progress_monitor) ((j_common_ptr)cinfo);\n    }\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image, row, (JDIMENSION)1, TRUE);\n    out_ptr = image_ptr[0];\n    if (fread(out_ptr, 1, source->row_width, infile) != source->row_width) {\n      if (feof(infile))\n        ERREXIT(cinfo, JERR_INPUT_EOF);\n      else\n        ERREXIT(cinfo, JERR_FILE_READ);\n    }\n  }\n  if (progress != NULL)\n    progress->completed_extra_passes++;\n\n  /* Set up to read from the virtual array in top-to-bottom order */\n  switch (source->bits_per_pixel) {\n  case 8:\n    source->pub.get_pixel_rows = get_8bit_row;\n    break;\n  case 24:\n    source->pub.get_pixel_rows = get_24bit_row;\n    break;\n  case 32:\n    source->pub.get_pixel_rows = get_32bit_row;\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n  }\n  source->source_row = cinfo->image_height;\n\n  /* And read the first row */\n  return (*source->pub.get_pixel_rows) (cinfo, sinfo);\n}\n\n\n/*\n * Read the file header; return image size and component count.\n */\n\nMETHODDEF(void)\nstart_input_bmp(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  U_CHAR bmpfileheader[14];\n  U_CHAR bmpinfoheader[64];\n\n#define GET_2B(array, offset) \\\n  ((unsigned short)UCH(array[offset]) + \\\n   (((unsigned short)UCH(array[offset + 1])) << 8))\n#define GET_4B(array, offset) \\\n  ((unsigned int)UCH(array[offset]) + \\\n   (((unsigned int)UCH(array[offset + 1])) << 8) + \\\n   (((unsigned int)UCH(array[offset + 2])) << 16) + \\\n   (((unsigned int)UCH(array[offset + 3])) << 24))\n\n  int bfOffBits;\n  int headerSize;\n  int biWidth;\n  int biHeight;\n  unsigned short biPlanes;\n  unsigned int biCompression;\n  int biXPelsPerMeter, biYPelsPerMeter;\n  int biClrUsed = 0;\n  int mapentrysize = 0;         /* 0 indicates no colormap */\n  int bPad;\n  JDIMENSION row_width = 0;\n\n  /* Read and verify the bitmap file header */\n  if (!ReadOK(source->pub.input_file, bmpfileheader, 14))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  if (GET_2B(bmpfileheader, 0) != 0x4D42) /* 'BM' */\n    ERREXIT(cinfo, JERR_BMP_NOT);\n  bfOffBits = GET_4B(bmpfileheader, 10);\n  /* We ignore the remaining fileheader fields */\n\n  /* The infoheader might be 12 bytes (OS/2 1.x), 40 bytes (Windows),\n   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.\n   */\n  if (!ReadOK(source->pub.input_file, bmpinfoheader, 4))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  headerSize = GET_4B(bmpinfoheader, 0);\n  if (headerSize < 12 || headerSize > 64 || (headerSize + 14) > bfOffBits)\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n  if (!ReadOK(source->pub.input_file, bmpinfoheader + 4, headerSize - 4))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n\n  switch (headerSize) {\n  case 12:\n    /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */\n    biWidth = (int)GET_2B(bmpinfoheader, 4);\n    biHeight = (int)GET_2B(bmpinfoheader, 6);\n    biPlanes = GET_2B(bmpinfoheader, 8);\n    source->bits_per_pixel = (int)GET_2B(bmpinfoheader, 10);\n\n    switch (source->bits_per_pixel) {\n    case 8:                     /* colormapped image */\n      mapentrysize = 3;         /* OS/2 uses RGBTRIPLE colormap */\n      TRACEMS2(cinfo, 1, JTRC_BMP_OS2_MAPPED, biWidth, biHeight);\n      break;\n    case 24:                    /* RGB image */\n    case 32:                    /* RGB image + Alpha channel */\n      TRACEMS3(cinfo, 1, JTRC_BMP_OS2, biWidth, biHeight,\n               source->bits_per_pixel);\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n      break;\n    }\n    break;\n  case 40:\n  case 64:\n    /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */\n    /* or OS/2 2.x header, which has additional fields that we ignore */\n    biWidth = (int)GET_4B(bmpinfoheader, 4);\n    biHeight = (int)GET_4B(bmpinfoheader, 8);\n    biPlanes = GET_2B(bmpinfoheader, 12);\n    source->bits_per_pixel = (int)GET_2B(bmpinfoheader, 14);\n    biCompression = GET_4B(bmpinfoheader, 16);\n    biXPelsPerMeter = (int)GET_4B(bmpinfoheader, 24);\n    biYPelsPerMeter = (int)GET_4B(bmpinfoheader, 28);\n    biClrUsed = GET_4B(bmpinfoheader, 32);\n    /* biSizeImage, biClrImportant fields are ignored */\n\n    switch (source->bits_per_pixel) {\n    case 8:                     /* colormapped image */\n      mapentrysize = 4;         /* Windows uses RGBQUAD colormap */\n      TRACEMS2(cinfo, 1, JTRC_BMP_MAPPED, biWidth, biHeight);\n      break;\n    case 24:                    /* RGB image */\n    case 32:                    /* RGB image + Alpha channel */\n      TRACEMS3(cinfo, 1, JTRC_BMP, biWidth, biHeight, source->bits_per_pixel);\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n      break;\n    }\n    if (biCompression != 0)\n      ERREXIT(cinfo, JERR_BMP_COMPRESSED);\n\n    if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0) {\n      /* Set JFIF density parameters from the BMP data */\n      cinfo->X_density = (UINT16)(biXPelsPerMeter / 100); /* 100 cm per meter */\n      cinfo->Y_density = (UINT16)(biYPelsPerMeter / 100);\n      cinfo->density_unit = 2;  /* dots/cm */\n    }\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n    return;\n  }\n\n  if (biWidth <= 0 || biHeight <= 0 || biWidth > 0x7fffffffL || biHeight > 0x7fffffffL)\n    ERREXIT(cinfo, JERR_BMP_EMPTY);\n  if (sinfo->max_pixels &&\n      (unsigned long long)biWidth * biHeight > sinfo->max_pixels)\n    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, sinfo->max_pixels);\n  if (biPlanes != 1)\n    ERREXIT(cinfo, JERR_BMP_BADPLANES);\n\n  /* Compute distance to bitmap data --- will adjust for colormap below */\n  bPad = bfOffBits - (headerSize + 14);\n\n  /* Read the colormap, if any */\n  if (mapentrysize > 0) {\n    if (biClrUsed <= 0)\n      biClrUsed = 256;          /* assume it's 256 */\n    else if (biClrUsed > 256)\n      ERREXIT(cinfo, JERR_BMP_BADCMAP);\n    /* Allocate space to store the colormap */\n    source->colormap = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)biClrUsed, (JDIMENSION)3);\n    source->cmap_length = (int)biClrUsed;\n    /* and read it from the file */\n    read_colormap(source, (int)biClrUsed, mapentrysize);\n    /* account for size of colormap */\n    bPad -= biClrUsed * mapentrysize;\n  }\n\n  /* Skip any remaining pad bytes */\n  if (bPad < 0)                 /* incorrect bfOffBits value? */\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n  while (--bPad >= 0) {\n    (void)read_byte(source);\n  }\n\n  /* Compute row width in file, including padding to 4-byte boundary */\n  switch (source->bits_per_pixel) {\n  case 8:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_GRAYSCALE)\n      cinfo->input_components = 1;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)biWidth;\n    break;\n  case 24:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_BGR;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    if ((unsigned long long)biWidth * 3ULL > 0xFFFFFFFFULL)\n      ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n    row_width = (JDIMENSION)biWidth * 3;\n    break;\n  case 32:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_BGRA;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    if ((unsigned long long)biWidth * 4ULL > 0xFFFFFFFFULL)\n      ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n    row_width = (JDIMENSION)biWidth * 4;\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n  }\n  while ((row_width & 3) != 0) row_width++;\n  source->row_width = row_width;\n\n  if (source->use_inversion_array) {\n    /* Allocate space for inversion array, prepare for preload pass */\n    source->whole_image = (*cinfo->mem->request_virt_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n       row_width, (JDIMENSION)biHeight, (JDIMENSION)1);\n    source->pub.get_pixel_rows = preload_image;\n    if (cinfo->progress != NULL) {\n      cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n      progress->total_extra_passes++; /* count file input as separate pass */\n    }\n  } else {\n    source->iobuffer = (U_CHAR *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE, row_width);\n    switch (source->bits_per_pixel) {\n    case 8:\n      source->pub.get_pixel_rows = get_8bit_row;\n      break;\n    case 24:\n      source->pub.get_pixel_rows = get_24bit_row;\n      break;\n    case 32:\n      source->pub.get_pixel_rows = get_32bit_row;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n    }\n  }\n\n  /* Ensure that biWidth * cinfo->input_components doesn't exceed the maximum\n     value of the JDIMENSION type.  This is only a danger with BMP files, since\n     their width and height fields are 32-bit integers. */\n  if ((unsigned long long)biWidth *\n      (unsigned long long)cinfo->input_components > 0xFFFFFFFFULL)\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n  /* Allocate one-row buffer for returned data */\n  source->pub.buffer = (*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE,\n     (JDIMENSION)biWidth * (JDIMENSION)cinfo->input_components, (JDIMENSION)1);\n  source->pub.buffer_height = 1;\n\n  cinfo->data_precision = 8;\n  cinfo->image_width = (JDIMENSION)biWidth;\n  cinfo->image_height = (JDIMENSION)biHeight;\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_input_bmp(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  /* no work */\n}\n\n\n/*\n * The module selection routine for BMP format input.\n */\n\nGLOBAL(cjpeg_source_ptr)\njinit_read_bmp(j_compress_ptr cinfo, boolean use_inversion_array)\n{\n  bmp_source_ptr source;\n\n  if (cinfo->data_precision != 8)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Create module interface object */\n  source = (bmp_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(bmp_source_struct));\n  source->cinfo = cinfo;        /* make back link for subroutines */\n  /* Fill in method ptrs, except get_pixel_rows which start_input sets */\n  source->pub.start_input = start_input_bmp;\n  source->pub.finish_input = finish_input_bmp;\n  source->pub.max_pixels = 0;\n\n  source->use_inversion_array = use_inversion_array;\n\n  return (cjpeg_source_ptr)source;\n}\n\n#endif /* BMP_SUPPORTED */\n"
        },
        {
          "name": "rdcolmap.c",
          "type": "blob",
          "size": 7.22265625,
          "content": "/*\n * rdcolmap.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file implements djpeg's \"-map file\" switch.  It reads a source image\n * and constructs a colormap to be supplied to the JPEG decompressor.\n *\n * Currently, these file formats are supported for the map file:\n *   GIF: the contents of the GIF's global colormap are used.\n *   PPM (either text or raw flavor): the entire file is read and\n *      each unique pixel value is entered in the map.\n * Note that reading a large PPM file will be horrendously slow.\n * Typically, a PPM-format map file should contain just one pixel\n * of each desired color.  Such a file can be extracted from an\n * ordinary image PPM file with ppmtomap(1).\n *\n * Rescaling a PPM that has a maxval unequal to _MAXJSAMPLE is not\n * currently implemented.\n */\n\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n#include \"jsamplecomp.h\"\n\n#ifdef QUANT_2PASS_SUPPORTED    /* otherwise can't quantize to supplied map */\n#if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)\n\n/* Portions of this code are based on the PBMPLUS library, which is:\n**\n** Copyright (C) 1988 by Jef Poskanzer.\n**\n** Permission to use, copy, modify, and distribute this software and its\n** documentation for any purpose and without fee is hereby granted, provided\n** that the above copyright notice appear in all copies and that both that\n** copyright notice and this permission notice appear in supporting\n** documentation.  This software is provided \"as is\" without express or\n** implied warranty.\n*/\n\n\n/*\n * Add a (potentially) new color to the color map.\n */\n\nLOCAL(void)\nadd_map_entry(j_decompress_ptr cinfo, int R, int G, int B)\n{\n  _JSAMPROW colormap0 = ((_JSAMPARRAY)cinfo->colormap)[0];\n  _JSAMPROW colormap1 = ((_JSAMPARRAY)cinfo->colormap)[1];\n  _JSAMPROW colormap2 = ((_JSAMPARRAY)cinfo->colormap)[2];\n  int ncolors = cinfo->actual_number_of_colors;\n  int index;\n\n  /* Check for duplicate color. */\n  for (index = 0; index < ncolors; index++) {\n    if (colormap0[index] == R && colormap1[index] == G &&\n        colormap2[index] == B)\n      return;                   /* color is already in map */\n  }\n\n  /* Check for map overflow. */\n  if (ncolors >= (_MAXJSAMPLE + 1))\n    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, (_MAXJSAMPLE + 1));\n\n  /* OK, add color to map. */\n  colormap0[ncolors] = (_JSAMPLE)R;\n  colormap1[ncolors] = (_JSAMPLE)G;\n  colormap2[ncolors] = (_JSAMPLE)B;\n  cinfo->actual_number_of_colors++;\n}\n\n\n/*\n * Extract color map from a GIF file.\n */\n\nLOCAL(void)\nread_gif_map(j_decompress_ptr cinfo, FILE *infile)\n{\n  int header[13];\n  int i, colormaplen;\n  int R, G, B;\n\n  /* Initial 'G' has already been read by read_color_map */\n  /* Read the rest of the GIF header and logical screen descriptor */\n  for (i = 1; i < 13; i++) {\n    if ((header[i] = getc(infile)) == EOF)\n      ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n  }\n\n  /* Verify GIF Header */\n  if (header[1] != 'I' || header[2] != 'F')\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  /* There must be a global color map. */\n  if ((header[10] & 0x80) == 0)\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  /* OK, fetch it. */\n  colormaplen = 2 << (header[10] & 0x07);\n\n  for (i = 0; i < colormaplen; i++) {\n    R = getc(infile);\n    G = getc(infile);\n    B = getc(infile);\n    if (R == EOF || G == EOF || B == EOF)\n      ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n    add_map_entry(cinfo,\n                  R << (BITS_IN_JSAMPLE - 8),\n                  G << (BITS_IN_JSAMPLE - 8),\n                  B << (BITS_IN_JSAMPLE - 8));\n  }\n}\n\n\n/* Support routines for reading PPM */\n\n\nLOCAL(int)\npbm_getc(FILE *infile)\n/* Read next char, skipping over any comments */\n/* A comment/newline sequence is returned as a newline */\n{\n  register int ch;\n\n  ch = getc(infile);\n  if (ch == '#') {\n    do {\n      ch = getc(infile);\n    } while (ch != '\\n' && ch != EOF);\n  }\n  return ch;\n}\n\n\nLOCAL(unsigned int)\nread_pbm_integer(j_decompress_ptr cinfo, FILE *infile)\n/* Read an unsigned decimal integer from the PPM file */\n/* Swallows one trailing character after the integer */\n/* Note that on a 16-bit-int machine, only values up to 64k can be read. */\n/* This should not be a problem in practice. */\n{\n  register int ch;\n  register unsigned int val;\n\n  /* Skip any leading whitespace */\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  return val;\n}\n\n\n/*\n * Extract color map from a PPM file.\n */\n\nLOCAL(void)\nread_ppm_map(j_decompress_ptr cinfo, FILE *infile)\n{\n  int c;\n  unsigned int w, h, maxval, row, col;\n  int R, G, B;\n\n  /* Initial 'P' has already been read by read_color_map */\n  c = getc(infile);             /* save format discriminator for a sec */\n\n  /* while we fetch the remaining header info */\n  w = read_pbm_integer(cinfo, infile);\n  h = read_pbm_integer(cinfo, infile);\n  maxval = read_pbm_integer(cinfo, infile);\n\n  if (w <= 0 || h <= 0 || maxval <= 0) /* error check */\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  /* For now, we don't support rescaling from an unusual maxval. */\n  if (maxval != (unsigned int)_MAXJSAMPLE)\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n\n  switch (c) {\n  case '3':                     /* it's a text-format PPM file */\n    for (row = 0; row < h; row++) {\n      for (col = 0; col < w; col++) {\n        R = read_pbm_integer(cinfo, infile);\n        G = read_pbm_integer(cinfo, infile);\n        B = read_pbm_integer(cinfo, infile);\n        add_map_entry(cinfo, R, G, B);\n      }\n    }\n    break;\n\n  case '6':                     /* it's a raw-format PPM file */\n    for (row = 0; row < h; row++) {\n      for (col = 0; col < w; col++) {\n        R = getc(infile);\n        G = getc(infile);\n        B = getc(infile);\n        if (R == EOF || G == EOF || B == EOF)\n          ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n        add_map_entry(cinfo, R, G, B);\n      }\n    }\n    break;\n\n  default:\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n    break;\n  }\n}\n\n\n/*\n * Main entry point from djpeg.c.\n *  Input: opened input file (from file name argument on command line).\n *  Output: colormap and actual_number_of_colors fields are set in cinfo.\n */\n\nGLOBAL(void)\n_read_color_map(j_decompress_ptr cinfo, FILE *infile)\n{\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Allocate space for a color map of maximum supported size. */\n  cinfo->colormap = (*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE,\n     (JDIMENSION)(_MAXJSAMPLE + 1), (JDIMENSION)3);\n  cinfo->actual_number_of_colors = 0; /* initialize map to empty */\n\n  /* Read first byte to determine file format */\n  switch (getc(infile)) {\n  case 'G':\n    read_gif_map(cinfo, infile);\n    break;\n  case 'P':\n    read_ppm_map(cinfo, infile);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BAD_CMAP_FILE);\n    break;\n  }\n}\n\n#endif /* BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED) */\n#endif /* QUANT_2PASS_SUPPORTED */\n"
        },
        {
          "name": "rdgif.c",
          "type": "blob",
          "size": 24.1943359375,
          "content": "/*\n * rdgif.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 2019 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2021-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to read input images in GIF format.\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume input from\n * an ordinary stdio stream.  They further assume that reading begins\n * at the start of the file; start_input may need work if the\n * user interface has already read some data (e.g., to determine that\n * the file is indeed GIF format).\n */\n\n/*\n * This code is loosely based on giftoppm from the PBMPLUS distribution\n * of Feb. 1991.  That file contains the following copyright notice:\n * +-------------------------------------------------------------------+\n * | Copyright 1990, David Koblas.                                     |\n * |   Permission to use, copy, modify, and distribute this software   |\n * |   and its documentation for any purpose and without fee is hereby |\n * |   granted, provided that the above copyright notice appear in all |\n * |   copies and that both that copyright notice and this permission  |\n * |   notice appear in supporting documentation.  This software is    |\n * |   provided \"as is\" without express or implied warranty.           |\n * +-------------------------------------------------------------------+\n */\n\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n#include \"jsamplecomp.h\"\n\n#if defined(GIF_SUPPORTED) && \\\n    (BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED))\n\n\n/* Macros to deal with unsigned chars as efficiently as compiler allows */\n\ntypedef unsigned char U_CHAR;\n#define UCH(x)  ((int)(x))\n\n\n#define ReadOK(file, buffer, len) \\\n  (fread(buffer, 1, len, file) == ((size_t)(len)))\n\n\n#define MAXCOLORMAPSIZE  256    /* max # of colors in a GIF colormap */\n#define NUMCOLORS        3      /* # of colors */\n#define CM_RED           0      /* color component numbers */\n#define CM_GREEN         1\n#define CM_BLUE          2\n\n#define MAX_LZW_BITS     12     /* maximum LZW code size */\n#define LZW_TABLE_SIZE   (1 << MAX_LZW_BITS) /* # of possible LZW symbols */\n\n/* Macros for extracting header data --- note we assume chars may be signed */\n\n#define LM_to_uint(array, offset) \\\n  ((unsigned int)UCH(array[offset]) + \\\n   (((unsigned int)UCH(array[offset + 1])) << 8))\n\n#define BitSet(byte, bit)       ((byte) & (bit))\n#define INTERLACE       0x40    /* mask for bit signifying interlaced image */\n#define COLORMAPFLAG    0x80    /* mask for bit signifying colormap presence */\n\n\n/*\n * LZW decompression tables look like this:\n *   symbol_head[K] = prefix symbol of any LZW symbol K (0..LZW_TABLE_SIZE-1)\n *   symbol_tail[K] = suffix byte   of any LZW symbol K (0..LZW_TABLE_SIZE-1)\n * Note that entries 0..end_code of the above tables are not used,\n * since those symbols represent raw bytes or special codes.\n *\n * The stack represents the not-yet-used expansion of the last LZW symbol.\n * In the worst case, a symbol could expand to as many bytes as there are\n * LZW symbols, so we allocate LZW_TABLE_SIZE bytes for the stack.\n * (This is conservative since that number includes the raw-byte symbols.)\n */\n\n\n/* Private version of data source object */\n\ntypedef struct {\n  struct cjpeg_source_struct pub; /* public fields */\n\n  j_compress_ptr cinfo;         /* back link saves passing separate parm */\n\n  _JSAMPARRAY colormap;         /* GIF colormap (converted to my format) */\n\n  /* State for GetCode and LZWReadByte */\n  U_CHAR code_buf[256 + 4];     /* current input data block */\n  int last_byte;                /* # of bytes in code_buf */\n  int last_bit;                 /* # of bits in code_buf */\n  int cur_bit;                  /* next bit index to read */\n  boolean first_time;           /* flags first call to GetCode */\n  boolean out_of_blocks;        /* TRUE if hit terminator data block */\n\n  int input_code_size;          /* codesize given in GIF file */\n  int clear_code, end_code;     /* values for Clear and End codes */\n\n  int code_size;                /* current actual code size */\n  int limit_code;               /* 2^code_size */\n  int max_code;                 /* first unused code value */\n\n  /* Private state for LZWReadByte */\n  int oldcode;                  /* previous LZW symbol */\n  int firstcode;                /* first byte of oldcode's expansion */\n\n  /* LZW symbol table and expansion stack */\n  UINT16 *symbol_head;          /* => table of prefix symbols */\n  UINT8  *symbol_tail;          /* => table of suffix bytes */\n  UINT8  *symbol_stack;         /* => stack for symbol expansions */\n  UINT8  *sp;                   /* stack pointer */\n\n  /* State for interlaced image processing */\n  boolean is_interlaced;        /* TRUE if have interlaced image */\n  jvirt_sarray_ptr interlaced_image; /* full image in interlaced order */\n  JDIMENSION cur_row_number;    /* need to know actual row number */\n  JDIMENSION pass2_offset;      /* # of pixel rows in pass 1 */\n  JDIMENSION pass3_offset;      /* # of pixel rows in passes 1&2 */\n  JDIMENSION pass4_offset;      /* # of pixel rows in passes 1,2,3 */\n} gif_source_struct;\n\ntypedef gif_source_struct *gif_source_ptr;\n\n\n/* Forward declarations */\nMETHODDEF(JDIMENSION) get_pixel_rows(j_compress_ptr cinfo,\n                                     cjpeg_source_ptr sinfo);\nMETHODDEF(JDIMENSION) load_interlaced_image(j_compress_ptr cinfo,\n                                            cjpeg_source_ptr sinfo);\nMETHODDEF(JDIMENSION) get_interlaced_row(j_compress_ptr cinfo,\n                                         cjpeg_source_ptr sinfo);\n\n\nLOCAL(int)\nReadByte(gif_source_ptr sinfo)\n/* Read next byte from GIF file */\n{\n  register FILE *infile = sinfo->pub.input_file;\n  register int c;\n\n  if ((c = getc(infile)) == EOF)\n    ERREXIT(sinfo->cinfo, JERR_INPUT_EOF);\n  return c;\n}\n\n\nLOCAL(int)\nGetDataBlock(gif_source_ptr sinfo, U_CHAR *buf)\n/* Read a GIF data block, which has a leading count byte */\n/* A zero-length block marks the end of a data block sequence */\n{\n  int count;\n\n  count = ReadByte(sinfo);\n  if (count > 0) {\n    if (!ReadOK(sinfo->pub.input_file, buf, count))\n      ERREXIT(sinfo->cinfo, JERR_INPUT_EOF);\n  }\n  return count;\n}\n\n\nLOCAL(void)\nSkipDataBlocks(gif_source_ptr sinfo)\n/* Skip a series of data blocks, until a block terminator is found */\n{\n  U_CHAR buf[256];\n\n  while (GetDataBlock(sinfo, buf) > 0)\n    /* skip */;\n}\n\n\nLOCAL(void)\nReInitLZW(gif_source_ptr sinfo)\n/* (Re)initialize LZW state; shared code for startup and Clear processing */\n{\n  sinfo->code_size = sinfo->input_code_size + 1;\n  sinfo->limit_code = sinfo->clear_code << 1;   /* 2^code_size */\n  sinfo->max_code = sinfo->clear_code + 2;      /* first unused code value */\n  sinfo->sp = sinfo->symbol_stack;              /* init stack to empty */\n}\n\n\nLOCAL(void)\nInitLZWCode(gif_source_ptr sinfo)\n/* Initialize for a series of LZWReadByte (and hence GetCode) calls */\n{\n  /* GetCode initialization */\n  sinfo->last_byte = 2;         /* make safe to \"recopy last two bytes\" */\n  sinfo->code_buf[0] = 0;\n  sinfo->code_buf[1] = 0;\n  sinfo->last_bit = 0;          /* nothing in the buffer */\n  sinfo->cur_bit = 0;           /* force buffer load on first call */\n  sinfo->first_time = TRUE;\n  sinfo->out_of_blocks = FALSE;\n\n  /* LZWReadByte initialization: */\n  /* compute special code values (note that these do not change later) */\n  sinfo->clear_code = 1 << sinfo->input_code_size;\n  sinfo->end_code = sinfo->clear_code + 1;\n  ReInitLZW(sinfo);\n}\n\n\nLOCAL(int)\nGetCode(gif_source_ptr sinfo)\n/* Fetch the next code_size bits from the GIF data */\n/* We assume code_size is less than 16 */\n{\n  register int accum;\n  int offs, count;\n\n  while (sinfo->cur_bit + sinfo->code_size > sinfo->last_bit) {\n    /* Time to reload the buffer */\n    /* First time, share code with Clear case */\n    if (sinfo->first_time) {\n      sinfo->first_time = FALSE;\n      return sinfo->clear_code;\n    }\n    if (sinfo->out_of_blocks) {\n      WARNMS(sinfo->cinfo, JWRN_GIF_NOMOREDATA);\n      return sinfo->end_code;   /* fake something useful */\n    }\n    /* preserve last two bytes of what we have -- assume code_size <= 16 */\n    sinfo->code_buf[0] = sinfo->code_buf[sinfo->last_byte-2];\n    sinfo->code_buf[1] = sinfo->code_buf[sinfo->last_byte-1];\n    /* Load more bytes; set flag if we reach the terminator block */\n    if ((count = GetDataBlock(sinfo, &sinfo->code_buf[2])) == 0) {\n      sinfo->out_of_blocks = TRUE;\n      WARNMS(sinfo->cinfo, JWRN_GIF_NOMOREDATA);\n      return sinfo->end_code;   /* fake something useful */\n    }\n    /* Reset counters */\n    sinfo->cur_bit = (sinfo->cur_bit - sinfo->last_bit) + 16;\n    sinfo->last_byte = 2 + count;\n    sinfo->last_bit = sinfo->last_byte * 8;\n  }\n\n  /* Form up next 24 bits in accum */\n  offs = sinfo->cur_bit >> 3;   /* byte containing cur_bit */\n  accum = UCH(sinfo->code_buf[offs + 2]);\n  accum <<= 8;\n  accum |= UCH(sinfo->code_buf[offs + 1]);\n  accum <<= 8;\n  accum |= UCH(sinfo->code_buf[offs]);\n\n  /* Right-align cur_bit in accum, then mask off desired number of bits */\n  accum >>= (sinfo->cur_bit & 7);\n  sinfo->cur_bit += sinfo->code_size;\n  return accum & ((1 << sinfo->code_size) - 1);\n}\n\n\nLOCAL(int)\nLZWReadByte(gif_source_ptr sinfo)\n/* Read an LZW-compressed byte */\n{\n  register int code;            /* current working code */\n  int incode;                   /* saves actual input code */\n\n  /* If any codes are stacked from a previously read symbol, return them */\n  if (sinfo->sp > sinfo->symbol_stack)\n    return (int)(*(--sinfo->sp));\n\n  /* Time to read a new symbol */\n  code = GetCode(sinfo);\n\n  if (code == sinfo->clear_code) {\n    /* Reinit state, swallow any extra Clear codes, and */\n    /* return next code, which is expected to be a raw byte. */\n    ReInitLZW(sinfo);\n    do {\n      code = GetCode(sinfo);\n    } while (code == sinfo->clear_code);\n    if (code > sinfo->clear_code) { /* make sure it is a raw byte */\n      WARNMS(sinfo->cinfo, JWRN_GIF_BADDATA);\n      code = 0;                 /* use something valid */\n    }\n    /* make firstcode, oldcode valid! */\n    sinfo->firstcode = sinfo->oldcode = code;\n    return code;\n  }\n\n  if (code == sinfo->end_code) {\n    /* Skip the rest of the image, unless GetCode already read terminator */\n    if (!sinfo->out_of_blocks) {\n      SkipDataBlocks(sinfo);\n      sinfo->out_of_blocks = TRUE;\n    }\n    /* Complain that there's not enough data */\n    WARNMS(sinfo->cinfo, JWRN_GIF_ENDCODE);\n    /* Pad data with 0's */\n    return 0;                   /* fake something usable */\n  }\n\n  /* Got normal raw byte or LZW symbol */\n  incode = code;                /* save for a moment */\n\n  if (code >= sinfo->max_code) { /* special case for not-yet-defined symbol */\n    /* code == max_code is OK; anything bigger is bad data */\n    if (code > sinfo->max_code) {\n      WARNMS(sinfo->cinfo, JWRN_GIF_BADDATA);\n      incode = 0;               /* prevent creation of loops in symbol table */\n    }\n    /* this symbol will be defined as oldcode/firstcode */\n    *(sinfo->sp++) = (UINT8)sinfo->firstcode;\n    code = sinfo->oldcode;\n  }\n\n  /* If it's a symbol, expand it into the stack */\n  while (code >= sinfo->clear_code) {\n    *(sinfo->sp++) = sinfo->symbol_tail[code]; /* tail is a byte value */\n    code = sinfo->symbol_head[code]; /* head is another LZW symbol */\n  }\n  /* At this point code just represents a raw byte */\n  sinfo->firstcode = code;      /* save for possible future use */\n\n  /* If there's room in table... */\n  if ((code = sinfo->max_code) < LZW_TABLE_SIZE) {\n    /* Define a new symbol = prev sym + head of this sym's expansion */\n    sinfo->symbol_head[code] = (UINT16)sinfo->oldcode;\n    sinfo->symbol_tail[code] = (UINT8)sinfo->firstcode;\n    sinfo->max_code++;\n    /* Is it time to increase code_size? */\n    if (sinfo->max_code >= sinfo->limit_code &&\n        sinfo->code_size < MAX_LZW_BITS) {\n      sinfo->code_size++;\n      sinfo->limit_code <<= 1;  /* keep equal to 2^code_size */\n    }\n  }\n\n  sinfo->oldcode = incode;      /* save last input symbol for future use */\n  return sinfo->firstcode;      /* return first byte of symbol's expansion */\n}\n\n\nLOCAL(void)\nReadColorMap(gif_source_ptr sinfo, int cmaplen, _JSAMPARRAY cmap)\n/* Read a GIF colormap */\n{\n  int i, gray = 1;\n\n  for (i = 0; i < cmaplen; i++) {\n#if BITS_IN_JSAMPLE == 8\n#define UPSCALE(x)  (x)\n#else\n#define UPSCALE(x)  ((x) << (BITS_IN_JSAMPLE - 8))\n#endif\n    cmap[CM_RED][i]   = (_JSAMPLE)UPSCALE(ReadByte(sinfo));\n    cmap[CM_GREEN][i] = (_JSAMPLE)UPSCALE(ReadByte(sinfo));\n    cmap[CM_BLUE][i]  = (_JSAMPLE)UPSCALE(ReadByte(sinfo));\n    if (cmap[CM_RED][i] != cmap[CM_GREEN][i] ||\n        cmap[CM_GREEN][i] != cmap[CM_BLUE][i])\n      gray = 0;\n  }\n\n  if (sinfo->cinfo->in_color_space == JCS_RGB && gray) {\n    sinfo->cinfo->in_color_space = JCS_GRAYSCALE;\n    sinfo->cinfo->input_components = 1;\n  }\n}\n\n\nLOCAL(void)\nDoExtension(gif_source_ptr sinfo)\n/* Process an extension block */\n/* Currently we ignore 'em all */\n{\n  int extlabel;\n\n  /* Read extension label byte */\n  extlabel = ReadByte(sinfo);\n  TRACEMS1(sinfo->cinfo, 1, JTRC_GIF_EXTENSION, extlabel);\n  /* Skip the data block(s) associated with the extension */\n  SkipDataBlocks(sinfo);\n}\n\n\n/*\n * Read the file header; return image size and component count.\n */\n\nMETHODDEF(void)\nstart_input_gif(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  gif_source_ptr source = (gif_source_ptr)sinfo;\n  U_CHAR hdrbuf[10];            /* workspace for reading control blocks */\n  unsigned int width, height;   /* image dimensions */\n  int colormaplen, aspectRatio;\n  int c;\n\n  /* Read and verify GIF Header */\n  if (!ReadOK(source->pub.input_file, hdrbuf, 6))\n    ERREXIT(cinfo, JERR_GIF_NOT);\n  if (hdrbuf[0] != 'G' || hdrbuf[1] != 'I' || hdrbuf[2] != 'F')\n    ERREXIT(cinfo, JERR_GIF_NOT);\n  /* Check for expected version numbers.\n   * If unknown version, give warning and try to process anyway;\n   * this is per recommendation in GIF89a standard.\n   */\n  if ((hdrbuf[3] != '8' || hdrbuf[4] != '7' || hdrbuf[5] != 'a') &&\n      (hdrbuf[3] != '8' || hdrbuf[4] != '9' || hdrbuf[5] != 'a'))\n    TRACEMS3(cinfo, 1, JTRC_GIF_BADVERSION, hdrbuf[3], hdrbuf[4], hdrbuf[5]);\n\n  /* Read and decipher Logical Screen Descriptor */\n  if (!ReadOK(source->pub.input_file, hdrbuf, 7))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  width = LM_to_uint(hdrbuf, 0);\n  height = LM_to_uint(hdrbuf, 2);\n  if (width == 0 || height == 0)\n    ERREXIT(cinfo, JERR_GIF_EMPTY);\n  if (sinfo->max_pixels &&\n      (unsigned long long)width * height > sinfo->max_pixels)\n    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, sinfo->max_pixels);\n  /* we ignore the color resolution, sort flag, and background color index */\n  aspectRatio = UCH(hdrbuf[6]);\n  if (aspectRatio != 0 && aspectRatio != 49)\n    TRACEMS(cinfo, 1, JTRC_GIF_NONSQUARE);\n\n  /* Allocate space to store the colormap */\n  source->colormap = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)MAXCOLORMAPSIZE,\n     (JDIMENSION)NUMCOLORS);\n  colormaplen = 0;              /* indicate initialization */\n\n  /* Read global colormap if header indicates it is present */\n  if (BitSet(hdrbuf[4], COLORMAPFLAG)) {\n    colormaplen = 2 << (hdrbuf[4] & 0x07);\n    ReadColorMap(source, colormaplen, source->colormap);\n  }\n\n  /* Scan until we reach start of desired image.\n   * We don't currently support skipping images, but could add it easily.\n   */\n  for (;;) {\n    c = ReadByte(source);\n\n    if (c == ';')               /* GIF terminator?? */\n      ERREXIT(cinfo, JERR_GIF_IMAGENOTFOUND);\n\n    if (c == '!') {             /* Extension */\n      DoExtension(source);\n      continue;\n    }\n\n    if (c != ',') {             /* Not an image separator? */\n      WARNMS1(cinfo, JWRN_GIF_CHAR, c);\n      continue;\n    }\n\n    /* Read and decipher Local Image Descriptor */\n    if (!ReadOK(source->pub.input_file, hdrbuf, 9))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    /* we ignore top/left position info, also sort flag */\n    width = LM_to_uint(hdrbuf, 4);\n    height = LM_to_uint(hdrbuf, 6);\n    if (width == 0 || height == 0)\n      ERREXIT(cinfo, JERR_GIF_EMPTY);\n    if (sinfo->max_pixels &&\n        (unsigned long long)width * height > sinfo->max_pixels)\n      ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, sinfo->max_pixels);\n    source->is_interlaced = (BitSet(hdrbuf[8], INTERLACE) != 0);\n\n    /* Read local colormap if header indicates it is present */\n    /* Note: if we wanted to support skipping images, */\n    /* we'd need to skip rather than read colormap for ignored images */\n    if (BitSet(hdrbuf[8], COLORMAPFLAG)) {\n      colormaplen = 2 << (hdrbuf[8] & 0x07);\n      ReadColorMap(source, colormaplen, source->colormap);\n    }\n\n    source->input_code_size = ReadByte(source); /* get min-code-size byte */\n    if (source->input_code_size < 2 || source->input_code_size > 8)\n      ERREXIT1(cinfo, JERR_GIF_CODESIZE, source->input_code_size);\n\n    /* Reached desired image, so break out of loop */\n    /* If we wanted to skip this image, */\n    /* we'd call SkipDataBlocks and then continue the loop */\n    break;\n  }\n\n  /* Prepare to read selected image: first initialize LZW decompressor */\n  source->symbol_head = (UINT16 *)\n    (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                LZW_TABLE_SIZE * sizeof(UINT16));\n  source->symbol_tail = (UINT8 *)\n    (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                LZW_TABLE_SIZE * sizeof(UINT8));\n  source->symbol_stack = (UINT8 *)\n    (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                LZW_TABLE_SIZE * sizeof(UINT8));\n  InitLZWCode(source);\n\n  /*\n   * If image is interlaced, we read it into a full-size sample array,\n   * decompressing as we go; then get_interlaced_row selects rows from the\n   * sample array in the proper order.\n   */\n  if (source->is_interlaced) {\n    /* We request the virtual array now, but can't access it until virtual\n     * arrays have been allocated.  Hence, the actual work of reading the\n     * image is postponed until the first call to get_pixel_rows.\n     */\n    source->interlaced_image = (*cinfo->mem->request_virt_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n       (JDIMENSION)width, (JDIMENSION)height, (JDIMENSION)1);\n    if (cinfo->progress != NULL) {\n      cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n      progress->total_extra_passes++; /* count file input as separate pass */\n    }\n    source->pub.get_pixel_rows = load_interlaced_image;\n  } else {\n    source->pub.get_pixel_rows = get_pixel_rows;\n  }\n\n  if (cinfo->in_color_space != JCS_GRAYSCALE) {\n    cinfo->in_color_space = JCS_RGB;\n    cinfo->input_components = NUMCOLORS;\n  }\n\n  /* Create compressor input buffer. */\n  source->pub._buffer = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE,\n     (JDIMENSION)width * cinfo->input_components, (JDIMENSION)1);\n  source->pub.buffer_height = 1;\n\n  /* Pad colormap for safety. */\n  for (c = colormaplen; c < source->clear_code; c++) {\n    source->colormap[CM_RED][c]   =\n    source->colormap[CM_GREEN][c] =\n    source->colormap[CM_BLUE][c]  = _CENTERJSAMPLE;\n  }\n\n  /* Return info about the image. */\n  cinfo->data_precision = BITS_IN_JSAMPLE; /* we always rescale data to this */\n  cinfo->image_width = width;\n  cinfo->image_height = height;\n\n  TRACEMS3(cinfo, 1, JTRC_GIF, width, height, colormaplen);\n}\n\n\n/*\n * Read one row of pixels.\n * This version is used for noninterlaced GIF images:\n * we read directly from the GIF file.\n */\n\nMETHODDEF(JDIMENSION)\nget_pixel_rows(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  gif_source_ptr source = (gif_source_ptr)sinfo;\n  register int c;\n  register _JSAMPROW ptr;\n  register JDIMENSION col;\n  register _JSAMPARRAY colormap = source->colormap;\n\n  ptr = source->pub._buffer[0];\n  if (cinfo->in_color_space == JCS_GRAYSCALE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      c = LZWReadByte(source);\n      *ptr++ = colormap[CM_RED][c];\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      c = LZWReadByte(source);\n      *ptr++ = colormap[CM_RED][c];\n      *ptr++ = colormap[CM_GREEN][c];\n      *ptr++ = colormap[CM_BLUE][c];\n    }\n  }\n  return 1;\n}\n\n\n/*\n * Read one row of pixels.\n * This version is used for the first call on get_pixel_rows when\n * reading an interlaced GIF file: we read the whole image into memory.\n */\n\nMETHODDEF(JDIMENSION)\nload_interlaced_image(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  gif_source_ptr source = (gif_source_ptr)sinfo;\n  register _JSAMPROW sptr;\n  register JDIMENSION col;\n  JDIMENSION row;\n  cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n\n  /* Read the interlaced image into the virtual array we've created. */\n  for (row = 0; row < cinfo->image_height; row++) {\n    if (progress != NULL) {\n      progress->pub.pass_counter = (long)row;\n      progress->pub.pass_limit = (long)cinfo->image_height;\n      (*progress->pub.progress_monitor) ((j_common_ptr)cinfo);\n    }\n    sptr = *(_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->interlaced_image, row, (JDIMENSION)1,\n       TRUE);\n    for (col = cinfo->image_width; col > 0; col--) {\n      *sptr++ = (_JSAMPLE)LZWReadByte(source);\n    }\n  }\n  if (progress != NULL)\n    progress->completed_extra_passes++;\n\n  /* Replace method pointer so subsequent calls don't come here. */\n  source->pub.get_pixel_rows = get_interlaced_row;\n  /* Initialize for get_interlaced_row, and perform first call on it. */\n  source->cur_row_number = 0;\n  source->pass2_offset = (cinfo->image_height + 7) / 8;\n  source->pass3_offset = source->pass2_offset + (cinfo->image_height + 3) / 8;\n  source->pass4_offset = source->pass3_offset + (cinfo->image_height + 1) / 4;\n\n  return get_interlaced_row(cinfo, sinfo);\n}\n\n\n/*\n * Read one row of pixels.\n * This version is used for interlaced GIF images:\n * we read from the virtual array.\n */\n\nMETHODDEF(JDIMENSION)\nget_interlaced_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  gif_source_ptr source = (gif_source_ptr)sinfo;\n  register int c;\n  register _JSAMPROW sptr, ptr;\n  register JDIMENSION col;\n  register _JSAMPARRAY colormap = source->colormap;\n  JDIMENSION irow;\n\n  /* Figure out which row of interlaced image is needed, and access it. */\n  switch ((int)(source->cur_row_number & 7)) {\n  case 0:                       /* first-pass row */\n    irow = source->cur_row_number >> 3;\n    break;\n  case 4:                       /* second-pass row */\n    irow = (source->cur_row_number >> 3) + source->pass2_offset;\n    break;\n  case 2:                       /* third-pass row */\n  case 6:\n    irow = (source->cur_row_number >> 2) + source->pass3_offset;\n    break;\n  default:                      /* fourth-pass row */\n    irow = (source->cur_row_number >> 1) + source->pass4_offset;\n  }\n  sptr = *(_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)\n    ((j_common_ptr)cinfo, source->interlaced_image, irow, (JDIMENSION)1,\n     FALSE);\n  /* Scan the row, expand colormap, and output */\n  ptr = source->pub._buffer[0];\n  if (cinfo->in_color_space == JCS_GRAYSCALE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      c = *sptr++;\n      *ptr++ = colormap[CM_RED][c];\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      c = *sptr++;\n      *ptr++ = colormap[CM_RED][c];\n      *ptr++ = colormap[CM_GREEN][c];\n      *ptr++ = colormap[CM_BLUE][c];\n    }\n  }\n  source->cur_row_number++;     /* for next time */\n  return 1;\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_input_gif(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  /* no work */\n}\n\n\n/*\n * The module selection routine for GIF format input.\n */\n\nGLOBAL(cjpeg_source_ptr)\n_jinit_read_gif(j_compress_ptr cinfo)\n{\n  gif_source_ptr source;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Create module interface object */\n  source = (gif_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(gif_source_struct));\n  source->cinfo = cinfo;        /* make back link for subroutines */\n  /* Fill in method ptrs, except get_pixel_rows which start_input sets */\n  source->pub.start_input = start_input_gif;\n  source->pub.finish_input = finish_input_gif;\n  source->pub.max_pixels = 0;\n\n  return (cjpeg_source_ptr)source;\n}\n\n#endif /* defined(GIF_SUPPORTED) &&\n          (BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED)) */\n"
        },
        {
          "name": "rdjpeg.c",
          "type": "blob",
          "size": 4.3916015625,
          "content": "/*\n * rdjpeg.c\n *\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * mozjpeg Modifications:\n * Copyright (C) 2014, Mozilla Corporation.\n * This file is part of the Independent JPEG Group's software.\n * For conditions of distribution and use, see the accompanying README file.\n *\n */\n\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n\n#if JPEG_RAW_READER\n#define NUM_ROWS 32\n#endif\n\n/* Private version of data source object */\n\ntypedef struct _jpeg_source_struct * jpeg_source_ptr;\n\ntypedef struct _jpeg_source_struct {\n  struct cjpeg_source_struct pub; /* public fields */\n\n  j_compress_ptr cinfo;         /* back link saves passing separate parm */\n  \n  struct jpeg_decompress_struct dinfo;\n  struct jpeg_error_mgr jerr;\n} jpeg_source_struct;\n\n\n\nMETHODDEF(JDIMENSION)\nget_rows (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  jpeg_source_ptr source = (jpeg_source_ptr) sinfo;\n  \n#if !JPEG_RAW_READER\n  return jpeg_read_scanlines(&source->dinfo, source->pub.buffer, source->pub.buffer_height);\n#else\n  jpeg_read_raw_data(&source->dinfo, source->pub.plane_pointer, 8*cinfo->max_v_samp_factor);\n\n  return 8*cinfo->max_v_samp_factor;\n#endif\n}\n\n\n/*\n * Read the file header; return image size and component count.\n */\n\nMETHODDEF(void)\nstart_input_jpeg (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n#if JPEG_RAW_READER\n  int i;\n#endif\n  int m;\n  jpeg_source_ptr source = (jpeg_source_ptr) sinfo;\n\n  source->dinfo.err = jpeg_std_error(&source->jerr);\n  jpeg_create_decompress(&source->dinfo);\n  jpeg_stdio_src(&source->dinfo, source->pub.input_file);\n  \n  jpeg_save_markers(&source->dinfo, JPEG_COM, 0xFFFF);\n  \n  for (m = 0; m < 16; m++)\n    jpeg_save_markers(&source->dinfo, JPEG_APP0 + m, 0xFFFF);\n\n  jpeg_read_header(&source->dinfo, TRUE);\n\n  source->pub.marker_list = source->dinfo.marker_list;\n  \n#if !JPEG_RAW_READER\n  source->dinfo.raw_data_out = FALSE;\n  \n  jpeg_start_decompress(&source->dinfo);\n\n  cinfo->in_color_space = source->dinfo.out_color_space;\n  cinfo->input_components = source->dinfo.output_components;\n  cinfo->data_precision = source->dinfo.data_precision;\n  cinfo->image_width = source->dinfo.image_width;\n  cinfo->image_height = source->dinfo.image_height;\n\n  cinfo->raw_data_in = FALSE;\n\n  source->pub.buffer = (*cinfo->mem->alloc_sarray)\n  ((j_common_ptr) cinfo, JPOOL_IMAGE,\n   (JDIMENSION) (cinfo->image_width * cinfo->input_components), (JDIMENSION) 1);\n  source->pub.buffer_height = 1;\n#else\n  source->dinfo.raw_data_out = TRUE;\n  source->dinfo.do_fancy_upsampling = FALSE;\n  \n  jpeg_start_decompress(&source->dinfo);\n\n  cinfo->in_color_space = source->dinfo.out_color_space;\n  cinfo->input_components = source->dinfo.output_components;\n  cinfo->data_precision = source->dinfo.data_precision;\n  cinfo->image_width = source->dinfo.image_width;\n  cinfo->image_height = source->dinfo.image_height;\n  \n  jpeg_set_colorspace(cinfo, source->dinfo.jpeg_color_space);\n  \n  cinfo->max_v_samp_factor = source->dinfo.max_v_samp_factor;\n  cinfo->max_h_samp_factor = source->dinfo.max_h_samp_factor;\n  \n  cinfo->raw_data_in = TRUE;\n#if JPEG_LIB_VERSION >= 70\n  cinfo->do_fancy_upsampling = FALSE;\n#endif\n  \n  for (i = 0; i < cinfo->input_components; i++) {\n    cinfo->comp_info[i].h_samp_factor = source->dinfo.comp_info[i].h_samp_factor;\n    cinfo->comp_info[i].v_samp_factor = source->dinfo.comp_info[i].v_samp_factor;\n    \n    source->pub.plane_pointer[i] =  (*cinfo->mem->alloc_sarray)\n    ((j_common_ptr) cinfo, JPOOL_IMAGE,\n     (JDIMENSION) cinfo->image_width, (JDIMENSION) NUM_ROWS);\n  }\n#endif\n\n  source->pub.get_pixel_rows = get_rows;\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_input_jpeg (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  jpeg_source_ptr source = (jpeg_source_ptr) sinfo;\n  \n  jpeg_finish_decompress(&source->dinfo);\n  jpeg_destroy_decompress(&source->dinfo);\n}\n\n\n/*\n * The module selection routine for JPEG format input.\n */\n\nGLOBAL(cjpeg_source_ptr)\njinit_read_jpeg (j_compress_ptr cinfo)\n{\n  jpeg_source_ptr source;\n\n  /* Create module interface object */\n  source = (jpeg_source_ptr)\n      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,\n                                  sizeof(jpeg_source_struct));\n  source->cinfo = cinfo;        /* make back link for subroutines */\n  /* Fill in method ptrs, except get_pixel_rows which start_input sets */\n  source->pub.start_input = start_input_jpeg;\n  source->pub.finish_input = finish_input_jpeg;\n\n  return (cjpeg_source_ptr) source;\n}\n"
        },
        {
          "name": "rdjpgcom.1",
          "type": "blob",
          "size": 1.6591796875,
          "content": ".TH RDJPGCOM 1 \"02 April 2009\"\n.SH NAME\nrdjpgcom \\- display text comments from a JPEG file\n.SH SYNOPSIS\n.B rdjpgcom\n[\n.B \\-raw\n]\n[\n.B \\-verbose\n]\n[\n.I filename\n]\n.LP\n.SH DESCRIPTION\n.LP\n.B rdjpgcom\nreads the named JPEG/JFIF file, or the standard input if no file is named,\nand prints any text comments found in the file on the standard output.\n.PP\nThe JPEG standard allows \"comment\" (COM) blocks to occur within a JPEG file.\nAlthough the standard doesn't actually define what COM blocks are for, they\nare widely used to hold user-supplied text strings.  This lets you add\nannotations, titles, index terms, etc to your JPEG files, and later retrieve\nthem as text.  COM blocks do not interfere with the image stored in the JPEG\nfile.  The maximum size of a COM block is 64K, but you can have as many of\nthem as you like in one JPEG file.\n.SH OPTIONS\n.TP\n.B \\-raw\nNormally\n.B rdjpgcom\nescapes non-printable characters in comments, for security reasons.\nThis option avoids that.\n.PP\n.B \\-verbose\nCauses\n.B rdjpgcom\nto also display the JPEG image dimensions.\n.PP\nSwitch names may be abbreviated, and are not case sensitive.\n.SH HINTS\n.B rdjpgcom\ndoes not depend on the IJG JPEG library.  Its source code is intended as an\nillustration of the minimum amount of code required to parse a JPEG file\nheader correctly.\n.PP\nIn\n.B \\-verbose\nmode,\n.B rdjpgcom\nwill also attempt to print the contents of any \"APP12\" markers as text.\nSome digital cameras produce APP12 markers containing useful textual\ninformation.  If you like, you can modify the source code to print\nother APPn marker types as well.\n.SH SEE ALSO\n.BR cjpeg (1),\n.BR djpeg (1),\n.BR jpegtran (1),\n.BR wrjpgcom (1)\n.SH AUTHOR\nIndependent JPEG Group\n"
        },
        {
          "name": "rdjpgcom.c",
          "type": "blob",
          "size": 14.2890625,
          "content": "/*\n * rdjpgcom.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * Modified 2009 by Bill Allombert, Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a very simple stand-alone application that displays\n * the text in COM (comment) markers in a JFIF file.\n * This may be useful as an example of the minimum logic needed to parse\n * JPEG markers.\n */\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#define JPEG_CJPEG_DJPEG        /* to get the command-line config symbols */\n#include \"jinclude.h\"           /* get auto-config symbols, <stdio.h> */\n\n#include <locale.h>             /* Bill Allombert: use locale for isprint */\n#include <ctype.h>              /* to declare isupper(), tolower() */\n#ifdef USE_SETMODE\n#include <fcntl.h>              /* to declare setmode()'s parameter macros */\n/* If you have setmode() but not <io.h>, just delete this line: */\n#include <io.h>                 /* to declare setmode() */\n#endif\n\n#ifdef DONT_USE_B_MODE          /* define mode parameters for fopen() */\n#define READ_BINARY     \"r\"\n#else\n#define READ_BINARY     \"rb\"\n#endif\n\n#ifndef EXIT_FAILURE            /* define exit() codes if not provided */\n#define EXIT_FAILURE  1\n#endif\n#ifndef EXIT_SUCCESS\n#define EXIT_SUCCESS  0\n#endif\n\n\n/*\n * These macros are used to read the input file.\n * To reuse this code in another application, you might need to change these.\n */\n\nstatic FILE *infile;            /* input JPEG file */\n\n/* Return next input byte, or EOF if no more */\n#define NEXTBYTE()  getc(infile)\n\n\n/* Error exit handler */\n#define ERREXIT(msg)  (fprintf(stderr, \"%s\\n\", msg), exit(EXIT_FAILURE))\n\n\n/* Read one byte, testing for EOF */\nstatic int\nread_1_byte(void)\n{\n  int c;\n\n  c = NEXTBYTE();\n  if (c == EOF)\n    ERREXIT(\"Premature EOF in JPEG file\");\n  return c;\n}\n\n/* Read 2 bytes, convert to unsigned int */\n/* All 2-byte quantities in JPEG markers are MSB first */\nstatic unsigned int\nread_2_bytes(void)\n{\n  int c1, c2;\n\n  c1 = NEXTBYTE();\n  if (c1 == EOF)\n    ERREXIT(\"Premature EOF in JPEG file\");\n  c2 = NEXTBYTE();\n  if (c2 == EOF)\n    ERREXIT(\"Premature EOF in JPEG file\");\n  return (((unsigned int)c1) << 8) + ((unsigned int)c2);\n}\n\n\n/*\n * JPEG markers consist of one or more 0xFF bytes, followed by a marker\n * code byte (which is not an FF).  Here are the marker codes of interest\n * in this program.  (See jdmarker.c for a more complete list.)\n */\n\n#define M_SOF0   0xC0           /* Start Of Frame N */\n#define M_SOF1   0xC1           /* N indicates which compression process */\n#define M_SOF2   0xC2           /* Only SOF0-SOF2 are now in common use */\n#define M_SOF3   0xC3\n#define M_SOF5   0xC5           /* NB: codes C4 and CC are NOT SOF markers */\n#define M_SOF6   0xC6\n#define M_SOF7   0xC7\n#define M_SOF9   0xC9\n#define M_SOF10  0xCA\n#define M_SOF11  0xCB\n#define M_SOF13  0xCD\n#define M_SOF14  0xCE\n#define M_SOF15  0xCF\n#define M_SOI    0xD8           /* Start Of Image (beginning of datastream) */\n#define M_EOI    0xD9           /* End Of Image (end of datastream) */\n#define M_SOS    0xDA           /* Start Of Scan (begins compressed data) */\n#define M_APP0   0xE0           /* Application-specific marker, type N */\n#define M_APP12  0xEC           /* (we don't bother to list all 16 APPn's) */\n#define M_COM    0xFE           /* COMment */\n\n\n/*\n * Find the next JPEG marker and return its marker code.\n * We expect at least one FF byte, possibly more if the compressor used FFs\n * to pad the file.\n * There could also be non-FF garbage between markers.  The treatment of such\n * garbage is unspecified; we choose to skip over it but emit a warning msg.\n * NB: this routine must not be used after seeing SOS marker, since it will\n * not deal correctly with FF/00 sequences in the compressed image data...\n */\n\nstatic int\nnext_marker(void)\n{\n  int c;\n  int discarded_bytes = 0;\n\n  /* Find 0xFF byte; count and skip any non-FFs. */\n  c = read_1_byte();\n  while (c != 0xFF) {\n    discarded_bytes++;\n    c = read_1_byte();\n  }\n  /* Get marker code byte, swallowing any duplicate FF bytes.  Extra FFs\n   * are legal as pad bytes, so don't count them in discarded_bytes.\n   */\n  do {\n    c = read_1_byte();\n  } while (c == 0xFF);\n\n  if (discarded_bytes != 0) {\n    fprintf(stderr, \"Warning: garbage data found in JPEG file\\n\");\n  }\n\n  return c;\n}\n\n\n/*\n * Read the initial marker, which should be SOI.\n * For a JFIF file, the first two bytes of the file should be literally\n * 0xFF M_SOI.  To be more general, we could use next_marker, but if the\n * input file weren't actually JPEG at all, next_marker might read the whole\n * file and then return a misleading error message...\n */\n\nstatic int\nfirst_marker(void)\n{\n  int c1, c2;\n\n  c1 = NEXTBYTE();\n  c2 = NEXTBYTE();\n  if (c1 != 0xFF || c2 != M_SOI)\n    ERREXIT(\"Not a JPEG file\");\n  return c2;\n}\n\n\n/*\n * Most types of marker are followed by a variable-length parameter segment.\n * This routine skips over the parameters for any marker we don't otherwise\n * want to process.\n * Note that we MUST skip the parameter segment explicitly in order not to\n * be fooled by 0xFF bytes that might appear within the parameter segment;\n * such bytes do NOT introduce new markers.\n */\n\nstatic void\nskip_variable(void)\n/* Skip over an unknown or uninteresting variable-length marker */\n{\n  unsigned int length;\n\n  /* Get the marker parameter length count */\n  length = read_2_bytes();\n  /* Length includes itself, so must be at least 2 */\n  if (length < 2)\n    ERREXIT(\"Erroneous JPEG marker length\");\n  length -= 2;\n  /* Skip over the remaining bytes */\n  while (length > 0) {\n    (void)read_1_byte();\n    length--;\n  }\n}\n\n\n/*\n * Process a COM marker.\n * We want to print out the marker contents as legible text;\n * we must guard against non-text junk and varying newline representations.\n */\n\nstatic void\nprocess_COM(int raw)\n{\n  unsigned int length;\n  int ch;\n  int lastch = 0;\n\n  /* Bill Allombert: set locale properly for isprint */\n  setlocale(LC_CTYPE, \"\");\n\n  /* Get the marker parameter length count */\n  length = read_2_bytes();\n  /* Length includes itself, so must be at least 2 */\n  if (length < 2)\n    ERREXIT(\"Erroneous JPEG marker length\");\n  length -= 2;\n\n  while (length > 0) {\n    ch = read_1_byte();\n    if (raw) {\n      putc(ch, stdout);\n    /* Emit the character in a readable form.\n     * Nonprintables are converted to \\nnn form,\n     * while \\ is converted to \\\\.\n     * Newlines in CR, CR/LF, or LF form will be printed as one newline.\n     */\n    } else if (ch == '\\r') {\n      printf(\"\\n\");\n    } else if (ch == '\\n') {\n      if (lastch != '\\r')\n        printf(\"\\n\");\n    } else if (ch == '\\\\') {\n      printf(\"\\\\\\\\\");\n    } else if (isprint(ch)) {\n      putc(ch, stdout);\n    } else {\n      printf(\"\\\\%03o\", (unsigned int)ch);\n    }\n    lastch = ch;\n    length--;\n  }\n  printf(\"\\n\");\n\n  /* Bill Allombert: revert to C locale */\n  setlocale(LC_CTYPE, \"C\");\n}\n\n\n/*\n * Process a SOFn marker.\n * This code is only needed if you want to know the image dimensions...\n */\n\nstatic void\nprocess_SOFn(int marker)\n{\n  unsigned int length;\n  unsigned int image_height, image_width;\n  int data_precision, num_components;\n  const char *process;\n  int ci;\n\n  length = read_2_bytes();      /* usual parameter length count */\n\n  data_precision = read_1_byte();\n  image_height = read_2_bytes();\n  image_width = read_2_bytes();\n  num_components = read_1_byte();\n\n  switch (marker) {\n  case M_SOF0:  process = \"Baseline\";  break;\n  case M_SOF1:  process = \"Extended sequential\";  break;\n  case M_SOF2:  process = \"Progressive\";  break;\n  case M_SOF3:  process = \"Lossless\";  break;\n  case M_SOF5:  process = \"Differential sequential\";  break;\n  case M_SOF6:  process = \"Differential progressive\";  break;\n  case M_SOF7:  process = \"Differential lossless\";  break;\n  case M_SOF9:  process = \"Extended sequential, arithmetic coding\";  break;\n  case M_SOF10: process = \"Progressive, arithmetic coding\";  break;\n  case M_SOF11: process = \"Lossless, arithmetic coding\";  break;\n  case M_SOF13: process = \"Differential sequential, arithmetic coding\";  break;\n  case M_SOF14:\n    process = \"Differential progressive, arithmetic coding\";  break;\n  case M_SOF15: process = \"Differential lossless, arithmetic coding\";  break;\n  default:      process = \"Unknown\";  break;\n  }\n\n  printf(\"JPEG image is %uw * %uh, %d color components, %d bits per sample\\n\",\n         image_width, image_height, num_components, data_precision);\n  printf(\"JPEG process: %s\\n\", process);\n\n  if (length != (unsigned int)(8 + num_components * 3))\n    ERREXIT(\"Bogus SOF marker length\");\n\n  for (ci = 0; ci < num_components; ci++) {\n    (void)read_1_byte();        /* Component ID code */\n    (void)read_1_byte();        /* H, V sampling factors */\n    (void)read_1_byte();        /* Quantization table number */\n  }\n}\n\n\n/*\n * Parse the marker stream until SOS or EOI is seen;\n * display any COM markers.\n * While the companion program wrjpgcom will always insert COM markers before\n * SOFn, other implementations might not, so we scan to SOS before stopping.\n * If we were only interested in the image dimensions, we would stop at SOFn.\n * (Conversely, if we only cared about COM markers, there would be no need\n * for special code to handle SOFn; we could treat it like other markers.)\n */\n\nstatic int\nscan_JPEG_header(int verbose, int raw)\n{\n  int marker;\n\n  /* Expect SOI at start of file */\n  if (first_marker() != M_SOI)\n    ERREXIT(\"Expected SOI marker first\");\n\n  /* Scan miscellaneous markers until we reach SOS. */\n  for (;;) {\n    marker = next_marker();\n    switch (marker) {\n      /* Note that marker codes 0xC4, 0xC8, 0xCC are not, and must not be,\n       * treated as SOFn.  C4 in particular is actually DHT.\n       */\n    case M_SOF0:                /* Baseline */\n    case M_SOF1:                /* Extended sequential, Huffman */\n    case M_SOF2:                /* Progressive, Huffman */\n    case M_SOF3:                /* Lossless, Huffman */\n    case M_SOF5:                /* Differential sequential, Huffman */\n    case M_SOF6:                /* Differential progressive, Huffman */\n    case M_SOF7:                /* Differential lossless, Huffman */\n    case M_SOF9:                /* Extended sequential, arithmetic */\n    case M_SOF10:               /* Progressive, arithmetic */\n    case M_SOF11:               /* Lossless, arithmetic */\n    case M_SOF13:               /* Differential sequential, arithmetic */\n    case M_SOF14:               /* Differential progressive, arithmetic */\n    case M_SOF15:               /* Differential lossless, arithmetic */\n      if (verbose)\n        process_SOFn(marker);\n      else\n        skip_variable();\n      break;\n\n    case M_SOS:                 /* stop before hitting compressed data */\n      return marker;\n\n    case M_EOI:                 /* in case it's a tables-only JPEG stream */\n      return marker;\n\n    case M_COM:\n      process_COM(raw);\n      break;\n\n    case M_APP12:\n      /* Some digital camera makers put useful textual information into\n       * APP12 markers, so we print those out too when in -verbose mode.\n       */\n      if (verbose) {\n        printf(\"APP12 contains:\\n\");\n        process_COM(raw);\n      } else\n        skip_variable();\n      break;\n\n    default:                    /* Anything else just gets skipped */\n      skip_variable();          /* we assume it has a parameter count... */\n      break;\n    }\n  } /* end loop */\n}\n\n\n/* Command line parsing code */\n\nstatic const char *progname;    /* program name for error messages */\n\n\nstatic void\nusage(void)\n/* complain about bad command line */\n{\n  fprintf(stderr, \"rdjpgcom displays any textual comments in a JPEG file.\\n\");\n\n  fprintf(stderr, \"Usage: %s [switches] [inputfile]\\n\", progname);\n\n  fprintf(stderr, \"Switches (names may be abbreviated):\\n\");\n  fprintf(stderr, \"  -raw        Display non-printable characters in comments (unsafe)\\n\");\n  fprintf(stderr, \"  -verbose    Also display dimensions of JPEG image\\n\");\n\n  exit(EXIT_FAILURE);\n}\n\n\nstatic int\nkeymatch(char *arg, const char *keyword, int minchars)\n/* Case-insensitive matching of (possibly abbreviated) keyword switches. */\n/* keyword is the constant keyword (must be lower case already), */\n/* minchars is length of minimum legal abbreviation. */\n{\n  register int ca, ck;\n  register int nmatched = 0;\n\n  while ((ca = *arg++) != '\\0') {\n    if ((ck = *keyword++) == '\\0')\n      return 0;                 /* arg longer than keyword, no good */\n    if (isupper(ca))            /* force arg to lcase (assume ck is already) */\n      ca = tolower(ca);\n    if (ca != ck)\n      return 0;                 /* no good */\n    nmatched++;                 /* count matched characters */\n  }\n  /* reached end of argument; fail if it's too short for unique abbrev */\n  if (nmatched < minchars)\n    return 0;\n  return 1;                     /* A-OK */\n}\n\n\n/*\n * The main program.\n */\n\nint\nmain(int argc, char **argv)\n{\n  int argn;\n  char *arg;\n  int verbose = 0, raw = 0;\n\n  progname = argv[0];\n  if (progname == NULL || progname[0] == 0)\n    progname = \"rdjpgcom\";      /* in case C library doesn't provide it */\n\n  /* Parse switches, if any */\n  for (argn = 1; argn < argc; argn++) {\n    arg = argv[argn];\n    if (arg[0] != '-')\n      break;                    /* not switch, must be file name */\n    arg++;                      /* advance over '-' */\n    if (keymatch(arg, \"verbose\", 1)) {\n      verbose++;\n    } else if (keymatch(arg, \"raw\", 1)) {\n      raw = 1;\n    } else\n      usage();\n  }\n\n  /* Open the input file. */\n  /* Unix style: expect zero or one file name */\n  if (argn < argc - 1) {\n    fprintf(stderr, \"%s: only one input file\\n\", progname);\n    usage();\n  }\n  if (argn < argc) {\n    if ((infile = fopen(argv[argn], READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, argv[argn]);\n      exit(EXIT_FAILURE);\n    }\n  } else {\n    /* default input file is stdin */\n#ifdef USE_SETMODE              /* need to hack file mode? */\n    setmode(fileno(stdin), O_BINARY);\n#endif\n#ifdef USE_FDOPEN               /* need to re-open in binary mode? */\n    if ((infile = fdopen(fileno(stdin), READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open stdin\\n\", progname);\n      exit(EXIT_FAILURE);\n    }\n#else\n    infile = stdin;\n#endif\n  }\n\n  /* Scan the JPEG headers. */\n  (void)scan_JPEG_header(verbose, raw);\n\n  /* All done. */\n  exit(EXIT_SUCCESS);\n  return 0;                     /* suppress no-return-value warnings */\n}\n"
        },
        {
          "name": "rdpng.c",
          "type": "blob",
          "size": 6.708984375,
          "content": "\n#include \"cdjpeg.h\"   /* Common decls for cjpeg/djpeg applications */\n\n#ifdef PNG_SUPPORTED\n\n#include <png.h>      /* if this fails, you need to install libpng-devel */\n\n\ntypedef struct png_source_struct {\n    struct cjpeg_source_struct pub;\n    png_structp  png_ptr;\n    png_infop    info_ptr;\n    JDIMENSION   current_row;\n} png_source_struct;\n\n\nMETHODDEF(void)\nfinish_input_png (j_compress_ptr cinfo, cjpeg_source_ptr sinfo);\n\nMETHODDEF(JDIMENSION)\nget_pixel_rows_png (j_compress_ptr cinfo, cjpeg_source_ptr sinfo);\n\nMETHODDEF(void)\nstart_input_png (j_compress_ptr cinfo, cjpeg_source_ptr sinfo);\n\n\nGLOBAL(cjpeg_source_ptr)\njinit_read_png(j_compress_ptr cinfo)\n{\n    png_source_struct *source = (*cinfo->mem->alloc_small)((j_common_ptr) cinfo, JPOOL_IMAGE, sizeof(png_source_struct));\n\n    memset(source, 0, sizeof(*source));\n\n    /* Fill in method ptrs, except get_pixel_rows which start_input sets */\n    source->pub.start_input = start_input_png;\n    source->pub.finish_input = finish_input_png;\n\n    return &source->pub;\n}\n\nMETHODDEF(void) error_input_png(png_structp png_ptr, png_const_charp msg) {\n    j_compress_ptr cinfo = png_get_error_ptr(png_ptr);\n    ERREXITS(cinfo, JERR_PNG_ERROR, msg);\n}\n\n/* This is a small ICC profile for sRGB */\nstatic unsigned char tiny_srgb[] = {0,0,2,24,108,99,109,115,2,16,0,0,109,110,\n116,114,82,71,66,32,88,89,90,32,7,220,0,1,0,25,0,3,0,41,0,57,97,99,115,112,65,\n80,80,76,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,246,214,0,1,0,0,0,\n0,211,45,108,99,109,115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,100,101,115,99,0,0,0,252,0,0,0,106,\n99,112,114,116,0,0,1,104,0,0,0,11,119,116,112,116,0,0,1,116,0,0,0,20,98,107,\n112,116,0,0,1,136,0,0,0,20,114,88,89,90,0,0,1,156,0,0,0,20,103,88,89,90,0,0,1,\n176,0,0,0,20,98,88,89,90,0,0,1,196,0,0,0,20,114,84,82,67,0,0,1,216,0,0,0,64,98,\n84,82,67,0,0,1,216,0,0,0,64,103,84,82,67,0,0,1,216,0,0,0,64,100,101,115,99,0,0,\n0,0,0,0,0,13,115,82,71,66,32,77,111,122,74,80,69,71,0,0,0,0,0,0,0,0,1,0,0,0,0,\n1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,116,101,120,\n116,0,0,0,0,80,68,0,0,88,89,90,32,0,0,0,0,0,0,246,214,0,1,0,0,0,0,211,45,88,89,\n90,32,0,0,0,0,0,0,3,22,0,0,3,51,0,0,2,164,88,89,90,32,0,0,0,0,0,0,111,162,0,0,\n56,245,0,0,3,144,88,89,90,32,0,0,0,0,0,0,98,153,0,0,183,133,0,0,24,218,88,89,\n90,32,0,0,0,0,0,0,36,160,0,0,15,132,0,0,182,207,99,117,114,118,0,0,0,0,0,0,0,\n26,0,0,0,203,1,201,3,99,5,146,8,107,11,246,16,63,21,81,27,52,33,241,41,144,50,\n24,59,146,70,5,81,119,93,237,107,112,122,5,137,177,154,124,172,105,191,125,211,\n195,233,48,255,255,};\n\nMETHODDEF(void)\nstart_input_png (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n    png_source_struct *source = (png_source_struct *)sinfo;\n    png_uint_32 width, height;\n    int bit_depth, color_type;\n    int has_srgb_chunk;\n    double gamma;\n    png_bytep profile;\n    png_charp unused1;\n    int unused2;\n    png_uint_32 proflen;\n    int has_profile;\n    size_t datalen;\n    JOCTET *dataptr;\n    struct jpeg_marker_struct *marker;\n    png_size_t rowbytes;\n\n    source->png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, cinfo, error_input_png, NULL);\n    source->info_ptr = png_create_info_struct(source->png_ptr);\n\n    if (!source->png_ptr || !source->info_ptr) {\n        ERREXITS(cinfo, JERR_PNG_ERROR, \"Can't create read/info_struct\");\n        return;\n    }\n\n    png_set_palette_to_rgb(source->png_ptr);\n    png_set_expand_gray_1_2_4_to_8(source->png_ptr);\n    png_set_strip_alpha(source->png_ptr);\n    png_set_interlace_handling(source->png_ptr);\n\n    png_init_io(source->png_ptr, source->pub.input_file);\n    png_read_info(source->png_ptr, source->info_ptr);\n\n    png_get_IHDR(source->png_ptr, source->info_ptr, &width, &height,\n                 &bit_depth, &color_type, NULL, NULL, NULL);\n\n    if (width > 65535 || height > 65535) {\n        ERREXITS(cinfo, JERR_PNG_ERROR, \"Image too large\");\n        return;\n    }\n\n    if (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n        cinfo->in_color_space = JCS_GRAYSCALE;\n        cinfo->input_components = 1;\n    } else {\n        cinfo->in_color_space = JCS_RGB;\n        cinfo->input_components = 3;\n    }\n\n    if (bit_depth == 16) {\n        png_set_strip_16(source->png_ptr);\n    }\n\n    cinfo->data_precision = 8;\n    cinfo->image_width = width;\n    cinfo->image_height = height;\n\n    has_srgb_chunk = png_get_valid(source->png_ptr, source->info_ptr, PNG_INFO_sRGB);\n\n    gamma = 0.45455;\n    if (!has_srgb_chunk) {\n        png_get_gAMA(source->png_ptr, source->info_ptr, &gamma);\n    }\n    cinfo->input_gamma = gamma;\n    sinfo->get_pixel_rows = get_pixel_rows_png;\n\n    source->pub.marker_list = NULL;\n    profile = NULL;\n    unused1 = NULL;\n    unused2 = 0;\n    proflen = 0;\n    has_profile = 0;\n\n    if (has_srgb_chunk) {\n        /* PNG can declare use of an sRGB profile without embedding an ICC file, but JPEG doesn't have such feature */\n        has_profile = 1;\n        profile = tiny_srgb;\n        proflen = sizeof(tiny_srgb);\n    } else {\n        has_profile = png_get_iCCP(source->png_ptr, source->info_ptr, &unused1, &unused2, &profile, &proflen); /* your libpng is out of date if you get a warning here */\n    }\n\n    if (has_profile && profile && proflen) {\n        if (proflen < 65535-14) {\n            datalen = proflen + 14;\n            dataptr = (*cinfo->mem->alloc_small)((j_common_ptr)cinfo, JPOOL_IMAGE, datalen);\n            memcpy(dataptr, \"ICC_PROFILE\\0\\x01\\x01\", 14);\n            memcpy(dataptr + 14, profile, proflen);\n            marker = (*cinfo->mem->alloc_small)((j_common_ptr)cinfo, JPOOL_IMAGE, sizeof(struct jpeg_marker_struct));\n            marker->next = NULL;\n            marker->marker = JPEG_APP0+2;\n            marker->original_length = 0;\n            marker->data_length = datalen;\n            marker->data = dataptr;\n            source->pub.marker_list = marker;\n        } else {\n            WARNMS(cinfo, JERR_PNG_PROFILETOOLARGE);\n        }\n    }\n\n    png_read_update_info(source->png_ptr, source->info_ptr);\n\n    rowbytes = png_get_rowbytes(source->png_ptr, source->info_ptr);\n\n    source->pub.buffer = (*cinfo->mem->alloc_sarray)((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)rowbytes, 1);\n    source->pub.buffer_height = 1;\n}\n\nMETHODDEF(JDIMENSION)\nget_pixel_rows_png (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n    png_source_struct *source = (png_source_struct *)sinfo;\n\n    png_read_row(source->png_ptr, source->pub.buffer[0], NULL);\n    return 1;\n}\n\nMETHODDEF(void)\nfinish_input_png (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n    png_source_struct *source = (png_source_struct *)sinfo;\n\n    png_read_end(source->png_ptr, source->info_ptr);\n    png_destroy_read_struct(&source->png_ptr, &source->info_ptr, NULL);\n}\n\n#endif\n"
        },
        {
          "name": "rdppm.c",
          "type": "blob",
          "size": 28.92578125,
          "content": "/*\n * rdppm.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 2009 by Bill Allombert, Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015-2017, 2020-2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to read input images in PPM/PGM format.\n * The extended 2-byte-per-sample raw PPM/PGM formats are supported.\n * The PBMPLUS library is NOT required to compile this software\n * (but it is highly useful as a set of PPM image manipulation programs).\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume input from\n * an ordinary stdio stream.  They further assume that reading begins\n * at the start of the file; start_input may need work if the\n * user interface has already read some data (e.g., to determine that\n * the file is indeed PPM format).\n */\n\n#include \"cmyk.h\"\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n\n#if defined(PPM_SUPPORTED) && \\\n    (BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED))\n\n\n/* Portions of this code are based on the PBMPLUS library, which is:\n**\n** Copyright (C) 1988 by Jef Poskanzer.\n**\n** Permission to use, copy, modify, and distribute this software and its\n** documentation for any purpose and without fee is hereby granted, provided\n** that the above copyright notice appear in all copies and that both that\n** copyright notice and this permission notice appear in supporting\n** documentation.  This software is provided \"as is\" without express or\n** implied warranty.\n*/\n\n\n/* Macros to deal with unsigned chars as efficiently as compiler allows */\n\ntypedef unsigned char U_CHAR;\n#define UCH(x)  ((int)(x))\n\n\n#define ReadOK(file, buffer, len) \\\n  (fread(buffer, 1, len, file) == ((size_t)(len)))\n\nstatic int alpha_index[JPEG_NUMCS] = {\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1\n};\n\n\n/* Private version of data source object */\n\ntypedef struct {\n  struct cjpeg_source_struct pub; /* public fields */\n\n  /* Usually these two pointers point to the same place: */\n  U_CHAR *iobuffer;             /* fread's I/O buffer */\n  _JSAMPROW pixrow;             /* compressor input buffer */\n  size_t buffer_width;          /* width of I/O buffer */\n  _JSAMPLE *rescale;            /* => maxval-remapping array, or NULL */\n  unsigned int maxval;\n} ppm_source_struct;\n\ntypedef ppm_source_struct *ppm_source_ptr;\n\n\nLOCAL(int)\npbm_getc(FILE *infile)\n/* Read next char, skipping over any comments */\n/* A comment/newline sequence is returned as a newline */\n{\n  register int ch;\n\n  ch = getc(infile);\n  if (ch == '#') {\n    do {\n      ch = getc(infile);\n    } while (ch != '\\n' && ch != EOF);\n  }\n  return ch;\n}\n\n\nLOCAL(unsigned int)\nread_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n/* Read an unsigned decimal integer from the PPM file */\n/* Swallows one trailing character after the integer */\n/* Note that on a 16-bit-int machine, only values up to 64k can be read. */\n/* This should not be a problem in practice. */\n{\n  register int ch;\n  register unsigned int val;\n\n  /* Skip any leading whitespace */\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n    if (val > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n  }\n\n  return val;\n}\n\n\n/*\n * Read one row of pixels.\n *\n * We provide several different versions depending on input file format.\n * In all cases, input is scaled to the size of _JSAMPLE.\n *\n * A really fast path is provided for reading byte/sample raw files with\n * maxval = _MAXJSAMPLE, which is the normal case for 8-bit data.\n */\n\n\nMETHODDEF(JDIMENSION)\nget_text_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register _JSAMPROW ptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  ptr = source->pub._buffer[0];\n  for (col = cinfo->image_width; col > 0; col--) {\n    *ptr++ = rescale[read_pbm_integer(cinfo, infile, maxval)];\n  }\n  return 1;\n}\n\n\n#define GRAY_RGB_READ_LOOP(read_op, alpha_set_op) { \\\n  for (col = cinfo->image_width; col > 0; col--) { \\\n    ptr[rindex] = ptr[gindex] = ptr[bindex] = read_op; \\\n    alpha_set_op \\\n    ptr += ps; \\\n  } \\\n}\n\nMETHODDEF(JDIMENSION)\nget_text_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval and\n   converting to extended RGB */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register _JSAMPROW ptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  ptr = source->pub._buffer[0];\n  if (maxval == _MAXJSAMPLE) {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP((_JSAMPLE)read_pbm_integer(cinfo, infile, maxval),\n                         ptr[aindex] = _MAXJSAMPLE;)\n    else\n      GRAY_RGB_READ_LOOP((_JSAMPLE)read_pbm_integer(cinfo, infile, maxval), {})\n  } else {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],\n                         ptr[aindex] = _MAXJSAMPLE;)\n    else\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)], {})\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_text_gray_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PGM files with any maxval and\n   converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register _JSAMPROW ptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  ptr = source->pub._buffer[0];\n  if (maxval == _MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      _JSAMPLE gray = (_JSAMPLE)read_pbm_integer(cinfo, infile, maxval);\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      _JSAMPLE gray = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\n#define RGB_READ_LOOP(read_op, alpha_set_op) { \\\n  for (col = cinfo->image_width; col > 0; col--) { \\\n    ptr[rindex] = read_op; \\\n    ptr[gindex] = read_op; \\\n    ptr[bindex] = read_op; \\\n    alpha_set_op \\\n    ptr += ps; \\\n  } \\\n}\n\nMETHODDEF(JDIMENSION)\nget_text_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register _JSAMPROW ptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  ptr = source->pub._buffer[0];\n  if (maxval == _MAXJSAMPLE) {\n    if (aindex >= 0)\n      RGB_READ_LOOP((_JSAMPLE)read_pbm_integer(cinfo, infile, maxval),\n                    ptr[aindex] = _MAXJSAMPLE;)\n    else\n      RGB_READ_LOOP((_JSAMPLE)read_pbm_integer(cinfo, infile, maxval), {})\n  } else {\n    if (aindex >= 0)\n      RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],\n                    ptr[aindex] = _MAXJSAMPLE;)\n    else\n      RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)], {})\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_text_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PPM files with any maxval and\n   converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register _JSAMPROW ptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  ptr = source->pub._buffer[0];\n  if (maxval == _MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      _JSAMPLE r = (_JSAMPLE)read_pbm_integer(cinfo, infile, maxval);\n      _JSAMPLE g = (_JSAMPLE)read_pbm_integer(cinfo, infile, maxval);\n      _JSAMPLE b = (_JSAMPLE)read_pbm_integer(cinfo, infile, maxval);\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      _JSAMPLE r = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      _JSAMPLE g = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      _JSAMPLE b = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_scaled_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register _JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub._buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    *ptr++ = rescale[UCH(*bufferptr++)];\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PGM files with any maxval\n   and converting to extended RGB */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register _JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub._buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == _MAXJSAMPLE) {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(*bufferptr++, ptr[aindex] = _MAXJSAMPLE;)\n    else\n      GRAY_RGB_READ_LOOP(*bufferptr++, {})\n  } else {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)],\n                         ptr[aindex] = _MAXJSAMPLE;)\n    else\n      GRAY_RGB_READ_LOOP(rescale[UCH(*bufferptr++)], {})\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_gray_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PGM files with any maxval\n   and converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register _JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub._buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == _MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      _JSAMPLE gray = *bufferptr++;\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      _JSAMPLE gray = rescale[UCH(*bufferptr++)];\n      rgb_to_cmyk(gray, gray, gray, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register _JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub._buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == _MAXJSAMPLE) {\n    if (aindex >= 0)\n      RGB_READ_LOOP(*bufferptr++, ptr[aindex] = _MAXJSAMPLE;)\n    else\n      RGB_READ_LOOP(*bufferptr++, {})\n  } else {\n    if (aindex >= 0)\n      RGB_READ_LOOP(rescale[UCH(*bufferptr++)], ptr[aindex] = _MAXJSAMPLE;)\n    else\n      RGB_READ_LOOP(rescale[UCH(*bufferptr++)], {})\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format PPM files with any maxval and\n   converting to CMYK */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register _JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub._buffer[0];\n  bufferptr = source->iobuffer;\n  if (maxval == _MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      _JSAMPLE r = *bufferptr++;\n      _JSAMPLE g = *bufferptr++;\n      _JSAMPLE b = *bufferptr++;\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      _JSAMPLE r = rescale[UCH(*bufferptr++)];\n      _JSAMPLE g = rescale[UCH(*bufferptr++)];\n      _JSAMPLE b = rescale[UCH(*bufferptr++)];\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_raw_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format files with maxval = _MAXJSAMPLE.\n * In this case we just read right into the _JSAMPLE buffer!\n * Note that same code works for PPM and PGM files.\n */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register _JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub._buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_word_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register _JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub._buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[rindex] = ptr[gindex] = ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = _MAXJSAMPLE;\n    ptr += ps;\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_word_gray_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PGM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register _JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub._buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int gray;\n    gray  = UCH(*bufferptr++) << 8;\n    gray |= UCH(*bufferptr++);\n    if (gray > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    rgb_to_cmyk(rescale[gray], rescale[gray], rescale[gray], ptr, ptr + 1,\n                ptr + 2, ptr + 3);\n    ptr += 4;\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register _JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub._buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[rindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[gindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = _MAXJSAMPLE;\n    ptr += ps;\n  }\n  return 1;\n}\n\n\nMETHODDEF(JDIMENSION)\nget_word_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-word-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register _JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register _JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub._buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int r, g, b;\n    r  = UCH(*bufferptr++) << 8;\n    r |= UCH(*bufferptr++);\n    if (r > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    g  = UCH(*bufferptr++) << 8;\n    g |= UCH(*bufferptr++);\n    if (g > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    b  = UCH(*bufferptr++) << 8;\n    b |= UCH(*bufferptr++);\n    if (b > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    rgb_to_cmyk(rescale[r], rescale[g], rescale[b], ptr, ptr + 1, ptr + 2,\n                ptr + 3);\n    ptr += 4;\n  }\n  return 1;\n}\n\n\n/*\n * Read the file header; return image size and component count.\n */\n\nMETHODDEF(void)\nstart_input_ppm(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  int c;\n  unsigned int w, h, maxval;\n  boolean need_iobuffer, use_raw_buffer, need_rescale;\n\n  if (getc(source->pub.input_file) != 'P')\n    ERREXIT(cinfo, JERR_PPM_NOT);\n\n  c = getc(source->pub.input_file); /* subformat discriminator character */\n\n  /* detect unsupported variants (ie, PBM) before trying to read header */\n  switch (c) {\n  case '2':                     /* it's a text-format PGM file */\n  case '3':                     /* it's a text-format PPM file */\n  case '5':                     /* it's a raw-format PGM file */\n  case '6':                     /* it's a raw-format PPM file */\n    break;\n  default:\n    ERREXIT(cinfo, JERR_PPM_NOT);\n    break;\n  }\n\n  /* fetch the remaining header info */\n  w = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n  h = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n  maxval = read_pbm_integer(cinfo, source->pub.input_file, 65535);\n\n  if (w <= 0 || h <= 0 || maxval <= 0) /* error check */\n    ERREXIT(cinfo, JERR_PPM_NOT);\n  if (sinfo->max_pixels && (unsigned long long)w * h > sinfo->max_pixels)\n    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, sinfo->max_pixels);\n\n  cinfo->data_precision = BITS_IN_JSAMPLE; /* we always rescale data to this */\n  cinfo->image_width = (JDIMENSION)w;\n  cinfo->image_height = (JDIMENSION)h;\n  source->maxval = maxval;\n\n  /* initialize flags to most common settings */\n  need_iobuffer = TRUE;         /* do we need an I/O buffer? */\n  use_raw_buffer = FALSE;       /* do we map input buffer onto I/O buffer? */\n  need_rescale = TRUE;          /* do we need a rescale array? */\n\n  switch (c) {\n  case '2':                     /* it's a text-format PGM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN ||\n        cinfo->in_color_space == JCS_RGB)\n      cinfo->in_color_space = JCS_GRAYSCALE;\n    TRACEMS3(cinfo, 1, JTRC_PGM_TEXT, w, h, maxval);\n    if (cinfo->in_color_space == JCS_GRAYSCALE)\n      source->pub.get_pixel_rows = get_text_gray_row;\n    else if (IsExtRGB(cinfo->in_color_space))\n      source->pub.get_pixel_rows = get_text_gray_rgb_row;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      source->pub.get_pixel_rows = get_text_gray_cmyk_row;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    need_iobuffer = FALSE;\n    break;\n\n  case '3':                     /* it's a text-format PPM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    TRACEMS3(cinfo, 1, JTRC_PPM_TEXT, w, h, maxval);\n    if (IsExtRGB(cinfo->in_color_space))\n      source->pub.get_pixel_rows = get_text_rgb_row;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      source->pub.get_pixel_rows = get_text_rgb_cmyk_row;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    need_iobuffer = FALSE;\n    break;\n\n  case '5':                     /* it's a raw-format PGM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN ||\n        cinfo->in_color_space == JCS_RGB)\n      cinfo->in_color_space = JCS_GRAYSCALE;\n    TRACEMS3(cinfo, 1, JTRC_PGM, w, h, maxval);\n    if (maxval > 255) {\n      if (cinfo->in_color_space == JCS_GRAYSCALE)\n        source->pub.get_pixel_rows = get_word_gray_row;\n      else if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_word_gray_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_word_gray_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    } else if (maxval == _MAXJSAMPLE && sizeof(_JSAMPLE) == sizeof(U_CHAR) &&\n               cinfo->in_color_space == JCS_GRAYSCALE) {\n      source->pub.get_pixel_rows = get_raw_row;\n      use_raw_buffer = TRUE;\n      need_rescale = FALSE;\n    } else {\n      if (cinfo->in_color_space == JCS_GRAYSCALE)\n        source->pub.get_pixel_rows = get_scaled_gray_row;\n      else if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_gray_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_gray_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    }\n    break;\n\n  case '6':                     /* it's a raw-format PPM file */\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    TRACEMS3(cinfo, 1, JTRC_PPM, w, h, maxval);\n    if (maxval > 255) {\n      if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_word_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_word_rgb_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    } else if (maxval == _MAXJSAMPLE && sizeof(_JSAMPLE) == sizeof(U_CHAR) &&\n#if RGB_RED == 0 && RGB_GREEN == 1 && RGB_BLUE == 2 && RGB_PIXELSIZE == 3\n               (cinfo->in_color_space == JCS_EXT_RGB ||\n                cinfo->in_color_space == JCS_RGB)) {\n#else\n               cinfo->in_color_space == JCS_EXT_RGB) {\n#endif\n      source->pub.get_pixel_rows = get_raw_row;\n      use_raw_buffer = TRUE;\n      need_rescale = FALSE;\n    } else {\n      if (IsExtRGB(cinfo->in_color_space))\n        source->pub.get_pixel_rows = get_rgb_row;\n      else if (cinfo->in_color_space == JCS_CMYK)\n        source->pub.get_pixel_rows = get_rgb_cmyk_row;\n      else\n        ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    }\n    break;\n  }\n\n  if (IsExtRGB(cinfo->in_color_space))\n    cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n  else if (cinfo->in_color_space == JCS_GRAYSCALE)\n    cinfo->input_components = 1;\n  else if (cinfo->in_color_space == JCS_CMYK)\n    cinfo->input_components = 4;\n\n  /* Allocate space for I/O buffer: 1 or 3 bytes or words/pixel. */\n  if (need_iobuffer) {\n    if (c == '6')\n      source->buffer_width = (size_t)w * 3 *\n        ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));\n    else\n      source->buffer_width = (size_t)w *\n        ((maxval <= 255) ? sizeof(U_CHAR) : (2 * sizeof(U_CHAR)));\n    source->iobuffer = (U_CHAR *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  source->buffer_width);\n  }\n\n  /* Create compressor input buffer. */\n  if (use_raw_buffer) {\n    /* For unscaled raw-input case, we can just map it onto the I/O buffer. */\n    /* Synthesize a _JSAMPARRAY pointer structure */\n    source->pixrow = (_JSAMPROW)source->iobuffer;\n    source->pub._buffer = &source->pixrow;\n    source->pub.buffer_height = 1;\n  } else {\n    /* Need to translate anyway, so make a separate sample buffer. */\n    source->pub._buffer = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       (JDIMENSION)w * cinfo->input_components, (JDIMENSION)1);\n    source->pub.buffer_height = 1;\n  }\n\n  /* Compute the rescaling array if required. */\n  if (need_rescale) {\n    long val, half_maxval;\n\n    /* On 16-bit-int machines we have to be careful of maxval = 65535 */\n    source->rescale = (_JSAMPLE *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  (size_t)(((long)MAX(maxval, 255) + 1L) *\n                                           sizeof(_JSAMPLE)));\n    memset(source->rescale, 0, (size_t)(((long)MAX(maxval, 255) + 1L) *\n                                        sizeof(_JSAMPLE)));\n    half_maxval = maxval / 2;\n    for (val = 0; val <= (long)maxval; val++) {\n      /* The multiplication here must be done in 32 bits to avoid overflow */\n      source->rescale[val] = (_JSAMPLE)((val * _MAXJSAMPLE + half_maxval) /\n                                        maxval);\n    }\n  }\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_input_ppm(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  /* no work */\n}\n\n\n/*\n * The module selection routine for PPM format input.\n */\n\nGLOBAL(cjpeg_source_ptr)\n_jinit_read_ppm(j_compress_ptr cinfo)\n{\n  ppm_source_ptr source;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Create module interface object */\n  source = (ppm_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(ppm_source_struct));\n  /* Fill in method ptrs, except get_pixel_rows which start_input sets */\n  source->pub.start_input = start_input_ppm;\n  source->pub.finish_input = finish_input_ppm;\n  source->pub.max_pixels = 0;\n\n  return (cjpeg_source_ptr)source;\n}\n\n#endif /* defined(PPM_SUPPORTED) &&\n          (BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED)) */\n"
        },
        {
          "name": "rdswitch.c",
          "type": "blob",
          "size": 19.8837890625,
          "content": "/*\n * rdswitch.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010, 2018, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to process some of cjpeg's more complicated\n * command-line switches.  Switches processed here are:\n *      -qtables file           Read quantization tables from text file\n *      -scans file             Read scan script from text file\n *      -quality N[,N,...]      Set quality ratings\n *      -qslots N[,N,...]       Set component quantization table selectors\n *      -sample HxV[,HxV,...]   Set component sampling factors\n */\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n#include <ctype.h>              /* to declare isdigit(), isspace() */\n\n\nLOCAL(int)\ntext_getc(FILE *file)\n/* Read next char, skipping over any comments (# to end of line) */\n/* A comment/newline sequence is returned as a newline */\n{\n  register int ch;\n\n  ch = getc(file);\n  if (ch == '#') {\n    do {\n      ch = getc(file);\n    } while (ch != '\\n' && ch != EOF);\n  }\n  return ch;\n}\n\n\nLOCAL(boolean)\nread_text_integer(FILE *file, long *result, int *termchar)\n/* Read an unsigned decimal integer from a file, store it in result */\n/* Reads one trailing character after the integer; returns it in termchar */\n{\n  register int ch;\n  register long val;\n\n  /* Skip any leading whitespace, detect EOF */\n  do {\n    ch = text_getc(file);\n    if (ch == EOF) {\n      *termchar = ch;\n      return FALSE;\n    }\n  } while (isspace(ch));\n\n  if (!isdigit(ch)) {\n    *termchar = ch;\n    return FALSE;\n  }\n\n  val = ch - '0';\n  while ((ch = text_getc(file)) != EOF) {\n    if (!isdigit(ch))\n      break;\n    val *= 10;\n    val += ch - '0';\n  }\n  *result = val;\n  *termchar = ch;\n  return TRUE;\n}\n\n\n#if JPEG_LIB_VERSION < 70\nstatic int q_scale_factor[NUM_QUANT_TBLS] = { 100, 100, 100, 100 };\n#endif\n\nGLOBAL(boolean)\nread_quant_tables(j_compress_ptr cinfo, char *filename, boolean force_baseline)\n/* Read a set of quantization tables from the specified file.\n * The file is plain ASCII text: decimal numbers with whitespace between.\n * Comments preceded by '#' may be included in the file.\n * There may be one to NUM_QUANT_TBLS tables in the file, each of 64 values.\n * The tables are implicitly numbered 0,1,etc.\n * NOTE: does not affect the qslots mapping, which will default to selecting\n * table 0 for luminance (or primary) components, 1 for chrominance components.\n * You must use -qslots if you want a different component->table mapping.\n */\n{\n  FILE *fp;\n  int tblno, i, termchar;\n  long val;\n  unsigned int table[DCTSIZE2];\n\n  if ((fp = fopen(filename, \"r\")) == NULL) {\n    fprintf(stderr, \"Can't open table file %s\\n\", filename);\n    return FALSE;\n  }\n  tblno = 0;\n\n  while (read_text_integer(fp, &val, &termchar)) { /* read 1st element of table */\n    if (tblno >= NUM_QUANT_TBLS) {\n      fprintf(stderr, \"Too many tables in file %s\\n\", filename);\n      fclose(fp);\n      return FALSE;\n    }\n    table[0] = (unsigned int)val;\n    for (i = 1; i < DCTSIZE2; i++) {\n      if (!read_text_integer(fp, &val, &termchar)) {\n        fprintf(stderr, \"Invalid table data in file %s\\n\", filename);\n        fclose(fp);\n        return FALSE;\n      }\n      table[i] = (unsigned int)val;\n    }\n#if JPEG_LIB_VERSION >= 70\n    jpeg_add_quant_table(cinfo, tblno, table, cinfo->q_scale_factor[tblno],\n                         force_baseline);\n#else\n    jpeg_add_quant_table(cinfo, tblno, table, q_scale_factor[tblno],\n                         force_baseline);\n#endif\n    tblno++;\n  }\n\n  if (termchar != EOF) {\n    fprintf(stderr, \"Non-numeric data in file %s\\n\", filename);\n    fclose(fp);\n    return FALSE;\n  }\n\n  fclose(fp);\n  return TRUE;\n}\n\n\n#ifdef C_MULTISCAN_FILES_SUPPORTED\n\nLOCAL(boolean)\nread_scan_integer(FILE *file, long *result, int *termchar)\n/* Variant of read_text_integer that always looks for a non-space termchar;\n * this simplifies parsing of punctuation in scan scripts.\n */\n{\n  register int ch;\n\n  if (!read_text_integer(file, result, termchar))\n    return FALSE;\n  ch = *termchar;\n  while (ch != EOF && isspace(ch))\n    ch = text_getc(file);\n  if (isdigit(ch)) {            /* oops, put it back */\n    if (ungetc(ch, file) == EOF)\n      return FALSE;\n    ch = ' ';\n  } else {\n    /* Any separators other than ';' and ':' are ignored;\n     * this allows user to insert commas, etc, if desired.\n     */\n    if (ch != EOF && ch != ';' && ch != ':')\n      ch = ' ';\n  }\n  *termchar = ch;\n  return TRUE;\n}\n\n\nGLOBAL(boolean)\nread_scan_script(j_compress_ptr cinfo, char *filename)\n/* Read a scan script from the specified text file.\n * Each entry in the file defines one scan to be emitted.\n * Entries are separated by semicolons ';'.\n * An entry contains one to four component indexes,\n * optionally followed by a colon ':' and four progressive-JPEG parameters.\n * The component indexes denote which component(s) are to be transmitted\n * in the current scan.  The first component has index 0.\n * Sequential JPEG is used if the progressive-JPEG parameters are omitted.\n * The file is free format text: any whitespace may appear between numbers\n * and the ':' and ';' punctuation marks.  Also, other punctuation (such\n * as commas or dashes) can be placed between numbers if desired.\n * Comments preceded by '#' may be included in the file.\n * Note: we do very little validity checking here;\n * jcmaster.c will validate the script parameters.\n */\n{\n  FILE *fp;\n  int scanno, ncomps, termchar;\n  long val;\n  jpeg_scan_info *scanptr;\n#define MAX_SCANS  64          /* must match scan_buffer size */\n  jpeg_scan_info scans[MAX_SCANS];\n\n  if ((fp = fopen(filename, \"r\")) == NULL) {\n    fprintf(stderr, \"Can't open scan definition file %s\\n\", filename);\n    return FALSE;\n  }\n  scanptr = scans;\n  scanno = 0;\n\n  while (read_scan_integer(fp, &val, &termchar)) {\n    if (scanno >= MAX_SCANS) {\n      fprintf(stderr, \"Too many scans defined in file %s\\n\", filename);\n      fclose(fp);\n      return FALSE;\n    }\n    scanptr->component_index[0] = (int)val;\n    ncomps = 1;\n    while (termchar == ' ') {\n      if (ncomps >= MAX_COMPS_IN_SCAN) {\n        fprintf(stderr, \"Too many components in one scan in file %s\\n\",\n                filename);\n        fclose(fp);\n        return FALSE;\n      }\n      if (!read_scan_integer(fp, &val, &termchar))\n        goto bogus;\n      scanptr->component_index[ncomps] = (int)val;\n      ncomps++;\n    }\n    scanptr->comps_in_scan = ncomps;\n    if (termchar == ':') {\n      if (!read_scan_integer(fp, &val, &termchar) || termchar != ' ')\n        goto bogus;\n      scanptr->Ss = (int)val;\n      if (!read_scan_integer(fp, &val, &termchar) || termchar != ' ')\n        goto bogus;\n      scanptr->Se = (int)val;\n      if (!read_scan_integer(fp, &val, &termchar) || termchar != ' ')\n        goto bogus;\n      scanptr->Ah = (int)val;\n      if (!read_scan_integer(fp, &val, &termchar))\n        goto bogus;\n      scanptr->Al = (int)val;\n    } else {\n      /* set non-progressive parameters */\n      scanptr->Ss = 0;\n      scanptr->Se = DCTSIZE2 - 1;\n      scanptr->Ah = 0;\n      scanptr->Al = 0;\n    }\n    if (termchar != ';' && termchar != EOF) {\nbogus:\n      fprintf(stderr, \"Invalid scan entry format in file %s\\n\", filename);\n      fclose(fp);\n      return FALSE;\n    }\n    scanptr++, scanno++;\n  }\n\n  if (termchar != EOF) {\n    fprintf(stderr, \"Non-numeric data in file %s\\n\", filename);\n    fclose(fp);\n    return FALSE;\n  }\n\n  if (scanno > 0) {\n    /* Stash completed scan list in cinfo structure.\n     * NOTE: for cjpeg's use, JPOOL_IMAGE is the right lifetime for this data,\n     * but if you want to compress multiple images you'd want JPOOL_PERMANENT.\n     */\n    scanptr = (jpeg_scan_info *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  scanno * sizeof(jpeg_scan_info));\n    memcpy(scanptr, scans, scanno * sizeof(jpeg_scan_info));\n    cinfo->scan_info = scanptr;\n    cinfo->num_scans = scanno;\n    \n    /* Disable scan optimization if using custom scan */\n    jpeg_c_set_bool_param(cinfo, JBOOLEAN_OPTIMIZE_SCANS, FALSE);\n  }\n\n  fclose(fp);\n  return TRUE;\n}\n\n#endif /* C_MULTISCAN_FILES_SUPPORTED */\n\n\n#if JPEG_LIB_VERSION < 70\n/* These are the sample quantization tables given in Annex K (Clause K.1) of\n * Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994.\n * The spec says that the values given produce \"good\" quality, and\n * when divided by 2, \"very good\" quality.\n */\nstatic const unsigned int std_luminance_quant_tbl[9][DCTSIZE2] = {\n  {\n    /* JPEG Annex K\n     */\n  16,  11,  10,  16,  24,  40,  51,  61,\n  12,  12,  14,  19,  26,  58,  60,  55,\n  14,  13,  16,  24,  40,  57,  69,  56,\n  14,  17,  22,  29,  51,  87,  80,  62,\n  18,  22,  37,  56,  68, 109, 103,  77,\n  24,  35,  55,  64,  81, 104, 113,  92,\n  49,  64,  78,  87, 103, 121, 120, 101,\n  72,  92,  95,  98, 112, 100, 103,  99\n  },\n  {\n    /* flat\n     */\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16\n  },\n  {\n    12, 17, 20, 21, 30, 34, 56, 63,\n    18, 20, 20, 26, 28, 51, 61, 55,\n    19, 20, 21, 26, 33, 58, 69, 55,\n    26, 26, 26, 30, 46, 87, 86, 66,\n    31, 33, 36, 40, 46, 96, 100, 73,\n    40, 35, 46, 62, 81, 100, 111, 91,\n    46, 66, 76, 86, 102, 121, 120, 101,\n    68, 90, 90, 96, 113, 102, 105, 103\n  },\n  {\n    /* From http://www.imagemagick.org/discourse-server/viewtopic.php?f=22&t=20333&p=98008#p98008\n     */\n    16,  16,  16,  18,  25,  37,  56,  85,\n    16,  17,  20,  27,  34,  40,  53,  75,\n    16,  20,  24,  31,  43,  62,  91,  135,\n    18,  27,  31,  40,  53,  74,  106, 156,\n    25,  34,  43,  53,  69,  94,  131, 189,\n    37,  40,  62,  74,  94,  124, 169, 238,\n    56,  53,  91,  106, 131, 169, 226, 311,\n    85,  75,  135, 156, 189, 238, 311, 418\n  },\n  {\n    9, 10, 12, 14, 27, 32, 51, 62,\n    11, 12, 14, 19, 27, 44, 59, 73,\n    12, 14, 18, 25, 42, 59, 79, 78,\n    17, 18, 25, 42, 61, 92, 87, 92,\n    23, 28, 42, 75, 79, 112, 112, 99,\n    40, 42, 59, 84, 88, 124, 132, 111,\n    42, 64, 78, 95, 105, 126, 125, 99,\n    70, 75, 100, 102, 116, 100, 107, 98\n  },\n  {\n    /* Relevance of human vision to JPEG-DCT compression (1992) Klein, Silverstein and Carney.\n     */\n    10, 12, 14, 19, 26, 38, 57, 86,\n    12, 18, 21, 28, 35, 41, 54, 76,\n    14, 21, 25, 32, 44, 63, 92, 136,\n    19, 28, 32, 41, 54, 75, 107, 157,\n    26, 35, 44, 54, 70, 95, 132, 190,\n    38, 41, 63, 75, 95, 125, 170, 239,\n    57, 54, 92, 107, 132, 170, 227, 312,\n    86, 76, 136, 157, 190, 239, 312, 419\n  },\n  {\n    /* DCTune perceptual optimization of compressed dental X-Rays (1997) Watson, Taylor, Borthwick\n     */\n    7, 8, 10, 14, 23, 44, 95, 241,\n    8, 8, 11, 15, 25, 47, 102, 255,\n    10, 11, 13, 19, 31, 58, 127, 255,\n    14, 15, 19, 27, 44, 83, 181, 255,\n    23, 25, 31, 44, 72, 136, 255, 255,\n    44, 47, 58, 83, 136, 255, 255, 255,\n    95, 102, 127, 181, 255, 255, 255, 255,\n    241, 255, 255, 255, 255, 255, 255, 255\n  },\n  {\n    /* A visual detection model for DCT coefficient quantization (12/9/93) Ahumada, Watson, Peterson\n     */\n    15, 11, 11, 12, 15, 19, 25, 32,\n    11, 13, 10, 10, 12, 15, 19, 24,\n    11, 10, 14, 14, 16, 18, 22, 27,\n    12, 10, 14, 18, 21, 24, 28, 33,\n    15, 12, 16, 21, 26, 31, 36, 42,\n    19, 15, 18, 24, 31, 38, 45, 53,\n    25, 19, 22, 28, 36, 45, 55, 65,\n    32, 24, 27, 33, 42, 53, 65, 77\n  },\n  {\n    /* An improved detection model for DCT coefficient quantization (1993) Peterson, Ahumada and Watson\n     */\n    14, 10, 11, 14, 19, 25, 34, 45,\n    10, 11, 11, 12, 15, 20, 26, 33,\n    11, 11, 15, 18, 21, 25, 31, 38,\n    14, 12, 18, 24, 28, 33, 39, 47,\n    19, 15, 21, 28, 36, 43, 51, 59,\n    25, 20, 25, 33, 43, 54, 64, 74,\n    34, 26, 31, 39, 51, 64, 77, 91,\n    45, 33, 38, 47, 59, 74, 91, 108\n  }\n};\n\nstatic const unsigned int std_chrominance_quant_tbl[9][DCTSIZE2] = {\n  {\n    /* JPEG Annex K\n     */\n  17,  18,  24,  47,  99,  99,  99,  99,\n  18,  21,  26,  66,  99,  99,  99,  99,\n  24,  26,  56,  99,  99,  99,  99,  99,\n  47,  66,  99,  99,  99,  99,  99,  99,\n  99,  99,  99,  99,  99,  99,  99,  99,\n  99,  99,  99,  99,  99,  99,  99,  99,\n  99,  99,  99,  99,  99,  99,  99,  99,\n  99,  99,  99,  99,  99,  99,  99,  99\n  },\n  {\n    /* flat\n     */\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16,\n    16,  16,  16,  16,  16,  16,  16,  16\n  },\n  {\n    8, 12, 15, 15, 86, 96, 96, 98,\n    13, 13, 15, 26, 90, 96, 99, 98,\n    12, 15, 18, 96, 99, 99, 99, 99,\n    17, 16, 90, 96, 99, 99, 99, 99,\n    96, 96, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99\n  },\n  {\n    /* From http://www.imagemagick.org/discourse-server/viewtopic.php?f=22&t=20333&p=98008#p98008\n     */\n    16,  16,  16,  18,  25,  37,  56,  85,\n    16,  17,  20,  27,  34,  40,  53,  75,\n    16,  20,  24,  31,  43,  62,  91,  135,\n    18,  27,  31,  40,  53,  74,  106, 156,\n    25,  34,  43,  53,  69,  94,  131, 189,\n    37,  40,  62,  74,  94,  124, 169, 238,\n    56,  53,  91,  106, 131, 169, 226, 311,\n    85,  75,  135, 156, 189, 238, 311, 418\n  },\n  {\n    9, 10, 17, 19, 62, 89, 91, 97,\n    12, 13, 18, 29, 84, 91, 88, 98,\n    14, 19, 29, 93, 95, 95, 98, 97,\n    20, 26, 84, 88, 95, 95, 98, 94,\n    26, 86, 91, 93, 97, 99, 98, 99,\n    99, 100, 98, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    97, 97, 99, 99, 99, 99, 97, 99\n  },\n  {\n    /* Relevance of human vision to JPEG-DCT compression (1992) Klein, Silverstein and Carney.\n     * Copied from luma\n     */\n    10, 12, 14, 19, 26, 38, 57, 86,\n    12, 18, 21, 28, 35, 41, 54, 76,\n    14, 21, 25, 32, 44, 63, 92, 136,\n    19, 28, 32, 41, 54, 75, 107, 157,\n    26, 35, 44, 54, 70, 95, 132, 190,\n    38, 41, 63, 75, 95, 125, 170, 239,\n    57, 54, 92, 107, 132, 170, 227, 312,\n    86, 76, 136, 157, 190, 239, 312, 419\n  },\n  {\n    /* DCTune perceptual optimization of compressed dental X-Rays (1997) Watson, Taylor, Borthwick\n     * Copied from luma\n     */\n    7, 8, 10, 14, 23, 44, 95, 241,\n    8, 8, 11, 15, 25, 47, 102, 255,\n    10, 11, 13, 19, 31, 58, 127, 255,\n    14, 15, 19, 27, 44, 83, 181, 255,\n    23, 25, 31, 44, 72, 136, 255, 255,\n    44, 47, 58, 83, 136, 255, 255, 255,\n    95, 102, 127, 181, 255, 255, 255, 255,\n    241, 255, 255, 255, 255, 255, 255, 255\n  },\n  {\n    /* A visual detection model for DCT coefficient quantization (12/9/93) Ahumada, Watson, Peterson\n     * Copied from luma\n     */\n    15, 11, 11, 12, 15, 19, 25, 32,\n    11, 13, 10, 10, 12, 15, 19, 24,\n    11, 10, 14, 14, 16, 18, 22, 27,\n    12, 10, 14, 18, 21, 24, 28, 33,\n    15, 12, 16, 21, 26, 31, 36, 42,\n    19, 15, 18, 24, 31, 38, 45, 53,\n    25, 19, 22, 28, 36, 45, 55, 65,\n    32, 24, 27, 33, 42, 53, 65, 77\n  },\n  {\n    /* An improved detection model for DCT coefficient quantization (1993) Peterson, Ahumada and Watson\n     * Copied from luma\n     */\n    14, 10, 11, 14, 19, 25, 34, 45,\n    10, 11, 11, 12, 15, 20, 26, 33,\n    11, 11, 15, 18, 21, 25, 31, 38,\n    14, 12, 18, 24, 28, 33, 39, 47,\n    19, 15, 21, 28, 36, 43, 51, 59,\n    25, 20, 25, 33, 43, 54, 64, 74,\n    34, 26, 31, 39, 51, 64, 77, 91,\n    45, 33, 38, 47, 59, 74, 91, 108\n  }\n};\n\n\nLOCAL(void)\njpeg_default_qtables(j_compress_ptr cinfo, boolean force_baseline)\n{\n  int quant_tbl_master_idx = 0;\n  if (jpeg_c_int_param_supported(cinfo, JINT_BASE_QUANT_TBL_IDX))\n    quant_tbl_master_idx = jpeg_c_get_int_param(cinfo, JINT_BASE_QUANT_TBL_IDX);\n  \n  jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl[quant_tbl_master_idx],\n                       q_scale_factor[0], force_baseline);\n  jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl[quant_tbl_master_idx],\n                       q_scale_factor[1], force_baseline);\n}\n#endif\n\n\nGLOBAL(boolean)\nset_quality_ratings(j_compress_ptr cinfo, char *arg, boolean force_baseline)\n/* Process a quality-ratings parameter string, of the form\n *     N[,N,...]\n * If there are more q-table slots than parameters, the last value is replicated.\n */\n{\n  float val = 75.f;                 /* default value */\n  int tblno;\n  char ch;\n\n  for (tblno = 0; tblno < NUM_QUANT_TBLS; tblno++) {\n    if (*arg) {\n      ch = ',';                 /* if not set by sscanf, will be ',' */\n      if (sscanf(arg, \"%f%c\", &val, &ch) < 1)\n        return FALSE;\n      if (ch != ',')            /* syntax check */\n        return FALSE;\n      /* Convert user 0-100 rating to percentage scaling */\n#if JPEG_LIB_VERSION >= 70\n      cinfo->q_scale_factor[tblno] = jpeg_float_quality_scaling(val);\n#else\n      q_scale_factor[tblno] = jpeg_float_quality_scaling(val);\n#endif\n      while (*arg && *arg++ != ','); /* advance to next segment of arg\n                                        string */\n    } else {\n      /* reached end of parameter, set remaining factors to last value */\n#if JPEG_LIB_VERSION >= 70\n      cinfo->q_scale_factor[tblno] = jpeg_float_quality_scaling(val);\n#else\n      q_scale_factor[tblno] = jpeg_float_quality_scaling(val);\n#endif\n    }\n  }\n  jpeg_default_qtables(cinfo, force_baseline);\n\n  /* For some images chroma subsampling significantly degrades color quality,\n     making it impossible to achieve high visual quality regardless of quality setting.\n     To make the quality setting more intuitive, disable subsampling when high-quality\n     color is desired. */\n  if (val >= 90) {\n    set_sample_factors(cinfo, \"1x1\");\n  } else if (val >= 80) {\n    set_sample_factors(cinfo, \"2x1\");\n  }\n\n  return TRUE;\n}\n\n\nGLOBAL(boolean)\nset_quant_slots(j_compress_ptr cinfo, char *arg)\n/* Process a quantization-table-selectors parameter string, of the form\n *     N[,N,...]\n * If there are more components than parameters, the last value is replicated.\n */\n{\n  int val = 0;                  /* default table # */\n  int ci;\n  char ch;\n\n  for (ci = 0; ci < MAX_COMPONENTS; ci++) {\n    if (*arg) {\n      ch = ',';                 /* if not set by sscanf, will be ',' */\n      if (sscanf(arg, \"%d%c\", &val, &ch) < 1)\n        return FALSE;\n      if (ch != ',')            /* syntax check */\n        return FALSE;\n      if (val < 0 || val >= NUM_QUANT_TBLS) {\n        fprintf(stderr, \"JPEG quantization tables are numbered 0..%d\\n\",\n                NUM_QUANT_TBLS - 1);\n        return FALSE;\n      }\n      cinfo->comp_info[ci].quant_tbl_no = val;\n      while (*arg && *arg++ != ','); /* advance to next segment of arg\n                                        string */\n    } else {\n      /* reached end of parameter, set remaining components to last table */\n      cinfo->comp_info[ci].quant_tbl_no = val;\n    }\n  }\n  return TRUE;\n}\n\n\nGLOBAL(boolean)\nset_sample_factors(j_compress_ptr cinfo, char *arg)\n/* Process a sample-factors parameter string, of the form\n *     HxV[,HxV,...]\n * If there are more components than parameters, \"1x1\" is assumed for the rest.\n */\n{\n  int ci, val1, val2;\n  char ch1, ch2;\n\n  for (ci = 0; ci < MAX_COMPONENTS; ci++) {\n    if (*arg) {\n      ch2 = ',';                /* if not set by sscanf, will be ',' */\n      if (sscanf(arg, \"%d%c%d%c\", &val1, &ch1, &val2, &ch2) < 3)\n        return FALSE;\n      if ((ch1 != 'x' && ch1 != 'X') || ch2 != ',') /* syntax check */\n        return FALSE;\n      if (val1 <= 0 || val1 > 4 || val2 <= 0 || val2 > 4) {\n        fprintf(stderr, \"JPEG sampling factors must be 1..4\\n\");\n        return FALSE;\n      }\n      cinfo->comp_info[ci].h_samp_factor = val1;\n      cinfo->comp_info[ci].v_samp_factor = val2;\n      while (*arg && *arg++ != ',');  /* advance to next segment of arg\n                                         string */\n    } else {\n      /* reached end of parameter, set remaining components to 1x1 sampling */\n      cinfo->comp_info[ci].h_samp_factor = 1;\n      cinfo->comp_info[ci].v_samp_factor = 1;\n    }\n  }\n  return TRUE;\n}\n"
        },
        {
          "name": "rdtarga.c",
          "type": "blob",
          "size": 15.1318359375,
          "content": "/*\n * rdtarga.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * Modified 2017 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2018, 2021-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to read input images in Targa format.\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume input from\n * an ordinary stdio stream.  They further assume that reading begins\n * at the start of the file; start_input may need work if the\n * user interface has already read some data (e.g., to determine that\n * the file is indeed Targa format).\n *\n * Based on code contributed by Lee Daniel Crocker.\n */\n\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n\n#ifdef TARGA_SUPPORTED\n\n\n/* Macros to deal with unsigned chars as efficiently as compiler allows */\n\ntypedef unsigned char U_CHAR;\n#define UCH(x)  ((int)(x))\n\n\n#define ReadOK(file, buffer, len) \\\n  (fread(buffer, 1, len, file) == ((size_t)(len)))\n\n\n/* Private version of data source object */\n\ntypedef struct _tga_source_struct *tga_source_ptr;\n\ntypedef struct _tga_source_struct {\n  struct cjpeg_source_struct pub; /* public fields */\n\n  j_compress_ptr cinfo;         /* back link saves passing separate parm */\n\n  JSAMPARRAY colormap;          /* Targa colormap (converted to my format) */\n\n  jvirt_sarray_ptr whole_image; /* Needed if funny input row order */\n  JDIMENSION current_row;       /* Current logical row number to read */\n\n  /* Pointer to routine to extract next Targa pixel from input file */\n  void (*read_pixel) (tga_source_ptr sinfo);\n\n  /* Result of read_pixel is delivered here: */\n  U_CHAR tga_pixel[4];\n\n  int pixel_size;               /* Bytes per Targa pixel (1 to 4) */\n  int cmap_length;              /* colormap length */\n\n  /* State info for reading RLE-coded pixels; both counts must be init to 0 */\n  int block_count;              /* # of pixels remaining in RLE block */\n  int dup_pixel_count;          /* # of times to duplicate previous pixel */\n\n  /* This saves the correct pixel-row-expansion method for preload_image */\n  JDIMENSION (*get_pixel_rows) (j_compress_ptr cinfo, cjpeg_source_ptr sinfo);\n} tga_source_struct;\n\n\n/* For expanding 5-bit pixel values to 8-bit with best rounding */\n\nstatic const UINT8 c5to8bits[32] = {\n    0,   8,  16,  25,  33,  41,  49,  58,\n   66,  74,  82,  90,  99, 107, 115, 123,\n  132, 140, 148, 156, 165, 173, 181, 189,\n  197, 206, 214, 222, 230, 239, 247, 255\n};\n\n\n\nLOCAL(int)\nread_byte(tga_source_ptr sinfo)\n/* Read next byte from Targa file */\n{\n  register FILE *infile = sinfo->pub.input_file;\n  register int c;\n\n  if ((c = getc(infile)) == EOF)\n    ERREXIT(sinfo->cinfo, JERR_INPUT_EOF);\n  return c;\n}\n\n\nLOCAL(void)\nread_colormap(tga_source_ptr sinfo, int cmaplen, int mapentrysize)\n/* Read the colormap from a Targa file */\n{\n  int i;\n\n  /* Presently only handles 24-bit BGR format */\n  if (mapentrysize != 24)\n    ERREXIT(sinfo->cinfo, JERR_TGA_BADCMAP);\n\n  for (i = 0; i < cmaplen; i++) {\n    sinfo->colormap[2][i] = (JSAMPLE)read_byte(sinfo);\n    sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);\n    sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);\n  }\n}\n\n\n/*\n * read_pixel methods: get a single pixel from Targa file into tga_pixel[]\n */\n\nMETHODDEF(void)\nread_non_rle_pixel(tga_source_ptr sinfo)\n/* Read one Targa pixel from the input file; no RLE expansion */\n{\n  register int i;\n\n  for (i = 0; i < sinfo->pixel_size; i++) {\n    sinfo->tga_pixel[i] = (U_CHAR)read_byte(sinfo);\n  }\n}\n\n\nMETHODDEF(void)\nread_rle_pixel(tga_source_ptr sinfo)\n/* Read one Targa pixel from the input file, expanding RLE data as needed */\n{\n  register int i;\n\n  /* Duplicate previously read pixel? */\n  if (sinfo->dup_pixel_count > 0) {\n    sinfo->dup_pixel_count--;\n    return;\n  }\n\n  /* Time to read RLE block header? */\n  if (--sinfo->block_count < 0) { /* decrement pixels remaining in block */\n    i = read_byte(sinfo);\n    if (i & 0x80) {             /* Start of duplicate-pixel block? */\n      sinfo->dup_pixel_count = i & 0x7F; /* number of dups after this one */\n      sinfo->block_count = 0;   /* then read new block header */\n    } else {\n      sinfo->block_count = i & 0x7F; /* number of pixels after this one */\n    }\n  }\n\n  /* Read next pixel */\n  for (i = 0; i < sinfo->pixel_size; i++) {\n    sinfo->tga_pixel[i] = (U_CHAR)read_byte(sinfo);\n  }\n}\n\n\n/*\n * Read one row of pixels.\n *\n * We provide several different versions depending on input file format.\n */\n\n\nMETHODDEF(JDIMENSION)\nget_8bit_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 8-bit grayscale pixels */\n{\n  tga_source_ptr source = (tga_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register JDIMENSION col;\n\n  ptr = source->pub.buffer[0];\n  for (col = cinfo->image_width; col > 0; col--) {\n    (*source->read_pixel) (source); /* Load next pixel into tga_pixel */\n    *ptr++ = (JSAMPLE)UCH(source->tga_pixel[0]);\n  }\n  return 1;\n}\n\nMETHODDEF(JDIMENSION)\nget_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 8-bit colormap indexes */\n{\n  tga_source_ptr source = (tga_source_ptr)sinfo;\n  register int t;\n  register JSAMPROW ptr;\n  register JDIMENSION col;\n  register JSAMPARRAY colormap = source->colormap;\n  int cmaplen = source->cmap_length;\n\n  ptr = source->pub.buffer[0];\n  for (col = cinfo->image_width; col > 0; col--) {\n    (*source->read_pixel) (source); /* Load next pixel into tga_pixel */\n    t = UCH(source->tga_pixel[0]);\n    if (t >= cmaplen)\n      ERREXIT(cinfo, JERR_TGA_BADPARMS);\n    *ptr++ = colormap[0][t];\n    *ptr++ = colormap[1][t];\n    *ptr++ = colormap[2][t];\n  }\n  return 1;\n}\n\nMETHODDEF(JDIMENSION)\nget_16bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 16-bit pixels */\n{\n  tga_source_ptr source = (tga_source_ptr)sinfo;\n  register int t;\n  register JSAMPROW ptr;\n  register JDIMENSION col;\n\n  ptr = source->pub.buffer[0];\n  for (col = cinfo->image_width; col > 0; col--) {\n    (*source->read_pixel) (source); /* Load next pixel into tga_pixel */\n    t = UCH(source->tga_pixel[0]);\n    t += UCH(source->tga_pixel[1]) << 8;\n    /* We expand 5 bit data to 8 bit sample width.\n     * The format of the 16-bit (LSB first) input word is\n     *     xRRRRRGGGGGBBBBB\n     */\n    ptr[2] = (JSAMPLE)c5to8bits[t & 0x1F];\n    t >>= 5;\n    ptr[1] = (JSAMPLE)c5to8bits[t & 0x1F];\n    t >>= 5;\n    ptr[0] = (JSAMPLE)c5to8bits[t & 0x1F];\n    ptr += 3;\n  }\n  return 1;\n}\n\nMETHODDEF(JDIMENSION)\nget_24bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading 24-bit pixels */\n{\n  tga_source_ptr source = (tga_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register JDIMENSION col;\n\n  ptr = source->pub.buffer[0];\n  for (col = cinfo->image_width; col > 0; col--) {\n    (*source->read_pixel) (source); /* Load next pixel into tga_pixel */\n    *ptr++ = (JSAMPLE)UCH(source->tga_pixel[2]); /* change BGR to RGB order */\n    *ptr++ = (JSAMPLE)UCH(source->tga_pixel[1]);\n    *ptr++ = (JSAMPLE)UCH(source->tga_pixel[0]);\n  }\n  return 1;\n}\n\n/*\n * Targa also defines a 32-bit pixel format with order B,G,R,A.\n * We presently ignore the attribute byte, so the code for reading\n * these pixels is identical to the 24-bit routine above.\n * This works because the actual pixel length is only known to read_pixel.\n */\n\n#define get_32bit_row  get_24bit_row\n\n\n/*\n * This method is for re-reading the input data in standard top-down\n * row order.  The entire image has already been read into whole_image\n * with proper conversion of pixel format, but it's in a funny row order.\n */\n\nMETHODDEF(JDIMENSION)\nget_memory_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  tga_source_ptr source = (tga_source_ptr)sinfo;\n  JDIMENSION source_row;\n\n  /* Compute row of source that maps to current_row of normal order */\n  /* For now, assume image is bottom-up and not interlaced. */\n  /* NEEDS WORK to support interlaced images! */\n  source_row = cinfo->image_height - source->current_row - 1;\n\n  /* Fetch that row from virtual array */\n  source->pub.buffer = (*cinfo->mem->access_virt_sarray)\n    ((j_common_ptr)cinfo, source->whole_image,\n     source_row, (JDIMENSION)1, FALSE);\n\n  source->current_row++;\n  return 1;\n}\n\n\n/*\n * This method loads the image into whole_image during the first call on\n * get_pixel_rows.  The get_pixel_rows pointer is then adjusted to call\n * get_memory_row on subsequent calls.\n */\n\nMETHODDEF(JDIMENSION)\npreload_image(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  tga_source_ptr source = (tga_source_ptr)sinfo;\n  JDIMENSION row;\n  cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n\n  /* Read the data into a virtual array in input-file row order. */\n  for (row = 0; row < cinfo->image_height; row++) {\n    if (progress != NULL) {\n      progress->pub.pass_counter = (long)row;\n      progress->pub.pass_limit = (long)cinfo->image_height;\n      (*progress->pub.progress_monitor) ((j_common_ptr)cinfo);\n    }\n    source->pub.buffer = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image, row, (JDIMENSION)1, TRUE);\n    (*source->get_pixel_rows) (cinfo, sinfo);\n  }\n  if (progress != NULL)\n    progress->completed_extra_passes++;\n\n  /* Set up to read from the virtual array in unscrambled order */\n  source->pub.get_pixel_rows = get_memory_row;\n  source->current_row = 0;\n  /* And read the first row */\n  return get_memory_row(cinfo, sinfo);\n}\n\n\n/*\n * Read the file header; return image size and component count.\n */\n\nMETHODDEF(void)\nstart_input_tga(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  tga_source_ptr source = (tga_source_ptr)sinfo;\n  U_CHAR targaheader[18];\n  int idlen, cmaptype, subtype, flags, interlace_type, components;\n  unsigned int width, height, maplen;\n  boolean is_bottom_up;\n\n#define GET_2B(offset) \\\n  ((unsigned int)UCH(targaheader[offset]) + \\\n   (((unsigned int)UCH(targaheader[offset + 1])) << 8))\n\n  if (!ReadOK(source->pub.input_file, targaheader, 18))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n\n  /* Pretend \"15-bit\" pixels are 16-bit --- we ignore attribute bit anyway */\n  if (targaheader[16] == 15)\n    targaheader[16] = 16;\n\n  idlen = UCH(targaheader[0]);\n  cmaptype = UCH(targaheader[1]);\n  subtype = UCH(targaheader[2]);\n  maplen = GET_2B(5);\n  width = GET_2B(12);\n  height = GET_2B(14);\n  source->pixel_size = UCH(targaheader[16]) >> 3;\n  flags = UCH(targaheader[17]); /* Image Descriptor byte */\n\n  is_bottom_up = ((flags & 0x20) == 0); /* bit 5 set => top-down */\n  interlace_type = flags >> 6;  /* bits 6/7 are interlace code */\n\n  if (cmaptype > 1 ||           /* cmaptype must be 0 or 1 */\n      source->pixel_size < 1 || source->pixel_size > 4 ||\n      (UCH(targaheader[16]) & 7) != 0 || /* bits/pixel must be multiple of 8 */\n      interlace_type != 0 ||      /* currently don't allow interlaced image */\n      width == 0 || height == 0)  /* image width/height must be non-zero */\n    ERREXIT(cinfo, JERR_TGA_BADPARMS);\n  if (sinfo->max_pixels &&\n      (unsigned long long)width * height > sinfo->max_pixels)\n    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, sinfo->max_pixels);\n\n  if (subtype > 8) {\n    /* It's an RLE-coded file */\n    source->read_pixel = read_rle_pixel;\n    source->block_count = source->dup_pixel_count = 0;\n    subtype -= 8;\n  } else {\n    /* Non-RLE file */\n    source->read_pixel = read_non_rle_pixel;\n  }\n\n  /* Now should have subtype 1, 2, or 3 */\n  components = 3;               /* until proven different */\n  cinfo->in_color_space = JCS_RGB;\n\n  switch (subtype) {\n  case 1:                       /* Colormapped image */\n    if (source->pixel_size == 1 && cmaptype == 1)\n      source->get_pixel_rows = get_8bit_row;\n    else\n      ERREXIT(cinfo, JERR_TGA_BADPARMS);\n    TRACEMS2(cinfo, 1, JTRC_TGA_MAPPED, width, height);\n    break;\n  case 2:                       /* RGB image */\n    switch (source->pixel_size) {\n    case 2:\n      source->get_pixel_rows = get_16bit_row;\n      break;\n    case 3:\n      source->get_pixel_rows = get_24bit_row;\n      break;\n    case 4:\n      source->get_pixel_rows = get_32bit_row;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_TGA_BADPARMS);\n      break;\n    }\n    TRACEMS2(cinfo, 1, JTRC_TGA, width, height);\n    break;\n  case 3:                       /* Grayscale image */\n    components = 1;\n    cinfo->in_color_space = JCS_GRAYSCALE;\n    if (source->pixel_size == 1)\n      source->get_pixel_rows = get_8bit_gray_row;\n    else\n      ERREXIT(cinfo, JERR_TGA_BADPARMS);\n    TRACEMS2(cinfo, 1, JTRC_TGA_GRAY, width, height);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_TGA_BADPARMS);\n    break;\n  }\n\n  if (is_bottom_up) {\n    /* Create a virtual array to buffer the upside-down image. */\n    source->whole_image = (*cinfo->mem->request_virt_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n       (JDIMENSION)width * components, (JDIMENSION)height, (JDIMENSION)1);\n    if (cinfo->progress != NULL) {\n      cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n      progress->total_extra_passes++; /* count file input as separate pass */\n    }\n    /* source->pub.buffer will point to the virtual array. */\n    source->pub.buffer_height = 1; /* in case anyone looks at it */\n    source->pub.get_pixel_rows = preload_image;\n  } else {\n    /* Don't need a virtual array, but do need a one-row input buffer. */\n    source->whole_image = NULL;\n    source->pub.buffer = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       (JDIMENSION)width * components, (JDIMENSION)1);\n    source->pub.buffer_height = 1;\n    source->pub.get_pixel_rows = source->get_pixel_rows;\n  }\n\n  while (idlen--)               /* Throw away ID field */\n    (void)read_byte(source);\n\n  if (maplen > 0) {\n    if (maplen > 256 || GET_2B(3) != 0)\n      ERREXIT(cinfo, JERR_TGA_BADCMAP);\n    /* Allocate space to store the colormap */\n    source->colormap = (*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)maplen, (JDIMENSION)3);\n    source->cmap_length = (int)maplen;\n    /* and read it from the file */\n    read_colormap(source, (int)maplen, UCH(targaheader[7]));\n  } else {\n    if (cmaptype)               /* but you promised a cmap! */\n      ERREXIT(cinfo, JERR_TGA_BADPARMS);\n    source->colormap = NULL;\n    source->cmap_length = 0;\n  }\n\n  cinfo->input_components = components;\n  cinfo->data_precision = 8;\n  cinfo->image_width = width;\n  cinfo->image_height = height;\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_input_tga(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  /* no work */\n}\n\n\n/*\n * The module selection routine for Targa format input.\n */\n\nGLOBAL(cjpeg_source_ptr)\njinit_read_targa(j_compress_ptr cinfo)\n{\n  tga_source_ptr source;\n\n  if (cinfo->data_precision != 8)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Create module interface object */\n  source = (tga_source_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(tga_source_struct));\n  source->cinfo = cinfo;        /* make back link for subroutines */\n  /* Fill in method ptrs, except get_pixel_rows which start_input sets */\n  source->pub.start_input = start_input_tga;\n  source->pub.finish_input = finish_input_tga;\n  source->pub.max_pixels = 0;\n\n  return (cjpeg_source_ptr)source;\n}\n\n#endif /* TARGA_SUPPORTED */\n"
        },
        {
          "name": "release",
          "type": "tree",
          "content": null
        },
        {
          "name": "sharedlib",
          "type": "tree",
          "content": null
        },
        {
          "name": "simd",
          "type": "tree",
          "content": null
        },
        {
          "name": "strtest.c",
          "type": "blob",
          "size": 4.505859375,
          "content": "/*\n * Copyright (C)2022-2023 D. R. Commander.  All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"jinclude.h\"\n#include <errno.h>\n\n\n#define CHECK_VALUE(actual, expected, desc) \\\n  if (actual != expected) { \\\n    printf(\"ERROR in line %d: \" desc \" is %d, should be %d\\n\", \\\n           __LINE__, actual, expected); \\\n    return -1; \\\n  }\n\n#define CHECK_ERRNO(errno_return, expected_errno) \\\n  CHECK_VALUE(errno_return, expected_errno, \"Return value\") \\\n  CHECK_VALUE(errno, expected_errno, \"errno\") \\\n\n\n#ifdef _MSC_VER\n\nvoid invalid_parameter_handler(const wchar_t *expression,\n                               const wchar_t *function, const wchar_t *file,\n                               unsigned int line, uintptr_t pReserved)\n{\n}\n\n#endif\n\n\nint main(int argc, char **argv)\n{\n#if !defined(NO_GETENV) || !defined(NO_PUTENV)\n  int err;\n#endif\n#ifndef NO_GETENV\n  char env[3];\n#endif\n\n#ifdef _MSC_VER\n  _set_invalid_parameter_handler(invalid_parameter_handler);\n#endif\n\n  /***************************************************************************/\n\n#ifndef NO_PUTENV\n\n  printf(\"PUTENV_S():\\n\");\n\n  errno = 0;\n  err = PUTENV_S(NULL, \"12\");\n  CHECK_ERRNO(err, EINVAL);\n\n  errno = 0;\n  err = PUTENV_S(\"TESTENV\", NULL);\n  CHECK_ERRNO(err, EINVAL);\n\n  errno = 0;\n  err = PUTENV_S(\"TESTENV\", \"12\");\n  CHECK_ERRNO(err, 0);\n\n  printf(\"SUCCESS!\\n\\n\");\n\n#endif\n\n  /***************************************************************************/\n\n#ifndef NO_GETENV\n\n  printf(\"GETENV_S():\\n\");\n\n  errno = 0;\n  env[0] = 1;\n  env[1] = 2;\n  env[2] = 3;\n  err = GETENV_S(env, 3, NULL);\n  CHECK_ERRNO(err, 0);\n  CHECK_VALUE(env[0], 0, \"env[0]\");\n  CHECK_VALUE(env[1], 2, \"env[1]\");\n  CHECK_VALUE(env[2], 3, \"env[2]\");\n\n  errno = 0;\n  env[0] = 1;\n  env[1] = 2;\n  env[2] = 3;\n  err = GETENV_S(env, 3, \"TESTENV2\");\n  CHECK_ERRNO(err, 0);\n  CHECK_VALUE(env[0], 0, \"env[0]\");\n  CHECK_VALUE(env[1], 2, \"env[1]\");\n  CHECK_VALUE(env[2], 3, \"env[2]\");\n\n  errno = 0;\n  err = GETENV_S(NULL, 3, \"TESTENV\");\n  CHECK_ERRNO(err, EINVAL);\n\n  errno = 0;\n  err = GETENV_S(NULL, 0, \"TESTENV\");\n  CHECK_ERRNO(err, 0);\n\n  errno = 0;\n  env[0] = 1;\n  err = GETENV_S(env, 0, \"TESTENV\");\n  CHECK_ERRNO(err, EINVAL);\n  CHECK_VALUE(env[0], 1, \"env[0]\");\n\n  errno = 0;\n  env[0] = 1;\n  env[1] = 2;\n  env[2] = 3;\n  err = GETENV_S(env, 1, \"TESTENV\");\n  CHECK_VALUE(err, ERANGE, \"Return value\");\n  CHECK_VALUE(errno, 0, \"errno\");\n  CHECK_VALUE(env[0], 0, \"env[0]\");\n  CHECK_VALUE(env[1], 2, \"env[1]\");\n  CHECK_VALUE(env[2], 3, \"env[2]\");\n\n  errno = 0;\n  env[0] = 1;\n  env[1] = 2;\n  env[2] = 3;\n  err = GETENV_S(env, 2, \"TESTENV\");\n  CHECK_VALUE(err, ERANGE, \"Return value\");\n  CHECK_VALUE(errno, 0, \"errno\");\n  CHECK_VALUE(env[0], 0, \"env[0]\");\n  CHECK_VALUE(env[1], 2, \"env[1]\");\n  CHECK_VALUE(env[2], 3, \"env[2]\");\n\n  errno = 0;\n  env[0] = 1;\n  env[1] = 2;\n  env[2] = 3;\n  err = GETENV_S(env, 3, \"TESTENV\");\n  CHECK_ERRNO(err, 0);\n  CHECK_VALUE(env[0], '1', \"env[0]\");\n  CHECK_VALUE(env[1], '2', \"env[1]\");\n  CHECK_VALUE(env[2], 0, \"env[2]\");\n\n  printf(\"SUCCESS!\\n\\n\");\n\n#endif\n\n  /***************************************************************************/\n\n  return 0;\n}\n"
        },
        {
          "name": "structure.txt",
          "type": "blob",
          "size": 52.1474609375,
          "content": "IJG JPEG LIBRARY:  SYSTEM ARCHITECTURE\n\nThis file was part of the Independent JPEG Group's software:\nCopyright (C) 1991-2012, Thomas G. Lane, Guido Vollbeding.\nLossless JPEG Modifications:\nCopyright (C) 1999, Ken Murchison.\nlibjpeg-turbo Modifications:\nCopyright (C) 2022-2023, D. R. Commander.\nFor conditions of distribution and use, see the accompanying README.ijg file.\n\n\nThis file provides an overview of the architecture of the IJG JPEG software;\nthat is, the functions of the various modules in the system and the interfaces\nbetween modules.  For more precise details about any data structure or calling\nconvention, see the include files and comments in the source code.\n\nWe assume that the reader is already somewhat familiar with the JPEG standard.\nThe README.ijg file includes references for learning about JPEG.  The file\nlibjpeg.txt describes the library from the viewpoint of an application\nprogrammer using the library; it's best to read that file before this one.\nAlso, the file coderules.txt describes the coding style conventions we use.\n\nIn this document, JPEG-specific terminology follows the JPEG standard:\n  A \"component\" means a color channel, e.g., Red or Luminance.\n  A \"sample\" is a single component value (i.e., one number in the image data).\n  A \"coefficient\" is a frequency coefficient (a DCT transform output number).\n  A \"block\" is an 8x8 group of samples or coefficients.\n  A \"data unit\" is an abstract data type that is either a block for lossy\n        (DCT-based) codecs or a sample for lossless (predictive) codecs.\n  An \"MCU\" (minimum coded unit) is an interleaved set of data units of size\n        determined by the sampling factors, or a single data unit in a\n        noninterleaved scan.\nWe do not use the terms \"pixel\" and \"sample\" interchangeably.  When we say\npixel, we mean an element of the full-size image, while a sample is an element\nof the downsampled image.  Thus the number of samples may vary across\ncomponents while the number of pixels does not.  (This terminology is not used\nrigorously throughout the code, but it is used in places where confusion would\notherwise result.)\n\n\n*** System features ***\n\nThe IJG distribution contains two parts:\n  * A subroutine library for JPEG compression and decompression.\n  * cjpeg/djpeg, two sample applications that use the library to transform\n    JFIF JPEG files to and from several other image formats.\ncjpeg/djpeg are of no great intellectual complexity: they merely add a simple\ncommand-line user interface and I/O routines for several uncompressed image\nformats.  This document concentrates on the library itself.\n\nWe desire the library to be capable of supporting all JPEG baseline, extended\nsequential, progressive DCT, and lossless (spatial) processes.  Hierarchical\nprocesses are not supported.\n\nWithin these limits, any set of compression parameters allowed by the JPEG\nspec should be readable for decompression.  (We can be more restrictive about\nwhat formats we can generate.)  Although the system design allows for all\nparameter values, some uncommon settings are not yet implemented and may\nnever be; nonintegral sampling ratios are the prime example.\n\nBy itself, the library handles only interchange JPEG datastreams --- in\nparticular the widely used JFIF file format.  The library can be used by\nsurrounding code to process interchange or abbreviated JPEG datastreams that\nare embedded in more complex file formats.  (For example, libtiff uses this\nlibrary to implement JPEG compression within the TIFF file format.)\n\nThe library includes a substantial amount of code that is not covered by the\nJPEG standard but is necessary for typical applications of JPEG.  These\nfunctions preprocess the image before JPEG compression or postprocess it after\ndecompression.  They include colorspace conversion, downsampling/upsampling,\nand color quantization.  This code can be omitted if not needed.\n\nA wide range of quality vs. speed tradeoffs are possible in JPEG processing,\nand even more so in decompression postprocessing.  The decompression library\nprovides multiple implementations that cover most of the useful tradeoffs,\nranging from very-high-quality down to fast-preview operation.  On the\ncompression side we have generally not provided low-quality choices, since\ncompression is normally less time-critical.  It should be understood that the\nlow-quality modes may not meet the JPEG standard's accuracy requirements;\nnonetheless, they are useful for viewers.\n\n\n*** System overview ***\n\nThe compressor and decompressor are each divided into two main sections:\nthe JPEG compressor or decompressor proper, and the preprocessing or\npostprocessing functions.  The interface between these two sections is the\nimage data that Rec. ITU-T T.81 | ISO/IEC 10918-1 regards as its input or\noutput: this data is in the colorspace to be used for compression, and it is\ndownsampled to the sampling factors to be used.  The preprocessing and\npostprocessing steps are responsible for converting a normal image\nrepresentation to or from this form.  (Those few applications that want to deal\nwith YCbCr downsampled data can skip the preprocessing or postprocessing step.)\n\nLooking more closely, the compressor library contains the following main\nelements:\n\n  Preprocessing:\n    * Color space conversion (e.g., RGB to YCbCr).\n    * Edge expansion and downsampling.  Optionally, this step can do simple\n      smoothing --- this is often helpful for low-quality source data.\n  Lossy JPEG proper:\n    * MCU assembly, DCT, quantization.\n    * Entropy coding (sequential or progressive, Huffman or arithmetic).\n  Lossless JPEG proper:\n    * Point transform.\n    * Prediction, differencing.\n    * Entropy coding (Huffman or arithmetic)\n\nIn addition to these modules we need overall control, marker generation,\nand support code (memory management & error handling).  There is also a\nmodule responsible for physically writing the output data --- typically\nthis is just an interface to fwrite(), but some applications may need to\ndo something else with the data.\n\nThe decompressor library contains the following main elements:\n\n  Lossy JPEG proper:\n    * Entropy decoding (sequential or progressive, Huffman or arithmetic).\n    * Dequantization, inverse DCT, MCU disassembly.\n  Lossless JPEG proper:\n    * Entropy decoding (Huffman or arithmetic).\n    * Prediction, undifferencing.\n    * Point transform, sample size scaling.\n  Postprocessing:\n    * Upsampling.  Optionally, this step may be able to do more general\n      rescaling of the image.\n    * Color space conversion (e.g., YCbCr to RGB).  This step may also\n      provide gamma adjustment [ currently it does not ].\n    * Optional color quantization (e.g., reduction to 256 colors).\n    * Optional color precision reduction (e.g., 24-bit to 15-bit color).\n      [This feature is not currently implemented.]\n\nWe also need overall control, marker parsing, and a data source module.\nThe support code (memory management & error handling) can be shared with\nthe compression half of the library.\n\nThere may be several implementations of each of these elements, particularly\nin the decompressor, where a wide range of speed/quality tradeoffs is very\nuseful.  It must be understood that some of the best speedups involve\nmerging adjacent steps in the pipeline.  For example, upsampling, color space\nconversion, and color quantization might all be done at once when using a\nlow-quality ordered-dither technique.  The system architecture is designed to\nallow such merging where appropriate.\n\n\nNote: it is convenient to regard edge expansion (padding to block boundaries)\nas a preprocessing/postprocessing function, even though\nRec. ITU-T T.81 | ISO/IEC 10918-1 includes it in compression/decompression.  We\ndo this because downsampling/upsampling can be simplified a little if they work\non padded data: it's not necessary to have special cases at the right and\nbottom edges.  Therefore the interface buffer is always an integral number of\nblocks wide and high, and we expect compression preprocessing to pad the source\ndata properly.  Padding will occur only to the next block (8-sample) boundary.\nIn an interleaved-scan situation, additional dummy blocks may be used to fill\nout MCUs, but the MCU assembly and disassembly logic will create or discard\nthese blocks internally.  (This is advantageous for speed reasons, since we\navoid DCTing the dummy blocks.  It also permits a small reduction in file size,\nbecause the compressor can choose dummy block contents so as to minimize their\nsize in compressed form.  Finally, it makes the interface buffer specification\nindependent of whether the file is actually interleaved or not.)  Applications\nthat wish to deal directly with the downsampled data must provide similar\nbuffering and padding for odd-sized images.\n\n\n*** Poor man's object-oriented programming ***\n\nIt should be clear by now that we have a lot of quasi-independent processing\nsteps, many of which have several possible behaviors.  To avoid cluttering the\ncode with lots of switch statements, we use a simple form of object-style\nprogramming to separate out the different possibilities.\n\nFor example, two different color quantization algorithms could be implemented\nas two separate modules that present the same external interface; at runtime,\nthe calling code will access the proper module indirectly through an \"object\".\n\nWe can get the limited features we need while staying within portable C.\nThe basic tool is a function pointer.  An \"object\" is just a struct\ncontaining one or more function pointer fields, each of which corresponds to\na method name in real object-oriented languages.  During initialization we\nfill in the function pointers with references to whichever module we have\ndetermined we need to use in this run.  Then invocation of the module is done\nby indirecting through a function pointer; on most machines this is no more\nexpensive than a switch statement, which would be the only other way of\nmaking the required run-time choice.  The really significant benefit, of\ncourse, is keeping the source code clean and well structured.\n\nWe can also arrange to have private storage that varies between different\nimplementations of the same kind of object.  We do this by making all the\nmodule-specific object structs be separately allocated entities, which will\nbe accessed via pointers in the master compression or decompression struct.\nThe \"public\" fields or methods for a given kind of object are specified by\na commonly known struct.  But a module's initialization code can allocate\na larger struct that contains the common struct as its first member, plus\nadditional private fields.  With appropriate pointer casting, the module's\ninternal functions can access these private fields.  (For a simple example,\nsee jdatadst.c, which implements the external interface specified by struct\njpeg_destination_mgr, but adds extra fields.)\n\n(Of course this would all be a lot easier if we were using C++, but we are\nnot yet prepared to assume that everyone has a C++ compiler.)\n\nAn important benefit of this scheme is that it is easy to provide multiple\nversions of any method, each tuned to a particular case.  While a lot of\nprecalculation might be done to select an optimal implementation of a method,\nthe cost per invocation is constant.  For example, the upsampling step might\nhave a \"generic\" method, plus one or more \"hardwired\" methods for the most\npopular sampling factors; the hardwired methods would be faster because they'd\nuse straight-line code instead of for-loops.  The cost to determine which\nmethod to use is paid only once, at startup, and the selection criteria are\nhidden from the callers of the method.\n\nThis plan differs a little bit from usual object-oriented structures, in that\nonly one instance of each object class will exist during execution.  The\nreason for having the class structure is that on different runs we may create\ndifferent instances (choose to execute different modules).  You can think of\nthe term \"method\" as denoting the common interface presented by a particular\nset of interchangeable functions, and \"object\" as denoting a group of related\nmethods, or the total shared interface behavior of a group of modules.\n\n\n*** Overall control structure ***\n\nWe previously mentioned the need for overall control logic in the compression\nand decompression libraries.  In IJG implementations prior to v5, overall\ncontrol was mostly provided by \"pipeline control\" modules, which proved to be\nlarge, unwieldy, and hard to understand.  To improve the situation, the\ncontrol logic has been subdivided into multiple modules.  The control modules\nconsist of:\n\n1. Master control for module selection and initialization.  This has two\nresponsibilities:\n\n   1A.  Startup initialization at the beginning of image processing.\n        The individual processing modules to be used in this run are selected\n        and given initialization calls.\n\n   1B.  Per-pass control.  This determines how many passes will be performed\n        and calls each active processing module to configure itself\n        appropriately at the beginning of each pass.  End-of-pass processing,\n        where necessary, is also invoked from the master control module.\n\n   Method selection is partially distributed, in that a particular processing\n   module may contain several possible implementations of a particular method,\n   which it will select among when given its initialization call.  The master\n   control code need only be concerned with decisions that affect more than\n   one module.\n\n2. Data buffering control.  A separate control module exists for each\n   inter-processing-step data buffer.  This module is responsible for\n   invoking the processing steps that write or read that data buffer.\n\nEach buffer controller sees the world as follows:\n\ninput data => processing step A => buffer => processing step B => output data\n                      |              |               |\n              ------------------ controller ------------------\n\nThe controller knows the dataflow requirements of steps A and B: how much data\nthey want to accept in one chunk and how much they output in one chunk.  Its\nfunction is to manage its buffer and call A and B at the proper times.\n\nA data buffer control module may itself be viewed as a processing step by a\nhigher-level control module; thus the control modules form a binary tree with\nelementary processing steps at the leaves of the tree.\n\nThe control modules are objects.  A considerable amount of flexibility can\nbe had by replacing implementations of a control module.  For example:\n* Merging of adjacent steps in the pipeline is done by replacing a control\n  module and its pair of processing-step modules with a single processing-\n  step module.  (Hence the possible merges are determined by the tree of\n  control modules.)\n* In some processing modes, a given interstep buffer need only be a \"strip\"\n  buffer large enough to accommodate the desired data chunk sizes.  In other\n  modes, a full-image buffer is needed and several passes are required.\n  The control module determines which kind of buffer is used and manipulates\n  virtual array buffers as needed.  One or both processing steps may be\n  unaware of the multi-pass behavior.\n\nIn theory, we might be able to make all of the data buffer controllers\ninterchangeable and provide just one set of implementations for all.  In\npractice, each one contains considerable special-case processing for its\nparticular job.  The buffer controller concept should be regarded as an\noverall system structuring principle, not as a complete description of the\ntask performed by any one controller.\n\n\n*** Compression object structure ***\n\nHere is a sketch of the logical structure of the JPEG compression library in\nlossy mode:\n\n                                                 |-- Colorspace conversion\n                  |-- Preprocessing controller --|\n                  |                              |-- Downsampling\nMain controller --|\n                  |                            |-- Forward DCT, quantize\n                  |-- Coefficient controller --|\n                                               |-- Entropy encoding\n\n... and in lossless mode:\n\n                                                 |-- Colorspace conversion\n                  |-- Preprocessing controller --|\n                  |                              |-- Downsampling\nMain controller --|\n                  |                           |-- Point transform\n                  |                           |\n                  |-- Difference controller --|-- Prediction, differencing\n                                              |\n                                              |-- Lossless mode entropy\n                                                  encoding\n\nThis sketch also describes the flow of control (subroutine calls) during\ntypical image data processing.  Each of the components shown in the diagram is\nan \"object\" which may have several different implementations available.  One\nor more source code files contain the actual implementation(s) of each object.\n\nThe objects shown above are:\n\n* Main controller: buffer controller for the subsampled-data buffer, which\n  holds the preprocessed input data.  This controller invokes preprocessing to\n  fill the subsampled-data buffer, and JPEG compression to empty it.  There is\n  usually no need for a full-image buffer here; a strip buffer is adequate.\n\n* Preprocessing controller: buffer controller for the downsampling input data\n  buffer, which lies between colorspace conversion and downsampling.  Note\n  that a unified conversion/downsampling module would probably replace this\n  controller entirely.\n\n* Colorspace conversion: converts application image data into the desired\n  JPEG color space; also changes the data from pixel-interleaved layout to\n  separate component planes.  Processes one pixel row at a time.\n\n* Downsampling: performs reduction of chroma components as required.\n  Optionally may perform pixel-level smoothing as well.  Processes a \"row\n  group\" at a time, where a row group is defined as Vmax pixel rows of each\n  component before downsampling, and Vk sample rows afterwards (remember Vk\n  differs across components).  Some downsampling or smoothing algorithms may\n  require context rows above and below the current row group; the\n  preprocessing controller is responsible for supplying these rows via proper\n  buffering.  The downsampler is responsible for edge expansion at the right\n  edge (i.e., extending each sample row to a multiple of 8 samples); but the\n  preprocessing controller is responsible for vertical edge expansion (i.e.,\n  duplicating the bottom sample row as needed to make a multiple of 8 rows).\n\n* Coefficient controller: buffer controller for the DCT-coefficient data.\n  This controller handles MCU assembly, including insertion of dummy DCT\n  blocks when needed at the right or bottom edge.  When performing\n  Huffman-code optimization or emitting a multiscan JPEG file, this\n  controller is responsible for buffering the full image.  The equivalent of\n  one fully interleaved MCU row of subsampled data is processed per call,\n  even when the JPEG file is noninterleaved.\n\n* Forward DCT and quantization: Perform DCT, quantize, and emit coefficients.\n  Works on one or more DCT blocks at a time.  (Note: the coefficients are now\n  emitted in normal array order, which the entropy encoder is expected to\n  convert to zigzag order as necessary.  Prior versions of the IJG code did\n  the conversion to zigzag order within the quantization step.)\n\n* Entropy encoding: Perform Huffman or arithmetic entropy coding and emit the\n  coded data to the data destination module.  Works on one MCU per call.\n  For progressive JPEG, the same DCT blocks are fed to the entropy coder\n  during each pass, and the coder must emit the appropriate subset of\n  coefficients.\n\n* Difference controller: buffer controller for the spatial difference data.\n  When emitting a multiscan JPEG file, this controller is responsible for\n  buffering the full image.  The equivalent of one fully interleaved MCU row\n  of subsampled data is processed per call, even when the JPEG file is\n  noninterleaved.\n\n* Point transform: Downscale the data by the point transform value.\n\n* Prediction and differencing: Calculate the predictor and subtract it\n  from the input.  Works on one scanline per call.  The difference\n  controller supplies the prior scanline, which is used for prediction.\n\n* Lossless mode entropy encoding: Perform Huffman or arithmetic entropy coding\n  and emit the coded data to the data destination module.  This module handles\n  MCU assembly.  Works on one MCU row per call.\n\nIn addition to the above objects, the compression library includes these\nobjects:\n\n* Master control: determines the number of passes required, controls overall\n  and per-pass initialization of the other modules.\n\n* Marker writing: generates JPEG markers (except for RSTn, which is emitted\n  by the entropy encoder when needed).\n\n* Data destination manager: writes the output JPEG datastream to its final\n  destination (e.g., a file).  The destination manager supplied with the\n  library knows how to write to a stdio stream or to a memory buffer;\n  for other behaviors, the surrounding application may provide its own\n  destination manager.\n\n* Memory manager: allocates and releases memory, controls virtual arrays\n  (with backing store management, where required).\n\n* Error handler: performs formatting and output of error and trace messages;\n  determines handling of nonfatal errors.  The surrounding application may\n  override some or all of this object's methods to change error handling.\n\n* Progress monitor: supports output of \"percent-done\" progress reports.\n  This object represents an optional callback to the surrounding application:\n  if wanted, it must be supplied by the application.\n\nThe error handler, destination manager, and progress monitor objects are\ndefined as separate objects in order to simplify application-specific\ncustomization of the JPEG library.  A surrounding application may override\nindividual methods or supply its own all-new implementation of one of these\nobjects.  The object interfaces for these objects are therefore treated as\npart of the application interface of the library, whereas the other objects\nare internal to the library.\n\nThe error handler and memory manager are shared by JPEG compression and\ndecompression; the progress monitor, if used, may be shared as well.\n\n\n*** Decompression object structure ***\n\nHere is a sketch of the logical structure of the JPEG decompression library in\nlossy mode:\n\n                                               |-- Entropy decoding\n                  |-- Coefficient controller --|\n                  |                            |-- Dequantize, Inverse DCT\nMain controller --|\n                  |                               |-- Upsampling\n                  |-- Postprocessing controller --|   |-- Colorspace conversion\n                                                  |-- Color quantization\n                                                  |-- Color precision reduction\n\n... and in lossless mode:\n\n                                              |-- Lossless mode entropy\n                                              |   decoding\n                                              |\n                  |-- Difference controller --|-- Prediction, undifferencing\n                  |                           |\n                  |                           |-- Point transform, sample size\n                  |                               scaling\nMain controller --|\n                  |                               |-- Upsampling\n                  |-- Postprocessing controller --|\n                                                  |-- Color precision reduction\n\nAs before, this diagram also represents typical control flow.  The objects\nshown are:\n\n* Main controller: buffer controller for the subsampled-data buffer, which\n  holds the output of JPEG decompression proper.  This controller's primary\n  task is to feed the postprocessing procedure.  Some upsampling algorithms\n  may require context rows above and below the current row group; when this\n  is true, the main controller is responsible for managing its buffer so as\n  to make context rows available.  In the current design, the main buffer is\n  always a strip buffer; a full-image buffer is never required.\n\n* Coefficient controller: buffer controller for the DCT-coefficient data.\n  This controller handles MCU disassembly, including deletion of any dummy\n  DCT blocks at the right or bottom edge.  When reading a multiscan JPEG\n  file, this controller is responsible for buffering the full image.\n  (Buffering DCT coefficients, rather than samples, is necessary to support\n  progressive JPEG.)  The equivalent of one fully interleaved MCU row of\n  subsampled data is processed per call, even when the source JPEG file is\n  noninterleaved.\n\n* Entropy decoding: Read coded data from the data source module and perform\n  Huffman or arithmetic entropy decoding.  Works on one MCU per call.\n  For progressive JPEG decoding, the coefficient controller supplies the prior\n  coefficients of each MCU (initially all zeroes), which the entropy decoder\n  modifies in each scan.\n\n* Dequantization and inverse DCT: like it says.  Note that the coefficients\n  buffered by the coefficient controller have NOT been dequantized; we\n  merge dequantization and inverse DCT into a single step for speed reasons.\n  When scaled-down output is asked for, simplified DCT algorithms may be used\n  that emit fewer samples per DCT block, not the full 8x8.  Works on one DCT\n  block at a time.\n\n* Difference controller: buffer controller for the spatial difference data.\n  When reading a multiscan JPEG file, this controller is responsible for\n  buffering the full image. The equivalent of one fully interleaved MCU row\n  is processed per call, even when the source JPEG file is noninterleaved.\n\n* Lossless mode entropy decoding: Read coded data from the data source module\n  and perform Huffman or arithmetic entropy decoding.  Works on one MCU row per\n  call.\n\n* Prediction and undifferencing: Calculate the predictor and add it to the\n  decoded difference.  Works on one scanline per call.  The difference\n  controller supplies the prior scanline, which is used for prediction.\n\n* Point transform and sample size scaling: Upscale the data by the point\n  transform value and downscale it to fit into the compiled-in sample size.\n\n* Postprocessing controller: buffer controller for the color quantization\n  input buffer, when quantization is in use.  (Without quantization, this\n  controller just calls the upsampler.)  For two-pass quantization, this\n  controller is responsible for buffering the full-image data.\n\n* Upsampling: restores chroma components to full size.  (May support more\n  general output rescaling, too.  Note that if undersized DCT outputs have\n  been emitted by the DCT module, this module must adjust so that properly\n  sized outputs are created.)  Works on one row group at a time.  This module\n  also calls the color conversion module, so its top level is effectively a\n  buffer controller for the upsampling->color conversion buffer.  However, in\n  all but the highest-quality operating modes, upsampling and color\n  conversion are likely to be merged into a single step.\n\n* Colorspace conversion: convert from JPEG color space to output color space,\n  and change data layout from separate component planes to pixel-interleaved.\n  Works on one pixel row at a time.\n\n* Color quantization: reduce the data to colormapped form, using either an\n  externally specified colormap or an internally generated one.  This module\n  is not used for full-color output.  Works on one pixel row at a time; may\n  require two passes to generate a color map.  Note that the output will\n  always be a single component representing colormap indexes.  In the current\n  design, the output values are JSAMPLEs, J12SAMPLEs, or J16SAMPLEs, so the\n  library cannot quantize to more than 256 colors when using 8-bit data\n  precision.  This is unlikely to be a problem in practice.\n\n* Color reduction: this module handles color precision reduction, e.g.,\n  generating 15-bit color (5 bits/primary) from JPEG's 24-bit output.\n  Not quite clear yet how this should be handled... should we merge it with\n  colorspace conversion???\n\nNote that some high-speed operating modes might condense the entire\npostprocessing sequence to a single module (upsample, color convert, and\nquantize in one step).\n\nIn addition to the above objects, the decompression library includes these\nobjects:\n\n* Master control: determines the number of passes required, controls overall\n  and per-pass initialization of the other modules.  This is subdivided into\n  input and output control: jdinput.c controls only input-side processing,\n  while jdmaster.c handles overall initialization and output-side control.\n\n* Marker reading: decodes JPEG markers (except for RSTn).\n\n* Data source manager: supplies the input JPEG datastream.  The source\n  manager supplied with the library knows how to read from a stdio stream\n  or from a memory buffer;  for other behaviors, the surrounding application\n  may provide its own source manager.\n\n* Memory manager: same as for compression library.\n\n* Error handler: same as for compression library.\n\n* Progress monitor: same as for compression library.\n\nAs with compression, the data source manager, error handler, and progress\nmonitor are candidates for replacement by a surrounding application.\n\n\n*** Decompression input and output separation ***\n\nTo support efficient incremental display of progressive JPEG files, the\ndecompressor is divided into two sections that can run independently:\n\n1. Data input includes marker parsing, entropy decoding, and input into the\n   coefficient controller's DCT coefficient buffer.  Note that this\n   processing is relatively cheap and fast.\n\n2. Data output reads from the DCT coefficient buffer and performs the IDCT\n   and all postprocessing steps.\n\nFor a progressive JPEG file, the data input processing is allowed to get\narbitrarily far ahead of the data output processing.  (This occurs only\nif the application calls jpeg_consume_input(); otherwise input and output\nrun in lockstep, since the input section is called only when the output\nsection needs more data.)  In this way the application can avoid making\nextra display passes when data is arriving faster than the display pass\ncan run.  Furthermore, it is possible to abort an output pass without\nlosing anything, since the coefficient buffer is read-only as far as the\noutput section is concerned.  See libjpeg.txt for more detail.\n\nA full-image coefficient array is only created if the JPEG file has multiple\nscans (or if the application specifies buffered-image mode anyway).  When\nreading a single-scan file, the coefficient controller normally creates only\na one-MCU buffer, so input and output processing must run in lockstep in this\ncase.  jpeg_consume_input() is effectively a no-op in this situation.\n\nThe main impact of dividing the decompressor in this fashion is that we must\nbe very careful with shared variables in the cinfo data structure.  Each\nvariable that can change during the course of decompression must be\nclassified as belonging to data input or data output, and each section must\nlook only at its own variables.  For example, the data output section may not\ndepend on any of the variables that describe the current scan in the JPEG\nfile, because these may change as the data input section advances into a new\nscan.\n\nThe progress monitor is (somewhat arbitrarily) defined to treat input of the\nfile as one pass when buffered-image mode is not used, and to ignore data\ninput work completely when buffered-image mode is used.  Note that the\nlibrary has no reliable way to predict the number of passes when dealing\nwith a progressive JPEG file, nor can it predict the number of output passes\nin buffered-image mode.  So the work estimate is inherently bogus anyway.\n\nNo comparable division is currently made in the compression library, because\nthere isn't any real need for it.\n\n\n*** Data formats ***\n\nArrays of 8-bit pixel sample values use the following data structure:\n\n    typedef something JSAMPLE;          a pixel component value, 0..MAXJSAMPLE\n    typedef JSAMPLE *JSAMPROW;          ptr to a row of samples\n    typedef JSAMPROW *JSAMPARRAY;       ptr to a list of rows\n    typedef JSAMPARRAY *JSAMPIMAGE;     ptr to a list of color-component arrays\n\nArrays of 12-bit pixel sample values use the following data structure:\n\n    typedef something J12SAMPLE;        a pixel component value, 0..MAXJ12SAMPLE\n    typedef J12SAMPLE *J12SAMPROW;      ptr to a row of samples\n    typedef J12SAMPROW *J12SAMPARRAY;   ptr to a list of rows\n    typedef J12SAMPARRAY *J12SAMPIMAGE; ptr to a list of color-component arrays\n\nArrays of 16-bit pixel sample values use the following data structure:\n\n    typedef something J16SAMPLE;        a pixel component value, 0..MAXJ16SAMPLE\n    typedef J16SAMPLE *J16SAMPROW;      ptr to a row of samples\n    typedef J16SAMPROW *J16SAMPARRAY;   ptr to a list of rows\n    typedef J16SAMPARRAY *J16SAMPIMAGE; ptr to a list of color-component arrays\n\nThe basic element type JSAMPLE (8-bit sample) will be unsigned char, the basic\nelement type J12SAMPLE (12-bit sample) will be short, and the basic element\ntype J16SAMPLE (16-bit sample) will be unsigned short.\n\nWith these conventions, J*SAMPLE values can be assumed to be >= 0.  This helps\nsimplify correct rounding during downsampling, etc.  The JPEG standard's\nspecification that 8-bit sample values run from -128..127 is accommodated by\nsubtracting 128 from the sample value in the DCT step.  Similarly, during\ndecompression the output of the IDCT step will be immediately shifted back to\n0..255.  (NOTE: different values are required when 12-bit samples are in use.\nWhen 8-bit samples are in use, the code uses MAXJSAMPLE and CENTERJSAMPLE,\nwhich are defined as 255 and 128 respectively.  When 12-bit samples are in use,\nthe code uses MAXJ12SAMPLE and CENTERJ12SAMPLE, which are defined as 4095 and\n2048 respectively.  When 16-bit samples are in use, the code uses MAXJ16SAMPLE\nand CENTERJ16SAMPLE, which are defined as 65535 and 32768 respectively.)\n\nWe use a pointer per row, rather than a two-dimensional J*SAMPLE array.  This\nchoice costs only a small amount of memory and has several benefits:\n* Code using the data structure doesn't need to know the allocated width of\n  the rows.  This simplifies edge expansion/compression, since we can work\n  in an array that's wider than the logical picture width.\n* Indexing doesn't require multiplication; this is a performance win on many\n  machines.\n* Arrays with more than 64K total elements can be supported even on machines\n  where malloc() cannot allocate chunks larger than 64K.\n* The rows forming a component array may be allocated at different times\n  without extra copying.  This trick allows some speedups in smoothing steps\n  that need access to the previous and next rows.\n\nNote that each color component is stored in a separate array; we don't use the\ntraditional layout in which the components of a pixel are stored together.\nThis simplifies coding of modules that work on each component independently,\nbecause they don't need to know how many components there are.  Furthermore,\nwe can read or write each component to a temporary file independently, which\nis helpful when dealing with noninterleaved JPEG files.\n\nIn general, a specific sample value is accessed by code such as\n        image[colorcomponent][row][col]\nwhere col is measured from the image left edge, but row is measured from the\nfirst sample row currently in memory.  Either of the first two indexings can\nbe precomputed by copying the relevant pointer.\n\n\nSince most image-processing applications prefer to work on images in which\nthe components of a pixel are stored together, the data passed to or from the\nsurrounding application uses the traditional convention: a single pixel is\nrepresented by N consecutive J*SAMPLE values, and an image row is an array of\n(# of color components)*(image width) J*SAMPLEs.  One or more rows of data can\nbe represented by a pointer of type J*SAMPARRAY in this scheme.  This scheme is\nconverted to component-wise storage inside the JPEG library.  (Applications\nthat want to skip JPEG preprocessing or postprocessing will have to contend\nwith component-wise storage.)\n\n\nArrays of DCT-coefficient values use the following data structure:\n\n    typedef short JCOEF;                a 16-bit signed integer\n    typedef JCOEF JBLOCK[DCTSIZE2];     an 8x8 block of coefficients\n    typedef JBLOCK *JBLOCKROW;          ptr to one horizontal row of 8x8 blocks\n    typedef JBLOCKROW *JBLOCKARRAY;     ptr to a list of such rows\n    typedef JBLOCKARRAY *JBLOCKIMAGE;   ptr to a list of color component arrays\n\nThe underlying type is at least a 16-bit signed integer; while \"short\" is big\nenough on all machines of interest, on some machines it is preferable to use\n\"int\" for speed reasons, despite the storage cost.  Coefficients are grouped\ninto 8x8 blocks (but we always use #defines DCTSIZE and DCTSIZE2 rather than\n\"8\" and \"64\").\n\nThe contents of a coefficient block may be in either \"natural\" or zigzagged\norder, and may be true values or divided by the quantization coefficients,\ndepending on where the block is in the processing pipeline.  In the current\nlibrary, coefficient blocks are kept in natural order everywhere; the entropy\ncodecs zigzag or dezigzag the data as it is written or read.  The blocks\ncontain quantized coefficients everywhere outside the DCT/IDCT subsystems.\n(This latter decision may need to be revisited to support variable\nquantization a la JPEG Part 3.)\n\nNotice that the allocation unit is now a row of 8x8 blocks, corresponding to\neight rows of samples.  Otherwise the structure is much the same as for\nsamples, and for the same reasons.\n\n\n*** Suspendable processing ***\n\nIn some applications it is desirable to use the JPEG library as an\nincremental, memory-to-memory filter.  In this situation the data source or\ndestination may be a limited-size buffer, and we can't rely on being able to\nempty or refill the buffer at arbitrary times.  Instead the application would\nlike to have control return from the library at buffer overflow/underrun, and\nthen resume compression or decompression at a later time.\n\nThis scenario is supported for simple cases.  (For anything more complex, we\nrecommend that the application \"bite the bullet\" and develop real multitasking\ncapability.)  The libjpeg.txt file goes into more detail about the usage and\nlimitations of this capability; here we address the implications for library\nstructure.\n\nThe essence of the problem is that the entropy codec (coder or decoder) must\nbe prepared to stop at arbitrary times.  In turn, the controllers that call\nthe entropy codec must be able to stop before having produced or consumed all\nthe data that they normally would handle in one call.  That part is reasonably\nstraightforward: we make the controller call interfaces include \"progress\ncounters\" which indicate the number of data chunks successfully processed, and\nwe require callers to test the counter rather than just assume all of the data\nwas processed.\n\nRather than trying to restart at an arbitrary point, the current Huffman\ncodecs are designed to restart at the beginning of the current MCU after a\nsuspension due to buffer overflow/underrun.  At the start of each call, the\ncodec's internal state is loaded from permanent storage (in the JPEG object\nstructures) into local variables.  On successful completion of the MCU, the\npermanent state is updated.  (This copying is not very expensive, and may even\nlead to *improved* performance if the local variables can be registerized.)\nIf a suspension occurs, the codec simply returns without updating the state,\nthus effectively reverting to the start of the MCU.  Note that this implies\nleaving some data unprocessed in the source/destination buffer (ie, the\ncompressed partial MCU).  The data source/destination module interfaces are\nspecified so as to make this possible.  This also implies that the data buffer\nmust be large enough to hold a worst-case compressed MCU; a couple thousand\nbytes should be enough.\n\nIn a successive-approximation AC refinement scan, the progressive Huffman\ndecoder has to be able to undo assignments of newly nonzero coefficients if it\nsuspends before the MCU is complete, since decoding requires distinguishing\npreviously-zero and previously-nonzero coefficients.  This is a bit tedious\nbut probably won't have much effect on performance.  Other variants of Huffman\ndecoding need not worry about this, since they will just store the same values\nagain if forced to repeat the MCU.\n\nThis approach would probably not work for an arithmetic codec, since its\nmodifiable state is quite large and couldn't be copied cheaply.  Instead it\nwould have to suspend and resume exactly at the point of the buffer end.\n\nThe JPEG marker reader is designed to cope with suspension at an arbitrary\npoint.  It does so by backing up to the start of the marker parameter segment,\nso the data buffer must be big enough to hold the largest marker of interest.\nAgain, a couple KB should be adequate.  (A special \"skip\" convention is used\nto bypass COM and APPn markers, so these can be larger than the buffer size\nwithout causing problems; otherwise a 64K buffer would be needed in the worst\ncase.)\n\nThe JPEG marker writer currently does *not* cope with suspension.\nWe feel that this is not necessary; it is much easier simply to require\nthe application to ensure there is enough buffer space before starting.  (An\nempty 2K buffer is more than sufficient for the header markers; and ensuring\nthere are a dozen or two bytes available before calling jpeg_finish_compress()\nwill suffice for the trailer.)  This would not work for writing multi-scan\nJPEG files, but we simply do not intend to support that capability with\nsuspension.\n\n\n*** Memory manager services ***\n\nThe JPEG library's memory manager controls allocation and deallocation of\nmemory, and it manages large \"virtual\" data arrays on machines where the\noperating system does not provide virtual memory.  Note that the same\nmemory manager serves both compression and decompression operations.\n\nIn all cases, allocated objects are tied to a particular compression or\ndecompression master record, and they will be released when that master\nrecord is destroyed.\n\nThe memory manager does not provide explicit deallocation of objects.\nInstead, objects are created in \"pools\" of free storage, and a whole pool\ncan be freed at once.  This approach helps prevent storage-leak bugs, and\nit speeds up operations whenever malloc/free are slow (as they often are).\nThe pools can be regarded as lifetime identifiers for objects.  Two\npools/lifetimes are defined:\n  * JPOOL_PERMANENT     lasts until master record is destroyed\n  * JPOOL_IMAGE         lasts until done with image (JPEG datastream)\nPermanent lifetime is used for parameters and tables that should be carried\nacross from one datastream to another; this includes all application-visible\nparameters.  Image lifetime is used for everything else.  (A third lifetime,\nJPOOL_PASS = one processing pass, was originally planned.  However it was\ndropped as not being worthwhile.  The actual usage patterns are such that the\npeak memory usage would be about the same anyway; and having per-pass storage\nsubstantially complicates the virtual memory allocation rules --- see below.)\n\nThe memory manager deals with three kinds of object:\n1. \"Small\" objects.  Typically these require no more than 10K-20K total.\n2. \"Large\" objects.  These may require tens to hundreds of K depending on\n   image size.  Semantically they behave the same as small objects, but we\n   distinguish them because pool allocation heuristics may differ for large and\n   small objects (historically, large objects were also referenced by far\n   pointers on MS-DOS machines.)  Note that individual \"large\" objects cannot\n   exceed the size allowed by type size_t, which may be 64K or less on some\n   machines.\n3. \"Virtual\" objects.  These are large 2-D arrays of J*SAMPLEs or JBLOCKs\n   (typically large enough for the entire image being processed).  The\n   memory manager provides stripwise access to these arrays.  On machines\n   without virtual memory, the rest of the array may be swapped out to a\n   temporary file.\n\n(Note: J*SAMPARRAY and JBLOCKARRAY data structures are a combination of large\nobjects for the data proper and small objects for the row pointers.  For\nconvenience and speed, the memory manager provides single routines to create\nthese structures.  Similarly, virtual arrays include a small control block\nand a J*SAMPARRAY or JBLOCKARRAY working buffer, all created with one call.)\n\nIn the present implementation, virtual arrays are only permitted to have image\nlifespan.  (Permanent lifespan would not be reasonable, and pass lifespan is\nnot very useful since a virtual array's raison d'etre is to store data for\nmultiple passes through the image.)  We also expect that only \"small\" objects\nwill be given permanent lifespan, though this restriction is not required by\nthe memory manager.\n\nIn a non-virtual-memory machine, some performance benefit can be gained by\nmaking the in-memory buffers for virtual arrays be as large as possible.\n(For small images, the buffers might fit entirely in memory, so blind\nswapping would be very wasteful.)  The memory manager will adjust the height\nof the buffers to fit within a prespecified maximum memory usage.  In order\nto do this in a reasonably optimal fashion, the manager needs to allocate all\nof the virtual arrays at once.  Therefore, there isn't a one-step allocation\nroutine for virtual arrays; instead, there is a \"request\" routine that simply\nallocates the control block, and a \"realize\" routine (called just once) that\ndetermines space allocation and creates all of the actual buffers.  The\nrealize routine must allow for space occupied by non-virtual large objects.\n(We don't bother to factor in the space needed for small objects, on the\ngrounds that it isn't worth the trouble.)\n\nTo support all this, we establish the following protocol for doing business\nwith the memory manager:\n  1. Modules must request virtual arrays (which may have only image lifespan)\n     during the initial setup phase, i.e., in their jinit_xxx routines.\n  2. All \"large\" objects (including J*SAMPARRAYs and JBLOCKARRAYs) must also be\n     allocated during initial setup.\n  3. realize_virt_arrays will be called at the completion of initial setup.\n     The above conventions ensure that sufficient information is available\n     for it to choose a good size for virtual array buffers.\nSmall objects of any lifespan may be allocated at any time.  We expect that\nthe total space used for small objects will be small enough to be negligible\nin the realize_virt_arrays computation.\n\nIn a virtual-memory machine, we simply pretend that the available space is\ninfinite, thus causing realize_virt_arrays to decide that it can allocate all\nthe virtual arrays as full-size in-memory buffers.  The overhead of the\nvirtual-array access protocol is very small when no swapping occurs.\n\nA virtual array can be specified to be \"pre-zeroed\"; when this flag is set,\nnever-yet-written sections of the array are set to zero before being made\navailable to the caller.  If this flag is not set, never-written sections\nof the array contain garbage.  (This feature exists primarily because the\nequivalent logic would otherwise be needed in jdcoefct.c for progressive\nJPEG mode; we may as well make it available for possible other uses.)\n\nThe first write pass on a virtual array is required to occur in top-to-bottom\norder; read passes, as well as any write passes after the first one, may\naccess the array in any order.  This restriction exists partly to simplify\nthe virtual array control logic, and partly because some file systems may not\nsupport seeking beyond the current end-of-file in a temporary file.  The main\nimplication of this restriction is that rearrangement of rows (such as\nconverting top-to-bottom data order to bottom-to-top) must be handled while\nreading data out of the virtual array, not while putting it in.\n\n\n*** Memory manager internal structure ***\n\nTo isolate system dependencies as much as possible, we have broken the\nmemory manager into two parts.  There is a reasonably system-independent\n\"front end\" (jmemmgr.c) and a \"back end\" that contains only the code\nlikely to change across systems.  All of the memory management methods\noutlined above are implemented by the front end.  The back end provides\nthe following routines for use by the front end (none of these routines\nare known to the rest of the JPEG code):\n\njpeg_mem_init, jpeg_mem_term    system-dependent initialization/shutdown\n\njpeg_get_small, jpeg_free_small interface to malloc and free library routines\n                                (or their equivalents)\n\njpeg_get_large, jpeg_free_large historically was used to interface with\n                                FAR malloc/free on MS-DOS machines;  now the\n                                same as jpeg_get_small/jpeg_free_small\n\njpeg_mem_available              estimate available memory\n\njpeg_open_backing_store         create a backing-store object\n\nread_backing_store,             manipulate a backing-store object\nwrite_backing_store,\nclose_backing_store\n\nOn some systems there will be more than one type of backing-store object.\njpeg_open_backing_store is responsible for choosing how to implement a given\nobject.  The read/write/close routines are method pointers in the structure\nthat describes a given object; this lets them be different for different object\ntypes.\n\nIt may be necessary to ensure that backing store objects are explicitly\nreleased upon abnormal program termination.  To support this, we will expect\nthe main program or surrounding application to arrange to call self_destruct\n(typically via jpeg_destroy) upon abnormal termination.  This may require a\nSIGINT signal handler or equivalent.  We don't want to have the back end module\ninstall its own signal handler, because that would pre-empt the surrounding\napplication's ability to control signal handling.\n\nThe IJG distribution includes several memory manager back end implementations.\nUsually the same back end should be suitable for all applications on a given\nsystem, but it is possible for an application to supply its own back end at\nneed.\n\n\n*** Implications of DNL marker ***\n\nSome JPEG files may use a DNL marker to postpone definition of the image\nheight (this would be useful for a fax-like scanner's output, for instance).\nIn these files the SOF marker claims the image height is 0, and you only\nfind out the true image height at the end of the first scan.\n\nWe could read these files as follows:\n1. Upon seeing zero image height, replace it by 65535 (the maximum allowed).\n2. When the DNL is found, update the image height in the global image\n   descriptor.\nThis implies that control modules must avoid making copies of the image\nheight, and must re-test for termination after each MCU row.  This would\nbe easy enough to do.\n\nIn cases where image-size data structures are allocated, this approach will\nresult in very inefficient use of virtual memory or much-larger-than-necessary\ntemporary files.  This seems acceptable for something that probably won't be a\nmainstream usage.  People might have to forgo use of memory-hogging options\n(such as two-pass color quantization or noninterleaved JPEG files) if they\nwant efficient conversion of such files.  (One could improve efficiency by\ndemanding a user-supplied upper bound for the height, less than 65536; in most\ncases it could be much less.)\n\nThe standard also permits the SOF marker to overestimate the image height,\nwith a DNL to give the true, smaller height at the end of the first scan.\nThis would solve the space problems if the overestimate wasn't too great.\nHowever, it implies that you don't even know whether DNL will be used.\n\nThis leads to a couple of very serious objections:\n1. Testing for a DNL marker must occur in the inner loop of the decompressor's\n   Huffman decoder; this implies a speed penalty whether the feature is used\n   or not.\n2. There is no way to hide the last-minute change in image height from an\n   application using the decoder.  Thus *every* application using the IJG\n   library would suffer a complexity penalty whether it cared about DNL or\n   not.\nWe currently do not support DNL because of these problems.\n\nA different approach is to insist that DNL-using files be preprocessed by a\nseparate program that reads ahead to the DNL, then goes back and fixes the SOF\nmarker.  This is a much simpler solution and is probably far more efficient.\nEven if one wants piped input, buffering the first scan of the JPEG file needs\na lot smaller temp file than is implied by the maximum-height method.  For\nthis approach we'd simply treat DNL as a no-op in the decompressor (at most,\ncheck that it matches the SOF image height).\n\nWe will not worry about making the compressor capable of outputting DNL.\nSomething similar to the first scheme above could be applied if anyone ever\nwants to make that work.\n"
        },
        {
          "name": "testimages",
          "type": "tree",
          "content": null
        },
        {
          "name": "tjbench.c",
          "type": "blob",
          "size": 48.9052734375,
          "content": "/*\n * Copyright (C)2009-2019, 2021-2024 D. R. Commander.  All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n#include <errno.h>\n#include <limits.h>\n#if !defined(_MSC_VER) || _MSC_VER > 1600\n#include <stdint.h>\n#endif\n#include <cdjpeg.h>\n#include \"./tjutil.h\"\n#include \"./turbojpeg.h\"\n\n\n#define THROW(op, err) { \\\n  printf(\"ERROR in line %d while %s:\\n%s\\n\", __LINE__, op, err); \\\n  retval = -1;  goto bailout; \\\n}\n#define THROW_UNIX(m)  THROW(m, strerror(errno))\n\nstatic char tjErrorStr[JMSG_LENGTH_MAX] = \"\\0\";\nstatic int tjErrorLine = -1, tjErrorCode = -1;\n\n#define THROW_TJG() { \\\n  printf(\"ERROR in line %d\\n%s\\n\", __LINE__, tj3GetErrorStr(NULL)); \\\n  retval = -1;  goto bailout; \\\n}\n\n#define THROW_TJ() { \\\n  int _tjErrorCode = tj3GetErrorCode(handle); \\\n  char *_tjErrorStr = tj3GetErrorStr(handle); \\\n  \\\n  if (!tj3Get(handle, TJPARAM_STOPONWARNING) && \\\n      _tjErrorCode == TJERR_WARNING) { \\\n    if (strncmp(tjErrorStr, _tjErrorStr, JMSG_LENGTH_MAX) || \\\n        tjErrorCode != _tjErrorCode || tjErrorLine != __LINE__) { \\\n      strncpy(tjErrorStr, _tjErrorStr, JMSG_LENGTH_MAX); \\\n      tjErrorStr[JMSG_LENGTH_MAX - 1] = '\\0'; \\\n      tjErrorCode = _tjErrorCode; \\\n      tjErrorLine = __LINE__; \\\n      printf(\"WARNING in line %d:\\n%s\\n\", __LINE__, _tjErrorStr); \\\n    } \\\n  } else { \\\n    printf(\"%s in line %d:\\n%s\\n\", \\\n           _tjErrorCode == TJERR_WARNING ? \"WARNING\" : \"ERROR\", __LINE__, \\\n           _tjErrorStr); \\\n    retval = -1;  goto bailout; \\\n  } \\\n}\n\n#define IS_CROPPED(cr)  (cr.x != 0 || cr.y != 0 || cr.w != 0 || cr.h != 0)\n\n#define CROPPED_WIDTH(width) \\\n  (IS_CROPPED(cr) ? (cr.w != 0 ? cr.w : TJSCALED(width, sf) - cr.x) : \\\n                    TJSCALED(width, sf))\n\n#define CROPPED_HEIGHT(height) \\\n  (IS_CROPPED(cr) ? (cr.h != 0 ? cr.h : TJSCALED(height, sf) - cr.y) : \\\n                    TJSCALED(height, sf))\n\nstatic int stopOnWarning = 0, bottomUp = 0, noRealloc = 1, fastUpsample = 0,\n  fastDCT = 0, optimize = 0, progressive = 0, limitScans = 0, maxMemory = 0,\n  maxPixels = 0, arithmetic = 0, lossless = 0, restartIntervalBlocks = 0,\n  restartIntervalRows = 0;\nstatic int precision = 8, sampleSize, compOnly = 0, decompOnly = 0, doYUV = 0,\n  quiet = 0, doTile = 0, pf = TJPF_BGR, yuvAlign = 1, doWrite = 1;\nstatic char *ext = \"ppm\";\nstatic const char *pixFormatStr[TJ_NUMPF] = {\n  \"RGB\", \"BGR\", \"RGBX\", \"BGRX\", \"XBGR\", \"XRGB\", \"GRAY\", \"\", \"\", \"\", \"\", \"CMYK\"\n};\nstatic const char *subNameLong[TJ_NUMSAMP] = {\n  \"4:4:4\", \"4:2:2\", \"4:2:0\", \"GRAY\", \"4:4:0\", \"4:1:1\", \"4:4:1\"\n};\nstatic const char *csName[TJ_NUMCS] = {\n  \"RGB\", \"YCbCr\", \"GRAY\", \"CMYK\", \"YCCK\"\n};\nstatic const char *subName[TJ_NUMSAMP] = {\n  \"444\", \"422\", \"420\", \"GRAY\", \"440\", \"411\", \"441\"\n};\nstatic tjscalingfactor *scalingFactors = NULL, sf = { 1, 1 };\nstatic tjregion cr = { 0, 0, 0, 0 };\nstatic int nsf = 0, xformOp = TJXOP_NONE, xformOpt = 0;\nstatic int (*customFilter) (short *, tjregion, tjregion, int, int,\n                            tjtransform *);\nstatic double benchTime = 5.0, warmup = 1.0;\n\n\nstatic char *formatName(int subsamp, int cs, char *buf)\n{\n  if (quiet == 1) {\n    if (lossless)\n      SNPRINTF(buf, 80, \"%-2d/LOSSLESS   \", precision);\n    else if (subsamp == TJSAMP_UNKNOWN)\n      SNPRINTF(buf, 80, \"%-2d/%-5s      \", precision, csName[cs]);\n    else\n      SNPRINTF(buf, 80, \"%-2d/%-5s/%-5s\", precision, csName[cs],\n               subNameLong[subsamp]);\n    return buf;\n  } else {\n    if (lossless)\n      return (char *)\"Lossless\";\n    else if (subsamp == TJSAMP_UNKNOWN)\n      return (char *)csName[cs];\n    else {\n      SNPRINTF(buf, 80, \"%s %s\", csName[cs], subNameLong[subsamp]);\n      return buf;\n    }\n  }\n}\n\n\nstatic char *sigfig(double val, int figs, char *buf, int len)\n{\n  char format[80];\n  int digitsAfterDecimal = figs - (int)ceil(log10(fabs(val)));\n\n  if (digitsAfterDecimal < 1)\n    SNPRINTF(format, 80, \"%%.0f\");\n  else\n    SNPRINTF(format, 80, \"%%.%df\", digitsAfterDecimal);\n  SNPRINTF(buf, len, format, val);\n  return buf;\n}\n\n\n/* Custom DCT filter which produces a negative of the image */\nstatic int dummyDCTFilter(short *coeffs, tjregion arrayRegion,\n                          tjregion planeRegion, int componentIndex,\n                          int transformIndex, tjtransform *transform)\n{\n  int i;\n\n  for (i = 0; i < arrayRegion.w * arrayRegion.h; i++)\n    coeffs[i] = -coeffs[i];\n  return 0;\n}\n\n\n/* Decompression test */\nstatic int decomp(unsigned char **jpegBufs, size_t *jpegSizes, void *dstBuf,\n                  int w, int h, int subsamp, int jpegQual, char *fileName,\n                  int tilew, int tileh)\n{\n  char tempStr[1024], sizeStr[24] = \"\\0\", qualStr[16] = \"\\0\";\n  FILE *file = NULL;\n  tjhandle handle = NULL;\n  int i, row, col, iter = 0, dstBufAlloc = 0, retval = 0;\n  double elapsed, elapsedDecode;\n  int ps = tjPixelSize[pf];\n  int scaledw, scaledh, pitch;\n  int ntilesw = (w + tilew - 1) / tilew, ntilesh = (h + tileh - 1) / tileh;\n  unsigned char *dstPtr, *dstPtr2, *yuvBuf = NULL;\n\n  if (lossless) sf = TJUNSCALED;\n\n  scaledw = TJSCALED(w, sf);\n  scaledh = TJSCALED(h, sf);\n\n  if (jpegQual > 0) {\n    SNPRINTF(qualStr, 16, \"_%s%d\", lossless ? \"PSV\" : \"Q\", jpegQual);\n    qualStr[15] = 0;\n  }\n\n  if ((handle = tj3Init(TJINIT_DECOMPRESS)) == NULL)\n    THROW_TJG();\n  if (tj3Set(handle, TJPARAM_STOPONWARNING, stopOnWarning) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_BOTTOMUP, bottomUp) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_FASTUPSAMPLE, fastUpsample) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_FASTDCT, fastDCT) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_SCANLIMIT, limitScans ? 500 : 0) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_MAXMEMORY, maxMemory) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_MAXPIXELS, maxPixels) == -1)\n    THROW_TJ();\n\n  if (IS_CROPPED(cr)) {\n    if (tj3DecompressHeader(handle, jpegBufs[0], jpegSizes[0]) == -1)\n      THROW_TJ();\n  }\n  if (tj3SetScalingFactor(handle, sf) == -1)\n    THROW_TJ();\n  if (tj3SetCroppingRegion(handle, cr) == -1)\n    THROW_TJ();\n  if (IS_CROPPED(cr)) {\n    scaledw = cr.w ? cr.w : scaledw - cr.x;\n    scaledh = cr.h ? cr.h : scaledh - cr.y;\n  }\n  pitch = scaledw * ps;\n\n  if (dstBuf == NULL) {\n#if ULLONG_MAX > SIZE_MAX\n    if ((unsigned long long)pitch * (unsigned long long)scaledh *\n        (unsigned long long)sampleSize > (unsigned long long)((size_t)-1))\n      THROW(\"allocating destination buffer\", \"Image is too large\");\n#endif\n    if ((dstBuf = malloc((size_t)pitch * scaledh * sampleSize)) == NULL)\n      THROW_UNIX(\"allocating destination buffer\");\n    dstBufAlloc = 1;\n  }\n\n  /* Set the destination buffer to gray so we know whether the decompressor\n     attempted to write to it */\n  if (precision == 8)\n    memset((unsigned char *)dstBuf, 127, (size_t)pitch * scaledh);\n  else if (precision == 12) {\n    for (i = 0; i < pitch * scaledh; i++)\n      ((short *)dstBuf)[i] = (short)2047;\n  } else {\n    for (i = 0; i < pitch * scaledh; i++)\n      ((unsigned short *)dstBuf)[i] = (unsigned short)32767;\n  }\n\n  if (doYUV) {\n    int width = doTile ? tilew : scaledw;\n    int height = doTile ? tileh : scaledh;\n    size_t yuvSize = tj3YUVBufSize(width, yuvAlign, height, subsamp);\n\n    if (yuvSize == 0)\n      THROW_TJG();\n    if ((yuvBuf = (unsigned char *)malloc(yuvSize)) == NULL)\n      THROW_UNIX(\"allocating YUV buffer\");\n    memset(yuvBuf, 127, yuvSize);\n  }\n\n  /* Benchmark */\n  iter = -1;\n  elapsed = elapsedDecode = 0.;\n  while (1) {\n    int tile = 0;\n    double start = getTime();\n\n    for (row = 0, dstPtr = dstBuf; row < ntilesh;\n         row++, dstPtr += (size_t)pitch * tileh * sampleSize) {\n      for (col = 0, dstPtr2 = dstPtr; col < ntilesw;\n           col++, tile++, dstPtr2 += ps * tilew * sampleSize) {\n        int width = doTile ? min(tilew, w - col * tilew) : scaledw;\n        int height = doTile ? min(tileh, h - row * tileh) : scaledh;\n\n        if (doYUV) {\n          double startDecode;\n\n          if (tj3DecompressToYUV8(handle, jpegBufs[tile], jpegSizes[tile],\n                                  yuvBuf, yuvAlign) == -1)\n            THROW_TJ();\n          startDecode = getTime();\n          if (tj3DecodeYUV8(handle, yuvBuf, yuvAlign, dstPtr2, width, pitch,\n                            height, pf) == -1)\n            THROW_TJ();\n          if (iter >= 0) elapsedDecode += getTime() - startDecode;\n        } else {\n          if (precision == 8) {\n            if (tj3Decompress8(handle, jpegBufs[tile], jpegSizes[tile],\n                               dstPtr2, pitch, pf) == -1)\n              THROW_TJ();\n          } else if (precision == 12) {\n            if (tj3Decompress12(handle, jpegBufs[tile], jpegSizes[tile],\n                                (short *)dstPtr2, pitch, pf) == -1)\n              THROW_TJ();\n          } else {\n            if (tj3Decompress16(handle, jpegBufs[tile], jpegSizes[tile],\n                                (unsigned short *)dstPtr2, pitch, pf) == -1)\n              THROW_TJ();\n          }\n        }\n      }\n    }\n    elapsed += getTime() - start;\n    if (iter >= 0) {\n      iter++;\n      if (elapsed >= benchTime) break;\n    } else if (elapsed >= warmup) {\n      iter = 0;\n      elapsed = elapsedDecode = 0.;\n    }\n  }\n  if (doYUV) elapsed -= elapsedDecode;\n\n  if (quiet) {\n    printf(\"%-6s%s\",\n           sigfig((double)(w * h) / 1000000. * (double)iter / elapsed, 4,\n                  tempStr, 1024),\n           quiet == 2 ? \"\\n\" : \"  \");\n    if (doYUV)\n      printf(\"%s\\n\",\n             sigfig((double)(w * h) / 1000000. * (double)iter / elapsedDecode,\n                    4, tempStr, 1024));\n    else if (quiet != 2) printf(\"\\n\");\n  } else {\n    printf(\"%s --> Frame rate:         %f fps\\n\",\n           doYUV ? \"Decomp to YUV\" : \"Decompress   \", (double)iter / elapsed);\n    printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n           (double)(w * h) / 1000000. * (double)iter / elapsed);\n    if (doYUV) {\n      printf(\"YUV Decode    --> Frame rate:         %f fps\\n\",\n             (double)iter / elapsedDecode);\n      printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n             (double)(w * h) / 1000000. * (double)iter / elapsedDecode);\n    }\n  }\n\n  if (!doWrite) goto bailout;\n\n  if (sf.num != 1 || sf.denom != 1)\n    SNPRINTF(sizeStr, 24, \"%d_%d\", sf.num, sf.denom);\n  else if (tilew != w || tileh != h)\n    SNPRINTF(sizeStr, 24, \"%dx%d\", tilew, tileh);\n  else SNPRINTF(sizeStr, 24, \"full\");\n  if (decompOnly)\n    SNPRINTF(tempStr, 1024, \"%s_%s.%s\", fileName, sizeStr, ext);\n  else\n    SNPRINTF(tempStr, 1024, \"%s_%s%s_%s.%s\", fileName,\n             lossless ? \"LOSSLS\" : subName[subsamp], qualStr, sizeStr, ext);\n\n  if (precision == 8) {\n    if (tj3SaveImage8(handle, tempStr, (unsigned char *)dstBuf, scaledw, 0,\n                      scaledh, pf) == -1)\n      THROW_TJ();\n  } else if (precision == 12) {\n    if (tj3SaveImage12(handle, tempStr, (short *)dstBuf, scaledw, 0, scaledh,\n                       pf) == -1)\n      THROW_TJ();\n  } else {\n    if (tj3SaveImage16(handle, tempStr, (unsigned short *)dstBuf, scaledw, 0,\n                      scaledh, pf) == -1)\n      THROW_TJ();\n  }\n\nbailout:\n  if (file) fclose(file);\n  tj3Destroy(handle);\n  if (dstBufAlloc) free(dstBuf);\n  free(yuvBuf);\n  return retval;\n}\n\n\nstatic int fullTest(tjhandle handle, void *srcBuf, int w, int h, int subsamp,\n                    int jpegQual, char *fileName)\n{\n  char tempStr[1024], tempStr2[80];\n  FILE *file = NULL;\n  unsigned char **jpegBufs = NULL, *yuvBuf = NULL, *srcPtr, *srcPtr2;\n  void *tmpBuf = NULL;\n  double start, elapsed, elapsedEncode;\n  int row, col, i, tilew = w, tileh = h, retval = 0;\n  int iter;\n  size_t totalJpegSize = 0, *jpegSizes = NULL, yuvSize = 0;\n  int ps = tjPixelSize[pf];\n  int ntilesw = 1, ntilesh = 1, pitch = w * ps;\n  const char *pfStr = pixFormatStr[pf];\n\n#if ULLONG_MAX > SIZE_MAX\n  if ((unsigned long long)pitch * (unsigned long long)h *\n      (unsigned long long)sampleSize > (unsigned long long)((size_t)-1))\n    THROW(\"allocating temporary image buffer\", \"Image is too large\");\n#endif\n  if ((tmpBuf = malloc((size_t)pitch * h * sampleSize)) == NULL)\n    THROW_UNIX(\"allocating temporary image buffer\");\n\n  if (!quiet)\n    printf(\">>>>>  %s (%s) <--> %d-bit JPEG (%s %s%d)  <<<<<\\n\", pfStr,\n           bottomUp ? \"Bottom-up\" : \"Top-down\", precision,\n           lossless ? \"Lossless\" : subNameLong[subsamp],\n           lossless ? \"PSV\" : \"Q\", jpegQual);\n\n  for (tilew = doTile ? 8 : w, tileh = doTile ? 8 : h; ;\n       tilew *= 2, tileh *= 2) {\n    if (tilew > w) tilew = w;\n    if (tileh > h) tileh = h;\n    ntilesw = (w + tilew - 1) / tilew;\n    ntilesh = (h + tileh - 1) / tileh;\n\n    if ((jpegBufs = (unsigned char **)malloc(sizeof(unsigned char *) *\n                                             ntilesw * ntilesh)) == NULL)\n      THROW_UNIX(\"allocating JPEG tile array\");\n    memset(jpegBufs, 0, sizeof(unsigned char *) * ntilesw * ntilesh);\n    if ((jpegSizes = (size_t *)malloc(sizeof(size_t) * ntilesw *\n                                      ntilesh)) == NULL)\n      THROW_UNIX(\"allocating JPEG size array\");\n    memset(jpegSizes, 0, sizeof(size_t) * ntilesw * ntilesh);\n\n    if (noRealloc) {\n      for (i = 0; i < ntilesw * ntilesh; i++) {\n        size_t jpegBufSize = tj3JPEGBufSize(tilew, tileh, subsamp);\n\n        if (jpegBufSize == 0)\n          THROW_TJG();\n        if ((jpegBufs[i] = tj3Alloc(jpegBufSize)) == NULL)\n          THROW_UNIX(\"allocating JPEG tiles\");\n      }\n    }\n\n    /* Compression test */\n    if (quiet == 1)\n      printf(\"%-4s(%s)  %-2d/%-6s %-3d   \", pfStr, bottomUp ? \"BU\" : \"TD\",\n             precision, lossless ? \"LOSSLS\" : subNameLong[subsamp], jpegQual);\n    if (precision == 8) {\n      for (i = 0; i < h; i++)\n        memcpy(&((unsigned char *)tmpBuf)[pitch * i],\n               &((unsigned char *)srcBuf)[w * ps * i], w * ps);\n    } else {\n      for (i = 0; i < h; i++)\n        memcpy(&((unsigned short *)tmpBuf)[pitch * i],\n               &((unsigned short *)srcBuf)[w * ps * i], w * ps * sampleSize);\n    }\n\n    if (tj3Set(handle, TJPARAM_NOREALLOC, noRealloc) == -1)\n      THROW_TJ();\n    if (tj3Set(handle, TJPARAM_SUBSAMP, subsamp) == -1)\n      THROW_TJ();\n    if (tj3Set(handle, TJPARAM_FASTDCT, fastDCT) == -1)\n      THROW_TJ();\n    if (tj3Set(handle, TJPARAM_OPTIMIZE, optimize) == -1)\n      THROW_TJ();\n    if (tj3Set(handle, TJPARAM_PROGRESSIVE, progressive) == -1)\n      THROW_TJ();\n    if (tj3Set(handle, TJPARAM_ARITHMETIC, arithmetic) == -1)\n      THROW_TJ();\n    if (tj3Set(handle, TJPARAM_LOSSLESS, lossless) == -1)\n      THROW_TJ();\n    if (lossless) {\n      if (tj3Set(handle, TJPARAM_LOSSLESSPSV, jpegQual) == -1)\n        THROW_TJ();\n    } else {\n      if (tj3Set(handle, TJPARAM_QUALITY, jpegQual) == -1)\n        THROW_TJ();\n    }\n    if (tj3Set(handle, TJPARAM_RESTARTBLOCKS, restartIntervalBlocks) == -1)\n      THROW_TJ();\n    if (tj3Set(handle, TJPARAM_RESTARTROWS, restartIntervalRows) == -1)\n      THROW_TJ();\n    if (tj3Set(handle, TJPARAM_MAXMEMORY, maxMemory) == -1)\n      THROW_TJ();\n\n    if (doYUV) {\n      yuvSize = tj3YUVBufSize(tilew, yuvAlign, tileh, subsamp);\n      if (yuvSize == 0)\n        THROW_TJG();\n      if ((yuvBuf = (unsigned char *)malloc(yuvSize)) == NULL)\n        THROW_UNIX(\"allocating YUV buffer\");\n      memset(yuvBuf, 127, yuvSize);\n    }\n\n    /* Benchmark */\n    iter = -1;\n    elapsed = elapsedEncode = 0.;\n    while (1) {\n      int tile = 0;\n\n      totalJpegSize = 0;\n      start = getTime();\n      for (row = 0, srcPtr = srcBuf; row < ntilesh;\n           row++, srcPtr += pitch * tileh * sampleSize) {\n        for (col = 0, srcPtr2 = srcPtr; col < ntilesw;\n             col++, tile++, srcPtr2 += ps * tilew * sampleSize) {\n          int width = min(tilew, w - col * tilew);\n          int height = min(tileh, h - row * tileh);\n\n          if (doYUV) {\n            double startEncode = getTime();\n\n            if (tj3EncodeYUV8(handle, srcPtr2, width, pitch, height, pf,\n                              yuvBuf, yuvAlign) == -1)\n              THROW_TJ();\n            if (iter >= 0) elapsedEncode += getTime() - startEncode;\n            if (tj3CompressFromYUV8(handle, yuvBuf, width, yuvAlign, height,\n                                    &jpegBufs[tile], &jpegSizes[tile]) == -1)\n              THROW_TJ();\n          } else {\n            if (precision == 8) {\n              if (tj3Compress8(handle, srcPtr2, width, pitch, height, pf,\n                               &jpegBufs[tile], &jpegSizes[tile]) == -1)\n                THROW_TJ();\n            } else if (precision == 12) {\n              if (tj3Compress12(handle, (short *)srcPtr2, width, pitch, height,\n                                pf, &jpegBufs[tile], &jpegSizes[tile]) == -1)\n                THROW_TJ();\n            } else {\n              if (tj3Compress16(handle, (unsigned short *)srcPtr2, width,\n                                pitch, height, pf, &jpegBufs[tile],\n                                &jpegSizes[tile]) == -1)\n                THROW_TJ();\n            }\n          }\n          totalJpegSize += jpegSizes[tile];\n        }\n      }\n      elapsed += getTime() - start;\n      if (iter >= 0) {\n        iter++;\n        if (elapsed >= benchTime) break;\n      } else if (elapsed >= warmup) {\n        iter = 0;\n        elapsed = elapsedEncode = 0.;\n      }\n    }\n    if (doYUV) elapsed -= elapsedEncode;\n\n    if (quiet == 1) printf(\"%-5d  %-5d   \", tilew, tileh);\n    if (quiet) {\n      if (doYUV)\n        printf(\"%-6s%s\",\n               sigfig((double)(w * h) / 1000000. *\n                      (double)iter / elapsedEncode, 4, tempStr, 1024),\n               quiet == 2 ? \"\\n\" : \"  \");\n      printf(\"%-6s%s\",\n             sigfig((double)(w * h) / 1000000. * (double)iter / elapsed, 4,\n                    tempStr, 1024),\n             quiet == 2 ? \"\\n\" : \"  \");\n      printf(\"%-6s%s\",\n             sigfig((double)(w * h * ps) / (double)totalJpegSize, 4, tempStr2,\n                    80),\n             quiet == 2 ? \"\\n\" : \"  \");\n    } else {\n      printf(\"\\n%s size: %d x %d\\n\", doTile ? \"Tile\" : \"Image\", tilew, tileh);\n      if (doYUV) {\n        printf(\"Encode YUV    --> Frame rate:         %f fps\\n\",\n               (double)iter / elapsedEncode);\n        printf(\"                  Output image size:  %lu bytes\\n\",\n               (unsigned long)yuvSize);\n        printf(\"                  Compression ratio:  %f:1\\n\",\n               (double)(w * h * ps) / (double)yuvSize);\n        printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n               (double)(w * h) / 1000000. * (double)iter / elapsedEncode);\n        printf(\"                  Output bit stream:  %f Megabits/sec\\n\",\n               (double)yuvSize * 8. / 1000000. * (double)iter / elapsedEncode);\n      }\n      printf(\"%s --> Frame rate:         %f fps\\n\",\n             doYUV ? \"Comp from YUV\" : \"Compress     \",\n             (double)iter / elapsed);\n      printf(\"                  Output image size:  %lu bytes\\n\",\n             (unsigned long)totalJpegSize);\n      printf(\"                  Compression ratio:  %f:1\\n\",\n             (double)(w * h * ps) / (double)totalJpegSize);\n      printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n             (double)(w * h) / 1000000. * (double)iter / elapsed);\n      printf(\"                  Output bit stream:  %f Megabits/sec\\n\",\n             (double)totalJpegSize * 8. / 1000000. * (double)iter / elapsed);\n    }\n    if (tilew == w && tileh == h && doWrite) {\n     SNPRINTF(tempStr, 1024, \"%s_%s_%s%d.jpg\", fileName,\n              lossless ? \"LOSSLS\" : subName[subsamp],\n              lossless ? \"PSV\" : \"Q\", jpegQual);\n      if ((file = fopen(tempStr, \"wb\")) == NULL)\n        THROW_UNIX(\"opening reference image\");\n      if (fwrite(jpegBufs[0], jpegSizes[0], 1, file) != 1)\n        THROW_UNIX(\"writing reference image\");\n      fclose(file);  file = NULL;\n      if (!quiet) printf(\"Reference image written to %s\\n\", tempStr);\n    }\n\n    /* Decompression test */\n    if (!compOnly) {\n      if (decomp(jpegBufs, jpegSizes, tmpBuf, w, h, subsamp, jpegQual,\n                 fileName, tilew, tileh) == -1)\n        goto bailout;\n    } else if (quiet == 1) printf(\"N/A\\n\");\n\n    for (i = 0; i < ntilesw * ntilesh; i++) {\n      tj3Free(jpegBufs[i]);\n      jpegBufs[i] = NULL;\n    }\n    free(jpegBufs);  jpegBufs = NULL;\n    free(jpegSizes);  jpegSizes = NULL;\n    if (doYUV) {\n      free(yuvBuf);  yuvBuf = NULL;\n    }\n\n    if (tilew == w && tileh == h) break;\n  }\n\nbailout:\n  if (file) fclose(file);\n  if (jpegBufs) {\n    for (i = 0; i < ntilesw * ntilesh; i++)\n      tj3Free(jpegBufs[i]);\n  }\n  free(jpegBufs);\n  free(yuvBuf);\n  free(jpegSizes);\n  free(tmpBuf);\n  return retval;\n}\n\n\nstatic int decompTest(char *fileName)\n{\n  FILE *file = NULL;\n  tjhandle handle = NULL;\n  unsigned char **jpegBufs = NULL, *srcBuf = NULL;\n  size_t *jpegSizes = NULL, srcSize, totalJpegSize;\n  tjtransform *t = NULL;\n  double start, elapsed;\n  int ps = tjPixelSize[pf], tile, row, col, i, iter, retval = 0, decompsrc = 0;\n  char *temp = NULL, tempStr[80], tempStr2[80];\n  /* Original image */\n  int w = 0, h = 0, minTile = 16, tilew, tileh, ntilesw = 1, ntilesh = 1,\n    subsamp = -1, cs = -1;\n  /* Transformed image */\n  int tw, th, ttilew, ttileh, tntilesw, tntilesh, tsubsamp;\n\n  if ((file = fopen(fileName, \"rb\")) == NULL)\n    THROW_UNIX(\"opening file\");\n  if (fseek(file, 0, SEEK_END) < 0 ||\n      (srcSize = ftell(file)) == (size_t)-1)\n    THROW_UNIX(\"determining file size\");\n  if ((srcBuf = (unsigned char *)malloc(srcSize)) == NULL)\n    THROW_UNIX(\"allocating memory\");\n  if (fseek(file, 0, SEEK_SET) < 0)\n    THROW_UNIX(\"setting file position\");\n  if (fread(srcBuf, srcSize, 1, file) < 1)\n    THROW_UNIX(\"reading JPEG data\");\n  fclose(file);  file = NULL;\n\n  temp = strrchr(fileName, '.');\n  if (temp != NULL) *temp = '\\0';\n\n  if ((handle = tj3Init(TJINIT_TRANSFORM)) == NULL)\n    THROW_TJG();\n  if (tj3Set(handle, TJPARAM_STOPONWARNING, stopOnWarning) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_BOTTOMUP, bottomUp) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_NOREALLOC, noRealloc) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_FASTUPSAMPLE, fastUpsample) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_FASTDCT, fastDCT) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_SCANLIMIT, limitScans ? 500 : 0) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_MAXMEMORY, maxMemory) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_MAXPIXELS, maxPixels) == -1)\n    THROW_TJ();\n\n  if (tj3DecompressHeader(handle, srcBuf, srcSize) == -1)\n    THROW_TJ();\n  w = tj3Get(handle, TJPARAM_JPEGWIDTH);\n  h = tj3Get(handle, TJPARAM_JPEGHEIGHT);\n  subsamp = tj3Get(handle, TJPARAM_SUBSAMP);\n  precision = tj3Get(handle, TJPARAM_PRECISION);\n  if (tj3Get(handle, TJPARAM_PROGRESSIVE) == 1)\n    printf(\"JPEG image is progressive\\n\\n\");\n  if (tj3Get(handle, TJPARAM_ARITHMETIC) == 1)\n    printf(\"JPEG image uses arithmetic entropy coding\\n\\n\");\n  if (tj3Set(handle, TJPARAM_PROGRESSIVE, progressive) == -1)\n    THROW_TJ();\n  if (tj3Set(handle, TJPARAM_ARITHMETIC, arithmetic) == -1)\n    THROW_TJ();\n\n  lossless = tj3Get(handle, TJPARAM_LOSSLESS);\n  sampleSize = (precision == 8 ? sizeof(unsigned char) : sizeof(short));\n  cs = tj3Get(handle, TJPARAM_COLORSPACE);\n  if (w < 1 || h < 1)\n    THROW(\"reading JPEG header\", \"Invalid image dimensions\");\n  if (cs == TJCS_YCCK || cs == TJCS_CMYK) {\n    pf = TJPF_CMYK;  ps = tjPixelSize[pf];\n  }\n  if (lossless) sf = TJUNSCALED;\n\n  if (tj3SetScalingFactor(handle, sf) == -1)\n    THROW_TJ();\n  if (tj3SetCroppingRegion(handle, cr) == -1)\n    THROW_TJ();\n\n  if (quiet == 1) {\n    printf(\"All performance values in Mpixels/sec\\n\\n\");\n    printf(\"Pixel     JPEG             %s  %s   Xform   Comp    Decomp  \",\n           doTile ? \"Tile \" : \"Image\", doTile ? \"Tile \" : \"Image\");\n    if (doYUV) printf(\"Decode\");\n    printf(\"\\n\");\n    printf(\"Format    Format           Width  Height  Perf    Ratio   Perf    \");\n    if (doYUV) printf(\"Perf\");\n    printf(\"\\n\\n\");\n  } else if (!quiet)\n    printf(\">>>>>  %d-bit JPEG (%s) --> %s (%s)  <<<<<\\n\", precision,\n           formatName(subsamp, cs, tempStr), pixFormatStr[pf],\n           bottomUp ? \"Bottom-up\" : \"Top-down\");\n\n  if (doTile) {\n    if (subsamp == TJSAMP_UNKNOWN)\n      THROW(\"transforming\",\n            \"Could not determine subsampling level of JPEG image\");\n    minTile = max(tjMCUWidth[subsamp], tjMCUHeight[subsamp]);\n  }\n  for (tilew = doTile ? minTile : w, tileh = doTile ? minTile : h; ;\n       tilew *= 2, tileh *= 2) {\n    if (tilew > w) tilew = w;\n    if (tileh > h) tileh = h;\n    ntilesw = (w + tilew - 1) / tilew;\n    ntilesh = (h + tileh - 1) / tileh;\n\n    if ((jpegBufs = (unsigned char **)malloc(sizeof(unsigned char *) *\n                                             ntilesw * ntilesh)) == NULL)\n      THROW_UNIX(\"allocating JPEG tile array\");\n    memset(jpegBufs, 0, sizeof(unsigned char *) * ntilesw * ntilesh);\n    if ((jpegSizes = (size_t *)malloc(sizeof(size_t) * ntilesw *\n                                      ntilesh)) == NULL)\n      THROW_UNIX(\"allocating JPEG size array\");\n    memset(jpegSizes, 0, sizeof(size_t) * ntilesw * ntilesh);\n\n    tsubsamp = (xformOpt & TJXOPT_GRAY) ? TJSAMP_GRAY : subsamp;\n    if (xformOp == TJXOP_TRANSPOSE || xformOp == TJXOP_TRANSVERSE ||\n        xformOp == TJXOP_ROT90 || xformOp == TJXOP_ROT270) {\n      if (tsubsamp == TJSAMP_422) tsubsamp = TJSAMP_440;\n      else if (tsubsamp == TJSAMP_440) tsubsamp = TJSAMP_422;\n      else if (tsubsamp == TJSAMP_411) tsubsamp = TJSAMP_441;\n      else if (tsubsamp == TJSAMP_441) tsubsamp = TJSAMP_411;\n    }\n\n    if (noRealloc &&\n        (doTile || xformOp != TJXOP_NONE || xformOpt != 0 || customFilter)) {\n      for (i = 0; i < ntilesw * ntilesh; i++) {\n        size_t jpegBufSize;\n\n        if (xformOp == TJXOP_TRANSPOSE || xformOp == TJXOP_TRANSVERSE ||\n            xformOp == TJXOP_ROT90 || xformOp == TJXOP_ROT270)\n          jpegBufSize = tj3JPEGBufSize(tileh, tilew, tsubsamp);\n        else\n          jpegBufSize = tj3JPEGBufSize(tilew, tileh, tsubsamp);\n        if (jpegBufSize == 0)\n          THROW_TJG();\n        if ((jpegBufs[i] = tj3Alloc(jpegBufSize)) == NULL)\n          THROW_UNIX(\"allocating JPEG tiles\");\n      }\n    }\n\n    tw = w;  th = h;  ttilew = tilew;  ttileh = tileh;\n    if (!quiet) {\n      printf(\"\\n%s size: %d x %d\", doTile ? \"Tile\" : \"Image\", ttilew, ttileh);\n      if (sf.num != 1 || sf.denom != 1 || IS_CROPPED(cr))\n        printf(\" --> %d x %d\", CROPPED_WIDTH(tw), CROPPED_HEIGHT(th));\n      printf(\"\\n\");\n    } else if (quiet == 1) {\n      printf(\"%-4s(%s)  %-14s   \", pixFormatStr[pf],\n             bottomUp ? \"BU\" : \"TD\", formatName(subsamp, cs, tempStr));\n      printf(\"%-5d  %-5d   \", CROPPED_WIDTH(tilew), CROPPED_HEIGHT(tileh));\n    }\n\n    if (doTile || xformOp != TJXOP_NONE || xformOpt != 0 || customFilter) {\n      if ((t = (tjtransform *)malloc(sizeof(tjtransform) * ntilesw *\n                                     ntilesh)) == NULL)\n        THROW_UNIX(\"allocating image transform array\");\n\n      if (xformOp == TJXOP_TRANSPOSE || xformOp == TJXOP_TRANSVERSE ||\n          xformOp == TJXOP_ROT90 || xformOp == TJXOP_ROT270) {\n        tw = h;  th = w;  ttilew = tileh;  ttileh = tilew;\n      }\n\n      if (xformOp != TJXOP_NONE && xformOp != TJXOP_TRANSPOSE &&\n          subsamp == TJSAMP_UNKNOWN)\n        THROW(\"transforming\",\n              \"Could not determine subsampling level of JPEG image\");\n      if (xformOp == TJXOP_HFLIP || xformOp == TJXOP_TRANSVERSE ||\n          xformOp == TJXOP_ROT90 || xformOp == TJXOP_ROT180)\n        tw = tw - (tw % tjMCUWidth[tsubsamp]);\n      if (xformOp == TJXOP_VFLIP || xformOp == TJXOP_TRANSVERSE ||\n          xformOp == TJXOP_ROT180 || xformOp == TJXOP_ROT270)\n        th = th - (th % tjMCUHeight[tsubsamp]);\n      tntilesw = (tw + ttilew - 1) / ttilew;\n      tntilesh = (th + ttileh - 1) / ttileh;\n\n      for (row = 0, tile = 0; row < tntilesh; row++) {\n        for (col = 0; col < tntilesw; col++, tile++) {\n          t[tile].r.w = min(ttilew, tw - col * ttilew);\n          t[tile].r.h = min(ttileh, th - row * ttileh);\n          t[tile].r.x = col * ttilew;\n          t[tile].r.y = row * ttileh;\n          t[tile].op = xformOp;\n          t[tile].options = xformOpt | TJXOPT_TRIM;\n          t[tile].customFilter = customFilter;\n          if (t[tile].options & TJXOPT_NOOUTPUT && jpegBufs[tile]) {\n            tj3Free(jpegBufs[tile]);  jpegBufs[tile] = NULL;\n          }\n        }\n      }\n\n      iter = -1;\n      elapsed = 0.;\n      while (1) {\n        start = getTime();\n        if (tj3Transform(handle, srcBuf, srcSize, tntilesw * tntilesh,\n                         jpegBufs, jpegSizes, t) == -1)\n          THROW_TJ();\n        elapsed += getTime() - start;\n        if (iter >= 0) {\n          iter++;\n          if (elapsed >= benchTime) break;\n        } else if (elapsed >= warmup) {\n          iter = 0;\n          elapsed = 0.;\n        }\n      }\n\n      free(t);  t = NULL;\n\n      for (tile = 0, totalJpegSize = 0; tile < tntilesw * tntilesh; tile++)\n        totalJpegSize += jpegSizes[tile];\n\n      if (quiet) {\n        printf(\"%-6s%s%-6s%s\",\n               sigfig((double)(w * h) / 1000000. / elapsed, 4, tempStr, 80),\n               quiet == 2 ? \"\\n\" : \"  \",\n               sigfig((double)(w * h * ps) / (double)totalJpegSize, 4,\n                      tempStr2, 80),\n               quiet == 2 ? \"\\n\" : \"  \");\n      } else {\n        printf(\"Transform     --> Frame rate:         %f fps\\n\",\n               1.0 / elapsed);\n        printf(\"                  Output image size:  %lu bytes\\n\",\n               (unsigned long)totalJpegSize);\n        printf(\"                  Compression ratio:  %f:1\\n\",\n               (double)(w * h * ps) / (double)totalJpegSize);\n        printf(\"                  Throughput:         %f Megapixels/sec\\n\",\n               (double)(w * h) / 1000000. / elapsed);\n        printf(\"                  Output bit stream:  %f Megabits/sec\\n\",\n               (double)totalJpegSize * 8. / 1000000. / elapsed);\n      }\n    } else {\n      if (quiet == 1) printf(\"N/A     N/A     \");\n      tj3Free(jpegBufs[0]);\n      jpegBufs[0] = NULL;\n      decompsrc = 1;\n    }\n\n    if (w == tilew) ttilew = tw;\n    if (h == tileh) ttileh = th;\n    if (!(xformOpt & TJXOPT_NOOUTPUT)) {\n      if (decomp(decompsrc ? &srcBuf : jpegBufs,\n                 decompsrc ? &srcSize : jpegSizes, NULL, tw, th, tsubsamp, 0,\n                 fileName, ttilew, ttileh) == -1)\n        goto bailout;\n    } else if (quiet == 1) printf(\"N/A\\n\");\n\n    for (i = 0; i < ntilesw * ntilesh; i++) {\n      tj3Free(jpegBufs[i]);\n      jpegBufs[i] = NULL;\n    }\n    free(jpegBufs);  jpegBufs = NULL;\n    free(jpegSizes);  jpegSizes = NULL;\n\n    if (tilew == w && tileh == h) break;\n  }\n\nbailout:\n  if (file) fclose(file);\n  if (jpegBufs) {\n    for (i = 0; i < ntilesw * ntilesh; i++)\n      tj3Free(jpegBufs[i]);\n  }\n  free(jpegBufs);\n  free(jpegSizes);\n  free(srcBuf);\n  free(t);\n  tj3Destroy(handle);\n  return retval;\n}\n\n\nstatic void usage(char *progName)\n{\n  int i;\n\n  printf(\"USAGE: %s\\n\", progName);\n  printf(\"       <Inputimage (BMP|PPM)> <Quality or PSV> [options]\\n\\n\");\n  printf(\"       %s\\n\", progName);\n  printf(\"       <Inputimage (JPG)> [options]\\n\");\n\n  printf(\"\\nGENERAL OPTIONS\\n\");\n  printf(\"---------------\\n\");\n  printf(\"-alloc = Dynamically allocate JPEG buffers\\n\");\n  printf(\"-benchtime T = Run each benchmark for at least T seconds [default = 5.0]\\n\");\n  printf(\"-bmp = Use Windows Bitmap format for output images [default = PPM]\\n\");\n  printf(\"     ** 8-bit data precision only **\\n\");\n  printf(\"-bottomup = Use bottom-up row order for packed-pixel source/destination buffers\\n\");\n  printf(\"-componly = Stop after running compression tests.  Do not test decompression.\\n\");\n  printf(\"-lossless = Generate lossless JPEG images when compressing (implies\\n\");\n  printf(\"     -subsamp 444).  PSV is the predictor selection value (1-7).\\n\");\n  printf(\"-maxmemory N = Memory limit (in megabytes) for intermediate buffers used with\\n\");\n  printf(\"     progressive JPEG compression and decompression, Huffman table\\n\");\n  printf(\"     optimization, lossless JPEG compression, and lossless transformation\\n\");\n  printf(\"     [default = no limit]\\n\");\n  printf(\"-maxpixels N = Input image size limit (in pixels) [default = no limit]\\n\");\n  printf(\"-nowrite = Do not write reference or output images (improves consistency of\\n\");\n  printf(\"     benchmark results)\\n\");\n  printf(\"-rgb, -bgr, -rgbx, -bgrx, -xbgr, -xrgb =\\n\");\n  printf(\"     Use the specified pixel format for packed-pixel source/destination buffers\\n\");\n  printf(\"     [default = BGR]\\n\");\n  printf(\"-cmyk = Indirectly test YCCK JPEG compression/decompression\\n\");\n  printf(\"     (use the CMYK pixel format for packed-pixel source/destination buffers)\\n\");\n  printf(\"-precision N = Use N-bit data precision when compressing [N is 8, 12, or 16;\\n\");\n  printf(\"     default = 8; if N is 16, then -lossless must also be specified]\\n\");\n  printf(\"     (-precision 12 implies -optimize unless -arithmetic is also specified)\\n\");\n  printf(\"-quiet = Output results in tabular rather than verbose format\\n\");\n  printf(\"-restart N = When compressing, add a restart marker every N MCU rows\\n\");\n  printf(\"     [default = 0 (no restart markers)].  Append 'B' to specify the restart\\n\");\n  printf(\"     marker interval in MCUs (lossy only.)\\n\");\n  printf(\"-stoponwarning = Immediately discontinue the current\\n\");\n  printf(\"     compression/decompression/transform operation if a warning (non-fatal\\n\");\n  printf(\"     error) occurs\\n\");\n  printf(\"-tile = Compress/transform the input image into separate JPEG tiles of varying\\n\");\n  printf(\"     sizes (useful for measuring JPEG overhead)\\n\");\n  printf(\"-warmup T = Run each benchmark for T seconds [default = 1.0] prior to starting\\n\");\n  printf(\"     the timer, in order to prime the caches and thus improve the consistency\\n\");\n  printf(\"     of the benchmark results\\n\");\n\n  printf(\"\\nLOSSY JPEG OPTIONS\\n\");\n  printf(\"------------------\\n\");\n  printf(\"-arithmetic = Use arithmetic entropy coding in JPEG images generated by\\n\");\n  printf(\"     compression and transform operations (can be combined with -progressive)\\n\");\n  printf(\"-crop WxH+X+Y = Decompress only the specified region of the JPEG image, where W\\n\");\n  printf(\"     and H are the width and height of the region (0 = maximum possible width\\n\");\n  printf(\"     or height) and X and Y are the left and upper boundary of the region, all\\n\");\n  printf(\"     specified relative to the scaled image dimensions.  X must be divible by\\n\");\n  printf(\"     the scaled iMCU width.\\n\");\n  printf(\"-fastdct = Use the fastest DCT/IDCT algorithm available\\n\");\n  printf(\"-fastupsample = Use the fastest chrominance upsampling algorithm available\\n\");\n  printf(\"-optimize = Compute optimal Huffman tables for JPEG images generated by\\n\");\n  printf(\"     compession and transform operations\\n\");\n  printf(\"-progressive = Generate progressive JPEG images when compressing or\\n\");\n  printf(\"     transforming (can be combined with -arithmetic; implies -optimize unless\\n\");\n  printf(\"     -arithmetic is also specified)\\n\");\n  printf(\"-limitscans = Refuse to decompress or transform progressive JPEG images that\\n\");\n  printf(\"     have an unreasonably large number of scans\\n\");\n  printf(\"-scale M/N = When decompressing, scale the width/height of the JPEG image by a\\n\");\n  printf(\"     factor of M/N (M/N = \");\n  for (i = 0; i < nsf; i++) {\n    printf(\"%d/%d\", scalingFactors[i].num, scalingFactors[i].denom);\n    if (nsf == 2 && i != nsf - 1) printf(\" or \");\n    else if (nsf > 2) {\n      if (i != nsf - 1) printf(\", \");\n      if (i == nsf - 2) printf(\"or \");\n    }\n    if (i % 8 == 0 && i != 0) printf(\"\\n     \");\n  }\n  printf(\")\\n\");\n  printf(\"-subsamp S = When compressing, use the specified level of chrominance\\n\");\n  printf(\"     subsampling (S = 444, 422, 440, 420, 411, 441, or GRAY) [default = test\\n\");\n  printf(\"     Grayscale, 4:2:0, 4:2:2, and 4:4:4 in sequence]\\n\");\n  printf(\"-hflip, -vflip, -transpose, -transverse, -rot90, -rot180, -rot270 =\\n\");\n  printf(\"     Perform the specified lossless transform operation on the input image\\n\");\n  printf(\"     prior to decompression (these operations are mutually exclusive)\\n\");\n  printf(\"-grayscale = Transform the input image into a grayscale JPEG image prior to\\n\");\n  printf(\"     decompression (can be combined with the other transform operations above)\\n\");\n  printf(\"-copynone = Do not copy any extra markers (including Exif and ICC profile data)\\n\");\n  printf(\"     when transforming the input image\\n\");\n  printf(\"-yuv = Compress from/decompress to intermediate planar YUV images\\n\");\n  printf(\"     ** 8-bit data precision only **\\n\");\n  printf(\"-yuvpad N = The number of bytes by which each row in each plane of an\\n\");\n  printf(\"     intermediate YUV image is evenly divisible (N must be a power of 2)\\n\");\n  printf(\"     [default = 1]\\n\");\n\n  printf(\"\\nNOTE:  If the quality/PSV is specified as a range (e.g. 90-100 or 1-4), a\\n\");\n  printf(\"separate test will be performed for all values in the range.\\n\\n\");\n  exit(1);\n}\n\n\nint main(int argc, char *argv[])\n{\n  void *srcBuf = NULL;\n  int w = 0, h = 0, i, j, minQual = -1, maxQual = -1;\n  char *temp;\n  int minArg = 2, retval = 0, subsamp = -1;\n  tjhandle handle = NULL;\n\n  if ((scalingFactors = tj3GetScalingFactors(&nsf)) == NULL || nsf == 0)\n    THROW(\"executing tj3GetScalingFactors()\", tj3GetErrorStr(NULL));\n\n  if (argc < minArg) usage(argv[0]);\n\n  temp = strrchr(argv[1], '.');\n  if (temp != NULL) {\n    if (!strcasecmp(temp, \".bmp\")) ext = \"bmp\";\n    if (!strcasecmp(temp, \".jpg\") || !strcasecmp(temp, \".jpeg\"))\n      decompOnly = 1;\n  }\n\n  printf(\"\\n\");\n\n  if (!decompOnly) {\n    minArg = 3;\n    if (argc < minArg) usage(argv[0]);\n    minQual = atoi(argv[2]);\n    if ((temp = strchr(argv[2], '-')) != NULL && strlen(temp) > 1 &&\n        sscanf(&temp[1], \"%d\", &maxQual) == 1 && maxQual > minQual) {}\n    else maxQual = minQual;\n  }\n\n  if (argc > minArg) {\n    for (i = minArg; i < argc; i++) {\n      if (!strcasecmp(argv[i], \"-tile\")) {\n        doTile = 1;  xformOpt |= TJXOPT_CROP;\n      } else if (!strcasecmp(argv[i], \"-precision\") && i < argc - 1) {\n        int tempi = atoi(argv[++i]);\n\n        if (tempi != 8 && tempi != 12 && tempi != 16)\n          usage(argv[0]);\n        precision = tempi;\n      } else if (!strcasecmp(argv[i], \"-fastupsample\")) {\n        printf(\"Using fastest upsampling algorithm\\n\\n\");\n        fastUpsample = 1;\n      } else if (!strcasecmp(argv[i], \"-fastdct\")) {\n        printf(\"Using fastest DCT/IDCT algorithm\\n\\n\");\n        fastDCT = 1;\n      } else if (!strcasecmp(argv[i], \"-optimize\")) {\n        optimize = 1;\n        xformOpt |= TJXOPT_OPTIMIZE;\n      } else if (!strcasecmp(argv[i], \"-progressive\")) {\n        printf(\"Generating progressive JPEG images\\n\\n\");\n        progressive = 1;\n        xformOpt |= TJXOPT_PROGRESSIVE;\n      } else if (!strcasecmp(argv[i], \"-arithmetic\")) {\n        printf(\"Using arithmetic entropy coding\\n\\n\");\n        arithmetic = 1;\n        xformOpt |= TJXOPT_ARITHMETIC;\n      } else if (!strcasecmp(argv[i], \"-lossless\"))\n        lossless = 1;\n      else if (!strcasecmp(argv[i], \"-rgb\"))\n        pf = TJPF_RGB;\n      else if (!strcasecmp(argv[i], \"-rgbx\"))\n        pf = TJPF_RGBX;\n      else if (!strcasecmp(argv[i], \"-bgr\"))\n        pf = TJPF_BGR;\n      else if (!strcasecmp(argv[i], \"-bgrx\"))\n        pf = TJPF_BGRX;\n      else if (!strcasecmp(argv[i], \"-xbgr\"))\n        pf = TJPF_XBGR;\n      else if (!strcasecmp(argv[i], \"-xrgb\"))\n        pf = TJPF_XRGB;\n      else if (!strcasecmp(argv[i], \"-cmyk\"))\n        pf = TJPF_CMYK;\n      else if (!strcasecmp(argv[i], \"-bottomup\"))\n        bottomUp = 1;\n      else if (!strcasecmp(argv[i], \"-quiet\"))\n        quiet = 1;\n      else if (!strcasecmp(argv[i], \"-qq\"))\n        quiet = 2;\n      else if (!strcasecmp(argv[i], \"-scale\") && i < argc - 1) {\n        int temp1 = 0, temp2 = 0, match = 0;\n\n        if (sscanf(argv[++i], \"%d/%d\", &temp1, &temp2) == 2) {\n          for (j = 0; j < nsf; j++) {\n            if ((double)temp1 / (double)temp2 ==\n                (double)scalingFactors[j].num /\n                (double)scalingFactors[j].denom) {\n              sf = scalingFactors[j];\n              match = 1;  break;\n            }\n          }\n          if (!match) usage(argv[0]);\n        } else usage(argv[0]);\n      } else if (!strcasecmp(argv[i], \"-crop\") && i < argc - 1) {\n        int temp1 = -1, temp2 = -1, temp3 = -1, temp4 = -1;\n\n        if (sscanf(argv[++i], \"%dx%d+%d+%d\", &temp1, &temp2, &temp3,\n                   &temp4) == 4 &&\n            temp1 >= 0 && temp2 >= 0 && temp3 >= 0 && temp4 >= 0) {\n          cr.w = temp1;  cr.h = temp2;  cr.x = temp3;  cr.y = temp4;\n        } else usage(argv[0]);\n      } else if (!strcasecmp(argv[i], \"-hflip\"))\n        xformOp = TJXOP_HFLIP;\n      else if (!strcasecmp(argv[i], \"-vflip\"))\n        xformOp = TJXOP_VFLIP;\n      else if (!strcasecmp(argv[i], \"-transpose\"))\n        xformOp = TJXOP_TRANSPOSE;\n      else if (!strcasecmp(argv[i], \"-transverse\"))\n        xformOp = TJXOP_TRANSVERSE;\n      else if (!strcasecmp(argv[i], \"-rot90\"))\n        xformOp = TJXOP_ROT90;\n      else if (!strcasecmp(argv[i], \"-rot180\"))\n        xformOp = TJXOP_ROT180;\n      else if (!strcasecmp(argv[i], \"-rot270\"))\n        xformOp = TJXOP_ROT270;\n      else if (!strcasecmp(argv[i], \"-grayscale\"))\n        xformOpt |= TJXOPT_GRAY;\n      else if (!strcasecmp(argv[i], \"-custom\"))\n        customFilter = dummyDCTFilter;\n      else if (!strcasecmp(argv[i], \"-nooutput\"))\n        xformOpt |= TJXOPT_NOOUTPUT;\n      else if (!strcasecmp(argv[i], \"-copynone\"))\n        xformOpt |= TJXOPT_COPYNONE;\n      else if (!strcasecmp(argv[i], \"-benchtime\") && i < argc - 1) {\n        double tempd = atof(argv[++i]);\n\n        if (tempd > 0.0) benchTime = tempd;\n        else usage(argv[0]);\n      } else if (!strcasecmp(argv[i], \"-warmup\") && i < argc - 1) {\n        double tempd = atof(argv[++i]);\n\n        if (tempd >= 0.0) warmup = tempd;\n        else usage(argv[0]);\n        printf(\"Warmup time = %.1f seconds\\n\\n\", warmup);\n      } else if (!strcasecmp(argv[i], \"-alloc\"))\n        noRealloc = 0;\n      else if (!strcasecmp(argv[i], \"-bmp\"))\n        ext = \"bmp\";\n      else if (!strcasecmp(argv[i], \"-yuv\")) {\n        printf(\"Testing planar YUV encoding/decoding\\n\\n\");\n        doYUV = 1;\n      } else if (!strcasecmp(argv[i], \"-yuvpad\") && i < argc - 1) {\n        int tempi = atoi(argv[++i]);\n\n        if (tempi >= 1 && (tempi & (tempi - 1)) == 0) yuvAlign = tempi;\n        else usage(argv[0]);\n      } else if (!strcasecmp(argv[i], \"-subsamp\") && i < argc - 1) {\n        i++;\n        if (toupper(argv[i][0]) == 'G') subsamp = TJSAMP_GRAY;\n        else {\n          int tempi = atoi(argv[i]);\n\n          switch (tempi) {\n          case 444:  subsamp = TJSAMP_444;  break;\n          case 422:  subsamp = TJSAMP_422;  break;\n          case 440:  subsamp = TJSAMP_440;  break;\n          case 420:  subsamp = TJSAMP_420;  break;\n          case 411:  subsamp = TJSAMP_411;  break;\n          case 441:  subsamp = TJSAMP_441;  break;\n          default:  usage(argv[0]);\n          }\n        }\n      } else if (!strcasecmp(argv[i], \"-componly\"))\n        compOnly = 1;\n      else if (!strcasecmp(argv[i], \"-nowrite\"))\n        doWrite = 0;\n      else if (!strcasecmp(argv[i], \"-limitscans\"))\n        limitScans = 1;\n      else if (!strcasecmp(argv[i], \"-maxmemory\") && i < argc - 1) {\n        int tempi = atoi(argv[++i]);\n\n        if (tempi < 0) usage(argv[0]);\n        maxMemory = tempi;\n      } else if (!strcasecmp(argv[i], \"-maxpixels\") && i < argc - 1) {\n        int tempi = atoi(argv[++i]);\n\n        if (tempi < 0) usage(argv[0]);\n        maxPixels = tempi;\n      } else if (!strcasecmp(argv[i], \"-restart\") && i < argc - 1) {\n        int tempi = -1, nscan;  char tempc = 0;\n\n        if ((nscan = sscanf(argv[++i], \"%d%c\", &tempi, &tempc)) < 1 ||\n            tempi < 0 || tempi > 65535 ||\n            (nscan == 2 && tempc != 'B' && tempc != 'b'))\n          usage(argv[0]);\n\n        if (tempc == 'B' || tempc == 'b')\n          restartIntervalBlocks = tempi;\n        else\n          restartIntervalRows = tempi;\n      } else if (!strcasecmp(argv[i], \"-stoponwarning\"))\n        stopOnWarning = 1;\n      else usage(argv[0]);\n    }\n  }\n\n  if (optimize && !progressive && !arithmetic && !lossless && precision != 12)\n    printf(\"Computing optimal Huffman tables\\n\\n\");\n\n  if (lossless)\n    subsamp = TJSAMP_444;\n\n  if (precision == 16 && !lossless) {\n    printf(\"ERROR: -lossless must be specified along with -precision 16\\n\");\n    retval = -1;  goto bailout;\n  }\n  if (precision != 8 && doYUV) {\n    printf(\"ERROR: -yuv requires 8-bit data precision\\n\");\n    retval = -1;  goto bailout;\n  }\n  if (lossless && doYUV) {\n    printf(\"ERROR: -lossless and -yuv are incompatible\\n\");\n    retval = -1;  goto bailout;\n  }\n  sampleSize = (precision == 8 ? sizeof(unsigned char) : sizeof(short));\n\n  if ((sf.num != 1 || sf.denom != 1) && doTile) {\n    printf(\"Disabling tiled compression/decompression tests, because those tests do not\\n\");\n    printf(\"work when scaled decompression is enabled.\\n\\n\");\n    doTile = 0;  xformOpt &= (~TJXOPT_CROP);\n  }\n\n  if (IS_CROPPED(cr)) {\n    if (!decompOnly) {\n      printf(\"ERROR: Partial image decompression can only be enabled for JPEG input images\\n\");\n      retval = -1;  goto bailout;\n    }\n    if (doTile) {\n      printf(\"Disabling tiled compression/decompression tests, because those tests do not\\n\");\n      printf(\"work when partial image decompression is enabled.\\n\\n\");\n      doTile = 0;  xformOpt &= (~TJXOPT_CROP);\n    }\n    if (doYUV) {\n      printf(\"ERROR: -crop and -yuv are incompatible\\n\");\n      retval = -1;  goto bailout;\n    }\n  }\n\n  if (!noRealloc && doTile) {\n    printf(\"Disabling tiled compression/decompression tests, because those tests do not\\n\");\n    printf(\"work when dynamic JPEG buffer allocation is enabled.\\n\\n\");\n    doTile = 0;  xformOpt &= (~TJXOPT_CROP);\n  }\n\n  if (!decompOnly) {\n    if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n      THROW_TJG();\n    if (tj3Set(handle, TJPARAM_STOPONWARNING, stopOnWarning) == -1)\n      THROW_TJ();\n    if (tj3Set(handle, TJPARAM_BOTTOMUP, bottomUp) == -1)\n      THROW_TJ();\n    if (tj3Set(handle, TJPARAM_MAXPIXELS, maxPixels) == -1)\n      THROW_TJ();\n\n    if (precision == 8) {\n      if ((srcBuf = tj3LoadImage8(handle, argv[1], &w, 1, &h, &pf)) == NULL)\n        THROW_TJ();\n    } else if (precision == 12) {\n      if ((srcBuf = tj3LoadImage12(handle, argv[1], &w, 1, &h, &pf)) == NULL)\n        THROW_TJ();\n    } else {\n      if ((srcBuf = tj3LoadImage16(handle, argv[1], &w, 1, &h, &pf)) == NULL)\n        THROW_TJ();\n    }\n    temp = strrchr(argv[1], '.');\n    if (temp != NULL) *temp = '\\0';\n  }\n\n  if (quiet == 1 && !decompOnly) {\n    printf(\"All performance values in Mpixels/sec\\n\\n\");\n    printf(\"Pixel     JPEG      JPEG  %s  %s   \",\n           doTile ? \"Tile \" : \"Image\", doTile ? \"Tile \" : \"Image\");\n    if (doYUV) printf(\"Encode  \");\n    printf(\"Comp    Comp    Decomp  \");\n    if (doYUV) printf(\"Decode\");\n    printf(\"\\n\");\n    printf(\"Format    Format    %s  Width  Height  \",\n           lossless ? \"PSV \" : \"Qual\");\n    if (doYUV) printf(\"Perf    \");\n    printf(\"Perf    Ratio   Perf    \");\n    if (doYUV) printf(\"Perf\");\n    printf(\"\\n\\n\");\n  }\n\n  if (decompOnly) {\n    decompTest(argv[1]);\n    printf(\"\\n\");\n    goto bailout;\n  }\n  if (lossless) {\n    if (minQual < 1 || minQual > 7 || maxQual < 1 || maxQual > 7) {\n      puts(\"ERROR: PSV must be between 1 and 7.\");\n      exit(1);\n    }\n  } else {\n    if (minQual < 1 || minQual > 100 || maxQual < 1 || maxQual > 100) {\n      puts(\"ERROR: Quality must be between 1 and 100.\");\n      exit(1);\n    }\n  }\n  if (subsamp >= 0 && subsamp < TJ_NUMSAMP) {\n    for (i = maxQual; i >= minQual; i--)\n      fullTest(handle, srcBuf, w, h, subsamp, i, argv[1]);\n    printf(\"\\n\");\n  } else {\n    if (pf != TJPF_CMYK) {\n      for (i = maxQual; i >= minQual; i--)\n        fullTest(handle, srcBuf, w, h, TJSAMP_GRAY, i, argv[1]);\n      printf(\"\\n\");\n    }\n    for (i = maxQual; i >= minQual; i--)\n      fullTest(handle, srcBuf, w, h, TJSAMP_420, i, argv[1]);\n    printf(\"\\n\");\n    for (i = maxQual; i >= minQual; i--)\n      fullTest(handle, srcBuf, w, h, TJSAMP_422, i, argv[1]);\n    printf(\"\\n\");\n    for (i = maxQual; i >= minQual; i--)\n      fullTest(handle, srcBuf, w, h, TJSAMP_444, i, argv[1]);\n    printf(\"\\n\");\n  }\n\nbailout:\n  tj3Destroy(handle);\n  tj3Free(srcBuf);\n  return retval;\n}\n"
        },
        {
          "name": "tjbenchtest.in",
          "type": "blob",
          "size": 20.4560546875,
          "content": "#!/bin/bash\n\nset -u\nset -e\ntrap onexit INT\ntrap onexit TERM\ntrap onexit EXIT\n\nonexit()\n{\n\tif [ -d $OUTDIR ]; then\n\t\trm -rf $OUTDIR\n\tfi\n}\n\nrunme()\n{\n\techo \\*\\*\\* $*\n\t\"$@\"\n}\n\nEXT=bmp\nIMAGES=\"vgl_5674_0098.${EXT} vgl_6434_0018a.${EXT} vgl_6548_0026a.${EXT} shira_bird8.${EXT}\"\nIMGDIR=@CMAKE_CURRENT_SOURCE_DIR@/testimages\nOUTDIR=`mktemp -d /tmp/__tjbenchtest_output.XXXXXX`\nEXEDIR=@CMAKE_CURRENT_BINARY_DIR@\nJAVA=\"@Java_JAVA_EXECUTABLE@\"\nJAVAARGS=\"-cp $EXEDIR/java/turbojpeg.jar -Djava.library.path=$EXEDIR\"\nTJBENCH=$EXEDIR/tjbench\nBMPARG=\nNSARG=\nYUVARG=\nALLOC=0\nALLOCARG=\nENTROPYARG=\nJAVAARG=\nLOSSLSARG=\nLOSSLSPSV=\nTJQUAL=95\nx1SUBSAMP=\"444 GRAY\"\nx24SUBSAMP=\"422 440 420 411 441\"\nALLSUBSAMP=\"444 422 440 420 411 441 GRAY\"\nPRECISION=8\nif [ \"$EXT\" = \"bmp\" ]; then BMPARG=-bmp; fi\n\nif [ -d $OUTDIR ]; then\n\trm -rf $OUTDIR\nfi\nmkdir -p $OUTDIR\n\nwhile [ $# -gt 0 ]; do\n\tcase \"$1\" in\n\t-yuv)\n\t\tNSARG=-nosmooth\n\t\tYUVARG=-yuv\n\n# NOTE: The combination of tj3EncodeYUV*() and tj3CompressFromYUV*() does not\n# always produce bitwise-identical results to tj3Compress*() if subsampling is\n# enabled.  In both cases, if the image width or height are not evenly\n# divisible by the MCU width/height, then the bottom and/or right edge are\n# expanded.  However, the libjpeg code performs this expansion prior to\n# downsampling, and TurboJPEG performs it in tj3CompressFromYUV*(), which is\n# after downsampling.  Thus, the two will agree only if the width/height along\n# each downsampled dimension is an odd number or is evenly divisible by the MCU\n# width/height.  This disagreement basically amounts to a round-off error, but\n# there is no easy way around it, so for now, we just test the only image that\n# works.  (NOTE: shira_bird8 does not suffer from the above issue, but it\n# suffers from an unrelated problem whereby the combination of\n# tj3DecompressToYUV*() and tj3DecodeYUV*() does not produce bitwise-identical\n# results to tj3Decompress*() if decompression scaling is enabled.  This latter\n# phenomenon is not yet fully understood but is also believed to be some sort\n# of round-off error.)\n\t\tIMAGES=\"vgl_6548_0026a.${EXT}\"\n\t\t;;\n\t-alloc)\n\t\tALLOCARG=-alloc\n\t\tALLOC=1\n\t\t;;\n\t-java)\n\t\tJAVAARG=-java\n\t\tTJBENCH=\"$JAVA $JAVAARGS TJBench\"\n\t\t;;\n\t-optimize)\n\t\tENTROPYARG=-optimize\n\t\t;;\n\t-progressive)\n\t\tif [ \"$ENTROPYARG\" = \"-arithmetic\" ]; then\n\t\t\tENTROPYARG=-progressive-arithmetic\n\t\telse\n\t\t\tENTROPYARG=-progressive\n\t\tfi\n\t\t;;\n\t-arithmetic)\n\t\tif [ \"$ENTROPYARG\" = \"-progressive\" ]; then\n\t\t\tENTROPYARG=-progressive-arithmetic\n\t\telse\n\t\t\tENTROPYARG=-arithmetic\n\t\tfi\n\t\t;;\n\t-lossless)\n\t\tLOSSLSARG=\"-lossless\"\n\t\tLOSSLSPSV=4\n\t\tTJQUAL=4\n\t\tx1SUBSAMP=444\n\t\tx24SUBSAMP=444\n\t\tALLSUBSAMP=444\n\t\t;;\n\t-precision)\n\t\tshift\n\t\tPRECISION=$1\n\t\tif [ $PRECISION != 8 ]; then\n\t\t\tEXT=ppm\n\t\t\tIMAGES=\"monkey16.${EXT}\"\n\t\t\tBMPARG=\n\t\tfi\n\t\t;;\n\tesac\n\tshift\ndone\n\nif [ $PRECISION = 8 -a \"$YUVARG\" = \"\" ]; then\n\tif [ \"$ENTROPYARG\" = \"-optimize\" ]; then\n\t\tIMAGES=\"vgl_6434_0018a.${EXT}\"\n\telif [ \"$ENTROPYARG\" = \"-progressive\" ]; then\n\t\tIMAGES=\"vgl_6548_0026a.${EXT}\"\n\telif [ \"$ENTROPYARG\" = \"-arithmetic\" -o \\\n\t\t\"$ENTROPYARG\" = \"-progressive-arithmetic\" ]; then\n\t\tIMAGES=\"shira_bird8.${EXT}\"\n\tfi\nfi\n\nexec >$EXEDIR/tjbenchtest$JAVAARG$YUVARG$ALLOCARG$ENTROPYARG$LOSSLSARG-$PRECISION.log\n\nif [ \"$ENTROPYARG\" = \"-progressive-arithmetic\" ]; then\n\tENTROPYARG=\"-progressive -arithmetic\"\nfi\n\n# Standard tests\nfor image in $IMAGES; do\n\n\tcp $IMGDIR/$image $OUTDIR\n\tbasename=`basename $image .${EXT}`\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct fast $ENTROPYARG $LOSSLSARG $LOSSLSPSV -grayscale -outfile $OUTDIR/${basename}_GRAY_fast_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct fast $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 1x4 -outfile $OUTDIR/${basename}_441_fast_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct fast $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 4x1 -outfile $OUTDIR/${basename}_411_fast_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct fast $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 2x2 -outfile $OUTDIR/${basename}_420_fast_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct fast $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 1x2 -outfile $OUTDIR/${basename}_440_fast_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct fast $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 2x1 -outfile $OUTDIR/${basename}_422_fast_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct fast $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 1x1 -outfile $OUTDIR/${basename}_444_fast_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct int $ENTROPYARG $LOSSLSARG $LOSSLSPSV -grayscale -outfile $OUTDIR/${basename}_GRAY_accurate_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct int $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 1x4 -outfile $OUTDIR/${basename}_441_accurate_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct int $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 4x1 -outfile $OUTDIR/${basename}_411_accurate_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct int $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 2x2 -outfile $OUTDIR/${basename}_420_accurate_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct int $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 1x2 -outfile $OUTDIR/${basename}_440_accurate_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct int $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 2x1 -outfile $OUTDIR/${basename}_422_accurate_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\trunme $EXEDIR/cjpeg -quality 95 -precision $PRECISION -dct int $ENTROPYARG $LOSSLSARG $LOSSLSPSV -sample 1x1 -outfile $OUTDIR/${basename}_444_accurate_cjpeg.jpg $IMGDIR/${basename}.${EXT}\n\tfor samp in $ALLSUBSAMP; do\n\t\trunme $EXEDIR/djpeg -dct fast -rgb $NSARG $BMPARG -outfile $OUTDIR/${basename}_${samp}_fast_djpeg.${EXT} $OUTDIR/${basename}_${samp}_fast_cjpeg.jpg\n\t\trunme $EXEDIR/djpeg -dct int -rgb $NSARG $BMPARG -outfile $OUTDIR/${basename}_${samp}_accurate_djpeg.${EXT} $OUTDIR/${basename}_${samp}_accurate_cjpeg.jpg\n\tdone\n\tfor samp in $x24SUBSAMP; do\n\t\trunme $EXEDIR/djpeg -dct fast -nosmooth $BMPARG -outfile $OUTDIR/${basename}_${samp}_fast_nosmooth_djpeg.${EXT} $OUTDIR/${basename}_${samp}_fast_cjpeg.jpg\n\t\trunme $EXEDIR/djpeg -dct int -nosmooth $BMPARG -outfile $OUTDIR/${basename}_${samp}_accurate_nosmooth_djpeg.${EXT} $OUTDIR/${basename}_${samp}_accurate_cjpeg.jpg\n\tdone\n\n\t# Compression\n\tfor dct in accurate fast; do\n\t\tdctarg=\n\t\tif [ \"${dct}\" = \"fast\" ]; then\n\t\t\tdctarg=-fastdct\n\t\tfi\n\t\trunme $TJBENCH $OUTDIR/$image $TJQUAL -precision $PRECISION -rgb -quiet -benchtime 0.01 -warmup 0 ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\tif [ \"$LOSSLSARG\" != \"-lossless\" ]; then\n\t\t\trunme $TJBENCH $OUTDIR/$image $TJQUAL -precision $PRECISION -subsamp 440 -rgb -quiet -benchtime 0.01 -warmup 0 ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\t\trunme $TJBENCH $OUTDIR/$image $TJQUAL -precision $PRECISION -subsamp 411 -rgb -quiet -benchtime 0.01 -warmup 0 ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\t\trunme $TJBENCH $OUTDIR/$image $TJQUAL -precision $PRECISION -subsamp 441 -rgb -quiet -benchtime 0.01 -warmup 0 ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\tfi\n\t\tfor samp in $ALLSUBSAMP; do\n\t\t\tif [ \"$LOSSLSARG\" = \"-lossless\" ]; then\n\t\t\t\trunme cmp $OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}.jpg $OUTDIR/${basename}_${samp}_${dct}_cjpeg.jpg\n\t\t\telse\n\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q${TJQUAL}.jpg $OUTDIR/${basename}_${samp}_${dct}_cjpeg.jpg\n\t\t\tfi\n\t\tdone\n\tdone\n\n\tfor dct in fast accurate; do\n\t\tdctarg=\n\t\tif [ \"${dct}\" = \"fast\" ]; then\n\t\t\tdctarg=-fastdct\n\t\tfi\n\n\t\t# Tiled compression & decompression\n\t\trunme $TJBENCH $OUTDIR/$image $TJQUAL -precision $PRECISION -rgb -tile -quiet -benchtime 0.01 -warmup 0 ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\tfor samp in $x1SUBSAMP; do\n\t\t\tif [ $ALLOC = 1 ]; then\n\t\t\t\tif [ \"$LOSSLSARG\" = \"-lossless\" ]; then\n\t\t\t\t\trunme cmp $OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}_full.${EXT} $OUTDIR/${basename}_${samp}_${dct}_djpeg.${EXT}\n\t\t\t\t\trm $OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}_full.${EXT}\n\t\t\t\telse\n\t\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q${TJQUAL}_full.${EXT} $OUTDIR/${basename}_${samp}_${dct}_djpeg.${EXT}\n\t\t\t\t\trm $OUTDIR/${basename}_${samp}_Q${TJQUAL}_full.${EXT}\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tif [ \"$LOSSLSARG\" = \"-lossless\" ]; then\n\t\t\t\t\tfor i in $OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}_[0-9]*x[0-9]*.${EXT} \\\n\t\t\t\t\t\t$OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}_full.${EXT}; do\n\t\t\t\t\t\trunme cmp $i $OUTDIR/${basename}_${samp}_${dct}_djpeg.${EXT}\n\t\t\t\t\t\trm $i\n\t\t\t\t\tdone\n\t\t\t\telse\n\t\t\t\t\tfor i in $OUTDIR/${basename}_${samp}_Q${TJQUAL}_[0-9]*x[0-9]*.${EXT} \\\n\t\t\t\t\t\t$OUTDIR/${basename}_${samp}_Q${TJQUAL}_full.${EXT}; do\n\t\t\t\t\t\trunme cmp $i $OUTDIR/${basename}_${samp}_${dct}_djpeg.${EXT}\n\t\t\t\t\t\trm $i\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\t\trunme $TJBENCH $OUTDIR/$image $TJQUAL -precision $PRECISION -rgb -tile -quiet -benchtime 0.01 -warmup 0 -fastupsample ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\tif [ \"$LOSSLSARG\" != \"-lossless\" ]; then\n\t\t\trunme $TJBENCH $OUTDIR/$image $TJQUAL -precision $PRECISION -subsamp 440 -rgb -tile -quiet -benchtime 0.01 -warmup 0 -fastupsample ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\t\trunme $TJBENCH $OUTDIR/$image $TJQUAL -precision $PRECISION -subsamp 411 -rgb -tile -quiet -benchtime 0.01 -warmup 0 -fastupsample ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\t\trunme $TJBENCH $OUTDIR/$image $TJQUAL -precision $PRECISION -subsamp 441 -rgb -tile -quiet -benchtime 0.01 -warmup 0 -fastupsample ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\tfi\n\t\tfor samp in $x24SUBSAMP; do\n\t\t\tif [ $ALLOC = 1 ]; then\n\t\t\t\tif [ \"$LOSSLSARG\" = \"-lossless\" ]; then\n\t\t\t\t\trunme cmp $OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}_full.${EXT} $OUTDIR/${basename}_${samp}_${dct}_nosmooth_djpeg.${EXT}\n\t\t\t\t\trm $OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}_full.${EXT}\n\t\t\t\telse\n\t\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q${TJQUAL}_full.${EXT} $OUTDIR/${basename}_${samp}_${dct}_nosmooth_djpeg.${EXT}\n\t\t\t\t\trm $OUTDIR/${basename}_${samp}_Q${TJQUAL}_full.${EXT}\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tif [ \"$LOSSLSARG\" = \"-lossless\" ]; then\n\t\t\t\t\tfor i in $OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}_[0-9]*x[0-9]*.${EXT} \\\n\t\t\t\t\t\t$OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}_full.${EXT}; do\n\t\t\t\t\t\trunme cmp $i $OUTDIR/${basename}_${samp}_${dct}_nosmooth_djpeg.${EXT}\n\t\t\t\t\t\trm $i\n\t\t\t\t\tdone\n\t\t\t\telse\n\t\t\t\t\tfor i in $OUTDIR/${basename}_${samp}_Q${TJQUAL}_[0-9]*x[0-9]*.${EXT} \\\n\t\t\t\t\t\t$OUTDIR/${basename}_${samp}_Q${TJQUAL}_full.${EXT}; do\n\t\t\t\t\t\t# If the tile size is smaller than the MCU size, then there will be\n\t\t\t\t\t\t# edge artifacts at the tile boundaries, so the decompressed image\n\t\t\t\t\t\t# will not be identical to the untiled decompressed image.\n\t\t\t\t\t\tTILESIZE=$(basename $(echo $i | sed 's/.*_//g') .${EXT})\n\t\t\t\t\t\tif [ \"$TILESIZE\" = \"8x8\" ]; then\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tfi\n\t\t\t\t\t\tif [ \"$TILESIZE\" = \"16x16\" -a \\\n\t\t\t\t\t\t\t\\( \"${samp}\" = \"411\" -o \"${samp}\" = \"441\" \\) ]; then\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tfi\n\t\t\t\t\t\trunme cmp $i $OUTDIR/${basename}_${samp}_${dct}_nosmooth_djpeg.${EXT}\n\t\t\t\t\t\trm $i\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\n\t\t# Tiled decompression\n\t\tif [ \"$LOSSLSARG\" != \"-lossless\" ]; then\n\t\t\tfor samp in $x1SUBSAMP; do\n\t\t\t\trunme $TJBENCH $OUTDIR/${basename}_${samp}_Q95.jpg $BMPARG -tile -quiet -benchtime 0.01 -warmup 0 ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG\n\t\t\t\tif [ $ALLOC = 1 ]; then\n\t\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q95_full.${EXT} $OUTDIR/${basename}_${samp}_${dct}_djpeg.${EXT}\n\t\t\t\t\trm $OUTDIR/${basename}_${samp}_Q95_full.${EXT}\n\t\t\t\telse\n\t\t\t\t\tfor i in $OUTDIR/${basename}_${samp}_Q95_[0-9]*x[0-9]*.${EXT} \\\n\t\t\t\t\t\t$OUTDIR/${basename}_${samp}_Q95_full.${EXT}; do\n\t\t\t\t\t\trunme cmp $i $OUTDIR/${basename}_${samp}_${dct}_djpeg.${EXT}\n\t\t\t\t\t\trm $i\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tfor samp in $x24SUBSAMP; do\n\t\t\t\trunme $TJBENCH $OUTDIR/${basename}_${samp}_Q95.jpg $BMPARG -tile -quiet -benchtime 0.01 -warmup 0 -fastupsample ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG\n\t\t\t\tif [ $ALLOC = 1 ]; then\n\t\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q95_full.${EXT} $OUTDIR/${basename}_${samp}_${dct}_nosmooth_djpeg.${EXT}\n\t\t\t\t\trm $OUTDIR/${basename}_${samp}_Q95_full.${EXT}\n\t\t\t\telse\n\t\t\t\t\tfor i in $OUTDIR/${basename}_${samp}_Q95_[0-9]*x[0-9]*.${EXT} \\\n\t\t\t\t\t\t$OUTDIR/${basename}_${samp}_Q95_full.${EXT}; do\n\t\t\t\t\t\tTILESIZE=$(basename $(echo $i | sed 's/.*_//g') .${EXT})\n\t\t\t\t\t\tif [ \"$TILESIZE\" = \"8x8\" ]; then\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tfi\n\t\t\t\t\t\tif [ \"$TILESIZE\" = \"16x16\" -a \\\n\t\t\t\t\t\t\t\\( \"${samp}\" = \"411\" -o \"${samp}\" = \"441\" \\) ]; then\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tfi\n\t\t\t\t\t\trunme cmp $i $OUTDIR/${basename}_${samp}_${dct}_nosmooth_djpeg.${EXT}\n\t\t\t\t\t\trm $i\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone\n\n\t# Partial decompression\n\tif [ \"$LOSSLSARG\" != \"-lossless\" -a \"$YUVARG\" != \"-yuv\" ]; then\n\t\tfor samp in $ALLSUBSAMP; do\n\t\t\tCROPW8_8=103\n\t\t\tCROPL8_8=16\n\t\t\tCROPW7_8=91\n\t\t\tCROPL7_8=14\n\t\t\tif [ \"${samp}\" = \"411\" ]; then\n\t\t\t\tCROPW8_8=87\n\t\t\t\tCROPL8_8=32\n\t\t\t\tCROPW7_8=77\n\t\t\t\tCROPL7_8=28\n\t\t\tfi\n\t\t\trunme $EXEDIR/djpeg -rgb -crop ${CROPW8_8}x90+${CROPL8_8}+5 $NSARG -outfile $OUTDIR/${basename}_${samp}_scale_crop_djpeg.ppm $OUTDIR/${basename}_${samp}_accurate_cjpeg.jpg\n\t\t\trunme $TJBENCH $OUTDIR/${basename}_${samp}_Q${TJQUAL}.jpg -crop ${CROPW8_8}x90+${CROPL8_8}+5 -quiet -benchtime 0.01 -warmup 0 ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q${TJQUAL}_full.ppm $OUTDIR/${basename}_${samp}_scale_crop_djpeg.ppm\n\t\t\trm $OUTDIR/${basename}_${samp}_Q${TJQUAL}_full.ppm $OUTDIR/${basename}_${samp}_scale_crop_djpeg.ppm\n\n\t\t\trunme $EXEDIR/djpeg -rgb -scale 14/16 -crop ${CROPW7_8}x81+${CROPL7_8}+3 $NSARG -outfile $OUTDIR/${basename}_${samp}_scale_crop_djpeg.ppm $OUTDIR/${basename}_${samp}_accurate_cjpeg.jpg\n\t\t\trunme $TJBENCH $OUTDIR/${basename}_${samp}_Q${TJQUAL}.jpg -scale 7/8 -crop ${CROPW7_8}x81+${CROPL7_8}+3 -quiet -benchtime 0.01 -warmup 0 ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q${TJQUAL}_7_8.ppm $OUTDIR/${basename}_${samp}_scale_crop_djpeg.ppm\n\t\t\trm $OUTDIR/${basename}_${samp}_Q${TJQUAL}_7_8.ppm $OUTDIR/${basename}_${samp}_scale_crop_djpeg.ppm\n\n\t\t\trunme $EXEDIR/djpeg -rgb -scale 1/2 -crop 40x40+0+0 $NSARG -outfile $OUTDIR/${basename}_${samp}_scale_crop_djpeg.ppm $OUTDIR/${basename}_${samp}_accurate_cjpeg.jpg\n\t\t\trunme $TJBENCH $OUTDIR/${basename}_${samp}_Q${TJQUAL}.jpg -scale 4/8 -crop 40x40+0+0 -quiet -benchtime 0.01 -warmup 0 ${dctarg} $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q${TJQUAL}_1_2.ppm $OUTDIR/${basename}_${samp}_scale_crop_djpeg.ppm\n\t\t\trm $OUTDIR/${basename}_${samp}_Q${TJQUAL}_1_2.ppm $OUTDIR/${basename}_${samp}_scale_crop_djpeg.ppm\n\t\tdone\n\tfi\n\n\t# Scaled decompression\n\tfor scale in 2_1 15_8 7_4 13_8 3_2 11_8 5_4 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8; do\n\t\tscalearg=`echo $scale | sed 's/\\_/\\//g'`\n\t\tSCALE=$scale\n\t\tif [ \"$LOSSLSARG\" = \"-lossless\" ]; then\n\t\t\tSCALE=full\n\t\tfi\n\t\tfor samp in $ALLSUBSAMP; do\n\t\t\trunme $EXEDIR/djpeg -rgb -scale ${scalearg} $NSARG $BMPARG -outfile $OUTDIR/${basename}_${samp}_${scale}_djpeg.${EXT} $OUTDIR/${basename}_${samp}_accurate_cjpeg.jpg\n\t\t\tif [ \"$LOSSLSARG\" = \"-lossless\" ]; then\n\t\t\t\trunme $TJBENCH $OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}.jpg $BMPARG -scale ${scalearg} -quiet -benchtime 0.01 -warmup 0 $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\t\t\trunme cmp $OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}_${SCALE}.${EXT} $OUTDIR/${basename}_${samp}_${scale}_djpeg.${EXT}\n\t\t\t\trm $OUTDIR/${basename}_LOSSLS_PSV${TJQUAL}_${SCALE}.${EXT}\n\t\t\telse\n\t\t\t\trunme $TJBENCH $OUTDIR/${basename}_${samp}_Q${TJQUAL}.jpg $BMPARG -scale ${scalearg} -quiet -benchtime 0.01 -warmup 0 $YUVARG $ALLOCARG $ENTROPYARG $LOSSLSARG\n\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q${TJQUAL}_${SCALE}.${EXT} $OUTDIR/${basename}_${samp}_${scale}_djpeg.${EXT}\n\t\t\t\trm $OUTDIR/${basename}_${samp}_Q${TJQUAL}_${SCALE}.${EXT}\n\t\t\tfi\n\t\tdone\n\tdone\n\n\t# Transforms\n\tif [ \"$LOSSLSARG\" != \"-lossless\" ]; then\n\t\tfor samp in $ALLSUBSAMP; do\n\t\t\trunme $EXEDIR/jpegtran -flip horizontal -trim -outfile $OUTDIR/${basename}_${samp}_hflip_jpegtran.jpg $OUTDIR/${basename}_${samp}_Q95.jpg\n\t\t\trunme $EXEDIR/jpegtran -flip vertical -trim -outfile $OUTDIR/${basename}_${samp}_vflip_jpegtran.jpg $OUTDIR/${basename}_${samp}_Q95.jpg\n\t\t\trunme $EXEDIR/jpegtran -transpose -trim -outfile $OUTDIR/${basename}_${samp}_transpose_jpegtran.jpg $OUTDIR/${basename}_${samp}_Q95.jpg\n\t\t\trunme $EXEDIR/jpegtran -transverse -trim -outfile $OUTDIR/${basename}_${samp}_transverse_jpegtran.jpg $OUTDIR/${basename}_${samp}_Q95.jpg\n\t\t\trunme $EXEDIR/jpegtran -rotate 90 -trim -outfile $OUTDIR/${basename}_${samp}_rot90_jpegtran.jpg $OUTDIR/${basename}_${samp}_Q95.jpg\n\t\t\trunme $EXEDIR/jpegtran -rotate 180 -trim -outfile $OUTDIR/${basename}_${samp}_rot180_jpegtran.jpg $OUTDIR/${basename}_${samp}_Q95.jpg\n\t\t\trunme $EXEDIR/jpegtran -rotate 270 -trim -outfile $OUTDIR/${basename}_${samp}_rot270_jpegtran.jpg $OUTDIR/${basename}_${samp}_Q95.jpg\n\t\tdone\n\t\tfor xform in hflip vflip transpose transverse rot90 rot180 rot270; do\n\t\t\tfor samp in $x1SUBSAMP; do\n\t\t\t\trunme $EXEDIR/djpeg -rgb $BMPARG -outfile $OUTDIR/${basename}_${samp}_${xform}_jpegtran.${EXT} $OUTDIR/${basename}_${samp}_${xform}_jpegtran.jpg\n\t\t\t\trunme $TJBENCH $OUTDIR/${basename}_${samp}_Q95.jpg $BMPARG -$xform -tile -quiet -benchtime 0.01 -warmup 0 $YUVARG $ALLOCARG $ENTROPYARG\n\t\t\t\tif [ $ALLOC = 1 ]; then\n\t\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q95_full.${EXT} $OUTDIR/${basename}_${samp}_${xform}_jpegtran.${EXT}\n\t\t\t\t\trm $OUTDIR/${basename}_${samp}_Q95_full.${EXT}\n\t\t\t\telse\n\t\t\t\t\tfor i in $OUTDIR/${basename}_${samp}_Q95_[0-9]*x[0-9]*.${EXT} \\\n\t\t\t\t\t\t$OUTDIR/${basename}_${samp}_Q95_full.${EXT}; do\n\t\t\t\t\t\trunme cmp $i $OUTDIR/${basename}_${samp}_${xform}_jpegtran.${EXT}\n\t\t\t\t\t\trm $i\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tfor samp in $x24SUBSAMP; do\n\t\t\t\trunme $EXEDIR/djpeg -nosmooth -rgb $BMPARG -outfile $OUTDIR/${basename}_${samp}_${xform}_jpegtran.${EXT} $OUTDIR/${basename}_${samp}_${xform}_jpegtran.jpg\n\t\t\t\trunme $TJBENCH $OUTDIR/${basename}_${samp}_Q95.jpg $BMPARG -$xform -tile -quiet -benchtime 0.01 -warmup 0 -fastupsample $YUVARG $ALLOCARG $ENTROPYARG\n\t\t\t\tif [ $ALLOC = 1 ]; then\n\t\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q95_full.${EXT} $OUTDIR/${basename}_${samp}_${xform}_jpegtran.${EXT}\n\t\t\t\t\trm $OUTDIR/${basename}_${samp}_Q95_full.${EXT}\n\t\t\t\telse\n\t\t\t\t\tfor i in $OUTDIR/${basename}_${samp}_Q95_[0-9]*x[0-9]*.${EXT} \\\n\t\t\t\t\t\t$OUTDIR/${basename}_${samp}_Q95_full.${EXT}; do\n\t\t\t\t\t\tTILESIZE=$(basename $(echo $i | sed 's/.*_//g') .${EXT})\n\t\t\t\t\t\tif [ \"$TILESIZE\" = \"8x8\" ]; then\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tfi\n\t\t\t\t\t\tif [ \"$TILESIZE\" = \"16x16\" -a \\\n\t\t\t\t\t\t\t\\( \"${samp}\" = \"411\" -o \"${samp}\" = \"441\" \\) ]; then\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tfi\n\t\t\t\t\t\trunme cmp $i $OUTDIR/${basename}_${samp}_${xform}_jpegtran.${EXT}\n\t\t\t\t\t\trm $i\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tdone\n\t\tdone\n\n\t\t# Grayscale transform\n\t\tfor xform in hflip vflip transpose transverse rot90 rot180 rot270; do\n\t\t\tfor samp in $ALLSUBSAMP; do\n\t\t\t\trunme $TJBENCH $OUTDIR/${basename}_${samp}_Q95.jpg $BMPARG -$xform -tile -quiet -benchtime 0.01 -warmup 0 -grayscale $YUVARG $ALLOCARG $ENTROPYARG\n\t\t\t\tif [ $ALLOC = 1 ]; then\n\t\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q95_full.${EXT} $OUTDIR/${basename}_GRAY_${xform}_jpegtran.${EXT}\n\t\t\t\t\trm $OUTDIR/${basename}_${samp}_Q95_full.${EXT}\n\t\t\t\telse\n\t\t\t\t\tfor i in $OUTDIR/${basename}_${samp}_Q95_[0-9]*x[0-9]*.${EXT} \\\n\t\t\t\t\t\t$OUTDIR/${basename}_${samp}_Q95_full.${EXT}; do\n\t\t\t\t\t\tTILESIZE=$(basename $(echo $i | sed 's/.*_//g') .${EXT})\n\t\t\t\t\t\tif [ \"$TILESIZE\" = \"8x8\" -a \\\n\t\t\t\t\t\t\t\"${samp}\" != \"444\" -a \"${samp}\" != \"GRAY\" ]; then\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tfi\n\t\t\t\t\t\tif [ \"$TILESIZE\" = \"16x16\" -a \\\n\t\t\t\t\t\t\t\\( \"${samp}\" = \"411\" -o \"${samp}\" = \"441\" \\) ]; then\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tfi\n\t\t\t\t\t\trunme cmp $i $OUTDIR/${basename}_GRAY_${xform}_jpegtran.${EXT}\n\t\t\t\t\t\trm $i\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tdone\n\t\tdone\n\n\t\t# Transforms with scaling\n\t\tfor xform in hflip vflip transpose transverse rot90 rot180 rot270; do\n\t\t\tfor samp in $ALLSUBSAMP; do\n\t\t\t\tfor scale in 2_1 15_8 7_4 13_8 3_2 11_8 5_4 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8; do\n\t\t\t\t\tscalearg=`echo $scale | sed 's/\\_/\\//g'`\n\t\t\t\t\trunme $EXEDIR/djpeg -rgb -scale ${scalearg} $NSARG $BMPARG -outfile $OUTDIR/${basename}_${samp}_${xform}_${scale}_jpegtran.${EXT} $OUTDIR/${basename}_${samp}_${xform}_jpegtran.jpg\n\t\t\t\t\trunme $TJBENCH $OUTDIR/${basename}_${samp}_Q95.jpg $BMPARG -$xform -scale ${scalearg} -quiet -benchtime 0.01 -warmup 0 $YUVARG $ALLOCARG $ENTROPYARG\n\t\t\t\t\trunme cmp $OUTDIR/${basename}_${samp}_Q95_${scale}.${EXT} $OUTDIR/${basename}_${samp}_${xform}_${scale}_jpegtran.${EXT}\n\t\t\t\t\trm $OUTDIR/${basename}_${samp}_Q95_${scale}.${EXT}\n\t\t\t\tdone\n\t\t\tdone\n\t\tdone\n\tfi\n\ndone\n\necho SUCCESS!\n"
        },
        {
          "name": "tjexample.c",
          "type": "blob",
          "size": 15.27734375,
          "content": "/*\n * Copyright (C)2011-2012, 2014-2015, 2017, 2019, 2021-2024\n *           D. R. Commander.  All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program demonstrates how to compress, decompress, and transform JPEG\n * images using the TurboJPEG C API\n */\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <limits.h>\n#if !defined(_MSC_VER) || _MSC_VER > 1600\n#include <stdint.h>\n#endif\n#include <turbojpeg.h>\n\n\n#ifdef _WIN32\n#define strcasecmp  stricmp\n#define strncasecmp  strnicmp\n#endif\n\n#define THROW(action, message) { \\\n  printf(\"ERROR in line %d while %s:\\n%s\\n\", __LINE__, action, message); \\\n  retval = -1;  goto bailout; \\\n}\n\n#define THROW_TJ(action)  THROW(action, tj3GetErrorStr(tjInstance))\n\n#define THROW_UNIX(action)  THROW(action, strerror(errno))\n\n#define DEFAULT_SUBSAMP  TJSAMP_444\n#define DEFAULT_QUALITY  95\n\n\nstatic const char *subsampName[TJ_NUMSAMP] = {\n  \"4:4:4\", \"4:2:2\", \"4:2:0\", \"Grayscale\", \"4:4:0\", \"4:1:1\", \"4:4:1\"\n};\n\nstatic const char *colorspaceName[TJ_NUMCS] = {\n  \"RGB\", \"YCbCr\", \"GRAY\", \"CMYK\", \"YCCK\"\n};\n\nstatic tjscalingfactor *scalingFactors = NULL;\nstatic int numScalingFactors = 0;\n\n\n/* DCT filter example.  This produces a negative of the image. */\n\nstatic int customFilter(short *coeffs, tjregion arrayRegion,\n                        tjregion planeRegion, int componentIndex,\n                        int transformIndex, tjtransform *transform)\n{\n  int i;\n\n  for (i = 0; i < arrayRegion.w * arrayRegion.h; i++)\n    coeffs[i] = -coeffs[i];\n\n  return 0;\n}\n\n\nstatic void usage(char *programName)\n{\n  int i;\n\n  printf(\"\\nUSAGE: %s <Input image> <Output image> [options]\\n\\n\",\n         programName);\n\n  printf(\"Input and output images can be in Windows BMP or PBMPLUS (PPM/PGM) format.  If\\n\");\n  printf(\"either filename ends in a .jpg extension, then the TurboJPEG API will be used\\n\");\n  printf(\"to compress or decompress the image.\\n\\n\");\n\n  printf(\"Compression Options (used if the output image is a JPEG image)\\n\");\n  printf(\"--------------------------------------------------------------\\n\\n\");\n\n  printf(\"-subsamp <444|422|420|gray> = Apply this level of chrominance subsampling when\\n\");\n  printf(\"     compressing the output image.  The default is to use the same level of\\n\");\n  printf(\"     subsampling as in the input image, if the input image is also a JPEG\\n\");\n  printf(\"     image, or to use grayscale if the input image is a grayscale non-JPEG\\n\");\n  printf(\"     image, or to use %s subsampling otherwise.\\n\\n\",\n         subsampName[DEFAULT_SUBSAMP]);\n\n  printf(\"-q <1-100> = Compress the output image with this JPEG quality level\\n\");\n  printf(\"     (default = %d).\\n\\n\", DEFAULT_QUALITY);\n\n  printf(\"Decompression Options (used if the input image is a JPEG image)\\n\");\n  printf(\"---------------------------------------------------------------\\n\\n\");\n\n  printf(\"-scale M/N = Scale the input image by a factor of M/N when decompressing it.\\n\");\n  printf(\"(M/N = \");\n  for (i = 0; i < numScalingFactors; i++) {\n    printf(\"%d/%d\", scalingFactors[i].num, scalingFactors[i].denom);\n    if (numScalingFactors == 2 && i != numScalingFactors - 1)\n      printf(\" or \");\n    else if (numScalingFactors > 2) {\n      if (i != numScalingFactors - 1)\n        printf(\", \");\n      if (i == numScalingFactors - 2)\n        printf(\"or \");\n    }\n  }\n  printf(\")\\n\\n\");\n\n  printf(\"-hflip, -vflip, -transpose, -transverse, -rot90, -rot180, -rot270 =\\n\");\n  printf(\"     Perform one of these lossless transform operations on the input image\\n\");\n  printf(\"     prior to decompressing it (these options are mutually exclusive.)\\n\\n\");\n\n  printf(\"-grayscale = Perform lossless grayscale conversion on the input image prior\\n\");\n  printf(\"     to decompressing it (can be combined with the other transform operations\\n\");\n  printf(\"     above.)\\n\\n\");\n\n  printf(\"-crop WxH+X+Y = Perform lossless cropping on the input image prior to\\n\");\n  printf(\"     decompressing it.  X and Y specify the upper left corner of the cropping\\n\");\n  printf(\"     region, and W and H specify the width and height of the cropping region.\\n\");\n  printf(\"     X and Y must be evenly divible by the iMCU size (8x8 if the input image\\n\");\n  printf(\"     was compressed using no subsampling or grayscale, 16x8 if it was\\n\");\n  printf(\"     compressed using 4:2:2 subsampling, or 16x16 if it was compressed using\\n\");\n  printf(\"     4:2:0 subsampling.)\\n\\n\");\n\n  printf(\"General Options\\n\");\n  printf(\"---------------\\n\\n\");\n\n  printf(\"-fastupsample = Use the fastest chrominance upsampling algorithm available\\n\\n\");\n\n  printf(\"-fastdct = Use the fastest DCT/IDCT algorithm available\\n\\n\");\n\n  exit(1);\n}\n\n\nint main(int argc, char **argv)\n{\n  tjscalingfactor scalingFactor = TJUNSCALED;\n  int outSubsamp = -1, outQual = -1;\n  tjtransform xform;\n  int fastUpsample = 0, fastDCT = 0;\n  int width, height;\n  char *inFormat, *outFormat;\n  FILE *jpegFile = NULL;\n  unsigned char *imgBuf = NULL, *jpegBuf = NULL;\n  int retval = 0, i, pixelFormat = TJPF_UNKNOWN;\n  tjhandle tjInstance = NULL;\n\n  if ((scalingFactors = tj3GetScalingFactors(&numScalingFactors)) == NULL)\n    THROW_TJ(\"getting scaling factors\");\n  memset(&xform, 0, sizeof(tjtransform));\n\n  if (argc < 3)\n    usage(argv[0]);\n\n  /* Parse arguments. */\n  for (i = 3; i < argc; i++) {\n    if (!strncasecmp(argv[i], \"-sc\", 3) && i < argc - 1) {\n      int match = 0, temp1 = 0, temp2 = 0, j;\n\n      if (sscanf(argv[++i], \"%d/%d\", &temp1, &temp2) < 2)\n        usage(argv[0]);\n      for (j = 0; j < numScalingFactors; j++) {\n        if ((double)temp1 / (double)temp2 == (double)scalingFactors[j].num /\n                                             (double)scalingFactors[j].denom) {\n          scalingFactor = scalingFactors[j];\n          match = 1;\n          break;\n        }\n      }\n      if (match != 1)\n        usage(argv[0]);\n    } else if (!strncasecmp(argv[i], \"-su\", 3) && i < argc - 1) {\n      i++;\n      if (!strncasecmp(argv[i], \"g\", 1))\n        outSubsamp = TJSAMP_GRAY;\n      else if (!strcasecmp(argv[i], \"444\"))\n        outSubsamp = TJSAMP_444;\n      else if (!strcasecmp(argv[i], \"422\"))\n        outSubsamp = TJSAMP_422;\n      else if (!strcasecmp(argv[i], \"420\"))\n        outSubsamp = TJSAMP_420;\n      else\n        usage(argv[0]);\n    } else if (!strncasecmp(argv[i], \"-q\", 2) && i < argc - 1) {\n      outQual = atoi(argv[++i]);\n      if (outQual < 1 || outQual > 100)\n        usage(argv[0]);\n    } else if (!strncasecmp(argv[i], \"-g\", 2))\n      xform.options |= TJXOPT_GRAY;\n    else if (!strcasecmp(argv[i], \"-hflip\"))\n      xform.op = TJXOP_HFLIP;\n    else if (!strcasecmp(argv[i], \"-vflip\"))\n      xform.op = TJXOP_VFLIP;\n    else if (!strcasecmp(argv[i], \"-transpose\"))\n      xform.op = TJXOP_TRANSPOSE;\n    else if (!strcasecmp(argv[i], \"-transverse\"))\n      xform.op = TJXOP_TRANSVERSE;\n    else if (!strcasecmp(argv[i], \"-rot90\"))\n      xform.op = TJXOP_ROT90;\n    else if (!strcasecmp(argv[i], \"-rot180\"))\n      xform.op = TJXOP_ROT180;\n    else if (!strcasecmp(argv[i], \"-rot270\"))\n      xform.op = TJXOP_ROT270;\n    else if (!strcasecmp(argv[i], \"-custom\"))\n      xform.customFilter = customFilter;\n    else if (!strncasecmp(argv[i], \"-c\", 2) && i < argc - 1) {\n      if (sscanf(argv[++i], \"%dx%d+%d+%d\", &xform.r.w, &xform.r.h, &xform.r.x,\n                 &xform.r.y) < 4 ||\n          xform.r.x < 0 || xform.r.y < 0 || xform.r.w < 1 || xform.r.h < 1)\n        usage(argv[0]);\n      xform.options |= TJXOPT_CROP;\n    } else if (!strcasecmp(argv[i], \"-fastupsample\")) {\n      printf(\"Using fast upsampling code\\n\");\n      fastUpsample = 1;\n    } else if (!strcasecmp(argv[i], \"-fastdct\")) {\n      printf(\"Using fastest DCT/IDCT algorithm\\n\");\n      fastDCT = 1;\n    } else usage(argv[0]);\n  }\n\n  /* Determine input and output image formats based on file extensions. */\n  inFormat = strrchr(argv[1], '.');\n  outFormat = strrchr(argv[2], '.');\n  if (inFormat == NULL || outFormat == NULL || strlen(inFormat) < 2 ||\n      strlen(outFormat) < 2)\n    usage(argv[0]);\n  inFormat = &inFormat[1];\n  outFormat = &outFormat[1];\n\n  if ((tjInstance = tj3Init(TJINIT_TRANSFORM)) == NULL)\n    THROW_TJ(\"creating TurboJPEG instance\");\n\n  if (!strcasecmp(inFormat, \"jpg\")) {\n    /* Input image is a JPEG image.  Decompress and/or transform it. */\n    long size;\n    int inSubsamp, inColorspace;\n    int doTransform = (xform.op != TJXOP_NONE || xform.options != 0 ||\n                       xform.customFilter != NULL);\n    size_t jpegSize;\n\n    /* Read the JPEG file into memory. */\n    if ((jpegFile = fopen(argv[1], \"rb\")) == NULL)\n      THROW_UNIX(\"opening input file\");\n    if (fseek(jpegFile, 0, SEEK_END) < 0 || ((size = ftell(jpegFile)) < 0) ||\n        fseek(jpegFile, 0, SEEK_SET) < 0)\n      THROW_UNIX(\"determining input file size\");\n    if (size == 0)\n      THROW(\"determining input file size\", \"Input file contains no data\");\n    jpegSize = size;\n    if (jpegSize > (unsigned long)INT_MAX)\n      THROW(\"allocating JPEG buffer\", \"Input file is too large\");\n    if ((jpegBuf = tj3Alloc(jpegSize)) == NULL)\n      THROW_UNIX(\"allocating JPEG buffer\");\n    if (fread(jpegBuf, jpegSize, 1, jpegFile) < 1)\n      THROW_UNIX(\"reading input file\");\n    fclose(jpegFile);  jpegFile = NULL;\n\n    if (doTransform) {\n      /* Transform it. */\n      unsigned char *dstBuf = NULL;  /* Dynamically allocate the JPEG buffer */\n      size_t dstSize = 0;\n\n      xform.options |= TJXOPT_TRIM;\n      if (tj3Transform(tjInstance, jpegBuf, jpegSize, 1, &dstBuf, &dstSize,\n                       &xform) < 0) {\n        tj3Free(dstBuf);\n        THROW_TJ(\"transforming input image\");\n      }\n      tj3Free(jpegBuf);\n      jpegBuf = dstBuf;\n      jpegSize = dstSize;\n    }\n    if (tj3Set(tjInstance, TJPARAM_FASTUPSAMPLE, fastUpsample) < 0)\n      THROW_TJ(\"setting TJPARAM_FASTUPSAMPLE\");\n    if (tj3Set(tjInstance, TJPARAM_FASTDCT, fastDCT) < 0)\n      THROW_TJ(\"setting TJPARAM_FASTDCT\");\n\n    if (tj3DecompressHeader(tjInstance, jpegBuf, jpegSize) < 0)\n      THROW_TJ(\"reading JPEG header\");\n    width = tj3Get(tjInstance, TJPARAM_JPEGWIDTH);\n    height = tj3Get(tjInstance, TJPARAM_JPEGHEIGHT);\n    inSubsamp = tj3Get(tjInstance, TJPARAM_SUBSAMP);\n    inColorspace = tj3Get(tjInstance, TJPARAM_COLORSPACE);\n\n    if (tj3Get(tjInstance, TJPARAM_LOSSLESS))\n      scalingFactor = TJUNSCALED;\n\n    printf(\"%s Image:  %d x %d pixels, %s subsampling, %s colorspace\\n\",\n           (doTransform ? \"Transformed\" : \"Input\"), width, height,\n           subsampName[inSubsamp], colorspaceName[inColorspace]);\n\n    if (!strcasecmp(outFormat, \"jpg\") && doTransform &&\n        scalingFactor.num == 1 && scalingFactor.denom == 1 && outSubsamp < 0 &&\n        outQual < 0) {\n      /* Input image has been transformed, and no re-compression options\n         have been selected.  Write the transformed image to disk and exit. */\n      if ((jpegFile = fopen(argv[2], \"wb\")) == NULL)\n        THROW_UNIX(\"opening output file\");\n      if (fwrite(jpegBuf, jpegSize, 1, jpegFile) < 1)\n        THROW_UNIX(\"writing output file\");\n      goto bailout;\n    }\n\n    /* Scaling and/or a non-JPEG output image format and/or compression options\n       have been selected, so we need to decompress the input/transformed\n       image. */\n    if (tj3SetScalingFactor(tjInstance, scalingFactor) < 0)\n      THROW_TJ(\"setting scaling factor\");\n    width = TJSCALED(width, scalingFactor);\n    height = TJSCALED(height, scalingFactor);\n    if (outSubsamp < 0)\n      outSubsamp = inSubsamp;\n\n    pixelFormat = TJPF_BGRX;\n#if ULLONG_MAX > SIZE_MAX\n    if ((unsigned long long)width * height * tjPixelSize[pixelFormat] >\n        (unsigned long long)((size_t)-1))\n      THROW(\"allocating uncompressed image buffer\", \"Image is too large\");\n#endif\n    if ((imgBuf =\n         (unsigned char *)malloc(sizeof(unsigned char) * width * height *\n                                 tjPixelSize[pixelFormat])) == NULL)\n      THROW_UNIX(\"allocating uncompressed image buffer\");\n\n    if (tj3Decompress8(tjInstance, jpegBuf, jpegSize, imgBuf, 0,\n                       pixelFormat) < 0)\n      THROW_TJ(\"decompressing JPEG image\");\n    tj3Free(jpegBuf);  jpegBuf = NULL;\n  } else {\n    /* Input image is not a JPEG image.  Load it into memory. */\n    if ((imgBuf = tj3LoadImage8(tjInstance, argv[1], &width, 1, &height,\n                                &pixelFormat)) == NULL)\n      THROW_TJ(\"loading input image\");\n    if (outSubsamp < 0) {\n      if (pixelFormat == TJPF_GRAY)\n        outSubsamp = TJSAMP_GRAY;\n      else\n        outSubsamp = TJSAMP_444;\n    }\n    printf(\"Input Image:  %d x %d pixels\\n\", width, height);\n  }\n\n  printf(\"Output Image (%s):  %d x %d pixels\", outFormat, width, height);\n\n  if (!strcasecmp(outFormat, \"jpg\")) {\n    /* Output image format is JPEG.  Compress the uncompressed image. */\n    size_t jpegSize = 0;\n\n    jpegBuf = NULL;  /* Dynamically allocate the JPEG buffer */\n\n    if (outQual < 0)\n      outQual = DEFAULT_QUALITY;\n    printf(\", %s subsampling, quality = %d\\n\", subsampName[outSubsamp],\n           outQual);\n\n    if (tj3Set(tjInstance, TJPARAM_SUBSAMP, outSubsamp) < 0)\n      THROW_TJ(\"setting TJPARAM_SUBSAMP\");\n    if (tj3Set(tjInstance, TJPARAM_QUALITY, outQual) < 0)\n      THROW_TJ(\"setting TJPARAM_QUALITY\");\n    if (tj3Set(tjInstance, TJPARAM_FASTDCT, fastDCT) < 0)\n      THROW_TJ(\"setting TJPARAM_FASTDCT\");\n    if (tj3Compress8(tjInstance, imgBuf, width, 0, height, pixelFormat,\n                     &jpegBuf, &jpegSize) < 0)\n      THROW_TJ(\"compressing image\");\n\n    /* Write the JPEG image to disk. */\n    if ((jpegFile = fopen(argv[2], \"wb\")) == NULL)\n      THROW_UNIX(\"opening output file\");\n    if (fwrite(jpegBuf, jpegSize, 1, jpegFile) < 1)\n      THROW_UNIX(\"writing output file\");\n  } else {\n    /* Output image format is not JPEG.  Save the uncompressed image\n       directly to disk. */\n    printf(\"\\n\");\n    if (tj3SaveImage8(tjInstance, argv[2], imgBuf, width, 0, height,\n                      pixelFormat) < 0)\n      THROW_TJ(\"saving output image\");\n  }\n\nbailout:\n  tj3Free(imgBuf);\n  tj3Destroy(tjInstance);\n  tj3Free(jpegBuf);\n  if (jpegFile) fclose(jpegFile);\n  return retval;\n}\n"
        },
        {
          "name": "tjexampletest.in",
          "type": "blob",
          "size": 9.7041015625,
          "content": "#!/bin/bash\n\nset -u\nset -e\ntrap onexit INT\ntrap onexit TERM\ntrap onexit EXIT\n\nonexit()\n{\n\tif [ -d $OUTDIR ]; then\n\t\trm -rf $OUTDIR\n\tfi\n}\n\nrunme()\n{\n\techo \\*\\*\\* $*\n\t$*\n}\n\nIMAGES=\"vgl_5674_0098.bmp vgl_6434_0018a.bmp vgl_6548_0026a.bmp shira_bird8.bmp\"\nIMGDIR=@CMAKE_CURRENT_SOURCE_DIR@/testimages\nOUTDIR=`mktemp -d /tmp/__tjexampletest_output.XXXXXX`\nEXEDIR=@CMAKE_CURRENT_BINARY_DIR@\nJAVA=\"@Java_JAVA_EXECUTABLE@\"\nJAVAARGS=\"-cp $EXEDIR/java/turbojpeg.jar -Djava.library.path=$EXEDIR\"\nTJEXAMPLE=$EXEDIR/tjexample\nJAVAARG=\n\nif [ -d $OUTDIR ]; then\n\trm -rf $OUTDIR\nfi\nmkdir -p $OUTDIR\n\nwhile [ $# -gt 0 ]; do\n\tcase \"$1\" in\n\t-java)\n\t\tJAVAARG=-java\n\t\tTJEXAMPLE=\"$JAVA $JAVAARGS TJExample\"\n\t\t# The Java version of TJExample can't currently handle pixel density\n\t\t# information, so it fails on shira_bird8.bmp.\n\t\tIMAGES=\"vgl_5674_0098.bmp vgl_6434_0018a.bmp vgl_6548_0026a.bmp\"\n\t\t;;\n\tesac\n\tshift\ndone\n\nexec >$EXEDIR/tjexampletest$JAVAARG.log\n\nfor image in $IMAGES; do\n\n\tcp $IMGDIR/$image $OUTDIR\n\tbasename=`basename $image .bmp`\n\trunme $EXEDIR/cjpeg -quality 95 -dct fast -grayscale -outfile $OUTDIR/${basename}_GRAY_fast_cjpeg.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct fast -sample 2x2 -outfile $OUTDIR/${basename}_420_fast_cjpeg.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct fast -sample 2x1 -outfile $OUTDIR/${basename}_422_fast_cjpeg.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct fast -sample 1x1 -outfile $OUTDIR/${basename}_444_fast_cjpeg.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct int -grayscale -outfile $OUTDIR/${basename}_GRAY_accurate_cjpeg.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct int -sample 2x2 -outfile $OUTDIR/${basename}_420_accurate_cjpeg.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct int -sample 2x1 -outfile $OUTDIR/${basename}_422_accurate_cjpeg.jpg $IMGDIR/${basename}.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct int -sample 1x1 -outfile $OUTDIR/${basename}_444_accurate_cjpeg.jpg $IMGDIR/${basename}.bmp\n\tfor samp in GRAY 420 422 444; do\n\t\trunme $EXEDIR/djpeg -dct fast -rgb -bmp -outfile $OUTDIR/${basename}_${samp}_fast_djpeg.bmp $OUTDIR/${basename}_${samp}_fast_cjpeg.jpg\n\t\trunme $EXEDIR/djpeg -dct int -rgb -bmp -outfile $OUTDIR/${basename}_${samp}_accurate_djpeg.bmp $OUTDIR/${basename}_${samp}_accurate_cjpeg.jpg\n\tdone\n\tfor samp in 420 422; do\n\t\trunme $EXEDIR/djpeg -dct fast -nosmooth -bmp -outfile $OUTDIR/${basename}_${samp}_fast_nosmooth_djpeg.bmp $OUTDIR/${basename}_${samp}_fast_cjpeg.jpg\n\t\trunme $EXEDIR/djpeg -dct int -nosmooth -bmp -outfile $OUTDIR/${basename}_${samp}_accurate_nosmooth_djpeg.bmp $OUTDIR/${basename}_${samp}_accurate_cjpeg.jpg\n\tdone\n\trunme $EXEDIR/cjpeg -quality 95 -dct fast -grayscale -outfile $OUTDIR/${basename}_GRAY_fast_cjpeg2.jpg $OUTDIR/${basename}_GRAY_fast_djpeg.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct fast -sample 2x2 -outfile $OUTDIR/${basename}_420_fast_cjpeg2.jpg $OUTDIR/${basename}_420_fast_djpeg.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct fast -sample 2x1 -outfile $OUTDIR/${basename}_422_fast_cjpeg2.jpg $OUTDIR/${basename}_422_fast_djpeg.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct fast -sample 1x1 -outfile $OUTDIR/${basename}_444_fast_cjpeg2.jpg $OUTDIR/${basename}_444_fast_djpeg.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct int -grayscale -outfile $OUTDIR/${basename}_GRAY_accurate_cjpeg2.jpg $OUTDIR/${basename}_GRAY_accurate_djpeg.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct int -sample 2x2 -outfile $OUTDIR/${basename}_420_accurate_cjpeg2.jpg $OUTDIR/${basename}_420_accurate_djpeg.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct int -sample 2x1 -outfile $OUTDIR/${basename}_422_accurate_cjpeg2.jpg $OUTDIR/${basename}_422_accurate_djpeg.bmp\n\trunme $EXEDIR/cjpeg -quality 95 -dct int -sample 1x1 -outfile $OUTDIR/${basename}_444_accurate_cjpeg2.jpg $OUTDIR/${basename}_444_accurate_djpeg.bmp\n\n\t# Compression\n\tfor dct in fast accurate; do\n\t\tdctarg=\n\t\tif [ \"${dct}\" = \"fast\" ]; then\n\t\t\tdctarg=-fastdct\n\t\tfi\n\t\tfor samp in GRAY 420 422 444; do\n\t\t\trunme $TJEXAMPLE $OUTDIR/$image $OUTDIR/${basename}_${samp}_${dct}.jpg -q 95 -subsamp ${samp} ${dctarg}\n\t\t\trunme cmp $OUTDIR/${basename}_${samp}_${dct}.jpg $OUTDIR/${basename}_${samp}_${dct}_cjpeg.jpg\n\t\tdone\n\tdone\n\n\t# Recompression\n\tfor dct in fast accurate; do\n\t\tdctarg=\n\t\tif [ \"${dct}\" = \"fast\" ]; then\n\t\t\tdctarg=-fastdct\n\t\tfi\n\t\tfor samp in GRAY 420 422 444; do\n\t\t\trunme $TJEXAMPLE $OUTDIR/${basename}_${samp}_${dct}.jpg $OUTDIR/${basename}_${samp}_${dct}_recomp.jpg -q 95 -subsamp ${samp} ${dctarg}\n\t\t\trunme cmp $OUTDIR/${basename}_${samp}_${dct}_recomp.jpg $OUTDIR/${basename}_${samp}_${dct}_cjpeg2.jpg\n\t\tdone\n\tdone\n\n\t# Decompression\n\tfor dct in fast accurate; do\n\t\tdctarg=\n\t\tif [ \"${dct}\" = \"fast\" ]; then\n\t\t\tdctarg=-fastdct\n\t\tfi\n\t\tfor samp in GRAY 420 422 444; do\n\t\t\trunme $TJEXAMPLE $OUTDIR/${basename}_${samp}_${dct}.jpg $OUTDIR/${basename}_${samp}_${dct}.bmp ${dctarg}\n\t\t\trunme cmp -i 54:54 $OUTDIR/${basename}_${samp}_${dct}.bmp $OUTDIR/${basename}_${samp}_${dct}_djpeg.bmp\n\t\t\trm $OUTDIR/${basename}_${samp}_${dct}.bmp\n\t\tdone\n\t\tfor samp in 420 422; do\n\t\t\trunme $TJEXAMPLE $OUTDIR/${basename}_${samp}_${dct}.jpg $OUTDIR/${basename}_${samp}_${dct}_nosmooth.bmp -fastupsample ${dctarg}\n\t\t\trunme cmp -i 54:54 $OUTDIR/${basename}_${samp}_${dct}_nosmooth.bmp $OUTDIR/${basename}_${samp}_${dct}_nosmooth_djpeg.bmp\n\t\t\trm $OUTDIR/${basename}_${samp}_${dct}_nosmooth.bmp\n\t\tdone\n\tdone\n\n\t# Scaled decompression\n\tfor scale in 2_1 15_8 7_4 13_8 3_2 11_8 5_4 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8; do\n\t\tscalearg=`echo $scale | sed 's/\\_/\\//g'`\n\t\tfor samp in GRAY 420 422 444; do\n\t\t\trunme $EXEDIR/djpeg -rgb -bmp -scale ${scalearg} -outfile $OUTDIR/${basename}_${samp}_${scale}_djpeg.bmp $OUTDIR/${basename}_${samp}_fast_cjpeg.jpg\n\t\t\trunme $TJEXAMPLE $OUTDIR/${basename}_${samp}_fast.jpg $OUTDIR/${basename}_${samp}_${scale}.bmp -scale ${scalearg}\n\t\t\trunme cmp -i 54:54 $OUTDIR/${basename}_${samp}_${scale}.bmp $OUTDIR/${basename}_${samp}_${scale}_djpeg.bmp\n\t\t\trm $OUTDIR/${basename}_${samp}_${scale}.bmp\n\t\tdone\n\tdone\n\n\t# Transforms\n\tfor samp in GRAY 420 422 444; do\n\t\trunme $EXEDIR/jpegtran -crop 70x60+16+16 -flip horizontal -trim -outfile $OUTDIR/${basename}_${samp}_hflip_jpegtran.jpg $OUTDIR/${basename}_${samp}_fast.jpg\n\t\trunme $EXEDIR/jpegtran -crop 70x60+16+16 -flip vertical -trim -outfile $OUTDIR/${basename}_${samp}_vflip_jpegtran.jpg $OUTDIR/${basename}_${samp}_fast.jpg\n\t\trunme $EXEDIR/jpegtran -crop 70x60+16+16 -transpose -trim -outfile $OUTDIR/${basename}_${samp}_transpose_jpegtran.jpg $OUTDIR/${basename}_${samp}_fast.jpg\n\t\trunme $EXEDIR/jpegtran -crop 70x60+16+16 -transverse -trim -outfile $OUTDIR/${basename}_${samp}_transverse_jpegtran.jpg $OUTDIR/${basename}_${samp}_fast.jpg\n\t\trunme $EXEDIR/jpegtran -crop 70x60+16+16 -rotate 90 -trim -outfile $OUTDIR/${basename}_${samp}_rot90_jpegtran.jpg $OUTDIR/${basename}_${samp}_fast.jpg\n\t\trunme $EXEDIR/jpegtran -crop 70x60+16+16 -rotate 180 -trim -outfile $OUTDIR/${basename}_${samp}_rot180_jpegtran.jpg $OUTDIR/${basename}_${samp}_fast.jpg\n\t\trunme $EXEDIR/jpegtran -crop 70x60+16+16 -rotate 270 -trim -outfile $OUTDIR/${basename}_${samp}_rot270_jpegtran.jpg $OUTDIR/${basename}_${samp}_fast.jpg\n\tdone\n\tfor xform in hflip vflip transpose transverse rot90 rot180 rot270; do\n\t\tfor samp in GRAY 420 422 444; do\n\t\t\trunme $TJEXAMPLE $OUTDIR/${basename}_${samp}_fast.jpg $OUTDIR/${basename}_${samp}_${xform}.jpg -$xform -crop 70x60+16+16\n\t\t\trunme cmp $OUTDIR/${basename}_${samp}_${xform}.jpg $OUTDIR/${basename}_${samp}_${xform}_jpegtran.jpg\n\t\t\trunme $EXEDIR/djpeg -rgb -bmp -outfile $OUTDIR/${basename}_${samp}_${xform}_jpegtran.bmp $OUTDIR/${basename}_${samp}_${xform}_jpegtran.jpg\n\t\t\trunme $TJEXAMPLE $OUTDIR/${basename}_${samp}_fast.jpg $OUTDIR/${basename}_${samp}_${xform}.bmp -$xform -crop 70x60+16+16\n\t\t\trunme cmp -i 54:54 $OUTDIR/${basename}_${samp}_${xform}.bmp $OUTDIR/${basename}_${samp}_${xform}_jpegtran.bmp\n\t\t\trm $OUTDIR/${basename}_${samp}_${xform}.bmp\n\t\tdone\n\t\tfor samp in 420 422; do\n\t\t\trunme $EXEDIR/djpeg -nosmooth -rgb -bmp -outfile $OUTDIR/${basename}_${samp}_${xform}_jpegtran.bmp $OUTDIR/${basename}_${samp}_${xform}_jpegtran.jpg\n\t\t\trunme $TJEXAMPLE $OUTDIR/${basename}_${samp}_fast.jpg $OUTDIR/${basename}_${samp}_${xform}.bmp -$xform -crop 70x60+16+16 -fastupsample\n\t\t\trunme cmp -i 54:54 $OUTDIR/${basename}_${samp}_${xform}.bmp $OUTDIR/${basename}_${samp}_${xform}_jpegtran.bmp\n\t\t\trm $OUTDIR/${basename}_${samp}_${xform}.bmp\n\t\tdone\n\tdone\n\n\t# Grayscale transform\n\tfor xform in hflip vflip transpose transverse rot90 rot180 rot270; do\n\t\tfor samp in GRAY 444 422 420; do\n\t\t\trunme $TJEXAMPLE $OUTDIR/${basename}_${samp}_fast.jpg $OUTDIR/${basename}_${samp}_${xform}.jpg -$xform -grayscale -crop 70x60+16+16\n\t\t\trunme cmp $OUTDIR/${basename}_${samp}_${xform}.jpg $OUTDIR/${basename}_GRAY_${xform}_jpegtran.jpg\n\t\t\trunme $TJEXAMPLE $OUTDIR/${basename}_${samp}_fast.jpg $OUTDIR/${basename}_${samp}_${xform}.bmp -$xform -grayscale -crop 70x60+16+16\n\t\t\trunme cmp -i 54:54 $OUTDIR/${basename}_${samp}_${xform}.bmp $OUTDIR/${basename}_GRAY_${xform}_jpegtran.bmp\n\t\t\trm $OUTDIR/${basename}_${samp}_${xform}.bmp\n\t\tdone\n\tdone\n\n\t# Transforms with scaling\n\tfor xform in hflip vflip transpose transverse rot90 rot180 rot270; do\n\t\tfor samp in GRAY 444 422 420; do\n\t\t\tfor scale in 2_1 15_8 7_4 13_8 3_2 11_8 5_4 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8; do\n\t\t\t\tscalearg=`echo $scale | sed 's/\\_/\\//g'`\n\t\t\t\trunme $EXEDIR/djpeg -rgb -bmp -scale ${scalearg} -outfile $OUTDIR/${basename}_${samp}_${xform}_${scale}_jpegtran.bmp $OUTDIR/${basename}_${samp}_${xform}_jpegtran.jpg\n\t\t\t\trunme $TJEXAMPLE $OUTDIR/${basename}_${samp}_fast.jpg $OUTDIR/${basename}_${samp}_${xform}_${scale}.bmp -$xform -scale ${scalearg} -crop 70x60+16+16\n\t\t\t\trunme cmp -i 54:54 $OUTDIR/${basename}_${samp}_${xform}_${scale}.bmp $OUTDIR/${basename}_${samp}_${xform}_${scale}_jpegtran.bmp\n\t\t\t\trm $OUTDIR/${basename}_${samp}_${xform}_${scale}.bmp\n\t\t\tdone\n\t\tdone\n\tdone\n\ndone\n\necho SUCCESS!\n"
        },
        {
          "name": "tjunittest.c",
          "type": "blob",
          "size": 40.7841796875,
          "content": "/*\n * Copyright (C)2009-2014, 2017-2019, 2022-2024 D. R. Commander.\n *                                              All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program tests the various code paths in the TurboJPEG C Wrapper\n */\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n#include \"tjutil.h\"\n#include \"turbojpeg.h\"\n#include \"md5/md5.h\"\n#include \"jconfigint.h\"\n#ifdef _WIN32\n#include <time.h>\n#include <process.h>\n#define random()  rand()\n#define getpid()  _getpid()\n#else\n#include <unistd.h>\n#endif\n\n\nstatic void usage(char *progName)\n{\n  printf(\"\\nUSAGE: %s [options]\\n\\n\", progName);\n  printf(\"Options:\\n\");\n  printf(\"-yuv = test YUV encoding/compression/decompression/decoding\\n\");\n  printf(\"       (8-bit data precision only)\\n\");\n  printf(\"-noyuvpad = do not pad each row in each Y, U, and V plane to the nearest\\n\");\n  printf(\"            multiple of 4 bytes\\n\");\n  printf(\"-precision N = test N-bit data precision (N is 8, 12, or 16; default is 8; if N\\n\");\n  printf(\"               is 16, then -lossless is implied)\\n\");\n  printf(\"-lossless = test lossless JPEG compression/decompression\\n\");\n  printf(\"-alloc = test automatic JPEG buffer allocation\\n\");\n  printf(\"-bmp = test packed-pixel image I/O\\n\");\n  exit(1);\n}\n\n\n#define THROW_TJ(handle) { \\\n  printf(\"TurboJPEG ERROR:\\n%s\\n\", tj3GetErrorStr(handle)); \\\n  BAILOUT() \\\n}\n#define TRY_TJ(handle, f) { if ((f) == -1) THROW_TJ(handle); }\n#define THROW(m) { printf(\"ERROR: %s\\n\", m);  BAILOUT() }\n#define THROW_MD5(filename, md5sum, ref) { \\\n  printf(\"\\n%s has an MD5 sum of %s.\\n   Should be %s.\\n\", filename, md5sum, \\\n         ref); \\\n  BAILOUT() \\\n}\n\nstatic const char *subNameLong[TJ_NUMSAMP] = {\n  \"4:4:4\", \"4:2:2\", \"4:2:0\", \"GRAY\", \"4:4:0\", \"4:1:1\", \"4:4:1\"\n};\nstatic const char *subName[TJ_NUMSAMP] = {\n  \"444\", \"422\", \"420\", \"GRAY\", \"440\", \"411\", \"441\"\n};\n\nstatic const char *pixFormatStr[TJ_NUMPF] = {\n  \"RGB\", \"BGR\", \"RGBX\", \"BGRX\", \"XBGR\", \"XRGB\", \"Grayscale\",\n  \"RGBA\", \"BGRA\", \"ABGR\", \"ARGB\", \"CMYK\"\n};\n\nstatic const int _3sampleFormats[] = { TJPF_RGB, TJPF_BGR };\nstatic const int _4sampleFormats[] = {\n  TJPF_RGBX, TJPF_BGRX, TJPF_XBGR, TJPF_XRGB, TJPF_CMYK\n};\nstatic const int _onlyGray[] = { TJPF_GRAY };\nstatic const int _onlyRGB[] = { TJPF_RGB };\n\nstatic int doYUV = 0, lossless = 0, psv = 1, alloc = 0, yuvAlign = 4;\nstatic int precision = 8, sampleSize, maxSample, tolerance, redToY, yellowToY;\n\nstatic int exitStatus = 0;\n#define BAILOUT() { exitStatus = -1;  goto bailout; }\n\n\nstatic void setVal(void *buf, int index, int value)\n{\n  if (precision == 8)\n    ((unsigned char *)buf)[index] = (unsigned char)value;\n  else if (precision == 12)\n    ((short *)buf)[index] = (short)value;\n  else\n    ((unsigned short *)buf)[index] = (unsigned short)value;\n}\n\nstatic void initBuf(void *buf, int w, int h, int pf, int bottomUp)\n{\n  int roffset = tjRedOffset[pf];\n  int goffset = tjGreenOffset[pf];\n  int boffset = tjBlueOffset[pf];\n  int ps = tjPixelSize[pf];\n  int i, index, row, col, halfway = 16;\n\n  if (pf == TJPF_GRAY) {\n    memset(buf, 0, w * h * ps * sampleSize);\n    for (row = 0; row < h; row++) {\n      for (col = 0; col < w; col++) {\n        if (bottomUp) index = (h - row - 1) * w + col;\n        else index = row * w + col;\n        if (((row / 8) + (col / 8)) % 2 == 0)\n          setVal(buf, index, (row < halfway) ? maxSample : 0);\n        else setVal(buf, index, (row < halfway) ? redToY : yellowToY);\n      }\n    }\n  } else if (pf == TJPF_CMYK) {\n    for (i = 0; i < w * h * ps; i++)\n      setVal(buf, i, maxSample);\n    for (row = 0; row < h; row++) {\n      for (col = 0; col < w; col++) {\n        if (bottomUp) index = (h - row - 1) * w + col;\n        else index = row * w + col;\n        if (((row / 8) + (col / 8)) % 2 == 0) {\n          if (row >= halfway) setVal(buf, index * ps + 3, 0);\n        } else {\n          setVal(buf, index * ps + 2, 0);\n          if (row < halfway) setVal(buf, index * ps + 1, 0);\n        }\n      }\n    }\n  } else {\n    memset(buf, 0, w * h * ps * sampleSize);\n    for (row = 0; row < h; row++) {\n      for (col = 0; col < w; col++) {\n        if (bottomUp) index = (h - row - 1) * w + col;\n        else index = row * w + col;\n        if (((row / 8) + (col / 8)) % 2 == 0) {\n          if (row < halfway) {\n            setVal(buf, index * ps + roffset, maxSample);\n            setVal(buf, index * ps + goffset, maxSample);\n            setVal(buf, index * ps + boffset, maxSample);\n          }\n        } else {\n          setVal(buf, index * ps + roffset, maxSample);\n          if (row >= halfway) setVal(buf, index * ps + goffset, maxSample);\n        }\n      }\n    }\n  }\n}\n\n\n#define CHECKVAL(v, cv) { \\\n  if (v < cv - tolerance || v > cv + tolerance) { \\\n    printf(\"\\nComp. %s at %d,%d should be %d, not %d\\n\", #v, row, col, cv, \\\n           v); \\\n    retval = 0;  exitStatus = -1;  goto bailout; \\\n  } \\\n}\n\n#define CHECKVAL0(v) { \\\n  if (v > tolerance) { \\\n    printf(\"\\nComp. %s at %d,%d should be 0, not %d\\n\", #v, row, col, v); \\\n    retval = 0;  exitStatus = -1;  goto bailout; \\\n  } \\\n}\n\n#define CHECKVALMAX(v) { \\\n  if (v < maxSample - tolerance) { \\\n    printf(\"\\nComp. %s at %d,%d should be %d, not %d\\n\", #v, row, col, \\\n           maxSample, v); \\\n    retval = 0;  exitStatus = -1;  goto bailout; \\\n  } \\\n}\n\n\nstatic int getVal(void *buf, int index)\n{\n  if (precision == 8)\n    return ((unsigned char *)buf)[index];\n  else if (precision == 12)\n    return ((short *)buf)[index];\n  else\n    return ((unsigned short *)buf)[index];\n}\n\nstatic int checkBuf(void *buf, int w, int h, int pf,  int subsamp,\n                    tjscalingfactor sf, int bottomUp)\n{\n  int roffset = tjRedOffset[pf];\n  int goffset = tjGreenOffset[pf];\n  int boffset = tjBlueOffset[pf];\n  int aoffset = tjAlphaOffset[pf];\n  int ps = tjPixelSize[pf];\n  int index, row, col, retval = 1;\n  int halfway = 16 * sf.num / sf.denom;\n  int blocksize = 8 * sf.num / sf.denom;\n\n  if (pf == TJPF_GRAY) roffset = goffset = boffset = 0;\n\n  if (pf == TJPF_CMYK) {\n    for (row = 0; row < h; row++) {\n      for (col = 0; col < w; col++) {\n        int c, m, y, k;\n\n        if (bottomUp) index = (h - row - 1) * w + col;\n        else index = row * w + col;\n        c = getVal(buf, index * ps);\n        m = getVal(buf, index * ps + 1);\n        y = getVal(buf, index * ps + 2);\n        k = getVal(buf, index * ps + 3);\n        if (((row / blocksize) + (col / blocksize)) % 2 == 0) {\n          CHECKVALMAX(c);  CHECKVALMAX(m);  CHECKVALMAX(y);\n          if (row < halfway) CHECKVALMAX(k)\n          else CHECKVAL0(k)\n        } else {\n          CHECKVALMAX(c);  CHECKVAL0(y);  CHECKVALMAX(k);\n          if (row < halfway) CHECKVAL0(m)\n          else CHECKVALMAX(m)\n        }\n      }\n    }\n    return 1;\n  }\n\n  for (row = 0; row < h; row++) {\n    for (col = 0; col < w; col++) {\n      int r, g, b, a;\n\n      if (bottomUp) index = (h - row - 1) * w + col;\n      else index = row * w + col;\n      r = getVal(buf, index * ps + roffset);\n      g = getVal(buf, index * ps + goffset);\n      b = getVal(buf, index * ps + boffset);\n      a = aoffset >= 0 ? getVal(buf, index * ps + aoffset) : maxSample;\n      if (((row / blocksize) + (col / blocksize)) % 2 == 0) {\n        if (row < halfway) {\n          CHECKVALMAX(r);  CHECKVALMAX(g);  CHECKVALMAX(b);\n        } else {\n          CHECKVAL0(r);  CHECKVAL0(g);  CHECKVAL0(b);\n        }\n      } else {\n        if (subsamp == TJSAMP_GRAY) {\n          if (row < halfway) {\n            CHECKVAL(r, redToY);  CHECKVAL(g, redToY);  CHECKVAL(b, redToY);\n          } else {\n            CHECKVAL(r, yellowToY);  CHECKVAL(g, yellowToY);\n            CHECKVAL(b, yellowToY);\n          }\n        } else {\n          if (row < halfway) {\n            CHECKVALMAX(r);  CHECKVAL0(g);  CHECKVAL0(b);\n          } else {\n            CHECKVALMAX(r);  CHECKVALMAX(g);  CHECKVAL0(b);\n          }\n        }\n      }\n      CHECKVALMAX(a);\n    }\n  }\n\nbailout:\n  if (retval == 0) {\n    for (row = 0; row < h; row++) {\n      for (col = 0; col < w; col++) {\n        if (pf == TJPF_CMYK)\n          printf(\"%.3d/%.3d/%.3d/%.3d \", getVal(buf, (row * w + col) * ps),\n                 getVal(buf, (row * w + col) * ps + 1),\n                 getVal(buf, (row * w + col) * ps + 2),\n                 getVal(buf, (row * w + col) * ps + 3));\n        else\n          printf(\"%.3d/%.3d/%.3d \",\n                 getVal(buf, (row * w + col) * ps + roffset),\n                 getVal(buf, (row * w + col) * ps + goffset),\n                 getVal(buf, (row * w + col) * ps + boffset));\n      }\n      printf(\"\\n\");\n    }\n  }\n  return retval;\n}\n\n\n#define PAD(v, p)  ((v + (p) - 1) & (~((p) - 1)))\n\nstatic int checkBufYUV(unsigned char *buf, int w, int h, int subsamp,\n                       tjscalingfactor sf)\n{\n  int row, col;\n  int hsf = tjMCUWidth[subsamp] / 8, vsf = tjMCUHeight[subsamp] / 8;\n  int pw = PAD(w, hsf), ph = PAD(h, vsf);\n  int cw = pw / hsf, ch = ph / vsf;\n  int ypitch = PAD(pw, yuvAlign), uvpitch = PAD(cw, yuvAlign);\n  int retval = 1;\n  int halfway = 16 * sf.num / sf.denom;\n  int blocksize = 8 * sf.num / sf.denom;\n\n  for (row = 0; row < ph; row++) {\n    for (col = 0; col < pw; col++) {\n      unsigned char y = buf[ypitch * row + col];\n\n      if (((row / blocksize) + (col / blocksize)) % 2 == 0) {\n        if (row < halfway) CHECKVALMAX(y)\n        else CHECKVAL0(y);\n      } else {\n        if (row < halfway) CHECKVAL(y, 76)\n        else CHECKVAL(y, 225);\n      }\n    }\n  }\n  if (subsamp != TJSAMP_GRAY) {\n    halfway = 16 / vsf * sf.num / sf.denom;\n\n    for (row = 0; row < ch; row++) {\n      for (col = 0; col < cw; col++) {\n        unsigned char u = buf[ypitch * ph + (uvpitch * row + col)],\n          v = buf[ypitch * ph + uvpitch * ch + (uvpitch * row + col)];\n\n        if (((row * vsf / blocksize) + (col * hsf / blocksize)) % 2 == 0) {\n          CHECKVAL(u, 128);  CHECKVAL(v, 128);\n        } else {\n          if (row < halfway) {\n            CHECKVAL(u, 85);  CHECKVALMAX(v);\n          } else {\n            CHECKVAL0(u);  CHECKVAL(v, 149);\n          }\n        }\n      }\n    }\n  }\n\nbailout:\n  if (retval == 0) {\n    for (row = 0; row < ph; row++) {\n      for (col = 0; col < pw; col++)\n        printf(\"%.3d \", buf[ypitch * row + col]);\n      printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    for (row = 0; row < ch; row++) {\n      for (col = 0; col < cw; col++)\n        printf(\"%.3d \", buf[ypitch * ph + (uvpitch * row + col)]);\n      printf(\"\\n\");\n    }\n    printf(\"\\n\");\n    for (row = 0; row < ch; row++) {\n      for (col = 0; col < cw; col++)\n        printf(\"%.3d \",\n               buf[ypitch * ph + uvpitch * ch + (uvpitch * row + col)]);\n      printf(\"\\n\");\n    }\n  }\n\n  return retval;\n}\n\n\nstatic void writeJPEG(unsigned char *jpegBuf, size_t jpegSize, char *filename)\n{\n  FILE *file = fopen(filename, \"wb\");\n\n  if (!file || fwrite(jpegBuf, jpegSize, 1, file) != 1) {\n    printf(\"ERROR: Could not write to %s.\\n%s\\n\", filename, strerror(errno));\n    BAILOUT()\n  }\n\nbailout:\n  if (file) fclose(file);\n}\n\n\nstatic void compTest(tjhandle handle, unsigned char **dstBuf, size_t *dstSize,\n                     int w, int h, int pf, char *basename)\n{\n  char tempStr[1024];\n  void *srcBuf = NULL;\n  unsigned char *yuvBuf = NULL;\n  const char *pfStr = pixFormatStr[pf];\n  int bottomUp = tj3Get(handle, TJPARAM_BOTTOMUP);\n  int subsamp = tj3Get(handle, TJPARAM_SUBSAMP);\n  int jpegPSV = tj3Get(handle, TJPARAM_LOSSLESSPSV);\n  int jpegQual = tj3Get(handle, TJPARAM_QUALITY);\n  const char *buStrLong = bottomUp ? \"Bottom-Up\" : \"Top-Down \";\n  const char *buStr = bottomUp ? \"BU\" : \"TD\";\n\n  if ((srcBuf = malloc(w * h * tjPixelSize[pf] * sampleSize)) == NULL)\n      THROW(\"Memory allocation failure\");\n  initBuf(srcBuf, w, h, pf, bottomUp);\n\n  if (*dstBuf && *dstSize > 0) memset(*dstBuf, 0, *dstSize);\n\n  if (doYUV) {\n    size_t yuvSize = tj3YUVBufSize(w, yuvAlign, h, subsamp);\n    tjscalingfactor sf = { 1, 1 };\n    tjhandle handle2 = NULL;\n\n    if ((handle2 = tj3Init(TJINIT_COMPRESS)) == NULL)\n      THROW_TJ(NULL);\n    TRY_TJ(handle2, tj3Set(handle2, TJPARAM_BOTTOMUP, bottomUp));\n    TRY_TJ(handle2, tj3Set(handle2, TJPARAM_SUBSAMP, subsamp));\n\n    if ((yuvBuf = (unsigned char *)malloc(yuvSize)) == NULL)\n      THROW(\"Memory allocation failure\");\n    memset(yuvBuf, 0, yuvSize);\n\n    printf(\"%s %s -> YUV %s ... \", pfStr, buStrLong, subNameLong[subsamp]);\n    TRY_TJ(handle2, tj3EncodeYUV8(handle2, (unsigned char *)srcBuf, w, 0, h,\n                                  pf, yuvBuf, yuvAlign));\n    tj3Destroy(handle2);\n    if (checkBufYUV(yuvBuf, w, h, subsamp, sf)) printf(\"Passed.\\n\");\n    else printf(\"FAILED!\\n\");\n\n    printf(\"YUV %s %s -> JPEG Q%d ... \", subNameLong[subsamp], buStrLong,\n           jpegQual);\n    TRY_TJ(handle, tj3CompressFromYUV8(handle, yuvBuf, w, yuvAlign, h, dstBuf,\n                                       dstSize));\n  } else {\n    if (lossless)\n      printf(\"%s %s -> LOSSLESS PSV%d ... \", pfStr, buStrLong, jpegPSV);\n    else\n      printf(\"%s %s -> %s Q%d ... \", pfStr, buStrLong, subNameLong[subsamp],\n             jpegQual);\n    if (precision == 8) {\n      TRY_TJ(handle, tj3Compress8(handle, (unsigned char *)srcBuf, w, 0, h, pf,\n                                  dstBuf, dstSize));\n    } else if (precision == 12) {\n      TRY_TJ(handle, tj3Compress12(handle, (short *)srcBuf, w, 0, h, pf,\n                                   dstBuf, dstSize));\n    } else {\n      TRY_TJ(handle, tj3Compress16(handle, (unsigned short *)srcBuf, w, 0, h,\n                                   pf, dstBuf, dstSize));\n    }\n  }\n\n  if (lossless)\n    SNPRINTF(tempStr, 1024, \"%s_enc%d_%s_%s_LOSSLESS_PSV%d.jpg\", basename,\n             precision, pfStr, buStr, jpegPSV);\n  else\n    SNPRINTF(tempStr, 1024, \"%s_enc%d_%s_%s_%s_Q%d.jpg\", basename, precision,\n             pfStr, buStr, subName[subsamp], jpegQual);\n  writeJPEG(*dstBuf, *dstSize, tempStr);\n  printf(\"Done.\\n  Result in %s\\n\", tempStr);\n\nbailout:\n  free(yuvBuf);\n  free(srcBuf);\n}\n\n\nstatic void _decompTest(tjhandle handle, unsigned char *jpegBuf,\n                        size_t jpegSize, int w, int h, int pf, char *basename,\n                        int subsamp, tjscalingfactor sf)\n{\n  void *dstBuf = NULL;\n  unsigned char *yuvBuf = NULL;\n  int _hdrw = 0, _hdrh = 0, _hdrsubsamp;\n  int scaledWidth = TJSCALED(w, sf);\n  int scaledHeight = TJSCALED(h, sf);\n  size_t dstSize = 0;\n  int bottomUp = tj3Get(handle, TJPARAM_BOTTOMUP);\n\n  TRY_TJ(handle, tj3SetScalingFactor(handle, sf));\n\n  TRY_TJ(handle, tj3DecompressHeader(handle, jpegBuf, jpegSize));\n  _hdrw = tj3Get(handle, TJPARAM_JPEGWIDTH);\n  _hdrh = tj3Get(handle, TJPARAM_JPEGHEIGHT);\n  _hdrsubsamp = tj3Get(handle, TJPARAM_SUBSAMP);\n  if (lossless && subsamp != TJSAMP_444 && subsamp != TJSAMP_GRAY)\n    subsamp = TJSAMP_444;\n  if (_hdrw != w || _hdrh != h || _hdrsubsamp != subsamp)\n    THROW(\"Incorrect JPEG header\");\n\n  dstSize = scaledWidth * scaledHeight * tjPixelSize[pf];\n  if ((dstBuf = malloc(dstSize * sampleSize)) == NULL)\n    THROW(\"Memory allocation failure\");\n  memset(dstBuf, 0, dstSize * sampleSize);\n\n  if (doYUV) {\n    size_t yuvSize = tj3YUVBufSize(scaledWidth, yuvAlign, scaledHeight,\n                                   subsamp);\n    tjhandle handle2 = NULL;\n\n    if ((handle2 = tj3Init(TJINIT_DECOMPRESS)) == NULL)\n      THROW_TJ(NULL);\n    TRY_TJ(handle2, tj3Set(handle2, TJPARAM_BOTTOMUP, bottomUp));\n    TRY_TJ(handle2, tj3Set(handle2, TJPARAM_SUBSAMP, subsamp));\n\n    if ((yuvBuf = (unsigned char *)malloc(yuvSize)) == NULL)\n      THROW(\"Memory allocation failure\");\n    memset(yuvBuf, 0, yuvSize);\n\n    printf(\"JPEG -> YUV %s \", subNameLong[subsamp]);\n    if (sf.num != 1 || sf.denom != 1)\n      printf(\"%d/%d ... \", sf.num, sf.denom);\n    else printf(\"... \");\n    TRY_TJ(handle, tj3DecompressToYUV8(handle, jpegBuf, jpegSize, yuvBuf,\n                                       yuvAlign));\n    if (checkBufYUV(yuvBuf, scaledWidth, scaledHeight, subsamp, sf))\n      printf(\"Passed.\\n\");\n    else printf(\"FAILED!\\n\");\n\n    printf(\"YUV %s -> %s %s ... \", subNameLong[subsamp], pixFormatStr[pf],\n           bottomUp ? \"Bottom-Up\" : \"Top-Down \");\n    TRY_TJ(handle2, tj3DecodeYUV8(handle2, yuvBuf, yuvAlign,\n                                  (unsigned char *)dstBuf, scaledWidth, 0,\n                                  scaledHeight, pf));\n    tj3Destroy(handle2);\n  } else {\n    printf(\"JPEG -> %s %s \", pixFormatStr[pf],\n           bottomUp ? \"Bottom-Up\" : \"Top-Down \");\n    if (sf.num != 1 || sf.denom != 1)\n      printf(\"%d/%d ... \", sf.num, sf.denom);\n    else printf(\"... \");\n    if (precision == 8) {\n      TRY_TJ(handle, tj3Decompress8(handle, jpegBuf, jpegSize,\n                                    (unsigned char *)dstBuf, 0, pf));\n    } else if (precision == 12) {\n      TRY_TJ(handle, tj3Decompress12(handle, jpegBuf, jpegSize,\n                                     (short *)dstBuf, 0, pf));\n    } else {\n      TRY_TJ(handle, tj3Decompress16(handle, jpegBuf, jpegSize,\n                                     (unsigned short *)dstBuf, 0, pf));\n    }\n  }\n\n  if (checkBuf(dstBuf, scaledWidth, scaledHeight, pf, subsamp, sf, bottomUp))\n    printf(\"Passed.\");\n  else printf(\"FAILED!\");\n  printf(\"\\n\");\n\nbailout:\n  free(yuvBuf);\n  free(dstBuf);\n}\n\n\nstatic void decompTest(tjhandle handle, unsigned char *jpegBuf,\n                       size_t jpegSize, int w, int h, int pf, char *basename,\n                       int subsamp)\n{\n  int i, n = 0;\n  tjscalingfactor *sf = NULL;\n\n  if (lossless) {\n    _decompTest(handle, jpegBuf, jpegSize, w, h, pf, basename, subsamp,\n                TJUNSCALED);\n    return;\n  }\n\n  sf = tj3GetScalingFactors(&n);\n  if (!sf || !n) THROW_TJ(NULL);\n\n  for (i = 0; i < n; i++) {\n    if (subsamp == TJSAMP_444 || subsamp == TJSAMP_GRAY ||\n        ((subsamp == TJSAMP_411 || subsamp == TJSAMP_441) && sf[i].num == 1 &&\n         (sf[i].denom == 2 || sf[i].denom == 1)) ||\n        (subsamp != TJSAMP_411 && subsamp != TJSAMP_441 && sf[i].num == 1 &&\n         (sf[i].denom == 4 || sf[i].denom == 2 || sf[i].denom == 1)))\n      _decompTest(handle, jpegBuf, jpegSize, w, h, pf, basename, subsamp,\n                  sf[i]);\n  }\n\nbailout:\n  return;\n}\n\n\nstatic void doTest(int w, int h, const int *formats, int nformats, int subsamp,\n                   char *basename)\n{\n  tjhandle chandle = NULL, dhandle = NULL;\n  unsigned char *dstBuf = NULL;\n  size_t size = 0;\n  int pfi, pf, i;\n\n  if (lossless && subsamp != TJSAMP_GRAY)\n    subsamp = TJSAMP_444;\n\n  if (!alloc)\n    size = tj3JPEGBufSize(w, h, subsamp);\n  if (size != 0)\n    if ((dstBuf = (unsigned char *)tj3Alloc(size)) == NULL)\n      THROW(\"Memory allocation failure.\");\n\n  if ((chandle = tj3Init(TJINIT_COMPRESS)) == NULL ||\n      (dhandle = tj3Init(TJINIT_DECOMPRESS)) == NULL)\n    THROW_TJ(NULL);\n\n  TRY_TJ(chandle, tj3Set(chandle, TJPARAM_NOREALLOC, !alloc));\n  if (lossless) {\n    TRY_TJ(chandle, tj3Set(chandle, TJPARAM_LOSSLESS, lossless));\n    TRY_TJ(chandle, tj3Set(chandle, TJPARAM_LOSSLESSPSV,\n                           ((psv++ - 1) % 7) + 1));\n  } else {\n    TRY_TJ(chandle, tj3Set(chandle, TJPARAM_QUALITY, 100));\n    if (subsamp == TJSAMP_422 || subsamp == TJSAMP_420 ||\n        subsamp == TJSAMP_440 || subsamp == TJSAMP_411 ||\n        subsamp == TJSAMP_441)\n      TRY_TJ(dhandle, tj3Set(dhandle, TJPARAM_FASTUPSAMPLE, 1));\n  }\n  TRY_TJ(chandle, tj3Set(chandle, TJPARAM_SUBSAMP, subsamp));\n\n  for (pfi = 0; pfi < nformats; pfi++) {\n    for (i = 0; i < 2; i++) {\n      TRY_TJ(chandle, tj3Set(chandle, TJPARAM_BOTTOMUP, i == 1));\n      TRY_TJ(dhandle, tj3Set(dhandle, TJPARAM_BOTTOMUP, i == 1));\n      pf = formats[pfi];\n      compTest(chandle, &dstBuf, &size, w, h, pf, basename);\n      decompTest(dhandle, dstBuf, size, w, h, pf, basename, subsamp);\n      if (pf >= TJPF_RGBX && pf <= TJPF_XRGB) {\n        printf(\"\\n\");\n        decompTest(dhandle, dstBuf, size, w, h, pf + (TJPF_RGBA - TJPF_RGBX),\n                   basename, subsamp);\n      }\n      printf(\"\\n\");\n    }\n  }\n  printf(\"--------------------\\n\\n\");\n\nbailout:\n  tj3Destroy(chandle);\n  tj3Destroy(dhandle);\n  tj3Free(dstBuf);\n}\n\n\n#if SIZEOF_SIZE_T == 8\n#define CHECKSIZE(function) { \\\n  if (size && size < (size_t)0xFFFFFFFF) \\\n    THROW(#function \" overflow\"); \\\n}\n#define CHECKSIZEUL(function) { \\\n  if ((unsigned long long)ulsize < (unsigned long long)0xFFFFFFFF) \\\n    THROW(#function \" overflow\"); \\\n}\n#else\n#define CHECKSIZE(function) { \\\n  if (size != 0 || !strcmp(tj3GetErrorStr(NULL), \"No error\")) \\\n    THROW(#function \" overflow\"); \\\n}\n#define CHECKSIZEUL(function) { \\\n  if (ulsize != (unsigned long)(-1) || \\\n      !strcmp(tj3GetErrorStr(NULL), \"No error\")) \\\n    THROW(#function \" overflow\"); \\\n}\n#endif\n#define CHECKSIZEINT(function) { \\\n  if (intsize != 0 || !strcmp(tj3GetErrorStr(NULL), \"No error\")) \\\n    THROW(#function \" overflow\"); \\\n}\n\nstatic void overflowTest(void)\n{\n  /* Ensure that the various buffer size functions don't overflow */\n  size_t size;\n  unsigned long ulsize;\n  int intsize;\n\n  size = tj3JPEGBufSize(26755, 26755, TJSAMP_444);\n  CHECKSIZE(tj3JPEGBufSize());\n  ulsize = tjBufSize(26755, 26755, TJSAMP_444);\n  CHECKSIZEUL(tjBufSize());\n  ulsize = TJBUFSIZE(26755, 26755);\n  CHECKSIZEUL(TJBUFSIZE());\n  size = tj3YUVBufSize(37838, 1, 37838, TJSAMP_444);\n  CHECKSIZE(tj3YUVBufSize());\n  size = tj3YUVBufSize(37837, 3, 37837, TJSAMP_444);\n  CHECKSIZE(tj3YUVBufSize());\n  size = tj3YUVBufSize(37837, -1, 37837, TJSAMP_444);\n  CHECKSIZE(tj3YUVBufSize());\n  ulsize = tjBufSizeYUV2(37838, 1, 37838, TJSAMP_444);\n  CHECKSIZEUL(tjBufSizeYUV2());\n  ulsize = tjBufSizeYUV2(37837, 3, 37837, TJSAMP_444);\n  CHECKSIZEUL(tjBufSizeYUV2());\n  ulsize = tjBufSizeYUV2(37837, -1, 37837, TJSAMP_444);\n  CHECKSIZEUL(tjBufSizeYUV2());\n  ulsize = TJBUFSIZEYUV(37838, 37838, TJSAMP_444);\n  CHECKSIZEUL(TJBUFSIZEYUV());\n  ulsize = tjBufSizeYUV(37838, 37838, TJSAMP_444);\n  CHECKSIZEUL(tjBufSizeYUV());\n  size = tj3YUVPlaneSize(0, 65536, 0, 65536, TJSAMP_444);\n  CHECKSIZE(tj3YUVPlaneSize());\n  ulsize = tjPlaneSizeYUV(0, 65536, 0, 65536, TJSAMP_444);\n  CHECKSIZEUL(tjPlaneSizeYUV());\n  intsize = tj3YUVPlaneWidth(0, INT_MAX, TJSAMP_420);\n  CHECKSIZEINT(tj3YUVPlaneWidth());\n  intsize = tj3YUVPlaneHeight(0, INT_MAX, TJSAMP_420);\n  CHECKSIZEINT(tj3YUVPlaneHeight());\n\nbailout:\n  return;\n}\n\n\nstatic void bufSizeTest(void)\n{\n  int w, h, i, subsamp;\n  void *srcBuf = NULL;\n  unsigned char *dstBuf = NULL;\n  tjhandle handle = NULL;\n  size_t dstSize = 0;\n  int numSamp = TJ_NUMSAMP;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n    THROW_TJ(NULL);\n\n  TRY_TJ(handle, tj3Set(handle, TJPARAM_NOREALLOC, !alloc));\n  if (lossless) {\n    TRY_TJ(handle, tj3Set(handle, TJPARAM_LOSSLESS, lossless));\n    TRY_TJ(handle, tj3Set(handle, TJPARAM_LOSSLESSPSV,\n                          ((psv++ - 1) % 7) + 1));\n    numSamp = 1;\n  } else\n    TRY_TJ(handle, tj3Set(handle, TJPARAM_QUALITY, 100));\n\n  printf(\"Buffer size regression test\\n\");\n  for (subsamp = 0; subsamp < numSamp; subsamp++) {\n    TRY_TJ(handle, tj3Set(handle, TJPARAM_SUBSAMP, subsamp));\n    for (w = 1; w < 48; w++) {\n      int maxh = (w == 1) ? 2048 : 48;\n\n      for (h = 1; h < maxh; h++) {\n        if (h % 100 == 0) printf(\"%.4d x %.4d\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b\", w, h);\n        if ((srcBuf = malloc(w * h * 4 * sampleSize)) == NULL)\n          THROW(\"Memory allocation failure\");\n        if (!alloc || doYUV) {\n          if (doYUV) dstSize = tj3YUVBufSize(w, yuvAlign, h, subsamp);\n          else dstSize = tj3JPEGBufSize(w, h, subsamp);\n          if ((dstBuf = (unsigned char *)tj3Alloc(dstSize)) == NULL)\n            THROW(\"Memory allocation failure\");\n        }\n\n        for (i = 0; i < w * h * 4; i++) {\n          if (random() < RAND_MAX / 2) setVal(srcBuf, i, 0);\n          else setVal(srcBuf, i, maxSample);\n        }\n\n        if (doYUV) {\n          TRY_TJ(handle, tj3EncodeYUV8(handle, (unsigned char *)srcBuf, w, 0,\n                                       h, TJPF_BGRX, dstBuf, yuvAlign));\n        } else {\n          if (precision == 8) {\n            TRY_TJ(handle, tj3Compress8(handle, (unsigned char *)srcBuf, w, 0,\n                                        h, TJPF_BGRX, &dstBuf, &dstSize));\n          } else if (precision == 12) {\n            TRY_TJ(handle, tj3Compress12(handle, (short *)srcBuf, w, 0, h,\n                                         TJPF_BGRX, &dstBuf, &dstSize));\n          } else {\n            TRY_TJ(handle, tj3Compress16(handle, (unsigned short *)srcBuf, w,\n                                         0, h, TJPF_BGRX, &dstBuf, &dstSize));\n          }\n        }\n        free(srcBuf);  srcBuf = NULL;\n        if (!alloc || doYUV) {\n          tj3Free(dstBuf);  dstBuf = NULL;\n        }\n\n        if ((srcBuf = malloc(h * w * 4 * sampleSize)) == NULL)\n          THROW(\"Memory allocation failure\");\n        if (!alloc || doYUV) {\n          if (doYUV) dstSize = tj3YUVBufSize(h, yuvAlign, w, subsamp);\n          else dstSize = tj3JPEGBufSize(h, w, subsamp);\n          if ((dstBuf = (unsigned char *)tj3Alloc(dstSize)) == NULL)\n            THROW(\"Memory allocation failure\");\n        }\n\n        for (i = 0; i < h * w * 4; i++) {\n          if (random() < RAND_MAX / 2) setVal(srcBuf, i, 0);\n          else setVal(srcBuf, i, maxSample);\n        }\n\n        if (doYUV) {\n          TRY_TJ(handle, tj3EncodeYUV8(handle, (unsigned char *)srcBuf, h, 0,\n                                       w, TJPF_BGRX, dstBuf, yuvAlign));\n        } else {\n          if (precision == 8) {\n            TRY_TJ(handle, tj3Compress8(handle, (unsigned char *)srcBuf, h, 0,\n                                        w, TJPF_BGRX, &dstBuf, &dstSize));\n          } else if (precision == 12) {\n            TRY_TJ(handle, tj3Compress12(handle, (short *)srcBuf, h, 0, w,\n                                         TJPF_BGRX, &dstBuf, &dstSize));\n          } else {\n            TRY_TJ(handle, tj3Compress16(handle, (unsigned short *)srcBuf, h,\n                                         0, w, TJPF_BGRX, &dstBuf, &dstSize));\n          }\n        }\n        free(srcBuf);  srcBuf = NULL;\n        if (!alloc || doYUV) {\n          tj3Free(dstBuf);  dstBuf = NULL;\n        }\n      }\n    }\n  }\n  printf(\"Done.      \\n\");\n\nbailout:\n  free(srcBuf);\n  tj3Free(dstBuf);\n  tj3Destroy(handle);\n}\n\n\nstatic void rgb_to_cmyk(int r, int g, int b, int *c, int *m, int *y, int *k)\n{\n  double ctmp = 1.0 - ((double)r / (double)maxSample);\n  double mtmp = 1.0 - ((double)g / (double)maxSample);\n  double ytmp = 1.0 - ((double)b / (double)maxSample);\n  double ktmp = min(min(ctmp, mtmp), ytmp);\n\n  if (ktmp == 1.0) ctmp = mtmp = ytmp = 0.0;\n  else {\n    ctmp = (ctmp - ktmp) / (1.0 - ktmp);\n    mtmp = (mtmp - ktmp) / (1.0 - ktmp);\n    ytmp = (ytmp - ktmp) / (1.0 - ktmp);\n  }\n  *c = (int)((double)maxSample - ctmp * (double)maxSample + 0.5);\n  *m = (int)((double)maxSample - mtmp * (double)maxSample + 0.5);\n  *y = (int)((double)maxSample - ytmp * (double)maxSample + 0.5);\n  *k = (int)((double)maxSample - ktmp * (double)maxSample + 0.5);\n}\n\nstatic void initBitmap(void *buf, int width, int pitch, int height, int pf,\n                       int bottomUp)\n{\n  int roffset = tjRedOffset[pf];\n  int goffset = tjGreenOffset[pf];\n  int boffset = tjBlueOffset[pf];\n  int ps = tjPixelSize[pf];\n  int i, j, ci;\n\n  for (j = 0; j < height; j++) {\n    int row = bottomUp ? height - j - 1 : j;\n\n    for (i = 0; i < width; i++) {\n      int r = (i * (maxSample + 1) / width) % (maxSample + 1);\n      int g = (j * (maxSample + 1) / height) % (maxSample + 1);\n      int b = (j * (maxSample + 1) / height +\n               i * (maxSample + 1) / width) % (maxSample + 1);\n\n      for (ci = 0; ci < ps; ci++)\n        setVal(buf, row * pitch + i * ps + ci, 0);\n      if (pf == TJPF_GRAY) setVal(buf, row * pitch + i * ps, b);\n      else if (pf == TJPF_CMYK) {\n        int c, m, y, k;\n\n        rgb_to_cmyk(r, g, b, &c, &m, &y, &k);\n        setVal(buf, row * pitch + i * ps + 0, c);\n        setVal(buf, row * pitch + i * ps + 1, m);\n        setVal(buf, row * pitch + i * ps + 2, y);\n        setVal(buf, row * pitch + i * ps + 3, k);\n      } else {\n        setVal(buf, row * pitch + i * ps + roffset, r);\n        setVal(buf, row * pitch + i * ps + goffset, g);\n        setVal(buf, row * pitch + i * ps + boffset, b);\n      }\n    }\n  }\n}\n\n\nstatic void cmyk_to_rgb(int c, int m, int y, int k, int *r, int *g, int *b)\n{\n  *r = (int)((double)c * (double)k / (double)maxSample + 0.5);\n  *g = (int)((double)m * (double)k / (double)maxSample + 0.5);\n  *b = (int)((double)y * (double)k / (double)maxSample + 0.5);\n}\n\nstatic int cmpBitmap(void *buf, int width, int pitch, int height, int pf,\n                     int bottomUp, int gray2rgb)\n{\n  int roffset = tjRedOffset[pf];\n  int goffset = tjGreenOffset[pf];\n  int boffset = tjBlueOffset[pf];\n  int aoffset = tjAlphaOffset[pf];\n  int ps = tjPixelSize[pf];\n  int i, j;\n\n  for (j = 0; j < height; j++) {\n    int row = bottomUp ? height - j - 1 : j;\n\n    for (i = 0; i < width; i++) {\n      int r = (i * (maxSample + 1) / width) % (maxSample + 1);\n      int g = (j * (maxSample + 1) / height) % (maxSample + 1);\n      int b = (j * (maxSample + 1) / height +\n               i * (maxSample + 1) / width) % (maxSample + 1);\n\n      if (pf == TJPF_GRAY) {\n        if (getVal(buf, row * pitch + i * ps) != b)\n          return 0;\n      } else if (pf == TJPF_CMYK) {\n        int rf, gf, bf;\n\n        cmyk_to_rgb(getVal(buf, row * pitch + i * ps + 0),\n                    getVal(buf, row * pitch + i * ps + 1),\n                    getVal(buf, row * pitch + i * ps + 2),\n                    getVal(buf, row * pitch + i * ps + 3), &rf, &gf, &bf);\n        if (gray2rgb) {\n          if (rf != b || gf != b || bf != b)\n            return 0;\n        } else if (rf != r || gf != g || bf != b) return 0;\n      } else {\n        if (gray2rgb) {\n          if (getVal(buf, row * pitch + i * ps + roffset) != b ||\n              getVal(buf, row * pitch + i * ps + goffset) != b ||\n              getVal(buf, row * pitch + i * ps + boffset) != b)\n            return 0;\n        } else if (getVal(buf, row * pitch + i * ps + roffset) != r ||\n                   getVal(buf, row * pitch + i * ps + goffset) != g ||\n                   getVal(buf, row * pitch + i * ps + boffset) != b)\n          return 0;\n        if (aoffset >= 0 &&\n            getVal(buf, row * pitch + i * ps + aoffset) != maxSample)\n          return 0;\n      }\n    }\n  }\n  return 1;\n}\n\n\nstatic int doBmpTest(const char *ext, int width, int align, int height, int pf,\n                     int bottomUp)\n{\n  tjhandle handle = NULL;\n  char filename[80], *md5sum, md5buf[65];\n  int ps = tjPixelSize[pf], pitch = PAD(width * ps, align), loadWidth = 0,\n    loadHeight = 0, retval = 0, pixelFormat = pf;\n  void *buf = NULL;\n  char *md5ref;\n\n  if ((handle = tj3Init(TJINIT_TRANSFORM)) == NULL)\n    THROW_TJ(NULL);\n  TRY_TJ(handle, tj3Set(handle, TJPARAM_BOTTOMUP, bottomUp));\n\n  if (pf == TJPF_GRAY) {\n    if (precision == 8)\n      md5ref = !strcasecmp(ext, \"ppm\") ? \"112c682e82ce5de1cca089e20d60000b\" :\n                                         \"51976530acf75f02beddf5d21149101d\";\n    else if (precision == 12)\n      md5ref = \"0d1895c7e6f2b2c9af6e821a655c239c\";\n    else\n      md5ref = \"64f3320b226ea37fb58080713b4df1b2\";\n  } else {\n    if (precision == 8)\n      md5ref = !strcasecmp(ext, \"ppm\") ? \"c0c9f772b464d1896326883a5c79c545\" :\n                                         \"6d659071b9bfcdee2def22cb58ddadca\";\n    else if (precision == 12)\n      md5ref = \"2ff5299287017502832c99718450c90a\";\n    else\n      md5ref = \"623f54661b928d170bd2324bc3620565\";\n  }\n\n  if ((buf = tj3Alloc(pitch * height * sampleSize)) == NULL)\n    THROW(\"Could not allocate memory\");\n  initBitmap(buf, width, pitch, height, pf, bottomUp);\n\n  SNPRINTF(filename, 80, \"test_bmp%d_%s_%d_%s_%d.%s\", precision, pixFormatStr[pf],\n           align, bottomUp ? \"bu\" : \"td\", getpid(), ext);\n  if (precision == 8) {\n    TRY_TJ(handle, tj3SaveImage8(handle, filename, (unsigned char *)buf, width,\n                                 pitch, height, pf));\n  } else if (precision == 12) {\n    TRY_TJ(handle, tj3SaveImage12(handle, filename, (short *)buf, width, pitch,\n                                  height, pf));\n  } else {\n    TRY_TJ(handle, tj3SaveImage16(handle, filename, (unsigned short *)buf,\n                                  width, pitch, height, pf));\n  }\n  md5sum = MD5File(filename, md5buf);\n  if (!md5sum) {\n    printf(\"\\n   Could not determine MD5 sum of %s\\n\", filename);\n    retval = -1;  goto bailout;\n  }\n  if (strcasecmp(md5sum, md5ref))\n    THROW_MD5(filename, md5sum, md5ref);\n\n  tj3Free(buf);  buf = NULL;\n  if (precision == 8) {\n    if ((buf = tj3LoadImage8(handle, filename, &loadWidth, align, &loadHeight,\n                             &pf)) == NULL)\n      THROW_TJ(handle);\n  } else if (precision == 12) {\n    if ((buf = tj3LoadImage12(handle, filename, &loadWidth, align, &loadHeight,\n                              &pf)) == NULL)\n      THROW_TJ(handle);\n  } else {\n    if ((buf = tj3LoadImage16(handle, filename, &loadWidth, align, &loadHeight,\n                              &pf)) == NULL)\n      THROW_TJ(handle);\n  }\n  if (width != loadWidth || height != loadHeight) {\n    printf(\"\\n   Image dimensions of %s are bogus\\n\", filename);\n    retval = -1;  goto bailout;\n  }\n  if (!cmpBitmap(buf, width, pitch, height, pf, bottomUp, 0)) {\n    printf(\"\\n   Pixel data in %s is bogus\\n\", filename);\n    retval = -1;  goto bailout;\n  }\n  if (pf == TJPF_GRAY) {\n    tj3Free(buf);  buf = NULL;\n    pf = TJPF_XBGR;\n    if (precision == 8) {\n      if ((buf = tj3LoadImage8(handle, filename, &loadWidth, align,\n                               &loadHeight, &pf)) == NULL)\n        THROW_TJ(handle);\n    } else if (precision == 12) {\n      if ((buf = tj3LoadImage12(handle, filename, &loadWidth, align,\n                                &loadHeight, &pf)) == NULL)\n        THROW_TJ(handle);\n    } else {\n      if ((buf = tj3LoadImage16(handle, filename, &loadWidth, align,\n                                &loadHeight, &pf)) == NULL)\n        THROW_TJ(handle);\n    }\n    pitch = PAD(width * tjPixelSize[pf], align);\n    if (!cmpBitmap(buf, width, pitch, height, pf, bottomUp, 1)) {\n      printf(\"\\n   Converting %s to RGB failed\\n\", filename);\n      retval = -1;  goto bailout;\n    }\n\n    tj3Free(buf);  buf = NULL;\n    pf = TJPF_CMYK;\n    if (precision == 8) {\n      if ((buf = tj3LoadImage8(handle, filename, &loadWidth, align,\n                               &loadHeight, &pf)) == NULL)\n        THROW_TJ(handle);\n    } else if (precision == 12) {\n      if ((buf = tj3LoadImage12(handle, filename, &loadWidth, align,\n                                &loadHeight, &pf)) == NULL)\n        THROW_TJ(handle);\n    } else {\n      if ((buf = tj3LoadImage16(handle, filename, &loadWidth, align,\n                                &loadHeight, &pf)) == NULL)\n        THROW_TJ(handle);\n    }\n    pitch = PAD(width * tjPixelSize[pf], align);\n    if (!cmpBitmap(buf, width, pitch, height, pf, bottomUp, 1)) {\n      printf(\"\\n   Converting %s to CMYK failed\\n\", filename);\n      retval = -1;  goto bailout;\n    }\n  }\n  /* Verify that tj3LoadImage*() returns the proper \"preferred\" pixel format\n     for the file type. */\n  tj3Free(buf);  buf = NULL;\n  pf = pixelFormat;\n  pixelFormat = TJPF_UNKNOWN;\n  if (precision == 8) {\n    if ((buf = tj3LoadImage8(handle, filename, &loadWidth, align, &loadHeight,\n                             &pixelFormat)) == NULL)\n      THROW_TJ(handle);\n  } else if (precision == 12) {\n    if ((buf = tj3LoadImage12(handle, filename, &loadWidth, align, &loadHeight,\n                              &pixelFormat)) == NULL)\n      THROW_TJ(handle);\n  } else {\n    if ((buf = tj3LoadImage16(handle, filename, &loadWidth, align, &loadHeight,\n                              &pixelFormat)) == NULL)\n      THROW_TJ(handle);\n  }\n  if ((pf == TJPF_GRAY && pixelFormat != TJPF_GRAY) ||\n      (pf != TJPF_GRAY && !strcasecmp(ext, \"bmp\") &&\n       pixelFormat != TJPF_BGR) ||\n      (pf != TJPF_GRAY && !strcasecmp(ext, \"ppm\") &&\n       pixelFormat != TJPF_RGB)) {\n    printf(\"\\n   tj3LoadImage8() returned unexpected pixel format: %s\\n\",\n           pixFormatStr[pixelFormat]);\n    retval = -1;\n  }\n  unlink(filename);\n\nbailout:\n  tj3Destroy(handle);\n  tj3Free(buf);\n  if (exitStatus < 0) return exitStatus;\n  return retval;\n}\n\n\nstatic int bmpTest(void)\n{\n  int align, width = 35, height = 39, format;\n\n  for (align = 1; align <= 8; align *= 2) {\n    for (format = 0; format < TJ_NUMPF; format++) {\n      if (precision == 8) {\n        printf(\"%s Top-Down BMP (row alignment = %d samples)  ...  \",\n               pixFormatStr[format], align);\n        if (doBmpTest(\"bmp\", width, align, height, format, 0) == -1)\n          return -1;\n        printf(\"OK.\\n\");\n      }\n\n      printf(\"%s Top-Down PPM (row alignment = %d samples)  ...  \",\n             pixFormatStr[format], align);\n      if (doBmpTest(\"ppm\", width, align, height, format, 1) == -1)\n        return -1;\n      printf(\"OK.\\n\");\n\n      if (precision == 8) {\n        printf(\"%s Bottom-Up BMP (row alignment = %d samples)  ...  \",\n               pixFormatStr[format], align);\n        if (doBmpTest(\"bmp\", width, align, height, format, 0) == -1)\n          return -1;\n        printf(\"OK.\\n\");\n      }\n\n      printf(\"%s Bottom-Up PPM (row alignment = %d samples)  ...  \",\n             pixFormatStr[format], align);\n      if (doBmpTest(\"ppm\", width, align, height, format, 1) == -1)\n        return -1;\n      printf(\"OK.\\n\");\n    }\n  }\n\n  return 0;\n}\n\n\nint main(int argc, char *argv[])\n{\n  int i, bmp = 0, num4bf = 5;\n\n#ifdef _WIN32\n  srand((unsigned int)time(NULL));\n#endif\n  if (argc > 1) {\n    for (i = 1; i < argc; i++) {\n      if (!strcasecmp(argv[i], \"-yuv\")) doYUV = 1;\n      else if (!strcasecmp(argv[i], \"-noyuvpad\")) yuvAlign = 1;\n      else if (!strcasecmp(argv[i], \"-lossless\")) lossless = 1;\n      else if (!strcasecmp(argv[i], \"-alloc\")) alloc = 1;\n      else if (!strcasecmp(argv[i], \"-bmp\")) bmp = 1;\n      else if (!strcasecmp(argv[i], \"-precision\") && i < argc - 1) {\n        int tempi = atoi(argv[++i]);\n\n        if (tempi != 8 && tempi != 12 && tempi != 16)\n          usage(argv[0]);\n        precision = tempi;\n        if (precision == 16) lossless = 1;\n      } else\n        usage(argv[0]);\n    }\n  }\n  if (lossless && doYUV)\n    THROW(\"Lossless JPEG and YUV encoding/decoding are incompatible.\");\n  if (precision != 8 && doYUV)\n    THROW(\"YUV encoding/decoding requires 8-bit data precision.\");\n\n  printf(\"Testing %d-bit precision\\n\", precision);\n  sampleSize = (precision == 8 ? sizeof(unsigned char) : sizeof(short));\n  maxSample = (1 << precision) - 1;\n  tolerance = (lossless ? 0 : (precision > 8 ? 2 : 1));\n  redToY = (19595U * maxSample) >> 16;\n  yellowToY = (58065U * maxSample) >> 16;\n\n  if (bmp) return bmpTest();\n  if (alloc) printf(\"Testing automatic buffer allocation\\n\");\n  if (doYUV) num4bf = 4;\n  overflowTest();\n  doTest(35, 39, _3sampleFormats, 2, TJSAMP_444, \"test\");\n  doTest(39, 41, _4sampleFormats, num4bf, TJSAMP_444, \"test\");\n  doTest(41, 35, _3sampleFormats, 2, TJSAMP_422, \"test\");\n  if (!lossless) {\n    doTest(35, 39, _4sampleFormats, num4bf, TJSAMP_422, \"test\");\n    doTest(39, 41, _3sampleFormats, 2, TJSAMP_420, \"test\");\n    doTest(41, 35, _4sampleFormats, num4bf, TJSAMP_420, \"test\");\n    doTest(35, 39, _3sampleFormats, 2, TJSAMP_440, \"test\");\n    doTest(39, 41, _4sampleFormats, num4bf, TJSAMP_440, \"test\");\n    doTest(41, 35, _3sampleFormats, 2, TJSAMP_411, \"test\");\n    doTest(35, 39, _4sampleFormats, num4bf, TJSAMP_411, \"test\");\n    doTest(39, 41, _3sampleFormats, 2, TJSAMP_441, \"test\");\n    doTest(41, 35, _4sampleFormats, num4bf, TJSAMP_441, \"test\");\n  }\n  doTest(39, 41, _onlyGray, 1, TJSAMP_GRAY, \"test\");\n  if (!lossless) {\n    doTest(41, 35, _3sampleFormats, 2, TJSAMP_GRAY, \"test\");\n    doTest(35, 39, _4sampleFormats, 4, TJSAMP_GRAY, \"test\");\n  }\n  bufSizeTest();\n  if (doYUV) {\n    printf(\"\\n--------------------\\n\\n\");\n    doTest(48, 48, _onlyRGB, 1, TJSAMP_444, \"test_yuv0\");\n    doTest(48, 48, _onlyRGB, 1, TJSAMP_422, \"test_yuv0\");\n    doTest(48, 48, _onlyRGB, 1, TJSAMP_420, \"test_yuv0\");\n    doTest(48, 48, _onlyRGB, 1, TJSAMP_440, \"test_yuv0\");\n    doTest(48, 48, _onlyRGB, 1, TJSAMP_411, \"test_yuv0\");\n    doTest(48, 48, _onlyRGB, 1, TJSAMP_441, \"test_yuv0\");\n    doTest(48, 48, _onlyRGB, 1, TJSAMP_GRAY, \"test_yuv0\");\n    doTest(48, 48, _onlyGray, 1, TJSAMP_GRAY, \"test_yuv0\");\n  }\n\n  bailout:\n  return exitStatus;\n}\n"
        },
        {
          "name": "tjutil.c",
          "type": "blob",
          "size": 2.2060546875,
          "content": "/*\n * Copyright (C)2011, 2019 D. R. Commander.  All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef _WIN32\n\n#include <windows.h>\n#include \"tjutil.h\"\n\nstatic double getFreq(void)\n{\n  LARGE_INTEGER freq;\n\n  if (!QueryPerformanceFrequency(&freq)) return 0.0;\n  return (double)freq.QuadPart;\n}\n\nstatic double f = -1.0;\n\ndouble getTime(void)\n{\n  LARGE_INTEGER t;\n\n  if (f < 0.0) f = getFreq();\n  if (f == 0.0) return (double)GetTickCount() / 1000.;\n  else {\n    QueryPerformanceCounter(&t);\n    return (double)t.QuadPart / f;\n  }\n}\n\n#else\n\n#include <stdlib.h>\n#include <sys/time.h>\n#include \"tjutil.h\"\n\ndouble getTime(void)\n{\n  struct timeval tv;\n\n  if (gettimeofday(&tv, NULL) < 0) return 0.0;\n  else return (double)tv.tv_sec + ((double)tv.tv_usec / 1000000.);\n}\n\n#endif\n"
        },
        {
          "name": "tjutil.h",
          "type": "blob",
          "size": 1.978515625,
          "content": "/*\n * Copyright (C)2011, 2022 D. R. Commander.  All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef _WIN32\n#ifndef strcasecmp\n#define strcasecmp  stricmp\n#endif\n#ifndef strncasecmp\n#define strncasecmp  strnicmp\n#endif\n#endif\n\n#ifdef _MSC_VER\n#define SNPRINTF(str, n, format, ...) \\\n  _snprintf_s(str, n, _TRUNCATE, format, ##__VA_ARGS__)\n#else\n#define SNPRINTF  snprintf\n#endif\n\n#ifndef min\n#define min(a, b)  ((a) < (b) ? (a) : (b))\n#endif\n\n#ifndef max\n#define max(a, b)  ((a) > (b) ? (a) : (b))\n#endif\n\nextern double getTime(void);\n"
        },
        {
          "name": "transupp.c",
          "type": "blob",
          "size": 91.5517578125,
          "content": "/*\n * transupp.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1997-2019, Thomas G. Lane, Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2010, 2017, 2021-2022, 2024, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains image transformation routines and other utility code\n * used by the jpegtran sample application.  These are NOT part of the core\n * JPEG library.  But we keep these routines separate from jpegtran.c to\n * ease the task of maintaining jpegtran-like programs that have other user\n * interfaces.\n */\n\n/* Although this file really shouldn't have access to the library internals,\n * it's helpful to let it call jround_up() and jcopy_block_row().\n */\n#define JPEG_INTERNALS\n\n#include \"jinclude.h\"\n#include \"jpeglib.h\"\n#include \"transupp.h\"           /* My own external interface */\n#include \"jpegapicomp.h\"\n#include <ctype.h>              /* to declare isdigit() */\n\n\n#if JPEG_LIB_VERSION >= 70\n#define dstinfo_min_DCT_h_scaled_size  dstinfo->min_DCT_h_scaled_size\n#define dstinfo_min_DCT_v_scaled_size  dstinfo->min_DCT_v_scaled_size\n#else\n#define dstinfo_min_DCT_h_scaled_size  DCTSIZE\n#define dstinfo_min_DCT_v_scaled_size  DCTSIZE\n#endif\n\n\n#if TRANSFORMS_SUPPORTED\n\n/*\n * Lossless image transformation routines.  These routines work on DCT\n * coefficient arrays and thus do not require any lossy decompression\n * or recompression of the image.\n * Thanks to Guido Vollbeding for the initial design and code of this feature,\n * and to Ben Jackson for introducing the cropping feature.\n *\n * Horizontal flipping is done in-place, using a single top-to-bottom\n * pass through the virtual source array.  It will thus be much the\n * fastest option for images larger than main memory.\n *\n * The other routines require a set of destination virtual arrays, so they\n * need twice as much memory as jpegtran normally does.  The destination\n * arrays are always written in normal scan order (top to bottom) because\n * the virtual array manager expects this.  The source arrays will be scanned\n * in the corresponding order, which means multiple passes through the source\n * arrays for most of the transforms.  That could result in much thrashing\n * if the image is larger than main memory.\n *\n * If cropping or trimming is involved, the destination arrays may be smaller\n * than the source arrays.  Note it is not possible to do horizontal flip\n * in-place when a nonzero Y crop offset is specified, since we'd have to move\n * data from one block row to another but the virtual array manager doesn't\n * guarantee we can touch more than one row at a time.  So in that case,\n * we have to use a separate destination array.\n *\n * Some notes about the operating environment of the individual transform\n * routines:\n * 1. Both the source and destination virtual arrays are allocated from the\n *    source JPEG object, and therefore should be manipulated by calling the\n *    source's memory manager.\n * 2. The destination's component count should be used.  It may be smaller\n *    than the source's when forcing to grayscale.\n * 3. Likewise the destination's sampling factors should be used.  When\n *    forcing to grayscale the destination's sampling factors will be all 1,\n *    and we may as well take that as the effective iMCU size.\n * 4. When \"trim\" is in effect, the destination's dimensions will be the\n *    trimmed values but the source's will be untrimmed.\n * 5. When \"crop\" is in effect, the destination's dimensions will be the\n *    cropped values but the source's will be uncropped.  Each transform\n *    routine is responsible for picking up source data starting at the\n *    correct X and Y offset for the crop region.  (The X and Y offsets\n *    passed to the transform routines are measured in iMCU blocks of the\n *    destination.)\n * 6. All the routines assume that the source and destination buffers are\n *    padded out to a full iMCU boundary.  This is true, although for the\n *    source buffer it is an undocumented property of jdcoefct.c.\n */\n\n\nLOCAL(void)\ndequant_comp(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n             jvirt_barray_ptr coef_array, JQUANT_TBL *qtblptr1)\n{\n  JDIMENSION blk_x, blk_y;\n  int offset_y, k;\n  JQUANT_TBL *qtblptr;\n  JBLOCKARRAY buffer;\n  JBLOCKROW block;\n  JCOEFPTR ptr;\n\n  qtblptr = compptr->quant_table;\n  for (blk_y = 0; blk_y < compptr->height_in_blocks;\n       blk_y += compptr->v_samp_factor) {\n    buffer = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr)cinfo, coef_array, blk_y,\n       (JDIMENSION)compptr->v_samp_factor, TRUE);\n    for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n      block = buffer[offset_y];\n      for (blk_x = 0; blk_x < compptr->width_in_blocks; blk_x++) {\n        ptr = block[blk_x];\n        for (k = 0; k < DCTSIZE2; k++)\n          if (qtblptr->quantval[k] != qtblptr1->quantval[k])\n            ptr[k] *= qtblptr->quantval[k] / qtblptr1->quantval[k];\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\nrequant_comp(j_decompress_ptr cinfo, jpeg_component_info *compptr,\n             jvirt_barray_ptr coef_array, JQUANT_TBL *qtblptr1)\n{\n  JDIMENSION blk_x, blk_y;\n  int offset_y, k;\n  JQUANT_TBL *qtblptr;\n  JBLOCKARRAY buffer;\n  JBLOCKROW block;\n  JCOEFPTR ptr;\n  JCOEF temp, qval;\n\n  qtblptr = compptr->quant_table;\n  for (blk_y = 0; blk_y < compptr->height_in_blocks;\n       blk_y += compptr->v_samp_factor) {\n    buffer = (*cinfo->mem->access_virt_barray)\n      ((j_common_ptr)cinfo, coef_array, blk_y,\n       (JDIMENSION)compptr->v_samp_factor, TRUE);\n    for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n      block = buffer[offset_y];\n      for (blk_x = 0; blk_x < compptr->width_in_blocks; blk_x++) {\n        ptr = block[blk_x];\n        for (k = 0; k < DCTSIZE2; k++) {\n          temp = qtblptr->quantval[k];\n          qval = qtblptr1->quantval[k];\n          if (temp != qval && qval != 0) {\n            temp *= ptr[k];\n            /* The following quantization code is copied from jcdctmgr.c */\n#ifdef FAST_DIVIDE\n#define DIVIDE_BY(a, b)  a /= b\n#else\n#define DIVIDE_BY(a, b)  if (a >= b) a /= b;  else a = 0\n#endif\n            if (temp < 0) {\n              temp = -temp;\n              temp += qval >> 1; /* for rounding */\n              DIVIDE_BY(temp, qval);\n              temp = -temp;\n            } else {\n              temp += qval >> 1; /* for rounding */\n              DIVIDE_BY(temp, qval);\n            }\n            ptr[k] = temp;\n          }\n        }\n      }\n    }\n  }\n}\n\n\n/*\n * Calculate largest common denominator using Euclid's algorithm.\n */\nLOCAL(JCOEF)\nlargest_common_denominator(JCOEF a, JCOEF b)\n{\n  JCOEF c;\n\n  do {\n    c = a % b;\n    a = b;\n    b = c;\n  } while (c);\n\n  return a;\n}\n\n\nLOCAL(void)\nadjust_quant(j_decompress_ptr srcinfo, jvirt_barray_ptr *src_coef_arrays,\n             j_decompress_ptr dropinfo, jvirt_barray_ptr *drop_coef_arrays,\n             boolean trim, j_compress_ptr dstinfo)\n{\n  jpeg_component_info *compptr1, *compptr2;\n  JQUANT_TBL *qtblptr1, *qtblptr2, *qtblptr3;\n  int ci, k;\n\n  for (ci = 0; ci < dstinfo->num_components && ci < dropinfo->num_components;\n       ci++) {\n    compptr1 = srcinfo->comp_info + ci;\n    compptr2 = dropinfo->comp_info + ci;\n    qtblptr1 = compptr1->quant_table;\n    if (qtblptr1 == NULL)\n      ERREXIT1(srcinfo, JERR_NO_QUANT_TABLE, compptr1->quant_tbl_no);\n    qtblptr2 = compptr2->quant_table;\n    if (qtblptr2 == NULL)\n      ERREXIT1(dropinfo, JERR_NO_QUANT_TABLE, compptr2->quant_tbl_no);\n    for (k = 0; k < DCTSIZE2; k++) {\n      if (qtblptr1->quantval[k] != qtblptr2->quantval[k]) {\n        if (trim)\n          requant_comp(dropinfo, compptr2, drop_coef_arrays[ci], qtblptr1);\n        else {\n          qtblptr3 = dstinfo->quant_tbl_ptrs[compptr1->quant_tbl_no];\n          for (k = 0; k < DCTSIZE2; k++)\n            if (qtblptr1->quantval[k] != qtblptr2->quantval[k])\n              qtblptr3->quantval[k] =\n                largest_common_denominator(qtblptr1->quantval[k],\n                                           qtblptr2->quantval[k]);\n          dequant_comp(srcinfo, compptr1, src_coef_arrays[ci], qtblptr3);\n          dequant_comp(dropinfo, compptr2, drop_coef_arrays[ci], qtblptr3);\n        }\n        break;\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_drop(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n        JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n        jvirt_barray_ptr *src_coef_arrays,\n        j_decompress_ptr dropinfo, jvirt_barray_ptr *drop_coef_arrays,\n        JDIMENSION drop_width, JDIMENSION drop_height)\n/* Drop (insert) the contents of another image into the source image.  If the\n * number of components in the drop image is smaller than the number of\n * components in the destination image, then we fill in the remaining\n * components with zero.  This allows for dropping the contents of grayscale\n * images into (arbitrarily sampled) color images.\n */\n{\n  JDIMENSION comp_width, comp_height;\n  JDIMENSION blk_y, x_drop_blocks, y_drop_blocks;\n  int ci, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  jpeg_component_info *compptr;\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_width = drop_width * compptr->h_samp_factor;\n    comp_height = drop_height * compptr->v_samp_factor;\n    x_drop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_drop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (blk_y = 0; blk_y < comp_height; blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, src_coef_arrays[ci], blk_y + y_drop_blocks,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      if (ci < dropinfo->num_components) {\n        src_buffer = (*dropinfo->mem->access_virt_barray)\n          ((j_common_ptr)dropinfo, drop_coef_arrays[ci], blk_y,\n           (JDIMENSION)compptr->v_samp_factor, FALSE);\n        for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n          jcopy_block_row(src_buffer[offset_y],\n                          dst_buffer[offset_y] + x_drop_blocks, comp_width);\n        }\n      } else {\n        for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n          memset(dst_buffer[offset_y] + x_drop_blocks, 0,\n                 comp_width * sizeof(JBLOCK));\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_crop(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n        JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n        jvirt_barray_ptr *src_coef_arrays,\n        jvirt_barray_ptr *dst_coef_arrays)\n/* Crop.  This is only used when no rotate/flip is requested with the crop. */\n{\n  JDIMENSION dst_blk_y, x_crop_blocks, y_crop_blocks;\n  int ci, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  jpeg_component_info *compptr;\n\n  /* We simply have to copy the right amount of data (the destination's\n   * image size) starting at the given X and Y offsets in the source.\n   */\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      src_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, src_coef_arrays[ci], dst_blk_y + y_crop_blocks,\n         (JDIMENSION)compptr->v_samp_factor, FALSE);\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,\n                        dst_buffer[offset_y], compptr->width_in_blocks);\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_crop_ext_zero(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n                 JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n                 jvirt_barray_ptr *src_coef_arrays,\n                 jvirt_barray_ptr *dst_coef_arrays)\n/* Crop.  This is only used when no rotate/flip is requested with the crop.\n * Extension: If the destination size is larger than the source, we fill in the\n * expanded region with zero (neutral gray).  Note that we also have to zero\n * partial iMCUs at the right and bottom edge of the source image area in this\n * case.\n */\n{\n  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height;\n  JDIMENSION dst_blk_y, x_crop_blocks, y_crop_blocks;\n  int ci, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  jpeg_component_info *compptr;\n\n  MCU_cols = srcinfo->output_width /\n             (dstinfo->max_h_samp_factor * dstinfo_min_DCT_h_scaled_size);\n  MCU_rows = srcinfo->output_height /\n             (dstinfo->max_v_samp_factor * dstinfo_min_DCT_v_scaled_size);\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_width = MCU_cols * compptr->h_samp_factor;\n    comp_height = MCU_rows * compptr->v_samp_factor;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      if (dstinfo->_jpeg_height > srcinfo->output_height) {\n        if (dst_blk_y < y_crop_blocks ||\n            dst_blk_y >= y_crop_blocks + comp_height) {\n          for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n            memset(dst_buffer[offset_y], 0,\n                   compptr->width_in_blocks * sizeof(JBLOCK));\n          }\n          continue;\n        }\n        src_buffer = (*srcinfo->mem->access_virt_barray)\n          ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n           dst_blk_y - y_crop_blocks, (JDIMENSION)compptr->v_samp_factor,\n           FALSE);\n      } else {\n        src_buffer = (*srcinfo->mem->access_virt_barray)\n          ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n           dst_blk_y + y_crop_blocks, (JDIMENSION)compptr->v_samp_factor,\n           FALSE);\n      }\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        if (dstinfo->_jpeg_width > srcinfo->output_width) {\n          if (x_crop_blocks > 0) {\n            memset(dst_buffer[offset_y], 0, x_crop_blocks * sizeof(JBLOCK));\n          }\n          jcopy_block_row(src_buffer[offset_y],\n                          dst_buffer[offset_y] + x_crop_blocks, comp_width);\n          if (compptr->width_in_blocks > x_crop_blocks + comp_width) {\n            memset(dst_buffer[offset_y] + x_crop_blocks + comp_width, 0,\n                   (compptr->width_in_blocks - x_crop_blocks - comp_width) *\n                   sizeof(JBLOCK));\n          }\n        } else {\n          jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,\n                          dst_buffer[offset_y], compptr->width_in_blocks);\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_crop_ext_flat(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n                 JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n                 jvirt_barray_ptr *src_coef_arrays,\n                 jvirt_barray_ptr *dst_coef_arrays)\n/* Crop.  This is only used when no rotate/flip is requested with the crop.\n * Extension: The destination width is larger than the source, and we fill in\n * the expanded region with the DC coefficient of the adjacent block.  Note\n * that we also have to fill partial iMCUs at the right and bottom edge of the\n * source image area in this case.\n */\n{\n  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height;\n  JDIMENSION dst_blk_x, dst_blk_y, x_crop_blocks, y_crop_blocks;\n  int ci, offset_y;\n  JCOEF dc;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  jpeg_component_info *compptr;\n\n  MCU_cols = srcinfo->output_width /\n             (dstinfo->max_h_samp_factor * dstinfo_min_DCT_h_scaled_size);\n  MCU_rows = srcinfo->output_height /\n             (dstinfo->max_v_samp_factor * dstinfo_min_DCT_v_scaled_size);\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_width = MCU_cols * compptr->h_samp_factor;\n    comp_height = MCU_rows * compptr->v_samp_factor;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      if (dstinfo->_jpeg_height > srcinfo->output_height) {\n        if (dst_blk_y < y_crop_blocks ||\n            dst_blk_y >= y_crop_blocks + comp_height) {\n          for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n            memset(dst_buffer[offset_y], 0,\n                   compptr->width_in_blocks * sizeof(JBLOCK));\n          }\n          continue;\n        }\n        src_buffer = (*srcinfo->mem->access_virt_barray)\n          ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n           dst_blk_y - y_crop_blocks, (JDIMENSION)compptr->v_samp_factor,\n           FALSE);\n      } else {\n        src_buffer = (*srcinfo->mem->access_virt_barray)\n          ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n           dst_blk_y + y_crop_blocks, (JDIMENSION)compptr->v_samp_factor,\n          FALSE);\n      }\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        if (x_crop_blocks > 0) {\n          memset(dst_buffer[offset_y], 0, x_crop_blocks * sizeof(JBLOCK));\n          dc = src_buffer[offset_y][0][0];\n          for (dst_blk_x = 0; dst_blk_x < x_crop_blocks; dst_blk_x++) {\n            dst_buffer[offset_y][dst_blk_x][0] = dc;\n          }\n        }\n        jcopy_block_row(src_buffer[offset_y],\n                        dst_buffer[offset_y] + x_crop_blocks, comp_width);\n        if (compptr->width_in_blocks > x_crop_blocks + comp_width) {\n          memset(dst_buffer[offset_y] + x_crop_blocks + comp_width, 0,\n                 (compptr->width_in_blocks - x_crop_blocks - comp_width) *\n                 sizeof(JBLOCK));\n          dc = src_buffer[offset_y][comp_width - 1][0];\n          for (dst_blk_x = x_crop_blocks + comp_width;\n               dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {\n            dst_buffer[offset_y][dst_blk_x][0] = dc;\n          }\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_crop_ext_reflect(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n                    JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n                    jvirt_barray_ptr *src_coef_arrays,\n                    jvirt_barray_ptr *dst_coef_arrays)\n/* Crop.  This is only used when no rotate/flip is requested with the crop.\n * Extension: The destination width is larger than the source, and we fill in\n * the expanded region with repeated reflections of the source image.  Note\n * that we also have to fill partial iMCUs at the right and bottom edge of the\n * source image area in this case.\n */\n{\n  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, src_blk_x;\n  JDIMENSION dst_blk_x, dst_blk_y, x_crop_blocks, y_crop_blocks;\n  int ci, k, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  JBLOCKROW src_row_ptr, dst_row_ptr;\n  JCOEFPTR src_ptr, dst_ptr;\n  jpeg_component_info *compptr;\n\n  MCU_cols = srcinfo->output_width /\n             (dstinfo->max_h_samp_factor * dstinfo_min_DCT_h_scaled_size);\n  MCU_rows = srcinfo->output_height /\n             (dstinfo->max_v_samp_factor * dstinfo_min_DCT_v_scaled_size);\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_width = MCU_cols * compptr->h_samp_factor;\n    comp_height = MCU_rows * compptr->v_samp_factor;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      if (dstinfo->_jpeg_height > srcinfo->output_height) {\n        if (dst_blk_y < y_crop_blocks ||\n            dst_blk_y >= y_crop_blocks + comp_height) {\n          for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n            memset(dst_buffer[offset_y], 0,\n                   compptr->width_in_blocks * sizeof(JBLOCK));\n          }\n          continue;\n        }\n        src_buffer = (*srcinfo->mem->access_virt_barray)\n          ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n           dst_blk_y - y_crop_blocks, (JDIMENSION)compptr->v_samp_factor,\n           FALSE);\n      } else {\n        src_buffer = (*srcinfo->mem->access_virt_barray)\n          ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n           dst_blk_y + y_crop_blocks, (JDIMENSION)compptr->v_samp_factor,\n           FALSE);\n      }\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        /* Copy source region */\n        jcopy_block_row(src_buffer[offset_y],\n                        dst_buffer[offset_y] + x_crop_blocks, comp_width);\n        if (x_crop_blocks > 0) {\n          /* Reflect to left */\n          dst_row_ptr = dst_buffer[offset_y] + x_crop_blocks;\n          for (dst_blk_x = x_crop_blocks; dst_blk_x > 0;) {\n            src_row_ptr = dst_row_ptr;      /* (re)set axis of reflection */\n            for (src_blk_x = comp_width; src_blk_x > 0 && dst_blk_x > 0;\n                 src_blk_x--, dst_blk_x--) {\n              dst_ptr = *(--dst_row_ptr);   /* destination goes left */\n              src_ptr = *src_row_ptr++;     /* source goes right */\n              /* This unrolled loop doesn't need to know which row it's on. */\n              for (k = 0; k < DCTSIZE2; k += 2) {\n                *dst_ptr++ = *src_ptr++;    /* copy even column */\n                *dst_ptr++ = -(*src_ptr++); /* copy odd column with sign\n                                               change */\n              }\n            }\n          }\n        }\n        if (compptr->width_in_blocks > x_crop_blocks + comp_width) {\n          /* Reflect to right */\n          dst_row_ptr = dst_buffer[offset_y] + x_crop_blocks + comp_width;\n          for (dst_blk_x = compptr->width_in_blocks - x_crop_blocks - comp_width;\n               dst_blk_x > 0;) {\n            src_row_ptr = dst_row_ptr;      /* (re)set axis of reflection */\n            for (src_blk_x = comp_width; src_blk_x > 0 && dst_blk_x > 0;\n                 src_blk_x--, dst_blk_x--) {\n              dst_ptr = *dst_row_ptr++;     /* destination goes right */\n              src_ptr = *(--src_row_ptr);   /* source goes left */\n              /* This unrolled loop doesn't need to know which row it's on. */\n              for (k = 0; k < DCTSIZE2; k += 2) {\n                *dst_ptr++ = *src_ptr++;    /* copy even column */\n                *dst_ptr++ = -(*src_ptr++); /* copy odd column with sign\n                                               change */\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_wipe(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n        JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n        jvirt_barray_ptr *src_coef_arrays,\n        JDIMENSION drop_width, JDIMENSION drop_height)\n/* Wipe - discard image contents of specified region and fill with zero\n * (neutral gray)\n */\n{\n  JDIMENSION x_wipe_blocks, wipe_width;\n  JDIMENSION y_wipe_blocks, wipe_bottom;\n  int ci, offset_y;\n  JBLOCKARRAY buffer;\n  jpeg_component_info *compptr;\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    x_wipe_blocks = x_crop_offset * compptr->h_samp_factor;\n    wipe_width = drop_width * compptr->h_samp_factor;\n    y_wipe_blocks = y_crop_offset * compptr->v_samp_factor;\n    wipe_bottom = drop_height * compptr->v_samp_factor + y_wipe_blocks;\n    for (; y_wipe_blocks < wipe_bottom;\n         y_wipe_blocks += compptr->v_samp_factor) {\n      buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, src_coef_arrays[ci], y_wipe_blocks,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        memset(buffer[offset_y] + x_wipe_blocks, 0,\n               wipe_width * sizeof(JBLOCK));\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_flatten(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n           JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n           jvirt_barray_ptr *src_coef_arrays,\n           JDIMENSION drop_width, JDIMENSION drop_height)\n/* Flatten - discard image contents of specified region, similarly to wipe,\n * but fill with the average of adjacent blocks instead of zero.\n */\n{\n  JDIMENSION x_wipe_blocks, wipe_width, wipe_right;\n  JDIMENSION y_wipe_blocks, wipe_bottom, blk_x;\n  int ci, offset_y, dc_left_value, dc_right_value, average;\n  JBLOCKARRAY buffer;\n  jpeg_component_info *compptr;\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    x_wipe_blocks = x_crop_offset * compptr->h_samp_factor;\n    wipe_width = drop_width * compptr->h_samp_factor;\n    wipe_right = wipe_width + x_wipe_blocks;\n    y_wipe_blocks = y_crop_offset * compptr->v_samp_factor;\n    wipe_bottom = drop_height * compptr->v_samp_factor + y_wipe_blocks;\n    for (; y_wipe_blocks < wipe_bottom;\n         y_wipe_blocks += compptr->v_samp_factor) {\n      buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, src_coef_arrays[ci], y_wipe_blocks,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        memset(buffer[offset_y] + x_wipe_blocks, 0,\n               wipe_width * sizeof(JBLOCK));\n        if (x_wipe_blocks > 0) {\n          dc_left_value = buffer[offset_y][x_wipe_blocks - 1][0];\n          if (wipe_right < compptr->width_in_blocks) {\n            dc_right_value = buffer[offset_y][wipe_right][0];\n            average = (dc_left_value + dc_right_value) >> 1;\n          } else {\n            average = dc_left_value;\n          }\n        } else if (wipe_right < compptr->width_in_blocks) {\n          average = buffer[offset_y][wipe_right][0];\n        } else continue;\n        for (blk_x = x_wipe_blocks; blk_x < wipe_right; blk_x++) {\n          buffer[offset_y][blk_x][0] = (JCOEF)average;\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_reflect(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n           JDIMENSION x_crop_offset, jvirt_barray_ptr *src_coef_arrays,\n           JDIMENSION drop_width, JDIMENSION drop_height)\n/* Reflect - discard image contents of specified region, similarly to wipe,\n * but fill with repeated reflections of the outside region instead of zero.\n * NB: y_crop_offset is assumed to be zero.\n */\n{\n  JDIMENSION x_wipe_blocks, wipe_width;\n  JDIMENSION y_wipe_blocks, wipe_bottom;\n  JDIMENSION src_blk_x, dst_blk_x;\n  int ci, k, offset_y;\n  JBLOCKARRAY buffer;\n  JBLOCKROW src_row_ptr, dst_row_ptr;\n  JCOEFPTR src_ptr, dst_ptr;\n  jpeg_component_info *compptr;\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    x_wipe_blocks = x_crop_offset * compptr->h_samp_factor;\n    wipe_width = drop_width * compptr->h_samp_factor;\n    wipe_bottom = drop_height * compptr->v_samp_factor;\n    for (y_wipe_blocks = 0; y_wipe_blocks < wipe_bottom;\n         y_wipe_blocks += compptr->v_samp_factor) {\n      buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, src_coef_arrays[ci], y_wipe_blocks,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        if (x_wipe_blocks > 0) {\n          /* Reflect from left */\n          dst_row_ptr = buffer[offset_y] + x_wipe_blocks;\n          for (dst_blk_x = wipe_width; dst_blk_x > 0;) {\n            src_row_ptr = dst_row_ptr;     /* (re)set axis of reflection */\n            for (src_blk_x = x_wipe_blocks;\n                 src_blk_x > 0 && dst_blk_x > 0; src_blk_x--, dst_blk_x--) {\n              dst_ptr = *dst_row_ptr++;    /* destination goes right */\n              src_ptr = *(--src_row_ptr);  /* source goes left */\n              /* this unrolled loop doesn't need to know which row it's on... */\n              for (k = 0; k < DCTSIZE2; k += 2) {\n                *dst_ptr++ = *src_ptr++;   /* copy even column */\n                *dst_ptr++ = -(*src_ptr++); /* copy odd column with sign change */\n              }\n            }\n          }\n        } else if (compptr->width_in_blocks > x_wipe_blocks + wipe_width) {\n          /* Reflect from right */\n          dst_row_ptr = buffer[offset_y] + x_wipe_blocks + wipe_width;\n          for (dst_blk_x = wipe_width; dst_blk_x > 0;) {\n            src_row_ptr = dst_row_ptr;     /* (re)set axis of reflection */\n            src_blk_x = compptr->width_in_blocks - x_wipe_blocks - wipe_width;\n            for (; src_blk_x > 0 && dst_blk_x > 0; src_blk_x--, dst_blk_x--) {\n              dst_ptr = *(--dst_row_ptr);  /* destination goes left */\n              src_ptr = *src_row_ptr++;    /* source goes right */\n              /* this unrolled loop doesn't need to know which row it's on... */\n              for (k = 0; k < DCTSIZE2; k += 2) {\n                *dst_ptr++ = *src_ptr++;   /* copy even column */\n                *dst_ptr++ = -(*src_ptr++); /* copy odd column with sign change */\n              }\n            }\n          }\n        } else {\n          memset(buffer[offset_y] + x_wipe_blocks, 0,\n                 wipe_width * sizeof(JBLOCK));\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_flip_h_no_crop(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n                  JDIMENSION x_crop_offset, jvirt_barray_ptr *src_coef_arrays)\n/* Horizontal flip; done in-place, so no separate dest array is required.\n * NB: this only works when y_crop_offset is zero.\n */\n{\n  JDIMENSION MCU_cols, comp_width, blk_x, blk_y, x_crop_blocks;\n  int ci, k, offset_y;\n  JBLOCKARRAY buffer;\n  JCOEFPTR ptr1, ptr2;\n  JCOEF temp1, temp2;\n  jpeg_component_info *compptr;\n\n  /* Horizontal mirroring of DCT blocks is accomplished by swapping\n   * pairs of blocks in-place.  Within a DCT block, we perform horizontal\n   * mirroring by changing the signs of odd-numbered columns.\n   * Partial iMCUs at the right edge are left untouched.\n   */\n  MCU_cols = srcinfo->output_width /\n             (dstinfo->max_h_samp_factor * dstinfo_min_DCT_h_scaled_size);\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_width = MCU_cols * compptr->h_samp_factor;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    for (blk_y = 0; blk_y < compptr->height_in_blocks;\n         blk_y += compptr->v_samp_factor) {\n      buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, src_coef_arrays[ci], blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        /* Do the mirroring */\n        for (blk_x = 0; blk_x * 2 < comp_width; blk_x++) {\n          ptr1 = buffer[offset_y][blk_x];\n          ptr2 = buffer[offset_y][comp_width - blk_x - 1];\n          /* this unrolled loop doesn't need to know which row it's on... */\n          for (k = 0; k < DCTSIZE2; k += 2) {\n            temp1 = *ptr1;      /* swap even column */\n            temp2 = *ptr2;\n            *ptr1++ = temp2;\n            *ptr2++ = temp1;\n            temp1 = *ptr1;      /* swap odd column with sign change */\n            temp2 = *ptr2;\n            *ptr1++ = -temp2;\n            *ptr2++ = -temp1;\n          }\n        }\n        if (x_crop_blocks > 0) {\n          /* Now left-justify the portion of the data to be kept.\n           * We can't use a single jcopy_block_row() call because that routine\n           * depends on memcpy(), whose behavior is unspecified for overlapping\n           * source and destination areas.  Sigh.\n           */\n          for (blk_x = 0; blk_x < compptr->width_in_blocks; blk_x++) {\n            jcopy_block_row(buffer[offset_y] + blk_x + x_crop_blocks,\n                            buffer[offset_y] + blk_x, (JDIMENSION)1);\n          }\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_flip_h(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n          JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n          jvirt_barray_ptr *src_coef_arrays,\n          jvirt_barray_ptr *dst_coef_arrays)\n/* Horizontal flip in general cropping case */\n{\n  JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;\n  JDIMENSION x_crop_blocks, y_crop_blocks;\n  int ci, k, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  JBLOCKROW src_row_ptr, dst_row_ptr;\n  JCOEFPTR src_ptr, dst_ptr;\n  jpeg_component_info *compptr;\n\n  /* Here we must output into a separate array because we can't touch\n   * different rows of a single virtual array simultaneously.  Otherwise,\n   * this is essentially the same as the routine above.\n   */\n  MCU_cols = srcinfo->output_width /\n             (dstinfo->max_h_samp_factor * dstinfo_min_DCT_h_scaled_size);\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_width = MCU_cols * compptr->h_samp_factor;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      src_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, src_coef_arrays[ci], dst_blk_y + y_crop_blocks,\n         (JDIMENSION)compptr->v_samp_factor, FALSE);\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        dst_row_ptr = dst_buffer[offset_y];\n        src_row_ptr = src_buffer[offset_y];\n        for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;\n             dst_blk_x++) {\n          if (x_crop_blocks + dst_blk_x < comp_width) {\n            /* Do the mirrorable blocks */\n            dst_ptr = dst_row_ptr[dst_blk_x];\n            src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];\n            /* this unrolled loop doesn't need to know which row it's on... */\n            for (k = 0; k < DCTSIZE2; k += 2) {\n              *dst_ptr++ = *src_ptr++;    /* copy even column */\n              *dst_ptr++ = -(*src_ptr++); /* copy odd column with sign\n                                             change */\n            }\n          } else {\n            /* Copy last partial block(s) verbatim */\n            jcopy_block_row(src_row_ptr + dst_blk_x + x_crop_blocks,\n                            dst_row_ptr + dst_blk_x, (JDIMENSION)1);\n          }\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_flip_v(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n          JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n          jvirt_barray_ptr *src_coef_arrays,\n          jvirt_barray_ptr *dst_coef_arrays)\n/* Vertical flip */\n{\n  JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;\n  JDIMENSION x_crop_blocks, y_crop_blocks;\n  int ci, i, j, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  JBLOCKROW src_row_ptr, dst_row_ptr;\n  JCOEFPTR src_ptr, dst_ptr;\n  jpeg_component_info *compptr;\n\n  /* We output into a separate array because we can't touch different\n   * rows of the source virtual array simultaneously.  Otherwise, this\n   * is a pretty straightforward analog of horizontal flip.\n   * Within a DCT block, vertical mirroring is done by changing the signs\n   * of odd-numbered rows.\n   * Partial iMCUs at the bottom edge are copied verbatim.\n   */\n  MCU_rows = srcinfo->output_height /\n             (dstinfo->max_v_samp_factor * dstinfo_min_DCT_v_scaled_size);\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_height = MCU_rows * compptr->v_samp_factor;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      if (y_crop_blocks + dst_blk_y < comp_height) {\n        /* Row is within the mirrorable area. */\n        src_buffer = (*srcinfo->mem->access_virt_barray)\n          ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n           comp_height - y_crop_blocks - dst_blk_y -\n           (JDIMENSION)compptr->v_samp_factor,\n           (JDIMENSION)compptr->v_samp_factor, FALSE);\n      } else {\n        /* Bottom-edge blocks will be copied verbatim. */\n        src_buffer = (*srcinfo->mem->access_virt_barray)\n          ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n           dst_blk_y + y_crop_blocks,\n           (JDIMENSION)compptr->v_samp_factor, FALSE);\n      }\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        if (y_crop_blocks + dst_blk_y < comp_height) {\n          /* Row is within the mirrorable area. */\n          dst_row_ptr = dst_buffer[offset_y];\n          src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];\n          src_row_ptr += x_crop_blocks;\n          for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;\n               dst_blk_x++) {\n            dst_ptr = dst_row_ptr[dst_blk_x];\n            src_ptr = src_row_ptr[dst_blk_x];\n            for (i = 0; i < DCTSIZE; i += 2) {\n              /* copy even row */\n              for (j = 0; j < DCTSIZE; j++)\n                *dst_ptr++ = *src_ptr++;\n              /* copy odd row with sign change */\n              for (j = 0; j < DCTSIZE; j++)\n                *dst_ptr++ = -(*src_ptr++);\n            }\n          }\n        } else {\n          /* Just copy row verbatim. */\n          jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,\n                          dst_buffer[offset_y], compptr->width_in_blocks);\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_transpose(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n             JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n             jvirt_barray_ptr *src_coef_arrays,\n             jvirt_barray_ptr *dst_coef_arrays)\n/* Transpose source into destination */\n{\n  JDIMENSION dst_blk_x, dst_blk_y, x_crop_blocks, y_crop_blocks;\n  int ci, i, j, offset_x, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  JCOEFPTR src_ptr, dst_ptr;\n  jpeg_component_info *compptr;\n\n  /* Transposing pixels within a block just requires transposing the\n   * DCT coefficients.\n   * Partial iMCUs at the edges require no special treatment; we simply\n   * process all the available DCT blocks for every component.\n   */\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;\n             dst_blk_x += compptr->h_samp_factor) {\n          src_buffer = (*srcinfo->mem->access_virt_barray)\n            ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n             dst_blk_x + x_crop_blocks,\n             (JDIMENSION)compptr->h_samp_factor, FALSE);\n          for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {\n            dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];\n            src_ptr =\n              src_buffer[offset_x][dst_blk_y + offset_y + y_crop_blocks];\n            for (i = 0; i < DCTSIZE; i++)\n              for (j = 0; j < DCTSIZE; j++)\n                dst_ptr[j * DCTSIZE + i] = src_ptr[i * DCTSIZE + j];\n          }\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_rot_90(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n          JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n          jvirt_barray_ptr *src_coef_arrays,\n          jvirt_barray_ptr *dst_coef_arrays)\n/* 90 degree rotation is equivalent to\n *   1. Transposing the image;\n *   2. Horizontal mirroring.\n * These two steps are merged into a single processing routine.\n */\n{\n  JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;\n  JDIMENSION x_crop_blocks, y_crop_blocks;\n  int ci, i, j, offset_x, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  JCOEFPTR src_ptr, dst_ptr;\n  jpeg_component_info *compptr;\n\n  /* Because of the horizontal mirror step, we can't process partial iMCUs\n   * at the (output) right edge properly.  They just get transposed and\n   * not mirrored.\n   */\n  MCU_cols = srcinfo->output_height /\n             (dstinfo->max_h_samp_factor * dstinfo_min_DCT_h_scaled_size);\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_width = MCU_cols * compptr->h_samp_factor;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;\n             dst_blk_x += compptr->h_samp_factor) {\n          if (x_crop_blocks + dst_blk_x < comp_width) {\n            /* Block is within the mirrorable area. */\n            src_buffer = (*srcinfo->mem->access_virt_barray)\n              ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n               comp_width - x_crop_blocks - dst_blk_x -\n               (JDIMENSION)compptr->h_samp_factor,\n               (JDIMENSION)compptr->h_samp_factor, FALSE);\n          } else {\n            /* Edge blocks are transposed but not mirrored. */\n            src_buffer = (*srcinfo->mem->access_virt_barray)\n              ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n               dst_blk_x + x_crop_blocks,\n               (JDIMENSION)compptr->h_samp_factor, FALSE);\n          }\n          for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {\n            dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];\n            if (x_crop_blocks + dst_blk_x < comp_width) {\n              /* Block is within the mirrorable area. */\n              src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]\n                [dst_blk_y + offset_y + y_crop_blocks];\n              for (i = 0; i < DCTSIZE; i++) {\n                for (j = 0; j < DCTSIZE; j++)\n                  dst_ptr[j * DCTSIZE + i] = src_ptr[i * DCTSIZE + j];\n                i++;\n                for (j = 0; j < DCTSIZE; j++)\n                  dst_ptr[j * DCTSIZE + i] = -src_ptr[i * DCTSIZE + j];\n              }\n            } else {\n              /* Edge blocks are transposed but not mirrored. */\n              src_ptr = src_buffer[offset_x]\n                [dst_blk_y + offset_y + y_crop_blocks];\n              for (i = 0; i < DCTSIZE; i++)\n                for (j = 0; j < DCTSIZE; j++)\n                  dst_ptr[j * DCTSIZE + i] = src_ptr[i * DCTSIZE + j];\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_rot_270(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n           JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n           jvirt_barray_ptr *src_coef_arrays,\n           jvirt_barray_ptr *dst_coef_arrays)\n/* 270 degree rotation is equivalent to\n *   1. Horizontal mirroring;\n *   2. Transposing the image.\n * These two steps are merged into a single processing routine.\n */\n{\n  JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;\n  JDIMENSION x_crop_blocks, y_crop_blocks;\n  int ci, i, j, offset_x, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  JCOEFPTR src_ptr, dst_ptr;\n  jpeg_component_info *compptr;\n\n  /* Because of the horizontal mirror step, we can't process partial iMCUs\n   * at the (output) bottom edge properly.  They just get transposed and\n   * not mirrored.\n   */\n  MCU_rows = srcinfo->output_width /\n             (dstinfo->max_v_samp_factor * dstinfo_min_DCT_v_scaled_size);\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_height = MCU_rows * compptr->v_samp_factor;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;\n             dst_blk_x += compptr->h_samp_factor) {\n          src_buffer = (*srcinfo->mem->access_virt_barray)\n            ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n             dst_blk_x + x_crop_blocks,\n             (JDIMENSION)compptr->h_samp_factor, FALSE);\n          for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {\n            dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];\n            if (y_crop_blocks + dst_blk_y < comp_height) {\n              /* Block is within the mirrorable area. */\n              src_ptr = src_buffer[offset_x]\n                [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];\n              for (i = 0; i < DCTSIZE; i++) {\n                for (j = 0; j < DCTSIZE; j++) {\n                  dst_ptr[j * DCTSIZE + i] = src_ptr[i * DCTSIZE + j];\n                  j++;\n                  dst_ptr[j * DCTSIZE + i] = -src_ptr[i * DCTSIZE + j];\n                }\n              }\n            } else {\n              /* Edge blocks are transposed but not mirrored. */\n              src_ptr = src_buffer[offset_x]\n                [dst_blk_y + offset_y + y_crop_blocks];\n              for (i = 0; i < DCTSIZE; i++)\n                for (j = 0; j < DCTSIZE; j++)\n                  dst_ptr[j * DCTSIZE + i] = src_ptr[i * DCTSIZE + j];\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_rot_180(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n           JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n           jvirt_barray_ptr *src_coef_arrays,\n           jvirt_barray_ptr *dst_coef_arrays)\n/* 180 degree rotation is equivalent to\n *   1. Vertical mirroring;\n *   2. Horizontal mirroring.\n * These two steps are merged into a single processing routine.\n */\n{\n  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;\n  JDIMENSION x_crop_blocks, y_crop_blocks;\n  int ci, i, j, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  JBLOCKROW src_row_ptr, dst_row_ptr;\n  JCOEFPTR src_ptr, dst_ptr;\n  jpeg_component_info *compptr;\n\n  MCU_cols = srcinfo->output_width /\n             (dstinfo->max_h_samp_factor * dstinfo_min_DCT_h_scaled_size);\n  MCU_rows = srcinfo->output_height /\n             (dstinfo->max_v_samp_factor * dstinfo_min_DCT_v_scaled_size);\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_width = MCU_cols * compptr->h_samp_factor;\n    comp_height = MCU_rows * compptr->v_samp_factor;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      if (y_crop_blocks + dst_blk_y < comp_height) {\n        /* Row is within the vertically mirrorable area. */\n        src_buffer = (*srcinfo->mem->access_virt_barray)\n          ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n           comp_height - y_crop_blocks - dst_blk_y -\n           (JDIMENSION)compptr->v_samp_factor,\n           (JDIMENSION)compptr->v_samp_factor, FALSE);\n      } else {\n        /* Bottom-edge rows are only mirrored horizontally. */\n        src_buffer = (*srcinfo->mem->access_virt_barray)\n          ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n           dst_blk_y + y_crop_blocks,\n           (JDIMENSION)compptr->v_samp_factor, FALSE);\n      }\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        dst_row_ptr = dst_buffer[offset_y];\n        if (y_crop_blocks + dst_blk_y < comp_height) {\n          /* Row is within the mirrorable area. */\n          src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];\n          for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;\n               dst_blk_x++) {\n            dst_ptr = dst_row_ptr[dst_blk_x];\n            if (x_crop_blocks + dst_blk_x < comp_width) {\n              /* Process the blocks that can be mirrored both ways. */\n              src_ptr =\n                src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];\n              for (i = 0; i < DCTSIZE; i += 2) {\n                /* For even row, negate every odd column. */\n                for (j = 0; j < DCTSIZE; j += 2) {\n                  *dst_ptr++ = *src_ptr++;\n                  *dst_ptr++ = -(*src_ptr++);\n                }\n                /* For odd row, negate every even column. */\n                for (j = 0; j < DCTSIZE; j += 2) {\n                  *dst_ptr++ = -(*src_ptr++);\n                  *dst_ptr++ = *src_ptr++;\n                }\n              }\n            } else {\n              /* Any remaining right-edge blocks are only mirrored vertically. */\n              src_ptr = src_row_ptr[x_crop_blocks + dst_blk_x];\n              for (i = 0; i < DCTSIZE; i += 2) {\n                for (j = 0; j < DCTSIZE; j++)\n                  *dst_ptr++ = *src_ptr++;\n                for (j = 0; j < DCTSIZE; j++)\n                  *dst_ptr++ = -(*src_ptr++);\n              }\n            }\n          }\n        } else {\n          /* Remaining rows are just mirrored horizontally. */\n          src_row_ptr = src_buffer[offset_y];\n          for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;\n               dst_blk_x++) {\n            if (x_crop_blocks + dst_blk_x < comp_width) {\n              /* Process the blocks that can be mirrored. */\n              dst_ptr = dst_row_ptr[dst_blk_x];\n              src_ptr =\n                src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];\n              for (i = 0; i < DCTSIZE2; i += 2) {\n                *dst_ptr++ = *src_ptr++;\n                *dst_ptr++ = -(*src_ptr++);\n              }\n            } else {\n              /* Any remaining right-edge blocks are only copied. */\n              jcopy_block_row(src_row_ptr + dst_blk_x + x_crop_blocks,\n                              dst_row_ptr + dst_blk_x, (JDIMENSION)1);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nLOCAL(void)\ndo_transverse(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n              JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,\n              jvirt_barray_ptr *src_coef_arrays,\n              jvirt_barray_ptr *dst_coef_arrays)\n/* Transverse transpose is equivalent to\n *   1. 180 degree rotation;\n *   2. Transposition;\n * or\n *   1. Horizontal mirroring;\n *   2. Transposition;\n *   3. Horizontal mirroring.\n * These steps are merged into a single processing routine.\n */\n{\n  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;\n  JDIMENSION x_crop_blocks, y_crop_blocks;\n  int ci, i, j, offset_x, offset_y;\n  JBLOCKARRAY src_buffer, dst_buffer;\n  JCOEFPTR src_ptr, dst_ptr;\n  jpeg_component_info *compptr;\n\n  MCU_cols = srcinfo->output_height /\n             (dstinfo->max_h_samp_factor * dstinfo_min_DCT_h_scaled_size);\n  MCU_rows = srcinfo->output_width /\n             (dstinfo->max_v_samp_factor * dstinfo_min_DCT_v_scaled_size);\n\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    comp_width = MCU_cols * compptr->h_samp_factor;\n    comp_height = MCU_rows * compptr->v_samp_factor;\n    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;\n    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;\n    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;\n         dst_blk_y += compptr->v_samp_factor) {\n      dst_buffer = (*srcinfo->mem->access_virt_barray)\n        ((j_common_ptr)srcinfo, dst_coef_arrays[ci], dst_blk_y,\n         (JDIMENSION)compptr->v_samp_factor, TRUE);\n      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {\n        for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;\n             dst_blk_x += compptr->h_samp_factor) {\n          if (x_crop_blocks + dst_blk_x < comp_width) {\n            /* Block is within the mirrorable area. */\n            src_buffer = (*srcinfo->mem->access_virt_barray)\n              ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n               comp_width - x_crop_blocks - dst_blk_x -\n               (JDIMENSION)compptr->h_samp_factor,\n               (JDIMENSION)compptr->h_samp_factor, FALSE);\n          } else {\n            src_buffer = (*srcinfo->mem->access_virt_barray)\n              ((j_common_ptr)srcinfo, src_coef_arrays[ci],\n               dst_blk_x + x_crop_blocks,\n               (JDIMENSION)compptr->h_samp_factor, FALSE);\n          }\n          for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {\n            dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];\n            if (y_crop_blocks + dst_blk_y < comp_height) {\n              if (x_crop_blocks + dst_blk_x < comp_width) {\n                /* Block is within the mirrorable area. */\n                src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]\n                  [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];\n                for (i = 0; i < DCTSIZE; i++) {\n                  for (j = 0; j < DCTSIZE; j++) {\n                    dst_ptr[j * DCTSIZE + i] = src_ptr[i * DCTSIZE + j];\n                    j++;\n                    dst_ptr[j * DCTSIZE + i] = -src_ptr[i * DCTSIZE + j];\n                  }\n                  i++;\n                  for (j = 0; j < DCTSIZE; j++) {\n                    dst_ptr[j * DCTSIZE + i] = -src_ptr[i * DCTSIZE + j];\n                    j++;\n                    dst_ptr[j * DCTSIZE + i] = src_ptr[i * DCTSIZE + j];\n                  }\n                }\n              } else {\n                /* Right-edge blocks are mirrored in y only */\n                src_ptr = src_buffer[offset_x]\n                  [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];\n                for (i = 0; i < DCTSIZE; i++) {\n                  for (j = 0; j < DCTSIZE; j++) {\n                    dst_ptr[j * DCTSIZE + i] = src_ptr[i * DCTSIZE + j];\n                    j++;\n                    dst_ptr[j * DCTSIZE + i] = -src_ptr[i * DCTSIZE + j];\n                  }\n                }\n              }\n            } else {\n              if (x_crop_blocks + dst_blk_x < comp_width) {\n                /* Bottom-edge blocks are mirrored in x only */\n                src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]\n                  [dst_blk_y + offset_y + y_crop_blocks];\n                for (i = 0; i < DCTSIZE; i++) {\n                  for (j = 0; j < DCTSIZE; j++)\n                    dst_ptr[j * DCTSIZE + i] = src_ptr[i * DCTSIZE + j];\n                  i++;\n                  for (j = 0; j < DCTSIZE; j++)\n                    dst_ptr[j * DCTSIZE + i] = -src_ptr[i * DCTSIZE + j];\n                }\n              } else {\n                /* At lower right corner, just transpose, no mirroring */\n                src_ptr = src_buffer[offset_x]\n                  [dst_blk_y + offset_y + y_crop_blocks];\n                for (i = 0; i < DCTSIZE; i++)\n                  for (j = 0; j < DCTSIZE; j++)\n                    dst_ptr[j * DCTSIZE + i] = src_ptr[i * DCTSIZE + j];\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\n/* Parse an unsigned integer: subroutine for jtransform_parse_crop_spec.\n * Returns TRUE if valid integer found, FALSE if not.\n * *strptr is advanced over the digit string, and *result is set to its value.\n */\n\nLOCAL(boolean)\njt_read_integer(const char **strptr, JDIMENSION *result)\n{\n  const char *ptr = *strptr;\n  JDIMENSION val = 0;\n\n  for (; isdigit(*ptr); ptr++) {\n    val = val * 10 + (JDIMENSION)(*ptr - '0');\n  }\n  *result = val;\n  if (ptr == *strptr)\n    return FALSE;               /* oops, no digits */\n  *strptr = ptr;\n  return TRUE;\n}\n\n\n/* Parse a crop specification (written in X11 geometry style).\n * The routine returns TRUE if the spec string is valid, FALSE if not.\n *\n * The crop spec string should have the format\n *      <width>[{fr}]x<height>[{fr}]{+-}<xoffset>{+-}<yoffset>\n * where width, height, xoffset, and yoffset are unsigned integers.\n * Each of the elements can be omitted to indicate a default value.\n * (A weakness of this style is that it is not possible to omit xoffset\n * while specifying yoffset, since they look alike.)\n *\n * This code is loosely based on XParseGeometry from the X11 distribution.\n */\n\nGLOBAL(boolean)\njtransform_parse_crop_spec(jpeg_transform_info *info, const char *spec)\n{\n  info->crop = FALSE;\n  info->crop_width_set = JCROP_UNSET;\n  info->crop_height_set = JCROP_UNSET;\n  info->crop_xoffset_set = JCROP_UNSET;\n  info->crop_yoffset_set = JCROP_UNSET;\n\n  if (isdigit(*spec)) {\n    /* fetch width */\n    if (!jt_read_integer(&spec, &info->crop_width))\n      return FALSE;\n    if (*spec == 'f' || *spec == 'F') {\n      spec++;\n      info->crop_width_set = JCROP_FORCE;\n    } else if (*spec == 'r' || *spec == 'R') {\n      spec++;\n      info->crop_width_set = JCROP_REFLECT;\n    } else\n      info->crop_width_set = JCROP_POS;\n  }\n  if (*spec == 'x' || *spec == 'X') {\n    /* fetch height */\n    spec++;\n    if (!jt_read_integer(&spec, &info->crop_height))\n      return FALSE;\n    if (*spec == 'f' || *spec == 'F') {\n      spec++;\n      info->crop_height_set = JCROP_FORCE;\n    } else if (*spec == 'r' || *spec == 'R') {\n      spec++;\n      info->crop_height_set = JCROP_REFLECT;\n    } else\n      info->crop_height_set = JCROP_POS;\n  }\n  if (*spec == '+' || *spec == '-') {\n    /* fetch xoffset */\n    info->crop_xoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;\n    spec++;\n    if (!jt_read_integer(&spec, &info->crop_xoffset))\n      return FALSE;\n  }\n  if (*spec == '+' || *spec == '-') {\n    /* fetch yoffset */\n    info->crop_yoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;\n    spec++;\n    if (!jt_read_integer(&spec, &info->crop_yoffset))\n      return FALSE;\n  }\n  /* We had better have gotten to the end of the string. */\n  if (*spec != '\\0')\n    return FALSE;\n  info->crop = TRUE;\n  return TRUE;\n}\n\n\n/* Trim off any partial iMCUs on the indicated destination edge */\n\nLOCAL(void)\ntrim_right_edge(jpeg_transform_info *info, JDIMENSION full_width)\n{\n  JDIMENSION MCU_cols;\n\n  MCU_cols = info->output_width / info->iMCU_sample_width;\n  if (MCU_cols > 0 && info->x_crop_offset + MCU_cols ==\n      full_width / info->iMCU_sample_width)\n    info->output_width = MCU_cols * info->iMCU_sample_width;\n}\n\nLOCAL(void)\ntrim_bottom_edge(jpeg_transform_info *info, JDIMENSION full_height)\n{\n  JDIMENSION MCU_rows;\n\n  MCU_rows = info->output_height / info->iMCU_sample_height;\n  if (MCU_rows > 0 && info->y_crop_offset + MCU_rows ==\n      full_height / info->iMCU_sample_height)\n    info->output_height = MCU_rows * info->iMCU_sample_height;\n}\n\n\n/* Request any required workspace.\n *\n * This routine figures out the size that the output image will be\n * (which implies that all the transform parameters must be set before\n * it is called).\n *\n * We allocate the workspace virtual arrays from the source decompression\n * object, so that all the arrays (both the original data and the workspace)\n * will be taken into account while making memory management decisions.\n * Hence, this routine must be called after jpeg_read_header (which reads\n * the image dimensions) and before jpeg_read_coefficients (which realizes\n * the source's virtual arrays).\n *\n * This function returns FALSE right away if -perfect is given\n * and transformation is not perfect.  Otherwise returns TRUE.\n */\n\nGLOBAL(boolean)\njtransform_request_workspace(j_decompress_ptr srcinfo,\n                             jpeg_transform_info *info)\n{\n  jvirt_barray_ptr *coef_arrays;\n  boolean need_workspace, transpose_it;\n  jpeg_component_info *compptr;\n  JDIMENSION xoffset, yoffset, dtemp;\n  JDIMENSION width_in_iMCUs, height_in_iMCUs;\n  JDIMENSION width_in_blocks, height_in_blocks;\n  int itemp, ci, h_samp_factor, v_samp_factor;\n\n  /* Determine number of components in output image */\n  if (info->force_grayscale &&\n      srcinfo->jpeg_color_space == JCS_YCbCr &&\n      srcinfo->num_components == 3)\n    /* We'll only process the first component */\n    info->num_components = 1;\n  else\n    /* Process all the components */\n    info->num_components = srcinfo->num_components;\n\n  /* Compute output image dimensions and related values. */\n#if JPEG_LIB_VERSION >= 80\n  jpeg_core_output_dimensions(srcinfo);\n#else\n  srcinfo->output_width = srcinfo->image_width;\n  srcinfo->output_height = srcinfo->image_height;\n#endif\n\n  /* Return right away if -perfect is given and transformation is not perfect.\n   */\n  if (info->perfect) {\n    if (info->num_components == 1) {\n      if (!jtransform_perfect_transform(srcinfo->output_width,\n          srcinfo->output_height,\n          srcinfo->_min_DCT_h_scaled_size,\n          srcinfo->_min_DCT_v_scaled_size,\n          info->transform))\n        return FALSE;\n    } else {\n      if (!jtransform_perfect_transform(srcinfo->output_width,\n          srcinfo->output_height,\n          srcinfo->max_h_samp_factor * srcinfo->_min_DCT_h_scaled_size,\n          srcinfo->max_v_samp_factor * srcinfo->_min_DCT_v_scaled_size,\n          info->transform))\n        return FALSE;\n    }\n  }\n\n  /* If there is only one output component, force the iMCU size to be 1;\n   * else use the source iMCU size.  (This allows us to do the right thing\n   * when reducing color to grayscale, and also provides a handy way of\n   * cleaning up \"funny\" grayscale images whose sampling factors are not 1x1.)\n   */\n  switch (info->transform) {\n  case JXFORM_TRANSPOSE:\n  case JXFORM_TRANSVERSE:\n  case JXFORM_ROT_90:\n  case JXFORM_ROT_270:\n    info->output_width = srcinfo->output_height;\n    info->output_height = srcinfo->output_width;\n    if (info->num_components == 1) {\n      info->iMCU_sample_width = srcinfo->_min_DCT_v_scaled_size;\n      info->iMCU_sample_height = srcinfo->_min_DCT_h_scaled_size;\n    } else {\n      info->iMCU_sample_width =\n        srcinfo->max_v_samp_factor * srcinfo->_min_DCT_v_scaled_size;\n      info->iMCU_sample_height =\n        srcinfo->max_h_samp_factor * srcinfo->_min_DCT_h_scaled_size;\n    }\n    break;\n  default:\n    info->output_width = srcinfo->output_width;\n    info->output_height = srcinfo->output_height;\n    if (info->num_components == 1) {\n      info->iMCU_sample_width = srcinfo->_min_DCT_h_scaled_size;\n      info->iMCU_sample_height = srcinfo->_min_DCT_v_scaled_size;\n    } else {\n      info->iMCU_sample_width =\n        srcinfo->max_h_samp_factor * srcinfo->_min_DCT_h_scaled_size;\n      info->iMCU_sample_height =\n        srcinfo->max_v_samp_factor * srcinfo->_min_DCT_v_scaled_size;\n    }\n    break;\n  }\n\n  /* If cropping has been requested, compute the crop area's position and\n   * dimensions, ensuring that its upper left corner falls at an iMCU boundary.\n   */\n  if (info->crop) {\n    /* Insert default values for unset crop parameters */\n    if (info->crop_xoffset_set == JCROP_UNSET)\n      info->crop_xoffset = 0;   /* default to +0 */\n    if (info->crop_yoffset_set == JCROP_UNSET)\n      info->crop_yoffset = 0;   /* default to +0 */\n    if (info->crop_width_set == JCROP_UNSET) {\n      if (info->crop_xoffset >= info->output_width)\n        ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);\n      info->crop_width = info->output_width - info->crop_xoffset;\n    } else {\n      /* Check for crop extension */\n      if (info->crop_width > info->output_width) {\n        /* Crop extension does not work when transforming! */\n        if (info->transform != JXFORM_NONE ||\n            info->crop_xoffset >= info->crop_width ||\n            info->crop_xoffset > info->crop_width - info->output_width)\n          ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);\n      } else {\n        if (info->crop_xoffset >= info->output_width ||\n            info->crop_width <= 0 ||\n            info->crop_xoffset > info->output_width - info->crop_width)\n          ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);\n      }\n    }\n    if (info->crop_height_set == JCROP_UNSET) {\n      if (info->crop_yoffset >= info->output_height)\n        ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);\n      info->crop_height = info->output_height - info->crop_yoffset;\n    } else {\n      /* Check for crop extension */\n      if (info->crop_height > info->output_height) {\n        /* Crop extension does not work when transforming! */\n        if (info->transform != JXFORM_NONE ||\n            info->crop_yoffset >= info->crop_height ||\n            info->crop_yoffset > info->crop_height - info->output_height)\n          ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);\n      } else {\n        if (info->crop_yoffset >= info->output_height ||\n            info->crop_height <= 0 ||\n            info->crop_yoffset > info->output_height - info->crop_height)\n          ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);\n      }\n    }\n    /* Convert negative crop offsets into regular offsets */\n    if (info->crop_xoffset_set != JCROP_NEG)\n      xoffset = info->crop_xoffset;\n    else if (info->crop_width > info->output_width) /* crop extension */\n      xoffset = info->crop_width - info->output_width - info->crop_xoffset;\n    else\n      xoffset = info->output_width - info->crop_width - info->crop_xoffset;\n    if (info->crop_yoffset_set != JCROP_NEG)\n      yoffset = info->crop_yoffset;\n    else if (info->crop_height > info->output_height) /* crop extension */\n      yoffset = info->crop_height - info->output_height - info->crop_yoffset;\n    else\n      yoffset = info->output_height - info->crop_height - info->crop_yoffset;\n    /* Now adjust so that upper left corner falls at an iMCU boundary */\n    switch (info->transform) {\n    case JXFORM_DROP:\n      /* Ensure the effective drop region will not exceed the requested */\n      itemp = info->iMCU_sample_width;\n      dtemp = itemp - 1 - ((xoffset + itemp - 1) % itemp);\n      xoffset += dtemp;\n      if (info->crop_width <= dtemp)\n        info->drop_width = 0;\n      else if (xoffset + info->crop_width - dtemp == info->output_width)\n        /* Matching right edge: include partial iMCU */\n        info->drop_width = (info->crop_width - dtemp + itemp - 1) / itemp;\n      else\n        info->drop_width = (info->crop_width - dtemp) / itemp;\n      itemp = info->iMCU_sample_height;\n      dtemp = itemp - 1 - ((yoffset + itemp - 1) % itemp);\n      yoffset += dtemp;\n      if (info->crop_height <= dtemp)\n        info->drop_height = 0;\n      else if (yoffset + info->crop_height - dtemp == info->output_height)\n        /* Matching bottom edge: include partial iMCU */\n        info->drop_height = (info->crop_height - dtemp + itemp - 1) / itemp;\n      else\n        info->drop_height = (info->crop_height - dtemp) / itemp;\n      /* Check if sampling factors match for dropping */\n      if (info->drop_width != 0 && info->drop_height != 0)\n        for (ci = 0; ci < info->num_components &&\n                     ci < info->drop_ptr->num_components; ci++) {\n          if (info->drop_ptr->comp_info[ci].h_samp_factor *\n              srcinfo->max_h_samp_factor !=\n              srcinfo->comp_info[ci].h_samp_factor *\n              info->drop_ptr->max_h_samp_factor)\n            ERREXIT6(srcinfo, JERR_BAD_DROP_SAMPLING, ci,\n              info->drop_ptr->comp_info[ci].h_samp_factor,\n              info->drop_ptr->max_h_samp_factor,\n              srcinfo->comp_info[ci].h_samp_factor,\n              srcinfo->max_h_samp_factor, 'h');\n          if (info->drop_ptr->comp_info[ci].v_samp_factor *\n              srcinfo->max_v_samp_factor !=\n              srcinfo->comp_info[ci].v_samp_factor *\n              info->drop_ptr->max_v_samp_factor)\n            ERREXIT6(srcinfo, JERR_BAD_DROP_SAMPLING, ci,\n              info->drop_ptr->comp_info[ci].v_samp_factor,\n              info->drop_ptr->max_v_samp_factor,\n              srcinfo->comp_info[ci].v_samp_factor,\n              srcinfo->max_v_samp_factor, 'v');\n        }\n      break;\n    case JXFORM_WIPE:\n      /* Ensure the effective wipe region will cover the requested */\n      info->drop_width = (JDIMENSION)jdiv_round_up\n        ((long)(info->crop_width + (xoffset % info->iMCU_sample_width)),\n         (long)info->iMCU_sample_width);\n      info->drop_height = (JDIMENSION)jdiv_round_up\n        ((long)(info->crop_height + (yoffset % info->iMCU_sample_height)),\n         (long)info->iMCU_sample_height);\n      break;\n    default:\n      /* Ensure the effective crop region will cover the requested */\n      if (info->crop_width_set == JCROP_FORCE ||\n          info->crop_width > info->output_width)\n        info->output_width = info->crop_width;\n      else\n        info->output_width =\n          info->crop_width + (xoffset % info->iMCU_sample_width);\n      if (info->crop_height_set == JCROP_FORCE ||\n          info->crop_height > info->output_height)\n        info->output_height = info->crop_height;\n      else\n        info->output_height =\n          info->crop_height + (yoffset % info->iMCU_sample_height);\n    }\n    /* Save x/y offsets measured in iMCUs */\n    info->x_crop_offset = xoffset / info->iMCU_sample_width;\n    info->y_crop_offset = yoffset / info->iMCU_sample_height;\n  } else {\n    info->x_crop_offset = 0;\n    info->y_crop_offset = 0;\n  }\n\n  /* Figure out whether we need workspace arrays,\n   * and if so whether they are transposed relative to the source.\n   */\n  need_workspace = FALSE;\n  transpose_it = FALSE;\n  switch (info->transform) {\n  case JXFORM_NONE:\n    if (info->x_crop_offset != 0 || info->y_crop_offset != 0 ||\n        info->output_width > srcinfo->output_width ||\n        info->output_height > srcinfo->output_height)\n      need_workspace = TRUE;\n    /* No workspace needed if neither cropping nor transforming */\n    break;\n  case JXFORM_FLIP_H:\n    if (info->trim)\n      trim_right_edge(info, srcinfo->output_width);\n    if (info->y_crop_offset != 0 || info->slow_hflip)\n      need_workspace = TRUE;\n    /* do_flip_h_no_crop doesn't need a workspace array */\n    break;\n  case JXFORM_FLIP_V:\n    if (info->trim)\n      trim_bottom_edge(info, srcinfo->output_height);\n    /* Need workspace arrays having same dimensions as source image. */\n    need_workspace = TRUE;\n    break;\n  case JXFORM_TRANSPOSE:\n    /* transpose does NOT have to trim anything */\n    /* Need workspace arrays having transposed dimensions. */\n    need_workspace = TRUE;\n    transpose_it = TRUE;\n    break;\n  case JXFORM_TRANSVERSE:\n    if (info->trim) {\n      trim_right_edge(info, srcinfo->output_height);\n      trim_bottom_edge(info, srcinfo->output_width);\n    }\n    /* Need workspace arrays having transposed dimensions. */\n    need_workspace = TRUE;\n    transpose_it = TRUE;\n    break;\n  case JXFORM_ROT_90:\n    if (info->trim)\n      trim_right_edge(info, srcinfo->output_height);\n    /* Need workspace arrays having transposed dimensions. */\n    need_workspace = TRUE;\n    transpose_it = TRUE;\n    break;\n  case JXFORM_ROT_180:\n    if (info->trim) {\n      trim_right_edge(info, srcinfo->output_width);\n      trim_bottom_edge(info, srcinfo->output_height);\n    }\n    /* Need workspace arrays having same dimensions as source image. */\n    need_workspace = TRUE;\n    break;\n  case JXFORM_ROT_270:\n    if (info->trim)\n      trim_bottom_edge(info, srcinfo->output_width);\n    /* Need workspace arrays having transposed dimensions. */\n    need_workspace = TRUE;\n    transpose_it = TRUE;\n    break;\n  case JXFORM_WIPE:\n    break;\n  case JXFORM_DROP:\n    break;\n  }\n\n  /* Allocate workspace if needed.\n   * Note that we allocate arrays padded out to the next iMCU boundary,\n   * so that transform routines need not worry about missing edge blocks.\n   */\n  if (need_workspace) {\n    coef_arrays = (jvirt_barray_ptr *)\n      (*srcinfo->mem->alloc_small) ((j_common_ptr)srcinfo, JPOOL_IMAGE,\n                sizeof(jvirt_barray_ptr) * info->num_components);\n    width_in_iMCUs = (JDIMENSION)\n      jdiv_round_up((long)info->output_width, (long)info->iMCU_sample_width);\n    height_in_iMCUs = (JDIMENSION)\n      jdiv_round_up((long)info->output_height, (long)info->iMCU_sample_height);\n    for (ci = 0; ci < info->num_components; ci++) {\n      compptr = srcinfo->comp_info + ci;\n      if (info->num_components == 1) {\n        /* we're going to force samp factors to 1x1 in this case */\n        h_samp_factor = v_samp_factor = 1;\n      } else if (transpose_it) {\n        h_samp_factor = compptr->v_samp_factor;\n        v_samp_factor = compptr->h_samp_factor;\n      } else {\n        h_samp_factor = compptr->h_samp_factor;\n        v_samp_factor = compptr->v_samp_factor;\n      }\n      width_in_blocks = width_in_iMCUs * h_samp_factor;\n      height_in_blocks = height_in_iMCUs * v_samp_factor;\n      coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)\n        ((j_common_ptr)srcinfo, JPOOL_IMAGE, FALSE,\n         width_in_blocks, height_in_blocks, (JDIMENSION)v_samp_factor);\n    }\n    info->workspace_coef_arrays = coef_arrays;\n  } else\n    info->workspace_coef_arrays = NULL;\n\n  return TRUE;\n}\n\n\n/* Transpose destination image parameters */\n\nLOCAL(void)\ntranspose_critical_parameters(j_compress_ptr dstinfo)\n{\n  int tblno, i, j, ci, itemp;\n  jpeg_component_info *compptr;\n  JQUANT_TBL *qtblptr;\n  JDIMENSION jtemp;\n  UINT16 qtemp;\n\n  /* Transpose image dimensions */\n  jtemp = dstinfo->image_width;\n  dstinfo->image_width = dstinfo->image_height;\n  dstinfo->image_height = jtemp;\n#if JPEG_LIB_VERSION >= 70\n  itemp = dstinfo->min_DCT_h_scaled_size;\n  dstinfo->min_DCT_h_scaled_size = dstinfo->min_DCT_v_scaled_size;\n  dstinfo->min_DCT_v_scaled_size = itemp;\n#endif\n\n  /* Transpose sampling factors */\n  for (ci = 0; ci < dstinfo->num_components; ci++) {\n    compptr = dstinfo->comp_info + ci;\n    itemp = compptr->h_samp_factor;\n    compptr->h_samp_factor = compptr->v_samp_factor;\n    compptr->v_samp_factor = itemp;\n  }\n\n  /* Transpose quantization tables */\n  for (tblno = 0; tblno < NUM_QUANT_TBLS; tblno++) {\n    qtblptr = dstinfo->quant_tbl_ptrs[tblno];\n    if (qtblptr != NULL) {\n      for (i = 0; i < DCTSIZE; i++) {\n        for (j = 0; j < i; j++) {\n          qtemp = qtblptr->quantval[i * DCTSIZE + j];\n          qtblptr->quantval[i * DCTSIZE + j] =\n            qtblptr->quantval[j * DCTSIZE + i];\n          qtblptr->quantval[j * DCTSIZE + i] = qtemp;\n        }\n      }\n    }\n  }\n}\n\n\n/* Adjust Exif image parameters.\n *\n * We try to adjust the Tags ExifImageWidth and ExifImageHeight if possible.\n */\n\nLOCAL(void)\nadjust_exif_parameters(JOCTET *data, unsigned int length, JDIMENSION new_width,\n                       JDIMENSION new_height)\n{\n  boolean is_motorola; /* Flag for byte order */\n  unsigned int number_of_tags, tagnum;\n  unsigned int firstoffset, offset;\n  JDIMENSION new_value;\n\n  if (length < 12) return; /* Length of an IFD entry */\n\n  /* Discover byte order */\n  if (data[0] == 0x49 && data[1] == 0x49)\n    is_motorola = FALSE;\n  else if (data[0] == 0x4D && data[1] == 0x4D)\n    is_motorola = TRUE;\n  else\n    return;\n\n  /* Check Tag Mark */\n  if (is_motorola) {\n    if (data[2] != 0) return;\n    if (data[3] != 0x2A) return;\n  } else {\n    if (data[3] != 0) return;\n    if (data[2] != 0x2A) return;\n  }\n\n  /* Get first IFD offset (offset to IFD0) */\n  if (is_motorola) {\n    if (data[4] != 0) return;\n    if (data[5] != 0) return;\n    firstoffset = data[6];\n    firstoffset <<= 8;\n    firstoffset += data[7];\n  } else {\n    if (data[7] != 0) return;\n    if (data[6] != 0) return;\n    firstoffset = data[5];\n    firstoffset <<= 8;\n    firstoffset += data[4];\n  }\n  if (firstoffset > length - 2) return; /* check end of data segment */\n\n  /* Get the number of directory entries contained in this IFD */\n  if (is_motorola) {\n    number_of_tags = data[firstoffset];\n    number_of_tags <<= 8;\n    number_of_tags += data[firstoffset + 1];\n  } else {\n    number_of_tags = data[firstoffset + 1];\n    number_of_tags <<= 8;\n    number_of_tags += data[firstoffset];\n  }\n  if (number_of_tags == 0) return;\n  firstoffset += 2;\n\n  /* Search for ExifSubIFD offset Tag in IFD0 */\n  for (;;) {\n    if (firstoffset > length - 12) return; /* check end of data segment */\n    /* Get Tag number */\n    if (is_motorola) {\n      tagnum = data[firstoffset];\n      tagnum <<= 8;\n      tagnum += data[firstoffset + 1];\n    } else {\n      tagnum = data[firstoffset + 1];\n      tagnum <<= 8;\n      tagnum += data[firstoffset];\n    }\n    if (tagnum == 0x8769) break; /* found ExifSubIFD offset Tag */\n    if (--number_of_tags == 0) return;\n    firstoffset += 12;\n  }\n\n  /* Get the ExifSubIFD offset */\n  if (is_motorola) {\n    if (data[firstoffset + 8] != 0) return;\n    if (data[firstoffset + 9] != 0) return;\n    offset = data[firstoffset + 10];\n    offset <<= 8;\n    offset += data[firstoffset + 11];\n  } else {\n    if (data[firstoffset + 11] != 0) return;\n    if (data[firstoffset + 10] != 0) return;\n    offset = data[firstoffset + 9];\n    offset <<= 8;\n    offset += data[firstoffset + 8];\n  }\n  if (offset > length - 2) return; /* check end of data segment */\n\n  /* Get the number of directory entries contained in this SubIFD */\n  if (is_motorola) {\n    number_of_tags = data[offset];\n    number_of_tags <<= 8;\n    number_of_tags += data[offset + 1];\n  } else {\n    number_of_tags = data[offset + 1];\n    number_of_tags <<= 8;\n    number_of_tags += data[offset];\n  }\n  if (number_of_tags < 2) return;\n  offset += 2;\n\n  /* Search for ExifImageWidth and ExifImageHeight Tags in this SubIFD */\n  do {\n    if (offset > length - 12) return; /* check end of data segment */\n    /* Get Tag number */\n    if (is_motorola) {\n      tagnum = data[offset];\n      tagnum <<= 8;\n      tagnum += data[offset + 1];\n    } else {\n      tagnum = data[offset + 1];\n      tagnum <<= 8;\n      tagnum += data[offset];\n    }\n    if (tagnum == 0xA002 || tagnum == 0xA003) {\n      if (tagnum == 0xA002)\n        new_value = new_width; /* ExifImageWidth Tag */\n      else\n        new_value = new_height; /* ExifImageHeight Tag */\n      if (is_motorola) {\n        data[offset + 2] = 0; /* Format = unsigned long (4 octets) */\n        data[offset + 3] = 4;\n        data[offset + 4] = 0; /* Number Of Components = 1 */\n        data[offset + 5] = 0;\n        data[offset + 6] = 0;\n        data[offset + 7] = 1;\n        data[offset + 8] = 0;\n        data[offset + 9] = 0;\n        data[offset + 10] = (JOCTET)((new_value >> 8) & 0xFF);\n        data[offset + 11] = (JOCTET)(new_value & 0xFF);\n      } else {\n        data[offset + 2] = 4; /* Format = unsigned long (4 octets) */\n        data[offset + 3] = 0;\n        data[offset + 4] = 1; /* Number Of Components = 1 */\n        data[offset + 5] = 0;\n        data[offset + 6] = 0;\n        data[offset + 7] = 0;\n        data[offset + 8] = (JOCTET)(new_value & 0xFF);\n        data[offset + 9] = (JOCTET)((new_value >> 8) & 0xFF);\n        data[offset + 10] = 0;\n        data[offset + 11] = 0;\n      }\n    }\n    offset += 12;\n  } while (--number_of_tags);\n}\n\n\n/* Adjust output image parameters as needed.\n *\n * This must be called after jpeg_copy_critical_parameters()\n * and before jpeg_write_coefficients().\n *\n * The return value is the set of virtual coefficient arrays to be written\n * (either the ones allocated by jtransform_request_workspace, or the\n * original source data arrays).  The caller will need to pass this value\n * to jpeg_write_coefficients().\n */\n\nGLOBAL(jvirt_barray_ptr *)\njtransform_adjust_parameters(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n                             jvirt_barray_ptr *src_coef_arrays,\n                             jpeg_transform_info *info)\n{\n  /* If force-to-grayscale is requested, adjust destination parameters */\n  if (info->force_grayscale) {\n    /* First, ensure we have YCbCr or grayscale data, and that the source's\n     * Y channel is full resolution.  (No reasonable person would make Y\n     * be less than full resolution, so actually coping with that case\n     * isn't worth extra code space.  But we check it to avoid crashing.)\n     */\n    if (((dstinfo->jpeg_color_space == JCS_YCbCr &&\n          dstinfo->num_components == 3) ||\n         (dstinfo->jpeg_color_space == JCS_GRAYSCALE &&\n          dstinfo->num_components == 1)) &&\n        srcinfo->comp_info[0].h_samp_factor == srcinfo->max_h_samp_factor &&\n        srcinfo->comp_info[0].v_samp_factor == srcinfo->max_v_samp_factor) {\n      /* We use jpeg_set_colorspace to make sure subsidiary settings get fixed\n       * properly.  Among other things, it sets the target h_samp_factor &\n       * v_samp_factor to 1, which typically won't match the source.\n       * We have to preserve the source's quantization table number, however.\n       */\n      int sv_quant_tbl_no = dstinfo->comp_info[0].quant_tbl_no;\n      jpeg_set_colorspace(dstinfo, JCS_GRAYSCALE);\n      dstinfo->comp_info[0].quant_tbl_no = sv_quant_tbl_no;\n    } else {\n      /* Sorry, can't do it */\n      ERREXIT(dstinfo, JERR_CONVERSION_NOTIMPL);\n    }\n  } else if (info->num_components == 1) {\n    /* For a single-component source, we force the destination sampling factors\n     * to 1x1, with or without force_grayscale.  This is useful because some\n     * decoders choke on grayscale images with other sampling factors.\n     */\n    dstinfo->comp_info[0].h_samp_factor = 1;\n    dstinfo->comp_info[0].v_samp_factor = 1;\n  }\n\n  /* Correct the destination's image dimensions as necessary\n   * for rotate/flip, resize, and crop operations.\n   */\n#if JPEG_LIB_VERSION >= 80\n  dstinfo->jpeg_width = info->output_width;\n  dstinfo->jpeg_height = info->output_height;\n#endif\n\n  /* Transpose destination image parameters, adjust quantization */\n  switch (info->transform) {\n  case JXFORM_TRANSPOSE:\n  case JXFORM_TRANSVERSE:\n  case JXFORM_ROT_90:\n  case JXFORM_ROT_270:\n#if JPEG_LIB_VERSION < 80\n    dstinfo->image_width = info->output_height;\n    dstinfo->image_height = info->output_width;\n#endif\n    transpose_critical_parameters(dstinfo);\n    break;\n  case JXFORM_DROP:\n    if (info->drop_width != 0 && info->drop_height != 0)\n      adjust_quant(srcinfo, src_coef_arrays,\n                   info->drop_ptr, info->drop_coef_arrays,\n                   info->trim, dstinfo);\n    break;\n  default:\n#if JPEG_LIB_VERSION < 80\n    dstinfo->image_width = info->output_width;\n    dstinfo->image_height = info->output_height;\n#endif\n    break;\n  }\n\n  /* Adjust Exif properties */\n  if (srcinfo->marker_list != NULL &&\n      srcinfo->marker_list->marker == JPEG_APP0 + 1 &&\n      srcinfo->marker_list->data_length >= 6 &&\n      srcinfo->marker_list->data[0] == 0x45 &&\n      srcinfo->marker_list->data[1] == 0x78 &&\n      srcinfo->marker_list->data[2] == 0x69 &&\n      srcinfo->marker_list->data[3] == 0x66 &&\n      srcinfo->marker_list->data[4] == 0 &&\n      srcinfo->marker_list->data[5] == 0) {\n    /* Suppress output of JFIF marker */\n    dstinfo->write_JFIF_header = FALSE;\n    /* Adjust Exif image parameters */\n#if JPEG_LIB_VERSION >= 80\n    if (dstinfo->jpeg_width != srcinfo->image_width ||\n        dstinfo->jpeg_height != srcinfo->image_height)\n      /* Align data segment to start of TIFF structure for parsing */\n      adjust_exif_parameters(srcinfo->marker_list->data + 6,\n                             srcinfo->marker_list->data_length - 6,\n                             dstinfo->jpeg_width, dstinfo->jpeg_height);\n#else\n    if (dstinfo->image_width != srcinfo->image_width ||\n        dstinfo->image_height != srcinfo->image_height)\n      /* Align data segment to start of TIFF structure for parsing */\n      adjust_exif_parameters(srcinfo->marker_list->data + 6,\n                             srcinfo->marker_list->data_length - 6,\n                             dstinfo->image_width, dstinfo->image_height);\n#endif\n  }\n\n  /* Return the appropriate output data set */\n  if (info->workspace_coef_arrays != NULL)\n    return info->workspace_coef_arrays;\n  return src_coef_arrays;\n}\n\n\n/* Execute the actual transformation, if any.\n *\n * This must be called *after* jpeg_write_coefficients, because it depends\n * on jpeg_write_coefficients to have computed subsidiary values such as\n * the per-component width and height fields in the destination object.\n *\n * Note that some transformations will modify the source data arrays!\n */\n\nGLOBAL(void)\njtransform_execute_transform(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n                             jvirt_barray_ptr *src_coef_arrays,\n                             jpeg_transform_info *info)\n{\n  jvirt_barray_ptr *dst_coef_arrays = info->workspace_coef_arrays;\n\n  /* Note: conditions tested here should match those in switch statement\n   * in jtransform_request_workspace()\n   */\n  switch (info->transform) {\n  case JXFORM_NONE:\n    if (info->output_width > srcinfo->output_width ||\n        info->output_height > srcinfo->output_height) {\n      if (info->output_width > srcinfo->output_width &&\n          info->crop_width_set == JCROP_REFLECT)\n        do_crop_ext_reflect(srcinfo, dstinfo,\n                            info->x_crop_offset, info->y_crop_offset,\n                            src_coef_arrays, dst_coef_arrays);\n      else if (info->output_width > srcinfo->output_width &&\n               info->crop_width_set == JCROP_FORCE)\n        do_crop_ext_flat(srcinfo, dstinfo,\n                         info->x_crop_offset, info->y_crop_offset,\n                         src_coef_arrays, dst_coef_arrays);\n      else\n        do_crop_ext_zero(srcinfo, dstinfo,\n                         info->x_crop_offset, info->y_crop_offset,\n                         src_coef_arrays, dst_coef_arrays);\n    } else if (info->x_crop_offset != 0 || info->y_crop_offset != 0)\n      do_crop(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n              src_coef_arrays, dst_coef_arrays);\n    break;\n  case JXFORM_FLIP_H:\n    if (info->y_crop_offset != 0 || info->slow_hflip)\n      do_flip_h(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n                src_coef_arrays, dst_coef_arrays);\n    else\n      do_flip_h_no_crop(srcinfo, dstinfo, info->x_crop_offset,\n                        src_coef_arrays);\n    break;\n  case JXFORM_FLIP_V:\n    do_flip_v(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n              src_coef_arrays, dst_coef_arrays);\n    break;\n  case JXFORM_TRANSPOSE:\n    do_transpose(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n                 src_coef_arrays, dst_coef_arrays);\n    break;\n  case JXFORM_TRANSVERSE:\n    do_transverse(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n                  src_coef_arrays, dst_coef_arrays);\n    break;\n  case JXFORM_ROT_90:\n    do_rot_90(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n              src_coef_arrays, dst_coef_arrays);\n    break;\n  case JXFORM_ROT_180:\n    do_rot_180(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n               src_coef_arrays, dst_coef_arrays);\n    break;\n  case JXFORM_ROT_270:\n    do_rot_270(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n               src_coef_arrays, dst_coef_arrays);\n    break;\n  case JXFORM_WIPE:\n    if (info->crop_width_set == JCROP_REFLECT &&\n        info->y_crop_offset == 0 && info->drop_height ==\n        (JDIMENSION)jdiv_round_up\n          ((long)info->output_height, (long)info->iMCU_sample_height) &&\n        (info->x_crop_offset == 0 ||\n         info->x_crop_offset + info->drop_width ==\n         (JDIMENSION)jdiv_round_up\n           ((long)info->output_width, (long)info->iMCU_sample_width)))\n      do_reflect(srcinfo, dstinfo, info->x_crop_offset,\n                 src_coef_arrays, info->drop_width, info->drop_height);\n    else if (info->crop_width_set == JCROP_FORCE)\n      do_flatten(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n                 src_coef_arrays, info->drop_width, info->drop_height);\n    else\n      do_wipe(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n              src_coef_arrays, info->drop_width, info->drop_height);\n    break;\n  case JXFORM_DROP:\n    if (info->drop_width != 0 && info->drop_height != 0)\n      do_drop(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,\n              src_coef_arrays, info->drop_ptr, info->drop_coef_arrays,\n              info->drop_width, info->drop_height);\n    break;\n  }\n}\n\n/* jtransform_perfect_transform\n *\n * Determine whether lossless transformation is perfectly\n * possible for a specified image and transformation.\n *\n * Inputs:\n *   image_width, image_height: source image dimensions.\n *   MCU_width, MCU_height: pixel dimensions of MCU.\n *   transform: transformation identifier.\n * Parameter sources from initialized jpeg_struct\n * (after reading source header):\n *   image_width = cinfo.image_width\n *   image_height = cinfo.image_height\n *   MCU_width = cinfo.max_h_samp_factor * cinfo.block_size\n *   MCU_height = cinfo.max_v_samp_factor * cinfo.block_size\n * Result:\n *   TRUE = perfect transformation possible\n *   FALSE = perfect transformation not possible\n *           (may use custom action then)\n */\n\nGLOBAL(boolean)\njtransform_perfect_transform(JDIMENSION image_width, JDIMENSION image_height,\n                             int MCU_width, int MCU_height,\n                             JXFORM_CODE transform)\n{\n  boolean result = TRUE; /* initialize TRUE */\n\n  switch (transform) {\n  case JXFORM_FLIP_H:\n  case JXFORM_ROT_270:\n    if (image_width % (JDIMENSION)MCU_width)\n      result = FALSE;\n    break;\n  case JXFORM_FLIP_V:\n  case JXFORM_ROT_90:\n    if (image_height % (JDIMENSION)MCU_height)\n      result = FALSE;\n    break;\n  case JXFORM_TRANSVERSE:\n  case JXFORM_ROT_180:\n    if (image_width % (JDIMENSION)MCU_width)\n      result = FALSE;\n    if (image_height % (JDIMENSION)MCU_height)\n      result = FALSE;\n    break;\n  default:\n    break;\n  }\n\n  return result;\n}\n\n#endif /* TRANSFORMS_SUPPORTED */\n\n\n/* Setup decompression object to save desired markers in memory.\n * This must be called before jpeg_read_header() to have the desired effect.\n */\n\nGLOBAL(void)\njcopy_markers_setup(j_decompress_ptr srcinfo, JCOPY_OPTION option)\n{\n#ifdef SAVE_MARKERS_SUPPORTED\n  int m;\n\n  /* Save comments unless JCOPYOPT_NONE or JCOPYOPT_ICC specified */\n  if (option != JCOPYOPT_NONE && option != JCOPYOPT_ICC) {\n    jpeg_save_markers(srcinfo, JPEG_COM, 0xFFFF);\n  }\n  /* Save all APPn markers iff JCOPYOPT_ALL* specified ... */\n  if (option == JCOPYOPT_ALL || option == JCOPYOPT_ALL_EXCEPT_ICC) {\n    for (m = 0; m < 16; m++) {\n      /* ... except APP2 markers if JCOPYOPT_ALL_EXCEPT_ICC specified */\n      if (option == JCOPYOPT_ALL_EXCEPT_ICC && m == 2)\n        continue;\n      jpeg_save_markers(srcinfo, JPEG_APP0 + m, 0xFFFF);\n    }\n  }\n  /* Save only APP2 markers if JCOPYOPT_ICC specified */\n  if (option == JCOPYOPT_ICC) {\n    jpeg_save_markers(srcinfo, JPEG_APP0 + 2, 0xFFFF);\n  }\n#endif /* SAVE_MARKERS_SUPPORTED */\n}\n\n/* Copy markers saved in the given source object to the destination object.\n * This should be called just after jpeg_start_compress() or\n * jpeg_write_coefficients().\n * Note that those routines will have written the SOI, and also the\n * JFIF APP0 or Adobe APP14 markers if selected.\n */\n\nGLOBAL(void)\njcopy_markers_execute(j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n                      JCOPY_OPTION option)\n{\n  jpeg_saved_marker_ptr marker;\n\n  for (marker = srcinfo->marker_list; marker != NULL; marker = marker->next) {\n    if (option == JCOPYOPT_NONE)\n      continue;\n    else if (option == JCOPYOPT_COMMENTS) {\n      if (marker->marker != JPEG_COM)\n        continue;\n    } else if (option == JCOPYOPT_ALL_EXCEPT_ICC) {\n      if (marker->marker == JPEG_APP0 + 2)\n        continue;\n    } else if (option == JCOPYOPT_ICC) {\n      if (marker->marker != JPEG_APP0 + 2)\n        continue;\n    }\n    /* To avoid confusion, we do not output JFIF and Adobe APP14 markers if the\n     * encoder library already wrote one.\n     */\n    if (dstinfo->write_JFIF_header &&\n        marker->marker == JPEG_APP0 &&\n        marker->data_length >= 5 &&\n        marker->data[0] == 0x4A &&\n        marker->data[1] == 0x46 &&\n        marker->data[2] == 0x49 &&\n        marker->data[3] == 0x46 &&\n        marker->data[4] == 0)\n      continue;                 /* reject duplicate JFIF */\n    if (dstinfo->write_Adobe_marker &&\n        marker->marker == JPEG_APP0 + 14 &&\n        marker->data_length >= 5 &&\n        marker->data[0] == 0x41 &&\n        marker->data[1] == 0x64 &&\n        marker->data[2] == 0x6F &&\n        marker->data[3] == 0x62 &&\n        marker->data[4] == 0x65)\n      continue;                 /* reject duplicate Adobe */\n    jpeg_write_marker(dstinfo, marker->marker,\n                      marker->data, marker->data_length);\n  }\n}\n"
        },
        {
          "name": "transupp.h",
          "type": "blob",
          "size": 11.0830078125,
          "content": "/*\n * transupp.h\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1997-2019, Thomas G. Lane, Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2017, 2021, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains declarations for image transformation routines and\n * other utility code used by the jpegtran sample application.  These are\n * NOT part of the core JPEG library.  But we keep these routines separate\n * from jpegtran.c to ease the task of maintaining jpegtran-like programs\n * that have other user interfaces.\n *\n * NOTE: all the routines declared here have very specific requirements\n * about when they are to be executed during the reading and writing of the\n * source and destination files.  See the comments in transupp.c, or see\n * jpegtran.c for an example of correct usage.\n */\n\n#ifdef __cplusplus\n#ifndef DONT_USE_EXTERN_C\nextern \"C\" {\n#endif\n#endif\n\n/* If you happen not to want the image transform support, disable it here */\n#ifndef TRANSFORMS_SUPPORTED\n#define TRANSFORMS_SUPPORTED  1         /* 0 disables transform code */\n#endif\n\n/*\n * Although rotating and flipping data expressed as DCT coefficients is not\n * hard, there is an asymmetry in the JPEG format specification for images\n * whose dimensions aren't multiples of the iMCU size.  The right and bottom\n * image edges are padded out to the next iMCU boundary with junk data; but\n * no padding is possible at the top and left edges.  If we were to flip\n * the whole image including the pad data, then pad garbage would become\n * visible at the top and/or left, and real pixels would disappear into the\n * pad margins --- perhaps permanently, since encoders & decoders may not\n * bother to preserve DCT blocks that appear to be completely outside the\n * nominal image area.  So, we have to exclude any partial iMCUs from the\n * basic transformation.\n *\n * Transpose is the only transformation that can handle partial iMCUs at the\n * right and bottom edges completely cleanly.  flip_h can flip partial iMCUs\n * at the bottom, but leaves any partial iMCUs at the right edge untouched.\n * Similarly flip_v leaves any partial iMCUs at the bottom edge untouched.\n * The other transforms are defined as combinations of these basic transforms\n * and process edge blocks in a way that preserves the equivalence.\n *\n * The \"trim\" option causes untransformable partial iMCUs to be dropped;\n * this is not strictly lossless, but it usually gives the best-looking\n * result for odd-size images.  Note that when this option is active,\n * the expected mathematical equivalences between the transforms may not hold.\n * (For example, -rot 270 -trim trims only the bottom edge, but -rot 90 -trim\n * followed by -rot 180 -trim trims both edges.)\n *\n * We also offer a lossless-crop option, which discards data outside a given\n * image region but losslessly preserves what is inside.  Like the rotate and\n * flip transforms, lossless crop is restricted by the JPEG format: the upper\n * left corner of the selected region must fall on an iMCU boundary.  If this\n * does not hold for the given crop parameters, we silently move the upper left\n * corner up and/or left to make it so, simultaneously increasing the region\n * dimensions to keep the lower right crop corner unchanged.  (Thus, the\n * output image covers at least the requested region, but may cover more.)\n * The adjustment of the region dimensions may be optionally disabled.\n *\n * A complementary lossless wipe option is provided to discard (gray out) data\n * inside a given image region while losslessly preserving what is outside.\n * A lossless drop option is also provided, which allows another JPEG image to\n * be inserted (\"dropped\") into the source image data at a given position,\n * replacing the existing image data at that position.  Both the source image\n * and the drop image must have the same subsampling level.  It is best if they\n * also have the same quantization (quality.)  Otherwise, the quantization of\n * the output image will be adapted to accommodate the higher of the source\n * image quality and the drop image quality.  The trim option can be used with\n * the drop option to requantize the drop image to match the source image.\n *\n * We also provide a lossless-resize option, which is kind of a lossless-crop\n * operation in the DCT coefficient block domain - it discards higher-order\n * coefficients and losslessly preserves lower-order coefficients of a\n * sub-block.\n *\n * Rotate/flip transform, resize, and crop can be requested together in a\n * single invocation.  The crop is applied last --- that is, the crop region\n * is specified in terms of the destination image after transform/resize.\n *\n * We also offer a \"force to grayscale\" option, which simply discards the\n * chrominance channels of a YCbCr image.  This is lossless in the sense that\n * the luminance channel is preserved exactly.  It's not the same kind of\n * thing as the rotate/flip transformations, but it's convenient to handle it\n * as part of this package, mainly because the transformation routines have to\n * be aware of the option to know how many components to work on.\n */\n\n\n/*\n * Codes for supported types of image transformations.\n */\n\ntypedef enum {\n  JXFORM_NONE,            /* no transformation */\n  JXFORM_FLIP_H,          /* horizontal flip */\n  JXFORM_FLIP_V,          /* vertical flip */\n  JXFORM_TRANSPOSE,       /* transpose across UL-to-LR axis */\n  JXFORM_TRANSVERSE,      /* transpose across UR-to-LL axis */\n  JXFORM_ROT_90,          /* 90-degree clockwise rotation */\n  JXFORM_ROT_180,         /* 180-degree rotation */\n  JXFORM_ROT_270,         /* 270-degree clockwise (or 90 ccw) */\n  JXFORM_WIPE,            /* wipe */\n  JXFORM_DROP             /* drop */\n} JXFORM_CODE;\n\n/*\n * Codes for crop parameters, which can individually be unspecified,\n * positive or negative for xoffset or yoffset,\n * positive or force or reflect for width or height.\n */\n\ntypedef enum {\n  JCROP_UNSET,\n  JCROP_POS,\n  JCROP_NEG,\n  JCROP_FORCE,\n  JCROP_REFLECT\n} JCROP_CODE;\n\n/*\n * Transform parameters struct.\n * NB: application must not change any elements of this struct after\n * calling jtransform_request_workspace.\n */\n\ntypedef struct {\n  /* Options: set by caller */\n  JXFORM_CODE transform;        /* image transform operator */\n  boolean perfect;              /* if TRUE, fail if partial MCUs are requested */\n  boolean trim;                 /* if TRUE, trim partial MCUs as needed */\n  boolean force_grayscale;      /* if TRUE, convert color image to grayscale */\n  boolean crop;                 /* if TRUE, crop or wipe source image, or drop */\n  boolean slow_hflip;  /* For best performance, the JXFORM_FLIP_H transform\n                          normally modifies the source coefficients in place.\n                          Setting this to TRUE will instead use a slower,\n                          double-buffered algorithm, which leaves the source\n                          coefficients in tact (necessary if other transformed\n                          images must be generated from the same set of\n                          coefficients. */\n\n  /* Crop parameters: application need not set these unless crop is TRUE.\n   * These can be filled in by jtransform_parse_crop_spec().\n   */\n  JDIMENSION crop_width;        /* Width of selected region */\n  JCROP_CODE crop_width_set;    /* (force-disables adjustment) */\n  JDIMENSION crop_height;       /* Height of selected region */\n  JCROP_CODE crop_height_set;   /* (force-disables adjustment) */\n  JDIMENSION crop_xoffset;      /* X offset of selected region */\n  JCROP_CODE crop_xoffset_set;  /* (negative measures from right edge) */\n  JDIMENSION crop_yoffset;      /* Y offset of selected region */\n  JCROP_CODE crop_yoffset_set;  /* (negative measures from bottom edge) */\n\n  /* Drop parameters: set by caller for drop request */\n  j_decompress_ptr drop_ptr;\n  jvirt_barray_ptr *drop_coef_arrays;\n\n  /* Internal workspace: caller should not touch these */\n  int num_components;           /* # of components in workspace */\n  jvirt_barray_ptr *workspace_coef_arrays; /* workspace for transformations */\n  JDIMENSION output_width;      /* cropped destination dimensions */\n  JDIMENSION output_height;\n  JDIMENSION x_crop_offset;     /* destination crop offsets measured in iMCUs */\n  JDIMENSION y_crop_offset;\n  JDIMENSION drop_width;        /* drop/wipe dimensions measured in iMCUs */\n  JDIMENSION drop_height;\n  int iMCU_sample_width;        /* destination iMCU size */\n  int iMCU_sample_height;\n} jpeg_transform_info;\n\n\n#if TRANSFORMS_SUPPORTED\n\n/* Parse a crop specification (written in X11 geometry style) */\nEXTERN(boolean) jtransform_parse_crop_spec(jpeg_transform_info *info,\n                                           const char *spec);\n/* Request any required workspace */\nEXTERN(boolean) jtransform_request_workspace(j_decompress_ptr srcinfo,\n                                             jpeg_transform_info *info);\n/* Adjust output image parameters */\nEXTERN(jvirt_barray_ptr *) jtransform_adjust_parameters\n  (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,\n   jvirt_barray_ptr *src_coef_arrays, jpeg_transform_info *info);\n/* Execute the actual transformation, if any */\nEXTERN(void) jtransform_execute_transform(j_decompress_ptr srcinfo,\n                                          j_compress_ptr dstinfo,\n                                          jvirt_barray_ptr *src_coef_arrays,\n                                          jpeg_transform_info *info);\n/* Determine whether lossless transformation is perfectly\n * possible for a specified image and transformation.\n */\nEXTERN(boolean) jtransform_perfect_transform(JDIMENSION image_width,\n                                             JDIMENSION image_height,\n                                             int MCU_width, int MCU_height,\n                                             JXFORM_CODE transform);\n\n/* jtransform_execute_transform used to be called\n * jtransform_execute_transformation, but some compilers complain about\n * routine names that long.  This macro is here to avoid breaking any\n * old source code that uses the original name...\n */\n#define jtransform_execute_transformation       jtransform_execute_transform\n\n#endif /* TRANSFORMS_SUPPORTED */\n\n\n/*\n * Support for copying optional markers from source to destination file.\n */\n\ntypedef enum {\n  JCOPYOPT_NONE,           /* copy no optional markers */\n  JCOPYOPT_COMMENTS,       /* copy only comment (COM) markers */\n  JCOPYOPT_ALL,            /* copy all optional markers */\n  JCOPYOPT_ALL_EXCEPT_ICC, /* copy all optional markers except APP2 */\n  JCOPYOPT_ICC             /* copy only ICC profile (APP2) markers */\n} JCOPY_OPTION;\n\n#define JCOPYOPT_DEFAULT  JCOPYOPT_COMMENTS     /* recommended default */\n\n/* Setup decompression object to save desired markers in memory */\nEXTERN(void) jcopy_markers_setup(j_decompress_ptr srcinfo,\n                                 JCOPY_OPTION option);\n/* Copy markers saved in the given source object to the destination object */\nEXTERN(void) jcopy_markers_execute(j_decompress_ptr srcinfo,\n                                   j_compress_ptr dstinfo,\n                                   JCOPY_OPTION option);\n\n#ifdef __cplusplus\n#ifndef DONT_USE_EXTERN_C\n}\n#endif\n#endif\n"
        },
        {
          "name": "turbojpeg-jni.c",
          "type": "blob",
          "size": 52.0419921875,
          "content": "/*\n * Copyright (C)2011-2024 D. R. Commander.  All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <limits.h>\n#include \"turbojpeg.h\"\n#include \"jinclude.h\"\n#include <jni.h>\n#include \"java/org_libjpegturbo_turbojpeg_TJCompressor.h\"\n#include \"java/org_libjpegturbo_turbojpeg_TJDecompressor.h\"\n#include \"java/org_libjpegturbo_turbojpeg_TJTransformer.h\"\n#include \"java/org_libjpegturbo_turbojpeg_TJ.h\"\n\n#define BAILIF0(f) { \\\n  if (!(f) || (*env)->ExceptionCheck(env)) { \\\n    goto bailout; \\\n  } \\\n}\n\n#define BAILIF0NOEC(f) { \\\n  if (!(f)) { \\\n    goto bailout; \\\n  } \\\n}\n\n#define THROW(msg, exceptionClass) { \\\n  jclass _exccls = (*env)->FindClass(env, exceptionClass); \\\n  \\\n  BAILIF0(_exccls); \\\n  (*env)->ThrowNew(env, _exccls, msg); \\\n  goto bailout; \\\n}\n\n#define THROW_TJ() { \\\n  jclass _exccls; \\\n  jmethodID _excid; \\\n  jobject _excobj; \\\n  jstring _errstr; \\\n  \\\n  BAILIF0(_errstr = (*env)->NewStringUTF(env, tj3GetErrorStr(handle))); \\\n  BAILIF0(_exccls = (*env)->FindClass(env, \\\n    \"org/libjpegturbo/turbojpeg/TJException\")); \\\n  BAILIF0(_excid = (*env)->GetMethodID(env, _exccls, \"<init>\", \\\n                                       \"(Ljava/lang/String;I)V\")); \\\n  BAILIF0(_excobj = (*env)->NewObject(env, _exccls, _excid, _errstr, \\\n                                      tj3GetErrorCode(handle))); \\\n  (*env)->Throw(env, _excobj); \\\n  goto bailout; \\\n}\n\n#define THROW_ARG(msg)  THROW(msg, \"java/lang/IllegalArgumentException\")\n\n#define THROW_MEM() \\\n  THROW(\"Memory allocation failure\", \"java/lang/OutOfMemoryError\");\n\n#define GET_HANDLE() \\\n  jclass _cls = (*env)->GetObjectClass(env, obj); \\\n  jfieldID _fid; \\\n  \\\n  BAILIF0(_cls); \\\n  BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"handle\", \"J\")); \\\n  handle = (tjhandle)(size_t)(*env)->GetLongField(env, obj, _fid);\n\n#define SAFE_RELEASE(javaArray, cArray) { \\\n  if (javaArray && cArray) \\\n    (*env)->ReleasePrimitiveArrayCritical(env, javaArray, (void *)cArray, 0); \\\n  cArray = NULL; \\\n}\n\n#define PAD(v, p)  ((v + (p) - 1) & (~((p) - 1)))\n\n/* TurboJPEG 1.2.x: TJ.bufSize() */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJ_bufSize\n  (JNIEnv *env, jclass cls, jint width, jint height, jint jpegSubsamp)\n{\n  size_t retval = tj3JPEGBufSize(width, height, jpegSubsamp);\n\n  if (retval == 0) THROW_ARG(tj3GetErrorStr(NULL));\n  if (retval > (size_t)INT_MAX)\n    THROW_ARG(\"Image is too large\");\n\nbailout:\n  return (jint)retval;\n}\n\n/* TurboJPEG 1.4.x: TJ.bufSizeYUV() */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJ_bufSizeYUV__IIII\n  (JNIEnv *env, jclass cls, jint width, jint align, jint height, jint subsamp)\n{\n  size_t retval = tj3YUVBufSize(width, align, height, subsamp);\n\n  if (retval == 0) THROW_ARG(tj3GetErrorStr(NULL));\n  if (retval > (size_t)INT_MAX)\n    THROW_ARG(\"Image is too large\");\n\nbailout:\n  return (jint)retval;\n}\n\n/* TurboJPEG 1.4.x: TJ.planeSizeYUV() */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJ_planeSizeYUV__IIIII\n  (JNIEnv *env, jclass cls, jint componentID, jint width, jint stride,\n   jint height, jint subsamp)\n{\n  size_t retval = tj3YUVPlaneSize(componentID, width, stride, height, subsamp);\n\n  if (retval == 0) THROW_ARG(tj3GetErrorStr(NULL));\n  if (retval > (size_t)INT_MAX)\n    THROW_ARG(\"Image is too large\");\n\nbailout:\n  return (jint)retval;\n}\n\n/* TurboJPEG 1.4.x: TJ.planeWidth() */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJ_planeWidth__III\n  (JNIEnv *env, jclass cls, jint componentID, jint width, jint subsamp)\n{\n  jint retval = (jint)tj3YUVPlaneWidth(componentID, width, subsamp);\n\n  if (retval == 0) THROW_ARG(tj3GetErrorStr(NULL));\n\nbailout:\n  return retval;\n}\n\n/* TurboJPEG 1.4.x: TJ.planeHeight() */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJ_planeHeight__III\n  (JNIEnv *env, jclass cls, jint componentID, jint height, jint subsamp)\n{\n  jint retval = (jint)tj3YUVPlaneHeight(componentID, height, subsamp);\n\n  if (retval == 0) THROW_ARG(tj3GetErrorStr(NULL));\n\nbailout:\n  return retval;\n}\n\n/* TurboJPEG 1.2.x: TJCompressor.init() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_init\n  (JNIEnv *env, jobject obj)\n{\n  jclass cls;\n  jfieldID fid;\n  tjhandle handle;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL)\n    THROW(tj3GetErrorStr(NULL), \"org/libjpegturbo/turbojpeg/TJException\");\n\n  BAILIF0(cls = (*env)->GetObjectClass(env, obj));\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"handle\", \"J\"));\n  (*env)->SetLongField(env, obj, fid, (size_t)handle);\n\nbailout:\n  return;\n}\n\n/* TurboJPEG 3: TJCompressor.set() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_set\n  (JNIEnv *env, jobject obj, jint param, jint value)\n{\n  tjhandle handle = 0;\n\n  GET_HANDLE();\n\n  if (tj3Set(handle, param, value) == -1)\n    THROW_TJ();\n\nbailout:\n  return;\n}\n\n/* TurboJPEG 3: TJCompressor.get() */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_get\n  (JNIEnv *env, jobject obj, jint param)\n{\n  tjhandle handle = 0;\n\n  GET_HANDLE();\n\n  return tj3Get(handle, param);\n\nbailout:\n  return -1;\n}\n\nstatic jint TJCompressor_compress\n  (JNIEnv *env, jobject obj, jarray src, jint srcElementSize, jint precision,\n   jint x, jint y, jint width, jint pitch, jint height, jint pf,\n   jbyteArray dst)\n{\n  tjhandle handle = 0;\n  size_t jpegSize = 0;\n  jsize arraySize = 0, actualPitch;\n  void *srcBuf = NULL;\n  unsigned char *jpegBuf = NULL;\n  int jpegSubsamp;\n\n  GET_HANDLE();\n\n  if (pf < 0 || pf >= org_libjpegturbo_turbojpeg_TJ_NUMPF || width < 1 ||\n      height < 1 || pitch < 0)\n    THROW_ARG(\"Invalid argument in compress*()\");\n  if (org_libjpegturbo_turbojpeg_TJ_NUMPF != TJ_NUMPF)\n    THROW_ARG(\"Mismatch between Java and C API\");\n\n  actualPitch = (pitch == 0) ? width * tjPixelSize[pf] : pitch;\n  arraySize = (y + height - 1) * actualPitch + (x + width) * tjPixelSize[pf];\n  if ((*env)->GetArrayLength(env, src) * srcElementSize < arraySize)\n    THROW_ARG(\"Source buffer is not large enough\");\n  jpegSubsamp = tj3Get(handle, TJPARAM_SUBSAMP);\n  if (tj3Get(handle, TJPARAM_LOSSLESS) && jpegSubsamp != TJSAMP_GRAY)\n    jpegSubsamp = TJSAMP_444;\n  else if (jpegSubsamp == TJSAMP_UNKNOWN)\n    THROW_ARG(\"TJPARAM_SUBSAMP must be specified\");\n  jpegSize = tj3JPEGBufSize(width, height, jpegSubsamp);\n  if ((*env)->GetArrayLength(env, dst) < (jsize)jpegSize)\n    THROW_ARG(\"Destination buffer is not large enough\");\n\n  if (tj3Set(handle, TJPARAM_NOREALLOC, 1) == -1)\n    THROW_TJ();\n\n  BAILIF0NOEC(srcBuf = (*env)->GetPrimitiveArrayCritical(env, src, 0));\n  BAILIF0NOEC(jpegBuf = (*env)->GetPrimitiveArrayCritical(env, dst, 0));\n\n  if (precision == 8) {\n    if (tj3Compress8(handle, &((unsigned char *)srcBuf)[y * actualPitch +\n                                                        x * tjPixelSize[pf]],\n                     width, pitch, height, pf, &jpegBuf, &jpegSize) == -1) {\n      SAFE_RELEASE(dst, jpegBuf);\n      SAFE_RELEASE(src, srcBuf);\n      THROW_TJ();\n    }\n  } else if (precision == 12) {\n    if (tj3Compress12(handle, &((short *)srcBuf)[y * actualPitch +\n                                                 x * tjPixelSize[pf]],\n                      width, pitch, height, pf, &jpegBuf, &jpegSize) == -1) {\n      SAFE_RELEASE(dst, jpegBuf);\n      SAFE_RELEASE(src, srcBuf);\n      THROW_TJ();\n    }\n  } else {\n    if (tj3Compress16(handle, &((unsigned short *)srcBuf)[y * actualPitch +\n                                                          x * tjPixelSize[pf]],\n                      width, pitch, height, pf, &jpegBuf, &jpegSize) == -1) {\n      SAFE_RELEASE(dst, jpegBuf);\n      SAFE_RELEASE(src, srcBuf);\n      THROW_TJ();\n    }\n  }\n\nbailout:\n  SAFE_RELEASE(dst, jpegBuf);\n  SAFE_RELEASE(src, srcBuf);\n  return (jint)jpegSize;\n}\n\n/* TurboJPEG 3: TJCompressor.compress8() byte source */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_compress8___3BIIIIII_3B\n  (JNIEnv *env, jobject obj, jbyteArray src, jint x, jint y, jint width,\n   jint pitch, jint height, jint pf, jbyteArray dst)\n{\n  return TJCompressor_compress(env, obj, src, 1, 8, x, y, width, pitch, height,\n                               pf, dst);\n}\n\n/* TurboJPEG 3: TJCompressor.compress12() */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_compress12\n  (JNIEnv *env, jobject obj, jshortArray src, jint x, jint y, jint width,\n   jint pitch, jint height, jint pf, jbyteArray dst)\n{\n  return TJCompressor_compress(env, obj, src, 1, 12, x, y, width, pitch,\n                               height, pf, dst);\n}\n\n/* TurboJPEG 3: TJCompressor.compress16() */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_compress16\n  (JNIEnv *env, jobject obj, jshortArray src, jint x, jint y, jint width,\n   jint pitch, jint height, jint pf, jbyteArray dst)\n{\n  return TJCompressor_compress(env, obj, src, 1, 16, x, y, width, pitch,\n                               height, pf, dst);\n}\n\n/* TurboJPEG 3: TJCompressor.compress8() int source */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_compress8___3IIIIIII_3B\n  (JNIEnv *env, jobject obj, jintArray src, jint x, jint y, jint width,\n   jint stride, jint height, jint pf, jbyteArray dst)\n{\n  if (pf < 0 || pf >= org_libjpegturbo_turbojpeg_TJ_NUMPF)\n    THROW_ARG(\"Invalid argument in compress8()\");\n  if (tjPixelSize[pf] != sizeof(jint))\n    THROW_ARG(\"Pixel format must be 32-bit when compressing from an integer buffer.\");\n\n  return TJCompressor_compress(env, obj, src, sizeof(jint), 8, x, y, width,\n                               stride * sizeof(jint), height, pf, dst);\n\nbailout:\n  return 0;\n}\n\n/* TurboJPEG 3: TJCompressor.compressFromYUV8() */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_compressFromYUV8\n  (JNIEnv *env, jobject obj, jobjectArray srcobjs, jintArray jSrcOffsets,\n   jint width, jintArray jSrcStrides, jint height, jbyteArray dst)\n{\n  tjhandle handle = 0;\n  size_t jpegSize = 0;\n  jbyteArray jSrcPlanes[3] = { NULL, NULL, NULL };\n  const unsigned char *srcPlanesTmp[3] = { NULL, NULL, NULL };\n  const unsigned char *srcPlanes[3] = { NULL, NULL, NULL };\n  jint srcOffsetsTmp[3] = { 0, 0, 0 }, srcStridesTmp[3] = { 0, 0, 0 };\n  int srcOffsets[3] = { 0, 0, 0 }, srcStrides[3] = { 0, 0, 0 };\n  unsigned char *jpegBuf = NULL;\n  int nc = 0, i, subsamp;\n\n  GET_HANDLE();\n\n  if (org_libjpegturbo_turbojpeg_TJ_NUMSAMP != TJ_NUMSAMP)\n    THROW_ARG(\"Mismatch between Java and C API\");\n\n  if ((subsamp = tj3Get(handle, TJPARAM_SUBSAMP)) == TJSAMP_UNKNOWN)\n    THROW_ARG(\"TJPARAM_SUBSAMP must be specified\");\n  nc = subsamp == TJSAMP_GRAY ? 1 : 3;\n  if ((*env)->GetArrayLength(env, srcobjs) < nc)\n    THROW_ARG(\"Planes array is too small for the subsampling type\");\n  if ((*env)->GetArrayLength(env, jSrcOffsets) < nc)\n    THROW_ARG(\"Offsets array is too small for the subsampling type\");\n  if ((*env)->GetArrayLength(env, jSrcStrides) < nc)\n    THROW_ARG(\"Strides array is too small for the subsampling type\");\n\n  jpegSize = tj3JPEGBufSize(width, height, subsamp);\n  if ((*env)->GetArrayLength(env, dst) < (jsize)jpegSize)\n    THROW_ARG(\"Destination buffer is not large enough\");\n\n  if (tj3Set(handle, TJPARAM_NOREALLOC, 1) == -1)\n    THROW_TJ();\n\n  (*env)->GetIntArrayRegion(env, jSrcOffsets, 0, nc, srcOffsetsTmp);\n  if ((*env)->ExceptionCheck(env)) goto bailout;\n  for (i = 0; i < 3; i++)\n    srcOffsets[i] = srcOffsetsTmp[i];\n\n  (*env)->GetIntArrayRegion(env, jSrcStrides, 0, nc, srcStridesTmp);\n  if ((*env)->ExceptionCheck(env)) goto bailout;\n  for (i = 0; i < 3; i++)\n    srcStrides[i] = srcStridesTmp[i];\n\n  for (i = 0; i < nc; i++) {\n    size_t planeSize = tj3YUVPlaneSize(i, width, srcStrides[i], height,\n                                       subsamp);\n    int pw = tj3YUVPlaneWidth(i, width, subsamp);\n\n    if (planeSize == 0 || pw == 0)\n      THROW_ARG(tj3GetErrorStr(NULL));\n\n    if (planeSize > (size_t)INT_MAX)\n      THROW_ARG(\"Source plane is too large\");\n    if (srcOffsets[i] < 0)\n      THROW_ARG(\"Invalid argument in compressFromYUV8()\");\n    if (srcStrides[i] < 0 && srcOffsets[i] - (int)planeSize + pw < 0)\n      THROW_ARG(\"Negative plane stride would cause memory to be accessed below plane boundary\");\n\n    BAILIF0(jSrcPlanes[i] = (*env)->GetObjectArrayElement(env, srcobjs, i));\n    if ((*env)->GetArrayLength(env, jSrcPlanes[i]) <\n        srcOffsets[i] + (int)planeSize)\n      THROW_ARG(\"Source plane is not large enough\");\n  }\n  for (i = 0; i < nc; i++) {\n    BAILIF0NOEC(srcPlanesTmp[i] =\n                (*env)->GetPrimitiveArrayCritical(env, jSrcPlanes[i], 0));\n    srcPlanes[i] = &srcPlanesTmp[i][srcOffsets[i]];\n  }\n  BAILIF0NOEC(jpegBuf = (*env)->GetPrimitiveArrayCritical(env, dst, 0));\n\n  if (tj3CompressFromYUVPlanes8(handle, srcPlanes, width, srcStrides, height,\n                                &jpegBuf, &jpegSize) == -1) {\n    SAFE_RELEASE(dst, jpegBuf);\n    for (i = 0; i < nc; i++)\n      SAFE_RELEASE(jSrcPlanes[i], srcPlanesTmp[i]);\n    THROW_TJ();\n  }\n\nbailout:\n  SAFE_RELEASE(dst, jpegBuf);\n  for (i = 0; i < nc; i++)\n    SAFE_RELEASE(jSrcPlanes[i], srcPlanesTmp[i]);\n  return (jint)jpegSize;\n}\n\nstatic void TJCompressor_encodeYUV8\n  (JNIEnv *env, jobject obj, jarray src, jint srcElementSize, jint x, jint y,\n   jint width, jint pitch, jint height, jint pf, jobjectArray dstobjs,\n   jintArray jDstOffsets, jintArray jDstStrides)\n{\n  tjhandle handle = 0;\n  jsize arraySize = 0, actualPitch;\n  unsigned char *srcBuf = NULL;\n  jbyteArray jDstPlanes[3] = { NULL, NULL, NULL };\n  unsigned char *dstPlanesTmp[3] = { NULL, NULL, NULL };\n  unsigned char *dstPlanes[3] = { NULL, NULL, NULL };\n  jint dstOffsetsTmp[3] = { 0, 0, 0 }, dstStridesTmp[3] = { 0, 0, 0 };\n  int dstOffsets[3] = { 0, 0, 0 }, dstStrides[3] = { 0, 0, 0 };\n  int nc = 0, i, subsamp;\n\n  GET_HANDLE();\n\n  if (pf < 0 || pf >= org_libjpegturbo_turbojpeg_TJ_NUMPF || width < 1 ||\n      height < 1 || pitch < 0)\n    THROW_ARG(\"Invalid argument in encodeYUV8()\");\n  if (org_libjpegturbo_turbojpeg_TJ_NUMPF != TJ_NUMPF ||\n      org_libjpegturbo_turbojpeg_TJ_NUMSAMP != TJ_NUMSAMP)\n    THROW_ARG(\"Mismatch between Java and C API\");\n\n  if ((subsamp = tj3Get(handle, TJPARAM_SUBSAMP)) == TJSAMP_UNKNOWN)\n    THROW_ARG(\"TJPARAM_SUBSAMP must be specified\");\n  nc = subsamp == TJSAMP_GRAY ? 1 : 3;\n  if ((*env)->GetArrayLength(env, dstobjs) < nc)\n    THROW_ARG(\"Planes array is too small for the subsampling type\");\n  if ((*env)->GetArrayLength(env, jDstOffsets) < nc)\n    THROW_ARG(\"Offsets array is too small for the subsampling type\");\n  if ((*env)->GetArrayLength(env, jDstStrides) < nc)\n    THROW_ARG(\"Strides array is too small for the subsampling type\");\n\n  actualPitch = (pitch == 0) ? width * tjPixelSize[pf] : pitch;\n  arraySize = (y + height - 1) * actualPitch + (x + width) * tjPixelSize[pf];\n  if ((*env)->GetArrayLength(env, src) * srcElementSize < arraySize)\n    THROW_ARG(\"Source buffer is not large enough\");\n\n  (*env)->GetIntArrayRegion(env, jDstOffsets, 0, nc, dstOffsetsTmp);\n  if ((*env)->ExceptionCheck(env)) goto bailout;\n  for (i = 0; i < 3; i++)\n    dstOffsets[i] = dstOffsetsTmp[i];\n\n  (*env)->GetIntArrayRegion(env, jDstStrides, 0, nc, dstStridesTmp);\n  if ((*env)->ExceptionCheck(env)) goto bailout;\n  for (i = 0; i < 3; i++)\n    dstStrides[i] = dstStridesTmp[i];\n\n  for (i = 0; i < nc; i++) {\n    size_t planeSize = tj3YUVPlaneSize(i, width, dstStrides[i], height,\n                                       subsamp);\n    int pw = tj3YUVPlaneWidth(i, width, subsamp);\n\n    if (planeSize == 0 || pw == 0)\n      THROW_ARG(tj3GetErrorStr(NULL));\n\n    if (planeSize > (size_t)INT_MAX)\n      THROW_ARG(\"Destination plane is too large\");\n    if (dstOffsets[i] < 0)\n      THROW_ARG(\"Invalid argument in encodeYUV8()\");\n    if (dstStrides[i] < 0 && dstOffsets[i] - (int)planeSize + pw < 0)\n      THROW_ARG(\"Negative plane stride would cause memory to be accessed below plane boundary\");\n\n    BAILIF0(jDstPlanes[i] = (*env)->GetObjectArrayElement(env, dstobjs, i));\n    if ((*env)->GetArrayLength(env, jDstPlanes[i]) <\n        dstOffsets[i] + (int)planeSize)\n      THROW_ARG(\"Destination plane is not large enough\");\n  }\n  for (i = 0; i < nc; i++) {\n    BAILIF0NOEC(dstPlanesTmp[i] =\n                (*env)->GetPrimitiveArrayCritical(env, jDstPlanes[i], 0));\n    dstPlanes[i] = &dstPlanesTmp[i][dstOffsets[i]];\n  }\n  BAILIF0NOEC(srcBuf = (*env)->GetPrimitiveArrayCritical(env, src, 0));\n\n  if (tj3EncodeYUVPlanes8(handle,\n                          &srcBuf[y * actualPitch + x * tjPixelSize[pf]],\n                          width, pitch, height, pf, dstPlanes,\n                          dstStrides) == -1) {\n    SAFE_RELEASE(src, srcBuf);\n    for (i = 0; i < nc; i++)\n      SAFE_RELEASE(jDstPlanes[i], dstPlanesTmp[i]);\n    THROW_TJ();\n  }\n\nbailout:\n  SAFE_RELEASE(src, srcBuf);\n  for (i = 0; i < nc; i++)\n    SAFE_RELEASE(jDstPlanes[i], dstPlanesTmp[i]);\n}\n\n/* TurboJPEG 3: TJCompressor.encodeYUV8() byte source */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_encodeYUV8___3BIIIIII_3_3B_3I_3I\n  (JNIEnv *env, jobject obj, jbyteArray src, jint x, jint y, jint width,\n   jint pitch, jint height, jint pf, jobjectArray dstobjs,\n   jintArray jDstOffsets, jintArray jDstStrides)\n{\n  TJCompressor_encodeYUV8(env, obj, src, 1, x, y, width, pitch, height, pf,\n                          dstobjs, jDstOffsets, jDstStrides);\n}\n\n/* TurboJPEG 3: TJCompressor.encodeYUV8() int source */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_encodeYUV8___3IIIIIII_3_3B_3I_3I\n  (JNIEnv *env, jobject obj, jintArray src, jint x, jint y, jint width,\n   jint stride, jint height, jint pf, jobjectArray dstobjs,\n   jintArray jDstOffsets, jintArray jDstStrides)\n{\n  if (pf < 0 || pf >= org_libjpegturbo_turbojpeg_TJ_NUMPF)\n    THROW_ARG(\"Invalid argument in encodeYUV8()\");\n  if (tjPixelSize[pf] != sizeof(jint))\n    THROW_ARG(\"Pixel format must be 32-bit when encoding from an integer buffer.\");\n\n  TJCompressor_encodeYUV8(env, obj, src, sizeof(jint), x, y, width,\n                          stride * sizeof(jint), height, pf, dstobjs,\n                          jDstOffsets, jDstStrides);\n\nbailout:\n  return;\n}\n\n/* TurboJPEG 1.2.x: TJCompressor.destroy() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_destroy\n  (JNIEnv *env, jobject obj)\n{\n  tjhandle handle = 0;\n\n  GET_HANDLE();\n\n  tj3Destroy(handle);\n  (*env)->SetLongField(env, obj, _fid, 0);\n\nbailout:\n  return;\n}\n\n/* TurboJPEG 1.2.x: TJDecompressor.init() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_init\n  (JNIEnv *env, jobject obj)\n{\n  jclass cls;\n  jfieldID fid;\n  tjhandle handle;\n\n  if ((handle = tj3Init(TJINIT_DECOMPRESS)) == NULL)\n    THROW(tj3GetErrorStr(NULL), \"org/libjpegturbo/turbojpeg/TJException\");\n\n  BAILIF0(cls = (*env)->GetObjectClass(env, obj));\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"handle\", \"J\"));\n  (*env)->SetLongField(env, obj, fid, (size_t)handle);\n\nbailout:\n  return;\n}\n\n/* TurboJPEG 3: TJDecompressor.set() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_set\n  (JNIEnv *env, jobject obj, jint param, jint value)\n{\n  Java_org_libjpegturbo_turbojpeg_TJCompressor_set(env, obj, param, value);\n}\n\n/* TurboJPEG 3: TJDecompressor.get() */\nJNIEXPORT jint JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_get\n  (JNIEnv *env, jobject obj, jint param)\n{\n  return Java_org_libjpegturbo_turbojpeg_TJCompressor_get(env, obj, param);\n}\n\n/* TurboJPEG 1.2.x: TJDecompressor.getScalingFactors() */\nJNIEXPORT jobjectArray JNICALL Java_org_libjpegturbo_turbojpeg_TJ_getScalingFactors\n  (JNIEnv *env, jclass cls)\n{\n  jclass sfcls = NULL;\n  jfieldID fid = 0;\n  tjscalingfactor *sf = NULL;\n  int n = 0, i;\n  jobject sfobj = NULL;\n  jobjectArray sfjava = NULL;\n\n  if ((sf = tj3GetScalingFactors(&n)) == NULL || n == 0)\n    THROW_ARG(tj3GetErrorStr(NULL));\n\n  BAILIF0(sfcls = (*env)->FindClass(env,\n    \"org/libjpegturbo/turbojpeg/TJScalingFactor\"));\n  BAILIF0(sfjava = (jobjectArray)(*env)->NewObjectArray(env, n, sfcls, 0));\n\n  for (i = 0; i < n; i++) {\n    BAILIF0(sfobj = (*env)->AllocObject(env, sfcls));\n    BAILIF0(fid = (*env)->GetFieldID(env, sfcls, \"num\", \"I\"));\n    (*env)->SetIntField(env, sfobj, fid, sf[i].num);\n    BAILIF0(fid = (*env)->GetFieldID(env, sfcls, \"denom\", \"I\"));\n    (*env)->SetIntField(env, sfobj, fid, sf[i].denom);\n    (*env)->SetObjectArrayElement(env, sfjava, i, sfobj);\n  }\n\nbailout:\n  return sfjava;\n}\n\n/* TurboJPEG 1.2.x: TJDecompressor.decompressHeader() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompressHeader\n  (JNIEnv *env, jobject obj, jbyteArray src, jint jpegSize)\n{\n  tjhandle handle = 0;\n  unsigned char *jpegBuf = NULL;\n\n  GET_HANDLE();\n\n  if ((*env)->GetArrayLength(env, src) < jpegSize)\n    THROW_ARG(\"Source buffer is not large enough\");\n\n  BAILIF0NOEC(jpegBuf = (*env)->GetPrimitiveArrayCritical(env, src, 0));\n\n  if (tj3DecompressHeader(handle, jpegBuf, (size_t)jpegSize) == -1) {\n    SAFE_RELEASE(src, jpegBuf);\n    THROW_TJ();\n  }\n\nbailout:\n  SAFE_RELEASE(src, jpegBuf);\n}\n\n/* TurboJPEG 3: TJDecompressor.setCroppingRegion() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_setCroppingRegion\n  (JNIEnv *env, jobject obj)\n{\n  tjhandle handle = 0;\n  jclass sfcls, crcls;\n  jobject sfobj, crobj;\n  tjregion croppingRegion;\n  tjscalingfactor scalingFactor;\n\n  GET_HANDLE();\n\n  BAILIF0(sfcls = (*env)->FindClass(env,\n    \"org/libjpegturbo/turbojpeg/TJScalingFactor\"));\n  BAILIF0(_fid =\n          (*env)->GetFieldID(env, _cls, \"scalingFactor\",\n                             \"Lorg/libjpegturbo/turbojpeg/TJScalingFactor;\"));\n  BAILIF0(sfobj = (*env)->GetObjectField(env, obj, _fid));\n  BAILIF0(_fid = (*env)->GetFieldID(env, sfcls, \"num\", \"I\"));\n  scalingFactor.num = (*env)->GetIntField(env, sfobj, _fid);\n  BAILIF0(_fid = (*env)->GetFieldID(env, sfcls, \"denom\", \"I\"));\n  scalingFactor.denom = (*env)->GetIntField(env, sfobj, _fid);\n\n  if (tj3SetScalingFactor(handle, scalingFactor) == -1)\n    THROW_TJ();\n\n  BAILIF0(crcls = (*env)->FindClass(env, \"java/awt/Rectangle\"));\n  BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"croppingRegion\",\n                                    \"Ljava/awt/Rectangle;\"));\n  BAILIF0(crobj = (*env)->GetObjectField(env, obj, _fid));\n  BAILIF0(_fid = (*env)->GetFieldID(env, crcls, \"x\", \"I\"));\n  croppingRegion.x = (*env)->GetIntField(env, crobj, _fid);\n  BAILIF0(_fid = (*env)->GetFieldID(env, crcls, \"y\", \"I\"));\n  croppingRegion.y = (*env)->GetIntField(env, crobj, _fid);\n  BAILIF0(_fid = (*env)->GetFieldID(env, crcls, \"width\", \"I\"));\n  croppingRegion.w = (*env)->GetIntField(env, crobj, _fid);\n  BAILIF0(_fid = (*env)->GetFieldID(env, crcls, \"height\", \"I\"));\n  croppingRegion.h = (*env)->GetIntField(env, crobj, _fid);\n\n  if (tj3SetCroppingRegion(handle, croppingRegion) == -1)\n    THROW_TJ();\n\nbailout:\n  return;\n}\n\nstatic void TJDecompressor_decompress\n  (JNIEnv *env, jobject obj, jbyteArray src, jint jpegSize, jarray dst,\n   jint dstElementSize, int precision, jint x, jint y, jint pitch, jint pf)\n{\n  tjhandle handle = 0;\n  jsize arraySize = 0, actualPitch;\n  unsigned char *jpegBuf = NULL;\n  void *dstBuf = NULL;\n  jclass sfcls, crcls;\n  jobject sfobj, crobj;\n  tjscalingfactor scalingFactor;\n  tjregion cr;\n  int jpegWidth, jpegHeight, scaledWidth, scaledHeight;\n\n  GET_HANDLE();\n\n  if (pf < 0 || pf >= org_libjpegturbo_turbojpeg_TJ_NUMPF)\n    THROW_ARG(\"Invalid argument in decompress*()\");\n  if (org_libjpegturbo_turbojpeg_TJ_NUMPF != TJ_NUMPF)\n    THROW_ARG(\"Mismatch between Java and C API\");\n\n  if ((*env)->GetArrayLength(env, src) < jpegSize)\n    THROW_ARG(\"Source buffer is not large enough\");\n  if ((jpegWidth = tj3Get(handle, TJPARAM_JPEGWIDTH)) == -1)\n    THROW_ARG(\"JPEG header has not yet been read\");\n  if ((jpegHeight = tj3Get(handle, TJPARAM_JPEGHEIGHT)) == -1)\n    THROW_ARG(\"JPEG header has not yet been read\");\n\n  BAILIF0(sfcls = (*env)->FindClass(env,\n    \"org/libjpegturbo/turbojpeg/TJScalingFactor\"));\n  BAILIF0(_fid =\n          (*env)->GetFieldID(env, _cls, \"scalingFactor\",\n                             \"Lorg/libjpegturbo/turbojpeg/TJScalingFactor;\"));\n  BAILIF0(sfobj = (*env)->GetObjectField(env, obj, _fid));\n  BAILIF0(_fid = (*env)->GetFieldID(env, sfcls, \"num\", \"I\"));\n  scalingFactor.num = (*env)->GetIntField(env, sfobj, _fid);\n  BAILIF0(_fid = (*env)->GetFieldID(env, sfcls, \"denom\", \"I\"));\n  scalingFactor.denom = (*env)->GetIntField(env, sfobj, _fid);\n\n  if (tj3SetScalingFactor(handle, scalingFactor) == -1)\n    THROW_TJ();\n  scaledWidth = TJSCALED(jpegWidth, scalingFactor);\n  scaledHeight = TJSCALED(jpegHeight, scalingFactor);\n\n  BAILIF0(crcls = (*env)->FindClass(env, \"java/awt/Rectangle\"));\n  BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"croppingRegion\",\n                                    \"Ljava/awt/Rectangle;\"));\n  BAILIF0(crobj = (*env)->GetObjectField(env, obj, _fid));\n  BAILIF0(_fid = (*env)->GetFieldID(env, crcls, \"x\", \"I\"));\n  cr.x = (*env)->GetIntField(env, crobj, _fid);\n  BAILIF0(_fid = (*env)->GetFieldID(env, crcls, \"y\", \"I\"));\n  cr.y = (*env)->GetIntField(env, crobj, _fid);\n  BAILIF0(_fid = (*env)->GetFieldID(env, crcls, \"width\", \"I\"));\n  cr.w = (*env)->GetIntField(env, crobj, _fid);\n  BAILIF0(_fid = (*env)->GetFieldID(env, crcls, \"height\", \"I\"));\n  cr.h = (*env)->GetIntField(env, crobj, _fid);\n  if (cr.x != 0 || cr.y != 0 || cr.w != 0 || cr.h != 0) {\n    scaledWidth = cr.w ? cr.w : scaledWidth - cr.x;\n    scaledHeight = cr.h ? cr.h : scaledHeight - cr.y;\n  }\n\n  actualPitch = (pitch == 0) ? scaledWidth * tjPixelSize[pf] : pitch;\n  arraySize = (y + scaledHeight - 1) * actualPitch +\n              (x + scaledWidth) * tjPixelSize[pf];\n  if ((*env)->GetArrayLength(env, dst) * dstElementSize < arraySize)\n    THROW_ARG(\"Destination buffer is not large enough\");\n\n  BAILIF0NOEC(jpegBuf = (*env)->GetPrimitiveArrayCritical(env, src, 0));\n  BAILIF0NOEC(dstBuf = (*env)->GetPrimitiveArrayCritical(env, dst, 0));\n\n  if (precision == 8) {\n    if (tj3Decompress8(handle, jpegBuf, (size_t)jpegSize,\n                       &((unsigned char *)dstBuf)[y * actualPitch +\n                                                  x * tjPixelSize[pf]],\n                       pitch, pf) == -1) {\n      SAFE_RELEASE(dst, dstBuf);\n      SAFE_RELEASE(src, jpegBuf);\n      THROW_TJ();\n    }\n  } else if (precision == 12) {\n    if (tj3Decompress12(handle, jpegBuf, (size_t)jpegSize,\n                        &((short *)dstBuf)[y * actualPitch +\n                                           x * tjPixelSize[pf]],\n                        pitch, pf) == -1) {\n      SAFE_RELEASE(dst, dstBuf);\n      SAFE_RELEASE(src, jpegBuf);\n      THROW_TJ();\n    }\n  } else {\n    if (tj3Decompress16(handle, jpegBuf, (size_t)jpegSize,\n                        &((unsigned short *)dstBuf)[y * actualPitch +\n                                                    x * tjPixelSize[pf]],\n                        pitch, pf) == -1) {\n      SAFE_RELEASE(dst, dstBuf);\n      SAFE_RELEASE(src, jpegBuf);\n      THROW_TJ();\n    }\n  }\n\nbailout:\n  SAFE_RELEASE(dst, dstBuf);\n  SAFE_RELEASE(src, jpegBuf);\n}\n\n/* TurboJPEG 3: TJDecompressor.decompress8() byte destination */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompress8___3BI_3BIIII\n  (JNIEnv *env, jobject obj, jbyteArray src, jint jpegSize, jbyteArray dst,\n   jint x, jint y, jint pitch, jint pf)\n{\n  TJDecompressor_decompress(env, obj, src, jpegSize, dst, 1, 8, x, y, pitch,\n                            pf);\n}\n\n/* TurboJPEG 3: TJDecompressor.decompress12() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompress12\n  (JNIEnv *env, jobject obj, jbyteArray src, jint jpegSize, jshortArray dst,\n   jint x, jint y, jint pitch, jint pf)\n{\n  TJDecompressor_decompress(env, obj, src, jpegSize, dst, 1, 12, x, y, pitch,\n                            pf);\n}\n\n/* TurboJPEG 3: TJDecompressor.decompress16() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompress16\n  (JNIEnv *env, jobject obj, jbyteArray src, jint jpegSize, jshortArray dst,\n   jint x, jint y, jint pitch, jint pf)\n{\n  TJDecompressor_decompress(env, obj, src, jpegSize, dst, 1, 16, x, y, pitch,\n                            pf);\n}\n\n/* TurboJPEG 3: TJDecompressor.decompress8() int destination */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompress8___3BI_3IIIII\n  (JNIEnv *env, jobject obj, jbyteArray src, jint jpegSize, jintArray dst,\n   jint x, jint y, jint stride, jint pf)\n{\n  if (pf < 0 || pf >= org_libjpegturbo_turbojpeg_TJ_NUMPF)\n    THROW_ARG(\"Invalid argument in decompress8()\");\n  if (tjPixelSize[pf] != sizeof(jint))\n    THROW_ARG(\"Pixel format must be 32-bit when decompressing to an integer buffer.\");\n\n  TJDecompressor_decompress(env, obj, src, jpegSize, dst, sizeof(jint), 8, x,\n                            y, stride * sizeof(jint), pf);\n\nbailout:\n  return;\n}\n\n/* TurboJPEG 3: TJDecompressor.decompressToYUV8() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompressToYUV8\n  (JNIEnv *env, jobject obj, jbyteArray src, jint jpegSize,\n   jobjectArray dstobjs, jintArray jDstOffsets, jintArray jDstStrides)\n{\n  tjhandle handle = 0;\n  unsigned char *jpegBuf = NULL;\n  jbyteArray jDstPlanes[3] = { NULL, NULL, NULL };\n  unsigned char *dstPlanesTmp[3] = { NULL, NULL, NULL };\n  unsigned char *dstPlanes[3] = { NULL, NULL, NULL };\n  jint dstOffsetsTmp[3] = { 0, 0, 0 }, dstStridesTmp[3] = { 0, 0, 0 };\n  int dstOffsets[3] = { 0, 0, 0 }, dstStrides[3] = { 0, 0, 0 };\n  jclass sfcls;\n  jobject sfobj;\n  int jpegSubsamp, jpegWidth = 0, jpegHeight = 0;\n  int nc = 0, i, scaledWidth, scaledHeight;\n  tjscalingfactor scalingFactor;\n\n  GET_HANDLE();\n\n  if ((*env)->GetArrayLength(env, src) < jpegSize)\n    THROW_ARG(\"Source buffer is not large enough\");\n  if ((jpegWidth = tj3Get(handle, TJPARAM_JPEGWIDTH)) == -1)\n    THROW_ARG(\"JPEG header has not yet been read\");\n  if ((jpegHeight = tj3Get(handle, TJPARAM_JPEGHEIGHT)) == -1)\n    THROW_ARG(\"JPEG header has not yet been read\");\n\n  BAILIF0(sfcls = (*env)->FindClass(env,\n    \"org/libjpegturbo/turbojpeg/TJScalingFactor\"));\n  BAILIF0(_fid =\n          (*env)->GetFieldID(env, _cls, \"scalingFactor\",\n                             \"Lorg/libjpegturbo/turbojpeg/TJScalingFactor;\"));\n  BAILIF0(sfobj = (*env)->GetObjectField(env, obj, _fid));\n  BAILIF0(_fid = (*env)->GetFieldID(env, sfcls, \"num\", \"I\"));\n  scalingFactor.num = (*env)->GetIntField(env, sfobj, _fid);\n  BAILIF0(_fid = (*env)->GetFieldID(env, sfcls, \"denom\", \"I\"));\n  scalingFactor.denom = (*env)->GetIntField(env, sfobj, _fid);\n\n  if (tj3SetScalingFactor(handle, scalingFactor) == -1)\n    THROW_TJ();\n  scaledWidth = TJSCALED(jpegWidth, scalingFactor);\n  scaledHeight = TJSCALED(jpegHeight, scalingFactor);\n\n  if ((jpegSubsamp = tj3Get(handle, TJPARAM_SUBSAMP)) == TJSAMP_UNKNOWN)\n    THROW_ARG(\"TJPARAM_SUBSAMP must be specified\");\n  nc = jpegSubsamp == TJSAMP_GRAY ? 1 : 3;\n\n  (*env)->GetIntArrayRegion(env, jDstOffsets, 0, nc, dstOffsetsTmp);\n  if ((*env)->ExceptionCheck(env)) goto bailout;\n  for (i = 0; i < 3; i++)\n    dstOffsets[i] = dstOffsetsTmp[i];\n\n  (*env)->GetIntArrayRegion(env, jDstStrides, 0, nc, dstStridesTmp);\n  if ((*env)->ExceptionCheck(env)) goto bailout;\n  for (i = 0; i < 3; i++)\n    dstStrides[i] = dstStridesTmp[i];\n\n  for (i = 0; i < nc; i++) {\n    size_t planeSize = tj3YUVPlaneSize(i, scaledWidth, dstStrides[i],\n                                       scaledHeight, jpegSubsamp);\n    int pw = tj3YUVPlaneWidth(i, scaledWidth, jpegSubsamp);\n\n    if (planeSize == 0 || pw == 0)\n      THROW_ARG(tj3GetErrorStr(NULL));\n\n    if (planeSize > (size_t)INT_MAX)\n      THROW_ARG(\"Destination plane is too large\");\n    if (dstOffsets[i] < 0)\n      THROW_ARG(\"Invalid argument in decompressToYUV8()\");\n    if (dstStrides[i] < 0 && dstOffsets[i] - (int)planeSize + pw < 0)\n      THROW_ARG(\"Negative plane stride would cause memory to be accessed below plane boundary\");\n\n    BAILIF0(jDstPlanes[i] = (*env)->GetObjectArrayElement(env, dstobjs, i));\n    if ((*env)->GetArrayLength(env, jDstPlanes[i]) <\n        dstOffsets[i] + (int)planeSize)\n      THROW_ARG(\"Destination plane is not large enough\");\n  }\n  for (i = 0; i < nc; i++) {\n    BAILIF0NOEC(dstPlanesTmp[i] =\n                (*env)->GetPrimitiveArrayCritical(env, jDstPlanes[i], 0));\n    dstPlanes[i] = &dstPlanesTmp[i][dstOffsets[i]];\n  }\n  BAILIF0NOEC(jpegBuf = (*env)->GetPrimitiveArrayCritical(env, src, 0));\n\n  if (tj3DecompressToYUVPlanes8(handle, jpegBuf, (size_t)jpegSize, dstPlanes,\n                                dstStrides) == -1) {\n    SAFE_RELEASE(src, jpegBuf);\n    for (i = 0; i < nc; i++)\n      SAFE_RELEASE(jDstPlanes[i], dstPlanesTmp[i]);\n    THROW_TJ();\n  }\n\nbailout:\n  SAFE_RELEASE(src, jpegBuf);\n  for (i = 0; i < nc; i++)\n    SAFE_RELEASE(jDstPlanes[i], dstPlanesTmp[i]);\n}\n\nstatic void TJDecompressor_decodeYUV8\n  (JNIEnv *env, jobject obj, jobjectArray srcobjs, jintArray jSrcOffsets,\n   jintArray jSrcStrides, jarray dst, jint dstElementSize, jint x, jint y,\n   jint width, jint pitch, jint height, jint pf)\n{\n  tjhandle handle = 0;\n  jsize arraySize = 0, actualPitch;\n  jbyteArray jSrcPlanes[3] = { NULL, NULL, NULL };\n  const unsigned char *srcPlanesTmp[3] = { NULL, NULL, NULL };\n  const unsigned char *srcPlanes[3] = { NULL, NULL, NULL };\n  jint srcOffsetsTmp[3] = { 0, 0, 0 }, srcStridesTmp[3] = { 0, 0, 0 };\n  int srcOffsets[3] = { 0, 0, 0 }, srcStrides[3] = { 0, 0, 0 };\n  unsigned char *dstBuf = NULL;\n  int nc = 0, i, subsamp;\n\n  GET_HANDLE();\n\n  if (pf < 0 || pf >= org_libjpegturbo_turbojpeg_TJ_NUMPF)\n    THROW_ARG(\"Invalid argument in decodeYUV8()\");\n  if (org_libjpegturbo_turbojpeg_TJ_NUMPF != TJ_NUMPF ||\n      org_libjpegturbo_turbojpeg_TJ_NUMSAMP != TJ_NUMSAMP)\n    THROW_ARG(\"Mismatch between Java and C API\");\n\n  if ((subsamp = tj3Get(handle, TJPARAM_SUBSAMP)) == TJSAMP_UNKNOWN)\n    THROW_ARG(\"TJPARAM_SUBSAMP must be specified\");\n  nc = subsamp == TJSAMP_GRAY ? 1 : 3;\n  if ((*env)->GetArrayLength(env, srcobjs) < nc)\n    THROW_ARG(\"Planes array is too small for the subsampling type\");\n  if ((*env)->GetArrayLength(env, jSrcOffsets) < nc)\n    THROW_ARG(\"Offsets array is too small for the subsampling type\");\n  if ((*env)->GetArrayLength(env, jSrcStrides) < nc)\n    THROW_ARG(\"Strides array is too small for the subsampling type\");\n\n  actualPitch = (pitch == 0) ? width * tjPixelSize[pf] : pitch;\n  arraySize = (y + height - 1) * actualPitch + (x + width) * tjPixelSize[pf];\n  if ((*env)->GetArrayLength(env, dst) * dstElementSize < arraySize)\n    THROW_ARG(\"Destination buffer is not large enough\");\n\n  (*env)->GetIntArrayRegion(env, jSrcOffsets, 0, nc, srcOffsetsTmp);\n  if ((*env)->ExceptionCheck(env)) goto bailout;\n  for (i = 0; i < 3; i++)\n    srcOffsets[i] = srcOffsetsTmp[i];\n\n  (*env)->GetIntArrayRegion(env, jSrcStrides, 0, nc, srcStridesTmp);\n  if ((*env)->ExceptionCheck(env)) goto bailout;\n  for (i = 0; i < 3; i++)\n    srcStrides[i] = srcStridesTmp[i];\n\n  for (i = 0; i < nc; i++) {\n    size_t planeSize = tj3YUVPlaneSize(i, width, srcStrides[i], height,\n                                       subsamp);\n    int pw = tj3YUVPlaneWidth(i, width, subsamp);\n\n    if (planeSize == 0 || pw == 0)\n      THROW_ARG(tj3GetErrorStr(NULL));\n\n    if (planeSize > (size_t)INT_MAX)\n      THROW_ARG(\"Source plane is too large\");\n    if (srcOffsets[i] < 0)\n      THROW_ARG(\"Invalid argument in decodeYUV8()\");\n    if (srcStrides[i] < 0 && srcOffsets[i] - (int)planeSize + pw < 0)\n      THROW_ARG(\"Negative plane stride would cause memory to be accessed below plane boundary\");\n\n    BAILIF0(jSrcPlanes[i] = (*env)->GetObjectArrayElement(env, srcobjs, i));\n    if ((*env)->GetArrayLength(env, jSrcPlanes[i]) <\n        srcOffsets[i] + (int)planeSize)\n      THROW_ARG(\"Source plane is not large enough\");\n  }\n  for (i = 0; i < nc; i++) {\n    BAILIF0NOEC(srcPlanesTmp[i] =\n                (*env)->GetPrimitiveArrayCritical(env, jSrcPlanes[i], 0));\n    srcPlanes[i] = &srcPlanesTmp[i][srcOffsets[i]];\n  }\n  BAILIF0NOEC(dstBuf = (*env)->GetPrimitiveArrayCritical(env, dst, 0));\n\n  if (tj3DecodeYUVPlanes8(handle, srcPlanes, srcStrides,\n                          &dstBuf[y * actualPitch + x * tjPixelSize[pf]],\n                          width, pitch, height, pf) == -1) {\n    SAFE_RELEASE(dst, dstBuf);\n    for (i = 0; i < nc; i++)\n      SAFE_RELEASE(jSrcPlanes[i], srcPlanesTmp[i]);\n    THROW_TJ();\n  }\n\nbailout:\n  SAFE_RELEASE(dst, dstBuf);\n  for (i = 0; i < nc; i++)\n    SAFE_RELEASE(jSrcPlanes[i], srcPlanesTmp[i]);\n}\n\n/* TurboJPEG 3: TJDecompressor.decodeYUV8() byte destination */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decodeYUV8___3_3B_3I_3I_3BIIIIII\n  (JNIEnv *env, jobject obj, jobjectArray srcobjs, jintArray jSrcOffsets,\n   jintArray jSrcStrides, jbyteArray dst, jint x, jint y, jint width,\n   jint pitch, jint height, jint pf)\n{\n  TJDecompressor_decodeYUV8(env, obj, srcobjs, jSrcOffsets, jSrcStrides, dst,\n                            1, x, y, width, pitch, height, pf);\n}\n\n/* TurboJPEG 3: TJDecompressor.decodeYUV8() int destination */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_decodeYUV8___3_3B_3I_3I_3IIIIIII\n  (JNIEnv *env, jobject obj, jobjectArray srcobjs, jintArray jSrcOffsets,\n   jintArray jSrcStrides, jintArray dst, jint x, jint y, jint width,\n   jint stride, jint height, jint pf)\n{\n  if (pf < 0 || pf >= org_libjpegturbo_turbojpeg_TJ_NUMPF)\n    THROW_ARG(\"Invalid argument in decodeYUV8()\");\n  if (tjPixelSize[pf] != sizeof(jint))\n    THROW_ARG(\"Pixel format must be 32-bit when decoding to an integer buffer.\");\n\n  TJDecompressor_decodeYUV8(env, obj, srcobjs, jSrcOffsets, jSrcStrides, dst,\n                            sizeof(jint), x, y, width, stride * sizeof(jint),\n                            height, pf);\n\nbailout:\n  return;\n}\n\n/* TurboJPEG 1.2.x: TJTransformer.init() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJTransformer_init\n  (JNIEnv *env, jobject obj)\n{\n  jclass cls;\n  jfieldID fid;\n  tjhandle handle;\n\n  if ((handle = tj3Init(TJINIT_TRANSFORM)) == NULL)\n    THROW(tj3GetErrorStr(NULL), \"org/libjpegturbo/turbojpeg/TJException\");\n\n  BAILIF0(cls = (*env)->GetObjectClass(env, obj));\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"handle\", \"J\"));\n  (*env)->SetLongField(env, obj, fid, (size_t)handle);\n\nbailout:\n  return;\n}\n\ntypedef struct _JNICustomFilterParams {\n  JNIEnv *env;\n  jobject tobj;\n  jobject cfobj;\n} JNICustomFilterParams;\n\nstatic int JNICustomFilter(short *coeffs, tjregion arrayRegion,\n                           tjregion planeRegion, int componentIndex,\n                           int transformIndex, tjtransform *transform)\n{\n  JNICustomFilterParams *params = (JNICustomFilterParams *)transform->data;\n  JNIEnv *env = params->env;\n  jobject tobj = params->tobj, cfobj = params->cfobj;\n  jobject arrayRegionObj, planeRegionObj, bufobj, borobj;\n  jclass cls;\n  jmethodID mid;\n  jfieldID fid;\n\n  BAILIF0(bufobj = (*env)->NewDirectByteBuffer(env, coeffs,\n    sizeof(short) * arrayRegion.w * arrayRegion.h));\n  BAILIF0(cls = (*env)->FindClass(env, \"java/nio/ByteOrder\"));\n  BAILIF0(mid = (*env)->GetStaticMethodID(env, cls, \"nativeOrder\",\n                                          \"()Ljava/nio/ByteOrder;\"));\n  BAILIF0(borobj = (*env)->CallStaticObjectMethod(env, cls, mid));\n  BAILIF0(cls = (*env)->GetObjectClass(env, bufobj));\n  BAILIF0(mid = (*env)->GetMethodID(env, cls, \"order\",\n    \"(Ljava/nio/ByteOrder;)Ljava/nio/ByteBuffer;\"));\n  (*env)->CallObjectMethod(env, bufobj, mid, borobj);\n  BAILIF0(mid = (*env)->GetMethodID(env, cls, \"asShortBuffer\",\n                                    \"()Ljava/nio/ShortBuffer;\"));\n  BAILIF0(bufobj = (*env)->CallObjectMethod(env, bufobj, mid));\n\n  BAILIF0(cls = (*env)->FindClass(env, \"java/awt/Rectangle\"));\n  BAILIF0(arrayRegionObj = (*env)->AllocObject(env, cls));\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"x\", \"I\"));\n  (*env)->SetIntField(env, arrayRegionObj, fid, arrayRegion.x);\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"y\", \"I\"));\n  (*env)->SetIntField(env, arrayRegionObj, fid, arrayRegion.y);\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"width\", \"I\"));\n  (*env)->SetIntField(env, arrayRegionObj, fid, arrayRegion.w);\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"height\", \"I\"));\n  (*env)->SetIntField(env, arrayRegionObj, fid, arrayRegion.h);\n\n  BAILIF0(planeRegionObj = (*env)->AllocObject(env, cls));\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"x\", \"I\"));\n  (*env)->SetIntField(env, planeRegionObj, fid, planeRegion.x);\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"y\", \"I\"));\n  (*env)->SetIntField(env, planeRegionObj, fid, planeRegion.y);\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"width\", \"I\"));\n  (*env)->SetIntField(env, planeRegionObj, fid, planeRegion.w);\n  BAILIF0(fid = (*env)->GetFieldID(env, cls, \"height\", \"I\"));\n  (*env)->SetIntField(env, planeRegionObj, fid, planeRegion.h);\n\n  BAILIF0(cls = (*env)->GetObjectClass(env, cfobj));\n  BAILIF0(mid = (*env)->GetMethodID(env, cls, \"customFilter\",\n    \"(Ljava/nio/ShortBuffer;Ljava/awt/Rectangle;Ljava/awt/Rectangle;IILorg/libjpegturbo/turbojpeg/TJTransform;)V\"));\n  (*env)->CallVoidMethod(env, cfobj, mid, bufobj, arrayRegionObj,\n                         planeRegionObj, componentIndex, transformIndex, tobj);\n\n  return 0;\n\nbailout:\n  return -1;\n}\n\n/* TurboJPEG 1.2.x: TJTransformer.transform() */\nJNIEXPORT jintArray JNICALL Java_org_libjpegturbo_turbojpeg_TJTransformer_transform\n  (JNIEnv *env, jobject obj, jbyteArray jsrcBuf, jint jpegSize,\n   jobjectArray dstobjs, jobjectArray tobjs)\n{\n  tjhandle handle = 0;\n  unsigned char *jpegBuf = NULL, **dstBufs = NULL;\n  jsize n = 0;\n  size_t *dstSizes = NULL;\n  tjtransform *t = NULL;\n  jbyteArray *jdstBufs = NULL;\n  int i, jpegWidth = 0, jpegHeight = 0, srcSubsamp;\n  jintArray jdstSizes = 0;\n  jint *dstSizesi = NULL;\n  JNICustomFilterParams *params = NULL;\n\n  GET_HANDLE();\n\n  if ((*env)->GetArrayLength(env, jsrcBuf) < jpegSize)\n    THROW_ARG(\"Source buffer is not large enough\");\n  if ((jpegWidth = tj3Get(handle, TJPARAM_JPEGWIDTH)) == -1)\n    THROW_ARG(\"JPEG header has not yet been read\");\n  if ((jpegHeight = tj3Get(handle, TJPARAM_JPEGHEIGHT)) == -1)\n    THROW_ARG(\"JPEG header has not yet been read\");\n  srcSubsamp = tj3Get(handle, TJPARAM_SUBSAMP);\n\n  n = (*env)->GetArrayLength(env, dstobjs);\n  if (n != (*env)->GetArrayLength(env, tobjs))\n    THROW_ARG(\"Mismatch between size of transforms array and destination buffers array\");\n\n  if ((dstBufs =\n       (unsigned char **)malloc(sizeof(unsigned char *) * n)) == NULL)\n    THROW_MEM();\n  if ((jdstBufs = (jbyteArray *)malloc(sizeof(jbyteArray) * n)) == NULL)\n    THROW_MEM();\n  if ((dstSizes = (size_t *)malloc(sizeof(size_t) * n)) == NULL)\n    THROW_MEM();\n  if ((t = (tjtransform *)malloc(sizeof(tjtransform) * n)) == NULL)\n    THROW_MEM();\n  if ((params = (JNICustomFilterParams *)malloc(sizeof(JNICustomFilterParams) *\n                                                n)) == NULL)\n    THROW_MEM();\n  for (i = 0; i < n; i++) {\n    dstBufs[i] = NULL;  jdstBufs[i] = NULL;  dstSizes[i] = 0;\n    memset(&t[i], 0, sizeof(tjtransform));\n    memset(&params[i], 0, sizeof(JNICustomFilterParams));\n  }\n\n  for (i = 0; i < n; i++) {\n    jobject tobj, cfobj;\n\n    BAILIF0(tobj = (*env)->GetObjectArrayElement(env, tobjs, i));\n    BAILIF0(_cls = (*env)->GetObjectClass(env, tobj));\n    BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"op\", \"I\"));\n    t[i].op = (*env)->GetIntField(env, tobj, _fid);\n    BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"options\", \"I\"));\n    t[i].options = (*env)->GetIntField(env, tobj, _fid);\n    BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"x\", \"I\"));\n    t[i].r.x = (*env)->GetIntField(env, tobj, _fid);\n    BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"y\", \"I\"));\n    t[i].r.y = (*env)->GetIntField(env, tobj, _fid);\n    BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"width\", \"I\"));\n    t[i].r.w = (*env)->GetIntField(env, tobj, _fid);\n    BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"height\", \"I\"));\n    t[i].r.h = (*env)->GetIntField(env, tobj, _fid);\n\n    BAILIF0(_fid = (*env)->GetFieldID(env, _cls, \"cf\",\n      \"Lorg/libjpegturbo/turbojpeg/TJCustomFilter;\"));\n    cfobj = (*env)->GetObjectField(env, tobj, _fid);\n    if (cfobj) {\n      params[i].env = env;\n      params[i].tobj = tobj;\n      params[i].cfobj = cfobj;\n      t[i].customFilter = JNICustomFilter;\n      t[i].data = (void *)&params[i];\n    }\n  }\n\n  if (tj3Set(handle, TJPARAM_NOREALLOC, 1) == -1)\n    THROW_TJ();\n\n  for (i = 0; i < n; i++) {\n    int w = jpegWidth, h = jpegHeight;\n    int dstSubsamp = (t[i].options & TJXOPT_GRAY) ? TJSAMP_GRAY : srcSubsamp;\n\n    if (t[i].op == TJXOP_TRANSPOSE || t[i].op == TJXOP_TRANSVERSE ||\n        t[i].op == TJXOP_ROT90 || t[i].op == TJXOP_ROT270) {\n      w = jpegHeight;  h = jpegWidth;\n      if (dstSubsamp == TJSAMP_422) dstSubsamp = TJSAMP_440;\n      else if (dstSubsamp == TJSAMP_440) dstSubsamp = TJSAMP_422;\n      else if (dstSubsamp == TJSAMP_411) dstSubsamp = TJSAMP_441;\n      else if (dstSubsamp == TJSAMP_441) dstSubsamp = TJSAMP_411;\n    }\n    if (t[i].r.w != 0) w = t[i].r.w;\n    if (t[i].r.h != 0) h = t[i].r.h;\n    BAILIF0(jdstBufs[i] = (*env)->GetObjectArrayElement(env, dstobjs, i));\n    if ((size_t)(*env)->GetArrayLength(env, jdstBufs[i]) <\n        tj3JPEGBufSize(w, h, dstSubsamp))\n      THROW_ARG(\"Destination buffer is not large enough\");\n  }\n  BAILIF0NOEC(jpegBuf = (*env)->GetPrimitiveArrayCritical(env, jsrcBuf, 0));\n  for (i = 0; i < n; i++)\n    BAILIF0NOEC(dstBufs[i] =\n                (*env)->GetPrimitiveArrayCritical(env, jdstBufs[i], 0));\n\n  if (tj3Transform(handle, jpegBuf, jpegSize, n, dstBufs, dstSizes, t) == -1) {\n    for (i = 0; i < n; i++)\n      SAFE_RELEASE(jdstBufs[i], dstBufs[i]);\n    SAFE_RELEASE(jsrcBuf, jpegBuf);\n    THROW_TJ();\n  }\n\n  for (i = 0; i < n; i++)\n    SAFE_RELEASE(jdstBufs[i], dstBufs[i]);\n  SAFE_RELEASE(jsrcBuf, jpegBuf);\n\n  jdstSizes = (*env)->NewIntArray(env, n);\n  BAILIF0(dstSizesi = (*env)->GetIntArrayElements(env, jdstSizes, 0));\n  for (i = 0; i < n; i++) dstSizesi[i] = (int)dstSizes[i];\n\nbailout:\n  if (dstSizesi) (*env)->ReleaseIntArrayElements(env, jdstSizes, dstSizesi, 0);\n  if (dstBufs) {\n    for (i = 0; i < n; i++) {\n      if (dstBufs[i] && jdstBufs && jdstBufs[i])\n        (*env)->ReleasePrimitiveArrayCritical(env, jdstBufs[i], dstBufs[i], 0);\n    }\n    free(dstBufs);\n  }\n  SAFE_RELEASE(jsrcBuf, jpegBuf);\n  free(jdstBufs);\n  free(dstSizes);\n  free(t);\n  return jdstSizes;\n}\n\n/* TurboJPEG 1.2.x: TJDecompressor.destroy() */\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_destroy\n  (JNIEnv *env, jobject obj)\n{\n  Java_org_libjpegturbo_turbojpeg_TJCompressor_destroy(env, obj);\n}\n\n/* Private image I/O routines (used only by TJBench) */\nJNIEXPORT jobject JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_loadImage\n  (JNIEnv *env, jobject obj, jint precision, jstring jfilename,\n   jintArray jwidth, jint align, jintArray jheight, jintArray jpixelFormat)\n{\n  tjhandle handle = NULL;\n  void *dstBuf = NULL, *jdstPtr;\n  int width, *warr, height, *harr, pixelFormat, *pfarr;\n  jsize arraySize, pitch;\n  const char *filename = NULL;\n  jboolean isCopy;\n  jobject jdstBuf = NULL;\n\n  GET_HANDLE();\n\n  if ((precision != 8 && precision != 12 && precision != 16) ||\n      jfilename == NULL || jwidth == NULL ||\n      (*env)->GetArrayLength(env, jwidth) < 1 || jheight == NULL ||\n      (*env)->GetArrayLength(env, jheight) < 1 || jpixelFormat == NULL ||\n      (*env)->GetArrayLength(env, jpixelFormat) < 1)\n    THROW_ARG(\"Invalid argument in loadImage()\");\n\n  BAILIF0NOEC(warr = (*env)->GetPrimitiveArrayCritical(env, jwidth, 0));\n  width = warr[0];\n  (*env)->ReleasePrimitiveArrayCritical(env, jwidth, warr, 0);\n  BAILIF0NOEC(harr = (*env)->GetPrimitiveArrayCritical(env, jheight, 0));\n  height = harr[0];\n  (*env)->ReleasePrimitiveArrayCritical(env, jheight, harr, 0);\n  BAILIF0NOEC(pfarr = (*env)->GetPrimitiveArrayCritical(env, jpixelFormat, 0));\n  pixelFormat = pfarr[0];\n  (*env)->ReleasePrimitiveArrayCritical(env, jpixelFormat, pfarr, 0);\n  BAILIF0(filename = (*env)->GetStringUTFChars(env, jfilename, &isCopy));\n\n  if (precision == 8) {\n    if ((dstBuf = tj3LoadImage8(handle, filename, &width, align, &height,\n                                &pixelFormat)) == NULL)\n      THROW_TJ();\n  } else if (precision == 12) {\n    if ((dstBuf = tj3LoadImage12(handle, filename, &width, align, &height,\n                                 &pixelFormat)) == NULL)\n      THROW_TJ();\n  } else {\n    if ((dstBuf = tj3LoadImage16(handle, filename, &width, align, &height,\n                                 &pixelFormat)) == NULL)\n      THROW_TJ();\n  }\n\n  (*env)->ReleaseStringUTFChars(env, jfilename, filename);\n  filename = NULL;\n\n  if ((unsigned long long)width * (unsigned long long)height *\n      (unsigned long long)tjPixelSize[pixelFormat] >\n      (unsigned long long)((unsigned int)-1))\n    THROW_ARG(\"Image is too large\");\n\n  BAILIF0NOEC(warr = (*env)->GetPrimitiveArrayCritical(env, jwidth, 0));\n  warr[0] = width;\n  (*env)->ReleasePrimitiveArrayCritical(env, jwidth, warr, 0);\n  BAILIF0NOEC(harr = (*env)->GetPrimitiveArrayCritical(env, jheight, 0));\n  harr[0] = height;\n  (*env)->ReleasePrimitiveArrayCritical(env, jheight, harr, 0);\n  BAILIF0NOEC(pfarr = (*env)->GetPrimitiveArrayCritical(env, jpixelFormat, 0));\n  pfarr[0] = pixelFormat;\n  (*env)->ReleasePrimitiveArrayCritical(env, jpixelFormat, pfarr, 0);\n\n  pitch = PAD(width * tjPixelSize[pixelFormat], align);\n  arraySize = pitch * height;\n  if (precision == 8)\n    jdstBuf = (*env)->NewByteArray(env, arraySize);\n  else\n    jdstBuf = (*env)->NewShortArray(env, arraySize);\n  BAILIF0NOEC(jdstPtr = (*env)->GetPrimitiveArrayCritical(env, jdstBuf, 0));\n  memcpy(jdstPtr, dstBuf, arraySize * (precision > 8 ? 2 : 1));\n  (*env)->ReleasePrimitiveArrayCritical(env, jdstBuf, jdstPtr, 0);\n\nbailout:\n  if (filename) (*env)->ReleaseStringUTFChars(env, jfilename, filename);\n  tj3Free(dstBuf);\n  return jdstBuf;\n}\n\n\nJNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_saveImage\n  (JNIEnv *env, jobject obj, jint precision, jstring jfilename,\n   jobject jsrcBuf, jint width, jint pitch, jint height, jint pixelFormat)\n{\n  tjhandle handle = NULL;\n  void *srcBuf = NULL, *jsrcPtr;\n  const char *filename = NULL;\n  jsize arraySize, actualPitch;\n  jboolean isCopy;\n\n  GET_HANDLE();\n\n  if ((precision != 8 && precision != 12 && precision != 16) ||\n      jfilename == NULL || jsrcBuf == NULL || width < 1 || pitch < 0 ||\n      height < 1 || pixelFormat < 0 ||\n      pixelFormat >= org_libjpegturbo_turbojpeg_TJ_NUMPF)\n    THROW_ARG(\"Invalid argument in saveImage()\");\n  if (org_libjpegturbo_turbojpeg_TJ_NUMPF != TJ_NUMPF)\n    THROW_ARG(\"Mismatch between Java and C API\");\n\n  if ((unsigned long long)width * (unsigned long long)height *\n      (unsigned long long)tjPixelSize[pixelFormat] >\n      (unsigned long long)((unsigned int)-1))\n    THROW_ARG(\"Image is too large\");\n  actualPitch = (pitch == 0) ? width * tjPixelSize[pixelFormat] : pitch;\n  arraySize = actualPitch * height;\n  if ((*env)->GetArrayLength(env, jsrcBuf) < arraySize)\n    THROW_ARG(\"Source buffer is not large enough\");\n\n  if ((srcBuf = malloc(arraySize * (precision > 8 ? 2 : 1))) == NULL)\n    THROW_MEM();\n\n  BAILIF0NOEC(jsrcPtr = (*env)->GetPrimitiveArrayCritical(env, jsrcBuf, 0));\n  memcpy(srcBuf, jsrcPtr, arraySize * (precision > 8 ? 2 : 1));\n  (*env)->ReleasePrimitiveArrayCritical(env, jsrcBuf, jsrcPtr, 0);\n  BAILIF0(filename = (*env)->GetStringUTFChars(env, jfilename, &isCopy));\n\n  if (precision == 8) {\n    if (tj3SaveImage8(handle, filename, srcBuf, width, pitch, height,\n                      pixelFormat) == -1)\n      THROW_TJ();\n  } else if (precision == 12) {\n    if (tj3SaveImage12(handle, filename, srcBuf, width, pitch, height,\n                       pixelFormat) == -1)\n      THROW_TJ();\n  } else {\n    if (tj3SaveImage16(handle, filename, srcBuf, width, pitch, height,\n                       pixelFormat) == -1)\n      THROW_TJ();\n  }\n\nbailout:\n  if (filename) (*env)->ReleaseStringUTFChars(env, jfilename, filename);\n  free(srcBuf);\n}\n"
        },
        {
          "name": "turbojpeg-mapfile",
          "type": "blob",
          "size": 1.7705078125,
          "content": "TURBOJPEG_1.0\n{\n  global:\n    TJBUFSIZE;\n    tjCompress;\n    tjDecompress;\n    tjDecompressHeader;\n    tjDestroy;\n    tjGetErrorStr;\n    tjInitCompress;\n    tjInitDecompress;\n  local:\n    *;\n};\n\nTURBOJPEG_1.1\n{\n  global:\n    TJBUFSIZEYUV;\n    tjDecompressHeader2;\n    tjDecompressToYUV;\n    tjEncodeYUV;\n} TURBOJPEG_1.0;\n\nTURBOJPEG_1.2\n{\n  global:\n    tjAlloc;\n    tjBufSize;\n    tjBufSizeYUV;\n    tjCompress2;\n    tjDecompress2;\n    tjEncodeYUV2;\n    tjFree;\n    tjGetScalingFactors;\n    tjInitTransform;\n    tjTransform;\n} TURBOJPEG_1.1;\n\nTURBOJPEG_1.4\n{\n  global:\n    tjBufSizeYUV2;\n    tjCompressFromYUV;\n    tjCompressFromYUVPlanes;\n    tjDecodeYUV;\n    tjDecodeYUVPlanes;\n    tjDecompressHeader3;\n    tjDecompressToYUV2;\n    tjDecompressToYUVPlanes;\n    tjEncodeYUV3;\n    tjEncodeYUVPlanes;\n    tjPlaneHeight;\n    tjPlaneSizeYUV;\n    tjPlaneWidth;\n} TURBOJPEG_1.2;\n\nTURBOJPEG_2.0\n{\n  global:\n    tjGetErrorCode;\n    tjGetErrorStr2;\n    tjLoadImage;\n    tjSaveImage;\n} TURBOJPEG_1.4;\n\nTURBOJPEG_3\n{\n  global:\n    tj3Alloc;\n    tj3Compress8;\n    tj3Compress12;\n    tj3Compress16;\n    tj3CompressFromYUV8;\n    tj3CompressFromYUVPlanes8;\n    tj3DecodeYUV8;\n    tj3DecodeYUVPlanes8;\n    tj3Decompress8;\n    tj3Decompress12;\n    tj3Decompress16;\n    tj3DecompressHeader;\n    tj3DecompressToYUV8;\n    tj3DecompressToYUVPlanes8;\n    tj3Destroy;\n    tj3EncodeYUV8;\n    tj3EncodeYUVPlanes8;\n    tj3Free;\n    tj3Get;\n    tj3GetErrorCode;\n    tj3GetErrorStr;\n    tj3GetScalingFactors;\n    tj3Init;\n    tj3JPEGBufSize;\n    tj3LoadImage8;\n    tj3LoadImage12;\n    tj3LoadImage16;\n    tj3SaveImage8;\n    tj3SaveImage12;\n    tj3SaveImage16;\n    tj3Set;\n    tj3SetCroppingRegion;\n    tj3SetScalingFactor;\n    tj3Transform;\n    tj3YUVBufSize;\n    tj3YUVPlaneHeight;\n    tj3YUVPlaneSize;\n    tj3YUVPlaneWidth;\n} TURBOJPEG_2.0;\n"
        },
        {
          "name": "turbojpeg-mapfile.jni",
          "type": "blob",
          "size": 3.9091796875,
          "content": "TURBOJPEG_1.0\n{\n  global:\n    TJBUFSIZE;\n    tjCompress;\n    tjDecompress;\n    tjDecompressHeader;\n    tjDestroy;\n    tjGetErrorStr;\n    tjInitCompress;\n    tjInitDecompress;\n  local:\n    *;\n};\n\nTURBOJPEG_1.1\n{\n  global:\n    TJBUFSIZEYUV;\n    tjDecompressHeader2;\n    tjDecompressToYUV;\n    tjEncodeYUV;\n} TURBOJPEG_1.0;\n\nTURBOJPEG_1.2\n{\n  global:\n    tjAlloc;\n    tjBufSize;\n    tjBufSizeYUV;\n    tjCompress2;\n    tjDecompress2;\n    tjEncodeYUV2;\n    tjFree;\n    tjGetScalingFactors;\n    tjInitTransform;\n    tjTransform;\n    Java_org_libjpegturbo_turbojpeg_TJ_bufSize;\n    Java_org_libjpegturbo_turbojpeg_TJ_getScalingFactors;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_init;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_destroy;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_init;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompressHeader;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_destroy;\n    Java_org_libjpegturbo_turbojpeg_TJTransformer_init;\n    Java_org_libjpegturbo_turbojpeg_TJTransformer_transform;\n} TURBOJPEG_1.1;\n\nTURBOJPEG_1.4\n{\n  global:\n    tjBufSizeYUV2;\n    tjCompressFromYUV;\n    tjCompressFromYUVPlanes;\n    tjDecodeYUV;\n    tjDecodeYUVPlanes;\n    tjDecompressHeader3;\n    tjDecompressToYUV2;\n    tjDecompressToYUVPlanes;\n    tjEncodeYUV3;\n    tjEncodeYUVPlanes;\n    tjPlaneHeight;\n    tjPlaneSizeYUV;\n    tjPlaneWidth;\n    Java_org_libjpegturbo_turbojpeg_TJ_bufSizeYUV__IIII;\n    Java_org_libjpegturbo_turbojpeg_TJ_planeHeight__III;\n    Java_org_libjpegturbo_turbojpeg_TJ_planeSizeYUV__IIIII;\n    Java_org_libjpegturbo_turbojpeg_TJ_planeWidth__III;\n} TURBOJPEG_1.2;\n\nTURBOJPEG_2.0\n{\n  global:\n    tjGetErrorCode;\n    tjGetErrorStr2;\n    tjLoadImage;\n    tjSaveImage;\n} TURBOJPEG_1.4;\n\nTURBOJPEG_3\n{\n  global:\n    tj3Alloc;\n    tj3Compress8;\n    tj3Compress12;\n    tj3Compress16;\n    tj3CompressFromYUV8;\n    tj3CompressFromYUVPlanes8;\n    tj3DecodeYUV8;\n    tj3DecodeYUVPlanes8;\n    tj3Decompress8;\n    tj3Decompress12;\n    tj3Decompress16;\n    tj3DecompressHeader;\n    tj3DecompressToYUV8;\n    tj3DecompressToYUVPlanes8;\n    tj3Destroy;\n    tj3EncodeYUV8;\n    tj3EncodeYUVPlanes8;\n    tj3Free;\n    tj3Get;\n    tj3GetErrorCode;\n    tj3GetErrorStr;\n    tj3GetScalingFactors;\n    tj3Init;\n    tj3JPEGBufSize;\n    tj3LoadImage8;\n    tj3LoadImage12;\n    tj3LoadImage16;\n    tj3SaveImage8;\n    tj3SaveImage12;\n    tj3SaveImage16;\n    tj3Set;\n    tj3SetCroppingRegion;\n    tj3SetScalingFactor;\n    tj3Transform;\n    tj3YUVBufSize;\n    tj3YUVPlaneHeight;\n    tj3YUVPlaneSize;\n    tj3YUVPlaneWidth;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_compress8___3BIIIIII_3B;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_compress8___3IIIIIII_3B;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_compress12;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_compress16;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_compressFromYUV8;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_encodeYUV8___3BIIIIII_3_3B_3I_3I;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_encodeYUV8___3IIIIIII_3_3B_3I_3I;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_get;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_loadImage;\n    Java_org_libjpegturbo_turbojpeg_TJCompressor_set;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_decodeYUV8___3_3B_3I_3I_3BIIIIII;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_decodeYUV8___3_3B_3I_3I_3IIIIIII;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompress8___3BI_3BIIII;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompress8___3BI_3IIIII;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompress12;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompress16;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_decompressToYUV8;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_get;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_saveImage;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_set;\n    Java_org_libjpegturbo_turbojpeg_TJDecompressor_setCroppingRegion;\n} TURBOJPEG_2.0;\n"
        },
        {
          "name": "turbojpeg-mp.c",
          "type": "blob",
          "size": 18.109375,
          "content": "/*\n * Copyright (C)2009-2024 D. R. Commander.  All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* TurboJPEG API functions that must be compiled for multiple data\n   precisions */\n\n#if BITS_IN_JSAMPLE == 8\n#define _JSAMPLE  JSAMPLE\n#define _JSAMPROW  JSAMPROW\n#define _buffer  buffer\n#define _jinit_read_ppm  jinit_read_ppm\n#define _jinit_write_ppm  jinit_write_ppm\n#define _jpeg_crop_scanline  jpeg_crop_scanline\n#define _jpeg_read_scanlines  jpeg_read_scanlines\n#define _jpeg_skip_scanlines  jpeg_skip_scanlines\n#define _jpeg_write_scanlines  jpeg_write_scanlines\n#elif BITS_IN_JSAMPLE == 12\n#define _JSAMPLE  J12SAMPLE\n#define _JSAMPROW  J12SAMPROW\n#define _buffer  buffer12\n#define _jinit_read_ppm  j12init_read_ppm\n#define _jinit_write_ppm  j12init_write_ppm\n#define _jpeg_crop_scanline  jpeg12_crop_scanline\n#define _jpeg_read_scanlines  jpeg12_read_scanlines\n#define _jpeg_skip_scanlines  jpeg12_skip_scanlines\n#define _jpeg_write_scanlines  jpeg12_write_scanlines\n#elif BITS_IN_JSAMPLE == 16\n#define _JSAMPLE  J16SAMPLE\n#define _JSAMPROW  J16SAMPROW\n#define _buffer  buffer16\n#define _jinit_read_ppm  j16init_read_ppm\n#define _jinit_write_ppm  j16init_write_ppm\n#define _jpeg_read_scanlines  jpeg16_read_scanlines\n#define _jpeg_write_scanlines  jpeg16_write_scanlines\n#endif\n\n#define _GET_NAME(name, suffix)  name##suffix\n#define GET_NAME(name, suffix)  _GET_NAME(name, suffix)\n#define _GET_STRING(name, suffix)  #name #suffix\n#define GET_STRING(name, suffix)  _GET_STRING(name, suffix)\n\n\n/******************************** Compressor *********************************/\n\n/* TurboJPEG 3+ */\nDLLEXPORT int GET_NAME(tj3Compress, BITS_IN_JSAMPLE)\n  (tjhandle handle, const _JSAMPLE *srcBuf, int width, int pitch, int height,\n   int pixelFormat, unsigned char **jpegBuf, size_t *jpegSize)\n{\n  static const char FUNCTION_NAME[] = GET_STRING(tj3Compress, BITS_IN_JSAMPLE);\n  int i, retval = 0;\n  boolean alloc = TRUE;\n  _JSAMPROW *row_pointer = NULL;\n\n  GET_CINSTANCE(handle)\n  if ((this->init & COMPRESS) == 0)\n    THROW(\"Instance has not been initialized for compression\");\n\n  if (srcBuf == NULL || width <= 0 || pitch < 0 || height <= 0 ||\n      pixelFormat < 0 || pixelFormat >= TJ_NUMPF || jpegBuf == NULL ||\n      jpegSize == NULL)\n    THROW(\"Invalid argument\");\n\n  if (!this->lossless && this->quality == -1)\n    THROW(\"TJPARAM_QUALITY must be specified\");\n  if (!this->lossless && this->subsamp == TJSAMP_UNKNOWN)\n    THROW(\"TJPARAM_SUBSAMP must be specified\");\n\n  if (pitch == 0) pitch = width * tjPixelSize[pixelFormat];\n\n  if ((row_pointer = (_JSAMPROW *)malloc(sizeof(_JSAMPROW) * height)) == NULL)\n    THROW(\"Memory allocation failure\");\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  cinfo->image_width = width;\n  cinfo->image_height = height;\n  cinfo->data_precision = BITS_IN_JSAMPLE;\n\n  setCompDefaults(this, pixelFormat);\n  if (this->noRealloc) {\n    alloc = FALSE;\n    *jpegSize = tj3JPEGBufSize(width, height, this->subsamp);\n  }\n  jpeg_mem_dest_tj(cinfo, jpegBuf, jpegSize, alloc);\n\n  jpeg_start_compress(cinfo, TRUE);\n  for (i = 0; i < height; i++) {\n    if (this->bottomUp)\n      row_pointer[i] = (_JSAMPROW)&srcBuf[(height - i - 1) * (size_t)pitch];\n    else\n      row_pointer[i] = (_JSAMPROW)&srcBuf[i * (size_t)pitch];\n  }\n  while (cinfo->next_scanline < cinfo->image_height)\n    _jpeg_write_scanlines(cinfo, &row_pointer[cinfo->next_scanline],\n                          cinfo->image_height - cinfo->next_scanline);\n  jpeg_finish_compress(cinfo);\n\nbailout:\n  if (cinfo->global_state > CSTATE_START && alloc)\n    (*cinfo->dest->term_destination) (cinfo);\n  if (cinfo->global_state > CSTATE_START || retval == -1)\n    jpeg_abort_compress(cinfo);\n  free(row_pointer);\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n\n/******************************* Decompressor ********************************/\n\n/* TurboJPEG 3+ */\nDLLEXPORT int GET_NAME(tj3Decompress, BITS_IN_JSAMPLE)\n  (tjhandle handle, const unsigned char *jpegBuf, size_t jpegSize,\n   _JSAMPLE *dstBuf, int pitch, int pixelFormat)\n{\n  static const char FUNCTION_NAME[] =\n    GET_STRING(tj3Decompress, BITS_IN_JSAMPLE);\n  _JSAMPROW *row_pointer = NULL;\n  int croppedHeight, i, retval = 0;\n#if BITS_IN_JSAMPLE != 16\n  int scaledWidth;\n#endif\n  struct my_progress_mgr progress;\n\n  GET_DINSTANCE(handle);\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for decompression\");\n\n  if (jpegBuf == NULL || jpegSize <= 0 || dstBuf == NULL || pitch < 0 ||\n      pixelFormat < 0 || pixelFormat >= TJ_NUMPF)\n    THROW(\"Invalid argument\");\n\n  if (this->scanLimit) {\n    memset(&progress, 0, sizeof(struct my_progress_mgr));\n    progress.pub.progress_monitor = my_progress_monitor;\n    progress.this = this;\n    dinfo->progress = &progress.pub;\n  } else\n    dinfo->progress = NULL;\n\n  dinfo->mem->max_memory_to_use = (long)this->maxMemory * 1048576L;\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  if (dinfo->global_state <= DSTATE_INHEADER) {\n    jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);\n    jpeg_read_header(dinfo, TRUE);\n  }\n  setDecompParameters(this);\n  if (this->maxPixels &&\n      (unsigned long long)this->jpegWidth * this->jpegHeight >\n      (unsigned long long)this->maxPixels)\n    THROW(\"Image is too large\");\n  this->dinfo.out_color_space = pf2cs[pixelFormat];\n#if BITS_IN_JSAMPLE != 16\n  scaledWidth = TJSCALED(dinfo->image_width, this->scalingFactor);\n#endif\n  dinfo->do_fancy_upsampling = !this->fastUpsample;\n  this->dinfo.dct_method = this->fastDCT ? JDCT_FASTEST : JDCT_ISLOW;\n\n  dinfo->scale_num = this->scalingFactor.num;\n  dinfo->scale_denom = this->scalingFactor.denom;\n\n  jpeg_start_decompress(dinfo);\n\n#if BITS_IN_JSAMPLE != 16\n  if (this->croppingRegion.x != 0 ||\n      (this->croppingRegion.w != 0 && this->croppingRegion.w != scaledWidth)) {\n    JDIMENSION crop_x = this->croppingRegion.x;\n    JDIMENSION crop_w = this->croppingRegion.w;\n\n    _jpeg_crop_scanline(dinfo, &crop_x, &crop_w);\n    if ((int)crop_x != this->croppingRegion.x)\n      THROWI(\"Unexplained mismatch between specified (%d) and\\n\"\n             \"actual (%d) cropping region left boundary\",\n             this->croppingRegion.x, (int)crop_x);\n    if ((int)crop_w != this->croppingRegion.w)\n      THROWI(\"Unexplained mismatch between specified (%d) and\\n\"\n             \"actual (%d) cropping region width\",\n             this->croppingRegion.w, (int)crop_w);\n  }\n#endif\n\n  if (pitch == 0) pitch = dinfo->output_width * tjPixelSize[pixelFormat];\n\n  croppedHeight = dinfo->output_height;\n#if BITS_IN_JSAMPLE != 16\n  if (this->croppingRegion.y != 0 || this->croppingRegion.h != 0)\n    croppedHeight = this->croppingRegion.h;\n#endif\n  if ((row_pointer =\n       (_JSAMPROW *)malloc(sizeof(_JSAMPROW) * croppedHeight)) == NULL)\n    THROW(\"Memory allocation failure\");\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n  for (i = 0; i < (int)croppedHeight; i++) {\n    if (this->bottomUp)\n      row_pointer[i] = &dstBuf[(croppedHeight - i - 1) * (size_t)pitch];\n    else\n      row_pointer[i] = &dstBuf[i * (size_t)pitch];\n  }\n\n#if BITS_IN_JSAMPLE != 16\n  if (this->croppingRegion.y != 0 || this->croppingRegion.h != 0) {\n    if (this->croppingRegion.y != 0) {\n      JDIMENSION lines = _jpeg_skip_scanlines(dinfo, this->croppingRegion.y);\n\n      if ((int)lines != this->croppingRegion.y)\n        THROWI(\"Unexplained mismatch between specified (%d) and\\n\"\n               \"actual (%d) cropping region upper boundary\",\n               this->croppingRegion.y, (int)lines);\n    }\n    while ((int)dinfo->output_scanline <\n           this->croppingRegion.y + this->croppingRegion.h)\n      _jpeg_read_scanlines(dinfo, &row_pointer[dinfo->output_scanline -\n                                               this->croppingRegion.y],\n                           this->croppingRegion.y + this->croppingRegion.h -\n                           dinfo->output_scanline);\n    if (this->croppingRegion.y + this->croppingRegion.h !=\n        (int)dinfo->output_height) {\n      JDIMENSION lines = _jpeg_skip_scanlines(dinfo, dinfo->output_height -\n                                                     this->croppingRegion.y -\n                                                     this->croppingRegion.h);\n\n      if (lines != dinfo->output_height - this->croppingRegion.y -\n                   this->croppingRegion.h)\n        THROWI(\"Unexplained mismatch between specified (%d) and\\n\"\n               \"actual (%d) cropping region lower boundary\",\n               this->croppingRegion.y + this->croppingRegion.h,\n               (int)(dinfo->output_height - lines));\n    }\n  } else\n#endif\n  {\n    while (dinfo->output_scanline < dinfo->output_height)\n      _jpeg_read_scanlines(dinfo, &row_pointer[dinfo->output_scanline],\n                           dinfo->output_height - dinfo->output_scanline);\n  }\n  jpeg_finish_decompress(dinfo);\n\nbailout:\n  if (dinfo->global_state > DSTATE_START) jpeg_abort_decompress(dinfo);\n  free(row_pointer);\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n\n/*************************** Packed-Pixel Image I/O **************************/\n\n/* TurboJPEG 3+ */\nDLLEXPORT _JSAMPLE *GET_NAME(tj3LoadImage, BITS_IN_JSAMPLE)\n  (tjhandle handle, const char *filename, int *width, int align, int *height,\n   int *pixelFormat)\n{\n  static const char FUNCTION_NAME[] =\n    GET_STRING(tj3LoadImage, BITS_IN_JSAMPLE);\n\n#if BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED)\n\n  int retval = 0, tempc;\n  size_t pitch;\n  tjhandle handle2 = NULL;\n  tjinstance *this2;\n  j_compress_ptr cinfo = NULL;\n  cjpeg_source_ptr src;\n  _JSAMPLE *dstBuf = NULL;\n  FILE *file = NULL;\n  boolean invert;\n\n  GET_TJINSTANCE(handle, NULL)\n\n  if (!filename || !width || align < 1 || !height || !pixelFormat ||\n      *pixelFormat < TJPF_UNKNOWN || *pixelFormat >= TJ_NUMPF)\n    THROW(\"Invalid argument\");\n  if ((align & (align - 1)) != 0)\n    THROW(\"Alignment must be a power of 2\");\n\n  /* The instance handle passed to this function is used only for parameter\n     retrieval.  Create a new temporary instance to avoid interfering with the\n     libjpeg state of the primary instance. */\n  if ((handle2 = tj3Init(TJINIT_COMPRESS)) == NULL) return NULL;\n  this2 = (tjinstance *)handle2;\n  cinfo = &this2->cinfo;\n\n#ifdef _MSC_VER\n  if (fopen_s(&file, filename, \"rb\") || file == NULL)\n#else\n  if ((file = fopen(filename, \"rb\")) == NULL)\n#endif\n    THROW_UNIX(\"Cannot open input file\");\n\n  if ((tempc = getc(file)) < 0 || ungetc(tempc, file) == EOF)\n    THROW_UNIX(\"Could not read input file\")\n  else if (tempc == EOF)\n    THROW(\"Input file contains no data\");\n\n  if (setjmp(this2->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  cinfo->data_precision = BITS_IN_JSAMPLE;\n  if (*pixelFormat == TJPF_UNKNOWN) cinfo->in_color_space = JCS_UNKNOWN;\n  else cinfo->in_color_space = pf2cs[*pixelFormat];\n  if (tempc == 'B') {\n    if ((src = jinit_read_bmp(cinfo, FALSE)) == NULL)\n      THROW(\"Could not initialize bitmap loader\");\n    invert = !this->bottomUp;\n  } else if (tempc == 'P') {\n    if ((src = _jinit_read_ppm(cinfo)) == NULL)\n      THROW(\"Could not initialize PPM loader\");\n    invert = this->bottomUp;\n  } else\n    THROW(\"Unsupported file type\");\n\n  cinfo->mem->max_memory_to_use = (long)this->maxMemory * 1048576L;\n\n  src->input_file = file;\n  /* Refuse to load images larger than the specified size. */\n  src->max_pixels = this->maxPixels;\n  (*src->start_input) (cinfo, src);\n  if (tempc == 'B') {\n    if (cinfo->X_density && cinfo->Y_density) {\n      this->xDensity = cinfo->X_density;\n      this->yDensity = cinfo->Y_density;\n      this->densityUnits = cinfo->density_unit;\n    }\n  }\n  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr)cinfo);\n\n  *width = cinfo->image_width;  *height = cinfo->image_height;\n  *pixelFormat = cs2pf[cinfo->in_color_space];\n\n  pitch = PAD((*width) * tjPixelSize[*pixelFormat], align);\n  if (\n#if ULLONG_MAX > SIZE_MAX\n      (unsigned long long)pitch * (unsigned long long)(*height) >\n      (unsigned long long)((size_t)-1) ||\n#endif\n      (dstBuf = (_JSAMPLE *)malloc(pitch * (*height) *\n                                   sizeof(_JSAMPLE))) == NULL)\n    THROW(\"Memory allocation failure\");\n\n  if (setjmp(this2->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  while (cinfo->next_scanline < cinfo->image_height) {\n    int i, nlines = (*src->get_pixel_rows) (cinfo, src);\n\n    for (i = 0; i < nlines; i++) {\n      _JSAMPLE *dstptr;\n      int row;\n\n      row = cinfo->next_scanline + i;\n      if (invert) dstptr = &dstBuf[((*height) - row - 1) * pitch];\n      else dstptr = &dstBuf[row * pitch];\n      memcpy(dstptr, src->_buffer[i],\n             (*width) * tjPixelSize[*pixelFormat] * sizeof(_JSAMPLE));\n    }\n    cinfo->next_scanline += nlines;\n  }\n\n  (*src->finish_input) (cinfo, src);\n\nbailout:\n  tj3Destroy(handle2);\n  if (file) fclose(file);\n  if (retval < 0) { free(dstBuf);  dstBuf = NULL; }\n  return dstBuf;\n\n#else /* BITS_IN_JSAMPLE != 16 || defined(C_LOSSLESS_SUPPORTED) */\n\n  static const char ERROR_MSG[] =\n    \"16-bit data precision requires lossless JPEG,\\n\"\n    \"which was disabled at build time.\";\n  _JSAMPLE *retval = NULL;\n\n  GET_TJINSTANCE(handle, NULL)\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"%s(): %s\", FUNCTION_NAME,\n           ERROR_MSG);\n  this->isInstanceError = TRUE;  THROWG(ERROR_MSG, NULL)\n\nbailout:\n  return retval;\n\n#endif\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int GET_NAME(tj3SaveImage, BITS_IN_JSAMPLE)\n  (tjhandle handle, const char *filename, const _JSAMPLE *buffer, int width,\n   int pitch, int height, int pixelFormat)\n{\n  static const char FUNCTION_NAME[] =\n    GET_STRING(tj3SaveImage, BITS_IN_JSAMPLE);\n  int retval = 0;\n\n#if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)\n\n  tjhandle handle2 = NULL;\n  tjinstance *this2;\n  j_decompress_ptr dinfo = NULL;\n  djpeg_dest_ptr dst;\n  FILE *file = NULL;\n  char *ptr = NULL;\n  boolean invert;\n\n  GET_TJINSTANCE(handle, -1)\n\n  if (!filename || !buffer || width < 1 || pitch < 0 || height < 1 ||\n      pixelFormat < 0 || pixelFormat >= TJ_NUMPF)\n    THROW(\"Invalid argument\");\n\n  /* The instance handle passed to this function is used only for parameter\n     retrieval.  Create a new temporary instance to avoid interfering with the\n     libjpeg state of the primary instance. */\n  if ((handle2 = tj3Init(TJINIT_DECOMPRESS)) == NULL)\n    return -1;\n  this2 = (tjinstance *)handle2;\n  dinfo = &this2->dinfo;\n\n#ifdef _MSC_VER\n  if (fopen_s(&file, filename, \"wb\") || file == NULL)\n#else\n  if ((file = fopen(filename, \"wb\")) == NULL)\n#endif\n    THROW_UNIX(\"Cannot open output file\");\n\n  if (setjmp(this2->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  this2->dinfo.out_color_space = pf2cs[pixelFormat];\n  dinfo->image_width = width;  dinfo->image_height = height;\n  dinfo->global_state = DSTATE_READY;\n  dinfo->scale_num = dinfo->scale_denom = 1;\n  dinfo->data_precision = BITS_IN_JSAMPLE;\n\n  ptr = strrchr(filename, '.');\n  if (ptr && !strcasecmp(ptr, \".bmp\")) {\n    if ((dst = jinit_write_bmp(dinfo, FALSE, FALSE)) == NULL)\n      THROW(\"Could not initialize bitmap writer\");\n    invert = !this->bottomUp;\n    dinfo->X_density = (UINT16)this->xDensity;\n    dinfo->Y_density = (UINT16)this->yDensity;\n    dinfo->density_unit = (UINT8)this->densityUnits;\n  } else {\n    if ((dst = _jinit_write_ppm(dinfo)) == NULL)\n      THROW(\"Could not initialize PPM writer\");\n    invert = this->bottomUp;\n  }\n\n  dinfo->mem->max_memory_to_use = (long)this->maxMemory * 1048576L;\n\n  dst->output_file = file;\n  (*dst->start_output) (dinfo, dst);\n  (*dinfo->mem->realize_virt_arrays) ((j_common_ptr)dinfo);\n\n  if (pitch == 0) pitch = width * tjPixelSize[pixelFormat];\n\n  while (dinfo->output_scanline < dinfo->output_height) {\n    _JSAMPLE *rowptr;\n\n    if (invert)\n      rowptr =\n        (_JSAMPLE *)&buffer[(height - dinfo->output_scanline - 1) * pitch];\n    else\n      rowptr = (_JSAMPLE *)&buffer[dinfo->output_scanline * pitch];\n    memcpy(dst->_buffer[0], rowptr,\n           width * tjPixelSize[pixelFormat] * sizeof(_JSAMPLE));\n    (*dst->put_pixel_rows) (dinfo, dst, 1);\n    dinfo->output_scanline++;\n  }\n\n  (*dst->finish_output) (dinfo, dst);\n\nbailout:\n  tj3Destroy(handle2);\n  if (file) fclose(file);\n  return retval;\n\n#else /* BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED) */\n\n  GET_TJINSTANCE(handle, -1)\n  THROW(\"16-bit data precision requires lossless JPEG,\\n\"\n        \"which was disabled at build time.\")\nbailout:\n  return retval;\n\n#endif\n}\n\n\n#undef _JSAMPLE\n#undef _JSAMPROW\n#undef _buffer\n#undef _jinit_read_ppm\n#undef _jinit_write_ppm\n#undef _jpeg_crop_scanline\n#undef _jpeg_read_scanlines\n#undef _jpeg_skip_scanlines\n#undef _jpeg_write_scanlines\n"
        },
        {
          "name": "turbojpeg.c",
          "type": "blob",
          "size": 93.4873046875,
          "content": "/*\n * Copyright (C)2009-2024 D. R. Commander.  All Rights Reserved.\n * Copyright (C)2021 Alex Richardson.  All Rights Reserved.\n * Copyright (C) 2014, Mozilla Corporation.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* TurboJPEG/LJT:  this implements the TurboJPEG API using libjpeg or\n   libjpeg-turbo */\n\n#include <ctype.h>\n#include <limits.h>\n#if !defined(_MSC_VER) || _MSC_VER > 1600\n#include <stdint.h>\n#endif\n#include <jinclude.h>\n#define JPEG_INTERNALS\n#include <jpeglib.h>\n#include <jerror.h>\n#include <setjmp.h>\n#include <errno.h>\n#include \"./turbojpeg.h\"\n#include \"./tjutil.h\"\n#include \"transupp.h\"\n#include \"./jpegapicomp.h\"\n#include \"./cdjpeg.h\"\n\nextern void jpeg_mem_dest_tj(j_compress_ptr, unsigned char **, size_t *,\n                             boolean);\nextern void jpeg_mem_src_tj(j_decompress_ptr, const unsigned char *, size_t);\n\n#define PAD(v, p)  ((v + (p) - 1) & (~((p) - 1)))\n#define IS_POW2(x)  (((x) & (x - 1)) == 0)\n\n\n/* Error handling (based on example in example.c) */\n\nstatic THREAD_LOCAL char errStr[JMSG_LENGTH_MAX] = \"No error\";\n\nstruct my_error_mgr {\n  struct jpeg_error_mgr pub;\n  jmp_buf setjmp_buffer;\n  void (*emit_message) (j_common_ptr, int);\n  boolean warning, stopOnWarning;\n};\ntypedef struct my_error_mgr *my_error_ptr;\n\n#define JMESSAGE(code, string)  string,\nstatic const char *turbojpeg_message_table[] = {\n#include \"cderror.h\"\n  NULL\n};\n\nstatic void my_error_exit(j_common_ptr cinfo)\n{\n  my_error_ptr myerr = (my_error_ptr)cinfo->err;\n\n  (*cinfo->err->output_message) (cinfo);\n  longjmp(myerr->setjmp_buffer, 1);\n}\n\n/* Based on output_message() in jerror.c */\n\nstatic void my_output_message(j_common_ptr cinfo)\n{\n  (*cinfo->err->format_message) (cinfo, errStr);\n}\n\nstatic void my_emit_message(j_common_ptr cinfo, int msg_level)\n{\n  my_error_ptr myerr = (my_error_ptr)cinfo->err;\n\n  myerr->emit_message(cinfo, msg_level);\n  if (msg_level < 0) {\n    myerr->warning = TRUE;\n    if (myerr->stopOnWarning) longjmp(myerr->setjmp_buffer, 1);\n  }\n}\n\n\n/********************** Global structures, macros, etc. **********************/\n\nenum { COMPRESS = 1, DECOMPRESS = 2 };\n\ntypedef struct _tjinstance {\n  struct jpeg_compress_struct cinfo;\n  struct jpeg_decompress_struct dinfo;\n  struct my_error_mgr jerr;\n  int init;\n  char errStr[JMSG_LENGTH_MAX];\n  boolean isInstanceError;\n  /* Parameters */\n  boolean bottomUp;\n  boolean noRealloc;\n  int quality;\n  int subsamp;\n  int jpegWidth;\n  int jpegHeight;\n  int precision;\n  int colorspace;\n  boolean fastUpsample;\n  boolean fastDCT;\n  boolean optimize;\n  boolean progressive;\n  int scanLimit;\n  boolean arithmetic;\n  boolean lossless;\n  int losslessPSV;\n  int losslessPt;\n  int restartIntervalBlocks;\n  int restartIntervalRows;\n  int xDensity;\n  int yDensity;\n  int densityUnits;\n  tjscalingfactor scalingFactor;\n  tjregion croppingRegion;\n  int maxMemory;\n  int maxPixels;\n} tjinstance;\n\nstatic tjhandle _tjInitCompress(tjinstance *this);\nstatic tjhandle _tjInitDecompress(tjinstance *this);\n\nstruct my_progress_mgr {\n  struct jpeg_progress_mgr pub;\n  tjinstance *this;\n};\ntypedef struct my_progress_mgr *my_progress_ptr;\n\nstatic void my_progress_monitor(j_common_ptr dinfo)\n{\n  my_error_ptr myerr = (my_error_ptr)dinfo->err;\n  my_progress_ptr myprog = (my_progress_ptr)dinfo->progress;\n\n  if (dinfo->is_decompressor) {\n    int scan_no = ((j_decompress_ptr)dinfo)->input_scan_number;\n\n    if (scan_no > myprog->this->scanLimit) {\n      SNPRINTF(myprog->this->errStr, JMSG_LENGTH_MAX,\n               \"Progressive JPEG image has more than %d scans\",\n               myprog->this->scanLimit);\n      SNPRINTF(errStr, JMSG_LENGTH_MAX,\n               \"Progressive JPEG image has more than %d scans\",\n               myprog->this->scanLimit);\n      myprog->this->isInstanceError = TRUE;\n      myerr->warning = FALSE;\n      longjmp(myerr->setjmp_buffer, 1);\n    }\n  }\n}\n\nstatic const JXFORM_CODE xformtypes[TJ_NUMXOP] = {\n  JXFORM_NONE, JXFORM_FLIP_H, JXFORM_FLIP_V, JXFORM_TRANSPOSE,\n  JXFORM_TRANSVERSE, JXFORM_ROT_90, JXFORM_ROT_180, JXFORM_ROT_270\n};\n\n#define NUMSF  16\nstatic const tjscalingfactor sf[NUMSF] = {\n  { 2, 1 },\n  { 15, 8 },\n  { 7, 4 },\n  { 13, 8 },\n  { 3, 2 },\n  { 11, 8 },\n  { 5, 4 },\n  { 9, 8 },\n  { 1, 1 },\n  { 7, 8 },\n  { 3, 4 },\n  { 5, 8 },\n  { 1, 2 },\n  { 3, 8 },\n  { 1, 4 },\n  { 1, 8 }\n};\n\nstatic J_COLOR_SPACE pf2cs[TJ_NUMPF] = {\n  JCS_EXT_RGB, JCS_EXT_BGR, JCS_EXT_RGBX, JCS_EXT_BGRX, JCS_EXT_XBGR,\n  JCS_EXT_XRGB, JCS_GRAYSCALE, JCS_EXT_RGBA, JCS_EXT_BGRA, JCS_EXT_ABGR,\n  JCS_EXT_ARGB, JCS_CMYK\n};\n\nstatic int cs2pf[JPEG_NUMCS] = {\n  TJPF_UNKNOWN, TJPF_GRAY,\n#if RGB_RED == 0 && RGB_GREEN == 1 && RGB_BLUE == 2 && RGB_PIXELSIZE == 3\n  TJPF_RGB,\n#elif RGB_RED == 2 && RGB_GREEN == 1 && RGB_BLUE == 0 && RGB_PIXELSIZE == 3\n  TJPF_BGR,\n#elif RGB_RED == 0 && RGB_GREEN == 1 && RGB_BLUE == 2 && RGB_PIXELSIZE == 4\n  TJPF_RGBX,\n#elif RGB_RED == 2 && RGB_GREEN == 1 && RGB_BLUE == 0 && RGB_PIXELSIZE == 4\n  TJPF_BGRX,\n#elif RGB_RED == 3 && RGB_GREEN == 2 && RGB_BLUE == 1 && RGB_PIXELSIZE == 4\n  TJPF_XBGR,\n#elif RGB_RED == 1 && RGB_GREEN == 2 && RGB_BLUE == 3 && RGB_PIXELSIZE == 4\n  TJPF_XRGB,\n#endif\n  TJPF_UNKNOWN, TJPF_CMYK, TJPF_UNKNOWN, TJPF_RGB, TJPF_RGBX, TJPF_BGR,\n  TJPF_BGRX, TJPF_XBGR, TJPF_XRGB, TJPF_RGBA, TJPF_BGRA, TJPF_ABGR, TJPF_ARGB,\n  TJPF_UNKNOWN\n};\n\n#define THROWG(m, rv) { \\\n  SNPRINTF(errStr, JMSG_LENGTH_MAX, \"%s(): %s\", FUNCTION_NAME, m); \\\n  retval = rv;  goto bailout; \\\n}\n#ifdef _MSC_VER\n#define THROW_UNIX(m) { \\\n  char strerrorBuf[80] = { 0 }; \\\n  strerror_s(strerrorBuf, 80, errno); \\\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"%s(): %s\\n%s\", FUNCTION_NAME, m, \\\n           strerrorBuf); \\\n  this->isInstanceError = TRUE; \\\n  SNPRINTF(errStr, JMSG_LENGTH_MAX, \"%s(): %s\\n%s\", FUNCTION_NAME, m, \\\n           strerrorBuf); \\\n  retval = -1;  goto bailout; \\\n}\n#else\n#define THROW_UNIX(m) { \\\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"%s(): %s\\n%s\", FUNCTION_NAME, m, \\\n           strerror(errno)); \\\n  this->isInstanceError = TRUE; \\\n  SNPRINTF(errStr, JMSG_LENGTH_MAX, \"%s(): %s\\n%s\", FUNCTION_NAME, m, \\\n           strerror(errno)); \\\n  retval = -1;  goto bailout; \\\n}\n#endif\n#define THROW(m) { \\\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"%s(): %s\", FUNCTION_NAME, m); \\\n  this->isInstanceError = TRUE;  THROWG(m, -1) \\\n}\n#define THROWI(format, val1, val2) { \\\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"%s(): \" format, FUNCTION_NAME, \\\n           val1, val2); \\\n  this->isInstanceError = TRUE; \\\n  SNPRINTF(errStr, JMSG_LENGTH_MAX, \"%s(): \" format, FUNCTION_NAME, val1, \\\n           val2); \\\n  retval = -1;  goto bailout; \\\n}\n\n#define GET_INSTANCE(handle) \\\n  tjinstance *this = (tjinstance *)handle; \\\n  j_compress_ptr cinfo = NULL; \\\n  j_decompress_ptr dinfo = NULL; \\\n  \\\n  if (!this) { \\\n    SNPRINTF(errStr, JMSG_LENGTH_MAX, \"%s(): Invalid handle\", FUNCTION_NAME); \\\n    return -1; \\\n  } \\\n  cinfo = &this->cinfo;  dinfo = &this->dinfo; \\\n  this->jerr.warning = FALSE; \\\n  this->isInstanceError = FALSE;\n\n#define GET_CINSTANCE(handle) \\\n  tjinstance *this = (tjinstance *)handle; \\\n  j_compress_ptr cinfo = NULL; \\\n  \\\n  if (!this) { \\\n    SNPRINTF(errStr, JMSG_LENGTH_MAX, \"%s(): Invalid handle\", FUNCTION_NAME); \\\n    return -1; \\\n  } \\\n  cinfo = &this->cinfo; \\\n  this->jerr.warning = FALSE; \\\n  this->isInstanceError = FALSE;\n\n#define GET_DINSTANCE(handle) \\\n  tjinstance *this = (tjinstance *)handle; \\\n  j_decompress_ptr dinfo = NULL; \\\n  \\\n  if (!this) { \\\n    SNPRINTF(errStr, JMSG_LENGTH_MAX, \"%s(): Invalid handle\", FUNCTION_NAME); \\\n    return -1; \\\n  } \\\n  dinfo = &this->dinfo; \\\n  this->jerr.warning = FALSE; \\\n  this->isInstanceError = FALSE;\n\n#define GET_TJINSTANCE(handle, errorReturn) \\\n  tjinstance *this = (tjinstance *)handle; \\\n  \\\n  if (!this) { \\\n    SNPRINTF(errStr, JMSG_LENGTH_MAX, \"%s(): Invalid handle\", FUNCTION_NAME); \\\n    return errorReturn; \\\n  } \\\n  this->jerr.warning = FALSE; \\\n  this->isInstanceError = FALSE;\n\nstatic int getPixelFormat(int pixelSize, int flags)\n{\n  if (pixelSize == 1) return TJPF_GRAY;\n  if (pixelSize == 3) {\n    if (flags & TJ_BGR) return TJPF_BGR;\n    else return TJPF_RGB;\n  }\n  if (pixelSize == 4) {\n    if (flags & TJ_ALPHAFIRST) {\n      if (flags & TJ_BGR) return TJPF_XBGR;\n      else return TJPF_XRGB;\n    } else {\n      if (flags & TJ_BGR) return TJPF_BGRX;\n      else return TJPF_RGBX;\n    }\n  }\n  return -1;\n}\n\nstatic void setCompDefaults(tjinstance *this, int pixelFormat)\n{\n  int subsamp = this->subsamp;\n\n  this->cinfo.in_color_space = pf2cs[pixelFormat];\n  this->cinfo.input_components = tjPixelSize[pixelFormat];\n  jpeg_c_set_int_param(&this->cinfo, JINT_COMPRESS_PROFILE, JCP_FASTEST);\n  jpeg_set_defaults(&this->cinfo);\n\n  this->cinfo.restart_interval = this->restartIntervalBlocks;\n  this->cinfo.restart_in_rows = this->restartIntervalRows;\n  this->cinfo.X_density = (UINT16)this->xDensity;\n  this->cinfo.Y_density = (UINT16)this->yDensity;\n  this->cinfo.density_unit = (UINT8)this->densityUnits;\n  this->cinfo.mem->max_memory_to_use = (long)this->maxMemory * 1048576L;\n\n  if (this->lossless) {\n#ifdef C_LOSSLESS_SUPPORTED\n    jpeg_enable_lossless(&this->cinfo, this->losslessPSV, this->losslessPt);\n#endif\n    if (pixelFormat == TJPF_GRAY)\n      subsamp = TJSAMP_GRAY;\n    else if (subsamp != TJSAMP_GRAY)\n      subsamp = TJSAMP_444;\n    return;\n  }\n\n  jpeg_set_quality(&this->cinfo, this->quality, TRUE);\n  this->cinfo.dct_method = this->fastDCT ? JDCT_FASTEST : JDCT_ISLOW;\n\n  switch (this->colorspace) {\n  case TJCS_RGB:\n    jpeg_set_colorspace(&this->cinfo, JCS_RGB);  break;\n  case TJCS_YCbCr:\n    jpeg_set_colorspace(&this->cinfo, JCS_YCbCr);  break;\n  case TJCS_GRAY:\n    jpeg_set_colorspace(&this->cinfo, JCS_GRAYSCALE);  break;\n  case TJCS_CMYK:\n    jpeg_set_colorspace(&this->cinfo, JCS_CMYK);  break;\n  case TJCS_YCCK:\n    jpeg_set_colorspace(&this->cinfo, JCS_YCCK);  break;\n  default:\n    if (subsamp == TJSAMP_GRAY)\n      jpeg_set_colorspace(&this->cinfo, JCS_GRAYSCALE);\n    else if (pixelFormat == TJPF_CMYK)\n      jpeg_set_colorspace(&this->cinfo, JCS_YCCK);\n    else\n      jpeg_set_colorspace(&this->cinfo, JCS_YCbCr);\n  }\n\n  if (this->cinfo.data_precision == 8)\n    this->cinfo.optimize_coding = this->optimize;\n#ifdef C_PROGRESSIVE_SUPPORTED\n  if (this->progressive) jpeg_simple_progression(&this->cinfo);\n#endif\n  this->cinfo.arith_code = this->arithmetic;\n\n  this->cinfo.comp_info[0].h_samp_factor = tjMCUWidth[subsamp] / 8;\n  this->cinfo.comp_info[1].h_samp_factor = 1;\n  this->cinfo.comp_info[2].h_samp_factor = 1;\n  if (this->cinfo.num_components > 3)\n    this->cinfo.comp_info[3].h_samp_factor = tjMCUWidth[subsamp] / 8;\n  this->cinfo.comp_info[0].v_samp_factor = tjMCUHeight[subsamp] / 8;\n  this->cinfo.comp_info[1].v_samp_factor = 1;\n  this->cinfo.comp_info[2].v_samp_factor = 1;\n  if (this->cinfo.num_components > 3)\n    this->cinfo.comp_info[3].v_samp_factor = tjMCUHeight[subsamp] / 8;\n}\n\n\nstatic int getSubsamp(j_decompress_ptr dinfo)\n{\n  int retval = TJSAMP_UNKNOWN, i, k;\n\n  /* The sampling factors actually have no meaning with grayscale JPEG files,\n     and in fact it's possible to generate grayscale JPEGs with sampling\n     factors > 1 (even though those sampling factors are ignored by the\n     decompressor.)  Thus, we need to treat grayscale as a special case. */\n  if (dinfo->num_components == 1 && dinfo->jpeg_color_space == JCS_GRAYSCALE)\n    return TJSAMP_GRAY;\n\n  for (i = 0; i < TJ_NUMSAMP; i++) {\n    if (i == TJSAMP_GRAY) continue;\n\n    if (dinfo->num_components == 3 ||\n        ((dinfo->jpeg_color_space == JCS_YCCK ||\n          dinfo->jpeg_color_space == JCS_CMYK) &&\n         dinfo->num_components == 4)) {\n      if (dinfo->comp_info[0].h_samp_factor == tjMCUWidth[i] / 8 &&\n          dinfo->comp_info[0].v_samp_factor == tjMCUHeight[i] / 8) {\n        int match = 0;\n\n        for (k = 1; k < dinfo->num_components; k++) {\n          int href = 1, vref = 1;\n\n          if ((dinfo->jpeg_color_space == JCS_YCCK ||\n               dinfo->jpeg_color_space == JCS_CMYK) && k == 3) {\n            href = tjMCUWidth[i] / 8;  vref = tjMCUHeight[i] / 8;\n          }\n          if (dinfo->comp_info[k].h_samp_factor == href &&\n              dinfo->comp_info[k].v_samp_factor == vref)\n            match++;\n        }\n        if (match == dinfo->num_components - 1) {\n          retval = i;  break;\n        }\n      }\n      /* Handle 4:2:2 and 4:4:0 images whose sampling factors are specified\n         in non-standard ways. */\n      if (dinfo->comp_info[0].h_samp_factor == 2 &&\n          dinfo->comp_info[0].v_samp_factor == 2 &&\n          (i == TJSAMP_422 || i == TJSAMP_440)) {\n        int match = 0;\n\n        for (k = 1; k < dinfo->num_components; k++) {\n          int href = tjMCUHeight[i] / 8, vref = tjMCUWidth[i] / 8;\n\n          if ((dinfo->jpeg_color_space == JCS_YCCK ||\n               dinfo->jpeg_color_space == JCS_CMYK) && k == 3) {\n            href = vref = 2;\n          }\n          if (dinfo->comp_info[k].h_samp_factor == href &&\n              dinfo->comp_info[k].v_samp_factor == vref)\n            match++;\n        }\n        if (match == dinfo->num_components - 1) {\n          retval = i;  break;\n        }\n      }\n      /* Handle 4:4:4 images whose sampling factors are specified in\n         non-standard ways. */\n      if (dinfo->comp_info[0].h_samp_factor *\n          dinfo->comp_info[0].v_samp_factor <=\n          D_MAX_BLOCKS_IN_MCU / 3 && i == TJSAMP_444) {\n        int match = 0;\n        for (k = 1; k < dinfo->num_components; k++) {\n          if (dinfo->comp_info[k].h_samp_factor ==\n              dinfo->comp_info[0].h_samp_factor &&\n              dinfo->comp_info[k].v_samp_factor ==\n              dinfo->comp_info[0].v_samp_factor)\n            match++;\n          if (match == dinfo->num_components - 1) {\n            retval = i;  break;\n          }\n        }\n      }\n    }\n  }\n  return retval;\n}\n\n\nstatic void setDecompParameters(tjinstance *this)\n{\n  this->subsamp = getSubsamp(&this->dinfo);\n  this->jpegWidth = this->dinfo.image_width;\n  this->jpegHeight = this->dinfo.image_height;\n  this->precision = this->dinfo.data_precision;\n  switch (this->dinfo.jpeg_color_space) {\n  case JCS_GRAYSCALE:  this->colorspace = TJCS_GRAY;  break;\n  case JCS_RGB:        this->colorspace = TJCS_RGB;  break;\n  case JCS_YCbCr:      this->colorspace = TJCS_YCbCr;  break;\n  case JCS_CMYK:       this->colorspace = TJCS_CMYK;  break;\n  case JCS_YCCK:       this->colorspace = TJCS_YCCK;  break;\n  default:             this->colorspace = -1;  break;\n  }\n  this->progressive = this->dinfo.progressive_mode;\n  this->arithmetic = this->dinfo.arith_code;\n  this->lossless = this->dinfo.master->lossless;\n  this->losslessPSV = this->dinfo.Ss;\n  this->losslessPt = this->dinfo.Al;\n  this->xDensity = this->dinfo.X_density;\n  this->yDensity = this->dinfo.Y_density;\n  this->densityUnits = this->dinfo.density_unit;\n}\n\n\nstatic void processFlags(tjhandle handle, int flags, int operation)\n{\n  tjinstance *this = (tjinstance *)handle;\n\n  this->bottomUp = !!(flags & TJFLAG_BOTTOMUP);\n\n#ifndef NO_PUTENV\n  if (flags & TJFLAG_FORCEMMX) PUTENV_S(\"JSIMD_FORCEMMX\", \"1\");\n  else if (flags & TJFLAG_FORCESSE) PUTENV_S(\"JSIMD_FORCESSE\", \"1\");\n  else if (flags & TJFLAG_FORCESSE2) PUTENV_S(\"JSIMD_FORCESSE2\", \"1\");\n#endif\n\n  this->fastUpsample = !!(flags & TJFLAG_FASTUPSAMPLE);\n  this->noRealloc = !!(flags & TJFLAG_NOREALLOC);\n\n  if (operation == COMPRESS) {\n    if (this->quality >= 96 || flags & TJFLAG_ACCURATEDCT)\n      this->fastDCT = FALSE;\n    else\n      this->fastDCT = TRUE;\n  } else\n    this->fastDCT = !!(flags & TJFLAG_FASTDCT);\n\n  this->jerr.stopOnWarning = !!(flags & TJFLAG_STOPONWARNING);\n  this->progressive = !!(flags & TJFLAG_PROGRESSIVE);\n\n  if (flags & TJFLAG_LIMITSCANS) this->scanLimit = 500;\n}\n\n\n/*************************** General API functions ***************************/\n\n/* TurboJPEG 3+ */\nDLLEXPORT tjhandle tj3Init(int initType)\n{\n  static const char FUNCTION_NAME[] = \"tj3Init\";\n  tjinstance *this = NULL;\n  tjhandle retval = NULL;\n\n  if (initType < 0 || initType >= TJ_NUMINIT)\n    THROWG(\"Invalid argument\", NULL);\n\n  if ((this = (tjinstance *)malloc(sizeof(tjinstance))) == NULL)\n    THROWG(\"Memory allocation failure\", NULL);\n  memset(this, 0, sizeof(tjinstance));\n  SNPRINTF(this->errStr, JMSG_LENGTH_MAX, \"No error\");\n\n  this->quality = -1;\n  this->subsamp = TJSAMP_UNKNOWN;\n  this->jpegWidth = -1;\n  this->jpegHeight = -1;\n  this->precision = 8;\n  this->colorspace = -1;\n  this->losslessPSV = 1;\n  this->xDensity = 1;\n  this->yDensity = 1;\n  this->scalingFactor = TJUNSCALED;\n\n  switch (initType) {\n  case TJINIT_COMPRESS:  return _tjInitCompress(this);\n  case TJINIT_DECOMPRESS:  return _tjInitDecompress(this);\n  case TJINIT_TRANSFORM:\n    retval = _tjInitCompress(this);\n    if (!retval) return NULL;\n    retval = _tjInitDecompress(this);\n    return retval;\n  }\n\nbailout:\n  return retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT void tj3Destroy(tjhandle handle)\n{\n  tjinstance *this = (tjinstance *)handle;\n  j_compress_ptr cinfo = NULL;\n  j_decompress_ptr dinfo = NULL;\n\n  if (!this) return;\n\n  cinfo = &this->cinfo;  dinfo = &this->dinfo;\n  this->jerr.warning = FALSE;\n  this->isInstanceError = FALSE;\n\n  if (setjmp(this->jerr.setjmp_buffer)) return;\n  if (this->init & COMPRESS) jpeg_destroy_compress(cinfo);\n  if (this->init & DECOMPRESS) jpeg_destroy_decompress(dinfo);\n  free(this);\n}\n\n/* TurboJPEG 1.0+ */\nDLLEXPORT int tjDestroy(tjhandle handle)\n{\n  static const char FUNCTION_NAME[] = \"tjDestroy\";\n  int retval = 0;\n\n  if (!handle) THROWG(\"Invalid handle\", -1);\n\n  SNPRINTF(errStr, JMSG_LENGTH_MAX, \"No error\");\n  tj3Destroy(handle);\n  if (strcmp(errStr, \"No error\")) retval = -1;\n\nbailout:\n  return retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT char *tj3GetErrorStr(tjhandle handle)\n{\n  tjinstance *this = (tjinstance *)handle;\n\n  if (this && this->isInstanceError) {\n    this->isInstanceError = FALSE;\n    return this->errStr;\n  } else\n    return errStr;\n}\n\n/* TurboJPEG 2.0+ */\nDLLEXPORT char *tjGetErrorStr2(tjhandle handle)\n{\n  return tj3GetErrorStr(handle);\n}\n\n/* TurboJPEG 1.0+ */\nDLLEXPORT char *tjGetErrorStr(void)\n{\n  return errStr;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3GetErrorCode(tjhandle handle)\n{\n  tjinstance *this = (tjinstance *)handle;\n\n  if (this && this->jerr.warning) return TJERR_WARNING;\n  else return TJERR_FATAL;\n}\n\n/* TurboJPEG 2.0+ */\nDLLEXPORT int tjGetErrorCode(tjhandle handle)\n{\n  return tj3GetErrorCode(handle);\n}\n\n\n#define SET_PARAM(field, minValue, maxValue) { \\\n  if (value < minValue || (maxValue > 0 && value > maxValue)) \\\n    THROW(\"Parameter value out of range\"); \\\n  this->field = value; \\\n}\n\n#define SET_BOOL_PARAM(field) { \\\n  if (value < 0 || value > 1) \\\n    THROW(\"Parameter value out of range\"); \\\n  this->field = (boolean)value; \\\n}\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3Set(tjhandle handle, int param, int value)\n{\n  static const char FUNCTION_NAME[] = \"tj3Set\";\n  int retval = 0;\n\n  GET_TJINSTANCE(handle, -1);\n\n  switch (param) {\n  case TJPARAM_STOPONWARNING:\n    SET_BOOL_PARAM(jerr.stopOnWarning);\n    break;\n  case TJPARAM_BOTTOMUP:\n    SET_BOOL_PARAM(bottomUp);\n    break;\n  case TJPARAM_NOREALLOC:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_NOREALLOC is not applicable to decompression instances.\");\n    SET_BOOL_PARAM(noRealloc);\n    break;\n  case TJPARAM_QUALITY:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_QUALITY is not applicable to decompression instances.\");\n    SET_PARAM(quality, 1, 100);\n    break;\n  case TJPARAM_SUBSAMP:\n    SET_PARAM(subsamp, 0, TJ_NUMSAMP - 1);\n    break;\n  case TJPARAM_JPEGWIDTH:\n    if (!(this->init & DECOMPRESS))\n      THROW(\"TJPARAM_JPEGWIDTH is not applicable to compression instances.\");\n    THROW(\"TJPARAM_JPEGWIDTH is read-only in decompression instances.\");\n    break;\n  case TJPARAM_JPEGHEIGHT:\n    if (!(this->init & DECOMPRESS))\n      THROW(\"TJPARAM_JPEGHEIGHT is not applicable to compression instances.\");\n    THROW(\"TJPARAM_JPEGHEIGHT is read-only in decompression instances.\");\n    break;\n  case TJPARAM_PRECISION:\n    if (!(this->init & DECOMPRESS))\n      THROW(\"TJPARAM_PRECISION is not applicable to compression instances.\");\n    THROW(\"TJPARAM_PRECISION is read-only in decompression instances.\");\n    break;\n  case TJPARAM_COLORSPACE:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_COLORSPACE is read-only in decompression instances.\");\n    SET_PARAM(colorspace, 0, TJ_NUMCS - 1);\n    break;\n  case TJPARAM_FASTUPSAMPLE:\n    if (!(this->init & DECOMPRESS))\n      THROW(\"TJPARAM_FASTUPSAMPLE is not applicable to compression instances.\");\n    SET_BOOL_PARAM(fastUpsample);\n    break;\n  case TJPARAM_FASTDCT:\n    SET_BOOL_PARAM(fastDCT);\n    break;\n  case TJPARAM_OPTIMIZE:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_OPTIMIZE is not applicable to decompression instances.\");\n    SET_BOOL_PARAM(optimize);\n    break;\n  case TJPARAM_PROGRESSIVE:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_PROGRESSIVE is read-only in decompression instances.\");\n    SET_BOOL_PARAM(progressive);\n    break;\n  case TJPARAM_SCANLIMIT:\n    if (!(this->init & DECOMPRESS))\n      THROW(\"TJPARAM_SCANLIMIT is not applicable to compression instances.\");\n    SET_PARAM(scanLimit, 0, -1);\n    break;\n  case TJPARAM_ARITHMETIC:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_ARITHMETIC is read-only in decompression instances.\");\n    SET_BOOL_PARAM(arithmetic);\n    break;\n  case TJPARAM_LOSSLESS:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_LOSSLESS is read-only in decompression instances.\");\n    SET_BOOL_PARAM(lossless);\n    break;\n  case TJPARAM_LOSSLESSPSV:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_LOSSLESSPSV is read-only in decompression instances.\");\n    SET_PARAM(losslessPSV, 1, 7);\n    break;\n  case TJPARAM_LOSSLESSPT:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_LOSSLESSPT is read-only in decompression instances.\");\n    SET_PARAM(losslessPt, 0, 15);\n    break;\n  case TJPARAM_RESTARTBLOCKS:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_RESTARTBLOCKS is not applicable to decompression instances.\");\n    SET_PARAM(restartIntervalBlocks, 0, 65535);\n    if (value != 0) this->restartIntervalRows = 0;\n    break;\n  case TJPARAM_RESTARTROWS:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_RESTARTROWS is not applicable to decompression instances.\");\n    SET_PARAM(restartIntervalRows, 0, 65535);\n    if (value != 0) this->restartIntervalBlocks = 0;\n    break;\n  case TJPARAM_XDENSITY:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_XDENSITY is read-only in decompression instances.\");\n    SET_PARAM(xDensity, 1, 65535);\n    break;\n  case TJPARAM_YDENSITY:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_YDENSITY is read-only in decompression instances.\");\n    SET_PARAM(yDensity, 1, 65535);\n    break;\n  case TJPARAM_DENSITYUNITS:\n    if (!(this->init & COMPRESS))\n      THROW(\"TJPARAM_DENSITYUNITS is read-only in decompression instances.\");\n    SET_PARAM(densityUnits, 0, 2);\n    break;\n  case TJPARAM_MAXMEMORY:\n    SET_PARAM(maxMemory, 0, (int)(min(LONG_MAX / 1048576L, (long)INT_MAX)));\n    break;\n  case TJPARAM_MAXPIXELS:\n    SET_PARAM(maxPixels, 0, -1);\n    break;\n  default:\n    THROW(\"Invalid parameter\");\n  }\n\nbailout:\n  return retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3Get(tjhandle handle, int param)\n{\n  tjinstance *this = (tjinstance *)handle;\n  if (!this) return -1;\n\n  switch (param) {\n  case TJPARAM_STOPONWARNING:\n    return this->jerr.stopOnWarning;\n  case TJPARAM_BOTTOMUP:\n    return this->bottomUp;\n  case TJPARAM_NOREALLOC:\n    return this->noRealloc;\n  case TJPARAM_QUALITY:\n    return this->quality;\n  case TJPARAM_SUBSAMP:\n    return this->subsamp;\n  case TJPARAM_JPEGWIDTH:\n    return this->jpegWidth;\n  case TJPARAM_JPEGHEIGHT:\n    return this->jpegHeight;\n  case TJPARAM_PRECISION:\n    return this->precision;\n  case TJPARAM_COLORSPACE:\n    return this->colorspace;\n  case TJPARAM_FASTUPSAMPLE:\n    return this->fastUpsample;\n  case TJPARAM_FASTDCT:\n    return this->fastDCT;\n  case TJPARAM_OPTIMIZE:\n    return this->optimize;\n  case TJPARAM_PROGRESSIVE:\n    return this->progressive;\n  case TJPARAM_SCANLIMIT:\n    return this->scanLimit;\n  case TJPARAM_ARITHMETIC:\n    return this->arithmetic;\n  case TJPARAM_LOSSLESS:\n    return this->lossless;\n  case TJPARAM_LOSSLESSPSV:\n    return this->losslessPSV;\n  case TJPARAM_LOSSLESSPT:\n    return this->losslessPt;\n  case TJPARAM_RESTARTBLOCKS:\n    return this->restartIntervalBlocks;\n  case TJPARAM_RESTARTROWS:\n    return this->restartIntervalRows;\n  case TJPARAM_XDENSITY:\n    return this->xDensity;\n  case TJPARAM_YDENSITY:\n    return this->yDensity;\n  case TJPARAM_DENSITYUNITS:\n    return this->densityUnits;\n  case TJPARAM_MAXMEMORY:\n    return this->maxMemory;\n  case TJPARAM_MAXPIXELS:\n    return this->maxPixels;\n  }\n\n  return -1;\n}\n\n\n/* These are exposed mainly because Windows can't malloc() and free() across\n   DLL boundaries except when the CRT DLL is used, and we don't use the CRT DLL\n   with turbojpeg.dll for compatibility reasons.  However, these functions\n   can potentially be used for other purposes by different implementations. */\n\n/* TurboJPEG 3+ */\nDLLEXPORT void *tj3Alloc(size_t bytes)\n{\n  return MALLOC(bytes);\n}\n\n/* TurboJPEG 1.2+ */\nDLLEXPORT unsigned char *tjAlloc(int bytes)\n{\n  return (unsigned char *)tj3Alloc((size_t)bytes);\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT void tj3Free(void *buf)\n{\n  free(buf);\n}\n\n/* TurboJPEG 1.2+ */\nDLLEXPORT void tjFree(unsigned char *buf)\n{\n  tj3Free(buf);\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT size_t tj3JPEGBufSize(int width, int height, int jpegSubsamp)\n{\n  static const char FUNCTION_NAME[] = \"tj3JPEGBufSize\";\n  unsigned long long retval = 0;\n  int mcuw, mcuh, chromasf;\n\n  if (width < 1 || height < 1 || jpegSubsamp < TJSAMP_UNKNOWN ||\n      jpegSubsamp >= TJ_NUMSAMP)\n    THROWG(\"Invalid argument\", 0);\n\n  if (jpegSubsamp == TJSAMP_UNKNOWN)\n    jpegSubsamp = TJSAMP_444;\n\n  /* This allows for rare corner cases in which a JPEG image can actually be\n     larger than the uncompressed input (we wouldn't mention it if it hadn't\n     happened before.) */\n  mcuw = tjMCUWidth[jpegSubsamp];\n  mcuh = tjMCUHeight[jpegSubsamp];\n  chromasf = jpegSubsamp == TJSAMP_GRAY ? 0 : 4 * 64 / (mcuw * mcuh);\n  retval = PAD(width, mcuw) * PAD(height, mcuh) * (2ULL + chromasf) + 2048ULL;\n#if ULLONG_MAX > ULONG_MAX\n  if (retval > (unsigned long long)((unsigned long)-1))\n    THROWG(\"Image is too large\", 0);\n#endif\n\nbailout:\n  return (size_t)retval;\n}\n\n/* TurboJPEG 1.2+ */\nDLLEXPORT unsigned long tjBufSize(int width, int height, int jpegSubsamp)\n{\n  static const char FUNCTION_NAME[] = \"tjBufSize\";\n  size_t retval;\n\n  if (jpegSubsamp < 0)\n    THROWG(\"Invalid argument\", 0);\n\n  retval = tj3JPEGBufSize(width, height, jpegSubsamp);\n\nbailout:\n  return (retval == 0) ? (unsigned long)-1 : (unsigned long)retval;\n}\n\n/* TurboJPEG 1.0+ */\nDLLEXPORT unsigned long TJBUFSIZE(int width, int height)\n{\n  static const char FUNCTION_NAME[] = \"TJBUFSIZE\";\n  unsigned long long retval = 0;\n\n  if (width < 1 || height < 1)\n    THROWG(\"Invalid argument\", (unsigned long)-1);\n\n  /* This allows for rare corner cases in which a JPEG image can actually be\n     larger than the uncompressed input (we wouldn't mention it if it hadn't\n     happened before.) */\n  retval = PAD(width, 16) * PAD(height, 16) * 6ULL + 2048ULL;\n#if ULLONG_MAX > ULONG_MAX\n  if (retval > (unsigned long long)((unsigned long)-1))\n    THROWG(\"Image is too large\", (unsigned long)-1);\n#endif\n\nbailout:\n  return (unsigned long)retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT size_t tj3YUVBufSize(int width, int align, int height, int subsamp)\n{\n  static const char FUNCTION_NAME[] = \"tj3YUVBufSize\";\n  unsigned long long retval = 0;\n  int nc, i;\n\n  if (align < 1 || !IS_POW2(align) || subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    THROWG(\"Invalid argument\", 0);\n\n  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);\n  for (i = 0; i < nc; i++) {\n    int pw = tj3YUVPlaneWidth(i, width, subsamp);\n    int stride = PAD(pw, align);\n    int ph = tj3YUVPlaneHeight(i, height, subsamp);\n\n    if (pw == 0 || ph == 0) return 0;\n    else retval += (unsigned long long)stride * ph;\n  }\n#if ULLONG_MAX > ULONG_MAX\n  if (retval > (unsigned long long)((unsigned long)-1))\n    THROWG(\"Image is too large\", 0);\n#endif\n\nbailout:\n  return (size_t)retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT unsigned long tjBufSizeYUV2(int width, int align, int height,\n                                      int subsamp)\n{\n  size_t retval = tj3YUVBufSize(width, align, height, subsamp);\n  return (retval == 0) ? (unsigned long)-1 : (unsigned long)retval;\n}\n\n/* TurboJPEG 1.2+ */\nDLLEXPORT unsigned long tjBufSizeYUV(int width, int height, int subsamp)\n{\n  return tjBufSizeYUV2(width, 4, height, subsamp);\n}\n\n/* TurboJPEG 1.1+ */\nDLLEXPORT unsigned long TJBUFSIZEYUV(int width, int height, int subsamp)\n{\n  return tjBufSizeYUV(width, height, subsamp);\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT size_t tj3YUVPlaneSize(int componentID, int width, int stride,\n                                 int height, int subsamp)\n{\n  static const char FUNCTION_NAME[] = \"tj3YUVPlaneSize\";\n  unsigned long long retval = 0;\n  int pw, ph;\n\n  if (width < 1 || height < 1 || subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    THROWG(\"Invalid argument\", 0);\n\n  pw = tj3YUVPlaneWidth(componentID, width, subsamp);\n  ph = tj3YUVPlaneHeight(componentID, height, subsamp);\n  if (pw == 0 || ph == 0) return 0;\n\n  if (stride == 0) stride = pw;\n  else stride = abs(stride);\n\n  retval = (unsigned long long)stride * (ph - 1) + pw;\n#if ULLONG_MAX > ULONG_MAX\n  if (retval > (unsigned long long)((unsigned long)-1))\n    THROWG(\"Image is too large\", 0);\n#endif\n\nbailout:\n  return (size_t)retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT unsigned long tjPlaneSizeYUV(int componentID, int width, int stride,\n                                       int height, int subsamp)\n{\n  size_t retval = tj3YUVPlaneSize(componentID, width, stride, height, subsamp);\n  return (retval == 0) ? -1 : (unsigned long)retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3YUVPlaneWidth(int componentID, int width, int subsamp)\n{\n  static const char FUNCTION_NAME[] = \"tj3YUVPlaneWidth\";\n  unsigned long long pw, retval = 0;\n  int nc;\n\n  if (width < 1 || subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    THROWG(\"Invalid argument\", 0);\n  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);\n  if (componentID < 0 || componentID >= nc)\n    THROWG(\"Invalid argument\", 0);\n\n  pw = PAD((unsigned long long)width, tjMCUWidth[subsamp] / 8);\n  if (componentID == 0)\n    retval = pw;\n  else\n    retval = pw * 8 / tjMCUWidth[subsamp];\n\n  if (retval > (unsigned long long)INT_MAX)\n    THROWG(\"Width is too large\", 0);\n\nbailout:\n  return (int)retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjPlaneWidth(int componentID, int width, int subsamp)\n{\n  int retval = tj3YUVPlaneWidth(componentID, width, subsamp);\n  return (retval == 0) ? -1 : retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3YUVPlaneHeight(int componentID, int height, int subsamp)\n{\n  static const char FUNCTION_NAME[] = \"tj3YUVPlaneHeight\";\n  unsigned long long ph, retval = 0;\n  int nc;\n\n  if (height < 1 || subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    THROWG(\"Invalid argument\", 0);\n  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);\n  if (componentID < 0 || componentID >= nc)\n    THROWG(\"Invalid argument\", 0);\n\n  ph = PAD((unsigned long long)height, tjMCUHeight[subsamp] / 8);\n  if (componentID == 0)\n    retval = ph;\n  else\n    retval = ph * 8 / tjMCUHeight[subsamp];\n\n  if (retval > (unsigned long long)INT_MAX)\n    THROWG(\"Height is too large\", 0);\n\nbailout:\n  return (int)retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp)\n{\n  int retval = tj3YUVPlaneHeight(componentID, height, subsamp);\n  return (retval == 0) ? -1 : retval;\n}\n\n\n/******************************** Compressor *********************************/\n\nstatic tjhandle _tjInitCompress(tjinstance *this)\n{\n  static unsigned char buffer[1];\n  unsigned char *buf = buffer;\n  size_t size = 1;\n\n  /* This is also straight out of example.c */\n  this->cinfo.err = jpeg_std_error(&this->jerr.pub);\n  this->jerr.pub.error_exit = my_error_exit;\n  this->jerr.pub.output_message = my_output_message;\n  this->jerr.emit_message = this->jerr.pub.emit_message;\n  this->jerr.pub.emit_message = my_emit_message;\n  this->jerr.pub.addon_message_table = turbojpeg_message_table;\n  this->jerr.pub.first_addon_message = JMSG_FIRSTADDONCODE;\n  this->jerr.pub.last_addon_message = JMSG_LASTADDONCODE;\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    free(this);\n    return NULL;\n  }\n\n  jpeg_create_compress(&this->cinfo);\n  /* Make an initial call so it will create the destination manager */\n  jpeg_mem_dest_tj(&this->cinfo, &buf, &size, 0);\n\n  this->init |= COMPRESS;\n  return (tjhandle)this;\n}\n\n/* TurboJPEG 1.0+ */\nDLLEXPORT tjhandle tjInitCompress(void)\n{\n  return tj3Init(TJINIT_COMPRESS);\n}\n\n\n/* tj3Compress*() is implemented in turbojpeg-mp.c */\n#define BITS_IN_JSAMPLE  8\n#include \"turbojpeg-mp.c\"\n#undef BITS_IN_JSAMPLE\n#define BITS_IN_JSAMPLE  12\n#include \"turbojpeg-mp.c\"\n#undef BITS_IN_JSAMPLE\n#define BITS_IN_JSAMPLE  16\n#include \"turbojpeg-mp.c\"\n#undef BITS_IN_JSAMPLE\n\n/* TurboJPEG 1.2+ */\nDLLEXPORT int tjCompress2(tjhandle handle, const unsigned char *srcBuf,\n                          int width, int pitch, int height, int pixelFormat,\n                          unsigned char **jpegBuf, unsigned long *jpegSize,\n                          int jpegSubsamp, int jpegQual, int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjCompress2\";\n  int retval = 0;\n  size_t size;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (jpegSize == NULL || jpegSubsamp < 0 || jpegSubsamp >= TJ_NUMSAMP ||\n      jpegQual < 0 || jpegQual > 100)\n    THROW(\"Invalid argument\");\n\n  this->quality = jpegQual;\n  this->subsamp = jpegSubsamp;\n  processFlags(handle, flags, COMPRESS);\n\n  size = (size_t)(*jpegSize);\n  retval = tj3Compress8(handle, srcBuf, width, pitch, height, pixelFormat,\n                        jpegBuf, &size);\n  *jpegSize = (unsigned long)size;\n\nbailout:\n  return retval;\n}\n\n/* TurboJPEG 1.0+ */\nDLLEXPORT int tjCompress(tjhandle handle, unsigned char *srcBuf, int width,\n                         int pitch, int height, int pixelSize,\n                         unsigned char *jpegBuf, unsigned long *jpegSize,\n                         int jpegSubsamp, int jpegQual, int flags)\n{\n  int retval = 0;\n  unsigned long size = jpegSize ? *jpegSize : 0;\n\n  if (flags & TJ_YUV) {\n    size = tjBufSizeYUV(width, height, jpegSubsamp);\n    retval = tjEncodeYUV2(handle, srcBuf, width, pitch, height,\n                          getPixelFormat(pixelSize, flags), jpegBuf,\n                          jpegSubsamp, flags);\n  } else {\n    retval = tjCompress2(handle, srcBuf, width, pitch, height,\n                         getPixelFormat(pixelSize, flags), &jpegBuf, &size,\n                         jpegSubsamp, jpegQual, flags | TJFLAG_NOREALLOC);\n  }\n  *jpegSize = size;\n  return retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3CompressFromYUVPlanes8(tjhandle handle,\n                                        const unsigned char * const *srcPlanes,\n                                        int width, const int *strides,\n                                        int height, unsigned char **jpegBuf,\n                                        size_t *jpegSize)\n{\n  static const char FUNCTION_NAME[] = \"tj3CompressFromYUVPlanes8\";\n  int i, row, retval = 0;\n  boolean alloc = TRUE;\n  int pw[MAX_COMPONENTS], ph[MAX_COMPONENTS], iw[MAX_COMPONENTS],\n    tmpbufsize = 0, usetmpbuf = 0, th[MAX_COMPONENTS];\n  JSAMPLE *_tmpbuf = NULL, *ptr;\n  JSAMPROW *inbuf[MAX_COMPONENTS], *tmpbuf[MAX_COMPONENTS];\n\n  GET_CINSTANCE(handle)\n\n  for (i = 0; i < MAX_COMPONENTS; i++) {\n    tmpbuf[i] = NULL;  inbuf[i] = NULL;\n  }\n\n  if ((this->init & COMPRESS) == 0)\n    THROW(\"Instance has not been initialized for compression\");\n\n  if (!srcPlanes || !srcPlanes[0] || width <= 0 || height <= 0 ||\n      jpegBuf == NULL || jpegSize == NULL)\n    THROW(\"Invalid argument\");\n  if (this->subsamp != TJSAMP_GRAY && (!srcPlanes[1] || !srcPlanes[2]))\n    THROW(\"Invalid argument\");\n\n  if (this->quality == -1)\n    THROW(\"TJPARAM_QUALITY must be specified\");\n  if (this->subsamp == TJSAMP_UNKNOWN)\n    THROW(\"TJPARAM_SUBSAMP must be specified\");\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  cinfo->image_width = width;\n  cinfo->image_height = height;\n  cinfo->data_precision = 8;\n\n  if (this->noRealloc) {\n    alloc = FALSE;  *jpegSize = tj3JPEGBufSize(width, height, this->subsamp);\n  }\n  jpeg_mem_dest_tj(cinfo, jpegBuf, jpegSize, alloc);\n  setCompDefaults(this, TJPF_RGB);\n  cinfo->raw_data_in = TRUE;\n\n  jpeg_start_compress(cinfo, TRUE);\n  for (i = 0; i < cinfo->num_components; i++) {\n    jpeg_component_info *compptr = &cinfo->comp_info[i];\n    int ih;\n\n    iw[i] = compptr->width_in_blocks * DCTSIZE;\n    ih = compptr->height_in_blocks * DCTSIZE;\n    pw[i] = PAD(cinfo->image_width, cinfo->max_h_samp_factor) *\n            compptr->h_samp_factor / cinfo->max_h_samp_factor;\n    ph[i] = PAD(cinfo->image_height, cinfo->max_v_samp_factor) *\n            compptr->v_samp_factor / cinfo->max_v_samp_factor;\n    if (iw[i] != pw[i] || ih != ph[i]) usetmpbuf = 1;\n    th[i] = compptr->v_samp_factor * DCTSIZE;\n    tmpbufsize += iw[i] * th[i];\n    if ((inbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph[i])) == NULL)\n      THROW(\"Memory allocation failure\");\n    ptr = (JSAMPLE *)srcPlanes[i];\n    for (row = 0; row < ph[i]; row++) {\n      inbuf[i][row] = ptr;\n      ptr += (strides && strides[i] != 0) ? strides[i] : pw[i];\n    }\n  }\n  if (usetmpbuf) {\n    if ((_tmpbuf = (JSAMPLE *)malloc(sizeof(JSAMPLE) * tmpbufsize)) == NULL)\n      THROW(\"Memory allocation failure\");\n    ptr = _tmpbuf;\n    for (i = 0; i < cinfo->num_components; i++) {\n      if ((tmpbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * th[i])) == NULL)\n        THROW(\"Memory allocation failure\");\n      for (row = 0; row < th[i]; row++) {\n        tmpbuf[i][row] = ptr;\n        ptr += iw[i];\n      }\n    }\n  }\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  for (row = 0; row < (int)cinfo->image_height;\n       row += cinfo->max_v_samp_factor * DCTSIZE) {\n    JSAMPARRAY yuvptr[MAX_COMPONENTS];\n    int crow[MAX_COMPONENTS];\n\n    for (i = 0; i < cinfo->num_components; i++) {\n      jpeg_component_info *compptr = &cinfo->comp_info[i];\n\n      crow[i] = row * compptr->v_samp_factor / cinfo->max_v_samp_factor;\n      if (usetmpbuf) {\n        int j, k;\n\n        for (j = 0; j < MIN(th[i], ph[i] - crow[i]); j++) {\n          memcpy(tmpbuf[i][j], inbuf[i][crow[i] + j], pw[i]);\n          /* Duplicate last sample in row to fill out MCU */\n          for (k = pw[i]; k < iw[i]; k++)\n            tmpbuf[i][j][k] = tmpbuf[i][j][pw[i] - 1];\n        }\n        /* Duplicate last row to fill out MCU */\n        for (j = ph[i] - crow[i]; j < th[i]; j++)\n          memcpy(tmpbuf[i][j], tmpbuf[i][ph[i] - crow[i] - 1], iw[i]);\n        yuvptr[i] = tmpbuf[i];\n      } else\n        yuvptr[i] = &inbuf[i][crow[i]];\n    }\n    jpeg_write_raw_data(cinfo, yuvptr, cinfo->max_v_samp_factor * DCTSIZE);\n  }\n  jpeg_finish_compress(cinfo);\n\nbailout:\n  if (cinfo->global_state > CSTATE_START && alloc)\n    (*cinfo->dest->term_destination) (cinfo);\n  if (cinfo->global_state > CSTATE_START || retval == -1)\n    jpeg_abort_compress(cinfo);\n  for (i = 0; i < MAX_COMPONENTS; i++) {\n    free(tmpbuf[i]);\n    free(inbuf[i]);\n  }\n  free(_tmpbuf);\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjCompressFromYUVPlanes(tjhandle handle,\n                                      const unsigned char **srcPlanes,\n                                      int width, const int *strides,\n                                      int height, int subsamp,\n                                      unsigned char **jpegBuf,\n                                      unsigned long *jpegSize, int jpegQual,\n                                      int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjCompressFromYUVPlanes\";\n  int retval = 0;\n  size_t size;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (subsamp < 0 || subsamp >= TJ_NUMSAMP || jpegSize == NULL ||\n      jpegQual < 0 || jpegQual > 100)\n    THROW(\"Invalid argument\");\n\n  this->quality = jpegQual;\n  this->subsamp = subsamp;\n  processFlags(handle, flags, COMPRESS);\n\n  size = (size_t)(*jpegSize);\n  retval = tj3CompressFromYUVPlanes8(handle, srcPlanes, width, strides, height,\n                                     jpegBuf, &size);\n  *jpegSize = (unsigned long)size;\n\nbailout:\n  return retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3CompressFromYUV8(tjhandle handle,\n                                  const unsigned char *srcBuf, int width,\n                                  int align, int height,\n                                  unsigned char **jpegBuf, size_t *jpegSize)\n{\n  static const char FUNCTION_NAME[] = \"tj3CompressFromYUV8\";\n  const unsigned char *srcPlanes[3];\n  int pw0, ph0, strides[3], retval = -1;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (srcBuf == NULL || width <= 0 || align < 1 || !IS_POW2(align) ||\n      height <= 0)\n    THROW(\"Invalid argument\");\n\n  if (this->subsamp == TJSAMP_UNKNOWN)\n    THROW(\"TJPARAM_SUBSAMP must be specified\");\n\n  pw0 = tj3YUVPlaneWidth(0, width, this->subsamp);\n  ph0 = tj3YUVPlaneHeight(0, height, this->subsamp);\n  srcPlanes[0] = srcBuf;\n  strides[0] = PAD(pw0, align);\n  if (this->subsamp == TJSAMP_GRAY) {\n    strides[1] = strides[2] = 0;\n    srcPlanes[1] = srcPlanes[2] = NULL;\n  } else {\n    int pw1 = tjPlaneWidth(1, width, this->subsamp);\n    int ph1 = tjPlaneHeight(1, height, this->subsamp);\n\n    strides[1] = strides[2] = PAD(pw1, align);\n    if ((unsigned long long)strides[0] * (unsigned long long)ph0 >\n        (unsigned long long)INT_MAX ||\n        (unsigned long long)strides[1] * (unsigned long long)ph1 >\n        (unsigned long long)INT_MAX)\n      THROW(\"Image or row alignment is too large\");\n    srcPlanes[1] = srcPlanes[0] + strides[0] * ph0;\n    srcPlanes[2] = srcPlanes[1] + strides[1] * ph1;\n  }\n\n  return tj3CompressFromYUVPlanes8(handle, srcPlanes, width, strides, height,\n                                   jpegBuf, jpegSize);\n\nbailout:\n  return retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,\n                                int width, int align, int height, int subsamp,\n                                unsigned char **jpegBuf,\n                                unsigned long *jpegSize, int jpegQual,\n                                int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjCompressFromYUV\";\n  int retval = -1;\n  size_t size;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    THROW(\"Invalid argument\");\n\n  this->quality = jpegQual;\n  this->subsamp = subsamp;\n  processFlags(handle, flags, COMPRESS);\n\n  size = (size_t)(*jpegSize);\n  retval = tj3CompressFromYUV8(handle, srcBuf, width, align, height, jpegBuf,\n                               &size);\n  *jpegSize = (unsigned long)size;\n\nbailout:\n  return retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3EncodeYUVPlanes8(tjhandle handle, const unsigned char *srcBuf,\n                                  int width, int pitch, int height,\n                                  int pixelFormat, unsigned char **dstPlanes,\n                                  int *strides)\n{\n  static const char FUNCTION_NAME[] = \"tj3EncodeYUVPlanes8\";\n  JSAMPROW *row_pointer = NULL;\n  JSAMPLE *_tmpbuf[MAX_COMPONENTS], *_tmpbuf2[MAX_COMPONENTS];\n  JSAMPROW *tmpbuf[MAX_COMPONENTS], *tmpbuf2[MAX_COMPONENTS];\n  JSAMPROW *outbuf[MAX_COMPONENTS];\n  int i, retval = 0, row, pw0, ph0, pw[MAX_COMPONENTS], ph[MAX_COMPONENTS];\n  JSAMPLE *ptr;\n  jpeg_component_info *compptr;\n\n  GET_CINSTANCE(handle)\n\n  for (i = 0; i < MAX_COMPONENTS; i++) {\n    tmpbuf[i] = NULL;  _tmpbuf[i] = NULL;\n    tmpbuf2[i] = NULL;  _tmpbuf2[i] = NULL;  outbuf[i] = NULL;\n  }\n\n  if ((this->init & COMPRESS) == 0)\n    THROW(\"Instance has not been initialized for compression\");\n\n  if (srcBuf == NULL || width <= 0 || pitch < 0 || height <= 0 ||\n      pixelFormat < 0 || pixelFormat >= TJ_NUMPF || !dstPlanes ||\n      !dstPlanes[0])\n    THROW(\"Invalid argument\");\n  if (this->subsamp != TJSAMP_GRAY && (!dstPlanes[1] || !dstPlanes[2]))\n    THROW(\"Invalid argument\");\n\n  if (this->subsamp == TJSAMP_UNKNOWN)\n    THROW(\"TJPARAM_SUBSAMP must be specified\");\n  if (pixelFormat == TJPF_CMYK)\n    THROW(\"Cannot generate YUV images from packed-pixel CMYK images\");\n\n  if (pitch == 0) pitch = width * tjPixelSize[pixelFormat];\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  cinfo->image_width = width;\n  cinfo->image_height = height;\n  cinfo->data_precision = 8;\n\n  setCompDefaults(this, pixelFormat);\n\n  /* Execute only the parts of jpeg_start_compress() that we need.  If we\n     were to call the whole jpeg_start_compress() function, then it would try\n     to write the file headers, which could overflow the output buffer if the\n     YUV image were very small. */\n  if (cinfo->global_state != CSTATE_START)\n    THROW(\"libjpeg API is in the wrong state\");\n  (*cinfo->err->reset_error_mgr) ((j_common_ptr)cinfo);\n  jinit_c_master_control(cinfo, FALSE);\n  jinit_color_converter(cinfo);\n  jinit_downsampler(cinfo);\n  (*cinfo->cconvert->start_pass) (cinfo);\n\n  pw0 = PAD(width, cinfo->max_h_samp_factor);\n  ph0 = PAD(height, cinfo->max_v_samp_factor);\n\n  if ((row_pointer = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph0)) == NULL)\n    THROW(\"Memory allocation failure\");\n  for (i = 0; i < height; i++) {\n    if (this->bottomUp)\n      row_pointer[i] = (JSAMPROW)&srcBuf[(height - i - 1) * (size_t)pitch];\n    else\n      row_pointer[i] = (JSAMPROW)&srcBuf[i * (size_t)pitch];\n  }\n  if (height < ph0)\n    for (i = height; i < ph0; i++) row_pointer[i] = row_pointer[height - 1];\n\n  for (i = 0; i < cinfo->num_components; i++) {\n    compptr = &cinfo->comp_info[i];\n    _tmpbuf[i] = (JSAMPLE *)MALLOC(\n      PAD((compptr->width_in_blocks * cinfo->max_h_samp_factor * DCTSIZE) /\n          compptr->h_samp_factor, 32) *\n      cinfo->max_v_samp_factor + 32);\n    if (!_tmpbuf[i])\n      THROW(\"Memory allocation failure\");\n    tmpbuf[i] =\n      (JSAMPROW *)malloc(sizeof(JSAMPROW) * cinfo->max_v_samp_factor);\n    if (!tmpbuf[i])\n      THROW(\"Memory allocation failure\");\n    for (row = 0; row < cinfo->max_v_samp_factor; row++) {\n      unsigned char *_tmpbuf_aligned =\n        (unsigned char *)PAD((JUINTPTR)_tmpbuf[i], 32);\n\n      tmpbuf[i][row] = &_tmpbuf_aligned[\n        PAD((compptr->width_in_blocks * cinfo->max_h_samp_factor * DCTSIZE) /\n            compptr->h_samp_factor, 32) * row];\n    }\n    _tmpbuf2[i] =\n      (JSAMPLE *)MALLOC(PAD(compptr->width_in_blocks * DCTSIZE, 32) *\n                        compptr->v_samp_factor + 32);\n    if (!_tmpbuf2[i])\n      THROW(\"Memory allocation failure\");\n    tmpbuf2[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * compptr->v_samp_factor);\n    if (!tmpbuf2[i])\n      THROW(\"Memory allocation failure\");\n    for (row = 0; row < compptr->v_samp_factor; row++) {\n      unsigned char *_tmpbuf2_aligned =\n        (unsigned char *)PAD((JUINTPTR)_tmpbuf2[i], 32);\n\n      tmpbuf2[i][row] =\n        &_tmpbuf2_aligned[PAD(compptr->width_in_blocks * DCTSIZE, 32) * row];\n    }\n    pw[i] = pw0 * compptr->h_samp_factor / cinfo->max_h_samp_factor;\n    ph[i] = ph0 * compptr->v_samp_factor / cinfo->max_v_samp_factor;\n    outbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph[i]);\n    if (!outbuf[i])\n      THROW(\"Memory allocation failure\");\n    ptr = dstPlanes[i];\n    for (row = 0; row < ph[i]; row++) {\n      outbuf[i][row] = ptr;\n      ptr += (strides && strides[i] != 0) ? strides[i] : pw[i];\n    }\n  }\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  for (row = 0; row < ph0; row += cinfo->max_v_samp_factor) {\n    (*cinfo->cconvert->color_convert) (cinfo, &row_pointer[row], tmpbuf, 0,\n                                       cinfo->max_v_samp_factor);\n    (cinfo->downsample->downsample) (cinfo, tmpbuf, 0, tmpbuf2, 0);\n    for (i = 0, compptr = cinfo->comp_info; i < cinfo->num_components;\n         i++, compptr++)\n      jcopy_sample_rows(tmpbuf2[i], 0, outbuf[i],\n        row * compptr->v_samp_factor / cinfo->max_v_samp_factor,\n        compptr->v_samp_factor, pw[i]);\n  }\n  cinfo->next_scanline += height;\n  jpeg_abort_compress(cinfo);\n\nbailout:\n  if (cinfo->global_state > CSTATE_START) jpeg_abort_compress(cinfo);\n  free(row_pointer);\n  for (i = 0; i < MAX_COMPONENTS; i++) {\n    free(tmpbuf[i]);\n    free(_tmpbuf[i]);\n    free(tmpbuf2[i]);\n    free(_tmpbuf2[i]);\n    free(outbuf[i]);\n  }\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjEncodeYUVPlanes(tjhandle handle, const unsigned char *srcBuf,\n                                int width, int pitch, int height,\n                                int pixelFormat, unsigned char **dstPlanes,\n                                int *strides, int subsamp, int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjEncodeYUVPlanes\";\n  int retval = 0;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    THROW(\"Invalid argument\");\n\n  this->subsamp = subsamp;\n  processFlags(handle, flags, COMPRESS);\n\n  return tj3EncodeYUVPlanes8(handle, srcBuf, width, pitch, height, pixelFormat,\n                             dstPlanes, strides);\n\nbailout:\n  return retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3EncodeYUV8(tjhandle handle, const unsigned char *srcBuf,\n                            int width, int pitch, int height, int pixelFormat,\n                            unsigned char *dstBuf, int align)\n{\n  static const char FUNCTION_NAME[] = \"tj3EncodeYUV8\";\n  unsigned char *dstPlanes[3];\n  int pw0, ph0, strides[3], retval = -1;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (width <= 0 || height <= 0 || dstBuf == NULL || align < 1 ||\n      !IS_POW2(align))\n    THROW(\"Invalid argument\");\n\n  if (this->subsamp == TJSAMP_UNKNOWN)\n    THROW(\"TJPARAM_SUBSAMP must be specified\");\n\n  pw0 = tj3YUVPlaneWidth(0, width, this->subsamp);\n  ph0 = tj3YUVPlaneHeight(0, height, this->subsamp);\n  dstPlanes[0] = dstBuf;\n  strides[0] = PAD(pw0, align);\n  if (this->subsamp == TJSAMP_GRAY) {\n    strides[1] = strides[2] = 0;\n    dstPlanes[1] = dstPlanes[2] = NULL;\n  } else {\n    int pw1 = tj3YUVPlaneWidth(1, width, this->subsamp);\n    int ph1 = tj3YUVPlaneHeight(1, height, this->subsamp);\n\n    strides[1] = strides[2] = PAD(pw1, align);\n    if ((unsigned long long)strides[0] * (unsigned long long)ph0 >\n        (unsigned long long)INT_MAX ||\n        (unsigned long long)strides[1] * (unsigned long long)ph1 >\n        (unsigned long long)INT_MAX)\n      THROW(\"Image or row alignment is too large\");\n    dstPlanes[1] = dstPlanes[0] + strides[0] * ph0;\n    dstPlanes[2] = dstPlanes[1] + strides[1] * ph1;\n  }\n\n  return tj3EncodeYUVPlanes8(handle, srcBuf, width, pitch, height, pixelFormat,\n                             dstPlanes, strides);\n\nbailout:\n  return retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjEncodeYUV3(tjhandle handle, const unsigned char *srcBuf,\n                           int width, int pitch, int height, int pixelFormat,\n                           unsigned char *dstBuf, int align, int subsamp,\n                           int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjEncodeYUV3\";\n  int retval = 0;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    THROW(\"Invalid argument\");\n\n  this->subsamp = subsamp;\n  processFlags(handle, flags, COMPRESS);\n\n  return tj3EncodeYUV8(handle, srcBuf, width, pitch, height, pixelFormat,\n                       dstBuf, align);\n\nbailout:\n  return retval;\n}\n\n/* TurboJPEG 1.2+ */\nDLLEXPORT int tjEncodeYUV2(tjhandle handle, unsigned char *srcBuf, int width,\n                           int pitch, int height, int pixelFormat,\n                           unsigned char *dstBuf, int subsamp, int flags)\n{\n  return tjEncodeYUV3(handle, srcBuf, width, pitch, height, pixelFormat,\n                      dstBuf, 4, subsamp, flags);\n}\n\n/* TurboJPEG 1.1+ */\nDLLEXPORT int tjEncodeYUV(tjhandle handle, unsigned char *srcBuf, int width,\n                          int pitch, int height, int pixelSize,\n                          unsigned char *dstBuf, int subsamp, int flags)\n{\n  return tjEncodeYUV2(handle, srcBuf, width, pitch, height,\n                      getPixelFormat(pixelSize, flags), dstBuf, subsamp,\n                      flags);\n}\n\n\n/******************************* Decompressor ********************************/\n\nstatic tjhandle _tjInitDecompress(tjinstance *this)\n{\n  static unsigned char buffer[1];\n\n  /* This is also straight out of example.c */\n  this->dinfo.err = jpeg_std_error(&this->jerr.pub);\n  this->jerr.pub.error_exit = my_error_exit;\n  this->jerr.pub.output_message = my_output_message;\n  this->jerr.emit_message = this->jerr.pub.emit_message;\n  this->jerr.pub.emit_message = my_emit_message;\n  this->jerr.pub.addon_message_table = turbojpeg_message_table;\n  this->jerr.pub.first_addon_message = JMSG_FIRSTADDONCODE;\n  this->jerr.pub.last_addon_message = JMSG_LASTADDONCODE;\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    free(this);\n    return NULL;\n  }\n\n  jpeg_create_decompress(&this->dinfo);\n  /* Make an initial call so it will create the source manager */\n  jpeg_mem_src_tj(&this->dinfo, buffer, 1);\n\n  this->init |= DECOMPRESS;\n  return (tjhandle)this;\n}\n\n/* TurboJPEG 1.0+ */\nDLLEXPORT tjhandle tjInitDecompress(void)\n{\n  return tj3Init(TJINIT_DECOMPRESS);\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3DecompressHeader(tjhandle handle,\n                                  const unsigned char *jpegBuf,\n                                  size_t jpegSize)\n{\n  static const char FUNCTION_NAME[] = \"tj3DecompressHeader\";\n  int retval = 0;\n\n  GET_DINSTANCE(handle);\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for decompression\");\n\n  if (jpegBuf == NULL || jpegSize <= 0)\n    THROW(\"Invalid argument\");\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    return -1;\n  }\n\n  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);\n\n  /* jpeg_read_header() calls jpeg_abort() and returns JPEG_HEADER_TABLES_ONLY\n     if the datastream is a tables-only datastream.  Since we aren't using a\n     suspending data source, the only other value it can return is\n     JPEG_HEADER_OK. */\n  if (jpeg_read_header(dinfo, FALSE) == JPEG_HEADER_TABLES_ONLY)\n    return 0;\n\n  setDecompParameters(this);\n\n  jpeg_abort_decompress(dinfo);\n\n  if (this->colorspace < 0)\n    THROW(\"Could not determine colorspace of JPEG image\");\n  if (this->jpegWidth < 1 || this->jpegHeight < 1)\n    THROW(\"Invalid data returned in header\");\n\nbailout:\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjDecompressHeader3(tjhandle handle,\n                                  const unsigned char *jpegBuf,\n                                  unsigned long jpegSize, int *width,\n                                  int *height, int *jpegSubsamp,\n                                  int *jpegColorspace)\n{\n  static const char FUNCTION_NAME[] = \"tjDecompressHeader3\";\n  int retval = 0;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (width == NULL || height == NULL || jpegSubsamp == NULL ||\n      jpegColorspace == NULL)\n    THROW(\"Invalid argument\");\n\n  retval = tj3DecompressHeader(handle, jpegBuf, jpegSize);\n\n  *width = tj3Get(handle, TJPARAM_JPEGWIDTH);\n  *height = tj3Get(handle, TJPARAM_JPEGHEIGHT);\n  *jpegSubsamp = tj3Get(handle, TJPARAM_SUBSAMP);\n  if (*jpegSubsamp == TJSAMP_UNKNOWN)\n    THROW(\"Could not determine subsampling level of JPEG image\");\n  *jpegColorspace = tj3Get(handle, TJPARAM_COLORSPACE);\n\nbailout:\n  return retval;\n}\n\n/* TurboJPEG 1.1+ */\nDLLEXPORT int tjDecompressHeader2(tjhandle handle, unsigned char *jpegBuf,\n                                  unsigned long jpegSize, int *width,\n                                  int *height, int *jpegSubsamp)\n{\n  int jpegColorspace;\n\n  return tjDecompressHeader3(handle, jpegBuf, jpegSize, width, height,\n                             jpegSubsamp, &jpegColorspace);\n}\n\n/* TurboJPEG 1.0+ */\nDLLEXPORT int tjDecompressHeader(tjhandle handle, unsigned char *jpegBuf,\n                                 unsigned long jpegSize, int *width,\n                                 int *height)\n{\n  int jpegSubsamp;\n\n  return tjDecompressHeader2(handle, jpegBuf, jpegSize, width, height,\n                             &jpegSubsamp);\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT tjscalingfactor *tj3GetScalingFactors(int *numScalingFactors)\n{\n  static const char FUNCTION_NAME[] = \"tj3GetScalingFactors\";\n  tjscalingfactor *retval = (tjscalingfactor *)sf;\n\n  if (numScalingFactors == NULL)\n    THROWG(\"Invalid argument\", NULL);\n\n  *numScalingFactors = NUMSF;\n\nbailout:\n  return retval;\n}\n\n/* TurboJPEG 1.2+ */\nDLLEXPORT tjscalingfactor *tjGetScalingFactors(int *numScalingFactors)\n{\n  return tj3GetScalingFactors(numScalingFactors);\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3SetScalingFactor(tjhandle handle,\n                                  tjscalingfactor scalingFactor)\n{\n  static const char FUNCTION_NAME[] = \"tj3SetScalingFactor\";\n  int i, retval = 0;\n\n  GET_TJINSTANCE(handle, -1);\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for decompression\");\n\n  for (i = 0; i < NUMSF; i++) {\n    if (scalingFactor.num == sf[i].num && scalingFactor.denom == sf[i].denom)\n      break;\n  }\n  if (i >= NUMSF)\n    THROW(\"Unsupported scaling factor\");\n\n  this->scalingFactor = scalingFactor;\n\nbailout:\n  return retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3SetCroppingRegion(tjhandle handle, tjregion croppingRegion)\n{\n  static const char FUNCTION_NAME[] = \"tj3SetCroppingRegion\";\n  int retval = 0, scaledWidth, scaledHeight;\n\n  GET_TJINSTANCE(handle, -1);\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for decompression\");\n\n  if (croppingRegion.x == 0 && croppingRegion.y == 0 &&\n      croppingRegion.w == 0 && croppingRegion.h == 0) {\n    this->croppingRegion = croppingRegion;\n    return 0;\n  }\n\n  if (croppingRegion.x < 0 || croppingRegion.y < 0 || croppingRegion.w < 0 ||\n      croppingRegion.h < 0)\n    THROW(\"Invalid cropping region\");\n  if (this->jpegWidth < 0 || this->jpegHeight < 0)\n    THROW(\"JPEG header has not yet been read\");\n  if (this->precision == 16 || this->lossless)\n    THROW(\"Cannot partially decompress lossless JPEG images\");\n  if (this->subsamp == TJSAMP_UNKNOWN)\n    THROW(\"Could not determine subsampling level of JPEG image\");\n\n  scaledWidth = TJSCALED(this->jpegWidth, this->scalingFactor);\n  scaledHeight = TJSCALED(this->jpegHeight, this->scalingFactor);\n\n  if (croppingRegion.x %\n      TJSCALED(tjMCUWidth[this->subsamp], this->scalingFactor) != 0)\n    THROWI(\"The left boundary of the cropping region (%d) is not\\n\"\n           \"divisible by the scaled iMCU width (%d)\",\n           croppingRegion.x,\n           TJSCALED(tjMCUWidth[this->subsamp], this->scalingFactor));\n  if (croppingRegion.w == 0)\n    croppingRegion.w = scaledWidth - croppingRegion.x;\n  if (croppingRegion.h == 0)\n    croppingRegion.h = scaledHeight - croppingRegion.y;\n  if (croppingRegion.w <= 0 || croppingRegion.h <= 0 ||\n      croppingRegion.x + croppingRegion.w > scaledWidth ||\n      croppingRegion.y + croppingRegion.h > scaledHeight)\n    THROW(\"The cropping region exceeds the scaled image dimensions\");\n\n  this->croppingRegion = croppingRegion;\n\nbailout:\n  return retval;\n}\n\n\n/* tj3Decompress*() is implemented in turbojpeg-mp.c */\n\n/* TurboJPEG 1.2+ */\nDLLEXPORT int tjDecompress2(tjhandle handle, const unsigned char *jpegBuf,\n                            unsigned long jpegSize, unsigned char *dstBuf,\n                            int width, int pitch, int height, int pixelFormat,\n                            int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjDecompress2\";\n  int i, retval = 0, jpegwidth, jpegheight, scaledw, scaledh;\n\n  GET_DINSTANCE(handle);\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for decompression\");\n\n  if (jpegBuf == NULL || jpegSize <= 0 || width < 0 || height < 0)\n    THROW(\"Invalid argument\");\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);\n  jpeg_read_header(dinfo, TRUE);\n  jpegwidth = dinfo->image_width;  jpegheight = dinfo->image_height;\n  if (width == 0) width = jpegwidth;\n  if (height == 0) height = jpegheight;\n  for (i = 0; i < NUMSF; i++) {\n    scaledw = TJSCALED(jpegwidth, sf[i]);\n    scaledh = TJSCALED(jpegheight, sf[i]);\n    if (scaledw <= width && scaledh <= height)\n      break;\n  }\n  if (i >= NUMSF)\n    THROW(\"Could not scale down to desired image dimensions\");\n\n  processFlags(handle, flags, DECOMPRESS);\n\n  if (tj3SetScalingFactor(handle, sf[i]) == -1)\n    return -1;\n  if (tj3SetCroppingRegion(handle, TJUNCROPPED) == -1)\n    return -1;\n  return tj3Decompress8(handle, jpegBuf, jpegSize, dstBuf, pitch, pixelFormat);\n\nbailout:\n  if (dinfo->global_state > DSTATE_START) jpeg_abort_decompress(dinfo);\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n/* TurboJPEG 1.0+ */\nDLLEXPORT int tjDecompress(tjhandle handle, unsigned char *jpegBuf,\n                           unsigned long jpegSize, unsigned char *dstBuf,\n                           int width, int pitch, int height, int pixelSize,\n                           int flags)\n{\n  if (flags & TJ_YUV)\n    return tjDecompressToYUV(handle, jpegBuf, jpegSize, dstBuf, flags);\n  else\n    return tjDecompress2(handle, jpegBuf, jpegSize, dstBuf, width, pitch,\n                         height, getPixelFormat(pixelSize, flags), flags);\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3DecompressToYUVPlanes8(tjhandle handle,\n                                        const unsigned char *jpegBuf,\n                                        size_t jpegSize,\n                                        unsigned char **dstPlanes,\n                                        int *strides)\n{\n  static const char FUNCTION_NAME[] = \"tj3DecompressToYUVPlanes8\";\n  int i, row, retval = 0;\n  int pw[MAX_COMPONENTS], ph[MAX_COMPONENTS], iw[MAX_COMPONENTS],\n    tmpbufsize = 0, usetmpbuf = 0, th[MAX_COMPONENTS];\n  JSAMPLE *_tmpbuf = NULL, *ptr;\n  JSAMPROW *outbuf[MAX_COMPONENTS], *tmpbuf[MAX_COMPONENTS];\n  int dctsize;\n  struct my_progress_mgr progress;\n\n  GET_DINSTANCE(handle);\n\n  for (i = 0; i < MAX_COMPONENTS; i++) {\n    tmpbuf[i] = NULL;  outbuf[i] = NULL;\n  }\n\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for decompression\");\n\n  if (jpegBuf == NULL || jpegSize <= 0 || !dstPlanes || !dstPlanes[0])\n    THROW(\"Invalid argument\");\n\n  if (this->scanLimit) {\n    memset(&progress, 0, sizeof(struct my_progress_mgr));\n    progress.pub.progress_monitor = my_progress_monitor;\n    progress.this = this;\n    dinfo->progress = &progress.pub;\n  } else\n    dinfo->progress = NULL;\n\n  dinfo->mem->max_memory_to_use = (long)this->maxMemory * 1048576L;\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  if (dinfo->global_state <= DSTATE_INHEADER) {\n    jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);\n    jpeg_read_header(dinfo, TRUE);\n  }\n  setDecompParameters(this);\n  if (this->maxPixels &&\n      (unsigned long long)this->jpegWidth * this->jpegHeight >\n      (unsigned long long)this->maxPixels)\n    THROW(\"Image is too large\");\n  if (this->subsamp == TJSAMP_UNKNOWN)\n    THROW(\"Could not determine subsampling level of JPEG image\");\n\n  if (this->subsamp != TJSAMP_GRAY && (!dstPlanes[1] || !dstPlanes[2]))\n    THROW(\"Invalid argument\");\n\n  if (dinfo->num_components > 3)\n    THROW(\"JPEG image must have 3 or fewer components\");\n\n  dinfo->scale_num = this->scalingFactor.num;\n  dinfo->scale_denom = this->scalingFactor.denom;\n  jpeg_calc_output_dimensions(dinfo);\n\n  dctsize = DCTSIZE * this->scalingFactor.num / this->scalingFactor.denom;\n\n  for (i = 0; i < dinfo->num_components; i++) {\n    jpeg_component_info *compptr = &dinfo->comp_info[i];\n    int ih;\n\n    iw[i] = compptr->width_in_blocks * dctsize;\n    ih = compptr->height_in_blocks * dctsize;\n    pw[i] = tj3YUVPlaneWidth(i, dinfo->output_width, this->subsamp);\n    ph[i] = tj3YUVPlaneHeight(i, dinfo->output_height, this->subsamp);\n    if (iw[i] != pw[i] || ih != ph[i]) usetmpbuf = 1;\n    th[i] = compptr->v_samp_factor * dctsize;\n    tmpbufsize += iw[i] * th[i];\n    if ((outbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph[i])) == NULL)\n      THROW(\"Memory allocation failure\");\n    ptr = dstPlanes[i];\n    for (row = 0; row < ph[i]; row++) {\n      outbuf[i][row] = ptr;\n      ptr += (strides && strides[i] != 0) ? strides[i] : pw[i];\n    }\n  }\n  if (usetmpbuf) {\n    if ((_tmpbuf = (JSAMPLE *)MALLOC(sizeof(JSAMPLE) * tmpbufsize)) == NULL)\n      THROW(\"Memory allocation failure\");\n    ptr = _tmpbuf;\n    for (i = 0; i < dinfo->num_components; i++) {\n      if ((tmpbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * th[i])) == NULL)\n        THROW(\"Memory allocation failure\");\n      for (row = 0; row < th[i]; row++) {\n        tmpbuf[i][row] = ptr;\n        ptr += iw[i];\n      }\n    }\n  }\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  dinfo->do_fancy_upsampling = !this->fastUpsample;\n  dinfo->dct_method = this->fastDCT ? JDCT_FASTEST : JDCT_ISLOW;\n  dinfo->raw_data_out = TRUE;\n\n  dinfo->mem->max_memory_to_use = (long)this->maxMemory * 1048576L;\n\n  jpeg_start_decompress(dinfo);\n  for (row = 0; row < (int)dinfo->output_height;\n       row += dinfo->max_v_samp_factor * dinfo->_min_DCT_scaled_size) {\n    JSAMPARRAY yuvptr[MAX_COMPONENTS];\n    int crow[MAX_COMPONENTS];\n\n    for (i = 0; i < dinfo->num_components; i++) {\n      jpeg_component_info *compptr = &dinfo->comp_info[i];\n\n      if (this->subsamp == TJSAMP_420) {\n        /* When 4:2:0 subsampling is used with IDCT scaling, libjpeg will try\n           to be clever and use the IDCT to perform upsampling on the U and V\n           planes.  For instance, if the output image is to be scaled by 1/2\n           relative to the JPEG image, then the scaling factor and upsampling\n           effectively cancel each other, so a normal 8x8 IDCT can be used.\n           However, this is not desirable when using the decompress-to-YUV\n           functionality in TurboJPEG, since we want to output the U and V\n           planes in their subsampled form.  Thus, we have to override some\n           internal libjpeg parameters to force it to use the \"scaled\" IDCT\n           functions on the U and V planes. */\n        compptr->_DCT_scaled_size = dctsize;\n        compptr->MCU_sample_width = tjMCUWidth[this->subsamp] *\n          this->scalingFactor.num / this->scalingFactor.denom *\n          compptr->v_samp_factor / dinfo->max_v_samp_factor;\n        dinfo->idct->inverse_DCT[i] = dinfo->idct->inverse_DCT[0];\n      }\n      crow[i] = row * compptr->v_samp_factor / dinfo->max_v_samp_factor;\n      if (usetmpbuf) yuvptr[i] = tmpbuf[i];\n      else yuvptr[i] = &outbuf[i][crow[i]];\n    }\n    jpeg_read_raw_data(dinfo, yuvptr,\n                       dinfo->max_v_samp_factor * dinfo->_min_DCT_scaled_size);\n    if (usetmpbuf) {\n      int j;\n\n      for (i = 0; i < dinfo->num_components; i++) {\n        for (j = 0; j < MIN(th[i], ph[i] - crow[i]); j++) {\n          memcpy(outbuf[i][crow[i] + j], tmpbuf[i][j], pw[i]);\n        }\n      }\n    }\n  }\n  jpeg_finish_decompress(dinfo);\n\nbailout:\n  if (dinfo->global_state > DSTATE_START) jpeg_abort_decompress(dinfo);\n  for (i = 0; i < MAX_COMPONENTS; i++) {\n    free(tmpbuf[i]);\n    free(outbuf[i]);\n  }\n  free(_tmpbuf);\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjDecompressToYUVPlanes(tjhandle handle,\n                                      const unsigned char *jpegBuf,\n                                      unsigned long jpegSize,\n                                      unsigned char **dstPlanes, int width,\n                                      int *strides, int height, int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjDecompressToYUVPlanes\";\n  int i, retval = 0, jpegwidth, jpegheight, scaledw, scaledh;\n\n  GET_DINSTANCE(handle);\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for decompression\");\n\n  if (jpegBuf == NULL || jpegSize <= 0 || width < 0 || height < 0)\n    THROW(\"Invalid argument\");\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);\n  jpeg_read_header(dinfo, TRUE);\n  jpegwidth = dinfo->image_width;  jpegheight = dinfo->image_height;\n  if (width == 0) width = jpegwidth;\n  if (height == 0) height = jpegheight;\n  for (i = 0; i < NUMSF; i++) {\n    scaledw = TJSCALED(jpegwidth, sf[i]);\n    scaledh = TJSCALED(jpegheight, sf[i]);\n    if (scaledw <= width && scaledh <= height)\n      break;\n  }\n  if (i >= NUMSF)\n    THROW(\"Could not scale down to desired image dimensions\");\n\n  processFlags(handle, flags, DECOMPRESS);\n\n  if (tj3SetScalingFactor(handle, sf[i]) == -1)\n    return -1;\n  return tj3DecompressToYUVPlanes8(handle, jpegBuf, jpegSize, dstPlanes,\n                                   strides);\n\nbailout:\n  if (dinfo->global_state > DSTATE_START) jpeg_abort_decompress(dinfo);\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3DecompressToYUV8(tjhandle handle,\n                                  const unsigned char *jpegBuf,\n                                  size_t jpegSize,\n                                  unsigned char *dstBuf, int align)\n{\n  static const char FUNCTION_NAME[] = \"tj3DecompressToYUV8\";\n  unsigned char *dstPlanes[3];\n  int pw0, ph0, strides[3], retval = -1;\n  int width, height;\n\n  GET_DINSTANCE(handle);\n\n  if (jpegBuf == NULL || jpegSize <= 0 || dstBuf == NULL || align < 1 ||\n      !IS_POW2(align))\n    THROW(\"Invalid argument\");\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  if (dinfo->global_state <= DSTATE_INHEADER) {\n    jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);\n    jpeg_read_header(dinfo, TRUE);\n  }\n  setDecompParameters(this);\n  if (this->subsamp == TJSAMP_UNKNOWN)\n    THROW(\"Could not determine subsampling level of JPEG image\");\n\n  width = TJSCALED(dinfo->image_width, this->scalingFactor);\n  height = TJSCALED(dinfo->image_height, this->scalingFactor);\n\n  pw0 = tj3YUVPlaneWidth(0, width, this->subsamp);\n  ph0 = tj3YUVPlaneHeight(0, height, this->subsamp);\n  dstPlanes[0] = dstBuf;\n  strides[0] = PAD(pw0, align);\n  if (this->subsamp == TJSAMP_GRAY) {\n    strides[1] = strides[2] = 0;\n    dstPlanes[1] = dstPlanes[2] = NULL;\n  } else {\n    int pw1 = tj3YUVPlaneWidth(1, width, this->subsamp);\n    int ph1 = tj3YUVPlaneHeight(1, height, this->subsamp);\n\n    strides[1] = strides[2] = PAD(pw1, align);\n    if ((unsigned long long)strides[0] * (unsigned long long)ph0 >\n        (unsigned long long)INT_MAX ||\n        (unsigned long long)strides[1] * (unsigned long long)ph1 >\n        (unsigned long long)INT_MAX)\n      THROW(\"Image or row alignment is too large\");\n    dstPlanes[1] = dstPlanes[0] + strides[0] * ph0;\n    dstPlanes[2] = dstPlanes[1] + strides[1] * ph1;\n  }\n\n  return tj3DecompressToYUVPlanes8(handle, jpegBuf, jpegSize, dstPlanes,\n                                   strides);\n\nbailout:\n  if (dinfo->global_state > DSTATE_START) jpeg_abort_decompress(dinfo);\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,\n                                 unsigned long jpegSize, unsigned char *dstBuf,\n                                 int width, int align, int height, int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjDecompressToYUV2\";\n  int i, retval = 0, jpegwidth, jpegheight, scaledw, scaledh;\n\n  GET_DINSTANCE(handle);\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for decompression\");\n\n  if (jpegBuf == NULL || jpegSize <= 0 || width < 0 || height < 0)\n    THROW(\"Invalid argument\");\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);\n  jpeg_read_header(dinfo, TRUE);\n  jpegwidth = dinfo->image_width;  jpegheight = dinfo->image_height;\n  if (width == 0) width = jpegwidth;\n  if (height == 0) height = jpegheight;\n  for (i = 0; i < NUMSF; i++) {\n    scaledw = TJSCALED(jpegwidth, sf[i]);\n    scaledh = TJSCALED(jpegheight, sf[i]);\n    if (scaledw <= width && scaledh <= height)\n      break;\n  }\n  if (i >= NUMSF)\n    THROW(\"Could not scale down to desired image dimensions\");\n\n  width = scaledw;  height = scaledh;\n\n  processFlags(handle, flags, DECOMPRESS);\n\n  if (tj3SetScalingFactor(handle, sf[i]) == -1)\n    return -1;\n  return tj3DecompressToYUV8(handle, jpegBuf, (size_t)jpegSize, dstBuf, align);\n\nbailout:\n  if (dinfo->global_state > DSTATE_START) jpeg_abort_decompress(dinfo);\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n/* TurboJPEG 1.1+ */\nDLLEXPORT int tjDecompressToYUV(tjhandle handle, unsigned char *jpegBuf,\n                                unsigned long jpegSize, unsigned char *dstBuf,\n                                int flags)\n{\n  return tjDecompressToYUV2(handle, jpegBuf, jpegSize, dstBuf, 0, 4, 0, flags);\n}\n\n\nstatic void setDecodeDefaults(tjinstance *this, int pixelFormat)\n{\n  int i;\n\n  this->dinfo.scale_num = this->dinfo.scale_denom = 1;\n\n  if (this->subsamp == TJSAMP_GRAY) {\n    this->dinfo.num_components = this->dinfo.comps_in_scan = 1;\n    this->dinfo.jpeg_color_space = JCS_GRAYSCALE;\n  } else {\n    this->dinfo.num_components = this->dinfo.comps_in_scan = 3;\n    this->dinfo.jpeg_color_space = JCS_YCbCr;\n  }\n\n  this->dinfo.comp_info = (jpeg_component_info *)\n    (*this->dinfo.mem->alloc_small) ((j_common_ptr)&this->dinfo, JPOOL_IMAGE,\n                                     this->dinfo.num_components *\n                                     sizeof(jpeg_component_info));\n\n  for (i = 0; i < this->dinfo.num_components; i++) {\n    jpeg_component_info *compptr = &this->dinfo.comp_info[i];\n\n    compptr->h_samp_factor = (i == 0) ? tjMCUWidth[this->subsamp] / 8 : 1;\n    compptr->v_samp_factor = (i == 0) ? tjMCUHeight[this->subsamp] / 8 : 1;\n    compptr->component_index = i;\n    compptr->component_id = i + 1;\n    compptr->quant_tbl_no = compptr->dc_tbl_no =\n      compptr->ac_tbl_no = (i == 0) ? 0 : 1;\n    this->dinfo.cur_comp_info[i] = compptr;\n  }\n  this->dinfo.data_precision = 8;\n  for (i = 0; i < 2; i++) {\n    if (this->dinfo.quant_tbl_ptrs[i] == NULL)\n      this->dinfo.quant_tbl_ptrs[i] =\n        jpeg_alloc_quant_table((j_common_ptr)&this->dinfo);\n  }\n\n  this->dinfo.mem->max_memory_to_use = (long)this->maxMemory * 1048576L;\n}\n\n\nstatic int my_read_markers(j_decompress_ptr dinfo)\n{\n  return JPEG_REACHED_SOS;\n}\n\nstatic void my_reset_marker_reader(j_decompress_ptr dinfo)\n{\n}\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3DecodeYUVPlanes8(tjhandle handle,\n                                  const unsigned char * const *srcPlanes,\n                                  const int *strides, unsigned char *dstBuf,\n                                  int width, int pitch, int height,\n                                  int pixelFormat)\n{\n  static const char FUNCTION_NAME[] = \"tj3DecodeYUVPlanes8\";\n  JSAMPROW *row_pointer = NULL;\n  JSAMPLE *_tmpbuf[MAX_COMPONENTS];\n  JSAMPROW *tmpbuf[MAX_COMPONENTS], *inbuf[MAX_COMPONENTS];\n  int i, retval = 0, row, pw0, ph0, pw[MAX_COMPONENTS], ph[MAX_COMPONENTS];\n  JSAMPLE *ptr;\n  jpeg_component_info *compptr;\n  int (*old_read_markers) (j_decompress_ptr);\n  void (*old_reset_marker_reader) (j_decompress_ptr);\n\n  GET_DINSTANCE(handle);\n\n  for (i = 0; i < MAX_COMPONENTS; i++) {\n    tmpbuf[i] = NULL;  _tmpbuf[i] = NULL;  inbuf[i] = NULL;\n  }\n\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for decompression\");\n\n  if (!srcPlanes || !srcPlanes[0] || dstBuf == NULL || width <= 0 ||\n      pitch < 0 || height <= 0 || pixelFormat < 0 || pixelFormat >= TJ_NUMPF)\n    THROW(\"Invalid argument\");\n  if (this->subsamp != TJSAMP_GRAY && (!srcPlanes[1] || !srcPlanes[2]))\n    THROW(\"Invalid argument\");\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  if (this->subsamp == TJSAMP_UNKNOWN)\n    THROW(\"TJPARAM_SUBSAMP must be specified\");\n  if (pixelFormat == TJPF_CMYK)\n    THROW(\"Cannot decode YUV images into packed-pixel CMYK images.\");\n\n  if (pitch == 0) pitch = width * tjPixelSize[pixelFormat];\n  dinfo->image_width = width;\n  dinfo->image_height = height;\n\n  dinfo->progressive_mode = dinfo->inputctl->has_multiple_scans = FALSE;\n  dinfo->Ss = dinfo->Ah = dinfo->Al = 0;\n  dinfo->Se = DCTSIZE2 - 1;\n  setDecodeDefaults(this, pixelFormat);\n  old_read_markers = dinfo->marker->read_markers;\n  dinfo->marker->read_markers = my_read_markers;\n  old_reset_marker_reader = dinfo->marker->reset_marker_reader;\n  dinfo->marker->reset_marker_reader = my_reset_marker_reader;\n  jpeg_read_header(dinfo, TRUE);\n  dinfo->marker->read_markers = old_read_markers;\n  dinfo->marker->reset_marker_reader = old_reset_marker_reader;\n\n  this->dinfo.out_color_space = pf2cs[pixelFormat];\n  this->dinfo.dct_method = this->fastDCT ? JDCT_FASTEST : JDCT_ISLOW;\n  dinfo->do_fancy_upsampling = FALSE;\n  dinfo->Se = DCTSIZE2 - 1;\n  jinit_master_decompress(dinfo);\n  (*dinfo->upsample->start_pass) (dinfo);\n\n  pw0 = PAD(width, dinfo->max_h_samp_factor);\n  ph0 = PAD(height, dinfo->max_v_samp_factor);\n\n  if (pitch == 0) pitch = dinfo->output_width * tjPixelSize[pixelFormat];\n\n  if ((row_pointer = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph0)) == NULL)\n    THROW(\"Memory allocation failure\");\n  for (i = 0; i < height; i++) {\n    if (this->bottomUp)\n      row_pointer[i] = &dstBuf[(height - i - 1) * (size_t)pitch];\n    else\n      row_pointer[i] = &dstBuf[i * (size_t)pitch];\n  }\n  if (height < ph0)\n    for (i = height; i < ph0; i++) row_pointer[i] = row_pointer[height - 1];\n\n  for (i = 0; i < dinfo->num_components; i++) {\n    compptr = &dinfo->comp_info[i];\n    _tmpbuf[i] =\n      (JSAMPLE *)malloc(PAD(compptr->width_in_blocks * DCTSIZE, 32) *\n                        compptr->v_samp_factor + 32);\n    if (!_tmpbuf[i])\n      THROW(\"Memory allocation failure\");\n    tmpbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * compptr->v_samp_factor);\n    if (!tmpbuf[i])\n      THROW(\"Memory allocation failure\");\n    for (row = 0; row < compptr->v_samp_factor; row++) {\n      unsigned char *_tmpbuf_aligned =\n        (unsigned char *)PAD((JUINTPTR)_tmpbuf[i], 32);\n\n      tmpbuf[i][row] =\n        &_tmpbuf_aligned[PAD(compptr->width_in_blocks * DCTSIZE, 32) * row];\n    }\n    pw[i] = pw0 * compptr->h_samp_factor / dinfo->max_h_samp_factor;\n    ph[i] = ph0 * compptr->v_samp_factor / dinfo->max_v_samp_factor;\n    inbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph[i]);\n    if (!inbuf[i])\n      THROW(\"Memory allocation failure\");\n    ptr = (JSAMPLE *)srcPlanes[i];\n    for (row = 0; row < ph[i]; row++) {\n      inbuf[i][row] = ptr;\n      ptr += (strides && strides[i] != 0) ? strides[i] : pw[i];\n    }\n  }\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  for (row = 0; row < ph0; row += dinfo->max_v_samp_factor) {\n    JDIMENSION inrow = 0, outrow = 0;\n\n    for (i = 0, compptr = dinfo->comp_info; i < dinfo->num_components;\n         i++, compptr++)\n      jcopy_sample_rows(inbuf[i],\n        row * compptr->v_samp_factor / dinfo->max_v_samp_factor, tmpbuf[i], 0,\n        compptr->v_samp_factor, pw[i]);\n    (dinfo->upsample->upsample) (dinfo, tmpbuf, &inrow,\n                                 dinfo->max_v_samp_factor, &row_pointer[row],\n                                 &outrow, dinfo->max_v_samp_factor);\n  }\n  jpeg_abort_decompress(dinfo);\n\nbailout:\n  if (dinfo->global_state > DSTATE_START) jpeg_abort_decompress(dinfo);\n  free(row_pointer);\n  for (i = 0; i < MAX_COMPONENTS; i++) {\n    free(tmpbuf[i]);\n    free(_tmpbuf[i]);\n    free(inbuf[i]);\n  }\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjDecodeYUVPlanes(tjhandle handle,\n                                const unsigned char **srcPlanes,\n                                const int *strides, int subsamp,\n                                unsigned char *dstBuf, int width, int pitch,\n                                int height, int pixelFormat, int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjDecodeYUVPlanes\";\n  int retval = 0;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    THROW(\"Invalid argument\");\n\n  this->subsamp = subsamp;\n  processFlags(handle, flags, DECOMPRESS);\n\n  return tj3DecodeYUVPlanes8(handle, srcPlanes, strides, dstBuf, width, pitch,\n                             height, pixelFormat);\n\nbailout:\n  return retval;\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3DecodeYUV8(tjhandle handle, const unsigned char *srcBuf,\n                            int align, unsigned char *dstBuf, int width,\n                            int pitch, int height, int pixelFormat)\n{\n  static const char FUNCTION_NAME[] = \"tj3DecodeYUV8\";\n  const unsigned char *srcPlanes[3];\n  int pw0, ph0, strides[3], retval = -1;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (srcBuf == NULL || align < 1 || !IS_POW2(align) || width <= 0 ||\n      height <= 0)\n    THROW(\"Invalid argument\");\n\n  if (this->subsamp == TJSAMP_UNKNOWN)\n    THROW(\"TJPARAM_SUBSAMP must be specified\");\n\n  pw0 = tj3YUVPlaneWidth(0, width, this->subsamp);\n  ph0 = tj3YUVPlaneHeight(0, height, this->subsamp);\n  srcPlanes[0] = srcBuf;\n  strides[0] = PAD(pw0, align);\n  if (this->subsamp == TJSAMP_GRAY) {\n    strides[1] = strides[2] = 0;\n    srcPlanes[1] = srcPlanes[2] = NULL;\n  } else {\n    int pw1 = tj3YUVPlaneWidth(1, width, this->subsamp);\n    int ph1 = tj3YUVPlaneHeight(1, height, this->subsamp);\n\n    strides[1] = strides[2] = PAD(pw1, align);\n    if ((unsigned long long)strides[0] * (unsigned long long)ph0 >\n        (unsigned long long)INT_MAX ||\n        (unsigned long long)strides[1] * (unsigned long long)ph1 >\n        (unsigned long long)INT_MAX)\n      THROW(\"Image or row alignment is too large\");\n    srcPlanes[1] = srcPlanes[0] + strides[0] * ph0;\n    srcPlanes[2] = srcPlanes[1] + strides[1] * ph1;\n  }\n\n  return tj3DecodeYUVPlanes8(handle, srcPlanes, strides, dstBuf, width, pitch,\n                             height, pixelFormat);\n\nbailout:\n  return retval;\n}\n\n/* TurboJPEG 1.4+ */\nDLLEXPORT int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,\n                          int align, int subsamp, unsigned char *dstBuf,\n                          int width, int pitch, int height, int pixelFormat,\n                          int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjDecodeYUV\";\n  int retval = -1;\n\n  GET_TJINSTANCE(handle, -1);\n\n  if (subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    THROW(\"Invalid argument\");\n\n  this->subsamp = subsamp;\n  processFlags(handle, flags, DECOMPRESS);\n\n  return tj3DecodeYUV8(handle, srcBuf, align, dstBuf, width, pitch, height,\n                       pixelFormat);\n\nbailout:\n  return retval;\n}\n\n\n/******************************** Transformer ********************************/\n\n/* TurboJPEG 1.2+ */\nDLLEXPORT tjhandle tjInitTransform(void)\n{\n  return tj3Init(TJINIT_TRANSFORM);\n}\n\n\n/* TurboJPEG 3+ */\nDLLEXPORT int tj3Transform(tjhandle handle, const unsigned char *jpegBuf,\n                           size_t jpegSize, int n, unsigned char **dstBufs,\n                           size_t *dstSizes, const tjtransform *t)\n{\n  static const char FUNCTION_NAME[] = \"tj3Transform\";\n  jpeg_transform_info *xinfo = NULL;\n  jvirt_barray_ptr *srccoefs, *dstcoefs;\n  int retval = 0, i, saveMarkers = 0, srcSubsamp;\n  boolean alloc = TRUE;\n  struct my_progress_mgr progress;\n\n  GET_INSTANCE(handle);\n  if ((this->init & COMPRESS) == 0 || (this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for transformation\");\n\n  if (jpegBuf == NULL || jpegSize <= 0 || n < 1 || dstBufs == NULL ||\n      dstSizes == NULL || t == NULL)\n    THROW(\"Invalid argument\");\n\n  if (this->scanLimit) {\n    memset(&progress, 0, sizeof(struct my_progress_mgr));\n    progress.pub.progress_monitor = my_progress_monitor;\n    progress.this = this;\n    dinfo->progress = &progress.pub;\n  } else\n    dinfo->progress = NULL;\n\n  dinfo->mem->max_memory_to_use = (long)this->maxMemory * 1048576L;\n\n  if ((xinfo =\n       (jpeg_transform_info *)malloc(sizeof(jpeg_transform_info) * n)) == NULL)\n    THROW(\"Memory allocation failure\");\n  memset(xinfo, 0, sizeof(jpeg_transform_info) * n);\n\n  if (setjmp(this->jerr.setjmp_buffer)) {\n    /* If we get here, the JPEG code has signaled an error. */\n    retval = -1;  goto bailout;\n  }\n\n  if (dinfo->global_state <= DSTATE_INHEADER)\n    jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);\n\n  for (i = 0; i < n; i++) {\n    if (t[i].op < 0 || t[i].op >= TJ_NUMXOP)\n      THROW(\"Invalid transform operation\");\n    xinfo[i].transform = xformtypes[t[i].op];\n    xinfo[i].perfect = (t[i].options & TJXOPT_PERFECT) ? 1 : 0;\n    xinfo[i].trim = (t[i].options & TJXOPT_TRIM) ? 1 : 0;\n    xinfo[i].force_grayscale = (t[i].options & TJXOPT_GRAY) ? 1 : 0;\n    xinfo[i].crop = (t[i].options & TJXOPT_CROP) ? 1 : 0;\n    if (n != 1 && t[i].op == TJXOP_HFLIP) xinfo[i].slow_hflip = 1;\n    else xinfo[i].slow_hflip = 0;\n\n    if (xinfo[i].crop) {\n      if (t[i].r.x < 0 || t[i].r.y < 0 || t[i].r.w < 0 || t[i].r.h < 0)\n        THROW(\"Invalid cropping region\");\n      xinfo[i].crop_xoffset = t[i].r.x;  xinfo[i].crop_xoffset_set = JCROP_POS;\n      xinfo[i].crop_yoffset = t[i].r.y;  xinfo[i].crop_yoffset_set = JCROP_POS;\n      if (t[i].r.w != 0) {\n        xinfo[i].crop_width = t[i].r.w;  xinfo[i].crop_width_set = JCROP_POS;\n      } else\n        xinfo[i].crop_width = JCROP_UNSET;\n      if (t[i].r.h != 0) {\n        xinfo[i].crop_height = t[i].r.h;  xinfo[i].crop_height_set = JCROP_POS;\n      } else\n        xinfo[i].crop_height = JCROP_UNSET;\n    }\n    if (!(t[i].options & TJXOPT_COPYNONE)) saveMarkers = 1;\n  }\n\n  jcopy_markers_setup(dinfo, saveMarkers ? JCOPYOPT_ALL : JCOPYOPT_NONE);\n  if (dinfo->global_state <= DSTATE_INHEADER)\n    jpeg_read_header(dinfo, TRUE);\n  if (this->maxPixels &&\n      (unsigned long long)dinfo->image_width * dinfo->image_height >\n      (unsigned long long)this->maxPixels)\n    THROW(\"Image is too large\");\n  srcSubsamp = getSubsamp(&this->dinfo);\n\n  for (i = 0; i < n; i++) {\n    if (!jtransform_request_workspace(dinfo, &xinfo[i]))\n      THROW(\"Transform is not perfect\");\n\n    if (xinfo[i].crop) {\n      int dstSubsamp = (t[i].options & TJXOPT_GRAY) ? TJSAMP_GRAY : srcSubsamp;\n\n      if (t[i].op == TJXOP_TRANSPOSE || t[i].op == TJXOP_TRANSVERSE ||\n          t[i].op == TJXOP_ROT90 || t[i].op == TJXOP_ROT270) {\n        if (dstSubsamp == TJSAMP_422) dstSubsamp = TJSAMP_440;\n        else if (dstSubsamp == TJSAMP_440) dstSubsamp = TJSAMP_422;\n        else if (dstSubsamp == TJSAMP_411) dstSubsamp = TJSAMP_441;\n        else if (dstSubsamp == TJSAMP_441) dstSubsamp = TJSAMP_411;\n      }\n      if (dstSubsamp == TJSAMP_UNKNOWN)\n        THROW(\"Could not determine subsampling level of destination image\");\n      if ((t[i].r.x % tjMCUWidth[dstSubsamp]) != 0 ||\n          (t[i].r.y % tjMCUHeight[dstSubsamp]) != 0)\n        THROWI(\"To crop this JPEG image, x must be a multiple of %d\\n\"\n               \"and y must be a multiple of %d.\", tjMCUWidth[dstSubsamp],\n               tjMCUHeight[dstSubsamp]);\n    }\n  }\n\n  srccoefs = jpeg_read_coefficients(dinfo);\n\n  for (i = 0; i < n; i++) {\n    JDIMENSION dstWidth = dinfo->image_width, dstHeight = dinfo->image_height;\n\n    if (t[i].op == TJXOP_TRANSPOSE || t[i].op == TJXOP_TRANSVERSE ||\n        t[i].op == TJXOP_ROT90 || t[i].op == TJXOP_ROT270) {\n      dstWidth = dinfo->image_height;  dstHeight = dinfo->image_width;\n    }\n\n    if (xinfo[i].crop) {\n      if ((JDIMENSION)t[i].r.x >= dstWidth ||\n          t[i].r.x + xinfo[i].crop_width > dstWidth ||\n          (JDIMENSION)t[i].r.y >= dstHeight ||\n          t[i].r.y + xinfo[i].crop_height > dstHeight)\n        THROW(\"The cropping region exceeds the destination image dimensions\");\n      dstWidth = xinfo[i].crop_width;  dstHeight = xinfo[i].crop_height;\n    }\n    if (this->noRealloc) {\n      int dstSubsamp = (t[i].options & TJXOPT_GRAY) ? TJSAMP_GRAY : srcSubsamp;\n\n      if (t[i].op == TJXOP_TRANSPOSE || t[i].op == TJXOP_TRANSVERSE ||\n          t[i].op == TJXOP_ROT90 || t[i].op == TJXOP_ROT270) {\n        if (dstSubsamp == TJSAMP_422) dstSubsamp = TJSAMP_440;\n        else if (dstSubsamp == TJSAMP_440) dstSubsamp = TJSAMP_422;\n        else if (dstSubsamp == TJSAMP_411) dstSubsamp = TJSAMP_441;\n        else if (dstSubsamp == TJSAMP_441) dstSubsamp = TJSAMP_411;\n      }\n      if (dstSubsamp == TJSAMP_UNKNOWN)\n        THROW(\"Could not determine subsampling level of destination image\");\n      alloc = FALSE;\n      dstSizes[i] = tj3JPEGBufSize(dstWidth, dstHeight, dstSubsamp);\n    }\n    if (!(t[i].options & TJXOPT_NOOUTPUT))\n      jpeg_mem_dest_tj(cinfo, &dstBufs[i], &dstSizes[i], alloc);\n    jpeg_copy_critical_parameters(dinfo, cinfo);\n    dstcoefs = jtransform_adjust_parameters(dinfo, cinfo, srccoefs, &xinfo[i]);\n    if (this->optimize || t[i].options & TJXOPT_OPTIMIZE)\n      cinfo->optimize_coding = TRUE;\n#ifdef C_PROGRESSIVE_SUPPORTED\n    if (this->progressive || t[i].options & TJXOPT_PROGRESSIVE)\n      jpeg_simple_progression(cinfo);\n#endif\n    if (this->arithmetic || t[i].options & TJXOPT_ARITHMETIC) {\n      cinfo->arith_code = TRUE;\n      cinfo->optimize_coding = FALSE;\n    }\n    if (!(t[i].options & TJXOPT_NOOUTPUT)) {\n      jpeg_write_coefficients(cinfo, dstcoefs);\n      jcopy_markers_execute(dinfo, cinfo, t[i].options & TJXOPT_COPYNONE ?\n                                          JCOPYOPT_NONE : JCOPYOPT_ALL);\n    } else\n      jinit_c_master_control(cinfo, TRUE);\n    jtransform_execute_transformation(dinfo, cinfo, srccoefs, &xinfo[i]);\n    if (t[i].customFilter) {\n      int ci, y;\n      JDIMENSION by;\n\n      for (ci = 0; ci < cinfo->num_components; ci++) {\n        jpeg_component_info *compptr = &cinfo->comp_info[ci];\n        tjregion arrayRegion = { 0, 0, 0, 0 };\n        tjregion planeRegion = { 0, 0, 0, 0 };\n\n        arrayRegion.w = compptr->width_in_blocks * DCTSIZE;\n        arrayRegion.h = DCTSIZE;\n        planeRegion.w = compptr->width_in_blocks * DCTSIZE;\n        planeRegion.h = compptr->height_in_blocks * DCTSIZE;\n\n        for (by = 0; by < compptr->height_in_blocks;\n             by += compptr->v_samp_factor) {\n          JBLOCKARRAY barray = (dinfo->mem->access_virt_barray)\n            ((j_common_ptr)dinfo, dstcoefs[ci], by, compptr->v_samp_factor,\n             TRUE);\n\n          for (y = 0; y < compptr->v_samp_factor; y++) {\n            if (t[i].customFilter(barray[y][0], arrayRegion, planeRegion, ci,\n                                  i, (tjtransform *)&t[i]) == -1)\n              THROW(\"Error in custom filter\");\n            arrayRegion.y += DCTSIZE;\n          }\n        }\n      }\n    }\n    if (!(t[i].options & TJXOPT_NOOUTPUT)) jpeg_finish_compress(cinfo);\n  }\n\n  jpeg_finish_decompress(dinfo);\n\nbailout:\n  if (cinfo->global_state > CSTATE_START) {\n    if (alloc) (*cinfo->dest->term_destination) (cinfo);\n    jpeg_abort_compress(cinfo);\n  }\n  if (dinfo->global_state > DSTATE_START) jpeg_abort_decompress(dinfo);\n  free(xinfo);\n  if (this->jerr.warning) retval = -1;\n  return retval;\n}\n\n/* TurboJPEG 1.2+ */\nDLLEXPORT int tjTransform(tjhandle handle, const unsigned char *jpegBuf,\n                          unsigned long jpegSize, int n,\n                          unsigned char **dstBufs, unsigned long *dstSizes,\n                          tjtransform *t, int flags)\n{\n  static const char FUNCTION_NAME[] = \"tjTransform\";\n  int i, retval = 0;\n  size_t *sizes = NULL;\n\n  GET_TJINSTANCE(handle, -1);\n  if ((this->init & DECOMPRESS) == 0)\n    THROW(\"Instance has not been initialized for decompression\");\n\n  if (n < 1 || dstSizes == NULL)\n    THROW(\"Invalid argument\");\n\n  processFlags(handle, flags, COMPRESS);\n\n  if ((sizes = (size_t *)malloc(n * sizeof(size_t))) == NULL)\n    THROW(\"Memory allocation failure\");\n  for (i = 0; i < n; i++)\n    sizes[i] = (size_t)dstSizes[i];\n  retval = tj3Transform(handle, jpegBuf, (size_t)jpegSize, n, dstBufs, sizes,\n                        t);\n  for (i = 0; i < n; i++)\n    dstSizes[i] = (unsigned long)sizes[i];\n\nbailout:\n  free(sizes);\n  return retval;\n}\n\n\n/*************************** Packed-Pixel Image I/O **************************/\n\n/* tj3LoadImage*() is implemented in turbojpeg-mp.c */\n\n/* TurboJPEG 2.0+ */\nDLLEXPORT unsigned char *tjLoadImage(const char *filename, int *width,\n                                     int align, int *height,\n                                     int *pixelFormat, int flags)\n{\n  tjhandle handle = NULL;\n  unsigned char *dstBuf = NULL;\n\n  if ((handle = tj3Init(TJINIT_COMPRESS)) == NULL) return NULL;\n\n  processFlags(handle, flags, COMPRESS);\n\n  dstBuf = tj3LoadImage8(handle, filename, width, align, height, pixelFormat);\n\n  tj3Destroy(handle);\n  return dstBuf;\n}\n\n\n/* tj3SaveImage*() is implemented in turbojpeg-mp.c */\n\n/* TurboJPEG 2.0+ */\nDLLEXPORT int tjSaveImage(const char *filename, unsigned char *buffer,\n                          int width, int pitch, int height, int pixelFormat,\n                          int flags)\n{\n  tjhandle handle = NULL;\n  int retval = -1;\n\n  if ((handle = tj3Init(TJINIT_DECOMPRESS)) == NULL) return -1;\n\n  processFlags(handle, flags, DECOMPRESS);\n\n  retval = tj3SaveImage8(handle, filename, buffer, width, pitch, height,\n                         pixelFormat);\n\n  tj3Destroy(handle);\n  return retval;\n}\n"
        },
        {
          "name": "turbojpeg.h",
          "type": "blob",
          "size": 97.9873046875,
          "content": "/*\n * Copyright (C)2009-2015, 2017, 2020-2024 D. R. Commander.\n *                                         All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * - Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * - Neither the name of the libjpeg-turbo Project nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef __TURBOJPEG_H__\n#define __TURBOJPEG_H__\n\n#include <stddef.h>\n\n#if defined(_WIN32) && defined(DLLDEFINE)\n#define DLLEXPORT  __declspec(dllexport)\n#else\n#define DLLEXPORT\n#endif\n#define DLLCALL\n\n\n/**\n * @addtogroup TurboJPEG\n * TurboJPEG API.  This API provides an interface for generating, decoding, and\n * transforming planar YUV and JPEG images in memory.\n *\n * @anchor YUVnotes\n * YUV Image Format Notes\n * ----------------------\n * Technically, the JPEG format uses the YCbCr colorspace (which is technically\n * not a colorspace but a color transform), but per the convention of the\n * digital video community, the TurboJPEG API uses \"YUV\" to refer to an image\n * format consisting of Y, Cb, and Cr image planes.\n *\n * Each plane is simply a 2D array of bytes, each byte representing the value\n * of one of the components (Y, Cb, or Cr) at a particular location in the\n * image.  The width and height of each plane are determined by the image\n * width, height, and level of chrominance subsampling.  The luminance plane\n * width is the image width padded to the nearest multiple of the horizontal\n * subsampling factor (1 in the case of 4:4:4, grayscale, 4:4:0, or 4:4:1; 2 in\n * the case of 4:2:2 or 4:2:0; 4 in the case of 4:1:1.)  Similarly, the\n * luminance plane height is the image height padded to the nearest multiple of\n * the vertical subsampling factor (1 in the case of 4:4:4, 4:2:2, grayscale,\n * or 4:1:1; 2 in the case of 4:2:0 or 4:4:0; 4 in the case of 4:4:1.)  This is\n * irrespective of any additional padding that may be specified as an argument\n * to the various YUV functions.  The chrominance plane width is equal to the\n * luminance plane width divided by the horizontal subsampling factor, and the\n * chrominance plane height is equal to the luminance plane height divided by\n * the vertical subsampling factor.\n *\n * For example, if the source image is 35 x 35 pixels and 4:2:2 subsampling is\n * used, then the luminance plane would be 36 x 35 bytes, and each of the\n * chrominance planes would be 18 x 35 bytes.  If you specify a row alignment\n * of 4 bytes on top of this, then the luminance plane would be 36 x 35 bytes,\n * and each of the chrominance planes would be 20 x 35 bytes.\n *\n * @{\n */\n\n\n/**\n * The number of initialization options\n */\n#define TJ_NUMINIT  3\n\n/**\n * Initialization options\n */\nenum TJINIT {\n  /**\n   * Initialize the TurboJPEG instance for compression.\n   */\n  TJINIT_COMPRESS,\n  /**\n   * Initialize the TurboJPEG instance for decompression.\n   */\n  TJINIT_DECOMPRESS,\n  /**\n   * Initialize the TurboJPEG instance for lossless transformation (both\n   * compression and decompression.)\n   */\n  TJINIT_TRANSFORM\n};\n\n\n/**\n * The number of chrominance subsampling options\n */\n#define TJ_NUMSAMP  7\n\n/**\n * Chrominance subsampling options\n *\n * When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK\n * to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of\n * the Cb and Cr (chrominance) components can be discarded or averaged together\n * to produce a smaller image with little perceptible loss of image quality.\n * (The human eye is more sensitive to small changes in brightness than to\n * small changes in color.)  This is called \"chrominance subsampling\".\n */\nenum TJSAMP {\n  /**\n   * 4:4:4 chrominance subsampling (no chrominance subsampling)\n   *\n   * The JPEG or YUV image will contain one chrominance component for every\n   * pixel in the source image.\n   */\n  TJSAMP_444,\n  /**\n   * 4:2:2 chrominance subsampling\n   *\n   * The JPEG or YUV image will contain one chrominance component for every 2x1\n   * block of pixels in the source image.\n   */\n  TJSAMP_422,\n  /**\n   * 4:2:0 chrominance subsampling\n   *\n   * The JPEG or YUV image will contain one chrominance component for every 2x2\n   * block of pixels in the source image.\n   */\n  TJSAMP_420,\n  /**\n   * Grayscale\n   *\n   * The JPEG or YUV image will contain no chrominance components.\n   */\n  TJSAMP_GRAY,\n  /**\n   * 4:4:0 chrominance subsampling\n   *\n   * The JPEG or YUV image will contain one chrominance component for every 1x2\n   * block of pixels in the source image.\n   *\n   * @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo.\n   */\n  TJSAMP_440,\n  /**\n   * 4:1:1 chrominance subsampling\n   *\n   * The JPEG or YUV image will contain one chrominance component for every 4x1\n   * block of pixels in the source image.  All else being equal, a JPEG image\n   * with 4:1:1 subsampling is almost exactly the same size as a JPEG image\n   * with 4:2:0 subsampling, and in the aggregate, both subsampling methods\n   * produce approximately the same perceptual quality.  However, 4:1:1 is\n   * better able to reproduce sharp horizontal features.\n   *\n   * @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo.\n   */\n  TJSAMP_411,\n  /**\n   * 4:4:1 chrominance subsampling\n   *\n   * The JPEG or YUV image will contain one chrominance component for every 1x4\n   * block of pixels in the source image.  All else being equal, a JPEG image\n   * with 4:4:1 subsampling is almost exactly the same size as a JPEG image\n   * with 4:2:0 subsampling, and in the aggregate, both subsampling methods\n   * produce approximately the same perceptual quality.  However, 4:4:1 is\n   * better able to reproduce sharp vertical features.\n   *\n   * @note 4:4:1 subsampling is not fully accelerated in libjpeg-turbo.\n   */\n  TJSAMP_441,\n  /**\n   * Unknown subsampling\n   *\n   * The JPEG image uses an unusual type of chrominance subsampling.  Such\n   * images can be decompressed into packed-pixel images, but they cannot be\n   * - decompressed into planar YUV images,\n   * - losslessly transformed if #TJXOPT_CROP is specified and #TJXOPT_GRAY is\n   * not specified, or\n   * - partially decompressed using a cropping region.\n   */\n  TJSAMP_UNKNOWN = -1\n};\n\n/**\n * iMCU width (in pixels) for a given level of chrominance subsampling\n *\n * In a typical lossy JPEG image, 8x8 blocks of DCT coefficients for each\n * component are interleaved in a single scan.  If the image uses chrominance\n * subsampling, then multiple luminance blocks are stored together, followed by\n * a single block for each chrominance component.  The minimum set of\n * full-resolution luminance block(s) and corresponding (possibly subsampled)\n * chrominance blocks necessary to represent at least one DCT block per\n * component is called a \"Minimum Coded Unit\" or \"MCU\".  (For example, an MCU\n * in an interleaved lossy JPEG image that uses 4:2:2 subsampling consists of\n * two luminance blocks followed by one block for each chrominance component.)\n * In a non-interleaved lossy JPEG image, each component is stored in a\n * separate scan, and an MCU is a single DCT block, so we use the term \"iMCU\"\n * (interleaved MCU) to refer to the equivalent of an MCU in an interleaved\n * JPEG image.  For the common case of interleaved JPEG images, an iMCU is the\n * same as an MCU.\n *\n * iMCU sizes:\n * - 8x8 for no subsampling or grayscale\n * - 16x8 for 4:2:2\n * - 8x16 for 4:4:0\n * - 16x16 for 4:2:0\n * - 32x8 for 4:1:1\n * - 8x32 for 4:4:1\n */\nstatic const int tjMCUWidth[TJ_NUMSAMP]  = { 8, 16, 16, 8, 8, 32, 8 };\n\n/**\n * iMCU height (in pixels) for a given level of chrominance subsampling\n *\n * In a typical lossy JPEG image, 8x8 blocks of DCT coefficients for each\n * component are interleaved in a single scan.  If the image uses chrominance\n * subsampling, then multiple luminance blocks are stored together, followed by\n * a single block for each chrominance component.  The minimum set of\n * full-resolution luminance block(s) and corresponding (possibly subsampled)\n * chrominance blocks necessary to represent at least one DCT block per\n * component is called a \"Minimum Coded Unit\" or \"MCU\".  (For example, an MCU\n * in an interleaved lossy JPEG image that uses 4:2:2 subsampling consists of\n * two luminance blocks followed by one block for each chrominance component.)\n * In a non-interleaved lossy JPEG image, each component is stored in a\n * separate scan, and an MCU is a single DCT block, so we use the term \"iMCU\"\n * (interleaved MCU) to refer to the equivalent of an MCU in an interleaved\n * JPEG image.  For the common case of interleaved JPEG images, an iMCU is the\n * same as an MCU.\n *\n * iMCU sizes:\n * - 8x8 for no subsampling or grayscale\n * - 16x8 for 4:2:2\n * - 8x16 for 4:4:0\n * - 16x16 for 4:2:0\n * - 32x8 for 4:1:1\n * - 8x32 for 4:4:1\n */\nstatic const int tjMCUHeight[TJ_NUMSAMP] = { 8, 8, 16, 8, 16, 8, 32 };\n\n\n/**\n * The number of pixel formats\n */\n#define TJ_NUMPF  12\n\n/**\n * Pixel formats\n */\nenum TJPF {\n  /**\n   * RGB pixel format\n   *\n   * The red, green, and blue components in the image are stored in 3-sample\n   * pixels in the order R, G, B from lowest to highest memory address within\n   * each pixel.\n   */\n  TJPF_RGB,\n  /**\n   * BGR pixel format\n   *\n   * The red, green, and blue components in the image are stored in 3-sample\n   * pixels in the order B, G, R from lowest to highest memory address within\n   * each pixel.\n   */\n  TJPF_BGR,\n  /**\n   * RGBX pixel format\n   *\n   * The red, green, and blue components in the image are stored in 4-sample\n   * pixels in the order R, G, B from lowest to highest memory address within\n   * each pixel.  The X component is ignored when compressing/encoding and\n   * undefined when decompressing/decoding.\n   */\n  TJPF_RGBX,\n  /**\n   * BGRX pixel format\n   *\n   * The red, green, and blue components in the image are stored in 4-sample\n   * pixels in the order B, G, R from lowest to highest memory address within\n   * each pixel.  The X component is ignored when compressing/encoding and\n   * undefined when decompressing/decoding.\n   */\n  TJPF_BGRX,\n  /**\n   * XBGR pixel format\n   *\n   * The red, green, and blue components in the image are stored in 4-sample\n   * pixels in the order R, G, B from highest to lowest memory address within\n   * each pixel.  The X component is ignored when compressing/encoding and\n   * undefined when decompressing/decoding.\n   */\n  TJPF_XBGR,\n  /**\n   * XRGB pixel format\n   *\n   * The red, green, and blue components in the image are stored in 4-sample\n   * pixels in the order B, G, R from highest to lowest memory address within\n   * each pixel.  The X component is ignored when compressing/encoding and\n   * undefined when decompressing/decoding.\n   */\n  TJPF_XRGB,\n  /**\n   * Grayscale pixel format\n   *\n   * Each 1-sample pixel represents a luminance (brightness) level from 0 to\n   * the maximum sample value (255 for 8-bit samples, 4095 for 12-bit samples,\n   * and 65535 for 16-bit samples.)\n   */\n  TJPF_GRAY,\n  /**\n   * RGBA pixel format\n   *\n   * This is the same as @ref TJPF_RGBX, except that when\n   * decompressing/decoding, the X component is guaranteed to be equal to the\n   * maximum sample value, which can be interpreted as an opaque alpha channel.\n   */\n  TJPF_RGBA,\n  /**\n   * BGRA pixel format\n   *\n   * This is the same as @ref TJPF_BGRX, except that when\n   * decompressing/decoding, the X component is guaranteed to be equal to the\n   * maximum sample value, which can be interpreted as an opaque alpha channel.\n   */\n  TJPF_BGRA,\n  /**\n   * ABGR pixel format\n   *\n   * This is the same as @ref TJPF_XBGR, except that when\n   * decompressing/decoding, the X component is guaranteed to be equal to the\n   * maximum sample value, which can be interpreted as an opaque alpha channel.\n   */\n  TJPF_ABGR,\n  /**\n   * ARGB pixel format\n   *\n   * This is the same as @ref TJPF_XRGB, except that when\n   * decompressing/decoding, the X component is guaranteed to be equal to the\n   * maximum sample value, which can be interpreted as an opaque alpha channel.\n   */\n  TJPF_ARGB,\n  /**\n   * CMYK pixel format\n   *\n   * Unlike RGB, which is an additive color model used primarily for display,\n   * CMYK (Cyan/Magenta/Yellow/Key) is a subtractive color model used primarily\n   * for printing.  In the CMYK color model, the value of each color component\n   * typically corresponds to an amount of cyan, magenta, yellow, or black ink\n   * that is applied to a white background.  In order to convert between CMYK\n   * and RGB, it is necessary to use a color management system (CMS.)  A CMS\n   * will attempt to map colors within the printer's gamut to perceptually\n   * similar colors in the display's gamut and vice versa, but the mapping is\n   * typically not 1:1 or reversible, nor can it be defined with a simple\n   * formula.  Thus, such a conversion is out of scope for a codec library.\n   * However, the TurboJPEG API allows for compressing packed-pixel CMYK images\n   * into YCCK JPEG images (see #TJCS_YCCK) and decompressing YCCK JPEG images\n   * into packed-pixel CMYK images.\n   */\n  TJPF_CMYK,\n  /**\n   * Unknown pixel format\n   *\n   * Currently this is only used by #tj3LoadImage8(), #tj3LoadImage12(), and\n   * #tj3LoadImage16().\n   */\n  TJPF_UNKNOWN = -1\n};\n\n/**\n * Red offset (in samples) for a given pixel format\n *\n * This specifies the number of samples that the red component is offset from\n * the start of the pixel.  For instance, if an 8-bit-per-component pixel of\n * format TJPF_BGRX is stored in `unsigned char pixel[]`, then the red\n * component is `pixel[tjRedOffset[TJPF_BGRX]]`.  The offset is -1 if the pixel\n * format does not have a red component.\n */\nstatic const int tjRedOffset[TJ_NUMPF] = {\n  0, 2, 0, 2, 3, 1, -1, 0, 2, 3, 1, -1\n};\n/**\n * Green offset (in samples) for a given pixel format\n *\n * This specifies the number of samples that the green component is offset from\n * the start of the pixel.  For instance, if an 8-bit-per-component pixel of\n * format TJPF_BGRX is stored in `unsigned char pixel[]`, then the green\n * component is `pixel[tjGreenOffset[TJPF_BGRX]]`.  The offset is -1 if the\n * pixel format does not have a green component.\n */\nstatic const int tjGreenOffset[TJ_NUMPF] = {\n  1, 1, 1, 1, 2, 2, -1, 1, 1, 2, 2, -1\n};\n/**\n * Blue offset (in samples) for a given pixel format\n *\n * This specifies the number of samples that the blue component is offset from\n * the start of the pixel.  For instance, if an 8-bit-per-component pixel of\n * format TJPF_BGRX is stored in `unsigned char pixel[]`, then the blue\n * component is `pixel[tjBlueOffset[TJPF_BGRX]]`.  The offset is -1 if the\n * pixel format does not have a blue component.\n */\nstatic const int tjBlueOffset[TJ_NUMPF] = {\n  2, 0, 2, 0, 1, 3, -1, 2, 0, 1, 3, -1\n};\n/**\n * Alpha offset (in samples) for a given pixel format\n *\n * This specifies the number of samples that the alpha component is offset from\n * the start of the pixel.  For instance, if an 8-bit-per-component pixel of\n * format TJPF_BGRA is stored in `unsigned char pixel[]`, then the alpha\n * component is `pixel[tjAlphaOffset[TJPF_BGRA]]`.  The offset is -1 if the\n * pixel format does not have an alpha component.\n */\nstatic const int tjAlphaOffset[TJ_NUMPF] = {\n  -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1\n};\n/**\n * Pixel size (in samples) for a given pixel format\n */\nstatic const int tjPixelSize[TJ_NUMPF] = {\n  3, 3, 4, 4, 4, 4, 1, 4, 4, 4, 4, 4\n};\n\n\n/**\n * The number of JPEG colorspaces\n */\n#define TJ_NUMCS  5\n\n/**\n * JPEG colorspaces\n */\nenum TJCS {\n  /**\n   * RGB colorspace\n   *\n   * When generating the JPEG image, the R, G, and B components in the source\n   * image are reordered into image planes, but no colorspace conversion or\n   * subsampling is performed.  RGB JPEG images can be generated from and\n   * decompressed to packed-pixel images with any of the extended RGB or\n   * grayscale pixel formats, but they cannot be generated from or\n   * decompressed to planar YUV images.\n   */\n  TJCS_RGB,\n  /**\n   * YCbCr colorspace\n   *\n   * YCbCr is not an absolute colorspace but rather a mathematical\n   * transformation of RGB designed solely for storage and transmission.  YCbCr\n   * images must be converted to RGB before they can be displayed.  In the\n   * YCbCr colorspace, the Y (luminance) component represents the black & white\n   * portion of the original image, and the Cb and Cr (chrominance) components\n   * represent the color portion of the original image.  Historically, the\n   * analog equivalent of this transformation allowed the same signal to be\n   * displayed to both black & white and color televisions, but JPEG images use\n   * YCbCr primarily because it allows the color data to be optionally\n   * subsampled in order to reduce network and disk usage.  YCbCr is the most\n   * common JPEG colorspace, and YCbCr JPEG images can be generated from and\n   * decompressed to packed-pixel images with any of the extended RGB or\n   * grayscale pixel formats.  YCbCr JPEG images can also be generated from\n   * and decompressed to planar YUV images.\n   */\n  TJCS_YCbCr,\n  /**\n   * Grayscale colorspace\n   *\n   * The JPEG image retains only the luminance data (Y component), and any\n   * color data from the source image is discarded.  Grayscale JPEG images can\n   * be generated from and decompressed to packed-pixel images with any of the\n   * extended RGB or grayscale pixel formats, or they can be generated from\n   * and decompressed to planar YUV images.\n   */\n  TJCS_GRAY,\n  /**\n   * CMYK colorspace\n   *\n   * When generating the JPEG image, the C, M, Y, and K components in the\n   * source image are reordered into image planes, but no colorspace conversion\n   * or subsampling is performed.  CMYK JPEG images can only be generated from\n   * and decompressed to packed-pixel images with the CMYK pixel format.\n   */\n  TJCS_CMYK,\n  /**\n   * YCCK colorspace\n   *\n   * YCCK (AKA \"YCbCrK\") is not an absolute colorspace but rather a\n   * mathematical transformation of CMYK designed solely for storage and\n   * transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be\n   * reversibly transformed into YCCK, and as with YCbCr, the chrominance\n   * components in the YCCK pixels can be subsampled without incurring major\n   * perceptual loss.  YCCK JPEG images can only be generated from and\n   * decompressed to packed-pixel images with the CMYK pixel format.\n   */\n  TJCS_YCCK\n};\n\n\n/**\n * Parameters\n */\nenum TJPARAM {\n  /**\n   * Error handling behavior\n   *\n   * **Value**\n   * - `0` *[default]* Allow the current compression/decompression/transform\n   * operation to complete unless a fatal error is encountered.\n   * - `1` Immediately discontinue the current\n   * compression/decompression/transform operation if a warning (non-fatal\n   * error) occurs.\n   */\n  TJPARAM_STOPONWARNING,\n  /**\n   * Row order in packed-pixel source/destination images\n   *\n   * **Value**\n   * - `0` *[default]* top-down (X11) order\n   * - `1` bottom-up (Windows, OpenGL) order\n   */\n  TJPARAM_BOTTOMUP,\n  /**\n   * JPEG destination buffer (re)allocation [compression, lossless\n   * transformation]\n   *\n   * **Value**\n   * - `0` *[default]* Attempt to allocate or reallocate the JPEG destination\n   * buffer as needed.\n   * - `1` Generate an error if the JPEG destination buffer is invalid or too\n   * small.\n   */\n  TJPARAM_NOREALLOC,\n  /**\n   * Perceptual quality of lossy JPEG images [compression only]\n   *\n   * **Value**\n   * - `1`-`100` (`1` = worst quality but best compression, `100` = best\n   * quality but worst compression) *[no default; must be explicitly\n   * specified]*\n   */\n  TJPARAM_QUALITY,\n  /**\n   * Chrominance subsampling level\n   *\n   * The JPEG or YUV image uses (decompression, decoding) or will use (lossy\n   * compression, encoding) the specified level of chrominance subsampling.\n   *\n   * **Value**\n   * - One of the @ref TJSAMP \"chrominance subsampling options\" *[no default;\n   * must be explicitly specified for lossy compression, encoding, and\n   * decoding]*\n   */\n  TJPARAM_SUBSAMP,\n  /**\n   * JPEG width (in pixels) [decompression only, read-only]\n   */\n  TJPARAM_JPEGWIDTH,\n  /**\n   * JPEG height (in pixels) [decompression only, read-only]\n   */\n  TJPARAM_JPEGHEIGHT,\n  /**\n   * JPEG data precision (bits per sample) [decompression only, read-only]\n   *\n   * The JPEG image uses the specified number of bits per sample.\n   *\n   * **Value**\n   * - `8`, `12`, or `16`\n   *\n   * 12-bit data precision implies #TJPARAM_OPTIMIZE unless #TJPARAM_ARITHMETIC\n   * is set.\n   */\n  TJPARAM_PRECISION,\n  /**\n   * JPEG colorspace\n   *\n   * The JPEG image uses (decompression) or will use (lossy compression) the\n   * specified colorspace.\n   *\n   * **Value**\n   * - One of the @ref TJCS \"JPEG colorspaces\" *[default for lossy compression:\n   * automatically selected based on the subsampling level and pixel format]*\n   */\n  TJPARAM_COLORSPACE,\n  /**\n   * Chrominance upsampling algorithm [lossy decompression only]\n   *\n   * **Value**\n   * - `0` *[default]* Use smooth upsampling when decompressing a JPEG image\n   * that was generated using chrominance subsampling.  This creates a smooth\n   * transition between neighboring chrominance components in order to reduce\n   * upsampling artifacts in the decompressed image.\n   * - `1` Use the fastest chrominance upsampling algorithm available, which\n   * may combine upsampling with color conversion.\n   */\n  TJPARAM_FASTUPSAMPLE,\n  /**\n   * DCT/IDCT algorithm [lossy compression and decompression]\n   *\n   * **Value**\n   * - `0` *[default]* Use the most accurate DCT/IDCT algorithm available.\n   * - `1` Use the fastest DCT/IDCT algorithm available.\n   *\n   * This parameter is provided mainly for backward compatibility with libjpeg,\n   * which historically implemented several different DCT/IDCT algorithms\n   * because of performance limitations with 1990s CPUs.  In the libjpeg-turbo\n   * implementation of the TurboJPEG API:\n   * - The \"fast\" and \"accurate\" DCT/IDCT algorithms perform similarly on\n   * modern x86/x86-64 CPUs that support AVX2 instructions.\n   * - The \"fast\" algorithm is generally only about 5-15% faster than the\n   * \"accurate\" algorithm on other types of CPUs.\n   * - The difference in accuracy between the \"fast\" and \"accurate\" algorithms\n   * is the most pronounced at JPEG quality levels above 90 and tends to be\n   * more pronounced with decompression than with compression.\n   * - For JPEG quality levels above 97, the \"fast\" algorithm degrades and is\n   * not fully accelerated, so it is slower than the \"accurate\" algorithm.\n   */\n  TJPARAM_FASTDCT,\n  /**\n   * Huffman table optimization [lossy compression, lossless transformation]\n   *\n   * **Value**\n   * - `0` *[default]* The JPEG image will use the default Huffman tables.\n   * - `1` Optimal Huffman tables will be computed for the JPEG image.  For\n   * lossless transformation, this can also be specified using\n   * #TJXOPT_OPTIMIZE.\n   *\n   * Huffman table optimization improves compression slightly (generally 5% or\n   * less), but it reduces compression performance considerably.\n   */\n  TJPARAM_OPTIMIZE,\n  /**\n   * Progressive JPEG\n   *\n   * In a progressive JPEG image, the DCT coefficients are split across\n   * multiple \"scans\" of increasing quality.  Thus, a low-quality scan\n   * containing the lowest-frequency DCT coefficients can be transmitted first\n   * and refined with subsequent higher-quality scans containing\n   * higher-frequency DCT coefficients.  When using Huffman entropy coding, the\n   * progressive JPEG format also provides an \"end-of-bands (EOB) run\" feature\n   * that allows large groups of zeroes, potentially spanning multiple MCUs,\n   * to be represented using only a few bytes.\n   *\n   * **Value**\n   * - `0` *[default for compression, lossless transformation]* The lossy JPEG\n   * image is (decompression) or will be (compression, lossless transformation)\n   * single-scan.\n   * - `1` The lossy JPEG image is (decompression) or will be (compression,\n   * lossless transformation) progressive.  For lossless transformation, this\n   * can also be specified using #TJXOPT_PROGRESSIVE.\n   *\n   * Progressive JPEG images generally have better compression ratios than\n   * single-scan JPEG images (much better if the image has large areas of solid\n   * color), but progressive JPEG compression and decompression is considerably\n   * slower than single-scan JPEG compression and decompression.  Can be\n   * combined with #TJPARAM_ARITHMETIC.  Implies #TJPARAM_OPTIMIZE unless\n   * #TJPARAM_ARITHMETIC is also set.\n   */\n  TJPARAM_PROGRESSIVE,\n  /**\n   * Progressive JPEG scan limit for lossy JPEG images [decompression, lossless\n   * transformation]\n   *\n   * Setting this parameter causes the decompression and transform functions to\n   * return an error if the number of scans in a progressive JPEG image exceeds\n   * the specified limit.  The primary purpose of this is to allow\n   * security-critical applications to guard against an exploit of the\n   * progressive JPEG format described in\n   * <a href=\"https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf\" target=\"_blank\">this report</a>.\n   *\n   * **Value**\n   * - maximum number of progressive JPEG scans that the decompression and\n   * transform functions will process *[default: `0` (no limit)]*\n   *\n   * @see #TJPARAM_PROGRESSIVE\n   */\n  TJPARAM_SCANLIMIT,\n  /**\n   * Arithmetic entropy coding\n   *\n   * **Value**\n   * - `0` *[default for compression, lossless transformation]* The lossy JPEG\n   * image uses (decompression) or will use (compression, lossless\n   * transformation) Huffman entropy coding.\n   * - `1` The lossy JPEG image uses (decompression) or will use (compression,\n   * lossless transformation) arithmetic entropy coding.  For lossless\n   * transformation, this can also be specified using #TJXOPT_ARITHMETIC.\n   *\n   * Arithmetic entropy coding generally improves compression relative to\n   * Huffman entropy coding, but it reduces compression and decompression\n   * performance considerably.  Can be combined with #TJPARAM_PROGRESSIVE.\n   */\n  TJPARAM_ARITHMETIC,\n  /**\n   * Lossless JPEG\n   *\n   * **Value**\n   * - `0` *[default for compression]* The JPEG image is (decompression) or\n   * will be (compression) lossy/DCT-based.\n   * - `1` The JPEG image is (decompression) or will be (compression)\n   * lossless/predictive.\n   *\n   * In most cases, lossless JPEG compression and decompression is considerably\n   * slower than lossy JPEG compression and decompression, and lossless JPEG\n   * images are much larger than lossy JPEG images.  Thus, lossless JPEG images\n   * are typically used only for applications that require mathematically\n   * lossless compression.  Also note that the following features are not\n   * available with lossless JPEG images:\n   * - Colorspace conversion (lossless JPEG images always use #TJCS_RGB,\n   * #TJCS_GRAY, or #TJCS_CMYK, depending on the pixel format of the source\n   * image)\n   * - Chrominance subsampling (lossless JPEG images always use #TJSAMP_444)\n   * - JPEG quality selection\n   * - DCT/IDCT algorithm selection\n   * - Progressive JPEG\n   * - Arithmetic entropy coding\n   * - Compression from/decompression to planar YUV images\n   * - Decompression scaling\n   * - Lossless transformation\n   *\n   * @see #TJPARAM_LOSSLESSPSV, #TJPARAM_LOSSLESSPT\n   */\n  TJPARAM_LOSSLESS,\n  /**\n   * Lossless JPEG predictor selection value (PSV)\n   *\n   * **Value**\n   * - `1`-`7` *[default for compression: `1`]*\n   *\n   * Lossless JPEG compression shares no algorithms with lossy JPEG\n   * compression.  Instead, it uses differential pulse-code modulation (DPCM),\n   * an algorithm whereby each sample is encoded as the difference between the\n   * sample's value and a \"predictor\", which is based on the values of\n   * neighboring samples.  If Ra is the sample immediately to the left of the\n   * current sample, Rb is the sample immediately above the current sample, and\n   * Rc is the sample diagonally to the left and above the current sample, then\n   * the relationship between the predictor selection value and the predictor\n   * is as follows:\n   *\n   * PSV | Predictor\n   * ----|----------\n   * 1   | Ra\n   * 2   | Rb\n   * 3   | Rc\n   * 4   | Ra + Rb  Rc\n   * 5   | Ra + (Rb  Rc) / 2\n   * 6   | Rb + (Ra  Rc) / 2\n   * 7   | (Ra + Rb) / 2\n   *\n   * Predictors 1-3 are 1-dimensional predictors, whereas Predictors 4-7 are\n   * 2-dimensional predictors.  The best predictor for a particular image\n   * depends on the image.\n   *\n   * @see #TJPARAM_LOSSLESS\n   */\n  TJPARAM_LOSSLESSPSV,\n  /**\n   * Lossless JPEG point transform (Pt)\n   *\n   * **Value**\n   * - `0` through ***precision*** *- 1*, where ***precision*** is the JPEG\n   * data precision in bits *[default for compression: `0`]*\n   *\n   * A point transform value of `0` is necessary in order to generate a fully\n   * lossless JPEG image.  (A non-zero point transform value right-shifts the\n   * input samples by the specified number of bits, which is effectively a form\n   * of lossy color quantization.)\n   *\n   * @see #TJPARAM_LOSSLESS, #TJPARAM_PRECISION\n   */\n  TJPARAM_LOSSLESSPT,\n  /**\n   * JPEG restart marker interval in MCUs [lossy compression only]\n   *\n   * The nature of entropy coding is such that a corrupt JPEG image cannot\n   * be decompressed beyond the point of corruption unless it contains restart\n   * markers.  A restart marker stops and restarts the entropy coding algorithm\n   * so that, if a JPEG image is corrupted, decompression can resume at the\n   * next marker.  Thus, adding more restart markers improves the fault\n   * tolerance of the JPEG image, but adding too many restart markers can\n   * adversely affect the compression ratio and performance.\n   *\n   * In typical JPEG images, an MCU (Minimum Coded Unit) is the minimum set of\n   * interleaved \"data units\" (8x8 DCT blocks if the image is lossy or samples\n   * if the image is lossless) necessary to represent at least one data unit\n   * per component.  (For example, an MCU in an interleaved lossy JPEG image\n   * that uses 4:2:2 subsampling consists of two luminance blocks followed by\n   * one block for each chrominance component.)  In single-component or\n   * non-interleaved JPEG images, an MCU is the same as a data unit.\n   *\n   * **Value**\n   * - the number of MCUs between each restart marker *[default: `0` (no\n   * restart markers)]*\n   *\n   * Setting this parameter to a non-zero value sets #TJPARAM_RESTARTROWS to 0.\n   */\n  TJPARAM_RESTARTBLOCKS,\n  /**\n   * JPEG restart marker interval in MCU rows [compression only]\n   *\n   * See #TJPARAM_RESTARTBLOCKS for a description of restart markers and MCUs.\n   * An MCU row is a row of MCUs spanning the entire width of the image.\n   *\n   * **Value**\n   * - the number of MCU rows between each restart marker *[default: `0` (no\n   * restart markers)]*\n   *\n   * Setting this parameter to a non-zero value sets #TJPARAM_RESTARTBLOCKS to\n   * 0.\n   */\n  TJPARAM_RESTARTROWS,\n  /**\n   * JPEG horizontal pixel density\n   *\n   * **Value**\n   * - The JPEG image has (decompression) or will have (compression) the\n   * specified horizontal pixel density *[default for compression: `1`]*.\n   *\n   * This value is stored in or read from the JPEG header.  It does not affect\n   * the contents of the JPEG image.  Note that this parameter is set by\n   * #tj3LoadImage8() when loading a Windows BMP file that contains pixel\n   * density information, and the value of this parameter is stored to a\n   * Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNITS\n   * is `2`.\n   *\n   * This parameter has no effect unless the JPEG colorspace (see\n   * #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY.\n   *\n   * @see TJPARAM_DENSITYUNITS\n   */\n  TJPARAM_XDENSITY,\n  /**\n   * JPEG vertical pixel density\n   *\n   * **Value**\n   * - The JPEG image has (decompression) or will have (compression) the\n   * specified vertical pixel density *[default for compression: `1`]*.\n   *\n   * This value is stored in or read from the JPEG header.  It does not affect\n   * the contents of the JPEG image.  Note that this parameter is set by\n   * #tj3LoadImage8() when loading a Windows BMP file that contains pixel\n   * density information, and the value of this parameter is stored to a\n   * Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNITS\n   * is `2`.\n   *\n   * This parameter has no effect unless the JPEG colorspace (see\n   * #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY.\n   *\n   * @see TJPARAM_DENSITYUNITS\n   */\n  TJPARAM_YDENSITY,\n  /**\n   * JPEG pixel density units\n   *\n   * **Value**\n   * - `0` *[default for compression]* The pixel density of the JPEG image is\n   * expressed (decompression) or will be expressed (compression) in unknown\n   * units.\n   * - `1` The pixel density of the JPEG image is expressed (decompression) or\n   * will be expressed (compression) in units of pixels/inch.\n   * - `2` The pixel density of the JPEG image is expressed (decompression) or\n   * will be expressed (compression) in units of pixels/cm.\n   *\n   * This value is stored in or read from the JPEG header.  It does not affect\n   * the contents of the JPEG image.  Note that this parameter is set by\n   * #tj3LoadImage8() when loading a Windows BMP file that contains pixel\n   * density information, and the value of this parameter is stored to a\n   * Windows BMP file by #tj3SaveImage8() if the value is `2`.\n   *\n   * This parameter has no effect unless the JPEG colorspace (see\n   * #TJPARAM_COLORSPACE) is #TJCS_YCbCr or #TJCS_GRAY.\n   *\n   * @see TJPARAM_XDENSITY, TJPARAM_YDENSITY\n   */\n  TJPARAM_DENSITYUNITS,\n  /**\n   * Memory limit for intermediate buffers\n   *\n   * **Value**\n   * - the maximum amount of memory (in megabytes) that will be allocated for\n   * intermediate buffers, which are used with progressive JPEG compression and\n   * decompression, Huffman table optimization, lossless JPEG compression, and\n   * lossless transformation *[default: `0` (no limit)]*\n   */\n  TJPARAM_MAXMEMORY,\n  /**\n   * Image size limit [decompression, lossless transformation, packed-pixel\n   * image loading]\n   *\n   * Setting this parameter causes the decompression, transform, and image\n   * loading functions to return an error if the number of pixels in the source\n   * image exceeds the specified limit.  This allows security-critical\n   * applications to guard against excessive memory consumption.\n   *\n   * **Value**\n   * - maximum number of pixels that the decompression, transform, and image\n   * loading functions will process *[default: `0` (no limit)]*\n   */\n  TJPARAM_MAXPIXELS\n};\n\n\n/**\n * The number of error codes\n */\n#define TJ_NUMERR  2\n\n/**\n * Error codes\n */\nenum TJERR {\n  /**\n   * The error was non-fatal and recoverable, but the destination image may\n   * still be corrupt.\n   */\n  TJERR_WARNING,\n  /**\n   * The error was fatal and non-recoverable.\n   */\n  TJERR_FATAL\n};\n\n\n/**\n * The number of transform operations\n */\n#define TJ_NUMXOP  8\n\n/**\n * Transform operations for #tj3Transform()\n */\nenum TJXOP {\n  /**\n   * Do not transform the position of the image pixels.\n   */\n  TJXOP_NONE,\n  /**\n   * Flip (mirror) image horizontally.  This transform is imperfect if there\n   * are any partial iMCUs on the right edge (see #TJXOPT_PERFECT.)\n   */\n  TJXOP_HFLIP,\n  /**\n   * Flip (mirror) image vertically.  This transform is imperfect if there are\n   * any partial iMCUs on the bottom edge (see #TJXOPT_PERFECT.)\n   */\n  TJXOP_VFLIP,\n  /**\n   * Transpose image (flip/mirror along upper left to lower right axis.)  This\n   * transform is always perfect.\n   */\n  TJXOP_TRANSPOSE,\n  /**\n   * Transverse transpose image (flip/mirror along upper right to lower left\n   * axis.)  This transform is imperfect if there are any partial iMCUs in the\n   * image (see #TJXOPT_PERFECT.)\n   */\n  TJXOP_TRANSVERSE,\n  /**\n   * Rotate image clockwise by 90 degrees.  This transform is imperfect if\n   * there are any partial iMCUs on the bottom edge (see #TJXOPT_PERFECT.)\n   */\n  TJXOP_ROT90,\n  /**\n   * Rotate image 180 degrees.  This transform is imperfect if there are any\n   * partial iMCUs in the image (see #TJXOPT_PERFECT.)\n   */\n  TJXOP_ROT180,\n  /**\n   * Rotate image counter-clockwise by 90 degrees.  This transform is imperfect\n   * if there are any partial iMCUs on the right edge (see #TJXOPT_PERFECT.)\n   */\n  TJXOP_ROT270\n};\n\n\n/**\n * This option causes #tj3Transform() to return an error if the transform is\n * not perfect.  Lossless transforms operate on iMCUs, the size of which\n * depends on the level of chrominance subsampling used (see #tjMCUWidth and\n * #tjMCUHeight.)  If the image's width or height is not evenly divisible by\n * the iMCU size, then there will be partial iMCUs on the right and/or bottom\n * edges.  It is not possible to move these partial iMCUs to the top or left of\n * the image, so any transform that would require that is \"imperfect.\"  If this\n * option is not specified, then any partial iMCUs that cannot be transformed\n * will be left in place, which will create odd-looking strips on the right or\n * bottom edge of the image.\n */\n#define TJXOPT_PERFECT  (1 << 0)\n/**\n * Discard any partial iMCUs that cannot be transformed.\n */\n#define TJXOPT_TRIM  (1 << 1)\n/**\n * Enable lossless cropping.  See #tj3Transform() for more information.\n */\n#define TJXOPT_CROP  (1 << 2)\n/**\n * Discard the color data in the source image, and generate a grayscale\n * destination image.\n */\n#define TJXOPT_GRAY  (1 << 3)\n/**\n * Do not generate a destination image.  (This can be used in conjunction with\n * a custom filter to capture the transformed DCT coefficients without\n * transcoding them.)\n */\n#define TJXOPT_NOOUTPUT  (1 << 4)\n/**\n * Generate a progressive destination image instead of a single-scan\n * destination image.  Progressive JPEG images generally have better\n * compression ratios than single-scan JPEG images (much better if the image\n * has large areas of solid color), but progressive JPEG decompression is\n * considerably slower than single-scan JPEG decompression.  Can be combined\n * with #TJXOPT_ARITHMETIC.  Implies #TJXOPT_OPTIMIZE unless #TJXOPT_ARITHMETIC\n * is also specified.\n */\n#define TJXOPT_PROGRESSIVE  (1 << 5)\n/**\n * Do not copy any extra markers (including Exif and ICC profile data) from the\n * source image to the destination image.\n */\n#define TJXOPT_COPYNONE  (1 << 6)\n/**\n * Enable arithmetic entropy coding in the destination image.  Arithmetic\n * entropy coding generally improves compression relative to Huffman entropy\n * coding (the default), but it reduces decompression performance considerably.\n * Can be combined with #TJXOPT_PROGRESSIVE.\n */\n#define TJXOPT_ARITHMETIC  (1 << 7)\n/**\n * Enable Huffman table optimization for the destination image.  Huffman table\n * optimization improves compression slightly (generally 5% or less.)\n */\n#define TJXOPT_OPTIMIZE  (1 << 8)\n\n\n/**\n * Scaling factor\n */\ntypedef struct {\n  /**\n   * Numerator\n   */\n  int num;\n  /**\n   * Denominator\n   */\n  int denom;\n} tjscalingfactor;\n\n/**\n * Cropping region\n */\ntypedef struct {\n  /**\n   * The left boundary of the cropping region.  For lossless transformation,\n   * this must be evenly divisible by the iMCU width (see #tjMCUWidth) of the\n   * destination image.  For decompression, this must be evenly divisible by\n   * the scaled iMCU width of the source image.\n   */\n  int x;\n  /**\n   * The upper boundary of the cropping region.  For lossless transformation,\n   * this must be evenly divisible by the iMCU height (see #tjMCUHeight) of the\n   * destination image.\n   */\n  int y;\n  /**\n   * The width of the cropping region.  Setting this to 0 is the equivalent of\n   * setting it to the width of the source JPEG image - x.\n   */\n  int w;\n  /**\n   * The height of the cropping region.  Setting this to 0 is the equivalent of\n   * setting it to the height of the source JPEG image - y.\n   */\n  int h;\n} tjregion;\n\n/**\n * A #tjregion structure that specifies no cropping\n */\nstatic const tjregion TJUNCROPPED = { 0, 0, 0, 0 };\n\n/**\n * Lossless transform\n */\ntypedef struct tjtransform {\n  /**\n   * Cropping region\n   */\n  tjregion r;\n  /**\n   * One of the @ref TJXOP \"transform operations\"\n   */\n  int op;\n  /**\n   * The bitwise OR of one of more of the @ref TJXOPT_ARITHMETIC\n   * \"transform options\"\n   */\n  int options;\n  /**\n   * Arbitrary data that can be accessed within the body of the callback\n   * function\n   */\n  void *data;\n  /**\n   * A callback function that can be used to modify the DCT coefficients after\n   * they are losslessly transformed but before they are transcoded to a new\n   * JPEG image.  This allows for custom filters or other transformations to be\n   * applied in the frequency domain.\n   *\n   * @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:\n   * This pointer is not guaranteed to be valid once the callback returns, so\n   * applications wishing to hand off the DCT coefficients to another function\n   * or library should make a copy of them within the body of the callback.)\n   *\n   * @param arrayRegion #tjregion structure containing the width and height of\n   * the array pointed to by `coeffs` as well as its offset relative to the\n   * component plane.  TurboJPEG implementations may choose to split each\n   * component plane into multiple DCT coefficient arrays and call the callback\n   * function once for each array.\n   *\n   * @param planeRegion #tjregion structure containing the width and height of\n   * the component plane to which `coeffs` belongs\n   *\n   * @param componentID ID number of the component plane to which `coeffs`\n   * belongs.  (Y, Cb, and Cr have, respectively, ID's of 0, 1, and 2 in\n   * typical JPEG images.)\n   *\n   * @param transformID ID number of the transformed image to which `coeffs`\n   * belongs.  This is the same as the index of the transform in the\n   * `transforms` array that was passed to #tj3Transform().\n   *\n   * @param transform a pointer to a #tjtransform structure that specifies the\n   * parameters and/or cropping region for this transform\n   *\n   * @return 0 if the callback was successful, or -1 if an error occurred.\n   */\n  int (*customFilter) (short *coeffs, tjregion arrayRegion,\n                       tjregion planeRegion, int componentID, int transformID,\n                       struct tjtransform *transform);\n} tjtransform;\n\n/**\n * TurboJPEG instance handle\n */\ntypedef void *tjhandle;\n\n\n/**\n * Compute the scaled value of `dimension` using the given scaling factor.\n * This macro performs the integer equivalent of `ceil(dimension *\n * scalingFactor)`.\n */\n#define TJSCALED(dimension, scalingFactor) \\\n  (((dimension) * scalingFactor.num + scalingFactor.denom - 1) / \\\n   scalingFactor.denom)\n\n/**\n * A #tjscalingfactor structure that specifies a scaling factor of 1/1 (no\n * scaling)\n */\nstatic const tjscalingfactor TJUNSCALED = { 1, 1 };\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/**\n * Create a new TurboJPEG instance.\n *\n * @param initType one of the @ref TJINIT \"initialization options\"\n *\n * @return a handle to the newly-created instance, or NULL if an error occurred\n * (see #tj3GetErrorStr().)\n */\nDLLEXPORT tjhandle tj3Init(int initType);\n\n\n/**\n * Destroy a TurboJPEG instance.\n *\n * @param handle handle to a TurboJPEG instance.  If the handle is NULL, then\n * this function has no effect.\n */\nDLLEXPORT void tj3Destroy(tjhandle handle);\n\n\n/**\n * Returns a descriptive error message explaining why the last command failed.\n *\n * @param handle handle to a TurboJPEG instance, or NULL if the error was\n * generated by a global function (but note that retrieving the error message\n * for a global function is thread-safe only on platforms that support\n * thread-local storage.)\n *\n * @return a descriptive error message explaining why the last command failed.\n */\nDLLEXPORT char *tj3GetErrorStr(tjhandle handle);\n\n\n/**\n * Returns a code indicating the severity of the last error.  See\n * @ref TJERR \"Error codes\".\n *\n * @param handle handle to a TurboJPEG instance\n *\n * @return a code indicating the severity of the last error.  See\n * @ref TJERR \"Error codes\".\n */\nDLLEXPORT int tj3GetErrorCode(tjhandle handle);\n\n\n/**\n * Set the value of a parameter.\n *\n * @param handle handle to a TurboJPEG instance\n *\n * @param param one of the @ref TJPARAM \"parameters\"\n *\n * @param value value of the parameter (refer to @ref TJPARAM\n * \"parameter documentation\")\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)\n */\nDLLEXPORT int tj3Set(tjhandle handle, int param, int value);\n\n\n/**\n * Get the value of a parameter.\n *\n * @param handle handle to a TurboJPEG instance\n *\n * @param param one of the @ref TJPARAM \"parameters\"\n *\n * @return the value of the specified parameter, or -1 if the value is unknown.\n */\nDLLEXPORT int tj3Get(tjhandle handle, int param);\n\n\n/**\n * Allocate a byte buffer for use with TurboJPEG.  You should always use this\n * function to allocate the JPEG destination buffer(s) for the compression and\n * transform functions unless you are disabling automatic buffer (re)allocation\n * (by setting #TJPARAM_NOREALLOC.)\n *\n * @param bytes the number of bytes to allocate\n *\n * @return a pointer to a newly-allocated buffer with the specified number of\n * bytes.\n *\n * @see tj3Free()\n */\nDLLEXPORT void *tj3Alloc(size_t bytes);\n\n\n/**\n * Free a byte buffer previously allocated by TurboJPEG.  You should always use\n * this function to free JPEG destination buffer(s) that were automatically\n * (re)allocated by the compression and transform functions or that were\n * manually allocated using #tj3Alloc().\n *\n * @param buffer address of the buffer to free.  If the address is NULL, then\n * this function has no effect.\n *\n * @see tj3Alloc()\n */\nDLLEXPORT void tj3Free(void *buffer);\n\n\n/**\n * The maximum size of the buffer (in bytes) required to hold a JPEG image with\n * the given parameters.  The number of bytes returned by this function is\n * larger than the size of the uncompressed source image.  The reason for this\n * is that the JPEG format uses 16-bit coefficients, so it is possible for a\n * very high-quality source image with very high-frequency content to expand\n * rather than compress when converted to the JPEG format.  Such images\n * represent very rare corner cases, but since there is no way to predict the\n * size of a JPEG image prior to compression, the corner cases have to be\n * handled.\n *\n * @param width width (in pixels) of the image\n *\n * @param height height (in pixels) of the image\n *\n * @param jpegSubsamp the level of chrominance subsampling to be used when\n * generating the JPEG image (see @ref TJSAMP\n * \"Chrominance subsampling options\".)  #TJSAMP_UNKNOWN is treated like\n * #TJSAMP_444, since a buffer large enough to hold a JPEG image with no\n * subsampling should also be large enough to hold a JPEG image with an\n * arbitrary level of subsampling.  Note that lossless JPEG images always\n * use #TJSAMP_444.\n *\n * @return the maximum size of the buffer (in bytes) required to hold the\n * image, or 0 if the arguments are out of bounds.\n */\nDLLEXPORT size_t tj3JPEGBufSize(int width, int height, int jpegSubsamp);\n\n\n/**\n * The size of the buffer (in bytes) required to hold a unified planar YUV\n * image with the given parameters.\n *\n * @param width width (in pixels) of the image\n *\n * @param align row alignment (in bytes) of the image (must be a power of 2.)\n * Setting this parameter to n specifies that each row in each plane of the\n * image will be padded to the nearest multiple of n bytes (1 = unpadded.)\n *\n * @param height height (in pixels) of the image\n *\n * @param subsamp level of chrominance subsampling in the image (see\n * @ref TJSAMP \"Chrominance subsampling options\".)\n *\n * @return the size of the buffer (in bytes) required to hold the image, or 0\n * if the arguments are out of bounds.\n */\nDLLEXPORT size_t tj3YUVBufSize(int width, int align, int height, int subsamp);\n\n\n/**\n * The size of the buffer (in bytes) required to hold a YUV image plane with\n * the given parameters.\n *\n * @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)\n *\n * @param width width (in pixels) of the YUV image.  NOTE: This is the width of\n * the whole image, not the plane width.\n *\n * @param stride bytes per row in the image plane.  Setting this to 0 is the\n * equivalent of setting it to the plane width.\n *\n * @param height height (in pixels) of the YUV image.  NOTE: This is the height\n * of the whole image, not the plane height.\n *\n * @param subsamp level of chrominance subsampling in the image (see\n * @ref TJSAMP \"Chrominance subsampling options\".)\n *\n * @return the size of the buffer (in bytes) required to hold the YUV image\n * plane, or 0 if the arguments are out of bounds.\n */\nDLLEXPORT size_t tj3YUVPlaneSize(int componentID, int width, int stride,\n                                 int height, int subsamp);\n\n\n/**\n * The plane width of a YUV image plane with the given parameters.  Refer to\n * @ref YUVnotes \"YUV Image Format Notes\" for a description of plane width.\n *\n * @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)\n *\n * @param width width (in pixels) of the YUV image\n *\n * @param subsamp level of chrominance subsampling in the image (see\n * @ref TJSAMP \"Chrominance subsampling options\".)\n *\n * @return the plane width of a YUV image plane with the given parameters, or 0\n * if the arguments are out of bounds.\n */\nDLLEXPORT int tj3YUVPlaneWidth(int componentID, int width, int subsamp);\n\n\n/**\n * The plane height of a YUV image plane with the given parameters.  Refer to\n * @ref YUVnotes \"YUV Image Format Notes\" for a description of plane height.\n *\n * @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)\n *\n * @param height height (in pixels) of the YUV image\n *\n * @param subsamp level of chrominance subsampling in the image (see\n * @ref TJSAMP \"Chrominance subsampling options\".)\n *\n * @return the plane height of a YUV image plane with the given parameters, or\n * 0 if the arguments are out of bounds.\n */\nDLLEXPORT int tj3YUVPlaneHeight(int componentID, int height, int subsamp);\n\n\n/**\n * Compress an 8-bit-per-sample packed-pixel RGB, grayscale, or CMYK image into\n * an 8-bit-per-sample JPEG image.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * compression\n *\n * @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,\n * or CMYK source image to be compressed.  This buffer should normally be\n * `pitch * height` samples in size.  However, you can also use this parameter\n * to compress from a specific region of a larger buffer.\n *\n * @param width width (in pixels) of the source image\n *\n * @param pitch samples per row in the source image.  Normally this should be\n * <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.\n * (Setting this parameter to 0 is the equivalent of setting it to\n * <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this\n * parameter to specify the row alignment/padding of the source image, to skip\n * rows, or to compress from a specific region of a larger buffer.\n *\n * @param height height (in pixels) of the source image\n *\n * @param pixelFormat pixel format of the source image (see @ref TJPF\n * \"Pixel formats\".)\n *\n * @param jpegBuf address of a pointer to a byte buffer that will receive the\n * JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to\n * accommodate the size of the JPEG image.  Thus, you can choose to:\n * -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and\n * let TurboJPEG grow the buffer as needed,\n * -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,\n * or\n * -# pre-allocate the buffer to a \"worst case\" size determined by calling\n * #tj3JPEGBufSize().  This should ensure that the buffer never has to be\n * re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)\n * .\n * If you choose option 1, then `*jpegSize` should be set to the size of your\n * pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,\n * you should always check `*jpegBuf` upon return from this function, as it may\n * have changed.\n *\n * @param jpegSize pointer to a size_t variable that holds the size of the JPEG\n * buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`\n * should be set to the size of the buffer.  Upon return, `*jpegSize` will\n * contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a\n * JPEG buffer that is being reused from a previous call to one of the JPEG\n * compression functions, then `*jpegSize` is ignored.\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3Compress8(tjhandle handle, const unsigned char *srcBuf,\n                           int width, int pitch, int height, int pixelFormat,\n                           unsigned char **jpegBuf, size_t *jpegSize);\n\n/**\n * Compress a 12-bit-per-sample packed-pixel RGB, grayscale, or CMYK image into\n * a 12-bit-per-sample JPEG image.\n *\n * \\details \\copydetails tj3Compress8()\n */\nDLLEXPORT int tj3Compress12(tjhandle handle, const short *srcBuf, int width,\n                            int pitch, int height, int pixelFormat,\n                            unsigned char **jpegBuf, size_t *jpegSize);\n\n/**\n * Compress a 16-bit-per-sample packed-pixel RGB, grayscale, or CMYK image into\n * a 16-bit-per-sample lossless JPEG image.\n *\n * \\details \\copydetails tj3Compress8()\n */\nDLLEXPORT int tj3Compress16(tjhandle handle, const unsigned short *srcBuf,\n                            int width, int pitch, int height, int pixelFormat,\n                            unsigned char **jpegBuf, size_t *jpegSize);\n\n\n/**\n * Compress a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into\n * an 8-bit-per-sample JPEG image.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * compression\n *\n * @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n * (or just a Y plane, if compressing a grayscale image) that contain a YUV\n * source image to be compressed.  These planes can be contiguous or\n * non-contiguous in memory.  The size of each plane should match the value\n * returned by #tj3YUVPlaneSize() for the given image width, height, strides,\n * and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer to\n * @ref YUVnotes \"YUV Image Format Notes\" for more details.\n *\n * @param width width (in pixels) of the source image.  If the width is not an\n * even multiple of the iMCU width (see #tjMCUWidth), then an intermediate\n * buffer copy will be performed.\n *\n * @param strides an array of integers, each specifying the number of bytes per\n * row in the corresponding plane of the YUV source image.  Setting the stride\n * for any plane to 0 is the same as setting it to the plane width (see\n * @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the\n * strides for all planes will be set to their respective plane widths.  You\n * can adjust the strides in order to specify an arbitrary amount of row\n * padding in each plane or to create a JPEG image from a subregion of a larger\n * planar YUV image.\n *\n * @param height height (in pixels) of the source image.  If the height is not\n * an even multiple of the iMCU height (see #tjMCUHeight), then an intermediate\n * buffer copy will be performed.\n *\n * @param jpegBuf address of a pointer to a byte buffer that will receive the\n * JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to\n * accommodate the size of the JPEG image.  Thus, you can choose to:\n * -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and\n * let TurboJPEG grow the buffer as needed,\n * -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,\n * or\n * -# pre-allocate the buffer to a \"worst case\" size determined by calling\n * #tj3JPEGBufSize().  This should ensure that the buffer never has to be\n * re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)\n * .\n * If you choose option 1, then `*jpegSize` should be set to the size of your\n * pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,\n * you should always check `*jpegBuf` upon return from this function, as it may\n * have changed.\n *\n * @param jpegSize pointer to a size_t variable that holds the size of the JPEG\n * buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`\n * should be set to the size of the buffer.  Upon return, `*jpegSize` will\n * contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a\n * JPEG buffer that is being reused from a previous call to one of the JPEG\n * compression functions, then `*jpegSize` is ignored.\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3CompressFromYUVPlanes8(tjhandle handle,\n                                        const unsigned char * const *srcPlanes,\n                                        int width, const int *strides,\n                                        int height, unsigned char **jpegBuf,\n                                        size_t *jpegSize);\n\n\n/**\n * Compress an 8-bit-per-sample unified planar YUV image into an\n * 8-bit-per-sample JPEG image.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * compression\n *\n * @param srcBuf pointer to a buffer containing a unified planar YUV source\n * image to be compressed.  The size of this buffer should match the value\n * returned by #tj3YUVBufSize() for the given image width, height, row\n * alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The\n * Y, U (Cb), and V (Cr) image planes should be stored sequentially in the\n * buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)\n *\n * @param width width (in pixels) of the source image.  If the width is not an\n * even multiple of the iMCU width (see #tjMCUWidth), then an intermediate\n * buffer copy will be performed.\n *\n * @param align row alignment (in bytes) of the source image (must be a power\n * of 2.)  Setting this parameter to n indicates that each row in each plane of\n * the source image is padded to the nearest multiple of n bytes\n * (1 = unpadded.)\n *\n * @param height height (in pixels) of the source image.  If the height is not\n * an even multiple of the iMCU height (see #tjMCUHeight), then an intermediate\n * buffer copy will be performed.\n *\n * @param jpegBuf address of a pointer to a byte buffer that will receive the\n * JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to\n * accommodate the size of the JPEG image.  Thus, you can choose to:\n * -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and\n * let TurboJPEG grow the buffer as needed,\n * -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,\n * or\n * -# pre-allocate the buffer to a \"worst case\" size determined by calling\n * #tj3JPEGBufSize().  This should ensure that the buffer never has to be\n * re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)\n * .\n * If you choose option 1, then `*jpegSize` should be set to the size of your\n * pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,\n * you should always check `*jpegBuf` upon return from this function, as it may\n * have changed.\n *\n * @param jpegSize pointer to a size_t variable that holds the size of the JPEG\n * buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`\n * should be set to the size of the buffer.  Upon return, `*jpegSize` will\n * contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a\n * JPEG buffer that is being reused from a previous call to one of the JPEG\n * compression functions, then `*jpegSize` is ignored.\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3CompressFromYUV8(tjhandle handle,\n                                  const unsigned char *srcBuf, int width,\n                                  int align, int height,\n                                  unsigned char **jpegBuf, size_t *jpegSize);\n\n\n/**\n * Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into separate\n * 8-bit-per-sample Y, U (Cb), and V (Cr) image planes.  This function performs\n * color conversion (which is accelerated in the libjpeg-turbo implementation)\n * but does not execute any of the other steps in the JPEG compression process.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * compression\n *\n * @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale\n * source image to be encoded.  This buffer should normally be `pitch * height`\n * bytes in size.  However, you can also use this parameter to encode from a\n * specific region of a larger buffer.\n *\n *\n * @param width width (in pixels) of the source image\n *\n * @param pitch bytes per row in the source image.  Normally this should be\n * <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.\n * (Setting this parameter to 0 is the equivalent of setting it to\n * <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this\n * parameter to specify the row alignment/padding of the source image, to skip\n * rows, or to encode from a specific region of a larger packed-pixel image.\n *\n * @param height height (in pixels) of the source image\n *\n * @param pixelFormat pixel format of the source image (see @ref TJPF\n * \"Pixel formats\".)\n *\n * @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n * (or just a Y plane, if generating a grayscale image) that will receive the\n * encoded image.  These planes can be contiguous or non-contiguous in memory.\n * Use #tj3YUVPlaneSize() to determine the appropriate size for each plane\n * based on the image width, height, strides, and level of chrominance\n * subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes\n * \"YUV Image Format Notes\" for more details.\n *\n * @param strides an array of integers, each specifying the number of bytes per\n * row in the corresponding plane of the YUV image.  Setting the stride for any\n * plane to 0 is the same as setting it to the plane width (see @ref YUVnotes\n * \"YUV Image Format Notes\".)  If `strides` is NULL, then the strides for all\n * planes will be set to their respective plane widths.  You can adjust the\n * strides in order to add an arbitrary amount of row padding to each plane or\n * to encode an RGB or grayscale image into a subregion of a larger planar YUV\n * image.\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3EncodeYUVPlanes8(tjhandle handle, const unsigned char *srcBuf,\n                                  int width, int pitch, int height,\n                                  int pixelFormat, unsigned char **dstPlanes,\n                                  int *strides);\n\n\n/**\n * Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into an\n * 8-bit-per-sample unified planar YUV image.  This function performs color\n * conversion (which is accelerated in the libjpeg-turbo implementation) but\n * does not execute any of the other steps in the JPEG compression process.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * compression\n *\n * @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale\n * source image to be encoded.  This buffer should normally be `pitch * height`\n * bytes in size.  However, you can also use this parameter to encode from a\n * specific region of a larger buffer.\n *\n * @param width width (in pixels) of the source image\n *\n * @param pitch bytes per row in the source image.  Normally this should be\n * <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.\n * (Setting this parameter to 0 is the equivalent of setting it to\n * <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this\n * parameter to specify the row alignment/padding of the source image, to skip\n * rows, or to encode from a specific region of a larger packed-pixel image.\n *\n * @param height height (in pixels) of the source image\n *\n * @param pixelFormat pixel format of the source image (see @ref TJPF\n * \"Pixel formats\".)\n *\n * @param dstBuf pointer to a buffer that will receive the unified planar YUV\n * image.  Use #tj3YUVBufSize() to determine the appropriate size for this\n * buffer based on the image width, height, row alignment, and level of\n * chrominance subsampling (see #TJPARAM_SUBSAMP.)  The Y, U (Cb), and V (Cr)\n * image planes will be stored sequentially in the buffer.  (Refer to\n * @ref YUVnotes \"YUV Image Format Notes\".)\n *\n * @param align row alignment (in bytes) of the YUV image (must be a power of\n * 2.)  Setting this parameter to n will cause each row in each plane of the\n * YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)\n * To generate images suitable for X Video, `align` should be set to 4.\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3EncodeYUV8(tjhandle handle, const unsigned char *srcBuf,\n                            int width, int pitch, int height, int pixelFormat,\n                            unsigned char *dstBuf, int align);\n\n\n/**\n * Retrieve information about a JPEG image without decompressing it, or prime\n * the decompressor with quantization and Huffman tables.  If a JPEG image is\n * passed to this function, then the @ref TJPARAM \"parameters\" that describe\n * the JPEG image will be set when the function returns.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * decompression\n *\n * @param jpegBuf pointer to a byte buffer containing a JPEG image or an\n * \"abbreviated table specification\" (AKA \"tables-only\") datastream.  Passing a\n * tables-only datastream to this function primes the decompressor with\n * quantization and Huffman tables that can be used when decompressing\n * subsequent \"abbreviated image\" datastreams.  This is useful, for instance,\n * when decompressing video streams in which all frames share the same\n * quantization and Huffman tables.\n *\n * @param jpegSize size of the JPEG image or tables-only datastream (in bytes)\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3DecompressHeader(tjhandle handle,\n                                  const unsigned char *jpegBuf,\n                                  size_t jpegSize);\n\n\n/**\n * Returns a list of fractional scaling factors that the JPEG decompressor\n * supports.\n *\n * @param numScalingFactors pointer to an integer variable that will receive\n * the number of elements in the list\n *\n * @return a pointer to a list of fractional scaling factors, or NULL if an\n * error is encountered (see #tj3GetErrorStr().)\n */\nDLLEXPORT tjscalingfactor *tj3GetScalingFactors(int *numScalingFactors);\n\n\n/**\n * Set the scaling factor for subsequent lossy decompression operations.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * decompression\n *\n * @param scalingFactor #tjscalingfactor structure that specifies a fractional\n * scaling factor that the decompressor supports (see #tj3GetScalingFactors()),\n * or <tt>#TJUNSCALED</tt> for no scaling.  Decompression scaling is a function\n * of the IDCT algorithm, so scaling factors are generally limited to multiples\n * of 1/8.  If the entire JPEG image will be decompressed, then the width and\n * height of the scaled destination image can be determined by calling\n * #TJSCALED() with the JPEG width and height (see #TJPARAM_JPEGWIDTH and\n * #TJPARAM_JPEGHEIGHT) and the specified scaling factor.  When decompressing\n * into a planar YUV image, an intermediate buffer copy will be performed if\n * the width or height of the scaled destination image is not an even multiple\n * of the iMCU size (see #tjMCUWidth and #tjMCUHeight.)  Note that\n * decompression scaling is not available (and the specified scaling factor is\n * ignored) when decompressing lossless JPEG images (see #TJPARAM_LOSSLESS),\n * since the IDCT algorithm is not used with those images.  Note also that\n * #TJPARAM_FASTDCT is ignored when decompression scaling is enabled.\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)\n */\nDLLEXPORT int tj3SetScalingFactor(tjhandle handle,\n                                  tjscalingfactor scalingFactor);\n\n\n/**\n * Set the cropping region for partially decompressing a lossy JPEG image into\n * a packed-pixel image\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * decompression\n *\n * @param croppingRegion #tjregion structure that specifies a subregion of the\n * JPEG image to decompress, or <tt>#TJUNCROPPED</tt> for no cropping.  The\n * left boundary of the cropping region must be evenly divisible by the scaled\n * iMCU width-- <tt>#TJSCALED(#tjMCUWidth[subsamp], scalingFactor)</tt>, where\n * `subsamp` is the level of chrominance subsampling in the JPEG image (see\n * #TJPARAM_SUBSAMP) and `scalingFactor` is the decompression scaling factor\n * (see #tj3SetScalingFactor().)  The cropping region should be specified\n * relative to the scaled image dimensions.  Unless `croppingRegion` is\n * <tt>#TJUNCROPPED</tt>, the JPEG header must be read (see\n * #tj3DecompressHeader()) prior to calling this function.\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)\n */\nDLLEXPORT int tj3SetCroppingRegion(tjhandle handle, tjregion croppingRegion);\n\n\n/**\n * Decompress an 8-bit-per-sample JPEG image into an 8-bit-per-sample\n * packed-pixel RGB, grayscale, or CMYK image.  The @ref TJPARAM \"parameters\"\n * that describe the JPEG image will be set when this function returns.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * decompression\n *\n * @param jpegBuf pointer to a byte buffer containing the JPEG image to\n * decompress\n *\n * @param jpegSize size of the JPEG image (in bytes)\n *\n * @param dstBuf pointer to a buffer that will receive the packed-pixel\n * decompressed image.  This buffer should normally be\n * `pitch * destinationHeight` samples in size.  However, you can also use this\n * parameter to decompress into a specific region of a larger buffer.  NOTE:\n * If the JPEG image is lossy, then `destinationHeight` is either the scaled\n * JPEG height (see #TJSCALED(), #TJPARAM_JPEGHEIGHT, and\n * #tj3SetScalingFactor()) or the height of the cropping region (see\n * #tj3SetCroppingRegion().)  If the JPEG image is lossless, then\n * `destinationHeight` is the JPEG height.\n *\n * @param pitch samples per row in the destination image.  Normally this should\n * be set to <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>, if the\n * destination image should be unpadded.  (Setting this parameter to 0 is the\n * equivalent of setting it to\n * <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>.)  However, you can\n * also use this parameter to specify the row alignment/padding of the\n * destination image, to skip rows, or to decompress into a specific region of\n * a larger buffer.  NOTE: If the JPEG image is lossy, then `destinationWidth`\n * is either the scaled JPEG width (see #TJSCALED(), #TJPARAM_JPEGWIDTH, and\n * #tj3SetScalingFactor()) or the width of the cropping region (see\n * #tj3SetCroppingRegion().)  If the JPEG image is lossless, then\n * `destinationWidth` is the JPEG width.\n *\n * @param pixelFormat pixel format of the destination image (see @ref\n * TJPF \"Pixel formats\".)\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3Decompress8(tjhandle handle, const unsigned char *jpegBuf,\n                             size_t jpegSize, unsigned char *dstBuf, int pitch,\n                             int pixelFormat);\n\n/**\n * Decompress a 12-bit-per-sample JPEG image into a 12-bit-per-sample\n * packed-pixel RGB, grayscale, or CMYK image.\n *\n * \\details \\copydetails tj3Decompress8()\n */\nDLLEXPORT int tj3Decompress12(tjhandle handle, const unsigned char *jpegBuf,\n                              size_t jpegSize, short *dstBuf, int pitch,\n                              int pixelFormat);\n\n/**\n * Decompress a 16-bit-per-sample lossless JPEG image into a 16-bit-per-sample\n * packed-pixel RGB, grayscale, or CMYK image.\n *\n * \\details \\copydetails tj3Decompress8()\n */\nDLLEXPORT int tj3Decompress16(tjhandle handle, const unsigned char *jpegBuf,\n                              size_t jpegSize, unsigned short *dstBuf,\n                              int pitch, int pixelFormat);\n\n\n/**\n * Decompress an 8-bit-per-sample JPEG image into separate 8-bit-per-sample Y,\n * U (Cb), and V (Cr) image planes.  This function performs JPEG decompression\n * but leaves out the color conversion step, so a planar YUV image is generated\n * instead of a packed-pixel image.  The @ref TJPARAM \"parameters\" that\n * describe the JPEG image will be set when this function returns.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * decompression\n *\n * @param jpegBuf pointer to a byte buffer containing the JPEG image to\n * decompress\n *\n * @param jpegSize size of the JPEG image (in bytes)\n *\n * @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n * (or just a Y plane, if decompressing a grayscale image) that will receive\n * the decompressed image.  These planes can be contiguous or non-contiguous in\n * memory.  Use #tj3YUVPlaneSize() to determine the appropriate size for each\n * plane based on the scaled JPEG width and height (see #TJSCALED(),\n * #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()),\n * strides, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer\n * to @ref YUVnotes \"YUV Image Format Notes\" for more details.\n *\n * @param strides an array of integers, each specifying the number of bytes per\n * row in the corresponding plane of the YUV image.  Setting the stride for any\n * plane to 0 is the same as setting it to the scaled plane width (see\n * @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the\n * strides for all planes will be set to their respective scaled plane widths.\n * You can adjust the strides in order to add an arbitrary amount of row\n * padding to each plane or to decompress the JPEG image into a subregion of a\n * larger planar YUV image.\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3DecompressToYUVPlanes8(tjhandle handle,\n                                        const unsigned char *jpegBuf,\n                                        size_t jpegSize,\n                                        unsigned char **dstPlanes,\n                                        int *strides);\n\n\n/**\n * Decompress an 8-bit-per-sample JPEG image into an 8-bit-per-sample unified\n * planar YUV image.  This function performs JPEG decompression but leaves out\n * the color conversion step, so a planar YUV image is generated instead of a\n * packed-pixel image.  The @ref TJPARAM \"parameters\" that describe the JPEG\n * image will be set when this function returns.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * decompression\n *\n * @param jpegBuf pointer to a byte buffer containing the JPEG image to\n * decompress\n *\n * @param jpegSize size of the JPEG image (in bytes)\n *\n * @param dstBuf pointer to a buffer that will receive the unified planar YUV\n * decompressed image.  Use #tj3YUVBufSize() to determine the appropriate size\n * for this buffer based on the scaled JPEG width and height (see #TJSCALED(),\n * #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()), row\n * alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The\n * Y, U (Cb), and V (Cr) image planes will be stored sequentially in the\n * buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)\n *\n * @param align row alignment (in bytes) of the YUV image (must be a power of\n * 2.)  Setting this parameter to n will cause each row in each plane of the\n * YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)\n * To generate images suitable for X Video, `align` should be set to 4.\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3DecompressToYUV8(tjhandle handle,\n                                  const unsigned char *jpegBuf,\n                                  size_t jpegSize,\n                                  unsigned char *dstBuf, int align);\n\n\n/**\n * Decode a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into an\n * 8-bit-per-sample packed-pixel RGB or grayscale image.  This function\n * performs color conversion (which is accelerated in the libjpeg-turbo\n * implementation) but does not execute any of the other steps in the JPEG\n * decompression process.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * decompression\n *\n * @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n * (or just a Y plane, if decoding a grayscale image) that contain a YUV image\n * to be decoded.  These planes can be contiguous or non-contiguous in memory.\n * The size of each plane should match the value returned by #tj3YUVPlaneSize()\n * for the given image width, height, strides, and level of chrominance\n * subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes\n * \"YUV Image Format Notes\" for more details.\n *\n * @param strides an array of integers, each specifying the number of bytes per\n * row in the corresponding plane of the YUV source image.  Setting the stride\n * for any plane to 0 is the same as setting it to the plane width (see\n * @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the\n * strides for all planes will be set to their respective plane widths.  You\n * can adjust the strides in order to specify an arbitrary amount of row\n * padding in each plane or to decode a subregion of a larger planar YUV image.\n *\n * @param dstBuf pointer to a buffer that will receive the packed-pixel decoded\n * image.  This buffer should normally be `pitch * height` bytes in size.\n * However, you can also use this parameter to decode into a specific region of\n * a larger buffer.\n *\n * @param width width (in pixels) of the source and destination images\n *\n * @param pitch bytes per row in the destination image.  Normally this should\n * be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination\n * image should be unpadded.  (Setting this parameter to 0 is the equivalent of\n * setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can\n * also use this parameter to specify the row alignment/padding of the\n * destination image, to skip rows, or to decode into a specific region of a\n * larger buffer.\n *\n * @param height height (in pixels) of the source and destination images\n *\n * @param pixelFormat pixel format of the destination image (see @ref TJPF\n * \"Pixel formats\".)\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3DecodeYUVPlanes8(tjhandle handle,\n                                  const unsigned char * const *srcPlanes,\n                                  const int *strides, unsigned char *dstBuf,\n                                  int width, int pitch, int height,\n                                  int pixelFormat);\n\n\n/**\n * Decode an 8-bit-per-sample unified planar YUV image into an 8-bit-per-sample\n * packed-pixel RGB or grayscale image.  This function performs color\n * conversion (which is accelerated in the libjpeg-turbo implementation) but\n * does not execute any of the other steps in the JPEG decompression process.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * decompression\n *\n * @param srcBuf pointer to a buffer containing a unified planar YUV source\n * image to be decoded.  The size of this buffer should match the value\n * returned by #tj3YUVBufSize() for the given image width, height, row\n * alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The\n * Y, U (Cb), and V (Cr) image planes should be stored sequentially in the\n * source buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)\n *\n * @param align row alignment (in bytes) of the YUV source image (must be a\n * power of 2.)  Setting this parameter to n indicates that each row in each\n * plane of the YUV source image is padded to the nearest multiple of n bytes\n * (1 = unpadded.)\n *\n * @param dstBuf pointer to a buffer that will receive the packed-pixel decoded\n * image.  This buffer should normally be `pitch * height` bytes in size.\n * However, you can also use this parameter to decode into a specific region of\n * a larger buffer.\n *\n * @param width width (in pixels) of the source and destination images\n *\n * @param pitch bytes per row in the destination image.  Normally this should\n * be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination\n * image should be unpadded.  (Setting this parameter to 0 is the equivalent of\n * setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can\n * also use this parameter to specify the row alignment/padding of the\n * destination image, to skip rows, or to decode into a specific region of a\n * larger buffer.\n *\n * @param height height (in pixels) of the source and destination images\n *\n * @param pixelFormat pixel format of the destination image (see @ref TJPF\n * \"Pixel formats\".)\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3DecodeYUV8(tjhandle handle, const unsigned char *srcBuf,\n                            int align, unsigned char *dstBuf, int width,\n                            int pitch, int height, int pixelFormat);\n\n\n/**\n * Losslessly transform a JPEG image into another JPEG image.  Lossless\n * transforms work by moving the raw DCT coefficients from one JPEG image\n * structure to another without altering the values of the coefficients.  While\n * this is typically faster than decompressing the image, transforming it, and\n * re-compressing it, lossless transforms are not free.  Each lossless\n * transform requires reading and performing entropy decoding on all of the\n * coefficients in the source image, regardless of the size of the destination\n * image.  Thus, this function provides a means of generating multiple\n * transformed images from the same source or applying multiple transformations\n * simultaneously, in order to eliminate the need to read the source\n * coefficients multiple times.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized for\n * lossless transformation\n *\n * @param jpegBuf pointer to a byte buffer containing the JPEG source image to\n * transform\n *\n * @param jpegSize size of the JPEG source image (in bytes)\n *\n * @param n the number of transformed JPEG images to generate\n *\n * @param dstBufs pointer to an array of n byte buffers.  `dstBufs[i]` will\n * receive a JPEG image that has been transformed using the parameters in\n * `transforms[i]`.  TurboJPEG has the ability to reallocate the JPEG\n * destination buffer to accommodate the size of the transformed JPEG image.\n * Thus, you can choose to:\n * -# pre-allocate the JPEG destination buffer with an arbitrary size using\n * #tj3Alloc() and let TurboJPEG grow the buffer as needed,\n * -# set `dstBufs[i]` to NULL to tell TurboJPEG to allocate the buffer for\n * you, or\n * -# pre-allocate the buffer to a \"worst case\" size determined by calling\n * #tj3JPEGBufSize() with the transformed or cropped width and height and the\n * level of subsampling used in the destination image (taking into account\n * grayscale conversion and transposition of the width and height.)  Under\n * normal circumstances, this should ensure that the buffer never has to be\n * re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)\n * Note, however, that there are some rare cases (such as transforming images\n * with a large amount of embedded Exif or ICC profile data) in which the\n * transformed JPEG image will be larger than the worst-case size, and\n * #TJPARAM_NOREALLOC cannot be used in those cases unless the embedded data is\n * discarded using #TJXOPT_COPYNONE.\n * .\n * If you choose option 1, then `dstSizes[i]` should be set to the size of your\n * pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,\n * you should always check `dstBufs[i]` upon return from this function, as it\n * may have changed.\n *\n * @param dstSizes pointer to an array of n size_t variables that will receive\n * the actual sizes (in bytes) of each transformed JPEG image.  If `dstBufs[i]`\n * points to a pre-allocated buffer, then `dstSizes[i]` should be set to the\n * size of the buffer.  Upon return, `dstSizes[i]` will contain the size of the\n * transformed JPEG image (in bytes.)\n *\n * @param transforms pointer to an array of n #tjtransform structures, each of\n * which specifies the transform parameters and/or cropping region for the\n * corresponding transformed JPEG image.\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nDLLEXPORT int tj3Transform(tjhandle handle, const unsigned char *jpegBuf,\n                           size_t jpegSize, int n, unsigned char **dstBufs,\n                           size_t *dstSizes, const tjtransform *transforms);\n\n\n/**\n * Load an 8-bit-per-sample packed-pixel image from disk into memory.\n *\n * @param handle handle to a TurboJPEG instance\n *\n * @param filename name of a file containing a packed-pixel image in Windows\n * BMP or PBMPLUS (PPM/PGM) format.  Windows BMP files require 8-bit-per-sample\n * data precision.  If the data precision of the PBMPLUS file does not match\n * the target data precision, then upconverting or downconverting will be\n * performed.\n *\n * @param width pointer to an integer variable that will receive the width (in\n * pixels) of the packed-pixel image\n *\n * @param align row alignment (in samples) of the packed-pixel buffer to be\n * returned (must be a power of 2.)  Setting this parameter to n will cause all\n * rows in the buffer to be padded to the nearest multiple of n samples\n * (1 = unpadded.)\n *\n * @param height pointer to an integer variable that will receive the height\n * (in pixels) of the packed-pixel image\n *\n * @param pixelFormat pointer to an integer variable that specifies or will\n * receive the pixel format of the packed-pixel buffer.  The behavior of this\n * function varies depending on the value of `*pixelFormat` passed to the\n * function:\n * - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will\n * use the most optimal pixel format for the file type, and `*pixelFormat` will\n * contain the ID of that pixel format upon successful return from this\n * function.\n * - @ref TJPF_GRAY : Only PGM files and 8-bit-per-pixel BMP files with a\n * grayscale colormap can be loaded.\n * - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be\n * converted using a quick & dirty algorithm that is suitable only for testing\n * purposes.  (Proper conversion between CMYK and other formats requires a\n * color management system.)\n * - Other @ref TJPF \"pixel formats\" : The packed-pixel buffer will use the\n * specified pixel format, and pixel format conversion will be performed if\n * necessary.\n *\n * @return a pointer to a newly-allocated buffer containing the packed-pixel\n * image, converted to the chosen pixel format and with the chosen row\n * alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This\n * buffer should be freed using #tj3Free().\n */\nDLLEXPORT unsigned char *tj3LoadImage8(tjhandle handle, const char *filename,\n                                       int *width, int align, int *height,\n                                       int *pixelFormat);\n\n/**\n * Load a 12-bit-per-sample packed-pixel image from disk into memory.\n *\n * \\details \\copydetails tj3LoadImage8()\n */\nDLLEXPORT short *tj3LoadImage12(tjhandle handle, const char *filename,\n                                int *width, int align, int *height,\n                                int *pixelFormat);\n\n/**\n * Load a 16-bit-per-sample packed-pixel image from disk into memory.\n *\n * \\details \\copydetails tj3LoadImage8()\n */\nDLLEXPORT unsigned short *tj3LoadImage16(tjhandle handle, const char *filename,\n                                         int *width, int align, int *height,\n                                         int *pixelFormat);\n\n\n/**\n * Save an 8-bit-per-sample packed-pixel image from memory to disk.\n *\n * @param handle handle to a TurboJPEG instance\n *\n * @param filename name of a file to which to save the packed-pixel image.  The\n * image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format, depending\n * on the file extension.  Windows BMP files require 8-bit-per-sample data\n * precision.\n *\n * @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,\n * or CMYK image to be saved\n *\n * @param width width (in pixels) of the packed-pixel image\n *\n * @param pitch samples per row in the packed-pixel image.  Setting this\n * parameter to 0 is the equivalent of setting it to\n * <tt>width * #tjPixelSize[pixelFormat]</tt>.\n *\n * @param height height (in pixels) of the packed-pixel image\n *\n * @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF\n * \"Pixel formats\".)  If this parameter is set to @ref TJPF_GRAY, then the\n * image will be stored in PGM or 8-bit-per-pixel (indexed color) BMP format.\n * Otherwise, the image will be stored in PPM or 24-bit-per-pixel BMP format.\n * If this parameter is set to @ref TJPF_CMYK, then the CMYK pixels will be\n * converted to RGB using a quick & dirty algorithm that is suitable only for\n * testing purposes.  (Proper conversion between CMYK and other formats\n * requires a color management system.)\n *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)\n */\nDLLEXPORT int tj3SaveImage8(tjhandle handle, const char *filename,\n                            const unsigned char *buffer, int width, int pitch,\n                            int height, int pixelFormat);\n\n/**\n * Save a 12-bit-per-sample packed-pixel image from memory to disk.\n *\n * \\details \\copydetails tj3SaveImage8()\n */\nDLLEXPORT int tj3SaveImage12(tjhandle handle, const char *filename,\n                             const short *buffer, int width, int pitch,\n                             int height, int pixelFormat);\n\n/**\n * Save a 16-bit-per-sample packed-pixel image from memory to disk.\n *\n * \\details \\copydetails tj3SaveImage8()\n */\nDLLEXPORT int tj3SaveImage16(tjhandle handle, const char *filename,\n                             const unsigned short *buffer, int width,\n                             int pitch, int height, int pixelFormat);\n\n\n/* Backward compatibility functions and macros (nothing to see here) */\n\n/* TurboJPEG 1.0+ */\n\n#define NUMSUBOPT  TJ_NUMSAMP\n#define TJ_444  TJSAMP_444\n#define TJ_422  TJSAMP_422\n#define TJ_420  TJSAMP_420\n#define TJ_411  TJSAMP_420\n#define TJ_GRAYSCALE  TJSAMP_GRAY\n\n#define TJ_BGR  1\n#define TJ_BOTTOMUP  TJFLAG_BOTTOMUP\n#define TJ_FORCEMMX  TJFLAG_FORCEMMX\n#define TJ_FORCESSE  TJFLAG_FORCESSE\n#define TJ_FORCESSE2  TJFLAG_FORCESSE2\n#define TJ_ALPHAFIRST  64\n#define TJ_FORCESSE3  TJFLAG_FORCESSE3\n#define TJ_FASTUPSAMPLE  TJFLAG_FASTUPSAMPLE\n\n#define TJPAD(width)  (((width) + 3) & (~3))\n\nDLLEXPORT unsigned long TJBUFSIZE(int width, int height);\n\nDLLEXPORT int tjCompress(tjhandle handle, unsigned char *srcBuf, int width,\n                         int pitch, int height, int pixelSize,\n                         unsigned char *dstBuf, unsigned long *compressedSize,\n                         int jpegSubsamp, int jpegQual, int flags);\n\nDLLEXPORT int tjDecompress(tjhandle handle, unsigned char *jpegBuf,\n                           unsigned long jpegSize, unsigned char *dstBuf,\n                           int width, int pitch, int height, int pixelSize,\n                           int flags);\n\nDLLEXPORT int tjDecompressHeader(tjhandle handle, unsigned char *jpegBuf,\n                                 unsigned long jpegSize, int *width,\n                                 int *height);\n\nDLLEXPORT int tjDestroy(tjhandle handle);\n\nDLLEXPORT char *tjGetErrorStr(void);\n\nDLLEXPORT tjhandle tjInitCompress(void);\n\nDLLEXPORT tjhandle tjInitDecompress(void);\n\n/* TurboJPEG 1.1+ */\n\n#define TJ_YUV  512\n\nDLLEXPORT unsigned long TJBUFSIZEYUV(int width, int height, int jpegSubsamp);\n\nDLLEXPORT int tjDecompressHeader2(tjhandle handle, unsigned char *jpegBuf,\n                                  unsigned long jpegSize, int *width,\n                                  int *height, int *jpegSubsamp);\n\nDLLEXPORT int tjDecompressToYUV(tjhandle handle, unsigned char *jpegBuf,\n                                unsigned long jpegSize, unsigned char *dstBuf,\n                                int flags);\n\nDLLEXPORT int tjEncodeYUV(tjhandle handle, unsigned char *srcBuf, int width,\n                          int pitch, int height, int pixelSize,\n                          unsigned char *dstBuf, int subsamp, int flags);\n\n/* TurboJPEG 1.2+ */\n\n#define TJFLAG_BOTTOMUP  2\n#define TJFLAG_FORCEMMX  8\n#define TJFLAG_FORCESSE  16\n#define TJFLAG_FORCESSE2  32\n#define TJFLAG_FORCESSE3  128\n#define TJFLAG_FASTUPSAMPLE  256\n#define TJFLAG_NOREALLOC  1024\n\nDLLEXPORT unsigned char *tjAlloc(int bytes);\n\nDLLEXPORT unsigned long tjBufSize(int width, int height, int jpegSubsamp);\n\nDLLEXPORT unsigned long tjBufSizeYUV(int width, int height, int subsamp);\n\nDLLEXPORT int tjCompress2(tjhandle handle, const unsigned char *srcBuf,\n                          int width, int pitch, int height, int pixelFormat,\n                          unsigned char **jpegBuf, unsigned long *jpegSize,\n                          int jpegSubsamp, int jpegQual, int flags);\n\nDLLEXPORT int tjDecompress2(tjhandle handle, const unsigned char *jpegBuf,\n                            unsigned long jpegSize, unsigned char *dstBuf,\n                            int width, int pitch, int height, int pixelFormat,\n                            int flags);\n\nDLLEXPORT int tjEncodeYUV2(tjhandle handle, unsigned char *srcBuf, int width,\n                           int pitch, int height, int pixelFormat,\n                           unsigned char *dstBuf, int subsamp, int flags);\n\nDLLEXPORT void tjFree(unsigned char *buffer);\n\nDLLEXPORT tjscalingfactor *tjGetScalingFactors(int *numscalingfactors);\n\nDLLEXPORT tjhandle tjInitTransform(void);\n\nDLLEXPORT int tjTransform(tjhandle handle, const unsigned char *jpegBuf,\n                            unsigned long jpegSize, int n,\n                            unsigned char **dstBufs, unsigned long *dstSizes,\n                            tjtransform *transforms, int flags);\n\n/* TurboJPEG 1.2.1+ */\n\n#define TJFLAG_FASTDCT  2048\n#define TJFLAG_ACCURATEDCT  4096\n\n/* TurboJPEG 1.4+ */\n\nDLLEXPORT unsigned long tjBufSizeYUV2(int width, int align, int height,\n                                      int subsamp);\n\nDLLEXPORT int tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,\n                                int width, int align, int height, int subsamp,\n                                unsigned char **jpegBuf,\n                                unsigned long *jpegSize, int jpegQual,\n                                int flags);\n\nDLLEXPORT int tjCompressFromYUVPlanes(tjhandle handle,\n                                      const unsigned char **srcPlanes,\n                                      int width, const int *strides,\n                                      int height, int subsamp,\n                                      unsigned char **jpegBuf,\n                                      unsigned long *jpegSize, int jpegQual,\n                                      int flags);\n\nDLLEXPORT int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,\n                          int align, int subsamp, unsigned char *dstBuf,\n                          int width, int pitch, int height, int pixelFormat,\n                          int flags);\n\nDLLEXPORT int tjDecodeYUVPlanes(tjhandle handle,\n                                const unsigned char **srcPlanes,\n                                const int *strides, int subsamp,\n                                unsigned char *dstBuf, int width, int pitch,\n                                int height, int pixelFormat, int flags);\n\nDLLEXPORT int tjDecompressHeader3(tjhandle handle,\n                                  const unsigned char *jpegBuf,\n                                  unsigned long jpegSize, int *width,\n                                  int *height, int *jpegSubsamp,\n                                  int *jpegColorspace);\n\nDLLEXPORT int tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,\n                                 unsigned long jpegSize, unsigned char *dstBuf,\n                                 int width, int align, int height, int flags);\n\nDLLEXPORT int tjDecompressToYUVPlanes(tjhandle handle,\n                                      const unsigned char *jpegBuf,\n                                      unsigned long jpegSize,\n                                      unsigned char **dstPlanes, int width,\n                                      int *strides, int height, int flags);\n\nDLLEXPORT int tjEncodeYUV3(tjhandle handle, const unsigned char *srcBuf,\n                           int width, int pitch, int height, int pixelFormat,\n                           unsigned char *dstBuf, int align, int subsamp,\n                           int flags);\n\nDLLEXPORT int tjEncodeYUVPlanes(tjhandle handle, const unsigned char *srcBuf,\n                                int width, int pitch, int height,\n                                int pixelFormat, unsigned char **dstPlanes,\n                                int *strides, int subsamp, int flags);\n\nDLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp);\n\nDLLEXPORT unsigned long tjPlaneSizeYUV(int componentID, int width, int stride,\n                                       int height, int subsamp);\n\nDLLEXPORT int tjPlaneWidth(int componentID, int width, int subsamp);\n\n/* TurboJPEG 2.0+ */\n\n#define TJFLAG_STOPONWARNING  8192\n#define TJFLAG_PROGRESSIVE  16384\n\nDLLEXPORT int tjGetErrorCode(tjhandle handle);\n\nDLLEXPORT char *tjGetErrorStr2(tjhandle handle);\n\nDLLEXPORT unsigned char *tjLoadImage(const char *filename, int *width,\n                                     int align, int *height, int *pixelFormat,\n                                     int flags);\n\nDLLEXPORT int tjSaveImage(const char *filename, unsigned char *buffer,\n                          int width, int pitch, int height, int pixelFormat,\n                          int flags);\n\n/* TurboJPEG 2.1+ */\n\n#define TJFLAG_LIMITSCANS  32768\n\n/**\n * @}\n */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "usage.txt",
          "type": "blob",
          "size": 45.8916015625,
          "content": "This file was part of the Independent JPEG Group's software:\nCopyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.\nlibjpeg-turbo Modifications:\nCopyright (C) 2010, 2012, 2014-2017, 2020-2024, D. R. Commander.\nFor conditions of distribution and use, see the accompanying README.ijg file.\n\nUSAGE instructions for the Independent JPEG Group's JPEG software\n=================================================================\n\nThis file describes usage of the JPEG conversion programs cjpeg and djpeg,\nas well as the utility programs jpegtran, rdjpgcom and wrjpgcom.  (See\nthe other documentation files if you wish to use the JPEG library within\nyour own programs.)\n\nIf you are on a Unix machine you may prefer to read the Unix-style manual\npages in files cjpeg.1, djpeg.1, jpegtran.1, rdjpgcom.1, wrjpgcom.1.\n\n\nINTRODUCTION\n\nThese programs implement JPEG image encoding, decoding, and transcoding.\nJPEG (pronounced \"jay-peg\") is a standardized compression method for\nfull-color and grayscale images.\n\n\nGENERAL USAGE\n\nWe provide two programs, cjpeg to compress an image file into JPEG format,\nand djpeg to decompress a JPEG file back into a conventional image format.\n\nOn most systems, you say:\n        cjpeg [switches] [imagefile] >jpegfile\nor\n        djpeg [switches] [jpegfile]  >imagefile\nThe programs read the specified input file, or standard input if none is\nnamed.  They always write to standard output (with trace/error messages to\nstandard error).  These conventions are handy for piping images between\nprograms.\n\nIf you defined TWO_FILE_COMMANDLINE when compiling the programs, you can\ninstead say:\n        cjpeg [switches] imagefile jpegfile\nor\n        djpeg [switches] jpegfile  imagefile\ni.e., both the input and output files are named on the command line.  This\nstyle is a little more foolproof, and it loses no functionality if you don't\nhave pipes.\n\nYou can also say:\n        cjpeg [switches] -outfile jpegfile  imagefile\nor\n        djpeg [switches] -outfile imagefile jpegfile\nThis syntax works on all systems, so it is useful for scripts.\n\nThe currently supported image file formats are: PPM (PBMPLUS color format),\nPGM (PBMPLUS grayscale format), BMP, GIF [legacy feature], and Targa [legacy\nfeature].  cjpeg recognizes the input image format automatically, with the\nexception of some Targa files.  You have to tell djpeg which format to\ngenerate.\n\nJPEG files are in the defacto standard JFIF file format.  There are other,\nless widely used JPEG-based file formats, but we don't support them.\n\nAll switch names may be abbreviated; for example, -grayscale may be written\n-gray or -gr.  Most of the \"basic\" switches can be abbreviated to as little as\none letter.  Upper and lower case are equivalent (-BMP is the same as -bmp).\nBritish spellings are also accepted (e.g., -greyscale), though for brevity\nthese are not mentioned below.\n\n\nCJPEG DETAILS\n\nThe basic command line switches for cjpeg are:\n\n        -quality N[,...]  Scale quantization tables to adjust image quality.\n                          Quality is 0 (worst) to 100 (best); default is 75.\n                          (See below for more info.)\n\n        -grayscale      Create monochrome JPEG file from color input.  By\n                        specifying -grayscale, you'll get a smaller JPEG file\n                        that takes less time to process.\n\n        -rgb            Create RGB JPEG file.  Using this switch suppresses the\n                        conversion from RGB colorspace input to the default\n                        YCbCr JPEG colorspace.\n\n        -optimize       Perform optimization of entropy encoding parameters.\n                        Without this, default encoding parameters are used.\n                        -optimize usually makes the JPEG file a little smaller,\n                        but cjpeg runs somewhat slower and needs much more\n                        memory.  Image quality and speed of decompression are\n                        unaffected by -optimize.\n\n        -progressive    Create progressive JPEG file (see below).  Implies\n                        -optimize unless -arithmetic is also specified.\n\n        -targa          Input file is Targa format [legacy feature].  Targa\n                        files that contain an \"identification\" field will not\n                        be automatically recognized by cjpeg.  For such files,\n                        you must specify -targa to make cjpeg treat the input\n                        as Targa format.  For most Targa files, you won't need\n                        this switch.\n\nThe -quality switch lets you trade off compressed file size against quality of\nthe reconstructed image: the higher the quality setting, the larger the JPEG\nfile, and the closer the output image will be to the original input.  Normally\nyou want to use the lowest quality setting (smallest file) that decompresses\ninto something visually indistinguishable from the original image.  For this\npurpose the quality setting should generally be between 50 and 95 (the default\nis 75) for photographic images.  If you see defects at -quality 75, then go up\n5 or 10 counts at a time until you are happy with the output image.  (The\noptimal setting will vary from one image to another.)\n\n-quality 100 will generate a quantization table of all 1's, minimizing loss\nin the quantization step (but there is still information loss in subsampling,\nas well as roundoff error.)  For most images, specifying a quality value above\nabout 95 will increase the size of the compressed file dramatically, and while\nthe quality gain from these higher quality values is measurable (using metrics\nsuch as PSNR or SSIM), it is rarely perceivable by human vision.\n\nIn the other direction, quality values below 50 will produce very small files\nof low image quality.  Settings around 5 to 10 might be useful in preparing an\nindex of a large image library, for example.  Try -quality 2 (or so) for some\namusing Cubist effects.  (Note: quality values below about 25 generate 2-byte\nquantization tables, which are considered optional in the JPEG standard.\ncjpeg emits a warning message when you give such a quality value, because some\nother JPEG programs may be unable to decode the resulting file.  Use -baseline\nif you need to ensure compatibility at low quality values.)\n\nThe -quality option has been extended in this version of cjpeg to support\nseparate quality settings for luminance and chrominance (or, in general,\nseparate settings for every quantization table slot.)  The principle is the\nsame as chrominance subsampling:  since the human eye is more sensitive to\nspatial changes in brightness than spatial changes in color, the chrominance\ncomponents can be quantized more than the luminance components without\nincurring any visible image quality loss.  However, unlike subsampling, this\nfeature reduces data in the frequency domain instead of the spatial domain,\nwhich allows for more fine-grained control.  This option is useful in\nquality-sensitive applications, for which the artifacts generated by\nsubsampling may be unacceptable.\n\nThe -quality option accepts a comma-separated list of parameters, which\nrespectively refer to the quality levels that should be assigned to the\nquantization table slots.  If there are more q-table slots than parameters,\nthen the last parameter is replicated.  Thus, if only one quality parameter is\ngiven, this is used for both luminance and chrominance (slots 0 and 1,\nrespectively), preserving the legacy behavior of cjpeg v6b and prior.  More (or\ncustomized) quantization tables can be set with the -qtables option and\nassigned to components with the -qslots option (see the \"wizard\" switches\nbelow.)\n\nJPEG files generated with separate luminance and chrominance quality are fully\ncompliant with standard JPEG decoders.\n\nCAUTION: For this setting to be useful, be sure to pass an argument of\n-sample 1x1 to cjpeg to disable chrominance subsampling.  Otherwise, the\ndefault subsampling level (2x2, AKA \"4:2:0\") will be used.\n\nThe -progressive switch creates a \"progressive JPEG\" file.  In this type of\nJPEG file, the data is stored in multiple scans of increasing quality.  If the\nfile is being transmitted over a slow communications link, the decoder can use\nthe first scan to display a low-quality image very quickly, and can then\nimprove the display with each subsequent scan.  The final image is exactly\nequivalent to a standard JPEG file of the same quality setting, and the total\nfile size is about the same --- often a little smaller.\n\nSwitches for advanced users:\n\n        -precision N   Create JPEG file with N-bit data precision.\n                       N is 8, 12, or 16; default is 8.  If N is 16, then\n                       -lossless must also be specified.  Note that only the\n                       PBMPLUS input file format supports data precisions other\n                       than 8.  (For historical reasons, cjpeg allows GIF input\n                       files to be converted into 12-bit-per-sample JPEG files,\n                       but this is not a useful conversion.)  Note also that\n                       PBMPLUS input files are silently scaled to the target\n                       data precision, even if it is lower than the precision\n                       of the input file.  Passing an argument of -verbose to\n                       cjpeg will cause it to print information about the\n                       precision of the input file.  CAUTION: 12-bit and 16-bit\n                       data precision is not yet widely implemented, so many\n                       decoders will be unable to handle a 12-bit-per-sample or\n                       16-bit-per-sample JPEG file at all.\n\n                       \"-precision 12\" implies -optimize unless -arithmetic is\n                       also specified.\n\n        -lossless psv[,Pt] Create a lossless JPEG file using the specified\n                        predictor selection value (1 - 7) and optional point\n                        transform (0 - {precision}-1, where {precision} is the\n                        JPEG data precision in bits).  A point transform value\n                        of 0 (the default) is necessary in order to create a\n                        fully lossless JPEG file.  (A non-zero point transform\n                        value right-shifts the input samples by the specified\n                        number of bits, which is effectively a form of lossy\n                        color quantization.)  CAUTION: lossless JPEG is not yet\n                        widely implemented, so many decoders will be unable to\n                        handle a lossless JPEG file at all.  In most cases,\n                        compressing and decompressing a lossless JPEG file is\n                        considerably slower than compressing and decompressing\n                        a lossy JPEG file, and lossless JPEG files are much\n                        larger than lossy JPEG files.  Also note that the\n                        following features will be unavailable when compressing\n                        or decompressing a lossless JPEG file:\n                          * Quality/quantization table selection\n                          * Color space conversion (the JPEG image will use the\n                            same color space as the input image)\n                          * Color quantization\n                          * DCT/IDCT algorithm selection\n                          * Smoothing\n                          * Downsampling/upsampling\n                          * IDCT scaling\n                          * Partial image decompression\n                          * Transformations using jpegtran\n                        Any switches used to enable or configure those features\n                        will be ignored.\n\n        -arithmetic     Use arithmetic coding.  CAUTION: arithmetic-coded JPEG\n                        is not yet widely implemented, so many decoders will\n                        be unable to handle an arithmetic-coded JPEG file at\n                        all.\n\n        -dct int        Use accurate integer DCT method (default).\n        -dct fast       Use less accurate integer DCT method [legacy feature].\n                        When the Independent JPEG Group's software was first\n                        released in 1991, the compression time for a\n                        1-megapixel JPEG image on a mainstream PC was measured\n                        in minutes.  Thus, the fast integer DCT algorithm\n                        provided noticeable performance benefits.  On modern\n                        CPUs running libjpeg-turbo, however, the compression\n                        time for a 1-megapixel JPEG image is measured in\n                        milliseconds, and thus the performance benefits of the\n                        fast algorithm are much less noticeable.  On modern\n                        x86/x86-64 CPUs that support AVX2 instructions, the\n                        fast and int methods have similar performance.  On\n                        other types of CPUs, the fast method is generally about\n                        5-15% faster than the int method.\n\n                        For quality levels of 90 and below, there should be\n                        little or no perceptible quality difference between the\n                        two algorithms.  For quality levels above 90, however,\n                        the difference between the fast and int methods becomes\n                        more pronounced.  With quality=97, for instance, the\n                        fast method incurs generally about a 1-3 dB loss in\n                        PSNR relative to the int method, but this can be larger\n                        for some images.  Do not use the fast method with\n                        quality levels above 97.  The algorithm often\n                        degenerates at quality=98 and above and can actually\n                        produce a more lossy image than if lower quality levels\n                        had been used.  Also, in libjpeg-turbo, the fast method\n                        is not fully accelerated for quality levels above 97,\n                        so it will be slower than the int method.\n        -dct float      Use floating-point DCT method [legacy feature].\n                        The float method does not produce significantly more\n                        accurate results than the int method, and it is much\n                        slower.  The float method may also give different\n                        results on different machines due to varying roundoff\n                        behavior, whereas the integer methods should give the\n                        same results on all machines.\n\n        -icc FILE       Embed ICC color management profile contained in the\n                        specified file.\n\n        -restart N      Emit a JPEG restart marker every N MCU rows, or every N\n                        MCUs if \"B\" is attached to the number.\n\n                        In typical JPEG images, an MCU (Minimum Coded Unit) is\n                        the minimum set of interleaved \"data units\" (8x8 DCT\n                        blocks if the image is lossy or samples if the image is\n                        lossless) necessary to represent at least one data unit\n                        per component.  (For example, an MCU in an interleaved\n                        lossy JPEG image that uses 4:2:2 subsampling consists\n                        of two luminance blocks followed by one block for each\n                        chrominance component.)  In single-component or\n                        non-interleaved JPEG images, an MCU is the same as a\n                        data unit.  An MCU row is a row of MCUs spanning the\n                        entire width of the image.\n\n                        -restart 0 (the default) means no restart markers.\n\n        -smooth N       Smooth the input image to eliminate dithering noise.\n                        N, ranging from 1 to 100, indicates the strength of\n                        smoothing.  0 (the default) means no smoothing.\n\n        -maxmemory N    Set limit for amount of memory to use in processing\n                        large images.  Value is in thousands of bytes, or\n                        millions of bytes if \"M\" is attached to the number.\n                        For example, -max 4m selects 4000000 bytes.  If more\n                        space is needed, an error will occur.\n\n        -memdst         Compress to memory instead of a file.  This feature was\n                        implemented mainly as a way of testing the in-memory\n                        destination manager (jpeg_mem_dest()), but it is also\n                        useful for benchmarking, since it reduces the I/O\n                        overhead.\n\n        -report         Report compression progress.\n\n        -strict         Treat all warnings as fatal.  Enabling this option will\n                        cause the compressor to abort if an LZW-compressed GIF\n                        input image contains incomplete or corrupt image data.\n\n        -verbose        Enable debug printout.  More -v's give more output.\n        or -debug       Also, version information is printed at startup.\n\n        -version        Print version information and exit.\n\nThe -restart option inserts extra markers that allow a JPEG decoder to\nresynchronize after a transmission error.  Without restart markers, any damage\nto a compressed file will usually ruin the image from the point of the error\nto the end of the image; with restart markers, the damage is usually confined\nto the portion of the image up to the next restart marker.  Of course, the\nrestart markers occupy extra space.  We recommend -restart 1 for images that\nwill be transmitted across unreliable networks such as Usenet.\n\nThe -smooth option filters the input to eliminate fine-scale noise.  This is\noften useful when converting dithered images to JPEG: a moderate smoothing\nfactor of 10 to 50 gets rid of dithering patterns in the input file, resulting\nin a smaller JPEG file and a better-looking image.  Too large a smoothing\nfactor will visibly blur the image, however.\n\nSwitches for wizards:\n\n        -baseline       Force baseline-compatible quantization tables to be\n                        generated.  This clamps quantization values to 8 bits\n                        even at low quality settings.  (This switch is poorly\n                        named, since it does not ensure that the output is\n                        actually baseline JPEG.  For example, you can use\n                        -baseline and -progressive together.)\n\n        -qtables file   Use the quantization tables given in the specified\n                        text file.\n\n        -qslots N[,...] Select which quantization table to use for each color\n                        component.\n\n        -sample HxV[,...]  Set JPEG sampling factors for each color component.\n\n        -scans file     Use the scan script given in the specified text file.\n\nThe \"wizard\" switches are intended for experimentation with JPEG.  If you\ndon't know what you are doing, DON'T USE THEM.  These switches are documented\nfurther in the file wizard.txt.\n\n\nDJPEG DETAILS\n\nThe basic command line switches for djpeg are:\n\n        -colors N       Reduce image to at most N colors [legacy feature].\n        or -quantize N  This reduces the number of colors used in the output\n                        image so that it can be stored in a colormapped file\n                        format.  This feature cannot be used when decompressing\n                        lossless JPEG images.  (-colors is the recommended\n                        name.  -quantize is provided only for backward\n                        compatibility.)\n\n        -fast           Select recommended processing options for low-quality\n                        output [legacy feature].  (The default options are\n                        chosen for highest-quality output.)  Currently, this is\n                        equivalent to \"-dct fast -nosmooth -onepass -dither\n                        ordered\".  On modern CPUs, these settings have little\n                        or no performance benefit and are retained solely for\n                        backward compatibility.\n\n        -grayscale      Force grayscale output even if JPEG file is full-color.\n                        This feature cannot be used when decompressing\n                        full-color lossless JPEG images.\n\n        -rgb            Force RGB output even if JPEG file is grayscale.  This\n                        feature cannot be used when decompressing grayscale\n                        lossless JPEG images.\n\n        -scale M/N      Scale the output image by a factor M/N.  Currently the\n                        scale factor must be M/8, where M is an integer between\n                        1 and 16 inclusive, or any reduced fraction thereof\n                        (such as 1/2, 3/4, etc.)  Scaling is handy if the image\n                        is larger than your screen.  This feature cannot be\n                        used when decompressing lossless JPEG images.\n\n        -bmp            Select BMP output format (Windows flavor).  8-bit\n                        colormapped format is emitted if -colors or -grayscale\n                        is specified, or if the JPEG file is grayscale;\n                        otherwise, 24-bit full-color format is emitted.  This\n                        format can only be used when decompressing\n                        8-bit-per-sample JPEG images.\n\n        -gif            Select GIF output format (LZW-compressed) [legacy\n                        feature].  Since GIF does not support more than 256\n                        colors, -colors 256 is assumed (unless you specify a\n                        smaller number of colors).  If you specify -fast, the\n                        default number of colors is 216.  This format can only\n                        be used when decompressing 8-bit-per-sample or\n                        12-bit-per-sample lossy JPEG images.\n\n        -gif0           Select GIF output format (uncompressed) [legacy\n                        feature].  Since GIF does not support more than 256\n                        colors, -colors 256 is assumed (unless you specify a\n                        smaller number of colors).  If you specify -fast, the\n                        default number of colors is 216.  This format can only\n                        be used when decompressing 8-bit-per-sample or\n                        12-bit-per-sample lossy JPEG images.\n\n        -os2            Select BMP output format (OS/2 1.x flavor) [legacy\n                        feature].  8-bit colormapped format is emitted if\n                        -colors or -grayscale is specified, or if the JPEG file\n                        is grayscale; otherwise, 24-bit full-color format is\n                        emitted.  This format can only be used when\n                        decompressing 8-bit-per-sample JPEG images.\n\n        -pnm            Select PBMPLUS (PPM/PGM) output format (this is the\n                        default format).  PGM is emitted if the JPEG file is\n                        grayscale or if -grayscale is specified; otherwise PPM\n                        is emitted.\n\n        -targa          Select Targa output format [legacy feature].  Grayscale\n                        format is emitted if the JPEG file is grayscale or if\n                        -grayscale is specified; otherwise, colormapped format\n                        is emitted if -colors is specified; otherwise, 24-bit\n                        full-color format is emitted.  This format can only be\n                        used when decompressing 8-bit-per-sample JPEG images.\n\nSwitches for advanced users:\n\n        -dct int        Use accurate integer DCT method (default).\n        -dct fast       Use less accurate integer DCT method [legacy feature].\n                        When the Independent JPEG Group's software was first\n                        released in 1991, the decompression time for a\n                        1-megapixel JPEG image on a mainstream PC was measured\n                        in minutes.  Thus, the fast integer DCT algorithm\n                        provided noticeable performance benefits.  On modern\n                        CPUs running libjpeg-turbo, however, the decompression\n                        time for a 1-megapixel JPEG image is measured in\n                        milliseconds, and thus the performance benefits of the\n                        fast algorithm are much less noticeable.  On modern\n                        x86/x86-64 CPUs that support AVX2 instructions, the\n                        fast and int methods have similar performance.  On\n                        other types of CPUs, the fast method is generally about\n                        5-15% faster than the int method.\n\n                        If the JPEG image was compressed using a quality level\n                        of 85 or below, then there should be little or no\n                        perceptible quality difference between the two\n                        algorithms.  When decompressing images that were\n                        compressed using quality levels above 85, however, the\n                        difference between the fast and int methods becomes\n                        more pronounced.  With images compressed using\n                        quality=97, for instance, the fast method incurs\n                        generally about a 4-6 dB loss in PSNR relative to the\n                        int method, but this can be larger for some images.  If\n                        you can avoid it, do not use the fast method when\n                        decompressing images that were compressed using quality\n                        levels above 97.  The algorithm often degenerates for\n                        such images and can actually produce a more lossy\n                        output image than if the JPEG image had been compressed\n                        using lower quality levels.\n        -dct float      Use floating-point DCT method [legacy feature].\n                        The float method does not produce significantly more\n                        accurate results than the int method, and it is much\n                        slower.  The float method may also give different\n                        results on different machines due to varying roundoff\n                        behavior, whereas the integer methods should give the\n                        same results on all machines.\n\n        -dither fs      Use Floyd-Steinberg dithering when quantizing colors\n                        [legacy feature].\n        -dither ordered Use ordered dithering when quantizing colors [legacy\n                        feature].\n        -dither none    Do not use dithering when quantizing colors [legacy\n                        feature].  By default, Floyd-Steinberg dithering is\n                        applied when quantizing colors.  This is slower but\n                        usually produces the best results.  Ordered dithering\n                        is a compromise between speed and quality.  No\n                        dithering is faster but usually looks awful.  Note that\n                        these switches have no effect unless color quantization\n                        is being done.  Ordered dithering is only available in\n                        -onepass mode.\n\n        -icc FILE       Extract ICC color management profile to the specified\n                        file.\n\n        -map FILE       Quantize to the colors used in the specified image file\n                        [legacy feature].  This is useful for producing\n                        multiple files with identical color maps, or for\n                        forcing a predefined set of colors to be used.  The\n                        FILE must be a GIF or PPM file.  This option overrides\n                        -colors and -onepass.\n\n        -nosmooth       Use a faster, lower-quality upsampling routine.\n\n        -onepass        Use one-pass instead of two-pass color quantization\n                        [legacy feature].  The one-pass method needs less\n                        memory, but it produces a lower-quality image.\n                        -onepass is ignored unless you also specify -colors N.\n                        Also, the one-pass method is always used for grayscale\n                        output.  (The two-pass method has no improvement in\n                        that case.)\n\n        -maxmemory N    Set limit for amount of memory to use in processing\n                        large images.  Value is in thousands of bytes, or\n                        millions of bytes if \"M\" is attached to the number.\n                        For example, -max 4m selects 4000000 bytes.  If more\n                        space is needed, an error will occur.\n\n        -maxscans N     Abort if the JPEG image contains more than N scans.\n                        This feature demonstrates a method by which\n                        applications can guard against denial-of-service\n                        attacks instigated by specially-crafted malformed JPEG\n                        images containing numerous scans with missing image\n                        data or image data consisting only of \"EOB runs\" (a\n                        feature of progressive JPEG images that allows\n                        potentially hundreds of thousands of adjoining\n                        zero-value pixels to be represented using only a few\n                        bytes.)  Attempting to decompress such malformed JPEG\n                        images can cause excessive CPU activity, since the\n                        decompressor must fully process each scan (even if the\n                        scan is corrupt) before it can proceed to the next\n                        scan.\n\n        -memsrc         Load input file into memory before decompressing.  This\n                        feature was implemented mainly as a way of testing the\n                        in-memory source manager (jpeg_mem_src().)\n\n        -report         Report decompression progress.\n\n        -skip Y0,Y1     Decompress all rows of the JPEG image except those\n                        between Y0 and Y1 (inclusive.)  Note that if\n                        decompression scaling is being used, then Y0 and Y1 are\n                        relative to the scaled image dimensions.\n\n        -crop WxH+X+Y   Decompress only a rectangular subregion of the image,\n                        starting at point X,Y with width W and height H.  If\n                        necessary, X will be shifted left to the nearest iMCU\n                        boundary, and the width will be increased accordingly.\n                        Note that if decompression scaling is being used, then\n                        X, Y, W, and H are relative to the scaled image\n                        dimensions.  Currently this option only works with the\n                        PBMPLUS (PPM/PGM), GIF, and Targa output formats.\n\n        -strict         Treat all warnings as fatal.  This feature also\n                        demonstrates a method by which applications can guard\n                        against attacks instigated by specially-crafted\n                        malformed JPEG images.  Enabling this option will cause\n                        the decompressor to abort if the JPEG image contains\n                        incomplete or corrupt image data.\n\n        -verbose        Enable debug printout.  More -v's give more output.\n        or  -debug      Also, version information is printed at startup.\n\n        -version        Print version information and exit.\n\n\nHINTS FOR CJPEG\n\nColor GIF files are not the ideal input for JPEG; JPEG is really intended for\ncompressing full-color (24-bit through 48-bit) images.  In particular, don't\ntry to convert cartoons, line drawings, and other images that have only a few\ndistinct colors.  GIF works great on these; JPEG does not.  If you want to\nconvert a GIF to JPEG, you should experiment with cjpeg's -quality and -smooth\noptions to get a satisfactory conversion.  -smooth 10 or so is often helpful.\n\nAvoid running an image through a series of JPEG compression/decompression\ncycles.  Image quality loss will accumulate; after ten or so cycles the image\nmay be noticeably worse than it was after one cycle.  It's best to use a\nlossless format while manipulating an image, then convert to JPEG format when\nyou are ready to file the image away.\n\nThe -optimize option to cjpeg is worth using when you are making a \"final\"\nversion for posting or archiving.  It's also a win when you are using low\nquality settings to make very small JPEG files; the percentage improvement\nis often a lot more than it is on larger files.  (At present, -optimize\nmode is always selected when generating progressive JPEG files.)\n\n\nHINTS FOR BOTH PROGRAMS\n\nIf the memory needed by cjpeg or djpeg exceeds the limit specified by\n-maxmemory, an error will occur.  You can leave out -progressive and -optimize\n(for cjpeg) or specify -onepass (for djpeg) to reduce memory usage.\n\nOn machines that have \"environment\" variables, you can define the environment\nvariable JPEGMEM to set the default memory limit.  The value is specified as\ndescribed for the -maxmemory switch.  JPEGMEM overrides the default value\nspecified when the program was compiled, and itself is overridden by an\nexplicit -maxmemory switch.\n\n\nJPEGTRAN\n\njpegtran performs various useful transformations of lossy (DCT-based) JPEG\nfiles.  It can translate the coded representation from one variant of JPEG to\nanother, for example from baseline JPEG to progressive JPEG or vice versa.  It\ncan also perform some rearrangements of the image data, for example turning an\nimage from landscape to portrait format by rotation.  For EXIF files and JPEG\nfiles containing Exif data, you may prefer to use exiftran instead.\n\njpegtran works by rearranging the compressed data (DCT coefficients), without\never fully decoding the image.  Therefore, its transformations are lossless:\nthere is no image degradation at all, which would not be true if you used\ndjpeg followed by cjpeg to accomplish the same conversion.  But by the same\ntoken, jpegtran cannot perform lossy operations such as changing the image\nquality.  However, while the image data is losslessly transformed, metadata\ncan be removed.  See the -copy option for specifics.\n\njpegtran uses a command line syntax similar to cjpeg or djpeg.\nOn most systems, you say:\n        jpegtran [switches] [inputfile] >outputfile\nIf you defined TWO_FILE_COMMANDLINE when compiling the program, you can instead\nsay:\n        jpegtran [switches] inputfile outputfile\nwhere both the input and output files are JPEG files.\n\nTo specify the coded JPEG representation used in the output file,\njpegtran accepts a subset of the switches recognized by cjpeg:\n        -optimize       Perform optimization of entropy encoding parameters.\n        -progressive    Create progressive JPEG file.\n        -arithmetic     Use arithmetic coding.\n        -restart N      Emit a JPEG restart marker every N MCU rows, or every\n                        N MCUs if \"B\" is attached to the number.\n        -scans file     Use the scan script given in the specified text file.\nSee the previous discussion of cjpeg for more details about these switches.\nIf you specify none of these switches, you get a plain baseline-JPEG output\nfile.  The quality setting and so forth are determined by the input file.\n\nThe image can be losslessly transformed by giving one of these switches:\n        -flip horizontal        Mirror image horizontally (left-right).\n        -flip vertical          Mirror image vertically (top-bottom).\n        -rotate 90              Rotate image 90 degrees clockwise.\n        -rotate 180             Rotate image 180 degrees.\n        -rotate 270             Rotate image 270 degrees clockwise (or 90 ccw).\n        -transpose              Transpose image (across UL-to-LR axis).\n        -transverse             Transverse transpose (across UR-to-LL axis).\n\nThe transpose transformation has no restrictions regarding image dimensions.\nThe other transformations operate rather oddly if the image dimensions are not\na multiple of the iMCU size (usually 8 or 16 pixels), because they can only\ntransform complete blocks of DCT coefficient data in the desired way.\n\njpegtran's default behavior when transforming an odd-size image is designed\nto preserve exact reversibility and mathematical consistency of the\ntransformation set.  As stated, transpose is able to flip the entire image\narea.  Horizontal mirroring leaves any partial iMCU column at the right edge\nuntouched, but is able to flip all rows of the image.  Similarly, vertical\nmirroring leaves any partial iMCU row at the bottom edge untouched, but is\nable to flip all columns.  The other transforms can be built up as sequences\nof transpose and flip operations; for consistency, their actions on edge\npixels are defined to be the same as the end result of the corresponding\ntranspose-and-flip sequence.\n\nFor practical use, you may prefer to discard any untransformable edge pixels\nrather than having a strange-looking strip along the right and/or bottom edges\nof a transformed image.  To do this, add the -trim switch:\n        -trim           Drop non-transformable edge blocks.\nObviously, a transformation with -trim is not reversible, so strictly speaking\njpegtran with this switch is not lossless.  Also, the expected mathematical\nequivalences between the transformations no longer hold.  For example,\n\"-rot 270 -trim\" trims only the bottom edge, but \"-rot 90 -trim\" followed by\n\"-rot 180 -trim\" trims both edges.\n\nIf you are only interested in perfect transformations, add the -perfect switch:\n        -perfect        Fail with an error if the transformation is not\n                        perfect.\nFor example, you may want to do\n  jpegtran -rot 90 -perfect foo.jpg || djpeg foo.jpg | pnmflip -r90 | cjpeg\nto do a perfect rotation, if available, or an approximated one if not.\n\nThis version of jpegtran also offers a lossless crop option, which discards\ndata outside of a given image region but losslessly preserves what is inside.\nLike the rotate and flip transforms, lossless crop is restricted by the current\nJPEG format; the upper left corner of the selected region must fall on an iMCU\nboundary.  If it doesn't, then it is silently moved up and/or left to the\nnearest iMCU boundary (the lower right corner is unchanged.)  Thus, the output\nimage covers at least the requested region, but it may cover more.  The\nadjustment of the region dimensions may be optionally disabled by attaching an\n'f' character (\"force\") to the width or height number.\n\nThe image can be losslessly cropped by giving the switch:\n        -crop WxH+X+Y   Crop to a rectangular region of width W and height H,\n                        starting at point X,Y.\n\nIf W or H is larger than the width/height of the input image, then the output\nimage is expanded in size, and the expanded region is filled in with zeros\n(neutral gray).  Attaching an 'f' character (\"flatten\") to the width number\nwill cause each block in the expanded region to be filled in with the DC\ncoefficient of the nearest block in the input image rather than grayed out.\nAttaching an 'r' character (\"reflect\") to the width number will cause the\nexpanded region to be filled in with repeated reflections of the input image\nrather than grayed out.\n\nA complementary lossless wipe option is provided to discard (gray out) data\ninside a given image region while losslessly preserving what is outside:\n        -wipe WxH+X+Y   Wipe (gray out) a rectangular region of width W and\n                        height H from the input image, starting at point X,Y.\n\nAttaching an 'f' character (\"flatten\") to the width number will cause the\nregion to be filled with the average of adjacent blocks rather than grayed out.\nIf the wipe region and the region outside the wipe region, when adjusted to the\nnearest iMCU boundary, form two horizontally adjacent rectangles, then\nattaching an 'r' character (\"reflect\") to the width number will cause the wipe\nregion to be filled with repeated reflections of the outside region rather than\ngrayed out.\n\nA lossless drop option is also provided, which allows another JPEG image to be\ninserted (\"dropped\") into the input image data at a given position, replacing\nthe existing image data at that position:\n        -drop +X+Y filename     Drop (insert) another image at point X,Y\n\nBoth the input image and the drop image must have the same subsampling level.\nIt is best if they also have the same quantization (quality.)  Otherwise, the\nquantization of the output image will be adapted to accommodate the higher of\nthe input image quality and the drop image quality.  The trim option can be\nused with the drop option to requantize the drop image to match the input\nimage.  Note that a grayscale image can be dropped into a full-color image or\nvice versa, as long as the full-color image has no vertical subsampling.  If\nthe input image is grayscale and the drop image is full-color, then the\nchrominance channels from the drop image will be discarded.\n\nOther not-strictly-lossless transformation switches are:\n\n        -grayscale      Force grayscale output.\nThis option discards the chrominance channels if the input image is YCbCr\n(ie, a standard color JPEG), resulting in a grayscale JPEG file.  The\nluminance channel is preserved exactly, so this is a better method of reducing\nto grayscale than decompression, conversion, and recompression.  This switch\nis particularly handy for fixing a monochrome picture that was mistakenly\nencoded as a color JPEG.  (In such a case, the space savings from getting rid\nof the near-empty chroma channels won't be large; but the decoding time for\na grayscale JPEG is substantially less than that for a color JPEG.)\n\njpegtran also recognizes these switches that control what to do with \"extra\"\nmarkers, such as comment blocks:\n        -copy none      Copy no extra markers from source file.  This setting\n                        suppresses all comments and other metadata in the\n                        source file.\n        -copy comments  Copy only comment markers.  This setting copies\n                        comments from the source file but discards any other\n                        metadata.\n        -copy icc       Copy only ICC profile markers.  This setting copies the\n                        ICC profile from the source file but discards any other\n                        metadata.\n        -copy all       Copy all extra markers.  This setting preserves\n                        miscellaneous markers found in the source file, such\n                        as JFIF thumbnails, Exif data, and Photoshop settings.\n                        In some files, these extra markers can be sizable.\n                        Note that this option will copy thumbnails as-is;\n                        they will not be transformed.\nThe default behavior is -copy comments.  (Note: in IJG releases v6 and v6a,\njpegtran always did the equivalent of -copy none.)\n\nAdditional switches recognized by jpegtran are:\n        -icc FILE\n        -maxmemory N\n        -maxscans N\n        -outfile filename\n        -report\n        -strict\n        -verbose\n        -debug\n        -version\nThese work the same as in cjpeg or djpeg.\n\n\nTHE COMMENT UTILITIES\n\nThe JPEG standard allows \"comment\" (COM) blocks to occur within a JPEG file.\nAlthough the standard doesn't actually define what COM blocks are for, they\nare widely used to hold user-supplied text strings.  This lets you add\nannotations, titles, index terms, etc to your JPEG files, and later retrieve\nthem as text.  COM blocks do not interfere with the image stored in the JPEG\nfile.  The maximum size of a COM block is 64K, but you can have as many of\nthem as you like in one JPEG file.\n\nWe provide two utility programs to display COM block contents and add COM\nblocks to a JPEG file.\n\nrdjpgcom searches a JPEG file and prints the contents of any COM blocks on\nstandard output.  The command line syntax is\n        rdjpgcom [-raw] [-verbose] [inputfilename]\nThe switch \"-raw\" (or just \"-r\") causes rdjpgcom to output non-printable\ncharacters in JPEG comments.  These characters are normally escaped for\nsecurity reasons.\nThe switch \"-verbose\" (or just \"-v\") causes rdjpgcom to also display the JPEG\nimage dimensions.  If you omit the input file name from the command line,\nthe JPEG file is read from standard input.  (This may not work on some\noperating systems, if binary data can't be read from stdin.)\n\nwrjpgcom adds a COM block, containing text you provide, to a JPEG file.\nOrdinarily, the COM block is added after any existing COM blocks, but you\ncan delete the old COM blocks if you wish.  wrjpgcom produces a new JPEG\nfile; it does not modify the input file.  DO NOT try to overwrite the input\nfile by directing wrjpgcom's output back into it; on most systems this will\njust destroy your file.\n\nThe command line syntax for wrjpgcom is similar to cjpeg's.  On most systems,\nit is\n        wrjpgcom [switches] [inputfilename]\nThe output file is written to standard output.  The input file comes from\nthe named file, or from standard input if no input file is named.\n\nIf you defined TWO_FILE_COMMANDLINE when compiling the program, the syntax is:\n        wrjpgcom [switches] inputfilename outputfilename\nwhere both input and output file names must be given explicitly.\n\nwrjpgcom understands three switches:\n        -replace                 Delete any existing COM blocks from the file.\n        -comment \"Comment text\"  Supply new COM text on command line.\n        -cfile name              Read text for new COM block from named file.\n(Switch names can be abbreviated.)  If you have only one line of comment text\nto add, you can provide it on the command line with -comment.  The comment\ntext must be surrounded with quotes so that it is treated as a single\nargument.  Longer comments can be read from a text file.\n\nIf you give neither -comment nor -cfile, then wrjpgcom will read the comment\ntext from standard input.  (In this case an input image file name MUST be\nsupplied, so that the source JPEG file comes from somewhere else.)  You can\nenter multiple lines, up to 64KB worth.  Type an end-of-file indicator\n(usually control-D or control-Z) to terminate the comment text entry.\n\nwrjpgcom will not add a COM block if the provided comment string is empty.\nTherefore -replace -comment \"\" can be used to delete all COM blocks from a\nfile.\n\nThese utility programs do not depend on the IJG JPEG library.  In\nparticular, the source code for rdjpgcom is intended as an illustration of\nthe minimum amount of code required to parse a JPEG file header correctly.\n"
        },
        {
          "name": "win",
          "type": "tree",
          "content": null
        },
        {
          "name": "wizard.txt",
          "type": "blob",
          "size": 10.9912109375,
          "content": "Advanced usage instructions for the Independent JPEG Group's JPEG software\n==========================================================================\n\nThis file describes cjpeg's \"switches for wizards\".\n\nThe \"wizard\" switches are intended for experimentation with JPEG by persons\nwho are reasonably knowledgeable about the JPEG standard.  If you don't know\nwhat you are doing, DON'T USE THESE SWITCHES.  You'll likely produce files\nwith worse image quality and/or poorer compression than you'd get from the\ndefault settings.  Furthermore, these switches must be used with caution\nwhen making files intended for general use, because not all JPEG decoders\nwill support unusual JPEG parameter settings.\n\n\nQuantization Table Adjustment\n-----------------------------\n\nOrdinarily, cjpeg starts with a default set of tables (the same ones given\nas examples in the JPEG standard) and scales them up or down according to\nthe -quality setting.  The details of the scaling algorithm can be found in\njcparam.c.  At very low quality settings, some quantization table entries\ncan get scaled up to values exceeding 255.  Although 2-byte quantization\nvalues are supported by the IJG software, this feature is not in baseline\nJPEG and is not supported by all implementations.  If you need to ensure\nwide compatibility of low-quality files, you can constrain the scaled\nquantization values to no more than 255 by giving the -baseline switch.\nNote that use of -baseline will result in poorer quality for the same file\nsize, since more bits than necessary are expended on higher AC coefficients.\n\nYou can substitute a different set of quantization values by using the\n-qtables switch:\n\n        -qtables file   Use the quantization tables given in the named file.\n\nThe specified file should be a text file containing decimal quantization\nvalues.  The file should contain one to four tables, each of 64 elements.\nThe tables are implicitly numbered 0,1,etc. in order of appearance.  Table\nentries appear in normal array order (NOT in the zigzag order in which they\nwill be stored in the JPEG file).\n\nQuantization table files are free format, in that arbitrary whitespace can\nappear between numbers.  Also, comments can be included: a comment starts\nwith '#' and extends to the end of the line.  Here is an example file that\nduplicates the default quantization tables:\n\n        # Quantization tables given in Annex K (Clause K.1) of\n        # Recommendation ITU-T T.81 (1992) | ISO/IEC 10918-1:1994.\n\n        # This is table 0 (the luminance table):\n          16  11  10  16  24  40  51  61\n          12  12  14  19  26  58  60  55\n          14  13  16  24  40  57  69  56\n          14  17  22  29  51  87  80  62\n          18  22  37  56  68 109 103  77\n          24  35  55  64  81 104 113  92\n          49  64  78  87 103 121 120 101\n          72  92  95  98 112 100 103  99\n\n        # This is table 1 (the chrominance table):\n          17  18  24  47  99  99  99  99\n          18  21  26  66  99  99  99  99\n          24  26  56  99  99  99  99  99\n          47  66  99  99  99  99  99  99\n          99  99  99  99  99  99  99  99\n          99  99  99  99  99  99  99  99\n          99  99  99  99  99  99  99  99\n          99  99  99  99  99  99  99  99\n\nIf the -qtables switch is used without -quality, then the specified tables\nare used exactly as-is.  If both -qtables and -quality are used, then the\ntables taken from the file are scaled in the same fashion that the default\ntables would be scaled for that quality setting.  If -baseline appears, then\nthe quantization values are constrained to the range 1-255.\n\nBy default, cjpeg will use quantization table 0 for luminance components and\ntable 1 for chrominance components.  To override this choice, use the -qslots\nswitch:\n\n        -qslots N[,...]         Select which quantization table to use for\n                                each color component.\n\nThe -qslots switch specifies a quantization table number for each color\ncomponent, in the order in which the components appear in the JPEG SOF marker.\nFor example, to create a separate table for each of Y,Cb,Cr, you could\nprovide a -qtables file that defines three quantization tables and say\n\"-qslots 0,1,2\".  If -qslots gives fewer table numbers than there are color\ncomponents, then the last table number is repeated as necessary.\n\n\nSampling Factor Adjustment\n--------------------------\n\nBy default, cjpeg uses 2:1 horizontal and vertical downsampling when\ncompressing YCbCr data, and no downsampling for all other color spaces.\nYou can override this default with the -sample switch:\n\n        -sample HxV[,...]       Set JPEG sampling factors for each color\n                                component.\n\nThe -sample switch specifies the JPEG sampling factors for each color\ncomponent, in the order in which they appear in the JPEG SOF marker.\nIf you specify fewer HxV pairs than there are components, the remaining\ncomponents are set to 1x1 sampling.  For example, the default YCbCr setting\nis equivalent to \"-sample 2x2,1x1,1x1\", which can be abbreviated to\n\"-sample 2x2\".\n\nThere are still some JPEG decoders in existence that support only 2x1\nsampling (also called 4:2:2 sampling).  Compatibility with such decoders can\nbe achieved by specifying \"-sample 2x1\".  This is not recommended unless\nreally necessary, since it increases file size and encoding/decoding time\nwith very little quality gain.\n\n\nMultiple Scan / Progression Control\n-----------------------------------\n\nBy default, cjpeg emits a single-scan sequential JPEG file.  The\n-progressive switch generates a progressive JPEG file using a default series\nof progression parameters.  You can create multiple-scan sequential or lossless\nJPEG files or progressive JPEG files with custom progression parameters by\nusing the -scans switch:\n\n        -scans file     Use the scan sequence given in the named file.\n\nThe specified file should be a text file containing a \"scan script\".\nThe script specifies the contents and ordering of the scans to be emitted.\nEach entry in the script defines one scan.  A scan definition specifies\nthe components to be included in the scan, and for progressive and lossless\nJPEG it also specifies the progression/lossless parameters Ss,Se,Ah,Al for the\nscan.  Scan definitions are separated by semicolons (';').  A semicolon after\nthe last scan definition is optional.\n\nEach scan definition contains one to four component indexes, optionally\nfollowed by a colon (':') and the four progressive/lossless-JPEG parameters.\nThe component indexes denote which color component(s) are to be transmitted in\nthe scan.  Components are numbered in the order in which they appear in the\nJPEG SOF marker, with the first component being numbered 0.  (Note that these\nindexes are not the \"component ID\" codes assigned to the components, just\npositional indexes.)\n\nThe progression parameters for each scan are:\n        Ss      Zigzag index of first coefficient included in scan\n        Se      Zigzag index of last coefficient included in scan\n        Ah      Zero for first scan of a coefficient, else Al of prior scan\n        Al      Successive approximation low bit position for scan\n\nThe lossless parameters for each scan are:\n        Ss      Predictor selection value\n        Se      Must be zero\n        Ah      Must be zero\n        Al      Point transform value\n\nIf the progression/lossless parameters are omitted, the values 0,63,0,0 are\nused, producing a sequential JPEG file.  cjpeg automatically determines whether\nthe script represents a progressive or sequential file, by observing whether\nSs and Se values other than 0 and 63 appear.  cjpeg also automatically\ndetermines whether the script represents a lossless file, by observing whether\nSs (the predictor selection value) is non-zero and Se is zero, which are\nillegal values for progressive and sequential files.  (The -progressive and\n-lossless switches are not needed to specify this; in fact, they are ignored\nwhen -scans appears.)  The scan script must meet the JPEG restrictions on\nprogression sequences.  (cjpeg checks that the spec's requirements are obeyed.)\nMore specifically:\n\n    * An AC scan cannot include coefficients from more than one component.\n\n    * An AC scan for a particular component must be preceded by a DC scan\n      that includes the same component.\n\n    * Only the first AC scan that includes a particular coefficient for a\n      particular component can include more than one bit from that coefficient.\n\nScan script files are free format, in that arbitrary whitespace can appear\nbetween numbers and around punctuation.  Also, comments can be included: a\ncomment starts with '#' and extends to the end of the line.  For additional\nlegibility, commas or dashes can be placed between values.  (Actually, any\nsingle punctuation character other than ':' or ';' can be inserted.)  For\nexample, the following two scan definitions are equivalent:\n        0 1 2: 0 63 0 0;\n        0,1,2 : 0-63, 0,0 ;\n\nHere is an example of a scan script that generates a partially interleaved\nsequential JPEG file:\n\n        0;                      # Y only in first scan\n        1 2;                    # Cb and Cr in second scan\n\nHere is an example of a progressive scan script using only spectral selection\n(no successive approximation):\n\n        # Interleaved DC scan for Y,Cb,Cr:\n        0,1,2: 0-0,   0, 0 ;\n        # AC scans:\n        0:     1-2,   0, 0 ;    # First two Y AC coefficients\n        0:     3-5,   0, 0 ;    # Three more\n        1:     1-63,  0, 0 ;    # All AC coefficients for Cb\n        2:     1-63,  0, 0 ;    # All AC coefficients for Cr\n        0:     6-9,   0, 0 ;    # More Y coefficients\n        0:     10-63, 0, 0 ;    # Remaining Y coefficients\n\nHere is an example of a successive-approximation script.  This is equivalent\nto the default script used by \"cjpeg -progressive\" for YCbCr images:\n\n        # Initial DC scan for Y,Cb,Cr (lowest bit not sent)\n        0,1,2: 0-0,   0, 1 ;\n        # First AC scan: send first 5 Y AC coefficients, minus 2 lowest bits:\n        0:     1-5,   0, 2 ;\n        # Send all Cr,Cb AC coefficients, minus lowest bit:\n        # (chroma data is usually too small to be worth subdividing further;\n        #  but note we send Cr first since eye is least sensitive to Cb)\n        2:     1-63,  0, 1 ;\n        1:     1-63,  0, 1 ;\n        # Send remaining Y AC coefficients, minus 2 lowest bits:\n        0:     6-63,  0, 2 ;\n        # Send next-to-lowest bit of all Y AC coefficients:\n        0:     1-63,  2, 1 ;\n        # At this point we've sent all but the lowest bit of all coefficients.\n        # Send lowest bit of DC coefficients\n        0,1,2: 0-0,   1, 0 ;\n        # Send lowest bit of AC coefficients\n        2:     1-63,  1, 0 ;\n        1:     1-63,  1, 0 ;\n        # Y AC lowest bit scan is last; it's usually the largest scan\n        0:     1-63,  1, 0 ;\n\nIt may be worth pointing out that this script is tuned for quality settings\nof around 50 to 75.  For lower quality settings, you'd probably want to use\na script with fewer stages of successive approximation (otherwise the\ninitial scans will be really bad).  For higher quality settings, you might\nwant to use more stages of successive approximation (so that the initial\nscans are not too large).\n"
        },
        {
          "name": "wrbmp.c",
          "type": "blob",
          "size": 17.701171875,
          "content": "/*\n * wrbmp.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2013, Linaro Limited.\n * Copyright (C) 2014-2015, 2017, 2019, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to write output images in Microsoft \"BMP\"\n * format (MS Windows 3.x and OS/2 1.x flavors).\n * Either 8-bit colormapped or 24-bit full-color format can be written.\n * No compression is supported.\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume output to\n * an ordinary stdio stream.\n *\n * This code contributed by James Arthur Boucher.\n */\n\n#include \"cmyk.h\"\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n#include \"jconfigint.h\"\n\n#ifdef BMP_SUPPORTED\n\n\n/*\n * To support 12-bit JPEG data, we'd have to scale output down to 8 bits.\n * This is not yet implemented.\n */\n\n#if BITS_IN_JSAMPLE != 8\n  Sorry, this code only copes with 8-bit JSAMPLEs. /* deliberate syntax err */\n#endif\n\n/*\n * Since BMP stores scanlines bottom-to-top, we have to invert the image\n * from JPEG's top-to-bottom order.  To do this, we save the outgoing data\n * in a virtual array during put_pixel_row calls, then actually emit the\n * BMP file during finish_output.  The virtual array contains one JSAMPLE per\n * pixel if the output is grayscale or colormapped, three if it is full color.\n */\n\n/* Private version of data destination object */\n\ntypedef struct {\n  struct djpeg_dest_struct pub; /* public fields */\n\n  boolean is_os2;               /* saves the OS2 format request flag */\n\n  jvirt_sarray_ptr whole_image; /* needed to reverse row order */\n  JDIMENSION data_width;        /* JSAMPLEs per row */\n  JDIMENSION row_width;         /* physical width of one row in the BMP file */\n  int pad_bytes;                /* number of padding bytes needed per row */\n  JDIMENSION cur_output_row;    /* next row# to write to virtual array */\n\n  boolean use_inversion_array;  /* TRUE = buffer the whole image, which is\n                                   stored to disk in bottom-up order, and\n                                   receive rows from the calling program in\n                                   top-down order\n\n                                   FALSE = the calling program will maintain\n                                   its own image buffer and write the rows in\n                                   bottom-up order */\n\n  JSAMPLE *iobuffer;            /* I/O buffer (used to buffer a single row to\n                                   disk if use_inversion_array == FALSE) */\n} bmp_dest_struct;\n\ntypedef bmp_dest_struct *bmp_dest_ptr;\n\n\n/* Forward declarations */\nLOCAL(void) write_colormap(j_decompress_ptr cinfo, bmp_dest_ptr dest,\n                           int map_colors, int map_entry_size);\n\n\nstatic INLINE boolean is_big_endian(void)\n{\n  int test_value = 1;\n  if (*(char *)&test_value != 1)\n    return TRUE;\n  return FALSE;\n}\n\n\n/*\n * Write some pixel data.\n * In this module rows_supplied will always be 1.\n */\n\nMETHODDEF(void)\nput_pixel_rows(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n               JDIMENSION rows_supplied)\n/* This version is for writing 24-bit pixels */\n{\n  bmp_dest_ptr dest = (bmp_dest_ptr)dinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  int pad;\n\n  if (dest->use_inversion_array) {\n    /* Access next row in virtual array */\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, dest->whole_image,\n       dest->cur_output_row, (JDIMENSION)1, TRUE);\n    dest->cur_output_row++;\n    outptr = image_ptr[0];\n  } else {\n    outptr = dest->iobuffer;\n  }\n\n  /* Transfer data.  Note destination values must be in BGR order\n   * (even though Microsoft's own documents say the opposite).\n   */\n  inptr = dest->pub.buffer[0];\n\n  if (cinfo->out_color_space == JCS_EXT_BGR) {\n    memcpy(outptr, inptr, dest->row_width);\n    outptr += cinfo->output_width * 3;\n  } else if (cinfo->out_color_space == JCS_RGB565) {\n    boolean big_endian = is_big_endian();\n    unsigned short *inptr2 = (unsigned short *)inptr;\n    for (col = cinfo->output_width; col > 0; col--) {\n      if (big_endian) {\n        outptr[0] = (*inptr2 >> 5) & 0xF8;\n        outptr[1] = ((*inptr2 << 5) & 0xE0) | ((*inptr2 >> 11) & 0x1C);\n        outptr[2] = *inptr2 & 0xF8;\n      } else {\n        outptr[0] = (*inptr2 << 3) & 0xF8;\n        outptr[1] = (*inptr2 >> 3) & 0xFC;\n        outptr[2] = (*inptr2 >> 8) & 0xF8;\n      }\n      outptr += 3;\n      inptr2++;\n    }\n  } else if (cinfo->out_color_space == JCS_CMYK) {\n    for (col = cinfo->output_width; col > 0; col--) {\n      JSAMPLE c = *inptr++, m = *inptr++, y = *inptr++, k = *inptr++;\n      cmyk_to_rgb(c, m, y, k, outptr + 2, outptr + 1, outptr);\n      outptr += 3;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->out_color_space];\n    register int gindex = rgb_green[cinfo->out_color_space];\n    register int bindex = rgb_blue[cinfo->out_color_space];\n    register int ps = rgb_pixelsize[cinfo->out_color_space];\n\n    for (col = cinfo->output_width; col > 0; col--) {\n      outptr[0] = inptr[bindex];\n      outptr[1] = inptr[gindex];\n      outptr[2] = inptr[rindex];\n      outptr += 3;  inptr += ps;\n    }\n  }\n\n  /* Zero out the pad bytes. */\n  pad = dest->pad_bytes;\n  while (--pad >= 0)\n    *outptr++ = 0;\n\n  if (!dest->use_inversion_array)\n    fwrite(dest->iobuffer, 1, dest->row_width, dest->pub.output_file);\n}\n\nMETHODDEF(void)\nput_gray_rows(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n              JDIMENSION rows_supplied)\n/* This version is for grayscale OR quantized color output */\n{\n  bmp_dest_ptr dest = (bmp_dest_ptr)dinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  int pad;\n\n  if (dest->use_inversion_array) {\n    /* Access next row in virtual array */\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, dest->whole_image,\n       dest->cur_output_row, (JDIMENSION)1, TRUE);\n    dest->cur_output_row++;\n    outptr = image_ptr[0];\n  } else {\n    outptr = dest->iobuffer;\n  }\n\n  /* Transfer data. */\n  inptr = dest->pub.buffer[0];\n  memcpy(outptr, inptr, cinfo->output_width);\n  outptr += cinfo->output_width;\n\n  /* Zero out the pad bytes. */\n  pad = dest->pad_bytes;\n  while (--pad >= 0)\n    *outptr++ = 0;\n\n  if (!dest->use_inversion_array)\n    fwrite(dest->iobuffer, 1, dest->row_width, dest->pub.output_file);\n}\n\n\n/*\n * Finish up at the end of the file.\n *\n * Here is where we really output the BMP file.\n *\n * First, routines to write the Windows and OS/2 variants of the file header.\n */\n\nLOCAL(void)\nwrite_bmp_header(j_decompress_ptr cinfo, bmp_dest_ptr dest)\n/* Write a Windows-style BMP file header, including colormap if needed */\n{\n  char bmpfileheader[14];\n  char bmpinfoheader[40];\n\n#define PUT_2B(array, offset, value) \\\n  (array[offset] = (char)((value) & 0xFF), \\\n   array[offset + 1] = (char)(((value) >> 8) & 0xFF))\n#define PUT_4B(array, offset, value) \\\n  (array[offset] = (char)((value) & 0xFF), \\\n   array[offset + 1] = (char)(((value) >> 8) & 0xFF), \\\n   array[offset + 2] = (char)(((value) >> 16) & 0xFF), \\\n   array[offset + 3] = (char)(((value) >> 24) & 0xFF))\n\n  long headersize, bfSize;\n  int bits_per_pixel, cmap_entries;\n\n  /* Compute colormap size and total file size */\n  if (IsExtRGB(cinfo->out_color_space)) {\n    if (cinfo->quantize_colors) {\n      /* Colormapped RGB */\n      bits_per_pixel = 8;\n      cmap_entries = 256;\n    } else {\n      /* Unquantized, full color RGB */\n      bits_per_pixel = 24;\n      cmap_entries = 0;\n    }\n  } else if (cinfo->out_color_space == JCS_RGB565 ||\n             cinfo->out_color_space == JCS_CMYK) {\n    bits_per_pixel = 24;\n    cmap_entries   = 0;\n  } else {\n    /* Grayscale output.  We need to fake a 256-entry colormap. */\n    bits_per_pixel = 8;\n    cmap_entries = 256;\n  }\n  /* File size */\n  headersize = 14 + 40 + cmap_entries * 4; /* Header and colormap */\n  bfSize = headersize + (long)dest->row_width * (long)cinfo->output_height;\n\n  /* Set unused fields of header to 0 */\n  memset(bmpfileheader, 0, sizeof(bmpfileheader));\n  memset(bmpinfoheader, 0, sizeof(bmpinfoheader));\n\n  /* Fill the file header */\n  bmpfileheader[0] = 0x42;      /* first 2 bytes are ASCII 'B', 'M' */\n  bmpfileheader[1] = 0x4D;\n  PUT_4B(bmpfileheader, 2, bfSize); /* bfSize */\n  /* we leave bfReserved1 & bfReserved2 = 0 */\n  PUT_4B(bmpfileheader, 10, headersize); /* bfOffBits */\n\n  /* Fill the info header (Microsoft calls this a BITMAPINFOHEADER) */\n  PUT_2B(bmpinfoheader, 0, 40); /* biSize */\n  PUT_4B(bmpinfoheader, 4, cinfo->output_width); /* biWidth */\n  PUT_4B(bmpinfoheader, 8, cinfo->output_height); /* biHeight */\n  PUT_2B(bmpinfoheader, 12, 1); /* biPlanes - must be 1 */\n  PUT_2B(bmpinfoheader, 14, bits_per_pixel); /* biBitCount */\n  /* we leave biCompression = 0, for none */\n  /* we leave biSizeImage = 0; this is correct for uncompressed data */\n  if (cinfo->density_unit == 2) { /* if have density in dots/cm, then */\n    PUT_4B(bmpinfoheader, 24, (long)(cinfo->X_density * 100)); /* XPels/M */\n    PUT_4B(bmpinfoheader, 28, (long)(cinfo->Y_density * 100)); /* XPels/M */\n  }\n  PUT_2B(bmpinfoheader, 32, cmap_entries); /* biClrUsed */\n  /* we leave biClrImportant = 0 */\n\n  if (fwrite(bmpfileheader, 1, 14, dest->pub.output_file) != (size_t)14)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (fwrite(bmpinfoheader, 1, 40, dest->pub.output_file) != (size_t)40)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n\n  if (cmap_entries > 0)\n    write_colormap(cinfo, dest, cmap_entries, 4);\n}\n\n\nLOCAL(void)\nwrite_os2_header(j_decompress_ptr cinfo, bmp_dest_ptr dest)\n/* Write an OS2-style BMP file header, including colormap if needed */\n{\n  char bmpfileheader[14];\n  char bmpcoreheader[12];\n  long headersize, bfSize;\n  int bits_per_pixel, cmap_entries;\n\n  /* Compute colormap size and total file size */\n  if (IsExtRGB(cinfo->out_color_space)) {\n    if (cinfo->quantize_colors) {\n      /* Colormapped RGB */\n      bits_per_pixel = 8;\n      cmap_entries = 256;\n    } else {\n      /* Unquantized, full color RGB */\n      bits_per_pixel = 24;\n      cmap_entries = 0;\n    }\n  } else if (cinfo->out_color_space == JCS_RGB565 ||\n             cinfo->out_color_space == JCS_CMYK) {\n    bits_per_pixel = 24;\n    cmap_entries   = 0;\n  } else {\n    /* Grayscale output.  We need to fake a 256-entry colormap. */\n    bits_per_pixel = 8;\n    cmap_entries = 256;\n  }\n  /* File size */\n  headersize = 14 + 12 + cmap_entries * 3; /* Header and colormap */\n  bfSize = headersize + (long)dest->row_width * (long)cinfo->output_height;\n\n  /* Set unused fields of header to 0 */\n  memset(bmpfileheader, 0, sizeof(bmpfileheader));\n  memset(bmpcoreheader, 0, sizeof(bmpcoreheader));\n\n  /* Fill the file header */\n  bmpfileheader[0] = 0x42;      /* first 2 bytes are ASCII 'B', 'M' */\n  bmpfileheader[1] = 0x4D;\n  PUT_4B(bmpfileheader, 2, bfSize); /* bfSize */\n  /* we leave bfReserved1 & bfReserved2 = 0 */\n  PUT_4B(bmpfileheader, 10, headersize); /* bfOffBits */\n\n  /* Fill the info header (Microsoft calls this a BITMAPCOREHEADER) */\n  PUT_2B(bmpcoreheader, 0, 12); /* bcSize */\n  PUT_2B(bmpcoreheader, 4, cinfo->output_width); /* bcWidth */\n  PUT_2B(bmpcoreheader, 6, cinfo->output_height); /* bcHeight */\n  PUT_2B(bmpcoreheader, 8, 1);  /* bcPlanes - must be 1 */\n  PUT_2B(bmpcoreheader, 10, bits_per_pixel); /* bcBitCount */\n\n  if (fwrite(bmpfileheader, 1, 14, dest->pub.output_file) != (size_t)14)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (fwrite(bmpcoreheader, 1, 12, dest->pub.output_file) != (size_t)12)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n\n  if (cmap_entries > 0)\n    write_colormap(cinfo, dest, cmap_entries, 3);\n}\n\n\n/*\n * Write the colormap.\n * Windows uses BGR0 map entries; OS/2 uses BGR entries.\n */\n\nLOCAL(void)\nwrite_colormap(j_decompress_ptr cinfo, bmp_dest_ptr dest, int map_colors,\n               int map_entry_size)\n{\n  JSAMPARRAY colormap = cinfo->colormap;\n  int num_colors = cinfo->actual_number_of_colors;\n  FILE *outfile = dest->pub.output_file;\n  int i;\n\n  if (colormap != NULL) {\n    if (cinfo->out_color_components == 3) {\n      /* Normal case with RGB colormap */\n      for (i = 0; i < num_colors; i++) {\n        putc(colormap[2][i], outfile);\n        putc(colormap[1][i], outfile);\n        putc(colormap[0][i], outfile);\n        if (map_entry_size == 4)\n          putc(0, outfile);\n      }\n    } else {\n      /* Grayscale colormap (only happens with grayscale quantization) */\n      for (i = 0; i < num_colors; i++) {\n        putc(colormap[0][i], outfile);\n        putc(colormap[0][i], outfile);\n        putc(colormap[0][i], outfile);\n        if (map_entry_size == 4)\n          putc(0, outfile);\n      }\n    }\n  } else {\n    /* If no colormap, must be grayscale data.  Generate a linear \"map\". */\n    for (i = 0; i < 256; i++) {\n      putc(i, outfile);\n      putc(i, outfile);\n      putc(i, outfile);\n      if (map_entry_size == 4)\n        putc(0, outfile);\n    }\n  }\n  /* Pad colormap with zeros to ensure specified number of colormap entries */\n  if (i > map_colors)\n    ERREXIT1(cinfo, JERR_TOO_MANY_COLORS, i);\n  for (; i < map_colors; i++) {\n    putc(0, outfile);\n    putc(0, outfile);\n    putc(0, outfile);\n    if (map_entry_size == 4)\n      putc(0, outfile);\n  }\n}\n\n\n/*\n * Startup: write the file header unless the inversion array is being used.\n */\n\nMETHODDEF(void)\nstart_output_bmp(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  bmp_dest_ptr dest = (bmp_dest_ptr)dinfo;\n\n  if (!dest->use_inversion_array) {\n    /* Write the header and colormap */\n    if (dest->is_os2)\n      write_os2_header(cinfo, dest);\n    else\n      write_bmp_header(cinfo, dest);\n  }\n}\n\n\nMETHODDEF(void)\nfinish_output_bmp(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  bmp_dest_ptr dest = (bmp_dest_ptr)dinfo;\n  register FILE *outfile = dest->pub.output_file;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW data_ptr;\n  JDIMENSION row;\n  cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n\n  if (dest->use_inversion_array) {\n    /* Write the header and colormap */\n    if (dest->is_os2)\n      write_os2_header(cinfo, dest);\n    else\n      write_bmp_header(cinfo, dest);\n\n    /* Write the file body from our virtual array */\n    for (row = cinfo->output_height; row > 0; row--) {\n      if (progress != NULL) {\n        progress->pub.pass_counter = (long)(cinfo->output_height - row);\n        progress->pub.pass_limit = (long)cinfo->output_height;\n        (*progress->pub.progress_monitor) ((j_common_ptr)cinfo);\n      }\n      image_ptr = (*cinfo->mem->access_virt_sarray)\n        ((j_common_ptr)cinfo, dest->whole_image, row - 1, (JDIMENSION)1,\n         FALSE);\n      data_ptr = image_ptr[0];\n      fwrite(data_ptr, 1, dest->row_width, outfile);\n    }\n    if (progress != NULL)\n      progress->completed_extra_passes++;\n  }\n\n  /* Make sure we wrote the output file OK */\n  fflush(outfile);\n  if (ferror(outfile))\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n}\n\n\n/*\n * The module selection routine for BMP format output.\n */\n\nGLOBAL(djpeg_dest_ptr)\njinit_write_bmp(j_decompress_ptr cinfo, boolean is_os2,\n                boolean use_inversion_array)\n{\n  bmp_dest_ptr dest;\n  JDIMENSION row_width;\n\n  if (cinfo->data_precision != 8)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Create module interface object, fill in method pointers */\n  dest = (bmp_dest_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(bmp_dest_struct));\n  dest->pub.start_output = start_output_bmp;\n  dest->pub.finish_output = finish_output_bmp;\n  dest->pub.calc_buffer_dimensions = NULL;\n  dest->is_os2 = is_os2;\n\n  if (cinfo->out_color_space == JCS_GRAYSCALE) {\n    dest->pub.put_pixel_rows = put_gray_rows;\n  } else if (IsExtRGB(cinfo->out_color_space)) {\n    if (cinfo->quantize_colors)\n      dest->pub.put_pixel_rows = put_gray_rows;\n    else\n      dest->pub.put_pixel_rows = put_pixel_rows;\n  } else if (!cinfo->quantize_colors &&\n             (cinfo->out_color_space == JCS_RGB565 ||\n              cinfo->out_color_space == JCS_CMYK)) {\n    dest->pub.put_pixel_rows = put_pixel_rows;\n  } else {\n    ERREXIT(cinfo, JERR_BMP_COLORSPACE);\n  }\n\n  /* Calculate output image dimensions so we can allocate space */\n  jpeg_calc_output_dimensions(cinfo);\n\n  /* Determine width of rows in the BMP file (padded to 4-byte boundary). */\n  if (cinfo->out_color_space == JCS_RGB565) {\n    row_width = cinfo->output_width * 2;\n    dest->row_width = dest->data_width = cinfo->output_width * 3;\n    while ((row_width & 3) != 0) row_width++;\n  } else if (!cinfo->quantize_colors &&\n             (IsExtRGB(cinfo->out_color_space) ||\n              cinfo->out_color_space == JCS_CMYK)) {\n    row_width = cinfo->output_width * cinfo->output_components;\n    dest->row_width = dest->data_width = cinfo->output_width * 3;\n  } else {\n    row_width = cinfo->output_width * cinfo->output_components;\n    dest->row_width = dest->data_width = row_width;\n  }\n  while ((dest->row_width & 3) != 0) dest->row_width++;\n  dest->pad_bytes = (int)(dest->row_width - dest->data_width);\n\n\n  if (use_inversion_array) {\n    /* Allocate space for inversion array, prepare for write pass */\n    dest->whole_image = (*cinfo->mem->request_virt_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n       dest->row_width, cinfo->output_height, (JDIMENSION)1);\n    dest->cur_output_row = 0;\n    if (cinfo->progress != NULL) {\n      cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n      progress->total_extra_passes++; /* count file input as separate pass */\n    }\n  } else {\n    dest->iobuffer = (JSAMPLE *)(*cinfo->mem->alloc_small)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, dest->row_width);\n  }\n  dest->use_inversion_array = use_inversion_array;\n\n  /* Create decompressor output buffer. */\n  dest->pub.buffer = (*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE, row_width, (JDIMENSION)1);\n  dest->pub.buffer_height = 1;\n\n  return (djpeg_dest_ptr)dest;\n}\n\n#endif /* BMP_SUPPORTED */\n"
        },
        {
          "name": "wrgif.c",
          "type": "blob",
          "size": 18.4638671875,
          "content": "/*\n * wrgif.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1997, Thomas G. Lane.\n * Modified 2015-2019 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2015, 2017, 2022-2023, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to write output images in GIF format.\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume output to\n * an ordinary stdio stream.\n */\n\n/*\n * This code is loosely based on ppmtogif from the PBMPLUS distribution\n * of Feb. 1991.  That file contains the following copyright notice:\n *    Based on GIFENCODE by David Rowley <mgardi@watdscu.waterloo.edu>.\n *    Lempel-Ziv compression based on \"compress\" by Spencer W. Thomas et al.\n *    Copyright (C) 1989 by Jef Poskanzer.\n *    Permission to use, copy, modify, and distribute this software and its\n *    documentation for any purpose and without fee is hereby granted, provided\n *    that the above copyright notice appear in all copies and that both that\n *    copyright notice and this permission notice appear in supporting\n *    documentation.  This software is provided \"as is\" without express or\n *    implied warranty.\n */\n\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n#include \"jsamplecomp.h\"\n\n#if defined(GIF_SUPPORTED) && BITS_IN_JSAMPLE != 16\n\n\n#define MAX_LZW_BITS     12     /* maximum LZW code size (4096 symbols) */\n\ntypedef INT16 code_int;         /* must hold -1 .. 2**MAX_LZW_BITS */\n\n#define LZW_TABLE_SIZE   ((code_int)1 << MAX_LZW_BITS)\n\n#define HSIZE            5003   /* hash table size for 80% occupancy */\n\ntypedef int hash_int;           /* must hold -2*HSIZE..2*HSIZE */\n\n#define MAXCODE(n_bits)  (((code_int)1 << (n_bits)) - 1)\n\n\n/*\n * The LZW hash table consists of two parallel arrays:\n *   hash_code[i]       code of symbol in slot i, or 0 if empty slot\n *   hash_value[i]      symbol's value; undefined if empty slot\n * where slot values (i) range from 0 to HSIZE-1.  The symbol value is\n * its prefix symbol's code concatenated with its suffix character.\n *\n * Algorithm:  use open addressing double hashing (no chaining) on the\n * prefix code / suffix character combination.  We do a variant of Knuth's\n * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n * secondary probe.\n */\n\ntypedef int hash_entry;         /* must hold (code_int << 8) | byte */\n\n#define HASH_ENTRY(prefix, suffix)  ((((hash_entry)(prefix)) << 8) | (suffix))\n\n\n/* Private version of data destination object */\n\ntypedef struct {\n  struct djpeg_dest_struct pub; /* public fields */\n\n  j_decompress_ptr cinfo;       /* back link saves passing separate parm */\n\n  /* State for packing variable-width codes into a bitstream */\n  int n_bits;                   /* current number of bits/code */\n  code_int maxcode;             /* maximum code, given n_bits */\n  int init_bits;                /* initial n_bits ... restored after clear */\n  int cur_accum;                /* holds bits not yet output */\n  int cur_bits;                 /* # of bits in cur_accum */\n\n  /* LZW string construction */\n  code_int waiting_code;        /* symbol not yet output; may be extendable */\n  boolean first_byte;           /* if TRUE, waiting_code is not valid */\n\n  /* State for GIF code assignment */\n  code_int ClearCode;           /* clear code (doesn't change) */\n  code_int EOFCode;             /* EOF code (ditto) */\n  code_int free_code;           /* LZW: first not-yet-used symbol code */\n  code_int code_counter;        /* not LZW: counts output symbols */\n\n  /* LZW hash table */\n  code_int *hash_code;          /* => hash table of symbol codes */\n  hash_entry *hash_value;       /* => hash table of symbol values */\n\n  /* GIF data packet construction buffer */\n  int bytesinpkt;               /* # of bytes in current packet */\n  char packetbuf[256];          /* workspace for accumulating packet */\n\n} gif_dest_struct;\n\ntypedef gif_dest_struct *gif_dest_ptr;\n\n\n/*\n * Routines to package finished data bytes into GIF data blocks.\n * A data block consists of a count byte (1..255) and that many data bytes.\n */\n\nLOCAL(void)\nflush_packet(gif_dest_ptr dinfo)\n/* flush any accumulated data */\n{\n  if (dinfo->bytesinpkt > 0) {  /* never write zero-length packet */\n    dinfo->packetbuf[0] = (char)dinfo->bytesinpkt++;\n    if (fwrite(dinfo->packetbuf, 1, dinfo->bytesinpkt,\n               dinfo->pub.output_file) != (size_t)dinfo->bytesinpkt)\n      ERREXIT(dinfo->cinfo, JERR_FILE_WRITE);\n    dinfo->bytesinpkt = 0;\n  }\n}\n\n\n/* Add a character to current packet; flush to disk if necessary */\n#define CHAR_OUT(dinfo, c) { \\\n  (dinfo)->packetbuf[++(dinfo)->bytesinpkt] = (char)(c); \\\n  if ((dinfo)->bytesinpkt >= 255) \\\n    flush_packet(dinfo); \\\n}\n\n\n/* Routine to convert variable-width codes into a byte stream */\n\nLOCAL(void)\noutput(gif_dest_ptr dinfo, code_int code)\n/* Emit a code of n_bits bits */\n/* Uses cur_accum and cur_bits to reblock into 8-bit bytes */\n{\n  dinfo->cur_accum |= ((long)code) << dinfo->cur_bits;\n  dinfo->cur_bits += dinfo->n_bits;\n\n  while (dinfo->cur_bits >= 8) {\n    CHAR_OUT(dinfo, dinfo->cur_accum & 0xFF);\n    dinfo->cur_accum >>= 8;\n    dinfo->cur_bits -= 8;\n  }\n\n  /*\n   * If the next entry is going to be too big for the code size,\n   * then increase it, if possible.  We do this here to ensure\n   * that it's done in sync with the decoder's codesize increases.\n   */\n  if (dinfo->free_code > dinfo->maxcode) {\n    dinfo->n_bits++;\n    if (dinfo->n_bits == MAX_LZW_BITS)\n      dinfo->maxcode = LZW_TABLE_SIZE; /* free_code will never exceed this */\n    else\n      dinfo->maxcode = MAXCODE(dinfo->n_bits);\n  }\n}\n\n\n/* Compression initialization & termination */\n\n\nLOCAL(void)\nclear_hash(gif_dest_ptr dinfo)\n/* Fill the hash table with empty entries */\n{\n  /* It's sufficient to zero hash_code[] */\n  memset(dinfo->hash_code, 0, HSIZE * sizeof(code_int));\n}\n\n\nLOCAL(void)\nclear_block(gif_dest_ptr dinfo)\n/* Reset compressor and issue a Clear code */\n{\n  clear_hash(dinfo);                    /* delete all the symbols */\n  dinfo->free_code = dinfo->ClearCode + 2;\n  output(dinfo, dinfo->ClearCode);      /* inform decoder */\n  dinfo->n_bits = dinfo->init_bits;     /* reset code size */\n  dinfo->maxcode = MAXCODE(dinfo->n_bits);\n}\n\n\nLOCAL(void)\ncompress_init(gif_dest_ptr dinfo, int i_bits)\n/* Initialize compressor */\n{\n  /* init all the state variables */\n  dinfo->n_bits = dinfo->init_bits = i_bits;\n  dinfo->maxcode = MAXCODE(dinfo->n_bits);\n  dinfo->ClearCode = ((code_int) 1 << (i_bits - 1));\n  dinfo->EOFCode = dinfo->ClearCode + 1;\n  dinfo->code_counter = dinfo->free_code = dinfo->ClearCode + 2;\n  dinfo->first_byte = TRUE;     /* no waiting symbol yet */\n  /* init output buffering vars */\n  dinfo->bytesinpkt = 0;\n  dinfo->cur_accum = 0;\n  dinfo->cur_bits = 0;\n  /* clear hash table */\n  if (dinfo->hash_code != NULL)\n    clear_hash(dinfo);\n  /* GIF specifies an initial Clear code */\n  output(dinfo, dinfo->ClearCode);\n}\n\n\nLOCAL(void)\ncompress_term(gif_dest_ptr dinfo)\n/* Clean up at end */\n{\n  /* Flush out the buffered LZW code */\n  if (!dinfo->first_byte)\n    output(dinfo, dinfo->waiting_code);\n  /* Send an EOF code */\n  output(dinfo, dinfo->EOFCode);\n  /* Flush the bit-packing buffer */\n  if (dinfo->cur_bits > 0) {\n    CHAR_OUT(dinfo, dinfo->cur_accum & 0xFF);\n  }\n  /* Flush the packet buffer */\n  flush_packet(dinfo);\n}\n\n\n/* GIF header construction */\n\n\nLOCAL(void)\nput_word(gif_dest_ptr dinfo, unsigned int w)\n/* Emit a 16-bit word, LSB first */\n{\n  putc(w & 0xFF, dinfo->pub.output_file);\n  putc((w >> 8) & 0xFF, dinfo->pub.output_file);\n}\n\n\nLOCAL(void)\nput_3bytes(gif_dest_ptr dinfo, int val)\n/* Emit 3 copies of same byte value --- handy subr for colormap construction */\n{\n  putc(val, dinfo->pub.output_file);\n  putc(val, dinfo->pub.output_file);\n  putc(val, dinfo->pub.output_file);\n}\n\n\nLOCAL(void)\nemit_header(gif_dest_ptr dinfo, int num_colors, _JSAMPARRAY colormap)\n/* Output the GIF file header, including color map */\n/* If colormap == NULL, synthesize a grayscale colormap */\n{\n  int BitsPerPixel, ColorMapSize, InitCodeSize, FlagByte;\n  int cshift = dinfo->cinfo->data_precision - 8;\n  int i;\n\n  if (num_colors > 256)\n    ERREXIT1(dinfo->cinfo, JERR_TOO_MANY_COLORS, num_colors);\n  /* Compute bits/pixel and related values */\n  BitsPerPixel = 1;\n  while (num_colors > (1 << BitsPerPixel))\n    BitsPerPixel++;\n  ColorMapSize = 1 << BitsPerPixel;\n  if (BitsPerPixel <= 1)\n    InitCodeSize = 2;\n  else\n    InitCodeSize = BitsPerPixel;\n  /*\n   * Write the GIF header.\n   * Note that we generate a plain GIF87 header for maximum compatibility.\n   */\n  putc('G', dinfo->pub.output_file);\n  putc('I', dinfo->pub.output_file);\n  putc('F', dinfo->pub.output_file);\n  putc('8', dinfo->pub.output_file);\n  putc('7', dinfo->pub.output_file);\n  putc('a', dinfo->pub.output_file);\n  /* Write the Logical Screen Descriptor */\n  put_word(dinfo, (unsigned int)dinfo->cinfo->output_width);\n  put_word(dinfo, (unsigned int)dinfo->cinfo->output_height);\n  FlagByte = 0x80;              /* Yes, there is a global color table */\n  FlagByte |= (BitsPerPixel - 1) << 4; /* color resolution */\n  FlagByte |= (BitsPerPixel - 1); /* size of global color table */\n  putc(FlagByte, dinfo->pub.output_file);\n  putc(0, dinfo->pub.output_file); /* Background color index */\n  putc(0, dinfo->pub.output_file); /* Reserved (aspect ratio in GIF89) */\n  /* Write the Global Color Map */\n  /* If the color map is more than 8 bits precision, */\n  /* we reduce it to 8 bits by shifting */\n  for (i = 0; i < ColorMapSize; i++) {\n    if (i < num_colors) {\n      if (colormap != NULL) {\n        if (dinfo->cinfo->out_color_space == JCS_RGB) {\n          /* Normal case: RGB color map */\n          putc(colormap[0][i] >> cshift, dinfo->pub.output_file);\n          putc(colormap[1][i] >> cshift, dinfo->pub.output_file);\n          putc(colormap[2][i] >> cshift, dinfo->pub.output_file);\n        } else {\n          /* Grayscale \"color map\": possible if quantizing grayscale image */\n          put_3bytes(dinfo, colormap[0][i] >> cshift);\n        }\n      } else {\n        /* Create a grayscale map of num_colors values, range 0..255 */\n        put_3bytes(dinfo, (i * 255 + (num_colors - 1) / 2) / (num_colors - 1));\n      }\n    } else {\n      /* fill out the map to a power of 2 */\n      put_3bytes(dinfo, _CENTERJSAMPLE >> cshift);\n    }\n  }\n  /* Write image separator and Image Descriptor */\n  putc(',', dinfo->pub.output_file); /* separator */\n  put_word(dinfo, 0);           /* left/top offset */\n  put_word(dinfo, 0);\n  put_word(dinfo, (unsigned int)dinfo->cinfo->output_width); /* image size */\n  put_word(dinfo, (unsigned int)dinfo->cinfo->output_height);\n  /* flag byte: not interlaced, no local color map */\n  putc(0x00, dinfo->pub.output_file);\n  /* Write Initial Code Size byte */\n  putc(InitCodeSize, dinfo->pub.output_file);\n\n  /* Initialize for compression of image data */\n  compress_init(dinfo, InitCodeSize + 1);\n}\n\n\n/*\n * Startup: write the file header.\n */\n\nMETHODDEF(void)\nstart_output_gif(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  gif_dest_ptr dest = (gif_dest_ptr)dinfo;\n\n  if (cinfo->quantize_colors)\n    emit_header(dest, cinfo->actual_number_of_colors,\n                (_JSAMPARRAY)cinfo->colormap);\n  else\n    emit_header(dest, 256, (_JSAMPARRAY)NULL);\n}\n\n\n/*\n * Write some pixel data.\n * In this module rows_supplied will always be 1.\n */\n\n\n/*\n * The LZW algorithm proper\n */\n\nMETHODDEF(void)\nput_LZW_pixel_rows(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n                   JDIMENSION rows_supplied)\n{\n  gif_dest_ptr dest = (gif_dest_ptr)dinfo;\n  register _JSAMPROW ptr;\n  register JDIMENSION col;\n  code_int c;\n  register hash_int i;\n  register hash_int disp;\n  register hash_entry probe_value;\n\n  ptr = dest->pub._buffer[0];\n  for (col = cinfo->output_width; col > 0; col--) {\n    /* Accept and compress one 8-bit byte */\n    c = (code_int)(*ptr++);\n\n    if (dest->first_byte) {     /* need to initialize waiting_code */\n      dest->waiting_code = c;\n      dest->first_byte = FALSE;\n      continue;\n    }\n\n    /* Probe hash table to see if a symbol exists for\n     * waiting_code followed by c.\n     * If so, replace waiting_code by that symbol and continue.\n     */\n    i = ((hash_int)c << (MAX_LZW_BITS - 8)) + dest->waiting_code;\n    /* i is less than twice 2**MAX_LZW_BITS, therefore less than twice HSIZE */\n    if (i >= HSIZE)\n      i -= HSIZE;\n\n    probe_value = HASH_ENTRY(dest->waiting_code, c);\n\n    if (dest->hash_code[i] == 0) {\n      /* hit empty slot; desired symbol not in table */\n      output(dest, dest->waiting_code);\n      if (dest->free_code < LZW_TABLE_SIZE) {\n        dest->hash_code[i] = dest->free_code++; /* add symbol to hashtable */\n        dest->hash_value[i] = probe_value;\n      } else\n        clear_block(dest);\n      dest->waiting_code = c;\n      continue;\n    }\n    if (dest->hash_value[i] == probe_value) {\n      dest->waiting_code = dest->hash_code[i];\n      continue;\n    }\n\n    if (i == 0)                 /* secondary hash (after G. Knott) */\n      disp = 1;\n    else\n      disp = HSIZE - i;\n    for (;;) {\n      i -= disp;\n      if (i < 0)\n        i += HSIZE;\n      if (dest->hash_code[i] == 0) {\n        /* hit empty slot; desired symbol not in table */\n        output(dest, dest->waiting_code);\n        if (dest->free_code < LZW_TABLE_SIZE) {\n          dest->hash_code[i] = dest->free_code++; /* add symbol to hashtable */\n          dest->hash_value[i] = probe_value;\n        } else\n          clear_block(dest);\n        dest->waiting_code = c;\n        break;\n      }\n      if (dest->hash_value[i] == probe_value) {\n        dest->waiting_code = dest->hash_code[i];\n        break;\n      }\n    }\n  }\n}\n\n\n/*\n * The pseudo-compression algorithm.\n *\n * In this version we simply output each pixel value as a separate symbol;\n * thus, no compression occurs.  In fact, there is expansion of one bit per\n * pixel, because we use a symbol width one bit wider than the pixel width.\n *\n * GIF ordinarily uses variable-width symbols, and the decoder will expect\n * to ratchet up the symbol width after a fixed number of symbols.\n * To simplify the logic and keep the expansion penalty down, we emit a\n * GIF Clear code to reset the decoder just before the width would ratchet up.\n * Thus, all the symbols in the output file will have the same bit width.\n * Note that emitting the Clear codes at the right times is a mere matter of\n * counting output symbols and is in no way dependent on the LZW algorithm.\n *\n * With a small basic pixel width (low color count), Clear codes will be\n * needed very frequently, causing the file to expand even more.  So this\n * simplistic approach wouldn't work too well on bilevel images, for example.\n * But for output of JPEG conversions the pixel width will usually be 8 bits\n * (129 to 256 colors), so the overhead added by Clear symbols is only about\n * one symbol in every 256.\n */\n\nMETHODDEF(void)\nput_raw_pixel_rows(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n                   JDIMENSION rows_supplied)\n{\n  gif_dest_ptr dest = (gif_dest_ptr)dinfo;\n  register _JSAMPROW ptr;\n  register JDIMENSION col;\n  code_int c;\n\n  ptr = dest->pub._buffer[0];\n  for (col = cinfo->output_width; col > 0; col--) {\n    c = (code_int)(*ptr++);\n    /* Accept and output one pixel value.\n     * The given value must be less than n_bits wide.\n     */\n\n    /* Output the given pixel value as a symbol. */\n    output(dest, c);\n    /* Issue Clear codes often enough to keep the reader from ratcheting up\n     * its symbol size.\n     */\n    if (dest->code_counter < dest->maxcode) {\n      dest->code_counter++;\n    } else {\n      output(dest, dest->ClearCode);\n      dest->code_counter = dest->ClearCode + 2; /* reset the counter */\n    }\n  }\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_output_gif(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  gif_dest_ptr dest = (gif_dest_ptr)dinfo;\n\n  /* Flush compression mechanism */\n  compress_term(dest);\n  /* Write a zero-length data block to end the series */\n  putc(0, dest->pub.output_file);\n  /* Write the GIF terminator mark */\n  putc(';', dest->pub.output_file);\n  /* Make sure we wrote the output file OK */\n  fflush(dest->pub.output_file);\n  if (ferror(dest->pub.output_file))\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n}\n\n\n/*\n * Re-calculate buffer dimensions based on output dimensions.\n */\n\nMETHODDEF(void)\ncalc_buffer_dimensions_gif(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n}\n\n\n/*\n * The module selection routine for GIF format output.\n */\n\nGLOBAL(djpeg_dest_ptr)\n_jinit_write_gif(j_decompress_ptr cinfo, boolean is_lzw)\n{\n  gif_dest_ptr dest;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Create module interface object, fill in method pointers */\n  dest = (gif_dest_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(gif_dest_struct));\n  dest->cinfo = cinfo;          /* make back link for subroutines */\n  dest->pub.start_output = start_output_gif;\n  dest->pub.finish_output = finish_output_gif;\n  dest->pub.calc_buffer_dimensions = calc_buffer_dimensions_gif;\n\n  if (cinfo->out_color_space != JCS_GRAYSCALE &&\n      cinfo->out_color_space != JCS_RGB)\n    ERREXIT(cinfo, JERR_GIF_COLORSPACE);\n\n  /* Force quantization if color or if > 8 bits input */\n  if (cinfo->out_color_space != JCS_GRAYSCALE || cinfo->data_precision > 8) {\n    /* Force quantization to at most 256 colors */\n    cinfo->quantize_colors = TRUE;\n    if (cinfo->desired_number_of_colors > 256)\n      cinfo->desired_number_of_colors = 256;\n  }\n\n  /* Calculate output image dimensions so we can allocate space */\n  jpeg_calc_output_dimensions(cinfo);\n\n  if (cinfo->output_components != 1) /* safety check: just one component? */\n    ERREXIT(cinfo, JERR_GIF_BUG);\n\n  /* Create decompressor output buffer. */\n  dest->pub._buffer = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE, cinfo->output_width, (JDIMENSION)1);\n  dest->pub.buffer_height = 1;\n\n  if (is_lzw) {\n    dest->pub.put_pixel_rows = put_LZW_pixel_rows;\n    /* Allocate space for hash table */\n    dest->hash_code = (code_int *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  HSIZE * sizeof(code_int));\n    dest->hash_value = (hash_entry *)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  HSIZE * sizeof(hash_entry));\n  } else {\n    dest->pub.put_pixel_rows = put_raw_pixel_rows;\n    /* Mark tables unused */\n    dest->hash_code = NULL;\n    dest->hash_value = NULL;\n  }\n\n  return (djpeg_dest_ptr)dest;\n}\n\n#endif /* defined(GIF_SUPPORTED) && BITS_IN_JSAMPLE != 16 */\n"
        },
        {
          "name": "wrjpgcom.1",
          "type": "blob",
          "size": 2.564453125,
          "content": ".TH WRJPGCOM 1 \"15 June 1995\"\n.SH NAME\nwrjpgcom \\- insert text comments into a JPEG file\n.SH SYNOPSIS\n.B wrjpgcom\n[\n.B \\-replace\n]\n[\n.BI \\-comment \" text\"\n]\n[\n.BI \\-cfile \" name\"\n]\n[\n.I filename\n]\n.LP\n.SH DESCRIPTION\n.LP\n.B wrjpgcom\nreads the named JPEG/JFIF file, or the standard input if no file is named,\nand generates a new JPEG/JFIF file on standard output.  A comment block is\nadded to the file.\n.PP\nThe JPEG standard allows \"comment\" (COM) blocks to occur within a JPEG file.\nAlthough the standard doesn't actually define what COM blocks are for, they\nare widely used to hold user-supplied text strings.  This lets you add\nannotations, titles, index terms, etc to your JPEG files, and later retrieve\nthem as text.  COM blocks do not interfere with the image stored in the JPEG\nfile.  The maximum size of a COM block is 64K, but you can have as many of\nthem as you like in one JPEG file.\n.PP\n.B wrjpgcom\nadds a COM block, containing text you provide, to a JPEG file.\nOrdinarily, the COM block is added after any existing COM blocks; but you\ncan delete the old COM blocks if you wish.\n.SH OPTIONS\nSwitch names may be abbreviated, and are not case sensitive.\n.TP\n.B \\-replace\nDelete any existing COM blocks from the file.\n.TP\n.BI \\-comment \" text\"\nSupply text for new COM block on command line.\n.TP\n.BI \\-cfile \" name\"\nRead text for new COM block from named file.\n.PP\nIf you have only one line of comment text to add, you can provide it on the\ncommand line with\n.BR \\-comment .\nThe comment text must be surrounded with quotes so that it is treated as a\nsingle argument.  Longer comments can be read from a text file.\n.PP\nIf you give neither\n.B \\-comment\nnor\n.BR \\-cfile,\nthen\n.B wrjpgcom\nwill read the comment text from standard input.  (In this case an input image\nfile name MUST be supplied, so that the source JPEG file comes from somewhere\nelse.)  You can enter multiple lines, up to 64KB worth.  Type an end-of-file\nindicator (usually control-D) to terminate the comment text entry.\n.PP\n.B wrjpgcom\nwill not add a COM block if the provided comment string is empty.  Therefore\n\\fB\\-replace \\-comment \"\"\\fR can be used to delete all COM blocks from a file.\n.SH EXAMPLES\n.LP\nAdd a short comment to in.jpg, producing out.jpg:\n.IP\n.B wrjpgcom \\-c\n\\fI\"View of my back yard\" in.jpg\n.B >\n.I out.jpg\n.PP\nAttach a long comment previously stored in comment.txt:\n.IP\n.B wrjpgcom\n.I in.jpg\n.B <\n.I comment.txt\n.B >\n.I out.jpg\n.PP\nor equivalently\n.IP\n.B wrjpgcom\n.B -cfile\n.I comment.txt\n.B <\n.I in.jpg\n.B >\n.I out.jpg\n.SH SEE ALSO\n.BR cjpeg (1),\n.BR djpeg (1),\n.BR jpegtran (1),\n.BR rdjpgcom (1)\n.SH AUTHOR\nIndependent JPEG Group\n"
        },
        {
          "name": "wrjpgcom.c",
          "type": "blob",
          "size": 17.0546875,
          "content": "/*\n * wrjpgcom.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1994-1997, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2014, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains a very simple stand-alone application that inserts\n * user-supplied text as a COM (comment) marker in a JFIF file.\n * This may be useful as an example of the minimum logic needed to parse\n * JPEG markers.\n */\n\n#ifdef _MSC_VER\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#define JPEG_CJPEG_DJPEG        /* to get the command-line config symbols */\n#include \"jinclude.h\"           /* get auto-config symbols, <stdio.h> */\n\n#include <ctype.h>              /* to declare isupper(), tolower() */\n#ifdef USE_SETMODE\n#include <fcntl.h>              /* to declare setmode()'s parameter macros */\n/* If you have setmode() but not <io.h>, just delete this line: */\n#include <io.h>                 /* to declare setmode() */\n#endif\n\n#ifdef DONT_USE_B_MODE          /* define mode parameters for fopen() */\n#define READ_BINARY     \"r\"\n#define WRITE_BINARY    \"w\"\n#else\n#define READ_BINARY     \"rb\"\n#define WRITE_BINARY    \"wb\"\n#endif\n\n#ifndef EXIT_FAILURE            /* define exit() codes if not provided */\n#define EXIT_FAILURE  1\n#endif\n#ifndef EXIT_SUCCESS\n#define EXIT_SUCCESS  0\n#endif\n\n/* Reduce this value if your malloc() can't allocate blocks up to 64K.\n * On DOS, compiling in large model is usually a better solution.\n */\n\n#ifndef MAX_COM_LENGTH\n#define MAX_COM_LENGTH  65000L  /* must be <= 65533 in any case */\n#endif\n\n\n/*\n * These macros are used to read the input file and write the output file.\n * To reuse this code in another application, you might need to change these.\n */\n\nstatic FILE *infile;            /* input JPEG file */\n\n/* Return next input byte, or EOF if no more */\n#define NEXTBYTE()  getc(infile)\n\nstatic FILE *outfile;           /* output JPEG file */\n\n/* Emit an output byte */\n#define PUTBYTE(x)  putc((x), outfile)\n\n\n/* Error exit handler */\n#define ERREXIT(msg)  (fprintf(stderr, \"%s\\n\", msg), exit(EXIT_FAILURE))\n\n\n/* Read one byte, testing for EOF */\nstatic int\nread_1_byte(void)\n{\n  int c;\n\n  c = NEXTBYTE();\n  if (c == EOF)\n    ERREXIT(\"Premature EOF in JPEG file\");\n  return c;\n}\n\n/* Read 2 bytes, convert to unsigned int */\n/* All 2-byte quantities in JPEG markers are MSB first */\nstatic unsigned int\nread_2_bytes(void)\n{\n  int c1, c2;\n\n  c1 = NEXTBYTE();\n  if (c1 == EOF)\n    ERREXIT(\"Premature EOF in JPEG file\");\n  c2 = NEXTBYTE();\n  if (c2 == EOF)\n    ERREXIT(\"Premature EOF in JPEG file\");\n  return (((unsigned int)c1) << 8) + ((unsigned int)c2);\n}\n\n\n/* Routines to write data to output file */\n\nstatic void\nwrite_1_byte(int c)\n{\n  PUTBYTE(c);\n}\n\nstatic void\nwrite_2_bytes(unsigned int val)\n{\n  PUTBYTE((val >> 8) & 0xFF);\n  PUTBYTE(val & 0xFF);\n}\n\nstatic void\nwrite_marker(int marker)\n{\n  PUTBYTE(0xFF);\n  PUTBYTE(marker);\n}\n\nstatic void\ncopy_rest_of_file(void)\n{\n  int c;\n\n  while ((c = NEXTBYTE()) != EOF)\n    PUTBYTE(c);\n}\n\n\n/*\n * JPEG markers consist of one or more 0xFF bytes, followed by a marker\n * code byte (which is not an FF).  Here are the marker codes of interest\n * in this program.  (See jdmarker.c for a more complete list.)\n */\n\n#define M_SOF0   0xC0           /* Start Of Frame N */\n#define M_SOF1   0xC1           /* N indicates which compression process */\n#define M_SOF2   0xC2           /* Only SOF0-SOF2 are now in common use */\n#define M_SOF3   0xC3\n#define M_SOF5   0xC5           /* NB: codes C4 and CC are NOT SOF markers */\n#define M_SOF6   0xC6\n#define M_SOF7   0xC7\n#define M_SOF9   0xC9\n#define M_SOF10  0xCA\n#define M_SOF11  0xCB\n#define M_SOF13  0xCD\n#define M_SOF14  0xCE\n#define M_SOF15  0xCF\n#define M_SOI    0xD8           /* Start Of Image (beginning of datastream) */\n#define M_EOI    0xD9           /* End Of Image (end of datastream) */\n#define M_SOS    0xDA           /* Start Of Scan (begins compressed data) */\n#define M_COM    0xFE           /* COMment */\n\n\n/*\n * Find the next JPEG marker and return its marker code.\n * We expect at least one FF byte, possibly more if the compressor used FFs\n * to pad the file.  (Padding FFs will NOT be replicated in the output file.)\n * There could also be non-FF garbage between markers.  The treatment of such\n * garbage is unspecified; we choose to skip over it but emit a warning msg.\n * NB: this routine must not be used after seeing SOS marker, since it will\n * not deal correctly with FF/00 sequences in the compressed image data...\n */\n\nstatic int\nnext_marker(void)\n{\n  int c;\n  int discarded_bytes = 0;\n\n  /* Find 0xFF byte; count and skip any non-FFs. */\n  c = read_1_byte();\n  while (c != 0xFF) {\n    discarded_bytes++;\n    c = read_1_byte();\n  }\n  /* Get marker code byte, swallowing any duplicate FF bytes.  Extra FFs\n   * are legal as pad bytes, so don't count them in discarded_bytes.\n   */\n  do {\n    c = read_1_byte();\n  } while (c == 0xFF);\n\n  if (discarded_bytes != 0) {\n    fprintf(stderr, \"Warning: garbage data found in JPEG file\\n\");\n  }\n\n  return c;\n}\n\n\n/*\n * Read the initial marker, which should be SOI.\n * For a JFIF file, the first two bytes of the file should be literally\n * 0xFF M_SOI.  To be more general, we could use next_marker, but if the\n * input file weren't actually JPEG at all, next_marker might read the whole\n * file and then return a misleading error message...\n */\n\nstatic int\nfirst_marker(void)\n{\n  int c1, c2;\n\n  c1 = NEXTBYTE();\n  c2 = NEXTBYTE();\n  if (c1 != 0xFF || c2 != M_SOI)\n    ERREXIT(\"Not a JPEG file\");\n  return c2;\n}\n\n\n/*\n * Most types of marker are followed by a variable-length parameter segment.\n * This routine skips over the parameters for any marker we don't otherwise\n * want to process.\n * Note that we MUST skip the parameter segment explicitly in order not to\n * be fooled by 0xFF bytes that might appear within the parameter segment;\n * such bytes do NOT introduce new markers.\n */\n\nstatic void\ncopy_variable(void)\n/* Copy an unknown or uninteresting variable-length marker */\n{\n  unsigned int length;\n\n  /* Get the marker parameter length count */\n  length = read_2_bytes();\n  write_2_bytes(length);\n  /* Length includes itself, so must be at least 2 */\n  if (length < 2)\n    ERREXIT(\"Erroneous JPEG marker length\");\n  length -= 2;\n  /* Copy the remaining bytes */\n  while (length > 0) {\n    write_1_byte(read_1_byte());\n    length--;\n  }\n}\n\nstatic void\nskip_variable(void)\n/* Skip over an unknown or uninteresting variable-length marker */\n{\n  unsigned int length;\n\n  /* Get the marker parameter length count */\n  length = read_2_bytes();\n  /* Length includes itself, so must be at least 2 */\n  if (length < 2)\n    ERREXIT(\"Erroneous JPEG marker length\");\n  length -= 2;\n  /* Skip over the remaining bytes */\n  while (length > 0) {\n    (void)read_1_byte();\n    length--;\n  }\n}\n\n\n/*\n * Parse the marker stream until SOFn or EOI is seen;\n * copy data to output, but discard COM markers unless keep_COM is true.\n */\n\nstatic int\nscan_JPEG_header(int keep_COM)\n{\n  int marker;\n\n  /* Expect SOI at start of file */\n  if (first_marker() != M_SOI)\n    ERREXIT(\"Expected SOI marker first\");\n  write_marker(M_SOI);\n\n  /* Scan miscellaneous markers until we reach SOFn. */\n  for (;;) {\n    marker = next_marker();\n    switch (marker) {\n      /* Note that marker codes 0xC4, 0xC8, 0xCC are not, and must not be,\n       * treated as SOFn.  C4 in particular is actually DHT.\n       */\n    case M_SOF0:                /* Baseline */\n    case M_SOF1:                /* Extended sequential, Huffman */\n    case M_SOF2:                /* Progressive, Huffman */\n    case M_SOF3:                /* Lossless, Huffman */\n    case M_SOF5:                /* Differential sequential, Huffman */\n    case M_SOF6:                /* Differential progressive, Huffman */\n    case M_SOF7:                /* Differential lossless, Huffman */\n    case M_SOF9:                /* Extended sequential, arithmetic */\n    case M_SOF10:               /* Progressive, arithmetic */\n    case M_SOF11:               /* Lossless, arithmetic */\n    case M_SOF13:               /* Differential sequential, arithmetic */\n    case M_SOF14:               /* Differential progressive, arithmetic */\n    case M_SOF15:               /* Differential lossless, arithmetic */\n      return marker;\n\n    case M_SOS:                 /* should not see compressed data before SOF */\n      ERREXIT(\"SOS without prior SOFn\");\n      break;\n\n    case M_EOI:                 /* in case it's a tables-only JPEG stream */\n      return marker;\n\n    case M_COM:                 /* Existing COM: conditionally discard */\n      if (keep_COM) {\n        write_marker(marker);\n        copy_variable();\n      } else {\n        skip_variable();\n      }\n      break;\n\n    default:                    /* Anything else just gets copied */\n      write_marker(marker);\n      copy_variable();          /* we assume it has a parameter count... */\n      break;\n    }\n  } /* end loop */\n}\n\n\n/* Command line parsing code */\n\nstatic const char *progname;    /* program name for error messages */\n\n\nstatic void\nusage(void)\n/* complain about bad command line */\n{\n  fprintf(stderr, \"wrjpgcom inserts a textual comment in a JPEG file.\\n\");\n  fprintf(stderr, \"You can add to or replace any existing comment(s).\\n\");\n\n  fprintf(stderr, \"Usage: %s [switches] \", progname);\n#ifdef TWO_FILE_COMMANDLINE\n  fprintf(stderr, \"inputfile outputfile\\n\");\n#else\n  fprintf(stderr, \"[inputfile]\\n\");\n#endif\n\n  fprintf(stderr, \"Switches (names may be abbreviated):\\n\");\n  fprintf(stderr, \"  -replace         Delete any existing comments\\n\");\n  fprintf(stderr, \"  -comment \\\"text\\\"  Insert comment with given text\\n\");\n  fprintf(stderr, \"  -cfile name      Read comment from named file\\n\");\n  fprintf(stderr, \"Notice that you must put quotes around the comment text\\n\");\n  fprintf(stderr, \"when you use -comment.\\n\");\n  fprintf(stderr, \"If you do not give either -comment or -cfile on the command line,\\n\");\n  fprintf(stderr, \"then the comment text is read from standard input.\\n\");\n  fprintf(stderr, \"It can be multiple lines, up to %u characters total.\\n\",\n          (unsigned int)MAX_COM_LENGTH);\n#ifndef TWO_FILE_COMMANDLINE\n  fprintf(stderr, \"You must specify an input JPEG file name when supplying\\n\");\n  fprintf(stderr, \"comment text from standard input.\\n\");\n#endif\n\n  exit(EXIT_FAILURE);\n}\n\n\nstatic int\nkeymatch(char *arg, const char *keyword, int minchars)\n/* Case-insensitive matching of (possibly abbreviated) keyword switches. */\n/* keyword is the constant keyword (must be lower case already), */\n/* minchars is length of minimum legal abbreviation. */\n{\n  register int ca, ck;\n  register int nmatched = 0;\n\n  while ((ca = *arg++) != '\\0') {\n    if ((ck = *keyword++) == '\\0')\n      return 0;                 /* arg longer than keyword, no good */\n    if (isupper(ca))            /* force arg to lcase (assume ck is already) */\n      ca = tolower(ca);\n    if (ca != ck)\n      return 0;                 /* no good */\n    nmatched++;                 /* count matched characters */\n  }\n  /* reached end of argument; fail if it's too short for unique abbrev */\n  if (nmatched < minchars)\n    return 0;\n  return 1;                     /* A-OK */\n}\n\n\n/*\n * The main program.\n */\n\nint\nmain(int argc, char **argv)\n{\n  int argn;\n  char *arg;\n  int keep_COM = 1;\n  char *comment_arg = NULL;\n  FILE *comment_file = NULL;\n  unsigned int comment_length = 0;\n  int marker;\n\n  progname = argv[0];\n  if (progname == NULL || progname[0] == 0)\n    progname = \"wrjpgcom\";      /* in case C library doesn't provide it */\n\n  /* Parse switches, if any */\n  for (argn = 1; argn < argc; argn++) {\n    arg = argv[argn];\n    if (arg[0] != '-')\n      break;                    /* not switch, must be file name */\n    arg++;                      /* advance over '-' */\n    if (keymatch(arg, \"replace\", 1)) {\n      keep_COM = 0;\n    } else if (keymatch(arg, \"cfile\", 2)) {\n      if (++argn >= argc) usage();\n      if ((comment_file = fopen(argv[argn], \"r\")) == NULL) {\n        fprintf(stderr, \"%s: can't open %s\\n\", progname, argv[argn]);\n        exit(EXIT_FAILURE);\n      }\n    } else if (keymatch(arg, \"comment\", 1)) {\n      if (++argn >= argc) usage();\n      comment_arg = argv[argn];\n      /* If the comment text starts with '\"', then we are probably running\n       * under MS-DOG and must parse out the quoted string ourselves.  Sigh.\n       */\n      if (comment_arg[0] == '\"') {\n        comment_arg = (char *)malloc((size_t)MAX_COM_LENGTH);\n        if (comment_arg == NULL)\n          ERREXIT(\"Insufficient memory\");\n        if (strlen(argv[argn]) + 2 >= (size_t)MAX_COM_LENGTH) {\n          fprintf(stderr, \"Comment text may not exceed %u bytes\\n\",\n                  (unsigned int)MAX_COM_LENGTH);\n          exit(EXIT_FAILURE);\n        }\n        strcpy(comment_arg, argv[argn] + 1);\n        for (;;) {\n          comment_length = (unsigned int)strlen(comment_arg);\n          if (comment_length > 0 && comment_arg[comment_length - 1] == '\"') {\n            comment_arg[comment_length - 1] = '\\0'; /* zap terminating quote */\n            break;\n          }\n          if (++argn >= argc)\n            ERREXIT(\"Missing ending quote mark\");\n          if (strlen(comment_arg) + strlen(argv[argn]) + 2 >=\n              (size_t)MAX_COM_LENGTH) {\n            fprintf(stderr, \"Comment text may not exceed %u bytes\\n\",\n                    (unsigned int)MAX_COM_LENGTH);\n            exit(EXIT_FAILURE);\n          }\n          strcat(comment_arg, \" \");\n          strcat(comment_arg, argv[argn]);\n        }\n      } else if (strlen(argv[argn]) >= (size_t)MAX_COM_LENGTH) {\n        fprintf(stderr, \"Comment text may not exceed %u bytes\\n\",\n                (unsigned int)MAX_COM_LENGTH);\n        exit(EXIT_FAILURE);\n      }\n      comment_length = (unsigned int)strlen(comment_arg);\n    } else\n      usage();\n  }\n\n  /* Cannot use both -comment and -cfile. */\n  if (comment_arg != NULL && comment_file != NULL)\n    usage();\n  /* If there is neither -comment nor -cfile, we will read the comment text\n   * from stdin; in this case there MUST be an input JPEG file name.\n   */\n  if (comment_arg == NULL && comment_file == NULL && argn >= argc)\n    usage();\n\n  /* Open the input file. */\n  if (argn < argc) {\n    if ((infile = fopen(argv[argn], READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open %s\\n\", progname, argv[argn]);\n      exit(EXIT_FAILURE);\n    }\n  } else {\n    /* default input file is stdin */\n#ifdef USE_SETMODE              /* need to hack file mode? */\n    setmode(fileno(stdin), O_BINARY);\n#endif\n#ifdef USE_FDOPEN               /* need to re-open in binary mode? */\n    if ((infile = fdopen(fileno(stdin), READ_BINARY)) == NULL) {\n      fprintf(stderr, \"%s: can't open stdin\\n\", progname);\n      exit(EXIT_FAILURE);\n    }\n#else\n    infile = stdin;\n#endif\n  }\n\n  /* Open the output file. */\n#ifdef TWO_FILE_COMMANDLINE\n  /* Must have explicit output file name */\n  if (argn != argc - 2) {\n    fprintf(stderr, \"%s: must name one input and one output file\\n\", progname);\n    usage();\n  }\n  if ((outfile = fopen(argv[argn + 1], WRITE_BINARY)) == NULL) {\n    fprintf(stderr, \"%s: can't open %s\\n\", progname, argv[argn + 1]);\n    exit(EXIT_FAILURE);\n  }\n#else\n  /* Unix style: expect zero or one file name */\n  if (argn < argc - 1) {\n    fprintf(stderr, \"%s: only one input file\\n\", progname);\n    usage();\n  }\n  /* default output file is stdout */\n#ifdef USE_SETMODE              /* need to hack file mode? */\n  setmode(fileno(stdout), O_BINARY);\n#endif\n#ifdef USE_FDOPEN               /* need to re-open in binary mode? */\n  if ((outfile = fdopen(fileno(stdout), WRITE_BINARY)) == NULL) {\n    fprintf(stderr, \"%s: can't open stdout\\n\", progname);\n    exit(EXIT_FAILURE);\n  }\n#else\n  outfile = stdout;\n#endif\n#endif /* TWO_FILE_COMMANDLINE */\n\n  /* Collect comment text from comment_file or stdin, if necessary */\n  if (comment_arg == NULL) {\n    FILE *src_file;\n    int c;\n\n    comment_arg = (char *)malloc((size_t)MAX_COM_LENGTH);\n    if (comment_arg == NULL)\n      ERREXIT(\"Insufficient memory\");\n    comment_length = 0;\n    src_file = (comment_file != NULL ? comment_file : stdin);\n    while ((c = getc(src_file)) != EOF) {\n      if (comment_length >= (unsigned int)MAX_COM_LENGTH) {\n        fprintf(stderr, \"Comment text may not exceed %u bytes\\n\",\n                (unsigned int)MAX_COM_LENGTH);\n        exit(EXIT_FAILURE);\n      }\n      comment_arg[comment_length++] = (char)c;\n    }\n    if (comment_file != NULL)\n      fclose(comment_file);\n  }\n\n  /* Copy JPEG headers until SOFn marker;\n   * we will insert the new comment marker just before SOFn.\n   * This (a) causes the new comment to appear after, rather than before,\n   * existing comments; and (b) ensures that comments come after any JFIF\n   * or JFXX markers, as required by the JFIF specification.\n   */\n  marker = scan_JPEG_header(keep_COM);\n  /* Insert the new COM marker, but only if nonempty text has been supplied */\n  if (comment_length > 0) {\n    write_marker(M_COM);\n    write_2_bytes(comment_length + 2);\n    while (comment_length > 0) {\n      write_1_byte(*comment_arg++);\n      comment_length--;\n    }\n  }\n  /* Duplicate the remainder of the source file.\n   * Note that any COM markers occurring after SOF will not be touched.\n   */\n  write_marker(marker);\n  copy_rest_of_file();\n\n  /* All done. */\n  exit(EXIT_SUCCESS);\n  return 0;                     /* suppress no-return-value warnings */\n}\n"
        },
        {
          "name": "wrppm.c",
          "type": "blob",
          "size": 10.9375,
          "content": "/*\n * wrppm.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * Modified 2009 by Guido Vollbeding.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2017, 2019-2020, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to write output images in PPM/PGM format.\n * The extended 2-byte-per-sample raw PPM/PGM formats are supported.\n * The PBMPLUS library is NOT required to compile this software\n * (but it is highly useful as a set of PPM image manipulation programs).\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume output to\n * an ordinary stdio stream.\n */\n\n#include \"cmyk.h\"\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n\n#if defined(PPM_SUPPORTED) && \\\n    (BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED))\n\n\n/*\n * For 12-bit JPEG data, we either downscale the values to 8 bits\n * (to write standard byte-per-sample PPM/PGM files), or output\n * nonstandard word-per-sample PPM/PGM files.  Downscaling is done\n * if PPM_NORAWWORD is defined (this can be done in the Makefile\n * or in jconfig.h).\n * (When the core library supports data precision reduction, a cleaner\n * implementation will be to ask for that instead.)\n */\n\n#if BITS_IN_JSAMPLE == 8\n#define PUTPPMSAMPLE(ptr, v)  *ptr++ = (char)(v)\n#define BYTESPERSAMPLE  1\n#define PPM_MAXVAL  255\n#else\n#ifdef PPM_NORAWWORD\n#define PUTPPMSAMPLE(ptr, v)  *ptr++ = (char)((v) >> (BITS_IN_JSAMPLE - 8))\n#define BYTESPERSAMPLE  1\n#define PPM_MAXVAL  255\n#else\n/* The word-per-sample format always puts the MSB first. */\n#define PUTPPMSAMPLE(ptr, v) { \\\n  register int val_ = v; \\\n  *ptr++ = (char)((val_ >> 8) & 0xFF); \\\n  *ptr++ = (char)(val_ & 0xFF); \\\n}\n#define BYTESPERSAMPLE  2\n#define PPM_MAXVAL  ((1 << BITS_IN_JSAMPLE) - 1)\n#endif\n#endif\n\n\n/*\n * When _JSAMPLE is the same size as char, we can just fwrite() the\n * decompressed data to the PPM or PGM file.\n */\n\n\n/* Private version of data destination object */\n\ntypedef struct {\n  struct djpeg_dest_struct pub; /* public fields */\n\n  /* Usually these two pointers point to the same place: */\n  char *iobuffer;               /* fwrite's I/O buffer */\n  _JSAMPROW pixrow;             /* decompressor output buffer */\n  size_t buffer_width;          /* width of I/O buffer */\n  JDIMENSION samples_per_row;   /* _JSAMPLEs per output row */\n} ppm_dest_struct;\n\ntypedef ppm_dest_struct *ppm_dest_ptr;\n\n\n/*\n * Write some pixel data.\n * In this module rows_supplied will always be 1.\n *\n * put_pixel_rows handles the \"normal\" 8-bit case where the decompressor\n * output buffer is physically the same as the fwrite buffer.\n */\n\nMETHODDEF(void)\nput_pixel_rows(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n               JDIMENSION rows_supplied)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr)dinfo;\n\n  fwrite(dest->iobuffer, 1, dest->buffer_width, dest->pub.output_file);\n}\n\n\n/*\n * This code is used when we have to copy the data and apply a pixel\n * format translation.  Typically this only happens in 12-bit mode.\n */\n\nMETHODDEF(void)\ncopy_pixel_rows(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n                JDIMENSION rows_supplied)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr)dinfo;\n  register char *bufferptr;\n  register _JSAMPROW ptr;\n#if BITS_IN_JSAMPLE != 8\n  register JDIMENSION col;\n#endif\n\n  ptr = dest->pub._buffer[0];\n  bufferptr = dest->iobuffer;\n#if BITS_IN_JSAMPLE == 8\n  memcpy(bufferptr, ptr, dest->samples_per_row);\n#else\n  for (col = dest->samples_per_row; col > 0; col--) {\n    PUTPPMSAMPLE(bufferptr, *ptr++);\n  }\n#endif\n  fwrite(dest->iobuffer, 1, dest->buffer_width, dest->pub.output_file);\n}\n\n\n/*\n * Convert extended RGB to RGB.\n */\n\nMETHODDEF(void)\nput_rgb(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo, JDIMENSION rows_supplied)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr)dinfo;\n  register char *bufferptr;\n  register _JSAMPROW ptr;\n  register JDIMENSION col;\n  register int rindex = rgb_red[cinfo->out_color_space];\n  register int gindex = rgb_green[cinfo->out_color_space];\n  register int bindex = rgb_blue[cinfo->out_color_space];\n  register int ps = rgb_pixelsize[cinfo->out_color_space];\n\n  ptr = dest->pub._buffer[0];\n  bufferptr = dest->iobuffer;\n  for (col = cinfo->output_width; col > 0; col--) {\n    PUTPPMSAMPLE(bufferptr, ptr[rindex]);\n    PUTPPMSAMPLE(bufferptr, ptr[gindex]);\n    PUTPPMSAMPLE(bufferptr, ptr[bindex]);\n    ptr += ps;\n  }\n  fwrite(dest->iobuffer, 1, dest->buffer_width, dest->pub.output_file);\n}\n\n\n/*\n * Convert CMYK to RGB.\n */\n\nMETHODDEF(void)\nput_cmyk(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n         JDIMENSION rows_supplied)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr)dinfo;\n  register char *bufferptr;\n  register _JSAMPROW ptr;\n  register JDIMENSION col;\n\n  ptr = dest->pub._buffer[0];\n  bufferptr = dest->iobuffer;\n  for (col = cinfo->output_width; col > 0; col--) {\n    _JSAMPLE r, g, b, c = *ptr++, m = *ptr++, y = *ptr++, k = *ptr++;\n    cmyk_to_rgb(c, m, y, k, &r, &g, &b);\n    PUTPPMSAMPLE(bufferptr, r);\n    PUTPPMSAMPLE(bufferptr, g);\n    PUTPPMSAMPLE(bufferptr, b);\n  }\n  fwrite(dest->iobuffer, 1, dest->buffer_width, dest->pub.output_file);\n}\n\n\n/*\n * Write some pixel data when color quantization is in effect.\n * We have to demap the color index values to straight data.\n */\n\nMETHODDEF(void)\nput_demapped_rgb(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n                 JDIMENSION rows_supplied)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr)dinfo;\n  register char *bufferptr;\n  register int pixval;\n  register _JSAMPROW ptr;\n  register _JSAMPROW color_map0 = ((_JSAMPARRAY)cinfo->colormap)[0];\n  register _JSAMPROW color_map1 = ((_JSAMPARRAY)cinfo->colormap)[1];\n  register _JSAMPROW color_map2 = ((_JSAMPARRAY)cinfo->colormap)[2];\n  register JDIMENSION col;\n\n  ptr = dest->pub._buffer[0];\n  bufferptr = dest->iobuffer;\n  for (col = cinfo->output_width; col > 0; col--) {\n    pixval = *ptr++;\n    PUTPPMSAMPLE(bufferptr, color_map0[pixval]);\n    PUTPPMSAMPLE(bufferptr, color_map1[pixval]);\n    PUTPPMSAMPLE(bufferptr, color_map2[pixval]);\n  }\n  fwrite(dest->iobuffer, 1, dest->buffer_width, dest->pub.output_file);\n}\n\n\nMETHODDEF(void)\nput_demapped_gray(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n                  JDIMENSION rows_supplied)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr)dinfo;\n  register char *bufferptr;\n  register _JSAMPROW ptr;\n  register _JSAMPROW color_map = ((_JSAMPARRAY)cinfo->colormap)[0];\n  register JDIMENSION col;\n\n  ptr = dest->pub._buffer[0];\n  bufferptr = dest->iobuffer;\n  for (col = cinfo->output_width; col > 0; col--) {\n    PUTPPMSAMPLE(bufferptr, color_map[*ptr++]);\n  }\n  fwrite(dest->iobuffer, 1, dest->buffer_width, dest->pub.output_file);\n}\n\n\n/*\n * Startup: write the file header.\n */\n\nMETHODDEF(void)\nstart_output_ppm(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr)dinfo;\n\n  /* Emit file header */\n  switch (cinfo->out_color_space) {\n  case JCS_GRAYSCALE:\n    /* emit header for raw PGM format */\n    fprintf(dest->pub.output_file, \"P5\\n%ld %ld\\n%d\\n\",\n            (long)cinfo->output_width, (long)cinfo->output_height, PPM_MAXVAL);\n    break;\n  case JCS_RGB:\n  case JCS_EXT_RGB:\n  case JCS_EXT_RGBX:\n  case JCS_EXT_BGR:\n  case JCS_EXT_BGRX:\n  case JCS_EXT_XBGR:\n  case JCS_EXT_XRGB:\n  case JCS_EXT_RGBA:\n  case JCS_EXT_BGRA:\n  case JCS_EXT_ABGR:\n  case JCS_EXT_ARGB:\n  case JCS_CMYK:\n    if (!IsExtRGB(cinfo->out_color_space) && cinfo->quantize_colors)\n      ERREXIT(cinfo, JERR_PPM_COLORSPACE);\n    /* emit header for raw PPM format */\n    fprintf(dest->pub.output_file, \"P6\\n%ld %ld\\n%d\\n\",\n            (long)cinfo->output_width, (long)cinfo->output_height, PPM_MAXVAL);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_PPM_COLORSPACE);\n  }\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_output_ppm(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  /* Make sure we wrote the output file OK */\n  fflush(dinfo->output_file);\n  if (ferror(dinfo->output_file))\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n}\n\n\n/*\n * Re-calculate buffer dimensions based on output dimensions.\n */\n\nMETHODDEF(void)\ncalc_buffer_dimensions_ppm(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr)dinfo;\n\n  if (cinfo->out_color_space == JCS_GRAYSCALE)\n    dest->samples_per_row = cinfo->output_width * cinfo->out_color_components;\n  else\n    dest->samples_per_row = cinfo->output_width * 3;\n  dest->buffer_width = dest->samples_per_row * (BYTESPERSAMPLE * sizeof(char));\n}\n\n\n/*\n * The module selection routine for PPM format output.\n */\n\nGLOBAL(djpeg_dest_ptr)\n_jinit_write_ppm(j_decompress_ptr cinfo)\n{\n  ppm_dest_ptr dest;\n\n  if (cinfo->data_precision != BITS_IN_JSAMPLE)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Create module interface object, fill in method pointers */\n  dest = (ppm_dest_ptr)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                  sizeof(ppm_dest_struct));\n  dest->pub.start_output = start_output_ppm;\n  dest->pub.finish_output = finish_output_ppm;\n  dest->pub.calc_buffer_dimensions = calc_buffer_dimensions_ppm;\n\n  /* Calculate output image dimensions so we can allocate space */\n  jpeg_calc_output_dimensions(cinfo);\n\n  /* Create physical I/O buffer */\n  dest->pub.calc_buffer_dimensions(cinfo, (djpeg_dest_ptr)dest);\n  dest->iobuffer = (char *)(*cinfo->mem->alloc_small)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE, dest->buffer_width);\n\n  if (cinfo->quantize_colors || BITS_IN_JSAMPLE != 8 ||\n      sizeof(_JSAMPLE) != sizeof(char) ||\n#if RGB_RED == 0 && RGB_GREEN == 1 && RGB_BLUE == 2 && RGB_PIXELSIZE == 3\n      (cinfo->out_color_space != JCS_EXT_RGB &&\n       cinfo->out_color_space != JCS_RGB)) {\n#else\n      cinfo->out_color_space != JCS_EXT_RGB) {\n#endif\n    /* When quantizing, we need an output buffer for colormap indexes\n     * that's separate from the physical I/O buffer.  We also need a\n     * separate buffer if pixel format translation must take place.\n     */\n    dest->pub._buffer = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE,\n       cinfo->output_width * cinfo->output_components, (JDIMENSION)1);\n    dest->pub.buffer_height = 1;\n    if (!cinfo->quantize_colors) {\n      if (IsExtRGB(cinfo->out_color_space))\n        dest->pub.put_pixel_rows = put_rgb;\n      else if (cinfo->out_color_space == JCS_CMYK)\n        dest->pub.put_pixel_rows = put_cmyk;\n      else\n        dest->pub.put_pixel_rows = copy_pixel_rows;\n    } else if (cinfo->out_color_space == JCS_GRAYSCALE)\n      dest->pub.put_pixel_rows = put_demapped_gray;\n    else\n      dest->pub.put_pixel_rows = put_demapped_rgb;\n  } else {\n    /* We will fwrite() directly from decompressor output buffer. */\n    /* Synthesize a _JSAMPARRAY pointer structure */\n    dest->pixrow = (_JSAMPROW)dest->iobuffer;\n    dest->pub._buffer = &dest->pixrow;\n    dest->pub.buffer_height = 1;\n    dest->pub.put_pixel_rows = put_pixel_rows;\n  }\n\n  return (djpeg_dest_ptr)dest;\n}\n\n#endif /* defined(PPM_SUPPORTED) &&\n          (BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)) */\n"
        },
        {
          "name": "wrtarga.c",
          "type": "blob",
          "size": 7.404296875,
          "content": "/*\n * wrtarga.c\n *\n * This file was part of the Independent JPEG Group's software:\n * Copyright (C) 1991-1996, Thomas G. Lane.\n * libjpeg-turbo Modifications:\n * Copyright (C) 2017, 2019, 2022, D. R. Commander.\n * For conditions of distribution and use, see the accompanying README.ijg\n * file.\n *\n * This file contains routines to write output images in Targa format.\n *\n * These routines may need modification for non-Unix environments or\n * specialized applications.  As they stand, they assume output to\n * an ordinary stdio stream.\n *\n * Based on code contributed by Lee Daniel Crocker.\n */\n\n#include \"cdjpeg.h\"             /* Common decls for cjpeg/djpeg applications */\n\n#ifdef TARGA_SUPPORTED\n\n\n/*\n * To support 12-bit JPEG data, we'd have to scale output down to 8 bits.\n * This is not yet implemented.\n */\n\n#if BITS_IN_JSAMPLE != 8\n  Sorry, this code only copes with 8-bit JSAMPLEs. /* deliberate syntax err */\n#endif\n\n\n/* Private version of data destination object */\n\ntypedef struct {\n  struct djpeg_dest_struct pub; /* public fields */\n\n  char *iobuffer;               /* physical I/O buffer */\n  JDIMENSION buffer_width;      /* width of one row */\n} tga_dest_struct;\n\ntypedef tga_dest_struct *tga_dest_ptr;\n\n\nLOCAL(void)\nwrite_header(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo, int num_colors)\n/* Create and write a Targa header */\n{\n  char targaheader[18];\n\n  /* Set unused fields of header to 0 */\n  memset(targaheader, 0, sizeof(targaheader));\n\n  if (num_colors > 0) {\n    targaheader[1] = 1;         /* color map type 1 */\n    targaheader[5] = (char)(num_colors & 0xFF);\n    targaheader[6] = (char)(num_colors >> 8);\n    targaheader[7] = 24;        /* 24 bits per cmap entry */\n  }\n\n  targaheader[12] = (char)(cinfo->output_width & 0xFF);\n  targaheader[13] = (char)(cinfo->output_width >> 8);\n  targaheader[14] = (char)(cinfo->output_height & 0xFF);\n  targaheader[15] = (char)(cinfo->output_height >> 8);\n  targaheader[17] = 0x20;       /* Top-down, non-interlaced */\n\n  if (cinfo->out_color_space == JCS_GRAYSCALE) {\n    targaheader[2] = 3;         /* image type = uncompressed grayscale */\n    targaheader[16] = 8;        /* bits per pixel */\n  } else {                      /* must be RGB */\n    if (num_colors > 0) {\n      targaheader[2] = 1;       /* image type = colormapped RGB */\n      targaheader[16] = 8;\n    } else {\n      targaheader[2] = 2;       /* image type = uncompressed RGB */\n      targaheader[16] = 24;\n    }\n  }\n\n  if (fwrite(targaheader, 1, 18, dinfo->output_file) != (size_t)18)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n}\n\n\n/*\n * Write some pixel data.\n * In this module rows_supplied will always be 1.\n */\n\nMETHODDEF(void)\nput_pixel_rows(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n               JDIMENSION rows_supplied)\n/* used for unquantized full-color output */\n{\n  tga_dest_ptr dest = (tga_dest_ptr)dinfo;\n  register JSAMPROW inptr;\n  register char *outptr;\n  register JDIMENSION col;\n\n  inptr = dest->pub.buffer[0];\n  outptr = dest->iobuffer;\n  for (col = cinfo->output_width; col > 0; col--) {\n    outptr[0] = inptr[2]; /* RGB to BGR order */\n    outptr[1] = inptr[1];\n    outptr[2] = inptr[0];\n    inptr += 3, outptr += 3;\n  }\n  fwrite(dest->iobuffer, 1, dest->buffer_width, dest->pub.output_file);\n}\n\nMETHODDEF(void)\nput_gray_rows(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n              JDIMENSION rows_supplied)\n/* used for grayscale OR quantized color output */\n{\n  tga_dest_ptr dest = (tga_dest_ptr)dinfo;\n  register JSAMPROW inptr;\n  register char *outptr;\n\n  inptr = dest->pub.buffer[0];\n  outptr = dest->iobuffer;\n  memcpy(outptr, inptr, cinfo->output_width);\n  fwrite(dest->iobuffer, 1, dest->buffer_width, dest->pub.output_file);\n}\n\n\n/*\n * Write some demapped pixel data when color quantization is in effect.\n * For Targa, this is only applied to grayscale data.\n */\n\nMETHODDEF(void)\nput_demapped_gray(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,\n                  JDIMENSION rows_supplied)\n{\n  tga_dest_ptr dest = (tga_dest_ptr)dinfo;\n  register JSAMPROW inptr;\n  register char *outptr;\n  register JSAMPROW color_map0 = cinfo->colormap[0];\n  register JDIMENSION col;\n\n  inptr = dest->pub.buffer[0];\n  outptr = dest->iobuffer;\n  for (col = cinfo->output_width; col > 0; col--) {\n    *outptr++ = color_map0[*inptr++];\n  }\n  fwrite(dest->iobuffer, 1, dest->buffer_width, dest->pub.output_file);\n}\n\n\n/*\n * Startup: write the file header.\n */\n\nMETHODDEF(void)\nstart_output_tga(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  tga_dest_ptr dest = (tga_dest_ptr)dinfo;\n  int num_colors, i;\n  FILE *outfile;\n\n  if (cinfo->out_color_space == JCS_GRAYSCALE) {\n    /* Targa doesn't have a mapped grayscale format, so we will */\n    /* demap quantized gray output.  Never emit a colormap. */\n    write_header(cinfo, dinfo, 0);\n    if (cinfo->quantize_colors)\n      dest->pub.put_pixel_rows = put_demapped_gray;\n    else\n      dest->pub.put_pixel_rows = put_gray_rows;\n  } else if (cinfo->out_color_space == JCS_RGB) {\n    if (cinfo->quantize_colors) {\n      /* We only support 8-bit colormap indexes, so only 256 colors */\n      num_colors = cinfo->actual_number_of_colors;\n      if (num_colors > 256)\n        ERREXIT1(cinfo, JERR_TOO_MANY_COLORS, num_colors);\n      write_header(cinfo, dinfo, num_colors);\n      /* Write the colormap.  Note Targa uses BGR byte order */\n      outfile = dest->pub.output_file;\n      for (i = 0; i < num_colors; i++) {\n        putc(cinfo->colormap[2][i], outfile);\n        putc(cinfo->colormap[1][i], outfile);\n        putc(cinfo->colormap[0][i], outfile);\n      }\n      dest->pub.put_pixel_rows = put_gray_rows;\n    } else {\n      write_header(cinfo, dinfo, 0);\n      dest->pub.put_pixel_rows = put_pixel_rows;\n    }\n  } else {\n    ERREXIT(cinfo, JERR_TGA_COLORSPACE);\n  }\n}\n\n\n/*\n * Finish up at the end of the file.\n */\n\nMETHODDEF(void)\nfinish_output_tga(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  /* Make sure we wrote the output file OK */\n  fflush(dinfo->output_file);\n  if (ferror(dinfo->output_file))\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n}\n\n\n/*\n * Re-calculate buffer dimensions based on output dimensions.\n */\n\nMETHODDEF(void)\ncalc_buffer_dimensions_tga(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  tga_dest_ptr dest = (tga_dest_ptr)dinfo;\n\n  dest->buffer_width = cinfo->output_width * cinfo->output_components;\n}\n\n\n/*\n * The module selection routine for Targa format output.\n */\n\nGLOBAL(djpeg_dest_ptr)\njinit_write_targa(j_decompress_ptr cinfo)\n{\n  tga_dest_ptr dest;\n\n  if (cinfo->data_precision != 8)\n    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);\n\n  /* Create module interface object, fill in method pointers */\n  dest = (tga_dest_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(tga_dest_struct));\n  dest->pub.start_output = start_output_tga;\n  dest->pub.finish_output = finish_output_tga;\n  dest->pub.calc_buffer_dimensions = calc_buffer_dimensions_tga;\n\n  /* Calculate output image dimensions so we can allocate space */\n  jpeg_calc_output_dimensions(cinfo);\n\n  /* Create I/O buffer. */\n  dest->pub.calc_buffer_dimensions(cinfo, (djpeg_dest_ptr)dest);\n  dest->iobuffer = (char *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (size_t)(dest->buffer_width * sizeof(char)));\n\n  /* Create decompressor output buffer. */\n  dest->pub.buffer = (*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE, dest->buffer_width, (JDIMENSION)1);\n  dest->pub.buffer_height = 1;\n\n  return (djpeg_dest_ptr)dest;\n}\n\n#endif /* TARGA_SUPPORTED */\n"
        },
        {
          "name": "yuvjpeg.c",
          "type": "blob",
          "size": 7.8642578125,
          "content": "/*\n * Written by Josh Aas and Tim Terriberry\n * Copyright (c) 2013, Mozilla Corporation\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n * 3. Neither the name of the Mozilla Corporation nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Expects 4:2:0 YCbCr */\n\n/* gcc -std=c99 yuvjpeg.c -I/opt/local/include/ -L/opt/local/lib/ -ljpeg -o yuvjpeg */\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"jpeglib.h\"\n\nvoid extend_edge(JSAMPLE *image, int width, int height, unsigned char *yuv,\n int luma_width, int luma_height, int chroma_width, int chroma_height) {\n  int x;\n  int y;\n\n  for (y = 0; y < luma_height; y++) {\n    for (x = 0; x < luma_width; x++) {\n      image[width*y + x] = yuv[luma_width*y + x];\n    }\n  }\n  for (y = 0; y < chroma_height; y++) {\n    for (x = 0; x < chroma_width; x++) {\n      image[width*height + (width/2)*y + x] =\n       yuv[luma_width*luma_height + chroma_width*y + x];\n      image[width*height + (width/2)*((height/2) + y) + x] =\n       yuv[luma_width*luma_height + chroma_width*(chroma_height + y) + x];\n    }\n  }\n\n  /* Perform right edge extension. */\n  for (y = 0; y < luma_height; y++) {\n    for (x = luma_width; x < width; x++) {\n      image[width*y + x] = image[width*y + (x - 1)];\n    }\n  }\n  for (y = 0; y < chroma_height; y++) {\n    for (x = chroma_width; x < width/2; x++) {\n      image[width*height + (width/2)*y + x] =\n       image[width*height + (width/2)*y + (x - 1)];\n      image[width*height + (width/2)*((height/2) + y) + x] =\n       image[width*height + (width/2)*((height/2) + y) + (x - 1)];\n    }\n  }\n\n  /* Perform bottom edge extension. */\n  for (x = 0; x < width; x++) {\n    for (y = luma_height; y < height; y++) {\n      image[width*y + x] = image[width*(y - 1) + x];\n    }\n  }\n  for (x = 0; x < width/2; x++) {\n    for (y = chroma_height; y < height/2; y++) {\n      image[width*height + (width/2)*y + x] =\n       image[width*height + (width/2)*(y - 1) + x];\n      image[width*height + (width/2)*((height/2) + y) + x] =\n       image[width*height + (width/2)*((height/2) + (y - 1)) + x];\n    }\n  }\n}\n\nint main(int argc, char *argv[]) {\n  long quality;\n  int matches;\n  int luma_width;\n  int luma_height;\n  int chroma_width;\n  int chroma_height;\n  int frame_width;\n  int frame_height;\n  const char *yuv_path;\n  const char *jpg_path;\n  FILE *yuv_fd;\n  size_t yuv_size;\n  unsigned char *yuv_buffer;\n  JSAMPLE *jpg_buffer;\n  struct jpeg_compress_struct cinfo;\n  struct jpeg_error_mgr jerr;\n  FILE *jpg_fd;\n  JSAMPROW yrow_pointer[16];\n  JSAMPROW cbrow_pointer[8];\n  JSAMPROW crrow_pointer[8];\n  JSAMPROW *plane_pointer[3];\n  int y;\n\n  if (argc != 5) {\n    fprintf(stderr, \"Required arguments:\\n\");\n    fprintf(stderr, \"1. JPEG quality value, 0-100\\n\");\n    fprintf(stderr, \"2. Image size (e.g. '512x512')\\n\");\n    fprintf(stderr, \"3. Path to YUV input file\\n\");\n    fprintf(stderr, \"4. Path to JPG output file\\n\");\n    return 1;\n  }\n\n  errno = 0;\n\n  quality = strtol(argv[1], NULL, 10);\n  if (errno != 0 || quality < 0 || quality > 100) {\n    fprintf(stderr, \"Invalid JPEG quality value!\\n\");\n    return 1;\n  }\n\n  matches = sscanf(argv[2], \"%dx%d\", &luma_width, &luma_height);\n  if (matches != 2) {\n    fprintf(stderr, \"Invalid image size input!\\n\");\n    return 1;\n  }\n  if (luma_width <= 0 || luma_height <= 0) {\n    fprintf(stderr, \"Invalid image size input!\\n\");\n    return 1;\n  }\n\n  chroma_width = (luma_width + 1) >> 1;\n  chroma_height = (luma_height + 1) >> 1;\n\n  /* Will check these for validity when opening via 'fopen'. */\n  yuv_path = argv[3];\n  jpg_path = argv[4];\n\n  yuv_fd = fopen(yuv_path, \"r\");\n  if (!yuv_fd) {\n    fprintf(stderr, \"Invalid path to YUV file!\\n\");\n    return 1;\n  }\n\n  fseek(yuv_fd, 0, SEEK_END);\n  yuv_size = ftell(yuv_fd);\n  fseek(yuv_fd, 0, SEEK_SET);\n\n  /* Check that the file size matches 4:2:0 yuv. */\n  if (yuv_size !=\n   (size_t)luma_width*luma_height + 2*chroma_width*chroma_height) {\n    fclose(yuv_fd);\n    fprintf(stderr, \"Unexpected input format!\\n\");\n    return 1;\n  }\n\n  yuv_buffer = malloc(yuv_size);\n  if (!yuv_buffer) {\n    fclose(yuv_fd);\n    fprintf(stderr, \"Memory allocation failure!\\n\");\n    return 1;\n  }\n\n  if (fread(yuv_buffer, yuv_size, 1, yuv_fd) != 1) {\n    fprintf(stderr, \"Error reading yuv file\\n\");\n  };\n\n  fclose(yuv_fd);\n\n  frame_width = (luma_width + (16 - 1)) & ~(16 - 1);\n  frame_height = (luma_height + (16 - 1)) & ~(16 - 1);\n\n  jpg_buffer =\n   malloc(frame_width*frame_height + 2*(frame_width/2)*(frame_height/2));\n  if (!jpg_buffer) {\n    free(yuv_buffer);\n    fprintf(stderr, \"Memory allocation failure!\\n\");\n    return 1;\n  }\n\n  extend_edge(jpg_buffer, frame_width, frame_height,\n   yuv_buffer, luma_width, luma_height, chroma_width, chroma_height);\n\n  free(yuv_buffer);\n\n  cinfo.err = jpeg_std_error(&jerr);\n  jpeg_create_compress(&cinfo);\n\n  jpg_fd = fopen(jpg_path, \"wb\");\n  if (!jpg_fd) {    \n    free(jpg_buffer);\n    fprintf(stderr, \"Invalid path to JPEG file!\\n\");\n    return 1;\n  }\n\n  jpeg_stdio_dest(&cinfo, jpg_fd);\n\n  cinfo.image_width = luma_width;\n  cinfo.image_height = luma_height;\n  cinfo.input_components = 3;\n\n  cinfo.in_color_space = JCS_YCbCr;\n  jpeg_set_defaults(&cinfo);\n\n  cinfo.raw_data_in = TRUE;\n\n  cinfo.comp_info[0].h_samp_factor = 2;\n  cinfo.comp_info[0].v_samp_factor = 2;\n  cinfo.comp_info[0].dc_tbl_no = 0;\n  cinfo.comp_info[0].ac_tbl_no = 0;\n  cinfo.comp_info[0].quant_tbl_no = 0;\n\n  cinfo.comp_info[1].h_samp_factor = 1;\n  cinfo.comp_info[1].v_samp_factor = 1;\n  cinfo.comp_info[1].dc_tbl_no = 1;\n  cinfo.comp_info[1].ac_tbl_no = 1;\n  cinfo.comp_info[1].quant_tbl_no = 1;\n\n  cinfo.comp_info[2].h_samp_factor = 1;\n  cinfo.comp_info[2].v_samp_factor = 1;\n  cinfo.comp_info[2].dc_tbl_no = 1;\n  cinfo.comp_info[2].ac_tbl_no = 1;\n  cinfo.comp_info[2].quant_tbl_no = 1;\n\n  jpeg_set_quality(&cinfo, quality, TRUE);\n  cinfo.optimize_coding = TRUE;\n\n  jpeg_start_compress(&cinfo, TRUE);\n\n  plane_pointer[0] = yrow_pointer;\n  plane_pointer[1] = cbrow_pointer;\n  plane_pointer[2] = crrow_pointer;\n\n  while (cinfo.next_scanline < cinfo.image_height) {\n    int scanline;\n    scanline = cinfo.next_scanline;\n\n    for (y = 0; y < 16; y++) {\n      yrow_pointer[y] = &jpg_buffer[frame_width*(scanline + y)];\n    }\n    for (y = 0; y < 8; y++) {\n      cbrow_pointer[y] = &jpg_buffer[frame_width*frame_height +\n       (frame_width/2)*((scanline/2) + y)];\n      crrow_pointer[y] = &jpg_buffer[frame_width*frame_height +\n       (frame_width/2)*(frame_height/2) + (frame_width/2)*((scanline/2) + y)];\n    }\n    jpeg_write_raw_data(&cinfo, plane_pointer, 16);\n  }\n\n  jpeg_finish_compress(&cinfo);\n  jpeg_destroy_compress(&cinfo);\n\n  free(jpg_buffer);\n  fclose(jpg_fd);\n\n  return 0;\n}\n"
        }
      ]
    }
  ]
}