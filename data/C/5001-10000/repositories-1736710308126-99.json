{
  "metadata": {
    "timestamp": 1736710308126,
    "page": 99,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "htop-dev/htop",
      "stars": 6685,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.375,
          "content": "# EditorConfig configuration for htop\n# http://EditorConfig.org\n\n# top-most EditorConfig file\nroot = true\n\n# Unix-style newlines with a newline ending every file, utf-8 charset\n[*]\nend_of_line = lf\ninsert_final_newline = true\ncharset = utf-8\n\n# match C source and header files, set indent to three spaces\n[*.{c,h}]\nindent_style = space\nindent_size = 3\ntrim_trailing_whitespace = true\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.57421875,
          "content": "# the binaries:\nhtop\npcp-htop\n\n# all object files\n*.o\n\n# skip all backups\n*.bak\n*~\n.*.sw?\n\n# skip coverage files\n*.gcda\n*/*.gcda\n*.gcno\n*/*.gcno\n*.h.gch\n*/.dirstamp\n\n# automake/autoconf related files\n.deps/\nMakefile\nMakefile.in\nINSTALL\naclocal.m4\nautom4te.cache/\ncompile\nconf*/\nconfig.guess\nconfig.h\nconfig.h.in\nconfig.log\nconfig.status\nconfig.cache\nconfig.sub\nconfigure\ndepcomp\nhtop.1\npcp-htop.5\ninstall-sh\nlibtool\nltmain.sh\nm4/\nmissing\nstamp-h1\n\n# files related to valgrind/callgrind\ncallgrind.out.*\n\n# IDE workspace configurations\n/.idea/\n/.vscode/\n\n# Language Servers\n/.cache/clangd/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.2275390625,
          "content": "language: c\n\ncompiler:\n  - clang\n  - gcc\n\nos:\n  - freebsd\n\nscript:\n  - ./autogen.sh\n  - ./configure --enable-werror\n  - make -k\n  - make distcheck DISTCHECK_CONFIGURE_FLAGS=--enable-werror\n  - sudo make install\n  - make installcheck\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.220703125,
          "content": "Originally authored by:\n Hisham H. Muhammad\n\nCurrently maintained by the htop dev team:\n Benny Baumann\n Christian GÃ¶ttsche\n Daniel Lange\n Nathan Scott\n\nFor the full list of contributors see:\n git log --format=\"%aN\" | sort -u\n"
        },
        {
          "name": "Action.c",
          "type": "blob",
          "size": 31.2265625,
          "content": "/*\nhtop - Action.c\n(C) 2015 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Action.h\"\n\n#include <assert.h>\n#include <pwd.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"CategoriesPanel.h\"\n#include \"CommandScreen.h\"\n#include \"DynamicColumn.h\"\n#include \"EnvScreen.h\"\n#include \"FunctionBar.h\"\n#include \"Hashtable.h\"\n#include \"IncSet.h\"\n#include \"InfoScreen.h\"\n#include \"ListItem.h\"\n#include \"Macros.h\"\n#include \"MainPanel.h\"\n#include \"OpenFilesScreen.h\"\n#include \"Process.h\"\n#include \"ProcessLocksScreen.h\"\n#include \"ProvideCurses.h\"\n#include \"Row.h\"\n#include \"RowField.h\"\n#include \"Scheduling.h\"\n#include \"ScreenManager.h\"\n#include \"SignalsPanel.h\"\n#include \"Table.h\"\n#include \"TraceScreen.h\"\n#include \"UsersTable.h\"\n#include \"Vector.h\"\n#include \"XUtils.h\"\n\n#if (defined(HAVE_LIBHWLOC) || defined(HAVE_AFFINITY))\n#include \"Affinity.h\"\n#include \"AffinityPanel.h\"\n#endif\n\n\nObject* Action_pickFromVector(State* st, Panel* list, int x, bool follow) {\n   MainPanel* mainPanel = st->mainPanel;\n   Header* header = st->header;\n   Machine* host = st->host;\n\n   int y = ((Panel*)mainPanel)->y;\n   ScreenManager* scr = ScreenManager_new(header, host, st, false);\n   scr->allowFocusChange = false;\n   ScreenManager_add(scr, list, x);\n   ScreenManager_add(scr, (Panel*)mainPanel, -1);\n   Panel* panelFocus;\n   int ch;\n   bool unfollow = false;\n   int row = follow ? MainPanel_selectedRow(mainPanel) : -1;\n   if (follow && host->activeTable->following == -1) {\n      host->activeTable->following = row;\n      unfollow = true;\n   }\n   ScreenManager_run(scr, &panelFocus, &ch, NULL);\n   if (unfollow) {\n      host->activeTable->following = -1;\n   }\n   ScreenManager_delete(scr);\n   Panel_move((Panel*)mainPanel, 0, y);\n   Panel_resize((Panel*)mainPanel, COLS, LINES - y - 1);\n   if (panelFocus == list && ch == 13) {\n      if (follow) {\n         const Row* selected = (const Row*)Panel_getSelected((Panel*)mainPanel);\n         if (selected && selected->id == row)\n            return Panel_getSelected(list);\n\n         beep();\n      } else {\n         return Panel_getSelected(list);\n      }\n   }\n\n   return NULL;\n}\n\n// ----------------------------------------\n\nstatic void Action_runSetup(State* st) {\n   const Settings* settings = st->host->settings;\n   ScreenManager* scr = ScreenManager_new(st->header, st->host, st, true);\n   CategoriesPanel_new(scr, st->header, st->host);\n   ScreenManager_run(scr, NULL, NULL, \"Setup\");\n   ScreenManager_delete(scr);\n   if (settings->changed) {\n      CRT_setMouse(settings->enableMouse);\n      Header_writeBackToSettings(st->header);\n   }\n}\n\nstatic bool changePriority(MainPanel* panel, int delta) {\n   bool anyTagged;\n   bool ok = MainPanel_foreachRow(panel, Process_rowChangePriorityBy, (Arg) { .i = delta }, &anyTagged);\n   if (!ok)\n      beep();\n   return anyTagged;\n}\n\nstatic void addUserToVector(ht_key_t key, void* userCast, void* panelCast) {\n   const char* user = userCast;\n   Panel* panel = panelCast;\n   Panel_add(panel, (Object*) ListItem_new(user, key));\n}\n\nbool Action_setUserOnly(const char* userName, uid_t* userId) {\n   const struct passwd* user = getpwnam(userName);\n   if (user) {\n      *userId = user->pw_uid;\n      return true;\n   }\n   *userId = (uid_t)-1;\n   return false;\n}\n\nstatic void tagAllChildren(Panel* panel, Row* parent) {\n   parent->tag = true;\n   int parent_id = parent->id;\n   for (int i = 0; i < Panel_size(panel); i++) {\n      Row* row = (Row*) Panel_get(panel, i);\n      if (!row->tag && Row_isChildOf(row, parent_id)) {\n         tagAllChildren(panel, row);\n      }\n   }\n}\n\nstatic bool expandCollapse(Panel* panel) {\n   Row* row = (Row*) Panel_getSelected(panel);\n   if (!row)\n      return false;\n\n   row->showChildren = !row->showChildren;\n   return true;\n}\n\nstatic bool collapseIntoParent(Panel* panel) {\n   const Row* r = (Row*) Panel_getSelected(panel);\n   if (!r)\n      return false;\n\n   int parent_id = Row_getGroupOrParent(r);\n   for (int i = 0; i < Panel_size(panel); i++) {\n      Row* row = (Row*) Panel_get(panel, i);\n      if (row->id == parent_id) {\n         row->showChildren = false;\n         Panel_setSelected(panel, i);\n         return true;\n      }\n   }\n   return false;\n}\n\nHtop_Reaction Action_setSortKey(Settings* settings, ProcessField sortKey) {\n   ScreenSettings_setSortKey(settings->ss, (RowField) sortKey);\n   return HTOP_REFRESH | HTOP_SAVE_SETTINGS | HTOP_UPDATE_PANELHDR | HTOP_KEEP_FOLLOWING;\n}\n\n// ----------------------------------------\n\nstatic bool Action_writeableProcess(State* st) {\n   const Settings* settings = st->host->settings;\n   bool readonly = Settings_isReadonly() || settings->ss->dynamic;\n   return !readonly;\n}\n\nstatic bool Action_readableProcess(State* st) {\n   const Settings* settings = st->host->settings;\n   return !settings->ss->dynamic;\n}\n\nstatic Htop_Reaction actionSetSortColumn(State* st) {\n   Htop_Reaction reaction = HTOP_OK;\n   Panel* sortPanel = Panel_new(0, 0, 0, 0, Class(ListItem), true, FunctionBar_newEnterEsc(\"Sort   \", \"Cancel \"));\n   Panel_setHeader(sortPanel, \"Sort by\");\n   Machine* host = st->host;\n   Settings* settings = host->settings;\n   const RowField* fields = settings->ss->fields;\n   Hashtable* dynamicColumns = settings->dynamicColumns;\n   for (int i = 0; fields[i]; i++) {\n      char* name = NULL;\n      if (fields[i] >= ROW_DYNAMIC_FIELDS) {\n         DynamicColumn* column = Hashtable_get(dynamicColumns, fields[i]);\n         if (!column)\n            continue;\n         name = xStrdup(column->caption ? column->caption : column->name);\n      } else {\n         name = String_trim(Process_fields[fields[i]].name);\n      }\n      Panel_add(sortPanel, (Object*) ListItem_new(name, fields[i]));\n      if (fields[i] == ScreenSettings_getActiveSortKey(settings->ss))\n         Panel_setSelected(sortPanel, i);\n\n      free(name);\n   }\n   const ListItem* field = (const ListItem*) Action_pickFromVector(st, sortPanel, 14, false);\n   if (field) {\n      reaction |= Action_setSortKey(settings, field->key);\n   }\n   Object_delete(sortPanel);\n\n   host->activeTable->needsSort = true;\n\n   return reaction | HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n}\n\nstatic Htop_Reaction actionSortByPID(State* st) {\n   return Action_setSortKey(st->host->settings, PID);\n}\n\nstatic Htop_Reaction actionSortByMemory(State* st) {\n   return Action_setSortKey(st->host->settings, PERCENT_MEM);\n}\n\nstatic Htop_Reaction actionSortByCPU(State* st) {\n   return Action_setSortKey(st->host->settings, PERCENT_CPU);\n}\n\nstatic Htop_Reaction actionSortByTime(State* st) {\n   return Action_setSortKey(st->host->settings, TIME);\n}\n\nstatic Htop_Reaction actionToggleKernelThreads(State* st) {\n   Settings* settings = st->host->settings;\n   settings->hideKernelThreads = !settings->hideKernelThreads;\n   settings->lastUpdate++;\n\n   Machine_scanTables(st->host); // needed to not have a visible delay showing wrong data\n\n   return HTOP_RECALCULATE | HTOP_SAVE_SETTINGS | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionToggleUserlandThreads(State* st) {\n   Settings* settings = st->host->settings;\n   settings->hideUserlandThreads = !settings->hideUserlandThreads;\n   settings->lastUpdate++;\n\n   Machine_scanTables(st->host); // needed to not have a visible delay showing wrong data\n\n   return HTOP_RECALCULATE | HTOP_SAVE_SETTINGS | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionToggleRunningInContainer(State* st) {\n   Settings* settings = st->host->settings;\n   settings->hideRunningInContainer = !settings->hideRunningInContainer;\n   settings->lastUpdate++;\n\n   return HTOP_RECALCULATE | HTOP_SAVE_SETTINGS | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionToggleProgramPath(State* st) {\n   Settings* settings = st->host->settings;\n   settings->showProgramPath = !settings->showProgramPath;\n   settings->lastUpdate++;\n\n   return HTOP_REFRESH | HTOP_SAVE_SETTINGS | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionToggleMergedCommand(State* st) {\n   Settings* settings = st->host->settings;\n   settings->showMergedCommand = !settings->showMergedCommand;\n   settings->lastUpdate++;\n\n   return HTOP_REFRESH | HTOP_SAVE_SETTINGS | HTOP_KEEP_FOLLOWING | HTOP_UPDATE_PANELHDR;\n}\n\nstatic Htop_Reaction actionToggleTreeView(State* st) {\n   Machine* host = st->host;\n   ScreenSettings* ss = host->settings->ss;\n   ss->treeView = !ss->treeView;\n\n   if (!ss->allBranchesCollapsed)\n      Table_expandTree(host->activeTable);\n\n   host->activeTable->needsSort = true;\n\n   return HTOP_REFRESH | HTOP_SAVE_SETTINGS | HTOP_KEEP_FOLLOWING | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n}\n\nstatic Htop_Reaction actionToggleHideMeters(State* st) {\n   st->hideMeters = !st->hideMeters;\n   return HTOP_RESIZE | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionExpandOrCollapseAllBranches(State* st) {\n   Machine* host = st->host;\n   ScreenSettings* ss = host->settings->ss;\n   if (!ss->treeView) {\n      return HTOP_OK;\n   }\n   ss->allBranchesCollapsed = !ss->allBranchesCollapsed;\n   if (ss->allBranchesCollapsed)\n      Table_collapseAllBranches(host->activeTable);\n   else\n      Table_expandTree(host->activeTable);\n   return HTOP_REFRESH | HTOP_SAVE_SETTINGS;\n}\n\nstatic Htop_Reaction actionIncFilter(State* st) {\n   Machine* host = st->host;\n   IncSet* inc = (st->mainPanel)->inc;\n   IncSet_activate(inc, INC_FILTER, (Panel*)st->mainPanel);\n   host->activeTable->incFilter = IncSet_filter(inc);\n   return HTOP_REFRESH | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionIncSearch(State* st) {\n   IncSet_reset(st->mainPanel->inc, INC_SEARCH);\n   IncSet_activate(st->mainPanel->inc, INC_SEARCH, (Panel*)st->mainPanel);\n   return HTOP_REFRESH | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionHigherPriority(State* st) {\n   if (!Action_writeableProcess(st))\n      return HTOP_OK;\n\n   bool changed = changePriority(st->mainPanel, -1);\n   return changed ? HTOP_REFRESH : HTOP_OK;\n}\n\nstatic Htop_Reaction actionLowerPriority(State* st) {\n   if (!Action_writeableProcess(st))\n      return HTOP_OK;\n\n   bool changed = changePriority(st->mainPanel, 1);\n   return changed ? HTOP_REFRESH : HTOP_OK;\n}\n\nstatic Htop_Reaction actionInvertSortOrder(State* st) {\n   Machine* host = st->host;\n   ScreenSettings_invertSortOrder(host->settings->ss);\n   host->activeTable->needsSort = true;\n   return HTOP_REFRESH | HTOP_SAVE_SETTINGS | HTOP_KEEP_FOLLOWING | HTOP_UPDATE_PANELHDR;\n}\n\nstatic Htop_Reaction actionExpandOrCollapse(State* st) {\n   if (!st->host->settings->ss->treeView)\n      return HTOP_OK;\n\n   bool changed = expandCollapse((Panel*)st->mainPanel);\n   return changed ? HTOP_RECALCULATE : HTOP_OK;\n}\n\nstatic Htop_Reaction actionCollapseIntoParent(State* st) {\n   if (!st->host->settings->ss->treeView) {\n      return HTOP_OK;\n   }\n   bool changed = collapseIntoParent((Panel*)st->mainPanel);\n   return changed ? HTOP_RECALCULATE : HTOP_OK;\n}\n\nstatic Htop_Reaction actionExpandCollapseOrSortColumn(State* st) {\n   return st->host->settings->ss->treeView ? actionExpandOrCollapse(st) : actionSetSortColumn(st);\n}\n\nstatic inline void setActiveScreen(Settings* settings, State* st, unsigned int ssIdx) {\n   assert(settings->ssIndex == ssIdx);\n   Machine* host = st->host;\n\n   settings->ss = settings->screens[ssIdx];\n   if (!settings->ss->table)\n      settings->ss->table = host->processTable;\n   host->activeTable = settings->ss->table;\n\n   // set correct functionBar - readonly if requested, and/or with non-process screens\n   bool readonly = Settings_isReadonly() || (host->activeTable != host->processTable);\n   MainPanel_setFunctionBar(st->mainPanel, readonly);\n}\n\nstatic Htop_Reaction actionNextScreen(State* st) {\n   Settings* settings = st->host->settings;\n   settings->ssIndex++;\n   if (settings->ssIndex == settings->nScreens) {\n      settings->ssIndex = 0;\n   }\n   setActiveScreen(settings, st, settings->ssIndex);\n   return HTOP_UPDATE_PANELHDR | HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nstatic Htop_Reaction actionPrevScreen(State* st) {\n   Settings* settings = st->host->settings;\n   if (settings->ssIndex == 0) {\n      settings->ssIndex = settings->nScreens - 1;\n   } else {\n      settings->ssIndex--;\n   }\n   setActiveScreen(settings, st, settings->ssIndex);\n   return HTOP_UPDATE_PANELHDR | HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nHtop_Reaction Action_setScreenTab(State* st, int x) {\n   Settings* settings = st->host->settings;\n   int s = 2;\n   for (unsigned int i = 0; i < settings->nScreens; i++) {\n      if (x < s) {\n         return 0;\n      }\n      const char* tab = settings->screens[i]->heading;\n      int len = strlen(tab);\n      if (x <= s + len + 1) {\n         settings->ssIndex = i;\n         setActiveScreen(settings, st, i);\n         return HTOP_UPDATE_PANELHDR | HTOP_REFRESH | HTOP_REDRAW_BAR;\n      }\n      s += len + 3;\n   }\n   return 0;\n}\n\nstatic Htop_Reaction actionQuit(ATTR_UNUSED State* st) {\n   return HTOP_QUIT;\n}\n\nstatic Htop_Reaction actionSetAffinity(State* st) {\n   if (!Action_writeableProcess(st))\n      return HTOP_OK;\n\n   Machine* host = st->host;\n   if (host->activeCPUs == 1)\n      return HTOP_OK;\n\n#if (defined(HAVE_LIBHWLOC) || defined(HAVE_AFFINITY))\n   const Row* row = (const Row*) Panel_getSelected((Panel*)st->mainPanel);\n   if (!row)\n      return HTOP_OK;\n\n   Affinity* affinity1 = Affinity_rowGet(row, host);\n   if (!affinity1)\n      return HTOP_OK;\n\n   int width;\n   Panel* affinityPanel = AffinityPanel_new(host, affinity1, &width);\n   Affinity_delete(affinity1);\n\n   const void* set = Action_pickFromVector(st, affinityPanel, width, true);\n   if (set) {\n      Affinity* affinity2 = AffinityPanel_getAffinity(affinityPanel, host);\n      bool ok = MainPanel_foreachRow(st->mainPanel, Affinity_rowSet, (Arg) { .v = affinity2 }, NULL);\n      if (!ok)\n         beep();\n      Affinity_delete(affinity2);\n   }\n   Object_delete(affinityPanel);\n   return HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n#else\n   return HTOP_OK;\n#endif\n}\n\n#ifdef SCHEDULER_SUPPORT\nstatic Htop_Reaction actionSetSchedPolicy(State* st) {\n   if (!Action_writeableProcess(st))\n      return HTOP_KEEP_FOLLOWING;\n\n   static int preSelectedPolicy = SCHEDULINGPANEL_INITSELECTEDPOLICY;\n   static int preSelectedPriority = SCHEDULINGPANEL_INITSELECTEDPRIORITY;\n\n   Panel* schedPanel = Scheduling_newPolicyPanel(preSelectedPolicy);\n\n   const ListItem* policy;\n   for (;;) {\n      policy = (const ListItem*) Action_pickFromVector(st, schedPanel, 18, true);\n\n      if (!policy || policy->key != -1)\n         break;\n\n      Scheduling_togglePolicyPanelResetOnFork(schedPanel);\n   }\n\n   if (policy) {\n      preSelectedPolicy = policy->key;\n\n      Panel* prioPanel = Scheduling_newPriorityPanel(policy->key, preSelectedPriority);\n      if (prioPanel) {\n         const ListItem* prio = (const ListItem*) Action_pickFromVector(st, prioPanel, 14, true);\n         if (prio)\n            preSelectedPriority = prio->key;\n\n         Panel_delete((Object*) prioPanel);\n      }\n\n      SchedulingArg v = { .policy = preSelectedPolicy, .priority = preSelectedPriority };\n\n      bool ok = MainPanel_foreachRow(st->mainPanel, Scheduling_rowSetPolicy, (Arg) { .v = &v }, NULL);\n      if (!ok)\n         beep();\n   }\n\n   Panel_delete((Object*)schedPanel);\n\n   return HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_KEEP_FOLLOWING;\n}\n#endif  /* SCHEDULER_SUPPORT */\n\nstatic Htop_Reaction actionKill(State* st) {\n   if (!Action_writeableProcess(st))\n      return HTOP_OK;\n\n   static int preSelectedSignal = SIGNALSPANEL_INITSELECTEDSIGNAL;\n\n   Panel* signalsPanel = SignalsPanel_new(preSelectedSignal);\n   const ListItem* sgn = (ListItem*) Action_pickFromVector(st, signalsPanel, 14, true);\n   if (sgn && sgn->key != 0) {\n      preSelectedSignal = sgn->key;\n      Panel_setHeader((Panel*)st->mainPanel, \"Sending...\");\n      Panel_draw((Panel*)st->mainPanel, false, true, true, State_hideFunctionBar(st));\n      refresh();\n      bool ok = MainPanel_foreachRow(st->mainPanel, Process_rowSendSignal, (Arg) { .i = sgn->key }, NULL);\n      if (!ok) {\n         beep();\n      }\n      napms(500);\n   }\n   Panel_delete((Object*)signalsPanel);\n\n   return HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n}\n\nstatic Htop_Reaction actionFilterByUser(State* st) {\n   Panel* usersPanel = Panel_new(0, 0, 0, 0, Class(ListItem), true, FunctionBar_newEnterEsc(\"Show   \", \"Cancel \"));\n   Panel_setHeader(usersPanel, \"Show processes of:\");\n   Machine* host = st->host;\n   UsersTable_foreach(host->usersTable, addUserToVector, usersPanel);\n   Vector_insertionSort(usersPanel->items);\n   ListItem* allUsers = ListItem_new(\"All users\", -1);\n   Panel_insert(usersPanel, 0, (Object*) allUsers);\n   const ListItem* picked = (ListItem*) Action_pickFromVector(st, usersPanel, 19, false);\n   if (picked) {\n      if (picked == allUsers) {\n         host->userId = (uid_t)-1;\n      } else {\n         Action_setUserOnly(ListItem_getRef(picked), &host->userId);\n      }\n   }\n   Panel_delete((Object*)usersPanel);\n   return HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n}\n\nHtop_Reaction Action_follow(State* st) {\n   st->host->activeTable->following = MainPanel_selectedRow(st->mainPanel);\n   Panel_setSelectionColor((Panel*)st->mainPanel, PANEL_SELECTION_FOLLOW);\n   return HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionSetup(State* st) {\n   Action_runSetup(st);\n   return HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR | HTOP_RESIZE;\n}\n\nstatic Htop_Reaction actionLsof(State* st) {\n   if (!Action_writeableProcess(st))\n      return HTOP_OK;\n\n   const Process* p = (Process*) Panel_getSelected((Panel*)st->mainPanel);\n   if (!p)\n      return HTOP_OK;\n\n   assert(Object_isA((const Object*) p, (const ObjectClass*) &Process_class));\n\n   OpenFilesScreen* ofs = OpenFilesScreen_new(p);\n   InfoScreen_run((InfoScreen*)ofs);\n   OpenFilesScreen_delete((Object*)ofs);\n   clear();\n   CRT_enableDelay();\n   return HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nstatic Htop_Reaction actionShowLocks(State* st) {\n   if (!Action_readableProcess(st))\n      return HTOP_OK;\n\n   const Process* p = (Process*) Panel_getSelected((Panel*)st->mainPanel);\n   if (!p)\n      return HTOP_OK;\n\n   assert(Object_isA((const Object*) p, (const ObjectClass*) &Process_class));\n\n   ProcessLocksScreen* pls = ProcessLocksScreen_new(p);\n   InfoScreen_run((InfoScreen*)pls);\n   ProcessLocksScreen_delete((Object*)pls);\n   clear();\n   CRT_enableDelay();\n   return HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nstatic Htop_Reaction actionStrace(State* st) {\n   if (!Action_writeableProcess(st))\n      return HTOP_OK;\n\n   const Process* p = (Process*) Panel_getSelected((Panel*)st->mainPanel);\n   if (!p)\n      return HTOP_OK;\n\n   assert(Object_isA((const Object*) p, (const ObjectClass*) &Process_class));\n\n   TraceScreen* ts = TraceScreen_new(p);\n   bool ok = TraceScreen_forkTracer(ts);\n   if (ok) {\n      InfoScreen_run((InfoScreen*)ts);\n   }\n   TraceScreen_delete((Object*)ts);\n   clear();\n   CRT_enableDelay();\n   return HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nstatic Htop_Reaction actionTag(State* st) {\n   Row* r = (Row*) Panel_getSelected((Panel*)st->mainPanel);\n   if (!r)\n      return HTOP_OK;\n\n   Row_toggleTag(r);\n   Panel_onKey((Panel*)st->mainPanel, KEY_DOWN);\n   return HTOP_OK;\n}\n\nstatic Htop_Reaction actionRedraw(ATTR_UNUSED State* st) {\n   clear();\n   // HTOP_RECALCULATE here to make Ctrl-L also refresh the data and not only redraw\n   return HTOP_RECALCULATE | HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nstatic Htop_Reaction actionTogglePauseUpdate(State* st) {\n   st->pauseUpdate = !st->pauseUpdate;\n   return HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_KEEP_FOLLOWING;\n}\n\nstatic const struct {\n   const char* key;\n   bool roInactive;\n   const char* info;\n} helpLeft[] = {\n   { .key = \"      #: \",  .roInactive = false, .info = \"hide/show header meters\" },\n   { .key = \"    Tab: \",  .roInactive = false, .info = \"switch to next screen tab\" },\n   { .key = \" Arrows: \",  .roInactive = false, .info = \"scroll process list\" },\n   { .key = \" Digits: \",  .roInactive = false, .info = \"incremental PID search\" },\n   { .key = \"   F3 /: \",  .roInactive = false, .info = \"incremental name search\" },\n   { .key = \"   F4 \\\\: \", .roInactive = false, .info = \"incremental name filtering\" },\n   { .key = \"   F5 t: \",  .roInactive = false, .info = \"tree view\" },\n   { .key = \"      p: \",  .roInactive = false, .info = \"toggle program path\" },\n   { .key = \"      m: \",  .roInactive = false, .info = \"toggle merged command\" },\n   { .key = \"      Z: \",  .roInactive = false, .info = \"pause/resume process updates\" },\n   { .key = \"      u: \",  .roInactive = false, .info = \"show processes of a single user\" },\n   { .key = \"      H: \",  .roInactive = false, .info = \"hide/show user process threads\" },\n   { .key = \"      K: \",  .roInactive = false, .info = \"hide/show kernel threads\" },\n   { .key = \"      O: \",  .roInactive = false, .info = \"hide/show processes in containers\" },\n   { .key = \"      F: \",  .roInactive = false, .info = \"cursor follows process\" },\n   { .key = \"  + - *: \",  .roInactive = false, .info = \"expand/collapse tree/toggle all\" },\n   { .key = \"N P M T: \",  .roInactive = false, .info = \"sort by PID, CPU%, MEM% or TIME\" },\n   { .key = \"      I: \",  .roInactive = false, .info = \"invert sort order\" },\n   { .key = \" F6 > .: \",  .roInactive = false, .info = \"select sort column\" },\n   { .key = NULL, .info = NULL }\n};\n\nstatic const struct {\n   const char* key;\n   bool roInactive;\n   const char* info;\n} helpRight[] = {\n   { .key = \"  S-Tab: \", .roInactive = false, .info = \"switch to previous screen tab\" },\n   { .key = \"  Space: \", .roInactive = false, .info = \"tag process\" },\n   { .key = \"      c: \", .roInactive = false, .info = \"tag process and its children\" },\n   { .key = \"      U: \", .roInactive = false, .info = \"untag all processes\" },\n   { .key = \"   F9 k: \", .roInactive = true,  .info = \"kill process/tagged processes\" },\n   { .key = \"   F7 ]: \", .roInactive = true,  .info = \"higher priority (root only)\" },\n   { .key = \"   F8 [: \", .roInactive = true,  .info = \"lower priority (+ nice)\" },\n#if (defined(HAVE_LIBHWLOC) || defined(HAVE_AFFINITY))\n   { .key = \"      a: \", .roInactive = true, .info = \"set CPU affinity\" },\n#endif\n   { .key = \"      e: \", .roInactive = false, .info = \"show process environment\" },\n   { .key = \"      i: \", .roInactive = true,  .info = \"set IO priority\" },\n   { .key = \"      l: \", .roInactive = true,  .info = \"list open files with lsof\" },\n   { .key = \"      x: \", .roInactive = false, .info = \"list file locks of process\" },\n   { .key = \"      s: \", .roInactive = true,  .info = \"trace syscalls with strace\" },\n   { .key = \"      w: \", .roInactive = false, .info = \"wrap process command in multiple lines\" },\n#ifdef SCHEDULER_SUPPORT\n   { .key = \"      Y: \", .roInactive = true,  .info = \"set scheduling policy\" },\n#endif\n   { .key = \" F2 C S: \", .roInactive = false, .info = \"setup\" },\n   { .key = \" F1 h ?: \", .roInactive = false, .info = \"show this help screen\" },\n   { .key = \"  F10 q: \", .roInactive = false, .info = \"quit\" },\n   { .key = NULL, .info = NULL }\n};\n\nstatic inline void addattrstr( int attr, const char* str) {\n   attrset(attr);\n   addstr(str);\n}\n\nstatic Htop_Reaction actionHelp(State* st) {\n   clear();\n   attrset(CRT_colors[HELP_BOLD]);\n\n   for (int i = 0; i < LINES - 1; i++)\n      mvhline(i, 0, ' ', COLS);\n\n   int line = 0;\n\n   mvaddstr(line++, 0, \"htop \" VERSION \" - \" COPYRIGHT);\n   mvaddstr(line++, 0, \"Released under the GNU GPLv2+. See 'man' page for more info.\");\n\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   line++;\n   mvaddstr(line++, 0, \"CPU usage bar: \");\n\n#define addbartext(attr, prefix, text)               \\\n   do {                                              \\\n      addattrstr(CRT_colors[DEFAULT_COLOR], prefix); \\\n      addattrstr(attr, text);                        \\\n   } while(0)\n\n   addattrstr(CRT_colors[BAR_BORDER], \"[\");\n   addbartext(CRT_colors[CPU_NICE_TEXT], \"\", \"low\");\n   addbartext(CRT_colors[CPU_NORMAL], \"/\", \"normal\");\n   addbartext(CRT_colors[CPU_SYSTEM], \"/\", \"kernel\");\n   if (st->host->settings->detailedCPUTime) {\n      addbartext(CRT_colors[CPU_IRQ], \"/\", \"irq\");\n      addbartext(CRT_colors[CPU_SOFTIRQ], \"/\", \"soft-irq\");\n      addbartext(CRT_colors[CPU_STEAL], \"/\", \"steal\");\n      addbartext(CRT_colors[CPU_GUEST], \"/\", \"guest\");\n      addbartext(CRT_colors[CPU_IOWAIT], \"/\", \"io-wait\");\n      addbartext(CRT_colors[BAR_SHADOW], \" \", \"used%\");\n   } else {\n      addbartext(CRT_colors[CPU_GUEST], \"/\", \"guest\");\n      addbartext(CRT_colors[BAR_SHADOW], \"                            \", \"used%\");\n   }\n   addattrstr(CRT_colors[BAR_BORDER], \"]\");\n\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   mvaddstr(line++, 0, \"Memory bar:    \");\n   addattrstr(CRT_colors[BAR_BORDER], \"[\");\n   addbartext(CRT_colors[MEMORY_USED], \"\", \"used\");\n   addbartext(CRT_colors[MEMORY_SHARED], \"/\", \"shared\");\n   addbartext(CRT_colors[MEMORY_COMPRESSED], \"/\", \"compressed\");\n   addbartext(CRT_colors[MEMORY_BUFFERS_TEXT], \"/\", \"buffers\");\n   addbartext(CRT_colors[MEMORY_CACHE], \"/\", \"cache\");\n   addbartext(CRT_colors[BAR_SHADOW], \"          \", \"used\");\n   addbartext(CRT_colors[BAR_SHADOW], \"/\", \"total\");\n   addattrstr(CRT_colors[BAR_BORDER], \"]\");\n\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   mvaddstr(line++, 0, \"Swap bar:      \");\n   addattrstr(CRT_colors[BAR_BORDER], \"[\");\n   addbartext(CRT_colors[SWAP], \"\", \"used\");\n#ifdef HTOP_LINUX\n   addbartext(CRT_colors[SWAP_CACHE], \"/\", \"cache\");\n   addbartext(CRT_colors[SWAP_FRONTSWAP], \"/\", \"frontswap\");\n#else\n   addbartext(CRT_colors[SWAP_CACHE], \"      \", \"\");\n#endif\n   addbartext(CRT_colors[BAR_SHADOW], \"                          \", \"used\");\n   addbartext(CRT_colors[BAR_SHADOW], \"/\", \"total\");\n   addattrstr(CRT_colors[BAR_BORDER], \"]\");\n\n   line++;\n\n#undef addbartext\n\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   mvaddstr(line++, 0, \"Type and layout of header meters are configurable in the setup screen.\");\n   if (CRT_colorScheme == COLORSCHEME_MONOCHROME) {\n      mvaddstr(line, 0, \"In monochrome, meters display as different chars, in order: |#*@$%&.\");\n   }\n   line++;\n\n#define addattrstatestr(attr, state, desc)              \\\n   do {                                                 \\\n      addattrstr(attr, state);                          \\\n      addattrstr(CRT_colors[DEFAULT_COLOR], \": \" desc); \\\n   } while(0)\n\n   mvaddstr(line, 0, \"Process state: \");\n   addattrstatestr(CRT_colors[PROCESS_RUN_STATE], \"R\", \"running; \");\n   addattrstatestr(CRT_colors[PROCESS_SHADOW], \"S\", \"sleeping; \");\n   addattrstatestr(CRT_colors[PROCESS_RUN_STATE], \"t\", \"traced/stopped; \");\n   addattrstatestr(CRT_colors[PROCESS_D_STATE], \"Z\", \"zombie; \");\n   addattrstatestr(CRT_colors[PROCESS_D_STATE], \"D\", \"disk sleep\");\n   attrset(CRT_colors[DEFAULT_COLOR]);\n\n#undef addattrstatestr\n\n   line += 2;\n\n   const bool readonly = Settings_isReadonly();\n\n   int item;\n   for (item = 0; helpLeft[item].key; item++) {\n      attrset((helpLeft[item].roInactive && readonly) ? CRT_colors[HELP_SHADOW] : CRT_colors[DEFAULT_COLOR]);\n      mvaddstr(line + item, 10, helpLeft[item].info);\n      attrset((helpLeft[item].roInactive && readonly) ? CRT_colors[HELP_SHADOW] : CRT_colors[HELP_BOLD]);\n      mvaddstr(line + item, 1,  helpLeft[item].key);\n      if (String_eq(helpLeft[item].key, \"      H: \")) {\n         attrset((helpLeft[item].roInactive && readonly) ? CRT_colors[HELP_SHADOW] : CRT_colors[PROCESS_THREAD]);\n         mvaddstr(line + item, 33, \"threads\");\n      } else if (String_eq(helpLeft[item].key, \"      K: \")) {\n         attrset((helpLeft[item].roInactive && readonly) ? CRT_colors[HELP_SHADOW] : CRT_colors[PROCESS_THREAD]);\n         mvaddstr(line + item, 27, \"threads\");\n      }\n   }\n   int leftHelpItems = item;\n\n   for (item = 0; helpRight[item].key; item++) {\n      attrset((helpRight[item].roInactive && readonly) ? CRT_colors[HELP_SHADOW] : CRT_colors[HELP_BOLD]);\n      mvaddstr(line + item, 43, helpRight[item].key);\n      attrset((helpRight[item].roInactive && readonly) ? CRT_colors[HELP_SHADOW] : CRT_colors[DEFAULT_COLOR]);\n      mvaddstr(line + item, 52, helpRight[item].info);\n   }\n   line += MAXIMUM(leftHelpItems, item);\n   line++;\n\n   attrset(CRT_colors[HELP_BOLD]);\n   mvaddstr(line++, 0, \"Press any key to return.\");\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   refresh();\n   CRT_readKey();\n   clear();\n\n   return HTOP_RECALCULATE | HTOP_REDRAW_BAR | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionUntagAll(State* st) {\n   for (int i = 0; i < Panel_size((Panel*)st->mainPanel); i++) {\n      Row* row = (Row*) Panel_get((Panel*)st->mainPanel, i);\n      row->tag = false;\n   }\n   return HTOP_REFRESH;\n}\n\nstatic Htop_Reaction actionTagAllChildren(State* st) {\n   Row* row = (Row*) Panel_getSelected((Panel*)st->mainPanel);\n   if (!row)\n      return HTOP_OK;\n\n   tagAllChildren((Panel*)st->mainPanel, row);\n   return HTOP_OK;\n}\n\nstatic Htop_Reaction actionShowEnvScreen(State* st) {\n   if (!Action_readableProcess(st))\n      return HTOP_OK;\n\n   Process* p = (Process*) Panel_getSelected((Panel*)st->mainPanel);\n   if (!p)\n      return HTOP_OK;\n\n   assert(Object_isA((const Object*) p, (const ObjectClass*) &Process_class));\n\n   EnvScreen* es = EnvScreen_new(p);\n   InfoScreen_run((InfoScreen*)es);\n   EnvScreen_delete((Object*)es);\n   clear();\n   CRT_enableDelay();\n   return HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nstatic Htop_Reaction actionShowCommandScreen(State* st) {\n   if (!Action_readableProcess(st))\n      return HTOP_OK;\n\n   Process* p = (Process*) Panel_getSelected((Panel*)st->mainPanel);\n   if (!p)\n      return HTOP_OK;\n\n   assert(Object_isA((const Object*) p, (const ObjectClass*) &Process_class));\n\n   CommandScreen* cmdScr = CommandScreen_new(p);\n   InfoScreen_run((InfoScreen*)cmdScr);\n   CommandScreen_delete((Object*)cmdScr);\n   clear();\n   CRT_enableDelay();\n   return HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nvoid Action_setBindings(Htop_Action* keys) {\n   keys[' '] = actionTag;\n   keys['#'] = actionToggleHideMeters;\n   keys['*'] = actionExpandOrCollapseAllBranches;\n   keys['+'] = actionExpandOrCollapse;\n   keys[','] = actionSetSortColumn;\n   keys['-'] = actionExpandOrCollapse;\n   keys['.'] = actionSetSortColumn;\n   keys['/'] = actionIncSearch;\n   keys['<'] = actionSetSortColumn;\n   keys['='] = actionExpandOrCollapse;\n   keys['>'] = actionSetSortColumn;\n   keys['?'] = actionHelp;\n   keys['C'] = actionSetup;\n   keys['F'] = Action_follow;\n   keys['H'] = actionToggleUserlandThreads;\n   keys['I'] = actionInvertSortOrder;\n   keys['K'] = actionToggleKernelThreads;\n   keys['M'] = actionSortByMemory;\n   keys['N'] = actionSortByPID;\n   keys['O'] = actionToggleRunningInContainer;\n   keys['P'] = actionSortByCPU;\n   keys['S'] = actionSetup;\n   keys['T'] = actionSortByTime;\n   keys['U'] = actionUntagAll;\n#ifdef SCHEDULER_SUPPORT\n   keys['Y'] = actionSetSchedPolicy;\n#endif\n   keys['Z'] = actionTogglePauseUpdate;\n   keys['['] = actionLowerPriority;\n   keys['\\014'] = actionRedraw; // Ctrl+L\n   keys['\\177'] = actionCollapseIntoParent;\n   keys['\\\\'] = actionIncFilter;\n   keys[']'] = actionHigherPriority;\n   keys['a'] = actionSetAffinity;\n   keys['c'] = actionTagAllChildren;\n   keys['e'] = actionShowEnvScreen;\n   keys['h'] = actionHelp;\n   keys['k'] = actionKill;\n   keys['l'] = actionLsof;\n   keys['m'] = actionToggleMergedCommand;\n   keys['p'] = actionToggleProgramPath;\n   keys['q'] = actionQuit;\n   keys['s'] = actionStrace;\n   keys['t'] = actionToggleTreeView;\n   keys['u'] = actionFilterByUser;\n   keys['w'] = actionShowCommandScreen;\n   keys['x'] = actionShowLocks;\n   keys[KEY_F(1)] = actionHelp;\n   keys[KEY_F(2)] = actionSetup;\n   keys[KEY_F(3)] = actionIncSearch;\n   keys[KEY_F(4)] = actionIncFilter;\n   keys[KEY_F(5)] = actionToggleTreeView;\n   keys[KEY_F(6)] = actionSetSortColumn;\n   keys[KEY_F(7)] = actionHigherPriority;\n   keys[KEY_F(8)] = actionLowerPriority;\n   keys[KEY_F(9)] = actionKill;\n   keys[KEY_F(10)] = actionQuit;\n   keys[KEY_F(18)] = actionExpandCollapseOrSortColumn;\n   keys[KEY_RECLICK] = actionExpandOrCollapse;\n   keys[KEY_SHIFT_TAB] = actionPrevScreen;\n   keys['\\t'] = actionNextScreen;\n}\n"
        },
        {
          "name": "Action.h",
          "type": "blob",
          "size": 1.5654296875,
          "content": "#ifndef HEADER_Action\n#define HEADER_Action\n/*\nhtop - Action.h\n(C) 2015 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n#include <sys/types.h>\n\n#include \"Header.h\"\n#include \"Machine.h\"\n#include \"Object.h\"\n#include \"Panel.h\"\n#include \"Process.h\"\n#include \"Settings.h\"\n\n\ntypedef enum {\n   HTOP_OK              = 0x00,\n   HTOP_REFRESH         = 0x01,\n   HTOP_RECALCULATE     = 0x02 | HTOP_REFRESH,\n   HTOP_SAVE_SETTINGS   = 0x04,\n   HTOP_KEEP_FOLLOWING  = 0x08,\n   HTOP_QUIT            = 0x10,\n   HTOP_REDRAW_BAR      = 0x20,\n   HTOP_UPDATE_PANELHDR = 0x40 | HTOP_REFRESH,\n   HTOP_RESIZE          = 0x80 | HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR,\n} Htop_Reaction;\n\nstruct MainPanel_; // IWYU pragma: keep\n\ntypedef struct State_ {\n   Machine* host;\n   struct MainPanel_* mainPanel;\n   Header* header;\n   bool pauseUpdate;\n   bool hideSelection;\n   bool hideMeters;\n} State;\n\nstatic inline bool State_hideFunctionBar(const State* st) {\n   const Settings* settings = st->host->settings;\n   return settings->hideFunctionBar == 2 || (settings->hideFunctionBar == 1 && st->hideSelection);\n}\n\ntypedef Htop_Reaction (*Htop_Action)(State* st);\n\nObject* Action_pickFromVector(State* st, Panel* list, int x, bool follow);\n\nbool Action_setUserOnly(const char* userName, uid_t* userId);\n\nHtop_Reaction Action_setSortKey(Settings* settings, ProcessField sortKey);\n\nHtop_Reaction Action_setScreenTab(State* st, int x);\n\nHtop_Reaction Action_follow(State* st);\n\nvoid Action_setBindings(Htop_Action* keys);\n\n#endif\n"
        },
        {
          "name": "Affinity.c",
          "type": "blob",
          "size": 3.4580078125,
          "content": "/*\nhtop - Affinity.c\n(C) 2004-2011 Hisham H. Muhammad\n(C) 2020 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Affinity.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n\n#include \"Process.h\"\n#include \"XUtils.h\"\n\n#if defined(HAVE_LIBHWLOC)\n#include <hwloc.h>\n#include <hwloc/bitmap.h>\n#ifdef __linux__\n#define HTOP_HWLOC_CPUBIND_FLAG HWLOC_CPUBIND_THREAD\n#else\n#define HTOP_HWLOC_CPUBIND_FLAG HWLOC_CPUBIND_PROCESS\n#endif\n#elif defined(HAVE_AFFINITY)\n#include <sched.h>\n#endif\n\n\nAffinity* Affinity_new(Machine* host) {\n   Affinity* this = xCalloc(1, sizeof(Affinity));\n   this->size = 8;\n   this->cpus = xCalloc(this->size, sizeof(unsigned int));\n   this->host = host;\n   return this;\n}\n\nvoid Affinity_delete(Affinity* this) {\n   free(this->cpus);\n   free(this);\n}\n\nvoid Affinity_add(Affinity* this, unsigned int id) {\n   if (this->used == this->size) {\n      this->size *= 2;\n      this->cpus = xRealloc(this->cpus, sizeof(unsigned int) * this->size);\n   }\n   this->cpus[this->used] = id;\n   this->used++;\n}\n\n#if defined(HAVE_LIBHWLOC)\n\nstatic Affinity* Affinity_get(const Process* p, Machine* host) {\n   hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();\n   bool ok = (hwloc_get_proc_cpubind(host->topology, Process_getPid(p), cpuset, HTOP_HWLOC_CPUBIND_FLAG) == 0);\n   Affinity* affinity = NULL;\n   if (ok) {\n      affinity = Affinity_new(host);\n      if (hwloc_bitmap_last(cpuset) == -1) {\n         for (unsigned int i = 0; i < host->existingCPUs; i++) {\n            Affinity_add(affinity, i);\n         }\n      } else {\n         int id;\n         hwloc_bitmap_foreach_begin(id, cpuset)\n            Affinity_add(affinity, (unsigned)id);\n         hwloc_bitmap_foreach_end();\n      }\n   }\n   hwloc_bitmap_free(cpuset);\n   return affinity;\n}\n\nstatic bool Affinity_set(Process* p, Arg arg) {\n   Affinity* this = arg.v;\n   hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();\n   for (unsigned int i = 0; i < this->used; i++) {\n      hwloc_bitmap_set(cpuset, this->cpus[i]);\n   }\n   bool ok = (hwloc_set_proc_cpubind(this->host->topology, Process_getPid(p), cpuset, HTOP_HWLOC_CPUBIND_FLAG) == 0);\n   hwloc_bitmap_free(cpuset);\n   return ok;\n}\n\n#elif defined(HAVE_AFFINITY)\n\nstatic Affinity* Affinity_get(const Process* p, Machine* host) {\n   cpu_set_t cpuset;\n   bool ok = (sched_getaffinity(Process_getPid(p), sizeof(cpu_set_t), &cpuset) == 0);\n   if (!ok)\n      return NULL;\n\n   Affinity* affinity = Affinity_new(host);\n   for (unsigned int i = 0; i < host->existingCPUs; i++) {\n      if (CPU_ISSET(i, &cpuset)) {\n         Affinity_add(affinity, i);\n      }\n   }\n   return affinity;\n}\n\nstatic bool Affinity_set(Process* p, Arg arg) {\n   Affinity* this = arg.v;\n   cpu_set_t cpuset;\n   CPU_ZERO(&cpuset);\n   for (unsigned int i = 0; i < this->used; i++) {\n      CPU_SET(this->cpus[i], &cpuset);\n   }\n   bool ok = (sched_setaffinity(Process_getPid(p), sizeof(unsigned long), &cpuset) == 0);\n   return ok;\n}\n\n#endif\n\n#if defined(HAVE_LIBHWLOC) || defined(HAVE_AFFINITY)\n\nbool Affinity_rowSet(Row* row, Arg arg) {\n   Process* p = (Process*) row;\n   assert(Object_isA((const Object*) p, (const ObjectClass*) &Process_class));\n   return Affinity_set(p, arg);\n}\n\nAffinity* Affinity_rowGet(const Row* row, Machine* host) {\n   const Process* p = (const Process*) row;\n   assert(Object_isA((const Object*) p, (const ObjectClass*) &Process_class));\n   return Affinity_get(p, host);\n}\n\n#endif /* HAVE_LIBHWLOC || HAVE_AFFINITY */\n"
        },
        {
          "name": "Affinity.h",
          "type": "blob",
          "size": 0.9560546875,
          "content": "#ifndef HEADER_Affinity\n#define HEADER_Affinity\n/*\nhtop - Affinity.h\n(C) 2004-2011 Hisham H. Muhammad\n(C) 2020,2023 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Machine.h\"\n\n#if defined(HAVE_LIBHWLOC) || defined(HAVE_AFFINITY)\n#include <stdbool.h>\n\n#include \"Object.h\"\n#include \"Row.h\"\n#endif\n\n\n#if defined(HAVE_LIBHWLOC) && defined(HAVE_AFFINITY)\n#error hwloc and affinity support are mutual exclusive.\n#endif\n\n\ntypedef struct Affinity_ {\n   Machine* host;\n   unsigned int size;\n   unsigned int used;\n   unsigned int* cpus;\n} Affinity;\n\nAffinity* Affinity_new(Machine* host);\n\nvoid Affinity_delete(Affinity* this);\n\nvoid Affinity_add(Affinity* this, unsigned int id);\n\n#if defined(HAVE_LIBHWLOC) || defined(HAVE_AFFINITY)\n\nAffinity* Affinity_rowGet(const Row* row, Machine* host);\n\nbool Affinity_rowSet(Row* row, Arg arg);\n\n#endif /* HAVE_LIBHWLOC || HAVE_AFFINITY */\n\n#endif\n"
        },
        {
          "name": "AffinityPanel.c",
          "type": "blob",
          "size": 12.3046875,
          "content": "/*\nhtop - AffinityPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"AffinityPanel.h\"\n\n#include <assert.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Object.h\"\n#include \"ProvideCurses.h\"\n#include \"RichString.h\"\n#include \"Settings.h\"\n#include \"Vector.h\"\n#include \"XUtils.h\"\n\n#ifdef HAVE_LIBHWLOC\n#include <hwloc.h>\n#include <hwloc/bitmap.h>\n#endif\n\n\ntypedef struct MaskItem_ {\n   Object super;\n   char* text;\n   char* indent; /* used also as an condition whether this is a tree node */\n   int value; /* tri-state: 0 - off, 1 - some set, 2 - all set */\n   int sub_tree; /* tri-state: 0 - no sub-tree, 1 - open sub-tree, 2 - closed sub-tree */\n   Vector* children;\n   #ifdef HAVE_LIBHWLOC\n   bool ownCpuset;\n   hwloc_bitmap_t cpuset;\n   #else\n   int cpu;\n   #endif\n} MaskItem;\n\nstatic void MaskItem_delete(Object* cast) {\n   MaskItem* this = (MaskItem*) cast;\n   free(this->text);\n   free(this->indent);\n   Vector_delete(this->children);\n   #ifdef HAVE_LIBHWLOC\n   if (this->ownCpuset)\n      hwloc_bitmap_free(this->cpuset);\n   #endif\n   free(this);\n}\n\nstatic void MaskItem_display(const Object* cast, RichString* out) {\n   const MaskItem* this = (const MaskItem*)cast;\n   assert (this != NULL);\n   RichString_appendAscii(out, CRT_colors[CHECK_BOX], \"[\");\n   if (this->value == 2) {\n      RichString_appendAscii(out, CRT_colors[CHECK_MARK], \"x\");\n   } else if (this->value == 1) {\n      RichString_appendAscii(out, CRT_colors[CHECK_MARK], \"o\");\n   } else {\n      RichString_appendAscii(out, CRT_colors[CHECK_MARK], \" \");\n   }\n   RichString_appendAscii(out, CRT_colors[CHECK_BOX], \"]\");\n   RichString_appendAscii(out, CRT_colors[CHECK_TEXT], \" \");\n   if (this->indent) {\n      RichString_appendWide(out, CRT_colors[PROCESS_TREE], this->indent);\n      RichString_appendWide(out, CRT_colors[PROCESS_TREE],\n                            this->sub_tree == 2\n                            ? CRT_treeStr[TREE_STR_OPEN]\n                            : CRT_treeStr[TREE_STR_SHUT]);\n      RichString_appendAscii(out, CRT_colors[CHECK_TEXT], \" \");\n   }\n   RichString_appendWide(out, CRT_colors[CHECK_TEXT], this->text);\n}\n\nstatic const ObjectClass MaskItem_class = {\n   .display = MaskItem_display,\n   .delete  = MaskItem_delete\n};\n\n#ifdef HAVE_LIBHWLOC\n\nstatic MaskItem* MaskItem_newMask(const char* text, const char* indent, hwloc_bitmap_t cpuset, bool owner) {\n   MaskItem* this = AllocThis(MaskItem);\n   this->text = xStrdup(text);\n   this->indent = xStrdup(indent); /* nonnull for tree node */\n   this->value = 0;\n   this->ownCpuset = owner;\n   this->cpuset = cpuset;\n   this->sub_tree = hwloc_bitmap_weight(cpuset) > 1 ? 1 : 0;\n   this->children = Vector_new(Class(MaskItem), true, DEFAULT_SIZE);\n   return this;\n}\n\n#endif\n\nstatic MaskItem* MaskItem_newSingleton(const char* text, int cpu, bool isSet) {\n   MaskItem* this = AllocThis(MaskItem);\n   this->text = xStrdup(text);\n   this->indent = NULL; /* not a tree node */\n   this->sub_tree = 0;\n   this->children = Vector_new(Class(MaskItem), true, DEFAULT_SIZE);\n\n   #ifdef HAVE_LIBHWLOC\n   this->ownCpuset = true;\n   this->cpuset = hwloc_bitmap_alloc();\n   hwloc_bitmap_set(this->cpuset, cpu);\n   #else\n   this->cpu = cpu;\n   #endif\n   this->value = isSet ? 2 : 0;\n\n   return this;\n}\n\ntypedef struct AffinityPanel_ {\n   Panel super;\n   Machine* host;\n   bool topoView;\n   Vector* cpuids;\n   unsigned width;\n\n   #ifdef HAVE_LIBHWLOC\n   MaskItem* topoRoot;\n   hwloc_const_cpuset_t allCpuset;\n   hwloc_bitmap_t workCpuset;\n   #endif\n} AffinityPanel;\n\nstatic void AffinityPanel_delete(Object* cast) {\n   AffinityPanel* this = (AffinityPanel*) cast;\n   Panel* super = (Panel*) this;\n   Panel_done(super);\n   Vector_delete(this->cpuids);\n   #ifdef HAVE_LIBHWLOC\n   hwloc_bitmap_free(this->workCpuset);\n   MaskItem_delete((Object*) this->topoRoot);\n   #endif\n   free(this);\n}\n\n#ifdef HAVE_LIBHWLOC\n\nstatic void AffinityPanel_updateItem(AffinityPanel* this, MaskItem* item) {\n   Panel* super = (Panel*) this;\n\n   item->value = hwloc_bitmap_isincluded(item->cpuset, this->workCpuset) ? 2 :\n                 hwloc_bitmap_intersects(item->cpuset, this->workCpuset) ? 1 : 0;\n\n   Panel_add(super, (Object*) item);\n}\n\nstatic void AffinityPanel_updateTopo(AffinityPanel* this, MaskItem* item) {\n   AffinityPanel_updateItem(this, item);\n\n   if (item->sub_tree == 2)\n      return;\n\n   for (int i = 0; i < Vector_size(item->children); i++)\n      AffinityPanel_updateTopo(this, (MaskItem*) Vector_get(item->children, i));\n}\n\n#endif\n\nstatic void AffinityPanel_update(AffinityPanel* this, bool keepSelected) {\n   Panel* super = (Panel*) this;\n\n   FunctionBar_setLabel(super->currentBar, KEY_F(3), this->topoView ? \"Collapse/Expand\" : \"\");\n\n   int oldSelected = Panel_getSelectedIndex(super);\n   Panel_prune(super);\n\n   #ifdef HAVE_LIBHWLOC\n   if (this->topoView) {\n      AffinityPanel_updateTopo(this, this->topoRoot);\n   } else {\n      for (int i = 0; i < Vector_size(this->cpuids); i++) {\n         AffinityPanel_updateItem(this, (MaskItem*) Vector_get(this->cpuids, i));\n      }\n   }\n   #else\n   Panel_splice(super, this->cpuids);\n   #endif\n\n   if (keepSelected)\n      Panel_setSelected(super, oldSelected);\n\n   super->needsRedraw = true;\n}\n\nstatic HandlerResult AffinityPanel_eventHandler(Panel* super, int ch) {\n   AffinityPanel* this = (AffinityPanel*) super;\n   HandlerResult result = IGNORED;\n   MaskItem* selected = (MaskItem*) Panel_getSelected(super);\n   bool keepSelected = true;\n\n   switch (ch) {\n      case KEY_MOUSE:\n      case KEY_RECLICK:\n      case ' ':\n         #ifdef HAVE_LIBHWLOC\n         if (selected->value == 2) {\n            /* Item was selected, so remove this mask from the top cpuset. */\n            hwloc_bitmap_andnot(this->workCpuset, this->workCpuset, selected->cpuset);\n            selected->value = 0;\n         } else {\n            /* Item was not or only partial selected, so set all bits from this object\n               in the top cpuset. */\n            hwloc_bitmap_or(this->workCpuset, this->workCpuset, selected->cpuset);\n            selected->value = 2;\n         }\n         #else\n         selected->value = selected->value ? 0 : 2; /* toggle between 0 and 2 */\n         #endif\n\n         result = HANDLED;\n         break;\n\n#ifdef HAVE_LIBHWLOC\n\n      case KEY_F(1):\n         hwloc_bitmap_copy(this->workCpuset, this->allCpuset);\n         result = HANDLED;\n         break;\n\n      case KEY_F(2):\n         this->topoView = !this->topoView;\n         keepSelected = false;\n\n         result = HANDLED;\n         break;\n\n      case KEY_F(3):\n      case '-':\n      case '+':\n         if (selected->sub_tree)\n            selected->sub_tree = 1 + !(selected->sub_tree - 1); /* toggle between 1 and 2 */\n\n         result = HANDLED;\n         break;\n\n#endif\n\n      case 0x0a:\n      case 0x0d:\n      case KEY_ENTER:\n         result = BREAK_LOOP;\n         break;\n   }\n\n   if (HANDLED == result)\n      AffinityPanel_update(this, keepSelected);\n\n   return result;\n}\n\n#ifdef HAVE_LIBHWLOC\n\nstatic MaskItem* AffinityPanel_addObject(AffinityPanel* this, hwloc_obj_t obj, unsigned indent, MaskItem* parent) {\n   const char* type_name = hwloc_obj_type_string(obj->type);\n   const char* index_prefix = \"#\";\n   unsigned depth = obj->depth;\n   unsigned index = obj->logical_index;\n   size_t off = 0, left = 10 * depth;\n   char buf[64], indent_buf[left + 1];\n\n   if (obj->type == HWLOC_OBJ_PU) {\n      index = Settings_cpuId(this->host->settings, obj->os_index);\n      type_name = \"CPU\";\n      index_prefix = \"\";\n   }\n\n   indent_buf[0] = '\\0';\n   if (depth > 0) {\n      for (unsigned i = 1; i < depth; i++) {\n         xSnprintf(&indent_buf[off], left, \"%s  \", (indent & (1U << i)) ? CRT_treeStr[TREE_STR_VERT] : \" \");\n         size_t len = strlen(&indent_buf[off]);\n         off += len;\n         left -= len;\n      }\n      xSnprintf(&indent_buf[off], left, \"%s\",\n                obj->next_sibling ? CRT_treeStr[TREE_STR_RTEE] : CRT_treeStr[TREE_STR_BEND]);\n      // Uncomment when further appending to indent_buf\n      //size_t len = strlen(&indent_buf[off]);\n      //off += len;\n      //left -= len;\n   }\n\n   xSnprintf(buf, sizeof(buf), \"%s %s%u\", type_name, index_prefix, index);\n\n   MaskItem* item = MaskItem_newMask(buf, indent_buf, obj->complete_cpuset, false);\n   if (parent)\n      Vector_add(parent->children, item);\n\n   if (item->sub_tree && parent && parent->sub_tree == 1) {\n      /* if obj is fully included or fully excluded, collapse the item */\n      hwloc_bitmap_t result = hwloc_bitmap_alloc();\n      hwloc_bitmap_and(result, obj->complete_cpuset, this->workCpuset);\n      int weight = hwloc_bitmap_weight(result);\n      hwloc_bitmap_free(result);\n      if (weight == 0 || weight == (hwloc_bitmap_weight(this->workCpuset) + hwloc_bitmap_weight(obj->complete_cpuset))) {\n         item->sub_tree = 2;\n      }\n   }\n\n   /* \"[x] \" + \"|- \" * depth + (\"- \")?(if root node) + name */\n   unsigned width = 4 + 3 * depth + (2 * !depth) + strlen(buf);\n   if (width > this->width) {\n      this->width = width;\n   }\n\n   return item;\n}\n\nstatic MaskItem* AffinityPanel_buildTopology(AffinityPanel* this, hwloc_obj_t obj, unsigned indent, MaskItem* parent) {\n   MaskItem* item = AffinityPanel_addObject(this, obj, indent, parent);\n   if (obj->next_sibling) {\n      indent |= (1U << obj->depth);\n   } else {\n      indent &= ~(1U << obj->depth);\n   }\n\n   for (unsigned i = 0; i < obj->arity; i++) {\n      AffinityPanel_buildTopology(this, obj->children[i], indent, item);\n   }\n\n   return parent == NULL ? item : NULL;\n}\n\n#endif\n\nconst PanelClass AffinityPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = AffinityPanel_delete\n   },\n   .eventHandler = AffinityPanel_eventHandler\n};\n\nstatic const char* const AffinityPanelFunctions[] = {\n   \"Set    \",\n   \"Cancel \",\n   #ifdef HAVE_LIBHWLOC\n   \"All\",\n   \"Topology\",\n   \"               \",\n   #endif\n   NULL\n};\nstatic const char* const AffinityPanelKeys[] = {\"Enter\", \"Esc\", \"F1\", \"F2\", \"F3\"};\nstatic const int AffinityPanelEvents[] = {13, 27, KEY_F(1), KEY_F(2), KEY_F(3)};\n\nPanel* AffinityPanel_new(Machine* host, const Affinity* affinity, int* width) {\n   AffinityPanel* this = AllocThis(AffinityPanel);\n   Panel* super = (Panel*) this;\n   Panel_init(super, 1, 1, 1, 1, Class(MaskItem), false, FunctionBar_new(AffinityPanelFunctions, AffinityPanelKeys, AffinityPanelEvents));\n\n   this->host = host;\n   /* defaults to 15, this also includes the gap between the panels,\n    * but this will be added by the caller */\n   this->width = 14;\n\n   this->cpuids   = Vector_new(Class(MaskItem), true, DEFAULT_SIZE);\n\n   #ifdef HAVE_LIBHWLOC\n   this->topoView = host->settings->topologyAffinity;\n   #else\n   this->topoView = false;\n   #endif\n\n   #ifdef HAVE_LIBHWLOC\n   this->allCpuset  = hwloc_topology_get_complete_cpuset(host->topology);\n   this->workCpuset = hwloc_bitmap_alloc();\n   #endif\n\n   Panel_setHeader(super, \"Use CPUs:\");\n\n   unsigned int curCpu = 0;\n   for (unsigned int i = 0; i < host->existingCPUs; i++) {\n      if (!Machine_isCPUonline(host, i))\n         continue;\n\n      char number[16];\n      xSnprintf(number, 9, \"CPU %d\", Settings_cpuId(host->settings, i));\n      unsigned cpu_width = 4 + strlen(number);\n      if (cpu_width > this->width) {\n         this->width = cpu_width;\n      }\n\n      bool isSet = false;\n      if (curCpu < affinity->used && affinity->cpus[curCpu] == i) {\n         #ifdef HAVE_LIBHWLOC\n         hwloc_bitmap_set(this->workCpuset, i);\n         #endif\n         isSet = true;\n         curCpu++;\n      }\n\n      MaskItem* cpuItem = MaskItem_newSingleton(number, i, isSet);\n      Vector_add(this->cpuids, (Object*) cpuItem);\n   }\n\n   #ifdef HAVE_LIBHWLOC\n   this->topoRoot = AffinityPanel_buildTopology(this, hwloc_get_root_obj(host->topology), 0, NULL);\n   #endif\n\n   if (width) {\n      *width = this->width;\n   }\n\n   AffinityPanel_update(this, false);\n\n   return super;\n}\n\nAffinity* AffinityPanel_getAffinity(Panel* super, Machine* host) {\n   const AffinityPanel* this = (AffinityPanel*) super;\n   Affinity* affinity = Affinity_new(host);\n\n   #ifdef HAVE_LIBHWLOC\n   int i;\n   hwloc_bitmap_foreach_begin(i, this->workCpuset)\n      Affinity_add(affinity, (unsigned)i);\n   hwloc_bitmap_foreach_end();\n   #else\n   for (int i = 0; i < Vector_size(this->cpuids); i++) {\n      const MaskItem* item = (const MaskItem*)Vector_get(this->cpuids, i);\n      if (item->value) {\n         Affinity_add(affinity, item->cpu);\n      }\n   }\n   #endif\n\n   return affinity;\n}\n"
        },
        {
          "name": "AffinityPanel.h",
          "type": "blob",
          "size": 0.4716796875,
          "content": "#ifndef HEADER_AffinityPanel\n#define HEADER_AffinityPanel\n/*\nhtop - AffinityPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Affinity.h\"\n#include \"Machine.h\"\n#include \"Panel.h\"\n\n\nextern const PanelClass AffinityPanel_class;\n\nPanel* AffinityPanel_new(Machine* host, const Affinity* affinity, int* width);\n\nAffinity* AffinityPanel_getAffinity(Panel* super, Machine* host);\n\n#endif\n"
        },
        {
          "name": "AvailableColumnsPanel.c",
          "type": "blob",
          "size": 4.7841796875,
          "content": "/*\nhtop - AvailableColumnsPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"AvailableColumnsPanel.h\"\n\n#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"ColumnsPanel.h\"\n#include \"DynamicColumn.h\"\n#include \"FunctionBar.h\"\n#include \"Hashtable.h\"\n#include \"ListItem.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"Process.h\"\n#include \"ProvideCurses.h\"\n#include \"RowField.h\"\n#include \"XUtils.h\"\n\n\nstatic const char* const AvailableColumnsFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"Add   \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nstatic void AvailableColumnsPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   AvailableColumnsPanel* this = (AvailableColumnsPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic void AvailableColumnsPanel_insert(AvailableColumnsPanel* this, int at, int key) {\n   const char* name;\n   if (key >= ROW_DYNAMIC_FIELDS)\n      name = DynamicColumn_name(key);\n   else\n      name = Process_fields[key].name;\n   Panel_insert(this->columns, at, (Object*) ListItem_new(name, key));\n}\n\nstatic HandlerResult AvailableColumnsPanel_eventHandler(Panel* super, int ch) {\n   AvailableColumnsPanel* this = (AvailableColumnsPanel*) super;\n   HandlerResult result = IGNORED;\n\n   switch (ch) {\n      case 13:\n      case KEY_ENTER:\n      case KEY_F(5): {\n         const ListItem* selected = (ListItem*) Panel_getSelected(super);\n         if (!selected)\n            break;\n\n         int at = Panel_getSelectedIndex(this->columns);\n         AvailableColumnsPanel_insert(this, at, selected->key);\n         Panel_setSelected(this->columns, at + 1);\n         ColumnsPanel_update(this->columns);\n         result = HANDLED;\n         break;\n      }\n      default:\n         if (0 < ch && ch < 255 && isgraph((unsigned char)ch))\n            result = Panel_selectByTyping(super, ch);\n         break;\n   }\n   return result;\n}\n\nconst PanelClass AvailableColumnsPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = AvailableColumnsPanel_delete\n   },\n   .eventHandler = AvailableColumnsPanel_eventHandler\n};\n\nstatic void AvailableColumnsPanel_addDynamicColumn(ht_key_t key, void* value, void* data) {\n   const DynamicColumn* column = (const DynamicColumn*) value;\n   if (column->table) /* DynamicScreen, handled differently */\n      return;\n   AvailableColumnsPanel* this = (AvailableColumnsPanel*) data;\n   const char* title = column->heading ? column->heading : column->name;\n   const char* text = column->description ? column->description : column->caption;\n   char description[256];\n   if (text)\n      xSnprintf(description, sizeof(description), \"%s - %s\", title, text);\n   else\n      xSnprintf(description, sizeof(description), \"%s\", title);\n   Panel_add(&this->super, (Object*) ListItem_new(description, key));\n}\n\n// Handle DynamicColumns entries in the AvailableColumnsPanel\nstatic void AvailableColumnsPanel_addDynamicColumns(AvailableColumnsPanel* this, Hashtable* dynamicColumns) {\n   assert(dynamicColumns);\n   Hashtable_foreach(dynamicColumns, AvailableColumnsPanel_addDynamicColumn, this);\n}\n\n// Handle remaining Platform Meter entries in the AvailableColumnsPanel\nstatic void AvailableColumnsPanel_addPlatformColumns(AvailableColumnsPanel* this) {\n   for (int i = 1; i < LAST_PROCESSFIELD; i++) {\n      if (Process_fields[i].description) {\n         char description[256];\n         xSnprintf(description, sizeof(description), \"%s - %s\", Process_fields[i].name, Process_fields[i].description);\n         Panel_add(&this->super, (Object*) ListItem_new(description, i));\n      }\n   }\n}\n\n// Handle DynamicColumns entries associated with DynamicScreens\nstatic void AvailableColumnsPanel_addDynamicScreens(AvailableColumnsPanel* this, const char* screen) {\n   Platform_addDynamicScreenAvailableColumns(&this->super, screen);\n}\n\nvoid AvailableColumnsPanel_fill(AvailableColumnsPanel* this, const char* dynamicScreen, Hashtable* dynamicColumns) {\n   Panel* super = (Panel*) this;\n   Panel_prune(super);\n   if (dynamicScreen) {\n      AvailableColumnsPanel_addDynamicScreens(this, dynamicScreen);\n   } else {\n      AvailableColumnsPanel_addPlatformColumns(this);\n      AvailableColumnsPanel_addDynamicColumns(this, dynamicColumns);\n   }\n}\n\nAvailableColumnsPanel* AvailableColumnsPanel_new(Panel* columns, Hashtable* dynamicColumns) {\n   AvailableColumnsPanel* this = AllocThis(AvailableColumnsPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(AvailableColumnsFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n   Panel_setHeader(super, \"Available Columns\");\n\n   this->columns = columns;\n   AvailableColumnsPanel_fill(this, NULL, dynamicColumns);\n\n   return this;\n}\n"
        },
        {
          "name": "AvailableColumnsPanel.h",
          "type": "blob",
          "size": 0.64453125,
          "content": "#ifndef HEADER_AvailableColumnsPanel\n#define HEADER_AvailableColumnsPanel\n/*\nhtop - AvailableColumnsPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Hashtable.h\"\n#include \"Panel.h\"\n\n\ntypedef struct AvailableColumnsPanel_ {\n   Panel super;\n   Panel* columns;\n} AvailableColumnsPanel;\n\nextern const PanelClass AvailableColumnsPanel_class;\n\nAvailableColumnsPanel* AvailableColumnsPanel_new(Panel* columns, Hashtable* dynamicColumns);\n\nvoid AvailableColumnsPanel_fill(AvailableColumnsPanel* this, const char* dynamicScreen, Hashtable* dynamicColumns);\n\n#endif\n"
        },
        {
          "name": "AvailableMetersPanel.c",
          "type": "blob",
          "size": 5.9189453125,
          "content": "/*\nhtop - AvailableMetersPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"AvailableMetersPanel.h\"\n\n#include <assert.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"CPUMeter.h\"\n#include \"DynamicMeter.h\"\n#include \"FunctionBar.h\"\n#include \"Hashtable.h\"\n#include \"Header.h\"\n#include \"ListItem.h\"\n#include \"Macros.h\"\n#include \"Meter.h\"\n#include \"MetersPanel.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"ProvideCurses.h\"\n#include \"Settings.h\"\n#include \"XUtils.h\"\n\n\nstatic void AvailableMetersPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   AvailableMetersPanel* this = (AvailableMetersPanel*) object;\n   Panel_done(super);\n   free(this->meterPanels);\n   free(this);\n}\n\nstatic inline void AvailableMetersPanel_addMeter(Header* header, MetersPanel* panel, const MeterClass* type, unsigned int param, size_t column) {\n   const Meter* meter = Header_addMeterByClass(header, type, param, column);\n   Panel_add((Panel*)panel, (Object*) Meter_toListItem(meter, false));\n   Panel_setSelected((Panel*)panel, Panel_size((Panel*)panel) - 1);\n   MetersPanel_setMoving(panel, true);\n}\n\nstatic HandlerResult AvailableMetersPanel_eventHandler(Panel* super, int ch) {\n   AvailableMetersPanel* this = (AvailableMetersPanel*) super;\n   Header* header = this->header;\n\n   const ListItem* selected = (ListItem*) Panel_getSelected(super);\n   if (!selected)\n      return IGNORED;\n\n   unsigned int param = selected->key & 0xffff;\n   int type = selected->key >> 16;\n   HandlerResult result = IGNORED;\n   bool update = false;\n\n   switch (ch) {\n      case KEY_F(5):\n      case 'l':\n      case 'L':\n         AvailableMetersPanel_addMeter(header, this->meterPanels[0], Platform_meterTypes[type], param, 0);\n         result = HANDLED;\n         update = true;\n         break;\n      case 0x0a:\n      case 0x0d:\n      case KEY_ENTER:\n      case KEY_F(6):\n      case 'r':\n      case 'R':\n         AvailableMetersPanel_addMeter(header, this->meterPanels[this->columns - 1], Platform_meterTypes[type], param, this->columns - 1);\n         result = (KEY_LEFT << 16) | SYNTH_KEY;\n         update = true;\n         break;\n   }\n\n   if (update) {\n      Settings* settings = this->host->settings;\n      settings->changed = true;\n      settings->lastUpdate++;\n      Header_calculateHeight(header);\n      Header_updateData(header);\n      Header_draw(header);\n      ScreenManager_resize(this->scr);\n   }\n\n   return result;\n}\n\nconst PanelClass AvailableMetersPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = AvailableMetersPanel_delete\n   },\n   .eventHandler = AvailableMetersPanel_eventHandler\n};\n\n// Handle (&CPUMeter_class) entries in the AvailableMetersPanel\nstatic void AvailableMetersPanel_addCPUMeters(Panel* super, const MeterClass* type, const Machine* host) {\n   if (host->existingCPUs > 1) {\n      Panel_add(super, (Object*) ListItem_new(\"CPU average\", 0));\n      for (unsigned int i = 1; i <= host->existingCPUs; i++) {\n         char buffer[50];\n         xSnprintf(buffer, sizeof(buffer), \"%s %d\", type->uiName, Settings_cpuId(host->settings, i - 1));\n         Panel_add(super, (Object*) ListItem_new(buffer, i));\n      }\n   } else {\n      Panel_add(super, (Object*) ListItem_new(type->uiName, 1));\n   }\n}\n\ntypedef struct {\n   Panel* super;\n   unsigned int id;\n   unsigned int offset;\n} DynamicIterator;\n\nstatic void AvailableMetersPanel_addDynamicMeter(ATTR_UNUSED ht_key_t key, void* value, void* data) {\n   const DynamicMeter* meter = (const DynamicMeter*)value;\n   DynamicIterator* iter = (DynamicIterator*)data;\n   unsigned int identifier = (iter->offset << 16) | iter->id;\n   const char* label = meter->description ? meter->description : meter->caption;\n   if (!label)\n      label = meter->name; /* last fallback to name, guaranteed set */\n   Panel_add(iter->super, (Object*) ListItem_new(label, identifier));\n   iter->id++;\n}\n\n// Handle (&DynamicMeter_class) entries in the AvailableMetersPanel\nstatic void AvailableMetersPanel_addDynamicMeters(Panel* super, const Settings* settings, unsigned int offset) {\n   DynamicIterator iter = { .super = super, .id = 1, .offset = offset };\n   Hashtable* dynamicMeters = settings->dynamicMeters;\n   assert(dynamicMeters != NULL);\n   Hashtable_foreach(dynamicMeters, AvailableMetersPanel_addDynamicMeter, &iter);\n}\n\n// Handle remaining Platform Meter entries in the AvailableMetersPanel\nstatic void AvailableMetersPanel_addPlatformMeter(Panel* super, const MeterClass* type, unsigned int offset) {\n   const char* label = type->description ? type->description : type->uiName;\n   Panel_add(super, (Object*) ListItem_new(label, offset << 16));\n}\n\nAvailableMetersPanel* AvailableMetersPanel_new(Machine* host, Header* header, size_t columns, MetersPanel** meterPanels, ScreenManager* scr) {\n   AvailableMetersPanel* this = AllocThis(AvailableMetersPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_newEnterEsc(\"Add   \", \"Done   \");\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   this->host = host;\n   this->header = header;\n   this->columns = columns;\n   this->meterPanels = meterPanels;\n   this->scr = scr;\n\n   Panel_setHeader(super, \"Available meters\");\n   // Platform_meterTypes[0] should be always (&CPUMeter_class) which we will\n   // handle separately in the code below.  Likewise, identifiers for Dynamic\n   // Meters are handled separately - similar to CPUs, this allows generation\n   // of multiple different Meters (also using 'param' to distinguish them).\n   for (unsigned int i = 1; Platform_meterTypes[i]; i++) {\n      const MeterClass* type = Platform_meterTypes[i];\n      assert(type != &CPUMeter_class);\n      if (type == &DynamicMeter_class)\n         AvailableMetersPanel_addDynamicMeters(super, host->settings, i);\n      else\n         AvailableMetersPanel_addPlatformMeter(super, type, i);\n   }\n   AvailableMetersPanel_addCPUMeters(super, &CPUMeter_class, host);\n\n   return this;\n}\n"
        },
        {
          "name": "AvailableMetersPanel.h",
          "type": "blob",
          "size": 0.7490234375,
          "content": "#ifndef HEADER_AvailableMetersPanel\n#define HEADER_AvailableMetersPanel\n/*\nhtop - AvailableMetersPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stddef.h>\n\n#include \"Header.h\"\n#include \"Machine.h\"\n#include \"MetersPanel.h\"\n#include \"Panel.h\"\n#include \"ScreenManager.h\"\n\n\ntypedef struct AvailableMetersPanel_ {\n   Panel super;\n   ScreenManager* scr;\n   Machine* host;\n   Header* header;\n   size_t columns;\n   MetersPanel** meterPanels;\n} AvailableMetersPanel;\n\nextern const PanelClass AvailableMetersPanel_class;\n\nAvailableMetersPanel* AvailableMetersPanel_new(Machine* host, Header* header, size_t columns, MetersPanel** meterPanels, ScreenManager* scr);\n\n#endif\n"
        },
        {
          "name": "BatteryMeter.c",
          "type": "blob",
          "size": 1.6142578125,
          "content": "/*\nhtop - BatteryMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n\nThis meter written by Ian P. Hands (iphands@gmail.com, ihands@redhat.com).\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"BatteryMeter.h\"\n\n#include <math.h>\n\n#include \"CRT.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"XUtils.h\"\n\n\nstatic const int BatteryMeter_attributes[] = {\n   BATTERY\n};\n\nstatic void BatteryMeter_updateValues(Meter* this) {\n   ACPresence isOnAC;\n   double percent;\n\n   Platform_getBattery(&percent, &isOnAC);\n\n   if (!isNonnegative(percent)) {\n      this->values[0] = NAN;\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"N/A\");\n      return;\n   }\n\n   this->values[0] = percent;\n\n   const char* text;\n   switch (isOnAC) {\n      case AC_PRESENT:\n         text = this->mode == TEXT_METERMODE ? \" (Running on A/C)\" : \"(A/C)\";\n         break;\n      case AC_ABSENT:\n         text = this->mode == TEXT_METERMODE ? \" (Running on battery)\" : \"(bat)\";\n         break;\n      case AC_ERROR:\n      default:\n         text = \"\";\n         break;\n   }\n\n   xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"%.1f%%%s\", percent, text);\n}\n\nconst MeterClass BatteryMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = BatteryMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = 1,\n   .total = 100.0,\n   .attributes = BatteryMeter_attributes,\n   .name = \"Battery\",\n   .uiName = \"Battery\",\n   .caption = \"Battery: \"\n};\n"
        },
        {
          "name": "BatteryMeter.h",
          "type": "blob",
          "size": 0.4375,
          "content": "#ifndef HEADER_BatteryMeter\n#define HEADER_BatteryMeter\n/*\nhtop - BatteryMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n\nThis meter written by Ian P. Hands (iphands@gmail.com, ihands@redhat.com).\n*/\n\n#include \"Meter.h\"\n\n\ntypedef enum ACPresence_ {\n   AC_ABSENT,\n   AC_PRESENT,\n   AC_ERROR\n} ACPresence;\n\nextern const MeterClass BatteryMeter_class;\n\n#endif\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.85546875,
          "content": "Contributing Guide\n==================\n\nThank you so much for taking the time to contribute in to htop!\n\nBug Reports\n-----------\n\nBug reports should be posted in the [Github issue\ntracker](https://github.com/htop-dev/htop/issues).\nBug reports are extremely important since it's impossible for us to test\nhtop in every possible system, distribution and scenario. Your feedback\nis what keeps the tool stable and always improving!  Thank you!\n\nPull Requests\n-------------\n\nCode contributions are most welcome! Just [fork the\nrepo](https://github.com/htop-dev/htop) and send a [pull\nrequest](https://github.com/htop-dev/htop/pulls).  Help is especially\nappreciated for support of platforms other than Linux.  If proposing new\nfeatures, please be mindful that htop is a system tool that needs to keep a\nsmall footprint and perform well on systems under stress -- so unfortunately\nwe can't accept every new feature proposed, as we need to keep the tool slim\nand maintainable.  Great ideas backed by a PR are always carefully considered\nfor inclusion though!  Also, PRs containing bug fixes and portability tweaks\nare always included, please send those in!\n\nFeature Requests\n----------------\n\nPlease label Github issues that are feature requests with one of the `feature request`\nlabels. If you can't do this yourself, don't worry. The friendly folks from the\ncore team will distribute and fixup Github labels as part of the regular reviews.\n\nStyle Guide\n-----------\n\nTo make working with the code easier a set of guidelines have evolved in\nthe past that new contributions should try to follow. While they are not set\nin stone and always up for changes should the need arise they still provide\na first orientation to go by when contributing to this repository.\n\nThe details of the coding style as well as what to take care about with your\ncontributions can be found in our [style guide](docs/styleguide.md).\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "CPUMeter.c",
          "type": "blob",
          "size": 19.76953125,
          "content": "/*\nhtop - CPUMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"CPUMeter.h\"\n\n#include <assert.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"Machine.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"RichString.h\"\n#include \"Settings.h\"\n#include \"XUtils.h\"\n\n\nstatic const int CPUMeter_attributes[] = {\n   CPU_NICE,\n   CPU_NORMAL,\n   CPU_SYSTEM,\n   CPU_IRQ,\n   CPU_SOFTIRQ,\n   CPU_STEAL,\n   CPU_GUEST,\n   CPU_IOWAIT\n};\n\ntypedef struct CPUMeterData_ {\n   unsigned int cpus;\n   Meter** meters;\n} CPUMeterData;\n\nstatic void CPUMeter_init(Meter* this) {\n   unsigned int cpu = this->param;\n   const Machine* host = this->host;\n   if (cpu == 0) {\n      Meter_setCaption(this, \"Avg\");\n   } else if (host->activeCPUs > 1) {\n      char caption[10];\n      xSnprintf(caption, sizeof(caption), \"%3u\", Settings_cpuId(host->settings, cpu - 1));\n      Meter_setCaption(this, caption);\n   }\n}\n\n// Custom uiName runtime logic to include the param (processor)\nstatic void CPUMeter_getUiName(const Meter* this, char* buffer, size_t length) {\n   assert(length > 0);\n\n   if (this->param > 0)\n      xSnprintf(buffer, length, \"%s %u\", Meter_uiName(this), this->param);\n   else\n      xSnprintf(buffer, length, \"%s\", Meter_uiName(this));\n}\n\nstatic void CPUMeter_updateValues(Meter* this) {\n   memset(this->values, 0, sizeof(double) * CPU_METER_ITEMCOUNT);\n\n   const Machine* host = this->host;\n   const Settings* settings = host->settings;\n\n   unsigned int cpu = this->param;\n   if (cpu > host->existingCPUs) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"absent\");\n      return;\n   }\n\n   double percent = Platform_setCPUValues(this, cpu);\n   if (!isNonnegative(percent)) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"offline\");\n      return;\n   }\n\n   char cpuUsageBuffer[8] = { 0 };\n   char cpuFrequencyBuffer[16] = { 0 };\n   char cpuTemperatureBuffer[16] = { 0 };\n\n   if (settings->showCPUUsage) {\n      xSnprintf(cpuUsageBuffer, sizeof(cpuUsageBuffer), \"%.1f%%\", percent);\n   }\n\n   if (settings->showCPUFrequency) {\n      double cpuFrequency = this->values[CPU_METER_FREQUENCY];\n      if (isNonnegative(cpuFrequency)) {\n         xSnprintf(cpuFrequencyBuffer, sizeof(cpuFrequencyBuffer), \"%4uMHz\", (unsigned)cpuFrequency);\n      } else {\n         xSnprintf(cpuFrequencyBuffer, sizeof(cpuFrequencyBuffer), \"N/A\");\n      }\n   }\n\n   #ifdef BUILD_WITH_CPU_TEMP\n   if (settings->showCPUTemperature) {\n      double cpuTemperature = this->values[CPU_METER_TEMPERATURE];\n      if (isNaN(cpuTemperature))\n         xSnprintf(cpuTemperatureBuffer, sizeof(cpuTemperatureBuffer), \"N/A\");\n      else if (settings->degreeFahrenheit)\n         xSnprintf(cpuTemperatureBuffer, sizeof(cpuTemperatureBuffer), \"%3d%sF\", (int)(cpuTemperature * 9 / 5 + 32), CRT_degreeSign);\n      else\n         xSnprintf(cpuTemperatureBuffer, sizeof(cpuTemperatureBuffer), \"%d%sC\", (int)cpuTemperature, CRT_degreeSign);\n   }\n   #endif\n\n   xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"%s%s%s%s%s\",\n             cpuUsageBuffer,\n             (cpuUsageBuffer[0] && (cpuFrequencyBuffer[0] || cpuTemperatureBuffer[0])) ? \" \" : \"\",\n             cpuFrequencyBuffer,\n             (cpuFrequencyBuffer[0] && cpuTemperatureBuffer[0]) ? \" \" : \"\",\n             cpuTemperatureBuffer);\n}\n\nstatic void CPUMeter_display(const Object* cast, RichString* out) {\n   char buffer[50];\n   int len;\n   const Meter* this = (const Meter*)cast;\n   const Machine* host = this->host;\n   const Settings* settings = host->settings;\n\n   if (this->param > host->existingCPUs) {\n      RichString_appendAscii(out, CRT_colors[METER_SHADOW], \" absent\");\n      return;\n   }\n\n   if (this->curItems == 0) {\n      RichString_appendAscii(out, CRT_colors[METER_SHADOW], \" offline\");\n      return;\n   }\n\n   len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_NORMAL]);\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \":\");\n   RichString_appendnAscii(out, CRT_colors[CPU_NORMAL], buffer, len);\n   if (settings->detailedCPUTime) {\n      len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_KERNEL]);\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \"sy:\");\n      RichString_appendnAscii(out, CRT_colors[CPU_SYSTEM], buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_NICE]);\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \"ni:\");\n      RichString_appendnAscii(out, CRT_colors[CPU_NICE_TEXT], buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_IRQ]);\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \"hi:\");\n      RichString_appendnAscii(out, CRT_colors[CPU_IRQ], buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_SOFTIRQ]);\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \"si:\");\n      RichString_appendnAscii(out, CRT_colors[CPU_SOFTIRQ], buffer, len);\n      if (isNonnegative(this->values[CPU_METER_STEAL])) {\n         len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_STEAL]);\n         RichString_appendAscii(out, CRT_colors[METER_TEXT], \"st:\");\n         RichString_appendnAscii(out, CRT_colors[CPU_STEAL], buffer, len);\n      }\n      if (isNonnegative(this->values[CPU_METER_GUEST])) {\n         len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_GUEST]);\n         RichString_appendAscii(out, CRT_colors[METER_TEXT], \"gu:\");\n         RichString_appendnAscii(out, CRT_colors[CPU_GUEST], buffer, len);\n      }\n      len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_IOWAIT]);\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \"wa:\");\n      RichString_appendnAscii(out, CRT_colors[CPU_IOWAIT], buffer, len);\n   } else {\n      len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_KERNEL]);\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \"sys:\");\n      RichString_appendnAscii(out, CRT_colors[CPU_SYSTEM], buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_NICE]);\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \"low:\");\n      RichString_appendnAscii(out, CRT_colors[CPU_NICE_TEXT], buffer, len);\n      if (isNonnegative(this->values[CPU_METER_IRQ])) {\n         len = xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_IRQ]);\n         RichString_appendAscii(out, CRT_colors[METER_TEXT], \"vir:\");\n         RichString_appendnAscii(out, CRT_colors[CPU_GUEST], buffer, len);\n      }\n   }\n\n   if (settings->showCPUFrequency) {\n      char cpuFrequencyBuffer[10];\n      double cpuFrequency = this->values[CPU_METER_FREQUENCY];\n      if (isNonnegative(cpuFrequency)) {\n         len = xSnprintf(cpuFrequencyBuffer, sizeof(cpuFrequencyBuffer), \"%4uMHz \", (unsigned)cpuFrequency);\n      } else {\n         len = xSnprintf(cpuFrequencyBuffer, sizeof(cpuFrequencyBuffer), \"N/A     \");\n      }\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \"freq: \");\n      RichString_appendnWide(out, CRT_colors[METER_VALUE], cpuFrequencyBuffer, len);\n   }\n\n   #ifdef BUILD_WITH_CPU_TEMP\n   if (settings->showCPUTemperature) {\n      char cpuTemperatureBuffer[10];\n      double cpuTemperature = this->values[CPU_METER_TEMPERATURE];\n      if (isNaN(cpuTemperature)) {\n         len = xSnprintf(cpuTemperatureBuffer, sizeof(cpuTemperatureBuffer), \"N/A\");\n      } else if (settings->degreeFahrenheit) {\n         len = xSnprintf(cpuTemperatureBuffer, sizeof(cpuTemperatureBuffer), \"%5.1f%sF\", cpuTemperature * 9 / 5 + 32, CRT_degreeSign);\n      } else {\n         len = xSnprintf(cpuTemperatureBuffer, sizeof(cpuTemperatureBuffer), \"%5.1f%sC\", cpuTemperature, CRT_degreeSign);\n      }\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \"temp:\");\n      RichString_appendnWide(out, CRT_colors[METER_VALUE], cpuTemperatureBuffer, len);\n   }\n   #endif\n}\n\nstatic void AllCPUsMeter_getRange(const Meter* this, int* start, int* count) {\n   const CPUMeterData* data = this->meterData;\n   unsigned int cpus = data->cpus;\n   switch (Meter_name(this)[0]) {\n      default:\n      case 'A': // All\n         *start = 0;\n         *count = cpus;\n         break;\n      case 'L': // First Half\n         *start = 0;\n         *count = (cpus + 1) / 2;\n         break;\n      case 'R': // Second Half\n         *start = (cpus + 1) / 2;\n         *count = cpus / 2;\n         break;\n   }\n}\n\nstatic void AllCPUsMeter_updateValues(Meter* this) {\n   CPUMeterData* data = this->meterData;\n   Meter** meters = data->meters;\n   int start, count;\n   AllCPUsMeter_getRange(this, &start, &count);\n   for (int i = 0; i < count; i++)\n      Meter_updateValues(meters[i]);\n}\n\nstatic void CPUMeterCommonInit(Meter* this) {\n   unsigned int cpus = this->host->existingCPUs;\n   CPUMeterData* data = this->meterData;\n   if (!data) {\n      data = this->meterData = xMalloc(sizeof(CPUMeterData));\n      data->cpus = cpus;\n      data->meters = xCalloc(cpus, sizeof(Meter*));\n   }\n   Meter** meters = data->meters;\n   int start, count;\n   AllCPUsMeter_getRange(this, &start, &count);\n   for (int i = 0; i < count; i++) {\n      if (!meters[i])\n         meters[i] = Meter_new(this->host, start + i + 1, (const MeterClass*) Class(CPUMeter));\n\n      Meter_init(meters[i]);\n   }\n}\n\nstatic void CPUMeterCommonUpdateMode(Meter* this, MeterModeId mode, int ncol) {\n   CPUMeterData* data = this->meterData;\n   Meter** meters = data->meters;\n   this->mode = mode;\n   int start, count;\n   AllCPUsMeter_getRange(this, &start, &count);\n   for (int i = 0; i < count; i++) {\n      Meter_setMode(meters[i], mode);\n   }\n   int h = meters[0]->h;\n   assert(h > 0);\n   this->h = h * ((count + ncol - 1) / ncol);\n}\n\nstatic void AllCPUsMeter_done(Meter* this) {\n   CPUMeterData* data = this->meterData;\n   Meter** meters = data->meters;\n   int start, count;\n   AllCPUsMeter_getRange(this, &start, &count);\n   for (int i = 0; i < count; i++)\n      Meter_delete((Object*)meters[i]);\n   free(data->meters);\n   free(data);\n}\n\nstatic void SingleColCPUsMeter_updateMode(Meter* this, MeterModeId mode) {\n   CPUMeterCommonUpdateMode(this, mode, 1);\n}\n\nstatic void DualColCPUsMeter_updateMode(Meter* this, MeterModeId mode) {\n   CPUMeterCommonUpdateMode(this, mode, 2);\n}\n\nstatic void QuadColCPUsMeter_updateMode(Meter* this, MeterModeId mode) {\n   CPUMeterCommonUpdateMode(this, mode, 4);\n}\n\nstatic void OctoColCPUsMeter_updateMode(Meter* this, MeterModeId mode) {\n   CPUMeterCommonUpdateMode(this, mode, 8);\n}\n\nstatic void CPUMeterCommonDraw(Meter* this, int x, int y, int w, int ncol) {\n   CPUMeterData* data = this->meterData;\n   Meter** meters = data->meters;\n   int start, count;\n   AllCPUsMeter_getRange(this, &start, &count);\n   int colwidth = (w - ncol) / ncol + 1;\n   int diff = (w - (colwidth * ncol));\n   int nrows = (count + ncol - 1) / ncol;\n   for (int i = 0; i < count; i++) {\n      int d = (i / nrows) > diff ? diff : (i / nrows); // dynamic spacer\n      int xpos = x + ((i / nrows) * colwidth) + d;\n      int ypos = y + ((i % nrows) * meters[0]->h);\n      meters[i]->draw(meters[i], xpos, ypos, colwidth);\n   }\n}\n\nstatic void DualColCPUsMeter_draw(Meter* this, int x, int y, int w) {\n   CPUMeterCommonDraw(this, x, y, w, 2);\n}\n\nstatic void QuadColCPUsMeter_draw(Meter* this, int x, int y, int w) {\n   CPUMeterCommonDraw(this, x, y, w, 4);\n}\n\nstatic void OctoColCPUsMeter_draw(Meter* this, int x, int y, int w) {\n   CPUMeterCommonDraw(this, x, y, w, 8);\n}\n\n\nstatic void SingleColCPUsMeter_draw(Meter* this, int x, int y, int w) {\n   CPUMeterData* data = this->meterData;\n   Meter** meters = data->meters;\n   int start, count;\n   AllCPUsMeter_getRange(this, &start, &count);\n   for (int i = 0; i < count; i++) {\n      meters[i]->draw(meters[i], x, y, w);\n      y += meters[i]->h;\n   }\n}\n\n\nconst MeterClass CPUMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = CPUMeter_updateValues,\n   .getUiName = CPUMeter_getUiName,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = CPU_METER_ITEMCOUNT,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"CPU\",\n   .uiName = \"CPU\",\n   .caption = \"CPU\",\n   .init = CPUMeter_init\n};\n\nconst MeterClass AllCPUsMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"AllCPUs\",\n   .uiName = \"CPUs (1/1)\",\n   .description = \"CPUs (1/1): all CPUs\",\n   .caption = \"CPU\",\n   .draw = SingleColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = SingleColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass AllCPUs2Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"AllCPUs2\",\n   .uiName = \"CPUs (1&2/2)\",\n   .description = \"CPUs (1&2/2): all CPUs in 2 shorter columns\",\n   .caption = \"CPU\",\n   .draw = DualColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = DualColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass LeftCPUsMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"LeftCPUs\",\n   .uiName = \"CPUs (1/2)\",\n   .description = \"CPUs (1/2): first half of list\",\n   .caption = \"CPU\",\n   .draw = SingleColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = SingleColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass RightCPUsMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"RightCPUs\",\n   .uiName = \"CPUs (2/2)\",\n   .description = \"CPUs (2/2): second half of list\",\n   .caption = \"CPU\",\n   .draw = SingleColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = SingleColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass LeftCPUs2Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"LeftCPUs2\",\n   .uiName = \"CPUs (1&2/4)\",\n   .description = \"CPUs (1&2/4): first half in 2 shorter columns\",\n   .caption = \"CPU\",\n   .draw = DualColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = DualColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass RightCPUs2Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"RightCPUs2\",\n   .uiName = \"CPUs (3&4/4)\",\n   .description = \"CPUs (3&4/4): second half in 2 shorter columns\",\n   .caption = \"CPU\",\n   .draw = DualColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = DualColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass AllCPUs4Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"AllCPUs4\",\n   .uiName = \"CPUs (1&2&3&4/4)\",\n   .description = \"CPUs (1&2&3&4/4): all CPUs in 4 shorter columns\",\n   .caption = \"CPU\",\n   .draw = QuadColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = QuadColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass LeftCPUs4Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"LeftCPUs4\",\n   .uiName = \"CPUs (1-4/8)\",\n   .description = \"CPUs (1-4/8): first half in 4 shorter columns\",\n   .caption = \"CPU\",\n   .draw = QuadColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = QuadColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass RightCPUs4Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"RightCPUs4\",\n   .uiName = \"CPUs (5-8/8)\",\n   .description = \"CPUs (5-8/8): second half in 4 shorter columns\",\n   .caption = \"CPU\",\n   .draw = QuadColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = QuadColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass AllCPUs8Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"AllCPUs8\",\n   .uiName = \"CPUs (1-8/8)\",\n   .description = \"CPUs (1-8/8): all CPUs in 8 shorter columns\",\n   .caption = \"CPU\",\n   .draw = OctoColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = OctoColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass LeftCPUs8Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"LeftCPUs8\",\n   .uiName = \"CPUs (1-8/16)\",\n   .description = \"CPUs (1-8/16): first half in 8 shorter columns\",\n   .caption = \"CPU\",\n   .draw = OctoColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = OctoColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nconst MeterClass RightCPUs8Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = AllCPUsMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes,\n   .name = \"RightCPUs8\",\n   .uiName = \"CPUs (9-16/16)\",\n   .description = \"CPUs (9-16/16): second half in 8 shorter columns\",\n   .caption = \"CPU\",\n   .draw = OctoColCPUsMeter_draw,\n   .init = CPUMeterCommonInit,\n   .updateMode = OctoColCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n"
        },
        {
          "name": "CPUMeter.h",
          "type": "blob",
          "size": 1.1552734375,
          "content": "#ifndef HEADER_CPUMeter\n#define HEADER_CPUMeter\n/*\nhtop - CPUMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n\ntypedef enum {\n   CPU_METER_NICE = 0,\n   CPU_METER_NORMAL = 1,\n   CPU_METER_KERNEL = 2,\n   CPU_METER_IRQ = 3,\n   CPU_METER_SOFTIRQ = 4,\n   CPU_METER_STEAL = 5,\n   CPU_METER_GUEST = 6,\n   CPU_METER_IOWAIT = 7,\n   CPU_METER_FREQUENCY = 8,\n   CPU_METER_TEMPERATURE = 9,\n   CPU_METER_ITEMCOUNT = 10, // number of entries in this enum\n} CPUMeterValues;\n\nextern const MeterClass CPUMeter_class;\n\nextern const MeterClass AllCPUsMeter_class;\n\nextern const MeterClass AllCPUs2Meter_class;\n\nextern const MeterClass LeftCPUsMeter_class;\n\nextern const MeterClass RightCPUsMeter_class;\n\nextern const MeterClass LeftCPUs2Meter_class;\n\nextern const MeterClass RightCPUs2Meter_class;\n\nextern const MeterClass AllCPUs4Meter_class;\n\nextern const MeterClass LeftCPUs4Meter_class;\n\nextern const MeterClass RightCPUs4Meter_class;\n\nextern const MeterClass AllCPUs8Meter_class;\n\nextern const MeterClass LeftCPUs8Meter_class;\n\nextern const MeterClass RightCPUs8Meter_class;\n\n#endif\n"
        },
        {
          "name": "CRT.c",
          "type": "blob",
          "size": 49.5205078125,
          "content": "/*\nhtop - CRT.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"CRT.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <langinfo.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"CommandLine.h\"\n#include \"ProvideCurses.h\"\n#include \"ProvideTerm.h\"\n#include \"XUtils.h\"\n\n#if !defined(NDEBUG) && defined(HAVE_MEMFD_CREATE)\n#include <sys/mman.h>\n#endif\n\n#if defined(HAVE_LIBUNWIND_H) && defined(HAVE_LIBUNWIND)\n# define PRINT_BACKTRACE\n# define UNW_LOCAL_ONLY\n# include <libunwind.h>\n# if defined(HAVE_DLADDR)\n#  include <dlfcn.h>\n# endif\n#elif defined(HAVE_EXECINFO_H)\n# define PRINT_BACKTRACE\n# include <execinfo.h>\n#endif\n\n\n#define ColorIndex(i,j) ((7-(i))*8+(j))\n\n#define ColorPair(i,j) COLOR_PAIR(ColorIndex(i,j))\n\n#define Black   COLOR_BLACK\n#define Red     COLOR_RED\n#define Green   COLOR_GREEN\n#define Yellow  COLOR_YELLOW\n#define Blue    COLOR_BLUE\n#define Magenta COLOR_MAGENTA\n#define Cyan    COLOR_CYAN\n#define White   COLOR_WHITE\n\n#define ColorPairGrayBlack  ColorPair(Magenta,Magenta)\n#define ColorIndexGrayBlack ColorIndex(Magenta,Magenta)\n\n#define ColorPairWhiteDefault  ColorPair(Red, Red)\n#define ColorIndexWhiteDefault ColorIndex(Red, Red)\n\nstatic const char* const CRT_treeStrAscii[LAST_TREE_STR] = {\n   [TREE_STR_VERT] = \"|\",\n   [TREE_STR_RTEE] = \"`\",\n   [TREE_STR_BEND] = \"`\",\n   [TREE_STR_TEND] = \",\",\n   [TREE_STR_OPEN] = \"+\",\n   [TREE_STR_SHUT] = \"-\",\n   [TREE_STR_ASC]  = \"+\",\n   [TREE_STR_DESC] = \"-\",\n};\n\n#ifdef HAVE_LIBNCURSESW\n\nstatic const char* const CRT_treeStrUtf8[LAST_TREE_STR] = {\n   [TREE_STR_VERT] = \"\\xe2\\x94\\x82\", // â\n   [TREE_STR_RTEE] = \"\\xe2\\x94\\x9c\", // â\n   [TREE_STR_BEND] = \"\\xe2\\x94\\x94\", // â\n   [TREE_STR_TEND] = \"\\xe2\\x94\\x8c\", // â\n   [TREE_STR_OPEN] = \"+\",            // +, TODO use ð®¯ 'BOX DRAWINGS LIGHT HORIZONTAL\n                                     // WITH VERTICAL STROKE' (U+1FBAF, \"\\xf0\\x9f\\xae\\xaf\") when\n                                     // Unicode 13 is common\n   [TREE_STR_SHUT] = \"\\xe2\\x94\\x80\", // â\n   [TREE_STR_ASC]  = \"\\xe2\\x96\\xb3\", // â³\n   [TREE_STR_DESC] = \"\\xe2\\x96\\xbd\", // â½\n};\n\nbool CRT_utf8 = false;\n\n#endif\n\nconst char* const* CRT_treeStr = CRT_treeStrAscii;\n\nstatic const Settings* CRT_settings;\n\nconst char* CRT_degreeSign;\n\nstatic const char* initDegreeSign(void) {\n#ifdef HAVE_LIBNCURSESW\n   if (CRT_utf8)\n      return \"\\xc2\\xb0\";\n\n   static char buffer[4];\n   // this might fail if the current locale does not support wide characters\n   int r = snprintf(buffer, sizeof(buffer), \"%lc\", 176);\n   if (r > 0)\n      return buffer;\n#endif\n\n   return \"\";\n}\n\nconst int* CRT_colors;\n\nstatic int CRT_colorSchemes[LAST_COLORSCHEME][LAST_COLORELEMENT] = {\n   [COLORSCHEME_DEFAULT] = {\n      [RESET_COLOR] = ColorPair(White, Black),\n      [DEFAULT_COLOR] = ColorPair(White, Black),\n      [FUNCTION_BAR] = ColorPair(Black, Cyan),\n      [FUNCTION_KEY] = ColorPair(White, Black),\n      [PANEL_HEADER_FOCUS] = ColorPair(Black, Green),\n      [PANEL_HEADER_UNFOCUS] = ColorPair(Black, Green),\n      [PANEL_SELECTION_FOCUS] = ColorPair(Black, Cyan),\n      [PANEL_SELECTION_FOLLOW] = ColorPair(Black, Yellow),\n      [PANEL_SELECTION_UNFOCUS] = ColorPair(Black, White),\n      [FAILED_SEARCH] = ColorPair(Red, Cyan),\n      [FAILED_READ] = A_BOLD | ColorPair(Red, Black),\n      [PAUSED] = A_BOLD | ColorPair(Yellow, Cyan),\n      [UPTIME] = A_BOLD | ColorPair(Cyan, Black),\n      [BATTERY] = A_BOLD | ColorPair(Cyan, Black),\n      [LARGE_NUMBER] = A_BOLD | ColorPair(Red, Black),\n      [METER_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [METER_TEXT] = ColorPair(Cyan, Black),\n      [METER_VALUE] = A_BOLD | ColorPair(Cyan, Black),\n      [METER_VALUE_ERROR] = A_BOLD | ColorPair(Red, Black),\n      [METER_VALUE_IOREAD] = ColorPair(Green, Black),\n      [METER_VALUE_IOWRITE] = A_BOLD | ColorPair(Blue, Black),\n      [METER_VALUE_NOTICE] = A_BOLD | ColorPair(White, Black),\n      [METER_VALUE_OK] = ColorPair(Green, Black),\n      [METER_VALUE_WARN] = A_BOLD | ColorPair(Yellow, Black),\n      [LED_COLOR] = ColorPair(Green, Black),\n      [TASKS_RUNNING] = A_BOLD | ColorPair(Green, Black),\n      [PROCESS] = A_NORMAL,\n      [PROCESS_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [PROCESS_TAG] = A_BOLD | ColorPair(Yellow, Black),\n      [PROCESS_MEGABYTES] = ColorPair(Cyan, Black),\n      [PROCESS_GIGABYTES] = ColorPair(Green, Black),\n      [PROCESS_BASENAME] = A_BOLD | ColorPair(Cyan, Black),\n      [PROCESS_TREE] = ColorPair(Cyan, Black),\n      [PROCESS_RUN_STATE] = ColorPair(Green, Black),\n      [PROCESS_D_STATE] = A_BOLD | ColorPair(Red, Black),\n      [PROCESS_HIGH_PRIORITY] = ColorPair(Red, Black),\n      [PROCESS_LOW_PRIORITY] = ColorPair(Green, Black),\n      [PROCESS_NEW] = ColorPair(Black, Green),\n      [PROCESS_TOMB] = ColorPair(Black, Red),\n      [PROCESS_THREAD] = ColorPair(Green, Black),\n      [PROCESS_THREAD_BASENAME] = A_BOLD | ColorPair(Green, Black),\n      [PROCESS_COMM] = ColorPair(Magenta, Black),\n      [PROCESS_THREAD_COMM] = A_BOLD | ColorPair(Blue, Black),\n      [PROCESS_PRIV] = ColorPair(Magenta, Black),\n      [BAR_BORDER] = A_BOLD,\n      [BAR_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [SWAP] = ColorPair(Red, Black),\n      [SWAP_CACHE] = ColorPair(Yellow, Black),\n      [SWAP_FRONTSWAP] = A_BOLD | ColorPairGrayBlack,\n      [GRAPH_1] = A_BOLD | ColorPair(Cyan, Black),\n      [GRAPH_2] = ColorPair(Cyan, Black),\n      [MEMORY_USED] = ColorPair(Green, Black),\n      [MEMORY_BUFFERS] = A_BOLD | ColorPair(Blue, Black),\n      [MEMORY_BUFFERS_TEXT] = A_BOLD | ColorPair(Blue, Black),\n      [MEMORY_CACHE] = ColorPair(Yellow, Black),\n      [MEMORY_SHARED] = ColorPair(Magenta, Black),\n      [MEMORY_COMPRESSED] = A_BOLD | ColorPairGrayBlack,\n      [HUGEPAGE_1] = ColorPair(Green, Black),\n      [HUGEPAGE_2] = ColorPair(Yellow, Black),\n      [HUGEPAGE_3] = ColorPair(Red, Black),\n      [HUGEPAGE_4] = A_BOLD | ColorPair(Blue, Black),\n      [LOAD_AVERAGE_FIFTEEN] = ColorPair(Cyan, Black),\n      [LOAD_AVERAGE_FIVE] = A_BOLD | ColorPair(Cyan, Black),\n      [LOAD_AVERAGE_ONE] = A_BOLD | ColorPair(White, Black),\n      [LOAD] = A_BOLD,\n      [HELP_BOLD] = A_BOLD | ColorPair(Cyan, Black),\n      [HELP_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [CLOCK] = A_BOLD,\n      [DATE] = A_BOLD,\n      [DATETIME] = A_BOLD,\n      [CHECK_BOX] = ColorPair(Cyan, Black),\n      [CHECK_MARK] = A_BOLD,\n      [CHECK_TEXT] = A_NORMAL,\n      [HOSTNAME] = A_BOLD,\n      [CPU_NICE] = A_BOLD | ColorPair(Blue, Black),\n      [CPU_NICE_TEXT] = A_BOLD | ColorPair(Blue, Black),\n      [CPU_NORMAL] = ColorPair(Green, Black),\n      [CPU_SYSTEM] = ColorPair(Red, Black),\n      [CPU_IOWAIT] = A_BOLD | ColorPairGrayBlack,\n      [CPU_IRQ] = ColorPair(Yellow, Black),\n      [CPU_SOFTIRQ] = ColorPair(Magenta, Black),\n      [CPU_STEAL] = ColorPair(Cyan, Black),\n      [CPU_GUEST] = ColorPair(Cyan, Black),\n      [GPU_ENGINE_1] = ColorPair(Green, Black),\n      [GPU_ENGINE_2] = ColorPair(Yellow, Black),\n      [GPU_ENGINE_3] = ColorPair(Red, Black),\n      [GPU_ENGINE_4] = A_BOLD | ColorPair(Blue, Black),\n      [GPU_RESIDUE] = ColorPair(Magenta, Black),\n      [PANEL_EDIT] = ColorPair(White, Blue),\n      [SCREENS_OTH_BORDER] = ColorPair(Blue, Blue),\n      [SCREENS_OTH_TEXT] = ColorPair(Black, Blue),\n      [SCREENS_CUR_BORDER] = ColorPair(Green, Green),\n      [SCREENS_CUR_TEXT] = ColorPair(Black, Green),\n      [PRESSURE_STALL_THREEHUNDRED] = ColorPair(Cyan, Black),\n      [PRESSURE_STALL_SIXTY] = A_BOLD | ColorPair(Cyan, Black),\n      [PRESSURE_STALL_TEN] = A_BOLD | ColorPair(White, Black),\n      [FILE_DESCRIPTOR_USED] = ColorPair(Green, Black),\n      [FILE_DESCRIPTOR_MAX] = A_BOLD | ColorPair(Blue, Black),\n      [ZFS_MFU] = A_BOLD | ColorPair(Blue, Black),\n      [ZFS_MRU] = ColorPair(Yellow, Black),\n      [ZFS_ANON] = ColorPair(Magenta, Black),\n      [ZFS_HEADER] = ColorPair(Cyan, Black),\n      [ZFS_OTHER] = ColorPair(Magenta, Black),\n      [ZFS_COMPRESSED] = A_BOLD | ColorPair(Blue, Black),\n      [ZFS_RATIO] = ColorPair(Magenta, Black),\n      [ZRAM_COMPRESSED] = A_BOLD | ColorPair(Blue, Black),\n      [ZRAM_UNCOMPRESSED] = ColorPair(Yellow, Black),\n      [DYNAMIC_GRAY] = ColorPairGrayBlack,\n      [DYNAMIC_DARKGRAY] = A_BOLD | ColorPairGrayBlack,\n      [DYNAMIC_RED] = ColorPair(Red, Black),\n      [DYNAMIC_GREEN] = ColorPair(Green, Black),\n      [DYNAMIC_BLUE] = A_BOLD | ColorPair(Blue, Black),\n      [DYNAMIC_CYAN] = ColorPair(Cyan, Black),\n      [DYNAMIC_MAGENTA] = ColorPair(Magenta, Black),\n      [DYNAMIC_YELLOW] = ColorPair(Yellow, Black),\n      [DYNAMIC_WHITE] = ColorPair(White, Black),\n   },\n   [COLORSCHEME_MONOCHROME] = {\n      [RESET_COLOR] = A_NORMAL,\n      [DEFAULT_COLOR] = A_NORMAL,\n      [FUNCTION_BAR] = A_REVERSE,\n      [FUNCTION_KEY] = A_NORMAL,\n      [PANEL_HEADER_FOCUS] = A_REVERSE,\n      [PANEL_HEADER_UNFOCUS] = A_REVERSE,\n      [PANEL_SELECTION_FOCUS] = A_REVERSE,\n      [PANEL_SELECTION_FOLLOW] = A_REVERSE,\n      [PANEL_SELECTION_UNFOCUS] = A_BOLD,\n      [FAILED_SEARCH] = A_REVERSE | A_BOLD,\n      [FAILED_READ] = A_BOLD,\n      [PAUSED] = A_BOLD | A_REVERSE,\n      [UPTIME] = A_BOLD,\n      [BATTERY] = A_BOLD,\n      [LARGE_NUMBER] = A_BOLD,\n      [METER_SHADOW] = A_DIM,\n      [METER_TEXT] = A_NORMAL,\n      [METER_VALUE] = A_BOLD,\n      [METER_VALUE_ERROR] = A_BOLD,\n      [METER_VALUE_IOREAD] = A_NORMAL,\n      [METER_VALUE_IOWRITE] = A_NORMAL,\n      [METER_VALUE_NOTICE] = A_BOLD,\n      [METER_VALUE_OK] = A_NORMAL,\n      [METER_VALUE_WARN] = A_BOLD,\n      [LED_COLOR] = A_NORMAL,\n      [TASKS_RUNNING] = A_BOLD,\n      [PROCESS] = A_NORMAL,\n      [PROCESS_SHADOW] = A_DIM,\n      [PROCESS_TAG] = A_BOLD,\n      [PROCESS_MEGABYTES] = A_BOLD,\n      [PROCESS_GIGABYTES] = A_BOLD,\n      [PROCESS_BASENAME] = A_BOLD,\n      [PROCESS_TREE] = A_BOLD,\n      [PROCESS_RUN_STATE] = A_BOLD,\n      [PROCESS_D_STATE] = A_BOLD,\n      [PROCESS_HIGH_PRIORITY] = A_BOLD,\n      [PROCESS_LOW_PRIORITY] = A_DIM,\n      [PROCESS_NEW] = A_BOLD,\n      [PROCESS_TOMB] = A_DIM,\n      [PROCESS_THREAD] = A_BOLD,\n      [PROCESS_THREAD_BASENAME] = A_REVERSE,\n      [PROCESS_COMM] = A_BOLD,\n      [PROCESS_THREAD_COMM] = A_REVERSE,\n      [PROCESS_PRIV] = A_BOLD,\n      [BAR_BORDER] = A_BOLD,\n      [BAR_SHADOW] = A_DIM,\n      [SWAP] = A_BOLD,\n      [SWAP_CACHE] = A_NORMAL,\n      [SWAP_FRONTSWAP] = A_DIM,\n      [GRAPH_1] = A_BOLD,\n      [GRAPH_2] = A_NORMAL,\n      [MEMORY_USED] = A_BOLD,\n      [MEMORY_BUFFERS] = A_NORMAL,\n      [MEMORY_BUFFERS_TEXT] = A_NORMAL,\n      [MEMORY_CACHE] = A_NORMAL,\n      [MEMORY_SHARED] = A_NORMAL,\n      [MEMORY_COMPRESSED] = A_DIM,\n      [HUGEPAGE_1] = A_BOLD,\n      [HUGEPAGE_2] = A_NORMAL,\n      [HUGEPAGE_3] = A_REVERSE | A_BOLD,\n      [HUGEPAGE_4] = A_REVERSE,\n      [LOAD_AVERAGE_FIFTEEN] = A_DIM,\n      [LOAD_AVERAGE_FIVE] = A_NORMAL,\n      [LOAD_AVERAGE_ONE] = A_BOLD,\n      [LOAD] = A_BOLD,\n      [HELP_BOLD] = A_BOLD,\n      [HELP_SHADOW] = A_DIM,\n      [CLOCK] = A_BOLD,\n      [DATE] = A_BOLD,\n      [DATETIME] = A_BOLD,\n      [CHECK_BOX] = A_BOLD,\n      [CHECK_MARK] = A_NORMAL,\n      [CHECK_TEXT] = A_NORMAL,\n      [HOSTNAME] = A_BOLD,\n      [CPU_NICE] = A_NORMAL,\n      [CPU_NICE_TEXT] = A_NORMAL,\n      [CPU_NORMAL] = A_BOLD,\n      [CPU_SYSTEM] = A_BOLD,\n      [CPU_IOWAIT] = A_NORMAL,\n      [CPU_IRQ] = A_BOLD,\n      [CPU_SOFTIRQ] = A_BOLD,\n      [CPU_STEAL] = A_DIM,\n      [CPU_GUEST] = A_DIM,\n      [GPU_ENGINE_1] = A_BOLD,\n      [GPU_ENGINE_2] = A_NORMAL,\n      [GPU_ENGINE_3] = A_REVERSE | A_BOLD,\n      [GPU_ENGINE_4] = A_REVERSE,\n      [GPU_RESIDUE] = A_BOLD,\n      [PANEL_EDIT] = A_BOLD,\n      [SCREENS_OTH_BORDER] = A_DIM,\n      [SCREENS_OTH_TEXT] = A_DIM,\n      [SCREENS_CUR_BORDER] = A_REVERSE,\n      [SCREENS_CUR_TEXT] = A_REVERSE,\n      [PRESSURE_STALL_THREEHUNDRED] = A_DIM,\n      [PRESSURE_STALL_SIXTY] = A_NORMAL,\n      [PRESSURE_STALL_TEN] = A_BOLD,\n      [FILE_DESCRIPTOR_USED] = A_BOLD,\n      [FILE_DESCRIPTOR_MAX] = A_BOLD,\n      [ZFS_MFU] = A_NORMAL,\n      [ZFS_MRU] = A_NORMAL,\n      [ZFS_ANON] = A_DIM,\n      [ZFS_HEADER] = A_BOLD,\n      [ZFS_OTHER] = A_DIM,\n      [ZFS_COMPRESSED] = A_BOLD,\n      [ZFS_RATIO] = A_BOLD,\n      [ZRAM_COMPRESSED] = A_NORMAL,\n      [ZRAM_UNCOMPRESSED] = A_NORMAL,\n      [DYNAMIC_GRAY] = A_DIM,\n      [DYNAMIC_DARKGRAY] = A_DIM,\n      [DYNAMIC_RED] = A_BOLD,\n      [DYNAMIC_GREEN] = A_NORMAL,\n      [DYNAMIC_BLUE] = A_NORMAL,\n      [DYNAMIC_CYAN] = A_BOLD,\n      [DYNAMIC_MAGENTA] = A_NORMAL,\n      [DYNAMIC_YELLOW] = A_NORMAL,\n      [DYNAMIC_WHITE] = A_BOLD,\n   },\n   [COLORSCHEME_BLACKONWHITE] = {\n      [RESET_COLOR] = ColorPair(Black, White),\n      [DEFAULT_COLOR] = ColorPair(Black, White),\n      [FUNCTION_BAR] = ColorPair(Black, Cyan),\n      [FUNCTION_KEY] = ColorPair(Black, White),\n      [PANEL_HEADER_FOCUS] = ColorPair(Black, Green),\n      [PANEL_HEADER_UNFOCUS] = ColorPair(Black, Green),\n      [PANEL_SELECTION_FOCUS] = ColorPair(Black, Cyan),\n      [PANEL_SELECTION_FOLLOW] = ColorPair(Black, Yellow),\n      [PANEL_SELECTION_UNFOCUS] = ColorPair(Blue, White),\n      [FAILED_SEARCH] = ColorPair(Red, Cyan),\n      [FAILED_READ] = ColorPair(Red, White),\n      [PAUSED] = A_BOLD | ColorPair(Yellow, Cyan),\n      [UPTIME] = ColorPair(Yellow, White),\n      [BATTERY] = ColorPair(Yellow, White),\n      [LARGE_NUMBER] = ColorPair(Red, White),\n      [METER_SHADOW] = ColorPair(Blue, White),\n      [METER_TEXT] = ColorPair(Blue, White),\n      [METER_VALUE] = ColorPair(Black, White),\n      [METER_VALUE_ERROR] = A_BOLD | ColorPair(Red, White),\n      [METER_VALUE_IOREAD] = ColorPair(Green, White),\n      [METER_VALUE_IOWRITE] = ColorPair(Yellow, White),\n      [METER_VALUE_NOTICE] = A_BOLD | ColorPair(Yellow, White),\n      [METER_VALUE_OK] = ColorPair(Green, White),\n      [METER_VALUE_WARN] = A_BOLD | ColorPair(Yellow, White),\n      [LED_COLOR] = ColorPair(Green, White),\n      [TASKS_RUNNING] = ColorPair(Green, White),\n      [PROCESS] = ColorPair(Black, White),\n      [PROCESS_SHADOW] = A_BOLD | ColorPair(Black, White),\n      [PROCESS_TAG] = ColorPair(White, Blue),\n      [PROCESS_MEGABYTES] = ColorPair(Blue, White),\n      [PROCESS_GIGABYTES] = ColorPair(Green, White),\n      [PROCESS_BASENAME] = ColorPair(Blue, White),\n      [PROCESS_TREE] = ColorPair(Green, White),\n      [PROCESS_RUN_STATE] = ColorPair(Green, White),\n      [PROCESS_D_STATE] = A_BOLD | ColorPair(Red, White),\n      [PROCESS_HIGH_PRIORITY] = ColorPair(Red, White),\n      [PROCESS_LOW_PRIORITY] = ColorPair(Green, White),\n      [PROCESS_NEW] = ColorPair(White, Green),\n      [PROCESS_TOMB] = ColorPair(White, Red),\n      [PROCESS_THREAD] = ColorPair(Blue, White),\n      [PROCESS_THREAD_BASENAME] = A_BOLD | ColorPair(Blue, White),\n      [PROCESS_COMM] = ColorPair(Magenta, White),\n      [PROCESS_THREAD_COMM] = ColorPair(Green, White),\n      [PROCESS_PRIV] = ColorPair(Magenta, White),\n      [BAR_BORDER] = ColorPair(Blue, White),\n      [BAR_SHADOW] = ColorPair(Black, White),\n      [SWAP] = ColorPair(Red, White),\n      [SWAP_CACHE] = ColorPair(Yellow, White),\n      [SWAP_FRONTSWAP] = A_BOLD | ColorPair(Black, White),\n      [GRAPH_1] = A_BOLD | ColorPair(Blue, White),\n      [GRAPH_2] = ColorPair(Blue, White),\n      [MEMORY_USED] = ColorPair(Green, White),\n      [MEMORY_BUFFERS] = ColorPair(Cyan, White),\n      [MEMORY_BUFFERS_TEXT] = ColorPair(Cyan, White),\n      [MEMORY_CACHE] = ColorPair(Yellow, White),\n      [MEMORY_SHARED] = ColorPair(Magenta, White),\n      [MEMORY_COMPRESSED] = A_BOLD | ColorPair(Black, White),\n      [HUGEPAGE_1] = ColorPair(Green, White),\n      [HUGEPAGE_2] = ColorPair(Yellow, White),\n      [HUGEPAGE_3] = ColorPair(Red, White),\n      [HUGEPAGE_4] = ColorPair(Blue, White),\n      [LOAD_AVERAGE_FIFTEEN] = ColorPair(Black, White),\n      [LOAD_AVERAGE_FIVE] = ColorPair(Black, White),\n      [LOAD_AVERAGE_ONE] = ColorPair(Black, White),\n      [LOAD] = ColorPair(Black, White),\n      [HELP_BOLD] = ColorPair(Blue, White),\n      [HELP_SHADOW] = A_BOLD | ColorPair(Black, White),\n      [CLOCK] = ColorPair(Black, White),\n      [DATE] = ColorPair(Black, White),\n      [DATETIME] = ColorPair(Black, White),\n      [CHECK_BOX] = ColorPair(Blue, White),\n      [CHECK_MARK] = ColorPair(Black, White),\n      [CHECK_TEXT] = ColorPair(Black, White),\n      [HOSTNAME] = ColorPair(Black, White),\n      [CPU_NICE] = ColorPair(Cyan, White),\n      [CPU_NICE_TEXT] = ColorPair(Cyan, White),\n      [CPU_NORMAL] = ColorPair(Green, White),\n      [CPU_SYSTEM] = ColorPair(Red, White),\n      [CPU_IOWAIT] = A_BOLD | ColorPair(Black, White),\n      [CPU_IRQ] = ColorPair(Blue, White),\n      [CPU_SOFTIRQ] = ColorPair(Blue, White),\n      [CPU_STEAL] = ColorPair(Cyan, White),\n      [CPU_GUEST] = ColorPair(Cyan, White),\n      [GPU_ENGINE_1] = ColorPair(Green, White),\n      [GPU_ENGINE_2] = ColorPair(Yellow, White),\n      [GPU_ENGINE_3] = ColorPair(Red, White),\n      [GPU_ENGINE_4] = ColorPair(Blue, White),\n      [GPU_RESIDUE] = ColorPair(Magenta, White),\n      [PANEL_EDIT] = ColorPair(White, Blue),\n      [SCREENS_OTH_BORDER] = A_BOLD | ColorPair(Black, White),\n      [SCREENS_OTH_TEXT] = A_BOLD | ColorPair(Black, White),\n      [SCREENS_CUR_BORDER] = ColorPair(Green, Green),\n      [SCREENS_CUR_TEXT] = ColorPair(Black, Green),\n      [PRESSURE_STALL_THREEHUNDRED] = ColorPair(Black, White),\n      [PRESSURE_STALL_SIXTY] = ColorPair(Black, White),\n      [PRESSURE_STALL_TEN] = ColorPair(Black, White),\n      [FILE_DESCRIPTOR_USED] = ColorPair(Green, White),\n      [FILE_DESCRIPTOR_MAX] = ColorPair(Blue, White),\n      [ZFS_MFU] = ColorPair(Cyan, White),\n      [ZFS_MRU] = ColorPair(Yellow, White),\n      [ZFS_ANON] = ColorPair(Magenta, White),\n      [ZFS_HEADER] = ColorPair(Yellow, White),\n      [ZFS_OTHER] = ColorPair(Magenta, White),\n      [ZFS_COMPRESSED] = ColorPair(Cyan, White),\n      [ZFS_RATIO] = ColorPair(Magenta, White),\n      [ZRAM_COMPRESSED] = ColorPair(Cyan, White),\n      [ZRAM_UNCOMPRESSED] = ColorPair(Yellow, White),\n      [DYNAMIC_GRAY] = ColorPair(Black, White),\n      [DYNAMIC_DARKGRAY] = A_BOLD | ColorPair(Black, White),\n      [DYNAMIC_RED] = ColorPair(Red, White),\n      [DYNAMIC_GREEN] = ColorPair(Green, White),\n      [DYNAMIC_BLUE] = ColorPair(Blue, White),\n      [DYNAMIC_CYAN] = ColorPair(Yellow, White),\n      [DYNAMIC_MAGENTA] = ColorPair(Magenta, White),\n      [DYNAMIC_YELLOW] = ColorPair(Yellow, White),\n      [DYNAMIC_WHITE] = A_BOLD | ColorPair(Black, White),\n   },\n   [COLORSCHEME_LIGHTTERMINAL] = {\n      [RESET_COLOR] = ColorPair(Black, Black),\n      [DEFAULT_COLOR] = ColorPair(Black, Black),\n      [FUNCTION_BAR] = ColorPair(Black, Cyan),\n      [FUNCTION_KEY] = ColorPair(Black, Black),\n      [PANEL_HEADER_FOCUS] = ColorPair(Black, Green),\n      [PANEL_HEADER_UNFOCUS] = ColorPair(Black, Green),\n      [PANEL_SELECTION_FOCUS] = ColorPair(Black, Cyan),\n      [PANEL_SELECTION_FOLLOW] = ColorPair(Black, Yellow),\n      [PANEL_SELECTION_UNFOCUS] = ColorPair(Blue, Black),\n      [FAILED_SEARCH] = ColorPair(Red, Cyan),\n      [FAILED_READ] = ColorPair(Red, Black),\n      [PAUSED] = A_BOLD | ColorPair(Yellow, Cyan),\n      [UPTIME] = ColorPair(Yellow, Black),\n      [BATTERY] = ColorPair(Yellow, Black),\n      [LARGE_NUMBER] = ColorPair(Red, Black),\n      [METER_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [METER_TEXT] = ColorPair(Blue, Black),\n      [METER_VALUE] = ColorPair(Black, Black),\n      [METER_VALUE_ERROR] = A_BOLD | ColorPair(Red, Black),\n      [METER_VALUE_IOREAD] = ColorPair(Green, Black),\n      [METER_VALUE_IOWRITE] = ColorPair(Yellow, Black),\n      [METER_VALUE_NOTICE] = A_BOLD | ColorPairWhiteDefault,\n      [METER_VALUE_OK] = ColorPair(Green, Black),\n      [METER_VALUE_WARN] = A_BOLD | ColorPair(Yellow, Black),\n      [LED_COLOR] = ColorPair(Green, Black),\n      [TASKS_RUNNING] = ColorPair(Green, Black),\n      [PROCESS] = ColorPair(Black, Black),\n      [PROCESS_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [PROCESS_TAG] = ColorPair(White, Blue),\n      [PROCESS_MEGABYTES] = ColorPair(Blue, Black),\n      [PROCESS_GIGABYTES] = ColorPair(Green, Black),\n      [PROCESS_BASENAME] = ColorPair(Green, Black),\n      [PROCESS_TREE] = ColorPair(Blue, Black),\n      [PROCESS_RUN_STATE] = ColorPair(Green, Black),\n      [PROCESS_D_STATE] = A_BOLD | ColorPair(Red, Black),\n      [PROCESS_HIGH_PRIORITY] = ColorPair(Red, Black),\n      [PROCESS_LOW_PRIORITY] = ColorPair(Green, Black),\n      [PROCESS_NEW] = ColorPair(Black, Green),\n      [PROCESS_TOMB] = ColorPair(Black, Red),\n      [PROCESS_THREAD] = ColorPair(Blue, Black),\n      [PROCESS_THREAD_BASENAME] = A_BOLD | ColorPair(Blue, Black),\n      [PROCESS_COMM] = ColorPair(Magenta, Black),\n      [PROCESS_THREAD_COMM] = ColorPair(Yellow, Black),\n      [PROCESS_PRIV] = ColorPair(Magenta, Black),\n      [BAR_BORDER] = ColorPair(Blue, Black),\n      [BAR_SHADOW] = ColorPairGrayBlack,\n      [SWAP] = ColorPair(Red, Black),\n      [SWAP_CACHE] = ColorPair(Yellow, Black),\n      [SWAP_FRONTSWAP] = ColorPairGrayBlack,\n      [GRAPH_1] = A_BOLD | ColorPair(Cyan, Black),\n      [GRAPH_2] = ColorPair(Cyan, Black),\n      [MEMORY_USED] = ColorPair(Green, Black),\n      [MEMORY_BUFFERS] = ColorPair(Cyan, Black),\n      [MEMORY_BUFFERS_TEXT] = ColorPair(Cyan, Black),\n      [MEMORY_CACHE] = ColorPair(Yellow, Black),\n      [MEMORY_SHARED] = ColorPair(Magenta, Black),\n      [MEMORY_COMPRESSED] = ColorPairGrayBlack,\n      [HUGEPAGE_1] = ColorPair(Green, Black),\n      [HUGEPAGE_2] = ColorPair(Yellow, Black),\n      [HUGEPAGE_3] = ColorPair(Red, Black),\n      [HUGEPAGE_4] = ColorPair(Blue, Black),\n      [LOAD_AVERAGE_FIFTEEN] = ColorPair(Black, Black),\n      [LOAD_AVERAGE_FIVE] = ColorPair(Black, Black),\n      [LOAD_AVERAGE_ONE] = ColorPair(Black, Black),\n      [LOAD] = ColorPairWhiteDefault,\n      [HELP_BOLD] = ColorPair(Blue, Black),\n      [HELP_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [CLOCK] = ColorPairWhiteDefault,\n      [DATE] = ColorPairWhiteDefault,\n      [DATETIME] = ColorPairWhiteDefault,\n      [CHECK_BOX] = ColorPair(Blue, Black),\n      [CHECK_MARK] = ColorPair(Black, Black),\n      [CHECK_TEXT] = ColorPair(Black, Black),\n      [HOSTNAME] = ColorPairWhiteDefault,\n      [CPU_NICE] = ColorPair(Cyan, Black),\n      [CPU_NICE_TEXT] = ColorPair(Cyan, Black),\n      [CPU_NORMAL] = ColorPair(Green, Black),\n      [CPU_SYSTEM] = ColorPair(Red, Black),\n      [CPU_IOWAIT] = A_BOLD | ColorPair(Black, Black),\n      [CPU_IRQ] = A_BOLD | ColorPair(Blue, Black),\n      [CPU_SOFTIRQ] = ColorPair(Blue, Black),\n      [CPU_STEAL] = ColorPair(Black, Black),\n      [CPU_GUEST] = ColorPair(Black, Black),\n      [GPU_ENGINE_1] = ColorPair(Green, Black),\n      [GPU_ENGINE_2] = ColorPair(Yellow, Black),\n      [GPU_ENGINE_3] = ColorPair(Red, Black),\n      [GPU_ENGINE_4] = ColorPair(Blue, Black),\n      [GPU_RESIDUE] = ColorPair(Magenta, Black),\n      [PANEL_EDIT] = ColorPair(White, Blue),\n      [SCREENS_OTH_BORDER] = ColorPair(Blue, Black),\n      [SCREENS_OTH_TEXT] = ColorPair(Blue, Black),\n      [SCREENS_CUR_BORDER] = ColorPair(Green, Green),\n      [SCREENS_CUR_TEXT] = ColorPair(Black, Green),\n      [PRESSURE_STALL_THREEHUNDRED] = ColorPair(Black, Black),\n      [PRESSURE_STALL_SIXTY] = ColorPair(Black, Black),\n      [PRESSURE_STALL_TEN] = ColorPair(Black, Black),\n      [FILE_DESCRIPTOR_USED] = ColorPair(Green, Black),\n      [FILE_DESCRIPTOR_MAX] = A_BOLD | ColorPair(Blue, Black),\n      [ZFS_MFU] = ColorPair(Cyan, Black),\n      [ZFS_MRU] = ColorPair(Yellow, Black),\n      [ZFS_ANON] = A_BOLD | ColorPair(Magenta, Black),\n      [ZFS_HEADER] = ColorPair(Black, Black),\n      [ZFS_OTHER] = A_BOLD | ColorPair(Magenta, Black),\n      [ZFS_COMPRESSED] = ColorPair(Cyan, Black),\n      [ZFS_RATIO] = A_BOLD | ColorPair(Magenta, Black),\n      [ZRAM_COMPRESSED] = ColorPair(Cyan, Black),\n      [ZRAM_UNCOMPRESSED] = ColorPair(Yellow, Black),\n      [DYNAMIC_GRAY] = ColorPairGrayBlack,\n      [DYNAMIC_DARKGRAY] = A_BOLD | ColorPairGrayBlack,\n      [DYNAMIC_RED] = ColorPair(Red, Black),\n      [DYNAMIC_GREEN] = ColorPair(Green, Black),\n      [DYNAMIC_BLUE] = ColorPair(Blue, Black),\n      [DYNAMIC_CYAN] = ColorPair(Cyan, Black),\n      [DYNAMIC_MAGENTA] = ColorPair(Magenta, Black),\n      [DYNAMIC_YELLOW] = ColorPair(Yellow, Black),\n      [DYNAMIC_WHITE] = ColorPairWhiteDefault,\n   },\n   [COLORSCHEME_MIDNIGHT] = {\n      [RESET_COLOR] = ColorPair(White, Blue),\n      [DEFAULT_COLOR] = ColorPair(White, Blue),\n      [FUNCTION_BAR] = ColorPair(Black, Cyan),\n      [FUNCTION_KEY] = A_NORMAL,\n      [PANEL_HEADER_FOCUS] = ColorPair(Black, Cyan),\n      [PANEL_HEADER_UNFOCUS] = ColorPair(Black, Cyan),\n      [PANEL_SELECTION_FOCUS] = ColorPair(Black, White),\n      [PANEL_SELECTION_FOLLOW] = ColorPair(Black, Yellow),\n      [PANEL_SELECTION_UNFOCUS] = A_BOLD | ColorPair(Yellow, Blue),\n      [FAILED_SEARCH] = ColorPair(Red, Cyan),\n      [FAILED_READ] = A_BOLD | ColorPair(Red, Blue),\n      [PAUSED] = A_BOLD | ColorPair(Yellow, Cyan),\n      [UPTIME] = A_BOLD | ColorPair(Yellow, Blue),\n      [BATTERY] = A_BOLD | ColorPair(Yellow, Blue),\n      [LARGE_NUMBER] = A_BOLD | ColorPair(Red, Blue),\n      [METER_SHADOW] = ColorPair(Cyan, Blue),\n      [METER_TEXT] = ColorPair(Cyan, Blue),\n      [METER_VALUE] = A_BOLD | ColorPair(Cyan, Blue),\n      [METER_VALUE_ERROR] = A_BOLD | ColorPair(Red, Blue),\n      [METER_VALUE_IOREAD] = ColorPair(Green, Blue),\n      [METER_VALUE_IOWRITE] = ColorPair(Black, Blue),\n      [METER_VALUE_NOTICE] = A_BOLD | ColorPair(White, Blue),\n      [METER_VALUE_OK] = ColorPair(Green, Blue),\n      [METER_VALUE_WARN] = A_BOLD | ColorPair(Yellow, Black),\n      [LED_COLOR] = ColorPair(Green, Blue),\n      [TASKS_RUNNING] = A_BOLD | ColorPair(Green, Blue),\n      [PROCESS] = ColorPair(White, Blue),\n      [PROCESS_SHADOW] = A_BOLD | ColorPair(Black, Blue),\n      [PROCESS_TAG] = A_BOLD | ColorPair(Yellow, Blue),\n      [PROCESS_MEGABYTES] = ColorPair(Cyan, Blue),\n      [PROCESS_GIGABYTES] = ColorPair(Green, Blue),\n      [PROCESS_BASENAME] = A_BOLD | ColorPair(Cyan, Blue),\n      [PROCESS_TREE] = ColorPair(Cyan, Blue),\n      [PROCESS_RUN_STATE] = ColorPair(Green, Blue),\n      [PROCESS_D_STATE] = A_BOLD | ColorPair(Red, Blue),\n      [PROCESS_HIGH_PRIORITY] = ColorPair(Red, Blue),\n      [PROCESS_LOW_PRIORITY] = ColorPair(Green, Blue),\n      [PROCESS_NEW] = ColorPair(Blue, Green),\n      [PROCESS_TOMB] = ColorPair(Blue, Red),\n      [PROCESS_THREAD] = ColorPair(Green, Blue),\n      [PROCESS_THREAD_BASENAME] = A_BOLD | ColorPair(Green, Blue),\n      [PROCESS_COMM] = ColorPair(Magenta, Blue),\n      [PROCESS_THREAD_COMM] = ColorPair(Black, Blue),\n      [PROCESS_PRIV] = ColorPair(Magenta, Blue),\n      [BAR_BORDER] = A_BOLD | ColorPair(Yellow, Blue),\n      [BAR_SHADOW] = ColorPair(Cyan, Blue),\n      [SWAP] = ColorPair(Red, Blue),\n      [SWAP_CACHE] = A_BOLD | ColorPair(Yellow, Blue),\n      [SWAP_FRONTSWAP] = A_BOLD | ColorPair(Black, Blue),\n      [GRAPH_1] = A_BOLD | ColorPair(Cyan, Blue),\n      [GRAPH_2] = ColorPair(Cyan, Blue),\n      [MEMORY_USED] = A_BOLD | ColorPair(Green, Blue),\n      [MEMORY_BUFFERS] = A_BOLD | ColorPair(Cyan, Blue),\n      [MEMORY_BUFFERS_TEXT] = A_BOLD | ColorPair(Cyan, Blue),\n      [MEMORY_CACHE] = A_BOLD | ColorPair(Yellow, Blue),\n      [MEMORY_SHARED] = A_BOLD | ColorPair(Magenta, Blue),\n      [MEMORY_COMPRESSED] = A_BOLD | ColorPair(Black, Blue),\n      [HUGEPAGE_1] = A_BOLD | ColorPair(Green, Blue),\n      [HUGEPAGE_2] = A_BOLD | ColorPair(Yellow, Blue),\n      [HUGEPAGE_3] = A_BOLD | ColorPair(Red, Blue),\n      [HUGEPAGE_4] = A_BOLD | ColorPair(White, Blue),\n      [LOAD_AVERAGE_FIFTEEN] = A_BOLD | ColorPair(Black, Blue),\n      [LOAD_AVERAGE_FIVE] = A_NORMAL | ColorPair(White, Blue),\n      [LOAD_AVERAGE_ONE] = A_BOLD | ColorPair(White, Blue),\n      [LOAD] = A_BOLD | ColorPair(White, Blue),\n      [HELP_BOLD] = A_BOLD | ColorPair(Cyan, Blue),\n      [HELP_SHADOW] = A_BOLD | ColorPair(Black, Blue),\n      [CLOCK] = ColorPair(White, Blue),\n      [DATE] = ColorPair(White, Blue),\n      [DATETIME] = ColorPair(White, Blue),\n      [CHECK_BOX] = ColorPair(Cyan, Blue),\n      [CHECK_MARK] = A_BOLD | ColorPair(White, Blue),\n      [CHECK_TEXT] = A_NORMAL | ColorPair(White, Blue),\n      [HOSTNAME] = ColorPair(White, Blue),\n      [CPU_NICE] = A_BOLD | ColorPair(Cyan, Blue),\n      [CPU_NICE_TEXT] = A_BOLD | ColorPair(Cyan, Blue),\n      [CPU_NORMAL] = A_BOLD | ColorPair(Green, Blue),\n      [CPU_SYSTEM] = A_BOLD | ColorPair(Red, Blue),\n      [CPU_IOWAIT] = A_BOLD | ColorPair(Black, Blue),\n      [CPU_IRQ] = A_BOLD | ColorPair(Black, Blue),\n      [CPU_SOFTIRQ] = ColorPair(Black, Blue),\n      [CPU_STEAL] = ColorPair(White, Blue),\n      [CPU_GUEST] = ColorPair(White, Blue),\n      [GPU_ENGINE_1] = A_BOLD | ColorPair(Green, Blue),\n      [GPU_ENGINE_2] = A_BOLD | ColorPair(Yellow, Blue),\n      [GPU_ENGINE_3] = A_BOLD | ColorPair(Red, Blue),\n      [GPU_ENGINE_4] = A_BOLD | ColorPair(White, Blue),\n      [GPU_RESIDUE] = A_BOLD | ColorPair(Magenta, Blue),\n      [PANEL_EDIT] = ColorPair(White, Blue),\n      [SCREENS_OTH_BORDER] = A_BOLD | ColorPair(Yellow, Blue),\n      [SCREENS_OTH_TEXT] = ColorPair(Cyan, Blue),\n      [SCREENS_CUR_BORDER] = ColorPair(Cyan, Cyan),\n      [SCREENS_CUR_TEXT] = ColorPair(Black, Cyan),\n      [PRESSURE_STALL_THREEHUNDRED] = A_BOLD | ColorPair(Black, Blue),\n      [PRESSURE_STALL_SIXTY] = A_NORMAL | ColorPair(White, Blue),\n      [PRESSURE_STALL_TEN] = A_BOLD | ColorPair(White, Blue),\n      [FILE_DESCRIPTOR_USED] = A_BOLD | ColorPair(Green, Blue),\n      [FILE_DESCRIPTOR_MAX] = A_BOLD | ColorPair(Red, Blue),\n      [ZFS_MFU] = A_BOLD | ColorPair(White, Blue),\n      [ZFS_MRU] = A_BOLD | ColorPair(Yellow, Blue),\n      [ZFS_ANON] = A_BOLD | ColorPair(Magenta, Blue),\n      [ZFS_HEADER] = A_BOLD | ColorPair(Yellow, Blue),\n      [ZFS_OTHER] = A_BOLD | ColorPair(Magenta, Blue),\n      [ZFS_COMPRESSED] = A_BOLD | ColorPair(White, Blue),\n      [ZFS_RATIO] = A_BOLD | ColorPair(Magenta, Blue),\n      [ZRAM_COMPRESSED] = ColorPair(Cyan, Blue),\n      [ZRAM_UNCOMPRESSED] = ColorPair(Yellow, Blue),\n      [DYNAMIC_GRAY] = ColorPairGrayBlack,\n      [DYNAMIC_DARKGRAY] = A_BOLD | ColorPairGrayBlack,\n      [DYNAMIC_RED] = ColorPair(Red, Blue),\n      [DYNAMIC_GREEN] = ColorPair(Green, Blue),\n      [DYNAMIC_BLUE] = ColorPair(Black, Blue),\n      [DYNAMIC_CYAN] = ColorPair(Cyan, Blue),\n      [DYNAMIC_MAGENTA] = ColorPair(Magenta, Blue),\n      [DYNAMIC_YELLOW] = ColorPair(Yellow, Blue),\n      [DYNAMIC_WHITE] = ColorPair(White, Blue),\n   },\n   [COLORSCHEME_BLACKNIGHT] = {\n      [RESET_COLOR] = ColorPair(Cyan, Black),\n      [DEFAULT_COLOR] = ColorPair(Cyan, Black),\n      [FUNCTION_BAR] = ColorPair(Black, Green),\n      [FUNCTION_KEY] = ColorPair(Cyan, Black),\n      [PANEL_HEADER_FOCUS] = ColorPair(Black, Green),\n      [PANEL_HEADER_UNFOCUS] = ColorPair(Black, Green),\n      [PANEL_SELECTION_FOCUS] = ColorPair(Black, Cyan),\n      [PANEL_SELECTION_FOLLOW] = ColorPair(Black, Yellow),\n      [PANEL_SELECTION_UNFOCUS] = ColorPair(Black, White),\n      [FAILED_SEARCH] = ColorPair(Red, Green),\n      [FAILED_READ] = A_BOLD | ColorPair(Red, Black),\n      [PAUSED] = A_BOLD | ColorPair(Yellow, Green),\n      [UPTIME] = ColorPair(Green, Black),\n      [BATTERY] = ColorPair(Green, Black),\n      [LARGE_NUMBER] = A_BOLD | ColorPair(Red, Black),\n      [METER_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [METER_TEXT] = ColorPair(Cyan, Black),\n      [METER_VALUE] = ColorPair(Green, Black),\n      [METER_VALUE_ERROR] = A_BOLD | ColorPair(Red, Black),\n      [METER_VALUE_IOREAD] = ColorPair(Green, Black),\n      [METER_VALUE_IOWRITE] = ColorPair(Blue, Black),\n      [METER_VALUE_NOTICE] = A_BOLD | ColorPair(White, Black),\n      [METER_VALUE_OK] = ColorPair(Green, Black),\n      [METER_VALUE_WARN] = A_BOLD | ColorPair(Yellow, Black),\n      [LED_COLOR] = ColorPair(Green, Black),\n      [TASKS_RUNNING] = A_BOLD | ColorPair(Green, Black),\n      [PROCESS] = ColorPair(Cyan, Black),\n      [PROCESS_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [PROCESS_TAG] = A_BOLD | ColorPair(Yellow, Black),\n      [PROCESS_MEGABYTES] = A_BOLD | ColorPair(Green, Black),\n      [PROCESS_GIGABYTES] = A_BOLD | ColorPair(Yellow, Black),\n      [PROCESS_BASENAME] = A_BOLD | ColorPair(Green, Black),\n      [PROCESS_TREE] = ColorPair(Cyan, Black),\n      [PROCESS_THREAD] = ColorPair(Green, Black),\n      [PROCESS_THREAD_BASENAME] = A_BOLD | ColorPair(Blue, Black),\n      [PROCESS_COMM] = ColorPair(Magenta, Black),\n      [PROCESS_THREAD_COMM] = ColorPair(Yellow, Black),\n      [PROCESS_RUN_STATE] = ColorPair(Green, Black),\n      [PROCESS_D_STATE] = A_BOLD | ColorPair(Red, Black),\n      [PROCESS_HIGH_PRIORITY] = ColorPair(Red, Black),\n      [PROCESS_LOW_PRIORITY] = ColorPair(Green, Black),\n      [PROCESS_NEW] = ColorPair(Black, Green),\n      [PROCESS_TOMB] = ColorPair(Black, Red),\n      [PROCESS_PRIV] = ColorPair(Magenta, Black),\n      [BAR_BORDER] = A_BOLD | ColorPair(Green, Black),\n      [BAR_SHADOW] = ColorPair(Cyan, Black),\n      [SWAP] = ColorPair(Red, Black),\n      [SWAP_CACHE] = ColorPair(Yellow, Black),\n      [SWAP_FRONTSWAP] = ColorPair(Yellow, Black),\n      [GRAPH_1] = A_BOLD | ColorPair(Green, Black),\n      [GRAPH_2] = ColorPair(Green, Black),\n      [MEMORY_USED] = ColorPair(Green, Black),\n      [MEMORY_BUFFERS] = ColorPair(Blue, Black),\n      [MEMORY_BUFFERS_TEXT] = A_BOLD | ColorPair(Blue, Black),\n      [MEMORY_CACHE] = ColorPair(Yellow, Black),\n      [MEMORY_SHARED] = ColorPair(Magenta, Black),\n      [MEMORY_COMPRESSED] = ColorPair(Yellow, Black),\n      [HUGEPAGE_1] = ColorPair(Green, Black),\n      [HUGEPAGE_2] = ColorPair(Yellow, Black),\n      [HUGEPAGE_3] = ColorPair(Red, Black),\n      [HUGEPAGE_4] = ColorPair(Blue, Black),\n      [LOAD_AVERAGE_FIFTEEN] = ColorPair(Green, Black),\n      [LOAD_AVERAGE_FIVE] = ColorPair(Green, Black),\n      [LOAD_AVERAGE_ONE] = A_BOLD | ColorPair(Green, Black),\n      [LOAD] = A_BOLD,\n      [HELP_BOLD] = A_BOLD | ColorPair(Cyan, Black),\n      [HELP_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [CLOCK] = ColorPair(Green, Black),\n      [CHECK_BOX] = ColorPair(Green, Black),\n      [CHECK_MARK] = A_BOLD | ColorPair(Green, Black),\n      [CHECK_TEXT] = ColorPair(Cyan, Black),\n      [HOSTNAME] = ColorPair(Green, Black),\n      [CPU_NICE] = ColorPair(Blue, Black),\n      [CPU_NICE_TEXT] = A_BOLD | ColorPair(Blue, Black),\n      [CPU_NORMAL] = ColorPair(Green, Black),\n      [CPU_SYSTEM] = ColorPair(Red, Black),\n      [CPU_IOWAIT] = ColorPair(Yellow, Black),\n      [CPU_IRQ] = A_BOLD | ColorPair(Blue, Black),\n      [CPU_SOFTIRQ] = ColorPair(Blue, Black),\n      [CPU_STEAL] = ColorPair(Cyan, Black),\n      [CPU_GUEST] = ColorPair(Cyan, Black),\n      [GPU_ENGINE_1] = ColorPair(Green, Black),\n      [GPU_ENGINE_2] = ColorPair(Yellow, Black),\n      [GPU_ENGINE_3] = ColorPair(Red, Black),\n      [GPU_ENGINE_4] = ColorPair(Blue, Black),\n      [GPU_RESIDUE] = ColorPair(Magenta, Black),\n      [PANEL_EDIT] = ColorPair(White, Cyan),\n      [SCREENS_OTH_BORDER] = ColorPair(White, Black),\n      [SCREENS_OTH_TEXT] = ColorPair(Cyan, Black),\n      [SCREENS_CUR_BORDER] = A_BOLD | ColorPair(White, Black),\n      [SCREENS_CUR_TEXT] = A_BOLD | ColorPair(Green, Black),\n      [PRESSURE_STALL_THREEHUNDRED] = ColorPair(Green, Black),\n      [PRESSURE_STALL_SIXTY] = ColorPair(Green, Black),\n      [PRESSURE_STALL_TEN] = A_BOLD | ColorPair(Green, Black),\n      [FILE_DESCRIPTOR_USED] = ColorPair(Green, Black),\n      [FILE_DESCRIPTOR_MAX] = A_BOLD | ColorPair(Blue, Black),\n      [ZFS_MFU] = ColorPair(Blue, Black),\n      [ZFS_MRU] = ColorPair(Yellow, Black),\n      [ZFS_ANON] = ColorPair(Magenta, Black),\n      [ZFS_HEADER] = ColorPair(Yellow, Black),\n      [ZFS_OTHER] = ColorPair(Magenta, Black),\n      [ZFS_COMPRESSED] = ColorPair(Blue, Black),\n      [ZFS_RATIO] = ColorPair(Magenta, Black),\n      [ZRAM_COMPRESSED] = ColorPair(Blue, Black),\n      [ZRAM_UNCOMPRESSED] = ColorPair(Yellow, Black),\n      [DYNAMIC_GRAY] = ColorPairGrayBlack,\n      [DYNAMIC_DARKGRAY] = A_BOLD | ColorPairGrayBlack,\n      [DYNAMIC_RED] = ColorPair(Red, Black),\n      [DYNAMIC_GREEN] = ColorPair(Green, Black),\n      [DYNAMIC_BLUE] = ColorPair(Blue, Black),\n      [DYNAMIC_CYAN] = ColorPair(Cyan, Black),\n      [DYNAMIC_MAGENTA] = ColorPair(Magenta, Black),\n      [DYNAMIC_YELLOW] = ColorPair(Yellow, Black),\n      [DYNAMIC_WHITE] = ColorPair(White, Black),\n   },\n   [COLORSCHEME_BROKENGRAY] = { 0 } // dynamically generated.\n};\n\nstatic bool CRT_retainScreenOnExit = false;\n\nint CRT_scrollHAmount = 5;\n\nint CRT_scrollWheelVAmount = 10;\n\nColorScheme CRT_colorScheme = COLORSCHEME_DEFAULT;\n\nATTR_NORETURN\nstatic void CRT_handleSIGTERM(int sgn) {\n   CRT_done();\n\n   if (!CRT_settings->changed)\n      _exit(0);\n\n   const char* signal_str = strsignal(sgn);\n   if (!signal_str)\n      signal_str = \"unknown reason\";\n\n   char err_buf[512];\n   snprintf(err_buf, sizeof(err_buf),\n           \"A signal %d (%s) was received, exiting without persisting settings to htoprc.\\n\",\n           sgn, signal_str);\n   full_write_str(STDERR_FILENO, err_buf);\n   _exit(0);\n}\n\n#ifndef NDEBUG\n\nstatic int stderrRedirectNewFd = -1;\nstatic int stderrRedirectBackupFd = -1;\n\nstatic int createStderrCacheFile(void) {\n#if defined(HAVE_MEMFD_CREATE)\n   return memfd_create(\"htop.stderr-redirect\", 0);\n#elif defined(O_TMPFILE)\n   return open(\"/tmp\", O_TMPFILE | O_CREAT | O_EXCL | O_RDWR, S_IRUSR | S_IWUSR);\n#else\n   char tmpName[] = \"htop.stderr-redirectXXXXXX\";\n   mode_t curUmask = umask(S_IXUSR | S_IRWXG | S_IRWXO);\n   int r = mkstemp(tmpName);\n   umask(curUmask);\n   if (r < 0)\n      return r;\n\n   (void) unlink(tmpName);\n\n   return r;\n#endif /* HAVE_MEMFD_CREATE */\n}\n\nstatic void redirectStderr(void) {\n   stderrRedirectNewFd = createStderrCacheFile();\n   if (stderrRedirectNewFd < 0) {\n      /* ignore failure */\n      return;\n   }\n\n   stderrRedirectBackupFd = dup(STDERR_FILENO);\n   dup2(stderrRedirectNewFd, STDERR_FILENO);\n}\n\nstatic void dumpStderr(void) {\n   if (stderrRedirectNewFd < 0)\n      return;\n\n   fsync(STDERR_FILENO);\n   dup2(stderrRedirectBackupFd, STDERR_FILENO);\n   close(stderrRedirectBackupFd);\n   stderrRedirectBackupFd = -1;\n   lseek(stderrRedirectNewFd, 0, SEEK_SET);\n\n   bool header = false;\n   char buffer[8192];\n   for (;;) {\n      errno = 0;\n      ssize_t res = read(stderrRedirectNewFd, buffer, sizeof(buffer));\n      if (res < 0) {\n         if (errno == EINTR)\n            continue;\n\n         break;\n      }\n\n      if (res == 0) {\n         break;\n      }\n\n      if (res > 0) {\n         if (!header) {\n            full_write_str(STDERR_FILENO, \">>>>>>>>>> stderr output >>>>>>>>>>\\n\");\n            header = true;\n         }\n         full_write(STDERR_FILENO, buffer, res);\n      }\n   }\n\n   if (header)\n      full_write_str(STDERR_FILENO, \"\\n<<<<<<<<<< stderr output <<<<<<<<<<\\n\");\n\n   close(stderrRedirectNewFd);\n   stderrRedirectNewFd = -1;\n}\n\nvoid CRT_debug_impl(const char* file, size_t lineno, const char* func, const char* fmt, ...)  {\n   va_list args;\n\n   fprintf(stderr, \"[%s:%zu (%s)]: \", file, lineno, func);\n   va_start(args, fmt);\n   vfprintf(stderr, fmt, args);\n   va_end(args);\n   fprintf(stderr, \"\\n\");\n}\n\n#else /* !NDEBUG */\n\nstatic void redirectStderr(void) {\n}\n\nstatic void dumpStderr(void) {\n}\n\n#endif /* !NDEBUG */\n\nstatic struct sigaction old_sig_handler[32];\n\nstatic void CRT_installSignalHandlers(void) {\n   struct sigaction act;\n   sigemptyset(&act.sa_mask);\n   act.sa_flags = (int)SA_RESETHAND | SA_NODEFER;\n   act.sa_handler = CRT_handleSIGSEGV;\n   sigaction(SIGSEGV, &act, &old_sig_handler[SIGSEGV]);\n   sigaction(SIGFPE, &act, &old_sig_handler[SIGFPE]);\n   sigaction(SIGILL, &act, &old_sig_handler[SIGILL]);\n   sigaction(SIGBUS, &act, &old_sig_handler[SIGBUS]);\n   sigaction(SIGPIPE, &act, &old_sig_handler[SIGPIPE]);\n   sigaction(SIGSYS, &act, &old_sig_handler[SIGSYS]);\n   sigaction(SIGABRT, &act, &old_sig_handler[SIGABRT]);\n\n   signal(SIGCHLD, SIG_DFL);\n   signal(SIGINT, CRT_handleSIGTERM);\n   signal(SIGTERM, CRT_handleSIGTERM);\n   signal(SIGQUIT, CRT_handleSIGTERM);\n   signal(SIGUSR1, SIG_IGN);\n   signal(SIGUSR2, SIG_IGN);\n}\n\nvoid CRT_resetSignalHandlers(void) {\n   sigaction(SIGSEGV, &old_sig_handler[SIGSEGV], NULL);\n   sigaction(SIGFPE, &old_sig_handler[SIGFPE], NULL);\n   sigaction(SIGILL, &old_sig_handler[SIGILL], NULL);\n   sigaction(SIGBUS, &old_sig_handler[SIGBUS], NULL);\n   sigaction(SIGPIPE, &old_sig_handler[SIGPIPE], NULL);\n   sigaction(SIGSYS, &old_sig_handler[SIGSYS], NULL);\n   sigaction(SIGABRT, &old_sig_handler[SIGABRT], NULL);\n\n   signal(SIGINT, SIG_DFL);\n   signal(SIGTERM, SIG_DFL);\n   signal(SIGQUIT, SIG_DFL);\n   signal(SIGUSR1, SIG_DFL);\n   signal(SIGUSR2, SIG_DFL);\n}\n\n#ifdef HAVE_GETMOUSE\nvoid CRT_setMouse(bool enabled) {\n   if (enabled) {\n#if NCURSES_MOUSE_VERSION > 1\n      mousemask(BUTTON1_RELEASED | BUTTON4_PRESSED | BUTTON5_PRESSED, NULL);\n#else\n      mousemask(BUTTON1_RELEASED, NULL);\n#endif\n   } else {\n      mousemask(0, NULL);\n   }\n}\n#endif\n\nstatic bool terminalSupportsDefinedKeys(const char* termType) {\n   if (!termType) {\n      return false;\n   }\n\n   switch (termType[0]) {\n   case 'a':\n      if (String_eq(termType, \"alacritty\")) {\n         return true;\n      }\n      break;\n   case 's':\n      if (termType[1] == 't' && (termType[2] == '-' || !termType[2])) {\n         return true;\n      }\n      if (String_eq(termType, \"screen\")) {\n         return true;\n      }\n      break;\n   case 't':\n      if (String_eq(termType, \"tmux\")) {\n         return true;\n      }\n      break;\n   case 'v':\n      if (String_eq(termType, \"vt220\")) {\n         return true;\n      }\n      break;\n   case 'x':\n      if (String_eq(termType, \"xterm\")) {\n         return true;\n      }\n      break;\n   }\n\n   return false;\n}\n\nvoid CRT_init(const Settings* settings, bool allowUnicode, bool retainScreenOnExit) {\n   initscr();\n\n   if (retainScreenOnExit) {\n      CRT_retainScreenOnExit = true;\n      refresh();\n      tputs(exit_ca_mode, 0, putchar);\n      tputs(clear_screen, 0, putchar);\n      fflush(stdout);\n      enter_ca_mode = 0;\n      exit_ca_mode = 0;\n   }\n\n   redirectStderr();\n   noecho();\n   CRT_settings = settings;\n   CRT_colors = CRT_colorSchemes[settings->colorScheme];\n   CRT_colorScheme = settings->colorScheme;\n\n   for (int i = 0; i < LAST_COLORELEMENT; i++) {\n      unsigned int color = CRT_colorSchemes[COLORSCHEME_DEFAULT][i];\n      CRT_colorSchemes[COLORSCHEME_BROKENGRAY][i] = color == (A_BOLD | ColorPairGrayBlack) ? ColorPair(White, Black) : color;\n   }\n\n   halfdelay(settings->delay);\n   nonl();\n   intrflush(stdscr, false);\n   keypad(stdscr, true);\n#ifdef HAVE_GETMOUSE\n   mouseinterval(0);\n#endif\n   curs_set(0);\n\n   if (has_colors()) {\n      start_color();\n   }\n\n   const char* termType = getenv(\"TERM\");\n   if (termType && String_eq(termType, \"linux\")) {\n      CRT_scrollHAmount = 20;\n   } else {\n      CRT_scrollHAmount = 5;\n   }\n\n   if (terminalSupportsDefinedKeys(termType)) {\n#ifdef HTOP_NETBSD\n#define define_key(s_, k_) define_key((char*)s_, k_)\nIGNORE_WCASTQUAL_BEGIN\n#endif\n      define_key(\"\\033[H\", KEY_HOME);\n      define_key(\"\\033[F\", KEY_END);\n      define_key(\"\\033[7~\", KEY_HOME);\n      define_key(\"\\033[8~\", KEY_END);\n      define_key(\"\\033OP\", KEY_F(1));\n      define_key(\"\\033OQ\", KEY_F(2));\n      define_key(\"\\033OR\", KEY_F(3));\n      define_key(\"\\033OS\", KEY_F(4));\n      define_key(\"\\033O2R\", KEY_F(15));\n      define_key(\"\\033[11~\", KEY_F(1));\n      define_key(\"\\033[12~\", KEY_F(2));\n      define_key(\"\\033[13~\", KEY_F(3));\n      define_key(\"\\033[14~\", KEY_F(4));\n      define_key(\"\\033[14;2~\", KEY_F(15));\n      define_key(\"\\033[17;2~\", KEY_F(18));\n      define_key(\"\\033[Z\", KEY_SHIFT_TAB);\n      char sequence[3] = \"\\033a\";\n      for (char c = 'a'; c <= 'z'; c++) {\n         sequence[1] = c;\n         define_key(sequence, KEY_ALT('A' + (c - 'a')));\n      }\n      define_key(\"\\033[I\", KEY_FOCUS_IN);\n      define_key(\"\\033[O\", KEY_FOCUS_OUT);\n#ifdef HTOP_NETBSD\nIGNORE_WCASTQUAL_END\n#undef define_key\n#endif\n   }\n   if (termType && (String_startsWith(termType, \"rxvt\"))) {\n      define_key(\"\\033[Z\", KEY_SHIFT_TAB);\n   }\n\n   CRT_installSignalHandlers();\n\n   use_default_colors();\n   if (!has_colors())\n      CRT_colorScheme = COLORSCHEME_MONOCHROME;\n   CRT_setColors(CRT_colorScheme);\n\n#ifdef HAVE_LIBNCURSESW\n   if (allowUnicode && String_eq(nl_langinfo(CODESET), \"UTF-8\")) {\n      CRT_utf8 = true;\n   } else {\n      CRT_utf8 = false;\n   }\n#else\n   (void) allowUnicode;\n#endif\n\n   CRT_treeStr =\n#ifdef HAVE_LIBNCURSESW\n      CRT_utf8 ? CRT_treeStrUtf8 :\n#endif\n      CRT_treeStrAscii;\n\n   CRT_setMouse(settings->enableMouse);\n\n   CRT_degreeSign = initDegreeSign();\n}\n\nvoid CRT_done(void) {\n   int resetColor = CRT_colors ? CRT_colors[RESET_COLOR] : CRT_colorSchemes[COLORSCHEME_DEFAULT][RESET_COLOR];\n\n   attron(resetColor);\n   mvhline(LINES - 1, 0, ' ', COLS);\n   attroff(resetColor);\n   refresh();\n\n   if (CRT_retainScreenOnExit) {\n      mvcur(-1, -1, LINES - 1, 0);\n   }\n\n   curs_set(1);\n   endwin();\n\n   dumpStderr();\n}\n\nvoid CRT_fatalError(const char* note) {\n   const char* sysMsg = strerror(errno);\n   CRT_done();\n   fprintf(stderr, \"%s: %s\\n\", note, sysMsg);\n   exit(2);\n}\n\nint CRT_readKey(void) {\n   nocbreak();\n   cbreak();\n   nodelay(stdscr, FALSE);\n   int ret = getch();\n   halfdelay(CRT_settings->delay);\n   return ret;\n}\n\nvoid CRT_disableDelay(void) {\n   nocbreak();\n   cbreak();\n   nodelay(stdscr, TRUE);\n}\n\nvoid CRT_enableDelay(void) {\n   halfdelay(CRT_settings->delay);\n}\n\nvoid CRT_setColors(int colorScheme) {\n   CRT_colorScheme = colorScheme;\n\n   for (short int i = 0; i < 8; i++) {\n      for (short int j = 0; j < 8; j++) {\n         if (ColorIndex(i, j) != ColorIndexGrayBlack && ColorIndex(i, j) != ColorIndexWhiteDefault) {\n            short int bg = (colorScheme != COLORSCHEME_BLACKNIGHT) && (j == 0) ? -1 : j;\n            init_pair(ColorIndex(i, j), i, bg);\n         }\n      }\n   }\n\n   short int grayBlackFg = COLORS > 8 ? 8 : 0;\n   short int grayBlackBg = (colorScheme != COLORSCHEME_BLACKNIGHT) ? -1 : 0;\n   init_pair(ColorIndexGrayBlack, grayBlackFg, grayBlackBg);\n\n   init_pair(ColorIndexWhiteDefault, White, -1);\n\n   CRT_colors = CRT_colorSchemes[colorScheme];\n}\n\n#ifdef PRINT_BACKTRACE\nstatic void print_backtrace(void) {\n#if defined(HAVE_LIBUNWIND_H) && defined(HAVE_LIBUNWIND)\n   unw_context_t context;\n   unw_getcontext(&context);\n\n   unw_cursor_t cursor;\n   unw_init_local(&cursor, &context);\n\n   unsigned int item = 0;\n\n   char err_buf[1024];\n\n   while (unw_step(&cursor) > 0) {\n      unw_word_t pc;\n      unw_get_reg(&cursor, UNW_REG_IP, &pc);\n      if (pc == 0)\n         break;\n\n      char symbolName[256] = \"?\";\n      unw_word_t offset = 0;\n      unw_get_proc_name(&cursor, symbolName, sizeof(symbolName), &offset);\n\n      unw_proc_info_t pip;\n      pip.unwind_info = 0;\n\n      const char* fname = \"?\";\n      const void* ptr = 0;\n      if (unw_get_proc_info(&cursor, &pip) == 0) {\n         ptr = (const void*)(pip.start_ip + offset);\n\n         #ifdef HAVE_DLADDR\n         Dl_info dlinfo;\n         if (dladdr(ptr, &dlinfo) && dlinfo.dli_fname && *dlinfo.dli_fname)\n            fname = dlinfo.dli_fname;\n         #endif\n      }\n\n      const bool is_signal_frame = unw_is_signal_frame(&cursor) > 0;\n      const char* frame = is_signal_frame ? \"  {signal frame}\" : \"\";\n\n      snprintf(err_buf, sizeof(err_buf), \"%2u: %#14lx  %s  (%s+%#lx)  [%p]%s\\n\", item++, pc, fname, symbolName, offset, ptr, frame);\n      full_write_str(STDERR_FILENO, err_buf);\n   }\n#elif defined(HAVE_EXECINFO_H)\n   void* backtraceArray[256];\n\n   int nptrs = backtrace(backtraceArray, ARRAYSIZE(backtraceArray));\n   if (nptrs > 0) {\n      backtrace_symbols_fd(backtraceArray, nptrs, STDERR_FILENO);\n   } else {\n      full_write_str(STDERR_FILENO,\n         \"[No backtrace information available from libc]\\n\"\n      );\n   }\n#else\n#error No implementation for print_backtrace()!\n#endif\n}\n#endif\n\nvoid CRT_handleSIGSEGV(int signal) {\n   CRT_done();\n\n   char err_buf[512];\n\n   snprintf(err_buf, sizeof(err_buf), \"\\n\\n\"\n      \"FATAL PROGRAM ERROR DETECTED\\n\"\n      \"============================\\n\"\n      \"Please check at https://htop.dev/issues whether this issue has already been reported.\\n\"\n      \"If no similar issue has been reported before, please create a new issue with the following information:\\n\"\n      \"  - Your %s version: '\"VERSION\"'\\n\"\n      \"  - Your OS and kernel version (uname -a)\\n\"\n      \"  - Your distribution and release (lsb_release -a)\\n\"\n      \"  - Likely steps to reproduce (How did it happen?)\\n\",\n      program\n   );\n   full_write_str(STDERR_FILENO, err_buf);\n\n#ifdef PRINT_BACKTRACE\n   full_write_str(STDERR_FILENO, \"  - Backtrace of the issue (see below)\\n\");\n#endif\n\n   full_write_str(STDERR_FILENO,\n      \"\\n\"\n   );\n\n   const char* signal_str = strsignal(signal);\n   if (!signal_str) {\n      signal_str = \"unknown reason\";\n   }\n   snprintf(err_buf, sizeof(err_buf),\n      \"Error information:\\n\"\n      \"------------------\\n\"\n      \"A signal %d (%s) was received.\\n\"\n      \"\\n\",\n      signal, signal_str\n   );\n   full_write_str(STDERR_FILENO, err_buf);\n\n   full_write_str(STDERR_FILENO,\n      \"Setting information:\\n\"\n      \"--------------------\\n\");\n   Settings_write(CRT_settings, true);\n   full_write_str(STDERR_FILENO, \"\\n\\n\");\n\n#ifdef PRINT_BACKTRACE\n   full_write_str(STDERR_FILENO,\n      \"Backtrace information:\\n\"\n      \"----------------------\\n\"\n   );\n\n   print_backtrace();\n\n   snprintf(err_buf, sizeof(err_buf),\n      \"\\n\"\n      \"To make the above information more practical to work with, \"\n      \"please also provide a disassembly of your %s binary. \"\n      \"This can usually be done by running the following command:\\n\"\n      \"\\n\",\n      program\n   );\n   full_write_str(STDERR_FILENO, err_buf);\n\n#ifdef HTOP_DARWIN\n   snprintf(err_buf, sizeof(err_buf), \"   otool -tvV `which %s` > ~/%s.otool\\n\", program, program);\n#else\n   snprintf(err_buf, sizeof(err_buf), \"   objdump -d -S -w `which %s` > ~/%s.objdump\\n\", program, program);\n#endif\n   full_write_str(STDERR_FILENO, err_buf);\n\n   full_write_str(STDERR_FILENO,\n      \"\\n\"\n      \"Please include the generated file in your report.\\n\"\n   );\n#endif\n\n   snprintf(err_buf, sizeof(err_buf),\n      \"Running this program with debug symbols or inside a debugger may provide further insights.\\n\"\n      \"\\n\"\n      \"Thank you for helping to improve %s!\\n\"\n      \"\\n\",\n      program\n   );\n   full_write_str(STDERR_FILENO, err_buf);\n\n   /* Call old sigsegv handler; may be default exit or third party one (e.g. ASAN) */\n   if (sigaction(signal, &old_sig_handler[signal], NULL) < 0) {\n      /* This avoids an infinite loop in case the handler could not be reset. */\n      full_write_str(STDERR_FILENO,\n         \"!!! Chained handler could not be restored. Forcing exit.\\n\"\n      );\n      _exit(1);\n   }\n\n   /* Trigger the previous signal handler. */\n   raise(signal);\n\n   // Always terminate, even if installed handler returns\n   full_write_str(STDERR_FILENO,\n      \"!!! Chained handler did not exit. Forcing exit.\\n\"\n   );\n   _exit(1);\n}\n"
        },
        {
          "name": "CRT.h",
          "type": "blob",
          "size": 4.169921875,
          "content": "#ifndef HEADER_CRT\n#define HEADER_CRT\n/*\nhtop - CRT.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Macros.h\"\n#include \"ProvideCurses.h\"\n#include \"Settings.h\"\n\n\ntypedef enum TreeStr_ {\n   TREE_STR_VERT,\n   TREE_STR_RTEE,\n   TREE_STR_BEND,\n   TREE_STR_TEND,\n   TREE_STR_OPEN,\n   TREE_STR_SHUT,\n   TREE_STR_ASC,\n   TREE_STR_DESC,\n   LAST_TREE_STR\n} TreeStr;\n\ntypedef enum ColorScheme_ {\n   COLORSCHEME_DEFAULT,\n   COLORSCHEME_MONOCHROME,\n   COLORSCHEME_BLACKONWHITE,\n   COLORSCHEME_LIGHTTERMINAL,\n   COLORSCHEME_MIDNIGHT,\n   COLORSCHEME_BLACKNIGHT,\n   COLORSCHEME_BROKENGRAY,\n   LAST_COLORSCHEME\n} ColorScheme;\n\ntypedef enum ColorElements_ {\n   RESET_COLOR,\n   DEFAULT_COLOR,\n   FUNCTION_BAR,\n   FUNCTION_KEY,\n   FAILED_SEARCH,\n   FAILED_READ,\n   PAUSED,\n   PANEL_HEADER_FOCUS,\n   PANEL_HEADER_UNFOCUS,\n   PANEL_SELECTION_FOCUS,\n   PANEL_SELECTION_FOLLOW,\n   PANEL_SELECTION_UNFOCUS,\n   LARGE_NUMBER,\n   METER_SHADOW,\n   METER_TEXT,\n   METER_VALUE,\n   METER_VALUE_ERROR,\n   METER_VALUE_IOREAD,\n   METER_VALUE_IOWRITE,\n   METER_VALUE_NOTICE,\n   METER_VALUE_OK,\n   METER_VALUE_WARN,\n   LED_COLOR,\n   UPTIME,\n   BATTERY,\n   TASKS_RUNNING,\n   SWAP,\n   SWAP_CACHE,\n   SWAP_FRONTSWAP,\n   PROCESS,\n   PROCESS_SHADOW,\n   PROCESS_TAG,\n   PROCESS_MEGABYTES,\n   PROCESS_GIGABYTES,\n   PROCESS_TREE,\n   PROCESS_RUN_STATE,\n   PROCESS_D_STATE,\n   PROCESS_BASENAME,\n   PROCESS_HIGH_PRIORITY,\n   PROCESS_LOW_PRIORITY,\n   PROCESS_NEW,\n   PROCESS_TOMB,\n   PROCESS_THREAD,\n   PROCESS_THREAD_BASENAME,\n   PROCESS_COMM,\n   PROCESS_THREAD_COMM,\n   PROCESS_PRIV,\n   BAR_BORDER,\n   BAR_SHADOW,\n   GRAPH_1,\n   GRAPH_2,\n   MEMORY_USED,\n   MEMORY_BUFFERS,\n   MEMORY_BUFFERS_TEXT,\n   MEMORY_CACHE,\n   MEMORY_SHARED,\n   MEMORY_COMPRESSED,\n   HUGEPAGE_1,\n   HUGEPAGE_2,\n   HUGEPAGE_3,\n   HUGEPAGE_4,\n   LOAD,\n   LOAD_AVERAGE_FIFTEEN,\n   LOAD_AVERAGE_FIVE,\n   LOAD_AVERAGE_ONE,\n   CHECK_BOX,\n   CHECK_MARK,\n   CHECK_TEXT,\n   CLOCK,\n   DATE,\n   DATETIME,\n   HELP_BOLD,\n   HELP_SHADOW,\n   HOSTNAME,\n   CPU_NICE,\n   CPU_NICE_TEXT,\n   CPU_NORMAL,\n   CPU_SYSTEM,\n   CPU_IOWAIT,\n   CPU_IRQ,\n   CPU_SOFTIRQ,\n   CPU_STEAL,\n   CPU_GUEST,\n   GPU_ENGINE_1,\n   GPU_ENGINE_2,\n   GPU_ENGINE_3,\n   GPU_ENGINE_4,\n   GPU_RESIDUE,\n   PANEL_EDIT,\n   SCREENS_OTH_BORDER,\n   SCREENS_OTH_TEXT,\n   SCREENS_CUR_BORDER,\n   SCREENS_CUR_TEXT,\n   PRESSURE_STALL_TEN,\n   PRESSURE_STALL_SIXTY,\n   PRESSURE_STALL_THREEHUNDRED,\n   FILE_DESCRIPTOR_USED,\n   FILE_DESCRIPTOR_MAX,\n   ZFS_MFU,\n   ZFS_MRU,\n   ZFS_ANON,\n   ZFS_HEADER,\n   ZFS_OTHER,\n   ZFS_COMPRESSED,\n   ZFS_RATIO,\n   ZRAM_COMPRESSED,\n   ZRAM_UNCOMPRESSED,\n   DYNAMIC_GRAY,\n   DYNAMIC_DARKGRAY,\n   DYNAMIC_RED,\n   DYNAMIC_GREEN,\n   DYNAMIC_BLUE,\n   DYNAMIC_CYAN,\n   DYNAMIC_MAGENTA,\n   DYNAMIC_YELLOW,\n   DYNAMIC_WHITE,\n   LAST_COLORELEMENT\n} ColorElements;\n\nvoid CRT_fatalError(const char* note) ATTR_NORETURN;\n\n#ifdef NDEBUG\n# define CRT_debug(...)\n#else\nvoid CRT_debug_impl(const char* file, size_t lineno, const char* func, const char* fmt, ...) ATTR_FORMAT(printf, 4, 5);\n# define CRT_debug(...) CRT_debug_impl(__FILE__, __LINE__, __func__, __VA_ARGS__)\n#endif\n\nvoid CRT_handleSIGSEGV(int signal) ATTR_NORETURN;\n\n#define KEY_WHEELUP   KEY_F(30)\n#define KEY_WHEELDOWN KEY_F(31)\n#define KEY_RECLICK   KEY_F(32)\n#define KEY_SHIFT_TAB KEY_F(33)\n#define KEY_ALT(x)    (KEY_F(64 - 26) + ((x) - 'A'))\n#define KEY_FOCUS_IN  (KEY_MAX + 'I')\n#define KEY_FOCUS_OUT (KEY_MAX + 'O')\n\nextern const char* CRT_degreeSign;\n\n#ifdef HAVE_LIBNCURSESW\n\nextern bool CRT_utf8;\n\n#endif\n\nextern const char* const* CRT_treeStr;\n\nextern const int* CRT_colors;\n\nextern int CRT_cursorX;\n\nextern int CRT_scrollHAmount;\n\nextern int CRT_scrollWheelVAmount;\n\nextern ColorScheme CRT_colorScheme;\n\n#ifdef HAVE_GETMOUSE\nvoid CRT_setMouse(bool enabled);\n#else\n#define CRT_setMouse(enabled)\n#endif\n\nvoid CRT_init(const Settings* settings, bool allowUnicode, bool retainScreenOnExit);\n\nvoid CRT_done(void);\n\nvoid CRT_resetSignalHandlers(void);\n\nint CRT_readKey(void);\n\nvoid CRT_disableDelay(void);\n\nvoid CRT_enableDelay(void);\n\nstatic inline void CRT_updateDelay(void) {\n   CRT_enableDelay(); // pushes new delay setting into halfdelay(3X)\n}\n\nvoid CRT_setColors(int colorScheme);\n\n#endif\n"
        },
        {
          "name": "CategoriesPanel.c",
          "type": "blob",
          "size": 6.2890625,
          "content": "/*\nhtop - CategoriesPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"CategoriesPanel.h\"\n\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"AvailableMetersPanel.h\"\n#include \"ColorsPanel.h\"\n#include \"DisplayOptionsPanel.h\"\n#include \"FunctionBar.h\"\n#include \"Header.h\"\n#include \"HeaderLayout.h\"\n#include \"HeaderOptionsPanel.h\"\n#include \"ListItem.h\"\n#include \"Macros.h\"\n#include \"MetersPanel.h\"\n#include \"Object.h\"\n#include \"ProvideCurses.h\"\n#include \"ScreensPanel.h\"\n#include \"ScreenTabsPanel.h\"\n#include \"Settings.h\"\n#include \"Vector.h\"\n#include \"XUtils.h\"\n\n\nstatic const char* const CategoriesFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nstatic void CategoriesPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   CategoriesPanel* this = (CategoriesPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic void CategoriesPanel_makeMetersPage(CategoriesPanel* this) {\n   size_t columns = HeaderLayout_getColumns(this->scr->header->headerLayout);\n   MetersPanel** meterPanels = xMallocArray(columns, sizeof(MetersPanel*));\n   Settings* settings = this->host->settings;\n\n   for (size_t i = 0; i < columns; i++) {\n      char titleBuffer[32];\n      xSnprintf(titleBuffer, sizeof(titleBuffer), \"Column %zu\", i + 1);\n      meterPanels[i] = MetersPanel_new(settings, titleBuffer, this->header->columns[i], this->scr);\n\n      if (i != 0) {\n         meterPanels[i]->leftNeighbor = meterPanels[i - 1];\n         meterPanels[i - 1]->rightNeighbor = meterPanels[i];\n      }\n\n      ScreenManager_add(this->scr, (Panel*) meterPanels[i], 20);\n   }\n\n   Panel* availableMeters = (Panel*) AvailableMetersPanel_new(this->host, this->header, columns, meterPanels, this->scr);\n   ScreenManager_add(this->scr, availableMeters, -1);\n}\n\nstatic void CategoriesPanel_makeDisplayOptionsPage(CategoriesPanel* this) {\n   Settings* settings = this->host->settings;\n   Panel* displayOptions = (Panel*) DisplayOptionsPanel_new(settings, this->scr);\n   ScreenManager_add(this->scr, displayOptions, -1);\n}\n\nstatic void CategoriesPanel_makeColorsPage(CategoriesPanel* this) {\n   Settings* settings = this->host->settings;\n   Panel* colors = (Panel*) ColorsPanel_new(settings);\n   ScreenManager_add(this->scr, colors, -1);\n}\n\n#if defined(HTOP_PCP)   /* all platforms supporting dynamic screens */\nstatic void CategoriesPanel_makeScreenTabsPage(CategoriesPanel* this) {\n   Settings* settings = this->host->settings;\n   Panel* screenTabs = (Panel*) ScreenTabsPanel_new(settings);\n   Panel* screenNames = (Panel*) ((ScreenTabsPanel*)screenTabs)->names;\n   ScreenManager_add(this->scr, screenTabs, 20);\n   ScreenManager_add(this->scr, screenNames, -1);\n}\n#endif\n\nstatic void CategoriesPanel_makeScreensPage(CategoriesPanel* this) {\n   Settings* settings = this->host->settings;\n   Panel* screens = (Panel*) ScreensPanel_new(settings);\n   Panel* columns = (Panel*) ((ScreensPanel*)screens)->columns;\n   Panel* availableColumns = (Panel*) ((ScreensPanel*)screens)->availableColumns;\n   ScreenManager_add(this->scr, screens, 20);\n   ScreenManager_add(this->scr, columns, 20);\n   ScreenManager_add(this->scr, availableColumns, -1);\n}\n\nstatic void CategoriesPanel_makeHeaderOptionsPage(CategoriesPanel* this) {\n   Settings* settings = this->host->settings;\n   Panel* colors = (Panel*) HeaderOptionsPanel_new(settings, this->scr);\n   ScreenManager_add(this->scr, colors, -1);\n}\n\ntypedef void (* CategoriesPanel_makePageFunc)(CategoriesPanel* ref);\ntypedef struct CategoriesPanelPage_ {\n   const char* name;\n   CategoriesPanel_makePageFunc ctor;\n} CategoriesPanelPage;\n\nstatic CategoriesPanelPage categoriesPanelPages[] = {\n   { .name = \"Display options\", .ctor = CategoriesPanel_makeDisplayOptionsPage },\n   { .name = \"Header layout\", .ctor = CategoriesPanel_makeHeaderOptionsPage },\n   { .name = \"Meters\", .ctor = CategoriesPanel_makeMetersPage },\n#if defined(HTOP_PCP)   /* all platforms supporting dynamic screens */\n   { .name = \"Screen tabs\", .ctor = CategoriesPanel_makeScreenTabsPage },\n#endif\n   { .name = \"Screens\", .ctor = CategoriesPanel_makeScreensPage },\n   { .name = \"Colors\", .ctor = CategoriesPanel_makeColorsPage },\n};\n\nstatic HandlerResult CategoriesPanel_eventHandler(Panel* super, int ch) {\n   CategoriesPanel* this = (CategoriesPanel*) super;\n\n   HandlerResult result = IGNORED;\n\n   int selected = Panel_getSelectedIndex(super);\n   switch (ch) {\n      case EVENT_SET_SELECTED:\n         result = HANDLED;\n         break;\n      case KEY_UP:\n      case KEY_CTRL('P'):\n      case KEY_DOWN:\n      case KEY_CTRL('N'):\n      case KEY_NPAGE:\n      case KEY_PPAGE:\n      case KEY_HOME:\n      case KEY_END: {\n         int previous = selected;\n         Panel_onKey(super, ch);\n         selected = Panel_getSelectedIndex(super);\n         if (previous != selected)\n            result = HANDLED;\n         break;\n      }\n      default:\n         if (0 < ch && ch < 255 && isgraph((unsigned char)ch))\n            result = Panel_selectByTyping(super, ch);\n         if (result == BREAK_LOOP)\n            result = IGNORED;\n         break;\n   }\n   if (result == HANDLED) {\n      int size = ScreenManager_size(this->scr);\n      for (int i = 1; i < size; i++)\n         ScreenManager_remove(this->scr, 1);\n\n      if (selected >= 0 && (size_t)selected < ARRAYSIZE(categoriesPanelPages)) {\n         categoriesPanelPages[selected].ctor(this);\n      }\n   }\n   return result;\n}\n\nconst PanelClass CategoriesPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = CategoriesPanel_delete\n   },\n   .eventHandler = CategoriesPanel_eventHandler\n};\n\nCategoriesPanel* CategoriesPanel_new(ScreenManager* scr, Header* header, Machine* host) {\n   CategoriesPanel* this = AllocThis(CategoriesPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(CategoriesFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   this->scr = scr;\n   this->host = host;\n   this->header = header;\n   Panel_setHeader(super, \"Categories\");\n   for (size_t i = 0; i < ARRAYSIZE(categoriesPanelPages); i++)\n      Panel_add(super, (Object*) ListItem_new(categoriesPanelPages[i].name, 0));\n\n   ScreenManager_add(scr, super, 16);\n   categoriesPanelPages[0].ctor(this);\n   return this;\n}\n"
        },
        {
          "name": "CategoriesPanel.h",
          "type": "blob",
          "size": 0.5751953125,
          "content": "#ifndef HEADER_CategoriesPanel\n#define HEADER_CategoriesPanel\n/*\nhtop - CategoriesPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Header.h\"\n#include \"Machine.h\"\n#include \"Panel.h\"\n#include \"ScreenManager.h\"\n\n\ntypedef struct CategoriesPanel_ {\n   Panel super;\n   ScreenManager* scr;\n   Machine* host;\n   Header* header;\n} CategoriesPanel;\n\nextern const PanelClass CategoriesPanel_class;\n\nCategoriesPanel* CategoriesPanel_new(ScreenManager* scr, Header* header, Machine* host);\n\n#endif\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 46.0361328125,
          "content": "What's new in version 3.3.0\n\n* Multiple refactorings and code improvements\n* Shorten docker container IDs to 12 characters\n* Settings: preserve empty header\n* Fix execlp() argument without pointer cast\n* OpenFilesScreen: Make column sizing dynamic for file size, offset and inode\n* Add support for \"truss\" (FreeBSD equivalent of \"strace\")\n* Darwin: add NetworkIOMeter support\n* HeaderLayout: add \"3 columns - 40/30/30\", \"... 30/40/30\" & \"... 30/30/40\"\n* Meter: use correct unicode characters for digit '9'\n* Note in manual re default memory units of KiB\n* Add column for process container name\n* Add logic to filter the container name (+type) from the CGroup name\n* Change NetworkIOMeter value unit from KiB/s to bytes/second\n* Cap DiskIOMeter \"utilisation\" percentage at 100%\n* PCP platform implementation of frontswap and zswap accounting\n* Shorten podman/libpod container IDs to 12 characters\n* Write configuration to temporary file first\n* Incorporate shared memory in bar text\n* Move shared memory next to used memory\n* Correct order of memory meter in help\n* Add recalculate to Ctrl-L refresh\n* Update process list on thread visibility toggling\n* Support dynamic screens with 'top-most' entities beyond processes\n* Introduce Row and Table classes for screens beyond top-processes\n* Rework ZramMeter and remove MeterClass.comprisedValues\n* More robust logic for CPU process percentages (Linux & PCP)\n* Show year as start time for processes older than a year\n* Short-term fix for docker container detection\n* default color preset: use bold blue for better visibility\n* Document 'O' keyboard shortcut\n* Implement logic for '--max-iterations'\n* Update F5 key label on tab switch (Tree <-> List)\n* Force re-sorting of the process list view after switching between list/treeview mode\n* Linux: (hack) work around the fact that Zswapped pages may be SwapCached\n* Linux: implement zswap support\n* {Memory,Swap}Meter: add \"compressed memory\" metrics\n* Darwin: add DiskIOMeter support\n* Fix scroll relative to followed process\n* ZramMeter: update bar mode\n* Use shared real memory on FreeBSD\n* Increase Search and Filter max string length to 128\n* Improve CPU computation code\n* Remove LXC special handling for the CPU count\n* Create new File Descriptor meter\n* PCP: add IRQ PSI meter\n* Linux: add IRQ PSI meter\n* Linux: highlight username if process has elevated privileges\n* Add support for scheduling policies\n* Add a systemd user meter to monitor user units.\n* FreeBSD: remove duplicate zfs ARC size subtraction\n\nWhat's new in version 3.2.2\n\n* CPUMeter now can show frequency in text mode\n* Add option to render distribution path prefixes shadowed\n* DiskIOMeter converts to bytes per second (not per interval)\n* DiskIOMeter uses complete units, including missing \"iB/s\"\n* DiskIOMeter indicates read and write in meter mode\n* NetworkIOMeter converts to packets per second, shows packet rate\n* Allow continued process following when changing display settings\n* Update the panel header when changing to another tab\n* Drop margin around the header if there are no meters\n* Use Unicode replacement character for non-printable characters\n* Default color preset uses bold blue for better visibility\n* Update the Panel header on sort order inversions ('I')\n* Toggle the header meters with pound key\n* Fix ScreenPanel to handle quitting the panel while renaming\n* Add fallback for HOME environment variable using passwd database\n* Replace meaningless ID column with FD column in lock screen\n* Use device format in the lock screen matching the files screen\n* On Linux, improvements to file-descriptor lock detection\n* On Linux, further distinguish systemd states in the SystemdMeter\n* On Linux, improvements to cgroup and container identification\n* On Linux, support openat(2) without readlinkat(2) platforms\n* On Darwin, fix current process buffer handling for busy systems\n* On DragonFly BSD, fix incorrect processor time of processes\n* On FreeBSD, fix an issue with the memory graph not showing correctly\n* On FreeBSD, add support for displaying shared memory usage\n* On PCP, use pmLookupDescs(3) if available for efficiency\n* On PCP, normalize generic columns values for consistent display\n* On PCP, changes preparing for configurable, dynamic screens\n* Handle invalid process columns from the configuration file\n* Avoid undefined behaviour with deeply nested processes\n* Fix crash when removing the currently active screen\n* Prevent possible crash on a very early error path\n* Include automake for Debian/Ubuntu\n* Restore non-mouse support\n* Reject unsupported command line arguments\n* Document idle process state\n* Clarify M_TRS/M_DRS columns\n\nWhat's new in version 3.2.1\n\n* Fix setting to show all branches collapsed by default\n* Restore functionality of stripExeFromCmdline setting\n* Fix some command line display settings not being honored without restart\n* Display single digit precision for CPU% greater than 99.9%\n* On Linux, FreeBSD and PCP consider only shrinkable ZFS ARC as cache\n* On Linux, increase field width of CPUD% and SWAPD% columns\n* Colorize process state characters in help screen\n* Use mousemask(3X) to enable and disable mouse control\n* Fix heap buffer overflow in Vector_compact\n* On Solaris, fix a process time scaling error\n* On Solaris, fix the build\n* On NetBSD, OpenBSD and Solaris ensure env buffer size is sufficient\n* On Linux, resolve processes exiting interfering with sampling\n* Fix ProcessTable quadratic removal when scanning processes\n* Under LXC, limit CPU count to that given by /proc/cpuinfo\n* Improve container detection for LXC\n* Some minor documentation fixes\n\nWhat's new in version 3.2.0\n\n* Support for displaying multiple tabs in the user interface\n* Allow multiple filter and search terms (logical OR, separate by \"|\")\n* Set correct default sorting direction (defaultSortDesc)\n* Improve performance for process lookup and update\n* Rework the IOMeters initial display\n* Removed duplicate sections on COMM and EXE\n* Highlight process UNINTERRUPTIBLE_WAIT state (D)\n* Show only integer value when CPU% more than 99.9%\n* Handle rounding ambiguity between 99.9 and 100.0%\n* No longer leaves empty the last column in header\n* Fix header layout and meters reset if a header column is empty\n* Fix PID and UID column widths off-by-one error\n* On Linux, read generic sysfs batteries\n* On Linux, do not collect LRS per thread (it is process-wide)\n* On Linux, dynamically adjust the SECATTR and CGROUP column widths\n* On Linux, fix a crash in LXD\n* On FreeBSD, add support for showing process emulation\n* On Darwin, lazily set process TTY name\n* Always set SIGCHLD to default handling\n* Avoid zombie processes on signal races\n* Ensure last line is cleared when SIGINT is received\n* Instead of SIGTERM, pre-select the last sent signal\n* Internal Hashtable performance and sizing improvements\n* Add heuristics for guessing LXC or Docker from /proc/1/mounts\n* Force elapsed time display to zero if process started in the future\n* Avoid extremely large year values when printing time\n* Fix division by zero when calculating IO rates\n* Fix out of boundary writes in XUtils\n* Fix custom thread name display issue\n* Use AC_CANONICAL_HOST, not AC_CANONICAL_TARGET in configure.ac\n* Support libunwind of LLVM\n\nWhat's new in version 3.1.2\n\n* Bugfix for crash when storing modified settings at exit\n* Generate xz-compressed source tarball (with configure) using github actions\n* Allow -u UID with numerical value as argument\n* Added documentation for obsolete/state libraries/program files highlighting\n* Some obsolete/stale library highlighting refinements\n* Column width issues resolved\n* Dynamic UID column sizing improved\n* Discard stale information from Disk and Network I/O meters\n* Refined Linux kernel thread detection\n* Reworked process state handling\n* New CCGROUP column showing abbreviated cgroup name\n* New OFFSET column in the list of open files screen\n\nWhat's new in version 3.1.1\n\n* Update license headers to explicitly say GPLv2+\n* Document minimum version for libcap (thanks to James Brown)\n* Fix mouse wheel collision with autogroups nice adjustment\n* Adjust Makefile.am macro definitions for older automake versions\n* Ensure consistent reporting of MemoryMeter 'used' memory\n* Report hugepage memory as real and used memory (as before)\n* Handle procExeDeleted, usesDeletedLib without mergedCommandline mode\n* Validate meter configuration before proceeding beyond htoprc parsing\n* Properly release memory on partially read configuration\n* Handle interrupted sampling from within libpcp PDU transfers\n* On Linux, provide O_PATH value if not defined\n* On Linux, always compute procExeDeleted if already set\n* Workaround for Rosetta 2 on Darwin (thanks to Alexander Momchilov)\n* Fix FreeBSD cmdline memory leak in Process_updateCmdline, and\n* Plug a Disk I/O meter memory leak on FreeBSD (thanks to Ximalas)\n\nWhat's new in version 3.1.0\n\n* Updated COPYING file to remove the PLPA exemption (appendix 2)\n  With this change the license is now GPLv2 without any additional wording.\n* Improved default sort ordering\n  Note for users: This may lead to an inverted sort order on startup of\n  htop 3.1.0 compared to previous versions.\n  This is due to what is stored in your htoprc file. Solution: Press I\n  (to invert sort order).\n  This changed setting will be saved by htop on exit as long as it can\n  write to your htoprc file.\n* The compile-time option to cater specifically for running htop as\n  setuid has been removed\n* Add read-only option\n  This allows htop to be run in an non-intrusive fashion where it acts only\n  as a process viewer disabling all functions to manipulate system state.\n  Note: This is not a security feature!\n* Move the code for handling the command line formatting related tasks\n  to be shared across all platforms\n  This means important features like stale binary/library highlighting\n  can now be available on all supported platforms.\n* Make the EXE and COMM columns available on all platforms\n  All supported platforms have the name of the executable (EXE) and a\n  self-chosen thread/command name (COMM) available one way or the other.\n  Moving this column to be handled as a platform-independently available\n  information simplifies the markup of the command line.\n* Introduce configuration file versioning and config_reader_min_version\n  Starting with this version the configuration file contains a version\n  identifying the minimum version of the configuration parser needed to\n  fully understand the configuration file format.\n  Old configuration file formats are automatically upgraded when\n  saving the config file (htoprc).\n* Make the configuration parser friendlier to users (thanks to Bart Bakker)\n  With this change only settings that cannot be parsed properly are\n  reset to their defaults.\n* Improve default display for systems with many CPUs\n* Add the process ELAPSED time column\n* Improve the process STATE column sorting\n* Reworked handling resize and redrawing of the UI\n* Fixed an issue where the LED meter mode could overflow allotted space\n* Allow text mode Meters to span empty neighbors to the right\n* Rescale graph meters when value of total changes\n  (thanks to Michael SchÃ¶nitzer)\n* Update generic process field display\n  Usually \"uninteresting\" values in columns like 1 thread, nice value\n  of 0, CPU and memory of 0%, idle/sleeping state, etc. are shown with\n  reduced intensity (dark grey)\n* Option and key (\"*\") to collapse / expand all branches under PID 1\n  (and PID 2 if kernel threads are shown) (thanks to Krishna Chaitanya)\n* Keep following a process when inverting the sort order, displaying\n  the help screen or hiding/unhiding userland threads.\n  If a thread is currently selected the selection is updated to point\n  to the thread's parent process. (thanks to Gonzalo, et.al.)\n* Reorder process scanning to be performed before updating the display\n  of the meters in the header\n* Always check the user for a process for any changes.\n  This affects multiple platforms that previously didn't correctly handle\n  the user field for a process to change at runtime (e.g. due to seteuid\n  or similar syscalls).\n* Disable mouse option when support is unavailable\n* Support curses libraries without ncurses mouse support\n  (thanks to Santhosh Raju)\n* Support offline and hot-swapping of CPUs on all platforms\n* Fix the CPU Meter for machines with more than 256 CPUs\n* Supplemented the \"show updated/deleted executables\" feature (red basename)\n  to indicate when linked libraries were updated (yellow basename)\n* Apply the stale binary highlighting for the EXE column in addition to\n  the command line field\n* Add new combined Memory and Swap meter\n* Implement bar and graph mode for NetworkIO Meter\n  (thanks to Michael F. SchÃ¶nitzer)\n* Rework TTY column to be more consistent across platforms\n* Make the CWD column generally available on all platforms\n  (thanks to Santhosh Raju et. al.)\n* Add Performance Co-Pilot (PCP) platform support\n  This is added via a separate pcp-htop(1) binary which provides remote host\n  analysis, new Meters for any PCP metric and new Columns for any PCP process\n  metric - see the pcp-htop(5) man page for further details.\n  (thanks to Sohaib Mohamed)\n* Add Linux columns and key bindings for process autogroup identifier\n  and nice value\n* Change available and used memory reporting on Linux to be based on\n  MemAvailable (Kernel 3.14+) (thanks to Chris Cheney and Tomas Wido)\n* Add a new SysArchMeter showing kernel and platform information\n  (thanks to ahgamut)\n* Linux memory usage explicitly treats tmpfs memory usage as shared memory\n  This is to make memory used by tmpfs visible as this cannot be freed\n  unlike normal filesystem cache data.\n* Exclude zram devices when calculating DiskIO on Linux\n* Use PATH lookup for systemctl in systemd meter (thanks to Scott Olson)\n* Add native platform support for NetBSD\n  This allows htop to run on NetBSD without the need for active Linux\n  emulation of the procfs filesystem.\n  (thanks to Santhosh Raju and Nia Alarie)\n* Add NetworkIO, DiskIO, CPU frequency, and battery meter support on NetBSD\n  (thanks to Nia Alarie)\n* Fix NetBSD display of in-use and cached memory (thanks to Nia Alarie)\n* Rework NetBSD CPU and memory accounting (thanks to Santhosh Raju)\n* Fix NetBSD accounting of user and kernel threads (thanks to Santhosh Raju)\n* Initial work to allow building with default libcurses on NetBSD\n  (thanks to Santhosh Raju)\n* FreeBSD updates - implement process majflt and processor column values\n* Add FreeBSD support for CPU frequency and temperature\n* Fixes and cleanups for ZFS Meters and metrics\n* Correctly color the ZFS ARC ratio (thanks to Ross Williams)\n* Bugfixes related to CPU time display/calculations for darwin on M1 systems\n  (thanks to Alexander Momchilov)\n* Harmonize the handling of multiple batteries across different platforms.\n  The system is now considered to run on AC if at least one power supply\n  marked as AC is found in the system.\n  Battery capacity is summed up over all batteries found.\n  This also changes the old behavior that batteries reported by the\n  system after the first AC adapter where sometimes ignored.\n* Correctly handle multiple batteries on Darwin.\n  Resolves a possible memory leak on systems with multiple batteries.\n* Handle Linux Shmem being part of Cached in the MemoryMeter\n* Add SwapCached to the Linux swap meter (thanks to David Zarzycki)\n* Convert process time to days if applicable (thanks to David Zarzycki)\n* Always show the number of threads in the TaskMeter, even when threads\n  are not shown in the process list\n* Fix Linux --drop-capabilities option handling\n* Correctly detect failure to initialize Linux boottime\n* Overhaul the Linux memory fields to partition them like free(1) now does\n* Improve the Linux process I/O column values\n* Rework the libsensors parsing on Linux\n* Update the MemoryMeter to display shared memory\n* Update OpenBSD platform - implement additional columns, scan LWP,\n  proper markup for STATE, show CPU frequency\n* Fix the tree view on OpenBSD when hiding kernel threads\n* Remove old InfoScreen lines before re-scanning (thanks to Ãystein HiÃ¥sen)\n* Document historic naming of Light-Weight Processes column aka threads\n* Improve user interaction when the last process entry is selected\n* Draw the panel header on the TraceScreen (thanks to Youngjae Lee)\n* Add mouse wheel scroll and fix mouse selection on the InfoScreen\n  (thanks to Youngjae Lee)\n* Add a HugepageMeter and subtract hugepages from normal memory\n* Display wide characters in LED meters and restore non-wide ncurses support\n* Add command line option to drop Linux capabilities\n* Support scheduler affinity on platforms beyond Linux\n* Report on any failure to write the configuration file\n* Cache stderr to be able to print assert messages.\n  These messages are shown in case htop terminates unexpectedly.\n* Print current settings on crash\n* Reset signal handlers on program exit\n* Add configure script option to create a static htop binary\n* Resolved longer-standing compilation issues on Solaris/Illumos\n* Check for availability of set_escdelay in configure\n  (thanks to Stefan Polluks)\n* Build system updates for autotools 2.70\n\nWhat's new in version 3.0.5\n\n* BUGFIX / SECURITY: InfoScreen: fix uncontrolled format string\n* BUGFIX: Improve white text in the Light Terminal colour scheme\n  (both of the above thanks to V)\n* Enable the function bar on the main screen to be hidden (see Setup -> Display options)\n* BUGFIX: Reduce layout issues esp. around printing wide characters (not complete yet)\n* BUGFIX: Make the follow function exit cleanly after followed process died\n* Solaris: make Process callbacks static\n* Update help and man page for improved -t / -s options\n* Drop usage of formatted error messages from <err.h>\n* Show arrow indicating order of sorted process column\n* Lots of plumbing around the internal Hashtable, hardening and code cleanups\n* LibSensors: add support for Ryzen CPUs\n  (thanks to Matej Dian)\n* BUGFIX: Fix CPU percentage on M1 silicon Macs\n  (thanks to Luke Groeninger)\n* LoadMeter: dynamically adjust color and total of bar\n* Find libsensors.so.4 for Fedora and friends\n* Add support to display CPU frequencies on Solarish platforms\n  (thanks to Dominik Hassler)\n* Enable going back to previous search matches (Shift-F3)\n* Added keybind 'N' for sorting by PID (drops 'n'/'N' as not used before much)\n  (thanks to Jake Mannens)\n\nWhat's new in version 3.0.4\n\n* Separate tree and list sort orders\n* Invert Process_compare so that superclass matches run first\n  (thanks to Hisham Muhammad)\n* Unhardcode Mac OS tick-to-milliseconds conversion\n  (thanks to Alexander Momchilov)\n* Check if clock_gettime needs linking of librt\n* Define O_PATH if not already defined\n  (thanks to Chris Burr)\n* Add column on Mac for processes running under translation\n  (thanks to DÃ¡niel Bakai)\n* Configure check for additional linker flags for keypad(3)\n* PSI Meter: constant width and only print ten-duration as bar\n* Sort in paused mode after inverting sort order\n* Handle absence of package CPU temperature\n* Meter: restore non-wide-character build\n* LibSensors: restore temperature for Raspberry Pi\n* MainPanel: do not reset hideProcessSelection on KEY_SHUFFLE\n* BarMeter: rework text padding\n* Panel: rework drawing of FunctionBar\n* Meter: fix artifacts with very tiny width\n* DragonFlyBSD updates\n* BUGFIX: Fix dlopen issue for libsensors5 for some platforms\n* BUGFIX: Fix broken tree display on inverted sort order\n* BUGFIX: Fix pause mode (\"Z\") in tree view\n* BUGFIX: Correct timebase for non-x86 CPUs on Darwin\n* BUGFIX: Avoid NULL dereference on zombie processes\n* Document dynamic bindings and assumed external configuration\n* Update key mapping documentation for sorting\n\nWhat's new in version 3.0.3\n\n* Process sorting in 'tree' mode\n  (thanks to Maxim Zhiburt)\n* Improved command display/sort functionality\n  (thanks to Narendran Gopalakrishnan)\n* Add screen for active file locks\n  (thanks to Fynn J. Wulf)\n* Calculate library size (M_LRS column) from maps file\n  (thanks to Fynn J. Wulf)\n* Add a Zram meter\n  (thanks to Murloc Knight)\n* Add Linux cwd process column\n* Dynamically load libsensors at runtime\n* Improve PressureStall Meter display strings\n* Hide process selection on ESC\n* Fully support non-ascii characters in Meter-Bar\n* Add support to change numeric options in settings screen\n* Rename virtual memory column from M_SIZE to M_VIRT\n* Add process column for normalized CPU usage\n* Show CPU temperature in CPU meter\n* Drop hideThreads Setting\n* Add a systemd meter\n* Add a network IO meter\n* Add a SELinux meter\n* Compress size of default FunctionBar\n* Updates to the OpenFiles screen\n* Continue updating header data in paused mode\n* BUGFIX: Handle data wraparounds in IO meters\n* BUGFIX: Update InfoScreen content on resize\n* Add security attribute process column\n* Add DiskIOMeter for IO read/write usage\n* Read CPU frequency from sysfs by default\n* Add Linux process column for context switches\n* Several FreeBSD and Mac OS X platform updates\n  (thanks to Christian GÃ¶ttsche)\n* Add process environment for FreeBSD\n  (thanks to Ross Williams)\n* Parse POWER_SUPPLY_CAPACITY for Linux Battery meter\n  (thanks to Jan Palus)\n* Add octuple-column CPU meters.\n* BUGFIX: On Linux consider ZFS ARC to be cache\n  (thanks to @multi)\n* BUGFIX: Limit screen title length to window width\n* Show selected command wrapped in a separate window\n  (thanks to @ryenus)\n* Allow to pass '/' for item search\n* Document implicit incremental search\n* Handle 'q' as quit if first character\n* Avoid expensive build of process tree when not using it\n* Include documentation for COMM and EXE\n* Distinguish display of no permissions for reading M_LRS\n* Only calculate M_LRS size every 2 seconds\n* Improvements to comm / cmdline display functionality\n* Merged view for COMM, EXE and cmdline\n  (thanks to Narendran Gopalakrishnan and Benny Baumann)\n* Consistent kernel thread display for COMM/EXE columns\n* Central fault handling for all platforms\n* Handle parsing envID & VPid from process status file\n* Use threshold for display of guest/steal/irq meters\n* Enhance highlighting of semi-large and large numbers\n* Documentation on the repository style guide\n  (thanks to Benny Baumann)\n* Align processor identifier to the right\n  (thanks to Christian Hesse)\n* Document M_PSS, M_PSSWP, M_SWAP in man page\n* Add Date and DateTime meters\n  (thanks to Michael F. SchÃ¶nitzer)\n* BUGFIX: Fix Solaris 11.4 due to missing ZFS ARC kstats\n  (thanks to @senjan)\n* Code hardening, speedups, fd and memory leak fixes\n  (thanks to Christian GÃ¶ttsche and Benny Baumann)\n* Number CPUs from zero by default\n  (thanks to Zev Weiss)\n* Remove residual python checks during the build process\n  (thanks to Stephen Gregoratto)\n\nWhat's new in version 3.0.2\n\n* BUGFIX: Drop 'vim_mode' - several issues, needs rethink\n* BUGFIX: fix regression in -u optional-argument handling\n* Build system rework to remove python, header generation\n  (thanks to Zev Weiss and Hugo Musso Gualandi)\n* BUGFIX: report nice level correctly on Solaris\n  (thanks to Dominik Hassler)\n* CI, code quality improvements\n  (thanks to Tobias Kortkamp, Christian Hesse, Benny Baumann)\n\nWhat's new in version 3.0.1\n\n* Coverity fixes, CI improvements, documentation updates\n* BUGFIX: Fix early exit with longer sysfs battery paths\n* BUGFIX: Improve OOM output, fix sorting\n  (thanks to Christian GÃ¶ttsche)\n* Rework check buttons and tree open/closed\n  (thanks to Bert Wesarg)\n* Add -U/--no-unicode option to disable unicode\n  (thanks to Christian Hesse)\n* Improvements to the affinity panel\n  (thanks to Bert Wesarg)\n\nWhat's new in version 3.0.0\n\n* New maintainers - after a prolonged period of inactivity\n  from Hisham, the creator and original maintainer, a team\n  of community maintainers have volunteered to take over a\n  fork at https://htop.dev and https://github.com/htop-dev\n  to keep the project going.\n* Support ZFS ARC statistics\n  (thanks to Ross Williams)\n* Support more than 2 smaller CPU meter columns\n  (thanks to Christoph Budziszewski)\n* Support Linux proportional set size metrics\n  (thanks to @linvinus, @ntninja and @himikof)\n* Support Linux pressure stall information metrics\n  (thanks to Ran Benita)\n* New display option to show CPU frequency in CPU meters\n  (thanks to Arnav Singh)\n* Update Linux sysfs battery discovery for recent kernels\n  (thanks to @smattie)\n* Add hardware topology information in the affinity panel\n  (thanks to Bert Wesarg)\n* Add timestamp reporting to the strace screen\n  (thanks to Mario Harjac)\n* Add simple, optional vim key mapping mode\n  (thanks to Daniel Flanagan)\n* Added an option to disable the mouse\n  (thanks to MartinJM)\n* Add Solaris11 compatibility\n  (thanks to Jan Senolt)\n* Without an argument -u uses $USER value automatically\n  (thanks to @solanav)\n* Support less(1) search navigation shortcuts\n  (thanks to @syrrim)\n* Update the FreeBSD maximum PID to match FreeBSD change\n  (thanks to @multiplexd)\n* Report values larger than 100 terabytes\n  (thanks to @adrien1018)\n* Widen ST_UID (UID) column to allow for UIDs > 9999\n  (thanks to DLange)\n* BUGFIX: fix makefiles for building with clang\n  (thanks to Jorge Pereira)\n* BUGFIX: fix <sys/sysmacros.h> major() usage\n  (thanks to @wataash and Kang-Che Sung)\n* BUGFIX: fix the STARTTIME column on FreeBSD\n  (thanks to Rob Crowston)\n* BUGFIX: truncate overwide jail names on FreeBSD\n  (thanks to Rob Crowston)\n* BUGFIX: fix reported memory values on FreeBSD\n  (thanks to Tobias Kortkamp)\n* BUGFIX: fix reported CPU meter values on OpenBSD\n  (thanks to @motet-a)\n* BUGFIX: correctly identify other types of zombie process\n  (thanks to @joder)\n* BUGFIX: improve follow-process handling in some situations\n  (thanks to @wangqr)\n* BUGFIX: fix custom meters reverting to unexpected setting\n  (thanks to @wangqr)\n* BUGFIX: close pipe after running lsof(1)\n  (thanks to Jesin)\n* BUGFIX: meters honour setting of counting CPUs from 0/1\n  (thanks to @rnsanchez)\n\nWhat's new in version 2.2.0\n\n* Solaris/Illumos/OpenIndiana support\n  (thanks to Guy M. Broome)\n* -t/--tree flag for starting in tree-view mode\n  (thanks to Daniel Flanagan)\n* macOS: detects High Sierra version to avoid OS bug\n  (thanks to Pierre Malhaire)\n* OpenBSD: read battery data\n  (thanks to @nerd972)\n* Various automake and build improvements\n  (thanks to Kang-Che Sung)\n* Check for pkg-config when building with --enable-delayacct\n  (thanks to @florian2833z for the report)\n* Avoid some bashisms in configure script\n  (thanks to Jesin)\n* Use CFLAGS from ncurses*-config if present\n  (thanks to Michael Klein)\n* Header generator supports non-UTF-8 environments\n  (thanks to @volkov-am)\n* Linux: changed detection of kernel threads\n* Collapse current subtree pressing Backspace\n* BUGFIX: fix behavior of SYSCR column\n  (thanks to Marc Kleine-Budde)\n* BUGFIX: obtain exit code of lsof correctly\n  (thanks to @wangqr)\n* BUGFIX: fix crash with particular keycodes\n  (thanks to Wellington Torrejais da Silva for the report)\n* BUGFIX: fix issue with small terminals\n  (thanks to Daniel Elf for the report)\n* BUGFIX: fix terminal color issues\n  (thanks to Kang-Che Sung for the report)\n* BUGFIX: preserve LDFLAGS when building\n  (thanks to Lance Frederickson for the report)\n* BUGFIX: fixed overflow for systems with >= 100 signals\n\nWhat's new in version 2.1.0\n\n* Linux: Delay accounting metrics\n  (thanks to AndrÃ© Carvalho)\n* DragonFlyBSD support\n  (thanks to Diederik de Groot)\n* Support for real-time signals\n  (thanks to Kang-Che Sung)\n* 'c' key now works with threads as well\n* Session column renamed from SESN to SID\n  (thanks to Kamyar Rasta)\n* Improved UI for meter style selection\n  (thanks to Kang-Che Sung)\n* Improved code for constructing process tree\n  (thanks to wangqr)\n* Compile-time option to disable setuid\n* Error checking of various standard library operations\n* Replacement of sprintf with snprintf\n  (thanks to Tomasz Kramkowski)\n* Linux: performance improvements in battery meter\n* Linux: update process TTY device\n* Linux: add support for sorting TASK_IDLE\n  (thanks to Vladimir Panteleev)\n* Linux: add upper-bound to running process counter\n  (thanks to Lucas Correia Villa Real)\n* BUGFIX: avoid crash when battery is removed\n  (thanks to Jan Chren)\n* BUGFIX: macOS: fix infinite loop in tree view\n  (thanks to Wataru Ashihara)\n\nWhat's new in version 2.0.2\n\n* Mac OS X: stop trying when task_for_pid fails for a process,\n  stops spamming logs with errors.\n* Add Ctrl+A and Ctrl+E to go to beginning and end of line\n* FreeBSD: fixes for CPU calculation\n  (thanks to Tim Creech, Andy Pilate)\n* Usability: auto-follow process after a search.\n* Use Linux backend on GNU Hurd\n* Improvement for reproducible builds.\n* BUGFIX: Fix behavior of Alt-key combinations\n  (thanks to Kang-Che Sung)\n* Various code tweaks and cleanups\n  (thanks to Kang-Che Sung)\n\nWhat's new in version 2.0.1\n\n* OpenBSD: Various fixes and improvements\n  (thanks to Michael McConville and Juan Francisco Cantero Hurtado)\n* FreeBSD: fix CPU and memory readings\n  (thanks to Tim Creech, Hung-Yi Chen, Bernard Spil, Greg V)\n* FreeBSD: add battery support\n  (thanks to Greg V)\n* Linux: Retain last-obtained name of a zombie process\n* Mac OS X: Improve portability for OS X versions\n  (thanks to Michael Klein)\n* Mac OS X: Fix reading command-line arguments and basename\n* Mac OS X: Fix process state information\n* Mac OS X: Fix tree view collapsing/expanding\n* Mac OS X: Fix tree organization\n* Mac OS X: Fix memory accounting\n* Fix crash when emptying a column of meters\n* Make Esc key more responsive\n\nWhat's new in version 2.0.0\n\n* Platform abstraction layer\n* Initial FreeBSD support\n* Initial Mac OS X support\n  (thanks to David Hunt)\n* Swap meter for Mac OSX\n  (thanks to Ètefan Rusu)\n* OpenBSD port\n  (thanks to Michael McConville)\n* FreeBSD support improvements\n  (thanks to Martin Misuth)\n* Support for NCurses 6 ABI, including mouse wheel support\n* Much improved mouse responsiveness\n* Process environment variables screen\n  (thanks to Michael Klein)\n* Higher-resolution UTF-8 based Graph mode\n  (Thanks to James Hall from vtop for the idea!)\n* Show program path settings\n  (thanks to Tobias Geerinckx-Rice)\n* BUGFIX: Fix crash when scrolling an empty filtered list.\n* Use dynamic units for text display, and several fixes\n  (thanks to Christian Hesse)\n* BUGFIX: fix error caused by overflow in usertime calculation.\n  (thanks to Patrick Marlier)\n* Catch all memory allocation errors\n  (thanks to Michael McConville for the push)\n* Several tweaks and bugfixes\n  (See the Git log for details and contributors!)\n\nWhat's new in version 1.0.3\n\n* Tag all children ('c' key)\n* Fixes in accounting of guest time when using virtualization\n  (thanks to Patrick Marlier)\n* Performance improvements\n  (thanks to Jann Horn)\n* Further performance improvements due to conditional parsing\n  of IO data depending on selected fields.\n* Better consistency in coloring.\n* Increase limit of buffer when tracing a deep nested process tree.\n* Display pagefault stats.\n* BUGFIX: Fix crash when adding meters and toggling detailed CPU time.\n  (thanks to Dawid Gajownik)\n* Add column to track the OOM-killer score of processes\n  (thanks to Leigh Simpson)\n\nWhat's new in version 1.0.2\n\n* Add IO priority support ('i' key)\n* Avoid deleting .htoprc if it is a symlink\n* Fail gracefully when /proc is not mounted\n  (thanks to Philipp Hagemeister)\n* Option to update process names on every refresh\n  (thanks to Rob Hoelz)\n* BUGFIX: Fix crashes when process list is empty\n\nWhat's new in version 1.0.1\n\n* Move .htoprc to XDG-compliant path ~/.config/htop/htoprc,\n  respecting $XDG_CONFIG_HOME\n  (thanks to Hadzhimurad Ustarkhan for the suggestion.)\n* Safer behavior on the kill screen, to make it harder to kill the wrong process.\n* Fix for building in FreeBSD 8.2\n  (thanks to Trond Endrestol)\n* BUGFIX: behavior of 'F' (follow) key was broken, also affecting the\n  persistence of mouse selections.\n* BUGFIX: keep main panel up-to-date when running the screen manager,\n  to fix crash when processes die while on the F9/Kill screen.\n\nWhat's new in version 1.0\n\n* Performance improvements\n* Support for splitting CPU meters into two or four columns\n  (thanks to Wim Heirman)\n* Switch from PLPA, which is now deprecated, to HWLOC.\n* Bring back support for native Linux sched_setaffinity,\n  so we don't have to use HWLOC where we don't need to.\n* Support for typing in user names and column fields in selection panels.\n* Support for UTF-8 tree drawing\n  (thanks to Bin Guo)\n* Option for counting CPUs from zero\n  (thanks to Sean Noonan)\n* Meters update in every screen (no longer halting while on Setup, etc.)\n* Stricter checks for command-line options\n  (thanks to Sebastian Pipping)\n* Incremental filtering\n  (thanks to Seth Heeren for the idea and initial implementation)\n* Try harder to find the ncurses header\n  (thanks to Moritz Barsnick)\n* Man page updates\n  (thanks to Vincent Launchbury)\n* BUGFIX: Support larger numbers for process times.\n  (thanks to Tristan Nakagawa for the report.)\n* BUGFIX: Segfault in BarMeterMode_draw() for small terminal widths\n  (patch by Sebastian Pipping)\n\nWhat's new in version 0.9\n\n* Add support for \"steal\"/guest CPU time measurement\n  in virtualization environments\n* Expand and collapse subtrees using '+' and '-' when in tree-view\n* Support for cgroups\n  (thanks to Guillaume Zitta and Daniel Lezcano)\n* Show custom thread names\n  (thanks to Anders Torger)\n* Add support for STARTTIME field\n* Upgrade PLPA to version 1.3.2\n* Fix license terms with regard to PLPA\n  (thanks to Tom Callaway)\n* getopt-based long options and --no-color\n  (thanks to Vincent Launchbury)\n* BUGFIX: Fix display of nan% in CPU meters\n  (thanks to Steven Hampson)\n* BUGFIX: Fix memory leak\n  (thanks to Pavol Rusnak)\n* Add Bash/emacs style navigation keys\n  (thanks to Daniel Schuler)\n* Improve battery meter support\n  (thanks to Richard W.)\n* BUGFIX: Fix IO-wait color in \"Black on White\" scheme\n* BUGFIX: Fix search by process name when list is filtered by user.\n  (thanks to Sergej Pupykin for the report.)\n* BUGFIX: Fix alignment for display of memory values above 100G (sign of the times!)\n  (thanks to Jan van Haarst for the report.)\n\nWhat's new in version 0.8.3\n\n* BUGFIX: Fix crash on F6 key\n  (thanks to Rainer Suhm)\n* BUGFIX: Fix a minor bug which affected the build process.\n\nWhat's new in version 0.8.2\n\n* Integrated lsof (press 'l')\n* Fix display of gigabyte-sized values\n  (thanks to Andika Triwidada)\n* Option to display hostname in the meters area\n* Rename VEID to CTID in OpenVZ systems\n  (thanks to Thorsten Schifferdecker)\n* Corrections to the desktop entry file\n  (thanks by Samuli Suominen)\n* BUGFIX: Correct page size calculation for FreeBSD systems\n  (thanks to Andrew Paulsen)\n* Allow compilation without PLPA on systems that don't support it\n  (thanks to Timothy Redaelli)\n* BUGFIX: Fix missing tree view when userland threads are hidden\n  (thanks to Josh Stone)\n* BUGFIX: Fix for VPID on OpenVZ systems\n  (thanks to Wolfgang Frisch)\n\nWhat's new in version 0.8.1\n\n* Linux-VServer support\n  (thanks to Jonathan Sambrook and Benedikt Bohm)\n* Battery meter\n  (thanks to Ian Page Hands)\n* BUGFIX: Fix collection of IO stats in multithreaded processes\n  (thanks to Gerhard Heift)\n* Remove assertion that fails on hardened kernels\n  (thanks to Wolfram Schlich for the report)\n\nWhat's new in version 0.8\n\n* Ability to change sort column with the mouse by\n  clicking column titles (click again to invert order)\n* Add support for Linux per-process IO statistics,\n  enabled with the --enable-taskstats flag, which\n  requires a kernel compiled with taskstats support.\n  (thanks to Tobias Oetiker)\n* Add Unicode support, enabled with the --enable-unicode\n  flag, which requires libncursesw.\n  (thanks to Sergej Pupykin)\n* BUGFIX: Fix display of CPU count for threaded processes.\n  When user threads are hidden, process now shows the\n  sum of processor usage for all processors. When user\n  threads are displayed, each thread shows its own\n  processor usage, including the root thread.\n  (thanks to Bert Wesarg for the report)\n* BUGFIX: avoid crashing when using many meters\n  (thanks to David Cho for the report)\n\nWhat's new in version 0.7\n\n* CPU affinity configuration ('a' key)\n* Improve display of tree view, properly nesting\n  threads of the same app based on TGID.\n* IO-wait time now counts as idle time, which is a more\n  accurate description. It is still available in\n  split time, now called detailed CPU time.\n  (thanks to Samuel Thibault for the report)\n* BUGFIX: Correct display of TPGID field\n* Add TGID field\n* BUGFIX: Don't crash with invalid command-line flags\n  (thanks to Nico Golde for the report)\n* Fix GCC 4.3 compilation issues\n  (thanks to Martin Michlmayr for the report)\n* OpenVZ support, enabled at compile-time with\n  the --enable-openvz flag.\n  (thanks to Sergey Lychko)\n\nWhat's new in version 0.6.6\n\n* Add support of NLWP field\n  (thanks to Bert Wesarg)\n* BUGFIX: Fix use of configurable /proc location\n  (thanks to Florent Thoumie)\n* Fix memory percentage calculation and make it saner\n  (thanks to Olev Kartau for the report)\n* Added display of DRS, DT, LRS and TRS\n  (thanks to Matthias Lederhofer)\n* BUGFIX: LRS and DRS memory values were flipped\n  (thanks to Matthias Lederhofer)\n* BUGFIX: Don't crash on very high UIDs\n  (thanks to Egmont Koblinger)\n\nWhat's new in version 0.6.5\n\n* Add hardened-debug flags for debugging with Hardened GCC\n* BUGFIX: Handle error condition when a directory vanishes\n  from /proc\n* BUGFIX: Fix leak of process command line\n* BUGFIX: Collect orphaned items when arranging the tree view.\n  (thanks to Wolfram Schlich for assistance with debugging)\n* Separate proc and memory debugging into separate #defines.\n* BUGFIX: Fix message when configure fails due to\n  missing libraries\n  (thanks to Jon)\n* BUGFIX: Don't truncate value when displaying a very large\n  process\n  (thanks to Bo Liu)\n\nWhat's new in version 0.6.4\n\n* Add an option to split the display of kernel time\n  in the CPU meter into system, IO-wait, IRQ and soft-IRQ.\n  (thanks to Philipp Richter)\n* --sort-key flag in the command-line, overriding the\n  saved setting in .htoprc for the session.\n  (thanks to Rodolfo Borges)\n* BUGFIX: Fixed string overflow on uptime display.\n  (thanks to Marc Cahalan)\n\nWhat's new in version 0.6.3\n\n* Performance improvements: uses much less CPU than the\n  previous release with the default setup.\n* Use 64-bit values when storing processor times to\n  avoid overflow.\n* Memory consumption improvements, compensating storage\n  of 64-bit values.\n* Internal change: rename TypedVector to Vector and\n  ListBox (and related classes) to Panel.\n* Have configure actually fail when needed libraries or\n  headers are not found.\n* Horizontally scroll in larger increments when on the\n  Linux console because of slow update of unaccelerated fb\n* No longer untag processes after sending a signal\n  (useful for when SIGTERM fails and one wants to try again\n  with SIGKILL). All processes can be untagged at once with 'U'.\n  (thanks to A. Costa for the suggestion)\n\nWhat's new in version 0.6.2\n\n* BUGFIX: Fixed crash when using some .htoprc files from 0.6\n  (thanks to Wolfram Schlich and John Thomas for the reports)\n* BUGFIX: Ensure changes to color scheme are saved\n* BUGFIX: Make configure behave correctly with --with-proc\n* Minor addition to .desktop file.\n\nWhat's new in version 0.6.1\n\n* New meter type: \"All CPUs\", which dynamically adjusts\n  to the number of CPUs present in the machine. Note that\n  because of this, older versions of htop may crash when\n  using an .htoprc file modified my the newer version.\n* Accept --with-proc=<dir> in configure, to specify\n  alternative procfs locations (making htop friendlier\n  to the Linux compatibility layer in FreeBSD)\n* Included icon .desktop and desktop entry\n  (thanks to Peter Hyman)\n* Added a check to make sure that a root-user htop closes\n  when its parent non-root terminal is closed.\n  (thanks to Ilya Evseev for the report)\n* BUGFIX: does not crash anymore when $HOME is not set\n  (thanks to Henning Schild for the report)\n* Wait for strace child process to die properly.\n  (thanks to Marcus Fritzsch)\n* Support $HTOPRC\n  (thanks to Luis Limon)\n\nWhat's new in version 0.6\n\n* Configuration of columns merged into the Setup screen\n* Integrated strace (press 's')\n  (thanks to Marinho Barcellos for the help)\n* BUGFIX: some fixes, aided by Valgrind\n  (thanks to Wolfram Schlich for the report)\n* BUGFIX: fixed bug when switching meter modes\n  (thanks to Eduardo Righes for the report)\n* Show processes of a single user\n* \"SortBy\" function now menu-based\n* Improved mouse handling\n* ...and on top of that reduced memory consumption!\n\nWhat's new in version 0.5.4\n\n* Color schemes\n* -d flag, to configure delay between updates.\n  Note that the delay value is saved in ~/.htoprc.\n* BUGFIX: Update of meters was halting after help screen.\n  (thanks to Matt Moore)\n* BUGFIX: No longer display incorrect information\n  in first frame.\n* BUGFIX: Fix auto-detection of /proc/stat,\n  correcting CPU usage information on multiprocessor\n  systems.\n\nWhat's new in version 0.5.3\n\n* Read new field \"steal\" on newer /proc/stat files\n* Auto-detects format of /proc/stat, to cope\n  with patched 2.4 kernels which display 2.6-style\n  information (most notably those on RHEL 3)\n  (thanks to Fernando Dotta for the report)\n* Support $HOME_ETC initiative\n  (see http://www.pld-linux.org/Docs/home-etc)\n  (thanks to Roman Barczynski for the tip)\n* The configure script now tests for /proc, so\n  that it fails early on unsupported platforms\n  instead of during compilation/execution.\n* Made presentation of the function keys in the\n  status bar consistent across views\n  (thanks to David Mathog for the report)\n* Minor changes to make the codebase more friendly\n  to possible future ports\n  (thanks to Jari Aalto and David Mathog for the reports)\n\nWhat's new in version 0.5.2\n\n* BUGFIX: Correct display of user field\n  (thanks to Marcin Miroslaw for the report)\n* Keyboard support improvements\n  (thanks to Aury Fink Filho for the report)\n\nWhat's new in version 0.5.1\n\n* BUGFIX: Correctly displays NPTL threads from\n  /proc/<pid>/task subdirectories\n  (thanks to Mike Pot for the report)\n* BUGFIX: Fixes key handling on Signals listbox\n  (thanks to Ondrej Vlach)\n* Renicing no longer displays temporary illegal values\n  (thanks to Ondrej Vlach)\n* 'Hide userland threads' feature for NPTL threads\n\nWhat's new in version 0.5\n\n* Tree view\n* New column, TIME (user + system time,\n  like in top, 'T' switches to \"sort by time\")\n* Major reorganization of the underlying code of the\n  setup screen, to manage setup pages\n* New setup page: Display options\n* Hide kernel threads ('K' key)\n* Colorized memory numbers\n* Vastly improved support for monochromatic terminals\n* Shadow processes that do not belong to user ('U' key)\n* Header margin configuration accessible via setup screen\n* Visual feedback on failing incremental search\n* BUGFIX: fixed keyboard input issues on 64-bit machines\n* BUGFIX: hopefully fixed the incorrect values\n  that show on status bars in some systems\n* BUGFIX: doesn't mess with fields list anymore when\n  canceling after changing the number of items\n* Uptime meter no longer says \"1 days\" ;)\n\nWhat's new in version 0.4.1\n\n* BUGFIX: compiles on 64-bit architectures again\n  (thanks to Bartosz Fenski for the report)\n* BUGFIX: multi-processor support fixed on kernels 2.6\n  (thanks to Wolfram Schlich for the report)\n\nWhat's new in version 0.4\n\n* Support for multiple processors!\n* Basic mouse support\n* Modular header based on configurable meters;\n  supports 4 view modes: bar, text, LED, graph\n* Uptime, load average meters\n  (thanks to Marc Calahan)\n* Meters setup screen; should eventually evolve into a\n  general setup screen, with column setup, keybindings, etc.\n* Thread hiding toggleable\n  (press 'T' to hide the nonstandard dotfiles in /proc)\n* BUGFIX: Do not flicker screen on column configuration screen\n* Clock and load average meters\n  (thanks to Marc Calahan)\n* BUGFIX: numeric swap indicator was printing bogus value\n* BUGFIX: internal fixes on Panel widget\n* Clear the bottom line when exiting\n* Press \"F3\" during search to walk through the results\n* Improved navigation on column configuration screen\n* BUGFIX: fix segfault on kernels with restricted /proc\n  enabled\n* BUGFIX: a few last-minute bugfixes in the setup UI\n  (thanks to Gaspare Bruno for the reports)\n\n\nWhat's new in version 0.3.3\n\n* Saves column and sorting configuration in ~/.htoprc\n* Displays \"hidden\" threads on RedHat 9\n  (Thanks to Leonardo Godinho)\n* BUGFIX: supports process names with spaces\n  (Thanks to Marc Calahan)\n* BUGFIX: ...and parentheses :)\n* BUGFIX: long process names overflowed RichString\n  (Thanks to Marc Calahan)\n\nWhat's new in version 0.3.2\n\n* Performance and memory usage improvements, aided by gprof\n* BUGFIX: quite a few fixes, aided by Valgrind\n* Header preview on column configuration screen\n  (Thanks to Marc Calahan)\n\nWhat's new in version 0.3.1\n\n* BUGFIX: crash fixes related to process list handling\n  (thanks to Marc Calahan)\n* Man page\n  (thanks to Bartosz Fenski)\n* Tag processes with the space bar\n* Kill multiple process based on tag\n* BUGFIX: corrected processing order of updates in list\n* Screen refresh function on Ctrl-L\n* Large numbers are shown in MB/GB notation in order to fit screen\n  (thanks to Marc Calahan)\n* Realtime priority is correctly displayed\n  (thanks to Marc Calahan)\n* Preliminary support for configurable columns, with 'C'\n  (thanks to Marc Calahan)\n  -- not all columns display properly yet\n\nWhat's new in version 0.3\n\n* BUGFIX: no dirt left on screen on horizontal scrolling\n* Signal selection on \"kill\" command\n* Color-coding for users, nice and process status\n* \"Follow\" function\n* Fully selectable sort order\n* Function bar on last line\n* Build system now uses autotools\n\nWhat's new in version 0.2.1\n\n* Sorting by process or memory usage ('P' and 'M', like top)\n* Quicker default update (1.5 second, not yet configurable)\n* Now the order of the elements in the process list stay\n  'locked' for a while after you move the cursor to ease\n  selecting a process\n* Corrected the installation instructions in README\n  (Thanks to Jeremy Eglen)\n* Should now compile cleanly on Conectiva 9 and similar systems\n  (Thanks to Adriano Frare for the report)\n* Friendlier Makefile\n* Help screen ('h')\n\nWhat's new in version 0.2\n\n* Memory indicators in header now show used and total, in MB\n* Preliminary support for sorting (CPU% only)\n* Memory percentage field (resident memory / used memory)\n* BUGFIX: identified source of spurious crashes\n* Can search names containing numbers\n  (Thanks to Rafael Jeffman)\n* Correctly calculates memory page size\n  (Thanks to Rafael Jeffman)\n\nWhat's new in version 0.13\n\n* Handles terminal resize\n* Display all user names (not only those in /etc/passwd)\n  (Thanks to Julio Biason)\n\nWhat's new in version 0.12\n\n* Support for 2.6 kernels\n* Uses terminal default colors as a background\n\nWhat's new in version 0.11\n\n* BUGFIX: does not crash when UID is not in /etc/passwd\n\nWhat's new in version 0.1\n\n* Everything!\n"
        },
        {
          "name": "ClockMeter.c",
          "type": "blob",
          "size": 1.021484375,
          "content": "/*\nhtop - ClockMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"ClockMeter.h\"\n\n#include <time.h>\n#include <sys/time.h>\n\n#include \"CRT.h\"\n#include \"Machine.h\"\n#include \"Object.h\"\n\n\nstatic const int ClockMeter_attributes[] = {\n   CLOCK\n};\n\nstatic void ClockMeter_updateValues(Meter* this) {\n   const Machine* host = this->host;\n\n   struct tm result;\n   const struct tm* lt = localtime_r(&host->realtime.tv_sec, &result);\n   strftime(this->txtBuffer, sizeof(this->txtBuffer), \"%H:%M:%S\", lt);\n}\n\nconst MeterClass ClockMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = ClockMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = (1 << TEXT_METERMODE) | (1 << LED_METERMODE),\n   .maxItems = 0,\n   .total = 0.0,\n   .attributes = ClockMeter_attributes,\n   .name = \"Clock\",\n   .uiName = \"Clock\",\n   .caption = \"Time: \",\n};\n"
        },
        {
          "name": "ClockMeter.h",
          "type": "blob",
          "size": 0.2744140625,
          "content": "#ifndef HEADER_ClockMeter\n#define HEADER_ClockMeter\n/*\nhtop - ClockMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n\nextern const MeterClass ClockMeter_class;\n\n#endif\n"
        },
        {
          "name": "ColorsPanel.c",
          "type": "blob",
          "size": 2.7509765625,
          "content": "/*\nhtop - ColorsPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"ColorsPanel.h\"\n\n#include <assert.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Object.h\"\n#include \"OptionItem.h\"\n#include \"ProvideCurses.h\"\n\n\n// TO ADD A NEW SCHEME:\n// * Increment the size of bool check in ColorsPanel.h\n// * Add the entry in the ColorSchemeNames array below in the file\n// * Add a define in CRT.h that matches the order of the array\n// * Add the colors in CRT_setColors\n\n\nstatic const char* const ColorsFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nstatic const char* const ColorSchemeNames[] = {\n   \"Default\",\n   \"Monochromatic\",\n   \"Black on White\",\n   \"Light Terminal\",\n   \"MC\",\n   \"Black Night\",\n   \"Broken Gray\",\n   NULL\n};\n\nstatic void ColorsPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   ColorsPanel* this = (ColorsPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic HandlerResult ColorsPanel_eventHandler(Panel* super, int ch) {\n   ColorsPanel* this = (ColorsPanel*) super;\n\n   HandlerResult result = IGNORED;\n\n   switch (ch) {\n      case 0x0a:\n      case 0x0d:\n      case KEY_ENTER:\n      case KEY_MOUSE:\n      case KEY_RECLICK:\n      case ' ': {\n         int mark = Panel_getSelectedIndex(super);\n         assert(mark >= 0);\n         assert(mark < LAST_COLORSCHEME);\n\n         for (int i = 0; ColorSchemeNames[i] != NULL; i++)\n            CheckItem_set((CheckItem*)Panel_get(super, i), false);\n         CheckItem_set((CheckItem*)Panel_get(super, mark), true);\n\n         this->settings->colorScheme = mark;\n         this->settings->changed = true;\n         this->settings->lastUpdate++;\n\n         CRT_setColors(mark);\n         clear();\n\n         result = HANDLED | REDRAW;\n      }\n   }\n\n   return result;\n}\n\nconst PanelClass ColorsPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = ColorsPanel_delete\n   },\n   .eventHandler = ColorsPanel_eventHandler\n};\n\nColorsPanel* ColorsPanel_new(Settings* settings) {\n   ColorsPanel* this = AllocThis(ColorsPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(ColorsFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(CheckItem), true, fuBar);\n\n   this->settings = settings;\n\n   assert(ARRAYSIZE(ColorSchemeNames) == LAST_COLORSCHEME + 1);\n\n   Panel_setHeader(super, \"Colors\");\n   for (int i = 0; ColorSchemeNames[i] != NULL; i++) {\n      Panel_add(super, (Object*) CheckItem_newByVal(ColorSchemeNames[i], false));\n   }\n   CheckItem_set((CheckItem*)Panel_get(super, settings->colorScheme), true);\n   return this;\n}\n"
        },
        {
          "name": "ColorsPanel.h",
          "type": "blob",
          "size": 0.43359375,
          "content": "#ifndef HEADER_ColorsPanel\n#define HEADER_ColorsPanel\n/*\nhtop - ColorsPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n#include \"Settings.h\"\n\n\ntypedef struct ColorsPanel_ {\n   Panel super;\n\n   Settings* settings;\n} ColorsPanel;\n\nextern const PanelClass ColorsPanel_class;\n\nColorsPanel* ColorsPanel_new(Settings* settings);\n\n#endif\n"
        },
        {
          "name": "ColumnsPanel.c",
          "type": "blob",
          "size": 4.525390625,
          "content": "/*\nhtop - ColumnsPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"ColumnsPanel.h\"\n\n#include <assert.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n#include \"CRT.h\"\n#include \"DynamicColumn.h\"\n#include \"FunctionBar.h\"\n#include \"Hashtable.h\"\n#include \"ListItem.h\"\n#include \"Object.h\"\n#include \"Process.h\"\n#include \"ProvideCurses.h\"\n#include \"RowField.h\"\n#include \"XUtils.h\"\n\n\nstatic const char* const ColumnsFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"MoveUp\", \"MoveDn\", \"Remove\", \"Done  \", NULL};\n\nstatic void ColumnsPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   ColumnsPanel* this = (ColumnsPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic HandlerResult ColumnsPanel_eventHandler(Panel* super, int ch) {\n   ColumnsPanel* const this = (ColumnsPanel*) super;\n\n   int selected = Panel_getSelectedIndex(super);\n   HandlerResult result = IGNORED;\n   int size = Panel_size(super);\n\n   switch (ch) {\n      case 0x0a:\n      case 0x0d:\n      case KEY_ENTER:\n      case KEY_MOUSE:\n      case KEY_RECLICK:\n         if (selected < size) {\n            this->moving = !(this->moving);\n            Panel_setSelectionColor(super, this->moving ? PANEL_SELECTION_FOLLOW : PANEL_SELECTION_FOCUS);\n            ListItem* selectedItem = (ListItem*) Panel_getSelected(super);\n            if (selectedItem)\n               selectedItem->moving = this->moving;\n            result = HANDLED;\n         }\n         break;\n      case KEY_UP:\n         if (!this->moving)\n            break;\n         /* else fallthrough */\n      case KEY_F(7):\n      case '[':\n      case '-':\n         if (selected < size)\n            Panel_moveSelectedUp(super);\n         result = HANDLED;\n         break;\n      case KEY_DOWN:\n         if (!this->moving)\n            break;\n         /* else fallthrough */\n      case KEY_F(8):\n      case ']':\n      case '+':\n         if (selected < size - 1)\n            Panel_moveSelectedDown(super);\n         result = HANDLED;\n         break;\n      case KEY_F(9):\n      case KEY_DC:\n         if (size > 1 && selected < size)\n            Panel_remove(super, selected);\n         result = HANDLED;\n         break;\n      default:\n         if (0 < ch && ch < 255 && isgraph((unsigned char)ch))\n            result = Panel_selectByTyping(super, ch);\n         if (result == BREAK_LOOP)\n            result = IGNORED;\n         break;\n   }\n\n   if (result == HANDLED)\n      ColumnsPanel_update(super);\n\n   return result;\n}\n\nconst PanelClass ColumnsPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = ColumnsPanel_delete\n   },\n   .eventHandler = ColumnsPanel_eventHandler\n};\n\nstatic void ColumnsPanel_add(Panel* super, unsigned int key, Hashtable* columns) {\n   const char* name;\n   if (key < LAST_PROCESSFIELD) {\n      name = Process_fields[key].name;\n   } else {\n      const DynamicColumn* column = Hashtable_get(columns, key);\n      assert(column);\n      if (!column) {\n         name = NULL;\n      } else {\n         /* heading preferred here but name is always available */\n         name = column->heading ? column->heading : column->name;\n      }\n   }\n   if (name == NULL)\n      name = \"- \";\n   Panel_add(super, (Object*) ListItem_new(name, key));\n}\n\nvoid ColumnsPanel_fill(ColumnsPanel* this, ScreenSettings* ss, Hashtable* columns) {\n   Panel* super = (Panel*) this;\n   Panel_prune(super);\n   for (const RowField* fields = ss->fields; *fields; fields++)\n      ColumnsPanel_add(super, *fields, columns);\n   this->ss = ss;\n}\n\nColumnsPanel* ColumnsPanel_new(ScreenSettings* ss, Hashtable* columns, bool* changed) {\n   ColumnsPanel* this = AllocThis(ColumnsPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(ColumnsFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   this->ss = ss;\n   this->changed = changed;\n   this->moving = false;\n   Panel_setHeader(super, \"Active Columns\");\n\n   ColumnsPanel_fill(this, ss, columns);\n\n   return this;\n}\n\nvoid ColumnsPanel_update(Panel* super) {\n   ColumnsPanel* this = (ColumnsPanel*) super;\n   int size = Panel_size(super);\n   *(this->changed) = true;\n   this->ss->fields = xRealloc(this->ss->fields, sizeof(ProcessField) * (size + 1));\n   this->ss->flags = 0;\n   for (int i = 0; i < size; i++) {\n      int key = ((ListItem*) Panel_get(super, i))->key;\n      this->ss->fields[i] = key;\n      if (key < LAST_PROCESSFIELD)\n         this->ss->flags |= Process_fields[key].flags;\n   }\n   this->ss->fields[size] = 0;\n}\n"
        },
        {
          "name": "ColumnsPanel.h",
          "type": "blob",
          "size": 0.67578125,
          "content": "#ifndef HEADER_ColumnsPanel\n#define HEADER_ColumnsPanel\n/*\nhtop - ColumnsPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Hashtable.h\"\n#include \"Panel.h\"\n#include \"Settings.h\"\n\n\ntypedef struct ColumnsPanel_ {\n   Panel super;\n   ScreenSettings* ss;\n   bool* changed;\n\n   bool moving;\n} ColumnsPanel;\n\nextern const PanelClass ColumnsPanel_class;\n\nColumnsPanel* ColumnsPanel_new(ScreenSettings* ss, Hashtable* columns, bool* changed);\n\nvoid ColumnsPanel_fill(ColumnsPanel* this, ScreenSettings* ss, Hashtable* columns);\n\nvoid ColumnsPanel_update(Panel* super);\n\n#endif\n"
        },
        {
          "name": "CommandLine.c",
          "type": "blob",
          "size": 13.8271484375,
          "content": "/*\nhtop - CommandLine.c\n(C) 2004-2011 Hisham H. Muhammad\n(C) 2020-2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"CommandLine.h\"\n\n#include <assert.h>\n#include <ctype.h>\n#include <getopt.h>\n#include <locale.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"Action.h\"\n#include \"CRT.h\"\n#include \"DynamicColumn.h\"\n#include \"DynamicMeter.h\"\n#include \"DynamicScreen.h\"\n#include \"Hashtable.h\"\n#include \"Header.h\"\n#include \"IncSet.h\"\n#include \"Machine.h\"\n#include \"MainPanel.h\"\n#include \"MetersPanel.h\"\n#include \"Panel.h\"\n#include \"Platform.h\"\n#include \"Process.h\"\n#include \"ProcessTable.h\"\n#include \"ScreenManager.h\"\n#include \"Settings.h\"\n#include \"Table.h\"\n#include \"UsersTable.h\"\n#include \"XUtils.h\"\n\n\nstatic void printVersionFlag(const char* name) {\n   printf(\"%s \" VERSION \"\\n\", name);\n}\n\nstatic void printHelpFlag(const char* name) {\n   printf(\"%s \" VERSION \"\\n\"\n          COPYRIGHT \"\\n\"\n          \"Released under the GNU GPLv2+.\\n\\n\"\n          \"-C --no-color                   Use a monochrome color scheme\\n\"\n          \"-d --delay=DELAY                Set the delay between updates, in tenths of seconds\\n\"\n          \"-F --filter=FILTER              Show only the commands matching the given filter\\n\"\n          \"-h --help                       Print this help screen\\n\"\n          \"-H --highlight-changes[=DELAY]  Highlight new and old processes\\n\", name);\n#ifdef HAVE_GETMOUSE\n   printf(\"-M --no-mouse                   Disable the mouse\\n\");\n#endif\n   printf(\"-n --max-iterations=NUMBER      Exit htop after NUMBER iterations/frame updates\\n\"\n          \"-p --pid=PID[,PID,PID...]       Show only the given PIDs\\n\"\n          \"   --readonly                   Disable all system and process changing features\\n\"\n          \"-s --sort-key=COLUMN            Sort by COLUMN in list view (try --sort-key=help for a list)\\n\"\n          \"-t --tree                       Show the tree view (can be combined with -s)\\n\"\n          \"-u --user[=USERNAME]            Show only processes for a given user (or $USER)\\n\"\n          \"-U --no-unicode                 Do not use unicode but plain ASCII\\n\"\n          \"-V --version                    Print version info\\n\");\n   Platform_longOptionsUsage(name);\n   printf(\"\\n\"\n          \"Press F1 inside %s for online help.\\n\"\n          \"See 'man %s' for more information.\\n\", name, name);\n}\n\n// ----------------------------------------\n\ntypedef struct CommandLineSettings_ {\n   Hashtable* pidMatchList;\n   char* commFilter;\n   uid_t userId;\n   int sortKey;\n   int delay;\n   int iterationsRemaining;\n   bool useColors;\n#ifdef HAVE_GETMOUSE\n   bool enableMouse;\n#endif\n   bool treeView;\n   bool allowUnicode;\n   bool highlightChanges;\n   int highlightDelaySecs;\n   bool readonly;\n} CommandLineSettings;\n\nstatic CommandLineStatus parseArguments(int argc, char** argv, CommandLineSettings* flags) {\n\n   *flags = (CommandLineSettings) {\n      .pidMatchList = NULL,\n      .commFilter = NULL,\n      .userId = (uid_t)-1, // -1 is guaranteed to be an invalid uid_t (see setreuid(2))\n      .sortKey = 0,\n      .delay = -1,\n      .iterationsRemaining = -1,\n      .useColors = true,\n#ifdef HAVE_GETMOUSE\n      .enableMouse = true,\n#endif\n      .treeView = false,\n      .allowUnicode = true,\n      .highlightChanges = false,\n      .highlightDelaySecs = -1,\n      .readonly = false,\n   };\n\n   const struct option long_opts[] =\n   {\n      {\"help\",       no_argument,         0, 'h'},\n      {\"version\",    no_argument,         0, 'V'},\n      {\"delay\",      required_argument,   0, 'd'},\n      {\"max-iterations\", required_argument, 0, 'n'},\n      {\"sort-key\",   required_argument,   0, 's'},\n      {\"user\",       optional_argument,   0, 'u'},\n      {\"no-color\",   no_argument,         0, 'C'},\n      {\"no-colour\",  no_argument,         0, 'C'},\n      {\"no-mouse\",   no_argument,         0, 'M'},\n      {\"no-unicode\", no_argument,         0, 'U'},\n      {\"tree\",       no_argument,         0, 't'},\n      {\"pid\",        required_argument,   0, 'p'},\n      {\"filter\",     required_argument,   0, 'F'},\n      {\"highlight-changes\", optional_argument, 0, 'H'},\n      {\"readonly\",   no_argument,         0, 128},\n      PLATFORM_LONG_OPTIONS\n      {0, 0, 0, 0}\n   };\n\n   int opt, opti = 0;\n   /* Parse arguments */\n   while ((opt = getopt_long(argc, argv, \"hVMCs:td:n:u::Up:F:H::\", long_opts, &opti))) {\n      if (opt == EOF)\n         break;\n\n      switch (opt) {\n         case 'h':\n            printHelpFlag(program);\n            return STATUS_OK_EXIT;\n         case 'V':\n            printVersionFlag(program);\n            return STATUS_OK_EXIT;\n         case 's':\n            assert(optarg); /* please clang analyzer, cause optarg can be NULL in the 'u' case */\n            if (String_eq(optarg, \"help\")) {\n               for (int j = 1; j < LAST_PROCESSFIELD; j++) {\n                  const char* name = Process_fields[j].name;\n                  const char* description = Process_fields[j].description;\n                  if (name)\n                     printf(\"%19s %s\\n\", name, description);\n               }\n               return STATUS_OK_EXIT;\n            }\n            flags->sortKey = 0;\n            for (int j = 1; j < LAST_PROCESSFIELD; j++) {\n               if (Process_fields[j].name == NULL)\n                  continue;\n               if (String_eq(optarg, Process_fields[j].name)) {\n                  flags->sortKey = j;\n                  break;\n               }\n            }\n            if (flags->sortKey == 0) {\n               fprintf(stderr, \"Error: invalid column \\\"%s\\\".\\n\", optarg);\n               return STATUS_ERROR_EXIT;\n            }\n            break;\n         case 'd':\n            if (sscanf(optarg, \"%16d\", &(flags->delay)) == 1) {\n               if (flags->delay < 1)\n                  flags->delay = 1;\n               if (flags->delay > 100)\n                  flags->delay = 100;\n            } else {\n               fprintf(stderr, \"Error: invalid delay value \\\"%s\\\".\\n\", optarg);\n               return STATUS_ERROR_EXIT;\n            }\n            break;\n         case 'n':\n            if (sscanf(optarg, \"%16d\", &flags->iterationsRemaining) == 1) {\n               if (flags->iterationsRemaining <= 0) {\n                  fprintf(stderr, \"Error: maximum iteration count must be positive.\\n\");\n                  return STATUS_ERROR_EXIT;\n               }\n            } else {\n               fprintf(stderr, \"Error: invalid maximum iteration count \\\"%s\\\".\\n\", optarg);\n               return STATUS_ERROR_EXIT;\n            }\n            break;\n         case 'u': {\n            const char* username = optarg;\n            if (!username && optind < argc && argv[optind] != NULL &&\n                (argv[optind][0] != '\\0' && argv[optind][0] != '-')) {\n               username = argv[optind++];\n            }\n\n            if (!username) {\n               flags->userId = geteuid();\n            } else if (!Action_setUserOnly(username, &(flags->userId))) {\n               for (const char* itr = username; *itr; ++itr)\n                  if (!isdigit((unsigned char)*itr)) {\n                     fprintf(stderr, \"Error: invalid user \\\"%s\\\".\\n\", username);\n                     return STATUS_ERROR_EXIT;\n                  }\n               flags->userId = atol(username);\n            }\n            break;\n         }\n         case 'C':\n            flags->useColors = false;\n            break;\n         case 'M':\n#ifdef HAVE_GETMOUSE\n            flags->enableMouse = false;\n#endif\n            break;\n         case 'U':\n            flags->allowUnicode = false;\n            break;\n         case 't':\n            flags->treeView = true;\n            break;\n         case 'p': {\n            assert(optarg); /* please clang analyzer, cause optarg can be NULL in the 'u' case */\n            char* argCopy = xStrdup(optarg);\n            char* saveptr;\n            const char* pid = strtok_r(argCopy, \",\", &saveptr);\n\n            if (!flags->pidMatchList) {\n               flags->pidMatchList = Hashtable_new(8, false);\n            }\n\n            while (pid) {\n               unsigned int num_pid = atoi(pid);\n               //  deepcode ignore CastIntegerToAddress: we just want a non-NULL pointer here\n               Hashtable_put(flags->pidMatchList, num_pid, (void*) 1);\n               pid = strtok_r(NULL, \",\", &saveptr);\n            }\n            free(argCopy);\n\n            break;\n         }\n         case 'F':\n            assert(optarg);\n            free_and_xStrdup(&flags->commFilter, optarg);\n            break;\n         case 'H': {\n            const char* delay = optarg;\n            if (!delay && optind < argc && argv[optind] != NULL &&\n                (argv[optind][0] != '\\0' && argv[optind][0] != '-')) {\n               delay = argv[optind++];\n            }\n            if (delay) {\n               if (sscanf(delay, \"%16d\", &(flags->highlightDelaySecs)) == 1) {\n                  if (flags->highlightDelaySecs < 1)\n                     flags->highlightDelaySecs = 1;\n               } else {\n                  fprintf(stderr, \"Error: invalid highlight delay value \\\"%s\\\".\\n\", delay);\n                  return STATUS_ERROR_EXIT;\n               }\n            }\n            flags->highlightChanges = true;\n            break;\n         }\n         case 128:\n            flags->readonly = true;\n            break;\n\n         default: {\n            CommandLineStatus status;\n            if ((status = Platform_getLongOption(opt, argc, argv)) != STATUS_OK)\n               return status;\n            break;\n         }\n      }\n   }\n\n   if (optind < argc) {\n      fprintf(stderr, \"Error: unsupported non-option ARGV-elements:\");\n      while (optind < argc)\n         fprintf(stderr, \" %s\", argv[optind++]);\n      fprintf(stderr, \"\\n\");\n      return STATUS_ERROR_EXIT;\n   }\n\n   return STATUS_OK;\n}\n\nstatic void CommandLine_delay(Machine* host, unsigned long millisec) {\n   struct timespec req = {\n      .tv_sec = 0,\n      .tv_nsec = millisec * 1000000L\n   };\n   while (nanosleep(&req, &req) == -1)\n      continue;\n   Platform_gettime_realtime(&host->realtime, &host->realtimeMs);\n}\n\nstatic void setCommFilter(State* state, char** commFilter) {\n   Table* table = state->host->activeTable;\n   IncSet* inc = state->mainPanel->inc;\n\n   IncSet_setFilter(inc, *commFilter);\n   table->incFilter = IncSet_filter(inc);\n\n   free(*commFilter);\n   *commFilter = NULL;\n}\n\nint CommandLine_run(int argc, char** argv) {\n\n   /* initialize locale */\n   const char* lc_ctype;\n   if ((lc_ctype = getenv(\"LC_CTYPE\")) || (lc_ctype = getenv(\"LC_ALL\")))\n      setlocale(LC_CTYPE, lc_ctype);\n   else\n      setlocale(LC_CTYPE, \"\");\n\n   CommandLineStatus status = STATUS_OK;\n   CommandLineSettings flags = { 0 };\n\n   if ((status = parseArguments(argc, argv, &flags)) != STATUS_OK)\n      return status != STATUS_OK_EXIT ? 1 : 0;\n\n   if (flags.readonly)\n      Settings_enableReadonly();\n\n   if (!Platform_init())\n      return 1;\n\n   UsersTable* ut = UsersTable_new();\n   Hashtable* dm = DynamicMeters_new();\n   Hashtable* dc = DynamicColumns_new();\n   Hashtable* ds = DynamicScreens_new();\n\n   Machine* host = Machine_new(ut, flags.userId);\n   ProcessTable* pt = ProcessTable_new(host, flags.pidMatchList);\n   Settings* settings = Settings_new(host, dm, dc, ds);\n   Machine_populateTablesFromSettings(host, settings, &pt->super);\n\n   Header* header = Header_new(host, 2);\n   Header_populateFromSettings(header);\n\n   if (flags.delay != -1)\n      settings->delay = flags.delay;\n   if (!flags.useColors)\n      settings->colorScheme = COLORSCHEME_MONOCHROME;\n#ifdef HAVE_GETMOUSE\n   if (!flags.enableMouse)\n      settings->enableMouse = false;\n#endif\n   if (flags.treeView)\n      settings->ss->treeView = true;\n   if (flags.highlightChanges)\n      settings->highlightChanges = true;\n   if (flags.highlightDelaySecs != -1)\n      settings->highlightDelaySecs = flags.highlightDelaySecs;\n   if (flags.sortKey > 0) {\n      // -t -s <key> means \"tree sorted by key\"\n      // -s <key> means \"list sorted by key\" (previous existing behavior)\n      if (!flags.treeView) {\n         settings->ss->treeView = false;\n      }\n      ScreenSettings_setSortKey(settings->ss, flags.sortKey);\n   }\n\n   host->iterationsRemaining = flags.iterationsRemaining;\n   CRT_init(settings, flags.allowUnicode, flags.iterationsRemaining != -1);\n\n   MainPanel* panel = MainPanel_new();\n   Machine_setTablesPanel(host, (Panel*) panel);\n\n   MainPanel_updateLabels(panel, settings->ss->treeView, flags.commFilter);\n\n   State state = {\n      .host = host,\n      .mainPanel = panel,\n      .header = header,\n      .pauseUpdate = false,\n      .hideSelection = false,\n      .hideMeters = false,\n   };\n\n   MainPanel_setState(panel, &state);\n   if (flags.commFilter)\n      setCommFilter(&state, &(flags.commFilter));\n\n   ScreenManager* scr = ScreenManager_new(header, host, &state, true);\n   ScreenManager_add(scr, (Panel*) panel, -1);\n\n   Machine_scan(host);\n   Machine_scanTables(host);\n   CommandLine_delay(host, 75);\n   Machine_scan(host);\n   Machine_scanTables(host);\n\n   if (settings->ss->allBranchesCollapsed)\n      Table_collapseAllBranches(&pt->super);\n\n   ScreenManager_run(scr, NULL, NULL, NULL);\n\n   Platform_done();\n\n   CRT_done();\n\n   if (settings->changed) {\n#ifndef NDEBUG\n      if (!String_eq(settings->initialFilename, settings->filename))\n         fprintf(stderr, \"Configuration %s was resolved to %s\\n\", settings->initialFilename, settings->filename);\n#endif /* NDEBUG */\n      int r = Settings_write(settings, false);\n      if (r < 0)\n         fprintf(stderr, \"Can not save configuration to %s: %s\\n\", settings->filename, strerror(-r));\n   }\n\n   Header_delete(header);\n   Machine_delete(host);\n\n   ScreenManager_delete(scr);\n   MetersPanel_cleanup();\n\n   UsersTable_delete(ut);\n\n   if (flags.pidMatchList)\n      Hashtable_delete(flags.pidMatchList);\n\n   CRT_resetSignalHandlers();\n\n   /* Delete these last, since they can get accessed in the crash handler */\n   Settings_delete(settings);\n   DynamicColumns_delete(dc);\n   DynamicMeters_delete(dm);\n   DynamicScreens_delete(ds);\n\n   return 0;\n}\n"
        },
        {
          "name": "CommandLine.h",
          "type": "blob",
          "size": 0.4033203125,
          "content": "#ifndef HEADER_CommandLine\n#define HEADER_CommandLine\n/*\nhtop - CommandLine.h\n(C) 2004-2011 Hisham H. Muhammad\n(C) 2020-2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\ntypedef enum {\n   STATUS_OK,\n   STATUS_ERROR_EXIT,\n   STATUS_OK_EXIT\n} CommandLineStatus;\n\nextern const char* program;\n\nint CommandLine_run(int argc, char** argv);\n\n#endif\n"
        },
        {
          "name": "CommandScreen.c",
          "type": "blob",
          "size": 1.9150390625,
          "content": "/*\nhtop - CommandScreen.c\n(C) 2017,2020 ryenus\n(C) 2020,2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"CommandScreen.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"Macros.h\"\n#include \"Panel.h\"\n#include \"ProvideCurses.h\"\n\n\nstatic void CommandScreen_scan(InfoScreen* this) {\n   Panel* panel = this->display;\n   int idx = MAXIMUM(Panel_getSelectedIndex(panel), 0);\n   Panel_prune(panel);\n\n   const char* p = Process_getCommand(this->process);\n   char line[COLS + 1];\n   int line_offset = 0, last_spc = -1, len;\n   for (; *p != '\\0'; p++, line_offset++) {\n      assert(line_offset >= 0 && (size_t)line_offset < sizeof(line));\n      line[line_offset] = *p;\n      if (*p == ' ') {\n         last_spc = line_offset;\n      }\n\n      if (line_offset == COLS) {\n         len = (last_spc == -1) ? line_offset : last_spc;\n         line[len] = '\\0';\n         InfoScreen_addLine(this, line);\n\n         line_offset -= len;\n         last_spc = -1;\n         memcpy(line, p - line_offset, line_offset + 1);\n      }\n   }\n\n   if (line_offset > 0) {\n      line[line_offset] = '\\0';\n      InfoScreen_addLine(this, line);\n   }\n\n   Panel_setSelected(panel, idx);\n}\n\nstatic void CommandScreen_draw(InfoScreen* this) {\n   InfoScreen_drawTitled(this, \"Command of process %d - %s\", Process_getPid(this->process), Process_getCommand(this->process));\n}\n\nconst InfoScreenClass CommandScreen_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = CommandScreen_delete\n   },\n   .scan = CommandScreen_scan,\n   .draw = CommandScreen_draw\n};\n\nCommandScreen* CommandScreen_new(Process* process) {\n   CommandScreen* this = AllocThis(CommandScreen);\n   return (CommandScreen*) InfoScreen_init(&this->super, process, NULL, LINES - 2, \" \");\n}\n\nvoid CommandScreen_delete(Object* this) {\n   free(InfoScreen_done((InfoScreen*)this));\n}\n"
        },
        {
          "name": "CommandScreen.h",
          "type": "blob",
          "size": 0.513671875,
          "content": "#ifndef HEADER_CommandScreen\n#define HEADER_CommandScreen\n/*\nhtop - CommandScreen.h\n(C) 2017,2020 ryenus\n(C) 2020,2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"InfoScreen.h\"\n#include \"Object.h\"\n#include \"Process.h\"\n\n\ntypedef struct CommandScreen_ {\n   InfoScreen super;\n} CommandScreen;\n\nextern const InfoScreenClass CommandScreen_class;\n\nCommandScreen* CommandScreen_new(Process* process);\n\nvoid CommandScreen_delete(Object* this);\n\n#endif\n"
        },
        {
          "name": "Compat.c",
          "type": "blob",
          "size": 3.1220703125,
          "content": "/*\nhtop - Compat.c\n(C) 2020 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Compat.h\"\n\n#include <errno.h>\n#include <fcntl.h> // IWYU pragma: keep\n#include <limits.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h> // IWYU pragma: keep\n\n#include \"XUtils.h\" // IWYU pragma: keep\n\n\n/* GNU/Hurd does not have PATH_MAX in limits.h */\n#ifndef PATH_MAX\n# define PATH_MAX 4096\n#endif\n\n\nint Compat_faccessat(int dirfd,\n                     const char* pathname,\n                     int mode,\n                     int flags) {\n   int ret;\n\n#ifdef HAVE_FACCESSAT\n\n   // Implementation note: AT_SYMLINK_NOFOLLOW unsupported on FreeBSD, fallback to lstat in that case\n\n   errno = 0;\n\n   ret = faccessat(dirfd, pathname, mode, flags);\n   if (!ret || errno != EINVAL)\n      return ret;\n\n#endif\n\n   // Error out on unsupported configurations\n   if (dirfd != (int)AT_FDCWD || mode != F_OK) {\n      errno = EINVAL;\n      return -1;\n   }\n\n   // Fallback to stat(2)/lstat(2) depending on flags\n   struct stat sb;\n   if (flags) {\n      ret = lstat(pathname, &sb);\n   } else {\n      ret = stat(pathname, &sb);\n   }\n\n   return ret;\n}\n\nint Compat_fstatat(int dirfd,\n                   const char* dirpath,\n                   const char* pathname,\n                   struct stat* statbuf,\n                   int flags) {\n\n#ifdef HAVE_FSTATAT\n\n   (void)dirpath;\n\n   return fstatat(dirfd, pathname, statbuf, flags);\n\n#else\n\n   (void)dirfd;\n\n   char path[4096];\n   xSnprintf(path, sizeof(path), \"%s/%s\", dirpath, pathname);\n\n   if (flags & AT_SYMLINK_NOFOLLOW)\n      return lstat(path, statbuf);\n\n   return stat(path, statbuf);\n\n#endif\n}\n\n#ifndef HAVE_OPENAT\n\nint Compat_openat(const char* dirpath,\n                  const char* pathname,\n                  int flags) {\n\n   char path[4096];\n   xSnprintf(path, sizeof(path), \"%s/%s\", dirpath, pathname);\n\n   return open(path, flags);\n}\n\n#endif /* !HAVE_OPENAT */\n\nssize_t Compat_readlinkat(int dirfd,\n                          const char* dirpath,\n                          const char* pathname,\n                          char* buf,\n                          size_t bufsize) {\n\n#ifdef HAVE_READLINKAT\n\n   (void)dirpath;\n\n   return readlinkat(dirfd, pathname, buf, bufsize);\n\n#else\n\n   (void)dirfd;\n\n   char path[4096];\n   xSnprintf(path, sizeof(path), \"%s/%s\", dirpath, pathname);\n\n   return readlink(path, buf, bufsize);\n\n#endif\n}\n\nssize_t Compat_readlink(openat_arg_t dirfd,\n                        const char* pathname,\n                        char* buf,\n                        size_t bufsize) {\n\n#ifdef HAVE_OPENAT\n\n   char fdPath[32];\n   xSnprintf(fdPath, sizeof(fdPath), \"/proc/self/fd/%d\", dirfd);\n\n   char dirPath[PATH_MAX + 1];\n   ssize_t r = readlink(fdPath, dirPath, sizeof(dirPath) - 1);\n   if (r < 0)\n      return r;\n\n   dirPath[r] = '\\0';\n\n   char linkPath[PATH_MAX + 1];\n   xSnprintf(linkPath, sizeof(linkPath), \"%s/%s\", dirPath, pathname);\n\n#else\n\n   char linkPath[PATH_MAX + 1];\n   xSnprintf(linkPath, sizeof(linkPath), \"%s/%s\", dirfd, pathname);\n\n#endif /* HAVE_OPENAT */\n\n   return readlink(linkPath, buf, bufsize);\n}\n"
        },
        {
          "name": "Compat.h",
          "type": "blob",
          "size": 2.23828125,
          "content": "#ifndef HEADER_Compat\n#define HEADER_Compat\n/*\nhtop - Compat.h\n(C) 2020 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <assert.h> // IWYU pragma: keep\n#include <fcntl.h>\n#include <stddef.h> // IWYU pragma: keep\n#include <unistd.h>\n#include <sys/stat.h> // IWYU pragma: keep\n\n\nint Compat_faccessat(int dirfd,\n                     const char* pathname,\n                     int mode,\n                     int flags);\n\nint Compat_fstatat(int dirfd,\n                   const char* dirpath,\n                   const char* pathname,\n                   struct stat* statbuf,\n                   int flags);\n\n#ifdef HAVE_OPENAT\n\ntypedef int openat_arg_t;\n\nstatic inline void Compat_openatArgClose(openat_arg_t dirfd) {\n   close(dirfd);\n}\n\nstatic inline int Compat_openat(openat_arg_t dirfd, const char* pathname, int flags) {\n   return openat(dirfd, pathname, flags);\n}\n\n#else /* HAVE_OPENAT */\n\ntypedef const char* openat_arg_t;\n\nstatic inline void Compat_openatArgClose(openat_arg_t dirpath) {\n   (void)dirpath;\n}\n\nint Compat_openat(openat_arg_t dirpath, const char* pathname, int flags);\n\n#endif /* HAVE_OPENAT */\n\nssize_t Compat_readlinkat(int dirfd,\n                          const char* dirpath,\n                          const char* pathname,\n                          char* buf,\n                          size_t bufsize);\n\nssize_t Compat_readlink(openat_arg_t dirfd,\n                        const char* pathname,\n                        char* buf,\n                        size_t bufsize);\n\n/*\n * static_assert() hack for pre-C11\n * TODO: drop after moving to -std=c11 or newer\n */\n\n/* C11 guarantees _Static_assert is a keyword */\n#if (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) < 201112L\n# if !defined(_Static_assert)\n#  define _Static_assert(expr, msg)                                    \\\n   extern int (*__Static_assert_function (void))                       \\\n      [!!sizeof (struct { int __error_if_negative: (expr) ? 2 : -1; })]\n# endif\n#endif\n\n/* C23 guarantees static_assert is a keyword or a macro */\n#if (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) < 202311L\n# if !defined(static_assert)\n#  define static_assert(expr, msg) _Static_assert(expr, msg)\n# endif\n#endif\n\n#endif /* HEADER_Compat */\n"
        },
        {
          "name": "DateMeter.c",
          "type": "blob",
          "size": 1.0263671875,
          "content": "/*\nhtop - DateMeter.c\n(C) 2004-2020 Hisham H. Muhammad, Michael SchÃ¶nitzer\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"DateMeter.h\"\n\n#include <time.h>\n#include <sys/time.h>\n\n#include \"CRT.h\"\n#include \"Machine.h\"\n#include \"Object.h\"\n\n\nstatic const int DateMeter_attributes[] = {\n   DATE\n};\n\nstatic void DateMeter_updateValues(Meter* this) {\n   const Machine* host = this->host;\n\n   struct tm result;\n   const struct tm* lt = localtime_r(&host->realtime.tv_sec, &result);\n   strftime(this->txtBuffer, sizeof(this->txtBuffer), \"%F\", lt);\n}\n\nconst MeterClass DateMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = DateMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = (1 << TEXT_METERMODE) | (1 << LED_METERMODE),\n   .maxItems = 0,\n   .total = 0.0,\n   .attributes = DateMeter_attributes,\n   .name = \"Date\",\n   .uiName = \"Date\",\n   .caption = \"Date: \",\n};\n"
        },
        {
          "name": "DateMeter.h",
          "type": "blob",
          "size": 0.2705078125,
          "content": "#ifndef HEADER_DateMeter\n#define HEADER_DateMeter\n/*\nhtop - DateMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n\nextern const MeterClass DateMeter_class;\n\n#endif\n"
        },
        {
          "name": "DateTimeMeter.c",
          "type": "blob",
          "size": 1.0859375,
          "content": "/*\nhtop - DateTimeMeter.c\n(C) 2004-2020 Hisham H. Muhammad, Michael SchÃ¶nitzer\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"DateTimeMeter.h\"\n\n#include <time.h>\n#include <sys/time.h>\n\n#include \"CRT.h\"\n#include \"Machine.h\"\n#include \"Object.h\"\n\n\nstatic const int DateTimeMeter_attributes[] = {\n   DATETIME\n};\n\nstatic void DateTimeMeter_updateValues(Meter* this) {\n   const Machine* host = this->host;\n\n   struct tm result;\n   const struct tm* lt = localtime_r(&host->realtime.tv_sec, &result);\n   strftime(this->txtBuffer, sizeof(this->txtBuffer), \"%F %H:%M:%S\", lt);\n}\n\nconst MeterClass DateTimeMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = DateTimeMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = (1 << TEXT_METERMODE) | (1 << LED_METERMODE),\n   .maxItems = 0,\n   .total = 0.0,\n   .attributes = DateTimeMeter_attributes,\n   .name = \"DateTime\",\n   .uiName = \"Date and Time\",\n   .caption = \"Date & Time: \",\n};\n"
        },
        {
          "name": "DateTimeMeter.h",
          "type": "blob",
          "size": 0.2861328125,
          "content": "#ifndef HEADER_DateTimeMeter\n#define HEADER_DateTimeMeter\n/*\nhtop - DateTimeMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n\nextern const MeterClass DateTimeMeter_class;\n\n#endif\n"
        },
        {
          "name": "DiskIOMeter.c",
          "type": "blob",
          "size": 5.25,
          "content": "/*\nhtop - DiskIOMeter.c\n(C) 2020 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"DiskIOMeter.h\"\n\n#include <stdbool.h>\n\n#include \"CRT.h\"\n#include \"Machine.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"RichString.h\"\n#include \"Row.h\"\n#include \"XUtils.h\"\n\n\nstatic const int DiskIOMeter_attributes[] = {\n   METER_VALUE_NOTICE,\n   METER_VALUE_IOREAD,\n   METER_VALUE_IOWRITE,\n};\n\nstatic MeterRateStatus status = RATESTATUS_INIT;\nstatic char cached_read_diff_str[6];\nstatic char cached_write_diff_str[6];\nstatic double cached_utilisation_diff;\nstatic double cached_utilisation_norm;\n\nstatic void DiskIOMeter_updateValues(Meter* this) {\n   const Machine* host = this->host;\n\n   static uint64_t cached_last_update;\n   uint64_t passedTimeInMs = host->realtimeMs - cached_last_update;\n   bool hasNewData = false;\n   DiskIOData data;\n\n   /* update only every 500ms to have a sane span for rate calculation */\n   if (passedTimeInMs > 500) {\n      hasNewData = Platform_getDiskIO(&data);\n      if (!hasNewData) {\n         status = RATESTATUS_NODATA;\n      } else if (cached_last_update == 0) {\n         status = RATESTATUS_INIT;\n      } else if (passedTimeInMs > 30000) {\n         status = RATESTATUS_STALE;\n      } else {\n         status = RATESTATUS_DATA;\n      }\n\n      cached_last_update = host->realtimeMs;\n   }\n\n   if (hasNewData) {\n      static uint64_t cached_read_total;\n      static uint64_t cached_write_total;\n      static uint64_t cached_msTimeSpend_total;\n\n      if (status != RATESTATUS_INIT) {\n         uint64_t diff;\n\n         if (data.totalBytesRead > cached_read_total) {\n            diff = data.totalBytesRead - cached_read_total;\n            diff = (1000 * diff) / passedTimeInMs; /* convert to B/s */\n            diff /= ONE_K; /* convert to KiB/s */\n         } else {\n            diff = 0;\n         }\n         Meter_humanUnit(cached_read_diff_str, diff, sizeof(cached_read_diff_str));\n\n         if (data.totalBytesWritten > cached_write_total) {\n            diff = data.totalBytesWritten - cached_write_total;\n            diff = (1000 * diff) / passedTimeInMs; /* convert to B/s */\n            diff /= ONE_K; /* convert to KiB/s */\n         } else {\n            diff = 0;\n         }\n         Meter_humanUnit(cached_write_diff_str, diff, sizeof(cached_write_diff_str));\n\n         cached_utilisation_diff = 0.0;\n         cached_utilisation_norm = 0.0;\n         if (data.totalMsTimeSpend > cached_msTimeSpend_total) {\n            diff = data.totalMsTimeSpend - cached_msTimeSpend_total;\n            cached_utilisation_diff = 100.0 * (double)diff / passedTimeInMs;\n            if (data.numDisks > 0) {\n               cached_utilisation_norm = (double)diff / (passedTimeInMs * data.numDisks);\n               cached_utilisation_norm = MINIMUM(cached_utilisation_norm, 1.0);\n            }\n         }\n      }\n\n      cached_read_total = data.totalBytesRead;\n      cached_write_total = data.totalBytesWritten;\n      cached_msTimeSpend_total = data.totalMsTimeSpend;\n   }\n\n   this->values[0] = cached_utilisation_norm;\n\n   if (status == RATESTATUS_NODATA) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"no data\");\n      return;\n   }\n   if (status == RATESTATUS_INIT) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"init\");\n      return;\n   }\n   if (status == RATESTATUS_STALE) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"stale\");\n      return;\n   }\n\n   xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"r:%siB/s w:%siB/s %.1f%%\", cached_read_diff_str, cached_write_diff_str, cached_utilisation_diff);\n}\n\nstatic void DiskIOMeter_display(ATTR_UNUSED const Object* cast, RichString* out) {\n   switch (status) {\n      case RATESTATUS_NODATA:\n         RichString_writeAscii(out, CRT_colors[METER_VALUE_ERROR], \"no data\");\n         return;\n      case RATESTATUS_INIT:\n         RichString_writeAscii(out, CRT_colors[METER_VALUE], \"initializing...\");\n         return;\n      case RATESTATUS_STALE:\n         RichString_writeAscii(out, CRT_colors[METER_VALUE_WARN], \"stale data\");\n         return;\n      case RATESTATUS_DATA:\n         break;\n   }\n\n   char buffer[16];\n\n   int color = cached_utilisation_diff > 40.0 ? METER_VALUE_NOTICE : METER_VALUE;\n   int len = xSnprintf(buffer, sizeof(buffer), \"%.1f%%\", cached_utilisation_diff);\n   RichString_appendnAscii(out, CRT_colors[color], buffer, len);\n\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \" read: \");\n   RichString_appendAscii(out, CRT_colors[METER_VALUE_IOREAD], cached_read_diff_str);\n   RichString_appendAscii(out, CRT_colors[METER_VALUE_IOREAD], \"iB/s\");\n\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \" write: \");\n   RichString_appendAscii(out, CRT_colors[METER_VALUE_IOWRITE], cached_write_diff_str);\n   RichString_appendAscii(out, CRT_colors[METER_VALUE_IOWRITE], \"iB/s\");\n}\n\nconst MeterClass DiskIOMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = DiskIOMeter_display\n   },\n   .updateValues = DiskIOMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = 1,\n   .total = 1.0,\n   .attributes = DiskIOMeter_attributes,\n   .name = \"DiskIO\",\n   .uiName = \"Disk IO\",\n   .caption = \"Disk IO: \"\n};\n"
        },
        {
          "name": "DiskIOMeter.h",
          "type": "blob",
          "size": 0.46484375,
          "content": "#ifndef HEADER_DiskIOMeter\n#define HEADER_DiskIOMeter\n/*\nhtop - DiskIOMeter.h\n(C) 2020 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdint.h>\n\n#include \"Meter.h\"\n\n\ntypedef struct DiskIOData_ {\n   uint64_t totalBytesRead;\n   uint64_t totalBytesWritten;\n   uint64_t totalMsTimeSpend;\n   uint64_t numDisks;\n} DiskIOData;\n\nextern const MeterClass DiskIOMeter_class;\n\n#endif /* HEADER_DiskIOMeter */\n"
        },
        {
          "name": "DisplayOptionsPanel.c",
          "type": "blob",
          "size": 7.7919921875,
          "content": "/*\nhtop - DisplayOptionsPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"DisplayOptionsPanel.h\"\n\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Header.h\"\n#include \"Object.h\"\n#include \"OptionItem.h\"\n#include \"ProvideCurses.h\"\n#include \"ScreensPanel.h\"\n\n\nstatic const char* const DisplayOptionsFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nstatic void DisplayOptionsPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   DisplayOptionsPanel* this = (DisplayOptionsPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic HandlerResult DisplayOptionsPanel_eventHandler(Panel* super, int ch) {\n   DisplayOptionsPanel* this = (DisplayOptionsPanel*) super;\n\n   HandlerResult result = IGNORED;\n   OptionItem* selected = (OptionItem*) Panel_getSelected(super);\n\n   switch (ch) {\n      case '\\n':\n      case '\\r':\n      case KEY_ENTER:\n      case KEY_MOUSE:\n      case KEY_RECLICK:\n      case ' ':\n         switch (OptionItem_kind(selected)) {\n            case OPTION_ITEM_TEXT:\n               break;\n            case OPTION_ITEM_CHECK:\n               CheckItem_toggle((CheckItem*)selected);\n               result = HANDLED;\n               break;\n            case OPTION_ITEM_NUMBER:\n               NumberItem_toggle((NumberItem*)selected);\n               result = HANDLED;\n               break;\n         }\n         break;\n      case '-':\n         if (OptionItem_kind(selected) == OPTION_ITEM_NUMBER) {\n            NumberItem_decrease((NumberItem*)selected);\n            result = HANDLED;\n         }\n         break;\n      case '+':\n         if (OptionItem_kind(selected) == OPTION_ITEM_NUMBER) {\n            NumberItem_increase((NumberItem*)selected);\n            result = HANDLED;\n         }\n         break;\n   }\n\n   if (result == HANDLED) {\n      this->settings->changed = true;\n      this->settings->lastUpdate++;\n      CRT_updateDelay();\n      Header* header = this->scr->header;\n      Header_calculateHeight(header);\n      Header_reinit(header);\n      Header_updateData(header);\n      Header_draw(header);\n      ScreenManager_resize(this->scr);\n   }\n\n   return result;\n}\n\nconst PanelClass DisplayOptionsPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = DisplayOptionsPanel_delete\n   },\n   .eventHandler = DisplayOptionsPanel_eventHandler\n};\n\nDisplayOptionsPanel* DisplayOptionsPanel_new(Settings* settings, ScreenManager* scr) {\n   DisplayOptionsPanel* this = AllocThis(DisplayOptionsPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(DisplayOptionsFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(OptionItem), true, fuBar);\n\n   this->settings = settings;\n   this->scr = scr;\n\n   Panel_setHeader(super, \"Display options\");\n\n   #define TABMSG \"For current screen tab: \\0\"\n   char tabheader[sizeof(TABMSG) + SCREEN_NAME_LEN + 1] = TABMSG;\n   strncat(tabheader, settings->ss->heading, SCREEN_NAME_LEN);\n   Panel_add(super, (Object*) TextItem_new(tabheader));\n   #undef TABMSG\n\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Tree view\", &(settings->ss->treeView)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"- Tree view is always sorted by PID (htop 2 behavior)\", &(settings->ss->treeViewAlwaysByPID)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"- Tree view is collapsed by default\", &(settings->ss->allBranchesCollapsed)));\n   Panel_add(super, (Object*) TextItem_new(\"Global options:\"));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Show tabs for screens\", &(settings->screenTabs)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Shadow other users' processes\", &(settings->shadowOtherUsers)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Hide kernel threads\", &(settings->hideKernelThreads)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Hide userland process threads\", &(settings->hideUserlandThreads)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Hide processes running in containers\", &(settings->hideRunningInContainer)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Display threads in a different color\", &(settings->highlightThreads)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Show custom thread names\", &(settings->showThreadNames)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Show program path\", &(settings->showProgramPath)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Highlight program \\\"basename\\\"\", &(settings->highlightBaseName)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Highlight out-dated/removed programs (red) / libraries (yellow)\", &(settings->highlightDeletedExe)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Shadow distribution path prefixes\", &(settings->shadowDistPathPrefix)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Merge exe, comm and cmdline in Command\", &(settings->showMergedCommand)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"- Try to find comm in cmdline (when Command is merged)\", &(settings->findCommInCmdline)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"- Try to strip exe from cmdline (when Command is merged)\", &(settings->stripExeFromCmdline)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Highlight large numbers in memory counters\", &(settings->highlightMegabytes)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Leave a margin around header\", &(settings->headerMargin)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Detailed CPU time (System/IO-Wait/Hard-IRQ/Soft-IRQ/Steal/Guest)\", &(settings->detailedCPUTime)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Count CPUs from 1 instead of 0\", &(settings->countCPUsFromOne)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Update process names on every refresh\", &(settings->updateProcessNames)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Add guest time in CPU meter percentage\", &(settings->accountGuestInCPUMeter)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Also show CPU percentage numerically\", &(settings->showCPUUsage)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Also show CPU frequency\", &(settings->showCPUFrequency)));\n   #ifdef BUILD_WITH_CPU_TEMP\n   Panel_add(super, (Object*) CheckItem_newByRef(\n   #if defined(HTOP_LINUX)\n                                                 \"Also show CPU temperature (requires libsensors)\",\n   #elif defined(HTOP_FREEBSD)\n                                                 \"Also show CPU temperature\",\n   #else\n   #error Unknown temperature implementation!\n   #endif\n                                                 &(settings->showCPUTemperature)));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"- Show temperature in degree Fahrenheit instead of Celsius\", &(settings->degreeFahrenheit)));\n   #endif\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Show cached memory in graph and bar modes\", &(settings->showCachedMemory)));\n   #ifdef HAVE_GETMOUSE\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Enable the mouse\", &(settings->enableMouse)));\n   #endif\n   Panel_add(super, (Object*) NumberItem_newByRef(\"Update interval (in seconds)\", &(settings->delay), -1, 1, 255));\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Highlight new and old processes\", &(settings->highlightChanges)));\n   Panel_add(super, (Object*) NumberItem_newByRef(\"- Highlight time (in seconds)\", &(settings->highlightDelaySecs), 0, 1, 24 * 60 * 60));\n   Panel_add(super, (Object*) NumberItem_newByRef(\"Hide main function bar (0 - off, 1 - on ESC until next input, 2 - permanently)\", &(settings->hideFunctionBar), 0, 0, 2));\n   #ifdef HAVE_LIBHWLOC\n   Panel_add(super, (Object*) CheckItem_newByRef(\"Show topology when selecting affinity by default\", &(settings->topologyAffinity)));\n   #endif\n   return this;\n}\n"
        },
        {
          "name": "DisplayOptionsPanel.h",
          "type": "blob",
          "size": 0.564453125,
          "content": "#ifndef HEADER_DisplayOptionsPanel\n#define HEADER_DisplayOptionsPanel\n/*\nhtop - DisplayOptionsPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n#include \"ScreenManager.h\"\n#include \"Settings.h\"\n\n\ntypedef struct DisplayOptionsPanel_ {\n   Panel super;\n\n   Settings* settings;\n   ScreenManager* scr;\n} DisplayOptionsPanel;\n\nextern const PanelClass DisplayOptionsPanel_class;\n\nDisplayOptionsPanel* DisplayOptionsPanel_new(Settings* settings, ScreenManager* scr);\n\n#endif\n"
        },
        {
          "name": "DynamicColumn.c",
          "type": "blob",
          "size": 1.916015625,
          "content": "/*\nhtop - DynamicColumn.c\n(C) 2021 Sohaib Mohammed\n(C) 2021 htop dev team\n(C) 2021 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"DynamicColumn.h\"\n\n#include <stddef.h>\n#include <stdlib.h>\n\n#include \"Platform.h\"\n#include \"RichString.h\"\n#include \"XUtils.h\"\n\n\nHashtable* DynamicColumns_new(void) {\n   Hashtable* dynamics = Platform_dynamicColumns();\n   if (!dynamics)\n      dynamics = Hashtable_new(0, true);\n   return dynamics;\n}\n\nvoid DynamicColumns_delete(Hashtable* dynamics) {\n   if (dynamics) {\n      Platform_dynamicColumnsDone(dynamics);\n      Hashtable_delete(dynamics);\n   }\n}\n\nconst char* DynamicColumn_name(unsigned int key) {\n   return Platform_dynamicColumnName(key);\n}\n\nvoid DynamicColumn_done(DynamicColumn* this) {\n   free(this->heading);\n   free(this->caption);\n   free(this->description);\n}\n\ntypedef struct {\n   const char* name;\n   const DynamicColumn* data;\n   unsigned int key;\n} DynamicIterator;\n\nstatic void DynamicColumn_compare(ht_key_t key, void* value, void* data) {\n   const DynamicColumn* column = (const DynamicColumn*)value;\n   DynamicIterator* iter = (DynamicIterator*)data;\n   if (String_eq(iter->name, column->name)) {\n      iter->data = column;\n      iter->key = key;\n   }\n}\n\nconst DynamicColumn* DynamicColumn_search(Hashtable* dynamics, const char* name, unsigned int* key) {\n   DynamicIterator iter = { .key = 0, .data = NULL, .name = name };\n   if (dynamics)\n      Hashtable_foreach(dynamics, DynamicColumn_compare, &iter);\n   if (key)\n      *key = iter.key;\n   return iter.data;\n}\n\nconst DynamicColumn* DynamicColumn_lookup(Hashtable* dynamics, unsigned int key) {\n   return (const DynamicColumn*) Hashtable_get(dynamics, key);\n}\n\nbool DynamicColumn_writeField(const Process* proc, RichString* str, unsigned int key) {\n   return Platform_dynamicColumnWriteField(proc, str, key);\n}\n"
        },
        {
          "name": "DynamicColumn.h",
          "type": "blob",
          "size": 1.36328125,
          "content": "#ifndef HEADER_DynamicColumn\n#define HEADER_DynamicColumn\n/*\nhtop - DynamicColumn.h\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Hashtable.h\"\n#include \"Process.h\"\n#include \"RichString.h\"\n#include \"Table.h\"\n\n\n#define DYNAMIC_MAX_COLUMN_WIDTH 64\n#define DYNAMIC_DEFAULT_COLUMN_WIDTH -5\n\ntypedef struct DynamicColumn_ {\n   char name[32];           /* unique, internal-only name */\n   char* heading;           /* displayed in main screen */\n   char* caption;           /* displayed in setup menu (short name) */\n   char* description;       /* displayed in setup menu (detail) */\n   int width;               /* display width +/- for value alignment */\n   bool enabled;            /* false == ignore this column (until enabled) */\n   Table* table;            /* pointer to DynamicScreen or ProcessTable */\n} DynamicColumn;\n\nHashtable* DynamicColumns_new(void);\n\nvoid DynamicColumns_delete(Hashtable* dynamics);\n\nconst char* DynamicColumn_name(unsigned int key);\n\nvoid DynamicColumn_done(DynamicColumn* this);\n\nconst DynamicColumn* DynamicColumn_lookup(Hashtable* dynamics, unsigned int key);\n\nconst DynamicColumn* DynamicColumn_search(Hashtable* dynamics, const char* name, unsigned int* key);\n\nbool DynamicColumn_writeField(const Process* proc, RichString* str, unsigned int key);\n\n#endif\n"
        },
        {
          "name": "DynamicMeter.c",
          "type": "blob",
          "size": 3.521484375,
          "content": "/*\nhtop - DynamicMeter.c\n(C) 2021 htop dev team\n(C) 2021 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"DynamicMeter.h\"\n\n#include <assert.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"Machine.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"RichString.h\"\n#include \"Settings.h\"\n#include \"XUtils.h\"\n\n\nstatic const int DynamicMeter_attributes[] = {\n   DYNAMIC_GRAY,\n   DYNAMIC_DARKGRAY,\n   DYNAMIC_RED,\n   DYNAMIC_GREEN,\n   DYNAMIC_BLUE,\n   DYNAMIC_CYAN,\n   DYNAMIC_MAGENTA,\n   DYNAMIC_YELLOW,\n   DYNAMIC_WHITE\n};\n\nHashtable* DynamicMeters_new(void) {\n   return Platform_dynamicMeters();\n}\n\nvoid DynamicMeters_delete(Hashtable* dynamics) {\n   if (dynamics) {\n      Platform_dynamicMetersDone(dynamics);\n      Hashtable_delete(dynamics);\n   }\n}\n\ntypedef struct {\n   unsigned int key;\n   const char* name;\n   bool found;\n} DynamicIterator;\n\nstatic void DynamicMeter_compare(ht_key_t key, void* value, void* data) {\n   const DynamicMeter* meter = (const DynamicMeter*)value;\n   DynamicIterator* iter = (DynamicIterator*)data;\n   if (String_eq(iter->name, meter->name)) {\n      iter->found = true;\n      iter->key = key;\n   }\n}\n\nbool DynamicMeter_search(Hashtable* dynamics, const char* name, unsigned int* key) {\n   DynamicIterator iter = { .key = 0, .name = name, .found = false };\n   if (dynamics)\n      Hashtable_foreach(dynamics, DynamicMeter_compare, &iter);\n   if (key)\n      *key = iter.key;\n   return iter.found;\n}\n\nconst char* DynamicMeter_lookup(Hashtable* dynamics, unsigned int key) {\n   const DynamicMeter* meter = Hashtable_get(dynamics, key);\n   return meter ? meter->name : NULL;\n}\n\nstatic void DynamicMeter_init(Meter* meter) {\n   Platform_dynamicMeterInit(meter);\n}\n\nstatic void DynamicMeter_updateValues(Meter* meter) {\n   Platform_dynamicMeterUpdateValues(meter);\n}\n\nstatic void DynamicMeter_display(const Object* cast, RichString* out) {\n   const Meter* meter = (const Meter*)cast;\n   Platform_dynamicMeterDisplay(meter, out);\n}\n\nstatic const char* DynamicMeter_getCaption(const Meter* this) {\n   const Settings* settings = this->host->settings;\n   const DynamicMeter* meter = Hashtable_get(settings->dynamicMeters, this->param);\n   if (meter)\n      return meter->caption ? meter->caption : meter->name;\n   return this->caption;\n}\n\nstatic void DynamicMeter_getUiName(const Meter* this, char* name, size_t length) {\n   assert(length > 0);\n\n   const Settings* settings = this->host->settings;\n   const DynamicMeter* meter = Hashtable_get(settings->dynamicMeters, this->param);\n   if (meter) {\n      const char* uiName = meter->caption;\n      if (uiName) {\n         size_t uiNameLen = strlen(uiName);\n         if (uiNameLen > 2 && uiName[uiNameLen - 2] == ':')\n            uiNameLen -= 2;\n\n         String_safeStrncpy(name, uiName, MINIMUM(length, uiNameLen + 1));\n      } else {\n         String_safeStrncpy(name, meter->name, length);\n      }\n   }\n}\n\nconst MeterClass DynamicMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = DynamicMeter_display\n   },\n   .init = DynamicMeter_init,\n   .updateValues = DynamicMeter_updateValues,\n   .getCaption = DynamicMeter_getCaption,\n   .getUiName = DynamicMeter_getUiName,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = 0,\n   .total = 100.0,\n   .attributes = DynamicMeter_attributes,\n   .name = \"Dynamic\",\n   .uiName = \"Dynamic\",\n   .caption = \"\",\n};\n"
        },
        {
          "name": "DynamicMeter.h",
          "type": "blob",
          "size": 0.783203125,
          "content": "#ifndef HEADER_DynamicMeter\n#define HEADER_DynamicMeter\n/*\nhtop - DynamicMeter.h\n(C) 2021 htop dev team\n(C) 2021 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Hashtable.h\"\n#include \"Meter.h\"\n\n\ntypedef struct DynamicMeter_ {\n   char name[32];  /* unique name, cannot contain spaces */\n   char* caption;\n   char* description;\n   unsigned int type;\n   double maximum;\n} DynamicMeter;\n\nHashtable* DynamicMeters_new(void);\n\nvoid DynamicMeters_delete(Hashtable* dynamics);\n\nconst char* DynamicMeter_lookup(Hashtable* dynamics, unsigned int key);\n\nbool DynamicMeter_search(Hashtable* dynamics, const char* name, unsigned int* key);\n\nextern const MeterClass DynamicMeter_class;\n\n#endif\n"
        },
        {
          "name": "DynamicScreen.c",
          "type": "blob",
          "size": 1.5888671875,
          "content": "/*\nhtop - DynamicScreen.c\n(C) 2022 Sohaib Mohammed\n(C) 2022-2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"DynamicScreen.h\"\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdlib.h>\n\n#include \"Hashtable.h\"\n#include \"Platform.h\"\n#include \"XUtils.h\"\n\n\nHashtable* DynamicScreens_new(void) {\n   return Platform_dynamicScreens();\n}\n\nvoid DynamicScreens_delete(Hashtable* screens) {\n   if (screens) {\n      Platform_dynamicScreensDone(screens);\n      Hashtable_delete(screens);\n   }\n}\n\nvoid DynamicScreen_done(DynamicScreen* this) {\n   free(this->caption);\n   free(this->fields);\n   free(this->heading);\n   free(this->sortKey);\n   free(this->columnKeys);\n}\n\ntypedef struct {\n   ht_key_t key;\n   const char* name;\n   bool found;\n} DynamicIterator;\n\nstatic void DynamicScreen_compare(ht_key_t key, void* value, void* data) {\n   const DynamicScreen* screen = (const DynamicScreen*)value;\n   DynamicIterator* iter = (DynamicIterator*)data;\n   if (String_eq(iter->name, screen->name)) {\n      iter->found = true;\n      iter->key = key;\n   }\n}\n\nbool DynamicScreen_search(Hashtable* screens, const char* name, ht_key_t* key) {\n   DynamicIterator iter = { .key = 0, .name = name, .found = false };\n   if (screens)\n      Hashtable_foreach(screens, DynamicScreen_compare, &iter);\n   if (key)\n      *key = iter.key;\n   return iter.found;\n}\n\nconst char* DynamicScreen_lookup(Hashtable* screens, ht_key_t key) {\n   const DynamicScreen* screen = Hashtable_get(screens, key);\n   return screen ? screen->name : NULL;\n}\n"
        },
        {
          "name": "DynamicScreen.h",
          "type": "blob",
          "size": 0.9306640625,
          "content": "#ifndef HEADER_DynamicScreen\n#define HEADER_DynamicScreen\n/*\nhtop - DynamicColumn.h\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Hashtable.h\"\n#include \"Panel.h\"\n\n\ntypedef struct DynamicScreen_ {\n   char name[32];  /* unique name cannot contain any spaces */\n   char* heading;  /* user-settable more readable name */\n   char* caption;  /* explanatory text for screen */\n   char* fields;\n   char* sortKey;\n   char* columnKeys;\n   int direction;\n} DynamicScreen;\n\nHashtable* DynamicScreens_new(void);\n\nvoid DynamicScreens_delete(Hashtable* screens);\n\nvoid DynamicScreen_done(DynamicScreen* this);\n\nvoid DynamicScreens_addAvailableColumns(Panel* availableColumns, char* screen);\n\nconst char* DynamicScreen_lookup(Hashtable* screens, unsigned int key);\n\nbool DynamicScreen_search(Hashtable* screens, const char* name, unsigned int* key);\n\n#endif\n"
        },
        {
          "name": "EnvScreen.c",
          "type": "blob",
          "size": 1.65234375,
          "content": "/*\nhtop - EnvScreen.c\n(C) 2015,2016 Michael Klein\n(C) 2016,2017 Hisham H. Muhammad\n(C) 2020,2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"EnvScreen.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"Macros.h\"\n#include \"Panel.h\"\n#include \"Platform.h\"\n#include \"ProvideCurses.h\"\n#include \"Vector.h\"\n#include \"XUtils.h\"\n\n\nEnvScreen* EnvScreen_new(Process* process) {\n   EnvScreen* this = xMalloc(sizeof(EnvScreen));\n   Object_setClass(this, Class(EnvScreen));\n   return (EnvScreen*) InfoScreen_init(&this->super, process, NULL, LINES - 2, \" \");\n}\n\nvoid EnvScreen_delete(Object* this) {\n   free(InfoScreen_done((InfoScreen*)this));\n}\n\nstatic void EnvScreen_draw(InfoScreen* this) {\n   InfoScreen_drawTitled(this, \"Environment of process %d - %s\", Process_getPid(this->process), Process_getCommand(this->process));\n}\n\nstatic void EnvScreen_scan(InfoScreen* this) {\n   Panel* panel = this->display;\n   int idx = MAXIMUM(Panel_getSelectedIndex(panel), 0);\n\n   Panel_prune(panel);\n\n   char* env = Platform_getProcessEnv(Process_getPid(this->process));\n   if (env) {\n      for (const char* p = env; *p; p = strrchr(p, 0) + 1)\n         InfoScreen_addLine(this, p);\n      free(env);\n   }\n   else {\n      InfoScreen_addLine(this, \"Could not read process environment.\");\n   }\n\n   Vector_insertionSort(this->lines);\n   Vector_insertionSort(panel->items);\n   Panel_setSelected(panel, idx);\n}\n\nconst InfoScreenClass EnvScreen_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = EnvScreen_delete\n   },\n   .scan = EnvScreen_scan,\n   .draw = EnvScreen_draw\n};\n"
        },
        {
          "name": "EnvScreen.h",
          "type": "blob",
          "size": 0.517578125,
          "content": "#ifndef HEADER_EnvScreen\n#define HEADER_EnvScreen\n/*\nhtop - EnvScreen.h\n(C) 2015,2016 Michael Klein\n(C) 2016,2017 Hisham H. Muhammad\n(C) 2020,2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"InfoScreen.h\"\n#include \"Object.h\"\n#include \"Process.h\"\n\n\ntypedef struct EnvScreen_ {\n   InfoScreen super;\n} EnvScreen;\n\nextern const InfoScreenClass EnvScreen_class;\n\nEnvScreen* EnvScreen_new(Process* process);\n\nvoid EnvScreen_delete(Object* this);\n\n#endif\n"
        },
        {
          "name": "FileDescriptorMeter.c",
          "type": "blob",
          "size": 3.6455078125,
          "content": "/*\nhtop - FileDescriptorMeter.c\n(C) 2022 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"FileDescriptorMeter.h\"\n\n#include <math.h>\n\n#include \"CRT.h\"\n#include \"Macros.h\"\n#include \"Meter.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"RichString.h\"\n#include \"XUtils.h\"\n\n\n#define FD_EFFECTIVE_UNLIMITED(x) (!isgreaterequal((double)(1<<30), (x)))\n\nstatic const int FileDescriptorMeter_attributes[] = {\n   FILE_DESCRIPTOR_USED,\n   FILE_DESCRIPTOR_MAX\n};\n\nstatic void FileDescriptorMeter_updateValues(Meter* this) {\n   this->values[0] = 0;\n   this->values[1] = 1;\n\n   Platform_getFileDescriptors(&this->values[0], &this->values[1]);\n\n   /* only print bar for first value */\n   this->curItems = 1;\n\n   /* Use maximum value for scaling of bar mode\n    *\n    * As the plain total value can be very large compared to\n    * the actually used value, this is capped in the following way:\n    *\n    * 1. If the maximum value is below (or equal to) 1<<16, use it directly\n    * 2. If the maximum value is above, use powers of 2 starting at 1<<16 and\n    *    double it until it's larger than 16 times the used file handles\n    *    (capped at the maximum number of files)\n    * 3. If the maximum is effectively unlimited (AKA > 1<<30),\n    *    Do the same as for 2, but cap at 1<<30.\n    */\n   if (this->values[1] <= 1 << 16) {\n      this->total = this->values[1];\n   } else {\n      if (this->total < 16 * this->values[0]) {\n         for (this->total = 1 << 16; this->total < 16 * this->values[0]; this->total *= 2) {\n            if (this->total >= 1 << 30) {\n               break;\n            }\n         }\n      }\n\n      if (this->total > this->values[1]) {\n         this->total = this->values[1];\n      }\n\n      if (this->total > 1 << 30) {\n         this->total = 1 << 30;\n      }\n   }\n\n   if (!isNonnegative(this->values[0])) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"unknown/unknown\");\n   } else if (FD_EFFECTIVE_UNLIMITED(this->values[1])) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"%.0lf/unlimited\", this->values[0]);\n   } else {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"%.0lf/%.0lf\", this->values[0], this->values[1]);\n   }\n}\n\nstatic void FileDescriptorMeter_display(const Object* cast, RichString* out) {\n   const Meter* this = (const Meter*)cast;\n   char buffer[50];\n   int len;\n\n   if (!isNonnegative(this->values[0])) {\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \"unknown\");\n      return;\n   }\n\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \"used: \");\n   len = xSnprintf(buffer, sizeof(buffer), \"%.0lf\", this->values[0]);\n   RichString_appendnAscii(out, CRT_colors[FILE_DESCRIPTOR_USED], buffer, len);\n\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \" max: \");\n   if (FD_EFFECTIVE_UNLIMITED(this->values[1])) {\n      RichString_appendAscii(out, CRT_colors[FILE_DESCRIPTOR_MAX], \"unlimited\");\n   } else {\n      len = xSnprintf(buffer, sizeof(buffer), \"%.0lf\", this->values[1]);\n      RichString_appendnAscii(out, CRT_colors[FILE_DESCRIPTOR_MAX], buffer, len);\n   }\n}\n\nconst MeterClass FileDescriptorMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = FileDescriptorMeter_display,\n   },\n   .updateValues = FileDescriptorMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = 2,\n   .total = 65536.0,\n   .attributes = FileDescriptorMeter_attributes,\n   .name = \"FileDescriptors\",\n   .uiName = \"File Descriptors\",\n   .caption = \"FDs: \",\n   .description = \"Number of allocated/available file descriptors\"\n};\n"
        },
        {
          "name": "FileDescriptorMeter.h",
          "type": "blob",
          "size": 0.2998046875,
          "content": "#ifndef HEADER_FileDescriptorMeter\n#define HEADER_FileDescriptorMeter\n/*\nhtop - FileDescriptorMeter.h\n(C) 2022 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n\nextern const MeterClass FileDescriptorMeter_class;\n\n#endif\n"
        },
        {
          "name": "FunctionBar.c",
          "type": "blob",
          "size": 4.3310546875,
          "content": "/*\nhtop - FunctionBar.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"FunctionBar.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"Macros.h\"\n#include \"ProvideCurses.h\"\n#include \"XUtils.h\"\n\n\nstatic const char* const FunctionBar_FKeys[] = {\"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"F10\", NULL};\n\nstatic const char* const FunctionBar_FLabels[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", NULL};\n\nstatic int FunctionBar_FEvents[] = {KEY_F(1), KEY_F(2), KEY_F(3), KEY_F(4), KEY_F(5), KEY_F(6), KEY_F(7), KEY_F(8), KEY_F(9), KEY_F(10)};\n\nstatic const char* const FunctionBar_EnterEscKeys[] = {\"Enter\", \"Esc\", NULL};\nstatic const int FunctionBar_EnterEscEvents[] = {13, 27};\n\nstatic int currentLen = 0;\n\nFunctionBar* FunctionBar_newEnterEsc(const char* enter, const char* esc) {\n   const char* functions[FUNCTIONBAR_MAXEVENTS + 1] = {enter, esc, NULL};\n   return FunctionBar_new(functions, FunctionBar_EnterEscKeys, FunctionBar_EnterEscEvents);\n}\n\nFunctionBar* FunctionBar_new(const char* const* functions, const char* const* keys, const int* events) {\n   FunctionBar* this = xCalloc(1, sizeof(FunctionBar));\n   this->functions = xCalloc(FUNCTIONBAR_MAXEVENTS + 1, sizeof(char*));\n   if (!functions) {\n      functions = FunctionBar_FLabels;\n   }\n   for (int i = 0; i < FUNCTIONBAR_MAXEVENTS && functions[i]; i++) {\n      this->functions[i] = xStrdup(functions[i]);\n   }\n   if (keys && events) {\n      this->staticData = false;\n      this->keys.keys = xCalloc(FUNCTIONBAR_MAXEVENTS, sizeof(char*));\n      this->events = xCalloc(FUNCTIONBAR_MAXEVENTS, sizeof(int));\n      int i = 0;\n      while (i < FUNCTIONBAR_MAXEVENTS && functions[i]) {\n         this->keys.keys[i] = xStrdup(keys[i]);\n         this->events[i] = events[i];\n         i++;\n      }\n      this->size = i;\n   } else {\n      this->staticData = true;\n      this->keys.constKeys = FunctionBar_FKeys;\n      this->events = FunctionBar_FEvents;\n      this->size = ARRAYSIZE(FunctionBar_FEvents);\n   }\n   return this;\n}\n\nvoid FunctionBar_delete(FunctionBar* this) {\n   for (int i = 0; i < FUNCTIONBAR_MAXEVENTS && this->functions[i]; i++) {\n      free(this->functions[i]);\n   }\n   free(this->functions);\n   if (!this->staticData) {\n      for (int i = 0; i < this->size; i++) {\n         free(this->keys.keys[i]);\n      }\n      free(this->keys.keys);\n      free(this->events);\n   }\n   free(this);\n}\n\nvoid FunctionBar_setLabel(FunctionBar* this, int event, const char* text) {\n   for (int i = 0; i < this->size; i++) {\n      if (this->events[i] == event) {\n         free(this->functions[i]);\n         this->functions[i] = xStrdup(text);\n         break;\n      }\n   }\n}\n\nint FunctionBar_draw(const FunctionBar* this) {\n   return FunctionBar_drawExtra(this, NULL, -1, false);\n}\n\nint FunctionBar_drawExtra(const FunctionBar* this, const char* buffer, int attr, bool setCursor) {\n   int cursorX = 0;\n   attrset(CRT_colors[FUNCTION_BAR]);\n   mvhline(LINES - 1, 0, ' ', COLS);\n   int x = 0;\n   for (int i = 0; i < this->size; i++) {\n      attrset(CRT_colors[FUNCTION_KEY]);\n      mvaddstr(LINES - 1, x, this->keys.constKeys[i]);\n      x += strlen(this->keys.constKeys[i]);\n      attrset(CRT_colors[FUNCTION_BAR]);\n      mvaddstr(LINES - 1, x, this->functions[i]);\n      x += strlen(this->functions[i]);\n   }\n\n   if (buffer) {\n      if (attr == -1) {\n         attrset(CRT_colors[FUNCTION_BAR]);\n      } else {\n         attrset(attr);\n      }\n      mvaddstr(LINES - 1, x, buffer);\n      x += strlen(buffer);\n      cursorX = x;\n   }\n\n   attrset(CRT_colors[RESET_COLOR]);\n\n   if (setCursor) {\n      curs_set(1);\n   } else {\n      curs_set(0);\n   }\n\n   currentLen = x;\n\n   return cursorX;\n}\n\nvoid FunctionBar_append(const char* buffer, int attr) {\n   if (attr == -1) {\n      attrset(CRT_colors[FUNCTION_BAR]);\n   } else {\n      attrset(attr);\n   }\n   mvaddstr(LINES - 1, currentLen + 1, buffer);\n   attrset(CRT_colors[RESET_COLOR]);\n\n   currentLen += strlen(buffer) + 1;\n}\n\nint FunctionBar_synthesizeEvent(const FunctionBar* this, int pos) {\n   int x = 0;\n   for (int i = 0; i < this->size; i++) {\n      x += strlen(this->keys.constKeys[i]);\n      x += strlen(this->functions[i]);\n      if (pos < x) {\n         return this->events[i];\n      }\n   }\n   return ERR;\n}\n"
        },
        {
          "name": "FunctionBar.h",
          "type": "blob",
          "size": 1.017578125,
          "content": "#ifndef HEADER_FunctionBar\n#define HEADER_FunctionBar\n/*\nhtop - FunctionBar.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n\ntypedef struct FunctionBar_ {\n   int size;\n   char** functions;\n   union {\n      char** keys;\n      const char* const* constKeys;\n   } keys;\n   int* events;\n   bool staticData;\n} FunctionBar;\n\n#define FUNCTIONBAR_MAXEVENTS 15\n\nFunctionBar* FunctionBar_newEnterEsc(const char* enter, const char* esc);\n\nFunctionBar* FunctionBar_new(const char* const* functions, const char* const* keys, const int* events);\n\nvoid FunctionBar_delete(FunctionBar* this);\n\nvoid FunctionBar_setLabel(FunctionBar* this, int event, const char* text);\n\nint FunctionBar_draw(const FunctionBar* this);\n\nint FunctionBar_drawExtra(const FunctionBar* this, const char* buffer, int attr, bool setCursor);\n\nvoid FunctionBar_append(const char* buffer, int attr);\n\nint FunctionBar_synthesizeEvent(const FunctionBar* this, int pos);\n\n#endif\n"
        },
        {
          "name": "Hashtable.c",
          "type": "blob",
          "size": 7.681640625,
          "content": "/*\nhtop - Hashtable.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Hashtable.h\"\n\n#include <assert.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"Macros.h\"\n#include \"XUtils.h\"\n\n#ifndef NDEBUG\n#include <stdio.h>\n#endif\n\n\ntypedef struct HashtableItem_ {\n   ht_key_t key;\n   size_t probe;\n   void* value;\n} HashtableItem;\n\nstruct Hashtable_ {\n   size_t size;\n   HashtableItem* buckets;\n   size_t items;\n   bool owner;\n};\n\n\n#ifndef NDEBUG\n\nstatic void Hashtable_dump(const Hashtable* this) {\n   fprintf(stderr, \"Hashtable %p: size=%zu items=%zu owner=%s\\n\",\n           (const void*)this,\n           this->size,\n           this->items,\n           this->owner ? \"yes\" : \"no\");\n\n   size_t items = 0;\n   for (size_t i = 0; i < this->size; i++) {\n      fprintf(stderr, \"  item %5zu: key = %5u probe = %2zu value = %p\\n\",\n              i,\n              this->buckets[i].key,\n              this->buckets[i].probe,\n              this->buckets[i].value);\n\n      if (this->buckets[i].value)\n         items++;\n   }\n\n   fprintf(stderr, \"Hashtable %p: items=%zu counted=%zu\\n\",\n           (const void*)this,\n           this->items,\n           items);\n}\n\nstatic bool Hashtable_isConsistent(const Hashtable* this) {\n   size_t items = 0;\n   for (size_t i = 0; i < this->size; i++) {\n      if (this->buckets[i].value)\n         items++;\n   }\n   bool res = items == this->items;\n   if (!res)\n      Hashtable_dump(this);\n   return res;\n}\n\nsize_t Hashtable_count(const Hashtable* this) {\n   size_t items = 0;\n   for (size_t i = 0; i < this->size; i++) {\n      if (this->buckets[i].value)\n         items++;\n   }\n   assert(items == this->items);\n   return items;\n}\n\n#endif /* NDEBUG */\n\n/* https://oeis.org/A014234 */\nstatic const uint64_t OEISprimes[] = {\n   7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191,\n   16381, 32749, 65521, 131071, 262139, 524287, 1048573,\n   2097143, 4194301, 8388593, 16777213, 33554393,\n   67108859, 134217689, 268435399, 536870909, 1073741789,\n   2147483647, 4294967291, 8589934583, 17179869143,\n   34359738337, 68719476731, 137438953447\n};\n\nstatic size_t nextPrime(size_t n) {\n   /* on 32-bit make sure we do not return primes not fitting in size_t */\n   for (size_t i = 0; i < ARRAYSIZE(OEISprimes) && OEISprimes[i] < SIZE_MAX; i++) {\n      if (n <= OEISprimes[i])\n         return OEISprimes[i];\n   }\n\n   CRT_fatalError(\"Hashtable: no prime found\");\n}\n\nHashtable* Hashtable_new(size_t size, bool owner) {\n   size = size ? nextPrime(size) : 13;\n\n   Hashtable* this = xMalloc(sizeof(Hashtable));\n   *this = (Hashtable) {\n      .items = 0,\n      .size = size,\n      .buckets = xCalloc(size, sizeof(HashtableItem)),\n      .owner = owner,\n   };\n\n   assert(Hashtable_isConsistent(this));\n   return this;\n}\n\nvoid Hashtable_delete(Hashtable* this) {\n   Hashtable_clear(this);\n\n   free(this->buckets);\n   free(this);\n}\n\nvoid Hashtable_clear(Hashtable* this) {\n   assert(Hashtable_isConsistent(this));\n\n   if (this->owner)\n      for (size_t i = 0; i < this->size; i++)\n         free(this->buckets[i].value);\n\n   memset(this->buckets, 0, this->size * sizeof(HashtableItem));\n   this->items = 0;\n\n   assert(Hashtable_isConsistent(this));\n}\n\nstatic void insert(Hashtable* this, ht_key_t key, void* value) {\n   size_t index = key % this->size;\n   size_t probe = 0;\n#ifndef NDEBUG\n   size_t origIndex = index;\n#endif\n\n   for (;;) {\n      if (!this->buckets[index].value) {\n         this->items++;\n         this->buckets[index].key = key;\n         this->buckets[index].probe = probe;\n         this->buckets[index].value = value;\n         return;\n      }\n\n      if (this->buckets[index].key == key) {\n         if (this->owner && this->buckets[index].value != value)\n            free(this->buckets[index].value);\n         this->buckets[index].value = value;\n         return;\n      }\n\n      /* Robin Hood swap */\n      if (probe > this->buckets[index].probe) {\n         HashtableItem tmp = this->buckets[index];\n\n         this->buckets[index].key = key;\n         this->buckets[index].probe = probe;\n         this->buckets[index].value = value;\n\n         key = tmp.key;\n         probe = tmp.probe;\n         value = tmp.value;\n      }\n\n      index = (index + 1) % this->size;\n      probe++;\n\n      assert(index != origIndex);\n   }\n}\n\nvoid Hashtable_setSize(Hashtable* this, size_t size) {\n\n   assert(Hashtable_isConsistent(this));\n\n   if (size <= this->items)\n      return;\n\n   size_t newSize = nextPrime(size);\n   if (newSize == this->size)\n      return;\n\n   HashtableItem* oldBuckets = this->buckets;\n   size_t oldSize = this->size;\n\n   this->size = newSize;\n   this->buckets = (HashtableItem*) xCalloc(this->size, sizeof(HashtableItem));\n   this->items = 0;\n\n   /* rehash */\n   for (size_t i = 0; i < oldSize; i++) {\n      if (!oldBuckets[i].value)\n         continue;\n\n      insert(this, oldBuckets[i].key, oldBuckets[i].value);\n   }\n\n   free(oldBuckets);\n\n   assert(Hashtable_isConsistent(this));\n}\n\nvoid Hashtable_put(Hashtable* this, ht_key_t key, void* value) {\n\n   assert(Hashtable_isConsistent(this));\n   assert(this->size > 0);\n   assert(value);\n\n   /* grow on load-factor > 0.7 */\n   if (10 * this->items > 7 * this->size) {\n      if (SIZE_MAX / 2 < this->size)\n         CRT_fatalError(\"Hashtable: size overflow\");\n\n      Hashtable_setSize(this, 2 * this->size);\n   }\n\n   insert(this, key, value);\n\n   assert(Hashtable_isConsistent(this));\n   assert(Hashtable_get(this, key) != NULL);\n   assert(this->size > this->items);\n}\n\nvoid* Hashtable_remove(Hashtable* this, ht_key_t key) {\n   size_t index = key % this->size;\n   size_t probe = 0;\n#ifndef NDEBUG\n   size_t origIndex = index;\n#endif\n\n   assert(Hashtable_isConsistent(this));\n\n   void* res = NULL;\n\n   while (this->buckets[index].value) {\n      if (this->buckets[index].key == key) {\n         if (this->owner) {\n            free(this->buckets[index].value);\n         } else {\n            res = this->buckets[index].value;\n         }\n\n         size_t next = (index + 1) % this->size;\n\n         while (this->buckets[next].value && this->buckets[next].probe > 0) {\n            this->buckets[index] = this->buckets[next];\n            this->buckets[index].probe -= 1;\n\n            index = next;\n            next = (index + 1) % this->size;\n         }\n\n         /* set empty after backward shifting */\n         this->buckets[index].value = NULL;\n         this->items--;\n\n         break;\n      }\n\n      if (this->buckets[index].probe < probe)\n         break;\n\n      index = (index + 1) % this->size;\n      probe++;\n\n      assert(index != origIndex);\n   }\n\n   assert(Hashtable_isConsistent(this));\n   assert(Hashtable_get(this, key) == NULL);\n\n   /* shrink on load-factor < 0.125 */\n   if (8 * this->items < this->size)\n      Hashtable_setSize(this, this->size / 3); /* account for nextPrime rounding up */\n\n   return res;\n}\n\nvoid* Hashtable_get(Hashtable* this, ht_key_t key) {\n   size_t index = key % this->size;\n   size_t probe = 0;\n   void* res = NULL;\n#ifndef NDEBUG\n   size_t origIndex = index;\n#endif\n\n   assert(Hashtable_isConsistent(this));\n\n   while (this->buckets[index].value) {\n      if (this->buckets[index].key == key) {\n         res = this->buckets[index].value;\n         break;\n      }\n\n      if (this->buckets[index].probe < probe)\n         break;\n\n      index = (index + 1) != this->size ? (index + 1) : 0;\n      probe++;\n\n      assert(index != origIndex);\n   }\n\n   return res;\n}\n\nvoid Hashtable_foreach(Hashtable* this, Hashtable_PairFunction f, void* userData) {\n   assert(Hashtable_isConsistent(this));\n   for (size_t i = 0; i < this->size; i++) {\n      HashtableItem* walk = &this->buckets[i];\n      if (walk->value)\n         f(walk->key, walk->value, userData);\n   }\n   assert(Hashtable_isConsistent(this));\n}\n"
        },
        {
          "name": "Hashtable.h",
          "type": "blob",
          "size": 0.9189453125,
          "content": "#ifndef HEADER_Hashtable\n#define HEADER_Hashtable\n/*\nhtop - Hashtable.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n#include <stddef.h>\n\n\ntypedef unsigned int ht_key_t;\n\ntypedef void(*Hashtable_PairFunction)(ht_key_t key, void* value, void* userdata);\n\ntypedef struct Hashtable_ Hashtable;\n\n#ifndef NDEBUG\n\nsize_t Hashtable_count(const Hashtable* this);\n\n#endif /* NDEBUG */\n\nHashtable* Hashtable_new(size_t size, bool owner);\n\nvoid Hashtable_delete(Hashtable* this);\n\nvoid Hashtable_clear(Hashtable* this);\n\nvoid Hashtable_setSize(Hashtable* this, size_t size);\n\nvoid Hashtable_put(Hashtable* this, ht_key_t key, void* value);\n\nvoid* Hashtable_remove(Hashtable* this, ht_key_t key);\n\nvoid* Hashtable_get(Hashtable* this, ht_key_t key);\n\nvoid Hashtable_foreach(Hashtable* this, Hashtable_PairFunction f, void* userData);\n\n#endif\n"
        },
        {
          "name": "Header.c",
          "type": "blob",
          "size": 9.3994140625,
          "content": "/*\nhtop - Header.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Header.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"CPUMeter.h\"\n#include \"DynamicMeter.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"ProvideCurses.h\"\n#include \"Settings.h\"\n#include \"XUtils.h\"\n\n\nHeader* Header_new(Machine* host, HeaderLayout hLayout) {\n   Header* this = xCalloc(1, sizeof(Header));\n   this->columns = xMallocArray(HeaderLayout_getColumns(hLayout), sizeof(Vector*));\n   this->headerLayout = hLayout;\n   this->host = host;\n\n   Header_forEachColumn(this, i) {\n      this->columns[i] = Vector_new(Class(Meter), true, DEFAULT_SIZE);\n   }\n\n   return this;\n}\n\nvoid Header_delete(Header* this) {\n   Header_forEachColumn(this, i) {\n      Vector_delete(this->columns[i]);\n   }\n\n   free(this->columns);\n   free(this);\n}\n\nvoid Header_setLayout(Header* this, HeaderLayout hLayout) {\n   size_t oldColumns = HeaderLayout_getColumns(this->headerLayout);\n   size_t newColumns = HeaderLayout_getColumns(hLayout);\n\n   this->headerLayout = hLayout;\n\n   if (newColumns == oldColumns)\n      return;\n\n   if (newColumns > oldColumns) {\n      this->columns = xReallocArray(this->columns, newColumns, sizeof(Vector*));\n      for (size_t i = oldColumns; i < newColumns; i++)\n         this->columns[i] = Vector_new(Class(Meter), true, DEFAULT_SIZE);\n   } else {\n      // move meters from to-be-deleted columns into last one\n      for (size_t i = newColumns; i < oldColumns; i++) {\n         for (int j = this->columns[i]->items - 1; j >= 0; j--) {\n            Vector_add(this->columns[newColumns - 1], Vector_take(this->columns[i], j));\n         }\n         Vector_delete(this->columns[i]);\n      }\n      this->columns = xReallocArray(this->columns, newColumns, sizeof(Vector*));\n   }\n\n   Header_calculateHeight(this);\n}\n\nstatic void Header_addMeterByName(Header* this, const char* name, MeterModeId mode, unsigned int column) {\n   assert(column < HeaderLayout_getColumns(this->headerLayout));\n\n   Vector* meters = this->columns[column];\n\n   const char* paren = strchr(name, '(');\n   unsigned int param = 0;\n   size_t nameLen;\n   if (paren) {\n      if (sscanf(paren, \"(%10u)\", &param) != 1) { // not CPUMeter\n         char dynamic[32] = {0};\n         if (sscanf(paren, \"(%30s)\", dynamic) == 1) { // DynamicMeter\n            char* end;\n            if ((end = strrchr(dynamic, ')')) == NULL)\n               return;    // htoprc parse failure\n            *end = '\\0';\n            const Settings* settings = this->host->settings;\n            if (!DynamicMeter_search(settings->dynamicMeters, dynamic, &param))\n               return;    // name lookup failure\n         } else {\n            param = 0;\n         }\n      }\n      nameLen = paren - name;\n   } else {\n      nameLen = strlen(name);\n   }\n\n   for (const MeterClass* const* type = Platform_meterTypes; *type; type++) {\n      if (0 == strncmp(name, (*type)->name, nameLen) && (*type)->name[nameLen] == '\\0') {\n         Meter* meter = Meter_new(this->host, param, *type);\n         if (mode != 0) {\n            Meter_setMode(meter, mode);\n         }\n         Vector_add(meters, meter);\n         break;\n      }\n   }\n}\n\nvoid Header_populateFromSettings(Header* this) {\n   const Settings* settings = this->host->settings;\n   Header_setLayout(this, settings->hLayout);\n\n   Header_forEachColumn(this, col) {\n      const MeterColumnSetting* colSettings = &settings->hColumns[col];\n      Vector_prune(this->columns[col]);\n      for (size_t i = 0; i < colSettings->len; i++) {\n         Header_addMeterByName(this, colSettings->names[i], colSettings->modes[i], col);\n      }\n   }\n\n   Header_calculateHeight(this);\n}\n\nvoid Header_writeBackToSettings(const Header* this) {\n   Settings* settings = this->host->settings;\n   Settings_setHeaderLayout(settings, this->headerLayout);\n\n   Header_forEachColumn(this, col) {\n      MeterColumnSetting* colSettings = &settings->hColumns[col];\n\n      if (colSettings->names) {\n         for (size_t j = 0; j < colSettings->len; j++)\n            free(colSettings->names[j]);\n         free(colSettings->names);\n      }\n      free(colSettings->modes);\n\n      const Vector* vec = this->columns[col];\n      int len = Vector_size(vec);\n\n      colSettings->names = len ? xCalloc(len + 1, sizeof(*colSettings->names)) : NULL;\n      colSettings->modes = len ? xCalloc(len, sizeof(*colSettings->modes)) : NULL;\n      colSettings->len = len;\n\n      for (int i = 0; i < len; i++) {\n         const Meter* meter = (Meter*) Vector_get(vec, i);\n         char* name;\n         if (meter->param && As_Meter(meter) == &DynamicMeter_class) {\n            const char* dynamic = DynamicMeter_lookup(settings->dynamicMeters, meter->param);\n            xAsprintf(&name, \"%s(%s)\", As_Meter(meter)->name, dynamic);\n         } else if (meter->param && As_Meter(meter) == &CPUMeter_class) {\n            xAsprintf(&name, \"%s(%u)\", As_Meter(meter)->name, meter->param);\n         } else {\n            xAsprintf(&name, \"%s\", As_Meter(meter)->name);\n         }\n         colSettings->names[i] = name;\n         colSettings->modes[i] = meter->mode;\n      }\n   }\n}\n\nMeter* Header_addMeterByClass(Header* this, const MeterClass* type, unsigned int param, unsigned int column) {\n   assert(column < HeaderLayout_getColumns(this->headerLayout));\n\n   Vector* meters = this->columns[column];\n\n   Meter* meter = Meter_new(this->host, param, type);\n   Vector_add(meters, meter);\n   return meter;\n}\n\nvoid Header_reinit(Header* this) {\n   Header_forEachColumn(this, col) {\n      for (int i = 0; i < Vector_size(this->columns[col]); i++) {\n         Meter* meter = (Meter*) Vector_get(this->columns[col], i);\n         if (Meter_initFn(meter)) {\n            Meter_init(meter);\n         }\n      }\n   }\n}\n\nvoid Header_draw(const Header* this) {\n   const int height = this->height;\n   const int pad = this->pad;\n   attrset(CRT_colors[RESET_COLOR]);\n   for (int y = 0; y < height; y++) {\n      mvhline(y, 0, ' ', COLS);\n   }\n   const int numCols = HeaderLayout_getColumns(this->headerLayout);\n   const int width = COLS - 2 * pad - (numCols - 1);\n   int x = pad;\n   float roundingLoss = 0.0F;\n\n   Header_forEachColumn(this, col) {\n      Vector* meters = this->columns[col];\n      float colWidth = (float)width * HeaderLayout_layouts[this->headerLayout].widths[col] / 100.0F;\n\n      roundingLoss += colWidth - floorf(colWidth);\n      if (roundingLoss >= 1.0F) {\n         colWidth += 1.0F;\n         roundingLoss -= 1.0F;\n      }\n\n      for (int y = (pad / 2), i = 0; i < Vector_size(meters); i++) {\n         Meter* meter = (Meter*) Vector_get(meters, i);\n\n         float actualWidth = colWidth;\n\n         /* Let meters in text mode expand to the right on empty neighbors;\n            except for multi column meters. */\n         if (meter->mode == TEXT_METERMODE && !Meter_isMultiColumn(meter)) {\n            for (int j = 1; j < meter->columnWidthCount; j++) {\n               actualWidth++; /* separator column */\n               actualWidth += (float)width * HeaderLayout_layouts[this->headerLayout].widths[col + j] / 100.0F;\n            }\n         }\n\n         assert(meter->draw);\n         meter->draw(meter, x, y, floorf(actualWidth));\n         y += meter->h;\n      }\n\n      x += floorf(colWidth);\n      x++; /* separator column */\n   }\n}\n\nvoid Header_updateData(Header* this) {\n   Header_forEachColumn(this, col) {\n      Vector* meters = this->columns[col];\n      int items = Vector_size(meters);\n      for (int i = 0; i < items; i++) {\n         Meter* meter = (Meter*) Vector_get(meters, i);\n         Meter_updateValues(meter);\n      }\n   }\n}\n\n/*\n * Calculate how many columns the current meter is allowed to span,\n * by counting how many columns to the right are empty or contain a BlankMeter.\n * Returns the number of columns to span, i.e. if the direct neighbor is occupied 1.\n */\nstatic int calcColumnWidthCount(const Header* this, const Meter* curMeter, const int pad, const unsigned int curColumn, const int curHeight) {\n   for (size_t i = curColumn + 1; i < HeaderLayout_getColumns(this->headerLayout); i++) {\n      const Vector* meters = this->columns[i];\n\n      int height = pad;\n      for (int j = 0; j < Vector_size(meters); j++) {\n         const Meter* meter = (const Meter*) Vector_get(meters, j);\n\n         if (height >= curHeight + curMeter->h)\n            break;\n\n         height += meter->h;\n         if (height <= curHeight)\n            continue;\n\n         if (!Object_isA((const Object*) meter, (const ObjectClass*) &BlankMeter_class))\n            return i - curColumn;\n      }\n   }\n\n   return HeaderLayout_getColumns(this->headerLayout) - curColumn;\n}\n\nint Header_calculateHeight(Header* this) {\n   const Settings* settings = this->host->settings;\n   const int pad = settings->headerMargin ? 2 : 0;\n   int maxHeight = pad;\n\n   Header_forEachColumn(this, col) {\n      const Vector* meters = this->columns[col];\n      int height = pad;\n      for (int i = 0; i < Vector_size(meters); i++) {\n         Meter* meter = (Meter*) Vector_get(meters, i);\n         meter->columnWidthCount = calcColumnWidthCount(this, meter, pad, col, height);\n         height += meter->h;\n      }\n      maxHeight = MAXIMUM(maxHeight, height);\n   }\n\n   if (maxHeight == pad) {\n      maxHeight = 0;\n      this->pad = 0;\n   } else {\n      this->pad = pad;\n   }\n\n   if (settings->screenTabs) {\n      maxHeight++;\n   }\n\n   this->height = maxHeight;\n\n   return maxHeight;\n}\n"
        },
        {
          "name": "Header.h",
          "type": "blob",
          "size": 1.10546875,
          "content": "#ifndef HEADER_Header\n#define HEADER_Header\n/*\nhtop - Header.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stddef.h>\n\n#include \"HeaderLayout.h\"\n#include \"Machine.h\"\n#include \"Meter.h\"\n#include \"Vector.h\"\n\n\ntypedef struct Header_ {\n   Vector** columns;\n   Machine* host;\n   HeaderLayout headerLayout;\n   int pad;\n   int height;\n} Header;\n\n#define Header_forEachColumn(this_, i_) for (size_t (i_)=0, H_fEC_numColumns_ = HeaderLayout_getColumns((this_)->headerLayout); (i_) < H_fEC_numColumns_; ++(i_))\n\nHeader* Header_new(Machine* host, HeaderLayout hLayout);\n\nvoid Header_delete(Header* this);\n\nvoid Header_setLayout(Header* this, HeaderLayout hLayout);\n\nvoid Header_populateFromSettings(Header* this);\n\nvoid Header_writeBackToSettings(const Header* this);\n\nMeter* Header_addMeterByClass(Header* this, const MeterClass* type, unsigned int param, unsigned int column);\n\nvoid Header_reinit(Header* this);\n\nvoid Header_draw(const Header* this);\n\nvoid Header_updateData(Header* this);\n\nint Header_calculateHeight(Header* this);\n\n#endif\n"
        },
        {
          "name": "HeaderLayout.h",
          "type": "blob",
          "size": 3.0927734375,
          "content": "#ifndef HEADER_HeaderLayout\n#define HEADER_HeaderLayout\n/*\nhtop - HeaderLayout.h\n(C) 2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <assert.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"Macros.h\"\n#include \"XUtils.h\"\n\n\ntypedef enum HeaderLayout_ {\n   HF_INVALID = -1,\n   HF_ONE_100,\n   HF_TWO_50_50,\n   HF_TWO_33_67,\n   HF_TWO_67_33,\n   HF_THREE_33_34_33,\n   HF_THREE_25_25_50,\n   HF_THREE_25_50_25,\n   HF_THREE_50_25_25,\n   HF_THREE_40_30_30,\n   HF_THREE_30_40_30,\n   HF_THREE_30_30_40,\n   HF_THREE_40_20_40,\n   HF_FOUR_25_25_25_25,\n   LAST_HEADER_LAYOUT\n} HeaderLayout;\n\nstatic const struct {\n   uint8_t columns;\n   const uint8_t widths[4];\n   const char* name;\n   const char* description;\n} HeaderLayout_layouts[LAST_HEADER_LAYOUT] = {\n   [HF_ONE_100]          = { 1, { 100, 0,  0,  0 }, \"one_100\",          \"1 column  - full width\",      },\n   [HF_TWO_50_50]        = { 2, { 50, 50,  0,  0 }, \"two_50_50\",        \"2 columns - 50/50 (default)\", },\n   [HF_TWO_33_67]        = { 2, { 33, 67,  0,  0 }, \"two_33_67\",        \"2 columns - 33/67\",           },\n   [HF_TWO_67_33]        = { 2, { 67, 33,  0,  0 }, \"two_67_33\",        \"2 columns - 67/33\",           },\n   [HF_THREE_33_34_33]   = { 3, { 33, 34, 33,  0 }, \"three_33_34_33\",   \"3 columns - 33/34/33\",        },\n   [HF_THREE_25_25_50]   = { 3, { 25, 25, 50,  0 }, \"three_25_25_50\",   \"3 columns - 25/25/50\",        },\n   [HF_THREE_25_50_25]   = { 3, { 25, 50, 25,  0 }, \"three_25_50_25\",   \"3 columns - 25/50/25\",        },\n   [HF_THREE_50_25_25]   = { 3, { 50, 25, 25,  0 }, \"three_50_25_25\",   \"3 columns - 50/25/25\",        },\n   [HF_THREE_40_30_30]   = { 3, { 40, 30, 30,  0 }, \"three_40_30_30\",   \"3 columns - 40/30/30\",        },\n   [HF_THREE_30_40_30]   = { 3, { 30, 40, 30,  0 }, \"three_30_40_30\",   \"3 columns - 30/40/30\",        },\n   [HF_THREE_30_30_40]   = { 3, { 30, 30, 40,  0 }, \"three_30_30_40\",   \"3 columns - 30/30/40\",        },\n   [HF_THREE_40_20_40]   = { 3, { 40, 20, 40,  0 }, \"three_40_20_40\",   \"3 columns - 40/20/40\",        },\n   [HF_FOUR_25_25_25_25] = { 4, { 25, 25, 25, 25 }, \"four_25_25_25_25\", \"4 columns - 25/25/25/25\",     },\n};\n\nstatic inline size_t HeaderLayout_getColumns(HeaderLayout hLayout) {\n   /* assert the layout is initialized */\n   assert(0 <= hLayout);\n   assert(hLayout < LAST_HEADER_LAYOUT);\n   assert(HeaderLayout_layouts[hLayout].name[0]);\n   assert(HeaderLayout_layouts[hLayout].description[0]);\n   return HeaderLayout_layouts[hLayout].columns;\n}\n\nstatic inline const char* HeaderLayout_getName(HeaderLayout hLayout) {\n   /* assert the layout is initialized */\n   assert(0 <= hLayout);\n   assert(hLayout < LAST_HEADER_LAYOUT);\n   assert(HeaderLayout_layouts[hLayout].name[0]);\n   assert(HeaderLayout_layouts[hLayout].description[0]);\n   return HeaderLayout_layouts[hLayout].name;\n}\n\nstatic inline HeaderLayout HeaderLayout_fromName(const char* name) {\n   for (size_t i = 0; i < LAST_HEADER_LAYOUT; i++) {\n      if (String_eq(HeaderLayout_layouts[i].name, name))\n         return (HeaderLayout) i;\n   }\n\n   return LAST_HEADER_LAYOUT;\n}\n\n#endif /* HEADER_HeaderLayout */\n"
        },
        {
          "name": "HeaderOptionsPanel.c",
          "type": "blob",
          "size": 2.4697265625,
          "content": "/*\nhtop - HeaderOptionsPanel.c\n(C) 2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"HeaderOptionsPanel.h\"\n\n#include <assert.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Header.h\"\n#include \"HeaderLayout.h\"\n#include \"Object.h\"\n#include \"OptionItem.h\"\n#include \"ProvideCurses.h\"\n\n\nstatic const char* const HeaderOptionsFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nstatic void HeaderOptionsPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   HeaderOptionsPanel* this = (HeaderOptionsPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic HandlerResult HeaderOptionsPanel_eventHandler(Panel* super, int ch) {\n   HeaderOptionsPanel* this = (HeaderOptionsPanel*) super;\n\n   HandlerResult result = IGNORED;\n\n   switch (ch) {\n      case 0x0a:\n      case 0x0d:\n      case KEY_ENTER:\n      case KEY_MOUSE:\n      case KEY_RECLICK:\n      case ' ': {\n         int mark = Panel_getSelectedIndex(super);\n         assert(mark >= 0);\n         assert(mark < LAST_HEADER_LAYOUT);\n\n         for (int i = 0; i < LAST_HEADER_LAYOUT; i++)\n            CheckItem_set((CheckItem*)Panel_get(super, i), false);\n         CheckItem_set((CheckItem*)Panel_get(super, mark), true);\n\n         Header_setLayout(this->scr->header, mark);\n         this->settings->changed = true;\n         this->settings->lastUpdate++;\n\n         ScreenManager_resize(this->scr);\n\n         result = HANDLED;\n      }\n   }\n\n   return result;\n}\n\nconst PanelClass HeaderOptionsPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = HeaderOptionsPanel_delete\n   },\n   .eventHandler = HeaderOptionsPanel_eventHandler\n};\n\nHeaderOptionsPanel* HeaderOptionsPanel_new(Settings* settings, ScreenManager* scr) {\n   HeaderOptionsPanel* this = AllocThis(HeaderOptionsPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(HeaderOptionsFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(CheckItem), true, fuBar);\n\n   this->scr = scr;\n   this->settings = settings;\n\n   Panel_setHeader(super, \"Header Layout\");\n   for (int i = 0; i < LAST_HEADER_LAYOUT; i++) {\n      Panel_add(super, (Object*) CheckItem_newByVal(HeaderLayout_layouts[i].description, false));\n   }\n   CheckItem_set((CheckItem*)Panel_get(super, scr->header->headerLayout), true);\n   return this;\n}\n"
        },
        {
          "name": "HeaderOptionsPanel.h",
          "type": "blob",
          "size": 0.5712890625,
          "content": "#ifndef HEADER_HeaderOptionsPanel\n#define HEADER_HeaderOptionsPanel\n/*\nhtop - ColorsPanel.h\n(C) 2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n#include \"ScreenManager.h\"\n#include \"Settings.h\"\n\n\ntypedef struct HeaderOptionsPanel_ {\n   Panel super;\n\n   ScreenManager* scr;\n   Settings* settings;\n} HeaderOptionsPanel;\n\nextern const PanelClass HeaderOptionsPanel_class;\n\nHeaderOptionsPanel* HeaderOptionsPanel_new(Settings* settings, ScreenManager* scr);\n\n#endif /* HEADER_HeaderOptionsPanel */\n"
        },
        {
          "name": "HostnameMeter.c",
          "type": "blob",
          "size": 0.8623046875,
          "content": "/*\nhtop - HostnameMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"HostnameMeter.h\"\n\n#include \"CRT.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n\n\nstatic const int HostnameMeter_attributes[] = {\n   HOSTNAME\n};\n\nstatic void HostnameMeter_updateValues(Meter* this) {\n   Platform_getHostname(this->txtBuffer, sizeof(this->txtBuffer));\n}\n\nconst MeterClass HostnameMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = HostnameMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = (1 << TEXT_METERMODE),\n   .maxItems = 0,\n   .total = 0.0,\n   .attributes = HostnameMeter_attributes,\n   .name = \"Hostname\",\n   .uiName = \"Hostname\",\n   .caption = \"Hostname: \",\n};\n"
        },
        {
          "name": "HostnameMeter.h",
          "type": "blob",
          "size": 0.2861328125,
          "content": "#ifndef HEADER_HostnameMeter\n#define HEADER_HostnameMeter\n/*\nhtop - HostnameMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n\nextern const MeterClass HostnameMeter_class;\n\n#endif\n"
        },
        {
          "name": "IncSet.c",
          "type": "blob",
          "size": 6.7939453125,
          "content": "/*\nhtop - IncSet.c\n(C) 2005-2012 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"IncSet.h\"\n\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"CRT.h\"\n#include \"ListItem.h\"\n#include \"Object.h\"\n#include \"ProvideCurses.h\"\n#include \"XUtils.h\"\n\n\nstatic void IncMode_reset(IncMode* mode) {\n   mode->index = 0;\n   mode->buffer[0] = 0;\n}\n\nvoid IncSet_reset(IncSet* this, IncType type) {\n   IncMode_reset(&this->modes[type]);\n}\n\nvoid IncSet_setFilter(IncSet* this, const char* filter) {\n   IncMode* mode = &this->modes[INC_FILTER];\n   size_t len = String_safeStrncpy(mode->buffer, filter, sizeof(mode->buffer));\n   mode->index = len;\n   this->filtering = true;\n}\n\nstatic const char* const searchFunctions[] = {\"Next  \", \"Prev   \", \"Cancel \", \" Search: \", NULL};\nstatic const char* const searchKeys[] = {\"F3\", \"S-F3\", \"Esc\", \"  \"};\nstatic const int searchEvents[] = {KEY_F(3), KEY_F(15), 27, ERR};\n\nstatic inline void IncMode_initSearch(IncMode* search) {\n   memset(search, 0, sizeof(IncMode));\n   search->bar = FunctionBar_new(searchFunctions, searchKeys, searchEvents);\n   search->isFilter = false;\n}\n\nstatic const char* const filterFunctions[] = {\"Done  \", \"Clear \", \" Filter: \", NULL};\nstatic const char* const filterKeys[] = {\"Enter\", \"Esc\", \"  \"};\nstatic const int filterEvents[] = {13, 27, ERR};\n\nstatic inline void IncMode_initFilter(IncMode* filter) {\n   memset(filter, 0, sizeof(IncMode));\n   filter->bar = FunctionBar_new(filterFunctions, filterKeys, filterEvents);\n   filter->isFilter = true;\n}\n\nstatic inline void IncMode_done(IncMode* mode) {\n   FunctionBar_delete(mode->bar);\n}\n\nIncSet* IncSet_new(FunctionBar* bar) {\n   IncSet* this = xMalloc(sizeof(IncSet));\n   IncMode_initSearch(&(this->modes[INC_SEARCH]));\n   IncMode_initFilter(&(this->modes[INC_FILTER]));\n   this->active = NULL;\n   this->defaultBar = bar;\n   this->filtering = false;\n   this->found = false;\n   return this;\n}\n\nvoid IncSet_delete(IncSet* this) {\n   IncMode_done(&(this->modes[0]));\n   IncMode_done(&(this->modes[1]));\n   free(this);\n}\n\nstatic void updateWeakPanel(const IncSet* this, Panel* panel, Vector* lines) {\n   const Object* selected = Panel_getSelected(panel);\n   Panel_prune(panel);\n   if (this->filtering) {\n      int n = 0;\n      const char* incFilter = this->modes[INC_FILTER].buffer;\n      for (int i = 0; i < Vector_size(lines); i++) {\n         ListItem* line = (ListItem*)Vector_get(lines, i);\n         if (String_contains_i(line->value, incFilter, true)) {\n            Panel_add(panel, (Object*)line);\n            if (selected == (Object*)line) {\n               Panel_setSelected(panel, n);\n            }\n\n            n++;\n         }\n      }\n   } else {\n      for (int i = 0; i < Vector_size(lines); i++) {\n         Object* line = Vector_get(lines, i);\n         Panel_add(panel, line);\n         if (selected == line) {\n            Panel_setSelected(panel, i);\n         }\n      }\n   }\n}\n\nstatic bool search(const IncSet* this, Panel* panel, IncMode_GetPanelValue getPanelValue) {\n   int size = Panel_size(panel);\n   for (int i = 0; i < size; i++) {\n      if (String_contains_i(getPanelValue(panel, i), this->active->buffer, true)) {\n         Panel_setSelected(panel, i);\n         return true;\n      }\n   }\n\n   return false;\n}\n\nvoid IncSet_activate(IncSet* this, IncType type, Panel* panel) {\n   this->active = &(this->modes[type]);\n   panel->currentBar = this->active->bar;\n   panel->cursorOn = true;\n   this->panel = panel;\n   IncSet_drawBar(this, CRT_colors[FUNCTION_BAR]);\n}\n\nstatic void IncSet_deactivate(IncSet* this, Panel* panel) {\n   this->active = NULL;\n   Panel_setDefaultBar(panel);\n   panel->cursorOn = false;\n   FunctionBar_draw(this->defaultBar);\n}\n\nstatic bool IncMode_find(const IncMode* mode, Panel* panel, IncMode_GetPanelValue getPanelValue, int step) {\n   int size = Panel_size(panel);\n   int here = Panel_getSelectedIndex(panel);\n   int i = here;\n   for (;;) {\n      i += step;\n      if (i == size) {\n         i = 0;\n      }\n      if (i == -1) {\n         i = size - 1;\n      }\n      if (i == here) {\n         return false;\n      }\n\n      if (String_contains_i(getPanelValue(panel, i), mode->buffer, true)) {\n         Panel_setSelected(panel, i);\n         return true;\n      }\n   }\n}\n\nbool IncSet_handleKey(IncSet* this, int ch, Panel* panel, IncMode_GetPanelValue getPanelValue, Vector* lines) {\n   if (ch == ERR)\n      return true;\n\n   IncMode* mode = this->active;\n   int size = Panel_size(panel);\n   bool filterChanged = false;\n   bool doSearch = true;\n   if (ch == KEY_F(3) || ch == KEY_F(15)) {\n      if (size == 0)\n         return true;\n\n      IncMode_find(mode, panel, getPanelValue, ch == KEY_F(3) ? 1 : -1);\n      doSearch = false;\n   } else if (0 < ch && ch < 255 && isprint((unsigned char)ch)) {\n      if (mode->index < INCMODE_MAX) {\n         mode->buffer[mode->index] = (char) ch;\n         mode->index++;\n         mode->buffer[mode->index] = 0;\n         if (mode->isFilter) {\n            filterChanged = true;\n            if (mode->index == 1) {\n               this->filtering = true;\n            }\n         }\n      }\n   } else if (ch == KEY_BACKSPACE || ch == 127) {\n      if (mode->index > 0) {\n         mode->index--;\n         mode->buffer[mode->index] = 0;\n         if (mode->isFilter) {\n            filterChanged = true;\n            if (mode->index == 0) {\n               this->filtering = false;\n               IncMode_reset(mode);\n            }\n         }\n      } else {\n         doSearch = false;\n      }\n   } else if (ch == KEY_RESIZE) {\n      doSearch = (mode->index > 0);\n   } else {\n      if (mode->isFilter) {\n         filterChanged = true;\n         if (ch == 27) {\n            this->filtering = false;\n            IncMode_reset(mode);\n         }\n      } else {\n         if (ch == 27) {\n            IncMode_reset(mode);\n         }\n      }\n      IncSet_deactivate(this, panel);\n      doSearch = false;\n   }\n   if (doSearch) {\n      this->found = search(this, panel, getPanelValue);\n   }\n   if (filterChanged && lines) {\n      updateWeakPanel(this, panel, lines);\n   }\n   return filterChanged;\n}\n\nconst char* IncSet_getListItemValue(Panel* panel, int i) {\n   const ListItem* l = (const ListItem*) Panel_get(panel, i);\n   return l ? l->value : \"\";\n}\n\nvoid IncSet_drawBar(const IncSet* this, int attr) {\n   if (this->active) {\n      if (!this->active->isFilter && !this->found)\n         attr = CRT_colors[FAILED_SEARCH];\n      int cursorX = FunctionBar_drawExtra(this->active->bar, this->active->buffer, attr, true);\n      this->panel->cursorY = LINES - 1;\n      this->panel->cursorX = cursorX;\n   } else {\n      FunctionBar_draw(this->defaultBar);\n   }\n}\n\nint IncSet_synthesizeEvent(IncSet* this, int x) {\n   if (this->active) {\n      return FunctionBar_synthesizeEvent(this->active->bar, x);\n   } else {\n      return FunctionBar_synthesizeEvent(this->defaultBar, x);\n   }\n}\n"
        },
        {
          "name": "IncSet.h",
          "type": "blob",
          "size": 1.359375,
          "content": "#ifndef HEADER_IncSet\n#define HEADER_IncSet\n/*\nhtop - IncSet.h\n(C) 2005-2012 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n#include <stddef.h>\n\n#include \"FunctionBar.h\"\n#include \"Panel.h\"\n#include \"Vector.h\"\n\n\n#define INCMODE_MAX 128\n\ntypedef enum {\n   INC_SEARCH = 0,\n   INC_FILTER = 1\n} IncType;\n\ntypedef struct IncMode_ {\n   char buffer[INCMODE_MAX + 1];\n   int index;\n   FunctionBar* bar;\n   bool isFilter;\n} IncMode;\n\ntypedef struct IncSet_ {\n   IncMode modes[2];\n   IncMode* active;\n   Panel* panel;\n   FunctionBar* defaultBar;\n   bool filtering;\n   bool found;\n} IncSet;\n\nstatic inline const char* IncSet_filter(const IncSet* this) {\n   return this->filtering ? this->modes[INC_FILTER].buffer : NULL;\n}\n\nvoid IncSet_setFilter(IncSet* this, const char* filter);\n\ntypedef const char* (*IncMode_GetPanelValue)(Panel*, int);\n\nvoid IncSet_reset(IncSet* this, IncType type);\n\nIncSet* IncSet_new(FunctionBar* bar);\n\nvoid IncSet_delete(IncSet* this);\n\nbool IncSet_handleKey(IncSet* this, int ch, Panel* panel, IncMode_GetPanelValue getPanelValue, Vector* lines);\n\nconst char* IncSet_getListItemValue(Panel* panel, int i);\n\nvoid IncSet_activate(IncSet* this, IncType type, Panel* panel);\n\nvoid IncSet_drawBar(const IncSet* this, int attr);\n\nint IncSet_synthesizeEvent(IncSet* this, int x);\n\n#endif\n"
        },
        {
          "name": "InfoScreen.c",
          "type": "blob",
          "size": 5.1943359375,
          "content": "/*\nhtop - InfoScreen.c\n(C) 2016 Hisham H. Muhammad\n(C) 2020,2022 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"InfoScreen.h\"\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"IncSet.h\"\n#include \"ListItem.h\"\n#include \"Object.h\"\n#include \"ProvideCurses.h\"\n#include \"XUtils.h\"\n\n\nstatic const char* const InfoScreenFunctions[] = {\"Search \", \"Filter \", \"Refresh\", \"Done   \", NULL};\n\nstatic const char* const InfoScreenKeys[] = {\"F3\", \"F4\", \"F5\", \"Esc\"};\n\nstatic const int InfoScreenEvents[] = {KEY_F(3), KEY_F(4), KEY_F(5), 27};\n\nInfoScreen* InfoScreen_init(InfoScreen* this, const Process* process, FunctionBar* bar, int height, const char* panelHeader) {\n   this->process = process;\n   if (!bar) {\n      bar = FunctionBar_new(InfoScreenFunctions, InfoScreenKeys, InfoScreenEvents);\n   }\n   this->display = Panel_new(0, 1, COLS, height, Class(ListItem), false, bar);\n   this->inc = IncSet_new(bar);\n   this->lines = Vector_new(Vector_type(this->display->items), true, DEFAULT_SIZE);\n   Panel_setHeader(this->display, panelHeader);\n   return this;\n}\n\nInfoScreen* InfoScreen_done(InfoScreen* this) {\n   Panel_delete((Object*)this->display);\n   IncSet_delete(this->inc);\n   Vector_delete(this->lines);\n   return this;\n}\n\nvoid InfoScreen_drawTitled(InfoScreen* this, const char* fmt, ...) {\n   va_list ap;\n   va_start(ap, fmt);\n\n   char title[COLS + 1];\n   int len = vsnprintf(title, sizeof(title), fmt, ap);\n   va_end(ap);\n\n   if (len > COLS) {\n      memset(&title[COLS - 3], '.', 3);\n   }\n\n   attrset(CRT_colors[METER_TEXT]);\n   mvhline(0, 0, ' ', COLS);\n   mvaddstr(0, 0, title);\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   Panel_draw(this->display, true, true, true, false);\n\n   IncSet_drawBar(this->inc, CRT_colors[FUNCTION_BAR]);\n}\n\nvoid InfoScreen_addLine(InfoScreen* this, const char* line) {\n   Vector_add(this->lines, (Object*) ListItem_new(line, 0));\n   const char* incFilter = IncSet_filter(this->inc);\n   if (!incFilter || String_contains_i(line, incFilter, true)) {\n      Panel_add(this->display, Vector_get(this->lines, Vector_size(this->lines) - 1));\n   }\n}\n\nvoid InfoScreen_appendLine(InfoScreen* this, const char* line) {\n   ListItem* last = (ListItem*)Vector_get(this->lines, Vector_size(this->lines) - 1);\n   ListItem_append(last, line);\n   const char* incFilter = IncSet_filter(this->inc);\n   if (incFilter && Panel_get(this->display, Panel_size(this->display) - 1) != (Object*)last && String_contains_i(line, incFilter, true)) {\n      Panel_add(this->display, (Object*)last);\n   }\n}\n\nvoid InfoScreen_run(InfoScreen* this) {\n   Panel* panel = this->display;\n\n   if (As_InfoScreen(this)->scan)\n      InfoScreen_scan(this);\n\n   InfoScreen_draw(this);\n\n   bool looping = true;\n   while (looping) {\n\n      Panel_draw(panel, false, true, true, false);\n      IncSet_drawBar(this->inc, CRT_colors[FUNCTION_BAR]);\n\n      int ch = Panel_getCh(panel);\n\n      if (ch == ERR) {\n         if (As_InfoScreen(this)->onErr) {\n            InfoScreen_onErr(this);\n            continue;\n         }\n      }\n\n#ifdef HAVE_GETMOUSE\n      if (ch == KEY_MOUSE) {\n         MEVENT mevent;\n         int ok = getmouse(&mevent);\n         if (ok == OK) {\n            if (mevent.bstate & BUTTON1_RELEASED) {\n               if (mevent.y >= panel->y && mevent.y < LINES - 1) {\n                  Panel_setSelected(panel, mevent.y - panel->y + panel->scrollV - 1);\n                  ch = 0;\n               } else if (mevent.y == LINES - 1) {\n                  ch = IncSet_synthesizeEvent(this->inc, mevent.x);\n               }\n            }\n            #if NCURSES_MOUSE_VERSION > 1\n            else if (mevent.bstate & BUTTON4_PRESSED) {\n               ch = KEY_WHEELUP;\n            } else if (mevent.bstate & BUTTON5_PRESSED) {\n               ch = KEY_WHEELDOWN;\n            }\n            #endif\n         }\n      }\n#endif\n\n      if (this->inc->active) {\n         IncSet_handleKey(this->inc, ch, panel, IncSet_getListItemValue, this->lines);\n         continue;\n      }\n\n      switch (ch) {\n         case ERR:\n            continue;\n         case KEY_F(3):\n         case '/':\n            IncSet_activate(this->inc, INC_SEARCH, panel);\n            break;\n         case KEY_F(4):\n         case '\\\\':\n            IncSet_activate(this->inc, INC_FILTER, panel);\n            break;\n         case KEY_F(5):\n            clear();\n            if (As_InfoScreen(this)->scan) {\n               Vector_prune(this->lines);\n               InfoScreen_scan(this);\n            }\n\n            InfoScreen_draw(this);\n            break;\n         case '\\014': // Ctrl+L\n            clear();\n            InfoScreen_draw(this);\n            break;\n         case 27:\n         case 'q':\n         case KEY_F(10):\n            looping = false;\n            break;\n         case KEY_RESIZE:\n            Panel_resize(panel, COLS, LINES - 2);\n            if (As_InfoScreen(this)->scan) {\n               Vector_prune(this->lines);\n               InfoScreen_scan(this);\n            }\n\n            InfoScreen_draw(this);\n            break;\n         default:\n            if (As_InfoScreen(this)->onKey && InfoScreen_onKey(this, ch)) {\n               continue;\n            }\n            Panel_onKey(panel, ch);\n      }\n   }\n}\n"
        },
        {
          "name": "InfoScreen.h",
          "type": "blob",
          "size": 1.7998046875,
          "content": "#ifndef HEADER_InfoScreen\n#define HEADER_InfoScreen\n/*\nhtop - InfoScreen.h\n(C) 2016 Hisham H. Muhammad\n(C) 2020,2022 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"FunctionBar.h\"\n#include \"IncSet.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"Panel.h\"\n#include \"Process.h\"\n#include \"Vector.h\"\n\n\ntypedef struct InfoScreen_ {\n   Object super;\n   const Process* process;\n   Panel* display;\n   IncSet* inc;\n   Vector* lines;\n} InfoScreen;\n\ntypedef void(*InfoScreen_Scan)(InfoScreen*);\ntypedef void(*InfoScreen_Draw)(InfoScreen*);\ntypedef void(*InfoScreen_OnErr)(InfoScreen*);\ntypedef bool(*InfoScreen_OnKey)(InfoScreen*, int);\n\ntypedef struct InfoScreenClass_ {\n   const ObjectClass super;\n   const InfoScreen_Scan scan;\n   const InfoScreen_Draw draw;\n   const InfoScreen_OnErr onErr;\n   const InfoScreen_OnKey onKey;\n} InfoScreenClass;\n\n#define As_InfoScreen(this_)          ((const InfoScreenClass*)(((InfoScreen*)(this_))->super.klass))\n#define InfoScreen_scan(this_)        As_InfoScreen(this_)->scan((InfoScreen*)(this_))\n#define InfoScreen_draw(this_)        As_InfoScreen(this_)->draw((InfoScreen*)(this_))\n#define InfoScreen_onErr(this_)       As_InfoScreen(this_)->onErr((InfoScreen*)(this_))\n#define InfoScreen_onKey(this_, ch_)  As_InfoScreen(this_)->onKey((InfoScreen*)(this_), ch_)\n\nInfoScreen* InfoScreen_init(InfoScreen* this, const Process* process, FunctionBar* bar, int height, const char* panelHeader);\n\nInfoScreen* InfoScreen_done(InfoScreen* this);\n\nATTR_FORMAT(printf, 2, 3)\nvoid InfoScreen_drawTitled(InfoScreen* this, const char* fmt, ...);\n\nvoid InfoScreen_addLine(InfoScreen* this, const char* line);\n\nvoid InfoScreen_appendLine(InfoScreen* this, const char* line);\n\nvoid InfoScreen_run(InfoScreen* this);\n\n#endif\n"
        },
        {
          "name": "ListItem.c",
          "type": "blob",
          "size": 1.7724609375,
          "content": "/*\nhtop - ListItem.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"ListItem.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"RichString.h\"\n#include \"XUtils.h\"\n\n\nvoid ListItem_delete(Object* cast) {\n   ListItem* this = (ListItem*)cast;\n   free(this->value);\n   free(this);\n}\n\nvoid ListItem_display(const Object* cast, RichString* out) {\n   const ListItem* const this = (const ListItem*)cast;\n   assert (this != NULL);\n\n   if (this->moving) {\n      RichString_writeWide(out, CRT_colors[DEFAULT_COLOR],\n#ifdef HAVE_LIBNCURSESW\n                           CRT_utf8 ? \"â \" :\n#endif\n                           \"+ \");\n   }\n   RichString_appendWide(out, CRT_colors[DEFAULT_COLOR], this->value);\n}\n\nvoid ListItem_init(ListItem* this, const char* value, int key) {\n   this->value = xStrdup(value);\n   this->key = key;\n   this->moving = false;\n}\n\nListItem* ListItem_new(const char* value, int key) {\n   ListItem* this = AllocThis(ListItem);\n   ListItem_init(this, value, key);\n   return this;\n}\n\nvoid ListItem_append(ListItem* this, const char* text) {\n   size_t oldLen = strlen(this->value);\n   size_t textLen = strlen(text);\n   size_t newLen = oldLen + textLen;\n   this->value = xRealloc(this->value, newLen + 1);\n   memcpy(this->value + oldLen, text, textLen);\n   this->value[newLen] = '\\0';\n}\n\nint ListItem_compare(const void* cast1, const void* cast2) {\n   const ListItem* obj1 = (const ListItem*) cast1;\n   const ListItem* obj2 = (const ListItem*) cast2;\n   return strcmp(obj1->value, obj2->value);\n}\n\nconst ObjectClass ListItem_class = {\n   .display = ListItem_display,\n   .delete = ListItem_delete,\n   .compare = ListItem_compare\n};\n"
        },
        {
          "name": "ListItem.h",
          "type": "blob",
          "size": 0.828125,
          "content": "#ifndef HEADER_ListItem\n#define HEADER_ListItem\n/*\nhtop - ListItem.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Object.h\"\n#include \"RichString.h\"\n\n\ntypedef struct ListItem_ {\n   Object super;\n   char* value;\n   int key;\n   bool moving;\n} ListItem;\n\nextern const ObjectClass ListItem_class;\n\nvoid ListItem_delete(Object* cast);\n\nvoid ListItem_display(const Object* cast, RichString* out);\n\nvoid ListItem_init(ListItem* this, const char* value, int key);\n\nListItem* ListItem_new(const char* value, int key);\n\nvoid ListItem_append(ListItem* this, const char* text);\n\nint ListItem_compare(const void* cast1, const void* cast2);\n\nstatic inline const char* ListItem_getRef(const ListItem* this) {\n   return this->value;\n}\n\n#endif\n"
        },
        {
          "name": "LoadAverageMeter.c",
          "type": "blob",
          "size": 3.919921875,
          "content": "/*\nhtop - LoadAverageMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"LoadAverageMeter.h\"\n\n#include \"CRT.h\"\n#include \"Machine.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"RichString.h\"\n#include \"XUtils.h\"\n\n\nstatic const int LoadAverageMeter_attributes[] = {\n   LOAD_AVERAGE_ONE,\n   LOAD_AVERAGE_FIVE,\n   LOAD_AVERAGE_FIFTEEN\n};\n\nstatic const int LoadMeter_attributes[] = {\n   LOAD\n};\n\nstatic const int OK_attributes[] = {\n   METER_VALUE_OK\n};\n\nstatic const int Medium_attributes[] = {\n   METER_VALUE_WARN\n};\n\nstatic const int High_attributes[] = {\n   METER_VALUE_ERROR\n};\n\nstatic void LoadAverageMeter_updateValues(Meter* this) {\n   Platform_getLoadAverage(&this->values[0], &this->values[1], &this->values[2]);\n\n   // only show bar for 1min value\n   this->curItems = 1;\n\n   // change bar color and total based on value\n   if (this->values[0] < 1.0) {\n      this->curAttributes = OK_attributes;\n      this->total = 1.0;\n   } else if (this->values[0] < this->host->activeCPUs) {\n      this->curAttributes = Medium_attributes;\n      this->total = this->host->activeCPUs;\n   } else {\n      this->curAttributes = High_attributes;\n      this->total = 2 * this->host->activeCPUs;\n   }\n\n   xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"%.2f/%.2f/%.2f\", this->values[0], this->values[1], this->values[2]);\n}\n\nstatic void LoadAverageMeter_display(const Object* cast, RichString* out) {\n   const Meter* this = (const Meter*)cast;\n   char buffer[20];\n   int len;\n\n   len = xSnprintf(buffer, sizeof(buffer), \"%.2f \", this->values[0]);\n   RichString_appendnAscii(out, CRT_colors[LOAD_AVERAGE_ONE], buffer, len);\n   len = xSnprintf(buffer, sizeof(buffer), \"%.2f \", this->values[1]);\n   RichString_appendnAscii(out, CRT_colors[LOAD_AVERAGE_FIVE], buffer, len);\n   len = xSnprintf(buffer, sizeof(buffer), \"%.2f \", this->values[2]);\n   RichString_appendnAscii(out, CRT_colors[LOAD_AVERAGE_FIFTEEN], buffer, len);\n}\n\nstatic void LoadMeter_updateValues(Meter* this) {\n   double five, fifteen;\n   Platform_getLoadAverage(&this->values[0], &five, &fifteen);\n\n   // change bar color and total based on value\n   if (this->values[0] < 1.0) {\n      this->curAttributes = OK_attributes;\n      this->total = 1.0;\n   } else if (this->values[0] < this->host->activeCPUs) {\n      this->curAttributes = Medium_attributes;\n      this->total = this->host->activeCPUs;\n   } else {\n      this->curAttributes = High_attributes;\n      this->total = 2 * this->host->activeCPUs;\n   }\n\n   xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"%.2f\", this->values[0]);\n}\n\nstatic void LoadMeter_display(const Object* cast, RichString* out) {\n   const Meter* this = (const Meter*)cast;\n   char buffer[20];\n   int len;\n\n   len = xSnprintf(buffer, sizeof(buffer), \"%.2f \", this->values[0]);\n   RichString_appendnAscii(out, CRT_colors[LOAD], buffer, len);\n}\n\nconst MeterClass LoadAverageMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = LoadAverageMeter_display,\n   },\n   .updateValues = LoadAverageMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = 3,\n   .total = 100.0,\n   .attributes = LoadAverageMeter_attributes,\n   .name = \"LoadAverage\",\n   .uiName = \"Load average\",\n   .description = \"Load averages: 1 minute, 5 minutes, 15 minutes\",\n   .caption = \"Load average: \"\n};\n\nconst MeterClass LoadMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = LoadMeter_display,\n   },\n   .updateValues = LoadMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = 1,\n   .total = 100.0,\n   .attributes = LoadMeter_attributes,\n   .name = \"Load\",\n   .uiName = \"Load\",\n   .description = \"Load: average of ready processes in the last minute\",\n   .caption = \"Load: \"\n};\n"
        },
        {
          "name": "LoadAverageMeter.h",
          "type": "blob",
          "size": 0.3388671875,
          "content": "#ifndef HEADER_LoadAverageMeter\n#define HEADER_LoadAverageMeter\n/*\nhtop - LoadAverageMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n\nextern const MeterClass LoadAverageMeter_class;\n\nextern const MeterClass LoadMeter_class;\n\n#endif\n"
        },
        {
          "name": "Machine.c",
          "type": "blob",
          "size": 3.5517578125,
          "content": "/*\nhtop - Machine.c\n(C) 2023 Red Hat, Inc.\n(C) 2004,2005 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Machine.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"Row.h\"\n#include \"XUtils.h\"\n\n\nvoid Machine_init(Machine* this, UsersTable* usersTable, uid_t userId) {\n   this->usersTable = usersTable;\n   this->userId = userId;\n\n   this->htopUserId = getuid();\n\n   // discover fixed column width limits\n   Row_setPidColumnWidth(Platform_getMaxPid());\n\n   // always maintain valid realtime timestamps\n   Platform_gettime_realtime(&this->realtime, &this->realtimeMs);\n\n#ifdef HAVE_LIBHWLOC\n   this->topologyOk = false;\n   if (hwloc_topology_init(&this->topology) == 0) {\n      this->topologyOk =\n         #if HWLOC_API_VERSION < 0x00020000\n         /* try to ignore the top-level machine object type */\n         0 == hwloc_topology_ignore_type_keep_structure(this->topology, HWLOC_OBJ_MACHINE) &&\n         /* ignore caches, which don't add structure */\n         0 == hwloc_topology_ignore_type_keep_structure(this->topology, HWLOC_OBJ_CORE) &&\n         0 == hwloc_topology_ignore_type_keep_structure(this->topology, HWLOC_OBJ_CACHE) &&\n         0 == hwloc_topology_set_flags(this->topology, HWLOC_TOPOLOGY_FLAG_WHOLE_SYSTEM) &&\n         #else\n         0 == hwloc_topology_set_all_types_filter(this->topology, HWLOC_TYPE_FILTER_KEEP_STRUCTURE) &&\n         #endif\n         0 == hwloc_topology_load(this->topology);\n   }\n#endif\n}\n\nvoid Machine_done(Machine* this) {\n#ifdef HAVE_LIBHWLOC\n   if (this->topologyOk) {\n      hwloc_topology_destroy(this->topology);\n   }\n#endif\n   Object_delete(this->processTable);\n   free(this->tables);\n}\n\nstatic void Machine_addTable(Machine* this, Table* table) {\n   /* check that this table has not been seen previously */\n   for (size_t i = 0; i < this->tableCount; i++)\n      if (this->tables[i] == table)\n         return;\n\n   size_t nmemb = this->tableCount + 1;\n   Table** tables = xReallocArray(this->tables, nmemb, sizeof(Table*));\n   tables[nmemb - 1] = table;\n   this->tables = tables;\n   this->tableCount++;\n}\n\nvoid Machine_populateTablesFromSettings(Machine* this, Settings* settings, Table* processTable) {\n   this->settings = settings;\n   this->processTable = processTable;\n\n   for (size_t i = 0; i < settings->nScreens; i++) {\n      ScreenSettings* ss = settings->screens[i];\n      Table* table = ss->table;\n      if (!table)\n         table = ss->table = processTable;\n      if (i == 0)\n         this->activeTable = table;\n\n      Machine_addTable(this, table);\n   }\n}\n\nvoid Machine_setTablesPanel(Machine* this, Panel* panel) {\n   for (size_t i = 0; i < this->tableCount; i++) {\n      Table_setPanel(this->tables[i], panel);\n   }\n}\n\nvoid Machine_scanTables(Machine* this) {\n   // set scan timestamp\n   static bool firstScanDone = false;\n\n   if (firstScanDone) {\n      this->prevMonotonicMs = this->monotonicMs;\n      Platform_gettime_monotonic(&this->monotonicMs);\n   } else {\n      this->prevMonotonicMs = 0;\n      this->monotonicMs = 1;\n      firstScanDone = true;\n   }\n   assert(this->monotonicMs > this->prevMonotonicMs);\n\n   this->maxUserId = 0;\n   Row_resetFieldWidths();\n\n   for (size_t i = 0; i < this->tableCount; i++) {\n      Table* table = this->tables[i];\n\n      // pre-processing of each row\n      Table_scanPrepare(table);\n\n      // scan values for this table\n      Table_scanIterate(table);\n\n      // post-process after scanning\n      Table_scanCleanup(table);\n   }\n\n   Row_setUidColumnWidth(this->maxUserId);\n}\n"
        },
        {
          "name": "Machine.h",
          "type": "blob",
          "size": 2.0673828125,
          "content": "#ifndef HEADER_Machine\n#define HEADER_Machine\n/*\nhtop - Machine.h\n(C) 2023 Red Hat, Inc.\n(C) 2004,2005 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/time.h>\n#include <sys/types.h>\n\n#include \"Panel.h\"\n#include \"Settings.h\"\n#include \"Table.h\"\n#include \"UsersTable.h\"\n\n#ifdef HAVE_LIBHWLOC\n#include <hwloc.h>\n#endif\n\n\n#ifndef MAX_NAME\n#define MAX_NAME 128\n#endif\n\n#ifndef MAX_READ\n#define MAX_READ 2048\n#endif\n\ntypedef unsigned long long int memory_t;\n#define MEMORY_MAX ULLONG_MAX\n\ntypedef struct Machine_ {\n   struct Settings_* settings;\n\n   struct timeval realtime;   /* time of the current sample */\n   uint64_t realtimeMs;       /* current time in milliseconds */\n   uint64_t monotonicMs;      /* same, but from monotonic clock */\n   uint64_t prevMonotonicMs;  /* time in milliseconds from monotonic clock of previous scan */\n\n   int64_t iterationsRemaining;\n\n   #ifdef HAVE_LIBHWLOC\n   hwloc_topology_t topology;\n   bool topologyOk;\n   #endif\n\n   memory_t totalMem;\n   memory_t usedMem;\n   memory_t buffersMem;\n   memory_t cachedMem;\n   memory_t sharedMem;\n   memory_t availableMem;\n\n   memory_t totalSwap;\n   memory_t usedSwap;\n   memory_t cachedSwap;\n\n   unsigned int activeCPUs;\n   unsigned int existingCPUs;\n\n   UsersTable* usersTable;\n   uid_t htopUserId;\n   uid_t maxUserId;  /* recently observed */\n   uid_t userId;  /* selected row user ID */\n\n   size_t tableCount;\n   Table **tables;\n   Table *activeTable;\n   Table *processTable;\n} Machine;\n\n\nMachine* Machine_new(UsersTable* usersTable, uid_t userId);\n\nvoid Machine_init(Machine* this, UsersTable* usersTable, uid_t userId);\n\nvoid Machine_delete(Machine* this);\n\nvoid Machine_done(Machine* this);\n\nbool Machine_isCPUonline(const Machine* this, unsigned int id);\n\nvoid Machine_populateTablesFromSettings(Machine* this, Settings* settings, Table* processTable);\n\nvoid Machine_setTablesPanel(Machine* this, Panel* panel);\n\nvoid Machine_scan(Machine* this);\n\nvoid Machine_scanTables(Machine* this);\n\n#endif\n"
        },
        {
          "name": "Macros.h",
          "type": "blob",
          "size": 4.44140625,
          "content": "#ifndef HEADER_Macros\n#define HEADER_Macros\n/*\nhtop - Macros.h\n(C) 2020-2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <assert.h> // IWYU pragma: keep\n#include <math.h>\n#include <stdbool.h>\n#include <string.h> // IWYU pragma: keep\n\n\n#ifndef MINIMUM\n#define MINIMUM(a, b)                  ((a) < (b) ? (a) : (b))\n#endif\n\n#ifndef MAXIMUM\n#define MAXIMUM(a, b)                  ((a) > (b) ? (a) : (b))\n#endif\n\n#ifndef CLAMP\n#define CLAMP(x, low, high)            (assert((low) <= (high)), ((x) > (high)) ? (high) : MAXIMUM(x, low))\n#endif\n\n#ifndef ARRAYSIZE\n#define ARRAYSIZE(x)                   (sizeof(x) / sizeof((x)[0]))\n#endif\n\n#ifndef SPACESHIP_NUMBER\n#define SPACESHIP_NUMBER(a, b)         (((a) > (b)) - ((a) < (b)))\n#endif\n\n#ifndef SPACESHIP_NULLSTR\n#define SPACESHIP_NULLSTR(a, b)        strcmp((a) ? (a) : \"\", (b) ? (b) : \"\")\n#endif\n\n#ifndef SPACESHIP_DEFAULTSTR\n#define SPACESHIP_DEFAULTSTR(a, b, s)  strcmp((a) ? (a) : (s), (b) ? (b) : (s))\n#endif\n\n#ifdef  __GNUC__  // defined by GCC and Clang\n\n#define ATTR_FORMAT(type, index, check) __attribute__((format (type, index, check)))\n#define ATTR_NORETURN                   __attribute__((noreturn))\n#define ATTR_UNUSED                     __attribute__((unused))\n#define ATTR_MALLOC                     __attribute__((malloc))\n\n#else /* __GNUC__ */\n\n#define ATTR_FORMAT(type, index, check)\n#define ATTR_NORETURN\n#define ATTR_UNUSED\n#define ATTR_MALLOC\n\n#endif /* __GNUC__ */\n\n#ifdef HAVE_ATTR_NONNULL\n\n#define ATTR_NONNULL                    __attribute__((nonnull))\n#define ATTR_NONNULL_N(...)             __attribute__((nonnull(__VA_ARGS__)))\n\n#else\n\n#define ATTR_NONNULL\n#define ATTR_NONNULL_N(...)\n\n#endif /* HAVE_ATTR_NONNULL */\n\n#ifdef HAVE_ATTR_RETNONNULL\n\n#define ATTR_RETNONNULL                 __attribute__((returns_nonnull))\n\n#else\n\n#define ATTR_RETNONNULL\n\n#endif /* HAVE_ATTR_RETNONNULL */\n\n#ifdef HAVE_ATTR_ALLOC_SIZE\n\n#define ATTR_ALLOC_SIZE1(a)             __attribute__((alloc_size (a)))\n#define ATTR_ALLOC_SIZE2(a, b)          __attribute__((alloc_size (a, b)))\n\n#else\n\n#define ATTR_ALLOC_SIZE1(a)\n#define ATTR_ALLOC_SIZE2(a, b)\n\n#endif /* HAVE_ATTR_ALLOC_SIZE */\n\n#ifdef HAVE_ATTR_ACCESS\n\n#define ATTR_ACCESS2(mode, ref)         __attribute__((access (mode, ref)))\n#define ATTR_ACCESS3(mode, ref, size)   __attribute__((access (mode, ref, size)))\n\n#else\n\n#define ATTR_ACCESS2(mode, ref)\n#define ATTR_ACCESS3(mode, ref, size)\n\n#endif /* HAVE_ATTR_ACCESS */\n\n#define ATTR_ACCESS2_R(ref)              ATTR_ACCESS2(read_only, ref)\n#define ATTR_ACCESS3_R(ref, size)        ATTR_ACCESS3(read_only, ref, size)\n\n#define ATTR_ACCESS2_RW(ref)             ATTR_ACCESS2(read_write, ref)\n#define ATTR_ACCESS3_RW(ref, size)       ATTR_ACCESS3(read_write, ref, size)\n\n#define ATTR_ACCESS2_W(ref)              ATTR_ACCESS2(write_only, ref)\n#define ATTR_ACCESS3_W(ref, size)        ATTR_ACCESS3(write_only, ref, size)\n\n// ignore casts discarding const specifier, e.g.\n//     const char []     ->  char * / void *\n//     const char *[2]'  ->  char *const *\n#if defined(__clang__)\n#define IGNORE_WCASTQUAL_BEGIN  _Pragma(\"clang diagnostic push\") \\\n                                _Pragma(\"clang diagnostic ignored \\\"-Wcast-qual\\\"\")\n#define IGNORE_WCASTQUAL_END    _Pragma(\"clang diagnostic pop\")\n#elif defined(__GNUC__)\n#define IGNORE_WCASTQUAL_BEGIN  _Pragma(\"GCC diagnostic push\") \\\n                                _Pragma(\"GCC diagnostic ignored \\\"-Wcast-qual\\\"\")\n#define IGNORE_WCASTQUAL_END    _Pragma(\"GCC diagnostic pop\")\n#else\n#define IGNORE_WCASTQUAL_BEGIN\n#define IGNORE_WCASTQUAL_END\n#endif\n\n/* Cheaper function for checking NaNs. Unlike the standard isnan(), this may\n   throw an FP exception on a \"signaling NaN\".\n   (ISO/IEC TS 18661-1 and the C23 standard stated that isnan() throws no\n   exceptions even with a \"signaling NaN\") */\nstatic inline bool isNaN(double x) {\n   return !isgreaterequal(x, x);\n}\n\n/* Checks if x >= 0.0 but returns false if x is NaN. Because IEEE 754 considers\n   -0.0 == 0.0, this function treats both zeros as nonnegative. */\nstatic inline bool isNonnegative(double x) {\n   return isgreaterequal(x, 0.0);\n}\n\n/* Checks if x > 0.0 but returns false if x is NaN. */\nstatic inline bool isPositive(double x) {\n   return isgreater(x, 0.0);\n}\n\n/* This subtraction is used by Linux / NetBSD / OpenBSD for calculation of CPU usage items. */\nstatic inline unsigned long long saturatingSub(unsigned long long a, unsigned long long b) {\n   return a > b ? a - b : 0;\n}\n\n#endif\n"
        },
        {
          "name": "MainPanel.c",
          "type": "blob",
          "size": 7.5078125,
          "content": "/*\nhtop - ColumnsPanel.c\n(C) 2004-2015 Hisham H. Muhammad\n(C) 2020 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"MainPanel.h\"\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Machine.h\"\n#include \"Platform.h\"\n#include \"ProvideCurses.h\"\n#include \"Row.h\"\n#include \"RowField.h\"\n#include \"Settings.h\"\n#include \"Table.h\"\n#include \"XUtils.h\"\n\n\nstatic const char* const MainFunctions[]     = {\"Help  \", \"Setup \", \"Search\", \"Filter\", \"Tree  \", \"SortBy\", \"Nice -\", \"Nice +\", \"Kill  \", \"Quit  \", NULL};\nstatic const char* const MainFunctions_ro[]  = {\"Help  \", \"Setup \", \"Search\", \"Filter\", \"Tree  \", \"SortBy\", \"      \", \"      \", \"      \", \"Quit  \", NULL};\n\nvoid MainPanel_updateLabels(MainPanel* this, bool list, bool filter) {\n   FunctionBar* bar = MainPanel_getFunctionBar(this);\n   FunctionBar_setLabel(bar, KEY_F(5), list   ? \"List  \" : \"Tree  \");\n   FunctionBar_setLabel(bar, KEY_F(4), filter ? \"FILTER\" : \"Filter\");\n}\n\nstatic void MainPanel_idSearch(MainPanel* this, int ch) {\n   Panel* super = (Panel*) this;\n   pid_t id = ch - 48 + this->idSearch;\n   for (int i = 0; i < Panel_size(super); i++) {\n      const Row* row = (const Row*) Panel_get(super, i);\n      if (row && row->id == id) {\n         Panel_setSelected(super, i);\n         break;\n      }\n   }\n   this->idSearch = id * 10;\n   if (this->idSearch > 10000000) {\n      this->idSearch = 0;\n   }\n}\n\nstatic const char* MainPanel_getValue(Panel* this, int i) {\n   Row* row = (Row*) Panel_get(this, i);\n   return Row_sortKeyString(row);\n}\n\nstatic HandlerResult MainPanel_eventHandler(Panel* super, int ch) {\n   MainPanel* this = (MainPanel*) super;\n   Machine* host = this->state->host;\n   Htop_Reaction reaction = HTOP_OK;\n   HandlerResult result = IGNORED;\n\n   /* Let supervising ScreenManager handle resize */\n   if (ch == KEY_RESIZE)\n      return IGNORED;\n\n   /* reset on every normal key */\n   bool needReset = ch != ERR;\n   #ifdef HAVE_GETMOUSE\n   /* except mouse events while mouse support is disabled */\n   if (!(ch != KEY_MOUSE || host->settings->enableMouse))\n      needReset = false;\n   #endif\n   if (needReset)\n      this->state->hideSelection = false;\n\n   Settings* settings = host->settings;\n   ScreenSettings* ss = settings->ss;\n\n   if (EVENT_IS_HEADER_CLICK(ch)) {\n      int x = EVENT_HEADER_CLICK_GET_X(ch);\n      int hx = super->scrollH + x + 1;\n      RowField field = RowField_keyAt(settings, hx);\n      if (ss->treeView && ss->treeViewAlwaysByPID) {\n         ss->treeView = false;\n         ss->direction = 1;\n         reaction |= Action_setSortKey(settings, field);\n      } else if (field == ScreenSettings_getActiveSortKey(ss)) {\n         ScreenSettings_invertSortOrder(ss);\n      } else {\n         reaction |= Action_setSortKey(settings, field);\n      }\n      reaction |= HTOP_RECALCULATE | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR | HTOP_SAVE_SETTINGS;\n      result = HANDLED;\n   } else if (EVENT_IS_SCREEN_TAB_CLICK(ch)) {\n      int x = EVENT_SCREEN_TAB_GET_X(ch);\n      reaction |= Action_setScreenTab(this->state, x);\n      result = HANDLED;\n   } else if (ch != ERR && this->inc->active) {\n      bool filterChanged = IncSet_handleKey(this->inc, ch, super, MainPanel_getValue, NULL);\n      if (filterChanged) {\n         host->activeTable->incFilter = IncSet_filter(this->inc);\n         reaction = HTOP_REFRESH | HTOP_REDRAW_BAR;\n      }\n      if (this->inc->found) {\n         reaction |= Action_follow(this->state);\n         reaction |= HTOP_KEEP_FOLLOWING;\n      }\n      result = HANDLED;\n   } else if (ch == 27) {\n      this->state->hideSelection = true;\n      return HANDLED;\n   } else if (ch != ERR && ch > 0 && ch < KEY_MAX && this->keys[ch]) {\n      reaction |= (this->keys[ch])(this->state);\n      result = HANDLED;\n   } else if (0 < ch && ch < 255 && isdigit((unsigned char)ch)) {\n      MainPanel_idSearch(this, ch);\n   } else {\n      if (ch != ERR) {\n         this->idSearch = 0;\n      } else {\n         reaction |= HTOP_KEEP_FOLLOWING;\n      }\n   }\n\n   if ((reaction & HTOP_REDRAW_BAR) == HTOP_REDRAW_BAR) {\n      MainPanel_updateLabels(this, settings->ss->treeView, host->activeTable->incFilter);\n   }\n   if ((reaction & HTOP_RESIZE) == HTOP_RESIZE) {\n      result |= RESIZE;\n   }\n   if ((reaction & HTOP_UPDATE_PANELHDR) == HTOP_UPDATE_PANELHDR) {\n      result |= REDRAW;\n   }\n   if ((reaction & HTOP_REFRESH) == HTOP_REFRESH) {\n      result |= REFRESH;\n   }\n   if ((reaction & HTOP_RECALCULATE) == HTOP_RECALCULATE) {\n      result |= RESCAN;\n   }\n   if ((reaction & HTOP_SAVE_SETTINGS) == HTOP_SAVE_SETTINGS) {\n      host->settings->changed = true;\n   }\n   if ((reaction & HTOP_QUIT) == HTOP_QUIT) {\n      return BREAK_LOOP;\n   }\n   if ((reaction & HTOP_KEEP_FOLLOWING) != HTOP_KEEP_FOLLOWING) {\n      host->activeTable->following = -1;\n      Panel_setSelectionColor(super, PANEL_SELECTION_FOCUS);\n   }\n   return result;\n}\n\nint MainPanel_selectedRow(MainPanel* this) {\n   const Row* row = (const Row*) Panel_getSelected((Panel*)this);\n   return row ? row->id : -1;\n}\n\nbool MainPanel_foreachRow(MainPanel* this, MainPanel_foreachRowFn fn, Arg arg, bool* wasAnyTagged) {\n   Panel* super = (Panel*) this;\n   bool ok = true;\n   bool anyTagged = false;\n   for (int i = 0; i < Panel_size(super); i++) {\n      Row* row = (Row*) Panel_get(super, i);\n      if (row->tag) {\n         ok &= fn(row, arg);\n         anyTagged = true;\n      }\n   }\n   if (!anyTagged) {\n      Row* row = (Row*) Panel_getSelected(super);\n      if (row) {\n         ok &= fn(row, arg);\n      }\n   }\n\n   if (wasAnyTagged)\n      *wasAnyTagged = anyTagged;\n\n   return ok;\n}\n\nstatic void MainPanel_drawFunctionBar(Panel* super, bool hideFunctionBar) {\n   MainPanel* this = (MainPanel*) super;\n\n   // Do not hide active search and filter bar.\n   if (hideFunctionBar && !this->inc->active)\n      return;\n\n   IncSet_drawBar(this->inc, CRT_colors[FUNCTION_BAR]);\n   if (this->state->pauseUpdate) {\n      FunctionBar_append(\"PAUSED\", CRT_colors[PAUSED]);\n   }\n}\n\nstatic void MainPanel_printHeader(Panel* super) {\n   MainPanel* this = (MainPanel*) super;\n   Machine* host = this->state->host;\n   Table_printHeader(host->settings, &super->header);\n}\n\nconst PanelClass MainPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = MainPanel_delete\n   },\n   .eventHandler = MainPanel_eventHandler,\n   .drawFunctionBar = MainPanel_drawFunctionBar,\n   .printHeader = MainPanel_printHeader\n};\n\nMainPanel* MainPanel_new(void) {\n   MainPanel* this = AllocThis(MainPanel);\n   this->processBar = FunctionBar_new(MainFunctions, NULL, NULL);\n   this->readonlyBar = FunctionBar_new(MainFunctions_ro, NULL, NULL);\n   FunctionBar* activeBar = Settings_isReadonly() ? this->readonlyBar : this->processBar;\n   Panel_init((Panel*) this, 1, 1, 1, 1, Class(Row), false, activeBar);\n   this->keys = xCalloc(KEY_MAX, sizeof(Htop_Action));\n   this->inc = IncSet_new(activeBar);\n\n   Action_setBindings(this->keys);\n   Platform_setBindings(this->keys);\n\n   return this;\n}\n\nvoid MainPanel_setState(MainPanel* this, State* state) {\n   this->state = state;\n}\n\nvoid MainPanel_setFunctionBar(MainPanel* this, bool readonly) {\n   this->super.defaultBar = readonly ? this->readonlyBar : this->processBar;\n   this->inc->defaultBar = this->super.defaultBar;\n}\n\nvoid MainPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   MainPanel* this = (MainPanel*) object;\n   MainPanel_setFunctionBar(this, false);\n   FunctionBar_delete(this->readonlyBar);\n   Panel_done(super);\n   IncSet_delete(this->inc);\n   free(this->keys);\n   free(this);\n}\n"
        },
        {
          "name": "MainPanel.h",
          "type": "blob",
          "size": 1.3564453125,
          "content": "#ifndef HEADER_MainPanel\n#define HEADER_MainPanel\n/*\nhtop - ColumnsPanel.h\n(C) 2004-2015 Hisham H. Muhammad\n(C) 2020 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Action.h\"\n#include \"FunctionBar.h\"\n#include \"IncSet.h\"\n#include \"Object.h\"\n#include \"Panel.h\"\n#include \"Row.h\"\n\n\ntypedef struct MainPanel_ {\n   Panel super;\n   State* state;\n   IncSet* inc;\n   Htop_Action* keys;\n   FunctionBar* processBar;  /* function bar with process-specific actions */\n   FunctionBar* readonlyBar;  /* function bar without process actions (ro) */\n   unsigned int idSearch;\n} MainPanel;\n\ntypedef bool(*MainPanel_foreachRowFn)(Row*, Arg);\n\n#define MainPanel_getFunctionBar(this_) (((Panel*)(this_))->defaultBar)\n\n// update the Label Keys in the MainPanel bar, list: list / tree mode, filter: filter (inc) active / inactive\nvoid MainPanel_updateLabels(MainPanel* this, bool list, bool filter);\n\nint MainPanel_selectedRow(MainPanel* this);\n\nbool MainPanel_foreachRow(MainPanel* this, MainPanel_foreachRowFn fn, Arg arg, bool* wasAnyTagged);\n\nextern const PanelClass MainPanel_class;\n\nMainPanel* MainPanel_new(void);\n\nvoid MainPanel_setState(MainPanel* this, State* state);\n\nvoid MainPanel_setFunctionBar(MainPanel* this, bool readonly);\n\nvoid MainPanel_delete(Object* object);\n\n#endif\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 11.1005859375,
          "content": "if !HTOP_PCP\nbin_PROGRAMS = htop\nmyhtopplatprogram = htop.c\nelse\nbin_PROGRAMS = pcp-htop\nmyhtopplatprogram = pcp-htop.c\nendif\n\ndist_man_MANS = htop.1\nEXTRA_DIST = \\\n\t$(dist_man_MANS) \\\n\tautogen.sh \\\n\thtop.desktop \\\n\thtop.png \\\n\thtop.svg \\\n\tbuild-aux/compile \\\n\tbuild-aux/depcomp \\\n\tbuild-aux/install-sh \\\n\tbuild-aux/missing\napplicationsdir = $(datadir)/applications\napplications_DATA = htop.desktop\npixmapdir = $(datadir)/pixmaps\npixmap_DATA = htop.png\nappicondir = $(datadir)/icons/hicolor/scalable/apps\nappicon_DATA = htop.svg\n\nAM_CFLAGS += -DSYSCONFDIR=\"\\\"$(sysconfdir)\\\"\" -I\"$(top_srcdir)/$(my_htop_platform)\"\nAM_LDFLAGS =\n\nmyhtopsources = \\\n\tAction.c \\\n\tAffinity.c \\\n\tAffinityPanel.c \\\n\tAvailableColumnsPanel.c \\\n\tAvailableMetersPanel.c \\\n\tBatteryMeter.c \\\n\tCategoriesPanel.c \\\n\tClockMeter.c \\\n\tColorsPanel.c \\\n\tColumnsPanel.c \\\n\tCommandLine.c \\\n\tCommandScreen.c \\\n\tCompat.c \\\n\tCPUMeter.c \\\n\tCRT.c \\\n\tDateMeter.c \\\n\tDateTimeMeter.c \\\n\tDiskIOMeter.c \\\n\tDisplayOptionsPanel.c \\\n\tDynamicColumn.c \\\n\tDynamicMeter.c \\\n\tDynamicScreen.c \\\n\tEnvScreen.c \\\n\tFileDescriptorMeter.c \\\n\tFunctionBar.c \\\n\tHashtable.c \\\n\tHeader.c \\\n\tHeaderOptionsPanel.c \\\n\tHostnameMeter.c \\\n\tIncSet.c \\\n\tInfoScreen.c \\\n\tListItem.c \\\n\tLoadAverageMeter.c \\\n\tMachine.c \\\n\tMainPanel.c \\\n\tMemoryMeter.c \\\n\tMemorySwapMeter.c \\\n\tMeter.c \\\n\tMetersPanel.c \\\n\tNetworkIOMeter.c \\\n\tObject.c \\\n\tOpenFilesScreen.c \\\n\tOptionItem.c \\\n\tPanel.c \\\n\tProcess.c \\\n\tProcessLocksScreen.c \\\n\tProcessTable.c \\\n\tRow.c \\\n\tRichString.c \\\n\tScheduling.c \\\n\tScreenManager.c \\\n\tScreensPanel.c \\\n\tScreenTabsPanel.c \\\n\tSettings.c \\\n\tSignalsPanel.c \\\n\tSwapMeter.c \\\n\tSysArchMeter.c \\\n\tTable.c \\\n\tTasksMeter.c \\\n\tTraceScreen.c \\\n\tUptimeMeter.c \\\n\tUsersTable.c \\\n\tVector.c \\\n\tXUtils.c\n\nmyhtopheaders = \\\n\tAction.h \\\n\tAffinity.h \\\n\tAffinityPanel.h \\\n\tAvailableColumnsPanel.h \\\n\tAvailableMetersPanel.h \\\n\tBatteryMeter.h \\\n\tCPUMeter.h \\\n\tCRT.h \\\n\tCategoriesPanel.h \\\n\tClockMeter.h \\\n\tColorsPanel.h \\\n\tColumnsPanel.h \\\n\tCommandLine.h \\\n\tCommandScreen.h \\\n\tCompat.h \\\n\tDateMeter.h \\\n\tDateTimeMeter.h \\\n\tDiskIOMeter.h \\\n\tDisplayOptionsPanel.h \\\n\tDynamicColumn.h \\\n\tDynamicMeter.h \\\n\tDynamicScreen.h \\\n\tEnvScreen.h \\\n\tFileDescriptorMeter.h \\\n\tFunctionBar.h \\\n\tHashtable.h \\\n\tHeader.h \\\n\tHeaderLayout.h \\\n\tHeaderOptionsPanel.h \\\n\tHostnameMeter.h \\\n\tIncSet.h \\\n\tInfoScreen.h \\\n\tListItem.h \\\n\tLoadAverageMeter.h \\\n\tMachine.h \\\n\tMacros.h \\\n\tMainPanel.h \\\n\tMemoryMeter.h \\\n\tMemorySwapMeter.h \\\n\tMeter.h \\\n\tMeterMode.h \\\n\tMetersPanel.h \\\n\tNetworkIOMeter.h \\\n\tObject.h \\\n\tOpenFilesScreen.h \\\n\tOptionItem.h \\\n\tPanel.h \\\n\tProcess.h \\\n\tProcessLocksScreen.h \\\n\tProcessTable.h \\\n\tProvideCurses.h \\\n\tProvideTerm.h \\\n\tRichString.h \\\n\tRow.h \\\n\tRowField.h \\\n\tScheduling.h \\\n\tScreenManager.h \\\n\tScreensPanel.h \\\n\tScreenTabsPanel.h \\\n\tSettings.h \\\n\tSignalsPanel.h \\\n\tSwapMeter.h \\\n\tSysArchMeter.h \\\n\tTable.h \\\n\tTasksMeter.h \\\n\tTraceScreen.h \\\n\tUptimeMeter.h \\\n\tUsersTable.h \\\n\tVector.h \\\n\tXUtils.h\n\n# Linux\n# -----\n\nlinux_platform_headers = \\\n\tgeneric/gettime.h \\\n\tgeneric/hostname.h \\\n\tgeneric/uname.h \\\n\tlinux/CGroupUtils.h \\\n\tlinux/GPU.h \\\n\tlinux/GPUMeter.h \\\n\tlinux/HugePageMeter.h \\\n\tlinux/IOPriority.h \\\n\tlinux/IOPriorityPanel.h \\\n\tlinux/LibSensors.h \\\n\tlinux/LinuxMachine.h \\\n\tlinux/LinuxProcess.h \\\n\tlinux/LinuxProcessTable.h \\\n\tlinux/Platform.h \\\n\tlinux/PressureStallMeter.h \\\n\tlinux/ProcessField.h \\\n\tlinux/SELinuxMeter.h \\\n\tlinux/SystemdMeter.h \\\n\tlinux/ZramMeter.h \\\n\tlinux/ZramStats.h \\\n\tlinux/ZswapStats.h \\\n\tzfs/ZfsArcMeter.h \\\n\tzfs/ZfsArcStats.h \\\n\tzfs/ZfsCompressedArcMeter.h\n\nlinux_platform_sources = \\\n\tgeneric/gettime.c \\\n\tgeneric/hostname.c \\\n\tgeneric/uname.c \\\n\tlinux/CGroupUtils.c \\\n\tlinux/GPU.c \\\n\tlinux/GPUMeter.c \\\n\tlinux/HugePageMeter.c \\\n\tlinux/IOPriorityPanel.c \\\n\tlinux/LibSensors.c \\\n\tlinux/LinuxMachine.c \\\n\tlinux/LinuxProcess.c \\\n\tlinux/LinuxProcessTable.c \\\n\tlinux/Platform.c \\\n\tlinux/PressureStallMeter.c \\\n\tlinux/SELinuxMeter.c \\\n\tlinux/SystemdMeter.c \\\n\tlinux/ZramMeter.c \\\n\tzfs/ZfsArcMeter.c \\\n\tzfs/ZfsCompressedArcMeter.c\n\nif HAVE_DELAYACCT\nlinux_platform_headers += linux/LibNl.h\nlinux_platform_sources += linux/LibNl.c\nendif\n\nif HTOP_LINUX\nAM_LDFLAGS += -rdynamic\nmyhtopplatheaders = $(linux_platform_headers)\nmyhtopplatsources = $(linux_platform_sources)\nendif\n\n# FreeBSD\n# -------\n\nfreebsd_platform_headers = \\\n\tfreebsd/FreeBSDMachine.h \\\n\tfreebsd/FreeBSDProcessTable.h \\\n\tfreebsd/FreeBSDProcess.h \\\n\tfreebsd/Platform.h \\\n\tfreebsd/ProcessField.h \\\n\tgeneric/fdstat_sysctl.h \\\n\tgeneric/gettime.h \\\n\tgeneric/hostname.h \\\n\tgeneric/openzfs_sysctl.h \\\n\tgeneric/uname.h \\\n\tzfs/ZfsArcMeter.h \\\n\tzfs/ZfsArcStats.h \\\n\tzfs/ZfsCompressedArcMeter.h\n\nfreebsd_platform_sources = \\\n\tfreebsd/Platform.c \\\n\tfreebsd/FreeBSDMachine.c \\\n\tfreebsd/FreeBSDProcessTable.c \\\n\tfreebsd/FreeBSDProcess.c \\\n\tgeneric/fdstat_sysctl.c \\\n\tgeneric/gettime.c \\\n\tgeneric/hostname.c \\\n\tgeneric/openzfs_sysctl.c \\\n\tgeneric/uname.c \\\n\tzfs/ZfsArcMeter.c \\\n\tzfs/ZfsCompressedArcMeter.c\n\nif HTOP_FREEBSD\nmyhtopplatheaders = $(freebsd_platform_headers)\nmyhtopplatsources = $(freebsd_platform_sources)\nendif\n\n# DragonFlyBSD\n# ------------\n\ndragonflybsd_platform_headers = \\\n\tdragonflybsd/DragonFlyBSDMachine.h \\\n\tdragonflybsd/DragonFlyBSDProcessTable.h \\\n\tdragonflybsd/DragonFlyBSDProcess.h \\\n\tdragonflybsd/Platform.h \\\n\tdragonflybsd/ProcessField.h \\\n\tgeneric/fdstat_sysctl.h \\\n\tgeneric/gettime.h \\\n\tgeneric/hostname.h \\\n\tgeneric/uname.h\n\ndragonflybsd_platform_sources = \\\n\tdragonflybsd/DragonFlyBSDMachine.c \\\n\tdragonflybsd/DragonFlyBSDProcessTable.c \\\n\tdragonflybsd/DragonFlyBSDProcess.c \\\n\tdragonflybsd/Platform.c \\\n\tgeneric/fdstat_sysctl.c \\\n\tgeneric/gettime.c \\\n\tgeneric/hostname.c \\\n\tgeneric/uname.c\n\nif HTOP_DRAGONFLYBSD\nmyhtopplatheaders = $(dragonflybsd_platform_headers)\nmyhtopplatsources = $(dragonflybsd_platform_sources)\nendif\n\n# NetBSD\n# -------\n\nnetbsd_platform_headers = \\\n\tgeneric/fdstat_sysctl.h \\\n\tgeneric/gettime.h \\\n\tgeneric/hostname.h \\\n\tgeneric/uname.h \\\n\tnetbsd/Platform.h \\\n\tnetbsd/ProcessField.h \\\n\tnetbsd/NetBSDMachine.h \\\n\tnetbsd/NetBSDProcess.h \\\n\tnetbsd/NetBSDProcessTable.h\n\nnetbsd_platform_sources = \\\n\tgeneric/fdstat_sysctl.c \\\n\tgeneric/gettime.c \\\n\tgeneric/hostname.c \\\n\tgeneric/uname.c \\\n\tnetbsd/Platform.c \\\n\tnetbsd/NetBSDMachine.c \\\n\tnetbsd/NetBSDProcess.c \\\n\tnetbsd/NetBSDProcessTable.c\n\nif HTOP_NETBSD\nmyhtopplatheaders = $(netbsd_platform_headers)\nmyhtopplatsources = $(netbsd_platform_sources)\nendif\n\n# OpenBSD\n# -------\n\nopenbsd_platform_headers = \\\n\tgeneric/gettime.h \\\n\tgeneric/hostname.h \\\n\tgeneric/uname.h \\\n\topenbsd/OpenBSDMachine.h \\\n\topenbsd/OpenBSDProcessTable.h \\\n\topenbsd/OpenBSDProcess.h \\\n\topenbsd/Platform.h \\\n\topenbsd/ProcessField.h\n\nopenbsd_platform_sources = \\\n\tgeneric/gettime.c \\\n\tgeneric/hostname.c \\\n\tgeneric/uname.c \\\n\topenbsd/OpenBSDMachine.c \\\n\topenbsd/OpenBSDProcessTable.c \\\n\topenbsd/OpenBSDProcess.c \\\n\topenbsd/Platform.c\n\nif HTOP_OPENBSD\nmyhtopplatheaders = $(openbsd_platform_headers)\nmyhtopplatsources = $(openbsd_platform_sources)\nendif\n\n# Darwin\n# ------\n\ndarwin_platform_headers = \\\n\tdarwin/DarwinMachine.h \\\n\tdarwin/DarwinProcess.h \\\n\tdarwin/DarwinProcessTable.h \\\n\tdarwin/Platform.h \\\n\tdarwin/PlatformHelpers.h \\\n\tdarwin/ProcessField.h \\\n\tgeneric/fdstat_sysctl.h \\\n\tgeneric/gettime.h \\\n\tgeneric/hostname.h \\\n\tgeneric/openzfs_sysctl.h \\\n\tgeneric/uname.h \\\n\tzfs/ZfsArcMeter.h \\\n\tzfs/ZfsArcStats.h \\\n\tzfs/ZfsCompressedArcMeter.h\n\ndarwin_platform_sources = \\\n\tdarwin/Platform.c \\\n\tdarwin/PlatformHelpers.c \\\n\tdarwin/DarwinMachine.c \\\n\tdarwin/DarwinProcess.c \\\n\tdarwin/DarwinProcessTable.c \\\n\tgeneric/fdstat_sysctl.c \\\n\tgeneric/gettime.c \\\n\tgeneric/hostname.c \\\n\tgeneric/openzfs_sysctl.c \\\n\tgeneric/uname.c \\\n\tzfs/ZfsArcMeter.c \\\n\tzfs/ZfsCompressedArcMeter.c\n\nif HTOP_DARWIN\nAM_LDFLAGS += -framework IOKit -framework CoreFoundation\nmyhtopplatheaders = $(darwin_platform_headers)\nmyhtopplatsources = $(darwin_platform_sources)\nendif\n\n# Solaris\n# -------\n\nsolaris_platform_headers = \\\n\tgeneric/gettime.h \\\n\tgeneric/hostname.h \\\n\tgeneric/uname.h \\\n\tsolaris/ProcessField.h \\\n\tsolaris/Platform.h \\\n\tsolaris/SolarisMachine.h \\\n\tsolaris/SolarisProcess.h \\\n\tsolaris/SolarisProcessTable.h \\\n\tzfs/ZfsArcMeter.h \\\n\tzfs/ZfsArcStats.h \\\n\tzfs/ZfsCompressedArcMeter.h\n\nsolaris_platform_sources = \\\n\tgeneric/gettime.c \\\n\tgeneric/hostname.c \\\n\tgeneric/uname.c \\\n\tsolaris/Platform.c \\\n\tsolaris/SolarisMachine.c \\\n\tsolaris/SolarisProcess.c \\\n\tsolaris/SolarisProcessTable.c \\\n\tzfs/ZfsArcMeter.c \\\n\tzfs/ZfsCompressedArcMeter.c\n\nif HTOP_SOLARIS\nmyhtopplatheaders = $(solaris_platform_headers)\nmyhtopplatsources = $(solaris_platform_sources)\nendif\n\n# Performance Co-Pilot (PCP)\n# --------------------------\n\npcp_platform_headers = \\\n\tlinux/CGroupUtils.h \\\n\tlinux/PressureStallMeter.h \\\n\tlinux/ZramMeter.h \\\n\tlinux/ZramStats.h \\\n\tpcp/Instance.h \\\n\tpcp/InDomTable.h \\\n\tpcp/Metric.h \\\n\tpcp/Platform.h \\\n\tpcp/ProcessField.h \\\n\tpcp/PCPDynamicColumn.h \\\n\tpcp/PCPDynamicMeter.h \\\n\tpcp/PCPDynamicScreen.h \\\n\tpcp/PCPMachine.h \\\n\tpcp/PCPProcess.h \\\n\tpcp/PCPProcessTable.h \\\n\tzfs/ZfsArcMeter.h \\\n\tzfs/ZfsArcStats.h \\\n\tzfs/ZfsCompressedArcMeter.h\n\npcp_platform_sources = \\\n\tlinux/CGroupUtils.c \\\n\tlinux/PressureStallMeter.c \\\n\tlinux/ZramMeter.c \\\n\tpcp/Instance.c \\\n\tpcp/InDomTable.c \\\n\tpcp/Metric.c \\\n\tpcp/Platform.c \\\n\tpcp/PCPDynamicColumn.c \\\n\tpcp/PCPDynamicMeter.c \\\n\tpcp/PCPDynamicScreen.c \\\n\tpcp/PCPMachine.c \\\n\tpcp/PCPProcess.c \\\n\tpcp/PCPProcessTable.c \\\n\tzfs/ZfsArcMeter.c \\\n\tzfs/ZfsCompressedArcMeter.c\n\nif HTOP_PCP\nmyhtopplatheaders = $(pcp_platform_headers)\nmyhtopplatsources = $(pcp_platform_sources)\npcp_htop_SOURCES  = $(myhtopplatprogram) $(myhtopheaders) $(myhtopplatheaders) $(myhtopsources) $(myhtopplatsources)\nendif\n\n# Unsupported\n# -----------\n\nunsupported_platform_headers = \\\n\tgeneric/gettime.h \\\n\tunsupported/Platform.h \\\n\tunsupported/ProcessField.h \\\n\tunsupported/UnsupportedMachine.h \\\n\tunsupported/UnsupportedProcess.h \\\n\tunsupported/UnsupportedProcessTable.h\n\nunsupported_platform_sources = \\\n\tgeneric/gettime.c \\\n\tunsupported/Platform.c \\\n\tunsupported/UnsupportedMachine.c \\\n\tunsupported/UnsupportedProcess.c \\\n\tunsupported/UnsupportedProcessTable.c\n\nif HTOP_UNSUPPORTED\nmyhtopplatsources = $(unsupported_platform_sources)\nmyhtopplatheaders = $(unsupported_platform_headers)\nendif\n\n# ----\n\nhtop_SOURCES = $(myhtopplatprogram) $(myhtopheaders) $(myhtopplatheaders) $(myhtopsources) $(myhtopplatsources)\nnodist_htop_SOURCES = config.h\n\ntarget:\n\techo $(htop_SOURCES)\n\nprofile:\n\t$(MAKE) all AM_CPPFLAGS=\"-pg -O2 -DNDEBUG\"\n\ndebug:\n\t$(MAKE) all AM_CPPFLAGS=\"-ggdb3 -Og\" CFLAGS=\"`printf ' %s ' \"$(CFLAGS)\"|sed -E 's#[[:space:]]-O[^[:space:]]+[[:space:]]# #g'` -ggdb3 -Og\"\n\ncoverage:\n\t$(MAKE) all AM_CPPFLAGS=\"-fprofile-arcs -ftest-coverage\" AM_LDFLAGS=\"-lgcov\"\n\ncppcheck:\n\tcppcheck -q -v . --enable=all -DHAVE_OPENVZ\n\ndist-hook: $(top_distdir)/configure\n\t@if test \"x$$FORCE_MAKE_DIST\" != x || \\\n\t   grep 'pkg_m4_included' '$(top_distdir)/configure' >/dev/null; then :; \\\n\telse \\\n\t   echo 'ERROR: The configure script has incomplete pkg-config support and regenerating it is advised. Set FORCE_MAKE_DIST=1 to ignore this warning.'>&2; \\\n\t   (exit 1); \\\n\tfi\n\t@if grep 'PACKAGE_VERSION.*-g' '$(top_distdir)/configure'; then \\\n\t  echo 'WARNING: You are building a dist from a git version. Better run make dist outside of a .git repo on a tagged release.'>&2; \\\n\tfi\n\n.PHONY: lcov\n\nlcov:\n\tmkdir -p lcov\n\tlcov --capture --directory . --output-file coverage.info\n\tgenhtml coverage.info --output-directory lcov\n"
        },
        {
          "name": "MemoryMeter.c",
          "type": "blob",
          "size": 4.32421875,
          "content": "/*\nhtop - MemoryMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"MemoryMeter.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <stddef.h>\n\n#include \"CRT.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"RichString.h\"\n\n\nstatic const int MemoryMeter_attributes[] = {\n   MEMORY_USED,\n   MEMORY_SHARED,\n   MEMORY_COMPRESSED,\n   MEMORY_BUFFERS,\n   MEMORY_CACHE\n};\n\nstatic void MemoryMeter_updateValues(Meter* this) {\n   char* buffer = this->txtBuffer;\n   size_t size = sizeof(this->txtBuffer);\n   int written;\n\n   Settings *settings = this->host->settings;\n\n   /* shared, compressed and available memory are not supported on all platforms */\n   this->values[MEMORY_METER_SHARED] = NAN;\n   this->values[MEMORY_METER_COMPRESSED] = NAN;\n   this->values[MEMORY_METER_AVAILABLE] = NAN;\n   Platform_setMemoryValues(this);\n   if ((this->mode == GRAPH_METERMODE || this->mode == BAR_METERMODE) && !settings->showCachedMemory) {\n      this->values[MEMORY_METER_BUFFERS] = 0;\n      this->values[MEMORY_METER_CACHE] = 0;\n   }\n   /* Do not print available memory in bar mode */\n   static_assert(MEMORY_METER_AVAILABLE + 1 == MEMORY_METER_ITEMCOUNT,\n      \"MEMORY_METER_AVAILABLE is not the last item in MemoryMeterValues\");\n   this->curItems = MEMORY_METER_AVAILABLE;\n\n   /* we actually want to show \"used + shared + compressed\" */\n   double used = this->values[MEMORY_METER_USED];\n   if (isPositive(this->values[MEMORY_METER_SHARED]))\n      used += this->values[MEMORY_METER_SHARED];\n   if (isPositive(this->values[MEMORY_METER_COMPRESSED]))\n      used += this->values[MEMORY_METER_COMPRESSED];\n\n   written = Meter_humanUnit(buffer, used, size);\n   METER_BUFFER_CHECK(buffer, size, written);\n\n   METER_BUFFER_APPEND_CHR(buffer, size, '/');\n\n   Meter_humanUnit(buffer, this->total, size);\n}\n\nstatic void MemoryMeter_display(const Object* cast, RichString* out) {\n   char buffer[50];\n   const Meter* this = (const Meter*)cast;\n\n   RichString_writeAscii(out, CRT_colors[METER_TEXT], \":\");\n   Meter_humanUnit(buffer, this->total, sizeof(buffer));\n   RichString_appendAscii(out, CRT_colors[METER_VALUE], buffer);\n\n   Meter_humanUnit(buffer, this->values[MEMORY_METER_USED], sizeof(buffer));\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \" used:\");\n   RichString_appendAscii(out, CRT_colors[MEMORY_USED], buffer);\n\n   /* shared memory is not supported on all platforms */\n   if (isNonnegative(this->values[MEMORY_METER_SHARED])) {\n      Meter_humanUnit(buffer, this->values[MEMORY_METER_SHARED], sizeof(buffer));\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \" shared:\");\n      RichString_appendAscii(out, CRT_colors[MEMORY_SHARED], buffer);\n   }\n\n   /* compressed memory is not supported on all platforms */\n   if (isNonnegative(this->values[MEMORY_METER_COMPRESSED])) {\n      Meter_humanUnit(buffer, this->values[MEMORY_METER_COMPRESSED], sizeof(buffer));\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \" compressed:\");\n      RichString_appendAscii(out, CRT_colors[MEMORY_COMPRESSED], buffer);\n   }\n\n   Meter_humanUnit(buffer, this->values[MEMORY_METER_BUFFERS], sizeof(buffer));\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \" buffers:\");\n   RichString_appendAscii(out, CRT_colors[MEMORY_BUFFERS_TEXT], buffer);\n\n   Meter_humanUnit(buffer, this->values[MEMORY_METER_CACHE], sizeof(buffer));\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \" cache:\");\n   RichString_appendAscii(out, CRT_colors[MEMORY_CACHE], buffer);\n\n   /* available memory is not supported on all platforms */\n   if (isNonnegative(this->values[MEMORY_METER_AVAILABLE])) {\n      Meter_humanUnit(buffer, this->values[MEMORY_METER_AVAILABLE], sizeof(buffer));\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \" available:\");\n      RichString_appendAscii(out, CRT_colors[METER_VALUE], buffer);\n   }\n}\n\nconst MeterClass MemoryMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = MemoryMeter_display,\n   },\n   .updateValues = MemoryMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = MEMORY_METER_ITEMCOUNT,\n   .total = 100.0,\n   .attributes = MemoryMeter_attributes,\n   .name = \"Memory\",\n   .uiName = \"Memory\",\n   .caption = \"Mem\"\n};\n"
        },
        {
          "name": "MemoryMeter.h",
          "type": "blob",
          "size": 0.5458984375,
          "content": "#ifndef HEADER_MemoryMeter\n#define HEADER_MemoryMeter\n/*\nhtop - MemoryMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\ntypedef enum {\n   MEMORY_METER_USED = 0,\n   MEMORY_METER_SHARED = 1,\n   MEMORY_METER_COMPRESSED = 2,\n   MEMORY_METER_BUFFERS = 3,\n   MEMORY_METER_CACHE = 4,\n   MEMORY_METER_AVAILABLE = 5,\n   MEMORY_METER_ITEMCOUNT = 6, // number of entries in this enum\n} MemoryMeterValues;\n\nextern const MeterClass MemoryMeter_class;\n\n#endif\n"
        },
        {
          "name": "MemorySwapMeter.c",
          "type": "blob",
          "size": 2.765625,
          "content": "/*\nhtop - MemorySwapMeter.c\n(C) 2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"MemorySwapMeter.h\"\n\n#include <assert.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdlib.h>\n\n#include \"Macros.h\"\n#include \"MemoryMeter.h\"\n#include \"Object.h\"\n#include \"SwapMeter.h\"\n#include \"XUtils.h\"\n\n\ntypedef struct MemorySwapMeterData_ {\n   Meter* memoryMeter;\n   Meter* swapMeter;\n} MemorySwapMeterData;\n\nstatic void MemorySwapMeter_updateValues(Meter* this) {\n   MemorySwapMeterData* data = this->meterData;\n\n   Meter_updateValues(data->memoryMeter);\n   Meter_updateValues(data->swapMeter);\n}\n\nstatic void MemorySwapMeter_draw(Meter* this, int x, int y, int w) {\n   MemorySwapMeterData* data = this->meterData;\n\n   /* Use the same width for each sub meter to align with CPU meter */\n   const int colwidth = w / 2;\n   const int diff = w - colwidth * 2;\n\n   assert(data->memoryMeter->draw);\n   data->memoryMeter->draw(data->memoryMeter, x, y, colwidth);\n   assert(data->swapMeter->draw);\n   data->swapMeter->draw(data->swapMeter, x + colwidth + diff, y, colwidth);\n}\n\nstatic void MemorySwapMeter_init(Meter* this) {\n   MemorySwapMeterData* data = this->meterData;\n\n   if (!data) {\n      data = this->meterData = xCalloc(1, sizeof(MemorySwapMeterData));\n   }\n\n   if (!data->memoryMeter)\n      data->memoryMeter = Meter_new(this->host, 0, (const MeterClass*) Class(MemoryMeter));\n   if (!data->swapMeter)\n      data->swapMeter = Meter_new(this->host, 0, (const MeterClass*) Class(SwapMeter));\n\n   if (Meter_initFn(data->memoryMeter)) {\n      Meter_init(data->memoryMeter);\n   }\n   if (Meter_initFn(data->swapMeter)) {\n      Meter_init(data->swapMeter);\n   }\n}\n\nstatic void MemorySwapMeter_updateMode(Meter* this, MeterModeId mode) {\n   MemorySwapMeterData* data = this->meterData;\n\n   this->mode = mode;\n\n   Meter_setMode(data->memoryMeter, mode);\n   Meter_setMode(data->swapMeter, mode);\n\n   this->h = MAXIMUM(data->memoryMeter->h, data->swapMeter->h);\n}\n\nstatic void MemorySwapMeter_done(Meter* this) {\n   MemorySwapMeterData* data = this->meterData;\n\n   Meter_delete((Object*)data->swapMeter);\n   Meter_delete((Object*)data->memoryMeter);\n\n   free(data);\n}\n\nconst MeterClass MemorySwapMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n   },\n   .updateValues = MemorySwapMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .isMultiColumn = true,\n   .name = \"MemorySwap\",\n   .uiName = \"Memory & Swap\",\n   .description = \"Combined memory and swap usage\",\n   .caption = \"M&S\",\n   .draw = MemorySwapMeter_draw,\n   .init = MemorySwapMeter_init,\n   .updateMode = MemorySwapMeter_updateMode,\n   .done = MemorySwapMeter_done\n};\n"
        },
        {
          "name": "MemorySwapMeter.h",
          "type": "blob",
          "size": 0.2841796875,
          "content": "#ifndef HEADER_MemorySwapMeter\n#define HEADER_MemorySwapMeter\n/*\nhtop - MemorySwapMeter.h\n(C) 2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n\nextern const MeterClass MemorySwapMeter_class;\n\n#endif\n"
        },
        {
          "name": "Meter.c",
          "type": "blob",
          "size": 15.4208984375,
          "content": "/*\nhtop - Meter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Meter.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"ProvideCurses.h\"\n#include \"RichString.h\"\n#include \"Row.h\"\n#include \"Settings.h\"\n#include \"XUtils.h\"\n\n\n#ifndef UINT32_WIDTH\n#define UINT32_WIDTH 32\n#endif\n\n#define GRAPH_HEIGHT 4 /* Unit: rows (lines) */\n\ntypedef struct MeterMode_ {\n   Meter_Draw draw;\n   const char* uiName;\n   int h;\n} MeterMode;\n\n/* Meter drawing modes */\n\nstatic inline void Meter_displayBuffer(const Meter* this, RichString* out) {\n   if (Object_displayFn(this)) {\n      Object_display(this, out);\n   } else {\n      RichString_writeWide(out, CRT_colors[Meter_attributes(this)[0]], this->txtBuffer);\n   }\n}\n\n/* ---------- TextMeterMode ---------- */\n\nstatic void TextMeterMode_draw(Meter* this, int x, int y, int w) {\n   const char* caption = Meter_getCaption(this);\n   attrset(CRT_colors[METER_TEXT]);\n   mvaddnstr(y, x, caption, w);\n   attrset(CRT_colors[RESET_COLOR]);\n\n   int captionLen = strlen(caption);\n   x += captionLen;\n   w -= captionLen;\n   if (w <= 0)\n      return;\n\n   RichString_begin(out);\n   Meter_displayBuffer(this, &out);\n   RichString_printoffnVal(out, y, x, 0, w);\n   RichString_delete(&out);\n}\n\n/* ---------- BarMeterMode ---------- */\n\nstatic const char BarMeterMode_characters[] = \"|#*@$%&.\";\n\nstatic void BarMeterMode_draw(Meter* this, int x, int y, int w) {\n   // Draw the caption\n   const char* caption = Meter_getCaption(this);\n   attrset(CRT_colors[METER_TEXT]);\n   int captionLen = 3;\n   mvaddnstr(y, x, caption, captionLen);\n   x += captionLen;\n   w -= captionLen;\n\n   // Draw the bar borders\n   attrset(CRT_colors[BAR_BORDER]);\n   mvaddch(y, x, '[');\n   w--;\n   mvaddch(y, x + MAXIMUM(w, 0), ']');\n   w--;\n   attrset(CRT_colors[RESET_COLOR]);\n\n   x++;\n\n   if (w < 1) {\n      return;\n   }\n\n   // The text in the bar is right aligned;\n   // Pad with maximal spaces and then calculate needed starting position offset\n   RichString_begin(bar);\n   RichString_appendChr(&bar, 0, ' ', w);\n   RichString_appendWide(&bar, 0, this->txtBuffer);\n\n   int startPos = RichString_sizeVal(bar) - w;\n   if (startPos > w) {\n      // Text is too large for bar\n      // Truncate meter text at a space character\n      for (int pos = 2 * w; pos > w; pos--) {\n         if (RichString_getCharVal(bar, pos) == ' ') {\n            while (pos > w && RichString_getCharVal(bar, pos - 1) == ' ')\n               pos--;\n            startPos = pos - w;\n            break;\n         }\n      }\n\n      // If still too large, print the start not the end\n      startPos = MINIMUM(startPos, w);\n   }\n\n   assert(startPos >= 0);\n   assert(startPos <= w);\n   assert(startPos + w <= RichString_sizeVal(bar));\n\n   int blockSizes[10];\n\n   // First draw in the bar[] buffer...\n   int offset = 0;\n   for (uint8_t i = 0; i < this->curItems; i++) {\n      double value = this->values[i];\n      if (isPositive(value) && this->total > 0.0) {\n         value = MINIMUM(value, this->total);\n         blockSizes[i] = ceil((value / this->total) * w);\n      } else {\n         blockSizes[i] = 0;\n      }\n      int nextOffset = offset + blockSizes[i];\n      // (Control against invalid values)\n      nextOffset = CLAMP(nextOffset, 0, w);\n      for (int j = offset; j < nextOffset; j++)\n         if (RichString_getCharVal(bar, startPos + j) == ' ') {\n            if (CRT_colorScheme == COLORSCHEME_MONOCHROME) {\n               assert(i < strlen(BarMeterMode_characters));\n               RichString_setChar(&bar, startPos + j, BarMeterMode_characters[i]);\n            } else {\n               RichString_setChar(&bar, startPos + j, '|');\n            }\n         }\n      offset = nextOffset;\n   }\n\n   // ...then print the buffer.\n   offset = 0;\n   for (uint8_t i = 0; i < this->curItems; i++) {\n      int attr = this->curAttributes ? this->curAttributes[i] : Meter_attributes(this)[i];\n      RichString_setAttrn(&bar, CRT_colors[attr], startPos + offset, blockSizes[i]);\n      RichString_printoffnVal(bar, y, x + offset, startPos + offset, MINIMUM(blockSizes[i], w - offset));\n      offset += blockSizes[i];\n      offset = CLAMP(offset, 0, w);\n   }\n   if (offset < w) {\n      RichString_setAttrn(&bar, CRT_colors[BAR_SHADOW], startPos + offset, w - offset);\n      RichString_printoffnVal(bar, y, x + offset, startPos + offset, w - offset);\n   }\n\n   RichString_delete(&bar);\n\n   move(y, x + w + 1);\n   attrset(CRT_colors[RESET_COLOR]);\n}\n\n/* ---------- GraphMeterMode ---------- */\n\n#ifdef HAVE_LIBNCURSESW\n\n#define PIXPERROW_UTF8 4\nstatic const char* const GraphMeterMode_dotsUtf8[] = {\n   /*00*/\" \", /*01*/\"â¢\", /*02*/\"â¢ \", /*03*/\"â¢°\", /*04*/ \"â¢¸\",\n   /*10*/\"â¡\", /*11*/\"â£\", /*12*/\"â£ \", /*13*/\"â£°\", /*14*/ \"â£¸\",\n   /*20*/\"â¡\", /*21*/\"â£\", /*22*/\"â£¤\", /*23*/\"â£´\", /*24*/ \"â£¼\",\n   /*30*/\"â¡\", /*31*/\"â£\", /*32*/\"â£¦\", /*33*/\"â£¶\", /*34*/ \"â£¾\",\n   /*40*/\"â¡\", /*41*/\"â£\", /*42*/\"â£§\", /*43*/\"â£·\", /*44*/ \"â£¿\"\n};\n\n#endif\n\n#define PIXPERROW_ASCII 2\nstatic const char* const GraphMeterMode_dotsAscii[] = {\n   /*00*/\" \", /*01*/\".\", /*02*/\":\",\n   /*10*/\".\", /*11*/\".\", /*12*/\":\",\n   /*20*/\":\", /*21*/\":\", /*22*/\":\"\n};\n\nstatic void GraphMeterMode_draw(Meter* this, int x, int y, int w) {\n   // Draw the caption\n   const char* caption = Meter_getCaption(this);\n   attrset(CRT_colors[METER_TEXT]);\n   const int captionLen = 3;\n   mvaddnstr(y, x, caption, captionLen);\n   x += captionLen;\n   w -= captionLen;\n\n   GraphData* data = &this->drawData;\n\n   // Expand the graph data buffer if necessary\n   assert(data->nValues / 2 <= INT_MAX);\n   if (w > (int)(data->nValues / 2) && MAX_METER_GRAPHDATA_VALUES > data->nValues) {\n      size_t oldNValues = data->nValues;\n      data->nValues = MAXIMUM(oldNValues + oldNValues / 2, (size_t)w * 2);\n      data->nValues = MINIMUM(data->nValues, MAX_METER_GRAPHDATA_VALUES);\n      data->values = xReallocArray(data->values, data->nValues, sizeof(*data->values));\n      memmove(data->values + (data->nValues - oldNValues), data->values, oldNValues * sizeof(*data->values));\n      memset(data->values, 0, (data->nValues - oldNValues) * sizeof(*data->values));\n   }\n\n   const size_t nValues = data->nValues;\n   if (nValues < 1)\n      return;\n\n   // Record new value if necessary\n   const Machine* host = this->host;\n   if (!timercmp(&host->realtime, &(data->time), <)) {\n      int globalDelay = host->settings->delay;\n      struct timeval delay = { .tv_sec = globalDelay / 10, .tv_usec = (globalDelay % 10) * 100000L };\n      timeradd(&host->realtime, &delay, &(data->time));\n\n      memmove(&data->values[0], &data->values[1], (nValues - 1) * sizeof(*data->values));\n\n      data->values[nValues - 1] = 0.0;\n      if (this->curItems > 0) {\n         assert(this->values);\n         data->values[nValues - 1] = sumPositiveValues(this->values, this->curItems);\n      }\n   }\n\n   if (w <= 0)\n      return;\n\n   // Graph drawing style (character set, etc.)\n   const char* const* GraphMeterMode_dots;\n   int GraphMeterMode_pixPerRow;\n#ifdef HAVE_LIBNCURSESW\n   if (CRT_utf8) {\n      GraphMeterMode_dots = GraphMeterMode_dotsUtf8;\n      GraphMeterMode_pixPerRow = PIXPERROW_UTF8;\n   } else\n#endif\n   {\n      GraphMeterMode_dots = GraphMeterMode_dotsAscii;\n      GraphMeterMode_pixPerRow = PIXPERROW_ASCII;\n   }\n\n   // Starting positions of graph data and terminal column\n   if ((size_t)w > nValues / 2) {\n      x += w - nValues / 2;\n      w = nValues / 2;\n   }\n   size_t i = nValues - (size_t)w * 2;\n\n   // Draw the actual graph\n   for (int col = 0; i < nValues - 1; i += 2, col++) {\n      int pix = GraphMeterMode_pixPerRow * GRAPH_HEIGHT;\n      double total = MAXIMUM(this->total, 1);\n      int v1 = (int) lround(CLAMP(data->values[i] / total * pix, 1.0, pix));\n      int v2 = (int) lround(CLAMP(data->values[i + 1] / total * pix, 1.0, pix));\n\n      int colorIdx = GRAPH_1;\n      for (int line = 0; line < GRAPH_HEIGHT; line++) {\n         int line1 = CLAMP(v1 - (GraphMeterMode_pixPerRow * (GRAPH_HEIGHT - 1 - line)), 0, GraphMeterMode_pixPerRow);\n         int line2 = CLAMP(v2 - (GraphMeterMode_pixPerRow * (GRAPH_HEIGHT - 1 - line)), 0, GraphMeterMode_pixPerRow);\n\n         attrset(CRT_colors[colorIdx]);\n         mvaddstr(y + line, x + col, GraphMeterMode_dots[line1 * (GraphMeterMode_pixPerRow + 1) + line2]);\n         colorIdx = GRAPH_2;\n      }\n   }\n   attrset(CRT_colors[RESET_COLOR]);\n}\n\n/* ---------- LEDMeterMode ---------- */\n\nstatic const char* const LEDMeterMode_digitsAscii[] = {\n   \" __ \", \"    \", \" __ \", \" __ \", \"    \", \" __ \", \" __ \", \" __ \", \" __ \", \" __ \",\n   \"|  |\", \"   |\", \" __|\", \" __|\", \"|__|\", \"|__ \", \"|__ \", \"   |\", \"|__|\", \"|__|\",\n   \"|__|\", \"   |\", \"|__ \", \" __|\", \"   |\", \" __|\", \"|__|\", \"   |\", \"|__|\", \" __|\"\n};\n\n#ifdef HAVE_LIBNCURSESW\n\nstatic const char* const LEDMeterMode_digitsUtf8[] = {\n   \"ââââ\", \"  â \", \"â¶âââ\", \"â¶âââ\", \"â·  â·\", \"ââââ´\", \"ââââ´\", \"â¶âââ\", \"ââââ\", \"ââââ\",\n   \"â  â\", \"  â \", \"ââââ\", \" âââ¤\", \"ââââ¤\", \"ââââ\", \"ââââ\", \"   â\", \"ââââ¤\", \"ââââ¤\",\n   \"ââââ\", \"  âµ \", \"ââââ´\", \"â¶âââ\", \"   âµ\", \"â¶âââ\", \"ââââ\", \"   âµ\", \"ââââ\", \"â¶âââ\"\n};\n\n#endif\n\nstatic const char* const* LEDMeterMode_digits;\n\nstatic void LEDMeterMode_drawDigit(int x, int y, int n) {\n   for (int i = 0; i < 3; i++)\n      mvaddstr(y + i, x, LEDMeterMode_digits[i * 10 + n]);\n}\n\nstatic void LEDMeterMode_draw(Meter* this, int x, int y, int w) {\n#ifdef HAVE_LIBNCURSESW\n   if (CRT_utf8)\n      LEDMeterMode_digits = LEDMeterMode_digitsUtf8;\n   else\n#endif\n      LEDMeterMode_digits = LEDMeterMode_digitsAscii;\n\n   RichString_begin(out);\n   Meter_displayBuffer(this, &out);\n\n   int yText =\n#ifdef HAVE_LIBNCURSESW\n      CRT_utf8 ? y + 1 :\n#endif\n      y + 2;\n   attrset(CRT_colors[LED_COLOR]);\n   const char* caption = Meter_getCaption(this);\n   mvaddstr(yText, x, caption);\n   int xx = x + strlen(caption);\n   int len = RichString_sizeVal(out);\n   for (int i = 0; i < len; i++) {\n      int c = RichString_getCharVal(out, i);\n      if (c >= '0' && c <= '9') {\n         if (xx - x + 4 > w)\n            break;\n\n         LEDMeterMode_drawDigit(xx, y, c - '0');\n         xx += 4;\n      } else {\n         if (xx - x + 1 > w)\n            break;\n#ifdef HAVE_LIBNCURSESW\n         const cchar_t wc = { .chars = { c, '\\0' }, .attr = 0 }; /* use LED_COLOR from attrset() */\n         mvadd_wch(yText, xx, &wc);\n#else\n         mvaddch(yText, xx, c);\n#endif\n         xx += 1;\n      }\n   }\n   attrset(CRT_colors[RESET_COLOR]);\n   RichString_delete(&out);\n}\n\nstatic const MeterMode Meter_modes[] = {\n   [0] = {\n      .uiName = NULL,\n      .h = 0,\n      .draw = NULL,\n   },\n   [BAR_METERMODE] = {\n      .uiName = \"Bar\",\n      .h = 1,\n      .draw = BarMeterMode_draw,\n   },\n   [TEXT_METERMODE] = {\n      .uiName = \"Text\",\n      .h = 1,\n      .draw = TextMeterMode_draw,\n   },\n   [GRAPH_METERMODE] = {\n      .uiName = \"Graph\",\n      .h = GRAPH_HEIGHT,\n      .draw = GraphMeterMode_draw,\n   },\n   [LED_METERMODE] = {\n      .uiName = \"LED\",\n      .h = 3,\n      .draw = LEDMeterMode_draw,\n   },\n};\n\n/* Meter class and methods */\n\nconst MeterClass Meter_class = {\n   .super = {\n      .extends = Class(Object)\n   }\n};\n\nMeter* Meter_new(const Machine* host, unsigned int param, const MeterClass* type) {\n   Meter* this = xCalloc(1, sizeof(Meter));\n   Object_setClass(this, type);\n   this->h = 1;\n   this->param = param;\n   this->host = host;\n   this->curItems = type->maxItems;\n   this->curAttributes = NULL;\n   this->values = type->maxItems ? xCalloc(type->maxItems, sizeof(double)) : NULL;\n   this->total = type->total;\n   this->caption = xStrdup(type->caption);\n   if (Meter_initFn(this)) {\n      Meter_init(this);\n   }\n\n   Meter_setMode(this, type->defaultMode);\n   assert(this->mode > 0);\n   return this;\n}\n\n/* Converts 'value' in kibibytes into a human readable string.\n   Example output strings: \"0K\", \"1023K\", \"98.7M\" and \"1.23G\" */\nint Meter_humanUnit(char* buffer, double value, size_t size) {\n   size_t i = 0;\n\n   assert(value >= 0.0);\n   while (value >= ONE_K) {\n      if (i >= ARRAYSIZE(unitPrefixes) - 1) {\n         if (value > 9999.0) {\n            return xSnprintf(buffer, size, \"inf\");\n         }\n         break;\n      }\n\n      value /= ONE_K;\n      ++i;\n   }\n\n   int precision = 0;\n\n   if (i > 0) {\n      // Fraction digits for mebibytes and above\n      precision = value <= 99.9 ? (value <= 9.99 ? 2 : 1) : 0;\n\n      // Round up if 'value' is in range (99.9, 100) or (9.99, 10)\n      if (precision < 2) {\n         double limit = precision == 1 ? 10.0 : 100.0;\n         if (value < limit) {\n            value = limit;\n         }\n      }\n   }\n\n   return xSnprintf(buffer, size, \"%.*f%c\", precision, value, unitPrefixes[i]);\n}\n\nvoid Meter_delete(Object* cast) {\n   if (!cast)\n      return;\n\n   Meter* this = (Meter*) cast;\n   if (Meter_doneFn(this)) {\n      Meter_done(this);\n   }\n   free(this->drawData.values);\n   free(this->caption);\n   free(this->values);\n   free(this);\n}\n\nvoid Meter_setCaption(Meter* this, const char* caption) {\n   free_and_xStrdup(&this->caption, caption);\n}\n\nvoid Meter_setMode(Meter* this, MeterModeId modeIndex) {\n   if (modeIndex == this->mode) {\n      assert(this->mode > 0);\n      return;\n   }\n\n   uint32_t supportedModes = Meter_supportedModes(this);\n   assert(supportedModes);\n   assert(!(supportedModes & (1 << 0)));\n\n   assert(LAST_METERMODE <= UINT32_WIDTH);\n   if (modeIndex >= LAST_METERMODE || !(supportedModes & (1UL << modeIndex)))\n      return;\n\n   assert(modeIndex >= 1);\n   if (Meter_updateModeFn(this)) {\n      assert(Meter_drawFn(this));\n      this->draw = Meter_drawFn(this);\n      Meter_updateMode(this, modeIndex);\n   } else {\n      free(this->drawData.values);\n      this->drawData.values = NULL;\n      this->drawData.nValues = 0;\n\n      const MeterMode* mode = &Meter_modes[modeIndex];\n      this->draw = mode->draw;\n      this->h = mode->h;\n   }\n   this->mode = modeIndex;\n}\n\nMeterModeId Meter_nextSupportedMode(const Meter* this) {\n   uint32_t supportedModes = Meter_supportedModes(this);\n   assert(supportedModes);\n\n   assert(this->mode < UINT32_WIDTH);\n   uint32_t modeMask = ((uint32_t)-1 << 1) << this->mode;\n   uint32_t nextModes = supportedModes & modeMask;\n   if (!nextModes) {\n      nextModes = supportedModes;\n   }\n\n   return (MeterModeId)countTrailingZeros(nextModes);\n}\n\nListItem* Meter_toListItem(const Meter* this, bool moving) {\n   char mode[20];\n   if (this->mode > 0) {\n      xSnprintf(mode, sizeof(mode), \" [%s]\", Meter_modes[this->mode].uiName);\n   } else {\n      mode[0] = '\\0';\n   }\n   char name[32];\n   if (Meter_getUiNameFn(this))\n      Meter_getUiName(this, name, sizeof(name));\n   else\n      xSnprintf(name, sizeof(name), \"%s\", Meter_uiName(this));\n   char buffer[50];\n   xSnprintf(buffer, sizeof(buffer), \"%s%s\", name, mode);\n   ListItem* li = ListItem_new(buffer, 0);\n   li->moving = moving;\n   return li;\n}\n\n/* Blank meter */\n\nstatic void BlankMeter_updateValues(Meter* this) {\n   this->txtBuffer[0] = '\\0';\n}\n\nstatic void BlankMeter_display(ATTR_UNUSED const Object* cast, ATTR_UNUSED RichString* out) {\n}\n\nstatic const int BlankMeter_attributes[] = {\n   DEFAULT_COLOR\n};\n\nconst MeterClass BlankMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = BlankMeter_display,\n   },\n   .updateValues = BlankMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = (1 << TEXT_METERMODE),\n   .maxItems = 0,\n   .total = 0.0,\n   .attributes = BlankMeter_attributes,\n   .name = \"Blank\",\n   .uiName = \"Blank\",\n   .caption = \"\"\n};\n"
        },
        {
          "name": "Meter.h",
          "type": "blob",
          "size": 5.5478515625,
          "content": "#ifndef HEADER_Meter\n#define HEADER_Meter\n/*\nhtop - Meter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <sys/time.h>\n\n#include \"ListItem.h\"\n#include \"Machine.h\"\n#include \"Macros.h\"\n#include \"MeterMode.h\"\n#include \"Object.h\"\n\n\n#define METER_TXTBUFFER_LEN 256\n#define MAX_METER_GRAPHDATA_VALUES 32768\n\n#define METER_BUFFER_CHECK(buffer, size, written)          \\\n   do {                                                    \\\n      if ((written) < 0 || (size_t)(written) >= (size)) {  \\\n         return;                                           \\\n      }                                                    \\\n      (buffer) += (written);                               \\\n      (size) -= (size_t)(written);                         \\\n   } while (0)\n\n#define METER_BUFFER_APPEND_CHR(buffer, size, c)           \\\n   do {                                                    \\\n      if ((size) < 2) {                                    \\\n         return;                                           \\\n      }                                                    \\\n      *(buffer)++ = c;                                     \\\n      *(buffer) = '\\0';                                    \\\n      (size)--;                                            \\\n      if ((size) == 0) {                                   \\\n         return;                                           \\\n      }                                                    \\\n   } while (0)\n\n\nstruct Meter_;\ntypedef struct Meter_ Meter;\n\ntypedef ATTR_NONNULL void (*Meter_Init)(Meter*);\ntypedef ATTR_NONNULL void (*Meter_Done)(Meter*);\ntypedef ATTR_NONNULL void (*Meter_UpdateMode)(Meter*, MeterModeId);\ntypedef ATTR_NONNULL void (*Meter_UpdateValues)(Meter*);\ntypedef ATTR_NONNULL void (*Meter_Draw)(Meter*, int, int, int);\ntypedef ATTR_NONNULL const char* (*Meter_GetCaption)(const Meter*);\ntypedef ATTR_NONNULL ATTR_ACCESS3_W(2, 3) void (*Meter_GetUiName)(const Meter*, char*, size_t);\n\ntypedef struct MeterClass_ {\n   const ObjectClass super;\n   const Meter_Init init;\n   const Meter_Done done;\n   const Meter_UpdateMode updateMode;\n   const Meter_UpdateValues updateValues;\n   const Meter_Draw draw;\n   const Meter_GetCaption getCaption;\n   const Meter_GetUiName getUiName;\n   const MeterModeId defaultMode;\n   const uint32_t supportedModes;          /* bitset of supported modes, 1<<mode_id */\n   const double total;\n   const int* const attributes;\n   const char* const name;                 /* internal name of the meter, must not contain any space */\n   const char* const uiName;               /* display name in header setup menu */\n   const char* const caption;              /* prefix in the actual header */\n   const char* const description;          /* optional meter description in header setup menu */\n   const uint8_t maxItems;\n   const bool isMultiColumn;               /* whether the meter draws multiple sub-columns (defaults to false) */\n} MeterClass;\n\n#define As_Meter(this_)                ((const MeterClass*)((this_)->super.klass))\n#define Meter_initFn(this_)            As_Meter(this_)->init\n#define Meter_init(this_)              As_Meter(this_)->init((Meter*)(this_))\n#define Meter_done(this_)              As_Meter(this_)->done((Meter*)(this_))\n#define Meter_updateModeFn(this_)      As_Meter(this_)->updateMode\n#define Meter_updateMode(this_, m_)    As_Meter(this_)->updateMode((Meter*)(this_), m_)\n#define Meter_drawFn(this_)            As_Meter(this_)->draw\n#define Meter_doneFn(this_)            As_Meter(this_)->done\n#define Meter_updateValues(this_)      As_Meter(this_)->updateValues((Meter*)(this_))\n#define Meter_getUiNameFn(this_)       As_Meter(this_)->getUiName\n#define Meter_getUiName(this_,n_,l_)   As_Meter(this_)->getUiName((const Meter*)(this_),n_,l_)\n#define Meter_getCaptionFn(this_)      As_Meter(this_)->getCaption\n#define Meter_getCaption(this_)        (Meter_getCaptionFn(this_) ? As_Meter(this_)->getCaption((const Meter*)(this_)) : (this_)->caption)\n#define Meter_supportedModes(this_)    As_Meter(this_)->supportedModes\n#define Meter_attributes(this_)        As_Meter(this_)->attributes\n#define Meter_name(this_)              As_Meter(this_)->name\n#define Meter_uiName(this_)            As_Meter(this_)->uiName\n#define Meter_isMultiColumn(this_)     As_Meter(this_)->isMultiColumn\n\ntypedef struct GraphData_ {\n   struct timeval time;\n   size_t nValues;\n   double* values;\n} GraphData;\n\nstruct Meter_ {\n   Object super;\n   Meter_Draw draw;\n   const Machine* host;\n\n   char* caption;\n   MeterModeId mode;\n   unsigned int param;\n   GraphData drawData;\n   int h;\n   int columnWidthCount;      /**< only used internally by the Header */\n   uint8_t curItems;\n   const int* curAttributes;\n   char txtBuffer[METER_TXTBUFFER_LEN];\n   double* values;\n   double total;\n   void* meterData;\n};\n\ntypedef enum {\n   RATESTATUS_DATA,\n   RATESTATUS_INIT,\n   RATESTATUS_NODATA,\n   RATESTATUS_STALE\n} MeterRateStatus;\n\nextern const MeterClass Meter_class;\n\nMeter* Meter_new(const Machine* host, unsigned int param, const MeterClass* type);\n\n/* Converts 'value' in kibibytes into a human readable string.\n   Example output strings: \"0K\", \"1023K\", \"98.7M\" and \"1.23G\" */\nint Meter_humanUnit(char* buffer, double value, size_t size);\n\nvoid Meter_delete(Object* cast);\n\nvoid Meter_setCaption(Meter* this, const char* caption);\n\nvoid Meter_setMode(Meter* this, MeterModeId modeIndex);\n\nMeterModeId Meter_nextSupportedMode(const Meter* this);\n\nListItem* Meter_toListItem(const Meter* this, bool moving);\n\nextern const MeterClass BlankMeter_class;\n\n#endif\n"
        },
        {
          "name": "MeterMode.h",
          "type": "blob",
          "size": 0.6171875,
          "content": "#ifndef HEADER_MeterMode\n#define HEADER_MeterMode\n/*\nhtop - MeterMode.h\n(C) 2024 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n\nenum MeterModeId_ {\n   /* Meter mode 0 is reserved */\n   BAR_METERMODE = 1,\n   TEXT_METERMODE,\n   GRAPH_METERMODE,\n   LED_METERMODE,\n   LAST_METERMODE\n};\n\ntypedef unsigned int MeterModeId;\n\n#define METERMODE_DEFAULT_SUPPORTED ( \\\n   (1 << BAR_METERMODE) |             \\\n   (1 << TEXT_METERMODE) |            \\\n   (1 << GRAPH_METERMODE) |           \\\n   (1 << LED_METERMODE) |             \\\n   0) // Avoids edits when updating\n\n#endif\n"
        },
        {
          "name": "MetersPanel.c",
          "type": "blob",
          "size": 6.4453125,
          "content": "/*\nhtop - MetersPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"MetersPanel.h\"\n\n#include <stdlib.h>\n\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Header.h\"\n#include \"ListItem.h\"\n#include \"Meter.h\"\n#include \"Object.h\"\n#include \"ProvideCurses.h\"\n\n\n// Note: In code the meters are known to have bar/text/graph \"Modes\", but in UI\n// we call them \"Styles\".\nstatic const char* const MetersFunctions[] = {\"Style \", \"Move  \", \"                                         \", \"Delete\", \"Done  \", NULL};\nstatic const char* const MetersKeys[] = {\"Space\", \"Enter\", \"\", \"Del\", \"F10\"};\nstatic const int MetersEvents[] = {' ', 13, ERR, KEY_DC, KEY_F(10)};\n\n// We avoid UTF-8 arrows â â here as they might display full-width on Chinese\n// terminals, breaking our aligning.\n// In <http://unicode.org/reports/tr11/>, arrows (U+2019..U+2199) are\n// considered \"Ambiguous characters\".\nstatic const char* const MetersMovingFunctions[] = {\"Style \", \"Lock  \", \"Up    \", \"Down  \", \"Left  \", \"Right \", \"       \", \"Delete\", \"Done  \", NULL};\nstatic const char* const MetersMovingKeys[] = {\"Space\", \"Enter\", \"Up\", \"Dn\", \"<-\", \"->\", \"  \", \"Del\", \"F10\"};\nstatic const int MetersMovingEvents[] = {' ', 13, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, ERR, KEY_DC, KEY_F(10)};\nstatic FunctionBar* Meters_movingBar = NULL;\n\nvoid MetersPanel_cleanup(void) {\n   if (Meters_movingBar) {\n      FunctionBar_delete(Meters_movingBar);\n      Meters_movingBar = NULL;\n   }\n}\n\nstatic void MetersPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   MetersPanel* this = (MetersPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nvoid MetersPanel_setMoving(MetersPanel* this, bool moving) {\n   Panel* super = (Panel*) this;\n   this->moving = moving;\n   ListItem* selected = (ListItem*)Panel_getSelected(super);\n   if (selected) {\n      selected->moving = moving;\n   }\n   if (!moving) {\n      Panel_setSelectionColor(super, PANEL_SELECTION_FOCUS);\n      Panel_setDefaultBar(super);\n   } else {\n      Panel_setSelectionColor(super, PANEL_SELECTION_FOLLOW);\n      super->currentBar = Meters_movingBar;\n   }\n}\n\nstatic inline bool moveToNeighbor(MetersPanel* this, MetersPanel* neighbor, int selected) {\n   Panel* super = (Panel*) this;\n   if (this->moving) {\n      if (neighbor) {\n         if (selected < Vector_size(this->meters)) {\n            MetersPanel_setMoving(this, false);\n\n            Meter* meter = (Meter*) Vector_take(this->meters, selected);\n            Panel_remove(super, selected);\n            Vector_insert(neighbor->meters, selected, meter);\n            Panel_insert(&(neighbor->super), selected, (Object*) Meter_toListItem(meter, false));\n            Panel_setSelected(&(neighbor->super), selected);\n\n            MetersPanel_setMoving(neighbor, true);\n            return true;\n         }\n      }\n   }\n   return false;\n}\n\nstatic HandlerResult MetersPanel_eventHandler(Panel* super, int ch) {\n   MetersPanel* this = (MetersPanel*) super;\n\n   int selected = Panel_getSelectedIndex(super);\n   HandlerResult result = IGNORED;\n   bool sideMove = false;\n\n   switch (ch) {\n      case 0x0a:\n      case 0x0d:\n      case KEY_ENTER:\n         if (!Vector_size(this->meters))\n            break;\n         MetersPanel_setMoving(this, !(this->moving));\n         result = HANDLED;\n         break;\n      case ' ':\n      case KEY_F(4):\n      case 't': {\n         if (!Vector_size(this->meters))\n            break;\n         Meter* meter = (Meter*) Vector_get(this->meters, selected);\n         MeterModeId mode = Meter_nextSupportedMode(meter);\n         Meter_setMode(meter, mode);\n         Panel_set(super, selected, (Object*) Meter_toListItem(meter, this->moving));\n         result = HANDLED;\n         break;\n      }\n      case KEY_UP:\n         if (!this->moving)\n            break;\n         /* else fallthrough */\n      case KEY_F(7):\n      case '[':\n      case '-':\n         Vector_moveUp(this->meters, selected);\n         Panel_moveSelectedUp(super);\n         result = HANDLED;\n         break;\n      case KEY_DOWN:\n         if (!this->moving)\n            break;\n         /* else fallthrough */\n      case KEY_F(8):\n      case ']':\n      case '+':\n         Vector_moveDown(this->meters, selected);\n         Panel_moveSelectedDown(super);\n         result = HANDLED;\n         break;\n      case KEY_RIGHT:\n         sideMove = moveToNeighbor(this, this->rightNeighbor, selected);\n         if (this->moving && !sideMove) {\n            // lock user here until it exits positioning-mode\n            result = HANDLED;\n         }\n         // if user is free, don't set HANDLED;\n         // let ScreenManager handle focus.\n         break;\n      case KEY_LEFT:\n         sideMove = moveToNeighbor(this, this->leftNeighbor, selected);\n         if (this->moving && !sideMove) {\n            result = HANDLED;\n         }\n         break;\n      case KEY_F(9):\n      case KEY_DC:\n         if (!Vector_size(this->meters))\n            break;\n         if (selected < Vector_size(this->meters)) {\n            Vector_remove(this->meters, selected);\n            Panel_remove(super, selected);\n         }\n         MetersPanel_setMoving(this, false);\n         result = HANDLED;\n         break;\n   }\n\n   if (result == HANDLED || sideMove) {\n      Header* header = this->scr->header;\n      this->settings->changed = true;\n      this->settings->lastUpdate++;\n      Header_calculateHeight(header);\n      ScreenManager_resize(this->scr);\n   }\n\n   return result;\n}\n\nconst PanelClass MetersPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = MetersPanel_delete\n   },\n   .eventHandler = MetersPanel_eventHandler\n};\n\nMetersPanel* MetersPanel_new(Settings* settings, const char* header, Vector* meters, ScreenManager* scr) {\n   MetersPanel* this = AllocThis(MetersPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(MetersFunctions, MetersKeys, MetersEvents);\n   if (!Meters_movingBar) {\n      Meters_movingBar = FunctionBar_new(MetersMovingFunctions, MetersMovingKeys, MetersMovingEvents);\n   }\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   this->settings = settings;\n   this->meters = meters;\n   this->scr = scr;\n   this->moving = false;\n   this->rightNeighbor = NULL;\n   this->leftNeighbor = NULL;\n   Panel_setHeader(super, header);\n   for (int i = 0; i < Vector_size(meters); i++) {\n      const Meter* meter = (const Meter*) Vector_get(meters, i);\n      Panel_add(super, (Object*) Meter_toListItem(meter, false));\n   }\n   return this;\n}\n"
        },
        {
          "name": "MetersPanel.h",
          "type": "blob",
          "size": 0.8056640625,
          "content": "#ifndef HEADER_MetersPanel\n#define HEADER_MetersPanel\n/*\nhtop - MetersPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Panel.h\"\n#include \"ScreenManager.h\"\n#include \"Settings.h\"\n#include \"Vector.h\"\n\n\nstruct MetersPanel_;\ntypedef struct MetersPanel_ MetersPanel;\n\nstruct MetersPanel_ {\n   Panel super;\n\n   Settings* settings;\n   Vector* meters;\n   ScreenManager* scr;\n   MetersPanel* leftNeighbor;\n   MetersPanel* rightNeighbor;\n   bool moving;\n};\n\nvoid MetersPanel_cleanup(void);\n\nvoid MetersPanel_setMoving(MetersPanel* this, bool moving);\n\nextern const PanelClass MetersPanel_class;\n\nMetersPanel* MetersPanel_new(Settings* settings, const char* header, Vector* meters, ScreenManager* scr);\n\n#endif\n"
        },
        {
          "name": "NEWS",
          "type": "blob",
          "size": 0.1279296875,
          "content": "\nSee the commit history for news of the past.\nSee the bug tracker for news of the future.\nRun the program for news of the present.\n"
        },
        {
          "name": "NetworkIOMeter.c",
          "type": "blob",
          "size": 5.5966796875,
          "content": "/*\nhtop - NetworkIOMeter.c\n(C) 2020-2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"NetworkIOMeter.h\"\n\n#include <stdbool.h>\n\n#include \"CRT.h\"\n#include \"Machine.h\"\n#include \"Macros.h\"\n#include \"Meter.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"RichString.h\"\n#include \"Row.h\"\n#include \"XUtils.h\"\n\n\nstatic const int NetworkIOMeter_attributes[] = {\n   METER_VALUE_IOREAD,\n   METER_VALUE_IOWRITE,\n};\n\nstatic MeterRateStatus status = RATESTATUS_INIT;\nstatic double cached_rxb_diff;\nstatic char cached_rxb_diff_str[6];\nstatic uint32_t cached_rxp_diff;\nstatic double cached_txb_diff;\nstatic char cached_txb_diff_str[6];\nstatic uint32_t cached_txp_diff;\n\nstatic void NetworkIOMeter_updateValues(Meter* this) {\n   const Machine* host = this->host;\n\n   static uint64_t cached_last_update = 0;\n   uint64_t passedTimeInMs = host->realtimeMs - cached_last_update;\n   bool hasNewData = false;\n   NetworkIOData data;\n\n   /* update only every 500ms to have a sane span for rate calculation */\n   if (passedTimeInMs > 500) {\n      hasNewData = Platform_getNetworkIO(&data);\n      if (!hasNewData) {\n         status = RATESTATUS_NODATA;\n      } else if (cached_last_update == 0) {\n         status = RATESTATUS_INIT;\n      } else if (passedTimeInMs > 30000) {\n         status = RATESTATUS_STALE;\n      } else {\n         status = RATESTATUS_DATA;\n      }\n\n      cached_last_update = host->realtimeMs;\n   }\n\n   if (hasNewData) {\n      static uint64_t cached_rxb_total;\n      static uint64_t cached_rxp_total;\n      static uint64_t cached_txb_total;\n      static uint64_t cached_txp_total;\n\n      if (status != RATESTATUS_INIT) {\n         uint64_t diff;\n\n         if (data.bytesReceived > cached_rxb_total) {\n            diff = data.bytesReceived - cached_rxb_total;\n            diff = (1000 * diff) / passedTimeInMs; /* convert to B/s */\n            cached_rxb_diff = diff;\n         } else {\n            cached_rxb_diff = 0;\n         }\n         Meter_humanUnit(cached_rxb_diff_str, cached_rxb_diff / ONE_K, sizeof(cached_rxb_diff_str));\n\n         if (data.packetsReceived > cached_rxp_total) {\n            diff = data.packetsReceived - cached_rxp_total;\n            diff = (1000 * diff) / passedTimeInMs; /* convert to pkts/s */\n            cached_rxp_diff = (uint32_t)diff;\n         } else {\n            cached_rxp_diff = 0;\n         }\n\n         if (data.bytesTransmitted > cached_txb_total) {\n            diff = data.bytesTransmitted - cached_txb_total;\n            diff = (1000 * diff) / passedTimeInMs; /* convert to B/s */\n            cached_txb_diff = diff;\n         } else {\n            cached_txb_diff = 0;\n         }\n         Meter_humanUnit(cached_txb_diff_str, cached_txb_diff / ONE_K, sizeof(cached_txb_diff_str));\n\n         if (data.packetsTransmitted > cached_txp_total) {\n            diff = data.packetsTransmitted - cached_txp_total;\n            diff = (1000 * diff) / passedTimeInMs; /* convert to pkts/s */\n            cached_txp_diff = (uint32_t)diff;\n         } else {\n            cached_txp_diff = 0;\n         }\n      }\n\n      cached_rxb_total = data.bytesReceived;\n      cached_rxp_total = data.packetsReceived;\n      cached_txb_total = data.bytesTransmitted;\n      cached_txp_total = data.packetsTransmitted;\n   }\n\n   this->values[0] = cached_rxb_diff;\n   this->values[1] = cached_txb_diff;\n   if (cached_rxb_diff + cached_txb_diff > this->total) {\n      this->total = cached_rxb_diff + cached_txb_diff;\n   }\n\n   if (status == RATESTATUS_NODATA) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"no data\");\n      return;\n   }\n   if (status == RATESTATUS_INIT) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"init\");\n      return;\n   }\n   if (status == RATESTATUS_STALE) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"stale\");\n      return;\n   }\n\n   xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"rx:%siB/s tx:%siB/s %u/%upkts/s\",\n      cached_rxb_diff_str, cached_txb_diff_str, cached_rxp_diff, cached_txp_diff);\n}\n\nstatic void NetworkIOMeter_display(ATTR_UNUSED const Object* cast, RichString* out) {\n   switch (status) {\n      case RATESTATUS_NODATA:\n         RichString_writeAscii(out, CRT_colors[METER_VALUE_ERROR], \"no data\");\n         return;\n      case RATESTATUS_INIT:\n         RichString_writeAscii(out, CRT_colors[METER_VALUE], \"initializing...\");\n         return;\n      case RATESTATUS_STALE:\n         RichString_writeAscii(out, CRT_colors[METER_VALUE_WARN], \"stale data\");\n         return;\n      case RATESTATUS_DATA:\n         break;\n   }\n\n   char buffer[64];\n\n   RichString_writeAscii(out, CRT_colors[METER_TEXT], \"rx: \");\n   RichString_appendAscii(out, CRT_colors[METER_VALUE_IOREAD], cached_rxb_diff_str);\n   RichString_appendAscii(out, CRT_colors[METER_VALUE_IOREAD], \"iB/s\");\n\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \" tx: \");\n   RichString_appendAscii(out, CRT_colors[METER_VALUE_IOWRITE], cached_txb_diff_str);\n   RichString_appendAscii(out, CRT_colors[METER_VALUE_IOWRITE], \"iB/s\");\n\n   int len = xSnprintf(buffer, sizeof(buffer), \" (%u/%u pkts/s) \", cached_rxp_diff, cached_txp_diff);\n   RichString_appendnAscii(out, CRT_colors[METER_TEXT], buffer, len);\n}\n\nconst MeterClass NetworkIOMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = NetworkIOMeter_display\n   },\n   .updateValues = NetworkIOMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = 2,\n   .total = 100.0,\n   .attributes = NetworkIOMeter_attributes,\n   .name = \"NetworkIO\",\n   .uiName = \"Network IO\",\n   .caption = \"Network: \"\n};\n"
        },
        {
          "name": "NetworkIOMeter.h",
          "type": "blob",
          "size": 0.4970703125,
          "content": "#ifndef HEADER_NetworkIOMeter\n#define HEADER_NetworkIOMeter\n/*\nhtop - NetworkIOMeter.h\n(C) 2020-2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdint.h>\n\n#include \"Meter.h\"\n\n\ntypedef struct NetworkIOData_ {\n   uint64_t bytesReceived;\n   uint64_t packetsReceived;\n   uint64_t bytesTransmitted;\n   uint64_t packetsTransmitted;\n} NetworkIOData;\n\nextern const MeterClass NetworkIOMeter_class;\n\n#endif /* HEADER_NetworkIOMeter */\n"
        },
        {
          "name": "Object.c",
          "type": "blob",
          "size": 0.5771484375,
          "content": "/*\nhtop - Object.c\n(C) 2004-2012 Hisham H. Muhammad\n(C) 2020 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Object.h\"\n\n#include <stddef.h>\n\n\nconst ObjectClass Object_class = {\n   .extends = NULL\n};\n\nbool Object_isA(const Object* o, const ObjectClass* klass) {\n   if (!o)\n      return false;\n\n   for (const ObjectClass* type = o->klass; type; type = type->extends) {\n      if (type == klass) {\n         return true;\n      }\n   }\n\n   return false;\n}\n"
        },
        {
          "name": "Object.h",
          "type": "blob",
          "size": 1.7177734375,
          "content": "#ifndef HEADER_Object\n#define HEADER_Object\n/*\nhtop - Object.h\n(C) 2004-2012 Hisham H. Muhammad\n(C) 2020 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <assert.h>\n#include <stdbool.h>\n\n#include \"RichString.h\"\n#include \"XUtils.h\" // IWYU pragma: keep\n\n\nstruct Object_;\ntypedef struct Object_ Object;\n\ntypedef void(*Object_Display)(const Object*, RichString*);\ntypedef int(*Object_Compare)(const void*, const void*);\ntypedef void(*Object_Delete)(Object*);\n\n#define Object_getClass(obj_)         ((const Object*)(obj_))->klass\n#define Object_setClass(obj_, class_) (((Object*)(obj_))->klass = (const ObjectClass*) (class_))\n\n#define Object_delete(obj_)           (assert(Object_getClass(obj_)->delete), Object_getClass(obj_)->delete((Object*)(obj_)))\n#define Object_displayFn(obj_)        Object_getClass(obj_)->display\n#define Object_display(obj_, str_)    (assert(Object_getClass(obj_)->display), Object_getClass(obj_)->display((const Object*)(obj_), str_))\n#define Object_compare(obj_, other_)  (assert(Object_getClass(obj_)->compare), Object_getClass(obj_)->compare((const void*)(obj_), other_))\n\n#define Class(class_)                 ((const ObjectClass*)(&(class_ ## _class)))\n\n#define AllocThis(class_) (class_*)   xMalloc(sizeof(class_)); Object_setClass(this, Class(class_))\n\ntypedef struct ObjectClass_ {\n   const void* const extends;\n   const Object_Display display;\n   const Object_Delete delete;\n   const Object_Compare compare;\n} ObjectClass;\n\nstruct Object_ {\n   const ObjectClass* klass;\n};\n\ntypedef union {\n   int i;\n   void* v;\n} Arg;\n\nextern const ObjectClass Object_class;\n\nbool Object_isA(const Object* o, const ObjectClass* klass);\n\n#endif\n"
        },
        {
          "name": "OpenFilesScreen.c",
          "type": "blob",
          "size": 9.40234375,
          "content": "/*\nhtop - OpenFilesScreen.c\n(C) 2005-2006 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"OpenFilesScreen.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n\n#include \"Macros.h\"\n#include \"Panel.h\"\n#include \"ProvideCurses.h\"\n#include \"Vector.h\"\n#include \"XUtils.h\"\n\n\n// cf. getIndexForType; must be larger than the maximum value returned.\n#define LSOF_DATACOL_COUNT 8\n\ntypedef struct OpenFiles_Data_ {\n   char* data[LSOF_DATACOL_COUNT];\n} OpenFiles_Data;\n\ntypedef struct OpenFiles_ProcessData_ {\n   OpenFiles_Data data;\n   int error;\n   int cols[LSOF_DATACOL_COUNT];\n   struct OpenFiles_FileData_* files;\n} OpenFiles_ProcessData;\n\ntypedef struct OpenFiles_FileData_ {\n   OpenFiles_Data data;\n   struct OpenFiles_FileData_* next;\n} OpenFiles_FileData;\n\nstatic size_t getIndexForType(char type) {\n   switch (type) {\n      case 'f':\n         return 0;\n      case 'a':\n         return 1;\n      case 'D':\n         return 2;\n      case 'i':\n         return 3;\n      case 'n':\n         return 4;\n      case 's':\n         return 5;\n      case 't':\n         return 6;\n      case 'o':\n         return 7;\n   }\n\n   /* should never reach here */\n   abort();\n}\n\nstatic const char* getDataForType(const OpenFiles_Data* data, char type) {\n   size_t index = getIndexForType(type);\n   return data->data[index] ? data->data[index] : \"\";\n}\n\nOpenFilesScreen* OpenFilesScreen_new(const Process* process) {\n   OpenFilesScreen* this = xCalloc(1, sizeof(OpenFilesScreen));\n   Object_setClass(this, Class(OpenFilesScreen));\n   if (Process_isThread(process)) {\n      this->pid = Process_getThreadGroup(process);\n   } else {\n      this->pid = Process_getPid(process);\n   }\n   return (OpenFilesScreen*) InfoScreen_init(&this->super, process, NULL, LINES - 2, \"   FD TYPE    MODE DEVICE           SIZE     OFFSET       NODE  NAME\");\n}\n\nvoid OpenFilesScreen_delete(Object* this) {\n   free(InfoScreen_done((InfoScreen*)this));\n}\n\nstatic void OpenFilesScreen_draw(InfoScreen* this) {\n   InfoScreen_drawTitled(this, \"Snapshot of files open in process %d - %s\", ((OpenFilesScreen*)this)->pid, Process_getCommand(this->process));\n}\n\nstatic OpenFiles_ProcessData* OpenFilesScreen_getProcessData(pid_t pid) {\n   OpenFiles_ProcessData* pdata = xCalloc(1, sizeof(OpenFiles_ProcessData));\n   pdata->cols[getIndexForType('s')] = 8;\n   pdata->cols[getIndexForType('o')] = 8;\n   pdata->cols[getIndexForType('i')] = 8;\n\n   int fdpair[2] = {0, 0};\n   if (pipe(fdpair) == -1) {\n      pdata->error = 1;\n      return pdata;\n   }\n\n   pid_t child = fork();\n   if (child == -1) {\n      close(fdpair[1]);\n      close(fdpair[0]);\n      pdata->error = 1;\n      return pdata;\n   }\n\n   if (child == 0) {\n      close(fdpair[0]);\n      dup2(fdpair[1], STDOUT_FILENO);\n      close(fdpair[1]);\n      int fdnull = open(\"/dev/null\", O_WRONLY);\n      if (fdnull < 0) {\n         exit(1);\n      }\n\n      dup2(fdnull, STDERR_FILENO);\n      close(fdnull);\n      char buffer[32] = {0};\n      xSnprintf(buffer, sizeof(buffer), \"%d\", pid);\n      // Use of NULL in variadic functions must have a pointer cast.\n      // The NULL constant is not required by standard to have a pointer type.\n      execlp(\"lsof\", \"lsof\", \"-P\", \"-o\", \"-p\", buffer, \"-F\", (char*)NULL);\n      exit(127);\n   }\n   close(fdpair[1]);\n\n   OpenFiles_Data* item = &(pdata->data);\n   OpenFiles_FileData* fdata = NULL;\n   bool lsofIncludesFileSize = false;\n\n   FILE* fp = fdopen(fdpair[0], \"r\");\n   if (!fp) {\n      pdata->error = 1;\n      return pdata;\n   }\n   for (;;) {\n      char* line = String_readLine(fp);\n      if (!line) {\n         break;\n      }\n\n      unsigned char cmd = line[0];\n      switch (cmd) {\n         case 'f':  /* file descriptor */\n         {\n            OpenFiles_FileData* nextFile = xCalloc(1, sizeof(OpenFiles_FileData));\n            if (fdata == NULL) {\n               pdata->files = nextFile;\n            } else {\n               fdata->next = nextFile;\n            }\n            fdata = nextFile;\n            item = &(fdata->data);\n         } /* FALLTHRU */\n         case 'a':  /* file access mode */\n         case 'D':  /* file's major/minor device number */\n         case 'i':  /* file's inode number */\n         case 'n':  /* file name, comment, Internet address */\n         case 's':  /* file's size */\n         case 't':  /* file's type */\n         {\n            size_t index = getIndexForType(cmd);\n            free_and_xStrdup(&item->data[index], line + 1);\n            size_t dlen = strlen(item->data[index]);\n            if (dlen > (size_t)pdata->cols[index]) {\n               pdata->cols[index] = (int)CLAMP(dlen, 0, INT16_MAX);\n            }\n            break;\n         }\n         case 'o':  /* file's offset */\n         {\n            size_t index = getIndexForType(cmd);\n            if (String_startsWith(line + 1, \"0t\")) {\n               free_and_xStrdup(&item->data[index], line + 3);\n            } else {\n               free_and_xStrdup(&item->data[index], line + 1);\n            }\n            size_t dlen = strlen(item->data[index]);\n            if (dlen > (size_t)pdata->cols[index]) {\n               pdata->cols[index] = (int)CLAMP(dlen, 0, INT16_MAX);\n            }\n            break;\n         }\n         case 'c':  /* process command name  */\n         case 'd':  /* file's device character code */\n         case 'g':  /* process group ID */\n         case 'G':  /* file flags */\n         case 'k':  /* link count */\n         case 'l':  /* file's lock status */\n         case 'L':  /* process login name */\n         case 'p':  /* process ID */\n         case 'P':  /* protocol name */\n         case 'R':  /* parent process ID */\n         case 'T':  /* TCP/TPI information, identified by prefixes */\n         case 'u':  /* process user ID */\n            /* ignore */\n            break;\n      }\n\n      if (cmd == 's')\n         lsofIncludesFileSize = true;\n\n      free(line);\n   }\n   fclose(fp);\n\n   int wstatus;\n   while (waitpid(child, &wstatus, 0) == -1)\n      if (errno != EINTR) {\n         pdata->error = 1;\n         return pdata;\n      }\n\n   if (!WIFEXITED(wstatus)) {\n      pdata->error = 1;\n   } else {\n      pdata->error = WEXITSTATUS(wstatus);\n   }\n\n   /* We got all information we need; no post-processing needed */\n   if (lsofIncludesFileSize)\n      return pdata;\n\n   /* On linux, `lsof -o -F` omits SIZE, so add it back. */\n   /* On macOS, `lsof -o -F` includes SIZE, so this block isn't needed.  If no open files have a filesize, this will still run, unfortunately. */\n   size_t fileSizeIndex = getIndexForType('s');\n   for (fdata = pdata->files; fdata != NULL; fdata = fdata->next) {\n      item = &fdata->data;\n      const char* filename = getDataForType(item, 'n');\n\n      struct stat sb;\n      if (stat(filename, &sb) == 0) {\n         char fileSizeBuf[21]; /* 20 (long long) + 1 (NULL) */\n         xSnprintf(fileSizeBuf, sizeof(fileSizeBuf), \"%\"PRIu64, (uint64_t)sb.st_size); /* sb.st_size is long long on macOS, long on linux */\n         free_and_xStrdup(&item->data[fileSizeIndex], fileSizeBuf);\n      }\n   }\n\n   return pdata;\n}\n\nstatic void OpenFiles_Data_clear(OpenFiles_Data* data) {\n   for (size_t i = 0; i < ARRAYSIZE(data->data); i++)\n      free(data->data[i]);\n}\n\nstatic void OpenFilesScreen_scan(InfoScreen* super) {\n   Panel* panel = super->display;\n   int idx = Panel_getSelectedIndex(panel);\n   Panel_prune(panel);\n   OpenFiles_ProcessData* pdata = OpenFilesScreen_getProcessData(((OpenFilesScreen*)super)->pid);\n   if (pdata->error == 127) {\n      InfoScreen_addLine(super, \"Could not execute 'lsof'. Please make sure it is available in your $PATH.\");\n   } else if (pdata->error == 1) {\n      InfoScreen_addLine(super, \"Failed listing open files.\");\n   } else {\n      char hdrbuf[128] = {0};\n      snprintf(hdrbuf, sizeof(hdrbuf), \"%5.5s %-7.7s %-4.4s %6.6s %*s %*s %*s  %s\",\n         \"FD\", \"TYPE\", \"MODE\", \"DEVICE\",\n         pdata->cols[getIndexForType('s')], \"SIZE\",\n         pdata->cols[getIndexForType('o')], \"OFFSET\",\n         pdata->cols[getIndexForType('i')], \"NODE\",\n         \"NAME\"\n      );\n      Panel_setHeader(panel, hdrbuf);\n\n      OpenFiles_FileData* fdata = pdata->files;\n      while (fdata) {\n         OpenFiles_Data* data = &fdata->data;\n         char* entry = NULL;\n         xAsprintf(&entry, \"%5.5s %-7.7s %-4.4s %6.6s %*s %*s %*s  %s\",\n                   getDataForType(data, 'f'),\n                   getDataForType(data, 't'),\n                   getDataForType(data, 'a'),\n                   getDataForType(data, 'D'),\n                   pdata->cols[getIndexForType('s')],\n                   getDataForType(data, 's'),\n                   pdata->cols[getIndexForType('o')],\n                   getDataForType(data, 'o'),\n                   pdata->cols[getIndexForType('i')],\n                   getDataForType(data, 'i'),\n                   getDataForType(data, 'n'));\n         InfoScreen_addLine(super, entry);\n         free(entry);\n         OpenFiles_Data_clear(data);\n         OpenFiles_FileData* old = fdata;\n         fdata = fdata->next;\n         free(old);\n      }\n      OpenFiles_Data_clear(&pdata->data);\n   }\n   free(pdata);\n   Vector_insertionSort(super->lines);\n   Vector_insertionSort(panel->items);\n   Panel_setSelected(panel, idx);\n}\n\nconst InfoScreenClass OpenFilesScreen_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = OpenFilesScreen_delete\n   },\n   .scan = OpenFilesScreen_scan,\n   .draw = OpenFilesScreen_draw\n};\n"
        },
        {
          "name": "OpenFilesScreen.h",
          "type": "blob",
          "size": 0.55859375,
          "content": "#ifndef HEADER_OpenFilesScreen\n#define HEADER_OpenFilesScreen\n/*\nhtop - OpenFilesScreen.h\n(C) 2005-2006 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <sys/types.h>\n\n#include \"InfoScreen.h\"\n#include \"Object.h\"\n#include \"Process.h\"\n\n\ntypedef struct OpenFilesScreen_ {\n   InfoScreen super;\n   pid_t pid;\n} OpenFilesScreen;\n\nextern const InfoScreenClass OpenFilesScreen_class;\n\nOpenFilesScreen* OpenFilesScreen_new(const Process* process);\n\nvoid OpenFilesScreen_delete(Object* this);\n\n#endif\n"
        },
        {
          "name": "OptionItem.c",
          "type": "blob",
          "size": 5.3369140625,
          "content": "/*\nhtop - OptionItem.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"OptionItem.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <stdlib.h>\n\n#include \"CRT.h\"\n#include \"Macros.h\"\n#include \"RichString.h\"\n#include \"XUtils.h\"\n\n\nstatic void OptionItem_delete(Object* cast) {\n   OptionItem* this = (OptionItem*)cast;\n   assert (this != NULL);\n\n   free(this->text);\n   free(this);\n}\n\nstatic void TextItem_display(const Object* cast, RichString* out) {\n   const TextItem* this = (const TextItem*)cast;\n   assert (this != NULL);\n\n   RichString_appendWide(out, CRT_colors[HELP_BOLD], this->super.text);\n}\n\nstatic void CheckItem_display(const Object* cast, RichString* out) {\n   const CheckItem* this = (const CheckItem*)cast;\n   assert (this != NULL);\n\n   RichString_writeAscii(out, CRT_colors[CHECK_BOX], \"[\");\n   if (CheckItem_get(this)) {\n      RichString_appendAscii(out, CRT_colors[CHECK_MARK], \"x\");\n   } else {\n      RichString_appendAscii(out, CRT_colors[CHECK_MARK], \" \");\n   }\n   RichString_appendAscii(out, CRT_colors[CHECK_BOX], \"]    \");\n   RichString_appendWide(out, CRT_colors[CHECK_TEXT], this->super.text);\n}\n\nstatic void NumberItem_display(const Object* cast, RichString* out) {\n   const NumberItem* this = (const NumberItem*)cast;\n   assert (this != NULL);\n\n   char buffer[12];\n   RichString_writeAscii(out, CRT_colors[CHECK_BOX], \"[\");\n   int written;\n   if (this->scale < 0) {\n      written = xSnprintf(buffer, sizeof(buffer), \"%.*f\", -this->scale, pow(10, this->scale) * NumberItem_get(this));\n   } else if (this->scale > 0) {\n      written = xSnprintf(buffer, sizeof(buffer), \"%d\", (int) (pow(10, this->scale) * NumberItem_get(this)));\n   } else {\n      written = xSnprintf(buffer, sizeof(buffer), \"%d\", NumberItem_get(this));\n   }\n   RichString_appendnAscii(out, CRT_colors[CHECK_MARK], buffer, written);\n   RichString_appendAscii(out, CRT_colors[CHECK_BOX], \"]\");\n   for (int i = written; i < 5; i++) {\n      RichString_appendAscii(out, CRT_colors[CHECK_BOX], \" \");\n   }\n   RichString_appendWide(out, CRT_colors[CHECK_TEXT], this->super.text);\n}\n\nconst OptionItemClass OptionItem_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = OptionItem_delete\n   }\n};\n\nconst OptionItemClass TextItem_class = {\n   .super = {\n      .extends = Class(OptionItem),\n      .delete = OptionItem_delete,\n      .display = TextItem_display\n   },\n   .kind = OPTION_ITEM_TEXT\n};\n\n\nconst OptionItemClass CheckItem_class = {\n   .super = {\n      .extends = Class(OptionItem),\n      .delete = OptionItem_delete,\n      .display = CheckItem_display\n   },\n   .kind = OPTION_ITEM_CHECK\n};\n\n\nconst OptionItemClass NumberItem_class = {\n   .super = {\n      .extends = Class(OptionItem),\n      .delete = OptionItem_delete,\n      .display = NumberItem_display\n   },\n   .kind = OPTION_ITEM_NUMBER\n};\n\nTextItem* TextItem_new(const char* text) {\n   TextItem* this = AllocThis(TextItem);\n   this->super.text = xStrdup(text);\n   return this;\n}\n\nCheckItem* CheckItem_newByRef(const char* text, bool* ref) {\n   CheckItem* this = AllocThis(CheckItem);\n   this->super.text = xStrdup(text);\n   this->value = false;\n   this->ref = ref;\n   return this;\n}\n\nCheckItem* CheckItem_newByVal(const char* text, bool value) {\n   CheckItem* this = AllocThis(CheckItem);\n   this->super.text = xStrdup(text);\n   this->value = value;\n   this->ref = NULL;\n   return this;\n}\n\nbool CheckItem_get(const CheckItem* this) {\n   if (this->ref) {\n      return *(this->ref);\n   } else {\n      return this->value;\n   }\n}\n\nvoid CheckItem_set(CheckItem* this, bool value) {\n   if (this->ref) {\n      *(this->ref) = value;\n   } else {\n      this->value = value;\n   }\n}\n\nvoid CheckItem_toggle(CheckItem* this) {\n   if (this->ref) {\n      *(this->ref) = !*(this->ref);\n   } else {\n      this->value = !this->value;\n   }\n}\n\nNumberItem* NumberItem_newByRef(const char* text, int* ref, int scale, int min, int max) {\n   assert(min <= max);\n\n   NumberItem* this = AllocThis(NumberItem);\n   this->super.text = xStrdup(text);\n   this->value = 0;\n   this->ref = ref;\n   this->scale = scale;\n   this->min = min;\n   this->max = max;\n   return this;\n}\n\nNumberItem* NumberItem_newByVal(const char* text, int value, int scale, int min, int max) {\n   assert(min <= max);\n\n   NumberItem* this = AllocThis(NumberItem);\n   this->super.text = xStrdup(text);\n   this->value = CLAMP(value, min, max);\n   this->ref = NULL;\n   this->scale = scale;\n   this->min = min;\n   this->max = max;\n   return this;\n}\n\nint NumberItem_get(const NumberItem* this) {\n   if (this->ref) {\n      return *(this->ref);\n   } else {\n      return this->value;\n   }\n}\n\nvoid NumberItem_decrease(NumberItem* this) {\n   if (this->ref) {\n      *(this->ref) = CLAMP(*(this->ref) - 1, this->min, this->max);\n   } else {\n      this->value = CLAMP(this->value - 1, this->min, this->max);\n   }\n}\n\nvoid NumberItem_increase(NumberItem* this) {\n   if (this->ref) {\n      *(this->ref) = CLAMP(*(this->ref) + 1, this->min, this->max);\n   } else {\n      this->value = CLAMP(this->value + 1, this->min, this->max);\n   }\n}\n\nvoid NumberItem_toggle(NumberItem* this) {\n   if (this->ref) {\n      if (*(this->ref) >= this->max)\n         *(this->ref) = this->min;\n      else\n         *(this->ref) += 1;\n   } else {\n      if (this->value >= this->max)\n         this->value = this->min;\n      else\n         this->value += 1;\n   }\n}\n"
        },
        {
          "name": "OptionItem.h",
          "type": "blob",
          "size": 1.818359375,
          "content": "#ifndef HEADER_OptionItem\n#define HEADER_OptionItem\n/*\nhtop - OptionItem.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Object.h\"\n\n\nenum OptionItemType {\n   OPTION_ITEM_TEXT,\n   OPTION_ITEM_CHECK,\n   OPTION_ITEM_NUMBER,\n};\n\ntypedef struct OptionItemClass_ {\n   const ObjectClass super;\n\n   enum OptionItemType kind;\n} OptionItemClass;\n\n#define As_OptionItem(this_)                ((const OptionItemClass*)((this_)->super.klass))\n#define OptionItem_kind(this_)              As_OptionItem(this_)->kind\n\ntypedef struct OptionItem_ {\n   Object super;\n\n   char* text;\n} OptionItem;\n\ntypedef struct TextItem_ {\n   OptionItem super;\n\n   char* text;\n} TextItem;\n\ntypedef struct CheckItem_ {\n   OptionItem super;\n\n   bool* ref;\n   bool value;\n} CheckItem;\n\ntypedef struct NumberItem_ {\n   OptionItem super;\n\n   char* text;\n   int* ref;\n   int value;\n   int scale;\n   int min;\n   int max;\n} NumberItem;\n\nextern const OptionItemClass OptionItem_class;\nextern const OptionItemClass TextItem_class;\nextern const OptionItemClass CheckItem_class;\nextern const OptionItemClass NumberItem_class;\n\nTextItem* TextItem_new(const char* text);\n\nCheckItem* CheckItem_newByRef(const char* text, bool* ref);\nCheckItem* CheckItem_newByVal(const char* text, bool value);\nbool CheckItem_get(const CheckItem* this);\nvoid CheckItem_set(CheckItem* this, bool value);\nvoid CheckItem_toggle(CheckItem* this);\n\nNumberItem* NumberItem_newByRef(const char* text, int* ref, int scale, int min, int max);\nNumberItem* NumberItem_newByVal(const char* text, int value, int scale, int min, int max);\nint NumberItem_get(const NumberItem* this);\nvoid NumberItem_decrease(NumberItem* this);\nvoid NumberItem_increase(NumberItem* this);\nvoid NumberItem_toggle(NumberItem* this);\n\n#endif\n"
        },
        {
          "name": "Panel.c",
          "type": "blob",
          "size": 12.9775390625,
          "content": "/*\nhtop - Panel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Panel.h\"\n\n#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n\n#include \"CRT.h\"\n#include \"ListItem.h\"\n#include \"Macros.h\"\n#include \"ProvideCurses.h\"\n#include \"RichString.h\"\n#include \"XUtils.h\"\n\n\nconst PanelClass Panel_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = Panel_delete\n   },\n   .eventHandler = Panel_selectByTyping,\n};\n\nPanel* Panel_new(int x, int y, int w, int h, const ObjectClass* type, bool owner, FunctionBar* fuBar) {\n   Panel* this;\n   this = xMalloc(sizeof(Panel));\n   Object_setClass(this, Class(Panel));\n   Panel_init(this, x, y, w, h, type, owner, fuBar);\n   return this;\n}\n\nvoid Panel_delete(Object* cast) {\n   Panel* this = (Panel*)cast;\n   Panel_done(this);\n   free(this);\n}\n\nvoid Panel_init(Panel* this, int x, int y, int w, int h, const ObjectClass* type, bool owner, FunctionBar* fuBar) {\n   this->x = x;\n   this->y = y;\n   this->w = w;\n   this->h = h;\n   this->cursorX = 0;\n   this->cursorY = 0;\n   this->eventHandlerState = NULL;\n   this->items = Vector_new(type, owner, DEFAULT_SIZE);\n   this->scrollV = 0;\n   this->scrollH = 0;\n   this->selected = 0;\n   this->oldSelected = 0;\n   this->selectedLen = 0;\n   this->needsRedraw = true;\n   this->cursorOn = false;\n   this->wasFocus = false;\n   RichString_beginAllocated(this->header);\n   this->defaultBar = fuBar;\n   this->currentBar = fuBar;\n   this->selectionColorId = PANEL_SELECTION_FOCUS;\n}\n\nvoid Panel_done(Panel* this) {\n   assert (this != NULL);\n   free(this->eventHandlerState);\n   Vector_delete(this->items);\n   FunctionBar_delete(this->defaultBar);\n   RichString_delete(&this->header);\n}\n\nvoid Panel_setCursorToSelection(Panel* this) {\n   this->cursorY = this->y + this->selected - this->scrollV + 1;\n   this->cursorX = this->x + this->selectedLen - this->scrollH;\n}\n\nvoid Panel_setSelectionColor(Panel* this, ColorElements colorId) {\n   this->selectionColorId = colorId;\n}\n\ninline void Panel_setHeader(Panel* this, const char* header) {\n   RichString_writeWide(&(this->header), CRT_colors[PANEL_HEADER_FOCUS], header);\n   this->needsRedraw = true;\n}\n\nvoid Panel_move(Panel* this, int x, int y) {\n   assert (this != NULL);\n\n   this->x = x;\n   this->y = y;\n   this->needsRedraw = true;\n}\n\nvoid Panel_resize(Panel* this, int w, int h) {\n   assert (this != NULL);\n\n   this->w = w;\n   this->h = h;\n   this->needsRedraw = true;\n}\n\nvoid Panel_prune(Panel* this) {\n   assert (this != NULL);\n\n   Vector_prune(this->items);\n   this->scrollV = 0;\n   this->selected = 0;\n   this->oldSelected = 0;\n   this->needsRedraw = true;\n}\n\nvoid Panel_add(Panel* this, Object* o) {\n   assert (this != NULL);\n\n   Vector_add(this->items, o);\n   this->needsRedraw = true;\n}\n\nvoid Panel_insert(Panel* this, int i, Object* o) {\n   assert (this != NULL);\n\n   Vector_insert(this->items, i, o);\n   this->needsRedraw = true;\n}\n\nvoid Panel_set(Panel* this, int i, Object* o) {\n   assert (this != NULL);\n\n   Vector_set(this->items, i, o);\n}\n\nObject* Panel_get(Panel* this, int i) {\n   assert (this != NULL);\n\n   return Vector_get(this->items, i);\n}\n\nObject* Panel_remove(Panel* this, int i) {\n   assert (this != NULL);\n\n   this->needsRedraw = true;\n   Object* removed = Vector_remove(this->items, i);\n   if (this->selected > 0 && this->selected >= Vector_size(this->items)) {\n      this->selected--;\n   }\n\n   return removed;\n}\n\nObject* Panel_getSelected(Panel* this) {\n   assert (this != NULL);\n   if (Vector_size(this->items) > 0) {\n      return Vector_get(this->items, this->selected);\n   } else {\n      return NULL;\n   }\n}\n\nvoid Panel_moveSelectedUp(Panel* this) {\n   assert (this != NULL);\n\n   Vector_moveUp(this->items, this->selected);\n   if (this->selected > 0) {\n      this->selected--;\n   }\n}\n\nvoid Panel_moveSelectedDown(Panel* this) {\n   assert (this != NULL);\n\n   Vector_moveDown(this->items, this->selected);\n   if (this->selected + 1 < Vector_size(this->items)) {\n      this->selected++;\n   }\n}\n\nint Panel_getSelectedIndex(const Panel* this) {\n   assert (this != NULL);\n\n   return this->selected;\n}\n\nint Panel_size(const Panel* this) {\n   assert (this != NULL);\n\n   return Vector_size(this->items);\n}\n\nvoid Panel_setSelected(Panel* this, int selected) {\n   assert (this != NULL);\n\n   int size = Vector_size(this->items);\n   if (selected >= size) {\n      selected = size - 1;\n   }\n   if (selected < 0) {\n      selected = 0;\n   }\n   this->selected = selected;\n   if (Panel_eventHandlerFn(this)) {\n      Panel_eventHandler(this, EVENT_SET_SELECTED);\n   }\n}\n\nvoid Panel_splice(Panel* this, Vector* from) {\n   assert (this != NULL);\n   assert (from != NULL);\n\n   Vector_splice(this->items, from);\n   this->needsRedraw = true;\n}\n\nvoid Panel_draw(Panel* this, bool force_redraw, bool focus, bool highlightSelected, bool hideFunctionBar) {\n   assert (this != NULL);\n\n   int size = Vector_size(this->items);\n   int scrollH = this->scrollH;\n   int y = this->y;\n   int x = this->x;\n   int h = this->h;\n\n   if (hideFunctionBar)\n      h++;\n\n   const int header_attr = focus\n                         ? CRT_colors[PANEL_HEADER_FOCUS]\n                         : CRT_colors[PANEL_HEADER_UNFOCUS];\n   if (force_redraw) {\n      if (Panel_printHeaderFn(this))\n         Panel_printHeader(this);\n      else\n         RichString_setAttr(&this->header, header_attr);\n   }\n   int headerLen = RichString_sizeVal(this->header);\n   if (headerLen > 0) {\n      attrset(header_attr);\n      mvhline(y, x, ' ', this->w);\n      if (scrollH < headerLen) {\n         RichString_printoffnVal(this->header, y, x, scrollH,\n            MINIMUM(headerLen - scrollH, this->w));\n      }\n      attrset(CRT_colors[RESET_COLOR]);\n      y++;\n      h--;\n   }\n\n   // ensure scroll area is on screen\n   if (this->scrollV < 0) {\n      this->scrollV = 0;\n      this->needsRedraw = true;\n   } else if (this->scrollV > size - h) {\n      this->scrollV = MAXIMUM(size - h, 0);\n      this->needsRedraw = true;\n   }\n   // ensure selection is on screen\n   if (this->selected < this->scrollV) {\n      this->scrollV = this->selected;\n      this->needsRedraw = true;\n   } else if (this->selected >= this->scrollV + h) {\n      this->scrollV = this->selected - h + 1;\n      this->needsRedraw = true;\n   }\n\n   int first = this->scrollV;\n   int upTo = MINIMUM(first + h, size);\n\n   int selectionColor = focus\n      ? CRT_colors[this->selectionColorId]\n      : CRT_colors[PANEL_SELECTION_UNFOCUS];\n\n   if (this->needsRedraw || force_redraw) {\n      int line = 0;\n      for (int i = first; line < h && i < upTo; i++) {\n         const Object* itemObj = Vector_get(this->items, i);\n         RichString_begin(item);\n         Object_display(itemObj, &item);\n         int itemLen = RichString_sizeVal(item);\n         int amt = MINIMUM(itemLen - scrollH, this->w);\n         if (highlightSelected && i == this->selected) {\n            item.highlightAttr = selectionColor;\n         }\n         if (item.highlightAttr) {\n            attrset(item.highlightAttr);\n            RichString_setAttr(&item, item.highlightAttr);\n            this->selectedLen = itemLen;\n         }\n         mvhline(y + line, x, ' ', this->w);\n         if (amt > 0)\n            RichString_printoffnVal(item, y + line, x, scrollH, amt);\n         if (item.highlightAttr)\n            attrset(CRT_colors[RESET_COLOR]);\n         RichString_delete(&item);\n         line++;\n      }\n      while (line < h) {\n         mvhline(y + line, x, ' ', this->w);\n         line++;\n      }\n\n   } else {\n      const Object* oldObj = Vector_get(this->items, this->oldSelected);\n      RichString_begin(old);\n      Object_display(oldObj, &old);\n      int oldLen = RichString_sizeVal(old);\n      const Object* newObj = Vector_get(this->items, this->selected);\n      RichString_begin(new);\n      Object_display(newObj, &new);\n      int newLen = RichString_sizeVal(new);\n      this->selectedLen = newLen;\n      mvhline(y + this->oldSelected - first, x + 0, ' ', this->w);\n      if (scrollH < oldLen)\n         RichString_printoffnVal(old, y + this->oldSelected - first, x,\n            scrollH, MINIMUM(oldLen - scrollH, this->w));\n      attrset(selectionColor);\n      mvhline(y + this->selected - first, x + 0, ' ', this->w);\n      RichString_setAttr(&new, selectionColor);\n      if (scrollH < newLen)\n         RichString_printoffnVal(new, y + this->selected - first, x,\n            scrollH, MINIMUM(newLen - scrollH, this->w));\n      attrset(CRT_colors[RESET_COLOR]);\n      RichString_delete(&new);\n      RichString_delete(&old);\n   }\n\n   if (focus && (this->needsRedraw || force_redraw || !this->wasFocus)) {\n      if (Panel_drawFunctionBarFn(this))\n         Panel_drawFunctionBar(this, hideFunctionBar);\n      else if (!hideFunctionBar)\n         FunctionBar_draw(this->currentBar);\n   }\n\n   this->oldSelected = this->selected;\n   this->wasFocus = focus;\n   this->needsRedraw = false;\n}\n\nstatic int Panel_headerHeight(const Panel* this) {\n   return RichString_sizeVal(this->header) > 0 ? 1 : 0;\n}\n\nbool Panel_onKey(Panel* this, int key) {\n   assert (this != NULL);\n\n   const int size = Vector_size(this->items);\n\n   #define PANEL_SCROLL(amount)                                                                                     \\\n   do {                                                                                                             \\\n      this->selected += (amount);                                                                                   \\\n      this->scrollV = CLAMP(this->scrollV + (amount), 0, MAXIMUM(0, (size - this->h - Panel_headerHeight(this))));  \\\n      this->needsRedraw = true;                                                                                     \\\n   } while (0)\n\n   switch (key) {\n      case KEY_DOWN:\n      case KEY_CTRL('N'):\n      #ifdef KEY_C_DOWN\n      case KEY_C_DOWN:\n      #endif\n         this->selected++;\n         break;\n\n      case KEY_UP:\n      case KEY_CTRL('P'):\n      #ifdef KEY_C_UP\n      case KEY_C_UP:\n      #endif\n         this->selected--;\n         break;\n\n      case KEY_LEFT:\n      case KEY_CTRL('B'):\n         if (this->scrollH > 0) {\n            this->scrollH -= MAXIMUM(CRT_scrollHAmount, 0);\n            this->needsRedraw = true;\n         }\n         break;\n\n      case KEY_RIGHT:\n      case KEY_CTRL('F'):\n         this->scrollH += CRT_scrollHAmount;\n         this->needsRedraw = true;\n         break;\n\n      case KEY_PPAGE:\n         PANEL_SCROLL(-(this->h - Panel_headerHeight(this)));\n         break;\n\n      case KEY_NPAGE:\n         PANEL_SCROLL(+(this->h - Panel_headerHeight(this)));\n         break;\n\n      case KEY_WHEELUP:\n         PANEL_SCROLL(-CRT_scrollWheelVAmount);\n         break;\n\n      case KEY_WHEELDOWN:\n         PANEL_SCROLL(+CRT_scrollWheelVAmount);\n         break;\n\n      case KEY_HOME:\n         this->selected = 0;\n         break;\n\n      case KEY_END:\n         this->selected = size - 1;\n         break;\n\n      case KEY_CTRL('A'):\n      case '^':\n         this->scrollH = 0;\n         this->needsRedraw = true;\n         break;\n\n      case KEY_CTRL('E'):\n      case '$':\n         this->scrollH = MAXIMUM(this->selectedLen - this->w, 0);\n         this->needsRedraw = true;\n         break;\n\n      default:\n         return false;\n   }\n\n   #undef PANEL_SCROLL\n\n   // ensure selection within bounds\n   if (this->selected < 0 || size == 0) {\n      this->selected = 0;\n      this->needsRedraw = true;\n   } else if (this->selected >= size) {\n      this->selected = size - 1;\n      this->needsRedraw = true;\n   }\n\n   return true;\n}\n\n\nHandlerResult Panel_selectByTyping(Panel* this, int ch) {\n   int size = Panel_size(this);\n\n   if (ch == '#')\n      return IGNORED;\n\n   if (!this->eventHandlerState)\n      this->eventHandlerState = xCalloc(100, sizeof(char));\n   char* buffer = this->eventHandlerState;\n\n   if (0 < ch && ch < 255 && isgraph((unsigned char)ch)) {\n      int len = strlen(buffer);\n      if (!len) {\n         if ('/' == ch) {\n            ch = '\\001';\n         } else if ('q' == ch) {\n            return BREAK_LOOP;\n         }\n      } else if (1 == len && '\\001' == buffer[0]) {\n         len--;\n      }\n\n      if (len < 99) {\n         buffer[len] = (char) ch;\n         buffer[len + 1] = '\\0';\n      }\n\n      for (int try = 0; try < 2; try++) {\n         len = strlen(buffer);\n         for (int i = 0; i < size; i++) {\n            const char* cur = ((ListItem*) Panel_get(this, i))->value;\n            while (*cur == ' ')\n               cur++;\n            if (strncasecmp(cur, buffer, len) == 0) {\n               Panel_setSelected(this, i);\n               return HANDLED;\n            }\n         }\n\n         // if current word did not match,\n         // retry considering the character the start of a new word.\n         buffer[0] = (char) ch;\n         buffer[1] = '\\0';\n      }\n\n      return HANDLED;\n   } else if (ch != ERR) {\n      buffer[0] = '\\0';\n   }\n\n   if (ch == 13) {\n      return BREAK_LOOP;\n   }\n\n   return IGNORED;\n}\n\nint Panel_getCh(Panel* this) {\n   if (this->cursorOn) {\n      move(this->cursorY, this->cursorX);\n      curs_set(1);\n   } else {\n      curs_set(0);\n   }\n#ifdef HAVE_SET_ESCDELAY\n   set_escdelay(25);\n#endif\n   return getch();\n}\n"
        },
        {
          "name": "Panel.h",
          "type": "blob",
          "size": 3.92578125,
          "content": "#ifndef HEADER_Panel\n#define HEADER_Panel\n/*\nhtop - Panel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <assert.h>\n#include <stdbool.h>\n\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Object.h\"\n#include \"RichString.h\"\n#include \"Vector.h\"\n\n\nstruct Panel_;\ntypedef struct Panel_ Panel;\n\ntypedef enum HandlerResult_ {\n   HANDLED     = 0x01,\n   IGNORED     = 0x02,\n   BREAK_LOOP  = 0x04,\n   REFRESH     = 0x08,\n   REDRAW      = 0x10,\n   RESCAN      = 0x20,\n   RESIZE      = 0x40,\n   SYNTH_KEY   = 0x80,\n} HandlerResult;\n\n#define EVENT_SET_SELECTED (-1)\n\n#define EVENT_HEADER_CLICK(x_) (-10000 + (x_))\n#define EVENT_IS_HEADER_CLICK(ev_) ((ev_) >= -10000 && (ev_) <= -9000)\n#define EVENT_HEADER_CLICK_GET_X(ev_) ((ev_) + 10000)\n\n#define EVENT_SCREEN_TAB_CLICK(x_) (-20000 + (x_))\n#define EVENT_IS_SCREEN_TAB_CLICK(ev_) ((ev_) >= -20000 && (ev_) < -10000)\n#define EVENT_SCREEN_TAB_GET_X(ev_) ((ev_) + 20000)\n\ntypedef HandlerResult (*Panel_EventHandler)(Panel*, int);\ntypedef void (*Panel_DrawFunctionBar)(Panel*, bool);\ntypedef void (*Panel_PrintHeader)(Panel*);\n\ntypedef struct PanelClass_ {\n   const ObjectClass super;\n   const Panel_EventHandler eventHandler;\n   const Panel_DrawFunctionBar drawFunctionBar;\n   const Panel_PrintHeader printHeader;\n} PanelClass;\n\n#define As_Panel(this_)                        ((const PanelClass*)((this_)->super.klass))\n#define Panel_eventHandlerFn(this_)            As_Panel(this_)->eventHandler\n#define Panel_eventHandler(this_, ev_)         (assert(As_Panel(this_)->eventHandler), As_Panel(this_)->eventHandler((Panel*)(this_), ev_))\n#define Panel_drawFunctionBarFn(this_)         As_Panel(this_)->drawFunctionBar\n#define Panel_drawFunctionBar(this_, hideFB_)  (assert(As_Panel(this_)->drawFunctionBar), As_Panel(this_)->drawFunctionBar((Panel*)(this_), hideFB_))\n#define Panel_printHeaderFn(this_)             As_Panel(this_)->printHeader\n#define Panel_printHeader(this_)               (assert(As_Panel(this_)->printHeader), As_Panel(this_)->printHeader((Panel*)(this_)))\n\nstruct Panel_ {\n   Object super;\n   int x, y, w, h;\n   int cursorX, cursorY;\n   Vector* items;\n   int selected;\n   int oldSelected;\n   int selectedLen;\n   void* eventHandlerState;\n   int scrollV;\n   int scrollH;\n   bool needsRedraw;\n   bool cursorOn;\n   bool wasFocus;\n   FunctionBar* currentBar;\n   FunctionBar* defaultBar;\n   RichString header;\n   ColorElements selectionColorId;\n};\n\n#define Panel_setDefaultBar(this_) do { (this_)->currentBar = (this_)->defaultBar; } while (0)\n\n#define KEY_CTRL(l) ((l)-'A'+1)\n\nextern const PanelClass Panel_class;\n\nPanel* Panel_new(int x, int y, int w, int h, const ObjectClass* type, bool owner, FunctionBar* fuBar);\n\nvoid Panel_delete(Object* cast);\n\nvoid Panel_init(Panel* this, int x, int y, int w, int h, const ObjectClass* type, bool owner, FunctionBar* fuBar);\n\nvoid Panel_done(Panel* this);\n\nvoid Panel_setCursorToSelection(Panel* this);\n\nvoid Panel_setSelectionColor(Panel* this, ColorElements colorId);\n\nvoid Panel_setHeader(Panel* this, const char* header);\n\nvoid Panel_move(Panel* this, int x, int y);\n\nvoid Panel_resize(Panel* this, int w, int h);\n\nvoid Panel_prune(Panel* this);\n\nvoid Panel_add(Panel* this, Object* o);\n\nvoid Panel_insert(Panel* this, int i, Object* o);\n\nvoid Panel_set(Panel* this, int i, Object* o);\n\nObject* Panel_get(Panel* this, int i);\n\nObject* Panel_remove(Panel* this, int i);\n\nObject* Panel_getSelected(Panel* this);\n\nvoid Panel_moveSelectedUp(Panel* this);\n\nvoid Panel_moveSelectedDown(Panel* this);\n\nint Panel_getSelectedIndex(const Panel* this);\n\nint Panel_size(const Panel* this);\n\nvoid Panel_setSelected(Panel* this, int selected);\n\nvoid Panel_draw(Panel* this, bool force_redraw, bool focus, bool highlightSelected, bool hideFunctionBar);\n\nvoid Panel_splice(Panel* this, Vector* from);\n\nbool Panel_onKey(Panel* this, int key);\n\nHandlerResult Panel_selectByTyping(Panel* this, int ch);\n\nint Panel_getCh(Panel* this);\n\n#endif\n"
        },
        {
          "name": "Process.c",
          "type": "blob",
          "size": 41.431640625,
          "content": "/*\nhtop - Process.c\n(C) 2004-2015 Hisham H. Muhammad\n(C) 2020 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Process.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sys/resource.h>\n\n#include \"CRT.h\"\n#include \"Hashtable.h\"\n#include \"Machine.h\"\n#include \"Macros.h\"\n#include \"ProcessTable.h\"\n#include \"DynamicColumn.h\"\n#include \"RichString.h\"\n#include \"Scheduling.h\"\n#include \"Settings.h\"\n#include \"Table.h\"\n#include \"XUtils.h\"\n\n#if defined(MAJOR_IN_MKDEV)\n#include <sys/mkdev.h>\n#endif\n\n\n/* Used to identify kernel threads in Comm and Exe columns */\nstatic const char* const kthreadID = \"KTHREAD\";\n\nvoid Process_fillStarttimeBuffer(Process* this) {\n   struct tm date;\n   time_t now = this->super.host->realtime.tv_sec;\n   (void) localtime_r(&this->starttime_ctime, &date);\n\n   strftime(this->starttime_show,\n            sizeof(this->starttime_show) - 1,\n            (this->starttime_ctime > now - 86400) ? \"%R \" : (this->starttime_ctime > now - 364 * 86400) ? \"%b%d \" : \" %Y \",\n            &date);\n}\n\n/*\n * TASK_COMM_LEN is defined to be 16 for /proc/[pid]/comm in man proc(5), but it is\n * not available in an userspace header - so define it.\n *\n * Note: This is taken from LINUX headers, but implicitly taken for other platforms\n * for sake of brevity.\n *\n * Note: when colorizing a basename with the comm prefix, the entire basename\n * (not just the comm prefix) is colorized for better readability, and it is\n * implicit that only up to (TASK_COMM_LEN - 1) could be comm.\n */\n#define TASK_COMM_LEN 16\n\nstatic bool findCommInCmdline(const char* comm, const char* cmdline, int cmdlineBasenameStart, int* pCommStart, int* pCommEnd) {\n   /* Try to find procComm in tokenized cmdline - this might in rare cases\n    * mis-identify a string or fail, if comm or cmdline had been unsuitably\n    * modified by the process */\n   const char* tokenBase;\n   size_t tokenLen;\n   const size_t commLen = strlen(comm);\n\n   if (cmdlineBasenameStart < 0)\n      return false;\n\n   for (const char* token = cmdline + cmdlineBasenameStart; *token;) {\n      for (tokenBase = token; *token && *token != '\\n'; ++token) {\n         if (*token == '/') {\n            tokenBase = token + 1;\n         }\n      }\n      tokenLen = token - tokenBase;\n\n      if ((tokenLen == commLen || (tokenLen > commLen && commLen == (TASK_COMM_LEN - 1))) &&\n          strncmp(tokenBase, comm, commLen) == 0) {\n         *pCommStart = tokenBase - cmdline;\n         *pCommEnd = token - cmdline;\n         return true;\n      }\n\n      if (*token) {\n         do {\n            ++token;\n         } while (*token && '\\n' == *token);\n      }\n   }\n   return false;\n}\n\nstatic int matchCmdlinePrefixWithExeSuffix(const char* cmdline, int cmdlineBaseOffset, const char* exe, int exeBaseOffset, int exeBaseLen) {\n   int matchLen; /* matching length to be returned */\n   char delim;   /* delimiter following basename */\n\n   /* cmdline prefix is an absolute path: it must match whole exe. */\n   if (cmdline[0] == '/') {\n      matchLen = exeBaseLen + exeBaseOffset;\n      if (strncmp(cmdline, exe, matchLen) == 0) {\n         delim = cmdline[matchLen];\n         if (delim == 0 || delim == '\\n' || delim == ' ') {\n            return matchLen;\n         }\n      }\n      return 0;\n   }\n\n   /* cmdline prefix is a relative path: We need to first match the basename at\n    * cmdlineBaseOffset and then reverse match the cmdline prefix with the exe\n    * suffix. But there is a catch: Some processes modify their cmdline in ways\n    * that make htop's identification of the basename in cmdline unreliable.\n    * For e.g. /usr/libexec/gdm-session-worker modifies its cmdline to\n    * \"gdm-session-worker [pam/gdm-autologin]\" and htop ends up with\n    * proccmdlineBasenameEnd at \"gdm-autologin]\". This issue could arise with\n    * chrome as well as it stores in cmdline its concatenated argument vector,\n    * without NUL delimiter between the arguments (which may contain a '/')\n    *\n    * So if needed, we adjust cmdlineBaseOffset to the previous (if any)\n    * component of the cmdline relative path, and retry the procedure. */\n   bool delimFound; /* if valid basename delimiter found */\n   do {\n      /* match basename */\n      matchLen = exeBaseLen + cmdlineBaseOffset;\n      if (cmdlineBaseOffset < exeBaseOffset &&\n          strncmp(cmdline + cmdlineBaseOffset, exe + exeBaseOffset, exeBaseLen) == 0) {\n         delim = cmdline[matchLen];\n         if (delim == 0 || delim == '\\n' || delim == ' ') {\n            int i, j;\n            /* reverse match the cmdline prefix and exe suffix */\n            for (i = cmdlineBaseOffset - 1, j = exeBaseOffset - 1;\n                 i >= 0 && j >= 0 && cmdline[i] == exe[j]; --i, --j)\n               ;\n\n            /* full match, with exe suffix being a valid relative path */\n            if (i < 0 && j >= 0 && exe[j] == '/')\n               return matchLen;\n         }\n      }\n\n      /* Try to find the previous potential cmdlineBaseOffset - it would be\n       * preceded by '/' or nothing, and delimited by ' ' or '\\n' */\n      for (delimFound = false, cmdlineBaseOffset -= 2; cmdlineBaseOffset > 0; --cmdlineBaseOffset) {\n         if (delimFound) {\n            if (cmdline[cmdlineBaseOffset - 1] == '/') {\n               break;\n            }\n         } else if (cmdline[cmdlineBaseOffset] == ' ' || cmdline[cmdlineBaseOffset] == '\\n') {\n            delimFound = true;\n         }\n      }\n   } while (delimFound);\n\n   return 0;\n}\n\n/* stpcpy, but also converts newlines to spaces */\nstatic inline char* stpcpyWithNewlineConversion(char* dstStr, const char* srcStr) {\n   for (; *srcStr; ++srcStr) {\n      *dstStr++ = (*srcStr == '\\n') ? ' ' : *srcStr;\n   }\n   *dstStr = 0;\n   return dstStr;\n}\n\n/*\n * This function makes the merged Command string. It also stores the offsets of the\n * basename, comm w.r.t the merged Command string - these offsets will be used by\n * Process_writeCommand() for coloring. The merged Command string is also\n * returned by Process_getCommand() for searching, sorting and filtering.\n */\nvoid Process_makeCommandStr(Process* this, const Settings* settings) {\n   ProcessMergedCommand* mc = &this->mergedCommand;\n\n   bool showMergedCommand = settings->showMergedCommand;\n   bool showProgramPath = settings->showProgramPath;\n   bool searchCommInCmdline = settings->findCommInCmdline;\n   bool stripExeFromCmdline = settings->stripExeFromCmdline;\n   bool showThreadNames = settings->showThreadNames;\n   bool shadowDistPathPrefix = settings->shadowDistPathPrefix;\n\n   uint64_t settingsStamp = settings->lastUpdate;\n\n   /* Nothing to do to (Re)Generate the Command string, if the process is:\n    * - a kernel thread, or\n    * - a zombie from before being under htop's watch, or\n    * - a user thread and showThreadNames is not set */\n   if (Process_isKernelThread(this))\n      return;\n   if (this->state == ZOMBIE && !this->mergedCommand.str)\n      return;\n\n   /* this->mergedCommand.str needs updating only if its state or contents changed.\n    * Its content is based on the fields cmdline, comm, and exe. */\n   if (mc->lastUpdate >= settingsStamp)\n      return;\n\n   mc->lastUpdate = settingsStamp;\n\n   /* The field separator \"â\" has been chosen such that it will not match any\n    * valid string used for searching or filtering */\n   const char* SEPARATOR = CRT_treeStr[TREE_STR_VERT];\n   const int SEPARATOR_LEN = strlen(SEPARATOR);\n\n   /* Accommodate the column text, two field separators and terminating NUL */\n   size_t maxLen = 2 * SEPARATOR_LEN + 1;\n   maxLen += this->cmdline ? strlen(this->cmdline) : strlen(\"(zombie)\");\n   maxLen += this->procComm ? strlen(this->procComm) : 0;\n   maxLen += this->procExe ? strlen(this->procExe) : 0;\n\n   free(mc->str);\n   mc->str = xCalloc(1, maxLen);\n\n   /* Reset all locations that need extra handling when actually displaying */\n   mc->highlightCount = 0;\n   memset(mc->highlights, 0, sizeof(mc->highlights));\n\n   size_t mbMismatch = 0;\n   #define WRITE_HIGHLIGHT(_offset, _length, _attr, _flags)                                   \\\n      do {                                                                                    \\\n         /* Check if we still have capacity */                                                \\\n         assert(mc->highlightCount < ARRAYSIZE(mc->highlights));                              \\\n         if (mc->highlightCount >= ARRAYSIZE(mc->highlights))                                 \\\n            break;                                                                            \\\n                                                                                              \\\n         mc->highlights[mc->highlightCount].offset = str - strStart + (_offset) - mbMismatch; \\\n         mc->highlights[mc->highlightCount].length = _length;                                 \\\n         mc->highlights[mc->highlightCount].attr = _attr;                                     \\\n         mc->highlights[mc->highlightCount].flags = _flags;                                   \\\n         mc->highlightCount++;                                                                \\\n      } while (0)\n\n   #define WRITE_SEPARATOR                                                                    \\\n      do {                                                                                    \\\n         WRITE_HIGHLIGHT(0, 1, CRT_colors[FAILED_READ], CMDLINE_HIGHLIGHT_FLAG_SEPARATOR);    \\\n         mbMismatch += SEPARATOR_LEN - 1;                                                     \\\n         str = stpcpy(str, SEPARATOR);                                                        \\\n      } while (0)\n\n   #define CHECK_AND_MARK(str_, prefix_)                                                      \\\n      if (String_startsWith(str_, prefix_)) {                                                 \\\n         WRITE_HIGHLIGHT(0, strlen(prefix_), CRT_colors[PROCESS_SHADOW], CMDLINE_HIGHLIGHT_FLAG_PREFIXDIR); \\\n         break;                                                                               \\\n      } else (void)0\n\n   #define CHECK_AND_MARK_DIST_PATH_PREFIXES(str_)                                            \\\n      do {                                                                                    \\\n         if ((str_)[0] != '/') {                                                              \\\n            break;                                                                            \\\n         }                                                                                    \\\n         switch ((str_)[1]) {                                                                 \\\n            case 'b':                                                                         \\\n               CHECK_AND_MARK(str_, \"/bin/\");                                                 \\\n               break;                                                                         \\\n            case 'l':                                                                         \\\n               CHECK_AND_MARK(str_, \"/lib/\");                                                 \\\n               CHECK_AND_MARK(str_, \"/lib32/\");                                               \\\n               CHECK_AND_MARK(str_, \"/lib64/\");                                               \\\n               CHECK_AND_MARK(str_, \"/libx32/\");                                              \\\n               break;                                                                         \\\n            case 's':                                                                         \\\n               CHECK_AND_MARK(str_, \"/sbin/\");                                                \\\n               break;                                                                         \\\n            case 'u':                                                                         \\\n               if (String_startsWith(str_, \"/usr/\")) {                                        \\\n                  switch ((str_)[5]) {                                                        \\\n                     case 'b':                                                                \\\n                        CHECK_AND_MARK(str_, \"/usr/bin/\");                                    \\\n                        break;                                                                \\\n                     case 'l':                                                                \\\n                        CHECK_AND_MARK(str_, \"/usr/libexec/\");                                \\\n                        CHECK_AND_MARK(str_, \"/usr/lib/\");                                    \\\n                        CHECK_AND_MARK(str_, \"/usr/lib32/\");                                  \\\n                        CHECK_AND_MARK(str_, \"/usr/lib64/\");                                  \\\n                        CHECK_AND_MARK(str_, \"/usr/libx32/\");                                 \\\n                                                                                              \\\n                        CHECK_AND_MARK(str_, \"/usr/local/bin/\");                              \\\n                        CHECK_AND_MARK(str_, \"/usr/local/lib/\");                              \\\n                        CHECK_AND_MARK(str_, \"/usr/local/sbin/\");                             \\\n                        break;                                                                \\\n                     case 's':                                                                \\\n                        CHECK_AND_MARK(str_, \"/usr/sbin/\");                                   \\\n                        break;                                                                \\\n                  }                                                                           \\\n               }                                                                              \\\n               break;                                                                         \\\n         }                                                                                    \\\n      } while (0)\n\n   const int baseAttr = Process_isThread(this) ? CRT_colors[PROCESS_THREAD_BASENAME] : CRT_colors[PROCESS_BASENAME];\n   const int commAttr = Process_isThread(this) ? CRT_colors[PROCESS_THREAD_COMM] : CRT_colors[PROCESS_COMM];\n   const int delExeAttr = CRT_colors[FAILED_READ];\n   const int delLibAttr = CRT_colors[PROCESS_TAG];\n\n   /* Establish some shortcuts to data we need */\n   const char* cmdline = this->cmdline;\n   const char* procComm = this->procComm;\n   const char* procExe = this->procExe;\n\n   char* strStart = mc->str;\n   char* str = strStart;\n\n   int cmdlineBasenameStart = this->cmdlineBasenameStart;\n   int cmdlineBasenameEnd = this->cmdlineBasenameEnd;\n\n   if (!cmdline) {\n      cmdlineBasenameStart = 0;\n      cmdlineBasenameEnd = 0;\n      cmdline = \"(zombie)\";\n   }\n\n   assert(cmdlineBasenameStart >= 0);\n   assert(cmdlineBasenameStart <= (int)strlen(cmdline));\n\n   if (!showMergedCommand || !procExe || !procComm) { /* fall back to cmdline */\n      if ((showMergedCommand || (Process_isUserlandThread(this) && showThreadNames)) && procComm && strlen(procComm)) { /* set column to or prefix it with comm */\n         if (strncmp(cmdline + cmdlineBasenameStart, procComm, MINIMUM(TASK_COMM_LEN - 1, strlen(procComm))) != 0) {\n            WRITE_HIGHLIGHT(0, strlen(procComm), commAttr, CMDLINE_HIGHLIGHT_FLAG_COMM);\n            str = stpcpy(str, procComm);\n\n            if (!showMergedCommand)\n               return;\n\n            WRITE_SEPARATOR;\n         }\n      }\n\n      if (shadowDistPathPrefix && showProgramPath)\n         CHECK_AND_MARK_DIST_PATH_PREFIXES(cmdline);\n\n      if (cmdlineBasenameEnd > cmdlineBasenameStart)\n         WRITE_HIGHLIGHT(showProgramPath ? cmdlineBasenameStart : 0, cmdlineBasenameEnd - cmdlineBasenameStart, baseAttr, CMDLINE_HIGHLIGHT_FLAG_BASENAME);\n\n      if (this->procExeDeleted)\n         WRITE_HIGHLIGHT(showProgramPath ? cmdlineBasenameStart : 0, cmdlineBasenameEnd - cmdlineBasenameStart, delExeAttr, CMDLINE_HIGHLIGHT_FLAG_DELETED);\n      else if (this->usesDeletedLib)\n         WRITE_HIGHLIGHT(showProgramPath ? cmdlineBasenameStart : 0, cmdlineBasenameEnd - cmdlineBasenameStart, delLibAttr, CMDLINE_HIGHLIGHT_FLAG_DELETED);\n\n      (void)stpcpyWithNewlineConversion(str, cmdline + (showProgramPath ? 0 : cmdlineBasenameStart));\n\n      return;\n   }\n\n   int exeLen = strlen(this->procExe);\n   int exeBasenameOffset = this->procExeBasenameOffset;\n   int exeBasenameLen = exeLen - exeBasenameOffset;\n\n   assert(exeBasenameOffset >= 0);\n   assert(exeBasenameOffset <= (int)strlen(procExe));\n\n   bool haveCommInExe = false;\n   if (procExe && procComm && (!Process_isUserlandThread(this) || showThreadNames)) {\n      haveCommInExe = strncmp(procExe + exeBasenameOffset, procComm, TASK_COMM_LEN - 1) == 0;\n   }\n\n   /* Start with copying exe */\n   if (showProgramPath) {\n      if (shadowDistPathPrefix)\n         CHECK_AND_MARK_DIST_PATH_PREFIXES(procExe);\n      if (haveCommInExe)\n         WRITE_HIGHLIGHT(exeBasenameOffset, exeBasenameLen, commAttr, CMDLINE_HIGHLIGHT_FLAG_COMM);\n      WRITE_HIGHLIGHT(exeBasenameOffset, exeBasenameLen, baseAttr, CMDLINE_HIGHLIGHT_FLAG_BASENAME);\n      if (this->procExeDeleted)\n         WRITE_HIGHLIGHT(exeBasenameOffset, exeBasenameLen, delExeAttr, CMDLINE_HIGHLIGHT_FLAG_DELETED);\n      else if (this->usesDeletedLib)\n         WRITE_HIGHLIGHT(exeBasenameOffset, exeBasenameLen, delLibAttr, CMDLINE_HIGHLIGHT_FLAG_DELETED);\n      str = stpcpy(str, procExe);\n   } else {\n      if (haveCommInExe)\n         WRITE_HIGHLIGHT(0, exeBasenameLen, commAttr, CMDLINE_HIGHLIGHT_FLAG_COMM);\n      WRITE_HIGHLIGHT(0, exeBasenameLen, baseAttr, CMDLINE_HIGHLIGHT_FLAG_BASENAME);\n      if (this->procExeDeleted)\n         WRITE_HIGHLIGHT(0, exeBasenameLen, delExeAttr, CMDLINE_HIGHLIGHT_FLAG_DELETED);\n      else if (this->usesDeletedLib)\n         WRITE_HIGHLIGHT(0, exeBasenameLen, delLibAttr, CMDLINE_HIGHLIGHT_FLAG_DELETED);\n      str = stpcpy(str, procExe + exeBasenameOffset);\n   }\n\n   bool haveCommInCmdline = false;\n   int commStart = 0;\n   int commEnd = 0;\n\n   /* Try to match procComm with procExe's basename: This is reliable (predictable) */\n   if (searchCommInCmdline) {\n      /* commStart/commEnd will be adjusted later along with cmdline */\n      haveCommInCmdline = (!Process_isUserlandThread(this) || showThreadNames) && findCommInCmdline(procComm, cmdline, cmdlineBasenameStart, &commStart, &commEnd);\n   }\n\n   int matchLen = matchCmdlinePrefixWithExeSuffix(cmdline, cmdlineBasenameStart, procExe, exeBasenameOffset, exeBasenameLen);\n\n   bool haveCommField = false;\n\n   if (!haveCommInExe && !haveCommInCmdline && procComm && (!Process_isUserlandThread(this) || showThreadNames)) {\n      WRITE_SEPARATOR;\n      WRITE_HIGHLIGHT(0, strlen(procComm), commAttr, CMDLINE_HIGHLIGHT_FLAG_COMM);\n      str = stpcpy(str, procComm);\n      haveCommField = true;\n   }\n\n   if (matchLen) {\n      if (stripExeFromCmdline) {\n         /* strip the matched exe prefix */\n         cmdline += matchLen;\n\n         commStart -= matchLen;\n         commEnd -= matchLen;\n      } else {\n         matchLen = 0;\n      }\n   }\n\n   if (!matchLen || (haveCommField && *cmdline)) {\n      /* cmdline will be a separate field */\n      WRITE_SEPARATOR;\n   }\n\n   if (shadowDistPathPrefix)\n      CHECK_AND_MARK_DIST_PATH_PREFIXES(cmdline);\n\n   if (!haveCommInExe && haveCommInCmdline && !haveCommField && (!Process_isUserlandThread(this) || showThreadNames))\n      WRITE_HIGHLIGHT(commStart, commEnd - commStart, commAttr, CMDLINE_HIGHLIGHT_FLAG_COMM);\n\n   /* Display cmdline if it hasn't been consumed by procExe */\n   if (*cmdline)\n      (void)stpcpyWithNewlineConversion(str, cmdline);\n\n   #undef CHECK_AND_MARK_DIST_PATH_PREFIXES\n   #undef CHECK_AND_MARK\n   #undef WRITE_SEPARATOR\n   #undef WRITE_HIGHLIGHT\n}\n\nvoid Process_writeCommand(const Process* this, int attr, int baseAttr, RichString* str) {\n   (void)baseAttr;\n\n   const ProcessMergedCommand* mc = &this->mergedCommand;\n   const char* mergedCommand = mc->str;\n\n   int strStart = RichString_size(str);\n\n   const Settings* settings = this->super.host->settings;\n   const bool highlightBaseName = settings->highlightBaseName;\n   const bool highlightSeparator = true;\n   const bool highlightDeleted = settings->highlightDeletedExe;\n\n   if (!mergedCommand) {\n      int len = 0;\n      const char* cmdline = this->cmdline;\n\n      if (highlightBaseName || !settings->showProgramPath) {\n         int basename = 0;\n         for (int i = 0; i < this->cmdlineBasenameEnd; i++) {\n            if (cmdline[i] == '/') {\n               basename = i + 1;\n            } else if (cmdline[i] == ':') {\n               len = i + 1;\n               break;\n            }\n         }\n         if (len == 0) {\n            if (settings->showProgramPath) {\n               strStart += basename;\n            } else {\n               cmdline += basename;\n            }\n            len = this->cmdlineBasenameEnd - basename;\n         }\n      }\n\n      RichString_appendWide(str, attr, cmdline);\n\n      if (settings->highlightBaseName) {\n         RichString_setAttrn(str, baseAttr, strStart, len);\n      }\n\n      return;\n   }\n\n   RichString_appendWide(str, attr, mergedCommand);\n\n   for (size_t i = 0, hlCount = CLAMP(mc->highlightCount, 0, ARRAYSIZE(mc->highlights)); i < hlCount; i++) {\n      const ProcessCmdlineHighlight* hl = &mc->highlights[i];\n\n      if (!hl->length)\n         continue;\n\n      if (hl->flags & CMDLINE_HIGHLIGHT_FLAG_SEPARATOR)\n         if (!highlightSeparator)\n            continue;\n\n      if (hl->flags & CMDLINE_HIGHLIGHT_FLAG_BASENAME)\n         if (!highlightBaseName)\n            continue;\n\n      if (hl->flags & CMDLINE_HIGHLIGHT_FLAG_DELETED)\n         if (!highlightDeleted)\n            continue;\n\n      if (hl->flags & CMDLINE_HIGHLIGHT_FLAG_PREFIXDIR)\n         if (!highlightDeleted)\n            continue;\n\n      RichString_setAttrn(str, hl->attr, strStart + hl->offset, hl->length);\n   }\n}\n\nstatic inline char processStateChar(ProcessState state) {\n   switch (state) {\n      case UNKNOWN: return '?';\n      case RUNNABLE: return 'U';\n      case RUNNING: return 'R';\n      case QUEUED: return 'Q';\n      case WAITING: return 'W';\n      case UNINTERRUPTIBLE_WAIT: return 'D';\n      case BLOCKED: return 'B';\n      case PAGING: return 'P';\n      case STOPPED: return 'T';\n      case TRACED: return 't';\n      case ZOMBIE: return 'Z';\n      case DEFUNCT: return 'X';\n      case IDLE: return 'I';\n      case SLEEPING: return 'S';\n      default:\n         assert(0);\n         return '!';\n   }\n}\n\nstatic void Process_rowWriteField(const Row* super, RichString* str, RowField field) {\n   const Process* this = (const Process*) super;\n   assert(Object_isA((const Object*) this, (const ObjectClass*) &Process_class));\n   Process_writeField(this, str, field);\n}\n\nvoid Process_writeField(const Process* this, RichString* str, RowField field) {\n   const Row* super = (const Row*) &this->super;\n   const Machine* host = super->host;\n   const Settings* settings = host->settings;\n\n   bool coloring = settings->highlightMegabytes;\n   char buffer[256]; buffer[255] = '\\0';\n   int attr = CRT_colors[DEFAULT_COLOR];\n   size_t n = sizeof(buffer) - 1;\n\n   switch (field) {\n   case COMM: {\n      int baseattr = CRT_colors[PROCESS_BASENAME];\n      if (settings->highlightThreads && Process_isThread(this)) {\n         attr = CRT_colors[PROCESS_THREAD];\n         baseattr = CRT_colors[PROCESS_THREAD_BASENAME];\n      }\n      const ScreenSettings* ss = settings->ss;\n      if (!ss->treeView || super->indent == 0) {\n         Process_writeCommand(this, attr, baseattr, str);\n         return;\n      }\n\n      char* buf = buffer;\n      const bool lastItem = (super->indent < 0);\n\n      for (uint32_t indent = (super->indent < 0 ? -super->indent : super->indent); indent > 1; indent >>= 1) {\n         int written, ret;\n         if (indent & 1U) {\n            ret = xSnprintf(buf, n, \"%s  \", CRT_treeStr[TREE_STR_VERT]);\n         } else {\n            ret = xSnprintf(buf, n, \"   \");\n         }\n         if (ret < 0 || (size_t)ret >= n) {\n            written = n;\n         } else {\n            written = ret;\n         }\n         buf += written;\n         n -= written;\n      }\n\n      const char* draw = CRT_treeStr[lastItem ? TREE_STR_BEND : TREE_STR_RTEE];\n      xSnprintf(buf, n, \"%s%s \", draw, super->showChildren ? CRT_treeStr[TREE_STR_SHUT] : CRT_treeStr[TREE_STR_OPEN] );\n      RichString_appendWide(str, CRT_colors[PROCESS_TREE], buffer);\n      Process_writeCommand(this, attr, baseattr, str);\n      return;\n   }\n   case PROC_COMM: {\n      const char* procComm;\n      if (this->procComm) {\n         attr = CRT_colors[Process_isUserlandThread(this) ? PROCESS_THREAD_COMM : PROCESS_COMM];\n         procComm = this->procComm;\n      } else {\n         attr = CRT_colors[PROCESS_SHADOW];\n         procComm = Process_isKernelThread(this) ? kthreadID : \"N/A\";\n      }\n\n      Row_printLeftAlignedField(str, attr, procComm, TASK_COMM_LEN - 1);\n      return;\n   }\n   case PROC_EXE: {\n      const char* procExe;\n      if (this->procExe) {\n         attr = CRT_colors[Process_isUserlandThread(this) ? PROCESS_THREAD_BASENAME : PROCESS_BASENAME];\n         if (settings->highlightDeletedExe) {\n            if (this->procExeDeleted)\n               attr = CRT_colors[FAILED_READ];\n            else if (this->usesDeletedLib)\n               attr = CRT_colors[PROCESS_TAG];\n         }\n         procExe = this->procExe + this->procExeBasenameOffset;\n      } else {\n         attr = CRT_colors[PROCESS_SHADOW];\n         procExe = Process_isKernelThread(this) ? kthreadID : \"N/A\";\n      }\n\n      Row_printLeftAlignedField(str, attr, procExe, TASK_COMM_LEN - 1);\n      return;\n   }\n   case CWD: {\n      const char* cwd;\n      if (!this->procCwd) {\n         attr = CRT_colors[PROCESS_SHADOW];\n         cwd = \"N/A\";\n      } else if (String_startsWith(this->procCwd, \"/proc/\") && strstr(this->procCwd, \" (deleted)\") != NULL) {\n         attr = CRT_colors[PROCESS_SHADOW];\n         cwd = \"main thread terminated\";\n      } else {\n         cwd = this->procCwd;\n      }\n      Row_printLeftAlignedField(str, attr, cwd, 25);\n      return;\n   }\n   case ELAPSED: {\n      const uint64_t rt = host->realtimeMs;\n      const uint64_t st = this->starttime_ctime * 1000;\n      const uint64_t dt =\n         rt < st ? 0 :\n         rt - st;\n      Row_printTime(str, /* convert to hundreds of a second */ dt / 10, coloring);\n      return;\n   }\n   case MAJFLT: Row_printCount(str, this->majflt, coloring); return;\n   case MINFLT: Row_printCount(str, this->minflt, coloring); return;\n   case M_RESIDENT: Row_printKBytes(str, this->m_resident, coloring); return;\n   case M_VIRT: Row_printKBytes(str, this->m_virt, coloring); return;\n   case NICE:\n      if (this->nice == PROCESS_NICE_UNKNOWN) {\n         xSnprintf(buffer, n, \"N/A \");\n         attr = CRT_colors[PROCESS_SHADOW];\n      } else {\n         xSnprintf(buffer, n, \"%3ld \", this->nice);\n         attr = this->nice < 0 ? CRT_colors[PROCESS_HIGH_PRIORITY]\n            : this->nice > 0 ? CRT_colors[PROCESS_LOW_PRIORITY]\n            : CRT_colors[PROCESS_SHADOW];\n      }\n      break;\n   case NLWP:\n      if (this->nlwp == 1)\n         attr = CRT_colors[PROCESS_SHADOW];\n\n      xSnprintf(buffer, n, \"%4ld \", this->nlwp);\n      break;\n   case PERCENT_CPU: Row_printPercentage(this->percent_cpu, buffer, n, Row_fieldWidths[PERCENT_CPU], &attr); break;\n   case PERCENT_NORM_CPU: {\n      float cpuPercentage = this->percent_cpu / host->activeCPUs;\n      Row_printPercentage(cpuPercentage, buffer, n, Row_fieldWidths[PERCENT_CPU], &attr);\n      break;\n   }\n   case PERCENT_MEM: Row_printPercentage(this->percent_mem, buffer, n, 4, &attr); break;\n   case PGRP: xSnprintf(buffer, n, \"%*d \", Process_pidDigits, this->pgrp); break;\n   case PID: xSnprintf(buffer, n, \"%*d \", Process_pidDigits, Process_getPid(this)); break;\n   case PPID: xSnprintf(buffer, n, \"%*d \", Process_pidDigits, Process_getParent(this)); break;\n   case PRIORITY:\n      if (this->priority <= -100)\n         xSnprintf(buffer, n, \" RT \");\n      else\n         xSnprintf(buffer, n, \"%3ld \", this->priority);\n      break;\n   case PROCESSOR: xSnprintf(buffer, n, \"%3d \", Settings_cpuId(settings, this->processor)); break;\n   case SCHEDULERPOLICY: {\n      const char* schedPolStr = \"N/A\";\n#ifdef SCHEDULER_SUPPORT\n      if (this->scheduling_policy >= 0)\n         schedPolStr = Scheduling_formatPolicy(this->scheduling_policy);\n#endif\n      xSnprintf(buffer, n, \"%-5s \", schedPolStr);\n      break;\n   }\n   case SESSION: xSnprintf(buffer, n, \"%*d \", Process_pidDigits, this->session); break;\n   case STARTTIME: xSnprintf(buffer, n, \"%s\", this->starttime_show); break;\n   case STATE:\n      xSnprintf(buffer, n, \"%c \", processStateChar(this->state));\n      switch (this->state) {\n      case RUNNABLE:\n      case RUNNING:\n      case TRACED:\n         attr = CRT_colors[PROCESS_RUN_STATE];\n         break;\n\n      case BLOCKED:\n      case DEFUNCT:\n      case STOPPED:\n      case UNINTERRUPTIBLE_WAIT:\n      case ZOMBIE:\n         attr = CRT_colors[PROCESS_D_STATE];\n         break;\n\n      case QUEUED:\n      case WAITING:\n      case IDLE:\n      case SLEEPING:\n         attr = CRT_colors[PROCESS_SHADOW];\n         break;\n\n      case UNKNOWN:\n      case PAGING:\n         break;\n      }\n      break;\n   case ST_UID: xSnprintf(buffer, n, \"%*d \", Process_uidDigits, this->st_uid); break;\n   case TIME: Row_printTime(str, this->time, coloring); return;\n   case TGID:\n      if (Process_getThreadGroup(this) == Process_getPid(this))\n         attr = CRT_colors[PROCESS_SHADOW];\n\n      xSnprintf(buffer, n, \"%*d \", Process_pidDigits, Process_getThreadGroup(this));\n      break;\n   case TPGID: xSnprintf(buffer, n, \"%*d \", Process_pidDigits, this->tpgid); break;\n   case TTY:\n      if (!this->tty_name) {\n         attr = CRT_colors[PROCESS_SHADOW];\n         xSnprintf(buffer, n, \"(no tty) \");\n      } else {\n         const char* name = String_startsWith(this->tty_name, \"/dev/\") ? (this->tty_name + strlen(\"/dev/\")) : this->tty_name;\n         xSnprintf(buffer, n, \"%-8s \", name);\n      }\n      break;\n   case USER:\n      if (this->elevated_priv == TRI_ON)\n         attr = CRT_colors[PROCESS_PRIV];\n      else if (host->htopUserId != this->st_uid)\n         attr = CRT_colors[PROCESS_SHADOW];\n\n      if (this->user) {\n         Row_printLeftAlignedField(str, attr, this->user, 10);\n         return;\n      }\n\n      xSnprintf(buffer, n, \"%-10d \", this->st_uid);\n      break;\n   default:\n      if (DynamicColumn_writeField(this, str, field))\n         return;\n      assert(0 && \"Process_writeField: default key reached\"); /* should never be reached */\n      xSnprintf(buffer, n, \"- \");\n      break;\n   }\n\n   RichString_appendAscii(str, attr, buffer);\n}\n\nvoid Process_done(Process* this) {\n   assert(this != NULL);\n   free(this->cmdline);\n   free(this->procComm);\n   free(this->procExe);\n   free(this->procCwd);\n   free(this->mergedCommand.str);\n   free(this->tty_name);\n}\n\n/* This function returns the string displayed in Command column, so that sorting\n * happens on what is displayed - whether comm, full path, basename, etc.. So\n * this follows Process_writeField(COMM) and Process_writeCommand */\nconst char* Process_getCommand(const Process* this) {\n   const Settings* settings = this->super.host->settings;\n\n   if ((Process_isUserlandThread(this) && settings->showThreadNames) || !this->mergedCommand.str) {\n      return this->cmdline;\n   }\n\n   return this->mergedCommand.str;\n}\n\nstatic const char* Process_getSortKey(const Process* this) {\n   return Process_getCommand(this);\n}\n\nconst char* Process_rowGetSortKey(Row* super) {\n   const Process* this = (const Process*) super;\n   assert(Object_isA((const Object*) this, (const ObjectClass*) &Process_class));\n   return Process_getSortKey(this);\n}\n\n/* Test whether display must highlight this row (if the htop UID matches) */\nstatic bool Process_isHighlighted(const Process* this) {\n   const Machine* host = this->super.host;\n   const Settings* settings = host->settings;\n   return settings->shadowOtherUsers && this->st_uid != host->htopUserId;\n}\n\nbool Process_rowIsHighlighted(const Row* super) {\n   const Process* this = (const Process*) super;\n   assert(Object_isA((const Object*) this, (const ObjectClass*) &Process_class));\n   return Process_isHighlighted(this);\n}\n\n/* Test whether display must follow parent process (if this thread is hidden) */\nstatic bool Process_isVisible(const Process* p, const Settings* settings) {\n   if (settings->hideUserlandThreads)\n      return !Process_isThread(p);\n   return true;\n}\n\nbool Process_rowIsVisible(const Row* super, const Table* table) {\n   const Process* this = (const Process*) super;\n   assert(Object_isA((const Object*) this, (const ObjectClass*) &Process_class));\n   return Process_isVisible(this, table->host->settings);\n}\n\n/* Test whether display must filter out this process (various mechanisms) */\nstatic bool Process_matchesFilter(const Process* this, const Table* table) {\n   const Machine* host = table->host;\n   if (host->userId != (uid_t) -1 && this->st_uid != host->userId)\n      return true;\n\n   const char* incFilter = table->incFilter;\n   if (incFilter && !String_contains_i(Process_getCommand(this), incFilter, true))\n      return true;\n\n   const ProcessTable* pt = (const ProcessTable*) host->activeTable;\n   assert(Object_isA((const Object*) pt, (const ObjectClass*) &ProcessTable_class));\n   if (pt->pidMatchList && !Hashtable_get(pt->pidMatchList, Process_getThreadGroup(this)))\n      return true;\n\n   return false;\n}\n\nbool Process_rowMatchesFilter(const Row* super, const Table* table) {\n   const Process* this = (const Process*) super;\n   assert(Object_isA((const Object*) this, (const ObjectClass*) &Process_class));\n   return Process_matchesFilter(this, table);\n}\n\nvoid Process_init(Process* this, const Machine* host) {\n   Row_init(&this->super, host);\n\n   this->cmdlineBasenameEnd = -1;\n   this->st_uid = (uid_t)-1;\n}\n\nstatic bool Process_setPriority(Process* this, int priority) {\n   if (Settings_isReadonly())\n      return false;\n\n   int old_prio = getpriority(PRIO_PROCESS, Process_getPid(this));\n   int err = setpriority(PRIO_PROCESS, Process_getPid(this), priority);\n\n   if (err == 0 && old_prio != getpriority(PRIO_PROCESS, Process_getPid(this))) {\n      this->nice = priority;\n   }\n   return (err == 0);\n}\n\nbool Process_rowChangePriorityBy(Row* super, Arg delta) {\n   Process* this = (Process*) super;\n   assert(Object_isA((const Object*) this, (const ObjectClass*) &Process_class));\n   return Process_setPriority(this, this->nice + delta.i);\n}\n\nstatic bool Process_sendSignal(Process* this, Arg sgn) {\n   return kill(Process_getPid(this), sgn.i) == 0;\n}\n\nbool Process_rowSendSignal(Row* super, Arg sgn) {\n   Process* this = (Process*) super;\n   assert(Object_isA((const Object*) this, (const ObjectClass*) &Process_class));\n   return Process_sendSignal(this, sgn);\n}\n\nint Process_compare(const void* v1, const void* v2) {\n   const Process* p1 = (const Process*)v1;\n   const Process* p2 = (const Process*)v2;\n\n   const ScreenSettings* ss = p1->super.host->settings->ss;\n\n   ProcessField key = ScreenSettings_getActiveSortKey(ss);\n\n   int result = Process_compareByKey(p1, p2, key);\n\n   // Implement tie-breaker (needed to make tree mode more stable)\n   if (!result)\n      return SPACESHIP_NUMBER(Process_getPid(p1), Process_getPid(p2));\n\n   return (ScreenSettings_getActiveDirection(ss) == 1) ? result : -result;\n}\n\nint Process_compareByParent(const Row* r1, const Row* r2) {\n   int result = SPACESHIP_NUMBER(\n      r1->isRoot ? 0 : Row_getGroupOrParent(r1),\n      r2->isRoot ? 0 : Row_getGroupOrParent(r2)\n   );\n\n   if (result != 0)\n      return result;\n\n   return Process_compare(r1, r2);\n}\n\nint Process_compareByKey_Base(const Process* p1, const Process* p2, ProcessField key) {\n   int r;\n\n   switch (key) {\n   case PERCENT_CPU:\n   case PERCENT_NORM_CPU:\n      return compareRealNumbers(p1->percent_cpu, p2->percent_cpu);\n   case PERCENT_MEM:\n      return SPACESHIP_NUMBER(p1->m_resident, p2->m_resident);\n   case COMM:\n      return SPACESHIP_NULLSTR(Process_getCommand(p1), Process_getCommand(p2));\n   case PROC_COMM: {\n      const char* comm1 = p1->procComm ? p1->procComm : (Process_isKernelThread(p1) ? kthreadID : \"\");\n      const char* comm2 = p2->procComm ? p2->procComm : (Process_isKernelThread(p2) ? kthreadID : \"\");\n      return SPACESHIP_NULLSTR(comm1, comm2);\n   }\n   case PROC_EXE: {\n      const char* exe1 = p1->procExe ? (p1->procExe + p1->procExeBasenameOffset) : (Process_isKernelThread(p1) ? kthreadID : \"\");\n      const char* exe2 = p2->procExe ? (p2->procExe + p2->procExeBasenameOffset) : (Process_isKernelThread(p2) ? kthreadID : \"\");\n      return SPACESHIP_NULLSTR(exe1, exe2);\n   }\n   case CWD:\n      return SPACESHIP_NULLSTR(p1->procCwd, p2->procCwd);\n   case ELAPSED:\n      r = -SPACESHIP_NUMBER(p1->starttime_ctime, p2->starttime_ctime);\n      return r != 0 ? r : SPACESHIP_NUMBER(Process_getPid(p1), Process_getPid(p2));\n   case MAJFLT:\n      return SPACESHIP_NUMBER(p1->majflt, p2->majflt);\n   case MINFLT:\n      return SPACESHIP_NUMBER(p1->minflt, p2->minflt);\n   case M_RESIDENT:\n      return SPACESHIP_NUMBER(p1->m_resident, p2->m_resident);\n   case M_VIRT:\n      return SPACESHIP_NUMBER(p1->m_virt, p2->m_virt);\n   case NICE:\n      return SPACESHIP_NUMBER(p1->nice, p2->nice);\n   case NLWP:\n      return SPACESHIP_NUMBER(p1->nlwp, p2->nlwp);\n   case PGRP:\n      return SPACESHIP_NUMBER(p1->pgrp, p2->pgrp);\n   case PID:\n      return SPACESHIP_NUMBER(Process_getPid(p1), Process_getPid(p2));\n   case PPID:\n      return SPACESHIP_NUMBER(Process_getParent(p1), Process_getParent(p2));\n   case PRIORITY:\n      return SPACESHIP_NUMBER(p1->priority, p2->priority);\n   case PROCESSOR:\n      return SPACESHIP_NUMBER(p1->processor, p2->processor);\n   case SCHEDULERPOLICY:\n      return SPACESHIP_NUMBER(p1->scheduling_policy, p2->scheduling_policy);\n   case SESSION:\n      return SPACESHIP_NUMBER(p1->session, p2->session);\n   case STARTTIME:\n      r = SPACESHIP_NUMBER(p1->starttime_ctime, p2->starttime_ctime);\n      return r != 0 ? r : SPACESHIP_NUMBER(Process_getPid(p1), Process_getPid(p2));\n   case STATE:\n      return SPACESHIP_NUMBER(p1->state, p2->state);\n   case ST_UID:\n      return SPACESHIP_NUMBER(p1->st_uid, p2->st_uid);\n   case TIME:\n      return SPACESHIP_NUMBER(p1->time, p2->time);\n   case TGID:\n      return SPACESHIP_NUMBER(Process_getThreadGroup(p1), Process_getThreadGroup(p2));\n   case TPGID:\n      return SPACESHIP_NUMBER(p1->tpgid, p2->tpgid);\n   case TTY:\n      /* Order no tty last */\n      return SPACESHIP_DEFAULTSTR(p1->tty_name, p2->tty_name, \"\\x7F\");\n   case USER:\n      return SPACESHIP_NULLSTR(p1->user, p2->user);\n   default:\n      CRT_debug(\"Process_compareByKey_Base() called with key %d\", key);\n      assert(0 && \"Process_compareByKey_Base: default key reached\"); /* should never be reached */\n      return SPACESHIP_NUMBER(Process_getPid(p1), Process_getPid(p2));\n   }\n}\n\nvoid Process_updateComm(Process* this, const char* comm) {\n   if (!this->procComm && !comm)\n      return;\n\n   if (this->procComm && comm && String_eq(this->procComm, comm))\n      return;\n\n   free(this->procComm);\n   this->procComm = comm ? xStrdup(comm) : NULL;\n\n   this->mergedCommand.lastUpdate = 0;\n}\n\nstatic int skipPotentialPath(const char* cmdline, int end) {\n   if (cmdline[0] != '/')\n      return 0;\n\n   int slash = 0;\n   for (int i = 1; i < end; i++) {\n      if (cmdline[i] == '/' && cmdline[i + 1] != '\\0') {\n         slash = i + 1;\n         continue;\n      }\n\n      if (cmdline[i] == ' ' && cmdline[i - 1] != '\\\\')\n         return slash;\n\n      if (cmdline[i] == ':' && cmdline[i + 1] == ' ')\n         return slash;\n   }\n\n   return slash;\n}\n\nvoid Process_updateCmdline(Process* this, const char* cmdline, int basenameStart, int basenameEnd) {\n   assert(basenameStart >= 0);\n   assert((cmdline && basenameStart < (int)strlen(cmdline)) || (!cmdline && basenameStart == 0));\n   assert((basenameEnd > basenameStart) || (basenameEnd == 0 && basenameStart == 0));\n   assert((cmdline && basenameEnd <= (int)strlen(cmdline)) || (!cmdline && basenameEnd == 0));\n\n   if (!this->cmdline && !cmdline)\n      return;\n\n   if (this->cmdline && cmdline && String_eq(this->cmdline, cmdline))\n      return;\n\n   free(this->cmdline);\n   this->cmdline = cmdline ? xStrdup(cmdline) : NULL;\n   if (Process_isKernelThread(this)) {\n      /* kernel threads have no basename */\n      this->cmdlineBasenameStart = 0;\n      this->cmdlineBasenameEnd = 0;\n   } else {\n      this->cmdlineBasenameStart = (basenameStart || !cmdline) ? basenameStart : skipPotentialPath(cmdline, basenameEnd);\n      this->cmdlineBasenameEnd = basenameEnd;\n   }\n\n   this->mergedCommand.lastUpdate = 0;\n}\n\nvoid Process_updateExe(Process* this, const char* exe) {\n   if (!this->procExe && !exe)\n      return;\n\n   if (this->procExe && exe && String_eq(this->procExe, exe))\n      return;\n\n   free(this->procExe);\n   if (exe) {\n      this->procExe = xStrdup(exe);\n      const char* lastSlash = strrchr(exe, '/');\n      this->procExeBasenameOffset = (lastSlash && *(lastSlash + 1) != '\\0' && lastSlash != exe) ? (lastSlash - exe + 1) : 0;\n   } else {\n      this->procExe = NULL;\n      this->procExeBasenameOffset = 0;\n   }\n\n   this->mergedCommand.lastUpdate = 0;\n}\n\nvoid Process_updateCPUFieldWidths(float percentage) {\n   if (!isgreaterequal(percentage, 99.9F)) {\n      Row_updateFieldWidth(PERCENT_CPU, 4);\n      Row_updateFieldWidth(PERCENT_NORM_CPU, 4);\n      return;\n   }\n\n   // Add additional two characters, one for \".\" and another for precision.\n   uint8_t width = ceil(log10(percentage + 0.1)) + 2;\n\n   Row_updateFieldWidth(PERCENT_CPU, width);\n   Row_updateFieldWidth(PERCENT_NORM_CPU, width);\n}\n\nconst ProcessClass Process_class = {\n   .super = {\n      .super = {\n         .extends = Class(Row),\n         .display = Row_display,\n         .delete = Process_delete,\n         .compare = Process_compare\n      },\n      .isHighlighted = Process_rowIsHighlighted,\n      .isVisible = Process_rowIsVisible,\n      .matchesFilter = Process_rowMatchesFilter,\n      .sortKeyString = Process_rowGetSortKey,\n      .compareByParent = Process_compareByParent,\n      .writeField = Process_rowWriteField\n   },\n};\n"
        },
        {
          "name": "Process.h",
          "type": "blob",
          "size": 9.73828125,
          "content": "#ifndef HEADER_Process\n#define HEADER_Process\n/*\nhtop - Process.h\n(C) 2004-2015 Hisham H. Muhammad\n(C) 2020 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/types.h>\n\n#include \"Object.h\"\n#include \"RichString.h\"\n#include \"Row.h\"\n#include \"RowField.h\"\n\n\n#define PROCESS_FLAG_IO              0x00000001\n#define PROCESS_FLAG_CWD             0x00000002\n#define PROCESS_FLAG_SCHEDPOL        0x00000004\n\n#define DEFAULT_HIGHLIGHT_SECS 5\n\n/* Sentinel value for an unknown niceness in Process.nice */\n#define PROCESS_NICE_UNKNOWN (-LONG_MAX)\n\ntypedef enum Tristate_ {\n   TRI_INITIAL = 0,\n   TRI_OFF = -1,\n   TRI_ON = 1,\n} Tristate;\n\n\n/* Core process states (shared by platforms)\n * NOTE: The enum has an ordering that is important!\n * See processStateChar in process.c for ProcessSate -> letter mapping */\ntypedef enum ProcessState_ {\n   UNKNOWN = 1,\n   RUNNABLE,\n   RUNNING,\n   QUEUED,\n   WAITING,\n   UNINTERRUPTIBLE_WAIT,\n   BLOCKED,\n   PAGING,\n   STOPPED,\n   TRACED,\n   ZOMBIE,\n   DEFUNCT,\n   IDLE,\n   SLEEPING\n} ProcessState;\n\nstruct Machine_;  // IWYU pragma: keep\nstruct Settings_; // IWYU pragma: keep\n\n/* Holds information about regions of the cmdline that should be\n * highlighted (e.g. program basename, delimiter, comm). */\ntypedef struct ProcessCmdlineHighlight_ {\n   size_t offset; /* first character to highlight */\n   size_t length; /* How many characters to highlight, zero if unused */\n   int attr;      /* The attributes used to highlight */\n   int flags;     /* Special flags used for selective highlighting, zero for always */\n} ProcessCmdlineHighlight;\n\n/* ProcessMergedCommand is populated by Process_makeCommandStr: It\n * contains the merged Command string, and the information needed by\n * Process_writeCommand to color the string. str will be NULL for kernel\n * threads and zombies */\ntypedef struct ProcessMergedCommand_ {\n   uint64_t lastUpdate;                        /* Marker based on settings->lastUpdate to track when the rendering needs refreshing */\n   char* str;                                  /* merged Command string */\n   size_t highlightCount;                      /* how many portions of cmdline to highlight */\n   ProcessCmdlineHighlight highlights[8];      /* which portions of cmdline to highlight */\n} ProcessMergedCommand;\n\ntypedef struct Process_ {\n   /* Super object for emulated OOP */\n   Row super;\n\n   /* Process group identifier */\n   int pgrp;\n\n   /* Session identifier */\n   int session;\n\n   /* Foreground group identifier of the controlling terminal */\n   int tpgid;\n\n   /* This is a kernel (helper) task */\n   bool isKernelThread;\n\n   /* This is a userland thread / LWP */\n   bool isUserlandThread;\n\n   /* This process is running inside a container */\n   Tristate isRunningInContainer;\n\n   /* Controlling terminal identifier of the process */\n   unsigned long int tty_nr;\n\n   /* Controlling terminal name of the process */\n   char* tty_name;\n\n   /* User identifier */\n   uid_t st_uid;\n\n   /* User name */\n   const char* user;\n\n   /* Non root owned process with elevated privileges\n    * Linux:\n    *   - from file capabilities\n    *   - inherited from the ambient set\n    */\n   Tristate elevated_priv;\n\n   /* Process runtime (in hundredth of a second) */\n   unsigned long long int time;\n\n   /*\n    * Process name including arguments.\n    * Use Process_getCommand() for Command actually displayed.\n    */\n   char* cmdline;\n\n   /* End Offset in cmdline of the process basename */\n   int cmdlineBasenameEnd;\n\n   /* Start Offset in cmdline of the process basename */\n   int cmdlineBasenameStart;\n\n   /* The process' \"command\" name */\n   char* procComm;\n\n   /* The main process executable */\n   char* procExe;\n\n   /* The process/thread working directory */\n   char* procCwd;\n\n   /* Offset in procExe of the process basename */\n   int procExeBasenameOffset;\n\n   /* Tells if the executable has been replaced in the filesystem since start */\n   bool procExeDeleted;\n\n   /* Tells if the process uses replaced shared libraries since start */\n   bool usesDeletedLib;\n\n   /* CPU number last executed on */\n   int processor;\n\n   /* CPU usage during last cycle (in percent) */\n   float percent_cpu;\n\n   /* Memory usage during last cycle (in percent) */\n   float percent_mem;\n\n   /* Scheduling priority */\n   long int priority;\n\n   /* Nice value */\n   long int nice;\n\n   /* Number of threads in this process */\n   long int nlwp;\n\n   /* Process start time (in seconds elapsed since the Epoch) */\n   time_t starttime_ctime;\n\n   /* Process start time (cached formatted string) */\n   char starttime_show[8];\n\n   /* Total program size (in kilobytes) */\n   long m_virt;\n\n   /* Resident set size (in kilobytes) */\n   long m_resident;\n\n   /* Number of minor faults the process has made which have not required loading a memory page from disk */\n   unsigned long int minflt;\n\n   /* Number of major faults the process has made which have required loading a memory page from disk */\n   unsigned long int majflt;\n\n   /* Process state enum field (platform dependent) */\n   ProcessState state;\n\n   /* Current scheduling policy */\n   int scheduling_policy;\n\n   /*\n    * Internal state for merged Command display\n    */\n   ProcessMergedCommand mergedCommand;\n} Process;\n\ntypedef struct ProcessFieldData_ {\n   /* Name (displayed in setup menu) */\n   const char* name;\n\n   /* Title (display in main screen); must have same width as the printed values */\n   const char* title;\n\n   /* Description (displayed in setup menu) */\n   const char* description;\n\n   /* Scan flag to enable scan-method otherwise not run */\n   uint32_t flags;\n\n   /* Whether the values are process identifiers; adjusts the width of title and values if true */\n   bool pidColumn;\n\n   /* Whether the column should be sorted in descending order by default */\n   bool defaultSortDesc;\n\n   /* Whether the column width is dynamically adjusted (the minimum width is determined by the title length) */\n   bool autoWidth;\n\n   /* Whether the title of a column with dynamically adjusted width is right aligned (default is left aligned) */\n   bool autoTitleRightAlign;\n} ProcessFieldData;\n\n#define LAST_PROCESSFIELD LAST_RESERVED_FIELD\ntypedef int32_t ProcessField;  /* see ReservedField list in RowField.h */\n\n// Implemented in platform-specific code:\nvoid Process_writeField(const Process* this, RichString* str, ProcessField field);\nint Process_compare(const void* v1, const void* v2);\nint Process_compareByParent(const Row* r1, const Row* r2);\nvoid Process_delete(Object* cast);\nextern const ProcessFieldData Process_fields[LAST_PROCESSFIELD];\n#define Process_pidDigits Row_pidDigits\n#define Process_uidDigits Row_uidDigits\n\ntypedef Process* (*Process_New)(const struct Machine_*);\ntypedef int (*Process_CompareByKey)(const Process*, const Process*, ProcessField);\n\ntypedef struct ProcessClass_ {\n   const RowClass super;\n   const Process_CompareByKey compareByKey;\n} ProcessClass;\n\n#define As_Process(this_)   ((const ProcessClass*)((this_)->super.super.klass))\n\n#define Process_compareByKey(p1_, p2_, key_)   (As_Process(p1_)->compareByKey ? (As_Process(p1_)->compareByKey(p1_, p2_, key_)) : Process_compareByKey_Base(p1_, p2_, key_))\n\n\nstatic inline void Process_setPid(Process* this, pid_t pid) {\n   this->super.id = pid;\n}\n\nstatic inline pid_t Process_getPid(const Process* this) {\n   return (pid_t)this->super.id;\n}\n\nstatic inline void Process_setThreadGroup(Process* this, pid_t pid) {\n   this->super.group = pid;\n}\n\nstatic inline pid_t Process_getThreadGroup(const Process* this) {\n   return (pid_t)this->super.group;\n}\n\nstatic inline void Process_setParent(Process* this, pid_t pid) {\n   this->super.parent = pid;\n}\n\nstatic inline pid_t Process_getParent(const Process* this) {\n   return (pid_t)this->super.parent;\n}\n\nstatic inline pid_t Process_getGroupOrParent(const Process* this) {\n   return Row_getGroupOrParent(&this->super);\n}\n\nstatic inline bool Process_isKernelThread(const Process* this) {\n   return this->isKernelThread;\n}\n\nstatic inline bool Process_isUserlandThread(const Process* this) {\n   return this->isUserlandThread;\n}\n\nstatic inline bool Process_isThread(const Process* this) {\n   return Process_isUserlandThread(this) || Process_isKernelThread(this);\n}\n\n#define CMDLINE_HIGHLIGHT_FLAG_SEPARATOR  0x00000001\n#define CMDLINE_HIGHLIGHT_FLAG_BASENAME   0x00000002\n#define CMDLINE_HIGHLIGHT_FLAG_COMM       0x00000004\n#define CMDLINE_HIGHLIGHT_FLAG_DELETED    0x00000008\n#define CMDLINE_HIGHLIGHT_FLAG_PREFIXDIR  0x00000010\n\nvoid Process_fillStarttimeBuffer(Process* this);\n\nvoid Process_done(Process* this);\n\nextern const ProcessClass Process_class;\n\nvoid Process_init(Process* this, const struct Machine_* host);\n\nconst char* Process_rowGetSortKey(Row* super);\n\nbool Process_rowChangePriorityBy(Row* super, Arg delta);\n\nbool Process_rowSendSignal(Row* super, Arg sgn);\n\nbool Process_rowIsHighlighted(const Row* super);\n\nbool Process_rowIsVisible(const Row* super, const struct Table_* table);\n\nbool Process_rowMatchesFilter(const Row* super, const struct Table_* table);\n\nstatic inline int Process_pidEqualCompare(const void* v1, const void* v2) {\n   return Row_idEqualCompare(v1, v2);\n}\n\nint Process_compareByKey_Base(const Process* p1, const Process* p2, ProcessField key);\n\nconst char* Process_getCommand(const Process* this);\n\nvoid Process_updateComm(Process* this, const char* comm);\nvoid Process_updateCmdline(Process* this, const char* cmdline, int basenameStart, int basenameEnd);\nvoid Process_updateExe(Process* this, const char* exe);\n\n/* This function constructs the string that is displayed by\n * Process_writeCommand and also returned by Process_getCommand */\nvoid Process_makeCommandStr(Process* this, const struct Settings_ *settings);\n\nvoid Process_writeCommand(const Process* this, int attr, int baseAttr, RichString* str);\n\nvoid Process_updateCPUFieldWidths(float percentage);\n\n#endif\n"
        },
        {
          "name": "ProcessLocksScreen.c",
          "type": "blob",
          "size": 3.3935546875,
          "content": "/*\nhtop - ProcessLocksScreen.c\n(C) 2020 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"ProcessLocksScreen.h\"\n\n#include <inttypes.h>\n#include <limits.h>\n#include <stdlib.h>\n\n#include \"Panel.h\"\n#include \"Platform.h\"\n#include \"ProvideCurses.h\"\n#include \"Vector.h\"\n#include \"XUtils.h\"\n\n\nProcessLocksScreen* ProcessLocksScreen_new(const Process* process) {\n   ProcessLocksScreen* this = xMalloc(sizeof(ProcessLocksScreen));\n   Object_setClass(this, Class(ProcessLocksScreen));\n   if (Process_isThread(process))\n      this->pid = Process_getThreadGroup(process);\n   else\n      this->pid = Process_getPid(process);\n\n   return (ProcessLocksScreen*) InfoScreen_init(&this->super, process, NULL, LINES - 2, \"   FD TYPE       EXCLUSION  READ/WRITE DEVICE       NODE               START                 END  FILENAME\");\n}\n\nvoid ProcessLocksScreen_delete(Object* this) {\n   free(InfoScreen_done((InfoScreen*)this));\n}\n\nstatic void ProcessLocksScreen_draw(InfoScreen* this) {\n   InfoScreen_drawTitled(this, \"Snapshot of file locks of process %d - %s\", ((ProcessLocksScreen*)this)->pid, Process_getCommand(this->process));\n}\n\nstatic inline void FileLocks_Data_clear(FileLocks_Data* data) {\n   free(data->locktype);\n   free(data->exclusive);\n   free(data->readwrite);\n   free(data->filename);\n}\n\nstatic void ProcessLocksScreen_scan(InfoScreen* this) {\n   Panel* panel = this->display;\n   int idx = Panel_getSelectedIndex(panel);\n   Panel_prune(panel);\n   FileLocks_ProcessData* pdata = Platform_getProcessLocks(((ProcessLocksScreen*)this)->pid);\n   if (!pdata) {\n      InfoScreen_addLine(this, \"This feature is not supported on your platform.\");\n   } else if (pdata->error) {\n      InfoScreen_addLine(this, \"Could not determine file locks.\");\n   } else {\n      FileLocks_LockData* ldata = pdata->locks;\n      if (!ldata) {\n         InfoScreen_addLine(this, \"No locks have been found for the selected process.\");\n      }\n      while (ldata) {\n         FileLocks_Data* data = &ldata->data;\n\n         char entry[512];\n         if (ULLONG_MAX == data->end) {\n            xSnprintf(entry, sizeof(entry), \"%5d %-10s %-10s %-10s %#6\"PRIx64\" %10\"PRIu64\" %19\"PRIu64\" %19s  %s\",\n               data->fd,\n               data->locktype, data->exclusive, data->readwrite,\n               (uint64_t) data->dev, data->inode,\n               data->start, \"<END OF FILE>\",\n               data->filename ? data->filename : \"<N/A>\"\n            );\n         } else {\n            xSnprintf(entry, sizeof(entry), \"%5d %-10s %-10s %-10s %#6\"PRIx64\" %10\"PRIu64\" %19\"PRIu64\" %19\"PRIu64\"  %s\",\n               data->fd,\n               data->locktype, data->exclusive, data->readwrite,\n               (uint64_t) data->dev, data->inode,\n               data->start, data->end,\n               data->filename ? data->filename : \"<N/A>\"\n            );\n         }\n\n         InfoScreen_addLine(this, entry);\n         FileLocks_Data_clear(&ldata->data);\n\n         FileLocks_LockData* old = ldata;\n         ldata = ldata->next;\n         free(old);\n      }\n   }\n   free(pdata);\n   Vector_insertionSort(this->lines);\n   Vector_insertionSort(panel->items);\n   Panel_setSelected(panel, idx);\n}\n\nconst InfoScreenClass ProcessLocksScreen_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = ProcessLocksScreen_delete\n   },\n   .scan = ProcessLocksScreen_scan,\n   .draw = ProcessLocksScreen_draw\n};\n"
        },
        {
          "name": "ProcessLocksScreen.h",
          "type": "blob",
          "size": 1.0546875,
          "content": "#ifndef HEADER_ProcessLocksScreen\n#define HEADER_ProcessLocksScreen\n/*\nhtop - ProcessLocksScreen.h\n(C) 2020 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/types.h>\n\n#include \"InfoScreen.h\"\n#include \"Object.h\"\n#include \"Process.h\"\n\n\ntypedef struct ProcessLocksScreen_ {\n   InfoScreen super;\n   pid_t pid;\n} ProcessLocksScreen;\n\ntypedef struct FileLocks_Data_ {\n   char* locktype;\n   char* exclusive;\n   char* readwrite;\n   char* filename;\n   int fd;\n   dev_t dev;\n   uint64_t inode;\n   uint64_t start;\n   uint64_t end;\n} FileLocks_Data;\n\ntypedef struct FileLocks_LockData_ {\n   FileLocks_Data data;\n   struct FileLocks_LockData_* next;\n} FileLocks_LockData;\n\ntypedef struct FileLocks_ProcessData_ {\n   bool error;\n   struct FileLocks_LockData_* locks;\n} FileLocks_ProcessData;\n\nextern const InfoScreenClass ProcessLocksScreen_class;\n\nProcessLocksScreen* ProcessLocksScreen_new(const Process* process);\n\nvoid ProcessLocksScreen_delete(Object* this);\n\n#endif\n"
        },
        {
          "name": "ProcessTable.c",
          "type": "blob",
          "size": 2.478515625,
          "content": "/*\nhtop - ProcessTable.c\n(C) 2004,2005 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"ProcessTable.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n\n#include \"Hashtable.h\"\n#include \"Row.h\"\n#include \"Settings.h\"\n#include \"Vector.h\"\n\n\nvoid ProcessTable_init(ProcessTable* this, const ObjectClass* klass, Machine* host, Hashtable* pidMatchList) {\n   Table_init(&this->super, klass, host);\n\n   this->pidMatchList = pidMatchList;\n}\n\nvoid ProcessTable_done(ProcessTable* this) {\n   Table_done(&this->super);\n}\n\nProcess* ProcessTable_getProcess(ProcessTable* this, pid_t pid, bool* preExisting, Process_New constructor) {\n   const Table* table = &this->super;\n   Process* proc = (Process*) Hashtable_get(table->table, pid);\n   *preExisting = proc != NULL;\n   if (proc) {\n      assert(Vector_indexOf(table->rows, proc, Row_idEqualCompare) != -1);\n      assert(Process_getPid(proc) == pid);\n   } else {\n      proc = constructor(table->host);\n      assert(proc->cmdline == NULL);\n      Process_setPid(proc, pid);\n   }\n   return proc;\n}\n\nstatic void ProcessTable_prepareEntries(Table* super) {\n   ProcessTable* this = (ProcessTable*) super;\n   this->totalTasks = 0;\n   this->userlandThreads = 0;\n   this->kernelThreads = 0;\n   this->runningTasks = 0;\n\n   Table_prepareEntries(super);\n}\n\nstatic void ProcessTable_iterateEntries(Table* super) {\n   ProcessTable* this = (ProcessTable*) super;\n   // calling into platform-specific code\n   ProcessTable_goThroughEntries(this);\n}\n\nstatic void ProcessTable_cleanupEntries(Table* super) {\n   Machine* host = super->host;\n   const Settings* settings = host->settings;\n\n   // Finish process table update, culling any exit'd processes\n   for (int i = Vector_size(super->rows) - 1; i >= 0; i--) {\n      Process* p = (Process*) Vector_get(super->rows, i);\n\n      // tidy up Process state after refreshing the ProcessTable table\n      Process_makeCommandStr(p, settings);\n\n      // keep track of the highest UID for column scaling\n      if (p->st_uid > host->maxUserId)\n         host->maxUserId = p->st_uid;\n\n      Table_cleanupRow(super, (Row*) p, i);\n   }\n\n   // compact the table in case of deletions\n   Table_compact(super);\n}\n\nconst TableClass ProcessTable_class = {\n   .super = {\n      .extends = Class(Table),\n      .delete = ProcessTable_delete,\n   },\n   .prepare = ProcessTable_prepareEntries,\n   .iterate = ProcessTable_iterateEntries,\n   .cleanup = ProcessTable_cleanupEntries,\n};\n"
        },
        {
          "name": "ProcessTable.h",
          "type": "blob",
          "size": 1.33203125,
          "content": "#ifndef HEADER_ProcessTable\n#define HEADER_ProcessTable\n/*\nhtop - ProcessTable.h\n(C) 2004,2005 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n#include <sys/types.h>\n\n#include \"Hashtable.h\"\n#include \"Machine.h\"\n#include \"Object.h\"\n#include \"Process.h\"\n#include \"Table.h\"\n\n\ntypedef struct ProcessTable_ {\n   Table super;\n\n   Hashtable* pidMatchList;\n\n   unsigned int totalTasks;\n   unsigned int runningTasks;\n   unsigned int userlandThreads;\n   unsigned int kernelThreads;\n} ProcessTable;\n\n/* Implemented by platforms */\nProcessTable* ProcessTable_new(Machine* host, Hashtable* pidMatchList);\nvoid ProcessTable_delete(Object* cast);\nvoid ProcessTable_goThroughEntries(ProcessTable* this);\n\nvoid ProcessTable_init(ProcessTable* this, const ObjectClass* klass, Machine* host, Hashtable* pidMatchList);\n\nvoid ProcessTable_done(ProcessTable* this);\n\nextern const TableClass ProcessTable_class;\n\nstatic inline void ProcessTable_add(ProcessTable* this, Process* process) {\n   Table_add(&this->super, &process->super);\n}\n\nProcess* ProcessTable_getProcess(ProcessTable* this, pid_t pid, bool* preExisting, Process_New constructor);\n\nstatic inline Process* ProcessTable_findProcess(ProcessTable* this, pid_t pid) {\n   return (Process*) Table_findRow(&this->super, pid);\n}\n\n#endif\n"
        },
        {
          "name": "ProvideCurses.h",
          "type": "blob",
          "size": 0.837890625,
          "content": "#ifndef HEADER_ProvideCurses\n#define HEADER_ProvideCurses\n/*\nhtop - ProvideCurses.h\n(C) 2004,2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n\n// This header is also used in tests by configure, thus conditionally\n// including \"config.h\".\n#if defined(HAVE_CONFIG_H)\n#include \"config.h\" // IWYU pragma: keep\n#endif\n\n// IWYU pragma: begin_exports\n\n#if defined(HAVE_NCURSESW_CURSES_H)\n#include <ncursesw/curses.h>\n#elif defined(HAVE_NCURSES_NCURSES_H)\n#include <ncurses/ncurses.h>\n#elif defined(HAVE_NCURSES_CURSES_H)\n#include <ncurses/curses.h>\n#elif defined(HAVE_NCURSES_H)\n#include <ncurses.h>\n#elif defined(HAVE_CURSES_H)\n#include <curses.h>\n#endif\n\n#ifdef HAVE_LIBNCURSESW\n#include <wchar.h>\n#include <wctype.h>\n#endif\n\n// IWYU pragma: end_exports\n\n#endif // HEADER_ProvideCurses\n"
        },
        {
          "name": "ProvideTerm.h",
          "type": "blob",
          "size": 0.4970703125,
          "content": "#ifndef HEADER_ProvideTerm\n#define HEADER_ProvideTerm\n/*\nhtop - ProvideTerm.h\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n// IWYU pragma: begin_exports\n\n#if defined(HAVE_NCURSESW_TERM_H)\n#include <ncursesw/term.h>\n#elif defined(HAVE_NCURSES_TERM_H)\n#include <ncurses/term.h>\n#elif defined(HAVE_TERM_H)\n#include <term.h>\n#endif\n\n// IWYU pragma: end_exports\n\n#endif // HEADER_ProvideTerm\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 0.0087890625,
          "content": "README.md"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.0703125,
          "content": "# [![htop logo](htop.png)](https://htop.dev)\n\n[![CI](https://github.com/htop-dev/htop/workflows/CI/badge.svg)](https://github.com/htop-dev/htop/actions)\n[![Coverity Scan Build Status](https://scan.coverity.com/projects/21665/badge.svg)](https://scan.coverity.com/projects/21665)\n[![Mailing List](https://img.shields.io/badge/Mailing%20List-htop-blue.svg)](https://groups.io/g/htop)\n[![IRC #htop](https://img.shields.io/badge/IRC-htop-blue.svg)](https://web.libera.chat/#htop)\n[![GitHub Release](https://img.shields.io/github/release/htop-dev/htop.svg)](https://github.com/htop-dev/htop/releases/latest)\n[![Packaging status](https://repology.org/badge/tiny-repos/htop.svg)](https://repology.org/project/htop/versions)\n[![License: GPL v2+](https://img.shields.io/badge/License-GPL%20v2+-blue.svg)](COPYING?raw=true)\n\n![Screenshot of htop](docs/images/screenshot.png?raw=true)\n\n## Introduction\n\n`htop` is a cross-platform interactive process viewer.\n\n`htop` allows scrolling the list of processes vertically and horizontally to see their full command lines and related information like memory and CPU consumption.\nAlso system wide information, like load average or swap usage, is shown.\n\nThe information displayed is configurable through a graphical setup and can be sorted and filtered interactively.\n\nTasks related to processes (e.g. killing and renicing) can be done without entering their PIDs.\n\nRunning `htop` requires `ncurses` libraries, typically named libncurses(w).\n\n`htop` is written in C.\n\nFor more information and details visit [htop.dev](https://htop.dev).\n\n## Build instructions\n\n### Prerequisite\nList of build-time dependencies:\n  * standard GNU autotools-based C toolchain\n    - C99 compliant compiler\n    - `autoconf`\n    - `automake`\n    - `autotools`\n  * `ncurses`\n\n**Note about `ncurses`:**\n> `htop` requires `ncurses` 6.0. Be aware the appropriate package is sometimes still called libncurses5 (on Debian/Ubuntu). Also `ncurses` usually comes in two flavours:\n>* With Unicode support.\n>* Without Unicode support.\n>\n> This is also something that is reflected in the package name on Debian/Ubuntu (via the additional 'w' - 'w'ide character support).\n\nList of additional build-time dependencies (based on feature flags):\n*  `pkg-config`\n*  `sensors`\n*  `hwloc`\n*  `libcap` (v2.21 or later)\n*  `libnl-3` and `libnl-genl-3`\n\n`pkg-config` is optional but recommended. The configure script of `htop` might utilize `pkg-config` to obtain the compiler and linker flags required for a library. Some OS distributions provide `pkg-config` functionalities through an alternative implementation such as `pkgconf`. Look for both names in your package manager.\n\nInstall these and other required packages for C development from your package manager.\n\n**Debian/Ubuntu**\n~~~ shell\nsudo apt install libncursesw5-dev autotools-dev autoconf automake build-essential\n~~~\n\n**Fedora/RHEL**\n~~~ shell\nsudo dnf install ncurses-devel automake autoconf gcc\n~~~\n\n**Archlinux/Manjaro**\n~~~ shell\nsudo pacman -S ncurses automake autoconf gcc\n~~~\n\n**macOS**\n~~~ shell\nbrew install ncurses automake autoconf gcc\n~~~\n\n### Compile from source:\nTo compile from source, download from the Git repository (`git clone` or downloads from [GitHub releases](https://github.com/htop-dev/htop/releases/)), then run:\n~~~ shell\n./autogen.sh && ./configure && make\n~~~\n\n### Install\nTo install on the local system run `make install`. By default `make install` installs into `/usr/local`. To change this path use `./configure --prefix=/some/path`.\n\n### Build Options\n\n`htop` has several build-time options to enable/disable additional features.\n\n#### Generic\n\n  * `--enable-unicode`:\n    enable Unicode support\n    - dependency: *libncursesw*\n    - default: *yes*\n  * `--enable-affinity`:\n    enable `sched_setaffinity(2)` and `sched_getaffinity(2)` for affinity support; conflicts with hwloc\n    - default: *check*\n  * `--enable-hwloc`:\n    enable hwloc support for CPU affinity; disables affinity support\n    - dependency: *libhwloc*\n    - default: *no*\n  * `--enable-static`:\n    build a static htop binary; hwloc and delay accounting are not supported\n    - default: *no*\n  * `--enable-debug`:\n    Enable asserts and internal sanity checks; implies a performance penalty\n    - default: *no*\n\n#### Performance Co-Pilot\n\n  * `--enable-pcp`:\n    enable Performance Co-Pilot support via a new pcp-htop utility\n    - dependency: *libpcp*\n    - default: *no*\n\n#### Linux\n\n  * `--enable-sensors`:\n    enable libsensors(3) support for reading temperature data\n    - dependencies: *libsensors-dev*(build-time), at runtime *libsensors* is loaded via `dlopen(3)` if available\n    - default: *check*\n  * `--enable-capabilities`:\n    enable Linux capabilities support\n    - dependency: *libcap*\n    - default: *check*\n  * `--with-proc`:\n    location of a Linux-compatible proc filesystem\n    - default: */proc*\n  * `--enable-openvz`:\n    enable OpenVZ support\n    - default: *no*\n  * `--enable-vserver`:\n    enable VServer support\n    - default: *no*\n  * `--enable-ancient-vserver`:\n    enable ancient VServer support (implies `--enable-vserver`)\n    - default: *no*\n  * `--enable-delayacct`:\n    enable Linux delay accounting support\n    - dependencies: *libnl-3-dev*(build-time) and *libnl-genl-3-dev*(build-time), at runtime *libnl-3* and *libnl-genl-3* are loaded via `dlopen(3)` if available and requested\n    - default: *check*\n\n\n## Runtime dependencies:\n`htop` has a set of fixed minimum runtime dependencies, which is kept as minimal as possible:\n* `ncurses` libraries for terminal handling (wide character support).\n\n### Runtime optional dependencies:\n`htop` has a set of fixed optional dependencies, depending on build/configure option used:\n\n#### Linux\n* `libdl`, if not building a static binary, is always required when support for optional dependencies (i.e. `libsensors`, `libsystemd`) is present.\n* `libcap`, user-space interfaces to POSIX 1003.1e capabilities, is always required when `--enable-capabilities` was used to configure `htop`.\n* `libsensors`, readout of temperatures and CPU speeds, is optional even when `--enable-sensors` was used to configure `htop`.\n* `libsystemd` is optional when `--enable-static` was not used to configure `htop`. If building statically and `libsystemd` is not found by `configure`, support for the systemd meter is disabled entirely.\n* `libnl-3` and `libnl-genl-3`, if `htop` was configured with `--enable-delayacct` and delay accounting process fields are active.\n* I/O counters are available when the kernel is compiled with `CONFIG_TASK_IO_ACCOUNTING=Y`.\n\n`htop` checks for the availability of the actual runtime libraries as `htop` runs.\n\n#### BSD\nOn most BSD systems `kvm` is a requirement to read kernel information.\n\nMore information on required and optional dependencies can be found in [configure.ac](configure.ac).\n\n## Usage\nSee the manual page (`man htop`) or the help menu (**F1** or **h** inside `htop`) for a list of supported key commands.\n\n## Support\n\nIf you have trouble running `htop` please consult your operating system / Linux distribution documentation for getting support and filing bugs.\n\n## Bugs, development feedback\n\nWe have a [development mailing list](https://htop.dev/mailinglist.html). Feel free to subscribe for release announcements or asking questions on the development of `htop`.\n\nYou can also join our IRC channel [#htop on Libera.Chat](https://web.libera.chat/#htop) and talk to the developers there.\n\nIf you have found an issue within the source of `htop`, please check whether this has already been reported in our [GitHub issue tracker](https://github.com/htop-dev/htop/issues).\nIf not, please file a new issue describing the problem you have found, the potential location in the source code you are referring to and a possible fix if available.\n\n## History\n\n`htop` was invented, developed and maintained by [Hisham Muhammad](https://hisham.hm/) from 2004 to 2019. His [legacy repository](https://github.com/hishamhm/htop/) has been archived to preserve the history.\n\nIn 2020 a [team](https://github.com/orgs/htop-dev/people) took over the development amicably and continues to maintain `htop` collaboratively.\n\n## License\n\nGNU General Public License, version 2 (GPL-2.0) or, at your option, any later version.\n"
        },
        {
          "name": "RichString.c",
          "type": "blob",
          "size": 7.53515625,
          "content": "/*\nhtop - RichString.c\n(C) 2004,2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"RichString.h\"\n\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h> // IWYU pragma: keep\n#include <stdlib.h>\n#include <string.h>\n\n#include \"Macros.h\"\n#include \"XUtils.h\"\n\n\n#define charBytes(n) (sizeof(CharType) * (n))\n\nstatic void RichString_extendLen(RichString* this, int len) {\n   if (this->chptr == this->chstr) {\n      // String is in internal buffer\n      if (len > RICHSTRING_MAXLEN) {\n         // Copy from internal buffer to allocated string\n         this->chptr = xMalloc(charBytes(len + 1));\n         memcpy(this->chptr, this->chstr, charBytes(this->chlen));\n      } else {\n         // Still fits in internal buffer, do nothing\n         assert(this->chlen <= RICHSTRING_MAXLEN);\n      }\n   } else {\n      // String is managed externally\n      if (len > RICHSTRING_MAXLEN) {\n         // Just reallocate the buffer accordingly\n         this->chptr = xRealloc(this->chptr, charBytes(len + 1));\n      } else {\n         // Move string into internal buffer and free resources\n         memcpy(this->chstr, this->chptr, charBytes(len));\n         free(this->chptr);\n         this->chptr = this->chstr;\n      }\n   }\n\n   RichString_setChar(this, len, 0);\n   this->chlen = len;\n}\n\nstatic void RichString_setLen(RichString* this, int len) {\n   if (len < RICHSTRING_MAXLEN && this->chlen < RICHSTRING_MAXLEN) {\n      RichString_setChar(this, len, 0);\n      this->chlen = len;\n   } else {\n      RichString_extendLen(this, len);\n   }\n}\n\nvoid RichString_rewind(RichString* this, int count) {\n   RichString_setLen(this, this->chlen - count);\n}\n\n#ifdef HAVE_LIBNCURSESW\n\nstatic size_t mbstowcs_nonfatal(wchar_t* restrict dest, const char* restrict src, size_t n) {\n   size_t written = 0;\n   mbstate_t ps = { 0 };\n   bool broken = false;\n\n   while (n > 0) {\n      size_t ret = mbrtowc(dest, src, n, &ps);\n      if (ret == (size_t)-1 || ret == (size_t)-2) {\n         if (!broken) {\n            broken = true;\n            *dest++ = L'\\xFFFD';\n            written++;\n         }\n         src++;\n         n--;\n         continue;\n      }\n\n      broken = false;\n\n      if (ret == 0) {\n         break;\n      }\n\n      dest++;\n      written++;\n      src += ret;\n      n -= ret;\n   }\n\n   return written;\n}\n\nstatic inline int RichString_writeFromWide(RichString* this, int attrs, const char* data_c, int from, int len) {\n   wchar_t data[len];\n   len = mbstowcs_nonfatal(data, data_c, len);\n   if (len <= 0)\n      return 0;\n\n   int newLen = from + len;\n   RichString_setLen(this, newLen);\n   for (int i = from, j = 0; i < newLen; i++, j++) {\n      this->chptr[i] = (CharType) { .attr = attrs & 0xffffff, .chars = { (iswprint(data[j]) ? data[j] : L'\\xFFFD') } };\n   }\n\n   return len;\n}\n\nint RichString_appendnWideColumns(RichString* this, int attrs, const char* data_c, int len, int* columns) {\n   wchar_t data[len];\n   len = mbstowcs_nonfatal(data, data_c, len);\n   if (len <= 0)\n      return 0;\n\n   int from = this->chlen;\n   int newLen = from + len;\n   RichString_setLen(this, newLen);\n   int columnsWritten = 0;\n   int pos = from;\n   for (int j = 0; j < len; j++) {\n      wchar_t c = iswprint(data[j]) ? data[j] : L'\\xFFFD';\n      int cwidth = wcwidth(c);\n      if (cwidth > *columns)\n         break;\n\n      *columns -= cwidth;\n      columnsWritten += cwidth;\n\n      this->chptr[pos] = (CharType) { .attr = attrs & 0xffffff, .chars = { c, '\\0' } };\n      pos++;\n   }\n\n   RichString_setLen(this, pos);\n   *columns = columnsWritten;\n\n   return pos - from;\n}\n\nstatic inline int RichString_writeFromAscii(RichString* this, int attrs, const char* data, int from, int len) {\n   int newLen = from + len;\n   RichString_setLen(this, newLen);\n   for (int i = from, j = 0; i < newLen; i++, j++) {\n      assert((unsigned char)data[j] <= SCHAR_MAX);\n      this->chptr[i] = (CharType) { .attr = attrs & 0xffffff, .chars = { (isprint((unsigned char)data[j]) ? data[j] : L'\\xFFFD') } };\n   }\n\n   return len;\n}\n\ninline void RichString_setAttrn(RichString* this, int attrs, int start, int charcount) {\n   int end = CLAMP(start + charcount, 0, this->chlen);\n   for (int i = start; i < end; i++) {\n      this->chptr[i].attr = attrs;\n   }\n}\n\nvoid RichString_appendChr(RichString* this, int attrs, char c, int count) {\n   int from = this->chlen;\n   int newLen = from + count;\n   RichString_setLen(this, newLen);\n   for (int i = from; i < newLen; i++) {\n      this->chptr[i] = (CharType) { .attr = attrs, .chars = { c, 0 } };\n   }\n}\n\nint RichString_findChar(const RichString* this, char c, int start) {\n   const wchar_t wc = btowc(c);\n   const cchar_t* ch = this->chptr + start;\n   for (int i = start; i < this->chlen; i++) {\n      if (ch->chars[0] == wc)\n         return i;\n      ch++;\n   }\n   return -1;\n}\n\n#else /* HAVE_LIBNCURSESW */\n\nstatic inline int RichString_writeFromWide(RichString* this, int attrs, const char* data_c, int from, int len) {\n   int newLen = from + len;\n   RichString_setLen(this, newLen);\n   for (int i = from, j = 0; i < newLen; i++, j++) {\n      this->chptr[i] = (((unsigned char)data_c[j]) >= 32 ? ((unsigned char)data_c[j]) : '?') | attrs;\n   }\n   this->chptr[newLen] = 0;\n\n   return len;\n}\n\nint RichString_appendnWideColumns(RichString* this, int attrs, const char* data_c, int len, int* columns) {\n   int written = RichString_writeFromWide(this, attrs, data_c, this->chlen, MINIMUM(len, *columns));\n   *columns = written;\n   return written;\n}\n\nstatic inline int RichString_writeFromAscii(RichString* this, int attrs, const char* data_c, int from, int len) {\n   return RichString_writeFromWide(this, attrs, data_c, from, len);\n}\n\nvoid RichString_setAttrn(RichString* this, int attrs, int start, int charcount) {\n   int end = CLAMP(start + charcount, 0, this->chlen);\n   for (int i = start; i < end; i++) {\n      this->chptr[i] = (this->chptr[i] & 0xff) | attrs;\n   }\n}\n\nvoid RichString_appendChr(RichString* this, int attrs, char c, int count) {\n   int from = this->chlen;\n   int newLen = from + count;\n   RichString_setLen(this, newLen);\n   for (int i = from; i < newLen; i++) {\n      this->chptr[i] = c | attrs;\n   }\n}\n\nint RichString_findChar(const RichString* this, char c, int start) {\n   const chtype* ch = this->chptr + start;\n   for (int i = start; i < this->chlen; i++) {\n      if ((*ch & 0xff) == (chtype) c)\n         return i;\n      ch++;\n   }\n   return -1;\n}\n\n#endif /* HAVE_LIBNCURSESW */\n\nvoid RichString_delete(RichString* this) {\n   if (this->chlen > RICHSTRING_MAXLEN) {\n      free(this->chptr);\n      this->chptr = this->chstr;\n   }\n}\n\nvoid RichString_setAttr(RichString* this, int attrs) {\n   RichString_setAttrn(this, attrs, 0, this->chlen);\n}\n\nint RichString_appendWide(RichString* this, int attrs, const char* data) {\n   return RichString_writeFromWide(this, attrs, data, this->chlen, strlen(data));\n}\n\nint RichString_appendnWide(RichString* this, int attrs, const char* data, int len) {\n   return RichString_writeFromWide(this, attrs, data, this->chlen, len);\n}\n\nint RichString_writeWide(RichString* this, int attrs, const char* data) {\n   return RichString_writeFromWide(this, attrs, data, 0, strlen(data));\n}\n\nint RichString_appendAscii(RichString* this, int attrs, const char* data) {\n   return RichString_writeFromAscii(this, attrs, data, this->chlen, strlen(data));\n}\n\nint RichString_appendnAscii(RichString* this, int attrs, const char* data, int len) {\n   return RichString_writeFromAscii(this, attrs, data, this->chlen, len);\n}\n\nint RichString_writeAscii(RichString* this, int attrs, const char* data) {\n   return RichString_writeFromAscii(this, attrs, data, 0, strlen(data));\n}\n"
        },
        {
          "name": "RichString.h",
          "type": "blob",
          "size": 2.787109375,
          "content": "#ifndef HEADER_RichString\n#define HEADER_RichString\n/*\nhtop - RichString.h\n(C) 2004,2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Macros.h\"\n#include \"ProvideCurses.h\"\n\n\n#define RichString_size(this) ((this)->chlen)\n#define RichString_sizeVal(this) ((this).chlen)\n\n#define RichString_begin(this) RichString this; RichString_beginAllocated(this)\n#define RichString_beginAllocated(this)   \\\n   do {                                   \\\n      (this).chlen = 0;                   \\\n      (this).chptr = (this).chstr;        \\\n      RichString_setChar(&(this), 0, 0);  \\\n      (this).highlightAttr = 0;           \\\n   } while(0)\n\n#ifdef HAVE_LIBNCURSESW\n#define RichString_printVal(this, y, x) mvadd_wchstr(y, x, (this).chptr)\n#define RichString_printoffnVal(this, y, x, off, n) mvadd_wchnstr(y, x, (this).chptr + (off), n)\n#define RichString_getCharVal(this, i) ((this).chptr[i].chars[0])\n#define RichString_setChar(this, at, ch) do { (this)->chptr[(at)] = (CharType) { .chars = { ch, 0 } }; } while (0)\n#define CharType cchar_t\n#else\n#define RichString_printVal(this, y, x) mvaddchstr(y, x, (this).chptr)\n#define RichString_printoffnVal(this, y, x, off, n) mvaddchnstr(y, x, (this).chptr + (off), n)\n#define RichString_getCharVal(this, i) ((this).chptr[i] & 0xff)\n#define RichString_setChar(this, at, ch) do { (this)->chptr[(at)] = ch; } while (0)\n#define CharType chtype\n#endif\n\n#define RICHSTRING_MAXLEN 350\n\ntypedef struct RichString_ {\n   int chlen;\n   CharType* chptr;\n   CharType chstr[RICHSTRING_MAXLEN + 1];\n   int highlightAttr;\n} RichString;\n\nvoid RichString_delete(RichString* this);\n\nvoid RichString_rewind(RichString* this, int count);\n\nvoid RichString_setAttrn(RichString* this, int attrs, int start, int charcount);\n\nint RichString_findChar(const RichString* this, char c, int start);\n\nvoid RichString_setAttr(RichString* this, int attrs);\n\nvoid RichString_appendChr(RichString* this, int attrs, char c, int count);\n\n/* All appending and writing functions return the number of written characters (not columns). */\n\nint RichString_appendWide(RichString* this, int attrs, const char* data);\n\nATTR_ACCESS3_R(3, 4)\nint RichString_appendnWide(RichString* this, int attrs, const char* data, int len);\n\n/* columns takes the maximum number of columns to write and contains on return the number of columns written. */\nint RichString_appendnWideColumns(RichString* this, int attrs, const char* data, int len, int* columns);\n\nint RichString_writeWide(RichString* this, int attrs, const char* data);\n\nint RichString_appendAscii(RichString* this, int attrs, const char* data);\n\nATTR_ACCESS3_R(3, 4)\nint RichString_appendnAscii(RichString* this, int attrs, const char* data, int len);\n\nint RichString_writeAscii(RichString* this, int attrs, const char* data);\n\n#endif\n"
        },
        {
          "name": "Row.c",
          "type": "blob",
          "size": 18.7578125,
          "content": "/*\nhtop - Row.c\n(C) 2004-2015 Hisham H. Muhammad\n(C) 2020-2023 Red Hat, Inc.  All Rights Reserved.\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Row.h\"\n\n#include <assert.h>\n#include <limits.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"DynamicColumn.h\"\n#include \"Hashtable.h\"\n#include \"Machine.h\"\n#include \"Macros.h\"\n#include \"Process.h\"\n#include \"RichString.h\"\n#include \"Settings.h\"\n#include \"XUtils.h\"\n\n\nint Row_pidDigits = ROW_MIN_PID_DIGITS;\nint Row_uidDigits = ROW_MIN_UID_DIGITS;\n\nvoid Row_init(Row* this, const Machine* host) {\n   this->host = host;\n   this->tag = false;\n   this->showChildren = true;\n   this->show = true;\n   this->wasShown = false;\n   this->updated = false;\n}\n\nvoid Row_done(Row* this) {\n   assert(this != NULL);\n   (void) this;\n}\n\nstatic inline bool Row_isNew(const Row* this) {\n   const Machine* host = this->host;\n   if (host->monotonicMs < this->seenStampMs)\n      return false;\n\n   const Settings* settings = host->settings;\n   return host->monotonicMs - this->seenStampMs <= 1000 * (uint64_t)settings->highlightDelaySecs;\n}\n\nstatic inline bool Row_isTomb(const Row* this) {\n   return this->tombStampMs > 0;\n}\n\nvoid Row_display(const Object* cast, RichString* out) {\n   const Row* this = (const Row*) cast;\n   const Settings* settings = this->host->settings;\n   const RowField* fields = settings->ss->fields;\n\n   for (int i = 0; fields[i]; i++)\n      As_Row(this)->writeField(this, out, fields[i]);\n\n   if (Row_isHighlighted(this))\n      RichString_setAttr(out, CRT_colors[PROCESS_SHADOW]);\n\n   if (this->tag == true)\n      RichString_setAttr(out, CRT_colors[PROCESS_TAG]);\n\n   if (settings->highlightChanges) {\n      if (Row_isTomb(this))\n         out->highlightAttr = CRT_colors[PROCESS_TOMB];\n      else if (Row_isNew(this))\n         out->highlightAttr = CRT_colors[PROCESS_NEW];\n   }\n\n   assert(RichString_size(out) > 0);\n}\n\nvoid Row_setPidColumnWidth(pid_t maxPid) {\n   if (maxPid < (int)pow(10, ROW_MIN_PID_DIGITS)) {\n      Row_pidDigits = ROW_MIN_PID_DIGITS;\n      return;\n   }\n\n   Row_pidDigits = countDigits((size_t)maxPid, 10);\n   assert(Row_pidDigits <= ROW_MAX_PID_DIGITS);\n}\n\nvoid Row_setUidColumnWidth(uid_t maxUid) {\n   if (maxUid < (uid_t)pow(10, ROW_MIN_UID_DIGITS)) {\n      Row_uidDigits = ROW_MIN_UID_DIGITS;\n      return;\n   }\n\n   Row_uidDigits = countDigits((size_t)maxUid, 10);\n   assert(Row_uidDigits <= ROW_MAX_UID_DIGITS);\n}\n\nuint8_t Row_fieldWidths[LAST_PROCESSFIELD] = { 0 };\n\nvoid Row_resetFieldWidths(void) {\n   for (size_t i = 0; i < LAST_PROCESSFIELD; i++) {\n      if (!Process_fields[i].autoWidth)\n         continue;\n\n      size_t len = strlen(Process_fields[i].title);\n      assert(len <= UINT8_MAX);\n      Row_fieldWidths[i] = (uint8_t)len;\n   }\n}\n\nvoid Row_updateFieldWidth(RowField key, size_t width) {\n   if (width > UINT8_MAX)\n      Row_fieldWidths[key] = UINT8_MAX;\n   else if (width > Row_fieldWidths[key])\n      Row_fieldWidths[key] = (uint8_t)width;\n}\n\n// helper function to fill an aligned title string for a dynamic column\nstatic const char* alignedTitleDynamicColumn(const Settings* settings, int key, char* titleBuffer, size_t titleBufferSize) {\n   const DynamicColumn* column = Hashtable_get(settings->dynamicColumns, key);\n   if (column == NULL)\n      return \"- \";\n\n   int width = column->width;\n   if (!width || abs(width) > DYNAMIC_MAX_COLUMN_WIDTH)\n      width = DYNAMIC_DEFAULT_COLUMN_WIDTH;\n\n   xSnprintf(titleBuffer, titleBufferSize, \"%*s \", width, column->heading);\n   return titleBuffer;\n}\n\n// helper function to fill an aligned title string for a process field\nstatic const char* alignedTitleProcessField(ProcessField field, char* titleBuffer, size_t titleBufferSize) {\n   const char* title = Process_fields[field].title;\n   if (!title)\n      return \"- \";\n\n   if (Process_fields[field].pidColumn) {\n      xSnprintf(titleBuffer, titleBufferSize, \"%*s \", Row_pidDigits, title);\n      return titleBuffer;\n   }\n\n   if (field == ST_UID) {\n      xSnprintf(titleBuffer, titleBufferSize, \"%*s \", Row_uidDigits, title);\n      return titleBuffer;\n   }\n\n   if (Process_fields[field].autoWidth) {\n      if (Process_fields[field].autoTitleRightAlign)\n         xSnprintf(titleBuffer, titleBufferSize, \"%*s \", Row_fieldWidths[field], title);\n      else\n         xSnprintf(titleBuffer, titleBufferSize, \"%-*.*s \", Row_fieldWidths[field], Row_fieldWidths[field], title);\n      return titleBuffer;\n   }\n\n   return title;\n}\n\n// helper function to create an aligned title string for a given field\nconst char* RowField_alignedTitle(const Settings* settings, RowField field) {\n   static char titleBuffer[UINT8_MAX + sizeof(\" \")];\n   assert(sizeof(titleBuffer) >= DYNAMIC_MAX_COLUMN_WIDTH + sizeof(\" \"));\n   assert(sizeof(titleBuffer) >= ROW_MAX_PID_DIGITS + sizeof(\" \"));\n   assert(sizeof(titleBuffer) >= ROW_MAX_UID_DIGITS + sizeof(\" \"));\n\n   if (field < LAST_PROCESSFIELD)\n      return alignedTitleProcessField((ProcessField)field, titleBuffer, sizeof(titleBuffer));\n   return alignedTitleDynamicColumn(settings, field, titleBuffer, sizeof(titleBuffer));\n}\n\nRowField RowField_keyAt(const Settings* settings, int at) {\n   const RowField* fields = (const RowField*) settings->ss->fields;\n   RowField field;\n   int x = 0;\n   for (int i = 0; (field = fields[i]); i++) {\n      int len = strlen(RowField_alignedTitle(settings, field));\n      if (at >= x && at <= x + len) {\n         return field;\n      }\n      x += len;\n   }\n   return COMM;\n}\n\nvoid Row_printKBytes(RichString* str, unsigned long long number, bool coloring) {\n   char buffer[16];\n   int len;\n\n   int color = CRT_colors[PROCESS];\n   int nextUnitColor = CRT_colors[PROCESS];\n\n   const int colors[4] = {\n      [0] = CRT_colors[PROCESS],\n      [1] = CRT_colors[PROCESS_MEGABYTES],\n      [2] = CRT_colors[PROCESS_GIGABYTES],\n      [3] = CRT_colors[LARGE_NUMBER]\n   };\n\n   if (number == ULLONG_MAX)\n      goto invalidNumber;\n\n   if (coloring) {\n      color = colors[0];\n      nextUnitColor = colors[1];\n   }\n\n   if (number < 1000) {\n      // Plain number, no markings\n      len = xSnprintf(buffer, sizeof(buffer), \"%5u \", (unsigned int)number);\n      RichString_appendnAscii(str, color, buffer, len);\n      return;\n   }\n\n   if (number < 100000) {\n      // 2 digits for M, 3 digits for K\n      len = xSnprintf(buffer, sizeof(buffer), \"%2u\", (unsigned int)(number / 1000));\n      RichString_appendnAscii(str, nextUnitColor, buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%03u \", (unsigned int)(number % 1000));\n      RichString_appendnAscii(str, color, buffer, len);\n      return;\n   }\n\n   // 100000 KiB (97.6 MiB) or greater. A unit prefix would be added.\n   const size_t maxUnitIndex = (sizeof(number) * CHAR_BIT - 1) / 10 + 1;\n   const bool canOverflow = maxUnitIndex >= ARRAYSIZE(unitPrefixes);\n\n   size_t i = 1;\n   int prevUnitColor;\n   // Convert KiB to (1/100) of MiB\n   unsigned long long hundredths = (number / 256) * 25 + (number % 256) * 25 / 256;\n   while (true) {\n      if (canOverflow && i >= ARRAYSIZE(unitPrefixes))\n         goto invalidNumber;\n\n      prevUnitColor = color;\n      color = nextUnitColor;\n\n      if (coloring && i + 1 < ARRAYSIZE(colors))\n         nextUnitColor = colors[i + 1];\n\n      if (hundredths < 1000000)\n         break;\n\n      hundredths /= ONE_K;\n      i++;\n   }\n\n   number = hundredths / 100;\n   hundredths %= 100;\n   if (number < 100) {\n      if (number < 10) {\n         // 1 digit + decimal point + 2 digits\n         // \"9.76G\", \"9.99G\", \"9.76T\", \"9.99T\", etc.\n         len = xSnprintf(buffer, sizeof(buffer), \"%1u\", (unsigned int)number);\n         RichString_appendnAscii(str, color, buffer, len);\n         len = xSnprintf(buffer, sizeof(buffer), \".%02u\", (unsigned int)hundredths);\n      } else {\n         // 2 digits + decimal point + 1 digit\n         // \"97.6M\", \"99.9M\", \"10.0G\", \"99.9G\", etc.\n         len = xSnprintf(buffer, sizeof(buffer), \"%2u\", (unsigned int)number);\n         RichString_appendnAscii(str, color, buffer, len);\n         len = xSnprintf(buffer, sizeof(buffer), \".%1u\", (unsigned int)hundredths / 10);\n      }\n      RichString_appendnAscii(str, prevUnitColor, buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%c \", unitPrefixes[i]);\n   } else if (number < 1000) {\n      // 3 digits\n      // \"100M\", \"999M\", \"100G\", \"999G\", etc.\n      len = xSnprintf(buffer, sizeof(buffer), \"%4u%c \", (unsigned int)number, unitPrefixes[i]);\n   } else {\n      // 1 digit + 3 digits\n      // \"1000M\", \"9999M\", \"1000G\", \"9999G\", etc.\n      assert(number < 10000);\n\n      len = xSnprintf(buffer, sizeof(buffer), \"%1u\", (unsigned int)number / 1000);\n      RichString_appendnAscii(str, nextUnitColor, buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%03u%c \", (unsigned int)number % 1000, unitPrefixes[i]);\n   }\n   RichString_appendnAscii(str, color, buffer, len);\n   return;\n\ninvalidNumber:\n   if (coloring)\n      color = CRT_colors[PROCESS_SHADOW];\n\n   RichString_appendAscii(str, color, \"  N/A \");\n}\n\nvoid Row_printBytes(RichString* str, unsigned long long number, bool coloring) {\n   if (number == ULLONG_MAX)\n      Row_printKBytes(str, ULLONG_MAX, coloring);\n   else\n      Row_printKBytes(str, number / ONE_K, coloring);\n}\n\nvoid Row_printCount(RichString* str, unsigned long long number, bool coloring) {\n   char buffer[13];\n\n   int largeNumberColor = coloring ? CRT_colors[LARGE_NUMBER] : CRT_colors[PROCESS];\n   int megabytesColor = coloring ? CRT_colors[PROCESS_MEGABYTES] : CRT_colors[PROCESS];\n   int shadowColor = coloring ? CRT_colors[PROCESS_SHADOW] : CRT_colors[PROCESS];\n   int baseColor = CRT_colors[PROCESS];\n\n   if (number == ULLONG_MAX) {\n      RichString_appendAscii(str, CRT_colors[PROCESS_SHADOW], \"        N/A \");\n   } else if (number >= 100000LL * ONE_DECIMAL_T) {\n      xSnprintf(buffer, sizeof(buffer), \"%11llu \", number / ONE_DECIMAL_G);\n      RichString_appendnAscii(str, largeNumberColor, buffer, 12);\n   } else if (number >= 100LL * ONE_DECIMAL_T) {\n      xSnprintf(buffer, sizeof(buffer), \"%11llu \", number / ONE_DECIMAL_M);\n      RichString_appendnAscii(str, largeNumberColor, buffer, 8);\n      RichString_appendnAscii(str, megabytesColor, buffer + 8, 4);\n   } else if (number >= 10LL * ONE_DECIMAL_G) {\n      xSnprintf(buffer, sizeof(buffer), \"%11llu \", number / ONE_DECIMAL_K);\n      RichString_appendnAscii(str, largeNumberColor, buffer, 5);\n      RichString_appendnAscii(str, megabytesColor, buffer + 5, 3);\n      RichString_appendnAscii(str, baseColor, buffer + 8, 4);\n   } else {\n      xSnprintf(buffer, sizeof(buffer), \"%11llu \", number);\n      RichString_appendnAscii(str, largeNumberColor, buffer, 2);\n      RichString_appendnAscii(str, megabytesColor, buffer + 2, 3);\n      RichString_appendnAscii(str, baseColor, buffer + 5, 3);\n      RichString_appendnAscii(str, shadowColor, buffer + 8, 4);\n   }\n}\n\nvoid Row_printTime(RichString* str, unsigned long long totalHundredths, bool coloring) {\n   char buffer[10];\n   int len;\n\n   if (totalHundredths == 0) {\n      int shadowColor = coloring ? CRT_colors[PROCESS_SHADOW] : CRT_colors[PROCESS];\n\n      RichString_appendAscii(str, shadowColor, \" 0:00.00 \");\n      return;\n   }\n\n   int yearColor = coloring ? CRT_colors[LARGE_NUMBER]      : CRT_colors[PROCESS];\n   int dayColor  = coloring ? CRT_colors[PROCESS_GIGABYTES] : CRT_colors[PROCESS];\n   int hourColor = coloring ? CRT_colors[PROCESS_MEGABYTES] : CRT_colors[PROCESS];\n   int baseColor = CRT_colors[PROCESS];\n\n   unsigned long long totalSeconds = totalHundredths / 100;\n   unsigned long long totalMinutes = totalSeconds / 60;\n   unsigned long long totalHours = totalMinutes / 60;\n   unsigned int seconds = totalSeconds % 60;\n   unsigned int minutes = totalMinutes % 60;\n\n   if (totalMinutes < 60) {\n      unsigned int hundredths = totalHundredths % 100;\n      len = xSnprintf(buffer, sizeof(buffer), \"%2u:%02u.%02u \", (unsigned int)totalMinutes, seconds, hundredths);\n      RichString_appendnAscii(str, baseColor, buffer, len);\n      return;\n   }\n   if (totalHours < 24) {\n      len = xSnprintf(buffer, sizeof(buffer), \"%2uh\", (unsigned int)totalHours);\n      RichString_appendnAscii(str, hourColor, buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%02u:%02u \", minutes, seconds);\n      RichString_appendnAscii(str, baseColor, buffer, len);\n      return;\n   }\n\n   unsigned long long totalDays = totalHours / 24;\n   unsigned int hours = totalHours % 24;\n   if (totalDays < 10) {\n      len = xSnprintf(buffer, sizeof(buffer), \"%1ud\", (unsigned int)totalDays);\n      RichString_appendnAscii(str, dayColor, buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%02uh\", hours);\n      RichString_appendnAscii(str, hourColor, buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%02um \", minutes);\n      RichString_appendnAscii(str, baseColor, buffer, len);\n      return;\n   }\n   if (totalDays < /* Ignore leap years */365) {\n      len = xSnprintf(buffer, sizeof(buffer), \"%4ud\", (unsigned int)totalDays);\n      RichString_appendnAscii(str, dayColor, buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%02uh \", hours);\n      RichString_appendnAscii(str, hourColor, buffer, len);\n      return;\n   }\n\n   unsigned long long years = totalDays / 365;\n   unsigned int days = totalDays % 365;\n   if (years < 1000) {\n      len = xSnprintf(buffer, sizeof(buffer), \"%3uy\", (unsigned int)years);\n      RichString_appendnAscii(str, yearColor, buffer, len);\n      len = xSnprintf(buffer, sizeof(buffer), \"%03ud \", days);\n      RichString_appendnAscii(str, dayColor, buffer, len);\n   } else if (years < 10000000) {\n      len = xSnprintf(buffer, sizeof(buffer), \"%7luy \", (unsigned long)years);\n      RichString_appendnAscii(str, yearColor, buffer, len);\n   } else {\n      RichString_appendAscii(str, yearColor, \"eternity \");\n   }\n}\n\nvoid Row_printNanoseconds(RichString* str, unsigned long long totalNanoseconds, bool coloring) {\n   if (totalNanoseconds == 0) {\n      int shadowColor = coloring ? CRT_colors[PROCESS_SHADOW] : CRT_colors[PROCESS];\n\n      RichString_appendAscii(str, shadowColor, \"     0ns \");\n      return;\n   }\n\n   char buffer[10];\n   int len;\n   int baseColor = CRT_colors[PROCESS];\n\n   if (totalNanoseconds < 1000000) {\n      len = xSnprintf(buffer, sizeof(buffer), \"%6luns \", (unsigned long)totalNanoseconds);\n      RichString_appendnAscii(str, baseColor, buffer, len);\n      return;\n   }\n\n   unsigned long long totalMicroseconds = totalNanoseconds / 1000;\n   if (totalMicroseconds < 1000000) {\n      len = xSnprintf(buffer, sizeof(buffer), \".%06lus \", (unsigned long)totalMicroseconds);\n      RichString_appendnAscii(str, baseColor, buffer, len);\n      return;\n   }\n\n   unsigned long long totalSeconds = totalMicroseconds / 1000000;\n   unsigned long microseconds = totalMicroseconds % 1000000;\n   if (totalSeconds < 60) {\n      int width = 5;\n      unsigned long fraction = microseconds / 10;\n      if (totalSeconds >= 10) {\n         width--;\n         fraction /= 10;\n      }\n      len = xSnprintf(buffer, sizeof(buffer), \"%u.%0*lus \", (unsigned int)totalSeconds, width, fraction);\n      RichString_appendnAscii(str, baseColor, buffer, len);\n      return;\n   }\n\n   if (totalSeconds < 600) {\n      unsigned int minutes = totalSeconds / 60;\n      unsigned int seconds = totalSeconds % 60;\n      unsigned int milliseconds = microseconds / 1000;\n      len = xSnprintf(buffer, sizeof(buffer), \"%u:%02u.%03u \", minutes, seconds, milliseconds);\n      RichString_appendnAscii(str, baseColor, buffer, len);\n      return;\n   }\n\n   unsigned long long totalHundredths = totalMicroseconds / 1000 / 10;\n   Row_printTime(str, totalHundredths, coloring);\n}\n\nvoid Row_printRate(RichString* str, double rate, bool coloring) {\n   char buffer[16];\n\n   int largeNumberColor = CRT_colors[LARGE_NUMBER];\n   int megabytesColor = CRT_colors[PROCESS_MEGABYTES];\n   int shadowColor = CRT_colors[PROCESS_SHADOW];\n   int baseColor = CRT_colors[PROCESS];\n\n   if (!coloring) {\n      largeNumberColor = CRT_colors[PROCESS];\n      megabytesColor = CRT_colors[PROCESS];\n   }\n\n   if (!isNonnegative(rate)) {\n      RichString_appendAscii(str, shadowColor, \"        N/A \");\n   } else if (rate < 0.005) {\n      int len = snprintf(buffer, sizeof(buffer), \"%7.2f B/s \", rate);\n      RichString_appendnAscii(str, shadowColor, buffer, len);\n   } else if (rate < ONE_K) {\n      int len = snprintf(buffer, sizeof(buffer), \"%7.2f B/s \", rate);\n      RichString_appendnAscii(str, baseColor, buffer, len);\n   } else if (rate < ONE_M) {\n      int len = snprintf(buffer, sizeof(buffer), \"%7.2f K/s \", rate / ONE_K);\n      RichString_appendnAscii(str, baseColor, buffer, len);\n   } else if (rate < ONE_G) {\n      int len = snprintf(buffer, sizeof(buffer), \"%7.2f M/s \", rate / ONE_M);\n      RichString_appendnAscii(str, megabytesColor, buffer, len);\n   } else if (rate < ONE_T) {\n      int len = snprintf(buffer, sizeof(buffer), \"%7.2f G/s \", rate / ONE_G);\n      RichString_appendnAscii(str, largeNumberColor, buffer, len);\n   } else if (rate < ONE_P) {\n      int len = snprintf(buffer, sizeof(buffer), \"%7.2f T/s \", rate / ONE_T);\n      RichString_appendnAscii(str, largeNumberColor, buffer, len);\n   } else {\n      int len = snprintf(buffer, sizeof(buffer), \"%7.2f P/s \", rate / ONE_P);\n      RichString_appendnAscii(str, largeNumberColor, buffer, len);\n   }\n}\n\nvoid Row_printLeftAlignedField(RichString* str, int attr, const char* content, unsigned int width) {\n   int columns = width;\n   RichString_appendnWideColumns(str, attr, content, strlen(content), &columns);\n   RichString_appendChr(str, attr, ' ', width + 1 - columns);\n}\n\nint Row_printPercentage(float val, char* buffer, size_t n, uint8_t width, int* attr) {\n   assert(n >= 6 && width >= 4 && \"Invalid width in Row_printPercentage()\");\n   // truncate in favour of abort in xSnprintf()\n   width = (uint8_t)CLAMP(width, 4, n - 2);\n   assert(width < n - 1 && \"Insufficient space to print column\");\n\n   if (isNonnegative(val)) {\n      if (val < 0.05F)\n         *attr = CRT_colors[PROCESS_SHADOW];\n      else if (val >= 99.9F)\n         *attr = CRT_colors[PROCESS_MEGABYTES];\n\n      int precision = 1;\n\n      // Display \"val\" as \"100\" for columns like \"MEM%\".\n      if (width == 4 && val > 99.9F) {\n         precision = 0;\n         val = 100.0F;\n      }\n\n      return xSnprintf(buffer, n, \"%*.*f \", width, precision, val);\n   }\n\n   *attr = CRT_colors[PROCESS_SHADOW];\n   return xSnprintf(buffer, n, \"%*.*s \", width, width, \"N/A\");\n}\n\nvoid Row_toggleTag(Row* this) {\n   this->tag = !this->tag;\n}\n\nint Row_compare(const void* v1, const void* v2) {\n   const Row* r1 = (const Row*)v1;\n   const Row* r2 = (const Row*)v2;\n\n   return SPACESHIP_NUMBER(r1->id, r2->id);\n}\n\nint Row_compareByParent_Base(const void* v1, const void* v2) {\n   const Row* r1 = (const Row*)v1;\n   const Row* r2 = (const Row*)v2;\n\n   int result = SPACESHIP_NUMBER(\n      r1->isRoot ? 0 : Row_getGroupOrParent(r1),\n      r2->isRoot ? 0 : Row_getGroupOrParent(r2)\n   );\n\n   if (result != 0)\n      return result;\n\n   return Row_compare(v1, v2);\n}\n\nconst RowClass Row_class = {\n   .super = {\n      .extends = Class(Object),\n      .compare = Row_compare\n   },\n};\n"
        },
        {
          "name": "Row.h",
          "type": "blob",
          "size": 5.6005859375,
          "content": "#ifndef HEADER_Row\n#define HEADER_Row\n/*\nhtop - Row.h\n(C) 2004-2015 Hisham H. Muhammad\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <sys/types.h>\n\n#include \"Object.h\"\n#include \"RichString.h\"\n#include \"RowField.h\"\n\n\nextern uint8_t Row_fieldWidths[LAST_RESERVED_FIELD];\n#define ROW_MIN_PID_DIGITS 5\n#define ROW_MAX_PID_DIGITS 19\n#define ROW_MIN_UID_DIGITS 5\n#define ROW_MAX_UID_DIGITS 20\nextern int Row_pidDigits;\nextern int Row_uidDigits;\n\nstruct Machine_;     // IWYU pragma: keep\nstruct Settings_;    // IWYU pragma: keep\nstruct Table_;       // IWYU pragma: keep\n\n/* Class representing entities (such as processes) that can be\n * represented in a tabular form in the lower half of the htop\n * display. */\n\ntypedef struct Row_ {\n   /* Super object for emulated OOP */\n   Object super;\n\n   /* Pointer to quasi-global data */\n   const struct Machine_* host;\n\n   int id;\n   int group;\n   int parent;\n\n   /* Has no known parent */\n   bool isRoot;\n\n   /* Whether the row was tagged by the user */\n   bool tag;\n\n   /* Whether to display this row */\n   bool show;\n\n   /* Whether this row was shown last cycle */\n   bool wasShown;\n\n   /* Whether to show children of this row in tree-mode */\n   bool showChildren;\n\n   /* Whether the row was updated during the last scan */\n   bool updated;\n\n   /*\n    * Internal state for tree-mode.\n    */\n   int32_t indent;\n   unsigned int tree_depth;\n\n   /*\n    * Internal time counts for showing new and exited processes.\n    */\n   uint64_t seenStampMs;\n   uint64_t tombStampMs;\n} Row;\n\ntypedef Row* (*Row_New)(const struct Machine_*);\ntypedef void (*Row_WriteField)(const Row*, RichString*, RowField);\ntypedef bool (*Row_IsHighlighted)(const Row*);\ntypedef bool (*Row_IsVisible)(const Row*, const struct Table_*);\ntypedef bool (*Row_MatchesFilter)(const Row*, const struct Table_*);\ntypedef const char* (*Row_SortKeyString)(Row*);\ntypedef int (*Row_CompareByParent)(const Row*, const Row*);\n\nint Row_compare(const void* v1, const void* v2);\n\ntypedef struct RowClass_ {\n   const ObjectClass super;\n   const Row_IsHighlighted isHighlighted;\n   const Row_IsVisible isVisible;\n   const Row_WriteField writeField;\n   const Row_MatchesFilter matchesFilter;\n   const Row_SortKeyString sortKeyString;\n   const Row_CompareByParent compareByParent;\n} RowClass;\n\n#define As_Row(this_)  ((const RowClass*)((this_)->super.klass))\n\n#define Row_isHighlighted(r_)  (As_Row(r_)->isHighlighted ? (As_Row(r_)->isHighlighted(r_)) : false)\n#define Row_isVisible(r_, t_)  (As_Row(r_)->isVisible ? (As_Row(r_)->isVisible(r_, t_)) : true)\n#define Row_matchesFilter(r_, t_)  (As_Row(r_)->matchesFilter ? (As_Row(r_)->matchesFilter(r_, t_)) : false)\n#define Row_sortKeyString(r_)  (As_Row(r_)->sortKeyString ? (As_Row(r_)->sortKeyString(r_)) : \"\")\n#define Row_compareByParent(r1_, r2_)  (As_Row(r1_)->compareByParent ? (As_Row(r1_)->compareByParent(r1_, r2_)) : Row_compareByParent_Base(r1_, r2_))\n\n#define ONE_K 1024UL\n#define ONE_M (ONE_K * ONE_K)\n#define ONE_G (ONE_M * ONE_K)\n#define ONE_T (1ULL * ONE_G * ONE_K)\n#define ONE_P (1ULL * ONE_T * ONE_K)\n\n#define ONE_DECIMAL_K 1000UL\n#define ONE_DECIMAL_M (ONE_DECIMAL_K * ONE_DECIMAL_K)\n#define ONE_DECIMAL_G (ONE_DECIMAL_M * ONE_DECIMAL_K)\n#define ONE_DECIMAL_T (1ULL * ONE_DECIMAL_G * ONE_DECIMAL_K)\n#define ONE_DECIMAL_P (1ULL * ONE_DECIMAL_T * ONE_DECIMAL_K)\n\nextern const RowClass Row_class;\n\nvoid Row_init(Row* this, const struct Machine_* host);\n\nvoid Row_done(Row* this);\n\nvoid Row_display(const Object* cast, RichString* out);\n\nvoid Row_toggleTag(Row* this);\n\nvoid Row_resetFieldWidths(void);\n\nvoid Row_updateFieldWidth(RowField key, size_t width);\n\nvoid Row_printLeftAlignedField(RichString* str, int attr, const char* content, unsigned int width);\n\nconst char* RowField_alignedTitle(const struct Settings_* settings, RowField field);\n\nRowField RowField_keyAt(const struct Settings_* settings, int at);\n\n/* Sets the size of the PID column based on the passed PID */\nvoid Row_setPidColumnWidth(pid_t maxPid);\n\n/* Sets the size of the UID column based on the passed UID */\nvoid Row_setUidColumnWidth(uid_t maxUid);\n\n/* Takes number in kibibytes (base 1024). Prints 6 columns. */\nvoid Row_printKBytes(RichString* str, unsigned long long number, bool coloring);\n\n/* Takes number in bytes (base 1024). Prints 6 columns. */\nvoid Row_printBytes(RichString* str, unsigned long long number, bool coloring);\n\n/* Takes number as count (base 1000). Prints 12 columns. */\nvoid Row_printCount(RichString* str, unsigned long long number, bool coloring);\n\n/* Takes time in hundredths of a seconds. Prints 9 columns. */\nvoid Row_printTime(RichString* str, unsigned long long totalHundredths, bool coloring);\n\n/* Takes time in nanoseconds. Prints 9 columns. */\nvoid Row_printNanoseconds(RichString* str, unsigned long long totalNanoseconds, bool coloring);\n\n/* Takes rate in bare unit (base 1024) per second. Prints 12 columns. */\nvoid Row_printRate(RichString* str, double rate, bool coloring);\n\nint Row_printPercentage(float val, char* buffer, size_t n, uint8_t width, int* attr);\n\nstatic inline int Row_idEqualCompare(const void* v1, const void* v2) {\n   const int p1 = ((const Row*)v1)->id;\n   const int p2 = ((const Row*)v2)->id;\n   return p1 != p2; /* return zero when equal */\n}\n\n/* Routines used primarily with the tree view */\nstatic inline int Row_getGroupOrParent(const Row* this) {\n   return this->group == this->id ? this->parent : this->group;\n}\n\nstatic inline bool Row_isChildOf(const Row* this, int id) {\n   return id == Row_getGroupOrParent(this);\n}\n\nint Row_compareByParent_Base(const void* v1, const void* v2);\n\n#endif\n"
        },
        {
          "name": "RowField.h",
          "type": "blob",
          "size": 1.1474609375,
          "content": "#ifndef HEADER_RowField\n#define HEADER_RowField\n/*\nhtop - RowField.h\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"ProcessField.h\" // platform-specific fields reserved for processes\n\n\ntypedef enum ReservedFields_ {\n   NULL_FIELD = 0,\n   PID = 1,\n   COMM = 2,\n   STATE = 3,\n   PPID = 4,\n   PGRP = 5,\n   SESSION = 6,\n   TTY = 7,\n   TPGID = 8,\n   MINFLT = 10,\n   MAJFLT = 12,\n   PRIORITY = 18,\n   NICE = 19,\n   STARTTIME = 21,\n   PROCESSOR = 38,\n   M_VIRT = 39,\n   M_RESIDENT = 40,\n   ST_UID = 46,\n   PERCENT_CPU = 47,\n   PERCENT_MEM = 48,\n   USER = 49,\n   TIME = 50,\n   NLWP = 51,\n   TGID = 52,\n   PERCENT_NORM_CPU = 53,\n   ELAPSED = 54,\n   SCHEDULERPOLICY = 55,\n   PROC_COMM = 124,\n   PROC_EXE = 125,\n   CWD = 126,\n\n   /* Platform specific fields, defined in ${platform}/ProcessField.h */\n   PLATFORM_PROCESS_FIELDS\n\n   /* Do not add new fields after this entry (dynamic entries follow) */\n   LAST_RESERVED_FIELD\n} ReservedFields;\n\n/* Follow ReservedField entries with dynamic fields defined at runtime */\n#define ROW_DYNAMIC_FIELDS LAST_RESERVED_FIELD\ntypedef int32_t RowField;\n\n#endif\n"
        },
        {
          "name": "Scheduling.c",
          "type": "blob",
          "size": 4.181640625,
          "content": "/*\nhtop - Scheduling.c\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Scheduling.h\"\n\n#ifdef SCHEDULER_SUPPORT\n\n#include <assert.h>\n#include <stddef.h>\n\n#include \"FunctionBar.h\"\n#include \"ListItem.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"Panel.h\"\n#include \"XUtils.h\"\n\n\nstatic const SchedulingPolicy policies[] = {\n   [SCHED_OTHER] = { \"Other\",      SCHED_OTHER, false },\n#ifdef SCHED_BATCH\n   [SCHED_BATCH] = { \"Batch\",      SCHED_BATCH, false },\n#endif\n#ifdef SCHED_IDLE\n   [SCHED_IDLE]  = { \"Idle\",       SCHED_IDLE,  false },\n#endif\n   [SCHED_FIFO]  = { \"FiFo\",       SCHED_FIFO,  true },\n   [SCHED_RR]    = { \"RoundRobin\", SCHED_RR,    true },\n};\n\n#ifdef SCHED_RESET_ON_FORK\nstatic bool reset_on_fork = false;\n#endif\n\n\nPanel* Scheduling_newPolicyPanel(int preSelectedPolicy) {\n   Panel* this = Panel_new(0, 0, 0, 0, Class(ListItem), true, FunctionBar_newEnterEsc(\"Select \", \"Cancel \"));\n   Panel_setHeader(this, \"New policy:\");\n\n#ifdef SCHED_RESET_ON_FORK\n   Panel_add(this, (Object*) ListItem_new(reset_on_fork ? \"Reset on fork: on\" : \"Reset on fork: off\", -1));\n#endif\n\n   for (unsigned i = 0; i < ARRAYSIZE(policies); i++) {\n      if (!policies[i].name)\n         continue;\n\n      Panel_add(this, (Object*) ListItem_new(policies[i].name, policies[i].id));\n      if (policies[i].id == preSelectedPolicy)\n         Panel_setSelected(this, i);\n   }\n\n   return this;\n}\n\nvoid Scheduling_togglePolicyPanelResetOnFork(Panel* schedPanel) {\n#ifdef SCHED_RESET_ON_FORK\n   reset_on_fork = !reset_on_fork;\n\n   ListItem* item = (ListItem*) Panel_get(schedPanel, 0);\n\n   free_and_xStrdup(&item->value, reset_on_fork ? \"Reset on fork: on\" : \"Reset on fork: off\");\n#else\n   (void)schedPanel;\n#endif\n}\n\nPanel* Scheduling_newPriorityPanel(int policy, int preSelectedPriority) {\n   if (policy < 0 || (unsigned)policy >= ARRAYSIZE(policies) || policies[policy].name == NULL)\n      return NULL;\n\n   if (!policies[policy].prioritySupport)\n      return NULL;\n\n   int min = sched_get_priority_min(policy);\n   if (min < 0)\n      return NULL;\n   int max = sched_get_priority_max(policy);\n   if (max < 0 )\n      return NULL;\n\n   Panel* this = Panel_new(0, 0, 0, 0, Class(ListItem), true, FunctionBar_newEnterEsc(\"Select \", \"Cancel \"));\n   Panel_setHeader(this, \"Priority:\");\n\n   for (int i = min; i <= max; i++) {\n      char buf[16];\n      xSnprintf(buf, sizeof(buf), \"%d\", i);\n      Panel_add(this, (Object*) ListItem_new(buf, i));\n      if (i == preSelectedPriority)\n         Panel_setSelected(this, i);\n   }\n\n   return this;\n}\n\nstatic bool Scheduling_setPolicy(Process* p, Arg arg) {\n   const SchedulingArg* sarg = arg.v;\n   int policy = sarg->policy;\n\n   assert(policy >= 0);\n   assert((unsigned)policy < ARRAYSIZE(policies));\n   assert(policies[policy].name);\n\n   const struct sched_param param = { .sched_priority = policies[policy].prioritySupport ? sarg->priority : 0 };\n\n   #ifdef SCHED_RESET_ON_FORK\n   if (reset_on_fork)\n      policy &= SCHED_RESET_ON_FORK;\n   #endif\n\n   int r = sched_setscheduler(Process_getPid(p), policy, &param);\n\n   /* POSIX says on success the previous scheduling policy should be returned,\n    * but Linux always returns 0. */\n   return r != -1;\n}\n\nbool Scheduling_rowSetPolicy(Row* row, Arg arg) {\n   Process* p = (Process*) row;\n   assert(Object_isA((const Object*) p, (const ObjectClass*) &Process_class));\n   return Scheduling_setPolicy(p, arg);\n}\n\nconst char* Scheduling_formatPolicy(int policy) {\n#ifdef SCHED_RESET_ON_FORK\n   policy = policy & ~SCHED_RESET_ON_FORK;\n#endif\n\n   switch (policy) {\n      case SCHED_OTHER:\n         return \"OTHER\";\n      case SCHED_FIFO:\n         return \"FIFO\";\n      case SCHED_RR:\n         return \"RR\";\n#ifdef SCHED_BATCH\n      case SCHED_BATCH:\n         return \"BATCH\";\n#endif\n#ifdef SCHED_IDLE\n      case SCHED_IDLE:\n         return \"IDLE\";\n#endif\n#ifdef SCHED_DEADLINE\n      case SCHED_DEADLINE:\n         return \"EDF\";\n#endif\n      default:\n         return \"???\";\n   }\n}\n\n/*\n * Gather scheduling policy (thread-specific data)\n */\nvoid Scheduling_readProcessPolicy(Process* proc) {\n   proc->scheduling_policy = sched_getscheduler(Process_getPid(proc));\n}\n#endif  /* SCHEDULER_SUPPORT */\n"
        },
        {
          "name": "Scheduling.h",
          "type": "blob",
          "size": 1.05078125,
          "content": "#ifndef HEADER_Scheduling\n#define HEADER_Scheduling\n/*\nhtop - Scheduling.h\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <sched.h>\n#include <stdbool.h>\n\n#include \"Object.h\"\n#include \"Panel.h\"\n#include \"Process.h\"\n#include \"Row.h\"\n\n\n#if defined(HAVE_SCHED_SETSCHEDULER) && defined(HAVE_SCHED_GETSCHEDULER)\n#define SCHEDULER_SUPPORT\n\ntypedef struct {\n   const char* name;\n   int id;\n   bool prioritySupport;\n} SchedulingPolicy;\n\n#define SCHEDULINGPANEL_INITSELECTEDPOLICY SCHED_OTHER\n#define SCHEDULINGPANEL_INITSELECTEDPRIORITY 50\n\nPanel* Scheduling_newPolicyPanel(int preSelectedPolicy);\nvoid Scheduling_togglePolicyPanelResetOnFork(Panel* schedPanel);\n\nPanel* Scheduling_newPriorityPanel(int policy, int preSelectedPriority);\n\n\ntypedef struct {\n   int policy;\n   int priority;\n} SchedulingArg;\n\nbool Scheduling_rowSetPolicy(Row* proc, Arg arg);\n\nconst char* Scheduling_formatPolicy(int policy);\n\nvoid Scheduling_readProcessPolicy(Process* proc);\n\n#endif\n\n#endif  /* HEADER_Scheduling */\n"
        },
        {
          "name": "ScreenManager.c",
          "type": "blob",
          "size": 12.306640625,
          "content": "/*\nhtop - ScreenManager.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"ScreenManager.h\"\n\n#include <assert.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/time.h>\n\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Machine.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"Process.h\"\n#include \"ProvideCurses.h\"\n#include \"Settings.h\"\n#include \"Table.h\"\n#include \"XUtils.h\"\n\n\nScreenManager* ScreenManager_new(Header* header, Machine* host, State* state, bool owner) {\n   ScreenManager* this;\n   this = xMalloc(sizeof(ScreenManager));\n   this->x1 = 0;\n   this->y1 = 0;\n   this->x2 = 0;\n   this->y2 = -1;\n   this->panels = Vector_new(Class(Panel), owner, DEFAULT_SIZE);\n   this->panelCount = 0;\n   this->header = header;\n   this->host = host;\n   this->state = state;\n   this->allowFocusChange = true;\n   return this;\n}\n\nvoid ScreenManager_delete(ScreenManager* this) {\n   Vector_delete(this->panels);\n   free(this);\n}\n\ninline int ScreenManager_size(const ScreenManager* this) {\n   return this->panelCount;\n}\n\nvoid ScreenManager_add(ScreenManager* this, Panel* item, int size) {\n   ScreenManager_insert(this, item, size, Vector_size(this->panels));\n}\n\nstatic int header_height(const ScreenManager* this) {\n   if (this->state->hideMeters)\n      return 0;\n\n   if (this->header)\n      return this->header->height;\n\n   return 0;\n}\n\nvoid ScreenManager_insert(ScreenManager* this, Panel* item, int size, int idx) {\n   int lastX = 0;\n   if (idx > 0) {\n      const Panel* last = (const Panel*) Vector_get(this->panels, idx - 1);\n      lastX = last->x + last->w + 1;\n   }\n   int height = LINES - this->y1 - header_height(this) + this->y2;\n   if (size <= 0) {\n      size = COLS - this->x1 + this->x2 - lastX;\n   }\n   Panel_resize(item, size, height);\n   Panel_move(item, lastX, this->y1 + header_height(this));\n   if (idx < this->panelCount) {\n      for (int i =  idx + 1; i <= this->panelCount; i++) {\n         Panel* p = (Panel*) Vector_get(this->panels, i);\n         Panel_move(p, p->x + size, p->y);\n      }\n   }\n   Vector_insert(this->panels, idx, item);\n   item->needsRedraw = true;\n   this->panelCount++;\n}\n\nPanel* ScreenManager_remove(ScreenManager* this, int idx) {\n   assert(this->panelCount > idx);\n   int w = ((Panel*) Vector_get(this->panels, idx))->w;\n   Panel* panel = (Panel*) Vector_remove(this->panels, idx);\n   this->panelCount--;\n   if (idx < this->panelCount) {\n      for (int i = idx; i < this->panelCount; i++) {\n         Panel* p = (Panel*) Vector_get(this->panels, i);\n         Panel_move(p, p->x - w, p->y);\n      }\n   }\n   return panel;\n}\n\nvoid ScreenManager_resize(ScreenManager* this) {\n   int y1_header = this->y1 + header_height(this);\n   int panels = this->panelCount;\n   int lastX = 0;\n   for (int i = 0; i < panels - 1; i++) {\n      Panel* panel = (Panel*) Vector_get(this->panels, i);\n      Panel_resize(panel, panel->w, LINES - y1_header + this->y2);\n      Panel_move(panel, lastX, y1_header);\n      lastX = panel->x + panel->w + 1;\n   }\n   Panel* panel = (Panel*) Vector_get(this->panels, panels - 1);\n   Panel_resize(panel, COLS - this->x1 + this->x2 - lastX, LINES - y1_header + this->y2);\n   Panel_move(panel, lastX, y1_header);\n}\n\nstatic void checkRecalculation(ScreenManager* this, double* oldTime, int* sortTimeout, bool* redraw, bool* rescan, bool* timedOut, bool* force_redraw) {\n   Machine* host = this->host;\n\n   Platform_gettime_realtime(&host->realtime, &host->realtimeMs);\n   double newTime = ((double)host->realtime.tv_sec * 10) + ((double)host->realtime.tv_usec / 100000);\n\n   *timedOut = (newTime - *oldTime > host->settings->delay);\n   *rescan |= *timedOut;\n\n   if (newTime < *oldTime) {\n      *rescan = true; // clock was adjusted?\n   }\n\n   if (*rescan) {\n      *oldTime = newTime;\n      int oldUidDigits = Process_uidDigits;\n      if (!this->state->pauseUpdate && (*sortTimeout == 0 || host->settings->ss->treeView)) {\n         host->activeTable->needsSort = true;\n         *sortTimeout = 1;\n      }\n      // sample current values for system metrics and processes if not paused\n      Machine_scan(host);\n      if (!this->state->pauseUpdate)\n         Machine_scanTables(host);\n\n      // always update header, especially to avoid gaps in graph meters\n      Header_updateData(this->header);\n      // force redraw if the number of UID digits was changed\n      if (Process_uidDigits != oldUidDigits) {\n         *force_redraw = true;\n      }\n      *redraw = true;\n   }\n   if (*redraw) {\n      Table_rebuildPanel(host->activeTable);\n      if (!this->state->hideMeters)\n         Header_draw(this->header);\n   }\n   *rescan = false;\n}\n\nstatic inline bool drawTab(const int* y, int* x, int l, const char* name, bool cur) {\n   attrset(CRT_colors[cur ? SCREENS_CUR_BORDER : SCREENS_OTH_BORDER]);\n   mvaddch(*y, *x, '[');\n   (*x)++;\n   if (*x >= l)\n      return false;\n   int nameLen = strlen(name);\n   int n = MINIMUM(l - *x, nameLen);\n   attrset(CRT_colors[cur ? SCREENS_CUR_TEXT : SCREENS_OTH_TEXT]);\n   mvaddnstr(*y, *x, name, n);\n   *x += n;\n   if (*x >= l)\n      return false;\n   attrset(CRT_colors[cur ? SCREENS_CUR_BORDER : SCREENS_OTH_BORDER]);\n   mvaddch(*y, *x, ']');\n   *x += 2;\n   if (*x >= l)\n      return false;\n   return true;\n}\n\nstatic void ScreenManager_drawScreenTabs(ScreenManager* this) {\n   Settings* settings = this->host->settings;\n   ScreenSettings** screens = settings->screens;\n   int cur = settings->ssIndex;\n   int l = COLS;\n   Panel* panel = (Panel*) Vector_get(this->panels, 0);\n   int y = panel->y - 1;\n   int x = 2;\n\n   if (this->name) {\n      drawTab(&y, &x, l, this->name, true);\n      return;\n   }\n\n   for (int s = 0; screens[s]; s++) {\n      bool ok = drawTab(&y, &x, l, screens[s]->heading, s == cur);\n      if (!ok) {\n         break;\n      }\n   }\n   attrset(CRT_colors[RESET_COLOR]);\n}\n\nstatic void ScreenManager_drawPanels(ScreenManager* this, int focus, bool force_redraw) {\n   Settings* settings = this->host->settings;\n   if (settings->screenTabs) {\n      ScreenManager_drawScreenTabs(this);\n   }\n   const int nPanels = this->panelCount;\n   for (int i = 0; i < nPanels; i++) {\n      Panel* panel = (Panel*) Vector_get(this->panels, i);\n      Panel_draw(panel,\n                 force_redraw,\n                 i == focus,\n                 panel != (Panel*)this->state->mainPanel || !this->state->hideSelection,\n                 State_hideFunctionBar(this->state));\n      mvvline(panel->y, panel->x + panel->w, ' ', panel->h + (State_hideFunctionBar(this->state) ? 1 : 0));\n   }\n}\n\nvoid ScreenManager_run(ScreenManager* this, Panel** lastFocus, int* lastKey, const char* name) {\n   bool quit = false;\n   int focus = 0;\n\n   Panel* panelFocus = (Panel*) Vector_get(this->panels, focus);\n   Settings* settings = this->host->settings;\n\n   double oldTime = 0.0;\n\n   int ch = ERR;\n   int closeTimeout = 0;\n\n   bool timedOut = true;\n   bool redraw = true;\n   bool force_redraw = true;\n   bool rescan = false;\n   int sortTimeout = 0;\n   int resetSortTimeout = 5;\n\n   this->name = name;\n\n   while (!quit) {\n      if (this->header) {\n         checkRecalculation(this, &oldTime, &sortTimeout, &redraw, &rescan, &timedOut, &force_redraw);\n      }\n\n      if (redraw || force_redraw) {\n         ScreenManager_drawPanels(this, focus, force_redraw);\n         force_redraw = false;\n         if (this->host->iterationsRemaining != -1) {\n            if (!--this->host->iterationsRemaining) {\n               quit = true;\n               continue;\n            }\n         }\n      }\n\n      int prevCh = ch;\n      ch = Panel_getCh(panelFocus);\n\n      HandlerResult result = IGNORED;\n#ifdef HAVE_GETMOUSE\n      if (ch == KEY_MOUSE && settings->enableMouse) {\n         ch = ERR;\n         MEVENT mevent;\n         int ok = getmouse(&mevent);\n         if (ok == OK) {\n            if (mevent.bstate & BUTTON1_RELEASED) {\n               if (mevent.y == LINES - 1) {\n                  ch = FunctionBar_synthesizeEvent(panelFocus->currentBar, mevent.x);\n               } else {\n                  for (int i = 0; i < this->panelCount; i++) {\n                     Panel* panel = (Panel*) Vector_get(this->panels, i);\n                     if (mevent.x >= panel->x && mevent.x <= panel->x + panel->w) {\n                        if (mevent.y == panel->y) {\n                           ch = EVENT_HEADER_CLICK(mevent.x - panel->x);\n                           break;\n                        } else if (settings->screenTabs && mevent.y == panel->y - 1) {\n                           ch = EVENT_SCREEN_TAB_CLICK(mevent.x);\n                           break;\n                        } else if (mevent.y > panel->y && mevent.y <= panel->y + panel->h) {\n                           ch = KEY_MOUSE;\n                           if (panel == panelFocus || this->allowFocusChange) {\n                              focus = i;\n                              panelFocus = panel;\n                              const Object* oldSelection = Panel_getSelected(panel);\n                              Panel_setSelected(panel, mevent.y - panel->y + panel->scrollV - 1);\n                              if (Panel_getSelected(panel) == oldSelection) {\n                                 ch = KEY_RECLICK;\n                              }\n                           }\n                           break;\n                        }\n                     }\n                  }\n               }\n            #if NCURSES_MOUSE_VERSION > 1\n            } else if (mevent.bstate & BUTTON4_PRESSED) {\n               ch = KEY_WHEELUP;\n            } else if (mevent.bstate & BUTTON5_PRESSED) {\n               ch = KEY_WHEELDOWN;\n            #endif\n            }\n         }\n      }\n#endif\n      if (ch == ERR) {\n         if (sortTimeout > 0)\n            sortTimeout--;\n         if (prevCh == ch && !timedOut) {\n            closeTimeout++;\n            if (closeTimeout == 100) {\n               break;\n            }\n         } else {\n            closeTimeout = 0;\n         }\n         redraw = false;\n         continue;\n      }\n\n      switch (ch) {\n         case KEY_ALT('H'): ch = KEY_LEFT; break;\n         case KEY_ALT('J'): ch = KEY_DOWN; break;\n         case KEY_ALT('K'): ch = KEY_UP; break;\n         case KEY_ALT('L'): ch = KEY_RIGHT; break;\n      }\n\n      redraw = true;\n      if (Panel_eventHandlerFn(panelFocus)) {\n         result = Panel_eventHandler(panelFocus, ch);\n      }\n      if (result & SYNTH_KEY) {\n         ch = result >> 16;\n      }\n      if (result & REFRESH) {\n         sortTimeout = 0;\n      }\n      if (result & REDRAW) {\n         force_redraw = true;\n      }\n      if (result & RESIZE) {\n         ScreenManager_resize(this);\n         force_redraw = true;\n      }\n      if (result & RESCAN) {\n         rescan = true;\n         sortTimeout = 0;\n      }\n      if (result & HANDLED) {\n         continue;\n      } else if (result & BREAK_LOOP) {\n         quit = true;\n         continue;\n      }\n\n      switch (ch) {\n      case KEY_RESIZE:\n      {\n         ScreenManager_resize(this);\n         continue;\n      }\n      case KEY_FOCUS_IN:\n      case KEY_FOCUS_OUT:\n         break;\n      case KEY_LEFT:\n      case KEY_CTRL('B'):\n         if (this->panelCount < 2) {\n            goto defaultHandler;\n         }\n\n         if (!this->allowFocusChange) {\n            break;\n         }\n\ntryLeft:\n         if (focus > 0) {\n            focus--;\n         }\n\n         panelFocus = (Panel*) Vector_get(this->panels, focus);\n         if (Panel_size(panelFocus) == 0 && focus > 0) {\n            goto tryLeft;\n         }\n\n         break;\n      case KEY_RIGHT:\n      case KEY_CTRL('F'):\n      case 9:\n         if (this->panelCount < 2) {\n            goto defaultHandler;\n         }\n         if (!this->allowFocusChange) {\n            break;\n         }\n\ntryRight:\n         if (focus < this->panelCount - 1) {\n            focus++;\n         }\n\n         panelFocus = (Panel*) Vector_get(this->panels, focus);\n         if (Panel_size(panelFocus) == 0 && focus < this->panelCount - 1) {\n            goto tryRight;\n         }\n\n         break;\n      case '#':\n         this->state->hideMeters = !this->state->hideMeters;\n         ScreenManager_resize(this);\n         force_redraw = true;\n         break;\n      case 27:\n      case 'q':\n      case KEY_F(10):\n         quit = true;\n         continue;\n      default:\ndefaultHandler:\n         sortTimeout = resetSortTimeout;\n         Panel_onKey(panelFocus, ch);\n         break;\n      }\n   }\n\n   if (lastFocus) {\n      *lastFocus = panelFocus;\n   }\n\n   if (lastKey) {\n      *lastKey = ch;\n   }\n}\n"
        },
        {
          "name": "ScreenManager.h",
          "type": "blob",
          "size": 1.10546875,
          "content": "#ifndef HEADER_ScreenManager\n#define HEADER_ScreenManager\n/*\nhtop - ScreenManager.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Action.h\"\n#include \"Header.h\"\n#include \"Machine.h\"\n#include \"Panel.h\"\n#include \"Vector.h\"\n\n\ntypedef struct ScreenManager_ {\n   int x1;\n   int y1;\n   int x2;\n   int y2;\n   Vector* panels;\n   const char* name;\n   int panelCount;\n   Header* header;\n   Machine* host;\n   State* state;\n   bool allowFocusChange;\n} ScreenManager;\n\nScreenManager* ScreenManager_new(Header* header, Machine* host, State* state, bool owner);\n\nvoid ScreenManager_delete(ScreenManager* this);\n\nint ScreenManager_size(const ScreenManager* this);\n\nvoid ScreenManager_add(ScreenManager* this, Panel* item, int size);\n\nvoid ScreenManager_insert(ScreenManager* this, Panel* item, int size, int idx);\n\nPanel* ScreenManager_remove(ScreenManager* this, int idx);\n\nvoid ScreenManager_resize(ScreenManager* this);\n\nvoid ScreenManager_run(ScreenManager* this, Panel** lastFocus, int* lastKey, const char* name);\n\n#endif\n"
        },
        {
          "name": "ScreenTabsPanel.c",
          "type": "blob",
          "size": 10.994140625,
          "content": "/*\nhtop - ScreenTabsPanel.c\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"ScreenTabsPanel.h\"\n\n#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Hashtable.h\"\n#include \"Macros.h\"\n#include \"ProvideCurses.h\"\n#include \"Settings.h\"\n#include \"XUtils.h\"\n\n\nstatic HandlerResult ScreenNamesPanel_eventHandlerNormal(Panel* super, int ch);\n\nObjectClass ScreenTabListItem_class = {\n   .extends = Class(ListItem),\n   .display = ListItem_display,\n   .delete = ListItem_delete,\n   .compare = ListItem_compare\n};\n\nstatic void ScreenNamesPanel_fill(ScreenNamesPanel* this, DynamicScreen* ds) {\n   const Settings* settings = this->settings;\n   Panel* super = (Panel*) this;\n   Panel_prune(super);\n\n   for (unsigned int i = 0; i < settings->nScreens; i++) {\n      const ScreenSettings* ss = settings->screens[i];\n\n      if (ds == NULL) {\n         if (ss->dynamic != NULL)\n            continue;\n         /* built-in (processes, not dynamic) - e.g. Main or I/O */\n      } else {\n         if (ss->dynamic == NULL)\n            continue;\n         if (!String_eq(ds->name, ss->dynamic))\n            continue;\n         /* matching dynamic screen found, add it into the Panel */\n      }\n      Panel_add(super, (Object*) ListItem_new(ss->heading, i));\n   }\n\n   this->ds = ds;\n}\n\nstatic void ScreenTabsPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   ScreenTabsPanel* this = (ScreenTabsPanel*) object;\n\n   Panel_done(super);\n   free(this);\n}\n\nstatic HandlerResult ScreenTabsPanel_eventHandler(Panel* super, int ch) {\n   ScreenTabsPanel* const this = (ScreenTabsPanel* const) super;\n\n   HandlerResult result = IGNORED;\n\n   int selected = Panel_getSelectedIndex(super);\n   switch (ch) {\n      case EVENT_SET_SELECTED:\n         result = HANDLED;\n         break;\n      case KEY_F(5):\n      case KEY_CTRL('N'):\n         /* pass onto the Names panel for creating new screen */\n         return ScreenNamesPanel_eventHandlerNormal(&this->names->super, ch);\n      case KEY_UP:\n      case KEY_DOWN:\n      case KEY_NPAGE:\n      case KEY_PPAGE:\n      case KEY_HOME:\n      case KEY_END: {\n         int previous = selected;\n         Panel_onKey(super, ch);\n         selected = Panel_getSelectedIndex(super);\n         if (previous != selected)\n            result = HANDLED;\n         break;\n      }\n      default:\n         if (ch < 255 && isalpha(ch))\n            result = Panel_selectByTyping(super, ch);\n         if (result == BREAK_LOOP)\n            result = IGNORED;\n         break;\n   }\n\n   if (result == HANDLED) {\n      ScreenTabListItem* focus = (ScreenTabListItem*) Panel_getSelected(super);\n      if (focus) {\n         ScreenNamesPanel_fill(this->names, focus->ds);\n      }\n   }\n\n   return result;\n}\n\nPanelClass ScreenTabsPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = ScreenTabsPanel_delete,\n   },\n   .eventHandler = ScreenTabsPanel_eventHandler\n};\n\nstatic ScreenTabListItem* ScreenTabListItem_new(const char* value, DynamicScreen* ds) {\n   ScreenTabListItem* this = AllocThis(ScreenTabListItem);\n   ListItem_init((ListItem*)this, value, 0);\n   this->ds = ds;\n   return this;\n}\n\nstatic void addDynamicScreen(ATTR_UNUSED ht_key_t key, void* value, void* userdata) {\n   DynamicScreen* screen = (DynamicScreen*) value;\n   Panel* super = (Panel*) userdata;\n   const char* name = screen->heading ? screen->heading : screen->name;\n\n   Panel_add(super, (Object*) ScreenTabListItem_new(name, screen));\n}\n\nstatic const char* const ScreenTabsFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"New   \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nScreenTabsPanel* ScreenTabsPanel_new(Settings* settings) {\n   ScreenTabsPanel* this = AllocThis(ScreenTabsPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(ScreenTabsFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   this->settings = settings;\n   this->names = ScreenNamesPanel_new(settings);\n   super->cursorOn = false;\n   this->cursor = 0;\n   Panel_setHeader(super, \"Screen tabs\");\n\n   assert(settings->dynamicScreens != NULL);\n   Panel_add(super, (Object*) ScreenTabListItem_new(\"Processes\", NULL));\n   Hashtable_foreach(settings->dynamicScreens, addDynamicScreen, super);\n\n   return this;\n}\n\n// -------------\n\nObjectClass ScreenNameListItem_class = {\n   .extends = Class(ListItem),\n   .display = ListItem_display,\n   .delete = ListItem_delete,\n   .compare = ListItem_compare\n};\n\nScreenNameListItem* ScreenNameListItem_new(const char* value, ScreenSettings* ss) {\n   ScreenNameListItem* this = AllocThis(ScreenNameListItem);\n   ListItem_init((ListItem*)this, value, 0);\n   this->ss = ss;\n   return this;\n}\n\nstatic const char* const ScreenNamesFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"New   \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nstatic void ScreenNamesPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   ScreenNamesPanel* this = (ScreenNamesPanel*) object;\n\n   /* do not delete screen settings still in use */\n   int n = Panel_size(super);\n   for (int i = 0; i < n; i++) {\n      ScreenNameListItem* item = (ScreenNameListItem*) Panel_get(super, i);\n      item->ss = NULL;\n   }\n\n   /* during renaming the ListItem's value points to our static buffer */\n   if (this->renamingItem)\n      this->renamingItem->value = this->saved;\n\n   Panel_done(super);\n   free(this);\n}\n\nstatic void renameScreenSettings(ScreenNamesPanel* this, const ListItem* item) {\n   const ScreenNameListItem* nameItem = (const ScreenNameListItem*) item;\n\n   ScreenSettings* ss = nameItem->ss;\n   free_and_xStrdup(&ss->heading, item->value);\n\n   Settings* settings = this->settings;\n   settings->changed = true;\n   settings->lastUpdate++;\n}\n\nstatic HandlerResult ScreenNamesPanel_eventHandlerRenaming(Panel* super, int ch) {\n   ScreenNamesPanel* const this = (ScreenNamesPanel*) super;\n\n   if (ch >= 32 && ch < 127 && ch != '=') {\n      if (this->cursor < SCREEN_NAME_LEN - 1) {\n         this->buffer[this->cursor] = (char)ch;\n         this->cursor++;\n         super->selectedLen = strlen(this->buffer);\n         Panel_setCursorToSelection(super);\n      }\n\n      return HANDLED;\n   }\n\n   switch (ch) {\n      case 127:\n      case KEY_BACKSPACE:\n         if (this->cursor > 0) {\n            this->cursor--;\n            this->buffer[this->cursor] = '\\0';\n            super->selectedLen = strlen(this->buffer);\n            Panel_setCursorToSelection(super);\n         }\n         break;\n      case '\\n':\n      case '\\r':\n      case KEY_ENTER: {\n         ListItem* item = (ListItem*) Panel_getSelected(super);\n         if (!item)\n            break;\n         assert(item == this->renamingItem);\n         free(this->saved);\n         item->value = xStrdup(this->buffer);\n         this->renamingItem = NULL;\n         super->cursorOn = false;\n         Panel_setSelectionColor(super, PANEL_SELECTION_FOCUS);\n         renameScreenSettings(this, item);\n         break;\n      }\n      case 27: { // Esc\n         ListItem* item = (ListItem*) Panel_getSelected(super);\n         if (!item)\n            break;\n         assert(item == this->renamingItem);\n         item->value = this->saved;\n         this->renamingItem = NULL;\n         super->cursorOn = false;\n         Panel_setSelectionColor(super, PANEL_SELECTION_FOCUS);\n         break;\n      }\n   }\n\n   return HANDLED;\n}\n\nstatic void startRenaming(Panel* super) {\n   ScreenNamesPanel* const this = (ScreenNamesPanel*) super;\n\n   ListItem* item = (ListItem*) Panel_getSelected(super);\n   if (item == NULL)\n      return;\n\n   this->renamingItem = item;\n   super->cursorOn = true;\n   char* name = item->value;\n   this->saved = name;\n   strncpy(this->buffer, name, SCREEN_NAME_LEN);\n   this->buffer[SCREEN_NAME_LEN] = '\\0';\n   this->cursor = strlen(this->buffer);\n   item->value = this->buffer;\n   Panel_setSelectionColor(super, PANEL_EDIT);\n   super->selectedLen = strlen(this->buffer);\n   Panel_setCursorToSelection(super);\n}\n\nstatic void addNewScreen(Panel* super, DynamicScreen* ds) {\n   ScreenNamesPanel* const this = (ScreenNamesPanel*) super;\n   const char* name = \"New\";\n   ScreenSettings* ss = (ds != NULL) ? Settings_newDynamicScreen(this->settings, name, ds, NULL) : Settings_newScreen(this->settings, &(const ScreenDefaults) { .name = name, .columns = \"PID Command\", .sortKey = \"PID\" });\n   ScreenNameListItem* item = ScreenNameListItem_new(name, ss);\n   int idx = Panel_getSelectedIndex(super);\n   Panel_insert(super, idx + 1, (Object*) item);\n   Panel_setSelected(super, idx + 1);\n}\n\nstatic HandlerResult ScreenNamesPanel_eventHandlerNormal(Panel* super, int ch) {\n   ScreenNamesPanel* const this = (ScreenNamesPanel*) super;\n   ScreenNameListItem* oldFocus = (ScreenNameListItem*) Panel_getSelected(super);\n   HandlerResult result = IGNORED;\n\n   switch (ch) {\n      case '\\n':\n      case '\\r':\n      case KEY_ENTER:\n      case KEY_MOUSE:\n      case KEY_RECLICK:\n         Panel_setSelectionColor(super, PANEL_SELECTION_FOCUS);\n         result = HANDLED;\n         break;\n      case EVENT_SET_SELECTED:\n         result = HANDLED;\n         break;\n      case KEY_NPAGE:\n      case KEY_PPAGE:\n      case KEY_HOME:\n      case KEY_END:\n         Panel_onKey(super, ch);\n         break;\n      case KEY_F(5):\n      case KEY_CTRL('N'):\n         addNewScreen(super, this->ds);\n         startRenaming(super);\n         result = HANDLED;\n         break;\n      default:\n         if (ch < 255 && isalpha(ch))\n            result = Panel_selectByTyping(super, ch);\n         if (result == BREAK_LOOP)\n            result = IGNORED;\n         break;\n   }\n\n   ScreenNameListItem* newFocus = (ScreenNameListItem*) Panel_getSelected(super);\n   if (newFocus && oldFocus != newFocus)\n      result = HANDLED;\n\n   return result;\n}\n\nstatic HandlerResult ScreenNamesPanel_eventHandler(Panel* super, int ch) {\n   ScreenNamesPanel* const this = (ScreenNamesPanel*) super;\n\n   if (!this->renamingItem)\n      return ScreenNamesPanel_eventHandlerNormal(super, ch);\n   return ScreenNamesPanel_eventHandlerRenaming(super, ch);\n}\n\nPanelClass ScreenNamesPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = ScreenNamesPanel_delete\n   },\n   .eventHandler = ScreenNamesPanel_eventHandler\n};\n\nScreenNamesPanel* ScreenNamesPanel_new(Settings* settings) {\n   ScreenNamesPanel* this = AllocThis(ScreenNamesPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(ScreenNamesFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   this->settings = settings;\n   this->renamingItem = NULL;\n   memset(this->buffer, 0, sizeof(this->buffer));\n   this->ds = NULL;\n   this->saved = NULL;\n   this->cursor = 0;\n   super->cursorOn = false;\n   Panel_setHeader(super, \"Screens\");\n\n   for (unsigned int i = 0; i < settings->nScreens; i++) {\n      ScreenSettings* ss = settings->screens[i];\n      /* initially show only for Processes tabs (selected) */\n      if (ss->dynamic)\n         continue;\n      Panel_add(super, (Object*) ScreenNameListItem_new(ss->heading, ss));\n   }\n   return this;\n}\n"
        },
        {
          "name": "ScreenTabsPanel.h",
          "type": "blob",
          "size": 1.248046875,
          "content": "#ifndef HEADER_ScreenTabsPanel\n#define HEADER_ScreenTabsPanel\n/*\nhtop - ScreenTabsPanel.h\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"DynamicScreen.h\"\n#include \"ListItem.h\"\n#include \"Object.h\"\n#include \"Panel.h\"\n#include \"ScreensPanel.h\"\n#include \"ScreenManager.h\"\n#include \"Settings.h\"\n\n\ntypedef struct ScreenNamesPanel_ {\n   Panel super;\n\n   ScreenManager* scr;\n   Settings* settings;\n   char buffer[SCREEN_NAME_LEN + 1];\n   DynamicScreen* ds;\n   char* saved;\n   int cursor;\n   ListItem* renamingItem;\n} ScreenNamesPanel;\n\ntypedef struct ScreenNameListItem_ {\n   ListItem super;\n   ScreenSettings* ss;\n} ScreenNameListItem;\n\ntypedef struct ScreenTabsPanel_ {\n   Panel super;\n\n   ScreenManager* scr;\n   Settings* settings;\n   ScreenNamesPanel* names;\n   int cursor;\n} ScreenTabsPanel;\n\ntypedef struct ScreenTabListItem_ {\n   ListItem super;\n   DynamicScreen* ds;\n} ScreenTabListItem;\n\n\nScreenTabsPanel* ScreenTabsPanel_new(Settings* settings);\n\nextern ObjectClass ScreenNameListItem_class;\n\nScreenNameListItem* ScreenNameListItem_new(const char* value, ScreenSettings* ss);\n\nextern PanelClass ScreenNamesPanel_class;\n\nScreenNamesPanel* ScreenNamesPanel_new(Settings* settings);\n\n#endif\n"
        },
        {
          "name": "ScreensPanel.c",
          "type": "blob",
          "size": 9.736328125,
          "content": "/*\nhtop - ScreensPanel.c\n(C) 2004-2011 Hisham H. Muhammad\n(C) 2020-2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"ScreensPanel.h\"\n\n#include <assert.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"AvailableColumnsPanel.h\"\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Hashtable.h\"\n#include \"ProvideCurses.h\"\n#include \"Settings.h\"\n#include \"XUtils.h\"\n\n\nstatic void ScreenListItem_delete(Object* cast) {\n   ScreenListItem* this = (ScreenListItem*)cast;\n   if (this->ss) {\n      ScreenSettings_delete(this->ss);\n   }\n   ListItem_delete(cast);\n}\n\nObjectClass ScreenListItem_class = {\n   .extends = Class(ListItem),\n   .display = ListItem_display,\n   .delete = ScreenListItem_delete,\n   .compare = ListItem_compare\n};\n\nScreenListItem* ScreenListItem_new(const char* value, ScreenSettings* ss) {\n   ScreenListItem* this = AllocThis(ScreenListItem);\n   ListItem_init((ListItem*)this, value, 0);\n   this->ss = ss;\n   return this;\n}\n\nstatic const char* const ScreensFunctions[] = {\"      \", \"Rename\", \"      \", \"      \", \"New   \", \"      \", \"MoveUp\", \"MoveDn\", \"Remove\", \"Done  \", NULL};\nstatic const char* const DynamicFunctions[] = {\"      \", \"Rename\", \"      \", \"      \", \"      \", \"      \", \"MoveUp\", \"MoveDn\", \"Remove\", \"Done  \", NULL};\n\nstatic void ScreensPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n\n   /* do not delete screen settings still in use */\n   int n = Panel_size(super);\n   for (int i = 0; i < n; i++) {\n      ScreenListItem* item = (ScreenListItem*) Panel_get(super, i);\n      item->ss = NULL;\n   }\n\n   Panel_delete(object);\n}\n\nstatic HandlerResult ScreensPanel_eventHandlerRenaming(Panel* super, int ch) {\n   ScreensPanel* const this = (ScreensPanel*) super;\n\n   if (ch >= 32 && ch < 127 && ch != '=') {\n      if (this->cursor < SCREEN_NAME_LEN - 1) {\n         this->buffer[this->cursor] = (char)ch;\n         this->cursor++;\n         super->selectedLen = strlen(this->buffer);\n         Panel_setCursorToSelection(super);\n      }\n\n      return HANDLED;\n   }\n\n   switch (ch) {\n      case 127:\n      case KEY_BACKSPACE:\n         if (this->cursor > 0) {\n            this->cursor--;\n            this->buffer[this->cursor] = '\\0';\n            super->selectedLen = strlen(this->buffer);\n            Panel_setCursorToSelection(super);\n         }\n         break;\n      case '\\n':\n      case '\\r':\n      case KEY_ENTER: {\n         ListItem* item = (ListItem*) Panel_getSelected(super);\n         if (!item)\n            break;\n         assert(item == this->renamingItem);\n         free(this->saved);\n         item->value = xStrdup(this->buffer);\n         this->renamingItem = NULL;\n         super->cursorOn = false;\n         Panel_setSelectionColor(super, PANEL_SELECTION_FOCUS);\n         ScreensPanel_update(super);\n         break;\n      }\n      case 27: { // Esc\n         ListItem* item = (ListItem*) Panel_getSelected(super);\n         if (!item)\n            break;\n         assert(item == this->renamingItem);\n         item->value = this->saved;\n         this->renamingItem = NULL;\n         super->cursorOn = false;\n         Panel_setSelectionColor(super, PANEL_SELECTION_FOCUS);\n         break;\n      }\n   }\n\n   return HANDLED;\n}\n\nstatic void startRenaming(Panel* super) {\n   ScreensPanel* const this = (ScreensPanel*) super;\n\n   ListItem* item = (ListItem*) Panel_getSelected(super);\n   if (item == NULL)\n      return;\n   this->renamingItem = item;\n   super->cursorOn = true;\n   char* name = item->value;\n   this->saved = name;\n   strncpy(this->buffer, name, SCREEN_NAME_LEN);\n   this->buffer[SCREEN_NAME_LEN] = '\\0';\n   this->cursor = strlen(this->buffer);\n   item->value = this->buffer;\n   Panel_setSelectionColor(super, PANEL_EDIT);\n   super->selectedLen = strlen(this->buffer);\n   Panel_setCursorToSelection(super);\n}\n\nstatic void rebuildSettingsArray(Panel* super, int selected) {\n   ScreensPanel* const this = (ScreensPanel*) super;\n\n   int n = Panel_size(super);\n   free(this->settings->screens);\n   this->settings->screens = xMallocArray(n + 1, sizeof(ScreenSettings*));\n   this->settings->screens[n] = NULL;\n   for (int i = 0; i < n; i++) {\n      ScreenListItem* item = (ScreenListItem*) Panel_get(super, i);\n      this->settings->screens[i] = item->ss;\n   }\n   this->settings->nScreens = n;\n   /* ensure selection is in valid range */\n   if (selected > n - 1)\n      selected = n - 1;\n   else if (selected < 0)\n      selected = 0;\n   this->settings->ssIndex = selected;\n   this->settings->ss = this->settings->screens[selected];\n}\n\nstatic void addNewScreen(Panel* super) {\n   ScreensPanel* const this = (ScreensPanel*) super;\n\n   const char* name = \"New\";\n   ScreenSettings* ss = Settings_newScreen(this->settings, &(const ScreenDefaults) { .name = name, .columns = \"PID Command\", .sortKey = \"PID\" });\n   ScreenListItem* item = ScreenListItem_new(name, ss);\n   int idx = Panel_getSelectedIndex(super);\n   Panel_insert(super, idx + 1, (Object*) item);\n   Panel_setSelected(super, idx + 1);\n}\n\nstatic HandlerResult ScreensPanel_eventHandlerNormal(Panel* super, int ch) {\n   ScreensPanel* const this = (ScreensPanel*) super;\n\n   int selected = Panel_getSelectedIndex(super);\n   ScreenListItem* oldFocus = (ScreenListItem*) Panel_getSelected(super);\n   bool shouldRebuildArray = false;\n   HandlerResult result = IGNORED;\n\n   switch (ch) {\n      case '\\n':\n      case '\\r':\n      case KEY_ENTER:\n      case KEY_MOUSE:\n      case KEY_RECLICK: {\n         this->moving = !this->moving;\n         Panel_setSelectionColor(super, this->moving ? PANEL_SELECTION_FOLLOW : PANEL_SELECTION_FOCUS);\n         ListItem* item = (ListItem*) Panel_getSelected(super);\n         if (item)\n            item->moving = this->moving;\n         result = HANDLED;\n         break;\n      }\n      case EVENT_SET_SELECTED:\n         result = HANDLED;\n         break;\n      case KEY_NPAGE:\n      case KEY_PPAGE:\n      case KEY_HOME:\n      case KEY_END:\n         Panel_onKey(super, ch);\n         break;\n      case KEY_F(2):\n      case KEY_CTRL('R'):\n         startRenaming(super);\n         result = HANDLED;\n         break;\n      case KEY_F(5):\n      case KEY_CTRL('N'):\n         if (this->settings->dynamicScreens)\n            break;\n         addNewScreen(super);\n         startRenaming(super);\n         shouldRebuildArray = true;\n         result = HANDLED;\n         break;\n      case KEY_UP:\n         if (!this->moving) {\n            Panel_onKey(super, ch);\n            break;\n         }\n         /* FALLTHRU */\n      case KEY_F(7):\n      case '[':\n      case '-':\n         Panel_moveSelectedUp(super);\n         shouldRebuildArray = true;\n         result = HANDLED;\n         break;\n      case KEY_DOWN:\n         if (!this->moving) {\n            Panel_onKey(super, ch);\n            break;\n         }\n         /* FALLTHRU */\n      case KEY_F(8):\n      case ']':\n      case '+':\n         Panel_moveSelectedDown(super);\n         shouldRebuildArray = true;\n         result = HANDLED;\n         break;\n      case KEY_F(9):\n      //case KEY_DC:\n         if (Panel_size(super) > 1)\n            Panel_remove(super, selected);\n         shouldRebuildArray = true;\n         result = HANDLED;\n         break;\n      default:\n         if (ch < 255 && isalpha(ch))\n            result = Panel_selectByTyping(super, ch);\n         if (result == BREAK_LOOP)\n            result = IGNORED;\n         break;\n   }\n\n   ScreenListItem* newFocus = (ScreenListItem*) Panel_getSelected(super);\n   if (newFocus && oldFocus != newFocus) {\n      Hashtable* dynamicColumns = this->settings->dynamicColumns;\n      ColumnsPanel_fill(this->columns, newFocus->ss, dynamicColumns);\n      AvailableColumnsPanel_fill(this->availableColumns, newFocus->ss->dynamic, dynamicColumns);\n      result = HANDLED;\n   }\n\n   if (shouldRebuildArray)\n      rebuildSettingsArray(super, selected);\n   if (result == HANDLED)\n      ScreensPanel_update(super);\n\n   return result;\n}\n\nstatic HandlerResult ScreensPanel_eventHandler(Panel* super, int ch) {\n   ScreensPanel* const this = (ScreensPanel*) super;\n\n   if (this->renamingItem) {\n      return ScreensPanel_eventHandlerRenaming(super, ch);\n   } else {\n      return ScreensPanel_eventHandlerNormal(super, ch);\n   }\n}\n\nPanelClass ScreensPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = ScreensPanel_delete\n   },\n   .eventHandler = ScreensPanel_eventHandler\n};\n\nScreensPanel* ScreensPanel_new(Settings* settings) {\n   ScreensPanel* this = AllocThis(ScreensPanel);\n   Panel* super = (Panel*) this;\n   Hashtable* columns = settings->dynamicColumns;\n   FunctionBar* fuBar = FunctionBar_new(settings->dynamicScreens ? DynamicFunctions : ScreensFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   this->settings = settings;\n   this->columns = ColumnsPanel_new(settings->screens[0], columns, &(settings->changed));\n   this->availableColumns = AvailableColumnsPanel_new((Panel*) this->columns, columns);\n   this->moving = false;\n   this->renamingItem = NULL;\n   super->cursorOn = false;\n   this->cursor = 0;\n   Panel_setHeader(super, \"Screens\");\n\n   for (unsigned int i = 0; i < settings->nScreens; i++) {\n      ScreenSettings* ss = settings->screens[i];\n      char* name = ss->heading;\n      Panel_add(super, (Object*) ScreenListItem_new(name, ss));\n   }\n   return this;\n}\n\nvoid ScreensPanel_update(Panel* super) {\n   ScreensPanel* this = (ScreensPanel*) super;\n   int size = Panel_size(super);\n   this->settings->changed = true;\n   this->settings->lastUpdate++;\n   this->settings->screens = xReallocArray(this->settings->screens, size + 1, sizeof(ScreenSettings*));\n   for (int i = 0; i < size; i++) {\n      ScreenListItem* item = (ScreenListItem*) Panel_get(super, i);\n      ScreenSettings* ss = item->ss;\n      free_and_xStrdup(&ss->heading, ((ListItem*) item)->value);\n      this->settings->screens[i] = ss;\n   }\n   this->settings->screens[size] = NULL;\n}\n"
        },
        {
          "name": "ScreensPanel.h",
          "type": "blob",
          "size": 1.125,
          "content": "#ifndef HEADER_ScreensPanel\n#define HEADER_ScreensPanel\n/*\nhtop - ScreensPanel.h\n(C) 2004-2011 Hisham H. Muhammad\n(C) 2020-2022 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"AvailableColumnsPanel.h\"\n#include \"ColumnsPanel.h\"\n#include \"DynamicScreen.h\"\n#include \"ListItem.h\"\n#include \"Object.h\"\n#include \"Panel.h\"\n#include \"ScreenManager.h\"\n#include \"Settings.h\"\n\n#ifndef SCREEN_NAME_LEN\n#define SCREEN_NAME_LEN 20\n#endif\n\ntypedef struct ScreensPanel_ {\n   Panel super;\n\n   ScreenManager* scr;\n   Settings* settings;\n   ColumnsPanel* columns;\n   AvailableColumnsPanel* availableColumns;\n   char buffer[SCREEN_NAME_LEN + 1];\n   char* saved;\n   int cursor;\n   bool moving;\n   ListItem* renamingItem;\n} ScreensPanel;\n\ntypedef struct ScreenListItem_ {\n   ListItem super;\n   DynamicScreen* ds;\n   ScreenSettings* ss;\n} ScreenListItem;\n\n\nextern ObjectClass ScreenListItem_class;\n\nScreenListItem* ScreenListItem_new(const char* value, ScreenSettings* ss);\n\nScreensPanel* ScreensPanel_new(Settings* settings);\n\nvoid ScreensPanel_update(Panel* super);\n\n#endif\n"
        },
        {
          "name": "Settings.c",
          "type": "blob",
          "size": 35.46484375,
          "content": "/*\nhtop - Settings.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Settings.h\"\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\n#include \"CRT.h\"\n#include \"DynamicColumn.h\"\n#include \"DynamicScreen.h\"\n#include \"Macros.h\"\n#include \"Meter.h\"\n#include \"Platform.h\"\n#include \"Process.h\"\n#include \"Table.h\"\n#include \"XUtils.h\"\n\n\nstatic void Settings_deleteColumns(Settings* this) {\n   for (size_t i = 0; i < HeaderLayout_getColumns(this->hLayout); i++) {\n      String_freeArray(this->hColumns[i].names);\n      free(this->hColumns[i].modes);\n   }\n   free(this->hColumns);\n}\n\nstatic void Settings_deleteScreens(Settings* this) {\n   if (this->screens) {\n      for (size_t i = 0; this->screens[i]; i++)\n         ScreenSettings_delete(this->screens[i]);\n      free(this->screens);\n   }\n}\n\nvoid Settings_delete(Settings* this) {\n   free(this->filename);\n   free(this->initialFilename);\n   Settings_deleteColumns(this);\n   Settings_deleteScreens(this);\n   free(this);\n}\n\nstatic char** Settings_splitLineToIDs(const char* line) {\n   char* trim = String_trim(line);\n   char** ids = String_split(trim, ' ', NULL);\n   free(trim);\n   return ids;\n}\n\nstatic void Settings_readMeters(Settings* this, const char* line, size_t column) {\n   column = MINIMUM(column, HeaderLayout_getColumns(this->hLayout) - 1);\n   this->hColumns[column].names = Settings_splitLineToIDs(line);\n}\n\nstatic void Settings_readMeterModes(Settings* this, const char* line, size_t column) {\n   char** ids = Settings_splitLineToIDs(line);\n\n   size_t len = 0;\n   for (size_t i = 0; ids[i]; i++) {\n      len++;\n   }\n\n   column = MINIMUM(column, HeaderLayout_getColumns(this->hLayout) - 1);\n   this->hColumns[column].len = len;\n   MeterModeId* modes = len ? xCalloc(len, sizeof(MeterModeId)) : NULL;\n   for (size_t i = 0; i < len; i++) {\n      modes[i] = (MeterModeId) atoi(ids[i]);\n   }\n   this->hColumns[column].modes = modes;\n\n   String_freeArray(ids);\n}\n\nstatic bool Settings_validateMeters(Settings* this) {\n   const size_t colCount = HeaderLayout_getColumns(this->hLayout);\n\n   bool anyMeter = false;\n\n   for (size_t column = 0; column < colCount; column++) {\n      char** names = this->hColumns[column].names;\n      const MeterModeId* modes = this->hColumns[column].modes;\n      const size_t len = this->hColumns[column].len;\n\n      if (!len)\n         continue;\n\n      if (!names || !modes)\n         return false;\n\n      anyMeter |= !!len;\n\n      // Check for each mode there is an entry with a non-NULL name\n      for (size_t meterIdx = 0; meterIdx < len; meterIdx++)\n         if (!names[meterIdx])\n            return false;\n\n      if (names[len])\n         return false;\n   }\n\n   return anyMeter;\n}\n\nstatic void Settings_defaultMeters(Settings* this, const Machine* host) {\n   unsigned int initialCpuCount = host->activeCPUs;\n   size_t sizes[] = { 3, 3 };\n\n   if (initialCpuCount > 4 && initialCpuCount <= 128) {\n      sizes[1]++;\n   }\n\n   // Release any previously allocated memory\n   Settings_deleteColumns(this);\n\n   this->hLayout = HF_TWO_50_50;\n   this->hColumns = xCalloc(HeaderLayout_getColumns(this->hLayout), sizeof(MeterColumnSetting));\n   for (size_t i = 0; i < 2; i++) {\n      this->hColumns[i].names = xCalloc(sizes[i] + 1, sizeof(*this->hColumns[0].names));\n      this->hColumns[i].modes = xCalloc(sizes[i], sizeof(*this->hColumns[0].modes));\n      this->hColumns[i].len = sizes[i];\n   }\n\n   int r = 0;\n\n   if (initialCpuCount > 128) {\n      // Just show the average, ricers need to config for impressive screenshots\n      this->hColumns[0].names[0] = xStrdup(\"CPU\");\n      this->hColumns[0].modes[0] = BAR_METERMODE;\n   } else if (initialCpuCount > 32) {\n      this->hColumns[0].names[0] = xStrdup(\"LeftCPUs8\");\n      this->hColumns[0].modes[0] = BAR_METERMODE;\n      this->hColumns[1].names[r] = xStrdup(\"RightCPUs8\");\n      this->hColumns[1].modes[r++] = BAR_METERMODE;\n   } else if (initialCpuCount > 16) {\n      this->hColumns[0].names[0] = xStrdup(\"LeftCPUs4\");\n      this->hColumns[0].modes[0] = BAR_METERMODE;\n      this->hColumns[1].names[r] = xStrdup(\"RightCPUs4\");\n      this->hColumns[1].modes[r++] = BAR_METERMODE;\n   } else if (initialCpuCount > 8) {\n      this->hColumns[0].names[0] = xStrdup(\"LeftCPUs2\");\n      this->hColumns[0].modes[0] = BAR_METERMODE;\n      this->hColumns[1].names[r] = xStrdup(\"RightCPUs2\");\n      this->hColumns[1].modes[r++] = BAR_METERMODE;\n   } else if (initialCpuCount > 4) {\n      this->hColumns[0].names[0] = xStrdup(\"LeftCPUs\");\n      this->hColumns[0].modes[0] = BAR_METERMODE;\n      this->hColumns[1].names[r] = xStrdup(\"RightCPUs\");\n      this->hColumns[1].modes[r++] = BAR_METERMODE;\n   } else {\n      this->hColumns[0].names[0] = xStrdup(\"AllCPUs\");\n      this->hColumns[0].modes[0] = BAR_METERMODE;\n   }\n   this->hColumns[0].names[1] = xStrdup(\"Memory\");\n   this->hColumns[0].modes[1] = BAR_METERMODE;\n   this->hColumns[0].names[2] = xStrdup(\"Swap\");\n   this->hColumns[0].modes[2] = BAR_METERMODE;\n   this->hColumns[1].names[r] = xStrdup(\"Tasks\");\n   this->hColumns[1].modes[r++] = TEXT_METERMODE;\n   this->hColumns[1].names[r] = xStrdup(\"LoadAverage\");\n   this->hColumns[1].modes[r++] = TEXT_METERMODE;\n   this->hColumns[1].names[r] = xStrdup(\"Uptime\");\n   this->hColumns[1].modes[r++] = TEXT_METERMODE;\n}\n\nstatic const char* toFieldName(Hashtable* columns, int id, bool* enabled) {\n   if (id < 0) {\n      if (enabled)\n         *enabled = false;\n      return NULL;\n   }\n   if (id >= ROW_DYNAMIC_FIELDS) {\n      const DynamicColumn* column = DynamicColumn_lookup(columns, id);\n      if (enabled)\n         *enabled = column ? column->enabled : false;\n      return column ? column->name : NULL;\n   }\n   if (enabled)\n      *enabled = true;\n   return Process_fields[id].name;\n}\n\nstatic int toFieldIndex(Hashtable* columns, const char* str) {\n   if (isdigit((unsigned char)str[0])) {\n      // This \"+1\" is for compatibility with the older enum format.\n      int id = atoi(str) + 1;\n      if (toFieldName(columns, id, NULL)) {\n         return id;\n      }\n   } else {\n      // Dynamically-defined columns are always stored by-name.\n      char dynamic[32] = {0};\n      if (sscanf(str, \"Dynamic(%30s)\", dynamic) == 1) {\n         char* end;\n         if ((end = strrchr(dynamic, ')')) != NULL) {\n            bool success;\n            unsigned int key;\n            *end = '\\0';\n            success = DynamicColumn_search(columns, dynamic, &key) != NULL;\n            *end = ')';\n            if (success)\n               return key;\n         }\n      }\n      // Fallback to iterative scan of table of fields by-name.\n      for (int p = 1; p < LAST_PROCESSFIELD; p++) {\n         const char* pName = toFieldName(columns, p, NULL);\n         if (pName && strcmp(pName, str) == 0)\n            return p;\n      }\n   }\n   return -1;\n}\n\nstatic void ScreenSettings_readFields(ScreenSettings* ss, Hashtable* columns, const char* line) {\n   char* trim = String_trim(line);\n   char** ids = String_split(trim, ' ', NULL);\n   free(trim);\n\n   /* reset default fields */\n   memset(ss->fields, '\\0', LAST_PROCESSFIELD * sizeof(ProcessField));\n\n   for (size_t j = 0, i = 0; ids[i]; i++) {\n      if (j >= UINT_MAX / sizeof(ProcessField))\n         continue;\n      if (j >= LAST_PROCESSFIELD) {\n         ss->fields = xRealloc(ss->fields, (j + 1) * sizeof(ProcessField));\n         memset(&ss->fields[j], 0, sizeof(ProcessField));\n      }\n      int id = toFieldIndex(columns, ids[i]);\n      if (id >= 0)\n         ss->fields[j++] = id;\n      if (id > 0 && id < LAST_PROCESSFIELD)\n         ss->flags |= Process_fields[id].flags;\n   }\n   String_freeArray(ids);\n}\n\nstatic ScreenSettings* Settings_initScreenSettings(ScreenSettings* ss, Settings* this, const char* columns) {\n   ScreenSettings_readFields(ss, this->dynamicColumns, columns);\n   this->screens[this->nScreens] = ss;\n   this->nScreens++;\n   this->screens = xRealloc(this->screens, sizeof(ScreenSettings*) * (this->nScreens + 1));\n   this->screens[this->nScreens] = NULL;\n   return ss;\n}\n\nScreenSettings* Settings_newScreen(Settings* this, const ScreenDefaults* defaults) {\n   int sortKey = defaults->sortKey ? toFieldIndex(this->dynamicColumns, defaults->sortKey) : PID;\n   int treeSortKey = defaults->treeSortKey ? toFieldIndex(this->dynamicColumns, defaults->treeSortKey) : PID;\n   int sortDesc = (sortKey >= 0 && sortKey < LAST_PROCESSFIELD) ? Process_fields[sortKey].defaultSortDesc : 1;\n\n   ScreenSettings* ss = xMalloc(sizeof(ScreenSettings));\n   *ss = (ScreenSettings) {\n      .heading = xStrdup(defaults->name),\n      .dynamic = NULL,\n      .table = NULL,\n      .fields = xCalloc(LAST_PROCESSFIELD, sizeof(ProcessField)),\n      .flags = 0,\n      .direction = sortDesc ? -1 : 1,\n      .treeDirection = 1,\n      .sortKey = sortKey,\n      .treeSortKey = treeSortKey,\n      .treeView = false,\n      .treeViewAlwaysByPID = false,\n      .allBranchesCollapsed = false,\n   };\n   return Settings_initScreenSettings(ss, this, defaults->columns);\n}\n\nScreenSettings* Settings_newDynamicScreen(Settings* this, const char* tab, const DynamicScreen* screen, Table* table) {\n   int sortKey = toFieldIndex(this->dynamicColumns, screen->columnKeys);\n\n   ScreenSettings* ss = xMalloc(sizeof(ScreenSettings));\n   *ss = (ScreenSettings) {\n      .heading = xStrdup(tab),\n      .dynamic = xStrdup(screen->name),\n      .table = table,\n      .fields = xCalloc(LAST_PROCESSFIELD, sizeof(ProcessField)),\n      .direction = screen->direction,\n      .treeDirection = 1,\n      .sortKey = sortKey,\n   };\n   return Settings_initScreenSettings(ss, this, screen->columnKeys);\n}\n\nvoid ScreenSettings_delete(ScreenSettings* this) {\n   free(this->heading);\n   free(this->dynamic);\n   free(this->fields);\n   free(this);\n}\n\nstatic ScreenSettings* Settings_defaultScreens(Settings* this) {\n   if (this->nScreens)\n      return this->screens[0];\n   for (unsigned int i = 0; i < Platform_numberOfDefaultScreens; i++) {\n      const ScreenDefaults* defaults = &Platform_defaultScreens[i];\n      Settings_newScreen(this, defaults);\n   }\n   Platform_defaultDynamicScreens(this);\n   return this->screens[0];\n}\n\nstatic bool Settings_read(Settings* this, const char* fileName, const Machine* host, bool checkWritability) {\n   int fd = -1;\n   const char* fopen_mode = \"r+\";\n   if (checkWritability) {\n      do {\n         fd = open(fileName, O_RDWR | O_NOCTTY | O_NOFOLLOW);\n      } while (fd < 0 && errno == EINTR);\n\n      if (fd < 0) {\n         this->writeConfig = (errno == ENOENT);\n         if (errno != EACCES && errno != EPERM && errno != EROFS) {\n            return false;\n         }\n      } else {\n         // Check if this is a regular file\n         struct stat sb;\n         int err = fstat(fd, &sb);\n         this->writeConfig = !err && S_ISREG(sb.st_mode);\n      }\n   }\n\n   // If opening for read & write is not needed or fails, open for read only.\n   // There is no risk of following symlink in this case.\n   if (fd < 0) {\n      fopen_mode = \"r\";\n      do {\n         fd = open(fileName, O_RDONLY | O_NOCTTY);\n      } while (fd < 0 && errno == EINTR);\n   }\n\n   if (fd < 0)\n      return false;\n\n   FILE* fp = fdopen(fd, fopen_mode);\n   if (!fp) {\n      close(fd);\n      return false;\n   }\n\n   ScreenSettings* screen = NULL;\n   bool didReadMeters = false;\n   bool didReadAny = false;\n   for (;;) {\n      char* line = String_readLine(fp);\n      if (!line) {\n         break;\n      }\n      didReadAny = true;\n      size_t nOptions;\n      char** option = String_split(line, '=', &nOptions);\n      free (line);\n      if (nOptions < 2) {\n         String_freeArray(option);\n         continue;\n      }\n      if (String_eq(option[0], \"config_reader_min_version\")) {\n         this->config_version = atoi(option[1]);\n         if (this->config_version > CONFIG_READER_MIN_VERSION) {\n            // the version of the config file on disk is newer than what we can read\n            fprintf(stderr, \"WARNING: %s specifies configuration format\\n\", fileName);\n            fprintf(stderr, \"         version v%d, but this %s binary only supports up to version v%d.\\n\", this->config_version, PACKAGE, CONFIG_READER_MIN_VERSION);\n            fprintf(stderr, \"         The configuration file will be downgraded to v%d when %s exits.\\n\", CONFIG_READER_MIN_VERSION, PACKAGE);\n            String_freeArray(option);\n            fclose(fp);\n            return false;\n         }\n      } else if (String_eq(option[0], \"fields\") && this->config_version <= 2) {\n         // old (no screen) naming also supported for backwards compatibility\n         screen = Settings_defaultScreens(this);\n         ScreenSettings_readFields(screen, this->dynamicColumns, option[1]);\n      } else if (String_eq(option[0], \"sort_key\") && this->config_version <= 2) {\n         // old (no screen) naming also supported for backwards compatibility\n         // This \"+1\" is for compatibility with the older enum format.\n         screen = Settings_defaultScreens(this);\n         screen->sortKey = atoi(option[1]) + 1;\n      } else if (String_eq(option[0], \"tree_sort_key\") && this->config_version <= 2) {\n         // old (no screen) naming also supported for backwards compatibility\n         // This \"+1\" is for compatibility with the older enum format.\n         screen = Settings_defaultScreens(this);\n         screen->treeSortKey = atoi(option[1]) + 1;\n      } else if (String_eq(option[0], \"sort_direction\") && this->config_version <= 2) {\n         // old (no screen) naming also supported for backwards compatibility\n         screen = Settings_defaultScreens(this);\n         screen->direction = atoi(option[1]);\n      } else if (String_eq(option[0], \"tree_sort_direction\") && this->config_version <= 2) {\n         // old (no screen) naming also supported for backwards compatibility\n         screen = Settings_defaultScreens(this);\n         screen->treeDirection = atoi(option[1]);\n      } else if (String_eq(option[0], \"tree_view\") && this->config_version <= 2) {\n         // old (no screen) naming also supported for backwards compatibility\n         screen = Settings_defaultScreens(this);\n         screen->treeView = atoi(option[1]);\n      } else if (String_eq(option[0], \"tree_view_always_by_pid\") && this->config_version <= 2) {\n         // old (no screen) naming also supported for backwards compatibility\n         screen = Settings_defaultScreens(this);\n         screen->treeViewAlwaysByPID = atoi(option[1]);\n      } else if (String_eq(option[0], \"all_branches_collapsed\") && this->config_version <= 2) {\n         // old (no screen) naming also supported for backwards compatibility\n         screen = Settings_defaultScreens(this);\n         screen->allBranchesCollapsed = atoi(option[1]);\n      } else if (String_eq(option[0], \"hide_kernel_threads\")) {\n         this->hideKernelThreads = atoi(option[1]);\n      } else if (String_eq(option[0], \"hide_userland_threads\")) {\n         this->hideUserlandThreads = atoi(option[1]);\n      } else if (String_eq(option[0], \"hide_running_in_container\")) {\n         this->hideRunningInContainer = atoi(option[1]);\n      } else if (String_eq(option[0], \"shadow_other_users\")) {\n         this->shadowOtherUsers = atoi(option[1]);\n      } else if (String_eq(option[0], \"show_thread_names\")) {\n         this->showThreadNames = atoi(option[1]);\n      } else if (String_eq(option[0], \"show_program_path\")) {\n         this->showProgramPath = atoi(option[1]);\n      } else if (String_eq(option[0], \"highlight_base_name\")) {\n         this->highlightBaseName = atoi(option[1]);\n      } else if (String_eq(option[0], \"highlight_deleted_exe\")) {\n         this->highlightDeletedExe = atoi(option[1]);\n      } else if (String_eq(option[0], \"shadow_distribution_path_prefix\")) {\n         this->shadowDistPathPrefix = atoi(option[1]);\n      } else if (String_eq(option[0], \"highlight_megabytes\")) {\n         this->highlightMegabytes = atoi(option[1]);\n      } else if (String_eq(option[0], \"highlight_threads\")) {\n         this->highlightThreads = atoi(option[1]);\n      } else if (String_eq(option[0], \"highlight_changes\")) {\n         this->highlightChanges = atoi(option[1]);\n      } else if (String_eq(option[0], \"highlight_changes_delay_secs\")) {\n         this->highlightDelaySecs = CLAMP(atoi(option[1]), 1, 24 * 60 * 60);\n      } else if (String_eq(option[0], \"find_comm_in_cmdline\")) {\n         this->findCommInCmdline = atoi(option[1]);\n      } else if (String_eq(option[0], \"strip_exe_from_cmdline\")) {\n         this->stripExeFromCmdline = atoi(option[1]);\n      } else if (String_eq(option[0], \"show_merged_command\")) {\n         this->showMergedCommand = atoi(option[1]);\n      } else if (String_eq(option[0], \"header_margin\")) {\n         this->headerMargin = atoi(option[1]);\n      } else if (String_eq(option[0], \"screen_tabs\")) {\n         this->screenTabs = atoi(option[1]);\n      } else if (String_eq(option[0], \"expand_system_time\")) {\n         // Compatibility option.\n         this->detailedCPUTime = atoi(option[1]);\n      } else if (String_eq(option[0], \"detailed_cpu_time\")) {\n         this->detailedCPUTime = atoi(option[1]);\n      } else if (String_eq(option[0], \"cpu_count_from_one\")) {\n         this->countCPUsFromOne = atoi(option[1]);\n      } else if (String_eq(option[0], \"cpu_count_from_zero\")) {\n         // old (inverted) naming also supported for backwards compatibility\n         this->countCPUsFromOne = !atoi(option[1]);\n      } else if (String_eq(option[0], \"show_cpu_usage\")) {\n         this->showCPUUsage = atoi(option[1]);\n      } else if (String_eq(option[0], \"show_cpu_frequency\")) {\n         this->showCPUFrequency = atoi(option[1]);\n      } else if (String_eq(option[0], \"show_cached_memory\")) {\n         this->showCachedMemory = atoi(option[1]);\n      #ifdef BUILD_WITH_CPU_TEMP\n      } else if (String_eq(option[0], \"show_cpu_temperature\")) {\n         this->showCPUTemperature = atoi(option[1]);\n      } else if (String_eq(option[0], \"degree_fahrenheit\")) {\n         this->degreeFahrenheit = atoi(option[1]);\n      #endif\n      } else if (String_eq(option[0], \"update_process_names\")) {\n         this->updateProcessNames = atoi(option[1]);\n      } else if (String_eq(option[0], \"account_guest_in_cpu_meter\")) {\n         this->accountGuestInCPUMeter = atoi(option[1]);\n      } else if (String_eq(option[0], \"delay\")) {\n         this->delay = CLAMP(atoi(option[1]), 1, 255);\n      } else if (String_eq(option[0], \"color_scheme\")) {\n         this->colorScheme = atoi(option[1]);\n         if (this->colorScheme < 0 || this->colorScheme >= LAST_COLORSCHEME) {\n            this->colorScheme = 0;\n         }\n      #ifdef HAVE_GETMOUSE\n      } else if (String_eq(option[0], \"enable_mouse\")) {\n         this->enableMouse = atoi(option[1]);\n      #endif\n      } else if (String_eq(option[0], \"header_layout\")) {\n         this->hLayout = isdigit((unsigned char)option[1][0]) ? ((HeaderLayout) atoi(option[1])) : HeaderLayout_fromName(option[1]);\n         if (this->hLayout < 0 || this->hLayout >= LAST_HEADER_LAYOUT)\n            this->hLayout = HF_TWO_50_50;\n         free(this->hColumns);\n         this->hColumns = xCalloc(HeaderLayout_getColumns(this->hLayout), sizeof(MeterColumnSetting));\n      } else if (String_eq(option[0], \"left_meters\")) {\n         Settings_readMeters(this, option[1], 0);\n         didReadMeters = true;\n      } else if (String_eq(option[0], \"right_meters\")) {\n         Settings_readMeters(this, option[1], 1);\n         didReadMeters = true;\n      } else if (String_eq(option[0], \"left_meter_modes\")) {\n         Settings_readMeterModes(this, option[1], 0);\n         didReadMeters = true;\n      } else if (String_eq(option[0], \"right_meter_modes\")) {\n         Settings_readMeterModes(this, option[1], 1);\n         didReadMeters = true;\n      } else if (String_startsWith(option[0], \"column_meters_\")) {\n         Settings_readMeters(this, option[1], atoi(option[0] + strlen(\"column_meters_\")));\n         didReadMeters = true;\n      } else if (String_startsWith(option[0], \"column_meter_modes_\")) {\n         Settings_readMeterModes(this, option[1], atoi(option[0] + strlen(\"column_meter_modes_\")));\n         didReadMeters = true;\n      } else if (String_eq(option[0], \"hide_function_bar\")) {\n         this->hideFunctionBar = atoi(option[1]);\n      #ifdef HAVE_LIBHWLOC\n      } else if (String_eq(option[0], \"topology_affinity\")) {\n         this->topologyAffinity = !!atoi(option[1]);\n      #endif\n      } else if (strncmp(option[0], \"screen:\", 7) == 0) {\n         screen = Settings_newScreen(this, &(const ScreenDefaults) { .name = option[0] + 7, .columns = option[1] });\n      } else if (String_eq(option[0], \".sort_key\")) {\n         if (screen) {\n            int key = toFieldIndex(this->dynamicColumns, option[1]);\n            screen->sortKey = key > 0 ? key : PID;\n         }\n      } else if (String_eq(option[0], \".tree_sort_key\")) {\n         if (screen) {\n            int key = toFieldIndex(this->dynamicColumns, option[1]);\n            screen->treeSortKey = key > 0 ? key : PID;\n         }\n      } else if (String_eq(option[0], \".sort_direction\")) {\n         if (screen)\n            screen->direction = atoi(option[1]);\n      } else if (String_eq(option[0], \".tree_sort_direction\")) {\n         if (screen)\n            screen->treeDirection = atoi(option[1]);\n      } else if (String_eq(option[0], \".tree_view\")) {\n         if (screen)\n            screen->treeView = atoi(option[1]);\n      } else if (String_eq(option[0], \".tree_view_always_by_pid\")) {\n         if (screen)\n            screen->treeViewAlwaysByPID = atoi(option[1]);\n      } else if (String_eq(option[0], \".all_branches_collapsed\")) {\n         if (screen)\n            screen->allBranchesCollapsed = atoi(option[1]);\n      } else if (String_eq(option[0], \".dynamic\")) {\n         if (screen) {\n            free_and_xStrdup(&screen->dynamic, option[1]);\n            Platform_addDynamicScreen(screen);\n         }\n      }\n      String_freeArray(option);\n   }\n   fclose(fp);\n   if (!didReadMeters || !Settings_validateMeters(this))\n      Settings_defaultMeters(this, host);\n   if (!this->nScreens)\n      Settings_defaultScreens(this);\n   return didReadAny;\n}\n\ntypedef ATTR_FORMAT(printf, 2, 3) int (*OutputFunc)(FILE*, const char*,...);\n\nstatic void writeFields(OutputFunc of, FILE* fp,\n                        const ProcessField* fields, Hashtable* columns,\n                        bool byName, char separator) {\n   const char* sep = \"\";\n   for (unsigned int i = 0; fields[i]; i++) {\n      if (fields[i] < LAST_PROCESSFIELD && byName) {\n         const char* pName = toFieldName(columns, fields[i], NULL);\n         of(fp, \"%s%s\", sep, pName);\n      } else if (fields[i] >= LAST_PROCESSFIELD && byName) {\n         bool enabled;\n         const char* pName = toFieldName(columns, fields[i], &enabled);\n         if (enabled)\n            of(fp, \"%sDynamic(%s)\", sep, pName);\n      } else {\n         // This \"-1\" is for compatibility with the older enum format.\n         of(fp, \"%s%d\", sep, (int) fields[i] - 1);\n      }\n      sep = \" \";\n   }\n   of(fp, \"%c\", separator);\n}\n\nstatic void writeList(OutputFunc of, FILE* fp,\n                      char** list, int len, char separator) {\n   const char* sep = \"\";\n   for (int i = 0; i < len; i++) {\n      of(fp, \"%s%s\", sep, list[i]);\n      sep = \" \";\n   }\n   of(fp, \"%c\", separator);\n}\n\nstatic void writeMeters(const Settings* this, OutputFunc of,\n                        FILE* fp, char separator, unsigned int column) {\n   if (this->hColumns[column].len) {\n      writeList(of, fp, this->hColumns[column].names, this->hColumns[column].len, separator);\n   } else {\n      of(fp, \"!%c\", separator);\n   }\n}\n\nstatic void writeMeterModes(const Settings* this, OutputFunc of,\n                            FILE* fp, char separator, unsigned int column) {\n   if (this->hColumns[column].len) {\n      const char* sep = \"\";\n      for (size_t i = 0; i < this->hColumns[column].len; i++) {\n         of(fp, \"%s%u\", sep, this->hColumns[column].modes[i]);\n         sep = \" \";\n      }\n   } else {\n      of(fp, \"!\");\n   }\n\n   of(fp, \"%c\", separator);\n}\n\nATTR_FORMAT(printf, 2, 3)\nstatic int signal_safe_fprintf(FILE* stream, const char* fmt, ...) {\n   char buf[2048];\n\n   va_list vl;\n   va_start(vl, fmt);\n   int n = vsnprintf(buf, sizeof(buf), fmt, vl);\n   va_end(vl);\n\n   if (n <= 0)\n      return n;\n\n   return full_write_str(fileno(stream), buf);\n}\n\nint Settings_write(const Settings* this, bool onCrash) {\n   FILE* fp;\n   char separator;\n   char* tmpFilename = NULL;\n   OutputFunc of;\n   if (onCrash) {\n      fp = stderr;\n      separator = ';';\n      of = signal_safe_fprintf;\n   } else if (!this->writeConfig) {\n      return 0;\n   } else {\n      /* create tempfile with mode 0600 */\n      mode_t cur_umask = umask(S_IXUSR | S_IRWXG | S_IRWXO);\n      xAsprintf(&tmpFilename, \"%s.tmp.XXXXXX\", this->filename);\n      int fdtmp = mkstemp(tmpFilename);\n      umask(cur_umask);\n      if (fdtmp == -1) {\n         free(tmpFilename);\n         return -errno;\n      }\n      fp = fdopen(fdtmp, \"w\");\n      if (!fp) {\n         free(tmpFilename);\n         return -errno;\n      }\n      separator = '\\n';\n      of = fprintf;\n   }\n\n   #define printSettingInteger(setting_, value_) \\\n      of(fp, setting_ \"=%d%c\", (int) (value_), separator)\n   #define printSettingString(setting_, value_) \\\n      of(fp, setting_ \"=%s%c\", value_, separator)\n\n   if (!onCrash) {\n      of(fp, \"# Beware! This file is rewritten by htop when settings are changed in the interface.\\n\");\n      of(fp, \"# The parser is also very primitive, and not human-friendly.\\n\");\n   }\n   printSettingString(\"htop_version\", VERSION);\n   printSettingInteger(\"config_reader_min_version\", CONFIG_READER_MIN_VERSION);\n   of(fp, \"fields=\"); writeFields(of, fp, this->screens[0]->fields, this->dynamicColumns, false, separator);\n   printSettingInteger(\"hide_kernel_threads\", this->hideKernelThreads);\n   printSettingInteger(\"hide_userland_threads\", this->hideUserlandThreads);\n   printSettingInteger(\"hide_running_in_container\", this->hideRunningInContainer);\n   printSettingInteger(\"shadow_other_users\", this->shadowOtherUsers);\n   printSettingInteger(\"show_thread_names\", this->showThreadNames);\n   printSettingInteger(\"show_program_path\", this->showProgramPath);\n   printSettingInteger(\"highlight_base_name\", this->highlightBaseName);\n   printSettingInteger(\"highlight_deleted_exe\", this->highlightDeletedExe);\n   printSettingInteger(\"shadow_distribution_path_prefix\", this->shadowDistPathPrefix);\n   printSettingInteger(\"highlight_megabytes\", this->highlightMegabytes);\n   printSettingInteger(\"highlight_threads\", this->highlightThreads);\n   printSettingInteger(\"highlight_changes\", this->highlightChanges);\n   printSettingInteger(\"highlight_changes_delay_secs\", this->highlightDelaySecs);\n   printSettingInteger(\"find_comm_in_cmdline\", this->findCommInCmdline);\n   printSettingInteger(\"strip_exe_from_cmdline\", this->stripExeFromCmdline);\n   printSettingInteger(\"show_merged_command\", this->showMergedCommand);\n   printSettingInteger(\"header_margin\", this->headerMargin);\n   printSettingInteger(\"screen_tabs\", this->screenTabs);\n   printSettingInteger(\"detailed_cpu_time\", this->detailedCPUTime);\n   printSettingInteger(\"cpu_count_from_one\", this->countCPUsFromOne);\n   printSettingInteger(\"show_cpu_usage\", this->showCPUUsage);\n   printSettingInteger(\"show_cpu_frequency\", this->showCPUFrequency);\n   #ifdef BUILD_WITH_CPU_TEMP\n   printSettingInteger(\"show_cpu_temperature\", this->showCPUTemperature);\n   printSettingInteger(\"degree_fahrenheit\", this->degreeFahrenheit);\n   #endif\n   printSettingInteger(\"show_cached_memory\", this->showCachedMemory);\n   printSettingInteger(\"update_process_names\", this->updateProcessNames);\n   printSettingInteger(\"account_guest_in_cpu_meter\", this->accountGuestInCPUMeter);\n   printSettingInteger(\"color_scheme\", this->colorScheme);\n   #ifdef HAVE_GETMOUSE\n   printSettingInteger(\"enable_mouse\", this->enableMouse);\n   #endif\n   printSettingInteger(\"delay\", (int) this->delay);\n   printSettingInteger(\"hide_function_bar\", (int) this->hideFunctionBar);\n   #ifdef HAVE_LIBHWLOC\n   printSettingInteger(\"topology_affinity\", this->topologyAffinity);\n   #endif\n\n   printSettingString(\"header_layout\", HeaderLayout_getName(this->hLayout));\n   for (unsigned int i = 0; i < HeaderLayout_getColumns(this->hLayout); i++) {\n      of(fp, \"column_meters_%u=\", i);\n      writeMeters(this, of, fp, separator, i);\n      of(fp, \"column_meter_modes_%u=\", i);\n      writeMeterModes(this, of, fp, separator, i);\n   }\n\n   // Legacy compatibility with older versions of htop\n   printSettingInteger(\"tree_view\", this->screens[0]->treeView);\n   // This \"-1\" is for compatibility with the older enum format.\n   printSettingInteger(\"sort_key\", this->screens[0]->sortKey - 1);\n   printSettingInteger(\"tree_sort_key\", this->screens[0]->treeSortKey - 1);\n   printSettingInteger(\"sort_direction\", this->screens[0]->direction);\n   printSettingInteger(\"tree_sort_direction\", this->screens[0]->treeDirection);\n   printSettingInteger(\"tree_view_always_by_pid\", this->screens[0]->treeViewAlwaysByPID);\n   printSettingInteger(\"all_branches_collapsed\", this->screens[0]->allBranchesCollapsed);\n\n   for (unsigned int i = 0; i < this->nScreens; i++) {\n      ScreenSettings* ss = this->screens[i];\n      const char* sortKey = toFieldName(this->dynamicColumns, ss->sortKey, NULL);\n      const char* treeSortKey = toFieldName(this->dynamicColumns, ss->treeSortKey, NULL);\n\n      of(fp, \"screen:%s=\", ss->heading);\n      writeFields(of, fp, ss->fields, this->dynamicColumns, true, separator);\n      if (ss->dynamic) {\n         printSettingString(\".dynamic\", ss->dynamic);\n         if (ss->sortKey && ss->sortKey != PID)\n            of(fp, \"%s=Dynamic(%s)%c\", \".sort_key\", sortKey, separator);\n         if (ss->treeSortKey && ss->treeSortKey != PID)\n            of(fp, \"%s=Dynamic(%s)%c\", \".tree_sort_key\", treeSortKey, separator);\n      } else {\n         printSettingString(\".sort_key\", sortKey);\n         printSettingString(\".tree_sort_key\", treeSortKey);\n         printSettingInteger(\".tree_view_always_by_pid\", ss->treeViewAlwaysByPID);\n      }\n      printSettingInteger(\".tree_view\", ss->treeView);\n      printSettingInteger(\".sort_direction\", ss->direction);\n      printSettingInteger(\".tree_sort_direction\", ss->treeDirection);\n      printSettingInteger(\".all_branches_collapsed\", ss->allBranchesCollapsed);\n   }\n\n   #undef printSettingString\n   #undef printSettingInteger\n\n   if (onCrash)\n      return 0;\n\n   int r = 0;\n\n   if (ferror(fp) != 0)\n      r = (errno != 0) ? -errno : -EBADF;\n\n   if (fclose(fp) != 0)\n      r = r ? r : -errno;\n\n   if (r == 0)\n      r = (rename(tmpFilename, this->filename) == -1) ? -errno : 0;\n\n   free(tmpFilename);\n\n   return r;\n}\n\nSettings* Settings_new(const Machine* host, Hashtable* dynamicMeters, Hashtable* dynamicColumns, Hashtable* dynamicScreens) {\n   Settings* this = xCalloc(1, sizeof(Settings));\n\n   this->writeConfig = true;\n\n   this->dynamicScreens = dynamicScreens;\n   this->dynamicColumns = dynamicColumns;\n   this->dynamicMeters = dynamicMeters;\n   this->hLayout = HF_TWO_50_50;\n   this->hColumns = xCalloc(HeaderLayout_getColumns(this->hLayout), sizeof(MeterColumnSetting));\n\n   this->shadowOtherUsers = false;\n   this->showThreadNames = false;\n   this->hideKernelThreads = true;\n   this->hideUserlandThreads = false;\n   this->hideRunningInContainer = false;\n   this->highlightBaseName = false;\n   this->highlightDeletedExe = true;\n   this->shadowDistPathPrefix = false;\n   this->highlightMegabytes = true;\n   this->detailedCPUTime = false;\n   this->countCPUsFromOne = false;\n   this->showCPUUsage = true;\n   this->showCPUFrequency = false;\n   #ifdef BUILD_WITH_CPU_TEMP\n   this->showCPUTemperature = false;\n   this->degreeFahrenheit = false;\n   #endif\n   this->showCachedMemory = true;\n   this->updateProcessNames = false;\n   this->showProgramPath = true;\n   this->highlightThreads = true;\n   this->highlightChanges = false;\n   this->highlightDelaySecs = DEFAULT_HIGHLIGHT_SECS;\n   this->findCommInCmdline = true;\n   this->stripExeFromCmdline = true;\n   this->showMergedCommand = false;\n   this->hideFunctionBar = 0;\n   this->headerMargin = true;\n   #ifdef HAVE_LIBHWLOC\n   this->topologyAffinity = false;\n   #endif\n\n   this->screens = xCalloc(Platform_numberOfDefaultScreens, sizeof(ScreenSettings*));\n   this->nScreens = 0;\n\n   char* legacyDotfile = NULL;\n   const char* rcfile = getenv(\"HTOPRC\");\n   if (rcfile) {\n      this->initialFilename = xStrdup(rcfile);\n   } else {\n      const char* home = getenv(\"HOME\");\n      if (!home || home[0] != '/') {\n         const struct passwd* pw = getpwuid(getuid());\n         home = (pw && pw->pw_dir && pw->pw_dir[0] == '/') ? pw->pw_dir : \"\";\n      }\n      const char* xdgConfigHome = getenv(\"XDG_CONFIG_HOME\");\n      char* configDir = NULL;\n      char* htopDir = NULL;\n      if (xdgConfigHome && xdgConfigHome[0] == '/') {\n         this->initialFilename = String_cat(xdgConfigHome, \"/htop/htoprc\");\n         configDir = xStrdup(xdgConfigHome);\n         htopDir = String_cat(xdgConfigHome, \"/htop\");\n      } else {\n         this->initialFilename = String_cat(home, CONFIGDIR \"/htop/htoprc\");\n         configDir = String_cat(home, CONFIGDIR);\n         htopDir = String_cat(home, CONFIGDIR \"/htop\");\n      }\n      (void) mkdir(configDir, 0700);\n      (void) mkdir(htopDir, 0700);\n      free(htopDir);\n      free(configDir);\n\n      legacyDotfile = String_cat(home, \"/.htoprc\");\n   }\n\n   this->filename = xMalloc(PATH_MAX);\n   if (!realpath(this->initialFilename, this->filename))\n      free_and_xStrdup(&this->filename, this->initialFilename);\n\n   this->colorScheme = 0;\n#ifdef HAVE_GETMOUSE\n   this->enableMouse = true;\n#endif\n   this->changed = false;\n   this->delay = DEFAULT_DELAY;\n\n   bool ok = Settings_read(this, this->filename, host, /*checkWritability*/true);\n   if (!ok && legacyDotfile) {\n      ok = Settings_read(this, legacyDotfile, host, this->writeConfig);\n      if (ok && this->writeConfig) {\n         // Transition to new location and delete old configuration file\n         if (Settings_write(this, false) == 0) {\n            unlink(legacyDotfile);\n         }\n      }\n   }\n   if (!ok) {\n      this->screenTabs = true;\n      this->changed = true;\n\n      ok = Settings_read(this, SYSCONFDIR \"/htoprc\", host, /*checkWritability*/false);\n   }\n   if (!ok) {\n      Settings_defaultMeters(this, host);\n      Settings_defaultScreens(this);\n   }\n\n   this->ssIndex = 0;\n   this->ss = this->screens[this->ssIndex];\n\n   this->lastUpdate = 1;\n\n   free(legacyDotfile);\n\n   return this;\n}\n\nvoid ScreenSettings_invertSortOrder(ScreenSettings* this) {\n   int* attr = (this->treeView) ? &(this->treeDirection) : &(this->direction);\n   *attr = (*attr == 1) ? -1 : 1;\n}\n\nvoid ScreenSettings_setSortKey(ScreenSettings* this, ProcessField sortKey) {\n   if (this->treeViewAlwaysByPID || !this->treeView) {\n      this->sortKey = sortKey;\n      this->direction = (Process_fields[sortKey].defaultSortDesc) ? -1 : 1;\n      this->treeView = false;\n   } else {\n      this->treeSortKey = sortKey;\n      this->treeDirection = (Process_fields[sortKey].defaultSortDesc) ? -1 : 1;\n   }\n}\n\nstatic bool readonly = false;\n\nvoid Settings_enableReadonly(void) {\n   readonly = true;\n}\n\nbool Settings_isReadonly(void) {\n   return readonly;\n}\n\nvoid Settings_setHeaderLayout(Settings* this, HeaderLayout hLayout) {\n   unsigned int oldColumns = HeaderLayout_getColumns(this->hLayout);\n   unsigned int newColumns = HeaderLayout_getColumns(hLayout);\n\n   if (newColumns > oldColumns) {\n      this->hColumns = xReallocArray(this->hColumns, newColumns, sizeof(MeterColumnSetting));\n      memset(this->hColumns + oldColumns, 0, (newColumns - oldColumns) * sizeof(MeterColumnSetting));\n   } else if (newColumns < oldColumns) {\n      for (unsigned int i = newColumns; i < oldColumns; i++) {\n         if (this->hColumns[i].names) {\n            for (size_t j = 0; j < this->hColumns[i].len; j++)\n               free(this->hColumns[i].names[j]);\n            free(this->hColumns[i].names);\n         }\n         free(this->hColumns[i].modes);\n      }\n      this->hColumns = xReallocArray(this->hColumns, newColumns, sizeof(MeterColumnSetting));\n   }\n\n   this->hLayout = hLayout;\n   this->changed = true;\n}\n"
        },
        {
          "name": "Settings.h",
          "type": "blob",
          "size": 3.9052734375,
          "content": "#ifndef HEADER_Settings\n#define HEADER_Settings\n/*\nhtop - Settings.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"Hashtable.h\"\n#include \"HeaderLayout.h\"\n#include \"MeterMode.h\"\n#include \"Row.h\"\n#include \"RowField.h\"\n\n\n#define DEFAULT_DELAY 15\n\n#define CONFIG_READER_MIN_VERSION 3\n\nstruct DynamicScreen_;  // IWYU pragma: keep\nstruct Machine_;        // IWYU pragma: keep\nstruct Table_;          // IWYU pragma: keep\n\ntypedef struct {\n   const char* name;\n   const char* columns;\n   const char* sortKey;\n   const char* treeSortKey;\n} ScreenDefaults;\n\ntypedef struct {\n   size_t len;\n   char** names;\n   MeterModeId* modes;\n} MeterColumnSetting;\n\ntypedef struct ScreenSettings_ {\n   char* heading;  /* user-editable screen name (pretty) */\n   char* dynamic;  /* from DynamicScreen config (fixed) */\n   struct Table_* table;\n   RowField* fields;\n   uint32_t flags;\n   int direction;\n   int treeDirection;\n   RowField sortKey;\n   RowField treeSortKey;\n   bool treeView;\n   bool treeViewAlwaysByPID;\n   bool allBranchesCollapsed;\n} ScreenSettings;\n\ntypedef struct Settings_ {\n   char* filename;\n   char* initialFilename;\n   bool writeConfig; /* whether to write the current settings on exit */\n   int config_version;\n   HeaderLayout hLayout;\n   MeterColumnSetting* hColumns;\n   Hashtable* dynamicColumns; /* runtime-discovered columns */\n   Hashtable* dynamicMeters;  /* runtime-discovered meters */\n   Hashtable* dynamicScreens; /* runtime-discovered screens */\n\n   ScreenSettings** screens;\n   unsigned int nScreens;\n   unsigned int ssIndex;\n   ScreenSettings* ss;\n\n   int colorScheme;\n   int delay;\n\n   bool countCPUsFromOne;\n   bool detailedCPUTime;\n   bool showCPUUsage;\n   bool showCPUFrequency;\n   #ifdef BUILD_WITH_CPU_TEMP\n   bool showCPUTemperature;\n   bool degreeFahrenheit;\n   #endif\n   bool showProgramPath;\n   bool shadowOtherUsers;\n   bool showThreadNames;\n   bool hideKernelThreads;\n   bool hideRunningInContainer;\n   bool hideUserlandThreads;\n   bool highlightBaseName;\n   bool highlightDeletedExe;\n   bool shadowDistPathPrefix;\n   bool highlightMegabytes;\n   bool highlightThreads;\n   bool highlightChanges;\n   int highlightDelaySecs;\n   bool findCommInCmdline;\n   bool stripExeFromCmdline;\n   bool showMergedCommand;\n   bool updateProcessNames;\n   bool accountGuestInCPUMeter;\n   bool headerMargin;\n   bool screenTabs;\n   bool showCachedMemory;\n   #ifdef HAVE_GETMOUSE\n   bool enableMouse;\n   #endif\n   int hideFunctionBar;  // 0 - off, 1 - on ESC until next input, 2 - permanently\n   #ifdef HAVE_LIBHWLOC\n   bool topologyAffinity;\n   #endif\n\n   bool changed;\n   uint64_t lastUpdate;\n} Settings;\n\n#define Settings_cpuId(settings, cpu) ((settings)->countCPUsFromOne ? (cpu)+1 : (cpu))\n\nstatic inline RowField ScreenSettings_getActiveSortKey(const ScreenSettings* this) {\n   return (this->treeView)\n          ? (this->treeViewAlwaysByPID ? 1 : this->treeSortKey)\n          : this->sortKey;\n}\n\nstatic inline int ScreenSettings_getActiveDirection(const ScreenSettings* this) {\n   return this->treeView ? this->treeDirection : this->direction;\n}\n\nvoid Settings_delete(Settings* this);\n\nint Settings_write(const Settings* this, bool onCrash);\n\nSettings* Settings_new(const struct Machine_* host, Hashtable* dynamicMeters, Hashtable* dynamicColumns, Hashtable* dynamicScreens);\n\nScreenSettings* Settings_newScreen(Settings* this, const ScreenDefaults* defaults);\n\nScreenSettings* Settings_newDynamicScreen(Settings* this, const char* tab, const struct DynamicScreen_* screen, struct Table_* table);\n\nvoid ScreenSettings_delete(ScreenSettings* this);\n\nvoid ScreenSettings_invertSortOrder(ScreenSettings* this);\n\nvoid ScreenSettings_setSortKey(ScreenSettings* this, RowField sortKey);\n\nvoid Settings_enableReadonly(void);\n\nbool Settings_isReadonly(void);\n\nvoid Settings_setHeaderLayout(Settings* this, HeaderLayout hLayout);\n\n#endif\n"
        },
        {
          "name": "SignalsPanel.c",
          "type": "blob",
          "size": 1.49609375,
          "content": "/*\nhtop - SignalsPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"SignalsPanel.h\"\n// the above contains #include <signal.h> so do not add that here again (breaks Solaris build)\n\n#include <stdbool.h>\n\n#include \"FunctionBar.h\"\n#include \"ListItem.h\"\n#include \"Object.h\"\n#include \"Panel.h\"\n#include \"Platform.h\"\n#include \"XUtils.h\"\n\n\nPanel* SignalsPanel_new(int preSelectedSignal) {\n   Panel* this = Panel_new(1, 1, 1, 1, Class(ListItem), true, FunctionBar_newEnterEsc(\"Send   \", \"Cancel \"));\n   int defaultPosition = 15;\n   unsigned int i;\n   for (i = 0; i < Platform_numberOfSignals; i++) {\n      Panel_set(this, i, (Object*) ListItem_new(Platform_signals[i].name, Platform_signals[i].number));\n      // signal 15 is not always the 15th signal in the table\n      if (Platform_signals[i].number == preSelectedSignal) {\n         defaultPosition = i;\n      }\n   }\n   #if (defined(SIGRTMIN) && defined(SIGRTMAX))\n   if (SIGRTMAX - SIGRTMIN <= 100) {\n      static char buf[16];\n      for (int sig = SIGRTMIN; sig <= SIGRTMAX; i++, sig++) {\n         int n = sig - SIGRTMIN;\n         xSnprintf(buf, sizeof(buf), \"%2d SIGRTMIN%-+3d\", sig, n);\n         if (n == 0) {\n            buf[11] = '\\0';\n         }\n         Panel_set(this, i, (Object*) ListItem_new(buf, sig));\n      }\n   }\n   #endif\n   Panel_setHeader(this, \"Send signal:\");\n   Panel_setSelected(this, defaultPosition);\n   return this;\n}\n"
        },
        {
          "name": "SignalsPanel.h",
          "type": "blob",
          "size": 0.4599609375,
          "content": "#ifndef HEADER_SignalsPanel\n#define HEADER_SignalsPanel\n/*\nhtop - SignalsPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n\n#ifndef HTOP_SOLARIS\n#include <signal.h>\n#endif\n\n\ntypedef struct SignalItem_ {\n   const char* name;\n   int number;\n} SignalItem;\n\n#define SIGNALSPANEL_INITSELECTEDSIGNAL SIGTERM\n\nPanel* SignalsPanel_new(int preSelectedSignal);\n\n#endif\n"
        },
        {
          "name": "SwapMeter.c",
          "type": "blob",
          "size": 2.509765625,
          "content": "/*\nhtop - SwapMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"SwapMeter.h\"\n\n#include <math.h>\n#include <stddef.h>\n\n#include \"CRT.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"RichString.h\"\n\n\nstatic const int SwapMeter_attributes[] = {\n   SWAP,\n   SWAP_CACHE,\n   SWAP_FRONTSWAP,\n};\n\nstatic void SwapMeter_updateValues(Meter* this) {\n   char* buffer = this->txtBuffer;\n   size_t size = sizeof(this->txtBuffer);\n   int written;\n\n   this->values[SWAP_METER_CACHE] = NAN;   /* 'cached' not present on all platforms */\n   this->values[SWAP_METER_FRONTSWAP] = NAN;   /* 'frontswap' not present on all platforms */\n   Platform_setSwapValues(this);\n\n   written = Meter_humanUnit(buffer, this->values[SWAP_METER_USED], size);\n   METER_BUFFER_CHECK(buffer, size, written);\n\n   METER_BUFFER_APPEND_CHR(buffer, size, '/');\n\n   Meter_humanUnit(buffer, this->total, size);\n}\n\nstatic void SwapMeter_display(const Object* cast, RichString* out) {\n   char buffer[50];\n   const Meter* this = (const Meter*)cast;\n   RichString_writeAscii(out, CRT_colors[METER_TEXT], \":\");\n   Meter_humanUnit(buffer, this->total, sizeof(buffer));\n   RichString_appendAscii(out, CRT_colors[METER_VALUE], buffer);\n   Meter_humanUnit(buffer, this->values[SWAP_METER_USED], sizeof(buffer));\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \" used:\");\n   RichString_appendAscii(out, CRT_colors[METER_VALUE], buffer);\n\n   if (isNonnegative(this->values[SWAP_METER_CACHE])) {\n      Meter_humanUnit(buffer, this->values[SWAP_METER_CACHE], sizeof(buffer));\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \" cache:\");\n      RichString_appendAscii(out, CRT_colors[SWAP_CACHE], buffer);\n   }\n\n   if (isNonnegative(this->values[SWAP_METER_FRONTSWAP])) {\n      Meter_humanUnit(buffer, this->values[SWAP_METER_FRONTSWAP], sizeof(buffer));\n      RichString_appendAscii(out, CRT_colors[METER_TEXT], \" frontswap:\");\n      RichString_appendAscii(out, CRT_colors[SWAP_FRONTSWAP], buffer);\n   }\n}\n\nconst MeterClass SwapMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = SwapMeter_display,\n   },\n   .updateValues = SwapMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = SWAP_METER_ITEMCOUNT,\n   .total = 100.0,\n   .attributes = SwapMeter_attributes,\n   .name = \"Swap\",\n   .uiName = \"Swap\",\n   .caption = \"Swp\"\n};\n"
        },
        {
          "name": "SwapMeter.h",
          "type": "blob",
          "size": 0.44140625,
          "content": "#ifndef HEADER_SwapMeter\n#define HEADER_SwapMeter\n/*\nhtop - SwapMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\ntypedef enum {\n   SWAP_METER_USED = 0,\n   SWAP_METER_CACHE = 1,\n   SWAP_METER_FRONTSWAP = 2,\n   SWAP_METER_ITEMCOUNT = 3, // number of entries in this enum\n} SwapMeterValues;\n\nextern const MeterClass SwapMeter_class;\n\n#endif\n"
        },
        {
          "name": "SysArchMeter.c",
          "type": "blob",
          "size": 0.96484375,
          "content": "/*\nhtop - SysArchMeter.c\n(C) 2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\"  // IWYU pragma: keep\n\n#include \"SysArchMeter.h\"\n\n#include <stddef.h>\n\n#include \"CRT.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"XUtils.h\"\n\n\nstatic const int SysArchMeter_attributes[] = {HOSTNAME};\n\nstatic void SysArchMeter_updateValues(Meter* this) {\n   static char* string;\n\n   if (string == NULL)\n      Platform_getRelease(&string);\n\n   String_safeStrncpy(this->txtBuffer, string, sizeof(this->txtBuffer));\n}\n\nconst MeterClass SysArchMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = SysArchMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = (1 << TEXT_METERMODE),\n   .maxItems = 0,\n   .total = 0.0,\n   .attributes = SysArchMeter_attributes,\n   .name = \"System\",\n   .uiName = \"System\",\n   .caption = \"System: \",\n};\n"
        },
        {
          "name": "SysArchMeter.h",
          "type": "blob",
          "size": 0.271484375,
          "content": "#ifndef HEADER_SysArchMeter\n#define HEADER_SysArchMeter\n/*\nhtop - SysArchMeter.h\n(C) 2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n#include \"Meter.h\"\n\n\nextern const MeterClass SysArchMeter_class;\n\n#endif\n"
        },
        {
          "name": "TESTPLAN",
          "type": "blob",
          "size": 2.80078125,
          "content": "\nMain screen:\n\n   For all views, all modes:\n\n      Mouse click header - nothing happens.\n\n      Mouse click on ProcessTable title bar - exit Tree view, update FunctionBar, title bar updates, sort by clicked field.\n*** FAILING: wrong FB update depending on mode; does not change sort in wip branch\n         click on same entry - invert sort.\n            click on another entry - sort another field.\n\n      Mouse click on a process - select that process.\n\n      for each entry in FunctionBar:\n         Mouse click entry - perform action of associated key.\n\n   In Normal mode, Sorted view:\n\n      <+> or <-> - do nothing.\n\n      <F6> - enter SortBy screen.\n\n   In Normal mode, Tree view:\n\n      select process - update F6 in FunctionBar if subtree is collapsed or expanded.\n\n      <F6>, <+> or <-> - expand/collapse subtree.\n\n   In Normal mode, either Sorted or Tree view:\n\n      <F3>, </> - activate Search mode.\n\n      <F4>, <\\> - activate Filter mode.\n\n      <F7>, <]> - as root only, decrease process NICE value.\n\n      <F8>, <[> - increase process NICE value.\n\n      <a> - enter Affinity screen.\n\n      <b> - do nothing.\n\n      <c> - select process and all its children.\n\n      <d>, <e>, <f>, <g> - do nothing.\n\n      <F1>, <h>, <?> - enter Help screen.\n\n      <i> - on Linux, enter IOPriority screen.\n\n      <j> - do nothing.\n\n      <F9>, <k> - enter Kill screen.\n\n      <l> - enter LSOF screen.\n\n      <m>, <n>, <o> - do nothing.\n\n      <p> - hide/show program path.\n\n      <F10>, <q> - quit program.\n\n      <r> - do nothing.\n\n      <s> - enter STrace screen.\n\n      <F5>, <t> - toggle between Tree and Sorted view, update F5 in FunctionBar, follow process\n\n      <u> - enter User screen.\n\n      <v>, <w>, <x>, <y>, <z> - do nothing.\n\n      <A>, <B> - do nothing.\n\n      <F2>, <C>, <S> - enter Setup screen.\n\n      <D>, <E> - do nothing.\n\n      <F> - follow process.\n\n      <G> - do nothing.\n\n      <H> - toggle show/hide userland threads.\n\n      <I> - invert sort order.\n\n      <J> - do nothing.\n\n      <K> - toggle show/hide kernel threads.\n\n      <L> - do nothing.\n\n      <M> - enter Sorted view, update function bar, sort by MEM%.\n\n      <N>, <O> - do nothing.\n\n      <P> - enter Sorted view, update function bar, sort by CPU%.\n\n      <Q>, <R> - do nothing.\n\n      <T> - enter Sorted view, update function bar, sort by TIME.\n\n      <U> - untag all processes.\n\n      <V>, <W>, <X>, <Y>, <Z> - do nothing.\n\n      <<>, <>>, <,>, <.> - enter SortBy screen.\n\n      space - tag current process, move down cursor.\n\n      numbers - incremental PID search.\n\n   In Search mode:\n\n      TODO\n\n   In Filter mode:\n\n      TODO\n\nSetup screen:\n\n   TODO\n\nSortBy screen:\n\n   TODO\n\nUser screen:\n\n   TODO\n\nKill screen:\n\n   TODO\n\nAffinity screen:\n\n   TODO\n\nHelp screen:\n\n   any key - back to Main screen.\n\nIOPriority screen:\n\n   TODO\n\nSTrace screen:\n\n   TODO\n\nLSOF screen:\n\n   TODO\n"
        },
        {
          "name": "Table.c",
          "type": "blob",
          "size": 11.2626953125,
          "content": "/*\nhtop - Table.c\n(C) 2004,2005 Hisham H. Muhammad\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Table.h\"\n\n#include <assert.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include \"CRT.h\"\n#include \"Hashtable.h\"\n#include \"Machine.h\"\n#include \"Macros.h\"\n#include \"Panel.h\"\n#include \"RowField.h\"\n#include \"Vector.h\"\n\n\nTable* Table_init(Table* this, const ObjectClass* klass, Machine* host) {\n   this->rows = Vector_new(klass, true, DEFAULT_SIZE);\n   this->displayList = Vector_new(klass, false, DEFAULT_SIZE);\n   this->table = Hashtable_new(200, false);\n   this->needsSort = true;\n   this->following = -1;\n   this->host = host;\n   return this;\n}\n\nvoid Table_done(Table* this) {\n   Hashtable_delete(this->table);\n   Vector_delete(this->displayList);\n   Vector_delete(this->rows);\n}\n\nstatic void Table_delete(Object* cast) {\n   Table* this = (Table*) cast;\n   Table_done(this);\n   free(this);\n}\n\nvoid Table_setPanel(Table* this, Panel* panel) {\n   this->panel = panel;\n}\n\nvoid Table_add(Table* this, Row* row) {\n   assert(Vector_indexOf(this->rows, row, Row_idEqualCompare) == -1);\n   assert(Hashtable_get(this->table, row->id) == NULL);\n\n   // highlighting row found in first scan by first scan marked \"far in the past\"\n   row->seenStampMs = this->host->monotonicMs;\n\n   Vector_add(this->rows, row);\n   Hashtable_put(this->table, row->id, row);\n\n   assert(Vector_indexOf(this->rows, row, Row_idEqualCompare) != -1);\n   assert(Hashtable_get(this->table, row->id) != NULL);\n   assert(Vector_countEquals(this->rows, Hashtable_count(this->table)));\n}\n\n// Table_removeIndex removes a given row from the lists map and soft deletes\n// it from its vector. Vector_compact *must* be called once the caller is done\n// removing items.\n// Note: for processes should only be called from ProcessTable_iterate to avoid\n// breaking dying process highlighting.\nstatic void Table_removeIndex(Table* this, const Row* row, int idx) {\n   int rowid = row->id;\n\n   assert(row == (Row*)Vector_get(this->rows, idx));\n   assert(Hashtable_get(this->table, rowid) != NULL);\n\n   Hashtable_remove(this->table, rowid);\n   Vector_softRemove(this->rows, idx);\n\n   if (this->following != -1 && this->following == rowid) {\n      this->following = -1;\n      Panel_setSelectionColor(this->panel, PANEL_SELECTION_FOCUS);\n   }\n\n   assert(Hashtable_get(this->table, rowid) == NULL);\n   assert(Vector_countEquals(this->rows, Hashtable_count(this->table)));\n}\n\nstatic void Table_buildTreeBranch(Table* this, int rowid, unsigned int level, int32_t indent, bool show) {\n   // Do not treat zero as root of any tree.\n   // (e.g. on OpenBSD the kernel thread 'swapper' has pid 0.)\n   if (rowid == 0)\n      return;\n\n   // The vector is sorted by parent, find the start of the range by bisection\n   int vsize = Vector_size(this->rows);\n   int l = 0;\n   int r = vsize;\n   while (l < r) {\n      int c = (l + r) / 2;\n      Row* row = (Row*)Vector_get(this->rows, c);\n      int parent = row->isRoot ? 0 : Row_getGroupOrParent(row);\n      if (parent < rowid) {\n         l = c + 1;\n      } else {\n         r = c;\n      }\n   }\n   // Find the end to know the last line for indent handling purposes\n   int lastShown = r;\n   while (r < vsize) {\n      Row* row = (Row*)Vector_get(this->rows, r);\n      if (!Row_isChildOf(row, rowid))\n         break;\n      if (row->show)\n         lastShown = r;\n      r++;\n   }\n\n   for (int i = l; i < r; i++) {\n      Row* row = (Row*)Vector_get(this->rows, i);\n\n      if (!show)\n         row->show = false;\n\n      Vector_add(this->displayList, row);\n\n      int32_t nextIndent = indent | ((int32_t)1 << MINIMUM(level, sizeof(row->indent) * 8 - 2));\n      Table_buildTreeBranch(this, row->id, level + 1, (i < lastShown) ? nextIndent : indent, row->show && row->showChildren);\n      if (i == lastShown)\n         row->indent = -nextIndent;\n      else\n         row->indent = nextIndent;\n\n      row->tree_depth = level + 1;\n   }\n}\n\nstatic int compareRowByKnownParentThenNatural(const void* v1, const void* v2) {\n   return Row_compareByParent((const Row*) v1, (const Row*) v2);\n}\n\n// Builds a sorted tree from scratch, without relying on previously gathered information\nstatic void Table_buildTree(Table* this) {\n   Vector_prune(this->displayList);\n\n   // Mark root processes\n   int vsize = Vector_size(this->rows);\n   for (int i = 0; i < vsize; i++) {\n      Row* row = (Row*) Vector_get(this->rows, i);\n      int parent = Row_getGroupOrParent(row);\n      row->isRoot = false;\n\n      if (row->id == parent) {\n         row->isRoot = true;\n         continue;\n      }\n\n      if (!parent) {\n         row->isRoot = true;\n         continue;\n      }\n\n      // We don't know about its parent for whatever reason\n      if (Table_findRow(this, parent) == NULL)\n         row->isRoot = true;\n   }\n\n   // Sort by known parent (roots first), then row ID\n   Vector_quickSortCustomCompare(this->rows, compareRowByKnownParentThenNatural);\n\n   // Find all processes whose parent is not visible\n   for (int i = 0; i < vsize; i++) {\n      Row* row = (Row*)Vector_get(this->rows, i);\n\n      // If parent not found, then construct the tree with this node as root\n      if (row->isRoot) {\n         row = (Row*)Vector_get(this->rows, i);\n         row->indent = 0;\n         row->tree_depth = 0;\n         Vector_add(this->displayList, row);\n         Table_buildTreeBranch(this, row->id, 0, 0, row->showChildren);\n         continue;\n      }\n   }\n\n   this->needsSort = false;\n\n   // Check consistency of the built structures\n   assert(Vector_size(this->displayList) == vsize); (void)vsize;\n}\n\nvoid Table_updateDisplayList(Table* this) {\n   const Settings* settings = this->host->settings;\n\n   if (settings->ss->treeView) {\n      if (this->needsSort)\n         Table_buildTree(this);\n   } else {\n      if (this->needsSort)\n         Vector_insertionSort(this->rows);\n      Vector_prune(this->displayList);\n      int size = Vector_size(this->rows);\n      for (int i = 0; i < size; i++)\n         Vector_add(this->displayList, Vector_get(this->rows, i));\n   }\n   this->needsSort = false;\n}\n\nvoid Table_expandTree(Table* this) {\n   int size = Vector_size(this->rows);\n   for (int i = 0; i < size; i++) {\n      Row* row = (Row*) Vector_get(this->rows, i);\n      row->showChildren = true;\n   }\n}\n\n// Called on collapse-all toggle and on startup, possibly in non-tree mode\nvoid Table_collapseAllBranches(Table* this) {\n   Table_buildTree(this); // Update `tree_depth` fields of the rows\n   this->needsSort = true; // Table is sorted by parent now, force new sort\n   int size = Vector_size(this->rows);\n   for (int i = 0; i < size; i++) {\n      Row* row = (Row*) Vector_get(this->rows, i);\n      // FreeBSD has pid 0 = kernel and pid 1 = init, so init has tree_depth = 1\n      if (row->tree_depth > 0 && row->id > 1)\n         row->showChildren = false;\n   }\n}\n\nvoid Table_rebuildPanel(Table* this) {\n   Table_updateDisplayList(this);\n\n   const int currPos = Panel_getSelectedIndex(this->panel);\n   const int currScrollV = this->panel->scrollV;\n   const int currSize = Panel_size(this->panel);\n\n   Panel_prune(this->panel);\n\n   /* Follow main group row instead if following a row that is occluded (hidden) */\n   if (this->following != -1) {\n      const Row* followed = (const Row*) Hashtable_get(this->table, this->following);\n      if (followed != NULL\n         && Hashtable_get(this->table, followed->group)\n         && Row_isVisible(followed, this) == false ) {\n         this->following = followed->group;\n      }\n   }\n\n   const int rowCount = Vector_size(this->displayList);\n   bool foundFollowed = false;\n   int idx = 0;\n\n   for (int i = 0; i < rowCount; i++) {\n      Row* row = (Row*) Vector_get(this->displayList, i);\n\n      if ( !row->show || (Row_matchesFilter(row, this) == true) )\n         continue;\n\n      Panel_set(this->panel, idx, (Object*)row);\n\n      if (this->following != -1 && row->id == this->following) {\n         foundFollowed = true;\n         Panel_setSelected(this->panel, idx);\n         /* Keep scroll position relative to followed row */\n         this->panel->scrollV = idx - (currPos - currScrollV);\n      }\n      idx++;\n   }\n\n   if (this->following != -1 && !foundFollowed) {\n      /* Reset if current followed row not found */\n      this->following = -1;\n      Panel_setSelectionColor(this->panel, PANEL_SELECTION_FOCUS);\n   }\n\n   if (this->following == -1) {\n      /* If the last item was selected, keep the new last item selected */\n      if (currPos > 0 && currPos == currSize - 1)\n         Panel_setSelected(this->panel, Panel_size(this->panel) - 1);\n      else\n         Panel_setSelected(this->panel, currPos);\n\n      this->panel->scrollV = currScrollV;\n   }\n}\n\nvoid Table_printHeader(const Settings* settings, RichString* header) {\n   RichString_rewind(header, RichString_size(header));\n\n   const ScreenSettings* ss = settings->ss;\n   const RowField* fields = ss->fields;\n\n   RowField key = ScreenSettings_getActiveSortKey(ss);\n\n   for (int i = 0; fields[i]; i++) {\n      int color;\n      if (ss->treeView && ss->treeViewAlwaysByPID) {\n         color = CRT_colors[PANEL_HEADER_FOCUS];\n      } else if (key == fields[i]) {\n         color = CRT_colors[PANEL_SELECTION_FOCUS];\n      } else {\n         color = CRT_colors[PANEL_HEADER_FOCUS];\n      }\n\n      RichString_appendWide(header, color, RowField_alignedTitle(settings, fields[i]));\n      if (key == fields[i] && RichString_getCharVal(*header, RichString_size(header) - 1) == ' ') {\n         bool ascending = ScreenSettings_getActiveDirection(ss) == 1;\n         RichString_rewind(header, 1);  // rewind to override space\n         RichString_appendWide(header,\n                                CRT_colors[PANEL_SELECTION_FOCUS],\n                                CRT_treeStr[ascending ? TREE_STR_ASC : TREE_STR_DESC]);\n      }\n      if (COMM == fields[i] && settings->showMergedCommand) {\n         RichString_appendAscii(header, color, \"(merged)\");\n      }\n   }\n}\n\n// set flags on an existing rows before refreshing table\nvoid Table_prepareEntries(Table* this) {\n   for (int i = 0; i < Vector_size(this->rows); i++) {\n      Row* row = (struct Row_*) Vector_get(this->rows, i);\n      row->updated = false;\n      row->wasShown = row->show;\n      row->show = true;\n   }\n}\n\n// tidy up Row state after refreshing the table\nvoid Table_cleanupRow(Table* table, Row* row, int idx) {\n   Machine* host = table->host;\n   const Settings* settings = host->settings;\n\n   if (row->tombStampMs > 0) {\n      // remove tombed process\n      if (host->monotonicMs >= row->tombStampMs) {\n         Table_removeIndex(table, row, idx);\n      }\n   } else if (row->updated == false) {\n      // process no longer exists\n      if (settings->highlightChanges && row->wasShown) {\n         // mark tombed\n         row->tombStampMs = host->monotonicMs + 1000 * settings->highlightDelaySecs;\n      } else {\n         // immediately remove\n         Table_removeIndex(table, row, idx);\n      }\n   }\n}\n\nvoid Table_cleanupEntries(Table* this) {\n   // Finish process table update, culling any removed rows\n   for (int i = Vector_size(this->rows) - 1; i >= 0; i--) {\n      Row* row = (Row*) Vector_get(this->rows, i);\n      Table_cleanupRow(this, row, i);\n   }\n\n   // compact the table in case of any earlier row removals\n   Table_compact(this);\n}\n\nconst TableClass Table_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = Table_delete,\n   },\n   .prepare = Table_prepareEntries,\n   .cleanup = Table_cleanupEntries,\n};\n"
        },
        {
          "name": "Table.h",
          "type": "blob",
          "size": 2.6630859375,
          "content": "#ifndef HEADER_Table\n#define HEADER_Table\n/*\nhtop - Table.h\n(C) 2004,2005 Hisham H. Muhammad\n(C) 2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\n#include \"Hashtable.h\"\n#include \"Object.h\"\n#include \"RichString.h\"\n#include \"Settings.h\"\n#include \"Vector.h\"\n\n\nstruct Machine_;  // IWYU pragma: keep\nstruct Panel_;    // IWYU pragma: keep\nstruct Row_;      // IWYU pragma: keep\n\ntypedef struct Table_ {\n   /* Super object for emulated OOP */\n   Object super;\n\n   Vector* rows;          /* all known; sort order can vary and differ from display order */\n   Vector* displayList;   /* row tree flattened in display order (borrowed);\n                             updated in Table_updateDisplayList when rebuilding panel */\n   Hashtable* table;      /* fast known row lookup by identifier */\n\n   struct Machine_* host;\n   const char* incFilter;\n   bool needsSort;\n   int following;         /* -1 or row being visually tracked in the user interface */\n\n   struct Panel_* panel;\n} Table;\n\ntypedef Table* (*Table_New)(const struct Machine_*);\ntypedef void (*Table_ScanPrepare)(Table* this);\ntypedef void (*Table_ScanIterate)(Table* this);\ntypedef void (*Table_ScanCleanup)(Table* this);\n\ntypedef struct TableClass_ {\n   const ObjectClass super;\n   const Table_ScanPrepare prepare;\n   const Table_ScanIterate iterate;\n   const Table_ScanCleanup cleanup;\n} TableClass;\n\n#define As_Table(this_)  ((const TableClass*)((this_)->super.klass))\n\n#define Table_scanPrepare(t_)  (As_Table(t_)->prepare ? (As_Table(t_)->prepare(t_)) : Table_prepareEntries(t_))\n#define Table_scanIterate(t_)  (As_Table(t_)->iterate(t_))  /* mandatory; must have a custom iterate method */\n#define Table_scanCleanup(t_)  (As_Table(t_)->cleanup ? (As_Table(t_)->cleanup(t_)) : Table_cleanupEntries(t_))\n\nTable* Table_init(Table* this, const ObjectClass* klass, struct Machine_* host);\n\nvoid Table_done(Table* this);\n\nextern const TableClass Table_class;\n\nvoid Table_setPanel(Table* this, struct Panel_* panel);\n\nvoid Table_printHeader(const Settings* settings, RichString* header);\n\nvoid Table_add(Table* this, struct Row_* row);\n\nvoid Table_updateDisplayList(Table* this);\n\nvoid Table_expandTree(Table* this);\n\nvoid Table_collapseAllBranches(Table* this);\n\nvoid Table_rebuildPanel(Table* this);\n\nstatic inline struct Row_* Table_findRow(Table* this, int id) {\n   return (struct Row_*) Hashtable_get(this->table, id);\n}\n\nvoid Table_prepareEntries(Table* this);\n\nvoid Table_cleanupEntries(Table* this);\n\nvoid Table_cleanupRow(Table* this, Row* row, int idx);\n\nstatic inline void Table_compact(Table* this) {\n   Vector_compact(this->rows);\n   this->needsSort = true;\n}\n\n#endif\n"
        },
        {
          "name": "TasksMeter.c",
          "type": "blob",
          "size": 2.94140625,
          "content": "/*\nhtop - TasksMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"TasksMeter.h\"\n\n#include \"CRT.h\"\n#include \"Machine.h\"\n#include \"Macros.h\"\n#include \"Object.h\"\n#include \"ProcessTable.h\"\n#include \"RichString.h\"\n#include \"Settings.h\"\n#include \"XUtils.h\"\n\n\nstatic const int TasksMeter_attributes[] = {\n   CPU_SYSTEM,\n   PROCESS_THREAD,\n   PROCESS,\n   TASKS_RUNNING\n};\n\nstatic void TasksMeter_updateValues(Meter* this) {\n   const Machine* host = this->host;\n   const ProcessTable* pt = (const ProcessTable*) host->processTable;\n\n   this->values[0] = pt->kernelThreads;\n   this->values[1] = pt->userlandThreads;\n   this->values[2] = pt->totalTasks - pt->kernelThreads - pt->userlandThreads;\n   this->values[3] = MINIMUM(pt->runningTasks, host->activeCPUs);\n   this->total     = pt->totalTasks;\n\n   xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"%u/%u\", MINIMUM(pt->runningTasks, host->activeCPUs), pt->totalTasks);\n}\n\nstatic void TasksMeter_display(const Object* cast, RichString* out) {\n   const Meter* this = (const Meter*)cast;\n   const Settings* settings = this->host->settings;\n   char buffer[20];\n   int len;\n\n   len = xSnprintf(buffer, sizeof(buffer), \"%d\", (int)this->values[2]);\n   RichString_appendnAscii(out, CRT_colors[METER_VALUE], buffer, len);\n\n   RichString_appendAscii(out, settings->hideUserlandThreads ? CRT_colors[METER_SHADOW] : CRT_colors[METER_TEXT], \", \");\n   len = xSnprintf(buffer, sizeof(buffer), \"%d\", (int)this->values[1]);\n   RichString_appendnAscii(out, settings->hideUserlandThreads ? CRT_colors[METER_SHADOW] : CRT_colors[TASKS_RUNNING], buffer, len);\n   RichString_appendAscii(out, settings->hideUserlandThreads ? CRT_colors[METER_SHADOW] : CRT_colors[METER_TEXT], \" thr\");\n\n   RichString_appendAscii(out, settings->hideKernelThreads ? CRT_colors[METER_SHADOW] : CRT_colors[METER_TEXT], \", \");\n   len = xSnprintf(buffer, sizeof(buffer), \"%d\", (int)this->values[0]);\n   RichString_appendnAscii(out, settings->hideKernelThreads ? CRT_colors[METER_SHADOW] : CRT_colors[TASKS_RUNNING], buffer, len);\n   RichString_appendAscii(out, settings->hideKernelThreads ? CRT_colors[METER_SHADOW] : CRT_colors[METER_TEXT], \" kthr\");\n\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \"; \");\n   len = xSnprintf(buffer, sizeof(buffer), \"%d\", (int)this->values[3]);\n   RichString_appendnAscii(out, CRT_colors[TASKS_RUNNING], buffer, len);\n   RichString_appendAscii(out, CRT_colors[METER_TEXT], \" running\");\n}\n\nconst MeterClass TasksMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = TasksMeter_display,\n   },\n   .updateValues = TasksMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = METERMODE_DEFAULT_SUPPORTED,\n   .maxItems = 4,\n   .total = 100.0,\n   .attributes = TasksMeter_attributes,\n   .name = \"Tasks\",\n   .uiName = \"Task counter\",\n   .caption = \"Tasks: \"\n};\n"
        },
        {
          "name": "TasksMeter.h",
          "type": "blob",
          "size": 0.2744140625,
          "content": "#ifndef HEADER_TasksMeter\n#define HEADER_TasksMeter\n/*\nhtop - TasksMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n\nextern const MeterClass TasksMeter_class;\n\n#endif\n"
        },
        {
          "name": "TraceScreen.c",
          "type": "blob",
          "size": 6.1748046875,
          "content": "/*\nhtop - TraceScreen.c\n(C) 2005-2006 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"TraceScreen.h\"\n\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/select.h>\n#include <sys/wait.h>\n\n#include \"CRT.h\"\n#include \"FunctionBar.h\"\n#include \"Panel.h\"\n#include \"ProvideCurses.h\"\n#include \"XUtils.h\"\n\n\nstatic const char* const TraceScreenFunctions[] = {\"Search \", \"Filter \", \"AutoScroll \", \"Stop Tracing   \", \"Done   \", NULL};\n\nstatic const char* const TraceScreenKeys[] = {\"F3\", \"F4\", \"F8\", \"F9\", \"Esc\"};\n\nstatic const int TraceScreenEvents[] = {KEY_F(3), KEY_F(4), KEY_F(8), KEY_F(9), 27};\n\nTraceScreen* TraceScreen_new(const Process* process) {\n   // This initializes all TraceScreen variables to \"false\" so only default = true ones need to be set below\n   TraceScreen* this = xCalloc(1, sizeof(TraceScreen));\n   Object_setClass(this, Class(TraceScreen));\n   this->tracing = true;\n   this->strace_alive = false;\n   FunctionBar* fuBar = FunctionBar_new(TraceScreenFunctions, TraceScreenKeys, TraceScreenEvents);\n   CRT_disableDelay();\n   return (TraceScreen*) InfoScreen_init(&this->super, process, fuBar, LINES - 2, \" \");\n}\n\nvoid TraceScreen_delete(Object* cast) {\n   TraceScreen* this = (TraceScreen*) cast;\n   if (this->child > 0) {\n      kill(this->child, SIGTERM);\n      while (waitpid(this->child, NULL, 0) == -1)\n         if (errno != EINTR)\n            break;\n   }\n\n   if (this->strace) {\n      fclose(this->strace);\n   }\n\n   CRT_enableDelay();\n   free(InfoScreen_done((InfoScreen*)this));\n}\n\nstatic void TraceScreen_draw(InfoScreen* this) {\n   InfoScreen_drawTitled(this, \"Trace of process %d - %s\", Process_getPid(this->process), Process_getCommand(this->process));\n}\n\nbool TraceScreen_forkTracer(TraceScreen* this) {\n   int fdpair[2] = {0, 0};\n\n   if (pipe(fdpair) == -1)\n      return false;\n\n   if (fcntl(fdpair[0], F_SETFL, O_NONBLOCK) < 0)\n      goto err;\n\n   if (fcntl(fdpair[1], F_SETFL, O_NONBLOCK) < 0)\n      goto err;\n\n   pid_t child = fork();\n   if (child == -1)\n      goto err;\n\n   if (child == 0) {\n      close(fdpair[0]);\n\n      dup2(fdpair[1], STDOUT_FILENO);\n      dup2(fdpair[1], STDERR_FILENO);\n      close(fdpair[1]);\n\n      char buffer[32] = {0};\n      xSnprintf(buffer, sizeof(buffer), \"%d\", Process_getPid(this->super.process));\n\n      #if defined(HTOP_FREEBSD) || defined(HTOP_OPENBSD) || defined(HTOP_NETBSD) || defined(HTOP_DRAGONFLYBSD) || defined(HTOP_SOLARIS)\n         // Use of NULL in variadic functions must have a pointer cast.\n         // The NULL constant is not required by standard to have a pointer type.\n         execlp(\"truss\", \"truss\", \"-s\", \"512\", \"-p\", buffer, (void*)NULL);\n\n         // Should never reach here, unless execlp fails ...\n         const char* message = \"Could not execute 'truss'. Please make sure it is available in your $PATH.\";\n         (void)! write(STDERR_FILENO, message, strlen(message));\n      #elif defined(HTOP_LINUX)\n         execlp(\"strace\", \"strace\", \"-T\", \"-tt\", \"-s\", \"512\", \"-p\", buffer, (void*)NULL);\n\n         // Should never reach here, unless execlp fails ...\n         const char* message = \"Could not execute 'strace'. Please make sure it is available in your $PATH.\";\n         (void)! write(STDERR_FILENO, message, strlen(message));\n      #else // HTOP_DARWIN, HTOP_PCP == HTOP_UNSUPPORTED\n         const char* message = \"Tracing unavailable on not supported system.\";\n         (void)! write(STDERR_FILENO, message, strlen(message));\n      #endif\n\n      exit(127);\n   }\n\n   FILE* fp = fdopen(fdpair[0], \"r\");\n   if (!fp)\n      goto err;\n\n   close(fdpair[1]);\n\n   this->child = child;\n   this->strace = fp;\n   this->strace_alive = true;\n\n   return true;\n\nerr:\n   close(fdpair[1]);\n   close(fdpair[0]);\n   return false;\n}\n\nstatic void TraceScreen_updateTrace(InfoScreen* super) {\n   TraceScreen* this = (TraceScreen*) super;\n\n   int fd_strace = fileno(this->strace);\n\n   fd_set fds;\n   FD_ZERO(&fds);\n   FD_SET(STDIN_FILENO, &fds);\n   if (this->strace_alive) {\n      assert(fd_strace != -1);\n      FD_SET(fd_strace, &fds);\n   }\n\n   struct timeval tv = { .tv_sec = 0, .tv_usec = 500 };\n   int ready = select(MAXIMUM(STDIN_FILENO, fd_strace) + 1, &fds, NULL, NULL, &tv);\n\n   char buffer[1025];\n   size_t nread = 0;\n   if (ready > 0 && FD_ISSET(fd_strace, &fds))\n      nread = fread(buffer, 1, sizeof(buffer) - 1, this->strace);\n\n   if (nread && this->tracing) {\n      const char* line = buffer;\n      buffer[nread] = '\\0';\n      for (size_t i = 0; i < nread; i++) {\n         if (buffer[i] == '\\n') {\n            buffer[i] = '\\0';\n            if (this->contLine) {\n               InfoScreen_appendLine(&this->super, line);\n               this->contLine = false;\n            } else {\n               InfoScreen_addLine(&this->super, line);\n            }\n            line = buffer + i + 1;\n         }\n      }\n      if (line < buffer + nread) {\n         InfoScreen_addLine(&this->super, line);\n         buffer[nread] = '\\0';\n         this->contLine = true;\n      }\n      if (this->follow) {\n         Panel_setSelected(this->super.display, Panel_size(this->super.display) - 1);\n      }\n   } else {\n      if (this->strace_alive && waitpid(this->child, NULL, WNOHANG) != 0)\n         this->strace_alive = false;\n   }\n}\n\nstatic bool TraceScreen_onKey(InfoScreen* super, int ch) {\n   TraceScreen* this = (TraceScreen*) super;\n\n   switch (ch) {\n      case 'f':\n      case KEY_F(8):\n         this->follow = !(this->follow);\n         if (this->follow)\n            Panel_setSelected(super->display, Panel_size(super->display) - 1);\n         return true;\n      case 't':\n      case KEY_F(9):\n         this->tracing = !this->tracing;\n         FunctionBar_setLabel(super->display->defaultBar, KEY_F(9), this->tracing ? \"Stop Tracing   \" : \"Resume Tracing \");\n         InfoScreen_draw(this);\n         return true;\n   }\n\n   this->follow = false;\n   return false;\n}\n\nconst InfoScreenClass TraceScreen_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = TraceScreen_delete\n   },\n   .draw = TraceScreen_draw,\n   .onErr = TraceScreen_updateTrace,\n   .onKey = TraceScreen_onKey,\n};\n"
        },
        {
          "name": "TraceScreen.h",
          "type": "blob",
          "size": 0.701171875,
          "content": "#ifndef HEADER_TraceScreen\n#define HEADER_TraceScreen\n/*\nhtop - TraceScreen.h\n(C) 2005-2006 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#include \"InfoScreen.h\"\n#include \"Object.h\"\n#include \"Process.h\"\n\n\ntypedef struct TraceScreen_ {\n   InfoScreen super;\n   bool tracing;\n   pid_t child;\n   FILE* strace;\n   bool contLine;\n   bool follow;\n   bool strace_alive;\n} TraceScreen;\n\n\nextern const InfoScreenClass TraceScreen_class;\n\nTraceScreen* TraceScreen_new(const Process* process);\n\nvoid TraceScreen_delete(Object* cast);\n\nbool TraceScreen_forkTracer(TraceScreen* this);\n\n#endif\n"
        },
        {
          "name": "UptimeMeter.c",
          "type": "blob",
          "size": 1.55078125,
          "content": "/*\nhtop - UptimeMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"UptimeMeter.h\"\n\n#include \"CRT.h\"\n#include \"Object.h\"\n#include \"Platform.h\"\n#include \"XUtils.h\"\n\n\nstatic const int UptimeMeter_attributes[] = {\n   UPTIME\n};\n\nstatic void UptimeMeter_updateValues(Meter* this) {\n   int totalseconds = Platform_getUptime();\n   if (totalseconds <= 0) {\n      xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"(unknown)\");\n      return;\n   }\n   int seconds = totalseconds % 60;\n   int minutes = (totalseconds / 60) % 60;\n   int hours = (totalseconds / 3600) % 24;\n   int days = (totalseconds / 86400);\n\n   char daysbuf[32];\n   if (days > 100) {\n      xSnprintf(daysbuf, sizeof(daysbuf), \"%d days(!), \", days);\n   } else if (days > 1) {\n      xSnprintf(daysbuf, sizeof(daysbuf), \"%d days, \", days);\n   } else if (days == 1) {\n      xSnprintf(daysbuf, sizeof(daysbuf), \"1 day, \");\n   } else {\n      daysbuf[0] = '\\0';\n   }\n   xSnprintf(this->txtBuffer, sizeof(this->txtBuffer), \"%s%02d:%02d:%02d\", daysbuf, hours, minutes, seconds);\n}\n\nconst MeterClass UptimeMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = UptimeMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .supportedModes = (1 << TEXT_METERMODE) | (1 << LED_METERMODE),\n   .maxItems = 0,\n   .total = 0.0,\n   .attributes = UptimeMeter_attributes,\n   .name = \"Uptime\",\n   .uiName = \"Uptime\",\n   .caption = \"Uptime: \"\n};\n"
        },
        {
          "name": "UptimeMeter.h",
          "type": "blob",
          "size": 0.2783203125,
          "content": "#ifndef HEADER_UptimeMeter\n#define HEADER_UptimeMeter\n/*\nhtop - UptimeMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n\nextern const MeterClass UptimeMeter_class;\n\n#endif\n"
        },
        {
          "name": "UsersTable.c",
          "type": "blob",
          "size": 1.03515625,
          "content": "/*\nhtop - UsersTable.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"UsersTable.h\"\n\n#include <pwd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"XUtils.h\"\n\n\nUsersTable* UsersTable_new(void) {\n   UsersTable* this;\n   this = xMalloc(sizeof(UsersTable));\n   this->users = Hashtable_new(10, true);\n   return this;\n}\n\nvoid UsersTable_delete(UsersTable* this) {\n   Hashtable_delete(this->users);\n   free(this);\n}\n\nchar* UsersTable_getRef(UsersTable* this, unsigned int uid) {\n   char* name = Hashtable_get(this->users, uid);\n   if (name == NULL) {\n      const struct passwd* userData = getpwuid(uid);\n      if (userData != NULL) {\n         name = xStrdup(userData->pw_name);\n         Hashtable_put(this->users, uid, name);\n      }\n   }\n   return name;\n}\n\ninline void UsersTable_foreach(UsersTable* this, Hashtable_PairFunction f, void* userData) {\n   Hashtable_foreach(this->users, f, userData);\n}\n"
        },
        {
          "name": "UsersTable.h",
          "type": "blob",
          "size": 0.5205078125,
          "content": "#ifndef HEADER_UsersTable\n#define HEADER_UsersTable\n/*\nhtop - UsersTable.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Hashtable.h\"\n\n\ntypedef struct UsersTable_ {\n   Hashtable* users;\n} UsersTable;\n\nUsersTable* UsersTable_new(void);\n\nvoid UsersTable_delete(UsersTable* this);\n\nchar* UsersTable_getRef(UsersTable* this, unsigned int uid);\n\nvoid UsersTable_foreach(UsersTable* this, Hashtable_PairFunction f, void* userData);\n\n#endif\n"
        },
        {
          "name": "Vector.c",
          "type": "blob",
          "size": 10.103515625,
          "content": "/*\nhtop - Vector.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"Vector.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"XUtils.h\"\n\n\nVector* Vector_new(const ObjectClass* type, bool owner, int size) {\n   Vector* this;\n\n   if (size == DEFAULT_SIZE) {\n      size = 10;\n   }\n\n   assert(size > 0);\n   this = xMalloc(sizeof(Vector));\n   *this = (Vector) {\n      .growthRate = size,\n      .array = xCalloc(size, sizeof(Object*)),\n      .arraySize = size,\n      .items = 0,\n      .type = type,\n      .owner = owner,\n      .dirty_index = -1,\n      .dirty_count = 0,\n   };\n   return this;\n}\n\nvoid Vector_delete(Vector* this) {\n   if (this->owner) {\n      for (int i = 0; i < this->items; i++) {\n         if (this->array[i]) {\n            Object_delete(this->array[i]);\n         }\n      }\n   }\n   free(this->array);\n   free(this);\n}\n\nstatic inline bool Vector_isDirty(const Vector* this) {\n   if (this->dirty_count > 0) {\n      assert(0 <= this->dirty_index && this->dirty_index < this->items);\n      assert(this->dirty_count <= this->items);\n      return true;\n   }\n   assert(this->dirty_index == -1);\n   return false;\n}\n\n#ifndef NDEBUG\n\nstatic bool Vector_isConsistent(const Vector* this) {\n   assert(this->items <= this->arraySize);\n   assert(!Vector_isDirty(this));\n\n   return true;\n}\n\nbool Vector_countEquals(const Vector* this, unsigned int expectedCount) {\n   unsigned int n = 0;\n   for (int i = 0; i < this->items; i++) {\n      if (this->array[i]) {\n         n++;\n      }\n   }\n   return n == expectedCount;\n}\n\nObject* Vector_get(const Vector* this, int idx) {\n   assert(idx >= 0 && idx < this->items);\n   assert(this->array[idx]);\n   assert(Object_isA(this->array[idx], this->type));\n   return this->array[idx];\n}\n\nint Vector_size(const Vector* this) {\n   assert(Vector_isConsistent(this));\n   return this->items;\n}\n\n#endif /* NDEBUG */\n\nvoid Vector_prune(Vector* this) {\n   assert(Vector_isConsistent(this));\n   if (this->owner) {\n      for (int i = 0; i < this->items; i++) {\n         if (this->array[i]) {\n            Object_delete(this->array[i]);\n         }\n      }\n   }\n   this->items = 0;\n   this->dirty_index = -1;\n   this->dirty_count = 0;\n   memset(this->array, '\\0', this->arraySize * sizeof(Object*));\n}\n\n//static int comparisons = 0;\n\nstatic void swap(Object** array, int indexA, int indexB) {\n   assert(indexA >= 0);\n   assert(indexB >= 0);\n   Object* tmp = array[indexA];\n   array[indexA] = array[indexB];\n   array[indexB] = tmp;\n}\n\nstatic int partition(Object** array, int left, int right, int pivotIndex, Object_Compare compare) {\n   const Object* pivotValue = array[pivotIndex];\n   swap(array, pivotIndex, right);\n   int storeIndex = left;\n   for (int i = left; i < right; i++) {\n      //comparisons++;\n      if (compare(array[i], pivotValue) <= 0) {\n         swap(array, i, storeIndex);\n         storeIndex++;\n      }\n   }\n   swap(array, storeIndex, right);\n   return storeIndex;\n}\n\nstatic void quickSort(Object** array, int left, int right, Object_Compare compare) {\n   if (left >= right)\n      return;\n\n   int pivotIndex = (left + right) / 2;\n   int pivotNewIndex = partition(array, left, right, pivotIndex, compare);\n   quickSort(array, left, pivotNewIndex - 1, compare);\n   quickSort(array, pivotNewIndex + 1, right, compare);\n}\n\n// If I were to use only one sorting algorithm for both cases, it would probably be this one:\n/*\n\nstatic void combSort(Object** array, int left, int right, Object_Compare compare) {\n   int gap = right - left;\n   bool swapped = true;\n   while ((gap > 1) || swapped) {\n      if (gap > 1) {\n         gap = (int)((double)gap / 1.247330950103979);\n      }\n      swapped = false;\n      for (int i = left; gap + i <= right; i++) {\n         comparisons++;\n         if (compare(array[i], array[i+gap]) > 0) {\n            swap(array, i, i+gap);\n            swapped = true;\n         }\n      }\n   }\n}\n\n*/\n\nstatic void insertionSort(Object** array, int left, int right, Object_Compare compare) {\n   for (int i = left + 1; i <= right; i++) {\n      Object* t = array[i];\n      int j = i - 1;\n      while (j >= left) {\n         //comparisons++;\n         if (compare(array[j], t) <= 0)\n            break;\n\n         array[j + 1] = array[j];\n         j--;\n      }\n      array[j + 1] = t;\n   }\n}\n\nvoid Vector_quickSortCustomCompare(Vector* this, Object_Compare compare) {\n   assert(compare);\n   assert(Vector_isConsistent(this));\n   quickSort(this->array, 0, this->items - 1, compare);\n   assert(Vector_isConsistent(this));\n}\n\nvoid Vector_insertionSort(Vector* this) {\n   assert(this->type->compare);\n   assert(Vector_isConsistent(this));\n   insertionSort(this->array, 0, this->items - 1, this->type->compare);\n   assert(Vector_isConsistent(this));\n}\n\nstatic void Vector_resizeIfNecessary(Vector* this, int newSize) {\n   assert(newSize >= 0);\n   if (newSize > this->arraySize) {\n      assert(Vector_isConsistent(this));\n      int oldSize = this->arraySize;\n      this->arraySize = newSize + this->growthRate;\n      this->array = (Object**)xReallocArrayZero(this->array, oldSize, this->arraySize, sizeof(Object*));\n   }\n   assert(Vector_isConsistent(this));\n}\n\nvoid Vector_insert(Vector* this, int idx, void* data_) {\n   Object* data = data_;\n   assert(idx >= 0);\n   assert(Object_isA(data, this->type));\n   assert(Vector_isConsistent(this));\n\n   if (idx > this->items) {\n      idx = this->items;\n   }\n\n   Vector_resizeIfNecessary(this, this->items + 1);\n   //assert(this->array[this->items] == NULL);\n   if (idx < this->items) {\n      memmove(&this->array[idx + 1], &this->array[idx], (this->items - idx) * sizeof(this->array[0]));\n   }\n   this->array[idx] = data;\n   this->items++;\n   assert(Vector_isConsistent(this));\n}\n\nObject* Vector_take(Vector* this, int idx) {\n   assert(idx >= 0 && idx < this->items);\n   assert(Vector_isConsistent(this));\n   Object* removed = this->array[idx];\n   assert(removed);\n   this->items--;\n   if (idx < this->items) {\n      memmove(&this->array[idx], &this->array[idx + 1], (this->items - idx) * sizeof(this->array[0]));\n   }\n   this->array[this->items] = NULL;\n   assert(Vector_isConsistent(this));\n   return removed;\n}\n\nObject* Vector_remove(Vector* this, int idx) {\n   Object* removed = Vector_take(this, idx);\n   if (this->owner) {\n      Object_delete(removed);\n      return NULL;\n   } else {\n      return removed;\n   }\n}\n\nObject* Vector_softRemove(Vector* this, int idx) {\n   assert(idx >= 0 && idx < this->items);\n\n   Object* removed = this->array[idx];\n   assert(removed);\n   if (removed) {\n      this->array[idx] = NULL;\n\n      this->dirty_count++;\n      if (this->dirty_index < 0 || idx < this->dirty_index) {\n         this->dirty_index = idx;\n      }\n\n      if (this->owner) {\n         Object_delete(removed);\n         return NULL;\n      }\n   }\n\n   return removed;\n}\n\nvoid Vector_compact(Vector* this) {\n   if (!Vector_isDirty(this)) {\n      return;\n   }\n\n   const int size = this->items;\n   assert(0 <= this->dirty_index && this->dirty_index < size);\n   assert(this->array[this->dirty_index] == NULL);\n\n   int idx = this->dirty_index;\n\n   // one deletion: use memmove, which should be faster\n   if (this->dirty_count == 1) {\n      memmove(&this->array[idx], &this->array[idx + 1], (this->items - idx - 1) * sizeof(this->array[0]));\n      this->array[this->items - 1] = NULL;\n   } else {\n      // multiple deletions\n      for (int i = idx + 1; i < size; i++) {\n         if (this->array[i]) {\n            this->array[idx++] = this->array[i];\n         }\n      }\n      // idx is now at the end of the vector and on the first index which should be set to NULL\n      memset(&this->array[idx], '\\0', (size - idx) * sizeof(this->array[0]));\n   }\n\n   this->items -= this->dirty_count;\n   this->dirty_index = -1;\n   this->dirty_count = 0;\n\n   assert(Vector_isConsistent(this));\n}\n\nvoid Vector_moveUp(Vector* this, int idx) {\n   assert(idx >= 0 && idx < this->items);\n   assert(Vector_isConsistent(this));\n\n   if (idx == 0)\n      return;\n\n   Object* temp = this->array[idx];\n   this->array[idx] = this->array[idx - 1];\n   this->array[idx - 1] = temp;\n}\n\nvoid Vector_moveDown(Vector* this, int idx) {\n   assert(idx >= 0 && idx < this->items);\n   assert(Vector_isConsistent(this));\n\n   if (idx == this->items - 1)\n      return;\n\n   Object* temp = this->array[idx];\n   this->array[idx] = this->array[idx + 1];\n   this->array[idx + 1] = temp;\n}\n\nvoid Vector_set(Vector* this, int idx, void* data_) {\n   Object* data = data_;\n   assert(idx >= 0);\n   assert(Object_isA(data, this->type));\n   assert(Vector_isConsistent(this));\n\n   Vector_resizeIfNecessary(this, idx + 1);\n   if (idx >= this->items) {\n      this->items = idx + 1;\n   } else {\n      if (this->owner) {\n         Object* removed = this->array[idx];\n         if (removed != NULL) {\n            Object_delete(removed);\n         }\n      }\n   }\n   this->array[idx] = data;\n   assert(Vector_isConsistent(this));\n}\n\n/*\n\nstatic void Vector_merge(Vector* this, Vector* v2) {\n   int i;\n   assert(Vector_isConsistent(this));\n\n   for (i = 0; i < v2->items; i++)\n      Vector_add(this, v2->array[i]);\n   v2->items = 0;\n   Vector_delete(v2);\n   assert(Vector_isConsistent(this));\n}\n\n*/\n\nvoid Vector_add(Vector* this, void* data_) {\n   Object* data = data_;\n   assert(Object_isA(data, this->type));\n   assert(Vector_isConsistent(this));\n   int i = this->items;\n   Vector_set(this, this->items, data);\n   assert(this->items == i + 1); (void)(i);\n   assert(Vector_isConsistent(this));\n}\n\nint Vector_indexOf(const Vector* this, const void* search_, Object_Compare compare) {\n   const Object* search = search_;\n   assert(Object_isA(search, this->type));\n   assert(compare);\n   assert(Vector_isConsistent(this));\n   for (int i = 0; i < this->items; i++) {\n      const Object* o = this->array[i];\n      assert(o);\n      if (compare(search, o) == 0) {\n         return i;\n      }\n   }\n   return -1;\n}\n\nvoid Vector_splice(Vector* this, Vector* from) {\n   assert(Vector_isConsistent(this));\n   assert(Vector_isConsistent(from));\n   assert(!this->owner);\n\n   int olditems = this->items;\n   Vector_resizeIfNecessary(this, this->items + from->items);\n   this->items += from->items;\n   for (int j = 0; j < from->items; j++) {\n      this->array[olditems + j] = from->array[j];\n   }\n}\n"
        },
        {
          "name": "Vector.h",
          "type": "blob",
          "size": 2.458984375,
          "content": "#ifndef HEADER_Vector\n#define HEADER_Vector\n/*\nhtop - Vector.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Object.h\"\n\n#include <stdbool.h>\n\n\n#ifndef DEFAULT_SIZE\n#define DEFAULT_SIZE (-1)\n#endif\n\ntypedef struct Vector_ {\n   Object** array;\n   const ObjectClass* type;\n   int arraySize;\n   int growthRate;\n   int items;\n   /* lowest index of a pending soft remove/delete operation,\n      used to speed up compaction */\n   int dirty_index;\n   /* count of soft deletes, required for Vector_count to work in debug mode */\n   int dirty_count;\n   bool owner;\n} Vector;\n\nVector* Vector_new(const ObjectClass* type, bool owner, int size);\n\nvoid Vector_delete(Vector* this);\n\nvoid Vector_prune(Vector* this);\n\nvoid Vector_quickSortCustomCompare(Vector* this, Object_Compare compare);\nstatic inline void Vector_quickSort(Vector* this) {\n   Vector_quickSortCustomCompare(this, this->type->compare);\n}\n\nvoid Vector_insertionSort(Vector* this);\n\nvoid Vector_insert(Vector* this, int idx, void* data_);\n\nObject* Vector_take(Vector* this, int idx);\n\nObject* Vector_remove(Vector* this, int idx);\n\n/* Vector_softRemove marks the item at index idx for deletion without\n   reclaiming any space. If owned, the item is immediately freed.\n\n   Vector_compact must be called to reclaim space.*/\nObject* Vector_softRemove(Vector* this, int idx);\n\n/* Vector_compact reclaims space free'd up by Vector_softRemove, if any. */\nvoid Vector_compact(Vector* this);\n\nvoid Vector_moveUp(Vector* this, int idx);\n\nvoid Vector_moveDown(Vector* this, int idx);\n\nvoid Vector_set(Vector* this, int idx, void* data_);\n\n#ifndef NDEBUG\n\nObject* Vector_get(const Vector* this, int idx);\nint Vector_size(const Vector* this);\n\n/* Vector_countEquals returns true if the number of non-NULL items\n   in the Vector is equal to expectedCount. This is only for debugging\n   and consistency checks. */\nbool Vector_countEquals(const Vector* this, unsigned int expectedCount);\n\n#else /* NDEBUG */\n\nstatic inline Object* Vector_get(const Vector* this, int idx) {\n   return this->array[idx];\n}\n\nstatic inline int Vector_size(const Vector* this) {\n   return this->items;\n}\n\n#endif /* NDEBUG */\n\nstatic inline const ObjectClass* Vector_type(const Vector* this) {\n   return this->type;\n}\n\nvoid Vector_add(Vector* this, void* data_);\n\nint Vector_indexOf(const Vector* this, const void* search_, Object_Compare compare);\n\nvoid Vector_splice(Vector* this, Vector* from);\n\n#endif\n"
        },
        {
          "name": "XUtils.c",
          "type": "blob",
          "size": 8.828125,
          "content": "/*\nhtop - StringUtils.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"XUtils.h\"\n\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"CRT.h\"\n#include \"Macros.h\"\n\n\nvoid fail(void) {\n   CRT_done();\n   abort();\n\n   _exit(1); // Should never reach here\n}\n\nvoid* xMalloc(size_t size) {\n   assert(size > 0);\n   void* data = malloc(size);\n   if (!data) {\n      fail();\n   }\n   return data;\n}\n\nvoid* xMallocArray(size_t nmemb, size_t size) {\n   assert(nmemb > 0);\n   assert(size > 0);\n   if (SIZE_MAX / nmemb < size) {\n      fail();\n   }\n   return xMalloc(nmemb * size);\n}\n\nvoid* xCalloc(size_t nmemb, size_t size) {\n   assert(nmemb > 0);\n   assert(size > 0);\n   if (SIZE_MAX / nmemb < size) {\n      fail();\n   }\n   void* data = calloc(nmemb, size);\n   if (!data) {\n      fail();\n   }\n   return data;\n}\n\nvoid* xRealloc(void* ptr, size_t size) {\n   assert(size > 0);\n   void* data = realloc(ptr, size);\n   if (!data) {\n      /* free'ing ptr here causes an indirect memory leak if pointers\n       * are held as part of an potential array referenced in ptr.\n       * In GCC 14 -fanalyzer recognizes this leak, but fails to\n       * ignore it given that this path ends in a noreturn function.\n       * Thus to avoid this confusing diagnostic we opt to leave\n       * that pointer alone instead.\n       */\n      // free(ptr);\n      fail();\n   }\n   return data;\n}\n\nvoid* xReallocArray(void* ptr, size_t nmemb, size_t size) {\n   assert(nmemb > 0);\n   assert(size > 0);\n   if (SIZE_MAX / nmemb < size) {\n      fail();\n   }\n   return xRealloc(ptr, nmemb * size);\n}\n\nvoid* xReallocArrayZero(void* ptr, size_t prevmemb, size_t newmemb, size_t size) {\n   assert((ptr == NULL) == (prevmemb == 0));\n\n   if (prevmemb == newmemb) {\n      return ptr;\n   }\n\n   void* ret = xReallocArray(ptr, newmemb, size);\n\n   if (newmemb > prevmemb) {\n      memset((unsigned char*)ret + prevmemb * size, '\\0', (newmemb - prevmemb) * size);\n   }\n\n   return ret;\n}\n\ninline bool String_contains_i(const char* s1, const char* s2, bool multi) {\n   // we have a multi-string search term, handle as special case for performance reasons\n   if (multi && strstr(s2, \"|\")) {\n      size_t nNeedles;\n      char** needles = String_split(s2, '|', &nNeedles);\n      for (size_t i = 0; i < nNeedles; i++) {\n         if (strcasestr(s1, needles[i]) != NULL) {\n            String_freeArray(needles);\n            return true;\n         }\n      }\n      String_freeArray(needles);\n      return false;\n   } else {\n      return strcasestr(s1, s2) != NULL;\n   }\n}\n\nchar* String_cat(const char* s1, const char* s2) {\n   const size_t l1 = strlen(s1);\n   const size_t l2 = strlen(s2);\n   if (SIZE_MAX - l1 <= l2) {\n      fail();\n   }\n   char* out = xMalloc(l1 + l2 + 1);\n   memcpy(out, s1, l1);\n   memcpy(out + l1, s2, l2);\n   out[l1 + l2] = '\\0';\n   return out;\n}\n\nchar* String_trim(const char* in) {\n   while (in[0] == ' ' || in[0] == '\\t' || in[0] == '\\n') {\n      in++;\n   }\n\n   size_t len = strlen(in);\n   while (len > 0 && (in[len - 1] == ' ' || in[len - 1] == '\\t' || in[len - 1] == '\\n')) {\n      len--;\n   }\n\n   return xStrndup(in, len);\n}\n\nchar** String_split(const char* s, char sep, size_t* n) {\n   const size_t rate = 10;\n   char** out = xCalloc(rate, sizeof(char*));\n   size_t ctr = 0;\n   size_t blocks = rate;\n   const char* where;\n   while ((where = strchr(s, sep)) != NULL) {\n      size_t size = (size_t)(where - s);\n      out[ctr] = xStrndup(s, size);\n      ctr++;\n      if (ctr == blocks) {\n         blocks += rate;\n         out = (char**) xRealloc(out, sizeof(char*) * blocks);\n      }\n      s += size + 1;\n   }\n   if (s[0] != '\\0') {\n      out[ctr] = xStrdup(s);\n      ctr++;\n   }\n   out = xRealloc(out, sizeof(char*) * (ctr + 1));\n   out[ctr] = NULL;\n\n   if (n)\n      *n = ctr;\n\n   return out;\n}\n\nvoid String_freeArray(char** s) {\n   if (!s) {\n      return;\n   }\n   for (size_t i = 0; s[i] != NULL; i++) {\n      free(s[i]);\n   }\n   free(s);\n}\n\nchar* String_readLine(FILE* fp) {\n   const size_t step = 1024;\n   size_t bufSize = step;\n   char* buffer = xMalloc(step + 1);\n   char* at = buffer;\n   for (;;) {\n      const char* ok = fgets(at, step + 1, fp);\n      if (!ok) {\n         free(buffer);\n         return NULL;\n      }\n      char* newLine = strrchr(at, '\\n');\n      if (newLine) {\n         *newLine = '\\0';\n         return buffer;\n      } else {\n         if (feof(fp)) {\n            return buffer;\n         }\n      }\n      bufSize += step;\n      buffer = xRealloc(buffer, bufSize + 1);\n      at = buffer + bufSize - step;\n   }\n}\n\nsize_t String_safeStrncpy(char* restrict dest, const char* restrict src, size_t size) {\n   assert(size > 0);\n\n   size_t i = 0;\n   for (; i < size - 1 && src[i]; i++)\n      dest[i] = src[i];\n\n   dest[i] = '\\0';\n\n   return i;\n}\n\nint xAsprintf(char** strp, const char* fmt, ...) {\n   va_list vl;\n   va_start(vl, fmt);\n   int r = vasprintf(strp, fmt, vl);\n   va_end(vl);\n\n   if (r < 0 || !*strp) {\n      fail();\n   }\n\n   return r;\n}\n\nint xSnprintf(char* buf, size_t len, const char* fmt, ...) {\n   assert(len > 0);\n\n   va_list vl;\n   va_start(vl, fmt);\n   int n = vsnprintf(buf, len, fmt, vl);\n   va_end(vl);\n\n   if (n < 0 || (size_t)n >= len) {\n      fail();\n   }\n\n   return n;\n}\n\nchar* xStrdup(const char* str) {\n   char* data = strdup(str);\n   if (!data) {\n      fail();\n   }\n   return data;\n}\n\nvoid free_and_xStrdup(char** ptr, const char* str) {\n   if (*ptr && String_eq(*ptr, str))\n      return;\n\n   free(*ptr);\n   *ptr = xStrdup(str);\n}\n\nchar* xStrndup(const char* str, size_t len) {\n   char* data = strndup(str, len);\n   if (!data) {\n      fail();\n   }\n   return data;\n}\n\nATTR_ACCESS3_W(2, 3)\nstatic ssize_t readfd_internal(int fd, void* buffer, size_t count) {\n   if (!count) {\n      close(fd);\n      return -EINVAL;\n   }\n\n   ssize_t alreadyRead = 0;\n   count--; // reserve one for null-terminator\n\n   for (;;) {\n      ssize_t res = read(fd, buffer, count);\n      if (res == -1) {\n         if (errno == EINTR)\n            continue;\n\n         close(fd);\n         *((char*)buffer) = '\\0';\n         return -errno;\n      }\n\n      if (res > 0) {\n         assert((size_t)res <= count);\n\n         buffer = ((char*)buffer) + res;\n         count -= (size_t)res;\n         alreadyRead += res;\n      }\n\n      if (count == 0 || res == 0) {\n         close(fd);\n         *((char*)buffer) = '\\0';\n         return alreadyRead;\n      }\n   }\n}\n\nssize_t xReadfile(const char* pathname, void* buffer, size_t count) {\n   int fd = open(pathname, O_RDONLY);\n   if (fd < 0)\n      return -errno;\n\n   return readfd_internal(fd, buffer, count);\n}\n\nssize_t xReadfileat(openat_arg_t dirfd, const char* pathname, void* buffer, size_t count) {\n   int fd = Compat_openat(dirfd, pathname, O_RDONLY);\n   if (fd < 0)\n      return -errno;\n\n   return readfd_internal(fd, buffer, count);\n}\n\nssize_t full_write(int fd, const void* buf, size_t count) {\n   ssize_t written = 0;\n\n   while (count > 0) {\n      ssize_t r = write(fd, buf, count);\n      if (r < 0) {\n         if (errno == EINTR)\n            continue;\n\n         return r;\n      }\n\n      if (r == 0)\n         break;\n\n      written += r;\n      buf = (const unsigned char*)buf + r;\n      count -= (size_t)r;\n   }\n\n   return written;\n}\n\n/* Compares floating point values for ordering data entries. In this function,\n   NaN is considered \"less than\" any other floating point value (regardless of\n   sign), and two NaNs are considered \"equal\" regardless of payload. */\nint compareRealNumbers(double a, double b) {\n   int result = isgreater(a, b) - isgreater(b, a);\n   if (result)\n      return result;\n   return !isNaN(a) - !isNaN(b);\n}\n\n/* Computes the sum of all positive floating point values in an array.\n   NaN values in the array are skipped. The returned sum will always be\n   nonnegative. */\ndouble sumPositiveValues(const double* array, size_t count) {\n   double sum = 0.0;\n   for (size_t i = 0; i < count; i++) {\n      if (isPositive(array[i]))\n         sum += array[i];\n   }\n   return sum;\n}\n\n/* Counts the number of digits needed to print \"n\" with a given base.\n   If \"n\" is zero, returns 1. This function expects small numbers to\n   appear often, hence it uses a O(log(n)) time algorithm. */\nsize_t countDigits(size_t n, size_t base) {\n   assert(base > 1);\n   size_t res = 1;\n   for (size_t limit = base; n >= limit; limit *= base) {\n      res++;\n      if (base && limit > SIZE_MAX / base) {\n         break;\n      }\n   }\n   return res;\n}\n\n#if !defined(HAVE_BUILTIN_CTZ)\n// map a bit value mod 37 to its position\nstatic const uint8_t mod37BitPosition[] = {\n  32, 0, 1, 26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11, 0, 13, 4,\n  7, 17, 0, 25, 22, 31, 15, 29, 10, 12, 6, 0, 21, 14, 9, 5,\n  20, 8, 19, 18\n};\n\n/* Returns the number of trailing zero bits */\nunsigned int countTrailingZeros(unsigned int x) {\n   return mod37BitPosition[(-x & x) % 37];\n}\n#endif\n"
        },
        {
          "name": "XUtils.h",
          "type": "blob",
          "size": 5.0205078125,
          "content": "#ifndef HEADER_XUtils\n#define HEADER_XUtils\n/*\nhtop - StringUtils.h\n(C) 2004-2011 Hisham H. Muhammad\n(C) 2020-2023 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n// IWYU pragma: no_include \"config.h\"\n#ifndef PACKAGE\n// strchrnul() needs _GNU_SOURCE defined, see PR #1337 for details\n#error \"Must have #include \\\"config.h\\\" line at the top of the file that includes these XUtils helper functions\"\n#endif\n\n#include <dirent.h>\n#include <stdbool.h>\n#include <stddef.h> // IWYU pragma: keep\n#include <stdio.h>\n#include <stdlib.h> // IWYU pragma: keep\n#include <string.h> // IWYU pragma: keep\n\n#include \"Compat.h\"\n#include \"Macros.h\"\n\n\nATTR_NORETURN\nvoid fail(void);\n\nATTR_RETNONNULL ATTR_MALLOC ATTR_ALLOC_SIZE1(1)\nvoid* xMalloc(size_t size);\n\nATTR_RETNONNULL ATTR_MALLOC ATTR_ALLOC_SIZE2(1, 2)\nvoid* xMallocArray(size_t nmemb, size_t size);\n\nATTR_RETNONNULL ATTR_MALLOC ATTR_ALLOC_SIZE2(1, 2)\nvoid* xCalloc(size_t nmemb, size_t size);\n\nATTR_RETNONNULL ATTR_ALLOC_SIZE1(2)\nvoid* xRealloc(void* ptr, size_t size);\n\nATTR_RETNONNULL ATTR_ALLOC_SIZE2(2, 3)\nvoid* xReallocArray(void* ptr, size_t nmemb, size_t size);\n\nATTR_RETNONNULL ATTR_ALLOC_SIZE2(3, 4)\nvoid* xReallocArrayZero(void* ptr, size_t prevmemb, size_t newmemb, size_t size);\n\n/*\n * String_startsWith gives better performance if strlen(match) can be computed\n * at compile time (e.g. when they are immutable string literals). :)\n */\nATTR_NONNULL\nstatic inline bool String_startsWith(const char* s, const char* match) {\n   return strncmp(s, match, strlen(match)) == 0;\n}\n\nbool String_contains_i(const char* s1, const char* s2, bool multi);\n\nATTR_NONNULL\nstatic inline bool String_eq(const char* s1, const char* s2) {\n   return strcmp(s1, s2) == 0;\n}\n\nstatic inline bool String_eq_nullable(const char* s1, const char* s2) {\n   if (s1 == s2)\n      return true;\n\n   if (s1 && s2)\n      return String_eq(s1, s2);\n\n   return false;\n}\n\nATTR_NONNULL ATTR_RETNONNULL ATTR_MALLOC\nchar* String_cat(const char* s1, const char* s2);\n\nATTR_NONNULL ATTR_RETNONNULL ATTR_MALLOC\nchar* String_trim(const char* in);\n\nATTR_NONNULL_N(1) ATTR_RETNONNULL\nchar** String_split(const char* s, char sep, size_t* n);\n\nvoid String_freeArray(char** s);\n\nATTR_NONNULL ATTR_MALLOC\nchar* String_readLine(FILE* fp);\n\nATTR_NONNULL ATTR_RETNONNULL\nstatic inline char* String_strchrnul(const char* s, int c) {\n#ifdef HAVE_STRCHRNUL\n   return strchrnul(s, c);\n#else\n   char* result = strchr(s, c);\n   if (result)\n      return result;\n   return strchr(s, '\\0');\n#endif\n}\n\n/* Always null-terminates dest. Caller must pass a strictly positive size. */\nATTR_NONNULL ATTR_ACCESS3_W(1, 3) ATTR_ACCESS3_R(2, 3)\nsize_t String_safeStrncpy(char* restrict dest, const char* restrict src, size_t size);\n\nATTR_FORMAT(printf, 2, 3) ATTR_NONNULL_N(1, 2)\nint xAsprintf(char** strp, const char* fmt, ...);\n\nATTR_FORMAT(printf, 3, 4) ATTR_NONNULL_N(1, 3) ATTR_ACCESS3_W(1, 2)\nint xSnprintf(char* buf, size_t len, const char* fmt, ...);\n\nATTR_NONNULL ATTR_RETNONNULL ATTR_MALLOC\nchar* xStrdup(const char* str);\n\nATTR_NONNULL\nvoid free_and_xStrdup(char** ptr, const char* str);\n\nATTR_NONNULL ATTR_RETNONNULL ATTR_MALLOC ATTR_ACCESS3_R(1, 2)\nchar* xStrndup(const char* str, size_t len);\n\nATTR_NONNULL ATTR_ACCESS3_W(2, 3)\nssize_t xReadfile(const char* pathname, void* buffer, size_t count);\nATTR_NONNULL ATTR_ACCESS3_W(3, 4)\nssize_t xReadfileat(openat_arg_t dirfd, const char* pathname, void* buffer, size_t count);\n\nATTR_NONNULL ATTR_ACCESS3_R(2, 3)\nssize_t full_write(int fd, const void* buf, size_t count);\n\nATTR_NONNULL\nstatic inline ssize_t full_write_str(int fd, const char* str) {\n   return full_write(fd, str, strlen(str));\n}\n\n/* Compares floating point values for ordering data entries. In this function,\n   NaN is considered \"less than\" any other floating point value (regardless of\n   sign), and two NaNs are considered \"equal\" regardless of payload. */\nint compareRealNumbers(double a, double b);\n\n/* Computes the sum of all positive floating point values in an array.\n   NaN values in the array are skipped. The returned sum will always be\n   nonnegative. */\nATTR_NONNULL ATTR_ACCESS3_R(1, 2)\ndouble sumPositiveValues(const double* array, size_t count);\n\n/* Counts the number of digits needed to print \"n\" with a given base.\n   If \"n\" is zero, returns 1. This function expects small numbers to\n   appear often, hence it uses a O(log(n)) time algorithm. */\nsize_t countDigits(size_t n, size_t base);\n\n/* Returns the number of trailing zero bits */\n#if defined(HAVE_BUILTIN_CTZ)\nstatic inline unsigned int countTrailingZeros(unsigned int x) {\n   return !x ? 32 : __builtin_ctz(x);\n}\n#else\nunsigned int countTrailingZeros(unsigned int x);\n#endif\n\n/* IEC unit prefixes */\nstatic const char unitPrefixes[] = { 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y', 'R', 'Q' };\n\nstatic inline bool skipEndOfLine(FILE* fp) {\n   char buffer[1024];\n   while (fgets(buffer, sizeof(buffer), fp)) {\n      if (strchr(buffer, '\\n')) {\n         return true;\n      }\n   }\n   return false;\n}\n\nstatic inline int xDirfd(DIR* dirp) {\n   int r = dirfd(dirp);\n   assert(r >= 0);\n   return r;\n}\n\n#endif\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.0537109375,
          "content": "#!/bin/sh\nautoreconf --force --install --verbose -Wall\n"
        },
        {
          "name": "check-pcp-style.sh",
          "type": "blob",
          "size": 5.3125,
          "content": "#!/bin/bash\n\nset -eu -o pipefail\n\nPCP_DIR=\"$(dirname \"$0\")/pcp\"\n\nif [ ! -d \"${PCP_DIR}\" ]; then\n   echo Could not find PCP platform sources. >&2\n   exit 1\nfi\n\necho Scanning definitions in ${PCP_DIR} ...\n\nPCP_COLUMNS=\"${PCP_DIR}/columns\"\nPCP_METERS=\"${PCP_DIR}/meters\"\nPCP_SCREENS=\"${PCP_DIR}/screens\"\n\nif [ ! -d \"${PCP_COLUMNS}\" ]; then\n   echo Could not find PCP column definitions. >&2\n   exit 1\nfi\n\nif [ ! -d \"${PCP_METERS}\" ]; then\n   echo Could not find PCP meter definitions. >&2\n   exit 1\nfi\n\nif [ ! -d \"${PCP_SCREENS}\" ]; then\n   echo Could not find PCP screen definitions. >&2\n   exit 1\nfi\n\ncheck_file() {\n   f=\"$1\"\n   r=\"$2\"\n\n   echo \"Processing $f ...\"\n\n   awk -v required_names_str=\"$2\" '\n      BEGIN {\n         # Define the required names\n         split(required_names_str, required_names)\n         section = \"\"\n      }\n\n      # Skip comment lines\n      /^#/ {\n         next\n      }\n\n      # Detect section headers\n      /^\\[.*\\]$/ {\n         if (section != \"\") {\n            check_section()\n         }\n         section = $0\n         if (section in sections_seen) {\n            print \"Error: Duplicate section \" section\n            exit 1\n         }\n         sections_seen[section] = 1\n         delete seen\n         delete groups\n         next\n      }\n\n      # Process name = value pairs with whitespace around the equals sign\n      /^[^=]+ = [^=]+$/ {\n         split($0, pair, \" = \")\n\n         name = trim(pair[1])\n         value = trim(pair[2])\n         group = \"\"\n\n         known = 0\n         for (i in required_names) {\n            rname = required_names[i]\n            if (rname ~ /\\?$/) {\n               rname = substr(rname, 1, length(rname) - 1)\n            }\n            if (rname ~ /^\\*\\./) {\n               rlname = substr(rname, 2, length(rname) - 1)\n               if (substr(name, length(name) - length(rlname) + 1) == rlname) {\n                  group = substr(name, 1, length(name) - length(rlname) + 1)\n                  known = 1\n                  break\n               }\n            }\n            if (rname == name) {\n               known = 1\n               break\n            }\n         }\n         if (!known) {\n            print \"Error: Unknown name \" name \" in section \" section\n            exit 1\n         }\n\n         if (name in seen) {\n            print \"Error: Duplicate name \" name \" in section \" section\n            exit 1\n         }\n\n         seen[name] = 1\n         groups[group] = 1\n\n         if (name ~ /(^|\\.)width$/) {\n            if (!(value ~ /^-?[0-9]{1,3}$/)) {\n               print \"Error: Specified width \" value \" for \" name \" in section \" section \" is not an integer or out of range (-999..999).\"\n               exit 1\n            }\n         }\n\n         if (name ~ /(^|\\.)type$/) {\n            if (!(value ~ /^(bar|text|graph|led)$/)) {\n               print \"Error: Specified type \" value \" for \" name \" in section \" section \" is not recognized.\"\n               exit 1\n            }\n         }\n\n         if (name ~ /(^|\\.)color$/) {\n            if (!(value ~ /^(black|blue|green|red|cyan|magenta|yellow|(dark)?gray|white)$/)) {\n               print \"Error: Specified color \" value \" for \" name \" in section \" section \" is not recognized.\"\n               exit 1\n            }\n         }\n\n         next\n      }\n\n      # Function to trim whitespace\n      function trim(s) {\n         gsub(/^[ \\t]+|[ \\t]+$/, \"\", s)\n         return s\n      }\n\n      # Function to check if all required names are present\n      function check_section() {\n         missing = \"\"\n         for (i in required_names) {\n            rname = required_names[i]\n            if (rname ~ /\\?$/) {\n               continue\n            }\n            if (rname ~ /^\\*\\./) {\n               rname = substr(rname, 3, length(rname) - 2)\n               for (g in groups) {\n                  if (g == \"\") {\n                     continue\n                  }\n                  if (!(g rname in seen)) {\n                     missing = missing g rname \" \"\n                  }\n               }\n               continue\n            }\n            if (!(rname in seen)) {\n               missing = missing rname \" \"\n            }\n         }\n         if (missing != \"\") {\n            print \"Error: Missing \" missing \"in section \" section\n            exit 1\n         }\n      }\n\n      # End of file processing\n      END {\n         if (section != \"\") {\n            check_section()\n         }\n\n         # Ensure the file ends with a single newline\n         if (NR > 0 && length($0) < 1) {\n            print \"Error: Whitespace at EOF.\"\n            exit 1\n         }\n      }\n   ' \"$f\"\n}\n\nerror_occurred=0\n\nfor pcp_file in \"${PCP_COLUMNS}\"/*; do\n   if ! check_file \"$pcp_file\" \"heading caption? width metric description\"; then\n      echo \"Error processing file: $pcp_file\" >&2\n      error_occurred=1\n   fi\ndone\n\nfor pcp_file in \"${PCP_METERS}\"/*; do\n   if ! check_file \"$pcp_file\" \"caption description? type? *.metric *.color? *.label? *.suffix?\"; then\n      echo \"Error processing file: $pcp_file\" >&2\n      error_occurred=1\n   fi\ndone\n\nfor pcp_file in \"${PCP_SCREENS}\"/*; do\n   if ! check_file \"$pcp_file\" \"heading caption default? *.heading *.metric *.default? *.caption? *.format? *.instances? *.width?\"; then\n      echo \"Error processing file: $pcp_file\" >&2\n      error_occurred=1\n   fi\ndone\n\nif [ $error_occurred -ne 0 ]; then\n   echo \"One or more files failed to process.\" >&2\n   exit 1\nelse\n   echo \"All files processed successfully.\" >&2\nfi\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 39.4296875,
          "content": "#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\n# ----------------------------------------------------------------------\n# Build version string.\n# ----------------------------------------------------------------------\n\nm4_define([htop_git_version],\n  m4_normalize(m4_esyscmd([git describe --abbrev=7 --dirty --always --tags 2> /dev/null || echo ''])))\nm4_define([htop_release_version], [3.4.0-dev])\n\n# ----------------------------------------------------------------------\n# Autoconf initialization.\n# ----------------------------------------------------------------------\n\nAC_PREREQ([2.69])\nAC_INIT([htop], [m4_join([-],m4_defn([htop_release_version]),m4_defn([htop_git_version]))], [htop@groups.io], [], [https://htop.dev/])\n\nAC_CONFIG_SRCDIR([htop.c])\nAC_CONFIG_AUX_DIR([build-aux])\nAC_CONFIG_HEADERS([config.h])\n\nAC_CANONICAL_HOST\nAM_INIT_AUTOMAKE([-Wall std-options subdir-objects])\n\n# ----------------------------------------------------------------------\n\n\n# ----------------------------------------------------------------------\n# Checks for platform.\n# ----------------------------------------------------------------------\n\ncase \"$host_os\" in\nlinux*|gnu*)\n   my_htop_platform=linux\n   AC_DEFINE([HTOP_LINUX], [], [Building for Linux.])\n   ;;\nfreebsd*|kfreebsd*)\n   my_htop_platform=freebsd\n   AC_DEFINE([HTOP_FREEBSD], [], [Building for FreeBSD.])\n   ;;\nnetbsd*)\n   my_htop_platform=netbsd\n   AC_DEFINE([HTOP_NETBSD], [], [Building for NetBSD.])\n   ;;\nopenbsd*)\n   my_htop_platform=openbsd\n   AC_DEFINE([HTOP_OPENBSD], [], [Building for OpenBSD.])\n   ;;\ndragonfly*)\n   my_htop_platform=dragonflybsd\n   AC_DEFINE([HTOP_DRAGONFLYBSD], [], [Building for DragonFlyBSD.])\n   ;;\ndarwin*)\n   my_htop_platform=darwin\n   AC_DEFINE([HTOP_DARWIN], [], [Building for Darwin.])\n   ;;\nsolaris*)\n   my_htop_platform=solaris\n   AC_DEFINE([HTOP_SOLARIS], [], [Building for Solaris.])\n   ;;\n*)\n   my_htop_platform=unsupported\n   AC_DEFINE([HTOP_UNSUPPORTED], [], [Building for an unsupported platform.])\n   ;;\nesac\n\n# Enable extensions, required by hwloc scripts\nAC_USE_SYSTEM_EXTENSIONS\n\n# The header of ncurses exposes wide-character interfaces only if\n# _XOPEN_SOURCE_EXTENDED is defined or _XOPEN_SOURCE defined to be\n# >= 500. In DragonFly BSD, FreeBSD and OpenBSD, defining\n# _XOPEN_SOURCE to any value *hides* interfaces that would be useful\n# for htop.\ndnl\ndnl Note: The \"#undef\" in AH_VERBATIM will be replaced with \"#define\"\ndnl when config.h is generated.\nAH_VERBATIM([_XOPEN_SOURCE_EXTENDED],\n[/* Enables XPG4v2 (SUSv1) interfaces if they are not enabled already with _XOPEN_SOURCE */\n#ifndef _XOPEN_SOURCE_EXTENDED\n#undef _XOPEN_SOURCE_EXTENDED\n#endif\n])\nAC_DEFINE([_XOPEN_SOURCE_EXTENDED], 1)\n\n# Activate some more of the missing global defines\nAC_SYS_LARGEFILE\n\n# ----------------------------------------------------------------------\n\n\n# ----------------------------------------------------------------------\n# Checks for compiler.\n# ----------------------------------------------------------------------\n\nAC_PROG_CC\nAM_PROG_CC_C_O\nm4_version_prereq([2.70], [], [AC_PROG_CC_C99])\nAS_IF([test \"x$ac_cv_prog_cc_c99\" = xno], [AC_MSG_ERROR([htop is written in C99. A newer compiler is required.])])\nAM_CFLAGS=\"-std=c99 -pedantic\"\n\n# ----------------------------------------------------------------------\n\n\n# ----------------------------------------------------------------------\n# Checks for static build.\n# ----------------------------------------------------------------------\n\nAC_ARG_ENABLE([static],\n              [AS_HELP_STRING([--enable-static],\n                              [build a static htop binary @<:@default=no@:>@])],\n              [],\n              [enable_static=no])\ncase \"$enable_static\" in\n   no)\n      ;;\n   yes)\n      AC_DEFINE([BUILD_STATIC], [1], [Define if building static binary.])\n      CFLAGS=\"$CFLAGS -static\"\n      LDFLAGS=\"$LDFLAGS -static\"\n      ;;\n   *)\n      AC_MSG_ERROR([bad value '$enable_static' for --enable-static option])\n      ;;\nesac\n\n# ----------------------------------------------------------------------\n\n# ----------------------------------------------------------------------\n# Checks for a PCP-based htop build.  (https://pcp.io)\n# ----------------------------------------------------------------------\n\nAC_ARG_ENABLE([pcp],\n              [AS_HELP_STRING([--enable-pcp],\n                              [build a pcp-htop binary @<:@default=no@:>@])],\n              [],\n              [enable_pcp=no])\ncase \"$enable_pcp\" in\n   no)\n      ;;\n   yes)\n      AC_CHECK_HEADERS([pcp/pmapi.h], [my_htop_platform=pcp],\n                       [AC_MSG_ERROR([can not find PCP header file])])\n      AC_SEARCH_LIBS([pmNewContext], [pcp], [], [AC_MSG_ERROR([can not find PCP library])])\n      AC_DEFINE([HTOP_PCP], [1], [Define if building pcp-htop binary.])\n      AC_CONFIG_FILES([pcp-htop.5])\n      ;;\n   *)\n      AC_MSG_ERROR([bad value '$enable_pcp' for --enable-pcp option])\n      ;;\nesac\n\n# ----------------------------------------------------------------------\n\n\n# ----------------------------------------------------------------------\n# Checks for generic header files.\n# ----------------------------------------------------------------------\n\nAC_HEADER_DIRENT\nm4_version_prereq([2.70], [AC_CHECK_INCLUDES_DEFAULT], [AC_HEADER_STDC])\nAC_CHECK_HEADERS([ \\\n    stdlib.h \\\n    string.h \\\n    strings.h \\\n    sys/param.h \\\n    sys/time.h \\\n    sys/utsname.h \\\n    unistd.h\n   ], [], [AC_MSG_ERROR([can not find required generic header files])])\n\nAC_HEADER_MAJOR\ndnl glibc 2.25 deprecates 'major' and 'minor' in <sys/types.h> and requires to\ndnl include <sys/sysmacros.h>. However the logic in AC_HEADER_MAJOR has not yet\ndnl been updated in Autoconf 2.69, so use a workaround:\nm4_version_prereq([2.70], [],\n[if test \"x$ac_cv_header_sys_mkdev_h\" != xyes; then\n   AC_CHECK_HEADER([sys/sysmacros.h], [AC_DEFINE([MAJOR_IN_SYSMACROS], [1],\n      [Define to 1 if 'major', 'minor', and 'makedev' are declared in <sys/sysmacros.h>.])])\nfi])\n\n# Optional Section\n\nAC_CHECK_HEADERS([execinfo.h])\n\nif test \"$my_htop_platform\" = darwin; then\n   AC_CHECK_HEADERS([mach/mach_time.h])\nfi\n\n# ----------------------------------------------------------------------\n\n\n# ----------------------------------------------------------------------\n# Checks for typedefs, structures, and compiler characteristics.\n# ----------------------------------------------------------------------\n\nAC_TYPE_MBSTATE_T\nAC_TYPE_MODE_T\nAC_TYPE_OFF_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\nAC_TYPE_SSIZE_T\nAC_TYPE_UID_T\nAC_TYPE_UINT8_T\nAC_TYPE_UINT16_T\nAC_TYPE_UINT32_T\nAC_TYPE_UINT64_T\n\nAC_MSG_CHECKING(for alloc_size)\nold_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -Wno-error -Werror=attributes\"\nAC_COMPILE_IFELSE([\n   AC_LANG_SOURCE(\n      [\n         /* Attribute supported in GCC 4.3 or later */\n         __attribute__((alloc_size(1))) char* my_alloc(int size) { return 0; }\n      ],[]\n   )],\n   AC_DEFINE([HAVE_ATTR_ALLOC_SIZE], 1, [The alloc_size attribute is supported.])\n   AC_MSG_RESULT(yes),\n   AC_MSG_RESULT(no))\nCFLAGS=\"$old_CFLAGS\"\n\nAC_MSG_CHECKING(for access)\nold_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -Wno-error -Werror=attributes\"\nAC_COMPILE_IFELSE([\n   AC_LANG_SOURCE(\n      [\n         /* Attribute supported in GCC 10 or later */\n         __attribute__((access(read_only, 1, 2))) extern int foo(const char* str, unsigned len);\n      ],[]\n   )],\n   AC_DEFINE([HAVE_ATTR_ACCESS], 1, [The access attribute is supported.])\n   AC_MSG_RESULT(yes),\n   AC_MSG_RESULT(no))\nCFLAGS=\"$old_CFLAGS\"\n\nAC_MSG_CHECKING(for nonnull)\nold_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -Wno-error -Werror=attributes\"\nAC_COMPILE_IFELSE([\n   AC_LANG_SOURCE(\n      [[\n         /* Attribute supported in GCC 3.3 or later */\n         __attribute__((nonnull)) int my_strcmp(const char* a, const char* b);\n         __attribute__((nonnull(1))) long my_strtol(const char* str, char** endptr, int base);\n      ]]\n   )],\n   AC_DEFINE([HAVE_ATTR_NONNULL], 1, [The nonnull attribute is supported.])\n   AC_MSG_RESULT(yes),\n   AC_MSG_RESULT(no))\nCFLAGS=\"$old_CFLAGS\"\n\nAC_MSG_CHECKING(for returns_nonnull)\nold_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -Wno-error -Werror=attributes\"\nAC_COMPILE_IFELSE([\n   AC_LANG_SOURCE(\n      [[\n         /* Attribute supported in GCC 4.9 or later */\n         __attribute__((returns_nonnull)) void* foo(void);\n      ]]\n   )],\n   AC_DEFINE([HAVE_ATTR_RETNONNULL], 1, [The returns_nonnull attribute is supported.])\n   AC_MSG_RESULT(yes),\n   AC_MSG_RESULT(no))\nCFLAGS=\"$old_CFLAGS\"\n\nAC_MSG_CHECKING(for NaN support)\ndnl Note: AC_RUN_IFELSE does not try compiling the program at all when\ndnl $cross_compiling is 'yes'.\nAC_LINK_IFELSE([\n   AC_LANG_PROGRAM(\n      [[\n#include <math.h>\n      ]],\n      [[\n         double x = NAN;\n         /* Both should evaluate to false -> 0 (exit success) */\n         return isgreater(x, x) || isgreaterequal(x, x);\n      ]]\n   )],\n   [flag_finite_math_only=unknown\n   if test \"$cross_compiling\" = yes; then\n      AC_COMPILE_IFELSE([\n         AC_LANG_SOURCE([[\n/* __FINITE_MATH_ONLY__ is documented in Clang. */\n#ifdef __FINITE_MATH_ONLY__\n#error \"should not enable -ffinite-math-only\"\n#endif\n         ]])],\n         AC_MSG_RESULT([assume yes (cross compiling)]),\n         flag_finite_math_only=yes)\n   elif ./conftest$EXEEXT >&AS_MESSAGE_LOG_FD; then\n      flag_finite_math_only=no\n      AC_MSG_RESULT(yes)\n   else\n      flag_finite_math_only=yes\n   fi\n   if test \"$flag_finite_math_only\" = yes; then\n      AC_MSG_RESULT(no)\n      AC_MSG_WARN([runtime behavior with NaN is not compliant - some functionality might break; consider using '-fno-finite-math-only'])\n   fi],\n   [AC_MSG_RESULT(no)\n   AC_MSG_ERROR([can not find required macros: NAN, isgreater() and isgreaterequal()])])\n\nAC_MSG_CHECKING(for __builtin_ctz)\nAC_COMPILE_IFELSE([\n   AC_LANG_PROGRAM([], [[__builtin_ctz(1); /* Supported in GCC 3.4 or later */]])],\n   [AC_DEFINE([HAVE_BUILTIN_CTZ], 1, [Define to 1 if the compiler supports '__builtin_ctz' function.])\n   AC_MSG_RESULT(yes)],\n   AC_MSG_RESULT(no))\n\n# ----------------------------------------------------------------------\n\n\n# ----------------------------------------------------------------------\n# Checks for generic library functions.\n# ----------------------------------------------------------------------\n\nAC_SEARCH_LIBS([ceil], [m], [], [AC_MSG_ERROR([can not find required function ceil()])])\n\nif test \"$my_htop_platform\" = dragonflybsd; then\n   AC_SEARCH_LIBS([kvm_open], [kvm], [], [AC_MSG_ERROR([can not find required function kvm_open()])])\n   AC_SEARCH_LIBS([getdevs], [devstat], [], [AC_MSG_ERROR([can not find required function getdevs()])])\nfi\n\nif test \"$my_htop_platform\" = freebsd; then\n   if test \"$enable_static\" = yes; then\n      AC_SEARCH_LIBS([elf_version], [elf], [], [AC_MSG_ERROR([can not find required function elf_version()])])\n   fi\n   AC_SEARCH_LIBS([kvm_open], [kvm], [], [AC_MSG_ERROR([can not find required function kvm_open()])])\n   AC_SEARCH_LIBS([devstat_checkversion], [devstat], [], [AC_MSG_ERROR([can not find required function devstat_checkversion()])])\nfi\n\nif test \"$my_htop_platform\" = linux; then\n   if test \"$enable_static\" != yes; then\n      AC_SEARCH_LIBS([dlopen], [dl dld], [], [AC_MSG_ERROR([can not find required function dlopen()])])\n   fi\nfi\n\nif test \"$my_htop_platform\" = netbsd; then\n   AC_SEARCH_LIBS([kvm_open], [kvm], [], [AC_MSG_ERROR([can not find required function kvm_open()])])\n   AC_SEARCH_LIBS([prop_dictionary_get], [prop], [], [AC_MSG_ERROR([can not find required function prop_dictionary_get()])])\nfi\n\nif test \"$my_htop_platform\" = openbsd; then\n   AC_SEARCH_LIBS([kvm_open], [kvm], [], [AC_MSG_ERROR([can not find required function kvm_open()])])\nfi\n\nif test \"$my_htop_platform\" = solaris; then\n   AC_SEARCH_LIBS([kstat_open], [kstat], [], [AC_MSG_ERROR([can not find required function kstat_open()])])\n   AC_SEARCH_LIBS([Pgrab_error], [proc], [], [AC_MSG_ERROR([can not find required function Pgrab_error()])])\n   AC_SEARCH_LIBS([free], [malloc], [], [AC_MSG_ERROR([can not find required function free()])])\nfi\n\n# Optional Section\n\nAC_SEARCH_LIBS([clock_gettime], [rt])\n\nAC_CHECK_FUNCS([ \\\n    clock_gettime \\\n    dladdr \\\n    faccessat \\\n    fstatat \\\n    host_get_clock_service \\\n    memfd_create\\\n    openat \\\n    readlinkat \\\n    sched_getscheduler \\\n    sched_setscheduler \\\n    strchrnul \\\n   ])\n\nif test \"$my_htop_platform\" = darwin; then\n   AC_CHECK_FUNCS([mach_timebase_info])\n   AC_CHECK_DECLS([IOMainPort], [], [], [[#include <IOKit/IOKitLib.h>]])\n   AC_CHECK_DECLS([IOMasterPort], [], [], [[#include <IOKit/IOKitLib.h>]])\n\n   AC_CHECK_FUNCS([host_statistics64], [\n      AC_CHECK_TYPES([struct vm_statistics64], [], [], [[#include <mach/vm_statistics.h>]])\n   ], [])\nfi\n\nif test \"$my_htop_platform\" = pcp; then\n   AC_CHECK_FUNCS([pmLookupDescs])\nfi\n\nif test \"$my_htop_platform\" = linux && test \"x$enable_static\" = xyes; then\n   AC_CHECK_LIB([systemd], [sd_bus_open_system], [], [], [-lcap])\nfi\n\n# ----------------------------------------------------------------------\n\n\n# ----------------------------------------------------------------------\n# Checks for cross-platform features and flags.\n# ----------------------------------------------------------------------\n\ndnl PKG_PROG_PKG_CONFIG initializes $PKG_CONFIG and related variables.\ndnl If the macro is not called, some pkg-config checks might be skipped\ndnl and $PKG_CONFIG might be unset.\nm4_ifdef([PKG_PROG_PKG_CONFIG], [\n   PKG_PROG_PKG_CONFIG()\n   pkg_m4_included=1 # Makefile might grep this keyword. Don't remove.\n], [\n   m4_warn(\n      [syntax],\n      [pkg.m4 is absent or older than version 0.16; this 'configure' would have incomplete pkg-config support])\n])\n\nAC_ARG_ENABLE([unicode],\n              [AS_HELP_STRING([--enable-unicode],\n                              [enable Unicode support @<:@default=yes@:>@])],\n              [],\n              [enable_unicode=yes])\n\nAC_ARG_VAR([CURSES_CFLAGS], [C compiler flags for curses; this overrides auto detected values])\nAC_ARG_VAR([CURSES_LIBS], [linker flags for curses; this overrides auto detected values])\n\ncurses_pkg_names=\"ncurses6 ncurses5 ncurses ncursest6 ncursest5 \\\n   ncursest curses\"\n\nif test \"x$enable_unicode\" = xyes; then\n   curses_pkg_names=\"ncursesw6 ncursesw5 ncursesw ncursestw6 ncursestw5 \\\n      ncursestw $curses_pkg_names\"\nfi\n\nAC_ARG_WITH([curses],\n            [AS_HELP_STRING([--with-curses=NAME],\n                            [select curses package NAME to link with; e.g. ncursesw6])],\n            [],\n            [with_curses=check])\ncase $with_curses in\ncheck|yes)\n   : # No-op. Use default list.\n   ;;\nno)\n   AC_MSG_ERROR([bad value '$with_curses' for --with-curses option])\n   ;;\n*)\n   if test \"x${CURSES_CFLAGS+y}${CURSES_LIBS+y}\" = xyy; then\n      AC_MSG_WARN([ignoring --with-curses value due to override])\n   fi\n   curses_pkg_names=`echo \"x$with_curses\" | sed 's/^x\\(lib\\)\\{0,1\\}//'`\n   ;;\nesac\n\n# $1: C preprocessor and compiler flags for curses library\n# $2: linker flags for curses library\nhtop_check_curses_capability () {\n   htop_curses_cflags=${CURSES_CFLAGS-\"$1\"}\n   htop_curses_libs=${CURSES_LIBS-\"$2\"}\n\n   echo \"curses cflags${CURSES_CFLAGS+ (override)}: $htop_curses_cflags\" >&AS_MESSAGE_LOG_FD\n   echo \"curses libs${CURSES_LIBS+ (override)}: $htop_curses_libs\" >&AS_MESSAGE_LOG_FD\n\n   htop_msg_linker_flags=$htop_curses_libs\n   if test \"`echo x $htop_msg_linker_flags`\" = x; then\n      htop_msg_linker_flags=\"(no linker flags)\"\n   fi\n\n   htop_curses_status=0 # 0 for success; nonzero for failure\n\n   htop_save_CFLAGS=$CFLAGS\n   htop_save_LIBS=$LIBS\n   CFLAGS=\"$AM_CFLAGS $htop_curses_cflags $CFLAGS\"\n   LIBS=\"$htop_curses_libs $LIBS\"\n\n   # At this point we have not checked the name of curses header, so\n   # use forward declaration for the linking tests below.\n\n   # htop uses keypad(), but for ncurses implementation, the symbol is\n   # in \"-ltinfo\" and not \"-lncurses\".\n   # Check \"-ltinfo\" symbols first, as libncurses might require\n   # explicit \"-ltinfo\" to link (for internal dependency).\n   AC_MSG_CHECKING([for keypad in $htop_msg_linker_flags])\n   AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n/* int keypad(WINDOW* win, bool enable); */\nint keypad(void* win, int enable);\n      ]], [[\nstatic char dummy;\nkeypad((void*)&dummy, 0);\n      ]])],\n      [AC_MSG_RESULT(yes)],\n      [AC_MSG_RESULT(no)\n      htop_curses_status=1])\n\n   # htop calls refresh(), which might be implemented as a macro.\n   # It is more reliable to test linking with doupdate(), which\n   # refresh() would call internally.\n   if test \"$htop_curses_status\" -eq 0; then\n      AC_MSG_CHECKING([for doupdate in $htop_msg_linker_flags])\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([[\nint doupdate(void);\n         ]], [[\ndoupdate();\n         ]])],\n         [AC_MSG_RESULT(yes)\n         htop_curses_capability=nonwide],\n         [AC_MSG_RESULT(no)\n         htop_curses_status=1])\n   fi\n\n   # htop calls mvadd_wchnstr(), which might be implemented as a macro.\n   # It is more reliable to test linking with wadd_wchnstr().\n   if test \"x$htop_curses_status$enable_unicode\" = x0yes; then\n      AC_MSG_CHECKING([for wadd_wchnstr in $htop_msg_linker_flags])\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n/* int wadd_wchnstr(WINDOW* win, const cchar_t* wchstr, int n); */\nint wadd_wchnstr(void* win, const void* wchstr, int n);\n         ]], [[\nstatic char dummy1;\nstatic char dummy2;\nwadd_wchnstr((void*)&dummy1, (void*)&dummy2, 0);\n         ]])],\n         [AC_MSG_RESULT(yes)\n         htop_curses_capability=wide],\n         [AC_MSG_RESULT(no)\n         htop_curses_status=1])\n   fi\n\n   if test \"$htop_curses_status\" -eq 0; then\n      AM_CFLAGS=\"$AM_CFLAGS $htop_curses_cflags\"\n      if test \"$htop_curses_capability\" = wide; then\n         AC_DEFINE([HAVE_LIBNCURSESW], 1, [libncursesw is present])\n      else\n         AC_DEFINE([HAVE_LIBNCURSES], 1, [libcurses is present])\n      fi\n   else\n      LIBS=$htop_save_LIBS\n   fi\n   CFLAGS=$htop_save_CFLAGS\n   return \"$htop_curses_status\"\n} # htop_check_curses_capability\n\nhtop_curses_capability=none\n\nif test \"x${CURSES_CFLAGS+y}${CURSES_LIBS+y}\" = xyy; then\n   curses_pkg_names=\"\"\n   htop_check_curses_capability \"$CURSES_CFLAGS\" \"$CURSES_LIBS\"\nfi\n\n# Prioritize $PKG_CONFIG over ncurses*-config, as users might need to\n# cross-compile htop.\nif test \"x$PKG_CONFIG\" != x; then\n   pkg_config_static_flag=\"\"\n   if test \"$enable_static\" = yes; then\n      pkg_config_static_flag=--static\n   fi\n\n   for curses_name in $curses_pkg_names; do\n      echo retrieving $curses_name information through $PKG_CONFIG >&AS_MESSAGE_LOG_FD\n      $PKG_CONFIG --exists --print-errors $curses_name >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD || continue\n\n      : # Resets \"$?\" to 0\n      htop_config_cflags=`$PKG_CONFIG --cflags $pkg_config_static_flag $curses_name 2>/dev/null` || continue\n      : # Resets \"$?\" to 0\n      htop_config_libs=`$PKG_CONFIG --libs $pkg_config_static_flag $curses_name 2>/dev/null` || continue\n\n      AC_MSG_RESULT([found $curses_name information through $PKG_CONFIG])\n\n      if htop_check_curses_capability \"$htop_config_cflags\" \"$htop_config_libs\"; then\n         break\n      fi\n   done\nfi\n\ncase ${htop_curses_capability}-$enable_unicode in\nnone-*|nonwide-yes)\n   for curses_name in $curses_pkg_names; do\n      echo retrieving $curses_name information through ${curses_name}-config >&AS_MESSAGE_LOG_FD\n\n      ${curses_name}-config --cflags >/dev/null 2>&AS_MESSAGE_LOG_FD || continue\n\n      : # Resets \"$?\" to 0\n      htop_config_cflags=`${curses_name}-config --cflags 2>/dev/null` || continue\n      : # Resets \"$?\" to 0\n      htop_config_libs=`${curses_name}-config --libs 2>/dev/null` || continue\n\n      AC_MSG_RESULT([found $curses_name information through ${curses_name}-config])\n\n      if htop_check_curses_capability \"$htop_config_cflags\" \"$htop_config_libs\"; then\n         break\n      fi\n   done\n   ;;\nesac\n\ncase ${htop_curses_capability}-$enable_unicode in\nnone-*|nonwide-yes)\n   if test \"x$PKG_CONFIG\" = x; then (\n      # Friendly warning to advise user to install pkg-config.\n      # The local variables get discarded when done.\n      list=\"\"\n      echo \"\" >conftest.c\n      if test \"$cross_compiling\" != yes; then\n         # \"-print-multi-directory\" supported in GCC 3.0 or later\n         name=\"\"\n         if $CC $CPPFLAGS $CFLAGS -print-multi-directory -E conftest.c >/dev/null 2>&1; then\n            name=`$CC $CPPFLAGS $CFLAGS -print-multi-directory -E conftest.c 2>/dev/null |\n               sed '/^ *#/ d; s/^\\.$//; q'`\n         fi\n         list=\"/usr/lib${name}/pkgconfig $list\"\n         case $host_os in\n         darwin*)\n            list=\"/opt/homebrew/Library/Homebrew/os/mac/pkgconfig $list\"\n            ;;\n         freebsd*)\n            list=\"/usr/libdata/pkgconfig $list\"\n            ;;\n         netbsd*)\n            list=\"/usr/pkg/lib/pkgconfig $list\"\n            ;;\n         esac\n      fi\n      if test \"x$host_alias\" != x; then\n         list=\"/usr/lib/${host_alias}/pkgconfig $list\"\n      fi\n      # \"-print-multiarch\" supported in GCC 4.6 or later\n      if $CC $CPPFLAGS $CFLAGS -print-multiarch -E conftest.c >/dev/null 2>&1; then\n         name=`$CC $CPPFLAGS $CFLAGS -print-multiarch -E conftest.c 2>/dev/null |\n            sed '/^ *#/ d; q'`\n         if test \"x$name\" != x; then\n            list=\"/usr/lib/${name}/pkgconfig $list\"\n         fi\n      fi\n      rm -f conftest.*\n\n      for d in $list; do\n         result=`find \"$d\" -name '*curses*.pc' 2>/dev/null | sed '1 q'`\n         if test \"x$result\" != x; then\n            echo detected a .pc file: \"$result\" >&AS_MESSAGE_LOG_FD\n            AC_MSG_WARN([your system supports pkg-config; installing pkg-config is recommended before configuring htop])\n            m4_ifdef([PKG_PROG_PKG_CONFIG], [], [\n               AC_MSG_WARN([this configure script would also need to be regenerated])\n            ])\n            break\n         fi\n      done\n   ) fi\n\n   # OpenBSD and Solaris are known to not provide '*curses*.pc' files.\n   AC_MSG_RESULT([no curses information found through '*-config' utilities; will guess the linker flags])\n   for curses_name in $curses_pkg_names; do\n      if htop_check_curses_capability \"\" \"-l$curses_name\"; then\n         break\n      fi\n      # For ncurses implementation, an extra terminfo library might be\n      # needed. Guess the terminfo library name based on the ncurses\n      # library file name (e.g. \"-ltinfow\" for \"-lncursesw\"), before\n      # trying the \"-ltinfo\" name.\n      tinfo_name=`echo x$curses_name | sed 's/^xncurses/tinfo/p; d'`\n      case x$tinfo_name in\n      x|xtinfo)\n         ;;\n      *)\n         if htop_check_curses_capability \"\" \"-l$curses_name -l$tinfo_name\"; then\n            break\n         fi\n         ;;\n      esac\n      if htop_check_curses_capability \"\" \"-l$curses_name -ltinfo\"; then\n         break\n      fi\n   done\n   ;;\nesac\n\ncase ${htop_curses_capability}-$enable_unicode in\nnonwide-yes)\n   AC_MSG_ERROR([cannot find required ncursesw library; you may want to use --disable-unicode])\n   ;;\nnone-*)\n   AC_MSG_ERROR([cannot find required curses/ncurses library])\n   ;;\nesac\n\nhtop_save_CFLAGS=$CFLAGS\nCFLAGS=\"$AM_CFLAGS $CFLAGS\"\n\nif test \"x$enable_unicode\" = xyes; then\n   AC_CHECK_HEADERS([ncursesw/curses.h], [],\n      [AC_CHECK_HEADERS([ncurses/ncurses.h], [],\n         [AC_CHECK_HEADERS([ncurses/curses.h], [],\n            [AC_CHECK_HEADERS([ncurses.h], [],\n               [AC_MSG_ERROR([can not find required ncurses header file])])])])])\n\n   AC_CHECK_HEADERS([ncursesw/term.h], [],\n      [AC_CHECK_HEADERS([ncurses/term.h], [],\n         [AC_CHECK_HEADERS([term.h], [],\n            [AC_MSG_ERROR([can not find required term header file])])])])\nelse\n   AC_CHECK_HEADERS([curses.h], [],\n      [AC_CHECK_HEADERS([ncurses/curses.h], [],\n         [AC_CHECK_HEADERS([ncurses/ncurses.h], [],\n            [AC_CHECK_HEADERS([ncurses.h], [],\n               [AC_MSG_ERROR([can not find required ncurses header file])])])])])\n\n   AC_CHECK_HEADERS([ncurses/term.h], [],\n      [AC_CHECK_HEADERS([term.h], [],\n         [AC_MSG_ERROR([can not find required term header file])])])\nfi\n\nCFLAGS=\"-I$srcdir $CFLAGS\"\n\n# Check for things that might be macros.\n# \"stdscr\" is a macro in ncursest (reentrant version of ncurses).\nAC_MSG_CHECKING([whether the curses header works])\nAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n/* Checks if the \"bool\" definition in curses is ISO C compatible */\n#include <stdbool.h>\n\n#include \"ProvideCurses.h\"\n   ]], [[\nkeypad(stdscr, false);\n\nrefresh();\n\n#if defined(HAVE_LIBNCURSESW)\n{\n   static cchar_t dummy;\n   mvadd_wchnstr(0, 0, &dummy, 0);\n}\n#endif\n   ]])],\n   [AC_MSG_RESULT(yes)],\n   [AC_MSG_RESULT(no)\n   AC_MSG_FAILURE([there are problems with the curses header])]\n)\n\nCFLAGS=$htop_save_CFLAGS\n\nif test \"$enable_static\" = yes; then\n   AC_SEARCH_LIBS([Gpm_GetEvent], [gpm])\nfi\nif test \"$my_htop_platform\" = \"solaris\"; then\n   # On OmniOS /usr/include/sys/regset.h redefines ERR to 13 - \\r, breaking the Enter key.\n   # Since ncurses macros use the ERR macro, we can not use another name.\n   AC_DEFINE([ERR], [(-1)], [Predefine ncurses macro.])\nfi\nAC_CHECK_FUNCS( [set_escdelay] )\nAC_CHECK_FUNCS( [getmouse] )\nAC_DEFINE([NCURSES_ENABLE_STDBOOL_H], [1], [Define to enable stdbool.h in ncurses])\n\n\nAC_ARG_ENABLE([affinity],\n              [AS_HELP_STRING([--enable-affinity],\n                              [enable sched_setaffinity and sched_getaffinity for affinity support, conflicts with hwloc @<:@default=check@:>@])],\n              [],\n              [enable_affinity=check])\nif test \"x$enable_affinity\" = xcheck; then\n   if test \"x$enable_hwloc\" = xyes; then\n      enable_affinity=no\n   else\n      AC_MSG_CHECKING([for usable sched_setaffinity])\n      AC_RUN_IFELSE([\n         AC_LANG_PROGRAM([[\n            #include <sched.h>\n            #include <errno.h>\n            static cpu_set_t cpuset;\n         ]], [[\n            CPU_ZERO(&cpuset);\n            sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);\n            if (errno == ENOSYS) return 1;\n         ]])],\n      [enable_affinity=yes\n         AC_MSG_RESULT([yes])],\n      [enable_affinity=no\n         AC_MSG_RESULT([no])],\n      [AC_MSG_RESULT([assume yes (cross compiling)])])\n   fi\nfi\nif test \"x$enable_affinity\" = xyes; then\n   if test \"x$enable_hwloc\" = xyes; then\n      AC_MSG_ERROR([--enable-hwloc and --enable-affinity are mutual exclusive. Specify at most one of them.])\n   fi\n   AC_DEFINE([HAVE_AFFINITY], [1], [Define if sched_setaffinity and sched_getaffinity are to be used.])\nfi\n\n\nAC_ARG_ENABLE([unwind],\n              [AS_HELP_STRING([--enable-unwind],\n              [enable unwind support for printing backtraces; requires libunwind @<:@default=check@:>@])],\n              [],\n              [enable_unwind=check])\ncase \"$enable_unwind\" in\n   check)\n      enable_unwind=yes\n      if test \"$enable_static\" = yes; then\n         AC_CHECK_LIB([lzma], [lzma_index_buffer_decode])\n      fi\n      AC_CHECK_LIB([unwind], [backtrace], [], [enable_unwind=no])\n      AC_CHECK_HEADERS([libunwind.h], [], [\n         old_CFLAGS=\"$CFLAGS\"\n         CFLAGS=\"$CFLAGS -I/usr/include/libunwind\"\n         AC_CHECK_HEADERS([libunwind/libunwind.h], [], [\n            enable_unwind=no\n            CFLAGS=\"$old_CFLAGS\"\n         ])\n      ])\n      ;;\n   no)\n      ;;\n   yes)\n      AC_CHECK_LIB([unwind], [backtrace], [], [AC_MSG_ERROR([can not find required library libunwind])])\n      AC_CHECK_HEADERS([libunwind.h], [], [\n         AM_CFLAGS=\"$AM_CFLAGS -I/usr/include/libunwind\"\n         AC_CHECK_HEADERS([libunwind/libunwind.h], [], [AC_MSG_ERROR([can not find required header file libunwind.h])])\n      ])\n      ;;\n   *)\n      AC_MSG_ERROR([bad value '$enable_unwind' for --enable-unwind])\n      ;;\nesac\nif test \"x$enable_unwind\" = xno; then\n   # Fall back to backtrace(3) and add -lexecinfo if needed\n   AC_SEARCH_LIBS([backtrace], [execinfo])\nfi\n\n\nAC_ARG_ENABLE([hwloc],\n              [AS_HELP_STRING([--enable-hwloc],\n              [enable hwloc support for CPU affinity; disables affinity support; requires libhwloc @<:@default=no@:>@])],\n              [],\n              [enable_hwloc=no])\ncase \"$enable_hwloc\" in\n   no)\n      ;;\n   yes)\n      m4_ifdef([PKG_PROG_PKG_CONFIG], [\n         PKG_CHECK_MODULES(HWLOC, hwloc, [\n               AM_CFLAGS=\"$AM_CFLAGS $HWLOC_CFLAGS\"\n               LIBS=\"$LIBS $HWLOC_LIBS\"\n               AC_DEFINE([HAVE_LIBHWLOC], [1], [Define to 1 if you have the 'hwloc' library (-lhwloc).])\n            ], [\n               AC_CHECK_LIB([hwloc], [hwloc_get_proc_cpubind], [], [AC_MSG_ERROR([can not find required library libhwloc])])\n               AC_CHECK_HEADERS([hwloc.h], [], [AC_MSG_ERROR([can not find require header file hwloc.h])])\n            ])\n         ], [\n            AC_CHECK_LIB([hwloc], [hwloc_get_proc_cpubind], [], [AC_MSG_ERROR([can not find required library libhwloc])])\n            AC_CHECK_HEADERS([hwloc.h], [], [AC_MSG_ERROR([can not find require header file hwloc.h])])\n         ])\n      ;;\n   *)\n      AC_MSG_ERROR([bad value '$enable_hwloc' for --enable-hwloc])\n      ;;\nesac\n\n\nAC_ARG_WITH([os-release],\n            [AS_HELP_STRING([--with-os-release=FILE],\n                            [location of an os-release file @<:@default=/etc/os-release@:>@])],\n            [],\n            [with_os_release=/etc/os-release])\nif test -n \"$with_os_release\" && test ! -f \"$with_os_release\"; then\n   if test -f \"/usr/lib/os-release\"; then\n      with_os_release=\"/usr/lib/os-release\"\n   fi\nfi\nAC_DEFINE_UNQUOTED([OSRELEASEFILE], [\"$with_os_release\"], [File with OS release details.])\n\nAC_ARG_WITH([config],\n            [AS_HELP_STRING([--with-config=DIR],\n                            [configuration path @<:@default=/.config@:>@])],\n            [],\n            [with_config=\"/.config\"])\ndnl Performance Co-Pilot configuration location to prevent overwrite\nif test \"$my_htop_platform\" = pcp -a \"$with_config\" = /.config; then\n    with_config=\"/.pcp\"\nelif test -z \"$with_config\"; then\n   AC_MSG_ERROR([bad empty value for --with-config option])\nfi\nAC_DEFINE_UNQUOTED([CONFIGDIR], [\"$with_config\"], [Configuration path.])\n\n# ----------------------------------------------------------------------\n\n\n# ----------------------------------------------------------------------\n# Checks for Linux features and flags.\n# ----------------------------------------------------------------------\n\nAC_ARG_WITH([proc],\n            [AS_HELP_STRING([--with-proc=DIR],\n                            [location of a Linux-compatible proc filesystem @<:@default=/proc@:>@])],\n            [],\n            [with_proc=/proc])\nif test -z \"$with_proc\"; then\n   AC_MSG_ERROR([bad empty value for --with-proc option])\nfi\nAC_DEFINE_UNQUOTED([PROCDIR], [\"$with_proc\"], [Path of proc filesystem.])\n\n\nAC_ARG_ENABLE([openvz],\n              [AS_HELP_STRING([--enable-openvz],\n                              [enable OpenVZ support @<:@default=no@:>@])],\n              [],\n              [enable_openvz=no])\nif test \"x$enable_openvz\" = xyes; then\n   AC_DEFINE([HAVE_OPENVZ], [1], [Define if openvz support enabled.])\nfi\n\n\nAC_ARG_ENABLE([vserver],\n              [AS_HELP_STRING([--enable-vserver],\n                              [enable VServer support @<:@default=no@:>@])],\n              [],\n              [enable_vserver=no])\nif test \"x$enable_vserver\" = xyes; then\n   AC_DEFINE([HAVE_VSERVER], [1], [Define if VServer support enabled.])\nfi\n\n\nAC_ARG_ENABLE([ancient_vserver],\n              [AS_HELP_STRING([--enable-ancient-vserver],\n                              [enable ancient VServer support (implies --enable-vserver) @<:@default=no@:>@])],\n              [],\n              [enable_ancient_vserver=no])\nif test \"x$enable_ancient_vserver\" = xyes; then\n   if test \"x$enable_vserver\" != xyes; then\n      enable_vserver=implied\n   fi\n   AC_DEFINE([HAVE_VSERVER], [1], [Define if VServer support enabled.])\n   AC_DEFINE([HAVE_ANCIENT_VSERVER], [1], [Define if ancient vserver support enabled.])\nfi\n\n\nAC_ARG_ENABLE([capabilities],\n              [AS_HELP_STRING([--enable-capabilities],\n                              [enable Linux capabilities support; requires libcap @<:@default=check@:>@])],\n              [],\n              [enable_capabilities=check])\ncase \"$enable_capabilities\" in\n   no)\n      ;;\n   check)\n      enable_capabilities=yes\n      AC_CHECK_LIB([cap], [cap_init], [], [enable_capabilities=no])\n      AC_CHECK_HEADERS([sys/capability.h], [], [enable_capabilities=no])\n      ;;\n   yes)\n      AC_CHECK_LIB([cap], [cap_init], [], [AC_MSG_ERROR([can not find required library libcap])])\n      AC_CHECK_HEADERS([sys/capability.h], [], [AC_MSG_ERROR([can not find required header file sys/capability.h])])\n      ;;\n   *)\n      AC_MSG_ERROR([bad value '$enable_capabilities' for --enable-capabilities])\n      ;;\nesac\n\n\nAC_ARG_ENABLE([delayacct],\n              [AS_HELP_STRING([--enable-delayacct],\n                              [enable Linux delay accounting support; requires pkg-config, libnl-3 and libnl-genl-3 @<:@default=check@:>@])],\n              [],\n              [enable_delayacct=check])\ncase \"$enable_delayacct\" in\n   no)\n      ;;\n   check)\n      if test \"$my_htop_platform\" != linux; then\n         enable_delayacct=no\n      elif test \"$enable_static\" = yes; then\n         enable_delayacct=no\n      else\n         old_CFLAGS=\"$CFLAGS\"\n         CFLAGS=\"$CFLAGS -I/usr/include/libnl3\"\n         AC_CHECK_HEADERS([netlink/attr.h netlink/handlers.h netlink/msg.h], [enable_delayacct=yes], [enable_delayacct=no])\n         CFLAGS=\"$old_CFLAGS\"\n      fi\n      ;;\n   yes)\n      old_CFLAGS=\"$CFLAGS\"\n      CFLAGS=\"$CFLAGS -I/usr/include/libnl3\"\n      AC_CHECK_HEADERS([netlink/attr.h netlink/handlers.h netlink/msg.h], [], [AC_MSG_ERROR([can not find required header files netlink/attr.h, netlink/handlers.h, netlink/msg.h])])\n      CFLAGS=\"$old_CFLAGS\"\n      ;;\n   *)\n      AC_MSG_ERROR([bad value '$enable_delayacct' for --enable-delayacct])\n      ;;\nesac\nif test \"$enable_delayacct\" = yes; then\n  AC_DEFINE([HAVE_DELAYACCT], [1], [Define if delay accounting support should be enabled.])\n  AM_CFLAGS=\"$AM_CFLAGS -I/usr/include/libnl3\"\nfi\nAM_CONDITIONAL([HAVE_DELAYACCT], [test \"$enable_delayacct\" = yes])\n\n\nAC_ARG_ENABLE([sensors],\n              [AS_HELP_STRING([--enable-sensors],\n                              [enable libsensors support for reading temperature data; requires only libsensors headers at compile time, at runtime libsensors is loaded via dlopen @<:@default=check@:>@])],\n              [],\n              [enable_sensors=check])\ncase \"$enable_sensors\" in\n   no)\n      ;;\n   check)\n      enable_sensors=yes\n      if test \"$enable_static\" = yes; then\n         AC_CHECK_LIB([sensors], [sensors_init], [], [enable_sensors=no])\n      fi\n      AC_CHECK_HEADERS([sensors/sensors.h], [], [enable_sensors=no])\n      ;;\n   yes)\n      if test \"$enable_static\" = yes; then\n         AC_CHECK_LIB([sensors], [sensors_init], [], [AC_MSG_ERROR([can not find required library libsensors])])\n      fi\n      AC_CHECK_HEADERS([sensors/sensors.h], [], [AC_MSG_ERROR([can not find required header file sensors/sensors.h])])\n      ;;\n   *)\n      AC_MSG_ERROR([bad value '$enable_sensors' for --enable-sensors])\n      ;;\nesac\nif test \"$enable_sensors\" = yes || test \"$my_htop_platform\" = freebsd; then\n   AC_DEFINE([BUILD_WITH_CPU_TEMP], [1], [Define if CPU temperature option should be enabled.])\nfi\n\n# ----------------------------------------------------------------------\n\n\n# ----------------------------------------------------------------------\n# Checks for compiler warnings.\n# ----------------------------------------------------------------------\n\nAM_CFLAGS=\"$AM_CFLAGS\\\n -Wall\\\n -Wcast-align\\\n -Wcast-qual\\\n -Wextra\\\n -Wfloat-equal\\\n -Wformat=2\\\n -Winit-self\\\n -Wmissing-format-attribute\\\n -Wmissing-noreturn\\\n -Wmissing-prototypes\\\n -Wpointer-arith\\\n -Wshadow\\\n -Wstrict-prototypes\\\n -Wundef\\\n -Wunused\\\n -Wwrite-strings\"\n\ndnl https://www.gnu.org/software/autoconf-archive/ax_check_compile_flag.html\nAC_DEFUN([AX_CHECK_COMPILE_FLAG],\n[\nAS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl\nAC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [\n   ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS\n   _AC_LANG_PREFIX[]FLAGS=\"$[]_AC_LANG_PREFIX[]FLAGS $4 $1\"\n   AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],\n      [AS_VAR_SET(CACHEVAR,[yes])],\n      [AS_VAR_SET(CACHEVAR,[no])])\n   _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])\nAS_VAR_IF(CACHEVAR,yes,\n   [m4_default([$2], :)],\n   [m4_default([$3], :)])\nAS_VAR_POPDEF([CACHEVAR])dnl\n])dnl AX_CHECK_COMPILE_FLAGS\n\nAX_CHECK_COMPILE_FLAG([-Wextra-semi-stmt],         [AM_CFLAGS=\"$AM_CFLAGS -Wextra-semi-stmt\"],         , [-Werror=unknown-warning-option]) dnl the autoconf check itself generates -Wextra-semi-stmt\nAX_CHECK_COMPILE_FLAG([-Wimplicit-int-conversion], [AM_CFLAGS=\"$AM_CFLAGS -Wimplicit-int-conversion\"], , [-Werror])\nAX_CHECK_COMPILE_FLAG([-Wnull-dereference],        [AM_CFLAGS=\"$AM_CFLAGS -Wnull-dereference\"],        , [-Werror])\n\nAC_ARG_ENABLE([werror],\n              [AS_HELP_STRING([--enable-werror],\n                              [Treat warnings as errors @<:@default=no@:>@])],\n              [],\n              [enable_werror=no])\nif test \"x$enable_werror\" = xyes; then\n   AM_CFLAGS=\"$AM_CFLAGS -Werror\"\nfi\n\nAC_ARG_ENABLE([debug],\n              [AS_HELP_STRING([--enable-debug],\n                              [Enable compiling with maximum debug info, asserts and internal sanity checks @<:@default=no@:>@])],\n              [],\n              [enable_debug=no])\nif test \"x$enable_debug\" != xyes; then\n   AM_CPPFLAGS=\"$AM_CPPFLAGS -DNDEBUG\"\n\n   AC_COMPILE_IFELSE([\n      AC_LANG_SOURCE([[\n#ifdef __SUPPORT_SNAN__\n#error \"signaling NaN support not recommended\"\n#endif\n      ]])],\n      :,\n      [warning_msg=\"signaling NaN support is enabled; not recommended for htop\"\n      case \"$CC\" in\n      *gcc*)\n         warning_msg=\"$warning_msg (use '-fno-signaling-nans' compiler flag to disable)\"\n         ;;\n      esac\n      AC_MSG_WARN([$warning_msg])\n      ])\nelse\n   AM_CPPFLAGS=\"$AM_CPPFLAGS -ggdb3\"\nfi\n\n\nAC_SUBST([AM_CFLAGS])\nAC_SUBST([AM_CPPFLAGS])\n\n# ----------------------------------------------------------------------\n\n\n# ----------------------------------------------------------------------\n# We're done, let's go!\n# ----------------------------------------------------------------------\n\nAC_DEFINE_UNQUOTED([COPYRIGHT], [\"(C) 2004-2019 Hisham Muhammad. (C) 2020-2025 htop dev team.\"], [Copyright message.])\n\nAM_CONDITIONAL([HTOP_LINUX], [test \"$my_htop_platform\" = linux])\nAM_CONDITIONAL([HTOP_FREEBSD], [test \"$my_htop_platform\" = freebsd])\nAM_CONDITIONAL([HTOP_DRAGONFLYBSD], [test \"$my_htop_platform\" = dragonflybsd])\nAM_CONDITIONAL([HTOP_NETBSD], [test \"$my_htop_platform\" = netbsd])\nAM_CONDITIONAL([HTOP_OPENBSD], [test \"$my_htop_platform\" = openbsd])\nAM_CONDITIONAL([HTOP_DARWIN], [test \"$my_htop_platform\" = darwin])\nAM_CONDITIONAL([HTOP_SOLARIS], [test \"$my_htop_platform\" = solaris])\nAM_CONDITIONAL([HTOP_PCP], [test \"$my_htop_platform\" = pcp])\nAM_CONDITIONAL([HTOP_UNSUPPORTED], [test \"$my_htop_platform\" = unsupported])\n\nAC_SUBST(my_htop_platform)\nAC_CONFIG_FILES([Makefile htop.1])\nAC_OUTPUT\n\nif test \"$my_htop_platform\" = unsupported; then\n   echo \"\"\n   echo \"****************************************************************\"\n   echo \"WARNING! This platform is not currently supported by htop.\"\n   echo \"\"\n   echo \"The code will build, but it will produce a dummy version of htop\"\n   echo \"which shows no processes, using the files from the unsupported/\"\n   echo \"directory. This is meant to be a skeleton, to be used as a\"\n   echo \"starting point if you are porting htop to a new platform.\"\n   echo \"****************************************************************\"\n   echo \"\"\nfi\n\nAC_MSG_RESULT([\n  ${PACKAGE_NAME} ${VERSION}\n\n  platform:                  $my_htop_platform\n  os-release file:           $with_os_release\n  (Linux) proc directory:    $with_proc\n  (Linux) openvz:            $enable_openvz\n  (Linux) vserver:           $enable_vserver\n  (Linux) ancient vserver:   $enable_ancient_vserver\n  (Linux) delay accounting:  $enable_delayacct\n  (Linux) sensors:           $enable_sensors\n  (Linux) capabilities:      $enable_capabilities\n  unicode:                   $enable_unicode\n  affinity:                  $enable_affinity\n  unwind:                    $enable_unwind\n  hwloc:                     $enable_hwloc\n  debug:                     $enable_debug\n  static:                    $enable_static\n])\n"
        },
        {
          "name": "darwin",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "dragonflybsd",
          "type": "tree",
          "content": null
        },
        {
          "name": "freebsd",
          "type": "tree",
          "content": null
        },
        {
          "name": "generic",
          "type": "tree",
          "content": null
        },
        {
          "name": "htop.1.in",
          "type": "blob",
          "size": 22.501953125,
          "content": ".TH \"HTOP\" \"1\" \"2025\" \"@PACKAGE_STRING@\" \"User Commands\"\n.SH \"NAME\"\nhtop, pcp-htop \\- interactive process viewer\n.SH \"SYNOPSIS\"\n.B htop\n.RB [ \\-dCFhpustvH ]\n.br\n.B pcp-htop\n.RB [ \\-dCFhpustvH ]\n.RB [ \\-\\-host/-h\\ host ]\n.SH \"DESCRIPTION\"\n.B htop\nis a cross-platform ncurses-based process viewer.\n.LP\nIt is similar to\n.BR top ,\nbut allows you to scroll vertically and horizontally, and interact using\na pointing device (mouse).\nYou can observe all processes running on the system, along with their\ncommand line arguments, as well as view them in a tree format, select\nmultiple processes and act on them all at once.\n.LP\nTasks related to processes (killing, renicing) can be done without\nentering their PIDs.\n.LP\n.B pcp-htop\nis a version of\n.B htop\nbuilt using the Performance Co-Pilot (PCP) Metrics API (see \\c\n.BR PCPIntro (1),\n.BR PMAPI (3)),\nallowing to extend\n.B htop\nto display values from arbitrary metrics.\nSee the section below titled\n.B \"CONFIG FILES\"\nfor further details.\n.br\n.SH \"COMMAND-LINE OPTIONS\"\nMandatory arguments to long options are mandatory for short options too.\n.TP\n\\fB\\-d \\-\\-delay=DELAY\\fR\nDelay between updates, in tenths of a second. If the delay value is\nless than 1, it is increased to 1, i.e. 1/10 second. If the delay value\nis greater than 100, it is decreased to 100, i.e. 10 seconds.\n.TP\n\\fB\\-C \\-\\-no-color \\-\\-no-colour\\fR\nStart\n.B htop\nin monochrome mode\n.TP\n\\fB\\-F \\-\\-filter=FILTER\nFilter processes by terms matching the commands. The terms are matched\ncase-insensitive and as fixed strings (not regexs). You can separate multiple terms with \"|\".\n.TP\n\\fB\\-h \\-\\-help\nDisplay a help message and exit\n.TP\n\\fB\\-p \\-\\-pid=PID,PID...\\fR\nShow only the given PIDs\n.TP\n\\fB\\-s \\-\\-sort\\-key COLUMN\\fR\nSort by this column (use \\-\\-sort\\-key help for a column list).\nThis will force a list view unless you specify -t at the same time.\n.TP\n\\fB\\-u \\-\\-user=USERNAME|UID\\fR\nShow only the processes of a given user\n.TP\n\\fB\\-U \\-\\-no-unicode\\fR\nDo not use unicode but ASCII characters for graph meters\n.TP\n\\fB\\-M \\-\\-no-mouse\\fR\nDisable support of mouse control\n.TP\n\\fB\\-\\-readonly\\fR\nDisable all system and process changing features\n.TP\n\\fB\\-V \\-\\-version\nOutput version information and exit\n.TP\n\\fB\\-t \\-\\-tree\nShow processes in tree view. This can be used to force a tree view when\nrequesting a sort order with -s.\n.TP\n\\fB\\-H \\-\\-highlight-changes=DELAY\\fR\nHighlight new and old processes\n.TP\n\\fB\\-\\-drop-capabilities[=off|basic|strict]\\fR\nLinux only; this option needs to have been enabled at compile-time and\nrequires libcap support at runtime.\n.br\nDrop unneeded Linux capabilities.\nIn strict mode features like killing, changing process priorities and reading\nprocess delay accounting information will not work due to fewer capabilities\nbeing held.\n.SH \"INTERACTIVE COMMANDS\"\nThe following commands are supported while in\n.BR htop :\n.TP 5\n.B Tab, Shift-Tab\nSelect the next / the previous screen tab to display.\nYou can enable showing the screen tab names in the Setup screen (F2).\n.TP\n.B Up, Alt-k\nSelect (highlight) the previous process in the process list. Scroll the list\nif necessary.\n.TP\n.B Down, Alt-j\nSelect (highlight) the next process in the process list. Scroll the list if\nnecessary.\n.TP\n.B Left, Alt-h\nScroll the process list left.\n.TP\n.B Right, Alt-l\nScroll the process list right.\n.TP\n.B PgUp, PgDn\nScroll the process list up or down one window.\n.TP\n.B Home\nScroll to the top of the process list and select the first process.\n.TP\n.B End\nScroll to the bottom of the process list and select the last process.\n.TP\n.B Ctrl-A, ^\nScroll left to the beginning of the process entry (i.e. beginning of line).\n.TP\n.B Ctrl-E, $\nScroll right to the end of the process entry (i.e. end of line).\n.TP\n.B Space\nTag or untag a process. Commands that can operate on multiple processes,\nlike \"kill\", will then apply over the list of tagged processes, instead\nof the currently highlighted one.\n.TP\n.B c\nTag the current process and its children. Commands that can operate on multiple\nprocesses, like \"kill\", will then apply over the list of tagged processes,\ninstead of the currently highlighted one.\n.TP\n.B U\nUntag all processes (remove all tags added with the Space or c keys).\n.TP\n.B s\nTrace process system calls: if strace(1) is installed, pressing this key\nwill attach it to the currently selected process, presenting a live\nupdate of system calls issued by the process.\n.TP\n.B l\nDisplay open files for a process: if lsof(1) is installed, pressing this key\nwill display the list of file descriptors opened by the process.\n.TP\n.B w\nDisplay the command line of the selected process in a separate screen, wrapped\nonto multiple lines as needed.\n.TP\n.B x\nDisplay the active file locks of the selected process in a separate screen.\n.TP\n.B F1, h, ?\nGo to the help screen\n.TP\n.B F2, S\nGo to the setup screen, where you can configure the meters displayed at the top\nof the screen, set various display options, choose among color schemes, and\nselect which columns are displayed, in which order.\n.TP\n.B F3, /\nIncrementally search the command lines of all the displayed processes. The\ncurrently selected (highlighted) command will update as you type. While in\nsearch mode, pressing F3 will cycle through matching occurrences.\nPressing Shift-F3 will cycle backwards.\n\nAlternatively the search can be started by simply typing the command\nyou are looking for, although for the first character normal key\nbindings take precedence.\n.TP\n.B F4, \\\\\\\\\nIncremental process filtering: type in part of a process command line and\nonly processes whose names match will be shown. To cancel filtering,\nenter the Filter option again and press Esc.\nThe matching is done case-insensitive. Terms are fixed strings (no regex).\nYou can separate multiple terms with \"|\".\n.TP\n.B F5, t\nTree view: organize processes by parenthood, and layout the relations\nbetween them as a tree. Toggling the key will switch between tree and\nyour previously selected sort view. Selecting a sort view will exit\ntree view.\n.TP\n.B F6, <, >\nSelects a field for sorting, also accessible through < and >.\nThe current sort field is indicated by a highlight in the header.\n.TP\n.B F7, ]\nIncrease the selected process's priority (subtract from 'nice' value).\nThis can only be done by the superuser.\n.TP\n.B F8, [\nDecrease the selected process's priority (add to 'nice' value)\n.TP\n.B Shift-F7, }\nIncrease the selected process's autogroup priority (subtract from autogroup 'nice' value).\nThis can only be done by the superuser.\n.TP\n.B Shift-F8, {\nDecrease the selected process's autogroup priority (add to autogroup 'nice' value)\n.TP\n.B F9, k\n\"Kill\" process: sends a signal which is selected in a menu, to one or a group\nof processes. If processes were tagged, sends the signal to all tagged processes.\nIf none is tagged, sends to the currently selected process.\n.TP\n.B F10, q\nQuit\n.TP\n.B I\nInvert the sort order: if sort order is increasing, switch to decreasing, and\nvice-versa.\n.TP\n.B +, \\-, *\nWhen in tree view mode, expand or collapse subtree. When a subtree is collapsed\na \"+\" sign shows to the left of the process name.\nPressing \"*\" will expand or collapse all children of PIDs without parents, so\ntypically PID 1 (init) and PID 2 (kthreadd on Linux, if kernel threads are shown).\n.TP\n.B a (on multiprocessor machines)\nSet CPU affinity: mark which CPUs a process is allowed to use.\n.TP\n.B u\nShow only processes owned by a specified user.\n.TP\n.B N\nSort by PID.\n.TP\n.B M\nSort by memory usage (top compatibility key).\n.TP\n.B P\nSort by processor usage (top compatibility key).\n.TP\n.B T\nSort by time (top compatibility key).\n.TP\n.B F\n\"Follow\" process: if the sort order causes the currently selected process\nto move in the list, make the selection bar follow it. This is useful for\nmonitoring a process: this way, you can keep a process always visible on\nscreen. When a movement key is used, \"follow\" loses effect.\n.TP\n.B K\nHide kernel threads: prevent the threads belonging the kernel to be\ndisplayed in the process list. (This is a toggle key.)\n.TP\n.B H\nHide user threads: on systems that represent them differently than ordinary\nprocesses (such as recent NPTL-based systems), this can hide threads from\nuserspace processes in the process list. (This is a toggle key.)\n.TP\n.B O\nHide containerized processes: prevent processes running in a container\nfrom being displayed in the process list. (This is a toggle key.)\n.TP\n.B p\nShow full paths to running programs, where applicable. (This is a toggle key.)\n.TP\n.B Z\nPause/resume process updates.\n.TP\n.B m\nMerge exe, comm and cmdline, where applicable. (This is a toggle key.)\n.TP\n.B Ctrl-L\nRefresh: redraw screen and recalculate values.\n.TP\n.B Numbers\nPID search: type in process ID and the selection highlight will be moved to it.\n.PD\n.SH \"COLUMNS\"\nThe following columns can display data about each process. A value of '\\-' in\nall the rows indicates that a column is unsupported on your system, or\ncurrently unimplemented in\n.BR htop .\nThe names below are the ones used in the\n\"Available Columns\" section of the setup screen. If a different name is\nshown in\n.BR htop 's\nmain screen, it is shown below in parenthesis.\n.TP 5\n.B Command\nThe full command line of the process (i.e. program name and arguments).\n\nIf the option 'Merge exe, comm and cmdline in Command' (toggled by the 'm' key)\nis active, the executable path (/proc/[pid]/exe) and the command name\n(/proc/[pid]/comm) are also shown merged with the command line, if available.\n\nThe program basename is highlighted if set in the configuration. Additional\nhighlighting can be configured for stale executables (cf. EXE column below).\n\nThe Command column should be the last column in each screen as can get very long\nand profits from being able to extend its length dynamically.\n.TP\n.B COMM\nThe command name of the process obtained from /proc/[pid]/comm, if readable.\n\nRequires Linux kernel 2.6.33 or newer.\n.TP\n.B EXE\nThe abbreviated basename of the executable of the process, obtained from\n/proc/[pid]/exe, if readable. htop is able to read this file on linux for ALL\nthe processes only if it has the capability CAP_SYS_PTRACE or root privileges.\n\nThe basename is marked in red if the executable used to run the process has\nbeen replaced or deleted on disk since the process started. The information is\nobtained by processing the contents of /proc/[pid]/exe.\n\nFurthermore the basename is marked in yellow if any library is reported as having\nbeen replaced or deleted on disk since it was last loaded. The information is\nobtained by processing the contents of /proc/[pid]/maps.\n\nWhen deciding the color the replacement of the main executable always takes\nprecedence over replacement of any other library. If only the memory map indicates\na replacement of the main executable, this will show as if any other library had\nbeen replaced or deleted.\n\nThis additional color markup can be configured in the \"Display Options\" section of\nthe setup screen.\n\nDisplaying EXE requires CAP_SYS_PTRACE and PTRACE_MODE_READ_FSCRED.\n.TP\n.B PID\nThe process ID.\n.TP\n.B STATE (S)\nThe state of the process:\n   \\fBS\\fR for sleeping\n   \\fBI\\fR for idle (longer inactivity than sleeping on platforms that distinguish)\n   \\fBR\\fR for running\n   \\fBD\\fR for disk sleep (uninterruptible)\n   \\fBZ\\fR for zombie (waiting for parent to read its exit status)\n   \\fBT\\fR for traced or suspended (e.g by SIGTSTP)\n   \\fBW\\fR for paging\n.TP\n.B PPID\nThe parent process ID.\n.TP\n.B PGRP\nThe process's group ID.\n.TP\n.B SESSION (SID)\nThe process's session ID.\n.TP\n.B TTY\nThe controlling terminal of the process.\n.TP\n.B TPGID\nThe process ID of the foreground process group of the controlling terminal.\n.TP\n.B MINFLT\nThe number of page faults happening in the main memory.\n.TP\n.B CMINFLT\nThe number of minor faults for the process's waited-for children (see MINFLT above).\n.TP\n.B MAJFLT\nThe number of page faults happening out of the main memory.\n.TP\n.B CMAJFLT\nThe number of major faults for the process's waited-for children (see MAJFLT above).\n.TP\n.B UTIME (UTIME+)\nThe user CPU time, which is the amount of time the process has spent executing\non the CPU in user mode (i.e. everything but system calls), measured in clock\nticks.\n.TP\n.B STIME (STIME+)\nThe system CPU time, which is the amount of time the kernel has spent\nexecuting system calls on behalf of the process, measured in clock ticks.\n.TP\n.B CUTIME (CUTIME+)\nThe children's user CPU time, which is the amount of time the process's\nwaited-for children have spent executing in user mode (see UTIME above).\n.TP\n.B CSTIME (CSTIME+)\nThe children's system CPU time, which is the amount of time the kernel has spent\nexecuting system calls on behalf of all the process's waited-for children (see\nSTIME above).\n.TP\n.B PRIORITY (PRI)\nThe kernel's internal priority for the process, usually just its nice value\nplus twenty. Different for real-time processes.\n.TP\n.B NICE (NI)\nThe nice value of a process, from 19 (low priority) to -20 (high priority). A\nhigh value means the process is being nice, letting others have a higher\nrelative priority. The usual OS permission restrictions for adjusting priority apply.\n.TP\n.B STARTTIME (START)\nThe time the process was started.\n.TP\n.B PROCESSOR (CPU)\nThe ID of the CPU the process last executed on.\n.TP\n.B M_VIRT (VIRT)\nThe size of the virtual memory of the process.\n.TP\n.B M_RESIDENT (RES)\nThe resident set size (text + data + stack) of the process (i.e. the size of the\nprocess's used physical memory).\n.TP\n.B M_SHARE (SHR)\nThe size of the process's shared pages.\n.TP\n.B M_TRS (CODE)\nThe text resident set size of the process (i.e. the size of the process's\nexecutable instructions).\n.TP\n.B M_DRS (DATA)\nThe data resident set size (data + stack) of the process (i.e. the size of anything\nexcept the process's executable instructions).\n.TP\n.B M_LRS (LIB)\nThe library size of the process.\n.TP\n.B M_SWAP (SWAP)\nThe size of the process's swapped pages.\n.TP\n.B M_PSS (PSS)\nThe proportional set size, same as M_RESIDENT but each page is divided by the\nnumber of processes sharing it.\n.TP\n.B M_M_PSSWP (PSSWP)\nThe proportional swap share of this mapping, unlike M_SWAP this does not take\ninto account swapped out page of underlying shmem objects.\n.TP\n.B ST_UID (UID)\nThe user ID of the process owner.\n.TP\n.B PERCENT_CPU (CPU%)\nThe percentage of the CPU time that the process is currently using.\nThis is the default way to represent CPU usage in Linux. Each process can\nconsume up to 100% which means the full capacity of the core it is running\non. This is sometimes called \"Irix mode\" e.g. in\n.BR top (1).\n.TP\n.B PERCENT_NORM_CPU (NCPU%)\nThe percentage of the CPU time that the process is currently using normalized\nby CPU count. This is sometimes called \"Solaris mode\" e.g. in\n.BR top (1).\n.TP\n.B PERCENT_MEM (MEM%)\nThe percentage of memory the process is currently using (based on the process's\nresident memory size, see M_RESIDENT above).\n.TP\n.B USER\nThe username of the process owner, or the user ID if the name can't be\ndetermined.\n\nOn Linux the username is highlighted if the process has elevated privileges,\ni.e. if it has been started from binaries with file capabilities set or\nretained Linux capabilities, via the ambient set, after switching from the\nroot user.\n.TP\n.B TIME (TIME+)\nThe time, measured in clock ticks that the process has spent in user and system\ntime (see UTIME, STIME above).\n.TP\n.B NLWP\nThe number of Light-Weight Processes (=threads) in the process.\n.TP\n.B TGID\nThe thread group ID.\n.TP\n.B CTID\nOpenVZ container ID, a.k.a virtual environment ID.\n.TP\n.B VPID\nOpenVZ process ID.\n.TP\n.B VXID\nVServer process ID.\n.TP\n.B RCHAR (RD_CHAR)\nThe number of bytes the process has read.\n.TP\n.B WCHAR (WR_CHAR)\nThe number of bytes the process has written.\n.TP\n.B SYSCR (RD_SYSC)\nThe number of read(2) syscalls for the process.\n.TP\n.B SYSCW (WR_SYSC)\nThe number of write(2) syscalls for the process.\n.TP\n.B RBYTES (IO_RBYTES)\nBytes of read(2) I/O for the process.\n.TP\n.B WBYTES (IO_WBYTES)\nBytes of write(2) I/O for the process.\n.TP\n.B CNCLWB (IO_CANCEL)\nBytes of cancelled write(2) I/O.\n.TP\n.B IO_READ_RATE (DISK READ)\nThe I/O rate of read(2) in bytes per second, for the process.\n.TP\n.B IO_WRITE_RATE (DISK WRITE)\nThe I/O rate of write(2) in bytes per second, for the process.\n.TP\n.B IO_RATE (DISK R/W)\nThe I/O rate, IO_READ_RATE + IO_WRITE_RATE (see above).\n.TP\n.B CGROUP\nWhich cgroup the process is in. For a shortened view see the CCGROUP column below.\n.TP\n.B CCGROUP\nShortened view of the cgroup name that the process is in.\nThis performs some pattern-based replacements to shorten the displayed string and thus condense the information.\n   \\fB/*.slice\\fR is shortened to \\fB/[*]\\fR (exceptions below)\n   \\fB/system.slice\\fR is shortened to \\fB/[S]\\fR\n   \\fB/user.slice\\fR is shortened to \\fB/[U]\\fR\n   \\fB/user-*.slice\\fR is shortened to \\fB/[U:*]\\fR (directly preceding \\fB/[U]\\fR before dropped)\n   \\fB/machine.slice\\fR is shortened to \\fB/[M]\\fR\n   \\fB/machine-*.scope\\fR is shortened to \\fB/[SNC:*]\\fR (SNC: systemd nspawn container), uppercase for the monitor\n   \\fB/lxc.monitor.*\\fR is shortened to \\fB/[LXC:*]\\fR\n   \\fB/lxc.payload.*\\fR is shortened to \\fB/[lxc:*]\\fR\n   \\fB/*.scope\\fR is shortened to \\fB/!*\\fR\n   \\fB/*.service\\fR is shortened to \\fB/*\\fR (suffix removed)\n\nEncountered escape sequences (e.g. from systemd) inside the cgroup name are not decoded.\n.TP\n.B OOM\nOOM killer score.\n.TP\n.B CTXT\nIncremental sum of voluntary and nonvoluntary context switches.\n.TP\n.B IO_PRIORITY (IO)\nThe I/O scheduling class followed by the priority if the class supports it:\n   \\fBR\\fR for Realtime\n   \\fBB\\fR for Best-effort\n   \\fBid\\fR for Idle\n.TP\n.B PERCENT_CPU_DELAY (CPUD%)\nThe percentage of time spent waiting for a CPU (while runnable). Requires CAP_NET_ADMIN.\n.TP\n.B PERCENT_IO_DELAY (IOD%)\nThe percentage of time spent waiting for the completion of synchronous block I/O. Requires CAP_NET_ADMIN.\n.TP\n.B PERCENT_SWAP_DELAY (SWAPD%)\nThe percentage of time spent swapping in pages. Requires CAP_NET_ADMIN.\n.TP\n.B AGRP\nThe autogroup identifier for the process. Requires Linux CFS to be enabled.\n.TP\n.B ANI\nThe autogroup nice value for the process autogroup. Requires Linux CFS to be enabled.\n.TP\n.B All other flags\nCurrently unsupported (always displays '-').\n.SH \"EXTERNAL LIBRARIES\"\nWhile\n.B htop\ndepends on most of the libraries it uses at build time there are two\nnoteworthy exceptions to this rule. These exceptions both relate to\ndata displayed in meters displayed in the header of\n.B htop\nand were intentionally created as optional runtime dependencies instead.\nThese exceptions are described below:\n.TP\n.B libsystemd\nThe bindings for libsystemd are used in the SystemD meter to determine\nthe number of active services and the overall system state. Looking for\nthe functions to determine these information at runtime allows for\nbuilds to support these meters without forcing the package manager\nto install these libraries on systems that otherwise don't use systemd.\n\nSummary: no build time dependency, optional runtime dependency on\n.B libsystemd\nvia dynamic loading, with\n.B systemctl(1)\nfallback.\n.TP\n.B libsensors\nThe bindings for libsensors are used for the CPU temperature readings\nin the CPU usage meters if displaying the temperature is enabled through\nthe setup screen. In order for\n.B htop\nto show these temperatures correctly though, a proper configuration\nof libsensors through its usual configuration files is assumed and that\nall CPU cores correspond to temperature sensors from the\n.B coretemp\ndriver with core 0 corresponding to a sensor labelled \"Core 0\". The\npackage temperature may be given as \"Package id 0\". If missing it is\ninferred as the maximum value from the available per-core readings.\n\nSummary: build time dependency on\n.B libsensors(3)\nC header files, optional runtime dependency on\n.B libsensors(3)\nvia dynamic loading.\n.SH \"CONFIG FILES\"\nBy default\n.B htop\nreads its configuration from the XDG-compliant path\n.IR ~/.config/htop/htoprc .\nThe configuration file is overwritten upon clean exit by\n.BR htop 's\nin-program Setup configuration, so it should not be hand-edited.\nIf no user configuration exists\n.B htop\ntries to read the system-wide configuration from\n.I @sysconfdir@/htoprc\nand as a last resort, falls back to its hard coded defaults.\n.LP\nYou may override the location of the configuration file using the $HTOPRC\nenvironment variable (so you can have multiple configurations for different\nmachines that share the same home directory, for example).\n.LP\nThe\n.B pcp-htop\nutility makes use of\n.I htoprc\nin a similar way.\nHowever,\n.B pcp-htop\nreads its configuration from a path more conventionally used by\nPerformance Co-Pilot tools,\n.IR ~/.pcp/htop/htoprc ,\nin order to provide separate configuration when both\n.B htop\nand\n.B pcp-htop\nare installed and in use.\n.B pcp-htop\nsupports additional configuration files below the same directory\nallowing new meters, columns and screen tabs to be added via the\nSetup screen (F2).\nThis displays additional Available Meters, Available Column and\nScreen Tabs for each meter, column or screen configuration file.\n.LP\nThese\n.B pcp-htop\nconfiguration files are read once at startup.\nThe format of these files is described in detail in the\n.BR pcp-htop (5)\nmanual page.\n.LP\nThis functionality makes available many thousands of Performance\nCo-Pilot metrics for display by\n.BR pcp-htop ,\nas well as the ability to display custom metrics added at individual sites.\nApplications and services instrumented using the OpenMetrics format\n.B https://openmetrics.io\ncan also be displayed by\n.B pcp-htop\nif the\n.BR pmdaopenmetrics (1)\ncomponent is configured.\n.LP\nThe configuration for both\n.B htop\nand\n.B pcp-htop\nis only saved when a clean exit is performed. Sending any signal will cause\n.I all configuration changes to be lost.\n.SH \"MEMORY SIZES\"\nMemory sizes in\n.B htop\nare displayed in a human-readable form.\nSizes are printed in powers of 1024 using binary IEC units.\nIf no suffix is shown the units are implicitly K as in KiB (kibibyte, 1 KiB = 1024 bytes).\n.LP\nThe decision to use this convention was made in order to conserve screen\nspace and make memory size representations consistent throughout\n.B htop\nas allocations are granular to full memory pages (4 KiB for most platforms).\n.SH \"SEE ALSO\"\n.BR proc (5),\n.BR top (1),\n.BR free (1),\n.BR ps (1),\n.BR uptime (1)\nand\n.BR limits.conf (5).\n.SH \"SEE ALSO FOR PCP\"\n.BR pmdaopenmetrics (1),\n.BR PCPIntro (1),\n.BR PMAPI (3),\nand\n.BR pcp-htop (5).\n.SH \"AUTHORS\"\n.B htop\nwas originally developed by Hisham Muhammad.\nNowadays it is maintained by the community at <htop@groups.io>.\n.LP\n.B pcp-htop\nis maintained as a collaboration between the <htop@groups.io> and <pcp@groups.io>\ncommunities, and forms part of the Performance Co-Pilot suite of tools.\n.SH \"COPYRIGHT\"\nCopyright \\(co 2004-2019 Hisham Muhammad.\n.br\nCopyright \\(co 2020-2025 htop dev team.\n.LP\nLicense GPLv2+: GNU General Public License version 2 or, at your option, any later version.\n.LP\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"
        },
        {
          "name": "htop.c",
          "type": "blob",
          "size": 0.34765625,
          "content": "/*\nhtop - htop.c\n(C) 2004-2011 Hisham H. Muhammad\n(C) 2020-2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include \"CommandLine.h\"\n\n\nconst char* program = PACKAGE;\n\nint main(int argc, char** argv) {\n   return CommandLine_run(argc, argv);\n}\n"
        },
        {
          "name": "htop.desktop",
          "type": "blob",
          "size": 2.486328125,
          "content": "[Desktop Entry]\nType=Application\nVersion=1.0\nName=Htop\nGenericName=Process Viewer\nGenericName[ca]=Visualitzador de processos\nGenericName[da]=Procesfremviser\nGenericName[de]=Prozessanzeige\nGenericName[en_GB]=Process Viewer\nGenericName[es]=Visor de procesos\nGenericName[fi]=Prosessikatselin\nGenericName[fr]=Visualiseur de processus\nGenericName[gl]=Visor de procesos\nGenericName[it]=Visore dei processi\nGenericName[ko]=íë¡ì¸ì¤ ë·°ì´\nGenericName[nb]=Prosessviser\nGenericName[nl]=Viewer van processen\nGenericName[nn]=Prosessvisar\nGenericName[pl]=PrzeglÄdarka procesÃ³w\nGenericName[pt]=Visualizador de Processos\nGenericName[pt_BR]=Visualizador de processos\nGenericName[ru]=ÐÐ¾Ð½Ð¸ÑÐ¾Ñ Ð¿ÑÐ¾ÑÐµÑÑÐ¾Ð²\nGenericName[sk]=PrehliadaÄ procesov\nGenericName[sl]=Pregledovalnik opravil\nGenericName[sr@ijekavian]=ÐÑÐ¸ÐºÐ°Ð·Ð¸Ð²Ð°Ñ Ð¿ÑÐ¾ÑÐµÑÐ°\nGenericName[sr@ijekavianlatin]=PrikazivaÄ procesa\nGenericName[sr@latin]=PrikazivaÄ procesa\nGenericName[sr]=ÐÑÐ¸ÐºÐ°Ð·Ð¸Ð²Ð°Ñ Ð¿ÑÐ¾ÑÐµÑÐ°\nGenericName[sv]=Processvisning\nGenericName[tr]=SÃ¼reÃ§ GÃ¶rÃ¼ntÃ¼leyici\nGenericName[uk]=ÐÐµÑÐµÐ³Ð»ÑÐ´ Ð¿ÑÐ¾ÑÐµÑÑÐ²\nGenericName[zh_CN]=è¿ç¨æ¥çå¨\nGenericName[zh_TW]=è¡ç¨æª¢è¦å¨\nComment=Show System Processes\nComment[ca]=Visualitzeu els processos del sistema\nComment[da]=Vis systemprocesser\nComment[de]=Systemprozesse anzeigen\nComment[en_GB]=Show System Processes\nComment[es]=Mostrar procesos del sistema\nComment[fi]=Katsele jÃ¤rjestelmÃ¤n prosesseja\nComment[fr]=Affiche les processus systÃ¨me\nComment[gl]=Mostrar os procesos do sistema.\nComment[it]=Mostra processi di sistema\nComment[ko]=ìì¤í íë¡ì¸ì¤ ë³´ê¸°\nComment[nb]=Vis systemprosesser\nComment[nl]=Systeemprocessen tonen\nComment[nn]=Vis systemprosessar\nComment[pl]=PokaÅ¼ procesy systemowe\nComment[pt]=Mostrar os Processos do Sistema\nComment[pt_BR]=Mostra os processos do sistema\nComment[ru]=ÐÑÐ¾ÑÐ¼Ð¾ÑÑ ÑÐ¿Ð¸ÑÐºÐ° Ð¿ÑÐ¾ÑÐµÑÑÐ¾Ð² Ð² ÑÐ¸ÑÑÐµÐ¼Ðµ\nComment[sk]=ZobraziÅ¥ systÃ©movÃ© procesy\nComment[sl]=Prikaz sistemskih opravil\nComment[sr@ijekavian]=ÐÑÐ¸ÐºÐ°Ð· ÑÐ¸ÑÑÐµÐ¼ÑÐºÐ¸Ñ Ð¿ÑÐ¾ÑÐµÑÐ°\nComment[sr@ijekavianlatin]=Prikaz sistemskih procesa\nComment[sr@latin]=Prikaz sistemskih procesa\nComment[sr]=ÐÑÐ¸ÐºÐ°Ð· ÑÐ¸ÑÑÐµÐ¼ÑÐºÐ¸Ñ Ð¿ÑÐ¾ÑÐµÑÐ°\nComment[sv]=Visa systemprocesser\nComment[tr]=Sistem SÃ¼reÃ§lerini GÃ¶ster\nComment[uk]=ÐÐµÑÐµÐ³Ð»ÑÐ´ ÑÐ¸ÑÑÐµÐ¼Ð½Ð¸Ñ Ð¿ÑÐ¾ÑÐµÑÑÐ²\nComment[zh_CN]=æ¾ç¤ºç³»ç»è¿ç¨\nComment[zh_TW]=é¡¯ç¤ºç³»çµ±è¡ç¨\nIcon=htop\nExec=htop\nTerminal=true\nCategories=System;Monitor;ConsoleOnly;\nKeywords=system;process;task\n"
        },
        {
          "name": "htop.png",
          "type": "blob",
          "size": 2.5546875,
          "content": null
        },
        {
          "name": "htop.svg",
          "type": "blob",
          "size": 10.939453125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"30.398mm\" height=\"30.399mm\" version=\"1.1\" viewBox=\"0 0 30.398 30.399\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n <defs>\n  <linearGradient id=\"aj\" x1=\"42.304\" x2=\"42.245\" y1=\"57.522\" y2=\"50.607\" gradientTransform=\"translate(41.404 221.45)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#c\"/>\n  <linearGradient id=\"c\">\n   <stop stop-color=\"#363d36\" offset=\"0\"/>\n   <stop stop-color=\"#565d56\" offset=\".2\"/>\n   <stop stop-color=\"#6c766c\" offset=\".8\"/>\n   <stop stop-color=\"#8c968c\" offset=\"1\"/>\n  </linearGradient>\n  <filter id=\"f\" x=\"-.063963\" y=\"-.025049\" width=\"1.1279\" height=\"1.0501\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.072789412\"/>\n  </filter>\n  <linearGradient id=\"ai\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(41.508 221.43)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <linearGradient id=\"a\">\n   <stop stop-color=\"#8bf18b\" offset=\"0\"/>\n   <stop stop-color=\"#5bc15b\" offset=\".2\"/>\n   <stop stop-color=\"#47a347\" offset=\".8\"/>\n   <stop stop-color=\"#177317\" offset=\"1\"/>\n  </linearGradient>\n  <filter id=\"l\" x=\"-.08928\" y=\"-.022545\" width=\"1.1786\" height=\"1.0451\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.065909587\"/>\n  </filter>\n  <linearGradient id=\"d\" x1=\"42.304\" x2=\"42.245\" y1=\"57.522\" y2=\"50.607\" gradientTransform=\"translate(24.234,-9.2667)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#c\"/>\n  <filter id=\"e\" x=\"-.063963\" y=\"-.025049\" width=\"1.1279\" height=\"1.0501\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.072789412\"/>\n  </filter>\n  <linearGradient id=\"ah\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(44.242 221.43)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <filter id=\"k\" x=\"-.08928\" y=\"-.022545\" width=\"1.1786\" height=\"1.0451\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.065909587\"/>\n  </filter>\n  <linearGradient id=\"ag\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(46.976 221.43)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <filter id=\"j\" x=\"-.08928\" y=\"-.022545\" width=\"1.1786\" height=\"1.0451\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.065909587\"/>\n  </filter>\n  <linearGradient id=\"af\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(49.709 221.43)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <filter id=\"am\" x=\"-.08928\" y=\"-.022545\" width=\"1.1786\" height=\"1.0451\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.065909587\"/>\n  </filter>\n  <linearGradient id=\"ae\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(52.443 221.43)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <filter id=\"al\" x=\"-.08928\" y=\"-.022545\" width=\"1.1786\" height=\"1.0451\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.065909587\"/>\n  </filter>\n  <linearGradient id=\"ad\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(55.177 221.43)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <filter id=\"ak\" x=\"-.08928\" y=\"-.022545\" width=\"1.1786\" height=\"1.0451\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.065909587\"/>\n  </filter>\n  <linearGradient id=\"ac\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(57.91 221.43)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <filter id=\"i\" x=\"-.08928\" y=\"-.022545\" width=\"1.1786\" height=\"1.0451\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.065909587\"/>\n  </filter>\n  <linearGradient id=\"ab\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(60.644 221.43)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#b\"/>\n  <linearGradient id=\"b\">\n   <stop stop-color=\"#fe7f7f\" offset=\"0\"/>\n   <stop stop-color=\"#ce4f4f\" offset=\".2\"/>\n   <stop stop-color=\"#b23030\" offset=\".8\"/>\n   <stop stop-color=\"#920000\" offset=\"1\"/>\n  </linearGradient>\n  <filter id=\"h\" x=\"-.08928\" y=\"-.022545\" width=\"1.1786\" height=\"1.0451\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.065909587\"/>\n  </filter>\n  <linearGradient id=\"aa\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(63.376 221.43)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#b\"/>\n  <filter id=\"g\" x=\"-.08928\" y=\"-.022545\" width=\"1.1786\" height=\"1.0451\" color-interpolation-filters=\"sRGB\">\n   <feGaussianBlur stdDeviation=\"0.065909587\"/>\n  </filter>\n  <linearGradient id=\"z\" x1=\"42.304\" x2=\"42.245\" y1=\"57.522\" y2=\"50.607\" gradientTransform=\"translate(41.404 210.02)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#c\"/>\n  <linearGradient id=\"y\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(41.508 210)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <linearGradient id=\"x\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(44.242 210)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <linearGradient id=\"w\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(46.976 210)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <linearGradient id=\"v\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(57.91 210)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <linearGradient id=\"u\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(63.376 210)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#b\"/>\n  <linearGradient id=\"t\" x1=\"42.304\" x2=\"42.245\" y1=\"57.522\" y2=\"50.607\" gradientTransform=\"translate(41.404 232.87)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#c\"/>\n  <linearGradient id=\"s\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(41.508 232.85)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <linearGradient id=\"r\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(44.242 232.85)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <linearGradient id=\"q\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(46.976 232.85)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n  <linearGradient id=\"p\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(60.644 232.85)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#b\"/>\n  <linearGradient id=\"o\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(63.376 232.85)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#b\"/>\n  <linearGradient id=\"n\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(57.91 232.85)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#b\"/>\n  <linearGradient id=\"m\" x1=\"44.761\" x2=\"44.761\" y1=\"50.493\" y2=\"57.517\" gradientTransform=\"translate(60.644 210)\" gradientUnits=\"userSpaceOnUse\" xlink:href=\"#a\"/>\n </defs>\n <g transform=\"translate(.08011 -.58599)\">\n  <g transform=\"matrix(.98769 0 0 .99741 -80.905 -258.93)\" fill-rule=\"evenodd\">\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -76.353)\" d=\"m82.188 271.97 0.0251 6.963 2.7061-8e-3v-1.2194h-1.0357v-4.602h1.019v-1.1442z\" fill=\"url(#aj)\" filter=\"url(#f)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -76.353)\" d=\"m85.401 271.95v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#ai)\" filter=\"url(#l)\"/>\n   <path transform=\"matrix(-.99856 0 0 1.2772 177.16 218.32)\" d=\"m65.017 41.255 0.02508 6.963 2.7061-0.0084v-1.2194h-1.0357v-4.602h1.019v-1.1442z\" fill=\"url(#d)\" filter=\"url(#e)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -76.353)\" d=\"m88.135 271.95v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#ah)\" filter=\"url(#k)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -76.353)\" d=\"m90.868 271.95v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#ag)\" filter=\"url(#j)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -76.353)\" d=\"m93.602 271.95v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#af)\" filter=\"url(#am)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -76.353)\" d=\"m96.335 271.95v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#ae)\" filter=\"url(#al)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -76.353)\" d=\"m99.069 271.95v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#ad)\" filter=\"url(#ak)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -76.353)\" d=\"m101.8 271.95v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#ac)\" filter=\"url(#i)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -76.353)\" d=\"m104.54 271.95v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#ab)\" filter=\"url(#h)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -76.353)\" d=\"m107.27 271.95v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#aa)\" filter=\"url(#g)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -72.134)\" d=\"m82.188 260.54 0.0251 6.963 2.7061-8e-3v-1.2194h-1.0357v-4.602h1.019v-1.1442z\" fill=\"url(#z)\" filter=\"url(#f)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -72.134)\" d=\"m85.401 260.52v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#y)\" filter=\"url(#l)\"/>\n   <path transform=\"matrix(-.99856 0 0 1.2772 177.16 207.94)\" d=\"m65.017 41.255 0.02508 6.963 2.7061-0.0084v-1.2194h-1.0357v-4.602h1.019v-1.1442z\" fill=\"url(#d)\" filter=\"url(#e)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -72.134)\" d=\"m88.135 260.52v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#x)\" filter=\"url(#k)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -72.134)\" d=\"m90.868 260.52v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#w)\" filter=\"url(#j)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -72.134)\" d=\"m101.8 260.52v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#v)\" filter=\"url(#i)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -72.134)\" d=\"m107.27 260.52v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#u)\" filter=\"url(#g)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -80.616)\" d=\"m82.188 283.39 0.0251 6.963 2.7061-8e-3v-1.2194h-1.0357v-4.602h1.019v-1.1442z\" fill=\"url(#t)\" filter=\"url(#f)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -80.616)\" d=\"m85.401 283.37v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#s)\" filter=\"url(#l)\"/>\n   <path transform=\"matrix(-.99856 0 0 1.2772 177.16 228.65)\" d=\"m65.017 41.255 0.02508 6.963 2.7061-0.0084v-1.2194h-1.0357v-4.602h1.019v-1.1442z\" fill=\"url(#d)\" filter=\"url(#e)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -80.616)\" d=\"m88.135 283.37v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#r)\" filter=\"url(#k)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -80.616)\" d=\"m90.868 283.37v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#q)\" filter=\"url(#j)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -80.616)\" d=\"m104.54 283.37v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#p)\" filter=\"url(#h)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -80.616)\" d=\"m107.27 283.37v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#o)\" filter=\"url(#g)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -80.616)\" d=\"m101.8 283.37v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#n)\" filter=\"url(#h)\"/>\n   <path transform=\"matrix(.99856 0 0 1.2772 .14037 -72.134)\" d=\"m104.54 260.52v7.0132h1.7718v-7.0162h-1.7718z\" fill=\"url(#m)\" filter=\"url(#i)\"/>\n  </g>\n </g>\n</svg>\n"
        },
        {
          "name": "iwyu",
          "type": "tree",
          "content": null
        },
        {
          "name": "linux",
          "type": "tree",
          "content": null
        },
        {
          "name": "netbsd",
          "type": "tree",
          "content": null
        },
        {
          "name": "openbsd",
          "type": "tree",
          "content": null
        },
        {
          "name": "pcp-htop.5.in",
          "type": "blob",
          "size": 6.5009765625,
          "content": ".TH \"PCP-HTOP\" \"5\" \"2025\" \"@PACKAGE_STRING@\" \"File Formats\"\n.SH \"NAME\"\n\\f3pcp-htop\\f1 \\- pcp-htop configuration file\n.SH \"DESCRIPTION\"\n.B pcp-htop\nis a customizable performance metrics reporting tool.\nIt has a dynamic architecture, where a set of configuration files\nprovide additional, optional meters and columns to extend the fixed\nset of display options provided by regular\n.BR htop .\n.LP\nThese configuration files can be provided from both system-wide\nlocations (first\n.I @sysconfdir@/pcp/htop\nthen\n.IR @datarootdir@/pcp/htop )\nand below the user's home directory (usually\n.IR ~/.config/htop ).\nWithin these locations the\n.I meters\nand\n.I columns\nare scanned for dynamic Meter and Column specifications.\n.LP\nMeters are displayed in the top part of the\n.B pcp-htop\nwindow, and columns are displayed in the lower part.\nMeters tend to display system-wide metrics, and Columns\ndisplay metrics about individual processes.\n.LP\nThe formats are similar but have slightly different requirements.\nBoth formats follow the common ini-style. Blank lines are ignored.\nLines starting with the \"#\" character are treated as comments.\n.SH \"METERS\"\nThe following is an example configuration for a new Redis meter:\n.LP\n.ft CW\n.nf\n.in +0.5i\n[redisclient]\ncaption = Redis clients\ntype = bar\nblocked.metric = redis.blocked_clients\nblocked.color = blue\nblocked.label = blk\nclients.metric = redis.connected_clients\nclients.color = green\nclients.label = conn\n.in\n.fi\n.ft 1\n.LP\nA configuration file can contain multiple meter definitions.\nEach definition begins with a identifying name enclosed by\nsquare brackets \\-\n.I redisclient\nin this example.\nThe name is used internally within\n.B pcp-htop\nand must be unique, must begin with an alphabetic character,\nand may subsequently only contain alphanumeric characters or\nthe underscore character.\nNo whitespace or other characters are allowed.\n.LP\nThere are several parameters that define the way the meter\nwill be displayed to the user.\n.TP 5\n.B caption\nThis value is displayed on the Setup screen once the meter\nhas been selected.\nA truncated version of the\n.I caption\nwill also be displayed (followed by a colon) on the primary\ndisplay while the meter is updating.\n.TP\n.B description\nThis can be used to provide more detail during the meter\nselection process on the Setup screen, and if present it is\ndisplayed in the \"Available Meters\" column.\nIf not present, the\n.B caption\nwill be used for this.\nIf neither is present, the internal (mandatory)\n.B name\nwill be used.\n.TP\n.B type\nThis setting allows a preferred default meter type to be specified.\nThe associated value must be one of\n.IR bar ,\n.IR text ,\n.IR graph ,\nor\n.IR led .\nIf no value is provided for a dynamic meter, the default value of\n.IR text\nwill be used.\n.TP\n.B maximum\nA numeric value can also be set to size the meter, such that\nvalues (e.g. for a\n.I bar\ntype meter display) will be scaled within range zero to\n.IR maximum .\n.LP\nThe remaining definition syntax describes the individual\nmetric(s) which will be used to animate the meter.\nOne or more metrics must be specified for each meter and\nthere are several properties associated with each.\nOnce again, these metrics must be named (the same rules\ndescribed above for meters apply here) and the following\nproperties can be configured:\n.TP 5\n.B name.metric\nThis is the only mandatory field and associates a PCP metric\nwith the meter.\nValues sampled for each metric at runtime provide the\nanimation visible in the\n.B pcp-htop\ndisplay.\nThe metric specification can be either a PCP metric name as\nlisted by\n.BR pminfo (1)\nor a \"derived\" metric expression.\nThe format for derived metric expressions is described on the\n.BR pmRegisterDerived (3)\nmanual page.\n.TP\n.B name.color\nSetting color to be used when rendering metric values.\nPossible values are\n.IR red ,\n.IR green ,\n.IR blue ,\n.IR cyan ,\n.IR magenta ,\n.IR yellow ,\n.IR gray ,\n.I darkgray\nor\n.IR white .\n.TP\n.B name.label\nAn optional, short label to display before the metric value.\nThe \":\" character will be appended to the\n.I label\nbefore the metric value part of the display.\n.TP\n.B name.suffix\nAn optional, short suffix to display after the metric value.\nCommonly used to indicate values as a percentage using a \"%\"\n.I suffix\nvalue and to provide the base unit of measurement.\nNote that since PCP maintains units for metrics, for those\nmetrics that have dimension in \"space\" (bytes, kilobytes,\nmegabytes, etc), a suffix will be automatically appended.\n.SH \"COLUMNS\"\nThe following is an example configuration for a new column\nshowing open file descriptors for each process:\n.LP\n.ft CW\n.nf\n.in +0.5i\n[openfds]\nheading = FDS\ncaption = FDCOUNT\ndescription = Open file descriptors\nmetric = proc.fd.count\nwidth = 3\n.in\n.fi\n.ft 1\n.LP\nA configuration file can contain multiple column definitions.\nEach definition begins with a identifying name enclosed\nby square brackets \\-\n.I openfds\nin this example, and the same rules apply as described above\nfor meter names.\n.LP\nEach column must specify a metric.\nOptional parameters can also be set.\n.TP 5\n.B metric\nAs with meters, the metric value must be either a PCP metric\nname as listed by\n.BR pminfo (1)\nor a derived metric.\nThe metric must have an instance domain (set of values) and\nthat instance domain must map to the set of processes with\nthe instance identifier being PIDs (process identifiers).\nTypically this will be metrics from the\n.I proc\nor\n.I hotproc\nnamespace (\\c\n.BR pmdaproc (1)),\nbut metrics from other domains (\\c\n.BR pmdabcc (1),\n.BR pmdabpf (1),\netc) that have per-process values are equally applicable.\n.TP\n.B width\nColumn width to use when displaying values for the metric.\nA negative value can be used to specify left alignment.\nAn upper column limit of 28 characters is enforced.\nThe default column width is 5 characters.\n.TP\n.B heading\nThe short title that will be displayed at the head of the\ncolumn \\- usually a short, cryptic, all uppercase string.\n.TP\n.B caption\nA short identifying word presented to users on the Setup\nscreen under both the Available and Active Columns lists.\n.TP\n.B description\nText that assists users to understand the meaning of this\ncolumn when it is being presented via the Setup screen in\nthe Available Columns list.\n.SH \"SEE ALSO\"\n.BR pcp-htop (1),\n.BR pminfo (1),\n.BR pmcd (1),\n.BR pmdaproc (1),\n.BR pmdabcc (1),\n.BR pmdabpf (1)\nand\n.BR pmRegisterDerived (3).\n.SH \"AUTHORS\"\n.B htop\nwas originally developed by Hisham Muhammad.\nNowadays it is maintained by the community at <htop@groups.io>.\n.LP\n.B pcp-htop\nis maintained as a collaboration between the <htop@groups.io> and <pcp@groups.io>\ncommunities, and forms part of the Performance Co-Pilot suite of tools.\n"
        },
        {
          "name": "pcp-htop.c",
          "type": "blob",
          "size": 0.5439453125,
          "content": "/*\nhtop - pcp-htop.c\n(C) 2004-2011 Hisham H. Muhammad\n(C) 2020-2021 htop dev team\nReleased under the GNU GPLv2+, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\" // IWYU pragma: keep\n\n#include <pcp/pmapi.h>\n\n#include \"CommandLine.h\"\n#include \"Platform.h\"\n\n\nconst char* program = \"pcp-htop\";\n\nint main(int argc, char** argv) {\n   pmSetProgname(program);\n\n   /* extract environment variables */\n   opts.flags |= PM_OPTFLAG_ENV_ONLY;\n   (void)pmGetOptions(argc, argv, &opts);\n\n   return CommandLine_run(argc, argv);\n}\n"
        },
        {
          "name": "pcp",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "solaris",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_spec.lua",
          "type": "blob",
          "size": 17.44140625,
          "content": "#!/usr/bin/env lua\n\nlocal VISUALDELAY = os.getenv(\"VISUALDELAY\")\n\nlocal visual = VISUALDELAY or false\nlocal visual_delay = VISUALDELAY and (tonumber(VISUALDELAY)) or 0.1\nlocal short_delay = 0.3\nlocal long_delay = 1\n\nlocal unistd = require(\"posix.unistd\")\nlocal time = require(\"posix.time\")\nlocal curses = require(\"posix.curses\")\nlocal rote = require(\"rote\")\n\nlocal rt = rote.RoteTerm(24, 80)\n\n--[[\nlocal function os_execread(cmd)\n   local fd = io.popen(cmd, \"r\")\n   local out = fd:read(\"*a\")\n   fd:close()\n   return (out:gsub(\"\\n$\", \"\"))\nend\n]]\n--local branch = os_execread(\"git branch | grep '*'\"):sub(3)\n--print(\"Running in branch \"..branch)\n\nos.execute(\"make coverage\")\nos.execute(\"rm -f *.gcda */*.gcda\")\nos.execute(\"rm -f coverage.info test.htoprc\")\nos.execute(\"rm -rf lcov\")\nos.execute(\"killall htop\")\nos.execute(\"ps aux | grep '[s]leep 12345' | awk '{print $2}' | xargs kill 2> /dev/null\")\n\nos.execute(\"cp ./default.htoprc ./test.htoprc\")\nrt:forkPty(\"LC_ALL=C HTOPRC=./test.htoprc ./htop 2> htop-valgrind.txt\")\n\nlocal stdscr, term_win\n-- Curses initialization needed even when not in visual mode\n-- because luaposix only initializes KEY_* constants after initscr().\nstdscr = curses.initscr()\nif visual then\n   curses.echo(false)\n   curses.start_color()\n   curses.raw(true)\n   curses.halfdelay(1)\n   stdscr:keypad(true)\n   term_win = curses.newwin(24, 80, 0, 0)\n   local function makePair(foreground, background)\n      return background * 8 + 7 - foreground\n   end\n   -- initialize the color pairs the way rt:draw() expects it\n   for foreground = 0, 7 do\n      for background = 0, 7 do\n         if foreground ~= 7 or background ~= 0 then\n            local pair = makePair(foreground, background)\n            curses.init_pair(pair, foreground, background)\n         end\n      end\n   end\nelse\n   curses.endwin()\nend\n\nlocal function show(key)\n   rt:update()\n   if visual then\n      rt:draw(term_win, 0, 0)\n      if key then\n         term_win:mvaddstr(0, 0, tostring(key))\n      end\n      term_win:refresh()\n\n      delay(visual_delay)\n   end\nend\n\nlocal function send(key, times, quick)\n   if times == 0 then return end\n   for _ = 1, times or 1 do\n      delay(0.003) -- 30ms delay to avoid clobbering Esc sequences\n      if type(key) == \"string\" then\n         for c in key:gmatch('.') do\n            rt:keyPress(string.byte(c))\n         end\n      else\n         rt:keyPress(key)\n      end\n      if not quick then\n         show(key)\n      end\n   end\n   if quick then\n      show(key)\n   end\nend\n\nlocal function string_at(x, y, len)\n   rt:update()\n   local out = {}\n   for i = 1, len do\n      out[#out+1] = rt:cellChar(y-1, x+i-2)\n   end\n   return table.concat(out)\nend\n\nlocal function is_string_at(x, y, str)\n   return string_at(x, y, #str) == str\nend\n\nlocal function check_string_at(x, y, str)\n   return { str, string_at(x, y, #str) }\nend\n\nlocal ESC = \"\\27\\27\"\n\nfunction delay(t)\n   time.nanosleep({ tv_sec = math.floor(t), tv_nsec = (t - math.floor(t)) * 1000000000 })\nend\n\ndelay(2) -- give some time for htop to initialize.\nrt:update()\n\nlocal y_panelhdr = (function()\n   for y = 1, 24 do\n      if is_string_at(3, y, \"PID\") then\n         return y\n      end\n   end\nend)() or 1\n\nassert.not_equal(y_panelhdr, 1)\n\nlocal x_metercol2 = 41\n\nshow()\n\nos.execute(\"sleep 12345 &\")\n\nlocal function terminated()\n   return not os.execute(\"ps aux | grep -q '\\\\./[h]top'\")\nend\n\nlocal function running_it(desc, fn)\n   it(desc, function()\n      assert(not terminated())\n      show()\n      fn()\n      assert(not terminated())\n   end)\nend\n\nlocal function check(t)\n   return t[1], t[2]\nend\n\nlocal attrs = {\n   black_on_cyan = 6,\n   red_on_cyan = 22,\n   white_on_black = 176,\n   yellow_on_black = 112,\n}\n\nlocal function find_selected_y(from)\n   rt:update()\n   for y = from or (y_panelhdr + 1), rt:rows() - 1 do\n      local attr = rt:cellAttr(y-1, 1)\n      if attr == attrs.black_on_cyan then\n         return y\n      end\n   end\n   return y_panelhdr + 1\nend\n\nlocal function find_command_x()\n   for x = 1, 80 do\n      if is_string_at(x, y_panelhdr, \"Command\") then\n         return x\n      end\n   end\n   return 64\nend\n\nlocal function set_display_option(n)\n   send(\"S\")\n   send(curses.KEY_DOWN)\n   send(curses.KEY_RIGHT)\n   send(curses.KEY_DOWN, n, \"quick\")\n   send(\"\\n\")\n   send(curses.KEY_F10)\nend\n\ndescribe(\"htop test suite\", function()\n\n   running_it(\"performs incremental filter\", function()\n      send(\"\\\\\")\n      send(\"x\\127bux\\127sted\") -- test backspace\n      send(\"\\n\")\n      delay(short_delay)\n      rt:update()\n      local pid = (\"      \"..tostring(unistd.getpid())):sub(-5)\n      local ourpid = check_string_at(1, y_panelhdr + 1, pid)\n      send(\"\\\\\")\n      send(ESC)\n      send(curses.KEY_F5)\n      send(curses.KEY_HOME)\n      delay(short_delay)\n      rt:update()\n      local initpid = check_string_at(1, y_panelhdr + 1, \"    1\")\n      delay(short_delay)\n      rt:update()\n      send(curses.KEY_F5)\n      assert.equal(check(ourpid))\n      assert.equal(check(initpid))\n   end)\n\n   running_it(\"performs incremental search\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"busted\")\n      local attr = rt:cellAttr(rt:rows() - 1, 30)\n      delay(short_delay)\n      local line = find_selected_y()\n      local pid = (\"      \"..tostring(unistd.getpid())):sub(-5)\n      assert.equal(attr, attrs.black_on_cyan)\n      local ourpid = check_string_at(1, line, pid)\n      send(\"\\n\")\n      send(curses.KEY_HOME)\n      assert.equal(check(ourpid))\n   end)\n\n   running_it(\"performs pid search\", function()\n      send(curses.KEY_F5)\n      send(curses.KEY_END)\n      send(\"1\")\n      delay(short_delay)\n      local line = find_selected_y()\n      local initpid = check_string_at(1, line, \"    1\")\n      send(curses.KEY_F5)\n      assert.equal(check(initpid))\n   end)\n\n\n   running_it(\"horizontal scroll\", function()\n      local h_scroll = 20\n      send(curses.KEY_F5)\n      delay(short_delay)\n      local str1 = string_at(1+h_scroll, y_panelhdr+1, 5)\n      send(curses.KEY_RIGHT)\n      delay(short_delay)\n      local str2 = string_at(1, y_panelhdr+1, 5)\n      send(curses.KEY_LEFT)\n      delay(short_delay)\n      local str3 = string_at(1+h_scroll, y_panelhdr+1, 5)\n      send(curses.KEY_LEFT)\n      delay(short_delay)\n      local str4 = string_at(1+h_scroll, y_panelhdr+1, 5)\n      send(curses.KEY_F5)\n      assert.equal(str1, str2)\n      assert.equal(str2, str3)\n      assert.equal(str3, str4)\n   end)\n\n   running_it(\"kills a process\", function()\n      send(curses.KEY_HOME)\n      send(\"\\\\\")\n      send(\"sleep 12345\")\n      local attr = rt:cellAttr(rt:rows() - 1, 30)\n      assert.equal(attr, attrs.black_on_cyan)\n      send(\"\\n\")\n      delay(short_delay)\n      rt:update()\n      local col = find_command_x()\n      local procname = check_string_at(col, y_panelhdr + 1, \"sleep 12345\")\n      send(\"k\")\n      send(\"\\n\")\n      send(\"\\\\\")\n      send(ESC)\n      delay(short_delay)\n      assert.equal(check(procname))\n      assert.not_equal((os.execute(\"ps aux | grep -q '[s]leep 12345'\")), true)\n   end)\n\n   running_it(\"runs strace\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"busted\")\n      send(\"\\n\")\n      send(\"s\")\n      delay(long_delay)\n      send(ESC)\n   end)\n\n   running_it(\"runs lsof\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"busted\")\n      send(\"\\n\")\n      send(\"l\")\n      delay(long_delay)\n      send(ESC)\n   end)\n\n   running_it(\"performs filtering in lsof\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"htop\")\n      send(\"\\n\")\n      send(\"l\")\n      send(curses.KEY_F4)\n      send(\"pipe\")\n      delay(long_delay)\n      local pipefd = check_string_at(1, 3, \"    3\")\n      send(ESC)\n      assert.equal(check(pipefd))\n   end)\n\n   running_it(\"performs search in lsof\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"htop\")\n      send(\"\\n\")\n      send(\"l\")\n      send(curses.KEY_F3)\n      send(\"pipe\")\n      delay(long_delay)\n      local line = find_selected_y(3)\n      local pipefd = check_string_at(1, line, \"    3\")\n      send(ESC)\n      assert.equal(check(pipefd))\n   end)\n\n\n   running_it(\"cycles through meter modes in the default meters\", function()\n      send(\"S\")\n      for _ = 1, 2 do\n         send(curses.KEY_RIGHT)\n         for _ = 1, 3 do\n            send(\"\\n\", 4)\n            send(curses.KEY_DOWN)\n         end\n      end\n      send(ESC)\n   end)\n\n   running_it(\"show process of a user\", function()\n      send(curses.KEY_F5)\n      send(\"u\")\n      send(curses.KEY_DOWN)\n      delay(short_delay)\n      rt:update()\n      local chosen = string_at(1, y_panelhdr + 2, 9)\n      send(\"\\n\")\n      send(curses.KEY_HOME)\n      delay(short_delay)\n      rt:update()\n      local shown = string_at(7, y_panelhdr + 1, 9)\n      send(\"u\")\n      send(\"\\n\")\n      send(curses.KEY_HOME)\n      delay(short_delay)\n      rt:update()\n      local inituser = string_at(7, y_panelhdr + 1, 9)\n      send(curses.KEY_F5)\n      assert.equal(shown, chosen)\n      assert.equal(inituser, \"root     \")\n   end)\n\n   running_it(\"performs failing search\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"xxxxxxxxxx\")\n      delay(short_delay)\n      rt:update()\n      local attr = rt:cellAttr(rt:rows() - 1, 30)\n      assert.equal(attr, attrs.red_on_cyan)\n      send(\"\\n\")\n   end)\n\n   running_it(\"cycles through search\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"sh\")\n      local lastpid\n      local pidpairs = {}\n      for _ = 1, 3 do\n         send(curses.KEY_F3)\n         local line = find_selected_y()\n         local pid = string_at(1, line, 5)\n         if lastpid then\n            pidpairs[#pidpairs + 1] = { lastpid, pid }\n            lastpid = pid\n         end\n      end\n      send(curses.KEY_HOME)\n      for _, pair in pairs(pidpairs) do\n         assert.not_equal(pair[1], pair[2])\n      end\n   end)\n\n   running_it(\"visits each setup screen\", function()\n      send(\"S\")\n      send(curses.KEY_DOWN, 3)\n      send(curses.KEY_F10)\n   end)\n\n   running_it(\"adds and removes PPID column\", function()\n      send(\"S\")\n      send(curses.KEY_DOWN, 3)\n      send(curses.KEY_RIGHT, 2)\n      send(curses.KEY_DOWN, 2)\n      send(\"\\n\")\n      send(curses.KEY_F10)\n      delay(short_delay)\n      local ppid = check_string_at(2, y_panelhdr, \"PPID\")\n      send(\"S\")\n      send(curses.KEY_DOWN, 3)\n      send(curses.KEY_RIGHT, 1)\n      send(curses.KEY_DC)\n      send(curses.KEY_F10)\n      delay(short_delay)\n      local not_ppid = check_string_at(2, y_panelhdr, \"PPID\")\n      assert.equal(check(ppid))\n      assert.not_equal(check(not_ppid))\n   end)\n\n   running_it(\"changes CPU affinity for a process\", function()\n      send(\"a\")\n      send(\" \\n\")\n      send(ESC)\n   end)\n\n   running_it(\"renices for a process\", function()\n      send(\"/\")\n      send(\"busted\")\n      send(\"\\n\")\n      local line = find_selected_y()\n      local before = check_string_at(22, line, \" 0\")\n      send(curses.KEY_F8)\n      delay(short_delay)\n      local after = check_string_at(22, line, \" 1\")\n      assert.equal(check(before))\n      assert.equal(check(after))\n   end)\n\n   running_it(\"tries to lower nice for a process\", function()\n      send(\"/\")\n      send(\"busted\")\n      send(\"\\n\")\n      local line = find_selected_y()\n      local before = string_at(22, line, 2)\n      send(curses.KEY_F7)\n      delay(short_delay)\n      local after = string_at(22, line, 2)\n      assert.equal(before, after) -- no permissions\n   end)\n\n   running_it(\"invert sort order\", function()\n      local cpu_col = 45\n      send(\"P\")\n      send(\"I\")\n      send(curses.KEY_HOME)\n      delay(short_delay)\n      local zerocpu = check_string_at(cpu_col, y_panelhdr + 1, \" 0.0\")\n      send(\"I\")\n      delay(short_delay)\n      local nonzerocpu = check_string_at(cpu_col, y_panelhdr + 1, \" 0.0\")\n      assert.equal(check(zerocpu))\n      assert.not_equal(check(nonzerocpu))\n   end)\n\n   running_it(\"changes IO priority for a process\", function()\n      send(\"/\")\n      send(\"htop\")\n      send(\"\\n\")\n      send(\"i\")\n      send(curses.KEY_END)\n      send(\"\\n\")\n      send(ESC)\n   end)\n\n   running_it(\"shows help\", function()\n      send(curses.KEY_F1)\n      send(\"\\n\")\n      set_display_option(9)\n      send(curses.KEY_F1)\n      send(\"\\n\")\n      set_display_option(9)\n   end)\n\n   running_it(\"moves meters around\", function()\n      send(\"S\")\n      send(curses.KEY_RIGHT)\n      send(curses.KEY_UP)\n      send(\"\\n\")\n      send(curses.KEY_DOWN)\n      send(curses.KEY_UP)\n      send(curses.KEY_RIGHT)\n      send(curses.KEY_RIGHT)\n      send(curses.KEY_LEFT)\n      send(curses.KEY_LEFT)\n      send(\"\\n\")\n      send(curses.KEY_F10)\n   end)\n\n   local meters = {\n      { name = \"clock\", down = 0, string = \"Time\" },\n      { name = \"load\", down = 2, string = \"Load\" },\n      { name = \"battery\", down = 7, string = \"Battery\" },\n      { name = \"hostname\", down = 8, string = \"Hostname\" },\n      { name = \"memory\", down = 3, string = \"Mem\" },\n      { name = \"CPU average\", down = 16, string = \"Avg\" },\n   }\n\n   running_it(\"checks various CPU meters\", function()\n      send(\"S\")\n      send(curses.KEY_RIGHT, 3)\n      send(curses.KEY_DOWN, 9, \"quick\")\n      for _ = 9, 14 do\n         send(\"\\n\")\n         send(\"\\n\")\n         send(curses.KEY_DC)\n         send(curses.KEY_RIGHT)\n         send(curses.KEY_DOWN)\n      end\n   end)\n\n   for _, item in ipairs(meters) do\n      running_it(\"adds and removes a \"..item.name..\" widget\", function()\n         send(\"S\")\n         send(curses.KEY_RIGHT, 3)\n         send(curses.KEY_DOWN, item.down)\n         send(\"\\n\")\n         send(curses.KEY_UP, 4)\n         send(\"\\n\")\n         send(curses.KEY_F4, 4) -- cycle through meter modes\n         delay(short_delay)\n         rt:update()\n         local with = check_string_at(x_metercol2, 2, item.string)\n         send(curses.KEY_DC)\n         delay(short_delay)\n         local without = check_string_at(x_metercol2, 2, item.string)\n         send(curses.KEY_F10)\n         assert.equal(check(with))\n         assert.not_equal(check(without))\n      end)\n   end\n\n   running_it(\"goes through themes\", function()\n      send(curses.KEY_F2)\n      send(curses.KEY_DOWN, 2)\n      send(curses.KEY_RIGHT)\n      for _ = 1, 6 do\n         send(\"\\n\")\n         send(curses.KEY_DOWN)\n      end\n      send(curses.KEY_UP, 6)\n      send(\"\\n\")\n      send(curses.KEY_F10)\n   end)\n\n   local display_options = {\n      { name = \"tree view\", down = 0 },\n      { name = \"shadow other user's process\", down = 1 },\n      { name = \"hide kernel threads\", down = 2 },\n      { name = \"hide userland threads\", down = 3 },\n      { name = \"display threads in different color\", down = 4 },\n      { name = \"show custom thread names\", down = 5 },\n      { name = \"highlight basename\", down = 6 },\n      { name = \"highlight large numbers\", down = 7 },\n      { name = \"leave margin around header\", down = 8 },\n      { name = \"use detailed CPU time\", down = 9 },\n      { name = \"count from zero\", down = 10 },\n      { name = \"update process names\", down = 11 },\n      { name = \"guest time in CPU%\", down = 12 },\n   }\n\n   for _, item in ipairs(display_options) do\n      running_it(\"checks display option to \"..item.name, function()\n         for _ = 1, 2 do\n            set_display_option(item.down)\n            delay(short_delay)\n         end\n      end)\n   end\n\n   running_it(\"shows detailed CPU with guest time\", function()\n      for _ = 1, 2 do\n         send(\"S\")\n         send(curses.KEY_DOWN)\n         send(curses.KEY_RIGHT)\n         send(curses.KEY_DOWN, 9)\n         send(\"\\n\")\n         send(curses.KEY_DOWN, 3)\n         send(\"\\n\")\n         send(curses.KEY_LEFT)\n         send(curses.KEY_UP)\n         send(curses.KEY_RIGHT)\n         send(curses.KEY_F4, 4) -- cycle through CPU meter modes\n         send(curses.KEY_F10)\n         delay(short_delay)\n      end\n   end)\n\n   running_it(\"expands and collapses tree\", function()\n      send(curses.KEY_F5) -- tree view\n      send(curses.KEY_HOME)\n      send(curses.KEY_DOWN) -- second process in the tree\n      send(\"-\")\n      send(\"+\")\n      send(curses.KEY_F5)\n   end)\n\n   running_it(\"sets sort key\", function()\n      send(\".\")\n      send(\"\\n\")\n   end)\n\n   running_it(\"tags all children\", function()\n      send(curses.KEY_F5) -- tree view\n      send(curses.KEY_HOME) -- ensure we're at init\n      send(\"c\")\n      local taggedattrs = {}\n      rt:update()\n      for y = y_panelhdr + 2, 23 do\n         table.insert(taggedattrs, rt:cellAttr(y-1, 4))\n      end\n      delay(short_delay)\n      send(\"U\")\n      local untaggedattrs = {}\n      rt:update()\n      for y = y_panelhdr + 2, 23 do\n         table.insert(untaggedattrs, rt:cellAttr(y-1, 4))\n      end\n      send(curses.KEY_F5)\n\n      for _, taggedattr in ipairs(taggedattrs) do\n         assert.equal(attrs.yellow_on_black, taggedattr)\n      end\n      for _, untaggedattr in ipairs(untaggedattrs) do\n         assert.equal(attrs.white_on_black, untaggedattr)\n      end\n   end)\n\n   for i = 1, 62 do\n      running_it(\"show column \"..i, function()\n         send(\"S\")\n         send(curses.KEY_END)\n         send(curses.KEY_RIGHT, 1)\n         if i > 1 then\n            send(curses.KEY_DC)\n         end\n         send(curses.KEY_RIGHT, 1)\n         local down = i\n         while down > 13 do\n            send(curses.KEY_NPAGE)\n            down = down - 13\n         end\n         send(curses.KEY_DOWN, down, \"quick\")\n         send(\"\\n\")\n         send(curses.KEY_F10)\n         if i == 62 then\n            send(\"S\")\n            send(curses.KEY_END)\n            send(curses.KEY_RIGHT, 1)\n            if i > 1 then\n               send(curses.KEY_DC)\n            end\n            send(curses.KEY_F10)\n         end\n      end)\n   end\n\n   it(\"finally quits\", function()\n      assert(not terminated())\n      send(\"q\")\n      while not terminated() do\n         unistd.sleep(1)\n         send(\"q\")\n      end\n      assert(terminated())\n      if visual then\n         curses.endwin()\n      end\n      os.execute(\"make lcov && xdg-open lcov/index.html\")\n   end)\nend)\n"
        },
        {
          "name": "unsupported",
          "type": "tree",
          "content": null
        },
        {
          "name": "zfs",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}