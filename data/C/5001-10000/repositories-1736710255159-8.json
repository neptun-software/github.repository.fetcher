{
  "metadata": {
    "timestamp": 1736710255159,
    "page": 8,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nicbarker/clay",
      "stars": 9750,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0751953125,
          "content": "cmake-build-debug/\ncmake-build-release/\n.DS_Store\n.idea/\nbuild/\nnode_modules/"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.080078125,
          "content": "cmake-build-debug/\ncmake-build-release/\n.DS_Store\n.idea/\nnode_modules/\n*.dSYM\n.vs/"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.5625,
          "content": "cmake_minimum_required(VERSION 3.27)\nproject(clay)\n\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n\nadd_subdirectory(\"examples/cpp-project-example\")\nadd_subdirectory(\"examples/raylib-multi-context\")\nadd_subdirectory(\"examples/raylib-sidebar-scrolling-container\")\n#  add_subdirectory(\"examples/cairo-pdf-rendering\") Some issue with github actions populating cairo, disable for now\nif(NOT MSVC)\n  add_subdirectory(\"examples/clay-official-website\")\nendif()\nadd_subdirectory(\"examples/introducing-clay-video-demo\")\nadd_subdirectory(\"examples/SDL2-video-demo\")\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 0.8701171875,
          "content": "zlib/libpng license\n\nCopyright (c) 2024 Nic Barker\n\nThis software is provided 'as-is', without any express or implied warranty.\nIn no event will the authors be held liable for any damages arising from the\nuse of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software in a\n    product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not\n    be misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 83.1845703125,
          "content": "# Clay\n**_Clay_** (short for **C Layout**) is a high performance 2D UI layout library.\n\n### Major Features\n- Microsecond layout performance\n- Flex-box like layout model for complex, responsive layouts including text wrapping, scrolling containers and aspect ratio scaling\n- Single ~2k LOC **clay.h** file with **zero** dependencies (including no standard library)\n- Wasm support: compile with clang to a 15kb uncompressed **.wasm** file for use in the browser\n- Static arena based memory use with no malloc / free, and low total memory overhead (e.g. ~3.5mb for 8192 layout elements).\n- React-like nested declarative syntax\n- Renderer agnostic: outputs a sorted list of rendering primitives that can be easily composited in any 3D engine, and even compiled to HTML (examples provided)\n\nTake a look at the [clay website](https://nicbarker.com/clay) for an example of clay compiled to wasm and running in the browser, or others in the [examples directory](https://github.com/nicbarker/clay/tree/main/examples).\n\nYou can also watch the [introduction video](https://youtu.be/DYWTw19_8r4) for an overview of the motivation behind Clay's development and a short demo of its usage.\n\n<img width=\"1394\" alt=\"A screenshot of a code IDE with lots of visual and textual elements\" src=\"https://github.com/user-attachments/assets/9986149a-ee0f-449a-a83e-64a392267e3d\">\n\n_An example GUI application built with clay_\n\n## Quick Start\n\n1. Download or clone clay.h and include it after defining `CLAY_IMPLEMENTATION` in one file.\n\n```C\n// Must be defined in one file, _before_ #include \"clay.h\"\n#define CLAY_IMPLEMENTATION\n#include \"clay.h\"\n```\n\n2. Ask clay for how much static memory it needs using [Clay_MinMemorySize()](#clay_minmemorysize), create an Arena for it to use with [Clay_CreateArenaWithCapacityAndMemory(size, void *memory)](#clay_createarenawithcapacityandmemory), and initialize it with [Clay_Initialize(arena, dimensions)](#clay_initialize).\n\n```C\n// Note: malloc is only used here as an example, any allocator that provides\n// a pointer to addressable memory of at least totalMemorySize will work\nuint64_t totalMemorySize = Clay_MinMemorySize();\nClay_Arena arena = Clay_CreateArenaWithCapacityAndMemory(totalMemorySize, malloc(totalMemorySize));\nClay_Initialize(arena, (Clay_Dimensions) { screenWidth, screenHeight });\n``` \n\n3. Provide a `MeasureText(text, config)` function pointer with [Clay_SetMeasureTextFunction(function)](#clay_setmeasuretextfunction) so that clay can measure and wrap text.\n\n```C\n// Example measure text function\nstatic inline Clay_Dimensions MeasureText(Clay_String *text, Clay_TextElementConfig *config) {\n    // Clay_TextElementConfig contains members such as fontId, fontSize, letterSpacing etc\n    // Note: Clay_String->chars is not guaranteed to be null terminated\n}\n\n// Tell clay how to measure text\nClay_SetMeasureTextFunction(MeasureText);\n```\n\n4. **Optional** - Call [Clay_SetLayoutDimensions(dimensions)](#clay_setlayoutdimensions) if the window size of your application has changed.\n\n```C\n// Update internal layout dimensions\nClay_SetLayoutDimensions((Clay_Dimensions) { screenWidth, screenHeight });\n```\n\n5. **Optional** - Call [Clay_SetPointerState(pointerPosition, isPointerDown)](#clay_setpointerstate) if you want to use mouse interactions.\n\n```C\n// Update internal pointer position for handling mouseover / click / touch events\nClay_SetPointerState((Clay_Vector2) { mousePositionX, mousePositionY }, isMouseDown);\n```\n\n6. **Optional** - Call [Clay_UpdateScrollContainers(enableDragScrolling, scrollDelta, deltaTime)](#clay_updatescrollcontainers) if you want to use clay's built in scrolling containers.\n\n```C\n// Update internal pointer position for handling mouseover / click / touch events\nClay_UpdateScrollContainers(true, (Clay_Vector2) { mouseWheelX, mouseWheelY }, deltaTime);\n```\n\n7. Call [Clay_BeginLayout()](#clay_beginlayout) and declare your layout using the provided macros.\n\n```C\nconst Clay_Color COLOR_LIGHT = (Clay_Color) {224, 215, 210, 255};\nconst Clay_Color COLOR_RED = (Clay_Color) {168, 66, 28, 255};\nconst Clay_Color COLOR_ORANGE = (Clay_Color) {225, 138, 50, 255};\n\n// Layout config is just a struct that can be declared statically, or inline\nClay_LayoutConfig sidebarItemLayout = (Clay_LayoutConfig) {\n    .sizing = { .width = CLAY_SIZING_GROW(0), .height = CLAY_SIZING_FIXED(50) },\n};\n\n// Re-useable components are just normal functions\nvoid SidebarItemComponent() {\n    CLAY(CLAY_LAYOUT(sidebarItemLayout), CLAY_RECTANGLE({ .color = COLOR_ORANGE })) {}\n}\n\n// An example function to begin the \"root\" of your layout tree\nClay_RenderCommandArray CreateLayout() {\n    Clay_BeginLayout();\n\n    // An example of laying out a UI with a fixed width sidebar and flexible width main content\n    CLAY(CLAY_ID(\"OuterContainer\"), CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_GROW(0)}, .padding = {16, 16}, .childGap = 16 }), CLAY_RECTANGLE({ .color = {250,250,255,255} })) {\n        CLAY(CLAY_ID(\"SideBar\"),\n            CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM, .sizing = { .width = CLAY_SIZING_FIXED(300), .height = CLAY_SIZING_GROW(0) }, .padding = {16, 16}, .childGap = 16 }),\n            CLAY_RECTANGLE({ .color = COLOR_LIGHT })\n        ) {\n            CLAY(CLAY_ID(\"ProfilePictureOuter\"), CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_GROW(0) }, .padding = {16, 16}, .childGap = 16, .childAlignment = { .y = CLAY_ALIGN_Y_CENTER }), CLAY_RECTANGLE({ .color = COLOR_RED })) {\n                CLAY(CLAY_ID(\"ProfilePicture\"), CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_FIXED(60), .height = CLAY_SIZING_FIXED(60) }}), CLAY_IMAGE({ .imageData = &profilePicture, .sourceDimensions = {60, 60} })) {}\n                CLAY_TEXT(CLAY_STRING(\"Clay - UI Library\"), CLAY_TEXT_CONFIG({ .fontSize = 24, .textColor = {255, 255, 255, 255} }));\n            }\n\n            // Standard C code like loops etc work inside components\n            for (int i = 0; i < 5; i++) {\n                SidebarItemComponent();\n            }\n        }\n\n        CLAY(CLAY_ID(\"MainContent\"), CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_GROW(0), .height = CLAY_SIZING_GROW(0) }}), CLAY_RECTANGLE({ .color = COLOR_LIGHT })) {}\n    }\n    // ...\n});\n```\n\n8. Call [Clay_EndLayout()](#clay_endlayout) and process the resulting [Clay_RenderCommandArray](#clay_rendercommandarray) in your choice of renderer.\n\n```C\nClay_RenderCommandArray renderCommands = Clay_EndLayout();\n\nfor (int i = 0; i < renderCommands.length; i++) {\n    Clay_RenderCommand *renderCommand = &renderCommands.internalArray[i];\n    \n    switch (renderCommand->commandType) {\n        case CLAY_RENDER_COMMAND_TYPE_RECTANGLE: {\n            DrawRectangle(\n                renderCommand->boundingBox,\n                renderCommand->config.rectangleElementConfig->color);\n        }\n        // ... Implement handling of other command types\n    }\n}\n```\n\nThe above example, rendered correctly will look something like the following:\n\n![Clay Example](https://github.com/user-attachments/assets/1928c6d4-ada9-4a4c-a3d1-44fe9b23b3bd)\n\nIn summary, the general order of steps is:\n\n1. [Clay_SetLayoutDimensions(dimensions)](#clay_setlayoutdimensions)\t\n2. [Clay_SetPointerState(pointerPosition, isPointerDown)](#clay_setpointerstate)\n3. [Clay_UpdateScrollContainers(enableDragScrolling, scrollDelta, deltaTime)](#clay_updatescrollcontainers)\n4. [Clay_BeginLayout()](#clay_beginlayout)\n5. Declare your layout with the provided [Element Macros](#element-macros)\n6. [Clay_EndLayout()](#clay_endlayout)\n7. Render the results using the outputted [Clay_RenderCommandArray](#clay_rendercommandarray)\n\nFor help starting out or to discuss clay, considering joining [the discord server.](https://discord.gg/b4FTWkxdvT)\n\n## Summary\n\n- [High Level Documentation](#high-level-documentation)\n  - [Building UI Hierarchies](#building-ui-hierarchies)\n  - [Configuring Layout and Styling UI Elements](#configuring-layout-and-styling-ui-elements)\n  - [Element IDs](#element-ids)\n  - [Mouse, Touch and Pointer Interactions](#mouse-touch-and-pointer-interactions)\n  - [Scrolling Elements](#scrolling-elements)\n  - [Floating Elements](#floating-elements-absolute-positioning)\n  - [Custom Elements](#laying-out-your-own-custom-elements)\n  - [Retained Mode Rendering](#retained-mode-rendering)\n  - [Visibility Culling](#visibility-culling)\n  - [Preprocessor Directives](#preprocessor-directives)\n  - [Bindings](#bindings-for-non-c)\n  - [Debug Tools](#debug-tools)\n- [API](#api)\n  - [Naming Conventions](#naming-conventions)\n  - [Public Functions](#public-functions)\n    - [Lifecycle](#lifecycle-for-public-functions)\n    - [Clay_MinMemorySize](#clay_minmemorysize)\n    - [Clay_CreateArenaWithCapacityAndMemory](#clay_createarenawithcapacityandmemory)\n    - [Clay_SetMeasureTextFunction](#clay_setmeasuretextfunction)\n    - [Clay_SetMaxElementCount](clay_setmaxelementcount)\n    - [Clay_SetMaxMeasureTextCacheWordCount](#clay_setmaxmeasuretextcachewordcount)\n    - [Clay_Initialize](#clay_initialize)\n    - [Clay_SetLayoutDimensions](#clay_setlayoutdimensions)\n    - [Clay_SetPointerState](#clay_setpointerstate)\n    - [Clay_UpdateScrollContainers](#clay_updatescrollcontainers)\n    - [Clay_BeginLayout](#clay_beginlayout)\n    - [Clay_EndLayout](#clay_endlayout)\n    - [Clay_Hovered](#clay_hovered)\n    - [Clay_OnHover](#clay_onhover)\n    - [Clay_PointerOver](#clay_pointerover)\n    - [Clay_GetScrollContainerData](#clay_getscrollcontainerdata)\n    - [Clay_GetElementId](#clay_getelementid)\n  - [Element Macros](#element-macros)\n    - [CLAY](#clay-1)\n    - [CLAY_ID](#clay_id)\n    - [CLAY_IDI](#clay_idi)\n    - [CLAY_LAYOUT](#clay_layout)\n    - [CLAY_RECTANGLE](#clay_rectangle)\n    - [CLAY_TEXT](#clay_text)\n    - [CLAY_IMAGE](#clay_image)\n    - [CLAY_SCROLL](#clay_scroll)\n    - [CLAY_BORDER](#clay_border)\n    - [CLAY_FLOATING](#clay_floating)\n    - [CLAY_CUSTOM_ELEMENT](#clay_custom_element)\n  - [Data Structures & Defs](data-structures--definitions)\n    - [Clay_String](#clay_string)\n    - [Clay_ElementId](#clay_elementid)\n    - [Clay_RenderCommandArray](#clay_rendercommandarray)\n    - [Clay_RenderCommand](#clay_rendercommand)\n    - [Clay_ScrollContainerData](#clay_scrollcontainerdata)\n    - [Clay_ErrorHandler](#clay_errorhandler)\n    - [Clay_ErrorData](#clay_errordata)\n\n## High Level Documentation\n\n### Building UI Hierarchies\nClay UIs are built using the C macro `CLAY()`. This macro creates a new empty element in the UI hierarchy, and supports modular customisation of layout, styling and functionality. The `CLAY()` macro can also be _nested_, similar to other declarative UI systems like HTML.\n\nChild elements are added by opening a block: `{}` after calling the `CLAY()` macro (exactly like you would with an `if` statement or `for` loop), and declaring child components inside the braces.\n```C\n// Parent element with 8px of padding\nCLAY(CLAY_LAYOUT({ .padding = 8 })) {\n    // Child element 1\n    CLAY_TEXT(CLAY_STRING(\"Hello World\"), CLAY_TEXT_CONFIG({ .fontSize = 16 }));\n    // Child element 2 with red background\n    CLAY(CLAY_RECTANGLE({ .color = COLOR_RED })) {\n        // etc\n    }\n}\n```\n\nHowever, unlike HTML and other declarative DSLs, these macros are just C. As a result, you can use arbitrary C code such as loops, functions and conditions inside your layout declaration code:\n```C\n// Re-usable \"components\" are just functions that declare more UI\nvoid ButtonComponent(Clay_String buttonText) {\n    // Red box button with 8px of padding\n    CLAY(CLAY_LAYOUT({ .padding = { 8, 8 }}), CLAY_RECTANGLE({ .color = COLOR_RED })) {\n        CLAY_TEXT(buttonText, textConfig);\n    }\n}\n\n// Parent element\nCLAY(CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM })) {\n    // Render a bunch of text elements\n    for (int i = 0; i < textArray.length; i++) {\n        CLAY_TEXT(textArray.elements[i], textConfig);\n    }\n    // Only render this element if we're on a mobile screen\n    if (isMobileScreen) {\n        CLAY(0) {\n            // etc\n        }\n    }\n    // Re-usable components\n    ButtonComponent(CLAY_STRING(\"Click me!\"));\n    ButtonComponent(CLAY_STRING(\"No, click me!\"));\n});\n```\n\n### Configuring Layout and Styling UI Elements\nThe layout of clay elements is configured with the `CLAY_LAYOUT()` macro. \n```C\nCLAY(CLAY_LAYOUT({ .padding = {.x = 8, .y = 8}, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {\n    // Children are 8px inset into parent, and laid out top to bottom\n}\n```\nThis macro isn't magic - all it's doing is wrapping the standard designated initializer syntax and adding the result to an internal array. e.g. `(Clay_LayoutConfig) { .padding = { .x = 8, .y = 8 } ...`.\n\nSee the [Clay_LayoutConfig](#clay_layout) API for the full list of options.\n\nA `Clay_LayoutConfig` struct can be defined in file scope or elsewhere, and reused.\n```C\n// Define a style in the global / file scope\nClay_LayoutConfig reusableStyle = (Clay_LayoutConfig) { .backgroundColor = {120, 120, 120, 255} };\n\nCLAY(CLAY_LAYOUT(reusableStyle)) {\n    // ...\n}\n```\n\n### Element IDs\n\nClay elements can optionally be tagged with a unique identifier using [CLAY_ID()](#clay_id).\n\n```C\n// Will always produce the same ID from the same input string\nCLAY(CLAY_ID(\"OuterContainer\"), style) {}\n```\n\nElement IDs have two main use cases. Firstly, tagging an element with an ID allows you to query information about the element later, such as its [mouseover state](#clay_pointerover) or dimensions.\n\nSecondly, IDs are visually useful when attempting to read and modify UI code, as well as when using the built-in [debug tools](#debug-tools).\n\nTo avoid having to construct dynamic strings at runtime to differentiate ids in loops, clay provides the [CLAY_IDI(string, index)](#clay_idi) macro to generate different ids from a single input string. Think of IDI as \"**ID** + **I**ndex\"\n```C\n// This is the equivalent of calling CLAY_ID(\"Item0\"), CLAY_ID(\"Item1\") etc\nfor (int index = 0; index < items.length; index++) {\n    CLAY(CLAY_IDI(\"Item\", index)) {}\n}\n```\n\nThis ID (or, if not provided, an auto generated ID) will be forwarded to the final `Clay_RenderCommandArray` for use in retained mode UIs. Using duplicate IDs may cause some functionality to misbehave (i.e. if you're trying to attach a floating container to a specific element with ID that is duplicated, it may not attach to the one you expect)\n\n### Mouse, Touch and Pointer Interactions\n\nClay provides several functions for handling mouse and pointer interactions.\n\nAll pointer interactions depend on the function `void Clay_SetPointerState(Clay_Vector2 position, bool isPointerDown)` being called after each mouse position update and before any other clay functions.\n\n**During UI declaration**\n\nThe function `bool Clay_Hovered()` can be called during element construction or in the body of an element, and returns `true` if the mouse / pointer is over the currently open element.\n\n```C\n// An orange button that turns blue when hovered\nCLAY(CLAY_RECTANGLE(.color = Clay_Hovered() ? COLOR_BLUE : COLOR_ORANGE)) {\n    bool buttonHovered = Clay_Hovered();\n    CLAY_TEXT(buttonHovered ? CLAY_STRING(\"Hovered\") : CLAY_STRING(\"Hover me!\"), headerTextConfig);\n}\n```\n\nThe function `void Clay_OnHover()` allows you to attach a function pointer to the currently open element, which will be called if the mouse / pointer is over the element.\n\n```C\nvoid HandleButtonInteraction(Clay_ElementId elementId, Clay_PointerData pointerInfo, intptr_t userData) {\n    ButtonData *buttonData = (ButtonData *)userData;\n    // Pointer state allows you to detect mouse down / hold / release\n    if (pointerInfo.state == CLAY_POINTER_DATA_PRESSED_THIS_FRAME) {\n        // Do some click handling\n        NavigateTo(buttonData->link);\n    }\n}\n\nButtonData linkButton = (ButtonData) { .link = \"https://github.com/nicbarker/clay\" };\n\n// HandleButtonInteraction will be called for each frame the mouse / pointer / touch is inside the button boundaries\nCLAY(CLAY_LAYOUT({ .padding = { 8, 8 }}), Clay_OnHover(HandleButtonInteraction, &linkButton)) {\n    CLAY_TEXT(CLAY_STRING(\"Button\"), &headerTextConfig);\n}\n```\n\n**Before / After UI declaration**\n\nIf you want to query mouse / pointer overlaps outside layout declarations, you can use the function `bool Clay_PointerOver(Clay_ElementId id)`, which takes an [element id](#element-ids) and returns a bool representing whether the current pointer position is within its bounding box. \n```C\n// Reminder: Clay_SetPointerState must be called before functions that rely on pointer position otherwise it will have no effect\nClay_Vector2 mousePosition = { x, y };\nClay_SetPointerState(mousePosition);\n// ...\n// If profile picture was clicked\nif (mouseButtonDown(0) && Clay_PointerOver(Clay_GetElementId(\"ProfilePicture\"))) {\n    // Handle profile picture clicked\n}\n```\n\nNote that the bounding box queried by `Clay_PointerOver` is from the last frame. This generally shouldn't make a difference except in the case of animations that move at high speed.\nIf this is an issue for you, performing layout twice per frame with the same data will give you the correct interaction the second time.\n\n### Scrolling Elements\n\nElements are configured as scrollable with the `CLAY_SCROLL` macro. To make scroll containers respond to mouse wheel and scroll events, two functions need to be called before `BeginLayout()`:\n```C\nClay_Vector2 mousePosition = { x, y };\n// Reminder: Clay_SetPointerState must be called before Clay_UpdateScrollContainers otherwise it will have no effect\nClay_SetPointerState(mousePosition);\n// Clay_UpdateScrollContainers needs to be called before Clay_BeginLayout for the position to avoid a 1 frame delay\nClay_UpdateScrollContainers(\n    true, // Enable drag scrolling\n    scrollDelta, // Clay_Vector2 scrollwheel / trackpad scroll x and y delta this frame\n    float deltaTime, // Time since last frame in seconds as a float e.g. 8ms is 0.008f\n);\n// ...\n```\n\nMore specific details can be found in the full [Scroll API](#clay_scroll).\n\n### Floating Elements (\"Absolute\" Positioning)\n\nAll standard elements in clay are laid out on top of, and _within_ their parent, positioned according to their parent's layout rules, and affect the positioning and sizing of siblings.\n\n**\"Floating\"** is configured with the `CLAY_FLOATING()` macro. Floating elements don't affect the parent they are defined in, or the position of their siblings.\nThey also have a **z-index**, and as a result can intersect and render over the top of other elements.\n\nA classic example use case for floating elements is tooltips and modals.\n\n```C\n// The two text elements will be laid out top to bottom, and the floating container\n// will be attached to \"Outer\"\nCLAY(CLAY_ID(\"Outer\"), CLAY_LAYOUT({ .layoutDirection = TOP_TO_BOTTOM })) {\n    CLAY_TEXT(CLAY_ID(\"Button\"), text, &headerTextConfig);\n    CLAY(CLAY_ID(\"Tooltip\"), CLAY_FLOATING()) {}\n    CLAY_TEXT(CLAY_ID(\"Button\"), text, &headerTextConfig);\n}\n```\n\nMore specific details can be found in the full [Floating API](#clay_floating).\n\n### Laying Out Your Own Custom Elements\n\nClay only supports a simple set of UI element primitives, such as rectangles, text and images. Clay provides a singular API for layout out custom elements:\n```C\n// Extend CLAY_CUSTOM_ELEMENT_CONFIG with your custom data\n#define CLAY_EXTEND_CONFIG_CUSTOM struct t_CustomElementData customData;\n// Extensions need to happen _before_ the clay include\n#include \"clay.h\"\n\nenum CustomElementType {\n    CUSTOM_ELEMENT_TYPE_MODEL,\n    CUSTOM_ELEMENT_TYPE_VIDEO\n};\n\n// A rough example of how you could handle laying out 3d models in your UI\ntypedef struct t_CustomElementData {\n    CustomElementType type;\n    union {\n        Model model;\n        Video video;\n        // ...\n    };\n} CustomElementData;\n\nModel myModel = Load3DModel(filePath);\nCustomElement modelElement = (CustomElement) { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel }\n// ...\nCLAY(0) {\n    // This config is type safe and contains the CustomElementData struct\n    CLAY(CLAY_CUSTOM_ELEMENT({ .customData = { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel } })) {}\n}\n\n// Later during your rendering\nswitch (renderCommand->commandType) {\n    // ...\n    case CLAY_RENDER_COMMAND_TYPE_CUSTOM: {\n        // Your extended struct is passed through\n        CustomElementData *customElement = renderCommand->config.customElementConfig->customData;\n        if (!customElement) continue;\n        switch (customElement->type) {\n            case CUSTOM_ELEMENT_TYPE_MODEL: {\n                // Render your 3d model here\n                break;\n            }\n            case CUSTOM_ELEMENT_TYPE_VIDEO: {\n                // Render your video here\n                break;\n            }\n            // ...\n        }\n        break;\n    }\n}\n```\n\nMore specific details can be found in the full [Custom Element API](#clay_custom_element).\n\n### Retained Mode Rendering\nClay was originally designed for [Immediate Mode](https://www.youtube.com/watch?v=Z1qyvQsjK5Y) rendering - where the entire UI is redrawn every frame. This may not be possible with your platform, renderer design or performance constraints.\n\nThere are some general techniques that can be used to integrate clay into a retained mode rendering system:\n\n- `Clay_RenderCommand` includes the `uint32_t id` that was used to declare the element. If unique ids are used, these can be mapped to persistent graphics objects across multiple frames / layouts.\n- Render commands are culled automatically to only currently visible elements, and `Clay_RenderCommand` is a small enough struct that you can simply compare the memory of two render commands with matching IDs to determine if the element is \"dirty\" and needs to be re-rendered or updated.\n\nFor a worked example, see the provided [HTML renderer](https://github.com/nicbarker/clay/blob/main/renderers/web/html/clay-html-renderer.html). This renderer converts clay layouts into persistent HTML documents with minimal changes per frame.  \n\n### Visibility Culling\nClay provides a built-in visibility-culling mechanism that is **enabled by default**. It will only output render commands for elements that are visible - that is, **at least one pixel of their bounding box is inside the viewport.**\n\nThis culling mechanism can be disabled via the use of the `#define CLAY_DISABLE_CULLING` directive. See [Preprocessor Directives](#preprocessor-directives) for more information.\n\n### Preprocessor Directives\nClay supports C preprocessor directives to modulate functionality at compile time. These can be set either in code using `#define CLAY_DISABLE_CULLING` or on the command line when compiling using the appropriate compiler specific arguments, e.g. `clang -DCLAY_DISABLE_CULLING main.c ...`\n\nThe supported directives are:\n\n- `CLAY_WASM` - Required when targeting Web Assembly.\n- `CLAY_DEBUG` - Used for debugging clay's internal implementation. Useful if you want to modify or debug clay, or learn how things work. It enables a number of debug features such as preserving source strings for hash IDs to make debugging easier.\n- `CLAY_EXTEND_CONFIG_RECTANGLE` - Provide additional struct members to `CLAY_RECTANGLE` that will be passed through with output render commands.\n- `CLAY_EXTEND_CONFIG_TEXT` - Provide additional struct members to `CLAY_TEXT_CONFIG` that will be passed through with output render commands.\n- `CLAY_EXTEND_CONFIG_IMAGE` - Provide additional struct members to `CLAY_IMAGE_CONFIG` that will be passed through with output render commands.\n- `CLAY_EXTEND_CONFIG_CUSTOM` - Provide additional struct members to `CLAY_CUSTOM_CONFIG` that will be passed through with output render commands.\n\n### Bindings for non C\n\nClay is usable out of the box as a `.h` include in both C99 and C++20 with designated initializer support.\nThere are also supported bindings for other languages, including:\n\n- [Odin Bindings](https://github.com/nicbarker/clay/tree/main/bindings/odin)\n- [Rust Bindings](https://github.com/clay-ui-rs/clay)\n\n### Debug Tools\n\nClay includes built-in UI debugging tools, similar to the \"inspector\" in browsers such as Chrome or Firefox. These tools are included in `clay.h`, and work by injecting additional render commands into the output [Clay_RenderCommandArray](#clay_rendercommandarray).\n\nAs long as the renderer that you're using works correctly, no additional setup or configuration is required to use the debug tools.\n\nTo enable the debug tools, use the function `Clay_SetDebugModeEnabled(bool enabled)`. This boolean is persistent and does not need to be set every frame.\n\nThe debug tooling by default will render as a panel to the right side of the screen, compressing your layout by its width. The default width is 400 and is currently configurable via the direct mutation of the internal variable `Clay__debugViewWidth`, however this is an internal API and is potentially subject to change.\n\n<img width=\"1506\" alt=\"Screenshot 2024-09-12 at 12 54 03 PM\" src=\"https://github.com/user-attachments/assets/2d122658-3305-4e27-88d6-44f08c0cb4e6\">\n\n_The official Clay website with debug tooling visible_\n\n### Running more than one Clay instance\n\nClay allows you to run more than one instance in a program. To do this, [Clay_Initialize](#clay_initialize) returns a [Clay_Context*](#clay_context) reference. You can activate a specific instance using [Clay_SetCurrentContext](#clay_setcurrentcontext). If [Clay_SetCurrentContext](#clay_setcurrentcontext) is not called, then Clay will default to using the context from the most recently called [Clay_Initialize](#clay_initialize).\n\n**⚠ Important: Do not render instances across different threads simultaneously, as Clay does not currently support proper multi-threading.**\n\n```c++\n// Define separate arenas for the instances.\nClay_Arena arena1, arena2;\n// ... allocate arenas\n\n// Initialize both instances, storing the context for each one.\nClay_Context* instance1 = Clay_Initialize(arena1, layoutDimensions, errorHandler);\nClay_Context* instance2 = Clay_Initialize(arena2, layoutDimensions, errorHandler);\n\n// In the program's render function, activate each instance before executing clay commands and macros.\nClay_SetCurrentContext(instance1);\nClay_BeginLayout();\n// ... declare layout for instance1\nClay_RenderCommandArray renderCommands1 = Clay_EndLayout();\nrender(renderCommands1);\n\n// Switch to the second instance\nClay_SetCurrentContext(instance2);\nClay_BeginLayout();\n// ... declare layout for instance2\nClay_RenderCommandArray renderCommands2 = Clay_EndLayout();\nrender(renderCommands2);\n```\n\n# API\n\n### Naming Conventions\n\n- \"**CAPITAL_LETTERS()**\" are used for macros.\n- \"**Clay__**\" (\"Clay\" followed by **double** underscore) is used for internal functions that are not intended for use and are subject to change.\n- \"**Clay_**\" (\"Clay\" followed by **single** underscore) is used for external functions that can be called by the user.\n\n## Public Functions\n\n### Lifecycle for public functions\n\n**At startup / initialization time, run once**\n`Clay_MinMemorySize` -> `Clay_CreateArenaWithCapacityAndMemory` -> `Clay_SetMeasureTextFunction` -> `Clay_Initialize`\n\n**Each Frame**\n`Clay_SetLayoutDimensions` -> `Clay_SetPointerState` -> `Clay_UpdateScrollContainers` -> `Clay_BeginLayout` -> `CLAY() etc...` -> `Clay_EndLayout`\n\n---\n\n### Clay_MinMemorySize\n\n`uint32_t Clay_MinMemorySize()`\n\nReturns the minimum amount of memory **in bytes** that clay needs to accomodate the current [CLAY_MAX_ELEMENT_COUNT](#preprocessor-directives).\n\n---\n\n### Clay_CreateArenaWithCapacityAndMemory\n\n`Clay_Arena Clay_CreateArenaWithCapacityAndMemory(uint32_t capacity, void *offset)`\n\nCreates a `Clay_Arena` struct with the given capacity and base memory pointer, which can be passed to [Clay_Initialize](#clay_initialize).\n\n---\n\n### Clay_SetMeasureTextFunction\n\n`void Clay_SetMeasureTextFunction(Clay_Dimensions (*measureTextFunction)(Clay_String *text, Clay_TextElementConfig *config))`\n\nTakes a pointer to a function that can be used to measure the `width, height` dimensions of a string. Used by clay during layout to determine [CLAY_TEXT](#clay_text) element sizing and wrapping.\n\n**Note 1: This string is not guaranteed to be null terminated.** Clay saves significant performance overhead by using slices when wrapping text instead of having to clone new null terminated strings. If your renderer does not support **ptr, length** style strings (e.g. Raylib), you will need to clone this to a new C string before rendering.\n\n**Note 2: It is essential that this function is as fast as possible.** For text heavy use-cases this function is called many times, and despite the fact that clay caches text measurements internally, it can easily become the dominant overall layout cost if the provided function is slow. **This is on the hot path!**\n\n---\n\n### Clay_SetMaxElementCount\n\n`void Clay_SetMaxElementCount(uint32_t maxElementCount)`\n\nSets the internal maximum element count that will be used in subsequent [Clay_Initialize()](#clay_initialize) and [Clay_MinMemorySize()](#clay_minmemorysize) calls, allowing clay to allocate larger UI hierarchies.\n\n**Note: You will need to reinitialize clay, after calling [Clay_MinMemorySize()](#clay_minmemorysize) to calculate updated memory requirements.**\n\n---\n\n### Clay_SetMaxMeasureTextCacheWordCount\n\n`void Clay_SetMaxMeasureTextCacheWordCount(uint32_t maxMeasureTextCacheWordCount)`\n\nSets the internal text measurement cache size that will be used in subsequent [Clay_Initialize()](#clay_initialize) and [Clay_MinMemorySize()](#clay_minmemorysize) calls, allowing clay to allocate more text. The value represents how many separate words can be stored in the text measurement cache.\n\n**Note: You will need to reinitialize clay, after calling [Clay_MinMemorySize()](#clay_minmemorysize) to calculate updated memory requirements.**\n\n---\n\n### Clay_Initialize\n\n`Clay_Context* Clay_Initialize(Clay_Arena arena, Clay_Dimensions layoutDimensions, Clay_ErrorHandler errorHandler)`\n\nInitializes the internal memory mapping, sets the internal dimensions for layout, and binds an error handler for clay to use when something goes wrong. Returns a [Clay_Context*](#clay_context) that can optionally be given to [Clay_SetCurrentContext](#clay_setcurrentcontext) to allow running multiple instances of clay in the same program, and sets it as the current context. See [Running more than one Clay instance](#running-more-than-one-clay-instance).\n\nReference: [Clay_Arena](#clay_createarenawithcapacityandmemory), [Clay_ErrorHandler](#clay_errorhandler), [Clay_SetCurrentContext](#clay_setcurrentcontext)\n\n### Clay_SetCurrentContext\n\n`void Clay_SetCurrentContext(Clay_Context* context)`\n\nSets the context that subsequent clay commands will operate on. You can get this reference from [Clay_Initialize](#clay_initialize) or [Clay_GetCurrentContext](#clay_getcurrentcontext). See [Running more than one Clay instance](#running-more-than-one-clay-instance).\n\n### Clay_GetCurrentContext\n\n`Clay_Context* Clay_GetCurrentContext()`\n\nReturns the context that clay commands are currently operating on, or null if no context has been set. See [Running more than one Clay instance](#running-more-than-one-clay-instance).\n\n---\n\n### Clay_SetLayoutDimensions\n\n`void Clay_SetLayoutDimensions(Clay_Dimensions dimensions)`\n\nSets the internal layout dimensions. Cheap enough to be called every frame with your screen dimensions to automatically respond to window resizing, etc.\n\n---\n\n### Clay_SetPointerState\n\n`void Clay_SetPointerState(Clay_Vector2 position, bool isPointerDown)`\n\nSets the internal pointer position and state (i.e. current mouse / touch position) and recalculates overlap info, which is used for mouseover / click calculation (via [Clay_PointerOver](#clay_pointerover) and updating scroll containers with [Clay_UpdateScrollContainers](#clay_updatescrollcontainers). **isPointerDown should represent the current state this frame, e.g. it should be `true` for the entire duration the left mouse button is held down.** Clay has internal handling for detecting click / touch start & end.\n\n---\n\n### Clay_UpdateScrollContainers\n\n`void Clay_UpdateScrollContainers(bool enableDragScrolling, Clay_Vector2 scrollDelta, float deltaTime)`\n\nThis function handles scrolling of containers. It responds to both `scrollDelta`, which represents mouse wheel or trackpad scrolling this frame, as well as \"touch scrolling\" on mobile devices, or \"drag scrolling\" with a mouse or similar device.\n\nTouch / drag scrolling only occurs if the `enableDragScrolling` parameter is `true`, **and** [Clay_SetPointerState](#clay_setpointerstate) has been called this frame. As a result, you can simply always call it with `false` as the first argument if you want to disable touch scrolling.\n\n`deltaTime` is the time **in seconds** since the last frame (e.g. 0.016 is **16 milliseconds**), and is used to normalize & smooth scrolling across different refresh rates.\n\n---\n\n### Clay_BeginLayout\n\n`void Clay_BeginLayout()`\n\nPrepares clay to calculate a new layout. Called each frame / layout **before** any of the [Element Macros](#element-macros).\n\n---\n\n### Clay_EndLayout\n\n`Clay_RenderCommandArray Clay_EndLayout()`\n\nEnds declaration of element macros and calculates the results of the current layout. Renders a [Clay_RenderCommandArray](#clay_rendercommandarray) containing the results of the layout calculation.\n\n---\n\n### Clay_Hovered\n\n`bool Clay_Hovered()`\n\nCalled **during** layout declaration, and returns `true` if the pointer position previously set with `Clay_SetPointerState` is inside the bounding box of the currently open element. Note: this is based on the element's position from the **last** frame.\n\n---\n\n### Clay_OnHover\n\n`void Clay_OnHover(void (*onHoverFunction)(Clay_ElementId elementId, Clay_PointerData pointerData, intptr_t userData), intptr_t userData)`\n\nCalled **during** layout declaration, this function allows you to attach a function pointer to the currently open element that will be called once per layout if the pointer position previously set with `Clay_SetPointerState` is inside the bounding box of the currently open element. See [Clay_PointerData](#clay_pointerdata) for more information on the `pointerData` argument.\n\n```C\nvoid HandleButtonInteraction(Clay_ElementId elementId, Clay_PointerData pointerData, intptr_t userData) {\n    ButtonData *buttonData = (ButtonData *)userData;\n    // Pointer state allows you to detect mouse down / hold / release\n    if (pointerData.state == CLAY_POINTER_DATA_PRESSED_THIS_FRAME) {\n        // Do some click handling\n        NavigateTo(buttonData->link);\n    }\n}\n\nButtonData linkButton = (ButtonData) { .link = \"https://github.com/nicbarker/clay\" };\n\n// HandleButtonInteraction will be called for each frame the mouse / pointer / touch is inside the button boundaries\nCLAY(CLAY_LAYOUT({ .padding = { 8, 8 }}), Clay_OnHover(HandleButtonInteraction, &buttonData)) {\n    CLAY_TEXT(CLAY_STRING(\"Button\"), &headerTextConfig);\n}\n```\n\n---\n\n### Clay_PointerOver\n\n`bool Clay_PointerOver(Clay_ElementId id)`\n\nReturns `true` if the pointer position previously set with `Clay_SetPointerState` is inside the bounding box of the layout element with the provided `id`. Note: this is based on the element's position from the **last** frame. If frame-accurate pointer overlap detection is required, perhaps in the case of significant change in UI layout between frames, you can simply run your layout code twice that frame. The second call to `Clay_PointerOver` will be frame-accurate.\n\n### Clay_GetScrollContainerData\n\n`Clay_ScrollContainerData Clay_GetScrollContainerData(Clay_ElementId id)`\n\nReturns [Clay_ScrollContainerData](#clay_scrollcontainerdata) for the scroll container matching the provided ID. This function allows imperative manipulation of scroll position, allowing you to build things such as scroll bars, buttons that \"jump\" to somewhere in a scroll container, etc.\n\n---\n\n### Clay_GetElementId\n\n`Clay_ElementId Clay_GetElementId(Clay_String idString)`\n\nReturns a [Clay_ElementId](#clay_elementid) for the provided id string, used for querying element info such as mouseover state, scroll container data, etc.\n\n## Element Macros\n\n### CLAY()\n**Usage**\n\n`CLAY(...configuration) { ...children }`\n\n**Lifecycle**\n\n`Clay_BeginLayout()` -> `CLAY()` -> `Clay_EndLayout()` \n\n**Notes**\n\n**CLAY** opens a generic empty container, that is configurable and supports nested children.\n**CLAY** requires at least 1 parameter, so if you want to create an element without any configuration, use `CLAY(0)`.\n\n**Examples**\n```C\n// Define an element with 16px of x and y padding\nCLAY(CLAY_ID(\"Outer\"), CLAY_LAYOUT({ .padding = {16, 16} })) {\n    // A nested child element\n    CLAY(CLAY_ID(\"SideBar\"), CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM, .childGap = 16 })) {\n        // Children laid out top to bottom with a 16 px gap between them\n    }\n    // A vertical scrolling container with a colored background\n    CLAY(\n        CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM, .childGap = 16 })\n        CLAY_RECTANGLE({ .color = { 200, 200, 100, 255 }, .cornerRadius = CLAY_CORNER_RADIUS(10) })\n        CLAY_SCROLL({ .vertical = true })\n    ) {\n        // child elements\n    }\n}\n```\n\n---\n\n### CLAY_ID\n\n**Usage**\n\n`CLAY(CLAY_ID(char* idString)) {}`\n\n**Lifecycle**\n\n`Clay_BeginLayout()` -> `CLAY(` -> `CLAY_ID()` -> `)` -> `Clay_EndLayout()` \n\n**Notes**\n\n**CLAY_ID()** is used to generate and attach a [Clay_ElementId](#clay_elementid) to a layout element during declaration.\n\nTo regenerate the same ID outside of layout declaration when using utility functions such as [Clay_PointerOver](#clay_pointerover), use the [Clay_GetElementId](#clay_getelementid) function.\n\n**Examples**\n\n```C\n// Tag a button with the Id \"Button\"\nCLAY(\n    CLAY_ID(\"Button\"),\n    CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM, .sizing = { .width = CLAY_SIZING_GROW(0) }, .padding = {16, 16}, .childGap = 16) })\n) {\n    // ...children\n}\n\n// Later on outside of layout code\nbool buttonIsHovered = Clay_IsPointerOver(Clay_GetElementId(\"Button\"));\nif (buttonIsHovered && leftMouseButtonPressed) {\n    // ... do some click handling\n}\n```\n\n---\n\n### CLAY_IDI()\n\n`Clay_ElementId CLAY_IDI(char *label, int index)`\n\nAn offset version of [CLAY_ID](#clay_id). Generates a [Clay_ElementId](#clay_elementid) string id from the provided `char *label`, combined with the `int index`. Used for generating ids for sequential elements (such as in a `for` loop) without having to construct dynamic strings at runtime.\n\n---\n\n### CLAY_LAYOUT\n\n**Usage**\n\n`CLAY(CLAY_LAYOUT(...layout config)) {}`\n\n**Lifecycle**\n\n`Clay_BeginLayout()` -> `CLAY(` -> `CLAY_LAYOUT()` -> `)` -> `Clay_EndLayout()` \n\n**Notes**\n\n**CLAY_LAYOUT()** is used for configuring _layout_ options (i.e. options that affect the final position and size of an element, its parents, siblings, and children)\n\n**Struct API (Pseudocode)**\n\n```C\n// CLAY_LAYOUT({ .member = value }) supports these options\nClay_LayoutConfig {\n    Clay_LayoutDirection layoutDirection = CLAY_LEFT_TO_RIGHT (default) | CLAY_TOP_TO_BOTTOM;\n    Clay_Padding padding {\n        float x; float y; \n    };\n    uint16_t childGap;\n    Clay_ChildAlignment childAlignment {\n        .x = CLAY_ALIGN_X_LEFT (default) | CLAY_ALIGN_X_CENTER | CLAY_ALIGN_X_RIGHT;\n        .y = CLAY_ALIGN_Y_TOP (default) | CLAY_ALIGN_Y_CENTER | CLAY_ALIGN_Y_BOTTOM;\n    };\n    Clay_Sizing sizing { // Recommended to use the provided macros here - see #sizing for more in depth explanation\n        .width = CLAY_SIZING_FIT(float min, float max) (default) | CLAY_SIZING_GROW(float min, float max) | CLAY_SIZING_FIXED(float width) | CLAY_SIZING_PERCENT(float percent)\n        .height = CLAY_SIZING_FIT(float min, float max) (default) | CLAY_SIZING_GROW(float min, float max) | CLAY_SIZING_FIXED(float height) | CLAY_SIZING_PERCENT(float percent)\n    }; // See CLAY_SIZING_GROW() etc for more details\n};\n```\nAs with all config macros, `CLAY_LAYOUT()` accepts designated initializer syntax and provides default values for any unspecified struct members. \n\n**Fields**\n\n**`.layoutDirection`** - `Clay_LayoutDirection`\n\n`CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM })`\n\nControls the axis / direction in which child elements are laid out. Available options are `CLAY_LEFT_TO_RIGHT` (default) and `CLAY_TOP_TO_BOTTOM`.\n\n_Did you know that \"left to right\" and \"top to bottom\" both have 13 letters?_\n\n<img width=\"580\" alt=\"Screenshot 2024-08-22 at 11 10 27 AM\" src=\"https://github.com/user-attachments/assets/7008aa47-8826-4338-9257-8bc83f7813ce\">\n\n---\n\n**`.padding`** - `Clay_Padding`\n\n`CLAY_LAYOUT({ .padding = { .x = 16, .y = 16 } })`\n\nControls horizontal and vertical white-space \"padding\" around the **outside** of child elements.\n\n<img width=\"486\" alt=\"Screenshot 2024-08-22 at 10 50 49 AM\" src=\"https://github.com/user-attachments/assets/9311cf10-b8aa-40fe-922a-5dee3663f1a0\">\n\n---\n\n**`.childGap`** - `uint16_t`\n\n`CLAY_LAYOUT({ .childGap = 16 })`\n\nControls the white-space **between** child elements as they are laid out. When `.layoutDirection` is `CLAY_LEFT_TO_RIGHT` (default), this will be horizontal space, whereas for `CLAY_TOP_TO_BOTTOM` it will be vertical space.\n\n<img width=\"600\" alt=\"Screenshot 2024-08-22 at 11 05 15 AM\" src=\"https://github.com/user-attachments/assets/fa0dae1f-1936-47f6-a299-634bd7d40d58\">\n\n---\n\n**`.childAlignment`** - `Clay_ChildAlignment`\n\n`CLAY_LAYOUT({ .childAlignment = { .x = CLAY_ALIGN_X_LEFT, .y = CLAY_ALIGN_Y_CENTER } })`\n\nControls the alignment of children relative to the height and width of the parent container. Available options are:\n```C\n.x = CLAY_ALIGN_X_LEFT (default) | CLAY_ALIGN_X_CENTER | CLAY_ALIGN_X_RIGHT;\n.y = CLAY_ALIGN_Y_TOP (default) | CLAY_ALIGN_Y_CENTER | CLAY_ALIGN_Y_BOTTOM;\n```\n\n<img width=\"1030\" alt=\"Screenshot 2024-08-22 at 11 25 16 AM\" src=\"https://github.com/user-attachments/assets/be61b4a7-db4f-447c-b6d6-b2d4a91fc664\">\n\n---\n\n**`.sizing`** - `Clay_Sizing`\n\n`CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_FIXED(300), .height = CLAY_SIZING_PERCENT(0.5) } })`\n\nControls how final width and height of element are calculated. The same configurations are available for both the `.width` and `.height` axis. There are several options:\n\n- `CLAY_SIZING_FIT(float min, float max) (default)` - The element will be sized to fit its children (plus padding and gaps), up to `max`. If `max` is left unspecified, it will default to `FLOAT_MAX`. When elements are compressed to fit into a smaller parent, this element will not shrink below `min`.\n\n- `CLAY_SIZING_GROW(float min, float max)` - The element will grow to fill available space in its parent, up to `max`. If `max` is left unspecified, it will default to `FLOAT_MAX`. When elements are compressed to fit into a smaller parent, this element will not shrink below `min`.\n\n- `CLAY_SIZING_FIXED(float fixed)` - The final size will always be exactly the provided `fixed` value. Shorthand for `CLAY_SIZING_FIT(fixed, fixed)`\n\n- `CLAY_SIZING_PERCENT(float percent)` - Final size will be a percentage of parent size, minus padding and child gaps. `percent` is assumed to be a float between `0` and `1`.\n\n<img width=\"1056\" alt=\"Screenshot 2024-08-22 at 2 10 33 PM\" src=\"https://github.com/user-attachments/assets/1236efb1-77dc-44cd-a207-7944e0f5e500\">\n\n<img width=\"1141\" alt=\"Screenshot 2024-08-22 at 2 19 04 PM\" src=\"https://github.com/user-attachments/assets/a26074ff-f155-4d35-9ca4-9278a64aac00\">\n\n\n**Example Usage**\n\n```C\nCLAY(CLAY_ID(\"Button\"), CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM, .sizing = { .width = CLAY_SIZING_GROW(0) }, .padding = {16, 16}, .childGap = 16) }) {\n    // Children will be laid out vertically with 16px of padding around and between\n}\n``` \n\n---\n\n### CLAY_RECTANGLE\n**Usage**\n\n`CLAY(CLAY_RECTANGLE(...rectangle config)) {}`\n\n**Lifecycle**\n\n`Clay_BeginLayout()` -> `CLAY(` -> `CLAY_RECTANGLE()` -> `)` -> `Clay_EndLayout()` \n\n**Notes**\n\n**RECTANGLE** configures a clay element to background-fill its bounding box with a color. It uses `Clay_RectangleElementConfig` for rectangle specific options.\n\n**Struct API (Pseudocode)**\n\n```C\n// CLAY_RECTANGLE({ .member = value }) supports these options\nClay_RectangleElementConfig {\n    Clay_Color color {\n        float r; float g; float b; float a;\n    };\n    float cornerRadius;\n\n    #ifdef CLAY_EXTEND_CONFIG_RECTANGLE\n        // Contents of CLAY_EXTEND_CONFIG_RECTANGLE will be pasted here\n    #endif\n}\n```\n\nAs with all config macros, `CLAY_RECTANGLE()` accepts designated initializer syntax and provides default values for any unspecified struct members.\n\n**Extension**\n\nThe underlying `Clay_RectangleElementConfig` can be extended with new members by using:\n```C\n#define CLAY_EXTEND_CONFIG_RECTANGLE float newField;\n#include \"clay.h\" // Define your extension before including clay.h\n```\n\n**Fields**\n\n**`.color`** - `Clay_Color`\n\n`CLAY_RECTANGLE({ .color = {120, 120, 120, 255} })`\n\nConventionally accepts `rgba` float values between 0 and 255, but interpretation is left up to the renderer and does not affect layout.\n\n---\n\n**`.cornerRadius`** - `float`\n\n`CLAY_RECTANGLE({ .cornerRadius = { .topLeft = 16, .topRight = 16, .bottomLeft = 16, .bottomRight = 16 })`\n\nDefines the radius in pixels for the arc of rectangle corners (`0` is square, `rectangle.width / 2` is circular).\n\nNote that the `CLAY_CORNER_RADIUS(radius)` function-like macro is available to provide short hand for setting all four corner radii to the same value. e.g. `CLAY_BORDER({ .cornerRadius = CLAY_CORNER_RADIUS(10) })`\n\n**Rendering**\n\nElement is subject to [culling](#visibility-culling). Otherwise, a single `Clay_RenderCommand`s with `commandType = CLAY_RENDER_COMMAND_TYPE_RECTANGLE` will be created, with `renderCommand->elementConfig.rectangleElementConfig` containing a pointer to the element's Clay_RectangleElementConfig.\n\n**Examples**\n\n```C\n// Declare a reusable rectangle config, with a purple color and 10px rounded corners\nClay_RectangleElementConfig rectangleConfig = (Clay_RectangleElementConfig) { .color = { 200, 200, 100, 255 }, .cornerRadius = CLAY_CORNER_RADIUS(10) };\n// Declare a rectangle element using a reusable config\nCLAY(CLAY_RECTANGLE(rectangleConfig)) {}\n// Declare a retangle element using an inline config\nCLAY(CLAY_RECTANGLE({ .color = { 200, 200, 100, 255 }, .cornerRadius = CLAY_CORNER_RADIUS(10) })) {\n    // child elements\n}\n// Declare a scrolling container with a colored background\nCLAY(\n    CLAY_RECTANGLE({ .color = { 200, 200, 100, 255 }, .cornerRadius = CLAY_CORNER_RADIUS(10) })\n    CLAY_SCROLL({ .vertical = true })\n) {\n    // child elements\n}\n```\n\n---\n\n### CLAY_TEXT\n**Usage**\n\n`CLAY_TEXT(Clay_String textContents, Clay_TextElementConfig *textConfig);`\n\n**Lifecycle**\n\n`Clay_BeginLayout()` -> `CLAY_TEXT()` -> `Clay_EndLayout()` \n\n**Notes**\n\n**TEXT** is a measured, auto-wrapped text element. It uses `Clay_TextElementConfig` to configure text specific options.\n\nNote that `Clay_TextElementConfig` uses `uint32_t fontId`. Font ID to font asset mapping is managed in user code and passed to render commands.\n\n**Struct API (Pseudocode)**\n\n```C\n// CLAY_TEXT(text, CLAY_TEXT_CONFIG({ .member = value })) supports these options\nClay_TextElementConfig {\n    Clay_Color textColor {\n        float r; float g; float b; float a;\n    };\n    uint16_t fontId;\n    uint16_t fontSize;\n    uint16_t letterSpacing;\n    uint16_t lineHeight;\n    Clay_TextElementConfigWrapMode wrapMode {\n        CLAY_TEXT_WRAP_WORDS (default),\n\tCLAY_TEXT_WRAP_NEWLINES,\n\tCLAY_TEXT_WRAP_NONE,\n    };\n\n    #ifdef CLAY_EXTEND_CONFIG_TEXT\n        // Contents of CLAY_EXTEND_CONFIG_TEXT will be pasted here\n    #endif\n};\n```\nAs with all config macros, `CLAY_TEXT_CONFIG()` accepts designated initializer syntax and provides default values for any unspecified struct members. \n\n**Extension**\n\nThe underlying `Clay_TextElementConfig` can be extended with new members by using:\n```C\n#define CLAY_EXTEND_CONFIG_TEXT float newField;\n#include \"clay.h\" // Define your extension before including clay.h\n```\n\n**Fields**\n\n**`.textColor`**\n\n`CLAY_TEXT_CONFIG(.textColor = {120, 120, 120, 255})`\n\nConventionally accepts `rgba` float values between 0 and 255, but interpretation is left up to the renderer and does not affect layout.\n\n---\n\n**`.fontId`**\n\n`CLAY_TEXT_CONFIG(.fontId = FONT_ID_LATO)`\n                     \nIt's up to the user to load fonts and create a mapping from `fontId` to a font that can be measured and rendered.\n\n---\n\n**`.fontSize`**\n\n`CLAY_TEXT_CONFIG(.fontSize = 16)`\n\nFont size is generally thought of as `x pixels tall`, but interpretation is left up to the user & renderer.\n\n---\n\n**`.letterSpacing`**\n\n`CLAY_TEXT_CONFIG(.letterSpacing = 1)`\n\n`.letterSpacing` results in **horizontal** white space between individual rendered characters.\n\n---\n\n**`.lineHeight`**\n\n`CLAY_TEXT_CONFIG(.lineHeight = 20)`\n\n`.lineHeight` - when non zero - forcibly sets the `height` of each wrapped line of text to `.lineheight` pixels tall. Will affect the layout of both parents and siblings. A value of `0` will use the measured height of the font.\n\n---\n\n**`.wrapMode`**\n\n`CLAY_TEXT_CONFIG(.wrapMode = CLAY_TEXT_WRAP_NONE)`\n\n`.wrapMode` specifies under what conditions text should [wrap](https://en.wikipedia.org/wiki/Line_wrap_and_word_wrap).\n\nAvailable options are:\n\n- `CLAY_TEXT_WRAP_WORDS` (default) - Text will wrap on whitespace characters as container width shrinks, preserving whole words.\n- `CLAY_TEXT_WRAP_NEWLINES` -  will only wrap when encountering newline characters.\n- `CLAY_TEXT_WRAP_NONE` - Text will never wrap even if its container is compressed beyond the text measured width.\n\n---\n\n**Examples**\n\n```C\n// Define a font somewhere in your code\nconst uint32_t FONT_ID_LATO = 3;\n// ..\nCLAY_TEXT(CLAY_STRING(\"John Smith\"), CLAY_TEXT_CONFIG({ .fontId = FONT_ID_LATO, .fontSize = 24, .textColor = {255, 0, 0, 255} }));\n// Rendering example\nFont fontToUse = LoadedFonts[renderCommand->elementConfig.textElementConfig->fontId];\n```\n\n**Rendering**\n\nElement is subject to [culling](#visibility-culling). Otherwise, multiple `Clay_RenderCommand`s with `commandType = CLAY_RENDER_COMMAND_TYPE_TEXT` may be created, one for each wrapped line of text.\n\n`Clay_RenderCommand.textContent` will be populated with a `Clay_String` _slice_ of the original string passed in (i.e. wrapping doesn't reallocate, it just returns a `Clay_String` pointing to the start of the new line with a `length`)\n\n---\n\n### CLAY_IMAGE\n**Usage**\n\n`CLAY(CLAY_IMAGE(...image config)) {}`\n\n**Lifecycle**\n\n`Clay_BeginLayout()` -> `CLAY(` -> `CLAY_IMAGE()` -> `)` -> `Clay_EndLayout()` \n\n**Notes**\n\n**IMAGE** configures a clay element to render an image as its background. It uses Clay_ImageElementConfig for image specific options.\n\n**Struct API (Pseudocode)**\n\n```C\nClay_ImageElementConfig {\n    Clay_Dimensions sourceDimensions {\n        float width; float height; \n    };\n    // --\n    #ifndef CLAY_EXTEND_CONFIG_IMAGE\n        void * imageData; // Note: This field will be replaced if #define CLAY_EXTEND_CONFIG_IMAGE is specified\n    #else CLAY_EXTEND_CONFIG_IMAGE\n        // Contents of CLAY_EXTEND_CONFIG_IMAGE will be pasted here\n    #endif\n};\n```\n\nAs with all config macros, `CLAY_IMAGE_CONFIG()` accepts designated initializer syntax and provides default values for any unspecified struct members. \n\n**Extension**\n\nThe underlying `Clay_ImageElementConfig` can be extended with new members by using:\n```C\n#define CLAY_EXTEND_CONFIG_IMAGE float newField;\n#include \"clay.h\" // Define your extension before including clay.h\n```\n\n**Fields**\n\n**`.sourceDimensions`** - `Clay_Dimensions`\n\n`CLAY_IMAGE_CONFIG(.sourceDimensions = { 1024, 768 })`\n\nUsed to perform **aspect ratio scaling** on the image element. As of this version of clay, aspect ratio scaling only applies to the `height` of an image (i.e. image height will scale with width growth and limitations, but width will not scale with height growth and limitations)\n\n---\n\n**`.imageData`** - `void *`\n\n`CLAY_IMAGE_CONFIG(.imageData = &myImage)`\n\n`.imageData` is a generic void pointer that can be used to pass through image data to the renderer. **Note:** this field is generally not recommended for usage due to the lack of type safety, see `#define CLAY_EXTEND_CONFIG_IMAGE` in [Preprocessor Directives](#preprocessor-directives) for an alternative.\n\n```C\n// Load an image somewhere in your code\nImage profilePicture = LoadImage(\"profilePicture.png\");\n// Note that when rendering, .imageData will be void* type.\nCLAY(CLAY_IMAGE({ .imageData = &profilePicture, .sourceDimensions = { 60, 60 } })) {}\n\n// OR ----------------\n\n// Extend CLAY_CUSTOM_IMAGE_CONFIG with your custom image format\n#define CLAY_EXTEND_CONFIG_IMAGE struct t_Image image;\n// Extensions need to happen _before_ the clay include\n#include \"clay.h\"\n\ntypedef struct t_Image {\n    ImageFormat format;\n    u8int_t *internalData;\n    // ... etc\n} Image;\n\n// You can now use CLAY_IMAGE with your custom type and still have type safety & code completion\nCLAY(CLAY_IMAGE({ .image = { .format = IMAGE_FORMAT_RGBA, .internalData = &imageData }, .sourceDimensions = { 60, 60 } })) {}\n```\n\n**Examples**\n\n```C\n// Load an image somewhere in your code\nImage profilePicture = LoadImage(\"profilePicture.png\");\n// Declare a reusable image config\nClay_ImageElementConfig imageConfig = (Clay_ImageElementConfig) { .imageData = &profilePicture, .sourceDimensions = {60, 60} };\n// Declare an image element using a reusable config\nCLAY(CLAY_IMAGE(imageConfig)) {}\n// Declare an image element using an inline config\nCLAY(CLAY_IMAGE({ .imageData = &profilePicture, .sourceDimensions = {60, 60} })) {}\n// Rendering example\nImage *imageToRender = renderCommand->elementConfig.imageElementConfig->imageData;\n```\n\n**Rendering**\n\nElement is subject to [culling](#visibility-culling). Otherwise, a single `Clay_RenderCommand`s with `commandType = CLAY_RENDER_COMMAND_TYPE_IMAGE` will be created. The user will need to access `renderCommand->elementConfig.imageElementConfig->imageData` to retrieve image data referenced during layout creation. It's also up to the user to decide how / if they wish to blend `rectangleElementConfig->color` with the image.\n\n---\n\n### CLAY_SCROLL\n**Usage**\n\n`CLAY(CLAY_SCROLL(...scroll config)) {}`\n\n**Lifecycle**\n\n`Clay_SetPointerState()` -> `Clay_UpdateScrollContainers()` -> `Clay_BeginLayout()` -> `CLAY(` -> `CLAY_SCROLL()` -> `)` -> `Clay_EndLayout()` \n\n**Notes**\n\n**SCROLL** configures the element as a scrolling container, enabling masking of children that extend beyond its boundaries. It uses `Clay_ScrollElementConfig` to configure scroll specific options.\n\nNote: In order to process scrolling based on pointer position and mouse wheel or touch interactions, you must call `Clay_SetPointerState()` and `Clay_UpdateScrollContainers()` _before_ calling `BeginLayout`.\n\n**Struct Definition (Pseudocode)**\n\n```C\nClay_ScrollElementConfig {\n    bool horizontal;\n    bool vertical;\n};\n```\n\nAs with all config macros, `CLAY_SCROLL()` accepts designated initializer syntax and provides default values for any unspecified struct members. \n\n**Fields**\n\n**`.horizontal`** - `bool`\n\n`CLAY_SCROLL(.horizontal = true)`\n\nEnables or disables horizontal scrolling for this container element.\n\n---\n\n**`.vertical`** - `bool`\n\n`CLAY_SCROLL(.vertical = true)`\n\nEnables or disables vertical scrolling for this container element.\n\n---\n\n**Rendering**\n\nEnabling scroll for an element will result in two additional render commands: \n- `commandType = CLAY_RENDER_COMMAND_TYPE_SCISSOR_START`, which should create a rectangle mask with its `boundingBox` and is **not** subject to [culling](#visibility-culling)\n- `commandType = CLAY_RENDER_COMMAND_TYPE_SCISSOR_END`, which disables the previous rectangle mask and is **not** subject to [culling](#visibility-culling)\n\n**Examples**\n\n```C\nCLAY(CLAY_SCROLL(.vertical = true)) {\n    // Create child content with a fixed height of 5000\n    CLAY(CLAY_ID(\"ScrollInner\"), CLAY_LAYOUT({ .sizing = { .height = CLAY_SIZING_FIXED(5000) } })) {}\n}\n```\n\n---\n\n### CLAY_BORDER\n**Usage**\n\n`CLAY(CLAY_BORDER(...border config)) {}`\n\n**Lifecycle**\n\n`Clay_BeginLayout()` -> `CLAY(` -> `CLAY_BORDER()` -> `)` -> `Clay_EndLayout()` \n\n**Notes**\n\n**BORDER** adds borders to the edges or between the children of elements. It uses Clay_BorderElementConfig to configure border specific options.\n\n**Struct Definition (Pseudocode)**\n\n```C\ntypedef struct Clay_BorderElementConfig\n{\n    Clay_Border left {\n        float width;\n        Clay_Color color {\n            float r; float g; float b; float a;\n        };\n    };\n    Clay_Border right // Exactly the same as left\n    Clay_Border top // Exactly the same as left\n    Clay_Border bottom // Exactly the same as left\n    Clay_Border betweenChildren // Exactly the same as left\n    Clay_CornerRadius cornerRadius {\n        float topLeft;\n        float topRight;\n        float bottomLeft;\n        float bottomRight;\n    };\n} Clay_BorderElementConfig;\n```\n\n**Usage**\n\nAs with all config macros, `CLAY_BORDER()` accepts designated initializer syntax and provides default values for any unspecified struct members. \n\n**Fields**\n\n**`.left, .right, .top, .bottom`** - `Clay_Border`\n\n`CLAY_BORDER({ .left = { 2, COLOR_RED }, .right = { 4, COLOR_YELLOW } /* etc */ })`\n\nIndicates to the renderer that a border of `.color` should be draw at the specified edges of the bounding box, **overlapping the box contents by `.width`**.\n\nThis means that border configuration does not affect layout, as the width of the border doesn't contribute to the total container width or layout position. Border containers with zero padding will be drawn over the top of child elements.\n\n---\n\n**`.betweenChildren`** - `Clay_Border`\n\n`CLAY_BORDER({ .betweenChildren = { 2, COLOR_RED } })`\n\nConfigures the width and color of borders to be drawn between children. These borders will be vertical lines if the parent uses `.layoutDirection = CLAY_LEFT_TO_RIGHT` and horizontal lines if the parent uses `CLAY_TOP_TO_BOTTOM`. Unlike `.left, .top` etc, this option **will generate additional rectangle render commands representing the borders between children.** As a result, the renderer does not need to specifically implement rendering for these border elements.\n\n---\n\n**`.cornerRadius`** - `float`\n\n`CLAY_BORDER({ .cornerRadius = 16 })`\n\nDefines the radius in pixels for the arc of border corners (`0` is square, `rectangle.width / 2` is circular). It is up to the renderer to decide how to interpolate between differing border widths and colors across shared corners.\n\nNote that the `CLAY_CORNER_RADIUS(radius)` function-like macro is available to provide short hand for setting all four corner radii to the same value. e.g. `CLAY_BORDER(.cornerRadius = CLAY_CORNER_RADIUS(10))`\n\n**Convenience Macros**\n\nThere are some common cases for border configuration that are repetitive, i.e. specifying the same border around all four edges. Some convenience macros are provided for these cases:\n\n- `CLAY_BORDER_CONFIG_OUTSIDE({ .width = 2, .color = COLOR_RED })` - Shorthand for configuring all 4 outside borders at once.`\n- `CLAY_BORDER_CONFIG_OUTSIDE_RADIUS(width, color, radius)` - Shorthand for configuring all 4 outside borders at once, with the provided `.cornerRadius`. Note this is a function-like macro and does not take `.member = value` syntax.\n- `CLAY_BORDER_CONFIG_ALL({ .width = 2, .color = COLOR_RED })` - Shorthand for configuring all 4 outside borders and `.betweenChildren` at once. \n- `CLAY_BORDER_CONFIG_ALL_RADIUS(width, color, radius)` - Shorthand for configuring all 4 outside borders and `.betweenChildren` at once, with the provided `cornerRadius`. Note this is a function-like macro and does not take `.member = value` syntax.\n\n**Examples**\n\n```C\n// 300x300 container with a 1px red border around all the edges\nCLAY(\n    CLAY_ID(\"OuterBorder\"),\n    CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_FIXED(300), .height = CLAY_SIZING_FIXED(300)}),\n    CLAY_BORDER_CONFIG_OUTSIDE({ .color = COLOR_RED, .width = 1 })\n) {\n    // ...\n}\n\n// Container with a 3px yellow bottom border\nCLAY(\n    CLAY_ID(\"OuterBorder\"),\n    CLAY_BORDER({ .bottom = { .color = COLOR_YELLOW, .width = 3 } })\n) {\n    // ...\n}\n\n// Container with a 5px curved border around the edges, and a 5px blue border between all children laid out top to bottom\nCLAY(\n    CLAY_ID(\"OuterBorder\"),\n    CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM }),\n    CLAY_BORDER_CONFIG_ALL_RADIUS(5, COLOR_BLUE, 5)\n) {\n    // Child\n    // -- 5px blue border will be here --\n    // Child\n    // -- 5px blue border will be here --\n    // Child\n}\n```\n\n**Rendering**\n\nElement is subject to [culling](#visibility-culling). Otherwise, a single `Clay_RenderCommand` with `commandType = CLAY_RENDER_COMMAND_TYPE_BORDER` representing the container will be created.\nRendering of borders and rounded corners is left up to the user. See the provided [Raylib Renderer](https://github.com/nicbarker/clay/tree/main/renderers/raylib) for examples of how to draw borders using line and curve primitives.\n\n---\n\n### CLAY_FLOATING\n**Usage**\n\n`CLAY(CLAY_FLOATING(...floating config)) {}`\n\n**Lifecycle**\n\n`Clay_BeginLayout()` -> `CLAY(` -> `CLAY_FLOATING()` -> `)` -> `Clay_EndLayout()` \n\n**Notes**\n\n**FLOATING** defines an element that \"floats\" above other content. Typical use-cases include tooltips and modals.\n\nFloating containers:\n\n- With the default configuration, attach to the top left corner of their \"parent\" \n- Don't affect the width and height of their parent\n- Don't affect the positioning of sibling elements\n- Depending on their z-index can appear above or below other elements, partially or completely occluding them\n- Apart from positioning, function just like standard `CLAY` elements - including expanding to fit their children, etc.\n\nThe easiest mental model to use when thinking about floating containers is that they are a completely separate UI hierarchy, attached to a specific x,y point on their \"parent\".\n\nFloating elements uses `Clay_FloatingElementConfig` to configure specific options.\n\n**Struct Definition (Pseudocode)** \n\n```C\nClay_FloatingElementConfig {\n    Clay_Vector2 offset {\n        float x, float y\n    };\n    Clay_Dimensions expand {\n        float width, float height\n    };\n    uint16_t zIndex;\n    uint32_t parentId;\n    Clay_FloatingAttachPoints attachment {\n        .element = CLAY_ATTACH_POINT_LEFT_TOP (default) | CLAY_ATTACH_POINT_LEFT_CENTER | CLAY_ATTACH_POINT_LEFT_BOTTOM | CLAY_ATTACH_POINT_CENTER_TOP | CLAY_ATTACH_POINT_CENTER_CENTER | CLAY_ATTACH_POINT_CENTER_BOTTOM | CLAY_ATTACH_POINT_RIGHT_TOP | CLAY_ATTACH_POINT_RIGHT_CENTER | CLAY_ATTACH_POINT_RIGHT_BOTTOM\n        .parent = CLAY_ATTACH_POINT_LEFT_TOP (default) | CLAY_ATTACH_POINT_LEFT_CENTER | CLAY_ATTACH_POINT_LEFT_BOTTOM | CLAY_ATTACH_POINT_CENTER_TOP | CLAY_ATTACH_POINT_CENTER_CENTER | CLAY_ATTACH_POINT_CENTER_BOTTOM | CLAY_ATTACH_POINT_RIGHT_TOP | CLAY_ATTACH_POINT_RIGHT_CENTER | CLAY_ATTACH_POINT_RIGHT_BOTTOM\n    };\n    Clay_PointerCaptureMode captureMode {\n        CLAY_POINTER_CAPTURE_MODE_CAPTURE (default),\n        CLAY_POINTER_CAPTURE_MODE_PASSTHROUGH\n    };\n};\n```\n\nAs with all config macros, `CLAY_FLOATING()` accepts designated initializer syntax and provides default values for any unspecified struct members. \n\n**Fields**\n\n**`.offset`** - `Clay_Vector2`\n\n`CLAY_FLOATING({ .offset = { -24, -24 } })`\n\nUsed to apply a position offset to the floating container _after_ all other layout has been calculated. \n\n---\n\n**`.expand`** - `Clay_Dimensions`\n\n`CLAY_FLOATING({ .expand = { 16, 16 } })`\n\nUsed to expand the width and height of the floating container _before_ laying out child elements.\n\n---\n\n**`.zIndex`** - `float`\n\n`CLAY_FLOATING({ .zIndex = 1 })`\n\nAll floating elements (as well as their entire child hierarchies) will be sorted by `.zIndex` order before being converted to render commands. If render commands are drawn in order, elements with higher `.zIndex` values will be drawn on top.\n\n---\n\n**`.parentId`** - `uint32_t`\n\n`CLAY_FLOATING({ .parentId = Clay_GetElementId(\"HeaderButton\").id })`\n\nBy default, floating containers will \"attach\" to the parent element that they are declared inside. However, there are cases where this limitation could cause significant performance or ergonomics problems. `.parentId` allows you to specify a `CLAY_ID().id` to attach the floating container to. The parent element with the matching id can be declared anywhere in the hierarchy, it doesn't need to be declared before or after the floating container in particular.  \n\nConsider the following case:\n```C\n// Load an image somewhere in your code\nCLAY(CLAY_IDI(\"SidebarButton\", 1), &CLAY_LAYOUT_DEFAULT) {\n    // .. some button contents\n    if (tooltip.attachedButtonIndex == 1) {\n        CLAY_FLOATING(/* floating config... */)\n    }\n}\nCLAY(CLAY_IDI(\"SidebarButton\", 2), &CLAY_LAYOUT_DEFAULT) {\n    // .. some button contents\n    if (tooltip.attachedButtonIndex == 2) {\n        CLAY_FLOATING(/* floating config... */)\n    }\n}\nCLAY(CLAY_IDI(\"SidebarButton\", 3), &CLAY_LAYOUT_DEFAULT) {\n    // .. some button contents\n    if (tooltip.attachedButtonIndex == 3) {\n        CLAY_FLOATING(/* floating config... */)\n    }\n}\nCLAY(CLAY_IDI(\"SidebarButton\", 4), &CLAY_LAYOUT_DEFAULT) {\n    // .. some button contents\n    if (tooltip.attachedButtonIndex == 4) {\n        CLAY_FLOATING(/* floating config... */)\n    }\n}\nCLAY(CLAY_IDI(\"SidebarButton\", 5), &CLAY_LAYOUT_DEFAULT) {\n    // .. some button contents\n    if (tooltip.attachedButtonIndex == 5) {\n        CLAY_FLOATING(/* floating config... */)\n    }\n}\n```\n\nThe definition of the above UI is significantly polluted by the need to conditionally render floating tooltips as a child of many possible elements. The alternative, using `parentId`, looks like this:\n\n```C\n// Load an image somewhere in your code\nCLAY(CLAY_IDI(\"SidebarButton\", 1), &CLAY_LAYOUT_DEFAULT) {\n    // .. some button contents\n}\nCLAY(CLAY_IDI(\"SidebarButton\", 2), &CLAY_LAYOUT_DEFAULT) {\n    // .. some button contents\n}\nCLAY(CLAY_IDI(\"SidebarButton\", 3), &CLAY_LAYOUT_DEFAULT) {\n    // .. some button contents\n}\nCLAY(CLAY_IDI(\"SidebarButton\", 4), &CLAY_LAYOUT_DEFAULT) {\n    // .. some button contents\n}\nCLAY(CLAY_IDI(\"SidebarButton\", 5), &CLAY_LAYOUT_DEFAULT) {\n    // .. some button contents\n}\n\n// Any other point in the hierarchy\nCLAY_FLOATING(CLAY_ID(\"OptionTooltip\"), &CLAY_LAYOUT_DEFAULT, CLAY_FLOATING(.parentId = CLAY_IDI(\"SidebarButton\", tooltip.attachedButtonIndex).id)) {\n    // Tooltip contents...\n}\n```\n\n---\n\n**`.attachment`** - `Clay_FloatingAttachPoints`\n\n`CLAY_FLOATING(.attachment = { .element = CLAY_ATTACH_POINT_LEFT_CENTER, .parent = CLAY_ATTACH_POINT_RIGHT_TOP });`\n\nIn terms of positioning the floating container, `.attachment` specifies \n\n- The point on the floating container (`.element`)\n- The point on the parent element that it \"attaches\" to (`.parent`)\n\n![Screenshot 2024-08-23 at 11 47 21 AM](https://github.com/user-attachments/assets/b8c6dfaa-c1b1-41a4-be55-013473e4a6ce)\n\nYou can mentally visualise this as finding a point on the floating container, then finding a point on the parent, and lining them up over the top of one another.\n\nFor example:\n\n\"Attach the LEFT_CENTER of the floating container to the RIGHT_TOP of the parent\"\n\n`CLAY_FLOATING({ .attachment = { .element = CLAY_ATTACH_POINT_LEFT_CENTER, .parent = CLAY_ATTACH_POINT_RIGHT_TOP } });`\n\n![Screenshot 2024-08-23 at 11 53 24 AM](https://github.com/user-attachments/assets/ebe75e0d-1904-46b0-982d-418f929d1516)\n\n**`.pointerCaptureMode`** - `Clay_PointerCaptureMode`\n\n`CLAY_FLOATING({ .pointerCaptureMode = CLAY_POINTER_CAPTURE_MODE_CAPTURE })`\n\nControls whether pointer events like hover and click should pass through to content underneath this floating element, or whether the pointer should be \"captured\" by this floating element. Defaults to `CLAY_POINTER_CAPTURE_MODE_CAPTURE`. \n\n**Examples**\n\n```C\n// Horizontal container with three option buttons\nCLAY(CLAY_ID(\"OptionsList\"), CLAY_LAYOUT(.childGap = 16)) {\n    CLAY_RECTANGLE(CLAY_IDI(\"Option\", 1), CLAY_LAYOUT(.padding = {16, 16}), CLAY_RECTANGLE(.color = COLOR_BLUE)) {\n        CLAY_TEXT(CLAY_IDI(\"OptionText\", 1), CLAY_STRING(\"Option 1\"), CLAY_TEXT_CONFIG());\n    }\n    CLAY_RECTANGLE(CLAY_IDI(\"Option\", 2), CLAY_LAYOUT(.padding = {16, 16}), CLAY_RECTANGLE(.color = COLOR_BLUE)) {\n        CLAY_TEXT(CLAY_IDI(\"OptionText\", 2), CLAY_STRING(\"Option 2\"), CLAY_TEXT_CONFIG());\n        // Floating tooltip will attach above the \"Option 2\" container and not affect widths or positions of other elements\n        CLAY_FLOATING(CLAY_ID(\"OptionTooltip\"), &CLAY_LAYOUT_DEFAULT, CLAY_FLOATING({ .zIndex = 1, .attachment = { .element = CLAY_ATTACH_POINT_CENTER_BOTTOM, .parent = CLAY_ATTACH_POINT_CENTER_TOP } })) {\n            CLAY_TEXT(CLAY_IDI(\"OptionTooltipText\", 1), CLAY_STRING(\"Most popular!\"), CLAY_TEXT_CONFIG());\n        }\n    }\n    CLAY_RECTANGLE(CLAY_IDI(\"Option\", 3), CLAY_LAYOUT(.padding = {16, 16}), CLAY_RECTANGLE(.color = COLOR_BLUE)) {\n        CLAY_TEXT(CLAY_IDI(\"OptionText\", 3), CLAY_STRING(\"Option 3\"), CLAY_TEXT_CONFIG());\n    }\n}\n\n// Floating containers can also be declared elsewhere in a layout, to avoid branching or polluting other UI\nfor (int i = 0; i < 1000; i++) {\n    CLAY(CLAY_IDI(\"Option\", i + 1), &CLAY_LAYOUT_DEFAULT) {\n        // ...\n    }\n}\n// Note the use of \"parentId\".\n// Floating tooltip will attach above the \"Option 2\" container and not affect widths or positions of other elements\nCLAY_FLOATING(CLAY_ID(\"OptionTooltip\"), &CLAY_LAYOUT_DEFAULT, CLAY_FLOATING({ .parentId = CLAY_IDI(\"Option\", 2).id, .zIndex = 1, .attachment = { .element = CLAY_ATTACH_POINT_CENTER_BOTTOM, .parent = CLAY_ATTACH_POINT_TOP_CENTER } })) {\n    CLAY_TEXT(CLAY_IDI(\"OptionTooltipText\", 1), CLAY_STRING(\"Most popular!\"), CLAY_TEXT_CONFIG());\n}\n```\n\nWhen using `.parentId`, the floating container can be declared anywhere after `BeginLayout` and before `EndLayout`. The target element matching the `.parentId` doesn't need to exist when `CLAY_FLOATING` is called.\n\n**Rendering**\n\n`CLAY_FLOATING` elements will not generate any render commands.\n\n---\n\n### CLAY_CUSTOM_ELEMENT\n**Usage**\n\n`CLAY_CUSTOM_ELEMENT(Clay_ElementId id, Clay_LayoutConfig *layoutConfig, Clay_CustomElementConfig *customConfig);`\n\n**Lifecycle**\n\n`Clay_BeginLayout()` -> `CLAY_CUSTOM_ELEMENT()` -> `Clay_EndLayout()` \n\n**Notes**\n\n**CUSTOM_ELEMENT** allows the user to pass custom data to the renderer. \n\n**Struct Definition (Pseudocode)** \n\n```C\ntypedef struct\n{\n    #ifndef CLAY_EXTEND_CONFIG_CUSTOM\n        void * customData; // Note: This field will be replaced if #define CLAY_EXTEND_CONFIG_CUSTOM is specified\n    #else CLAY_EXTEND_CONFIG_CUSTOM\n        // Contents of CLAY_EXTEND_CONFIG_CUSTOM will be pasted here\n    #endif\n} Clay_CustomElementConfig;\n```\n\nAs with all config macros, `CLAY_CUSTOM_ELEMENT_CONFIG()` accepts designated initializer syntax and provides default values for any unspecified struct members. \n\n**Extension**\n\nThe underlying `Clay_ImageCustomConfig` can be extended with new members by using:\n```C\n#define CLAY_EXTEND_CONFIG_CUSTOM float newField;\n#include \"clay.h\" // Define your extension before including clay.h\n```\n\n**Fields**\n\n`.customData` - `void *`\n\n`CLAY_CUSTOM_CONFIG(.customData = &myCustomData)`\n\n`.customData` is a generic void pointer that can be used to pass through custom data to the renderer. **Note:** this field is generally not recommended for usage due to the lack of type safety, see `#define CLAY_EXTEND_CONFIG_CUSTOM` in [Preprocessor Directives]() for an alternative.\n\n**Examples**\n```C\n// Extend CLAY_CUSTOM_ELEMENT_CONFIG with your custom data\n#define CLAY_EXTEND_CONFIG_CUSTOM struct t_CustomElementData customData;\n// Extensions need to happen _before_ the clay include\n#include \"clay.h\"\n\nenum CustomElementType {\n    CUSTOM_ELEMENT_TYPE_MODEL,\n    CUSTOM_ELEMENT_TYPE_VIDEO\n};\n\n// A rough example of how you could handle laying out 3d models in your UI\ntypedef struct t_CustomElementData {\n    CustomElementType type;\n    union {\n        Model model;\n        Video video;\n        // ...\n    };\n} CustomElementData;\n\nModel myModel = Load3DModel(filePath);\nCustomElement modelElement = (CustomElement) { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel }\n// ...\nCLAY(id, style) {\n    // This config is type safe and contains the CustomElementData struct\n    CLAY_CUSTOM_ELEMENT(id, layout, CLAY_CUSTOM_ELEMENT_CONFIG(.customData = { .type = CUSTOM_ELEMENT_TYPE_MODEL, .model = myModel })) {}\n}\n\n// Later during your rendering\nswitch (renderCommand->commandType) {\n    // ...\n    case CLAY_RENDER_COMMAND_TYPE_CUSTOM: {\n        // Your extended struct is passed through\n        CustomElementData *data = renderCommand->elementConfig.customElementConfig->customData;\n        if (!customElement) continue;\n        switch (customElement->type) {\n            case CUSTOM_ELEMENT_TYPE_MODEL: {\n                // Render your 3d model here\n                break;\n            }\n            case CUSTOM_ELEMENT_TYPE_VIDEO: {\n                // Render your video here\n                break;\n            }\n            // ...\n        }\n        break;\n    }\n}\n```\n\n**Rendering**\n\nElement is subject to [culling](#visibility-culling). Otherwise, a single `Clay_RenderCommand` with `commandType = CLAY_RENDER_COMMAND_TYPE_CUSTOM` will be created.\n\n## Data Structures & Definitions\n\n### Clay_String\n\n```C\ntypedef struct {\n    int length;\n    const char *chars;\n} Clay_String;\n```\n\n`Clay_String` is a string container that clay uses internally to represent all strings.\n\n**Fields**\n\n**`.length`** - `int`\n\nThe number of characters in the string, _not including an optional null terminator._\n\n---\n\n**`.chars`** - `const char *`\n\nA pointer to the contents of the string. This data is not guaranteed to be null terminated, so if you are passing it to code that expects standard null terminated C strings, you will need to copy the data and append a null terminator.\n\n---\n\n### Clay_ElementId\n\n```C\ntypedef struct {\n    uint32_t id;\n    uint32_t offset;\n    uint32_t baseId;\n    Clay_String stringId;\n} Clay_ElementId;\n```\n\nReturned by [CLAY_ID](#clay_id) and [CLAY_IDI](#clay_idi), this struct contains a hash id, as well as the source string that was used to generate it.\n\n**Fields**\n\n**`.id`** - `uint32_t`\n\nA unique ID derived from the string passed to [CLAY_ID](#clay_id) or [CLAY_IDI](#clay_idi).\n\n---\n\n**`.offset`** - `uint32_t`\n\nIf this id was generated using [CLAY_IDI](#clay_idi), `.offset` is the value passed as the second argument. For [CLAY_ID](#clay_id), this will always be `0`.\n\n---\n\n**`.baseId`** - `uint32_t`\n\nIf this id was generated using [CLAY_IDI](#clay_idi), `.baseId` is the hash of the base string passed, **before it is additionally hashed with `.offset`**. For [CLAY_ID](#clay_id), this will always be the same as `.id`.\n\n---\n\n**`.stringId`** - `Clay_String`\n\nStores the original string that was passed in when [CLAY_ID](#clay_id) or [CLAY_IDI](#clay_idi) were called.\n\n---\n\n### Clay_RenderCommandArray\n\n```C\ntypedef struct\n{\n\tuint32_t capacity;\n\tuint32_t length;\n\tClay_RenderCommand *internalArray;\n} Clay_RenderCommandArray;\n```\n\nReturned by [Clay_EndLayout](#clay_endlayout), this array contains the [Clay_RenderCommand](#clay_rendercommand)s representing the calculated layout.\n\n**Fields**\n\n**`.capacity`** - `uint32_t`\n\nRepresents the total capacity of the allocated memory in `.internalArray`.\n\n---\n\n**`.length`** - `uint32_t`\n\nRepresents the total number of `Clay_RenderCommand` elements stored consecutively at the address `.internalArray`.\n\n\n---\n\n**`.internalArray`** - `Clay_RenderCommand`\n\nAn array of [Clay_RenderCommand](#clay_rendercommand)s representing the calculated layout. If there was at least one render command, this array will contain elements from `.internalArray[0]` to `.internalArray[.length - 1]`.\n\n---\n\n### Clay_RenderCommand\n\n```C\ntypedef struct\n{\n    Clay_BoundingBox boundingBox;\n    Clay_ElementConfigUnion config;\n    Clay_String text;\n    uint32_t id;\n    Clay_RenderCommandType commandType;\n} Clay_RenderCommand;\n```\n\n**Fields**\n\n**`.commandType`** - `Clay_RenderCommandType`\n\nAn enum indicating how this render command should be handled. Possible values include:\n\n- `CLAY_RENDER_COMMAND_TYPE_NONE` - Should be ignored by the renderer, and never emitted by clay under normal conditions.\n- `CLAY_RENDER_COMMAND_TYPE_RECTANGLE` - A rectangle should be drawn, configured with `.config.rectangleElementConfig`\n- `CLAY_RENDER_COMMAND_TYPE_BORDER` - A border should be drawn, configured with `.config.borderElementConfig`\n- `CLAY_RENDER_COMMAND_TYPE_TEXT` - Text should be drawn, configured with `.config.textElementConfig`\n- `CLAY_RENDER_COMMAND_TYPE_IMAGE` - An image should be drawn, configured with `.config.imageElementConfig`\n- `CLAY_RENDER_COMMAND_TYPE_SCISSOR_START` - Named after [glScissor](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glScissor.xhtml), this indicates that the renderer should begin culling any subsequent pixels that are drawn outside the `.boundingBox` of this render command.\n- `CLAY_RENDER_COMMAND_TYPE_SCISSOR_END` - Only ever appears after a matching `CLAY_RENDER_COMMAND_TYPE_SCISSOR_START` command, and indicates that the scissor has ended.\n- `CLAY_RENDER_COMMAND_TYPE_CUSTOM` - A custom render command controlled by the user, configured with `.config.customElementConfig`\n\n---\n\n**`.boundingBox`** - `Clay_BoundingBox`\n\n```C\ntypedef struct {\n    float x, y, width, height;\n} Clay_BoundingBox;\n```\n\nA rectangle representing the bounding box of this render command, with `.x` and `.y` representing the top left corner of the element.\n\n---\n\n**`.config`** - `Clay_ElementConfigUnion`\n\nA C union containing various pointers to config data, with the type dependent on `.commandType`. Possible values include:\n\n- `config.rectangleElementConfig` - Used when `.commandType == CLAY_RENDER_COMMAND_TYPE_RECTANGLE`. See [CLAY_RECTANGLE](#clay_rectangle) for details.\n- `config.textElementConfig` - Used when `.commandType == CLAY_RENDER_COMMAND_TYPE_TEXT`. See [CLAY_TEXT](#clay_text) for details.\n- `config.imageElementConfig` - Used when `.commandType == CLAY_RENDER_COMMAND_TYPE_IMAGE`. See [CLAY_IMAGE](#clay_image) for details.\n- `config.borderElementConfig` - Used when `.commandType == CLAY_RENDER_COMMAND_TYPE_BORDER`. See [CLAY_BORDER](#clay_border) for details.\n- `config.customElementConfig` - Used when `.commandType == CLAY_RENDER_COMMAND_TYPE_CUSTOM`. See [CLAY_CUSTOM](#clay_custom_element) for details.\n- `config.floatingElementConfig` - Not used and will always be NULL.\n- `config.scrollElementConfig` - Not used and will always be NULL.\n\n---\n\n**`.text`** - `Clay_String`\n\nOnly used if `.commandType == CLAY_RENDER_COMMAND_TYPE_TEXT`. A `Clay_String` containing a string slice (char *chars, int length) representing text to be rendered. **Note: This string is not guaranteed to be null terminated.** Clay saves significant performance overhead by using slices when wrapping text instead of having to clone new null terminated strings. If your renderer does not support **ptr, length** style strings (e.g. Raylib), you will need to clone this to a new C string before rendering.\n\n---\n\n**`.id`** - `uint32_t`\n\nThe id that was originally used with the element macro that created this render command. See [CLAY_ID](#clay_id) for details.\n\n---\n\n### Clay_ScrollContainerData\n\n```C\ntypedef struct\n{\n    Clay_Vector2 *scrollPosition;\n    Clay_Dimensions scrollContainerDimensions;\n    Clay_Dimensions contentDimensions;\n    Clay_ScrollElementConfig config;\n    bool found;\n} Clay_ScrollContainerData;\n```\n\n**Fields**\n\n**`.scrollPosition`** - `Clay_Vector2 *`\n\nA pointer to the internal scroll position of this scroll container. Mutating it will result in elements inside the scroll container shifting up / down (`.y`) or left / right (`.x`).\n\n---\n\n**`.scrollContainerDimensions`** - `Clay_Dimensions`\n\n```C\ntypedef struct {\n    float width, height;\n} Clay_Dimensions;\n```\n\nDimensions representing the outer width and height of the scroll container itself.\n\n---\n\n**`.contentDimensions`** - `Clay_Dimensions`\n\n```C\ntypedef struct {\n    float width, height;\n} Clay_Dimensions;\n```\n\nDimensions representing the inner width and height of the content _inside_ the scroll container. Scrolling is only possible when the `contentDimensions` are larger in at least one dimension than the `scrollContainerDimensions`.\n\n---\n\n**`.config`** - `Clay_ScrollElementConfig`\n\nThe [Clay_ScrollElementConfig](#clay_scroll) for the matching scroll container element.\n\n---\n\n### Clay_PointerData\n\n```C\ntypedef struct\n{\n    Clay_Vector2 position;\n    Clay_PointerDataInteractionState state;\n} Clay_PointerData;\n```\n\n**Fields**\n\n**`.position`** - `Clay_Vector2`\n\nA Vector2 containing the current x,y coordinates of the mouse pointer, which were originally passed into [Clay_SetPointerState()](#clay_setpointerstate).\n\n---\n\n**`.state`** - `Clay_PointerDataInteractionState`\n\n```C\ntypedef enum\n{\n    CLAY_POINTER_DATA_PRESSED_THIS_FRAME,\n    CLAY_POINTER_DATA_PRESSED,\n    CLAY_POINTER_DATA_RELEASED_THIS_FRAME,\n    CLAY_POINTER_DATA_RELEASED,\n} Clay_PointerDataInteractionState;\n```\n\nAn enum value representing the current \"state\" of the pointer interaction. As an example, consider the case where a user is on a desktop computer, moves the mouse pointer over a button, clicks and holds the left mouse button for a short time, then releases it:\n\n- While the mouse pointer is over (\"hovering\") the button, but no mouse button has been pressed: `CLAY_POINTER_DATA_RELEASED`\n- First frame that the user presses the left mouse button: `CLAY_POINTER_DATA_PRESSED_THIS_FRAME`\n- All subsequent frames where the user is still holding the left mouse button: `CLAY_POINTER_DATA_PRESSED`\n- The single frame where the left mouse button goes from pressed -> released: `CLAY_POINTER_DATA_RELEASED_THIS_FRAME`\n- All subsequent frames while the mouse pointer is still over the button: `CLAY_POINTER_DATA_RELEASED`\n\n---\n\n### Clay_ErrorHandler\n\n```C\ntypedef struct\n{\n    void (*errorHandlerFunction)(Clay_ErrorData errorText);\n    uintptr_t userData;\n} Clay_ErrorHandler;\n```\n\n**Fields**\n\n**`.errorHandlerFunction`** - `void (Clay_ErrorData errorText) {}`\n\nA function pointer to an error handler function, which takes `Clay_ErrorData` as an argument. This function will be called whenever Clay encounters an internal error.\n\n---\n\n**`.userData`** - `uintptr_t`\n\nA generic pointer to extra userdata that is transparently passed through from `Clay_Initialize` to Clay's error handler callback. Defaults to NULL.\n\n---\n\n### Clay_ErrorData\n\n```C\ntypedef struct\n{\n    Clay_ErrorType errorType;\n    Clay_String errorText;\n    uintptr_t userData;\n} Clay_ErrorData;\n```\n\n**Fields**\n\n**`.errorType`** - `Clay_ErrorType`\n\n```C\ntypedef enum {\n    CLAY_ERROR_TYPE_TEXT_MEASUREMENT_FUNCTION_NOT_PROVIDED,\n    CLAY_ERROR_TYPE_ARENA_CAPACITY_EXCEEDED,\n    CLAY_ERROR_TYPE_ELEMENTS_CAPACITY_EXCEEDED,\n    CLAY_ERROR_TYPE_TEXT_MEASUREMENT_CAPACITY_EXCEEDED,\n    CLAY_ERROR_TYPE_DUPLICATE_ID,\n    CLAY_ERROR_TYPE_FLOATING_CONTAINER_PARENT_NOT_FOUND,\n    CLAY_ERROR_TYPE_INTERNAL_ERROR,\n} Clay_ErrorType;\n```\n\nAn enum representing the type of error Clay encountered. It's up to the user to handle on a case by case basis, but as some general guidance:\n\n- `CLAY_ERROR_TYPE_TEXT_MEASUREMENT_FUNCTION_NOT_PROVIDED` - The user is attempting to use `CLAY_TEXT` and either forgot to call [Clay_SetMeasureTextFunction](#clay_setmeasuretextfunction) or accidentally passed a null function pointer.\n- `CLAY_ERROR_TYPE_ARENA_CAPACITY_EXCEEDED` - Clay was initialized with an Arena that was too small for the configured [Clay_SetMaxElementCount](#clay_setmaxelementcount). Try using [Clay_MinMemorySize()](#clay_minmemorysize) to get the exact number of bytes required by the current configuration.\n- `CLAY_ERROR_TYPE_ELEMENTS_CAPACITY_EXCEEDED` - The declared UI hierarchy has too many elements for the configured max element count. Use [Clay_SetMaxElementCount](#clay_setmaxelementcount) to increase the max, then call [Clay_MinMemorySize()](#clay_minmemorysize) again and reinitialize clay's memory with the required size.\n- `CLAY_ERROR_TYPE_ELEMENTS_CAPACITY_EXCEEDED` - The declared UI hierarchy has too much text for the configured text measure cache size. Use [Clay_SetMaxMeasureTextCacheWordCount](#clay_setmeasuretextcachesize) to increase the max, then call [Clay_MinMemorySize()](#clay_minmemorysize) again and reinitialize clay's memory with the required size.\n- `CLAY_ERROR_TYPE_DUPLICATE_ID` - Two elements in Clays UI Hierarchy have been declared with exactly the same ID. Set a breakpoint in your error handler function for a stack trace back to exactly where this occured.\n- `CLAY_ERROR_TYPE_FLOATING_CONTAINER_PARENT_NOT_FOUND` - A `CLAY_FLOATING` element was declared with the `.parentId` property, but no element with that ID was found. Set a breakpoint in your error handler function for a stack trace back to exactly where this occured.\n- `CLAY_ERROR_TYPE_INTERNAL_ERROR` - Clay has encountered an internal logic or memory error. Please report this as a bug with a stack trace to help us fix these!\n\n---\n\n**`.errorText`** - `Clay_String`\n\nA [Clay_String](#clay_string) that provides a human readable description of the error. May change in future and should not be relied on to detect error types.\n\n---\n\n**`.userData`** - `uintptr_t`\n\nA generic pointer to extra userdata that is transparently passed through from `Clay_Initialize` to Clay's error handler callback. Defaults to NULL.\n\n---\n"
        },
        {
          "name": "bindings",
          "type": "tree",
          "content": null
        },
        {
          "name": "clay.h",
          "type": "blob",
          "size": 223.8359375,
          "content": "// VERSION: 0.11\n\n/*\n    NOTE: In order to use this library you must define\n    the following macro in exactly one file, _before_ including clay.h:\n\n    #define CLAY_IMPLEMENTATION\n    #include \"clay.h\"\n\n    See the examples folder for details.\n*/\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n\n// -----------------------------------------\n// HEADER DECLARATIONS ---------------------\n// -----------------------------------------\n\n#ifndef CLAY_HEADER\n#define CLAY_HEADER\n\n#if !( \\\n    (defined(__cplusplus) && __cplusplus >= 202002L) || \\\n    (defined(__STDC__) && __STDC__ == 1 && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || \\\n    defined(_MSC_VER) \\\n)\n#error \"Clay requires C99, C++20, or MSVC\"\n#endif\n\n#ifdef CLAY_WASM\n#define CLAY_WASM_EXPORT(name) __attribute__((export_name(name)))\n#else\n#define CLAY_WASM_EXPORT(null)\n#endif\n\n// Public Macro API ------------------------\n\n#define CLAY__WRAPPER_TYPE(type) Clay__##type##Wrapper\n#define CLAY__WRAPPER_STRUCT(type) typedef struct { type wrapped; } CLAY__WRAPPER_TYPE(type)\n#define CLAY__CONFIG_WRAPPER(type, ...) (CLAY__INIT(CLAY__WRAPPER_TYPE(type)) { __VA_ARGS__ }).wrapped\n\n#define CLAY__MAX(x, y) (((x) > (y)) ? (x) : (y))\n#define CLAY__MIN(x, y) (((x) < (y)) ? (x) : (y))\n\n#define CLAY_LAYOUT(...) Clay__AttachLayoutConfig(Clay__StoreLayoutConfig(CLAY__CONFIG_WRAPPER(Clay_LayoutConfig, __VA_ARGS__)))\n\n#define CLAY_RECTANGLE(...) Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .rectangleElementConfig = Clay__StoreRectangleElementConfig(CLAY__CONFIG_WRAPPER(Clay_RectangleElementConfig, __VA_ARGS__)) }, CLAY__ELEMENT_CONFIG_TYPE_RECTANGLE)\n\n#define CLAY_TEXT_CONFIG(...) Clay__StoreTextElementConfig(CLAY__CONFIG_WRAPPER(Clay_TextElementConfig, __VA_ARGS__))\n\n#define CLAY_IMAGE(...) Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .imageElementConfig = Clay__StoreImageElementConfig(CLAY__CONFIG_WRAPPER(Clay_ImageElementConfig, __VA_ARGS__)) }, CLAY__ELEMENT_CONFIG_TYPE_IMAGE)\n\n#define CLAY_FLOATING(...) Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .floatingElementConfig = Clay__StoreFloatingElementConfig(CLAY__CONFIG_WRAPPER(Clay_FloatingElementConfig, __VA_ARGS__)) }, CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER)\n\n#define CLAY_CUSTOM_ELEMENT(...) Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .customElementConfig = Clay__StoreCustomElementConfig(CLAY__CONFIG_WRAPPER(Clay_CustomElementConfig, __VA_ARGS__)) }, CLAY__ELEMENT_CONFIG_TYPE_CUSTOM)\n\n#define CLAY_SCROLL(...) Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .scrollElementConfig = Clay__StoreScrollElementConfig(CLAY__CONFIG_WRAPPER(Clay_ScrollElementConfig, __VA_ARGS__)) }, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER)\n\n#define CLAY_BORDER(...) Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .borderElementConfig = Clay__StoreBorderElementConfig(CLAY__CONFIG_WRAPPER(Clay_BorderElementConfig, __VA_ARGS__)) }, CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER)\n\n#define CLAY_BORDER_OUTSIDE(...) Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .borderElementConfig = Clay__StoreBorderElementConfig(CLAY__INIT(Clay_BorderElementConfig) { .left = __VA_ARGS__, .right = __VA_ARGS__, .top = __VA_ARGS__, .bottom = __VA_ARGS__ }) }, CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER)\n\n#define CLAY_BORDER_OUTSIDE_RADIUS(width, color, radius) Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .borderElementConfig = Clay__StoreBorderElementConfig(CLAY__INIT(Clay_BorderElementConfig) { .left = { width, color }, .right = { width, color }, .top = { width, color }, .bottom = { width, color }, .cornerRadius = CLAY_CORNER_RADIUS(radius) })}, CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER)\n\n#define CLAY_BORDER_ALL(...) Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .borderElementConfig = Clay__StoreBorderElementConfig(CLAY__INIT(Clay_BorderElementConfig) { .left = __VA_ARGS__, .right = __VA_ARGS__, .top = __VA_ARGS__, .bottom = __VA_ARGS__, .betweenChildren = __VA_ARGS__ }) }, CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER)\n\n#define CLAY_BORDER_ALL_RADIUS(width, color, radius) Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .borderElementConfig = Clay__StoreBorderElementConfig(CLAY__INIT(Clay_BorderElementConfig) { .left = { width, color }, .right = { width, color }, .top = { width, color }, .bottom = { width, color }, .betweenChildren = { width, color }, .cornerRadius = CLAY_CORNER_RADIUS(radius)}) }, CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER)\n\n#define CLAY_CORNER_RADIUS(radius) (CLAY__INIT(Clay_CornerRadius) { radius, radius, radius, radius })\n\n#define CLAY_SIZING_FIT(...) (CLAY__INIT(Clay_SizingAxis) { .size = { .minMax = { __VA_ARGS__ } }, .type = CLAY__SIZING_TYPE_FIT })\n\n#define CLAY_SIZING_GROW(...) (CLAY__INIT(Clay_SizingAxis) { .size = { .minMax = { __VA_ARGS__ } }, .type = CLAY__SIZING_TYPE_GROW })\n\n#define CLAY_SIZING_FIXED(fixedSize) (CLAY__INIT(Clay_SizingAxis) { .size = { .minMax = { fixedSize, fixedSize } }, .type = CLAY__SIZING_TYPE_FIXED })\n\n#define CLAY_SIZING_PERCENT(percentOfParent) (CLAY__INIT(Clay_SizingAxis) { .size = { .percent = (percentOfParent) }, .type = CLAY__SIZING_TYPE_PERCENT })\n\n#define CLAY_ID(label) Clay__AttachId(Clay__HashString(CLAY_STRING(label), 0, 0))\n\n#define CLAY_IDI(label, index) Clay__AttachId(Clay__HashString(CLAY_STRING(label), index, 0))\n\n#define CLAY_ID_LOCAL(label) CLAY_IDI_LOCAL(label, 0)\n\n#define CLAY_IDI_LOCAL(label, index) Clay__AttachId(Clay__HashString(CLAY_STRING(label), index, Clay__GetParentElementId()))\n\n#define CLAY__STRING_LENGTH(s) ((sizeof(s) / sizeof((s)[0])) - sizeof((s)[0]))\n\n#define CLAY__ENSURE_STRING_LITERAL(x) (\"\" x \"\")\n\n// Note: If an error led you here, it's because CLAY_STRING can only be used with string literals, i.e. CLAY_STRING(\"SomeString\") and not CLAY_STRING(yourString)\n#define CLAY_STRING(string) (CLAY__INIT(Clay_String) { .length = CLAY__STRING_LENGTH(CLAY__ENSURE_STRING_LITERAL(string)), .chars = (string) })\n\n#define CLAY_STRING_CONST(string) { .length = CLAY__STRING_LENGTH(CLAY__ENSURE_STRING_LITERAL(string)), .chars = (string) }\n\nstatic uint8_t CLAY__ELEMENT_DEFINITION_LATCH;\n\n// Publicly visible layout element macros -----------------------------------------------------\n\n/* This macro looks scary on the surface, but is actually quite simple.\n  It turns a macro call like this:\n\n  CLAY(\n    CLAY_RECTANGLE(),\n    CLAY_ID()\n  ) {\n      ...children declared here\n  }\n\n  Into calls like this:\n\n  Clay_OpenElement();\n  CLAY_RECTANGLE();\n  CLAY_ID();\n  Clay_ElementPostConfiguration();\n  ...children declared here\n  Clay_CloseElement();\n\n  The for loop will only ever run a single iteration, putting Clay__CloseElement() in the increment of the loop\n  means that it will run after the body - where the children are declared. It just exists to make sure you don't forget\n  to call Clay_CloseElement().\n*/\n#define CLAY(...) \\\n\tfor (\\\n\t\tCLAY__ELEMENT_DEFINITION_LATCH = (Clay__OpenElement(), __VA_ARGS__, Clay__ElementPostConfiguration(), 0); \\\n\t\tCLAY__ELEMENT_DEFINITION_LATCH < 1; \\\n\t\t++CLAY__ELEMENT_DEFINITION_LATCH, Clay__CloseElement() \\\n\t)\n\n#define CLAY_TEXT(text, textConfig) Clay__OpenTextElement(text, textConfig)\n\n#ifdef __cplusplus\n\n#define CLAY__INIT(type) type\n#define CLAY__TYPEDEF(name, ...) typedef __VA_ARGS__ name; CLAY__WRAPPER_STRUCT(name)\n#define CLAY__ALIGNMENT(type) alignof(type)\n#define CLAY__POINTER_ALIGNMENT alignof(void *)\n\n#define CLAY_PACKED_ENUM enum : uint8_t\n\n#define CLAY__DEFAULT_STRUCT {}\n\n#else\n\n#define CLAY__INIT(type) (type)\n\n#define CLAY__ALIGNMENT_STRUCT(type) struct Clay__Align##type { char c; type x; }\n#define CLAY__TYPEDEF(name, ...) typedef __VA_ARGS__ name; CLAY__ALIGNMENT_STRUCT(name); CLAY__WRAPPER_STRUCT(name)\n#define CLAY__ALIGNMENT(type) (offsetof(struct Clay__Align##type, x))\n#define CLAY__POINTER_ALIGNMENT CLAY__ALIGNMENT(pointer)\n\n// NOTE: If you need to get the offset for other standard types in the future, add them here.\nstruct Clay__Alignpointer { char c; void *x; };\nCLAY__ALIGNMENT_STRUCT(bool);\nCLAY__ALIGNMENT_STRUCT(uint8_t);\nCLAY__ALIGNMENT_STRUCT(int32_t);\n\n#if defined(_MSC_VER) && !defined(__clang__)\n#define CLAY_PACKED_ENUM __pragma(pack(push, 1)) enum __pragma(pack(pop))\n#else\n#define CLAY_PACKED_ENUM enum __attribute__((__packed__))\n#endif\n\n#if __STDC_VERSION__ >= 202311L\n#define CLAY__DEFAULT_STRUCT {}\n#else\n#define CLAY__DEFAULT_STRUCT {0}\n#endif\n\n#endif // __cplusplus\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Utility Structs -------------------------\n// Note: Clay_String is not guaranteed to be null terminated. It may be if created from a literal C string,\n// but it is also used to represent slices.\nCLAY__TYPEDEF(Clay_String, struct {\n    int32_t length;\n    const char *chars;\n});\n\nCLAY__TYPEDEF(Clay__StringArray, struct {\n    int32_t capacity;\n    int32_t length;\n    Clay_String *internalArray;\n});\n\ntypedef struct Clay_Context Clay_Context;\n\nCLAY__TYPEDEF(Clay_Arena, struct {\n    uintptr_t nextAllocation;\n    size_t capacity;\n    char *memory;\n});\n\nCLAY__TYPEDEF(Clay_Dimensions, struct {\n    float width, height;\n});\n\nCLAY__TYPEDEF(Clay_Vector2, struct {\n    float x, y;\n});\n\nCLAY__TYPEDEF(Clay_Color, struct {\n    float r, g, b, a;\n});\n\nCLAY__TYPEDEF(Clay_BoundingBox, struct {\n    float x, y, width, height;\n});\n\n// baseId + offset = id\nCLAY__TYPEDEF(Clay_ElementId, struct {\n    uint32_t id;\n    uint32_t offset;\n    uint32_t baseId;\n    Clay_String stringId;\n});\n\nCLAY__TYPEDEF(Clay_CornerRadius, struct {\n    float topLeft;\n    float topRight;\n    float bottomLeft;\n    float bottomRight;\n});\n\nCLAY__TYPEDEF(Clay__ElementConfigType, CLAY_PACKED_ENUM {\n    CLAY__ELEMENT_CONFIG_TYPE_NONE = 0,\n    CLAY__ELEMENT_CONFIG_TYPE_RECTANGLE = 1,\n    CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER = 2,\n    CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER = 4,\n    CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER = 8,\n    CLAY__ELEMENT_CONFIG_TYPE_IMAGE = 16,\n    CLAY__ELEMENT_CONFIG_TYPE_TEXT = 32,\n    CLAY__ELEMENT_CONFIG_TYPE_CUSTOM = 64,\n});\n\n// Element Configs ---------------------------\n// Layout\nCLAY__TYPEDEF(Clay_LayoutDirection, CLAY_PACKED_ENUM {\n    CLAY_LEFT_TO_RIGHT,\n    CLAY_TOP_TO_BOTTOM,\n});\n\nCLAY__TYPEDEF(Clay_LayoutAlignmentX, CLAY_PACKED_ENUM {\n    CLAY_ALIGN_X_LEFT,\n    CLAY_ALIGN_X_RIGHT,\n    CLAY_ALIGN_X_CENTER,\n});\n\nCLAY__TYPEDEF(Clay_LayoutAlignmentY, CLAY_PACKED_ENUM {\n    CLAY_ALIGN_Y_TOP,\n    CLAY_ALIGN_Y_BOTTOM,\n    CLAY_ALIGN_Y_CENTER,\n});\n\nCLAY__TYPEDEF(Clay__SizingType, CLAY_PACKED_ENUM {\n    CLAY__SIZING_TYPE_FIT,\n    CLAY__SIZING_TYPE_GROW,\n    CLAY__SIZING_TYPE_PERCENT,\n    CLAY__SIZING_TYPE_FIXED,\n});\n\nCLAY__TYPEDEF(Clay_ChildAlignment, struct {\n    Clay_LayoutAlignmentX x;\n    Clay_LayoutAlignmentY y;\n});\n\nCLAY__TYPEDEF(Clay_SizingMinMax, struct {\n    float min;\n    float max;\n});\n\nCLAY__TYPEDEF(Clay_SizingAxis, struct {\n    union {\n        Clay_SizingMinMax minMax;\n        float percent;\n    } size;\n    Clay__SizingType type;\n});\n\nCLAY__TYPEDEF(Clay_Sizing, struct {\n    Clay_SizingAxis width;\n    Clay_SizingAxis height;\n});\n\nCLAY__TYPEDEF(Clay_Padding, struct {\n    uint16_t x;\n    uint16_t y;\n});\n\nCLAY__TYPEDEF(Clay_LayoutConfig, struct {\n    Clay_Sizing sizing;\n    Clay_Padding padding;\n    uint16_t childGap;\n    Clay_ChildAlignment childAlignment;\n    Clay_LayoutDirection layoutDirection;\n});\n\nextern Clay_LayoutConfig CLAY_LAYOUT_DEFAULT;\n\n// Rectangle\n// NOTE: Not declared in the typedef as an ifdef inside macro arguments is UB\nstruct Clay_RectangleElementConfig {\n    Clay_Color color;\n    Clay_CornerRadius cornerRadius;\n    #ifdef CLAY_EXTEND_CONFIG_RECTANGLE\n    CLAY_EXTEND_CONFIG_RECTANGLE\n    #endif\n};\nCLAY__TYPEDEF(Clay_RectangleElementConfig, struct Clay_RectangleElementConfig);\n\n// Text\nCLAY__TYPEDEF(Clay_TextElementConfigWrapMode, enum {\n    CLAY_TEXT_WRAP_WORDS,\n    CLAY_TEXT_WRAP_NEWLINES,\n    CLAY_TEXT_WRAP_NONE,\n});\n\nstruct Clay_TextElementConfig {\n    Clay_Color textColor;\n    uint16_t fontId;\n    uint16_t fontSize;\n    uint16_t letterSpacing;\n    uint16_t lineHeight;\n    Clay_TextElementConfigWrapMode wrapMode;\n    #ifdef CLAY_EXTEND_CONFIG_TEXT\n    CLAY_EXTEND_CONFIG_TEXT\n    #endif\n};\nCLAY__TYPEDEF(Clay_TextElementConfig, struct Clay_TextElementConfig);\n\n// Image\nstruct Clay_ImageElementConfig {\n    void *imageData;\n    Clay_Dimensions sourceDimensions;\n    #ifdef CLAY_EXTEND_CONFIG_IMAGE\n    CLAY_EXTEND_CONFIG_IMAGE\n    #endif\n};\nCLAY__TYPEDEF(Clay_ImageElementConfig, struct Clay_ImageElementConfig);\n\n// Floating\nCLAY__TYPEDEF(Clay_FloatingAttachPointType, CLAY_PACKED_ENUM {\n    CLAY_ATTACH_POINT_LEFT_TOP,\n    CLAY_ATTACH_POINT_LEFT_CENTER,\n    CLAY_ATTACH_POINT_LEFT_BOTTOM,\n    CLAY_ATTACH_POINT_CENTER_TOP,\n    CLAY_ATTACH_POINT_CENTER_CENTER,\n    CLAY_ATTACH_POINT_CENTER_BOTTOM,\n    CLAY_ATTACH_POINT_RIGHT_TOP,\n    CLAY_ATTACH_POINT_RIGHT_CENTER,\n    CLAY_ATTACH_POINT_RIGHT_BOTTOM,\n});\n\nCLAY__TYPEDEF(Clay_FloatingAttachPoints, struct {\n    Clay_FloatingAttachPointType element;\n    Clay_FloatingAttachPointType parent;\n});\n\nCLAY__TYPEDEF(Clay_PointerCaptureMode, enum {\n    CLAY_POINTER_CAPTURE_MODE_CAPTURE,\n//    CLAY_POINTER_CAPTURE_MODE_PARENT, TODO pass pointer through to attached parent\n    CLAY_POINTER_CAPTURE_MODE_PASSTHROUGH,\n});\n\nCLAY__TYPEDEF(Clay_FloatingElementConfig, struct {\n    Clay_Vector2 offset;\n    Clay_Dimensions expand;\n    uint16_t zIndex;\n    uint32_t parentId;\n    Clay_FloatingAttachPoints attachment;\n    Clay_PointerCaptureMode pointerCaptureMode;\n});\n\n// Custom\nstruct Clay_CustomElementConfig {\n    #ifndef CLAY_EXTEND_CONFIG_CUSTOM\n    void *customData;\n    #else\n    CLAY_EXTEND_CONFIG_CUSTOM\n    #endif\n};\nCLAY__TYPEDEF(Clay_CustomElementConfig, struct Clay_CustomElementConfig);\n\n// Scroll\nCLAY__TYPEDEF(Clay_ScrollElementConfig, struct {\n    bool horizontal;\n    bool vertical;\n});\n\n// Border\nCLAY__TYPEDEF(Clay_Border, struct {\n    uint32_t width;\n    Clay_Color color;\n});\n\nstruct Clay_BorderElementConfig {\n    Clay_Border left;\n    Clay_Border right;\n    Clay_Border top;\n    Clay_Border bottom;\n    Clay_Border betweenChildren;\n    Clay_CornerRadius cornerRadius;\n    #ifdef CLAY_EXTEND_CONFIG_BORDER\n    CLAY_EXTEND_CONFIG_BORDER\n    #endif\n};\nCLAY__TYPEDEF(Clay_BorderElementConfig, struct Clay_BorderElementConfig);\n\nCLAY__TYPEDEF(Clay_ElementConfigUnion, union {\n    Clay_RectangleElementConfig *rectangleElementConfig;\n    Clay_TextElementConfig *textElementConfig;\n    Clay_ImageElementConfig *imageElementConfig;\n    Clay_FloatingElementConfig *floatingElementConfig;\n    Clay_CustomElementConfig *customElementConfig;\n    Clay_ScrollElementConfig *scrollElementConfig;\n    Clay_BorderElementConfig *borderElementConfig;\n});\n\nCLAY__TYPEDEF(Clay_ElementConfig, struct {\n    Clay__ElementConfigType type;\n    Clay_ElementConfigUnion config;\n});\n\n// Miscellaneous Structs & Enums ---------------------------------\nCLAY__TYPEDEF(Clay_ScrollContainerData, struct {\n    // Note: This is a pointer to the real internal scroll position, mutating it may cause a change in final layout.\n    // Intended for use with external functionality that modifies scroll position, such as scroll bars or auto scrolling.\n    Clay_Vector2 *scrollPosition;\n    Clay_Dimensions scrollContainerDimensions;\n    Clay_Dimensions contentDimensions;\n    Clay_ScrollElementConfig config;\n    // Indicates whether an actual scroll container matched the provided ID or if the default struct was returned.\n    bool found;\n});\n\nCLAY__TYPEDEF(Clay_RenderCommandType, CLAY_PACKED_ENUM {\n    CLAY_RENDER_COMMAND_TYPE_NONE,\n    CLAY_RENDER_COMMAND_TYPE_RECTANGLE,\n    CLAY_RENDER_COMMAND_TYPE_BORDER,\n    CLAY_RENDER_COMMAND_TYPE_TEXT,\n    CLAY_RENDER_COMMAND_TYPE_IMAGE,\n    CLAY_RENDER_COMMAND_TYPE_SCISSOR_START,\n    CLAY_RENDER_COMMAND_TYPE_SCISSOR_END,\n    CLAY_RENDER_COMMAND_TYPE_CUSTOM,\n});\n\nCLAY__TYPEDEF(Clay_RenderCommand, struct {\n    Clay_BoundingBox boundingBox;\n    Clay_ElementConfigUnion config;\n    Clay_String text; // TODO I wish there was a way to avoid having to have this on every render command\n    uint32_t id;\n    Clay_RenderCommandType commandType;\n});\n\nCLAY__TYPEDEF(Clay_RenderCommandArray, struct {\n    int32_t capacity;\n    int32_t length;\n    Clay_RenderCommand *internalArray;\n});\n\nCLAY__TYPEDEF(Clay_PointerDataInteractionState, enum {\n    CLAY_POINTER_DATA_PRESSED_THIS_FRAME,\n    CLAY_POINTER_DATA_PRESSED,\n    CLAY_POINTER_DATA_RELEASED_THIS_FRAME,\n    CLAY_POINTER_DATA_RELEASED,\n});\n\nCLAY__TYPEDEF(Clay_PointerData, struct {\n    Clay_Vector2 position;\n    Clay_PointerDataInteractionState state;\n});\n\nCLAY__TYPEDEF(Clay_ErrorType, enum {\n    CLAY_ERROR_TYPE_TEXT_MEASUREMENT_FUNCTION_NOT_PROVIDED,\n    CLAY_ERROR_TYPE_ARENA_CAPACITY_EXCEEDED,\n    CLAY_ERROR_TYPE_ELEMENTS_CAPACITY_EXCEEDED,\n    CLAY_ERROR_TYPE_TEXT_MEASUREMENT_CAPACITY_EXCEEDED,\n    CLAY_ERROR_TYPE_DUPLICATE_ID,\n    CLAY_ERROR_TYPE_FLOATING_CONTAINER_PARENT_NOT_FOUND,\n    CLAY_ERROR_TYPE_INTERNAL_ERROR,\n});\n\nCLAY__TYPEDEF(Clay_ErrorData, struct {\n    Clay_ErrorType errorType;\n    Clay_String errorText;\n    uintptr_t userData;\n});\n\nCLAY__TYPEDEF(Clay_ErrorHandler, struct {\n    void (*errorHandlerFunction)(Clay_ErrorData errorText);\n    uintptr_t userData;\n});\n\n// Function Forward Declarations ---------------------------------\n// Public API functions ---\nuint32_t Clay_MinMemorySize(void);\nClay_Arena Clay_CreateArenaWithCapacityAndMemory(uint32_t capacity, void *offset);\nvoid Clay_SetPointerState(Clay_Vector2 position, bool pointerDown);\nClay_Context* Clay_Initialize(Clay_Arena arena, Clay_Dimensions layoutDimensions, Clay_ErrorHandler errorHandler);\nClay_Context* Clay_GetCurrentContext(void);\nvoid Clay_SetCurrentContext(Clay_Context* context);\nvoid Clay_UpdateScrollContainers(bool enableDragScrolling, Clay_Vector2 scrollDelta, float deltaTime);\nvoid Clay_SetLayoutDimensions(Clay_Dimensions dimensions);\nvoid Clay_BeginLayout(void);\nClay_RenderCommandArray Clay_EndLayout(void);\nClay_ElementId Clay_GetElementId(Clay_String idString);\nClay_ElementId Clay_GetElementIdWithIndex(Clay_String idString, uint32_t index);\nbool Clay_Hovered(void);\nvoid Clay_OnHover(void (*onHoverFunction)(Clay_ElementId elementId, Clay_PointerData pointerData, intptr_t userData), intptr_t userData);\nbool Clay_PointerOver(Clay_ElementId elementId);\nClay_ScrollContainerData Clay_GetScrollContainerData(Clay_ElementId id);\nvoid Clay_SetMeasureTextFunction(Clay_Dimensions (*measureTextFunction)(Clay_String *text, Clay_TextElementConfig *config));\nvoid Clay_SetQueryScrollOffsetFunction(Clay_Vector2 (*queryScrollOffsetFunction)(uint32_t elementId));\nClay_RenderCommand * Clay_RenderCommandArray_Get(Clay_RenderCommandArray* array, int32_t index);\nvoid Clay_SetDebugModeEnabled(bool enabled);\nbool Clay_IsDebugModeEnabled(void);\nvoid Clay_SetCullingEnabled(bool enabled);\nint32_t Clay_GetMaxElementCount(void);\nvoid Clay_SetMaxElementCount(int32_t maxElementCount);\nint32_t Clay_GetMaxMeasureTextCacheWordCount(void);\nvoid Clay_SetMaxMeasureTextCacheWordCount(int32_t maxMeasureTextCacheWordCount);\n\n// Internal API functions required by macros\nvoid Clay__OpenElement(void);\nvoid Clay__CloseElement(void);\nClay_LayoutConfig * Clay__StoreLayoutConfig(Clay_LayoutConfig config);\nvoid Clay__ElementPostConfiguration(void);\nvoid Clay__AttachId(Clay_ElementId id);\nvoid Clay__AttachLayoutConfig(Clay_LayoutConfig *config);\nvoid Clay__AttachElementConfig(Clay_ElementConfigUnion config, Clay__ElementConfigType type);\nClay_RectangleElementConfig * Clay__StoreRectangleElementConfig(Clay_RectangleElementConfig config);\nClay_TextElementConfig * Clay__StoreTextElementConfig(Clay_TextElementConfig config);\nClay_ImageElementConfig * Clay__StoreImageElementConfig(Clay_ImageElementConfig config);\nClay_FloatingElementConfig * Clay__StoreFloatingElementConfig(Clay_FloatingElementConfig config);\nClay_CustomElementConfig * Clay__StoreCustomElementConfig(Clay_CustomElementConfig config);\nClay_ScrollElementConfig * Clay__StoreScrollElementConfig(Clay_ScrollElementConfig config);\nClay_BorderElementConfig * Clay__StoreBorderElementConfig(Clay_BorderElementConfig config);\nClay_ElementId Clay__HashString(Clay_String key, uint32_t offset, uint32_t seed);\nvoid Clay__OpenTextElement(Clay_String text, Clay_TextElementConfig *textConfig);\nuint32_t Clay__GetParentElementId(void);\n\nextern Clay_Color Clay__debugViewHighlightColor;\nextern uint32_t Clay__debugViewWidth;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // CLAY_HEADER\n\n// -----------------------------------------\n// IMPLEMENTATION --------------------------\n// -----------------------------------------\n#ifdef CLAY_IMPLEMENTATION\n#undef CLAY_IMPLEMENTATION\n\n#ifndef CLAY__NULL\n#define CLAY__NULL 0\n#endif\n\n#ifndef CLAY__MAXFLOAT\n#define CLAY__MAXFLOAT 3.40282346638528859812e+38F\n#endif\n\nClay_Context *Clay__currentContext;\nint32_t Clay__defaultMaxElementCount = 8192;\nint32_t Clay__defaultMaxMeasureTextWordCacheCount = 16384;\n\nvoid Clay__ErrorHandlerFunctionDefault(Clay_ErrorData errorText) {\n    (void) errorText;\n}\n\nClay_String CLAY__SPACECHAR = { .length = 1, .chars = \" \" };\nClay_String CLAY__STRING_DEFAULT = { .length = 0, .chars = NULL };\n\nCLAY__TYPEDEF(Clay_BooleanWarnings, struct {\n    bool maxElementsExceeded;\n    bool maxRenderCommandsExceeded;\n    bool maxTextMeasureCacheExceeded;\n});\n\nCLAY__TYPEDEF(Clay__Warning, struct {\n    Clay_String baseMessage;\n    Clay_String dynamicMessage;\n});\n\nClay__Warning CLAY__WARNING_DEFAULT = CLAY__DEFAULT_STRUCT;\n\nCLAY__TYPEDEF(Clay__WarningArray, struct {\n    int32_t capacity;\n    int32_t length;\n    Clay__Warning *internalArray;\n});\n\nClay__WarningArray Clay__WarningArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena);\nClay__Warning *Clay__WarningArray_Add(Clay__WarningArray *array, Clay__Warning item);\nvoid* Clay__Array_Allocate_Arena(int32_t capacity, uint32_t itemSize, uint32_t alignment, Clay_Arena *arena);\nbool Clay__Array_RangeCheck(int32_t index, int32_t length);\nbool Clay__Array_AddCapacityCheck(int32_t length, int32_t capacity);\n\n// __GENERATED__ template array_define,array_allocate TYPE=bool NAME=Clay__BoolArray\n#pragma region generated\nCLAY__TYPEDEF(Clay__BoolArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tbool *internalArray;\n});\nClay__BoolArray Clay__BoolArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__BoolArray){.capacity = capacity, .length = 0, .internalArray = (bool *)Clay__Array_Allocate_Arena(capacity, sizeof(bool), CLAY__ALIGNMENT(bool), arena)};\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_ElementId CLAY__ELEMENT_ID_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_get,array_add TYPE=Clay_ElementId NAME=Clay__ElementIdArray DEFAULT_VALUE=&CLAY__ELEMENT_ID_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__ElementIdArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_ElementId *internalArray;\n});\nClay__ElementIdArray Clay__ElementIdArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__ElementIdArray){.capacity = capacity, .length = 0, .internalArray = (Clay_ElementId *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_ElementId), CLAY__ALIGNMENT(Clay_ElementId), arena)};\n}\nClay_ElementId *Clay__ElementIdArray_Get(Clay__ElementIdArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__ELEMENT_ID_DEFAULT;\n}\nClay_ElementId *Clay__ElementIdArray_Add(Clay__ElementIdArray *array, Clay_ElementId item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__ELEMENT_ID_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_ElementConfig CLAY__ELEMENT_CONFIG_DEFAULT = {CLAY__ELEMENT_CONFIG_TYPE_NONE, CLAY__DEFAULT_STRUCT};\n\n// __GENERATED__ template array_define,array_define_slice,array_allocate,array_get,array_add,array_get_slice TYPE=Clay_ElementConfig NAME=Clay__ElementConfigArray DEFAULT_VALUE=&CLAY__ELEMENT_CONFIG_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__ElementConfigArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_ElementConfig *internalArray;\n});\nCLAY__TYPEDEF(Clay__ElementConfigArraySlice, struct\n{\n\tint32_t length;\n\tClay_ElementConfig *internalArray;\n});\nClay__ElementConfigArray Clay__ElementConfigArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__ElementConfigArray){.capacity = capacity, .length = 0, .internalArray = (Clay_ElementConfig *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_ElementConfig), CLAY__ALIGNMENT(Clay_ElementConfig), arena)};\n}\nClay_ElementConfig *Clay__ElementConfigArray_Get(Clay__ElementConfigArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__ELEMENT_CONFIG_DEFAULT;\n}\nClay_ElementConfig *Clay__ElementConfigArray_Add(Clay__ElementConfigArray *array, Clay_ElementConfig item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__ELEMENT_CONFIG_DEFAULT;\n}\nClay_ElementConfig *Clay__ElementConfigArraySlice_Get(Clay__ElementConfigArraySlice *slice, int32_t index) {\n    return Clay__Array_RangeCheck(index, slice->length) ? &slice->internalArray[index] : &CLAY__ELEMENT_CONFIG_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_LayoutConfig CLAY_LAYOUT_DEFAULT = { .sizing = { .width = { .size = { .minMax = {0, CLAY__MAXFLOAT } }, .type = CLAY__SIZING_TYPE_FIT }, .height = { .size = { .minMax = {0, CLAY__MAXFLOAT } }, .type = CLAY__SIZING_TYPE_FIT } } };\n\n// __GENERATED__ template array_define,array_allocate,array_add TYPE=Clay_LayoutConfig NAME=Clay__LayoutConfigArray DEFAULT_VALUE=&CLAY_LAYOUT_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__LayoutConfigArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_LayoutConfig *internalArray;\n});\nClay__LayoutConfigArray Clay__LayoutConfigArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__LayoutConfigArray){.capacity = capacity, .length = 0, .internalArray = (Clay_LayoutConfig *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_LayoutConfig), CLAY__ALIGNMENT(Clay_LayoutConfig), arena)};\n}\nClay_LayoutConfig *Clay__LayoutConfigArray_Add(Clay__LayoutConfigArray *array, Clay_LayoutConfig item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY_LAYOUT_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_RectangleElementConfig CLAY__RECTANGLE_ELEMENT_CONFIG_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add TYPE=Clay_RectangleElementConfig NAME=Clay__RectangleElementConfigArray DEFAULT_VALUE=&CLAY__RECTANGLE_ELEMENT_CONFIG_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__RectangleElementConfigArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_RectangleElementConfig *internalArray;\n});\nClay__RectangleElementConfigArray Clay__RectangleElementConfigArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__RectangleElementConfigArray){.capacity = capacity, .length = 0, .internalArray = (Clay_RectangleElementConfig *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_RectangleElementConfig), CLAY__ALIGNMENT(Clay_RectangleElementConfig), arena)};\n}\nClay_RectangleElementConfig *Clay__RectangleElementConfigArray_Add(Clay__RectangleElementConfigArray *array, Clay_RectangleElementConfig item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__RECTANGLE_ELEMENT_CONFIG_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_TextElementConfig CLAY__TEXT_ELEMENT_CONFIG_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add TYPE=Clay_TextElementConfig NAME=Clay__TextElementConfigArray DEFAULT_VALUE=&CLAY__TEXT_ELEMENT_CONFIG_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__TextElementConfigArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_TextElementConfig *internalArray;\n});\nClay__TextElementConfigArray Clay__TextElementConfigArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__TextElementConfigArray){.capacity = capacity, .length = 0, .internalArray = (Clay_TextElementConfig *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_TextElementConfig), CLAY__ALIGNMENT(Clay_TextElementConfig), arena)};\n}\nClay_TextElementConfig *Clay__TextElementConfigArray_Add(Clay__TextElementConfigArray *array, Clay_TextElementConfig item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__TEXT_ELEMENT_CONFIG_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_ImageElementConfig CLAY__IMAGE_ELEMENT_CONFIG_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add TYPE=Clay_ImageElementConfig NAME=Clay__ImageElementConfigArray DEFAULT_VALUE=&CLAY__IMAGE_ELEMENT_CONFIG_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__ImageElementConfigArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_ImageElementConfig *internalArray;\n});\nClay__ImageElementConfigArray Clay__ImageElementConfigArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__ImageElementConfigArray){.capacity = capacity, .length = 0, .internalArray = (Clay_ImageElementConfig *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_ImageElementConfig), CLAY__ALIGNMENT(Clay_ImageElementConfig), arena)};\n}\nClay_ImageElementConfig *Clay__ImageElementConfigArray_Add(Clay__ImageElementConfigArray *array, Clay_ImageElementConfig item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__IMAGE_ELEMENT_CONFIG_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_FloatingElementConfig CLAY__FLOATING_ELEMENT_CONFIG_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add TYPE=Clay_FloatingElementConfig NAME=Clay__FloatingElementConfigArray DEFAULT_VALUE=&CLAY__FLOATING_ELEMENT_CONFIG_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__FloatingElementConfigArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_FloatingElementConfig *internalArray;\n});\nClay__FloatingElementConfigArray Clay__FloatingElementConfigArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__FloatingElementConfigArray){.capacity = capacity, .length = 0, .internalArray = (Clay_FloatingElementConfig *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_FloatingElementConfig), CLAY__ALIGNMENT(Clay_FloatingElementConfig), arena)};\n}\nClay_FloatingElementConfig *Clay__FloatingElementConfigArray_Add(Clay__FloatingElementConfigArray *array, Clay_FloatingElementConfig item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__FLOATING_ELEMENT_CONFIG_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_CustomElementConfig CLAY__CUSTOM_ELEMENT_CONFIG_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add TYPE=Clay_CustomElementConfig NAME=Clay__CustomElementConfigArray DEFAULT_VALUE=&CLAY__CUSTOM_ELEMENT_CONFIG_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__CustomElementConfigArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_CustomElementConfig *internalArray;\n});\nClay__CustomElementConfigArray Clay__CustomElementConfigArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__CustomElementConfigArray){.capacity = capacity, .length = 0, .internalArray = (Clay_CustomElementConfig *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_CustomElementConfig), CLAY__ALIGNMENT(Clay_CustomElementConfig), arena)};\n}\nClay_CustomElementConfig *Clay__CustomElementConfigArray_Add(Clay__CustomElementConfigArray *array, Clay_CustomElementConfig item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__CUSTOM_ELEMENT_CONFIG_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_ScrollElementConfig CLAY__SCROLL_ELEMENT_CONFIG_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add TYPE=Clay_ScrollElementConfig NAME=Clay__ScrollElementConfigArray DEFAULT_VALUE=&CLAY__SCROLL_ELEMENT_CONFIG_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__ScrollElementConfigArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_ScrollElementConfig *internalArray;\n});\nClay__ScrollElementConfigArray Clay__ScrollElementConfigArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__ScrollElementConfigArray){.capacity = capacity, .length = 0, .internalArray = (Clay_ScrollElementConfig *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_ScrollElementConfig), CLAY__ALIGNMENT(Clay_ScrollElementConfig), arena)};\n}\nClay_ScrollElementConfig *Clay__ScrollElementConfigArray_Add(Clay__ScrollElementConfigArray *array, Clay_ScrollElementConfig item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__SCROLL_ELEMENT_CONFIG_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\n// __GENERATED__ template array_define_slice,array_allocate,array_add TYPE=Clay_String NAME=Clay__StringArray DEFAULT_VALUE=&CLAY__STRING_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__StringArraySlice, struct\n{\n\tint32_t length;\n\tClay_String *internalArray;\n});\nClay__StringArray Clay__StringArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__StringArray){.capacity = capacity, .length = 0, .internalArray = (Clay_String *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_String), CLAY__ALIGNMENT(Clay_String), arena)};\n}\nClay_String *Clay__StringArray_Add(Clay__StringArray *array, Clay_String item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__STRING_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nCLAY__TYPEDEF(Clay__WrappedTextLine, struct {\n    Clay_Dimensions dimensions;\n    Clay_String line;\n});\n\nClay__WrappedTextLine CLAY__WRAPPED_TEXT_LINE_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_define_slice,array_allocate,array_add,array_get TYPE=Clay__WrappedTextLine NAME=Clay__WrappedTextLineArray DEFAULT_VALUE=&CLAY__WRAPPED_TEXT_LINE_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__WrappedTextLineArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay__WrappedTextLine *internalArray;\n});\nCLAY__TYPEDEF(Clay__WrappedTextLineArraySlice, struct\n{\n\tint32_t length;\n\tClay__WrappedTextLine *internalArray;\n});\nClay__WrappedTextLineArray Clay__WrappedTextLineArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__WrappedTextLineArray){.capacity = capacity, .length = 0, .internalArray = (Clay__WrappedTextLine *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay__WrappedTextLine), CLAY__ALIGNMENT(Clay__WrappedTextLine), arena)};\n}\nClay__WrappedTextLine *Clay__WrappedTextLineArray_Add(Clay__WrappedTextLineArray *array, Clay__WrappedTextLine item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__WRAPPED_TEXT_LINE_DEFAULT;\n}\nClay__WrappedTextLine *Clay__WrappedTextLineArray_Get(Clay__WrappedTextLineArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__WRAPPED_TEXT_LINE_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nCLAY__TYPEDEF(Clay__TextElementData, struct {\n    Clay_String text;\n    Clay_Dimensions preferredDimensions;\n    int32_t elementIndex;\n    Clay__WrappedTextLineArraySlice wrappedLines;\n});\n\nClay__TextElementData CLAY__TEXT_ELEMENT_DATA_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_get,array_add TYPE=Clay__TextElementData NAME=Clay__TextElementDataArray DEFAULT_VALUE=&CLAY__TEXT_ELEMENT_DATA_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__TextElementDataArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay__TextElementData *internalArray;\n});\nClay__TextElementDataArray Clay__TextElementDataArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__TextElementDataArray){.capacity = capacity, .length = 0, .internalArray = (Clay__TextElementData *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay__TextElementData), CLAY__ALIGNMENT(Clay__TextElementData), arena)};\n}\nClay__TextElementData *Clay__TextElementDataArray_Get(Clay__TextElementDataArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__TEXT_ELEMENT_DATA_DEFAULT;\n}\nClay__TextElementData *Clay__TextElementDataArray_Add(Clay__TextElementDataArray *array, Clay__TextElementData item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__TEXT_ELEMENT_DATA_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_BorderElementConfig CLAY__BORDER_ELEMENT_CONFIG_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add TYPE=Clay_BorderElementConfig NAME=Clay__BorderElementConfigArray DEFAULT_VALUE=&CLAY__BORDER_ELEMENT_CONFIG_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__BorderElementConfigArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_BorderElementConfig *internalArray;\n});\nClay__BorderElementConfigArray Clay__BorderElementConfigArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__BorderElementConfigArray){.capacity = capacity, .length = 0, .internalArray = (Clay_BorderElementConfig *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_BorderElementConfig), CLAY__ALIGNMENT(Clay_BorderElementConfig), arena)};\n}\nClay_BorderElementConfig *Clay__BorderElementConfigArray_Add(Clay__BorderElementConfigArray *array, Clay_BorderElementConfig item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__BORDER_ELEMENT_CONFIG_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nCLAY__TYPEDEF(Clay__LayoutElementChildren, struct {\n    int32_t *elements;\n    uint16_t length;\n});\n\nCLAY__TYPEDEF(Clay_LayoutElement, struct {\n    union {\n        Clay__LayoutElementChildren children;\n        Clay__TextElementData *textElementData;\n    } childrenOrTextContent;\n    Clay_Dimensions dimensions;\n    Clay_Dimensions minDimensions;\n    Clay_LayoutConfig *layoutConfig;\n    Clay__ElementConfigArraySlice elementConfigs;\n    uint32_t configsEnabled;\n    uint32_t id;\n});\n\nClay_LayoutElement CLAY__LAYOUT_ELEMENT_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add,array_get TYPE=Clay_LayoutElement NAME=Clay_LayoutElementArray DEFAULT_VALUE=&CLAY__LAYOUT_ELEMENT_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay_LayoutElementArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_LayoutElement *internalArray;\n});\nClay_LayoutElementArray Clay_LayoutElementArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay_LayoutElementArray){.capacity = capacity, .length = 0, .internalArray = (Clay_LayoutElement *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_LayoutElement), CLAY__ALIGNMENT(Clay_LayoutElement), arena)};\n}\nClay_LayoutElement *Clay_LayoutElementArray_Add(Clay_LayoutElementArray *array, Clay_LayoutElement item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__LAYOUT_ELEMENT_DEFAULT;\n}\nClay_LayoutElement *Clay_LayoutElementArray_Get(Clay_LayoutElementArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__LAYOUT_ELEMENT_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\n// __GENERATED__ template array_define,array_allocate_pointer,array_add,array_get_value,array_remove_swapback TYPE=Clay_LayoutElement* NAME=Clay__LayoutElementPointerArray DEFAULT_VALUE=CLAY__NULL\n#pragma region generated\nCLAY__TYPEDEF(Clay__LayoutElementPointerArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_LayoutElement* *internalArray;\n});\nClay__LayoutElementPointerArray Clay__LayoutElementPointerArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__LayoutElementPointerArray){.capacity = capacity, .length = 0, .internalArray = (Clay_LayoutElement* *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_LayoutElement*), CLAY__POINTER_ALIGNMENT, arena)};\n}\nClay_LayoutElement* *Clay__LayoutElementPointerArray_Add(Clay__LayoutElementPointerArray *array, Clay_LayoutElement* item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn CLAY__NULL;\n}\nClay_LayoutElement* Clay__LayoutElementPointerArray_Get(Clay__LayoutElementPointerArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? array->internalArray[index] : CLAY__NULL;\n}\nClay_LayoutElement* Clay__LayoutElementPointerArray_RemoveSwapback(Clay__LayoutElementPointerArray *array, int32_t index) {\n\tif (Clay__Array_RangeCheck(index, array->length)) {\n\t\tarray->length--;\n\t\tClay_LayoutElement* removed = array->internalArray[index];\n\t\tarray->internalArray[index] = array->internalArray[array->length];\n\t\treturn removed;\n\t}\n\treturn CLAY__NULL;\n}\n#pragma endregion\n// __GENERATED__ template\n\nClay_RenderCommand CLAY__RENDER_COMMAND_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_allocate,array_add,array_get TYPE=Clay_RenderCommand NAME=Clay_RenderCommandArray DEFAULT_VALUE=&CLAY__RENDER_COMMAND_DEFAULT\n#pragma region generated\nClay_RenderCommandArray Clay_RenderCommandArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay_RenderCommandArray){.capacity = capacity, .length = 0, .internalArray = (Clay_RenderCommand *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_RenderCommand), CLAY__ALIGNMENT(Clay_RenderCommand), arena)};\n}\nClay_RenderCommand *Clay_RenderCommandArray_Add(Clay_RenderCommandArray *array, Clay_RenderCommand item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__RENDER_COMMAND_DEFAULT;\n}\nClay_RenderCommand *Clay_RenderCommandArray_Get(Clay_RenderCommandArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__RENDER_COMMAND_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nCLAY__TYPEDEF(Clay__ScrollContainerDataInternal, struct {\n    Clay_LayoutElement *layoutElement;\n    Clay_BoundingBox boundingBox;\n    Clay_Dimensions contentSize;\n    Clay_Vector2 scrollOrigin;\n    Clay_Vector2 pointerOrigin;\n    Clay_Vector2 scrollMomentum;\n    Clay_Vector2 scrollPosition;\n    Clay_Vector2 previousDelta;\n    float momentumTime;\n    uint32_t elementId;\n    bool openThisFrame;\n    bool pointerScrollActive;\n});\n\nClay__ScrollContainerDataInternal CLAY__SCROLL_CONTAINER_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add,array_get TYPE=Clay__ScrollContainerDataInternal NAME=Clay__ScrollContainerDataInternalArray DEFAULT_VALUE=&CLAY__SCROLL_CONTAINER_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__ScrollContainerDataInternalArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay__ScrollContainerDataInternal *internalArray;\n});\nClay__ScrollContainerDataInternalArray Clay__ScrollContainerDataInternalArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__ScrollContainerDataInternalArray){.capacity = capacity, .length = 0, .internalArray = (Clay__ScrollContainerDataInternal *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay__ScrollContainerDataInternal), CLAY__ALIGNMENT(Clay__ScrollContainerDataInternal), arena)};\n}\nClay__ScrollContainerDataInternal *Clay__ScrollContainerDataInternalArray_Add(Clay__ScrollContainerDataInternalArray *array, Clay__ScrollContainerDataInternal item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__SCROLL_CONTAINER_DEFAULT;\n}\nClay__ScrollContainerDataInternal *Clay__ScrollContainerDataInternalArray_Get(Clay__ScrollContainerDataInternalArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__SCROLL_CONTAINER_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\n// __GENERATED__ template array_remove_swapback TYPE=Clay__ScrollContainerDataInternal NAME=Clay__ScrollContainerDataInternalArray DEFAULT_VALUE=CLAY__SCROLL_CONTAINER_DEFAULT\n#pragma region generated\nClay__ScrollContainerDataInternal Clay__ScrollContainerDataInternalArray_RemoveSwapback(Clay__ScrollContainerDataInternalArray *array, int32_t index) {\n\tif (Clay__Array_RangeCheck(index, array->length)) {\n\t\tarray->length--;\n\t\tClay__ScrollContainerDataInternal removed = array->internalArray[index];\n\t\tarray->internalArray[index] = array->internalArray[array->length];\n\t\treturn removed;\n\t}\n\treturn CLAY__SCROLL_CONTAINER_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nCLAY__TYPEDEF(Clay__DebugElementData, struct {\n    bool collision;\n    bool collapsed;\n});\n\nClay__DebugElementData CLAY__DEBUG_ELEMENT_DATA_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add,array_get TYPE=Clay__DebugElementData NAME=Clay__DebugElementDataArray DEFAULT_VALUE=&CLAY__DEBUG_ELEMENT_DATA_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__DebugElementDataArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay__DebugElementData *internalArray;\n});\nClay__DebugElementDataArray Clay__DebugElementDataArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__DebugElementDataArray){.capacity = capacity, .length = 0, .internalArray = (Clay__DebugElementData *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay__DebugElementData), CLAY__ALIGNMENT(Clay__DebugElementData), arena)};\n}\nClay__DebugElementData *Clay__DebugElementDataArray_Add(Clay__DebugElementDataArray *array, Clay__DebugElementData item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__DEBUG_ELEMENT_DATA_DEFAULT;\n}\nClay__DebugElementData *Clay__DebugElementDataArray_Get(Clay__DebugElementDataArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__DEBUG_ELEMENT_DATA_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nCLAY__TYPEDEF(Clay_LayoutElementHashMapItem, struct { // todo get this struct into a single cache line\n    Clay_BoundingBox boundingBox;\n    Clay_ElementId elementId;\n    Clay_LayoutElement* layoutElement;\n    void (*onHoverFunction)(Clay_ElementId elementId, Clay_PointerData pointerInfo, intptr_t userData);\n    intptr_t hoverFunctionUserData;\n    int32_t nextIndex;\n    uint32_t generation;\n    Clay__DebugElementData *debugData;\n});\n\nClay_LayoutElementHashMapItem CLAY__LAYOUT_ELEMENT_HASH_MAP_ITEM_DEFAULT = { .layoutElement = &CLAY__LAYOUT_ELEMENT_DEFAULT };\n\n// __GENERATED__ template array_define,array_allocate,array_get,array_add TYPE=Clay_LayoutElementHashMapItem NAME=Clay__LayoutElementHashMapItemArray DEFAULT_VALUE=&CLAY__LAYOUT_ELEMENT_HASH_MAP_ITEM_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__LayoutElementHashMapItemArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay_LayoutElementHashMapItem *internalArray;\n});\nClay__LayoutElementHashMapItemArray Clay__LayoutElementHashMapItemArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__LayoutElementHashMapItemArray){.capacity = capacity, .length = 0, .internalArray = (Clay_LayoutElementHashMapItem *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay_LayoutElementHashMapItem), CLAY__ALIGNMENT(Clay_LayoutElementHashMapItem), arena)};\n}\nClay_LayoutElementHashMapItem *Clay__LayoutElementHashMapItemArray_Get(Clay__LayoutElementHashMapItemArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__LAYOUT_ELEMENT_HASH_MAP_ITEM_DEFAULT;\n}\nClay_LayoutElementHashMapItem *Clay__LayoutElementHashMapItemArray_Add(Clay__LayoutElementHashMapItemArray *array, Clay_LayoutElementHashMapItem item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__LAYOUT_ELEMENT_HASH_MAP_ITEM_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nCLAY__TYPEDEF(Clay__MeasuredWord, struct {\n    int32_t startOffset;\n    int32_t length;\n    float width;\n    int32_t next;\n});\n\nClay__MeasuredWord CLAY__MEASURED_WORD_DEFAULT = { .next = -1 };\n\n// __GENERATED__ template array_define,array_allocate,array_get,array_set,array_add TYPE=Clay__MeasuredWord NAME=Clay__MeasuredWordArray DEFAULT_VALUE=&CLAY__MEASURED_WORD_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__MeasuredWordArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay__MeasuredWord *internalArray;\n});\nClay__MeasuredWordArray Clay__MeasuredWordArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__MeasuredWordArray){.capacity = capacity, .length = 0, .internalArray = (Clay__MeasuredWord *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay__MeasuredWord), CLAY__ALIGNMENT(Clay__MeasuredWord), arena)};\n}\nClay__MeasuredWord *Clay__MeasuredWordArray_Get(Clay__MeasuredWordArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__MEASURED_WORD_DEFAULT;\n}\nvoid Clay__MeasuredWordArray_Set(Clay__MeasuredWordArray *array, int32_t index, Clay__MeasuredWord value) {\n\tif (Clay__Array_RangeCheck(index, array->capacity)) {\n\t\tarray->internalArray[index] = value;\n\t\tarray->length = index < array->length ? array->length : index + 1;\n\t}\n}\nClay__MeasuredWord *Clay__MeasuredWordArray_Add(Clay__MeasuredWordArray *array, Clay__MeasuredWord item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__MEASURED_WORD_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nCLAY__TYPEDEF(Clay__MeasureTextCacheItem, struct {\n    Clay_Dimensions unwrappedDimensions;\n    int32_t measuredWordsStartIndex;\n    // Hash map data\n    uint32_t id;\n    int32_t nextIndex;\n    uint32_t generation;\n});\n\nClay__MeasureTextCacheItem CLAY__MEASURE_TEXT_CACHE_ITEM_DEFAULT = { .measuredWordsStartIndex = -1 };\n\n// __GENERATED__ template array_define,array_allocate,array_get,array_add,array_set TYPE=Clay__MeasureTextCacheItem NAME=Clay__MeasureTextCacheItemArray DEFAULT_VALUE=&CLAY__MEASURE_TEXT_CACHE_ITEM_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__MeasureTextCacheItemArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay__MeasureTextCacheItem *internalArray;\n});\nClay__MeasureTextCacheItemArray Clay__MeasureTextCacheItemArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__MeasureTextCacheItemArray){.capacity = capacity, .length = 0, .internalArray = (Clay__MeasureTextCacheItem *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay__MeasureTextCacheItem), CLAY__ALIGNMENT(Clay__MeasureTextCacheItem), arena)};\n}\nClay__MeasureTextCacheItem *Clay__MeasureTextCacheItemArray_Get(Clay__MeasureTextCacheItemArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__MEASURE_TEXT_CACHE_ITEM_DEFAULT;\n}\nClay__MeasureTextCacheItem *Clay__MeasureTextCacheItemArray_Add(Clay__MeasureTextCacheItemArray *array, Clay__MeasureTextCacheItem item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__MEASURE_TEXT_CACHE_ITEM_DEFAULT;\n}\nvoid Clay__MeasureTextCacheItemArray_Set(Clay__MeasureTextCacheItemArray *array, int32_t index, Clay__MeasureTextCacheItem value) {\n\tif (Clay__Array_RangeCheck(index, array->capacity)) {\n\t\tarray->internalArray[index] = value;\n\t\tarray->length = index < array->length ? array->length : index + 1;\n\t}\n}\n#pragma endregion\n// __GENERATED__ template\n\n// __GENERATED__ template array_define,array_allocate,array_get_value,array_add_value,array_set,array_remove_swapback TYPE=int32_t NAME=Clay__int32_tArray DEFAULT_VALUE=-1\n#pragma region generated\nCLAY__TYPEDEF(Clay__int32_tArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tint32_t *internalArray;\n});\nClay__int32_tArray Clay__int32_tArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__int32_tArray){.capacity = capacity, .length = 0, .internalArray = (int32_t *)Clay__Array_Allocate_Arena(capacity, sizeof(int32_t), CLAY__ALIGNMENT(int32_t), arena)};\n}\nint32_t Clay__int32_tArray_Get(Clay__int32_tArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? array->internalArray[index] : -1;\n}\nvoid Clay__int32_tArray_Add(Clay__int32_tArray *array, int32_t item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t}\n}\nvoid Clay__int32_tArray_Set(Clay__int32_tArray *array, int32_t index, int32_t value) {\n\tif (Clay__Array_RangeCheck(index, array->capacity)) {\n\t\tarray->internalArray[index] = value;\n\t\tarray->length = index < array->length ? array->length : index + 1;\n\t}\n}\nint32_t Clay__int32_tArray_RemoveSwapback(Clay__int32_tArray *array, int32_t index) {\n\tif (Clay__Array_RangeCheck(index, array->length)) {\n\t\tarray->length--;\n\t\tint32_t removed = array->internalArray[index];\n\t\tarray->internalArray[index] = array->internalArray[array->length];\n\t\treturn removed;\n\t}\n\treturn -1;\n}\n#pragma endregion\n// __GENERATED__ template\n\nCLAY__TYPEDEF(Clay__LayoutElementTreeNode, struct {\n    Clay_LayoutElement *layoutElement;\n    Clay_Vector2 position;\n    Clay_Vector2 nextChildOffset;\n});\n\nClay__LayoutElementTreeNode CLAY__LAYOUT_ELEMENT_TREE_NODE_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add,array_get TYPE=Clay__LayoutElementTreeNode NAME=Clay__LayoutElementTreeNodeArray DEFAULT_VALUE=&CLAY__LAYOUT_ELEMENT_TREE_NODE_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__LayoutElementTreeNodeArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay__LayoutElementTreeNode *internalArray;\n});\nClay__LayoutElementTreeNodeArray Clay__LayoutElementTreeNodeArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__LayoutElementTreeNodeArray){.capacity = capacity, .length = 0, .internalArray = (Clay__LayoutElementTreeNode *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay__LayoutElementTreeNode), CLAY__ALIGNMENT(Clay__LayoutElementTreeNode), arena)};\n}\nClay__LayoutElementTreeNode *Clay__LayoutElementTreeNodeArray_Add(Clay__LayoutElementTreeNodeArray *array, Clay__LayoutElementTreeNode item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__LAYOUT_ELEMENT_TREE_NODE_DEFAULT;\n}\nClay__LayoutElementTreeNode *Clay__LayoutElementTreeNodeArray_Get(Clay__LayoutElementTreeNodeArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__LAYOUT_ELEMENT_TREE_NODE_DEFAULT;\n}\n#pragma endregion\n// __GENERATED__ template\n\nCLAY__TYPEDEF(Clay__LayoutElementTreeRoot, struct {\n    int32_t layoutElementIndex;\n    uint32_t parentId; // This can be zero in the case of the root layout tree\n    uint32_t clipElementId; // This can be zero if there is no clip element\n    int32_t zIndex;\n    Clay_Vector2 pointerOffset; // Only used when scroll containers are managed externally\n});\n\nClay__LayoutElementTreeRoot CLAY__LAYOUT_ELEMENT_TREE_ROOT_DEFAULT = CLAY__DEFAULT_STRUCT;\n\n// __GENERATED__ template array_define,array_allocate,array_add,array_get,array_set TYPE=Clay__LayoutElementTreeRoot NAME=Clay__LayoutElementTreeRootArray DEFAULT_VALUE=&CLAY__LAYOUT_ELEMENT_TREE_ROOT_DEFAULT\n#pragma region generated\nCLAY__TYPEDEF(Clay__LayoutElementTreeRootArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tClay__LayoutElementTreeRoot *internalArray;\n});\nClay__LayoutElementTreeRootArray Clay__LayoutElementTreeRootArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__LayoutElementTreeRootArray){.capacity = capacity, .length = 0, .internalArray = (Clay__LayoutElementTreeRoot *)Clay__Array_Allocate_Arena(capacity, sizeof(Clay__LayoutElementTreeRoot), CLAY__ALIGNMENT(Clay__LayoutElementTreeRoot), arena)};\n}\nClay__LayoutElementTreeRoot *Clay__LayoutElementTreeRootArray_Add(Clay__LayoutElementTreeRootArray *array, Clay__LayoutElementTreeRoot item) {\n\tif (Clay__Array_AddCapacityCheck(array->length, array->capacity)) {\n\t\tarray->internalArray[array->length++] = item;\n\t\treturn &array->internalArray[array->length - 1];\n\t}\n\treturn &CLAY__LAYOUT_ELEMENT_TREE_ROOT_DEFAULT;\n}\nClay__LayoutElementTreeRoot *Clay__LayoutElementTreeRootArray_Get(Clay__LayoutElementTreeRootArray *array, int32_t index) {\n    return Clay__Array_RangeCheck(index, array->length) ? &array->internalArray[index] : &CLAY__LAYOUT_ELEMENT_TREE_ROOT_DEFAULT;\n}\nvoid Clay__LayoutElementTreeRootArray_Set(Clay__LayoutElementTreeRootArray *array, int32_t index, Clay__LayoutElementTreeRoot value) {\n\tif (Clay__Array_RangeCheck(index, array->capacity)) {\n\t\tarray->internalArray[index] = value;\n\t\tarray->length = index < array->length ? array->length : index + 1;\n\t}\n}\n#pragma endregion\n// __GENERATED__ template\n\n// __GENERATED__ template array_define,array_allocate TYPE=uint8_t NAME=Clay__CharArray DEFAULT_VALUE=0\n#pragma region generated\nCLAY__TYPEDEF(Clay__CharArray, struct\n{\n\tint32_t capacity;\n\tint32_t length;\n\tuint8_t *internalArray;\n});\nClay__CharArray Clay__CharArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    return CLAY__INIT(Clay__CharArray){.capacity = capacity, .length = 0, .internalArray = (uint8_t *)Clay__Array_Allocate_Arena(capacity, sizeof(uint8_t), CLAY__ALIGNMENT(uint8_t), arena)};\n}\n#pragma endregion\n// __GENERATED__ template\n\nstruct Clay_Context {\n    int32_t maxElementCount;\n    int32_t maxMeasureTextCacheWordCount;\n    bool warningsEnabled;\n    Clay_ErrorHandler errorHandler;\n    Clay_BooleanWarnings booleanWarnings;\n    Clay__WarningArray warnings;\n\n    Clay_PointerData pointerInfo;\n    Clay_Dimensions layoutDimensions;\n    Clay_ElementId dynamicElementIndexBaseHash;\n    uint32_t dynamicElementIndex;\n    bool debugModeEnabled;\n    bool disableCulling;\n    bool externalScrollHandlingEnabled;\n    uint32_t debugSelectedElementId;\n    uint32_t generation;\n    uintptr_t arenaResetOffset;\n    Clay_Arena internalArena;\n    // Layout Elements / Render Commands\n    Clay_LayoutElementArray layoutElements;\n    Clay_RenderCommandArray renderCommands;\n    Clay__int32_tArray openLayoutElementStack;\n    Clay__int32_tArray layoutElementChildren;\n    Clay__int32_tArray layoutElementChildrenBuffer;\n    Clay__TextElementDataArray textElementData;\n    Clay__LayoutElementPointerArray imageElementPointers;\n    Clay__int32_tArray reusableElementIndexBuffer;\n    Clay__int32_tArray layoutElementClipElementIds;\n    // Configs\n    Clay__LayoutConfigArray layoutConfigs;\n    Clay__ElementConfigArray elementConfigBuffer;\n    Clay__ElementConfigArray elementConfigs;\n    Clay__RectangleElementConfigArray rectangleElementConfigs;\n    Clay__TextElementConfigArray textElementConfigs;\n    Clay__ImageElementConfigArray imageElementConfigs;\n    Clay__FloatingElementConfigArray floatingElementConfigs;\n    Clay__ScrollElementConfigArray scrollElementConfigs;\n    Clay__CustomElementConfigArray customElementConfigs;\n    Clay__BorderElementConfigArray borderElementConfigs;\n    // Misc Data Structures\n    Clay__StringArray layoutElementIdStrings;\n    Clay__WrappedTextLineArray wrappedTextLines;\n    Clay__LayoutElementTreeNodeArray layoutElementTreeNodeArray1;\n    Clay__LayoutElementTreeRootArray layoutElementTreeRoots;\n    Clay__LayoutElementHashMapItemArray layoutElementsHashMapInternal;\n    Clay__int32_tArray layoutElementsHashMap;\n    Clay__MeasureTextCacheItemArray measureTextHashMapInternal;\n    Clay__int32_tArray measureTextHashMapInternalFreeList;\n    Clay__int32_tArray measureTextHashMap;\n    Clay__MeasuredWordArray measuredWords;\n    Clay__int32_tArray measuredWordsFreeList;\n    Clay__int32_tArray openClipElementStack;\n    Clay__ElementIdArray pointerOverIds;\n    Clay__ScrollContainerDataInternalArray scrollContainerDatas;\n    Clay__BoolArray treeNodeVisited;\n    Clay__CharArray dynamicStringData;\n    Clay__DebugElementDataArray debugElementData;\n};\n\nstruct Clay__AlignClay_Context {\n    char c;\n    Clay_Context x;\n};\ntypedef struct {\n    Clay_Context wrapped;\n} Clay__Clay_ContextWrapper;\n\nClay_Context* Clay__Context_Allocate_Arena(Clay_Arena *arena) {\n    uint32_t alignment = CLAY__ALIGNMENT(Clay_Context);\n    size_t totalSizeBytes = sizeof(Clay_Context);\n    uintptr_t nextAllocAddress = arena->nextAllocation + (uintptr_t)arena->memory;\n    uintptr_t arenaOffsetAligned = nextAllocAddress + (alignment - (nextAllocAddress & alignment));\n    arenaOffsetAligned -= (uintptr_t)arena->memory;\n    if (arenaOffsetAligned + totalSizeBytes > arena->capacity)\n    {\n        return NULL;\n    }\n    arena->nextAllocation = arenaOffsetAligned + totalSizeBytes;\n    return (Clay_Context*)((uintptr_t)arena->memory + arenaOffsetAligned);\n}\n\nClay_String Clay__WriteStringToCharBuffer(Clay__CharArray *buffer, Clay_String string) {\n    for (int32_t i = 0; i < string.length; i++) {\n        buffer->internalArray[buffer->length + i] = string.chars[i];\n    }\n    buffer->length += string.length;\n    return CLAY__INIT(Clay_String) { .length = string.length, .chars = (const char *)(buffer->internalArray + buffer->length - string.length) };\n}\n\n#ifdef CLAY_WASM\n    __attribute__((import_module(\"clay\"), import_name(\"measureTextFunction\"))) Clay_Dimensions Clay__MeasureText(Clay_String *text, Clay_TextElementConfig *config);\n    __attribute__((import_module(\"clay\"), import_name(\"queryScrollOffsetFunction\"))) Clay_Vector2 Clay__QueryScrollOffset(uint32_t elementId);\n#else\n    Clay_Dimensions (*Clay__MeasureText)(Clay_String *text, Clay_TextElementConfig *config);\n    Clay_Vector2 (*Clay__QueryScrollOffset)(uint32_t elementId);\n#endif\n\nClay_LayoutElement* Clay__GetOpenLayoutElement(void) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    return Clay_LayoutElementArray_Get(&context->layoutElements, Clay__int32_tArray_Get(&context->openLayoutElementStack, context->openLayoutElementStack.length - 1));\n}\n\nuint32_t Clay__GetParentElementId(void) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    return Clay_LayoutElementArray_Get(&context->layoutElements, Clay__int32_tArray_Get(&context->openLayoutElementStack, context->openLayoutElementStack.length - 2))->id;\n}\n\nbool Clay__ElementHasConfig(Clay_LayoutElement *element, Clay__ElementConfigType type) {\n    return (element->configsEnabled & type);\n}\n\nClay_ElementConfigUnion Clay__FindElementConfigWithType(Clay_LayoutElement *element, Clay__ElementConfigType type) {\n    for (int32_t i = 0; i < element->elementConfigs.length; i++) {\n        Clay_ElementConfig *config = Clay__ElementConfigArraySlice_Get(&element->elementConfigs, i);\n        if (config->type == type) {\n            return config->config;\n        }\n    }\n    return CLAY__INIT(Clay_ElementConfigUnion) { NULL };\n}\n\nClay_ElementId Clay__HashNumber(const uint32_t offset, const uint32_t seed) {\n    uint32_t hash = seed;\n    hash += (offset + 48);\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    hash += (hash << 3);\n    hash ^= (hash >> 11);\n    hash += (hash << 15);\n    return CLAY__INIT(Clay_ElementId) { .id = hash + 1, .offset = offset, .baseId = seed, .stringId = CLAY__STRING_DEFAULT }; // Reserve the hash result of zero as \"null id\"\n}\n\nClay_ElementId Clay__HashString(Clay_String key, const uint32_t offset, const uint32_t seed) {\n    uint32_t hash = 0;\n    uint32_t base = seed;\n\n    for (int32_t i = 0; i < key.length; i++) {\n        base += key.chars[i];\n        base += (base << 10);\n        base ^= (base >> 6);\n    }\n    hash = base;\n    hash += offset;\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    hash += (hash << 3);\n    base += (base << 3);\n    hash ^= (hash >> 11);\n    base ^= (base >> 11);\n    hash += (hash << 15);\n    base += (base << 15);\n    return CLAY__INIT(Clay_ElementId) { .id = hash + 1, .offset = offset, .baseId = base + 1, .stringId = key }; // Reserve the hash result of zero as \"null id\"\n}\n\nClay_ElementId Clay__Rehash(Clay_ElementId elementId, uint32_t number) {\n    uint32_t id = elementId.baseId;\n    id += number;\n    id += (id << 10);\n    id ^= (id >> 6);\n\n    id += (id << 3);\n    id ^= (id >> 11);\n    id += (id << 15);\n    return CLAY__INIT(Clay_ElementId) { .id = id, .offset = number, .baseId = elementId.baseId, .stringId = elementId.stringId };\n}\n\nuint32_t Clay__RehashWithNumber(uint32_t id, uint32_t number) {\n    id += number;\n    id += (id << 10);\n    id ^= (id >> 6);\n\n    id += (id << 3);\n    id ^= (id >> 11);\n    id += (id << 15);\n    return id;\n}\n\nuint32_t Clay__HashTextWithConfig(Clay_String *text, Clay_TextElementConfig *config) {\n    uint32_t hash = 0;\n    uintptr_t pointerAsNumber = (uintptr_t)text->chars;\n\n    hash += pointerAsNumber;\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    hash += text->length;\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    hash += config->fontId;\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    hash += config->fontSize;\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    hash += config->lineHeight;\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    hash += config->letterSpacing;\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    hash += config->wrapMode;\n    hash += (hash << 10);\n    hash ^= (hash >> 6);\n\n    hash += (hash << 3);\n    hash ^= (hash >> 11);\n    hash += (hash << 15);\n    return hash + 1; // Reserve the hash result of zero as \"null id\"\n}\n\nClay__MeasuredWord *Clay__AddMeasuredWord(Clay__MeasuredWord word, Clay__MeasuredWord *previousWord) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->measuredWordsFreeList.length > 0) {\n        uint32_t newItemIndex = Clay__int32_tArray_Get(&context->measuredWordsFreeList, (int)context->measuredWordsFreeList.length - 1);\n        context->measuredWordsFreeList.length--;\n        Clay__MeasuredWordArray_Set(&context->measuredWords, (int)newItemIndex, word);\n        previousWord->next = (int32_t)newItemIndex;\n        return Clay__MeasuredWordArray_Get(&context->measuredWords, (int)newItemIndex);\n    } else {\n        previousWord->next = (int32_t)context->measuredWords.length;\n        return Clay__MeasuredWordArray_Add(&context->measuredWords, word);\n    }\n}\n\nClay__MeasureTextCacheItem *Clay__MeasureTextCached(Clay_String *text, Clay_TextElementConfig *config) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    #ifndef CLAY_WASM\n    if (!Clay__MeasureText) {\n        context->errorHandler.errorHandlerFunction(CLAY__INIT(Clay_ErrorData) {\n            .errorType = CLAY_ERROR_TYPE_TEXT_MEASUREMENT_FUNCTION_NOT_PROVIDED,\n            .errorText = CLAY_STRING(\"Clay's internal MeasureText function is null. You may have forgotten to call Clay_SetMeasureTextFunction(), or passed a NULL function pointer by mistake.\"),\n            .userData = context->errorHandler.userData });\n        return NULL;\n    }\n    #endif\n    uint32_t id = Clay__HashTextWithConfig(text, config);\n    uint32_t hashBucket = id % (context->maxMeasureTextCacheWordCount / 32);\n    int32_t elementIndexPrevious = 0;\n    int32_t elementIndex = context->measureTextHashMap.internalArray[hashBucket];\n    while (elementIndex != 0) {\n        Clay__MeasureTextCacheItem *hashEntry = Clay__MeasureTextCacheItemArray_Get(&context->measureTextHashMapInternal, elementIndex);\n        if (hashEntry->id == id) {\n            hashEntry->generation = context->generation;\n            return hashEntry;\n        }\n        // This element hasn't been seen in a few frames, delete the hash map item\n        if (context->generation - hashEntry->generation > 2) {\n            // Add all the measured words that were included in this measurement to the freelist\n            int32_t nextWordIndex = hashEntry->measuredWordsStartIndex;\n            while (nextWordIndex != -1) {\n                Clay__MeasuredWord *measuredWord = Clay__MeasuredWordArray_Get(&context->measuredWords, nextWordIndex);\n                Clay__int32_tArray_Add(&context->measuredWordsFreeList, nextWordIndex);\n                nextWordIndex = measuredWord->next;\n            }\n\n            int32_t nextIndex = hashEntry->nextIndex;\n            Clay__MeasureTextCacheItemArray_Set(&context->measureTextHashMapInternal, elementIndex, CLAY__INIT(Clay__MeasureTextCacheItem) { .measuredWordsStartIndex = -1 });\n            Clay__int32_tArray_Add(&context->measureTextHashMapInternalFreeList, elementIndex);\n            if (elementIndexPrevious == 0) {\n                context->measureTextHashMap.internalArray[hashBucket] = nextIndex;\n            } else {\n                Clay__MeasureTextCacheItem *previousHashEntry = Clay__MeasureTextCacheItemArray_Get(&context->measureTextHashMapInternal, elementIndexPrevious);\n                previousHashEntry->nextIndex = nextIndex;\n            }\n            elementIndex = nextIndex;\n        } else {\n            elementIndexPrevious = elementIndex;\n            elementIndex = hashEntry->nextIndex;\n        }\n    }\n\n    int32_t newItemIndex = 0;\n    Clay__MeasureTextCacheItem newCacheItem = { .measuredWordsStartIndex = -1, .id = id, .generation = context->generation };\n    Clay__MeasureTextCacheItem *measured = NULL;\n    if (context->measureTextHashMapInternalFreeList.length > 0) {\n        newItemIndex = Clay__int32_tArray_Get(&context->measureTextHashMapInternalFreeList, context->measureTextHashMapInternalFreeList.length - 1);\n        context->measureTextHashMapInternalFreeList.length--;\n        Clay__MeasureTextCacheItemArray_Set(&context->measureTextHashMapInternal, newItemIndex, newCacheItem);\n        measured = Clay__MeasureTextCacheItemArray_Get(&context->measureTextHashMapInternal, newItemIndex);\n    } else {\n        if (context->measureTextHashMapInternal.length == context->measureTextHashMapInternal.capacity - 1) {\n            if (context->booleanWarnings.maxTextMeasureCacheExceeded) {\n                context->errorHandler.errorHandlerFunction(CLAY__INIT(Clay_ErrorData) {\n                        .errorType = CLAY_ERROR_TYPE_ELEMENTS_CAPACITY_EXCEEDED,\n                        .errorText = CLAY_STRING(\"Clay ran out of capacity while attempting to measure text elements. Try using Clay_SetMaxElementCount() with a higher value.\"),\n                        .userData = context->errorHandler.userData });\n                context->booleanWarnings.maxTextMeasureCacheExceeded = true;\n            }\n            return &CLAY__MEASURE_TEXT_CACHE_ITEM_DEFAULT;\n        }\n        measured = Clay__MeasureTextCacheItemArray_Add(&context->measureTextHashMapInternal, newCacheItem);\n        newItemIndex = context->measureTextHashMapInternal.length - 1;\n    }\n\n    int32_t start = 0;\n    int32_t end = 0;\n    float measuredWidth = 0;\n    float measuredHeight = 0;\n    float spaceWidth = Clay__MeasureText(&CLAY__SPACECHAR, config).width;\n    Clay__MeasuredWord tempWord = { .next = -1 };\n    Clay__MeasuredWord *previousWord = &tempWord;\n    while (end < text->length) {\n        if (context->measuredWords.length == context->measuredWords.capacity - 1) {\n            if (!context->booleanWarnings.maxTextMeasureCacheExceeded) {\n                context->errorHandler.errorHandlerFunction(CLAY__INIT(Clay_ErrorData) {\n                    .errorType = CLAY_ERROR_TYPE_TEXT_MEASUREMENT_CAPACITY_EXCEEDED,\n                    .errorText = CLAY_STRING(\"Clay has run out of space in it's internal text measurement cache. Try using Clay_SetMaxMeasureTextCacheWordCount() (default 16384, with 1 unit storing 1 measured word).\"),\n                    .userData = context->errorHandler.userData });\n                context->booleanWarnings.maxTextMeasureCacheExceeded = true;\n            }\n            return &CLAY__MEASURE_TEXT_CACHE_ITEM_DEFAULT;\n        }\n        char current = text->chars[end];\n        if (current == ' ' || current == '\\n') {\n            int32_t length = end - start;\n            Clay_String word = { .length = length, .chars = &text->chars[start] };\n            Clay_Dimensions dimensions = Clay__MeasureText(&word, config);\n            if (current == ' ') {\n                dimensions.width += spaceWidth;\n                previousWord = Clay__AddMeasuredWord(CLAY__INIT(Clay__MeasuredWord) { .startOffset = start, .length = length + 1, .width = dimensions.width, .next = -1 }, previousWord);\n            }\n            if (current == '\\n') {\n                if (length > 1) {\n                    previousWord = Clay__AddMeasuredWord(CLAY__INIT(Clay__MeasuredWord) { .startOffset = start, .length = length, .width = dimensions.width, .next = -1 }, previousWord);\n                }\n                previousWord = Clay__AddMeasuredWord(CLAY__INIT(Clay__MeasuredWord) { .startOffset = end + 1, .length = 0, .width = 0, .next = -1 }, previousWord);\n            }\n            measuredWidth += dimensions.width;\n            measuredHeight = dimensions.height;\n            start = end + 1;\n        }\n        end++;\n    }\n    if (end - start > 0) {\n        Clay_String lastWord = { .length = end - start, .chars = &text->chars[start] };\n        Clay_Dimensions dimensions = Clay__MeasureText(&lastWord, config);\n        Clay__AddMeasuredWord(CLAY__INIT(Clay__MeasuredWord) { .startOffset = start, .length = end - start, .width = dimensions.width, .next = -1 }, previousWord);\n        measuredWidth += dimensions.width;\n        measuredHeight = dimensions.height;\n    }\n    measured->measuredWordsStartIndex = tempWord.next;\n    measured->unwrappedDimensions.width = measuredWidth;\n    measured->unwrappedDimensions.height = measuredHeight;\n\n    if (elementIndexPrevious != 0) {\n        Clay__MeasureTextCacheItemArray_Get(&context->measureTextHashMapInternal, elementIndexPrevious)->nextIndex = newItemIndex;\n    } else {\n        context->measureTextHashMap.internalArray[hashBucket] = newItemIndex;\n    }\n    return measured;\n}\n\nbool Clay__PointIsInsideRect(Clay_Vector2 point, Clay_BoundingBox rect) {\n    return point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height;\n}\n\nClay_LayoutElementHashMapItem* Clay__AddHashMapItem(Clay_ElementId elementId, Clay_LayoutElement* layoutElement) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->layoutElementsHashMapInternal.length == context->layoutElementsHashMapInternal.capacity - 1) {\n        return NULL;\n    }\n    Clay_LayoutElementHashMapItem item = { .elementId = elementId, .layoutElement = layoutElement, .nextIndex = -1, .generation = context->generation + 1 };\n    uint32_t hashBucket = elementId.id % context->layoutElementsHashMap.capacity;\n    int32_t hashItemPrevious = -1;\n    int32_t hashItemIndex = context->layoutElementsHashMap.internalArray[hashBucket];\n    while (hashItemIndex != -1) { // Just replace collision, not a big deal - leave it up to the end user\n        Clay_LayoutElementHashMapItem *hashItem = Clay__LayoutElementHashMapItemArray_Get(&context->layoutElementsHashMapInternal, hashItemIndex);\n        if (hashItem->elementId.id == elementId.id) { // Collision - resolve based on generation\n            item.nextIndex = hashItem->nextIndex;\n            if (hashItem->generation <= context->generation) { // First collision - assume this is the \"same\" element\n                hashItem->generation = context->generation + 1;\n                hashItem->layoutElement = layoutElement;\n                hashItem->debugData->collision = false;\n            } else { // Multiple collisions this frame - two elements have the same ID\n                context->errorHandler.errorHandlerFunction(CLAY__INIT(Clay_ErrorData) {\n                    .errorType = CLAY_ERROR_TYPE_DUPLICATE_ID,\n                    .errorText = CLAY_STRING(\"An element with this ID was already previously declared during this layout.\"),\n                    .userData = context->errorHandler.userData });\n                if (context->debugModeEnabled) {\n                    hashItem->debugData->collision = true;\n                }\n            }\n            return hashItem;\n        }\n        hashItemPrevious = hashItemIndex;\n        hashItemIndex = hashItem->nextIndex;\n    }\n    Clay_LayoutElementHashMapItem *hashItem = Clay__LayoutElementHashMapItemArray_Add(&context->layoutElementsHashMapInternal, item);\n    hashItem->debugData = Clay__DebugElementDataArray_Add(&context->debugElementData, CLAY__INIT(Clay__DebugElementData) CLAY__DEFAULT_STRUCT);\n    if (hashItemPrevious != -1) {\n        Clay__LayoutElementHashMapItemArray_Get(&context->layoutElementsHashMapInternal, hashItemPrevious)->nextIndex = (int32_t)context->layoutElementsHashMapInternal.length - 1;\n    } else {\n        context->layoutElementsHashMap.internalArray[hashBucket] = (int32_t)context->layoutElementsHashMapInternal.length - 1;\n    }\n    return hashItem;\n}\n\nClay_LayoutElementHashMapItem *Clay__GetHashMapItem(uint32_t id) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    uint32_t hashBucket = id % context->layoutElementsHashMap.capacity;\n    int32_t elementIndex = context->layoutElementsHashMap.internalArray[hashBucket];\n    while (elementIndex != -1) {\n        Clay_LayoutElementHashMapItem *hashEntry = Clay__LayoutElementHashMapItemArray_Get(&context->layoutElementsHashMapInternal, elementIndex);\n        if (hashEntry->elementId.id == id) {\n            return hashEntry;\n        }\n        elementIndex = hashEntry->nextIndex;\n    }\n    return &CLAY__LAYOUT_ELEMENT_HASH_MAP_ITEM_DEFAULT;\n}\n\nvoid Clay__GenerateIdForAnonymousElement(Clay_LayoutElement *openLayoutElement) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    Clay_LayoutElement *parentElement = Clay_LayoutElementArray_Get(&context->layoutElements, Clay__int32_tArray_Get(&context->openLayoutElementStack, context->openLayoutElementStack.length - 2));\n    Clay_ElementId elementId = Clay__HashNumber(parentElement->childrenOrTextContent.children.length, parentElement->id);\n    openLayoutElement->id = elementId.id;\n    Clay__AddHashMapItem(elementId, openLayoutElement);\n    Clay__StringArray_Add(&context->layoutElementIdStrings, elementId.stringId);\n}\n\nvoid Clay__ElementPostConfiguration(void) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->booleanWarnings.maxElementsExceeded) {\n        return;\n    }\n    Clay_LayoutElement *openLayoutElement = Clay__GetOpenLayoutElement();\n    // ID\n    if (openLayoutElement->id == 0) {\n        Clay__GenerateIdForAnonymousElement(openLayoutElement);\n    }\n    // Layout Config\n    if (!openLayoutElement->layoutConfig) {\n        openLayoutElement->layoutConfig = &CLAY_LAYOUT_DEFAULT;\n    }\n\n    // Loop through element configs and handle special cases\n    openLayoutElement->elementConfigs.internalArray = &context->elementConfigs.internalArray[context->elementConfigs.length];\n    for (int32_t elementConfigIndex = 0; elementConfigIndex < openLayoutElement->elementConfigs.length; elementConfigIndex++) {\n        Clay_ElementConfig *config = Clay__ElementConfigArray_Add(&context->elementConfigs, *Clay__ElementConfigArray_Get(&context->elementConfigBuffer, context->elementConfigBuffer.length - openLayoutElement->elementConfigs.length + elementConfigIndex));\n        openLayoutElement->configsEnabled |= config->type;\n        switch (config->type) {\n            case CLAY__ELEMENT_CONFIG_TYPE_RECTANGLE:\n            case CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER: break;\n            case CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER: {\n                Clay_FloatingElementConfig *floatingConfig = config->config.floatingElementConfig;\n                // This looks dodgy but because of the auto generated root element the depth of the tree will always be at least 2 here\n                Clay_LayoutElement *hierarchicalParent = Clay_LayoutElementArray_Get(&context->layoutElements, Clay__int32_tArray_Get(&context->openLayoutElementStack, context->openLayoutElementStack.length - 2));\n                if (!hierarchicalParent) {\n                    break;\n                }\n                uint32_t clipElementId = 0;\n                if (floatingConfig->parentId == 0) {\n                    // If no parent id was specified, attach to the elements direct hierarchical parent\n                    Clay_FloatingElementConfig newConfig = *floatingConfig;\n                    newConfig.parentId = hierarchicalParent->id;\n                    floatingConfig = Clay__FloatingElementConfigArray_Add(&context->floatingElementConfigs, newConfig);\n                    config->config.floatingElementConfig = floatingConfig;\n                    if (context->openClipElementStack.length > 0) {\n                        clipElementId = Clay__int32_tArray_Get(&context->openClipElementStack, (int)context->openClipElementStack.length - 1);\n                    }\n                } else {\n                    Clay_LayoutElementHashMapItem *parentItem = Clay__GetHashMapItem(floatingConfig->parentId);\n                    if (!parentItem) {\n                        context->errorHandler.errorHandlerFunction(CLAY__INIT(Clay_ErrorData) {\n                            .errorType = CLAY_ERROR_TYPE_FLOATING_CONTAINER_PARENT_NOT_FOUND,\n                            .errorText = CLAY_STRING(\"A floating element was declared with a parentId, but no element with that ID was found.\"),\n                            .userData = context->errorHandler.userData });\n                    } else {\n                        clipElementId = Clay__int32_tArray_Get(&context->layoutElementClipElementIds, parentItem->layoutElement - context->layoutElements.internalArray);\n                    }\n                }\n                Clay__LayoutElementTreeRootArray_Add(&context->layoutElementTreeRoots, CLAY__INIT(Clay__LayoutElementTreeRoot) {\n                    .layoutElementIndex = Clay__int32_tArray_Get(&context->openLayoutElementStack, context->openLayoutElementStack.length - 1),\n                    .parentId = floatingConfig->parentId,\n                    .clipElementId = clipElementId,\n                    .zIndex = floatingConfig->zIndex,\n                });\n                break;\n            }\n            case CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER: {\n                Clay__int32_tArray_Add(&context->openClipElementStack, (int)openLayoutElement->id);\n                // Retrieve or create cached data to track scroll position across frames\n                Clay__ScrollContainerDataInternal *scrollOffset = CLAY__NULL;\n                for (int32_t i = 0; i < context->scrollContainerDatas.length; i++) {\n                    Clay__ScrollContainerDataInternal *mapping = Clay__ScrollContainerDataInternalArray_Get(&context->scrollContainerDatas, i);\n                    if (openLayoutElement->id == mapping->elementId) {\n                        scrollOffset = mapping;\n                        scrollOffset->layoutElement = openLayoutElement;\n                        scrollOffset->openThisFrame = true;\n                    }\n                }\n                if (!scrollOffset) {\n                    scrollOffset = Clay__ScrollContainerDataInternalArray_Add(&context->scrollContainerDatas, CLAY__INIT(Clay__ScrollContainerDataInternal){.layoutElement = openLayoutElement, .scrollOrigin = {-1,-1}, .elementId = openLayoutElement->id, .openThisFrame = true});\n                }\n                if (context->externalScrollHandlingEnabled) {\n                    scrollOffset->scrollPosition = Clay__QueryScrollOffset(scrollOffset->elementId);\n                }\n                break;\n            }\n            case CLAY__ELEMENT_CONFIG_TYPE_CUSTOM: break;\n            case CLAY__ELEMENT_CONFIG_TYPE_IMAGE: {\n                Clay__LayoutElementPointerArray_Add(&context->imageElementPointers, openLayoutElement);\n                break;\n            }\n            case CLAY__ELEMENT_CONFIG_TYPE_TEXT:\n            default: break;\n        }\n    }\n    context->elementConfigBuffer.length -= openLayoutElement->elementConfigs.length;\n}\n\nvoid Clay__CloseElement(void) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->booleanWarnings.maxElementsExceeded) {\n        return;\n    }\n    Clay_LayoutElement *openLayoutElement = Clay__GetOpenLayoutElement();\n    Clay_LayoutConfig *layoutConfig = openLayoutElement->layoutConfig;\n    bool elementHasScrollHorizontal = false;\n    bool elementHasScrollVertical = false;\n    if (Clay__ElementHasConfig(openLayoutElement, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER)) {\n        Clay_ScrollElementConfig *scrollConfig = Clay__FindElementConfigWithType(openLayoutElement, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER).scrollElementConfig;\n        elementHasScrollHorizontal = scrollConfig->horizontal;\n        elementHasScrollVertical = scrollConfig->vertical;\n        context->openClipElementStack.length--;\n    }\n\n    // Attach children to the current open element\n    openLayoutElement->childrenOrTextContent.children.elements = &context->layoutElementChildren.internalArray[context->layoutElementChildren.length];\n    if (layoutConfig->layoutDirection == CLAY_LEFT_TO_RIGHT) {\n        openLayoutElement->dimensions.width = (float)layoutConfig->padding.x * 2;\n        for (int32_t i = 0; i < openLayoutElement->childrenOrTextContent.children.length; i++) {\n            int32_t childIndex = Clay__int32_tArray_Get(&context->layoutElementChildrenBuffer, (int)context->layoutElementChildrenBuffer.length - openLayoutElement->childrenOrTextContent.children.length + i);\n            Clay_LayoutElement *child = Clay_LayoutElementArray_Get(&context->layoutElements, childIndex);\n            openLayoutElement->dimensions.width += child->dimensions.width;\n            openLayoutElement->dimensions.height = CLAY__MAX(openLayoutElement->dimensions.height, child->dimensions.height + layoutConfig->padding.y * 2);\n            // Minimum size of child elements doesn't matter to scroll containers as they can shrink and hide their contents\n            if (!elementHasScrollHorizontal) {\n                openLayoutElement->minDimensions.width += child->minDimensions.width;\n            }\n            if (!elementHasScrollVertical) {\n                openLayoutElement->minDimensions.height = CLAY__MAX(openLayoutElement->minDimensions.height, child->minDimensions.height + layoutConfig->padding.y * 2);\n            }\n            Clay__int32_tArray_Add(&context->layoutElementChildren, childIndex);\n        }\n        float childGap = (float)(CLAY__MAX(openLayoutElement->childrenOrTextContent.children.length - 1, 0) * layoutConfig->childGap);\n        openLayoutElement->dimensions.width += childGap; // TODO this is technically a bug with childgap and scroll containers\n        openLayoutElement->minDimensions.width += childGap;\n    }\n    else if (layoutConfig->layoutDirection == CLAY_TOP_TO_BOTTOM) {\n        openLayoutElement->dimensions.height = (float)layoutConfig->padding.y * 2;\n        for (int32_t i = 0; i < openLayoutElement->childrenOrTextContent.children.length; i++) {\n            int32_t childIndex = Clay__int32_tArray_Get(&context->layoutElementChildrenBuffer, (int)context->layoutElementChildrenBuffer.length - openLayoutElement->childrenOrTextContent.children.length + i);\n            Clay_LayoutElement *child = Clay_LayoutElementArray_Get(&context->layoutElements, childIndex);\n            openLayoutElement->dimensions.height += child->dimensions.height;\n            openLayoutElement->dimensions.width = CLAY__MAX(openLayoutElement->dimensions.width, child->dimensions.width + layoutConfig->padding.x * 2);\n            // Minimum size of child elements doesn't matter to scroll containers as they can shrink and hide their contents\n            if (!elementHasScrollVertical) {\n                openLayoutElement->minDimensions.height += child->minDimensions.height;\n            }\n            if (!elementHasScrollHorizontal) {\n                openLayoutElement->minDimensions.width = CLAY__MAX(openLayoutElement->minDimensions.width, child->minDimensions.width + layoutConfig->padding.x * 2);\n            }\n            Clay__int32_tArray_Add(&context->layoutElementChildren, childIndex);\n        }\n        float childGap = (float)(CLAY__MAX(openLayoutElement->childrenOrTextContent.children.length - 1, 0) * layoutConfig->childGap);\n        openLayoutElement->dimensions.height += childGap; // TODO this is technically a bug with childgap and scroll containers\n        openLayoutElement->minDimensions.height += childGap;\n    }\n\n    context->layoutElementChildrenBuffer.length -= openLayoutElement->childrenOrTextContent.children.length;\n\n    // Clamp element min and max width to the values configured in the layout\n    if (layoutConfig->sizing.width.type != CLAY__SIZING_TYPE_PERCENT) {\n        if (layoutConfig->sizing.width.size.minMax.max <= 0) { // Set the max size if the user didn't specify, makes calculations easier\n            layoutConfig->sizing.width.size.minMax.max = CLAY__MAXFLOAT;\n        }\n        openLayoutElement->dimensions.width = CLAY__MIN(CLAY__MAX(openLayoutElement->dimensions.width, layoutConfig->sizing.width.size.minMax.min), layoutConfig->sizing.width.size.minMax.max);\n        openLayoutElement->minDimensions.width = CLAY__MIN(CLAY__MAX(openLayoutElement->minDimensions.width, layoutConfig->sizing.width.size.minMax.min), layoutConfig->sizing.width.size.minMax.max);\n    } else {\n        openLayoutElement->dimensions.width = 0;\n    }\n\n    // Clamp element min and max height to the values configured in the layout\n    if (layoutConfig->sizing.height.type != CLAY__SIZING_TYPE_PERCENT) {\n        if (layoutConfig->sizing.height.size.minMax.max <= 0) { // Set the max size if the user didn't specify, makes calculations easier\n            layoutConfig->sizing.height.size.minMax.max = CLAY__MAXFLOAT;\n        }\n        openLayoutElement->dimensions.height = CLAY__MIN(CLAY__MAX(openLayoutElement->dimensions.height, layoutConfig->sizing.height.size.minMax.min), layoutConfig->sizing.height.size.minMax.max);\n        openLayoutElement->minDimensions.height = CLAY__MIN(CLAY__MAX(openLayoutElement->minDimensions.height, layoutConfig->sizing.height.size.minMax.min), layoutConfig->sizing.height.size.minMax.max);\n    } else {\n        openLayoutElement->dimensions.height = 0;\n    }\n\n    bool elementIsFloating = Clay__ElementHasConfig(openLayoutElement, CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER);\n\n    // Close the currently open element\n    int32_t closingElementIndex = Clay__int32_tArray_RemoveSwapback(&context->openLayoutElementStack, (int)context->openLayoutElementStack.length - 1);\n    openLayoutElement = Clay__GetOpenLayoutElement();\n\n    if (!elementIsFloating && context->openLayoutElementStack.length > 1) {\n        openLayoutElement->childrenOrTextContent.children.length++;\n        Clay__int32_tArray_Add(&context->layoutElementChildrenBuffer, closingElementIndex);\n    }\n}\n\nvoid Clay__OpenElement(void) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->layoutElements.length == context->layoutElements.capacity - 1 || context->booleanWarnings.maxElementsExceeded) {\n        context->booleanWarnings.maxElementsExceeded = true;\n        return;\n    }\n    Clay_LayoutElement layoutElement = CLAY__DEFAULT_STRUCT;\n    Clay_LayoutElementArray_Add(&context->layoutElements, layoutElement);\n    Clay__int32_tArray_Add(&context->openLayoutElementStack, context->layoutElements.length - 1);\n    if (context->openClipElementStack.length > 0) {\n        Clay__int32_tArray_Set(&context->layoutElementClipElementIds, context->layoutElements.length - 1, Clay__int32_tArray_Get(&context->openClipElementStack, (int)context->openClipElementStack.length - 1));\n    } else {\n        Clay__int32_tArray_Set(&context->layoutElementClipElementIds, context->layoutElements.length - 1, 0);\n    }\n}\n\nvoid Clay__OpenTextElement(Clay_String text, Clay_TextElementConfig *textConfig) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->layoutElements.length == context->layoutElements.capacity - 1 || context->booleanWarnings.maxElementsExceeded) {\n        context->booleanWarnings.maxElementsExceeded = true;\n        return;\n    }\n    Clay_LayoutElement *parentElement = Clay__GetOpenLayoutElement();\n    parentElement->childrenOrTextContent.children.length++;\n\n    Clay__OpenElement();\n    Clay_LayoutElement * openLayoutElement = Clay__GetOpenLayoutElement();\n    Clay__int32_tArray_Add(&context->layoutElementChildrenBuffer, context->layoutElements.length - 1);\n    Clay__MeasureTextCacheItem *textMeasured = Clay__MeasureTextCached(&text, textConfig);\n    Clay_ElementId elementId = Clay__HashString(CLAY_STRING(\"Text\"), parentElement->childrenOrTextContent.children.length, parentElement->id);\n    openLayoutElement->id = elementId.id;\n    Clay__AddHashMapItem(elementId, openLayoutElement);\n    Clay__StringArray_Add(&context->layoutElementIdStrings, elementId.stringId);\n    Clay_Dimensions textDimensions = { .width = textMeasured->unwrappedDimensions.width, .height = textConfig->lineHeight > 0 ? (float)textConfig->lineHeight : textMeasured->unwrappedDimensions.height };\n    openLayoutElement->dimensions = textDimensions;\n    openLayoutElement->minDimensions = CLAY__INIT(Clay_Dimensions) { .width = textMeasured->unwrappedDimensions.height, .height = textDimensions.height }; // TODO not sure this is the best way to decide min width for text\n    openLayoutElement->childrenOrTextContent.textElementData = Clay__TextElementDataArray_Add(&context->textElementData, CLAY__INIT(Clay__TextElementData) { .text = text, .preferredDimensions = textMeasured->unwrappedDimensions, .elementIndex = context->layoutElements.length - 1 });\n    openLayoutElement->elementConfigs = CLAY__INIT(Clay__ElementConfigArraySlice) {\n        .length = 1,\n        .internalArray = Clay__ElementConfigArray_Add(&context->elementConfigs, CLAY__INIT(Clay_ElementConfig) { .type = CLAY__ELEMENT_CONFIG_TYPE_TEXT, .config = { .textElementConfig = textConfig }})\n    };\n    openLayoutElement->configsEnabled |= CLAY__ELEMENT_CONFIG_TYPE_TEXT;\n    openLayoutElement->layoutConfig = &CLAY_LAYOUT_DEFAULT;\n    // Close the currently open element\n    Clay__int32_tArray_RemoveSwapback(&context->openLayoutElementStack, (int)context->openLayoutElementStack.length - 1);\n}\n\nvoid Clay__InitializeEphemeralMemory(Clay_Context* context) {\n    int32_t maxElementCount = context->maxElementCount;\n    // Ephemeral Memory - reset every frame\n    Clay_Arena *arena = &context->internalArena;\n    arena->nextAllocation = context->arenaResetOffset;\n\n    context->layoutElementChildrenBuffer = Clay__int32_tArray_Allocate_Arena(maxElementCount, arena);\n    context->layoutElements = Clay_LayoutElementArray_Allocate_Arena(maxElementCount, arena);\n    context->warnings = Clay__WarningArray_Allocate_Arena(100, arena);\n\n    context->layoutConfigs = Clay__LayoutConfigArray_Allocate_Arena(maxElementCount, arena);\n    context->elementConfigBuffer = Clay__ElementConfigArray_Allocate_Arena(maxElementCount, arena);\n    context->elementConfigs = Clay__ElementConfigArray_Allocate_Arena(maxElementCount, arena);\n    context->rectangleElementConfigs = Clay__RectangleElementConfigArray_Allocate_Arena(maxElementCount, arena);\n    context->textElementConfigs = Clay__TextElementConfigArray_Allocate_Arena(maxElementCount, arena);\n    context->imageElementConfigs = Clay__ImageElementConfigArray_Allocate_Arena(maxElementCount, arena);\n    context->floatingElementConfigs = Clay__FloatingElementConfigArray_Allocate_Arena(maxElementCount, arena);\n    context->scrollElementConfigs = Clay__ScrollElementConfigArray_Allocate_Arena(maxElementCount, arena);\n    context->customElementConfigs = Clay__CustomElementConfigArray_Allocate_Arena(maxElementCount, arena);\n    context->borderElementConfigs = Clay__BorderElementConfigArray_Allocate_Arena(maxElementCount, arena);\n\n    context->layoutElementIdStrings = Clay__StringArray_Allocate_Arena(maxElementCount, arena);\n    context->wrappedTextLines = Clay__WrappedTextLineArray_Allocate_Arena(maxElementCount, arena);\n    context->layoutElementTreeNodeArray1 = Clay__LayoutElementTreeNodeArray_Allocate_Arena(maxElementCount, arena);\n    context->layoutElementTreeRoots = Clay__LayoutElementTreeRootArray_Allocate_Arena(maxElementCount, arena);\n    context->layoutElementChildren = Clay__int32_tArray_Allocate_Arena(maxElementCount, arena);\n    context->openLayoutElementStack = Clay__int32_tArray_Allocate_Arena(maxElementCount, arena);\n    context->textElementData = Clay__TextElementDataArray_Allocate_Arena(maxElementCount, arena);\n    context->imageElementPointers = Clay__LayoutElementPointerArray_Allocate_Arena(maxElementCount, arena);\n    context->renderCommands = Clay_RenderCommandArray_Allocate_Arena(maxElementCount, arena);\n    context->treeNodeVisited = Clay__BoolArray_Allocate_Arena(maxElementCount, arena);\n    context->treeNodeVisited.length = context->treeNodeVisited.capacity; // This array is accessed directly rather than behaving as a list\n    context->openClipElementStack = Clay__int32_tArray_Allocate_Arena(maxElementCount, arena);\n    context->reusableElementIndexBuffer = Clay__int32_tArray_Allocate_Arena(maxElementCount, arena);\n    context->layoutElementClipElementIds = Clay__int32_tArray_Allocate_Arena(maxElementCount, arena);\n    context->dynamicStringData = Clay__CharArray_Allocate_Arena(maxElementCount, arena);\n}\n\nvoid Clay__InitializePersistentMemory(Clay_Context* context) {\n    // Persistent memory - initialized once and not reset\n    int32_t maxElementCount = context->maxElementCount;\n    int32_t maxMeasureTextCacheWordCount = context->maxMeasureTextCacheWordCount;\n    Clay_Arena *arena = &context->internalArena;\n    \n    context->scrollContainerDatas = Clay__ScrollContainerDataInternalArray_Allocate_Arena(10, arena);\n    context->layoutElementsHashMapInternal = Clay__LayoutElementHashMapItemArray_Allocate_Arena(maxElementCount, arena);\n    context->layoutElementsHashMap = Clay__int32_tArray_Allocate_Arena(maxElementCount, arena);\n    context->measureTextHashMapInternal = Clay__MeasureTextCacheItemArray_Allocate_Arena(maxElementCount, arena);\n    context->measureTextHashMapInternalFreeList = Clay__int32_tArray_Allocate_Arena(maxElementCount, arena);\n    context->measuredWordsFreeList = Clay__int32_tArray_Allocate_Arena(maxMeasureTextCacheWordCount, arena);\n    context->measureTextHashMap = Clay__int32_tArray_Allocate_Arena(maxElementCount, arena);\n    context->measuredWords = Clay__MeasuredWordArray_Allocate_Arena(maxMeasureTextCacheWordCount, arena);\n    context->pointerOverIds = Clay__ElementIdArray_Allocate_Arena(maxElementCount, arena);\n    context->debugElementData = Clay__DebugElementDataArray_Allocate_Arena(maxElementCount, arena);\n    context->arenaResetOffset = arena->nextAllocation;\n}\n\n\nvoid Clay__CompressChildrenAlongAxis(bool xAxis, float totalSizeToDistribute, Clay__int32_tArray resizableContainerBuffer) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    Clay__int32_tArray largestContainers = context->openClipElementStack;\n    largestContainers.length = 0;\n\n    while (totalSizeToDistribute > 0.1) {\n        float largestSize = 0;\n        float targetSize = 0;\n        for (int32_t i = 0; i < resizableContainerBuffer.length; ++i) {\n            Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, Clay__int32_tArray_Get(&resizableContainerBuffer, i));\n            if (!xAxis && Clay__ElementHasConfig(childElement, CLAY__ELEMENT_CONFIG_TYPE_IMAGE)) {\n                continue;\n            }\n            float childSize = xAxis ? childElement->dimensions.width : childElement->dimensions.height;\n            if ((childSize - largestSize) < 0.1 && (childSize - largestSize) > -0.1) {\n                Clay__int32_tArray_Add(&largestContainers, Clay__int32_tArray_Get(&resizableContainerBuffer, i));\n            } else if (childSize > largestSize) {\n                targetSize = largestSize;\n                largestSize = childSize;\n                largestContainers.length = 0;\n                Clay__int32_tArray_Add(&largestContainers, Clay__int32_tArray_Get(&resizableContainerBuffer, i));\n            }\n            else if (childSize > targetSize) {\n                targetSize = childSize;\n            }\n        }\n\n        targetSize = CLAY__MAX(targetSize, (largestSize * largestContainers.length) - totalSizeToDistribute) / largestContainers.length;\n        for (int32_t childOffset = 0; childOffset < largestContainers.length; childOffset++) {\n            Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, Clay__int32_tArray_Get(&largestContainers, childOffset));\n            float *childSize = xAxis ? &childElement->dimensions.width : &childElement->dimensions.height;\n            float childMinSize = xAxis ? childElement->minDimensions.width : childElement->minDimensions.height;\n            float oldChildSize = *childSize;\n            *childSize = CLAY__MAX(childMinSize, targetSize);\n            totalSizeToDistribute -= (oldChildSize - *childSize);\n            if (*childSize == childMinSize) {\n                Clay__int32_tArray_RemoveSwapback(&largestContainers, childOffset);\n                childOffset--;\n            }\n        }\n\n        if (largestContainers.length == 0) {\n            break;\n        }\n    }\n}\n\nvoid Clay__SizeContainersAlongAxis(bool xAxis) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    Clay__int32_tArray bfsBuffer = context->layoutElementChildrenBuffer;\n    Clay__int32_tArray resizableContainerBuffer = context->openLayoutElementStack;\n    for (int32_t rootIndex = 0; rootIndex < context->layoutElementTreeRoots.length; ++rootIndex) {\n        bfsBuffer.length = 0;\n        Clay__LayoutElementTreeRoot *root = Clay__LayoutElementTreeRootArray_Get(&context->layoutElementTreeRoots, rootIndex);\n        Clay_LayoutElement *rootElement = Clay_LayoutElementArray_Get(&context->layoutElements, (int)root->layoutElementIndex);\n        Clay__int32_tArray_Add(&bfsBuffer, (int32_t)root->layoutElementIndex);\n\n        // Size floating containers to their parents\n        if (Clay__ElementHasConfig(rootElement, CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER)) {\n            Clay_FloatingElementConfig *floatingElementConfig = Clay__FindElementConfigWithType(rootElement, CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER).floatingElementConfig;\n            Clay_LayoutElementHashMapItem *parentItem = Clay__GetHashMapItem(floatingElementConfig->parentId);\n            if (parentItem) {\n                Clay_LayoutElement *parentLayoutElement = parentItem->layoutElement;\n                if (rootElement->layoutConfig->sizing.width.type == CLAY__SIZING_TYPE_GROW) {\n                    rootElement->dimensions.width = parentLayoutElement->dimensions.width;\n                }\n                if (rootElement->layoutConfig->sizing.height.type == CLAY__SIZING_TYPE_GROW) {\n                    rootElement->dimensions.height = parentLayoutElement->dimensions.height;\n                }\n            }\n        }\n\n        rootElement->dimensions.width = CLAY__MIN(CLAY__MAX(rootElement->dimensions.width, rootElement->layoutConfig->sizing.width.size.minMax.min), rootElement->layoutConfig->sizing.width.size.minMax.max);\n        rootElement->dimensions.height = CLAY__MIN(CLAY__MAX(rootElement->dimensions.height, rootElement->layoutConfig->sizing.height.size.minMax.min), rootElement->layoutConfig->sizing.height.size.minMax.max);\n\n        for (int32_t i = 0; i < bfsBuffer.length; ++i) {\n            int32_t parentIndex = Clay__int32_tArray_Get(&bfsBuffer, i);\n            Clay_LayoutElement *parent = Clay_LayoutElementArray_Get(&context->layoutElements, parentIndex);\n            Clay_LayoutConfig *parentStyleConfig = parent->layoutConfig;\n            int32_t growContainerCount = 0;\n            float parentSize = xAxis ? parent->dimensions.width : parent->dimensions.height;\n            float parentPadding = (float)(xAxis ? parent->layoutConfig->padding.x : parent->layoutConfig->padding.y);\n            float innerContentSize = 0, growContainerContentSize = 0, totalPaddingAndChildGaps = parentPadding * 2;\n            bool sizingAlongAxis = (xAxis && parentStyleConfig->layoutDirection == CLAY_LEFT_TO_RIGHT) || (!xAxis && parentStyleConfig->layoutDirection == CLAY_TOP_TO_BOTTOM);\n            resizableContainerBuffer.length = 0;\n            float parentChildGap = parentStyleConfig->childGap;\n\n            for (int32_t childOffset = 0; childOffset < parent->childrenOrTextContent.children.length; childOffset++) {\n                int32_t childElementIndex = parent->childrenOrTextContent.children.elements[childOffset];\n                Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, childElementIndex);\n                Clay_SizingAxis childSizing = xAxis ? childElement->layoutConfig->sizing.width : childElement->layoutConfig->sizing.height;\n                float childSize = xAxis ? childElement->dimensions.width : childElement->dimensions.height;\n\n                if (!Clay__ElementHasConfig(childElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT) && childElement->childrenOrTextContent.children.length > 0) {\n                    Clay__int32_tArray_Add(&bfsBuffer, childElementIndex);\n                }\n\n                if (childSizing.type != CLAY__SIZING_TYPE_PERCENT && childSizing.type != CLAY__SIZING_TYPE_FIXED && (!Clay__ElementHasConfig(childElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT) || (Clay__FindElementConfigWithType(childElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT).textElementConfig->wrapMode == CLAY_TEXT_WRAP_WORDS))) {\n                    Clay__int32_tArray_Add(&resizableContainerBuffer, childElementIndex);\n                }\n\n                if (sizingAlongAxis) {\n                    innerContentSize += (childSizing.type == CLAY__SIZING_TYPE_PERCENT ? 0 : childSize);\n                    if (childSizing.type == CLAY__SIZING_TYPE_GROW) {\n                        growContainerContentSize += childSize;\n                        growContainerCount++;\n                    }\n                    if (childOffset > 0) {\n                        innerContentSize += parentChildGap; // For children after index 0, the childAxisOffset is the gap from the previous child\n                        totalPaddingAndChildGaps += parentChildGap;\n                    }\n                } else {\n                    innerContentSize = CLAY__MAX(childSize, innerContentSize);\n                }\n            }\n\n            // Expand percentage containers to size\n            for (int32_t childOffset = 0; childOffset < parent->childrenOrTextContent.children.length; childOffset++) {\n                int32_t childElementIndex = parent->childrenOrTextContent.children.elements[childOffset];\n                Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, childElementIndex);\n                Clay_SizingAxis childSizing = xAxis ? childElement->layoutConfig->sizing.width : childElement->layoutConfig->sizing.height;\n                float *childSize = xAxis ? &childElement->dimensions.width : &childElement->dimensions.height;\n                if (childSizing.type == CLAY__SIZING_TYPE_PERCENT) {\n                    *childSize = (parentSize - totalPaddingAndChildGaps) * childSizing.size.percent;\n                    if (sizingAlongAxis) {\n                        innerContentSize += *childSize;\n                        if (childOffset > 0) {\n                            innerContentSize += parentChildGap; // For children after index 0, the childAxisOffset is the gap from the previous child\n                            totalPaddingAndChildGaps += parentChildGap;\n                        }\n                    } else {\n                        innerContentSize = CLAY__MAX(*childSize, innerContentSize);\n                    }\n                }\n            }\n\n            if (sizingAlongAxis) {\n                float sizeToDistribute = parentSize - parentPadding * 2 - innerContentSize;\n                // The content is too large, compress the children as much as possible\n                if (sizeToDistribute < 0) {\n                    // If the parent can scroll in the axis direction in this direction, don't compress children, just leave them alone\n                    if (Clay__ElementHasConfig(parent, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER)) {\n                        Clay_ScrollElementConfig *scrollElementConfig = Clay__FindElementConfigWithType(parent, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER).scrollElementConfig;\n                        if (((xAxis && scrollElementConfig->horizontal) || (!xAxis && scrollElementConfig->vertical))) {\n                            continue;\n                        }\n                    }\n                    // Scrolling containers preferentially compress before others\n                    Clay__CompressChildrenAlongAxis(xAxis, -sizeToDistribute, resizableContainerBuffer);\n                // The content is too small, allow SIZING_GROW containers to expand\n                } else if (sizeToDistribute > 0 && growContainerCount > 0) {\n                    float targetSize = (sizeToDistribute + growContainerContentSize) / (float)growContainerCount;\n                    for (int32_t childOffset = 0; childOffset < resizableContainerBuffer.length; childOffset++) {\n                        Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, Clay__int32_tArray_Get(&resizableContainerBuffer, childOffset));\n                        Clay_SizingAxis childSizing = xAxis ? childElement->layoutConfig->sizing.width : childElement->layoutConfig->sizing.height;\n                        if (childSizing.type == CLAY__SIZING_TYPE_GROW) {\n                            float *childSize = xAxis ? &childElement->dimensions.width : &childElement->dimensions.height;\n                            float *minSize = xAxis ? &childElement->minDimensions.width : &childElement->minDimensions.height;\n                            if (targetSize < *minSize) {\n                                growContainerContentSize -= *minSize;\n                                Clay__int32_tArray_RemoveSwapback(&resizableContainerBuffer, childOffset);\n                                growContainerCount--;\n                                targetSize = (sizeToDistribute + growContainerContentSize) / (float)growContainerCount;\n                                childOffset = -1;\n                                continue;\n                            }\n                            *childSize = targetSize;\n                        }\n                    }\n                }\n            // Sizing along the non layout axis (\"off axis\")\n            } else {\n                for (int32_t childOffset = 0; childOffset < resizableContainerBuffer.length; childOffset++) {\n                    Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, Clay__int32_tArray_Get(&resizableContainerBuffer, childOffset));\n                    Clay_SizingAxis childSizing = xAxis ? childElement->layoutConfig->sizing.width : childElement->layoutConfig->sizing.height;\n                    float *childSize = xAxis ? &childElement->dimensions.width : &childElement->dimensions.height;\n\n                    if (!xAxis && Clay__ElementHasConfig(childElement, CLAY__ELEMENT_CONFIG_TYPE_IMAGE)) {\n                        continue; // Currently we don't support resizing aspect ratio images on the Y axis because it would break the ratio\n                    }\n\n                    // If we're laying out the children of a scroll panel, grow containers expand to the height of the inner content, not the outer container\n                    float maxSize = parentSize - parentPadding * 2;\n                    if (Clay__ElementHasConfig(parent, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER)) {\n                        Clay_ScrollElementConfig *scrollElementConfig = Clay__FindElementConfigWithType(parent, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER).scrollElementConfig;\n                        if (((xAxis && scrollElementConfig->horizontal) || (!xAxis && scrollElementConfig->vertical))) {\n                            maxSize = CLAY__MAX(maxSize, innerContentSize);\n                        }\n                    }\n                    if (childSizing.type == CLAY__SIZING_TYPE_FIT) {\n                        *childSize = CLAY__MAX(childSizing.size.minMax.min, CLAY__MIN(*childSize, maxSize));\n                    } else if (childSizing.type == CLAY__SIZING_TYPE_GROW) {\n                        *childSize = CLAY__MIN(maxSize, childSizing.size.minMax.max);\n                    }\n                }\n            }\n        }\n    }\n}\n\nClay_String Clay__IntToString(int32_t integer) {\n    if (integer == 0) {\n        return CLAY__INIT(Clay_String) { .length = 1, .chars = \"0\" };\n    }\n    Clay_Context* context = Clay_GetCurrentContext();\n    char *chars = (char *)(context->dynamicStringData.internalArray + context->dynamicStringData.length);\n    int32_t length = 0;\n    int32_t sign = integer;\n\n    if (integer < 0) {\n        integer = -integer;\n    }\n    while (integer > 0) {\n        chars[length++] = (char)(integer % 10 + '0');\n        integer /= 10;\n    }\n\n    if (sign < 0) {\n        chars[length++] = '-';\n    }\n\n    // Reverse the string to get the correct order\n    for (int32_t j = 0, k = length - 1; j < k; j++, k--) {\n        char temp = chars[j];\n        chars[j] = chars[k];\n        chars[k] = temp;\n    }\n    context->dynamicStringData.length += length;\n    return CLAY__INIT(Clay_String) { .length = length, .chars = chars };\n}\n\nvoid Clay__AddRenderCommand(Clay_RenderCommand renderCommand) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->renderCommands.length < context->renderCommands.capacity - 1) {\n        Clay_RenderCommandArray_Add(&context->renderCommands, renderCommand);\n    } else {\n        if (!context->booleanWarnings.maxRenderCommandsExceeded) {\n            context->booleanWarnings.maxRenderCommandsExceeded = true;\n            context->errorHandler.errorHandlerFunction(CLAY__INIT(Clay_ErrorData) {\n                .errorType = CLAY_ERROR_TYPE_ELEMENTS_CAPACITY_EXCEEDED,\n                .errorText = CLAY_STRING(\"Clay ran out of capacity while attempting to create render commands. This is usually caused by a large amount of wrapping text elements while close to the max element capacity. Try using Clay_SetMaxElementCount() with a higher value.\"),\n                .userData = context->errorHandler.userData });\n        }\n    }\n}\n\nbool Clay__ElementIsOffscreen(Clay_BoundingBox *boundingBox) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->disableCulling) {\n        return false;\n    }\n\n    return (boundingBox->x > (float)context->layoutDimensions.width) ||\n           (boundingBox->y > (float)context->layoutDimensions.height) ||\n           (boundingBox->x + boundingBox->width < 0) ||\n           (boundingBox->y + boundingBox->height < 0);\n}\n\nvoid Clay__CalculateFinalLayout() {\n    Clay_Context* context = Clay_GetCurrentContext();\n    // Calculate sizing along the X axis\n    Clay__SizeContainersAlongAxis(true);\n\n    // Wrap text\n    for (int32_t textElementIndex = 0; textElementIndex < context->textElementData.length; ++textElementIndex) {\n        Clay__TextElementData *textElementData = Clay__TextElementDataArray_Get(&context->textElementData, textElementIndex);\n        textElementData->wrappedLines = CLAY__INIT(Clay__WrappedTextLineArraySlice) { .length = 0, .internalArray = &context->wrappedTextLines.internalArray[context->wrappedTextLines.length] };\n        Clay_LayoutElement *containerElement = Clay_LayoutElementArray_Get(&context->layoutElements, (int)textElementData->elementIndex);\n        Clay_TextElementConfig *textConfig = Clay__FindElementConfigWithType(containerElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT).textElementConfig;\n        Clay__MeasureTextCacheItem *measureTextCacheItem = Clay__MeasureTextCached(&textElementData->text, textConfig);\n        float lineWidth = 0;\n        float lineHeight = textConfig->lineHeight > 0 ? (float)textConfig->lineHeight : textElementData->preferredDimensions.height;\n        int32_t lineLengthChars = 0;\n        int32_t lineStartOffset = 0;\n        if (textElementData->preferredDimensions.width <= containerElement->dimensions.width) {\n            Clay__WrappedTextLineArray_Add(&context->wrappedTextLines, CLAY__INIT(Clay__WrappedTextLine) { containerElement->dimensions,  textElementData->text });\n            textElementData->wrappedLines.length++;\n            continue;\n        }\n        int32_t wordIndex = measureTextCacheItem->measuredWordsStartIndex;\n        while (wordIndex != -1) {\n            if (context->wrappedTextLines.length > context->wrappedTextLines.capacity - 1) {\n                break;\n            }\n            Clay__MeasuredWord *measuredWord = Clay__MeasuredWordArray_Get(&context->measuredWords, wordIndex);\n            // Only word on the line is too large, just render it anyway\n            if (lineLengthChars == 0 && lineWidth + measuredWord->width > containerElement->dimensions.width) {\n                Clay__WrappedTextLineArray_Add(&context->wrappedTextLines, CLAY__INIT(Clay__WrappedTextLine) { { measuredWord->width, lineHeight }, { .length = measuredWord->length, .chars = &textElementData->text.chars[measuredWord->startOffset] } });\n                textElementData->wrappedLines.length++;\n                wordIndex = measuredWord->next;\n                lineStartOffset = measuredWord->startOffset + measuredWord->length;\n            }\n            // measuredWord->length == 0 means a newline character\n            else if (measuredWord->length == 0 || lineWidth + measuredWord->width > containerElement->dimensions.width) {\n                // Wrapped text lines list has overflowed, just render out the line\n                Clay__WrappedTextLineArray_Add(&context->wrappedTextLines, CLAY__INIT(Clay__WrappedTextLine) { { lineWidth, lineHeight }, { .length = lineLengthChars, .chars = &textElementData->text.chars[lineStartOffset] } });\n                textElementData->wrappedLines.length++;\n                if (lineLengthChars == 0 || measuredWord->length == 0) {\n                    wordIndex = measuredWord->next;\n                }\n                lineWidth = 0;\n                lineLengthChars = 0;\n                lineStartOffset = measuredWord->startOffset;\n            } else {\n                lineWidth += measuredWord->width;\n                lineLengthChars += measuredWord->length;\n                wordIndex = measuredWord->next;\n            }\n        }\n        if (lineLengthChars > 0) {\n            Clay__WrappedTextLineArray_Add(&context->wrappedTextLines, CLAY__INIT(Clay__WrappedTextLine) { { lineWidth, lineHeight }, {.length = lineLengthChars, .chars = &textElementData->text.chars[lineStartOffset] } });\n            textElementData->wrappedLines.length++;\n        }\n        containerElement->dimensions.height = lineHeight * (float)textElementData->wrappedLines.length;\n    }\n\n    // Scale vertical image heights according to aspect ratio\n    for (int32_t i = 0; i < context->imageElementPointers.length; ++i) {\n        Clay_LayoutElement* imageElement = Clay__LayoutElementPointerArray_Get(&context->imageElementPointers, i);\n        Clay_ImageElementConfig *config = Clay__FindElementConfigWithType(imageElement, CLAY__ELEMENT_CONFIG_TYPE_IMAGE).imageElementConfig;\n        imageElement->dimensions.height = (config->sourceDimensions.height / CLAY__MAX(config->sourceDimensions.width, 1)) * imageElement->dimensions.width;\n    }\n\n    // Propagate effect of text wrapping, image aspect scaling etc. on height of parents\n    Clay__LayoutElementTreeNodeArray dfsBuffer = context->layoutElementTreeNodeArray1;\n    dfsBuffer.length = 0;\n    for (int32_t i = 0; i < context->layoutElementTreeRoots.length; ++i) {\n        Clay__LayoutElementTreeRoot *root = Clay__LayoutElementTreeRootArray_Get(&context->layoutElementTreeRoots, i);\n        context->treeNodeVisited.internalArray[dfsBuffer.length] = false;\n        Clay__LayoutElementTreeNodeArray_Add(&dfsBuffer, CLAY__INIT(Clay__LayoutElementTreeNode) { .layoutElement = Clay_LayoutElementArray_Get(&context->layoutElements, (int)root->layoutElementIndex) });\n    }\n    while (dfsBuffer.length > 0) {\n        Clay__LayoutElementTreeNode *currentElementTreeNode = Clay__LayoutElementTreeNodeArray_Get(&dfsBuffer, (int)dfsBuffer.length - 1);\n        Clay_LayoutElement *currentElement = currentElementTreeNode->layoutElement;\n        if (!context->treeNodeVisited.internalArray[dfsBuffer.length - 1]) {\n            context->treeNodeVisited.internalArray[dfsBuffer.length - 1] = true;\n            // If the element has no children or is the container for a text element, don't bother inspecting it\n            if (Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT) || currentElement->childrenOrTextContent.children.length == 0) {\n                dfsBuffer.length--;\n                continue;\n            }\n            // Add the children to the DFS buffer (needs to be pushed in reverse so that stack traversal is in correct layout order)\n            for (int32_t i = 0; i < currentElement->childrenOrTextContent.children.length; i++) {\n                context->treeNodeVisited.internalArray[dfsBuffer.length] = false;\n                Clay__LayoutElementTreeNodeArray_Add(&dfsBuffer, CLAY__INIT(Clay__LayoutElementTreeNode) { .layoutElement = Clay_LayoutElementArray_Get(&context->layoutElements, currentElement->childrenOrTextContent.children.elements[i]) });\n            }\n            continue;\n        }\n        dfsBuffer.length--;\n\n        // DFS node has been visited, this is on the way back up to the root\n        Clay_LayoutConfig *layoutConfig = currentElement->layoutConfig;\n        if (layoutConfig->sizing.height.type == CLAY__SIZING_TYPE_PERCENT) {\n            continue;\n        }\n        if (layoutConfig->layoutDirection == CLAY_LEFT_TO_RIGHT) {\n            // Resize any parent containers that have grown in height along their non layout axis\n            for (int32_t j = 0; j < currentElement->childrenOrTextContent.children.length; ++j) {\n                Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, currentElement->childrenOrTextContent.children.elements[j]);\n                float childHeightWithPadding = CLAY__MAX(childElement->dimensions.height + layoutConfig->padding.y * 2, currentElement->dimensions.height);\n                currentElement->dimensions.height = CLAY__MIN(CLAY__MAX(childHeightWithPadding, layoutConfig->sizing.height.size.minMax.min), layoutConfig->sizing.height.size.minMax.max);\n            }\n        } else if (layoutConfig->layoutDirection == CLAY_TOP_TO_BOTTOM) {\n            // Resizing along the layout axis\n            float contentHeight = (float)layoutConfig->padding.y * 2;\n            for (int32_t j = 0; j < currentElement->childrenOrTextContent.children.length; ++j) {\n                Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, currentElement->childrenOrTextContent.children.elements[j]);\n                contentHeight += childElement->dimensions.height;\n            }\n            contentHeight += (float)(CLAY__MAX(currentElement->childrenOrTextContent.children.length - 1, 0) * layoutConfig->childGap);\n            currentElement->dimensions.height = CLAY__MIN(CLAY__MAX(contentHeight, layoutConfig->sizing.height.size.minMax.min), layoutConfig->sizing.height.size.minMax.max);\n        }\n    }\n\n    // Calculate sizing along the Y axis\n    Clay__SizeContainersAlongAxis(false);\n\n    // Sort tree roots by z-index\n    int32_t sortMax = context->layoutElementTreeRoots.length - 1;\n    while (sortMax > 0) { // todo dumb bubble sort\n        for (int32_t i = 0; i < sortMax; ++i) {\n            Clay__LayoutElementTreeRoot current = *Clay__LayoutElementTreeRootArray_Get(&context->layoutElementTreeRoots, i);\n            Clay__LayoutElementTreeRoot next = *Clay__LayoutElementTreeRootArray_Get(&context->layoutElementTreeRoots, i + 1);\n            if (next.zIndex < current.zIndex) {\n                Clay__LayoutElementTreeRootArray_Set(&context->layoutElementTreeRoots, i, next);\n                Clay__LayoutElementTreeRootArray_Set(&context->layoutElementTreeRoots, i + 1, current);\n            }\n        }\n        sortMax--;\n    }\n\n    // Calculate final positions and generate render commands\n    context->renderCommands.length = 0;\n    dfsBuffer.length = 0;\n    for (int32_t rootIndex = 0; rootIndex < context->layoutElementTreeRoots.length; ++rootIndex) {\n        dfsBuffer.length = 0;\n        Clay__LayoutElementTreeRoot *root = Clay__LayoutElementTreeRootArray_Get(&context->layoutElementTreeRoots, rootIndex);\n        Clay_LayoutElement *rootElement = Clay_LayoutElementArray_Get(&context->layoutElements, (int)root->layoutElementIndex);\n        Clay_Vector2 rootPosition = CLAY__DEFAULT_STRUCT;\n        Clay_LayoutElementHashMapItem *parentHashMapItem = Clay__GetHashMapItem(root->parentId);\n        // Position root floating containers\n        if (Clay__ElementHasConfig(rootElement, CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER) && parentHashMapItem) {\n            Clay_FloatingElementConfig *config = Clay__FindElementConfigWithType(rootElement, CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER).floatingElementConfig;\n            Clay_Dimensions rootDimensions = rootElement->dimensions;\n            Clay_BoundingBox parentBoundingBox = parentHashMapItem->boundingBox;\n            // Set X position\n            Clay_Vector2 targetAttachPosition = CLAY__DEFAULT_STRUCT;\n            switch (config->attachment.parent) {\n                case CLAY_ATTACH_POINT_LEFT_TOP:\n                case CLAY_ATTACH_POINT_LEFT_CENTER:\n                case CLAY_ATTACH_POINT_LEFT_BOTTOM: targetAttachPosition.x = parentBoundingBox.x; break;\n                case CLAY_ATTACH_POINT_CENTER_TOP:\n                case CLAY_ATTACH_POINT_CENTER_CENTER:\n                case CLAY_ATTACH_POINT_CENTER_BOTTOM: targetAttachPosition.x = parentBoundingBox.x + (parentBoundingBox.width / 2); break;\n                case CLAY_ATTACH_POINT_RIGHT_TOP:\n                case CLAY_ATTACH_POINT_RIGHT_CENTER:\n                case CLAY_ATTACH_POINT_RIGHT_BOTTOM: targetAttachPosition.x = parentBoundingBox.x + parentBoundingBox.width; break;\n            }\n            switch (config->attachment.element) {\n                case CLAY_ATTACH_POINT_LEFT_TOP:\n                case CLAY_ATTACH_POINT_LEFT_CENTER:\n                case CLAY_ATTACH_POINT_LEFT_BOTTOM: break;\n                case CLAY_ATTACH_POINT_CENTER_TOP:\n                case CLAY_ATTACH_POINT_CENTER_CENTER:\n                case CLAY_ATTACH_POINT_CENTER_BOTTOM: targetAttachPosition.x -= (rootDimensions.width / 2); break;\n                case CLAY_ATTACH_POINT_RIGHT_TOP:\n                case CLAY_ATTACH_POINT_RIGHT_CENTER:\n                case CLAY_ATTACH_POINT_RIGHT_BOTTOM: targetAttachPosition.x -= rootDimensions.width; break;\n            }\n            switch (config->attachment.parent) { // I know I could merge the x and y switch statements, but this is easier to read\n                case CLAY_ATTACH_POINT_LEFT_TOP:\n                case CLAY_ATTACH_POINT_RIGHT_TOP:\n                case CLAY_ATTACH_POINT_CENTER_TOP: targetAttachPosition.y = parentBoundingBox.y; break;\n                case CLAY_ATTACH_POINT_LEFT_CENTER:\n                case CLAY_ATTACH_POINT_CENTER_CENTER:\n                case CLAY_ATTACH_POINT_RIGHT_CENTER: targetAttachPosition.y = parentBoundingBox.y + (parentBoundingBox.height / 2); break;\n                case CLAY_ATTACH_POINT_LEFT_BOTTOM:\n                case CLAY_ATTACH_POINT_CENTER_BOTTOM:\n                case CLAY_ATTACH_POINT_RIGHT_BOTTOM: targetAttachPosition.y = parentBoundingBox.y + parentBoundingBox.height; break;\n            }\n            switch (config->attachment.element) {\n                case CLAY_ATTACH_POINT_LEFT_TOP:\n                case CLAY_ATTACH_POINT_RIGHT_TOP:\n                case CLAY_ATTACH_POINT_CENTER_TOP: break;\n                case CLAY_ATTACH_POINT_LEFT_CENTER:\n                case CLAY_ATTACH_POINT_CENTER_CENTER:\n                case CLAY_ATTACH_POINT_RIGHT_CENTER: targetAttachPosition.y -= (rootDimensions.height / 2); break;\n                case CLAY_ATTACH_POINT_LEFT_BOTTOM:\n                case CLAY_ATTACH_POINT_CENTER_BOTTOM:\n                case CLAY_ATTACH_POINT_RIGHT_BOTTOM: targetAttachPosition.y -= rootDimensions.height; break;\n            }\n            targetAttachPosition.x += config->offset.x;\n            targetAttachPosition.y += config->offset.y;\n            rootPosition = targetAttachPosition;\n        }\n        if (root->clipElementId) {\n            Clay_LayoutElementHashMapItem *clipHashMapItem = Clay__GetHashMapItem(root->clipElementId);\n            if (clipHashMapItem) {\n                // Floating elements that are attached to scrolling contents won't be correctly positioned if external scroll handling is enabled, fix here\n                if (context->externalScrollHandlingEnabled) {\n                    Clay_ScrollElementConfig *scrollConfig = Clay__FindElementConfigWithType(clipHashMapItem->layoutElement, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER).scrollElementConfig;\n                    for (int32_t i = 0; i < context->scrollContainerDatas.length; i++) {\n                        Clay__ScrollContainerDataInternal *mapping = Clay__ScrollContainerDataInternalArray_Get(&context->scrollContainerDatas, i);\n                        if (mapping->layoutElement == clipHashMapItem->layoutElement) {\n                            root->pointerOffset = mapping->scrollPosition;\n                            if (scrollConfig->horizontal) {\n                                rootPosition.x += mapping->scrollPosition.x;\n                            }\n                            if (scrollConfig->vertical) {\n                                rootPosition.y += mapping->scrollPosition.y;\n                            }\n                            break;\n                        }\n                    }\n                }\n                Clay__AddRenderCommand(CLAY__INIT(Clay_RenderCommand) {\n                    .boundingBox = clipHashMapItem->boundingBox,\n                    .config = { .scrollElementConfig = Clay__StoreScrollElementConfig(CLAY__INIT(Clay_ScrollElementConfig)CLAY__DEFAULT_STRUCT) },\n                    .id = Clay__RehashWithNumber(rootElement->id, 10), // TODO need a better strategy for managing derived ids\n                    .commandType = CLAY_RENDER_COMMAND_TYPE_SCISSOR_START,\n                });\n            }\n        }\n        Clay__LayoutElementTreeNodeArray_Add(&dfsBuffer, CLAY__INIT(Clay__LayoutElementTreeNode) { .layoutElement = rootElement, .position = rootPosition, .nextChildOffset = { .x = (float)rootElement->layoutConfig->padding.x, .y = (float)rootElement->layoutConfig->padding.y } });\n\n        context->treeNodeVisited.internalArray[0] = false;\n        while (dfsBuffer.length > 0) {\n            Clay__LayoutElementTreeNode *currentElementTreeNode = Clay__LayoutElementTreeNodeArray_Get(&dfsBuffer, (int)dfsBuffer.length - 1);\n            Clay_LayoutElement *currentElement = currentElementTreeNode->layoutElement;\n            Clay_LayoutConfig *layoutConfig = currentElement->layoutConfig;\n            Clay_Vector2 scrollOffset = CLAY__DEFAULT_STRUCT;\n\n            // This will only be run a single time for each element in downwards DFS order\n            if (!context->treeNodeVisited.internalArray[dfsBuffer.length - 1]) {\n                context->treeNodeVisited.internalArray[dfsBuffer.length - 1] = true;\n\n                Clay_BoundingBox currentElementBoundingBox = { currentElementTreeNode->position.x, currentElementTreeNode->position.y, currentElement->dimensions.width, currentElement->dimensions.height };\n                if (Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER)) {\n                    Clay_FloatingElementConfig *floatingElementConfig = Clay__FindElementConfigWithType(currentElement, CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER).floatingElementConfig;\n                    Clay_Dimensions expand = floatingElementConfig->expand;\n                    currentElementBoundingBox.x -= expand.width;\n                    currentElementBoundingBox.width += expand.width * 2;\n                    currentElementBoundingBox.y -= expand.height;\n                    currentElementBoundingBox.height += expand.height * 2;\n                }\n\n                Clay__ScrollContainerDataInternal *scrollContainerData = CLAY__NULL;\n                // Apply scroll offsets to container\n                if (Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER)) {\n                    Clay_ScrollElementConfig *scrollConfig = Clay__FindElementConfigWithType(currentElement, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER).scrollElementConfig;\n\n                    // This linear scan could theoretically be slow under very strange conditions, but I can't imagine a real UI with more than a few 10's of scroll containers\n                    for (int32_t i = 0; i < context->scrollContainerDatas.length; i++) {\n                        Clay__ScrollContainerDataInternal *mapping = Clay__ScrollContainerDataInternalArray_Get(&context->scrollContainerDatas, i);\n                        if (mapping->layoutElement == currentElement) {\n                            scrollContainerData = mapping;\n                            mapping->boundingBox = currentElementBoundingBox;\n                            if (scrollConfig->horizontal) {\n                                scrollOffset.x = mapping->scrollPosition.x;\n                            }\n                            if (scrollConfig->vertical) {\n                                scrollOffset.y = mapping->scrollPosition.y;\n                            }\n                            if (context->externalScrollHandlingEnabled) {\n                                scrollOffset = CLAY__INIT(Clay_Vector2) CLAY__DEFAULT_STRUCT;\n                            }\n                            break;\n                        }\n                    }\n                }\n\n                Clay_LayoutElementHashMapItem *hashMapItem = Clay__GetHashMapItem(currentElement->id);\n                if (hashMapItem) {\n                    hashMapItem->boundingBox = currentElementBoundingBox;\n                }\n\n                int32_t sortedConfigIndexes[20];\n                for (int32_t elementConfigIndex = 0; elementConfigIndex < currentElement->elementConfigs.length; ++elementConfigIndex) {\n                    sortedConfigIndexes[elementConfigIndex] = elementConfigIndex;\n                }\n                sortMax = currentElement->elementConfigs.length - 1;\n                while (sortMax > 0) { // todo dumb bubble sort\n                    for (int32_t i = 0; i < sortMax; ++i) {\n                        int32_t current = sortedConfigIndexes[i];\n                        int32_t next = sortedConfigIndexes[i + 1];\n                        Clay__ElementConfigType currentType = Clay__ElementConfigArraySlice_Get(&currentElement->elementConfigs, current)->type;\n                        Clay__ElementConfigType nextType = Clay__ElementConfigArraySlice_Get(&currentElement->elementConfigs, next)->type;\n                        if (nextType == CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER || currentType == CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER) {\n                            sortedConfigIndexes[i] = next;\n                            sortedConfigIndexes[i + 1] = current;\n                        }\n                    }\n                    sortMax--;\n                }\n\n                // Create the render commands for this element\n                for (int32_t elementConfigIndex = 0; elementConfigIndex < currentElement->elementConfigs.length; ++elementConfigIndex) {\n                    Clay_ElementConfig *elementConfig = Clay__ElementConfigArraySlice_Get(&currentElement->elementConfigs, sortedConfigIndexes[elementConfigIndex]);\n                    Clay_RenderCommand renderCommand = {\n                        .boundingBox = currentElementBoundingBox,\n                        .config = elementConfig->config,\n                        .id = currentElement->id,\n                    };\n\n                    bool offscreen = Clay__ElementIsOffscreen(&currentElementBoundingBox);\n                    // Culling - Don't bother to generate render commands for rectangles entirely outside the screen - this won't stop their children from being rendered if they overflow\n                    bool shouldRender = !offscreen;\n                    switch (elementConfig->type) {\n                        case CLAY__ELEMENT_CONFIG_TYPE_RECTANGLE: {\n                            renderCommand.commandType = CLAY_RENDER_COMMAND_TYPE_RECTANGLE;\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER: {\n                            shouldRender = false;\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER: {\n                            renderCommand.commandType = CLAY_RENDER_COMMAND_TYPE_NONE;\n                            shouldRender = false;\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER: {\n                            renderCommand.commandType = CLAY_RENDER_COMMAND_TYPE_SCISSOR_START;\n                            shouldRender = true;\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_IMAGE: {\n                            renderCommand.commandType = CLAY_RENDER_COMMAND_TYPE_IMAGE;\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_TEXT: {\n                            if (!shouldRender) {\n                                break;\n                            }\n                            shouldRender = false;\n                            Clay_ElementConfigUnion configUnion = elementConfig->config;\n                            Clay_TextElementConfig *textElementConfig = configUnion.textElementConfig;\n                            float naturalLineHeight = currentElement->childrenOrTextContent.textElementData->preferredDimensions.height;\n                            float finalLineHeight = textElementConfig->lineHeight > 0 ? (float)textElementConfig->lineHeight : naturalLineHeight;\n                            float lineHeightOffset = (finalLineHeight - naturalLineHeight) / 2;\n                            float yPosition = lineHeightOffset;\n                            for (int32_t lineIndex = 0; lineIndex < currentElement->childrenOrTextContent.textElementData->wrappedLines.length; ++lineIndex) {\n                                Clay__WrappedTextLine wrappedLine = currentElement->childrenOrTextContent.textElementData->wrappedLines.internalArray[lineIndex]; // todo range check\n                                if (wrappedLine.line.length == 0) {\n                                    yPosition += finalLineHeight;\n                                    continue;\n                                }\n                                Clay__AddRenderCommand(CLAY__INIT(Clay_RenderCommand) {\n                                    .boundingBox = { currentElementBoundingBox.x, currentElementBoundingBox.y + yPosition, wrappedLine.dimensions.width, wrappedLine.dimensions.height }, // TODO width\n                                    .config = configUnion,\n                                    .text = wrappedLine.line,\n                                    .id = Clay__HashNumber(lineIndex, currentElement->id).id,\n                                    .commandType = CLAY_RENDER_COMMAND_TYPE_TEXT,\n                                });\n                                yPosition += finalLineHeight;\n\n                                if (!context->disableCulling && (currentElementBoundingBox.y + yPosition > context->layoutDimensions.height)) {\n                                    break;\n                                }\n                            }\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_CUSTOM: {\n                            renderCommand.commandType = CLAY_RENDER_COMMAND_TYPE_CUSTOM;\n                            break;\n                        }\n                        default: break;\n                    }\n                    if (shouldRender) {\n                        Clay__AddRenderCommand(renderCommand);\n                    }\n                    if (offscreen) {\n                        // NOTE: You may be tempted to try an early return / continue if an element is off screen. Why bother calculating layout for its children, right?\n                        // Unfortunately, a FLOATING_CONTAINER may be defined that attaches to a child or grandchild of this element, which is large enough to still\n                        // be on screen, even if this element isn't. That depends on this element and it's children being laid out correctly (even if they are entirely off screen)\n                    }\n                }\n\n                // Setup initial on-axis alignment\n                if (!Clay__ElementHasConfig(currentElementTreeNode->layoutElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT)) {\n                    Clay_Dimensions contentSize = {0,0};\n                    if (layoutConfig->layoutDirection == CLAY_LEFT_TO_RIGHT) {\n                        for (int32_t i = 0; i < currentElement->childrenOrTextContent.children.length; ++i) {\n                            Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, currentElement->childrenOrTextContent.children.elements[i]);\n                            contentSize.width += childElement->dimensions.width;\n                            contentSize.height = CLAY__MAX(contentSize.height, childElement->dimensions.height);\n                        }\n                        contentSize.width += (float)(CLAY__MAX(currentElement->childrenOrTextContent.children.length - 1, 0) * layoutConfig->childGap);\n                        float extraSpace = currentElement->dimensions.width - (float)layoutConfig->padding.x * 2 - contentSize.width;\n                        switch (layoutConfig->childAlignment.x) {\n                            case CLAY_ALIGN_X_LEFT: extraSpace = 0; break;\n                            case CLAY_ALIGN_X_CENTER: extraSpace /= 2; break;\n                            default: break;\n                        }\n                        currentElementTreeNode->nextChildOffset.x += extraSpace;\n                    } else {\n                        for (int32_t i = 0; i < currentElement->childrenOrTextContent.children.length; ++i) {\n                            Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, currentElement->childrenOrTextContent.children.elements[i]);\n                            contentSize.width = CLAY__MAX(contentSize.width, childElement->dimensions.width);\n                            contentSize.height += childElement->dimensions.height;\n                        }\n                        contentSize.height += (float)(CLAY__MAX(currentElement->childrenOrTextContent.children.length - 1, 0) * layoutConfig->childGap);\n                        float extraSpace = currentElement->dimensions.height - (float)layoutConfig->padding.y * 2 - contentSize.height;\n                        switch (layoutConfig->childAlignment.y) {\n                            case CLAY_ALIGN_Y_TOP: extraSpace = 0; break;\n                            case CLAY_ALIGN_Y_CENTER: extraSpace /= 2; break;\n                            default: break;\n                        }\n                        currentElementTreeNode->nextChildOffset.y += extraSpace;\n                    }\n\n                    if (scrollContainerData) {\n                        scrollContainerData->contentSize = CLAY__INIT(Clay_Dimensions) { contentSize.width + (float)layoutConfig->padding.x * 2, contentSize.height + (float)layoutConfig->padding.y * 2 };\n                    }\n                }\n            }\n            else {\n                // DFS is returning upwards backwards\n                bool closeScrollElement = false;\n                if (Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER)) {\n                    closeScrollElement = true;\n                    Clay_ScrollElementConfig *scrollConfig = Clay__FindElementConfigWithType(currentElement, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER).scrollElementConfig;\n                    for (int32_t i = 0; i < context->scrollContainerDatas.length; i++) {\n                        Clay__ScrollContainerDataInternal *mapping = Clay__ScrollContainerDataInternalArray_Get(&context->scrollContainerDatas, i);\n                        if (mapping->layoutElement == currentElement) {\n                            if (scrollConfig->horizontal) { scrollOffset.x = mapping->scrollPosition.x; }\n                            if (scrollConfig->vertical) { scrollOffset.y = mapping->scrollPosition.y; }\n                            if (context->externalScrollHandlingEnabled) {\n                                scrollOffset = CLAY__INIT(Clay_Vector2) CLAY__DEFAULT_STRUCT;\n                            }\n                            break;\n                        }\n                    }\n                }\n\n                if (Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER)) {\n                    Clay_LayoutElementHashMapItem *currentElementData = Clay__GetHashMapItem(currentElement->id);\n                    Clay_BoundingBox currentElementBoundingBox = currentElementData->boundingBox;\n\n                    // Culling - Don't bother to generate render commands for rectangles entirely outside the screen - this won't stop their children from being rendered if they overflow\n                    if (!Clay__ElementIsOffscreen(&currentElementBoundingBox)) {\n                        Clay_BorderElementConfig *borderConfig = Clay__FindElementConfigWithType(currentElement, CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER).borderElementConfig;\n                        Clay_RenderCommand renderCommand = {\n                                .boundingBox = currentElementBoundingBox,\n                                .config = { .borderElementConfig = borderConfig },\n                                .id = Clay__RehashWithNumber(currentElement->id, 4),\n                                .commandType = CLAY_RENDER_COMMAND_TYPE_BORDER,\n                        };\n                        Clay__AddRenderCommand(renderCommand);\n                        if (borderConfig->betweenChildren.width > 0 && borderConfig->betweenChildren.color.a > 0) {\n                            Clay_RectangleElementConfig *rectangleConfig = Clay__StoreRectangleElementConfig(CLAY__INIT(Clay_RectangleElementConfig) {.color = borderConfig->betweenChildren.color});\n                            float halfGap = layoutConfig->childGap / 2;\n                            Clay_Vector2 borderOffset = { (float)layoutConfig->padding.x - halfGap, (float)layoutConfig->padding.y - halfGap };\n                            if (layoutConfig->layoutDirection == CLAY_LEFT_TO_RIGHT) {\n                                for (int32_t i = 0; i < currentElement->childrenOrTextContent.children.length; ++i) {\n                                    Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, currentElement->childrenOrTextContent.children.elements[i]);\n                                    if (i > 0) {\n                                        Clay__AddRenderCommand(CLAY__INIT(Clay_RenderCommand) {\n                                            .boundingBox = { currentElementBoundingBox.x + borderOffset.x + scrollOffset.x, currentElementBoundingBox.y + scrollOffset.y, (float)borderConfig->betweenChildren.width, currentElement->dimensions.height },\n                                            .config = { rectangleConfig },\n                                            .id = Clay__RehashWithNumber(currentElement->id, 5 + i),\n                                            .commandType = CLAY_RENDER_COMMAND_TYPE_RECTANGLE,\n                                        });\n                                    }\n                                    borderOffset.x += (childElement->dimensions.width + (float)layoutConfig->childGap);\n                                }\n                            } else {\n                                for (int32_t i = 0; i < currentElement->childrenOrTextContent.children.length; ++i) {\n                                    Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, currentElement->childrenOrTextContent.children.elements[i]);\n                                    if (i > 0) {\n                                        Clay__AddRenderCommand(CLAY__INIT(Clay_RenderCommand) {\n                                                .boundingBox = { currentElementBoundingBox.x + scrollOffset.x, currentElementBoundingBox.y + borderOffset.y + scrollOffset.y, currentElement->dimensions.width, (float)borderConfig->betweenChildren.width },\n                                                .config = { rectangleConfig },\n                                                .id = Clay__RehashWithNumber(currentElement->id, 5 + i),\n                                                .commandType = CLAY_RENDER_COMMAND_TYPE_RECTANGLE,\n                                        });\n                                    }\n                                    borderOffset.y += (childElement->dimensions.height + (float)layoutConfig->childGap);\n                                }\n                            }\n                        }\n                    }\n                }\n                // This exists because the scissor needs to end _after_ borders between elements\n                if (closeScrollElement) {\n                    Clay__AddRenderCommand(CLAY__INIT(Clay_RenderCommand) {\n                        .id = Clay__RehashWithNumber(currentElement->id, 11),\n                       .commandType = CLAY_RENDER_COMMAND_TYPE_SCISSOR_END,\n                    });\n                }\n\n                dfsBuffer.length--;\n                continue;\n            }\n\n            // Add children to the DFS buffer\n            if (!Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT)) {\n                dfsBuffer.length += currentElement->childrenOrTextContent.children.length;\n                for (int32_t i = 0; i < currentElement->childrenOrTextContent.children.length; ++i) {\n                    Clay_LayoutElement *childElement = Clay_LayoutElementArray_Get(&context->layoutElements, currentElement->childrenOrTextContent.children.elements[i]);\n                    // Alignment along non layout axis\n                    if (layoutConfig->layoutDirection == CLAY_LEFT_TO_RIGHT) {\n                        currentElementTreeNode->nextChildOffset.y = currentElement->layoutConfig->padding.y;\n                        float whiteSpaceAroundChild = currentElement->dimensions.height - (float)currentElement->layoutConfig->padding.y * 2 - childElement->dimensions.height;\n                        switch (layoutConfig->childAlignment.y) {\n                            case CLAY_ALIGN_Y_TOP: break;\n                            case CLAY_ALIGN_Y_CENTER: currentElementTreeNode->nextChildOffset.y += whiteSpaceAroundChild / 2; break;\n                            case CLAY_ALIGN_Y_BOTTOM: currentElementTreeNode->nextChildOffset.y += whiteSpaceAroundChild; break;\n                        }\n                    } else {\n                        currentElementTreeNode->nextChildOffset.x = currentElement->layoutConfig->padding.x;\n                        float whiteSpaceAroundChild = currentElement->dimensions.width - (float)currentElement->layoutConfig->padding.x * 2 - childElement->dimensions.width;\n                        switch (layoutConfig->childAlignment.x) {\n                            case CLAY_ALIGN_X_LEFT: break;\n                            case CLAY_ALIGN_X_CENTER: currentElementTreeNode->nextChildOffset.x += whiteSpaceAroundChild / 2; break;\n                            case CLAY_ALIGN_X_RIGHT: currentElementTreeNode->nextChildOffset.x += whiteSpaceAroundChild; break;\n                        }\n                    }\n\n                    Clay_Vector2 childPosition = {\n                        currentElementTreeNode->position.x + currentElementTreeNode->nextChildOffset.x + scrollOffset.x,\n                        currentElementTreeNode->position.y + currentElementTreeNode->nextChildOffset.y + scrollOffset.y,\n                    };\n\n                    // DFS buffer elements need to be added in reverse because stack traversal happens backwards\n                    uint32_t newNodeIndex = dfsBuffer.length - 1 - i;\n                    dfsBuffer.internalArray[newNodeIndex] = CLAY__INIT(Clay__LayoutElementTreeNode) {\n                        .layoutElement = childElement,\n                        .position = { childPosition.x, childPosition.y },\n                        .nextChildOffset = { .x = (float)childElement->layoutConfig->padding.x, .y = (float)childElement->layoutConfig->padding.y },\n                    };\n                    context->treeNodeVisited.internalArray[newNodeIndex] = false;\n\n                    // Update parent offsets\n                    if (layoutConfig->layoutDirection == CLAY_LEFT_TO_RIGHT) {\n                        currentElementTreeNode->nextChildOffset.x += childElement->dimensions.width + (float)layoutConfig->childGap;\n                    } else {\n                        currentElementTreeNode->nextChildOffset.y += childElement->dimensions.height + (float)layoutConfig->childGap;\n                    }\n                }\n            }\n        }\n\n        if (root->clipElementId) {\n            Clay__AddRenderCommand(CLAY__INIT(Clay_RenderCommand) { .id = Clay__RehashWithNumber(rootElement->id, 11), .commandType = CLAY_RENDER_COMMAND_TYPE_SCISSOR_END });\n        }\n    }\n}\n\nvoid Clay__AttachId(Clay_ElementId elementId) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->booleanWarnings.maxElementsExceeded) {\n        return;\n    }\n    Clay_LayoutElement *openLayoutElement = Clay__GetOpenLayoutElement();\n    openLayoutElement->id = elementId.id;\n    Clay__AddHashMapItem(elementId, openLayoutElement);\n    Clay__StringArray_Add(&context->layoutElementIdStrings, elementId.stringId);\n}\n\nvoid Clay__AttachLayoutConfig(Clay_LayoutConfig *config) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->booleanWarnings.maxElementsExceeded) {\n        return;\n    }\n    Clay__GetOpenLayoutElement()->layoutConfig = config;\n}\nvoid Clay__AttachElementConfig(Clay_ElementConfigUnion config, Clay__ElementConfigType type) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->booleanWarnings.maxElementsExceeded) {\n        return;\n    }\n    Clay_LayoutElement *openLayoutElement = Clay__GetOpenLayoutElement();\n    openLayoutElement->elementConfigs.length++;\n    Clay__ElementConfigArray_Add(&context->elementConfigBuffer, CLAY__INIT(Clay_ElementConfig) { .type = type, .config = config });\n}\nClay_LayoutConfig * Clay__StoreLayoutConfig(Clay_LayoutConfig config) {  return Clay_GetCurrentContext()->booleanWarnings.maxElementsExceeded ? &CLAY_LAYOUT_DEFAULT : Clay__LayoutConfigArray_Add(&Clay_GetCurrentContext()->layoutConfigs, config); }\nClay_RectangleElementConfig * Clay__StoreRectangleElementConfig(Clay_RectangleElementConfig config) {  return Clay_GetCurrentContext()->booleanWarnings.maxElementsExceeded ? &CLAY__RECTANGLE_ELEMENT_CONFIG_DEFAULT : Clay__RectangleElementConfigArray_Add(&Clay_GetCurrentContext()->rectangleElementConfigs, config); }\nClay_TextElementConfig * Clay__StoreTextElementConfig(Clay_TextElementConfig config) {  return Clay_GetCurrentContext()->booleanWarnings.maxElementsExceeded ? &CLAY__TEXT_ELEMENT_CONFIG_DEFAULT : Clay__TextElementConfigArray_Add(&Clay_GetCurrentContext()->textElementConfigs, config); }\nClay_ImageElementConfig * Clay__StoreImageElementConfig(Clay_ImageElementConfig config) {  return Clay_GetCurrentContext()->booleanWarnings.maxElementsExceeded ? &CLAY__IMAGE_ELEMENT_CONFIG_DEFAULT : Clay__ImageElementConfigArray_Add(&Clay_GetCurrentContext()->imageElementConfigs, config); }\nClay_FloatingElementConfig * Clay__StoreFloatingElementConfig(Clay_FloatingElementConfig config) {  return Clay_GetCurrentContext()->booleanWarnings.maxElementsExceeded ? &CLAY__FLOATING_ELEMENT_CONFIG_DEFAULT : Clay__FloatingElementConfigArray_Add(&Clay_GetCurrentContext()->floatingElementConfigs, config); }\nClay_CustomElementConfig * Clay__StoreCustomElementConfig(Clay_CustomElementConfig config) {  return Clay_GetCurrentContext()->booleanWarnings.maxElementsExceeded ? &CLAY__CUSTOM_ELEMENT_CONFIG_DEFAULT : Clay__CustomElementConfigArray_Add(&Clay_GetCurrentContext()->customElementConfigs, config); }\nClay_ScrollElementConfig * Clay__StoreScrollElementConfig(Clay_ScrollElementConfig config) {  return Clay_GetCurrentContext()->booleanWarnings.maxElementsExceeded ? &CLAY__SCROLL_ELEMENT_CONFIG_DEFAULT : Clay__ScrollElementConfigArray_Add(&Clay_GetCurrentContext()->scrollElementConfigs, config); }\nClay_BorderElementConfig * Clay__StoreBorderElementConfig(Clay_BorderElementConfig config) {  return Clay_GetCurrentContext()->booleanWarnings.maxElementsExceeded ? &CLAY__BORDER_ELEMENT_CONFIG_DEFAULT : Clay__BorderElementConfigArray_Add(&Clay_GetCurrentContext()->borderElementConfigs, config); }\n\n#pragma region DebugTools\nClay_Color CLAY__DEBUGVIEW_COLOR_1 = {58, 56, 52, 255};\nClay_Color CLAY__DEBUGVIEW_COLOR_2 = {62, 60, 58, 255};\nClay_Color CLAY__DEBUGVIEW_COLOR_3 = {141, 133, 135, 255};\nClay_Color CLAY__DEBUGVIEW_COLOR_4 = {238, 226, 231, 255};\nClay_Color CLAY__DEBUGVIEW_COLOR_SELECTED_ROW = {102, 80, 78, 255};\nconst int32_t CLAY__DEBUGVIEW_ROW_HEIGHT = 30;\nconst int32_t CLAY__DEBUGVIEW_OUTER_PADDING = 10;\nconst int32_t CLAY__DEBUGVIEW_INDENT_WIDTH = 16;\nClay_TextElementConfig Clay__DebugView_TextNameConfig = {.textColor = {238, 226, 231, 255}, .fontSize = 16, .wrapMode = CLAY_TEXT_WRAP_NONE };\nClay_LayoutConfig Clay__DebugView_ScrollViewItemLayoutConfig = CLAY__DEFAULT_STRUCT;\n\nCLAY__TYPEDEF(Clay__DebugElementConfigTypeLabelConfig, struct {\n    Clay_String label;\n    Clay_Color color;\n});\n\nClay__DebugElementConfigTypeLabelConfig Clay__DebugGetElementConfigTypeLabel(Clay__ElementConfigType type) {\n    switch (type) {\n        case CLAY__ELEMENT_CONFIG_TYPE_RECTANGLE: return CLAY__INIT(Clay__DebugElementConfigTypeLabelConfig) { CLAY_STRING(\"Rectangle\"), {243,134,48,255} };\n        case CLAY__ELEMENT_CONFIG_TYPE_TEXT: return CLAY__INIT(Clay__DebugElementConfigTypeLabelConfig) { CLAY_STRING(\"Text\"), {105,210,231,255} };\n        case CLAY__ELEMENT_CONFIG_TYPE_IMAGE: return CLAY__INIT(Clay__DebugElementConfigTypeLabelConfig) { CLAY_STRING(\"Image\"), {121,189,154,255} };\n        case CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER: return CLAY__INIT(Clay__DebugElementConfigTypeLabelConfig) { CLAY_STRING(\"Floating\"), {250,105,0,255} };\n        case CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER: return CLAY__INIT(Clay__DebugElementConfigTypeLabelConfig) { CLAY_STRING(\"Scroll\"), {242,196,90,255} };\n        case CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER: return CLAY__INIT(Clay__DebugElementConfigTypeLabelConfig) { CLAY_STRING(\"Border\"), {108,91,123, 255} };\n        case CLAY__ELEMENT_CONFIG_TYPE_CUSTOM: return CLAY__INIT(Clay__DebugElementConfigTypeLabelConfig) { CLAY_STRING(\"Custom\"), {11,72,107,255} };\n        default: break;\n    }\n    return CLAY__INIT(Clay__DebugElementConfigTypeLabelConfig) { CLAY_STRING(\"Error\"), {0,0,0,255} };\n}\n\nCLAY__TYPEDEF(Clay__RenderDebugLayoutData, struct {\n    int32_t rowCount;\n    int32_t selectedElementRowIndex;\n});\n\n// Returns row count\nClay__RenderDebugLayoutData Clay__RenderDebugLayoutElementsList(int32_t initialRootsLength, int32_t highlightedRowIndex) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    Clay__int32_tArray dfsBuffer = context->reusableElementIndexBuffer;\n    Clay__DebugView_ScrollViewItemLayoutConfig = CLAY__INIT(Clay_LayoutConfig) { .sizing = { .height = CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT) }, .childGap = 6, .childAlignment = { .y = CLAY_ALIGN_Y_CENTER }};\n    Clay__RenderDebugLayoutData layoutData = CLAY__DEFAULT_STRUCT;\n\n    uint32_t highlightedElementId = 0;\n\n    for (int32_t rootIndex = 0; rootIndex < initialRootsLength; ++rootIndex) {\n        dfsBuffer.length = 0;\n        Clay__LayoutElementTreeRoot *root = Clay__LayoutElementTreeRootArray_Get(&context->layoutElementTreeRoots, rootIndex);\n        Clay__int32_tArray_Add(&dfsBuffer, (int32_t)root->layoutElementIndex);\n        context->treeNodeVisited.internalArray[0] = false;\n        if (rootIndex > 0) {\n            CLAY(CLAY_IDI(\"Clay__DebugView_EmptyRowOuter\", rootIndex), CLAY_LAYOUT({ .sizing = {.width = CLAY_SIZING_GROW(0)}, .padding = {CLAY__DEBUGVIEW_INDENT_WIDTH / 2, 0} })) {\n                CLAY(CLAY_IDI(\"Clay__DebugView_EmptyRow\", rootIndex), CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_GROW(0), .height = CLAY_SIZING_FIXED((float)CLAY__DEBUGVIEW_ROW_HEIGHT) }}), CLAY_BORDER({ .top = { .width = 1, .color = CLAY__DEBUGVIEW_COLOR_3 } })) {}\n            }\n            layoutData.rowCount++;\n        }\n        while (dfsBuffer.length > 0) {\n            int32_t currentElementIndex = Clay__int32_tArray_Get(&dfsBuffer, (int)dfsBuffer.length - 1);\n            Clay_LayoutElement *currentElement = Clay_LayoutElementArray_Get(&context->layoutElements, (int)currentElementIndex);\n            if (context->treeNodeVisited.internalArray[dfsBuffer.length - 1]) {\n                if (!Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT) && currentElement->childrenOrTextContent.children.length > 0) {\n                    Clay__CloseElement();\n                    Clay__CloseElement();\n                    Clay__CloseElement();\n                }\n                dfsBuffer.length--;\n                continue;\n            }\n\n            if (highlightedRowIndex == layoutData.rowCount) {\n                if (context->pointerInfo.state == CLAY_POINTER_DATA_PRESSED_THIS_FRAME) {\n                    context->debugSelectedElementId = currentElement->id;\n                }\n                highlightedElementId = currentElement->id;\n            }\n\n            context->treeNodeVisited.internalArray[dfsBuffer.length - 1] = true;\n            Clay_LayoutElementHashMapItem *currentElementData = Clay__GetHashMapItem(currentElement->id);\n            bool offscreen = Clay__ElementIsOffscreen(&currentElementData->boundingBox);\n            if (context->debugSelectedElementId == currentElement->id) {\n                layoutData.selectedElementRowIndex = layoutData.rowCount;\n            }\n            CLAY(CLAY_IDI(\"Clay__DebugView_ElementOuter\", currentElement->id), Clay__AttachLayoutConfig(&Clay__DebugView_ScrollViewItemLayoutConfig)) {\n                // Collapse icon / button\n                if (!(Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT) || currentElement->childrenOrTextContent.children.length == 0)) {\n                    CLAY(CLAY_IDI(\"Clay__DebugView_CollapseElement\", currentElement->id),\n                        CLAY_LAYOUT({ .sizing = {CLAY_SIZING_FIXED(16), CLAY_SIZING_FIXED(16)}, .childAlignment = { CLAY_ALIGN_X_CENTER, CLAY_ALIGN_Y_CENTER} }),\n                        CLAY_BORDER_OUTSIDE_RADIUS(1, CLAY__DEBUGVIEW_COLOR_3, 4)\n                    ) {\n                        CLAY_TEXT((currentElementData && currentElementData->debugData->collapsed) ? CLAY_STRING(\"+\") : CLAY_STRING(\"-\"), CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_4, .fontSize = 16 }));\n                    }\n                } else { // Square dot for empty containers\n                    CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_FIXED(16), CLAY_SIZING_FIXED(16)}, .childAlignment = { CLAY_ALIGN_X_CENTER, CLAY_ALIGN_Y_CENTER } })) {\n                        CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_FIXED(8), CLAY_SIZING_FIXED(8)} }), CLAY_RECTANGLE({ .color = CLAY__DEBUGVIEW_COLOR_3, .cornerRadius = CLAY_CORNER_RADIUS(2) })) {}\n                    }\n                }\n                // Collisions and offscreen info\n                if (currentElementData) {\n                    if (currentElementData->debugData->collision) {\n                        CLAY(CLAY_LAYOUT({ .padding = { 8, 2 } }), CLAY_BORDER_OUTSIDE_RADIUS(1, (CLAY__INIT(Clay_Color){177, 147, 8, 255}), 4)) {\n                            CLAY_TEXT(CLAY_STRING(\"Duplicate ID\"), CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_3, .fontSize = 16 }));\n                        }\n                    }\n                    if (offscreen) {\n                        CLAY(CLAY_LAYOUT({ .padding = { 8, 2 } }), CLAY_BORDER_OUTSIDE_RADIUS(1, CLAY__DEBUGVIEW_COLOR_3, 4)) {\n                            CLAY_TEXT(CLAY_STRING(\"Offscreen\"), CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_3, .fontSize = 16 }));\n                        }\n                    }\n                }\n                Clay_String idString = context->layoutElementIdStrings.internalArray[currentElementIndex];\n                if (idString.length > 0) {\n                    CLAY_TEXT(idString, offscreen ? CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_3, .fontSize = 16 }) : &Clay__DebugView_TextNameConfig);\n                }\n                for (int32_t elementConfigIndex = 0; elementConfigIndex < currentElement->elementConfigs.length; ++elementConfigIndex) {\n                    Clay_ElementConfig *elementConfig = Clay__ElementConfigArraySlice_Get(&currentElement->elementConfigs, elementConfigIndex);\n                    Clay__DebugElementConfigTypeLabelConfig config = Clay__DebugGetElementConfigTypeLabel(elementConfig->type);\n                    Clay_Color backgroundColor = config.color;\n                    backgroundColor.a = 90;\n                    CLAY(CLAY_LAYOUT({ .padding = { 8, 2 } }), CLAY_RECTANGLE({ .color = backgroundColor, .cornerRadius = CLAY_CORNER_RADIUS(4) }), CLAY_BORDER_OUTSIDE_RADIUS(1, config.color, 4)) {\n                        CLAY_TEXT(config.label, CLAY_TEXT_CONFIG({ .textColor = offscreen ? CLAY__DEBUGVIEW_COLOR_3 : CLAY__DEBUGVIEW_COLOR_4, .fontSize = 16 }));\n                    }\n                }\n            }\n\n            // Render the text contents below the element as a non-interactive row\n            if (Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT)) {\n                layoutData.rowCount++;\n                Clay__TextElementData *textElementData = currentElement->childrenOrTextContent.textElementData;\n                Clay_TextElementConfig *rawTextConfig = offscreen ? CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_3, .fontSize = 16 }) : &Clay__DebugView_TextNameConfig;\n                CLAY(CLAY_LAYOUT({ .sizing = { .height = CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT)}, .childAlignment = { .y = CLAY_ALIGN_Y_CENTER } }), CLAY_RECTANGLE(CLAY__DEFAULT_STRUCT)) {\n                    CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_INDENT_WIDTH + 16), CLAY__DEFAULT_STRUCT} })) {}\n                    CLAY_TEXT(CLAY_STRING(\"\\\"\"), rawTextConfig);\n                    CLAY_TEXT(textElementData->text.length > 40 ? (CLAY__INIT(Clay_String) { .length = 40, .chars = textElementData->text.chars }) : textElementData->text, rawTextConfig);\n                    if (textElementData->text.length > 40) {\n                        CLAY_TEXT(CLAY_STRING(\"...\"), rawTextConfig);\n                    }\n                    CLAY_TEXT(CLAY_STRING(\"\\\"\"), rawTextConfig);\n                }\n            } else if (currentElement->childrenOrTextContent.children.length > 0) {\n                Clay__OpenElement();\n                CLAY_LAYOUT({ .padding = { 8 , 0} });\n                Clay__ElementPostConfiguration();\n                Clay__OpenElement();\n                CLAY_BORDER({ .left = { .width = 1, .color = CLAY__DEBUGVIEW_COLOR_3 }});\n                Clay__ElementPostConfiguration();\n                CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_FIXED( CLAY__DEBUGVIEW_INDENT_WIDTH), CLAY__DEFAULT_STRUCT}, .childAlignment = { .x = CLAY_ALIGN_X_RIGHT } })) {}\n                Clay__OpenElement();\n                CLAY_LAYOUT({ .layoutDirection = CLAY_TOP_TO_BOTTOM });\n                Clay__ElementPostConfiguration();\n            }\n\n            layoutData.rowCount++;\n            if (!(Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT) || (currentElementData && currentElementData->debugData->collapsed))) {\n                for (int32_t i = currentElement->childrenOrTextContent.children.length - 1; i >= 0; --i) {\n                    Clay__int32_tArray_Add(&dfsBuffer, currentElement->childrenOrTextContent.children.elements[i]);\n                    context->treeNodeVisited.internalArray[dfsBuffer.length - 1] = false; // TODO needs to be ranged checked\n                }\n            }\n        }\n    }\n\n    if (context->pointerInfo.state == CLAY_POINTER_DATA_PRESSED_THIS_FRAME) {\n        Clay_ElementId collapseButtonId = Clay__HashString(CLAY_STRING(\"Clay__DebugView_CollapseElement\"), 0, 0);\n        for (int32_t i = (int)context->pointerOverIds.length - 1; i >= 0; i--) {\n            Clay_ElementId *elementId = Clay__ElementIdArray_Get(&context->pointerOverIds, i);\n            if (elementId->baseId == collapseButtonId.baseId) {\n                Clay_LayoutElementHashMapItem *highlightedItem = Clay__GetHashMapItem(elementId->offset);\n                highlightedItem->debugData->collapsed = !highlightedItem->debugData->collapsed;\n                break;\n            }\n        }\n    }\n\n    if (highlightedElementId) {\n        CLAY(CLAY_ID(\"Clay__DebugView_ElementHighlight\"), CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_GROW(0)} }), CLAY_FLOATING({ .zIndex = 65535, .parentId = highlightedElementId })) {\n            CLAY(CLAY_ID(\"Clay__DebugView_ElementHighlightRectangle\"), CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_GROW(0)} }), CLAY_RECTANGLE({.color = Clay__debugViewHighlightColor })) {}\n        }\n    }\n    return layoutData;\n}\n\nvoid Clay__RenderDebugLayoutSizing(Clay_SizingAxis sizing, Clay_TextElementConfig *infoTextConfig) {\n    Clay_String sizingLabel = CLAY_STRING(\"GROW\");\n    if (sizing.type == CLAY__SIZING_TYPE_FIT) {\n        sizingLabel = CLAY_STRING(\"FIT\");\n    } else if (sizing.type == CLAY__SIZING_TYPE_PERCENT) {\n        sizingLabel = CLAY_STRING(\"PERCENT\");\n    }\n    CLAY_TEXT(sizingLabel, infoTextConfig);\n    if (sizing.type == CLAY__SIZING_TYPE_GROW || sizing.type == CLAY__SIZING_TYPE_FIT) {\n        CLAY_TEXT(CLAY_STRING(\"(\"), infoTextConfig);\n        if (sizing.size.minMax.min != 0) {\n            CLAY_TEXT(CLAY_STRING(\"min: \"), infoTextConfig);\n            CLAY_TEXT(Clay__IntToString(sizing.size.minMax.min), infoTextConfig);\n            if (sizing.size.minMax.max != CLAY__MAXFLOAT) {\n                CLAY_TEXT(CLAY_STRING(\", \"), infoTextConfig);\n            }\n        }\n        if (sizing.size.minMax.max != CLAY__MAXFLOAT) {\n            CLAY_TEXT(CLAY_STRING(\"max: \"), infoTextConfig);\n            CLAY_TEXT(Clay__IntToString(sizing.size.minMax.max), infoTextConfig);\n        }\n        CLAY_TEXT(CLAY_STRING(\")\"), infoTextConfig);\n    }\n}\n\nvoid Clay__RenderDebugViewElementConfigHeader(Clay_String elementId, Clay__ElementConfigType type) {\n    Clay__DebugElementConfigTypeLabelConfig config = Clay__DebugGetElementConfigTypeLabel(type);\n    Clay_Color backgroundColor = config.color;\n    backgroundColor.a = 90;\n    CLAY(CLAY_LAYOUT({ .sizing = { CLAY_SIZING_GROW(0), CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT + 8)}, .padding = { .x = CLAY__DEBUGVIEW_OUTER_PADDING }, .childAlignment = { .y = CLAY_ALIGN_Y_CENTER } })) {\n        CLAY(CLAY_LAYOUT({ .padding = { 8, 2 } }), CLAY_RECTANGLE({ .color = backgroundColor, .cornerRadius = CLAY_CORNER_RADIUS(4) }), CLAY_BORDER_OUTSIDE_RADIUS(1, config.color, 4)) {\n            CLAY_TEXT(config.label, CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_4, .fontSize = 16 }));\n        }\n        CLAY(CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_GROW(0) } })) {}\n        CLAY_TEXT(elementId, CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_3, .fontSize = 16, .wrapMode = CLAY_TEXT_WRAP_NONE }));\n    }\n}\n\nvoid Clay__RenderDebugViewColor(Clay_Color color, Clay_TextElementConfig *textConfig) {\n    CLAY(CLAY_LAYOUT({ .childAlignment = {.y = CLAY_ALIGN_Y_CENTER} })) {\n        CLAY_TEXT(CLAY_STRING(\"{ r: \"), textConfig);\n        CLAY_TEXT(Clay__IntToString(color.r), textConfig);\n        CLAY_TEXT(CLAY_STRING(\", g: \"), textConfig);\n        CLAY_TEXT(Clay__IntToString(color.g), textConfig);\n        CLAY_TEXT(CLAY_STRING(\", b: \"), textConfig);\n        CLAY_TEXT(Clay__IntToString(color.b), textConfig);\n        CLAY_TEXT(CLAY_STRING(\", a: \"), textConfig);\n        CLAY_TEXT(Clay__IntToString(color.a), textConfig);\n        CLAY_TEXT(CLAY_STRING(\" }\"), textConfig);\n        CLAY(CLAY_LAYOUT({ .sizing = { CLAY_SIZING_FIXED(10), CLAY__DEFAULT_STRUCT } })) {}\n        CLAY(CLAY_LAYOUT({ .sizing = { CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT - 8), CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT - 8)} }), CLAY_BORDER_OUTSIDE_RADIUS(1, CLAY__DEBUGVIEW_COLOR_4, 4)) {\n            CLAY(CLAY_LAYOUT({ .sizing = { CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT - 8), CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT - 8)} }), CLAY_RECTANGLE({ .color = color, .cornerRadius = CLAY_CORNER_RADIUS(4) })) {}\n        }\n    }\n}\n\nvoid Clay__RenderDebugViewCornerRadius(Clay_CornerRadius cornerRadius, Clay_TextElementConfig *textConfig) {\n    CLAY(CLAY_LAYOUT({ .childAlignment = {.y = CLAY_ALIGN_Y_CENTER} })) {\n        CLAY_TEXT(CLAY_STRING(\"{ topLeft: \"), textConfig);\n        CLAY_TEXT(Clay__IntToString(cornerRadius.topLeft), textConfig);\n        CLAY_TEXT(CLAY_STRING(\", topRight: \"), textConfig);\n        CLAY_TEXT(Clay__IntToString(cornerRadius.topRight), textConfig);\n        CLAY_TEXT(CLAY_STRING(\", bottomLeft: \"), textConfig);\n        CLAY_TEXT(Clay__IntToString(cornerRadius.bottomLeft), textConfig);\n        CLAY_TEXT(CLAY_STRING(\", bottomRight: \"), textConfig);\n        CLAY_TEXT(Clay__IntToString(cornerRadius.bottomRight), textConfig);\n        CLAY_TEXT(CLAY_STRING(\" }\"), textConfig);\n    }\n}\n\nvoid Clay__RenderDebugViewBorder(int32_t index, Clay_Border border, Clay_TextElementConfig *textConfig) {\n    (void) index;\n    CLAY(CLAY_LAYOUT({ .childAlignment = {.y = CLAY_ALIGN_Y_CENTER} })) {\n        CLAY_TEXT(CLAY_STRING(\"{ width: \"), textConfig);\n        CLAY_TEXT(Clay__IntToString(border.width), textConfig);\n        CLAY_TEXT(CLAY_STRING(\", color: \"), textConfig);\n        Clay__RenderDebugViewColor(border.color, textConfig);\n        CLAY_TEXT(CLAY_STRING(\" }\"), textConfig);\n    }\n}\n\nvoid HandleDebugViewCloseButtonInteraction(Clay_ElementId elementId, Clay_PointerData pointerInfo, intptr_t userData) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    (void) elementId; (void) pointerInfo; (void) userData;\n    if (pointerInfo.state == CLAY_POINTER_DATA_PRESSED_THIS_FRAME) {\n        context->debugModeEnabled = false;\n    }\n}\n\nvoid Clay__RenderDebugView() {\n    Clay_Context* context = Clay_GetCurrentContext();\n    Clay_ElementId closeButtonId = Clay__HashString(CLAY_STRING(\"Clay__DebugViewTopHeaderCloseButtonOuter\"), 0, 0);\n    if (context->pointerInfo.state == CLAY_POINTER_DATA_PRESSED_THIS_FRAME) {\n        for (int32_t i = 0; i < context->pointerOverIds.length; ++i) {\n            Clay_ElementId *elementId = Clay__ElementIdArray_Get(&context->pointerOverIds, i);\n            if (elementId->id == closeButtonId.id) {\n                context->debugModeEnabled = false;\n                return;\n            }\n        }\n    }\n\n    uint32_t initialRootsLength = context->layoutElementTreeRoots.length;\n    uint32_t initialElementsLength = context->layoutElements.length;\n    Clay_TextElementConfig *infoTextConfig = CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_4, .fontSize = 16, .wrapMode = CLAY_TEXT_WRAP_NONE });\n    Clay_TextElementConfig *infoTitleConfig = CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_3, .fontSize = 16, .wrapMode = CLAY_TEXT_WRAP_NONE });\n    Clay_ElementId scrollId = Clay__HashString(CLAY_STRING(\"Clay__DebugViewOuterScrollPane\"), 0, 0);\n    float scrollYOffset = 0;\n    bool pointerInDebugView = context->pointerInfo.position.y < context->layoutDimensions.height - 300;\n    for (int32_t i = 0; i < context->scrollContainerDatas.length; ++i) {\n        Clay__ScrollContainerDataInternal *scrollContainerData = Clay__ScrollContainerDataInternalArray_Get(&context->scrollContainerDatas, i);\n        if (scrollContainerData->elementId == scrollId.id) {\n            if (!context->externalScrollHandlingEnabled) {\n                scrollYOffset = scrollContainerData->scrollPosition.y;\n            } else {\n                pointerInDebugView = context->pointerInfo.position.y + scrollContainerData->scrollPosition.y < context->layoutDimensions.height - 300;\n            }\n            break;\n        }\n    }\n    int32_t highlightedRow = pointerInDebugView\n            ? (int32_t)((context->pointerInfo.position.y - scrollYOffset) / (float)CLAY__DEBUGVIEW_ROW_HEIGHT) - 1\n            : -1;\n    if (context->pointerInfo.position.x < context->layoutDimensions.width - (float)Clay__debugViewWidth) {\n        highlightedRow = -1;\n    }\n    Clay__RenderDebugLayoutData layoutData = CLAY__DEFAULT_STRUCT;\n    CLAY(CLAY_ID(\"Clay__DebugView\"),\n        CLAY_FLOATING({ .zIndex = 65000, .parentId = Clay__HashString(CLAY_STRING(\"Clay__RootContainer\"), 0, 0).id, .attachment = { .element = CLAY_ATTACH_POINT_LEFT_CENTER, .parent = CLAY_ATTACH_POINT_RIGHT_CENTER }}),\n        CLAY_LAYOUT({ .sizing = { CLAY_SIZING_FIXED((float)Clay__debugViewWidth) , CLAY_SIZING_FIXED(context->layoutDimensions.height) }, .layoutDirection = CLAY_TOP_TO_BOTTOM }),\n        CLAY_BORDER({ .bottom = { .width = 1, .color = CLAY__DEBUGVIEW_COLOR_3 }})\n    ) {\n        CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT)}, .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 0}, .childAlignment = {.y = CLAY_ALIGN_Y_CENTER} }), CLAY_RECTANGLE({ .color = CLAY__DEBUGVIEW_COLOR_2 })) {\n            CLAY_TEXT(CLAY_STRING(\"Clay Debug Tools\"), infoTextConfig);\n            CLAY(CLAY_LAYOUT({ .sizing = { CLAY_SIZING_GROW(0) } })) {}\n            // Close button\n            CLAY(CLAY_BORDER_OUTSIDE_RADIUS(1, (CLAY__INIT(Clay_Color){217,91,67,255}), 4),\n                CLAY_LAYOUT({ .sizing = {CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT - 10), CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT - 10)}, .childAlignment = {CLAY_ALIGN_X_CENTER, CLAY_ALIGN_Y_CENTER} }),\n                CLAY_RECTANGLE({ .color = {217,91,67,80} }),\n                Clay_OnHover(HandleDebugViewCloseButtonInteraction, 0)\n            ) {\n                CLAY_TEXT(CLAY_STRING(\"x\"), CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_4, .fontSize = 16 }));\n            }\n        }\n        CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_FIXED(1)} }), CLAY_RECTANGLE({ .color = CLAY__DEBUGVIEW_COLOR_3 })) {}\n        CLAY(Clay__AttachId(scrollId), CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_GROW(0)} }), CLAY_SCROLL({ .horizontal = true, .vertical = true })) {\n            CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_GROW(0)}, .layoutDirection = CLAY_TOP_TO_BOTTOM }), CLAY_RECTANGLE({ .color = ((initialElementsLength + initialRootsLength) & 1) == 0 ? CLAY__DEBUGVIEW_COLOR_2 : CLAY__DEBUGVIEW_COLOR_1 })) {\n                Clay_ElementId panelContentsId = Clay__HashString(CLAY_STRING(\"Clay__DebugViewPaneOuter\"), 0, 0);\n                // Element list\n                CLAY(Clay__AttachId(panelContentsId), CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_GROW(0)} }), CLAY_FLOATING({ .zIndex = 65001, .pointerCaptureMode = CLAY_POINTER_CAPTURE_MODE_PASSTHROUGH })) {\n                    CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_GROW(0)}, .padding = {.x = CLAY__DEBUGVIEW_OUTER_PADDING }, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {\n                        layoutData = Clay__RenderDebugLayoutElementsList((int32_t)initialRootsLength, highlightedRow);\n                    }\n                }\n                float contentWidth = Clay__GetHashMapItem(panelContentsId.id)->layoutElement->dimensions.width;\n                CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_FIXED(contentWidth), CLAY__DEFAULT_STRUCT}, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {}\n                for (int32_t i = 0; i < layoutData.rowCount; i++) {\n                    Clay_Color rowColor = (i & 1) == 0 ? CLAY__DEBUGVIEW_COLOR_2 : CLAY__DEBUGVIEW_COLOR_1;\n                    if (i == layoutData.selectedElementRowIndex) {\n                        rowColor = CLAY__DEBUGVIEW_COLOR_SELECTED_ROW;\n                    }\n                    if (i == highlightedRow) {\n                        rowColor.r *= 1.25f;\n                        rowColor.g *= 1.25f;\n                        rowColor.b *= 1.25f;\n                    }\n                    CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT)}, .layoutDirection = CLAY_TOP_TO_BOTTOM }), CLAY_RECTANGLE({ .color = rowColor })) {}\n                }\n            }\n        }\n        CLAY(CLAY_LAYOUT({ .sizing = {.width = CLAY_SIZING_GROW(0), .height = CLAY_SIZING_FIXED(1)} }), CLAY_RECTANGLE({ .color = CLAY__DEBUGVIEW_COLOR_3 })) {}\n        if (context->debugSelectedElementId != 0) {\n            Clay_LayoutElementHashMapItem *selectedItem = Clay__GetHashMapItem(context->debugSelectedElementId);\n            CLAY(\n                CLAY_SCROLL({ .vertical = true }),\n                CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_FIXED(300)}, .layoutDirection = CLAY_TOP_TO_BOTTOM }),\n                CLAY_RECTANGLE({ .color = CLAY__DEBUGVIEW_COLOR_2 }),\n                CLAY_BORDER({ .betweenChildren = { .width = 1, .color = CLAY__DEBUGVIEW_COLOR_3 }})\n            ) {\n                CLAY(CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT + 8)}, .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 0}, .childAlignment = {.y = CLAY_ALIGN_Y_CENTER} })) {\n                    CLAY_TEXT(CLAY_STRING(\"Layout Config\"), infoTextConfig);\n                    CLAY(CLAY_LAYOUT({ .sizing = { CLAY_SIZING_GROW(0) } })) {}\n                    if (selectedItem->elementId.stringId.length != 0) {\n                        CLAY_TEXT(selectedItem->elementId.stringId, infoTitleConfig);\n                        if (selectedItem->elementId.offset != 0) {\n                            CLAY_TEXT(CLAY_STRING(\" (\"), infoTitleConfig);\n                            CLAY_TEXT(Clay__IntToString(selectedItem->elementId.offset), infoTitleConfig);\n                            CLAY_TEXT(CLAY_STRING(\")\"), infoTitleConfig);\n                        }\n                    }\n                }\n                // Clay_LayoutConfig debug info\n                CLAY(CLAY_LAYOUT({ .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 8}, .childGap = 8, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {\n                    // .boundingBox\n                    CLAY_TEXT(CLAY_STRING(\"Bounding Box\"), infoTitleConfig);\n                    CLAY(CLAY_LAYOUT(CLAY__DEFAULT_STRUCT)) {\n                        CLAY_TEXT(CLAY_STRING(\"{ x: \"), infoTextConfig);\n                        CLAY_TEXT(Clay__IntToString(selectedItem->boundingBox.x), infoTextConfig);\n                        CLAY_TEXT(CLAY_STRING(\", y: \"), infoTextConfig);\n                        CLAY_TEXT(Clay__IntToString(selectedItem->boundingBox.y), infoTextConfig);\n                        CLAY_TEXT(CLAY_STRING(\", width: \"), infoTextConfig);\n                        CLAY_TEXT(Clay__IntToString(selectedItem->boundingBox.width), infoTextConfig);\n                        CLAY_TEXT(CLAY_STRING(\", height: \"), infoTextConfig);\n                        CLAY_TEXT(Clay__IntToString(selectedItem->boundingBox.height), infoTextConfig);\n                        CLAY_TEXT(CLAY_STRING(\" }\"), infoTextConfig);\n                    }\n                    // .layoutDirection\n                    CLAY_TEXT(CLAY_STRING(\"Layout Direction\"), infoTitleConfig);\n                    Clay_LayoutConfig *layoutConfig = selectedItem->layoutElement->layoutConfig;\n                    CLAY_TEXT(layoutConfig->layoutDirection == CLAY_TOP_TO_BOTTOM ? CLAY_STRING(\"TOP_TO_BOTTOM\") : CLAY_STRING(\"LEFT_TO_RIGHT\"), infoTextConfig);\n                    // .sizing\n                    CLAY_TEXT(CLAY_STRING(\"Sizing\"), infoTitleConfig);\n                    CLAY(CLAY_LAYOUT(CLAY__DEFAULT_STRUCT)) {\n                        CLAY_TEXT(CLAY_STRING(\"width: \"), infoTextConfig);\n                        Clay__RenderDebugLayoutSizing(layoutConfig->sizing.width, infoTextConfig);\n                    }\n                    CLAY(CLAY_LAYOUT(CLAY__DEFAULT_STRUCT)) {\n                        CLAY_TEXT(CLAY_STRING(\"height: \"), infoTextConfig);\n                        Clay__RenderDebugLayoutSizing(layoutConfig->sizing.height, infoTextConfig);\n                    }\n                    // .padding\n                    CLAY_TEXT(CLAY_STRING(\"Padding\"), infoTitleConfig);\n                    CLAY(CLAY_ID(\"Clay__DebugViewElementInfoPadding\")) {\n                        CLAY_TEXT(CLAY_STRING(\"{ x: \"), infoTextConfig);\n                        CLAY_TEXT(Clay__IntToString(layoutConfig->padding.x), infoTextConfig);\n                        CLAY_TEXT(CLAY_STRING(\", y: \"), infoTextConfig);\n                        CLAY_TEXT(Clay__IntToString(layoutConfig->padding.y), infoTextConfig);\n                        CLAY_TEXT(CLAY_STRING(\" }\"), infoTextConfig);\n                    }\n                    // .childGap\n                    CLAY_TEXT(CLAY_STRING(\"Child Gap\"), infoTitleConfig);\n                    CLAY_TEXT(Clay__IntToString(layoutConfig->childGap), infoTextConfig);\n                    // .childAlignment\n                    CLAY_TEXT(CLAY_STRING(\"Child Alignment\"), infoTitleConfig);\n                    CLAY(CLAY_LAYOUT(CLAY__DEFAULT_STRUCT)) {\n                        CLAY_TEXT(CLAY_STRING(\"{ x: \"), infoTextConfig);\n                        Clay_String alignX = CLAY_STRING(\"LEFT\");\n                        if (layoutConfig->childAlignment.x == CLAY_ALIGN_X_CENTER) {\n                            alignX = CLAY_STRING(\"CENTER\");\n                        } else if (layoutConfig->childAlignment.x == CLAY_ALIGN_X_RIGHT) {\n                            alignX = CLAY_STRING(\"RIGHT\");\n                        }\n                        CLAY_TEXT(alignX, infoTextConfig);\n                        CLAY_TEXT(CLAY_STRING(\", y: \"), infoTextConfig);\n                        Clay_String alignY = CLAY_STRING(\"TOP\");\n                        if (layoutConfig->childAlignment.y == CLAY_ALIGN_Y_CENTER) {\n                            alignY = CLAY_STRING(\"CENTER\");\n                        } else if (layoutConfig->childAlignment.y == CLAY_ALIGN_Y_BOTTOM) {\n                            alignY = CLAY_STRING(\"BOTTOM\");\n                        }\n                        CLAY_TEXT(alignY, infoTextConfig);\n                        CLAY_TEXT(CLAY_STRING(\" }\"), infoTextConfig);\n                    }\n                }\n                for (int32_t elementConfigIndex = 0; elementConfigIndex < selectedItem->layoutElement->elementConfigs.length; ++elementConfigIndex) {\n                    Clay_ElementConfig *elementConfig = Clay__ElementConfigArraySlice_Get(&selectedItem->layoutElement->elementConfigs, elementConfigIndex);\n                    Clay__RenderDebugViewElementConfigHeader(selectedItem->elementId.stringId, elementConfig->type);\n                    switch (elementConfig->type) {\n                        case CLAY__ELEMENT_CONFIG_TYPE_RECTANGLE: {\n                            Clay_RectangleElementConfig *rectangleConfig = elementConfig->config.rectangleElementConfig;\n                            CLAY(CLAY_LAYOUT({ .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 8}, .childGap = 8, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {\n                                // .color\n                                CLAY_TEXT(CLAY_STRING(\"Color\"), infoTitleConfig);\n                                Clay__RenderDebugViewColor(rectangleConfig->color, infoTextConfig);\n                                // .cornerRadius\n                                CLAY_TEXT(CLAY_STRING(\"Corner Radius\"), infoTitleConfig);\n                                Clay__RenderDebugViewCornerRadius(rectangleConfig->cornerRadius, infoTextConfig);\n                            }\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_TEXT: {\n                            Clay_TextElementConfig *textConfig = elementConfig->config.textElementConfig;\n                            CLAY(CLAY_LAYOUT({ .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 8}, .childGap = 8, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {\n                                // .fontSize\n                                CLAY_TEXT(CLAY_STRING(\"Font Size\"), infoTitleConfig);\n                                CLAY_TEXT(Clay__IntToString(textConfig->fontSize), infoTextConfig);\n                                // .fontId\n                                CLAY_TEXT(CLAY_STRING(\"Font ID\"), infoTitleConfig);\n                                CLAY_TEXT(Clay__IntToString(textConfig->fontId), infoTextConfig);\n                                // .lineHeight\n                                CLAY_TEXT(CLAY_STRING(\"Line Height\"), infoTitleConfig);\n                                CLAY_TEXT(textConfig->lineHeight == 0 ? CLAY_STRING(\"auto\") : Clay__IntToString(textConfig->lineHeight), infoTextConfig);\n                                // .letterSpacing\n                                CLAY_TEXT(CLAY_STRING(\"Letter Spacing\"), infoTitleConfig);\n                                CLAY_TEXT(Clay__IntToString(textConfig->letterSpacing), infoTextConfig);\n                                // .lineSpacing\n                                CLAY_TEXT(CLAY_STRING(\"Wrap Mode\"), infoTitleConfig);\n                                Clay_String wrapMode = CLAY_STRING(\"WORDS\");\n                                if (textConfig->wrapMode == CLAY_TEXT_WRAP_NONE) {\n                                    wrapMode = CLAY_STRING(\"NONE\");\n                                } else if (textConfig->wrapMode == CLAY_TEXT_WRAP_NEWLINES) {\n                                    wrapMode = CLAY_STRING(\"NEWLINES\");\n                                }\n                                CLAY_TEXT(wrapMode, infoTextConfig);\n                                // .textColor\n                                CLAY_TEXT(CLAY_STRING(\"Text Color\"), infoTitleConfig);\n                                Clay__RenderDebugViewColor(textConfig->textColor, infoTextConfig);\n                            }\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_IMAGE: {\n                            Clay_ImageElementConfig *imageConfig = elementConfig->config.imageElementConfig;\n                            CLAY(CLAY_ID(\"Clay__DebugViewElementInfoImageBody\"), CLAY_LAYOUT({ .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 8}, .childGap = 8, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {\n                                // .sourceDimensions\n                                CLAY_TEXT(CLAY_STRING(\"Source Dimensions\"), infoTitleConfig);\n                                CLAY(CLAY_ID(\"Clay__DebugViewElementInfoImageDimensions\")) {\n                                    CLAY_TEXT(CLAY_STRING(\"{ width: \"), infoTextConfig);\n                                    CLAY_TEXT(Clay__IntToString(imageConfig->sourceDimensions.width), infoTextConfig);\n                                    CLAY_TEXT(CLAY_STRING(\", height: \"), infoTextConfig);\n                                    CLAY_TEXT(Clay__IntToString(imageConfig->sourceDimensions.height), infoTextConfig);\n                                    CLAY_TEXT(CLAY_STRING(\" }\"), infoTextConfig);\n                                }\n                                // Image Preview\n                                CLAY_TEXT(CLAY_STRING(\"Preview\"), infoTitleConfig);\n                                CLAY(CLAY_LAYOUT({ .sizing = { CLAY_SIZING_GROW(0, imageConfig->sourceDimensions.width) }}), Clay__AttachElementConfig(CLAY__INIT(Clay_ElementConfigUnion) { .imageElementConfig = imageConfig }, CLAY__ELEMENT_CONFIG_TYPE_IMAGE)) {}\n                            }\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER: {\n                            Clay_ScrollElementConfig *scrollConfig = elementConfig->config.scrollElementConfig;\n                            CLAY(CLAY_LAYOUT({ .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 8}, .childGap = 8, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {\n                                // .vertical\n                                CLAY_TEXT(CLAY_STRING(\"Vertical\"), infoTitleConfig);\n                                CLAY_TEXT(scrollConfig->vertical ? CLAY_STRING(\"true\") : CLAY_STRING(\"false\") , infoTextConfig);\n                                // .horizontal\n                                CLAY_TEXT(CLAY_STRING(\"Horizontal\"), infoTitleConfig);\n                                CLAY_TEXT(scrollConfig->horizontal ? CLAY_STRING(\"true\") : CLAY_STRING(\"false\") , infoTextConfig);\n                            }\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER: {\n                            Clay_FloatingElementConfig *floatingConfig = elementConfig->config.floatingElementConfig;\n                            CLAY(CLAY_LAYOUT({ .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 8}, .childGap = 8, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {\n                                // .offset\n                                CLAY_TEXT(CLAY_STRING(\"Offset\"), infoTitleConfig);\n                                CLAY(CLAY_LAYOUT(CLAY__DEFAULT_STRUCT)) {\n                                    CLAY_TEXT(CLAY_STRING(\"{ x: \"), infoTextConfig);\n                                    CLAY_TEXT(Clay__IntToString(floatingConfig->offset.x), infoTextConfig);\n                                    CLAY_TEXT(CLAY_STRING(\", y: \"), infoTextConfig);\n                                    CLAY_TEXT(Clay__IntToString(floatingConfig->offset.y), infoTextConfig);\n                                    CLAY_TEXT(CLAY_STRING(\" }\"), infoTextConfig);\n                                }\n                                // .expand\n                                CLAY_TEXT(CLAY_STRING(\"Expand\"), infoTitleConfig);\n                                CLAY(CLAY_LAYOUT(CLAY__DEFAULT_STRUCT)) {\n                                    CLAY_TEXT(CLAY_STRING(\"{ width: \"), infoTextConfig);\n                                    CLAY_TEXT(Clay__IntToString(floatingConfig->expand.width), infoTextConfig);\n                                    CLAY_TEXT(CLAY_STRING(\", height: \"), infoTextConfig);\n                                    CLAY_TEXT(Clay__IntToString(floatingConfig->expand.height), infoTextConfig);\n                                    CLAY_TEXT(CLAY_STRING(\" }\"), infoTextConfig);\n                                }\n                                // .zIndex\n                                CLAY_TEXT(CLAY_STRING(\"z-index\"), infoTitleConfig);\n                                CLAY_TEXT(Clay__IntToString(floatingConfig->zIndex), infoTextConfig);\n                                // .parentId\n                                CLAY_TEXT(CLAY_STRING(\"Parent\"), infoTitleConfig);\n                                Clay_LayoutElementHashMapItem *hashItem = Clay__GetHashMapItem(floatingConfig->parentId);\n                                CLAY_TEXT(hashItem->elementId.stringId, infoTextConfig);\n                            }\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_BORDER_CONTAINER: {\n                            Clay_BorderElementConfig *borderConfig = elementConfig->config.borderElementConfig;\n                            CLAY(CLAY_ID(\"Clay__DebugViewElementInfoBorderBody\"), CLAY_LAYOUT({ .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 8}, .childGap = 8, .layoutDirection = CLAY_TOP_TO_BOTTOM })) {\n                                // .left\n                                CLAY_TEXT(CLAY_STRING(\"Left Border\"), infoTitleConfig);\n                                Clay__RenderDebugViewBorder(1, borderConfig->left, infoTextConfig);\n                                // .right\n                                CLAY_TEXT(CLAY_STRING(\"Right Border\"), infoTitleConfig);\n                                Clay__RenderDebugViewBorder(2, borderConfig->right, infoTextConfig);\n                                // .top\n                                CLAY_TEXT(CLAY_STRING(\"Top Border\"), infoTitleConfig);\n                                Clay__RenderDebugViewBorder(3, borderConfig->top, infoTextConfig);\n                                // .bottom\n                                CLAY_TEXT(CLAY_STRING(\"Bottom Border\"), infoTitleConfig);\n                                Clay__RenderDebugViewBorder(4, borderConfig->bottom, infoTextConfig);\n                                // .betweenChildren\n                                CLAY_TEXT(CLAY_STRING(\"Border Between Children\"), infoTitleConfig);\n                                Clay__RenderDebugViewBorder(5, borderConfig->betweenChildren, infoTextConfig);\n                                // .cornerRadius\n                                CLAY_TEXT(CLAY_STRING(\"Corner Radius\"), infoTitleConfig);\n                                Clay__RenderDebugViewCornerRadius(borderConfig->cornerRadius, infoTextConfig);\n                            }\n                            break;\n                        }\n                        case CLAY__ELEMENT_CONFIG_TYPE_CUSTOM:\n                        default: break;\n                    }\n                }\n            }\n        } else {\n            CLAY(CLAY_ID(\"Clay__DebugViewWarningsScrollPane\"), CLAY_LAYOUT({ .sizing = {CLAY_SIZING_GROW(0), CLAY_SIZING_FIXED(300)}, .childGap = 6, .layoutDirection = CLAY_TOP_TO_BOTTOM }), CLAY_SCROLL({ .horizontal = true, .vertical = true }), CLAY_RECTANGLE({ .color = CLAY__DEBUGVIEW_COLOR_2 })) {\n                Clay_TextElementConfig *warningConfig = CLAY_TEXT_CONFIG({ .textColor = CLAY__DEBUGVIEW_COLOR_4, .fontSize = 16, .wrapMode = CLAY_TEXT_WRAP_NONE });\n                CLAY(CLAY_ID(\"Clay__DebugViewWarningItemHeader\"), CLAY_LAYOUT({ .sizing = {.height = CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT)}, .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 0}, .childGap = 8, .childAlignment = {.y = CLAY_ALIGN_Y_CENTER} })) {\n                    CLAY_TEXT(CLAY_STRING(\"Warnings\"), warningConfig);\n                }\n                CLAY(CLAY_ID(\"Clay__DebugViewWarningsTopBorder\"), CLAY_LAYOUT({ .sizing = { .width = CLAY_SIZING_GROW(0), .height = CLAY_SIZING_FIXED(1)} }), CLAY_RECTANGLE({ .color = {200, 200, 200, 255} })) {}\n                int32_t previousWarningsLength = context->warnings.length;\n                for (int32_t i = 0; i < previousWarningsLength; i++) {\n                    Clay__Warning warning = context->warnings.internalArray[i];\n                    CLAY(CLAY_IDI(\"Clay__DebugViewWarningItem\", i), CLAY_LAYOUT({ .sizing = {.height = CLAY_SIZING_FIXED(CLAY__DEBUGVIEW_ROW_HEIGHT)}, .padding = {CLAY__DEBUGVIEW_OUTER_PADDING, 0}, .childGap = 8, .childAlignment = {.y = CLAY_ALIGN_Y_CENTER} })) {\n                        CLAY_TEXT(warning.baseMessage, warningConfig);\n                        if (warning.dynamicMessage.length > 0) {\n                            CLAY_TEXT(warning.dynamicMessage, warningConfig);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n#pragma endregion\n\nuint32_t Clay__debugViewWidth = 400;\nClay_Color Clay__debugViewHighlightColor = { 168, 66, 28, 100 };\n\nClay__WarningArray Clay__WarningArray_Allocate_Arena(int32_t capacity, Clay_Arena *arena) {\n    size_t totalSizeBytes = capacity * sizeof(Clay_String);\n    Clay__WarningArray array = {.capacity = capacity, .length = 0};\n    uintptr_t nextAllocAddress = arena->nextAllocation + (uintptr_t)arena->memory;\n    uintptr_t arenaOffsetAligned = nextAllocAddress + (CLAY__ALIGNMENT(Clay_String) - (nextAllocAddress % CLAY__ALIGNMENT(Clay_String)));\n    arenaOffsetAligned -= (uintptr_t)arena->memory;\n    if (arenaOffsetAligned + totalSizeBytes <= arena->capacity) {\n        array.internalArray = (Clay__Warning*)((uintptr_t)arena->memory + (uintptr_t)arenaOffsetAligned);\n        arena->nextAllocation = arenaOffsetAligned + totalSizeBytes;\n    }\n    else {\n        Clay__currentContext->errorHandler.errorHandlerFunction(CLAY__INIT(Clay_ErrorData) {\n            .errorType = CLAY_ERROR_TYPE_ARENA_CAPACITY_EXCEEDED,\n            .errorText = CLAY_STRING(\"Clay attempted to allocate memory in its arena, but ran out of capacity. Try increasing the capacity of the arena passed to Clay_Initialize()\"),\n            .userData = Clay__currentContext->errorHandler.userData });\n    }\n    return array;\n}\n\nClay__Warning *Clay__WarningArray_Add(Clay__WarningArray *array, Clay__Warning item)\n{\n    if (array->length < array->capacity) {\n        array->internalArray[array->length++] = item;\n        return &array->internalArray[array->length - 1];\n    }\n    return &CLAY__WARNING_DEFAULT;\n}\n\nvoid* Clay__Array_Allocate_Arena(int32_t capacity, uint32_t itemSize, uint32_t alignment, Clay_Arena *arena)\n{\n    size_t totalSizeBytes = capacity * itemSize;\n    uintptr_t nextAllocAddress = arena->nextAllocation + (uintptr_t)arena->memory;\n    uintptr_t arenaOffsetAligned = nextAllocAddress + (alignment - (nextAllocAddress % alignment));\n    arenaOffsetAligned -= (uintptr_t)arena->memory;\n    if (arenaOffsetAligned + totalSizeBytes <= arena->capacity) {\n        arena->nextAllocation = arenaOffsetAligned + totalSizeBytes;\n        return (void*)((uintptr_t)arena->memory + (uintptr_t)arenaOffsetAligned);\n    }\n    else {\n        Clay__currentContext->errorHandler.errorHandlerFunction(CLAY__INIT(Clay_ErrorData) {\n                .errorType = CLAY_ERROR_TYPE_ARENA_CAPACITY_EXCEEDED,\n                .errorText = CLAY_STRING(\"Clay attempted to allocate memory in its arena, but ran out of capacity. Try increasing the capacity of the arena passed to Clay_Initialize()\"),\n                .userData = Clay__currentContext->errorHandler.userData });\n    }\n    return CLAY__NULL;\n}\n\nbool Clay__Array_RangeCheck(int32_t index, int32_t length)\n{\n    if (index < length && index >= 0) {\n        return true;\n    }\n    Clay_Context* context = Clay_GetCurrentContext();\n    context->errorHandler.errorHandlerFunction(CLAY__INIT(Clay_ErrorData) {\n            .errorType = CLAY_ERROR_TYPE_INTERNAL_ERROR,\n            .errorText = CLAY_STRING(\"Clay attempted to make an out of bounds array access. This is an internal error and is likely a bug.\"),\n            .userData = context->errorHandler.userData });\n    return false;\n}\n\nbool Clay__Array_AddCapacityCheck(int32_t length, int32_t capacity)\n{\n    if (length < capacity) {\n        return true;\n    }\n    Clay_Context* context = Clay_GetCurrentContext();\n    context->errorHandler.errorHandlerFunction(CLAY__INIT(Clay_ErrorData) {\n        .errorType = CLAY_ERROR_TYPE_INTERNAL_ERROR,\n        .errorText = CLAY_STRING(\"Clay attempted to make an out of bounds array access. This is an internal error and is likely a bug.\"),\n        .userData = context->errorHandler.userData });\n    return false;\n}\n\n// PUBLIC API FROM HERE ---------------------------------------\n\nCLAY_WASM_EXPORT(\"Clay_MinMemorySize\")\nuint32_t Clay_MinMemorySize(void) {\n    Clay_Context fakeContext = {\n        .maxElementCount = Clay__defaultMaxElementCount,\n        .maxMeasureTextCacheWordCount = Clay__defaultMaxMeasureTextWordCacheCount,\n        .internalArena = {\n            .capacity = SIZE_MAX,\n            .memory = NULL,\n        }\n    };\n    Clay_Context* currentContext = Clay_GetCurrentContext();\n    if (currentContext) {\n        fakeContext.maxElementCount = currentContext->maxElementCount;\n        fakeContext.maxMeasureTextCacheWordCount = currentContext->maxElementCount;\n    }\n    // Reserve space in the arena for the context, important for calculating min memory size correctly\n    Clay__Context_Allocate_Arena(&fakeContext.internalArena);\n    Clay__InitializePersistentMemory(&fakeContext);\n    Clay__InitializeEphemeralMemory(&fakeContext);\n    return fakeContext.internalArena.nextAllocation;\n}\n\nCLAY_WASM_EXPORT(\"Clay_CreateArenaWithCapacityAndMemory\")\nClay_Arena Clay_CreateArenaWithCapacityAndMemory(uint32_t capacity, void *offset) {\n    Clay_Arena arena = {\n        .capacity = capacity,\n        .memory = (char *)offset\n    };\n    return arena;\n}\n\n#ifndef CLAY_WASM\nvoid Clay_SetMeasureTextFunction(Clay_Dimensions (*measureTextFunction)(Clay_String *text, Clay_TextElementConfig *config)) {\n    Clay__MeasureText = measureTextFunction;\n}\nvoid Clay_SetQueryScrollOffsetFunction(Clay_Vector2 (*queryScrollOffsetFunction)(uint32_t elementId)) {\n    Clay__QueryScrollOffset = queryScrollOffsetFunction;\n}\n#endif\n\nCLAY_WASM_EXPORT(\"Clay_SetLayoutDimensions\")\nvoid Clay_SetLayoutDimensions(Clay_Dimensions dimensions) {\n    Clay_GetCurrentContext()->layoutDimensions = dimensions;\n}\n\nCLAY_WASM_EXPORT(\"Clay_SetPointerState\")\nvoid Clay_SetPointerState(Clay_Vector2 position, bool isPointerDown) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->booleanWarnings.maxElementsExceeded) {\n        return;\n    }\n    context->pointerInfo.position = position;\n    context->pointerOverIds.length = 0;\n    Clay__int32_tArray dfsBuffer = context->layoutElementChildrenBuffer;\n    for (int32_t rootIndex = context->layoutElementTreeRoots.length - 1; rootIndex >= 0; --rootIndex) {\n        dfsBuffer.length = 0;\n        Clay__LayoutElementTreeRoot *root = Clay__LayoutElementTreeRootArray_Get(&context->layoutElementTreeRoots, rootIndex);\n        Clay__int32_tArray_Add(&dfsBuffer, (int32_t)root->layoutElementIndex);\n        context->treeNodeVisited.internalArray[0] = false;\n        bool found = false;\n        while (dfsBuffer.length > 0) {\n            if (context->treeNodeVisited.internalArray[dfsBuffer.length - 1]) {\n                dfsBuffer.length--;\n                continue;\n            }\n            context->treeNodeVisited.internalArray[dfsBuffer.length - 1] = true;\n            Clay_LayoutElement *currentElement = Clay_LayoutElementArray_Get(&context->layoutElements, Clay__int32_tArray_Get(&dfsBuffer, (int)dfsBuffer.length - 1));\n            Clay_LayoutElementHashMapItem *mapItem = Clay__GetHashMapItem(currentElement->id); // TODO think of a way around this, maybe the fact that it's essentially a binary tree limits the cost, but the worst case is not great\n            Clay_BoundingBox elementBox = mapItem->boundingBox;\n            elementBox.x -= root->pointerOffset.x;\n            elementBox.y -= root->pointerOffset.y;\n            if (mapItem) {\n                if ((Clay__PointIsInsideRect(position, elementBox))) {\n                    if (mapItem->onHoverFunction) {\n                        mapItem->onHoverFunction(mapItem->elementId, context->pointerInfo, mapItem->hoverFunctionUserData);\n                    }\n                    Clay__ElementIdArray_Add(&context->pointerOverIds, mapItem->elementId);\n                    found = true;\n                }\n                if (Clay__ElementHasConfig(currentElement, CLAY__ELEMENT_CONFIG_TYPE_TEXT)) {\n                    dfsBuffer.length--;\n                    continue;\n                }\n                for (int32_t i = currentElement->childrenOrTextContent.children.length - 1; i >= 0; --i) {\n                    Clay__int32_tArray_Add(&dfsBuffer, currentElement->childrenOrTextContent.children.elements[i]);\n                    context->treeNodeVisited.internalArray[dfsBuffer.length - 1] = false; // TODO needs to be ranged checked\n                }\n            } else {\n                dfsBuffer.length--;\n            }\n        }\n\n        Clay_LayoutElement *rootElement = Clay_LayoutElementArray_Get(&context->layoutElements, root->layoutElementIndex);\n        if (found && Clay__ElementHasConfig(rootElement, CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER) &&\n                Clay__FindElementConfigWithType(rootElement, CLAY__ELEMENT_CONFIG_TYPE_FLOATING_CONTAINER).floatingElementConfig->pointerCaptureMode == CLAY_POINTER_CAPTURE_MODE_CAPTURE) {\n            break;\n        }\n    }\n\n    if (isPointerDown) {\n        if (context->pointerInfo.state == CLAY_POINTER_DATA_PRESSED_THIS_FRAME) {\n            context->pointerInfo.state = CLAY_POINTER_DATA_PRESSED;\n        } else if (context->pointerInfo.state != CLAY_POINTER_DATA_PRESSED) {\n            context->pointerInfo.state = CLAY_POINTER_DATA_PRESSED_THIS_FRAME;\n        }\n    } else {\n        if (context->pointerInfo.state == CLAY_POINTER_DATA_RELEASED_THIS_FRAME) {\n            context->pointerInfo.state = CLAY_POINTER_DATA_RELEASED;\n        } else if (context->pointerInfo.state != CLAY_POINTER_DATA_RELEASED)  {\n            context->pointerInfo.state = CLAY_POINTER_DATA_RELEASED_THIS_FRAME;\n        }\n    }\n}\n\nCLAY_WASM_EXPORT(\"Clay_Initialize\")\nClay_Context* Clay_Initialize(Clay_Arena arena, Clay_Dimensions layoutDimensions, Clay_ErrorHandler errorHandler) {\n    Clay_Context *context = Clay__Context_Allocate_Arena(&arena);\n    if (context == NULL) return NULL;\n    // DEFAULTS\n    Clay_Context *oldContext = Clay_GetCurrentContext();\n    *context = CLAY__INIT(Clay_Context) {\n        .maxElementCount = oldContext ? oldContext->maxElementCount : Clay__defaultMaxElementCount,\n        .maxMeasureTextCacheWordCount = oldContext ? oldContext->maxMeasureTextCacheWordCount : Clay__defaultMaxElementCount * 2,\n        .errorHandler = errorHandler.errorHandlerFunction ? errorHandler : CLAY__INIT(Clay_ErrorHandler) { Clay__ErrorHandlerFunctionDefault },\n        .layoutDimensions = layoutDimensions,\n        .internalArena = arena,\n    };\n    Clay_SetCurrentContext(context);\n    Clay__InitializePersistentMemory(context);\n    Clay__InitializeEphemeralMemory(context);\n    for (int32_t i = 0; i < context->layoutElementsHashMap.capacity; ++i) {\n        context->layoutElementsHashMap.internalArray[i] = -1;\n    }\n    for (int32_t i = 0; i < context->measureTextHashMap.capacity; ++i) {\n        context->measureTextHashMap.internalArray[i] = 0;\n    }\n    context->measureTextHashMapInternal.length = 1; // Reserve the 0 value to mean \"no next element\"\n    context->layoutDimensions = layoutDimensions;\n    return context;\n}\n\nCLAY_WASM_EXPORT(\"Clay_GetCurrentContext\")\nClay_Context* Clay_GetCurrentContext(void) {\n    return Clay__currentContext;\n}\n\nCLAY_WASM_EXPORT(\"Clay_SetCurrentContext\")\nvoid Clay_SetCurrentContext(Clay_Context* context) {\n    Clay__currentContext = context;\n}\n\nCLAY_WASM_EXPORT(\"Clay_UpdateScrollContainers\")\nvoid Clay_UpdateScrollContainers(bool enableDragScrolling, Clay_Vector2 scrollDelta, float deltaTime) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    bool isPointerActive = enableDragScrolling && (context->pointerInfo.state == CLAY_POINTER_DATA_PRESSED || context->pointerInfo.state == CLAY_POINTER_DATA_PRESSED_THIS_FRAME);\n    // Don't apply scroll events to ancestors of the inner element\n    int32_t highestPriorityElementIndex = -1;\n    Clay__ScrollContainerDataInternal *highestPriorityScrollData = CLAY__NULL;\n    for (int32_t i = 0; i < context->scrollContainerDatas.length; i++) {\n        Clay__ScrollContainerDataInternal *scrollData = Clay__ScrollContainerDataInternalArray_Get(&context->scrollContainerDatas, i);\n        if (!scrollData->openThisFrame) {\n            Clay__ScrollContainerDataInternalArray_RemoveSwapback(&context->scrollContainerDatas, i);\n            continue;\n        }\n        scrollData->openThisFrame = false;\n        Clay_LayoutElementHashMapItem *hashMapItem = Clay__GetHashMapItem(scrollData->elementId);\n        // Element isn't rendered this frame but scroll offset has been retained\n        if (!hashMapItem) {\n            Clay__ScrollContainerDataInternalArray_RemoveSwapback(&context->scrollContainerDatas, i);\n            continue;\n        }\n\n        // Touch / click is released\n        if (!isPointerActive && scrollData->pointerScrollActive) {\n            float xDiff = scrollData->scrollPosition.x - scrollData->scrollOrigin.x;\n            if (xDiff < -10 || xDiff > 10) {\n                scrollData->scrollMomentum.x = (scrollData->scrollPosition.x - scrollData->scrollOrigin.x) / (scrollData->momentumTime * 25);\n            }\n            float yDiff = scrollData->scrollPosition.y - scrollData->scrollOrigin.y;\n            if (yDiff < -10 || yDiff > 10) {\n                scrollData->scrollMomentum.y = (scrollData->scrollPosition.y - scrollData->scrollOrigin.y) / (scrollData->momentumTime * 25);\n            }\n            scrollData->pointerScrollActive = false;\n\n            scrollData->pointerOrigin = CLAY__INIT(Clay_Vector2){0,0};\n            scrollData->scrollOrigin = CLAY__INIT(Clay_Vector2){0,0};\n            scrollData->momentumTime = 0;\n        }\n\n        // Apply existing momentum\n        scrollData->scrollPosition.x += scrollData->scrollMomentum.x;\n        scrollData->scrollMomentum.x *= 0.95f;\n        bool scrollOccurred = scrollDelta.x != 0 || scrollDelta.y != 0;\n        if ((scrollData->scrollMomentum.x > -0.1f && scrollData->scrollMomentum.x < 0.1f) || scrollOccurred) {\n            scrollData->scrollMomentum.x = 0;\n        }\n        scrollData->scrollPosition.x = CLAY__MIN(CLAY__MAX(scrollData->scrollPosition.x, -(CLAY__MAX(scrollData->contentSize.width - scrollData->layoutElement->dimensions.width, 0))), 0);\n\n        scrollData->scrollPosition.y += scrollData->scrollMomentum.y;\n        scrollData->scrollMomentum.y *= 0.95f;\n        if ((scrollData->scrollMomentum.y > -0.1f && scrollData->scrollMomentum.y < 0.1f) || scrollOccurred) {\n            scrollData->scrollMomentum.y = 0;\n        }\n        scrollData->scrollPosition.y = CLAY__MIN(CLAY__MAX(scrollData->scrollPosition.y, -(CLAY__MAX(scrollData->contentSize.height - scrollData->layoutElement->dimensions.height, 0))), 0);\n\n        for (int32_t j = 0; j < context->pointerOverIds.length; ++j) { // TODO n & m are small here but this being n*m gives me the creeps\n            if (scrollData->layoutElement->id == Clay__ElementIdArray_Get(&context->pointerOverIds, j)->id) {\n                highestPriorityElementIndex = j;\n                highestPriorityScrollData = scrollData;\n            }\n        }\n    }\n\n    if (highestPriorityElementIndex > -1 && highestPriorityScrollData) {\n        Clay_LayoutElement *scrollElement = highestPriorityScrollData->layoutElement;\n        Clay_ScrollElementConfig *scrollConfig = Clay__FindElementConfigWithType(scrollElement, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER).scrollElementConfig;\n        bool canScrollVertically = scrollConfig->vertical && highestPriorityScrollData->contentSize.height > scrollElement->dimensions.height;\n        bool canScrollHorizontally = scrollConfig->horizontal && highestPriorityScrollData->contentSize.width > scrollElement->dimensions.width;\n        // Handle wheel scroll\n        if (canScrollVertically) {\n            highestPriorityScrollData->scrollPosition.y = highestPriorityScrollData->scrollPosition.y + scrollDelta.y * 10;\n        }\n        if (canScrollHorizontally) {\n            highestPriorityScrollData->scrollPosition.x = highestPriorityScrollData->scrollPosition.x + scrollDelta.x * 10;\n        }\n        // Handle click / touch scroll\n        if (isPointerActive) {\n            highestPriorityScrollData->scrollMomentum = CLAY__INIT(Clay_Vector2)CLAY__DEFAULT_STRUCT;\n            if (!highestPriorityScrollData->pointerScrollActive) {\n                highestPriorityScrollData->pointerOrigin = context->pointerInfo.position;\n                highestPriorityScrollData->scrollOrigin = highestPriorityScrollData->scrollPosition;\n                highestPriorityScrollData->pointerScrollActive = true;\n            } else {\n                float scrollDeltaX = 0, scrollDeltaY = 0;\n                if (canScrollHorizontally) {\n                    float oldXScrollPosition = highestPriorityScrollData->scrollPosition.x;\n                    highestPriorityScrollData->scrollPosition.x = highestPriorityScrollData->scrollOrigin.x + (context->pointerInfo.position.x - highestPriorityScrollData->pointerOrigin.x);\n                    highestPriorityScrollData->scrollPosition.x = CLAY__MAX(CLAY__MIN(highestPriorityScrollData->scrollPosition.x, 0), -(highestPriorityScrollData->contentSize.width - highestPriorityScrollData->boundingBox.width));\n                    scrollDeltaX = highestPriorityScrollData->scrollPosition.x - oldXScrollPosition;\n                }\n                if (canScrollVertically) {\n                    float oldYScrollPosition = highestPriorityScrollData->scrollPosition.y;\n                    highestPriorityScrollData->scrollPosition.y = highestPriorityScrollData->scrollOrigin.y + (context->pointerInfo.position.y - highestPriorityScrollData->pointerOrigin.y);\n                    highestPriorityScrollData->scrollPosition.y = CLAY__MAX(CLAY__MIN(highestPriorityScrollData->scrollPosition.y, 0), -(highestPriorityScrollData->contentSize.height - highestPriorityScrollData->boundingBox.height));\n                    scrollDeltaY = highestPriorityScrollData->scrollPosition.y - oldYScrollPosition;\n                }\n                if (scrollDeltaX > -0.1f && scrollDeltaX < 0.1f && scrollDeltaY > -0.1f && scrollDeltaY < 0.1f && highestPriorityScrollData->momentumTime > 0.15f) {\n                    highestPriorityScrollData->momentumTime = 0;\n                    highestPriorityScrollData->pointerOrigin = context->pointerInfo.position;\n                    highestPriorityScrollData->scrollOrigin = highestPriorityScrollData->scrollPosition;\n                } else {\n                     highestPriorityScrollData->momentumTime += deltaTime;\n                }\n            }\n        }\n        // Clamp any changes to scroll position to the maximum size of the contents\n        if (canScrollVertically) {\n            highestPriorityScrollData->scrollPosition.y = CLAY__MAX(CLAY__MIN(highestPriorityScrollData->scrollPosition.y, 0), -(highestPriorityScrollData->contentSize.height - scrollElement->dimensions.height));\n        }\n        if (canScrollHorizontally) {\n            highestPriorityScrollData->scrollPosition.x = CLAY__MAX(CLAY__MIN(highestPriorityScrollData->scrollPosition.x, 0), -(highestPriorityScrollData->contentSize.width - scrollElement->dimensions.width));\n        }\n    }\n}\n\nCLAY_WASM_EXPORT(\"Clay_BeginLayout\")\nvoid Clay_BeginLayout(void) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    Clay__InitializeEphemeralMemory(context);\n    context->generation++;\n    context->dynamicElementIndex = 0;\n    // Set up the root container that covers the entire window\n    Clay_Dimensions rootDimensions = {context->layoutDimensions.width, context->layoutDimensions.height};\n    if (context->debugModeEnabled) {\n        rootDimensions.width -= (float)Clay__debugViewWidth;\n    }\n    context->booleanWarnings.maxElementsExceeded = false;\n    context->booleanWarnings.maxTextMeasureCacheExceeded = false;\n    context->booleanWarnings.maxRenderCommandsExceeded = false;\n    Clay__OpenElement();\n    CLAY_ID(\"Clay__RootContainer\");\n    CLAY_LAYOUT({ .sizing = {CLAY_SIZING_FIXED((rootDimensions.width)), CLAY_SIZING_FIXED(rootDimensions.height)} });\n    Clay__ElementPostConfiguration();\n    Clay__int32_tArray_Add(&context->openLayoutElementStack, 0);\n    Clay__LayoutElementTreeRootArray_Add(&context->layoutElementTreeRoots, CLAY__INIT(Clay__LayoutElementTreeRoot) { .layoutElementIndex = 0 });\n}\n\nClay_TextElementConfig Clay__DebugView_ErrorTextConfig = {.textColor = {255, 0, 0, 255}, .fontSize = 16, .wrapMode = CLAY_TEXT_WRAP_NONE };\n\nCLAY_WASM_EXPORT(\"Clay_EndLayout\")\nClay_RenderCommandArray Clay_EndLayout() {\n    Clay_Context* context = Clay_GetCurrentContext();\n    Clay__CloseElement();\n    if (context->debugModeEnabled) {\n        context->warningsEnabled = false;\n        Clay__RenderDebugView();\n        context->warningsEnabled = true;\n    }\n    if (context->booleanWarnings.maxElementsExceeded) {\n        Clay__AddRenderCommand(CLAY__INIT(Clay_RenderCommand ) { .boundingBox = { context->layoutDimensions.width / 2 - 59 * 4, context->layoutDimensions.height / 2, 0, 0 },  .config = { .textElementConfig = &Clay__DebugView_ErrorTextConfig }, .text = CLAY_STRING(\"Clay Error: Layout elements exceeded Clay__maxElementCount\"), .commandType = CLAY_RENDER_COMMAND_TYPE_TEXT });\n    } else {\n        Clay__CalculateFinalLayout();\n    }\n    return context->renderCommands;\n}\n\nCLAY_WASM_EXPORT(\"Clay_GetElementId\")\nClay_ElementId Clay_GetElementId(Clay_String idString) {\n    return Clay__HashString(idString, 0, 0);\n}\n\nCLAY_WASM_EXPORT(\"Clay_GetElementIdWithIndex\")\nClay_ElementId Clay_GetElementIdWithIndex(Clay_String idString, uint32_t index) {\n    return Clay__HashString(idString, index, 0);\n}\n\nbool Clay_Hovered(void) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->booleanWarnings.maxElementsExceeded) {\n        return false;\n    }\n    Clay_LayoutElement *openLayoutElement = Clay__GetOpenLayoutElement();\n    // If the element has no id attached at this point, we need to generate one\n    if (openLayoutElement->id == 0) {\n        Clay__GenerateIdForAnonymousElement(openLayoutElement);\n    }\n    for (int32_t i = 0; i < context->pointerOverIds.length; ++i) {\n        if (Clay__ElementIdArray_Get(&context->pointerOverIds, i)->id == openLayoutElement->id) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid Clay_OnHover(void (*onHoverFunction)(Clay_ElementId elementId, Clay_PointerData pointerInfo, intptr_t userData), intptr_t userData) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context->booleanWarnings.maxElementsExceeded) {\n        return;\n    }\n    Clay_LayoutElement *openLayoutElement = Clay__GetOpenLayoutElement();\n    if (openLayoutElement->id == 0) {\n        Clay__GenerateIdForAnonymousElement(openLayoutElement);\n    }\n    Clay_LayoutElementHashMapItem *hashMapItem = Clay__GetHashMapItem(openLayoutElement->id);\n    hashMapItem->onHoverFunction = onHoverFunction;\n    hashMapItem->hoverFunctionUserData = userData;\n}\n\nCLAY_WASM_EXPORT(\"Clay_PointerOver\")\nbool Clay_PointerOver(Clay_ElementId elementId) { // TODO return priority for separating multiple results\n    Clay_Context* context = Clay_GetCurrentContext();\n    for (int32_t i = 0; i < context->pointerOverIds.length; ++i) {\n        if (Clay__ElementIdArray_Get(&context->pointerOverIds, i)->id == elementId.id) {\n            return true;\n        }\n    }\n    return false;\n}\n\nCLAY_WASM_EXPORT(\"Clay_GetScrollContainerData\")\nClay_ScrollContainerData Clay_GetScrollContainerData(Clay_ElementId id) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    for (int32_t i = 0; i < context->scrollContainerDatas.length; ++i) {\n        Clay__ScrollContainerDataInternal *scrollContainerData = Clay__ScrollContainerDataInternalArray_Get(&context->scrollContainerDatas, i);\n        if (scrollContainerData->elementId == id.id) {\n            return CLAY__INIT(Clay_ScrollContainerData) {\n                .scrollPosition = &scrollContainerData->scrollPosition,\n                .scrollContainerDimensions = { scrollContainerData->boundingBox.width, scrollContainerData->boundingBox.height },\n                .contentDimensions = scrollContainerData->contentSize,\n                .config = *Clay__FindElementConfigWithType(scrollContainerData->layoutElement, CLAY__ELEMENT_CONFIG_TYPE_SCROLL_CONTAINER).scrollElementConfig,\n                .found = true\n            };\n        }\n    }\n    return CLAY__INIT(Clay_ScrollContainerData) CLAY__DEFAULT_STRUCT;\n}\n\nCLAY_WASM_EXPORT(\"Clay_SetDebugModeEnabled\")\nvoid Clay_SetDebugModeEnabled(bool enabled) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    context->debugModeEnabled = enabled;\n}\n\nCLAY_WASM_EXPORT(\"Clay_IsDebugModeEnabled\")\nbool Clay_IsDebugModeEnabled(void) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    return context->debugModeEnabled;\n}\n\nCLAY_WASM_EXPORT(\"Clay_SetCullingEnabled\")\nvoid Clay_SetCullingEnabled(bool enabled) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    context->disableCulling = !enabled;\n}\n\nCLAY_WASM_EXPORT(\"Clay_SetExternalScrollHandlingEnabled\")\nvoid Clay_SetExternalScrollHandlingEnabled(bool enabled) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    context->externalScrollHandlingEnabled = enabled;\n}\n\nCLAY_WASM_EXPORT(\"Clay_GetMaxElementCount\")\nint32_t Clay_GetMaxElementCount(void) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    return context->maxElementCount;\n}\n\nCLAY_WASM_EXPORT(\"Clay_SetMaxElementCount\")\nvoid Clay_SetMaxElementCount(int32_t maxElementCount) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context) {\n        context->maxElementCount = maxElementCount;\n    } else {\n        Clay__defaultMaxElementCount = maxElementCount; // TODO: Fix this\n    }\n}\n\nCLAY_WASM_EXPORT(\"Clay_GetMaxMeasureTextCacheWordCount\")\nint32_t Clay_GetMaxMeasureTextCacheWordCount(void) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    return context->maxMeasureTextCacheWordCount;\n}\n\nCLAY_WASM_EXPORT(\"Clay_SetMaxMeasureTextCacheWordCount\")\nvoid Clay_SetMaxMeasureTextCacheWordCount(int32_t maxMeasureTextCacheWordCount) {\n    Clay_Context* context = Clay_GetCurrentContext();\n    if (context) {\n        Clay__currentContext->maxMeasureTextCacheWordCount = maxMeasureTextCacheWordCount;\n    } else {\n        Clay__defaultMaxMeasureTextWordCacheCount = maxMeasureTextCacheWordCount; // TODO: Fix this\n    }\n}\n\n#endif // CLAY_IMPLEMENTATION\n\n/*\nLICENSE\nzlib/libpng license\n\nCopyright (c) 2024 Nic Barker\n\nThis software is provided 'as-is', without any express or implied warranty.\nIn no event will the authors be held liable for any damages arising from the\nuse of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software in a\n    product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not\n    be misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "generator",
          "type": "tree",
          "content": null
        },
        {
          "name": "renderers",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}