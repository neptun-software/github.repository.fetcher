{
  "metadata": {
    "timestamp": 1736710270253,
    "page": 32,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "squeaky-pl/japronto",
      "stars": 8608,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0751953125,
          "content": "__pycache__\n.hypothesis\n.test\ncoverage.info\n*.egg-info\n*.build.toml\n*.so\n*.o\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0908203125,
          "content": "[submodule \"misc/terryfy\"]\n\tpath = misc/terryfy\n\turl = https://github.com/MacPython/terryfy/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.0615234375,
          "content": "language: python\n\nsudo: required\n\nservices:\n  - docker\n\nenv:\n  global:\n    - secure: \"HO3zCuv0FtNFTQ7kkBpIqKYAZW8sYZPfc1ROk6+ChoxufXcu529CTKNAr3KklfZCbMHiZKc3W83N7x9B/L2rtSuBQvJPPgVtIlaVKRyWWnY4nqrpwKEoOLUd3RjpAMfCB09sXQ2aTfQV8Ds5Zk+cF7R2toI6s2s4vymXvCLvfugrtO4sd91frSDv/fzjEEKOIeey8KXtPAPPFv6v64OScksPt1oCsVOPDtkZ7q0KSIzS9JN6BvM9oafPt9MaFPH84ITtdPMTjgQOQ+YFe8YBwgjkV/cX9rNs+vzSP6Bm2NQ9/xxd8XTDj6ukuEYD5HQi26IS6ddRyVGsn6/WRZx6/kQboJKh5r5pa4OAHPWnPirRWPQW46HI2iknAGTFWh8ARX2R208mK1vbQ66J+9zQDnkjMXGgX67gWyWQWfxwVHFsPyQEiSHHh2vEBkhs1+tqtvp7Ktnc+uCxXn0v/Humu3OvFSBxSXfyjvE9uUOGyB2zDwqmxLQQ5ftKAcGfLOaSqauJ1vQy1CWc5bROCn8aoch5iRf/tcX85TUDirAgAp3OUdt3VwcRNY+Fci7IU50gn2rghJWFzB5Zz9p1ShnZxIaD5GEPE45ju4UIpwYbs8iSqh+/RS8sR2Ffzx4M+6QJjj1BJABdtVPS9Jn5OkbuSdBW0K+MuLtmtbg4WLXv6+E=\"\n\njobs:\n  include:\n    - python: 3.5\n      env: VERSION=3.5.3\n    - python: 3.6\n      env: VERSION=3.6.0\n    - python: 3.7\n      env: VERSION=3.7.1\n    - python: 3.8\n      env: VERSION=3.8.0\n\nbefore_install: source misc/travis/before_install.sh\n\ninstall: source misc/travis/install.sh\n\nscript: misc/travis/script.sh\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.142578125,
          "content": "0.1.1 - Feb 9 2017\n------------------\n\n- Native support for OSX\n- Support for older hardware without SSE4.2\n- Better crash info with faulthandler\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0439453125,
          "content": "Copyright (c) 2017 Paweł Piotr Przeradowski\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.099609375,
          "content": "include README.md LICENSE.txt src/picohttpparser/picohttpparser.c src/picohttpparser/picohttpparser.h\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.587890625,
          "content": "# Japronto!\n\n[![irc: #japronto](https://img.shields.io/badge/irc-%23japronto-brightgreen.svg)](https://webchat.freenode.net/?channels=japronto)\n[![Gitter japronto/Lobby](https://badges.gitter.im/japronto/Lobby.svg)](https://gitter.im/japronto/Lobby) [![Build Status](https://travis-ci.org/squeaky-pl/japronto.svg?branch=master)](https://travis-ci.org/squeaky-pl/japronto) [![PyPI](https://img.shields.io/pypi/v/japronto.svg)](https://pypi.python.org/pypi/japronto) [![PyPI version](https://img.shields.io/pypi/pyversions/japronto.svg)](https://pypi.python.org/pypi/japronto/)\n\n__There is no new project development happening at the moment, but it's not abandoned either. Pull requests and new maintainers are welcome__.\n\n__If you are a novice Python programmer, you don't like plumbing yourself or you don't have basic understanding of C, this project is not probably what you are looking for__.\n\nJapronto (from Portuguese \"já pronto\" /ˈʒa pɾõtu/ meaning \"already done\") is a __screaming-fast__, __scalable__, __asynchronous__\nPython 3.5+ HTTP __toolkit__ integrated with __pipelining HTTP server__ based on [uvloop](https://github.com/MagicStack/uvloop) and [picohttpparser](https://github.com/h2o/picohttpparser). It's targeted at speed enthusiasts, people who like\nplumbing and early adopters.\n\nYou can read more in the [release announcement on medium](https://medium.com/@squeaky_pl/million-requests-per-second-with-python-95c137af319)\n\nPerformance\n-----------\n\nHere's a chart to help you imagine what kind of things you can do with Japronto:\n\n![Requests per second](benchmarks/results.png)\n\nAs user @heppu points out Go’s stdlib HTTP server can be 12% faster than the graph shows when written more carefully. Also there is the awesome fasthttp server for Go that apparently is only 18% slower than Japronto in this particular benchmark. Awesome! For details see https://github.com/squeaky-pl/japronto/pull/12 and https://github.com/squeaky-pl/japronto/pull/14.\n\nThese results of a simple \"Hello world\" application were obtained on AWS c4.2xlarge instance. To be fair all the contestants (including Go) were running single worker process. Servers were load tested using [wrk](https://github.com/wg/wrk) with 1 thread, 100 connections and 24 simultaneous (pipelined) requests per connection (cumulative parallelism of 2400 requests).\n\nThe source code for the benchmark can be found in [benchmarks](benchmarks) directory.\n\nThe server is written in hand tweaked C trying to take advantage of modern CPUs. It relies on picohttpparser for header &\nchunked-encoding parsing while uvloop provides asynchronous I/O. It also tries to save up on\nsystem calls by combining writes together when possible.\n\nEarly preview\n-------------\n\nThis is an early preview with alpha quality implementation. APIs are provisional meaning that they will change between versions and more testing is needed. Don't use it for anything serious for now and definitely don't use it in production. Please try it though and report back feedback. If you are shopping for your next project's framework I would recommend [Sanic](https://github.com/channelcat/sanic).\n\nAt the moment the work is focused on CPython but I have PyPy on my radar, though I am not gonna look into it until PyPy reaches 3.5 compatibility somewhere later this year and most known JIT regressions are removed.\n\nHello world\n-----------\n\nHere is how a simple web application looks like in Japronto:\n\n```python\nfrom japronto import Application\n\n\ndef hello(request):\n    return request.Response(text='Hello world!')\n\n\napp = Application()\napp.router.add_route('/', hello)\napp.run(debug=True)\n```\n\nTutorial\n--------\n\n1. [Getting started](tutorial/1_hello.md)\n2. [Asynchronous handlers](tutorial/2_async.md)\n3. [Router](tutorial/3_router.md)\n4. [Request object](tutorial/4_request.md)\n5. [Response object](tutorial/5_response.md)\n6. [Handling exceptions](tutorial/6_exceptions.md)\n7. [Extending request](tutorial/7_extend.md)\n\nFeatures\n--------\n\n- HTTP 1.x implementation with support for chunked uploads\n- Full support for HTTP pipelining\n- Keep-alive connections with configurable reaper\n- Support for synchronous and asynchronous views\n- Master-multiworker model based on forking\n- Support for code reloading on changes\n- Simple routing\n\nLicense\n-------\n\nThis software is distributed under [MIT License](https://en.wikipedia.org/wiki/MIT_License). This is a very permissive license that lets you use this software for any\ncommercial and non-commercial work. Full text of the license is\nincluded in [LICENSE.txt](LICENSE.txt) file.\n\nThe source distribution of this software includes a copy of picohttpparser which is distributed under MIT license as well.\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.py",
          "type": "blob",
          "size": 12.3154296875,
          "content": "import argparse\nimport distutils\nfrom distutils.command.build_ext import build_ext, CompileError\nfrom distutils.core import Distribution\nfrom glob import glob\nimport os.path\nimport shutil\nimport sysconfig\nimport os\nimport sys\nimport subprocess\ntry:\n    import pytoml\nexcept ImportError:\n    pytoml = None\nimport runpy\n\n\nSRC_LOCATION = 'src'\nsys.path.insert(0, SRC_LOCATION)\n\n\nclass BuildSystem:\n    def __init__(self, args, relative_source=False):\n        self.args = args\n        self.dest = self.args.dest\n        self.relative_source = relative_source\n\n    def get_extension_by_path(self, path):\n        path = SRC_LOCATION + '/' + path\n        result = runpy.run_path(path, {'system': self})\n        extension = result['get_extension']()\n\n        base_path = os.path.dirname(path)\n\n        def fix_path(p):\n            if os.path.isabs(p):\n                return p\n\n            return os.path.abspath(os.path.join(base_path, p))\n\n        attrs = ['sources', 'include_dirs', 'library_dirs',\n                 'runtime_library_dirs']\n        for attr in attrs:\n            val = getattr(extension, attr)\n            if not val:\n                continue\n\n            if attr == 'sources' and self.relative_source:\n                val = [\n                    (os.path.normpath(os.path.join(base_path, v))\n                     if not v.startswith('src')\n                     else v) for v in val]\n            elif attr == 'runtime_library_dirs' and self.relative_source:\n                pass\n            else:\n                val = [fix_path(v) for v in val]\n            if attr == 'runtime_library_dirs':\n                setattr(extension, attr, None)\n                attr = 'extra_link_args'\n                val = ['-Wl,-rpath,' + v for v in val]\n                val = (getattr(extension, attr) or []) + val\n            setattr(extension, attr, val)\n\n        return extension\n\n    def discover_extensions(self):\n        self.extensions = []\n\n        ext_files = glob(SRC_LOCATION + '/**/*_ext.py', recursive=True)\n        ext_files = [os.path.relpath(p, SRC_LOCATION) for p in ext_files]\n        self.extensions = [self.get_extension_by_path(f) for f in ext_files]\n\n        return self.extensions\n\n    def dest_folder(self, mod_name):\n        return self.dest + '/' + '/'.join(mod_name.split('.')[:-1])\n\n    def build_toml(self, mod_name):\n        return self.dest + '/' + '/'.join(mod_name.split('.')) + '.build.toml'\n\n    def get_so(self, ext):\n        return self.dest + '/' + '/'.join(ext.name.split('.')) + '.' + \\\n            sysconfig.get_config_var('SOABI') + '.so'\n\n    def flags_changed(self, ext):\n        toml = self.build_toml(ext.name)\n        if not os.path.exists(toml):\n            return True\n\n        with open(toml) as f:\n            flags = pytoml.load(f)\n\n        ext_flags = {\n            \"extra_compile_args\": ext.extra_compile_args,\n            \"extra_link_args\": ext.extra_link_args,\n            \"define_macros\": dict(ext.define_macros),\n            \"sources\": ext.sources}\n\n        return flags != ext_flags\n\n    def should_rebuild(self, ext):\n        so = self.get_so(ext)\n        if not os.path.exists(so):\n            return True\n\n        so_mtime = os.stat(so).st_mtime\n\n        includes = get_includes(ext)\n        input_mtimes = [os.stat(s).st_mtime for s in ext.sources + includes]\n\n        if max(input_mtimes) > so_mtime:\n            return True\n\n        if self.flags_changed(ext):\n            return True\n\n        return False\n\n\ndef prune(dest):\n    paths = glob(os.path.join(dest, '.build/**/*.o'), recursive=True)\n    paths.extend(glob(os.path.join(dest, '.build/**/*.so'), recursive=True))\n    for path in paths:\n        os.remove(path)\n\n\ndef profile_clean():\n    paths = glob('build/**/*.gcda', recursive=True)\n    for path in paths:\n        os.remove(path)\n\n\ndef get_includes(ext):\n    includes = []\n\n    include_base = SRC_LOCATION + '/' + '/'.join(ext.name.split('.')[:-1])\n    include_paths = [os.path.join(include_base, i) for i in ext.include_dirs]\n\n    for source in ext.sources:\n        with open(source) as f:\n            for line in f:\n                line = line.strip()\n                if not line.startswith('#include'):\n                    continue\n\n                header = line.split()[1][1:-1]\n                for path in include_paths:\n                    if not os.path.exists(os.path.join(path, header)):\n                        continue\n\n                    includes.append(os.path.join(path, header))\n                    break\n\n    return includes\n\n\ndef symlink_python_files(dest):\n    if dest == SRC_LOCATION:\n        return\n\n    for parent, dirs, files in os.walk(SRC_LOCATION):\n        if os.path.basename(parent) == '__pycache__':\n            continue\n\n        def _is_python_file(f):\n            return f.endswith('.py') and not f.endswith('_ext.py') \\\n                and not f.startswith('test_')\n\n        files = [f for f in files if _is_python_file(f)]\n\n        if not files:\n            continue\n\n        dest_parent = os.path.join(dest, *parent.split(os.sep)[1:])\n        os.makedirs(dest_parent, exist_ok=True)\n        for file in files:\n            dst = os.path.join(dest_parent, file)\n            src = os.path.relpath(os.path.join(parent, file), dest_parent)\n            if os.path.exists(dst):\n                os.unlink(dst)\n            os.symlink(src, dst)\n\n\nkits = {\n    'platform': [\n        'japronto.request.crequest', 'japronto.protocol.cprotocol',\n        'japronto.protocol.creaper', 'japronto.router.cmatcher',\n        'japronto.response.cresponse']\n}\n\n\ndef get_parser():\n    argparser = argparse.ArgumentParser('build')\n    argparser.add_argument(\n        '-d', dest='debug', const=True, action='store_const', default=False)\n    argparser.add_argument(\n        '--sanitize', dest='sanitize', const=True, action='store_const',\n        default=False)\n    argparser.add_argument(\n        '--profile-generate', dest='profile_generate', const=True,\n        action='store_const', default=False)\n    argparser.add_argument('--dest', dest='dest', default='src')\n    argparser.add_argument(\n        '--profile-use', dest='profile_use', const=True,\n        action='store_const', default=False)\n    argparser.add_argument(\n        '-flto', dest='flto', const=True,\n        action='store_const', default=False)\n    argparser.add_argument(\n        '--profile-clean', dest='profile_clean', const=True,\n        action='store_const', default=False)\n    argparser.add_argument(\n        '--disable-reaper', dest='enable_reaper', const=False,\n        action='store_const', default=True)\n    argparser.add_argument(\n        '--disable-response-cache', dest='enable_response_cache', const=False,\n        action='store_const', default=True)\n    argparser.add_argument(\n        '--coverage', dest='coverage', const=True,\n        action='store_const', default=False)\n    argparser.add_argument('-O1', dest='optimization', const='1',\n                           action='store_const')\n    argparser.add_argument('-O2', dest='optimization', const='2',\n                           action='store_const')\n    argparser.add_argument('-O3', dest='optimization', const='3',\n                           action='store_const')\n    argparser.add_argument('-Os', dest='optimization', const='s',\n                           action='store_const')\n    argparser.add_argument('-native', dest='native', const=True,\n                           action='store_const', default=False)\n    argparser.add_argument('--path', dest='path')\n    argparser.add_argument('--extra-compile', dest='extra_compile', default='')\n    argparser.add_argument('--kit', dest='kit')\n\n    return argparser\n\n\ndef get_platform():\n    argparser = get_parser()\n    args = argparser.parse_args([])\n    system = BuildSystem(args, relative_source=True)\n\n    ext_modules = system.discover_extensions()\n    ext_modules = [e for e in ext_modules if e.name in kits['platform']]\n\n    print({e.name: e.sources for e in ext_modules})\n    return ext_modules\n\n\nclass custom_build_ext(build_ext):\n    def build_extensions(self):\n        if self.compiler.compiler_type == 'unix':\n            for ext in self.extensions:\n                if not ext.extra_compile_args:\n                    ext.extra_compiler_args = []\n                extra_compile_args = ['-std=c99', '-UNDEBUG', '-D_GNU_SOURCE']\n                if self.compiler.compiler_so[0].startswith('gcc') and sys.platform != 'darwin':\n                    extra_compile_args.append('-frecord-gcc-switches')\n                ext.extra_compile_args.extend(extra_compile_args)\n        compile_c(\n            self.compiler,\n            'src/picohttpparser/picohttpparser.c',\n            'src/picohttpparser/ssepicohttpparser.o',\n            options={'unix': ['-msse4.2']})\n        compile_c(\n            self.compiler,\n            'src/picohttpparser/picohttpparser.c',\n            'src/picohttpparser/picohttpparser.o')\n        build_ext.build_extensions(self)\n\n\ndef compile_c(compiler, cfile, ofile, *, options=None):\n    if not options:\n        options = {}\n\n    options = options.get(compiler.compiler_type, [])\n    cmd = [*compiler.compiler_so, *options, '-c', '-o', ofile, cfile]\n    print(\"building '{}'\".format(ofile))\n    print(' '.join(cmd))\n    subprocess.check_call(cmd)\n\n\ndef main():\n    argparser = get_parser()\n    args = argparser.parse_args(sys.argv[1:])\n\n    if args.profile_clean:\n        profile_clean()\n        return\n\n    distutils.log.set_verbosity(1)\n\n    system = BuildSystem(args)\n\n    if args.path:\n        ext_modules = [system.get_extension_by_path(args.path)]\n    else:\n        ext_modules = system.discover_extensions()\n\n    if args.kit:\n        ext_modules = [e for e in ext_modules if e.name in kits[args.kit]]\n\n    def add_args(arg_name, values, append=True):\n        for ext_module in ext_modules:\n            arg_value = getattr(ext_module, arg_name) or []\n            if append:\n                arg_value.extend(values)\n            else:\n                newvalues = list(values)\n                newvalues.extend(arg_value)\n                arg_value = newvalues\n            setattr(ext_module, arg_name, arg_value)\n\n    def append_compile_args(*values):\n        add_args('extra_compile_args', values)\n\n    def append_link_args(*values):\n        add_args('extra_link_args', values)\n\n    def prepend_libraries(*values):\n        add_args('libraries', values, append=False)\n\n    if args.native:\n        append_compile_args('-march=native')\n    if args.optimization:\n        append_compile_args('-O' + args.optimization)\n    if args.debug:\n        append_compile_args('-g3', '-O0', '-Wp,-U_FORTIFY_SOURCE')\n    if args.sanitize:\n        append_compile_args('-g3', '-fsanitize=address',\n                            '-fsanitize=undefined', '-fno-common',\n                            '-fno-omit-frame-pointer')\n        prepend_libraries('asan', 'ubsan')\n    if args.profile_generate:\n        append_compile_args('--profile-generate')\n        append_link_args('-lgcov')\n    if args.profile_use:\n        for ext_module in ext_modules:\n            if ext_module.name in ('parser.cparser', 'pipeline.cpipeline'):\n                continue\n            ext_module.extra_compile_args.append('--profile-use')\n    if args.flto:\n        append_compile_args('-flto')\n        append_link_args('-flto')\n    if args.coverage:\n        append_compile_args('--coverage')\n        append_link_args('-lgcov')\n    if args.extra_compile:\n        append_compile_args(args.extra_compile)\n\n    ext_modules = [e for e in ext_modules if system.should_rebuild(e)]\n    if not ext_modules:\n        return\n\n    dist = Distribution(dict(ext_modules=ext_modules))\n\n    prune(args.dest)\n\n    cmd = custom_build_ext(dist)\n    cmd.build_lib = os.path.join(args.dest, '.build/lib')\n    cmd.build_temp = os.path.join(args.dest, '.build/temp')\n    cmd.finalize_options()\n\n    try:\n        cmd.run()\n    except CompileError:\n        sys.exit(1)\n\n    symlink_python_files(args.dest)\n\n    for ext_module in ext_modules:\n        os.makedirs(system.dest_folder(ext_module.name), exist_ok=True)\n        shutil.copy(\n            cmd.get_ext_fullpath(ext_module.name),\n            system.dest_folder(ext_module.name))\n\n    for ext_module in ext_modules:\n        with open(system.build_toml(ext_module.name), 'w') as f:\n            build_info = {\n                'extra_compile_args': ext_module.extra_compile_args,\n                'extra_link_args': ext_module.extra_link_args,\n                'define_macros': dict(ext_module.define_macros),\n                'sources': ext_module.sources\n            }\n            pytoml.dump(build_info, f)\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "cases",
          "type": "tree",
          "content": null
        },
        {
          "name": "conftest.py",
          "type": "blob",
          "size": 2.2880859375,
          "content": "import subprocess\nimport sys\nimport os\nimport shutil\n\n\nbuilds = []\ncoverages = set()\n\n\ndef add_build(mark):\n    global builds\n    args, kwargs = list(mark.args), mark.kwargs.copy()\n    kwargs.pop('coverage', None)\n    cfg = args, kwargs\n    if cfg not in builds:\n        builds.append(cfg)\n\n\ndef execute_builds():\n    common_options = ['--coverage', '-d', '--sanitize']\n    for args, kwargs in builds:\n        build_options = args[:]\n        build_options.extend(['--dest', kwargs.get('dest', '.test')])\n        if 'kit' not in kwargs:\n            build_options.extend(['--kit', 'platform'])\n        build_options.extend(common_options)\n\n        print('Executing build', *build_options)\n        subprocess.check_call([sys.executable, 'build.py', *build_options])\n\n\ndef add_coverage(mark):\n    dest = mark.kwargs.get('dest', '.test')\n    coverages.add(dest)\n\n\ndef setup_coverage():\n    if coverages:\n        print('Setting up C coverage for', *coverages)\n\n    for dest in coverages:\n        subprocess.check_call([\n             'lcov', '--base-directory', '.', '--directory',\n             dest + '/.build/temp', '--zerocounters', '-q'])\n\n\ndef make_coverage():\n    for dest in coverages:\n        try:\n            os.unlink(dest + '/coverage.info')\n        except FileNotFoundError:\n            pass\n\n        subprocess.check_call([\n            'lcov', '--base-directory', '.', '--directory',\n            dest + '/.build/temp', '-c', '-o', dest + '/coverage.info', '-q'])\n        subprocess.check_call([\n            'lcov', '--remove', dest + '/coverage.info',\n            '/usr*', '-o', 'coverage.info', '-q'])\n\n        try:\n            shutil.rmtree(dest + '/coverage_report')\n        except FileNotFoundError:\n            pass\n\n        subprocess.check_call([\n            'genhtml', '-o', dest + '/coverage_report',\n            dest + '/coverage.info', '-q'\n        ])\n\n        print('C coverage report saved in',\n              dest + '/coverage_report/index.html')\n\n\ndef pytest_itemcollected(item):\n    needs_build = item.get_closest_marker('needs_build')\n    if needs_build:\n        add_build(needs_build)\n    if needs_build and needs_build.kwargs.get('coverage'):\n        add_coverage(needs_build)\n\n\ndef pytest_collection_modifyitems(config, items):\n    execute_builds()\n    setup_coverage()\n\n\ndef pytest_unconfigure():\n    make_coverage()\n"
        },
        {
          "name": "do_wrk.py",
          "type": "blob",
          "size": 3.4091796875,
          "content": "import argparse\nimport sys\nimport asyncio as aio\nimport os\nfrom asyncio.subprocess import PIPE, STDOUT\nimport statistics\n\nimport uvloop\nimport psutil\n\nfrom misc import cpu\nfrom misc import buggers\n\n\ndef run_wrk(loop, endpoint=None):\n    endpoint = endpoint or 'http://localhost:8080'\n    wrk_fut = aio.create_subprocess_exec(\n        './wrk', '-t', '1', '-c', '100', '-d', '2', '-s', 'misc/pipeline.lua',\n        endpoint, stdout=PIPE, stderr=STDOUT)\n\n    wrk = loop.run_until_complete(wrk_fut)\n\n    lines = []\n    while 1:\n        line = loop.run_until_complete(wrk.stdout.readline())\n        if line:\n            line = line.decode('utf-8')\n            lines.append(line)\n            if line.startswith('Requests/sec:'):\n                rps = float(line.split()[-1])\n        else:\n            break\n\n    retcode = loop.run_until_complete(wrk.wait())\n    if retcode != 0:\n        print('\\r\\n'.join(lines))\n\n    return rps\n\n\ndef cpu_usage(p):\n    return p.cpu_percent() + sum(c.cpu_percent() for c in p.children())\n\n\ndef connections(process):\n    return len(\n        set(c.fd for c in process.connections()) |\n        set(c.fd for p in process.children() for c in p.connections()))\n\n\ndef memory(p):\n    return p.memory_percent('uss') \\\n        + sum(c.memory_percent('uss') for c in p.children())\n\n\nif __name__ == '__main__':\n    buggers.silence()\n    loop = uvloop.new_event_loop()\n\n    argparser = argparse.ArgumentParser('do_wrk')\n    argparser.add_argument('-s', dest='server', default='')\n    argparser.add_argument('-e', dest='endpoint')\n    argparser.add_argument('--pid', dest='pid', type=int)\n    argparser.add_argument(\n        '--no-cpu', dest='cpu_change', default=True,\n        action='store_const', const=False)\n\n    args = argparser.parse_args(sys.argv[1:])\n\n    if args.cpu_change:\n        cpu.change('userspace', cpu.min_freq())\n    cpu.dump()\n\n    aio.set_event_loop(loop)\n\n    if not args.endpoint:\n        os.putenv('PYTHONPATH', 'src')\n        server_fut = aio.create_subprocess_exec(\n            'python', 'benchmarks/japronto/micro.py', *args.server.split())\n        server = loop.run_until_complete(server_fut)\n        os.unsetenv('PYTHONPATH')\n    if not args.endpoint:\n        process = psutil.Process(server.pid)\n    elif args.pid:\n        process = psutil.Process(args.pid)\n    else:\n        process = None\n\n    cpu_p = 100\n    while cpu_p > 5:\n        cpu_p = psutil.cpu_percent(interval=1)\n        print('CPU usage in 1 sec:', cpu_p)\n\n    results = []\n    cpu_usages = []\n    process_cpu_usages = []\n    mem_usages = []\n    conn_cnt = []\n    if process:\n        cpu_usage(process)\n    for _ in range(10):\n        results.append(run_wrk(loop, args.endpoint))\n        cpu_usages.append(psutil.cpu_percent())\n        if process:\n            process_cpu_usages.append(cpu_usage(process))\n            conn_cnt.append(connections(process))\n            mem_usages.append(round(memory(process), 2))\n        print('.', end='')\n        sys.stdout.flush()\n\n    if not args.endpoint:\n        server.terminate()\n        loop.run_until_complete(server.wait())\n\n    if args.cpu_change:\n        cpu.change('ondemand')\n\n    print()\n    print('RPS', results)\n    print('Mem', mem_usages)\n    print('Conn', conn_cnt)\n    print('Server', process_cpu_usages)\n    print('System', cpu_usages)\n    median = statistics.median_grouped(results)\n    stdev = round(statistics.stdev(results), 2)\n    p = round((stdev / median) * 100, 2)\n    print('median:', median, 'stdev:', stdev, '%', p)\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "integration_tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 1.861328125,
          "content": "\"\"\"\nJapronto\n\"\"\"\nimport codecs\nimport os\nimport re\n\nfrom setuptools import setup, find_packages\n\nimport build\n\n\nwith codecs.open(os.path.join(os.path.abspath(os.path.dirname(\n        __file__)), 'src', 'japronto', '__init__.py'), 'r', 'latin1') as fp:\n    try:\n        version = re.findall(r\"^__version__ = '([^']+)'\\r?$\",\n                             fp.read(), re.M)[0]\n    except IndexError:\n        raise RuntimeError('Unable to determine version.')\n\n\nsetup(\n    name='japronto',\n    version=version,\n    url='http://github.com/squeaky-pl/japronto/',\n    license='MIT',\n    author='Paweł Piotr Przeradowski',\n    author_email='przeradowski@gmail.com',\n    description='A HTTP application toolkit and server bundle ' +\n                'based on uvloop and picohttpparser',\n    package_dir={'': 'src'},\n    packages=find_packages('src'),\n    keywords=['web', 'asyncio'],\n    platforms='x86_64 Linux and MacOS X',\n    install_requires=[\n        'uvloop>=0.11.3',\n    ],\n    entry_points=\"\"\"\n         [console_scripts]\n         japronto = japronto.__main__:main\n    \"\"\",\n    classifiers=[\n        'Development Status :: 2 - Pre-Alpha',\n        'Intended Audience :: Developers',\n        'Environment :: Web Environment',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: MacOS :: MacOS X',\n        'Operating System :: POSIX :: Linux',\n        'Programming Language :: C',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Topic :: Internet :: WWW/HTTP'\n    ],\n    zip_safe=False,\n    include_package_data=True,\n    package_data={'picohttpparser': ['*.so']},\n    ext_modules=build.get_platform(),\n    cmdclass={'build_ext': build.custom_build_ext}\n)\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tutorial",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}