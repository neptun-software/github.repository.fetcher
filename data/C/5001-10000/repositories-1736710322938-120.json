{
  "metadata": {
    "timestamp": 1736710322938,
    "page": 120,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nodejs/http-parser",
      "stars": 6369,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2490234375,
          "content": "/out/\ncore\ntags\n*.o\ntest\ntest_g\ntest_fast\nbench\nurl_parser\nparsertrace\nparsertrace_g\n*.mk\n*.Makefile\n*.so.*\n*.exe.*\n*.exe\n*.a\n\n\n# Visual Studio uglies\n*.suo\n*.sln\n*.vcxproj\n*.vcxproj.filters\n*.vcxproj.user\n*.opensdf\n*.ncrunchsolution*\n*.sdf\n*.vsp\n*.psess\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 0.46875,
          "content": "# update AUTHORS with:\n#   git log --all --reverse --format='%aN <%aE>' | perl -ne 'BEGIN{print \"# Authors ordered by first contribution.\\n\"} print unless $h{$_}; $h{$_} = 1' > AUTHORS\nRyan Dahl <ry@tinyclouds.org>\nSalman Haq <salman.haq@asti-usa.com>\nSimon Zimmermann <simonz05@gmail.com>\nThomas LE ROUX <thomas@november-eleven.fr> LE ROUX Thomas <thomas@procheo.fr>\nThomas LE ROUX <thomas@november-eleven.fr> Thomas LE ROUX <thomas@procheo.fr>\nFedor Indutny <fedor@indutny.com>\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.12890625,
          "content": "language: c\n\ncompiler:\n  - clang\n  - gcc\n\nscript:\n  - \"make\"\n\nnotifications:\n  email: false\n  irc:\n    - \"irc.freenode.net#node-ci\"\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 2.443359375,
          "content": "# Authors ordered by first contribution.\nRyan Dahl <ry@tinyclouds.org>\nJeremy Hinegardner <jeremy@hinegardner.org>\nSergey Shepelev <temotor@gmail.com>\nJoe Damato <ice799@gmail.com>\ntomika <tomika_nospam@freemail.hu>\nPhoenix Sol <phoenix@burninglabs.com>\nCliff Frey <cliff@meraki.com>\nEwen Cheslack-Postava <ewencp@cs.stanford.edu>\nSantiago Gala <sgala@apache.org>\nTim Becker <tim.becker@syngenio.de>\nJeff Terrace <jterrace@gmail.com>\nBen Noordhuis <info@bnoordhuis.nl>\nNathan Rajlich <nathan@tootallnate.net>\nMark Nottingham <mnot@mnot.net>\nAman Gupta <aman@tmm1.net>\nTim Becker <tim.becker@kuriositaet.de>\nSean Cunningham <sean.cunningham@mandiant.com>\nPeter Griess <pg@std.in>\nSalman Haq <salman.haq@asti-usa.com>\nCliff Frey <clifffrey@gmail.com>\nJon Kolb <jon@b0g.us>\nFouad Mardini <f.mardini@gmail.com>\nPaul Querna <pquerna@apache.org>\nFelix Geisendörfer <felix@debuggable.com>\nkoichik <koichik@improvement.jp>\nAndre Caron <andre.l.caron@gmail.com>\nIvo Raisr <ivosh@ivosh.net>\nJames McLaughlin <jamie@lacewing-project.org>\nDavid Gwynne <loki@animata.net>\nThomas LE ROUX <thomas@november-eleven.fr>\nRandy Rizun <rrizun@ortivawireless.com>\nAndre Louis Caron <andre.louis.caron@usherbrooke.ca>\nSimon Zimmermann <simonz05@gmail.com>\nErik Dubbelboer <erik@dubbelboer.com>\nMartell Malone <martellmalone@gmail.com>\nBertrand Paquet <bpaquet@octo.com>\nBogDan Vatra <bogdan@kde.org>\nPeter Faiman <peter@thepicard.org>\nCorey Richardson <corey@octayn.net>\nTóth Tamás <tomika_nospam@freemail.hu>\nCam Swords <cam.swords@gmail.com>\nChris Dickinson <christopher.s.dickinson@gmail.com>\nUli Köhler <ukoehler@btronik.de>\nCharlie Somerville <charlie@charliesomerville.com>\nPatrik Stutz <patrik.stutz@gmail.com>\nFedor Indutny <fedor.indutny@gmail.com>\nrunner <runner.mei@gmail.com>\nAlexis Campailla <alexis@janeasystems.com>\nDavid Wragg <david@wragg.org>\nVinnie Falco <vinnie.falco@gmail.com>\nAlex Butum <alexbutum@linux.com>\nRex Feng <rexfeng@gmail.com>\nAlex Kocharin <alex@kocharin.ru>\nMark Koopman <markmontymark@yahoo.com>\nHelge Heß <me@helgehess.eu>\nAlexis La Goutte <alexis.lagoutte@gmail.com>\nGeorge Miroshnykov <george.miroshnykov@gmail.com>\nMaciej Małecki <me@mmalecki.com>\nMarc O'Morain <github.com@marcomorain.com>\nJeff Pinner <jpinner@twitter.com>\nTimothy J Fontaine <tjfontaine@gmail.com>\nAkagi201 <akagi201@gmail.com>\nRomain Giraud <giraud.romain@gmail.com>\nJay Satiro <raysatiro@yahoo.com>\nArne Steen <Arne.Steen@gmx.de>\nKjell Schubert <kjell.schubert@gmail.com>\nOlivier Mengué <dolmen@cpan.org>\n"
        },
        {
          "name": "LICENSE-MIT",
          "type": "blob",
          "size": 1.0517578125,
          "content": "Copyright Joyent, Inc. and other Node contributors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE. \n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 5.1640625,
          "content": "# Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to\n# deal in the Software without restriction, including without limitation the\n# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n# sell copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\nPLATFORM ?= $(shell sh -c 'uname -s | tr \"[A-Z]\" \"[a-z]\"')\nHELPER ?=\nBINEXT ?=\nSOLIBNAME = libhttp_parser\nSOMAJOR = 2\nSOMINOR = 9\nSOREV   = 4\nifeq (darwin,$(PLATFORM))\nSOEXT ?= dylib\nSONAME ?= $(SOLIBNAME).$(SOMAJOR).$(SOMINOR).$(SOEXT)\nLIBNAME ?= $(SOLIBNAME).$(SOMAJOR).$(SOMINOR).$(SOREV).$(SOEXT)\nelse ifeq (wine,$(PLATFORM))\nCC = winegcc\nBINEXT = .exe.so\nHELPER = wine\nelse\nSOEXT ?= so\nSONAME ?= $(SOLIBNAME).$(SOEXT).$(SOMAJOR).$(SOMINOR)\nLIBNAME ?= $(SOLIBNAME).$(SOEXT).$(SOMAJOR).$(SOMINOR).$(SOREV)\nendif\n\nCC?=gcc\nAR?=ar\n\nCPPFLAGS ?=\nLDFLAGS ?=\n\nCPPFLAGS += -I.\nCPPFLAGS_DEBUG = $(CPPFLAGS) -DHTTP_PARSER_STRICT=1\nCPPFLAGS_DEBUG += $(CPPFLAGS_DEBUG_EXTRA)\nCPPFLAGS_FAST = $(CPPFLAGS) -DHTTP_PARSER_STRICT=0\nCPPFLAGS_FAST += $(CPPFLAGS_FAST_EXTRA)\nCPPFLAGS_BENCH = $(CPPFLAGS_FAST)\n\nCFLAGS += -Wall -Wextra -Werror\nCFLAGS_DEBUG = $(CFLAGS) -O0 -g $(CFLAGS_DEBUG_EXTRA)\nCFLAGS_FAST = $(CFLAGS) -O3 $(CFLAGS_FAST_EXTRA)\nCFLAGS_BENCH = $(CFLAGS_FAST) -Wno-unused-parameter\nCFLAGS_LIB = $(CFLAGS_FAST) -fPIC\n\nLDFLAGS_LIB = $(LDFLAGS) -shared\n\nINSTALL ?= install\nPREFIX ?= /usr/local\nLIBDIR = $(PREFIX)/lib\nINCLUDEDIR = $(PREFIX)/include\n\nifeq (darwin,$(PLATFORM))\nLDFLAGS_LIB += -Wl,-install_name,$(LIBDIR)/$(SONAME)\nelse\n# TODO(bnoordhuis) The native SunOS linker expects -h rather than -soname...\nLDFLAGS_LIB += -Wl,-soname=$(SONAME)\nendif\n\ntest: test_g test_fast\n\t$(HELPER) ./test_g$(BINEXT)\n\t$(HELPER) ./test_fast$(BINEXT)\n\ntest_g: http_parser_g.o test_g.o\n\t$(CC) $(CFLAGS_DEBUG) $(LDFLAGS) http_parser_g.o test_g.o -o $@\n\ntest_g.o: test.c http_parser.h Makefile\n\t$(CC) $(CPPFLAGS_DEBUG) $(CFLAGS_DEBUG) -c test.c -o $@\n\nhttp_parser_g.o: http_parser.c http_parser.h Makefile\n\t$(CC) $(CPPFLAGS_DEBUG) $(CFLAGS_DEBUG) -c http_parser.c -o $@\n\ntest_fast: http_parser.o test.o http_parser.h\n\t$(CC) $(CFLAGS_FAST) $(LDFLAGS) http_parser.o test.o -o $@\n\ntest.o: test.c http_parser.h Makefile\n\t$(CC) $(CPPFLAGS_FAST) $(CFLAGS_FAST) -c test.c -o $@\n\nbench: http_parser.o bench.o\n\t$(CC) $(CFLAGS_BENCH) $(LDFLAGS) http_parser.o bench.o -o $@\n\nbench.o: bench.c http_parser.h Makefile\n\t$(CC) $(CPPFLAGS_BENCH) $(CFLAGS_BENCH) -c bench.c -o $@\n\nhttp_parser.o: http_parser.c http_parser.h Makefile\n\t$(CC) $(CPPFLAGS_FAST) $(CFLAGS_FAST) -c http_parser.c\n\ntest-run-timed: test_fast\n\twhile(true) do time $(HELPER) ./test_fast$(BINEXT) > /dev/null; done\n\ntest-valgrind: test_g\n\tvalgrind ./test_g\n\nlibhttp_parser.o: http_parser.c http_parser.h Makefile\n\t$(CC) $(CPPFLAGS_FAST) $(CFLAGS_LIB) -c http_parser.c -o libhttp_parser.o\n\nlibrary: libhttp_parser.o\n\t$(CC) $(LDFLAGS_LIB) -o $(LIBNAME) $<\n\npackage: http_parser.o\n\t$(AR) rcs libhttp_parser.a http_parser.o\n\nurl_parser: http_parser.o contrib/url_parser.c\n\t$(CC) $(CPPFLAGS_FAST) $(CFLAGS_FAST) $^ -o $@\n\nurl_parser_g: http_parser_g.o contrib/url_parser.c\n\t$(CC) $(CPPFLAGS_DEBUG) $(CFLAGS_DEBUG) $^ -o $@\n\nparsertrace: http_parser.o contrib/parsertrace.c\n\t$(CC) $(CPPFLAGS_FAST) $(CFLAGS_FAST) $^ -o parsertrace$(BINEXT)\n\nparsertrace_g: http_parser_g.o contrib/parsertrace.c\n\t$(CC) $(CPPFLAGS_DEBUG) $(CFLAGS_DEBUG) $^ -o parsertrace_g$(BINEXT)\n\ntags: http_parser.c http_parser.h test.c\n\tctags $^\n\ninstall: library\n\t$(INSTALL) -D  http_parser.h $(DESTDIR)$(INCLUDEDIR)/http_parser.h\n\t$(INSTALL) -D $(LIBNAME) $(DESTDIR)$(LIBDIR)/$(LIBNAME)\n\tln -sf $(LIBNAME) $(DESTDIR)$(LIBDIR)/$(SONAME)\n\tln -sf $(LIBNAME) $(DESTDIR)$(LIBDIR)/$(SOLIBNAME).$(SOEXT)\n\ninstall-strip: library\n\t$(INSTALL) -D  http_parser.h $(DESTDIR)$(INCLUDEDIR)/http_parser.h\n\t$(INSTALL) -D -s $(LIBNAME) $(DESTDIR)$(LIBDIR)/$(LIBNAME)\n\tln -sf $(LIBNAME) $(DESTDIR)$(LIBDIR)/$(SONAME)\n\tln -sf $(LIBNAME) $(DESTDIR)$(LIBDIR)/$(SOLIBNAME).$(SOEXT)\n\nuninstall:\n\trm $(DESTDIR)$(INCLUDEDIR)/http_parser.h\n\trm $(DESTDIR)$(LIBDIR)/$(SOLIBNAME).$(SOEXT)\n\trm $(DESTDIR)$(LIBDIR)/$(SONAME)\n\trm $(DESTDIR)$(LIBDIR)/$(LIBNAME)\n\nclean:\n\trm -f *.o *.a tags test test_fast test_g \\\n\t\thttp_parser.tar libhttp_parser.so.* \\\n\t\turl_parser url_parser_g parsertrace parsertrace_g \\\n\t\t*.exe *.exe.so\n\ncontrib/url_parser.c:\thttp_parser.h\ncontrib/parsertrace.c:\thttp_parser.h\n\n.PHONY: clean package test-run test-run-timed test-valgrind install install-strip uninstall\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.3212890625,
          "content": "HTTP Parser\n===========\n\nhttp-parser is [**not** actively maintained](https://github.com/nodejs/http-parser/issues/522).\nNew projects and projects looking to migrate should consider [llhttp](https://github.com/nodejs/llhttp).\n\n[![Build Status](https://api.travis-ci.org/nodejs/http-parser.svg?branch=master)](https://travis-ci.org/nodejs/http-parser)\n\nThis is a parser for HTTP messages written in C. It parses both requests and\nresponses. The parser is designed to be used in performance HTTP\napplications. It does not make any syscalls nor allocations, it does not\nbuffer data, it can be interrupted at anytime. Depending on your\narchitecture, it only requires about 40 bytes of data per message\nstream (in a web server that is per connection).\n\nFeatures:\n\n  * No dependencies\n  * Handles persistent streams (keep-alive).\n  * Decodes chunked encoding.\n  * Upgrade support\n  * Defends against buffer overflow attacks.\n\nThe parser extracts the following information from HTTP messages:\n\n  * Header fields and values\n  * Content-Length\n  * Request method\n  * Response status code\n  * Transfer-Encoding\n  * HTTP version\n  * Request URL\n  * Message body\n\n\nUsage\n-----\n\nOne `http_parser` object is used per TCP connection. Initialize the struct\nusing `http_parser_init()` and set the callbacks. That might look something\nlike this for a request parser:\n```c\nhttp_parser_settings settings;\nsettings.on_url = my_url_callback;\nsettings.on_header_field = my_header_field_callback;\n/* ... */\n\nhttp_parser *parser = malloc(sizeof(http_parser));\nhttp_parser_init(parser, HTTP_REQUEST);\nparser->data = my_socket;\n```\n\nWhen data is received on the socket execute the parser and check for errors.\n\n```c\nsize_t len = 80*1024, nparsed;\nchar buf[len];\nssize_t recved;\n\nrecved = recv(fd, buf, len, 0);\n\nif (recved < 0) {\n  /* Handle error. */\n}\n\n/* Start up / continue the parser.\n * Note we pass recved==0 to signal that EOF has been received.\n */\nnparsed = http_parser_execute(parser, &settings, buf, recved);\n\nif (parser->upgrade) {\n  /* handle new protocol */\n} else if (nparsed != recved) {\n  /* Handle error. Usually just close the connection. */\n}\n```\n\n`http_parser` needs to know where the end of the stream is. For example, sometimes\nservers send responses without Content-Length and expect the client to\nconsume input (for the body) until EOF. To tell `http_parser` about EOF, give\n`0` as the fourth parameter to `http_parser_execute()`. Callbacks and errors\ncan still be encountered during an EOF, so one must still be prepared\nto receive them.\n\nScalar valued message information such as `status_code`, `method`, and the\nHTTP version are stored in the parser structure. This data is only\ntemporally stored in `http_parser` and gets reset on each new message. If\nthis information is needed later, copy it out of the structure during the\n`headers_complete` callback.\n\nThe parser decodes the transfer-encoding for both requests and responses\ntransparently. That is, a chunked encoding is decoded before being sent to\nthe on_body callback.\n\n\nThe Special Problem of Upgrade\n------------------------------\n\n`http_parser` supports upgrading the connection to a different protocol. An\nincreasingly common example of this is the WebSocket protocol which sends\na request like\n\n        GET /demo HTTP/1.1\n        Upgrade: WebSocket\n        Connection: Upgrade\n        Host: example.com\n        Origin: http://example.com\n        WebSocket-Protocol: sample\n\nfollowed by non-HTTP data.\n\n(See [RFC6455](https://tools.ietf.org/html/rfc6455) for more information the\nWebSocket protocol.)\n\nTo support this, the parser will treat this as a normal HTTP message without a\nbody, issuing both on_headers_complete and on_message_complete callbacks. However\nhttp_parser_execute() will stop parsing at the end of the headers and return.\n\nThe user is expected to check if `parser->upgrade` has been set to 1 after\n`http_parser_execute()` returns. Non-HTTP data begins at the buffer supplied\noffset by the return value of `http_parser_execute()`.\n\n\nCallbacks\n---------\n\nDuring the `http_parser_execute()` call, the callbacks set in\n`http_parser_settings` will be executed. The parser maintains state and\nnever looks behind, so buffering the data is not necessary. If you need to\nsave certain data for later usage, you can do that from the callbacks.\n\nThere are two types of callbacks:\n\n* notification `typedef int (*http_cb) (http_parser*);`\n    Callbacks: on_message_begin, on_headers_complete, on_message_complete.\n* data `typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);`\n    Callbacks: (requests only) on_url,\n               (common) on_header_field, on_header_value, on_body;\n\nCallbacks must return 0 on success. Returning a non-zero value indicates\nerror to the parser, making it exit immediately.\n\nFor cases where it is necessary to pass local information to/from a callback,\nthe `http_parser` object's `data` field can be used.\nAn example of such a case is when using threads to handle a socket connection,\nparse a request, and then give a response over that socket. By instantiation\nof a thread-local struct containing relevant data (e.g. accepted socket,\nallocated memory for callbacks to write into, etc), a parser's callbacks are\nable to communicate data between the scope of the thread and the scope of the\ncallback in a threadsafe manner. This allows `http_parser` to be used in\nmulti-threaded contexts.\n\nExample:\n```c\n typedef struct {\n  socket_t sock;\n  void* buffer;\n  int buf_len;\n } custom_data_t;\n\n\nint my_url_callback(http_parser* parser, const char *at, size_t length) {\n  /* access to thread local custom_data_t struct.\n  Use this access save parsed data for later use into thread local\n  buffer, or communicate over socket\n  */\n  parser->data;\n  ...\n  return 0;\n}\n\n...\n\nvoid http_parser_thread(socket_t sock) {\n int nparsed = 0;\n /* allocate memory for user data */\n custom_data_t *my_data = malloc(sizeof(custom_data_t));\n\n /* some information for use by callbacks.\n * achieves thread -> callback information flow */\n my_data->sock = sock;\n\n /* instantiate a thread-local parser */\n http_parser *parser = malloc(sizeof(http_parser));\n http_parser_init(parser, HTTP_REQUEST); /* initialise parser */\n /* this custom data reference is accessible through the reference to the\n parser supplied to callback functions */\n parser->data = my_data;\n\n http_parser_settings settings; /* set up callbacks */\n settings.on_url = my_url_callback;\n\n /* execute parser */\n nparsed = http_parser_execute(parser, &settings, buf, recved);\n\n ...\n /* parsed information copied from callback.\n can now perform action on data copied into thread-local memory from callbacks.\n achieves callback -> thread information flow */\n my_data->buffer;\n ...\n}\n\n```\n\nIn case you parse HTTP message in chunks (i.e. `read()` request line\nfrom socket, parse, read half headers, parse, etc) your data callbacks\nmay be called more than once. `http_parser` guarantees that data pointer is only\nvalid for the lifetime of callback. You can also `read()` into a heap allocated\nbuffer to avoid copying memory around if this fits your application.\n\nReading headers may be a tricky task if you read/parse headers partially.\nBasically, you need to remember whether last header callback was field or value\nand apply the following logic:\n\n    (on_header_field and on_header_value shortened to on_h_*)\n     ------------------------ ------------ --------------------------------------------\n    | State (prev. callback) | Callback   | Description/action                         |\n     ------------------------ ------------ --------------------------------------------\n    | nothing (first call)   | on_h_field | Allocate new buffer and copy callback data |\n    |                        |            | into it                                    |\n     ------------------------ ------------ --------------------------------------------\n    | value                  | on_h_field | New header started.                        |\n    |                        |            | Copy current name,value buffers to headers |\n    |                        |            | list and allocate new buffer for new name  |\n     ------------------------ ------------ --------------------------------------------\n    | field                  | on_h_field | Previous name continues. Reallocate name   |\n    |                        |            | buffer and append callback data to it      |\n     ------------------------ ------------ --------------------------------------------\n    | field                  | on_h_value | Value for current header started. Allocate |\n    |                        |            | new buffer and copy callback data to it    |\n     ------------------------ ------------ --------------------------------------------\n    | value                  | on_h_value | Value continues. Reallocate value buffer   |\n    |                        |            | and append callback data to it             |\n     ------------------------ ------------ --------------------------------------------\n\n\nParsing URLs\n------------\n\nA simplistic zero-copy URL parser is provided as `http_parser_parse_url()`.\nUsers of this library may wish to use it to parse URLs constructed from\nconsecutive `on_url` callbacks.\n\nSee examples of reading in headers:\n\n* [partial example](http://gist.github.com/155877) in C\n* [from http-parser tests](http://github.com/joyent/http-parser/blob/37a0ff8/test.c#L403) in C\n* [from Node library](http://github.com/joyent/node/blob/842eaf4/src/http.js#L284) in Javascript\n"
        },
        {
          "name": "bench.c",
          "type": "blob",
          "size": 3.697265625,
          "content": "/* Copyright Fedor Indutny. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#include \"http_parser.h\"\n#include <assert.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n\n/* 8 gb */\nstatic const int64_t kBytes = 8LL << 30;\n\nstatic const char data[] =\n    \"POST /joyent/http-parser HTTP/1.1\\r\\n\"\n    \"Host: github.com\\r\\n\"\n    \"DNT: 1\\r\\n\"\n    \"Accept-Encoding: gzip, deflate, sdch\\r\\n\"\n    \"Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4\\r\\n\"\n    \"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) \"\n        \"AppleWebKit/537.36 (KHTML, like Gecko) \"\n        \"Chrome/39.0.2171.65 Safari/537.36\\r\\n\"\n    \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,\"\n        \"image/webp,*/*;q=0.8\\r\\n\"\n    \"Referer: https://github.com/joyent/http-parser\\r\\n\"\n    \"Connection: keep-alive\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Cache-Control: max-age=0\\r\\n\\r\\nb\\r\\nhello world\\r\\n0\\r\\n\";\nstatic const size_t data_len = sizeof(data) - 1;\n\nstatic int on_info(http_parser* p) {\n  return 0;\n}\n\n\nstatic int on_data(http_parser* p, const char *at, size_t length) {\n  return 0;\n}\n\nstatic http_parser_settings settings = {\n  .on_message_begin = on_info,\n  .on_headers_complete = on_info,\n  .on_message_complete = on_info,\n  .on_header_field = on_data,\n  .on_header_value = on_data,\n  .on_url = on_data,\n  .on_status = on_data,\n  .on_body = on_data\n};\n\nint bench(int iter_count, int silent) {\n  struct http_parser parser;\n  int i;\n  int err;\n  struct timeval start;\n  struct timeval end;\n\n  if (!silent) {\n    err = gettimeofday(&start, NULL);\n    assert(err == 0);\n  }\n\n  fprintf(stderr, \"req_len=%d\\n\", (int) data_len);\n  for (i = 0; i < iter_count; i++) {\n    size_t parsed;\n    http_parser_init(&parser, HTTP_REQUEST);\n\n    parsed = http_parser_execute(&parser, &settings, data, data_len);\n    assert(parsed == data_len);\n  }\n\n  if (!silent) {\n    double elapsed;\n    double bw;\n    double total;\n\n    err = gettimeofday(&end, NULL);\n    assert(err == 0);\n\n    fprintf(stdout, \"Benchmark result:\\n\");\n\n    elapsed = (double) (end.tv_sec - start.tv_sec) +\n              (end.tv_usec - start.tv_usec) * 1e-6f;\n\n    total = (double) iter_count * data_len;\n    bw = (double) total / elapsed;\n\n    fprintf(stdout, \"%.2f mb | %.2f mb/s | %.2f req/sec | %.2f s\\n\",\n        (double) total / (1024 * 1024),\n        bw / (1024 * 1024),\n        (double) iter_count / elapsed,\n        elapsed);\n\n    fflush(stdout);\n  }\n\n  return 0;\n}\n\nint main(int argc, char** argv) {\n  int64_t iterations;\n\n  iterations = kBytes / (int64_t) data_len;\n  if (argc == 2 && strcmp(argv[1], \"infinite\") == 0) {\n    for (;;)\n      bench(iterations, 1);\n    return 0;\n  } else {\n    return bench(iterations, 0);\n  }\n}\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzzers",
          "type": "tree",
          "content": null
        },
        {
          "name": "http_parser.c",
          "type": "blob",
          "size": 73.8720703125,
          "content": "/* Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#include \"http_parser.h\"\n#include <assert.h>\n#include <stddef.h>\n#include <ctype.h>\n#include <string.h>\n#include <limits.h>\n\nstatic uint32_t max_header_size = HTTP_MAX_HEADER_SIZE;\n\n#ifndef ULLONG_MAX\n# define ULLONG_MAX ((uint64_t) -1) /* 2^64-1 */\n#endif\n\n#ifndef MIN\n# define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n#ifndef ARRAY_SIZE\n# define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n#endif\n\n#ifndef BIT_AT\n# define BIT_AT(a, i)                                                \\\n  (!!((unsigned int) (a)[(unsigned int) (i) >> 3] &                  \\\n   (1 << ((unsigned int) (i) & 7))))\n#endif\n\n#ifndef ELEM_AT\n# define ELEM_AT(a, i, v) ((unsigned int) (i) < ARRAY_SIZE(a) ? (a)[(i)] : (v))\n#endif\n\n#define SET_ERRNO(e)                                                 \\\ndo {                                                                 \\\n  parser->nread = nread;                                             \\\n  parser->http_errno = (e);                                          \\\n} while(0)\n\n#define CURRENT_STATE() p_state\n#define UPDATE_STATE(V) p_state = (enum state) (V);\n#define RETURN(V)                                                    \\\ndo {                                                                 \\\n  parser->nread = nread;                                             \\\n  parser->state = CURRENT_STATE();                                   \\\n  return (V);                                                        \\\n} while (0);\n#define REEXECUTE()                                                  \\\n  goto reexecute;                                                    \\\n\n\n#ifdef __GNUC__\n# define LIKELY(X) __builtin_expect(!!(X), 1)\n# define UNLIKELY(X) __builtin_expect(!!(X), 0)\n#else\n# define LIKELY(X) (X)\n# define UNLIKELY(X) (X)\n#endif\n\n\n/* Run the notify callback FOR, returning ER if it fails */\n#define CALLBACK_NOTIFY_(FOR, ER)                                    \\\ndo {                                                                 \\\n  assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \\\n                                                                     \\\n  if (LIKELY(settings->on_##FOR)) {                                  \\\n    parser->state = CURRENT_STATE();                                 \\\n    if (UNLIKELY(0 != settings->on_##FOR(parser))) {                 \\\n      SET_ERRNO(HPE_CB_##FOR);                                       \\\n    }                                                                \\\n    UPDATE_STATE(parser->state);                                     \\\n                                                                     \\\n    /* We either errored above or got paused; get out */             \\\n    if (UNLIKELY(HTTP_PARSER_ERRNO(parser) != HPE_OK)) {             \\\n      return (ER);                                                   \\\n    }                                                                \\\n  }                                                                  \\\n} while (0)\n\n/* Run the notify callback FOR and consume the current byte */\n#define CALLBACK_NOTIFY(FOR)            CALLBACK_NOTIFY_(FOR, p - data + 1)\n\n/* Run the notify callback FOR and don't consume the current byte */\n#define CALLBACK_NOTIFY_NOADVANCE(FOR)  CALLBACK_NOTIFY_(FOR, p - data)\n\n/* Run data callback FOR with LEN bytes, returning ER if it fails */\n#define CALLBACK_DATA_(FOR, LEN, ER)                                 \\\ndo {                                                                 \\\n  assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \\\n                                                                     \\\n  if (FOR##_mark) {                                                  \\\n    if (LIKELY(settings->on_##FOR)) {                                \\\n      parser->state = CURRENT_STATE();                               \\\n      if (UNLIKELY(0 !=                                              \\\n                   settings->on_##FOR(parser, FOR##_mark, (LEN)))) { \\\n        SET_ERRNO(HPE_CB_##FOR);                                     \\\n      }                                                              \\\n      UPDATE_STATE(parser->state);                                   \\\n                                                                     \\\n      /* We either errored above or got paused; get out */           \\\n      if (UNLIKELY(HTTP_PARSER_ERRNO(parser) != HPE_OK)) {           \\\n        return (ER);                                                 \\\n      }                                                              \\\n    }                                                                \\\n    FOR##_mark = NULL;                                               \\\n  }                                                                  \\\n} while (0)\n\n/* Run the data callback FOR and consume the current byte */\n#define CALLBACK_DATA(FOR)                                           \\\n    CALLBACK_DATA_(FOR, p - FOR##_mark, p - data + 1)\n\n/* Run the data callback FOR and don't consume the current byte */\n#define CALLBACK_DATA_NOADVANCE(FOR)                                 \\\n    CALLBACK_DATA_(FOR, p - FOR##_mark, p - data)\n\n/* Set the mark FOR; non-destructive if mark is already set */\n#define MARK(FOR)                                                    \\\ndo {                                                                 \\\n  if (!FOR##_mark) {                                                 \\\n    FOR##_mark = p;                                                  \\\n  }                                                                  \\\n} while (0)\n\n/* Don't allow the total size of the HTTP headers (including the status\n * line) to exceed max_header_size.  This check is here to protect\n * embedders against denial-of-service attacks where the attacker feeds\n * us a never-ending header that the embedder keeps buffering.\n *\n * This check is arguably the responsibility of embedders but we're doing\n * it on the embedder's behalf because most won't bother and this way we\n * make the web a little safer.  max_header_size is still far bigger\n * than any reasonable request or response so this should never affect\n * day-to-day operation.\n */\n#define COUNT_HEADER_SIZE(V)                                         \\\ndo {                                                                 \\\n  nread += (uint32_t)(V);                                            \\\n  if (UNLIKELY(nread > max_header_size)) {                           \\\n    SET_ERRNO(HPE_HEADER_OVERFLOW);                                  \\\n    goto error;                                                      \\\n  }                                                                  \\\n} while (0)\n\n\n#define PROXY_CONNECTION \"proxy-connection\"\n#define CONNECTION \"connection\"\n#define CONTENT_LENGTH \"content-length\"\n#define TRANSFER_ENCODING \"transfer-encoding\"\n#define UPGRADE \"upgrade\"\n#define CHUNKED \"chunked\"\n#define KEEP_ALIVE \"keep-alive\"\n#define CLOSE \"close\"\n\n\nstatic const char *method_strings[] =\n  {\n#define XX(num, name, string) #string,\n  HTTP_METHOD_MAP(XX)\n#undef XX\n  };\n\n\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */\nstatic const char tokens[256] = {\n/*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */\n        0,       0,       0,       0,       0,       0,       0,       0,\n/*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */\n        0,       0,       0,       0,       0,       0,       0,       0,\n/*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */\n        0,       0,       0,       0,       0,       0,       0,       0,\n/*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */\n        0,       0,       0,       0,       0,       0,       0,       0,\n/*  32 sp    33  !    34  \"    35  #    36  $    37  %    38  &    39  '  */\n       ' ',     '!',      0,      '#',     '$',     '%',     '&',    '\\'',\n/*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */\n        0,       0,      '*',     '+',      0,      '-',     '.',      0,\n/*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */\n       '0',     '1',     '2',     '3',     '4',     '5',     '6',     '7',\n/*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */\n       '8',     '9',      0,       0,       0,       0,       0,       0,\n/*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */\n        0,      'a',     'b',     'c',     'd',     'e',     'f',     'g',\n/*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */\n       'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',\n/*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */\n       'p',     'q',     'r',     's',     't',     'u',     'v',     'w',\n/*  88  X    89  Y    90  Z    91  [    92  \\    93  ]    94  ^    95  _  */\n       'x',     'y',     'z',      0,       0,       0,      '^',     '_',\n/*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */\n       '`',     'a',     'b',     'c',     'd',     'e',     'f',     'g',\n/* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */\n       'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',\n/* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */\n       'p',     'q',     'r',     's',     't',     'u',     'v',     'w',\n/* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */\n       'x',     'y',     'z',      0,      '|',      0,      '~',       0 };\n\n\nstatic const int8_t unhex[256] =\n  {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1\n  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n  };\n\n\n#if HTTP_PARSER_STRICT\n# define T(v) 0\n#else\n# define T(v) v\n#endif\n\n\nstatic const uint8_t normal_url_char[32] = {\n/*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */\n        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,\n/*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */\n        0    | T(2)   |   0    |   0    | T(16)  |   0    |   0    |   0,\n/*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */\n        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,\n/*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */\n        0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,\n/*  32 sp    33  !    34  \"    35  #    36  $    37  %    38  &    39  '  */\n        0    |   2    |   4    |   0    |   16   |   32   |   64   |  128,\n/*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |   0,\n/*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  88  X    89  Y    90  Z    91  [    92  \\    93  ]    94  ^    95  _  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n/* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */\n        1    |   2    |   4    |   8    |   16   |   32   |   64   |   0, };\n\n#undef T\n\nenum state\n  { s_dead = 1 /* important that this is > 0 */\n\n  , s_start_req_or_res\n  , s_res_or_resp_H\n  , s_start_res\n  , s_res_H\n  , s_res_HT\n  , s_res_HTT\n  , s_res_HTTP\n  , s_res_http_major\n  , s_res_http_dot\n  , s_res_http_minor\n  , s_res_http_end\n  , s_res_first_status_code\n  , s_res_status_code\n  , s_res_status_start\n  , s_res_status\n  , s_res_line_almost_done\n\n  , s_start_req\n\n  , s_req_method\n  , s_req_spaces_before_url\n  , s_req_schema\n  , s_req_schema_slash\n  , s_req_schema_slash_slash\n  , s_req_server_start\n  , s_req_server\n  , s_req_server_with_at\n  , s_req_path\n  , s_req_query_string_start\n  , s_req_query_string\n  , s_req_fragment_start\n  , s_req_fragment\n  , s_req_http_start\n  , s_req_http_H\n  , s_req_http_HT\n  , s_req_http_HTT\n  , s_req_http_HTTP\n  , s_req_http_I\n  , s_req_http_IC\n  , s_req_http_major\n  , s_req_http_dot\n  , s_req_http_minor\n  , s_req_http_end\n  , s_req_line_almost_done\n\n  , s_header_field_start\n  , s_header_field\n  , s_header_value_discard_ws\n  , s_header_value_discard_ws_almost_done\n  , s_header_value_discard_lws\n  , s_header_value_start\n  , s_header_value\n  , s_header_value_lws\n\n  , s_header_almost_done\n\n  , s_chunk_size_start\n  , s_chunk_size\n  , s_chunk_parameters\n  , s_chunk_size_almost_done\n\n  , s_headers_almost_done\n  , s_headers_done\n\n  /* Important: 's_headers_done' must be the last 'header' state. All\n   * states beyond this must be 'body' states. It is used for overflow\n   * checking. See the PARSING_HEADER() macro.\n   */\n\n  , s_chunk_data\n  , s_chunk_data_almost_done\n  , s_chunk_data_done\n\n  , s_body_identity\n  , s_body_identity_eof\n\n  , s_message_done\n  };\n\n\n#define PARSING_HEADER(state) (state <= s_headers_done)\n\n\nenum header_states\n  { h_general = 0\n  , h_C\n  , h_CO\n  , h_CON\n\n  , h_matching_connection\n  , h_matching_proxy_connection\n  , h_matching_content_length\n  , h_matching_transfer_encoding\n  , h_matching_upgrade\n\n  , h_connection\n  , h_content_length\n  , h_content_length_num\n  , h_content_length_ws\n  , h_transfer_encoding\n  , h_upgrade\n\n  , h_matching_transfer_encoding_token_start\n  , h_matching_transfer_encoding_chunked\n  , h_matching_transfer_encoding_token\n\n  , h_matching_connection_token_start\n  , h_matching_connection_keep_alive\n  , h_matching_connection_close\n  , h_matching_connection_upgrade\n  , h_matching_connection_token\n\n  , h_transfer_encoding_chunked\n  , h_connection_keep_alive\n  , h_connection_close\n  , h_connection_upgrade\n  };\n\nenum http_host_state\n  {\n    s_http_host_dead = 1\n  , s_http_userinfo_start\n  , s_http_userinfo\n  , s_http_host_start\n  , s_http_host_v6_start\n  , s_http_host\n  , s_http_host_v6\n  , s_http_host_v6_end\n  , s_http_host_v6_zone_start\n  , s_http_host_v6_zone\n  , s_http_host_port_start\n  , s_http_host_port\n};\n\n/* Macros for character classes; depends on strict-mode  */\n#define CR                  '\\r'\n#define LF                  '\\n'\n#define LOWER(c)            (unsigned char)(c | 0x20)\n#define IS_ALPHA(c)         (LOWER(c) >= 'a' && LOWER(c) <= 'z')\n#define IS_NUM(c)           ((c) >= '0' && (c) <= '9')\n#define IS_ALPHANUM(c)      (IS_ALPHA(c) || IS_NUM(c))\n#define IS_HEX(c)           (IS_NUM(c) || (LOWER(c) >= 'a' && LOWER(c) <= 'f'))\n#define IS_MARK(c)          ((c) == '-' || (c) == '_' || (c) == '.' || \\\n  (c) == '!' || (c) == '~' || (c) == '*' || (c) == '\\'' || (c) == '(' || \\\n  (c) == ')')\n#define IS_USERINFO_CHAR(c) (IS_ALPHANUM(c) || IS_MARK(c) || (c) == '%' || \\\n  (c) == ';' || (c) == ':' || (c) == '&' || (c) == '=' || (c) == '+' || \\\n  (c) == '$' || (c) == ',')\n\n#define STRICT_TOKEN(c)     ((c == ' ') ? 0 : tokens[(unsigned char)c])\n\n#if HTTP_PARSER_STRICT\n#define TOKEN(c)            STRICT_TOKEN(c)\n#define IS_URL_CHAR(c)      (BIT_AT(normal_url_char, (unsigned char)c))\n#define IS_HOST_CHAR(c)     (IS_ALPHANUM(c) || (c) == '.' || (c) == '-')\n#else\n#define TOKEN(c)            tokens[(unsigned char)c]\n#define IS_URL_CHAR(c)                                                         \\\n  (BIT_AT(normal_url_char, (unsigned char)c) || ((c) & 0x80))\n#define IS_HOST_CHAR(c)                                                        \\\n  (IS_ALPHANUM(c) || (c) == '.' || (c) == '-' || (c) == '_')\n#endif\n\n/**\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n **/\n#define IS_HEADER_CHAR(ch)                                                     \\\n  (ch == CR || ch == LF || ch == 9 || ((unsigned char)ch > 31 && ch != 127))\n\n#define start_state (parser->type == HTTP_REQUEST ? s_start_req : s_start_res)\n\n\n#if HTTP_PARSER_STRICT\n# define STRICT_CHECK(cond)                                          \\\ndo {                                                                 \\\n  if (cond) {                                                        \\\n    SET_ERRNO(HPE_STRICT);                                           \\\n    goto error;                                                      \\\n  }                                                                  \\\n} while (0)\n# define NEW_MESSAGE() (http_should_keep_alive(parser) ? start_state : s_dead)\n#else\n# define STRICT_CHECK(cond)\n# define NEW_MESSAGE() start_state\n#endif\n\n\n/* Map errno values to strings for human-readable output */\n#define HTTP_STRERROR_GEN(n, s) { \"HPE_\" #n, s },\nstatic struct {\n  const char *name;\n  const char *description;\n} http_strerror_tab[] = {\n  HTTP_ERRNO_MAP(HTTP_STRERROR_GEN)\n};\n#undef HTTP_STRERROR_GEN\n\nint http_message_needs_eof(const http_parser *parser);\n\n/* Our URL parser.\n *\n * This is designed to be shared by http_parser_execute() for URL validation,\n * hence it has a state transition + byte-for-byte interface. In addition, it\n * is meant to be embedded in http_parser_parse_url(), which does the dirty\n * work of turning state transitions URL components for its API.\n *\n * This function should only be invoked with non-space characters. It is\n * assumed that the caller cares about (and can detect) the transition between\n * URL and non-URL states by looking for these.\n */\nstatic enum state\nparse_url_char(enum state s, const char ch)\n{\n  if (ch == ' ' || ch == '\\r' || ch == '\\n') {\n    return s_dead;\n  }\n\n#if HTTP_PARSER_STRICT\n  if (ch == '\\t' || ch == '\\f') {\n    return s_dead;\n  }\n#endif\n\n  switch (s) {\n    case s_req_spaces_before_url:\n      /* Proxied requests are followed by scheme of an absolute URI (alpha).\n       * All methods except CONNECT are followed by '/' or '*'.\n       */\n\n      if (ch == '/' || ch == '*') {\n        return s_req_path;\n      }\n\n      if (IS_ALPHA(ch)) {\n        return s_req_schema;\n      }\n\n      break;\n\n    case s_req_schema:\n      if (IS_ALPHA(ch)) {\n        return s;\n      }\n\n      if (ch == ':') {\n        return s_req_schema_slash;\n      }\n\n      break;\n\n    case s_req_schema_slash:\n      if (ch == '/') {\n        return s_req_schema_slash_slash;\n      }\n\n      break;\n\n    case s_req_schema_slash_slash:\n      if (ch == '/') {\n        return s_req_server_start;\n      }\n\n      break;\n\n    case s_req_server_with_at:\n      if (ch == '@') {\n        return s_dead;\n      }\n\n    /* fall through */\n    case s_req_server_start:\n    case s_req_server:\n      if (ch == '/') {\n        return s_req_path;\n      }\n\n      if (ch == '?') {\n        return s_req_query_string_start;\n      }\n\n      if (ch == '@') {\n        return s_req_server_with_at;\n      }\n\n      if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {\n        return s_req_server;\n      }\n\n      break;\n\n    case s_req_path:\n      if (IS_URL_CHAR(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case '?':\n          return s_req_query_string_start;\n\n        case '#':\n          return s_req_fragment_start;\n      }\n\n      break;\n\n    case s_req_query_string_start:\n    case s_req_query_string:\n      if (IS_URL_CHAR(ch)) {\n        return s_req_query_string;\n      }\n\n      switch (ch) {\n        case '?':\n          /* allow extra '?' in query string */\n          return s_req_query_string;\n\n        case '#':\n          return s_req_fragment_start;\n      }\n\n      break;\n\n    case s_req_fragment_start:\n      if (IS_URL_CHAR(ch)) {\n        return s_req_fragment;\n      }\n\n      switch (ch) {\n        case '?':\n          return s_req_fragment;\n\n        case '#':\n          return s;\n      }\n\n      break;\n\n    case s_req_fragment:\n      if (IS_URL_CHAR(ch)) {\n        return s;\n      }\n\n      switch (ch) {\n        case '?':\n        case '#':\n          return s;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  /* We should never fall out of the switch above unless there's an error */\n  return s_dead;\n}\n\nsize_t http_parser_execute (http_parser *parser,\n                            const http_parser_settings *settings,\n                            const char *data,\n                            size_t len)\n{\n  char c, ch;\n  int8_t unhex_val;\n  const char *p = data;\n  const char *header_field_mark = 0;\n  const char *header_value_mark = 0;\n  const char *url_mark = 0;\n  const char *body_mark = 0;\n  const char *status_mark = 0;\n  enum state p_state = (enum state) parser->state;\n  const unsigned int lenient = parser->lenient_http_headers;\n  const unsigned int allow_chunked_length = parser->allow_chunked_length;\n\n  uint32_t nread = parser->nread;\n\n  /* We're in an error state. Don't bother doing anything. */\n  if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {\n    return 0;\n  }\n\n  if (len == 0) {\n    switch (CURRENT_STATE()) {\n      case s_body_identity_eof:\n        /* Use of CALLBACK_NOTIFY() here would erroneously return 1 byte read if\n         * we got paused.\n         */\n        CALLBACK_NOTIFY_NOADVANCE(message_complete);\n        return 0;\n\n      case s_dead:\n      case s_start_req_or_res:\n      case s_start_res:\n      case s_start_req:\n        return 0;\n\n      default:\n        SET_ERRNO(HPE_INVALID_EOF_STATE);\n        return 1;\n    }\n  }\n\n\n  if (CURRENT_STATE() == s_header_field)\n    header_field_mark = data;\n  if (CURRENT_STATE() == s_header_value)\n    header_value_mark = data;\n  switch (CURRENT_STATE()) {\n  case s_req_path:\n  case s_req_schema:\n  case s_req_schema_slash:\n  case s_req_schema_slash_slash:\n  case s_req_server_start:\n  case s_req_server:\n  case s_req_server_with_at:\n  case s_req_query_string_start:\n  case s_req_query_string:\n  case s_req_fragment_start:\n  case s_req_fragment:\n    url_mark = data;\n    break;\n  case s_res_status:\n    status_mark = data;\n    break;\n  default:\n    break;\n  }\n\n  for (p=data; p != data + len; p++) {\n    ch = *p;\n\n    if (PARSING_HEADER(CURRENT_STATE()))\n      COUNT_HEADER_SIZE(1);\n\nreexecute:\n    switch (CURRENT_STATE()) {\n\n      case s_dead:\n        /* this state is used after a 'Connection: close' message\n         * the parser will error out if it reads another message\n         */\n        if (LIKELY(ch == CR || ch == LF))\n          break;\n\n        SET_ERRNO(HPE_CLOSED_CONNECTION);\n        goto error;\n\n      case s_start_req_or_res:\n      {\n        if (ch == CR || ch == LF)\n          break;\n        parser->flags = 0;\n        parser->uses_transfer_encoding = 0;\n        parser->content_length = ULLONG_MAX;\n\n        if (ch == 'H') {\n          UPDATE_STATE(s_res_or_resp_H);\n\n          CALLBACK_NOTIFY(message_begin);\n        } else {\n          parser->type = HTTP_REQUEST;\n          UPDATE_STATE(s_start_req);\n          REEXECUTE();\n        }\n\n        break;\n      }\n\n      case s_res_or_resp_H:\n        if (ch == 'T') {\n          parser->type = HTTP_RESPONSE;\n          UPDATE_STATE(s_res_HT);\n        } else {\n          if (UNLIKELY(ch != 'E')) {\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n          }\n\n          parser->type = HTTP_REQUEST;\n          parser->method = HTTP_HEAD;\n          parser->index = 2;\n          UPDATE_STATE(s_req_method);\n        }\n        break;\n\n      case s_start_res:\n      {\n        if (ch == CR || ch == LF)\n          break;\n        parser->flags = 0;\n        parser->uses_transfer_encoding = 0;\n        parser->content_length = ULLONG_MAX;\n\n        if (ch == 'H') {\n          UPDATE_STATE(s_res_H);\n        } else {\n          SET_ERRNO(HPE_INVALID_CONSTANT);\n          goto error;\n        }\n\n        CALLBACK_NOTIFY(message_begin);\n        break;\n      }\n\n      case s_res_H:\n        STRICT_CHECK(ch != 'T');\n        UPDATE_STATE(s_res_HT);\n        break;\n\n      case s_res_HT:\n        STRICT_CHECK(ch != 'T');\n        UPDATE_STATE(s_res_HTT);\n        break;\n\n      case s_res_HTT:\n        STRICT_CHECK(ch != 'P');\n        UPDATE_STATE(s_res_HTTP);\n        break;\n\n      case s_res_HTTP:\n        STRICT_CHECK(ch != '/');\n        UPDATE_STATE(s_res_http_major);\n        break;\n\n      case s_res_http_major:\n        if (UNLIKELY(!IS_NUM(ch))) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major = ch - '0';\n        UPDATE_STATE(s_res_http_dot);\n        break;\n\n      case s_res_http_dot:\n      {\n        if (UNLIKELY(ch != '.')) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        UPDATE_STATE(s_res_http_minor);\n        break;\n      }\n\n      case s_res_http_minor:\n        if (UNLIKELY(!IS_NUM(ch))) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor = ch - '0';\n        UPDATE_STATE(s_res_http_end);\n        break;\n\n      case s_res_http_end:\n      {\n        if (UNLIKELY(ch != ' ')) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        UPDATE_STATE(s_res_first_status_code);\n        break;\n      }\n\n      case s_res_first_status_code:\n      {\n        if (!IS_NUM(ch)) {\n          if (ch == ' ') {\n            break;\n          }\n\n          SET_ERRNO(HPE_INVALID_STATUS);\n          goto error;\n        }\n        parser->status_code = ch - '0';\n        UPDATE_STATE(s_res_status_code);\n        break;\n      }\n\n      case s_res_status_code:\n      {\n        if (!IS_NUM(ch)) {\n          switch (ch) {\n            case ' ':\n              UPDATE_STATE(s_res_status_start);\n              break;\n            case CR:\n            case LF:\n              UPDATE_STATE(s_res_status_start);\n              REEXECUTE();\n              break;\n            default:\n              SET_ERRNO(HPE_INVALID_STATUS);\n              goto error;\n          }\n          break;\n        }\n\n        parser->status_code *= 10;\n        parser->status_code += ch - '0';\n\n        if (UNLIKELY(parser->status_code > 999)) {\n          SET_ERRNO(HPE_INVALID_STATUS);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_res_status_start:\n      {\n        MARK(status);\n        UPDATE_STATE(s_res_status);\n        parser->index = 0;\n\n        if (ch == CR || ch == LF)\n          REEXECUTE();\n\n        break;\n      }\n\n      case s_res_status:\n        if (ch == CR) {\n          UPDATE_STATE(s_res_line_almost_done);\n          CALLBACK_DATA(status);\n          break;\n        }\n\n        if (ch == LF) {\n          UPDATE_STATE(s_header_field_start);\n          CALLBACK_DATA(status);\n          break;\n        }\n\n        break;\n\n      case s_res_line_almost_done:\n        STRICT_CHECK(ch != LF);\n        UPDATE_STATE(s_header_field_start);\n        break;\n\n      case s_start_req:\n      {\n        if (ch == CR || ch == LF)\n          break;\n        parser->flags = 0;\n        parser->uses_transfer_encoding = 0;\n        parser->content_length = ULLONG_MAX;\n\n        if (UNLIKELY(!IS_ALPHA(ch))) {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        parser->method = (enum http_method) 0;\n        parser->index = 1;\n        switch (ch) {\n          case 'A': parser->method = HTTP_ACL; break;\n          case 'B': parser->method = HTTP_BIND; break;\n          case 'C': parser->method = HTTP_CONNECT; /* or COPY, CHECKOUT */ break;\n          case 'D': parser->method = HTTP_DELETE; break;\n          case 'G': parser->method = HTTP_GET; break;\n          case 'H': parser->method = HTTP_HEAD; break;\n          case 'L': parser->method = HTTP_LOCK; /* or LINK */ break;\n          case 'M': parser->method = HTTP_MKCOL; /* or MOVE, MKACTIVITY, MERGE, M-SEARCH, MKCALENDAR */ break;\n          case 'N': parser->method = HTTP_NOTIFY; break;\n          case 'O': parser->method = HTTP_OPTIONS; break;\n          case 'P': parser->method = HTTP_POST;\n            /* or PROPFIND|PROPPATCH|PUT|PATCH|PURGE */\n            break;\n          case 'R': parser->method = HTTP_REPORT; /* or REBIND */ break;\n          case 'S': parser->method = HTTP_SUBSCRIBE; /* or SEARCH, SOURCE */ break;\n          case 'T': parser->method = HTTP_TRACE; break;\n          case 'U': parser->method = HTTP_UNLOCK; /* or UNSUBSCRIBE, UNBIND, UNLINK */ break;\n          default:\n            SET_ERRNO(HPE_INVALID_METHOD);\n            goto error;\n        }\n        UPDATE_STATE(s_req_method);\n\n        CALLBACK_NOTIFY(message_begin);\n\n        break;\n      }\n\n      case s_req_method:\n      {\n        const char *matcher;\n        if (UNLIKELY(ch == '\\0')) {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        matcher = method_strings[parser->method];\n        if (ch == ' ' && matcher[parser->index] == '\\0') {\n          UPDATE_STATE(s_req_spaces_before_url);\n        } else if (ch == matcher[parser->index]) {\n          ; /* nada */\n        } else if ((ch >= 'A' && ch <= 'Z') || ch == '-') {\n\n          switch (parser->method << 16 | parser->index << 8 | ch) {\n#define XX(meth, pos, ch, new_meth) \\\n            case (HTTP_##meth << 16 | pos << 8 | ch): \\\n              parser->method = HTTP_##new_meth; break;\n\n            XX(POST,      1, 'U', PUT)\n            XX(POST,      1, 'A', PATCH)\n            XX(POST,      1, 'R', PROPFIND)\n            XX(PUT,       2, 'R', PURGE)\n            XX(CONNECT,   1, 'H', CHECKOUT)\n            XX(CONNECT,   2, 'P', COPY)\n            XX(MKCOL,     1, 'O', MOVE)\n            XX(MKCOL,     1, 'E', MERGE)\n            XX(MKCOL,     1, '-', MSEARCH)\n            XX(MKCOL,     2, 'A', MKACTIVITY)\n            XX(MKCOL,     3, 'A', MKCALENDAR)\n            XX(SUBSCRIBE, 1, 'E', SEARCH)\n            XX(SUBSCRIBE, 1, 'O', SOURCE)\n            XX(REPORT,    2, 'B', REBIND)\n            XX(PROPFIND,  4, 'P', PROPPATCH)\n            XX(LOCK,      1, 'I', LINK)\n            XX(UNLOCK,    2, 'S', UNSUBSCRIBE)\n            XX(UNLOCK,    2, 'B', UNBIND)\n            XX(UNLOCK,    3, 'I', UNLINK)\n#undef XX\n            default:\n              SET_ERRNO(HPE_INVALID_METHOD);\n              goto error;\n          }\n        } else {\n          SET_ERRNO(HPE_INVALID_METHOD);\n          goto error;\n        }\n\n        ++parser->index;\n        break;\n      }\n\n      case s_req_spaces_before_url:\n      {\n        if (ch == ' ') break;\n\n        MARK(url);\n        if (parser->method == HTTP_CONNECT) {\n          UPDATE_STATE(s_req_server_start);\n        }\n\n        UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));\n        if (UNLIKELY(CURRENT_STATE() == s_dead)) {\n          SET_ERRNO(HPE_INVALID_URL);\n          goto error;\n        }\n\n        break;\n      }\n\n      case s_req_schema:\n      case s_req_schema_slash:\n      case s_req_schema_slash_slash:\n      case s_req_server_start:\n      {\n        switch (ch) {\n          /* No whitespace allowed here */\n          case ' ':\n          case CR:\n          case LF:\n            SET_ERRNO(HPE_INVALID_URL);\n            goto error;\n          default:\n            UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));\n            if (UNLIKELY(CURRENT_STATE() == s_dead)) {\n              SET_ERRNO(HPE_INVALID_URL);\n              goto error;\n            }\n        }\n\n        break;\n      }\n\n      case s_req_server:\n      case s_req_server_with_at:\n      case s_req_path:\n      case s_req_query_string_start:\n      case s_req_query_string:\n      case s_req_fragment_start:\n      case s_req_fragment:\n      {\n        switch (ch) {\n          case ' ':\n            UPDATE_STATE(s_req_http_start);\n            CALLBACK_DATA(url);\n            break;\n          case CR:\n          case LF:\n            parser->http_major = 0;\n            parser->http_minor = 9;\n            UPDATE_STATE((ch == CR) ?\n              s_req_line_almost_done :\n              s_header_field_start);\n            CALLBACK_DATA(url);\n            break;\n          default:\n            UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));\n            if (UNLIKELY(CURRENT_STATE() == s_dead)) {\n              SET_ERRNO(HPE_INVALID_URL);\n              goto error;\n            }\n        }\n        break;\n      }\n\n      case s_req_http_start:\n        switch (ch) {\n          case ' ':\n            break;\n          case 'H':\n            UPDATE_STATE(s_req_http_H);\n            break;\n          case 'I':\n            if (parser->method == HTTP_SOURCE) {\n              UPDATE_STATE(s_req_http_I);\n              break;\n            }\n            /* fall through */\n          default:\n            SET_ERRNO(HPE_INVALID_CONSTANT);\n            goto error;\n        }\n        break;\n\n      case s_req_http_H:\n        STRICT_CHECK(ch != 'T');\n        UPDATE_STATE(s_req_http_HT);\n        break;\n\n      case s_req_http_HT:\n        STRICT_CHECK(ch != 'T');\n        UPDATE_STATE(s_req_http_HTT);\n        break;\n\n      case s_req_http_HTT:\n        STRICT_CHECK(ch != 'P');\n        UPDATE_STATE(s_req_http_HTTP);\n        break;\n\n      case s_req_http_I:\n        STRICT_CHECK(ch != 'C');\n        UPDATE_STATE(s_req_http_IC);\n        break;\n\n      case s_req_http_IC:\n        STRICT_CHECK(ch != 'E');\n        UPDATE_STATE(s_req_http_HTTP);  /* Treat \"ICE\" as \"HTTP\". */\n        break;\n\n      case s_req_http_HTTP:\n        STRICT_CHECK(ch != '/');\n        UPDATE_STATE(s_req_http_major);\n        break;\n\n      case s_req_http_major:\n        if (UNLIKELY(!IS_NUM(ch))) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_major = ch - '0';\n        UPDATE_STATE(s_req_http_dot);\n        break;\n\n      case s_req_http_dot:\n      {\n        if (UNLIKELY(ch != '.')) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        UPDATE_STATE(s_req_http_minor);\n        break;\n      }\n\n      case s_req_http_minor:\n        if (UNLIKELY(!IS_NUM(ch))) {\n          SET_ERRNO(HPE_INVALID_VERSION);\n          goto error;\n        }\n\n        parser->http_minor = ch - '0';\n        UPDATE_STATE(s_req_http_end);\n        break;\n\n      case s_req_http_end:\n      {\n        if (ch == CR) {\n          UPDATE_STATE(s_req_line_almost_done);\n          break;\n        }\n\n        if (ch == LF) {\n          UPDATE_STATE(s_header_field_start);\n          break;\n        }\n\n        SET_ERRNO(HPE_INVALID_VERSION);\n        goto error;\n        break;\n      }\n\n      /* end of request line */\n      case s_req_line_almost_done:\n      {\n        if (UNLIKELY(ch != LF)) {\n          SET_ERRNO(HPE_LF_EXPECTED);\n          goto error;\n        }\n\n        UPDATE_STATE(s_header_field_start);\n        break;\n      }\n\n      case s_header_field_start:\n      {\n        if (ch == CR) {\n          UPDATE_STATE(s_headers_almost_done);\n          break;\n        }\n\n        if (ch == LF) {\n          /* they might be just sending \\n instead of \\r\\n so this would be\n           * the second \\n to denote the end of headers*/\n          UPDATE_STATE(s_headers_almost_done);\n          REEXECUTE();\n        }\n\n        c = TOKEN(ch);\n\n        if (UNLIKELY(!c)) {\n          SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n          goto error;\n        }\n\n        MARK(header_field);\n\n        parser->index = 0;\n        UPDATE_STATE(s_header_field);\n\n        switch (c) {\n          case 'c':\n            parser->header_state = h_C;\n            break;\n\n          case 'p':\n            parser->header_state = h_matching_proxy_connection;\n            break;\n\n          case 't':\n            parser->header_state = h_matching_transfer_encoding;\n            break;\n\n          case 'u':\n            parser->header_state = h_matching_upgrade;\n            break;\n\n          default:\n            parser->header_state = h_general;\n            break;\n        }\n        break;\n      }\n\n      case s_header_field:\n      {\n        const char* start = p;\n        for (; p != data + len; p++) {\n          ch = *p;\n          c = TOKEN(ch);\n\n          if (!c)\n            break;\n\n          switch (parser->header_state) {\n            case h_general: {\n              size_t left = data + len - p;\n              const char* pe = p + MIN(left, max_header_size);\n              while (p+1 < pe && TOKEN(p[1])) {\n                p++;\n              }\n              break;\n            }\n\n            case h_C:\n              parser->index++;\n              parser->header_state = (c == 'o' ? h_CO : h_general);\n              break;\n\n            case h_CO:\n              parser->index++;\n              parser->header_state = (c == 'n' ? h_CON : h_general);\n              break;\n\n            case h_CON:\n              parser->index++;\n              switch (c) {\n                case 'n':\n                  parser->header_state = h_matching_connection;\n                  break;\n                case 't':\n                  parser->header_state = h_matching_content_length;\n                  break;\n                default:\n                  parser->header_state = h_general;\n                  break;\n              }\n              break;\n\n            /* connection */\n\n            case h_matching_connection:\n              parser->index++;\n              if (parser->index > sizeof(CONNECTION)-1\n                  || c != CONNECTION[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(CONNECTION)-2) {\n                parser->header_state = h_connection;\n              }\n              break;\n\n            /* proxy-connection */\n\n            case h_matching_proxy_connection:\n              parser->index++;\n              if (parser->index > sizeof(PROXY_CONNECTION)-1\n                  || c != PROXY_CONNECTION[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(PROXY_CONNECTION)-2) {\n                parser->header_state = h_connection;\n              }\n              break;\n\n            /* content-length */\n\n            case h_matching_content_length:\n              parser->index++;\n              if (parser->index > sizeof(CONTENT_LENGTH)-1\n                  || c != CONTENT_LENGTH[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(CONTENT_LENGTH)-2) {\n                parser->header_state = h_content_length;\n              }\n              break;\n\n            /* transfer-encoding */\n\n            case h_matching_transfer_encoding:\n              parser->index++;\n              if (parser->index > sizeof(TRANSFER_ENCODING)-1\n                  || c != TRANSFER_ENCODING[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(TRANSFER_ENCODING)-2) {\n                parser->header_state = h_transfer_encoding;\n                parser->uses_transfer_encoding = 1;\n              }\n              break;\n\n            /* upgrade */\n\n            case h_matching_upgrade:\n              parser->index++;\n              if (parser->index > sizeof(UPGRADE)-1\n                  || c != UPGRADE[parser->index]) {\n                parser->header_state = h_general;\n              } else if (parser->index == sizeof(UPGRADE)-2) {\n                parser->header_state = h_upgrade;\n              }\n              break;\n\n            case h_connection:\n            case h_content_length:\n            case h_transfer_encoding:\n            case h_upgrade:\n              if (ch != ' ') parser->header_state = h_general;\n              break;\n\n            default:\n              assert(0 && \"Unknown header_state\");\n              break;\n          }\n        }\n\n        if (p == data + len) {\n          --p;\n          COUNT_HEADER_SIZE(p - start);\n          break;\n        }\n\n        COUNT_HEADER_SIZE(p - start);\n\n        if (ch == ':') {\n          UPDATE_STATE(s_header_value_discard_ws);\n          CALLBACK_DATA(header_field);\n          break;\n        }\n\n        SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n        goto error;\n      }\n\n      case s_header_value_discard_ws:\n        if (ch == ' ' || ch == '\\t') break;\n\n        if (ch == CR) {\n          UPDATE_STATE(s_header_value_discard_ws_almost_done);\n          break;\n        }\n\n        if (ch == LF) {\n          UPDATE_STATE(s_header_value_discard_lws);\n          break;\n        }\n\n        /* fall through */\n\n      case s_header_value_start:\n      {\n        MARK(header_value);\n\n        UPDATE_STATE(s_header_value);\n        parser->index = 0;\n\n        c = LOWER(ch);\n\n        switch (parser->header_state) {\n          case h_upgrade:\n            parser->flags |= F_UPGRADE;\n            parser->header_state = h_general;\n            break;\n\n          case h_transfer_encoding:\n            /* looking for 'Transfer-Encoding: chunked' */\n            if ('c' == c) {\n              parser->header_state = h_matching_transfer_encoding_chunked;\n            } else {\n              parser->header_state = h_matching_transfer_encoding_token;\n            }\n            break;\n\n          /* Multi-value `Transfer-Encoding` header */\n          case h_matching_transfer_encoding_token_start:\n            break;\n\n          case h_content_length:\n            if (UNLIKELY(!IS_NUM(ch))) {\n              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n              goto error;\n            }\n\n            if (parser->flags & F_CONTENTLENGTH) {\n              SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);\n              goto error;\n            }\n\n            parser->flags |= F_CONTENTLENGTH;\n            parser->content_length = ch - '0';\n            parser->header_state = h_content_length_num;\n            break;\n\n          /* when obsolete line folding is encountered for content length\n           * continue to the s_header_value state */\n          case h_content_length_ws:\n            break;\n\n          case h_connection:\n            /* looking for 'Connection: keep-alive' */\n            if (c == 'k') {\n              parser->header_state = h_matching_connection_keep_alive;\n            /* looking for 'Connection: close' */\n            } else if (c == 'c') {\n              parser->header_state = h_matching_connection_close;\n            } else if (c == 'u') {\n              parser->header_state = h_matching_connection_upgrade;\n            } else {\n              parser->header_state = h_matching_connection_token;\n            }\n            break;\n\n          /* Multi-value `Connection` header */\n          case h_matching_connection_token_start:\n            break;\n\n          default:\n            parser->header_state = h_general;\n            break;\n        }\n        break;\n      }\n\n      case s_header_value:\n      {\n        const char* start = p;\n        enum header_states h_state = (enum header_states) parser->header_state;\n        for (; p != data + len; p++) {\n          ch = *p;\n          if (ch == CR) {\n            UPDATE_STATE(s_header_almost_done);\n            parser->header_state = h_state;\n            CALLBACK_DATA(header_value);\n            break;\n          }\n\n          if (ch == LF) {\n            UPDATE_STATE(s_header_almost_done);\n            COUNT_HEADER_SIZE(p - start);\n            parser->header_state = h_state;\n            CALLBACK_DATA_NOADVANCE(header_value);\n            REEXECUTE();\n          }\n\n          if (!lenient && !IS_HEADER_CHAR(ch)) {\n            SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n            goto error;\n          }\n\n          c = LOWER(ch);\n\n          switch (h_state) {\n            case h_general:\n              {\n                size_t left = data + len - p;\n                const char* pe = p + MIN(left, max_header_size);\n\n                for (; p != pe; p++) {\n                  ch = *p;\n                  if (ch == CR || ch == LF) {\n                    --p;\n                    break;\n                  }\n                  if (!lenient && !IS_HEADER_CHAR(ch)) {\n                    SET_ERRNO(HPE_INVALID_HEADER_TOKEN);\n                    goto error;\n                  }\n                }\n                if (p == data + len)\n                  --p;\n                break;\n              }\n\n            case h_connection:\n            case h_transfer_encoding:\n              assert(0 && \"Shouldn't get here.\");\n              break;\n\n            case h_content_length:\n              if (ch == ' ') break;\n              h_state = h_content_length_num;\n              /* fall through */\n\n            case h_content_length_num:\n            {\n              uint64_t t;\n\n              if (ch == ' ') {\n                h_state = h_content_length_ws;\n                break;\n              }\n\n              if (UNLIKELY(!IS_NUM(ch))) {\n                SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n                parser->header_state = h_state;\n                goto error;\n              }\n\n              t = parser->content_length;\n              t *= 10;\n              t += ch - '0';\n\n              /* Overflow? Test against a conservative limit for simplicity. */\n              if (UNLIKELY((ULLONG_MAX - 10) / 10 < parser->content_length)) {\n                SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n                parser->header_state = h_state;\n                goto error;\n              }\n\n              parser->content_length = t;\n              break;\n            }\n\n            case h_content_length_ws:\n              if (ch == ' ') break;\n              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n              parser->header_state = h_state;\n              goto error;\n\n            /* Transfer-Encoding: chunked */\n            case h_matching_transfer_encoding_token_start:\n              /* looking for 'Transfer-Encoding: chunked' */\n              if ('c' == c) {\n                h_state = h_matching_transfer_encoding_chunked;\n              } else if (STRICT_TOKEN(c)) {\n                /* TODO(indutny): similar code below does this, but why?\n                 * At the very least it seems to be inconsistent given that\n                 * h_matching_transfer_encoding_token does not check for\n                 * `STRICT_TOKEN`\n                 */\n                h_state = h_matching_transfer_encoding_token;\n              } else if (c == ' ' || c == '\\t') {\n                /* Skip lws */\n              } else {\n                h_state = h_general;\n              }\n              break;\n\n            case h_matching_transfer_encoding_chunked:\n              parser->index++;\n              if (parser->index > sizeof(CHUNKED)-1\n                  || c != CHUNKED[parser->index]) {\n                h_state = h_matching_transfer_encoding_token;\n              } else if (parser->index == sizeof(CHUNKED)-2) {\n                h_state = h_transfer_encoding_chunked;\n              }\n              break;\n\n            case h_matching_transfer_encoding_token:\n              if (ch == ',') {\n                h_state = h_matching_transfer_encoding_token_start;\n                parser->index = 0;\n              }\n              break;\n\n            case h_matching_connection_token_start:\n              /* looking for 'Connection: keep-alive' */\n              if (c == 'k') {\n                h_state = h_matching_connection_keep_alive;\n              /* looking for 'Connection: close' */\n              } else if (c == 'c') {\n                h_state = h_matching_connection_close;\n              } else if (c == 'u') {\n                h_state = h_matching_connection_upgrade;\n              } else if (STRICT_TOKEN(c)) {\n                h_state = h_matching_connection_token;\n              } else if (c == ' ' || c == '\\t') {\n                /* Skip lws */\n              } else {\n                h_state = h_general;\n              }\n              break;\n\n            /* looking for 'Connection: keep-alive' */\n            case h_matching_connection_keep_alive:\n              parser->index++;\n              if (parser->index > sizeof(KEEP_ALIVE)-1\n                  || c != KEEP_ALIVE[parser->index]) {\n                h_state = h_matching_connection_token;\n              } else if (parser->index == sizeof(KEEP_ALIVE)-2) {\n                h_state = h_connection_keep_alive;\n              }\n              break;\n\n            /* looking for 'Connection: close' */\n            case h_matching_connection_close:\n              parser->index++;\n              if (parser->index > sizeof(CLOSE)-1 || c != CLOSE[parser->index]) {\n                h_state = h_matching_connection_token;\n              } else if (parser->index == sizeof(CLOSE)-2) {\n                h_state = h_connection_close;\n              }\n              break;\n\n            /* looking for 'Connection: upgrade' */\n            case h_matching_connection_upgrade:\n              parser->index++;\n              if (parser->index > sizeof(UPGRADE) - 1 ||\n                  c != UPGRADE[parser->index]) {\n                h_state = h_matching_connection_token;\n              } else if (parser->index == sizeof(UPGRADE)-2) {\n                h_state = h_connection_upgrade;\n              }\n              break;\n\n            case h_matching_connection_token:\n              if (ch == ',') {\n                h_state = h_matching_connection_token_start;\n                parser->index = 0;\n              }\n              break;\n\n            case h_transfer_encoding_chunked:\n              if (ch != ' ') h_state = h_matching_transfer_encoding_token;\n              break;\n\n            case h_connection_keep_alive:\n            case h_connection_close:\n            case h_connection_upgrade:\n              if (ch == ',') {\n                if (h_state == h_connection_keep_alive) {\n                  parser->flags |= F_CONNECTION_KEEP_ALIVE;\n                } else if (h_state == h_connection_close) {\n                  parser->flags |= F_CONNECTION_CLOSE;\n                } else if (h_state == h_connection_upgrade) {\n                  parser->flags |= F_CONNECTION_UPGRADE;\n                }\n                h_state = h_matching_connection_token_start;\n                parser->index = 0;\n              } else if (ch != ' ') {\n                h_state = h_matching_connection_token;\n              }\n              break;\n\n            default:\n              UPDATE_STATE(s_header_value);\n              h_state = h_general;\n              break;\n          }\n        }\n        parser->header_state = h_state;\n\n        if (p == data + len)\n          --p;\n\n        COUNT_HEADER_SIZE(p - start);\n        break;\n      }\n\n      case s_header_almost_done:\n      {\n        if (UNLIKELY(ch != LF)) {\n          SET_ERRNO(HPE_LF_EXPECTED);\n          goto error;\n        }\n\n        UPDATE_STATE(s_header_value_lws);\n        break;\n      }\n\n      case s_header_value_lws:\n      {\n        if (ch == ' ' || ch == '\\t') {\n          if (parser->header_state == h_content_length_num) {\n              /* treat obsolete line folding as space */\n              parser->header_state = h_content_length_ws;\n          }\n          UPDATE_STATE(s_header_value_start);\n          REEXECUTE();\n        }\n\n        /* finished the header */\n        switch (parser->header_state) {\n          case h_connection_keep_alive:\n            parser->flags |= F_CONNECTION_KEEP_ALIVE;\n            break;\n          case h_connection_close:\n            parser->flags |= F_CONNECTION_CLOSE;\n            break;\n          case h_transfer_encoding_chunked:\n            parser->flags |= F_CHUNKED;\n            break;\n          case h_connection_upgrade:\n            parser->flags |= F_CONNECTION_UPGRADE;\n            break;\n          default:\n            break;\n        }\n\n        UPDATE_STATE(s_header_field_start);\n        REEXECUTE();\n      }\n\n      case s_header_value_discard_ws_almost_done:\n      {\n        STRICT_CHECK(ch != LF);\n        UPDATE_STATE(s_header_value_discard_lws);\n        break;\n      }\n\n      case s_header_value_discard_lws:\n      {\n        if (ch == ' ' || ch == '\\t') {\n          UPDATE_STATE(s_header_value_discard_ws);\n          break;\n        } else {\n          switch (parser->header_state) {\n            case h_connection_keep_alive:\n              parser->flags |= F_CONNECTION_KEEP_ALIVE;\n              break;\n            case h_connection_close:\n              parser->flags |= F_CONNECTION_CLOSE;\n              break;\n            case h_connection_upgrade:\n              parser->flags |= F_CONNECTION_UPGRADE;\n              break;\n            case h_transfer_encoding_chunked:\n              parser->flags |= F_CHUNKED;\n              break;\n            case h_content_length:\n              /* do not allow empty content length */\n              SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n              goto error;\n              break;\n            default:\n              break;\n          }\n\n          /* header value was empty */\n          MARK(header_value);\n          UPDATE_STATE(s_header_field_start);\n          CALLBACK_DATA_NOADVANCE(header_value);\n          REEXECUTE();\n        }\n      }\n\n      case s_headers_almost_done:\n      {\n        STRICT_CHECK(ch != LF);\n\n        if (parser->flags & F_TRAILING) {\n          /* End of a chunked request */\n          UPDATE_STATE(s_message_done);\n          CALLBACK_NOTIFY_NOADVANCE(chunk_complete);\n          REEXECUTE();\n        }\n\n        /* Cannot use transfer-encoding and a content-length header together\n           per the HTTP specification. (RFC 7230 Section 3.3.3) */\n        if ((parser->uses_transfer_encoding == 1) &&\n            (parser->flags & F_CONTENTLENGTH)) {\n          /* Allow it for lenient parsing as long as `Transfer-Encoding` is\n           * not `chunked` or allow_length_with_encoding is set\n           */\n          if (parser->flags & F_CHUNKED) {\n            if (!allow_chunked_length) {\n              SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);\n              goto error;\n            }\n          } else if (!lenient) {\n            SET_ERRNO(HPE_UNEXPECTED_CONTENT_LENGTH);\n            goto error;\n          }\n        }\n\n        UPDATE_STATE(s_headers_done);\n\n        /* Set this here so that on_headers_complete() callbacks can see it */\n        if ((parser->flags & F_UPGRADE) &&\n            (parser->flags & F_CONNECTION_UPGRADE)) {\n          /* For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n           * mandatory only when it is a 101 Switching Protocols response,\n           * otherwise it is purely informational, to announce support.\n           */\n          parser->upgrade =\n              (parser->type == HTTP_REQUEST || parser->status_code == 101);\n        } else {\n          parser->upgrade = (parser->method == HTTP_CONNECT);\n        }\n\n        /* Here we call the headers_complete callback. This is somewhat\n         * different than other callbacks because if the user returns 1, we\n         * will interpret that as saying that this message has no body. This\n         * is needed for the annoying case of recieving a response to a HEAD\n         * request.\n         *\n         * We'd like to use CALLBACK_NOTIFY_NOADVANCE() here but we cannot, so\n         * we have to simulate it by handling a change in errno below.\n         */\n        if (settings->on_headers_complete) {\n          switch (settings->on_headers_complete(parser)) {\n            case 0:\n              break;\n\n            case 2:\n              parser->upgrade = 1;\n\n              /* fall through */\n            case 1:\n              parser->flags |= F_SKIPBODY;\n              break;\n\n            default:\n              SET_ERRNO(HPE_CB_headers_complete);\n              RETURN(p - data); /* Error */\n          }\n        }\n\n        if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {\n          RETURN(p - data);\n        }\n\n        REEXECUTE();\n      }\n\n      case s_headers_done:\n      {\n        int hasBody;\n        STRICT_CHECK(ch != LF);\n\n        parser->nread = 0;\n        nread = 0;\n\n        hasBody = parser->flags & F_CHUNKED ||\n          (parser->content_length > 0 && parser->content_length != ULLONG_MAX);\n        if (parser->upgrade && (parser->method == HTTP_CONNECT ||\n                                (parser->flags & F_SKIPBODY) || !hasBody)) {\n          /* Exit, the rest of the message is in a different protocol. */\n          UPDATE_STATE(NEW_MESSAGE());\n          CALLBACK_NOTIFY(message_complete);\n          RETURN((p - data) + 1);\n        }\n\n        if (parser->flags & F_SKIPBODY) {\n          UPDATE_STATE(NEW_MESSAGE());\n          CALLBACK_NOTIFY(message_complete);\n        } else if (parser->flags & F_CHUNKED) {\n          /* chunked encoding - ignore Content-Length header,\n           * prepare for a chunk */\n          UPDATE_STATE(s_chunk_size_start);\n        } else if (parser->uses_transfer_encoding == 1) {\n          if (parser->type == HTTP_REQUEST && !lenient) {\n            /* RFC 7230 3.3.3 */\n\n            /* If a Transfer-Encoding header field\n             * is present in a request and the chunked transfer coding is not\n             * the final encoding, the message body length cannot be determined\n             * reliably; the server MUST respond with the 400 (Bad Request)\n             * status code and then close the connection.\n             */\n            SET_ERRNO(HPE_INVALID_TRANSFER_ENCODING);\n            RETURN(p - data); /* Error */\n          } else {\n            /* RFC 7230 3.3.3 */\n\n            /* If a Transfer-Encoding header field is present in a response and\n             * the chunked transfer coding is not the final encoding, the\n             * message body length is determined by reading the connection until\n             * it is closed by the server.\n             */\n            UPDATE_STATE(s_body_identity_eof);\n          }\n        } else {\n          if (parser->content_length == 0) {\n            /* Content-Length header given but zero: Content-Length: 0\\r\\n */\n            UPDATE_STATE(NEW_MESSAGE());\n            CALLBACK_NOTIFY(message_complete);\n          } else if (parser->content_length != ULLONG_MAX) {\n            /* Content-Length header given and non-zero */\n            UPDATE_STATE(s_body_identity);\n          } else {\n            if (!http_message_needs_eof(parser)) {\n              /* Assume content-length 0 - read the next */\n              UPDATE_STATE(NEW_MESSAGE());\n              CALLBACK_NOTIFY(message_complete);\n            } else {\n              /* Read body until EOF */\n              UPDATE_STATE(s_body_identity_eof);\n            }\n          }\n        }\n\n        break;\n      }\n\n      case s_body_identity:\n      {\n        uint64_t to_read = MIN(parser->content_length,\n                               (uint64_t) ((data + len) - p));\n\n        assert(parser->content_length != 0\n            && parser->content_length != ULLONG_MAX);\n\n        /* The difference between advancing content_length and p is because\n         * the latter will automaticaly advance on the next loop iteration.\n         * Further, if content_length ends up at 0, we want to see the last\n         * byte again for our message complete callback.\n         */\n        MARK(body);\n        parser->content_length -= to_read;\n        p += to_read - 1;\n\n        if (parser->content_length == 0) {\n          UPDATE_STATE(s_message_done);\n\n          /* Mimic CALLBACK_DATA_NOADVANCE() but with one extra byte.\n           *\n           * The alternative to doing this is to wait for the next byte to\n           * trigger the data callback, just as in every other case. The\n           * problem with this is that this makes it difficult for the test\n           * harness to distinguish between complete-on-EOF and\n           * complete-on-length. It's not clear that this distinction is\n           * important for applications, but let's keep it for now.\n           */\n          CALLBACK_DATA_(body, p - body_mark + 1, p - data);\n          REEXECUTE();\n        }\n\n        break;\n      }\n\n      /* read until EOF */\n      case s_body_identity_eof:\n        MARK(body);\n        p = data + len - 1;\n\n        break;\n\n      case s_message_done:\n        UPDATE_STATE(NEW_MESSAGE());\n        CALLBACK_NOTIFY(message_complete);\n        if (parser->upgrade) {\n          /* Exit, the rest of the message is in a different protocol. */\n          RETURN((p - data) + 1);\n        }\n        break;\n\n      case s_chunk_size_start:\n      {\n        assert(nread == 1);\n        assert(parser->flags & F_CHUNKED);\n\n        unhex_val = unhex[(unsigned char)ch];\n        if (UNLIKELY(unhex_val == -1)) {\n          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);\n          goto error;\n        }\n\n        parser->content_length = unhex_val;\n        UPDATE_STATE(s_chunk_size);\n        break;\n      }\n\n      case s_chunk_size:\n      {\n        uint64_t t;\n\n        assert(parser->flags & F_CHUNKED);\n\n        if (ch == CR) {\n          UPDATE_STATE(s_chunk_size_almost_done);\n          break;\n        }\n\n        unhex_val = unhex[(unsigned char)ch];\n\n        if (unhex_val == -1) {\n          if (ch == ';' || ch == ' ') {\n            UPDATE_STATE(s_chunk_parameters);\n            break;\n          }\n\n          SET_ERRNO(HPE_INVALID_CHUNK_SIZE);\n          goto error;\n        }\n\n        t = parser->content_length;\n        t *= 16;\n        t += unhex_val;\n\n        /* Overflow? Test against a conservative limit for simplicity. */\n        if (UNLIKELY((ULLONG_MAX - 16) / 16 < parser->content_length)) {\n          SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);\n          goto error;\n        }\n\n        parser->content_length = t;\n        break;\n      }\n\n      case s_chunk_parameters:\n      {\n        assert(parser->flags & F_CHUNKED);\n        /* just ignore this shit. TODO check for overflow */\n        if (ch == CR) {\n          UPDATE_STATE(s_chunk_size_almost_done);\n          break;\n        }\n        break;\n      }\n\n      case s_chunk_size_almost_done:\n      {\n        assert(parser->flags & F_CHUNKED);\n        STRICT_CHECK(ch != LF);\n\n        parser->nread = 0;\n        nread = 0;\n\n        if (parser->content_length == 0) {\n          parser->flags |= F_TRAILING;\n          UPDATE_STATE(s_header_field_start);\n        } else {\n          UPDATE_STATE(s_chunk_data);\n        }\n        CALLBACK_NOTIFY(chunk_header);\n        break;\n      }\n\n      case s_chunk_data:\n      {\n        uint64_t to_read = MIN(parser->content_length,\n                               (uint64_t) ((data + len) - p));\n\n        assert(parser->flags & F_CHUNKED);\n        assert(parser->content_length != 0\n            && parser->content_length != ULLONG_MAX);\n\n        /* See the explanation in s_body_identity for why the content\n         * length and data pointers are managed this way.\n         */\n        MARK(body);\n        parser->content_length -= to_read;\n        p += to_read - 1;\n\n        if (parser->content_length == 0) {\n          UPDATE_STATE(s_chunk_data_almost_done);\n        }\n\n        break;\n      }\n\n      case s_chunk_data_almost_done:\n        assert(parser->flags & F_CHUNKED);\n        assert(parser->content_length == 0);\n        STRICT_CHECK(ch != CR);\n        UPDATE_STATE(s_chunk_data_done);\n        CALLBACK_DATA(body);\n        break;\n\n      case s_chunk_data_done:\n        assert(parser->flags & F_CHUNKED);\n        STRICT_CHECK(ch != LF);\n        parser->nread = 0;\n        nread = 0;\n        UPDATE_STATE(s_chunk_size_start);\n        CALLBACK_NOTIFY(chunk_complete);\n        break;\n\n      default:\n        assert(0 && \"unhandled state\");\n        SET_ERRNO(HPE_INVALID_INTERNAL_STATE);\n        goto error;\n    }\n  }\n\n  /* Run callbacks for any marks that we have leftover after we ran out of\n   * bytes. There should be at most one of these set, so it's OK to invoke\n   * them in series (unset marks will not result in callbacks).\n   *\n   * We use the NOADVANCE() variety of callbacks here because 'p' has already\n   * overflowed 'data' and this allows us to correct for the off-by-one that\n   * we'd otherwise have (since CALLBACK_DATA() is meant to be run with a 'p'\n   * value that's in-bounds).\n   */\n\n  assert(((header_field_mark ? 1 : 0) +\n          (header_value_mark ? 1 : 0) +\n          (url_mark ? 1 : 0)  +\n          (body_mark ? 1 : 0) +\n          (status_mark ? 1 : 0)) <= 1);\n\n  CALLBACK_DATA_NOADVANCE(header_field);\n  CALLBACK_DATA_NOADVANCE(header_value);\n  CALLBACK_DATA_NOADVANCE(url);\n  CALLBACK_DATA_NOADVANCE(body);\n  CALLBACK_DATA_NOADVANCE(status);\n\n  RETURN(len);\n\nerror:\n  if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {\n    SET_ERRNO(HPE_UNKNOWN);\n  }\n\n  RETURN(p - data);\n}\n\n\n/* Does the parser need to see an EOF to find the end of the message? */\nint\nhttp_message_needs_eof (const http_parser *parser)\n{\n  if (parser->type == HTTP_REQUEST) {\n    return 0;\n  }\n\n  /* See RFC 2616 section 4.4 */\n  if (parser->status_code / 100 == 1 || /* 1xx e.g. Continue */\n      parser->status_code == 204 ||     /* No Content */\n      parser->status_code == 304 ||     /* Not Modified */\n      parser->flags & F_SKIPBODY) {     /* response to a HEAD request */\n    return 0;\n  }\n\n  /* RFC 7230 3.3.3, see `s_headers_almost_done` */\n  if ((parser->uses_transfer_encoding == 1) &&\n      (parser->flags & F_CHUNKED) == 0) {\n    return 1;\n  }\n\n  if ((parser->flags & F_CHUNKED) || parser->content_length != ULLONG_MAX) {\n    return 0;\n  }\n\n  return 1;\n}\n\n\nint\nhttp_should_keep_alive (const http_parser *parser)\n{\n  if (parser->http_major > 0 && parser->http_minor > 0) {\n    /* HTTP/1.1 */\n    if (parser->flags & F_CONNECTION_CLOSE) {\n      return 0;\n    }\n  } else {\n    /* HTTP/1.0 or earlier */\n    if (!(parser->flags & F_CONNECTION_KEEP_ALIVE)) {\n      return 0;\n    }\n  }\n\n  return !http_message_needs_eof(parser);\n}\n\n\nconst char *\nhttp_method_str (enum http_method m)\n{\n  return ELEM_AT(method_strings, m, \"<unknown>\");\n}\n\nconst char *\nhttp_status_str (enum http_status s)\n{\n  switch (s) {\n#define XX(num, name, string) case HTTP_STATUS_##name: return #string;\n    HTTP_STATUS_MAP(XX)\n#undef XX\n    default: return \"<unknown>\";\n  }\n}\n\nvoid\nhttp_parser_init (http_parser *parser, enum http_parser_type t)\n{\n  void *data = parser->data; /* preserve application data */\n  memset(parser, 0, sizeof(*parser));\n  parser->data = data;\n  parser->type = t;\n  parser->state = (t == HTTP_REQUEST ? s_start_req : (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));\n  parser->http_errno = HPE_OK;\n}\n\nvoid\nhttp_parser_settings_init(http_parser_settings *settings)\n{\n  memset(settings, 0, sizeof(*settings));\n}\n\nconst char *\nhttp_errno_name(enum http_errno err) {\n  assert(((size_t) err) < ARRAY_SIZE(http_strerror_tab));\n  return http_strerror_tab[err].name;\n}\n\nconst char *\nhttp_errno_description(enum http_errno err) {\n  assert(((size_t) err) < ARRAY_SIZE(http_strerror_tab));\n  return http_strerror_tab[err].description;\n}\n\nstatic enum http_host_state\nhttp_parse_host_char(enum http_host_state s, const char ch) {\n  switch(s) {\n    case s_http_userinfo:\n    case s_http_userinfo_start:\n      if (ch == '@') {\n        return s_http_host_start;\n      }\n\n      if (IS_USERINFO_CHAR(ch)) {\n        return s_http_userinfo;\n      }\n      break;\n\n    case s_http_host_start:\n      if (ch == '[') {\n        return s_http_host_v6_start;\n      }\n\n      if (IS_HOST_CHAR(ch)) {\n        return s_http_host;\n      }\n\n      break;\n\n    case s_http_host:\n      if (IS_HOST_CHAR(ch)) {\n        return s_http_host;\n      }\n\n    /* fall through */\n    case s_http_host_v6_end:\n      if (ch == ':') {\n        return s_http_host_port_start;\n      }\n\n      break;\n\n    case s_http_host_v6:\n      if (ch == ']') {\n        return s_http_host_v6_end;\n      }\n\n    /* fall through */\n    case s_http_host_v6_start:\n      if (IS_HEX(ch) || ch == ':' || ch == '.') {\n        return s_http_host_v6;\n      }\n\n      if (s == s_http_host_v6 && ch == '%') {\n        return s_http_host_v6_zone_start;\n      }\n      break;\n\n    case s_http_host_v6_zone:\n      if (ch == ']') {\n        return s_http_host_v6_end;\n      }\n\n    /* fall through */\n    case s_http_host_v6_zone_start:\n      /* RFC 6874 Zone ID consists of 1*( unreserved / pct-encoded) */\n      if (IS_ALPHANUM(ch) || ch == '%' || ch == '.' || ch == '-' || ch == '_' ||\n          ch == '~') {\n        return s_http_host_v6_zone;\n      }\n      break;\n\n    case s_http_host_port:\n    case s_http_host_port_start:\n      if (IS_NUM(ch)) {\n        return s_http_host_port;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n  return s_http_host_dead;\n}\n\nstatic int\nhttp_parse_host(const char * buf, struct http_parser_url *u, int found_at) {\n  enum http_host_state s;\n\n  const char *p;\n  size_t buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;\n\n  assert(u->field_set & (1 << UF_HOST));\n\n  u->field_data[UF_HOST].len = 0;\n\n  s = found_at ? s_http_userinfo_start : s_http_host_start;\n\n  for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {\n    enum http_host_state new_s = http_parse_host_char(s, *p);\n\n    if (new_s == s_http_host_dead) {\n      return 1;\n    }\n\n    switch(new_s) {\n      case s_http_host:\n        if (s != s_http_host) {\n          u->field_data[UF_HOST].off = (uint16_t)(p - buf);\n        }\n        u->field_data[UF_HOST].len++;\n        break;\n\n      case s_http_host_v6:\n        if (s != s_http_host_v6) {\n          u->field_data[UF_HOST].off = (uint16_t)(p - buf);\n        }\n        u->field_data[UF_HOST].len++;\n        break;\n\n      case s_http_host_v6_zone_start:\n      case s_http_host_v6_zone:\n        u->field_data[UF_HOST].len++;\n        break;\n\n      case s_http_host_port:\n        if (s != s_http_host_port) {\n          u->field_data[UF_PORT].off = (uint16_t)(p - buf);\n          u->field_data[UF_PORT].len = 0;\n          u->field_set |= (1 << UF_PORT);\n        }\n        u->field_data[UF_PORT].len++;\n        break;\n\n      case s_http_userinfo:\n        if (s != s_http_userinfo) {\n          u->field_data[UF_USERINFO].off = (uint16_t)(p - buf);\n          u->field_data[UF_USERINFO].len = 0;\n          u->field_set |= (1 << UF_USERINFO);\n        }\n        u->field_data[UF_USERINFO].len++;\n        break;\n\n      default:\n        break;\n    }\n    s = new_s;\n  }\n\n  /* Make sure we don't end somewhere unexpected */\n  switch (s) {\n    case s_http_host_start:\n    case s_http_host_v6_start:\n    case s_http_host_v6:\n    case s_http_host_v6_zone_start:\n    case s_http_host_v6_zone:\n    case s_http_host_port_start:\n    case s_http_userinfo:\n    case s_http_userinfo_start:\n      return 1;\n    default:\n      break;\n  }\n\n  return 0;\n}\n\nvoid\nhttp_parser_url_init(struct http_parser_url *u) {\n  memset(u, 0, sizeof(*u));\n}\n\nint\nhttp_parser_parse_url(const char *buf, size_t buflen, int is_connect,\n                      struct http_parser_url *u)\n{\n  enum state s;\n  const char *p;\n  enum http_parser_url_fields uf, old_uf;\n  int found_at = 0;\n\n  if (buflen == 0) {\n    return 1;\n  }\n\n  u->port = u->field_set = 0;\n  s = is_connect ? s_req_server_start : s_req_spaces_before_url;\n  old_uf = UF_MAX;\n\n  for (p = buf; p < buf + buflen; p++) {\n    s = parse_url_char(s, *p);\n\n    /* Figure out the next field that we're operating on */\n    switch (s) {\n      case s_dead:\n        return 1;\n\n      /* Skip delimeters */\n      case s_req_schema_slash:\n      case s_req_schema_slash_slash:\n      case s_req_server_start:\n      case s_req_query_string_start:\n      case s_req_fragment_start:\n        continue;\n\n      case s_req_schema:\n        uf = UF_SCHEMA;\n        break;\n\n      case s_req_server_with_at:\n        found_at = 1;\n\n      /* fall through */\n      case s_req_server:\n        uf = UF_HOST;\n        break;\n\n      case s_req_path:\n        uf = UF_PATH;\n        break;\n\n      case s_req_query_string:\n        uf = UF_QUERY;\n        break;\n\n      case s_req_fragment:\n        uf = UF_FRAGMENT;\n        break;\n\n      default:\n        assert(!\"Unexpected state\");\n        return 1;\n    }\n\n    /* Nothing's changed; soldier on */\n    if (uf == old_uf) {\n      u->field_data[uf].len++;\n      continue;\n    }\n\n    u->field_data[uf].off = (uint16_t)(p - buf);\n    u->field_data[uf].len = 1;\n\n    u->field_set |= (1 << uf);\n    old_uf = uf;\n  }\n\n  /* host must be present if there is a schema */\n  /* parsing http:///toto will fail */\n  if ((u->field_set & (1 << UF_SCHEMA)) &&\n      (u->field_set & (1 << UF_HOST)) == 0) {\n    return 1;\n  }\n\n  if (u->field_set & (1 << UF_HOST)) {\n    if (http_parse_host(buf, u, found_at) != 0) {\n      return 1;\n    }\n  }\n\n  /* CONNECT requests can only contain \"hostname:port\" */\n  if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {\n    return 1;\n  }\n\n  if (u->field_set & (1 << UF_PORT)) {\n    uint16_t off;\n    uint16_t len;\n    const char* p;\n    const char* end;\n    unsigned long v;\n\n    off = u->field_data[UF_PORT].off;\n    len = u->field_data[UF_PORT].len;\n    end = buf + off + len;\n\n    /* NOTE: The characters are already validated and are in the [0-9] range */\n    assert((size_t) (off + len) <= buflen && \"Port number overflow\");\n    v = 0;\n    for (p = buf + off; p < end; p++) {\n      v *= 10;\n      v += *p - '0';\n\n      /* Ports have a max value of 2^16 */\n      if (v > 0xffff) {\n        return 1;\n      }\n    }\n\n    u->port = (uint16_t) v;\n  }\n\n  return 0;\n}\n\nvoid\nhttp_parser_pause(http_parser *parser, int paused) {\n  /* Users should only be pausing/unpausing a parser that is not in an error\n   * state. In non-debug builds, there's not much that we can do about this\n   * other than ignore it.\n   */\n  if (HTTP_PARSER_ERRNO(parser) == HPE_OK ||\n      HTTP_PARSER_ERRNO(parser) == HPE_PAUSED) {\n    uint32_t nread = parser->nread; /* used by the SET_ERRNO macro */\n    SET_ERRNO((paused) ? HPE_PAUSED : HPE_OK);\n  } else {\n    assert(0 && \"Attempting to pause parser in error state\");\n  }\n}\n\nint\nhttp_body_is_final(const struct http_parser *parser) {\n    return parser->state == s_message_done;\n}\n\nunsigned long\nhttp_parser_version(void) {\n  return HTTP_PARSER_VERSION_MAJOR * 0x10000 |\n         HTTP_PARSER_VERSION_MINOR * 0x00100 |\n         HTTP_PARSER_VERSION_PATCH * 0x00001;\n}\n\nvoid\nhttp_parser_set_max_header_size(uint32_t size) {\n  max_header_size = size;\n}\n"
        },
        {
          "name": "http_parser.gyp",
          "type": "blob",
          "size": 2.7880859375,
          "content": "# This file is used with the GYP meta build system.\n# http://code.google.com/p/gyp/\n# To build try this:\n#   svn co http://gyp.googlecode.com/svn/trunk gyp\n#   ./gyp/gyp -f make --depth=`pwd` http_parser.gyp \n#   ./out/Debug/test \n{\n  'target_defaults': {\n    'default_configuration': 'Debug',\n    'configurations': {\n      # TODO: hoist these out and put them somewhere common, because\n      #       RuntimeLibrary MUST MATCH across the entire project\n      'Debug': {\n        'defines': [ 'DEBUG', '_DEBUG' ],\n        'cflags': [ '-Wall', '-Wextra', '-O0', '-g', '-ftrapv' ],\n        'msvs_settings': {\n          'VCCLCompilerTool': {\n            'RuntimeLibrary': 1, # static debug\n          },\n        },\n      },\n      'Release': {\n        'defines': [ 'NDEBUG' ],\n        'cflags': [ '-Wall', '-Wextra', '-O3' ],\n        'msvs_settings': {\n          'VCCLCompilerTool': {\n            'RuntimeLibrary': 0, # static release\n          },\n        },\n      }\n    },\n    'msvs_settings': {\n      'VCCLCompilerTool': {\n      },\n      'VCLibrarianTool': {\n      },\n      'VCLinkerTool': {\n        'GenerateDebugInformation': 'true',\n      },\n    },\n    'conditions': [\n      ['OS == \"win\"', {\n        'defines': [\n          'WIN32'\n        ],\n      }]\n    ],\n  },\n\n  'targets': [\n    {\n      'target_name': 'http_parser',\n      'type': 'static_library',\n      'include_dirs': [ '.' ],\n      'direct_dependent_settings': {\n        'defines': [ 'HTTP_PARSER_STRICT=0' ],\n        'include_dirs': [ '.' ],\n      },\n      'defines': [ 'HTTP_PARSER_STRICT=0' ],\n      'sources': [ './http_parser.c', ],\n      'conditions': [\n        ['OS==\"win\"', {\n          'msvs_settings': {\n            'VCCLCompilerTool': {\n              # Compile as C++. http_parser.c is actually C99, but C++ is\n              # close enough in this case.\n              'CompileAs': 2,\n            },\n          },\n        }]\n      ],\n    },\n\n    {\n      'target_name': 'http_parser_strict',\n      'type': 'static_library',\n      'include_dirs': [ '.' ],\n      'direct_dependent_settings': {\n        'defines': [ 'HTTP_PARSER_STRICT=1' ],\n        'include_dirs': [ '.' ],\n      },\n      'defines': [ 'HTTP_PARSER_STRICT=1' ],\n      'sources': [ './http_parser.c', ],\n      'conditions': [\n        ['OS==\"win\"', {\n          'msvs_settings': {\n            'VCCLCompilerTool': {\n              # Compile as C++. http_parser.c is actually C99, but C++ is\n              # close enough in this case.\n              'CompileAs': 2,\n            },\n          },\n        }]\n      ],\n    },\n\n    {\n      'target_name': 'test-nonstrict',\n      'type': 'executable',\n      'dependencies': [ 'http_parser' ],\n      'sources': [ 'test.c' ]\n    },\n\n    {\n      'target_name': 'test-strict',\n      'type': 'executable',\n      'dependencies': [ 'http_parser_strict' ],\n      'sources': [ 'test.c' ]\n    }\n  ]\n}\n"
        },
        {
          "name": "http_parser.h",
          "type": "blob",
          "size": 19.16796875,
          "content": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#ifndef http_parser_h\n#define http_parser_h\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Also update SONAME in the Makefile whenever you change these. */\n#define HTTP_PARSER_VERSION_MAJOR 2\n#define HTTP_PARSER_VERSION_MINOR 9\n#define HTTP_PARSER_VERSION_PATCH 4\n\n#include <stddef.h>\n#if defined(_WIN32) && !defined(__MINGW32__) && \\\n  (!defined(_MSC_VER) || _MSC_VER<1600) && !defined(__WINE__)\n#include <BaseTsd.h>\ntypedef __int8 int8_t;\ntypedef unsigned __int8 uint8_t;\ntypedef __int16 int16_t;\ntypedef unsigned __int16 uint16_t;\ntypedef __int32 int32_t;\ntypedef unsigned __int32 uint32_t;\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\n#elif (defined(__sun) || defined(__sun__)) && defined(__SunOS_5_9)\n#include <sys/inttypes.h>\n#else\n#include <stdint.h>\n#endif\n\n/* Compile with -DHTTP_PARSER_STRICT=0 to make less checks, but run\n * faster\n */\n#ifndef HTTP_PARSER_STRICT\n# define HTTP_PARSER_STRICT 1\n#endif\n\n/* Maximium header size allowed. If the macro is not defined\n * before including this header then the default is used. To\n * change the maximum header size, define the macro in the build\n * environment (e.g. -DHTTP_MAX_HEADER_SIZE=<value>). To remove\n * the effective limit on the size of the header, define the macro\n * to a very large number (e.g. -DHTTP_MAX_HEADER_SIZE=0x7fffffff)\n */\n#ifndef HTTP_MAX_HEADER_SIZE\n# define HTTP_MAX_HEADER_SIZE (80*1024)\n#endif\n\ntypedef struct http_parser http_parser;\ntypedef struct http_parser_settings http_parser_settings;\n\n\n/* Callbacks should return non-zero to indicate an error. The parser will\n * then halt execution.\n *\n * The one exception is on_headers_complete. In a HTTP_RESPONSE parser\n * returning '1' from on_headers_complete will tell the parser that it\n * should not expect a body. This is used when receiving a response to a\n * HEAD request which may contain 'Content-Length' or 'Transfer-Encoding:\n * chunked' headers that indicate the presence of a body.\n *\n * Returning `2` from on_headers_complete will tell parser that it should not\n * expect neither a body nor any futher responses on this connection. This is\n * useful for handling responses to a CONNECT request which may not contain\n * `Upgrade` or `Connection: upgrade` headers.\n *\n * http_data_cb does not return data chunks. It will be called arbitrarily\n * many times for each string. E.G. you might get 10 callbacks for \"on_url\"\n * each providing just a few characters more data.\n */\ntypedef int (*http_data_cb) (http_parser*, const char *at, size_t length);\ntypedef int (*http_cb) (http_parser*);\n\n\n/* Status Codes */\n#define HTTP_STATUS_MAP(XX)                                                 \\\n  XX(100, CONTINUE,                        Continue)                        \\\n  XX(101, SWITCHING_PROTOCOLS,             Switching Protocols)             \\\n  XX(102, PROCESSING,                      Processing)                      \\\n  XX(200, OK,                              OK)                              \\\n  XX(201, CREATED,                         Created)                         \\\n  XX(202, ACCEPTED,                        Accepted)                        \\\n  XX(203, NON_AUTHORITATIVE_INFORMATION,   Non-Authoritative Information)   \\\n  XX(204, NO_CONTENT,                      No Content)                      \\\n  XX(205, RESET_CONTENT,                   Reset Content)                   \\\n  XX(206, PARTIAL_CONTENT,                 Partial Content)                 \\\n  XX(207, MULTI_STATUS,                    Multi-Status)                    \\\n  XX(208, ALREADY_REPORTED,                Already Reported)                \\\n  XX(226, IM_USED,                         IM Used)                         \\\n  XX(300, MULTIPLE_CHOICES,                Multiple Choices)                \\\n  XX(301, MOVED_PERMANENTLY,               Moved Permanently)               \\\n  XX(302, FOUND,                           Found)                           \\\n  XX(303, SEE_OTHER,                       See Other)                       \\\n  XX(304, NOT_MODIFIED,                    Not Modified)                    \\\n  XX(305, USE_PROXY,                       Use Proxy)                       \\\n  XX(307, TEMPORARY_REDIRECT,              Temporary Redirect)              \\\n  XX(308, PERMANENT_REDIRECT,              Permanent Redirect)              \\\n  XX(400, BAD_REQUEST,                     Bad Request)                     \\\n  XX(401, UNAUTHORIZED,                    Unauthorized)                    \\\n  XX(402, PAYMENT_REQUIRED,                Payment Required)                \\\n  XX(403, FORBIDDEN,                       Forbidden)                       \\\n  XX(404, NOT_FOUND,                       Not Found)                       \\\n  XX(405, METHOD_NOT_ALLOWED,              Method Not Allowed)              \\\n  XX(406, NOT_ACCEPTABLE,                  Not Acceptable)                  \\\n  XX(407, PROXY_AUTHENTICATION_REQUIRED,   Proxy Authentication Required)   \\\n  XX(408, REQUEST_TIMEOUT,                 Request Timeout)                 \\\n  XX(409, CONFLICT,                        Conflict)                        \\\n  XX(410, GONE,                            Gone)                            \\\n  XX(411, LENGTH_REQUIRED,                 Length Required)                 \\\n  XX(412, PRECONDITION_FAILED,             Precondition Failed)             \\\n  XX(413, PAYLOAD_TOO_LARGE,               Payload Too Large)               \\\n  XX(414, URI_TOO_LONG,                    URI Too Long)                    \\\n  XX(415, UNSUPPORTED_MEDIA_TYPE,          Unsupported Media Type)          \\\n  XX(416, RANGE_NOT_SATISFIABLE,           Range Not Satisfiable)           \\\n  XX(417, EXPECTATION_FAILED,              Expectation Failed)              \\\n  XX(421, MISDIRECTED_REQUEST,             Misdirected Request)             \\\n  XX(422, UNPROCESSABLE_ENTITY,            Unprocessable Entity)            \\\n  XX(423, LOCKED,                          Locked)                          \\\n  XX(424, FAILED_DEPENDENCY,               Failed Dependency)               \\\n  XX(426, UPGRADE_REQUIRED,                Upgrade Required)                \\\n  XX(428, PRECONDITION_REQUIRED,           Precondition Required)           \\\n  XX(429, TOO_MANY_REQUESTS,               Too Many Requests)               \\\n  XX(431, REQUEST_HEADER_FIELDS_TOO_LARGE, Request Header Fields Too Large) \\\n  XX(451, UNAVAILABLE_FOR_LEGAL_REASONS,   Unavailable For Legal Reasons)   \\\n  XX(500, INTERNAL_SERVER_ERROR,           Internal Server Error)           \\\n  XX(501, NOT_IMPLEMENTED,                 Not Implemented)                 \\\n  XX(502, BAD_GATEWAY,                     Bad Gateway)                     \\\n  XX(503, SERVICE_UNAVAILABLE,             Service Unavailable)             \\\n  XX(504, GATEWAY_TIMEOUT,                 Gateway Timeout)                 \\\n  XX(505, HTTP_VERSION_NOT_SUPPORTED,      HTTP Version Not Supported)      \\\n  XX(506, VARIANT_ALSO_NEGOTIATES,         Variant Also Negotiates)         \\\n  XX(507, INSUFFICIENT_STORAGE,            Insufficient Storage)            \\\n  XX(508, LOOP_DETECTED,                   Loop Detected)                   \\\n  XX(510, NOT_EXTENDED,                    Not Extended)                    \\\n  XX(511, NETWORK_AUTHENTICATION_REQUIRED, Network Authentication Required) \\\n\nenum http_status\n  {\n#define XX(num, name, string) HTTP_STATUS_##name = num,\n  HTTP_STATUS_MAP(XX)\n#undef XX\n  };\n\n\n/* Request Methods */\n#define HTTP_METHOD_MAP(XX)         \\\n  XX(0,  DELETE,      DELETE)       \\\n  XX(1,  GET,         GET)          \\\n  XX(2,  HEAD,        HEAD)         \\\n  XX(3,  POST,        POST)         \\\n  XX(4,  PUT,         PUT)          \\\n  /* pathological */                \\\n  XX(5,  CONNECT,     CONNECT)      \\\n  XX(6,  OPTIONS,     OPTIONS)      \\\n  XX(7,  TRACE,       TRACE)        \\\n  /* WebDAV */                      \\\n  XX(8,  COPY,        COPY)         \\\n  XX(9,  LOCK,        LOCK)         \\\n  XX(10, MKCOL,       MKCOL)        \\\n  XX(11, MOVE,        MOVE)         \\\n  XX(12, PROPFIND,    PROPFIND)     \\\n  XX(13, PROPPATCH,   PROPPATCH)    \\\n  XX(14, SEARCH,      SEARCH)       \\\n  XX(15, UNLOCK,      UNLOCK)       \\\n  XX(16, BIND,        BIND)         \\\n  XX(17, REBIND,      REBIND)       \\\n  XX(18, UNBIND,      UNBIND)       \\\n  XX(19, ACL,         ACL)          \\\n  /* subversion */                  \\\n  XX(20, REPORT,      REPORT)       \\\n  XX(21, MKACTIVITY,  MKACTIVITY)   \\\n  XX(22, CHECKOUT,    CHECKOUT)     \\\n  XX(23, MERGE,       MERGE)        \\\n  /* upnp */                        \\\n  XX(24, MSEARCH,     M-SEARCH)     \\\n  XX(25, NOTIFY,      NOTIFY)       \\\n  XX(26, SUBSCRIBE,   SUBSCRIBE)    \\\n  XX(27, UNSUBSCRIBE, UNSUBSCRIBE)  \\\n  /* RFC-5789 */                    \\\n  XX(28, PATCH,       PATCH)        \\\n  XX(29, PURGE,       PURGE)        \\\n  /* CalDAV */                      \\\n  XX(30, MKCALENDAR,  MKCALENDAR)   \\\n  /* RFC-2068, section 19.6.1.2 */  \\\n  XX(31, LINK,        LINK)         \\\n  XX(32, UNLINK,      UNLINK)       \\\n  /* icecast */                     \\\n  XX(33, SOURCE,      SOURCE)       \\\n\nenum http_method\n  {\n#define XX(num, name, string) HTTP_##name = num,\n  HTTP_METHOD_MAP(XX)\n#undef XX\n  };\n\n\nenum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };\n\n\n/* Flag values for http_parser.flags field */\nenum flags\n  { F_CHUNKED               = 1 << 0\n  , F_CONNECTION_KEEP_ALIVE = 1 << 1\n  , F_CONNECTION_CLOSE      = 1 << 2\n  , F_CONNECTION_UPGRADE    = 1 << 3\n  , F_TRAILING              = 1 << 4\n  , F_UPGRADE               = 1 << 5\n  , F_SKIPBODY              = 1 << 6\n  , F_CONTENTLENGTH         = 1 << 7\n  };\n\n\n/* Map for errno-related constants\n *\n * The provided argument should be a macro that takes 2 arguments.\n */\n#define HTTP_ERRNO_MAP(XX)                                           \\\n  /* No error */                                                     \\\n  XX(OK, \"success\")                                                  \\\n                                                                     \\\n  /* Callback-related errors */                                      \\\n  XX(CB_message_begin, \"the on_message_begin callback failed\")       \\\n  XX(CB_url, \"the on_url callback failed\")                           \\\n  XX(CB_header_field, \"the on_header_field callback failed\")         \\\n  XX(CB_header_value, \"the on_header_value callback failed\")         \\\n  XX(CB_headers_complete, \"the on_headers_complete callback failed\") \\\n  XX(CB_body, \"the on_body callback failed\")                         \\\n  XX(CB_message_complete, \"the on_message_complete callback failed\") \\\n  XX(CB_status, \"the on_status callback failed\")                     \\\n  XX(CB_chunk_header, \"the on_chunk_header callback failed\")         \\\n  XX(CB_chunk_complete, \"the on_chunk_complete callback failed\")     \\\n                                                                     \\\n  /* Parsing-related errors */                                       \\\n  XX(INVALID_EOF_STATE, \"stream ended at an unexpected time\")        \\\n  XX(HEADER_OVERFLOW,                                                \\\n     \"too many header bytes seen; overflow detected\")                \\\n  XX(CLOSED_CONNECTION,                                              \\\n     \"data received after completed connection: close message\")      \\\n  XX(INVALID_VERSION, \"invalid HTTP version\")                        \\\n  XX(INVALID_STATUS, \"invalid HTTP status code\")                     \\\n  XX(INVALID_METHOD, \"invalid HTTP method\")                          \\\n  XX(INVALID_URL, \"invalid URL\")                                     \\\n  XX(INVALID_HOST, \"invalid host\")                                   \\\n  XX(INVALID_PORT, \"invalid port\")                                   \\\n  XX(INVALID_PATH, \"invalid path\")                                   \\\n  XX(INVALID_QUERY_STRING, \"invalid query string\")                   \\\n  XX(INVALID_FRAGMENT, \"invalid fragment\")                           \\\n  XX(LF_EXPECTED, \"LF character expected\")                           \\\n  XX(INVALID_HEADER_TOKEN, \"invalid character in header\")            \\\n  XX(INVALID_CONTENT_LENGTH,                                         \\\n     \"invalid character in content-length header\")                   \\\n  XX(UNEXPECTED_CONTENT_LENGTH,                                      \\\n     \"unexpected content-length header\")                             \\\n  XX(INVALID_CHUNK_SIZE,                                             \\\n     \"invalid character in chunk size header\")                       \\\n  XX(INVALID_CONSTANT, \"invalid constant string\")                    \\\n  XX(INVALID_INTERNAL_STATE, \"encountered unexpected internal state\")\\\n  XX(STRICT, \"strict mode assertion failed\")                         \\\n  XX(PAUSED, \"parser is paused\")                                     \\\n  XX(UNKNOWN, \"an unknown error occurred\")                           \\\n  XX(INVALID_TRANSFER_ENCODING,                                      \\\n     \"request has invalid transfer-encoding\")                        \\\n\n\n/* Define HPE_* values for each errno value above */\n#define HTTP_ERRNO_GEN(n, s) HPE_##n,\nenum http_errno {\n  HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)\n};\n#undef HTTP_ERRNO_GEN\n\n\n/* Get an http_errno value from an http_parser */\n#define HTTP_PARSER_ERRNO(p)            ((enum http_errno) (p)->http_errno)\n\n\nstruct http_parser {\n  /** PRIVATE **/\n  unsigned int type : 2;         /* enum http_parser_type */\n  unsigned int flags : 8;       /* F_* values from 'flags' enum; semi-public */\n  unsigned int state : 7;        /* enum state from http_parser.c */\n  unsigned int header_state : 7; /* enum header_state from http_parser.c */\n  unsigned int index : 5;        /* index into current matcher */\n  unsigned int uses_transfer_encoding : 1; /* Transfer-Encoding header is present */\n  unsigned int allow_chunked_length : 1; /* Allow headers with both\n                                          * `Content-Length` and\n                                          * `Transfer-Encoding: chunked` set */\n  unsigned int lenient_http_headers : 1;\n\n  uint32_t nread;          /* # bytes read in various scenarios */\n  uint64_t content_length; /* # bytes in body. `(uint64_t) -1` (all bits one)\n                            * if no Content-Length header.\n                            */\n\n  /** READ-ONLY **/\n  unsigned short http_major;\n  unsigned short http_minor;\n  unsigned int status_code : 16; /* responses only */\n  unsigned int method : 8;       /* requests only */\n  unsigned int http_errno : 7;\n\n  /* 1 = Upgrade header was present and the parser has exited because of that.\n   * 0 = No upgrade header present.\n   * Should be checked when http_parser_execute() returns in addition to\n   * error checking.\n   */\n  unsigned int upgrade : 1;\n\n  /** PUBLIC **/\n  void *data; /* A pointer to get hook to the \"connection\" or \"socket\" object */\n};\n\n\nstruct http_parser_settings {\n  http_cb      on_message_begin;\n  http_data_cb on_url;\n  http_data_cb on_status;\n  http_data_cb on_header_field;\n  http_data_cb on_header_value;\n  http_cb      on_headers_complete;\n  http_data_cb on_body;\n  http_cb      on_message_complete;\n  /* When on_chunk_header is called, the current chunk length is stored\n   * in parser->content_length.\n   */\n  http_cb      on_chunk_header;\n  http_cb      on_chunk_complete;\n};\n\n\nenum http_parser_url_fields\n  { UF_SCHEMA           = 0\n  , UF_HOST             = 1\n  , UF_PORT             = 2\n  , UF_PATH             = 3\n  , UF_QUERY            = 4\n  , UF_FRAGMENT         = 5\n  , UF_USERINFO         = 6\n  , UF_MAX              = 7\n  };\n\n\n/* Result structure for http_parser_parse_url().\n *\n * Callers should index into field_data[] with UF_* values iff field_set\n * has the relevant (1 << UF_*) bit set. As a courtesy to clients (and\n * because we probably have padding left over), we convert any port to\n * a uint16_t.\n */\nstruct http_parser_url {\n  uint16_t field_set;           /* Bitmask of (1 << UF_*) values */\n  uint16_t port;                /* Converted UF_PORT string */\n\n  struct {\n    uint16_t off;               /* Offset into buffer in which field starts */\n    uint16_t len;               /* Length of run in buffer */\n  } field_data[UF_MAX];\n};\n\n\n/* Returns the library version. Bits 16-23 contain the major version number,\n * bits 8-15 the minor version number and bits 0-7 the patch level.\n * Usage example:\n *\n *   unsigned long version = http_parser_version();\n *   unsigned major = (version >> 16) & 255;\n *   unsigned minor = (version >> 8) & 255;\n *   unsigned patch = version & 255;\n *   printf(\"http_parser v%u.%u.%u\\n\", major, minor, patch);\n */\nunsigned long http_parser_version(void);\n\nvoid http_parser_init(http_parser *parser, enum http_parser_type type);\n\n\n/* Initialize http_parser_settings members to 0\n */\nvoid http_parser_settings_init(http_parser_settings *settings);\n\n\n/* Executes the parser. Returns number of parsed bytes. Sets\n * `parser->http_errno` on error. */\nsize_t http_parser_execute(http_parser *parser,\n                           const http_parser_settings *settings,\n                           const char *data,\n                           size_t len);\n\n\n/* If http_should_keep_alive() in the on_headers_complete or\n * on_message_complete callback returns 0, then this should be\n * the last message on the connection.\n * If you are the server, respond with the \"Connection: close\" header.\n * If you are the client, close the connection.\n */\nint http_should_keep_alive(const http_parser *parser);\n\n/* Returns a string version of the HTTP method. */\nconst char *http_method_str(enum http_method m);\n\n/* Returns a string version of the HTTP status code. */\nconst char *http_status_str(enum http_status s);\n\n/* Return a string name of the given error */\nconst char *http_errno_name(enum http_errno err);\n\n/* Return a string description of the given error */\nconst char *http_errno_description(enum http_errno err);\n\n/* Initialize all http_parser_url members to 0 */\nvoid http_parser_url_init(struct http_parser_url *u);\n\n/* Parse a URL; return nonzero on failure */\nint http_parser_parse_url(const char *buf, size_t buflen,\n                          int is_connect,\n                          struct http_parser_url *u);\n\n/* Pause or un-pause the parser; a nonzero value pauses */\nvoid http_parser_pause(http_parser *parser, int paused);\n\n/* Checks if this is the final chunk of the body. */\nint http_body_is_final(const http_parser *parser);\n\n/* Change the maximum header size provided at compile time. */\nvoid http_parser_set_max_header_size(uint32_t size);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n"
        },
        {
          "name": "test.c",
          "type": "blob",
          "size": 123.65234375,
          "content": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#include \"http_parser.h\"\n#include <stdlib.h>\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h> /* rand */\n#include <string.h>\n#include <stdarg.h>\n\n#if defined(__APPLE__)\n# undef strlncpy\n#endif  /* defined(__APPLE__) */\n\n#undef TRUE\n#define TRUE 1\n#undef FALSE\n#define FALSE 0\n\n#define MAX_HEADERS 13\n#define MAX_ELEMENT_SIZE 2048\n#define MAX_CHUNKS 16\n\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*x))\n\nstatic http_parser parser;\n\nstruct message {\n  const char *name; // for debugging purposes\n  const char *raw;\n  enum http_parser_type type;\n  enum http_method method;\n  int status_code;\n  char response_status[MAX_ELEMENT_SIZE];\n  char request_path[MAX_ELEMENT_SIZE];\n  char request_url[MAX_ELEMENT_SIZE];\n  char fragment[MAX_ELEMENT_SIZE];\n  char query_string[MAX_ELEMENT_SIZE];\n  char body[MAX_ELEMENT_SIZE];\n  size_t body_size;\n  const char *host;\n  const char *userinfo;\n  uint16_t port;\n  int num_headers;\n  enum { NONE=0, FIELD, VALUE } last_header_element;\n  char headers [MAX_HEADERS][2][MAX_ELEMENT_SIZE];\n  int should_keep_alive;\n\n  int num_chunks;\n  int num_chunks_complete;\n  int chunk_lengths[MAX_CHUNKS];\n\n  const char *upgrade; // upgraded body\n\n  unsigned short http_major;\n  unsigned short http_minor;\n  uint64_t content_length;\n\n  int message_begin_cb_called;\n  int headers_complete_cb_called;\n  int message_complete_cb_called;\n  int status_cb_called;\n  int message_complete_on_eof;\n  int body_is_final;\n  int allow_chunked_length;\n};\n\nstatic int currently_parsing_eof;\n\nstatic struct message messages[5];\nstatic int num_messages;\nstatic http_parser_settings *current_pause_parser;\n\n/* * R E Q U E S T S * */\nconst struct message requests[] =\n#define CURL_GET 0\n{ {.name= \"curl get\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /test HTTP/1.1\\r\\n\"\n         \"User-Agent: curl/7.18.0 (i486-pc-linux-gnu) libcurl/7.18.0 OpenSSL/0.9.8g zlib/1.2.3.3 libidn/1.1\\r\\n\"\n         \"Host: 0.0.0.0=5000\\r\\n\"\n         \"Accept: */*\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/test\"\n  ,.request_url= \"/test\"\n  ,.content_length= -1\n  ,.num_headers= 3\n  ,.headers=\n    { { \"User-Agent\", \"curl/7.18.0 (i486-pc-linux-gnu) libcurl/7.18.0 OpenSSL/0.9.8g zlib/1.2.3.3 libidn/1.1\" }\n    , { \"Host\", \"0.0.0.0=5000\" }\n    , { \"Accept\", \"*/*\" }\n    }\n  ,.body= \"\"\n  }\n\n#define FIREFOX_GET 1\n, {.name= \"firefox get\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /favicon.ico HTTP/1.1\\r\\n\"\n         \"Host: 0.0.0.0=5000\\r\\n\"\n         \"User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9) Gecko/2008061015 Firefox/3.0\\r\\n\"\n         \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n\"\n         \"Accept-Language: en-us,en;q=0.5\\r\\n\"\n         \"Accept-Encoding: gzip,deflate\\r\\n\"\n         \"Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\\r\\n\"\n         \"Keep-Alive: 300\\r\\n\"\n         \"Connection: keep-alive\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/favicon.ico\"\n  ,.request_url= \"/favicon.ico\"\n  ,.content_length= -1\n  ,.num_headers= 8\n  ,.headers=\n    { { \"Host\", \"0.0.0.0=5000\" }\n    , { \"User-Agent\", \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9) Gecko/2008061015 Firefox/3.0\" }\n    , { \"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\" }\n    , { \"Accept-Language\", \"en-us,en;q=0.5\" }\n    , { \"Accept-Encoding\", \"gzip,deflate\" }\n    , { \"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.7\" }\n    , { \"Keep-Alive\", \"300\" }\n    , { \"Connection\", \"keep-alive\" }\n    }\n  ,.body= \"\"\n  }\n\n#define DUMBLUCK 2\n, {.name= \"dumbluck\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /dumbluck HTTP/1.1\\r\\n\"\n         \"aaaaaaaaaaaaa:++++++++++\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/dumbluck\"\n  ,.request_url= \"/dumbluck\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"aaaaaaaaaaaaa\",  \"++++++++++\" }\n    }\n  ,.body= \"\"\n  }\n\n#define FRAGMENT_IN_URI 3\n, {.name= \"fragment in url\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /forums/1/topics/2375?page=1#posts-17408 HTTP/1.1\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"page=1\"\n  ,.fragment= \"posts-17408\"\n  ,.request_path= \"/forums/1/topics/2375\"\n  /* XXX request url does include fragment? */\n  ,.request_url= \"/forums/1/topics/2375?page=1#posts-17408\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.body= \"\"\n  }\n\n#define GET_NO_HEADERS_NO_BODY 4\n, {.name= \"get no headers no body\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /get_no_headers_no_body/world HTTP/1.1\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE /* would need Connection: close */\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/get_no_headers_no_body/world\"\n  ,.request_url= \"/get_no_headers_no_body/world\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.body= \"\"\n  }\n\n#define GET_ONE_HEADER_NO_BODY 5\n, {.name= \"get one header no body\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /get_one_header_no_body HTTP/1.1\\r\\n\"\n         \"Accept: */*\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE /* would need Connection: close */\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/get_one_header_no_body\"\n  ,.request_url= \"/get_one_header_no_body\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Accept\" , \"*/*\" }\n    }\n  ,.body= \"\"\n  }\n\n#define GET_FUNKY_CONTENT_LENGTH 6\n, {.name= \"get funky content length body hello\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /get_funky_content_length_body_hello HTTP/1.0\\r\\n\"\n         \"conTENT-Length: 5\\r\\n\"\n         \"\\r\\n\"\n         \"HELLO\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 0\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/get_funky_content_length_body_hello\"\n  ,.request_url= \"/get_funky_content_length_body_hello\"\n  ,.content_length= 5\n  ,.num_headers= 1\n  ,.headers=\n    { { \"conTENT-Length\" , \"5\" }\n    }\n  ,.body= \"HELLO\"\n  }\n\n#define POST_IDENTITY_BODY_WORLD 7\n, {.name= \"post identity body world\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"POST /post_identity_body_world?q=search#hey HTTP/1.1\\r\\n\"\n         \"Accept: */*\\r\\n\"\n         \"Content-Length: 5\\r\\n\"\n         \"\\r\\n\"\n         \"World\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.query_string= \"q=search\"\n  ,.fragment= \"hey\"\n  ,.request_path= \"/post_identity_body_world\"\n  ,.request_url= \"/post_identity_body_world?q=search#hey\"\n  ,.content_length= 5\n  ,.num_headers= 2\n  ,.headers=\n    { { \"Accept\", \"*/*\" }\n    , { \"Content-Length\", \"5\" }\n    }\n  ,.body= \"World\"\n  }\n\n#define POST_CHUNKED_ALL_YOUR_BASE 8\n, {.name= \"post - chunked body: all your base are belong to us\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"POST /post_chunked_all_your_base HTTP/1.1\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"1e\\r\\nall your base are belong to us\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/post_chunked_all_your_base\"\n  ,.request_url= \"/post_chunked_all_your_base\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Transfer-Encoding\" , \"chunked\" }\n    }\n  ,.body= \"all your base are belong to us\"\n  ,.num_chunks_complete= 2\n  ,.chunk_lengths= { 0x1e }\n  }\n\n#define TWO_CHUNKS_MULT_ZERO_END 9\n, {.name= \"two chunks ; triple zero ending\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"POST /two_chunks_mult_zero_end HTTP/1.1\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"5\\r\\nhello\\r\\n\"\n         \"6\\r\\n world\\r\\n\"\n         \"000\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/two_chunks_mult_zero_end\"\n  ,.request_url= \"/two_chunks_mult_zero_end\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Transfer-Encoding\", \"chunked\" }\n    }\n  ,.body= \"hello world\"\n  ,.num_chunks_complete= 3\n  ,.chunk_lengths= { 5, 6 }\n  }\n\n#define CHUNKED_W_TRAILING_HEADERS 10\n, {.name= \"chunked with trailing headers. blech.\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"POST /chunked_w_trailing_headers HTTP/1.1\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"5\\r\\nhello\\r\\n\"\n         \"6\\r\\n world\\r\\n\"\n         \"0\\r\\n\"\n         \"Vary: *\\r\\n\"\n         \"Content-Type: text/plain\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/chunked_w_trailing_headers\"\n  ,.request_url= \"/chunked_w_trailing_headers\"\n  ,.content_length= -1\n  ,.num_headers= 3\n  ,.headers=\n    { { \"Transfer-Encoding\",  \"chunked\" }\n    , { \"Vary\", \"*\" }\n    , { \"Content-Type\", \"text/plain\" }\n    }\n  ,.body= \"hello world\"\n  ,.num_chunks_complete= 3\n  ,.chunk_lengths= { 5, 6 }\n  }\n\n#define CHUNKED_W_NONSENSE_AFTER_LENGTH 11\n, {.name= \"with nonsense after the length\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"POST /chunked_w_nonsense_after_length HTTP/1.1\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"5; ilovew3;whattheluck=aretheseparametersfor\\r\\nhello\\r\\n\"\n         \"6; blahblah; blah\\r\\n world\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/chunked_w_nonsense_after_length\"\n  ,.request_url= \"/chunked_w_nonsense_after_length\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Transfer-Encoding\", \"chunked\" }\n    }\n  ,.body= \"hello world\"\n  ,.num_chunks_complete= 3\n  ,.chunk_lengths= { 5, 6 }\n  }\n\n#define WITH_QUOTES 12\n, {.name= \"with quotes\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /with_\\\"stupid\\\"_quotes?foo=\\\"bar\\\" HTTP/1.1\\r\\n\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"foo=\\\"bar\\\"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/with_\\\"stupid\\\"_quotes\"\n  ,.request_url= \"/with_\\\"stupid\\\"_quotes?foo=\\\"bar\\\"\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= { }\n  ,.body= \"\"\n  }\n\n#define APACHEBENCH_GET 13\n/* The server receiving this request SHOULD NOT wait for EOF\n * to know that content-length == 0.\n * How to represent this in a unit test? message_complete_on_eof\n * Compare with NO_CONTENT_LENGTH_RESPONSE.\n */\n, {.name = \"apachebench get\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /test HTTP/1.0\\r\\n\"\n         \"Host: 0.0.0.0:5000\\r\\n\"\n         \"User-Agent: ApacheBench/2.3\\r\\n\"\n         \"Accept: */*\\r\\n\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 0\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/test\"\n  ,.request_url= \"/test\"\n  ,.content_length= -1\n  ,.num_headers= 3\n  ,.headers= { { \"Host\", \"0.0.0.0:5000\" }\n             , { \"User-Agent\", \"ApacheBench/2.3\" }\n             , { \"Accept\", \"*/*\" }\n             }\n  ,.body= \"\"\n  }\n\n#define QUERY_URL_WITH_QUESTION_MARK_GET 14\n/* Some clients include '?' characters in query strings.\n */\n, {.name = \"query url with question mark\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /test.cgi?foo=bar?baz HTTP/1.1\\r\\n\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"foo=bar?baz\"\n  ,.fragment= \"\"\n  ,.request_path= \"/test.cgi\"\n  ,.request_url= \"/test.cgi?foo=bar?baz\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= {}\n  ,.body= \"\"\n  }\n\n#define PREFIX_NEWLINE_GET 15\n/* Some clients, especially after a POST in a keep-alive connection,\n * will send an extra CRLF before the next request\n */\n, {.name = \"newline prefix get\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"\\r\\nGET /test HTTP/1.1\\r\\n\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/test\"\n  ,.request_url= \"/test\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= { }\n  ,.body= \"\"\n  }\n\n#define UPGRADE_REQUEST 16\n, {.name = \"upgrade request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /demo HTTP/1.1\\r\\n\"\n         \"Host: example.com\\r\\n\"\n         \"Connection: Upgrade\\r\\n\"\n         \"Sec-WebSocket-Key2: 12998 5 Y3 1  .P00\\r\\n\"\n         \"Sec-WebSocket-Protocol: sample\\r\\n\"\n         \"Upgrade: WebSocket\\r\\n\"\n         \"Sec-WebSocket-Key1: 4 @1  46546xW%0l 1 5\\r\\n\"\n         \"Origin: http://example.com\\r\\n\"\n         \"\\r\\n\"\n         \"Hot diggity dogg\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/demo\"\n  ,.request_url= \"/demo\"\n  ,.content_length= -1\n  ,.num_headers= 7\n  ,.upgrade=\"Hot diggity dogg\"\n  ,.headers= { { \"Host\", \"example.com\" }\n             , { \"Connection\", \"Upgrade\" }\n             , { \"Sec-WebSocket-Key2\", \"12998 5 Y3 1  .P00\" }\n             , { \"Sec-WebSocket-Protocol\", \"sample\" }\n             , { \"Upgrade\", \"WebSocket\" }\n             , { \"Sec-WebSocket-Key1\", \"4 @1  46546xW%0l 1 5\" }\n             , { \"Origin\", \"http://example.com\" }\n             }\n  ,.body= \"\"\n  }\n\n#define CONNECT_REQUEST 17\n, {.name = \"connect request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"CONNECT 0-home0.netscape.com:443 HTTP/1.0\\r\\n\"\n         \"User-agent: Mozilla/1.1N\\r\\n\"\n         \"Proxy-authorization: basic aGVsbG86d29ybGQ=\\r\\n\"\n         \"\\r\\n\"\n         \"some data\\r\\n\"\n         \"and yet even more data\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 0\n  ,.method= HTTP_CONNECT\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"\"\n  ,.request_url= \"0-home0.netscape.com:443\"\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.upgrade=\"some data\\r\\nand yet even more data\"\n  ,.headers= { { \"User-agent\", \"Mozilla/1.1N\" }\n             , { \"Proxy-authorization\", \"basic aGVsbG86d29ybGQ=\" }\n             }\n  ,.body= \"\"\n  }\n\n#define REPORT_REQ 18\n, {.name= \"report request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"REPORT /test HTTP/1.1\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_REPORT\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/test\"\n  ,.request_url= \"/test\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= {}\n  ,.body= \"\"\n  }\n\n#define NO_HTTP_VERSION 19\n, {.name= \"request with no http version\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 0\n  ,.http_minor= 9\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/\"\n  ,.request_url= \"/\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= {}\n  ,.body= \"\"\n  }\n\n#define MSEARCH_REQ 20\n, {.name= \"m-search request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"M-SEARCH * HTTP/1.1\\r\\n\"\n         \"HOST: 239.255.255.250:1900\\r\\n\"\n         \"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n         \"ST: \\\"ssdp:all\\\"\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_MSEARCH\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"*\"\n  ,.request_url= \"*\"\n  ,.content_length= -1\n  ,.num_headers= 3\n  ,.headers= { { \"HOST\", \"239.255.255.250:1900\" }\n             , { \"MAN\", \"\\\"ssdp:discover\\\"\" }\n             , { \"ST\", \"\\\"ssdp:all\\\"\" }\n             }\n  ,.body= \"\"\n  }\n\n#define LINE_FOLDING_IN_HEADER 21\n, {.name= \"line folding in header value\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET / HTTP/1.1\\r\\n\"\n         \"Line1:   abc\\r\\n\"\n         \"\\tdef\\r\\n\"\n         \" ghi\\r\\n\"\n         \"\\t\\tjkl\\r\\n\"\n         \"  mno \\r\\n\"\n         \"\\t \\tqrs\\r\\n\"\n         \"Line2: \\t line2\\t\\r\\n\"\n         \"Line3:\\r\\n\"\n         \" line3\\r\\n\"\n         \"Line4: \\r\\n\"\n         \" \\r\\n\"\n         \"Connection:\\r\\n\"\n         \" close\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/\"\n  ,.request_url= \"/\"\n  ,.content_length= -1\n  ,.num_headers= 5\n  ,.headers= { { \"Line1\", \"abc\\tdef ghi\\t\\tjkl  mno \\t \\tqrs\" }\n             , { \"Line2\", \"line2\\t\" }\n             , { \"Line3\", \"line3\" }\n             , { \"Line4\", \"\" }\n             , { \"Connection\", \"close\" },\n             }\n  ,.body= \"\"\n  }\n\n\n#define QUERY_TERMINATED_HOST 22\n, {.name= \"host terminated by a query string\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET http://hypnotoad.org?hail=all HTTP/1.1\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"hail=all\"\n  ,.fragment= \"\"\n  ,.request_path= \"\"\n  ,.request_url= \"http://hypnotoad.org?hail=all\"\n  ,.host= \"hypnotoad.org\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= { }\n  ,.body= \"\"\n  }\n\n#define QUERY_TERMINATED_HOSTPORT 23\n, {.name= \"host:port terminated by a query string\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET http://hypnotoad.org:1234?hail=all HTTP/1.1\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"hail=all\"\n  ,.fragment= \"\"\n  ,.request_path= \"\"\n  ,.request_url= \"http://hypnotoad.org:1234?hail=all\"\n  ,.host= \"hypnotoad.org\"\n  ,.port= 1234\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= { }\n  ,.body= \"\"\n  }\n\n#define SPACE_TERMINATED_HOSTPORT 24\n, {.name= \"host:port terminated by a space\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET http://hypnotoad.org:1234 HTTP/1.1\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"\"\n  ,.request_url= \"http://hypnotoad.org:1234\"\n  ,.host= \"hypnotoad.org\"\n  ,.port= 1234\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= { }\n  ,.body= \"\"\n  }\n\n#define PATCH_REQ 25\n, {.name = \"PATCH request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"PATCH /file.txt HTTP/1.1\\r\\n\"\n         \"Host: www.example.com\\r\\n\"\n         \"Content-Type: application/example\\r\\n\"\n         \"If-Match: \\\"e0023aa4e\\\"\\r\\n\"\n         \"Content-Length: 10\\r\\n\"\n         \"\\r\\n\"\n         \"cccccccccc\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_PATCH\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/file.txt\"\n  ,.request_url= \"/file.txt\"\n  ,.content_length= 10\n  ,.num_headers= 4\n  ,.headers= { { \"Host\", \"www.example.com\" }\n             , { \"Content-Type\", \"application/example\" }\n             , { \"If-Match\", \"\\\"e0023aa4e\\\"\" }\n             , { \"Content-Length\", \"10\" }\n             }\n  ,.body= \"cccccccccc\"\n  }\n\n#define CONNECT_CAPS_REQUEST 26\n, {.name = \"connect caps request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"CONNECT HOME0.NETSCAPE.COM:443 HTTP/1.0\\r\\n\"\n         \"User-agent: Mozilla/1.1N\\r\\n\"\n         \"Proxy-authorization: basic aGVsbG86d29ybGQ=\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 0\n  ,.method= HTTP_CONNECT\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"\"\n  ,.request_url= \"HOME0.NETSCAPE.COM:443\"\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.upgrade=\"\"\n  ,.headers= { { \"User-agent\", \"Mozilla/1.1N\" }\n             , { \"Proxy-authorization\", \"basic aGVsbG86d29ybGQ=\" }\n             }\n  ,.body= \"\"\n  }\n\n#if !HTTP_PARSER_STRICT\n#define UTF8_PATH_REQ 27\n, {.name= \"utf-8 path request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /δ¶/δt/pope?q=1#narf HTTP/1.1\\r\\n\"\n         \"Host: github.com\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"q=1\"\n  ,.fragment= \"narf\"\n  ,.request_path= \"/δ¶/δt/pope\"\n  ,.request_url= \"/δ¶/δt/pope?q=1#narf\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers= { {\"Host\", \"github.com\" }\n             }\n  ,.body= \"\"\n  }\n\n#define HOSTNAME_UNDERSCORE 28\n, {.name = \"hostname underscore\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"CONNECT home_0.netscape.com:443 HTTP/1.0\\r\\n\"\n         \"User-agent: Mozilla/1.1N\\r\\n\"\n         \"Proxy-authorization: basic aGVsbG86d29ybGQ=\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 0\n  ,.method= HTTP_CONNECT\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"\"\n  ,.request_url= \"home_0.netscape.com:443\"\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.upgrade=\"\"\n  ,.headers= { { \"User-agent\", \"Mozilla/1.1N\" }\n             , { \"Proxy-authorization\", \"basic aGVsbG86d29ybGQ=\" }\n             }\n  ,.body= \"\"\n  }\n#endif  /* !HTTP_PARSER_STRICT */\n\n/* see https://github.com/ry/http-parser/issues/47 */\n#define EAT_TRAILING_CRLF_NO_CONNECTION_CLOSE 29\n, {.name = \"eat CRLF between requests, no \\\"Connection: close\\\" header\"\n  ,.raw= \"POST / HTTP/1.1\\r\\n\"\n         \"Host: www.example.com\\r\\n\"\n         \"Content-Type: application/x-www-form-urlencoded\\r\\n\"\n         \"Content-Length: 4\\r\\n\"\n         \"\\r\\n\"\n         \"q=42\\r\\n\" /* note the trailing CRLF */\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/\"\n  ,.request_url= \"/\"\n  ,.content_length= 4\n  ,.num_headers= 3\n  ,.upgrade= 0\n  ,.headers= { { \"Host\", \"www.example.com\" }\n             , { \"Content-Type\", \"application/x-www-form-urlencoded\" }\n             , { \"Content-Length\", \"4\" }\n             }\n  ,.body= \"q=42\"\n  }\n\n/* see https://github.com/ry/http-parser/issues/47 */\n#define EAT_TRAILING_CRLF_WITH_CONNECTION_CLOSE 30\n, {.name = \"eat CRLF between requests even if \\\"Connection: close\\\" is set\"\n  ,.raw= \"POST / HTTP/1.1\\r\\n\"\n         \"Host: www.example.com\\r\\n\"\n         \"Content-Type: application/x-www-form-urlencoded\\r\\n\"\n         \"Content-Length: 4\\r\\n\"\n         \"Connection: close\\r\\n\"\n         \"\\r\\n\"\n         \"q=42\\r\\n\" /* note the trailing CRLF */\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE /* input buffer isn't empty when on_message_complete is called */\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/\"\n  ,.request_url= \"/\"\n  ,.content_length= 4\n  ,.num_headers= 4\n  ,.upgrade= 0\n  ,.headers= { { \"Host\", \"www.example.com\" }\n             , { \"Content-Type\", \"application/x-www-form-urlencoded\" }\n             , { \"Content-Length\", \"4\" }\n             , { \"Connection\", \"close\" }\n             }\n  ,.body= \"q=42\"\n  }\n\n#define PURGE_REQ 31\n, {.name = \"PURGE request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"PURGE /file.txt HTTP/1.1\\r\\n\"\n         \"Host: www.example.com\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_PURGE\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/file.txt\"\n  ,.request_url= \"/file.txt\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers= { { \"Host\", \"www.example.com\" } }\n  ,.body= \"\"\n  }\n\n#define SEARCH_REQ 32\n, {.name = \"SEARCH request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"SEARCH / HTTP/1.1\\r\\n\"\n         \"Host: www.example.com\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_SEARCH\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/\"\n  ,.request_url= \"/\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers= { { \"Host\", \"www.example.com\" } }\n  ,.body= \"\"\n  }\n\n#define PROXY_WITH_BASIC_AUTH 33\n, {.name= \"host:port and basic_auth\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET http://a%12:b!&*$@hypnotoad.org:1234/toto HTTP/1.1\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.fragment= \"\"\n  ,.request_path= \"/toto\"\n  ,.request_url= \"http://a%12:b!&*$@hypnotoad.org:1234/toto\"\n  ,.host= \"hypnotoad.org\"\n  ,.userinfo= \"a%12:b!&*$\"\n  ,.port= 1234\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= { }\n  ,.body= \"\"\n  }\n\n#define LINE_FOLDING_IN_HEADER_WITH_LF 34\n, {.name= \"line folding in header value\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET / HTTP/1.1\\n\"\n         \"Line1:   abc\\n\"\n         \"\\tdef\\n\"\n         \" ghi\\n\"\n         \"\\t\\tjkl\\n\"\n         \"  mno \\n\"\n         \"\\t \\tqrs\\n\"\n         \"Line2: \\t line2\\t\\n\"\n         \"Line3:\\n\"\n         \" line3\\n\"\n         \"Line4: \\n\"\n         \" \\n\"\n         \"Connection:\\n\"\n         \" close\\n\"\n         \"\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/\"\n  ,.request_url= \"/\"\n  ,.content_length= -1\n  ,.num_headers= 5\n  ,.headers= { { \"Line1\", \"abc\\tdef ghi\\t\\tjkl  mno \\t \\tqrs\" }\n             , { \"Line2\", \"line2\\t\" }\n             , { \"Line3\", \"line3\" }\n             , { \"Line4\", \"\" }\n             , { \"Connection\", \"close\" },\n             }\n  ,.body= \"\"\n  }\n\n#define CONNECTION_MULTI 35\n, {.name = \"multiple connection header values with folding\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /demo HTTP/1.1\\r\\n\"\n         \"Host: example.com\\r\\n\"\n         \"Connection: Something,\\r\\n\"\n         \" Upgrade, ,Keep-Alive\\r\\n\"\n         \"Sec-WebSocket-Key2: 12998 5 Y3 1  .P00\\r\\n\"\n         \"Sec-WebSocket-Protocol: sample\\r\\n\"\n         \"Upgrade: WebSocket\\r\\n\"\n         \"Sec-WebSocket-Key1: 4 @1  46546xW%0l 1 5\\r\\n\"\n         \"Origin: http://example.com\\r\\n\"\n         \"\\r\\n\"\n         \"Hot diggity dogg\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/demo\"\n  ,.request_url= \"/demo\"\n  ,.content_length= -1\n  ,.num_headers= 7\n  ,.upgrade=\"Hot diggity dogg\"\n  ,.headers= { { \"Host\", \"example.com\" }\n             , { \"Connection\", \"Something, Upgrade, ,Keep-Alive\" }\n             , { \"Sec-WebSocket-Key2\", \"12998 5 Y3 1  .P00\" }\n             , { \"Sec-WebSocket-Protocol\", \"sample\" }\n             , { \"Upgrade\", \"WebSocket\" }\n             , { \"Sec-WebSocket-Key1\", \"4 @1  46546xW%0l 1 5\" }\n             , { \"Origin\", \"http://example.com\" }\n             }\n  ,.body= \"\"\n  }\n\n#define CONNECTION_MULTI_LWS 36\n, {.name = \"multiple connection header values with folding and lws\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /demo HTTP/1.1\\r\\n\"\n         \"Connection: keep-alive, upgrade\\r\\n\"\n         \"Upgrade: WebSocket\\r\\n\"\n         \"\\r\\n\"\n         \"Hot diggity dogg\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/demo\"\n  ,.request_url= \"/demo\"\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.upgrade=\"Hot diggity dogg\"\n  ,.headers= { { \"Connection\", \"keep-alive, upgrade\" }\n             , { \"Upgrade\", \"WebSocket\" }\n             }\n  ,.body= \"\"\n  }\n\n#define CONNECTION_MULTI_LWS_CRLF 37\n, {.name = \"multiple connection header values with folding and lws\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"GET /demo HTTP/1.1\\r\\n\"\n         \"Connection: keep-alive, \\r\\n upgrade\\r\\n\"\n         \"Upgrade: WebSocket\\r\\n\"\n         \"\\r\\n\"\n         \"Hot diggity dogg\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_GET\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/demo\"\n  ,.request_url= \"/demo\"\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.upgrade=\"Hot diggity dogg\"\n  ,.headers= { { \"Connection\", \"keep-alive,  upgrade\" }\n             , { \"Upgrade\", \"WebSocket\" }\n             }\n  ,.body= \"\"\n  }\n\n#define UPGRADE_POST_REQUEST 38\n, {.name = \"upgrade post request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"POST /demo HTTP/1.1\\r\\n\"\n         \"Host: example.com\\r\\n\"\n         \"Connection: Upgrade\\r\\n\"\n         \"Upgrade: HTTP/2.0\\r\\n\"\n         \"Content-Length: 15\\r\\n\"\n         \"\\r\\n\"\n         \"sweet post body\"\n         \"Hot diggity dogg\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.request_path= \"/demo\"\n  ,.request_url= \"/demo\"\n  ,.content_length= 15\n  ,.num_headers= 4\n  ,.upgrade=\"Hot diggity dogg\"\n  ,.headers= { { \"Host\", \"example.com\" }\n             , { \"Connection\", \"Upgrade\" }\n             , { \"Upgrade\", \"HTTP/2.0\" }\n             , { \"Content-Length\", \"15\" }\n             }\n  ,.body= \"sweet post body\"\n  }\n\n#define CONNECT_WITH_BODY_REQUEST 39\n, {.name = \"connect with body request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"CONNECT foo.bar.com:443 HTTP/1.0\\r\\n\"\n         \"User-agent: Mozilla/1.1N\\r\\n\"\n         \"Proxy-authorization: basic aGVsbG86d29ybGQ=\\r\\n\"\n         \"Content-Length: 10\\r\\n\"\n         \"\\r\\n\"\n         \"blarfcicle\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 0\n  ,.method= HTTP_CONNECT\n  ,.request_url= \"foo.bar.com:443\"\n  ,.content_length= 10\n  ,.num_headers= 3\n  ,.upgrade=\"blarfcicle\"\n  ,.headers= { { \"User-agent\", \"Mozilla/1.1N\" }\n             , { \"Proxy-authorization\", \"basic aGVsbG86d29ybGQ=\" }\n             , { \"Content-Length\", \"10\" }\n             }\n  ,.body= \"\"\n  }\n\n/* Examples from the Internet draft for LINK/UNLINK methods:\n * https://tools.ietf.org/id/draft-snell-link-method-01.html#rfc.section.5\n */\n\n#define LINK_REQUEST 40\n, {.name = \"link request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"LINK /images/my_dog.jpg HTTP/1.1\\r\\n\"\n         \"Host: example.com\\r\\n\"\n         \"Link: <http://example.com/profiles/joe>; rel=\\\"tag\\\"\\r\\n\"\n         \"Link: <http://example.com/profiles/sally>; rel=\\\"tag\\\"\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_LINK\n  ,.request_path= \"/images/my_dog.jpg\"\n  ,.request_url= \"/images/my_dog.jpg\"\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.content_length= -1\n  ,.num_headers= 3\n  ,.headers= { { \"Host\", \"example.com\" }\n             , { \"Link\", \"<http://example.com/profiles/joe>; rel=\\\"tag\\\"\" }\n\t     , { \"Link\", \"<http://example.com/profiles/sally>; rel=\\\"tag\\\"\" }\n             }\n  ,.body= \"\"\n  }\n\n#define UNLINK_REQUEST 41\n, {.name = \"unlink request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"UNLINK /images/my_dog.jpg HTTP/1.1\\r\\n\"\n         \"Host: example.com\\r\\n\"\n         \"Link: <http://example.com/profiles/sally>; rel=\\\"tag\\\"\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_UNLINK\n  ,.request_path= \"/images/my_dog.jpg\"\n  ,.request_url= \"/images/my_dog.jpg\"\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.headers= { { \"Host\", \"example.com\" }\n\t     , { \"Link\", \"<http://example.com/profiles/sally>; rel=\\\"tag\\\"\" }\n             }\n  ,.body= \"\"\n  }\n\n#define SOURCE_REQUEST 42\n, {.name = \"source request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"SOURCE /music/sweet/music HTTP/1.1\\r\\n\"\n         \"Host: example.com\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_SOURCE\n  ,.request_path= \"/music/sweet/music\"\n  ,.request_url= \"/music/sweet/music\"\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers= { { \"Host\", \"example.com\" } }\n  ,.body= \"\"\n  }\n\n#define SOURCE_ICE_REQUEST 43\n, {.name = \"source request\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"SOURCE /music/sweet/music ICE/1.0\\r\\n\"\n         \"Host: example.com\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 0\n  ,.method= HTTP_SOURCE\n  ,.request_path= \"/music/sweet/music\"\n  ,.request_url= \"/music/sweet/music\"\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers= { { \"Host\", \"example.com\" } }\n  ,.body= \"\"\n  }\n\n#define POST_MULTI_TE_LAST_CHUNKED 44\n, {.name= \"post - multi coding transfer-encoding chunked body\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"POST / HTTP/1.1\\r\\n\"\n         \"Transfer-Encoding: deflate, chunked\\r\\n\"\n         \"\\r\\n\"\n         \"1e\\r\\nall your base are belong to us\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/\"\n  ,.request_url= \"/\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Transfer-Encoding\" , \"deflate, chunked\" }\n    }\n  ,.body= \"all your base are belong to us\"\n  ,.num_chunks_complete= 2\n  ,.chunk_lengths= { 0x1e }\n  }\n\n#define POST_MULTI_LINE_TE_LAST_CHUNKED 45\n, {.name= \"post - multi line coding transfer-encoding chunked body\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"POST / HTTP/1.1\\r\\n\"\n         \"Transfer-Encoding: deflate,\\r\\n\"\n         \" chunked\\r\\n\"\n         \"\\r\\n\"\n         \"1e\\r\\nall your base are belong to us\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/\"\n  ,.request_url= \"/\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Transfer-Encoding\" , \"deflate, chunked\" }\n    }\n  ,.body= \"all your base are belong to us\"\n  ,.num_chunks_complete= 2\n  ,.chunk_lengths= { 0x1e }\n  }\n\n#define CHUNKED_CONTENT_LENGTH 46\n, {.name= \"chunked with content-length set, allow_chunked_length flag is set\"\n  ,.type= HTTP_REQUEST\n  ,.raw= \"POST /chunked_w_content_length HTTP/1.1\\r\\n\"\n         \"Content-Length: 10\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"5; ilovew3;whattheluck=aretheseparametersfor\\r\\nhello\\r\\n\"\n         \"6; blahblah; blah\\r\\n world\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n  ,.allow_chunked_length = 1\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.method= HTTP_POST\n  ,.query_string= \"\"\n  ,.fragment= \"\"\n  ,.request_path= \"/chunked_w_content_length\"\n  ,.request_url= \"/chunked_w_content_length\"\n  ,.content_length= 10\n  ,.num_headers= 2\n  ,.headers={ { \"Content-Length\", \"10\"}\n            , { \"Transfer-Encoding\", \"chunked\" }\n  }\n  ,.body= \"hello world\"\n  ,.num_chunks_complete= 3\n  ,.chunk_lengths= { 5, 6 }\n  }\n};\n\n/* * R E S P O N S E S * */\nconst struct message responses[] =\n#define GOOGLE_301 0\n{ {.name= \"google 301\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 301 Moved Permanently\\r\\n\"\n         \"Location: http://www.google.com/\\r\\n\"\n         \"Content-Type: text/html; charset=UTF-8\\r\\n\"\n         \"Date: Sun, 26 Apr 2009 11:11:49 GMT\\r\\n\"\n         \"Expires: Tue, 26 May 2009 11:11:49 GMT\\r\\n\"\n         \"X-$PrototypeBI-Version: 1.6.0.3\\r\\n\" /* $ char in header field */\n         \"Cache-Control: public, max-age=2592000\\r\\n\"\n         \"Server: gws\\r\\n\"\n         \"Content-Length:  219  \\r\\n\"\n         \"\\r\\n\"\n         \"<HTML><HEAD><meta http-equiv=\\\"content-type\\\" content=\\\"text/html;charset=utf-8\\\">\\n\"\n         \"<TITLE>301 Moved</TITLE></HEAD><BODY>\\n\"\n         \"<H1>301 Moved</H1>\\n\"\n         \"The document has moved\\n\"\n         \"<A HREF=\\\"http://www.google.com/\\\">here</A>.\\r\\n\"\n         \"</BODY></HTML>\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 301\n  ,.response_status= \"Moved Permanently\"\n  ,.content_length= 219\n  ,.num_headers= 8\n  ,.headers=\n    { { \"Location\", \"http://www.google.com/\" }\n    , { \"Content-Type\", \"text/html; charset=UTF-8\" }\n    , { \"Date\", \"Sun, 26 Apr 2009 11:11:49 GMT\" }\n    , { \"Expires\", \"Tue, 26 May 2009 11:11:49 GMT\" }\n    , { \"X-$PrototypeBI-Version\", \"1.6.0.3\" }\n    , { \"Cache-Control\", \"public, max-age=2592000\" }\n    , { \"Server\", \"gws\" }\n    , { \"Content-Length\", \"219  \" }\n    }\n  ,.body= \"<HTML><HEAD><meta http-equiv=\\\"content-type\\\" content=\\\"text/html;charset=utf-8\\\">\\n\"\n          \"<TITLE>301 Moved</TITLE></HEAD><BODY>\\n\"\n          \"<H1>301 Moved</H1>\\n\"\n          \"The document has moved\\n\"\n          \"<A HREF=\\\"http://www.google.com/\\\">here</A>.\\r\\n\"\n          \"</BODY></HTML>\\r\\n\"\n  }\n\n#define NO_CONTENT_LENGTH_RESPONSE 1\n/* The client should wait for the server's EOF. That is, when content-length\n * is not specified, and \"Connection: close\", the end of body is specified\n * by the EOF.\n * Compare with APACHEBENCH_GET\n */\n, {.name= \"no content-length response\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Date: Tue, 04 Aug 2009 07:59:32 GMT\\r\\n\"\n         \"Server: Apache\\r\\n\"\n         \"X-Powered-By: Servlet/2.5 JSP/2.1\\r\\n\"\n         \"Content-Type: text/xml; charset=utf-8\\r\\n\"\n         \"Connection: close\\r\\n\"\n         \"\\r\\n\"\n         \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n         \"<SOAP-ENV:Envelope xmlns:SOAP-ENV=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\">\\n\"\n         \"  <SOAP-ENV:Body>\\n\"\n         \"    <SOAP-ENV:Fault>\\n\"\n         \"       <faultcode>SOAP-ENV:Client</faultcode>\\n\"\n         \"       <faultstring>Client Error</faultstring>\\n\"\n         \"    </SOAP-ENV:Fault>\\n\"\n         \"  </SOAP-ENV:Body>\\n\"\n         \"</SOAP-ENV:Envelope>\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 5\n  ,.headers=\n    { { \"Date\", \"Tue, 04 Aug 2009 07:59:32 GMT\" }\n    , { \"Server\", \"Apache\" }\n    , { \"X-Powered-By\", \"Servlet/2.5 JSP/2.1\" }\n    , { \"Content-Type\", \"text/xml; charset=utf-8\" }\n    , { \"Connection\", \"close\" }\n    }\n  ,.body= \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n          \"<SOAP-ENV:Envelope xmlns:SOAP-ENV=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\">\\n\"\n          \"  <SOAP-ENV:Body>\\n\"\n          \"    <SOAP-ENV:Fault>\\n\"\n          \"       <faultcode>SOAP-ENV:Client</faultcode>\\n\"\n          \"       <faultstring>Client Error</faultstring>\\n\"\n          \"    </SOAP-ENV:Fault>\\n\"\n          \"  </SOAP-ENV:Body>\\n\"\n          \"</SOAP-ENV:Envelope>\"\n  }\n\n#define NO_HEADERS_NO_BODY_404 2\n, {.name= \"404 no headers no body\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 404 Not Found\\r\\n\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 404\n  ,.response_status= \"Not Found\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= {}\n  ,.body_size= 0\n  ,.body= \"\"\n  }\n\n#define NO_REASON_PHRASE 3\n, {.name= \"301 no response phrase\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 301\\r\\n\\r\\n\"\n  ,.should_keep_alive = FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 301\n  ,.content_length= -1\n  ,.response_status= \"\"\n  ,.num_headers= 0\n  ,.headers= {}\n  ,.body= \"\"\n  }\n\n#define TRAILING_SPACE_ON_CHUNKED_BODY 4\n, {.name=\"200 trailing space on chunked body\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Content-Type: text/plain\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"25  \\r\\n\"\n         \"This is the data in the first chunk\\r\\n\"\n         \"\\r\\n\"\n         \"1C\\r\\n\"\n         \"and this is the second one\\r\\n\"\n         \"\\r\\n\"\n         \"0  \\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.headers=\n    { {\"Content-Type\", \"text/plain\" }\n    , {\"Transfer-Encoding\", \"chunked\" }\n    }\n  ,.body_size = 37+28\n  ,.body =\n         \"This is the data in the first chunk\\r\\n\"\n         \"and this is the second one\\r\\n\"\n  ,.num_chunks_complete= 3\n  ,.chunk_lengths= { 0x25, 0x1c }\n  }\n\n#define NO_CARRIAGE_RET 5\n, {.name=\"no carriage ret\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\n\"\n         \"Content-Type: text/html; charset=utf-8\\n\"\n         \"Connection: close\\n\"\n         \"\\n\"\n         \"these headers are from http://news.ycombinator.com/\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.headers=\n    { {\"Content-Type\", \"text/html; charset=utf-8\" }\n    , {\"Connection\", \"close\" }\n    }\n  ,.body= \"these headers are from http://news.ycombinator.com/\"\n  }\n\n#define PROXY_CONNECTION 6\n, {.name=\"proxy connection\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Content-Type: text/html; charset=UTF-8\\r\\n\"\n         \"Content-Length: 11\\r\\n\"\n         \"Proxy-Connection: close\\r\\n\"\n         \"Date: Thu, 31 Dec 2009 20:55:48 +0000\\r\\n\"\n         \"\\r\\n\"\n         \"hello world\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= 11\n  ,.num_headers= 4\n  ,.headers=\n    { {\"Content-Type\", \"text/html; charset=UTF-8\" }\n    , {\"Content-Length\", \"11\" }\n    , {\"Proxy-Connection\", \"close\" }\n    , {\"Date\", \"Thu, 31 Dec 2009 20:55:48 +0000\"}\n    }\n  ,.body= \"hello world\"\n  }\n\n#define UNDERSTORE_HEADER_KEY 7\n  // shown by\n  // curl -o /dev/null -v \"http://ad.doubleclick.net/pfadx/DARTSHELLCONFIGXML;dcmt=text/xml;\"\n, {.name=\"underscore header key\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Server: DCLK-AdSvr\\r\\n\"\n         \"Content-Type: text/xml\\r\\n\"\n         \"Content-Length: 0\\r\\n\"\n         \"DCLK_imp: v7;x;114750856;0-0;0;17820020;0/0;21603567/21621457/1;;~okv=;dcmt=text/xml;;~cs=o\\r\\n\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= 0\n  ,.num_headers= 4\n  ,.headers=\n    { {\"Server\", \"DCLK-AdSvr\" }\n    , {\"Content-Type\", \"text/xml\" }\n    , {\"Content-Length\", \"0\" }\n    , {\"DCLK_imp\", \"v7;x;114750856;0-0;0;17820020;0/0;21603567/21621457/1;;~okv=;dcmt=text/xml;;~cs=o\" }\n    }\n  ,.body= \"\"\n  }\n\n#define BONJOUR_MADAME_FR 8\n/* The client should not merge two headers fields when the first one doesn't\n * have a value.\n */\n, {.name= \"bonjourmadame.fr\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.0 301 Moved Permanently\\r\\n\"\n         \"Date: Thu, 03 Jun 2010 09:56:32 GMT\\r\\n\"\n         \"Server: Apache/2.2.3 (Red Hat)\\r\\n\"\n         \"Cache-Control: public\\r\\n\"\n         \"Pragma: \\r\\n\"\n         \"Location: http://www.bonjourmadame.fr/\\r\\n\"\n         \"Vary: Accept-Encoding\\r\\n\"\n         \"Content-Length: 0\\r\\n\"\n         \"Content-Type: text/html; charset=UTF-8\\r\\n\"\n         \"Connection: keep-alive\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 0\n  ,.status_code= 301\n  ,.response_status= \"Moved Permanently\"\n  ,.content_length= 0\n  ,.num_headers= 9\n  ,.headers=\n    { { \"Date\", \"Thu, 03 Jun 2010 09:56:32 GMT\" }\n    , { \"Server\", \"Apache/2.2.3 (Red Hat)\" }\n    , { \"Cache-Control\", \"public\" }\n    , { \"Pragma\", \"\" }\n    , { \"Location\", \"http://www.bonjourmadame.fr/\" }\n    , { \"Vary\",  \"Accept-Encoding\" }\n    , { \"Content-Length\", \"0\" }\n    , { \"Content-Type\", \"text/html; charset=UTF-8\" }\n    , { \"Connection\", \"keep-alive\" }\n    }\n  ,.body= \"\"\n  }\n\n#define RES_FIELD_UNDERSCORE 9\n/* Should handle spaces in header fields */\n, {.name= \"field underscore\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Date: Tue, 28 Sep 2010 01:14:13 GMT\\r\\n\"\n         \"Server: Apache\\r\\n\"\n         \"Cache-Control: no-cache, must-revalidate\\r\\n\"\n         \"Expires: Mon, 26 Jul 1997 05:00:00 GMT\\r\\n\"\n         \".et-Cookie: PlaxoCS=1274804622353690521; path=/; domain=.plaxo.com\\r\\n\"\n         \"Vary: Accept-Encoding\\r\\n\"\n         \"_eep-Alive: timeout=45\\r\\n\" /* semantic value ignored */\n         \"_onnection: Keep-Alive\\r\\n\" /* semantic value ignored */\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"Content-Type: text/html\\r\\n\"\n         \"Connection: close\\r\\n\"\n         \"\\r\\n\"\n         \"0\\r\\n\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 11\n  ,.headers=\n    { { \"Date\", \"Tue, 28 Sep 2010 01:14:13 GMT\" }\n    , { \"Server\", \"Apache\" }\n    , { \"Cache-Control\", \"no-cache, must-revalidate\" }\n    , { \"Expires\", \"Mon, 26 Jul 1997 05:00:00 GMT\" }\n    , { \".et-Cookie\", \"PlaxoCS=1274804622353690521; path=/; domain=.plaxo.com\" }\n    , { \"Vary\", \"Accept-Encoding\" }\n    , { \"_eep-Alive\", \"timeout=45\" }\n    , { \"_onnection\", \"Keep-Alive\" }\n    , { \"Transfer-Encoding\", \"chunked\" }\n    , { \"Content-Type\", \"text/html\" }\n    , { \"Connection\", \"close\" }\n    }\n  ,.body= \"\"\n  ,.num_chunks_complete= 1\n  ,.chunk_lengths= {}\n  }\n\n#define NON_ASCII_IN_STATUS_LINE 10\n/* Should handle non-ASCII in status line */\n, {.name= \"non-ASCII in status line\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 500 Oriëntatieprobleem\\r\\n\"\n         \"Date: Fri, 5 Nov 2010 23:07:12 GMT+2\\r\\n\"\n         \"Content-Length: 0\\r\\n\"\n         \"Connection: close\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 500\n  ,.response_status= \"Oriëntatieprobleem\"\n  ,.content_length= 0\n  ,.num_headers= 3\n  ,.headers=\n    { { \"Date\", \"Fri, 5 Nov 2010 23:07:12 GMT+2\" }\n    , { \"Content-Length\", \"0\" }\n    , { \"Connection\", \"close\" }\n    }\n  ,.body= \"\"\n  }\n\n#define HTTP_VERSION_0_9 11\n/* Should handle HTTP/0.9 */\n, {.name= \"http version 0.9\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/0.9 200 OK\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 0\n  ,.http_minor= 9\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers=\n    {}\n  ,.body= \"\"\n  }\n\n#define NO_CONTENT_LENGTH_NO_TRANSFER_ENCODING_RESPONSE 12\n/* The client should wait for the server's EOF. That is, when neither\n * content-length nor transfer-encoding is specified, the end of body\n * is specified by the EOF.\n */\n, {.name= \"neither content-length nor transfer-encoding response\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Content-Type: text/plain\\r\\n\"\n         \"\\r\\n\"\n         \"hello world\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Content-Type\", \"text/plain\" }\n    }\n  ,.body= \"hello world\"\n  }\n\n#define NO_BODY_HTTP10_KA_200 13\n, {.name= \"HTTP/1.0 with keep-alive and EOF-terminated 200 status\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.0 200 OK\\r\\n\"\n         \"Connection: keep-alive\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 1\n  ,.http_minor= 0\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Connection\", \"keep-alive\" }\n    }\n  ,.body_size= 0\n  ,.body= \"\"\n  }\n\n#define NO_BODY_HTTP10_KA_204 14\n, {.name= \"HTTP/1.0 with keep-alive and a 204 status\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.0 204 No content\\r\\n\"\n         \"Connection: keep-alive\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 0\n  ,.status_code= 204\n  ,.response_status= \"No content\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Connection\", \"keep-alive\" }\n    }\n  ,.body_size= 0\n  ,.body= \"\"\n  }\n\n#define NO_BODY_HTTP11_KA_200 15\n, {.name= \"HTTP/1.1 with an EOF-terminated 200 status\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers={}\n  ,.body_size= 0\n  ,.body= \"\"\n  }\n\n#define NO_BODY_HTTP11_KA_204 16\n, {.name= \"HTTP/1.1 with a 204 status\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 204 No content\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 204\n  ,.response_status= \"No content\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers={}\n  ,.body_size= 0\n  ,.body= \"\"\n  }\n\n#define NO_BODY_HTTP11_NOKA_204 17\n, {.name= \"HTTP/1.1 with a 204 status and keep-alive disabled\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 204 No content\\r\\n\"\n         \"Connection: close\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 204\n  ,.response_status= \"No content\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Connection\", \"close\" }\n    }\n  ,.body_size= 0\n  ,.body= \"\"\n  }\n\n#define NO_BODY_HTTP11_KA_CHUNKED_200 18\n, {.name= \"HTTP/1.1 with chunked endocing and a 200 response\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers=\n    { { \"Transfer-Encoding\", \"chunked\" }\n    }\n  ,.body_size= 0\n  ,.body= \"\"\n  ,.num_chunks_complete= 1\n  }\n\n#if !HTTP_PARSER_STRICT\n#define SPACE_IN_FIELD_RES 19\n/* Should handle spaces in header fields */\n, {.name= \"field space\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Server: Microsoft-IIS/6.0\\r\\n\"\n         \"X-Powered-By: ASP.NET\\r\\n\"\n         \"en-US Content-Type: text/xml\\r\\n\" /* this is the problem */\n         \"Content-Type: text/xml\\r\\n\"\n         \"Content-Length: 16\\r\\n\"\n         \"Date: Fri, 23 Jul 2010 18:45:38 GMT\\r\\n\"\n         \"Connection: keep-alive\\r\\n\"\n         \"\\r\\n\"\n         \"<xml>hello</xml>\" /* fake body */\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= 16\n  ,.num_headers= 7\n  ,.headers=\n    { { \"Server\",  \"Microsoft-IIS/6.0\" }\n    , { \"X-Powered-By\", \"ASP.NET\" }\n    , { \"en-US Content-Type\", \"text/xml\" }\n    , { \"Content-Type\", \"text/xml\" }\n    , { \"Content-Length\", \"16\" }\n    , { \"Date\", \"Fri, 23 Jul 2010 18:45:38 GMT\" }\n    , { \"Connection\", \"keep-alive\" }\n    }\n  ,.body= \"<xml>hello</xml>\"\n  }\n#endif /* !HTTP_PARSER_STRICT */\n\n#define AMAZON_COM 20\n, {.name= \"amazon.com\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 301 MovedPermanently\\r\\n\"\n         \"Date: Wed, 15 May 2013 17:06:33 GMT\\r\\n\"\n         \"Server: Server\\r\\n\"\n         \"x-amz-id-1: 0GPHKXSJQ826RK7GZEB2\\r\\n\"\n         \"p3p: policyref=\\\"http://www.amazon.com/w3c/p3p.xml\\\",CP=\\\"CAO DSP LAW CUR ADM IVAo IVDo CONo OTPo OUR DELi PUBi OTRi BUS PHY ONL UNI PUR FIN COM NAV INT DEM CNT STA HEA PRE LOC GOV OTC \\\"\\r\\n\"\n         \"x-amz-id-2: STN69VZxIFSz9YJLbz1GDbxpbjG6Qjmmq5E3DxRhOUw+Et0p4hr7c/Q8qNcx4oAD\\r\\n\"\n         \"Location: http://www.amazon.com/Dan-Brown/e/B000AP9DSU/ref=s9_pop_gw_al1?_encoding=UTF8&refinementId=618073011&pf_rd_m=ATVPDKIKX0DER&pf_rd_s=center-2&pf_rd_r=0SHYY5BZXN3KR20BNFAY&pf_rd_t=101&pf_rd_p=1263340922&pf_rd_i=507846\\r\\n\"\n         \"Vary: Accept-Encoding,User-Agent\\r\\n\"\n         \"Content-Type: text/html; charset=ISO-8859-1\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"1\\r\\n\"\n         \"\\n\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 301\n  ,.response_status= \"MovedPermanently\"\n  ,.content_length= -1\n  ,.num_headers= 9\n  ,.headers= { { \"Date\", \"Wed, 15 May 2013 17:06:33 GMT\" }\n             , { \"Server\", \"Server\" }\n             , { \"x-amz-id-1\", \"0GPHKXSJQ826RK7GZEB2\" }\n             , { \"p3p\", \"policyref=\\\"http://www.amazon.com/w3c/p3p.xml\\\",CP=\\\"CAO DSP LAW CUR ADM IVAo IVDo CONo OTPo OUR DELi PUBi OTRi BUS PHY ONL UNI PUR FIN COM NAV INT DEM CNT STA HEA PRE LOC GOV OTC \\\"\" }\n             , { \"x-amz-id-2\", \"STN69VZxIFSz9YJLbz1GDbxpbjG6Qjmmq5E3DxRhOUw+Et0p4hr7c/Q8qNcx4oAD\" }\n             , { \"Location\", \"http://www.amazon.com/Dan-Brown/e/B000AP9DSU/ref=s9_pop_gw_al1?_encoding=UTF8&refinementId=618073011&pf_rd_m=ATVPDKIKX0DER&pf_rd_s=center-2&pf_rd_r=0SHYY5BZXN3KR20BNFAY&pf_rd_t=101&pf_rd_p=1263340922&pf_rd_i=507846\" }\n             , { \"Vary\", \"Accept-Encoding,User-Agent\" }\n             , { \"Content-Type\", \"text/html; charset=ISO-8859-1\" }\n             , { \"Transfer-Encoding\", \"chunked\" }\n             }\n  ,.body= \"\\n\"\n  ,.num_chunks_complete= 2\n  ,.chunk_lengths= { 1 }\n  }\n\n#define EMPTY_REASON_PHRASE_AFTER_SPACE 21\n, {.name= \"empty reason phrase after space\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 \\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"\"\n  ,.content_length= -1\n  ,.num_headers= 0\n  ,.headers= {}\n  ,.body= \"\"\n  }\n\n#define CONTENT_LENGTH_X 22\n, {.name= \"Content-Length-X\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Content-Length-X: 0\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"2\\r\\n\"\n         \"OK\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.headers= { { \"Content-Length-X\", \"0\" }\n             , { \"Transfer-Encoding\", \"chunked\" }\n             }\n  ,.body= \"OK\"\n  ,.num_chunks_complete= 2\n  ,.chunk_lengths= { 2 }\n  }\n\n#define HTTP_101_RESPONSE_WITH_UPGRADE_HEADER 23\n, {.name= \"HTTP 101 response with Upgrade header\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n         \"Connection: upgrade\\r\\n\"\n         \"Upgrade: h2c\\r\\n\"\n         \"\\r\\n\"\n         \"proto\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 101\n  ,.response_status= \"Switching Protocols\"\n  ,.upgrade= \"proto\"\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.headers=\n    { { \"Connection\", \"upgrade\" }\n    , { \"Upgrade\", \"h2c\" }\n    }\n  }\n\n#define HTTP_101_RESPONSE_WITH_UPGRADE_HEADER_AND_CONTENT_LENGTH 24\n, {.name= \"HTTP 101 response with Upgrade and Content-Length header\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n         \"Connection: upgrade\\r\\n\"\n         \"Upgrade: h2c\\r\\n\"\n         \"Content-Length: 4\\r\\n\"\n         \"\\r\\n\"\n         \"body\"\n         \"proto\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 101\n  ,.response_status= \"Switching Protocols\"\n  ,.body= \"body\"\n  ,.upgrade= \"proto\"\n  ,.content_length= 4\n  ,.num_headers= 3\n  ,.headers=\n    { { \"Connection\", \"upgrade\" }\n    , { \"Upgrade\", \"h2c\" }\n    , { \"Content-Length\", \"4\" }\n    }\n  }\n\n#define HTTP_101_RESPONSE_WITH_UPGRADE_HEADER_AND_TRANSFER_ENCODING 25\n, {.name= \"HTTP 101 response with Upgrade and Transfer-Encoding header\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n         \"Connection: upgrade\\r\\n\"\n         \"Upgrade: h2c\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"2\\r\\n\"\n         \"bo\\r\\n\"\n         \"2\\r\\n\"\n         \"dy\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n         \"proto\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 101\n  ,.response_status= \"Switching Protocols\"\n  ,.body= \"body\"\n  ,.upgrade= \"proto\"\n  ,.content_length= -1\n  ,.num_headers= 3\n  ,.headers=\n    { { \"Connection\", \"upgrade\" }\n    , { \"Upgrade\", \"h2c\" }\n    , { \"Transfer-Encoding\", \"chunked\" }\n    }\n  ,.num_chunks_complete= 3\n  ,.chunk_lengths= { 2, 2 }\n  }\n\n#define HTTP_200_RESPONSE_WITH_UPGRADE_HEADER 26\n, {.name= \"HTTP 200 response with Upgrade header\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Connection: upgrade\\r\\n\"\n         \"Upgrade: h2c\\r\\n\"\n         \"\\r\\n\"\n         \"body\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.body= \"body\"\n  ,.upgrade= NULL\n  ,.content_length= -1\n  ,.num_headers= 2\n  ,.headers=\n    { { \"Connection\", \"upgrade\" }\n    , { \"Upgrade\", \"h2c\" }\n    }\n  }\n\n#define HTTP_200_RESPONSE_WITH_UPGRADE_HEADER_AND_CONTENT_LENGTH 27\n, {.name= \"HTTP 200 response with Upgrade and Content-Length header\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Connection: upgrade\\r\\n\"\n         \"Upgrade: h2c\\r\\n\"\n         \"Content-Length: 4\\r\\n\"\n         \"\\r\\n\"\n         \"body\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= 4\n  ,.num_headers= 3\n  ,.body= \"body\"\n  ,.upgrade= NULL\n  ,.headers=\n    { { \"Connection\", \"upgrade\" }\n    , { \"Upgrade\", \"h2c\" }\n    , { \"Content-Length\", \"4\" }\n    }\n  }\n\n#define HTTP_200_RESPONSE_WITH_UPGRADE_HEADER_AND_TRANSFER_ENCODING 28\n, {.name= \"HTTP 200 response with Upgrade and Transfer-Encoding header\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Connection: upgrade\\r\\n\"\n         \"Upgrade: h2c\\r\\n\"\n         \"Transfer-Encoding: chunked\\r\\n\"\n         \"\\r\\n\"\n         \"2\\r\\n\"\n         \"bo\\r\\n\"\n         \"2\\r\\n\"\n         \"dy\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= TRUE\n  ,.message_complete_on_eof= FALSE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 3\n  ,.body= \"body\"\n  ,.upgrade= NULL\n  ,.headers=\n    { { \"Connection\", \"upgrade\" }\n    , { \"Upgrade\", \"h2c\" }\n    , { \"Transfer-Encoding\", \"chunked\" }\n    }\n  ,.num_chunks_complete= 3\n  ,.chunk_lengths= { 2, 2 }\n  }\n#define HTTP_200_MULTI_TE_NOT_LAST_CHUNKED 29\n, {.name= \"HTTP 200 response with `chunked` being *not last* Transfer-Encoding\"\n  ,.type= HTTP_RESPONSE\n  ,.raw= \"HTTP/1.1 200 OK\\r\\n\"\n         \"Transfer-Encoding: chunked, identity\\r\\n\"\n         \"\\r\\n\"\n         \"2\\r\\n\"\n         \"OK\\r\\n\"\n         \"0\\r\\n\"\n         \"\\r\\n\"\n  ,.should_keep_alive= FALSE\n  ,.message_complete_on_eof= TRUE\n  ,.http_major= 1\n  ,.http_minor= 1\n  ,.status_code= 200\n  ,.response_status= \"OK\"\n  ,.content_length= -1\n  ,.num_headers= 1\n  ,.headers= { { \"Transfer-Encoding\", \"chunked, identity\" }\n             }\n  ,.body= \"2\\r\\nOK\\r\\n0\\r\\n\\r\\n\"\n  ,.num_chunks_complete= 0\n  }\n};\n\n/* strnlen() is a POSIX.2008 addition. Can't rely on it being available so\n * define it ourselves.\n */\nsize_t\nstrnlen(const char *s, size_t maxlen)\n{\n  const char *p;\n\n  p = memchr(s, '\\0', maxlen);\n  if (p == NULL)\n    return maxlen;\n\n  return p - s;\n}\n\nsize_t\nstrlncat(char *dst, size_t len, const char *src, size_t n)\n{\n  size_t slen;\n  size_t dlen;\n  size_t rlen;\n  size_t ncpy;\n\n  slen = strnlen(src, n);\n  dlen = strnlen(dst, len);\n\n  if (dlen < len) {\n    rlen = len - dlen;\n    ncpy = slen < rlen ? slen : (rlen - 1);\n    memcpy(dst + dlen, src, ncpy);\n    dst[dlen + ncpy] = '\\0';\n  }\n\n  assert(len > slen + dlen);\n  return slen + dlen;\n}\n\nsize_t\nstrlncpy(char *dst, size_t len, const char *src, size_t n)\n{\n  size_t slen;\n  size_t ncpy;\n\n  slen = strnlen(src, n);\n\n  if (len > 0) {\n    ncpy = slen < len ? slen : (len - 1);\n    memcpy(dst, src, ncpy);\n    dst[ncpy] = '\\0';\n  }\n\n  assert(len > slen);\n  return slen;\n}\n\nint\nrequest_url_cb (http_parser *p, const char *buf, size_t len)\n{\n  assert(p == &parser);\n  strlncat(messages[num_messages].request_url,\n           sizeof(messages[num_messages].request_url),\n           buf,\n           len);\n  return 0;\n}\n\nint\nheader_field_cb (http_parser *p, const char *buf, size_t len)\n{\n  assert(p == &parser);\n  struct message *m = &messages[num_messages];\n\n  if (m->last_header_element != FIELD)\n    m->num_headers++;\n\n  strlncat(m->headers[m->num_headers-1][0],\n           sizeof(m->headers[m->num_headers-1][0]),\n           buf,\n           len);\n\n  m->last_header_element = FIELD;\n\n  return 0;\n}\n\nint\nheader_value_cb (http_parser *p, const char *buf, size_t len)\n{\n  assert(p == &parser);\n  struct message *m = &messages[num_messages];\n\n  strlncat(m->headers[m->num_headers-1][1],\n           sizeof(m->headers[m->num_headers-1][1]),\n           buf,\n           len);\n\n  m->last_header_element = VALUE;\n\n  return 0;\n}\n\nvoid\ncheck_body_is_final (const http_parser *p)\n{\n  if (messages[num_messages].body_is_final) {\n    fprintf(stderr, \"\\n\\n *** Error http_body_is_final() should return 1 \"\n                    \"on last on_body callback call \"\n                    \"but it doesn't! ***\\n\\n\");\n    assert(0);\n    abort();\n  }\n  messages[num_messages].body_is_final = http_body_is_final(p);\n}\n\nint\nbody_cb (http_parser *p, const char *buf, size_t len)\n{\n  assert(p == &parser);\n  strlncat(messages[num_messages].body,\n           sizeof(messages[num_messages].body),\n           buf,\n           len);\n  messages[num_messages].body_size += len;\n  check_body_is_final(p);\n // printf(\"body_cb: '%s'\\n\", requests[num_messages].body);\n  return 0;\n}\n\nint\ncount_body_cb (http_parser *p, const char *buf, size_t len)\n{\n  assert(p == &parser);\n  assert(buf);\n  messages[num_messages].body_size += len;\n  check_body_is_final(p);\n  return 0;\n}\n\nint\nmessage_begin_cb (http_parser *p)\n{\n  assert(p == &parser);\n  assert(!messages[num_messages].message_begin_cb_called);\n  messages[num_messages].message_begin_cb_called = TRUE;\n  return 0;\n}\n\nint\nheaders_complete_cb (http_parser *p)\n{\n  assert(p == &parser);\n  messages[num_messages].method = parser.method;\n  messages[num_messages].status_code = parser.status_code;\n  messages[num_messages].http_major = parser.http_major;\n  messages[num_messages].http_minor = parser.http_minor;\n  messages[num_messages].content_length = parser.content_length;\n  messages[num_messages].headers_complete_cb_called = TRUE;\n  messages[num_messages].should_keep_alive = http_should_keep_alive(&parser);\n  return 0;\n}\n\nint\nmessage_complete_cb (http_parser *p)\n{\n  assert(p == &parser);\n  if (messages[num_messages].should_keep_alive !=\n      http_should_keep_alive(&parser))\n  {\n    fprintf(stderr, \"\\n\\n *** Error http_should_keep_alive() should have same \"\n                    \"value in both on_message_complete and on_headers_complete \"\n                    \"but it doesn't! ***\\n\\n\");\n    assert(0);\n    abort();\n  }\n\n  if (messages[num_messages].body_size &&\n      http_body_is_final(p) &&\n      !messages[num_messages].body_is_final)\n  {\n    fprintf(stderr, \"\\n\\n *** Error http_body_is_final() should return 1 \"\n                    \"on last on_body callback call \"\n                    \"but it doesn't! ***\\n\\n\");\n    assert(0);\n    abort();\n  }\n\n  messages[num_messages].message_complete_cb_called = TRUE;\n\n  messages[num_messages].message_complete_on_eof = currently_parsing_eof;\n\n  num_messages++;\n  return 0;\n}\n\nint\nresponse_status_cb (http_parser *p, const char *buf, size_t len)\n{\n  assert(p == &parser);\n\n  messages[num_messages].status_cb_called = TRUE;\n\n  strlncat(messages[num_messages].response_status,\n           sizeof(messages[num_messages].response_status),\n           buf,\n           len);\n  return 0;\n}\n\nint\nchunk_header_cb (http_parser *p)\n{\n  assert(p == &parser);\n  int chunk_idx = messages[num_messages].num_chunks;\n  messages[num_messages].num_chunks++;\n  if (chunk_idx < MAX_CHUNKS) {\n    messages[num_messages].chunk_lengths[chunk_idx] = p->content_length;\n  }\n\n  return 0;\n}\n\nint\nchunk_complete_cb (http_parser *p)\n{\n  assert(p == &parser);\n\n  /* Here we want to verify that each chunk_header_cb is matched by a\n   * chunk_complete_cb, so not only should the total number of calls to\n   * both callbacks be the same, but they also should be interleaved\n   * properly */\n  assert(messages[num_messages].num_chunks ==\n         messages[num_messages].num_chunks_complete + 1);\n\n  messages[num_messages].num_chunks_complete++;\n  return 0;\n}\n\n/* These dontcall_* callbacks exist so that we can verify that when we're\n * paused, no additional callbacks are invoked */\nint\ndontcall_message_begin_cb (http_parser *p)\n{\n  if (p) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_message_begin() called on paused parser ***\\n\\n\");\n  abort();\n}\n\nint\ndontcall_header_field_cb (http_parser *p, const char *buf, size_t len)\n{\n  if (p || buf || len) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_header_field() called on paused parser ***\\n\\n\");\n  abort();\n}\n\nint\ndontcall_header_value_cb (http_parser *p, const char *buf, size_t len)\n{\n  if (p || buf || len) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_header_value() called on paused parser ***\\n\\n\");\n  abort();\n}\n\nint\ndontcall_request_url_cb (http_parser *p, const char *buf, size_t len)\n{\n  if (p || buf || len) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_request_url() called on paused parser ***\\n\\n\");\n  abort();\n}\n\nint\ndontcall_body_cb (http_parser *p, const char *buf, size_t len)\n{\n  if (p || buf || len) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_body_cb() called on paused parser ***\\n\\n\");\n  abort();\n}\n\nint\ndontcall_headers_complete_cb (http_parser *p)\n{\n  if (p) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_headers_complete() called on paused \"\n                  \"parser ***\\n\\n\");\n  abort();\n}\n\nint\ndontcall_message_complete_cb (http_parser *p)\n{\n  if (p) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_message_complete() called on paused \"\n                  \"parser ***\\n\\n\");\n  abort();\n}\n\nint\ndontcall_response_status_cb (http_parser *p, const char *buf, size_t len)\n{\n  if (p || buf || len) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_status() called on paused parser ***\\n\\n\");\n  abort();\n}\n\nint\ndontcall_chunk_header_cb (http_parser *p)\n{\n  if (p) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_chunk_header() called on paused parser ***\\n\\n\");\n  exit(1);\n}\n\nint\ndontcall_chunk_complete_cb (http_parser *p)\n{\n  if (p) { } // gcc\n  fprintf(stderr, \"\\n\\n*** on_chunk_complete() \"\n          \"called on paused parser ***\\n\\n\");\n  exit(1);\n}\n\nstatic http_parser_settings settings_dontcall =\n  {.on_message_begin = dontcall_message_begin_cb\n  ,.on_header_field = dontcall_header_field_cb\n  ,.on_header_value = dontcall_header_value_cb\n  ,.on_url = dontcall_request_url_cb\n  ,.on_status = dontcall_response_status_cb\n  ,.on_body = dontcall_body_cb\n  ,.on_headers_complete = dontcall_headers_complete_cb\n  ,.on_message_complete = dontcall_message_complete_cb\n  ,.on_chunk_header = dontcall_chunk_header_cb\n  ,.on_chunk_complete = dontcall_chunk_complete_cb\n  };\n\n/* These pause_* callbacks always pause the parser and just invoke the regular\n * callback that tracks content. Before returning, we overwrite the parser\n * settings to point to the _dontcall variety so that we can verify that\n * the pause actually did, you know, pause. */\nint\npause_message_begin_cb (http_parser *p)\n{\n  http_parser_pause(p, 1);\n  *current_pause_parser = settings_dontcall;\n  return message_begin_cb(p);\n}\n\nint\npause_header_field_cb (http_parser *p, const char *buf, size_t len)\n{\n  http_parser_pause(p, 1);\n  *current_pause_parser = settings_dontcall;\n  return header_field_cb(p, buf, len);\n}\n\nint\npause_header_value_cb (http_parser *p, const char *buf, size_t len)\n{\n  http_parser_pause(p, 1);\n  *current_pause_parser = settings_dontcall;\n  return header_value_cb(p, buf, len);\n}\n\nint\npause_request_url_cb (http_parser *p, const char *buf, size_t len)\n{\n  http_parser_pause(p, 1);\n  *current_pause_parser = settings_dontcall;\n  return request_url_cb(p, buf, len);\n}\n\nint\npause_body_cb (http_parser *p, const char *buf, size_t len)\n{\n  http_parser_pause(p, 1);\n  *current_pause_parser = settings_dontcall;\n  return body_cb(p, buf, len);\n}\n\nint\npause_headers_complete_cb (http_parser *p)\n{\n  http_parser_pause(p, 1);\n  *current_pause_parser = settings_dontcall;\n  return headers_complete_cb(p);\n}\n\nint\npause_message_complete_cb (http_parser *p)\n{\n  http_parser_pause(p, 1);\n  *current_pause_parser = settings_dontcall;\n  return message_complete_cb(p);\n}\n\nint\npause_response_status_cb (http_parser *p, const char *buf, size_t len)\n{\n  http_parser_pause(p, 1);\n  *current_pause_parser = settings_dontcall;\n  return response_status_cb(p, buf, len);\n}\n\nint\npause_chunk_header_cb (http_parser *p)\n{\n  http_parser_pause(p, 1);\n  *current_pause_parser = settings_dontcall;\n  return chunk_header_cb(p);\n}\n\nint\npause_chunk_complete_cb (http_parser *p)\n{\n  http_parser_pause(p, 1);\n  *current_pause_parser = settings_dontcall;\n  return chunk_complete_cb(p);\n}\n\nint\nconnect_headers_complete_cb (http_parser *p)\n{\n  headers_complete_cb(p);\n  return 1;\n}\n\nint\nconnect_message_complete_cb (http_parser *p)\n{\n  messages[num_messages].should_keep_alive = http_should_keep_alive(&parser);\n  return message_complete_cb(p);\n}\n\nstatic http_parser_settings settings_pause =\n  {.on_message_begin = pause_message_begin_cb\n  ,.on_header_field = pause_header_field_cb\n  ,.on_header_value = pause_header_value_cb\n  ,.on_url = pause_request_url_cb\n  ,.on_status = pause_response_status_cb\n  ,.on_body = pause_body_cb\n  ,.on_headers_complete = pause_headers_complete_cb\n  ,.on_message_complete = pause_message_complete_cb\n  ,.on_chunk_header = pause_chunk_header_cb\n  ,.on_chunk_complete = pause_chunk_complete_cb\n  };\n\nstatic http_parser_settings settings =\n  {.on_message_begin = message_begin_cb\n  ,.on_header_field = header_field_cb\n  ,.on_header_value = header_value_cb\n  ,.on_url = request_url_cb\n  ,.on_status = response_status_cb\n  ,.on_body = body_cb\n  ,.on_headers_complete = headers_complete_cb\n  ,.on_message_complete = message_complete_cb\n  ,.on_chunk_header = chunk_header_cb\n  ,.on_chunk_complete = chunk_complete_cb\n  };\n\nstatic http_parser_settings settings_count_body =\n  {.on_message_begin = message_begin_cb\n  ,.on_header_field = header_field_cb\n  ,.on_header_value = header_value_cb\n  ,.on_url = request_url_cb\n  ,.on_status = response_status_cb\n  ,.on_body = count_body_cb\n  ,.on_headers_complete = headers_complete_cb\n  ,.on_message_complete = message_complete_cb\n  ,.on_chunk_header = chunk_header_cb\n  ,.on_chunk_complete = chunk_complete_cb\n  };\n\nstatic http_parser_settings settings_connect =\n  {.on_message_begin = message_begin_cb\n  ,.on_header_field = header_field_cb\n  ,.on_header_value = header_value_cb\n  ,.on_url = request_url_cb\n  ,.on_status = response_status_cb\n  ,.on_body = dontcall_body_cb\n  ,.on_headers_complete = connect_headers_complete_cb\n  ,.on_message_complete = connect_message_complete_cb\n  ,.on_chunk_header = chunk_header_cb\n  ,.on_chunk_complete = chunk_complete_cb\n  };\n\nstatic http_parser_settings settings_null =\n  {.on_message_begin = 0\n  ,.on_header_field = 0\n  ,.on_header_value = 0\n  ,.on_url = 0\n  ,.on_status = 0\n  ,.on_body = 0\n  ,.on_headers_complete = 0\n  ,.on_message_complete = 0\n  ,.on_chunk_header = 0\n  ,.on_chunk_complete = 0\n  };\n\nvoid\nparser_init (enum http_parser_type type)\n{\n  num_messages = 0;\n  http_parser_init(&parser, type);\n  memset(&messages, 0, sizeof messages);\n}\n\nsize_t parse (const char *buf, size_t len)\n{\n  size_t nparsed;\n  currently_parsing_eof = (len == 0);\n  nparsed = http_parser_execute(&parser, &settings, buf, len);\n  return nparsed;\n}\n\nsize_t parse_count_body (const char *buf, size_t len)\n{\n  size_t nparsed;\n  currently_parsing_eof = (len == 0);\n  nparsed = http_parser_execute(&parser, &settings_count_body, buf, len);\n  return nparsed;\n}\n\nsize_t parse_pause (const char *buf, size_t len)\n{\n  size_t nparsed;\n  http_parser_settings s = settings_pause;\n\n  currently_parsing_eof = (len == 0);\n  current_pause_parser = &s;\n  nparsed = http_parser_execute(&parser, current_pause_parser, buf, len);\n  return nparsed;\n}\n\nsize_t parse_connect (const char *buf, size_t len)\n{\n  size_t nparsed;\n  currently_parsing_eof = (len == 0);\n  nparsed = http_parser_execute(&parser, &settings_connect, buf, len);\n  return nparsed;\n}\n\nstatic inline int\ncheck_str_eq (const struct message *m,\n              const char *prop,\n              const char *expected,\n              const char *found) {\n  if ((expected == NULL) != (found == NULL)) {\n    printf(\"\\n*** Error: %s in '%s' ***\\n\\n\", prop, m->name);\n    printf(\"expected %s\\n\", (expected == NULL) ? \"NULL\" : expected);\n    printf(\"   found %s\\n\", (found == NULL) ? \"NULL\" : found);\n    return 0;\n  }\n  if (expected != NULL && 0 != strcmp(expected, found)) {\n    printf(\"\\n*** Error: %s in '%s' ***\\n\\n\", prop, m->name);\n    printf(\"expected '%s'\\n\", expected);\n    printf(\"   found '%s'\\n\", found);\n    return 0;\n  }\n  return 1;\n}\n\nstatic inline int\ncheck_num_eq (const struct message *m,\n              const char *prop,\n              int expected,\n              int found) {\n  if (expected != found) {\n    printf(\"\\n*** Error: %s in '%s' ***\\n\\n\", prop, m->name);\n    printf(\"expected %d\\n\", expected);\n    printf(\"   found %d\\n\", found);\n    return 0;\n  }\n  return 1;\n}\n\n#define MESSAGE_CHECK_STR_EQ(expected, found, prop) \\\n  if (!check_str_eq(expected, #prop, expected->prop, found->prop)) return 0\n\n#define MESSAGE_CHECK_NUM_EQ(expected, found, prop) \\\n  if (!check_num_eq(expected, #prop, expected->prop, found->prop)) return 0\n\n#define MESSAGE_CHECK_URL_EQ(u, expected, found, prop, fn)           \\\ndo {                                                                 \\\n  char ubuf[256];                                                    \\\n                                                                     \\\n  if ((u)->field_set & (1 << (fn))) {                                \\\n    memcpy(ubuf, (found)->request_url + (u)->field_data[(fn)].off,   \\\n      (u)->field_data[(fn)].len);                                    \\\n    ubuf[(u)->field_data[(fn)].len] = '\\0';                          \\\n  } else {                                                           \\\n    ubuf[0] = '\\0';                                                  \\\n  }                                                                  \\\n                                                                     \\\n  check_str_eq(expected, #prop, expected->prop, ubuf);               \\\n} while(0)\n\nint\nmessage_eq (int index, int connect, const struct message *expected)\n{\n  int i;\n  struct message *m = &messages[index];\n\n  MESSAGE_CHECK_NUM_EQ(expected, m, http_major);\n  MESSAGE_CHECK_NUM_EQ(expected, m, http_minor);\n  MESSAGE_CHECK_NUM_EQ(expected, m, content_length);\n\n  if (expected->type == HTTP_REQUEST) {\n    MESSAGE_CHECK_NUM_EQ(expected, m, method);\n  } else {\n    MESSAGE_CHECK_NUM_EQ(expected, m, status_code);\n    MESSAGE_CHECK_STR_EQ(expected, m, response_status);\n    assert(m->status_cb_called);\n  }\n\n  if (!connect) {\n    MESSAGE_CHECK_NUM_EQ(expected, m, should_keep_alive);\n    MESSAGE_CHECK_NUM_EQ(expected, m, message_complete_on_eof);\n  }\n\n  assert(m->message_begin_cb_called);\n  assert(m->headers_complete_cb_called);\n  assert(m->message_complete_cb_called);\n\n\n  MESSAGE_CHECK_STR_EQ(expected, m, request_url);\n\n  /* Check URL components; we can't do this w/ CONNECT since it doesn't\n   * send us a well-formed URL.\n   */\n  if (*m->request_url && m->method != HTTP_CONNECT) {\n    struct http_parser_url u;\n\n    if (http_parser_parse_url(m->request_url, strlen(m->request_url), 0, &u)) {\n      fprintf(stderr, \"\\n\\n*** failed to parse URL %s ***\\n\\n\",\n        m->request_url);\n      abort();\n    }\n\n    if (expected->host) {\n      MESSAGE_CHECK_URL_EQ(&u, expected, m, host, UF_HOST);\n    }\n\n    if (expected->userinfo) {\n      MESSAGE_CHECK_URL_EQ(&u, expected, m, userinfo, UF_USERINFO);\n    }\n\n    m->port = (u.field_set & (1 << UF_PORT)) ?\n      u.port : 0;\n\n    MESSAGE_CHECK_URL_EQ(&u, expected, m, query_string, UF_QUERY);\n    MESSAGE_CHECK_URL_EQ(&u, expected, m, fragment, UF_FRAGMENT);\n    MESSAGE_CHECK_URL_EQ(&u, expected, m, request_path, UF_PATH);\n    MESSAGE_CHECK_NUM_EQ(expected, m, port);\n  }\n\n  if (connect) {\n    check_num_eq(m, \"body_size\", 0, m->body_size);\n  } else if (expected->body_size) {\n    MESSAGE_CHECK_NUM_EQ(expected, m, body_size);\n  } else {\n    MESSAGE_CHECK_STR_EQ(expected, m, body);\n  }\n\n  if (connect) {\n    check_num_eq(m, \"num_chunks_complete\", 0, m->num_chunks_complete);\n  } else {\n    assert(m->num_chunks == m->num_chunks_complete);\n    MESSAGE_CHECK_NUM_EQ(expected, m, num_chunks_complete);\n    for (i = 0; i < m->num_chunks && i < MAX_CHUNKS; i++) {\n      MESSAGE_CHECK_NUM_EQ(expected, m, chunk_lengths[i]);\n    }\n  }\n\n  MESSAGE_CHECK_NUM_EQ(expected, m, num_headers);\n\n  int r;\n  for (i = 0; i < m->num_headers; i++) {\n    r = check_str_eq(expected, \"header field\", expected->headers[i][0], m->headers[i][0]);\n    if (!r) return 0;\n    r = check_str_eq(expected, \"header value\", expected->headers[i][1], m->headers[i][1]);\n    if (!r) return 0;\n  }\n\n  if (!connect) {\n    MESSAGE_CHECK_STR_EQ(expected, m, upgrade);\n  }\n\n  return 1;\n}\n\n/* Given a sequence of varargs messages, return the number of them that the\n * parser should successfully parse, taking into account that upgraded\n * messages prevent all subsequent messages from being parsed.\n */\nsize_t\ncount_parsed_messages(const size_t nmsgs, ...) {\n  size_t i;\n  va_list ap;\n\n  va_start(ap, nmsgs);\n\n  for (i = 0; i < nmsgs; i++) {\n    struct message *m = va_arg(ap, struct message *);\n\n    if (m->upgrade) {\n      va_end(ap);\n      return i + 1;\n    }\n  }\n\n  va_end(ap);\n  return nmsgs;\n}\n\n/* Given a sequence of bytes and the number of these that we were able to\n * parse, verify that upgrade bodies are correct.\n */\nvoid\nupgrade_message_fix(char *body, const size_t nread, const size_t nmsgs, ...) {\n  va_list ap;\n  size_t i;\n  size_t off = 0;\n\n  va_start(ap, nmsgs);\n\n  for (i = 0; i < nmsgs; i++) {\n    struct message *m = va_arg(ap, struct message *);\n\n    off += strlen(m->raw);\n\n    if (m->upgrade) {\n      off -= strlen(m->upgrade);\n\n      /* Check the portion of the response after its specified upgrade */\n      if (!check_str_eq(m, \"upgrade\", body + off, body + nread)) {\n        abort();\n      }\n\n      /* Fix up the response so that message_eq() will verify the beginning\n       * of the upgrade */\n      *(body + nread + strlen(m->upgrade)) = '\\0';\n      messages[num_messages -1 ].upgrade = body + nread;\n\n      va_end(ap);\n      return;\n    }\n  }\n\n  va_end(ap);\n  printf(\"\\n\\n*** Error: expected a message with upgrade ***\\n\");\n\n  abort();\n}\n\nstatic void\nprint_error (const char *raw, size_t error_location)\n{\n  fprintf(stderr, \"\\n*** %s ***\\n\\n\",\n          http_errno_description(HTTP_PARSER_ERRNO(&parser)));\n\n  int this_line = 0, char_len = 0;\n  size_t i, j, len = strlen(raw), error_location_line = 0;\n  for (i = 0; i < len; i++) {\n    if (i == error_location) this_line = 1;\n    switch (raw[i]) {\n      case '\\r':\n        char_len = 2;\n        fprintf(stderr, \"\\\\r\");\n        break;\n\n      case '\\n':\n        fprintf(stderr, \"\\\\n\\n\");\n\n        if (this_line) goto print;\n\n        error_location_line = 0;\n        continue;\n\n      default:\n        char_len = 1;\n        fputc(raw[i], stderr);\n        break;\n    }\n    if (!this_line) error_location_line += char_len;\n  }\n\n  fprintf(stderr, \"[eof]\\n\");\n\n print:\n  for (j = 0; j < error_location_line; j++) {\n    fputc(' ', stderr);\n  }\n  fprintf(stderr, \"^\\n\\nerror location: %u\\n\", (unsigned int)error_location);\n}\n\nvoid\ntest_preserve_data (void)\n{\n  char my_data[] = \"application-specific data\";\n  http_parser parser;\n  parser.data = my_data;\n  http_parser_init(&parser, HTTP_REQUEST);\n  if (parser.data != my_data) {\n    printf(\"\\n*** parser.data not preserved accross http_parser_init ***\\n\\n\");\n    abort();\n  }\n}\n\nstruct url_test {\n  const char *name;\n  const char *url;\n  int is_connect;\n  struct http_parser_url u;\n  int rv;\n};\n\nconst struct url_test url_tests[] =\n{ {.name=\"proxy request\"\n  ,.url=\"http://hostname/\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set=(1 << UF_SCHEMA) | (1 << UF_HOST) | (1 << UF_PATH)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  7,  8 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 15,  1 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"proxy request with port\"\n  ,.url=\"http://hostname:444/\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set=(1 << UF_SCHEMA) | (1 << UF_HOST) | (1 << UF_PORT) | (1 << UF_PATH)\n    ,.port=444\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  7,  8 } /* UF_HOST */\n      ,{ 16,  3 } /* UF_PORT */\n      ,{ 19,  1 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"CONNECT request\"\n  ,.url=\"hostname:443\"\n  ,.is_connect=1\n  ,.u=\n    {.field_set=(1 << UF_HOST) | (1 << UF_PORT)\n    ,.port=443\n    ,.field_data=\n      {{  0,  0 } /* UF_SCHEMA */\n      ,{  0,  8 } /* UF_HOST */\n      ,{  9,  3 } /* UF_PORT */\n      ,{  0,  0 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"CONNECT request but not connect\"\n  ,.url=\"hostname:443\"\n  ,.is_connect=0\n  ,.rv=1\n  }\n\n, {.name=\"proxy ipv6 request\"\n  ,.url=\"http://[1:2::3:4]/\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set=(1 << UF_SCHEMA) | (1 << UF_HOST) | (1 << UF_PATH)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  8,  8 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 17,  1 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"proxy ipv6 request with port\"\n  ,.url=\"http://[1:2::3:4]:67/\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set=(1 << UF_SCHEMA) | (1 << UF_HOST) | (1 << UF_PORT) | (1 << UF_PATH)\n    ,.port=67\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  8,  8 } /* UF_HOST */\n      ,{ 18,  2 } /* UF_PORT */\n      ,{ 20,  1 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"CONNECT ipv6 address\"\n  ,.url=\"[1:2::3:4]:443\"\n  ,.is_connect=1\n  ,.u=\n    {.field_set=(1 << UF_HOST) | (1 << UF_PORT)\n    ,.port=443\n    ,.field_data=\n      {{  0,  0 } /* UF_SCHEMA */\n      ,{  1,  8 } /* UF_HOST */\n      ,{ 11,  3 } /* UF_PORT */\n      ,{  0,  0 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"ipv4 in ipv6 address\"\n  ,.url=\"http://[2001:0000:0000:0000:0000:0000:1.9.1.1]/\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set=(1 << UF_SCHEMA) | (1 << UF_HOST) | (1 << UF_PATH)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  8, 37 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 46,  1 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"extra ? in query string\"\n  ,.url=\"http://a.tbcdn.cn/p/fp/2010c/??fp-header-min.css,fp-base-min.css,\"\n  \"fp-channel-min.css,fp-product-min.css,fp-mall-min.css,fp-category-min.css,\"\n  \"fp-sub-min.css,fp-gdp4p-min.css,fp-css3-min.css,fp-misc-min.css?t=20101022.css\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set=(1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH) | (1<<UF_QUERY)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  7, 10 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 17, 12 } /* UF_PATH */\n      ,{ 30,187 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"space URL encoded\"\n  ,.url=\"/toto.html?toto=a%20b\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set= (1<<UF_PATH) | (1<<UF_QUERY)\n    ,.port=0\n    ,.field_data=\n      {{  0,  0 } /* UF_SCHEMA */\n      ,{  0,  0 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{  0, 10 } /* UF_PATH */\n      ,{ 11, 10 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n\n, {.name=\"URL fragment\"\n  ,.url=\"/toto.html#titi\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set= (1<<UF_PATH) | (1<<UF_FRAGMENT)\n    ,.port=0\n    ,.field_data=\n      {{  0,  0 } /* UF_SCHEMA */\n      ,{  0,  0 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{  0, 10 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{ 11,  4 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"complex URL fragment\"\n  ,.url=\"http://www.webmasterworld.com/r.cgi?f=21&d=8405&url=\"\n    \"http://www.example.com/index.html?foo=bar&hello=world#midpage\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set= (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH) | (1<<UF_QUERY) |\\\n      (1<<UF_FRAGMENT)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  7, 22 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 29,  6 } /* UF_PATH */\n      ,{ 36, 69 } /* UF_QUERY */\n      ,{106,  7 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"complex URL from node js url parser doc\"\n  ,.url=\"http://host.com:8080/p/a/t/h?query=string#hash\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set= (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PORT) | (1<<UF_PATH) |\\\n      (1<<UF_QUERY) | (1<<UF_FRAGMENT)\n    ,.port=8080\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  7,  8 } /* UF_HOST */\n      ,{ 16,  4 } /* UF_PORT */\n      ,{ 20,  8 } /* UF_PATH */\n      ,{ 29, 12 } /* UF_QUERY */\n      ,{ 42,  4 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"complex URL with basic auth from node js url parser doc\"\n  ,.url=\"http://a:b@host.com:8080/p/a/t/h?query=string#hash\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set= (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PORT) | (1<<UF_PATH) |\\\n      (1<<UF_QUERY) | (1<<UF_FRAGMENT) | (1<<UF_USERINFO)\n    ,.port=8080\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{ 11,  8 } /* UF_HOST */\n      ,{ 20,  4 } /* UF_PORT */\n      ,{ 24,  8 } /* UF_PATH */\n      ,{ 33, 12 } /* UF_QUERY */\n      ,{ 46,  4 } /* UF_FRAGMENT */\n      ,{  7,  3 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"double @\"\n  ,.url=\"http://a:b@@hostname:443/\"\n  ,.is_connect=0\n  ,.rv=1\n  }\n\n, {.name=\"proxy empty host\"\n  ,.url=\"http://:443/\"\n  ,.is_connect=0\n  ,.rv=1\n  }\n\n, {.name=\"proxy empty port\"\n  ,.url=\"http://hostname:/\"\n  ,.is_connect=0\n  ,.rv=1\n  }\n\n, {.name=\"CONNECT with basic auth\"\n  ,.url=\"a:b@hostname:443\"\n  ,.is_connect=1\n  ,.rv=1\n  }\n\n, {.name=\"CONNECT empty host\"\n  ,.url=\":443\"\n  ,.is_connect=1\n  ,.rv=1\n  }\n\n, {.name=\"CONNECT empty port\"\n  ,.url=\"hostname:\"\n  ,.is_connect=1\n  ,.rv=1\n  }\n\n, {.name=\"CONNECT with extra bits\"\n  ,.url=\"hostname:443/\"\n  ,.is_connect=1\n  ,.rv=1\n  }\n\n, {.name=\"space in URL\"\n  ,.url=\"/foo bar/\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"proxy basic auth with space url encoded\"\n  ,.url=\"http://a%20:b@host.com/\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set= (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH) | (1<<UF_USERINFO)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{ 14,  8 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 22,  1 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  7,  6 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"carriage return in URL\"\n  ,.url=\"/foo\\rbar/\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"proxy double : in URL\"\n  ,.url=\"http://hostname::443/\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"proxy basic auth with double :\"\n  ,.url=\"http://a::b@host.com/\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set= (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH) | (1<<UF_USERINFO)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{ 12,  8 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 20,  1 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  7,  4 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"line feed in URL\"\n  ,.url=\"/foo\\nbar/\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"proxy empty basic auth\"\n  ,.url=\"http://@hostname/fo\"\n  ,.u=\n    {.field_set= (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  8,  8 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 16,  3 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n, {.name=\"proxy line feed in hostname\"\n  ,.url=\"http://host\\name/fo\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"proxy % in hostname\"\n  ,.url=\"http://host%name/fo\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"proxy ; in hostname\"\n  ,.url=\"http://host;ame/fo\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"proxy basic auth with unreservedchars\"\n  ,.url=\"http://a!;-_!=+$@host.com/\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set= (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH) | (1<<UF_USERINFO)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{ 17,  8 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 25,  1 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  7,  9 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"proxy only empty basic auth\"\n  ,.url=\"http://@/fo\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"proxy only basic auth\"\n  ,.url=\"http://toto@/fo\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"proxy emtpy hostname\"\n  ,.url=\"http:///fo\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"proxy = in URL\"\n  ,.url=\"http://host=ame/fo\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"ipv6 address with Zone ID\"\n  ,.url=\"http://[fe80::a%25eth0]/\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set= (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  8, 14 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 23,  1 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"ipv6 address with Zone ID, but '%' is not percent-encoded\"\n  ,.url=\"http://[fe80::a%eth0]/\"\n  ,.is_connect=0\n  ,.u=\n    {.field_set= (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH)\n    ,.port=0\n    ,.field_data=\n      {{  0,  4 } /* UF_SCHEMA */\n      ,{  8, 12 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{ 21,  1 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"ipv6 address ending with '%'\"\n  ,.url=\"http://[fe80::a%]/\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"ipv6 address with Zone ID including bad character\"\n  ,.url=\"http://[fe80::a%$HOME]/\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"just ipv6 Zone ID\"\n  ,.url=\"http://[%eth0]/\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"empty url\"\n  ,.url=\"\"\n  ,.is_connect=0\n  ,.rv=1\n  }\n\n, {.name=\"NULL url\"\n  ,.url=NULL\n  ,.is_connect=0\n  ,.rv=1\n  }\n\n, {.name=\"full of spaces url\"\n  ,.url=\"  \"\n  ,.is_connect=0\n  ,.rv=1\n  }\n\n#if HTTP_PARSER_STRICT\n\n, {.name=\"tab in URL\"\n  ,.url=\"/foo\\tbar/\"\n  ,.rv=1 /* s_dead */\n  }\n\n, {.name=\"form feed in URL\"\n  ,.url=\"/foo\\fbar/\"\n  ,.rv=1 /* s_dead */\n  }\n\n#else /* !HTTP_PARSER_STRICT */\n\n, {.name=\"tab in URL\"\n  ,.url=\"/foo\\tbar/\"\n  ,.u=\n    {.field_set=(1 << UF_PATH)\n    ,.field_data=\n      {{  0,  0 } /* UF_SCHEMA */\n      ,{  0,  0 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{  0,  9 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n\n, {.name=\"form feed in URL\"\n  ,.url=\"/foo\\fbar/\"\n  ,.u=\n    {.field_set=(1 << UF_PATH)\n    ,.field_data=\n      {{  0,  0 } /* UF_SCHEMA */\n      ,{  0,  0 } /* UF_HOST */\n      ,{  0,  0 } /* UF_PORT */\n      ,{  0,  9 } /* UF_PATH */\n      ,{  0,  0 } /* UF_QUERY */\n      ,{  0,  0 } /* UF_FRAGMENT */\n      ,{  0,  0 } /* UF_USERINFO */\n      }\n    }\n  ,.rv=0\n  }\n#endif\n};\n\nvoid\ndump_url (const char *url, const struct http_parser_url *u)\n{\n  unsigned int i;\n\n  printf(\"\\tfield_set: 0x%x, port: %u\\n\", u->field_set, u->port);\n  for (i = 0; i < UF_MAX; i++) {\n    if ((u->field_set & (1 << i)) == 0) {\n      printf(\"\\tfield_data[%u]: unset\\n\", i);\n      continue;\n    }\n\n    printf(\"\\tfield_data[%u]: off: %u len: %u part: \\\"%.*s\\n\\\"\",\n           i,\n           u->field_data[i].off,\n           u->field_data[i].len,\n           u->field_data[i].len,\n           url + u->field_data[i].off);\n  }\n}\n\nvoid\ntest_parse_url (void)\n{\n  struct http_parser_url u;\n  const struct url_test *test;\n  unsigned int i;\n  int rv;\n\n  for (i = 0; i < (sizeof(url_tests) / sizeof(url_tests[0])); i++) {\n    test = &url_tests[i];\n    memset(&u, 0, sizeof(u));\n\n    rv = http_parser_parse_url(test->url,\n                               test->url ? strlen(test->url) : 0,\n                               test->is_connect,\n                               &u);\n\n    if (test->rv == 0) {\n      if (rv != 0) {\n        printf(\"\\n*** http_parser_parse_url(\\\"%s\\\") \\\"%s\\\" test failed, \"\n               \"unexpected rv %d ***\\n\\n\", test->url, test->name, rv);\n        abort();\n      }\n\n      if (memcmp(&u, &test->u, sizeof(u)) != 0) {\n        printf(\"\\n*** http_parser_parse_url(\\\"%s\\\") \\\"%s\\\" failed ***\\n\",\n               test->url, test->name);\n\n        printf(\"target http_parser_url:\\n\");\n        dump_url(test->url, &test->u);\n        printf(\"result http_parser_url:\\n\");\n        dump_url(test->url, &u);\n\n        abort();\n      }\n    } else {\n      /* test->rv != 0 */\n      if (rv == 0) {\n        printf(\"\\n*** http_parser_parse_url(\\\"%s\\\") \\\"%s\\\" test failed, \"\n               \"unexpected rv %d ***\\n\\n\", test->url, test->name, rv);\n        abort();\n      }\n    }\n  }\n}\n\nvoid\ntest_method_str (void)\n{\n  assert(0 == strcmp(\"GET\", http_method_str(HTTP_GET)));\n  assert(0 == strcmp(\"<unknown>\", http_method_str(1337)));\n}\n\nvoid\ntest_status_str (void)\n{\n  assert(0 == strcmp(\"OK\", http_status_str(HTTP_STATUS_OK)));\n  assert(0 == strcmp(\"Not Found\", http_status_str(HTTP_STATUS_NOT_FOUND)));\n  assert(0 == strcmp(\"<unknown>\", http_status_str(1337)));\n}\n\nvoid\ntest_message (const struct message *message)\n{\n  size_t raw_len = strlen(message->raw);\n  size_t msg1len;\n  for (msg1len = 0; msg1len < raw_len; msg1len++) {\n    parser_init(message->type);\n    if (message->allow_chunked_length) {\n      parser.allow_chunked_length = 1;\n    }\n\n    size_t read;\n    const char *msg1 = message->raw;\n    const char *msg2 = msg1 + msg1len;\n    size_t msg2len = raw_len - msg1len;\n\n    if (msg1len) {\n      assert(num_messages == 0);\n      messages[0].headers_complete_cb_called = FALSE;\n\n      read = parse(msg1, msg1len);\n\n      if (!messages[0].headers_complete_cb_called && parser.nread != read) {\n        assert(parser.nread == read);\n        print_error(msg1, read);\n        abort();\n      }\n\n      if (message->upgrade && parser.upgrade && num_messages > 0) {\n        messages[num_messages - 1].upgrade = msg1 + read;\n        goto test;\n      }\n\n      if (read != msg1len) {\n        print_error(msg1, read);\n        abort();\n      }\n    }\n\n\n    read = parse(msg2, msg2len);\n\n    if (message->upgrade && parser.upgrade) {\n      messages[num_messages - 1].upgrade = msg2 + read;\n      goto test;\n    }\n\n    if (read != msg2len) {\n      print_error(msg2, read);\n      abort();\n    }\n\n    read = parse(NULL, 0);\n\n    if (read != 0) {\n      print_error(message->raw, read);\n      abort();\n    }\n\n  test:\n\n    if (num_messages != 1) {\n      printf(\"\\n*** num_messages != 1 after testing '%s' ***\\n\\n\", message->name);\n      abort();\n    }\n\n    if(!message_eq(0, 0, message)) abort();\n  }\n}\n\nvoid\ntest_message_count_body (const struct message *message)\n{\n  parser_init(message->type);\n\n  size_t read;\n  size_t l = strlen(message->raw);\n  size_t i, toread;\n  size_t chunk = 4024;\n\n  for (i = 0; i < l; i+= chunk) {\n    toread = MIN(l-i, chunk);\n    read = parse_count_body(message->raw + i, toread);\n    if (read != toread) {\n      print_error(message->raw, read);\n      abort();\n    }\n  }\n\n\n  read = parse_count_body(NULL, 0);\n  if (read != 0) {\n    print_error(message->raw, read);\n    abort();\n  }\n\n  if (num_messages != 1) {\n    printf(\"\\n*** num_messages != 1 after testing '%s' ***\\n\\n\", message->name);\n    abort();\n  }\n\n  if(!message_eq(0, 0, message)) abort();\n}\n\nvoid\ntest_simple_type (const char *buf,\n                  enum http_errno err_expected,\n                  enum http_parser_type type)\n{\n  parser_init(type);\n\n  enum http_errno err;\n\n  parse(buf, strlen(buf));\n  err = HTTP_PARSER_ERRNO(&parser);\n  parse(NULL, 0);\n\n  /* In strict mode, allow us to pass with an unexpected HPE_STRICT as\n   * long as the caller isn't expecting success.\n   */\n#if HTTP_PARSER_STRICT\n  if (err_expected != err && err_expected != HPE_OK && err != HPE_STRICT) {\n#else\n  if (err_expected != err) {\n#endif\n    fprintf(stderr, \"\\n*** test_simple expected %s, but saw %s ***\\n\\n%s\\n\",\n        http_errno_name(err_expected), http_errno_name(err), buf);\n    abort();\n  }\n}\n\nvoid\ntest_simple (const char *buf, enum http_errno err_expected)\n{\n  test_simple_type(buf, err_expected, HTTP_REQUEST);\n}\n\nvoid\ntest_invalid_header_content (int req, const char* str)\n{\n  http_parser parser;\n  http_parser_init(&parser, req ? HTTP_REQUEST : HTTP_RESPONSE);\n  size_t parsed;\n  const char *buf;\n  buf = req ?\n    \"GET / HTTP/1.1\\r\\n\" :\n    \"HTTP/1.1 200 OK\\r\\n\";\n  parsed = http_parser_execute(&parser, &settings_null, buf, strlen(buf));\n  assert(parsed == strlen(buf));\n\n  buf = str;\n  size_t buflen = strlen(buf);\n\n  parsed = http_parser_execute(&parser, &settings_null, buf, buflen);\n  if (parsed != buflen) {\n    assert(HTTP_PARSER_ERRNO(&parser) == HPE_INVALID_HEADER_TOKEN);\n    return;\n  }\n\n  fprintf(stderr,\n          \"\\n*** Error expected but none in invalid header content test ***\\n\");\n  abort();\n}\n\nvoid\ntest_invalid_header_field_content_error (int req)\n{\n  test_invalid_header_content(req, \"Foo: F\\01ailure\");\n  test_invalid_header_content(req, \"Foo: B\\02ar\");\n}\n\nvoid\ntest_invalid_header_field (int req, const char* str)\n{\n  http_parser parser;\n  http_parser_init(&parser, req ? HTTP_REQUEST : HTTP_RESPONSE);\n  size_t parsed;\n  const char *buf;\n  buf = req ?\n    \"GET / HTTP/1.1\\r\\n\" :\n    \"HTTP/1.1 200 OK\\r\\n\";\n  parsed = http_parser_execute(&parser, &settings_null, buf, strlen(buf));\n  assert(parsed == strlen(buf));\n\n  buf = str;\n  size_t buflen = strlen(buf);\n\n  parsed = http_parser_execute(&parser, &settings_null, buf, buflen);\n  if (parsed != buflen) {\n    assert(HTTP_PARSER_ERRNO(&parser) == HPE_INVALID_HEADER_TOKEN);\n    return;\n  }\n\n  fprintf(stderr,\n          \"\\n*** Error expected but none in invalid header token test ***\\n\");\n  abort();\n}\n\nvoid\ntest_invalid_header_field_token_error (int req)\n{\n  test_invalid_header_field(req, \"Fo@: Failure\");\n  test_invalid_header_field(req, \"Foo\\01\\test: Bar\");\n}\n\nvoid\ntest_double_content_length_error (int req)\n{\n  http_parser parser;\n  http_parser_init(&parser, req ? HTTP_REQUEST : HTTP_RESPONSE);\n  size_t parsed;\n  const char *buf;\n  buf = req ?\n    \"GET / HTTP/1.1\\r\\n\" :\n    \"HTTP/1.1 200 OK\\r\\n\";\n  parsed = http_parser_execute(&parser, &settings_null, buf, strlen(buf));\n  assert(parsed == strlen(buf));\n\n  buf = \"Content-Length: 0\\r\\nContent-Length: 1\\r\\n\\r\\n\";\n  size_t buflen = strlen(buf);\n\n  parsed = http_parser_execute(&parser, &settings_null, buf, buflen);\n  if (parsed != buflen) {\n    assert(HTTP_PARSER_ERRNO(&parser) == HPE_UNEXPECTED_CONTENT_LENGTH);\n    return;\n  }\n\n  fprintf(stderr,\n          \"\\n*** Error expected but none in double content-length test ***\\n\");\n  abort();\n}\n\nvoid\ntest_chunked_content_length_error (int req)\n{\n  http_parser parser;\n  http_parser_init(&parser, req ? HTTP_REQUEST : HTTP_RESPONSE);\n  size_t parsed;\n  const char *buf;\n  buf = req ?\n    \"GET / HTTP/1.1\\r\\n\" :\n    \"HTTP/1.1 200 OK\\r\\n\";\n  parsed = http_parser_execute(&parser, &settings_null, buf, strlen(buf));\n  assert(parsed == strlen(buf));\n\n  buf = \"Transfer-Encoding: anything\\r\\nContent-Length: 1\\r\\n\\r\\n\";\n  size_t buflen = strlen(buf);\n\n  parsed = http_parser_execute(&parser, &settings_null, buf, buflen);\n  if (parsed != buflen) {\n    assert(HTTP_PARSER_ERRNO(&parser) == HPE_UNEXPECTED_CONTENT_LENGTH);\n    return;\n  }\n\n  fprintf(stderr,\n          \"\\n*** Error expected but none in chunked content-length test ***\\n\");\n  abort();\n}\n\nvoid\ntest_header_cr_no_lf_error (int req)\n{\n  http_parser parser;\n  http_parser_init(&parser, req ? HTTP_REQUEST : HTTP_RESPONSE);\n  size_t parsed;\n  const char *buf;\n  buf = req ?\n    \"GET / HTTP/1.1\\r\\n\" :\n    \"HTTP/1.1 200 OK\\r\\n\";\n  parsed = http_parser_execute(&parser, &settings_null, buf, strlen(buf));\n  assert(parsed == strlen(buf));\n\n  buf = \"Foo: 1\\rBar: 1\\r\\n\\r\\n\";\n  size_t buflen = strlen(buf);\n\n  parsed = http_parser_execute(&parser, &settings_null, buf, buflen);\n  if (parsed != buflen) {\n    assert(HTTP_PARSER_ERRNO(&parser) == HPE_LF_EXPECTED);\n    return;\n  }\n\n  fprintf(stderr,\n          \"\\n*** Error expected but none in header whitespace test ***\\n\");\n  abort();\n}\n\nvoid\ntest_no_overflow_parse_url (void)\n{\n  int rv;\n  struct http_parser_url u;\n\n  http_parser_url_init(&u);\n  rv = http_parser_parse_url(\"http://example.com:8001\", 22, 0, &u);\n\n  if (rv != 0) {\n    fprintf(stderr,\n            \"\\n*** test_no_overflow_parse_url invalid return value=%d\\n\",\n            rv);\n    abort();\n  }\n\n  if (u.port != 800) {\n    fprintf(stderr,\n            \"\\n*** test_no_overflow_parse_url invalid port number=%d\\n\",\n            u.port);\n    abort();\n  }\n}\n\nvoid\ntest_header_overflow_error (int req)\n{\n  http_parser parser;\n  http_parser_init(&parser, req ? HTTP_REQUEST : HTTP_RESPONSE);\n  size_t parsed;\n  const char *buf;\n  buf = req ? \"GET / HTTP/1.1\\r\\n\" : \"HTTP/1.0 200 OK\\r\\n\";\n  parsed = http_parser_execute(&parser, &settings_null, buf, strlen(buf));\n  assert(parsed == strlen(buf));\n\n  buf = \"header-key: header-value\\r\\n\";\n  size_t buflen = strlen(buf);\n\n  int i;\n  for (i = 0; i < 10000; i++) {\n    parsed = http_parser_execute(&parser, &settings_null, buf, buflen);\n    if (parsed != buflen) {\n      //fprintf(stderr, \"error found on iter %d\\n\", i);\n      assert(HTTP_PARSER_ERRNO(&parser) == HPE_HEADER_OVERFLOW);\n      return;\n    }\n  }\n\n  fprintf(stderr, \"\\n*** Error expected but none in header overflow test ***\\n\");\n  abort();\n}\n\n\nvoid\ntest_header_nread_value ()\n{\n  http_parser parser;\n  http_parser_init(&parser, HTTP_REQUEST);\n  size_t parsed;\n  const char *buf;\n  buf = \"GET / HTTP/1.1\\r\\nheader: value\\nhdr: value\\r\\n\";\n  parsed = http_parser_execute(&parser, &settings_null, buf, strlen(buf));\n  assert(parsed == strlen(buf));\n\n  assert(parser.nread == strlen(buf));\n}\n\n\nstatic void\ntest_content_length_overflow (const char *buf, size_t buflen, int expect_ok)\n{\n  http_parser parser;\n  http_parser_init(&parser, HTTP_RESPONSE);\n  http_parser_execute(&parser, &settings_null, buf, buflen);\n\n  if (expect_ok)\n    assert(HTTP_PARSER_ERRNO(&parser) == HPE_OK);\n  else\n    assert(HTTP_PARSER_ERRNO(&parser) == HPE_INVALID_CONTENT_LENGTH);\n}\n\nvoid\ntest_header_content_length_overflow_error (void)\n{\n#define X(size)                                                               \\\n  \"HTTP/1.1 200 OK\\r\\n\"                                                       \\\n  \"Content-Length: \" #size \"\\r\\n\"                                             \\\n  \"\\r\\n\"\n  const char a[] = X(1844674407370955160);  /* 2^64 / 10 - 1 */\n  const char b[] = X(18446744073709551615); /* 2^64-1 */\n  const char c[] = X(18446744073709551616); /* 2^64   */\n#undef X\n  test_content_length_overflow(a, sizeof(a) - 1, 1); /* expect ok      */\n  test_content_length_overflow(b, sizeof(b) - 1, 0); /* expect failure */\n  test_content_length_overflow(c, sizeof(c) - 1, 0); /* expect failure */\n}\n\nvoid\ntest_chunk_content_length_overflow_error (void)\n{\n#define X(size)                                                               \\\n    \"HTTP/1.1 200 OK\\r\\n\"                                                     \\\n    \"Transfer-Encoding: chunked\\r\\n\"                                          \\\n    \"\\r\\n\"                                                                    \\\n    #size \"\\r\\n\"                                                              \\\n    \"...\"\n  const char a[] = X(FFFFFFFFFFFFFFE);   /* 2^64 / 16 - 1 */\n  const char b[] = X(FFFFFFFFFFFFFFFF);  /* 2^64-1 */\n  const char c[] = X(10000000000000000); /* 2^64   */\n#undef X\n  test_content_length_overflow(a, sizeof(a) - 1, 1); /* expect ok      */\n  test_content_length_overflow(b, sizeof(b) - 1, 0); /* expect failure */\n  test_content_length_overflow(c, sizeof(c) - 1, 0); /* expect failure */\n}\n\nvoid\ntest_no_overflow_long_body (int req, size_t length)\n{\n  http_parser parser;\n  http_parser_init(&parser, req ? HTTP_REQUEST : HTTP_RESPONSE);\n  size_t parsed;\n  size_t i;\n  char buf1[3000];\n  size_t buf1len = sprintf(buf1, \"%s\\r\\nConnection: Keep-Alive\\r\\nContent-Length: %lu\\r\\n\\r\\n\",\n      req ? \"POST / HTTP/1.0\" : \"HTTP/1.0 200 OK\", (unsigned long)length);\n  parsed = http_parser_execute(&parser, &settings_null, buf1, buf1len);\n  if (parsed != buf1len)\n    goto err;\n\n  for (i = 0; i < length; i++) {\n    char foo = 'a';\n    parsed = http_parser_execute(&parser, &settings_null, &foo, 1);\n    if (parsed != 1)\n      goto err;\n  }\n\n  parsed = http_parser_execute(&parser, &settings_null, buf1, buf1len);\n  if (parsed != buf1len) goto err;\n  return;\n\n err:\n  fprintf(stderr,\n          \"\\n*** error in test_no_overflow_long_body %s of length %lu ***\\n\",\n          req ? \"REQUEST\" : \"RESPONSE\",\n          (unsigned long)length);\n  abort();\n}\n\nvoid\ntest_multiple3 (const struct message *r1, const struct message *r2, const struct message *r3)\n{\n  int message_count = count_parsed_messages(3, r1, r2, r3);\n\n  char total[ strlen(r1->raw)\n            + strlen(r2->raw)\n            + strlen(r3->raw)\n            + 1\n            ];\n  total[0] = '\\0';\n\n  strcat(total, r1->raw);\n  strcat(total, r2->raw);\n  strcat(total, r3->raw);\n\n  parser_init(r1->type);\n  if (r1->allow_chunked_length ||\n      r2->allow_chunked_length ||\n      r3->allow_chunked_length) {\n    parser.allow_chunked_length = 1;\n  }\n\n  size_t read;\n\n  read = parse(total, strlen(total));\n\n  if (parser.upgrade) {\n    upgrade_message_fix(total, read, 3, r1, r2, r3);\n    goto test;\n  }\n\n  if (read != strlen(total)) {\n    print_error(total, read);\n    abort();\n  }\n\n  read = parse(NULL, 0);\n\n  if (read != 0) {\n    print_error(total, read);\n    abort();\n  }\n\ntest:\n\n  if (message_count != num_messages) {\n    fprintf(stderr, \"\\n\\n*** Parser didn't see 3 messages only %d *** \\n\", num_messages);\n    abort();\n  }\n\n  if (!message_eq(0, 0, r1)) abort();\n  if (message_count > 1 && !message_eq(1, 0, r2)) abort();\n  if (message_count > 2 && !message_eq(2, 0, r3)) abort();\n}\n\n/* SCAN through every possible breaking to make sure the\n * parser can handle getting the content in any chunks that\n * might come from the socket\n */\nvoid\ntest_scan (const struct message *r1, const struct message *r2, const struct message *r3)\n{\n  char total[80*1024] = \"\\0\";\n  char buf1[80*1024] = \"\\0\";\n  char buf2[80*1024] = \"\\0\";\n  char buf3[80*1024] = \"\\0\";\n\n  strcat(total, r1->raw);\n  strcat(total, r2->raw);\n  strcat(total, r3->raw);\n\n  size_t read;\n\n  int total_len = strlen(total);\n\n  int total_ops = 2 * (total_len - 1) * (total_len - 2) / 2;\n  int ops = 0 ;\n\n  size_t buf1_len, buf2_len, buf3_len;\n  int message_count = count_parsed_messages(3, r1, r2, r3);\n\n  int i,j,type_both;\n  for (type_both = 0; type_both < 2; type_both ++ ) {\n    for (j = 2; j < total_len; j ++ ) {\n      for (i = 1; i < j; i ++ ) {\n\n        if (ops % 1000 == 0)  {\n          printf(\"\\b\\b\\b\\b%3.0f%%\", 100 * (float)ops /(float)total_ops);\n          fflush(stdout);\n        }\n        ops += 1;\n\n        parser_init(type_both ? HTTP_BOTH : r1->type);\n\n        buf1_len = i;\n        strlncpy(buf1, sizeof(buf1), total, buf1_len);\n        buf1[buf1_len] = 0;\n\n        buf2_len = j - i;\n        strlncpy(buf2, sizeof(buf1), total+i, buf2_len);\n        buf2[buf2_len] = 0;\n\n        buf3_len = total_len - j;\n        strlncpy(buf3, sizeof(buf1), total+j, buf3_len);\n        buf3[buf3_len] = 0;\n\n        assert(num_messages == 0);\n        messages[0].headers_complete_cb_called = FALSE;\n\n        read = parse(buf1, buf1_len);\n\n        if (!messages[0].headers_complete_cb_called && parser.nread != read) {\n          print_error(buf1, read);\n          goto error;\n        }\n\n        if (parser.upgrade) goto test;\n\n        if (read != buf1_len) {\n          print_error(buf1, read);\n          goto error;\n        }\n\n        read += parse(buf2, buf2_len);\n\n        if (parser.upgrade) goto test;\n\n        if (read != buf1_len + buf2_len) {\n          print_error(buf2, read);\n          goto error;\n        }\n\n        read += parse(buf3, buf3_len);\n\n        if (parser.upgrade) goto test;\n\n        if (read != buf1_len + buf2_len + buf3_len) {\n          print_error(buf3, read);\n          goto error;\n        }\n\n        parse(NULL, 0);\n\ntest:\n        if (parser.upgrade) {\n          upgrade_message_fix(total, read, 3, r1, r2, r3);\n        }\n\n        if (message_count != num_messages) {\n          fprintf(stderr, \"\\n\\nParser didn't see %d messages only %d\\n\",\n            message_count, num_messages);\n          goto error;\n        }\n\n        if (!message_eq(0, 0, r1)) {\n          fprintf(stderr, \"\\n\\nError matching messages[0] in test_scan.\\n\");\n          goto error;\n        }\n\n        if (message_count > 1 && !message_eq(1, 0, r2)) {\n          fprintf(stderr, \"\\n\\nError matching messages[1] in test_scan.\\n\");\n          goto error;\n        }\n\n        if (message_count > 2 && !message_eq(2, 0, r3)) {\n          fprintf(stderr, \"\\n\\nError matching messages[2] in test_scan.\\n\");\n          goto error;\n        }\n      }\n    }\n  }\n  puts(\"\\b\\b\\b\\b100%\");\n  return;\n\n error:\n  fprintf(stderr, \"i=%d  j=%d\\n\", i, j);\n  fprintf(stderr, \"buf1 (%u) %s\\n\\n\", (unsigned int)buf1_len, buf1);\n  fprintf(stderr, \"buf2 (%u) %s\\n\\n\", (unsigned int)buf2_len , buf2);\n  fprintf(stderr, \"buf3 (%u) %s\\n\", (unsigned int)buf3_len, buf3);\n  abort();\n}\n\n// user required to free the result\n// string terminated by \\0\nchar *\ncreate_large_chunked_message (int body_size_in_kb, const char* headers)\n{\n  int i;\n  size_t wrote = 0;\n  size_t headers_len = strlen(headers);\n  size_t bufsize = headers_len + (5+1024+2)*body_size_in_kb + 6;\n  char * buf = malloc(bufsize);\n\n  memcpy(buf, headers, headers_len);\n  wrote += headers_len;\n\n  for (i = 0; i < body_size_in_kb; i++) {\n    // write 1kb chunk into the body.\n    memcpy(buf + wrote, \"400\\r\\n\", 5);\n    wrote += 5;\n    memset(buf + wrote, 'C', 1024);\n    wrote += 1024;\n    strcpy(buf + wrote, \"\\r\\n\");\n    wrote += 2;\n  }\n\n  memcpy(buf + wrote, \"0\\r\\n\\r\\n\", 6);\n  wrote += 6;\n  assert(wrote == bufsize);\n\n  return buf;\n}\n\n/* Verify that we can pause parsing at any of the bytes in the\n * message and still get the result that we're expecting. */\nvoid\ntest_message_pause (const struct message *msg)\n{\n  char *buf = (char*) msg->raw;\n  size_t buflen = strlen(msg->raw);\n  size_t nread;\n\n  parser_init(msg->type);\n  if (msg->allow_chunked_length) {\n    parser.allow_chunked_length = 1;\n  }\n\n  do {\n    nread = parse_pause(buf, buflen);\n\n    // We can only set the upgrade buffer once we've gotten our message\n    // completion callback.\n    if (messages[0].message_complete_cb_called &&\n        msg->upgrade &&\n        parser.upgrade) {\n      messages[0].upgrade = buf + nread;\n      goto test;\n    }\n\n    if (nread < buflen) {\n\n      // Not much do to if we failed a strict-mode check\n      if (HTTP_PARSER_ERRNO(&parser) == HPE_STRICT) {\n        return;\n      }\n\n      assert (HTTP_PARSER_ERRNO(&parser) == HPE_PAUSED);\n    }\n\n    buf += nread;\n    buflen -= nread;\n    http_parser_pause(&parser, 0);\n  } while (buflen > 0);\n\n  nread = parse_pause(NULL, 0);\n  assert (nread == 0);\n\ntest:\n  if (num_messages != 1) {\n    printf(\"\\n*** num_messages != 1 after testing '%s' ***\\n\\n\", msg->name);\n    abort();\n  }\n\n  if(!message_eq(0, 0, msg)) abort();\n}\n\n/* Verify that body and next message won't be parsed in responses to CONNECT */\nvoid\ntest_message_connect (const struct message *msg)\n{\n  char *buf = (char*) msg->raw;\n  size_t buflen = strlen(msg->raw);\n\n  parser_init(msg->type);\n\n  parse_connect(buf, buflen);\n\n  if (num_messages != 1) {\n    printf(\"\\n*** num_messages != 1 after testing '%s' ***\\n\\n\", msg->name);\n    abort();\n  }\n\n  if(!message_eq(0, 1, msg)) abort();\n}\n\nint\nmain (void)\n{\n  unsigned i, j, k;\n  unsigned long version;\n  unsigned major;\n  unsigned minor;\n  unsigned patch;\n\n  version = http_parser_version();\n  major = (version >> 16) & 255;\n  minor = (version >> 8) & 255;\n  patch = version & 255;\n  printf(\"http_parser v%u.%u.%u (0x%06lx)\\n\", major, minor, patch, version);\n\n  printf(\"sizeof(http_parser) = %u\\n\", (unsigned int)sizeof(http_parser));\n\n#if defined(__i386__) || defined(__x86_64__)\n  /* Should be 32 on both 32 bits and 64 bits x86 because of struct padding,\n   * see https://github.com/nodejs/http-parser/issues/507.\n   */\n  assert(sizeof(http_parser) == 32);\n#endif\n\n  //// API\n  test_preserve_data();\n  test_parse_url();\n  test_method_str();\n  test_status_str();\n\n  //// NREAD\n  test_header_nread_value();\n\n  //// OVERFLOW CONDITIONS\n  test_no_overflow_parse_url();\n\n  test_header_overflow_error(HTTP_REQUEST);\n  test_no_overflow_long_body(HTTP_REQUEST, 1000);\n  test_no_overflow_long_body(HTTP_REQUEST, 100000);\n\n  test_header_overflow_error(HTTP_RESPONSE);\n  test_no_overflow_long_body(HTTP_RESPONSE, 1000);\n  test_no_overflow_long_body(HTTP_RESPONSE, 100000);\n\n  test_header_content_length_overflow_error();\n  test_chunk_content_length_overflow_error();\n\n  //// HEADER FIELD CONDITIONS\n  test_double_content_length_error(HTTP_REQUEST);\n  test_chunked_content_length_error(HTTP_REQUEST);\n  test_header_cr_no_lf_error(HTTP_REQUEST);\n  test_invalid_header_field_token_error(HTTP_REQUEST);\n  test_invalid_header_field_content_error(HTTP_REQUEST);\n  test_double_content_length_error(HTTP_RESPONSE);\n  test_chunked_content_length_error(HTTP_RESPONSE);\n  test_header_cr_no_lf_error(HTTP_RESPONSE);\n  test_invalid_header_field_token_error(HTTP_RESPONSE);\n  test_invalid_header_field_content_error(HTTP_RESPONSE);\n\n  test_simple_type(\n      \"POST / HTTP/1.1\\r\\n\"\n      \"Content-Length:\\r\\n\"  // empty\n      \"\\r\\n\",\n      HPE_INVALID_CONTENT_LENGTH,\n      HTTP_REQUEST);\n\n  test_simple_type(\n      \"POST / HTTP/1.1\\r\\n\"\n      \"Content-Length:  42 \\r\\n\"  // Note the surrounding whitespace.\n      \"\\r\\n\",\n      HPE_OK,\n      HTTP_REQUEST);\n\n  test_simple_type(\n      \"POST / HTTP/1.1\\r\\n\"\n      \"Content-Length: 4 2\\r\\n\"\n      \"\\r\\n\",\n      HPE_INVALID_CONTENT_LENGTH,\n      HTTP_REQUEST);\n\n  test_simple_type(\n      \"POST / HTTP/1.1\\r\\n\"\n      \"Content-Length: 13 37\\r\\n\"\n      \"\\r\\n\",\n      HPE_INVALID_CONTENT_LENGTH,\n      HTTP_REQUEST);\n\n  test_simple_type(\n      \"POST / HTTP/1.1\\r\\n\"\n      \"Content-Length:  42\\r\\n\"\n      \" Hello world!\\r\\n\",\n      HPE_INVALID_CONTENT_LENGTH,\n      HTTP_REQUEST);\n\n  test_simple_type(\n      \"POST / HTTP/1.1\\r\\n\"\n      \"Content-Length:  42\\r\\n\"\n      \" \\r\\n\",\n      HPE_OK,\n      HTTP_REQUEST);\n\n  //// RESPONSES\n\n  test_simple_type(\"HTP/1.1 200 OK\\r\\n\\r\\n\", HPE_INVALID_VERSION, HTTP_RESPONSE);\n  test_simple_type(\"HTTP/01.1 200 OK\\r\\n\\r\\n\", HPE_INVALID_VERSION, HTTP_RESPONSE);\n  test_simple_type(\"HTTP/11.1 200 OK\\r\\n\\r\\n\", HPE_INVALID_VERSION, HTTP_RESPONSE);\n  test_simple_type(\"HTTP/1.01 200 OK\\r\\n\\r\\n\", HPE_INVALID_VERSION, HTTP_RESPONSE);\n  test_simple_type(\"HTTP/1.1\\t200 OK\\r\\n\\r\\n\", HPE_INVALID_VERSION, HTTP_RESPONSE);\n  test_simple_type(\"\\rHTTP/1.1\\t200 OK\\r\\n\\r\\n\", HPE_INVALID_VERSION, HTTP_RESPONSE);\n\n  for (i = 0; i < ARRAY_SIZE(responses); i++) {\n    test_message(&responses[i]);\n  }\n\n  for (i = 0; i < ARRAY_SIZE(responses); i++) {\n    test_message_pause(&responses[i]);\n  }\n\n  for (i = 0; i < ARRAY_SIZE(responses); i++) {\n    test_message_connect(&responses[i]);\n  }\n\n  for (i = 0; i < ARRAY_SIZE(responses); i++) {\n    if (!responses[i].should_keep_alive) continue;\n    for (j = 0; j < ARRAY_SIZE(responses); j++) {\n      if (!responses[j].should_keep_alive) continue;\n      for (k = 0; k < ARRAY_SIZE(responses); k++) {\n        test_multiple3(&responses[i], &responses[j], &responses[k]);\n      }\n    }\n  }\n\n  test_message_count_body(&responses[NO_HEADERS_NO_BODY_404]);\n  test_message_count_body(&responses[TRAILING_SPACE_ON_CHUNKED_BODY]);\n\n  // test very large chunked response\n  {\n    char * msg = create_large_chunked_message(31337,\n      \"HTTP/1.0 200 OK\\r\\n\"\n      \"Transfer-Encoding: chunked\\r\\n\"\n      \"Content-Type: text/plain\\r\\n\"\n      \"\\r\\n\");\n    struct message large_chunked =\n      {.name= \"large chunked\"\n      ,.type= HTTP_RESPONSE\n      ,.raw= msg\n      ,.should_keep_alive= FALSE\n      ,.message_complete_on_eof= FALSE\n      ,.http_major= 1\n      ,.http_minor= 0\n      ,.status_code= 200\n      ,.response_status= \"OK\"\n      ,.content_length= -1\n      ,.num_headers= 2\n      ,.headers=\n        { { \"Transfer-Encoding\", \"chunked\" }\n        , { \"Content-Type\", \"text/plain\" }\n        }\n      ,.body_size= 31337*1024\n      ,.num_chunks_complete= 31338\n      };\n    for (i = 0; i < MAX_CHUNKS; i++) {\n      large_chunked.chunk_lengths[i] = 1024;\n    }\n    test_message_count_body(&large_chunked);\n    free(msg);\n  }\n\n\n\n  printf(\"response scan 1/2      \");\n  test_scan( &responses[TRAILING_SPACE_ON_CHUNKED_BODY]\n           , &responses[NO_BODY_HTTP10_KA_204]\n           , &responses[NO_REASON_PHRASE]\n           );\n\n  printf(\"response scan 2/2      \");\n  test_scan( &responses[BONJOUR_MADAME_FR]\n           , &responses[UNDERSTORE_HEADER_KEY]\n           , &responses[NO_CARRIAGE_RET]\n           );\n\n  puts(\"responses okay\");\n\n\n  /// REQUESTS\n\n  test_simple(\"GET / IHTTP/1.0\\r\\n\\r\\n\", HPE_INVALID_CONSTANT);\n  test_simple(\"GET / ICE/1.0\\r\\n\\r\\n\", HPE_INVALID_CONSTANT);\n  test_simple(\"GET / HTP/1.1\\r\\n\\r\\n\", HPE_INVALID_VERSION);\n  test_simple(\"GET / HTTP/01.1\\r\\n\\r\\n\", HPE_INVALID_VERSION);\n  test_simple(\"GET / HTTP/11.1\\r\\n\\r\\n\", HPE_INVALID_VERSION);\n  test_simple(\"GET / HTTP/1.01\\r\\n\\r\\n\", HPE_INVALID_VERSION);\n\n  test_simple(\"GET / HTTP/1.0\\r\\nHello: w\\1rld\\r\\n\\r\\n\", HPE_INVALID_HEADER_TOKEN);\n  test_simple(\"GET / HTTP/1.0\\r\\nHello: woooo\\2rld\\r\\n\\r\\n\", HPE_INVALID_HEADER_TOKEN);\n\n  // Extended characters - see nodejs/test/parallel/test-http-headers-obstext.js\n  test_simple(\"GET / HTTP/1.1\\r\\n\"\n              \"Test: Düsseldorf\\r\\n\",\n              HPE_OK);\n\n  // Well-formed but incomplete\n  test_simple(\"GET / HTTP/1.1\\r\\n\"\n              \"Content-Type: text/plain\\r\\n\"\n              \"Content-Length: 6\\r\\n\"\n              \"\\r\\n\"\n              \"fooba\",\n              HPE_OK);\n\n  // Unknown Transfer-Encoding in request\n  test_simple(\"GET / HTTP/1.1\\r\\n\"\n              \"Transfer-Encoding: unknown\\r\\n\"\n              \"\\r\\n\",\n              HPE_INVALID_TRANSFER_ENCODING);\n\n  static const char *all_methods[] = {\n    \"DELETE\",\n    \"GET\",\n    \"HEAD\",\n    \"POST\",\n    \"PUT\",\n    //\"CONNECT\", //CONNECT can't be tested like other methods, it's a tunnel\n    \"OPTIONS\",\n    \"TRACE\",\n    \"COPY\",\n    \"LOCK\",\n    \"MKCOL\",\n    \"MOVE\",\n    \"PROPFIND\",\n    \"PROPPATCH\",\n    \"SEARCH\",\n    \"UNLOCK\",\n    \"BIND\",\n    \"REBIND\",\n    \"UNBIND\",\n    \"ACL\",\n    \"REPORT\",\n    \"MKACTIVITY\",\n    \"CHECKOUT\",\n    \"MERGE\",\n    \"M-SEARCH\",\n    \"NOTIFY\",\n    \"SUBSCRIBE\",\n    \"UNSUBSCRIBE\",\n    \"PATCH\",\n    \"PURGE\",\n    \"MKCALENDAR\",\n    \"LINK\",\n    \"UNLINK\",\n    0 };\n  const char **this_method;\n  for (this_method = all_methods; *this_method; this_method++) {\n    char buf[200];\n    sprintf(buf, \"%s / HTTP/1.1\\r\\n\\r\\n\", *this_method);\n    test_simple(buf, HPE_OK);\n  }\n\n  static const char *bad_methods[] = {\n      \"ASDF\",\n      \"C******\",\n      \"COLA\",\n      \"GEM\",\n      \"GETA\",\n      \"M****\",\n      \"MKCOLA\",\n      \"PROPPATCHA\",\n      \"PUN\",\n      \"PX\",\n      \"SA\",\n      \"hello world\",\n      0 };\n  for (this_method = bad_methods; *this_method; this_method++) {\n    char buf[200];\n    sprintf(buf, \"%s / HTTP/1.1\\r\\n\\r\\n\", *this_method);\n    test_simple(buf, HPE_INVALID_METHOD);\n  }\n\n  // illegal header field name line folding\n  test_simple(\"GET / HTTP/1.1\\r\\n\"\n              \"name\\r\\n\"\n              \" : value\\r\\n\"\n              \"\\r\\n\",\n              HPE_INVALID_HEADER_TOKEN);\n\n  const char *dumbluck2 =\n    \"GET / HTTP/1.1\\r\\n\"\n    \"X-SSL-Nonsense:   -----BEGIN CERTIFICATE-----\\r\\n\"\n    \"\\tMIIFbTCCBFWgAwIBAgICH4cwDQYJKoZIhvcNAQEFBQAwcDELMAkGA1UEBhMCVUsx\\r\\n\"\n    \"\\tETAPBgNVBAoTCGVTY2llbmNlMRIwEAYDVQQLEwlBdXRob3JpdHkxCzAJBgNVBAMT\\r\\n\"\n    \"\\tAkNBMS0wKwYJKoZIhvcNAQkBFh5jYS1vcGVyYXRvckBncmlkLXN1cHBvcnQuYWMu\\r\\n\"\n    \"\\tdWswHhcNMDYwNzI3MTQxMzI4WhcNMDcwNzI3MTQxMzI4WjBbMQswCQYDVQQGEwJV\\r\\n\"\n    \"\\tSzERMA8GA1UEChMIZVNjaWVuY2UxEzARBgNVBAsTCk1hbmNoZXN0ZXIxCzAJBgNV\\r\\n\"\n    \"\\tBAcTmrsogriqMWLAk1DMRcwFQYDVQQDEw5taWNoYWVsIHBhcmQYJKoZIhvcNAQEB\\r\\n\"\n    \"\\tBQADggEPADCCAQoCggEBANPEQBgl1IaKdSS1TbhF3hEXSl72G9J+WC/1R64fAcEF\\r\\n\"\n    \"\\tW51rEyFYiIeZGx/BVzwXbeBoNUK41OK65sxGuflMo5gLflbwJtHBRIEKAfVVp3YR\\r\\n\"\n    \"\\tgW7cMA/s/XKgL1GEC7rQw8lIZT8RApukCGqOVHSi/F1SiFlPDxuDfmdiNzL31+sL\\r\\n\"\n    \"\\t0iwHDdNkGjy5pyBSB8Y79dsSJtCW/iaLB0/n8Sj7HgvvZJ7x0fr+RQjYOUUfrePP\\r\\n\"\n    \"\\tu2MSpFyf+9BbC/aXgaZuiCvSR+8Snv3xApQY+fULK/xY8h8Ua51iXoQ5jrgu2SqR\\r\\n\"\n    \"\\twgA7BUi3G8LFzMBl8FRCDYGUDy7M6QaHXx1ZWIPWNKsCAwEAAaOCAiQwggIgMAwG\\r\\n\"\n    \"\\tA1UdEwEB/wQCMAAwEQYJYIZIAYb4QgHTTPAQDAgWgMA4GA1UdDwEB/wQEAwID6DAs\\r\\n\"\n    \"\\tBglghkgBhvhCAQ0EHxYdVUsgZS1TY2llbmNlIFVzZXIgQ2VydGlmaWNhdGUwHQYD\\r\\n\"\n    \"\\tVR0OBBYEFDTt/sf9PeMaZDHkUIldrDYMNTBZMIGaBgNVHSMEgZIwgY+AFAI4qxGj\\r\\n\"\n    \"\\tloCLDdMVKwiljjDastqooXSkcjBwMQswCQYDVQQGEwJVSzERMA8GA1UEChMIZVNj\\r\\n\"\n    \"\\taWVuY2UxEjAQBgNVBAsTCUF1dGhvcml0eTELMAkGA1UEAxMCQ0ExLTArBgkqhkiG\\r\\n\"\n    \"\\t9w0BCQEWHmNhLW9wZXJhdG9yQGdyaWQtc3VwcG9ydC5hYy51a4IBADApBgNVHRIE\\r\\n\"\n    \"\\tIjAggR5jYS1vcGVyYXRvckBncmlkLXN1cHBvcnQuYWMudWswGQYDVR0gBBIwEDAO\\r\\n\"\n    \"\\tBgwrBgEEAdkvAQEBAQYwPQYJYIZIAYb4QgEEBDAWLmh0dHA6Ly9jYS5ncmlkLXN1\\r\\n\"\n    \"\\tcHBvcnQuYWMudmT4sopwqlBWsvcHViL2NybC9jYWNybC5jcmwwPQYJYIZIAYb4QgEDBDAWLmh0\\r\\n\"\n    \"\\tdHA6Ly9jYS5ncmlkLXN1cHBvcnQuYWMudWsvcHViL2NybC9jYWNybC5jcmwwPwYD\\r\\n\"\n    \"\\tVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NhLmdyaWQt5hYy51ay9wdWIv\\r\\n\"\n    \"\\tY3JsL2NhY3JsLmNybDANBgkqhkiG9w0BAQUFAAOCAQEAS/U4iiooBENGW/Hwmmd3\\r\\n\"\n    \"\\tXCy6Zrt08YjKCzGNjorT98g8uGsqYjSxv/hmi0qlnlHs+k/3Iobc3LjS5AMYr5L8\\r\\n\"\n    \"\\tUO7OSkgFFlLHQyC9JzPfmLCAugvzEbyv4Olnsr8hbxF1MbKZoQxUZtMVu29wjfXk\\r\\n\"\n    \"\\thTeApBv7eaKCWpSp7MCbvgzm74izKhu3vlDk9w6qVrxePfGgpKPqfHiOoGhFnbTK\\r\\n\"\n    \"\\twTC6o2xq5y0qZ03JonF7OJspEd3I5zKY3E+ov7/ZhW6DqT8UFvsAdjvQbXyhV8Eu\\r\\n\"\n    \"\\tYhixw1aKEPzNjNowuIseVogKOLXxWI5vAi5HgXdS0/ES5gDGsABo4fqovUKlgop3\\r\\n\"\n    \"\\tRA==\\r\\n\"\n    \"\\t-----END CERTIFICATE-----\\r\\n\"\n    \"\\r\\n\";\n  test_simple(dumbluck2, HPE_OK);\n\n  const char *corrupted_connection =\n    \"GET / HTTP/1.1\\r\\n\"\n    \"Host: www.example.com\\r\\n\"\n    \"Connection\\r\\033\\065\\325eep-Alive\\r\\n\"\n    \"Accept-Encoding: gzip\\r\\n\"\n    \"\\r\\n\";\n  test_simple(corrupted_connection, HPE_INVALID_HEADER_TOKEN);\n\n  const char *corrupted_header_name =\n    \"GET / HTTP/1.1\\r\\n\"\n    \"Host: www.example.com\\r\\n\"\n    \"X-Some-Header\\r\\033\\065\\325eep-Alive\\r\\n\"\n    \"Accept-Encoding: gzip\\r\\n\"\n    \"\\r\\n\";\n  test_simple(corrupted_header_name, HPE_INVALID_HEADER_TOKEN);\n\n#if 0\n  // NOTE(Wed Nov 18 11:57:27 CET 2009) this seems okay. we just read body\n  // until EOF.\n  //\n  // no content-length\n  // error if there is a body without content length\n  const char *bad_get_no_headers_no_body = \"GET /bad_get_no_headers_no_body/world HTTP/1.1\\r\\n\"\n                                           \"Accept: */*\\r\\n\"\n                                           \"\\r\\n\"\n                                           \"HELLO\";\n  test_simple(bad_get_no_headers_no_body, 0);\n#endif\n  /* TODO sending junk and large headers gets rejected */\n\n\n  /* check to make sure our predefined requests are okay */\n  for (i = 0; i < ARRAY_SIZE(requests); i++) {\n    test_message(&requests[i]);\n  }\n\n  for (i = 0; i < ARRAY_SIZE(requests); i++) {\n    test_message_pause(&requests[i]);\n  }\n\n  for (i = 0; i < ARRAY_SIZE(requests); i++) {\n    if (!requests[i].should_keep_alive) continue;\n    for (j = 0; j < ARRAY_SIZE(requests); j++) {\n      if (!requests[j].should_keep_alive) continue;\n      for (k = 0; k < ARRAY_SIZE(requests); k++) {\n        test_multiple3(&requests[i], &requests[j], &requests[k]);\n      }\n    }\n  }\n\n  printf(\"request scan 1/4      \");\n  test_scan( &requests[GET_NO_HEADERS_NO_BODY]\n           , &requests[GET_ONE_HEADER_NO_BODY]\n           , &requests[GET_NO_HEADERS_NO_BODY]\n           );\n\n  printf(\"request scan 2/4      \");\n  test_scan( &requests[POST_CHUNKED_ALL_YOUR_BASE]\n           , &requests[POST_IDENTITY_BODY_WORLD]\n           , &requests[GET_FUNKY_CONTENT_LENGTH]\n           );\n\n  printf(\"request scan 3/4      \");\n  test_scan( &requests[TWO_CHUNKS_MULT_ZERO_END]\n           , &requests[CHUNKED_W_TRAILING_HEADERS]\n           , &requests[CHUNKED_W_NONSENSE_AFTER_LENGTH]\n           );\n\n  printf(\"request scan 4/4      \");\n  test_scan( &requests[QUERY_URL_WITH_QUESTION_MARK_GET]\n           , &requests[PREFIX_NEWLINE_GET ]\n           , &requests[CONNECT_REQUEST]\n           );\n\n  puts(\"requests okay\");\n\n  return 0;\n}\n"
        }
      ]
    }
  ]
}