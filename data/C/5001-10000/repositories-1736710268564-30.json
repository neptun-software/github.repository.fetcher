{
  "metadata": {
    "timestamp": 1736710268564,
    "page": 30,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bellard/quickjs",
      "stars": 8705,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2646484375,
          "content": "*.a\n.obj/\ntests/bjson.so\nexamples/test_fib\ntest_fib.c\nexamples/*.so\nexamples/hello\nexamples/hello_module\nhello.c\nmicrobench*.txt\nqjs\nqjsc\nqjscalc\nqjscalc.c\nrepl.c\nrun-test262\ntest262\ntest262_*.txt\ntest262o\ntest262o_*.txt\nunicode\nunicode_gen\nrun_octane\nrun_sunspider_like\n"
        },
        {
          "name": "Changelog",
          "type": "blob",
          "size": 4.5,
          "content": "2024-01-13:\n\n- top-level-await support in modules\n- allow 'await' in the REPL\n- added Array.prototype.{with,toReversed,toSpliced,toSorted} and\nTypedArray.prototype.{with,toReversed,toSorted}\n- added String.prototype.isWellFormed and String.prototype.toWellFormed\n- added Object.groupBy and Map.groupBy\n- added Promise.withResolvers\n- class static block\n- 'in' operator support for private fields\n- optional chaining fixes\n- added RegExp 'd' flag\n- fixed RegExp zero length match logic\n- fixed RegExp case insensitive flag\n- added os.sleepAsync(), os.getpid() and os.now()\n- added cosmopolitan build\n- misc bug fixes\n\n2023-12-09:\n\n- added Object.hasOwn, {String|Array|TypedArray}.prototype.at,\n  {Array|TypedArray}.prototype.findLast{Index}\n- BigInt support is enabled even if CONFIG_BIGNUM disabled\n- updated to Unicode 15.0.0\n- misc bug fixes\n\n2021-03-27:\n\n- faster Array.prototype.push and Array.prototype.unshift\n- added JS_UpdateStackTop()\n- fixed Windows console\n- misc bug fixes\n\n2020-11-08:\n\n- improved function parameter initializers\n- added std.setenv(), std.unsetenv() and std.getenviron()\n- added JS_EvalThis()\n- misc bug fixes\n\n2020-09-06:\n\n- added logical assignment operators\n- added IsHTMLDDA support\n- faster for-of loops\n- os.Worker now takes a module filename as parameter\n- qjsc: added -D option to compile dynamically loaded modules or workers\n- misc bug fixes\n\n2020-07-05:\n\n- modified JS_GetPrototype() to return a live value\n- REPL: support unicode characters larger than 16 bits\n- added os.Worker\n- improved object serialization\n- added std.parseExtJSON\n- misc bug fixes\n\n2020-04-12:\n\n- added cross realm support\n- added AggregateError and Promise.any\n- added env, uid and gid options in os.exec()\n- misc bug fixes\n\n2020-03-16:\n\n- reworked error handling in std and os libraries: suppressed I/O\n  exceptions in std FILE functions and return a positive errno value\n  when it is explicit\n- output exception messages to stderr\n- added std.loadFile(), std.strerror(), std.FILE.prototype.tello()\n- added JS_GetRuntimeOpaque(), JS_SetRuntimeOpaque(), JS_NewUint32()\n- updated to Unicode 13.0.0\n- misc bug fixes\n\n2020-01-19:\n\n- keep CONFIG_BIGNUM in the makefile\n- added os.chdir()\n- qjs: added -I option\n- more memory checks in the bignum operations\n- modified operator overloading semantics to be closer to the TC39\n  proposal\n- suppressed \"use bigint\" mode. Simplified \"use math\" mode\n- BigDecimal: changed suffix from 'd' to 'm'\n- misc bug fixes\n\n2020-01-05:\n\n- always compile the bignum code. Added '--bignum' option to qjs.\n- added BigDecimal\n- added String.prototype.replaceAll\n- misc bug fixes\n\n2019-12-21:\n\n- added nullish coalescing operator (ES2020)\n- added optional chaining (ES2020)\n- removed recursions in garbage collector\n- test stack overflow in the parser\n- improved backtrace logic\n- added JS_SetHostPromiseRejectionTracker()\n- allow exotic constructors\n- improved c++ compatibility\n- misc bug fixes\n\n2019-10-27:\n\n- added example of C class in a module (examples/test_point.js)\n- added JS_GetTypedArrayBuffer()\n- misc bug fixes\n\n2019-09-18:\n\n- added os.exec and other system calls\n- exported JS_ValueToAtom()\n- qjsc: added 'qjsc_' prefix to the generated C identifiers\n- added cross-compilation support\n- misc bug fixes\n\n2019-09-01:\n\n- added globalThis\n- documented JS_EVAL_FLAG_COMPILE_ONLY\n- added import.meta.url and import.meta.main\n- added 'debugger' statement\n- misc bug fixes\n\n2019-08-18:\n\n- added os.realpath, os.getcwd, os.mkdir, os.stat, os.lstat,\n  os.readlink, os.readdir, os.utimes, std.popen\n- module autodetection\n- added import.meta\n- misc bug fixes\n\n2019-08-10:\n\n- added public class fields and private class fields, methods and\n  accessors (TC39 proposal)\n- changed JS_ToCStringLen() prototype\n- qjsc: handle '-' in module names and modules with the same filename\n- added std.urlGet\n- exported JS_GetOwnPropertyNames() and JS_GetOwnProperty()\n- exported some bigint C functions\n- added support for eshost in run-test262\n- misc bug fixes\n\n2019-07-28:\n\n- added dynamic import\n- added Promise.allSettled\n- added String.prototype.matchAll\n- added Object.fromEntries\n- reduced number of ticks in await\n- added BigInt support in Atomics\n- exported JS_NewPromiseCapability()\n- misc async function and async generator fixes\n- enabled hashbang support by default\n\n2019-07-21:\n\n- updated test262 tests\n- updated to Unicode version 12.1.0\n- fixed missing Date object in qjsc\n- fixed multi-context creation\n- misc ES2020 related fixes\n- simplified power and division operators in bignum extension\n- fixed several crash conditions\n\n2019-07-09:\n\n- first public release\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.103515625,
          "content": "QuickJS Javascript Engine\n\nCopyright (c) 2017-2021 Fabrice Bellard\nCopyright (c) 2017-2021 Charlie Gordon\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 15.3544921875,
          "content": "#\n# QuickJS Javascript Engine\n#\n# Copyright (c) 2017-2021 Fabrice Bellard\n# Copyright (c) 2017-2021 Charlie Gordon\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nifeq ($(shell uname -s),Darwin)\nCONFIG_DARWIN=y\nendif\nifeq ($(shell uname -s),FreeBSD)\nCONFIG_FREEBSD=y\nendif\n# Windows cross compilation from Linux\n#CONFIG_WIN32=y\n# use link time optimization (smaller and faster executables but slower build)\n#CONFIG_LTO=y\n# consider warnings as errors (for development)\n#CONFIG_WERROR=y\n# force 32 bit build for some utilities\n#CONFIG_M32=y\n# cosmopolitan build (see https://github.com/jart/cosmopolitan)\n#CONFIG_COSMO=y\n\n# installation directory\nPREFIX?=/usr/local\n\n# use the gprof profiler\n#CONFIG_PROFILE=y\n# use address sanitizer\n#CONFIG_ASAN=y\n# use memory sanitizer\n#CONFIG_MSAN=y\n# use UB sanitizer\n#CONFIG_UBSAN=y\n\n# include the code for BigFloat/BigDecimal and math mode\nCONFIG_BIGNUM=y\n\nOBJDIR=.obj\n\nifdef CONFIG_ASAN\nOBJDIR:=$(OBJDIR)/asan\nendif\nifdef CONFIG_MSAN\nOBJDIR:=$(OBJDIR)/msan\nendif\nifdef CONFIG_UBSAN\nOBJDIR:=$(OBJDIR)/ubsan\nendif\n\nifdef CONFIG_DARWIN\n# use clang instead of gcc\nCONFIG_CLANG=y\nCONFIG_DEFAULT_AR=y\nendif\nifdef CONFIG_FREEBSD\n# use clang instead of gcc\nCONFIG_CLANG=y\nCONFIG_DEFAULT_AR=y\nCONFIG_LTO=\nendif\n\nifdef CONFIG_WIN32\n  ifdef CONFIG_M32\n    CROSS_PREFIX?=i686-w64-mingw32-\n  else\n    CROSS_PREFIX?=x86_64-w64-mingw32-\n  endif\n  EXE=.exe\nelse\n  CROSS_PREFIX?=\n  EXE=\nendif\n\nifdef CONFIG_CLANG\n  HOST_CC=clang\n  CC=$(CROSS_PREFIX)clang\n  CFLAGS+=-g -Wall -MMD -MF $(OBJDIR)/$(@F).d\n  CFLAGS += -Wextra\n  CFLAGS += -Wno-sign-compare\n  CFLAGS += -Wno-missing-field-initializers\n  CFLAGS += -Wundef -Wuninitialized\n  CFLAGS += -Wunused -Wno-unused-parameter\n  CFLAGS += -Wwrite-strings\n  CFLAGS += -Wchar-subscripts -funsigned-char\n  CFLAGS += -MMD -MF $(OBJDIR)/$(@F).d\n  ifdef CONFIG_DEFAULT_AR\n    AR=$(CROSS_PREFIX)ar\n  else\n    ifdef CONFIG_LTO\n      AR=$(CROSS_PREFIX)llvm-ar\n    else\n      AR=$(CROSS_PREFIX)ar\n    endif\n  endif\n  LIB_FUZZING_ENGINE ?= \"-fsanitize=fuzzer\"\nelse ifdef CONFIG_COSMO\n  CONFIG_LTO=\n  HOST_CC=gcc\n  CC=cosmocc\n  # cosmocc does not correct support -MF\n  CFLAGS=-g -Wall #-MMD -MF $(OBJDIR)/$(@F).d\n  CFLAGS += -Wno-array-bounds -Wno-format-truncation\n  AR=cosmoar\nelse\n  HOST_CC=gcc\n  CC=$(CROSS_PREFIX)gcc\n  CFLAGS+=-g -Wall -MMD -MF $(OBJDIR)/$(@F).d\n  CFLAGS += -Wno-array-bounds -Wno-format-truncation\n  ifdef CONFIG_LTO\n    AR=$(CROSS_PREFIX)gcc-ar\n  else\n    AR=$(CROSS_PREFIX)ar\n  endif\nendif\nSTRIP?=$(CROSS_PREFIX)strip\nCFLAGS+=-fwrapv # ensure that signed overflows behave as expected\nifdef CONFIG_WERROR\nCFLAGS+=-Werror\nendif\nDEFINES:=-D_GNU_SOURCE -DCONFIG_VERSION=\\\"$(shell cat VERSION)\\\"\nifdef CONFIG_BIGNUM\nDEFINES+=-DCONFIG_BIGNUM\nendif\nifdef CONFIG_WIN32\nDEFINES+=-D__USE_MINGW_ANSI_STDIO # for standard snprintf behavior\nendif\nifndef CONFIG_WIN32\nifeq ($(shell $(CC) -o /dev/null compat/test-closefrom.c 2>/dev/null && echo 1),1)\nDEFINES+=-DHAVE_CLOSEFROM\nendif\nendif\n\nCFLAGS+=$(DEFINES)\nCFLAGS_DEBUG=$(CFLAGS) -O0\nCFLAGS_SMALL=$(CFLAGS) -Os\nCFLAGS_OPT=$(CFLAGS) -O2\nCFLAGS_NOLTO:=$(CFLAGS_OPT)\nifdef CONFIG_COSMO\nLDFLAGS+=-s # better to strip by default\nelse\nLDFLAGS+=-g\nendif\nifdef CONFIG_LTO\nCFLAGS_SMALL+=-flto\nCFLAGS_OPT+=-flto\nLDFLAGS+=-flto\nendif\nifdef CONFIG_PROFILE\nCFLAGS+=-p\nLDFLAGS+=-p\nendif\nifdef CONFIG_ASAN\nCFLAGS+=-fsanitize=address -fno-omit-frame-pointer\nLDFLAGS+=-fsanitize=address -fno-omit-frame-pointer\nendif\nifdef CONFIG_MSAN\nCFLAGS+=-fsanitize=memory -fno-omit-frame-pointer\nLDFLAGS+=-fsanitize=memory -fno-omit-frame-pointer\nendif\nifdef CONFIG_UBSAN\nCFLAGS+=-fsanitize=undefined -fno-omit-frame-pointer\nLDFLAGS+=-fsanitize=undefined -fno-omit-frame-pointer\nendif\nifdef CONFIG_WIN32\nLDEXPORT=\nelse\nLDEXPORT=-rdynamic\nendif\n\nifndef CONFIG_COSMO\nifndef CONFIG_DARWIN\nCONFIG_SHARED_LIBS=y # building shared libraries is supported\nendif\nendif\n\nPROGS=qjs$(EXE) qjsc$(EXE) run-test262\nifneq ($(CROSS_PREFIX),)\nQJSC_CC=gcc\nQJSC=./host-qjsc\nPROGS+=$(QJSC)\nelse\nQJSC_CC=$(CC)\nQJSC=./qjsc$(EXE)\nendif\nifndef CONFIG_WIN32\nPROGS+=qjscalc\nendif\nifdef CONFIG_M32\nPROGS+=qjs32 qjs32_s\nendif\nPROGS+=libquickjs.a\nifdef CONFIG_LTO\nPROGS+=libquickjs.lto.a\nendif\n\n# examples\nifeq ($(CROSS_PREFIX),)\nifndef CONFIG_ASAN\nifndef CONFIG_MSAN\nifndef CONFIG_UBSAN\nPROGS+=examples/hello examples/hello_module examples/test_fib\nifdef CONFIG_SHARED_LIBS\nPROGS+=examples/fib.so examples/point.so\nendif\nendif\nendif\nendif\nendif\n\nall: $(OBJDIR) $(OBJDIR)/quickjs.check.o $(OBJDIR)/qjs.check.o $(PROGS)\n\nQJS_LIB_OBJS=$(OBJDIR)/quickjs.o $(OBJDIR)/libregexp.o $(OBJDIR)/libunicode.o $(OBJDIR)/cutils.o $(OBJDIR)/quickjs-libc.o $(OBJDIR)/libbf.o\n\nQJS_OBJS=$(OBJDIR)/qjs.o $(OBJDIR)/repl.o $(QJS_LIB_OBJS)\nifdef CONFIG_BIGNUM\nQJS_OBJS+=$(OBJDIR)/qjscalc.o\nendif\n\nHOST_LIBS=-lm -ldl -lpthread\nLIBS=-lm\nifndef CONFIG_WIN32\nLIBS+=-ldl -lpthread\nendif\nLIBS+=$(EXTRA_LIBS)\n\n$(OBJDIR):\n\tmkdir -p $(OBJDIR) $(OBJDIR)/examples $(OBJDIR)/tests\n\nqjs$(EXE): $(QJS_OBJS)\n\t$(CC) $(LDFLAGS) $(LDEXPORT) -o $@ $^ $(LIBS)\n\nqjs-debug$(EXE): $(patsubst %.o, %.debug.o, $(QJS_OBJS))\n\t$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)\n\nqjsc$(EXE): $(OBJDIR)/qjsc.o $(QJS_LIB_OBJS)\n\t$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)\n\nfuzz_eval: $(OBJDIR)/fuzz_eval.o $(OBJDIR)/fuzz_common.o libquickjs.fuzz.a\n\t$(CC) $(CFLAGS_OPT) $^ -o fuzz_eval $(LIB_FUZZING_ENGINE)\n\nfuzz_compile: $(OBJDIR)/fuzz_compile.o $(OBJDIR)/fuzz_common.o libquickjs.fuzz.a\n\t$(CC) $(CFLAGS_OPT) $^ -o fuzz_compile $(LIB_FUZZING_ENGINE)\n\nfuzz_regexp: $(OBJDIR)/fuzz_regexp.o $(OBJDIR)/libregexp.fuzz.o $(OBJDIR)/cutils.fuzz.o $(OBJDIR)/libunicode.fuzz.o\n\t$(CC) $(CFLAGS_OPT) $^ -o fuzz_regexp $(LIB_FUZZING_ENGINE)\n\nlibfuzzer: fuzz_eval fuzz_compile fuzz_regexp\n\nifneq ($(CROSS_PREFIX),)\n\n$(QJSC): $(OBJDIR)/qjsc.host.o \\\n    $(patsubst %.o, %.host.o, $(QJS_LIB_OBJS))\n\t$(HOST_CC) $(LDFLAGS) -o $@ $^ $(HOST_LIBS)\n\nendif #CROSS_PREFIX\n\nQJSC_DEFINES:=-DCONFIG_CC=\\\"$(QJSC_CC)\\\" -DCONFIG_PREFIX=\\\"$(PREFIX)\\\"\nifdef CONFIG_LTO\nQJSC_DEFINES+=-DCONFIG_LTO\nendif\nQJSC_HOST_DEFINES:=-DCONFIG_CC=\\\"$(HOST_CC)\\\" -DCONFIG_PREFIX=\\\"$(PREFIX)\\\"\n\n$(OBJDIR)/qjsc.o: CFLAGS+=$(QJSC_DEFINES)\n$(OBJDIR)/qjsc.host.o: CFLAGS+=$(QJSC_HOST_DEFINES)\n\nqjs32: $(patsubst %.o, %.m32.o, $(QJS_OBJS))\n\t$(CC) -m32 $(LDFLAGS) $(LDEXPORT) -o $@ $^ $(LIBS)\n\nqjs32_s: $(patsubst %.o, %.m32s.o, $(QJS_OBJS))\n\t$(CC) -m32 $(LDFLAGS) -o $@ $^ $(LIBS)\n\t@size $@\n\nqjscalc: qjs\n\tln -sf $< $@\n\nifdef CONFIG_LTO\nLTOEXT=.lto\nelse\nLTOEXT=\nendif\n\nlibquickjs$(LTOEXT).a: $(QJS_LIB_OBJS)\n\t$(AR) rcs $@ $^\n\nifdef CONFIG_LTO\nlibquickjs.a: $(patsubst %.o, %.nolto.o, $(QJS_LIB_OBJS))\n\t$(AR) rcs $@ $^\nendif # CONFIG_LTO\n\nlibquickjs.fuzz.a: $(patsubst %.o, %.fuzz.o, $(QJS_LIB_OBJS))\n\t$(AR) rcs $@ $^\n\nrepl.c: $(QJSC) repl.js\n\t$(QJSC) -c -o $@ -m repl.js\n\nqjscalc.c: $(QJSC) qjscalc.js\n\t$(QJSC) -fbignum -c -o $@ qjscalc.js\n\nifneq ($(wildcard unicode/UnicodeData.txt),)\n$(OBJDIR)/libunicode.o $(OBJDIR)/libunicode.m32.o $(OBJDIR)/libunicode.m32s.o \\\n    $(OBJDIR)/libunicode.nolto.o: libunicode-table.h\n\nlibunicode-table.h: unicode_gen\n\t./unicode_gen unicode $@\nendif\n\nrun-test262: $(OBJDIR)/run-test262.o $(QJS_LIB_OBJS)\n\t$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)\n\nrun-test262-debug: $(patsubst %.o, %.debug.o, $(OBJDIR)/run-test262.o $(QJS_LIB_OBJS))\n\t$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)\n\nrun-test262-32: $(patsubst %.o, %.m32.o, $(OBJDIR)/run-test262.o $(QJS_LIB_OBJS))\n\t$(CC) -m32 $(LDFLAGS) -o $@ $^ $(LIBS)\n\n# object suffix order: nolto, [m32|m32s]\n\n$(OBJDIR)/%.o: %.c | $(OBJDIR)\n\t$(CC) $(CFLAGS_OPT) -c -o $@ $<\n\n$(OBJDIR)/fuzz_%.o: fuzz/fuzz_%.c | $(OBJDIR)\n\t$(CC) $(CFLAGS_OPT) -c -I. -o $@ $<\n\n$(OBJDIR)/%.host.o: %.c | $(OBJDIR)\n\t$(HOST_CC) $(CFLAGS_OPT) -c -o $@ $<\n\n$(OBJDIR)/%.pic.o: %.c | $(OBJDIR)\n\t$(CC) $(CFLAGS_OPT) -fPIC -DJS_SHARED_LIBRARY -c -o $@ $<\n\n$(OBJDIR)/%.nolto.o: %.c | $(OBJDIR)\n\t$(CC) $(CFLAGS_NOLTO) -c -o $@ $<\n\n$(OBJDIR)/%.m32.o: %.c | $(OBJDIR)\n\t$(CC) -m32 $(CFLAGS_OPT) -c -o $@ $<\n\n$(OBJDIR)/%.m32s.o: %.c | $(OBJDIR)\n\t$(CC) -m32 $(CFLAGS_SMALL) -c -o $@ $<\n\n$(OBJDIR)/%.debug.o: %.c | $(OBJDIR)\n\t$(CC) $(CFLAGS_DEBUG) -c -o $@ $<\n\n$(OBJDIR)/%.fuzz.o: %.c | $(OBJDIR)\n\t$(CC) $(CFLAGS_OPT) -fsanitize=fuzzer-no-link -c -o $@ $<\n\n$(OBJDIR)/%.check.o: %.c | $(OBJDIR)\n\t$(CC) $(CFLAGS) -DCONFIG_CHECK_JSVALUE -c -o $@ $<\n\nregexp_test: libregexp.c libunicode.c cutils.c\n\t$(CC) $(LDFLAGS) $(CFLAGS) -DTEST -o $@ libregexp.c libunicode.c cutils.c $(LIBS)\n\nunicode_gen: $(OBJDIR)/unicode_gen.host.o $(OBJDIR)/cutils.host.o libunicode.c unicode_gen_def.h\n\t$(HOST_CC) $(LDFLAGS) $(CFLAGS) -o $@ $(OBJDIR)/unicode_gen.host.o $(OBJDIR)/cutils.host.o\n\nclean:\n\trm -f repl.c qjscalc.c out.c\n\trm -f *.a *.o *.d *~ unicode_gen regexp_test fuzz_eval fuzz_compile fuzz_regexp $(PROGS)\n\trm -f hello.c test_fib.c\n\trm -f examples/*.so tests/*.so\n\trm -rf $(OBJDIR)/ *.dSYM/ qjs-debug\n\trm -rf run-test262-debug run-test262-32\n\trm -f run_octane run_sunspider_like\n\ninstall: all\n\tmkdir -p \"$(DESTDIR)$(PREFIX)/bin\"\n\t$(STRIP) qjs$(EXE) qjsc$(EXE)\n\tinstall -m755 qjs$(EXE) qjsc$(EXE) \"$(DESTDIR)$(PREFIX)/bin\"\n\tln -sf qjs$(EXE) \"$(DESTDIR)$(PREFIX)/bin/qjscalc$(EXE)\"\n\tmkdir -p \"$(DESTDIR)$(PREFIX)/lib/quickjs\"\n\tinstall -m644 libquickjs.a \"$(DESTDIR)$(PREFIX)/lib/quickjs\"\nifdef CONFIG_LTO\n\tinstall -m644 libquickjs.lto.a \"$(DESTDIR)$(PREFIX)/lib/quickjs\"\nendif\n\tmkdir -p \"$(DESTDIR)$(PREFIX)/include/quickjs\"\n\tinstall -m644 quickjs.h quickjs-libc.h \"$(DESTDIR)$(PREFIX)/include/quickjs\"\n\n###############################################################################\n# examples\n\n# example of static JS compilation\nHELLO_SRCS=examples/hello.js\nHELLO_OPTS=-fno-string-normalize -fno-map -fno-promise -fno-typedarray \\\n           -fno-typedarray -fno-regexp -fno-json -fno-eval -fno-proxy \\\n           -fno-date -fno-module-loader -fno-bigint\n\nhello.c: $(QJSC) $(HELLO_SRCS)\n\t$(QJSC) -e $(HELLO_OPTS) -o $@ $(HELLO_SRCS)\n\nifdef CONFIG_M32\nexamples/hello: $(OBJDIR)/hello.m32s.o $(patsubst %.o, %.m32s.o, $(QJS_LIB_OBJS))\n\t$(CC) -m32 $(LDFLAGS) -o $@ $^ $(LIBS)\nelse\nexamples/hello: $(OBJDIR)/hello.o $(QJS_LIB_OBJS)\n\t$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)\nendif\n\n# example of static JS compilation with modules\nHELLO_MODULE_SRCS=examples/hello_module.js\nHELLO_MODULE_OPTS=-fno-string-normalize -fno-map -fno-promise -fno-typedarray \\\n           -fno-typedarray -fno-regexp -fno-json -fno-eval -fno-proxy \\\n           -fno-date -m\nexamples/hello_module: $(QJSC) libquickjs$(LTOEXT).a $(HELLO_MODULE_SRCS)\n\t$(QJSC) $(HELLO_MODULE_OPTS) -o $@ $(HELLO_MODULE_SRCS)\n\n# use of an external C module (static compilation)\n\ntest_fib.c: $(QJSC) examples/test_fib.js\n\t$(QJSC) -e -M examples/fib.so,fib -m -o $@ examples/test_fib.js\n\nexamples/test_fib: $(OBJDIR)/test_fib.o $(OBJDIR)/examples/fib.o libquickjs$(LTOEXT).a\n\t$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)\n\nexamples/fib.so: $(OBJDIR)/examples/fib.pic.o\n\t$(CC) $(LDFLAGS) -shared -o $@ $^\n\nexamples/point.so: $(OBJDIR)/examples/point.pic.o\n\t$(CC) $(LDFLAGS) -shared -o $@ $^\n\n###############################################################################\n# documentation\n\nDOCS=doc/quickjs.pdf doc/quickjs.html doc/jsbignum.pdf doc/jsbignum.html\n\nbuild_doc: $(DOCS)\n\nclean_doc:\n\trm -f $(DOCS)\n\ndoc/%.pdf: doc/%.texi\n\ttexi2pdf --clean -o $@ -q $<\n\ndoc/%.html.pre: doc/%.texi\n\tmakeinfo --html --no-headers --no-split --number-sections -o $@ $<\n\ndoc/%.html: doc/%.html.pre\n\tsed -e 's|</style>|</style>\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">|' < $< > $@\n\n###############################################################################\n# tests\n\nifdef CONFIG_SHARED_LIBS\ntest: tests/bjson.so examples/point.so\nendif\nifdef CONFIG_M32\ntest: qjs32\nendif\n\ntest: qjs\n\t./qjs tests/test_closure.js\n\t./qjs tests/test_language.js\n\t./qjs --std tests/test_builtin.js\n\t./qjs tests/test_loop.js\n\t./qjs tests/test_bignum.js\n\t./qjs tests/test_std.js\n\t./qjs tests/test_worker.js\nifdef CONFIG_SHARED_LIBS\nifdef CONFIG_BIGNUM\n\t./qjs --bignum tests/test_bjson.js\nelse\n\t./qjs tests/test_bjson.js\nendif\n\t./qjs examples/test_point.js\nendif\nifdef CONFIG_BIGNUM\n\t./qjs --bignum tests/test_op_overloading.js\n\t./qjs --bignum tests/test_bigfloat.js\n\t./qjs --qjscalc tests/test_qjscalc.js\nendif\nifdef CONFIG_M32\n\t./qjs32 tests/test_closure.js\n\t./qjs32 tests/test_language.js\n\t./qjs32 --std tests/test_builtin.js\n\t./qjs32 tests/test_loop.js\n\t./qjs32 tests/test_bignum.js\n\t./qjs32 tests/test_std.js\n\t./qjs32 tests/test_worker.js\nifdef CONFIG_BIGNUM\n\t./qjs32 --bignum tests/test_op_overloading.js\n\t./qjs32 --bignum tests/test_bigfloat.js\n\t./qjs32 --qjscalc tests/test_qjscalc.js\nendif\nendif\n\nstats: qjs qjs32\n\t./qjs -qd\n\t./qjs32 -qd\n\nmicrobench: qjs\n\t./qjs --std tests/microbench.js\n\nmicrobench-32: qjs32\n\t./qjs32 --std tests/microbench.js\n\nifeq ($(wildcard test262o/tests.txt),)\ntest2o test2o-32 test2o-update:\n\t@echo test262o tests not installed\nelse\n# ES5 tests (obsolete)\ntest2o: run-test262\n\ttime ./run-test262 -t -m -c test262o.conf\n\ntest2o-32: run-test262-32\n\ttime ./run-test262-32 -t -m -c test262o.conf\n\ntest2o-update: run-test262\n\t./run-test262 -t -u -c test262o.conf\nendif\n\nifeq ($(wildcard test262/features.txt),)\ntest2 test2-32 test2-update test2-default test2-check:\n\t@echo test262 tests not installed\nelse\n# Test262 tests\ntest2-default: run-test262\n\ttime ./run-test262 -t -m -c test262.conf\n\ntest2: run-test262\n\ttime ./run-test262 -t -m -c test262.conf -a\n\ntest2-32: run-test262-32\n\ttime ./run-test262-32 -t -m -c test262.conf -a\n\ntest2-update: run-test262\n\t./run-test262 -t -u -c test262.conf -a\n\ntest2-check: run-test262\n\ttime ./run-test262 -t -m -c test262.conf -E -a\nendif\n\ntestall: all test microbench test2o test2\n\ntestall-32: all test-32 microbench-32 test2o-32 test2-32\n\ntestall-complete: testall testall-32\n\nnode-test:\n\tnode tests/test_closure.js\n\tnode tests/test_language.js\n\tnode tests/test_builtin.js\n\tnode tests/test_loop.js\n\tnode tests/test_bignum.js\n\nnode-microbench:\n\tnode tests/microbench.js -s microbench-node.txt\n\tnode --jitless tests/microbench.js -s microbench-node-jitless.txt\n\nbench-v8: qjs\n\tmake -C tests/bench-v8\n\t./qjs -d tests/bench-v8/combined.js\n\nnode-bench-v8:\n\tmake -C tests/bench-v8\n\tnode --jitless tests/bench-v8/combined.js\n\ntests/bjson.so: $(OBJDIR)/tests/bjson.pic.o\n\t$(CC) $(LDFLAGS) -shared -o $@ $^ $(LIBS)\n\nBENCHMARKDIR=../quickjs-benchmarks\n\nrun_sunspider_like: $(BENCHMARKDIR)/run_sunspider_like.c\n\t$(CC) $(CFLAGS) $(LDFLAGS) -DNO_INCLUDE_DIR -I. -o $@ $< libquickjs$(LTOEXT).a $(LIBS)\n\nrun_octane: $(BENCHMARKDIR)/run_octane.c\n\t$(CC) $(CFLAGS) $(LDFLAGS) -DNO_INCLUDE_DIR -I. -o $@ $< libquickjs$(LTOEXT).a $(LIBS)\n\nbenchmarks: run_sunspider_like run_octane\n\t./run_sunspider_like $(BENCHMARKDIR)/kraken-1.0/\n\t./run_sunspider_like $(BENCHMARKDIR)/kraken-1.1/\n\t./run_sunspider_like $(BENCHMARKDIR)/sunspider-1.0/\n\t./run_octane $(BENCHMARKDIR)/\n\n-include $(wildcard $(OBJDIR)/*.d)\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 2.9482421875,
          "content": "Misc ideas:\n- use custom printf to avoid compatibility issues with floating point numbers\n- consistent naming for preprocessor defines\n- unify coding style and naming conventions\n- use names from the ECMA spec in library implementation\n- use byte code emitters with typed arguments (for clarity)\n- use 2 bytecode DynBufs in JSFunctionDef, one for reading, one for writing\n  and use the same wrappers in all phases\n- use more generic method for line numbers in resolve_variables and resolve_labels\n- use custom timezone support to avoid C library compatibility issues\n\nMemory:\n- use memory pools for objects, etc?\n- test border cases for max number of atoms, object properties, string length\n- add emergency malloc mode for out of memory exceptions.\n- test all DynBuf memory errors\n- test all js_realloc memory errors\n- improve JS_ComputeMemoryUsage() with more info\n\nBuilt-in standard library:\n- BSD sockets\n- modules: use realpath in module name normalizer and put it in quickjs-libc\n- modules: if no \".\", use a well known module loading path ?\n- get rid of __loadScript, use more common name\n\nREPL:\n- debugger\n- readline: support MS Windows terminal\n- readline: handle dynamic terminal resizing\n- readline: handle double width unicode characters\n- multiline editing\n- runtime object and function inspectors\n- interactive object browser\n- use more generic approach to display evaluation results\n- improve directive handling: dispatch, colorize, completion...\n- save history\n- close all predefined methods in repl.js and jscalc.js\n\nOptimization ideas:\n- 64-bit atoms in 64-bit mode ?\n- 64-bit small bigint in 64-bit mode ?\n- reuse stack slots for disjoint scopes, if strip\n- add heuristic to avoid some cycles in closures\n- small String (0-2 charcodes) with immediate storage\n- perform static string concatenation at compile time\n- optimize string concatenation with ropes or miniropes?\n- add implicit numeric strings for Uint32 numbers?\n- optimize `s += a + b`, `s += a.b` and similar simple expressions\n- ensure string canonical representation and optimise comparisons and hashes?\n- remove JSObject.first_weak_ref, use bit+context based hashed array for weak references\n- property access optimization on the global object, functions,\n  prototypes and special non extensible objects.\n- create object literals with the correct length by backpatching length argument\n- remove redundant set_loc_uninitialized/check_uninitialized opcodes\n- peephole optim: push_atom_value, to_propkey -> push_atom_value\n- peephole optim: put_loc x, get_loc_check x -> set_loc x\n- convert slow array to fast array when all properties != length are numeric\n- optimize destructuring assignments for global and local variables\n- implement some form of tail-call-optimization\n- optimize OP_apply\n- optimize f(...b)\n\nTest262o:   0/11262 errors, 463 excluded\nTest262o commit: 7da91bceb9ce7613f87db47ddd1292a2dda58b42 (es5-tests branch)\n\nResult: 8/76947 errors, 1497 excluded, 8117 skipped\nTest262 commit: 6cbb6da9473c56d95358d8e679c5a6d2b4574efb\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.0107421875,
          "content": "2024-02-14\n"
        },
        {
          "name": "compat",
          "type": "tree",
          "content": null
        },
        {
          "name": "cutils.c",
          "type": "blob",
          "size": 17.140625,
          "content": "/*\n * C utilities\n *\n * Copyright (c) 2017 Fabrice Bellard\n * Copyright (c) 2018 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\n#include \"cutils.h\"\n\nvoid pstrcpy(char *buf, int buf_size, const char *str)\n{\n    int c;\n    char *q = buf;\n\n    if (buf_size <= 0)\n        return;\n\n    for(;;) {\n        c = *str++;\n        if (c == 0 || q >= buf + buf_size - 1)\n            break;\n        *q++ = c;\n    }\n    *q = '\\0';\n}\n\n/* strcat and truncate. */\nchar *pstrcat(char *buf, int buf_size, const char *s)\n{\n    int len;\n    len = strlen(buf);\n    if (len < buf_size)\n        pstrcpy(buf + len, buf_size - len, s);\n    return buf;\n}\n\nint strstart(const char *str, const char *val, const char **ptr)\n{\n    const char *p, *q;\n    p = str;\n    q = val;\n    while (*q != '\\0') {\n        if (*p != *q)\n            return 0;\n        p++;\n        q++;\n    }\n    if (ptr)\n        *ptr = p;\n    return 1;\n}\n\nint has_suffix(const char *str, const char *suffix)\n{\n    size_t len = strlen(str);\n    size_t slen = strlen(suffix);\n    return (len >= slen && !memcmp(str + len - slen, suffix, slen));\n}\n\n/* Dynamic buffer package */\n\nstatic void *dbuf_default_realloc(void *opaque, void *ptr, size_t size)\n{\n    return realloc(ptr, size);\n}\n\nvoid dbuf_init2(DynBuf *s, void *opaque, DynBufReallocFunc *realloc_func)\n{\n    memset(s, 0, sizeof(*s));\n    if (!realloc_func)\n        realloc_func = dbuf_default_realloc;\n    s->opaque = opaque;\n    s->realloc_func = realloc_func;\n}\n\nvoid dbuf_init(DynBuf *s)\n{\n    dbuf_init2(s, NULL, NULL);\n}\n\n/* return < 0 if error */\nint dbuf_realloc(DynBuf *s, size_t new_size)\n{\n    size_t size;\n    uint8_t *new_buf;\n    if (new_size > s->allocated_size) {\n        if (s->error)\n            return -1;\n        size = s->allocated_size * 3 / 2;\n        if (size > new_size)\n            new_size = size;\n        new_buf = s->realloc_func(s->opaque, s->buf, new_size);\n        if (!new_buf) {\n            s->error = TRUE;\n            return -1;\n        }\n        s->buf = new_buf;\n        s->allocated_size = new_size;\n    }\n    return 0;\n}\n\nint dbuf_write(DynBuf *s, size_t offset, const uint8_t *data, size_t len)\n{\n    size_t end;\n    end = offset + len;\n    if (dbuf_realloc(s, end))\n        return -1;\n    memcpy(s->buf + offset, data, len);\n    if (end > s->size)\n        s->size = end;\n    return 0;\n}\n\nint dbuf_put(DynBuf *s, const uint8_t *data, size_t len)\n{\n    if (unlikely((s->size + len) > s->allocated_size)) {\n        if (dbuf_realloc(s, s->size + len))\n            return -1;\n    }\n    memcpy_no_ub(s->buf + s->size, data, len);\n    s->size += len;\n    return 0;\n}\n\nint dbuf_put_self(DynBuf *s, size_t offset, size_t len)\n{\n    if (unlikely((s->size + len) > s->allocated_size)) {\n        if (dbuf_realloc(s, s->size + len))\n            return -1;\n    }\n    memcpy(s->buf + s->size, s->buf + offset, len);\n    s->size += len;\n    return 0;\n}\n\nint dbuf_putc(DynBuf *s, uint8_t c)\n{\n    return dbuf_put(s, &c, 1);\n}\n\nint dbuf_putstr(DynBuf *s, const char *str)\n{\n    return dbuf_put(s, (const uint8_t *)str, strlen(str));\n}\n\nint __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,\n                                                      const char *fmt, ...)\n{\n    va_list ap;\n    char buf[128];\n    int len;\n\n    va_start(ap, fmt);\n    len = vsnprintf(buf, sizeof(buf), fmt, ap);\n    va_end(ap);\n    if (len < sizeof(buf)) {\n        /* fast case */\n        return dbuf_put(s, (uint8_t *)buf, len);\n    } else {\n        if (dbuf_realloc(s, s->size + len + 1))\n            return -1;\n        va_start(ap, fmt);\n        vsnprintf((char *)(s->buf + s->size), s->allocated_size - s->size,\n                  fmt, ap);\n        va_end(ap);\n        s->size += len;\n    }\n    return 0;\n}\n\nvoid dbuf_free(DynBuf *s)\n{\n    /* we test s->buf as a fail safe to avoid crashing if dbuf_free()\n       is called twice */\n    if (s->buf) {\n        s->realloc_func(s->opaque, s->buf, 0);\n    }\n    memset(s, 0, sizeof(*s));\n}\n\n/* Note: at most 31 bits are encoded. At most UTF8_CHAR_LEN_MAX bytes\n   are output. */\nint unicode_to_utf8(uint8_t *buf, unsigned int c)\n{\n    uint8_t *q = buf;\n\n    if (c < 0x80) {\n        *q++ = c;\n    } else {\n        if (c < 0x800) {\n            *q++ = (c >> 6) | 0xc0;\n        } else {\n            if (c < 0x10000) {\n                *q++ = (c >> 12) | 0xe0;\n            } else {\n                if (c < 0x00200000) {\n                    *q++ = (c >> 18) | 0xf0;\n                } else {\n                    if (c < 0x04000000) {\n                        *q++ = (c >> 24) | 0xf8;\n                    } else if (c < 0x80000000) {\n                        *q++ = (c >> 30) | 0xfc;\n                        *q++ = ((c >> 24) & 0x3f) | 0x80;\n                    } else {\n                        return 0;\n                    }\n                    *q++ = ((c >> 18) & 0x3f) | 0x80;\n                }\n                *q++ = ((c >> 12) & 0x3f) | 0x80;\n            }\n            *q++ = ((c >> 6) & 0x3f) | 0x80;\n        }\n        *q++ = (c & 0x3f) | 0x80;\n    }\n    return q - buf;\n}\n\nstatic const unsigned int utf8_min_code[5] = {\n    0x80, 0x800, 0x10000, 0x00200000, 0x04000000,\n};\n\nstatic const unsigned char utf8_first_code_mask[5] = {\n    0x1f, 0xf, 0x7, 0x3, 0x1,\n};\n\n/* return -1 if error. *pp is not updated in this case. max_len must\n   be >= 1. The maximum length for a UTF8 byte sequence is 6 bytes. */\nint unicode_from_utf8(const uint8_t *p, int max_len, const uint8_t **pp)\n{\n    int l, c, b, i;\n\n    c = *p++;\n    if (c < 0x80) {\n        *pp = p;\n        return c;\n    }\n    switch(c) {\n    case 0xc0: case 0xc1: case 0xc2: case 0xc3:\n    case 0xc4: case 0xc5: case 0xc6: case 0xc7:\n    case 0xc8: case 0xc9: case 0xca: case 0xcb:\n    case 0xcc: case 0xcd: case 0xce: case 0xcf:\n    case 0xd0: case 0xd1: case 0xd2: case 0xd3:\n    case 0xd4: case 0xd5: case 0xd6: case 0xd7:\n    case 0xd8: case 0xd9: case 0xda: case 0xdb:\n    case 0xdc: case 0xdd: case 0xde: case 0xdf:\n        l = 1;\n        break;\n    case 0xe0: case 0xe1: case 0xe2: case 0xe3:\n    case 0xe4: case 0xe5: case 0xe6: case 0xe7:\n    case 0xe8: case 0xe9: case 0xea: case 0xeb:\n    case 0xec: case 0xed: case 0xee: case 0xef:\n        l = 2;\n        break;\n    case 0xf0: case 0xf1: case 0xf2: case 0xf3:\n    case 0xf4: case 0xf5: case 0xf6: case 0xf7:\n        l = 3;\n        break;\n    case 0xf8: case 0xf9: case 0xfa: case 0xfb:\n        l = 4;\n        break;\n    case 0xfc: case 0xfd:\n        l = 5;\n        break;\n    default:\n        return -1;\n    }\n    /* check that we have enough characters */\n    if (l > (max_len - 1))\n        return -1;\n    c &= utf8_first_code_mask[l - 1];\n    for(i = 0; i < l; i++) {\n        b = *p++;\n        if (b < 0x80 || b >= 0xc0)\n            return -1;\n        c = (c << 6) | (b & 0x3f);\n    }\n    if (c < utf8_min_code[l - 1])\n        return -1;\n    *pp = p;\n    return c;\n}\n\n#if 0\n\n#if defined(EMSCRIPTEN) || defined(__ANDROID__)\n\nstatic void *rqsort_arg;\nstatic int (*rqsort_cmp)(const void *, const void *, void *);\n\nstatic int rqsort_cmp2(const void *p1, const void *p2)\n{\n    return rqsort_cmp(p1, p2, rqsort_arg);\n}\n\n/* not reentrant, but not needed with emscripten */\nvoid rqsort(void *base, size_t nmemb, size_t size,\n            int (*cmp)(const void *, const void *, void *),\n            void *arg)\n{\n    rqsort_arg = arg;\n    rqsort_cmp = cmp;\n    qsort(base, nmemb, size, rqsort_cmp2);\n}\n\n#endif\n\n#else\n\ntypedef void (*exchange_f)(void *a, void *b, size_t size);\ntypedef int (*cmp_f)(const void *, const void *, void *opaque);\n\nstatic void exchange_bytes(void *a, void *b, size_t size) {\n    uint8_t *ap = (uint8_t *)a;\n    uint8_t *bp = (uint8_t *)b;\n\n    while (size-- != 0) {\n        uint8_t t = *ap;\n        *ap++ = *bp;\n        *bp++ = t;\n    }\n}\n\nstatic void exchange_one_byte(void *a, void *b, size_t size) {\n    uint8_t *ap = (uint8_t *)a;\n    uint8_t *bp = (uint8_t *)b;\n    uint8_t t = *ap;\n    *ap = *bp;\n    *bp = t;\n}\n\nstatic void exchange_int16s(void *a, void *b, size_t size) {\n    uint16_t *ap = (uint16_t *)a;\n    uint16_t *bp = (uint16_t *)b;\n\n    for (size /= sizeof(uint16_t); size-- != 0;) {\n        uint16_t t = *ap;\n        *ap++ = *bp;\n        *bp++ = t;\n    }\n}\n\nstatic void exchange_one_int16(void *a, void *b, size_t size) {\n    uint16_t *ap = (uint16_t *)a;\n    uint16_t *bp = (uint16_t *)b;\n    uint16_t t = *ap;\n    *ap = *bp;\n    *bp = t;\n}\n\nstatic void exchange_int32s(void *a, void *b, size_t size) {\n    uint32_t *ap = (uint32_t *)a;\n    uint32_t *bp = (uint32_t *)b;\n\n    for (size /= sizeof(uint32_t); size-- != 0;) {\n        uint32_t t = *ap;\n        *ap++ = *bp;\n        *bp++ = t;\n    }\n}\n\nstatic void exchange_one_int32(void *a, void *b, size_t size) {\n    uint32_t *ap = (uint32_t *)a;\n    uint32_t *bp = (uint32_t *)b;\n    uint32_t t = *ap;\n    *ap = *bp;\n    *bp = t;\n}\n\nstatic void exchange_int64s(void *a, void *b, size_t size) {\n    uint64_t *ap = (uint64_t *)a;\n    uint64_t *bp = (uint64_t *)b;\n\n    for (size /= sizeof(uint64_t); size-- != 0;) {\n        uint64_t t = *ap;\n        *ap++ = *bp;\n        *bp++ = t;\n    }\n}\n\nstatic void exchange_one_int64(void *a, void *b, size_t size) {\n    uint64_t *ap = (uint64_t *)a;\n    uint64_t *bp = (uint64_t *)b;\n    uint64_t t = *ap;\n    *ap = *bp;\n    *bp = t;\n}\n\nstatic void exchange_int128s(void *a, void *b, size_t size) {\n    uint64_t *ap = (uint64_t *)a;\n    uint64_t *bp = (uint64_t *)b;\n\n    for (size /= sizeof(uint64_t) * 2; size-- != 0; ap += 2, bp += 2) {\n        uint64_t t = ap[0];\n        uint64_t u = ap[1];\n        ap[0] = bp[0];\n        ap[1] = bp[1];\n        bp[0] = t;\n        bp[1] = u;\n    }\n}\n\nstatic void exchange_one_int128(void *a, void *b, size_t size) {\n    uint64_t *ap = (uint64_t *)a;\n    uint64_t *bp = (uint64_t *)b;\n    uint64_t t = ap[0];\n    uint64_t u = ap[1];\n    ap[0] = bp[0];\n    ap[1] = bp[1];\n    bp[0] = t;\n    bp[1] = u;\n}\n\nstatic inline exchange_f exchange_func(const void *base, size_t size) {\n    switch (((uintptr_t)base | (uintptr_t)size) & 15) {\n    case 0:\n        if (size == sizeof(uint64_t) * 2)\n            return exchange_one_int128;\n        else\n            return exchange_int128s;\n    case 8:\n        if (size == sizeof(uint64_t))\n            return exchange_one_int64;\n        else\n            return exchange_int64s;\n    case 4:\n    case 12:\n        if (size == sizeof(uint32_t))\n            return exchange_one_int32;\n        else\n            return exchange_int32s;\n    case 2:\n    case 6:\n    case 10:\n    case 14:\n        if (size == sizeof(uint16_t))\n            return exchange_one_int16;\n        else\n            return exchange_int16s;\n    default:\n        if (size == 1)\n            return exchange_one_byte;\n        else\n            return exchange_bytes;\n    }\n}\n\nstatic void heapsortx(void *base, size_t nmemb, size_t size, cmp_f cmp, void *opaque)\n{\n    uint8_t *basep = (uint8_t *)base;\n    size_t i, n, c, r;\n    exchange_f swap = exchange_func(base, size);\n\n    if (nmemb > 1) {\n        i = (nmemb / 2) * size;\n        n = nmemb * size;\n\n        while (i > 0) {\n            i -= size;\n            for (r = i; (c = r * 2 + size) < n; r = c) {\n                if (c < n - size && cmp(basep + c, basep + c + size, opaque) <= 0)\n                    c += size;\n                if (cmp(basep + r, basep + c, opaque) > 0)\n                    break;\n                swap(basep + r, basep + c, size);\n            }\n        }\n        for (i = n - size; i > 0; i -= size) {\n            swap(basep, basep + i, size);\n\n            for (r = 0; (c = r * 2 + size) < i; r = c) {\n                if (c < i - size && cmp(basep + c, basep + c + size, opaque) <= 0)\n                    c += size;\n                if (cmp(basep + r, basep + c, opaque) > 0)\n                    break;\n                swap(basep + r, basep + c, size);\n            }\n        }\n    }\n}\n\nstatic inline void *med3(void *a, void *b, void *c, cmp_f cmp, void *opaque)\n{\n    return cmp(a, b, opaque) < 0 ?\n        (cmp(b, c, opaque) < 0 ? b : (cmp(a, c, opaque) < 0 ? c : a )) :\n        (cmp(b, c, opaque) > 0 ? b : (cmp(a, c, opaque) < 0 ? a : c ));\n}\n\n/* pointer based version with local stack and insertion sort threshhold */\nvoid rqsort(void *base, size_t nmemb, size_t size, cmp_f cmp, void *opaque)\n{\n    struct { uint8_t *base; size_t count; int depth; } stack[50], *sp = stack;\n    uint8_t *ptr, *pi, *pj, *plt, *pgt, *top, *m;\n    size_t m4, i, lt, gt, span, span2;\n    int c, depth;\n    exchange_f swap = exchange_func(base, size);\n    exchange_f swap_block = exchange_func(base, size | 128);\n\n    if (nmemb < 2 || size <= 0)\n        return;\n\n    sp->base = (uint8_t *)base;\n    sp->count = nmemb;\n    sp->depth = 0;\n    sp++;\n\n    while (sp > stack) {\n        sp--;\n        ptr = sp->base;\n        nmemb = sp->count;\n        depth = sp->depth;\n\n        while (nmemb > 6) {\n            if (++depth > 50) {\n                /* depth check to ensure worst case logarithmic time */\n                heapsortx(ptr, nmemb, size, cmp, opaque);\n                nmemb = 0;\n                break;\n            }\n            /* select median of 3 from 1/4, 1/2, 3/4 positions */\n            /* should use median of 5 or 9? */\n            m4 = (nmemb >> 2) * size;\n            m = med3(ptr + m4, ptr + 2 * m4, ptr + 3 * m4, cmp, opaque);\n            swap(ptr, m, size);  /* move the pivot to the start or the array */\n            i = lt = 1;\n            pi = plt = ptr + size;\n            gt = nmemb;\n            pj = pgt = top = ptr + nmemb * size;\n            for (;;) {\n                while (pi < pj && (c = cmp(ptr, pi, opaque)) >= 0) {\n                    if (c == 0) {\n                        swap(plt, pi, size);\n                        lt++;\n                        plt += size;\n                    }\n                    i++;\n                    pi += size;\n                }\n                while (pi < (pj -= size) && (c = cmp(ptr, pj, opaque)) <= 0) {\n                    if (c == 0) {\n                        gt--;\n                        pgt -= size;\n                        swap(pgt, pj, size);\n                    }\n                }\n                if (pi >= pj)\n                    break;\n                swap(pi, pj, size);\n                i++;\n                pi += size;\n            }\n            /* array has 4 parts:\n             * from 0 to lt excluded: elements identical to pivot\n             * from lt to pi excluded: elements smaller than pivot\n             * from pi to gt excluded: elements greater than pivot\n             * from gt to n excluded: elements identical to pivot\n             */\n            /* move elements identical to pivot in the middle of the array: */\n            /* swap values in ranges [0..lt[ and [i-lt..i[\n               swapping the smallest span between lt and i-lt is sufficient\n             */\n            span = plt - ptr;\n            span2 = pi - plt;\n            lt = i - lt;\n            if (span > span2)\n                span = span2;\n            swap_block(ptr, pi - span, span);\n            /* swap values in ranges [gt..top[ and [i..top-(top-gt)[\n               swapping the smallest span between top-gt and gt-i is sufficient\n             */\n            span = top - pgt;\n            span2 = pgt - pi;\n            pgt = top - span2;\n            gt = nmemb - (gt - i);\n            if (span > span2)\n                span = span2;\n            swap_block(pi, top - span, span);\n\n            /* now array has 3 parts:\n             * from 0 to lt excluded: elements smaller than pivot\n             * from lt to gt excluded: elements identical to pivot\n             * from gt to n excluded: elements greater than pivot\n             */\n            /* stack the larger segment and keep processing the smaller one\n               to minimize stack use for pathological distributions */\n            if (lt > nmemb - gt) {\n                sp->base = ptr;\n                sp->count = lt;\n                sp->depth = depth;\n                sp++;\n                ptr = pgt;\n                nmemb -= gt;\n            } else {\n                sp->base = pgt;\n                sp->count = nmemb - gt;\n                sp->depth = depth;\n                sp++;\n                nmemb = lt;\n            }\n        }\n        /* Use insertion sort for small fragments */\n        for (pi = ptr + size, top = ptr + nmemb * size; pi < top; pi += size) {\n            for (pj = pi; pj > ptr && cmp(pj - size, pj, opaque) > 0; pj -= size)\n                swap(pj, pj - size, size);\n        }\n    }\n}\n\n#endif\n"
        },
        {
          "name": "cutils.h",
          "type": "blob",
          "size": 8.4169921875,
          "content": "/*\n * C utilities\n *\n * Copyright (c) 2017 Fabrice Bellard\n * Copyright (c) 2018 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#ifndef CUTILS_H\n#define CUTILS_H\n\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n#define force_inline inline __attribute__((always_inline))\n#define no_inline __attribute__((noinline))\n#define __maybe_unused __attribute__((unused))\n\n#define xglue(x, y) x ## y\n#define glue(x, y) xglue(x, y)\n#define stringify(s)    tostring(s)\n#define tostring(s)     #s\n\n#ifndef offsetof\n#define offsetof(type, field) ((size_t) &((type *)0)->field)\n#endif\n#ifndef countof\n#define countof(x) (sizeof(x) / sizeof((x)[0]))\n#endif\n#ifndef container_of\n/* return the pointer of type 'type *' containing 'ptr' as field 'member' */\n#define container_of(ptr, type, member) ((type *)((uint8_t *)(ptr) - offsetof(type, member)))\n#endif\n\n#if !defined(_MSC_VER) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n#define minimum_length(n)  static n\n#else\n#define minimum_length(n)  n\n#endif\n\ntypedef int BOOL;\n\n#ifndef FALSE\nenum {\n    FALSE = 0,\n    TRUE = 1,\n};\n#endif\n\nvoid pstrcpy(char *buf, int buf_size, const char *str);\nchar *pstrcat(char *buf, int buf_size, const char *s);\nint strstart(const char *str, const char *val, const char **ptr);\nint has_suffix(const char *str, const char *suffix);\n\n/* Prevent UB when n == 0 and (src == NULL or dest == NULL) */\nstatic inline void memcpy_no_ub(void *dest, const void *src, size_t n) {\n    if (n)\n        memcpy(dest, src, n);\n}\n\nstatic inline int max_int(int a, int b)\n{\n    if (a > b)\n        return a;\n    else\n        return b;\n}\n\nstatic inline int min_int(int a, int b)\n{\n    if (a < b)\n        return a;\n    else\n        return b;\n}\n\nstatic inline uint32_t max_uint32(uint32_t a, uint32_t b)\n{\n    if (a > b)\n        return a;\n    else\n        return b;\n}\n\nstatic inline uint32_t min_uint32(uint32_t a, uint32_t b)\n{\n    if (a < b)\n        return a;\n    else\n        return b;\n}\n\nstatic inline int64_t max_int64(int64_t a, int64_t b)\n{\n    if (a > b)\n        return a;\n    else\n        return b;\n}\n\nstatic inline int64_t min_int64(int64_t a, int64_t b)\n{\n    if (a < b)\n        return a;\n    else\n        return b;\n}\n\n/* WARNING: undefined if a = 0 */\nstatic inline int clz32(unsigned int a)\n{\n    return __builtin_clz(a);\n}\n\n/* WARNING: undefined if a = 0 */\nstatic inline int clz64(uint64_t a)\n{\n    return __builtin_clzll(a);\n}\n\n/* WARNING: undefined if a = 0 */\nstatic inline int ctz32(unsigned int a)\n{\n    return __builtin_ctz(a);\n}\n\n/* WARNING: undefined if a = 0 */\nstatic inline int ctz64(uint64_t a)\n{\n    return __builtin_ctzll(a);\n}\n\nstruct __attribute__((packed)) packed_u64 {\n    uint64_t v;\n};\n\nstruct __attribute__((packed)) packed_u32 {\n    uint32_t v;\n};\n\nstruct __attribute__((packed)) packed_u16 {\n    uint16_t v;\n};\n\nstatic inline uint64_t get_u64(const uint8_t *tab)\n{\n    return ((const struct packed_u64 *)tab)->v;\n}\n\nstatic inline int64_t get_i64(const uint8_t *tab)\n{\n    return (int64_t)((const struct packed_u64 *)tab)->v;\n}\n\nstatic inline void put_u64(uint8_t *tab, uint64_t val)\n{\n    ((struct packed_u64 *)tab)->v = val;\n}\n\nstatic inline uint32_t get_u32(const uint8_t *tab)\n{\n    return ((const struct packed_u32 *)tab)->v;\n}\n\nstatic inline int32_t get_i32(const uint8_t *tab)\n{\n    return (int32_t)((const struct packed_u32 *)tab)->v;\n}\n\nstatic inline void put_u32(uint8_t *tab, uint32_t val)\n{\n    ((struct packed_u32 *)tab)->v = val;\n}\n\nstatic inline uint32_t get_u16(const uint8_t *tab)\n{\n    return ((const struct packed_u16 *)tab)->v;\n}\n\nstatic inline int32_t get_i16(const uint8_t *tab)\n{\n    return (int16_t)((const struct packed_u16 *)tab)->v;\n}\n\nstatic inline void put_u16(uint8_t *tab, uint16_t val)\n{\n    ((struct packed_u16 *)tab)->v = val;\n}\n\nstatic inline uint32_t get_u8(const uint8_t *tab)\n{\n    return *tab;\n}\n\nstatic inline int32_t get_i8(const uint8_t *tab)\n{\n    return (int8_t)*tab;\n}\n\nstatic inline void put_u8(uint8_t *tab, uint8_t val)\n{\n    *tab = val;\n}\n\n#ifndef bswap16\nstatic inline uint16_t bswap16(uint16_t x)\n{\n    return (x >> 8) | (x << 8);\n}\n#endif\n\n#ifndef bswap32\nstatic inline uint32_t bswap32(uint32_t v)\n{\n    return ((v & 0xff000000) >> 24) | ((v & 0x00ff0000) >>  8) |\n        ((v & 0x0000ff00) <<  8) | ((v & 0x000000ff) << 24);\n}\n#endif\n\n#ifndef bswap64\nstatic inline uint64_t bswap64(uint64_t v)\n{\n    return ((v & ((uint64_t)0xff << (7 * 8))) >> (7 * 8)) |\n        ((v & ((uint64_t)0xff << (6 * 8))) >> (5 * 8)) |\n        ((v & ((uint64_t)0xff << (5 * 8))) >> (3 * 8)) |\n        ((v & ((uint64_t)0xff << (4 * 8))) >> (1 * 8)) |\n        ((v & ((uint64_t)0xff << (3 * 8))) << (1 * 8)) |\n        ((v & ((uint64_t)0xff << (2 * 8))) << (3 * 8)) |\n        ((v & ((uint64_t)0xff << (1 * 8))) << (5 * 8)) |\n        ((v & ((uint64_t)0xff << (0 * 8))) << (7 * 8));\n}\n#endif\n\n/* XXX: should take an extra argument to pass slack information to the caller */\ntypedef void *DynBufReallocFunc(void *opaque, void *ptr, size_t size);\n\ntypedef struct DynBuf {\n    uint8_t *buf;\n    size_t size;\n    size_t allocated_size;\n    BOOL error; /* true if a memory allocation error occurred */\n    DynBufReallocFunc *realloc_func;\n    void *opaque; /* for realloc_func */\n} DynBuf;\n\nvoid dbuf_init(DynBuf *s);\nvoid dbuf_init2(DynBuf *s, void *opaque, DynBufReallocFunc *realloc_func);\nint dbuf_realloc(DynBuf *s, size_t new_size);\nint dbuf_write(DynBuf *s, size_t offset, const uint8_t *data, size_t len);\nint dbuf_put(DynBuf *s, const uint8_t *data, size_t len);\nint dbuf_put_self(DynBuf *s, size_t offset, size_t len);\nint dbuf_putc(DynBuf *s, uint8_t c);\nint dbuf_putstr(DynBuf *s, const char *str);\nstatic inline int dbuf_put_u16(DynBuf *s, uint16_t val)\n{\n    return dbuf_put(s, (uint8_t *)&val, 2);\n}\nstatic inline int dbuf_put_u32(DynBuf *s, uint32_t val)\n{\n    return dbuf_put(s, (uint8_t *)&val, 4);\n}\nstatic inline int dbuf_put_u64(DynBuf *s, uint64_t val)\n{\n    return dbuf_put(s, (uint8_t *)&val, 8);\n}\nint __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,\n                                                      const char *fmt, ...);\nvoid dbuf_free(DynBuf *s);\nstatic inline BOOL dbuf_error(DynBuf *s) {\n    return s->error;\n}\nstatic inline void dbuf_set_error(DynBuf *s)\n{\n    s->error = TRUE;\n}\n\n#define UTF8_CHAR_LEN_MAX 6\n\nint unicode_to_utf8(uint8_t *buf, unsigned int c);\nint unicode_from_utf8(const uint8_t *p, int max_len, const uint8_t **pp);\n\nstatic inline BOOL is_surrogate(uint32_t c)\n{\n    return (c >> 11) == (0xD800 >> 11); // 0xD800-0xDFFF\n}\n\nstatic inline BOOL is_hi_surrogate(uint32_t c)\n{\n    return (c >> 10) == (0xD800 >> 10); // 0xD800-0xDBFF\n}\n\nstatic inline BOOL is_lo_surrogate(uint32_t c)\n{\n    return (c >> 10) == (0xDC00 >> 10); // 0xDC00-0xDFFF\n}\n\nstatic inline uint32_t get_hi_surrogate(uint32_t c)\n{\n    return (c >> 10) - (0x10000 >> 10) + 0xD800;\n}\n\nstatic inline uint32_t get_lo_surrogate(uint32_t c)\n{\n    return (c & 0x3FF) | 0xDC00;\n}\n\nstatic inline uint32_t from_surrogate(uint32_t hi, uint32_t lo)\n{\n    return 0x10000 + 0x400 * (hi - 0xD800) + (lo - 0xDC00);\n}\n\nstatic inline int from_hex(int c)\n{\n    if (c >= '0' && c <= '9')\n        return c - '0';\n    else if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    else if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else\n        return -1;\n}\n\nvoid rqsort(void *base, size_t nmemb, size_t size,\n            int (*cmp)(const void *, const void *, void *),\n            void *arg);\n\n#endif  /* CUTILS_H */\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "libbf.c",
          "type": "blob",
          "size": 234.212890625,
          "content": "/*\n * Tiny arbitrary precision floating point library\n *\n * Copyright (c) 2017-2021 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <math.h>\n#include <string.h>\n#include <assert.h>\n\n#ifdef __AVX2__\n#include <immintrin.h>\n#endif\n\n#include \"cutils.h\"\n#include \"libbf.h\"\n\n/* enable it to check the multiplication result */\n//#define USE_MUL_CHECK\n#ifdef CONFIG_BIGNUM\n/* enable it to use FFT/NTT multiplication */\n#define USE_FFT_MUL\n/* enable decimal floating point support */\n#define USE_BF_DEC\n#endif\n\n//#define inline __attribute__((always_inline))\n\n#ifdef __AVX2__\n#define FFT_MUL_THRESHOLD 100 /* in limbs of the smallest factor */\n#else\n#define FFT_MUL_THRESHOLD 100 /* in limbs of the smallest factor */\n#endif\n\n/* XXX: adjust */\n#define DIVNORM_LARGE_THRESHOLD 50\n#define UDIV1NORM_THRESHOLD 3\n\n#if LIMB_BITS == 64\n#define FMT_LIMB1 \"%\" PRIx64\n#define FMT_LIMB \"%016\" PRIx64\n#define PRId_LIMB PRId64\n#define PRIu_LIMB PRIu64\n\n#else\n\n#define FMT_LIMB1 \"%x\"\n#define FMT_LIMB \"%08x\"\n#define PRId_LIMB \"d\"\n#define PRIu_LIMB \"u\"\n\n#endif\n\ntypedef intptr_t mp_size_t;\n\ntypedef int bf_op2_func_t(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n                          bf_flags_t flags);\n\n#ifdef USE_FFT_MUL\n\n#define FFT_MUL_R_OVERLAP_A (1 << 0)\n#define FFT_MUL_R_OVERLAP_B (1 << 1)\n#define FFT_MUL_R_NORESIZE  (1 << 2)\n\nstatic no_inline int fft_mul(bf_context_t *s,\n                             bf_t *res, limb_t *a_tab, limb_t a_len,\n                             limb_t *b_tab, limb_t b_len, int mul_flags);\nstatic void fft_clear_cache(bf_context_t *s);\n#endif\n#ifdef USE_BF_DEC\nstatic limb_t get_digit(const limb_t *tab, limb_t len, slimb_t pos);\n#endif\n\n\n/* could leading zeros */\nstatic inline int clz(limb_t a)\n{\n    if (a == 0) {\n        return LIMB_BITS;\n    } else {\n#if LIMB_BITS == 64\n        return clz64(a);\n#else\n        return clz32(a);\n#endif\n    }\n}\n\nstatic inline int ctz(limb_t a)\n{\n    if (a == 0) {\n        return LIMB_BITS;\n    } else {\n#if LIMB_BITS == 64\n        return ctz64(a);\n#else\n        return ctz32(a);\n#endif\n    }\n}\n\nstatic inline int ceil_log2(limb_t a)\n{\n    if (a <= 1)\n        return 0;\n    else\n        return LIMB_BITS - clz(a - 1);\n}\n\n/* b must be >= 1 */\nstatic inline slimb_t ceil_div(slimb_t a, slimb_t b)\n{\n    if (a >= 0)\n        return (a + b - 1) / b;\n    else\n        return a / b;\n}\n\n#ifdef USE_BF_DEC\n/* b must be >= 1 */\nstatic inline slimb_t floor_div(slimb_t a, slimb_t b)\n{\n    if (a >= 0) {\n        return a / b;\n    } else {\n        return (a - b + 1) / b;\n    }\n}\n#endif\n\n/* return r = a modulo b (0 <= r <= b - 1. b must be >= 1 */\nstatic inline limb_t smod(slimb_t a, slimb_t b)\n{\n    a = a % (slimb_t)b;\n    if (a < 0)\n        a += b;\n    return a;\n}\n\n/* signed addition with saturation */\nstatic inline slimb_t sat_add(slimb_t a, slimb_t b)\n{\n    slimb_t r;\n    r = a + b;\n    /* overflow ? */\n    if (((a ^ r) & (b ^ r)) < 0)\n        r = (a >> (LIMB_BITS - 1)) ^ (((limb_t)1 << (LIMB_BITS - 1)) - 1);\n    return r;\n}\n\nstatic inline __maybe_unused limb_t shrd(limb_t low, limb_t high, long shift)\n{\n    if (shift != 0)\n        low = (low >> shift) | (high << (LIMB_BITS - shift));\n    return low;\n}\n\nstatic inline __maybe_unused limb_t shld(limb_t a1, limb_t a0, long shift)\n{\n    if (shift != 0)\n        return (a1 << shift) | (a0 >> (LIMB_BITS - shift));\n    else\n        return a1;\n}\n\n#define malloc(s) malloc_is_forbidden(s)\n#define free(p) free_is_forbidden(p)\n#define realloc(p, s) realloc_is_forbidden(p, s)\n\nvoid bf_context_init(bf_context_t *s, bf_realloc_func_t *realloc_func,\n                     void *realloc_opaque)\n{\n    memset(s, 0, sizeof(*s));\n    s->realloc_func = realloc_func;\n    s->realloc_opaque = realloc_opaque;\n}\n\nvoid bf_context_end(bf_context_t *s)\n{\n    bf_clear_cache(s);\n}\n\nvoid bf_init(bf_context_t *s, bf_t *r)\n{\n    r->ctx = s;\n    r->sign = 0;\n    r->expn = BF_EXP_ZERO;\n    r->len = 0;\n    r->tab = NULL;\n}\n\n/* return 0 if OK, -1 if alloc error */\nint bf_resize(bf_t *r, limb_t len)\n{\n    limb_t *tab;\n\n    if (len != r->len) {\n        tab = bf_realloc(r->ctx, r->tab, len * sizeof(limb_t));\n        if (!tab && len != 0)\n            return -1;\n        r->tab = tab;\n        r->len = len;\n    }\n    return 0;\n}\n\n/* return 0 or BF_ST_MEM_ERROR */\nint bf_set_ui(bf_t *r, uint64_t a)\n{\n    r->sign = 0;\n    if (a == 0) {\n        r->expn = BF_EXP_ZERO;\n        bf_resize(r, 0); /* cannot fail */\n    }\n#if LIMB_BITS == 32\n    else if (a <= 0xffffffff)\n#else\n    else\n#endif\n    {\n        int shift;\n        if (bf_resize(r, 1))\n            goto fail;\n        shift = clz(a);\n        r->tab[0] = a << shift;\n        r->expn = LIMB_BITS - shift;\n    }\n#if LIMB_BITS == 32\n    else {\n        uint32_t a1, a0;\n        int shift;\n        if (bf_resize(r, 2))\n            goto fail;\n        a0 = a;\n        a1 = a >> 32;\n        shift = clz(a1);\n        r->tab[0] = a0 << shift;\n        r->tab[1] = shld(a1, a0, shift);\n        r->expn = 2 * LIMB_BITS - shift;\n    }\n#endif\n    return 0;\n fail:\n    bf_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}\n\n/* return 0 or BF_ST_MEM_ERROR */\nint bf_set_si(bf_t *r, int64_t a)\n{\n    int ret;\n\n    if (a < 0) {\n        ret = bf_set_ui(r, -a);\n        r->sign = 1;\n    } else {\n        ret = bf_set_ui(r, a);\n    }\n    return ret;\n}\n\nvoid bf_set_nan(bf_t *r)\n{\n    bf_resize(r, 0); /* cannot fail */\n    r->expn = BF_EXP_NAN;\n    r->sign = 0;\n}\n\nvoid bf_set_zero(bf_t *r, int is_neg)\n{\n    bf_resize(r, 0); /* cannot fail */\n    r->expn = BF_EXP_ZERO;\n    r->sign = is_neg;\n}\n\nvoid bf_set_inf(bf_t *r, int is_neg)\n{\n    bf_resize(r, 0); /* cannot fail */\n    r->expn = BF_EXP_INF;\n    r->sign = is_neg;\n}\n\n/* return 0 or BF_ST_MEM_ERROR */\nint bf_set(bf_t *r, const bf_t *a)\n{\n    if (r == a)\n        return 0;\n    if (bf_resize(r, a->len)) {\n        bf_set_nan(r);\n        return BF_ST_MEM_ERROR;\n    }\n    r->sign = a->sign;\n    r->expn = a->expn;\n    memcpy_no_ub(r->tab, a->tab, a->len * sizeof(limb_t));\n    return 0;\n}\n\n/* equivalent to bf_set(r, a); bf_delete(a) */\nvoid bf_move(bf_t *r, bf_t *a)\n{\n    bf_context_t *s = r->ctx;\n    if (r == a)\n        return;\n    bf_free(s, r->tab);\n    *r = *a;\n}\n\nstatic limb_t get_limbz(const bf_t *a, limb_t idx)\n{\n    if (idx >= a->len)\n        return 0;\n    else\n        return a->tab[idx];\n}\n\n/* get LIMB_BITS at bit position 'pos' in tab */\nstatic inline limb_t get_bits(const limb_t *tab, limb_t len, slimb_t pos)\n{\n    limb_t i, a0, a1;\n    int p;\n\n    i = pos >> LIMB_LOG2_BITS;\n    p = pos & (LIMB_BITS - 1);\n    if (i < len)\n        a0 = tab[i];\n    else\n        a0 = 0;\n    if (p == 0) {\n        return a0;\n    } else {\n        i++;\n        if (i < len)\n            a1 = tab[i];\n        else\n            a1 = 0;\n        return (a0 >> p) | (a1 << (LIMB_BITS - p));\n    }\n}\n\nstatic inline limb_t get_bit(const limb_t *tab, limb_t len, slimb_t pos)\n{\n    slimb_t i;\n    i = pos >> LIMB_LOG2_BITS;\n    if (i < 0 || i >= len)\n        return 0;\n    return (tab[i] >> (pos & (LIMB_BITS - 1))) & 1;\n}\n\nstatic inline limb_t limb_mask(int start, int last)\n{\n    limb_t v;\n    int n;\n    n = last - start + 1;\n    if (n == LIMB_BITS)\n        v = -1;\n    else\n        v = (((limb_t)1 << n) - 1) << start;\n    return v;\n}\n\nstatic limb_t mp_scan_nz(const limb_t *tab, mp_size_t n)\n{\n    mp_size_t i;\n    for(i = 0; i < n; i++) {\n        if (tab[i] != 0)\n            return 1;\n    }\n    return 0;\n}\n\n/* return != 0 if one bit between 0 and bit_pos inclusive is not zero. */\nstatic inline limb_t scan_bit_nz(const bf_t *r, slimb_t bit_pos)\n{\n    slimb_t pos;\n    limb_t v;\n\n    pos = bit_pos >> LIMB_LOG2_BITS;\n    if (pos < 0)\n        return 0;\n    v = r->tab[pos] & limb_mask(0, bit_pos & (LIMB_BITS - 1));\n    if (v != 0)\n        return 1;\n    pos--;\n    while (pos >= 0) {\n        if (r->tab[pos] != 0)\n            return 1;\n        pos--;\n    }\n    return 0;\n}\n\n/* return the addend for rounding. Note that prec can be <= 0 (for\n   BF_FLAG_RADPNT_PREC) */\nstatic int bf_get_rnd_add(int *pret, const bf_t *r, limb_t l,\n                          slimb_t prec, int rnd_mode)\n{\n    int add_one, inexact;\n    limb_t bit1, bit0;\n\n    if (rnd_mode == BF_RNDF) {\n        bit0 = 1; /* faithful rounding does not honor the INEXACT flag */\n    } else {\n        /* starting limb for bit 'prec + 1' */\n        bit0 = scan_bit_nz(r, l * LIMB_BITS - 1 - bf_max(0, prec + 1));\n    }\n\n    /* get the bit at 'prec' */\n    bit1 = get_bit(r->tab, l, l * LIMB_BITS - 1 - prec);\n    inexact = (bit1 | bit0) != 0;\n\n    add_one = 0;\n    switch(rnd_mode) {\n    case BF_RNDZ:\n        break;\n    case BF_RNDN:\n        if (bit1) {\n            if (bit0) {\n                add_one = 1;\n            } else {\n                /* round to even */\n                add_one =\n                    get_bit(r->tab, l, l * LIMB_BITS - 1 - (prec - 1));\n            }\n        }\n        break;\n    case BF_RNDD:\n    case BF_RNDU:\n        if (r->sign == (rnd_mode == BF_RNDD))\n            add_one = inexact;\n        break;\n    case BF_RNDA:\n        add_one = inexact;\n        break;\n    case BF_RNDNA:\n    case BF_RNDF:\n        add_one = bit1;\n        break;\n    default:\n        abort();\n    }\n\n    if (inexact)\n        *pret |= BF_ST_INEXACT;\n    return add_one;\n}\n\nstatic int bf_set_overflow(bf_t *r, int sign, limb_t prec, bf_flags_t flags)\n{\n    slimb_t i, l, e_max;\n    int rnd_mode;\n\n    rnd_mode = flags & BF_RND_MASK;\n    if (prec == BF_PREC_INF ||\n        rnd_mode == BF_RNDN ||\n        rnd_mode == BF_RNDNA ||\n        rnd_mode == BF_RNDA ||\n        (rnd_mode == BF_RNDD && sign == 1) ||\n        (rnd_mode == BF_RNDU && sign == 0)) {\n        bf_set_inf(r, sign);\n    } else {\n        /* set to maximum finite number */\n        l = (prec + LIMB_BITS - 1) / LIMB_BITS;\n        if (bf_resize(r, l)) {\n            bf_set_nan(r);\n            return BF_ST_MEM_ERROR;\n        }\n        r->tab[0] = limb_mask((-prec) & (LIMB_BITS - 1),\n                              LIMB_BITS - 1);\n        for(i = 1; i < l; i++)\n            r->tab[i] = (limb_t)-1;\n        e_max = (limb_t)1 << (bf_get_exp_bits(flags) - 1);\n        r->expn = e_max;\n        r->sign = sign;\n    }\n    return BF_ST_OVERFLOW | BF_ST_INEXACT;\n}\n\n/* round to prec1 bits assuming 'r' is non zero and finite. 'r' is\n   assumed to have length 'l' (1 <= l <= r->len). Note: 'prec1' can be\n   infinite (BF_PREC_INF). 'ret' is 0 or BF_ST_INEXACT if the result\n   is known to be inexact. Can fail with BF_ST_MEM_ERROR in case of\n   overflow not returning infinity. */\nstatic int __bf_round(bf_t *r, limb_t prec1, bf_flags_t flags, limb_t l,\n                      int ret)\n{\n    limb_t v, a;\n    int shift, add_one, rnd_mode;\n    slimb_t i, bit_pos, pos, e_min, e_max, e_range, prec;\n\n    /* e_min and e_max are computed to match the IEEE 754 conventions */\n    e_range = (limb_t)1 << (bf_get_exp_bits(flags) - 1);\n    e_min = -e_range + 3;\n    e_max = e_range;\n\n    if (flags & BF_FLAG_RADPNT_PREC) {\n        /* 'prec' is the precision after the radix point */\n        if (prec1 != BF_PREC_INF)\n            prec = r->expn + prec1;\n        else\n            prec = prec1;\n    } else if (unlikely(r->expn < e_min) && (flags & BF_FLAG_SUBNORMAL)) {\n        /* restrict the precision in case of potentially subnormal\n           result */\n        assert(prec1 != BF_PREC_INF);\n        prec = prec1 - (e_min - r->expn);\n    } else {\n        prec = prec1;\n    }\n\n    /* round to prec bits */\n    rnd_mode = flags & BF_RND_MASK;\n    add_one = bf_get_rnd_add(&ret, r, l, prec, rnd_mode);\n\n    if (prec <= 0) {\n        if (add_one) {\n            bf_resize(r, 1); /* cannot fail */\n            r->tab[0] = (limb_t)1 << (LIMB_BITS - 1);\n            r->expn += 1 - prec;\n            ret |= BF_ST_UNDERFLOW | BF_ST_INEXACT;\n            return ret;\n        } else {\n            goto underflow;\n        }\n    } else if (add_one) {\n        limb_t carry;\n\n        /* add one starting at digit 'prec - 1' */\n        bit_pos = l * LIMB_BITS - 1 - (prec - 1);\n        pos = bit_pos >> LIMB_LOG2_BITS;\n        carry = (limb_t)1 << (bit_pos & (LIMB_BITS - 1));\n\n        for(i = pos; i < l; i++) {\n            v = r->tab[i] + carry;\n            carry = (v < carry);\n            r->tab[i] = v;\n            if (carry == 0)\n                break;\n        }\n        if (carry) {\n            /* shift right by one digit */\n            v = 1;\n            for(i = l - 1; i >= pos; i--) {\n                a = r->tab[i];\n                r->tab[i] = (a >> 1) | (v << (LIMB_BITS - 1));\n                v = a;\n            }\n            r->expn++;\n        }\n    }\n\n    /* check underflow */\n    if (unlikely(r->expn < e_min)) {\n        if (flags & BF_FLAG_SUBNORMAL) {\n            /* if inexact, also set the underflow flag */\n            if (ret & BF_ST_INEXACT)\n                ret |= BF_ST_UNDERFLOW;\n        } else {\n        underflow:\n            ret |= BF_ST_UNDERFLOW | BF_ST_INEXACT;\n            bf_set_zero(r, r->sign);\n            return ret;\n        }\n    }\n\n    /* check overflow */\n    if (unlikely(r->expn > e_max))\n        return bf_set_overflow(r, r->sign, prec1, flags);\n\n    /* keep the bits starting at 'prec - 1' */\n    bit_pos = l * LIMB_BITS - 1 - (prec - 1);\n    i = bit_pos >> LIMB_LOG2_BITS;\n    if (i >= 0) {\n        shift = bit_pos & (LIMB_BITS - 1);\n        if (shift != 0)\n            r->tab[i] &= limb_mask(shift, LIMB_BITS - 1);\n    } else {\n        i = 0;\n    }\n    /* remove trailing zeros */\n    while (r->tab[i] == 0)\n        i++;\n    if (i > 0) {\n        l -= i;\n        memmove(r->tab, r->tab + i, l * sizeof(limb_t));\n    }\n    bf_resize(r, l); /* cannot fail */\n    return ret;\n}\n\n/* 'r' must be a finite number. */\nint bf_normalize_and_round(bf_t *r, limb_t prec1, bf_flags_t flags)\n{\n    limb_t l, v, a;\n    int shift, ret;\n    slimb_t i;\n\n    //    bf_print_str(\"bf_renorm\", r);\n    l = r->len;\n    while (l > 0 && r->tab[l - 1] == 0)\n        l--;\n    if (l == 0) {\n        /* zero */\n        r->expn = BF_EXP_ZERO;\n        bf_resize(r, 0); /* cannot fail */\n        ret = 0;\n    } else {\n        r->expn -= (r->len - l) * LIMB_BITS;\n        /* shift to have the MSB set to '1' */\n        v = r->tab[l - 1];\n        shift = clz(v);\n        if (shift != 0) {\n            v = 0;\n            for(i = 0; i < l; i++) {\n                a = r->tab[i];\n                r->tab[i] = (a << shift) | (v >> (LIMB_BITS - shift));\n                v = a;\n            }\n            r->expn -= shift;\n        }\n        ret = __bf_round(r, prec1, flags, l, 0);\n    }\n    //    bf_print_str(\"r_final\", r);\n    return ret;\n}\n\n/* return true if rounding can be done at precision 'prec' assuming\n   the exact result r is such that |r-a| <= 2^(EXP(a)-k). */\n/* XXX: check the case where the exponent would be incremented by the\n   rounding */\nint bf_can_round(const bf_t *a, slimb_t prec, bf_rnd_t rnd_mode, slimb_t k)\n{\n    BOOL is_rndn;\n    slimb_t bit_pos, n;\n    limb_t bit;\n\n    if (a->expn == BF_EXP_INF || a->expn == BF_EXP_NAN)\n        return FALSE;\n    if (rnd_mode == BF_RNDF) {\n        return (k >= (prec + 1));\n    }\n    if (a->expn == BF_EXP_ZERO)\n        return FALSE;\n    is_rndn = (rnd_mode == BF_RNDN || rnd_mode == BF_RNDNA);\n    if (k < (prec + 2))\n        return FALSE;\n    bit_pos = a->len * LIMB_BITS - 1 - prec;\n    n = k - prec;\n    /* bit pattern for RNDN or RNDNA: 0111.. or 1000...\n       for other rounding modes: 000... or 111...\n    */\n    bit = get_bit(a->tab, a->len, bit_pos);\n    bit_pos--;\n    n--;\n    bit ^= is_rndn;\n    /* XXX: slow, but a few iterations on average */\n    while (n != 0) {\n        if (get_bit(a->tab, a->len, bit_pos) != bit)\n            return TRUE;\n        bit_pos--;\n        n--;\n    }\n    return FALSE;\n}\n\n/* Cannot fail with BF_ST_MEM_ERROR. */\nint bf_round(bf_t *r, limb_t prec, bf_flags_t flags)\n{\n    if (r->len == 0)\n        return 0;\n    return __bf_round(r, prec, flags, r->len, 0);\n}\n\n/* for debugging */\nstatic __maybe_unused void dump_limbs(const char *str, const limb_t *tab, limb_t n)\n{\n    limb_t i;\n    printf(\"%s: len=%\" PRId_LIMB \"\\n\", str, n);\n    for(i = 0; i < n; i++) {\n        printf(\"%\" PRId_LIMB \": \" FMT_LIMB \"\\n\",\n               i, tab[i]);\n    }\n}\n\nvoid mp_print_str(const char *str, const limb_t *tab, limb_t n)\n{\n    slimb_t i;\n    printf(\"%s= 0x\", str);\n    for(i = n - 1; i >= 0; i--) {\n        if (i != (n - 1))\n            printf(\"_\");\n        printf(FMT_LIMB, tab[i]);\n    }\n    printf(\"\\n\");\n}\n\nstatic __maybe_unused void mp_print_str_h(const char *str,\n                                          const limb_t *tab, limb_t n,\n                                          limb_t high)\n{\n    slimb_t i;\n    printf(\"%s= 0x\", str);\n    printf(FMT_LIMB, high);\n    for(i = n - 1; i >= 0; i--) {\n        printf(\"_\");\n        printf(FMT_LIMB, tab[i]);\n    }\n    printf(\"\\n\");\n}\n\n/* for debugging */\nvoid bf_print_str(const char *str, const bf_t *a)\n{\n    slimb_t i;\n    printf(\"%s=\", str);\n\n    if (a->expn == BF_EXP_NAN) {\n        printf(\"NaN\");\n    } else {\n        if (a->sign)\n            putchar('-');\n        if (a->expn == BF_EXP_ZERO) {\n            putchar('0');\n        } else if (a->expn == BF_EXP_INF) {\n            printf(\"Inf\");\n        } else {\n            printf(\"0x0.\");\n            for(i = a->len - 1; i >= 0; i--)\n                printf(FMT_LIMB, a->tab[i]);\n            printf(\"p%\" PRId_LIMB, a->expn);\n        }\n    }\n    printf(\"\\n\");\n}\n\n/* compare the absolute value of 'a' and 'b'. Return < 0 if a < b, 0\n   if a = b and > 0 otherwise. */\nint bf_cmpu(const bf_t *a, const bf_t *b)\n{\n    slimb_t i;\n    limb_t len, v1, v2;\n\n    if (a->expn != b->expn) {\n        if (a->expn < b->expn)\n            return -1;\n        else\n            return 1;\n    }\n    len = bf_max(a->len, b->len);\n    for(i = len - 1; i >= 0; i--) {\n        v1 = get_limbz(a, a->len - len + i);\n        v2 = get_limbz(b, b->len - len + i);\n        if (v1 != v2) {\n            if (v1 < v2)\n                return -1;\n            else\n                return 1;\n        }\n    }\n    return 0;\n}\n\n/* Full order: -0 < 0, NaN == NaN and NaN is larger than all other numbers */\nint bf_cmp_full(const bf_t *a, const bf_t *b)\n{\n    int res;\n\n    if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {\n        if (a->expn == b->expn)\n            res = 0;\n        else if (a->expn == BF_EXP_NAN)\n            res = 1;\n        else\n            res = -1;\n    } else if (a->sign != b->sign) {\n        res = 1 - 2 * a->sign;\n    } else {\n        res = bf_cmpu(a, b);\n        if (a->sign)\n            res = -res;\n    }\n    return res;\n}\n\n/* Standard floating point comparison: return 2 if one of the operands\n   is NaN (unordered) or -1, 0, 1 depending on the ordering assuming\n   -0 == +0 */\nint bf_cmp(const bf_t *a, const bf_t *b)\n{\n    int res;\n\n    if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {\n        res = 2;\n    } else if (a->sign != b->sign) {\n        if (a->expn == BF_EXP_ZERO && b->expn == BF_EXP_ZERO)\n            res = 0;\n        else\n            res = 1 - 2 * a->sign;\n    } else {\n        res = bf_cmpu(a, b);\n        if (a->sign)\n            res = -res;\n    }\n    return res;\n}\n\n/* Compute the number of bits 'n' matching the pattern:\n   a= X1000..0\n   b= X0111..1\n\n   When computing a-b, the result will have at least n leading zero\n   bits.\n\n   Precondition: a > b and a.expn - b.expn = 0 or 1\n*/\nstatic limb_t count_cancelled_bits(const bf_t *a, const bf_t *b)\n{\n    slimb_t bit_offset, b_offset, n;\n    int p, p1;\n    limb_t v1, v2, mask;\n\n    bit_offset = a->len * LIMB_BITS - 1;\n    b_offset = (b->len - a->len) * LIMB_BITS - (LIMB_BITS - 1) +\n        a->expn - b->expn;\n    n = 0;\n\n    /* first search the equals bits */\n    for(;;) {\n        v1 = get_limbz(a, bit_offset >> LIMB_LOG2_BITS);\n        v2 = get_bits(b->tab, b->len, bit_offset + b_offset);\n        //        printf(\"v1=\" FMT_LIMB \" v2=\" FMT_LIMB \"\\n\", v1, v2);\n        if (v1 != v2)\n            break;\n        n += LIMB_BITS;\n        bit_offset -= LIMB_BITS;\n    }\n    /* find the position of the first different bit */\n    p = clz(v1 ^ v2) + 1;\n    n += p;\n    /* then search for '0' in a and '1' in b */\n    p = LIMB_BITS - p;\n    if (p > 0) {\n        /* search in the trailing p bits of v1 and v2 */\n        mask = limb_mask(0, p - 1);\n        p1 = bf_min(clz(v1 & mask), clz((~v2) & mask)) - (LIMB_BITS - p);\n        n += p1;\n        if (p1 != p)\n            goto done;\n    }\n    bit_offset -= LIMB_BITS;\n    for(;;) {\n        v1 = get_limbz(a, bit_offset >> LIMB_LOG2_BITS);\n        v2 = get_bits(b->tab, b->len, bit_offset + b_offset);\n        //        printf(\"v1=\" FMT_LIMB \" v2=\" FMT_LIMB \"\\n\", v1, v2);\n        if (v1 != 0 || v2 != -1) {\n            /* different: count the matching bits */\n            p1 = bf_min(clz(v1), clz(~v2));\n            n += p1;\n            break;\n        }\n        n += LIMB_BITS;\n        bit_offset -= LIMB_BITS;\n    }\n done:\n    return n;\n}\n\nstatic int bf_add_internal(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n                           bf_flags_t flags, int b_neg)\n{\n    const bf_t *tmp;\n    int is_sub, ret, cmp_res, a_sign, b_sign;\n\n    a_sign = a->sign;\n    b_sign = b->sign ^ b_neg;\n    is_sub = a_sign ^ b_sign;\n    cmp_res = bf_cmpu(a, b);\n    if (cmp_res < 0) {\n        tmp = a;\n        a = b;\n        b = tmp;\n        a_sign = b_sign; /* b_sign is never used later */\n    }\n    /* abs(a) >= abs(b) */\n    if (cmp_res == 0 && is_sub && a->expn < BF_EXP_INF) {\n        /* zero result */\n        bf_set_zero(r, (flags & BF_RND_MASK) == BF_RNDD);\n        ret = 0;\n    } else if (a->len == 0 || b->len == 0) {\n        ret = 0;\n        if (a->expn >= BF_EXP_INF) {\n            if (a->expn == BF_EXP_NAN) {\n                /* at least one operand is NaN */\n                bf_set_nan(r);\n            } else if (b->expn == BF_EXP_INF && is_sub) {\n                /* infinities with different signs */\n                bf_set_nan(r);\n                ret = BF_ST_INVALID_OP;\n            } else {\n                bf_set_inf(r, a_sign);\n            }\n        } else {\n            /* at least one zero and not subtract */\n            bf_set(r, a);\n            r->sign = a_sign;\n            goto renorm;\n        }\n    } else {\n        slimb_t d, a_offset, b_bit_offset, i, cancelled_bits;\n        limb_t carry, v1, v2, u, r_len, carry1, precl, tot_len, z, sub_mask;\n\n        r->sign = a_sign;\n        r->expn = a->expn;\n        d = a->expn - b->expn;\n        /* must add more precision for the leading cancelled bits in\n           subtraction */\n        if (is_sub) {\n            if (d <= 1)\n                cancelled_bits = count_cancelled_bits(a, b);\n            else\n                cancelled_bits = 1;\n        } else {\n            cancelled_bits = 0;\n        }\n\n        /* add two extra bits for rounding */\n        precl = (cancelled_bits + prec + 2 + LIMB_BITS - 1) / LIMB_BITS;\n        tot_len = bf_max(a->len, b->len + (d + LIMB_BITS - 1) / LIMB_BITS);\n        r_len = bf_min(precl, tot_len);\n        if (bf_resize(r, r_len))\n            goto fail;\n        a_offset = a->len - r_len;\n        b_bit_offset = (b->len - r_len) * LIMB_BITS + d;\n\n        /* compute the bits before for the rounding */\n        carry = is_sub;\n        z = 0;\n        sub_mask = -is_sub;\n        i = r_len - tot_len;\n        while (i < 0) {\n            slimb_t ap, bp;\n            BOOL inflag;\n\n            ap = a_offset + i;\n            bp = b_bit_offset + i * LIMB_BITS;\n            inflag = FALSE;\n            if (ap >= 0 && ap < a->len) {\n                v1 = a->tab[ap];\n                inflag = TRUE;\n            } else {\n                v1 = 0;\n            }\n            if (bp + LIMB_BITS > 0 && bp < (slimb_t)(b->len * LIMB_BITS)) {\n                v2 = get_bits(b->tab, b->len, bp);\n                inflag = TRUE;\n            } else {\n                v2 = 0;\n            }\n            if (!inflag) {\n                /* outside 'a' and 'b': go directly to the next value\n                   inside a or b so that the running time does not\n                   depend on the exponent difference */\n                i = 0;\n                if (ap < 0)\n                    i = bf_min(i, -a_offset);\n                /* b_bit_offset + i * LIMB_BITS + LIMB_BITS >= 1\n                   equivalent to\n                   i >= ceil(-b_bit_offset + 1 - LIMB_BITS) / LIMB_BITS)\n                */\n                if (bp + LIMB_BITS <= 0)\n                    i = bf_min(i, (-b_bit_offset) >> LIMB_LOG2_BITS);\n            } else {\n                i++;\n            }\n            v2 ^= sub_mask;\n            u = v1 + v2;\n            carry1 = u < v1;\n            u += carry;\n            carry = (u < carry) | carry1;\n            z |= u;\n        }\n        /* and the result */\n        for(i = 0; i < r_len; i++) {\n            v1 = get_limbz(a, a_offset + i);\n            v2 = get_bits(b->tab, b->len, b_bit_offset + i * LIMB_BITS);\n            v2 ^= sub_mask;\n            u = v1 + v2;\n            carry1 = u < v1;\n            u += carry;\n            carry = (u < carry) | carry1;\n            r->tab[i] = u;\n        }\n        /* set the extra bits for the rounding */\n        r->tab[0] |= (z != 0);\n\n        /* carry is only possible in add case */\n        if (!is_sub && carry) {\n            if (bf_resize(r, r_len + 1))\n                goto fail;\n            r->tab[r_len] = 1;\n            r->expn += LIMB_BITS;\n        }\n    renorm:\n        ret = bf_normalize_and_round(r, prec, flags);\n    }\n    return ret;\n fail:\n    bf_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}\n\nstatic int __bf_add(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n                     bf_flags_t flags)\n{\n    return bf_add_internal(r, a, b, prec, flags, 0);\n}\n\nstatic int __bf_sub(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n                     bf_flags_t flags)\n{\n    return bf_add_internal(r, a, b, prec, flags, 1);\n}\n\nlimb_t mp_add(limb_t *res, const limb_t *op1, const limb_t *op2,\n              limb_t n, limb_t carry)\n{\n    slimb_t i;\n    limb_t k, a, v, k1;\n\n    k = carry;\n    for(i=0;i<n;i++) {\n        v = op1[i];\n        a = v + op2[i];\n        k1 = a < v;\n        a = a + k;\n        k = (a < k) | k1;\n        res[i] = a;\n    }\n    return k;\n}\n\nlimb_t mp_add_ui(limb_t *tab, limb_t b, size_t n)\n{\n    size_t i;\n    limb_t k, a;\n\n    k=b;\n    for(i=0;i<n;i++) {\n        if (k == 0)\n            break;\n        a = tab[i] + k;\n        k = (a < k);\n        tab[i] = a;\n    }\n    return k;\n}\n\nlimb_t mp_sub(limb_t *res, const limb_t *op1, const limb_t *op2,\n              mp_size_t n, limb_t carry)\n{\n    int i;\n    limb_t k, a, v, k1;\n\n    k = carry;\n    for(i=0;i<n;i++) {\n        v = op1[i];\n        a = v - op2[i];\n        k1 = a > v;\n        v = a - k;\n        k = (v > a) | k1;\n        res[i] = v;\n    }\n    return k;\n}\n\n/* compute 0 - op2 */\nstatic limb_t mp_neg(limb_t *res, const limb_t *op2, mp_size_t n, limb_t carry)\n{\n    int i;\n    limb_t k, a, v, k1;\n\n    k = carry;\n    for(i=0;i<n;i++) {\n        v = 0;\n        a = v - op2[i];\n        k1 = a > v;\n        v = a - k;\n        k = (v > a) | k1;\n        res[i] = v;\n    }\n    return k;\n}\n\nlimb_t mp_sub_ui(limb_t *tab, limb_t b, mp_size_t n)\n{\n    mp_size_t i;\n    limb_t k, a, v;\n\n    k=b;\n    for(i=0;i<n;i++) {\n        v = tab[i];\n        a = v - k;\n        k = a > v;\n        tab[i] = a;\n        if (k == 0)\n            break;\n    }\n    return k;\n}\n\n/* r = (a + high*B^n) >> shift. Return the remainder r (0 <= r < 2^shift).\n   1 <= shift <= LIMB_BITS - 1 */\nstatic limb_t mp_shr(limb_t *tab_r, const limb_t *tab, mp_size_t n,\n                     int shift, limb_t high)\n{\n    mp_size_t i;\n    limb_t l, a;\n\n    assert(shift >= 1 && shift < LIMB_BITS);\n    l = high;\n    for(i = n - 1; i >= 0; i--) {\n        a = tab[i];\n        tab_r[i] = (a >> shift) | (l << (LIMB_BITS - shift));\n        l = a;\n    }\n    return l & (((limb_t)1 << shift) - 1);\n}\n\n/* tabr[] = taba[] * b + l. Return the high carry */\nstatic limb_t mp_mul1(limb_t *tabr, const limb_t *taba, limb_t n,\n                      limb_t b, limb_t l)\n{\n    limb_t i;\n    dlimb_t t;\n\n    for(i = 0; i < n; i++) {\n        t = (dlimb_t)taba[i] * (dlimb_t)b + l;\n        tabr[i] = t;\n        l = t >> LIMB_BITS;\n    }\n    return l;\n}\n\n/* tabr[] += taba[] * b, return the high word. */\nstatic limb_t mp_add_mul1(limb_t *tabr, const limb_t *taba, limb_t n,\n                          limb_t b)\n{\n    limb_t i, l;\n    dlimb_t t;\n\n    l = 0;\n    for(i = 0; i < n; i++) {\n        t = (dlimb_t)taba[i] * (dlimb_t)b + l + tabr[i];\n        tabr[i] = t;\n        l = t >> LIMB_BITS;\n    }\n    return l;\n}\n\n/* size of the result : op1_size + op2_size. */\nstatic void mp_mul_basecase(limb_t *result,\n                            const limb_t *op1, limb_t op1_size,\n                            const limb_t *op2, limb_t op2_size)\n{\n    limb_t i, r;\n\n    result[op1_size] = mp_mul1(result, op1, op1_size, op2[0], 0);\n    for(i=1;i<op2_size;i++) {\n        r = mp_add_mul1(result + i, op1, op1_size, op2[i]);\n        result[i + op1_size] = r;\n    }\n}\n\n/* return 0 if OK, -1 if memory error */\n/* XXX: change API so that result can be allocated */\nint mp_mul(bf_context_t *s, limb_t *result,\n           const limb_t *op1, limb_t op1_size,\n           const limb_t *op2, limb_t op2_size)\n{\n#ifdef USE_FFT_MUL\n    if (unlikely(bf_min(op1_size, op2_size) >= FFT_MUL_THRESHOLD)) {\n        bf_t r_s, *r = &r_s;\n        r->tab = result;\n        /* XXX: optimize memory usage in API */\n        if (fft_mul(s, r, (limb_t *)op1, op1_size,\n                    (limb_t *)op2, op2_size, FFT_MUL_R_NORESIZE))\n            return -1;\n    } else\n#endif\n    {\n        mp_mul_basecase(result, op1, op1_size, op2, op2_size);\n    }\n    return 0;\n}\n\n/* tabr[] -= taba[] * b. Return the value to substract to the high\n   word. */\nstatic limb_t mp_sub_mul1(limb_t *tabr, const limb_t *taba, limb_t n,\n                          limb_t b)\n{\n    limb_t i, l;\n    dlimb_t t;\n\n    l = 0;\n    for(i = 0; i < n; i++) {\n        t = tabr[i] - (dlimb_t)taba[i] * (dlimb_t)b - l;\n        tabr[i] = t;\n        l = -(t >> LIMB_BITS);\n    }\n    return l;\n}\n\n/* WARNING: d must be >= 2^(LIMB_BITS-1) */\nstatic inline limb_t udiv1norm_init(limb_t d)\n{\n    limb_t a0, a1;\n    a1 = -d - 1;\n    a0 = -1;\n    return (((dlimb_t)a1 << LIMB_BITS) | a0) / d;\n}\n\n/* return the quotient and the remainder in '*pr'of 'a1*2^LIMB_BITS+a0\n   / d' with 0 <= a1 < d. */\nstatic inline limb_t udiv1norm(limb_t *pr, limb_t a1, limb_t a0,\n                                limb_t d, limb_t d_inv)\n{\n    limb_t n1m, n_adj, q, r, ah;\n    dlimb_t a;\n    n1m = ((slimb_t)a0 >> (LIMB_BITS - 1));\n    n_adj = a0 + (n1m & d);\n    a = (dlimb_t)d_inv * (a1 - n1m) + n_adj;\n    q = (a >> LIMB_BITS) + a1;\n    /* compute a - q * r and update q so that the remainder is\\\n       between 0 and d - 1 */\n    a = ((dlimb_t)a1 << LIMB_BITS) | a0;\n    a = a - (dlimb_t)q * d - d;\n    ah = a >> LIMB_BITS;\n    q += 1 + ah;\n    r = (limb_t)a + (ah & d);\n    *pr = r;\n    return q;\n}\n\n/* b must be >= 1 << (LIMB_BITS - 1) */\nstatic limb_t mp_div1norm(limb_t *tabr, const limb_t *taba, limb_t n,\n                          limb_t b, limb_t r)\n{\n    slimb_t i;\n\n    if (n >= UDIV1NORM_THRESHOLD) {\n        limb_t b_inv;\n        b_inv = udiv1norm_init(b);\n        for(i = n - 1; i >= 0; i--) {\n            tabr[i] = udiv1norm(&r, r, taba[i], b, b_inv);\n        }\n    } else {\n        dlimb_t a1;\n        for(i = n - 1; i >= 0; i--) {\n            a1 = ((dlimb_t)r << LIMB_BITS) | taba[i];\n            tabr[i] = a1 / b;\n            r = a1 % b;\n        }\n    }\n    return r;\n}\n\nstatic int mp_divnorm_large(bf_context_t *s,\n                            limb_t *tabq, limb_t *taba, limb_t na,\n                            const limb_t *tabb, limb_t nb);\n\n/* base case division: divides taba[0..na-1] by tabb[0..nb-1]. tabb[nb\n   - 1] must be >= 1 << (LIMB_BITS - 1). na - nb must be >= 0. 'taba'\n   is modified and contains the remainder (nb limbs). tabq[0..na-nb]\n   contains the quotient with tabq[na - nb] <= 1. */\nstatic int mp_divnorm(bf_context_t *s, limb_t *tabq, limb_t *taba, limb_t na,\n                      const limb_t *tabb, limb_t nb)\n{\n    limb_t r, a, c, q, v, b1, b1_inv, n, dummy_r;\n    slimb_t i, j;\n\n    b1 = tabb[nb - 1];\n    if (nb == 1) {\n        taba[0] = mp_div1norm(tabq, taba, na, b1, 0);\n        return 0;\n    }\n    n = na - nb;\n    if (bf_min(n, nb) >= DIVNORM_LARGE_THRESHOLD) {\n        return mp_divnorm_large(s, tabq, taba, na, tabb, nb);\n    }\n\n    if (n >= UDIV1NORM_THRESHOLD)\n        b1_inv = udiv1norm_init(b1);\n    else\n        b1_inv = 0;\n\n    /* first iteration: the quotient is only 0 or 1 */\n    q = 1;\n    for(j = nb - 1; j >= 0; j--) {\n        if (taba[n + j] != tabb[j]) {\n            if (taba[n + j] < tabb[j])\n                q = 0;\n            break;\n        }\n    }\n    tabq[n] = q;\n    if (q) {\n        mp_sub(taba + n, taba + n, tabb, nb, 0);\n    }\n\n    for(i = n - 1; i >= 0; i--) {\n        if (unlikely(taba[i + nb] >= b1)) {\n            q = -1;\n        } else if (b1_inv) {\n            q = udiv1norm(&dummy_r, taba[i + nb], taba[i + nb - 1], b1, b1_inv);\n        } else {\n            dlimb_t al;\n            al = ((dlimb_t)taba[i + nb] << LIMB_BITS) | taba[i + nb - 1];\n            q = al / b1;\n            r = al % b1;\n        }\n        r = mp_sub_mul1(taba + i, tabb, nb, q);\n\n        v = taba[i + nb];\n        a = v - r;\n        c = (a > v);\n        taba[i + nb] = a;\n\n        if (c != 0) {\n            /* negative result */\n            for(;;) {\n                q--;\n                c = mp_add(taba + i, taba + i, tabb, nb, 0);\n                /* propagate carry and test if positive result */\n                if (c != 0) {\n                    if (++taba[i + nb] == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n        tabq[i] = q;\n    }\n    return 0;\n}\n\n/* compute r=B^(2*n)/a such as a*r < B^(2*n) < a*r + 2 with n >= 1. 'a'\n   has n limbs with a[n-1] >= B/2 and 'r' has n+1 limbs with r[n] = 1.\n\n   See Modern Computer Arithmetic by Richard P. Brent and Paul\n   Zimmermann, algorithm 3.5 */\nint mp_recip(bf_context_t *s, limb_t *tabr, const limb_t *taba, limb_t n)\n{\n    mp_size_t l, h, k, i;\n    limb_t *tabxh, *tabt, c, *tabu;\n\n    if (n <= 2) {\n        /* return ceil(B^(2*n)/a) - 1 */\n        /* XXX: could avoid allocation */\n        tabu = bf_malloc(s, sizeof(limb_t) * (2 * n + 1));\n        tabt = bf_malloc(s, sizeof(limb_t) * (n + 2));\n        if (!tabt || !tabu)\n            goto fail;\n        for(i = 0; i < 2 * n; i++)\n            tabu[i] = 0;\n        tabu[2 * n] = 1;\n        if (mp_divnorm(s, tabt, tabu, 2 * n + 1, taba, n))\n            goto fail;\n        for(i = 0; i < n + 1; i++)\n            tabr[i] = tabt[i];\n        if (mp_scan_nz(tabu, n) == 0) {\n            /* only happens for a=B^n/2 */\n            mp_sub_ui(tabr, 1, n + 1);\n        }\n    } else {\n        l = (n - 1) / 2;\n        h = n - l;\n        /* n=2p  -> l=p-1, h = p + 1, k = p + 3\n           n=2p+1-> l=p,  h = p + 1; k = p + 2\n        */\n        tabt = bf_malloc(s, sizeof(limb_t) * (n + h + 1));\n        tabu = bf_malloc(s, sizeof(limb_t) * (n + 2 * h - l + 2));\n        if (!tabt || !tabu)\n            goto fail;\n        tabxh = tabr + l;\n        if (mp_recip(s, tabxh, taba + l, h))\n            goto fail;\n        if (mp_mul(s, tabt, taba, n, tabxh, h + 1)) /* n + h + 1 limbs */\n            goto fail;\n        while (tabt[n + h] != 0) {\n            mp_sub_ui(tabxh, 1, h + 1);\n            c = mp_sub(tabt, tabt, taba, n, 0);\n            mp_sub_ui(tabt + n, c, h + 1);\n        }\n        /* T = B^(n+h) - T */\n        mp_neg(tabt, tabt, n + h + 1, 0);\n        tabt[n + h]++;\n        if (mp_mul(s, tabu, tabt + l, n + h + 1 - l, tabxh, h + 1))\n            goto fail;\n        /* n + 2*h - l + 2 limbs */\n        k = 2 * h - l;\n        for(i = 0; i < l; i++)\n            tabr[i] = tabu[i + k];\n        mp_add(tabr + l, tabr + l, tabu + 2 * h, h, 0);\n    }\n    bf_free(s, tabt);\n    bf_free(s, tabu);\n    return 0;\n fail:\n    bf_free(s, tabt);\n    bf_free(s, tabu);\n    return -1;\n}\n\n/* return -1, 0 or 1 */\nstatic int mp_cmp(const limb_t *taba, const limb_t *tabb, mp_size_t n)\n{\n    mp_size_t i;\n    for(i = n - 1; i >= 0; i--) {\n        if (taba[i] != tabb[i]) {\n            if (taba[i] < tabb[i])\n                return -1;\n            else\n                return 1;\n        }\n    }\n    return 0;\n}\n\n//#define DEBUG_DIVNORM_LARGE\n//#define DEBUG_DIVNORM_LARGE2\n\n/* subquadratic divnorm */\nstatic int mp_divnorm_large(bf_context_t *s,\n                            limb_t *tabq, limb_t *taba, limb_t na,\n                            const limb_t *tabb, limb_t nb)\n{\n    limb_t *tabb_inv, nq, *tabt, i, n;\n    nq = na - nb;\n#ifdef DEBUG_DIVNORM_LARGE\n    printf(\"na=%d nb=%d nq=%d\\n\", (int)na, (int)nb, (int)nq);\n    mp_print_str(\"a\", taba, na);\n    mp_print_str(\"b\", tabb, nb);\n#endif\n    assert(nq >= 1);\n    n = nq;\n    if (nq < nb)\n        n++;\n    tabb_inv = bf_malloc(s, sizeof(limb_t) * (n + 1));\n    tabt = bf_malloc(s, sizeof(limb_t) * 2 * (n + 1));\n    if (!tabb_inv || !tabt)\n        goto fail;\n\n    if (n >= nb) {\n        for(i = 0; i < n - nb; i++)\n            tabt[i] = 0;\n        for(i = 0; i < nb; i++)\n            tabt[i + n - nb] = tabb[i];\n    } else {\n        /* truncate B: need to increment it so that the approximate\n           inverse is smaller that the exact inverse */\n        for(i = 0; i < n; i++)\n            tabt[i] = tabb[i + nb - n];\n        if (mp_add_ui(tabt, 1, n)) {\n            /* tabt = B^n : tabb_inv = B^n */\n            memset(tabb_inv, 0, n * sizeof(limb_t));\n            tabb_inv[n] = 1;\n            goto recip_done;\n        }\n    }\n    if (mp_recip(s, tabb_inv, tabt, n))\n        goto fail;\n recip_done:\n    /* Q=A*B^-1 */\n    if (mp_mul(s, tabt, tabb_inv, n + 1, taba + na - (n + 1), n + 1))\n        goto fail;\n\n    for(i = 0; i < nq + 1; i++)\n        tabq[i] = tabt[i + 2 * (n + 1) - (nq + 1)];\n#ifdef DEBUG_DIVNORM_LARGE\n    mp_print_str(\"q\", tabq, nq + 1);\n#endif\n\n    bf_free(s, tabt);\n    bf_free(s, tabb_inv);\n    tabb_inv = NULL;\n\n    /* R=A-B*Q */\n    tabt = bf_malloc(s, sizeof(limb_t) * (na + 1));\n    if (!tabt)\n        goto fail;\n    if (mp_mul(s, tabt, tabq, nq + 1, tabb, nb))\n        goto fail;\n    /* we add one more limb for the result */\n    mp_sub(taba, taba, tabt, nb + 1, 0);\n    bf_free(s, tabt);\n    /* the approximated quotient is smaller than than the exact one,\n       hence we may have to increment it */\n#ifdef DEBUG_DIVNORM_LARGE2\n    int cnt = 0;\n    static int cnt_max;\n#endif\n    for(;;) {\n        if (taba[nb] == 0 && mp_cmp(taba, tabb, nb) < 0)\n            break;\n        taba[nb] -= mp_sub(taba, taba, tabb, nb, 0);\n        mp_add_ui(tabq, 1, nq + 1);\n#ifdef DEBUG_DIVNORM_LARGE2\n        cnt++;\n#endif\n    }\n#ifdef DEBUG_DIVNORM_LARGE2\n    if (cnt > cnt_max) {\n        cnt_max = cnt;\n        printf(\"\\ncnt=%d nq=%d nb=%d\\n\", cnt_max, (int)nq, (int)nb);\n    }\n#endif\n    return 0;\n fail:\n    bf_free(s, tabb_inv);\n    bf_free(s, tabt);\n    return -1;\n}\n\nint bf_mul(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n           bf_flags_t flags)\n{\n    int ret, r_sign;\n\n    if (a->len < b->len) {\n        const bf_t *tmp = a;\n        a = b;\n        b = tmp;\n    }\n    r_sign = a->sign ^ b->sign;\n    /* here b->len <= a->len */\n    if (b->len == 0) {\n        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n            ret = 0;\n        } else if (a->expn == BF_EXP_INF || b->expn == BF_EXP_INF) {\n            if ((a->expn == BF_EXP_INF && b->expn == BF_EXP_ZERO) ||\n                (a->expn == BF_EXP_ZERO && b->expn == BF_EXP_INF)) {\n                bf_set_nan(r);\n                ret = BF_ST_INVALID_OP;\n            } else {\n                bf_set_inf(r, r_sign);\n                ret = 0;\n            }\n        } else {\n            bf_set_zero(r, r_sign);\n            ret = 0;\n        }\n    } else {\n        bf_t tmp, *r1 = NULL;\n        limb_t a_len, b_len, precl;\n        limb_t *a_tab, *b_tab;\n\n        a_len = a->len;\n        b_len = b->len;\n\n        if ((flags & BF_RND_MASK) == BF_RNDF) {\n            /* faithful rounding does not require using the full inputs */\n            precl = (prec + 2 + LIMB_BITS - 1) / LIMB_BITS;\n            a_len = bf_min(a_len, precl);\n            b_len = bf_min(b_len, precl);\n        }\n        a_tab = a->tab + a->len - a_len;\n        b_tab = b->tab + b->len - b_len;\n\n#ifdef USE_FFT_MUL\n        if (b_len >= FFT_MUL_THRESHOLD) {\n            int mul_flags = 0;\n            if (r == a)\n                mul_flags |= FFT_MUL_R_OVERLAP_A;\n            if (r == b)\n                mul_flags |= FFT_MUL_R_OVERLAP_B;\n            if (fft_mul(r->ctx, r, a_tab, a_len, b_tab, b_len, mul_flags))\n                goto fail;\n        } else\n#endif\n        {\n            if (r == a || r == b) {\n                bf_init(r->ctx, &tmp);\n                r1 = r;\n                r = &tmp;\n            }\n            if (bf_resize(r, a_len + b_len)) {\n#ifdef USE_FFT_MUL\n            fail:\n#endif\n                bf_set_nan(r);\n                ret = BF_ST_MEM_ERROR;\n                goto done;\n            }\n            mp_mul_basecase(r->tab, a_tab, a_len, b_tab, b_len);\n        }\n        r->sign = r_sign;\n        r->expn = a->expn + b->expn;\n        ret = bf_normalize_and_round(r, prec, flags);\n    done:\n        if (r == &tmp)\n            bf_move(r1, &tmp);\n    }\n    return ret;\n}\n\n/* multiply 'r' by 2^e */\nint bf_mul_2exp(bf_t *r, slimb_t e, limb_t prec, bf_flags_t flags)\n{\n    slimb_t e_max;\n    if (r->len == 0)\n        return 0;\n    e_max = ((limb_t)1 << BF_EXT_EXP_BITS_MAX) - 1;\n    e = bf_max(e, -e_max);\n    e = bf_min(e, e_max);\n    r->expn += e;\n    return __bf_round(r, prec, flags, r->len, 0);\n}\n\n/* Return e such as a=m*2^e with m odd integer. return 0 if a is zero,\n   Infinite or Nan. */\nslimb_t bf_get_exp_min(const bf_t *a)\n{\n    slimb_t i;\n    limb_t v;\n    int k;\n\n    for(i = 0; i < a->len; i++) {\n        v = a->tab[i];\n        if (v != 0) {\n            k = ctz(v);\n            return a->expn - (a->len - i) * LIMB_BITS + k;\n        }\n    }\n    return 0;\n}\n\n/* a and b must be finite numbers with a >= 0 and b > 0. 'q' is the\n   integer defined as floor(a/b) and r = a - q * b. */\nstatic void bf_tdivremu(bf_t *q, bf_t *r,\n                        const bf_t *a, const bf_t *b)\n{\n    if (bf_cmpu(a, b) < 0) {\n        bf_set_ui(q, 0);\n        bf_set(r, a);\n    } else {\n        bf_div(q, a, b, bf_max(a->expn - b->expn + 1, 2), BF_RNDZ);\n        bf_rint(q, BF_RNDZ);\n        bf_mul(r, q, b, BF_PREC_INF, BF_RNDZ);\n        bf_sub(r, a, r, BF_PREC_INF, BF_RNDZ);\n    }\n}\n\nstatic int __bf_div(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n                    bf_flags_t flags)\n{\n    bf_context_t *s = r->ctx;\n    int ret, r_sign;\n    limb_t n, nb, precl;\n\n    r_sign = a->sign ^ b->sign;\n    if (a->expn >= BF_EXP_INF || b->expn >= BF_EXP_INF) {\n        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF && b->expn == BF_EXP_INF) {\n            bf_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else if (a->expn == BF_EXP_INF) {\n            bf_set_inf(r, r_sign);\n            return 0;\n        } else {\n            bf_set_zero(r, r_sign);\n            return 0;\n        }\n    } else if (a->expn == BF_EXP_ZERO) {\n        if (b->expn == BF_EXP_ZERO) {\n            bf_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else {\n            bf_set_zero(r, r_sign);\n            return 0;\n        }\n    } else if (b->expn == BF_EXP_ZERO) {\n        bf_set_inf(r, r_sign);\n        return BF_ST_DIVIDE_ZERO;\n    }\n\n    /* number of limbs of the quotient (2 extra bits for rounding) */\n    precl = (prec + 2 + LIMB_BITS - 1) / LIMB_BITS;\n    nb = b->len;\n    n = bf_max(a->len, precl);\n\n    {\n        limb_t *taba, na;\n        slimb_t d;\n\n        na = n + nb;\n        taba = bf_malloc(s, (na + 1) * sizeof(limb_t));\n        if (!taba)\n            goto fail;\n        d = na - a->len;\n        memset(taba, 0, d * sizeof(limb_t));\n        memcpy(taba + d, a->tab, a->len * sizeof(limb_t));\n        if (bf_resize(r, n + 1))\n            goto fail1;\n        if (mp_divnorm(s, r->tab, taba, na, b->tab, nb)) {\n        fail1:\n            bf_free(s, taba);\n            goto fail;\n        }\n        /* see if non zero remainder */\n        if (mp_scan_nz(taba, nb))\n            r->tab[0] |= 1;\n        bf_free(r->ctx, taba);\n        r->expn = a->expn - b->expn + LIMB_BITS;\n        r->sign = r_sign;\n        ret = bf_normalize_and_round(r, prec, flags);\n    }\n    return ret;\n fail:\n    bf_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}\n\n/* division and remainder.\n\n   rnd_mode is the rounding mode for the quotient. The additional\n   rounding mode BF_RND_EUCLIDIAN is supported.\n\n   'q' is an integer. 'r' is rounded with prec and flags (prec can be\n   BF_PREC_INF).\n*/\nint bf_divrem(bf_t *q, bf_t *r, const bf_t *a, const bf_t *b,\n              limb_t prec, bf_flags_t flags, int rnd_mode)\n{\n    bf_t a1_s, *a1 = &a1_s;\n    bf_t b1_s, *b1 = &b1_s;\n    int q_sign, ret;\n    BOOL is_ceil, is_rndn;\n\n    assert(q != a && q != b);\n    assert(r != a && r != b);\n    assert(q != r);\n\n    if (a->len == 0 || b->len == 0) {\n        bf_set_zero(q, 0);\n        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF || b->expn == BF_EXP_ZERO) {\n            bf_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else {\n            bf_set(r, a);\n            return bf_round(r, prec, flags);\n        }\n    }\n\n    q_sign = a->sign ^ b->sign;\n    is_rndn = (rnd_mode == BF_RNDN || rnd_mode == BF_RNDNA);\n    switch(rnd_mode) {\n    default:\n    case BF_RNDZ:\n    case BF_RNDN:\n    case BF_RNDNA:\n        is_ceil = FALSE;\n        break;\n    case BF_RNDD:\n        is_ceil = q_sign;\n        break;\n    case BF_RNDU:\n        is_ceil = q_sign ^ 1;\n        break;\n    case BF_RNDA:\n        is_ceil = TRUE;\n        break;\n    case BF_DIVREM_EUCLIDIAN:\n        is_ceil = a->sign;\n        break;\n    }\n\n    a1->expn = a->expn;\n    a1->tab = a->tab;\n    a1->len = a->len;\n    a1->sign = 0;\n\n    b1->expn = b->expn;\n    b1->tab = b->tab;\n    b1->len = b->len;\n    b1->sign = 0;\n\n    /* XXX: could improve to avoid having a large 'q' */\n    bf_tdivremu(q, r, a1, b1);\n    if (bf_is_nan(q) || bf_is_nan(r))\n        goto fail;\n\n    if (r->len != 0) {\n        if (is_rndn) {\n            int res;\n            b1->expn--;\n            res = bf_cmpu(r, b1);\n            b1->expn++;\n            if (res > 0 ||\n                (res == 0 &&\n                 (rnd_mode == BF_RNDNA ||\n                  get_bit(q->tab, q->len, q->len * LIMB_BITS - q->expn)))) {\n                goto do_sub_r;\n            }\n        } else if (is_ceil) {\n        do_sub_r:\n            ret = bf_add_si(q, q, 1, BF_PREC_INF, BF_RNDZ);\n            ret |= bf_sub(r, r, b1, BF_PREC_INF, BF_RNDZ);\n            if (ret & BF_ST_MEM_ERROR)\n                goto fail;\n        }\n    }\n\n    r->sign ^= a->sign;\n    q->sign = q_sign;\n    return bf_round(r, prec, flags);\n fail:\n    bf_set_nan(q);\n    bf_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}\n\nint bf_rem(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n           bf_flags_t flags, int rnd_mode)\n{\n    bf_t q_s, *q = &q_s;\n    int ret;\n\n    bf_init(r->ctx, q);\n    ret = bf_divrem(q, r, a, b, prec, flags, rnd_mode);\n    bf_delete(q);\n    return ret;\n}\n\nstatic inline int bf_get_limb(slimb_t *pres, const bf_t *a, int flags)\n{\n#if LIMB_BITS == 32\n    return bf_get_int32(pres, a, flags);\n#else\n    return bf_get_int64(pres, a, flags);\n#endif\n}\n\nint bf_remquo(slimb_t *pq, bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n              bf_flags_t flags, int rnd_mode)\n{\n    bf_t q_s, *q = &q_s;\n    int ret;\n\n    bf_init(r->ctx, q);\n    ret = bf_divrem(q, r, a, b, prec, flags, rnd_mode);\n    bf_get_limb(pq, q, BF_GET_INT_MOD);\n    bf_delete(q);\n    return ret;\n}\n\nstatic __maybe_unused inline limb_t mul_mod(limb_t a, limb_t b, limb_t m)\n{\n    dlimb_t t;\n    t = (dlimb_t)a * (dlimb_t)b;\n    return t % m;\n}\n\n#if defined(USE_MUL_CHECK)\nstatic limb_t mp_mod1(const limb_t *tab, limb_t n, limb_t m, limb_t r)\n{\n    slimb_t i;\n    dlimb_t t;\n\n    for(i = n - 1; i >= 0; i--) {\n        t = ((dlimb_t)r << LIMB_BITS) | tab[i];\n        r = t % m;\n    }\n    return r;\n}\n#endif\n\nstatic const uint16_t sqrt_table[192] = {\n128,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,144,145,146,147,148,149,150,150,151,152,153,154,155,155,156,157,158,159,160,160,161,162,163,163,164,165,166,167,167,168,169,170,170,171,172,173,173,174,175,176,176,177,178,178,179,180,181,181,182,183,183,184,185,185,186,187,187,188,189,189,190,191,192,192,193,193,194,195,195,196,197,197,198,199,199,200,201,201,202,203,203,204,204,205,206,206,207,208,208,209,209,210,211,211,212,212,213,214,214,215,215,216,217,217,218,218,219,219,220,221,221,222,222,223,224,224,225,225,226,226,227,227,228,229,229,230,230,231,231,232,232,233,234,234,235,235,236,236,237,237,238,238,239,240,240,241,241,242,242,243,243,244,244,245,245,246,246,247,247,248,248,249,249,250,250,251,251,252,252,253,253,254,254,255,\n};\n\n/* a >= 2^(LIMB_BITS - 2).  Return (s, r) with s=floor(sqrt(a)) and\n   r=a-s^2. 0 <= r <= 2 * s */\nstatic limb_t mp_sqrtrem1(limb_t *pr, limb_t a)\n{\n    limb_t s1, r1, s, r, q, u, num;\n\n    /* use a table for the 16 -> 8 bit sqrt */\n    s1 = sqrt_table[(a >> (LIMB_BITS - 8)) - 64];\n    r1 = (a >> (LIMB_BITS - 16)) - s1 * s1;\n    if (r1 > 2 * s1) {\n        r1 -= 2 * s1 + 1;\n        s1++;\n    }\n\n    /* one iteration to get a 32 -> 16 bit sqrt */\n    num = (r1 << 8) | ((a >> (LIMB_BITS - 32 + 8)) & 0xff);\n    q = num / (2 * s1); /* q <= 2^8 */\n    u = num % (2 * s1);\n    s = (s1 << 8) + q;\n    r = (u << 8) | ((a >> (LIMB_BITS - 32)) & 0xff);\n    r -= q * q;\n    if ((slimb_t)r < 0) {\n        s--;\n        r += 2 * s + 1;\n    }\n\n#if LIMB_BITS == 64\n    s1 = s;\n    r1 = r;\n    /* one more iteration for 64 -> 32 bit sqrt */\n    num = (r1 << 16) | ((a >> (LIMB_BITS - 64 + 16)) & 0xffff);\n    q = num / (2 * s1); /* q <= 2^16 */\n    u = num % (2 * s1);\n    s = (s1 << 16) + q;\n    r = (u << 16) | ((a >> (LIMB_BITS - 64)) & 0xffff);\n    r -= q * q;\n    if ((slimb_t)r < 0) {\n        s--;\n        r += 2 * s + 1;\n    }\n#endif\n    *pr = r;\n    return s;\n}\n\n/* return floor(sqrt(a)) */\nlimb_t bf_isqrt(limb_t a)\n{\n    limb_t s, r;\n    int k;\n\n    if (a == 0)\n        return 0;\n    k = clz(a) & ~1;\n    s = mp_sqrtrem1(&r, a << k);\n    s >>= (k >> 1);\n    return s;\n}\n\nstatic limb_t mp_sqrtrem2(limb_t *tabs, limb_t *taba)\n{\n    limb_t s1, r1, s, q, u, a0, a1;\n    dlimb_t r, num;\n    int l;\n\n    a0 = taba[0];\n    a1 = taba[1];\n    s1 = mp_sqrtrem1(&r1, a1);\n    l = LIMB_BITS / 2;\n    num = ((dlimb_t)r1 << l) | (a0 >> l);\n    q = num / (2 * s1);\n    u = num % (2 * s1);\n    s = (s1 << l) + q;\n    r = ((dlimb_t)u << l) | (a0 & (((limb_t)1 << l) - 1));\n    if (unlikely((q >> l) != 0))\n        r -= (dlimb_t)1 << LIMB_BITS; /* special case when q=2^l */\n    else\n        r -= q * q;\n    if ((slimb_t)(r >> LIMB_BITS) < 0) {\n        s--;\n        r += 2 * (dlimb_t)s + 1;\n    }\n    tabs[0] = s;\n    taba[0] = r;\n    return r >> LIMB_BITS;\n}\n\n//#define DEBUG_SQRTREM\n\n/* tmp_buf must contain (n / 2 + 1 limbs). *prh contains the highest\n   limb of the remainder. */\nstatic int mp_sqrtrem_rec(bf_context_t *s, limb_t *tabs, limb_t *taba, limb_t n,\n                          limb_t *tmp_buf, limb_t *prh)\n{\n    limb_t l, h, rh, ql, qh, c, i;\n\n    if (n == 1) {\n        *prh = mp_sqrtrem2(tabs, taba);\n        return 0;\n    }\n#ifdef DEBUG_SQRTREM\n    mp_print_str(\"a\", taba, 2 * n);\n#endif\n    l = n / 2;\n    h = n - l;\n    if (mp_sqrtrem_rec(s, tabs + l, taba + 2 * l, h, tmp_buf, &qh))\n        return -1;\n#ifdef DEBUG_SQRTREM\n    mp_print_str(\"s1\", tabs + l, h);\n    mp_print_str_h(\"r1\", taba + 2 * l, h, qh);\n    mp_print_str_h(\"r2\", taba + l, n, qh);\n#endif\n\n    /* the remainder is in taba + 2 * l. Its high bit is in qh */\n    if (qh) {\n        mp_sub(taba + 2 * l, taba + 2 * l, tabs + l, h, 0);\n    }\n    /* instead of dividing by 2*s, divide by s (which is normalized)\n       and update q and r */\n    if (mp_divnorm(s, tmp_buf, taba + l, n, tabs + l, h))\n        return -1;\n    qh += tmp_buf[l];\n    for(i = 0; i < l; i++)\n        tabs[i] = tmp_buf[i];\n    ql = mp_shr(tabs, tabs, l, 1, qh & 1);\n    qh = qh >> 1; /* 0 or 1 */\n    if (ql)\n        rh = mp_add(taba + l, taba + l, tabs + l, h, 0);\n    else\n        rh = 0;\n#ifdef DEBUG_SQRTREM\n    mp_print_str_h(\"q\", tabs, l, qh);\n    mp_print_str_h(\"u\", taba + l, h, rh);\n#endif\n\n    mp_add_ui(tabs + l, qh, h);\n#ifdef DEBUG_SQRTREM\n    mp_print_str_h(\"s2\", tabs, n, sh);\n#endif\n\n    /* q = qh, tabs[l - 1 ... 0], r = taba[n - 1 ... l] */\n    /* subtract q^2. if qh = 1 then q = B^l, so we can take shortcuts */\n    if (qh) {\n        c = qh;\n    } else {\n        if (mp_mul(s, taba + n, tabs, l, tabs, l))\n            return -1;\n        c = mp_sub(taba, taba, taba + n, 2 * l, 0);\n    }\n    rh -= mp_sub_ui(taba + 2 * l, c, n - 2 * l);\n    if ((slimb_t)rh < 0) {\n        mp_sub_ui(tabs, 1, n);\n        rh += mp_add_mul1(taba, tabs, n, 2);\n        rh += mp_add_ui(taba, 1, n);\n    }\n    *prh = rh;\n    return 0;\n}\n\n/* 'taba' has 2*n limbs with n >= 1 and taba[2*n-1] >= 2 ^ (LIMB_BITS\n   - 2). Return (s, r) with s=floor(sqrt(a)) and r=a-s^2. 0 <= r <= 2\n   * s. tabs has n limbs. r is returned in the lower n limbs of\n   taba. Its r[n] is the returned value of the function. */\n/* Algorithm from the article \"Karatsuba Square Root\" by Paul Zimmermann and\n   inspirated from its GMP implementation */\nint mp_sqrtrem(bf_context_t *s, limb_t *tabs, limb_t *taba, limb_t n)\n{\n    limb_t tmp_buf1[8];\n    limb_t *tmp_buf;\n    mp_size_t n2;\n    int ret;\n    n2 = n / 2 + 1;\n    if (n2 <= countof(tmp_buf1)) {\n        tmp_buf = tmp_buf1;\n    } else {\n        tmp_buf = bf_malloc(s, sizeof(limb_t) * n2);\n        if (!tmp_buf)\n            return -1;\n    }\n    ret = mp_sqrtrem_rec(s, tabs, taba, n, tmp_buf, taba + n);\n    if (tmp_buf != tmp_buf1)\n        bf_free(s, tmp_buf);\n    return ret;\n}\n\n/* Integer square root with remainder. 'a' must be an integer. r =\n   floor(sqrt(a)) and rem = a - r^2.  BF_ST_INEXACT is set if the result\n   is inexact. 'rem' can be NULL if the remainder is not needed. */\nint bf_sqrtrem(bf_t *r, bf_t *rem1, const bf_t *a)\n{\n    int ret;\n\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n        } else if (a->expn == BF_EXP_INF && a->sign) {\n            goto invalid_op;\n        } else {\n            bf_set(r, a);\n        }\n        if (rem1)\n            bf_set_ui(rem1, 0);\n        ret = 0;\n    } else if (a->sign) {\n invalid_op:\n        bf_set_nan(r);\n        if (rem1)\n            bf_set_ui(rem1, 0);\n        ret = BF_ST_INVALID_OP;\n    } else {\n        bf_t rem_s, *rem;\n\n        bf_sqrt(r, a, (a->expn + 1) / 2, BF_RNDZ);\n        bf_rint(r, BF_RNDZ);\n        /* see if the result is exact by computing the remainder */\n        if (rem1) {\n            rem = rem1;\n        } else {\n            rem = &rem_s;\n            bf_init(r->ctx, rem);\n        }\n        /* XXX: could avoid recomputing the remainder */\n        bf_mul(rem, r, r, BF_PREC_INF, BF_RNDZ);\n        bf_neg(rem);\n        bf_add(rem, rem, a, BF_PREC_INF, BF_RNDZ);\n        if (bf_is_nan(rem)) {\n            ret = BF_ST_MEM_ERROR;\n            goto done;\n        }\n        if (rem->len != 0) {\n            ret = BF_ST_INEXACT;\n        } else {\n            ret = 0;\n        }\n    done:\n        if (!rem1)\n            bf_delete(rem);\n    }\n    return ret;\n}\n\nint bf_sqrt(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)\n{\n    bf_context_t *s = a->ctx;\n    int ret;\n\n    assert(r != a);\n\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n        } else if (a->expn == BF_EXP_INF && a->sign) {\n            goto invalid_op;\n        } else {\n            bf_set(r, a);\n        }\n        ret = 0;\n    } else if (a->sign) {\n invalid_op:\n        bf_set_nan(r);\n        ret = BF_ST_INVALID_OP;\n    } else {\n        limb_t *a1;\n        slimb_t n, n1;\n        limb_t res;\n\n        /* convert the mantissa to an integer with at least 2 *\n           prec + 4 bits */\n        n = (2 * (prec + 2) + 2 * LIMB_BITS - 1) / (2 * LIMB_BITS);\n        if (bf_resize(r, n))\n            goto fail;\n        a1 = bf_malloc(s, sizeof(limb_t) * 2 * n);\n        if (!a1)\n            goto fail;\n        n1 = bf_min(2 * n, a->len);\n        memset(a1, 0, (2 * n - n1) * sizeof(limb_t));\n        memcpy(a1 + 2 * n - n1, a->tab + a->len - n1, n1 * sizeof(limb_t));\n        if (a->expn & 1) {\n            res = mp_shr(a1, a1, 2 * n, 1, 0);\n        } else {\n            res = 0;\n        }\n        if (mp_sqrtrem(s, r->tab, a1, n)) {\n            bf_free(s, a1);\n            goto fail;\n        }\n        if (!res) {\n            res = mp_scan_nz(a1, n + 1);\n        }\n        bf_free(s, a1);\n        if (!res) {\n            res = mp_scan_nz(a->tab, a->len - n1);\n        }\n        if (res != 0)\n            r->tab[0] |= 1;\n        r->sign = 0;\n        r->expn = (a->expn + 1) >> 1;\n        ret = bf_round(r, prec, flags);\n    }\n    return ret;\n fail:\n    bf_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}\n\nstatic no_inline int bf_op2(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n                            bf_flags_t flags, bf_op2_func_t *func)\n{\n    bf_t tmp;\n    int ret;\n\n    if (r == a || r == b) {\n        bf_init(r->ctx, &tmp);\n        ret = func(&tmp, a, b, prec, flags);\n        bf_move(r, &tmp);\n    } else {\n        ret = func(r, a, b, prec, flags);\n    }\n    return ret;\n}\n\nint bf_add(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n            bf_flags_t flags)\n{\n    return bf_op2(r, a, b, prec, flags, __bf_add);\n}\n\nint bf_sub(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n            bf_flags_t flags)\n{\n    return bf_op2(r, a, b, prec, flags, __bf_sub);\n}\n\nint bf_div(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n           bf_flags_t flags)\n{\n    return bf_op2(r, a, b, prec, flags, __bf_div);\n}\n\nint bf_mul_ui(bf_t *r, const bf_t *a, uint64_t b1, limb_t prec,\n               bf_flags_t flags)\n{\n    bf_t b;\n    int ret;\n    bf_init(r->ctx, &b);\n    ret = bf_set_ui(&b, b1);\n    ret |= bf_mul(r, a, &b, prec, flags);\n    bf_delete(&b);\n    return ret;\n}\n\nint bf_mul_si(bf_t *r, const bf_t *a, int64_t b1, limb_t prec,\n               bf_flags_t flags)\n{\n    bf_t b;\n    int ret;\n    bf_init(r->ctx, &b);\n    ret = bf_set_si(&b, b1);\n    ret |= bf_mul(r, a, &b, prec, flags);\n    bf_delete(&b);\n    return ret;\n}\n\nint bf_add_si(bf_t *r, const bf_t *a, int64_t b1, limb_t prec,\n              bf_flags_t flags)\n{\n    bf_t b;\n    int ret;\n\n    bf_init(r->ctx, &b);\n    ret = bf_set_si(&b, b1);\n    ret |= bf_add(r, a, &b, prec, flags);\n    bf_delete(&b);\n    return ret;\n}\n\nstatic int bf_pow_ui(bf_t *r, const bf_t *a, limb_t b, limb_t prec,\n                     bf_flags_t flags)\n{\n    int ret, n_bits, i;\n\n    assert(r != a);\n    if (b == 0)\n        return bf_set_ui(r, 1);\n    ret = bf_set(r, a);\n    n_bits = LIMB_BITS - clz(b);\n    for(i = n_bits - 2; i >= 0; i--) {\n        ret |= bf_mul(r, r, r, prec, flags);\n        if ((b >> i) & 1)\n            ret |= bf_mul(r, r, a, prec, flags);\n    }\n    return ret;\n}\n\nstatic int bf_pow_ui_ui(bf_t *r, limb_t a1, limb_t b,\n                        limb_t prec, bf_flags_t flags)\n{\n    bf_t a;\n    int ret;\n\n#ifdef USE_BF_DEC\n    if (a1 == 10 && b <= LIMB_DIGITS) {\n        /* use precomputed powers. We do not round at this point\n           because we expect the caller to do it */\n        ret = bf_set_ui(r, mp_pow_dec[b]);\n    } else\n#endif\n    {\n        bf_init(r->ctx, &a);\n        ret = bf_set_ui(&a, a1);\n        ret |= bf_pow_ui(r, &a, b, prec, flags);\n        bf_delete(&a);\n    }\n    return ret;\n}\n\n/* convert to integer (infinite precision) */\nint bf_rint(bf_t *r, int rnd_mode)\n{\n    return bf_round(r, 0, rnd_mode | BF_FLAG_RADPNT_PREC);\n}\n\n/* logical operations */\n#define BF_LOGIC_OR  0\n#define BF_LOGIC_XOR 1\n#define BF_LOGIC_AND 2\n\nstatic inline limb_t bf_logic_op1(limb_t a, limb_t b, int op)\n{\n    switch(op) {\n    case BF_LOGIC_OR:\n        return a | b;\n    case BF_LOGIC_XOR:\n        return a ^ b;\n    default:\n    case BF_LOGIC_AND:\n        return a & b;\n    }\n}\n\nstatic int bf_logic_op(bf_t *r, const bf_t *a1, const bf_t *b1, int op)\n{\n    bf_t b1_s, a1_s, *a, *b;\n    limb_t a_sign, b_sign, r_sign;\n    slimb_t l, i, a_bit_offset, b_bit_offset;\n    limb_t v1, v2, v1_mask, v2_mask, r_mask;\n    int ret;\n\n    assert(r != a1 && r != b1);\n\n    if (a1->expn <= 0)\n        a_sign = 0; /* minus zero is considered as positive */\n    else\n        a_sign = a1->sign;\n\n    if (b1->expn <= 0)\n        b_sign = 0; /* minus zero is considered as positive */\n    else\n        b_sign = b1->sign;\n\n    if (a_sign) {\n        a = &a1_s;\n        bf_init(r->ctx, a);\n        if (bf_add_si(a, a1, 1, BF_PREC_INF, BF_RNDZ)) {\n            b = NULL;\n            goto fail;\n        }\n    } else {\n        a = (bf_t *)a1;\n    }\n\n    if (b_sign) {\n        b = &b1_s;\n        bf_init(r->ctx, b);\n        if (bf_add_si(b, b1, 1, BF_PREC_INF, BF_RNDZ))\n            goto fail;\n    } else {\n        b = (bf_t *)b1;\n    }\n\n    r_sign = bf_logic_op1(a_sign, b_sign, op);\n    if (op == BF_LOGIC_AND && r_sign == 0) {\n        /* no need to compute extra zeros for and */\n        if (a_sign == 0 && b_sign == 0)\n            l = bf_min(a->expn, b->expn);\n        else if (a_sign == 0)\n            l = a->expn;\n        else\n            l = b->expn;\n    } else {\n        l = bf_max(a->expn, b->expn);\n    }\n    /* Note: a or b can be zero */\n    l = (bf_max(l, 1) + LIMB_BITS - 1) / LIMB_BITS;\n    if (bf_resize(r, l))\n        goto fail;\n    a_bit_offset = a->len * LIMB_BITS - a->expn;\n    b_bit_offset = b->len * LIMB_BITS - b->expn;\n    v1_mask = -a_sign;\n    v2_mask = -b_sign;\n    r_mask = -r_sign;\n    for(i = 0; i < l; i++) {\n        v1 = get_bits(a->tab, a->len, a_bit_offset + i * LIMB_BITS) ^ v1_mask;\n        v2 = get_bits(b->tab, b->len, b_bit_offset + i * LIMB_BITS) ^ v2_mask;\n        r->tab[i] = bf_logic_op1(v1, v2, op) ^ r_mask;\n    }\n    r->expn = l * LIMB_BITS;\n    r->sign = r_sign;\n    bf_normalize_and_round(r, BF_PREC_INF, BF_RNDZ); /* cannot fail */\n    if (r_sign) {\n        if (bf_add_si(r, r, -1, BF_PREC_INF, BF_RNDZ))\n            goto fail;\n    }\n    ret = 0;\n done:\n    if (a == &a1_s)\n        bf_delete(a);\n    if (b == &b1_s)\n        bf_delete(b);\n    return ret;\n fail:\n    bf_set_nan(r);\n    ret = BF_ST_MEM_ERROR;\n    goto done;\n}\n\n/* 'a' and 'b' must be integers. Return 0 or BF_ST_MEM_ERROR. */\nint bf_logic_or(bf_t *r, const bf_t *a, const bf_t *b)\n{\n    return bf_logic_op(r, a, b, BF_LOGIC_OR);\n}\n\n/* 'a' and 'b' must be integers. Return 0 or BF_ST_MEM_ERROR. */\nint bf_logic_xor(bf_t *r, const bf_t *a, const bf_t *b)\n{\n    return bf_logic_op(r, a, b, BF_LOGIC_XOR);\n}\n\n/* 'a' and 'b' must be integers. Return 0 or BF_ST_MEM_ERROR. */\nint bf_logic_and(bf_t *r, const bf_t *a, const bf_t *b)\n{\n    return bf_logic_op(r, a, b, BF_LOGIC_AND);\n}\n\n/* conversion between fixed size types */\n\ntypedef union {\n    double d;\n    uint64_t u;\n} Float64Union;\n\nint bf_get_float64(const bf_t *a, double *pres, bf_rnd_t rnd_mode)\n{\n    Float64Union u;\n    int e, ret;\n    uint64_t m;\n\n    ret = 0;\n    if (a->expn == BF_EXP_NAN) {\n        u.u = 0x7ff8000000000000; /* quiet nan */\n    } else {\n        bf_t b_s, *b = &b_s;\n\n        bf_init(a->ctx, b);\n        bf_set(b, a);\n        if (bf_is_finite(b)) {\n            ret = bf_round(b, 53, rnd_mode | BF_FLAG_SUBNORMAL | bf_set_exp_bits(11));\n        }\n        if (b->expn == BF_EXP_INF) {\n            e = (1 << 11) - 1;\n            m = 0;\n        } else if (b->expn == BF_EXP_ZERO) {\n            e = 0;\n            m = 0;\n        } else {\n            e = b->expn + 1023 - 1;\n#if LIMB_BITS == 32\n            if (b->len == 2) {\n                m = ((uint64_t)b->tab[1] << 32) | b->tab[0];\n            } else {\n                m = ((uint64_t)b->tab[0] << 32);\n            }\n#else\n            m = b->tab[0];\n#endif\n            if (e <= 0) {\n                /* subnormal */\n                m = m >> (12 - e);\n                e = 0;\n            } else {\n                m = (m << 1) >> 12;\n            }\n        }\n        u.u = m | ((uint64_t)e << 52) | ((uint64_t)b->sign << 63);\n        bf_delete(b);\n    }\n    *pres = u.d;\n    return ret;\n}\n\nint bf_set_float64(bf_t *a, double d)\n{\n    Float64Union u;\n    uint64_t m;\n    int shift, e, sgn;\n\n    u.d = d;\n    sgn = u.u >> 63;\n    e = (u.u >> 52) & ((1 << 11) - 1);\n    m = u.u & (((uint64_t)1 << 52) - 1);\n    if (e == ((1 << 11) - 1)) {\n        if (m != 0) {\n            bf_set_nan(a);\n        } else {\n            bf_set_inf(a, sgn);\n        }\n    } else if (e == 0) {\n        if (m == 0) {\n            bf_set_zero(a, sgn);\n        } else {\n            /* subnormal number */\n            m <<= 12;\n            shift = clz64(m);\n            m <<= shift;\n            e = -shift;\n            goto norm;\n        }\n    } else {\n        m = (m << 11) | ((uint64_t)1 << 63);\n    norm:\n        a->expn = e - 1023 + 1;\n#if LIMB_BITS == 32\n        if (bf_resize(a, 2))\n            goto fail;\n        a->tab[0] = m;\n        a->tab[1] = m >> 32;\n#else\n        if (bf_resize(a, 1))\n            goto fail;\n        a->tab[0] = m;\n#endif\n        a->sign = sgn;\n    }\n    return 0;\nfail:\n    bf_set_nan(a);\n    return BF_ST_MEM_ERROR;\n}\n\n/* The rounding mode is always BF_RNDZ. Return BF_ST_INVALID_OP if there\n   is an overflow and 0 otherwise. */\nint bf_get_int32(int *pres, const bf_t *a, int flags)\n{\n    uint32_t v;\n    int ret;\n    if (a->expn >= BF_EXP_INF) {\n        ret = BF_ST_INVALID_OP;\n        if (flags & BF_GET_INT_MOD) {\n            v = 0;\n        } else if (a->expn == BF_EXP_INF) {\n            v = (uint32_t)INT32_MAX + a->sign;\n        } else {\n            v = INT32_MAX;\n        }\n    } else if (a->expn <= 0) {\n        v = 0;\n        ret = 0;\n    } else if (a->expn <= 31) {\n        v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);\n        if (a->sign)\n            v = -v;\n        ret = 0;\n    } else if (!(flags & BF_GET_INT_MOD)) {\n        ret = BF_ST_INVALID_OP;\n        if (a->sign) {\n            v = (uint32_t)INT32_MAX + 1;\n            if (a->expn == 32 &&\n                (a->tab[a->len - 1] >> (LIMB_BITS - 32)) == v) {\n                ret = 0;\n            }\n        } else {\n            v = INT32_MAX;\n        }\n    } else {\n        v = get_bits(a->tab, a->len, a->len * LIMB_BITS - a->expn);\n        if (a->sign)\n            v = -v;\n        ret = 0;\n    }\n    *pres = v;\n    return ret;\n}\n\n/* The rounding mode is always BF_RNDZ. Return BF_ST_INVALID_OP if there\n   is an overflow and 0 otherwise. */\nint bf_get_int64(int64_t *pres, const bf_t *a, int flags)\n{\n    uint64_t v;\n    int ret;\n    if (a->expn >= BF_EXP_INF) {\n        ret = BF_ST_INVALID_OP;\n        if (flags & BF_GET_INT_MOD) {\n            v = 0;\n        } else if (a->expn == BF_EXP_INF) {\n            v = (uint64_t)INT64_MAX + a->sign;\n        } else {\n            v = INT64_MAX;\n        }\n    } else if (a->expn <= 0) {\n        v = 0;\n        ret = 0;\n    } else if (a->expn <= 63) {\n#if LIMB_BITS == 32\n        if (a->expn <= 32)\n            v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);\n        else\n            v = (((uint64_t)a->tab[a->len - 1] << 32) |\n                 get_limbz(a, a->len - 2)) >> (64 - a->expn);\n#else\n        v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);\n#endif\n        if (a->sign)\n            v = -v;\n        ret = 0;\n    } else if (!(flags & BF_GET_INT_MOD)) {\n        ret = BF_ST_INVALID_OP;\n        if (a->sign) {\n            uint64_t v1;\n            v = (uint64_t)INT64_MAX + 1;\n            if (a->expn == 64) {\n                v1 = a->tab[a->len - 1];\n#if LIMB_BITS == 32\n                v1 = (v1 << 32) | get_limbz(a, a->len - 2);\n#endif\n                if (v1 == v)\n                    ret = 0;\n            }\n        } else {\n            v = INT64_MAX;\n        }\n    } else {\n        slimb_t bit_pos = a->len * LIMB_BITS - a->expn;\n        v = get_bits(a->tab, a->len, bit_pos);\n#if LIMB_BITS == 32\n        v |= (uint64_t)get_bits(a->tab, a->len, bit_pos + 32) << 32;\n#endif\n        if (a->sign)\n            v = -v;\n        ret = 0;\n    }\n    *pres = v;\n    return ret;\n}\n\n/* The rounding mode is always BF_RNDZ. Return BF_ST_INVALID_OP if there\n   is an overflow and 0 otherwise. */\nint bf_get_uint64(uint64_t *pres, const bf_t *a)\n{\n    uint64_t v;\n    int ret;\n    if (a->expn == BF_EXP_NAN) {\n        goto overflow;\n    } else if (a->expn <= 0) {\n        v = 0;\n        ret = 0;\n    } else if (a->sign) {\n        v = 0;\n        ret = BF_ST_INVALID_OP;\n    } else if (a->expn <= 64) {\n#if LIMB_BITS == 32\n        if (a->expn <= 32)\n            v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);\n        else\n            v = (((uint64_t)a->tab[a->len - 1] << 32) |\n                 get_limbz(a, a->len - 2)) >> (64 - a->expn);\n#else\n        v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);\n#endif\n        ret = 0;\n    } else {\n    overflow:\n        v = UINT64_MAX;\n        ret = BF_ST_INVALID_OP;\n    }\n    *pres = v;\n    return ret;\n}\n\n/* base conversion from radix */\n\nstatic const uint8_t digits_per_limb_table[BF_RADIX_MAX - 1] = {\n#if LIMB_BITS == 32\n32,20,16,13,12,11,10,10, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n#else\n64,40,32,27,24,22,21,20,19,18,17,17,16,16,16,15,15,15,14,14,14,14,13,13,13,13,13,13,13,12,12,12,12,12,12,\n#endif\n};\n\nstatic limb_t get_limb_radix(int radix)\n{\n    int i, k;\n    limb_t radixl;\n\n    k = digits_per_limb_table[radix - 2];\n    radixl = radix;\n    for(i = 1; i < k; i++)\n        radixl *= radix;\n    return radixl;\n}\n\n/* return != 0 if error */\nstatic int bf_integer_from_radix_rec(bf_t *r, const limb_t *tab,\n                                     limb_t n, int level, limb_t n0,\n                                     limb_t radix, bf_t *pow_tab)\n{\n    int ret;\n    if (n == 1) {\n        ret = bf_set_ui(r, tab[0]);\n    } else {\n        bf_t T_s, *T = &T_s, *B;\n        limb_t n1, n2;\n\n        n2 = (((n0 * 2) >> (level + 1)) + 1) / 2;\n        n1 = n - n2;\n        //        printf(\"level=%d n0=%ld n1=%ld n2=%ld\\n\", level, n0, n1, n2);\n        B = &pow_tab[level];\n        if (B->len == 0) {\n            ret = bf_pow_ui_ui(B, radix, n2, BF_PREC_INF, BF_RNDZ);\n            if (ret)\n                return ret;\n        }\n        ret = bf_integer_from_radix_rec(r, tab + n2, n1, level + 1, n0,\n                                        radix, pow_tab);\n        if (ret)\n            return ret;\n        ret = bf_mul(r, r, B, BF_PREC_INF, BF_RNDZ);\n        if (ret)\n            return ret;\n        bf_init(r->ctx, T);\n        ret = bf_integer_from_radix_rec(T, tab, n2, level + 1, n0,\n                                        radix, pow_tab);\n        if (!ret)\n            ret = bf_add(r, r, T, BF_PREC_INF, BF_RNDZ);\n        bf_delete(T);\n    }\n    return ret;\n    //    bf_print_str(\"  r=\", r);\n}\n\n/* return 0 if OK != 0 if memory error */\nstatic int bf_integer_from_radix(bf_t *r, const limb_t *tab,\n                                 limb_t n, limb_t radix)\n{\n    bf_context_t *s = r->ctx;\n    int pow_tab_len, i, ret;\n    limb_t radixl;\n    bf_t *pow_tab;\n\n    radixl = get_limb_radix(radix);\n    pow_tab_len = ceil_log2(n) + 2; /* XXX: check */\n    pow_tab = bf_malloc(s, sizeof(pow_tab[0]) * pow_tab_len);\n    if (!pow_tab)\n        return -1;\n    for(i = 0; i < pow_tab_len; i++)\n        bf_init(r->ctx, &pow_tab[i]);\n    ret = bf_integer_from_radix_rec(r, tab, n, 0, n, radixl, pow_tab);\n    for(i = 0; i < pow_tab_len; i++) {\n        bf_delete(&pow_tab[i]);\n    }\n    bf_free(s, pow_tab);\n    return ret;\n}\n\n/* compute and round T * radix^expn. */\nint bf_mul_pow_radix(bf_t *r, const bf_t *T, limb_t radix,\n                     slimb_t expn, limb_t prec, bf_flags_t flags)\n{\n    int ret, expn_sign, overflow;\n    slimb_t e, extra_bits, prec1, ziv_extra_bits;\n    bf_t B_s, *B = &B_s;\n\n    if (T->len == 0) {\n        return bf_set(r, T);\n    } else if (expn == 0) {\n        ret = bf_set(r, T);\n        ret |= bf_round(r, prec, flags);\n        return ret;\n    }\n\n    e = expn;\n    expn_sign = 0;\n    if (e < 0) {\n        e = -e;\n        expn_sign = 1;\n    }\n    bf_init(r->ctx, B);\n    if (prec == BF_PREC_INF) {\n        /* infinite precision: only used if the result is known to be exact */\n        ret = bf_pow_ui_ui(B, radix, e, BF_PREC_INF, BF_RNDN);\n        if (expn_sign) {\n            ret |= bf_div(r, T, B, T->len * LIMB_BITS, BF_RNDN);\n        } else {\n            ret |= bf_mul(r, T, B, BF_PREC_INF, BF_RNDN);\n        }\n    } else {\n        ziv_extra_bits = 16;\n        for(;;) {\n            prec1 = prec + ziv_extra_bits;\n            /* XXX: correct overflow/underflow handling */\n            /* XXX: rigorous error analysis needed */\n            extra_bits = ceil_log2(e) * 2 + 1;\n            ret = bf_pow_ui_ui(B, radix, e, prec1 + extra_bits, BF_RNDN | BF_FLAG_EXT_EXP);\n            overflow = !bf_is_finite(B);\n            /* XXX: if bf_pow_ui_ui returns an exact result, can stop\n               after the next operation */\n            if (expn_sign)\n                ret |= bf_div(r, T, B, prec1 + extra_bits, BF_RNDN | BF_FLAG_EXT_EXP);\n            else\n                ret |= bf_mul(r, T, B, prec1 + extra_bits, BF_RNDN | BF_FLAG_EXT_EXP);\n            if (ret & BF_ST_MEM_ERROR)\n                break;\n            if ((ret & BF_ST_INEXACT) &&\n                !bf_can_round(r, prec, flags & BF_RND_MASK, prec1) &&\n                !overflow) {\n                /* and more precision and retry */\n                ziv_extra_bits = ziv_extra_bits  + (ziv_extra_bits / 2);\n            } else {\n                /* XXX: need to use __bf_round() to pass the inexact\n                   flag for the subnormal case */\n                ret = bf_round(r, prec, flags) | (ret & BF_ST_INEXACT);\n                break;\n            }\n        }\n    }\n    bf_delete(B);\n    return ret;\n}\n\nstatic inline int to_digit(int c)\n{\n    if (c >= '0' && c <= '9')\n        return c - '0';\n    else if (c >= 'A' && c <= 'Z')\n        return c - 'A' + 10;\n    else if (c >= 'a' && c <= 'z')\n        return c - 'a' + 10;\n    else\n        return 36;\n}\n\n/* add a limb at 'pos' and decrement pos. new space is created if\n   needed. Return 0 if OK, -1 if memory error */\nstatic int bf_add_limb(bf_t *a, slimb_t *ppos, limb_t v)\n{\n    slimb_t pos;\n    pos = *ppos;\n    if (unlikely(pos < 0)) {\n        limb_t new_size, d, *new_tab;\n        new_size = bf_max(a->len + 1, a->len * 3 / 2);\n        new_tab = bf_realloc(a->ctx, a->tab, sizeof(limb_t) * new_size);\n        if (!new_tab)\n            return -1;\n        a->tab = new_tab;\n        d = new_size - a->len;\n        memmove(a->tab + d, a->tab, a->len * sizeof(limb_t));\n        a->len = new_size;\n        pos += d;\n    }\n    a->tab[pos--] = v;\n    *ppos = pos;\n    return 0;\n}\n\nstatic int bf_tolower(int c)\n{\n    if (c >= 'A' && c <= 'Z')\n        c = c - 'A' + 'a';\n    return c;\n}\n\nstatic int strcasestart(const char *str, const char *val, const char **ptr)\n{\n    const char *p, *q;\n    p = str;\n    q = val;\n    while (*q != '\\0') {\n        if (bf_tolower(*p) != *q)\n            return 0;\n        p++;\n        q++;\n    }\n    if (ptr)\n        *ptr = p;\n    return 1;\n}\n\nstatic int bf_atof_internal(bf_t *r, slimb_t *pexponent,\n                            const char *str, const char **pnext, int radix,\n                            limb_t prec, bf_flags_t flags, BOOL is_dec)\n{\n    const char *p, *p_start;\n    int is_neg, radix_bits, exp_is_neg, ret, digits_per_limb, shift;\n    limb_t cur_limb;\n    slimb_t pos, expn, int_len, digit_count;\n    BOOL has_decpt, is_bin_exp;\n    bf_t a_s, *a;\n\n    *pexponent = 0;\n    p = str;\n    if (!(flags & BF_ATOF_NO_NAN_INF) && radix <= 16 &&\n        strcasestart(p, \"nan\", &p)) {\n        bf_set_nan(r);\n        ret = 0;\n        goto done;\n    }\n    is_neg = 0;\n\n    if (p[0] == '+') {\n        p++;\n        p_start = p;\n    } else if (p[0] == '-') {\n        is_neg = 1;\n        p++;\n        p_start = p;\n    } else {\n        p_start = p;\n    }\n    if (p[0] == '0') {\n        if ((p[1] == 'x' || p[1] == 'X') &&\n            (radix == 0 || radix == 16) &&\n            !(flags & BF_ATOF_NO_HEX)) {\n            radix = 16;\n            p += 2;\n        } else if ((p[1] == 'o' || p[1] == 'O') &&\n                   radix == 0 && (flags & BF_ATOF_BIN_OCT)) {\n            p += 2;\n            radix = 8;\n        } else if ((p[1] == 'b' || p[1] == 'B') &&\n                   radix == 0 && (flags & BF_ATOF_BIN_OCT)) {\n            p += 2;\n            radix = 2;\n        } else {\n            goto no_prefix;\n        }\n        /* there must be a digit after the prefix */\n        if (to_digit((uint8_t)*p) >= radix) {\n            bf_set_nan(r);\n            ret = 0;\n            goto done;\n        }\n    no_prefix: ;\n    } else {\n        if (!(flags & BF_ATOF_NO_NAN_INF) && radix <= 16 &&\n            strcasestart(p, \"inf\", &p)) {\n            bf_set_inf(r, is_neg);\n            ret = 0;\n            goto done;\n        }\n    }\n\n    if (radix == 0)\n        radix = 10;\n    if (is_dec) {\n        assert(radix == 10);\n        radix_bits = 0;\n        a = r;\n    } else if ((radix & (radix - 1)) != 0) {\n        radix_bits = 0; /* base is not a power of two */\n        a = &a_s;\n        bf_init(r->ctx, a);\n    } else {\n        radix_bits = ceil_log2(radix);\n        a = r;\n    }\n\n    /* skip leading zeros */\n    /* XXX: could also skip zeros after the decimal point */\n    while (*p == '0')\n        p++;\n\n    if (radix_bits) {\n        shift = digits_per_limb = LIMB_BITS;\n    } else {\n        radix_bits = 0;\n        shift = digits_per_limb = digits_per_limb_table[radix - 2];\n    }\n    cur_limb = 0;\n    bf_resize(a, 1);\n    pos = 0;\n    has_decpt = FALSE;\n    int_len = digit_count = 0;\n    for(;;) {\n        limb_t c;\n        if (*p == '.' && (p > p_start || to_digit(p[1]) < radix)) {\n            if (has_decpt)\n                break;\n            has_decpt = TRUE;\n            int_len = digit_count;\n            p++;\n        }\n        c = to_digit(*p);\n        if (c >= radix)\n            break;\n        digit_count++;\n        p++;\n        if (radix_bits) {\n            shift -= radix_bits;\n            if (shift <= 0) {\n                cur_limb |= c >> (-shift);\n                if (bf_add_limb(a, &pos, cur_limb))\n                    goto mem_error;\n                if (shift < 0)\n                    cur_limb = c << (LIMB_BITS + shift);\n                else\n                    cur_limb = 0;\n                shift += LIMB_BITS;\n            } else {\n                cur_limb |= c << shift;\n            }\n        } else {\n            cur_limb = cur_limb * radix + c;\n            shift--;\n            if (shift == 0) {\n                if (bf_add_limb(a, &pos, cur_limb))\n                    goto mem_error;\n                shift = digits_per_limb;\n                cur_limb = 0;\n            }\n        }\n    }\n    if (!has_decpt)\n        int_len = digit_count;\n\n    /* add the last limb and pad with zeros */\n    if (shift != digits_per_limb) {\n        if (radix_bits == 0) {\n            while (shift != 0) {\n                cur_limb *= radix;\n                shift--;\n            }\n        }\n        if (bf_add_limb(a, &pos, cur_limb)) {\n        mem_error:\n            ret = BF_ST_MEM_ERROR;\n            if (!radix_bits)\n                bf_delete(a);\n            bf_set_nan(r);\n            goto done;\n        }\n    }\n\n    /* reset the next limbs to zero (we prefer to reallocate in the\n       renormalization) */\n    memset(a->tab, 0, (pos + 1) * sizeof(limb_t));\n\n    if (p == p_start) {\n        ret = 0;\n        if (!radix_bits)\n            bf_delete(a);\n        bf_set_nan(r);\n        goto done;\n    }\n\n    /* parse the exponent, if any */\n    expn = 0;\n    is_bin_exp = FALSE;\n    if (((radix == 10 && (*p == 'e' || *p == 'E')) ||\n         (radix != 10 && (*p == '@' ||\n                          (radix_bits && (*p == 'p' || *p == 'P'))))) &&\n        p > p_start) {\n        is_bin_exp = (*p == 'p' || *p == 'P');\n        p++;\n        exp_is_neg = 0;\n        if (*p == '+') {\n            p++;\n        } else if (*p == '-') {\n            exp_is_neg = 1;\n            p++;\n        }\n        for(;;) {\n            int c;\n            c = to_digit(*p);\n            if (c >= 10)\n                break;\n            if (unlikely(expn > ((BF_RAW_EXP_MAX - 2 - 9) / 10))) {\n                /* exponent overflow */\n                if (exp_is_neg) {\n                    bf_set_zero(r, is_neg);\n                    ret = BF_ST_UNDERFLOW | BF_ST_INEXACT;\n                } else {\n                    bf_set_inf(r, is_neg);\n                    ret = BF_ST_OVERFLOW | BF_ST_INEXACT;\n                }\n                goto done;\n            }\n            p++;\n            expn = expn * 10 + c;\n        }\n        if (exp_is_neg)\n            expn = -expn;\n    }\n    if (is_dec) {\n        a->expn = expn + int_len;\n        a->sign = is_neg;\n        ret = bfdec_normalize_and_round((bfdec_t *)a, prec, flags);\n    } else if (radix_bits) {\n        /* XXX: may overflow */\n        if (!is_bin_exp)\n            expn *= radix_bits;\n        a->expn = expn + (int_len * radix_bits);\n        a->sign = is_neg;\n        ret = bf_normalize_and_round(a, prec, flags);\n    } else {\n        limb_t l;\n        pos++;\n        l = a->len - pos; /* number of limbs */\n        if (l == 0) {\n            bf_set_zero(r, is_neg);\n            ret = 0;\n        } else {\n            bf_t T_s, *T = &T_s;\n\n            expn -= l * digits_per_limb - int_len;\n            bf_init(r->ctx, T);\n            if (bf_integer_from_radix(T, a->tab + pos, l, radix)) {\n                bf_set_nan(r);\n                ret = BF_ST_MEM_ERROR;\n            } else {\n                T->sign = is_neg;\n                if (flags & BF_ATOF_EXPONENT) {\n                    /* return the exponent */\n                    *pexponent = expn;\n                    ret = bf_set(r, T);\n                } else {\n                    ret = bf_mul_pow_radix(r, T, radix, expn, prec, flags);\n                }\n            }\n            bf_delete(T);\n        }\n        bf_delete(a);\n    }\n done:\n    if (pnext)\n        *pnext = p;\n    return ret;\n}\n\n/*\n   Return (status, n, exp). 'status' is the floating point status. 'n'\n   is the parsed number.\n\n   If (flags & BF_ATOF_EXPONENT) and if the radix is not a power of\n   two, the parsed number is equal to r *\n   (*pexponent)^radix. Otherwise *pexponent = 0.\n*/\nint bf_atof2(bf_t *r, slimb_t *pexponent,\n             const char *str, const char **pnext, int radix,\n             limb_t prec, bf_flags_t flags)\n{\n    return bf_atof_internal(r, pexponent, str, pnext, radix, prec, flags,\n                            FALSE);\n}\n\nint bf_atof(bf_t *r, const char *str, const char **pnext, int radix,\n            limb_t prec, bf_flags_t flags)\n{\n    slimb_t dummy_exp;\n    return bf_atof_internal(r, &dummy_exp, str, pnext, radix, prec, flags, FALSE);\n}\n\n/* base conversion to radix */\n\n#if LIMB_BITS == 64\n#define RADIXL_10 UINT64_C(10000000000000000000)\n#else\n#define RADIXL_10 UINT64_C(1000000000)\n#endif\n\nstatic const uint32_t inv_log2_radix[BF_RADIX_MAX - 1][LIMB_BITS / 32 + 1] = {\n#if LIMB_BITS == 32\n{ 0x80000000, 0x00000000,},\n{ 0x50c24e60, 0xd4d4f4a7,},\n{ 0x40000000, 0x00000000,},\n{ 0x372068d2, 0x0a1ee5ca,},\n{ 0x3184648d, 0xb8153e7a,},\n{ 0x2d983275, 0x9d5369c4,},\n{ 0x2aaaaaaa, 0xaaaaaaab,},\n{ 0x28612730, 0x6a6a7a54,},\n{ 0x268826a1, 0x3ef3fde6,},\n{ 0x25001383, 0xbac8a744,},\n{ 0x23b46706, 0x82c0c709,},\n{ 0x229729f1, 0xb2c83ded,},\n{ 0x219e7ffd, 0xa5ad572b,},\n{ 0x20c33b88, 0xda7c29ab,},\n{ 0x20000000, 0x00000000,},\n{ 0x1f50b57e, 0xac5884b3,},\n{ 0x1eb22cc6, 0x8aa6e26f,},\n{ 0x1e21e118, 0x0c5daab2,},\n{ 0x1d9dcd21, 0x439834e4,},\n{ 0x1d244c78, 0x367a0d65,},\n{ 0x1cb40589, 0xac173e0c,},\n{ 0x1c4bd95b, 0xa8d72b0d,},\n{ 0x1bead768, 0x98f8ce4c,},\n{ 0x1b903469, 0x050f72e5,},\n{ 0x1b3b433f, 0x2eb06f15,},\n{ 0x1aeb6f75, 0x9c46fc38,},\n{ 0x1aa038eb, 0x0e3bfd17,},\n{ 0x1a593062, 0xb38d8c56,},\n{ 0x1a15f4c3, 0x2b95a2e6,},\n{ 0x19d630dc, 0xcc7ddef9,},\n{ 0x19999999, 0x9999999a,},\n{ 0x195fec80, 0x8a609431,},\n{ 0x1928ee7b, 0x0b4f22f9,},\n{ 0x18f46acf, 0x8c06e318,},\n{ 0x18c23246, 0xdc0a9f3d,},\n#else\n{ 0x80000000, 0x00000000, 0x00000000,},\n{ 0x50c24e60, 0xd4d4f4a7, 0x021f57bc,},\n{ 0x40000000, 0x00000000, 0x00000000,},\n{ 0x372068d2, 0x0a1ee5ca, 0x19ea911b,},\n{ 0x3184648d, 0xb8153e7a, 0x7fc2d2e1,},\n{ 0x2d983275, 0x9d5369c4, 0x4dec1661,},\n{ 0x2aaaaaaa, 0xaaaaaaaa, 0xaaaaaaab,},\n{ 0x28612730, 0x6a6a7a53, 0x810fabde,},\n{ 0x268826a1, 0x3ef3fde6, 0x23e2566b,},\n{ 0x25001383, 0xbac8a744, 0x385a3349,},\n{ 0x23b46706, 0x82c0c709, 0x3f891718,},\n{ 0x229729f1, 0xb2c83ded, 0x15fba800,},\n{ 0x219e7ffd, 0xa5ad572a, 0xe169744b,},\n{ 0x20c33b88, 0xda7c29aa, 0x9bddee52,},\n{ 0x20000000, 0x00000000, 0x00000000,},\n{ 0x1f50b57e, 0xac5884b3, 0x70e28eee,},\n{ 0x1eb22cc6, 0x8aa6e26f, 0x06d1a2a2,},\n{ 0x1e21e118, 0x0c5daab1, 0x81b4f4bf,},\n{ 0x1d9dcd21, 0x439834e3, 0x81667575,},\n{ 0x1d244c78, 0x367a0d64, 0xc8204d6d,},\n{ 0x1cb40589, 0xac173e0c, 0x3b7b16ba,},\n{ 0x1c4bd95b, 0xa8d72b0d, 0x5879f25a,},\n{ 0x1bead768, 0x98f8ce4c, 0x66cc2858,},\n{ 0x1b903469, 0x050f72e5, 0x0cf5488e,},\n{ 0x1b3b433f, 0x2eb06f14, 0x8c89719c,},\n{ 0x1aeb6f75, 0x9c46fc37, 0xab5fc7e9,},\n{ 0x1aa038eb, 0x0e3bfd17, 0x1bd62080,},\n{ 0x1a593062, 0xb38d8c56, 0x7998ab45,},\n{ 0x1a15f4c3, 0x2b95a2e6, 0x46aed6a0,},\n{ 0x19d630dc, 0xcc7ddef9, 0x5aadd61b,},\n{ 0x19999999, 0x99999999, 0x9999999a,},\n{ 0x195fec80, 0x8a609430, 0xe1106014,},\n{ 0x1928ee7b, 0x0b4f22f9, 0x5f69791d,},\n{ 0x18f46acf, 0x8c06e318, 0x4d2aeb2c,},\n{ 0x18c23246, 0xdc0a9f3d, 0x3fe16970,},\n#endif\n};\n\nstatic const limb_t log2_radix[BF_RADIX_MAX - 1] = {\n#if LIMB_BITS == 32\n0x20000000,\n0x32b80347,\n0x40000000,\n0x4a4d3c26,\n0x52b80347,\n0x59d5d9fd,\n0x60000000,\n0x6570068e,\n0x6a4d3c26,\n0x6eb3a9f0,\n0x72b80347,\n0x766a008e,\n0x79d5d9fd,\n0x7d053f6d,\n0x80000000,\n0x82cc7edf,\n0x8570068e,\n0x87ef05ae,\n0x8a4d3c26,\n0x8c8ddd45,\n0x8eb3a9f0,\n0x90c10501,\n0x92b80347,\n0x949a784c,\n0x966a008e,\n0x982809d6,\n0x99d5d9fd,\n0x9b74948f,\n0x9d053f6d,\n0x9e88c6b3,\n0xa0000000,\n0xa16bad37,\n0xa2cc7edf,\n0xa4231623,\n0xa570068e,\n#else\n0x2000000000000000,\n0x32b803473f7ad0f4,\n0x4000000000000000,\n0x4a4d3c25e68dc57f,\n0x52b803473f7ad0f4,\n0x59d5d9fd5010b366,\n0x6000000000000000,\n0x6570068e7ef5a1e8,\n0x6a4d3c25e68dc57f,\n0x6eb3a9f01975077f,\n0x72b803473f7ad0f4,\n0x766a008e4788cbcd,\n0x79d5d9fd5010b366,\n0x7d053f6d26089673,\n0x8000000000000000,\n0x82cc7edf592262d0,\n0x8570068e7ef5a1e8,\n0x87ef05ae409a0289,\n0x8a4d3c25e68dc57f,\n0x8c8ddd448f8b845a,\n0x8eb3a9f01975077f,\n0x90c10500d63aa659,\n0x92b803473f7ad0f4,\n0x949a784bcd1b8afe,\n0x966a008e4788cbcd,\n0x982809d5be7072dc,\n0x99d5d9fd5010b366,\n0x9b74948f5532da4b,\n0x9d053f6d26089673,\n0x9e88c6b3626a72aa,\n0xa000000000000000,\n0xa16bad3758efd873,\n0xa2cc7edf592262d0,\n0xa4231623369e78e6,\n0xa570068e7ef5a1e8,\n#endif\n};\n\n/* compute floor(a*b) or ceil(a*b) with b = log2(radix) or\n   b=1/log2(radix). For is_inv = 0, strict accuracy is not guaranteed\n   when radix is not a power of two. */\nslimb_t bf_mul_log2_radix(slimb_t a1, unsigned int radix, int is_inv,\n                          int is_ceil1)\n{\n    int is_neg;\n    limb_t a;\n    BOOL is_ceil;\n\n    is_ceil = is_ceil1;\n    a = a1;\n    if (a1 < 0) {\n        a = -a;\n        is_neg = 1;\n    } else {\n        is_neg = 0;\n    }\n    is_ceil ^= is_neg;\n    if ((radix & (radix - 1)) == 0) {\n        int radix_bits;\n        /* radix is a power of two */\n        radix_bits = ceil_log2(radix);\n        if (is_inv) {\n            if (is_ceil)\n                a += radix_bits - 1;\n            a = a / radix_bits;\n        } else {\n            a = a * radix_bits;\n        }\n    } else {\n        const uint32_t *tab;\n        limb_t b0, b1;\n        dlimb_t t;\n\n        if (is_inv) {\n            tab = inv_log2_radix[radix - 2];\n#if LIMB_BITS == 32\n            b1 = tab[0];\n            b0 = tab[1];\n#else\n            b1 = ((limb_t)tab[0] << 32) | tab[1];\n            b0 = (limb_t)tab[2] << 32;\n#endif\n            t = (dlimb_t)b0 * (dlimb_t)a;\n            t = (dlimb_t)b1 * (dlimb_t)a + (t >> LIMB_BITS);\n            a = t >> (LIMB_BITS - 1);\n        } else {\n            b0 = log2_radix[radix - 2];\n            t = (dlimb_t)b0 * (dlimb_t)a;\n            a = t >> (LIMB_BITS - 3);\n        }\n        /* a = floor(result) and 'result' cannot be an integer */\n        a += is_ceil;\n    }\n    if (is_neg)\n        a = -a;\n    return a;\n}\n\n/* 'n' is the number of output limbs */\nstatic int bf_integer_to_radix_rec(bf_t *pow_tab,\n                                   limb_t *out, const bf_t *a, limb_t n,\n                                   int level, limb_t n0, limb_t radixl,\n                                   unsigned int radixl_bits)\n{\n    limb_t n1, n2, q_prec;\n    int ret;\n\n    assert(n >= 1);\n    if (n == 1) {\n        out[0] = get_bits(a->tab, a->len, a->len * LIMB_BITS - a->expn);\n    } else if (n == 2) {\n        dlimb_t t;\n        slimb_t pos;\n        pos = a->len * LIMB_BITS - a->expn;\n        t = ((dlimb_t)get_bits(a->tab, a->len, pos + LIMB_BITS) << LIMB_BITS) |\n            get_bits(a->tab, a->len, pos);\n        if (likely(radixl == RADIXL_10)) {\n            /* use division by a constant when possible */\n            out[0] = t % RADIXL_10;\n            out[1] = t / RADIXL_10;\n        } else {\n            out[0] = t % radixl;\n            out[1] = t / radixl;\n        }\n    } else {\n        bf_t Q, R, *B, *B_inv;\n        int q_add;\n        bf_init(a->ctx, &Q);\n        bf_init(a->ctx, &R);\n        n2 = (((n0 * 2) >> (level + 1)) + 1) / 2;\n        n1 = n - n2;\n        B = &pow_tab[2 * level];\n        B_inv = &pow_tab[2 * level + 1];\n        ret = 0;\n        if (B->len == 0) {\n            /* compute BASE^n2 */\n            ret |= bf_pow_ui_ui(B, radixl, n2, BF_PREC_INF, BF_RNDZ);\n            /* we use enough bits for the maximum possible 'n1' value,\n               i.e. n2 + 1 */\n            ret |= bf_set_ui(&R, 1);\n            ret |= bf_div(B_inv, &R, B, (n2 + 1) * radixl_bits + 2, BF_RNDN);\n        }\n        //        printf(\"%d: n1=% \" PRId64 \" n2=%\" PRId64 \"\\n\", level, n1, n2);\n        q_prec = n1 * radixl_bits;\n        ret |= bf_mul(&Q, a, B_inv, q_prec, BF_RNDN);\n        ret |= bf_rint(&Q, BF_RNDZ);\n\n        ret |= bf_mul(&R, &Q, B, BF_PREC_INF, BF_RNDZ);\n        ret |= bf_sub(&R, a, &R, BF_PREC_INF, BF_RNDZ);\n\n        if (ret & BF_ST_MEM_ERROR)\n            goto fail;\n        /* adjust if necessary */\n        q_add = 0;\n        while (R.sign && R.len != 0) {\n            if (bf_add(&R, &R, B, BF_PREC_INF, BF_RNDZ))\n                goto fail;\n            q_add--;\n        }\n        while (bf_cmpu(&R, B) >= 0) {\n            if (bf_sub(&R, &R, B, BF_PREC_INF, BF_RNDZ))\n                goto fail;\n            q_add++;\n        }\n        if (q_add != 0) {\n            if (bf_add_si(&Q, &Q, q_add, BF_PREC_INF, BF_RNDZ))\n                goto fail;\n        }\n        if (bf_integer_to_radix_rec(pow_tab, out + n2, &Q, n1, level + 1, n0,\n                                    radixl, radixl_bits))\n            goto fail;\n        if (bf_integer_to_radix_rec(pow_tab, out, &R, n2, level + 1, n0,\n                                    radixl, radixl_bits)) {\n        fail:\n            bf_delete(&Q);\n            bf_delete(&R);\n            return -1;\n        }\n        bf_delete(&Q);\n        bf_delete(&R);\n    }\n    return 0;\n}\n\n/* return 0 if OK != 0 if memory error */\nstatic int bf_integer_to_radix(bf_t *r, const bf_t *a, limb_t radixl)\n{\n    bf_context_t *s = r->ctx;\n    limb_t r_len;\n    bf_t *pow_tab;\n    int i, pow_tab_len, ret;\n\n    r_len = r->len;\n    pow_tab_len = (ceil_log2(r_len) + 2) * 2; /* XXX: check */\n    pow_tab = bf_malloc(s, sizeof(pow_tab[0]) * pow_tab_len);\n    if (!pow_tab)\n        return -1;\n    for(i = 0; i < pow_tab_len; i++)\n        bf_init(r->ctx, &pow_tab[i]);\n\n    ret = bf_integer_to_radix_rec(pow_tab, r->tab, a, r_len, 0, r_len, radixl,\n                                  ceil_log2(radixl));\n\n    for(i = 0; i < pow_tab_len; i++) {\n        bf_delete(&pow_tab[i]);\n    }\n    bf_free(s, pow_tab);\n    return ret;\n}\n\n/* a must be >= 0. 'P' is the wanted number of digits in radix\n   'radix'. 'r' is the mantissa represented as an integer. *pE\n   contains the exponent. Return != 0 if memory error. */\nstatic int bf_convert_to_radix(bf_t *r, slimb_t *pE,\n                               const bf_t *a, int radix,\n                               limb_t P, bf_rnd_t rnd_mode,\n                               BOOL is_fixed_exponent)\n{\n    slimb_t E, e, prec, extra_bits, ziv_extra_bits, prec0;\n    bf_t B_s, *B = &B_s;\n    int e_sign, ret, res;\n\n    if (a->len == 0) {\n        /* zero case */\n        *pE = 0;\n        return bf_set(r, a);\n    }\n\n    if (is_fixed_exponent) {\n        E = *pE;\n    } else {\n        /* compute the new exponent */\n        E = 1 + bf_mul_log2_radix(a->expn - 1, radix, TRUE, FALSE);\n    }\n    //    bf_print_str(\"a\", a);\n    //    printf(\"E=%ld P=%ld radix=%d\\n\", E, P, radix);\n\n    for(;;) {\n        e = P - E;\n        e_sign = 0;\n        if (e < 0) {\n            e = -e;\n            e_sign = 1;\n        }\n        /* Note: precision for log2(radix) is not critical here */\n        prec0 = bf_mul_log2_radix(P, radix, FALSE, TRUE);\n        ziv_extra_bits = 16;\n        for(;;) {\n            prec = prec0 + ziv_extra_bits;\n            /* XXX: rigorous error analysis needed */\n            extra_bits = ceil_log2(e) * 2 + 1;\n            ret = bf_pow_ui_ui(r, radix, e, prec + extra_bits,\n                               BF_RNDN | BF_FLAG_EXT_EXP);\n            if (!e_sign)\n                ret |= bf_mul(r, r, a, prec + extra_bits,\n                              BF_RNDN | BF_FLAG_EXT_EXP);\n            else\n                ret |= bf_div(r, a, r, prec + extra_bits,\n                              BF_RNDN | BF_FLAG_EXT_EXP);\n            if (ret & BF_ST_MEM_ERROR)\n                return BF_ST_MEM_ERROR;\n            /* if the result is not exact, check that it can be safely\n               rounded to an integer */\n            if ((ret & BF_ST_INEXACT) &&\n                !bf_can_round(r, r->expn, rnd_mode, prec)) {\n                /* and more precision and retry */\n                ziv_extra_bits = ziv_extra_bits  + (ziv_extra_bits / 2);\n                continue;\n            } else {\n                ret = bf_rint(r, rnd_mode);\n                if (ret & BF_ST_MEM_ERROR)\n                    return BF_ST_MEM_ERROR;\n                break;\n            }\n        }\n        if (is_fixed_exponent)\n            break;\n        /* check that the result is < B^P */\n        /* XXX: do a fast approximate test first ? */\n        bf_init(r->ctx, B);\n        ret = bf_pow_ui_ui(B, radix, P, BF_PREC_INF, BF_RNDZ);\n        if (ret) {\n            bf_delete(B);\n            return ret;\n        }\n        res = bf_cmpu(r, B);\n        bf_delete(B);\n        if (res < 0)\n            break;\n        /* try a larger exponent */\n        E++;\n    }\n    *pE = E;\n    return 0;\n}\n\nstatic void limb_to_a(char *buf, limb_t n, unsigned int radix, int len)\n{\n    int digit, i;\n\n    if (radix == 10) {\n        /* specific case with constant divisor */\n        for(i = len - 1; i >= 0; i--) {\n            digit = (limb_t)n % 10;\n            n = (limb_t)n / 10;\n            buf[i] = digit + '0';\n        }\n    } else {\n        for(i = len - 1; i >= 0; i--) {\n            digit = (limb_t)n % radix;\n            n = (limb_t)n / radix;\n            if (digit < 10)\n                digit += '0';\n            else\n                digit += 'a' - 10;\n            buf[i] = digit;\n        }\n    }\n}\n\n/* for power of 2 radixes */\nstatic void limb_to_a2(char *buf, limb_t n, unsigned int radix_bits, int len)\n{\n    int digit, i;\n    unsigned int mask;\n\n    mask = (1 << radix_bits) - 1;\n    for(i = len - 1; i >= 0; i--) {\n        digit = n & mask;\n        n >>= radix_bits;\n        if (digit < 10)\n            digit += '0';\n        else\n            digit += 'a' - 10;\n        buf[i] = digit;\n    }\n}\n\n/* 'a' must be an integer if the is_dec = FALSE or if the radix is not\n   a power of two. A dot is added before the 'dot_pos' digit. dot_pos\n   = n_digits does not display the dot. 0 <= dot_pos <=\n   n_digits. n_digits >= 1. */\nstatic void output_digits(DynBuf *s, const bf_t *a1, int radix, limb_t n_digits,\n                          limb_t dot_pos, BOOL is_dec)\n{\n    limb_t i, v, l;\n    slimb_t pos, pos_incr;\n    int digits_per_limb, buf_pos, radix_bits, first_buf_pos;\n    char buf[65];\n    bf_t a_s, *a;\n\n    if (is_dec) {\n        digits_per_limb = LIMB_DIGITS;\n        a = (bf_t *)a1;\n        radix_bits = 0;\n        pos = a->len;\n        pos_incr = 1;\n        first_buf_pos = 0;\n    } else if ((radix & (radix - 1)) == 0) {\n        a = (bf_t *)a1;\n        radix_bits = ceil_log2(radix);\n        digits_per_limb = LIMB_BITS / radix_bits;\n        pos_incr = digits_per_limb * radix_bits;\n        /* digits are aligned relative to the radix point */\n        pos = a->len * LIMB_BITS + smod(-a->expn, radix_bits);\n        first_buf_pos = 0;\n    } else {\n        limb_t n, radixl;\n\n        digits_per_limb = digits_per_limb_table[radix - 2];\n        radixl = get_limb_radix(radix);\n        a = &a_s;\n        bf_init(a1->ctx, a);\n        n = (n_digits + digits_per_limb - 1) / digits_per_limb;\n        if (bf_resize(a, n)) {\n            dbuf_set_error(s);\n            goto done;\n        }\n        if (bf_integer_to_radix(a, a1, radixl)) {\n            dbuf_set_error(s);\n            goto done;\n        }\n        radix_bits = 0;\n        pos = n;\n        pos_incr = 1;\n        first_buf_pos = pos * digits_per_limb - n_digits;\n    }\n    buf_pos = digits_per_limb;\n    i = 0;\n    while (i < n_digits) {\n        if (buf_pos == digits_per_limb) {\n            pos -= pos_incr;\n            if (radix_bits == 0) {\n                v = get_limbz(a, pos);\n                limb_to_a(buf, v, radix, digits_per_limb);\n            } else {\n                v = get_bits(a->tab, a->len, pos);\n                limb_to_a2(buf, v, radix_bits, digits_per_limb);\n            }\n            buf_pos = first_buf_pos;\n            first_buf_pos = 0;\n        }\n        if (i < dot_pos) {\n            l = dot_pos;\n        } else {\n            if (i == dot_pos)\n                dbuf_putc(s, '.');\n            l = n_digits;\n        }\n        l = bf_min(digits_per_limb - buf_pos, l - i);\n        dbuf_put(s, (uint8_t *)(buf + buf_pos), l);\n        buf_pos += l;\n        i += l;\n    }\n done:\n    if (a != a1)\n        bf_delete(a);\n}\n\nstatic void *bf_dbuf_realloc(void *opaque, void *ptr, size_t size)\n{\n    bf_context_t *s = opaque;\n    return bf_realloc(s, ptr, size);\n}\n\n/* return the length in bytes. A trailing '\\0' is added */\nstatic char *bf_ftoa_internal(size_t *plen, const bf_t *a2, int radix,\n                              limb_t prec, bf_flags_t flags, BOOL is_dec)\n{\n    bf_context_t *ctx = a2->ctx;\n    DynBuf s_s, *s = &s_s;\n    int radix_bits;\n\n    //    bf_print_str(\"ftoa\", a2);\n    //    printf(\"radix=%d\\n\", radix);\n    dbuf_init2(s, ctx, bf_dbuf_realloc);\n    if (a2->expn == BF_EXP_NAN) {\n        dbuf_putstr(s, \"NaN\");\n    } else {\n        if (a2->sign)\n            dbuf_putc(s, '-');\n        if (a2->expn == BF_EXP_INF) {\n            if (flags & BF_FTOA_JS_QUIRKS)\n                dbuf_putstr(s, \"Infinity\");\n            else\n                dbuf_putstr(s, \"Inf\");\n        } else {\n            int fmt, ret;\n            slimb_t n_digits, n, i, n_max, n1;\n            bf_t a1_s, *a1 = &a1_s;\n\n            if ((radix & (radix - 1)) != 0)\n                radix_bits = 0;\n            else\n                radix_bits = ceil_log2(radix);\n\n            fmt = flags & BF_FTOA_FORMAT_MASK;\n            bf_init(ctx, a1);\n            if (fmt == BF_FTOA_FORMAT_FRAC) {\n                if (is_dec || radix_bits != 0) {\n                    if (bf_set(a1, a2))\n                        goto fail1;\n#ifdef USE_BF_DEC\n                    if (is_dec) {\n                        if (bfdec_round((bfdec_t *)a1, prec, (flags & BF_RND_MASK) | BF_FLAG_RADPNT_PREC) & BF_ST_MEM_ERROR)\n                            goto fail1;\n                        n = a1->expn;\n                    } else\n#endif\n                    {\n                        if (bf_round(a1, prec * radix_bits, (flags & BF_RND_MASK) | BF_FLAG_RADPNT_PREC) & BF_ST_MEM_ERROR)\n                            goto fail1;\n                        n = ceil_div(a1->expn, radix_bits);\n                    }\n                    if (flags & BF_FTOA_ADD_PREFIX) {\n                        if (radix == 16)\n                            dbuf_putstr(s, \"0x\");\n                        else if (radix == 8)\n                            dbuf_putstr(s, \"0o\");\n                        else if (radix == 2)\n                            dbuf_putstr(s, \"0b\");\n                    }\n                    if (a1->expn == BF_EXP_ZERO) {\n                        dbuf_putstr(s, \"0\");\n                        if (prec > 0) {\n                            dbuf_putstr(s, \".\");\n                            for(i = 0; i < prec; i++) {\n                                dbuf_putc(s, '0');\n                            }\n                        }\n                    } else {\n                        n_digits = prec + n;\n                        if (n <= 0) {\n                            /* 0.x */\n                            dbuf_putstr(s, \"0.\");\n                            for(i = 0; i < -n; i++) {\n                                dbuf_putc(s, '0');\n                            }\n                            if (n_digits > 0) {\n                                output_digits(s, a1, radix, n_digits, n_digits, is_dec);\n                            }\n                        } else {\n                            output_digits(s, a1, radix, n_digits, n, is_dec);\n                        }\n                    }\n                } else {\n                    size_t pos, start;\n                    bf_t a_s, *a = &a_s;\n\n                    /* make a positive number */\n                    a->tab = a2->tab;\n                    a->len = a2->len;\n                    a->expn = a2->expn;\n                    a->sign = 0;\n\n                    /* one more digit for the rounding */\n                    n = 1 + bf_mul_log2_radix(bf_max(a->expn, 0), radix, TRUE, TRUE);\n                    n_digits = n + prec;\n                    n1 = n;\n                    if (bf_convert_to_radix(a1, &n1, a, radix, n_digits,\n                                            flags & BF_RND_MASK, TRUE))\n                        goto fail1;\n                    start = s->size;\n                    output_digits(s, a1, radix, n_digits, n, is_dec);\n                    /* remove leading zeros because we allocated one more digit */\n                    pos = start;\n                    while ((pos + 1) < s->size && s->buf[pos] == '0' &&\n                           s->buf[pos + 1] != '.')\n                        pos++;\n                    if (pos > start) {\n                        memmove(s->buf + start, s->buf + pos, s->size - pos);\n                        s->size -= (pos - start);\n                    }\n                }\n            } else {\n#ifdef USE_BF_DEC\n                if (is_dec) {\n                    if (bf_set(a1, a2))\n                        goto fail1;\n                    if (fmt == BF_FTOA_FORMAT_FIXED) {\n                        n_digits = prec;\n                        n_max = n_digits;\n                        if (bfdec_round((bfdec_t *)a1, prec, (flags & BF_RND_MASK)) & BF_ST_MEM_ERROR)\n                            goto fail1;\n                    } else {\n                        /* prec is ignored */\n                        prec = n_digits = a1->len * LIMB_DIGITS;\n                        /* remove the trailing zero digits */\n                        while (n_digits > 1 &&\n                               get_digit(a1->tab, a1->len, prec - n_digits) == 0) {\n                            n_digits--;\n                        }\n                        n_max = n_digits + 4;\n                    }\n                    n = a1->expn;\n                } else\n#endif\n                if (radix_bits != 0) {\n                    if (bf_set(a1, a2))\n                        goto fail1;\n                    if (fmt == BF_FTOA_FORMAT_FIXED) {\n                        slimb_t prec_bits;\n                        n_digits = prec;\n                        n_max = n_digits;\n                        /* align to the radix point */\n                        prec_bits = prec * radix_bits -\n                            smod(-a1->expn, radix_bits);\n                        if (bf_round(a1, prec_bits,\n                                     (flags & BF_RND_MASK)) & BF_ST_MEM_ERROR)\n                            goto fail1;\n                    } else {\n                        limb_t digit_mask;\n                        slimb_t pos;\n                        /* position of the digit before the most\n                           significant digit in bits */\n                        pos = a1->len * LIMB_BITS +\n                            smod(-a1->expn, radix_bits);\n                        n_digits = ceil_div(pos, radix_bits);\n                        /* remove the trailing zero digits */\n                        digit_mask = ((limb_t)1 << radix_bits) - 1;\n                        while (n_digits > 1 &&\n                               (get_bits(a1->tab, a1->len, pos - n_digits * radix_bits) & digit_mask) == 0) {\n                            n_digits--;\n                        }\n                        n_max = n_digits + 4;\n                    }\n                    n = ceil_div(a1->expn, radix_bits);\n                } else {\n                    bf_t a_s, *a = &a_s;\n\n                    /* make a positive number */\n                    a->tab = a2->tab;\n                    a->len = a2->len;\n                    a->expn = a2->expn;\n                    a->sign = 0;\n\n                    if (fmt == BF_FTOA_FORMAT_FIXED) {\n                        n_digits = prec;\n                        n_max = n_digits;\n                    } else {\n                        slimb_t n_digits_max, n_digits_min;\n\n                        assert(prec != BF_PREC_INF);\n                        n_digits = 1 + bf_mul_log2_radix(prec, radix, TRUE, TRUE);\n                        /* max number of digits for non exponential\n                           notation. The rational is to have the same rule\n                           as JS i.e. n_max = 21 for 64 bit float in base 10. */\n                        n_max = n_digits + 4;\n                        if (fmt == BF_FTOA_FORMAT_FREE_MIN) {\n                            bf_t b_s, *b = &b_s;\n\n                            /* find the minimum number of digits by\n                               dichotomy. */\n                            /* XXX: inefficient */\n                            n_digits_max = n_digits;\n                            n_digits_min = 1;\n                            bf_init(ctx, b);\n                            while (n_digits_min < n_digits_max) {\n                                n_digits = (n_digits_min + n_digits_max) / 2;\n                                if (bf_convert_to_radix(a1, &n, a, radix, n_digits,\n                                                        flags & BF_RND_MASK, FALSE)) {\n                                    bf_delete(b);\n                                    goto fail1;\n                                }\n                                /* convert back to a number and compare */\n                                ret = bf_mul_pow_radix(b, a1, radix, n - n_digits,\n                                                       prec,\n                                                       (flags & ~BF_RND_MASK) |\n                                                       BF_RNDN);\n                                if (ret & BF_ST_MEM_ERROR) {\n                                    bf_delete(b);\n                                    goto fail1;\n                                }\n                                if (bf_cmpu(b, a) == 0) {\n                                    n_digits_max = n_digits;\n                                } else {\n                                    n_digits_min = n_digits + 1;\n                                }\n                            }\n                            bf_delete(b);\n                            n_digits = n_digits_max;\n                        }\n                    }\n                    if (bf_convert_to_radix(a1, &n, a, radix, n_digits,\n                                            flags & BF_RND_MASK, FALSE)) {\n                    fail1:\n                        bf_delete(a1);\n                        goto fail;\n                    }\n                }\n                if (a1->expn == BF_EXP_ZERO &&\n                    fmt != BF_FTOA_FORMAT_FIXED &&\n                    !(flags & BF_FTOA_FORCE_EXP)) {\n                    /* just output zero */\n                    dbuf_putstr(s, \"0\");\n                } else {\n                    if (flags & BF_FTOA_ADD_PREFIX) {\n                        if (radix == 16)\n                            dbuf_putstr(s, \"0x\");\n                        else if (radix == 8)\n                            dbuf_putstr(s, \"0o\");\n                        else if (radix == 2)\n                            dbuf_putstr(s, \"0b\");\n                    }\n                    if (a1->expn == BF_EXP_ZERO)\n                        n = 1;\n                    if ((flags & BF_FTOA_FORCE_EXP) ||\n                        n <= -6 || n > n_max) {\n                        const char *fmt;\n                        /* exponential notation */\n                        output_digits(s, a1, radix, n_digits, 1, is_dec);\n                        if (radix_bits != 0 && radix <= 16) {\n                            if (flags & BF_FTOA_JS_QUIRKS)\n                                fmt = \"p%+\" PRId_LIMB;\n                            else\n                                fmt = \"p%\" PRId_LIMB;\n                            dbuf_printf(s, fmt, (n - 1) * radix_bits);\n                        } else {\n                            if (flags & BF_FTOA_JS_QUIRKS)\n                                fmt = \"%c%+\" PRId_LIMB;\n                            else\n                                fmt = \"%c%\" PRId_LIMB;\n                            dbuf_printf(s, fmt,\n                                        radix <= 10 ? 'e' : '@', n - 1);\n                        }\n                    } else if (n <= 0) {\n                        /* 0.x */\n                        dbuf_putstr(s, \"0.\");\n                        for(i = 0; i < -n; i++) {\n                            dbuf_putc(s, '0');\n                        }\n                        output_digits(s, a1, radix, n_digits, n_digits, is_dec);\n                    } else {\n                        if (n_digits <= n) {\n                            /* no dot */\n                            output_digits(s, a1, radix, n_digits, n_digits, is_dec);\n                            for(i = 0; i < (n - n_digits); i++)\n                                dbuf_putc(s, '0');\n                        } else {\n                            output_digits(s, a1, radix, n_digits, n, is_dec);\n                        }\n                    }\n                }\n            }\n            bf_delete(a1);\n        }\n    }\n    dbuf_putc(s, '\\0');\n    if (dbuf_error(s))\n        goto fail;\n    if (plen)\n        *plen = s->size - 1;\n    return (char *)s->buf;\n fail:\n    bf_free(ctx, s->buf);\n    if (plen)\n        *plen = 0;\n    return NULL;\n}\n\nchar *bf_ftoa(size_t *plen, const bf_t *a, int radix, limb_t prec,\n              bf_flags_t flags)\n{\n    return bf_ftoa_internal(plen, a, radix, prec, flags, FALSE);\n}\n\n/***************************************************************/\n/* transcendental functions */\n\n/* Note: the algorithm is from MPFR */\nstatic void bf_const_log2_rec(bf_t *T, bf_t *P, bf_t *Q, limb_t n1,\n                              limb_t n2, BOOL need_P)\n{\n    bf_context_t *s = T->ctx;\n    if ((n2 - n1) == 1) {\n        if (n1 == 0) {\n            bf_set_ui(P, 3);\n        } else {\n            bf_set_ui(P, n1);\n            P->sign = 1;\n        }\n        bf_set_ui(Q, 2 * n1 + 1);\n        Q->expn += 2;\n        bf_set(T, P);\n    } else {\n        limb_t m;\n        bf_t T1_s, *T1 = &T1_s;\n        bf_t P1_s, *P1 = &P1_s;\n        bf_t Q1_s, *Q1 = &Q1_s;\n\n        m = n1 + ((n2 - n1) >> 1);\n        bf_const_log2_rec(T, P, Q, n1, m, TRUE);\n        bf_init(s, T1);\n        bf_init(s, P1);\n        bf_init(s, Q1);\n        bf_const_log2_rec(T1, P1, Q1, m, n2, need_P);\n        bf_mul(T, T, Q1, BF_PREC_INF, BF_RNDZ);\n        bf_mul(T1, T1, P, BF_PREC_INF, BF_RNDZ);\n        bf_add(T, T, T1, BF_PREC_INF, BF_RNDZ);\n        if (need_P)\n            bf_mul(P, P, P1, BF_PREC_INF, BF_RNDZ);\n        bf_mul(Q, Q, Q1, BF_PREC_INF, BF_RNDZ);\n        bf_delete(T1);\n        bf_delete(P1);\n        bf_delete(Q1);\n    }\n}\n\n/* compute log(2) with faithful rounding at precision 'prec' */\nstatic void bf_const_log2_internal(bf_t *T, limb_t prec)\n{\n    limb_t w, N;\n    bf_t P_s, *P = &P_s;\n    bf_t Q_s, *Q = &Q_s;\n\n    w = prec + 15;\n    N = w / 3 + 1;\n    bf_init(T->ctx, P);\n    bf_init(T->ctx, Q);\n    bf_const_log2_rec(T, P, Q, 0, N, FALSE);\n    bf_div(T, T, Q, prec, BF_RNDN);\n    bf_delete(P);\n    bf_delete(Q);\n}\n\n/* PI constant */\n\n#define CHUD_A 13591409\n#define CHUD_B 545140134\n#define CHUD_C 640320\n#define CHUD_BITS_PER_TERM 47\n\nstatic void chud_bs(bf_t *P, bf_t *Q, bf_t *G, int64_t a, int64_t b, int need_g,\n                    limb_t prec)\n{\n    bf_context_t *s = P->ctx;\n    int64_t c;\n\n    if (a == (b - 1)) {\n        bf_t T0, T1;\n\n        bf_init(s, &T0);\n        bf_init(s, &T1);\n        bf_set_ui(G, 2 * b - 1);\n        bf_mul_ui(G, G, 6 * b - 1, prec, BF_RNDN);\n        bf_mul_ui(G, G, 6 * b - 5, prec, BF_RNDN);\n        bf_set_ui(&T0, CHUD_B);\n        bf_mul_ui(&T0, &T0, b, prec, BF_RNDN);\n        bf_set_ui(&T1, CHUD_A);\n        bf_add(&T0, &T0, &T1, prec, BF_RNDN);\n        bf_mul(P, G, &T0, prec, BF_RNDN);\n        P->sign = b & 1;\n\n        bf_set_ui(Q, b);\n        bf_mul_ui(Q, Q, b, prec, BF_RNDN);\n        bf_mul_ui(Q, Q, b, prec, BF_RNDN);\n        bf_mul_ui(Q, Q, (uint64_t)CHUD_C * CHUD_C * CHUD_C / 24, prec, BF_RNDN);\n        bf_delete(&T0);\n        bf_delete(&T1);\n    } else {\n        bf_t P2, Q2, G2;\n\n        bf_init(s, &P2);\n        bf_init(s, &Q2);\n        bf_init(s, &G2);\n\n        c = (a + b) / 2;\n        chud_bs(P, Q, G, a, c, 1, prec);\n        chud_bs(&P2, &Q2, &G2, c, b, need_g, prec);\n\n        /* Q = Q1 * Q2 */\n        /* G = G1 * G2 */\n        /* P = P1 * Q2 + P2 * G1 */\n        bf_mul(&P2, &P2, G, prec, BF_RNDN);\n        if (!need_g)\n            bf_set_ui(G, 0);\n        bf_mul(P, P, &Q2, prec, BF_RNDN);\n        bf_add(P, P, &P2, prec, BF_RNDN);\n        bf_delete(&P2);\n\n        bf_mul(Q, Q, &Q2, prec, BF_RNDN);\n        bf_delete(&Q2);\n        if (need_g)\n            bf_mul(G, G, &G2, prec, BF_RNDN);\n        bf_delete(&G2);\n    }\n}\n\n/* compute Pi with faithful rounding at precision 'prec' using the\n   Chudnovsky formula */\nstatic void bf_const_pi_internal(bf_t *Q, limb_t prec)\n{\n    bf_context_t *s = Q->ctx;\n    int64_t n, prec1;\n    bf_t P, G;\n\n    /* number of serie terms */\n    n = prec / CHUD_BITS_PER_TERM + 1;\n    /* XXX: precision analysis */\n    prec1 = prec + 32;\n\n    bf_init(s, &P);\n    bf_init(s, &G);\n\n    chud_bs(&P, Q, &G, 0, n, 0, BF_PREC_INF);\n\n    bf_mul_ui(&G, Q, CHUD_A, prec1, BF_RNDN);\n    bf_add(&P, &G, &P, prec1, BF_RNDN);\n    bf_div(Q, Q, &P, prec1, BF_RNDF);\n\n    bf_set_ui(&P, CHUD_C);\n    bf_sqrt(&G, &P, prec1, BF_RNDF);\n    bf_mul_ui(&G, &G, (uint64_t)CHUD_C / 12, prec1, BF_RNDF);\n    bf_mul(Q, Q, &G, prec, BF_RNDN);\n    bf_delete(&P);\n    bf_delete(&G);\n}\n\nstatic int bf_const_get(bf_t *T, limb_t prec, bf_flags_t flags,\n                        BFConstCache *c,\n                        void (*func)(bf_t *res, limb_t prec), int sign)\n{\n    limb_t ziv_extra_bits, prec1;\n\n    ziv_extra_bits = 32;\n    for(;;) {\n        prec1 = prec + ziv_extra_bits;\n        if (c->prec < prec1) {\n            if (c->val.len == 0)\n                bf_init(T->ctx, &c->val);\n            func(&c->val, prec1);\n            c->prec = prec1;\n        } else {\n            prec1 = c->prec;\n        }\n        bf_set(T, &c->val);\n        T->sign = sign;\n        if (!bf_can_round(T, prec, flags & BF_RND_MASK, prec1)) {\n            /* and more precision and retry */\n            ziv_extra_bits = ziv_extra_bits  + (ziv_extra_bits / 2);\n        } else {\n            break;\n        }\n    }\n    return bf_round(T, prec, flags);\n}\n\nstatic void bf_const_free(BFConstCache *c)\n{\n    bf_delete(&c->val);\n    memset(c, 0, sizeof(*c));\n}\n\nint bf_const_log2(bf_t *T, limb_t prec, bf_flags_t flags)\n{\n    bf_context_t *s = T->ctx;\n    return bf_const_get(T, prec, flags, &s->log2_cache, bf_const_log2_internal, 0);\n}\n\n/* return rounded pi * (1 - 2 * sign) */\nstatic int bf_const_pi_signed(bf_t *T, int sign, limb_t prec, bf_flags_t flags)\n{\n    bf_context_t *s = T->ctx;\n    return bf_const_get(T, prec, flags, &s->pi_cache, bf_const_pi_internal,\n                        sign);\n}\n\nint bf_const_pi(bf_t *T, limb_t prec, bf_flags_t flags)\n{\n    return bf_const_pi_signed(T, 0, prec, flags);\n}\n\nvoid bf_clear_cache(bf_context_t *s)\n{\n#ifdef USE_FFT_MUL\n    fft_clear_cache(s);\n#endif\n    bf_const_free(&s->log2_cache);\n    bf_const_free(&s->pi_cache);\n}\n\n/* ZivFunc should compute the result 'r' with faithful rounding at\n   precision 'prec'. For efficiency purposes, the final bf_round()\n   does not need to be done in the function. */\ntypedef int ZivFunc(bf_t *r, const bf_t *a, limb_t prec, void *opaque);\n\nstatic int bf_ziv_rounding(bf_t *r, const bf_t *a,\n                           limb_t prec, bf_flags_t flags,\n                           ZivFunc *f, void *opaque)\n{\n    int rnd_mode, ret;\n    slimb_t prec1, ziv_extra_bits;\n\n    rnd_mode = flags & BF_RND_MASK;\n    if (rnd_mode == BF_RNDF) {\n        /* no need to iterate */\n        f(r, a, prec, opaque);\n        ret = 0;\n    } else {\n        ziv_extra_bits = 32;\n        for(;;) {\n            prec1 = prec + ziv_extra_bits;\n            ret = f(r, a, prec1, opaque);\n            if (ret & (BF_ST_OVERFLOW | BF_ST_UNDERFLOW | BF_ST_MEM_ERROR)) {\n                /* overflow or underflow should never happen because\n                   it indicates the rounding cannot be done correctly,\n                   but we do not catch all the cases */\n                return ret;\n            }\n            /* if the result is exact, we can stop */\n            if (!(ret & BF_ST_INEXACT)) {\n                ret = 0;\n                break;\n            }\n            if (bf_can_round(r, prec, rnd_mode, prec1)) {\n                ret = BF_ST_INEXACT;\n                break;\n            }\n            ziv_extra_bits = ziv_extra_bits * 2;\n            //            printf(\"ziv_extra_bits=%\" PRId64 \"\\n\", (int64_t)ziv_extra_bits);\n        }\n    }\n    if (r->len == 0)\n        return ret;\n    else\n        return __bf_round(r, prec, flags, r->len, ret);\n}\n\n/* add (1 - 2*e_sign) * 2^e */\nstatic int bf_add_epsilon(bf_t *r, const bf_t *a, slimb_t e, int e_sign,\n                          limb_t prec, int flags)\n{\n    bf_t T_s, *T = &T_s;\n    int ret;\n    /* small argument case: result = 1 + epsilon * sign(x) */\n    bf_init(a->ctx, T);\n    bf_set_ui(T, 1);\n    T->sign = e_sign;\n    T->expn += e;\n    ret = bf_add(r, r, T, prec, flags);\n    bf_delete(T);\n    return ret;\n}\n\n/* Compute the exponential using faithful rounding at precision 'prec'.\n   Note: the algorithm is from MPFR */\nstatic int bf_exp_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)\n{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n    slimb_t n, K, l, i, prec1;\n\n    assert(r != a);\n\n    /* argument reduction:\n       T = a - n*log(2) with 0 <= T < log(2) and n integer.\n    */\n    bf_init(s, T);\n    if (a->expn <= -1) {\n        /* 0 <= abs(a) <= 0.5 */\n        if (a->sign)\n            n = -1;\n        else\n            n = 0;\n    } else {\n        bf_const_log2(T, LIMB_BITS, BF_RNDZ);\n        bf_div(T, a, T, LIMB_BITS, BF_RNDD);\n        bf_get_limb(&n, T, 0);\n    }\n\n    K = bf_isqrt((prec + 1) / 2);\n    l = (prec - 1) / K + 1;\n    /* XXX: precision analysis ? */\n    prec1 = prec + (K + 2 * l + 18) + K + 8;\n    if (a->expn > 0)\n        prec1 += a->expn;\n    //    printf(\"n=%ld K=%ld prec1=%ld\\n\", n, K, prec1);\n\n    bf_const_log2(T, prec1, BF_RNDF);\n    bf_mul_si(T, T, n, prec1, BF_RNDN);\n    bf_sub(T, a, T, prec1, BF_RNDN);\n\n    /* reduce the range of T */\n    bf_mul_2exp(T, -K, BF_PREC_INF, BF_RNDZ);\n\n    /* Taylor expansion around zero :\n     1 + x + x^2/2 + ... + x^n/n!\n     = (1 + x * (1 + x/2 * (1 + ... (x/n))))\n    */\n    {\n        bf_t U_s, *U = &U_s;\n\n        bf_init(s, U);\n        bf_set_ui(r, 1);\n        for(i = l ; i >= 1; i--) {\n            bf_set_ui(U, i);\n            bf_div(U, T, U, prec1, BF_RNDN);\n            bf_mul(r, r, U, prec1, BF_RNDN);\n            bf_add_si(r, r, 1, prec1, BF_RNDN);\n        }\n        bf_delete(U);\n    }\n    bf_delete(T);\n\n    /* undo the range reduction */\n    for(i = 0; i < K; i++) {\n        bf_mul(r, r, r, prec1, BF_RNDN | BF_FLAG_EXT_EXP);\n    }\n\n    /* undo the argument reduction */\n    bf_mul_2exp(r, n, BF_PREC_INF, BF_RNDZ | BF_FLAG_EXT_EXP);\n\n    return BF_ST_INEXACT;\n}\n\n/* crude overflow and underflow tests for exp(a). a_low <= a <= a_high */\nstatic int check_exp_underflow_overflow(bf_context_t *s, bf_t *r,\n                                        const bf_t *a_low, const bf_t *a_high,\n                                        limb_t prec, bf_flags_t flags)\n{\n    bf_t T_s, *T = &T_s;\n    bf_t log2_s, *log2 = &log2_s;\n    slimb_t e_min, e_max;\n\n    if (a_high->expn <= 0)\n        return 0;\n\n    e_max = (limb_t)1 << (bf_get_exp_bits(flags) - 1);\n    e_min = -e_max + 3;\n    if (flags & BF_FLAG_SUBNORMAL)\n        e_min -= (prec - 1);\n\n    bf_init(s, T);\n    bf_init(s, log2);\n    bf_const_log2(log2, LIMB_BITS, BF_RNDU);\n    bf_mul_ui(T, log2, e_max, LIMB_BITS, BF_RNDU);\n    /* a_low > e_max * log(2) implies exp(a) > e_max */\n    if (bf_cmp_lt(T, a_low) > 0) {\n        /* overflow */\n        bf_delete(T);\n        bf_delete(log2);\n        return bf_set_overflow(r, 0, prec, flags);\n    }\n    /* a_high < (e_min - 2) * log(2) implies exp(a) < (e_min - 2) */\n    bf_const_log2(log2, LIMB_BITS, BF_RNDD);\n    bf_mul_si(T, log2, e_min - 2, LIMB_BITS, BF_RNDD);\n    if (bf_cmp_lt(a_high, T)) {\n        int rnd_mode = flags & BF_RND_MASK;\n\n        /* underflow */\n        bf_delete(T);\n        bf_delete(log2);\n        if (rnd_mode == BF_RNDU) {\n            /* set the smallest value */\n            bf_set_ui(r, 1);\n            r->expn = e_min;\n        } else {\n            bf_set_zero(r, 0);\n        }\n        return BF_ST_UNDERFLOW | BF_ST_INEXACT;\n    }\n    bf_delete(log2);\n    bf_delete(T);\n    return 0;\n}\n\nint bf_exp(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)\n{\n    bf_context_t *s = r->ctx;\n    int ret;\n    assert(r != a);\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n        } else if (a->expn == BF_EXP_INF) {\n            if (a->sign)\n                bf_set_zero(r, 0);\n            else\n                bf_set_inf(r, 0);\n        } else {\n            bf_set_ui(r, 1);\n        }\n        return 0;\n    }\n\n    ret = check_exp_underflow_overflow(s, r, a, a, prec, flags);\n    if (ret)\n        return ret;\n    if (a->expn < 0 && (-a->expn) >= (prec + 2)) {\n        /* small argument case: result = 1 + epsilon * sign(x) */\n        bf_set_ui(r, 1);\n        return bf_add_epsilon(r, r, -(prec + 2), a->sign, prec, flags);\n    }\n\n    return bf_ziv_rounding(r, a, prec, flags, bf_exp_internal, NULL);\n}\n\nstatic int bf_log_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)\n{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n    bf_t U_s, *U = &U_s;\n    bf_t V_s, *V = &V_s;\n    slimb_t n, prec1, l, i, K;\n\n    assert(r != a);\n\n    bf_init(s, T);\n    /* argument reduction 1 */\n    /* T=a*2^n with 2/3 <= T <= 4/3 */\n    {\n        bf_t U_s, *U = &U_s;\n        bf_set(T, a);\n        n = T->expn;\n        T->expn = 0;\n        /* U= ~ 2/3 */\n        bf_init(s, U);\n        bf_set_ui(U, 0xaaaaaaaa);\n        U->expn = 0;\n        if (bf_cmp_lt(T, U)) {\n            T->expn++;\n            n--;\n        }\n        bf_delete(U);\n    }\n    //    printf(\"n=%ld\\n\", n);\n    //    bf_print_str(\"T\", T);\n\n    /* XXX: precision analysis */\n    /* number of iterations for argument reduction 2 */\n    K = bf_isqrt((prec + 1) / 2);\n    /* order of Taylor expansion */\n    l = prec / (2 * K) + 1;\n    /* precision of the intermediate computations */\n    prec1 = prec + K + 2 * l + 32;\n\n    bf_init(s, U);\n    bf_init(s, V);\n\n    /* Note: cancellation occurs here, so we use more precision (XXX:\n       reduce the precision by computing the exact cancellation) */\n    bf_add_si(T, T, -1, BF_PREC_INF, BF_RNDN);\n\n    /* argument reduction 2 */\n    for(i = 0; i < K; i++) {\n        /* T = T / (1 + sqrt(1 + T)) */\n        bf_add_si(U, T, 1, prec1, BF_RNDN);\n        bf_sqrt(V, U, prec1, BF_RNDF);\n        bf_add_si(U, V, 1, prec1, BF_RNDN);\n        bf_div(T, T, U, prec1, BF_RNDN);\n    }\n\n    {\n        bf_t Y_s, *Y = &Y_s;\n        bf_t Y2_s, *Y2 = &Y2_s;\n        bf_init(s, Y);\n        bf_init(s, Y2);\n\n        /* compute ln(1+x) = ln((1+y)/(1-y)) with y=x/(2+x)\n           = y + y^3/3 + ... + y^(2*l + 1) / (2*l+1)\n           with Y=Y^2\n           = y*(1+Y/3+Y^2/5+...) = y*(1+Y*(1/3+Y*(1/5 + ...)))\n        */\n        bf_add_si(Y, T, 2, prec1, BF_RNDN);\n        bf_div(Y, T, Y, prec1, BF_RNDN);\n\n        bf_mul(Y2, Y, Y, prec1, BF_RNDN);\n        bf_set_ui(r, 0);\n        for(i = l; i >= 1; i--) {\n            bf_set_ui(U, 1);\n            bf_set_ui(V, 2 * i + 1);\n            bf_div(U, U, V, prec1, BF_RNDN);\n            bf_add(r, r, U, prec1, BF_RNDN);\n            bf_mul(r, r, Y2, prec1, BF_RNDN);\n        }\n        bf_add_si(r, r, 1, prec1, BF_RNDN);\n        bf_mul(r, r, Y, prec1, BF_RNDN);\n        bf_delete(Y);\n        bf_delete(Y2);\n    }\n    bf_delete(V);\n    bf_delete(U);\n\n    /* multiplication by 2 for the Taylor expansion and undo the\n       argument reduction 2*/\n    bf_mul_2exp(r, K + 1, BF_PREC_INF, BF_RNDZ);\n\n    /* undo the argument reduction 1 */\n    bf_const_log2(T, prec1, BF_RNDF);\n    bf_mul_si(T, T, n, prec1, BF_RNDN);\n    bf_add(r, r, T, prec1, BF_RNDN);\n\n    bf_delete(T);\n    return BF_ST_INEXACT;\n}\n\nint bf_log(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)\n{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n\n    assert(r != a);\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF) {\n            if (a->sign) {\n                bf_set_nan(r);\n                return BF_ST_INVALID_OP;\n            } else {\n                bf_set_inf(r, 0);\n                return 0;\n            }\n        } else {\n            bf_set_inf(r, 1);\n            return 0;\n        }\n    }\n    if (a->sign) {\n        bf_set_nan(r);\n        return BF_ST_INVALID_OP;\n    }\n    bf_init(s, T);\n    bf_set_ui(T, 1);\n    if (bf_cmp_eq(a, T)) {\n        bf_set_zero(r, 0);\n        bf_delete(T);\n        return 0;\n    }\n    bf_delete(T);\n\n    return bf_ziv_rounding(r, a, prec, flags, bf_log_internal, NULL);\n}\n\n/* x and y finite and x > 0 */\nstatic int bf_pow_generic(bf_t *r, const bf_t *x, limb_t prec, void *opaque)\n{\n    bf_context_t *s = r->ctx;\n    const bf_t *y = opaque;\n    bf_t T_s, *T = &T_s;\n    limb_t prec1;\n\n    bf_init(s, T);\n    /* XXX: proof for the added precision */\n    prec1 = prec + 32;\n    bf_log(T, x, prec1, BF_RNDF | BF_FLAG_EXT_EXP);\n    bf_mul(T, T, y, prec1, BF_RNDF | BF_FLAG_EXT_EXP);\n    if (bf_is_nan(T))\n        bf_set_nan(r);\n    else\n        bf_exp_internal(r, T, prec1, NULL); /* no overflow/underlow test needed */\n    bf_delete(T);\n    return BF_ST_INEXACT;\n}\n\n/* x and y finite, x > 0, y integer and y fits on one limb */\nstatic int bf_pow_int(bf_t *r, const bf_t *x, limb_t prec, void *opaque)\n{\n    bf_context_t *s = r->ctx;\n    const bf_t *y = opaque;\n    bf_t T_s, *T = &T_s;\n    limb_t prec1;\n    int ret;\n    slimb_t y1;\n\n    bf_get_limb(&y1, y, 0);\n    if (y1 < 0)\n        y1 = -y1;\n    /* XXX: proof for the added precision */\n    prec1 = prec + ceil_log2(y1) * 2 + 8;\n    ret = bf_pow_ui(r, x, y1 < 0 ? -y1 : y1, prec1, BF_RNDN | BF_FLAG_EXT_EXP);\n    if (y->sign) {\n        bf_init(s, T);\n        bf_set_ui(T, 1);\n        ret |= bf_div(r, T, r, prec1, BF_RNDN | BF_FLAG_EXT_EXP);\n        bf_delete(T);\n    }\n    return ret;\n}\n\n/* x must be a finite non zero float. Return TRUE if there is a\n   floating point number r such as x=r^(2^n) and return this floating\n   point number 'r'. Otherwise return FALSE and r is undefined. */\nstatic BOOL check_exact_power2n(bf_t *r, const bf_t *x, slimb_t n)\n{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n    slimb_t e, i, er;\n    limb_t v;\n\n    /* x = m*2^e with m odd integer */\n    e = bf_get_exp_min(x);\n    /* fast check on the exponent */\n    if (n > (LIMB_BITS - 1)) {\n        if (e != 0)\n            return FALSE;\n        er = 0;\n    } else {\n        if ((e & (((limb_t)1 << n) - 1)) != 0)\n            return FALSE;\n        er = e >> n;\n    }\n    /* every perfect odd square = 1 modulo 8 */\n    v = get_bits(x->tab, x->len, x->len * LIMB_BITS - x->expn + e);\n    if ((v & 7) != 1)\n        return FALSE;\n\n    bf_init(s, T);\n    bf_set(T, x);\n    T->expn -= e;\n    for(i = 0; i < n; i++) {\n        if (i != 0)\n            bf_set(T, r);\n        if (bf_sqrtrem(r, NULL, T) != 0)\n            return FALSE;\n    }\n    r->expn += er;\n    return TRUE;\n}\n\n/* prec = BF_PREC_INF is accepted for x and y integers and y >= 0 */\nint bf_pow(bf_t *r, const bf_t *x, const bf_t *y, limb_t prec, bf_flags_t flags)\n{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n    bf_t ytmp_s;\n    BOOL y_is_int, y_is_odd;\n    int r_sign, ret, rnd_mode;\n    slimb_t y_emin;\n\n    if (x->len == 0 || y->len == 0) {\n        if (y->expn == BF_EXP_ZERO) {\n            /* pow(x, 0) = 1 */\n            bf_set_ui(r, 1);\n        } else if (x->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n        } else {\n            int cmp_x_abs_1;\n            bf_set_ui(r, 1);\n            cmp_x_abs_1 = bf_cmpu(x, r);\n            if (cmp_x_abs_1 == 0 && (flags & BF_POW_JS_QUIRKS) &&\n                (y->expn >= BF_EXP_INF)) {\n                bf_set_nan(r);\n            } else if (cmp_x_abs_1 == 0 &&\n                       (!x->sign || y->expn != BF_EXP_NAN)) {\n                /* pow(1, y) = 1 even if y = NaN */\n                /* pow(-1, +/-inf) = 1 */\n            } else if (y->expn == BF_EXP_NAN) {\n                bf_set_nan(r);\n            } else if (y->expn == BF_EXP_INF) {\n                if (y->sign == (cmp_x_abs_1 > 0)) {\n                    bf_set_zero(r, 0);\n                } else {\n                    bf_set_inf(r, 0);\n                }\n            } else {\n                y_emin = bf_get_exp_min(y);\n                y_is_odd = (y_emin == 0);\n                if (y->sign == (x->expn == BF_EXP_ZERO)) {\n                    bf_set_inf(r, y_is_odd & x->sign);\n                    if (y->sign) {\n                        /* pow(0, y) with y < 0 */\n                        return BF_ST_DIVIDE_ZERO;\n                    }\n                } else {\n                    bf_set_zero(r, y_is_odd & x->sign);\n                }\n            }\n        }\n        return 0;\n    }\n    bf_init(s, T);\n    bf_set(T, x);\n    y_emin = bf_get_exp_min(y);\n    y_is_int = (y_emin >= 0);\n    rnd_mode = flags & BF_RND_MASK;\n    if (x->sign) {\n        if (!y_is_int) {\n            bf_set_nan(r);\n            bf_delete(T);\n            return BF_ST_INVALID_OP;\n        }\n        y_is_odd = (y_emin == 0);\n        r_sign = y_is_odd;\n        /* change the directed rounding mode if the sign of the result\n           is changed */\n        if (r_sign && (rnd_mode == BF_RNDD || rnd_mode == BF_RNDU))\n            flags ^= 1;\n        bf_neg(T);\n    } else {\n        r_sign = 0;\n    }\n\n    bf_set_ui(r, 1);\n    if (bf_cmp_eq(T, r)) {\n        /* abs(x) = 1: nothing more to do */\n        ret = 0;\n    } else {\n        /* check the overflow/underflow cases */\n        {\n            bf_t al_s, *al = &al_s;\n            bf_t ah_s, *ah = &ah_s;\n            limb_t precl = LIMB_BITS;\n\n            bf_init(s, al);\n            bf_init(s, ah);\n            /* compute bounds of log(abs(x)) * y with a low precision */\n            /* XXX: compute bf_log() once */\n            /* XXX: add a fast test before this slow test */\n            bf_log(al, T, precl, BF_RNDD);\n            bf_log(ah, T, precl, BF_RNDU);\n            bf_mul(al, al, y, precl, BF_RNDD ^ y->sign);\n            bf_mul(ah, ah, y, precl, BF_RNDU ^ y->sign);\n            ret = check_exp_underflow_overflow(s, r, al, ah, prec, flags);\n            bf_delete(al);\n            bf_delete(ah);\n            if (ret)\n                goto done;\n        }\n\n        if (y_is_int) {\n            slimb_t T_bits, e;\n        int_pow:\n            T_bits = T->expn - bf_get_exp_min(T);\n            if (T_bits == 1) {\n                /* pow(2^b, y) = 2^(b*y) */\n                bf_mul_si(T, y, T->expn - 1, LIMB_BITS, BF_RNDZ);\n                bf_get_limb(&e, T, 0);\n                bf_set_ui(r, 1);\n                ret = bf_mul_2exp(r, e, prec, flags);\n            } else if (prec == BF_PREC_INF) {\n                slimb_t y1;\n                /* specific case for infinite precision (integer case) */\n                bf_get_limb(&y1, y, 0);\n                assert(!y->sign);\n                /* x must be an integer, so abs(x) >= 2 */\n                if (y1 >= ((slimb_t)1 << BF_EXP_BITS_MAX)) {\n                    bf_delete(T);\n                    return bf_set_overflow(r, 0, BF_PREC_INF, flags);\n                }\n                ret = bf_pow_ui(r, T, y1, BF_PREC_INF, BF_RNDZ);\n            } else {\n                if (y->expn <= 31) {\n                    /* small enough power: use exponentiation in all cases */\n                } else if (y->sign) {\n                    /* cannot be exact */\n                    goto general_case;\n                } else {\n                    if (rnd_mode == BF_RNDF)\n                        goto general_case; /* no need to track exact results */\n                    /* see if the result has a chance to be exact:\n                       if x=a*2^b (a odd), x^y=a^y*2^(b*y)\n                       x^y needs a precision of at least floor_log2(a)*y bits\n                    */\n                    bf_mul_si(r, y, T_bits - 1, LIMB_BITS, BF_RNDZ);\n                    bf_get_limb(&e, r, 0);\n                    if (prec < e)\n                        goto general_case;\n                }\n                ret = bf_ziv_rounding(r, T, prec, flags, bf_pow_int, (void *)y);\n            }\n        } else {\n            if (rnd_mode != BF_RNDF) {\n                bf_t *y1;\n                if (y_emin < 0 && check_exact_power2n(r, T, -y_emin)) {\n                    /* the problem is reduced to a power to an integer */\n#if 0\n                    printf(\"\\nn=%\" PRId64 \"\\n\", -(int64_t)y_emin);\n                    bf_print_str(\"T\", T);\n                    bf_print_str(\"r\", r);\n#endif\n                    bf_set(T, r);\n                    y1 = &ytmp_s;\n                    y1->tab = y->tab;\n                    y1->len = y->len;\n                    y1->sign = y->sign;\n                    y1->expn = y->expn - y_emin;\n                    y = y1;\n                    goto int_pow;\n                }\n            }\n        general_case:\n            ret = bf_ziv_rounding(r, T, prec, flags, bf_pow_generic, (void *)y);\n        }\n    }\n done:\n    bf_delete(T);\n    r->sign = r_sign;\n    return ret;\n}\n\n/* compute sqrt(-2*x-x^2) to get |sin(x)| from cos(x) - 1. */\nstatic void bf_sqrt_sin(bf_t *r, const bf_t *x, limb_t prec1)\n{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n    bf_init(s, T);\n    bf_set(T, x);\n    bf_mul(r, T, T, prec1, BF_RNDN);\n    bf_mul_2exp(T, 1, BF_PREC_INF, BF_RNDZ);\n    bf_add(T, T, r, prec1, BF_RNDN);\n    bf_neg(T);\n    bf_sqrt(r, T, prec1, BF_RNDF);\n    bf_delete(T);\n}\n\nstatic int bf_sincos(bf_t *s, bf_t *c, const bf_t *a, limb_t prec)\n{\n    bf_context_t *s1 = a->ctx;\n    bf_t T_s, *T = &T_s;\n    bf_t U_s, *U = &U_s;\n    bf_t r_s, *r = &r_s;\n    slimb_t K, prec1, i, l, mod, prec2;\n    int is_neg;\n\n    assert(c != a && s != a);\n\n    bf_init(s1, T);\n    bf_init(s1, U);\n    bf_init(s1, r);\n\n    /* XXX: precision analysis */\n    K = bf_isqrt(prec / 2);\n    l = prec / (2 * K) + 1;\n    prec1 = prec + 2 * K + l + 8;\n\n    /* after the modulo reduction, -pi/4 <= T <= pi/4 */\n    if (a->expn <= -1) {\n        /* abs(a) <= 0.25: no modulo reduction needed */\n        bf_set(T, a);\n        mod = 0;\n    } else {\n        slimb_t cancel;\n        cancel = 0;\n        for(;;) {\n            prec2 = prec1 + a->expn + cancel;\n            bf_const_pi(U, prec2, BF_RNDF);\n            bf_mul_2exp(U, -1, BF_PREC_INF, BF_RNDZ);\n            bf_remquo(&mod, T, a, U, prec2, BF_RNDN, BF_RNDN);\n            //            printf(\"T.expn=%ld prec2=%ld\\n\", T->expn, prec2);\n            if (mod == 0 || (T->expn != BF_EXP_ZERO &&\n                             (T->expn + prec2) >= (prec1 - 1)))\n                break;\n            /* increase the number of bits until the precision is good enough */\n            cancel = bf_max(-T->expn, (cancel + 1) * 3 / 2);\n        }\n        mod &= 3;\n    }\n\n    is_neg = T->sign;\n\n    /* compute cosm1(x) = cos(x) - 1 */\n    bf_mul(T, T, T, prec1, BF_RNDN);\n    bf_mul_2exp(T, -2 * K, BF_PREC_INF, BF_RNDZ);\n\n    /* Taylor expansion:\n       -x^2/2 + x^4/4! - x^6/6! + ...\n    */\n    bf_set_ui(r, 1);\n    for(i = l ; i >= 1; i--) {\n        bf_set_ui(U, 2 * i - 1);\n        bf_mul_ui(U, U, 2 * i, BF_PREC_INF, BF_RNDZ);\n        bf_div(U, T, U, prec1, BF_RNDN);\n        bf_mul(r, r, U, prec1, BF_RNDN);\n        bf_neg(r);\n        if (i != 1)\n            bf_add_si(r, r, 1, prec1, BF_RNDN);\n    }\n    bf_delete(U);\n\n    /* undo argument reduction:\n       cosm1(2*x)= 2*(2*cosm1(x)+cosm1(x)^2)\n    */\n    for(i = 0; i < K; i++) {\n        bf_mul(T, r, r, prec1, BF_RNDN);\n        bf_mul_2exp(r, 1, BF_PREC_INF, BF_RNDZ);\n        bf_add(r, r, T, prec1, BF_RNDN);\n        bf_mul_2exp(r, 1, BF_PREC_INF, BF_RNDZ);\n    }\n    bf_delete(T);\n\n    if (c) {\n        if ((mod & 1) == 0) {\n            bf_add_si(c, r, 1, prec1, BF_RNDN);\n        } else {\n            bf_sqrt_sin(c, r, prec1);\n            c->sign = is_neg ^ 1;\n        }\n        c->sign ^= mod >> 1;\n    }\n    if (s) {\n        if ((mod & 1) == 0) {\n            bf_sqrt_sin(s, r, prec1);\n            s->sign = is_neg;\n        } else {\n            bf_add_si(s, r, 1, prec1, BF_RNDN);\n        }\n        s->sign ^= mod >> 1;\n    }\n    bf_delete(r);\n    return BF_ST_INEXACT;\n}\n\nstatic int bf_cos_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)\n{\n    return bf_sincos(NULL, r, a, prec);\n}\n\nint bf_cos(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)\n{\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF) {\n            bf_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else {\n            bf_set_ui(r, 1);\n            return 0;\n        }\n    }\n\n    /* small argument case: result = 1+r(x) with r(x) = -x^2/2 +\n       O(X^4). We assume r(x) < 2^(2*EXP(x) - 1). */\n    if (a->expn < 0) {\n        slimb_t e;\n        e = 2 * a->expn - 1;\n        if (e < -(prec + 2)) {\n            bf_set_ui(r, 1);\n            return bf_add_epsilon(r, r, e, 1, prec, flags);\n        }\n    }\n\n    return bf_ziv_rounding(r, a, prec, flags, bf_cos_internal, NULL);\n}\n\nstatic int bf_sin_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)\n{\n    return bf_sincos(r, NULL, a, prec);\n}\n\nint bf_sin(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)\n{\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF) {\n            bf_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else {\n            bf_set_zero(r, a->sign);\n            return 0;\n        }\n    }\n\n    /* small argument case: result = x+r(x) with r(x) = -x^3/6 +\n       O(X^5). We assume r(x) < 2^(3*EXP(x) - 2). */\n    if (a->expn < 0) {\n        slimb_t e;\n        e = sat_add(2 * a->expn, a->expn - 2);\n        if (e < a->expn - bf_max(prec + 2, a->len * LIMB_BITS + 2)) {\n            bf_set(r, a);\n            return bf_add_epsilon(r, r, e, 1 - a->sign, prec, flags);\n        }\n    }\n\n    return bf_ziv_rounding(r, a, prec, flags, bf_sin_internal, NULL);\n}\n\nstatic int bf_tan_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)\n{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n    limb_t prec1;\n\n    /* XXX: precision analysis */\n    prec1 = prec + 8;\n    bf_init(s, T);\n    bf_sincos(r, T, a, prec1);\n    bf_div(r, r, T, prec1, BF_RNDF);\n    bf_delete(T);\n    return BF_ST_INEXACT;\n}\n\nint bf_tan(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)\n{\n    assert(r != a);\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF) {\n            bf_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else {\n            bf_set_zero(r, a->sign);\n            return 0;\n        }\n    }\n\n    /* small argument case: result = x+r(x) with r(x) = x^3/3 +\n       O(X^5). We assume r(x) < 2^(3*EXP(x) - 1). */\n    if (a->expn < 0) {\n        slimb_t e;\n        e = sat_add(2 * a->expn, a->expn - 1);\n        if (e < a->expn - bf_max(prec + 2, a->len * LIMB_BITS + 2)) {\n            bf_set(r, a);\n            return bf_add_epsilon(r, r, e, a->sign, prec, flags);\n        }\n    }\n\n    return bf_ziv_rounding(r, a, prec, flags, bf_tan_internal, NULL);\n}\n\n/* if add_pi2 is true, add pi/2 to the result (used for acos(x) to\n   avoid cancellation) */\nstatic int bf_atan_internal(bf_t *r, const bf_t *a, limb_t prec,\n                            void *opaque)\n{\n    bf_context_t *s = r->ctx;\n    BOOL add_pi2 = (BOOL)(intptr_t)opaque;\n    bf_t T_s, *T = &T_s;\n    bf_t U_s, *U = &U_s;\n    bf_t V_s, *V = &V_s;\n    bf_t X2_s, *X2 = &X2_s;\n    int cmp_1;\n    slimb_t prec1, i, K, l;\n\n    /* XXX: precision analysis */\n    K = bf_isqrt((prec + 1) / 2);\n    l = prec / (2 * K) + 1;\n    prec1 = prec + K + 2 * l + 32;\n    //    printf(\"prec=%d K=%d l=%d prec1=%d\\n\", (int)prec, (int)K, (int)l, (int)prec1);\n\n    bf_init(s, T);\n    cmp_1 = (a->expn >= 1); /* a >= 1 */\n    if (cmp_1) {\n        bf_set_ui(T, 1);\n        bf_div(T, T, a, prec1, BF_RNDN);\n    } else {\n        bf_set(T, a);\n    }\n\n    /* abs(T) <= 1 */\n\n    /* argument reduction */\n\n    bf_init(s, U);\n    bf_init(s, V);\n    bf_init(s, X2);\n    for(i = 0; i < K; i++) {\n        /* T = T / (1 + sqrt(1 + T^2)) */\n        bf_mul(U, T, T, prec1, BF_RNDN);\n        bf_add_si(U, U, 1, prec1, BF_RNDN);\n        bf_sqrt(V, U, prec1, BF_RNDN);\n        bf_add_si(V, V, 1, prec1, BF_RNDN);\n        bf_div(T, T, V, prec1, BF_RNDN);\n    }\n\n    /* Taylor series:\n       x - x^3/3 + ... + (-1)^ l * y^(2*l + 1) / (2*l+1)\n    */\n    bf_mul(X2, T, T, prec1, BF_RNDN);\n    bf_set_ui(r, 0);\n    for(i = l; i >= 1; i--) {\n        bf_set_si(U, 1);\n        bf_set_ui(V, 2 * i + 1);\n        bf_div(U, U, V, prec1, BF_RNDN);\n        bf_neg(r);\n        bf_add(r, r, U, prec1, BF_RNDN);\n        bf_mul(r, r, X2, prec1, BF_RNDN);\n    }\n    bf_neg(r);\n    bf_add_si(r, r, 1, prec1, BF_RNDN);\n    bf_mul(r, r, T, prec1, BF_RNDN);\n\n    /* undo the argument reduction */\n    bf_mul_2exp(r, K, BF_PREC_INF, BF_RNDZ);\n\n    bf_delete(U);\n    bf_delete(V);\n    bf_delete(X2);\n\n    i = add_pi2;\n    if (cmp_1 > 0) {\n        /* undo the inversion : r = sign(a)*PI/2 - r */\n        bf_neg(r);\n        i += 1 - 2 * a->sign;\n    }\n    /* add i*(pi/2) with -1 <= i <= 2 */\n    if (i != 0) {\n        bf_const_pi(T, prec1, BF_RNDF);\n        if (i != 2)\n            bf_mul_2exp(T, -1, BF_PREC_INF, BF_RNDZ);\n        T->sign = (i < 0);\n        bf_add(r, T, r, prec1, BF_RNDN);\n    }\n\n    bf_delete(T);\n    return BF_ST_INEXACT;\n}\n\nint bf_atan(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)\n{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n    int res;\n\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF)  {\n            /* -PI/2 or PI/2 */\n            bf_const_pi_signed(r, a->sign, prec, flags);\n            bf_mul_2exp(r, -1, BF_PREC_INF, BF_RNDZ);\n            return BF_ST_INEXACT;\n        } else {\n            bf_set_zero(r, a->sign);\n            return 0;\n        }\n    }\n\n    bf_init(s, T);\n    bf_set_ui(T, 1);\n    res = bf_cmpu(a, T);\n    bf_delete(T);\n    if (res == 0) {\n        /* short cut: abs(a) == 1 -> +/-pi/4 */\n        bf_const_pi_signed(r, a->sign, prec, flags);\n        bf_mul_2exp(r, -2, BF_PREC_INF, BF_RNDZ);\n        return BF_ST_INEXACT;\n    }\n\n    /* small argument case: result = x+r(x) with r(x) = -x^3/3 +\n       O(X^5). We assume r(x) < 2^(3*EXP(x) - 1). */\n    if (a->expn < 0) {\n        slimb_t e;\n        e = sat_add(2 * a->expn, a->expn - 1);\n        if (e < a->expn - bf_max(prec + 2, a->len * LIMB_BITS + 2)) {\n            bf_set(r, a);\n            return bf_add_epsilon(r, r, e, 1 - a->sign, prec, flags);\n        }\n    }\n\n    return bf_ziv_rounding(r, a, prec, flags, bf_atan_internal, (void *)FALSE);\n}\n\nstatic int bf_atan2_internal(bf_t *r, const bf_t *y, limb_t prec, void *opaque)\n{\n    bf_context_t *s = r->ctx;\n    const bf_t *x = opaque;\n    bf_t T_s, *T = &T_s;\n    limb_t prec1;\n    int ret;\n\n    if (y->expn == BF_EXP_NAN || x->expn == BF_EXP_NAN) {\n        bf_set_nan(r);\n        return 0;\n    }\n\n    /* compute atan(y/x) assumming inf/inf = 1 and 0/0 = 0 */\n    bf_init(s, T);\n    prec1 = prec + 32;\n    if (y->expn == BF_EXP_INF && x->expn == BF_EXP_INF) {\n        bf_set_ui(T, 1);\n        T->sign = y->sign ^ x->sign;\n    } else if (y->expn == BF_EXP_ZERO && x->expn == BF_EXP_ZERO) {\n        bf_set_zero(T, y->sign ^ x->sign);\n    } else {\n        bf_div(T, y, x, prec1, BF_RNDF);\n    }\n    ret = bf_atan(r, T, prec1, BF_RNDF);\n\n    if (x->sign) {\n        /* if x < 0 (it includes -0), return sign(y)*pi + atan(y/x) */\n        bf_const_pi(T, prec1, BF_RNDF);\n        T->sign = y->sign;\n        bf_add(r, r, T, prec1, BF_RNDN);\n        ret |= BF_ST_INEXACT;\n    }\n\n    bf_delete(T);\n    return ret;\n}\n\nint bf_atan2(bf_t *r, const bf_t *y, const bf_t *x,\n             limb_t prec, bf_flags_t flags)\n{\n    return bf_ziv_rounding(r, y, prec, flags, bf_atan2_internal, (void *)x);\n}\n\nstatic int bf_asin_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)\n{\n    bf_context_t *s = r->ctx;\n    BOOL is_acos = (BOOL)(intptr_t)opaque;\n    bf_t T_s, *T = &T_s;\n    limb_t prec1, prec2;\n\n    /* asin(x) = atan(x/sqrt(1-x^2))\n       acos(x) = pi/2 - asin(x) */\n    prec1 = prec + 8;\n    /* increase the precision in x^2 to compensate the cancellation in\n       (1-x^2) if x is close to 1 */\n    /* XXX: use less precision when possible */\n    if (a->expn >= 0)\n        prec2 = BF_PREC_INF;\n    else\n        prec2 = prec1;\n    bf_init(s, T);\n    bf_mul(T, a, a, prec2, BF_RNDN);\n    bf_neg(T);\n    bf_add_si(T, T, 1, prec2, BF_RNDN);\n\n    bf_sqrt(r, T, prec1, BF_RNDN);\n    bf_div(T, a, r, prec1, BF_RNDN);\n    if (is_acos)\n        bf_neg(T);\n    bf_atan_internal(r, T, prec1, (void *)(intptr_t)is_acos);\n    bf_delete(T);\n    return BF_ST_INEXACT;\n}\n\nint bf_asin(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)\n{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n    int res;\n\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF) {\n            bf_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else {\n            bf_set_zero(r, a->sign);\n            return 0;\n        }\n    }\n    bf_init(s, T);\n    bf_set_ui(T, 1);\n    res = bf_cmpu(a, T);\n    bf_delete(T);\n    if (res > 0) {\n        bf_set_nan(r);\n        return BF_ST_INVALID_OP;\n    }\n\n    /* small argument case: result = x+r(x) with r(x) = x^3/6 +\n       O(X^5). We assume r(x) < 2^(3*EXP(x) - 2). */\n    if (a->expn < 0) {\n        slimb_t e;\n        e = sat_add(2 * a->expn, a->expn - 2);\n        if (e < a->expn - bf_max(prec + 2, a->len * LIMB_BITS + 2)) {\n            bf_set(r, a);\n            return bf_add_epsilon(r, r, e, a->sign, prec, flags);\n        }\n    }\n\n    return bf_ziv_rounding(r, a, prec, flags, bf_asin_internal, (void *)FALSE);\n}\n\nint bf_acos(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)\n{\n    bf_context_t *s = r->ctx;\n    bf_t T_s, *T = &T_s;\n    int res;\n\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bf_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF) {\n            bf_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else {\n            bf_const_pi(r, prec, flags);\n            bf_mul_2exp(r, -1, BF_PREC_INF, BF_RNDZ);\n            return BF_ST_INEXACT;\n        }\n    }\n    bf_init(s, T);\n    bf_set_ui(T, 1);\n    res = bf_cmpu(a, T);\n    bf_delete(T);\n    if (res > 0) {\n        bf_set_nan(r);\n        return BF_ST_INVALID_OP;\n    } else if (res == 0 && a->sign == 0) {\n        bf_set_zero(r, 0);\n        return 0;\n    }\n\n    return bf_ziv_rounding(r, a, prec, flags, bf_asin_internal, (void *)TRUE);\n}\n\n/***************************************************************/\n/* decimal floating point numbers */\n\n#ifdef USE_BF_DEC\n\n#define adddq(r1, r0, a1, a0)                   \\\n    do {                                        \\\n        limb_t __t = r0;                        \\\n        r0 += (a0);                             \\\n        r1 += (a1) + (r0 < __t);                \\\n    } while (0)\n\n#define subdq(r1, r0, a1, a0)                   \\\n    do {                                        \\\n        limb_t __t = r0;                        \\\n        r0 -= (a0);                             \\\n        r1 -= (a1) + (r0 > __t);                \\\n    } while (0)\n\n#if LIMB_BITS == 64\n\n/* Note: we assume __int128 is available */\n#define muldq(r1, r0, a, b)                     \\\n    do {                                        \\\n        unsigned __int128 __t;                          \\\n        __t = (unsigned __int128)(a) * (unsigned __int128)(b);  \\\n        r0 = __t;                               \\\n        r1 = __t >> 64;                         \\\n    } while (0)\n\n#define divdq(q, r, a1, a0, b)                  \\\n    do {                                        \\\n        unsigned __int128 __t;                  \\\n        limb_t __b = (b);                       \\\n        __t = ((unsigned __int128)(a1) << 64) | (a0);   \\\n        q = __t / __b;                                  \\\n        r = __t % __b;                                  \\\n    } while (0)\n\n#else\n\n#define muldq(r1, r0, a, b)                     \\\n    do {                                        \\\n        uint64_t __t;                          \\\n        __t = (uint64_t)(a) * (uint64_t)(b);  \\\n        r0 = __t;                               \\\n        r1 = __t >> 32;                         \\\n    } while (0)\n\n#define divdq(q, r, a1, a0, b)                  \\\n    do {                                        \\\n        uint64_t __t;                  \\\n        limb_t __b = (b);                       \\\n        __t = ((uint64_t)(a1) << 32) | (a0);   \\\n        q = __t / __b;                                  \\\n        r = __t % __b;                                  \\\n    } while (0)\n\n#endif /* LIMB_BITS != 64 */\n\n#if LIMB_DIGITS == 19\n\n/* WARNING: hardcoded for b = 1e19. It is assumed that:\n   0 <= a1 < 2^63 */\n#define divdq_base(q, r, a1, a0)\\\ndo {\\\n    uint64_t __a0, __a1, __t0, __t1, __b = BF_DEC_BASE; \\\n    __a0 = a0;\\\n    __a1 = a1;\\\n    __t0 = __a1;\\\n    __t0 = shld(__t0, __a0, 1);\\\n    muldq(q, __t1, __t0, UINT64_C(17014118346046923173)); \\\n    muldq(__t1, __t0, q, __b);\\\n    subdq(__a1, __a0, __t1, __t0);\\\n    subdq(__a1, __a0, 1, __b * 2);    \\\n    __t0 = (slimb_t)__a1 >> 1; \\\n    q += 2 + __t0;\\\n    adddq(__a1, __a0, 0, __b & __t0);\\\n    q += __a1;                  \\\n    __a0 += __b & __a1;           \\\n    r = __a0;\\\n} while(0)\n\n#elif LIMB_DIGITS == 9\n\n/* WARNING: hardcoded for b = 1e9. It is assumed that:\n   0 <= a1 < 2^29 */\n#define divdq_base(q, r, a1, a0)\\\ndo {\\\n    uint32_t __t0, __t1, __b = BF_DEC_BASE; \\\n    __t0 = a1;\\\n    __t1 = a0;\\\n    __t0 = (__t0 << 3) | (__t1 >> (32 - 3));    \\\n    muldq(q, __t1, __t0, 2305843009U);\\\n    r = a0 - q * __b;\\\n    __t1 = (r >= __b);\\\n    q += __t1;\\\n    if (__t1)\\\n        r -= __b;\\\n} while(0)\n\n#endif\n\n/* fast integer division by a fixed constant */\n\ntypedef struct FastDivData {\n    limb_t m1; /* multiplier */\n    int8_t shift1;\n    int8_t shift2;\n} FastDivData;\n\n/* From \"Division by Invariant Integers using Multiplication\" by\n   Torborn Granlund and Peter L. Montgomery */\n/* d must be != 0 */\nstatic inline __maybe_unused void fast_udiv_init(FastDivData *s, limb_t d)\n{\n    int l;\n    limb_t q, r, m1;\n    if (d == 1)\n        l = 0;\n    else\n        l = 64 - clz64(d - 1);\n    divdq(q, r, ((limb_t)1 << l) - d, 0, d);\n    (void)r;\n    m1 = q + 1;\n    //    printf(\"d=%lu l=%d m1=0x%016lx\\n\", d, l, m1);\n    s->m1 = m1;\n    s->shift1 = l;\n    if (s->shift1 > 1)\n        s->shift1 = 1;\n    s->shift2 = l - 1;\n    if (s->shift2 < 0)\n        s->shift2 = 0;\n}\n\nstatic inline limb_t fast_udiv(limb_t a, const FastDivData *s)\n{\n    limb_t t0, t1;\n    muldq(t1, t0, s->m1, a);\n    t0 = (a - t1) >> s->shift1;\n    return (t1 + t0) >> s->shift2;\n}\n\n/* contains 10^i */\nconst limb_t mp_pow_dec[LIMB_DIGITS + 1] = {\n    1U,\n    10U,\n    100U,\n    1000U,\n    10000U,\n    100000U,\n    1000000U,\n    10000000U,\n    100000000U,\n    1000000000U,\n#if LIMB_BITS == 64\n    10000000000U,\n    100000000000U,\n    1000000000000U,\n    10000000000000U,\n    100000000000000U,\n    1000000000000000U,\n    10000000000000000U,\n    100000000000000000U,\n    1000000000000000000U,\n    10000000000000000000U,\n#endif\n};\n\n/* precomputed from fast_udiv_init(10^i) */\nstatic const FastDivData mp_pow_div[LIMB_DIGITS + 1] = {\n#if LIMB_BITS == 32\n    { 0x00000001, 0, 0 },\n    { 0x9999999a, 1, 3 },\n    { 0x47ae147b, 1, 6 },\n    { 0x0624dd30, 1, 9 },\n    { 0xa36e2eb2, 1, 13 },\n    { 0x4f8b588f, 1, 16 },\n    { 0x0c6f7a0c, 1, 19 },\n    { 0xad7f29ac, 1, 23 },\n    { 0x5798ee24, 1, 26 },\n    { 0x12e0be83, 1, 29 },\n#else\n    { 0x0000000000000001, 0, 0 },\n    { 0x999999999999999a, 1, 3 },\n    { 0x47ae147ae147ae15, 1, 6 },\n    { 0x0624dd2f1a9fbe77, 1, 9 },\n    { 0xa36e2eb1c432ca58, 1, 13 },\n    { 0x4f8b588e368f0847, 1, 16 },\n    { 0x0c6f7a0b5ed8d36c, 1, 19 },\n    { 0xad7f29abcaf48579, 1, 23 },\n    { 0x5798ee2308c39dfa, 1, 26 },\n    { 0x12e0be826d694b2f, 1, 29 },\n    { 0xb7cdfd9d7bdbab7e, 1, 33 },\n    { 0x5fd7fe17964955fe, 1, 36 },\n    { 0x19799812dea11198, 1, 39 },\n    { 0xc25c268497681c27, 1, 43 },\n    { 0x6849b86a12b9b01f, 1, 46 },\n    { 0x203af9ee756159b3, 1, 49 },\n    { 0xcd2b297d889bc2b7, 1, 53 },\n    { 0x70ef54646d496893, 1, 56 },\n    { 0x2725dd1d243aba0f, 1, 59 },\n    { 0xd83c94fb6d2ac34d, 1, 63 },\n#endif\n};\n\n/* divide by 10^shift with 0 <= shift <= LIMB_DIGITS */\nstatic inline limb_t fast_shr_dec(limb_t a, int shift)\n{\n    return fast_udiv(a, &mp_pow_div[shift]);\n}\n\n/* division and remainder by 10^shift */\n#define fast_shr_rem_dec(q, r, a, shift) q = fast_shr_dec(a, shift), r = a - q * mp_pow_dec[shift]\n\nlimb_t mp_add_dec(limb_t *res, const limb_t *op1, const limb_t *op2,\n                  mp_size_t n, limb_t carry)\n{\n    limb_t base = BF_DEC_BASE;\n    mp_size_t i;\n    limb_t k, a, v;\n\n    k=carry;\n    for(i=0;i<n;i++) {\n        /* XXX: reuse the trick in add_mod */\n        v = op1[i];\n        a = v + op2[i] + k - base;\n        k = a <= v;\n        if (!k)\n            a += base;\n        res[i]=a;\n    }\n    return k;\n}\n\nlimb_t mp_add_ui_dec(limb_t *tab, limb_t b, mp_size_t n)\n{\n    limb_t base = BF_DEC_BASE;\n    mp_size_t i;\n    limb_t k, a, v;\n\n    k=b;\n    for(i=0;i<n;i++) {\n        v = tab[i];\n        a = v + k - base;\n        k = a <= v;\n        if (!k)\n            a += base;\n        tab[i] = a;\n        if (k == 0)\n            break;\n    }\n    return k;\n}\n\nlimb_t mp_sub_dec(limb_t *res, const limb_t *op1, const limb_t *op2,\n                  mp_size_t n, limb_t carry)\n{\n    limb_t base = BF_DEC_BASE;\n    mp_size_t i;\n    limb_t k, v, a;\n\n    k=carry;\n    for(i=0;i<n;i++) {\n        v = op1[i];\n        a = v - op2[i] - k;\n        k = a > v;\n        if (k)\n            a += base;\n        res[i] = a;\n    }\n    return k;\n}\n\nlimb_t mp_sub_ui_dec(limb_t *tab, limb_t b, mp_size_t n)\n{\n    limb_t base = BF_DEC_BASE;\n    mp_size_t i;\n    limb_t k, v, a;\n\n    k=b;\n    for(i=0;i<n;i++) {\n        v = tab[i];\n        a = v - k;\n        k = a > v;\n        if (k)\n            a += base;\n        tab[i]=a;\n        if (k == 0)\n            break;\n    }\n    return k;\n}\n\n/* taba[] = taba[] * b + l. 0 <= b, l <= base - 1. Return the high carry */\nlimb_t mp_mul1_dec(limb_t *tabr, const limb_t *taba, mp_size_t n,\n                   limb_t b, limb_t l)\n{\n    mp_size_t i;\n    limb_t t0, t1, r;\n\n    for(i = 0; i < n; i++) {\n        muldq(t1, t0, taba[i], b);\n        adddq(t1, t0, 0, l);\n        divdq_base(l, r, t1, t0);\n        tabr[i] = r;\n    }\n    return l;\n}\n\n/* tabr[] += taba[] * b. 0 <= b <= base - 1. Return the value to add\n   to the high word */\nlimb_t mp_add_mul1_dec(limb_t *tabr, const limb_t *taba, mp_size_t n,\n                       limb_t b)\n{\n    mp_size_t i;\n    limb_t l, t0, t1, r;\n\n    l = 0;\n    for(i = 0; i < n; i++) {\n        muldq(t1, t0, taba[i], b);\n        adddq(t1, t0, 0, l);\n        adddq(t1, t0, 0, tabr[i]);\n        divdq_base(l, r, t1, t0);\n        tabr[i] = r;\n    }\n    return l;\n}\n\n/* tabr[] -= taba[] * b. 0 <= b <= base - 1. Return the value to\n   substract to the high word. */\nlimb_t mp_sub_mul1_dec(limb_t *tabr, const limb_t *taba, mp_size_t n,\n                       limb_t b)\n{\n    limb_t base = BF_DEC_BASE;\n    mp_size_t i;\n    limb_t l, t0, t1, r, a, v, c;\n\n    /* XXX: optimize */\n    l = 0;\n    for(i = 0; i < n; i++) {\n        muldq(t1, t0, taba[i], b);\n        adddq(t1, t0, 0, l);\n        divdq_base(l, r, t1, t0);\n        v = tabr[i];\n        a = v - r;\n        c = a > v;\n        if (c)\n            a += base;\n        /* never bigger than base because r = 0 when l = base - 1 */\n        l += c;\n        tabr[i] = a;\n    }\n    return l;\n}\n\n/* size of the result : op1_size + op2_size. */\nvoid mp_mul_basecase_dec(limb_t *result,\n                         const limb_t *op1, mp_size_t op1_size,\n                         const limb_t *op2, mp_size_t op2_size)\n{\n    mp_size_t i;\n    limb_t r;\n\n    result[op1_size] = mp_mul1_dec(result, op1, op1_size, op2[0], 0);\n\n    for(i=1;i<op2_size;i++) {\n        r = mp_add_mul1_dec(result + i, op1, op1_size, op2[i]);\n        result[i + op1_size] = r;\n    }\n}\n\n/* taba[] = (taba[] + r*base^na) / b. 0 <= b < base. 0 <= r <\n   b. Return the remainder. */\nlimb_t mp_div1_dec(limb_t *tabr, const limb_t *taba, mp_size_t na,\n                   limb_t b, limb_t r)\n{\n    limb_t base = BF_DEC_BASE;\n    mp_size_t i;\n    limb_t t0, t1, q;\n    int shift;\n\n#if (BF_DEC_BASE % 2) == 0\n    if (b == 2) {\n        limb_t base_div2;\n        /* Note: only works if base is even */\n        base_div2 = base >> 1;\n        if (r)\n            r = base_div2;\n        for(i = na - 1; i >= 0; i--) {\n            t0 = taba[i];\n            tabr[i] = (t0 >> 1) + r;\n            r = 0;\n            if (t0 & 1)\n                r = base_div2;\n        }\n        if (r)\n            r = 1;\n    } else\n#endif\n    if (na >= UDIV1NORM_THRESHOLD) {\n        shift = clz(b);\n        if (shift == 0) {\n            /* normalized case: b >= 2^(LIMB_BITS-1) */\n            limb_t b_inv;\n            b_inv = udiv1norm_init(b);\n            for(i = na - 1; i >= 0; i--) {\n                muldq(t1, t0, r, base);\n                adddq(t1, t0, 0, taba[i]);\n                q = udiv1norm(&r, t1, t0, b, b_inv);\n                tabr[i] = q;\n            }\n        } else {\n            limb_t b_inv;\n            b <<= shift;\n            b_inv = udiv1norm_init(b);\n            for(i = na - 1; i >= 0; i--) {\n                muldq(t1, t0, r, base);\n                adddq(t1, t0, 0, taba[i]);\n                t1 = (t1 << shift) | (t0 >> (LIMB_BITS - shift));\n                t0 <<= shift;\n                q = udiv1norm(&r, t1, t0, b, b_inv);\n                r >>= shift;\n                tabr[i] = q;\n            }\n        }\n    } else {\n        for(i = na - 1; i >= 0; i--) {\n            muldq(t1, t0, r, base);\n            adddq(t1, t0, 0, taba[i]);\n            divdq(q, r, t1, t0, b);\n            tabr[i] = q;\n        }\n    }\n    return r;\n}\n\nstatic __maybe_unused void mp_print_str_dec(const char *str,\n                                       const limb_t *tab, slimb_t n)\n{\n    slimb_t i;\n    printf(\"%s=\", str);\n    for(i = n - 1; i >= 0; i--) {\n        if (i != n - 1)\n            printf(\"_\");\n        printf(\"%0*\" PRIu_LIMB, LIMB_DIGITS, tab[i]);\n    }\n    printf(\"\\n\");\n}\n\nstatic __maybe_unused void mp_print_str_h_dec(const char *str,\n                                              const limb_t *tab, slimb_t n,\n                                              limb_t high)\n{\n    slimb_t i;\n    printf(\"%s=\", str);\n    printf(\"%0*\" PRIu_LIMB, LIMB_DIGITS, high);\n    for(i = n - 1; i >= 0; i--) {\n        printf(\"_\");\n        printf(\"%0*\" PRIu_LIMB, LIMB_DIGITS, tab[i]);\n    }\n    printf(\"\\n\");\n}\n\n//#define DEBUG_DIV_SLOW\n\n#define DIV_STATIC_ALLOC_LEN 16\n\n/* return q = a / b and r = a % b.\n\n   taba[na] must be allocated if tabb1[nb - 1] < B / 2.  tabb1[nb - 1]\n   must be != zero. na must be >= nb. 's' can be NULL if tabb1[nb - 1]\n   >= B / 2.\n\n   The remainder is is returned in taba and contains nb libms. tabq\n   contains na - nb + 1 limbs. No overlap is permitted.\n\n   Running time of the standard method: (na - nb + 1) * nb\n   Return 0 if OK, -1 if memory alloc error\n*/\n/* XXX: optimize */\nstatic int mp_div_dec(bf_context_t *s, limb_t *tabq,\n                      limb_t *taba, mp_size_t na,\n                      const limb_t *tabb1, mp_size_t nb)\n{\n    limb_t base = BF_DEC_BASE;\n    limb_t r, mult, t0, t1, a, c, q, v, *tabb;\n    mp_size_t i, j;\n    limb_t static_tabb[DIV_STATIC_ALLOC_LEN];\n\n#ifdef DEBUG_DIV_SLOW\n    mp_print_str_dec(\"a\", taba, na);\n    mp_print_str_dec(\"b\", tabb1, nb);\n#endif\n\n    /* normalize tabb */\n    r = tabb1[nb - 1];\n    assert(r != 0);\n    i = na - nb;\n    if (r >= BF_DEC_BASE / 2) {\n        mult = 1;\n        tabb = (limb_t *)tabb1;\n        q = 1;\n        for(j = nb - 1; j >= 0; j--) {\n            if (taba[i + j] != tabb[j]) {\n                if (taba[i + j] < tabb[j])\n                    q = 0;\n                break;\n            }\n        }\n        tabq[i] = q;\n        if (q) {\n            mp_sub_dec(taba + i, taba + i, tabb, nb, 0);\n        }\n        i--;\n    } else {\n        mult = base / (r + 1);\n        if (likely(nb <= DIV_STATIC_ALLOC_LEN)) {\n            tabb = static_tabb;\n        } else {\n            tabb = bf_malloc(s, sizeof(limb_t) * nb);\n            if (!tabb)\n                return -1;\n        }\n        mp_mul1_dec(tabb, tabb1, nb, mult, 0);\n        taba[na] = mp_mul1_dec(taba, taba, na, mult, 0);\n    }\n\n#ifdef DEBUG_DIV_SLOW\n    printf(\"mult=\" FMT_LIMB \"\\n\", mult);\n    mp_print_str_dec(\"a_norm\", taba, na + 1);\n    mp_print_str_dec(\"b_norm\", tabb, nb);\n#endif\n\n    for(; i >= 0; i--) {\n        if (unlikely(taba[i + nb] >= tabb[nb - 1])) {\n            /* XXX: check if it is really possible */\n            q = base - 1;\n        } else {\n            muldq(t1, t0, taba[i + nb], base);\n            adddq(t1, t0, 0, taba[i + nb - 1]);\n            divdq(q, r, t1, t0, tabb[nb - 1]);\n        }\n        //        printf(\"i=%d q1=%ld\\n\", i, q);\n\n        r = mp_sub_mul1_dec(taba + i, tabb, nb, q);\n        //        mp_dump(\"r1\", taba + i, nb, bd);\n        //        printf(\"r2=%ld\\n\", r);\n\n        v = taba[i + nb];\n        a = v - r;\n        c = a > v;\n        if (c)\n            a += base;\n        taba[i + nb] = a;\n\n        if (c != 0) {\n            /* negative result */\n            for(;;) {\n                q--;\n                c = mp_add_dec(taba + i, taba + i, tabb, nb, 0);\n                /* propagate carry and test if positive result */\n                if (c != 0) {\n                    if (++taba[i + nb] == base) {\n                        break;\n                    }\n                }\n            }\n        }\n        tabq[i] = q;\n    }\n\n#ifdef DEBUG_DIV_SLOW\n    mp_print_str_dec(\"q\", tabq, na - nb + 1);\n    mp_print_str_dec(\"r\", taba, nb);\n#endif\n\n    /* remove the normalization */\n    if (mult != 1) {\n        mp_div1_dec(taba, taba, nb, mult, 0);\n        if (unlikely(tabb != static_tabb))\n            bf_free(s, tabb);\n    }\n    return 0;\n}\n\n/* divide by 10^shift */\nstatic limb_t mp_shr_dec(limb_t *tab_r, const limb_t *tab, mp_size_t n,\n                         limb_t shift, limb_t high)\n{\n    mp_size_t i;\n    limb_t l, a, q, r;\n\n    assert(shift >= 1 && shift < LIMB_DIGITS);\n    l = high;\n    for(i = n - 1; i >= 0; i--) {\n        a = tab[i];\n        fast_shr_rem_dec(q, r, a, shift);\n        tab_r[i] = q + l * mp_pow_dec[LIMB_DIGITS - shift];\n        l = r;\n    }\n    return l;\n}\n\n/* multiply by 10^shift */\nstatic limb_t mp_shl_dec(limb_t *tab_r, const limb_t *tab, mp_size_t n,\n                         limb_t shift, limb_t low)\n{\n    mp_size_t i;\n    limb_t l, a, q, r;\n\n    assert(shift >= 1 && shift < LIMB_DIGITS);\n    l = low;\n    for(i = 0; i < n; i++) {\n        a = tab[i];\n        fast_shr_rem_dec(q, r, a, LIMB_DIGITS - shift);\n        tab_r[i] = r * mp_pow_dec[shift] + l;\n        l = q;\n    }\n    return l;\n}\n\nstatic limb_t mp_sqrtrem2_dec(limb_t *tabs, limb_t *taba)\n{\n    int k;\n    dlimb_t a, b, r;\n    limb_t taba1[2], s, r0, r1;\n\n    /* convert to binary and normalize */\n    a = (dlimb_t)taba[1] * BF_DEC_BASE + taba[0];\n    k = clz(a >> LIMB_BITS) & ~1;\n    b = a << k;\n    taba1[0] = b;\n    taba1[1] = b >> LIMB_BITS;\n    mp_sqrtrem2(&s, taba1);\n    s >>= (k >> 1);\n    /* convert the remainder back to decimal */\n    r = a - (dlimb_t)s * (dlimb_t)s;\n    divdq_base(r1, r0, r >> LIMB_BITS, r);\n    taba[0] = r0;\n    tabs[0] = s;\n    return r1;\n}\n\n//#define DEBUG_SQRTREM_DEC\n\n/* tmp_buf must contain (n / 2 + 1 limbs) */\nstatic limb_t mp_sqrtrem_rec_dec(limb_t *tabs, limb_t *taba, limb_t n,\n                                 limb_t *tmp_buf)\n{\n    limb_t l, h, rh, ql, qh, c, i;\n\n    if (n == 1)\n        return mp_sqrtrem2_dec(tabs, taba);\n#ifdef DEBUG_SQRTREM_DEC\n    mp_print_str_dec(\"a\", taba, 2 * n);\n#endif\n    l = n / 2;\n    h = n - l;\n    qh = mp_sqrtrem_rec_dec(tabs + l, taba + 2 * l, h, tmp_buf);\n#ifdef DEBUG_SQRTREM_DEC\n    mp_print_str_dec(\"s1\", tabs + l, h);\n    mp_print_str_h_dec(\"r1\", taba + 2 * l, h, qh);\n    mp_print_str_h_dec(\"r2\", taba + l, n, qh);\n#endif\n\n    /* the remainder is in taba + 2 * l. Its high bit is in qh */\n    if (qh) {\n        mp_sub_dec(taba + 2 * l, taba + 2 * l, tabs + l, h, 0);\n    }\n    /* instead of dividing by 2*s, divide by s (which is normalized)\n       and update q and r */\n    mp_div_dec(NULL, tmp_buf, taba + l, n, tabs + l, h);\n    qh += tmp_buf[l];\n    for(i = 0; i < l; i++)\n        tabs[i] = tmp_buf[i];\n    ql = mp_div1_dec(tabs, tabs, l, 2, qh & 1);\n    qh = qh >> 1; /* 0 or 1 */\n    if (ql)\n        rh = mp_add_dec(taba + l, taba + l, tabs + l, h, 0);\n    else\n        rh = 0;\n#ifdef DEBUG_SQRTREM_DEC\n    mp_print_str_h_dec(\"q\", tabs, l, qh);\n    mp_print_str_h_dec(\"u\", taba + l, h, rh);\n#endif\n\n    mp_add_ui_dec(tabs + l, qh, h);\n#ifdef DEBUG_SQRTREM_DEC\n    mp_print_str_dec(\"s2\", tabs, n);\n#endif\n\n    /* q = qh, tabs[l - 1 ... 0], r = taba[n - 1 ... l] */\n    /* subtract q^2. if qh = 1 then q = B^l, so we can take shortcuts */\n    if (qh) {\n        c = qh;\n    } else {\n        mp_mul_basecase_dec(taba + n, tabs, l, tabs, l);\n        c = mp_sub_dec(taba, taba, taba + n, 2 * l, 0);\n    }\n    rh -= mp_sub_ui_dec(taba + 2 * l, c, n - 2 * l);\n    if ((slimb_t)rh < 0) {\n        mp_sub_ui_dec(tabs, 1, n);\n        rh += mp_add_mul1_dec(taba, tabs, n, 2);\n        rh += mp_add_ui_dec(taba, 1, n);\n    }\n    return rh;\n}\n\n/* 'taba' has 2*n limbs with n >= 1 and taba[2*n-1] >= B/4. Return (s,\n   r) with s=floor(sqrt(a)) and r=a-s^2. 0 <= r <= 2 * s. tabs has n\n   limbs. r is returned in the lower n limbs of taba. Its r[n] is the\n   returned value of the function. */\nint mp_sqrtrem_dec(bf_context_t *s, limb_t *tabs, limb_t *taba, limb_t n)\n{\n    limb_t tmp_buf1[8];\n    limb_t *tmp_buf;\n    mp_size_t n2;\n    n2 = n / 2 + 1;\n    if (n2 <= countof(tmp_buf1)) {\n        tmp_buf = tmp_buf1;\n    } else {\n        tmp_buf = bf_malloc(s, sizeof(limb_t) * n2);\n        if (!tmp_buf)\n            return -1;\n    }\n    taba[n] = mp_sqrtrem_rec_dec(tabs, taba, n, tmp_buf);\n    if (tmp_buf != tmp_buf1)\n        bf_free(s, tmp_buf);\n    return 0;\n}\n\n/* return the number of leading zero digits, from 0 to LIMB_DIGITS */\nstatic int clz_dec(limb_t a)\n{\n    if (a == 0)\n        return LIMB_DIGITS;\n    switch(LIMB_BITS - 1 - clz(a)) {\n    case 0: /* 1-1 */\n        return LIMB_DIGITS - 1;\n    case 1: /* 2-3 */\n        return LIMB_DIGITS - 1;\n    case 2: /* 4-7 */\n        return LIMB_DIGITS - 1;\n    case 3: /* 8-15 */\n        if (a < 10)\n            return LIMB_DIGITS - 1;\n        else\n            return LIMB_DIGITS - 2;\n    case 4: /* 16-31 */\n        return LIMB_DIGITS - 2;\n    case 5: /* 32-63 */\n        return LIMB_DIGITS - 2;\n    case 6: /* 64-127 */\n        if (a < 100)\n            return LIMB_DIGITS - 2;\n        else\n            return LIMB_DIGITS - 3;\n    case 7: /* 128-255 */\n        return LIMB_DIGITS - 3;\n    case 8: /* 256-511 */\n        return LIMB_DIGITS - 3;\n    case 9: /* 512-1023 */\n        if (a < 1000)\n            return LIMB_DIGITS - 3;\n        else\n            return LIMB_DIGITS - 4;\n    case 10: /* 1024-2047 */\n        return LIMB_DIGITS - 4;\n    case 11: /* 2048-4095 */\n        return LIMB_DIGITS - 4;\n    case 12: /* 4096-8191 */\n        return LIMB_DIGITS - 4;\n    case 13: /* 8192-16383 */\n        if (a < 10000)\n            return LIMB_DIGITS - 4;\n        else\n            return LIMB_DIGITS - 5;\n    case 14: /* 16384-32767 */\n        return LIMB_DIGITS - 5;\n    case 15: /* 32768-65535 */\n        return LIMB_DIGITS - 5;\n    case 16: /* 65536-131071 */\n        if (a < 100000)\n            return LIMB_DIGITS - 5;\n        else\n            return LIMB_DIGITS - 6;\n    case 17: /* 131072-262143 */\n        return LIMB_DIGITS - 6;\n    case 18: /* 262144-524287 */\n        return LIMB_DIGITS - 6;\n    case 19: /* 524288-1048575 */\n        if (a < 1000000)\n            return LIMB_DIGITS - 6;\n        else\n            return LIMB_DIGITS - 7;\n    case 20: /* 1048576-2097151 */\n        return LIMB_DIGITS - 7;\n    case 21: /* 2097152-4194303 */\n        return LIMB_DIGITS - 7;\n    case 22: /* 4194304-8388607 */\n        return LIMB_DIGITS - 7;\n    case 23: /* 8388608-16777215 */\n        if (a < 10000000)\n            return LIMB_DIGITS - 7;\n        else\n            return LIMB_DIGITS - 8;\n    case 24: /* 16777216-33554431 */\n        return LIMB_DIGITS - 8;\n    case 25: /* 33554432-67108863 */\n        return LIMB_DIGITS - 8;\n    case 26: /* 67108864-134217727 */\n        if (a < 100000000)\n            return LIMB_DIGITS - 8;\n        else\n            return LIMB_DIGITS - 9;\n#if LIMB_BITS == 64\n    case 27: /* 134217728-268435455 */\n        return LIMB_DIGITS - 9;\n    case 28: /* 268435456-536870911 */\n        return LIMB_DIGITS - 9;\n    case 29: /* 536870912-1073741823 */\n        if (a < 1000000000)\n            return LIMB_DIGITS - 9;\n        else\n            return LIMB_DIGITS - 10;\n    case 30: /* 1073741824-2147483647 */\n        return LIMB_DIGITS - 10;\n    case 31: /* 2147483648-4294967295 */\n        return LIMB_DIGITS - 10;\n    case 32: /* 4294967296-8589934591 */\n        return LIMB_DIGITS - 10;\n    case 33: /* 8589934592-17179869183 */\n        if (a < 10000000000)\n            return LIMB_DIGITS - 10;\n        else\n            return LIMB_DIGITS - 11;\n    case 34: /* 17179869184-34359738367 */\n        return LIMB_DIGITS - 11;\n    case 35: /* 34359738368-68719476735 */\n        return LIMB_DIGITS - 11;\n    case 36: /* 68719476736-137438953471 */\n        if (a < 100000000000)\n            return LIMB_DIGITS - 11;\n        else\n            return LIMB_DIGITS - 12;\n    case 37: /* 137438953472-274877906943 */\n        return LIMB_DIGITS - 12;\n    case 38: /* 274877906944-549755813887 */\n        return LIMB_DIGITS - 12;\n    case 39: /* 549755813888-1099511627775 */\n        if (a < 1000000000000)\n            return LIMB_DIGITS - 12;\n        else\n            return LIMB_DIGITS - 13;\n    case 40: /* 1099511627776-2199023255551 */\n        return LIMB_DIGITS - 13;\n    case 41: /* 2199023255552-4398046511103 */\n        return LIMB_DIGITS - 13;\n    case 42: /* 4398046511104-8796093022207 */\n        return LIMB_DIGITS - 13;\n    case 43: /* 8796093022208-17592186044415 */\n        if (a < 10000000000000)\n            return LIMB_DIGITS - 13;\n        else\n            return LIMB_DIGITS - 14;\n    case 44: /* 17592186044416-35184372088831 */\n        return LIMB_DIGITS - 14;\n    case 45: /* 35184372088832-70368744177663 */\n        return LIMB_DIGITS - 14;\n    case 46: /* 70368744177664-140737488355327 */\n        if (a < 100000000000000)\n            return LIMB_DIGITS - 14;\n        else\n            return LIMB_DIGITS - 15;\n    case 47: /* 140737488355328-281474976710655 */\n        return LIMB_DIGITS - 15;\n    case 48: /* 281474976710656-562949953421311 */\n        return LIMB_DIGITS - 15;\n    case 49: /* 562949953421312-1125899906842623 */\n        if (a < 1000000000000000)\n            return LIMB_DIGITS - 15;\n        else\n            return LIMB_DIGITS - 16;\n    case 50: /* 1125899906842624-2251799813685247 */\n        return LIMB_DIGITS - 16;\n    case 51: /* 2251799813685248-4503599627370495 */\n        return LIMB_DIGITS - 16;\n    case 52: /* 4503599627370496-9007199254740991 */\n        return LIMB_DIGITS - 16;\n    case 53: /* 9007199254740992-18014398509481983 */\n        if (a < 10000000000000000)\n            return LIMB_DIGITS - 16;\n        else\n            return LIMB_DIGITS - 17;\n    case 54: /* 18014398509481984-36028797018963967 */\n        return LIMB_DIGITS - 17;\n    case 55: /* 36028797018963968-72057594037927935 */\n        return LIMB_DIGITS - 17;\n    case 56: /* 72057594037927936-144115188075855871 */\n        if (a < 100000000000000000)\n            return LIMB_DIGITS - 17;\n        else\n            return LIMB_DIGITS - 18;\n    case 57: /* 144115188075855872-288230376151711743 */\n        return LIMB_DIGITS - 18;\n    case 58: /* 288230376151711744-576460752303423487 */\n        return LIMB_DIGITS - 18;\n    case 59: /* 576460752303423488-1152921504606846975 */\n        if (a < 1000000000000000000)\n            return LIMB_DIGITS - 18;\n        else\n            return LIMB_DIGITS - 19;\n#endif\n    default:\n        return 0;\n    }\n}\n\n/* for debugging */\nvoid bfdec_print_str(const char *str, const bfdec_t *a)\n{\n    slimb_t i;\n    printf(\"%s=\", str);\n\n    if (a->expn == BF_EXP_NAN) {\n        printf(\"NaN\");\n    } else {\n        if (a->sign)\n            putchar('-');\n        if (a->expn == BF_EXP_ZERO) {\n            putchar('0');\n        } else if (a->expn == BF_EXP_INF) {\n            printf(\"Inf\");\n        } else {\n            printf(\"0.\");\n            for(i = a->len - 1; i >= 0; i--)\n                printf(\"%0*\" PRIu_LIMB, LIMB_DIGITS, a->tab[i]);\n            printf(\"e%\" PRId_LIMB, a->expn);\n        }\n    }\n    printf(\"\\n\");\n}\n\n/* return != 0 if one digit between 0 and bit_pos inclusive is not zero. */\nstatic inline limb_t scan_digit_nz(const bfdec_t *r, slimb_t bit_pos)\n{\n    slimb_t pos;\n    limb_t v, q;\n    int shift;\n\n    if (bit_pos < 0)\n        return 0;\n    pos = (limb_t)bit_pos / LIMB_DIGITS;\n    shift = (limb_t)bit_pos % LIMB_DIGITS;\n    fast_shr_rem_dec(q, v, r->tab[pos], shift + 1);\n    (void)q;\n    if (v != 0)\n        return 1;\n    pos--;\n    while (pos >= 0) {\n        if (r->tab[pos] != 0)\n            return 1;\n        pos--;\n    }\n    return 0;\n}\n\nstatic limb_t get_digit(const limb_t *tab, limb_t len, slimb_t pos)\n{\n    slimb_t i;\n    int shift;\n    i = floor_div(pos, LIMB_DIGITS);\n    if (i < 0 || i >= len)\n        return 0;\n    shift = pos - i * LIMB_DIGITS;\n    return fast_shr_dec(tab[i], shift) % 10;\n}\n\n#if 0\nstatic limb_t get_digits(const limb_t *tab, limb_t len, slimb_t pos)\n{\n    limb_t a0, a1;\n    int shift;\n    slimb_t i;\n\n    i = floor_div(pos, LIMB_DIGITS);\n    shift = pos - i * LIMB_DIGITS;\n    if (i >= 0 && i < len)\n        a0 = tab[i];\n    else\n        a0 = 0;\n    if (shift == 0) {\n        return a0;\n    } else {\n        i++;\n        if (i >= 0 && i < len)\n            a1 = tab[i];\n        else\n            a1 = 0;\n        return fast_shr_dec(a0, shift) +\n            fast_urem(a1, &mp_pow_div[LIMB_DIGITS - shift]) *\n            mp_pow_dec[shift];\n    }\n}\n#endif\n\n/* return the addend for rounding. Note that prec can be <= 0 for bf_rint() */\nstatic int bfdec_get_rnd_add(int *pret, const bfdec_t *r, limb_t l,\n                             slimb_t prec, int rnd_mode)\n{\n    int add_one, inexact;\n    limb_t digit1, digit0;\n\n    //    bfdec_print_str(\"get_rnd_add\", r);\n    if (rnd_mode == BF_RNDF) {\n        digit0 = 1; /* faithful rounding does not honor the INEXACT flag */\n    } else {\n        /* starting limb for bit 'prec + 1' */\n        digit0 = scan_digit_nz(r, l * LIMB_DIGITS - 1 - bf_max(0, prec + 1));\n    }\n\n    /* get the digit at 'prec' */\n    digit1 = get_digit(r->tab, l, l * LIMB_DIGITS - 1 - prec);\n    inexact = (digit1 | digit0) != 0;\n\n    add_one = 0;\n    switch(rnd_mode) {\n    case BF_RNDZ:\n        break;\n    case BF_RNDN:\n        if (digit1 == 5) {\n            if (digit0) {\n                add_one = 1;\n            } else {\n                /* round to even */\n                add_one =\n                    get_digit(r->tab, l, l * LIMB_DIGITS - 1 - (prec - 1)) & 1;\n            }\n        } else if (digit1 > 5) {\n            add_one = 1;\n        }\n        break;\n    case BF_RNDD:\n    case BF_RNDU:\n        if (r->sign == (rnd_mode == BF_RNDD))\n            add_one = inexact;\n        break;\n    case BF_RNDNA:\n    case BF_RNDF:\n        add_one = (digit1 >= 5);\n        break;\n    case BF_RNDA:\n        add_one = inexact;\n        break;\n    default:\n        abort();\n    }\n\n    if (inexact)\n        *pret |= BF_ST_INEXACT;\n    return add_one;\n}\n\n/* round to prec1 bits assuming 'r' is non zero and finite. 'r' is\n   assumed to have length 'l' (1 <= l <= r->len). prec1 can be\n   BF_PREC_INF. BF_FLAG_SUBNORMAL is not supported. Cannot fail with\n   BF_ST_MEM_ERROR.\n */\nstatic int __bfdec_round(bfdec_t *r, limb_t prec1, bf_flags_t flags, limb_t l)\n{\n    int shift, add_one, rnd_mode, ret;\n    slimb_t i, bit_pos, pos, e_min, e_max, e_range, prec;\n\n    /* XXX: align to IEEE 754 2008 for decimal numbers ? */\n    e_range = (limb_t)1 << (bf_get_exp_bits(flags) - 1);\n    e_min = -e_range + 3;\n    e_max = e_range;\n\n    if (flags & BF_FLAG_RADPNT_PREC) {\n        /* 'prec' is the precision after the decimal point */\n        if (prec1 != BF_PREC_INF)\n            prec = r->expn + prec1;\n        else\n            prec = prec1;\n    } else if (unlikely(r->expn < e_min) && (flags & BF_FLAG_SUBNORMAL)) {\n        /* restrict the precision in case of potentially subnormal\n           result */\n        assert(prec1 != BF_PREC_INF);\n        prec = prec1 - (e_min - r->expn);\n    } else {\n        prec = prec1;\n    }\n\n    /* round to prec bits */\n    rnd_mode = flags & BF_RND_MASK;\n    ret = 0;\n    add_one = bfdec_get_rnd_add(&ret, r, l, prec, rnd_mode);\n\n    if (prec <= 0) {\n        if (add_one) {\n            bfdec_resize(r, 1); /* cannot fail because r is non zero */\n            r->tab[0] = BF_DEC_BASE / 10;\n            r->expn += 1 - prec;\n            ret |= BF_ST_UNDERFLOW | BF_ST_INEXACT;\n            return ret;\n        } else {\n            goto underflow;\n        }\n    } else if (add_one) {\n        limb_t carry;\n\n        /* add one starting at digit 'prec - 1' */\n        bit_pos = l * LIMB_DIGITS - 1 - (prec - 1);\n        pos = bit_pos / LIMB_DIGITS;\n        carry = mp_pow_dec[bit_pos % LIMB_DIGITS];\n        carry = mp_add_ui_dec(r->tab + pos, carry, l - pos);\n        if (carry) {\n            /* shift right by one digit */\n            mp_shr_dec(r->tab + pos, r->tab + pos, l - pos, 1, 1);\n            r->expn++;\n        }\n    }\n\n    /* check underflow */\n    if (unlikely(r->expn < e_min)) {\n        if (flags & BF_FLAG_SUBNORMAL) {\n            /* if inexact, also set the underflow flag */\n            if (ret & BF_ST_INEXACT)\n                ret |= BF_ST_UNDERFLOW;\n        } else {\n        underflow:\n            bfdec_set_zero(r, r->sign);\n            ret |= BF_ST_UNDERFLOW | BF_ST_INEXACT;\n            return ret;\n        }\n    }\n\n    /* check overflow */\n    if (unlikely(r->expn > e_max)) {\n        bfdec_set_inf(r, r->sign);\n        ret |= BF_ST_OVERFLOW | BF_ST_INEXACT;\n        return ret;\n    }\n\n    /* keep the bits starting at 'prec - 1' */\n    bit_pos = l * LIMB_DIGITS - 1 - (prec - 1);\n    i = floor_div(bit_pos, LIMB_DIGITS);\n    if (i >= 0) {\n        shift = smod(bit_pos, LIMB_DIGITS);\n        if (shift != 0) {\n            r->tab[i] = fast_shr_dec(r->tab[i], shift) *\n                mp_pow_dec[shift];\n        }\n    } else {\n        i = 0;\n    }\n    /* remove trailing zeros */\n    while (r->tab[i] == 0)\n        i++;\n    if (i > 0) {\n        l -= i;\n        memmove(r->tab, r->tab + i, l * sizeof(limb_t));\n    }\n    bfdec_resize(r, l); /* cannot fail */\n    return ret;\n}\n\n/* Cannot fail with BF_ST_MEM_ERROR. */\nint bfdec_round(bfdec_t *r, limb_t prec, bf_flags_t flags)\n{\n    if (r->len == 0)\n        return 0;\n    return __bfdec_round(r, prec, flags, r->len);\n}\n\n/* 'r' must be a finite number. Cannot fail with BF_ST_MEM_ERROR.  */\nint bfdec_normalize_and_round(bfdec_t *r, limb_t prec1, bf_flags_t flags)\n{\n    limb_t l, v;\n    int shift, ret;\n\n    //    bfdec_print_str(\"bf_renorm\", r);\n    l = r->len;\n    while (l > 0 && r->tab[l - 1] == 0)\n        l--;\n    if (l == 0) {\n        /* zero */\n        r->expn = BF_EXP_ZERO;\n        bfdec_resize(r, 0); /* cannot fail */\n        ret = 0;\n    } else {\n        r->expn -= (r->len - l) * LIMB_DIGITS;\n        /* shift to have the MSB set to '1' */\n        v = r->tab[l - 1];\n        shift = clz_dec(v);\n        if (shift != 0) {\n            mp_shl_dec(r->tab, r->tab, l, shift, 0);\n            r->expn -= shift;\n        }\n        ret = __bfdec_round(r, prec1, flags, l);\n    }\n    //    bf_print_str(\"r_final\", r);\n    return ret;\n}\n\nint bfdec_set_ui(bfdec_t *r, uint64_t v)\n{\n#if LIMB_BITS == 32\n    if (v >= BF_DEC_BASE * BF_DEC_BASE) {\n        if (bfdec_resize(r, 3))\n            goto fail;\n        r->tab[0] = v % BF_DEC_BASE;\n        v /= BF_DEC_BASE;\n        r->tab[1] = v % BF_DEC_BASE;\n        r->tab[2] = v / BF_DEC_BASE;\n        r->expn = 3 * LIMB_DIGITS;\n    } else\n#endif\n    if (v >= BF_DEC_BASE) {\n        if (bfdec_resize(r, 2))\n            goto fail;\n        r->tab[0] = v % BF_DEC_BASE;\n        r->tab[1] = v / BF_DEC_BASE;\n        r->expn = 2 * LIMB_DIGITS;\n    } else {\n        if (bfdec_resize(r, 1))\n            goto fail;\n        r->tab[0] = v;\n        r->expn = LIMB_DIGITS;\n    }\n    r->sign = 0;\n    return bfdec_normalize_and_round(r, BF_PREC_INF, 0);\n fail:\n    bfdec_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}\n\nint bfdec_set_si(bfdec_t *r, int64_t v)\n{\n    int ret;\n    if (v < 0) {\n        ret = bfdec_set_ui(r, -v);\n        r->sign = 1;\n    } else {\n        ret = bfdec_set_ui(r, v);\n    }\n    return ret;\n}\n\nstatic int bfdec_add_internal(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec, bf_flags_t flags, int b_neg)\n{\n    bf_context_t *s = r->ctx;\n    int is_sub, cmp_res, a_sign, b_sign, ret;\n\n    a_sign = a->sign;\n    b_sign = b->sign ^ b_neg;\n    is_sub = a_sign ^ b_sign;\n    cmp_res = bfdec_cmpu(a, b);\n    if (cmp_res < 0) {\n        const bfdec_t *tmp;\n        tmp = a;\n        a = b;\n        b = tmp;\n        a_sign = b_sign; /* b_sign is never used later */\n    }\n    /* abs(a) >= abs(b) */\n    if (cmp_res == 0 && is_sub && a->expn < BF_EXP_INF) {\n        /* zero result */\n        bfdec_set_zero(r, (flags & BF_RND_MASK) == BF_RNDD);\n        ret = 0;\n    } else if (a->len == 0 || b->len == 0) {\n        ret = 0;\n        if (a->expn >= BF_EXP_INF) {\n            if (a->expn == BF_EXP_NAN) {\n                /* at least one operand is NaN */\n                bfdec_set_nan(r);\n                ret = 0;\n            } else if (b->expn == BF_EXP_INF && is_sub) {\n                /* infinities with different signs */\n                bfdec_set_nan(r);\n                ret = BF_ST_INVALID_OP;\n            } else {\n                bfdec_set_inf(r, a_sign);\n            }\n        } else {\n            /* at least one zero and not subtract */\n            if (bfdec_set(r, a))\n                return BF_ST_MEM_ERROR;\n            r->sign = a_sign;\n            goto renorm;\n        }\n    } else {\n        slimb_t d, a_offset, b_offset, i, r_len;\n        limb_t carry;\n        limb_t *b1_tab;\n        int b_shift;\n        mp_size_t b1_len;\n\n        d = a->expn - b->expn;\n\n        /* XXX: not efficient in time and memory if the precision is\n           not infinite */\n        r_len = bf_max(a->len, b->len + (d + LIMB_DIGITS - 1) / LIMB_DIGITS);\n        if (bfdec_resize(r, r_len))\n            goto fail;\n        r->sign = a_sign;\n        r->expn = a->expn;\n\n        a_offset = r_len - a->len;\n        for(i = 0; i < a_offset; i++)\n            r->tab[i] = 0;\n        for(i = 0; i < a->len; i++)\n            r->tab[a_offset + i] = a->tab[i];\n\n        b_shift = d % LIMB_DIGITS;\n        if (b_shift == 0) {\n            b1_len = b->len;\n            b1_tab = (limb_t *)b->tab;\n        } else {\n            b1_len = b->len + 1;\n            b1_tab = bf_malloc(s, sizeof(limb_t) * b1_len);\n            if (!b1_tab)\n                goto fail;\n            b1_tab[0] = mp_shr_dec(b1_tab + 1, b->tab, b->len, b_shift, 0) *\n                mp_pow_dec[LIMB_DIGITS - b_shift];\n        }\n        b_offset = r_len - (b->len + (d + LIMB_DIGITS - 1) / LIMB_DIGITS);\n\n        if (is_sub) {\n            carry = mp_sub_dec(r->tab + b_offset, r->tab + b_offset,\n                               b1_tab, b1_len, 0);\n            if (carry != 0) {\n                carry = mp_sub_ui_dec(r->tab + b_offset + b1_len, carry,\n                                      r_len - (b_offset + b1_len));\n                assert(carry == 0);\n            }\n        } else {\n            carry = mp_add_dec(r->tab + b_offset, r->tab + b_offset,\n                               b1_tab, b1_len, 0);\n            if (carry != 0) {\n                carry = mp_add_ui_dec(r->tab + b_offset + b1_len, carry,\n                                      r_len - (b_offset + b1_len));\n            }\n            if (carry != 0) {\n                if (bfdec_resize(r, r_len + 1)) {\n                    if (b_shift != 0)\n                        bf_free(s, b1_tab);\n                    goto fail;\n                }\n                r->tab[r_len] = 1;\n                r->expn += LIMB_DIGITS;\n            }\n        }\n        if (b_shift != 0)\n            bf_free(s, b1_tab);\n    renorm:\n        ret = bfdec_normalize_and_round(r, prec, flags);\n    }\n    return ret;\n fail:\n    bfdec_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}\n\nstatic int __bfdec_add(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n                     bf_flags_t flags)\n{\n    return bfdec_add_internal(r, a, b, prec, flags, 0);\n}\n\nstatic int __bfdec_sub(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n                     bf_flags_t flags)\n{\n    return bfdec_add_internal(r, a, b, prec, flags, 1);\n}\n\nint bfdec_add(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n              bf_flags_t flags)\n{\n    return bf_op2((bf_t *)r, (bf_t *)a, (bf_t *)b, prec, flags,\n                  (bf_op2_func_t *)__bfdec_add);\n}\n\nint bfdec_sub(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n              bf_flags_t flags)\n{\n    return bf_op2((bf_t *)r, (bf_t *)a, (bf_t *)b, prec, flags,\n                  (bf_op2_func_t *)__bfdec_sub);\n}\n\nint bfdec_mul(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n              bf_flags_t flags)\n{\n    int ret, r_sign;\n\n    if (a->len < b->len) {\n        const bfdec_t *tmp = a;\n        a = b;\n        b = tmp;\n    }\n    r_sign = a->sign ^ b->sign;\n    /* here b->len <= a->len */\n    if (b->len == 0) {\n        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {\n            bfdec_set_nan(r);\n            ret = 0;\n        } else if (a->expn == BF_EXP_INF || b->expn == BF_EXP_INF) {\n            if ((a->expn == BF_EXP_INF && b->expn == BF_EXP_ZERO) ||\n                (a->expn == BF_EXP_ZERO && b->expn == BF_EXP_INF)) {\n                bfdec_set_nan(r);\n                ret = BF_ST_INVALID_OP;\n            } else {\n                bfdec_set_inf(r, r_sign);\n                ret = 0;\n            }\n        } else {\n            bfdec_set_zero(r, r_sign);\n            ret = 0;\n        }\n    } else {\n        bfdec_t tmp, *r1 = NULL;\n        limb_t a_len, b_len;\n        limb_t *a_tab, *b_tab;\n\n        a_len = a->len;\n        b_len = b->len;\n        a_tab = a->tab;\n        b_tab = b->tab;\n\n        if (r == a || r == b) {\n            bfdec_init(r->ctx, &tmp);\n            r1 = r;\n            r = &tmp;\n        }\n        if (bfdec_resize(r, a_len + b_len)) {\n            bfdec_set_nan(r);\n            ret = BF_ST_MEM_ERROR;\n            goto done;\n        }\n        mp_mul_basecase_dec(r->tab, a_tab, a_len, b_tab, b_len);\n        r->sign = r_sign;\n        r->expn = a->expn + b->expn;\n        ret = bfdec_normalize_and_round(r, prec, flags);\n    done:\n        if (r == &tmp)\n            bfdec_move(r1, &tmp);\n    }\n    return ret;\n}\n\nint bfdec_mul_si(bfdec_t *r, const bfdec_t *a, int64_t b1, limb_t prec,\n                 bf_flags_t flags)\n{\n    bfdec_t b;\n    int ret;\n    bfdec_init(r->ctx, &b);\n    ret = bfdec_set_si(&b, b1);\n    ret |= bfdec_mul(r, a, &b, prec, flags);\n    bfdec_delete(&b);\n    return ret;\n}\n\nint bfdec_add_si(bfdec_t *r, const bfdec_t *a, int64_t b1, limb_t prec,\n                 bf_flags_t flags)\n{\n    bfdec_t b;\n    int ret;\n\n    bfdec_init(r->ctx, &b);\n    ret = bfdec_set_si(&b, b1);\n    ret |= bfdec_add(r, a, &b, prec, flags);\n    bfdec_delete(&b);\n    return ret;\n}\n\nstatic int __bfdec_div(bfdec_t *r, const bfdec_t *a, const bfdec_t *b,\n                       limb_t prec, bf_flags_t flags)\n{\n    int ret, r_sign;\n    limb_t n, nb, precl;\n\n    r_sign = a->sign ^ b->sign;\n    if (a->expn >= BF_EXP_INF || b->expn >= BF_EXP_INF) {\n        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {\n            bfdec_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF && b->expn == BF_EXP_INF) {\n            bfdec_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else if (a->expn == BF_EXP_INF) {\n            bfdec_set_inf(r, r_sign);\n            return 0;\n        } else {\n            bfdec_set_zero(r, r_sign);\n            return 0;\n        }\n    } else if (a->expn == BF_EXP_ZERO) {\n        if (b->expn == BF_EXP_ZERO) {\n            bfdec_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else {\n            bfdec_set_zero(r, r_sign);\n            return 0;\n        }\n    } else if (b->expn == BF_EXP_ZERO) {\n        bfdec_set_inf(r, r_sign);\n        return BF_ST_DIVIDE_ZERO;\n    }\n\n    nb = b->len;\n    if (prec == BF_PREC_INF) {\n        /* infinite precision: return BF_ST_INVALID_OP if not an exact\n           result */\n        /* XXX: check */\n        precl = nb + 1;\n    } else if (flags & BF_FLAG_RADPNT_PREC) {\n        /* number of digits after the decimal point */\n        /* XXX: check (2 extra digits for rounding + 2 digits) */\n        precl = (bf_max(a->expn - b->expn, 0) + 2 +\n                 prec + 2 + LIMB_DIGITS - 1) / LIMB_DIGITS;\n    } else {\n        /* number of limbs of the quotient (2 extra digits for rounding) */\n        precl = (prec + 2 + LIMB_DIGITS - 1) / LIMB_DIGITS;\n    }\n    n = bf_max(a->len, precl);\n\n    {\n        limb_t *taba, na, i;\n        slimb_t d;\n\n        na = n + nb;\n        taba = bf_malloc(r->ctx, (na + 1) * sizeof(limb_t));\n        if (!taba)\n            goto fail;\n        d = na - a->len;\n        memset(taba, 0, d * sizeof(limb_t));\n        memcpy(taba + d, a->tab, a->len * sizeof(limb_t));\n        if (bfdec_resize(r, n + 1))\n            goto fail1;\n        if (mp_div_dec(r->ctx, r->tab, taba, na, b->tab, nb)) {\n        fail1:\n            bf_free(r->ctx, taba);\n            goto fail;\n        }\n        /* see if non zero remainder */\n        for(i = 0; i < nb; i++) {\n            if (taba[i] != 0)\n                break;\n        }\n        bf_free(r->ctx, taba);\n        if (i != nb) {\n            if (prec == BF_PREC_INF) {\n                bfdec_set_nan(r);\n                return BF_ST_INVALID_OP;\n            } else {\n                r->tab[0] |= 1;\n            }\n        }\n        r->expn = a->expn - b->expn + LIMB_DIGITS;\n        r->sign = r_sign;\n        ret = bfdec_normalize_and_round(r, prec, flags);\n    }\n    return ret;\n fail:\n    bfdec_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}\n\nint bfdec_div(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n              bf_flags_t flags)\n{\n    return bf_op2((bf_t *)r, (bf_t *)a, (bf_t *)b, prec, flags,\n                  (bf_op2_func_t *)__bfdec_div);\n}\n\n/* a and b must be finite numbers with a >= 0 and b > 0. 'q' is the\n   integer defined as floor(a/b) and r = a - q * b. */\nstatic void bfdec_tdivremu(bf_context_t *s, bfdec_t *q, bfdec_t *r,\n                           const bfdec_t *a, const bfdec_t *b)\n{\n    if (bfdec_cmpu(a, b) < 0) {\n        bfdec_set_ui(q, 0);\n        bfdec_set(r, a);\n    } else {\n        bfdec_div(q, a, b, 0, BF_RNDZ | BF_FLAG_RADPNT_PREC);\n        bfdec_mul(r, q, b, BF_PREC_INF, BF_RNDZ);\n        bfdec_sub(r, a, r, BF_PREC_INF, BF_RNDZ);\n    }\n}\n\n/* division and remainder.\n\n   rnd_mode is the rounding mode for the quotient. The additional\n   rounding mode BF_RND_EUCLIDIAN is supported.\n\n   'q' is an integer. 'r' is rounded with prec and flags (prec can be\n   BF_PREC_INF).\n*/\nint bfdec_divrem(bfdec_t *q, bfdec_t *r, const bfdec_t *a, const bfdec_t *b,\n                 limb_t prec, bf_flags_t flags, int rnd_mode)\n{\n    bf_context_t *s = q->ctx;\n    bfdec_t a1_s, *a1 = &a1_s;\n    bfdec_t b1_s, *b1 = &b1_s;\n    bfdec_t r1_s, *r1 = &r1_s;\n    int q_sign, res;\n    BOOL is_ceil, is_rndn;\n\n    assert(q != a && q != b);\n    assert(r != a && r != b);\n    assert(q != r);\n\n    if (a->len == 0 || b->len == 0) {\n        bfdec_set_zero(q, 0);\n        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {\n            bfdec_set_nan(r);\n            return 0;\n        } else if (a->expn == BF_EXP_INF || b->expn == BF_EXP_ZERO) {\n            bfdec_set_nan(r);\n            return BF_ST_INVALID_OP;\n        } else {\n            bfdec_set(r, a);\n            return bfdec_round(r, prec, flags);\n        }\n    }\n\n    q_sign = a->sign ^ b->sign;\n    is_rndn = (rnd_mode == BF_RNDN || rnd_mode == BF_RNDNA);\n    switch(rnd_mode) {\n    default:\n    case BF_RNDZ:\n    case BF_RNDN:\n    case BF_RNDNA:\n        is_ceil = FALSE;\n        break;\n    case BF_RNDD:\n        is_ceil = q_sign;\n        break;\n    case BF_RNDU:\n        is_ceil = q_sign ^ 1;\n        break;\n    case BF_RNDA:\n        is_ceil = TRUE;\n        break;\n    case BF_DIVREM_EUCLIDIAN:\n        is_ceil = a->sign;\n        break;\n    }\n\n    a1->expn = a->expn;\n    a1->tab = a->tab;\n    a1->len = a->len;\n    a1->sign = 0;\n\n    b1->expn = b->expn;\n    b1->tab = b->tab;\n    b1->len = b->len;\n    b1->sign = 0;\n\n    //    bfdec_print_str(\"a1\", a1);\n    //    bfdec_print_str(\"b1\", b1);\n    /* XXX: could improve to avoid having a large 'q' */\n    bfdec_tdivremu(s, q, r, a1, b1);\n    if (bfdec_is_nan(q) || bfdec_is_nan(r))\n        goto fail;\n    //    bfdec_print_str(\"q\", q);\n    //    bfdec_print_str(\"r\", r);\n\n    if (r->len != 0) {\n        if (is_rndn) {\n            bfdec_init(s, r1);\n            if (bfdec_set(r1, r))\n                goto fail;\n            if (bfdec_mul_si(r1, r1, 2, BF_PREC_INF, BF_RNDZ)) {\n                bfdec_delete(r1);\n                goto fail;\n            }\n            res = bfdec_cmpu(r1, b);\n            bfdec_delete(r1);\n            if (res > 0 ||\n                (res == 0 &&\n                 (rnd_mode == BF_RNDNA ||\n                  (get_digit(q->tab, q->len, q->len * LIMB_DIGITS - q->expn) & 1) != 0))) {\n                goto do_sub_r;\n            }\n        } else if (is_ceil) {\n        do_sub_r:\n            res = bfdec_add_si(q, q, 1, BF_PREC_INF, BF_RNDZ);\n            res |= bfdec_sub(r, r, b1, BF_PREC_INF, BF_RNDZ);\n            if (res & BF_ST_MEM_ERROR)\n                goto fail;\n        }\n    }\n\n    r->sign ^= a->sign;\n    q->sign = q_sign;\n    return bfdec_round(r, prec, flags);\n fail:\n    bfdec_set_nan(q);\n    bfdec_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}\n\nint bfdec_rem(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n              bf_flags_t flags, int rnd_mode)\n{\n    bfdec_t q_s, *q = &q_s;\n    int ret;\n\n    bfdec_init(r->ctx, q);\n    ret = bfdec_divrem(q, r, a, b, prec, flags, rnd_mode);\n    bfdec_delete(q);\n    return ret;\n}\n\n/* convert to integer (infinite precision) */\nint bfdec_rint(bfdec_t *r, int rnd_mode)\n{\n    return bfdec_round(r, 0, rnd_mode | BF_FLAG_RADPNT_PREC);\n}\n\nint bfdec_sqrt(bfdec_t *r, const bfdec_t *a, limb_t prec, bf_flags_t flags)\n{\n    bf_context_t *s = a->ctx;\n    int ret, k;\n    limb_t *a1, v;\n    slimb_t n, n1, prec1;\n    limb_t res;\n\n    assert(r != a);\n\n    if (a->len == 0) {\n        if (a->expn == BF_EXP_NAN) {\n            bfdec_set_nan(r);\n        } else if (a->expn == BF_EXP_INF && a->sign) {\n            goto invalid_op;\n        } else {\n            bfdec_set(r, a);\n        }\n        ret = 0;\n    } else if (a->sign || prec == BF_PREC_INF) {\n invalid_op:\n        bfdec_set_nan(r);\n        ret = BF_ST_INVALID_OP;\n    } else {\n        if (flags & BF_FLAG_RADPNT_PREC) {\n            prec1 = bf_max(floor_div(a->expn + 1, 2) + prec, 1);\n        } else {\n            prec1 = prec;\n        }\n        /* convert the mantissa to an integer with at least 2 *\n           prec + 4 digits */\n        n = (2 * (prec1 + 2) + 2 * LIMB_DIGITS - 1) / (2 * LIMB_DIGITS);\n        if (bfdec_resize(r, n))\n            goto fail;\n        a1 = bf_malloc(s, sizeof(limb_t) * 2 * n);\n        if (!a1)\n            goto fail;\n        n1 = bf_min(2 * n, a->len);\n        memset(a1, 0, (2 * n - n1) * sizeof(limb_t));\n        memcpy(a1 + 2 * n - n1, a->tab + a->len - n1, n1 * sizeof(limb_t));\n        if (a->expn & 1) {\n            res = mp_shr_dec(a1, a1, 2 * n, 1, 0);\n        } else {\n            res = 0;\n        }\n        /* normalize so that a1 >= B^(2*n)/4. Not need for n = 1\n           because mp_sqrtrem2_dec already does it */\n        k = 0;\n        if (n > 1) {\n            v = a1[2 * n - 1];\n            while (v < BF_DEC_BASE / 4) {\n                k++;\n                v *= 4;\n            }\n            if (k != 0)\n                mp_mul1_dec(a1, a1, 2 * n, 1 << (2 * k), 0);\n        }\n        if (mp_sqrtrem_dec(s, r->tab, a1, n)) {\n            bf_free(s, a1);\n            goto fail;\n        }\n        if (k != 0)\n            mp_div1_dec(r->tab, r->tab, n, 1 << k, 0);\n        if (!res) {\n            res = mp_scan_nz(a1, n + 1);\n        }\n        bf_free(s, a1);\n        if (!res) {\n            res = mp_scan_nz(a->tab, a->len - n1);\n        }\n        if (res != 0)\n            r->tab[0] |= 1;\n        r->sign = 0;\n        r->expn = (a->expn + 1) >> 1;\n        ret = bfdec_round(r, prec, flags);\n    }\n    return ret;\n fail:\n    bfdec_set_nan(r);\n    return BF_ST_MEM_ERROR;\n}\n\n/* The rounding mode is always BF_RNDZ. Return BF_ST_OVERFLOW if there\n   is an overflow and 0 otherwise. No memory error is possible. */\nint bfdec_get_int32(int *pres, const bfdec_t *a)\n{\n    uint32_t v;\n    int ret;\n    if (a->expn >= BF_EXP_INF) {\n        ret = 0;\n        if (a->expn == BF_EXP_INF) {\n            v = (uint32_t)INT32_MAX + a->sign;\n             /* XXX: return overflow ? */\n        } else {\n            v = INT32_MAX;\n        }\n    } else if (a->expn <= 0) {\n        v = 0;\n        ret = 0;\n    } else if (a->expn <= 9) {\n        v = fast_shr_dec(a->tab[a->len - 1], LIMB_DIGITS - a->expn);\n        if (a->sign)\n            v = -v;\n        ret = 0;\n    } else if (a->expn == 10) {\n        uint64_t v1;\n        uint32_t v_max;\n#if LIMB_BITS == 64\n        v1 = fast_shr_dec(a->tab[a->len - 1], LIMB_DIGITS - a->expn);\n#else\n        v1 = (uint64_t)a->tab[a->len - 1] * 10 +\n            get_digit(a->tab, a->len, (a->len - 1) * LIMB_DIGITS - 1);\n#endif\n        v_max = (uint32_t)INT32_MAX + a->sign;\n        if (v1 > v_max) {\n            v = v_max;\n            ret = BF_ST_OVERFLOW;\n        } else {\n            v = v1;\n            if (a->sign)\n                v = -v;\n            ret = 0;\n        }\n    } else {\n        v = (uint32_t)INT32_MAX + a->sign;\n        ret = BF_ST_OVERFLOW;\n    }\n    *pres = v;\n    return ret;\n}\n\n/* power to an integer with infinite precision */\nint bfdec_pow_ui(bfdec_t *r, const bfdec_t *a, limb_t b)\n{\n    int ret, n_bits, i;\n\n    assert(r != a);\n    if (b == 0)\n        return bfdec_set_ui(r, 1);\n    ret = bfdec_set(r, a);\n    n_bits = LIMB_BITS - clz(b);\n    for(i = n_bits - 2; i >= 0; i--) {\n        ret |= bfdec_mul(r, r, r, BF_PREC_INF, BF_RNDZ);\n        if ((b >> i) & 1)\n            ret |= bfdec_mul(r, r, a, BF_PREC_INF, BF_RNDZ);\n    }\n    return ret;\n}\n\nchar *bfdec_ftoa(size_t *plen, const bfdec_t *a, limb_t prec, bf_flags_t flags)\n{\n    return bf_ftoa_internal(plen, (const bf_t *)a, 10, prec, flags, TRUE);\n}\n\nint bfdec_atof(bfdec_t *r, const char *str, const char **pnext,\n               limb_t prec, bf_flags_t flags)\n{\n    slimb_t dummy_exp;\n    return bf_atof_internal((bf_t *)r, &dummy_exp, str, pnext, 10, prec,\n                            flags, TRUE);\n}\n\n#endif /* USE_BF_DEC */\n\n#ifdef USE_FFT_MUL\n/***************************************************************/\n/* Integer multiplication with FFT */\n\n/* or LIMB_BITS at bit position 'pos' in tab */\nstatic inline void put_bits(limb_t *tab, limb_t len, slimb_t pos, limb_t val)\n{\n    limb_t i;\n    int p;\n\n    i = pos >> LIMB_LOG2_BITS;\n    p = pos & (LIMB_BITS - 1);\n    if (i < len)\n        tab[i] |= val << p;\n    if (p != 0) {\n        i++;\n        if (i < len) {\n            tab[i] |= val >> (LIMB_BITS - p);\n        }\n    }\n}\n\n#if defined(__AVX2__)\n\ntypedef double NTTLimb;\n\n/* we must have: modulo >= 1 << NTT_MOD_LOG2_MIN */\n#define NTT_MOD_LOG2_MIN 50\n#define NTT_MOD_LOG2_MAX 51\n#define NB_MODS 5\n#define NTT_PROOT_2EXP 39\nstatic const int ntt_int_bits[NB_MODS] = { 254, 203, 152, 101, 50, };\n\nstatic const limb_t ntt_mods[NB_MODS] = { 0x00073a8000000001, 0x0007858000000001, 0x0007a38000000001, 0x0007a68000000001, 0x0007fd8000000001,\n};\n\nstatic const limb_t ntt_proot[2][NB_MODS] = {\n    { 0x00056198d44332c8, 0x0002eb5d640aad39, 0x00047e31eaa35fd0, 0x0005271ac118a150, 0x00075e0ce8442bd5, },\n    { 0x000461169761bcc5, 0x0002dac3cb2da688, 0x0004abc97751e3bf, 0x000656778fc8c485, 0x0000dc6469c269fa, },\n};\n\nstatic const limb_t ntt_mods_cr[NB_MODS * (NB_MODS - 1) / 2] = {\n 0x00020e4da740da8e, 0x0004c3dc09c09c1d, 0x000063bd097b4271, 0x000799d8f18f18fd,\n 0x0005384222222264, 0x000572b07c1f07fe, 0x00035cd08888889a,\n 0x00066015555557e3, 0x000725960b60b623,\n 0x0002fc1fa1d6ce12,\n};\n\n#else\n\ntypedef limb_t NTTLimb;\n\n#if LIMB_BITS == 64\n\n#define NTT_MOD_LOG2_MIN 61\n#define NTT_MOD_LOG2_MAX 62\n#define NB_MODS 5\n#define NTT_PROOT_2EXP 51\nstatic const int ntt_int_bits[NB_MODS] = { 307, 246, 185, 123, 61, };\n\nstatic const limb_t ntt_mods[NB_MODS] = { 0x28d8000000000001, 0x2a88000000000001, 0x2ed8000000000001, 0x3508000000000001, 0x3aa8000000000001,\n};\n\nstatic const limb_t ntt_proot[2][NB_MODS] = {\n    { 0x1b8ea61034a2bea7, 0x21a9762de58206fb, 0x02ca782f0756a8ea, 0x278384537a3e50a1, 0x106e13fee74ce0ab, },\n    { 0x233513af133e13b8, 0x1d13140d1c6f75f1, 0x12cde57f97e3eeda, 0x0d6149e23cbe654f, 0x36cd204f522a1379, },\n};\n\nstatic const limb_t ntt_mods_cr[NB_MODS * (NB_MODS - 1) / 2] = {\n 0x08a9ed097b425eea, 0x18a44aaaaaaaaab3, 0x2493f57f57f57f5d, 0x126b8d0649a7f8d4,\n 0x09d80ed7303b5ccc, 0x25b8bcf3cf3cf3d5, 0x2ce6ce63398ce638,\n 0x0e31fad40a57eb59, 0x02a3529fd4a7f52f,\n 0x3a5493e93e93e94a,\n};\n\n#elif LIMB_BITS == 32\n\n/* we must have: modulo >= 1 << NTT_MOD_LOG2_MIN */\n#define NTT_MOD_LOG2_MIN 29\n#define NTT_MOD_LOG2_MAX 30\n#define NB_MODS 5\n#define NTT_PROOT_2EXP 20\nstatic const int ntt_int_bits[NB_MODS] = { 148, 119, 89, 59, 29, };\n\nstatic const limb_t ntt_mods[NB_MODS] = { 0x0000000032b00001, 0x0000000033700001, 0x0000000036d00001, 0x0000000037300001, 0x000000003e500001,\n};\n\nstatic const limb_t ntt_proot[2][NB_MODS] = {\n    { 0x0000000032525f31, 0x0000000005eb3b37, 0x00000000246eda9f, 0x0000000035f25901, 0x00000000022f5768, },\n    { 0x00000000051eba1a, 0x00000000107be10e, 0x000000001cd574e0, 0x00000000053806e6, 0x000000002cd6bf98, },\n};\n\nstatic const limb_t ntt_mods_cr[NB_MODS * (NB_MODS - 1) / 2] = {\n 0x000000000449559a, 0x000000001eba6ca9, 0x000000002ec18e46, 0x000000000860160b,\n 0x000000000d321307, 0x000000000bf51120, 0x000000000f662938,\n 0x000000000932ab3e, 0x000000002f40eef8,\n 0x000000002e760905,\n};\n\n#endif /* LIMB_BITS */\n\n#endif /* !AVX2 */\n\n#if defined(__AVX2__)\n#define NTT_TRIG_K_MAX 18\n#else\n#define NTT_TRIG_K_MAX 19\n#endif\n\ntypedef struct BFNTTState {\n    bf_context_t *ctx;\n\n    /* used for mul_mod_fast() */\n    limb_t ntt_mods_div[NB_MODS];\n\n    limb_t ntt_proot_pow[NB_MODS][2][NTT_PROOT_2EXP + 1];\n    limb_t ntt_proot_pow_inv[NB_MODS][2][NTT_PROOT_2EXP + 1];\n    NTTLimb *ntt_trig[NB_MODS][2][NTT_TRIG_K_MAX + 1];\n    /* 1/2^n mod m */\n    limb_t ntt_len_inv[NB_MODS][NTT_PROOT_2EXP + 1][2];\n#if defined(__AVX2__)\n    __m256d ntt_mods_cr_vec[NB_MODS * (NB_MODS - 1) / 2];\n    __m256d ntt_mods_vec[NB_MODS];\n    __m256d ntt_mods_inv_vec[NB_MODS];\n#else\n    limb_t ntt_mods_cr_inv[NB_MODS * (NB_MODS - 1) / 2];\n#endif\n} BFNTTState;\n\nstatic NTTLimb *get_trig(BFNTTState *s, int k, int inverse, int m_idx);\n\n/* add modulo with up to (LIMB_BITS-1) bit modulo */\nstatic inline limb_t add_mod(limb_t a, limb_t b, limb_t m)\n{\n    limb_t r;\n    r = a + b;\n    if (r >= m)\n        r -= m;\n    return r;\n}\n\n/* sub modulo with up to LIMB_BITS bit modulo */\nstatic inline limb_t sub_mod(limb_t a, limb_t b, limb_t m)\n{\n    limb_t r;\n    r = a - b;\n    if (r > a)\n        r += m;\n    return r;\n}\n\n/* return (r0+r1*B) mod m\n   precondition: 0 <= r0+r1*B < 2^(64+NTT_MOD_LOG2_MIN)\n*/\nstatic inline limb_t mod_fast(dlimb_t r,\n                                limb_t m, limb_t m_inv)\n{\n    limb_t a1, q, t0, r1, r0;\n\n    a1 = r >> NTT_MOD_LOG2_MIN;\n\n    q = ((dlimb_t)a1 * m_inv) >> LIMB_BITS;\n    r = r - (dlimb_t)q * m - m * 2;\n    r1 = r >> LIMB_BITS;\n    t0 = (slimb_t)r1 >> 1;\n    r += m & t0;\n    r0 = r;\n    r1 = r >> LIMB_BITS;\n    r0 += m & r1;\n    return r0;\n}\n\n/* faster version using precomputed modulo inverse.\n   precondition: 0 <= a * b < 2^(64+NTT_MOD_LOG2_MIN) */\nstatic inline limb_t mul_mod_fast(limb_t a, limb_t b,\n                                    limb_t m, limb_t m_inv)\n{\n    dlimb_t r;\n    r = (dlimb_t)a * (dlimb_t)b;\n    return mod_fast(r, m, m_inv);\n}\n\nstatic inline limb_t init_mul_mod_fast(limb_t m)\n{\n    dlimb_t t;\n    assert(m < (limb_t)1 << NTT_MOD_LOG2_MAX);\n    assert(m >= (limb_t)1 << NTT_MOD_LOG2_MIN);\n    t = (dlimb_t)1 << (LIMB_BITS + NTT_MOD_LOG2_MIN);\n    return t / m;\n}\n\n/* Faster version used when the multiplier is constant. 0 <= a < 2^64,\n   0 <= b < m. */\nstatic inline limb_t mul_mod_fast2(limb_t a, limb_t b,\n                                     limb_t m, limb_t b_inv)\n{\n    limb_t r, q;\n\n    q = ((dlimb_t)a * (dlimb_t)b_inv) >> LIMB_BITS;\n    r = a * b - q * m;\n    if (r >= m)\n        r -= m;\n    return r;\n}\n\n/* Faster version used when the multiplier is constant. 0 <= a < 2^64,\n   0 <= b < m. Let r = a * b mod m. The return value is 'r' or 'r +\n   m'. */\nstatic inline limb_t mul_mod_fast3(limb_t a, limb_t b,\n                                     limb_t m, limb_t b_inv)\n{\n    limb_t r, q;\n\n    q = ((dlimb_t)a * (dlimb_t)b_inv) >> LIMB_BITS;\n    r = a * b - q * m;\n    return r;\n}\n\nstatic inline limb_t init_mul_mod_fast2(limb_t b, limb_t m)\n{\n    return ((dlimb_t)b << LIMB_BITS) / m;\n}\n\n#ifdef __AVX2__\n\nstatic inline limb_t ntt_limb_to_int(NTTLimb a, limb_t m)\n{\n    slimb_t v;\n    v = a;\n    if (v < 0)\n        v += m;\n    if (v >= m)\n        v -= m;\n    return v;\n}\n\nstatic inline NTTLimb int_to_ntt_limb(limb_t a, limb_t m)\n{\n    return (slimb_t)a;\n}\n\nstatic inline NTTLimb int_to_ntt_limb2(limb_t a, limb_t m)\n{\n    if (a >= (m / 2))\n        a -= m;\n    return (slimb_t)a;\n}\n\n/* return r + m if r < 0 otherwise r. */\nstatic inline __m256d ntt_mod1(__m256d r, __m256d m)\n{\n    return _mm256_blendv_pd(r, r + m, r);\n}\n\n/* input: abs(r) < 2 * m. Output: abs(r) < m */\nstatic inline __m256d ntt_mod(__m256d r, __m256d mf, __m256d m2f)\n{\n    return _mm256_blendv_pd(r, r + m2f, r) - mf;\n}\n\n/* input: abs(a*b) < 2 * m^2, output: abs(r) < m */\nstatic inline __m256d ntt_mul_mod(__m256d a, __m256d b, __m256d mf,\n                                  __m256d m_inv)\n{\n    __m256d r, q, ab1, ab0, qm0, qm1;\n    ab1 = a * b;\n    q = _mm256_round_pd(ab1 * m_inv, 0); /* round to nearest */\n    qm1 = q * mf;\n    qm0 = _mm256_fmsub_pd(q, mf, qm1); /* low part */\n    ab0 = _mm256_fmsub_pd(a, b, ab1); /* low part */\n    r = (ab1 - qm1) + (ab0 - qm0);\n    return r;\n}\n\nstatic void *bf_aligned_malloc(bf_context_t *s, size_t size, size_t align)\n{\n    void *ptr;\n    void **ptr1;\n    ptr = bf_malloc(s, size + sizeof(void *) + align - 1);\n    if (!ptr)\n        return NULL;\n    ptr1 = (void **)(((uintptr_t)ptr + sizeof(void *) + align - 1) &\n                     ~(align - 1));\n    ptr1[-1] = ptr;\n    return ptr1;\n}\n\nstatic void bf_aligned_free(bf_context_t *s, void *ptr)\n{\n    if (!ptr)\n        return;\n    bf_free(s, ((void **)ptr)[-1]);\n}\n\nstatic void *ntt_malloc(BFNTTState *s, size_t size)\n{\n    return bf_aligned_malloc(s->ctx, size, 64);\n}\n\nstatic void ntt_free(BFNTTState *s, void *ptr)\n{\n    bf_aligned_free(s->ctx, ptr);\n}\n\nstatic no_inline int ntt_fft(BFNTTState *s,\n                             NTTLimb *out_buf, NTTLimb *in_buf,\n                             NTTLimb *tmp_buf, int fft_len_log2,\n                             int inverse, int m_idx)\n{\n    limb_t nb_blocks, fft_per_block, p, k, n, stride_in, i, j;\n    NTTLimb *tab_in, *tab_out, *tmp, *trig;\n    __m256d m_inv, mf, m2f, c, a0, a1, b0, b1;\n    limb_t m;\n    int l;\n\n    m = ntt_mods[m_idx];\n\n    m_inv = _mm256_set1_pd(1.0 / (double)m);\n    mf = _mm256_set1_pd(m);\n    m2f = _mm256_set1_pd(m * 2);\n\n    n = (limb_t)1 << fft_len_log2;\n    assert(n >= 8);\n    stride_in = n / 2;\n\n    tab_in = in_buf;\n    tab_out = tmp_buf;\n    trig = get_trig(s, fft_len_log2, inverse, m_idx);\n    if (!trig)\n        return -1;\n    p = 0;\n    for(k = 0; k < stride_in; k += 4) {\n        a0 = _mm256_load_pd(&tab_in[k]);\n        a1 = _mm256_load_pd(&tab_in[k + stride_in]);\n        c = _mm256_load_pd(trig);\n        trig += 4;\n        b0 = ntt_mod(a0 + a1, mf, m2f);\n        b1 = ntt_mul_mod(a0 - a1, c, mf, m_inv);\n        a0 = _mm256_permute2f128_pd(b0, b1, 0x20);\n        a1 = _mm256_permute2f128_pd(b0, b1, 0x31);\n        a0 = _mm256_permute4x64_pd(a0, 0xd8);\n        a1 = _mm256_permute4x64_pd(a1, 0xd8);\n        _mm256_store_pd(&tab_out[p], a0);\n        _mm256_store_pd(&tab_out[p + 4], a1);\n        p += 2 * 4;\n    }\n    tmp = tab_in;\n    tab_in = tab_out;\n    tab_out = tmp;\n\n    trig = get_trig(s, fft_len_log2 - 1, inverse, m_idx);\n    if (!trig)\n        return -1;\n    p = 0;\n    for(k = 0; k < stride_in; k += 4) {\n        a0 = _mm256_load_pd(&tab_in[k]);\n        a1 = _mm256_load_pd(&tab_in[k + stride_in]);\n        c = _mm256_setr_pd(trig[0], trig[0], trig[1], trig[1]);\n        trig += 2;\n        b0 = ntt_mod(a0 + a1, mf, m2f);\n        b1 = ntt_mul_mod(a0 - a1, c, mf, m_inv);\n        a0 = _mm256_permute2f128_pd(b0, b1, 0x20);\n        a1 = _mm256_permute2f128_pd(b0, b1, 0x31);\n        _mm256_store_pd(&tab_out[p], a0);\n        _mm256_store_pd(&tab_out[p + 4], a1);\n        p += 2 * 4;\n    }\n    tmp = tab_in;\n    tab_in = tab_out;\n    tab_out = tmp;\n\n    nb_blocks = n / 4;\n    fft_per_block = 4;\n\n    l = fft_len_log2 - 2;\n    while (nb_blocks != 2) {\n        nb_blocks >>= 1;\n        p = 0;\n        k = 0;\n        trig = get_trig(s, l, inverse, m_idx);\n        if (!trig)\n            return -1;\n        for(i = 0; i < nb_blocks; i++) {\n            c = _mm256_set1_pd(trig[0]);\n            trig++;\n            for(j = 0; j < fft_per_block; j += 4) {\n                a0 = _mm256_load_pd(&tab_in[k + j]);\n                a1 = _mm256_load_pd(&tab_in[k + j + stride_in]);\n                b0 = ntt_mod(a0 + a1, mf, m2f);\n                b1 = ntt_mul_mod(a0 - a1, c, mf, m_inv);\n                _mm256_store_pd(&tab_out[p + j], b0);\n                _mm256_store_pd(&tab_out[p + j + fft_per_block], b1);\n            }\n            k += fft_per_block;\n            p += 2 * fft_per_block;\n        }\n        fft_per_block <<= 1;\n        l--;\n        tmp = tab_in;\n        tab_in = tab_out;\n        tab_out = tmp;\n    }\n\n    tab_out = out_buf;\n    for(k = 0; k < stride_in; k += 4) {\n        a0 = _mm256_load_pd(&tab_in[k]);\n        a1 = _mm256_load_pd(&tab_in[k + stride_in]);\n        b0 = ntt_mod(a0 + a1, mf, m2f);\n        b1 = ntt_mod(a0 - a1, mf, m2f);\n        _mm256_store_pd(&tab_out[k], b0);\n        _mm256_store_pd(&tab_out[k + stride_in], b1);\n    }\n    return 0;\n}\n\nstatic void ntt_vec_mul(BFNTTState *s,\n                        NTTLimb *tab1, NTTLimb *tab2, limb_t fft_len_log2,\n                        int k_tot, int m_idx)\n{\n    limb_t i, c_inv, n, m;\n    __m256d m_inv, mf, a, b, c;\n\n    m = ntt_mods[m_idx];\n    c_inv = s->ntt_len_inv[m_idx][k_tot][0];\n    m_inv = _mm256_set1_pd(1.0 / (double)m);\n    mf = _mm256_set1_pd(m);\n    c = _mm256_set1_pd(int_to_ntt_limb(c_inv, m));\n    n = (limb_t)1 << fft_len_log2;\n    for(i = 0; i < n; i += 4) {\n        a = _mm256_load_pd(&tab1[i]);\n        b = _mm256_load_pd(&tab2[i]);\n        a = ntt_mul_mod(a, b, mf, m_inv);\n        a = ntt_mul_mod(a, c, mf, m_inv);\n        _mm256_store_pd(&tab1[i], a);\n    }\n}\n\nstatic no_inline void mul_trig(NTTLimb *buf,\n                               limb_t n, limb_t c1, limb_t m, limb_t m_inv1)\n{\n    limb_t i, c2, c3, c4;\n    __m256d c, c_mul, a0, mf, m_inv;\n    assert(n >= 2);\n\n    mf = _mm256_set1_pd(m);\n    m_inv = _mm256_set1_pd(1.0 / (double)m);\n\n    c2 = mul_mod_fast(c1, c1, m, m_inv1);\n    c3 = mul_mod_fast(c2, c1, m, m_inv1);\n    c4 = mul_mod_fast(c2, c2, m, m_inv1);\n    c = _mm256_setr_pd(1, int_to_ntt_limb(c1, m),\n                       int_to_ntt_limb(c2, m), int_to_ntt_limb(c3, m));\n    c_mul = _mm256_set1_pd(int_to_ntt_limb(c4, m));\n    for(i = 0; i < n; i += 4) {\n        a0 = _mm256_load_pd(&buf[i]);\n        a0 = ntt_mul_mod(a0, c, mf, m_inv);\n        _mm256_store_pd(&buf[i], a0);\n        c = ntt_mul_mod(c, c_mul, mf, m_inv);\n    }\n}\n\n#else\n\nstatic void *ntt_malloc(BFNTTState *s, size_t size)\n{\n    return bf_malloc(s->ctx, size);\n}\n\nstatic void ntt_free(BFNTTState *s, void *ptr)\n{\n    bf_free(s->ctx, ptr);\n}\n\nstatic inline limb_t ntt_limb_to_int(NTTLimb a, limb_t m)\n{\n    if (a >= m)\n        a -= m;\n    return a;\n}\n\nstatic inline NTTLimb int_to_ntt_limb(slimb_t a, limb_t m)\n{\n    return a;\n}\n\nstatic no_inline int ntt_fft(BFNTTState *s, NTTLimb *out_buf, NTTLimb *in_buf,\n                             NTTLimb *tmp_buf, int fft_len_log2,\n                             int inverse, int m_idx)\n{\n    limb_t nb_blocks, fft_per_block, p, k, n, stride_in, i, j, m, m2;\n    NTTLimb *tab_in, *tab_out, *tmp, a0, a1, b0, b1, c, *trig, c_inv;\n    int l;\n\n    m = ntt_mods[m_idx];\n    m2 = 2 * m;\n    n = (limb_t)1 << fft_len_log2;\n    nb_blocks = n;\n    fft_per_block = 1;\n    stride_in = n / 2;\n    tab_in = in_buf;\n    tab_out = tmp_buf;\n    l = fft_len_log2;\n    while (nb_blocks != 2) {\n        nb_blocks >>= 1;\n        p = 0;\n        k = 0;\n        trig = get_trig(s, l, inverse, m_idx);\n        if (!trig)\n            return -1;\n        for(i = 0; i < nb_blocks; i++) {\n            c = trig[0];\n            c_inv = trig[1];\n            trig += 2;\n            for(j = 0; j < fft_per_block; j++) {\n                a0 = tab_in[k + j];\n                a1 = tab_in[k + j + stride_in];\n                b0 = add_mod(a0, a1, m2);\n                b1 = a0 - a1 + m2;\n                b1 = mul_mod_fast3(b1, c, m, c_inv);\n                tab_out[p + j] = b0;\n                tab_out[p + j + fft_per_block] = b1;\n            }\n            k += fft_per_block;\n            p += 2 * fft_per_block;\n        }\n        fft_per_block <<= 1;\n        l--;\n        tmp = tab_in;\n        tab_in = tab_out;\n        tab_out = tmp;\n    }\n    /* no twiddle in last step */\n    tab_out = out_buf;\n    for(k = 0; k < stride_in; k++) {\n        a0 = tab_in[k];\n        a1 = tab_in[k + stride_in];\n        b0 = add_mod(a0, a1, m2);\n        b1 = sub_mod(a0, a1, m2);\n        tab_out[k] = b0;\n        tab_out[k + stride_in] = b1;\n    }\n    return 0;\n}\n\nstatic void ntt_vec_mul(BFNTTState *s,\n                        NTTLimb *tab1, NTTLimb *tab2, int fft_len_log2,\n                        int k_tot, int m_idx)\n{\n    limb_t i, norm, norm_inv, a, n, m, m_inv;\n\n    m = ntt_mods[m_idx];\n    m_inv = s->ntt_mods_div[m_idx];\n    norm = s->ntt_len_inv[m_idx][k_tot][0];\n    norm_inv = s->ntt_len_inv[m_idx][k_tot][1];\n    n = (limb_t)1 << fft_len_log2;\n    for(i = 0; i < n; i++) {\n        a = tab1[i];\n        /* need to reduce the range so that the product is <\n           2^(LIMB_BITS+NTT_MOD_LOG2_MIN) */\n        if (a >= m)\n            a -= m;\n        a = mul_mod_fast(a, tab2[i], m, m_inv);\n        a = mul_mod_fast3(a, norm, m, norm_inv);\n        tab1[i] = a;\n    }\n}\n\nstatic no_inline void mul_trig(NTTLimb *buf,\n                               limb_t n, limb_t c_mul, limb_t m, limb_t m_inv)\n{\n    limb_t i, c0, c_mul_inv;\n\n    c0 = 1;\n    c_mul_inv = init_mul_mod_fast2(c_mul, m);\n    for(i = 0; i < n; i++) {\n        buf[i] = mul_mod_fast(buf[i], c0, m, m_inv);\n        c0 = mul_mod_fast2(c0, c_mul, m, c_mul_inv);\n    }\n}\n\n#endif /* !AVX2 */\n\nstatic no_inline NTTLimb *get_trig(BFNTTState *s,\n                                   int k, int inverse, int m_idx)\n{\n    NTTLimb *tab;\n    limb_t i, n2, c, c_mul, m, c_mul_inv;\n\n    if (k > NTT_TRIG_K_MAX)\n        return NULL;\n\n    tab = s->ntt_trig[m_idx][inverse][k];\n    if (tab)\n        return tab;\n    n2 = (limb_t)1 << (k - 1);\n    m = ntt_mods[m_idx];\n#ifdef __AVX2__\n    tab = ntt_malloc(s, sizeof(NTTLimb) * n2);\n#else\n    tab = ntt_malloc(s, sizeof(NTTLimb) * n2 * 2);\n#endif\n    if (!tab)\n        return NULL;\n    c = 1;\n    c_mul = s->ntt_proot_pow[m_idx][inverse][k];\n    c_mul_inv = s->ntt_proot_pow_inv[m_idx][inverse][k];\n    for(i = 0; i < n2; i++) {\n#ifdef __AVX2__\n        tab[i] = int_to_ntt_limb2(c, m);\n#else\n        tab[2 * i] = int_to_ntt_limb(c, m);\n        tab[2 * i + 1] = init_mul_mod_fast2(c, m);\n#endif\n        c = mul_mod_fast2(c, c_mul, m, c_mul_inv);\n    }\n    s->ntt_trig[m_idx][inverse][k] = tab;\n    return tab;\n}\n\nvoid fft_clear_cache(bf_context_t *s1)\n{\n    int m_idx, inverse, k;\n    BFNTTState *s = s1->ntt_state;\n    if (s) {\n        for(m_idx = 0; m_idx < NB_MODS; m_idx++) {\n            for(inverse = 0; inverse < 2; inverse++) {\n                for(k = 0; k < NTT_TRIG_K_MAX + 1; k++) {\n                    if (s->ntt_trig[m_idx][inverse][k]) {\n                        ntt_free(s, s->ntt_trig[m_idx][inverse][k]);\n                        s->ntt_trig[m_idx][inverse][k] = NULL;\n                    }\n                }\n            }\n        }\n#if defined(__AVX2__)\n        bf_aligned_free(s1, s);\n#else\n        bf_free(s1, s);\n#endif\n        s1->ntt_state = NULL;\n    }\n}\n\n#define STRIP_LEN 16\n\n/* dst = buf1, src = buf2 */\nstatic int ntt_fft_partial(BFNTTState *s, NTTLimb *buf1,\n                           int k1, int k2, limb_t n1, limb_t n2, int inverse,\n                           limb_t m_idx)\n{\n    limb_t i, j, c_mul, c0, m, m_inv, strip_len, l;\n    NTTLimb *buf2, *buf3;\n\n    buf2 = NULL;\n    buf3 = ntt_malloc(s, sizeof(NTTLimb) * n1);\n    if (!buf3)\n        goto fail;\n    if (k2 == 0) {\n        if (ntt_fft(s, buf1, buf1, buf3, k1, inverse, m_idx))\n            goto fail;\n    } else {\n        strip_len = STRIP_LEN;\n        buf2 = ntt_malloc(s, sizeof(NTTLimb) * n1 * strip_len);\n        if (!buf2)\n            goto fail;\n        m = ntt_mods[m_idx];\n        m_inv = s->ntt_mods_div[m_idx];\n        c0 = s->ntt_proot_pow[m_idx][inverse][k1 + k2];\n        c_mul = 1;\n        assert((n2 % strip_len) == 0);\n        for(j = 0; j < n2; j += strip_len) {\n            for(i = 0; i < n1; i++) {\n                for(l = 0; l < strip_len; l++) {\n                    buf2[i + l * n1] = buf1[i * n2 + (j + l)];\n                }\n            }\n            for(l = 0; l < strip_len; l++) {\n                if (inverse)\n                    mul_trig(buf2 + l * n1, n1, c_mul, m, m_inv);\n                if (ntt_fft(s, buf2 + l * n1, buf2 + l * n1, buf3, k1, inverse, m_idx))\n                    goto fail;\n                if (!inverse)\n                    mul_trig(buf2 + l * n1, n1, c_mul, m, m_inv);\n                c_mul = mul_mod_fast(c_mul, c0, m, m_inv);\n            }\n\n            for(i = 0; i < n1; i++) {\n                for(l = 0; l < strip_len; l++) {\n                    buf1[i * n2 + (j + l)] = buf2[i + l *n1];\n                }\n            }\n        }\n        ntt_free(s, buf2);\n    }\n    ntt_free(s, buf3);\n    return 0;\n fail:\n    ntt_free(s, buf2);\n    ntt_free(s, buf3);\n    return -1;\n}\n\n\n/* dst = buf1, src = buf2, tmp = buf3 */\nstatic int ntt_conv(BFNTTState *s, NTTLimb *buf1, NTTLimb *buf2,\n                    int k, int k_tot, limb_t m_idx)\n{\n    limb_t n1, n2, i;\n    int k1, k2;\n\n    if (k <= NTT_TRIG_K_MAX) {\n        k1 = k;\n    } else {\n        /* recursive split of the FFT */\n        k1 = bf_min(k / 2, NTT_TRIG_K_MAX);\n    }\n    k2 = k - k1;\n    n1 = (limb_t)1 << k1;\n    n2 = (limb_t)1 << k2;\n\n    if (ntt_fft_partial(s, buf1, k1, k2, n1, n2, 0, m_idx))\n        return -1;\n    if (ntt_fft_partial(s, buf2, k1, k2, n1, n2, 0, m_idx))\n        return -1;\n    if (k2 == 0) {\n        ntt_vec_mul(s, buf1, buf2, k, k_tot, m_idx);\n    } else {\n        for(i = 0; i < n1; i++) {\n            ntt_conv(s, buf1 + i * n2, buf2 + i * n2, k2, k_tot, m_idx);\n        }\n    }\n    if (ntt_fft_partial(s, buf1, k1, k2, n1, n2, 1, m_idx))\n        return -1;\n    return 0;\n}\n\n\nstatic no_inline void limb_to_ntt(BFNTTState *s,\n                                  NTTLimb *tabr, limb_t fft_len,\n                                  const limb_t *taba, limb_t a_len, int dpl,\n                                  int first_m_idx, int nb_mods)\n{\n    slimb_t i, n;\n    dlimb_t a, b;\n    int j, shift;\n    limb_t base_mask1, a0, a1, a2, r, m, m_inv;\n\n#if 0\n    for(i = 0; i < a_len; i++) {\n        printf(\"%\" PRId64 \": \" FMT_LIMB \"\\n\",\n               (int64_t)i, taba[i]);\n    }\n#endif\n    memset(tabr, 0, sizeof(NTTLimb) * fft_len * nb_mods);\n    shift = dpl & (LIMB_BITS - 1);\n    if (shift == 0)\n        base_mask1 = -1;\n    else\n        base_mask1 = ((limb_t)1 << shift) - 1;\n    n = bf_min(fft_len, (a_len * LIMB_BITS + dpl - 1) / dpl);\n    for(i = 0; i < n; i++) {\n        a0 = get_bits(taba, a_len, i * dpl);\n        if (dpl <= LIMB_BITS) {\n            a0 &= base_mask1;\n            a = a0;\n        } else {\n            a1 = get_bits(taba, a_len, i * dpl + LIMB_BITS);\n            if (dpl <= (LIMB_BITS + NTT_MOD_LOG2_MIN)) {\n                a = a0 | ((dlimb_t)(a1 & base_mask1) << LIMB_BITS);\n            } else {\n                if (dpl > 2 * LIMB_BITS) {\n                    a2 = get_bits(taba, a_len, i * dpl + LIMB_BITS * 2) &\n                        base_mask1;\n                } else {\n                    a1 &= base_mask1;\n                    a2 = 0;\n                }\n                //            printf(\"a=0x%016lx%016lx%016lx\\n\", a2, a1, a0);\n                a = (a0 >> (LIMB_BITS - NTT_MOD_LOG2_MAX + NTT_MOD_LOG2_MIN)) |\n                    ((dlimb_t)a1 << (NTT_MOD_LOG2_MAX - NTT_MOD_LOG2_MIN)) |\n                    ((dlimb_t)a2 << (LIMB_BITS + NTT_MOD_LOG2_MAX - NTT_MOD_LOG2_MIN));\n                a0 &= ((limb_t)1 << (LIMB_BITS - NTT_MOD_LOG2_MAX + NTT_MOD_LOG2_MIN)) - 1;\n            }\n        }\n        for(j = 0; j < nb_mods; j++) {\n            m = ntt_mods[first_m_idx + j];\n            m_inv = s->ntt_mods_div[first_m_idx + j];\n            r = mod_fast(a, m, m_inv);\n            if (dpl > (LIMB_BITS + NTT_MOD_LOG2_MIN)) {\n                b = ((dlimb_t)r << (LIMB_BITS - NTT_MOD_LOG2_MAX + NTT_MOD_LOG2_MIN)) | a0;\n                r = mod_fast(b, m, m_inv);\n            }\n            tabr[i + j * fft_len] = int_to_ntt_limb(r, m);\n        }\n    }\n}\n\n#if defined(__AVX2__)\n\n#define VEC_LEN 4\n\ntypedef union {\n    __m256d v;\n    double d[4];\n} VecUnion;\n\nstatic no_inline void ntt_to_limb(BFNTTState *s, limb_t *tabr, limb_t r_len,\n                                  const NTTLimb *buf, int fft_len_log2, int dpl,\n                                  int nb_mods)\n{\n    const limb_t *mods = ntt_mods + NB_MODS - nb_mods;\n    const __m256d *mods_cr_vec, *mf, *m_inv;\n    VecUnion y[NB_MODS];\n    limb_t u[NB_MODS], carry[NB_MODS], fft_len, base_mask1, r;\n    slimb_t i, len, pos;\n    int j, k, l, shift, n_limb1, p;\n    dlimb_t t;\n\n    j = NB_MODS * (NB_MODS - 1) / 2 - nb_mods * (nb_mods - 1) / 2;\n    mods_cr_vec = s->ntt_mods_cr_vec + j;\n    mf = s->ntt_mods_vec + NB_MODS - nb_mods;\n    m_inv = s->ntt_mods_inv_vec + NB_MODS - nb_mods;\n\n    shift = dpl & (LIMB_BITS - 1);\n    if (shift == 0)\n        base_mask1 = -1;\n    else\n        base_mask1 = ((limb_t)1 << shift) - 1;\n    n_limb1 = ((unsigned)dpl - 1) / LIMB_BITS;\n    for(j = 0; j < NB_MODS; j++)\n        carry[j] = 0;\n    for(j = 0; j < NB_MODS; j++)\n        u[j] = 0; /* avoid warnings */\n    memset(tabr, 0, sizeof(limb_t) * r_len);\n    fft_len = (limb_t)1 << fft_len_log2;\n    len = bf_min(fft_len, (r_len * LIMB_BITS + dpl - 1) / dpl);\n    len = (len + VEC_LEN - 1) & ~(VEC_LEN - 1);\n    i = 0;\n    while (i < len) {\n        for(j = 0; j < nb_mods; j++)\n            y[j].v = *(__m256d *)&buf[i + fft_len * j];\n\n        /* Chinese remainder to get mixed radix representation */\n        l = 0;\n        for(j = 0; j < nb_mods - 1; j++) {\n            y[j].v = ntt_mod1(y[j].v, mf[j]);\n            for(k = j + 1; k < nb_mods; k++) {\n                y[k].v = ntt_mul_mod(y[k].v - y[j].v,\n                                     mods_cr_vec[l], mf[k], m_inv[k]);\n                l++;\n            }\n        }\n        y[j].v = ntt_mod1(y[j].v, mf[j]);\n\n        for(p = 0; p < VEC_LEN; p++) {\n            /* back to normal representation */\n            u[0] = (int64_t)y[nb_mods - 1].d[p];\n            l = 1;\n            for(j = nb_mods - 2; j >= 1; j--) {\n                r = (int64_t)y[j].d[p];\n                for(k = 0; k < l; k++) {\n                    t = (dlimb_t)u[k] * mods[j] + r;\n                    r = t >> LIMB_BITS;\n                    u[k] = t;\n                }\n                u[l] = r;\n                l++;\n            }\n            /* XXX: for nb_mods = 5, l should be 4 */\n\n            /* last step adds the carry */\n            r = (int64_t)y[0].d[p];\n            for(k = 0; k < l; k++) {\n                t = (dlimb_t)u[k] * mods[j] + r + carry[k];\n                r = t >> LIMB_BITS;\n                u[k] = t;\n            }\n            u[l] = r + carry[l];\n\n#if 0\n            printf(\"%\" PRId64 \": \", i);\n            for(j = nb_mods - 1; j >= 0; j--) {\n                printf(\" %019\" PRIu64, u[j]);\n            }\n            printf(\"\\n\");\n#endif\n\n            /* write the digits */\n            pos = i * dpl;\n            for(j = 0; j < n_limb1; j++) {\n                put_bits(tabr, r_len, pos, u[j]);\n                pos += LIMB_BITS;\n            }\n            put_bits(tabr, r_len, pos, u[n_limb1] & base_mask1);\n            /* shift by dpl digits and set the carry */\n            if (shift == 0) {\n                for(j = n_limb1 + 1; j < nb_mods; j++)\n                    carry[j - (n_limb1 + 1)] = u[j];\n            } else {\n                for(j = n_limb1; j < nb_mods - 1; j++) {\n                    carry[j - n_limb1] = (u[j] >> shift) |\n                        (u[j + 1] << (LIMB_BITS - shift));\n                }\n                carry[nb_mods - 1 - n_limb1] = u[nb_mods - 1] >> shift;\n            }\n            i++;\n        }\n    }\n}\n#else\nstatic no_inline void ntt_to_limb(BFNTTState *s, limb_t *tabr, limb_t r_len,\n                                  const NTTLimb *buf, int fft_len_log2, int dpl,\n                                  int nb_mods)\n{\n    const limb_t *mods = ntt_mods + NB_MODS - nb_mods;\n    const limb_t *mods_cr, *mods_cr_inv;\n    limb_t y[NB_MODS], u[NB_MODS], carry[NB_MODS], fft_len, base_mask1, r;\n    slimb_t i, len, pos;\n    int j, k, l, shift, n_limb1;\n    dlimb_t t;\n\n    j = NB_MODS * (NB_MODS - 1) / 2 - nb_mods * (nb_mods - 1) / 2;\n    mods_cr = ntt_mods_cr + j;\n    mods_cr_inv = s->ntt_mods_cr_inv + j;\n\n    shift = dpl & (LIMB_BITS - 1);\n    if (shift == 0)\n        base_mask1 = -1;\n    else\n        base_mask1 = ((limb_t)1 << shift) - 1;\n    n_limb1 = ((unsigned)dpl - 1) / LIMB_BITS;\n    for(j = 0; j < NB_MODS; j++)\n        carry[j] = 0;\n    for(j = 0; j < NB_MODS; j++)\n        u[j] = 0; /* avoid warnings */\n    memset(tabr, 0, sizeof(limb_t) * r_len);\n    fft_len = (limb_t)1 << fft_len_log2;\n    len = bf_min(fft_len, (r_len * LIMB_BITS + dpl - 1) / dpl);\n    for(i = 0; i < len; i++) {\n        for(j = 0; j < nb_mods; j++)  {\n            y[j] = ntt_limb_to_int(buf[i + fft_len * j], mods[j]);\n        }\n\n        /* Chinese remainder to get mixed radix representation */\n        l = 0;\n        for(j = 0; j < nb_mods - 1; j++) {\n            for(k = j + 1; k < nb_mods; k++) {\n                limb_t m;\n                m = mods[k];\n                /* Note: there is no overflow in the sub_mod() because\n                   the modulos are sorted by increasing order */\n                y[k] = mul_mod_fast2(y[k] - y[j] + m,\n                                     mods_cr[l], m, mods_cr_inv[l]);\n                l++;\n            }\n        }\n\n        /* back to normal representation */\n        u[0] = y[nb_mods - 1];\n        l = 1;\n        for(j = nb_mods - 2; j >= 1; j--) {\n            r = y[j];\n            for(k = 0; k < l; k++) {\n                t = (dlimb_t)u[k] * mods[j] + r;\n                r = t >> LIMB_BITS;\n                u[k] = t;\n            }\n            u[l] = r;\n            l++;\n        }\n\n        /* last step adds the carry */\n        r = y[0];\n        for(k = 0; k < l; k++) {\n            t = (dlimb_t)u[k] * mods[j] + r + carry[k];\n            r = t >> LIMB_BITS;\n            u[k] = t;\n        }\n        u[l] = r + carry[l];\n\n#if 0\n        printf(\"%\" PRId64 \": \", (int64_t)i);\n        for(j = nb_mods - 1; j >= 0; j--) {\n            printf(\" \" FMT_LIMB, u[j]);\n        }\n        printf(\"\\n\");\n#endif\n\n        /* write the digits */\n        pos = i * dpl;\n        for(j = 0; j < n_limb1; j++) {\n            put_bits(tabr, r_len, pos, u[j]);\n            pos += LIMB_BITS;\n        }\n        put_bits(tabr, r_len, pos, u[n_limb1] & base_mask1);\n        /* shift by dpl digits and set the carry */\n        if (shift == 0) {\n            for(j = n_limb1 + 1; j < nb_mods; j++)\n                carry[j - (n_limb1 + 1)] = u[j];\n        } else {\n            for(j = n_limb1; j < nb_mods - 1; j++) {\n                carry[j - n_limb1] = (u[j] >> shift) |\n                    (u[j + 1] << (LIMB_BITS - shift));\n            }\n            carry[nb_mods - 1 - n_limb1] = u[nb_mods - 1] >> shift;\n        }\n    }\n}\n#endif\n\nstatic int ntt_static_init(bf_context_t *s1)\n{\n    BFNTTState *s;\n    int inverse, i, j, k, l;\n    limb_t c, c_inv, c_inv2, m, m_inv;\n\n    if (s1->ntt_state)\n        return 0;\n#if defined(__AVX2__)\n    s = bf_aligned_malloc(s1, sizeof(*s), 64);\n#else\n    s = bf_malloc(s1, sizeof(*s));\n#endif\n    if (!s)\n        return -1;\n    memset(s, 0, sizeof(*s));\n    s1->ntt_state = s;\n    s->ctx = s1;\n\n    for(j = 0; j < NB_MODS; j++) {\n        m = ntt_mods[j];\n        m_inv = init_mul_mod_fast(m);\n        s->ntt_mods_div[j] = m_inv;\n#if defined(__AVX2__)\n        s->ntt_mods_vec[j] = _mm256_set1_pd(m);\n        s->ntt_mods_inv_vec[j] = _mm256_set1_pd(1.0 / (double)m);\n#endif\n        c_inv2 = (m + 1) / 2; /* 1/2 */\n        c_inv = 1;\n        for(i = 0; i <= NTT_PROOT_2EXP; i++) {\n            s->ntt_len_inv[j][i][0] = c_inv;\n            s->ntt_len_inv[j][i][1] = init_mul_mod_fast2(c_inv, m);\n            c_inv = mul_mod_fast(c_inv, c_inv2, m, m_inv);\n        }\n\n        for(inverse = 0; inverse < 2; inverse++) {\n            c = ntt_proot[inverse][j];\n            for(i = 0; i < NTT_PROOT_2EXP; i++) {\n                s->ntt_proot_pow[j][inverse][NTT_PROOT_2EXP - i] = c;\n                s->ntt_proot_pow_inv[j][inverse][NTT_PROOT_2EXP - i] =\n                    init_mul_mod_fast2(c, m);\n                c = mul_mod_fast(c, c, m, m_inv);\n            }\n        }\n    }\n\n    l = 0;\n    for(j = 0; j < NB_MODS - 1; j++) {\n        for(k = j + 1; k < NB_MODS; k++) {\n#if defined(__AVX2__)\n            s->ntt_mods_cr_vec[l] = _mm256_set1_pd(int_to_ntt_limb2(ntt_mods_cr[l],\n                                                                    ntt_mods[k]));\n#else\n            s->ntt_mods_cr_inv[l] = init_mul_mod_fast2(ntt_mods_cr[l],\n                                                       ntt_mods[k]);\n#endif\n            l++;\n        }\n    }\n    return 0;\n}\n\nint bf_get_fft_size(int *pdpl, int *pnb_mods, limb_t len)\n{\n    int dpl, fft_len_log2, n_bits, nb_mods, dpl_found, fft_len_log2_found;\n    int int_bits, nb_mods_found;\n    limb_t cost, min_cost;\n\n    min_cost = -1;\n    dpl_found = 0;\n    nb_mods_found = 4;\n    fft_len_log2_found = 0;\n    for(nb_mods = 3; nb_mods <= NB_MODS; nb_mods++) {\n        int_bits = ntt_int_bits[NB_MODS - nb_mods];\n        dpl = bf_min((int_bits - 4) / 2,\n                     2 * LIMB_BITS + 2 * NTT_MOD_LOG2_MIN - NTT_MOD_LOG2_MAX);\n        for(;;) {\n            fft_len_log2 = ceil_log2((len * LIMB_BITS + dpl - 1) / dpl);\n            if (fft_len_log2 > NTT_PROOT_2EXP)\n                goto next;\n            n_bits = fft_len_log2 + 2 * dpl;\n            if (n_bits <= int_bits) {\n                cost = ((limb_t)(fft_len_log2 + 1) << fft_len_log2) * nb_mods;\n                //                printf(\"n=%d dpl=%d: cost=%\" PRId64 \"\\n\", nb_mods, dpl, (int64_t)cost);\n                if (cost < min_cost) {\n                    min_cost = cost;\n                    dpl_found = dpl;\n                    nb_mods_found = nb_mods;\n                    fft_len_log2_found = fft_len_log2;\n                }\n                break;\n            }\n            dpl--;\n            if (dpl == 0)\n                break;\n        }\n    next: ;\n    }\n    if (!dpl_found)\n        abort();\n    /* limit dpl if possible to reduce fixed cost of limb/NTT conversion */\n    if (dpl_found > (LIMB_BITS + NTT_MOD_LOG2_MIN) &&\n        ((limb_t)(LIMB_BITS + NTT_MOD_LOG2_MIN) << fft_len_log2_found) >=\n        len * LIMB_BITS) {\n        dpl_found = LIMB_BITS + NTT_MOD_LOG2_MIN;\n    }\n    *pnb_mods = nb_mods_found;\n    *pdpl = dpl_found;\n    return fft_len_log2_found;\n}\n\n/* return 0 if OK, -1 if memory error */\nstatic no_inline int fft_mul(bf_context_t *s1,\n                             bf_t *res, limb_t *a_tab, limb_t a_len,\n                             limb_t *b_tab, limb_t b_len, int mul_flags)\n{\n    BFNTTState *s;\n    int dpl, fft_len_log2, j, nb_mods, reduced_mem;\n    slimb_t len, fft_len;\n    NTTLimb *buf1, *buf2, *ptr;\n#if defined(USE_MUL_CHECK)\n    limb_t ha, hb, hr, h_ref;\n#endif\n\n    if (ntt_static_init(s1))\n        return -1;\n    s = s1->ntt_state;\n\n    /* find the optimal number of digits per limb (dpl) */\n    len = a_len + b_len;\n    fft_len_log2 = bf_get_fft_size(&dpl, &nb_mods, len);\n    fft_len = (uint64_t)1 << fft_len_log2;\n    //    printf(\"len=%\" PRId64 \" fft_len_log2=%d dpl=%d\\n\", len, fft_len_log2, dpl);\n#if defined(USE_MUL_CHECK)\n    ha = mp_mod1(a_tab, a_len, BF_CHKSUM_MOD, 0);\n    hb = mp_mod1(b_tab, b_len, BF_CHKSUM_MOD, 0);\n#endif\n    if ((mul_flags & (FFT_MUL_R_OVERLAP_A | FFT_MUL_R_OVERLAP_B)) == 0) {\n        if (!(mul_flags & FFT_MUL_R_NORESIZE))\n            bf_resize(res, 0);\n    } else if (mul_flags & FFT_MUL_R_OVERLAP_B) {\n        limb_t *tmp_tab, tmp_len;\n        /* it is better to free 'b' first */\n        tmp_tab = a_tab;\n        a_tab = b_tab;\n        b_tab = tmp_tab;\n        tmp_len = a_len;\n        a_len = b_len;\n        b_len = tmp_len;\n    }\n    buf1 = ntt_malloc(s, sizeof(NTTLimb) * fft_len * nb_mods);\n    if (!buf1)\n        return -1;\n    limb_to_ntt(s, buf1, fft_len, a_tab, a_len, dpl,\n                NB_MODS - nb_mods, nb_mods);\n    if ((mul_flags & (FFT_MUL_R_OVERLAP_A | FFT_MUL_R_OVERLAP_B)) ==\n        FFT_MUL_R_OVERLAP_A) {\n        if (!(mul_flags & FFT_MUL_R_NORESIZE))\n            bf_resize(res, 0);\n    }\n    reduced_mem = (fft_len_log2 >= 14);\n    if (!reduced_mem) {\n        buf2 = ntt_malloc(s, sizeof(NTTLimb) * fft_len * nb_mods);\n        if (!buf2)\n            goto fail;\n        limb_to_ntt(s, buf2, fft_len, b_tab, b_len, dpl,\n                    NB_MODS - nb_mods, nb_mods);\n        if (!(mul_flags & FFT_MUL_R_NORESIZE))\n            bf_resize(res, 0); /* in case res == b */\n    } else {\n        buf2 = ntt_malloc(s, sizeof(NTTLimb) * fft_len);\n        if (!buf2)\n            goto fail;\n    }\n    for(j = 0; j < nb_mods; j++) {\n        if (reduced_mem) {\n            limb_to_ntt(s, buf2, fft_len, b_tab, b_len, dpl,\n                        NB_MODS - nb_mods + j, 1);\n            ptr = buf2;\n        } else {\n            ptr = buf2 + fft_len * j;\n        }\n        if (ntt_conv(s, buf1 + fft_len * j, ptr,\n                     fft_len_log2, fft_len_log2, j + NB_MODS - nb_mods))\n            goto fail;\n    }\n    if (!(mul_flags & FFT_MUL_R_NORESIZE))\n        bf_resize(res, 0); /* in case res == b and reduced mem */\n    ntt_free(s, buf2);\n    buf2 = NULL;\n    if (!(mul_flags & FFT_MUL_R_NORESIZE)) {\n        if (bf_resize(res, len))\n            goto fail;\n    }\n    ntt_to_limb(s, res->tab, len, buf1, fft_len_log2, dpl, nb_mods);\n    ntt_free(s, buf1);\n#if defined(USE_MUL_CHECK)\n    hr = mp_mod1(res->tab, len, BF_CHKSUM_MOD, 0);\n    h_ref = mul_mod(ha, hb, BF_CHKSUM_MOD);\n    if (hr != h_ref) {\n        printf(\"ntt_mul_error: len=%\" PRId_LIMB \" fft_len_log2=%d dpl=%d nb_mods=%d\\n\",\n               len, fft_len_log2, dpl, nb_mods);\n        //        printf(\"ha=0x\" FMT_LIMB\" hb=0x\" FMT_LIMB \" hr=0x\" FMT_LIMB \" expected=0x\" FMT_LIMB \"\\n\", ha, hb, hr, h_ref);\n        exit(1);\n    }\n#endif\n    return 0;\n fail:\n    ntt_free(s, buf1);\n    ntt_free(s, buf2);\n    return -1;\n}\n\n#else /* USE_FFT_MUL */\n\nint bf_get_fft_size(int *pdpl, int *pnb_mods, limb_t len)\n{\n    return 0;\n}\n\n#endif /* !USE_FFT_MUL */\n"
        },
        {
          "name": "libbf.h",
          "type": "blob",
          "size": 17.4462890625,
          "content": "/*\n * Tiny arbitrary precision floating point library\n *\n * Copyright (c) 2017-2021 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#ifndef LIBBF_H\n#define LIBBF_H\n\n#include <stddef.h>\n#include <stdint.h>\n\n#if defined(__SIZEOF_INT128__) && (INTPTR_MAX >= INT64_MAX)\n#define LIMB_LOG2_BITS 6\n#else\n#define LIMB_LOG2_BITS 5\n#endif\n\n#define LIMB_BITS (1 << LIMB_LOG2_BITS)\n\n#if LIMB_BITS == 64\ntypedef __int128 int128_t;\ntypedef unsigned __int128 uint128_t;\ntypedef int64_t slimb_t;\ntypedef uint64_t limb_t;\ntypedef uint128_t dlimb_t;\n#define BF_RAW_EXP_MIN INT64_MIN\n#define BF_RAW_EXP_MAX INT64_MAX\n\n#define LIMB_DIGITS 19\n#define BF_DEC_BASE UINT64_C(10000000000000000000)\n\n#else\n\ntypedef int32_t slimb_t;\ntypedef uint32_t limb_t;\ntypedef uint64_t dlimb_t;\n#define BF_RAW_EXP_MIN INT32_MIN\n#define BF_RAW_EXP_MAX INT32_MAX\n\n#define LIMB_DIGITS 9\n#define BF_DEC_BASE 1000000000U\n\n#endif\n\n/* in bits */\n/* minimum number of bits for the exponent */\n#define BF_EXP_BITS_MIN 3\n/* maximum number of bits for the exponent */\n#define BF_EXP_BITS_MAX (LIMB_BITS - 3)\n/* extended range for exponent, used internally */\n#define BF_EXT_EXP_BITS_MAX (BF_EXP_BITS_MAX + 1)\n/* minimum possible precision */\n#define BF_PREC_MIN 2\n/* minimum possible precision */\n#define BF_PREC_MAX (((limb_t)1 << (LIMB_BITS - 2)) - 2)\n/* some operations support infinite precision */\n#define BF_PREC_INF (BF_PREC_MAX + 1) /* infinite precision */\n\n#if LIMB_BITS == 64\n#define BF_CHKSUM_MOD (UINT64_C(975620677) * UINT64_C(9795002197))\n#else\n#define BF_CHKSUM_MOD 975620677U\n#endif\n\n#define BF_EXP_ZERO BF_RAW_EXP_MIN\n#define BF_EXP_INF (BF_RAW_EXP_MAX - 1)\n#define BF_EXP_NAN BF_RAW_EXP_MAX\n\n/* +/-zero is represented with expn = BF_EXP_ZERO and len = 0,\n   +/-infinity is represented with expn = BF_EXP_INF and len = 0,\n   NaN is represented with expn = BF_EXP_NAN and len = 0 (sign is ignored)\n */\ntypedef struct {\n    struct bf_context_t *ctx;\n    int sign;\n    slimb_t expn;\n    limb_t len;\n    limb_t *tab;\n} bf_t;\n\ntypedef struct {\n    /* must be kept identical to bf_t */\n    struct bf_context_t *ctx;\n    int sign;\n    slimb_t expn;\n    limb_t len;\n    limb_t *tab;\n} bfdec_t;\n\ntypedef enum {\n    BF_RNDN, /* round to nearest, ties to even */\n    BF_RNDZ, /* round to zero */\n    BF_RNDD, /* round to -inf (the code relies on (BF_RNDD xor BF_RNDU) = 1) */\n    BF_RNDU, /* round to +inf */\n    BF_RNDNA, /* round to nearest, ties away from zero */\n    BF_RNDA, /* round away from zero */\n    BF_RNDF, /* faithful rounding (nondeterministic, either RNDD or RNDU,\n                inexact flag is always set)  */\n} bf_rnd_t;\n\n/* allow subnormal numbers. Only available if the number of exponent\n   bits is <= BF_EXP_BITS_USER_MAX and prec != BF_PREC_INF. */\n#define BF_FLAG_SUBNORMAL (1 << 3)\n/* 'prec' is the precision after the radix point instead of the whole\n   mantissa. Can only be used with bf_round() and\n   bfdec_[add|sub|mul|div|sqrt|round](). */\n#define BF_FLAG_RADPNT_PREC (1 << 4)\n\n#define BF_RND_MASK 0x7\n#define BF_EXP_BITS_SHIFT 5\n#define BF_EXP_BITS_MASK 0x3f\n\n/* shortcut for bf_set_exp_bits(BF_EXT_EXP_BITS_MAX) */\n#define BF_FLAG_EXT_EXP (BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT)\n\n/* contains the rounding mode and number of exponents bits */\ntypedef uint32_t bf_flags_t;\n\ntypedef void *bf_realloc_func_t(void *opaque, void *ptr, size_t size);\n\ntypedef struct {\n    bf_t val;\n    limb_t prec;\n} BFConstCache;\n\ntypedef struct bf_context_t {\n    void *realloc_opaque;\n    bf_realloc_func_t *realloc_func;\n    BFConstCache log2_cache;\n    BFConstCache pi_cache;\n    struct BFNTTState *ntt_state;\n} bf_context_t;\n\nstatic inline int bf_get_exp_bits(bf_flags_t flags)\n{\n    int e;\n    e = (flags >> BF_EXP_BITS_SHIFT) & BF_EXP_BITS_MASK;\n    if (e == BF_EXP_BITS_MASK)\n        return BF_EXP_BITS_MAX + 1;\n    else\n        return BF_EXP_BITS_MAX - e;\n}\n\nstatic inline bf_flags_t bf_set_exp_bits(int n)\n{\n    return ((BF_EXP_BITS_MAX - n) & BF_EXP_BITS_MASK) << BF_EXP_BITS_SHIFT;\n}\n\n/* returned status */\n#define BF_ST_INVALID_OP  (1 << 0)\n#define BF_ST_DIVIDE_ZERO (1 << 1)\n#define BF_ST_OVERFLOW    (1 << 2)\n#define BF_ST_UNDERFLOW   (1 << 3)\n#define BF_ST_INEXACT     (1 << 4)\n/* indicate that a memory allocation error occured. NaN is returned */\n#define BF_ST_MEM_ERROR   (1 << 5)\n\n#define BF_RADIX_MAX 36 /* maximum radix for bf_atof() and bf_ftoa() */\n\nstatic inline slimb_t bf_max(slimb_t a, slimb_t b)\n{\n    if (a > b)\n        return a;\n    else\n        return b;\n}\n\nstatic inline slimb_t bf_min(slimb_t a, slimb_t b)\n{\n    if (a < b)\n        return a;\n    else\n        return b;\n}\n\nvoid bf_context_init(bf_context_t *s, bf_realloc_func_t *realloc_func,\n                     void *realloc_opaque);\nvoid bf_context_end(bf_context_t *s);\n/* free memory allocated for the bf cache data */\nvoid bf_clear_cache(bf_context_t *s);\n\nstatic inline void *bf_realloc(bf_context_t *s, void *ptr, size_t size)\n{\n    return s->realloc_func(s->realloc_opaque, ptr, size);\n}\n\n/* 'size' must be != 0 */\nstatic inline void *bf_malloc(bf_context_t *s, size_t size)\n{\n    return bf_realloc(s, NULL, size);\n}\n\nstatic inline void bf_free(bf_context_t *s, void *ptr)\n{\n    /* must test ptr otherwise equivalent to malloc(0) */\n    if (ptr)\n        bf_realloc(s, ptr, 0);\n}\n\nvoid bf_init(bf_context_t *s, bf_t *r);\n\nstatic inline void bf_delete(bf_t *r)\n{\n    bf_context_t *s = r->ctx;\n    /* we accept to delete a zeroed bf_t structure */\n    if (s && r->tab) {\n        bf_realloc(s, r->tab, 0);\n    }\n}\n\nstatic inline void bf_neg(bf_t *r)\n{\n    r->sign ^= 1;\n}\n\nstatic inline int bf_is_finite(const bf_t *a)\n{\n    return (a->expn < BF_EXP_INF);\n}\n\nstatic inline int bf_is_nan(const bf_t *a)\n{\n    return (a->expn == BF_EXP_NAN);\n}\n\nstatic inline int bf_is_zero(const bf_t *a)\n{\n    return (a->expn == BF_EXP_ZERO);\n}\n\nstatic inline void bf_memcpy(bf_t *r, const bf_t *a)\n{\n    *r = *a;\n}\n\nint bf_set_ui(bf_t *r, uint64_t a);\nint bf_set_si(bf_t *r, int64_t a);\nvoid bf_set_nan(bf_t *r);\nvoid bf_set_zero(bf_t *r, int is_neg);\nvoid bf_set_inf(bf_t *r, int is_neg);\nint bf_set(bf_t *r, const bf_t *a);\nvoid bf_move(bf_t *r, bf_t *a);\nint bf_get_float64(const bf_t *a, double *pres, bf_rnd_t rnd_mode);\nint bf_set_float64(bf_t *a, double d);\n\nint bf_cmpu(const bf_t *a, const bf_t *b);\nint bf_cmp_full(const bf_t *a, const bf_t *b);\nint bf_cmp(const bf_t *a, const bf_t *b);\nstatic inline int bf_cmp_eq(const bf_t *a, const bf_t *b)\n{\n    return bf_cmp(a, b) == 0;\n}\n\nstatic inline int bf_cmp_le(const bf_t *a, const bf_t *b)\n{\n    return bf_cmp(a, b) <= 0;\n}\n\nstatic inline int bf_cmp_lt(const bf_t *a, const bf_t *b)\n{\n    return bf_cmp(a, b) < 0;\n}\n\nint bf_add(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec, bf_flags_t flags);\nint bf_sub(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec, bf_flags_t flags);\nint bf_add_si(bf_t *r, const bf_t *a, int64_t b1, limb_t prec, bf_flags_t flags);\nint bf_mul(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec, bf_flags_t flags);\nint bf_mul_ui(bf_t *r, const bf_t *a, uint64_t b1, limb_t prec, bf_flags_t flags);\nint bf_mul_si(bf_t *r, const bf_t *a, int64_t b1, limb_t prec,\n              bf_flags_t flags);\nint bf_mul_2exp(bf_t *r, slimb_t e, limb_t prec, bf_flags_t flags);\nint bf_div(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec, bf_flags_t flags);\n#define BF_DIVREM_EUCLIDIAN BF_RNDF\nint bf_divrem(bf_t *q, bf_t *r, const bf_t *a, const bf_t *b,\n              limb_t prec, bf_flags_t flags, int rnd_mode);\nint bf_rem(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n           bf_flags_t flags, int rnd_mode);\nint bf_remquo(slimb_t *pq, bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,\n              bf_flags_t flags, int rnd_mode);\n/* round to integer with infinite precision */\nint bf_rint(bf_t *r, int rnd_mode);\nint bf_round(bf_t *r, limb_t prec, bf_flags_t flags);\nint bf_sqrtrem(bf_t *r, bf_t *rem1, const bf_t *a);\nint bf_sqrt(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);\nslimb_t bf_get_exp_min(const bf_t *a);\nint bf_logic_or(bf_t *r, const bf_t *a, const bf_t *b);\nint bf_logic_xor(bf_t *r, const bf_t *a, const bf_t *b);\nint bf_logic_and(bf_t *r, const bf_t *a, const bf_t *b);\n\n/* additional flags for bf_atof */\n/* do not accept hex radix prefix (0x or 0X) if radix = 0 or radix = 16 */\n#define BF_ATOF_NO_HEX       (1 << 16)\n/* accept binary (0b or 0B) or octal (0o or 0O) radix prefix if radix = 0 */\n#define BF_ATOF_BIN_OCT      (1 << 17)\n/* Do not parse NaN or Inf */\n#define BF_ATOF_NO_NAN_INF   (1 << 18)\n/* return the exponent separately */\n#define BF_ATOF_EXPONENT       (1 << 19)\n\nint bf_atof(bf_t *a, const char *str, const char **pnext, int radix,\n            limb_t prec, bf_flags_t flags);\n/* this version accepts prec = BF_PREC_INF and returns the radix\n   exponent */\nint bf_atof2(bf_t *r, slimb_t *pexponent,\n             const char *str, const char **pnext, int radix,\n             limb_t prec, bf_flags_t flags);\nint bf_mul_pow_radix(bf_t *r, const bf_t *T, limb_t radix,\n                     slimb_t expn, limb_t prec, bf_flags_t flags);\n\n\n/* Conversion of floating point number to string. Return a null\n   terminated string or NULL if memory error. *plen contains its\n   length if plen != NULL.  The exponent letter is \"e\" for base 10,\n   \"p\" for bases 2, 8, 16 with a binary exponent and \"@\" for the other\n   bases. */\n\n#define BF_FTOA_FORMAT_MASK (3 << 16)\n\n/* fixed format: prec significant digits rounded with (flags &\n   BF_RND_MASK). Exponential notation is used if too many zeros are\n   needed.*/\n#define BF_FTOA_FORMAT_FIXED (0 << 16)\n/* fractional format: prec digits after the decimal point rounded with\n   (flags & BF_RND_MASK) */\n#define BF_FTOA_FORMAT_FRAC  (1 << 16)\n/* free format:\n\n   For binary radices with bf_ftoa() and for bfdec_ftoa(): use the minimum\n   number of digits to represent 'a'. The precision and the rounding\n   mode are ignored.\n\n   For the non binary radices with bf_ftoa(): use as many digits as\n   necessary so that bf_atof() return the same number when using\n   precision 'prec', rounding to nearest and the subnormal\n   configuration of 'flags'. The result is meaningful only if 'a' is\n   already rounded to 'prec' bits. If the subnormal flag is set, the\n   exponent in 'flags' must also be set to the desired exponent range.\n*/\n#define BF_FTOA_FORMAT_FREE  (2 << 16)\n/* same as BF_FTOA_FORMAT_FREE but uses the minimum number of digits\n   (takes more computation time). Identical to BF_FTOA_FORMAT_FREE for\n   binary radices with bf_ftoa() and for bfdec_ftoa(). */\n#define BF_FTOA_FORMAT_FREE_MIN (3 << 16)\n\n/* force exponential notation for fixed or free format */\n#define BF_FTOA_FORCE_EXP    (1 << 20)\n/* add 0x prefix for base 16, 0o prefix for base 8 or 0b prefix for\n   base 2 if non zero value */\n#define BF_FTOA_ADD_PREFIX   (1 << 21)\n/* return \"Infinity\" instead of \"Inf\" and add a \"+\" for positive\n   exponents */\n#define BF_FTOA_JS_QUIRKS    (1 << 22)\n\nchar *bf_ftoa(size_t *plen, const bf_t *a, int radix, limb_t prec,\n              bf_flags_t flags);\n\n/* modulo 2^n instead of saturation. NaN and infinity return 0 */\n#define BF_GET_INT_MOD (1 << 0)\nint bf_get_int32(int *pres, const bf_t *a, int flags);\nint bf_get_int64(int64_t *pres, const bf_t *a, int flags);\nint bf_get_uint64(uint64_t *pres, const bf_t *a);\n\n/* the following functions are exported for testing only. */\nvoid mp_print_str(const char *str, const limb_t *tab, limb_t n);\nvoid bf_print_str(const char *str, const bf_t *a);\nint bf_resize(bf_t *r, limb_t len);\nint bf_get_fft_size(int *pdpl, int *pnb_mods, limb_t len);\nint bf_normalize_and_round(bf_t *r, limb_t prec1, bf_flags_t flags);\nint bf_can_round(const bf_t *a, slimb_t prec, bf_rnd_t rnd_mode, slimb_t k);\nslimb_t bf_mul_log2_radix(slimb_t a1, unsigned int radix, int is_inv,\n                          int is_ceil1);\nint mp_mul(bf_context_t *s, limb_t *result,\n           const limb_t *op1, limb_t op1_size,\n           const limb_t *op2, limb_t op2_size);\nlimb_t mp_add(limb_t *res, const limb_t *op1, const limb_t *op2,\n              limb_t n, limb_t carry);\nlimb_t mp_add_ui(limb_t *tab, limb_t b, size_t n);\nint mp_sqrtrem(bf_context_t *s, limb_t *tabs, limb_t *taba, limb_t n);\nint mp_recip(bf_context_t *s, limb_t *tabr, const limb_t *taba, limb_t n);\nlimb_t bf_isqrt(limb_t a);\n\n/* transcendental functions */\nint bf_const_log2(bf_t *T, limb_t prec, bf_flags_t flags);\nint bf_const_pi(bf_t *T, limb_t prec, bf_flags_t flags);\nint bf_exp(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);\nint bf_log(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);\n#define BF_POW_JS_QUIRKS (1 << 16) /* (+/-1)^(+/-Inf) = NaN, 1^NaN = NaN */\nint bf_pow(bf_t *r, const bf_t *x, const bf_t *y, limb_t prec, bf_flags_t flags);\nint bf_cos(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);\nint bf_sin(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);\nint bf_tan(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);\nint bf_atan(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);\nint bf_atan2(bf_t *r, const bf_t *y, const bf_t *x,\n             limb_t prec, bf_flags_t flags);\nint bf_asin(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);\nint bf_acos(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);\n\n/* decimal floating point */\n\nstatic inline void bfdec_init(bf_context_t *s, bfdec_t *r)\n{\n    bf_init(s, (bf_t *)r);\n}\nstatic inline void bfdec_delete(bfdec_t *r)\n{\n    bf_delete((bf_t *)r);\n}\n\nstatic inline void bfdec_neg(bfdec_t *r)\n{\n    r->sign ^= 1;\n}\n\nstatic inline int bfdec_is_finite(const bfdec_t *a)\n{\n    return (a->expn < BF_EXP_INF);\n}\n\nstatic inline int bfdec_is_nan(const bfdec_t *a)\n{\n    return (a->expn == BF_EXP_NAN);\n}\n\nstatic inline int bfdec_is_zero(const bfdec_t *a)\n{\n    return (a->expn == BF_EXP_ZERO);\n}\n\nstatic inline void bfdec_memcpy(bfdec_t *r, const bfdec_t *a)\n{\n    bf_memcpy((bf_t *)r, (const bf_t *)a);\n}\n\nint bfdec_set_ui(bfdec_t *r, uint64_t a);\nint bfdec_set_si(bfdec_t *r, int64_t a);\n\nstatic inline void bfdec_set_nan(bfdec_t *r)\n{\n    bf_set_nan((bf_t *)r);\n}\nstatic inline void bfdec_set_zero(bfdec_t *r, int is_neg)\n{\n    bf_set_zero((bf_t *)r, is_neg);\n}\nstatic inline void bfdec_set_inf(bfdec_t *r, int is_neg)\n{\n    bf_set_inf((bf_t *)r, is_neg);\n}\nstatic inline int bfdec_set(bfdec_t *r, const bfdec_t *a)\n{\n    return bf_set((bf_t *)r, (bf_t *)a);\n}\nstatic inline void bfdec_move(bfdec_t *r, bfdec_t *a)\n{\n    bf_move((bf_t *)r, (bf_t *)a);\n}\nstatic inline int bfdec_cmpu(const bfdec_t *a, const bfdec_t *b)\n{\n    return bf_cmpu((const bf_t *)a, (const bf_t *)b);\n}\nstatic inline int bfdec_cmp_full(const bfdec_t *a, const bfdec_t *b)\n{\n    return bf_cmp_full((const bf_t *)a, (const bf_t *)b);\n}\nstatic inline int bfdec_cmp(const bfdec_t *a, const bfdec_t *b)\n{\n    return bf_cmp((const bf_t *)a, (const bf_t *)b);\n}\nstatic inline int bfdec_cmp_eq(const bfdec_t *a, const bfdec_t *b)\n{\n    return bfdec_cmp(a, b) == 0;\n}\nstatic inline int bfdec_cmp_le(const bfdec_t *a, const bfdec_t *b)\n{\n    return bfdec_cmp(a, b) <= 0;\n}\nstatic inline int bfdec_cmp_lt(const bfdec_t *a, const bfdec_t *b)\n{\n    return bfdec_cmp(a, b) < 0;\n}\n\nint bfdec_add(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n              bf_flags_t flags);\nint bfdec_sub(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n              bf_flags_t flags);\nint bfdec_add_si(bfdec_t *r, const bfdec_t *a, int64_t b1, limb_t prec,\n                 bf_flags_t flags);\nint bfdec_mul(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n              bf_flags_t flags);\nint bfdec_mul_si(bfdec_t *r, const bfdec_t *a, int64_t b1, limb_t prec,\n                 bf_flags_t flags);\nint bfdec_div(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n              bf_flags_t flags);\nint bfdec_divrem(bfdec_t *q, bfdec_t *r, const bfdec_t *a, const bfdec_t *b,\n                 limb_t prec, bf_flags_t flags, int rnd_mode);\nint bfdec_rem(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,\n              bf_flags_t flags, int rnd_mode);\nint bfdec_rint(bfdec_t *r, int rnd_mode);\nint bfdec_sqrt(bfdec_t *r, const bfdec_t *a, limb_t prec, bf_flags_t flags);\nint bfdec_round(bfdec_t *r, limb_t prec, bf_flags_t flags);\nint bfdec_get_int32(int *pres, const bfdec_t *a);\nint bfdec_pow_ui(bfdec_t *r, const bfdec_t *a, limb_t b);\n\nchar *bfdec_ftoa(size_t *plen, const bfdec_t *a, limb_t prec, bf_flags_t flags);\nint bfdec_atof(bfdec_t *r, const char *str, const char **pnext,\n               limb_t prec, bf_flags_t flags);\n\n/* the following functions are exported for testing only. */\nextern const limb_t mp_pow_dec[LIMB_DIGITS + 1];\nvoid bfdec_print_str(const char *str, const bfdec_t *a);\nstatic inline int bfdec_resize(bfdec_t *r, limb_t len)\n{\n    return bf_resize((bf_t *)r, len);\n}\nint bfdec_normalize_and_round(bfdec_t *r, limb_t prec1, bf_flags_t flags);\n\n#endif /* LIBBF_H */\n"
        },
        {
          "name": "libregexp-opcode.h",
          "type": "blob",
          "size": 2.197265625,
          "content": "/*\n * Regular Expression Engine\n *\n * Copyright (c) 2017-2018 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#ifdef DEF\n\nDEF(invalid, 1) /* never used */\nDEF(char, 3)\nDEF(char32, 5)\nDEF(dot, 1)\nDEF(any, 1) /* same as dot but match any character including line terminator */\nDEF(line_start, 1)\nDEF(line_end, 1)\nDEF(goto, 5)\nDEF(split_goto_first, 5)\nDEF(split_next_first, 5)\nDEF(match, 1)\nDEF(save_start, 2) /* save start position */\nDEF(save_end, 2) /* save end position, must come after saved_start */\nDEF(save_reset, 3) /* reset save positions */\nDEF(loop, 5) /* decrement the top the stack and goto if != 0 */\nDEF(push_i32, 5) /* push integer on the stack */\nDEF(drop, 1)\nDEF(word_boundary, 1)\nDEF(not_word_boundary, 1)\nDEF(back_reference, 2)\nDEF(backward_back_reference, 2) /* must come after back_reference */\nDEF(range, 3) /* variable length */\nDEF(range32, 3) /* variable length */\nDEF(lookahead, 5)\nDEF(negative_lookahead, 5)\nDEF(push_char_pos, 1) /* push the character position on the stack */\nDEF(check_advance, 1) /* pop one stack element and check that it is different from the character position */\nDEF(prev, 1) /* go to the previous char */\nDEF(simple_greedy_quant, 17)\n\n#endif /* DEF */\n"
        },
        {
          "name": "libregexp.c",
          "type": "blob",
          "size": 79.8623046875,
          "content": "/*\n * Regular Expression Engine\n *\n * Copyright (c) 2017-2018 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"cutils.h\"\n#include \"libregexp.h\"\n#include \"libunicode.h\"\n\n/*\n  TODO:\n\n  - Add a lock step execution mode (=linear time execution guaranteed)\n    when the regular expression is \"simple\" i.e. no backreference nor\n    complicated lookahead. The opcodes are designed for this execution\n    model.\n*/\n\n#if defined(TEST)\n#define DUMP_REOP\n#endif\n\ntypedef enum {\n#define DEF(id, size) REOP_ ## id,\n#include \"libregexp-opcode.h\"\n#undef DEF\n    REOP_COUNT,\n} REOPCodeEnum;\n\n#define CAPTURE_COUNT_MAX 255\n#define STACK_SIZE_MAX 255\n\n/* unicode code points */\n#define CP_LS   0x2028\n#define CP_PS   0x2029\n\n#define TMP_BUF_SIZE 128\n\ntypedef struct {\n    DynBuf byte_code;\n    const uint8_t *buf_ptr;\n    const uint8_t *buf_end;\n    const uint8_t *buf_start;\n    int re_flags;\n    BOOL is_unicode;\n    BOOL ignore_case;\n    BOOL dotall;\n    int capture_count;\n    int total_capture_count; /* -1 = not computed yet */\n    int has_named_captures; /* -1 = don't know, 0 = no, 1 = yes */\n    void *opaque;\n    DynBuf group_names;\n    union {\n        char error_msg[TMP_BUF_SIZE];\n        char tmp_buf[TMP_BUF_SIZE];\n    } u;\n} REParseState;\n\ntypedef struct {\n#ifdef DUMP_REOP\n    const char *name;\n#endif\n    uint8_t size;\n} REOpCode;\n\nstatic const REOpCode reopcode_info[REOP_COUNT] = {\n#ifdef DUMP_REOP\n#define DEF(id, size) { #id, size },\n#else\n#define DEF(id, size) { size },\n#endif\n#include \"libregexp-opcode.h\"\n#undef DEF\n};\n\n#define RE_HEADER_FLAGS         0\n#define RE_HEADER_CAPTURE_COUNT 1\n#define RE_HEADER_STACK_SIZE    2\n#define RE_HEADER_BYTECODE_LEN  3\n\n#define RE_HEADER_LEN 7\n\nstatic inline int is_digit(int c) {\n    return c >= '0' && c <= '9';\n}\n\n/* insert 'len' bytes at position 'pos'. Return < 0 if error. */\nstatic int dbuf_insert(DynBuf *s, int pos, int len)\n{\n    if (dbuf_realloc(s, s->size + len))\n        return -1;\n    memmove(s->buf + pos + len, s->buf + pos, s->size - pos);\n    s->size += len;\n    return 0;\n}\n\nstatic const uint16_t char_range_d[] = {\n    1,\n    0x0030, 0x0039 + 1,\n};\n\n/* code point ranges for Zs,Zl or Zp property */\nstatic const uint16_t char_range_s[] = {\n    10,\n    0x0009, 0x000D + 1,\n    0x0020, 0x0020 + 1,\n    0x00A0, 0x00A0 + 1,\n    0x1680, 0x1680 + 1,\n    0x2000, 0x200A + 1,\n    /* 2028;LINE SEPARATOR;Zl;0;WS;;;;;N;;;;; */\n    /* 2029;PARAGRAPH SEPARATOR;Zp;0;B;;;;;N;;;;; */\n    0x2028, 0x2029 + 1,\n    0x202F, 0x202F + 1,\n    0x205F, 0x205F + 1,\n    0x3000, 0x3000 + 1,\n    /* FEFF;ZERO WIDTH NO-BREAK SPACE;Cf;0;BN;;;;;N;BYTE ORDER MARK;;;; */\n    0xFEFF, 0xFEFF + 1,\n};\n\nstatic const uint16_t char_range_w[] = {\n    4,\n    0x0030, 0x0039 + 1,\n    0x0041, 0x005A + 1,\n    0x005F, 0x005F + 1,\n    0x0061, 0x007A + 1,\n};\n\n#define CLASS_RANGE_BASE 0x40000000\n\ntypedef enum {\n    CHAR_RANGE_d,\n    CHAR_RANGE_D,\n    CHAR_RANGE_s,\n    CHAR_RANGE_S,\n    CHAR_RANGE_w,\n    CHAR_RANGE_W,\n} CharRangeEnum;\n\nstatic const uint16_t * const char_range_table[] = {\n    char_range_d,\n    char_range_s,\n    char_range_w,\n};\n\nstatic int cr_init_char_range(REParseState *s, CharRange *cr, uint32_t c)\n{\n    BOOL invert;\n    const uint16_t *c_pt;\n    int len, i;\n\n    invert = c & 1;\n    c_pt = char_range_table[c >> 1];\n    len = *c_pt++;\n    cr_init(cr, s->opaque, lre_realloc);\n    for(i = 0; i < len * 2; i++) {\n        if (cr_add_point(cr, c_pt[i]))\n            goto fail;\n    }\n    if (invert) {\n        if (cr_invert(cr))\n            goto fail;\n    }\n    return 0;\n fail:\n    cr_free(cr);\n    return -1;\n}\n\n#ifdef DUMP_REOP\nstatic __maybe_unused void lre_dump_bytecode(const uint8_t *buf,\n                                                     int buf_len)\n{\n    int pos, len, opcode, bc_len, re_flags, i;\n    uint32_t val;\n\n    assert(buf_len >= RE_HEADER_LEN);\n\n    re_flags = lre_get_flags(buf);\n    bc_len = get_u32(buf + RE_HEADER_BYTECODE_LEN);\n    assert(bc_len + RE_HEADER_LEN <= buf_len);\n    printf(\"flags: 0x%x capture_count=%d stack_size=%d\\n\",\n           re_flags, buf[RE_HEADER_CAPTURE_COUNT], buf[RE_HEADER_STACK_SIZE]);\n    if (re_flags & LRE_FLAG_NAMED_GROUPS) {\n        const char *p;\n        p = (char *)buf + RE_HEADER_LEN + bc_len;\n        printf(\"named groups: \");\n        for(i = 1; i < buf[RE_HEADER_CAPTURE_COUNT]; i++) {\n            if (i != 1)\n                printf(\",\");\n            printf(\"<%s>\", p);\n            p += strlen(p) + 1;\n        }\n        printf(\"\\n\");\n        assert(p == (char *)(buf + buf_len));\n    }\n    printf(\"bytecode_len=%d\\n\", bc_len);\n\n    buf += RE_HEADER_LEN;\n    pos = 0;\n    while (pos < bc_len) {\n        printf(\"%5u: \", pos);\n        opcode = buf[pos];\n        len = reopcode_info[opcode].size;\n        if (opcode >= REOP_COUNT) {\n            printf(\" invalid opcode=0x%02x\\n\", opcode);\n            break;\n        }\n        if ((pos + len) > bc_len) {\n            printf(\" buffer overflow (opcode=0x%02x)\\n\", opcode);\n            break;\n        }\n        printf(\"%s\", reopcode_info[opcode].name);\n        switch(opcode) {\n        case REOP_char:\n            val = get_u16(buf + pos + 1);\n            if (val >= ' ' && val <= 126)\n                printf(\" '%c'\", val);\n            else\n                printf(\" 0x%04x\", val);\n            break;\n        case REOP_char32:\n            val = get_u32(buf + pos + 1);\n            if (val >= ' ' && val <= 126)\n                printf(\" '%c'\", val);\n            else\n                printf(\" 0x%08x\", val);\n            break;\n        case REOP_goto:\n        case REOP_split_goto_first:\n        case REOP_split_next_first:\n        case REOP_loop:\n        case REOP_lookahead:\n        case REOP_negative_lookahead:\n            val = get_u32(buf + pos + 1);\n            val += (pos + 5);\n            printf(\" %u\", val);\n            break;\n        case REOP_simple_greedy_quant:\n            printf(\" %u %u %u %u\",\n                   get_u32(buf + pos + 1) + (pos + 17),\n                   get_u32(buf + pos + 1 + 4),\n                   get_u32(buf + pos + 1 + 8),\n                   get_u32(buf + pos + 1 + 12));\n            break;\n        case REOP_save_start:\n        case REOP_save_end:\n        case REOP_back_reference:\n        case REOP_backward_back_reference:\n            printf(\" %u\", buf[pos + 1]);\n            break;\n        case REOP_save_reset:\n            printf(\" %u %u\", buf[pos + 1], buf[pos + 2]);\n            break;\n        case REOP_push_i32:\n            val = get_u32(buf + pos + 1);\n            printf(\" %d\", val);\n            break;\n        case REOP_range:\n            {\n                int n, i;\n                n = get_u16(buf + pos + 1);\n                len += n * 4;\n                for(i = 0; i < n * 2; i++) {\n                    val = get_u16(buf + pos + 3 + i * 2);\n                    printf(\" 0x%04x\", val);\n                }\n            }\n            break;\n        case REOP_range32:\n            {\n                int n, i;\n                n = get_u16(buf + pos + 1);\n                len += n * 8;\n                for(i = 0; i < n * 2; i++) {\n                    val = get_u32(buf + pos + 3 + i * 4);\n                    printf(\" 0x%08x\", val);\n                }\n            }\n            break;\n        default:\n            break;\n        }\n        printf(\"\\n\");\n        pos += len;\n    }\n}\n#endif\n\nstatic void re_emit_op(REParseState *s, int op)\n{\n    dbuf_putc(&s->byte_code, op);\n}\n\n/* return the offset of the u32 value */\nstatic int re_emit_op_u32(REParseState *s, int op, uint32_t val)\n{\n    int pos;\n    dbuf_putc(&s->byte_code, op);\n    pos = s->byte_code.size;\n    dbuf_put_u32(&s->byte_code, val);\n    return pos;\n}\n\nstatic int re_emit_goto(REParseState *s, int op, uint32_t val)\n{\n    int pos;\n    dbuf_putc(&s->byte_code, op);\n    pos = s->byte_code.size;\n    dbuf_put_u32(&s->byte_code, val - (pos + 4));\n    return pos;\n}\n\nstatic void re_emit_op_u8(REParseState *s, int op, uint32_t val)\n{\n    dbuf_putc(&s->byte_code, op);\n    dbuf_putc(&s->byte_code, val);\n}\n\nstatic void re_emit_op_u16(REParseState *s, int op, uint32_t val)\n{\n    dbuf_putc(&s->byte_code, op);\n    dbuf_put_u16(&s->byte_code, val);\n}\n\nstatic int __attribute__((format(printf, 2, 3))) re_parse_error(REParseState *s, const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vsnprintf(s->u.error_msg, sizeof(s->u.error_msg), fmt, ap);\n    va_end(ap);\n    return -1;\n}\n\nstatic int re_parse_out_of_memory(REParseState *s)\n{\n    return re_parse_error(s, \"out of memory\");\n}\n\n/* If allow_overflow is false, return -1 in case of\n   overflow. Otherwise return INT32_MAX. */\nstatic int parse_digits(const uint8_t **pp, BOOL allow_overflow)\n{\n    const uint8_t *p;\n    uint64_t v;\n    int c;\n\n    p = *pp;\n    v = 0;\n    for(;;) {\n        c = *p;\n        if (c < '0' || c > '9')\n            break;\n        v = v * 10 + c - '0';\n        if (v >= INT32_MAX) {\n            if (allow_overflow)\n                v = INT32_MAX;\n            else\n                return -1;\n        }\n        p++;\n    }\n    *pp = p;\n    return v;\n}\n\nstatic int re_parse_expect(REParseState *s, const uint8_t **pp, int c)\n{\n    const uint8_t *p;\n    p = *pp;\n    if (*p != c)\n        return re_parse_error(s, \"expecting '%c'\", c);\n    p++;\n    *pp = p;\n    return 0;\n}\n\n/* Parse an escape sequence, *pp points after the '\\':\n   allow_utf16 value:\n   0 : no UTF-16 escapes allowed\n   1 : UTF-16 escapes allowed\n   2 : UTF-16 escapes allowed and escapes of surrogate pairs are\n   converted to a unicode character (unicode regexp case).\n\n   Return the unicode char and update *pp if recognized,\n   return -1 if malformed escape,\n   return -2 otherwise. */\nint lre_parse_escape(const uint8_t **pp, int allow_utf16)\n{\n    const uint8_t *p;\n    uint32_t c;\n\n    p = *pp;\n    c = *p++;\n    switch(c) {\n    case 'b':\n        c = '\\b';\n        break;\n    case 'f':\n        c = '\\f';\n        break;\n    case 'n':\n        c = '\\n';\n        break;\n    case 'r':\n        c = '\\r';\n        break;\n    case 't':\n        c = '\\t';\n        break;\n    case 'v':\n        c = '\\v';\n        break;\n    case 'x':\n    case 'u':\n        {\n            int h, n, i;\n            uint32_t c1;\n\n            if (*p == '{' && allow_utf16) {\n                p++;\n                c = 0;\n                for(;;) {\n                    h = from_hex(*p++);\n                    if (h < 0)\n                        return -1;\n                    c = (c << 4) | h;\n                    if (c > 0x10FFFF)\n                        return -1;\n                    if (*p == '}')\n                        break;\n                }\n                p++;\n            } else {\n                if (c == 'x') {\n                    n = 2;\n                } else {\n                    n = 4;\n                }\n\n                c = 0;\n                for(i = 0; i < n; i++) {\n                    h = from_hex(*p++);\n                    if (h < 0) {\n                        return -1;\n                    }\n                    c = (c << 4) | h;\n                }\n                if (is_hi_surrogate(c) &&\n                    allow_utf16 == 2 && p[0] == '\\\\' && p[1] == 'u') {\n                    /* convert an escaped surrogate pair into a\n                       unicode char */\n                    c1 = 0;\n                    for(i = 0; i < 4; i++) {\n                        h = from_hex(p[2 + i]);\n                        if (h < 0)\n                            break;\n                        c1 = (c1 << 4) | h;\n                    }\n                    if (i == 4 && is_lo_surrogate(c1)) {\n                        p += 6;\n                        c = from_surrogate(c, c1);\n                    }\n                }\n            }\n        }\n        break;\n    case '0': case '1': case '2': case '3':\n    case '4': case '5': case '6': case '7':\n        c -= '0';\n        if (allow_utf16 == 2) {\n            /* only accept \\0 not followed by digit */\n            if (c != 0 || is_digit(*p))\n                return -1;\n        } else {\n            /* parse a legacy octal sequence */\n            uint32_t v;\n            v = *p - '0';\n            if (v > 7)\n                break;\n            c = (c << 3) | v;\n            p++;\n            if (c >= 32)\n                break;\n            v = *p - '0';\n            if (v > 7)\n                break;\n            c = (c << 3) | v;\n            p++;\n        }\n        break;\n    default:\n        return -2;\n    }\n    *pp = p;\n    return c;\n}\n\n#ifdef CONFIG_ALL_UNICODE\n/* XXX: we use the same chars for name and value */\nstatic BOOL is_unicode_char(int c)\n{\n    return ((c >= '0' && c <= '9') ||\n            (c >= 'A' && c <= 'Z') ||\n            (c >= 'a' && c <= 'z') ||\n            (c == '_'));\n}\n\nstatic int parse_unicode_property(REParseState *s, CharRange *cr,\n                                  const uint8_t **pp, BOOL is_inv)\n{\n    const uint8_t *p;\n    char name[64], value[64];\n    char *q;\n    BOOL script_ext;\n    int ret;\n\n    p = *pp;\n    if (*p != '{')\n        return re_parse_error(s, \"expecting '{' after \\\\p\");\n    p++;\n    q = name;\n    while (is_unicode_char(*p)) {\n        if ((q - name) >= sizeof(name) - 1)\n            goto unknown_property_name;\n        *q++ = *p++;\n    }\n    *q = '\\0';\n    q = value;\n    if (*p == '=') {\n        p++;\n        while (is_unicode_char(*p)) {\n            if ((q - value) >= sizeof(value) - 1)\n                return re_parse_error(s, \"unknown unicode property value\");\n            *q++ = *p++;\n        }\n    }\n    *q = '\\0';\n    if (*p != '}')\n        return re_parse_error(s, \"expecting '}'\");\n    p++;\n    //    printf(\"name=%s value=%s\\n\", name, value);\n\n    if (!strcmp(name, \"Script\") || !strcmp(name, \"sc\")) {\n        script_ext = FALSE;\n        goto do_script;\n    } else if (!strcmp(name, \"Script_Extensions\") || !strcmp(name, \"scx\")) {\n        script_ext = TRUE;\n    do_script:\n        cr_init(cr, s->opaque, lre_realloc);\n        ret = unicode_script(cr, value, script_ext);\n        if (ret) {\n            cr_free(cr);\n            if (ret == -2)\n                return re_parse_error(s, \"unknown unicode script\");\n            else\n                goto out_of_memory;\n        }\n    } else if (!strcmp(name, \"General_Category\") || !strcmp(name, \"gc\")) {\n        cr_init(cr, s->opaque, lre_realloc);\n        ret = unicode_general_category(cr, value);\n        if (ret) {\n            cr_free(cr);\n            if (ret == -2)\n                return re_parse_error(s, \"unknown unicode general category\");\n            else\n                goto out_of_memory;\n        }\n    } else if (value[0] == '\\0') {\n        cr_init(cr, s->opaque, lre_realloc);\n        ret = unicode_general_category(cr, name);\n        if (ret == -1) {\n            cr_free(cr);\n            goto out_of_memory;\n        }\n        if (ret < 0) {\n            ret = unicode_prop(cr, name);\n            if (ret) {\n                cr_free(cr);\n                if (ret == -2)\n                    goto unknown_property_name;\n                else\n                    goto out_of_memory;\n            }\n        }\n    } else {\n    unknown_property_name:\n        return re_parse_error(s, \"unknown unicode property name\");\n    }\n\n    if (is_inv) {\n        if (cr_invert(cr)) {\n            cr_free(cr);\n            return -1;\n        }\n    }\n    *pp = p;\n    return 0;\n out_of_memory:\n    return re_parse_out_of_memory(s);\n}\n#endif /* CONFIG_ALL_UNICODE */\n\n/* return -1 if error otherwise the character or a class range\n   (CLASS_RANGE_BASE). In case of class range, 'cr' is\n   initialized. Otherwise, it is ignored. */\nstatic int get_class_atom(REParseState *s, CharRange *cr,\n                          const uint8_t **pp, BOOL inclass)\n{\n    const uint8_t *p;\n    uint32_t c;\n    int ret;\n\n    p = *pp;\n\n    c = *p;\n    switch(c) {\n    case '\\\\':\n        p++;\n        if (p >= s->buf_end)\n            goto unexpected_end;\n        c = *p++;\n        switch(c) {\n        case 'd':\n            c = CHAR_RANGE_d;\n            goto class_range;\n        case 'D':\n            c = CHAR_RANGE_D;\n            goto class_range;\n        case 's':\n            c = CHAR_RANGE_s;\n            goto class_range;\n        case 'S':\n            c = CHAR_RANGE_S;\n            goto class_range;\n        case 'w':\n            c = CHAR_RANGE_w;\n            goto class_range;\n        case 'W':\n            c = CHAR_RANGE_W;\n        class_range:\n            if (cr_init_char_range(s, cr, c))\n                return -1;\n            c = CLASS_RANGE_BASE;\n            break;\n        case 'c':\n            c = *p;\n            if ((c >= 'a' && c <= 'z') ||\n                (c >= 'A' && c <= 'Z') ||\n                (((c >= '0' && c <= '9') || c == '_') &&\n                 inclass && !s->is_unicode)) {   /* Annex B.1.4 */\n                c &= 0x1f;\n                p++;\n            } else if (s->is_unicode) {\n                goto invalid_escape;\n            } else {\n                /* otherwise return '\\' and 'c' */\n                p--;\n                c = '\\\\';\n            }\n            break;\n#ifdef CONFIG_ALL_UNICODE\n        case 'p':\n        case 'P':\n            if (s->is_unicode) {\n                if (parse_unicode_property(s, cr, &p, (c == 'P')))\n                    return -1;\n                c = CLASS_RANGE_BASE;\n                break;\n            }\n            /* fall thru */\n#endif\n        default:\n            p--;\n            ret = lre_parse_escape(&p, s->is_unicode * 2);\n            if (ret >= 0) {\n                c = ret;\n            } else {\n                if (ret == -2 && *p != '\\0' && strchr(\"^$\\\\.*+?()[]{}|/\", *p)) {\n                    /* always valid to escape these characters */\n                    goto normal_char;\n                } else if (s->is_unicode) {\n                invalid_escape:\n                    return re_parse_error(s, \"invalid escape sequence in regular expression\");\n                } else {\n                    /* just ignore the '\\' */\n                    goto normal_char;\n                }\n            }\n            break;\n        }\n        break;\n    case '\\0':\n        if (p >= s->buf_end) {\n        unexpected_end:\n            return re_parse_error(s, \"unexpected end\");\n        }\n        /* fall thru */\n    default:\n    normal_char:\n        /* normal char */\n        if (c >= 128) {\n            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);\n            if ((unsigned)c > 0xffff && !s->is_unicode) {\n                /* XXX: should handle non BMP-1 code points */\n                return re_parse_error(s, \"malformed unicode char\");\n            }\n        } else {\n            p++;\n        }\n        break;\n    }\n    *pp = p;\n    return c;\n}\n\nstatic int re_emit_range(REParseState *s, const CharRange *cr)\n{\n    int len, i;\n    uint32_t high;\n\n    len = (unsigned)cr->len / 2;\n    if (len >= 65535)\n        return re_parse_error(s, \"too many ranges\");\n    if (len == 0) {\n        /* not sure it can really happen. Emit a match that is always\n           false */\n        re_emit_op_u32(s, REOP_char32, -1);\n    } else {\n        high = cr->points[cr->len - 1];\n        if (high == UINT32_MAX)\n            high = cr->points[cr->len - 2];\n        if (high <= 0xffff) {\n            /* can use 16 bit ranges with the conversion that 0xffff =\n               infinity */\n            re_emit_op_u16(s, REOP_range, len);\n            for(i = 0; i < cr->len; i += 2) {\n                dbuf_put_u16(&s->byte_code, cr->points[i]);\n                high = cr->points[i + 1] - 1;\n                if (high == UINT32_MAX - 1)\n                    high = 0xffff;\n                dbuf_put_u16(&s->byte_code, high);\n            }\n        } else {\n            re_emit_op_u16(s, REOP_range32, len);\n            for(i = 0; i < cr->len; i += 2) {\n                dbuf_put_u32(&s->byte_code, cr->points[i]);\n                dbuf_put_u32(&s->byte_code, cr->points[i + 1] - 1);\n            }\n        }\n    }\n    return 0;\n}\n\nstatic int re_parse_char_class(REParseState *s, const uint8_t **pp)\n{\n    const uint8_t *p;\n    uint32_t c1, c2;\n    CharRange cr_s, *cr = &cr_s;\n    CharRange cr1_s, *cr1 = &cr1_s;\n    BOOL invert;\n\n    cr_init(cr, s->opaque, lre_realloc);\n    p = *pp;\n    p++;    /* skip '[' */\n\n    invert = FALSE;\n    if (*p == '^') {\n        p++;\n        invert = TRUE;\n    }\n\n    for(;;) {\n        if (*p == ']')\n            break;\n        c1 = get_class_atom(s, cr1, &p, TRUE);\n        if ((int)c1 < 0)\n            goto fail;\n        if (*p == '-' && p[1] != ']') {\n            const uint8_t *p0 = p + 1;\n            if (c1 >= CLASS_RANGE_BASE) {\n                if (s->is_unicode) {\n                    cr_free(cr1);\n                    goto invalid_class_range;\n                }\n                /* Annex B: match '-' character */\n                goto class_atom;\n            }\n            c2 = get_class_atom(s, cr1, &p0, TRUE);\n            if ((int)c2 < 0)\n                goto fail;\n            if (c2 >= CLASS_RANGE_BASE) {\n                cr_free(cr1);\n                if (s->is_unicode) {\n                    goto invalid_class_range;\n                }\n                /* Annex B: match '-' character */\n                goto class_atom;\n            }\n            p = p0;\n            if (c2 < c1) {\n            invalid_class_range:\n                re_parse_error(s, \"invalid class range\");\n                goto fail;\n            }\n            if (cr_union_interval(cr, c1, c2))\n                goto memory_error;\n        } else {\n        class_atom:\n            if (c1 >= CLASS_RANGE_BASE) {\n                int ret;\n                ret = cr_union1(cr, cr1->points, cr1->len);\n                cr_free(cr1);\n                if (ret)\n                    goto memory_error;\n            } else {\n                if (cr_union_interval(cr, c1, c1))\n                    goto memory_error;\n            }\n        }\n    }\n    if (s->ignore_case) {\n        if (cr_regexp_canonicalize(cr, s->is_unicode))\n            goto memory_error;\n    }\n    if (invert) {\n        if (cr_invert(cr))\n            goto memory_error;\n    }\n    if (re_emit_range(s, cr))\n        goto fail;\n    cr_free(cr);\n    p++;    /* skip ']' */\n    *pp = p;\n    return 0;\n memory_error:\n    re_parse_out_of_memory(s);\n fail:\n    cr_free(cr);\n    return -1;\n}\n\n/* Return:\n   - true if the opcodes may not advance the char pointer\n   - false if the opcodes always advance the char pointer\n*/\nstatic BOOL re_need_check_advance(const uint8_t *bc_buf, int bc_buf_len)\n{\n    int pos, opcode, len;\n    uint32_t val;\n    BOOL ret;\n\n    ret = TRUE;\n    pos = 0;\n    while (pos < bc_buf_len) {\n        opcode = bc_buf[pos];\n        len = reopcode_info[opcode].size;\n        switch(opcode) {\n        case REOP_range:\n            val = get_u16(bc_buf + pos + 1);\n            len += val * 4;\n            goto simple_char;\n        case REOP_range32:\n            val = get_u16(bc_buf + pos + 1);\n            len += val * 8;\n            goto simple_char;\n        case REOP_char:\n        case REOP_char32:\n        case REOP_dot:\n        case REOP_any:\n        simple_char:\n            ret = FALSE;\n            break;\n        case REOP_line_start:\n        case REOP_line_end:\n        case REOP_push_i32:\n        case REOP_push_char_pos:\n        case REOP_drop:\n        case REOP_word_boundary:\n        case REOP_not_word_boundary:\n        case REOP_prev:\n            /* no effect */\n            break;\n        case REOP_save_start:\n        case REOP_save_end:\n        case REOP_save_reset:\n        case REOP_back_reference:\n        case REOP_backward_back_reference:\n            break;\n        default:\n            /* safe behavior: we cannot predict the outcome */\n            return TRUE;\n        }\n        pos += len;\n    }\n    return ret;\n}\n\n/* return -1 if a simple quantifier cannot be used. Otherwise return\n   the number of characters in the atom. */\nstatic int re_is_simple_quantifier(const uint8_t *bc_buf, int bc_buf_len)\n{\n    int pos, opcode, len, count;\n    uint32_t val;\n\n    count = 0;\n    pos = 0;\n    while (pos < bc_buf_len) {\n        opcode = bc_buf[pos];\n        len = reopcode_info[opcode].size;\n        switch(opcode) {\n        case REOP_range:\n            val = get_u16(bc_buf + pos + 1);\n            len += val * 4;\n            goto simple_char;\n        case REOP_range32:\n            val = get_u16(bc_buf + pos + 1);\n            len += val * 8;\n            goto simple_char;\n        case REOP_char:\n        case REOP_char32:\n        case REOP_dot:\n        case REOP_any:\n        simple_char:\n            count++;\n            break;\n        case REOP_line_start:\n        case REOP_line_end:\n        case REOP_word_boundary:\n        case REOP_not_word_boundary:\n            break;\n        default:\n            return -1;\n        }\n        pos += len;\n    }\n    return count;\n}\n\n/* '*pp' is the first char after '<' */\nstatic int re_parse_group_name(char *buf, int buf_size, const uint8_t **pp)\n{\n    const uint8_t *p, *p1;\n    uint32_t c, d;\n    char *q;\n\n    p = *pp;\n    q = buf;\n    for(;;) {\n        c = *p;\n        if (c == '\\\\') {\n            p++;\n            if (*p != 'u')\n                return -1;\n            c = lre_parse_escape(&p, 2); // accept surrogate pairs\n        } else if (c == '>') {\n            break;\n        } else if (c >= 128) {\n            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);\n            if (is_hi_surrogate(c)) {\n                d = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);\n                if (is_lo_surrogate(d)) {\n                    c = from_surrogate(c, d);\n                    p = p1;\n                }\n            }\n        } else {\n            p++;\n        }\n        if (c > 0x10FFFF)\n            return -1;\n        if (q == buf) {\n            if (!lre_js_is_ident_first(c))\n                return -1;\n        } else {\n            if (!lre_js_is_ident_next(c))\n                return -1;\n        }\n        if ((q - buf + UTF8_CHAR_LEN_MAX + 1) > buf_size)\n            return -1;\n        if (c < 128) {\n            *q++ = c;\n        } else {\n            q += unicode_to_utf8((uint8_t*)q, c);\n        }\n    }\n    if (q == buf)\n        return -1;\n    *q = '\\0';\n    p++;\n    *pp = p;\n    return 0;\n}\n\n/* if capture_name = NULL: return the number of captures + 1.\n   Otherwise, return the capture index corresponding to capture_name\n   or -1 if none */\nstatic int re_parse_captures(REParseState *s, int *phas_named_captures,\n                             const char *capture_name)\n{\n    const uint8_t *p;\n    int capture_index;\n    char name[TMP_BUF_SIZE];\n\n    capture_index = 1;\n    *phas_named_captures = 0;\n    for (p = s->buf_start; p < s->buf_end; p++) {\n        switch (*p) {\n        case '(':\n            if (p[1] == '?') {\n                if (p[2] == '<' && p[3] != '=' && p[3] != '!') {\n                    *phas_named_captures = 1;\n                    /* potential named capture */\n                    if (capture_name) {\n                        p += 3;\n                        if (re_parse_group_name(name, sizeof(name), &p) == 0) {\n                            if (!strcmp(name, capture_name))\n                                return capture_index;\n                        }\n                    }\n                    capture_index++;\n                    if (capture_index >= CAPTURE_COUNT_MAX)\n                        goto done;\n                }\n            } else {\n                capture_index++;\n                if (capture_index >= CAPTURE_COUNT_MAX)\n                    goto done;\n            }\n            break;\n        case '\\\\':\n            p++;\n            break;\n        case '[':\n            for (p += 1 + (*p == ']'); p < s->buf_end && *p != ']'; p++) {\n                if (*p == '\\\\')\n                    p++;\n            }\n            break;\n        }\n    }\n done:\n    if (capture_name)\n        return -1;\n    else\n        return capture_index;\n}\n\nstatic int re_count_captures(REParseState *s)\n{\n    if (s->total_capture_count < 0) {\n        s->total_capture_count = re_parse_captures(s, &s->has_named_captures,\n                                                   NULL);\n    }\n    return s->total_capture_count;\n}\n\nstatic BOOL re_has_named_captures(REParseState *s)\n{\n    if (s->has_named_captures < 0)\n        re_count_captures(s);\n    return s->has_named_captures;\n}\n\nstatic int find_group_name(REParseState *s, const char *name)\n{\n    const char *p, *buf_end;\n    size_t len, name_len;\n    int capture_index;\n\n    p = (char *)s->group_names.buf;\n    if (!p) return -1;\n    buf_end = (char *)s->group_names.buf + s->group_names.size;\n    name_len = strlen(name);\n    capture_index = 1;\n    while (p < buf_end) {\n        len = strlen(p);\n        if (len == name_len && memcmp(name, p, name_len) == 0)\n            return capture_index;\n        p += len + 1;\n        capture_index++;\n    }\n    return -1;\n}\n\nstatic int re_parse_disjunction(REParseState *s, BOOL is_backward_dir);\n\nstatic int re_parse_term(REParseState *s, BOOL is_backward_dir)\n{\n    const uint8_t *p;\n    int c, last_atom_start, quant_min, quant_max, last_capture_count;\n    BOOL greedy, add_zero_advance_check, is_neg, is_backward_lookahead;\n    CharRange cr_s, *cr = &cr_s;\n\n    last_atom_start = -1;\n    last_capture_count = 0;\n    p = s->buf_ptr;\n    c = *p;\n    switch(c) {\n    case '^':\n        p++;\n        re_emit_op(s, REOP_line_start);\n        break;\n    case '$':\n        p++;\n        re_emit_op(s, REOP_line_end);\n        break;\n    case '.':\n        p++;\n        last_atom_start = s->byte_code.size;\n        last_capture_count = s->capture_count;\n        if (is_backward_dir)\n            re_emit_op(s, REOP_prev);\n        re_emit_op(s, s->dotall ? REOP_any : REOP_dot);\n        if (is_backward_dir)\n            re_emit_op(s, REOP_prev);\n        break;\n    case '{':\n        if (s->is_unicode) {\n            return re_parse_error(s, \"syntax error\");\n        } else if (!is_digit(p[1])) {\n            /* Annex B: we accept '{' not followed by digits as a\n               normal atom */\n            goto parse_class_atom;\n        } else {\n            const uint8_t *p1 = p + 1;\n            /* Annex B: error if it is like a repetition count */\n            parse_digits(&p1, TRUE);\n            if (*p1 == ',') {\n                p1++;\n                if (is_digit(*p1)) {\n                    parse_digits(&p1, TRUE);\n                }\n            }\n            if (*p1 != '}') {\n                goto parse_class_atom;\n            }\n        }\n        /* fall thru */\n    case '*':\n    case '+':\n    case '?':\n        return re_parse_error(s, \"nothing to repeat\");\n    case '(':\n        if (p[1] == '?') {\n            if (p[2] == ':') {\n                p += 3;\n                last_atom_start = s->byte_code.size;\n                last_capture_count = s->capture_count;\n                s->buf_ptr = p;\n                if (re_parse_disjunction(s, is_backward_dir))\n                    return -1;\n                p = s->buf_ptr;\n                if (re_parse_expect(s, &p, ')'))\n                    return -1;\n            } else if ((p[2] == '=' || p[2] == '!')) {\n                is_neg = (p[2] == '!');\n                is_backward_lookahead = FALSE;\n                p += 3;\n                goto lookahead;\n            } else if (p[2] == '<' &&\n                       (p[3] == '=' || p[3] == '!')) {\n                int pos;\n                is_neg = (p[3] == '!');\n                is_backward_lookahead = TRUE;\n                p += 4;\n                /* lookahead */\n            lookahead:\n                /* Annex B allows lookahead to be used as an atom for\n                   the quantifiers */\n                if (!s->is_unicode && !is_backward_lookahead)  {\n                    last_atom_start = s->byte_code.size;\n                    last_capture_count = s->capture_count;\n                }\n                pos = re_emit_op_u32(s, REOP_lookahead + is_neg, 0);\n                s->buf_ptr = p;\n                if (re_parse_disjunction(s, is_backward_lookahead))\n                    return -1;\n                p = s->buf_ptr;\n                if (re_parse_expect(s, &p, ')'))\n                    return -1;\n                re_emit_op(s, REOP_match);\n                /* jump after the 'match' after the lookahead is successful */\n                if (dbuf_error(&s->byte_code))\n                    return -1;\n                put_u32(s->byte_code.buf + pos, s->byte_code.size - (pos + 4));\n            } else if (p[2] == '<') {\n                p += 3;\n                if (re_parse_group_name(s->u.tmp_buf, sizeof(s->u.tmp_buf),\n                                        &p)) {\n                    return re_parse_error(s, \"invalid group name\");\n                }\n                if (find_group_name(s, s->u.tmp_buf) > 0) {\n                    return re_parse_error(s, \"duplicate group name\");\n                }\n                /* group name with a trailing zero */\n                dbuf_put(&s->group_names, (uint8_t *)s->u.tmp_buf,\n                         strlen(s->u.tmp_buf) + 1);\n                s->has_named_captures = 1;\n                goto parse_capture;\n            } else {\n                return re_parse_error(s, \"invalid group\");\n            }\n        } else {\n            int capture_index;\n            p++;\n            /* capture without group name */\n            dbuf_putc(&s->group_names, 0);\n        parse_capture:\n            if (s->capture_count >= CAPTURE_COUNT_MAX)\n                return re_parse_error(s, \"too many captures\");\n            last_atom_start = s->byte_code.size;\n            last_capture_count = s->capture_count;\n            capture_index = s->capture_count++;\n            re_emit_op_u8(s, REOP_save_start + is_backward_dir,\n                          capture_index);\n\n            s->buf_ptr = p;\n            if (re_parse_disjunction(s, is_backward_dir))\n                return -1;\n            p = s->buf_ptr;\n\n            re_emit_op_u8(s, REOP_save_start + 1 - is_backward_dir,\n                          capture_index);\n\n            if (re_parse_expect(s, &p, ')'))\n                return -1;\n        }\n        break;\n    case '\\\\':\n        switch(p[1]) {\n        case 'b':\n        case 'B':\n            re_emit_op(s, REOP_word_boundary + (p[1] != 'b'));\n            p += 2;\n            break;\n        case 'k':\n            {\n                const uint8_t *p1;\n                int dummy_res;\n\n                p1 = p;\n                if (p1[2] != '<') {\n                    /* annex B: we tolerate invalid group names in non\n                       unicode mode if there is no named capture\n                       definition */\n                    if (s->is_unicode || re_has_named_captures(s))\n                        return re_parse_error(s, \"expecting group name\");\n                    else\n                        goto parse_class_atom;\n                }\n                p1 += 3;\n                if (re_parse_group_name(s->u.tmp_buf, sizeof(s->u.tmp_buf),\n                                        &p1)) {\n                    if (s->is_unicode || re_has_named_captures(s))\n                        return re_parse_error(s, \"invalid group name\");\n                    else\n                        goto parse_class_atom;\n                }\n                c = find_group_name(s, s->u.tmp_buf);\n                if (c < 0) {\n                    /* no capture name parsed before, try to look\n                       after (inefficient, but hopefully not common */\n                    c = re_parse_captures(s, &dummy_res, s->u.tmp_buf);\n                    if (c < 0) {\n                        if (s->is_unicode || re_has_named_captures(s))\n                            return re_parse_error(s, \"group name not defined\");\n                        else\n                            goto parse_class_atom;\n                    }\n                }\n                p = p1;\n            }\n            goto emit_back_reference;\n        case '0':\n            p += 2;\n            c = 0;\n            if (s->is_unicode) {\n                if (is_digit(*p)) {\n                    return re_parse_error(s, \"invalid decimal escape in regular expression\");\n                }\n            } else {\n                /* Annex B.1.4: accept legacy octal */\n                if (*p >= '0' && *p <= '7') {\n                    c = *p++ - '0';\n                    if (*p >= '0' && *p <= '7') {\n                        c = (c << 3) + *p++ - '0';\n                    }\n                }\n            }\n            goto normal_char;\n        case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8':\n        case '9':\n            {\n                const uint8_t *q = ++p;\n\n                c = parse_digits(&p, FALSE);\n                if (c < 0 || (c >= s->capture_count && c >= re_count_captures(s))) {\n                    if (!s->is_unicode) {\n                        /* Annex B.1.4: accept legacy octal */\n                        p = q;\n                        if (*p <= '7') {\n                            c = 0;\n                            if (*p <= '3')\n                                c = *p++ - '0';\n                            if (*p >= '0' && *p <= '7') {\n                                c = (c << 3) + *p++ - '0';\n                                if (*p >= '0' && *p <= '7') {\n                                    c = (c << 3) + *p++ - '0';\n                                }\n                            }\n                        } else {\n                            c = *p++;\n                        }\n                        goto normal_char;\n                    }\n                    return re_parse_error(s, \"back reference out of range in regular expression\");\n                }\n            emit_back_reference:\n                last_atom_start = s->byte_code.size;\n                last_capture_count = s->capture_count;\n                re_emit_op_u8(s, REOP_back_reference + is_backward_dir, c);\n            }\n            break;\n        default:\n            goto parse_class_atom;\n        }\n        break;\n    case '[':\n        last_atom_start = s->byte_code.size;\n        last_capture_count = s->capture_count;\n        if (is_backward_dir)\n            re_emit_op(s, REOP_prev);\n        if (re_parse_char_class(s, &p))\n            return -1;\n        if (is_backward_dir)\n            re_emit_op(s, REOP_prev);\n        break;\n    case ']':\n    case '}':\n        if (s->is_unicode)\n            return re_parse_error(s, \"syntax error\");\n        goto parse_class_atom;\n    default:\n    parse_class_atom:\n        c = get_class_atom(s, cr, &p, FALSE);\n        if ((int)c < 0)\n            return -1;\n    normal_char:\n        last_atom_start = s->byte_code.size;\n        last_capture_count = s->capture_count;\n        if (is_backward_dir)\n            re_emit_op(s, REOP_prev);\n        if (c >= CLASS_RANGE_BASE) {\n            int ret;\n            /* Note: canonicalization is not needed */\n            ret = re_emit_range(s, cr);\n            cr_free(cr);\n            if (ret)\n                return -1;\n        } else {\n            if (s->ignore_case)\n                c = lre_canonicalize(c, s->is_unicode);\n            if (c <= 0xffff)\n                re_emit_op_u16(s, REOP_char, c);\n            else\n                re_emit_op_u32(s, REOP_char32, c);\n        }\n        if (is_backward_dir)\n            re_emit_op(s, REOP_prev);\n        break;\n    }\n\n    /* quantifier */\n    if (last_atom_start >= 0) {\n        c = *p;\n        switch(c) {\n        case '*':\n            p++;\n            quant_min = 0;\n            quant_max = INT32_MAX;\n            goto quantifier;\n        case '+':\n            p++;\n            quant_min = 1;\n            quant_max = INT32_MAX;\n            goto quantifier;\n        case '?':\n            p++;\n            quant_min = 0;\n            quant_max = 1;\n            goto quantifier;\n        case '{':\n            {\n                const uint8_t *p1 = p;\n                /* As an extension (see ES6 annex B), we accept '{' not\n                   followed by digits as a normal atom */\n                if (!is_digit(p[1])) {\n                    if (s->is_unicode)\n                        goto invalid_quant_count;\n                    break;\n                }\n                p++;\n                quant_min = parse_digits(&p, TRUE);\n                quant_max = quant_min;\n                if (*p == ',') {\n                    p++;\n                    if (is_digit(*p)) {\n                        quant_max = parse_digits(&p, TRUE);\n                        if (quant_max < quant_min) {\n                        invalid_quant_count:\n                            return re_parse_error(s, \"invalid repetition count\");\n                        }\n                    } else {\n                        quant_max = INT32_MAX; /* infinity */\n                    }\n                }\n                if (*p != '}' && !s->is_unicode) {\n                    /* Annex B: normal atom if invalid '{' syntax */\n                    p = p1;\n                    break;\n                }\n                if (re_parse_expect(s, &p, '}'))\n                    return -1;\n            }\n        quantifier:\n            greedy = TRUE;\n            if (*p == '?') {\n                p++;\n                greedy = FALSE;\n            }\n            if (last_atom_start < 0) {\n                return re_parse_error(s, \"nothing to repeat\");\n            }\n            if (greedy) {\n                int len, pos;\n\n                if (quant_max > 0) {\n                    /* specific optimization for simple quantifiers */\n                    if (dbuf_error(&s->byte_code))\n                        goto out_of_memory;\n                    len = re_is_simple_quantifier(s->byte_code.buf + last_atom_start,\n                                                 s->byte_code.size - last_atom_start);\n                    if (len > 0) {\n                        re_emit_op(s, REOP_match);\n\n                        if (dbuf_insert(&s->byte_code, last_atom_start, 17))\n                            goto out_of_memory;\n                        pos = last_atom_start;\n                        s->byte_code.buf[pos++] = REOP_simple_greedy_quant;\n                        put_u32(&s->byte_code.buf[pos],\n                                s->byte_code.size - last_atom_start - 17);\n                        pos += 4;\n                        put_u32(&s->byte_code.buf[pos], quant_min);\n                        pos += 4;\n                        put_u32(&s->byte_code.buf[pos], quant_max);\n                        pos += 4;\n                        put_u32(&s->byte_code.buf[pos], len);\n                        pos += 4;\n                        goto done;\n                    }\n                }\n\n                if (dbuf_error(&s->byte_code))\n                    goto out_of_memory;\n            }\n            /* the spec tells that if there is no advance when\n               running the atom after the first quant_min times,\n               then there is no match. We remove this test when we\n               are sure the atom always advances the position. */\n            add_zero_advance_check = re_need_check_advance(s->byte_code.buf + last_atom_start,\n                                                           s->byte_code.size - last_atom_start);\n\n            {\n                int len, pos;\n                len = s->byte_code.size - last_atom_start;\n                if (quant_min == 0) {\n                    /* need to reset the capture in case the atom is\n                       not executed */\n                    if (last_capture_count != s->capture_count) {\n                        if (dbuf_insert(&s->byte_code, last_atom_start, 3))\n                            goto out_of_memory;\n                        s->byte_code.buf[last_atom_start++] = REOP_save_reset;\n                        s->byte_code.buf[last_atom_start++] = last_capture_count;\n                        s->byte_code.buf[last_atom_start++] = s->capture_count - 1;\n                    }\n                    if (quant_max == 0) {\n                        s->byte_code.size = last_atom_start;\n                    } else if (quant_max == 1 || quant_max == INT32_MAX) {\n                        BOOL has_goto = (quant_max == INT32_MAX);\n                        if (dbuf_insert(&s->byte_code, last_atom_start, 5 + add_zero_advance_check))\n                            goto out_of_memory;\n                        s->byte_code.buf[last_atom_start] = REOP_split_goto_first +\n                            greedy;\n                        put_u32(s->byte_code.buf + last_atom_start + 1,\n                                len + 5 * has_goto + add_zero_advance_check * 2);\n                        if (add_zero_advance_check) {\n                            s->byte_code.buf[last_atom_start + 1 + 4] = REOP_push_char_pos;\n                            re_emit_op(s, REOP_check_advance);\n                        }\n                        if (has_goto)\n                            re_emit_goto(s, REOP_goto, last_atom_start);\n                    } else {\n                        if (dbuf_insert(&s->byte_code, last_atom_start, 10 + add_zero_advance_check))\n                            goto out_of_memory;\n                        pos = last_atom_start;\n                        s->byte_code.buf[pos++] = REOP_push_i32;\n                        put_u32(s->byte_code.buf + pos, quant_max);\n                        pos += 4;\n                        s->byte_code.buf[pos++] = REOP_split_goto_first + greedy;\n                        put_u32(s->byte_code.buf + pos, len + 5 + add_zero_advance_check * 2);\n                        pos += 4;\n                        if (add_zero_advance_check) {\n                            s->byte_code.buf[pos++] = REOP_push_char_pos;\n                            re_emit_op(s, REOP_check_advance);\n                        }\n                        re_emit_goto(s, REOP_loop, last_atom_start + 5);\n                        re_emit_op(s, REOP_drop);\n                    }\n                } else if (quant_min == 1 && quant_max == INT32_MAX &&\n                           !add_zero_advance_check) {\n                    re_emit_goto(s, REOP_split_next_first - greedy,\n                                 last_atom_start);\n                } else {\n                    if (quant_min == 1) {\n                        /* nothing to add */\n                    } else {\n                        if (dbuf_insert(&s->byte_code, last_atom_start, 5))\n                            goto out_of_memory;\n                        s->byte_code.buf[last_atom_start] = REOP_push_i32;\n                        put_u32(s->byte_code.buf + last_atom_start + 1,\n                                quant_min);\n                        last_atom_start += 5;\n                        re_emit_goto(s, REOP_loop, last_atom_start);\n                        re_emit_op(s, REOP_drop);\n                    }\n                    if (quant_max == INT32_MAX) {\n                        pos = s->byte_code.size;\n                        re_emit_op_u32(s, REOP_split_goto_first + greedy,\n                                       len + 5 + add_zero_advance_check * 2);\n                        if (add_zero_advance_check)\n                            re_emit_op(s, REOP_push_char_pos);\n                        /* copy the atom */\n                        dbuf_put_self(&s->byte_code, last_atom_start, len);\n                        if (add_zero_advance_check)\n                            re_emit_op(s, REOP_check_advance);\n                        re_emit_goto(s, REOP_goto, pos);\n                    } else if (quant_max > quant_min) {\n                        re_emit_op_u32(s, REOP_push_i32, quant_max - quant_min);\n                        pos = s->byte_code.size;\n                        re_emit_op_u32(s, REOP_split_goto_first + greedy,\n                                       len + 5 + add_zero_advance_check * 2);\n                        if (add_zero_advance_check)\n                            re_emit_op(s, REOP_push_char_pos);\n                        /* copy the atom */\n                        dbuf_put_self(&s->byte_code, last_atom_start, len);\n                        if (add_zero_advance_check)\n                            re_emit_op(s, REOP_check_advance);\n                        re_emit_goto(s, REOP_loop, pos);\n                        re_emit_op(s, REOP_drop);\n                    }\n                }\n                last_atom_start = -1;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n done:\n    s->buf_ptr = p;\n    return 0;\n out_of_memory:\n    return re_parse_out_of_memory(s);\n}\n\nstatic int re_parse_alternative(REParseState *s, BOOL is_backward_dir)\n{\n    const uint8_t *p;\n    int ret;\n    size_t start, term_start, end, term_size;\n\n    start = s->byte_code.size;\n    for(;;) {\n        p = s->buf_ptr;\n        if (p >= s->buf_end)\n            break;\n        if (*p == '|' || *p == ')')\n            break;\n        term_start = s->byte_code.size;\n        ret = re_parse_term(s, is_backward_dir);\n        if (ret)\n            return ret;\n        if (is_backward_dir) {\n            /* reverse the order of the terms (XXX: inefficient, but\n               speed is not really critical here) */\n            end = s->byte_code.size;\n            term_size = end - term_start;\n            if (dbuf_realloc(&s->byte_code, end + term_size))\n                return -1;\n            memmove(s->byte_code.buf + start + term_size,\n                    s->byte_code.buf + start,\n                    end - start);\n            memcpy(s->byte_code.buf + start, s->byte_code.buf + end,\n                   term_size);\n        }\n    }\n    return 0;\n}\n\nstatic int re_parse_disjunction(REParseState *s, BOOL is_backward_dir)\n{\n    int start, len, pos;\n\n    if (lre_check_stack_overflow(s->opaque, 0))\n        return re_parse_error(s, \"stack overflow\");\n\n    start = s->byte_code.size;\n    if (re_parse_alternative(s, is_backward_dir))\n        return -1;\n    while (*s->buf_ptr == '|') {\n        s->buf_ptr++;\n\n        len = s->byte_code.size - start;\n\n        /* insert a split before the first alternative */\n        if (dbuf_insert(&s->byte_code, start, 5)) {\n            return re_parse_out_of_memory(s);\n        }\n        s->byte_code.buf[start] = REOP_split_next_first;\n        put_u32(s->byte_code.buf + start + 1, len + 5);\n\n        pos = re_emit_op_u32(s, REOP_goto, 0);\n\n        if (re_parse_alternative(s, is_backward_dir))\n            return -1;\n\n        /* patch the goto */\n        len = s->byte_code.size - (pos + 4);\n        put_u32(s->byte_code.buf + pos, len);\n    }\n    return 0;\n}\n\n/* the control flow is recursive so the analysis can be linear */\nstatic int compute_stack_size(const uint8_t *bc_buf, int bc_buf_len)\n{\n    int stack_size, stack_size_max, pos, opcode, len;\n    uint32_t val;\n\n    stack_size = 0;\n    stack_size_max = 0;\n    bc_buf += RE_HEADER_LEN;\n    bc_buf_len -= RE_HEADER_LEN;\n    pos = 0;\n    while (pos < bc_buf_len) {\n        opcode = bc_buf[pos];\n        len = reopcode_info[opcode].size;\n        assert(opcode < REOP_COUNT);\n        assert((pos + len) <= bc_buf_len);\n        switch(opcode) {\n        case REOP_push_i32:\n        case REOP_push_char_pos:\n            stack_size++;\n            if (stack_size > stack_size_max) {\n                if (stack_size > STACK_SIZE_MAX)\n                    return -1;\n                stack_size_max = stack_size;\n            }\n            break;\n        case REOP_drop:\n        case REOP_check_advance:\n            assert(stack_size > 0);\n            stack_size--;\n            break;\n        case REOP_range:\n            val = get_u16(bc_buf + pos + 1);\n            len += val * 4;\n            break;\n        case REOP_range32:\n            val = get_u16(bc_buf + pos + 1);\n            len += val * 8;\n            break;\n        }\n        pos += len;\n    }\n    return stack_size_max;\n}\n\n/* 'buf' must be a zero terminated UTF-8 string of length buf_len.\n   Return NULL if error and allocate an error message in *perror_msg,\n   otherwise the compiled bytecode and its length in plen.\n*/\nuint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,\n                     const char *buf, size_t buf_len, int re_flags,\n                     void *opaque)\n{\n    REParseState s_s, *s = &s_s;\n    int stack_size;\n    BOOL is_sticky;\n\n    memset(s, 0, sizeof(*s));\n    s->opaque = opaque;\n    s->buf_ptr = (const uint8_t *)buf;\n    s->buf_end = s->buf_ptr + buf_len;\n    s->buf_start = s->buf_ptr;\n    s->re_flags = re_flags;\n    s->is_unicode = ((re_flags & LRE_FLAG_UNICODE) != 0);\n    is_sticky = ((re_flags & LRE_FLAG_STICKY) != 0);\n    s->ignore_case = ((re_flags & LRE_FLAG_IGNORECASE) != 0);\n    s->dotall = ((re_flags & LRE_FLAG_DOTALL) != 0);\n    s->capture_count = 1;\n    s->total_capture_count = -1;\n    s->has_named_captures = -1;\n\n    dbuf_init2(&s->byte_code, opaque, lre_realloc);\n    dbuf_init2(&s->group_names, opaque, lre_realloc);\n\n    dbuf_putc(&s->byte_code, re_flags); /* first element is the flags */\n    dbuf_putc(&s->byte_code, 0); /* second element is the number of captures */\n    dbuf_putc(&s->byte_code, 0); /* stack size */\n    dbuf_put_u32(&s->byte_code, 0); /* bytecode length */\n\n    if (!is_sticky) {\n        /* iterate thru all positions (about the same as .*?( ... ) )\n           .  We do it without an explicit loop so that lock step\n           thread execution will be possible in an optimized\n           implementation */\n        re_emit_op_u32(s, REOP_split_goto_first, 1 + 5);\n        re_emit_op(s, REOP_any);\n        re_emit_op_u32(s, REOP_goto, -(5 + 1 + 5));\n    }\n    re_emit_op_u8(s, REOP_save_start, 0);\n\n    if (re_parse_disjunction(s, FALSE)) {\n    error:\n        dbuf_free(&s->byte_code);\n        dbuf_free(&s->group_names);\n        pstrcpy(error_msg, error_msg_size, s->u.error_msg);\n        *plen = 0;\n        return NULL;\n    }\n\n    re_emit_op_u8(s, REOP_save_end, 0);\n\n    re_emit_op(s, REOP_match);\n\n    if (*s->buf_ptr != '\\0') {\n        re_parse_error(s, \"extraneous characters at the end\");\n        goto error;\n    }\n\n    if (dbuf_error(&s->byte_code)) {\n        re_parse_out_of_memory(s);\n        goto error;\n    }\n\n    stack_size = compute_stack_size(s->byte_code.buf, s->byte_code.size);\n    if (stack_size < 0) {\n        re_parse_error(s, \"too many imbricated quantifiers\");\n        goto error;\n    }\n\n    s->byte_code.buf[RE_HEADER_CAPTURE_COUNT] = s->capture_count;\n    s->byte_code.buf[RE_HEADER_STACK_SIZE] = stack_size;\n    put_u32(s->byte_code.buf + RE_HEADER_BYTECODE_LEN,\n            s->byte_code.size - RE_HEADER_LEN);\n\n    /* add the named groups if needed */\n    if (s->group_names.size > (s->capture_count - 1)) {\n        dbuf_put(&s->byte_code, s->group_names.buf, s->group_names.size);\n        s->byte_code.buf[RE_HEADER_FLAGS] |= LRE_FLAG_NAMED_GROUPS;\n    }\n    dbuf_free(&s->group_names);\n\n#ifdef DUMP_REOP\n    lre_dump_bytecode(s->byte_code.buf, s->byte_code.size);\n#endif\n\n    error_msg[0] = '\\0';\n    *plen = s->byte_code.size;\n    return s->byte_code.buf;\n}\n\nstatic BOOL is_line_terminator(uint32_t c)\n{\n    return (c == '\\n' || c == '\\r' || c == CP_LS || c == CP_PS);\n}\n\nstatic BOOL is_word_char(uint32_t c)\n{\n    return ((c >= '0' && c <= '9') ||\n            (c >= 'a' && c <= 'z') ||\n            (c >= 'A' && c <= 'Z') ||\n            (c == '_'));\n}\n\n#define GET_CHAR(c, cptr, cbuf_end, cbuf_type)                          \\\n    do {                                                                \\\n        if (cbuf_type == 0) {                                           \\\n            c = *cptr++;                                                \\\n        } else {                                                        \\\n            const uint16_t *_p = (const uint16_t *)cptr;                \\\n            const uint16_t *_end = (const uint16_t *)cbuf_end;          \\\n            c = *_p++;                                                  \\\n            if (is_hi_surrogate(c) && cbuf_type == 2) {                 \\\n                if (_p < _end && is_lo_surrogate(*_p)) {                \\\n                    c = from_surrogate(c, *_p++);                       \\\n                }                                                       \\\n            }                                                           \\\n            cptr = (const void *)_p;                                    \\\n        }                                                               \\\n    } while (0)\n\n#define PEEK_CHAR(c, cptr, cbuf_end, cbuf_type)                         \\\n    do {                                                                \\\n        if (cbuf_type == 0) {                                           \\\n            c = cptr[0];                                                \\\n        } else {                                                        \\\n            const uint16_t *_p = (const uint16_t *)cptr;                \\\n            const uint16_t *_end = (const uint16_t *)cbuf_end;          \\\n            c = *_p++;                                                  \\\n            if (is_hi_surrogate(c) && cbuf_type == 2) {                 \\\n                if (_p < _end && is_lo_surrogate(*_p)) {                \\\n                    c = from_surrogate(c, *_p);                         \\\n                }                                                       \\\n            }                                                           \\\n        }                                                               \\\n    } while (0)\n\n#define PEEK_PREV_CHAR(c, cptr, cbuf_start, cbuf_type)                  \\\n    do {                                                                \\\n        if (cbuf_type == 0) {                                           \\\n            c = cptr[-1];                                               \\\n        } else {                                                        \\\n            const uint16_t *_p = (const uint16_t *)cptr - 1;            \\\n            const uint16_t *_start = (const uint16_t *)cbuf_start;      \\\n            c = *_p;                                                    \\\n            if (is_lo_surrogate(c) && cbuf_type == 2) {                 \\\n                if (_p > _start && is_hi_surrogate(_p[-1])) {           \\\n                    c = from_surrogate(*--_p, c);                       \\\n                }                                                       \\\n            }                                                           \\\n        }                                                               \\\n    } while (0)\n\n#define GET_PREV_CHAR(c, cptr, cbuf_start, cbuf_type)                   \\\n    do {                                                                \\\n        if (cbuf_type == 0) {                                           \\\n            cptr--;                                                     \\\n            c = cptr[0];                                                \\\n        } else {                                                        \\\n            const uint16_t *_p = (const uint16_t *)cptr - 1;            \\\n            const uint16_t *_start = (const uint16_t *)cbuf_start;      \\\n            c = *_p;                                                    \\\n            if (is_lo_surrogate(c) && cbuf_type == 2) {                 \\\n                if (_p > _start && is_hi_surrogate(_p[-1])) {           \\\n                    c = from_surrogate(*--_p, c);                       \\\n                }                                                       \\\n            }                                                           \\\n            cptr = (const void *)_p;                                    \\\n        }                                                               \\\n    } while (0)\n\n#define PREV_CHAR(cptr, cbuf_start, cbuf_type)                          \\\n    do {                                                                \\\n        if (cbuf_type == 0) {                                           \\\n            cptr--;                                                     \\\n        } else {                                                        \\\n            const uint16_t *_p = (const uint16_t *)cptr - 1;            \\\n            const uint16_t *_start = (const uint16_t *)cbuf_start;      \\\n            if (is_lo_surrogate(*_p) && cbuf_type == 2) {               \\\n                if (_p > _start && is_hi_surrogate(_p[-1])) {           \\\n                    --_p;                                               \\\n                }                                                       \\\n            }                                                           \\\n            cptr = (const void *)_p;                                    \\\n        }                                                               \\\n    } while (0)\n\ntypedef uintptr_t StackInt;\n\ntypedef enum {\n    RE_EXEC_STATE_SPLIT,\n    RE_EXEC_STATE_LOOKAHEAD,\n    RE_EXEC_STATE_NEGATIVE_LOOKAHEAD,\n    RE_EXEC_STATE_GREEDY_QUANT,\n} REExecStateEnum;\n\ntypedef struct REExecState {\n    REExecStateEnum type : 8;\n    uint8_t stack_len;\n    size_t count; /* only used for RE_EXEC_STATE_GREEDY_QUANT */\n    const uint8_t *cptr;\n    const uint8_t *pc;\n    void *buf[0];\n} REExecState;\n\ntypedef struct {\n    const uint8_t *cbuf;\n    const uint8_t *cbuf_end;\n    /* 0 = 8 bit chars, 1 = 16 bit chars, 2 = 16 bit chars, UTF-16 */\n    int cbuf_type;\n    int capture_count;\n    int stack_size_max;\n    BOOL multi_line;\n    BOOL ignore_case;\n    BOOL is_unicode;\n    void *opaque; /* used for stack overflow check */\n\n    size_t state_size;\n    uint8_t *state_stack;\n    size_t state_stack_size;\n    size_t state_stack_len;\n} REExecContext;\n\nstatic int push_state(REExecContext *s,\n                      uint8_t **capture,\n                      StackInt *stack, size_t stack_len,\n                      const uint8_t *pc, const uint8_t *cptr,\n                      REExecStateEnum type, size_t count)\n{\n    REExecState *rs;\n    uint8_t *new_stack;\n    size_t new_size, i, n;\n    StackInt *stack_buf;\n\n    if (unlikely((s->state_stack_len + 1) > s->state_stack_size)) {\n        /* reallocate the stack */\n        new_size = s->state_stack_size * 3 / 2;\n        if (new_size < 8)\n            new_size = 8;\n        new_stack = lre_realloc(s->opaque, s->state_stack, new_size * s->state_size);\n        if (!new_stack)\n            return -1;\n        s->state_stack_size = new_size;\n        s->state_stack = new_stack;\n    }\n    rs = (REExecState *)(s->state_stack + s->state_stack_len * s->state_size);\n    s->state_stack_len++;\n    rs->type = type;\n    rs->count = count;\n    rs->stack_len = stack_len;\n    rs->cptr = cptr;\n    rs->pc = pc;\n    n = 2 * s->capture_count;\n    for(i = 0; i < n; i++)\n        rs->buf[i] = capture[i];\n    stack_buf = (StackInt *)(rs->buf + n);\n    for(i = 0; i < stack_len; i++)\n        stack_buf[i] = stack[i];\n    return 0;\n}\n\n/* return 1 if match, 0 if not match or -1 if error. */\nstatic intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,\n                                   StackInt *stack, int stack_len,\n                                   const uint8_t *pc, const uint8_t *cptr,\n                                   BOOL no_recurse)\n{\n    int opcode, ret;\n    int cbuf_type;\n    uint32_t val, c;\n    const uint8_t *cbuf_end;\n\n    cbuf_type = s->cbuf_type;\n    cbuf_end = s->cbuf_end;\n\n    for(;;) {\n        //        printf(\"top=%p: pc=%d\\n\", th_list.top, (int)(pc - (bc_buf + RE_HEADER_LEN)));\n        opcode = *pc++;\n        switch(opcode) {\n        case REOP_match:\n            {\n                REExecState *rs;\n                if (no_recurse)\n                    return (intptr_t)cptr;\n                ret = 1;\n                goto recurse;\n            no_match:\n                if (no_recurse)\n                    return 0;\n                ret = 0;\n            recurse:\n                for(;;) {\n                    if (s->state_stack_len == 0)\n                        return ret;\n                    rs = (REExecState *)(s->state_stack +\n                                         (s->state_stack_len - 1) * s->state_size);\n                    if (rs->type == RE_EXEC_STATE_SPLIT) {\n                        if (!ret) {\n                        pop_state:\n                            memcpy(capture, rs->buf,\n                                   sizeof(capture[0]) * 2 * s->capture_count);\n                        pop_state1:\n                            pc = rs->pc;\n                            cptr = rs->cptr;\n                            stack_len = rs->stack_len;\n                            memcpy(stack, rs->buf + 2 * s->capture_count,\n                                   stack_len * sizeof(stack[0]));\n                            s->state_stack_len--;\n                            break;\n                        }\n                    } else if (rs->type == RE_EXEC_STATE_GREEDY_QUANT) {\n                        if (!ret) {\n                            uint32_t char_count, i;\n                            memcpy(capture, rs->buf,\n                                   sizeof(capture[0]) * 2 * s->capture_count);\n                            stack_len = rs->stack_len;\n                            memcpy(stack, rs->buf + 2 * s->capture_count,\n                                   stack_len * sizeof(stack[0]));\n                            pc = rs->pc;\n                            cptr = rs->cptr;\n                            /* go backward */\n                            char_count = get_u32(pc + 12);\n                            for(i = 0; i < char_count; i++) {\n                                PREV_CHAR(cptr, s->cbuf, cbuf_type);\n                            }\n                            pc = (pc + 16) + (int)get_u32(pc);\n                            rs->cptr = cptr;\n                            rs->count--;\n                            if (rs->count == 0) {\n                                s->state_stack_len--;\n                            }\n                            break;\n                        }\n                    } else {\n                        ret = ((rs->type == RE_EXEC_STATE_LOOKAHEAD && ret) ||\n                               (rs->type == RE_EXEC_STATE_NEGATIVE_LOOKAHEAD && !ret));\n                        if (ret) {\n                            /* keep the capture in case of positive lookahead */\n                            if (rs->type == RE_EXEC_STATE_LOOKAHEAD)\n                                goto pop_state1;\n                            else\n                                goto pop_state;\n                        }\n                    }\n                    s->state_stack_len--;\n                }\n            }\n            break;\n        case REOP_char32:\n            val = get_u32(pc);\n            pc += 4;\n            goto test_char;\n        case REOP_char:\n            val = get_u16(pc);\n            pc += 2;\n        test_char:\n            if (cptr >= cbuf_end)\n                goto no_match;\n            GET_CHAR(c, cptr, cbuf_end, cbuf_type);\n            if (s->ignore_case) {\n                c = lre_canonicalize(c, s->is_unicode);\n            }\n            if (val != c)\n                goto no_match;\n            break;\n        case REOP_split_goto_first:\n        case REOP_split_next_first:\n            {\n                const uint8_t *pc1;\n\n                val = get_u32(pc);\n                pc += 4;\n                if (opcode == REOP_split_next_first) {\n                    pc1 = pc + (int)val;\n                } else {\n                    pc1 = pc;\n                    pc = pc + (int)val;\n                }\n                ret = push_state(s, capture, stack, stack_len,\n                                 pc1, cptr, RE_EXEC_STATE_SPLIT, 0);\n                if (ret < 0)\n                    return -1;\n                break;\n            }\n        case REOP_lookahead:\n        case REOP_negative_lookahead:\n            val = get_u32(pc);\n            pc += 4;\n            ret = push_state(s, capture, stack, stack_len,\n                             pc + (int)val, cptr,\n                             RE_EXEC_STATE_LOOKAHEAD + opcode - REOP_lookahead,\n                             0);\n            if (ret < 0)\n                return -1;\n            break;\n\n        case REOP_goto:\n            val = get_u32(pc);\n            pc += 4 + (int)val;\n            break;\n        case REOP_line_start:\n            if (cptr == s->cbuf)\n                break;\n            if (!s->multi_line)\n                goto no_match;\n            PEEK_PREV_CHAR(c, cptr, s->cbuf, cbuf_type);\n            if (!is_line_terminator(c))\n                goto no_match;\n            break;\n        case REOP_line_end:\n            if (cptr == cbuf_end)\n                break;\n            if (!s->multi_line)\n                goto no_match;\n            PEEK_CHAR(c, cptr, cbuf_end, cbuf_type);\n            if (!is_line_terminator(c))\n                goto no_match;\n            break;\n        case REOP_dot:\n            if (cptr == cbuf_end)\n                goto no_match;\n            GET_CHAR(c, cptr, cbuf_end, cbuf_type);\n            if (is_line_terminator(c))\n                goto no_match;\n            break;\n        case REOP_any:\n            if (cptr == cbuf_end)\n                goto no_match;\n            GET_CHAR(c, cptr, cbuf_end, cbuf_type);\n            break;\n        case REOP_save_start:\n        case REOP_save_end:\n            val = *pc++;\n            assert(val < s->capture_count);\n            capture[2 * val + opcode - REOP_save_start] = (uint8_t *)cptr;\n            break;\n        case REOP_save_reset:\n            {\n                uint32_t val2;\n                val = pc[0];\n                val2 = pc[1];\n                pc += 2;\n                assert(val2 < s->capture_count);\n                while (val <= val2) {\n                    capture[2 * val] = NULL;\n                    capture[2 * val + 1] = NULL;\n                    val++;\n                }\n            }\n            break;\n        case REOP_push_i32:\n            val = get_u32(pc);\n            pc += 4;\n            stack[stack_len++] = val;\n            break;\n        case REOP_drop:\n            stack_len--;\n            break;\n        case REOP_loop:\n            val = get_u32(pc);\n            pc += 4;\n            if (--stack[stack_len - 1] != 0) {\n                pc += (int)val;\n            }\n            break;\n        case REOP_push_char_pos:\n            stack[stack_len++] = (uintptr_t)cptr;\n            break;\n        case REOP_check_advance:\n            if (stack[--stack_len] == (uintptr_t)cptr)\n                goto no_match;\n            break;\n        case REOP_word_boundary:\n        case REOP_not_word_boundary:\n            {\n                BOOL v1, v2;\n                /* char before */\n                if (cptr == s->cbuf) {\n                    v1 = FALSE;\n                } else {\n                    PEEK_PREV_CHAR(c, cptr, s->cbuf, cbuf_type);\n                    v1 = is_word_char(c);\n                }\n                /* current char */\n                if (cptr >= cbuf_end) {\n                    v2 = FALSE;\n                } else {\n                    PEEK_CHAR(c, cptr, cbuf_end, cbuf_type);\n                    v2 = is_word_char(c);\n                }\n                if (v1 ^ v2 ^ (REOP_not_word_boundary - opcode))\n                    goto no_match;\n            }\n            break;\n        case REOP_back_reference:\n        case REOP_backward_back_reference:\n            {\n                const uint8_t *cptr1, *cptr1_end, *cptr1_start;\n                uint32_t c1, c2;\n\n                val = *pc++;\n                if (val >= s->capture_count)\n                    goto no_match;\n                cptr1_start = capture[2 * val];\n                cptr1_end = capture[2 * val + 1];\n                if (!cptr1_start || !cptr1_end)\n                    break;\n                if (opcode == REOP_back_reference) {\n                    cptr1 = cptr1_start;\n                    while (cptr1 < cptr1_end) {\n                        if (cptr >= cbuf_end)\n                            goto no_match;\n                        GET_CHAR(c1, cptr1, cptr1_end, cbuf_type);\n                        GET_CHAR(c2, cptr, cbuf_end, cbuf_type);\n                        if (s->ignore_case) {\n                            c1 = lre_canonicalize(c1, s->is_unicode);\n                            c2 = lre_canonicalize(c2, s->is_unicode);\n                        }\n                        if (c1 != c2)\n                            goto no_match;\n                    }\n                } else {\n                    cptr1 = cptr1_end;\n                    while (cptr1 > cptr1_start) {\n                        if (cptr == s->cbuf)\n                            goto no_match;\n                        GET_PREV_CHAR(c1, cptr1, cptr1_start, cbuf_type);\n                        GET_PREV_CHAR(c2, cptr, s->cbuf, cbuf_type);\n                        if (s->ignore_case) {\n                            c1 = lre_canonicalize(c1, s->is_unicode);\n                            c2 = lre_canonicalize(c2, s->is_unicode);\n                        }\n                        if (c1 != c2)\n                            goto no_match;\n                    }\n                }\n            }\n            break;\n        case REOP_range:\n            {\n                int n;\n                uint32_t low, high, idx_min, idx_max, idx;\n\n                n = get_u16(pc); /* n must be >= 1 */\n                pc += 2;\n                if (cptr >= cbuf_end)\n                    goto no_match;\n                GET_CHAR(c, cptr, cbuf_end, cbuf_type);\n                if (s->ignore_case) {\n                    c = lre_canonicalize(c, s->is_unicode);\n                }\n                idx_min = 0;\n                low = get_u16(pc + 0 * 4);\n                if (c < low)\n                    goto no_match;\n                idx_max = n - 1;\n                high = get_u16(pc + idx_max * 4 + 2);\n                /* 0xffff in for last value means +infinity */\n                if (unlikely(c >= 0xffff) && high == 0xffff)\n                    goto range_match;\n                if (c > high)\n                    goto no_match;\n                while (idx_min <= idx_max) {\n                    idx = (idx_min + idx_max) / 2;\n                    low = get_u16(pc + idx * 4);\n                    high = get_u16(pc + idx * 4 + 2);\n                    if (c < low)\n                        idx_max = idx - 1;\n                    else if (c > high)\n                        idx_min = idx + 1;\n                    else\n                        goto range_match;\n                }\n                goto no_match;\n            range_match:\n                pc += 4 * n;\n            }\n            break;\n        case REOP_range32:\n            {\n                int n;\n                uint32_t low, high, idx_min, idx_max, idx;\n\n                n = get_u16(pc); /* n must be >= 1 */\n                pc += 2;\n                if (cptr >= cbuf_end)\n                    goto no_match;\n                GET_CHAR(c, cptr, cbuf_end, cbuf_type);\n                if (s->ignore_case) {\n                    c = lre_canonicalize(c, s->is_unicode);\n                }\n                idx_min = 0;\n                low = get_u32(pc + 0 * 8);\n                if (c < low)\n                    goto no_match;\n                idx_max = n - 1;\n                high = get_u32(pc + idx_max * 8 + 4);\n                if (c > high)\n                    goto no_match;\n                while (idx_min <= idx_max) {\n                    idx = (idx_min + idx_max) / 2;\n                    low = get_u32(pc + idx * 8);\n                    high = get_u32(pc + idx * 8 + 4);\n                    if (c < low)\n                        idx_max = idx - 1;\n                    else if (c > high)\n                        idx_min = idx + 1;\n                    else\n                        goto range32_match;\n                }\n                goto no_match;\n            range32_match:\n                pc += 8 * n;\n            }\n            break;\n        case REOP_prev:\n            /* go to the previous char */\n            if (cptr == s->cbuf)\n                goto no_match;\n            PREV_CHAR(cptr, s->cbuf, cbuf_type);\n            break;\n        case REOP_simple_greedy_quant:\n            {\n                uint32_t next_pos, quant_min, quant_max;\n                size_t q;\n                intptr_t res;\n                const uint8_t *pc1;\n\n                next_pos = get_u32(pc);\n                quant_min = get_u32(pc + 4);\n                quant_max = get_u32(pc + 8);\n                pc += 16;\n                pc1 = pc;\n                pc += (int)next_pos;\n\n                q = 0;\n                for(;;) {\n                    res = lre_exec_backtrack(s, capture, stack, stack_len,\n                                             pc1, cptr, TRUE);\n                    if (res == -1)\n                        return res;\n                    if (!res)\n                        break;\n                    cptr = (uint8_t *)res;\n                    q++;\n                    if (q >= quant_max && quant_max != INT32_MAX)\n                        break;\n                }\n                if (q < quant_min)\n                    goto no_match;\n                if (q > quant_min) {\n                    /* will examine all matches down to quant_min */\n                    ret = push_state(s, capture, stack, stack_len,\n                                     pc1 - 16, cptr,\n                                     RE_EXEC_STATE_GREEDY_QUANT,\n                                     q - quant_min);\n                    if (ret < 0)\n                        return -1;\n                }\n            }\n            break;\n        default:\n            abort();\n        }\n    }\n}\n\n/* Return 1 if match, 0 if not match or -1 if error. cindex is the\n   starting position of the match and must be such as 0 <= cindex <=\n   clen. */\nint lre_exec(uint8_t **capture,\n             const uint8_t *bc_buf, const uint8_t *cbuf, int cindex, int clen,\n             int cbuf_type, void *opaque)\n{\n    REExecContext s_s, *s = &s_s;\n    int re_flags, i, alloca_size, ret;\n    StackInt *stack_buf;\n\n    re_flags = lre_get_flags(bc_buf);\n    s->multi_line = (re_flags & LRE_FLAG_MULTILINE) != 0;\n    s->ignore_case = (re_flags & LRE_FLAG_IGNORECASE) != 0;\n    s->is_unicode = (re_flags & LRE_FLAG_UNICODE) != 0;\n    s->capture_count = bc_buf[RE_HEADER_CAPTURE_COUNT];\n    s->stack_size_max = bc_buf[RE_HEADER_STACK_SIZE];\n    s->cbuf = cbuf;\n    s->cbuf_end = cbuf + (clen << cbuf_type);\n    s->cbuf_type = cbuf_type;\n    if (s->cbuf_type == 1 && s->is_unicode)\n        s->cbuf_type = 2;\n    s->opaque = opaque;\n\n    s->state_size = sizeof(REExecState) +\n        s->capture_count * sizeof(capture[0]) * 2 +\n        s->stack_size_max * sizeof(stack_buf[0]);\n    s->state_stack = NULL;\n    s->state_stack_len = 0;\n    s->state_stack_size = 0;\n\n    for(i = 0; i < s->capture_count * 2; i++)\n        capture[i] = NULL;\n    alloca_size = s->stack_size_max * sizeof(stack_buf[0]);\n    stack_buf = alloca(alloca_size);\n    ret = lre_exec_backtrack(s, capture, stack_buf, 0, bc_buf + RE_HEADER_LEN,\n                             cbuf + (cindex << cbuf_type), FALSE);\n    lre_realloc(s->opaque, s->state_stack, 0);\n    return ret;\n}\n\nint lre_get_capture_count(const uint8_t *bc_buf)\n{\n    return bc_buf[RE_HEADER_CAPTURE_COUNT];\n}\n\nint lre_get_flags(const uint8_t *bc_buf)\n{\n    return bc_buf[RE_HEADER_FLAGS];\n}\n\n/* Return NULL if no group names. Otherwise, return a pointer to\n   'capture_count - 1' zero terminated UTF-8 strings. */\nconst char *lre_get_groupnames(const uint8_t *bc_buf)\n{\n    uint32_t re_bytecode_len;\n    if ((lre_get_flags(bc_buf) & LRE_FLAG_NAMED_GROUPS) == 0)\n        return NULL;\n    re_bytecode_len = get_u32(bc_buf + RE_HEADER_BYTECODE_LEN);\n    return (const char *)(bc_buf + RE_HEADER_LEN + re_bytecode_len);\n}\n\n#ifdef TEST\n\nBOOL lre_check_stack_overflow(void *opaque, size_t alloca_size)\n{\n    return FALSE;\n}\n\nvoid *lre_realloc(void *opaque, void *ptr, size_t size)\n{\n    return realloc(ptr, size);\n}\n\nint main(int argc, char **argv)\n{\n    int len, flags, ret, i;\n    uint8_t *bc;\n    char error_msg[64];\n    uint8_t *capture[CAPTURE_COUNT_MAX * 2];\n    const char *input;\n    int input_len, capture_count;\n\n    if (argc < 4) {\n        printf(\"usage: %s regexp flags input\\n\", argv[0]);\n        return 1;\n    }\n    flags = atoi(argv[2]);\n    bc = lre_compile(&len, error_msg, sizeof(error_msg), argv[1],\n                     strlen(argv[1]), flags, NULL);\n    if (!bc) {\n        fprintf(stderr, \"error: %s\\n\", error_msg);\n        exit(1);\n    }\n\n    input = argv[3];\n    input_len = strlen(input);\n\n    ret = lre_exec(capture, bc, (uint8_t *)input, 0, input_len, 0, NULL);\n    printf(\"ret=%d\\n\", ret);\n    if (ret == 1) {\n        capture_count = lre_get_capture_count(bc);\n        for(i = 0; i < 2 * capture_count; i++) {\n            uint8_t *ptr;\n            ptr = capture[i];\n            printf(\"%d: \", i);\n            if (!ptr)\n                printf(\"<nil>\");\n            else\n                printf(\"%u\", (int)(ptr - (uint8_t *)input));\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n#endif\n"
        },
        {
          "name": "libregexp.h",
          "type": "blob",
          "size": 2.3154296875,
          "content": "/*\n * Regular Expression Engine\n *\n * Copyright (c) 2017-2018 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#ifndef LIBREGEXP_H\n#define LIBREGEXP_H\n\n#include <stddef.h>\n#include <stdint.h>\n\n#define LRE_FLAG_GLOBAL     (1 << 0)\n#define LRE_FLAG_IGNORECASE (1 << 1)\n#define LRE_FLAG_MULTILINE  (1 << 2)\n#define LRE_FLAG_DOTALL     (1 << 3)\n#define LRE_FLAG_UNICODE    (1 << 4)\n#define LRE_FLAG_STICKY     (1 << 5)\n#define LRE_FLAG_INDICES    (1 << 6) /* Unused by libregexp, just recorded. */\n#define LRE_FLAG_NAMED_GROUPS (1 << 7) /* named groups are present in the regexp */\n\nuint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,\n                     const char *buf, size_t buf_len, int re_flags,\n                     void *opaque);\nint lre_get_capture_count(const uint8_t *bc_buf);\nint lre_get_flags(const uint8_t *bc_buf);\nconst char *lre_get_groupnames(const uint8_t *bc_buf);\nint lre_exec(uint8_t **capture,\n             const uint8_t *bc_buf, const uint8_t *cbuf, int cindex, int clen,\n             int cbuf_type, void *opaque);\n\nint lre_parse_escape(const uint8_t **pp, int allow_utf16);\n\n/* must be provided by the user, return non zero if overflow */\nint lre_check_stack_overflow(void *opaque, size_t alloca_size);\nvoid *lre_realloc(void *opaque, void *ptr, size_t size);\n\n#endif /* LIBREGEXP_H */\n"
        },
        {
          "name": "libunicode-table.h",
          "type": "blob",
          "size": 215.39453125,
          "content": "/* Compressed unicode tables */\n/* Automatically generated file - do not edit */\n\n#include <stdint.h>\n\nstatic const uint32_t case_conv_table1[370] = {\n    0x00209a30, 0x00309a00, 0x005a8173, 0x00601730,\n    0x006c0730, 0x006f81b3, 0x00701700, 0x007c0700,\n    0x007f8100, 0x00803040, 0x009801c3, 0x00988190,\n    0x00990640, 0x009c9040, 0x00a481b4, 0x00a52e40,\n    0x00bc0130, 0x00bc8640, 0x00bf8170, 0x00c00100,\n    0x00c08130, 0x00c10440, 0x00c30130, 0x00c38240,\n    0x00c48230, 0x00c58240, 0x00c70130, 0x00c78130,\n    0x00c80130, 0x00c88240, 0x00c98130, 0x00ca0130,\n    0x00ca8100, 0x00cb0130, 0x00cb8130, 0x00cc0240,\n    0x00cd0100, 0x00ce0130, 0x00ce8130, 0x00cf0100,\n    0x00cf8130, 0x00d00640, 0x00d30130, 0x00d38240,\n    0x00d48130, 0x00d60240, 0x00d70130, 0x00d78240,\n    0x00d88230, 0x00d98440, 0x00db8130, 0x00dc0240,\n    0x00de0240, 0x00df8100, 0x00e20350, 0x00e38350,\n    0x00e50350, 0x00e69040, 0x00ee8100, 0x00ef1240,\n    0x00f801b4, 0x00f88350, 0x00fa0240, 0x00fb0130,\n    0x00fb8130, 0x00fc2840, 0x01100130, 0x01111240,\n    0x011d0131, 0x011d8240, 0x011e8130, 0x011f0131,\n    0x011f8201, 0x01208240, 0x01218130, 0x01220130,\n    0x01228130, 0x01230a40, 0x01280101, 0x01288101,\n    0x01290101, 0x01298100, 0x012a0100, 0x012b0200,\n    0x012c8100, 0x012d8100, 0x012e0101, 0x01300100,\n    0x01308101, 0x01318100, 0x01328101, 0x01330101,\n    0x01340100, 0x01348100, 0x01350101, 0x01358101,\n    0x01360101, 0x01378100, 0x01388101, 0x01390100,\n    0x013a8100, 0x013e8101, 0x01400100, 0x01410101,\n    0x01418100, 0x01438101, 0x01440100, 0x01448100,\n    0x01450200, 0x01460100, 0x01490100, 0x014e8101,\n    0x014f0101, 0x01a28173, 0x01b80440, 0x01bb0240,\n    0x01bd8300, 0x01bf8130, 0x01c30130, 0x01c40330,\n    0x01c60130, 0x01c70230, 0x01c801d0, 0x01c89130,\n    0x01d18930, 0x01d60100, 0x01d68300, 0x01d801d3,\n    0x01d89100, 0x01e10173, 0x01e18900, 0x01e60100,\n    0x01e68200, 0x01e78130, 0x01e80173, 0x01e88173,\n    0x01ea8173, 0x01eb0173, 0x01eb8100, 0x01ec1840,\n    0x01f80173, 0x01f88173, 0x01f90100, 0x01f98100,\n    0x01fa01a0, 0x01fa8173, 0x01fb8240, 0x01fc8130,\n    0x01fd0240, 0x01fe8330, 0x02001030, 0x02082030,\n    0x02182000, 0x02281000, 0x02302240, 0x02453640,\n    0x02600130, 0x02608e40, 0x02678100, 0x02686040,\n    0x0298a630, 0x02b0a600, 0x02c381b5, 0x08502631,\n    0x08638131, 0x08668131, 0x08682b00, 0x087e8300,\n    0x09d05011, 0x09f80610, 0x09fc0620, 0x0e400174,\n    0x0e408174, 0x0e410174, 0x0e418174, 0x0e420174,\n    0x0e428174, 0x0e430174, 0x0e438180, 0x0e440180,\n    0x0e482b30, 0x0e5e8330, 0x0ebc8101, 0x0ebe8101,\n    0x0ec70101, 0x0f007e40, 0x0f3f1840, 0x0f4b01b5,\n    0x0f4b81b6, 0x0f4c01b6, 0x0f4c81b6, 0x0f4d01b7,\n    0x0f4d8180, 0x0f4f0130, 0x0f506040, 0x0f800800,\n    0x0f840830, 0x0f880600, 0x0f8c0630, 0x0f900800,\n    0x0f940830, 0x0f980800, 0x0f9c0830, 0x0fa00600,\n    0x0fa40630, 0x0fa801b0, 0x0fa88100, 0x0fa901d3,\n    0x0fa98100, 0x0faa01d3, 0x0faa8100, 0x0fab01d3,\n    0x0fab8100, 0x0fac8130, 0x0fad8130, 0x0fae8130,\n    0x0faf8130, 0x0fb00800, 0x0fb40830, 0x0fb80200,\n    0x0fb90400, 0x0fbb0200, 0x0fbc0201, 0x0fbd0201,\n    0x0fbe0201, 0x0fc008b7, 0x0fc40867, 0x0fc808b8,\n    0x0fcc0868, 0x0fd008b8, 0x0fd40868, 0x0fd80200,\n    0x0fd901b9, 0x0fd981b1, 0x0fda01b9, 0x0fdb01b1,\n    0x0fdb81d7, 0x0fdc0230, 0x0fdd0230, 0x0fde0161,\n    0x0fdf0173, 0x0fe101b9, 0x0fe181b2, 0x0fe201ba,\n    0x0fe301b2, 0x0fe381d8, 0x0fe40430, 0x0fe60162,\n    0x0fe80200, 0x0fe901d0, 0x0fe981d0, 0x0feb01b0,\n    0x0feb81d0, 0x0fec0230, 0x0fed0230, 0x0ff00201,\n    0x0ff101d3, 0x0ff181d3, 0x0ff201ba, 0x0ff28101,\n    0x0ff301b0, 0x0ff381d3, 0x0ff40230, 0x0ff50230,\n    0x0ff60131, 0x0ff901ba, 0x0ff981b2, 0x0ffa01bb,\n    0x0ffb01b2, 0x0ffb81d9, 0x0ffc0230, 0x0ffd0230,\n    0x0ffe0162, 0x109301a0, 0x109501a0, 0x109581a0,\n    0x10990131, 0x10a70101, 0x10b01031, 0x10b81001,\n    0x10c18240, 0x125b1a31, 0x12681a01, 0x16003031,\n    0x16183001, 0x16300240, 0x16310130, 0x16318130,\n    0x16320130, 0x16328100, 0x16330100, 0x16338640,\n    0x16368130, 0x16370130, 0x16378130, 0x16380130,\n    0x16390240, 0x163a8240, 0x163f0230, 0x16406440,\n    0x16758440, 0x16790240, 0x16802600, 0x16938100,\n    0x16968100, 0x53202e40, 0x53401c40, 0x53910e40,\n    0x53993e40, 0x53bc8440, 0x53be8130, 0x53bf0a40,\n    0x53c58240, 0x53c68130, 0x53c80440, 0x53ca0101,\n    0x53cb1440, 0x53d50130, 0x53d58130, 0x53d60130,\n    0x53d68130, 0x53d70130, 0x53d80130, 0x53d88130,\n    0x53d90130, 0x53d98131, 0x53da1040, 0x53e20131,\n    0x53e28130, 0x53e30130, 0x53e38440, 0x53e80240,\n    0x53eb0440, 0x53fa8240, 0x55a98101, 0x55b85020,\n    0x7d8001b2, 0x7d8081b2, 0x7d8101b2, 0x7d8181da,\n    0x7d8201da, 0x7d8281b3, 0x7d8301b3, 0x7d8981bb,\n    0x7d8a01bb, 0x7d8a81bb, 0x7d8b01bc, 0x7d8b81bb,\n    0x7f909a31, 0x7fa09a01, 0x82002831, 0x82142801,\n    0x82582431, 0x826c2401, 0x82b80b31, 0x82be0f31,\n    0x82c60731, 0x82ca0231, 0x82cb8b01, 0x82d18f01,\n    0x82d98701, 0x82dd8201, 0x86403331, 0x86603301,\n    0x8c502031, 0x8c602001, 0xb7202031, 0xb7302001,\n    0xf4802231, 0xf4912201,\n};\n\nstatic const uint8_t case_conv_table2[370] = {\n    0x01, 0x00, 0x9c, 0x06, 0x07, 0x4d, 0x03, 0x04,\n    0x10, 0x00, 0x8f, 0x0b, 0x00, 0x00, 0x11, 0x00,\n    0x08, 0x00, 0x53, 0x4a, 0x51, 0x00, 0x52, 0x00,\n    0x53, 0x00, 0x3a, 0x54, 0x55, 0x00, 0x57, 0x59,\n    0x3f, 0x5d, 0x5c, 0x00, 0x46, 0x61, 0x63, 0x42,\n    0x64, 0x00, 0x66, 0x00, 0x68, 0x00, 0x6a, 0x00,\n    0x6c, 0x00, 0x6e, 0x00, 0x00, 0x40, 0x00, 0x00,\n    0x00, 0x00, 0x1a, 0x00, 0x93, 0x00, 0x00, 0x20,\n    0x35, 0x00, 0x27, 0x00, 0x21, 0x00, 0x24, 0x22,\n    0x2a, 0x00, 0x13, 0x6b, 0x6d, 0x00, 0x26, 0x24,\n    0x27, 0x14, 0x16, 0x18, 0x1b, 0x1c, 0x3e, 0x1e,\n    0x3f, 0x1f, 0x39, 0x3d, 0x22, 0x21, 0x41, 0x1e,\n    0x40, 0x25, 0x25, 0x26, 0x28, 0x20, 0x2a, 0x48,\n    0x2c, 0x43, 0x2e, 0x4b, 0x30, 0x4c, 0x32, 0x44,\n    0x42, 0x99, 0x00, 0x00, 0x95, 0x8f, 0x7d, 0x7e,\n    0x83, 0x84, 0x12, 0x80, 0x82, 0x76, 0x77, 0x12,\n    0x7b, 0xa3, 0x7c, 0x78, 0x79, 0x8a, 0x92, 0x98,\n    0xa6, 0xa0, 0x85, 0x00, 0x9a, 0xa1, 0x93, 0x75,\n    0x33, 0x95, 0x00, 0x8e, 0x00, 0x74, 0x99, 0x98,\n    0x97, 0x96, 0x00, 0x00, 0x9e, 0x00, 0x9c, 0x00,\n    0xa1, 0xa0, 0x15, 0x2e, 0x2f, 0x30, 0xb4, 0xb5,\n    0x4f, 0xaa, 0xa9, 0x12, 0x14, 0x1e, 0x21, 0x22,\n    0x22, 0x2a, 0x34, 0x35, 0xa6, 0xa7, 0x36, 0x1f,\n    0x49, 0x00, 0x00, 0x97, 0x01, 0x5a, 0xda, 0x1d,\n    0x36, 0x05, 0x00, 0xc4, 0xc3, 0xc6, 0xc5, 0xc8,\n    0xc7, 0xca, 0xc9, 0xcc, 0xcb, 0xc4, 0xd5, 0x45,\n    0xd6, 0x42, 0xd7, 0x46, 0xd8, 0xce, 0xd0, 0xd2,\n    0xd4, 0xda, 0xd9, 0xee, 0xf6, 0xfe, 0x0e, 0x07,\n    0x0f, 0x80, 0x9f, 0x00, 0x21, 0x80, 0xa3, 0xed,\n    0x00, 0xc0, 0x40, 0xc6, 0x60, 0xe7, 0xdb, 0xe6,\n    0x99, 0xc0, 0x00, 0x00, 0x06, 0x60, 0xdc, 0x29,\n    0xfd, 0x15, 0x12, 0x06, 0x16, 0xf8, 0xdd, 0x06,\n    0x15, 0x12, 0x84, 0x08, 0xc6, 0x16, 0xff, 0xdf,\n    0x03, 0xc0, 0x40, 0x00, 0x46, 0x60, 0xde, 0xe0,\n    0x6d, 0x37, 0x38, 0x39, 0x15, 0x14, 0x17, 0x16,\n    0x00, 0x1a, 0x19, 0x1c, 0x1b, 0x00, 0x5f, 0xb7,\n    0x65, 0x44, 0x47, 0x00, 0x4f, 0x62, 0x4e, 0x50,\n    0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0xa3, 0xa4,\n    0xa5, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb6, 0x00,\n    0x00, 0x5a, 0x00, 0x47, 0x00, 0x5b, 0x56, 0x58,\n    0x60, 0x5e, 0x70, 0x69, 0x6f, 0x4e, 0x00, 0x3b,\n    0x67, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x45, 0xa8,\n    0x8a, 0x8b, 0x8c, 0xab, 0xac, 0x58, 0x58, 0xaf,\n    0x94, 0xb0, 0x6f, 0xb2, 0x5d, 0x5c, 0x5f, 0x5e,\n    0x61, 0x60, 0x66, 0x67, 0x68, 0x69, 0x62, 0x63,\n    0x64, 0x65, 0x6b, 0x6a, 0x6d, 0x6c, 0x6f, 0x6e,\n    0x71, 0x70,\n};\n\nstatic const uint16_t case_conv_ext[58] = {\n    0x0399, 0x0308, 0x0301, 0x03a5, 0x0313, 0x0300, 0x0342, 0x0391,\n    0x0397, 0x03a9, 0x0046, 0x0049, 0x004c, 0x0053, 0x0069, 0x0307,\n    0x02bc, 0x004e, 0x004a, 0x030c, 0x0535, 0x0552, 0x0048, 0x0331,\n    0x0054, 0x0057, 0x030a, 0x0059, 0x0041, 0x02be, 0x1f08, 0x1f80,\n    0x1f28, 0x1f90, 0x1f68, 0x1fa0, 0x1fba, 0x0386, 0x1fb3, 0x1fca,\n    0x0389, 0x1fc3, 0x03a1, 0x1ffa, 0x038f, 0x1ff3, 0x0544, 0x0546,\n    0x053b, 0x054e, 0x053d, 0x03b8, 0x0462, 0xa64a, 0x1e60, 0x03c9,\n    0x006b, 0x00e5,\n};\n\nstatic const uint8_t unicode_prop_Cased1_table[196] = {\n    0x40, 0xa9, 0x80, 0x8e, 0x80, 0xfc, 0x80, 0xd3,\n    0x80, 0x8c, 0x80, 0x8d, 0x81, 0x8d, 0x02, 0x80,\n    0xe1, 0x80, 0x91, 0x85, 0x9a, 0x01, 0x00, 0x01,\n    0x11, 0x00, 0x01, 0x04, 0x08, 0x01, 0x08, 0x30,\n    0x08, 0x01, 0x15, 0x20, 0x00, 0x39, 0x99, 0x31,\n    0x9d, 0x84, 0x40, 0x94, 0x80, 0xd6, 0x82, 0xa6,\n    0x80, 0x41, 0x62, 0x80, 0xa6, 0x80, 0x4b, 0x72,\n    0x80, 0x4c, 0x02, 0xf8, 0x02, 0x80, 0x8f, 0x80,\n    0xb0, 0x40, 0xdb, 0x08, 0x80, 0x41, 0xd0, 0x80,\n    0x8c, 0x80, 0x8f, 0x8c, 0xe4, 0x03, 0x01, 0x89,\n    0x00, 0x14, 0x28, 0x10, 0x11, 0x02, 0x01, 0x18,\n    0x0b, 0x24, 0x4b, 0x26, 0x01, 0x01, 0x86, 0xe5,\n    0x80, 0x60, 0x79, 0xb6, 0x81, 0x40, 0x91, 0x81,\n    0xbd, 0x88, 0x94, 0x05, 0x80, 0x98, 0x80, 0xa2,\n    0x00, 0x80, 0x9b, 0x12, 0x82, 0x43, 0x34, 0xa2,\n    0x06, 0x80, 0x8d, 0x60, 0x5c, 0x15, 0x01, 0x10,\n    0xa9, 0x80, 0x88, 0x60, 0xcc, 0x44, 0xd4, 0x80,\n    0xc6, 0x01, 0x08, 0x09, 0x0b, 0x80, 0x8b, 0x00,\n    0x06, 0x80, 0xc0, 0x03, 0x0f, 0x06, 0x80, 0x9b,\n    0x03, 0x04, 0x00, 0x16, 0x80, 0x41, 0x53, 0x81,\n    0x98, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,\n    0x9e, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,\n    0x9e, 0x80, 0x98, 0x07, 0x47, 0x33, 0x89, 0x80,\n    0x93, 0x2d, 0x41, 0x04, 0xbd, 0x50, 0xc1, 0x99,\n    0x85, 0x99, 0x85, 0x99,\n};\n\nstatic const uint8_t unicode_prop_Cased1_index[21] = {\n    0xb9, 0x02, 0xe0,  //  002B9 at 39\n    0xc0, 0x1d, 0x20,  //  01DC0 at 65\n    0xe5, 0x2c, 0x20,  //  02CE5 at 97\n    0xb1, 0x07, 0x21,  //  107B1 at 129\n    0xc1, 0xd6, 0x21,  //  1D6C1 at 161\n    0x4a, 0xf1, 0x01,  //  1F14A at 192\n    0x8a, 0xf1, 0x01,  //  1F18A at 224 (upper bound)\n};\n\nstatic const uint8_t unicode_prop_Case_Ignorable_table[737] = {\n    0xa6, 0x05, 0x80, 0x8a, 0x80, 0xa2, 0x00, 0x80,\n    0xc6, 0x03, 0x00, 0x03, 0x01, 0x81, 0x41, 0xf6,\n    0x40, 0xbf, 0x19, 0x18, 0x88, 0x08, 0x80, 0x40,\n    0xfa, 0x86, 0x40, 0xce, 0x04, 0x80, 0xb0, 0xac,\n    0x00, 0x01, 0x01, 0x00, 0xab, 0x80, 0x8a, 0x85,\n    0x89, 0x8a, 0x00, 0xa2, 0x80, 0x89, 0x94, 0x8f,\n    0x80, 0xe4, 0x38, 0x89, 0x03, 0xa0, 0x00, 0x80,\n    0x9d, 0x9a, 0xda, 0x8a, 0xb9, 0x8a, 0x18, 0x08,\n    0x97, 0x97, 0xaa, 0x82, 0xab, 0x06, 0x0d, 0x87,\n    0xa8, 0xb9, 0xb6, 0x00, 0x03, 0x3b, 0x02, 0x86,\n    0x89, 0x81, 0x8c, 0x80, 0x8e, 0x80, 0xb9, 0x03,\n    0x1f, 0x80, 0x93, 0x81, 0x99, 0x01, 0x81, 0xb8,\n    0x03, 0x0b, 0x09, 0x12, 0x80, 0x9d, 0x0a, 0x80,\n    0x8a, 0x81, 0xb8, 0x03, 0x20, 0x0b, 0x80, 0x93,\n    0x81, 0x95, 0x28, 0x80, 0xb9, 0x01, 0x00, 0x1f,\n    0x06, 0x81, 0x8a, 0x81, 0x9d, 0x80, 0xbc, 0x80,\n    0x8b, 0x80, 0xb1, 0x02, 0x80, 0xb6, 0x00, 0x14,\n    0x10, 0x1e, 0x81, 0x8a, 0x81, 0x9c, 0x80, 0xb9,\n    0x01, 0x05, 0x04, 0x81, 0x93, 0x81, 0x9b, 0x81,\n    0xb8, 0x0b, 0x1f, 0x80, 0x93, 0x81, 0x9c, 0x80,\n    0xc7, 0x06, 0x10, 0x80, 0xd9, 0x01, 0x86, 0x8a,\n    0x88, 0xe1, 0x01, 0x88, 0x88, 0x00, 0x86, 0xc8,\n    0x81, 0x9a, 0x00, 0x00, 0x80, 0xb6, 0x8d, 0x04,\n    0x01, 0x84, 0x8a, 0x80, 0xa3, 0x88, 0x80, 0xe5,\n    0x18, 0x28, 0x09, 0x81, 0x98, 0x0b, 0x82, 0x8f,\n    0x83, 0x8c, 0x01, 0x0d, 0x80, 0x8e, 0x80, 0xdd,\n    0x80, 0x42, 0x5f, 0x82, 0x43, 0xb1, 0x82, 0x9c,\n    0x81, 0x9d, 0x81, 0x9d, 0x81, 0xbf, 0x08, 0x37,\n    0x01, 0x8a, 0x10, 0x20, 0xac, 0x84, 0xb2, 0x80,\n    0xc0, 0x81, 0xa1, 0x80, 0xf5, 0x13, 0x81, 0x88,\n    0x05, 0x82, 0x40, 0xda, 0x09, 0x80, 0xb9, 0x00,\n    0x30, 0x00, 0x01, 0x3d, 0x89, 0x08, 0xa6, 0x07,\n    0x9e, 0xb0, 0x83, 0xaf, 0x00, 0x20, 0x04, 0x80,\n    0xa7, 0x88, 0x8b, 0x81, 0x9f, 0x19, 0x08, 0x82,\n    0xb7, 0x00, 0x0a, 0x00, 0x82, 0xb9, 0x39, 0x81,\n    0xbf, 0x85, 0xd1, 0x10, 0x8c, 0x06, 0x18, 0x28,\n    0x11, 0xb1, 0xbe, 0x8c, 0x80, 0xa1, 0xe4, 0x41,\n    0xbc, 0x00, 0x82, 0x8a, 0x82, 0x8c, 0x82, 0x8c,\n    0x82, 0x8c, 0x81, 0x8b, 0x27, 0x81, 0x89, 0x01,\n    0x01, 0x84, 0xb0, 0x20, 0x89, 0x00, 0x8c, 0x80,\n    0x8f, 0x8c, 0xb2, 0xa0, 0x4b, 0x8a, 0x81, 0xf0,\n    0x82, 0xfc, 0x80, 0x8e, 0x80, 0xdf, 0x9f, 0xae,\n    0x80, 0x41, 0xd4, 0x80, 0xa3, 0x1a, 0x24, 0x80,\n    0xdc, 0x85, 0xdc, 0x82, 0x60, 0x6f, 0x15, 0x80,\n    0x44, 0xe1, 0x85, 0x41, 0x0d, 0x80, 0xe1, 0x18,\n    0x89, 0x00, 0x9b, 0x83, 0xcf, 0x81, 0x8d, 0xa1,\n    0xcd, 0x80, 0x96, 0x82, 0xe6, 0x12, 0x0f, 0x02,\n    0x03, 0x80, 0x98, 0x0c, 0x80, 0x40, 0x96, 0x81,\n    0x99, 0x91, 0x8c, 0x80, 0xa5, 0x87, 0x98, 0x8a,\n    0xad, 0x82, 0xaf, 0x01, 0x19, 0x81, 0x90, 0x80,\n    0x94, 0x81, 0xc1, 0x29, 0x09, 0x81, 0x8b, 0x07,\n    0x80, 0xa2, 0x80, 0x8a, 0x80, 0xb2, 0x00, 0x11,\n    0x0c, 0x08, 0x80, 0x9a, 0x80, 0x8d, 0x0c, 0x08,\n    0x80, 0xe3, 0x84, 0x88, 0x82, 0xf8, 0x01, 0x03,\n    0x80, 0x60, 0x4f, 0x2f, 0x80, 0x40, 0x92, 0x90,\n    0x42, 0x3c, 0x8f, 0x10, 0x8b, 0x8f, 0xa1, 0x01,\n    0x80, 0x40, 0xa8, 0x06, 0x05, 0x80, 0x8a, 0x80,\n    0xa2, 0x00, 0x80, 0xae, 0x80, 0xac, 0x81, 0xc2,\n    0x80, 0x94, 0x82, 0x42, 0x00, 0x80, 0x40, 0xe1,\n    0x80, 0x40, 0x94, 0x84, 0x44, 0x04, 0x28, 0xa9,\n    0x80, 0x88, 0x42, 0x45, 0x10, 0x0c, 0x83, 0xa7,\n    0x13, 0x80, 0x40, 0xa4, 0x81, 0x42, 0x3c, 0x83,\n    0x41, 0x82, 0x81, 0xcf, 0x82, 0xc5, 0x8a, 0xb0,\n    0x83, 0xfa, 0x80, 0xb5, 0x8e, 0xa8, 0x01, 0x81,\n    0x89, 0x82, 0xb0, 0x19, 0x09, 0x03, 0x80, 0x89,\n    0x80, 0xb1, 0x82, 0xa3, 0x20, 0x87, 0xbd, 0x80,\n    0x8b, 0x81, 0xb3, 0x88, 0x89, 0x19, 0x80, 0xde,\n    0x11, 0x00, 0x0d, 0x01, 0x80, 0x40, 0x9c, 0x02,\n    0x87, 0x94, 0x81, 0xb8, 0x0a, 0x80, 0xa4, 0x32,\n    0x84, 0x40, 0xc2, 0x39, 0x10, 0x80, 0x96, 0x80,\n    0xd3, 0x28, 0x03, 0x08, 0x81, 0x40, 0xed, 0x1d,\n    0x08, 0x81, 0x9a, 0x81, 0xd4, 0x39, 0x00, 0x81,\n    0xe9, 0x00, 0x01, 0x28, 0x80, 0xe4, 0x11, 0x18,\n    0x84, 0x41, 0x02, 0x88, 0x01, 0x40, 0xff, 0x08,\n    0x03, 0x80, 0x40, 0x8f, 0x19, 0x0b, 0x80, 0x9f,\n    0x89, 0xa7, 0x29, 0x1f, 0x80, 0x88, 0x29, 0x82,\n    0xad, 0x8c, 0x01, 0x41, 0x95, 0x30, 0x28, 0x80,\n    0xd1, 0x95, 0x0e, 0x01, 0x01, 0xf9, 0x2a, 0x00,\n    0x08, 0x30, 0x80, 0xc7, 0x0a, 0x00, 0x80, 0x41,\n    0x5a, 0x81, 0x8a, 0x81, 0xb3, 0x24, 0x00, 0x80,\n    0x54, 0xec, 0x90, 0x85, 0x8e, 0x60, 0x36, 0x99,\n    0x84, 0xba, 0x86, 0x88, 0x83, 0x44, 0x0a, 0x80,\n    0xbe, 0x90, 0xbf, 0x08, 0x81, 0x60, 0x40, 0x0a,\n    0x18, 0x30, 0x81, 0x4c, 0x9d, 0x08, 0x83, 0x52,\n    0x5b, 0xad, 0x81, 0x96, 0x42, 0x1f, 0x82, 0x88,\n    0x8f, 0x0e, 0x9d, 0x83, 0x40, 0x93, 0x82, 0x47,\n    0xba, 0xb6, 0x83, 0xb1, 0x38, 0x8d, 0x80, 0x95,\n    0x20, 0x8e, 0x45, 0x4f, 0x30, 0x90, 0x0e, 0x01,\n    0x04, 0x84, 0xbd, 0xa0, 0x80, 0x40, 0x9f, 0x8d,\n    0x41, 0x6f, 0x80, 0xbc, 0x83, 0x41, 0xfa, 0x84,\n    0x43, 0xdf, 0x86, 0xec, 0x87, 0x4a, 0xae, 0x84,\n    0x6c, 0x0c, 0x00, 0x80, 0x9d, 0xdf, 0xff, 0x40,\n    0xef,\n};\n\nstatic const uint8_t unicode_prop_Case_Ignorable_index[69] = {\n    0xbe, 0x05, 0x00,  //  005BE at 32\n    0xfe, 0x07, 0x00,  //  007FE at 64\n    0x52, 0x0a, 0xa0,  //  00A52 at 101\n    0xc1, 0x0b, 0x00,  //  00BC1 at 128\n    0x82, 0x0d, 0x00,  //  00D82 at 160\n    0x3f, 0x10, 0x80,  //  0103F at 196\n    0xd4, 0x17, 0x40,  //  017D4 at 226\n    0xcf, 0x1a, 0x20,  //  01ACF at 257\n    0xf5, 0x1c, 0x00,  //  01CF5 at 288\n    0x80, 0x20, 0x00,  //  02080 at 320\n    0x16, 0xa0, 0x00,  //  0A016 at 352\n    0xc6, 0xa8, 0x00,  //  0A8C6 at 384\n    0xc2, 0xaa, 0x60,  //  0AAC2 at 419\n    0x56, 0xfe, 0x20,  //  0FE56 at 449\n    0xb1, 0x07, 0x01,  //  107B1 at 480\n    0x75, 0x10, 0x01,  //  11075 at 512\n    0xeb, 0x12, 0x21,  //  112EB at 545\n    0x41, 0x16, 0x01,  //  11641 at 576\n    0x5c, 0x1a, 0x01,  //  11A5C at 608\n    0x43, 0x1f, 0x01,  //  11F43 at 640\n    0x2e, 0xcf, 0x41,  //  1CF2E at 674\n    0x25, 0xe0, 0x01,  //  1E025 at 704\n    0xf0, 0x01, 0x0e,  //  E01F0 at 736 (upper bound)\n};\n\nstatic const uint8_t unicode_prop_ID_Start_table[1100] = {\n    0xc0, 0x99, 0x85, 0x99, 0xae, 0x80, 0x89, 0x03,\n    0x04, 0x96, 0x80, 0x9e, 0x80, 0x41, 0xc9, 0x83,\n    0x8b, 0x8d, 0x26, 0x00, 0x80, 0x40, 0x80, 0x20,\n    0x09, 0x18, 0x05, 0x00, 0x10, 0x00, 0x93, 0x80,\n    0xd2, 0x80, 0x40, 0x8a, 0x87, 0x40, 0xa5, 0x80,\n    0xa5, 0x08, 0x85, 0xa8, 0xc6, 0x9a, 0x1b, 0xac,\n    0xaa, 0xa2, 0x08, 0xe2, 0x00, 0x8e, 0x0e, 0x81,\n    0x89, 0x11, 0x80, 0x8f, 0x00, 0x9d, 0x9c, 0xd8,\n    0x8a, 0x80, 0x97, 0xa0, 0x88, 0x0b, 0x04, 0x95,\n    0x18, 0x88, 0x02, 0x80, 0x96, 0x98, 0x86, 0x8a,\n    0x84, 0x97, 0x05, 0x90, 0xa9, 0xb9, 0xb5, 0x10,\n    0x91, 0x06, 0x89, 0x8e, 0x8f, 0x1f, 0x09, 0x81,\n    0x95, 0x06, 0x00, 0x13, 0x10, 0x8f, 0x80, 0x8c,\n    0x08, 0x82, 0x8d, 0x81, 0x89, 0x07, 0x2b, 0x09,\n    0x95, 0x06, 0x01, 0x01, 0x01, 0x9e, 0x18, 0x80,\n    0x92, 0x82, 0x8f, 0x88, 0x02, 0x80, 0x95, 0x06,\n    0x01, 0x04, 0x10, 0x91, 0x80, 0x8e, 0x81, 0x96,\n    0x80, 0x8a, 0x39, 0x09, 0x95, 0x06, 0x01, 0x04,\n    0x10, 0x9d, 0x08, 0x82, 0x8e, 0x80, 0x90, 0x00,\n    0x2a, 0x10, 0x1a, 0x08, 0x00, 0x0a, 0x0a, 0x12,\n    0x8b, 0x95, 0x80, 0xb3, 0x38, 0x10, 0x96, 0x80,\n    0x8f, 0x10, 0x99, 0x11, 0x01, 0x81, 0x9d, 0x03,\n    0x38, 0x10, 0x96, 0x80, 0x89, 0x04, 0x10, 0x9e,\n    0x08, 0x81, 0x8e, 0x81, 0x90, 0x88, 0x02, 0x80,\n    0xa8, 0x08, 0x8f, 0x04, 0x17, 0x82, 0x97, 0x2c,\n    0x91, 0x82, 0x97, 0x80, 0x88, 0x00, 0x0e, 0xb9,\n    0xaf, 0x01, 0x8b, 0x86, 0xb9, 0x08, 0x00, 0x20,\n    0x97, 0x00, 0x80, 0x89, 0x01, 0x88, 0x01, 0x20,\n    0x80, 0x94, 0x83, 0x9f, 0x80, 0xbe, 0x38, 0xa3,\n    0x9a, 0x84, 0xf2, 0xaa, 0x93, 0x80, 0x8f, 0x2b,\n    0x1a, 0x02, 0x0e, 0x13, 0x8c, 0x8b, 0x80, 0x90,\n    0xa5, 0x00, 0x20, 0x81, 0xaa, 0x80, 0x41, 0x4c,\n    0x03, 0x0e, 0x00, 0x03, 0x81, 0xa8, 0x03, 0x81,\n    0xa0, 0x03, 0x0e, 0x00, 0x03, 0x81, 0x8e, 0x80,\n    0xb8, 0x03, 0x81, 0xc2, 0xa4, 0x8f, 0x8f, 0xd5,\n    0x0d, 0x82, 0x42, 0x6b, 0x81, 0x90, 0x80, 0x99,\n    0x84, 0xca, 0x82, 0x8a, 0x86, 0x91, 0x8c, 0x92,\n    0x8d, 0x91, 0x8d, 0x8c, 0x02, 0x8e, 0xb3, 0xa2,\n    0x03, 0x80, 0xc2, 0xd8, 0x86, 0xa8, 0x00, 0x84,\n    0xc5, 0x89, 0x9e, 0xb0, 0x9d, 0x0c, 0x8a, 0xab,\n    0x83, 0x99, 0xb5, 0x96, 0x88, 0xb4, 0xd1, 0x80,\n    0xdc, 0xae, 0x90, 0x87, 0xb5, 0x9d, 0x8c, 0x81,\n    0x89, 0xab, 0x99, 0xa3, 0xa8, 0x82, 0x89, 0xa3,\n    0x81, 0x88, 0x86, 0xaa, 0x0a, 0xa8, 0x18, 0x28,\n    0x0a, 0x04, 0x40, 0xbf, 0xbf, 0x41, 0x15, 0x0d,\n    0x81, 0xa5, 0x0d, 0x0f, 0x00, 0x00, 0x00, 0x80,\n    0x9e, 0x81, 0xb4, 0x06, 0x00, 0x12, 0x06, 0x13,\n    0x0d, 0x83, 0x8c, 0x22, 0x06, 0xf3, 0x80, 0x8c,\n    0x80, 0x8f, 0x8c, 0xe4, 0x03, 0x01, 0x89, 0x00,\n    0x0d, 0x28, 0x00, 0x00, 0x80, 0x8f, 0x0b, 0x24,\n    0x18, 0x90, 0xa8, 0x4a, 0x76, 0x40, 0xe4, 0x2b,\n    0x11, 0x8b, 0xa5, 0x00, 0x20, 0x81, 0xb7, 0x30,\n    0x8f, 0x96, 0x88, 0x30, 0x30, 0x30, 0x30, 0x30,\n    0x30, 0x30, 0x86, 0x42, 0x25, 0x82, 0x98, 0x88,\n    0x34, 0x0c, 0x83, 0xd5, 0x1c, 0x80, 0xd9, 0x03,\n    0x84, 0xaa, 0x80, 0xdd, 0x90, 0x9f, 0xaf, 0x8f,\n    0x41, 0xff, 0x59, 0xbf, 0xbf, 0x60, 0x56, 0x8c,\n    0xc2, 0xad, 0x81, 0x41, 0x0c, 0x82, 0x8f, 0x89,\n    0x81, 0x93, 0xae, 0x8f, 0x9e, 0x81, 0xcf, 0xa6,\n    0x88, 0x81, 0xe6, 0x81, 0xbf, 0x21, 0x00, 0x04,\n    0x97, 0x8f, 0x02, 0x03, 0x80, 0x96, 0x9c, 0xb3,\n    0x8d, 0xb1, 0xbd, 0x2a, 0x00, 0x81, 0x8a, 0x9b,\n    0x89, 0x96, 0x98, 0x9c, 0x86, 0xae, 0x9b, 0x80,\n    0x8f, 0x20, 0x89, 0x89, 0x20, 0xa8, 0x96, 0x10,\n    0x87, 0x93, 0x96, 0x10, 0x82, 0xb1, 0x00, 0x11,\n    0x0c, 0x08, 0x00, 0x97, 0x11, 0x8a, 0x32, 0x8b,\n    0x29, 0x29, 0x85, 0x88, 0x30, 0x30, 0xaa, 0x80,\n    0x8d, 0x85, 0xf2, 0x9c, 0x60, 0x2b, 0xa3, 0x8b,\n    0x96, 0x83, 0xb0, 0x60, 0x21, 0x03, 0x41, 0x6d,\n    0x81, 0xe9, 0xa5, 0x86, 0x8b, 0x24, 0x00, 0x89,\n    0x80, 0x8c, 0x04, 0x00, 0x01, 0x01, 0x80, 0xeb,\n    0xa0, 0x41, 0x6a, 0x91, 0xbf, 0x81, 0xb5, 0xa7,\n    0x8b, 0xf3, 0x20, 0x40, 0x86, 0xa3, 0x99, 0x85,\n    0x99, 0x8a, 0xd8, 0x15, 0x0d, 0x0d, 0x0a, 0xa2,\n    0x8b, 0x80, 0x99, 0x80, 0x92, 0x01, 0x80, 0x8e,\n    0x81, 0x8d, 0xa1, 0xfa, 0xc4, 0xb4, 0x41, 0x0a,\n    0x9c, 0x82, 0xb0, 0xae, 0x9f, 0x8c, 0x9d, 0x84,\n    0xa5, 0x89, 0x9d, 0x81, 0xa3, 0x1f, 0x04, 0xa9,\n    0x40, 0x9d, 0x91, 0xa3, 0x83, 0xa3, 0x83, 0xa7,\n    0x87, 0xb3, 0x8b, 0x8a, 0x80, 0x8e, 0x06, 0x01,\n    0x80, 0x8a, 0x80, 0x8e, 0x06, 0x01, 0xc2, 0x41,\n    0x36, 0x88, 0x95, 0x89, 0x87, 0x97, 0x28, 0xa9,\n    0x80, 0x88, 0xc4, 0x29, 0x00, 0xab, 0x01, 0x10,\n    0x81, 0x96, 0x89, 0x96, 0x88, 0x9e, 0xc0, 0x92,\n    0x01, 0x89, 0x95, 0x89, 0x99, 0xc5, 0xb7, 0x29,\n    0xbf, 0x80, 0x8e, 0x18, 0x10, 0x9c, 0xa9, 0x9c,\n    0x82, 0x9c, 0xa2, 0x38, 0x9b, 0x9a, 0xb5, 0x89,\n    0x95, 0x89, 0x92, 0x8c, 0x91, 0xed, 0xc8, 0xb6,\n    0xb2, 0x8c, 0xb2, 0x8c, 0xa3, 0x41, 0x5b, 0xa9,\n    0x29, 0xcd, 0x9c, 0x89, 0x07, 0x95, 0xa9, 0x91,\n    0xad, 0x94, 0x9a, 0x96, 0x8b, 0xb4, 0xb8, 0x09,\n    0x80, 0x8c, 0xac, 0x9f, 0x98, 0x99, 0xa3, 0x9c,\n    0x01, 0x07, 0xa2, 0x10, 0x8b, 0xaf, 0x8d, 0x83,\n    0x94, 0x00, 0x80, 0xa2, 0x91, 0x80, 0x98, 0x92,\n    0x81, 0xbe, 0x30, 0x00, 0x18, 0x8e, 0x80, 0x89,\n    0x86, 0xae, 0xa5, 0x39, 0x09, 0x95, 0x06, 0x01,\n    0x04, 0x10, 0x91, 0x80, 0x8b, 0x84, 0x40, 0x9d,\n    0xb4, 0x91, 0x83, 0x93, 0x82, 0x9d, 0xaf, 0x93,\n    0x08, 0x80, 0x40, 0xb7, 0xae, 0xa8, 0x83, 0xa3,\n    0xaf, 0x93, 0x80, 0xba, 0xaa, 0x8c, 0x80, 0xc6,\n    0x9a, 0xa4, 0x86, 0x40, 0xb8, 0xab, 0xf3, 0xbf,\n    0x9e, 0x39, 0x01, 0x38, 0x08, 0x97, 0x8e, 0x00,\n    0x80, 0xdd, 0x39, 0xa6, 0x8f, 0x00, 0x80, 0x9b,\n    0x80, 0x89, 0xa7, 0x30, 0x94, 0x80, 0x8a, 0xad,\n    0x92, 0x80, 0x91, 0xc8, 0x41, 0x06, 0x88, 0x80,\n    0xa4, 0x90, 0x80, 0xb0, 0x9d, 0xef, 0x30, 0x08,\n    0xa5, 0x94, 0x80, 0x98, 0x28, 0x08, 0x9f, 0x8d,\n    0x80, 0x41, 0x46, 0x92, 0x8e, 0x00, 0x8c, 0x80,\n    0xa1, 0xfb, 0x80, 0xce, 0x43, 0x99, 0xe5, 0xee,\n    0x90, 0x40, 0xc3, 0x4a, 0x4b, 0xe0, 0x8e, 0x44,\n    0x2f, 0x90, 0x85, 0x4f, 0xb8, 0x42, 0x46, 0x60,\n    0x21, 0xb8, 0x42, 0x38, 0x86, 0x9e, 0x90, 0xce,\n    0x90, 0x9d, 0x91, 0xaf, 0x8f, 0x83, 0x9e, 0x94,\n    0x84, 0x92, 0x42, 0xaf, 0xbf, 0xff, 0xca, 0x20,\n    0xc1, 0x8c, 0xbf, 0x08, 0x80, 0x9b, 0x57, 0xf7,\n    0x87, 0x44, 0xd5, 0xa9, 0x88, 0x60, 0x22, 0xe6,\n    0x18, 0x30, 0x08, 0x41, 0x22, 0x8e, 0x80, 0x9c,\n    0x11, 0x80, 0x8d, 0x1f, 0x41, 0x8b, 0x49, 0x03,\n    0xea, 0x84, 0x8c, 0x82, 0x88, 0x86, 0x89, 0x57,\n    0x65, 0xd4, 0x80, 0xc6, 0x01, 0x08, 0x09, 0x0b,\n    0x80, 0x8b, 0x00, 0x06, 0x80, 0xc0, 0x03, 0x0f,\n    0x06, 0x80, 0x9b, 0x03, 0x04, 0x00, 0x16, 0x80,\n    0x41, 0x53, 0x81, 0x98, 0x80, 0x98, 0x80, 0x9e,\n    0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80, 0x9e,\n    0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x07, 0x47,\n    0x33, 0x9e, 0x2d, 0x41, 0x04, 0xbd, 0x40, 0x91,\n    0xac, 0x89, 0x86, 0x8f, 0x80, 0x41, 0x40, 0x9d,\n    0x91, 0xab, 0x41, 0xe3, 0x9b, 0x42, 0xf3, 0x30,\n    0x18, 0x08, 0x8e, 0x80, 0x40, 0xc4, 0xba, 0xc3,\n    0x30, 0x44, 0xb3, 0x18, 0x9a, 0x01, 0x00, 0x08,\n    0x80, 0x89, 0x03, 0x00, 0x00, 0x28, 0x18, 0x00,\n    0x00, 0x02, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x00, 0x0b, 0x06, 0x03, 0x03, 0x00,\n    0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80, 0x90,\n    0x51, 0x43, 0x60, 0xa6, 0xdf, 0x9f, 0x50, 0x39,\n    0x85, 0x40, 0xdd, 0x81, 0x56, 0x81, 0x8d, 0x5d,\n    0x30, 0x4c, 0x1e, 0x42, 0x1d, 0x45, 0xe1, 0x53,\n    0x4a, 0x84, 0x50, 0x5f,\n};\n\nstatic const uint8_t unicode_prop_ID_Start_index[105] = {\n    0xf6, 0x03, 0x20,  //  003F6 at 33\n    0xa6, 0x07, 0x00,  //  007A6 at 64\n    0xa9, 0x09, 0x20,  //  009A9 at 97\n    0xb1, 0x0a, 0x00,  //  00AB1 at 128\n    0xba, 0x0b, 0x20,  //  00BBA at 161\n    0x3b, 0x0d, 0x20,  //  00D3B at 193\n    0xc7, 0x0e, 0x20,  //  00EC7 at 225\n    0x49, 0x12, 0x00,  //  01249 at 256\n    0x9b, 0x16, 0x00,  //  0169B at 288\n    0xac, 0x19, 0x00,  //  019AC at 320\n    0xc0, 0x1d, 0x80,  //  01DC0 at 356\n    0x80, 0x20, 0x20,  //  02080 at 385\n    0x70, 0x2d, 0x00,  //  02D70 at 416\n    0x00, 0x32, 0x00,  //  03200 at 448\n    0xda, 0xa7, 0x00,  //  0A7DA at 480\n    0x4c, 0xaa, 0x20,  //  0AA4C at 513\n    0xc7, 0xd7, 0x20,  //  0D7C7 at 545\n    0xfc, 0xfd, 0x20,  //  0FDFC at 577\n    0x9d, 0x02, 0x21,  //  1029D at 609\n    0x96, 0x05, 0x01,  //  10596 at 640\n    0xf3, 0x08, 0x01,  //  108F3 at 672\n    0xb3, 0x0c, 0x21,  //  10CB3 at 705\n    0x73, 0x11, 0x61,  //  11173 at 739\n    0x34, 0x13, 0x01,  //  11334 at 768\n    0x1b, 0x17, 0x21,  //  1171B at 801\n    0x8a, 0x1a, 0x01,  //  11A8A at 832\n    0x34, 0x1f, 0x21,  //  11F34 at 865\n    0xbf, 0x6a, 0x01,  //  16ABF at 896\n    0x23, 0xb1, 0xa1,  //  1B123 at 933\n    0xad, 0xd4, 0x01,  //  1D4AD at 960\n    0x6f, 0xd7, 0x01,  //  1D76F at 992\n    0xff, 0xe7, 0x61,  //  1E7FF at 1027\n    0x5e, 0xee, 0x01,  //  1EE5E at 1056\n    0xe1, 0xeb, 0x22,  //  2EBE1 at 1089\n    0xb0, 0x23, 0x03,  //  323B0 at 1120 (upper bound)\n};\n\nstatic const uint8_t unicode_prop_ID_Continue1_table[660] = {\n    0xaf, 0x89, 0xa4, 0x80, 0xd6, 0x80, 0x42, 0x47,\n    0xef, 0x96, 0x80, 0x40, 0xfa, 0x84, 0x41, 0x08,\n    0xac, 0x00, 0x01, 0x01, 0x00, 0xc7, 0x8a, 0xaf,\n    0x9e, 0x28, 0xe4, 0x31, 0x29, 0x08, 0x19, 0x89,\n    0x96, 0x80, 0x9d, 0x9a, 0xda, 0x8a, 0x8e, 0x89,\n    0xa0, 0x88, 0x88, 0x80, 0x97, 0x18, 0x88, 0x02,\n    0x04, 0xaa, 0x82, 0xbb, 0x87, 0xa9, 0x97, 0x80,\n    0xa0, 0xb5, 0x10, 0x91, 0x06, 0x89, 0x09, 0x89,\n    0x90, 0x82, 0xb7, 0x00, 0x31, 0x09, 0x82, 0x88,\n    0x80, 0x89, 0x09, 0x89, 0x8d, 0x01, 0x82, 0xb7,\n    0x00, 0x23, 0x09, 0x12, 0x80, 0x93, 0x8b, 0x10,\n    0x8a, 0x82, 0xb7, 0x00, 0x38, 0x10, 0x82, 0x93,\n    0x09, 0x89, 0x89, 0x28, 0x82, 0xb7, 0x00, 0x31,\n    0x09, 0x16, 0x82, 0x89, 0x09, 0x89, 0x91, 0x80,\n    0xba, 0x22, 0x10, 0x83, 0x88, 0x80, 0x8d, 0x89,\n    0x8f, 0x84, 0xb6, 0x00, 0x30, 0x10, 0x1e, 0x81,\n    0x8a, 0x09, 0x89, 0x90, 0x82, 0xb7, 0x00, 0x30,\n    0x10, 0x1e, 0x81, 0x8a, 0x09, 0x89, 0x10, 0x8b,\n    0x83, 0xb6, 0x08, 0x30, 0x10, 0x83, 0x88, 0x80,\n    0x89, 0x09, 0x89, 0x90, 0x82, 0xc5, 0x03, 0x28,\n    0x00, 0x3d, 0x89, 0x09, 0xbc, 0x01, 0x86, 0x8b,\n    0x38, 0x89, 0xd6, 0x01, 0x88, 0x8a, 0x30, 0x89,\n    0xbd, 0x0d, 0x89, 0x8a, 0x00, 0x00, 0x03, 0x81,\n    0xb0, 0x93, 0x01, 0x84, 0x8a, 0x80, 0xa3, 0x88,\n    0x80, 0xe3, 0x93, 0x80, 0x89, 0x8b, 0x1b, 0x10,\n    0x11, 0x32, 0x83, 0x8c, 0x8b, 0x80, 0x8e, 0x42,\n    0xbe, 0x82, 0x88, 0x88, 0x43, 0x9f, 0x83, 0x9b,\n    0x82, 0x9c, 0x81, 0x9d, 0x81, 0xbf, 0x9f, 0x88,\n    0x01, 0x89, 0xa0, 0x10, 0x8a, 0x40, 0x8e, 0x80,\n    0xf5, 0x8b, 0x83, 0x8b, 0x89, 0x89, 0xff, 0x8a,\n    0xbb, 0x84, 0xb8, 0x89, 0x80, 0x9c, 0x81, 0x8a,\n    0x85, 0x89, 0x95, 0x8d, 0x80, 0x8f, 0xb0, 0x84,\n    0xae, 0x90, 0x8a, 0x89, 0x90, 0x88, 0x8b, 0x82,\n    0x9d, 0x8c, 0x81, 0x89, 0xab, 0x8d, 0xaf, 0x93,\n    0x87, 0x89, 0x85, 0x89, 0xf5, 0x10, 0x94, 0x18,\n    0x28, 0x0a, 0x40, 0xc5, 0xbf, 0x42, 0x3e, 0x81,\n    0x92, 0x80, 0xfa, 0x8c, 0x18, 0x82, 0x8b, 0x4b,\n    0xfd, 0x82, 0x40, 0x8c, 0x80, 0xdf, 0x9f, 0x42,\n    0x29, 0x85, 0xe8, 0x81, 0x60, 0x75, 0x84, 0x89,\n    0xc4, 0x03, 0x89, 0x9f, 0x81, 0xcf, 0x81, 0x41,\n    0x0f, 0x02, 0x03, 0x80, 0x96, 0x23, 0x80, 0xd2,\n    0x81, 0xb1, 0x91, 0x89, 0x89, 0x85, 0x91, 0x8c,\n    0x8a, 0x9b, 0x87, 0x98, 0x8c, 0xab, 0x83, 0xae,\n    0x8d, 0x8e, 0x89, 0x8a, 0x80, 0x89, 0x89, 0xae,\n    0x8d, 0x8b, 0x07, 0x09, 0x89, 0xa0, 0x82, 0xb1,\n    0x00, 0x11, 0x0c, 0x08, 0x80, 0xa8, 0x24, 0x81,\n    0x40, 0xeb, 0x38, 0x09, 0x89, 0x60, 0x4f, 0x23,\n    0x80, 0x42, 0xe0, 0x8f, 0x8f, 0x8f, 0x11, 0x97,\n    0x82, 0x40, 0xbf, 0x89, 0xa4, 0x80, 0x42, 0xbc,\n    0x80, 0x40, 0xe1, 0x80, 0x40, 0x94, 0x84, 0x41,\n    0x24, 0x89, 0x45, 0x56, 0x10, 0x0c, 0x83, 0xa7,\n    0x13, 0x80, 0x40, 0xa4, 0x81, 0x42, 0x3c, 0x1f,\n    0x89, 0x41, 0x70, 0x81, 0xcf, 0x82, 0xc5, 0x8a,\n    0xb0, 0x83, 0xf9, 0x82, 0xb4, 0x8e, 0x9e, 0x8a,\n    0x09, 0x89, 0x83, 0xac, 0x8a, 0x30, 0xac, 0x89,\n    0x2a, 0xa3, 0x8d, 0x80, 0x89, 0x21, 0xab, 0x80,\n    0x8b, 0x82, 0xaf, 0x8d, 0x3b, 0x80, 0x8b, 0xd1,\n    0x8b, 0x28, 0x08, 0x40, 0x9c, 0x8b, 0x84, 0x89,\n    0x2b, 0xb6, 0x08, 0x31, 0x09, 0x82, 0x88, 0x80,\n    0x89, 0x09, 0x32, 0x84, 0x40, 0xbf, 0x91, 0x88,\n    0x89, 0x18, 0xd0, 0x93, 0x8b, 0x89, 0x40, 0xd4,\n    0x31, 0x88, 0x9a, 0x81, 0xd1, 0x90, 0x8e, 0x89,\n    0xd0, 0x8c, 0x87, 0x89, 0xd2, 0x8e, 0x83, 0x89,\n    0x40, 0xf1, 0x8e, 0x40, 0xa4, 0x89, 0xc5, 0x28,\n    0x09, 0x18, 0x00, 0x81, 0x8b, 0x89, 0xf6, 0x31,\n    0x32, 0x80, 0x9b, 0x89, 0xa7, 0x30, 0x1f, 0x80,\n    0x88, 0x8a, 0xad, 0x8f, 0x41, 0x94, 0x38, 0x87,\n    0x8f, 0x89, 0xb7, 0x95, 0x80, 0x8d, 0xf9, 0x2a,\n    0x00, 0x08, 0x30, 0x07, 0x89, 0xaf, 0x20, 0x08,\n    0x27, 0x89, 0x41, 0x48, 0x83, 0x88, 0x08, 0x80,\n    0xaf, 0x32, 0x84, 0x8c, 0x89, 0x54, 0xe5, 0x05,\n    0x8e, 0x60, 0x36, 0x09, 0x89, 0xd5, 0x89, 0xa5,\n    0x84, 0xba, 0x86, 0x98, 0x89, 0x43, 0xf4, 0x00,\n    0xb6, 0x33, 0xd0, 0x80, 0x8a, 0x81, 0x60, 0x4c,\n    0xaa, 0x81, 0x52, 0x60, 0xad, 0x81, 0x96, 0x42,\n    0x1d, 0x22, 0x2f, 0x39, 0x86, 0x9d, 0x83, 0x40,\n    0x93, 0x82, 0x45, 0x88, 0xb1, 0x41, 0xff, 0xb6,\n    0x83, 0xb1, 0x38, 0x8d, 0x80, 0x95, 0x20, 0x8e,\n    0x45, 0x4f, 0x30, 0x90, 0x0e, 0x01, 0x04, 0xe3,\n    0x80, 0x40, 0x9f, 0x86, 0x88, 0x89, 0x41, 0x63,\n    0x80, 0xbc, 0x8d, 0x41, 0xf1, 0x8d, 0x43, 0xd5,\n    0x86, 0xec, 0x34, 0x89, 0x52, 0x95, 0x89, 0x6c,\n    0x05, 0x05, 0x40, 0xef,\n};\n\nstatic const uint8_t unicode_prop_ID_Continue1_index[63] = {\n    0xfa, 0x06, 0x00,  //  006FA at 32\n    0x70, 0x09, 0x00,  //  00970 at 64\n    0xf0, 0x0a, 0x40,  //  00AF0 at 98\n    0x57, 0x0c, 0x00,  //  00C57 at 128\n    0xf0, 0x0d, 0x60,  //  00DF0 at 163\n    0xc7, 0x0f, 0x20,  //  00FC7 at 193\n    0xea, 0x17, 0x40,  //  017EA at 226\n    0x05, 0x1b, 0x00,  //  01B05 at 256\n    0x41, 0x20, 0x00,  //  02041 at 288\n    0x0c, 0xa8, 0x80,  //  0A80C at 324\n    0x37, 0xaa, 0x20,  //  0AA37 at 353\n    0x50, 0xfe, 0x20,  //  0FE50 at 385\n    0x3a, 0x0d, 0x21,  //  10D3A at 417\n    0x74, 0x11, 0x01,  //  11174 at 448\n    0x5a, 0x14, 0x21,  //  1145A at 481\n    0x44, 0x19, 0x81,  //  11944 at 516\n    0x5a, 0x1d, 0xa1,  //  11D5A at 549\n    0xf5, 0x6a, 0x21,  //  16AF5 at 577\n    0x45, 0xd2, 0x41,  //  1D245 at 610\n    0xaf, 0xe2, 0x21,  //  1E2AF at 641\n    0xf0, 0x01, 0x0e,  //  E01F0 at 672 (upper bound)\n};\n\n#ifdef CONFIG_ALL_UNICODE\n\nstatic const uint8_t unicode_cc_table[899] = {\n    0xb2, 0xcf, 0xd4, 0x00, 0xe8, 0x03, 0xdc, 0x00,\n    0xe8, 0x00, 0xd8, 0x04, 0xdc, 0x01, 0xca, 0x03,\n    0xdc, 0x01, 0xca, 0x0a, 0xdc, 0x04, 0x01, 0x03,\n    0xdc, 0xc7, 0x00, 0xf0, 0xc0, 0x02, 0xdc, 0xc2,\n    0x01, 0xdc, 0x80, 0xc2, 0x03, 0xdc, 0xc0, 0x00,\n    0xe8, 0x01, 0xdc, 0xc0, 0x41, 0xe9, 0x00, 0xea,\n    0x41, 0xe9, 0x00, 0xea, 0x00, 0xe9, 0xcc, 0xb0,\n    0xe2, 0xc4, 0xb0, 0xd8, 0x00, 0xdc, 0xc3, 0x00,\n    0xdc, 0xc2, 0x00, 0xde, 0x00, 0xdc, 0xc5, 0x05,\n    0xdc, 0xc1, 0x00, 0xdc, 0xc1, 0x00, 0xde, 0x00,\n    0xe4, 0xc0, 0x49, 0x0a, 0x43, 0x13, 0x80, 0x00,\n    0x17, 0x80, 0x41, 0x18, 0x80, 0xc0, 0x00, 0xdc,\n    0x80, 0x00, 0x12, 0xb0, 0x17, 0xc7, 0x42, 0x1e,\n    0xaf, 0x47, 0x1b, 0xc1, 0x01, 0xdc, 0xc4, 0x00,\n    0xdc, 0xc1, 0x00, 0xdc, 0x8f, 0x00, 0x23, 0xb0,\n    0x34, 0xc6, 0x81, 0xc3, 0x00, 0xdc, 0xc0, 0x81,\n    0xc1, 0x80, 0x00, 0xdc, 0xc1, 0x00, 0xdc, 0xa2,\n    0x00, 0x24, 0x9d, 0xc0, 0x00, 0xdc, 0xc1, 0x00,\n    0xdc, 0xc1, 0x02, 0xdc, 0xc0, 0x01, 0xdc, 0xc0,\n    0x00, 0xdc, 0xc2, 0x00, 0xdc, 0xc0, 0x00, 0xdc,\n    0xc0, 0x00, 0xdc, 0xc0, 0x00, 0xdc, 0xc1, 0xb0,\n    0x6f, 0xc6, 0x00, 0xdc, 0xc0, 0x88, 0x00, 0xdc,\n    0x97, 0xc3, 0x80, 0xc8, 0x80, 0xc2, 0x80, 0xc4,\n    0xaa, 0x02, 0xdc, 0xb0, 0x0b, 0xc0, 0x02, 0xdc,\n    0xc3, 0xa9, 0xc4, 0x04, 0xdc, 0xcd, 0x80, 0x00,\n    0xdc, 0xc1, 0x00, 0xdc, 0xc1, 0x00, 0xdc, 0xc2,\n    0x02, 0xdc, 0x42, 0x1b, 0xc2, 0x00, 0xdc, 0xc1,\n    0x01, 0xdc, 0xc4, 0xb0, 0x0b, 0x00, 0x07, 0x8f,\n    0x00, 0x09, 0x82, 0xc0, 0x00, 0xdc, 0xc1, 0xb0,\n    0x36, 0x00, 0x07, 0x8f, 0x00, 0x09, 0xaf, 0xc0,\n    0xb0, 0x0c, 0x00, 0x07, 0x8f, 0x00, 0x09, 0xb0,\n    0x3d, 0x00, 0x07, 0x8f, 0x00, 0x09, 0xb0, 0x3d,\n    0x00, 0x07, 0x8f, 0x00, 0x09, 0xb0, 0x4e, 0x00,\n    0x09, 0xb0, 0x3d, 0x00, 0x07, 0x8f, 0x00, 0x09,\n    0x86, 0x00, 0x54, 0x00, 0x5b, 0xb0, 0x34, 0x00,\n    0x07, 0x8f, 0x00, 0x09, 0xb0, 0x3c, 0x01, 0x09,\n    0x8f, 0x00, 0x09, 0xb0, 0x4b, 0x00, 0x09, 0xb0,\n    0x3c, 0x01, 0x67, 0x00, 0x09, 0x8c, 0x03, 0x6b,\n    0xb0, 0x3b, 0x01, 0x76, 0x00, 0x09, 0x8c, 0x03,\n    0x7a, 0xb0, 0x1b, 0x01, 0xdc, 0x9a, 0x00, 0xdc,\n    0x80, 0x00, 0xdc, 0x80, 0x00, 0xd8, 0xb0, 0x06,\n    0x41, 0x81, 0x80, 0x00, 0x84, 0x84, 0x03, 0x82,\n    0x81, 0x00, 0x82, 0x80, 0xc1, 0x00, 0x09, 0x80,\n    0xc1, 0xb0, 0x0d, 0x00, 0xdc, 0xb0, 0x3f, 0x00,\n    0x07, 0x80, 0x01, 0x09, 0xb0, 0x21, 0x00, 0xdc,\n    0xb2, 0x9e, 0xc2, 0xb3, 0x83, 0x01, 0x09, 0x9d,\n    0x00, 0x09, 0xb0, 0x6c, 0x00, 0x09, 0x89, 0xc0,\n    0xb0, 0x9a, 0x00, 0xe4, 0xb0, 0x5e, 0x00, 0xde,\n    0xc0, 0x00, 0xdc, 0xb0, 0xaa, 0xc0, 0x00, 0xdc,\n    0xb0, 0x16, 0x00, 0x09, 0x93, 0xc7, 0x81, 0x00,\n    0xdc, 0xaf, 0xc4, 0x05, 0xdc, 0xc1, 0x00, 0xdc,\n    0x80, 0x01, 0xdc, 0xc1, 0x01, 0xdc, 0xc4, 0x00,\n    0xdc, 0xc3, 0xb0, 0x34, 0x00, 0x07, 0x8e, 0x00,\n    0x09, 0xa5, 0xc0, 0x00, 0xdc, 0xc6, 0xb0, 0x05,\n    0x01, 0x09, 0xb0, 0x09, 0x00, 0x07, 0x8a, 0x01,\n    0x09, 0xb0, 0x12, 0x00, 0x07, 0xb0, 0x67, 0xc2,\n    0x41, 0x00, 0x04, 0xdc, 0xc1, 0x03, 0xdc, 0xc0,\n    0x41, 0x00, 0x05, 0x01, 0x83, 0x00, 0xdc, 0x85,\n    0xc0, 0x82, 0xc1, 0xb0, 0x95, 0xc1, 0x00, 0xdc,\n    0xc6, 0x00, 0xdc, 0xc1, 0x00, 0xea, 0x00, 0xd6,\n    0x00, 0xdc, 0x00, 0xca, 0xe4, 0x00, 0xe8, 0x01,\n    0xe4, 0x00, 0xdc, 0x00, 0xda, 0xc0, 0x00, 0xe9,\n    0x00, 0xdc, 0xc0, 0x00, 0xdc, 0xb2, 0x9f, 0xc1,\n    0x01, 0x01, 0xc3, 0x02, 0x01, 0xc1, 0x83, 0xc0,\n    0x82, 0x01, 0x01, 0xc0, 0x00, 0xdc, 0xc0, 0x01,\n    0x01, 0x03, 0xdc, 0xc0, 0xb8, 0x03, 0xcd, 0xc2,\n    0xb0, 0x5c, 0x00, 0x09, 0xb0, 0x2f, 0xdf, 0xb1,\n    0xf9, 0x00, 0xda, 0x00, 0xe4, 0x00, 0xe8, 0x00,\n    0xde, 0x01, 0xe0, 0xb0, 0x38, 0x01, 0x08, 0xb8,\n    0x6d, 0xa3, 0xc0, 0x83, 0xc9, 0x9f, 0xc1, 0xb0,\n    0x1f, 0xc1, 0xb0, 0xe3, 0x00, 0x09, 0xa4, 0x00,\n    0x09, 0xb0, 0x66, 0x00, 0x09, 0x9a, 0xd1, 0xb0,\n    0x08, 0x02, 0xdc, 0xa4, 0x00, 0x09, 0xb0, 0x2e,\n    0x00, 0x07, 0x8b, 0x00, 0x09, 0xb0, 0xbe, 0xc0,\n    0x80, 0xc1, 0x00, 0xdc, 0x81, 0xc1, 0x84, 0xc1,\n    0x80, 0xc0, 0xb0, 0x03, 0x00, 0x09, 0xb0, 0xc5,\n    0x00, 0x09, 0xb8, 0x46, 0xff, 0x00, 0x1a, 0xb2,\n    0xd0, 0xc6, 0x06, 0xdc, 0xc1, 0xb3, 0x9c, 0x00,\n    0xdc, 0xb0, 0xb1, 0x00, 0xdc, 0xb0, 0x64, 0xc4,\n    0xb6, 0x61, 0x00, 0xdc, 0x80, 0xc0, 0xa7, 0xc0,\n    0x00, 0x01, 0x00, 0xdc, 0x83, 0x00, 0x09, 0xb0,\n    0x74, 0xc0, 0x00, 0xdc, 0xb2, 0x0c, 0xc3, 0xb1,\n    0x52, 0xc1, 0xb0, 0x1f, 0x02, 0xdc, 0xb0, 0x15,\n    0x01, 0xdc, 0xc2, 0x00, 0xdc, 0xc0, 0x03, 0xdc,\n    0xb0, 0x00, 0xc0, 0x00, 0xdc, 0xc0, 0x00, 0xdc,\n    0xb0, 0x8f, 0x00, 0x09, 0xa8, 0x00, 0x09, 0x8d,\n    0x00, 0x09, 0xb0, 0x08, 0x00, 0x09, 0x00, 0x07,\n    0xb0, 0x14, 0xc2, 0xaf, 0x01, 0x09, 0xb0, 0x0d,\n    0x00, 0x07, 0xb0, 0x1b, 0x00, 0x09, 0x88, 0x00,\n    0x07, 0xb0, 0x39, 0x00, 0x09, 0x00, 0x07, 0xb0,\n    0x81, 0x00, 0x07, 0x00, 0x09, 0xb0, 0x1f, 0x01,\n    0x07, 0x8f, 0x00, 0x09, 0x97, 0xc6, 0x82, 0xc4,\n    0xb0, 0x9c, 0x00, 0x09, 0x82, 0x00, 0x07, 0x96,\n    0xc0, 0xb0, 0x32, 0x00, 0x09, 0x00, 0x07, 0xb0,\n    0xca, 0x00, 0x09, 0x00, 0x07, 0xb0, 0x4d, 0x00,\n    0x09, 0xb0, 0x45, 0x00, 0x09, 0x00, 0x07, 0xb0,\n    0x42, 0x00, 0x09, 0xb0, 0xdc, 0x00, 0x09, 0x00,\n    0x07, 0xb0, 0xd1, 0x01, 0x09, 0x83, 0x00, 0x07,\n    0xb0, 0x6b, 0x00, 0x09, 0xb0, 0x22, 0x00, 0x09,\n    0x91, 0x00, 0x09, 0xb0, 0x20, 0x00, 0x09, 0xb1,\n    0x74, 0x00, 0x09, 0xb0, 0xd1, 0x00, 0x07, 0x80,\n    0x01, 0x09, 0xb0, 0x20, 0x00, 0x09, 0xb1, 0x78,\n    0x01, 0x09, 0xb8, 0x43, 0x7c, 0x04, 0x01, 0xb0,\n    0x0a, 0xc6, 0xb4, 0x88, 0x01, 0x06, 0xb8, 0x44,\n    0x7b, 0x00, 0x01, 0xb8, 0x0c, 0x95, 0x01, 0xd8,\n    0x02, 0x01, 0x82, 0x00, 0xe2, 0x04, 0xd8, 0x87,\n    0x07, 0xdc, 0x81, 0xc4, 0x01, 0xdc, 0x9d, 0xc3,\n    0xb0, 0x63, 0xc2, 0xb8, 0x05, 0x8a, 0xc6, 0x80,\n    0xd0, 0x81, 0xc6, 0x80, 0xc1, 0x80, 0xc4, 0xb0,\n    0x33, 0xc0, 0xb0, 0x6f, 0xc6, 0xb1, 0x46, 0xc0,\n    0xb0, 0x0c, 0xc3, 0xb1, 0xcb, 0x01, 0xe8, 0x00,\n    0xdc, 0xc0, 0xb3, 0xaf, 0x06, 0xdc, 0xb0, 0x3c,\n    0xc5, 0x00, 0x07,\n};\n\nstatic const uint8_t unicode_cc_index[87] = {\n    0x4d, 0x03, 0x00,  //  0034D at 32\n    0x97, 0x05, 0x20,  //  00597 at 65\n    0xc6, 0x05, 0x00,  //  005C6 at 96\n    0xe7, 0x06, 0x00,  //  006E7 at 128\n    0x45, 0x07, 0x00,  //  00745 at 160\n    0x9c, 0x08, 0x00,  //  0089C at 192\n    0x4d, 0x09, 0x00,  //  0094D at 224\n    0x3c, 0x0b, 0x00,  //  00B3C at 256\n    0x3d, 0x0d, 0x00,  //  00D3D at 288\n    0x36, 0x0f, 0x00,  //  00F36 at 320\n    0x38, 0x10, 0x20,  //  01038 at 353\n    0x3a, 0x19, 0x00,  //  0193A at 384\n    0xcb, 0x1a, 0x20,  //  01ACB at 417\n    0xd3, 0x1c, 0x00,  //  01CD3 at 448\n    0xcf, 0x1d, 0x00,  //  01DCF at 480\n    0xe2, 0x20, 0x00,  //  020E2 at 512\n    0x2e, 0x30, 0x20,  //  0302E at 545\n    0x2b, 0xa9, 0x20,  //  0A92B at 577\n    0xed, 0xab, 0x00,  //  0ABED at 608\n    0x39, 0x0a, 0x01,  //  10A39 at 640\n    0x51, 0x0f, 0x01,  //  10F51 at 672\n    0x73, 0x11, 0x01,  //  11173 at 704\n    0x75, 0x13, 0x01,  //  11375 at 736\n    0x2b, 0x17, 0x21,  //  1172B at 769\n    0x3f, 0x1c, 0x21,  //  11C3F at 801\n    0x9e, 0xbc, 0x21,  //  1BC9E at 833\n    0x08, 0xe0, 0x01,  //  1E008 at 864\n    0x44, 0xe9, 0x01,  //  1E944 at 896\n    0x4b, 0xe9, 0x01,  //  1E94B at 928 (upper bound)\n};\n\nstatic const uint32_t unicode_decomp_table1[699] = {\n    0x00280081, 0x002a0097, 0x002a8081, 0x002bc097,\n    0x002c8115, 0x002d0097, 0x002d4081, 0x002e0097,\n    0x002e4115, 0x002f0199, 0x00302016, 0x00400842,\n    0x00448a42, 0x004a0442, 0x004c0096, 0x004c8117,\n    0x004d0242, 0x004e4342, 0x004fc12f, 0x0050c342,\n    0x005240bf, 0x00530342, 0x00550942, 0x005a0842,\n    0x005e0096, 0x005e4342, 0x005fc081, 0x00680142,\n    0x006bc142, 0x00710185, 0x0071c317, 0x00734844,\n    0x00778344, 0x00798342, 0x007b02be, 0x007c4197,\n    0x007d0142, 0x007e0444, 0x00800e42, 0x00878142,\n    0x00898744, 0x00ac0483, 0x00b60317, 0x00b80283,\n    0x00d00214, 0x00d10096, 0x00dd0080, 0x00de8097,\n    0x00df8080, 0x00e10097, 0x00e1413e, 0x00e1c080,\n    0x00e204be, 0x00ea83ae, 0x00f282ae, 0x00f401ad,\n    0x00f4c12e, 0x00f54103, 0x00fc0303, 0x00fe4081,\n    0x0100023e, 0x0101c0be, 0x010301be, 0x010640be,\n    0x010e40be, 0x0114023e, 0x0115c0be, 0x011701be,\n    0x011d8144, 0x01304144, 0x01340244, 0x01358144,\n    0x01368344, 0x01388344, 0x013a8644, 0x013e0144,\n    0x0161c085, 0x018882ae, 0x019d422f, 0x01b00184,\n    0x01b4c084, 0x024a4084, 0x024c4084, 0x024d0084,\n    0x0256042e, 0x0272c12e, 0x02770120, 0x0277c084,\n    0x028cc084, 0x028d8084, 0x029641ae, 0x02978084,\n    0x02d20084, 0x02d2c12e, 0x02d70120, 0x02e50084,\n    0x02f281ae, 0x03120084, 0x03300084, 0x0331c122,\n    0x0332812e, 0x035281ae, 0x03768084, 0x037701ae,\n    0x038cc085, 0x03acc085, 0x03b7012f, 0x03c30081,\n    0x03d0c084, 0x03d34084, 0x03d48084, 0x03d5c084,\n    0x03d70084, 0x03da4084, 0x03dcc084, 0x03dd412e,\n    0x03ddc085, 0x03de0084, 0x03de4085, 0x03e04084,\n    0x03e4c084, 0x03e74084, 0x03e88084, 0x03e9c084,\n    0x03eb0084, 0x03ee4084, 0x04098084, 0x043f0081,\n    0x06c18484, 0x06c48084, 0x06cec184, 0x06d00120,\n    0x06d0c084, 0x074b0383, 0x074cc41f, 0x074f1783,\n    0x075e0081, 0x0766d283, 0x07801d44, 0x078e8942,\n    0x07931844, 0x079f0d42, 0x07a58216, 0x07a68085,\n    0x07a6c0be, 0x07a80d44, 0x07aea044, 0x07c00122,\n    0x07c08344, 0x07c20122, 0x07c28344, 0x07c40122,\n    0x07c48244, 0x07c60122, 0x07c68244, 0x07c8113e,\n    0x07d08244, 0x07d20122, 0x07d28244, 0x07d40122,\n    0x07d48344, 0x07d64c3e, 0x07dc4080, 0x07dc80be,\n    0x07dcc080, 0x07dd00be, 0x07dd4080, 0x07dd80be,\n    0x07ddc080, 0x07de00be, 0x07de4080, 0x07de80be,\n    0x07dec080, 0x07df00be, 0x07df4080, 0x07e00820,\n    0x07e40820, 0x07e80820, 0x07ec05be, 0x07eec080,\n    0x07ef00be, 0x07ef4097, 0x07ef8080, 0x07efc117,\n    0x07f0443e, 0x07f24080, 0x07f280be, 0x07f2c080,\n    0x07f303be, 0x07f4c080, 0x07f582ae, 0x07f6c080,\n    0x07f7433e, 0x07f8c080, 0x07f903ae, 0x07fac080,\n    0x07fb013e, 0x07fb8102, 0x07fc83be, 0x07fe4080,\n    0x07fe80be, 0x07fec080, 0x07ff00be, 0x07ff4080,\n    0x07ff8097, 0x0800011e, 0x08008495, 0x08044081,\n    0x0805c097, 0x08090081, 0x08094097, 0x08098099,\n    0x080bc081, 0x080cc085, 0x080d00b1, 0x080d8085,\n    0x080dc0b1, 0x080f0197, 0x0811c197, 0x0815c0b3,\n    0x0817c081, 0x081c0595, 0x081ec081, 0x081f0215,\n    0x0820051f, 0x08228583, 0x08254415, 0x082a0097,\n    0x08400119, 0x08408081, 0x0840c0bf, 0x08414119,\n    0x0841c081, 0x084240bf, 0x0842852d, 0x08454081,\n    0x08458097, 0x08464295, 0x08480097, 0x08484099,\n    0x08488097, 0x08490081, 0x08498080, 0x084a0081,\n    0x084a8102, 0x084b0495, 0x084d421f, 0x084e4081,\n    0x084ec099, 0x084f0283, 0x08514295, 0x08540119,\n    0x0854809b, 0x0854c619, 0x0857c097, 0x08580081,\n    0x08584097, 0x08588099, 0x0858c097, 0x08590081,\n    0x08594097, 0x08598099, 0x0859c09b, 0x085a0097,\n    0x085a4081, 0x085a8097, 0x085ac099, 0x085b0295,\n    0x085c4097, 0x085c8099, 0x085cc097, 0x085d0081,\n    0x085d4097, 0x085d8099, 0x085dc09b, 0x085e0097,\n    0x085e4081, 0x085e8097, 0x085ec099, 0x085f0215,\n    0x08624099, 0x0866813e, 0x086b80be, 0x087341be,\n    0x088100be, 0x088240be, 0x088300be, 0x088901be,\n    0x088b0085, 0x088b40b1, 0x088bc085, 0x088c00b1,\n    0x089040be, 0x089100be, 0x0891c1be, 0x089801be,\n    0x089b42be, 0x089d0144, 0x089e0144, 0x08a00144,\n    0x08a10144, 0x08a20144, 0x08ab023e, 0x08b80244,\n    0x08ba8220, 0x08ca411e, 0x0918049f, 0x091a4523,\n    0x091cc097, 0x091d04a5, 0x091f452b, 0x0921c09b,\n    0x092204a1, 0x09244525, 0x0926c099, 0x09270d25,\n    0x092d8d1f, 0x09340d1f, 0x093a8081, 0x0a8300b3,\n    0x0a9d0099, 0x0a9d4097, 0x0a9d8099, 0x0ab700be,\n    0x0b1f0115, 0x0b5bc081, 0x0ba7c081, 0x0bbcc081,\n    0x0bc004ad, 0x0bc244ad, 0x0bc484ad, 0x0bc6f383,\n    0x0be0852d, 0x0be31d03, 0x0bf1882d, 0x0c000081,\n    0x0c0d8283, 0x0c130b84, 0x0c194284, 0x0c1c0122,\n    0x0c1cc122, 0x0c1d8122, 0x0c1e4122, 0x0c1f0122,\n    0x0c250084, 0x0c26c123, 0x0c278084, 0x0c27c085,\n    0x0c2b0b84, 0x0c314284, 0x0c340122, 0x0c34c122,\n    0x0c358122, 0x0c364122, 0x0c370122, 0x0c3d0084,\n    0x0c3dc220, 0x0c3f8084, 0x0c3fc085, 0x0c4c4a2d,\n    0x0c51451f, 0x0c53ca9f, 0x0c5915ad, 0x0c648703,\n    0x0c800741, 0x0c838089, 0x0c83c129, 0x0c8441a9,\n    0x0c850089, 0x0c854129, 0x0c85c2a9, 0x0c870089,\n    0x0c87408f, 0x0c87808d, 0x0c881241, 0x0c910203,\n    0x0c940099, 0x0c9444a3, 0x0c968323, 0x0c98072d,\n    0x0c9b84af, 0x0c9dc2a1, 0x0c9f00b5, 0x0c9f40b3,\n    0x0c9f8085, 0x0ca01883, 0x0cac4223, 0x0cad4523,\n    0x0cafc097, 0x0cb004a1, 0x0cb241a5, 0x0cb30097,\n    0x0cb34099, 0x0cb38097, 0x0cb3c099, 0x0cb417ad,\n    0x0cbfc085, 0x0cc001b3, 0x0cc0c0b1, 0x0cc100b3,\n    0x0cc14131, 0x0cc1c0b5, 0x0cc200b3, 0x0cc241b1,\n    0x0cc30133, 0x0cc38131, 0x0cc40085, 0x0cc440b1,\n    0x0cc48133, 0x0cc50085, 0x0cc540b5, 0x0cc580b7,\n    0x0cc5c0b5, 0x0cc600b1, 0x0cc64135, 0x0cc6c0b3,\n    0x0cc701b1, 0x0cc7c0b3, 0x0cc800b5, 0x0cc840b3,\n    0x0cc881b1, 0x0cc9422f, 0x0cca4131, 0x0ccac0b5,\n    0x0ccb00b1, 0x0ccb40b3, 0x0ccb80b5, 0x0ccbc0b1,\n    0x0ccc012f, 0x0ccc80b5, 0x0cccc0b3, 0x0ccd00b5,\n    0x0ccd40b1, 0x0ccd80b5, 0x0ccdc085, 0x0cce02b1,\n    0x0ccf40b3, 0x0ccf80b1, 0x0ccfc085, 0x0cd001b1,\n    0x0cd0c0b3, 0x0cd101b1, 0x0cd1c0b5, 0x0cd200b3,\n    0x0cd24085, 0x0cd280b5, 0x0cd2c085, 0x0cd30133,\n    0x0cd381b1, 0x0cd440b3, 0x0cd48085, 0x0cd4c0b1,\n    0x0cd500b3, 0x0cd54085, 0x0cd580b5, 0x0cd5c0b1,\n    0x0cd60521, 0x0cd88525, 0x0cdb02a5, 0x0cdc4099,\n    0x0cdc8117, 0x0cdd0099, 0x0cdd4197, 0x0cde0127,\n    0x0cde8285, 0x0cdfc089, 0x0ce0043f, 0x0ce20099,\n    0x0ce2409b, 0x0ce283bf, 0x0ce44219, 0x0ce54205,\n    0x0ce6433f, 0x0ce7c131, 0x0ce84085, 0x0ce881b1,\n    0x0ce94085, 0x0ce98107, 0x0cea0089, 0x0cea4097,\n    0x0cea8219, 0x0ceb809d, 0x0cebc08d, 0x0cec083f,\n    0x0cf00105, 0x0cf0809b, 0x0cf0c197, 0x0cf1809b,\n    0x0cf1c099, 0x0cf20517, 0x0cf48099, 0x0cf4c117,\n    0x0cf54119, 0x0cf5c097, 0x0cf6009b, 0x0cf64099,\n    0x0cf68217, 0x0cf78119, 0x0cf804a1, 0x0cfa4525,\n    0x0cfcc525, 0x0cff4125, 0x0cffc099, 0x29a70103,\n    0x29dc0081, 0x29fc8195, 0x29fe0103, 0x2ad70203,\n    0x2ada4081, 0x3e401482, 0x3e4a7f82, 0x3e6a3f82,\n    0x3e8aa102, 0x3e9b0110, 0x3e9c2f82, 0x3eb3c590,\n    0x3ec00197, 0x3ec0c119, 0x3ec1413f, 0x3ec4c2af,\n    0x3ec74184, 0x3ec804ad, 0x3eca4081, 0x3eca8304,\n    0x3ecc03a0, 0x3ece02a0, 0x3ecf8084, 0x3ed00120,\n    0x3ed0c120, 0x3ed184ae, 0x3ed3c085, 0x3ed4312d,\n    0x3ef4cbad, 0x3efa892f, 0x3eff022d, 0x3f002f2f,\n    0x3f1782a5, 0x3f18c0b1, 0x3f1907af, 0x3f1cffaf,\n    0x3f3c81a5, 0x3f3d64af, 0x3f542031, 0x3f649b31,\n    0x3f7c0131, 0x3f7c83b3, 0x3f7e40b1, 0x3f7e80bd,\n    0x3f7ec0bb, 0x3f7f00b3, 0x3f840503, 0x3f8c01ad,\n    0x3f8cc315, 0x3f8e462d, 0x3f91cc03, 0x3f97c695,\n    0x3f9c01af, 0x3f9d0085, 0x3f9d852f, 0x3fa03aad,\n    0x3fbd442f, 0x3fc06f1f, 0x3fd7c11f, 0x3fd85fad,\n    0x3fe80081, 0x3fe84f1f, 0x3ff0831f, 0x3ff2831f,\n    0x3ff4831f, 0x3ff6819f, 0x3ff80783, 0x41e04d83,\n    0x41e70f91, 0x44268192, 0x442ac092, 0x444b8112,\n    0x44d2c112, 0x452ec212, 0x456e8112, 0x464e0092,\n    0x74578392, 0x746ec312, 0x75000d1f, 0x75068d1f,\n    0x750d0d1f, 0x7513839f, 0x7515891f, 0x751a0d1f,\n    0x75208d1f, 0x75271015, 0x752f439f, 0x7531459f,\n    0x75340d1f, 0x753a8d1f, 0x75410395, 0x7543441f,\n    0x7545839f, 0x75478d1f, 0x754e0795, 0x7552839f,\n    0x75548d1f, 0x755b0d1f, 0x75618d1f, 0x75680d1f,\n    0x756e8d1f, 0x75750d1f, 0x757b8d1f, 0x75820d1f,\n    0x75888d1f, 0x758f0d1f, 0x75958d1f, 0x759c0d1f,\n    0x75a28d1f, 0x75a90103, 0x75aa089f, 0x75ae4081,\n    0x75ae839f, 0x75b04081, 0x75b08c9f, 0x75b6c081,\n    0x75b7032d, 0x75b8889f, 0x75bcc081, 0x75bd039f,\n    0x75bec081, 0x75bf0c9f, 0x75c54081, 0x75c5832d,\n    0x75c7089f, 0x75cb4081, 0x75cb839f, 0x75cd4081,\n    0x75cd8c9f, 0x75d3c081, 0x75d4032d, 0x75d5889f,\n    0x75d9c081, 0x75da039f, 0x75dbc081, 0x75dc0c9f,\n    0x75e24081, 0x75e2832d, 0x75e4089f, 0x75e84081,\n    0x75e8839f, 0x75ea4081, 0x75ea8c9f, 0x75f0c081,\n    0x75f1042d, 0x75f3851f, 0x75f6051f, 0x75f8851f,\n    0x75fb051f, 0x75fd851f, 0x780c049f, 0x780e419f,\n    0x780f059f, 0x7811c203, 0x7812d0ad, 0x781b0103,\n    0x7b80022d, 0x7b814dad, 0x7b884203, 0x7b89c081,\n    0x7b8a452d, 0x7b8d0403, 0x7b908081, 0x7b91dc03,\n    0x7ba0052d, 0x7ba2c8ad, 0x7ba84483, 0x7baac8ad,\n    0x7c400097, 0x7c404521, 0x7c440d25, 0x7c4a8087,\n    0x7c4ac115, 0x7c4b4117, 0x7c4c0d1f, 0x7c528217,\n    0x7c538099, 0x7c53c097, 0x7c5a8197, 0x7c640097,\n    0x7c80012f, 0x7c808081, 0x7c841603, 0x7c9004c1,\n    0x7c940103, 0x7efc051f, 0xbe0001ac, 0xbe00d110,\n    0xbe0947ac, 0xbe0d3910, 0xbe29872c, 0xbe2d022c,\n    0xbe2e3790, 0xbe49ff90, 0xbe69bc10,\n};\n\nstatic const uint16_t unicode_decomp_table2[699] = {\n    0x0020, 0x0000, 0x0061, 0x0002, 0x0004, 0x0006, 0x03bc, 0x0008,\n    0x000a, 0x000c, 0x0015, 0x0095, 0x00a5, 0x00b9, 0x00c1, 0x00c3,\n    0x00c7, 0x00cb, 0x00d1, 0x00d7, 0x00dd, 0x00e0, 0x00e6, 0x00f8,\n    0x0108, 0x010a, 0x0073, 0x0110, 0x0112, 0x0114, 0x0120, 0x012c,\n    0x0144, 0x014d, 0x0153, 0x0162, 0x0168, 0x016a, 0x0176, 0x0192,\n    0x0194, 0x01a9, 0x01bb, 0x01c7, 0x01d1, 0x01d5, 0x02b9, 0x01d7,\n    0x003b, 0x01d9, 0x01db, 0x00b7, 0x01e1, 0x01fc, 0x020c, 0x0218,\n    0x021d, 0x0223, 0x0227, 0x03a3, 0x0233, 0x023f, 0x0242, 0x024b,\n    0x024e, 0x0251, 0x025d, 0x0260, 0x0269, 0x026c, 0x026f, 0x0275,\n    0x0278, 0x0281, 0x028a, 0x029c, 0x029f, 0x02a3, 0x02af, 0x02b9,\n    0x02c5, 0x02c9, 0x02cd, 0x02d1, 0x02d5, 0x02e7, 0x02ed, 0x02f1,\n    0x02f5, 0x02f9, 0x02fd, 0x0305, 0x0309, 0x030d, 0x0313, 0x0317,\n    0x031b, 0x0323, 0x0327, 0x032b, 0x032f, 0x0335, 0x033d, 0x0341,\n    0x0349, 0x034d, 0x0351, 0x0f0b, 0x0357, 0x035b, 0x035f, 0x0363,\n    0x0367, 0x036b, 0x036f, 0x0373, 0x0379, 0x037d, 0x0381, 0x0385,\n    0x0389, 0x038d, 0x0391, 0x0395, 0x0399, 0x039d, 0x03a1, 0x10dc,\n    0x03a5, 0x03c9, 0x03cd, 0x03d9, 0x03dd, 0x03e1, 0x03ef, 0x03f1,\n    0x043d, 0x044f, 0x0499, 0x04f0, 0x0502, 0x054a, 0x0564, 0x056c,\n    0x0570, 0x0573, 0x059a, 0x05fa, 0x05fe, 0x0607, 0x060b, 0x0614,\n    0x0618, 0x061e, 0x0622, 0x0628, 0x068e, 0x0694, 0x0698, 0x069e,\n    0x06a2, 0x06ab, 0x03ac, 0x06f3, 0x03ad, 0x06f6, 0x03ae, 0x06f9,\n    0x03af, 0x06fc, 0x03cc, 0x06ff, 0x03cd, 0x0702, 0x03ce, 0x0705,\n    0x0709, 0x070d, 0x0711, 0x0386, 0x0732, 0x0735, 0x03b9, 0x0737,\n    0x073b, 0x0388, 0x0753, 0x0389, 0x0756, 0x0390, 0x076b, 0x038a,\n    0x0777, 0x03b0, 0x0789, 0x038e, 0x0799, 0x079f, 0x07a3, 0x038c,\n    0x07b8, 0x038f, 0x07bb, 0x00b4, 0x07be, 0x07c0, 0x07c2, 0x2010,\n    0x07cb, 0x002e, 0x07cd, 0x07cf, 0x0020, 0x07d2, 0x07d6, 0x07db,\n    0x07df, 0x07e4, 0x07ea, 0x07f0, 0x0020, 0x07f6, 0x2212, 0x0801,\n    0x0805, 0x0807, 0x081d, 0x0825, 0x0827, 0x0043, 0x082d, 0x0830,\n    0x0190, 0x0836, 0x0839, 0x004e, 0x0845, 0x0847, 0x084c, 0x084e,\n    0x0851, 0x005a, 0x03a9, 0x005a, 0x0853, 0x0857, 0x0860, 0x0069,\n    0x0862, 0x0865, 0x086f, 0x0874, 0x087a, 0x087e, 0x08a2, 0x0049,\n    0x08a4, 0x08a6, 0x08a9, 0x0056, 0x08ab, 0x08ad, 0x08b0, 0x08b4,\n    0x0058, 0x08b6, 0x08b8, 0x08bb, 0x08c0, 0x08c2, 0x08c5, 0x0076,\n    0x08c7, 0x08c9, 0x08cc, 0x08d0, 0x0078, 0x08d2, 0x08d4, 0x08d7,\n    0x08db, 0x08de, 0x08e4, 0x08e7, 0x08f0, 0x08f3, 0x08f6, 0x08f9,\n    0x0902, 0x0906, 0x090b, 0x090f, 0x0914, 0x0917, 0x091a, 0x0923,\n    0x092c, 0x093b, 0x093e, 0x0941, 0x0944, 0x0947, 0x094a, 0x0956,\n    0x095c, 0x0960, 0x0962, 0x0964, 0x0968, 0x096a, 0x0970, 0x0978,\n    0x097c, 0x0980, 0x0986, 0x0989, 0x098f, 0x0991, 0x0030, 0x0993,\n    0x0999, 0x099c, 0x099e, 0x09a1, 0x09a4, 0x2d61, 0x6bcd, 0x9f9f,\n    0x09a6, 0x09b1, 0x09bc, 0x09c7, 0x0a95, 0x0aa1, 0x0b15, 0x0020,\n    0x0b27, 0x0b31, 0x0b8d, 0x0ba1, 0x0ba5, 0x0ba9, 0x0bad, 0x0bb1,\n    0x0bb5, 0x0bb9, 0x0bbd, 0x0bc1, 0x0bc5, 0x0c21, 0x0c35, 0x0c39,\n    0x0c3d, 0x0c41, 0x0c45, 0x0c49, 0x0c4d, 0x0c51, 0x0c55, 0x0c59,\n    0x0c6f, 0x0c71, 0x0c73, 0x0ca0, 0x0cbc, 0x0cdc, 0x0ce4, 0x0cec,\n    0x0cf4, 0x0cfc, 0x0d04, 0x0d0c, 0x0d14, 0x0d22, 0x0d2e, 0x0d7a,\n    0x0d82, 0x0d85, 0x0d89, 0x0d8d, 0x0d9d, 0x0db1, 0x0db5, 0x0dbc,\n    0x0dc2, 0x0dc6, 0x0e28, 0x0e2c, 0x0e30, 0x0e32, 0x0e36, 0x0e3c,\n    0x0e3e, 0x0e41, 0x0e43, 0x0e46, 0x0e77, 0x0e7b, 0x0e89, 0x0e8e,\n    0x0e94, 0x0e9c, 0x0ea3, 0x0ea9, 0x0eb4, 0x0ebe, 0x0ec6, 0x0eca,\n    0x0ecf, 0x0ed9, 0x0edd, 0x0ee4, 0x0eec, 0x0ef3, 0x0ef8, 0x0f04,\n    0x0f0a, 0x0f15, 0x0f1b, 0x0f22, 0x0f28, 0x0f33, 0x0f3d, 0x0f45,\n    0x0f4c, 0x0f51, 0x0f57, 0x0f5e, 0x0f63, 0x0f69, 0x0f70, 0x0f76,\n    0x0f7d, 0x0f82, 0x0f89, 0x0f8d, 0x0f9e, 0x0fa4, 0x0fa9, 0x0fad,\n    0x0fb8, 0x0fbe, 0x0fc9, 0x0fd0, 0x0fd6, 0x0fda, 0x0fe1, 0x0fe5,\n    0x0fef, 0x0ffa, 0x1000, 0x1004, 0x1009, 0x100f, 0x1013, 0x101a,\n    0x101f, 0x1023, 0x1029, 0x102f, 0x1032, 0x1036, 0x1039, 0x103f,\n    0x1045, 0x1059, 0x1061, 0x1079, 0x107c, 0x1080, 0x1095, 0x10a1,\n    0x10b1, 0x10c3, 0x10cb, 0x10cf, 0x10da, 0x10de, 0x10ea, 0x10f2,\n    0x10f4, 0x1100, 0x1105, 0x1111, 0x1141, 0x1149, 0x114d, 0x1153,\n    0x1157, 0x115a, 0x116e, 0x1171, 0x1175, 0x117b, 0x117d, 0x1181,\n    0x1184, 0x118c, 0x1192, 0x1196, 0x119c, 0x11a2, 0x11a8, 0x11ab,\n    0xa76f, 0x11af, 0x11b2, 0x11b6, 0x028d, 0x11be, 0x1210, 0x130e,\n    0x140c, 0x1490, 0x1495, 0x1553, 0x156c, 0x1572, 0x1578, 0x157e,\n    0x158a, 0x1596, 0x002b, 0x15a1, 0x15b9, 0x15bd, 0x15c1, 0x15c5,\n    0x15c9, 0x15cd, 0x15e1, 0x15e5, 0x1649, 0x1662, 0x1688, 0x168e,\n    0x174c, 0x1752, 0x1757, 0x1777, 0x1877, 0x187d, 0x1911, 0x19d3,\n    0x1a77, 0x1a7f, 0x1a9d, 0x1aa2, 0x1ab6, 0x1ac0, 0x1ac6, 0x1ada,\n    0x1adf, 0x1ae5, 0x1af3, 0x1b23, 0x1b30, 0x1b38, 0x1b3c, 0x1b52,\n    0x1bc9, 0x1bdb, 0x1bdd, 0x1bdf, 0x3164, 0x1c20, 0x1c22, 0x1c24,\n    0x1c26, 0x1c28, 0x1c2a, 0x1c48, 0x1c7e, 0x1cc4, 0x1cd2, 0x1cd7,\n    0x1ce0, 0x1ce9, 0x1cfb, 0x1d04, 0x1d09, 0x1d29, 0x1d44, 0x1d46,\n    0x1d48, 0x1d4a, 0x1d4c, 0x1d4e, 0x1d50, 0x1d52, 0x1d72, 0x1d74,\n    0x1d76, 0x1d78, 0x1d7a, 0x1d81, 0x1d83, 0x1d85, 0x1d87, 0x1d96,\n    0x1d98, 0x1d9a, 0x1d9c, 0x1d9e, 0x1da0, 0x1da2, 0x1da4, 0x1da6,\n    0x1da8, 0x1daa, 0x1dac, 0x1dae, 0x1db0, 0x1db2, 0x1db6, 0x03f4,\n    0x1db8, 0x2207, 0x1dba, 0x2202, 0x1dbc, 0x1dc4, 0x03f4, 0x1dc6,\n    0x2207, 0x1dc8, 0x2202, 0x1dca, 0x1dd2, 0x03f4, 0x1dd4, 0x2207,\n    0x1dd6, 0x2202, 0x1dd8, 0x1de0, 0x03f4, 0x1de2, 0x2207, 0x1de4,\n    0x2202, 0x1de6, 0x1dee, 0x03f4, 0x1df0, 0x2207, 0x1df2, 0x2202,\n    0x1df4, 0x1dfe, 0x1e00, 0x1e02, 0x1e04, 0x1e06, 0x1e08, 0x1e0a,\n    0x1e0c, 0x1e0e, 0x1e16, 0x1e39, 0x1e3d, 0x1e43, 0x1e60, 0x062d,\n    0x1e68, 0x1e74, 0x062c, 0x1e84, 0x1ef4, 0x1f00, 0x1f13, 0x1f25,\n    0x1f38, 0x1f3a, 0x1f3e, 0x1f44, 0x1f4a, 0x1f4c, 0x1f50, 0x1f52,\n    0x1f5a, 0x1f5d, 0x1f5f, 0x1f65, 0x1f67, 0x30b5, 0x1f6d, 0x1fc5,\n    0x1fdb, 0x1fdf, 0x1fe1, 0x1fe6, 0x2033, 0x2044, 0x2145, 0x2155,\n    0x215b, 0x2255, 0x2373,\n};\n\nstatic const uint8_t unicode_decomp_data[9345] = {\n    0x20, 0x88, 0x20, 0x84, 0x32, 0x33, 0x20, 0x81,\n    0x20, 0xa7, 0x31, 0x6f, 0x31, 0xd0, 0x34, 0x31,\n    0xd0, 0x32, 0x33, 0xd0, 0x34, 0x41, 0x80, 0x41,\n    0x81, 0x41, 0x82, 0x41, 0x83, 0x41, 0x88, 0x41,\n    0x8a, 0x00, 0x00, 0x43, 0xa7, 0x45, 0x80, 0x45,\n    0x81, 0x45, 0x82, 0x45, 0x88, 0x49, 0x80, 0x49,\n    0x81, 0x49, 0x82, 0x49, 0x88, 0x00, 0x00, 0x4e,\n    0x83, 0x4f, 0x80, 0x4f, 0x81, 0x4f, 0x82, 0x4f,\n    0x83, 0x4f, 0x88, 0x00, 0x00, 0x00, 0x00, 0x55,\n    0x80, 0x55, 0x81, 0x55, 0x82, 0x55, 0x88, 0x59,\n    0x81, 0x00, 0x00, 0x00, 0x00, 0x61, 0x80, 0x61,\n    0x81, 0x61, 0x82, 0x61, 0x83, 0x61, 0x88, 0x61,\n    0x8a, 0x00, 0x00, 0x63, 0xa7, 0x65, 0x80, 0x65,\n    0x81, 0x65, 0x82, 0x65, 0x88, 0x69, 0x80, 0x69,\n    0x81, 0x69, 0x82, 0x69, 0x88, 0x00, 0x00, 0x6e,\n    0x83, 0x6f, 0x80, 0x6f, 0x81, 0x6f, 0x82, 0x6f,\n    0x83, 0x6f, 0x88, 0x00, 0x00, 0x00, 0x00, 0x75,\n    0x80, 0x75, 0x81, 0x75, 0x82, 0x75, 0x88, 0x79,\n    0x81, 0x00, 0x00, 0x79, 0x88, 0x41, 0x84, 0x41,\n    0x86, 0x41, 0xa8, 0x43, 0x81, 0x43, 0x82, 0x43,\n    0x87, 0x43, 0x8c, 0x44, 0x8c, 0x45, 0x84, 0x45,\n    0x86, 0x45, 0x87, 0x45, 0xa8, 0x45, 0x8c, 0x47,\n    0x82, 0x47, 0x86, 0x47, 0x87, 0x47, 0xa7, 0x48,\n    0x82, 0x49, 0x83, 0x49, 0x84, 0x49, 0x86, 0x49,\n    0xa8, 0x49, 0x87, 0x49, 0x4a, 0x69, 0x6a, 0x4a,\n    0x82, 0x4b, 0xa7, 0x4c, 0x81, 0x4c, 0xa7, 0x4c,\n    0x8c, 0x4c, 0x00, 0x00, 0x6b, 0x20, 0x6b, 0x4e,\n    0x81, 0x4e, 0xa7, 0x4e, 0x8c, 0xbc, 0x02, 0x6e,\n    0x4f, 0x84, 0x4f, 0x86, 0x4f, 0x8b, 0x52, 0x81,\n    0x52, 0xa7, 0x52, 0x8c, 0x53, 0x81, 0x53, 0x82,\n    0x53, 0xa7, 0x53, 0x8c, 0x54, 0xa7, 0x54, 0x8c,\n    0x55, 0x83, 0x55, 0x84, 0x55, 0x86, 0x55, 0x8a,\n    0x55, 0x8b, 0x55, 0xa8, 0x57, 0x82, 0x59, 0x82,\n    0x59, 0x88, 0x5a, 0x81, 0x5a, 0x87, 0x5a, 0x8c,\n    0x4f, 0x9b, 0x55, 0x9b, 0x44, 0x00, 0x7d, 0x01,\n    0x44, 0x00, 0x7e, 0x01, 0x64, 0x00, 0x7e, 0x01,\n    0x4c, 0x4a, 0x4c, 0x6a, 0x6c, 0x6a, 0x4e, 0x4a,\n    0x4e, 0x6a, 0x6e, 0x6a, 0x41, 0x00, 0x8c, 0x49,\n    0x00, 0x8c, 0x4f, 0x00, 0x8c, 0x55, 0x00, 0x8c,\n    0xdc, 0x00, 0x84, 0xdc, 0x00, 0x81, 0xdc, 0x00,\n    0x8c, 0xdc, 0x00, 0x80, 0xc4, 0x00, 0x84, 0x26,\n    0x02, 0x84, 0xc6, 0x00, 0x84, 0x47, 0x8c, 0x4b,\n    0x8c, 0x4f, 0xa8, 0xea, 0x01, 0x84, 0xeb, 0x01,\n    0x84, 0xb7, 0x01, 0x8c, 0x92, 0x02, 0x8c, 0x6a,\n    0x00, 0x8c, 0x44, 0x5a, 0x44, 0x7a, 0x64, 0x7a,\n    0x47, 0x81, 0x4e, 0x00, 0x80, 0xc5, 0x00, 0x81,\n    0xc6, 0x00, 0x81, 0xd8, 0x00, 0x81, 0x41, 0x8f,\n    0x41, 0x91, 0x45, 0x8f, 0x45, 0x91, 0x49, 0x8f,\n    0x49, 0x91, 0x4f, 0x8f, 0x4f, 0x91, 0x52, 0x8f,\n    0x52, 0x91, 0x55, 0x8f, 0x55, 0x91, 0x53, 0xa6,\n    0x54, 0xa6, 0x48, 0x8c, 0x41, 0x00, 0x87, 0x45,\n    0x00, 0xa7, 0xd6, 0x00, 0x84, 0xd5, 0x00, 0x84,\n    0x4f, 0x00, 0x87, 0x2e, 0x02, 0x84, 0x59, 0x00,\n    0x84, 0x68, 0x00, 0x66, 0x02, 0x6a, 0x00, 0x72,\n    0x00, 0x79, 0x02, 0x7b, 0x02, 0x81, 0x02, 0x77,\n    0x00, 0x79, 0x00, 0x20, 0x86, 0x20, 0x87, 0x20,\n    0x8a, 0x20, 0xa8, 0x20, 0x83, 0x20, 0x8b, 0x63,\n    0x02, 0x6c, 0x00, 0x73, 0x00, 0x78, 0x00, 0x95,\n    0x02, 0x80, 0x81, 0x00, 0x93, 0x88, 0x81, 0x20,\n    0xc5, 0x20, 0x81, 0xa8, 0x00, 0x81, 0x91, 0x03,\n    0x81, 0x95, 0x03, 0x81, 0x97, 0x03, 0x81, 0x99,\n    0x03, 0x81, 0x00, 0x00, 0x00, 0x9f, 0x03, 0x81,\n    0x00, 0x00, 0x00, 0xa5, 0x03, 0x81, 0xa9, 0x03,\n    0x81, 0xca, 0x03, 0x81, 0x01, 0x03, 0x98, 0x07,\n    0xa4, 0x07, 0xb0, 0x00, 0xb4, 0x00, 0xb6, 0x00,\n    0xb8, 0x00, 0xca, 0x00, 0x01, 0x03, 0xb8, 0x07,\n    0xc4, 0x07, 0xbe, 0x00, 0xc4, 0x00, 0xc8, 0x00,\n    0xa5, 0x03, 0x0d, 0x13, 0x00, 0x01, 0x03, 0xd1,\n    0x00, 0xd1, 0x07, 0xc6, 0x03, 0xc0, 0x03, 0xba,\n    0x03, 0xc1, 0x03, 0xc2, 0x03, 0x00, 0x00, 0x98,\n    0x03, 0xb5, 0x03, 0x15, 0x04, 0x80, 0x15, 0x04,\n    0x88, 0x00, 0x00, 0x00, 0x13, 0x04, 0x81, 0x06,\n    0x04, 0x88, 0x1a, 0x04, 0x81, 0x18, 0x04, 0x80,\n    0x23, 0x04, 0x86, 0x18, 0x04, 0x86, 0x38, 0x04,\n    0x86, 0x35, 0x04, 0x80, 0x35, 0x04, 0x88, 0x00,\n    0x00, 0x00, 0x33, 0x04, 0x81, 0x56, 0x04, 0x88,\n    0x3a, 0x04, 0x81, 0x38, 0x04, 0x80, 0x43, 0x04,\n    0x86, 0x74, 0x04, 0x8f, 0x16, 0x04, 0x86, 0x10,\n    0x04, 0x86, 0x10, 0x04, 0x88, 0x15, 0x04, 0x86,\n    0xd8, 0x04, 0x88, 0x16, 0x04, 0x88, 0x17, 0x04,\n    0x88, 0x18, 0x04, 0x84, 0x18, 0x04, 0x88, 0x1e,\n    0x04, 0x88, 0xe8, 0x04, 0x88, 0x2d, 0x04, 0x88,\n    0x23, 0x04, 0x84, 0x23, 0x04, 0x88, 0x23, 0x04,\n    0x8b, 0x27, 0x04, 0x88, 0x2b, 0x04, 0x88, 0x65,\n    0x05, 0x82, 0x05, 0x27, 0x06, 0x00, 0x2c, 0x00,\n    0x2d, 0x21, 0x2d, 0x00, 0x2e, 0x23, 0x2d, 0x27,\n    0x06, 0x00, 0x4d, 0x21, 0x4d, 0xa0, 0x4d, 0x23,\n    0x4d, 0xd5, 0x06, 0x54, 0x06, 0x00, 0x00, 0x00,\n    0x00, 0xc1, 0x06, 0x54, 0x06, 0xd2, 0x06, 0x54,\n    0x06, 0x28, 0x09, 0x3c, 0x09, 0x30, 0x09, 0x3c,\n    0x09, 0x33, 0x09, 0x3c, 0x09, 0x15, 0x09, 0x00,\n    0x27, 0x01, 0x27, 0x02, 0x27, 0x07, 0x27, 0x0c,\n    0x27, 0x0d, 0x27, 0x16, 0x27, 0x1a, 0x27, 0xbe,\n    0x09, 0x09, 0x00, 0x09, 0x19, 0xa1, 0x09, 0xbc,\n    0x09, 0xaf, 0x09, 0xbc, 0x09, 0x32, 0x0a, 0x3c,\n    0x0a, 0x38, 0x0a, 0x3c, 0x0a, 0x16, 0x0a, 0x00,\n    0x26, 0x01, 0x26, 0x06, 0x26, 0x2b, 0x0a, 0x3c,\n    0x0a, 0x47, 0x0b, 0x56, 0x0b, 0x3e, 0x0b, 0x09,\n    0x00, 0x09, 0x19, 0x21, 0x0b, 0x3c, 0x0b, 0x92,\n    0x0b, 0xd7, 0x0b, 0xbe, 0x0b, 0x08, 0x00, 0x09,\n    0x00, 0x08, 0x19, 0x46, 0x0c, 0x56, 0x0c, 0xbf,\n    0x0c, 0xd5, 0x0c, 0xc6, 0x0c, 0xd5, 0x0c, 0xc2,\n    0x0c, 0x04, 0x00, 0x08, 0x13, 0x3e, 0x0d, 0x08,\n    0x00, 0x09, 0x00, 0x08, 0x19, 0xd9, 0x0d, 0xca,\n    0x0d, 0xca, 0x0d, 0x0f, 0x05, 0x12, 0x00, 0x0f,\n    0x15, 0x4d, 0x0e, 0x32, 0x0e, 0xcd, 0x0e, 0xb2,\n    0x0e, 0x99, 0x0e, 0x12, 0x00, 0x12, 0x08, 0x42,\n    0x0f, 0xb7, 0x0f, 0x4c, 0x0f, 0xb7, 0x0f, 0x51,\n    0x0f, 0xb7, 0x0f, 0x56, 0x0f, 0xb7, 0x0f, 0x5b,\n    0x0f, 0xb7, 0x0f, 0x40, 0x0f, 0xb5, 0x0f, 0x71,\n    0x0f, 0x72, 0x0f, 0x71, 0x0f, 0x00, 0x03, 0x41,\n    0x0f, 0xb2, 0x0f, 0x81, 0x0f, 0xb3, 0x0f, 0x80,\n    0x0f, 0xb3, 0x0f, 0x81, 0x0f, 0x71, 0x0f, 0x80,\n    0x0f, 0x92, 0x0f, 0xb7, 0x0f, 0x9c, 0x0f, 0xb7,\n    0x0f, 0xa1, 0x0f, 0xb7, 0x0f, 0xa6, 0x0f, 0xb7,\n    0x0f, 0xab, 0x0f, 0xb7, 0x0f, 0x90, 0x0f, 0xb5,\n    0x0f, 0x25, 0x10, 0x2e, 0x10, 0x05, 0x1b, 0x35,\n    0x1b, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1b, 0x35,\n    0x1b, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1b, 0x35,\n    0x1b, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x1b, 0x35,\n    0x1b, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x1b, 0x35,\n    0x1b, 0x11, 0x1b, 0x35, 0x1b, 0x3a, 0x1b, 0x35,\n    0x1b, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x1b, 0x35,\n    0x1b, 0x3e, 0x1b, 0x35, 0x1b, 0x42, 0x1b, 0x35,\n    0x1b, 0x41, 0x00, 0xc6, 0x00, 0x42, 0x00, 0x00,\n    0x00, 0x44, 0x00, 0x45, 0x00, 0x8e, 0x01, 0x47,\n    0x00, 0x4f, 0x00, 0x22, 0x02, 0x50, 0x00, 0x52,\n    0x00, 0x54, 0x00, 0x55, 0x00, 0x57, 0x00, 0x61,\n    0x00, 0x50, 0x02, 0x51, 0x02, 0x02, 0x1d, 0x62,\n    0x00, 0x64, 0x00, 0x65, 0x00, 0x59, 0x02, 0x5b,\n    0x02, 0x5c, 0x02, 0x67, 0x00, 0x00, 0x00, 0x6b,\n    0x00, 0x6d, 0x00, 0x4b, 0x01, 0x6f, 0x00, 0x54,\n    0x02, 0x16, 0x1d, 0x17, 0x1d, 0x70, 0x00, 0x74,\n    0x00, 0x75, 0x00, 0x1d, 0x1d, 0x6f, 0x02, 0x76,\n    0x00, 0x25, 0x1d, 0xb2, 0x03, 0xb3, 0x03, 0xb4,\n    0x03, 0xc6, 0x03, 0xc7, 0x03, 0x69, 0x00, 0x72,\n    0x00, 0x75, 0x00, 0x76, 0x00, 0xb2, 0x03, 0xb3,\n    0x03, 0xc1, 0x03, 0xc6, 0x03, 0xc7, 0x03, 0x52,\n    0x02, 0x63, 0x00, 0x55, 0x02, 0xf0, 0x00, 0x5c,\n    0x02, 0x66, 0x00, 0x5f, 0x02, 0x61, 0x02, 0x65,\n    0x02, 0x68, 0x02, 0x69, 0x02, 0x6a, 0x02, 0x7b,\n    0x1d, 0x9d, 0x02, 0x6d, 0x02, 0x85, 0x1d, 0x9f,\n    0x02, 0x71, 0x02, 0x70, 0x02, 0x72, 0x02, 0x73,\n    0x02, 0x74, 0x02, 0x75, 0x02, 0x78, 0x02, 0x82,\n    0x02, 0x83, 0x02, 0xab, 0x01, 0x89, 0x02, 0x8a,\n    0x02, 0x1c, 0x1d, 0x8b, 0x02, 0x8c, 0x02, 0x7a,\n    0x00, 0x90, 0x02, 0x91, 0x02, 0x92, 0x02, 0xb8,\n    0x03, 0x41, 0x00, 0xa5, 0x42, 0x00, 0x87, 0x42,\n    0x00, 0xa3, 0x42, 0x00, 0xb1, 0xc7, 0x00, 0x81,\n    0x44, 0x00, 0x87, 0x44, 0x00, 0xa3, 0x44, 0x00,\n    0xb1, 0x44, 0x00, 0xa7, 0x44, 0x00, 0xad, 0x12,\n    0x01, 0x80, 0x12, 0x01, 0x81, 0x45, 0x00, 0xad,\n    0x45, 0x00, 0xb0, 0x28, 0x02, 0x86, 0x46, 0x00,\n    0x87, 0x47, 0x00, 0x84, 0x48, 0x00, 0x87, 0x48,\n    0x00, 0xa3, 0x48, 0x00, 0x88, 0x48, 0x00, 0xa7,\n    0x48, 0x00, 0xae, 0x49, 0x00, 0xb0, 0xcf, 0x00,\n    0x81, 0x4b, 0x00, 0x81, 0x4b, 0x00, 0xa3, 0x4b,\n    0x00, 0xb1, 0x4c, 0x00, 0xa3, 0x36, 0x1e, 0x84,\n    0x4c, 0xb1, 0x4c, 0xad, 0x4d, 0x81, 0x4d, 0x87,\n    0x4d, 0xa3, 0x4e, 0x87, 0x4e, 0xa3, 0x4e, 0xb1,\n    0x4e, 0xad, 0xd5, 0x00, 0x81, 0xd5, 0x00, 0x88,\n    0x4c, 0x01, 0x80, 0x4c, 0x01, 0x81, 0x50, 0x00,\n    0x81, 0x50, 0x00, 0x87, 0x52, 0x00, 0x87, 0x52,\n    0x00, 0xa3, 0x5a, 0x1e, 0x84, 0x52, 0x00, 0xb1,\n    0x53, 0x00, 0x87, 0x53, 0x00, 0xa3, 0x5a, 0x01,\n    0x87, 0x60, 0x01, 0x87, 0x62, 0x1e, 0x87, 0x54,\n    0x00, 0x87, 0x54, 0x00, 0xa3, 0x54, 0x00, 0xb1,\n    0x54, 0x00, 0xad, 0x55, 0x00, 0xa4, 0x55, 0x00,\n    0xb0, 0x55, 0x00, 0xad, 0x68, 0x01, 0x81, 0x6a,\n    0x01, 0x88, 0x56, 0x83, 0x56, 0xa3, 0x57, 0x80,\n    0x57, 0x81, 0x57, 0x88, 0x57, 0x87, 0x57, 0xa3,\n    0x58, 0x87, 0x58, 0x88, 0x59, 0x87, 0x5a, 0x82,\n    0x5a, 0xa3, 0x5a, 0xb1, 0x68, 0xb1, 0x74, 0x88,\n    0x77, 0x8a, 0x79, 0x8a, 0x61, 0x00, 0xbe, 0x02,\n    0x7f, 0x01, 0x87, 0x41, 0x00, 0xa3, 0x41, 0x00,\n    0x89, 0xc2, 0x00, 0x81, 0xc2, 0x00, 0x80, 0xc2,\n    0x00, 0x89, 0xc2, 0x00, 0x83, 0xa0, 0x1e, 0x82,\n    0x02, 0x01, 0x81, 0x02, 0x01, 0x80, 0x02, 0x01,\n    0x89, 0x02, 0x01, 0x83, 0xa0, 0x1e, 0x86, 0x45,\n    0x00, 0xa3, 0x45, 0x00, 0x89, 0x45, 0x00, 0x83,\n    0xca, 0x00, 0x81, 0xca, 0x00, 0x80, 0xca, 0x00,\n    0x89, 0xca, 0x00, 0x83, 0xb8, 0x1e, 0x82, 0x49,\n    0x00, 0x89, 0x49, 0x00, 0xa3, 0x4f, 0x00, 0xa3,\n    0x4f, 0x00, 0x89, 0xd4, 0x00, 0x81, 0xd4, 0x00,\n    0x80, 0xd4, 0x00, 0x89, 0xd4, 0x00, 0x83, 0xcc,\n    0x1e, 0x82, 0xa0, 0x01, 0x81, 0xa0, 0x01, 0x80,\n    0xa0, 0x01, 0x89, 0xa0, 0x01, 0x83, 0xa0, 0x01,\n    0xa3, 0x55, 0x00, 0xa3, 0x55, 0x00, 0x89, 0xaf,\n    0x01, 0x81, 0xaf, 0x01, 0x80, 0xaf, 0x01, 0x89,\n    0xaf, 0x01, 0x83, 0xaf, 0x01, 0xa3, 0x59, 0x00,\n    0x80, 0x59, 0x00, 0xa3, 0x59, 0x00, 0x89, 0x59,\n    0x00, 0x83, 0xb1, 0x03, 0x13, 0x03, 0x00, 0x1f,\n    0x80, 0x00, 0x1f, 0x81, 0x00, 0x1f, 0xc2, 0x91,\n    0x03, 0x13, 0x03, 0x08, 0x1f, 0x80, 0x08, 0x1f,\n    0x81, 0x08, 0x1f, 0xc2, 0xb5, 0x03, 0x13, 0x03,\n    0x10, 0x1f, 0x80, 0x10, 0x1f, 0x81, 0x95, 0x03,\n    0x13, 0x03, 0x18, 0x1f, 0x80, 0x18, 0x1f, 0x81,\n    0xb7, 0x03, 0x93, 0xb7, 0x03, 0x94, 0x20, 0x1f,\n    0x80, 0x21, 0x1f, 0x80, 0x20, 0x1f, 0x81, 0x21,\n    0x1f, 0x81, 0x20, 0x1f, 0xc2, 0x21, 0x1f, 0xc2,\n    0x97, 0x03, 0x93, 0x97, 0x03, 0x94, 0x28, 0x1f,\n    0x80, 0x29, 0x1f, 0x80, 0x28, 0x1f, 0x81, 0x29,\n    0x1f, 0x81, 0x28, 0x1f, 0xc2, 0x29, 0x1f, 0xc2,\n    0xb9, 0x03, 0x93, 0xb9, 0x03, 0x94, 0x30, 0x1f,\n    0x80, 0x31, 0x1f, 0x80, 0x30, 0x1f, 0x81, 0x31,\n    0x1f, 0x81, 0x30, 0x1f, 0xc2, 0x31, 0x1f, 0xc2,\n    0x99, 0x03, 0x93, 0x99, 0x03, 0x94, 0x38, 0x1f,\n    0x80, 0x39, 0x1f, 0x80, 0x38, 0x1f, 0x81, 0x39,\n    0x1f, 0x81, 0x38, 0x1f, 0xc2, 0x39, 0x1f, 0xc2,\n    0xbf, 0x03, 0x93, 0xbf, 0x03, 0x94, 0x40, 0x1f,\n    0x80, 0x40, 0x1f, 0x81, 0x9f, 0x03, 0x13, 0x03,\n    0x48, 0x1f, 0x80, 0x48, 0x1f, 0x81, 0xc5, 0x03,\n    0x13, 0x03, 0x50, 0x1f, 0x80, 0x50, 0x1f, 0x81,\n    0x50, 0x1f, 0xc2, 0xa5, 0x03, 0x94, 0x00, 0x00,\n    0x00, 0x59, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x59,\n    0x1f, 0x81, 0x00, 0x00, 0x00, 0x59, 0x1f, 0xc2,\n    0xc9, 0x03, 0x93, 0xc9, 0x03, 0x94, 0x60, 0x1f,\n    0x80, 0x61, 0x1f, 0x80, 0x60, 0x1f, 0x81, 0x61,\n    0x1f, 0x81, 0x60, 0x1f, 0xc2, 0x61, 0x1f, 0xc2,\n    0xa9, 0x03, 0x93, 0xa9, 0x03, 0x94, 0x68, 0x1f,\n    0x80, 0x69, 0x1f, 0x80, 0x68, 0x1f, 0x81, 0x69,\n    0x1f, 0x81, 0x68, 0x1f, 0xc2, 0x69, 0x1f, 0xc2,\n    0xb1, 0x03, 0x80, 0xb5, 0x03, 0x80, 0xb7, 0x03,\n    0x80, 0xb9, 0x03, 0x80, 0xbf, 0x03, 0x80, 0xc5,\n    0x03, 0x80, 0xc9, 0x03, 0x80, 0x00, 0x1f, 0x45,\n    0x03, 0x20, 0x1f, 0x45, 0x03, 0x60, 0x1f, 0x45,\n    0x03, 0xb1, 0x03, 0x86, 0xb1, 0x03, 0x84, 0x70,\n    0x1f, 0xc5, 0xb1, 0x03, 0xc5, 0xac, 0x03, 0xc5,\n    0x00, 0x00, 0x00, 0xb1, 0x03, 0xc2, 0xb6, 0x1f,\n    0xc5, 0x91, 0x03, 0x86, 0x91, 0x03, 0x84, 0x91,\n    0x03, 0x80, 0x91, 0x03, 0xc5, 0x20, 0x93, 0x20,\n    0x93, 0x20, 0xc2, 0xa8, 0x00, 0xc2, 0x74, 0x1f,\n    0xc5, 0xb7, 0x03, 0xc5, 0xae, 0x03, 0xc5, 0x00,\n    0x00, 0x00, 0xb7, 0x03, 0xc2, 0xc6, 0x1f, 0xc5,\n    0x95, 0x03, 0x80, 0x97, 0x03, 0x80, 0x97, 0x03,\n    0xc5, 0xbf, 0x1f, 0x80, 0xbf, 0x1f, 0x81, 0xbf,\n    0x1f, 0xc2, 0xb9, 0x03, 0x86, 0xb9, 0x03, 0x84,\n    0xca, 0x03, 0x80, 0x00, 0x03, 0xb9, 0x42, 0xca,\n    0x42, 0x99, 0x06, 0x99, 0x04, 0x99, 0x00, 0xfe,\n    0x1f, 0x80, 0xfe, 0x1f, 0x81, 0xfe, 0x1f, 0xc2,\n    0xc5, 0x03, 0x86, 0xc5, 0x03, 0x84, 0xcb, 0x03,\n    0x80, 0x00, 0x03, 0xc1, 0x13, 0xc1, 0x14, 0xc5,\n    0x42, 0xcb, 0x42, 0xa5, 0x06, 0xa5, 0x04, 0xa5,\n    0x00, 0xa1, 0x03, 0x94, 0xa8, 0x00, 0x80, 0x85,\n    0x03, 0x60, 0x00, 0x7c, 0x1f, 0xc5, 0xc9, 0x03,\n    0xc5, 0xce, 0x03, 0xc5, 0x00, 0x00, 0x00, 0xc9,\n    0x03, 0xc2, 0xf6, 0x1f, 0xc5, 0x9f, 0x03, 0x80,\n    0xa9, 0x03, 0x80, 0xa9, 0x03, 0xc5, 0x20, 0x94,\n    0x02, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n    0x20, 0x20, 0x20, 0x20, 0xb3, 0x2e, 0x2e, 0x2e,\n    0x2e, 0x2e, 0x32, 0x20, 0x32, 0x20, 0x32, 0x20,\n    0x00, 0x00, 0x00, 0x35, 0x20, 0x35, 0x20, 0x35,\n    0x20, 0x00, 0x00, 0x00, 0x21, 0x21, 0x00, 0x00,\n    0x20, 0x85, 0x3f, 0x3f, 0x3f, 0x21, 0x21, 0x3f,\n    0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x30, 0x69,\n    0x00, 0x00, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,\n    0x2b, 0x3d, 0x28, 0x29, 0x6e, 0x30, 0x00, 0x2b,\n    0x00, 0x12, 0x22, 0x3d, 0x00, 0x28, 0x00, 0x29,\n    0x00, 0x00, 0x00, 0x61, 0x00, 0x65, 0x00, 0x6f,\n    0x00, 0x78, 0x00, 0x59, 0x02, 0x68, 0x6b, 0x6c,\n    0x6d, 0x6e, 0x70, 0x73, 0x74, 0x52, 0x73, 0x61,\n    0x2f, 0x63, 0x61, 0x2f, 0x73, 0xb0, 0x00, 0x43,\n    0x63, 0x2f, 0x6f, 0x63, 0x2f, 0x75, 0xb0, 0x00,\n    0x46, 0x48, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x20,\n    0xdf, 0x01, 0x01, 0x04, 0x24, 0x4e, 0x6f, 0x50,\n    0x51, 0x52, 0x52, 0x52, 0x53, 0x4d, 0x54, 0x45,\n    0x4c, 0x54, 0x4d, 0x4b, 0x00, 0xc5, 0x00, 0x42,\n    0x43, 0x00, 0x65, 0x45, 0x46, 0x00, 0x4d, 0x6f,\n    0xd0, 0x05, 0x46, 0x41, 0x58, 0xc0, 0x03, 0xb3,\n    0x03, 0x93, 0x03, 0xa0, 0x03, 0x11, 0x22, 0x44,\n    0x64, 0x65, 0x69, 0x6a, 0x31, 0xd0, 0x37, 0x31,\n    0xd0, 0x39, 0x31, 0xd0, 0x31, 0x30, 0x31, 0xd0,\n    0x33, 0x32, 0xd0, 0x33, 0x31, 0xd0, 0x35, 0x32,\n    0xd0, 0x35, 0x33, 0xd0, 0x35, 0x34, 0xd0, 0x35,\n    0x31, 0xd0, 0x36, 0x35, 0xd0, 0x36, 0x31, 0xd0,\n    0x38, 0x33, 0xd0, 0x38, 0x35, 0xd0, 0x38, 0x37,\n    0xd0, 0x38, 0x31, 0xd0, 0x49, 0x49, 0x49, 0x49,\n    0x49, 0x49, 0x56, 0x56, 0x49, 0x56, 0x49, 0x49,\n    0x56, 0x49, 0x49, 0x49, 0x49, 0x58, 0x58, 0x49,\n    0x58, 0x49, 0x49, 0x4c, 0x43, 0x44, 0x4d, 0x69,\n    0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x76, 0x76,\n    0x69, 0x76, 0x69, 0x69, 0x76, 0x69, 0x69, 0x69,\n    0x69, 0x78, 0x78, 0x69, 0x78, 0x69, 0x69, 0x6c,\n    0x63, 0x64, 0x6d, 0x30, 0xd0, 0x33, 0x90, 0x21,\n    0xb8, 0x92, 0x21, 0xb8, 0x94, 0x21, 0xb8, 0xd0,\n    0x21, 0xb8, 0xd4, 0x21, 0xb8, 0xd2, 0x21, 0xb8,\n    0x03, 0x22, 0xb8, 0x08, 0x22, 0xb8, 0x0b, 0x22,\n    0xb8, 0x23, 0x22, 0xb8, 0x00, 0x00, 0x00, 0x25,\n    0x22, 0xb8, 0x2b, 0x22, 0x2b, 0x22, 0x2b, 0x22,\n    0x00, 0x00, 0x00, 0x2e, 0x22, 0x2e, 0x22, 0x2e,\n    0x22, 0x00, 0x00, 0x00, 0x3c, 0x22, 0xb8, 0x43,\n    0x22, 0xb8, 0x45, 0x22, 0xb8, 0x00, 0x00, 0x00,\n    0x48, 0x22, 0xb8, 0x3d, 0x00, 0xb8, 0x00, 0x00,\n    0x00, 0x61, 0x22, 0xb8, 0x4d, 0x22, 0xb8, 0x3c,\n    0x00, 0xb8, 0x3e, 0x00, 0xb8, 0x64, 0x22, 0xb8,\n    0x65, 0x22, 0xb8, 0x72, 0x22, 0xb8, 0x76, 0x22,\n    0xb8, 0x7a, 0x22, 0xb8, 0x82, 0x22, 0xb8, 0x86,\n    0x22, 0xb8, 0xa2, 0x22, 0xb8, 0xa8, 0x22, 0xb8,\n    0xa9, 0x22, 0xb8, 0xab, 0x22, 0xb8, 0x7c, 0x22,\n    0xb8, 0x91, 0x22, 0xb8, 0xb2, 0x22, 0x38, 0x03,\n    0x08, 0x30, 0x31, 0x00, 0x31, 0x00, 0x30, 0x00,\n    0x32, 0x30, 0x28, 0x00, 0x31, 0x00, 0x29, 0x00,\n    0x28, 0x00, 0x31, 0x00, 0x30, 0x00, 0x29, 0x00,\n    0x28, 0x32, 0x30, 0x29, 0x31, 0x00, 0x2e, 0x00,\n    0x31, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x32, 0x30,\n    0x2e, 0x28, 0x00, 0x61, 0x00, 0x29, 0x00, 0x41,\n    0x00, 0x61, 0x00, 0x2b, 0x22, 0x00, 0x00, 0x00,\n    0x00, 0x3a, 0x3a, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d,\n    0x3d, 0xdd, 0x2a, 0xb8, 0x6a, 0x56, 0x00, 0x4e,\n    0x00, 0x28, 0x36, 0x3f, 0x59, 0x85, 0x8c, 0xa0,\n    0xba, 0x3f, 0x51, 0x00, 0x26, 0x2c, 0x43, 0x57,\n    0x6c, 0xa1, 0xb6, 0xc1, 0x9b, 0x52, 0x00, 0x5e,\n    0x7a, 0x7f, 0x9d, 0xa6, 0xc1, 0xce, 0xe7, 0xb6,\n    0x53, 0xc8, 0x53, 0xe3, 0x53, 0xd7, 0x56, 0x1f,\n    0x57, 0xeb, 0x58, 0x02, 0x59, 0x0a, 0x59, 0x15,\n    0x59, 0x27, 0x59, 0x73, 0x59, 0x50, 0x5b, 0x80,\n    0x5b, 0xf8, 0x5b, 0x0f, 0x5c, 0x22, 0x5c, 0x38,\n    0x5c, 0x6e, 0x5c, 0x71, 0x5c, 0xdb, 0x5d, 0xe5,\n    0x5d, 0xf1, 0x5d, 0xfe, 0x5d, 0x72, 0x5e, 0x7a,\n    0x5e, 0x7f, 0x5e, 0xf4, 0x5e, 0xfe, 0x5e, 0x0b,\n    0x5f, 0x13, 0x5f, 0x50, 0x5f, 0x61, 0x5f, 0x73,\n    0x5f, 0xc3, 0x5f, 0x08, 0x62, 0x36, 0x62, 0x4b,\n    0x62, 0x2f, 0x65, 0x34, 0x65, 0x87, 0x65, 0x97,\n    0x65, 0xa4, 0x65, 0xb9, 0x65, 0xe0, 0x65, 0xe5,\n    0x65, 0xf0, 0x66, 0x08, 0x67, 0x28, 0x67, 0x20,\n    0x6b, 0x62, 0x6b, 0x79, 0x6b, 0xb3, 0x6b, 0xcb,\n    0x6b, 0xd4, 0x6b, 0xdb, 0x6b, 0x0f, 0x6c, 0x14,\n    0x6c, 0x34, 0x6c, 0x6b, 0x70, 0x2a, 0x72, 0x36,\n    0x72, 0x3b, 0x72, 0x3f, 0x72, 0x47, 0x72, 0x59,\n    0x72, 0x5b, 0x72, 0xac, 0x72, 0x84, 0x73, 0x89,\n    0x73, 0xdc, 0x74, 0xe6, 0x74, 0x18, 0x75, 0x1f,\n    0x75, 0x28, 0x75, 0x30, 0x75, 0x8b, 0x75, 0x92,\n    0x75, 0x76, 0x76, 0x7d, 0x76, 0xae, 0x76, 0xbf,\n    0x76, 0xee, 0x76, 0xdb, 0x77, 0xe2, 0x77, 0xf3,\n    0x77, 0x3a, 0x79, 0xb8, 0x79, 0xbe, 0x79, 0x74,\n    0x7a, 0xcb, 0x7a, 0xf9, 0x7a, 0x73, 0x7c, 0xf8,\n    0x7c, 0x36, 0x7f, 0x51, 0x7f, 0x8a, 0x7f, 0xbd,\n    0x7f, 0x01, 0x80, 0x0c, 0x80, 0x12, 0x80, 0x33,\n    0x80, 0x7f, 0x80, 0x89, 0x80, 0xe3, 0x81, 0x00,\n    0x07, 0x10, 0x19, 0x29, 0x38, 0x3c, 0x8b, 0x8f,\n    0x95, 0x4d, 0x86, 0x6b, 0x86, 0x40, 0x88, 0x4c,\n    0x88, 0x63, 0x88, 0x7e, 0x89, 0x8b, 0x89, 0xd2,\n    0x89, 0x00, 0x8a, 0x37, 0x8c, 0x46, 0x8c, 0x55,\n    0x8c, 0x78, 0x8c, 0x9d, 0x8c, 0x64, 0x8d, 0x70,\n    0x8d, 0xb3, 0x8d, 0xab, 0x8e, 0xca, 0x8e, 0x9b,\n    0x8f, 0xb0, 0x8f, 0xb5, 0x8f, 0x91, 0x90, 0x49,\n    0x91, 0xc6, 0x91, 0xcc, 0x91, 0xd1, 0x91, 0x77,\n    0x95, 0x80, 0x95, 0x1c, 0x96, 0xb6, 0x96, 0xb9,\n    0x96, 0xe8, 0x96, 0x51, 0x97, 0x5e, 0x97, 0x62,\n    0x97, 0x69, 0x97, 0xcb, 0x97, 0xed, 0x97, 0xf3,\n    0x97, 0x01, 0x98, 0xa8, 0x98, 0xdb, 0x98, 0xdf,\n    0x98, 0x96, 0x99, 0x99, 0x99, 0xac, 0x99, 0xa8,\n    0x9a, 0xd8, 0x9a, 0xdf, 0x9a, 0x25, 0x9b, 0x2f,\n    0x9b, 0x32, 0x9b, 0x3c, 0x9b, 0x5a, 0x9b, 0xe5,\n    0x9c, 0x75, 0x9e, 0x7f, 0x9e, 0xa5, 0x9e, 0x00,\n    0x16, 0x1e, 0x28, 0x2c, 0x54, 0x58, 0x69, 0x6e,\n    0x7b, 0x96, 0xa5, 0xad, 0xe8, 0xf7, 0xfb, 0x12,\n    0x30, 0x00, 0x00, 0x41, 0x53, 0x44, 0x53, 0x45,\n    0x53, 0x4b, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x4d, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x4f, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x51, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x53, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x55, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x57, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x59, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x5b, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x5d, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x5f, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0x61, 0x30, 0x99, 0x30, 0x64, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0x66, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0x68, 0x30, 0x99,\n    0x30, 0x6f, 0x30, 0x99, 0x30, 0x72, 0x30, 0x99,\n    0x30, 0x75, 0x30, 0x99, 0x30, 0x78, 0x30, 0x99,\n    0x30, 0x7b, 0x30, 0x99, 0x30, 0x46, 0x30, 0x99,\n    0x30, 0x20, 0x00, 0x99, 0x30, 0x9d, 0x30, 0x99,\n    0x30, 0x88, 0x30, 0x8a, 0x30, 0xab, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xad, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xb1, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xb3, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xb7, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x30, 0x99,\n    0x30, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x30, 0x99,\n    0x30, 0xc4, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0xc6, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,\n    0x00, 0xc8, 0x30, 0x99, 0x30, 0xcf, 0x30, 0x99,\n    0x30, 0xd2, 0x30, 0x99, 0x30, 0xd5, 0x30, 0x99,\n    0x30, 0xd8, 0x30, 0x99, 0x30, 0xdb, 0x30, 0x99,\n    0x30, 0xa6, 0x30, 0x99, 0x30, 0xef, 0x30, 0x99,\n    0x30, 0xfd, 0x30, 0x99, 0x30, 0xb3, 0x30, 0xc8,\n    0x30, 0x00, 0x11, 0x00, 0x01, 0xaa, 0x02, 0xac,\n    0xad, 0x03, 0x04, 0x05, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0x1a, 0x06, 0x07, 0x08, 0x21, 0x09,\n    0x11, 0x61, 0x11, 0x14, 0x11, 0x4c, 0x00, 0x01,\n    0xb3, 0xb4, 0xb8, 0xba, 0xbf, 0xc3, 0xc5, 0x08,\n    0xc9, 0xcb, 0x09, 0x0a, 0x0c, 0x0e, 0x0f, 0x13,\n    0x15, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1e, 0x22,\n    0x2c, 0x33, 0x38, 0xdd, 0xde, 0x43, 0x44, 0x45,\n    0x70, 0x71, 0x74, 0x7d, 0x7e, 0x80, 0x8a, 0x8d,\n    0x00, 0x4e, 0x8c, 0x4e, 0x09, 0x4e, 0xdb, 0x56,\n    0x0a, 0x4e, 0x2d, 0x4e, 0x0b, 0x4e, 0x32, 0x75,\n    0x59, 0x4e, 0x19, 0x4e, 0x01, 0x4e, 0x29, 0x59,\n    0x30, 0x57, 0xba, 0x4e, 0x28, 0x00, 0x29, 0x00,\n    0x00, 0x11, 0x02, 0x11, 0x03, 0x11, 0x05, 0x11,\n    0x06, 0x11, 0x07, 0x11, 0x09, 0x11, 0x0b, 0x11,\n    0x0c, 0x11, 0x0e, 0x11, 0x0f, 0x11, 0x10, 0x11,\n    0x11, 0x11, 0x12, 0x11, 0x28, 0x00, 0x00, 0x11,\n    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x02, 0x11,\n    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x05, 0x11,\n    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x09, 0x11,\n    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x0b, 0x11,\n    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x0e, 0x11,\n    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x0c, 0x11,\n    0x6e, 0x11, 0x29, 0x00, 0x28, 0x00, 0x0b, 0x11,\n    0x69, 0x11, 0x0c, 0x11, 0x65, 0x11, 0xab, 0x11,\n    0x29, 0x00, 0x28, 0x00, 0x0b, 0x11, 0x69, 0x11,\n    0x12, 0x11, 0x6e, 0x11, 0x29, 0x00, 0x28, 0x00,\n    0x29, 0x00, 0x00, 0x4e, 0x8c, 0x4e, 0x09, 0x4e,\n    0xdb, 0x56, 0x94, 0x4e, 0x6d, 0x51, 0x03, 0x4e,\n    0x6b, 0x51, 0x5d, 0x4e, 0x41, 0x53, 0x08, 0x67,\n    0x6b, 0x70, 0x34, 0x6c, 0x28, 0x67, 0xd1, 0x91,\n    0x1f, 0x57, 0xe5, 0x65, 0x2a, 0x68, 0x09, 0x67,\n    0x3e, 0x79, 0x0d, 0x54, 0x79, 0x72, 0xa1, 0x8c,\n    0x5d, 0x79, 0xb4, 0x52, 0xe3, 0x4e, 0x7c, 0x54,\n    0x66, 0x5b, 0xe3, 0x76, 0x01, 0x4f, 0xc7, 0x8c,\n    0x54, 0x53, 0x6d, 0x79, 0x11, 0x4f, 0xea, 0x81,\n    0xf3, 0x81, 0x4f, 0x55, 0x7c, 0x5e, 0x87, 0x65,\n    0x8f, 0x7b, 0x50, 0x54, 0x45, 0x32, 0x00, 0x31,\n    0x00, 0x33, 0x00, 0x30, 0x00, 0x00, 0x11, 0x00,\n    0x02, 0x03, 0x05, 0x06, 0x07, 0x09, 0x0b, 0x0c,\n    0x0e, 0x0f, 0x10, 0x11, 0x12, 0x00, 0x11, 0x00,\n    0x61, 0x02, 0x61, 0x03, 0x61, 0x05, 0x61, 0x06,\n    0x61, 0x07, 0x61, 0x09, 0x61, 0x0b, 0x61, 0x0c,\n    0x61, 0x0e, 0x11, 0x61, 0x11, 0x00, 0x11, 0x0e,\n    0x61, 0xb7, 0x00, 0x69, 0x0b, 0x11, 0x01, 0x63,\n    0x00, 0x69, 0x0b, 0x11, 0x6e, 0x11, 0x00, 0x4e,\n    0x8c, 0x4e, 0x09, 0x4e, 0xdb, 0x56, 0x94, 0x4e,\n    0x6d, 0x51, 0x03, 0x4e, 0x6b, 0x51, 0x5d, 0x4e,\n    0x41, 0x53, 0x08, 0x67, 0x6b, 0x70, 0x34, 0x6c,\n    0x28, 0x67, 0xd1, 0x91, 0x1f, 0x57, 0xe5, 0x65,\n    0x2a, 0x68, 0x09, 0x67, 0x3e, 0x79, 0x0d, 0x54,\n    0x79, 0x72, 0xa1, 0x8c, 0x5d, 0x79, 0xb4, 0x52,\n    0xd8, 0x79, 0x37, 0x75, 0x73, 0x59, 0x69, 0x90,\n    0x2a, 0x51, 0x70, 0x53, 0xe8, 0x6c, 0x05, 0x98,\n    0x11, 0x4f, 0x99, 0x51, 0x63, 0x6b, 0x0a, 0x4e,\n    0x2d, 0x4e, 0x0b, 0x4e, 0xe6, 0x5d, 0xf3, 0x53,\n    0x3b, 0x53, 0x97, 0x5b, 0x66, 0x5b, 0xe3, 0x76,\n    0x01, 0x4f, 0xc7, 0x8c, 0x54, 0x53, 0x1c, 0x59,\n    0x33, 0x00, 0x36, 0x00, 0x34, 0x00, 0x30, 0x00,\n    0x35, 0x30, 0x31, 0x00, 0x08, 0x67, 0x31, 0x00,\n    0x30, 0x00, 0x08, 0x67, 0x48, 0x67, 0x65, 0x72,\n    0x67, 0x65, 0x56, 0x4c, 0x54, 0x44, 0xa2, 0x30,\n    0x00, 0x02, 0x04, 0x06, 0x08, 0x09, 0x0b, 0x0d,\n    0x0f, 0x11, 0x13, 0x15, 0x17, 0x19, 0x1b, 0x1d,\n    0x1f, 0x22, 0x24, 0x26, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x30, 0x33, 0x36, 0x39, 0x3c, 0x3d,\n    0x3e, 0x3f, 0x40, 0x42, 0x44, 0x46, 0x47, 0x48,\n    0x49, 0x4a, 0x4b, 0x4d, 0x4e, 0x4f, 0x50, 0xe4,\n    0x4e, 0x8c, 0x54, 0xa1, 0x30, 0x01, 0x30, 0x5b,\n    0x27, 0x01, 0x4a, 0x34, 0x00, 0x01, 0x52, 0x39,\n    0x01, 0xa2, 0x30, 0x00, 0x5a, 0x49, 0xa4, 0x30,\n    0x00, 0x27, 0x4f, 0x0c, 0xa4, 0x30, 0x00, 0x4f,\n    0x1d, 0x02, 0x05, 0x4f, 0xa8, 0x30, 0x00, 0x11,\n    0x07, 0x54, 0x21, 0xa8, 0x30, 0x00, 0x54, 0x03,\n    0x54, 0xa4, 0x30, 0x06, 0x4f, 0x15, 0x06, 0x58,\n    0x3c, 0x07, 0x00, 0x46, 0xab, 0x30, 0x00, 0x3e,\n    0x18, 0x1d, 0x00, 0x42, 0x3f, 0x51, 0xac, 0x30,\n    0x00, 0x41, 0x47, 0x00, 0x47, 0x32, 0xae, 0x30,\n    0xac, 0x30, 0xae, 0x30, 0x00, 0x1d, 0x4e, 0xad,\n    0x30, 0x00, 0x38, 0x3d, 0x4f, 0x01, 0x3e, 0x13,\n    0x4f, 0xad, 0x30, 0xed, 0x30, 0xad, 0x30, 0x00,\n    0x40, 0x03, 0x3c, 0x33, 0xad, 0x30, 0x00, 0x40,\n    0x34, 0x4f, 0x1b, 0x3e, 0xad, 0x30, 0x00, 0x40,\n    0x42, 0x16, 0x1b, 0xb0, 0x30, 0x00, 0x39, 0x30,\n    0xa4, 0x30, 0x0c, 0x45, 0x3c, 0x24, 0x4f, 0x0b,\n    0x47, 0x18, 0x00, 0x49, 0xaf, 0x30, 0x00, 0x3e,\n    0x4d, 0x1e, 0xb1, 0x30, 0x00, 0x4b, 0x08, 0x02,\n    0x3a, 0x19, 0x02, 0x4b, 0x2c, 0xa4, 0x30, 0x11,\n    0x00, 0x0b, 0x47, 0xb5, 0x30, 0x00, 0x3e, 0x0c,\n    0x47, 0x2b, 0xb0, 0x30, 0x07, 0x3a, 0x43, 0x00,\n    0xb9, 0x30, 0x02, 0x3a, 0x08, 0x02, 0x3a, 0x0f,\n    0x07, 0x43, 0x00, 0xb7, 0x30, 0x10, 0x00, 0x12,\n    0x34, 0x11, 0x3c, 0x13, 0x17, 0xa4, 0x30, 0x2a,\n    0x1f, 0x24, 0x2b, 0x00, 0x20, 0xbb, 0x30, 0x16,\n    0x41, 0x00, 0x38, 0x0d, 0xc4, 0x30, 0x0d, 0x38,\n    0x00, 0xd0, 0x30, 0x00, 0x2c, 0x1c, 0x1b, 0xa2,\n    0x30, 0x32, 0x00, 0x17, 0x26, 0x49, 0xaf, 0x30,\n    0x25, 0x00, 0x3c, 0xb3, 0x30, 0x21, 0x00, 0x20,\n    0x38, 0xa1, 0x30, 0x34, 0x00, 0x48, 0x22, 0x28,\n    0xa3, 0x30, 0x32, 0x00, 0x59, 0x25, 0xa7, 0x30,\n    0x2f, 0x1c, 0x10, 0x00, 0x44, 0xd5, 0x30, 0x00,\n    0x14, 0x1e, 0xaf, 0x30, 0x29, 0x00, 0x10, 0x4d,\n    0x3c, 0xda, 0x30, 0xbd, 0x30, 0xb8, 0x30, 0x22,\n    0x13, 0x1a, 0x20, 0x33, 0x0c, 0x22, 0x3b, 0x01,\n    0x22, 0x44, 0x00, 0x21, 0x44, 0x07, 0xa4, 0x30,\n    0x39, 0x00, 0x4f, 0x24, 0xc8, 0x30, 0x14, 0x23,\n    0x00, 0xdb, 0x30, 0xf3, 0x30, 0xc9, 0x30, 0x14,\n    0x2a, 0x00, 0x12, 0x33, 0x22, 0x12, 0x33, 0x2a,\n    0xa4, 0x30, 0x3a, 0x00, 0x0b, 0x49, 0xa4, 0x30,\n    0x3a, 0x00, 0x47, 0x3a, 0x1f, 0x2b, 0x3a, 0x47,\n    0x0b, 0xb7, 0x30, 0x27, 0x3c, 0x00, 0x30, 0x3c,\n    0xaf, 0x30, 0x30, 0x00, 0x3e, 0x44, 0xdf, 0x30,\n    0xea, 0x30, 0xd0, 0x30, 0x0f, 0x1a, 0x00, 0x2c,\n    0x1b, 0xe1, 0x30, 0xac, 0x30, 0xac, 0x30, 0x35,\n    0x00, 0x1c, 0x47, 0x35, 0x50, 0x1c, 0x3f, 0xa2,\n    0x30, 0x42, 0x5a, 0x27, 0x42, 0x5a, 0x49, 0x44,\n    0x00, 0x51, 0xc3, 0x30, 0x27, 0x00, 0x05, 0x28,\n    0xea, 0x30, 0xe9, 0x30, 0xd4, 0x30, 0x17, 0x00,\n    0x28, 0xd6, 0x30, 0x15, 0x26, 0x00, 0x15, 0xec,\n    0x30, 0xe0, 0x30, 0xb2, 0x30, 0x3a, 0x41, 0x16,\n    0x00, 0x41, 0xc3, 0x30, 0x2c, 0x00, 0x05, 0x30,\n    0x00, 0xb9, 0x70, 0x31, 0x00, 0x30, 0x00, 0xb9,\n    0x70, 0x32, 0x00, 0x30, 0x00, 0xb9, 0x70, 0x68,\n    0x50, 0x61, 0x64, 0x61, 0x41, 0x55, 0x62, 0x61,\n    0x72, 0x6f, 0x56, 0x70, 0x63, 0x64, 0x6d, 0x64,\n    0x00, 0x6d, 0x00, 0xb2, 0x00, 0x49, 0x00, 0x55,\n    0x00, 0x73, 0x5e, 0x10, 0x62, 0x2d, 0x66, 0x8c,\n    0x54, 0x27, 0x59, 0x63, 0x6b, 0x0e, 0x66, 0xbb,\n    0x6c, 0x2a, 0x68, 0x0f, 0x5f, 0x1a, 0x4f, 0x3e,\n    0x79, 0x70, 0x00, 0x41, 0x6e, 0x00, 0x41, 0xbc,\n    0x03, 0x41, 0x6d, 0x00, 0x41, 0x6b, 0x00, 0x41,\n    0x4b, 0x00, 0x42, 0x4d, 0x00, 0x42, 0x47, 0x00,\n    0x42, 0x63, 0x61, 0x6c, 0x6b, 0x63, 0x61, 0x6c,\n    0x70, 0x00, 0x46, 0x6e, 0x00, 0x46, 0xbc, 0x03,\n    0x46, 0xbc, 0x03, 0x67, 0x6d, 0x00, 0x67, 0x6b,\n    0x00, 0x67, 0x48, 0x00, 0x7a, 0x6b, 0x48, 0x7a,\n    0x4d, 0x48, 0x7a, 0x47, 0x48, 0x7a, 0x54, 0x48,\n    0x7a, 0xbc, 0x03, 0x13, 0x21, 0x6d, 0x00, 0x13,\n    0x21, 0x64, 0x00, 0x13, 0x21, 0x6b, 0x00, 0x13,\n    0x21, 0x66, 0x00, 0x6d, 0x6e, 0x00, 0x6d, 0xbc,\n    0x03, 0x6d, 0x6d, 0x00, 0x6d, 0x63, 0x00, 0x6d,\n    0x6b, 0x00, 0x6d, 0x63, 0x00, 0x0a, 0x0a, 0x4f,\n    0x00, 0x0a, 0x4f, 0x6d, 0x00, 0xb2, 0x00, 0x63,\n    0x00, 0x08, 0x0a, 0x4f, 0x0a, 0x0a, 0x50, 0x00,\n    0x0a, 0x50, 0x6d, 0x00, 0xb3, 0x00, 0x6b, 0x00,\n    0x6d, 0x00, 0xb3, 0x00, 0x6d, 0x00, 0x15, 0x22,\n    0x73, 0x00, 0x6d, 0x00, 0x15, 0x22, 0x73, 0x00,\n    0xb2, 0x00, 0x50, 0x61, 0x6b, 0x50, 0x61, 0x4d,\n    0x50, 0x61, 0x47, 0x50, 0x61, 0x72, 0x61, 0x64,\n    0x72, 0x61, 0x64, 0xd1, 0x73, 0x72, 0x00, 0x61,\n    0x00, 0x64, 0x00, 0x15, 0x22, 0x73, 0x00, 0xb2,\n    0x00, 0x70, 0x00, 0x73, 0x6e, 0x00, 0x73, 0xbc,\n    0x03, 0x73, 0x6d, 0x00, 0x73, 0x70, 0x00, 0x56,\n    0x6e, 0x00, 0x56, 0xbc, 0x03, 0x56, 0x6d, 0x00,\n    0x56, 0x6b, 0x00, 0x56, 0x4d, 0x00, 0x56, 0x70,\n    0x00, 0x57, 0x6e, 0x00, 0x57, 0xbc, 0x03, 0x57,\n    0x6d, 0x00, 0x57, 0x6b, 0x00, 0x57, 0x4d, 0x00,\n    0x57, 0x6b, 0x00, 0xa9, 0x03, 0x4d, 0x00, 0xa9,\n    0x03, 0x61, 0x2e, 0x6d, 0x2e, 0x42, 0x71, 0x63,\n    0x63, 0x63, 0x64, 0x43, 0xd1, 0x6b, 0x67, 0x43,\n    0x6f, 0x2e, 0x64, 0x42, 0x47, 0x79, 0x68, 0x61,\n    0x48, 0x50, 0x69, 0x6e, 0x4b, 0x4b, 0x4b, 0x4d,\n    0x6b, 0x74, 0x6c, 0x6d, 0x6c, 0x6e, 0x6c, 0x6f,\n    0x67, 0x6c, 0x78, 0x6d, 0x62, 0x6d, 0x69, 0x6c,\n    0x6d, 0x6f, 0x6c, 0x50, 0x48, 0x70, 0x2e, 0x6d,\n    0x2e, 0x50, 0x50, 0x4d, 0x50, 0x52, 0x73, 0x72,\n    0x53, 0x76, 0x57, 0x62, 0x56, 0xd1, 0x6d, 0x41,\n    0xd1, 0x6d, 0x31, 0x00, 0xe5, 0x65, 0x31, 0x00,\n    0x30, 0x00, 0xe5, 0x65, 0x32, 0x00, 0x30, 0x00,\n    0xe5, 0x65, 0x33, 0x00, 0x30, 0x00, 0xe5, 0x65,\n    0x67, 0x61, 0x6c, 0x4a, 0x04, 0x4c, 0x04, 0x43,\n    0x46, 0x51, 0x26, 0x01, 0x53, 0x01, 0x27, 0xa7,\n    0x37, 0xab, 0x6b, 0x02, 0x52, 0xab, 0x48, 0x8c,\n    0xf4, 0x66, 0xca, 0x8e, 0xc8, 0x8c, 0xd1, 0x6e,\n    0x32, 0x4e, 0xe5, 0x53, 0x9c, 0x9f, 0x9c, 0x9f,\n    0x51, 0x59, 0xd1, 0x91, 0x87, 0x55, 0x48, 0x59,\n    0xf6, 0x61, 0x69, 0x76, 0x85, 0x7f, 0x3f, 0x86,\n    0xba, 0x87, 0xf8, 0x88, 0x8f, 0x90, 0x02, 0x6a,\n    0x1b, 0x6d, 0xd9, 0x70, 0xde, 0x73, 0x3d, 0x84,\n    0x6a, 0x91, 0xf1, 0x99, 0x82, 0x4e, 0x75, 0x53,\n    0x04, 0x6b, 0x1b, 0x72, 0x2d, 0x86, 0x1e, 0x9e,\n    0x50, 0x5d, 0xeb, 0x6f, 0xcd, 0x85, 0x64, 0x89,\n    0xc9, 0x62, 0xd8, 0x81, 0x1f, 0x88, 0xca, 0x5e,\n    0x17, 0x67, 0x6a, 0x6d, 0xfc, 0x72, 0xce, 0x90,\n    0x86, 0x4f, 0xb7, 0x51, 0xde, 0x52, 0xc4, 0x64,\n    0xd3, 0x6a, 0x10, 0x72, 0xe7, 0x76, 0x01, 0x80,\n    0x06, 0x86, 0x5c, 0x86, 0xef, 0x8d, 0x32, 0x97,\n    0x6f, 0x9b, 0xfa, 0x9d, 0x8c, 0x78, 0x7f, 0x79,\n    0xa0, 0x7d, 0xc9, 0x83, 0x04, 0x93, 0x7f, 0x9e,\n    0xd6, 0x8a, 0xdf, 0x58, 0x04, 0x5f, 0x60, 0x7c,\n    0x7e, 0x80, 0x62, 0x72, 0xca, 0x78, 0xc2, 0x8c,\n    0xf7, 0x96, 0xd8, 0x58, 0x62, 0x5c, 0x13, 0x6a,\n    0xda, 0x6d, 0x0f, 0x6f, 0x2f, 0x7d, 0x37, 0x7e,\n    0x4b, 0x96, 0xd2, 0x52, 0x8b, 0x80, 0xdc, 0x51,\n    0xcc, 0x51, 0x1c, 0x7a, 0xbe, 0x7d, 0xf1, 0x83,\n    0x75, 0x96, 0x80, 0x8b, 0xcf, 0x62, 0x02, 0x6a,\n    0xfe, 0x8a, 0x39, 0x4e, 0xe7, 0x5b, 0x12, 0x60,\n    0x87, 0x73, 0x70, 0x75, 0x17, 0x53, 0xfb, 0x78,\n    0xbf, 0x4f, 0xa9, 0x5f, 0x0d, 0x4e, 0xcc, 0x6c,\n    0x78, 0x65, 0x22, 0x7d, 0xc3, 0x53, 0x5e, 0x58,\n    0x01, 0x77, 0x49, 0x84, 0xaa, 0x8a, 0xba, 0x6b,\n    0xb0, 0x8f, 0x88, 0x6c, 0xfe, 0x62, 0xe5, 0x82,\n    0xa0, 0x63, 0x65, 0x75, 0xae, 0x4e, 0x69, 0x51,\n    0xc9, 0x51, 0x81, 0x68, 0xe7, 0x7c, 0x6f, 0x82,\n    0xd2, 0x8a, 0xcf, 0x91, 0xf5, 0x52, 0x42, 0x54,\n    0x73, 0x59, 0xec, 0x5e, 0xc5, 0x65, 0xfe, 0x6f,\n    0x2a, 0x79, 0xad, 0x95, 0x6a, 0x9a, 0x97, 0x9e,\n    0xce, 0x9e, 0x9b, 0x52, 0xc6, 0x66, 0x77, 0x6b,\n    0x62, 0x8f, 0x74, 0x5e, 0x90, 0x61, 0x00, 0x62,\n    0x9a, 0x64, 0x23, 0x6f, 0x49, 0x71, 0x89, 0x74,\n    0xca, 0x79, 0xf4, 0x7d, 0x6f, 0x80, 0x26, 0x8f,\n    0xee, 0x84, 0x23, 0x90, 0x4a, 0x93, 0x17, 0x52,\n    0xa3, 0x52, 0xbd, 0x54, 0xc8, 0x70, 0xc2, 0x88,\n    0xaa, 0x8a, 0xc9, 0x5e, 0xf5, 0x5f, 0x7b, 0x63,\n    0xae, 0x6b, 0x3e, 0x7c, 0x75, 0x73, 0xe4, 0x4e,\n    0xf9, 0x56, 0xe7, 0x5b, 0xba, 0x5d, 0x1c, 0x60,\n    0xb2, 0x73, 0x69, 0x74, 0x9a, 0x7f, 0x46, 0x80,\n    0x34, 0x92, 0xf6, 0x96, 0x48, 0x97, 0x18, 0x98,\n    0x8b, 0x4f, 0xae, 0x79, 0xb4, 0x91, 0xb8, 0x96,\n    0xe1, 0x60, 0x86, 0x4e, 0xda, 0x50, 0xee, 0x5b,\n    0x3f, 0x5c, 0x99, 0x65, 0x02, 0x6a, 0xce, 0x71,\n    0x42, 0x76, 0xfc, 0x84, 0x7c, 0x90, 0x8d, 0x9f,\n    0x88, 0x66, 0x2e, 0x96, 0x89, 0x52, 0x7b, 0x67,\n    0xf3, 0x67, 0x41, 0x6d, 0x9c, 0x6e, 0x09, 0x74,\n    0x59, 0x75, 0x6b, 0x78, 0x10, 0x7d, 0x5e, 0x98,\n    0x6d, 0x51, 0x2e, 0x62, 0x78, 0x96, 0x2b, 0x50,\n    0x19, 0x5d, 0xea, 0x6d, 0x2a, 0x8f, 0x8b, 0x5f,\n    0x44, 0x61, 0x17, 0x68, 0x87, 0x73, 0x86, 0x96,\n    0x29, 0x52, 0x0f, 0x54, 0x65, 0x5c, 0x13, 0x66,\n    0x4e, 0x67, 0xa8, 0x68, 0xe5, 0x6c, 0x06, 0x74,\n    0xe2, 0x75, 0x79, 0x7f, 0xcf, 0x88, 0xe1, 0x88,\n    0xcc, 0x91, 0xe2, 0x96, 0x3f, 0x53, 0xba, 0x6e,\n    0x1d, 0x54, 0xd0, 0x71, 0x98, 0x74, 0xfa, 0x85,\n    0xa3, 0x96, 0x57, 0x9c, 0x9f, 0x9e, 0x97, 0x67,\n    0xcb, 0x6d, 0xe8, 0x81, 0xcb, 0x7a, 0x20, 0x7b,\n    0x92, 0x7c, 0xc0, 0x72, 0x99, 0x70, 0x58, 0x8b,\n    0xc0, 0x4e, 0x36, 0x83, 0x3a, 0x52, 0x07, 0x52,\n    0xa6, 0x5e, 0xd3, 0x62, 0xd6, 0x7c, 0x85, 0x5b,\n    0x1e, 0x6d, 0xb4, 0x66, 0x3b, 0x8f, 0x4c, 0x88,\n    0x4d, 0x96, 0x8b, 0x89, 0xd3, 0x5e, 0x40, 0x51,\n    0xc0, 0x55, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x58,\n    0x00, 0x00, 0x74, 0x66, 0x00, 0x00, 0x00, 0x00,\n    0xde, 0x51, 0x2a, 0x73, 0xca, 0x76, 0x3c, 0x79,\n    0x5e, 0x79, 0x65, 0x79, 0x8f, 0x79, 0x56, 0x97,\n    0xbe, 0x7c, 0xbd, 0x7f, 0x00, 0x00, 0x12, 0x86,\n    0x00, 0x00, 0xf8, 0x8a, 0x00, 0x00, 0x00, 0x00,\n    0x38, 0x90, 0xfd, 0x90, 0xef, 0x98, 0xfc, 0x98,\n    0x28, 0x99, 0xb4, 0x9d, 0xde, 0x90, 0xb7, 0x96,\n    0xae, 0x4f, 0xe7, 0x50, 0x4d, 0x51, 0xc9, 0x52,\n    0xe4, 0x52, 0x51, 0x53, 0x9d, 0x55, 0x06, 0x56,\n    0x68, 0x56, 0x40, 0x58, 0xa8, 0x58, 0x64, 0x5c,\n    0x6e, 0x5c, 0x94, 0x60, 0x68, 0x61, 0x8e, 0x61,\n    0xf2, 0x61, 0x4f, 0x65, 0xe2, 0x65, 0x91, 0x66,\n    0x85, 0x68, 0x77, 0x6d, 0x1a, 0x6e, 0x22, 0x6f,\n    0x6e, 0x71, 0x2b, 0x72, 0x22, 0x74, 0x91, 0x78,\n    0x3e, 0x79, 0x49, 0x79, 0x48, 0x79, 0x50, 0x79,\n    0x56, 0x79, 0x5d, 0x79, 0x8d, 0x79, 0x8e, 0x79,\n    0x40, 0x7a, 0x81, 0x7a, 0xc0, 0x7b, 0xf4, 0x7d,\n    0x09, 0x7e, 0x41, 0x7e, 0x72, 0x7f, 0x05, 0x80,\n    0xed, 0x81, 0x79, 0x82, 0x79, 0x82, 0x57, 0x84,\n    0x10, 0x89, 0x96, 0x89, 0x01, 0x8b, 0x39, 0x8b,\n    0xd3, 0x8c, 0x08, 0x8d, 0xb6, 0x8f, 0x38, 0x90,\n    0xe3, 0x96, 0xff, 0x97, 0x3b, 0x98, 0x75, 0x60,\n    0xee, 0x42, 0x18, 0x82, 0x02, 0x26, 0x4e, 0xb5,\n    0x51, 0x68, 0x51, 0x80, 0x4f, 0x45, 0x51, 0x80,\n    0x51, 0xc7, 0x52, 0xfa, 0x52, 0x9d, 0x55, 0x55,\n    0x55, 0x99, 0x55, 0xe2, 0x55, 0x5a, 0x58, 0xb3,\n    0x58, 0x44, 0x59, 0x54, 0x59, 0x62, 0x5a, 0x28,\n    0x5b, 0xd2, 0x5e, 0xd9, 0x5e, 0x69, 0x5f, 0xad,\n    0x5f, 0xd8, 0x60, 0x4e, 0x61, 0x08, 0x61, 0x8e,\n    0x61, 0x60, 0x61, 0xf2, 0x61, 0x34, 0x62, 0xc4,\n    0x63, 0x1c, 0x64, 0x52, 0x64, 0x56, 0x65, 0x74,\n    0x66, 0x17, 0x67, 0x1b, 0x67, 0x56, 0x67, 0x79,\n    0x6b, 0xba, 0x6b, 0x41, 0x6d, 0xdb, 0x6e, 0xcb,\n    0x6e, 0x22, 0x6f, 0x1e, 0x70, 0x6e, 0x71, 0xa7,\n    0x77, 0x35, 0x72, 0xaf, 0x72, 0x2a, 0x73, 0x71,\n    0x74, 0x06, 0x75, 0x3b, 0x75, 0x1d, 0x76, 0x1f,\n    0x76, 0xca, 0x76, 0xdb, 0x76, 0xf4, 0x76, 0x4a,\n    0x77, 0x40, 0x77, 0xcc, 0x78, 0xb1, 0x7a, 0xc0,\n    0x7b, 0x7b, 0x7c, 0x5b, 0x7d, 0xf4, 0x7d, 0x3e,\n    0x7f, 0x05, 0x80, 0x52, 0x83, 0xef, 0x83, 0x79,\n    0x87, 0x41, 0x89, 0x86, 0x89, 0x96, 0x89, 0xbf,\n    0x8a, 0xf8, 0x8a, 0xcb, 0x8a, 0x01, 0x8b, 0xfe,\n    0x8a, 0xed, 0x8a, 0x39, 0x8b, 0x8a, 0x8b, 0x08,\n    0x8d, 0x38, 0x8f, 0x72, 0x90, 0x99, 0x91, 0x76,\n    0x92, 0x7c, 0x96, 0xe3, 0x96, 0x56, 0x97, 0xdb,\n    0x97, 0xff, 0x97, 0x0b, 0x98, 0x3b, 0x98, 0x12,\n    0x9b, 0x9c, 0x9f, 0x4a, 0x28, 0x44, 0x28, 0xd5,\n    0x33, 0x9d, 0x3b, 0x18, 0x40, 0x39, 0x40, 0x49,\n    0x52, 0xd0, 0x5c, 0xd3, 0x7e, 0x43, 0x9f, 0x8e,\n    0x9f, 0x2a, 0xa0, 0x02, 0x66, 0x66, 0x66, 0x69,\n    0x66, 0x6c, 0x66, 0x66, 0x69, 0x66, 0x66, 0x6c,\n    0x7f, 0x01, 0x74, 0x73, 0x00, 0x74, 0x65, 0x05,\n    0x0f, 0x11, 0x0f, 0x00, 0x0f, 0x06, 0x19, 0x11,\n    0x0f, 0x08, 0xd9, 0x05, 0xb4, 0x05, 0x00, 0x00,\n    0x00, 0x00, 0xf2, 0x05, 0xb7, 0x05, 0xd0, 0x05,\n    0x12, 0x00, 0x03, 0x04, 0x0b, 0x0c, 0x0d, 0x18,\n    0x1a, 0xe9, 0x05, 0xc1, 0x05, 0xe9, 0x05, 0xc2,\n    0x05, 0x49, 0xfb, 0xc1, 0x05, 0x49, 0xfb, 0xc2,\n    0x05, 0xd0, 0x05, 0xb7, 0x05, 0xd0, 0x05, 0xb8,\n    0x05, 0xd0, 0x05, 0xbc, 0x05, 0xd8, 0x05, 0xbc,\n    0x05, 0xde, 0x05, 0xbc, 0x05, 0xe0, 0x05, 0xbc,\n    0x05, 0xe3, 0x05, 0xbc, 0x05, 0xb9, 0x05, 0x2d,\n    0x03, 0x2e, 0x03, 0x2f, 0x03, 0x30, 0x03, 0x31,\n    0x03, 0x1c, 0x00, 0x18, 0x06, 0x22, 0x06, 0x2b,\n    0x06, 0xd0, 0x05, 0xdc, 0x05, 0x71, 0x06, 0x00,\n    0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0d, 0x0d, 0x0d,\n    0x0d, 0x0f, 0x0f, 0x0f, 0x0f, 0x09, 0x09, 0x09,\n    0x09, 0x0e, 0x0e, 0x0e, 0x0e, 0x08, 0x08, 0x08,\n    0x08, 0x33, 0x33, 0x33, 0x33, 0x35, 0x35, 0x35,\n    0x35, 0x13, 0x13, 0x13, 0x13, 0x12, 0x12, 0x12,\n    0x12, 0x15, 0x15, 0x15, 0x15, 0x16, 0x16, 0x16,\n    0x16, 0x1c, 0x1c, 0x1b, 0x1b, 0x1d, 0x1d, 0x17,\n    0x17, 0x27, 0x27, 0x20, 0x20, 0x38, 0x38, 0x38,\n    0x38, 0x3e, 0x3e, 0x3e, 0x3e, 0x42, 0x42, 0x42,\n    0x42, 0x40, 0x40, 0x40, 0x40, 0x49, 0x49, 0x4a,\n    0x4a, 0x4a, 0x4a, 0x4f, 0x4f, 0x50, 0x50, 0x50,\n    0x50, 0x4d, 0x4d, 0x4d, 0x4d, 0x61, 0x61, 0x62,\n    0x62, 0x49, 0x06, 0x64, 0x64, 0x64, 0x64, 0x7e,\n    0x7e, 0x7d, 0x7d, 0x7f, 0x7f, 0x2e, 0x82, 0x82,\n    0x7c, 0x7c, 0x80, 0x80, 0x87, 0x87, 0x87, 0x87,\n    0x00, 0x00, 0x26, 0x06, 0x00, 0x01, 0x00, 0x01,\n    0x00, 0xaf, 0x00, 0xaf, 0x00, 0x22, 0x00, 0x22,\n    0x00, 0xa1, 0x00, 0xa1, 0x00, 0xa0, 0x00, 0xa0,\n    0x00, 0xa2, 0x00, 0xa2, 0x00, 0xaa, 0x00, 0xaa,\n    0x00, 0xaa, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23,\n    0xcc, 0x06, 0x00, 0x00, 0x00, 0x00, 0x26, 0x06,\n    0x00, 0x06, 0x00, 0x07, 0x00, 0x1f, 0x00, 0x23,\n    0x00, 0x24, 0x02, 0x06, 0x02, 0x07, 0x02, 0x08,\n    0x02, 0x1f, 0x02, 0x23, 0x02, 0x24, 0x04, 0x06,\n    0x04, 0x07, 0x04, 0x08, 0x04, 0x1f, 0x04, 0x23,\n    0x04, 0x24, 0x05, 0x06, 0x05, 0x1f, 0x05, 0x23,\n    0x05, 0x24, 0x06, 0x07, 0x06, 0x1f, 0x07, 0x06,\n    0x07, 0x1f, 0x08, 0x06, 0x08, 0x07, 0x08, 0x1f,\n    0x0d, 0x06, 0x0d, 0x07, 0x0d, 0x08, 0x0d, 0x1f,\n    0x0f, 0x07, 0x0f, 0x1f, 0x10, 0x06, 0x10, 0x07,\n    0x10, 0x08, 0x10, 0x1f, 0x11, 0x07, 0x11, 0x1f,\n    0x12, 0x1f, 0x13, 0x06, 0x13, 0x1f, 0x14, 0x06,\n    0x14, 0x1f, 0x1b, 0x06, 0x1b, 0x07, 0x1b, 0x08,\n    0x1b, 0x1f, 0x1b, 0x23, 0x1b, 0x24, 0x1c, 0x07,\n    0x1c, 0x1f, 0x1c, 0x23, 0x1c, 0x24, 0x1d, 0x01,\n    0x1d, 0x06, 0x1d, 0x07, 0x1d, 0x08, 0x1d, 0x1e,\n    0x1d, 0x1f, 0x1d, 0x23, 0x1d, 0x24, 0x1e, 0x06,\n    0x1e, 0x07, 0x1e, 0x08, 0x1e, 0x1f, 0x1e, 0x23,\n    0x1e, 0x24, 0x1f, 0x06, 0x1f, 0x07, 0x1f, 0x08,\n    0x1f, 0x1f, 0x1f, 0x23, 0x1f, 0x24, 0x20, 0x06,\n    0x20, 0x07, 0x20, 0x08, 0x20, 0x1f, 0x20, 0x23,\n    0x20, 0x24, 0x21, 0x06, 0x21, 0x1f, 0x21, 0x23,\n    0x21, 0x24, 0x24, 0x06, 0x24, 0x07, 0x24, 0x08,\n    0x24, 0x1f, 0x24, 0x23, 0x24, 0x24, 0x0a, 0x4a,\n    0x0b, 0x4a, 0x23, 0x4a, 0x20, 0x00, 0x4c, 0x06,\n    0x51, 0x06, 0x51, 0x06, 0xff, 0x00, 0x1f, 0x26,\n    0x06, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x1f, 0x00,\n    0x20, 0x00, 0x23, 0x00, 0x24, 0x02, 0x0b, 0x02,\n    0x0c, 0x02, 0x1f, 0x02, 0x20, 0x02, 0x23, 0x02,\n    0x24, 0x04, 0x0b, 0x04, 0x0c, 0x04, 0x1f, 0x26,\n    0x06, 0x04, 0x20, 0x04, 0x23, 0x04, 0x24, 0x05,\n    0x0b, 0x05, 0x0c, 0x05, 0x1f, 0x05, 0x20, 0x05,\n    0x23, 0x05, 0x24, 0x1b, 0x23, 0x1b, 0x24, 0x1c,\n    0x23, 0x1c, 0x24, 0x1d, 0x01, 0x1d, 0x1e, 0x1d,\n    0x1f, 0x1d, 0x23, 0x1d, 0x24, 0x1e, 0x1f, 0x1e,\n    0x23, 0x1e, 0x24, 0x1f, 0x01, 0x1f, 0x1f, 0x20,\n    0x0b, 0x20, 0x0c, 0x20, 0x1f, 0x20, 0x20, 0x20,\n    0x23, 0x20, 0x24, 0x23, 0x4a, 0x24, 0x0b, 0x24,\n    0x0c, 0x24, 0x1f, 0x24, 0x20, 0x24, 0x23, 0x24,\n    0x24, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08, 0x00,\n    0x1f, 0x00, 0x21, 0x02, 0x06, 0x02, 0x07, 0x02,\n    0x08, 0x02, 0x1f, 0x02, 0x21, 0x04, 0x06, 0x04,\n    0x07, 0x04, 0x08, 0x04, 0x1f, 0x04, 0x21, 0x05,\n    0x1f, 0x06, 0x07, 0x06, 0x1f, 0x07, 0x06, 0x07,\n    0x1f, 0x08, 0x06, 0x08, 0x1f, 0x0d, 0x06, 0x0d,\n    0x07, 0x0d, 0x08, 0x0d, 0x1f, 0x0f, 0x07, 0x0f,\n    0x08, 0x0f, 0x1f, 0x10, 0x06, 0x10, 0x07, 0x10,\n    0x08, 0x10, 0x1f, 0x11, 0x07, 0x12, 0x1f, 0x13,\n    0x06, 0x13, 0x1f, 0x14, 0x06, 0x14, 0x1f, 0x1b,\n    0x06, 0x1b, 0x07, 0x1b, 0x08, 0x1b, 0x1f, 0x1c,\n    0x07, 0x1c, 0x1f, 0x1d, 0x06, 0x1d, 0x07, 0x1d,\n    0x08, 0x1d, 0x1e, 0x1d, 0x1f, 0x1e, 0x06, 0x1e,\n    0x07, 0x1e, 0x08, 0x1e, 0x1f, 0x1e, 0x21, 0x1f,\n    0x06, 0x1f, 0x07, 0x1f, 0x08, 0x1f, 0x1f, 0x20,\n    0x06, 0x20, 0x07, 0x20, 0x08, 0x20, 0x1f, 0x20,\n    0x21, 0x21, 0x06, 0x21, 0x1f, 0x21, 0x4a, 0x24,\n    0x06, 0x24, 0x07, 0x24, 0x08, 0x24, 0x1f, 0x24,\n    0x21, 0x00, 0x1f, 0x00, 0x21, 0x02, 0x1f, 0x02,\n    0x21, 0x04, 0x1f, 0x04, 0x21, 0x05, 0x1f, 0x05,\n    0x21, 0x0d, 0x1f, 0x0d, 0x21, 0x0e, 0x1f, 0x0e,\n    0x21, 0x1d, 0x1e, 0x1d, 0x1f, 0x1e, 0x1f, 0x20,\n    0x1f, 0x20, 0x21, 0x24, 0x1f, 0x24, 0x21, 0x40,\n    0x06, 0x4e, 0x06, 0x51, 0x06, 0x27, 0x06, 0x10,\n    0x22, 0x10, 0x23, 0x12, 0x22, 0x12, 0x23, 0x13,\n    0x22, 0x13, 0x23, 0x0c, 0x22, 0x0c, 0x23, 0x0d,\n    0x22, 0x0d, 0x23, 0x06, 0x22, 0x06, 0x23, 0x05,\n    0x22, 0x05, 0x23, 0x07, 0x22, 0x07, 0x23, 0x0e,\n    0x22, 0x0e, 0x23, 0x0f, 0x22, 0x0f, 0x23, 0x0d,\n    0x05, 0x0d, 0x06, 0x0d, 0x07, 0x0d, 0x1e, 0x0d,\n    0x0a, 0x0c, 0x0a, 0x0e, 0x0a, 0x0f, 0x0a, 0x10,\n    0x22, 0x10, 0x23, 0x12, 0x22, 0x12, 0x23, 0x13,\n    0x22, 0x13, 0x23, 0x0c, 0x22, 0x0c, 0x23, 0x0d,\n    0x22, 0x0d, 0x23, 0x06, 0x22, 0x06, 0x23, 0x05,\n    0x22, 0x05, 0x23, 0x07, 0x22, 0x07, 0x23, 0x0e,\n    0x22, 0x0e, 0x23, 0x0f, 0x22, 0x0f, 0x23, 0x0d,\n    0x05, 0x0d, 0x06, 0x0d, 0x07, 0x0d, 0x1e, 0x0d,\n    0x0a, 0x0c, 0x0a, 0x0e, 0x0a, 0x0f, 0x0a, 0x0d,\n    0x05, 0x0d, 0x06, 0x0d, 0x07, 0x0d, 0x1e, 0x0c,\n    0x20, 0x0d, 0x20, 0x10, 0x1e, 0x0c, 0x05, 0x0c,\n    0x06, 0x0c, 0x07, 0x0d, 0x05, 0x0d, 0x06, 0x0d,\n    0x07, 0x10, 0x1e, 0x11, 0x1e, 0x00, 0x24, 0x00,\n    0x24, 0x2a, 0x06, 0x00, 0x02, 0x1b, 0x00, 0x03,\n    0x02, 0x00, 0x03, 0x02, 0x00, 0x03, 0x1b, 0x00,\n    0x04, 0x1b, 0x00, 0x1b, 0x02, 0x00, 0x1b, 0x03,\n    0x00, 0x1b, 0x04, 0x02, 0x1b, 0x03, 0x02, 0x1b,\n    0x03, 0x03, 0x1b, 0x20, 0x03, 0x1b, 0x1f, 0x09,\n    0x03, 0x02, 0x09, 0x02, 0x03, 0x09, 0x02, 0x1f,\n    0x09, 0x1b, 0x03, 0x09, 0x1b, 0x03, 0x09, 0x1b,\n    0x02, 0x09, 0x1b, 0x1b, 0x09, 0x1b, 0x1b, 0x0b,\n    0x03, 0x03, 0x0b, 0x03, 0x03, 0x0b, 0x1b, 0x1b,\n    0x0a, 0x03, 0x1b, 0x0a, 0x03, 0x1b, 0x0a, 0x02,\n    0x20, 0x0a, 0x1b, 0x04, 0x0a, 0x1b, 0x04, 0x0a,\n    0x1b, 0x1b, 0x0a, 0x1b, 0x1b, 0x0c, 0x03, 0x1f,\n    0x0c, 0x04, 0x1b, 0x0c, 0x04, 0x1b, 0x0d, 0x1b,\n    0x03, 0x0d, 0x1b, 0x03, 0x0d, 0x1b, 0x1b, 0x0d,\n    0x1b, 0x20, 0x0f, 0x02, 0x1b, 0x0f, 0x1b, 0x1b,\n    0x0f, 0x1b, 0x1b, 0x0f, 0x1b, 0x1f, 0x10, 0x1b,\n    0x1b, 0x10, 0x1b, 0x20, 0x10, 0x1b, 0x1f, 0x17,\n    0x04, 0x1b, 0x17, 0x04, 0x1b, 0x18, 0x1b, 0x03,\n    0x18, 0x1b, 0x1b, 0x1a, 0x03, 0x1b, 0x1a, 0x03,\n    0x20, 0x1a, 0x03, 0x1f, 0x1a, 0x02, 0x02, 0x1a,\n    0x02, 0x02, 0x1a, 0x04, 0x1b, 0x1a, 0x04, 0x1b,\n    0x1a, 0x1b, 0x03, 0x1a, 0x1b, 0x03, 0x1b, 0x03,\n    0x02, 0x1b, 0x03, 0x1b, 0x1b, 0x03, 0x20, 0x1b,\n    0x02, 0x03, 0x1b, 0x02, 0x1b, 0x1b, 0x04, 0x02,\n    0x1b, 0x04, 0x1b, 0x28, 0x06, 0x1d, 0x04, 0x06,\n    0x1f, 0x1d, 0x04, 0x1f, 0x1d, 0x1d, 0x1e, 0x05,\n    0x1d, 0x1e, 0x05, 0x21, 0x1e, 0x04, 0x1d, 0x1e,\n    0x04, 0x1d, 0x1e, 0x04, 0x21, 0x1e, 0x1d, 0x22,\n    0x1e, 0x1d, 0x21, 0x22, 0x1d, 0x1d, 0x22, 0x1d,\n    0x1d, 0x00, 0x06, 0x22, 0x02, 0x04, 0x22, 0x02,\n    0x04, 0x21, 0x02, 0x06, 0x22, 0x02, 0x06, 0x21,\n    0x02, 0x1d, 0x22, 0x02, 0x1d, 0x21, 0x04, 0x1d,\n    0x22, 0x04, 0x05, 0x21, 0x04, 0x1d, 0x21, 0x0b,\n    0x06, 0x21, 0x0d, 0x05, 0x22, 0x0c, 0x05, 0x22,\n    0x0e, 0x05, 0x22, 0x1c, 0x04, 0x22, 0x1c, 0x1d,\n    0x22, 0x22, 0x05, 0x22, 0x22, 0x04, 0x22, 0x22,\n    0x1d, 0x22, 0x1d, 0x1d, 0x22, 0x1a, 0x1d, 0x22,\n    0x1e, 0x05, 0x22, 0x1a, 0x1d, 0x05, 0x1c, 0x05,\n    0x1d, 0x11, 0x1d, 0x22, 0x1b, 0x1d, 0x22, 0x1e,\n    0x04, 0x05, 0x1d, 0x06, 0x22, 0x1c, 0x04, 0x1d,\n    0x1b, 0x1d, 0x1d, 0x1c, 0x04, 0x1d, 0x1e, 0x04,\n    0x05, 0x04, 0x05, 0x22, 0x05, 0x04, 0x22, 0x1d,\n    0x04, 0x22, 0x19, 0x1d, 0x22, 0x00, 0x05, 0x22,\n    0x1b, 0x1d, 0x1d, 0x11, 0x04, 0x1d, 0x0d, 0x1d,\n    0x1d, 0x0b, 0x06, 0x22, 0x1e, 0x04, 0x22, 0x35,\n    0x06, 0x00, 0x0f, 0x9d, 0x0d, 0x0f, 0x9d, 0x27,\n    0x06, 0x00, 0x1d, 0x1d, 0x20, 0x00, 0x1c, 0x01,\n    0x0a, 0x1e, 0x06, 0x1e, 0x08, 0x0e, 0x1d, 0x12,\n    0x1e, 0x0a, 0x0c, 0x21, 0x1d, 0x12, 0x1d, 0x23,\n    0x20, 0x21, 0x0c, 0x1d, 0x1e, 0x35, 0x06, 0x00,\n    0x0f, 0x14, 0x27, 0x06, 0x0e, 0x1d, 0x22, 0xff,\n    0x00, 0x1d, 0x1d, 0x20, 0xff, 0x12, 0x1d, 0x23,\n    0x20, 0xff, 0x21, 0x0c, 0x1d, 0x1e, 0x27, 0x06,\n    0x05, 0x1d, 0xff, 0x05, 0x1d, 0x00, 0x1d, 0x20,\n    0x27, 0x06, 0x0a, 0xa5, 0x00, 0x1d, 0x2c, 0x00,\n    0x01, 0x30, 0x02, 0x30, 0x3a, 0x00, 0x3b, 0x00,\n    0x21, 0x00, 0x3f, 0x00, 0x16, 0x30, 0x17, 0x30,\n    0x26, 0x20, 0x13, 0x20, 0x12, 0x01, 0x00, 0x5f,\n    0x5f, 0x28, 0x29, 0x7b, 0x7d, 0x08, 0x30, 0x0c,\n    0x0d, 0x08, 0x09, 0x02, 0x03, 0x00, 0x01, 0x04,\n    0x05, 0x06, 0x07, 0x5b, 0x00, 0x5d, 0x00, 0x3e,\n    0x20, 0x3e, 0x20, 0x3e, 0x20, 0x3e, 0x20, 0x5f,\n    0x00, 0x5f, 0x00, 0x5f, 0x00, 0x2c, 0x00, 0x01,\n    0x30, 0x2e, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x3a,\n    0x00, 0x3f, 0x00, 0x21, 0x00, 0x14, 0x20, 0x28,\n    0x00, 0x29, 0x00, 0x7b, 0x00, 0x7d, 0x00, 0x14,\n    0x30, 0x15, 0x30, 0x23, 0x26, 0x2a, 0x2b, 0x2d,\n    0x3c, 0x3e, 0x3d, 0x00, 0x5c, 0x24, 0x25, 0x40,\n    0x40, 0x06, 0xff, 0x0b, 0x00, 0x0b, 0xff, 0x0c,\n    0x20, 0x00, 0x4d, 0x06, 0x40, 0x06, 0xff, 0x0e,\n    0x00, 0x0e, 0xff, 0x0f, 0x00, 0x0f, 0xff, 0x10,\n    0x00, 0x10, 0xff, 0x11, 0x00, 0x11, 0xff, 0x12,\n    0x00, 0x12, 0x21, 0x06, 0x00, 0x01, 0x01, 0x02,\n    0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x05,\n    0x05, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x08,\n    0x08, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a,\n    0x0a, 0x0b, 0x0b, 0x0b, 0x0b, 0x0c, 0x0c, 0x0c,\n    0x0c, 0x0d, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f,\n    0x0f, 0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x12,\n    0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14, 0x14,\n    0x14, 0x15, 0x15, 0x15, 0x15, 0x16, 0x16, 0x16,\n    0x16, 0x17, 0x17, 0x17, 0x17, 0x18, 0x18, 0x18,\n    0x18, 0x19, 0x19, 0x19, 0x19, 0x20, 0x20, 0x20,\n    0x20, 0x21, 0x21, 0x21, 0x21, 0x22, 0x22, 0x22,\n    0x22, 0x23, 0x23, 0x23, 0x23, 0x24, 0x24, 0x24,\n    0x24, 0x25, 0x25, 0x25, 0x25, 0x26, 0x26, 0x26,\n    0x26, 0x27, 0x27, 0x28, 0x28, 0x29, 0x29, 0x29,\n    0x29, 0x22, 0x06, 0x22, 0x00, 0x22, 0x00, 0x22,\n    0x01, 0x22, 0x01, 0x22, 0x03, 0x22, 0x03, 0x22,\n    0x05, 0x22, 0x05, 0x21, 0x00, 0x85, 0x29, 0x01,\n    0x30, 0x01, 0x0b, 0x0c, 0x00, 0xfa, 0xf1, 0xa0,\n    0xa2, 0xa4, 0xa6, 0xa8, 0xe2, 0xe4, 0xe6, 0xc2,\n    0xfb, 0xa1, 0xa3, 0xa5, 0xa7, 0xa9, 0xaa, 0xac,\n    0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc,\n    0xbe, 0xc0, 0xc3, 0xc5, 0xc7, 0xc9, 0xca, 0xcb,\n    0xcc, 0xcd, 0xce, 0xd1, 0xd4, 0xd7, 0xda, 0xdd,\n    0xde, 0xdf, 0xe0, 0xe1, 0xe3, 0xe5, 0xe7, 0xe8,\n    0xe9, 0xea, 0xeb, 0xec, 0xee, 0xf2, 0x98, 0x99,\n    0x31, 0x31, 0x4f, 0x31, 0x55, 0x31, 0x5b, 0x31,\n    0x61, 0x31, 0xa2, 0x00, 0xa3, 0x00, 0xac, 0x00,\n    0xaf, 0x00, 0xa6, 0x00, 0xa5, 0x00, 0xa9, 0x20,\n    0x00, 0x00, 0x02, 0x25, 0x90, 0x21, 0x91, 0x21,\n    0x92, 0x21, 0x93, 0x21, 0xa0, 0x25, 0xcb, 0x25,\n    0xd0, 0x02, 0xd1, 0x02, 0xe6, 0x00, 0x99, 0x02,\n    0x53, 0x02, 0x00, 0x00, 0xa3, 0x02, 0x66, 0xab,\n    0xa5, 0x02, 0xa4, 0x02, 0x56, 0x02, 0x57, 0x02,\n    0x91, 0x1d, 0x58, 0x02, 0x5e, 0x02, 0xa9, 0x02,\n    0x64, 0x02, 0x62, 0x02, 0x60, 0x02, 0x9b, 0x02,\n    0x27, 0x01, 0x9c, 0x02, 0x67, 0x02, 0x84, 0x02,\n    0xaa, 0x02, 0xab, 0x02, 0x6c, 0x02, 0x04, 0xdf,\n    0x8e, 0xa7, 0x6e, 0x02, 0x05, 0xdf, 0x8e, 0x02,\n    0x06, 0xdf, 0xf8, 0x00, 0x76, 0x02, 0x77, 0x02,\n    0x71, 0x00, 0x7a, 0x02, 0x08, 0xdf, 0x7d, 0x02,\n    0x7e, 0x02, 0x80, 0x02, 0xa8, 0x02, 0xa6, 0x02,\n    0x67, 0xab, 0xa7, 0x02, 0x88, 0x02, 0x71, 0x2c,\n    0x00, 0x00, 0x8f, 0x02, 0xa1, 0x02, 0xa2, 0x02,\n    0x98, 0x02, 0xc0, 0x01, 0xc1, 0x01, 0xc2, 0x01,\n    0x0a, 0xdf, 0x1e, 0xdf, 0x41, 0x04, 0x40, 0x00,\n    0x00, 0x00, 0x00, 0x14, 0x99, 0x10, 0xba, 0x10,\n    0x00, 0x00, 0x00, 0x00, 0x9b, 0x10, 0xba, 0x10,\n    0x05, 0x05, 0xa5, 0x10, 0xba, 0x10, 0x05, 0x31,\n    0x11, 0x27, 0x11, 0x32, 0x11, 0x27, 0x11, 0x55,\n    0x47, 0x13, 0x3e, 0x13, 0x47, 0x13, 0x57, 0x13,\n    0x55, 0xb9, 0x14, 0xba, 0x14, 0xb9, 0x14, 0xb0,\n    0x14, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x14, 0xbd,\n    0x14, 0x55, 0x50, 0xb8, 0x15, 0xaf, 0x15, 0xb9,\n    0x15, 0xaf, 0x15, 0x55, 0x35, 0x19, 0x30, 0x19,\n    0x05, 0x57, 0xd1, 0x65, 0xd1, 0x58, 0xd1, 0x65,\n    0xd1, 0x5f, 0xd1, 0x6e, 0xd1, 0x5f, 0xd1, 0x6f,\n    0xd1, 0x5f, 0xd1, 0x70, 0xd1, 0x5f, 0xd1, 0x71,\n    0xd1, 0x5f, 0xd1, 0x72, 0xd1, 0x55, 0x55, 0x55,\n    0x05, 0xb9, 0xd1, 0x65, 0xd1, 0xba, 0xd1, 0x65,\n    0xd1, 0xbb, 0xd1, 0x6e, 0xd1, 0xbc, 0xd1, 0x6e,\n    0xd1, 0xbb, 0xd1, 0x6f, 0xd1, 0xbc, 0xd1, 0x6f,\n    0xd1, 0x55, 0x55, 0x55, 0x41, 0x00, 0x61, 0x00,\n    0x41, 0x00, 0x61, 0x00, 0x69, 0x00, 0x41, 0x00,\n    0x61, 0x00, 0x41, 0x00, 0x43, 0x44, 0x00, 0x00,\n    0x47, 0x00, 0x00, 0x4a, 0x4b, 0x00, 0x00, 0x4e,\n    0x4f, 0x50, 0x51, 0x00, 0x53, 0x54, 0x55, 0x56,\n    0x57, 0x58, 0x59, 0x5a, 0x61, 0x62, 0x63, 0x64,\n    0x00, 0x66, 0x68, 0x00, 0x70, 0x00, 0x41, 0x00,\n    0x61, 0x00, 0x41, 0x42, 0x00, 0x44, 0x45, 0x46,\n    0x47, 0x4a, 0x00, 0x53, 0x00, 0x61, 0x00, 0x41,\n    0x42, 0x00, 0x44, 0x45, 0x46, 0x47, 0x00, 0x49,\n    0x4a, 0x4b, 0x4c, 0x4d, 0x00, 0x4f, 0x53, 0x00,\n    0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41, 0x00,\n    0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41, 0x00,\n    0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41, 0x00,\n    0x61, 0x00, 0x31, 0x01, 0x37, 0x02, 0x91, 0x03,\n    0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03, 0x24, 0x00,\n    0x1f, 0x04, 0x20, 0x05, 0x91, 0x03, 0xa3, 0x03,\n    0xb1, 0x03, 0xd1, 0x03, 0x24, 0x00, 0x1f, 0x04,\n    0x20, 0x05, 0x91, 0x03, 0xa3, 0x03, 0xb1, 0x03,\n    0xd1, 0x03, 0x24, 0x00, 0x1f, 0x04, 0x20, 0x05,\n    0x91, 0x03, 0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03,\n    0x24, 0x00, 0x1f, 0x04, 0x20, 0x05, 0x91, 0x03,\n    0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03, 0x24, 0x00,\n    0x1f, 0x04, 0x20, 0x05, 0x0b, 0x0c, 0x30, 0x00,\n    0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00,\n    0x30, 0x04, 0x3a, 0x04, 0x3e, 0x04, 0x4b, 0x04,\n    0x4d, 0x04, 0x4e, 0x04, 0x89, 0xa6, 0x30, 0x04,\n    0xa9, 0x26, 0x28, 0xb9, 0x7f, 0x9f, 0x00, 0x01,\n    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x0a,\n    0x0b, 0x0e, 0x0f, 0x11, 0x13, 0x14, 0x15, 0x16,\n    0x17, 0x18, 0x1a, 0x1b, 0x61, 0x26, 0x25, 0x2f,\n    0x7b, 0x51, 0xa6, 0xb1, 0x04, 0x27, 0x06, 0x00,\n    0x01, 0x05, 0x08, 0x2a, 0x06, 0x1e, 0x08, 0x03,\n    0x0d, 0x20, 0x19, 0x1a, 0x1b, 0x1c, 0x09, 0x0f,\n    0x17, 0x0b, 0x18, 0x07, 0x0a, 0x00, 0x01, 0x04,\n    0x06, 0x0c, 0x0e, 0x10, 0x44, 0x90, 0x77, 0x45,\n    0x28, 0x06, 0x2c, 0x06, 0x00, 0x00, 0x47, 0x06,\n    0x33, 0x06, 0x17, 0x10, 0x11, 0x12, 0x13, 0x00,\n    0x06, 0x0e, 0x02, 0x0f, 0x34, 0x06, 0x2a, 0x06,\n    0x2b, 0x06, 0x2e, 0x06, 0x00, 0x00, 0x36, 0x06,\n    0x00, 0x00, 0x3a, 0x06, 0x2d, 0x06, 0x00, 0x00,\n    0x4a, 0x06, 0x00, 0x00, 0x44, 0x06, 0x00, 0x00,\n    0x46, 0x06, 0x33, 0x06, 0x39, 0x06, 0x00, 0x00,\n    0x35, 0x06, 0x42, 0x06, 0x00, 0x00, 0x34, 0x06,\n    0x00, 0x00, 0x00, 0x00, 0x2e, 0x06, 0x00, 0x00,\n    0x36, 0x06, 0x00, 0x00, 0x3a, 0x06, 0x00, 0x00,\n    0xba, 0x06, 0x00, 0x00, 0x6f, 0x06, 0x00, 0x00,\n    0x28, 0x06, 0x2c, 0x06, 0x00, 0x00, 0x47, 0x06,\n    0x00, 0x00, 0x00, 0x00, 0x2d, 0x06, 0x37, 0x06,\n    0x4a, 0x06, 0x43, 0x06, 0x00, 0x00, 0x45, 0x06,\n    0x46, 0x06, 0x33, 0x06, 0x39, 0x06, 0x41, 0x06,\n    0x35, 0x06, 0x42, 0x06, 0x00, 0x00, 0x34, 0x06,\n    0x2a, 0x06, 0x2b, 0x06, 0x2e, 0x06, 0x00, 0x00,\n    0x36, 0x06, 0x38, 0x06, 0x3a, 0x06, 0x6e, 0x06,\n    0x00, 0x00, 0xa1, 0x06, 0x27, 0x06, 0x00, 0x01,\n    0x05, 0x08, 0x20, 0x21, 0x0b, 0x06, 0x10, 0x23,\n    0x2a, 0x06, 0x1a, 0x1b, 0x1c, 0x09, 0x0f, 0x17,\n    0x0b, 0x18, 0x07, 0x0a, 0x00, 0x01, 0x04, 0x06,\n    0x0c, 0x0e, 0x10, 0x28, 0x06, 0x2c, 0x06, 0x2f,\n    0x06, 0x00, 0x00, 0x48, 0x06, 0x32, 0x06, 0x2d,\n    0x06, 0x37, 0x06, 0x4a, 0x06, 0x2a, 0x06, 0x1a,\n    0x1b, 0x1c, 0x09, 0x0f, 0x17, 0x0b, 0x18, 0x07,\n    0x0a, 0x00, 0x01, 0x04, 0x06, 0x0c, 0x0e, 0x10,\n    0x30, 0x2e, 0x30, 0x00, 0x2c, 0x00, 0x28, 0x00,\n    0x41, 0x00, 0x29, 0x00, 0x14, 0x30, 0x53, 0x00,\n    0x15, 0x30, 0x43, 0x52, 0x43, 0x44, 0x57, 0x5a,\n    0x41, 0x00, 0x48, 0x56, 0x4d, 0x56, 0x53, 0x44,\n    0x53, 0x53, 0x50, 0x50, 0x56, 0x57, 0x43, 0x4d,\n    0x43, 0x4d, 0x44, 0x4d, 0x52, 0x44, 0x4a, 0x4b,\n    0x30, 0x30, 0x00, 0x68, 0x68, 0x4b, 0x62, 0x57,\n    0x5b, 0xcc, 0x53, 0xc7, 0x30, 0x8c, 0x4e, 0x1a,\n    0x59, 0xe3, 0x89, 0x29, 0x59, 0xa4, 0x4e, 0x20,\n    0x66, 0x21, 0x71, 0x99, 0x65, 0x4d, 0x52, 0x8c,\n    0x5f, 0x8d, 0x51, 0xb0, 0x65, 0x1d, 0x52, 0x42,\n    0x7d, 0x1f, 0x75, 0xa9, 0x8c, 0xf0, 0x58, 0x39,\n    0x54, 0x14, 0x6f, 0x95, 0x62, 0x55, 0x63, 0x00,\n    0x4e, 0x09, 0x4e, 0x4a, 0x90, 0xe6, 0x5d, 0x2d,\n    0x4e, 0xf3, 0x53, 0x07, 0x63, 0x70, 0x8d, 0x53,\n    0x62, 0x81, 0x79, 0x7a, 0x7a, 0x08, 0x54, 0x80,\n    0x6e, 0x09, 0x67, 0x08, 0x67, 0x33, 0x75, 0x72,\n    0x52, 0xb6, 0x55, 0x4d, 0x91, 0x14, 0x30, 0x15,\n    0x30, 0x2c, 0x67, 0x09, 0x4e, 0x8c, 0x4e, 0x89,\n    0x5b, 0xb9, 0x70, 0x53, 0x62, 0xd7, 0x76, 0xdd,\n    0x52, 0x57, 0x65, 0x97, 0x5f, 0xef, 0x53, 0x30,\n    0x00, 0x38, 0x4e, 0x05, 0x00, 0x09, 0x22, 0x01,\n    0x60, 0x4f, 0xae, 0x4f, 0xbb, 0x4f, 0x02, 0x50,\n    0x7a, 0x50, 0x99, 0x50, 0xe7, 0x50, 0xcf, 0x50,\n    0x9e, 0x34, 0x3a, 0x06, 0x4d, 0x51, 0x54, 0x51,\n    0x64, 0x51, 0x77, 0x51, 0x1c, 0x05, 0xb9, 0x34,\n    0x67, 0x51, 0x8d, 0x51, 0x4b, 0x05, 0x97, 0x51,\n    0xa4, 0x51, 0xcc, 0x4e, 0xac, 0x51, 0xb5, 0x51,\n    0xdf, 0x91, 0xf5, 0x51, 0x03, 0x52, 0xdf, 0x34,\n    0x3b, 0x52, 0x46, 0x52, 0x72, 0x52, 0x77, 0x52,\n    0x15, 0x35, 0x02, 0x00, 0x20, 0x80, 0x80, 0x00,\n    0x08, 0x00, 0x00, 0xc7, 0x52, 0x00, 0x02, 0x1d,\n    0x33, 0x3e, 0x3f, 0x50, 0x82, 0x8a, 0x93, 0xac,\n    0xb6, 0xb8, 0xb8, 0xb8, 0x2c, 0x0a, 0x70, 0x70,\n    0xca, 0x53, 0xdf, 0x53, 0x63, 0x0b, 0xeb, 0x53,\n    0xf1, 0x53, 0x06, 0x54, 0x9e, 0x54, 0x38, 0x54,\n    0x48, 0x54, 0x68, 0x54, 0xa2, 0x54, 0xf6, 0x54,\n    0x10, 0x55, 0x53, 0x55, 0x63, 0x55, 0x84, 0x55,\n    0x84, 0x55, 0x99, 0x55, 0xab, 0x55, 0xb3, 0x55,\n    0xc2, 0x55, 0x16, 0x57, 0x06, 0x56, 0x17, 0x57,\n    0x51, 0x56, 0x74, 0x56, 0x07, 0x52, 0xee, 0x58,\n    0xce, 0x57, 0xf4, 0x57, 0x0d, 0x58, 0x8b, 0x57,\n    0x32, 0x58, 0x31, 0x58, 0xac, 0x58, 0xe4, 0x14,\n    0xf2, 0x58, 0xf7, 0x58, 0x06, 0x59, 0x1a, 0x59,\n    0x22, 0x59, 0x62, 0x59, 0xa8, 0x16, 0xea, 0x16,\n    0xec, 0x59, 0x1b, 0x5a, 0x27, 0x5a, 0xd8, 0x59,\n    0x66, 0x5a, 0xee, 0x36, 0xfc, 0x36, 0x08, 0x5b,\n    0x3e, 0x5b, 0x3e, 0x5b, 0xc8, 0x19, 0xc3, 0x5b,\n    0xd8, 0x5b, 0xe7, 0x5b, 0xf3, 0x5b, 0x18, 0x1b,\n    0xff, 0x5b, 0x06, 0x5c, 0x53, 0x5f, 0x22, 0x5c,\n    0x81, 0x37, 0x60, 0x5c, 0x6e, 0x5c, 0xc0, 0x5c,\n    0x8d, 0x5c, 0xe4, 0x1d, 0x43, 0x5d, 0xe6, 0x1d,\n    0x6e, 0x5d, 0x6b, 0x5d, 0x7c, 0x5d, 0xe1, 0x5d,\n    0xe2, 0x5d, 0x2f, 0x38, 0xfd, 0x5d, 0x28, 0x5e,\n    0x3d, 0x5e, 0x69, 0x5e, 0x62, 0x38, 0x83, 0x21,\n    0x7c, 0x38, 0xb0, 0x5e, 0xb3, 0x5e, 0xb6, 0x5e,\n    0xca, 0x5e, 0x92, 0xa3, 0xfe, 0x5e, 0x31, 0x23,\n    0x31, 0x23, 0x01, 0x82, 0x22, 0x5f, 0x22, 0x5f,\n    0xc7, 0x38, 0xb8, 0x32, 0xda, 0x61, 0x62, 0x5f,\n    0x6b, 0x5f, 0xe3, 0x38, 0x9a, 0x5f, 0xcd, 0x5f,\n    0xd7, 0x5f, 0xf9, 0x5f, 0x81, 0x60, 0x3a, 0x39,\n    0x1c, 0x39, 0x94, 0x60, 0xd4, 0x26, 0xc7, 0x60,\n    0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x02, 0x08,\n    0x00, 0x80, 0x08, 0x00, 0x00, 0x08, 0x80, 0x28,\n    0x80, 0x02, 0x00, 0x00, 0x02, 0x48, 0x61, 0x00,\n    0x04, 0x06, 0x04, 0x32, 0x46, 0x6a, 0x5c, 0x67,\n    0x96, 0xaa, 0xae, 0xc8, 0xd3, 0x5d, 0x62, 0x00,\n    0x54, 0x77, 0xf3, 0x0c, 0x2b, 0x3d, 0x63, 0xfc,\n    0x62, 0x68, 0x63, 0x83, 0x63, 0xe4, 0x63, 0xf1,\n    0x2b, 0x22, 0x64, 0xc5, 0x63, 0xa9, 0x63, 0x2e,\n    0x3a, 0x69, 0x64, 0x7e, 0x64, 0x9d, 0x64, 0x77,\n    0x64, 0x6c, 0x3a, 0x4f, 0x65, 0x6c, 0x65, 0x0a,\n    0x30, 0xe3, 0x65, 0xf8, 0x66, 0x49, 0x66, 0x19,\n    0x3b, 0x91, 0x66, 0x08, 0x3b, 0xe4, 0x3a, 0x92,\n    0x51, 0x95, 0x51, 0x00, 0x67, 0x9c, 0x66, 0xad,\n    0x80, 0xd9, 0x43, 0x17, 0x67, 0x1b, 0x67, 0x21,\n    0x67, 0x5e, 0x67, 0x53, 0x67, 0xc3, 0x33, 0x49,\n    0x3b, 0xfa, 0x67, 0x85, 0x67, 0x52, 0x68, 0x85,\n    0x68, 0x6d, 0x34, 0x8e, 0x68, 0x1f, 0x68, 0x14,\n    0x69, 0x9d, 0x3b, 0x42, 0x69, 0xa3, 0x69, 0xea,\n    0x69, 0xa8, 0x6a, 0xa3, 0x36, 0xdb, 0x6a, 0x18,\n    0x3c, 0x21, 0x6b, 0xa7, 0x38, 0x54, 0x6b, 0x4e,\n    0x3c, 0x72, 0x6b, 0x9f, 0x6b, 0xba, 0x6b, 0xbb,\n    0x6b, 0x8d, 0x3a, 0x0b, 0x1d, 0xfa, 0x3a, 0x4e,\n    0x6c, 0xbc, 0x3c, 0xbf, 0x6c, 0xcd, 0x6c, 0x67,\n    0x6c, 0x16, 0x6d, 0x3e, 0x6d, 0x77, 0x6d, 0x41,\n    0x6d, 0x69, 0x6d, 0x78, 0x6d, 0x85, 0x6d, 0x1e,\n    0x3d, 0x34, 0x6d, 0x2f, 0x6e, 0x6e, 0x6e, 0x33,\n    0x3d, 0xcb, 0x6e, 0xc7, 0x6e, 0xd1, 0x3e, 0xf9,\n    0x6d, 0x6e, 0x6f, 0x5e, 0x3f, 0x8e, 0x3f, 0xc6,\n    0x6f, 0x39, 0x70, 0x1e, 0x70, 0x1b, 0x70, 0x96,\n    0x3d, 0x4a, 0x70, 0x7d, 0x70, 0x77, 0x70, 0xad,\n    0x70, 0x25, 0x05, 0x45, 0x71, 0x63, 0x42, 0x9c,\n    0x71, 0xab, 0x43, 0x28, 0x72, 0x35, 0x72, 0x50,\n    0x72, 0x08, 0x46, 0x80, 0x72, 0x95, 0x72, 0x35,\n    0x47, 0x02, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00,\n    0x00, 0x00, 0x08, 0x80, 0x00, 0x00, 0x02, 0x02,\n    0x80, 0x8a, 0x00, 0x00, 0x20, 0x00, 0x08, 0x0a,\n    0x00, 0x80, 0x88, 0x80, 0x20, 0x14, 0x48, 0x7a,\n    0x73, 0x8b, 0x73, 0xac, 0x3e, 0xa5, 0x73, 0xb8,\n    0x3e, 0xb8, 0x3e, 0x47, 0x74, 0x5c, 0x74, 0x71,\n    0x74, 0x85, 0x74, 0xca, 0x74, 0x1b, 0x3f, 0x24,\n    0x75, 0x36, 0x4c, 0x3e, 0x75, 0x92, 0x4c, 0x70,\n    0x75, 0x9f, 0x21, 0x10, 0x76, 0xa1, 0x4f, 0xb8,\n    0x4f, 0x44, 0x50, 0xfc, 0x3f, 0x08, 0x40, 0xf4,\n    0x76, 0xf3, 0x50, 0xf2, 0x50, 0x19, 0x51, 0x33,\n    0x51, 0x1e, 0x77, 0x1f, 0x77, 0x1f, 0x77, 0x4a,\n    0x77, 0x39, 0x40, 0x8b, 0x77, 0x46, 0x40, 0x96,\n    0x40, 0x1d, 0x54, 0x4e, 0x78, 0x8c, 0x78, 0xcc,\n    0x78, 0xe3, 0x40, 0x26, 0x56, 0x56, 0x79, 0x9a,\n    0x56, 0xc5, 0x56, 0x8f, 0x79, 0xeb, 0x79, 0x2f,\n    0x41, 0x40, 0x7a, 0x4a, 0x7a, 0x4f, 0x7a, 0x7c,\n    0x59, 0xa7, 0x5a, 0xa7, 0x5a, 0xee, 0x7a, 0x02,\n    0x42, 0xab, 0x5b, 0xc6, 0x7b, 0xc9, 0x7b, 0x27,\n    0x42, 0x80, 0x5c, 0xd2, 0x7c, 0xa0, 0x42, 0xe8,\n    0x7c, 0xe3, 0x7c, 0x00, 0x7d, 0x86, 0x5f, 0x63,\n    0x7d, 0x01, 0x43, 0xc7, 0x7d, 0x02, 0x7e, 0x45,\n    0x7e, 0x34, 0x43, 0x28, 0x62, 0x47, 0x62, 0x59,\n    0x43, 0xd9, 0x62, 0x7a, 0x7f, 0x3e, 0x63, 0x95,\n    0x7f, 0xfa, 0x7f, 0x05, 0x80, 0xda, 0x64, 0x23,\n    0x65, 0x60, 0x80, 0xa8, 0x65, 0x70, 0x80, 0x5f,\n    0x33, 0xd5, 0x43, 0xb2, 0x80, 0x03, 0x81, 0x0b,\n    0x44, 0x3e, 0x81, 0xb5, 0x5a, 0xa7, 0x67, 0xb5,\n    0x67, 0x93, 0x33, 0x9c, 0x33, 0x01, 0x82, 0x04,\n    0x82, 0x9e, 0x8f, 0x6b, 0x44, 0x91, 0x82, 0x8b,\n    0x82, 0x9d, 0x82, 0xb3, 0x52, 0xb1, 0x82, 0xb3,\n    0x82, 0xbd, 0x82, 0xe6, 0x82, 0x3c, 0x6b, 0xe5,\n    0x82, 0x1d, 0x83, 0x63, 0x83, 0xad, 0x83, 0x23,\n    0x83, 0xbd, 0x83, 0xe7, 0x83, 0x57, 0x84, 0x53,\n    0x83, 0xca, 0x83, 0xcc, 0x83, 0xdc, 0x83, 0x36,\n    0x6c, 0x6b, 0x6d, 0x02, 0x00, 0x00, 0x20, 0x22,\n    0x2a, 0xa0, 0x0a, 0x00, 0x20, 0x80, 0x28, 0x00,\n    0xa8, 0x20, 0x20, 0x00, 0x02, 0x80, 0x22, 0x02,\n    0x8a, 0x08, 0x00, 0xaa, 0x00, 0x00, 0x00, 0x02,\n    0x00, 0x00, 0x28, 0xd5, 0x6c, 0x2b, 0x45, 0xf1,\n    0x84, 0xf3, 0x84, 0x16, 0x85, 0xca, 0x73, 0x64,\n    0x85, 0x2c, 0x6f, 0x5d, 0x45, 0x61, 0x45, 0xb1,\n    0x6f, 0xd2, 0x70, 0x6b, 0x45, 0x50, 0x86, 0x5c,\n    0x86, 0x67, 0x86, 0x69, 0x86, 0xa9, 0x86, 0x88,\n    0x86, 0x0e, 0x87, 0xe2, 0x86, 0x79, 0x87, 0x28,\n    0x87, 0x6b, 0x87, 0x86, 0x87, 0xd7, 0x45, 0xe1,\n    0x87, 0x01, 0x88, 0xf9, 0x45, 0x60, 0x88, 0x63,\n    0x88, 0x67, 0x76, 0xd7, 0x88, 0xde, 0x88, 0x35,\n    0x46, 0xfa, 0x88, 0xbb, 0x34, 0xae, 0x78, 0x66,\n    0x79, 0xbe, 0x46, 0xc7, 0x46, 0xa0, 0x8a, 0xed,\n    0x8a, 0x8a, 0x8b, 0x55, 0x8c, 0xa8, 0x7c, 0xab,\n    0x8c, 0xc1, 0x8c, 0x1b, 0x8d, 0x77, 0x8d, 0x2f,\n    0x7f, 0x04, 0x08, 0xcb, 0x8d, 0xbc, 0x8d, 0xf0,\n    0x8d, 0xde, 0x08, 0xd4, 0x8e, 0x38, 0x8f, 0xd2,\n    0x85, 0xed, 0x85, 0x94, 0x90, 0xf1, 0x90, 0x11,\n    0x91, 0x2e, 0x87, 0x1b, 0x91, 0x38, 0x92, 0xd7,\n    0x92, 0xd8, 0x92, 0x7c, 0x92, 0xf9, 0x93, 0x15,\n    0x94, 0xfa, 0x8b, 0x8b, 0x95, 0x95, 0x49, 0xb7,\n    0x95, 0x77, 0x8d, 0xe6, 0x49, 0xc3, 0x96, 0xb2,\n    0x5d, 0x23, 0x97, 0x45, 0x91, 0x1a, 0x92, 0x6e,\n    0x4a, 0x76, 0x4a, 0xe0, 0x97, 0x0a, 0x94, 0xb2,\n    0x4a, 0x96, 0x94, 0x0b, 0x98, 0x0b, 0x98, 0x29,\n    0x98, 0xb6, 0x95, 0xe2, 0x98, 0x33, 0x4b, 0x29,\n    0x99, 0xa7, 0x99, 0xc2, 0x99, 0xfe, 0x99, 0xce,\n    0x4b, 0x30, 0x9b, 0x12, 0x9b, 0x40, 0x9c, 0xfd,\n    0x9c, 0xce, 0x4c, 0xed, 0x4c, 0x67, 0x9d, 0xce,\n    0xa0, 0xf8, 0x4c, 0x05, 0xa1, 0x0e, 0xa2, 0x91,\n    0xa2, 0xbb, 0x9e, 0x56, 0x4d, 0xf9, 0x9e, 0xfe,\n    0x9e, 0x05, 0x9f, 0x0f, 0x9f, 0x16, 0x9f, 0x3b,\n    0x9f, 0x00, 0xa6, 0x02, 0x88, 0xa0, 0x00, 0x00,\n    0x00, 0x00, 0x80, 0x00, 0x28, 0x00, 0x08, 0xa0,\n    0x80, 0xa0, 0x80, 0x00, 0x80, 0x80, 0x00, 0x0a,\n    0x88, 0x80, 0x00, 0x80, 0x00, 0x20, 0x2a, 0x00,\n    0x80,\n};\n\nstatic const uint16_t unicode_comp_table[945] = {\n    0x4a01, 0x49c0, 0x4a02, 0x0280, 0x0281, 0x0282, 0x0283, 0x02c0,\n    0x02c2, 0x0a00, 0x0284, 0x2442, 0x0285, 0x07c0, 0x0980, 0x0982,\n    0x2440, 0x2280, 0x02c4, 0x2282, 0x2284, 0x2286, 0x02c6, 0x02c8,\n    0x02ca, 0x02cc, 0x0287, 0x228a, 0x02ce, 0x228c, 0x2290, 0x2292,\n    0x228e, 0x0288, 0x0289, 0x028a, 0x2482, 0x0300, 0x0302, 0x0304,\n    0x028b, 0x2480, 0x0308, 0x0984, 0x0986, 0x2458, 0x0a02, 0x0306,\n    0x2298, 0x229a, 0x229e, 0x0900, 0x030a, 0x22a0, 0x030c, 0x030e,\n    0x0840, 0x0310, 0x0312, 0x22a2, 0x22a6, 0x09c0, 0x22a4, 0x22a8,\n    0x22aa, 0x028c, 0x028d, 0x028e, 0x0340, 0x0342, 0x0344, 0x0380,\n    0x028f, 0x248e, 0x07c2, 0x0988, 0x098a, 0x2490, 0x0346, 0x22ac,\n    0x0400, 0x22b0, 0x0842, 0x22b2, 0x0402, 0x22b4, 0x0440, 0x0444,\n    0x22b6, 0x0442, 0x22c2, 0x22c0, 0x22c4, 0x22c6, 0x22c8, 0x0940,\n    0x04c0, 0x0291, 0x22ca, 0x04c4, 0x22cc, 0x04c2, 0x22d0, 0x22ce,\n    0x0292, 0x0293, 0x0294, 0x0295, 0x0540, 0x0542, 0x0a08, 0x0296,\n    0x2494, 0x0544, 0x07c4, 0x098c, 0x098e, 0x06c0, 0x2492, 0x0844,\n    0x2308, 0x230a, 0x0580, 0x230c, 0x0584, 0x0990, 0x0992, 0x230e,\n    0x0582, 0x2312, 0x0586, 0x0588, 0x2314, 0x058c, 0x2316, 0x0998,\n    0x058a, 0x231e, 0x0590, 0x2320, 0x099a, 0x058e, 0x2324, 0x2322,\n    0x0299, 0x029a, 0x029b, 0x05c0, 0x05c2, 0x05c4, 0x029c, 0x24ac,\n    0x05c6, 0x05c8, 0x07c6, 0x0994, 0x0996, 0x0700, 0x24aa, 0x2326,\n    0x05ca, 0x232a, 0x2328, 0x2340, 0x2342, 0x2344, 0x2346, 0x05cc,\n    0x234a, 0x2348, 0x234c, 0x234e, 0x2350, 0x24b8, 0x029d, 0x05ce,\n    0x24be, 0x0a0c, 0x2352, 0x0600, 0x24bc, 0x24ba, 0x0640, 0x2354,\n    0x0642, 0x0644, 0x2356, 0x2358, 0x02a0, 0x02a1, 0x02a2, 0x02a3,\n    0x02c1, 0x02c3, 0x0a01, 0x02a4, 0x2443, 0x02a5, 0x07c1, 0x0981,\n    0x0983, 0x2441, 0x2281, 0x02c5, 0x2283, 0x2285, 0x2287, 0x02c7,\n    0x02c9, 0x02cb, 0x02cd, 0x02a7, 0x228b, 0x02cf, 0x228d, 0x2291,\n    0x2293, 0x228f, 0x02a8, 0x02a9, 0x02aa, 0x2483, 0x0301, 0x0303,\n    0x0305, 0x02ab, 0x2481, 0x0309, 0x0985, 0x0987, 0x2459, 0x0a03,\n    0x0307, 0x2299, 0x229b, 0x229f, 0x0901, 0x030b, 0x22a1, 0x030d,\n    0x030f, 0x0841, 0x0311, 0x0313, 0x22a3, 0x22a7, 0x09c1, 0x22a5,\n    0x22a9, 0x22ab, 0x2380, 0x02ac, 0x02ad, 0x02ae, 0x0341, 0x0343,\n    0x0345, 0x02af, 0x248f, 0x07c3, 0x0989, 0x098b, 0x2491, 0x0347,\n    0x22ad, 0x0401, 0x0884, 0x22b1, 0x0843, 0x22b3, 0x0403, 0x22b5,\n    0x0441, 0x0445, 0x22b7, 0x0443, 0x22c3, 0x22c1, 0x22c5, 0x22c7,\n    0x22c9, 0x0941, 0x04c1, 0x02b1, 0x22cb, 0x04c5, 0x22cd, 0x04c3,\n    0x22d1, 0x22cf, 0x02b2, 0x02b3, 0x02b4, 0x02b5, 0x0541, 0x0543,\n    0x0a09, 0x02b6, 0x2495, 0x0545, 0x07c5, 0x098d, 0x098f, 0x06c1,\n    0x2493, 0x0845, 0x2309, 0x230b, 0x0581, 0x230d, 0x0585, 0x0991,\n    0x0993, 0x230f, 0x0583, 0x2313, 0x0587, 0x0589, 0x2315, 0x058d,\n    0x2317, 0x0999, 0x058b, 0x231f, 0x2381, 0x0591, 0x2321, 0x099b,\n    0x058f, 0x2325, 0x2323, 0x02b9, 0x02ba, 0x02bb, 0x05c1, 0x05c3,\n    0x05c5, 0x02bc, 0x24ad, 0x05c7, 0x05c9, 0x07c7, 0x0995, 0x0997,\n    0x0701, 0x24ab, 0x2327, 0x05cb, 0x232b, 0x2329, 0x2341, 0x2343,\n    0x2345, 0x2347, 0x05cd, 0x234b, 0x2349, 0x2382, 0x234d, 0x234f,\n    0x2351, 0x24b9, 0x02bd, 0x05cf, 0x24bf, 0x0a0d, 0x2353, 0x02bf,\n    0x24bd, 0x2383, 0x24bb, 0x0641, 0x2355, 0x0643, 0x0645, 0x2357,\n    0x2359, 0x3101, 0x0c80, 0x2e00, 0x2446, 0x2444, 0x244a, 0x2448,\n    0x0800, 0x0942, 0x0944, 0x0804, 0x2288, 0x2486, 0x2484, 0x248a,\n    0x2488, 0x22ae, 0x2498, 0x2496, 0x249c, 0x249a, 0x2300, 0x0a06,\n    0x2302, 0x0a04, 0x0946, 0x07ce, 0x07ca, 0x07c8, 0x07cc, 0x2447,\n    0x2445, 0x244b, 0x2449, 0x0801, 0x0943, 0x0945, 0x0805, 0x2289,\n    0x2487, 0x2485, 0x248b, 0x2489, 0x22af, 0x2499, 0x2497, 0x249d,\n    0x249b, 0x2301, 0x0a07, 0x2303, 0x0a05, 0x0947, 0x07cf, 0x07cb,\n    0x07c9, 0x07cd, 0x2450, 0x244e, 0x2454, 0x2452, 0x2451, 0x244f,\n    0x2455, 0x2453, 0x2294, 0x2296, 0x2295, 0x2297, 0x2304, 0x2306,\n    0x2305, 0x2307, 0x2318, 0x2319, 0x231a, 0x231b, 0x232c, 0x232d,\n    0x232e, 0x232f, 0x2400, 0x24a2, 0x24a0, 0x24a6, 0x24a4, 0x24a8,\n    0x24a3, 0x24a1, 0x24a7, 0x24a5, 0x24a9, 0x24b0, 0x24ae, 0x24b4,\n    0x24b2, 0x24b6, 0x24b1, 0x24af, 0x24b5, 0x24b3, 0x24b7, 0x0882,\n    0x0880, 0x0881, 0x0802, 0x0803, 0x229c, 0x229d, 0x0a0a, 0x0a0b,\n    0x0883, 0x0b40, 0x2c8a, 0x0c81, 0x2c89, 0x2c88, 0x2540, 0x2541,\n    0x2d00, 0x2e07, 0x0d00, 0x2640, 0x2641, 0x2e80, 0x0d01, 0x26c8,\n    0x26c9, 0x2f00, 0x2f84, 0x0d02, 0x2f83, 0x2f82, 0x0d40, 0x26d8,\n    0x26d9, 0x3186, 0x0d04, 0x2740, 0x2741, 0x3100, 0x3086, 0x0d06,\n    0x3085, 0x3084, 0x0d41, 0x2840, 0x3200, 0x0d07, 0x284f, 0x2850,\n    0x3280, 0x2c84, 0x2e03, 0x2857, 0x0d42, 0x2c81, 0x2c80, 0x24c0,\n    0x24c1, 0x2c86, 0x2c83, 0x28c0, 0x0d43, 0x25c0, 0x25c1, 0x2940,\n    0x0d44, 0x26c0, 0x26c1, 0x2e05, 0x2e02, 0x29c0, 0x0d45, 0x2f05,\n    0x2f04, 0x0d80, 0x26d0, 0x26d1, 0x2f80, 0x2a40, 0x0d82, 0x26e0,\n    0x26e1, 0x3080, 0x3081, 0x2ac0, 0x0d83, 0x3004, 0x3003, 0x0d81,\n    0x27c0, 0x27c1, 0x3082, 0x2b40, 0x0d84, 0x2847, 0x2848, 0x3184,\n    0x3181, 0x2f06, 0x0d08, 0x2f81, 0x3005, 0x0d46, 0x3083, 0x3182,\n    0x0e00, 0x0e01, 0x0f40, 0x1180, 0x1182, 0x0f03, 0x0f00, 0x11c0,\n    0x0f01, 0x1140, 0x1202, 0x1204, 0x0f81, 0x1240, 0x0fc0, 0x1242,\n    0x0f80, 0x1244, 0x1284, 0x0f82, 0x1286, 0x1288, 0x128a, 0x12c0,\n    0x1282, 0x1181, 0x1183, 0x1043, 0x1040, 0x11c1, 0x1041, 0x1141,\n    0x1203, 0x1205, 0x10c1, 0x1241, 0x1000, 0x1243, 0x10c0, 0x1245,\n    0x1285, 0x10c2, 0x1287, 0x1289, 0x128b, 0x12c1, 0x1283, 0x1080,\n    0x1100, 0x1101, 0x1200, 0x1201, 0x1280, 0x1281, 0x1340, 0x1341,\n    0x1343, 0x1342, 0x1344, 0x13c2, 0x1400, 0x13c0, 0x1440, 0x1480,\n    0x14c0, 0x1540, 0x1541, 0x1740, 0x1700, 0x1741, 0x17c0, 0x1800,\n    0x1802, 0x1801, 0x1840, 0x1880, 0x1900, 0x18c0, 0x18c1, 0x1901,\n    0x1940, 0x1942, 0x1941, 0x1980, 0x19c0, 0x19c2, 0x19c1, 0x1c80,\n    0x1cc0, 0x1dc0, 0x1f80, 0x2000, 0x2002, 0x2004, 0x2006, 0x2008,\n    0x2040, 0x2080, 0x2082, 0x20c0, 0x20c1, 0x2100, 0x22b8, 0x22b9,\n    0x2310, 0x2311, 0x231c, 0x231d, 0x244c, 0x2456, 0x244d, 0x2457,\n    0x248c, 0x248d, 0x249e, 0x249f, 0x2500, 0x2502, 0x2504, 0x2bc0,\n    0x2501, 0x2503, 0x2505, 0x2bc1, 0x2bc2, 0x2bc3, 0x2bc4, 0x2bc5,\n    0x2bc6, 0x2bc7, 0x2580, 0x2582, 0x2584, 0x2bc8, 0x2581, 0x2583,\n    0x2585, 0x2bc9, 0x2bca, 0x2bcb, 0x2bcc, 0x2bcd, 0x2bce, 0x2bcf,\n    0x2600, 0x2602, 0x2601, 0x2603, 0x2680, 0x2682, 0x2681, 0x2683,\n    0x26c2, 0x26c4, 0x26c6, 0x2c00, 0x26c3, 0x26c5, 0x26c7, 0x2c01,\n    0x2c02, 0x2c03, 0x2c04, 0x2c05, 0x2c06, 0x2c07, 0x26ca, 0x26cc,\n    0x26ce, 0x2c08, 0x26cb, 0x26cd, 0x26cf, 0x2c09, 0x2c0a, 0x2c0b,\n    0x2c0c, 0x2c0d, 0x2c0e, 0x2c0f, 0x26d2, 0x26d4, 0x26d6, 0x26d3,\n    0x26d5, 0x26d7, 0x26da, 0x26dc, 0x26de, 0x26db, 0x26dd, 0x26df,\n    0x2700, 0x2702, 0x2701, 0x2703, 0x2780, 0x2782, 0x2781, 0x2783,\n    0x2800, 0x2802, 0x2804, 0x2801, 0x2803, 0x2805, 0x2842, 0x2844,\n    0x2846, 0x2849, 0x284b, 0x284d, 0x2c40, 0x284a, 0x284c, 0x284e,\n    0x2c41, 0x2c42, 0x2c43, 0x2c44, 0x2c45, 0x2c46, 0x2c47, 0x2851,\n    0x2853, 0x2855, 0x2c48, 0x2852, 0x2854, 0x2856, 0x2c49, 0x2c4a,\n    0x2c4b, 0x2c4c, 0x2c4d, 0x2c4e, 0x2c4f, 0x2c82, 0x2e01, 0x3180,\n    0x2c87, 0x2f01, 0x2f02, 0x2f03, 0x2e06, 0x3185, 0x3000, 0x3001,\n    0x3002, 0x4640, 0x4641, 0x4680, 0x46c0, 0x46c2, 0x46c1, 0x4700,\n    0x4740, 0x4780, 0x47c0, 0x47c2, 0x4900, 0x4940, 0x4980, 0x4982,\n    0x4a00, 0x49c2, 0x4a03, 0x4a04, 0x4a40, 0x4a41, 0x4a80, 0x4a81,\n    0x4ac0, 0x4ac1, 0x4bc0, 0x4bc1, 0x4b00, 0x4b01, 0x4b40, 0x4b41,\n    0x4bc2, 0x4bc3, 0x4b80, 0x4b81, 0x4b82, 0x4b83, 0x4c00, 0x4c01,\n    0x4c02, 0x4c03, 0x5600, 0x5440, 0x5442, 0x5444, 0x5446, 0x5448,\n    0x544a, 0x544c, 0x544e, 0x5450, 0x5452, 0x5454, 0x5456, 0x5480,\n    0x5482, 0x5484, 0x54c0, 0x54c1, 0x5500, 0x5501, 0x5540, 0x5541,\n    0x5580, 0x5581, 0x55c0, 0x55c1, 0x5680, 0x58c0, 0x5700, 0x5702,\n    0x5704, 0x5706, 0x5708, 0x570a, 0x570c, 0x570e, 0x5710, 0x5712,\n    0x5714, 0x5716, 0x5740, 0x5742, 0x5744, 0x5780, 0x5781, 0x57c0,\n    0x57c1, 0x5800, 0x5801, 0x5840, 0x5841, 0x5880, 0x5881, 0x5900,\n    0x5901, 0x5902, 0x5903, 0x5940, 0x8f40, 0x8f42, 0x8f80, 0x8fc0,\n    0x8fc1, 0x9000, 0x9001, 0x9041, 0x9040, 0x9043, 0x9080, 0x9081,\n    0x90c0,\n};\n\ntypedef enum {\n    UNICODE_GC_Cn,\n    UNICODE_GC_Lu,\n    UNICODE_GC_Ll,\n    UNICODE_GC_Lt,\n    UNICODE_GC_Lm,\n    UNICODE_GC_Lo,\n    UNICODE_GC_Mn,\n    UNICODE_GC_Mc,\n    UNICODE_GC_Me,\n    UNICODE_GC_Nd,\n    UNICODE_GC_Nl,\n    UNICODE_GC_No,\n    UNICODE_GC_Sm,\n    UNICODE_GC_Sc,\n    UNICODE_GC_Sk,\n    UNICODE_GC_So,\n    UNICODE_GC_Pc,\n    UNICODE_GC_Pd,\n    UNICODE_GC_Ps,\n    UNICODE_GC_Pe,\n    UNICODE_GC_Pi,\n    UNICODE_GC_Pf,\n    UNICODE_GC_Po,\n    UNICODE_GC_Zs,\n    UNICODE_GC_Zl,\n    UNICODE_GC_Zp,\n    UNICODE_GC_Cc,\n    UNICODE_GC_Cf,\n    UNICODE_GC_Cs,\n    UNICODE_GC_Co,\n    UNICODE_GC_LC,\n    UNICODE_GC_L,\n    UNICODE_GC_M,\n    UNICODE_GC_N,\n    UNICODE_GC_S,\n    UNICODE_GC_P,\n    UNICODE_GC_Z,\n    UNICODE_GC_C,\n    UNICODE_GC_COUNT,\n} UnicodeGCEnum;\n\nstatic const char unicode_gc_name_table[] =\n    \"Cn,Unassigned\"            \"\\0\"\n    \"Lu,Uppercase_Letter\"      \"\\0\"\n    \"Ll,Lowercase_Letter\"      \"\\0\"\n    \"Lt,Titlecase_Letter\"      \"\\0\"\n    \"Lm,Modifier_Letter\"       \"\\0\"\n    \"Lo,Other_Letter\"          \"\\0\"\n    \"Mn,Nonspacing_Mark\"       \"\\0\"\n    \"Mc,Spacing_Mark\"          \"\\0\"\n    \"Me,Enclosing_Mark\"        \"\\0\"\n    \"Nd,Decimal_Number,digit\"  \"\\0\"\n    \"Nl,Letter_Number\"         \"\\0\"\n    \"No,Other_Number\"          \"\\0\"\n    \"Sm,Math_Symbol\"           \"\\0\"\n    \"Sc,Currency_Symbol\"       \"\\0\"\n    \"Sk,Modifier_Symbol\"       \"\\0\"\n    \"So,Other_Symbol\"          \"\\0\"\n    \"Pc,Connector_Punctuation\" \"\\0\"\n    \"Pd,Dash_Punctuation\"      \"\\0\"\n    \"Ps,Open_Punctuation\"      \"\\0\"\n    \"Pe,Close_Punctuation\"     \"\\0\"\n    \"Pi,Initial_Punctuation\"   \"\\0\"\n    \"Pf,Final_Punctuation\"     \"\\0\"\n    \"Po,Other_Punctuation\"     \"\\0\"\n    \"Zs,Space_Separator\"       \"\\0\"\n    \"Zl,Line_Separator\"        \"\\0\"\n    \"Zp,Paragraph_Separator\"   \"\\0\"\n    \"Cc,Control,cntrl\"         \"\\0\"\n    \"Cf,Format\"                \"\\0\"\n    \"Cs,Surrogate\"             \"\\0\"\n    \"Co,Private_Use\"           \"\\0\"\n    \"LC,Cased_Letter\"          \"\\0\"\n    \"L,Letter\"                 \"\\0\"\n    \"M,Mark,Combining_Mark\"    \"\\0\"\n    \"N,Number\"                 \"\\0\"\n    \"S,Symbol\"                 \"\\0\"\n    \"P,Punctuation,punct\"      \"\\0\"\n    \"Z,Separator\"              \"\\0\"\n    \"C,Other\"                  \"\\0\"\n;\n\nstatic const uint8_t unicode_gc_table[3948] = {\n    0xfa, 0x18, 0x17, 0x56, 0x0d, 0x56, 0x12, 0x13,\n    0x16, 0x0c, 0x16, 0x11, 0x36, 0xe9, 0x02, 0x36,\n    0x4c, 0x36, 0xe1, 0x12, 0x12, 0x16, 0x13, 0x0e,\n    0x10, 0x0e, 0xe2, 0x12, 0x12, 0x0c, 0x13, 0x0c,\n    0xfa, 0x19, 0x17, 0x16, 0x6d, 0x0f, 0x16, 0x0e,\n    0x0f, 0x05, 0x14, 0x0c, 0x1b, 0x0f, 0x0e, 0x0f,\n    0x0c, 0x2b, 0x0e, 0x02, 0x36, 0x0e, 0x0b, 0x05,\n    0x15, 0x4b, 0x16, 0xe1, 0x0f, 0x0c, 0xc1, 0xe2,\n    0x10, 0x0c, 0xe2, 0x00, 0xff, 0x30, 0x02, 0xff,\n    0x08, 0x02, 0xff, 0x27, 0xbf, 0x22, 0x21, 0x02,\n    0x5f, 0x5f, 0x21, 0x22, 0x61, 0x02, 0x21, 0x02,\n    0x41, 0x42, 0x21, 0x02, 0x21, 0x02, 0x9f, 0x7f,\n    0x02, 0x5f, 0x5f, 0x21, 0x02, 0x5f, 0x3f, 0x02,\n    0x05, 0x3f, 0x22, 0x65, 0x01, 0x03, 0x02, 0x01,\n    0x03, 0x02, 0x01, 0x03, 0x02, 0xff, 0x08, 0x02,\n    0xff, 0x0a, 0x02, 0x01, 0x03, 0x02, 0x5f, 0x21,\n    0x02, 0xff, 0x32, 0xa2, 0x21, 0x02, 0x21, 0x22,\n    0x5f, 0x41, 0x02, 0xff, 0x00, 0xe2, 0x3c, 0x05,\n    0xe2, 0x13, 0xe4, 0x0a, 0x6e, 0xe4, 0x04, 0xee,\n    0x06, 0x84, 0xce, 0x04, 0x0e, 0x04, 0xee, 0x09,\n    0xe6, 0x68, 0x7f, 0x04, 0x0e, 0x3f, 0x20, 0x04,\n    0x42, 0x16, 0x01, 0x60, 0x2e, 0x01, 0x16, 0x41,\n    0x00, 0x01, 0x00, 0x21, 0x02, 0xe1, 0x09, 0x00,\n    0xe1, 0x01, 0xe2, 0x1b, 0x3f, 0x02, 0x41, 0x42,\n    0xff, 0x10, 0x62, 0x3f, 0x0c, 0x5f, 0x3f, 0x02,\n    0xe1, 0x2b, 0xe2, 0x28, 0xff, 0x1a, 0x0f, 0x86,\n    0x28, 0xff, 0x2f, 0xff, 0x06, 0x02, 0xff, 0x58,\n    0x00, 0xe1, 0x1e, 0x20, 0x04, 0xb6, 0xe2, 0x21,\n    0x16, 0x11, 0x20, 0x2f, 0x0d, 0x00, 0xe6, 0x25,\n    0x11, 0x06, 0x16, 0x26, 0x16, 0x26, 0x16, 0x06,\n    0xe0, 0x00, 0xe5, 0x13, 0x60, 0x65, 0x36, 0xe0,\n    0x03, 0xbb, 0x4c, 0x36, 0x0d, 0x36, 0x2f, 0xe6,\n    0x03, 0x16, 0x1b, 0x56, 0xe5, 0x18, 0x04, 0xe5,\n    0x02, 0xe6, 0x0d, 0xe9, 0x02, 0x76, 0x25, 0x06,\n    0xe5, 0x5b, 0x16, 0x05, 0xc6, 0x1b, 0x0f, 0xa6,\n    0x24, 0x26, 0x0f, 0x66, 0x25, 0xe9, 0x02, 0x45,\n    0x2f, 0x05, 0xf6, 0x06, 0x00, 0x1b, 0x05, 0x06,\n    0xe5, 0x16, 0xe6, 0x13, 0x20, 0xe5, 0x51, 0xe6,\n    0x03, 0x05, 0xe0, 0x06, 0xe9, 0x02, 0xe5, 0x19,\n    0xe6, 0x01, 0x24, 0x0f, 0x56, 0x04, 0x20, 0x06,\n    0x2d, 0xe5, 0x0e, 0x66, 0x04, 0xe6, 0x01, 0x04,\n    0x46, 0x04, 0x86, 0x20, 0xf6, 0x07, 0x00, 0xe5,\n    0x11, 0x46, 0x20, 0x16, 0x00, 0xe5, 0x03, 0x80,\n    0xe5, 0x10, 0x0e, 0xa5, 0x00, 0x3b, 0xa0, 0xe6,\n    0x00, 0xe5, 0x21, 0x04, 0xe6, 0x10, 0x1b, 0xe6,\n    0x18, 0x07, 0xe5, 0x2e, 0x06, 0x07, 0x06, 0x05,\n    0x47, 0xe6, 0x00, 0x67, 0x06, 0x27, 0x05, 0xc6,\n    0xe5, 0x02, 0x26, 0x36, 0xe9, 0x02, 0x16, 0x04,\n    0xe5, 0x07, 0x06, 0x27, 0x00, 0xe5, 0x00, 0x20,\n    0x25, 0x20, 0xe5, 0x0e, 0x00, 0xc5, 0x00, 0x05,\n    0x40, 0x65, 0x20, 0x06, 0x05, 0x47, 0x66, 0x20,\n    0x27, 0x20, 0x27, 0x06, 0x05, 0xe0, 0x00, 0x07,\n    0x60, 0x25, 0x00, 0x45, 0x26, 0x20, 0xe9, 0x02,\n    0x25, 0x2d, 0xab, 0x0f, 0x0d, 0x05, 0x16, 0x06,\n    0x20, 0x26, 0x07, 0x00, 0xa5, 0x60, 0x25, 0x20,\n    0xe5, 0x0e, 0x00, 0xc5, 0x00, 0x25, 0x00, 0x25,\n    0x00, 0x25, 0x20, 0x06, 0x00, 0x47, 0x26, 0x60,\n    0x26, 0x20, 0x46, 0x40, 0x06, 0xc0, 0x65, 0x00,\n    0x05, 0xc0, 0xe9, 0x02, 0x26, 0x45, 0x06, 0x16,\n    0xe0, 0x02, 0x26, 0x07, 0x00, 0xe5, 0x01, 0x00,\n    0x45, 0x00, 0xe5, 0x0e, 0x00, 0xc5, 0x00, 0x25,\n    0x00, 0x85, 0x20, 0x06, 0x05, 0x47, 0x86, 0x00,\n    0x26, 0x07, 0x00, 0x27, 0x06, 0x20, 0x05, 0xe0,\n    0x07, 0x25, 0x26, 0x20, 0xe9, 0x02, 0x16, 0x0d,\n    0xc0, 0x05, 0xa6, 0x00, 0x06, 0x27, 0x00, 0xe5,\n    0x00, 0x20, 0x25, 0x20, 0xe5, 0x0e, 0x00, 0xc5,\n    0x00, 0x25, 0x00, 0x85, 0x20, 0x06, 0x05, 0x07,\n    0x06, 0x07, 0x66, 0x20, 0x27, 0x20, 0x27, 0x06,\n    0xc0, 0x26, 0x07, 0x60, 0x25, 0x00, 0x45, 0x26,\n    0x20, 0xe9, 0x02, 0x0f, 0x05, 0xab, 0xe0, 0x02,\n    0x06, 0x05, 0x00, 0xa5, 0x40, 0x45, 0x00, 0x65,\n    0x40, 0x25, 0x00, 0x05, 0x00, 0x25, 0x40, 0x25,\n    0x40, 0x45, 0x40, 0xe5, 0x04, 0x60, 0x27, 0x06,\n    0x27, 0x40, 0x47, 0x00, 0x47, 0x06, 0x20, 0x05,\n    0xa0, 0x07, 0xe0, 0x06, 0xe9, 0x02, 0x4b, 0xaf,\n    0x0d, 0x0f, 0x80, 0x06, 0x47, 0x06, 0xe5, 0x00,\n    0x00, 0x45, 0x00, 0xe5, 0x0f, 0x00, 0xe5, 0x08,\n    0x20, 0x06, 0x05, 0x46, 0x67, 0x00, 0x46, 0x00,\n    0x66, 0xc0, 0x26, 0x00, 0x45, 0x20, 0x05, 0x20,\n    0x25, 0x26, 0x20, 0xe9, 0x02, 0xc0, 0x16, 0xcb,\n    0x0f, 0x05, 0x06, 0x27, 0x16, 0xe5, 0x00, 0x00,\n    0x45, 0x00, 0xe5, 0x0f, 0x00, 0xe5, 0x02, 0x00,\n    0x85, 0x20, 0x06, 0x05, 0x07, 0x06, 0x87, 0x00,\n    0x06, 0x27, 0x00, 0x27, 0x26, 0xc0, 0x27, 0xa0,\n    0x25, 0x00, 0x25, 0x26, 0x20, 0xe9, 0x02, 0x00,\n    0x25, 0x07, 0xe0, 0x04, 0x26, 0x27, 0xe5, 0x01,\n    0x00, 0x45, 0x00, 0xe5, 0x21, 0x26, 0x05, 0x47,\n    0x66, 0x00, 0x47, 0x00, 0x47, 0x06, 0x05, 0x0f,\n    0x60, 0x45, 0x07, 0xcb, 0x45, 0x26, 0x20, 0xe9,\n    0x02, 0xeb, 0x01, 0x0f, 0xa5, 0x00, 0x06, 0x27,\n    0x00, 0xe5, 0x0a, 0x40, 0xe5, 0x10, 0x00, 0xe5,\n    0x01, 0x00, 0x05, 0x20, 0xc5, 0x40, 0x06, 0x60,\n    0x47, 0x46, 0x00, 0x06, 0x00, 0xe7, 0x00, 0xa0,\n    0xe9, 0x02, 0x20, 0x27, 0x16, 0xe0, 0x04, 0xe5,\n    0x28, 0x06, 0x25, 0xc6, 0x60, 0x0d, 0xa5, 0x04,\n    0xe6, 0x00, 0x16, 0xe9, 0x02, 0x36, 0xe0, 0x1d,\n    0x25, 0x00, 0x05, 0x00, 0x85, 0x00, 0xe5, 0x10,\n    0x00, 0x05, 0x00, 0xe5, 0x02, 0x06, 0x25, 0xe6,\n    0x01, 0x05, 0x20, 0x85, 0x00, 0x04, 0x00, 0xc6,\n    0x00, 0xe9, 0x02, 0x20, 0x65, 0xe0, 0x18, 0x05,\n    0x4f, 0xf6, 0x07, 0x0f, 0x16, 0x4f, 0x26, 0xaf,\n    0xe9, 0x02, 0xeb, 0x02, 0x0f, 0x06, 0x0f, 0x06,\n    0x0f, 0x06, 0x12, 0x13, 0x12, 0x13, 0x27, 0xe5,\n    0x00, 0x00, 0xe5, 0x1c, 0x60, 0xe6, 0x06, 0x07,\n    0x86, 0x16, 0x26, 0x85, 0xe6, 0x03, 0x00, 0xe6,\n    0x1c, 0x00, 0xef, 0x00, 0x06, 0xaf, 0x00, 0x2f,\n    0x96, 0x6f, 0x36, 0xe0, 0x1d, 0xe5, 0x23, 0x27,\n    0x66, 0x07, 0xa6, 0x07, 0x26, 0x27, 0x26, 0x05,\n    0xe9, 0x02, 0xb6, 0xa5, 0x27, 0x26, 0x65, 0x46,\n    0x05, 0x47, 0x25, 0xc7, 0x45, 0x66, 0xe5, 0x05,\n    0x06, 0x27, 0x26, 0xa7, 0x06, 0x05, 0x07, 0xe9,\n    0x02, 0x47, 0x06, 0x2f, 0xe1, 0x1e, 0x00, 0x01,\n    0x80, 0x01, 0x20, 0xe2, 0x23, 0x16, 0x04, 0x42,\n    0xe5, 0x80, 0xc1, 0x00, 0x65, 0x20, 0xc5, 0x00,\n    0x05, 0x00, 0x65, 0x20, 0xe5, 0x21, 0x00, 0x65,\n    0x20, 0xe5, 0x19, 0x00, 0x65, 0x20, 0xc5, 0x00,\n    0x05, 0x00, 0x65, 0x20, 0xe5, 0x07, 0x00, 0xe5,\n    0x31, 0x00, 0x65, 0x20, 0xe5, 0x3b, 0x20, 0x46,\n    0xf6, 0x01, 0xeb, 0x0c, 0x40, 0xe5, 0x08, 0xef,\n    0x02, 0xa0, 0xe1, 0x4e, 0x20, 0xa2, 0x20, 0x11,\n    0xe5, 0x81, 0xe4, 0x0f, 0x16, 0xe5, 0x09, 0x17,\n    0xe5, 0x12, 0x12, 0x13, 0x40, 0xe5, 0x43, 0x56,\n    0x4a, 0xe5, 0x00, 0xc0, 0xe5, 0x0a, 0x46, 0x07,\n    0xe0, 0x01, 0xe5, 0x0b, 0x26, 0x07, 0x36, 0xe0,\n    0x01, 0xe5, 0x0a, 0x26, 0xe0, 0x04, 0xe5, 0x05,\n    0x00, 0x45, 0x00, 0x26, 0xe0, 0x04, 0xe5, 0x2c,\n    0x26, 0x07, 0xc6, 0xe7, 0x00, 0x06, 0x27, 0xe6,\n    0x03, 0x56, 0x04, 0x56, 0x0d, 0x05, 0x06, 0x20,\n    0xe9, 0x02, 0xa0, 0xeb, 0x02, 0xa0, 0xb6, 0x11,\n    0x76, 0x46, 0x1b, 0x06, 0xe9, 0x02, 0xa0, 0xe5,\n    0x1b, 0x04, 0xe5, 0x2d, 0xc0, 0x85, 0x26, 0xe5,\n    0x1a, 0x06, 0x05, 0x80, 0xe5, 0x3e, 0xe0, 0x02,\n    0xe5, 0x17, 0x00, 0x46, 0x67, 0x26, 0x47, 0x60,\n    0x27, 0x06, 0xa7, 0x46, 0x60, 0x0f, 0x40, 0x36,\n    0xe9, 0x02, 0xe5, 0x16, 0x20, 0x85, 0xe0, 0x03,\n    0xe5, 0x24, 0x60, 0xe5, 0x12, 0xa0, 0xe9, 0x02,\n    0x0b, 0x40, 0xef, 0x1a, 0xe5, 0x0f, 0x26, 0x27,\n    0x06, 0x20, 0x36, 0xe5, 0x2d, 0x07, 0x06, 0x07,\n    0xc6, 0x00, 0x06, 0x07, 0x06, 0x27, 0xe6, 0x00,\n    0xa7, 0xe6, 0x02, 0x20, 0x06, 0xe9, 0x02, 0xa0,\n    0xe9, 0x02, 0xa0, 0xd6, 0x04, 0xb6, 0x20, 0xe6,\n    0x06, 0x08, 0xe6, 0x08, 0xe0, 0x29, 0x66, 0x07,\n    0xe5, 0x27, 0x06, 0x07, 0x86, 0x07, 0x06, 0x87,\n    0x06, 0x27, 0xe5, 0x00, 0x40, 0xe9, 0x02, 0xd6,\n    0xef, 0x02, 0xe6, 0x01, 0xef, 0x01, 0x36, 0x00,\n    0x26, 0x07, 0xe5, 0x16, 0x07, 0x66, 0x27, 0x26,\n    0x07, 0x46, 0x25, 0xe9, 0x02, 0xe5, 0x24, 0x06,\n    0x07, 0x26, 0x47, 0x06, 0x07, 0x46, 0x27, 0xe0,\n    0x00, 0x76, 0xe5, 0x1c, 0xe7, 0x00, 0xe6, 0x00,\n    0x27, 0x26, 0x40, 0x96, 0xe9, 0x02, 0x40, 0x45,\n    0xe9, 0x02, 0xe5, 0x16, 0xa4, 0x36, 0xe2, 0x01,\n    0xc0, 0xe1, 0x23, 0x20, 0x41, 0xf6, 0x00, 0xe0,\n    0x00, 0x46, 0x16, 0xe6, 0x05, 0x07, 0xc6, 0x65,\n    0x06, 0xa5, 0x06, 0x25, 0x07, 0x26, 0x05, 0x80,\n    0xe2, 0x24, 0xe4, 0x37, 0xe2, 0x05, 0x04, 0xe2,\n    0x1a, 0xe4, 0x1d, 0xe6, 0x38, 0xff, 0x80, 0x0e,\n    0xe2, 0x00, 0xff, 0x5a, 0xe2, 0x00, 0xe1, 0x00,\n    0xa2, 0x20, 0xa1, 0x20, 0xe2, 0x00, 0xe1, 0x00,\n    0xe2, 0x00, 0xe1, 0x00, 0xa2, 0x20, 0xa1, 0x20,\n    0xe2, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,\n    0x00, 0x3f, 0xc2, 0xe1, 0x00, 0xe2, 0x06, 0x20,\n    0xe2, 0x00, 0xe3, 0x00, 0xe2, 0x00, 0xe3, 0x00,\n    0xe2, 0x00, 0xe3, 0x00, 0x82, 0x00, 0x22, 0x61,\n    0x03, 0x0e, 0x02, 0x4e, 0x42, 0x00, 0x22, 0x61,\n    0x03, 0x4e, 0x62, 0x20, 0x22, 0x61, 0x00, 0x4e,\n    0xe2, 0x00, 0x81, 0x4e, 0x20, 0x42, 0x00, 0x22,\n    0x61, 0x03, 0x2e, 0x00, 0xf7, 0x03, 0x9b, 0xb1,\n    0x36, 0x14, 0x15, 0x12, 0x34, 0x15, 0x12, 0x14,\n    0xf6, 0x00, 0x18, 0x19, 0x9b, 0x17, 0xf6, 0x01,\n    0x14, 0x15, 0x76, 0x30, 0x56, 0x0c, 0x12, 0x13,\n    0xf6, 0x03, 0x0c, 0x16, 0x10, 0xf6, 0x02, 0x17,\n    0x9b, 0x00, 0xfb, 0x02, 0x0b, 0x04, 0x20, 0xab,\n    0x4c, 0x12, 0x13, 0x04, 0xeb, 0x02, 0x4c, 0x12,\n    0x13, 0x00, 0xe4, 0x05, 0x40, 0xed, 0x19, 0xe0,\n    0x07, 0xe6, 0x05, 0x68, 0x06, 0x48, 0xe6, 0x04,\n    0xe0, 0x07, 0x2f, 0x01, 0x6f, 0x01, 0x2f, 0x02,\n    0x41, 0x22, 0x41, 0x02, 0x0f, 0x01, 0x2f, 0x0c,\n    0x81, 0xaf, 0x01, 0x0f, 0x01, 0x0f, 0x01, 0x0f,\n    0x61, 0x0f, 0x02, 0x61, 0x02, 0x65, 0x02, 0x2f,\n    0x22, 0x21, 0x8c, 0x3f, 0x42, 0x0f, 0x0c, 0x2f,\n    0x02, 0x0f, 0xeb, 0x08, 0xea, 0x1b, 0x3f, 0x6a,\n    0x0b, 0x2f, 0x60, 0x8c, 0x8f, 0x2c, 0x6f, 0x0c,\n    0x2f, 0x0c, 0x2f, 0x0c, 0xcf, 0x0c, 0xef, 0x17,\n    0x2c, 0x2f, 0x0c, 0x0f, 0x0c, 0xef, 0x17, 0xec,\n    0x80, 0x84, 0xef, 0x00, 0x12, 0x13, 0x12, 0x13,\n    0xef, 0x0c, 0x2c, 0xcf, 0x12, 0x13, 0xef, 0x49,\n    0x0c, 0xef, 0x16, 0xec, 0x11, 0xef, 0x20, 0xac,\n    0xef, 0x3d, 0xe0, 0x11, 0xef, 0x03, 0xe0, 0x0d,\n    0xeb, 0x34, 0xef, 0x46, 0xeb, 0x0e, 0xef, 0x80,\n    0x2f, 0x0c, 0xef, 0x01, 0x0c, 0xef, 0x2e, 0xec,\n    0x00, 0xef, 0x67, 0x0c, 0xef, 0x80, 0x70, 0x12,\n    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,\n    0x13, 0x12, 0x13, 0x12, 0x13, 0xeb, 0x16, 0xef,\n    0x24, 0x8c, 0x12, 0x13, 0xec, 0x17, 0x12, 0x13,\n    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,\n    0xec, 0x08, 0xef, 0x80, 0x78, 0xec, 0x7b, 0x12,\n    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,\n    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,\n    0x13, 0x12, 0x13, 0x12, 0x13, 0xec, 0x37, 0x12,\n    0x13, 0x12, 0x13, 0xec, 0x18, 0x12, 0x13, 0xec,\n    0x80, 0x7a, 0xef, 0x28, 0xec, 0x0d, 0x2f, 0xac,\n    0xef, 0x1f, 0x20, 0xef, 0x18, 0x00, 0xef, 0x61,\n    0xe1, 0x28, 0xe2, 0x28, 0x5f, 0x21, 0x22, 0xdf,\n    0x41, 0x02, 0x3f, 0x02, 0x3f, 0x82, 0x24, 0x41,\n    0x02, 0xff, 0x5a, 0x02, 0xaf, 0x7f, 0x46, 0x3f,\n    0x80, 0x76, 0x0b, 0x36, 0xe2, 0x1e, 0x00, 0x02,\n    0x80, 0x02, 0x20, 0xe5, 0x30, 0xc0, 0x04, 0x16,\n    0xe0, 0x06, 0x06, 0xe5, 0x0f, 0xe0, 0x01, 0xc5,\n    0x00, 0xc5, 0x00, 0xc5, 0x00, 0xc5, 0x00, 0xc5,\n    0x00, 0xc5, 0x00, 0xc5, 0x00, 0xc5, 0x00, 0xe6,\n    0x18, 0x36, 0x14, 0x15, 0x14, 0x15, 0x56, 0x14,\n    0x15, 0x16, 0x14, 0x15, 0xf6, 0x01, 0x11, 0x36,\n    0x11, 0x16, 0x14, 0x15, 0x36, 0x14, 0x15, 0x12,\n    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x96,\n    0x04, 0xf6, 0x02, 0x31, 0x76, 0x11, 0x16, 0x12,\n    0xf6, 0x05, 0x2f, 0x56, 0x12, 0x13, 0x12, 0x13,\n    0x12, 0x13, 0x12, 0x13, 0x11, 0xe0, 0x1a, 0xef,\n    0x12, 0x00, 0xef, 0x51, 0xe0, 0x04, 0xef, 0x80,\n    0x4e, 0xe0, 0x12, 0xef, 0x04, 0x60, 0x17, 0x56,\n    0x0f, 0x04, 0x05, 0x0a, 0x12, 0x13, 0x12, 0x13,\n    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x2f, 0x12,\n    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x11,\n    0x12, 0x33, 0x0f, 0xea, 0x01, 0x66, 0x27, 0x11,\n    0x84, 0x2f, 0x4a, 0x04, 0x05, 0x16, 0x2f, 0x00,\n    0xe5, 0x4e, 0x20, 0x26, 0x2e, 0x24, 0x05, 0x11,\n    0xe5, 0x52, 0x16, 0x44, 0x05, 0x80, 0xe5, 0x23,\n    0x00, 0xe5, 0x56, 0x00, 0x2f, 0x6b, 0xef, 0x02,\n    0xe5, 0x18, 0xef, 0x1c, 0xe0, 0x04, 0xe5, 0x08,\n    0xef, 0x17, 0x00, 0xeb, 0x02, 0xef, 0x16, 0xeb,\n    0x00, 0x0f, 0xeb, 0x07, 0xef, 0x18, 0xeb, 0x02,\n    0xef, 0x1f, 0xeb, 0x07, 0xef, 0x80, 0xb8, 0xe5,\n    0x99, 0x38, 0xef, 0x38, 0xe5, 0xc0, 0x11, 0x8d,\n    0x04, 0xe5, 0x83, 0xef, 0x40, 0xef, 0x2f, 0xe0,\n    0x01, 0xe5, 0x20, 0xa4, 0x36, 0xe5, 0x80, 0x84,\n    0x04, 0x56, 0xe5, 0x08, 0xe9, 0x02, 0x25, 0xe0,\n    0x0c, 0xff, 0x26, 0x05, 0x06, 0x48, 0x16, 0xe6,\n    0x02, 0x16, 0x04, 0xff, 0x14, 0x24, 0x26, 0xe5,\n    0x3e, 0xea, 0x02, 0x26, 0xb6, 0xe0, 0x00, 0xee,\n    0x0f, 0xe4, 0x01, 0x2e, 0xff, 0x06, 0x22, 0xff,\n    0x36, 0x04, 0xe2, 0x00, 0x9f, 0xff, 0x02, 0x04,\n    0x2e, 0x7f, 0x05, 0x7f, 0x22, 0xff, 0x0d, 0x61,\n    0x02, 0x81, 0x02, 0xff, 0x07, 0x41, 0x02, 0x3f,\n    0x80, 0x3f, 0x00, 0x02, 0x00, 0x02, 0x7f, 0xe0,\n    0x10, 0x44, 0x3f, 0x05, 0x24, 0x02, 0xc5, 0x06,\n    0x45, 0x06, 0x65, 0x06, 0xe5, 0x0f, 0x27, 0x26,\n    0x07, 0x6f, 0x06, 0x40, 0xab, 0x2f, 0x0d, 0x0f,\n    0xa0, 0xe5, 0x2c, 0x76, 0xe0, 0x00, 0x27, 0xe5,\n    0x2a, 0xe7, 0x08, 0x26, 0xe0, 0x00, 0x36, 0xe9,\n    0x02, 0xa0, 0xe6, 0x0a, 0xa5, 0x56, 0x05, 0x16,\n    0x25, 0x06, 0xe9, 0x02, 0xe5, 0x14, 0xe6, 0x00,\n    0x36, 0xe5, 0x0f, 0xe6, 0x03, 0x27, 0xe0, 0x03,\n    0x16, 0xe5, 0x15, 0x40, 0x46, 0x07, 0xe5, 0x27,\n    0x06, 0x27, 0x66, 0x27, 0x26, 0x47, 0xf6, 0x05,\n    0x00, 0x04, 0xe9, 0x02, 0x60, 0x36, 0x85, 0x06,\n    0x04, 0xe5, 0x01, 0xe9, 0x02, 0x85, 0x00, 0xe5,\n    0x21, 0xa6, 0x27, 0x26, 0x27, 0x26, 0xe0, 0x01,\n    0x45, 0x06, 0xe5, 0x00, 0x06, 0x07, 0x20, 0xe9,\n    0x02, 0x20, 0x76, 0xe5, 0x08, 0x04, 0xa5, 0x4f,\n    0x05, 0x07, 0x06, 0x07, 0xe5, 0x2a, 0x06, 0x05,\n    0x46, 0x25, 0x26, 0x85, 0x26, 0x05, 0x06, 0x05,\n    0xe0, 0x10, 0x25, 0x04, 0x36, 0xe5, 0x03, 0x07,\n    0x26, 0x27, 0x36, 0x05, 0x24, 0x07, 0x06, 0xe0,\n    0x02, 0xa5, 0x20, 0xa5, 0x20, 0xa5, 0xe0, 0x01,\n    0xc5, 0x00, 0xc5, 0x00, 0xe2, 0x23, 0x0e, 0x64,\n    0xe2, 0x01, 0x04, 0x2e, 0x60, 0xe2, 0x48, 0xe5,\n    0x1b, 0x27, 0x06, 0x27, 0x06, 0x27, 0x16, 0x07,\n    0x06, 0x20, 0xe9, 0x02, 0xa0, 0xe5, 0xab, 0x1c,\n    0xe0, 0x04, 0xe5, 0x0f, 0x60, 0xe5, 0x29, 0x60,\n    0xfc, 0x87, 0x78, 0xfd, 0x98, 0x78, 0xe5, 0x80,\n    0xe6, 0x20, 0xe5, 0x62, 0xe0, 0x1e, 0xc2, 0xe0,\n    0x04, 0x82, 0x80, 0x05, 0x06, 0xe5, 0x02, 0x0c,\n    0xe5, 0x05, 0x00, 0x85, 0x00, 0x05, 0x00, 0x25,\n    0x00, 0x25, 0x00, 0xe5, 0x64, 0xee, 0x09, 0xe0,\n    0x08, 0xe5, 0x80, 0xe3, 0x13, 0x12, 0xef, 0x08,\n    0xe5, 0x38, 0x20, 0xe5, 0x2e, 0xc0, 0x0f, 0xe0,\n    0x18, 0xe5, 0x04, 0x0d, 0x4f, 0xe6, 0x08, 0xd6,\n    0x12, 0x13, 0x16, 0xa0, 0xe6, 0x08, 0x16, 0x31,\n    0x30, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,\n    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,\n    0x13, 0x36, 0x12, 0x13, 0x76, 0x50, 0x56, 0x00,\n    0x76, 0x11, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,\n    0x56, 0x0c, 0x11, 0x4c, 0x00, 0x16, 0x0d, 0x36,\n    0x60, 0x85, 0x00, 0xe5, 0x7f, 0x20, 0x1b, 0x00,\n    0x56, 0x0d, 0x56, 0x12, 0x13, 0x16, 0x0c, 0x16,\n    0x11, 0x36, 0xe9, 0x02, 0x36, 0x4c, 0x36, 0xe1,\n    0x12, 0x12, 0x16, 0x13, 0x0e, 0x10, 0x0e, 0xe2,\n    0x12, 0x12, 0x0c, 0x13, 0x0c, 0x12, 0x13, 0x16,\n    0x12, 0x13, 0x36, 0xe5, 0x02, 0x04, 0xe5, 0x25,\n    0x24, 0xe5, 0x17, 0x40, 0xa5, 0x20, 0xa5, 0x20,\n    0xa5, 0x20, 0x45, 0x40, 0x2d, 0x0c, 0x0e, 0x0f,\n    0x2d, 0x00, 0x0f, 0x6c, 0x2f, 0xe0, 0x02, 0x5b,\n    0x2f, 0x20, 0xe5, 0x04, 0x00, 0xe5, 0x12, 0x00,\n    0xe5, 0x0b, 0x00, 0x25, 0x00, 0xe5, 0x07, 0x20,\n    0xe5, 0x06, 0xe0, 0x1a, 0xe5, 0x73, 0x80, 0x56,\n    0x60, 0xeb, 0x25, 0x40, 0xef, 0x01, 0xea, 0x2d,\n    0x6b, 0xef, 0x09, 0x2b, 0x4f, 0x00, 0xef, 0x05,\n    0x40, 0x0f, 0xe0, 0x27, 0xef, 0x25, 0x06, 0xe0,\n    0x7a, 0xe5, 0x15, 0x40, 0xe5, 0x29, 0xe0, 0x07,\n    0x06, 0xeb, 0x13, 0x60, 0xe5, 0x18, 0x6b, 0xe0,\n    0x01, 0xe5, 0x0c, 0x0a, 0xe5, 0x00, 0x0a, 0x80,\n    0xe5, 0x1e, 0x86, 0x80, 0xe5, 0x16, 0x00, 0x16,\n    0xe5, 0x1c, 0x60, 0xe5, 0x00, 0x16, 0x8a, 0xe0,\n    0x22, 0xe1, 0x20, 0xe2, 0x20, 0xe5, 0x46, 0x20,\n    0xe9, 0x02, 0xa0, 0xe1, 0x1c, 0x60, 0xe2, 0x1c,\n    0x60, 0xe5, 0x20, 0xe0, 0x00, 0xe5, 0x2c, 0xe0,\n    0x03, 0x16, 0xe1, 0x03, 0x00, 0xe1, 0x07, 0x00,\n    0xc1, 0x00, 0x21, 0x00, 0xe2, 0x03, 0x00, 0xe2,\n    0x07, 0x00, 0xc2, 0x00, 0x22, 0xe0, 0x3b, 0xe5,\n    0x80, 0xaf, 0xe0, 0x01, 0xe5, 0x0e, 0xe0, 0x02,\n    0xe5, 0x00, 0xe0, 0x10, 0xa4, 0x00, 0xe4, 0x22,\n    0x00, 0xe4, 0x01, 0xe0, 0x3d, 0xa5, 0x20, 0x05,\n    0x00, 0xe5, 0x24, 0x00, 0x25, 0x40, 0x05, 0x20,\n    0xe5, 0x0f, 0x00, 0x16, 0xeb, 0x00, 0xe5, 0x0f,\n    0x2f, 0xcb, 0xe5, 0x17, 0xe0, 0x00, 0xeb, 0x01,\n    0xe0, 0x28, 0xe5, 0x0b, 0x00, 0x25, 0x80, 0x8b,\n    0xe5, 0x0e, 0xab, 0x40, 0x16, 0xe5, 0x12, 0x80,\n    0x16, 0xe0, 0x38, 0xe5, 0x30, 0x60, 0x2b, 0x25,\n    0xeb, 0x08, 0x20, 0xeb, 0x26, 0x05, 0x46, 0x00,\n    0x26, 0x80, 0x66, 0x65, 0x00, 0x45, 0x00, 0xe5,\n    0x15, 0x20, 0x46, 0x60, 0x06, 0xeb, 0x01, 0xc0,\n    0xf6, 0x01, 0xc0, 0xe5, 0x15, 0x2b, 0x16, 0xe5,\n    0x15, 0x4b, 0xe0, 0x18, 0xe5, 0x00, 0x0f, 0xe5,\n    0x14, 0x26, 0x60, 0x8b, 0xd6, 0xe0, 0x01, 0xe5,\n    0x2e, 0x40, 0xd6, 0xe5, 0x0e, 0x20, 0xeb, 0x00,\n    0xe5, 0x0b, 0x80, 0xeb, 0x00, 0xe5, 0x0a, 0xc0,\n    0x76, 0xe0, 0x04, 0xcb, 0xe0, 0x48, 0xe5, 0x41,\n    0xe0, 0x2f, 0xe1, 0x2b, 0xe0, 0x05, 0xe2, 0x2b,\n    0xc0, 0xab, 0xe5, 0x1c, 0x66, 0xe0, 0x00, 0xe9,\n    0x02, 0xe0, 0x80, 0x9e, 0xeb, 0x17, 0x00, 0xe5,\n    0x22, 0x00, 0x26, 0x11, 0x20, 0x25, 0xe0, 0x43,\n    0x46, 0xe5, 0x15, 0xeb, 0x02, 0x05, 0xe0, 0x00,\n    0xe5, 0x0e, 0xe6, 0x03, 0x6b, 0x96, 0xe0, 0x0e,\n    0xe5, 0x0a, 0x66, 0x76, 0xe0, 0x1e, 0xe5, 0x0d,\n    0xcb, 0xe0, 0x0c, 0xe5, 0x0f, 0xe0, 0x01, 0x07,\n    0x06, 0x07, 0xe5, 0x2d, 0xe6, 0x07, 0xd6, 0x60,\n    0xeb, 0x0c, 0xe9, 0x02, 0x06, 0x25, 0x26, 0x05,\n    0xe0, 0x01, 0x46, 0x07, 0xe5, 0x25, 0x47, 0x66,\n    0x27, 0x26, 0x36, 0x1b, 0x76, 0x06, 0xe0, 0x02,\n    0x1b, 0x20, 0xe5, 0x11, 0xc0, 0xe9, 0x02, 0xa0,\n    0x46, 0xe5, 0x1c, 0x86, 0x07, 0xe6, 0x00, 0x00,\n    0xe9, 0x02, 0x76, 0x05, 0x27, 0x05, 0xe0, 0x00,\n    0xe5, 0x1b, 0x06, 0x36, 0x05, 0xe0, 0x01, 0x26,\n    0x07, 0xe5, 0x28, 0x47, 0xe6, 0x01, 0x27, 0x65,\n    0x76, 0x66, 0x16, 0x07, 0x06, 0xe9, 0x02, 0x05,\n    0x16, 0x05, 0x56, 0x00, 0xeb, 0x0c, 0xe0, 0x03,\n    0xe5, 0x0a, 0x00, 0xe5, 0x11, 0x47, 0x46, 0x27,\n    0x06, 0x07, 0x26, 0xb6, 0x06, 0x25, 0x06, 0xe0,\n    0x36, 0xc5, 0x00, 0x05, 0x00, 0x65, 0x00, 0xe5,\n    0x07, 0x00, 0xe5, 0x02, 0x16, 0xa0, 0xe5, 0x27,\n    0x06, 0x47, 0xe6, 0x00, 0x80, 0xe9, 0x02, 0xa0,\n    0x26, 0x27, 0x00, 0xe5, 0x00, 0x20, 0x25, 0x20,\n    0xe5, 0x0e, 0x00, 0xc5, 0x00, 0x25, 0x00, 0x85,\n    0x00, 0x26, 0x05, 0x27, 0x06, 0x67, 0x20, 0x27,\n    0x20, 0x47, 0x20, 0x05, 0xa0, 0x07, 0x80, 0x85,\n    0x27, 0x20, 0xc6, 0x40, 0x86, 0xe0, 0x80, 0x03,\n    0xe5, 0x2d, 0x47, 0xe6, 0x00, 0x27, 0x46, 0x07,\n    0x06, 0x65, 0x96, 0xe9, 0x02, 0x36, 0x00, 0x16,\n    0x06, 0x45, 0xe0, 0x16, 0xe5, 0x28, 0x47, 0xa6,\n    0x07, 0x06, 0x67, 0x26, 0x07, 0x26, 0x25, 0x16,\n    0x05, 0xe0, 0x00, 0xe9, 0x02, 0xe0, 0x80, 0x1e,\n    0xe5, 0x27, 0x47, 0x66, 0x20, 0x67, 0x26, 0x07,\n    0x26, 0xf6, 0x0f, 0x65, 0x26, 0xe0, 0x1a, 0xe5,\n    0x28, 0x47, 0xe6, 0x00, 0x27, 0x06, 0x07, 0x26,\n    0x56, 0x05, 0xe0, 0x03, 0xe9, 0x02, 0xa0, 0xf6,\n    0x05, 0xe0, 0x0b, 0xe5, 0x23, 0x06, 0x07, 0x06,\n    0x27, 0xa6, 0x07, 0x06, 0x05, 0x16, 0xa0, 0xe9,\n    0x02, 0xe0, 0x2e, 0xe5, 0x13, 0x20, 0x46, 0x27,\n    0x66, 0x07, 0x86, 0x60, 0xe9, 0x02, 0x2b, 0x56,\n    0x0f, 0xc5, 0xe0, 0x80, 0x31, 0xe5, 0x24, 0x47,\n    0xe6, 0x01, 0x07, 0x26, 0x16, 0xe0, 0x5c, 0xe1,\n    0x18, 0xe2, 0x18, 0xe9, 0x02, 0xeb, 0x01, 0xe0,\n    0x04, 0xe5, 0x00, 0x20, 0x05, 0x20, 0xe5, 0x00,\n    0x00, 0x25, 0x00, 0xe5, 0x10, 0xa7, 0x00, 0x27,\n    0x20, 0x26, 0x07, 0x06, 0x05, 0x07, 0x05, 0x07,\n    0x06, 0x56, 0xe0, 0x01, 0xe9, 0x02, 0xe0, 0x3e,\n    0xe5, 0x00, 0x20, 0xe5, 0x1f, 0x47, 0x66, 0x20,\n    0x26, 0x67, 0x06, 0x05, 0x16, 0x05, 0x07, 0xe0,\n    0x13, 0x05, 0xe6, 0x02, 0xe5, 0x20, 0xa6, 0x07,\n    0x05, 0x66, 0xf6, 0x00, 0x06, 0xe0, 0x00, 0x05,\n    0xa6, 0x27, 0x46, 0xe5, 0x26, 0xe6, 0x05, 0x07,\n    0x26, 0x56, 0x05, 0x96, 0xe0, 0x05, 0xe5, 0x41,\n    0xc0, 0xf6, 0x02, 0xe0, 0x80, 0x6e, 0xe5, 0x01,\n    0x00, 0xe5, 0x1d, 0x07, 0xc6, 0x00, 0xa6, 0x07,\n    0x06, 0x05, 0x96, 0xe0, 0x02, 0xe9, 0x02, 0xeb,\n    0x0b, 0x40, 0x36, 0xe5, 0x16, 0x20, 0xe6, 0x0e,\n    0x00, 0x07, 0xc6, 0x07, 0x26, 0x07, 0x26, 0xe0,\n    0x41, 0xc5, 0x00, 0x25, 0x00, 0xe5, 0x1e, 0xa6,\n    0x40, 0x06, 0x00, 0x26, 0x00, 0xc6, 0x05, 0x06,\n    0xe0, 0x00, 0xe9, 0x02, 0xa0, 0xa5, 0x00, 0x25,\n    0x00, 0xe5, 0x18, 0x87, 0x00, 0x26, 0x00, 0x27,\n    0x06, 0x07, 0x06, 0x05, 0xc0, 0xe9, 0x02, 0xe0,\n    0x80, 0xae, 0xe5, 0x0b, 0x26, 0x27, 0x36, 0xc0,\n    0x26, 0x05, 0x07, 0xe5, 0x05, 0x00, 0xe5, 0x1a,\n    0x27, 0x86, 0x40, 0x27, 0x06, 0x07, 0x06, 0xf6,\n    0x05, 0xe9, 0x02, 0xe0, 0x4e, 0x05, 0xe0, 0x07,\n    0xeb, 0x0d, 0xef, 0x00, 0x6d, 0xef, 0x09, 0xe0,\n    0x05, 0x16, 0xe5, 0x83, 0x12, 0xe0, 0x5e, 0xea,\n    0x67, 0x00, 0x96, 0xe0, 0x03, 0xe5, 0x80, 0x3c,\n    0xe0, 0x89, 0xc4, 0xe5, 0x59, 0x36, 0xe0, 0x05,\n    0xe5, 0x83, 0xa8, 0xfb, 0x08, 0x06, 0xa5, 0xe6,\n    0x07, 0xe0, 0x8f, 0x22, 0xe5, 0x81, 0xbf, 0xe0,\n    0xa1, 0x31, 0xe5, 0x81, 0xb1, 0xc0, 0xe5, 0x17,\n    0x00, 0xe9, 0x02, 0x60, 0x36, 0xe5, 0x47, 0x00,\n    0xe9, 0x02, 0xa0, 0xe5, 0x16, 0x20, 0x86, 0x16,\n    0xe0, 0x02, 0xe5, 0x28, 0xc6, 0x96, 0x6f, 0x64,\n    0x16, 0x0f, 0xe0, 0x02, 0xe9, 0x02, 0x00, 0xcb,\n    0x00, 0xe5, 0x0d, 0x80, 0xe5, 0x0b, 0xe0, 0x82,\n    0x28, 0xe1, 0x18, 0xe2, 0x18, 0xeb, 0x0f, 0x76,\n    0xe0, 0x5d, 0xe5, 0x43, 0x60, 0x06, 0x05, 0xe7,\n    0x2f, 0xc0, 0x66, 0xe4, 0x05, 0xe0, 0x38, 0x24,\n    0x16, 0x04, 0x06, 0xe0, 0x03, 0x27, 0xe0, 0x06,\n    0xe5, 0x97, 0x70, 0xe0, 0x00, 0xe5, 0x84, 0x4e,\n    0xe0, 0x22, 0xe5, 0x01, 0xe0, 0xa2, 0x5f, 0x64,\n    0x00, 0xc4, 0x00, 0x24, 0x00, 0xe5, 0x80, 0x9b,\n    0xe0, 0x07, 0x05, 0xe0, 0x15, 0x45, 0x20, 0x05,\n    0xe0, 0x06, 0x65, 0xe0, 0x00, 0xe5, 0x81, 0x04,\n    0xe0, 0x88, 0x7c, 0xe5, 0x63, 0x80, 0xe5, 0x05,\n    0x40, 0xe5, 0x01, 0xc0, 0xe5, 0x02, 0x20, 0x0f,\n    0x26, 0x16, 0x7b, 0xe0, 0x91, 0xd4, 0xe6, 0x26,\n    0x20, 0xe6, 0x0f, 0xe0, 0x01, 0xef, 0x6c, 0xe0,\n    0x34, 0xef, 0x80, 0x6e, 0xe0, 0x02, 0xef, 0x1f,\n    0x20, 0xef, 0x34, 0x27, 0x46, 0x4f, 0xa7, 0xfb,\n    0x00, 0xe6, 0x00, 0x2f, 0xc6, 0xef, 0x16, 0x66,\n    0xef, 0x35, 0xe0, 0x0d, 0xef, 0x3a, 0x46, 0x0f,\n    0xe0, 0x72, 0xeb, 0x0c, 0xe0, 0x04, 0xeb, 0x0c,\n    0xe0, 0x04, 0xef, 0x4f, 0xe0, 0x01, 0xeb, 0x11,\n    0xe0, 0x7f, 0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12,\n    0xc2, 0x00, 0xe2, 0x0a, 0xe1, 0x12, 0xe2, 0x12,\n    0x01, 0x00, 0x21, 0x20, 0x01, 0x20, 0x21, 0x20,\n    0x61, 0x00, 0xe1, 0x00, 0x62, 0x00, 0x02, 0x00,\n    0xc2, 0x00, 0xe2, 0x03, 0xe1, 0x12, 0xe2, 0x12,\n    0x21, 0x00, 0x61, 0x20, 0xe1, 0x00, 0x00, 0xc1,\n    0x00, 0xe2, 0x12, 0x21, 0x00, 0x61, 0x00, 0x81,\n    0x00, 0x01, 0x40, 0xc1, 0x00, 0xe2, 0x12, 0xe1,\n    0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1,\n    0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1,\n    0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x14, 0x20,\n    0xe1, 0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0xe1,\n    0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0xe1, 0x11,\n    0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0xe1, 0x11, 0x0c,\n    0xe2, 0x11, 0x0c, 0xa2, 0xe1, 0x11, 0x0c, 0xe2,\n    0x11, 0x0c, 0xa2, 0x3f, 0x20, 0xe9, 0x2a, 0xef,\n    0x81, 0x78, 0xe6, 0x2f, 0x6f, 0xe6, 0x2a, 0xef,\n    0x00, 0x06, 0xef, 0x06, 0x06, 0x2f, 0x96, 0xe0,\n    0x07, 0x86, 0x00, 0xe6, 0x07, 0xe0, 0x83, 0xc8,\n    0xe2, 0x02, 0x05, 0xe2, 0x0c, 0xa0, 0xa2, 0xe0,\n    0x80, 0x4d, 0xc6, 0x00, 0xe6, 0x09, 0x20, 0xc6,\n    0x00, 0x26, 0x00, 0x86, 0x80, 0xe4, 0x36, 0xe0,\n    0x19, 0x06, 0xe0, 0x68, 0xe5, 0x25, 0x40, 0xc6,\n    0xc4, 0x20, 0xe9, 0x02, 0x60, 0x05, 0x0f, 0xe0,\n    0x80, 0xb8, 0xe5, 0x16, 0x06, 0xe0, 0x09, 0xe5,\n    0x24, 0x66, 0xe9, 0x02, 0x80, 0x0d, 0xe0, 0x81,\n    0x48, 0xe5, 0x13, 0x04, 0x66, 0xe9, 0x02, 0xe0,\n    0x82, 0x5e, 0xc5, 0x00, 0x65, 0x00, 0x25, 0x00,\n    0xe5, 0x07, 0x00, 0xe5, 0x80, 0x3d, 0x20, 0xeb,\n    0x01, 0xc6, 0xe0, 0x21, 0xe1, 0x1a, 0xe2, 0x1a,\n    0xc6, 0x04, 0x60, 0xe9, 0x02, 0x60, 0x36, 0xe0,\n    0x82, 0x89, 0xeb, 0x33, 0x0f, 0x4b, 0x0d, 0x6b,\n    0xe0, 0x44, 0xeb, 0x25, 0x0f, 0xeb, 0x07, 0xe0,\n    0x80, 0x3a, 0x65, 0x00, 0xe5, 0x13, 0x00, 0x25,\n    0x00, 0x05, 0x20, 0x05, 0x00, 0xe5, 0x02, 0x00,\n    0x65, 0x00, 0x05, 0x00, 0x05, 0xa0, 0x05, 0x60,\n    0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x45, 0x00,\n    0x25, 0x00, 0x05, 0x20, 0x05, 0x00, 0x05, 0x00,\n    0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x25, 0x00,\n    0x05, 0x20, 0x65, 0x00, 0xc5, 0x00, 0x65, 0x00,\n    0x65, 0x00, 0x05, 0x00, 0xe5, 0x02, 0x00, 0xe5,\n    0x09, 0x80, 0x45, 0x00, 0x85, 0x00, 0xe5, 0x09,\n    0xe0, 0x2c, 0x2c, 0xe0, 0x80, 0x86, 0xef, 0x24,\n    0x60, 0xef, 0x5c, 0xe0, 0x04, 0xef, 0x07, 0x20,\n    0xef, 0x07, 0x00, 0xef, 0x07, 0x00, 0xef, 0x1d,\n    0xe0, 0x02, 0xeb, 0x05, 0xef, 0x80, 0x19, 0xe0,\n    0x30, 0xef, 0x15, 0xe0, 0x05, 0xef, 0x24, 0x60,\n    0xef, 0x01, 0xc0, 0x2f, 0xe0, 0x06, 0xaf, 0xe0,\n    0x80, 0x12, 0xef, 0x80, 0x73, 0x8e, 0xef, 0x82,\n    0x50, 0x60, 0xef, 0x09, 0x40, 0xef, 0x05, 0x40,\n    0xef, 0x6f, 0x60, 0xef, 0x57, 0xa0, 0xef, 0x04,\n    0x60, 0x0f, 0xe0, 0x07, 0xef, 0x04, 0x60, 0xef,\n    0x30, 0xe0, 0x00, 0xef, 0x02, 0xa0, 0xef, 0x20,\n    0xe0, 0x00, 0xef, 0x16, 0x20, 0x2f, 0xe0, 0x46,\n    0xef, 0x80, 0xcc, 0xe0, 0x04, 0xef, 0x06, 0x20,\n    0xef, 0x05, 0x40, 0xef, 0x01, 0xc0, 0xef, 0x26,\n    0x00, 0xcf, 0xe0, 0x00, 0xef, 0x06, 0x60, 0xef,\n    0x01, 0xc0, 0xef, 0x01, 0xc0, 0xef, 0x80, 0x0b,\n    0x00, 0xef, 0x2f, 0xe0, 0x1d, 0xe9, 0x02, 0xe0,\n    0x83, 0x7e, 0xe5, 0xc0, 0x66, 0x58, 0xe0, 0x18,\n    0xe5, 0x8f, 0xb2, 0xa0, 0xe5, 0x80, 0x56, 0x20,\n    0xe5, 0x95, 0xfa, 0xe0, 0x06, 0xe5, 0x9c, 0xa9,\n    0xe0, 0x8b, 0x97, 0xe5, 0x81, 0x96, 0xe0, 0x85,\n    0x5a, 0xe5, 0x92, 0xc3, 0x80, 0xe5, 0x8f, 0xd8,\n    0xe0, 0xca, 0x9b, 0xc9, 0x1b, 0xe0, 0x16, 0xfb,\n    0x58, 0xe0, 0x78, 0xe6, 0x80, 0x68, 0xe0, 0xc0,\n    0xbd, 0x88, 0xfd, 0xc0, 0xbf, 0x76, 0x20, 0xfd,\n    0xc0, 0xbf, 0x76, 0x20,\n};\n\ntypedef enum {\n    UNICODE_SCRIPT_Unknown,\n    UNICODE_SCRIPT_Adlam,\n    UNICODE_SCRIPT_Ahom,\n    UNICODE_SCRIPT_Anatolian_Hieroglyphs,\n    UNICODE_SCRIPT_Arabic,\n    UNICODE_SCRIPT_Armenian,\n    UNICODE_SCRIPT_Avestan,\n    UNICODE_SCRIPT_Balinese,\n    UNICODE_SCRIPT_Bamum,\n    UNICODE_SCRIPT_Bassa_Vah,\n    UNICODE_SCRIPT_Batak,\n    UNICODE_SCRIPT_Bengali,\n    UNICODE_SCRIPT_Bhaiksuki,\n    UNICODE_SCRIPT_Bopomofo,\n    UNICODE_SCRIPT_Brahmi,\n    UNICODE_SCRIPT_Braille,\n    UNICODE_SCRIPT_Buginese,\n    UNICODE_SCRIPT_Buhid,\n    UNICODE_SCRIPT_Canadian_Aboriginal,\n    UNICODE_SCRIPT_Carian,\n    UNICODE_SCRIPT_Caucasian_Albanian,\n    UNICODE_SCRIPT_Chakma,\n    UNICODE_SCRIPT_Cham,\n    UNICODE_SCRIPT_Cherokee,\n    UNICODE_SCRIPT_Chorasmian,\n    UNICODE_SCRIPT_Common,\n    UNICODE_SCRIPT_Coptic,\n    UNICODE_SCRIPT_Cuneiform,\n    UNICODE_SCRIPT_Cypriot,\n    UNICODE_SCRIPT_Cyrillic,\n    UNICODE_SCRIPT_Cypro_Minoan,\n    UNICODE_SCRIPT_Deseret,\n    UNICODE_SCRIPT_Devanagari,\n    UNICODE_SCRIPT_Dives_Akuru,\n    UNICODE_SCRIPT_Dogra,\n    UNICODE_SCRIPT_Duployan,\n    UNICODE_SCRIPT_Egyptian_Hieroglyphs,\n    UNICODE_SCRIPT_Elbasan,\n    UNICODE_SCRIPT_Elymaic,\n    UNICODE_SCRIPT_Ethiopic,\n    UNICODE_SCRIPT_Georgian,\n    UNICODE_SCRIPT_Glagolitic,\n    UNICODE_SCRIPT_Gothic,\n    UNICODE_SCRIPT_Grantha,\n    UNICODE_SCRIPT_Greek,\n    UNICODE_SCRIPT_Gujarati,\n    UNICODE_SCRIPT_Gunjala_Gondi,\n    UNICODE_SCRIPT_Gurmukhi,\n    UNICODE_SCRIPT_Han,\n    UNICODE_SCRIPT_Hangul,\n    UNICODE_SCRIPT_Hanifi_Rohingya,\n    UNICODE_SCRIPT_Hanunoo,\n    UNICODE_SCRIPT_Hatran,\n    UNICODE_SCRIPT_Hebrew,\n    UNICODE_SCRIPT_Hiragana,\n    UNICODE_SCRIPT_Imperial_Aramaic,\n    UNICODE_SCRIPT_Inherited,\n    UNICODE_SCRIPT_Inscriptional_Pahlavi,\n    UNICODE_SCRIPT_Inscriptional_Parthian,\n    UNICODE_SCRIPT_Javanese,\n    UNICODE_SCRIPT_Kaithi,\n    UNICODE_SCRIPT_Kannada,\n    UNICODE_SCRIPT_Katakana,\n    UNICODE_SCRIPT_Kawi,\n    UNICODE_SCRIPT_Kayah_Li,\n    UNICODE_SCRIPT_Kharoshthi,\n    UNICODE_SCRIPT_Khmer,\n    UNICODE_SCRIPT_Khojki,\n    UNICODE_SCRIPT_Khitan_Small_Script,\n    UNICODE_SCRIPT_Khudawadi,\n    UNICODE_SCRIPT_Lao,\n    UNICODE_SCRIPT_Latin,\n    UNICODE_SCRIPT_Lepcha,\n    UNICODE_SCRIPT_Limbu,\n    UNICODE_SCRIPT_Linear_A,\n    UNICODE_SCRIPT_Linear_B,\n    UNICODE_SCRIPT_Lisu,\n    UNICODE_SCRIPT_Lycian,\n    UNICODE_SCRIPT_Lydian,\n    UNICODE_SCRIPT_Makasar,\n    UNICODE_SCRIPT_Mahajani,\n    UNICODE_SCRIPT_Malayalam,\n    UNICODE_SCRIPT_Mandaic,\n    UNICODE_SCRIPT_Manichaean,\n    UNICODE_SCRIPT_Marchen,\n    UNICODE_SCRIPT_Masaram_Gondi,\n    UNICODE_SCRIPT_Medefaidrin,\n    UNICODE_SCRIPT_Meetei_Mayek,\n    UNICODE_SCRIPT_Mende_Kikakui,\n    UNICODE_SCRIPT_Meroitic_Cursive,\n    UNICODE_SCRIPT_Meroitic_Hieroglyphs,\n    UNICODE_SCRIPT_Miao,\n    UNICODE_SCRIPT_Modi,\n    UNICODE_SCRIPT_Mongolian,\n    UNICODE_SCRIPT_Mro,\n    UNICODE_SCRIPT_Multani,\n    UNICODE_SCRIPT_Myanmar,\n    UNICODE_SCRIPT_Nabataean,\n    UNICODE_SCRIPT_Nag_Mundari,\n    UNICODE_SCRIPT_Nandinagari,\n    UNICODE_SCRIPT_New_Tai_Lue,\n    UNICODE_SCRIPT_Newa,\n    UNICODE_SCRIPT_Nko,\n    UNICODE_SCRIPT_Nushu,\n    UNICODE_SCRIPT_Nyiakeng_Puachue_Hmong,\n    UNICODE_SCRIPT_Ogham,\n    UNICODE_SCRIPT_Ol_Chiki,\n    UNICODE_SCRIPT_Old_Hungarian,\n    UNICODE_SCRIPT_Old_Italic,\n    UNICODE_SCRIPT_Old_North_Arabian,\n    UNICODE_SCRIPT_Old_Permic,\n    UNICODE_SCRIPT_Old_Persian,\n    UNICODE_SCRIPT_Old_Sogdian,\n    UNICODE_SCRIPT_Old_South_Arabian,\n    UNICODE_SCRIPT_Old_Turkic,\n    UNICODE_SCRIPT_Old_Uyghur,\n    UNICODE_SCRIPT_Oriya,\n    UNICODE_SCRIPT_Osage,\n    UNICODE_SCRIPT_Osmanya,\n    UNICODE_SCRIPT_Pahawh_Hmong,\n    UNICODE_SCRIPT_Palmyrene,\n    UNICODE_SCRIPT_Pau_Cin_Hau,\n    UNICODE_SCRIPT_Phags_Pa,\n    UNICODE_SCRIPT_Phoenician,\n    UNICODE_SCRIPT_Psalter_Pahlavi,\n    UNICODE_SCRIPT_Rejang,\n    UNICODE_SCRIPT_Runic,\n    UNICODE_SCRIPT_Samaritan,\n    UNICODE_SCRIPT_Saurashtra,\n    UNICODE_SCRIPT_Sharada,\n    UNICODE_SCRIPT_Shavian,\n    UNICODE_SCRIPT_Siddham,\n    UNICODE_SCRIPT_SignWriting,\n    UNICODE_SCRIPT_Sinhala,\n    UNICODE_SCRIPT_Sogdian,\n    UNICODE_SCRIPT_Sora_Sompeng,\n    UNICODE_SCRIPT_Soyombo,\n    UNICODE_SCRIPT_Sundanese,\n    UNICODE_SCRIPT_Syloti_Nagri,\n    UNICODE_SCRIPT_Syriac,\n    UNICODE_SCRIPT_Tagalog,\n    UNICODE_SCRIPT_Tagbanwa,\n    UNICODE_SCRIPT_Tai_Le,\n    UNICODE_SCRIPT_Tai_Tham,\n    UNICODE_SCRIPT_Tai_Viet,\n    UNICODE_SCRIPT_Takri,\n    UNICODE_SCRIPT_Tamil,\n    UNICODE_SCRIPT_Tangut,\n    UNICODE_SCRIPT_Telugu,\n    UNICODE_SCRIPT_Thaana,\n    UNICODE_SCRIPT_Thai,\n    UNICODE_SCRIPT_Tibetan,\n    UNICODE_SCRIPT_Tifinagh,\n    UNICODE_SCRIPT_Tirhuta,\n    UNICODE_SCRIPT_Tangsa,\n    UNICODE_SCRIPT_Toto,\n    UNICODE_SCRIPT_Ugaritic,\n    UNICODE_SCRIPT_Vai,\n    UNICODE_SCRIPT_Vithkuqi,\n    UNICODE_SCRIPT_Wancho,\n    UNICODE_SCRIPT_Warang_Citi,\n    UNICODE_SCRIPT_Yezidi,\n    UNICODE_SCRIPT_Yi,\n    UNICODE_SCRIPT_Zanabazar_Square,\n    UNICODE_SCRIPT_COUNT,\n} UnicodeScriptEnum;\n\nstatic const char unicode_script_name_table[] =\n    \"Adlam,Adlm\"                  \"\\0\"\n    \"Ahom,Ahom\"                   \"\\0\"\n    \"Anatolian_Hieroglyphs,Hluw\"  \"\\0\"\n    \"Arabic,Arab\"                 \"\\0\"\n    \"Armenian,Armn\"               \"\\0\"\n    \"Avestan,Avst\"                \"\\0\"\n    \"Balinese,Bali\"               \"\\0\"\n    \"Bamum,Bamu\"                  \"\\0\"\n    \"Bassa_Vah,Bass\"              \"\\0\"\n    \"Batak,Batk\"                  \"\\0\"\n    \"Bengali,Beng\"                \"\\0\"\n    \"Bhaiksuki,Bhks\"              \"\\0\"\n    \"Bopomofo,Bopo\"               \"\\0\"\n    \"Brahmi,Brah\"                 \"\\0\"\n    \"Braille,Brai\"                \"\\0\"\n    \"Buginese,Bugi\"               \"\\0\"\n    \"Buhid,Buhd\"                  \"\\0\"\n    \"Canadian_Aboriginal,Cans\"    \"\\0\"\n    \"Carian,Cari\"                 \"\\0\"\n    \"Caucasian_Albanian,Aghb\"     \"\\0\"\n    \"Chakma,Cakm\"                 \"\\0\"\n    \"Cham,Cham\"                   \"\\0\"\n    \"Cherokee,Cher\"               \"\\0\"\n    \"Chorasmian,Chrs\"             \"\\0\"\n    \"Common,Zyyy\"                 \"\\0\"\n    \"Coptic,Copt,Qaac\"            \"\\0\"\n    \"Cuneiform,Xsux\"              \"\\0\"\n    \"Cypriot,Cprt\"                \"\\0\"\n    \"Cyrillic,Cyrl\"               \"\\0\"\n    \"Cypro_Minoan,Cpmn\"           \"\\0\"\n    \"Deseret,Dsrt\"                \"\\0\"\n    \"Devanagari,Deva\"             \"\\0\"\n    \"Dives_Akuru,Diak\"            \"\\0\"\n    \"Dogra,Dogr\"                  \"\\0\"\n    \"Duployan,Dupl\"               \"\\0\"\n    \"Egyptian_Hieroglyphs,Egyp\"   \"\\0\"\n    \"Elbasan,Elba\"                \"\\0\"\n    \"Elymaic,Elym\"                \"\\0\"\n    \"Ethiopic,Ethi\"               \"\\0\"\n    \"Georgian,Geor\"               \"\\0\"\n    \"Glagolitic,Glag\"             \"\\0\"\n    \"Gothic,Goth\"                 \"\\0\"\n    \"Grantha,Gran\"                \"\\0\"\n    \"Greek,Grek\"                  \"\\0\"\n    \"Gujarati,Gujr\"               \"\\0\"\n    \"Gunjala_Gondi,Gong\"          \"\\0\"\n    \"Gurmukhi,Guru\"               \"\\0\"\n    \"Han,Hani\"                    \"\\0\"\n    \"Hangul,Hang\"                 \"\\0\"\n    \"Hanifi_Rohingya,Rohg\"        \"\\0\"\n    \"Hanunoo,Hano\"                \"\\0\"\n    \"Hatran,Hatr\"                 \"\\0\"\n    \"Hebrew,Hebr\"                 \"\\0\"\n    \"Hiragana,Hira\"               \"\\0\"\n    \"Imperial_Aramaic,Armi\"       \"\\0\"\n    \"Inherited,Zinh,Qaai\"         \"\\0\"\n    \"Inscriptional_Pahlavi,Phli\"  \"\\0\"\n    \"Inscriptional_Parthian,Prti\" \"\\0\"\n    \"Javanese,Java\"               \"\\0\"\n    \"Kaithi,Kthi\"                 \"\\0\"\n    \"Kannada,Knda\"                \"\\0\"\n    \"Katakana,Kana\"               \"\\0\"\n    \"Kawi,Kawi\"                   \"\\0\"\n    \"Kayah_Li,Kali\"               \"\\0\"\n    \"Kharoshthi,Khar\"             \"\\0\"\n    \"Khmer,Khmr\"                  \"\\0\"\n    \"Khojki,Khoj\"                 \"\\0\"\n    \"Khitan_Small_Script,Kits\"    \"\\0\"\n    \"Khudawadi,Sind\"              \"\\0\"\n    \"Lao,Laoo\"                    \"\\0\"\n    \"Latin,Latn\"                  \"\\0\"\n    \"Lepcha,Lepc\"                 \"\\0\"\n    \"Limbu,Limb\"                  \"\\0\"\n    \"Linear_A,Lina\"               \"\\0\"\n    \"Linear_B,Linb\"               \"\\0\"\n    \"Lisu,Lisu\"                   \"\\0\"\n    \"Lycian,Lyci\"                 \"\\0\"\n    \"Lydian,Lydi\"                 \"\\0\"\n    \"Makasar,Maka\"                \"\\0\"\n    \"Mahajani,Mahj\"               \"\\0\"\n    \"Malayalam,Mlym\"              \"\\0\"\n    \"Mandaic,Mand\"                \"\\0\"\n    \"Manichaean,Mani\"             \"\\0\"\n    \"Marchen,Marc\"                \"\\0\"\n    \"Masaram_Gondi,Gonm\"          \"\\0\"\n    \"Medefaidrin,Medf\"            \"\\0\"\n    \"Meetei_Mayek,Mtei\"           \"\\0\"\n    \"Mende_Kikakui,Mend\"          \"\\0\"\n    \"Meroitic_Cursive,Merc\"       \"\\0\"\n    \"Meroitic_Hieroglyphs,Mero\"   \"\\0\"\n    \"Miao,Plrd\"                   \"\\0\"\n    \"Modi,Modi\"                   \"\\0\"\n    \"Mongolian,Mong\"              \"\\0\"\n    \"Mro,Mroo\"                    \"\\0\"\n    \"Multani,Mult\"                \"\\0\"\n    \"Myanmar,Mymr\"                \"\\0\"\n    \"Nabataean,Nbat\"              \"\\0\"\n    \"Nag_Mundari,Nagm\"            \"\\0\"\n    \"Nandinagari,Nand\"            \"\\0\"\n    \"New_Tai_Lue,Talu\"            \"\\0\"\n    \"Newa,Newa\"                   \"\\0\"\n    \"Nko,Nkoo\"                    \"\\0\"\n    \"Nushu,Nshu\"                  \"\\0\"\n    \"Nyiakeng_Puachue_Hmong,Hmnp\" \"\\0\"\n    \"Ogham,Ogam\"                  \"\\0\"\n    \"Ol_Chiki,Olck\"               \"\\0\"\n    \"Old_Hungarian,Hung\"          \"\\0\"\n    \"Old_Italic,Ital\"             \"\\0\"\n    \"Old_North_Arabian,Narb\"      \"\\0\"\n    \"Old_Permic,Perm\"             \"\\0\"\n    \"Old_Persian,Xpeo\"            \"\\0\"\n    \"Old_Sogdian,Sogo\"            \"\\0\"\n    \"Old_South_Arabian,Sarb\"      \"\\0\"\n    \"Old_Turkic,Orkh\"             \"\\0\"\n    \"Old_Uyghur,Ougr\"             \"\\0\"\n    \"Oriya,Orya\"                  \"\\0\"\n    \"Osage,Osge\"                  \"\\0\"\n    \"Osmanya,Osma\"                \"\\0\"\n    \"Pahawh_Hmong,Hmng\"           \"\\0\"\n    \"Palmyrene,Palm\"              \"\\0\"\n    \"Pau_Cin_Hau,Pauc\"            \"\\0\"\n    \"Phags_Pa,Phag\"               \"\\0\"\n    \"Phoenician,Phnx\"             \"\\0\"\n    \"Psalter_Pahlavi,Phlp\"        \"\\0\"\n    \"Rejang,Rjng\"                 \"\\0\"\n    \"Runic,Runr\"                  \"\\0\"\n    \"Samaritan,Samr\"              \"\\0\"\n    \"Saurashtra,Saur\"             \"\\0\"\n    \"Sharada,Shrd\"                \"\\0\"\n    \"Shavian,Shaw\"                \"\\0\"\n    \"Siddham,Sidd\"                \"\\0\"\n    \"SignWriting,Sgnw\"            \"\\0\"\n    \"Sinhala,Sinh\"                \"\\0\"\n    \"Sogdian,Sogd\"                \"\\0\"\n    \"Sora_Sompeng,Sora\"           \"\\0\"\n    \"Soyombo,Soyo\"                \"\\0\"\n    \"Sundanese,Sund\"              \"\\0\"\n    \"Syloti_Nagri,Sylo\"           \"\\0\"\n    \"Syriac,Syrc\"                 \"\\0\"\n    \"Tagalog,Tglg\"                \"\\0\"\n    \"Tagbanwa,Tagb\"               \"\\0\"\n    \"Tai_Le,Tale\"                 \"\\0\"\n    \"Tai_Tham,Lana\"               \"\\0\"\n    \"Tai_Viet,Tavt\"               \"\\0\"\n    \"Takri,Takr\"                  \"\\0\"\n    \"Tamil,Taml\"                  \"\\0\"\n    \"Tangut,Tang\"                 \"\\0\"\n    \"Telugu,Telu\"                 \"\\0\"\n    \"Thaana,Thaa\"                 \"\\0\"\n    \"Thai,Thai\"                   \"\\0\"\n    \"Tibetan,Tibt\"                \"\\0\"\n    \"Tifinagh,Tfng\"               \"\\0\"\n    \"Tirhuta,Tirh\"                \"\\0\"\n    \"Tangsa,Tnsa\"                 \"\\0\"\n    \"Toto,Toto\"                   \"\\0\"\n    \"Ugaritic,Ugar\"               \"\\0\"\n    \"Vai,Vaii\"                    \"\\0\"\n    \"Vithkuqi,Vith\"               \"\\0\"\n    \"Wancho,Wcho\"                 \"\\0\"\n    \"Warang_Citi,Wara\"            \"\\0\"\n    \"Yezidi,Yezi\"                 \"\\0\"\n    \"Yi,Yiii\"                     \"\\0\"\n    \"Zanabazar_Square,Zanb\"       \"\\0\"\n;\n\nstatic const uint8_t unicode_script_table[2720] = {\n    0xc0, 0x19, 0x99, 0x47, 0x85, 0x19, 0x99, 0x47,\n    0xae, 0x19, 0x80, 0x47, 0x8e, 0x19, 0x80, 0x47,\n    0x84, 0x19, 0x96, 0x47, 0x80, 0x19, 0x9e, 0x47,\n    0x80, 0x19, 0xe1, 0x60, 0x47, 0xa6, 0x19, 0x84,\n    0x47, 0x84, 0x19, 0x81, 0x0d, 0x93, 0x19, 0xe0,\n    0x0f, 0x38, 0x83, 0x2c, 0x80, 0x19, 0x82, 0x2c,\n    0x01, 0x83, 0x2c, 0x80, 0x19, 0x80, 0x2c, 0x03,\n    0x80, 0x2c, 0x80, 0x19, 0x80, 0x2c, 0x80, 0x19,\n    0x82, 0x2c, 0x00, 0x80, 0x2c, 0x00, 0x93, 0x2c,\n    0x00, 0xbe, 0x2c, 0x8d, 0x1a, 0x8f, 0x2c, 0xe0,\n    0x24, 0x1d, 0x81, 0x38, 0xe0, 0x48, 0x1d, 0x00,\n    0xa5, 0x05, 0x01, 0xb1, 0x05, 0x01, 0x82, 0x05,\n    0x00, 0xb6, 0x35, 0x07, 0x9a, 0x35, 0x03, 0x85,\n    0x35, 0x0a, 0x84, 0x04, 0x80, 0x19, 0x85, 0x04,\n    0x80, 0x19, 0x8d, 0x04, 0x80, 0x19, 0x82, 0x04,\n    0x80, 0x19, 0x9f, 0x04, 0x80, 0x19, 0x89, 0x04,\n    0x8a, 0x38, 0x99, 0x04, 0x80, 0x38, 0xe0, 0x0b,\n    0x04, 0x80, 0x19, 0xa1, 0x04, 0x8d, 0x8b, 0x00,\n    0xbb, 0x8b, 0x01, 0x82, 0x8b, 0xaf, 0x04, 0xb1,\n    0x95, 0x0d, 0xba, 0x66, 0x01, 0x82, 0x66, 0xad,\n    0x7f, 0x01, 0x8e, 0x7f, 0x00, 0x9b, 0x52, 0x01,\n    0x80, 0x52, 0x00, 0x8a, 0x8b, 0x04, 0x9e, 0x04,\n    0x00, 0x81, 0x04, 0x05, 0xc9, 0x04, 0x80, 0x19,\n    0x9c, 0x04, 0xd0, 0x20, 0x83, 0x38, 0x8e, 0x20,\n    0x81, 0x19, 0x99, 0x20, 0x83, 0x0b, 0x00, 0x87,\n    0x0b, 0x01, 0x81, 0x0b, 0x01, 0x95, 0x0b, 0x00,\n    0x86, 0x0b, 0x00, 0x80, 0x0b, 0x02, 0x83, 0x0b,\n    0x01, 0x88, 0x0b, 0x01, 0x81, 0x0b, 0x01, 0x83,\n    0x0b, 0x07, 0x80, 0x0b, 0x03, 0x81, 0x0b, 0x00,\n    0x84, 0x0b, 0x01, 0x98, 0x0b, 0x01, 0x82, 0x2f,\n    0x00, 0x85, 0x2f, 0x03, 0x81, 0x2f, 0x01, 0x95,\n    0x2f, 0x00, 0x86, 0x2f, 0x00, 0x81, 0x2f, 0x00,\n    0x81, 0x2f, 0x00, 0x81, 0x2f, 0x01, 0x80, 0x2f,\n    0x00, 0x84, 0x2f, 0x03, 0x81, 0x2f, 0x01, 0x82,\n    0x2f, 0x02, 0x80, 0x2f, 0x06, 0x83, 0x2f, 0x00,\n    0x80, 0x2f, 0x06, 0x90, 0x2f, 0x09, 0x82, 0x2d,\n    0x00, 0x88, 0x2d, 0x00, 0x82, 0x2d, 0x00, 0x95,\n    0x2d, 0x00, 0x86, 0x2d, 0x00, 0x81, 0x2d, 0x00,\n    0x84, 0x2d, 0x01, 0x89, 0x2d, 0x00, 0x82, 0x2d,\n    0x00, 0x82, 0x2d, 0x01, 0x80, 0x2d, 0x0e, 0x83,\n    0x2d, 0x01, 0x8b, 0x2d, 0x06, 0x86, 0x2d, 0x00,\n    0x82, 0x74, 0x00, 0x87, 0x74, 0x01, 0x81, 0x74,\n    0x01, 0x95, 0x74, 0x00, 0x86, 0x74, 0x00, 0x81,\n    0x74, 0x00, 0x84, 0x74, 0x01, 0x88, 0x74, 0x01,\n    0x81, 0x74, 0x01, 0x82, 0x74, 0x06, 0x82, 0x74,\n    0x03, 0x81, 0x74, 0x00, 0x84, 0x74, 0x01, 0x91,\n    0x74, 0x09, 0x81, 0x92, 0x00, 0x85, 0x92, 0x02,\n    0x82, 0x92, 0x00, 0x83, 0x92, 0x02, 0x81, 0x92,\n    0x00, 0x80, 0x92, 0x00, 0x81, 0x92, 0x02, 0x81,\n    0x92, 0x02, 0x82, 0x92, 0x02, 0x8b, 0x92, 0x03,\n    0x84, 0x92, 0x02, 0x82, 0x92, 0x00, 0x83, 0x92,\n    0x01, 0x80, 0x92, 0x05, 0x80, 0x92, 0x0d, 0x94,\n    0x92, 0x04, 0x8c, 0x94, 0x00, 0x82, 0x94, 0x00,\n    0x96, 0x94, 0x00, 0x8f, 0x94, 0x01, 0x88, 0x94,\n    0x00, 0x82, 0x94, 0x00, 0x83, 0x94, 0x06, 0x81,\n    0x94, 0x00, 0x82, 0x94, 0x01, 0x80, 0x94, 0x01,\n    0x83, 0x94, 0x01, 0x89, 0x94, 0x06, 0x88, 0x94,\n    0x8c, 0x3d, 0x00, 0x82, 0x3d, 0x00, 0x96, 0x3d,\n    0x00, 0x89, 0x3d, 0x00, 0x84, 0x3d, 0x01, 0x88,\n    0x3d, 0x00, 0x82, 0x3d, 0x00, 0x83, 0x3d, 0x06,\n    0x81, 0x3d, 0x05, 0x81, 0x3d, 0x00, 0x83, 0x3d,\n    0x01, 0x89, 0x3d, 0x00, 0x82, 0x3d, 0x0b, 0x8c,\n    0x51, 0x00, 0x82, 0x51, 0x00, 0xb2, 0x51, 0x00,\n    0x82, 0x51, 0x00, 0x85, 0x51, 0x03, 0x8f, 0x51,\n    0x01, 0x99, 0x51, 0x00, 0x82, 0x85, 0x00, 0x91,\n    0x85, 0x02, 0x97, 0x85, 0x00, 0x88, 0x85, 0x00,\n    0x80, 0x85, 0x01, 0x86, 0x85, 0x02, 0x80, 0x85,\n    0x03, 0x85, 0x85, 0x00, 0x80, 0x85, 0x00, 0x87,\n    0x85, 0x05, 0x89, 0x85, 0x01, 0x82, 0x85, 0x0b,\n    0xb9, 0x96, 0x03, 0x80, 0x19, 0x9b, 0x96, 0x24,\n    0x81, 0x46, 0x00, 0x80, 0x46, 0x00, 0x84, 0x46,\n    0x00, 0x97, 0x46, 0x00, 0x80, 0x46, 0x00, 0x96,\n    0x46, 0x01, 0x84, 0x46, 0x00, 0x80, 0x46, 0x00,\n    0x86, 0x46, 0x00, 0x89, 0x46, 0x01, 0x83, 0x46,\n    0x1f, 0xc7, 0x97, 0x00, 0xa3, 0x97, 0x03, 0xa6,\n    0x97, 0x00, 0xa3, 0x97, 0x00, 0x8e, 0x97, 0x00,\n    0x86, 0x97, 0x83, 0x19, 0x81, 0x97, 0x24, 0xe0,\n    0x3f, 0x60, 0xa5, 0x28, 0x00, 0x80, 0x28, 0x04,\n    0x80, 0x28, 0x01, 0xaa, 0x28, 0x80, 0x19, 0x83,\n    0x28, 0xe0, 0x9f, 0x31, 0xc8, 0x27, 0x00, 0x83,\n    0x27, 0x01, 0x86, 0x27, 0x00, 0x80, 0x27, 0x00,\n    0x83, 0x27, 0x01, 0xa8, 0x27, 0x00, 0x83, 0x27,\n    0x01, 0xa0, 0x27, 0x00, 0x83, 0x27, 0x01, 0x86,\n    0x27, 0x00, 0x80, 0x27, 0x00, 0x83, 0x27, 0x01,\n    0x8e, 0x27, 0x00, 0xb8, 0x27, 0x00, 0x83, 0x27,\n    0x01, 0xc2, 0x27, 0x01, 0x9f, 0x27, 0x02, 0x99,\n    0x27, 0x05, 0xd5, 0x17, 0x01, 0x85, 0x17, 0x01,\n    0xe2, 0x1f, 0x12, 0x9c, 0x69, 0x02, 0xca, 0x7e,\n    0x82, 0x19, 0x8a, 0x7e, 0x06, 0x95, 0x8c, 0x08,\n    0x80, 0x8c, 0x94, 0x33, 0x81, 0x19, 0x08, 0x93,\n    0x11, 0x0b, 0x8c, 0x8d, 0x00, 0x82, 0x8d, 0x00,\n    0x81, 0x8d, 0x0b, 0xdd, 0x42, 0x01, 0x89, 0x42,\n    0x05, 0x89, 0x42, 0x05, 0x81, 0x5d, 0x81, 0x19,\n    0x80, 0x5d, 0x80, 0x19, 0x93, 0x5d, 0x05, 0xd8,\n    0x5d, 0x06, 0xaa, 0x5d, 0x04, 0xc5, 0x12, 0x09,\n    0x9e, 0x49, 0x00, 0x8b, 0x49, 0x03, 0x8b, 0x49,\n    0x03, 0x80, 0x49, 0x02, 0x8b, 0x49, 0x9d, 0x8e,\n    0x01, 0x84, 0x8e, 0x0a, 0xab, 0x64, 0x03, 0x99,\n    0x64, 0x05, 0x8a, 0x64, 0x02, 0x81, 0x64, 0x9f,\n    0x42, 0x9b, 0x10, 0x01, 0x81, 0x10, 0xbe, 0x8f,\n    0x00, 0x9c, 0x8f, 0x01, 0x8a, 0x8f, 0x05, 0x89,\n    0x8f, 0x05, 0x8d, 0x8f, 0x01, 0x9e, 0x38, 0x30,\n    0xcc, 0x07, 0x02, 0xae, 0x07, 0x00, 0xbf, 0x89,\n    0xb3, 0x0a, 0x07, 0x83, 0x0a, 0xb7, 0x48, 0x02,\n    0x8e, 0x48, 0x02, 0x82, 0x48, 0xaf, 0x6a, 0x88,\n    0x1d, 0x06, 0xaa, 0x28, 0x01, 0x82, 0x28, 0x87,\n    0x89, 0x07, 0x82, 0x38, 0x80, 0x19, 0x8c, 0x38,\n    0x80, 0x19, 0x86, 0x38, 0x83, 0x19, 0x80, 0x38,\n    0x85, 0x19, 0x80, 0x38, 0x82, 0x19, 0x81, 0x38,\n    0x80, 0x19, 0x04, 0xa5, 0x47, 0x84, 0x2c, 0x80,\n    0x1d, 0xb0, 0x47, 0x84, 0x2c, 0x83, 0x47, 0x84,\n    0x2c, 0x8c, 0x47, 0x80, 0x1d, 0xc5, 0x47, 0x80,\n    0x2c, 0xbf, 0x38, 0xe0, 0x9f, 0x47, 0x95, 0x2c,\n    0x01, 0x85, 0x2c, 0x01, 0xa5, 0x2c, 0x01, 0x85,\n    0x2c, 0x01, 0x87, 0x2c, 0x00, 0x80, 0x2c, 0x00,\n    0x80, 0x2c, 0x00, 0x80, 0x2c, 0x00, 0x9e, 0x2c,\n    0x01, 0xb4, 0x2c, 0x00, 0x8e, 0x2c, 0x00, 0x8d,\n    0x2c, 0x01, 0x85, 0x2c, 0x00, 0x92, 0x2c, 0x01,\n    0x82, 0x2c, 0x00, 0x88, 0x2c, 0x00, 0x8b, 0x19,\n    0x81, 0x38, 0xd6, 0x19, 0x00, 0x8a, 0x19, 0x80,\n    0x47, 0x01, 0x8a, 0x19, 0x80, 0x47, 0x8e, 0x19,\n    0x00, 0x8c, 0x47, 0x02, 0xa0, 0x19, 0x0e, 0xa0,\n    0x38, 0x0e, 0xa5, 0x19, 0x80, 0x2c, 0x82, 0x19,\n    0x81, 0x47, 0x85, 0x19, 0x80, 0x47, 0x9a, 0x19,\n    0x80, 0x47, 0x90, 0x19, 0xa8, 0x47, 0x82, 0x19,\n    0x03, 0xe2, 0x36, 0x19, 0x18, 0x8a, 0x19, 0x14,\n    0xe3, 0x3f, 0x19, 0xe0, 0x9f, 0x0f, 0xe2, 0x13,\n    0x19, 0x01, 0x9f, 0x19, 0x00, 0xe0, 0x08, 0x19,\n    0xdf, 0x29, 0x9f, 0x47, 0xe0, 0x13, 0x1a, 0x04,\n    0x86, 0x1a, 0xa5, 0x28, 0x00, 0x80, 0x28, 0x04,\n    0x80, 0x28, 0x01, 0xb7, 0x98, 0x06, 0x81, 0x98,\n    0x0d, 0x80, 0x98, 0x96, 0x27, 0x08, 0x86, 0x27,\n    0x00, 0x86, 0x27, 0x00, 0x86, 0x27, 0x00, 0x86,\n    0x27, 0x00, 0x86, 0x27, 0x00, 0x86, 0x27, 0x00,\n    0x86, 0x27, 0x00, 0x86, 0x27, 0x00, 0x9f, 0x1d,\n    0xdd, 0x19, 0x21, 0x99, 0x30, 0x00, 0xd8, 0x30,\n    0x0b, 0xe0, 0x75, 0x30, 0x19, 0x8b, 0x19, 0x03,\n    0x84, 0x19, 0x80, 0x30, 0x80, 0x19, 0x80, 0x30,\n    0x98, 0x19, 0x88, 0x30, 0x83, 0x38, 0x81, 0x31,\n    0x87, 0x19, 0x83, 0x30, 0x83, 0x19, 0x00, 0xd5,\n    0x36, 0x01, 0x81, 0x38, 0x81, 0x19, 0x82, 0x36,\n    0x80, 0x19, 0xd9, 0x3e, 0x81, 0x19, 0x82, 0x3e,\n    0x04, 0xaa, 0x0d, 0x00, 0xdd, 0x31, 0x00, 0x8f,\n    0x19, 0x9f, 0x0d, 0xa3, 0x19, 0x0b, 0x8f, 0x3e,\n    0x9e, 0x31, 0x00, 0xbf, 0x19, 0x9e, 0x31, 0xd0,\n    0x19, 0xae, 0x3e, 0x80, 0x19, 0xd7, 0x3e, 0xe0,\n    0x47, 0x19, 0xf0, 0x09, 0x5f, 0x30, 0xbf, 0x19,\n    0xf0, 0x41, 0x9f, 0x30, 0xe4, 0x2c, 0xa2, 0x02,\n    0xb6, 0xa2, 0x08, 0xaf, 0x4c, 0xe0, 0xcb, 0x9d,\n    0x13, 0xdf, 0x1d, 0xd7, 0x08, 0x07, 0xa1, 0x19,\n    0xe0, 0x05, 0x47, 0x82, 0x19, 0xbf, 0x47, 0x04,\n    0x81, 0x47, 0x00, 0x80, 0x47, 0x00, 0x84, 0x47,\n    0x17, 0x8d, 0x47, 0xac, 0x8a, 0x02, 0x89, 0x19,\n    0x05, 0xb7, 0x7a, 0x07, 0xc5, 0x80, 0x07, 0x8b,\n    0x80, 0x05, 0x9f, 0x20, 0xad, 0x40, 0x80, 0x19,\n    0x80, 0x40, 0xa3, 0x7d, 0x0a, 0x80, 0x7d, 0x9c,\n    0x31, 0x02, 0xcd, 0x3b, 0x00, 0x80, 0x19, 0x89,\n    0x3b, 0x03, 0x81, 0x3b, 0x9e, 0x60, 0x00, 0xb6,\n    0x16, 0x08, 0x8d, 0x16, 0x01, 0x89, 0x16, 0x01,\n    0x83, 0x16, 0x9f, 0x60, 0xc2, 0x90, 0x17, 0x84,\n    0x90, 0x96, 0x57, 0x09, 0x85, 0x27, 0x01, 0x85,\n    0x27, 0x01, 0x85, 0x27, 0x08, 0x86, 0x27, 0x00,\n    0x86, 0x27, 0x00, 0xaa, 0x47, 0x80, 0x19, 0x88,\n    0x47, 0x80, 0x2c, 0x83, 0x47, 0x81, 0x19, 0x03,\n    0xcf, 0x17, 0xad, 0x57, 0x01, 0x89, 0x57, 0x05,\n    0xf0, 0x1b, 0x43, 0x31, 0x0b, 0x96, 0x31, 0x03,\n    0xb0, 0x31, 0x70, 0x10, 0xa3, 0xe1, 0x0d, 0x30,\n    0x01, 0xe0, 0x09, 0x30, 0x25, 0x86, 0x47, 0x0b,\n    0x84, 0x05, 0x04, 0x99, 0x35, 0x00, 0x84, 0x35,\n    0x00, 0x80, 0x35, 0x00, 0x81, 0x35, 0x00, 0x81,\n    0x35, 0x00, 0x89, 0x35, 0xe0, 0x12, 0x04, 0x0f,\n    0xe1, 0x0a, 0x04, 0x81, 0x19, 0xcf, 0x04, 0x01,\n    0xb5, 0x04, 0x06, 0x80, 0x04, 0x1f, 0x8f, 0x04,\n    0x8f, 0x38, 0x89, 0x19, 0x05, 0x8d, 0x38, 0x81,\n    0x1d, 0xa2, 0x19, 0x00, 0x92, 0x19, 0x00, 0x83,\n    0x19, 0x03, 0x84, 0x04, 0x00, 0xe0, 0x26, 0x04,\n    0x01, 0x80, 0x19, 0x00, 0x9f, 0x19, 0x99, 0x47,\n    0x85, 0x19, 0x99, 0x47, 0x8a, 0x19, 0x89, 0x3e,\n    0x80, 0x19, 0xac, 0x3e, 0x81, 0x19, 0x9e, 0x31,\n    0x02, 0x85, 0x31, 0x01, 0x85, 0x31, 0x01, 0x85,\n    0x31, 0x01, 0x82, 0x31, 0x02, 0x86, 0x19, 0x00,\n    0x86, 0x19, 0x09, 0x84, 0x19, 0x01, 0x8b, 0x4b,\n    0x00, 0x99, 0x4b, 0x00, 0x92, 0x4b, 0x00, 0x81,\n    0x4b, 0x00, 0x8e, 0x4b, 0x01, 0x8d, 0x4b, 0x21,\n    0xe0, 0x1a, 0x4b, 0x04, 0x82, 0x19, 0x03, 0xac,\n    0x19, 0x02, 0x88, 0x19, 0xce, 0x2c, 0x00, 0x8c,\n    0x19, 0x02, 0x80, 0x2c, 0x2e, 0xac, 0x19, 0x80,\n    0x38, 0x60, 0x21, 0x9c, 0x4d, 0x02, 0xb0, 0x13,\n    0x0e, 0x80, 0x38, 0x9a, 0x19, 0x03, 0xa3, 0x6c,\n    0x08, 0x82, 0x6c, 0x9a, 0x2a, 0x04, 0xaa, 0x6e,\n    0x04, 0x9d, 0x9c, 0x00, 0x80, 0x9c, 0xa3, 0x6f,\n    0x03, 0x8d, 0x6f, 0x29, 0xcf, 0x1f, 0xaf, 0x82,\n    0x9d, 0x76, 0x01, 0x89, 0x76, 0x05, 0xa3, 0x75,\n    0x03, 0xa3, 0x75, 0x03, 0xa7, 0x25, 0x07, 0xb3,\n    0x14, 0x0a, 0x80, 0x14, 0x8a, 0x9e, 0x00, 0x8e,\n    0x9e, 0x00, 0x86, 0x9e, 0x00, 0x81, 0x9e, 0x00,\n    0x8a, 0x9e, 0x00, 0x8e, 0x9e, 0x00, 0x86, 0x9e,\n    0x00, 0x81, 0x9e, 0x42, 0xe0, 0xd6, 0x4a, 0x08,\n    0x95, 0x4a, 0x09, 0x87, 0x4a, 0x17, 0x85, 0x47,\n    0x00, 0xa9, 0x47, 0x00, 0x88, 0x47, 0x44, 0x85,\n    0x1c, 0x01, 0x80, 0x1c, 0x00, 0xab, 0x1c, 0x00,\n    0x81, 0x1c, 0x02, 0x80, 0x1c, 0x01, 0x80, 0x1c,\n    0x95, 0x37, 0x00, 0x88, 0x37, 0x9f, 0x78, 0x9e,\n    0x61, 0x07, 0x88, 0x61, 0x2f, 0x92, 0x34, 0x00,\n    0x81, 0x34, 0x04, 0x84, 0x34, 0x9b, 0x7b, 0x02,\n    0x80, 0x7b, 0x99, 0x4e, 0x04, 0x80, 0x4e, 0x3f,\n    0x9f, 0x5a, 0x97, 0x59, 0x03, 0x93, 0x59, 0x01,\n    0xad, 0x59, 0x83, 0x41, 0x00, 0x81, 0x41, 0x04,\n    0x87, 0x41, 0x00, 0x82, 0x41, 0x00, 0x9c, 0x41,\n    0x01, 0x82, 0x41, 0x03, 0x89, 0x41, 0x06, 0x88,\n    0x41, 0x06, 0x9f, 0x71, 0x9f, 0x6d, 0x1f, 0xa6,\n    0x53, 0x03, 0x8b, 0x53, 0x08, 0xb5, 0x06, 0x02,\n    0x86, 0x06, 0x95, 0x3a, 0x01, 0x87, 0x3a, 0x92,\n    0x39, 0x04, 0x87, 0x39, 0x91, 0x7c, 0x06, 0x83,\n    0x7c, 0x0b, 0x86, 0x7c, 0x4f, 0xc8, 0x72, 0x36,\n    0xb2, 0x6b, 0x0c, 0xb2, 0x6b, 0x06, 0x85, 0x6b,\n    0xa7, 0x32, 0x07, 0x89, 0x32, 0x60, 0xc5, 0x9e,\n    0x04, 0x00, 0xa9, 0xa1, 0x00, 0x82, 0xa1, 0x01,\n    0x81, 0xa1, 0x4a, 0x82, 0x04, 0xa7, 0x70, 0x07,\n    0xa9, 0x86, 0x15, 0x99, 0x73, 0x25, 0x9b, 0x18,\n    0x13, 0x96, 0x26, 0x08, 0xcd, 0x0e, 0x03, 0xa3,\n    0x0e, 0x08, 0x80, 0x0e, 0xc2, 0x3c, 0x09, 0x80,\n    0x3c, 0x01, 0x98, 0x87, 0x06, 0x89, 0x87, 0x05,\n    0xb4, 0x15, 0x00, 0x91, 0x15, 0x07, 0xa6, 0x50,\n    0x08, 0xdf, 0x81, 0x00, 0x93, 0x85, 0x0a, 0x91,\n    0x43, 0x00, 0xae, 0x43, 0x3d, 0x86, 0x5f, 0x00,\n    0x80, 0x5f, 0x00, 0x83, 0x5f, 0x00, 0x8e, 0x5f,\n    0x00, 0x8a, 0x5f, 0x05, 0xba, 0x45, 0x04, 0x89,\n    0x45, 0x05, 0x83, 0x2b, 0x00, 0x87, 0x2b, 0x01,\n    0x81, 0x2b, 0x01, 0x95, 0x2b, 0x00, 0x86, 0x2b,\n    0x00, 0x81, 0x2b, 0x00, 0x84, 0x2b, 0x00, 0x80,\n    0x38, 0x88, 0x2b, 0x01, 0x81, 0x2b, 0x01, 0x82,\n    0x2b, 0x01, 0x80, 0x2b, 0x05, 0x80, 0x2b, 0x04,\n    0x86, 0x2b, 0x01, 0x86, 0x2b, 0x02, 0x84, 0x2b,\n    0x60, 0x2a, 0xdb, 0x65, 0x00, 0x84, 0x65, 0x1d,\n    0xc7, 0x99, 0x07, 0x89, 0x99, 0x60, 0x45, 0xb5,\n    0x83, 0x01, 0xa5, 0x83, 0x21, 0xc4, 0x5c, 0x0a,\n    0x89, 0x5c, 0x05, 0x8c, 0x5d, 0x12, 0xb9, 0x91,\n    0x05, 0x89, 0x91, 0x35, 0x9a, 0x02, 0x01, 0x8e,\n    0x02, 0x03, 0x96, 0x02, 0x60, 0x58, 0xbb, 0x22,\n    0x60, 0x03, 0xd2, 0xa0, 0x0b, 0x80, 0xa0, 0x86,\n    0x21, 0x01, 0x80, 0x21, 0x01, 0x87, 0x21, 0x00,\n    0x81, 0x21, 0x00, 0x9d, 0x21, 0x00, 0x81, 0x21,\n    0x01, 0x8b, 0x21, 0x08, 0x89, 0x21, 0x45, 0x87,\n    0x63, 0x01, 0xad, 0x63, 0x01, 0x8a, 0x63, 0x1a,\n    0xc7, 0xa3, 0x07, 0xd2, 0x88, 0x0c, 0x8f, 0x12,\n    0xb8, 0x79, 0x06, 0x89, 0x20, 0x60, 0x95, 0x88,\n    0x0c, 0x00, 0xac, 0x0c, 0x00, 0x8d, 0x0c, 0x09,\n    0x9c, 0x0c, 0x02, 0x9f, 0x54, 0x01, 0x95, 0x54,\n    0x00, 0x8d, 0x54, 0x48, 0x86, 0x55, 0x00, 0x81,\n    0x55, 0x00, 0xab, 0x55, 0x02, 0x80, 0x55, 0x00,\n    0x81, 0x55, 0x00, 0x88, 0x55, 0x07, 0x89, 0x55,\n    0x05, 0x85, 0x2e, 0x00, 0x81, 0x2e, 0x00, 0xa4,\n    0x2e, 0x00, 0x81, 0x2e, 0x00, 0x85, 0x2e, 0x06,\n    0x89, 0x2e, 0x60, 0xd5, 0x98, 0x4f, 0x06, 0x90,\n    0x3f, 0x00, 0xa8, 0x3f, 0x02, 0x9b, 0x3f, 0x55,\n    0x80, 0x4c, 0x0e, 0xb1, 0x92, 0x0c, 0x80, 0x92,\n    0xe3, 0x39, 0x1b, 0x60, 0x05, 0xe0, 0x0e, 0x1b,\n    0x00, 0x84, 0x1b, 0x0a, 0xe0, 0x63, 0x1b, 0x69,\n    0xeb, 0xe0, 0x02, 0x1e, 0x0c, 0xe3, 0xf5, 0x24,\n    0x6f, 0x49, 0xe1, 0xe6, 0x03, 0x70, 0x11, 0x58,\n    0xe1, 0xd8, 0x08, 0x06, 0x9e, 0x5e, 0x00, 0x89,\n    0x5e, 0x03, 0x81, 0x5e, 0xce, 0x9a, 0x00, 0x89,\n    0x9a, 0x05, 0x9d, 0x09, 0x01, 0x85, 0x09, 0x09,\n    0xc5, 0x77, 0x09, 0x89, 0x77, 0x00, 0x86, 0x77,\n    0x00, 0x94, 0x77, 0x04, 0x92, 0x77, 0x62, 0x4f,\n    0xda, 0x56, 0x60, 0x04, 0xca, 0x5b, 0x03, 0xb8,\n    0x5b, 0x06, 0x90, 0x5b, 0x3f, 0x80, 0x93, 0x80,\n    0x67, 0x81, 0x30, 0x80, 0x44, 0x0a, 0x81, 0x30,\n    0x0d, 0xf0, 0x07, 0x97, 0x93, 0x07, 0xe2, 0x9f,\n    0x93, 0xe1, 0x75, 0x44, 0x29, 0x88, 0x93, 0x70,\n    0x12, 0x86, 0x83, 0x3e, 0x00, 0x86, 0x3e, 0x00,\n    0x81, 0x3e, 0x00, 0x80, 0x3e, 0xe0, 0xbe, 0x36,\n    0x82, 0x3e, 0x0e, 0x80, 0x36, 0x1c, 0x82, 0x36,\n    0x01, 0x80, 0x3e, 0x0d, 0x83, 0x3e, 0x07, 0xe1,\n    0x2b, 0x67, 0x68, 0xa3, 0xe0, 0x0a, 0x23, 0x04,\n    0x8c, 0x23, 0x02, 0x88, 0x23, 0x06, 0x89, 0x23,\n    0x01, 0x83, 0x23, 0x83, 0x19, 0x70, 0x01, 0xfb,\n    0xad, 0x38, 0x01, 0x96, 0x38, 0x08, 0xe0, 0x13,\n    0x19, 0x3b, 0xe0, 0x95, 0x19, 0x09, 0xa6, 0x19,\n    0x01, 0xbd, 0x19, 0x82, 0x38, 0x90, 0x19, 0x87,\n    0x38, 0x81, 0x19, 0x86, 0x38, 0x9d, 0x19, 0x83,\n    0x38, 0xbc, 0x19, 0x14, 0xc5, 0x2c, 0x60, 0x19,\n    0x93, 0x19, 0x0b, 0x93, 0x19, 0x0b, 0xd6, 0x19,\n    0x08, 0x98, 0x19, 0x60, 0x26, 0xd4, 0x19, 0x00,\n    0xc6, 0x19, 0x00, 0x81, 0x19, 0x01, 0x80, 0x19,\n    0x01, 0x81, 0x19, 0x01, 0x83, 0x19, 0x00, 0x8b,\n    0x19, 0x00, 0x80, 0x19, 0x00, 0x86, 0x19, 0x00,\n    0xc0, 0x19, 0x00, 0x83, 0x19, 0x01, 0x87, 0x19,\n    0x00, 0x86, 0x19, 0x00, 0x9b, 0x19, 0x00, 0x83,\n    0x19, 0x00, 0x84, 0x19, 0x00, 0x80, 0x19, 0x02,\n    0x86, 0x19, 0x00, 0xe0, 0xf3, 0x19, 0x01, 0xe0,\n    0xc3, 0x19, 0x01, 0xb1, 0x19, 0xe2, 0x2b, 0x84,\n    0x0e, 0x84, 0x84, 0x00, 0x8e, 0x84, 0x63, 0xef,\n    0x9e, 0x47, 0x05, 0x85, 0x47, 0x60, 0x74, 0x86,\n    0x29, 0x00, 0x90, 0x29, 0x01, 0x86, 0x29, 0x00,\n    0x81, 0x29, 0x00, 0x84, 0x29, 0x04, 0xbd, 0x1d,\n    0x20, 0x80, 0x1d, 0x60, 0x0f, 0xac, 0x68, 0x02,\n    0x8d, 0x68, 0x01, 0x89, 0x68, 0x03, 0x81, 0x68,\n    0x60, 0xdf, 0x9e, 0x9b, 0x10, 0xb9, 0x9f, 0x04,\n    0x80, 0x9f, 0x61, 0x6f, 0xa9, 0x62, 0x62, 0x85,\n    0x86, 0x27, 0x00, 0x83, 0x27, 0x00, 0x81, 0x27,\n    0x00, 0x8e, 0x27, 0x00, 0xe0, 0x64, 0x58, 0x01,\n    0x8f, 0x58, 0x28, 0xcb, 0x01, 0x03, 0x89, 0x01,\n    0x03, 0x81, 0x01, 0x62, 0xb0, 0xc3, 0x19, 0x4b,\n    0xbc, 0x19, 0x60, 0x61, 0x83, 0x04, 0x00, 0x9a,\n    0x04, 0x00, 0x81, 0x04, 0x00, 0x80, 0x04, 0x01,\n    0x80, 0x04, 0x00, 0x89, 0x04, 0x00, 0x83, 0x04,\n    0x00, 0x80, 0x04, 0x00, 0x80, 0x04, 0x05, 0x80,\n    0x04, 0x03, 0x80, 0x04, 0x00, 0x80, 0x04, 0x00,\n    0x80, 0x04, 0x00, 0x82, 0x04, 0x00, 0x81, 0x04,\n    0x00, 0x80, 0x04, 0x01, 0x80, 0x04, 0x00, 0x80,\n    0x04, 0x00, 0x80, 0x04, 0x00, 0x80, 0x04, 0x00,\n    0x80, 0x04, 0x00, 0x81, 0x04, 0x00, 0x80, 0x04,\n    0x01, 0x83, 0x04, 0x00, 0x86, 0x04, 0x00, 0x83,\n    0x04, 0x00, 0x83, 0x04, 0x00, 0x80, 0x04, 0x00,\n    0x89, 0x04, 0x00, 0x90, 0x04, 0x04, 0x82, 0x04,\n    0x00, 0x84, 0x04, 0x00, 0x90, 0x04, 0x33, 0x81,\n    0x04, 0x60, 0xad, 0xab, 0x19, 0x03, 0xe0, 0x03,\n    0x19, 0x0b, 0x8e, 0x19, 0x01, 0x8e, 0x19, 0x00,\n    0x8e, 0x19, 0x00, 0xa4, 0x19, 0x09, 0xe0, 0x4d,\n    0x19, 0x37, 0x99, 0x19, 0x80, 0x36, 0x81, 0x19,\n    0x0c, 0xab, 0x19, 0x03, 0x88, 0x19, 0x06, 0x81,\n    0x19, 0x0d, 0x85, 0x19, 0x60, 0x39, 0xe3, 0x77,\n    0x19, 0x03, 0x90, 0x19, 0x02, 0x8c, 0x19, 0x02,\n    0xe0, 0x16, 0x19, 0x03, 0xde, 0x19, 0x05, 0x8b,\n    0x19, 0x03, 0x80, 0x19, 0x0e, 0x8b, 0x19, 0x03,\n    0xb7, 0x19, 0x07, 0x89, 0x19, 0x05, 0xa7, 0x19,\n    0x07, 0x9d, 0x19, 0x01, 0x81, 0x19, 0x4d, 0xe0,\n    0xf3, 0x19, 0x0b, 0x8d, 0x19, 0x01, 0x8c, 0x19,\n    0x02, 0x88, 0x19, 0x06, 0xad, 0x19, 0x00, 0x86,\n    0x19, 0x07, 0x8d, 0x19, 0x03, 0x88, 0x19, 0x06,\n    0x88, 0x19, 0x06, 0xe0, 0x32, 0x19, 0x00, 0xb6,\n    0x19, 0x24, 0x89, 0x19, 0x63, 0xa5, 0xf0, 0x96,\n    0x7f, 0x30, 0x1f, 0xef, 0xd9, 0x30, 0x05, 0xe0,\n    0x7d, 0x30, 0x01, 0xf0, 0x06, 0x21, 0x30, 0x0d,\n    0xf0, 0x0c, 0xd0, 0x30, 0x6b, 0xbe, 0xe1, 0xbd,\n    0x30, 0x65, 0x81, 0xf0, 0x02, 0xea, 0x30, 0x04,\n    0xef, 0xff, 0x30, 0x7a, 0xcb, 0xf0, 0x80, 0x19,\n    0x1d, 0xdf, 0x19, 0x60, 0x1f, 0xe0, 0x8f, 0x38,\n};\n\nstatic const uint8_t unicode_script_ext_table[828] = {\n    0x82, 0xc1, 0x00, 0x00, 0x01, 0x2c, 0x01, 0x00,\n    0x00, 0x01, 0x2c, 0x1c, 0x00, 0x0c, 0x01, 0x47,\n    0x80, 0x92, 0x00, 0x00, 0x02, 0x1d, 0x6e, 0x00,\n    0x02, 0x1d, 0x29, 0x01, 0x02, 0x1d, 0x47, 0x00,\n    0x02, 0x1d, 0x29, 0x81, 0x03, 0x00, 0x00, 0x06,\n    0x04, 0x66, 0x32, 0x8b, 0x95, 0xa1, 0x0d, 0x00,\n    0x00, 0x06, 0x04, 0x66, 0x32, 0x8b, 0x95, 0xa1,\n    0x00, 0x03, 0x04, 0x8b, 0x95, 0x01, 0x00, 0x00,\n    0x07, 0x01, 0x04, 0x66, 0x32, 0x8b, 0x95, 0xa1,\n    0x1f, 0x00, 0x00, 0x09, 0x01, 0x04, 0x52, 0x53,\n    0x73, 0x7c, 0x32, 0x86, 0x8b, 0x09, 0x00, 0x0a,\n    0x02, 0x04, 0x8b, 0x09, 0x00, 0x09, 0x03, 0x04,\n    0x95, 0xa1, 0x05, 0x00, 0x00, 0x02, 0x04, 0x8b,\n    0x62, 0x00, 0x00, 0x02, 0x04, 0x32, 0x81, 0xfb,\n    0x00, 0x00, 0x0d, 0x0b, 0x20, 0x2b, 0x2d, 0x2f,\n    0x3d, 0x47, 0x51, 0x74, 0x81, 0x92, 0x94, 0x99,\n    0x00, 0x0c, 0x0b, 0x20, 0x2b, 0x2d, 0x2f, 0x3d,\n    0x47, 0x51, 0x74, 0x92, 0x94, 0x99, 0x10, 0x00,\n    0x00, 0x14, 0x0b, 0x20, 0x22, 0x2e, 0x55, 0x2b,\n    0x2d, 0x2f, 0x3d, 0x50, 0x51, 0x63, 0x74, 0x45,\n    0x85, 0x8a, 0x91, 0x92, 0x94, 0x99, 0x00, 0x15,\n    0x0b, 0x20, 0x22, 0x2e, 0x55, 0x2b, 0x2d, 0x2f,\n    0x3d, 0x49, 0x50, 0x51, 0x63, 0x74, 0x45, 0x85,\n    0x8a, 0x91, 0x92, 0x94, 0x99, 0x09, 0x04, 0x20,\n    0x22, 0x3c, 0x50, 0x75, 0x00, 0x09, 0x03, 0x0b,\n    0x15, 0x8a, 0x75, 0x00, 0x09, 0x02, 0x2f, 0x5f,\n    0x75, 0x00, 0x09, 0x02, 0x2d, 0x43, 0x80, 0x75,\n    0x00, 0x0d, 0x02, 0x2b, 0x92, 0x80, 0x71, 0x00,\n    0x09, 0x02, 0x3d, 0x63, 0x82, 0xcf, 0x00, 0x09,\n    0x03, 0x15, 0x60, 0x8e, 0x80, 0x30, 0x00, 0x00,\n    0x02, 0x28, 0x47, 0x85, 0xb8, 0x00, 0x01, 0x04,\n    0x11, 0x33, 0x8d, 0x8c, 0x80, 0x4a, 0x00, 0x01,\n    0x02, 0x5d, 0x7a, 0x00, 0x00, 0x00, 0x02, 0x5d,\n    0x7a, 0x84, 0x49, 0x00, 0x00, 0x04, 0x0b, 0x20,\n    0x2b, 0x3d, 0x00, 0x01, 0x20, 0x00, 0x04, 0x0b,\n    0x20, 0x2b, 0x3d, 0x00, 0x02, 0x20, 0x2b, 0x00,\n    0x01, 0x20, 0x01, 0x02, 0x0b, 0x20, 0x00, 0x02,\n    0x20, 0x81, 0x00, 0x02, 0x0b, 0x20, 0x00, 0x02,\n    0x20, 0x81, 0x00, 0x06, 0x20, 0x3d, 0x51, 0x74,\n    0x92, 0x94, 0x00, 0x01, 0x20, 0x01, 0x02, 0x20,\n    0x81, 0x01, 0x01, 0x20, 0x00, 0x02, 0x20, 0x81,\n    0x00, 0x02, 0x0b, 0x20, 0x06, 0x01, 0x20, 0x00,\n    0x02, 0x20, 0x63, 0x00, 0x02, 0x0b, 0x20, 0x01,\n    0x01, 0x20, 0x00, 0x02, 0x0b, 0x20, 0x03, 0x01,\n    0x20, 0x00, 0x08, 0x0b, 0x20, 0x2b, 0x3d, 0x63,\n    0x74, 0x94, 0x99, 0x00, 0x02, 0x20, 0x2b, 0x00,\n    0x03, 0x20, 0x2b, 0x3d, 0x01, 0x02, 0x0b, 0x20,\n    0x00, 0x01, 0x0b, 0x01, 0x02, 0x20, 0x2b, 0x00,\n    0x01, 0x63, 0x80, 0x44, 0x00, 0x01, 0x01, 0x2c,\n    0x35, 0x00, 0x00, 0x02, 0x1d, 0x8b, 0x00, 0x00,\n    0x00, 0x01, 0x8b, 0x81, 0xb3, 0x00, 0x00, 0x02,\n    0x47, 0x5d, 0x80, 0x3f, 0x00, 0x00, 0x03, 0x20,\n    0x2b, 0x47, 0x8c, 0xd1, 0x00, 0x00, 0x02, 0x1d,\n    0x29, 0x81, 0x3c, 0x00, 0x01, 0x06, 0x0d, 0x31,\n    0x30, 0x36, 0x3e, 0xa2, 0x00, 0x05, 0x0d, 0x31,\n    0x30, 0x36, 0x3e, 0x01, 0x00, 0x00, 0x01, 0x30,\n    0x00, 0x00, 0x09, 0x06, 0x0d, 0x31, 0x30, 0x36,\n    0x3e, 0xa2, 0x00, 0x00, 0x00, 0x05, 0x0d, 0x31,\n    0x30, 0x36, 0x3e, 0x07, 0x06, 0x0d, 0x31, 0x30,\n    0x36, 0x3e, 0xa2, 0x03, 0x05, 0x0d, 0x31, 0x30,\n    0x36, 0x3e, 0x09, 0x00, 0x03, 0x02, 0x0d, 0x30,\n    0x01, 0x00, 0x00, 0x05, 0x0d, 0x31, 0x30, 0x36,\n    0x3e, 0x04, 0x02, 0x36, 0x3e, 0x00, 0x00, 0x00,\n    0x05, 0x0d, 0x31, 0x30, 0x36, 0x3e, 0x03, 0x00,\n    0x01, 0x03, 0x30, 0x36, 0x3e, 0x01, 0x01, 0x30,\n    0x58, 0x00, 0x03, 0x02, 0x36, 0x3e, 0x02, 0x00,\n    0x00, 0x02, 0x36, 0x3e, 0x59, 0x00, 0x00, 0x06,\n    0x0d, 0x31, 0x30, 0x36, 0x3e, 0xa2, 0x00, 0x02,\n    0x36, 0x3e, 0x80, 0x12, 0x00, 0x0f, 0x01, 0x30,\n    0x1f, 0x00, 0x23, 0x01, 0x30, 0x3b, 0x00, 0x27,\n    0x01, 0x30, 0x37, 0x00, 0x30, 0x01, 0x30, 0x0e,\n    0x00, 0x0b, 0x01, 0x30, 0x32, 0x00, 0x00, 0x01,\n    0x30, 0x57, 0x00, 0x18, 0x01, 0x30, 0x09, 0x00,\n    0x04, 0x01, 0x30, 0x5f, 0x00, 0x1e, 0x01, 0x30,\n    0xc0, 0x31, 0xef, 0x00, 0x00, 0x02, 0x1d, 0x29,\n    0x80, 0x0f, 0x00, 0x07, 0x02, 0x30, 0x47, 0x80,\n    0xa7, 0x00, 0x02, 0x0e, 0x20, 0x22, 0x2d, 0x2f,\n    0x43, 0x3d, 0x3c, 0x50, 0x51, 0x5c, 0x63, 0x45,\n    0x91, 0x99, 0x02, 0x0d, 0x20, 0x22, 0x2d, 0x2f,\n    0x43, 0x3d, 0x3c, 0x50, 0x5c, 0x63, 0x45, 0x91,\n    0x99, 0x03, 0x0b, 0x20, 0x22, 0x2d, 0x2f, 0x43,\n    0x3c, 0x50, 0x5c, 0x45, 0x91, 0x99, 0x80, 0x36,\n    0x00, 0x00, 0x02, 0x0b, 0x20, 0x00, 0x00, 0x00,\n    0x02, 0x20, 0x92, 0x39, 0x00, 0x00, 0x03, 0x40,\n    0x47, 0x60, 0x80, 0x1f, 0x00, 0x00, 0x02, 0x10,\n    0x3b, 0xc0, 0x12, 0xed, 0x00, 0x01, 0x02, 0x04,\n    0x66, 0x80, 0x31, 0x00, 0x00, 0x02, 0x04, 0x95,\n    0x09, 0x00, 0x00, 0x02, 0x04, 0x95, 0x46, 0x00,\n    0x01, 0x05, 0x0d, 0x31, 0x30, 0x36, 0x3e, 0x80,\n    0x99, 0x00, 0x04, 0x06, 0x0d, 0x31, 0x30, 0x36,\n    0x3e, 0xa2, 0x09, 0x00, 0x00, 0x02, 0x36, 0x3e,\n    0x2c, 0x00, 0x01, 0x02, 0x36, 0x3e, 0x80, 0xdf,\n    0x00, 0x01, 0x03, 0x1e, 0x1c, 0x4b, 0x00, 0x02,\n    0x1c, 0x4b, 0x03, 0x00, 0x2c, 0x03, 0x1c, 0x4a,\n    0x4b, 0x02, 0x00, 0x08, 0x02, 0x1c, 0x4b, 0x81,\n    0x1f, 0x00, 0x1b, 0x02, 0x04, 0x1a, 0x87, 0x75,\n    0x00, 0x00, 0x02, 0x53, 0x73, 0x87, 0x8d, 0x00,\n    0x00, 0x02, 0x2b, 0x92, 0x00, 0x00, 0x00, 0x02,\n    0x2b, 0x92, 0x36, 0x00, 0x01, 0x02, 0x2b, 0x92,\n    0x8c, 0x12, 0x00, 0x01, 0x02, 0x2b, 0x92, 0x00,\n    0x00, 0x00, 0x02, 0x2b, 0x92, 0xc0, 0x5c, 0x4b,\n    0x00, 0x03, 0x01, 0x23, 0x96, 0x3b, 0x00, 0x11,\n    0x01, 0x30, 0x9e, 0x5d, 0x00, 0x01, 0x01, 0x30,\n    0xce, 0xcd, 0x2d, 0x00,\n};\n\nstatic const uint8_t unicode_prop_Hyphen_table[28] = {\n    0xac, 0x80, 0xfe, 0x80, 0x44, 0xdb, 0x80, 0x52,\n    0x7a, 0x80, 0x48, 0x08, 0x81, 0x4e, 0x04, 0x80,\n    0x42, 0xe2, 0x80, 0x60, 0xcd, 0x66, 0x80, 0x40,\n    0xa8, 0x80, 0xd6, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Other_Math_table[200] = {\n    0xdd, 0x80, 0x43, 0x70, 0x11, 0x80, 0x99, 0x09,\n    0x81, 0x5c, 0x1f, 0x80, 0x9a, 0x82, 0x8a, 0x80,\n    0x9f, 0x83, 0x97, 0x81, 0x8d, 0x81, 0xc0, 0x8c,\n    0x18, 0x11, 0x1c, 0x91, 0x03, 0x01, 0x89, 0x00,\n    0x14, 0x28, 0x11, 0x09, 0x02, 0x05, 0x13, 0x24,\n    0xca, 0x21, 0x18, 0x08, 0x08, 0x00, 0x21, 0x0b,\n    0x0b, 0x91, 0x09, 0x00, 0x06, 0x00, 0x29, 0x41,\n    0x21, 0x83, 0x40, 0xa7, 0x08, 0x80, 0x97, 0x80,\n    0x90, 0x80, 0x41, 0xbc, 0x81, 0x8b, 0x88, 0x24,\n    0x21, 0x09, 0x14, 0x8d, 0x00, 0x01, 0x85, 0x97,\n    0x81, 0xb8, 0x00, 0x80, 0x9c, 0x83, 0x88, 0x81,\n    0x41, 0x55, 0x81, 0x9e, 0x89, 0x41, 0x92, 0x95,\n    0xbe, 0x83, 0x9f, 0x81, 0x60, 0xd4, 0x62, 0x00,\n    0x03, 0x80, 0x40, 0xd2, 0x00, 0x80, 0x60, 0xd4,\n    0xc0, 0xd4, 0x80, 0xc6, 0x01, 0x08, 0x09, 0x0b,\n    0x80, 0x8b, 0x00, 0x06, 0x80, 0xc0, 0x03, 0x0f,\n    0x06, 0x80, 0x9b, 0x03, 0x04, 0x00, 0x16, 0x80,\n    0x41, 0x53, 0x81, 0x98, 0x80, 0x98, 0x80, 0x9e,\n    0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80, 0x9e,\n    0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x07, 0x81,\n    0xb1, 0x55, 0xff, 0x18, 0x9a, 0x01, 0x00, 0x08,\n    0x80, 0x89, 0x03, 0x00, 0x00, 0x28, 0x18, 0x00,\n    0x00, 0x02, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x00, 0x0b, 0x06, 0x03, 0x03, 0x00,\n    0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80, 0x90,\n};\n\nstatic const uint8_t unicode_prop_Other_Alphabetic_table[428] = {\n    0x43, 0x44, 0x80, 0x42, 0x69, 0x8d, 0x00, 0x01,\n    0x01, 0x00, 0xc7, 0x8a, 0xaf, 0x8c, 0x06, 0x8f,\n    0x80, 0xe4, 0x33, 0x19, 0x0b, 0x80, 0xa2, 0x80,\n    0x9d, 0x8f, 0xe5, 0x8a, 0xe4, 0x0a, 0x88, 0x02,\n    0x03, 0x40, 0xa6, 0x8b, 0x16, 0x85, 0x93, 0xb5,\n    0x09, 0x8e, 0x01, 0x22, 0x89, 0x81, 0x9c, 0x82,\n    0xb9, 0x31, 0x09, 0x81, 0x89, 0x80, 0x89, 0x81,\n    0x9c, 0x82, 0xb9, 0x23, 0x09, 0x0b, 0x80, 0x9d,\n    0x0a, 0x80, 0x8a, 0x82, 0xb9, 0x38, 0x10, 0x81,\n    0x94, 0x81, 0x95, 0x13, 0x82, 0xb9, 0x31, 0x09,\n    0x81, 0x88, 0x81, 0x89, 0x81, 0x9d, 0x80, 0xba,\n    0x22, 0x10, 0x82, 0x89, 0x80, 0xa7, 0x84, 0xb8,\n    0x30, 0x10, 0x17, 0x81, 0x8a, 0x81, 0x9c, 0x82,\n    0xb9, 0x30, 0x10, 0x17, 0x81, 0x8a, 0x81, 0x8e,\n    0x80, 0x8b, 0x83, 0xb9, 0x30, 0x10, 0x82, 0x89,\n    0x80, 0x89, 0x81, 0x9c, 0x82, 0xca, 0x28, 0x00,\n    0x87, 0x91, 0x81, 0xbc, 0x01, 0x86, 0x91, 0x80,\n    0xe2, 0x01, 0x28, 0x81, 0x8f, 0x80, 0x40, 0xa2,\n    0x92, 0x88, 0x8a, 0x80, 0xa3, 0xed, 0x8b, 0x00,\n    0x0b, 0x96, 0x1b, 0x10, 0x11, 0x32, 0x83, 0x8c,\n    0x8b, 0x00, 0x89, 0x83, 0x46, 0x73, 0x81, 0x9d,\n    0x81, 0x9d, 0x81, 0x9d, 0x81, 0xc1, 0x92, 0x40,\n    0xbb, 0x81, 0xa1, 0x80, 0xf5, 0x8b, 0x83, 0x88,\n    0x40, 0xdd, 0x84, 0xb8, 0x89, 0x81, 0x93, 0xc9,\n    0x81, 0x8a, 0x82, 0xb0, 0x84, 0xaf, 0x8e, 0xbb,\n    0x82, 0x9d, 0x88, 0x09, 0xb8, 0x8a, 0xb1, 0x92,\n    0x41, 0xaf, 0x8d, 0x46, 0xc0, 0xb3, 0x48, 0xf5,\n    0x9f, 0x60, 0x78, 0x73, 0x87, 0xa1, 0x81, 0x41,\n    0x61, 0x07, 0x80, 0x96, 0x84, 0xd7, 0x81, 0xb1,\n    0x8f, 0x00, 0xb8, 0x80, 0xa5, 0x84, 0x9b, 0x8b,\n    0xac, 0x83, 0xaf, 0x8b, 0xa4, 0x80, 0xc2, 0x8d,\n    0x8b, 0x07, 0x81, 0xac, 0x82, 0xb1, 0x00, 0x11,\n    0x0c, 0x80, 0xab, 0x24, 0x80, 0x40, 0xec, 0x87,\n    0x60, 0x4f, 0x32, 0x80, 0x48, 0x56, 0x84, 0x46,\n    0x85, 0x10, 0x0c, 0x83, 0x43, 0x13, 0x83, 0x41,\n    0x82, 0x81, 0x41, 0x52, 0x82, 0xb4, 0x8d, 0xac,\n    0x81, 0x8a, 0x82, 0xac, 0x88, 0x88, 0x80, 0xbc,\n    0x82, 0xa3, 0x8b, 0x91, 0x81, 0xb8, 0x82, 0xaf,\n    0x8c, 0x8d, 0x81, 0xdb, 0x88, 0x08, 0x28, 0x08,\n    0x40, 0x9c, 0x89, 0x96, 0x83, 0xb9, 0x31, 0x09,\n    0x81, 0x89, 0x80, 0x89, 0x81, 0x40, 0xd0, 0x8c,\n    0x02, 0xe9, 0x91, 0x40, 0xec, 0x31, 0x86, 0x9c,\n    0x81, 0xd1, 0x8e, 0x00, 0xe9, 0x8a, 0xe6, 0x8d,\n    0x41, 0x00, 0x8c, 0x40, 0xf6, 0x28, 0x09, 0x0a,\n    0x00, 0x80, 0x40, 0x8d, 0x31, 0x2b, 0x80, 0x9b,\n    0x89, 0xa9, 0x20, 0x83, 0x91, 0x8a, 0xad, 0x8d,\n    0x41, 0x96, 0x38, 0x86, 0xd2, 0x95, 0x80, 0x8d,\n    0xf9, 0x2a, 0x00, 0x08, 0x10, 0x02, 0x80, 0xc1,\n    0x20, 0x08, 0x83, 0x41, 0x5b, 0x83, 0x88, 0x08,\n    0x80, 0xaf, 0x32, 0x82, 0x60, 0x50, 0x0d, 0x00,\n    0xb6, 0x33, 0xdc, 0x81, 0x60, 0x4c, 0xab, 0x80,\n    0x60, 0x23, 0x60, 0x30, 0x90, 0x0e, 0x01, 0x04,\n    0xe3, 0x80, 0x48, 0xb6, 0x80, 0x47, 0xe7, 0x99,\n    0x85, 0x99, 0x85, 0x99,\n};\n\nstatic const uint8_t unicode_prop_Other_Lowercase_table[69] = {\n    0x40, 0xa9, 0x80, 0x8e, 0x80, 0x41, 0xf4, 0x88,\n    0x31, 0x9d, 0x84, 0xdf, 0x80, 0xb3, 0x80, 0x4d,\n    0x80, 0x80, 0x4c, 0x2e, 0xbe, 0x8c, 0x80, 0xa1,\n    0xa4, 0x42, 0xb0, 0x80, 0x8c, 0x80, 0x8f, 0x8c,\n    0x40, 0xd2, 0x8f, 0x43, 0x4f, 0x99, 0x47, 0x91,\n    0x81, 0x60, 0x7a, 0x1d, 0x81, 0x40, 0xd1, 0x80,\n    0x40, 0x80, 0x12, 0x81, 0x43, 0x61, 0x83, 0x88,\n    0x80, 0x60, 0x5c, 0x15, 0x01, 0x10, 0xa9, 0x80,\n    0x88, 0x60, 0xd8, 0x74, 0xbd,\n};\n\nstatic const uint8_t unicode_prop_Other_Uppercase_table[15] = {\n    0x60, 0x21, 0x5f, 0x8f, 0x43, 0x45, 0x99, 0x61,\n    0xcc, 0x5f, 0x99, 0x85, 0x99, 0x85, 0x99,\n};\n\nstatic const uint8_t unicode_prop_Other_Grapheme_Extend_table[65] = {\n    0x49, 0xbd, 0x80, 0x97, 0x80, 0x41, 0x65, 0x80,\n    0x97, 0x80, 0xe5, 0x80, 0x97, 0x80, 0x40, 0xe9,\n    0x80, 0x91, 0x81, 0xe6, 0x80, 0x97, 0x80, 0xf6,\n    0x80, 0x8e, 0x80, 0x4d, 0x54, 0x80, 0x44, 0xd5,\n    0x80, 0x50, 0x20, 0x81, 0x60, 0xcf, 0x6d, 0x81,\n    0x53, 0x9d, 0x80, 0x97, 0x80, 0x41, 0x57, 0x80,\n    0x8b, 0x80, 0x40, 0xf0, 0x80, 0x43, 0x7f, 0x80,\n    0x60, 0xb8, 0x33, 0x07, 0x84, 0x6c, 0x2e, 0xac,\n    0xdf,\n};\n\nstatic const uint8_t unicode_prop_Other_Default_Ignorable_Code_Point_table[32] = {\n    0x43, 0x4e, 0x80, 0x4e, 0x0e, 0x81, 0x46, 0x52,\n    0x81, 0x48, 0xae, 0x80, 0x50, 0xfd, 0x80, 0x60,\n    0xce, 0x3a, 0x80, 0xce, 0x88, 0x6d, 0x00, 0x06,\n    0x00, 0x9d, 0xdf, 0xff, 0x40, 0xef, 0x4e, 0x0f,\n};\n\nstatic const uint8_t unicode_prop_Other_ID_Start_table[11] = {\n    0x58, 0x84, 0x81, 0x48, 0x90, 0x80, 0x94, 0x80,\n    0x4f, 0x6b, 0x81,\n};\n\nstatic const uint8_t unicode_prop_Other_ID_Continue_table[12] = {\n    0x40, 0xb6, 0x80, 0x42, 0xce, 0x80, 0x4f, 0xe0,\n    0x88, 0x46, 0x67, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Prepended_Concatenation_Mark_table[19] = {\n    0x45, 0xff, 0x85, 0x40, 0xd6, 0x80, 0xb0, 0x80,\n    0x41, 0x7f, 0x81, 0xcf, 0x80, 0x61, 0x07, 0xd9,\n    0x80, 0x8e, 0x80,\n};\n\nstatic const uint8_t unicode_prop_XID_Start1_table[31] = {\n    0x43, 0x79, 0x80, 0x4a, 0xb7, 0x80, 0xfe, 0x80,\n    0x60, 0x21, 0xe6, 0x81, 0x60, 0xcb, 0xc0, 0x85,\n    0x41, 0x95, 0x81, 0xf3, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x80, 0x41, 0x1e, 0x81,\n};\n\nstatic const uint8_t unicode_prop_XID_Continue1_table[23] = {\n    0x43, 0x79, 0x80, 0x60, 0x2d, 0x1f, 0x81, 0x60,\n    0xcb, 0xc0, 0x85, 0x41, 0x95, 0x81, 0xf3, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Changes_When_Titlecased1_table[22] = {\n    0x41, 0xc3, 0x08, 0x08, 0x81, 0xa4, 0x81, 0x4e,\n    0xdc, 0xaa, 0x0a, 0x4e, 0x87, 0x3f, 0x3f, 0x87,\n    0x8b, 0x80, 0x8e, 0x80, 0xae, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Changes_When_Casefolded1_table[29] = {\n    0x41, 0xef, 0x80, 0x41, 0x9e, 0x80, 0x9e, 0x80,\n    0x5a, 0xe4, 0x83, 0x40, 0xb5, 0x00, 0x00, 0x00,\n    0x80, 0xde, 0x06, 0x06, 0x80, 0x8a, 0x09, 0x81,\n    0x89, 0x10, 0x81, 0x8d, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Changes_When_NFKC_Casefolded1_table[447] = {\n    0x40, 0x9f, 0x06, 0x00, 0x01, 0x00, 0x01, 0x12,\n    0x10, 0x82, 0xf3, 0x80, 0x8b, 0x80, 0x40, 0x84,\n    0x01, 0x01, 0x80, 0xa2, 0x01, 0x80, 0x40, 0xbb,\n    0x88, 0x9e, 0x29, 0x84, 0xda, 0x08, 0x81, 0x89,\n    0x80, 0xa3, 0x04, 0x02, 0x04, 0x08, 0x07, 0x80,\n    0x9e, 0x80, 0xa0, 0x82, 0x9c, 0x80, 0x42, 0x28,\n    0x80, 0xd7, 0x83, 0x42, 0xde, 0x87, 0xfb, 0x08,\n    0x80, 0xd2, 0x01, 0x80, 0xa1, 0x11, 0x80, 0x40,\n    0xfc, 0x81, 0x42, 0xd4, 0x80, 0xfe, 0x80, 0xa7,\n    0x81, 0xad, 0x80, 0xb5, 0x80, 0x88, 0x03, 0x03,\n    0x03, 0x80, 0x8b, 0x80, 0x88, 0x00, 0x26, 0x80,\n    0x90, 0x80, 0x88, 0x03, 0x03, 0x03, 0x80, 0x8b,\n    0x80, 0x41, 0x41, 0x80, 0xe1, 0x81, 0x46, 0x52,\n    0x81, 0xd4, 0x84, 0x45, 0x1b, 0x10, 0x8a, 0x80,\n    0x91, 0x80, 0x9b, 0x8c, 0x80, 0xa1, 0xa4, 0x40,\n    0xd5, 0x83, 0x40, 0xb5, 0x00, 0x00, 0x00, 0x80,\n    0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n    0xb7, 0x05, 0x00, 0x13, 0x05, 0x11, 0x02, 0x0c,\n    0x11, 0x00, 0x00, 0x0c, 0x15, 0x05, 0x08, 0x8f,\n    0x00, 0x20, 0x8b, 0x12, 0x2a, 0x08, 0x0b, 0x00,\n    0x07, 0x82, 0x8c, 0x06, 0x92, 0x81, 0x9a, 0x80,\n    0x8c, 0x8a, 0x80, 0xd6, 0x18, 0x10, 0x8a, 0x01,\n    0x0c, 0x0a, 0x00, 0x10, 0x11, 0x02, 0x06, 0x05,\n    0x1c, 0x85, 0x8f, 0x8f, 0x8f, 0x88, 0x80, 0x40,\n    0xa1, 0x08, 0x81, 0x40, 0xf7, 0x81, 0x41, 0x34,\n    0xd5, 0x99, 0x9a, 0x45, 0x20, 0x80, 0xe6, 0x82,\n    0xe4, 0x80, 0x41, 0x9e, 0x81, 0x40, 0xf0, 0x80,\n    0x41, 0x2e, 0x80, 0xd2, 0x80, 0x8b, 0x40, 0xd5,\n    0xa9, 0x80, 0xb4, 0x00, 0x82, 0xdf, 0x09, 0x80,\n    0xde, 0x80, 0xb0, 0xdd, 0x82, 0x8d, 0xdf, 0x9e,\n    0x80, 0xa7, 0x87, 0xae, 0x80, 0x41, 0x7f, 0x60,\n    0x72, 0x9b, 0x81, 0x40, 0xd1, 0x80, 0x40, 0x80,\n    0x12, 0x81, 0x43, 0x61, 0x83, 0x88, 0x80, 0x60,\n    0x4d, 0x95, 0x41, 0x0d, 0x08, 0x00, 0x81, 0x89,\n    0x00, 0x00, 0x09, 0x82, 0xc3, 0x81, 0xe9, 0xc2,\n    0x00, 0x97, 0x04, 0x00, 0x01, 0x01, 0x80, 0xeb,\n    0xa0, 0x41, 0x6a, 0x91, 0xbf, 0x81, 0xb5, 0xa7,\n    0x8c, 0x82, 0x99, 0x95, 0x94, 0x81, 0x8b, 0x80,\n    0x92, 0x03, 0x1a, 0x00, 0x80, 0x40, 0x86, 0x08,\n    0x80, 0x9f, 0x99, 0x40, 0x83, 0x15, 0x0d, 0x0d,\n    0x0a, 0x16, 0x06, 0x80, 0x88, 0x47, 0x87, 0x20,\n    0xa9, 0x80, 0x88, 0x60, 0xb4, 0xe4, 0x83, 0x54,\n    0xb9, 0x86, 0x8d, 0x87, 0xbf, 0x85, 0x42, 0x3e,\n    0xd4, 0x80, 0xc6, 0x01, 0x08, 0x09, 0x0b, 0x80,\n    0x8b, 0x00, 0x06, 0x80, 0xc0, 0x03, 0x0f, 0x06,\n    0x80, 0x9b, 0x03, 0x04, 0x00, 0x16, 0x80, 0x41,\n    0x53, 0x81, 0x41, 0x23, 0x81, 0xb1, 0x48, 0x2f,\n    0xbd, 0x4d, 0x91, 0x18, 0x9a, 0x01, 0x00, 0x08,\n    0x80, 0x89, 0x03, 0x00, 0x00, 0x28, 0x18, 0x00,\n    0x00, 0x02, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x00, 0x0b, 0x06, 0x03, 0x03, 0x00,\n    0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80, 0x90,\n    0x42, 0x43, 0x8a, 0x84, 0x9e, 0x80, 0x9f, 0x99,\n    0x82, 0xa2, 0x80, 0xee, 0x82, 0x8c, 0xab, 0x83,\n    0x88, 0x31, 0x49, 0x9d, 0x89, 0x60, 0xfc, 0x05,\n    0x42, 0x1d, 0x6b, 0x05, 0xe1, 0x4f, 0xff,\n};\n\nstatic const uint8_t unicode_prop_ASCII_Hex_Digit_table[5] = {\n    0xaf, 0x89, 0x35, 0x99, 0x85,\n};\n\nstatic const uint8_t unicode_prop_Bidi_Control_table[10] = {\n    0x46, 0x1b, 0x80, 0x59, 0xf0, 0x81, 0x99, 0x84,\n    0xb6, 0x83,\n};\n\nstatic const uint8_t unicode_prop_Dash_table[55] = {\n    0xac, 0x80, 0x45, 0x5b, 0x80, 0xb2, 0x80, 0x4e,\n    0x40, 0x80, 0x44, 0x04, 0x80, 0x48, 0x08, 0x85,\n    0xbc, 0x80, 0xa6, 0x80, 0x8e, 0x80, 0x41, 0x85,\n    0x80, 0x4c, 0x03, 0x01, 0x80, 0x9e, 0x0b, 0x80,\n    0x9b, 0x80, 0x41, 0xbd, 0x80, 0x92, 0x80, 0xee,\n    0x80, 0x60, 0xcd, 0x8f, 0x81, 0xa4, 0x80, 0x89,\n    0x80, 0x40, 0xa8, 0x80, 0x4f, 0x9e, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Deprecated_table[23] = {\n    0x41, 0x48, 0x80, 0x45, 0x28, 0x80, 0x49, 0x02,\n    0x00, 0x80, 0x48, 0x28, 0x81, 0x48, 0xc4, 0x85,\n    0x42, 0xb8, 0x81, 0x6d, 0xdc, 0xd5, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Diacritic_table[399] = {\n    0xdd, 0x00, 0x80, 0xc6, 0x05, 0x03, 0x01, 0x81,\n    0x41, 0xf6, 0x40, 0x9e, 0x07, 0x25, 0x90, 0x0b,\n    0x80, 0x88, 0x81, 0x40, 0xfc, 0x84, 0x40, 0xd0,\n    0x80, 0xb6, 0x90, 0x80, 0x9a, 0x00, 0x01, 0x00,\n    0x40, 0x85, 0x3b, 0x81, 0x40, 0x85, 0x0b, 0x0a,\n    0x82, 0xc2, 0x9a, 0xda, 0x8a, 0xb9, 0x8a, 0xa1,\n    0x81, 0xfd, 0x87, 0xa8, 0x89, 0x8f, 0x9b, 0xbc,\n    0x80, 0x8f, 0x02, 0x83, 0x9b, 0x80, 0xc9, 0x80,\n    0x8f, 0x80, 0xed, 0x80, 0x8f, 0x80, 0xed, 0x80,\n    0x8f, 0x80, 0xae, 0x82, 0xbb, 0x80, 0x8f, 0x06,\n    0x80, 0xf6, 0x80, 0xed, 0x80, 0x8f, 0x80, 0xed,\n    0x80, 0x8f, 0x80, 0xec, 0x81, 0x8f, 0x80, 0xfb,\n    0x80, 0xfb, 0x28, 0x80, 0xea, 0x80, 0x8c, 0x84,\n    0xca, 0x81, 0x9a, 0x00, 0x00, 0x03, 0x81, 0xc1,\n    0x10, 0x81, 0xbd, 0x80, 0xef, 0x00, 0x81, 0xa7,\n    0x0b, 0x84, 0x98, 0x30, 0x80, 0x89, 0x81, 0x42,\n    0xc0, 0x82, 0x43, 0xb3, 0x81, 0x40, 0xb2, 0x8a,\n    0x88, 0x80, 0x41, 0x5a, 0x82, 0x41, 0x38, 0x39,\n    0x80, 0xaf, 0x8e, 0x81, 0x8a, 0xe7, 0x80, 0x8e,\n    0x80, 0xa5, 0x88, 0xb5, 0x81, 0x40, 0x89, 0x81,\n    0xbf, 0x85, 0xd1, 0x98, 0x18, 0x28, 0x0a, 0xb1,\n    0xbe, 0xd8, 0x8b, 0xa4, 0x8a, 0x41, 0xbc, 0x00,\n    0x82, 0x8a, 0x82, 0x8c, 0x82, 0x8c, 0x82, 0x8c,\n    0x81, 0x4c, 0xef, 0x82, 0x41, 0x3c, 0x80, 0x41,\n    0xf9, 0x85, 0xe8, 0x83, 0xde, 0x80, 0x60, 0x75,\n    0x71, 0x80, 0x8b, 0x08, 0x80, 0x9b, 0x81, 0xd1,\n    0x81, 0x8d, 0xa1, 0xe5, 0x82, 0xec, 0x81, 0x40,\n    0xc9, 0x80, 0x9a, 0x91, 0xb8, 0x83, 0xa3, 0x80,\n    0xde, 0x80, 0x8b, 0x80, 0xa3, 0x80, 0x40, 0x94,\n    0x82, 0xc0, 0x83, 0xb2, 0x80, 0xe3, 0x84, 0x88,\n    0x82, 0xff, 0x81, 0x60, 0x4f, 0x2f, 0x80, 0x43,\n    0x00, 0x8f, 0x41, 0x0d, 0x00, 0x80, 0xae, 0x80,\n    0xac, 0x81, 0xc2, 0x80, 0x42, 0xfb, 0x80, 0x44,\n    0x9e, 0x28, 0xa9, 0x80, 0x88, 0x43, 0x29, 0x81,\n    0x42, 0x3a, 0x85, 0x41, 0xd4, 0x82, 0xc5, 0x8a,\n    0xb0, 0x83, 0x40, 0xbf, 0x80, 0xa8, 0x80, 0xc7,\n    0x81, 0xf7, 0x81, 0xbd, 0x80, 0xcb, 0x80, 0x88,\n    0x82, 0xe7, 0x81, 0x40, 0xb1, 0x81, 0xd0, 0x80,\n    0x8f, 0x80, 0x97, 0x32, 0x84, 0x40, 0xcc, 0x02,\n    0x80, 0xfa, 0x81, 0x40, 0xfa, 0x81, 0xfd, 0x80,\n    0xf5, 0x81, 0xf2, 0x80, 0x41, 0x0c, 0x81, 0x41,\n    0x01, 0x0b, 0x80, 0x40, 0x9b, 0x80, 0xd2, 0x80,\n    0x91, 0x80, 0xd0, 0x80, 0x41, 0xa4, 0x80, 0x41,\n    0x01, 0x00, 0x81, 0xd0, 0x80, 0x56, 0xae, 0x8e,\n    0x60, 0x36, 0x99, 0x84, 0xba, 0x86, 0x44, 0x57,\n    0x90, 0xcf, 0x81, 0x60, 0x3f, 0xfd, 0x18, 0x30,\n    0x81, 0x5f, 0x00, 0xad, 0x81, 0x96, 0x42, 0x1f,\n    0x12, 0x2f, 0x39, 0x86, 0x9d, 0x83, 0x4e, 0x81,\n    0xbd, 0x40, 0xc1, 0x86, 0x41, 0x76, 0x80, 0xbc,\n    0x83, 0x45, 0xdf, 0x86, 0xec, 0x10, 0x82,\n};\n\nstatic const uint8_t unicode_prop_Extender_table[92] = {\n    0x40, 0xb6, 0x80, 0x42, 0x17, 0x81, 0x43, 0x6d,\n    0x80, 0x41, 0xb8, 0x80, 0x43, 0x59, 0x80, 0x42,\n    0xef, 0x80, 0xfe, 0x80, 0x49, 0x42, 0x80, 0xb7,\n    0x80, 0x42, 0x62, 0x80, 0x41, 0x8d, 0x80, 0xc3,\n    0x80, 0x53, 0x88, 0x80, 0xaa, 0x84, 0xe6, 0x81,\n    0xdc, 0x82, 0x60, 0x6f, 0x15, 0x80, 0x45, 0xf5,\n    0x80, 0x43, 0xc1, 0x80, 0x95, 0x80, 0x40, 0x88,\n    0x80, 0xeb, 0x80, 0x94, 0x81, 0x60, 0x54, 0x7a,\n    0x80, 0x48, 0x0f, 0x81, 0x4b, 0xd9, 0x80, 0x42,\n    0x67, 0x82, 0x44, 0xce, 0x80, 0x60, 0x50, 0xa8,\n    0x81, 0x44, 0x9b, 0x08, 0x80, 0x60, 0x71, 0x57,\n    0x81, 0x48, 0x05, 0x82,\n};\n\nstatic const uint8_t unicode_prop_Hex_Digit_table[12] = {\n    0xaf, 0x89, 0x35, 0x99, 0x85, 0x60, 0xfe, 0xa8,\n    0x89, 0x35, 0x99, 0x85,\n};\n\nstatic const uint8_t unicode_prop_IDS_Binary_Operator_table[5] = {\n    0x60, 0x2f, 0xef, 0x09, 0x87,\n};\n\nstatic const uint8_t unicode_prop_IDS_Trinary_Operator_table[4] = {\n    0x60, 0x2f, 0xf1, 0x81,\n};\n\nstatic const uint8_t unicode_prop_Ideographic_table[69] = {\n    0x60, 0x30, 0x05, 0x81, 0x98, 0x88, 0x8d, 0x82,\n    0x43, 0xc4, 0x59, 0xbf, 0xbf, 0x60, 0x51, 0xff,\n    0x60, 0x58, 0xff, 0x41, 0x6d, 0x81, 0xe9, 0x60,\n    0x75, 0x09, 0x80, 0x9a, 0x57, 0xf7, 0x87, 0x44,\n    0xd5, 0xa9, 0x88, 0x60, 0x24, 0x66, 0x41, 0x8b,\n    0x60, 0x4d, 0x03, 0x60, 0xa6, 0xdf, 0x9f, 0x50,\n    0x39, 0x85, 0x40, 0xdd, 0x81, 0x56, 0x81, 0x8d,\n    0x5d, 0x30, 0x4c, 0x1e, 0x42, 0x1d, 0x45, 0xe1,\n    0x53, 0x4a, 0x84, 0x50, 0x5f,\n};\n\nstatic const uint8_t unicode_prop_Join_Control_table[4] = {\n    0x60, 0x20, 0x0b, 0x81,\n};\n\nstatic const uint8_t unicode_prop_Logical_Order_Exception_table[15] = {\n    0x4e, 0x3f, 0x84, 0xfa, 0x84, 0x4a, 0xef, 0x11,\n    0x80, 0x60, 0x90, 0xf9, 0x09, 0x00, 0x81,\n};\n\nstatic const uint8_t unicode_prop_Noncharacter_Code_Point_table[71] = {\n    0x60, 0xfd, 0xcf, 0x9f, 0x42, 0x0d, 0x81, 0x60,\n    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,\n    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,\n    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,\n    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,\n    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,\n    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,\n    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,\n    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81,\n};\n\nstatic const uint8_t unicode_prop_Pattern_Syntax_table[58] = {\n    0xa0, 0x8e, 0x89, 0x86, 0x99, 0x18, 0x80, 0x99,\n    0x83, 0xa1, 0x30, 0x00, 0x08, 0x00, 0x0b, 0x03,\n    0x02, 0x80, 0x96, 0x80, 0x9e, 0x80, 0x5f, 0x17,\n    0x97, 0x87, 0x8e, 0x81, 0x92, 0x80, 0x89, 0x41,\n    0x30, 0x42, 0xcf, 0x40, 0x9f, 0x42, 0x75, 0x9d,\n    0x44, 0x6b, 0x41, 0xff, 0xff, 0x41, 0x80, 0x13,\n    0x98, 0x8e, 0x80, 0x60, 0xcd, 0x0c, 0x81, 0x41,\n    0x04, 0x81,\n};\n\nstatic const uint8_t unicode_prop_Pattern_White_Space_table[11] = {\n    0x88, 0x84, 0x91, 0x80, 0xe3, 0x80, 0x5f, 0x87,\n    0x81, 0x97, 0x81,\n};\n\nstatic const uint8_t unicode_prop_Quotation_Mark_table[31] = {\n    0xa1, 0x03, 0x80, 0x40, 0x82, 0x80, 0x8e, 0x80,\n    0x5f, 0x5b, 0x87, 0x98, 0x81, 0x4e, 0x06, 0x80,\n    0x41, 0xc8, 0x83, 0x8c, 0x82, 0x60, 0xce, 0x20,\n    0x83, 0x40, 0xbc, 0x03, 0x80, 0xd9, 0x81,\n};\n\nstatic const uint8_t unicode_prop_Radical_table[9] = {\n    0x60, 0x2e, 0x7f, 0x99, 0x80, 0xd8, 0x8b, 0x40,\n    0xd5,\n};\n\nstatic const uint8_t unicode_prop_Regional_Indicator_table[4] = {\n    0x61, 0xf1, 0xe5, 0x99,\n};\n\nstatic const uint8_t unicode_prop_Sentence_Terminal_table[196] = {\n    0xa0, 0x80, 0x8b, 0x80, 0x8f, 0x80, 0x45, 0x48,\n    0x80, 0x40, 0x92, 0x82, 0x40, 0xb3, 0x80, 0xaa,\n    0x82, 0x40, 0xf5, 0x80, 0xbc, 0x00, 0x02, 0x81,\n    0x41, 0x24, 0x81, 0x46, 0xe3, 0x81, 0x43, 0x15,\n    0x03, 0x81, 0x43, 0x04, 0x80, 0x40, 0xc5, 0x81,\n    0x40, 0xcb, 0x04, 0x80, 0x41, 0x39, 0x81, 0x41,\n    0x61, 0x83, 0x40, 0xad, 0x09, 0x81, 0x9c, 0x81,\n    0x40, 0xbb, 0x81, 0xc0, 0x81, 0x43, 0xbb, 0x81,\n    0x88, 0x82, 0x4d, 0xe3, 0x80, 0x8c, 0x80, 0x95,\n    0x81, 0x41, 0xac, 0x80, 0x60, 0x74, 0xfb, 0x80,\n    0x41, 0x0d, 0x81, 0x40, 0xe2, 0x02, 0x80, 0x41,\n    0x7d, 0x81, 0xd5, 0x81, 0xde, 0x80, 0x40, 0x97,\n    0x81, 0x40, 0x92, 0x82, 0x40, 0x8f, 0x81, 0x40,\n    0xf8, 0x80, 0x60, 0x52, 0x65, 0x02, 0x81, 0x40,\n    0xa8, 0x80, 0x8b, 0x80, 0x8f, 0x80, 0xc0, 0x80,\n    0x4a, 0xf3, 0x81, 0x44, 0xfc, 0x84, 0xab, 0x83,\n    0x40, 0xbc, 0x81, 0xf4, 0x83, 0xfe, 0x82, 0x40,\n    0x80, 0x0d, 0x80, 0x8f, 0x81, 0xd7, 0x08, 0x81,\n    0xeb, 0x80, 0x41, 0xa0, 0x81, 0x41, 0x74, 0x0c,\n    0x8e, 0xe8, 0x81, 0x40, 0xf8, 0x82, 0x42, 0x04,\n    0x00, 0x80, 0x40, 0xfa, 0x81, 0xd6, 0x81, 0x41,\n    0xa3, 0x81, 0x42, 0xb3, 0x81, 0xc9, 0x81, 0x60,\n    0x4b, 0x28, 0x81, 0x40, 0x84, 0x80, 0xc0, 0x81,\n    0x8a, 0x80, 0x43, 0x52, 0x80, 0x60, 0x4e, 0x05,\n    0x80, 0x5d, 0xe7, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Soft_Dotted_table[79] = {\n    0xe8, 0x81, 0x40, 0xc3, 0x80, 0x41, 0x18, 0x80,\n    0x9d, 0x80, 0xb3, 0x80, 0x93, 0x80, 0x41, 0x3f,\n    0x80, 0xe1, 0x00, 0x80, 0x59, 0x08, 0x80, 0xb2,\n    0x80, 0x8c, 0x02, 0x80, 0x40, 0x83, 0x80, 0x40,\n    0x9c, 0x80, 0x41, 0xa4, 0x80, 0x40, 0xd5, 0x81,\n    0x4b, 0x31, 0x80, 0x61, 0xa7, 0xa4, 0x81, 0xb1,\n    0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1,\n    0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1,\n    0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1, 0x81, 0x48,\n    0x85, 0x80, 0x41, 0x30, 0x81, 0x99, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Terminal_Punctuation_table[248] = {\n    0xa0, 0x80, 0x89, 0x00, 0x80, 0x8a, 0x0a, 0x80,\n    0x43, 0x3d, 0x07, 0x80, 0x42, 0x00, 0x80, 0xb8,\n    0x80, 0xc7, 0x80, 0x8d, 0x00, 0x82, 0x40, 0xb3,\n    0x80, 0xaa, 0x8a, 0x00, 0x40, 0xea, 0x81, 0xb5,\n    0x8e, 0x9e, 0x80, 0x41, 0x04, 0x81, 0x44, 0xf3,\n    0x81, 0x40, 0xab, 0x03, 0x85, 0x41, 0x36, 0x81,\n    0x43, 0x14, 0x87, 0x43, 0x04, 0x80, 0xfb, 0x82,\n    0xc6, 0x81, 0x40, 0x9c, 0x12, 0x80, 0xa6, 0x19,\n    0x81, 0x41, 0x39, 0x81, 0x41, 0x61, 0x83, 0x40,\n    0xad, 0x08, 0x82, 0x9c, 0x81, 0x40, 0xbb, 0x84,\n    0xbd, 0x81, 0x43, 0xbb, 0x81, 0x88, 0x82, 0x4d,\n    0xe3, 0x80, 0x8c, 0x03, 0x80, 0x89, 0x00, 0x0a,\n    0x81, 0x41, 0xab, 0x81, 0x60, 0x74, 0xfa, 0x81,\n    0x41, 0x0c, 0x82, 0x40, 0xe2, 0x84, 0x41, 0x7d,\n    0x81, 0xd5, 0x81, 0xde, 0x80, 0x40, 0x96, 0x82,\n    0x40, 0x92, 0x82, 0xfe, 0x80, 0x8f, 0x81, 0x40,\n    0xf8, 0x80, 0x60, 0x52, 0x63, 0x10, 0x83, 0x40,\n    0xa8, 0x80, 0x89, 0x00, 0x80, 0x8a, 0x0a, 0x80,\n    0xc0, 0x01, 0x80, 0x44, 0x39, 0x80, 0xaf, 0x80,\n    0x44, 0x85, 0x80, 0x40, 0xc6, 0x80, 0x41, 0x35,\n    0x81, 0x40, 0x97, 0x85, 0xc3, 0x85, 0xd8, 0x83,\n    0x43, 0xb7, 0x84, 0xab, 0x83, 0x40, 0xbc, 0x86,\n    0xef, 0x83, 0xfe, 0x82, 0x40, 0x80, 0x0d, 0x80,\n    0x8f, 0x81, 0xd7, 0x84, 0xeb, 0x80, 0x41, 0xa0,\n    0x82, 0x8b, 0x81, 0x41, 0x65, 0x1a, 0x8e, 0xe8,\n    0x81, 0x40, 0xf8, 0x82, 0x42, 0x04, 0x00, 0x80,\n    0x40, 0xfa, 0x81, 0xd6, 0x0b, 0x81, 0x41, 0x9d,\n    0x82, 0xac, 0x80, 0x42, 0x84, 0x81, 0xc9, 0x81,\n    0x45, 0x2a, 0x84, 0x60, 0x45, 0xf8, 0x81, 0x40,\n    0x84, 0x80, 0xc0, 0x82, 0x89, 0x80, 0x43, 0x51,\n    0x81, 0x60, 0x4e, 0x05, 0x80, 0x5d, 0xe6, 0x83,\n};\n\nstatic const uint8_t unicode_prop_Unified_Ideograph_table[45] = {\n    0x60, 0x33, 0xff, 0x59, 0xbf, 0xbf, 0x60, 0x51,\n    0xff, 0x60, 0x5a, 0x0d, 0x08, 0x00, 0x81, 0x89,\n    0x00, 0x00, 0x09, 0x82, 0x61, 0x05, 0xd5, 0x60,\n    0xa6, 0xdf, 0x9f, 0x50, 0x39, 0x85, 0x40, 0xdd,\n    0x81, 0x56, 0x81, 0x8d, 0x5d, 0x30, 0x54, 0x1e,\n    0x53, 0x4a, 0x84, 0x50, 0x5f,\n};\n\nstatic const uint8_t unicode_prop_Variation_Selector_table[13] = {\n    0x58, 0x0a, 0x10, 0x80, 0x60, 0xe5, 0xef, 0x8f,\n    0x6d, 0x02, 0xef, 0x40, 0xef,\n};\n\nstatic const uint8_t unicode_prop_White_Space_table[22] = {\n    0x88, 0x84, 0x91, 0x80, 0xe3, 0x80, 0x99, 0x80,\n    0x55, 0xde, 0x80, 0x49, 0x7e, 0x8a, 0x9c, 0x0c,\n    0x80, 0xae, 0x80, 0x4f, 0x9f, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Bidi_Mirrored_table[173] = {\n    0xa7, 0x81, 0x91, 0x00, 0x80, 0x9b, 0x00, 0x80,\n    0x9c, 0x00, 0x80, 0xac, 0x80, 0x8e, 0x80, 0x4e,\n    0x7d, 0x83, 0x47, 0x5c, 0x81, 0x49, 0x9b, 0x81,\n    0x89, 0x81, 0xb5, 0x81, 0x8d, 0x81, 0x40, 0xb0,\n    0x80, 0x40, 0xbf, 0x1a, 0x2a, 0x02, 0x0a, 0x18,\n    0x18, 0x00, 0x03, 0x88, 0x20, 0x80, 0x91, 0x23,\n    0x88, 0x08, 0x00, 0x39, 0x9e, 0x0b, 0x20, 0x88,\n    0x09, 0x92, 0x21, 0x88, 0x21, 0x0b, 0x97, 0x81,\n    0x8f, 0x3b, 0x93, 0x0e, 0x81, 0x44, 0x3c, 0x8d,\n    0xc9, 0x01, 0x18, 0x08, 0x14, 0x1c, 0x12, 0x8d,\n    0x41, 0x92, 0x95, 0x0d, 0x80, 0x8d, 0x38, 0x35,\n    0x10, 0x1c, 0x01, 0x0c, 0x18, 0x02, 0x09, 0x89,\n    0x29, 0x81, 0x8b, 0x92, 0x03, 0x08, 0x00, 0x08,\n    0x03, 0x21, 0x2a, 0x97, 0x81, 0x8a, 0x0b, 0x18,\n    0x09, 0x0b, 0xaa, 0x0f, 0x80, 0xa7, 0x20, 0x00,\n    0x14, 0x22, 0x18, 0x14, 0x00, 0x40, 0xff, 0x80,\n    0x42, 0x02, 0x1a, 0x08, 0x81, 0x8d, 0x09, 0x89,\n    0xaa, 0x87, 0x41, 0xaa, 0x89, 0x0f, 0x60, 0xce,\n    0x3c, 0x2c, 0x81, 0x40, 0xa1, 0x81, 0x91, 0x00,\n    0x80, 0x9b, 0x00, 0x80, 0x9c, 0x00, 0x00, 0x08,\n    0x81, 0x60, 0xd7, 0x76, 0x80, 0xb8, 0x80, 0xb8,\n    0x80, 0xb8, 0x80, 0xb8, 0x80,\n};\n\nstatic const uint8_t unicode_prop_Emoji_table[239] = {\n    0xa2, 0x05, 0x04, 0x89, 0xee, 0x03, 0x80, 0x5f,\n    0x8c, 0x80, 0x8b, 0x80, 0x40, 0xd7, 0x80, 0x95,\n    0x80, 0xd9, 0x85, 0x8e, 0x81, 0x41, 0x6e, 0x81,\n    0x8b, 0x80, 0x40, 0xa5, 0x80, 0x98, 0x8a, 0x1a,\n    0x40, 0xc6, 0x80, 0x40, 0xe6, 0x81, 0x89, 0x80,\n    0x88, 0x80, 0xb9, 0x18, 0x84, 0x88, 0x01, 0x01,\n    0x09, 0x03, 0x01, 0x00, 0x09, 0x02, 0x02, 0x0f,\n    0x14, 0x00, 0x04, 0x8b, 0x8a, 0x09, 0x00, 0x08,\n    0x80, 0x91, 0x01, 0x81, 0x91, 0x28, 0x00, 0x0a,\n    0x0c, 0x01, 0x0b, 0x81, 0x8a, 0x0c, 0x09, 0x04,\n    0x08, 0x00, 0x81, 0x93, 0x0c, 0x28, 0x19, 0x03,\n    0x01, 0x01, 0x28, 0x01, 0x00, 0x00, 0x05, 0x02,\n    0x05, 0x80, 0x89, 0x81, 0x8e, 0x01, 0x03, 0x00,\n    0x03, 0x10, 0x80, 0x8a, 0x81, 0xaf, 0x82, 0x88,\n    0x80, 0x8d, 0x80, 0x8d, 0x80, 0x41, 0x73, 0x81,\n    0x41, 0xce, 0x82, 0x92, 0x81, 0xb2, 0x03, 0x80,\n    0x44, 0xd9, 0x80, 0x8b, 0x80, 0x42, 0x58, 0x00,\n    0x80, 0x61, 0xbd, 0x69, 0x80, 0x40, 0xc9, 0x80,\n    0x40, 0x9f, 0x81, 0x8b, 0x81, 0x8d, 0x01, 0x89,\n    0xca, 0x99, 0x01, 0x96, 0x80, 0x93, 0x01, 0x88,\n    0x94, 0x81, 0x40, 0xad, 0xa1, 0x81, 0xef, 0x09,\n    0x02, 0x81, 0xd2, 0x0a, 0x80, 0x41, 0x06, 0x80,\n    0xbe, 0x8a, 0x28, 0x97, 0x31, 0x0f, 0x8b, 0x01,\n    0x19, 0x03, 0x81, 0x8c, 0x09, 0x07, 0x81, 0x88,\n    0x04, 0x82, 0x8b, 0x17, 0x11, 0x00, 0x03, 0x05,\n    0x02, 0x05, 0xd5, 0xaf, 0xc5, 0x27, 0x0a, 0x83,\n    0x89, 0x10, 0x01, 0x10, 0x81, 0x89, 0x40, 0xe2,\n    0x8b, 0x18, 0x41, 0x1a, 0xae, 0x80, 0x89, 0x80,\n    0x40, 0xb8, 0xef, 0x8c, 0x82, 0x88, 0x86, 0xad,\n    0x06, 0x87, 0x8d, 0x83, 0x88, 0x86, 0x88,\n};\n\nstatic const uint8_t unicode_prop_Emoji_Component_table[28] = {\n    0xa2, 0x05, 0x04, 0x89, 0x5f, 0xd2, 0x80, 0x40,\n    0xd4, 0x80, 0x60, 0xdd, 0x2a, 0x80, 0x60, 0xf3,\n    0xd5, 0x99, 0x41, 0xfa, 0x84, 0x45, 0xaf, 0x83,\n    0x6c, 0x06, 0x6b, 0xdf,\n};\n\nstatic const uint8_t unicode_prop_Emoji_Modifier_table[4] = {\n    0x61, 0xf3, 0xfa, 0x84,\n};\n\nstatic const uint8_t unicode_prop_Emoji_Modifier_Base_table[71] = {\n    0x60, 0x26, 0x1c, 0x80, 0x40, 0xda, 0x80, 0x8f,\n    0x83, 0x61, 0xcc, 0x76, 0x80, 0xbb, 0x11, 0x01,\n    0x82, 0xf4, 0x09, 0x8a, 0x94, 0x92, 0x10, 0x1a,\n    0x02, 0x30, 0x00, 0x97, 0x80, 0x40, 0xc8, 0x0b,\n    0x80, 0x94, 0x03, 0x81, 0x40, 0xad, 0x12, 0x84,\n    0xd2, 0x80, 0x8f, 0x82, 0x88, 0x80, 0x8a, 0x80,\n    0x42, 0x3e, 0x01, 0x07, 0x3d, 0x80, 0x88, 0x89,\n    0x0a, 0xb7, 0x80, 0xbc, 0x08, 0x08, 0x80, 0x90,\n    0x10, 0x8c, 0x40, 0xe4, 0x82, 0xa9, 0x88,\n};\n\nstatic const uint8_t unicode_prop_Emoji_Presentation_table[145] = {\n    0x60, 0x23, 0x19, 0x81, 0x40, 0xcc, 0x1a, 0x01,\n    0x80, 0x42, 0x08, 0x81, 0x94, 0x81, 0xb1, 0x8b,\n    0xaa, 0x80, 0x92, 0x80, 0x8c, 0x07, 0x81, 0x90,\n    0x0c, 0x0f, 0x04, 0x80, 0x94, 0x06, 0x08, 0x03,\n    0x01, 0x06, 0x03, 0x81, 0x9b, 0x80, 0xa2, 0x00,\n    0x03, 0x10, 0x80, 0xbc, 0x82, 0x97, 0x80, 0x8d,\n    0x80, 0x43, 0x5a, 0x81, 0xb2, 0x03, 0x80, 0x61,\n    0xc4, 0xad, 0x80, 0x40, 0xc9, 0x80, 0x40, 0xbd,\n    0x01, 0x89, 0xca, 0x99, 0x00, 0x97, 0x80, 0x93,\n    0x01, 0x20, 0x82, 0x94, 0x81, 0x40, 0xad, 0xa0,\n    0x8b, 0x88, 0x80, 0xc5, 0x80, 0x95, 0x8b, 0xaa,\n    0x1c, 0x8b, 0x90, 0x10, 0x82, 0xc6, 0x00, 0x80,\n    0x40, 0xba, 0x81, 0xbe, 0x8c, 0x18, 0x97, 0x91,\n    0x80, 0x99, 0x81, 0x8c, 0x80, 0xd5, 0xd4, 0xaf,\n    0xc5, 0x28, 0x12, 0x0a, 0x1b, 0x8a, 0x0e, 0x88,\n    0x40, 0xe2, 0x8b, 0x18, 0x41, 0x1a, 0xae, 0x80,\n    0x89, 0x80, 0x40, 0xb8, 0xef, 0x8c, 0x82, 0x88,\n    0x86, 0xad, 0x06, 0x87, 0x8d, 0x83, 0x88, 0x86,\n    0x88,\n};\n\nstatic const uint8_t unicode_prop_Extended_Pictographic_table[156] = {\n    0x40, 0xa8, 0x03, 0x80, 0x5f, 0x8c, 0x80, 0x8b,\n    0x80, 0x40, 0xd7, 0x80, 0x95, 0x80, 0xd9, 0x85,\n    0x8e, 0x81, 0x41, 0x6e, 0x81, 0x8b, 0x80, 0xde,\n    0x80, 0xc5, 0x80, 0x98, 0x8a, 0x1a, 0x40, 0xc6,\n    0x80, 0x40, 0xe6, 0x81, 0x89, 0x80, 0x88, 0x80,\n    0xb9, 0x18, 0x28, 0x8b, 0x80, 0xf1, 0x89, 0xf5,\n    0x81, 0x8a, 0x00, 0x00, 0x28, 0x10, 0x28, 0x89,\n    0x81, 0x8e, 0x01, 0x03, 0x00, 0x03, 0x10, 0x80,\n    0x8a, 0x84, 0xac, 0x82, 0x88, 0x80, 0x8d, 0x80,\n    0x8d, 0x80, 0x41, 0x73, 0x81, 0x41, 0xce, 0x82,\n    0x92, 0x81, 0xb2, 0x03, 0x80, 0x44, 0xd9, 0x80,\n    0x8b, 0x80, 0x42, 0x58, 0x00, 0x80, 0x61, 0xbd,\n    0x65, 0x40, 0xff, 0x8c, 0x82, 0x9e, 0x80, 0xbb,\n    0x85, 0x8b, 0x81, 0x8d, 0x01, 0x89, 0x91, 0xb8,\n    0x9a, 0x8e, 0x89, 0x80, 0x93, 0x01, 0x88, 0x03,\n    0x88, 0x41, 0xb1, 0x84, 0x41, 0x3d, 0x87, 0x41,\n    0x09, 0xaf, 0xff, 0xf3, 0x8b, 0xd4, 0xaa, 0x8b,\n    0x83, 0xb7, 0x87, 0x89, 0x85, 0xa7, 0x87, 0x9d,\n    0xd1, 0x8b, 0xae, 0x80, 0x89, 0x80, 0x41, 0xb8,\n    0x40, 0xff, 0x43, 0xfd,\n};\n\nstatic const uint8_t unicode_prop_Default_Ignorable_Code_Point_table[51] = {\n    0x40, 0xac, 0x80, 0x42, 0xa0, 0x80, 0x42, 0xcb,\n    0x80, 0x4b, 0x41, 0x81, 0x46, 0x52, 0x81, 0xd4,\n    0x84, 0x47, 0xfa, 0x84, 0x99, 0x84, 0xb0, 0x8f,\n    0x50, 0xf3, 0x80, 0x60, 0xcc, 0x9a, 0x8f, 0x40,\n    0xee, 0x80, 0x40, 0x9f, 0x80, 0xce, 0x88, 0x60,\n    0xbc, 0xa6, 0x83, 0x54, 0xce, 0x87, 0x6c, 0x2e,\n    0x84, 0x4f, 0xff,\n};\n\ntypedef enum {\n    UNICODE_PROP_Hyphen,\n    UNICODE_PROP_Other_Math,\n    UNICODE_PROP_Other_Alphabetic,\n    UNICODE_PROP_Other_Lowercase,\n    UNICODE_PROP_Other_Uppercase,\n    UNICODE_PROP_Other_Grapheme_Extend,\n    UNICODE_PROP_Other_Default_Ignorable_Code_Point,\n    UNICODE_PROP_Other_ID_Start,\n    UNICODE_PROP_Other_ID_Continue,\n    UNICODE_PROP_Prepended_Concatenation_Mark,\n    UNICODE_PROP_ID_Continue1,\n    UNICODE_PROP_XID_Start1,\n    UNICODE_PROP_XID_Continue1,\n    UNICODE_PROP_Changes_When_Titlecased1,\n    UNICODE_PROP_Changes_When_Casefolded1,\n    UNICODE_PROP_Changes_When_NFKC_Casefolded1,\n    UNICODE_PROP_ASCII_Hex_Digit,\n    UNICODE_PROP_Bidi_Control,\n    UNICODE_PROP_Dash,\n    UNICODE_PROP_Deprecated,\n    UNICODE_PROP_Diacritic,\n    UNICODE_PROP_Extender,\n    UNICODE_PROP_Hex_Digit,\n    UNICODE_PROP_IDS_Binary_Operator,\n    UNICODE_PROP_IDS_Trinary_Operator,\n    UNICODE_PROP_Ideographic,\n    UNICODE_PROP_Join_Control,\n    UNICODE_PROP_Logical_Order_Exception,\n    UNICODE_PROP_Noncharacter_Code_Point,\n    UNICODE_PROP_Pattern_Syntax,\n    UNICODE_PROP_Pattern_White_Space,\n    UNICODE_PROP_Quotation_Mark,\n    UNICODE_PROP_Radical,\n    UNICODE_PROP_Regional_Indicator,\n    UNICODE_PROP_Sentence_Terminal,\n    UNICODE_PROP_Soft_Dotted,\n    UNICODE_PROP_Terminal_Punctuation,\n    UNICODE_PROP_Unified_Ideograph,\n    UNICODE_PROP_Variation_Selector,\n    UNICODE_PROP_White_Space,\n    UNICODE_PROP_Bidi_Mirrored,\n    UNICODE_PROP_Emoji,\n    UNICODE_PROP_Emoji_Component,\n    UNICODE_PROP_Emoji_Modifier,\n    UNICODE_PROP_Emoji_Modifier_Base,\n    UNICODE_PROP_Emoji_Presentation,\n    UNICODE_PROP_Extended_Pictographic,\n    UNICODE_PROP_Default_Ignorable_Code_Point,\n    UNICODE_PROP_ID_Start,\n    UNICODE_PROP_Case_Ignorable,\n    UNICODE_PROP_ASCII,\n    UNICODE_PROP_Alphabetic,\n    UNICODE_PROP_Any,\n    UNICODE_PROP_Assigned,\n    UNICODE_PROP_Cased,\n    UNICODE_PROP_Changes_When_Casefolded,\n    UNICODE_PROP_Changes_When_Casemapped,\n    UNICODE_PROP_Changes_When_Lowercased,\n    UNICODE_PROP_Changes_When_NFKC_Casefolded,\n    UNICODE_PROP_Changes_When_Titlecased,\n    UNICODE_PROP_Changes_When_Uppercased,\n    UNICODE_PROP_Grapheme_Base,\n    UNICODE_PROP_Grapheme_Extend,\n    UNICODE_PROP_ID_Continue,\n    UNICODE_PROP_Lowercase,\n    UNICODE_PROP_Math,\n    UNICODE_PROP_Uppercase,\n    UNICODE_PROP_XID_Continue,\n    UNICODE_PROP_XID_Start,\n    UNICODE_PROP_Cased1,\n    UNICODE_PROP_COUNT,\n} UnicodePropertyEnum;\n\nstatic const char unicode_prop_name_table[] =\n    \"ASCII_Hex_Digit,AHex\"               \"\\0\"\n    \"Bidi_Control,Bidi_C\"                \"\\0\"\n    \"Dash\"                               \"\\0\"\n    \"Deprecated,Dep\"                     \"\\0\"\n    \"Diacritic,Dia\"                      \"\\0\"\n    \"Extender,Ext\"                       \"\\0\"\n    \"Hex_Digit,Hex\"                      \"\\0\"\n    \"IDS_Binary_Operator,IDSB\"           \"\\0\"\n    \"IDS_Trinary_Operator,IDST\"          \"\\0\"\n    \"Ideographic,Ideo\"                   \"\\0\"\n    \"Join_Control,Join_C\"                \"\\0\"\n    \"Logical_Order_Exception,LOE\"        \"\\0\"\n    \"Noncharacter_Code_Point,NChar\"      \"\\0\"\n    \"Pattern_Syntax,Pat_Syn\"             \"\\0\"\n    \"Pattern_White_Space,Pat_WS\"         \"\\0\"\n    \"Quotation_Mark,QMark\"               \"\\0\"\n    \"Radical\"                            \"\\0\"\n    \"Regional_Indicator,RI\"              \"\\0\"\n    \"Sentence_Terminal,STerm\"            \"\\0\"\n    \"Soft_Dotted,SD\"                     \"\\0\"\n    \"Terminal_Punctuation,Term\"          \"\\0\"\n    \"Unified_Ideograph,UIdeo\"            \"\\0\"\n    \"Variation_Selector,VS\"              \"\\0\"\n    \"White_Space,space\"                  \"\\0\"\n    \"Bidi_Mirrored,Bidi_M\"               \"\\0\"\n    \"Emoji\"                              \"\\0\"\n    \"Emoji_Component,EComp\"              \"\\0\"\n    \"Emoji_Modifier,EMod\"                \"\\0\"\n    \"Emoji_Modifier_Base,EBase\"          \"\\0\"\n    \"Emoji_Presentation,EPres\"           \"\\0\"\n    \"Extended_Pictographic,ExtPict\"      \"\\0\"\n    \"Default_Ignorable_Code_Point,DI\"    \"\\0\"\n    \"ID_Start,IDS\"                       \"\\0\"\n    \"Case_Ignorable,CI\"                  \"\\0\"\n    \"ASCII\"                              \"\\0\"\n    \"Alphabetic,Alpha\"                   \"\\0\"\n    \"Any\"                                \"\\0\"\n    \"Assigned\"                           \"\\0\"\n    \"Cased\"                              \"\\0\"\n    \"Changes_When_Casefolded,CWCF\"       \"\\0\"\n    \"Changes_When_Casemapped,CWCM\"       \"\\0\"\n    \"Changes_When_Lowercased,CWL\"        \"\\0\"\n    \"Changes_When_NFKC_Casefolded,CWKCF\" \"\\0\"\n    \"Changes_When_Titlecased,CWT\"        \"\\0\"\n    \"Changes_When_Uppercased,CWU\"        \"\\0\"\n    \"Grapheme_Base,Gr_Base\"              \"\\0\"\n    \"Grapheme_Extend,Gr_Ext\"             \"\\0\"\n    \"ID_Continue,IDC\"                    \"\\0\"\n    \"Lowercase,Lower\"                    \"\\0\"\n    \"Math\"                               \"\\0\"\n    \"Uppercase,Upper\"                    \"\\0\"\n    \"XID_Continue,XIDC\"                  \"\\0\"\n    \"XID_Start,XIDS\"                     \"\\0\"\n;\n\nstatic const uint8_t * const unicode_prop_table[] = {\n    unicode_prop_Hyphen_table,\n    unicode_prop_Other_Math_table,\n    unicode_prop_Other_Alphabetic_table,\n    unicode_prop_Other_Lowercase_table,\n    unicode_prop_Other_Uppercase_table,\n    unicode_prop_Other_Grapheme_Extend_table,\n    unicode_prop_Other_Default_Ignorable_Code_Point_table,\n    unicode_prop_Other_ID_Start_table,\n    unicode_prop_Other_ID_Continue_table,\n    unicode_prop_Prepended_Concatenation_Mark_table,\n    unicode_prop_ID_Continue1_table,\n    unicode_prop_XID_Start1_table,\n    unicode_prop_XID_Continue1_table,\n    unicode_prop_Changes_When_Titlecased1_table,\n    unicode_prop_Changes_When_Casefolded1_table,\n    unicode_prop_Changes_When_NFKC_Casefolded1_table,\n    unicode_prop_ASCII_Hex_Digit_table,\n    unicode_prop_Bidi_Control_table,\n    unicode_prop_Dash_table,\n    unicode_prop_Deprecated_table,\n    unicode_prop_Diacritic_table,\n    unicode_prop_Extender_table,\n    unicode_prop_Hex_Digit_table,\n    unicode_prop_IDS_Binary_Operator_table,\n    unicode_prop_IDS_Trinary_Operator_table,\n    unicode_prop_Ideographic_table,\n    unicode_prop_Join_Control_table,\n    unicode_prop_Logical_Order_Exception_table,\n    unicode_prop_Noncharacter_Code_Point_table,\n    unicode_prop_Pattern_Syntax_table,\n    unicode_prop_Pattern_White_Space_table,\n    unicode_prop_Quotation_Mark_table,\n    unicode_prop_Radical_table,\n    unicode_prop_Regional_Indicator_table,\n    unicode_prop_Sentence_Terminal_table,\n    unicode_prop_Soft_Dotted_table,\n    unicode_prop_Terminal_Punctuation_table,\n    unicode_prop_Unified_Ideograph_table,\n    unicode_prop_Variation_Selector_table,\n    unicode_prop_White_Space_table,\n    unicode_prop_Bidi_Mirrored_table,\n    unicode_prop_Emoji_table,\n    unicode_prop_Emoji_Component_table,\n    unicode_prop_Emoji_Modifier_table,\n    unicode_prop_Emoji_Modifier_Base_table,\n    unicode_prop_Emoji_Presentation_table,\n    unicode_prop_Extended_Pictographic_table,\n    unicode_prop_Default_Ignorable_Code_Point_table,\n    unicode_prop_ID_Start_table,\n    unicode_prop_Case_Ignorable_table,\n};\n\nstatic const uint16_t unicode_prop_len_table[] = {\n    countof(unicode_prop_Hyphen_table),\n    countof(unicode_prop_Other_Math_table),\n    countof(unicode_prop_Other_Alphabetic_table),\n    countof(unicode_prop_Other_Lowercase_table),\n    countof(unicode_prop_Other_Uppercase_table),\n    countof(unicode_prop_Other_Grapheme_Extend_table),\n    countof(unicode_prop_Other_Default_Ignorable_Code_Point_table),\n    countof(unicode_prop_Other_ID_Start_table),\n    countof(unicode_prop_Other_ID_Continue_table),\n    countof(unicode_prop_Prepended_Concatenation_Mark_table),\n    countof(unicode_prop_ID_Continue1_table),\n    countof(unicode_prop_XID_Start1_table),\n    countof(unicode_prop_XID_Continue1_table),\n    countof(unicode_prop_Changes_When_Titlecased1_table),\n    countof(unicode_prop_Changes_When_Casefolded1_table),\n    countof(unicode_prop_Changes_When_NFKC_Casefolded1_table),\n    countof(unicode_prop_ASCII_Hex_Digit_table),\n    countof(unicode_prop_Bidi_Control_table),\n    countof(unicode_prop_Dash_table),\n    countof(unicode_prop_Deprecated_table),\n    countof(unicode_prop_Diacritic_table),\n    countof(unicode_prop_Extender_table),\n    countof(unicode_prop_Hex_Digit_table),\n    countof(unicode_prop_IDS_Binary_Operator_table),\n    countof(unicode_prop_IDS_Trinary_Operator_table),\n    countof(unicode_prop_Ideographic_table),\n    countof(unicode_prop_Join_Control_table),\n    countof(unicode_prop_Logical_Order_Exception_table),\n    countof(unicode_prop_Noncharacter_Code_Point_table),\n    countof(unicode_prop_Pattern_Syntax_table),\n    countof(unicode_prop_Pattern_White_Space_table),\n    countof(unicode_prop_Quotation_Mark_table),\n    countof(unicode_prop_Radical_table),\n    countof(unicode_prop_Regional_Indicator_table),\n    countof(unicode_prop_Sentence_Terminal_table),\n    countof(unicode_prop_Soft_Dotted_table),\n    countof(unicode_prop_Terminal_Punctuation_table),\n    countof(unicode_prop_Unified_Ideograph_table),\n    countof(unicode_prop_Variation_Selector_table),\n    countof(unicode_prop_White_Space_table),\n    countof(unicode_prop_Bidi_Mirrored_table),\n    countof(unicode_prop_Emoji_table),\n    countof(unicode_prop_Emoji_Component_table),\n    countof(unicode_prop_Emoji_Modifier_table),\n    countof(unicode_prop_Emoji_Modifier_Base_table),\n    countof(unicode_prop_Emoji_Presentation_table),\n    countof(unicode_prop_Extended_Pictographic_table),\n    countof(unicode_prop_Default_Ignorable_Code_Point_table),\n    countof(unicode_prop_ID_Start_table),\n    countof(unicode_prop_Case_Ignorable_table),\n};\n\n#endif /* CONFIG_ALL_UNICODE */\n/* 62 tables / 32261 bytes, 5 index / 345 bytes */\n"
        },
        {
          "name": "libunicode.c",
          "type": "blob",
          "size": 54.9716796875,
          "content": "/*\n * Unicode utilities\n *\n * Copyright (c) 2017-2018 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"cutils.h\"\n#include \"libunicode.h\"\n#include \"libunicode-table.h\"\n\nenum {\n    RUN_TYPE_U,\n    RUN_TYPE_L,\n    RUN_TYPE_UF,\n    RUN_TYPE_LF,\n    RUN_TYPE_UL,\n    RUN_TYPE_LSU,\n    RUN_TYPE_U2L_399_EXT2,\n    RUN_TYPE_UF_D20,\n    RUN_TYPE_UF_D1_EXT,\n    RUN_TYPE_U_EXT,\n    RUN_TYPE_LF_EXT,\n    RUN_TYPE_UF_EXT2,\n    RUN_TYPE_LF_EXT2,\n    RUN_TYPE_UF_EXT3,\n};\n\nstatic int lre_case_conv1(uint32_t c, int conv_type)\n{\n    uint32_t res[LRE_CC_RES_LEN_MAX];\n    lre_case_conv(res, c, conv_type);\n    return res[0];\n}\n\n/* case conversion using the table entry 'idx' with value 'v' */\nstatic int lre_case_conv_entry(uint32_t *res, uint32_t c, int conv_type, uint32_t idx, uint32_t v)\n{\n    uint32_t code, data, type, a, is_lower;\n    is_lower = (conv_type != 0);\n    type = (v >> (32 - 17 - 7 - 4)) & 0xf;\n    data = ((v & 0xf) << 8) | case_conv_table2[idx];\n    code = v >> (32 - 17);\n    switch(type) {\n    case RUN_TYPE_U:\n    case RUN_TYPE_L:\n    case RUN_TYPE_UF:\n    case RUN_TYPE_LF:\n        if (conv_type == (type & 1) ||\n            (type >= RUN_TYPE_UF && conv_type == 2)) {\n            c = c - code + (case_conv_table1[data] >> (32 - 17));\n        }\n        break;\n    case RUN_TYPE_UL:\n        a = c - code;\n        if ((a & 1) != (1 - is_lower))\n            break;\n        c = (a ^ 1) + code;\n        break;\n    case RUN_TYPE_LSU:\n        a = c - code;\n        if (a == 1) {\n            c += 2 * is_lower - 1;\n        } else if (a == (1 - is_lower) * 2) {\n            c += (2 * is_lower - 1) * 2;\n        }\n        break;\n    case RUN_TYPE_U2L_399_EXT2:\n        if (!is_lower) {\n            res[0] = c - code + case_conv_ext[data >> 6];\n            res[1] = 0x399;\n            return 2;\n        } else {\n            c = c - code + case_conv_ext[data & 0x3f];\n        }\n        break;\n    case RUN_TYPE_UF_D20:\n        if (conv_type == 1)\n            break;\n        c = data + (conv_type == 2) * 0x20;\n        break;\n    case RUN_TYPE_UF_D1_EXT:\n        if (conv_type == 1)\n            break;\n        c = case_conv_ext[data] + (conv_type == 2);\n        break;\n    case RUN_TYPE_U_EXT:\n    case RUN_TYPE_LF_EXT:\n        if (is_lower != (type - RUN_TYPE_U_EXT))\n            break;\n        c = case_conv_ext[data];\n        break;\n    case RUN_TYPE_LF_EXT2:\n        if (!is_lower)\n            break;\n        res[0] = c - code + case_conv_ext[data >> 6];\n        res[1] = case_conv_ext[data & 0x3f];\n        return 2;\n    case RUN_TYPE_UF_EXT2:\n        if (conv_type == 1)\n            break;\n        res[0] = c - code + case_conv_ext[data >> 6];\n        res[1] = case_conv_ext[data & 0x3f];\n        if (conv_type == 2) {\n            /* convert to lower */\n            res[0] = lre_case_conv1(res[0], 1);\n            res[1] = lre_case_conv1(res[1], 1);\n        }\n        return 2;\n    default:\n    case RUN_TYPE_UF_EXT3:\n        if (conv_type == 1)\n            break;\n        res[0] = case_conv_ext[data >> 8];\n        res[1] = case_conv_ext[(data >> 4) & 0xf];\n        res[2] = case_conv_ext[data & 0xf];\n        if (conv_type == 2) {\n            /* convert to lower */\n            res[0] = lre_case_conv1(res[0], 1);\n            res[1] = lre_case_conv1(res[1], 1);\n            res[2] = lre_case_conv1(res[2], 1);\n        }\n        return 3;\n    }\n    res[0] = c;\n    return 1;\n}\n\n/* conv_type:\n   0 = to upper\n   1 = to lower\n   2 = case folding (= to lower with modifications)\n*/\nint lre_case_conv(uint32_t *res, uint32_t c, int conv_type)\n{\n    if (c < 128) {\n        if (conv_type) {\n            if (c >= 'A' && c <= 'Z') {\n                c = c - 'A' + 'a';\n            }\n        } else {\n            if (c >= 'a' && c <= 'z') {\n                c = c - 'a' + 'A';\n            }\n        }\n    } else {\n        uint32_t v, code, len;\n        int idx, idx_min, idx_max;\n\n        idx_min = 0;\n        idx_max = countof(case_conv_table1) - 1;\n        while (idx_min <= idx_max) {\n            idx = (unsigned)(idx_max + idx_min) / 2;\n            v = case_conv_table1[idx];\n            code = v >> (32 - 17);\n            len = (v >> (32 - 17 - 7)) & 0x7f;\n            if (c < code) {\n                idx_max = idx - 1;\n            } else if (c >= code + len) {\n                idx_min = idx + 1;\n            } else {\n                return lre_case_conv_entry(res, c, conv_type, idx, v);\n            }\n        }\n    }\n    res[0] = c;\n    return 1;\n}\n\nstatic int lre_case_folding_entry(uint32_t c, uint32_t idx, uint32_t v, BOOL is_unicode)\n{\n    uint32_t res[LRE_CC_RES_LEN_MAX];\n    int len;\n\n    if (is_unicode) {\n        len = lre_case_conv_entry(res, c, 2, idx, v);\n        if (len == 1) {\n            c = res[0];\n        } else {\n            /* handle the few specific multi-character cases (see\n               unicode_gen.c:dump_case_folding_special_cases()) */\n            if (c == 0xfb06) {\n                c = 0xfb05;\n            } else if (c == 0x01fd3) {\n                c = 0x390;\n            } else if (c == 0x01fe3) {\n                c = 0x3b0;\n            }\n        }\n    } else {\n        if (likely(c < 128)) {\n            if (c >= 'a' && c <= 'z')\n                c = c - 'a' + 'A';\n        } else {\n            /* legacy regexp: to upper case if single char >= 128 */\n            len = lre_case_conv_entry(res, c, FALSE, idx, v);\n            if (len == 1 && res[0] >= 128)\n                c = res[0];\n        }\n    }\n    return c;\n}\n\n/* JS regexp specific rules for case folding */\nint lre_canonicalize(uint32_t c, BOOL is_unicode)\n{\n    if (c < 128) {\n        /* fast case */\n        if (is_unicode) {\n            if (c >= 'A' && c <= 'Z') {\n                c = c - 'A' + 'a';\n            }\n        } else {\n            if (c >= 'a' && c <= 'z') {\n                c = c - 'a' + 'A';\n            }\n        }\n    } else {\n        uint32_t v, code, len;\n        int idx, idx_min, idx_max;\n\n        idx_min = 0;\n        idx_max = countof(case_conv_table1) - 1;\n        while (idx_min <= idx_max) {\n            idx = (unsigned)(idx_max + idx_min) / 2;\n            v = case_conv_table1[idx];\n            code = v >> (32 - 17);\n            len = (v >> (32 - 17 - 7)) & 0x7f;\n            if (c < code) {\n                idx_max = idx - 1;\n            } else if (c >= code + len) {\n                idx_min = idx + 1;\n            } else {\n                return lre_case_folding_entry(c, idx, v, is_unicode);\n            }\n        }\n    }\n    return c;\n}\n\nstatic uint32_t get_le24(const uint8_t *ptr)\n{\n    return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16);\n}\n\n#define UNICODE_INDEX_BLOCK_LEN 32\n\n/* return -1 if not in table, otherwise the offset in the block */\nstatic int get_index_pos(uint32_t *pcode, uint32_t c,\n                         const uint8_t *index_table, int index_table_len)\n{\n    uint32_t code, v;\n    int idx_min, idx_max, idx;\n\n    idx_min = 0;\n    v = get_le24(index_table);\n    code = v & ((1 << 21) - 1);\n    if (c < code) {\n        *pcode = 0;\n        return 0;\n    }\n    idx_max = index_table_len - 1;\n    code = get_le24(index_table + idx_max * 3);\n    if (c >= code)\n        return -1;\n    /* invariant: tab[idx_min] <= c < tab2[idx_max] */\n    while ((idx_max - idx_min) > 1) {\n        idx = (idx_max + idx_min) / 2;\n        v = get_le24(index_table + idx * 3);\n        code = v & ((1 << 21) - 1);\n        if (c < code) {\n            idx_max = idx;\n        } else {\n            idx_min = idx;\n        }\n    }\n    v = get_le24(index_table + idx_min * 3);\n    *pcode = v & ((1 << 21) - 1);\n    return (idx_min + 1) * UNICODE_INDEX_BLOCK_LEN + (v >> 21);\n}\n\nstatic BOOL lre_is_in_table(uint32_t c, const uint8_t *table,\n                            const uint8_t *index_table, int index_table_len)\n{\n    uint32_t code, b, bit;\n    int pos;\n    const uint8_t *p;\n\n    pos = get_index_pos(&code, c, index_table, index_table_len);\n    if (pos < 0)\n        return FALSE; /* outside the table */\n    p = table + pos;\n    bit = 0;\n    /* Compressed run length encoding:\n       00..3F: 2 packed lengths: 3-bit + 3-bit\n       40..5F: 5-bits plus extra byte for length\n       60..7F: 5-bits plus 2 extra bytes for length\n       80..FF: 7-bit length\n       lengths must be incremented to get character count\n       Ranges alternate between false and true return value.\n     */\n    for(;;) {\n        b = *p++;\n        if (b < 64) {\n            code += (b >> 3) + 1;\n            if (c < code)\n                return bit;\n            bit ^= 1;\n            code += (b & 7) + 1;\n        } else if (b >= 0x80) {\n            code += b - 0x80 + 1;\n        } else if (b < 0x60) {\n            code += (((b - 0x40) << 8) | p[0]) + 1;\n            p++;\n        } else {\n            code += (((b - 0x60) << 16) | (p[0] << 8) | p[1]) + 1;\n            p += 2;\n        }\n        if (c < code)\n            return bit;\n        bit ^= 1;\n    }\n}\n\nBOOL lre_is_cased(uint32_t c)\n{\n    uint32_t v, code, len;\n    int idx, idx_min, idx_max;\n\n    idx_min = 0;\n    idx_max = countof(case_conv_table1) - 1;\n    while (idx_min <= idx_max) {\n        idx = (unsigned)(idx_max + idx_min) / 2;\n        v = case_conv_table1[idx];\n        code = v >> (32 - 17);\n        len = (v >> (32 - 17 - 7)) & 0x7f;\n        if (c < code) {\n            idx_max = idx - 1;\n        } else if (c >= code + len) {\n            idx_min = idx + 1;\n        } else {\n            return TRUE;\n        }\n    }\n    return lre_is_in_table(c, unicode_prop_Cased1_table,\n                           unicode_prop_Cased1_index,\n                           sizeof(unicode_prop_Cased1_index) / 3);\n}\n\nBOOL lre_is_case_ignorable(uint32_t c)\n{\n    return lre_is_in_table(c, unicode_prop_Case_Ignorable_table,\n                           unicode_prop_Case_Ignorable_index,\n                           sizeof(unicode_prop_Case_Ignorable_index) / 3);\n}\n\n/* character range */\n\nstatic __maybe_unused void cr_dump(CharRange *cr)\n{\n    int i;\n    for(i = 0; i < cr->len; i++)\n        printf(\"%d: 0x%04x\\n\", i, cr->points[i]);\n}\n\nstatic void *cr_default_realloc(void *opaque, void *ptr, size_t size)\n{\n    return realloc(ptr, size);\n}\n\nvoid cr_init(CharRange *cr, void *mem_opaque, DynBufReallocFunc *realloc_func)\n{\n    cr->len = cr->size = 0;\n    cr->points = NULL;\n    cr->mem_opaque = mem_opaque;\n    cr->realloc_func = realloc_func ? realloc_func : cr_default_realloc;\n}\n\nvoid cr_free(CharRange *cr)\n{\n    cr->realloc_func(cr->mem_opaque, cr->points, 0);\n}\n\nint cr_realloc(CharRange *cr, int size)\n{\n    int new_size;\n    uint32_t *new_buf;\n\n    if (size > cr->size) {\n        new_size = max_int(size, cr->size * 3 / 2);\n        new_buf = cr->realloc_func(cr->mem_opaque, cr->points,\n                                   new_size * sizeof(cr->points[0]));\n        if (!new_buf)\n            return -1;\n        cr->points = new_buf;\n        cr->size = new_size;\n    }\n    return 0;\n}\n\nint cr_copy(CharRange *cr, const CharRange *cr1)\n{\n    if (cr_realloc(cr, cr1->len))\n        return -1;\n    memcpy(cr->points, cr1->points, sizeof(cr->points[0]) * cr1->len);\n    cr->len = cr1->len;\n    return 0;\n}\n\n/* merge consecutive intervals and remove empty intervals */\nstatic void cr_compress(CharRange *cr)\n{\n    int i, j, k, len;\n    uint32_t *pt;\n\n    pt = cr->points;\n    len = cr->len;\n    i = 0;\n    j = 0;\n    k = 0;\n    while ((i + 1) < len) {\n        if (pt[i] == pt[i + 1]) {\n            /* empty interval */\n            i += 2;\n        } else {\n            j = i;\n            while ((j + 3) < len && pt[j + 1] == pt[j + 2])\n                j += 2;\n            /* just copy */\n            pt[k] = pt[i];\n            pt[k + 1] = pt[j + 1];\n            k += 2;\n            i = j + 2;\n        }\n    }\n    cr->len = k;\n}\n\n/* union or intersection */\nint cr_op(CharRange *cr, const uint32_t *a_pt, int a_len,\n          const uint32_t *b_pt, int b_len, int op)\n{\n    int a_idx, b_idx, is_in;\n    uint32_t v;\n\n    a_idx = 0;\n    b_idx = 0;\n    for(;;) {\n        /* get one more point from a or b in increasing order */\n        if (a_idx < a_len && b_idx < b_len) {\n            if (a_pt[a_idx] < b_pt[b_idx]) {\n                goto a_add;\n            } else if (a_pt[a_idx] == b_pt[b_idx]) {\n                v = a_pt[a_idx];\n                a_idx++;\n                b_idx++;\n            } else {\n                goto b_add;\n            }\n        } else if (a_idx < a_len) {\n        a_add:\n            v = a_pt[a_idx++];\n        } else if (b_idx < b_len) {\n        b_add:\n            v = b_pt[b_idx++];\n        } else {\n            break;\n        }\n        /* add the point if the in/out status changes */\n        switch(op) {\n        case CR_OP_UNION:\n            is_in = (a_idx & 1) | (b_idx & 1);\n            break;\n        case CR_OP_INTER:\n            is_in = (a_idx & 1) & (b_idx & 1);\n            break;\n        case CR_OP_XOR:\n            is_in = (a_idx & 1) ^ (b_idx & 1);\n            break;\n        default:\n            abort();\n        }\n        if (is_in != (cr->len & 1)) {\n            if (cr_add_point(cr, v))\n                return -1;\n        }\n    }\n    cr_compress(cr);\n    return 0;\n}\n\nint cr_union1(CharRange *cr, const uint32_t *b_pt, int b_len)\n{\n    CharRange a = *cr;\n    int ret;\n    cr->len = 0;\n    cr->size = 0;\n    cr->points = NULL;\n    ret = cr_op(cr, a.points, a.len, b_pt, b_len, CR_OP_UNION);\n    cr_free(&a);\n    return ret;\n}\n\nint cr_invert(CharRange *cr)\n{\n    int len;\n    len = cr->len;\n    if (cr_realloc(cr, len + 2))\n        return -1;\n    memmove(cr->points + 1, cr->points, len * sizeof(cr->points[0]));\n    cr->points[0] = 0;\n    cr->points[len + 1] = UINT32_MAX;\n    cr->len = len + 2;\n    cr_compress(cr);\n    return 0;\n}\n\n#ifdef CONFIG_ALL_UNICODE\n\nBOOL lre_is_id_start(uint32_t c)\n{\n    return lre_is_in_table(c, unicode_prop_ID_Start_table,\n                           unicode_prop_ID_Start_index,\n                           sizeof(unicode_prop_ID_Start_index) / 3);\n}\n\nBOOL lre_is_id_continue(uint32_t c)\n{\n    return lre_is_id_start(c) ||\n        lre_is_in_table(c, unicode_prop_ID_Continue1_table,\n                        unicode_prop_ID_Continue1_index,\n                        sizeof(unicode_prop_ID_Continue1_index) / 3);\n}\n\n#define UNICODE_DECOMP_LEN_MAX 18\n\ntypedef enum {\n    DECOMP_TYPE_C1, /* 16 bit char */\n    DECOMP_TYPE_L1, /* 16 bit char table */\n    DECOMP_TYPE_L2,\n    DECOMP_TYPE_L3,\n    DECOMP_TYPE_L4,\n    DECOMP_TYPE_L5, /* XXX: not used */\n    DECOMP_TYPE_L6, /* XXX: could remove */\n    DECOMP_TYPE_L7, /* XXX: could remove */\n    DECOMP_TYPE_LL1, /* 18 bit char table */\n    DECOMP_TYPE_LL2,\n    DECOMP_TYPE_S1, /* 8 bit char table */\n    DECOMP_TYPE_S2,\n    DECOMP_TYPE_S3,\n    DECOMP_TYPE_S4,\n    DECOMP_TYPE_S5,\n    DECOMP_TYPE_I1, /* increment 16 bit char value */\n    DECOMP_TYPE_I2_0,\n    DECOMP_TYPE_I2_1,\n    DECOMP_TYPE_I3_1,\n    DECOMP_TYPE_I3_2,\n    DECOMP_TYPE_I4_1,\n    DECOMP_TYPE_I4_2,\n    DECOMP_TYPE_B1, /* 16 bit base + 8 bit offset */\n    DECOMP_TYPE_B2,\n    DECOMP_TYPE_B3,\n    DECOMP_TYPE_B4,\n    DECOMP_TYPE_B5,\n    DECOMP_TYPE_B6,\n    DECOMP_TYPE_B7,\n    DECOMP_TYPE_B8,\n    DECOMP_TYPE_B18,\n    DECOMP_TYPE_LS2,\n    DECOMP_TYPE_PAT3,\n    DECOMP_TYPE_S2_UL,\n    DECOMP_TYPE_LS2_UL,\n} DecompTypeEnum;\n\nstatic uint32_t unicode_get_short_code(uint32_t c)\n{\n    static const uint16_t unicode_short_table[2] = { 0x2044, 0x2215 };\n\n    if (c < 0x80)\n        return c;\n    else if (c < 0x80 + 0x50)\n        return c - 0x80 + 0x300;\n    else\n        return unicode_short_table[c - 0x80 - 0x50];\n}\n\nstatic uint32_t unicode_get_lower_simple(uint32_t c)\n{\n    if (c < 0x100 || (c >= 0x410 && c <= 0x42f))\n        c += 0x20;\n    else\n        c++;\n    return c;\n}\n\nstatic uint16_t unicode_get16(const uint8_t *p)\n{\n    return p[0] | (p[1] << 8);\n}\n\nstatic int unicode_decomp_entry(uint32_t *res, uint32_t c,\n                                int idx, uint32_t code, uint32_t len,\n                                uint32_t type)\n{\n    uint32_t c1;\n    int l, i, p;\n    const uint8_t *d;\n\n    if (type == DECOMP_TYPE_C1) {\n        res[0] = unicode_decomp_table2[idx];\n        return 1;\n    } else {\n        d = unicode_decomp_data + unicode_decomp_table2[idx];\n        switch(type) {\n        case DECOMP_TYPE_L1:\n        case DECOMP_TYPE_L2:\n        case DECOMP_TYPE_L3:\n        case DECOMP_TYPE_L4:\n        case DECOMP_TYPE_L5:\n        case DECOMP_TYPE_L6:\n        case DECOMP_TYPE_L7:\n            l = type - DECOMP_TYPE_L1 + 1;\n            d += (c - code) * l * 2;\n            for(i = 0; i < l; i++) {\n                if ((res[i] = unicode_get16(d + 2 * i)) == 0)\n                    return 0;\n            }\n            return l;\n        case DECOMP_TYPE_LL1:\n        case DECOMP_TYPE_LL2:\n            {\n                uint32_t k, p;\n                l = type - DECOMP_TYPE_LL1 + 1;\n                k = (c - code) * l;\n                p = len * l * 2;\n                for(i = 0; i < l; i++) {\n                    c1 = unicode_get16(d + 2 * k) |\n                        (((d[p + (k / 4)] >> ((k % 4) * 2)) & 3) << 16);\n                    if (!c1)\n                        return 0;\n                    res[i] = c1;\n                    k++;\n                }\n            }\n            return l;\n        case DECOMP_TYPE_S1:\n        case DECOMP_TYPE_S2:\n        case DECOMP_TYPE_S3:\n        case DECOMP_TYPE_S4:\n        case DECOMP_TYPE_S5:\n            l = type - DECOMP_TYPE_S1 + 1;\n            d += (c - code) * l;\n            for(i = 0; i < l; i++) {\n                if ((res[i] = unicode_get_short_code(d[i])) == 0)\n                    return 0;\n            }\n            return l;\n        case DECOMP_TYPE_I1:\n            l = 1;\n            p = 0;\n            goto decomp_type_i;\n        case DECOMP_TYPE_I2_0:\n        case DECOMP_TYPE_I2_1:\n        case DECOMP_TYPE_I3_1:\n        case DECOMP_TYPE_I3_2:\n        case DECOMP_TYPE_I4_1:\n        case DECOMP_TYPE_I4_2:\n            l = 2 + ((type - DECOMP_TYPE_I2_0) >> 1);\n            p = ((type - DECOMP_TYPE_I2_0) & 1) + (l > 2);\n        decomp_type_i:\n            for(i = 0; i < l; i++) {\n                c1 = unicode_get16(d + 2 * i);\n                if (i == p)\n                    c1 += c - code;\n                res[i] = c1;\n            }\n            return l;\n        case DECOMP_TYPE_B18:\n            l = 18;\n            goto decomp_type_b;\n        case DECOMP_TYPE_B1:\n        case DECOMP_TYPE_B2:\n        case DECOMP_TYPE_B3:\n        case DECOMP_TYPE_B4:\n        case DECOMP_TYPE_B5:\n        case DECOMP_TYPE_B6:\n        case DECOMP_TYPE_B7:\n        case DECOMP_TYPE_B8:\n            l = type - DECOMP_TYPE_B1 + 1;\n        decomp_type_b:\n            {\n                uint32_t c_min;\n                c_min = unicode_get16(d);\n                d += 2 + (c - code) * l;\n                for(i = 0; i < l; i++) {\n                    c1 = d[i];\n                    if (c1 == 0xff)\n                        c1 = 0x20;\n                    else\n                        c1 += c_min;\n                    res[i] = c1;\n                }\n            }\n            return l;\n        case DECOMP_TYPE_LS2:\n            d += (c - code) * 3;\n            if (!(res[0] = unicode_get16(d)))\n                return 0;\n            res[1] = unicode_get_short_code(d[2]);\n            return 2;\n        case DECOMP_TYPE_PAT3:\n            res[0] = unicode_get16(d);\n            res[2] = unicode_get16(d + 2);\n            d += 4 + (c - code) * 2;\n            res[1] = unicode_get16(d);\n            return 3;\n        case DECOMP_TYPE_S2_UL:\n        case DECOMP_TYPE_LS2_UL:\n            c1 = c - code;\n            if (type == DECOMP_TYPE_S2_UL) {\n                d += c1 & ~1;\n                c = unicode_get_short_code(*d);\n                d++;\n            } else {\n                d += (c1 >> 1) * 3;\n                c = unicode_get16(d);\n                d += 2;\n            }\n            if (c1 & 1)\n                c = unicode_get_lower_simple(c);\n            res[0] = c;\n            res[1] = unicode_get_short_code(*d);\n            return 2;\n        }\n    }\n    return 0;\n}\n\n\n/* return the length of the decomposition (length <=\n   UNICODE_DECOMP_LEN_MAX) or 0 if no decomposition */\nstatic int unicode_decomp_char(uint32_t *res, uint32_t c, BOOL is_compat1)\n{\n    uint32_t v, type, is_compat, code, len;\n    int idx_min, idx_max, idx;\n\n    idx_min = 0;\n    idx_max = countof(unicode_decomp_table1) - 1;\n    while (idx_min <= idx_max) {\n        idx = (idx_max + idx_min) / 2;\n        v = unicode_decomp_table1[idx];\n        code = v >> (32 - 18);\n        len = (v >> (32 - 18 - 7)) & 0x7f;\n        //        printf(\"idx=%d code=%05x len=%d\\n\", idx, code, len);\n        if (c < code) {\n            idx_max = idx - 1;\n        } else if (c >= code + len) {\n            idx_min = idx + 1;\n        } else {\n            is_compat = v & 1;\n            if (is_compat1 < is_compat)\n                break;\n            type = (v >> (32 - 18 - 7 - 6)) & 0x3f;\n            return unicode_decomp_entry(res, c, idx, code, len, type);\n        }\n    }\n    return 0;\n}\n\n/* return 0 if no pair found */\nstatic int unicode_compose_pair(uint32_t c0, uint32_t c1)\n{\n    uint32_t code, len, type, v, idx1, d_idx, d_offset, ch;\n    int idx_min, idx_max, idx, d;\n    uint32_t pair[2];\n\n    idx_min = 0;\n    idx_max = countof(unicode_comp_table) - 1;\n    while (idx_min <= idx_max) {\n        idx = (idx_max + idx_min) / 2;\n        idx1 = unicode_comp_table[idx];\n\n        /* idx1 represent an entry of the decomposition table */\n        d_idx = idx1 >> 6;\n        d_offset = idx1 & 0x3f;\n        v = unicode_decomp_table1[d_idx];\n        code = v >> (32 - 18);\n        len = (v >> (32 - 18 - 7)) & 0x7f;\n        type = (v >> (32 - 18 - 7 - 6)) & 0x3f;\n        ch = code + d_offset;\n        unicode_decomp_entry(pair, ch, d_idx, code, len, type);\n        d = c0 - pair[0];\n        if (d == 0)\n            d = c1 - pair[1];\n        if (d < 0) {\n            idx_max = idx - 1;\n        } else if (d > 0) {\n            idx_min = idx + 1;\n        } else {\n            return ch;\n        }\n    }\n    return 0;\n}\n\n/* return the combining class of character c (between 0 and 255) */\nstatic int unicode_get_cc(uint32_t c)\n{\n    uint32_t code, n, type, cc, c1, b;\n    int pos;\n    const uint8_t *p;\n\n    pos = get_index_pos(&code, c,\n                        unicode_cc_index, sizeof(unicode_cc_index) / 3);\n    if (pos < 0)\n        return 0;\n    p = unicode_cc_table + pos;\n    /* Compressed run length encoding:\n       - 2 high order bits are combining class type\n       -         0:0, 1:230, 2:extra byte linear progression, 3:extra byte\n       - 00..2F: range length (add 1)\n       - 30..37: 3-bit range-length + 1 extra byte\n       - 38..3F: 3-bit range-length + 2 extra byte\n     */\n    for(;;) {\n        b = *p++;\n        type = b >> 6;\n        n = b & 0x3f;\n        if (n < 48) {\n        } else if (n < 56) {\n            n = (n - 48) << 8;\n            n |= *p++;\n            n += 48;\n        } else {\n            n = (n - 56) << 8;\n            n |= *p++ << 8;\n            n |= *p++;\n            n += 48 + (1 << 11);\n        }\n        if (type <= 1)\n            p++;\n        c1 = code + n + 1;\n        if (c < c1) {\n            switch(type) {\n            case 0:\n                cc = p[-1];\n                break;\n            case 1:\n                cc = p[-1] + c - code;\n                break;\n            case 2:\n                cc = 0;\n                break;\n            default:\n            case 3:\n                cc = 230;\n                break;\n            }\n            return cc;\n        }\n        code = c1;\n    }\n}\n\nstatic void sort_cc(int *buf, int len)\n{\n    int i, j, k, cc, cc1, start, ch1;\n\n    for(i = 0; i < len; i++) {\n        cc = unicode_get_cc(buf[i]);\n        if (cc != 0) {\n            start = i;\n            j = i + 1;\n            while (j < len) {\n                ch1 = buf[j];\n                cc1 = unicode_get_cc(ch1);\n                if (cc1 == 0)\n                    break;\n                k = j - 1;\n                while (k >= start) {\n                    if (unicode_get_cc(buf[k]) <= cc1)\n                        break;\n                    buf[k + 1] = buf[k];\n                    k--;\n                }\n                buf[k + 1] = ch1;\n                j++;\n            }\n#if 0\n            printf(\"cc:\");\n            for(k = start; k < j; k++) {\n                printf(\" %3d\", unicode_get_cc(buf[k]));\n            }\n            printf(\"\\n\");\n#endif\n            i = j;\n        }\n    }\n}\n\nstatic void to_nfd_rec(DynBuf *dbuf,\n                       const int *src, int src_len, int is_compat)\n{\n    uint32_t c, v;\n    int i, l;\n    uint32_t res[UNICODE_DECOMP_LEN_MAX];\n\n    for(i = 0; i < src_len; i++) {\n        c = src[i];\n        if (c >= 0xac00 && c < 0xd7a4) {\n            /* Hangul decomposition */\n            c -= 0xac00;\n            dbuf_put_u32(dbuf, 0x1100 + c / 588);\n            dbuf_put_u32(dbuf, 0x1161 + (c % 588) / 28);\n            v = c % 28;\n            if (v != 0)\n                dbuf_put_u32(dbuf, 0x11a7 + v);\n        } else {\n            l = unicode_decomp_char(res, c, is_compat);\n            if (l) {\n                to_nfd_rec(dbuf, (int *)res, l, is_compat);\n            } else {\n                dbuf_put_u32(dbuf, c);\n            }\n        }\n    }\n}\n\n/* return 0 if not found */\nstatic int compose_pair(uint32_t c0, uint32_t c1)\n{\n    /* Hangul composition */\n    if (c0 >= 0x1100 && c0 < 0x1100 + 19 &&\n        c1 >= 0x1161 && c1 < 0x1161 + 21) {\n        return 0xac00 + (c0 - 0x1100) * 588 + (c1 - 0x1161) * 28;\n    } else if (c0 >= 0xac00 && c0 < 0xac00 + 11172 &&\n               (c0 - 0xac00) % 28 == 0 &&\n               c1 >= 0x11a7 && c1 < 0x11a7 + 28) {\n        return c0 + c1 - 0x11a7;\n    } else {\n        return unicode_compose_pair(c0, c1);\n    }\n}\n\nint unicode_normalize(uint32_t **pdst, const uint32_t *src, int src_len,\n                      UnicodeNormalizationEnum n_type,\n                      void *opaque, DynBufReallocFunc *realloc_func)\n{\n    int *buf, buf_len, i, p, starter_pos, cc, last_cc, out_len;\n    BOOL is_compat;\n    DynBuf dbuf_s, *dbuf = &dbuf_s;\n\n    is_compat = n_type >> 1;\n\n    dbuf_init2(dbuf, opaque, realloc_func);\n    if (dbuf_realloc(dbuf, sizeof(int) * src_len))\n        goto fail;\n\n    /* common case: latin1 is unaffected by NFC */\n    if (n_type == UNICODE_NFC) {\n        for(i = 0; i < src_len; i++) {\n            if (src[i] >= 0x100)\n                goto not_latin1;\n        }\n        buf = (int *)dbuf->buf;\n        memcpy(buf, src, src_len * sizeof(int));\n        *pdst = (uint32_t *)buf;\n        return src_len;\n    not_latin1: ;\n    }\n\n    to_nfd_rec(dbuf, (const int *)src, src_len, is_compat);\n    if (dbuf_error(dbuf)) {\n    fail:\n        *pdst = NULL;\n        return -1;\n    }\n    buf = (int *)dbuf->buf;\n    buf_len = dbuf->size / sizeof(int);\n\n    sort_cc(buf, buf_len);\n\n    if (buf_len <= 1 || (n_type & 1) != 0) {\n        /* NFD / NFKD */\n        *pdst = (uint32_t *)buf;\n        return buf_len;\n    }\n\n    i = 1;\n    out_len = 1;\n    while (i < buf_len) {\n        /* find the starter character and test if it is blocked from\n           the character at 'i' */\n        last_cc = unicode_get_cc(buf[i]);\n        starter_pos = out_len - 1;\n        while (starter_pos >= 0) {\n            cc = unicode_get_cc(buf[starter_pos]);\n            if (cc == 0)\n                break;\n            if (cc >= last_cc)\n                goto next;\n            last_cc = 256;\n            starter_pos--;\n        }\n        if (starter_pos >= 0 &&\n            (p = compose_pair(buf[starter_pos], buf[i])) != 0) {\n            buf[starter_pos] = p;\n            i++;\n        } else {\n        next:\n            buf[out_len++] = buf[i++];\n        }\n    }\n    *pdst = (uint32_t *)buf;\n    return out_len;\n}\n\n/* char ranges for various unicode properties */\n\nstatic int unicode_find_name(const char *name_table, const char *name)\n{\n    const char *p, *r;\n    int pos;\n    size_t name_len, len;\n\n    p = name_table;\n    pos = 0;\n    name_len = strlen(name);\n    while (*p) {\n        for(;;) {\n            r = strchr(p, ',');\n            if (!r)\n                len = strlen(p);\n            else\n                len = r - p;\n            if (len == name_len && !memcmp(p, name, name_len))\n                return pos;\n            p += len + 1;\n            if (!r)\n                break;\n        }\n        pos++;\n    }\n    return -1;\n}\n\n/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2\n   if not found */\nint unicode_script(CharRange *cr,\n                   const char *script_name, BOOL is_ext)\n{\n    int script_idx;\n    const uint8_t *p, *p_end;\n    uint32_t c, c1, b, n, v, v_len, i, type;\n    CharRange cr1_s, *cr1;\n    CharRange cr2_s, *cr2 = &cr2_s;\n    BOOL is_common;\n\n    script_idx = unicode_find_name(unicode_script_name_table, script_name);\n    if (script_idx < 0)\n        return -2;\n    /* Note: we remove the \"Unknown\" Script */\n    script_idx += UNICODE_SCRIPT_Unknown + 1;\n\n    is_common = (script_idx == UNICODE_SCRIPT_Common ||\n                 script_idx == UNICODE_SCRIPT_Inherited);\n    if (is_ext) {\n        cr1 = &cr1_s;\n        cr_init(cr1, cr->mem_opaque, cr->realloc_func);\n        cr_init(cr2, cr->mem_opaque, cr->realloc_func);\n    } else {\n        cr1 = cr;\n    }\n\n    p = unicode_script_table;\n    p_end = unicode_script_table + countof(unicode_script_table);\n    c = 0;\n    while (p < p_end) {\n        b = *p++;\n        type = b >> 7;\n        n = b & 0x7f;\n        if (n < 96) {\n        } else if (n < 112) {\n            n = (n - 96) << 8;\n            n |= *p++;\n            n += 96;\n        } else {\n            n = (n - 112) << 16;\n            n |= *p++ << 8;\n            n |= *p++;\n            n += 96 + (1 << 12);\n        }\n        if (type == 0)\n            v = 0;\n        else\n            v = *p++;\n        c1 = c + n + 1;\n        if (v == script_idx) {\n            if (cr_add_interval(cr1, c, c1))\n                goto fail;\n        }\n        c = c1;\n    }\n\n    if (is_ext) {\n        /* add the script extensions */\n        p = unicode_script_ext_table;\n        p_end = unicode_script_ext_table + countof(unicode_script_ext_table);\n        c = 0;\n        while (p < p_end) {\n            b = *p++;\n            if (b < 128) {\n                n = b;\n            } else if (b < 128 + 64) {\n                n = (b - 128) << 8;\n                n |= *p++;\n                n += 128;\n            } else {\n                n = (b - 128 - 64) << 16;\n                n |= *p++ << 8;\n                n |= *p++;\n                n += 128 + (1 << 14);\n            }\n            c1 = c + n + 1;\n            v_len = *p++;\n            if (is_common) {\n                if (v_len != 0) {\n                    if (cr_add_interval(cr2, c, c1))\n                        goto fail;\n                }\n            } else {\n                for(i = 0; i < v_len; i++) {\n                    if (p[i] == script_idx) {\n                        if (cr_add_interval(cr2, c, c1))\n                            goto fail;\n                        break;\n                    }\n                }\n            }\n            p += v_len;\n            c = c1;\n        }\n        if (is_common) {\n            /* remove all the characters with script extensions */\n            if (cr_invert(cr2))\n                goto fail;\n            if (cr_op(cr, cr1->points, cr1->len, cr2->points, cr2->len,\n                      CR_OP_INTER))\n                goto fail;\n        } else {\n            if (cr_op(cr, cr1->points, cr1->len, cr2->points, cr2->len,\n                      CR_OP_UNION))\n                goto fail;\n        }\n        cr_free(cr1);\n        cr_free(cr2);\n    }\n    return 0;\n fail:\n    if (is_ext) {\n        cr_free(cr1);\n        cr_free(cr2);\n    }\n    goto fail;\n}\n\n#define M(id) (1U << UNICODE_GC_ ## id)\n\nstatic int unicode_general_category1(CharRange *cr, uint32_t gc_mask)\n{\n    const uint8_t *p, *p_end;\n    uint32_t c, c0, b, n, v;\n\n    p = unicode_gc_table;\n    p_end = unicode_gc_table + countof(unicode_gc_table);\n    c = 0;\n    /* Compressed range encoding:\n       initial byte:\n       bits 0..4: category number (special case 31)\n       bits 5..7: range length (add 1)\n       special case bits 5..7 == 7: read an extra byte\n       - 00..7F: range length (add 7 + 1)\n       - 80..BF: 6-bits plus extra byte for range length (add 7 + 128)\n       - C0..FF: 6-bits plus 2 extra bytes for range length (add 7 + 128 + 16384)\n     */\n    while (p < p_end) {\n        b = *p++;\n        n = b >> 5;\n        v = b & 0x1f;\n        if (n == 7) {\n            n = *p++;\n            if (n < 128) {\n                n += 7;\n            } else if (n < 128 + 64) {\n                n = (n - 128) << 8;\n                n |= *p++;\n                n += 7 + 128;\n            } else {\n                n = (n - 128 - 64) << 16;\n                n |= *p++ << 8;\n                n |= *p++;\n                n += 7 + 128 + (1 << 14);\n            }\n        }\n        c0 = c;\n        c += n + 1;\n        if (v == 31) {\n            /* run of Lu / Ll */\n            b = gc_mask & (M(Lu) | M(Ll));\n            if (b != 0) {\n                if (b == (M(Lu) | M(Ll))) {\n                    goto add_range;\n                } else {\n                    c0 += ((gc_mask & M(Ll)) != 0);\n                    for(; c0 < c; c0 += 2) {\n                        if (cr_add_interval(cr, c0, c0 + 1))\n                            return -1;\n                    }\n                }\n            }\n        } else if ((gc_mask >> v) & 1) {\n        add_range:\n            if (cr_add_interval(cr, c0, c))\n                return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int unicode_prop1(CharRange *cr, int prop_idx)\n{\n    const uint8_t *p, *p_end;\n    uint32_t c, c0, b, bit;\n\n    p = unicode_prop_table[prop_idx];\n    p_end = p + unicode_prop_len_table[prop_idx];\n    c = 0;\n    bit = 0;\n    /* Compressed range encoding:\n       00..3F: 2 packed lengths: 3-bit + 3-bit\n       40..5F: 5-bits plus extra byte for length\n       60..7F: 5-bits plus 2 extra bytes for length\n       80..FF: 7-bit length\n       lengths must be incremented to get character count\n       Ranges alternate between false and true return value.\n     */\n    while (p < p_end) {\n        c0 = c;\n        b = *p++;\n        if (b < 64) {\n            c += (b >> 3) + 1;\n            if (bit)  {\n                if (cr_add_interval(cr, c0, c))\n                    return -1;\n            }\n            bit ^= 1;\n            c0 = c;\n            c += (b & 7) + 1;\n        } else if (b >= 0x80) {\n            c += b - 0x80 + 1;\n        } else if (b < 0x60) {\n            c += (((b - 0x40) << 8) | p[0]) + 1;\n            p++;\n        } else {\n            c += (((b - 0x60) << 16) | (p[0] << 8) | p[1]) + 1;\n            p += 2;\n        }\n        if (bit)  {\n            if (cr_add_interval(cr, c0, c))\n                return -1;\n        }\n        bit ^= 1;\n    }\n    return 0;\n}\n\n#define CASE_U (1 << 0)\n#define CASE_L (1 << 1)\n#define CASE_F (1 << 2)\n\n/* use the case conversion table to generate range of characters.\n   CASE_U: set char if modified by uppercasing,\n   CASE_L: set char if modified by lowercasing,\n   CASE_F: set char if modified by case folding,\n */\nstatic int unicode_case1(CharRange *cr, int case_mask)\n{\n#define MR(x) (1 << RUN_TYPE_ ## x)\n    const uint32_t tab_run_mask[3] = {\n        MR(U) | MR(UF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(UF_D20) |\n        MR(UF_D1_EXT) | MR(U_EXT) | MR(UF_EXT2) | MR(UF_EXT3),\n\n        MR(L) | MR(LF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(LF_EXT) | MR(LF_EXT2),\n\n        MR(UF) | MR(LF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(LF_EXT) | MR(LF_EXT2) | MR(UF_D20) | MR(UF_D1_EXT) | MR(LF_EXT) | MR(UF_EXT2) | MR(UF_EXT3),\n    };\n#undef MR\n    uint32_t mask, v, code, type, len, i, idx;\n\n    if (case_mask == 0)\n        return 0;\n    mask = 0;\n    for(i = 0; i < 3; i++) {\n        if ((case_mask >> i) & 1)\n            mask |= tab_run_mask[i];\n    }\n    for(idx = 0; idx < countof(case_conv_table1); idx++) {\n        v = case_conv_table1[idx];\n        type = (v >> (32 - 17 - 7 - 4)) & 0xf;\n        code = v >> (32 - 17);\n        len = (v >> (32 - 17 - 7)) & 0x7f;\n        if ((mask >> type) & 1) {\n            //            printf(\"%d: type=%d %04x %04x\\n\", idx, type, code, code + len - 1);\n            switch(type) {\n            case RUN_TYPE_UL:\n                if ((case_mask & CASE_U) && (case_mask & (CASE_L | CASE_F)))\n                    goto def_case;\n                code += ((case_mask & CASE_U) != 0);\n                for(i = 0; i < len; i += 2) {\n                    if (cr_add_interval(cr, code + i, code + i + 1))\n                        return -1;\n                }\n                break;\n            case RUN_TYPE_LSU:\n                if ((case_mask & CASE_U) && (case_mask & (CASE_L | CASE_F)))\n                    goto def_case;\n                if (!(case_mask & CASE_U)) {\n                    if (cr_add_interval(cr, code, code + 1))\n                        return -1;\n                }\n                if (cr_add_interval(cr, code + 1, code + 2))\n                    return -1;\n                if (case_mask & CASE_U) {\n                    if (cr_add_interval(cr, code + 2, code + 3))\n                        return -1;\n                }\n                break;\n            default:\n            def_case:\n                if (cr_add_interval(cr, code, code + len))\n                    return -1;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\nstatic int point_cmp(const void *p1, const void *p2, void *arg)\n{\n    uint32_t v1 = *(uint32_t *)p1;\n    uint32_t v2 = *(uint32_t *)p2;\n    return (v1 > v2) - (v1 < v2);\n}\n\nstatic void cr_sort_and_remove_overlap(CharRange *cr)\n{\n    uint32_t start, end, start1, end1, i, j;\n\n    /* the resulting ranges are not necessarily sorted and may overlap */\n    rqsort(cr->points, cr->len / 2, sizeof(cr->points[0]) * 2, point_cmp, NULL);\n    j = 0;\n    for(i = 0; i < cr->len; ) {\n        start = cr->points[i];\n        end = cr->points[i + 1];\n        i += 2;\n        while (i < cr->len) {\n            start1 = cr->points[i];\n            end1 = cr->points[i + 1];\n            if (start1 > end) {\n                /* |------|\n                 *           |-------| */\n                break;\n            } else if (end1 <= end) {\n                /* |------|\n                 *    |--| */\n                i += 2;\n            } else {\n                /* |------|\n                 *     |-------| */\n                end = end1;\n                i += 2;\n            }\n        }\n        cr->points[j] = start;\n        cr->points[j + 1] = end;\n        j += 2;\n    }\n    cr->len = j;\n}\n\n/* canonicalize a character set using the JS regex case folding rules\n   (see lre_canonicalize()) */\nint cr_regexp_canonicalize(CharRange *cr, BOOL is_unicode)\n{\n    CharRange cr_inter, cr_mask, cr_result, cr_sub;\n    uint32_t v, code, len, i, idx, start, end, c, d_start, d_end, d;\n\n    cr_init(&cr_mask, cr->mem_opaque, cr->realloc_func);\n    cr_init(&cr_inter, cr->mem_opaque, cr->realloc_func);\n    cr_init(&cr_result, cr->mem_opaque, cr->realloc_func);\n    cr_init(&cr_sub, cr->mem_opaque, cr->realloc_func);\n\n    if (unicode_case1(&cr_mask, is_unicode ? CASE_F : CASE_U))\n        goto fail;\n    if (cr_op(&cr_inter, cr_mask.points, cr_mask.len, cr->points, cr->len, CR_OP_INTER))\n        goto fail;\n\n    if (cr_invert(&cr_mask))\n        goto fail;\n    if (cr_op(&cr_sub, cr_mask.points, cr_mask.len, cr->points, cr->len, CR_OP_INTER))\n        goto fail;\n\n    /* cr_inter = cr & cr_mask */\n    /* cr_sub = cr & ~cr_mask */\n\n    /* use the case conversion table to compute the result */\n    d_start = -1;\n    d_end = -1;\n    idx = 0;\n    v = case_conv_table1[idx];\n    code = v >> (32 - 17);\n    len = (v >> (32 - 17 - 7)) & 0x7f;\n    for(i = 0; i < cr_inter.len; i += 2) {\n        start = cr_inter.points[i];\n        end = cr_inter.points[i + 1];\n\n        for(c = start; c < end; c++) {\n            for(;;) {\n                if (c >= code && c < code + len)\n                    break;\n                idx++;\n                assert(idx < countof(case_conv_table1));\n                v = case_conv_table1[idx];\n                code = v >> (32 - 17);\n                len = (v >> (32 - 17 - 7)) & 0x7f;\n            }\n            d = lre_case_folding_entry(c, idx, v, is_unicode);\n            /* try to merge with the current interval */\n            if (d_start == -1) {\n                d_start = d;\n                d_end = d + 1;\n            } else if (d_end == d) {\n                d_end++;\n            } else {\n                cr_add_interval(&cr_result, d_start, d_end);\n                d_start = d;\n                d_end = d + 1;\n            }\n        }\n    }\n    if (d_start != -1) {\n        if (cr_add_interval(&cr_result, d_start, d_end))\n            goto fail;\n    }\n\n    /* the resulting ranges are not necessarily sorted and may overlap */\n    cr_sort_and_remove_overlap(&cr_result);\n\n    /* or with the character not affected by the case folding */\n    cr->len = 0;\n    if (cr_op(cr, cr_result.points, cr_result.len, cr_sub.points, cr_sub.len, CR_OP_UNION))\n        goto fail;\n\n    cr_free(&cr_inter);\n    cr_free(&cr_mask);\n    cr_free(&cr_result);\n    cr_free(&cr_sub);\n    return 0;\n fail:\n    cr_free(&cr_inter);\n    cr_free(&cr_mask);\n    cr_free(&cr_result);\n    cr_free(&cr_sub);\n    return -1;\n}\n\ntypedef enum {\n    POP_GC,\n    POP_PROP,\n    POP_CASE,\n    POP_UNION,\n    POP_INTER,\n    POP_XOR,\n    POP_INVERT,\n    POP_END,\n} PropOPEnum;\n\n#define POP_STACK_LEN_MAX 4\n\nstatic int unicode_prop_ops(CharRange *cr, ...)\n{\n    va_list ap;\n    CharRange stack[POP_STACK_LEN_MAX];\n    int stack_len, op, ret, i;\n    uint32_t a;\n\n    va_start(ap, cr);\n    stack_len = 0;\n    for(;;) {\n        op = va_arg(ap, int);\n        switch(op) {\n        case POP_GC:\n            assert(stack_len < POP_STACK_LEN_MAX);\n            a = va_arg(ap, int);\n            cr_init(&stack[stack_len++], cr->mem_opaque, cr->realloc_func);\n            if (unicode_general_category1(&stack[stack_len - 1], a))\n                goto fail;\n            break;\n        case POP_PROP:\n            assert(stack_len < POP_STACK_LEN_MAX);\n            a = va_arg(ap, int);\n            cr_init(&stack[stack_len++], cr->mem_opaque, cr->realloc_func);\n            if (unicode_prop1(&stack[stack_len - 1], a))\n                goto fail;\n            break;\n        case POP_CASE:\n            assert(stack_len < POP_STACK_LEN_MAX);\n            a = va_arg(ap, int);\n            cr_init(&stack[stack_len++], cr->mem_opaque, cr->realloc_func);\n            if (unicode_case1(&stack[stack_len - 1], a))\n                goto fail;\n            break;\n        case POP_UNION:\n        case POP_INTER:\n        case POP_XOR:\n            {\n                CharRange *cr1, *cr2, *cr3;\n                assert(stack_len >= 2);\n                assert(stack_len < POP_STACK_LEN_MAX);\n                cr1 = &stack[stack_len - 2];\n                cr2 = &stack[stack_len - 1];\n                cr3 = &stack[stack_len++];\n                cr_init(cr3, cr->mem_opaque, cr->realloc_func);\n                if (cr_op(cr3, cr1->points, cr1->len,\n                          cr2->points, cr2->len, op - POP_UNION + CR_OP_UNION))\n                    goto fail;\n                cr_free(cr1);\n                cr_free(cr2);\n                *cr1 = *cr3;\n                stack_len -= 2;\n            }\n            break;\n        case POP_INVERT:\n            assert(stack_len >= 1);\n            if (cr_invert(&stack[stack_len - 1]))\n                goto fail;\n            break;\n        case POP_END:\n            goto done;\n        default:\n            abort();\n        }\n    }\n done:\n    assert(stack_len == 1);\n    ret = cr_copy(cr, &stack[0]);\n    cr_free(&stack[0]);\n    return ret;\n fail:\n    for(i = 0; i < stack_len; i++)\n        cr_free(&stack[i]);\n    return -1;\n}\n\nstatic const uint32_t unicode_gc_mask_table[] = {\n    M(Lu) | M(Ll) | M(Lt), /* LC */\n    M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo), /* L */\n    M(Mn) | M(Mc) | M(Me), /* M */\n    M(Nd) | M(Nl) | M(No), /* N */\n    M(Sm) | M(Sc) | M(Sk) | M(So), /* S */\n    M(Pc) | M(Pd) | M(Ps) | M(Pe) | M(Pi) | M(Pf) | M(Po), /* P */\n    M(Zs) | M(Zl) | M(Zp), /* Z */\n    M(Cc) | M(Cf) | M(Cs) | M(Co) | M(Cn), /* C */\n};\n\n/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2\n   if not found */\nint unicode_general_category(CharRange *cr, const char *gc_name)\n{\n    int gc_idx;\n    uint32_t gc_mask;\n\n    gc_idx = unicode_find_name(unicode_gc_name_table, gc_name);\n    if (gc_idx < 0)\n        return -2;\n    if (gc_idx <= UNICODE_GC_Co) {\n        gc_mask = (uint64_t)1 << gc_idx;\n    } else {\n        gc_mask = unicode_gc_mask_table[gc_idx - UNICODE_GC_LC];\n    }\n    return unicode_general_category1(cr, gc_mask);\n}\n\n\n/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2\n   if not found */\nint unicode_prop(CharRange *cr, const char *prop_name)\n{\n    int prop_idx, ret;\n\n    prop_idx = unicode_find_name(unicode_prop_name_table, prop_name);\n    if (prop_idx < 0)\n        return -2;\n    prop_idx += UNICODE_PROP_ASCII_Hex_Digit;\n\n    ret = 0;\n    switch(prop_idx) {\n    case UNICODE_PROP_ASCII:\n        if (cr_add_interval(cr, 0x00, 0x7f + 1))\n            return -1;\n        break;\n    case UNICODE_PROP_Any:\n        if (cr_add_interval(cr, 0x00000, 0x10ffff + 1))\n            return -1;\n        break;\n    case UNICODE_PROP_Assigned:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Cn),\n                               POP_INVERT,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Math:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Sm),\n                               POP_PROP, UNICODE_PROP_Other_Math,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Lowercase:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Ll),\n                               POP_PROP, UNICODE_PROP_Other_Lowercase,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Uppercase:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu),\n                               POP_PROP, UNICODE_PROP_Other_Uppercase,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Cased:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt),\n                               POP_PROP, UNICODE_PROP_Other_Uppercase,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Other_Lowercase,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Alphabetic:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),\n                               POP_PROP, UNICODE_PROP_Other_Uppercase,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Other_Lowercase,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Other_Alphabetic,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Grapheme_Base:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Cc) | M(Cf) | M(Cs) | M(Co) | M(Cn) | M(Zl) | M(Zp) | M(Me) | M(Mn),\n                               POP_PROP, UNICODE_PROP_Other_Grapheme_Extend,\n                               POP_UNION,\n                               POP_INVERT,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Grapheme_Extend:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Me) | M(Mn),\n                               POP_PROP, UNICODE_PROP_Other_Grapheme_Extend,\n                               POP_UNION,\n                               POP_END);\n        break;\n    case UNICODE_PROP_XID_Start:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),\n                               POP_PROP, UNICODE_PROP_Other_ID_Start,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Pattern_Syntax,\n                               POP_PROP, UNICODE_PROP_Pattern_White_Space,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_XID_Start1,\n                               POP_UNION,\n                               POP_INVERT,\n                               POP_INTER,\n                               POP_END);\n        break;\n    case UNICODE_PROP_XID_Continue:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl) |\n                               M(Mn) | M(Mc) | M(Nd) | M(Pc),\n                               POP_PROP, UNICODE_PROP_Other_ID_Start,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Other_ID_Continue,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Pattern_Syntax,\n                               POP_PROP, UNICODE_PROP_Pattern_White_Space,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_XID_Continue1,\n                               POP_UNION,\n                               POP_INVERT,\n                               POP_INTER,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Changes_When_Uppercased:\n        ret = unicode_case1(cr, CASE_U);\n        break;\n    case UNICODE_PROP_Changes_When_Lowercased:\n        ret = unicode_case1(cr, CASE_L);\n        break;\n    case UNICODE_PROP_Changes_When_Casemapped:\n        ret = unicode_case1(cr, CASE_U | CASE_L | CASE_F);\n        break;\n    case UNICODE_PROP_Changes_When_Titlecased:\n        ret = unicode_prop_ops(cr,\n                               POP_CASE, CASE_U,\n                               POP_PROP, UNICODE_PROP_Changes_When_Titlecased1,\n                               POP_XOR,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Changes_When_Casefolded:\n        ret = unicode_prop_ops(cr,\n                               POP_CASE, CASE_F,\n                               POP_PROP, UNICODE_PROP_Changes_When_Casefolded1,\n                               POP_XOR,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Changes_When_NFKC_Casefolded:\n        ret = unicode_prop_ops(cr,\n                               POP_CASE, CASE_F,\n                               POP_PROP, UNICODE_PROP_Changes_When_NFKC_Casefolded1,\n                               POP_XOR,\n                               POP_END);\n        break;\n#if 0\n    case UNICODE_PROP_ID_Start:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),\n                               POP_PROP, UNICODE_PROP_Other_ID_Start,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Pattern_Syntax,\n                               POP_PROP, UNICODE_PROP_Pattern_White_Space,\n                               POP_UNION,\n                               POP_INVERT,\n                               POP_INTER,\n                               POP_END);\n        break;\n    case UNICODE_PROP_ID_Continue:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl) |\n                               M(Mn) | M(Mc) | M(Nd) | M(Pc),\n                               POP_PROP, UNICODE_PROP_Other_ID_Start,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Other_ID_Continue,\n                               POP_UNION,\n                               POP_PROP, UNICODE_PROP_Pattern_Syntax,\n                               POP_PROP, UNICODE_PROP_Pattern_White_Space,\n                               POP_UNION,\n                               POP_INVERT,\n                               POP_INTER,\n                               POP_END);\n        break;\n    case UNICODE_PROP_Case_Ignorable:\n        ret = unicode_prop_ops(cr,\n                               POP_GC, M(Mn) | M(Cf) | M(Lm) | M(Sk),\n                               POP_PROP, UNICODE_PROP_Case_Ignorable1,\n                               POP_XOR,\n                               POP_END);\n        break;\n#else\n        /* we use the existing tables */\n    case UNICODE_PROP_ID_Continue:\n        ret = unicode_prop_ops(cr,\n                               POP_PROP, UNICODE_PROP_ID_Start,\n                               POP_PROP, UNICODE_PROP_ID_Continue1,\n                               POP_XOR,\n                               POP_END);\n        break;\n#endif\n    default:\n        if (prop_idx >= countof(unicode_prop_table))\n            return -2;\n        ret = unicode_prop1(cr, prop_idx);\n        break;\n    }\n    return ret;\n}\n\n#endif /* CONFIG_ALL_UNICODE */\n\n/*---- lre codepoint categorizing functions ----*/\n\n#define S  UNICODE_C_SPACE\n#define D  UNICODE_C_DIGIT\n#define X  UNICODE_C_XDIGIT\n#define U  UNICODE_C_UPPER\n#define L  UNICODE_C_LOWER\n#define _  UNICODE_C_UNDER\n#define d  UNICODE_C_DOLLAR\n\nuint8_t const lre_ctype_bits[256] = {\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, S, S, S, S, S, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n\n    S, 0, 0, 0, d, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    X|D, X|D, X|D, X|D, X|D, X|D, X|D, X|D,\n    X|D, X|D, 0, 0, 0, 0, 0, 0,\n\n    0, X|U, X|U, X|U, X|U, X|U, X|U, U,\n    U, U, U, U, U, U, U, U,\n    U, U, U, U, U, U, U, U,\n    U, U, U, 0, 0, 0, 0, _,\n\n    0, X|L, X|L, X|L, X|L, X|L, X|L, L,\n    L, L, L, L, L, L, L, L,\n    L, L, L, L, L, L, L, L,\n    L, L, L, 0, 0, 0, 0, 0,\n\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n\n    S, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n};\n\n#undef S\n#undef D\n#undef X\n#undef U\n#undef L\n#undef _\n#undef d\n\n/* code point ranges for Zs,Zl or Zp property */\nstatic const uint16_t char_range_s[] = {\n    10,\n    0x0009, 0x000D + 1,\n    0x0020, 0x0020 + 1,\n    0x00A0, 0x00A0 + 1,\n    0x1680, 0x1680 + 1,\n    0x2000, 0x200A + 1,\n    /* 2028;LINE SEPARATOR;Zl;0;WS;;;;;N;;;;; */\n    /* 2029;PARAGRAPH SEPARATOR;Zp;0;B;;;;;N;;;;; */\n    0x2028, 0x2029 + 1,\n    0x202F, 0x202F + 1,\n    0x205F, 0x205F + 1,\n    0x3000, 0x3000 + 1,\n    /* FEFF;ZERO WIDTH NO-BREAK SPACE;Cf;0;BN;;;;;N;BYTE ORDER MARK;;;; */\n    0xFEFF, 0xFEFF + 1,\n};\n\nBOOL lre_is_space_non_ascii(uint32_t c)\n{\n    size_t i, n;\n\n    n = countof(char_range_s);\n    for(i = 5; i < n; i += 2) {\n        uint32_t low = char_range_s[i];\n        uint32_t high = char_range_s[i + 1];\n        if (c < low)\n            return FALSE;\n        if (c < high)\n            return TRUE;\n    }\n    return FALSE;\n}\n"
        },
        {
          "name": "libunicode.h",
          "type": "blob",
          "size": 5.26171875,
          "content": "/*\n * Unicode utilities\n *\n * Copyright (c) 2017-2018 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#ifndef LIBUNICODE_H\n#define LIBUNICODE_H\n\n#include <stdint.h>\n\n/* define it to include all the unicode tables (40KB larger) */\n#define CONFIG_ALL_UNICODE\n\n#define LRE_CC_RES_LEN_MAX 3\n\n/* char ranges */\n\ntypedef struct {\n    int len; /* in points, always even */\n    int size;\n    uint32_t *points; /* points sorted by increasing value */\n    void *mem_opaque;\n    void *(*realloc_func)(void *opaque, void *ptr, size_t size);\n} CharRange;\n\ntypedef enum {\n    CR_OP_UNION,\n    CR_OP_INTER,\n    CR_OP_XOR,\n} CharRangeOpEnum;\n\nvoid cr_init(CharRange *cr, void *mem_opaque, void *(*realloc_func)(void *opaque, void *ptr, size_t size));\nvoid cr_free(CharRange *cr);\nint cr_realloc(CharRange *cr, int size);\nint cr_copy(CharRange *cr, const CharRange *cr1);\n\nstatic inline int cr_add_point(CharRange *cr, uint32_t v)\n{\n    if (cr->len >= cr->size) {\n        if (cr_realloc(cr, cr->len + 1))\n            return -1;\n    }\n    cr->points[cr->len++] = v;\n    return 0;\n}\n\nstatic inline int cr_add_interval(CharRange *cr, uint32_t c1, uint32_t c2)\n{\n    if ((cr->len + 2) > cr->size) {\n        if (cr_realloc(cr, cr->len + 2))\n            return -1;\n    }\n    cr->points[cr->len++] = c1;\n    cr->points[cr->len++] = c2;\n    return 0;\n}\n\nint cr_union1(CharRange *cr, const uint32_t *b_pt, int b_len);\n\nstatic inline int cr_union_interval(CharRange *cr, uint32_t c1, uint32_t c2)\n{\n    uint32_t b_pt[2];\n    b_pt[0] = c1;\n    b_pt[1] = c2 + 1;\n    return cr_union1(cr, b_pt, 2);\n}\n\nint cr_op(CharRange *cr, const uint32_t *a_pt, int a_len,\n          const uint32_t *b_pt, int b_len, int op);\n\nint cr_invert(CharRange *cr);\n\nint cr_regexp_canonicalize(CharRange *cr, int is_unicode);\n\ntypedef enum {\n    UNICODE_NFC,\n    UNICODE_NFD,\n    UNICODE_NFKC,\n    UNICODE_NFKD,\n} UnicodeNormalizationEnum;\n\nint unicode_normalize(uint32_t **pdst, const uint32_t *src, int src_len,\n                      UnicodeNormalizationEnum n_type,\n                      void *opaque, void *(*realloc_func)(void *opaque, void *ptr, size_t size));\n\n/* Unicode character range functions */\n\nint unicode_script(CharRange *cr, const char *script_name, int is_ext);\nint unicode_general_category(CharRange *cr, const char *gc_name);\nint unicode_prop(CharRange *cr, const char *prop_name);\n\nint lre_case_conv(uint32_t *res, uint32_t c, int conv_type);\nint lre_canonicalize(uint32_t c, int is_unicode);\n\n/* Code point type categories */\nenum {\n    UNICODE_C_SPACE  = (1 << 0),\n    UNICODE_C_DIGIT  = (1 << 1),\n    UNICODE_C_UPPER  = (1 << 2),\n    UNICODE_C_LOWER  = (1 << 3),\n    UNICODE_C_UNDER  = (1 << 4),\n    UNICODE_C_DOLLAR = (1 << 5),\n    UNICODE_C_XDIGIT = (1 << 6),\n};\nextern uint8_t const lre_ctype_bits[256];\n\n/* zero or non-zero return value */\nint lre_is_cased(uint32_t c);\nint lre_is_case_ignorable(uint32_t c);\nint lre_is_id_start(uint32_t c);\nint lre_is_id_continue(uint32_t c);\n\nstatic inline int lre_is_space_byte(uint8_t c) {\n    return lre_ctype_bits[c] & UNICODE_C_SPACE;\n}\n\nstatic inline int lre_is_id_start_byte(uint8_t c) {\n    return lre_ctype_bits[c] & (UNICODE_C_UPPER | UNICODE_C_LOWER |\n                                UNICODE_C_UNDER | UNICODE_C_DOLLAR);\n}\n\nstatic inline int lre_is_id_continue_byte(uint8_t c) {\n    return lre_ctype_bits[c] & (UNICODE_C_UPPER | UNICODE_C_LOWER |\n                                UNICODE_C_UNDER | UNICODE_C_DOLLAR |\n                                UNICODE_C_DIGIT);\n}\n\nint lre_is_space_non_ascii(uint32_t c);\n\nstatic inline int lre_is_space(uint32_t c) {\n    if (c < 256)\n        return lre_is_space_byte(c);\n    else\n        return lre_is_space_non_ascii(c);\n}\n\nstatic inline int lre_js_is_ident_first(uint32_t c) {\n    if (c < 128) {\n        return lre_is_id_start_byte(c);\n    } else {\n#ifdef CONFIG_ALL_UNICODE\n        return lre_is_id_start(c);\n#else\n        return !lre_is_space_non_ascii(c);\n#endif\n    }\n}\n\nstatic inline int lre_js_is_ident_next(uint32_t c) {\n    if (c < 128) {\n        return lre_is_id_continue_byte(c);\n    } else {\n        /* ZWNJ and ZWJ are accepted in identifiers */\n        if (c >= 0x200C && c <= 0x200D)\n            return TRUE;\n#ifdef CONFIG_ALL_UNICODE\n        return lre_is_id_continue(c);\n#else\n        return !lre_is_space_non_ascii(c);\n#endif\n    }\n}\n\n#endif /* LIBUNICODE_H */\n"
        },
        {
          "name": "list.h",
          "type": "blob",
          "size": 3.0166015625,
          "content": "/*\n * Linux klist like system\n *\n * Copyright (c) 2016-2017 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#ifndef LIST_H\n#define LIST_H\n\n#ifndef NULL\n#include <stddef.h>\n#endif\n\nstruct list_head {\n    struct list_head *prev;\n    struct list_head *next;\n};\n\n#define LIST_HEAD_INIT(el) { &(el), &(el) }\n\n/* return the pointer of type 'type *' containing 'el' as field 'member' */\n#define list_entry(el, type, member) container_of(el, type, member)\n\nstatic inline void init_list_head(struct list_head *head)\n{\n    head->prev = head;\n    head->next = head;\n}\n\n/* insert 'el' between 'prev' and 'next' */\nstatic inline void __list_add(struct list_head *el,\n                              struct list_head *prev, struct list_head *next)\n{\n    prev->next = el;\n    el->prev = prev;\n    el->next = next;\n    next->prev = el;\n}\n\n/* add 'el' at the head of the list 'head' (= after element head) */\nstatic inline void list_add(struct list_head *el, struct list_head *head)\n{\n    __list_add(el, head, head->next);\n}\n\n/* add 'el' at the end of the list 'head' (= before element head) */\nstatic inline void list_add_tail(struct list_head *el, struct list_head *head)\n{\n    __list_add(el, head->prev, head);\n}\n\nstatic inline void list_del(struct list_head *el)\n{\n    struct list_head *prev, *next;\n    prev = el->prev;\n    next = el->next;\n    prev->next = next;\n    next->prev = prev;\n    el->prev = NULL; /* fail safe */\n    el->next = NULL; /* fail safe */\n}\n\nstatic inline int list_empty(struct list_head *el)\n{\n    return el->next == el;\n}\n\n#define list_for_each(el, head) \\\n  for(el = (head)->next; el != (head); el = el->next)\n\n#define list_for_each_safe(el, el1, head)                \\\n    for(el = (head)->next, el1 = el->next; el != (head); \\\n        el = el1, el1 = el->next)\n\n#define list_for_each_prev(el, head) \\\n  for(el = (head)->prev; el != (head); el = el->prev)\n\n#define list_for_each_prev_safe(el, el1, head)           \\\n    for(el = (head)->prev, el1 = el->prev; el != (head); \\\n        el = el1, el1 = el->prev)\n\n#endif /* LIST_H */\n"
        },
        {
          "name": "qjs.c",
          "type": "blob",
          "size": 16.341796875,
          "content": "/*\n * QuickJS stand alone interpreter\n *\n * Copyright (c) 2017-2021 Fabrice Bellard\n * Copyright (c) 2017-2021 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <string.h>\n#include <assert.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <time.h>\n#if defined(__APPLE__)\n#include <malloc/malloc.h>\n#elif defined(__linux__) || defined(__GLIBC__)\n#include <malloc.h>\n#elif defined(__FreeBSD__)\n#include <malloc_np.h>\n#endif\n\n#include \"cutils.h\"\n#include \"quickjs-libc.h\"\n\nextern const uint8_t qjsc_repl[];\nextern const uint32_t qjsc_repl_size;\n#ifdef CONFIG_BIGNUM\nextern const uint8_t qjsc_qjscalc[];\nextern const uint32_t qjsc_qjscalc_size;\nstatic int bignum_ext;\n#endif\n\nstatic int eval_buf(JSContext *ctx, const void *buf, int buf_len,\n                    const char *filename, int eval_flags)\n{\n    JSValue val;\n    int ret;\n\n    if ((eval_flags & JS_EVAL_TYPE_MASK) == JS_EVAL_TYPE_MODULE) {\n        /* for the modules, we compile then run to be able to set\n           import.meta */\n        val = JS_Eval(ctx, buf, buf_len, filename,\n                      eval_flags | JS_EVAL_FLAG_COMPILE_ONLY);\n        if (!JS_IsException(val)) {\n            js_module_set_import_meta(ctx, val, TRUE, TRUE);\n            val = JS_EvalFunction(ctx, val);\n        }\n        val = js_std_await(ctx, val);\n    } else {\n        val = JS_Eval(ctx, buf, buf_len, filename, eval_flags);\n    }\n    if (JS_IsException(val)) {\n        js_std_dump_error(ctx);\n        ret = -1;\n    } else {\n        ret = 0;\n    }\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nstatic int eval_file(JSContext *ctx, const char *filename, int module)\n{\n    uint8_t *buf;\n    int ret, eval_flags;\n    size_t buf_len;\n\n    buf = js_load_file(ctx, &buf_len, filename);\n    if (!buf) {\n        perror(filename);\n        exit(1);\n    }\n\n    if (module < 0) {\n        module = (has_suffix(filename, \".mjs\") ||\n                  JS_DetectModule((const char *)buf, buf_len));\n    }\n    if (module)\n        eval_flags = JS_EVAL_TYPE_MODULE;\n    else\n        eval_flags = JS_EVAL_TYPE_GLOBAL;\n    ret = eval_buf(ctx, buf, buf_len, filename, eval_flags);\n    js_free(ctx, buf);\n    return ret;\n}\n\n/* also used to initialize the worker context */\nstatic JSContext *JS_NewCustomContext(JSRuntime *rt)\n{\n    JSContext *ctx;\n    ctx = JS_NewContext(rt);\n    if (!ctx)\n        return NULL;\n#ifdef CONFIG_BIGNUM\n    if (bignum_ext) {\n        JS_AddIntrinsicBigFloat(ctx);\n        JS_AddIntrinsicBigDecimal(ctx);\n        JS_AddIntrinsicOperators(ctx);\n        JS_EnableBignumExt(ctx, TRUE);\n    }\n#endif\n    /* system modules */\n    js_init_module_std(ctx, \"std\");\n    js_init_module_os(ctx, \"os\");\n    return ctx;\n}\n\n#if defined(__APPLE__)\n#define MALLOC_OVERHEAD  0\n#else\n#define MALLOC_OVERHEAD  8\n#endif\n\nstruct trace_malloc_data {\n    uint8_t *base;\n};\n\nstatic inline unsigned long long js_trace_malloc_ptr_offset(uint8_t *ptr,\n                                                struct trace_malloc_data *dp)\n{\n    return ptr - dp->base;\n}\n\n/* default memory allocation functions with memory limitation */\nstatic size_t js_trace_malloc_usable_size(const void *ptr)\n{\n#if defined(__APPLE__)\n    return malloc_size(ptr);\n#elif defined(_WIN32)\n    return _msize((void *)ptr);\n#elif defined(EMSCRIPTEN)\n    return 0;\n#elif defined(__linux__) || defined(__GLIBC__)\n    return malloc_usable_size((void *)ptr);\n#else\n    /* change this to `return 0;` if compilation fails */\n    return malloc_usable_size((void *)ptr);\n#endif\n}\n\nstatic void\n#ifdef _WIN32\n/* mingw printf is used */\n__attribute__((format(gnu_printf, 2, 3)))\n#else\n__attribute__((format(printf, 2, 3)))\n#endif\n    js_trace_malloc_printf(JSMallocState *s, const char *fmt, ...)\n{\n    va_list ap;\n    int c;\n\n    va_start(ap, fmt);\n    while ((c = *fmt++) != '\\0') {\n        if (c == '%') {\n            /* only handle %p and %zd */\n            if (*fmt == 'p') {\n                uint8_t *ptr = va_arg(ap, void *);\n                if (ptr == NULL) {\n                    printf(\"NULL\");\n                } else {\n                    printf(\"H%+06lld.%zd\",\n                           js_trace_malloc_ptr_offset(ptr, s->opaque),\n                           js_trace_malloc_usable_size(ptr));\n                }\n                fmt++;\n                continue;\n            }\n            if (fmt[0] == 'z' && fmt[1] == 'd') {\n                size_t sz = va_arg(ap, size_t);\n                printf(\"%zd\", sz);\n                fmt += 2;\n                continue;\n            }\n        }\n        putc(c, stdout);\n    }\n    va_end(ap);\n}\n\nstatic void js_trace_malloc_init(struct trace_malloc_data *s)\n{\n    free(s->base = malloc(8));\n}\n\nstatic void *js_trace_malloc(JSMallocState *s, size_t size)\n{\n    void *ptr;\n\n    /* Do not allocate zero bytes: behavior is platform dependent */\n    assert(size != 0);\n\n    if (unlikely(s->malloc_size + size > s->malloc_limit))\n        return NULL;\n    ptr = malloc(size);\n    js_trace_malloc_printf(s, \"A %zd -> %p\\n\", size, ptr);\n    if (ptr) {\n        s->malloc_count++;\n        s->malloc_size += js_trace_malloc_usable_size(ptr) + MALLOC_OVERHEAD;\n    }\n    return ptr;\n}\n\nstatic void js_trace_free(JSMallocState *s, void *ptr)\n{\n    if (!ptr)\n        return;\n\n    js_trace_malloc_printf(s, \"F %p\\n\", ptr);\n    s->malloc_count--;\n    s->malloc_size -= js_trace_malloc_usable_size(ptr) + MALLOC_OVERHEAD;\n    free(ptr);\n}\n\nstatic void *js_trace_realloc(JSMallocState *s, void *ptr, size_t size)\n{\n    size_t old_size;\n\n    if (!ptr) {\n        if (size == 0)\n            return NULL;\n        return js_trace_malloc(s, size);\n    }\n    old_size = js_trace_malloc_usable_size(ptr);\n    if (size == 0) {\n        js_trace_malloc_printf(s, \"R %zd %p\\n\", size, ptr);\n        s->malloc_count--;\n        s->malloc_size -= old_size + MALLOC_OVERHEAD;\n        free(ptr);\n        return NULL;\n    }\n    if (s->malloc_size + size - old_size > s->malloc_limit)\n        return NULL;\n\n    js_trace_malloc_printf(s, \"R %zd %p\", size, ptr);\n\n    ptr = realloc(ptr, size);\n    js_trace_malloc_printf(s, \" -> %p\\n\", ptr);\n    if (ptr) {\n        s->malloc_size += js_trace_malloc_usable_size(ptr) - old_size;\n    }\n    return ptr;\n}\n\nstatic const JSMallocFunctions trace_mf = {\n    js_trace_malloc,\n    js_trace_free,\n    js_trace_realloc,\n    js_trace_malloc_usable_size,\n};\n\n#define PROG_NAME \"qjs\"\n\nvoid help(void)\n{\n    printf(\"QuickJS version \" CONFIG_VERSION \"\\n\"\n           \"usage: \" PROG_NAME \" [options] [file [args]]\\n\"\n           \"-h  --help         list options\\n\"\n           \"-e  --eval EXPR    evaluate EXPR\\n\"\n           \"-i  --interactive  go to interactive mode\\n\"\n           \"-m  --module       load as ES6 module (default=autodetect)\\n\"\n           \"    --script       load as ES6 script (default=autodetect)\\n\"\n           \"-I  --include file include an additional file\\n\"\n           \"    --std          make 'std' and 'os' available to the loaded script\\n\"\n#ifdef CONFIG_BIGNUM\n           \"    --bignum       enable the bignum extensions (BigFloat, BigDecimal)\\n\"\n           \"    --qjscalc      load the QJSCalc runtime (default if invoked as qjscalc)\\n\"\n#endif\n           \"-T  --trace        trace memory allocation\\n\"\n           \"-d  --dump         dump the memory usage stats\\n\"\n           \"    --memory-limit n       limit the memory usage to 'n' bytes\\n\"\n           \"    --stack-size n         limit the stack size to 'n' bytes\\n\"\n           \"    --unhandled-rejection  dump unhandled promise rejections\\n\"\n           \"-q  --quit         just instantiate the interpreter and quit\\n\");\n    exit(1);\n}\n\nint main(int argc, char **argv)\n{\n    JSRuntime *rt;\n    JSContext *ctx;\n    struct trace_malloc_data trace_data = { NULL };\n    int optind;\n    char *expr = NULL;\n    int interactive = 0;\n    int dump_memory = 0;\n    int trace_memory = 0;\n    int empty_run = 0;\n    int module = -1;\n    int load_std = 0;\n    int dump_unhandled_promise_rejection = 0;\n    size_t memory_limit = 0;\n    char *include_list[32];\n    int i, include_count = 0;\n#ifdef CONFIG_BIGNUM\n    int load_jscalc;\n#endif\n    size_t stack_size = 0;\n\n#ifdef CONFIG_BIGNUM\n    /* load jscalc runtime if invoked as 'qjscalc' */\n    {\n        const char *p, *exename;\n        exename = argv[0];\n        p = strrchr(exename, '/');\n        if (p)\n            exename = p + 1;\n        load_jscalc = !strcmp(exename, \"qjscalc\");\n    }\n#endif\n\n    /* cannot use getopt because we want to pass the command line to\n       the script */\n    optind = 1;\n    while (optind < argc && *argv[optind] == '-') {\n        char *arg = argv[optind] + 1;\n        const char *longopt = \"\";\n        /* a single - is not an option, it also stops argument scanning */\n        if (!*arg)\n            break;\n        optind++;\n        if (*arg == '-') {\n            longopt = arg + 1;\n            arg += strlen(arg);\n            /* -- stops argument scanning */\n            if (!*longopt)\n                break;\n        }\n        for (; *arg || *longopt; longopt = \"\") {\n            char opt = *arg;\n            if (opt)\n                arg++;\n            if (opt == 'h' || opt == '?' || !strcmp(longopt, \"help\")) {\n                help();\n                continue;\n            }\n            if (opt == 'e' || !strcmp(longopt, \"eval\")) {\n                if (*arg) {\n                    expr = arg;\n                    break;\n                }\n                if (optind < argc) {\n                    expr = argv[optind++];\n                    break;\n                }\n                fprintf(stderr, \"qjs: missing expression for -e\\n\");\n                exit(2);\n            }\n            if (opt == 'I' || !strcmp(longopt, \"include\")) {\n                if (optind >= argc) {\n                    fprintf(stderr, \"expecting filename\");\n                    exit(1);\n                }\n                if (include_count >= countof(include_list)) {\n                    fprintf(stderr, \"too many included files\");\n                    exit(1);\n                }\n                include_list[include_count++] = argv[optind++];\n                continue;\n            }\n            if (opt == 'i' || !strcmp(longopt, \"interactive\")) {\n                interactive++;\n                continue;\n            }\n            if (opt == 'm' || !strcmp(longopt, \"module\")) {\n                module = 1;\n                continue;\n            }\n            if (!strcmp(longopt, \"script\")) {\n                module = 0;\n                continue;\n            }\n            if (opt == 'd' || !strcmp(longopt, \"dump\")) {\n                dump_memory++;\n                continue;\n            }\n            if (opt == 'T' || !strcmp(longopt, \"trace\")) {\n                trace_memory++;\n                continue;\n            }\n            if (!strcmp(longopt, \"std\")) {\n                load_std = 1;\n                continue;\n            }\n            if (!strcmp(longopt, \"unhandled-rejection\")) {\n                dump_unhandled_promise_rejection = 1;\n                continue;\n            }\n#ifdef CONFIG_BIGNUM\n            if (!strcmp(longopt, \"bignum\")) {\n                bignum_ext = 1;\n                continue;\n            }\n            if (!strcmp(longopt, \"qjscalc\")) {\n                load_jscalc = 1;\n                continue;\n            }\n#endif\n            if (opt == 'q' || !strcmp(longopt, \"quit\")) {\n                empty_run++;\n                continue;\n            }\n            if (!strcmp(longopt, \"memory-limit\")) {\n                if (optind >= argc) {\n                    fprintf(stderr, \"expecting memory limit\");\n                    exit(1);\n                }\n                memory_limit = (size_t)strtod(argv[optind++], NULL);\n                continue;\n            }\n            if (!strcmp(longopt, \"stack-size\")) {\n                if (optind >= argc) {\n                    fprintf(stderr, \"expecting stack size\");\n                    exit(1);\n                }\n                stack_size = (size_t)strtod(argv[optind++], NULL);\n                continue;\n            }\n            if (opt) {\n                fprintf(stderr, \"qjs: unknown option '-%c'\\n\", opt);\n            } else {\n                fprintf(stderr, \"qjs: unknown option '--%s'\\n\", longopt);\n            }\n            help();\n        }\n    }\n\n#ifdef CONFIG_BIGNUM\n    if (load_jscalc)\n        bignum_ext = 1;\n#endif\n\n    if (trace_memory) {\n        js_trace_malloc_init(&trace_data);\n        rt = JS_NewRuntime2(&trace_mf, &trace_data);\n    } else {\n        rt = JS_NewRuntime();\n    }\n    if (!rt) {\n        fprintf(stderr, \"qjs: cannot allocate JS runtime\\n\");\n        exit(2);\n    }\n    if (memory_limit != 0)\n        JS_SetMemoryLimit(rt, memory_limit);\n    if (stack_size != 0)\n        JS_SetMaxStackSize(rt, stack_size);\n    js_std_set_worker_new_context_func(JS_NewCustomContext);\n    js_std_init_handlers(rt);\n    ctx = JS_NewCustomContext(rt);\n    if (!ctx) {\n        fprintf(stderr, \"qjs: cannot allocate JS context\\n\");\n        exit(2);\n    }\n\n    /* loader for ES6 modules */\n    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);\n\n    if (dump_unhandled_promise_rejection) {\n        JS_SetHostPromiseRejectionTracker(rt, js_std_promise_rejection_tracker,\n                                          NULL);\n    }\n\n    if (!empty_run) {\n#ifdef CONFIG_BIGNUM\n        if (load_jscalc) {\n            js_std_eval_binary(ctx, qjsc_qjscalc, qjsc_qjscalc_size, 0);\n        }\n#endif\n        js_std_add_helpers(ctx, argc - optind, argv + optind);\n\n        /* make 'std' and 'os' visible to non module code */\n        if (load_std) {\n            const char *str = \"import * as std from 'std';\\n\"\n                \"import * as os from 'os';\\n\"\n                \"globalThis.std = std;\\n\"\n                \"globalThis.os = os;\\n\";\n            eval_buf(ctx, str, strlen(str), \"<input>\", JS_EVAL_TYPE_MODULE);\n        }\n\n        for(i = 0; i < include_count; i++) {\n            if (eval_file(ctx, include_list[i], module))\n                goto fail;\n        }\n\n        if (expr) {\n            if (eval_buf(ctx, expr, strlen(expr), \"<cmdline>\", 0))\n                goto fail;\n        } else\n        if (optind >= argc) {\n            /* interactive mode */\n            interactive = 1;\n        } else {\n            const char *filename;\n            filename = argv[optind];\n            if (eval_file(ctx, filename, module))\n                goto fail;\n        }\n        if (interactive) {\n            js_std_eval_binary(ctx, qjsc_repl, qjsc_repl_size, 0);\n        }\n        js_std_loop(ctx);\n    }\n\n    if (dump_memory) {\n        JSMemoryUsage stats;\n        JS_ComputeMemoryUsage(rt, &stats);\n        JS_DumpMemoryUsage(stdout, &stats, rt);\n    }\n    js_std_free_handlers(rt);\n    JS_FreeContext(ctx);\n    JS_FreeRuntime(rt);\n\n    if (empty_run && dump_memory) {\n        clock_t t[5];\n        double best[5];\n        int i, j;\n        for (i = 0; i < 100; i++) {\n            t[0] = clock();\n            rt = JS_NewRuntime();\n            t[1] = clock();\n            ctx = JS_NewContext(rt);\n            t[2] = clock();\n            JS_FreeContext(ctx);\n            t[3] = clock();\n            JS_FreeRuntime(rt);\n            t[4] = clock();\n            for (j = 4; j > 0; j--) {\n                double ms = 1000.0 * (t[j] - t[j - 1]) / CLOCKS_PER_SEC;\n                if (i == 0 || best[j] > ms)\n                    best[j] = ms;\n            }\n        }\n        printf(\"\\nInstantiation times (ms): %.3f = %.3f+%.3f+%.3f+%.3f\\n\",\n               best[1] + best[2] + best[3] + best[4],\n               best[1], best[2], best[3], best[4]);\n    }\n    return 0;\n fail:\n    js_std_free_handlers(rt);\n    JS_FreeContext(ctx);\n    JS_FreeRuntime(rt);\n    return 1;\n}\n"
        },
        {
          "name": "qjsc.c",
          "type": "blob",
          "size": 21.3994140625,
          "content": "/*\n * QuickJS command line compiler\n *\n * Copyright (c) 2018-2021 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <string.h>\n#include <assert.h>\n#include <unistd.h>\n#include <errno.h>\n#if !defined(_WIN32)\n#include <sys/wait.h>\n#endif\n\n#include \"cutils.h\"\n#include \"quickjs-libc.h\"\n\ntypedef struct {\n    char *name;\n    char *short_name;\n    int flags;\n} namelist_entry_t;\n\ntypedef struct namelist_t {\n    namelist_entry_t *array;\n    int count;\n    int size;\n} namelist_t;\n\ntypedef struct {\n    const char *option_name;\n    const char *init_name;\n} FeatureEntry;\n\nstatic namelist_t cname_list;\nstatic namelist_t cmodule_list;\nstatic namelist_t init_module_list;\nstatic uint64_t feature_bitmap;\nstatic FILE *outfile;\nstatic BOOL byte_swap;\nstatic BOOL dynamic_export;\nstatic const char *c_ident_prefix = \"qjsc_\";\n\n#define FE_ALL (-1)\n\nstatic const FeatureEntry feature_list[] = {\n    { \"date\", \"Date\" },\n    { \"eval\", \"Eval\" },\n    { \"string-normalize\", \"StringNormalize\" },\n    { \"regexp\", \"RegExp\" },\n    { \"json\", \"JSON\" },\n    { \"proxy\", \"Proxy\" },\n    { \"map\", \"MapSet\" },\n    { \"typedarray\", \"TypedArrays\" },\n    { \"promise\", \"Promise\" },\n#define FE_MODULE_LOADER 9\n    { \"module-loader\", NULL },\n    { \"bigint\", \"BigInt\" },\n};\n\nvoid namelist_add(namelist_t *lp, const char *name, const char *short_name,\n                  int flags)\n{\n    namelist_entry_t *e;\n    if (lp->count == lp->size) {\n        size_t newsize = lp->size + (lp->size >> 1) + 4;\n        namelist_entry_t *a =\n            realloc(lp->array, sizeof(lp->array[0]) * newsize);\n        /* XXX: check for realloc failure */\n        lp->array = a;\n        lp->size = newsize;\n    }\n    e =  &lp->array[lp->count++];\n    e->name = strdup(name);\n    if (short_name)\n        e->short_name = strdup(short_name);\n    else\n        e->short_name = NULL;\n    e->flags = flags;\n}\n\nvoid namelist_free(namelist_t *lp)\n{\n    while (lp->count > 0) {\n        namelist_entry_t *e = &lp->array[--lp->count];\n        free(e->name);\n        free(e->short_name);\n    }\n    free(lp->array);\n    lp->array = NULL;\n    lp->size = 0;\n}\n\nnamelist_entry_t *namelist_find(namelist_t *lp, const char *name)\n{\n    int i;\n    for(i = 0; i < lp->count; i++) {\n        namelist_entry_t *e = &lp->array[i];\n        if (!strcmp(e->name, name))\n            return e;\n    }\n    return NULL;\n}\n\nstatic void get_c_name(char *buf, size_t buf_size, const char *file)\n{\n    const char *p, *r;\n    size_t len, i;\n    int c;\n    char *q;\n\n    p = strrchr(file, '/');\n    if (!p)\n        p = file;\n    else\n        p++;\n    r = strrchr(p, '.');\n    if (!r)\n        len = strlen(p);\n    else\n        len = r - p;\n    pstrcpy(buf, buf_size, c_ident_prefix);\n    q = buf + strlen(buf);\n    for(i = 0; i < len; i++) {\n        c = p[i];\n        if (!((c >= '0' && c <= '9') ||\n              (c >= 'A' && c <= 'Z') ||\n              (c >= 'a' && c <= 'z'))) {\n            c = '_';\n        }\n        if ((q - buf) < buf_size - 1)\n            *q++ = c;\n    }\n    *q = '\\0';\n}\n\nstatic void dump_hex(FILE *f, const uint8_t *buf, size_t len)\n{\n    size_t i, col;\n    col = 0;\n    for(i = 0; i < len; i++) {\n        fprintf(f, \" 0x%02x,\", buf[i]);\n        if (++col == 8) {\n            fprintf(f, \"\\n\");\n            col = 0;\n        }\n    }\n    if (col != 0)\n        fprintf(f, \"\\n\");\n}\n\nstatic void output_object_code(JSContext *ctx,\n                               FILE *fo, JSValueConst obj, const char *c_name,\n                               BOOL load_only)\n{\n    uint8_t *out_buf;\n    size_t out_buf_len;\n    int flags;\n    flags = JS_WRITE_OBJ_BYTECODE;\n    if (byte_swap)\n        flags |= JS_WRITE_OBJ_BSWAP;\n    out_buf = JS_WriteObject(ctx, &out_buf_len, obj, flags);\n    if (!out_buf) {\n        js_std_dump_error(ctx);\n        exit(1);\n    }\n\n    namelist_add(&cname_list, c_name, NULL, load_only);\n\n    fprintf(fo, \"const uint32_t %s_size = %u;\\n\\n\",\n            c_name, (unsigned int)out_buf_len);\n    fprintf(fo, \"const uint8_t %s[%u] = {\\n\",\n            c_name, (unsigned int)out_buf_len);\n    dump_hex(fo, out_buf, out_buf_len);\n    fprintf(fo, \"};\\n\\n\");\n\n    js_free(ctx, out_buf);\n}\n\nstatic int js_module_dummy_init(JSContext *ctx, JSModuleDef *m)\n{\n    /* should never be called when compiling JS code */\n    abort();\n}\n\nstatic void find_unique_cname(char *cname, size_t cname_size)\n{\n    char cname1[1024];\n    int suffix_num;\n    size_t len, max_len;\n    assert(cname_size >= 32);\n    /* find a C name not matching an existing module C name by\n       adding a numeric suffix */\n    len = strlen(cname);\n    max_len = cname_size - 16;\n    if (len > max_len)\n        cname[max_len] = '\\0';\n    suffix_num = 1;\n    for(;;) {\n        snprintf(cname1, sizeof(cname1), \"%s_%d\", cname, suffix_num);\n        if (!namelist_find(&cname_list, cname1))\n            break;\n        suffix_num++;\n    }\n    pstrcpy(cname, cname_size, cname1);\n}\n\nJSModuleDef *jsc_module_loader(JSContext *ctx,\n                              const char *module_name, void *opaque)\n{\n    JSModuleDef *m;\n    namelist_entry_t *e;\n\n    /* check if it is a declared C or system module */\n    e = namelist_find(&cmodule_list, module_name);\n    if (e) {\n        /* add in the static init module list */\n        namelist_add(&init_module_list, e->name, e->short_name, 0);\n        /* create a dummy module */\n        m = JS_NewCModule(ctx, module_name, js_module_dummy_init);\n    } else if (has_suffix(module_name, \".so\")) {\n        fprintf(stderr, \"Warning: binary module '%s' will be dynamically loaded\\n\", module_name);\n        /* create a dummy module */\n        m = JS_NewCModule(ctx, module_name, js_module_dummy_init);\n        /* the resulting executable will export its symbols for the\n           dynamic library */\n        dynamic_export = TRUE;\n    } else {\n        size_t buf_len;\n        uint8_t *buf;\n        JSValue func_val;\n        char cname[1024];\n\n        buf = js_load_file(ctx, &buf_len, module_name);\n        if (!buf) {\n            JS_ThrowReferenceError(ctx, \"could not load module filename '%s'\",\n                                   module_name);\n            return NULL;\n        }\n\n        /* compile the module */\n        func_val = JS_Eval(ctx, (char *)buf, buf_len, module_name,\n                           JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);\n        js_free(ctx, buf);\n        if (JS_IsException(func_val))\n            return NULL;\n        get_c_name(cname, sizeof(cname), module_name);\n        if (namelist_find(&cname_list, cname)) {\n            find_unique_cname(cname, sizeof(cname));\n        }\n        output_object_code(ctx, outfile, func_val, cname, TRUE);\n\n        /* the module is already referenced, so we must free it */\n        m = JS_VALUE_GET_PTR(func_val);\n        JS_FreeValue(ctx, func_val);\n    }\n    return m;\n}\n\nstatic void compile_file(JSContext *ctx, FILE *fo,\n                         const char *filename,\n                         const char *c_name1,\n                         int module)\n{\n    uint8_t *buf;\n    char c_name[1024];\n    int eval_flags;\n    JSValue obj;\n    size_t buf_len;\n\n    buf = js_load_file(ctx, &buf_len, filename);\n    if (!buf) {\n        fprintf(stderr, \"Could not load '%s'\\n\", filename);\n        exit(1);\n    }\n    eval_flags = JS_EVAL_FLAG_COMPILE_ONLY;\n    if (module < 0) {\n        module = (has_suffix(filename, \".mjs\") ||\n                  JS_DetectModule((const char *)buf, buf_len));\n    }\n    if (module)\n        eval_flags |= JS_EVAL_TYPE_MODULE;\n    else\n        eval_flags |= JS_EVAL_TYPE_GLOBAL;\n    obj = JS_Eval(ctx, (const char *)buf, buf_len, filename, eval_flags);\n    if (JS_IsException(obj)) {\n        js_std_dump_error(ctx);\n        exit(1);\n    }\n    js_free(ctx, buf);\n    if (c_name1) {\n        pstrcpy(c_name, sizeof(c_name), c_name1);\n    } else {\n        get_c_name(c_name, sizeof(c_name), filename);\n    }\n    output_object_code(ctx, fo, obj, c_name, FALSE);\n    JS_FreeValue(ctx, obj);\n}\n\nstatic const char main_c_template1[] =\n    \"int main(int argc, char **argv)\\n\"\n    \"{\\n\"\n    \"  JSRuntime *rt;\\n\"\n    \"  JSContext *ctx;\\n\"\n    \"  rt = JS_NewRuntime();\\n\"\n    \"  js_std_set_worker_new_context_func(JS_NewCustomContext);\\n\"\n    \"  js_std_init_handlers(rt);\\n\"\n    ;\n\nstatic const char main_c_template2[] =\n    \"  js_std_loop(ctx);\\n\"\n    \"  js_std_free_handlers(rt);\\n\"\n    \"  JS_FreeContext(ctx);\\n\"\n    \"  JS_FreeRuntime(rt);\\n\"\n    \"  return 0;\\n\"\n    \"}\\n\";\n\n#define PROG_NAME \"qjsc\"\n\nvoid help(void)\n{\n    printf(\"QuickJS Compiler version \" CONFIG_VERSION \"\\n\"\n           \"usage: \" PROG_NAME \" [options] [files]\\n\"\n           \"\\n\"\n           \"options are:\\n\"\n           \"-c          only output bytecode to a C file\\n\"\n           \"-e          output main() and bytecode to a C file (default = executable output)\\n\"\n           \"-o output   set the output filename\\n\"\n           \"-N cname    set the C name of the generated data\\n\"\n           \"-m          compile as Javascript module (default=autodetect)\\n\"\n           \"-D module_name         compile a dynamically loaded module or worker\\n\"\n           \"-M module_name[,cname] add initialization code for an external C module\\n\"\n           \"-x          byte swapped output\\n\"\n           \"-p prefix   set the prefix of the generated C names\\n\"\n           \"-S n        set the maximum stack size to 'n' bytes (default=%d)\\n\",\n           JS_DEFAULT_STACK_SIZE);\n#ifdef CONFIG_LTO\n    {\n        int i;\n        printf(\"-flto       use link time optimization\\n\");\n        printf(\"-fbignum    enable bignum extensions\\n\");\n        printf(\"-fno-[\");\n        for(i = 0; i < countof(feature_list); i++) {\n            if (i != 0)\n                printf(\"|\");\n            printf(\"%s\", feature_list[i].option_name);\n        }\n        printf(\"]\\n\"\n               \"            disable selected language features (smaller code size)\\n\");\n    }\n#endif\n    exit(1);\n}\n\n#if defined(CONFIG_CC) && !defined(_WIN32)\n\nint exec_cmd(char **argv)\n{\n    int pid, status, ret;\n\n    pid = fork();\n    if (pid == 0) {\n        execvp(argv[0], argv);\n        exit(1);\n    }\n\n    for(;;) {\n        ret = waitpid(pid, &status, 0);\n        if (ret == pid && WIFEXITED(status))\n            break;\n    }\n    return WEXITSTATUS(status);\n}\n\nstatic int output_executable(const char *out_filename, const char *cfilename,\n                             BOOL use_lto, BOOL verbose, const char *exename)\n{\n    const char *argv[64];\n    const char **arg, *bn_suffix, *lto_suffix;\n    char libjsname[1024];\n    char exe_dir[1024], inc_dir[1024], lib_dir[1024], buf[1024], *p;\n    int ret;\n\n    /* get the directory of the executable */\n    pstrcpy(exe_dir, sizeof(exe_dir), exename);\n    p = strrchr(exe_dir, '/');\n    if (p) {\n        *p = '\\0';\n    } else {\n        pstrcpy(exe_dir, sizeof(exe_dir), \".\");\n    }\n\n    /* if 'quickjs.h' is present at the same path as the executable, we\n       use it as include and lib directory */\n    snprintf(buf, sizeof(buf), \"%s/quickjs.h\", exe_dir);\n    if (access(buf, R_OK) == 0) {\n        pstrcpy(inc_dir, sizeof(inc_dir), exe_dir);\n        pstrcpy(lib_dir, sizeof(lib_dir), exe_dir);\n    } else {\n        snprintf(inc_dir, sizeof(inc_dir), \"%s/include/quickjs\", CONFIG_PREFIX);\n        snprintf(lib_dir, sizeof(lib_dir), \"%s/lib/quickjs\", CONFIG_PREFIX);\n    }\n\n    lto_suffix = \"\";\n    bn_suffix = \"\";\n\n    arg = argv;\n    *arg++ = CONFIG_CC;\n    *arg++ = \"-O2\";\n#ifdef CONFIG_LTO\n    if (use_lto) {\n        *arg++ = \"-flto\";\n        lto_suffix = \".lto\";\n    }\n#endif\n    /* XXX: use the executable path to find the includes files and\n       libraries */\n    *arg++ = \"-D\";\n    *arg++ = \"_GNU_SOURCE\";\n    *arg++ = \"-I\";\n    *arg++ = inc_dir;\n    *arg++ = \"-o\";\n    *arg++ = out_filename;\n    if (dynamic_export)\n        *arg++ = \"-rdynamic\";\n    *arg++ = cfilename;\n    snprintf(libjsname, sizeof(libjsname), \"%s/libquickjs%s%s.a\",\n             lib_dir, bn_suffix, lto_suffix);\n    *arg++ = libjsname;\n    *arg++ = \"-lm\";\n    *arg++ = \"-ldl\";\n    *arg++ = \"-lpthread\";\n    *arg = NULL;\n\n    if (verbose) {\n        for(arg = argv; *arg != NULL; arg++)\n            printf(\"%s \", *arg);\n        printf(\"\\n\");\n    }\n\n    ret = exec_cmd((char **)argv);\n    unlink(cfilename);\n    return ret;\n}\n#else\nstatic int output_executable(const char *out_filename, const char *cfilename,\n                             BOOL use_lto, BOOL verbose, const char *exename)\n{\n    fprintf(stderr, \"Executable output is not supported for this target\\n\");\n    exit(1);\n    return 0;\n}\n#endif\n\n\ntypedef enum {\n    OUTPUT_C,\n    OUTPUT_C_MAIN,\n    OUTPUT_EXECUTABLE,\n} OutputTypeEnum;\n\nint main(int argc, char **argv)\n{\n    int c, i, verbose;\n    const char *out_filename, *cname;\n    char cfilename[1024];\n    FILE *fo;\n    JSRuntime *rt;\n    JSContext *ctx;\n    BOOL use_lto;\n    int module;\n    OutputTypeEnum output_type;\n    size_t stack_size;\n#ifdef CONFIG_BIGNUM\n    BOOL bignum_ext = FALSE;\n#endif\n    namelist_t dynamic_module_list;\n\n    out_filename = NULL;\n    output_type = OUTPUT_EXECUTABLE;\n    cname = NULL;\n    feature_bitmap = FE_ALL;\n    module = -1;\n    byte_swap = FALSE;\n    verbose = 0;\n    use_lto = FALSE;\n    stack_size = 0;\n    memset(&dynamic_module_list, 0, sizeof(dynamic_module_list));\n\n    /* add system modules */\n    namelist_add(&cmodule_list, \"std\", \"std\", 0);\n    namelist_add(&cmodule_list, \"os\", \"os\", 0);\n\n    for(;;) {\n        c = getopt(argc, argv, \"ho:cN:f:mxevM:p:S:D:\");\n        if (c == -1)\n            break;\n        switch(c) {\n        case 'h':\n            help();\n        case 'o':\n            out_filename = optarg;\n            break;\n        case 'c':\n            output_type = OUTPUT_C;\n            break;\n        case 'e':\n            output_type = OUTPUT_C_MAIN;\n            break;\n        case 'N':\n            cname = optarg;\n            break;\n        case 'f':\n            {\n                const char *p;\n                p = optarg;\n                if (!strcmp(optarg, \"lto\")) {\n                    use_lto = TRUE;\n                } else if (strstart(p, \"no-\", &p)) {\n                    use_lto = TRUE;\n                    for(i = 0; i < countof(feature_list); i++) {\n                        if (!strcmp(p, feature_list[i].option_name)) {\n                            feature_bitmap &= ~((uint64_t)1 << i);\n                            break;\n                        }\n                    }\n                    if (i == countof(feature_list))\n                        goto bad_feature;\n                } else\n#ifdef CONFIG_BIGNUM\n                if (!strcmp(optarg, \"bignum\")) {\n                    bignum_ext = TRUE;\n                } else\n#endif\n                {\n                bad_feature:\n                    fprintf(stderr, \"unsupported feature: %s\\n\", optarg);\n                    exit(1);\n                }\n            }\n            break;\n        case 'm':\n            module = 1;\n            break;\n        case 'M':\n            {\n                char *p;\n                char path[1024];\n                char cname[1024];\n                pstrcpy(path, sizeof(path), optarg);\n                p = strchr(path, ',');\n                if (p) {\n                    *p = '\\0';\n                    pstrcpy(cname, sizeof(cname), p + 1);\n                } else {\n                    get_c_name(cname, sizeof(cname), path);\n                }\n                namelist_add(&cmodule_list, path, cname, 0);\n            }\n            break;\n        case 'D':\n            namelist_add(&dynamic_module_list, optarg, NULL, 0);\n            break;\n        case 'x':\n            byte_swap = TRUE;\n            break;\n        case 'v':\n            verbose++;\n            break;\n        case 'p':\n            c_ident_prefix = optarg;\n            break;\n        case 'S':\n            stack_size = (size_t)strtod(optarg, NULL);\n            break;\n        default:\n            break;\n        }\n    }\n\n    if (optind >= argc)\n        help();\n\n    if (!out_filename) {\n        if (output_type == OUTPUT_EXECUTABLE) {\n            out_filename = \"a.out\";\n        } else {\n            out_filename = \"out.c\";\n        }\n    }\n\n    if (output_type == OUTPUT_EXECUTABLE) {\n#if defined(_WIN32) || defined(__ANDROID__)\n        /* XXX: find a /tmp directory ? */\n        snprintf(cfilename, sizeof(cfilename), \"out%d.c\", getpid());\n#else\n        snprintf(cfilename, sizeof(cfilename), \"/tmp/out%d.c\", getpid());\n#endif\n    } else {\n        pstrcpy(cfilename, sizeof(cfilename), out_filename);\n    }\n\n    fo = fopen(cfilename, \"w\");\n    if (!fo) {\n        perror(cfilename);\n        exit(1);\n    }\n    outfile = fo;\n\n    rt = JS_NewRuntime();\n    ctx = JS_NewContext(rt);\n#ifdef CONFIG_BIGNUM\n    if (bignum_ext) {\n        JS_AddIntrinsicBigFloat(ctx);\n        JS_AddIntrinsicBigDecimal(ctx);\n        JS_AddIntrinsicOperators(ctx);\n        JS_EnableBignumExt(ctx, TRUE);\n    }\n#endif\n\n    /* loader for ES6 modules */\n    JS_SetModuleLoaderFunc(rt, NULL, jsc_module_loader, NULL);\n\n    fprintf(fo, \"/* File generated automatically by the QuickJS compiler. */\\n\"\n            \"\\n\"\n            );\n\n    if (output_type != OUTPUT_C) {\n        fprintf(fo, \"#include \\\"quickjs-libc.h\\\"\\n\"\n                \"\\n\"\n                );\n    } else {\n        fprintf(fo, \"#include <inttypes.h>\\n\"\n                \"\\n\"\n                );\n    }\n\n    for(i = optind; i < argc; i++) {\n        const char *filename = argv[i];\n        compile_file(ctx, fo, filename, cname, module);\n        cname = NULL;\n    }\n\n    for(i = 0; i < dynamic_module_list.count; i++) {\n        if (!jsc_module_loader(ctx, dynamic_module_list.array[i].name, NULL)) {\n            fprintf(stderr, \"Could not load dynamic module '%s'\\n\",\n                    dynamic_module_list.array[i].name);\n            exit(1);\n        }\n    }\n\n    if (output_type != OUTPUT_C) {\n        fprintf(fo,\n                \"static JSContext *JS_NewCustomContext(JSRuntime *rt)\\n\"\n                \"{\\n\"\n                \"  JSContext *ctx = JS_NewContextRaw(rt);\\n\"\n                \"  if (!ctx)\\n\"\n                \"    return NULL;\\n\");\n        /* add the basic objects */\n        fprintf(fo, \"  JS_AddIntrinsicBaseObjects(ctx);\\n\");\n        for(i = 0; i < countof(feature_list); i++) {\n            if ((feature_bitmap & ((uint64_t)1 << i)) &&\n                feature_list[i].init_name) {\n                fprintf(fo, \"  JS_AddIntrinsic%s(ctx);\\n\",\n                        feature_list[i].init_name);\n            }\n        }\n#ifdef CONFIG_BIGNUM\n        if (bignum_ext) {\n            fprintf(fo,\n                    \"  JS_AddIntrinsicBigFloat(ctx);\\n\"\n                    \"  JS_AddIntrinsicBigDecimal(ctx);\\n\"\n                    \"  JS_AddIntrinsicOperators(ctx);\\n\"\n                    \"  JS_EnableBignumExt(ctx, 1);\\n\");\n        }\n#endif\n        /* add the precompiled modules (XXX: could modify the module\n           loader instead) */\n        for(i = 0; i < init_module_list.count; i++) {\n            namelist_entry_t *e = &init_module_list.array[i];\n            /* initialize the static C modules */\n\n            fprintf(fo,\n                    \"  {\\n\"\n                    \"    extern JSModuleDef *js_init_module_%s(JSContext *ctx, const char *name);\\n\"\n                    \"    js_init_module_%s(ctx, \\\"%s\\\");\\n\"\n                    \"  }\\n\",\n                    e->short_name, e->short_name, e->name);\n        }\n        for(i = 0; i < cname_list.count; i++) {\n            namelist_entry_t *e = &cname_list.array[i];\n            if (e->flags) {\n                fprintf(fo, \"  js_std_eval_binary(ctx, %s, %s_size, 1);\\n\",\n                        e->name, e->name);\n            }\n        }\n        fprintf(fo,\n                \"  return ctx;\\n\"\n                \"}\\n\\n\");\n\n        fputs(main_c_template1, fo);\n\n        if (stack_size != 0) {\n            fprintf(fo, \"  JS_SetMaxStackSize(rt, %u);\\n\",\n                    (unsigned int)stack_size);\n        }\n\n        /* add the module loader if necessary */\n        if (feature_bitmap & (1 << FE_MODULE_LOADER)) {\n            fprintf(fo, \"  JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);\\n\");\n        }\n\n        fprintf(fo,\n                \"  ctx = JS_NewCustomContext(rt);\\n\"\n                \"  js_std_add_helpers(ctx, argc, argv);\\n\");\n\n        for(i = 0; i < cname_list.count; i++) {\n            namelist_entry_t *e = &cname_list.array[i];\n            if (!e->flags) {\n                fprintf(fo, \"  js_std_eval_binary(ctx, %s, %s_size, 0);\\n\",\n                        e->name, e->name);\n            }\n        }\n        fputs(main_c_template2, fo);\n    }\n\n    JS_FreeContext(ctx);\n    JS_FreeRuntime(rt);\n\n    fclose(fo);\n\n    if (output_type == OUTPUT_EXECUTABLE) {\n        return output_executable(out_filename, cfilename, use_lto, verbose,\n                                 argv[0]);\n    }\n    namelist_free(&cname_list);\n    namelist_free(&cmodule_list);\n    namelist_free(&init_module_list);\n    return 0;\n}\n"
        },
        {
          "name": "qjscalc.js",
          "type": "blob",
          "size": 71.0859375,
          "content": "/*\n * QuickJS Javascript Calculator\n *\n * Copyright (c) 2017-2020 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\"use strict\";\n\"use math\";\n\nvar Integer, Float, Fraction, Complex, Mod, Polynomial, PolyMod, RationalFunction, Series, Matrix;\n\n(function(global) {\n    global.Integer = global.BigInt;\n    global.Float = global.BigFloat;\n    global.algebraicMode = true;\n\n    /* add non enumerable properties */\n    function add_props(obj, props) {\n        var i, val, prop, tab, desc;\n        tab = Reflect.ownKeys(props);\n        for(i = 0; i < tab.length; i++) {\n            prop = tab[i];\n            desc = Object.getOwnPropertyDescriptor(props, prop);\n            desc.enumerable = false;\n            if (\"value\" in desc) {\n                if (typeof desc.value !== \"function\") {\n                    desc.writable = false;\n                    desc.configurable = false;\n                }\n            } else {\n                /* getter/setter */\n                desc.configurable = false;\n            }\n            Object.defineProperty(obj, prop, desc);\n        }\n    }\n\n    /* same as proto[Symbol.operatorSet] = Operators.create(..op_list)\n       but allow shortcuts: left: [], right: [] or both\n    */\n    function operators_set(proto, ...op_list)\n    {\n        var new_op_list, i, a, j, b, k, obj, tab;\n        var fields = [ \"left\", \"right\" ];\n        new_op_list = [];\n        for(i = 0; i < op_list.length; i++) {\n            a = op_list[i];\n            if (a.left || a.right) {\n                tab = [ a.left, a.right ];\n                delete a.left;\n                delete a.right;\n                for(k = 0; k < 2; k++) {\n                    obj = tab[k];\n                    if (obj) {\n                        if (!Array.isArray(obj)) {\n                            obj = [ obj ];\n                        }\n                        for(j = 0; j < obj.length; j++) {\n                            b = {};\n                            Object.assign(b, a);\n                            b[fields[k]] = obj[j];\n                            new_op_list.push(b);\n                        }\n                    }\n                }\n            } else {\n                new_op_list.push(a);\n            }\n        }\n        proto[Symbol.operatorSet] =\n            Operators.create.call(null, ...new_op_list);\n    }\n\n    /* Integer */\n\n    function generic_pow(a, b) {\n        var r, is_neg, i;\n        if (!Integer.isInteger(b)) {\n            return exp(log(a) * b);\n        }\n        if (Array.isArray(a) && !(a instanceof Polynomial ||\n                                  a instanceof Series)) {\n            r = idn(Matrix.check_square(a));\n        } else {\n            r = 1;\n        }\n        if (b == 0)\n            return r;\n        is_neg = false;\n        if (b < 0) {\n            is_neg = true;\n            b = -b;\n        }\n        r = a;\n        for(i = Integer.floorLog2(b) - 1; i >= 0; i--) {\n            r *= r;\n            if ((b >> i) & 1)\n                r *= a;\n        }\n        if (is_neg) {\n            if (typeof r.inverse != \"function\")\n                throw \"negative powers are not supported for this type\";\n            r = r.inverse();\n        }\n        return r;\n    }\n\n    var small_primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499 ];\n\n    function miller_rabin_test(n, t) {\n        var d, r, s, i, j, a;\n        d = n - 1;\n        s = 0;\n        while ((d & 1) == 0) {\n            d >>= 1;\n            s++;\n        }\n        if (small_primes.length < t)\n            t = small_primes.length;\n        loop: for(j = 0; j < t; j++) {\n            a = small_primes[j];\n            r = Integer.pmod(a, d, n);\n            if (r == 1 || r == (n - 1))\n                continue;\n            for(i = 1; i < s; i++) {\n                r = (r * r) % n;\n                if (r == 1)\n                    return false;\n                if (r == (n - 1))\n                    continue loop;\n            }\n            return false; /* n is composite */\n        }\n        return true; /* n is probably prime with probability (1-0.5^t) */\n    }\n\n    function fact_rec(a, b) {  /* assumes a <= b */\n        var i, r;\n        if ((b - a) <= 5) {\n            r = a;\n            for(i = a + 1; i <= b; i++)\n                r *= i;\n            return r;\n        } else {\n            /* to avoid a quadratic running time it is better to\n               multiply numbers of similar size */\n            i = (a + b) >> 1;\n            return fact_rec(a, i) * fact_rec(i + 1, b);\n        }\n    }\n\n    /* math mode specific quirk to overload the integer division and power */\n    Operators.updateBigIntOperators(\n        {\n            \"/\"(a, b) {\n                if (algebraicMode) {\n                    return Fraction.toFraction(a, b);\n                } else {\n                    return Float(a) / Float(b);\n                }\n            },\n            \"**\"(a, b) {\n                if (algebraicMode) {\n                    return generic_pow(a, b);\n                } else {\n                    return Float(a) ** Float(b);\n                }\n            }\n        });\n\n    add_props(Integer, {\n        isInteger(a) {\n            /* integers are represented either as bigint or as number */\n            return typeof a === \"bigint\" ||\n                (typeof a === \"number\" && Number.isSafeInteger(a));\n        },\n        gcd(a, b) {\n            var r;\n            while (b != 0) {\n                r = a % b;\n                a = b;\n                b = r;\n            }\n            return a;\n        },\n        fact(n) {\n            return n <= 0 ? 1 : fact_rec(1, n);\n        },\n        /* binomial coefficient */\n        comb(n, k) {\n            if (k < 0 || k > n)\n                return 0;\n            if (k > n - k)\n                k = n - k;\n            if (k == 0)\n                return 1;\n            return Integer.tdiv(fact_rec(n - k + 1, n), fact_rec(1, k));\n        },\n        /* inverse of x modulo y */\n        invmod(x, y) {\n            var q, u, v, a, c, t;\n            u = x;\n            v = y;\n            c = 1;\n            a = 0;\n            while (u != 0) {\n                t = Integer.fdivrem(v, u);\n                q = t[0];\n                v = u;\n                u = t[1];\n                t = c;\n                c = a - q * c;\n                a = t;\n            }\n            /* v = gcd(x, y) */\n            if (v != 1)\n                throw RangeError(\"not invertible\");\n            return a % y;\n        },\n        /* return a ^ b modulo m */\n        pmod(a, b, m) {\n            var r;\n            if (b == 0)\n                return 1;\n            if (b < 0) {\n                a = Integer.invmod(a, m);\n                b = -b;\n            }\n            r = 1;\n            for(;;) {\n                if (b & 1) {\n                    r = (r * a) % m;\n                }\n                b >>= 1;\n                if (b == 0)\n                    break;\n                a = (a * a) % m;\n            }\n            return r;\n        },\n\n        /* return true if n is prime (or probably prime with\n           probability 1-0.5^t) */\n        isPrime(n, t) {\n            var i, d, n1;\n            if (!Integer.isInteger(n))\n                throw TypeError(\"invalid type\");\n            if (n <= 1)\n                return false;\n            n1 = small_primes.length;\n            /* XXX: need Integer.sqrt() */\n            for(i = 0; i < n1; i++) {\n                d = small_primes[i];\n                if (d == n)\n                    return true;\n                if (d > n)\n                    return false;\n                if ((n % d) == 0)\n                    return false;\n            }\n            if (n < d * d)\n                return true;\n            if (typeof t == \"undefined\")\n                t = 64;\n            return miller_rabin_test(n, t);\n        },\n        nextPrime(n) {\n            if (!Integer.isInteger(n))\n                throw TypeError(\"invalid type\");\n            if (n < 1)\n                n = 1;\n            for(;;) {\n                n++;\n                if (Integer.isPrime(n))\n                    return n;\n            }\n        },\n        factor(n) {\n            var r, d;\n            if (!Integer.isInteger(n))\n                throw TypeError(\"invalid type\");\n            r = [];\n            if (abs(n) <= 1) {\n                r.push(n);\n                return r;\n            }\n            if (n < 0) {\n                r.push(-1);\n                n = -n;\n            }\n\n            while ((n % 2) == 0) {\n                n >>= 1;\n                r.push(2);\n            }\n\n            d = 3;\n            while (n != 1) {\n                if (Integer.isPrime(n)) {\n                    r.push(n);\n                    break;\n                }\n                /* we are sure there is at least one divisor, so one test */\n                for(;;) {\n                    if ((n % d) == 0)\n                        break;\n                    d += 2;\n                }\n                for(;;) {\n                    r.push(d);\n                    n = Integer.tdiv(n, d);\n                    if ((n % d) != 0)\n                        break;\n                }\n            }\n            return r;\n        },\n    });\n\n    add_props(Integer.prototype, {\n        inverse() {\n            return 1 / this;\n        },\n        norm2() {\n            return this * this;\n        },\n        abs() {\n            var v = this;\n            if (v < 0)\n                v = -v;\n            return v;\n        },\n        conj() {\n            return this;\n        },\n        arg() {\n            if (this >= 0)\n                return 0;\n            else\n                return Float.PI;\n        },\n        exp() {\n            if (this == 0)\n                return 1;\n            else\n                return Float.exp(this);\n        },\n        log() {\n            if (this == 1)\n                return 0;\n            else\n                return Float(this).log();\n        },\n    });\n\n    /* Fraction */\n\n    Fraction = function Fraction(a, b)\n    {\n        var d, r, obj;\n\n        if (new.target)\n            throw TypeError(\"not a constructor\");\n        if (a instanceof Fraction)\n            return a;\n        if (!Integer.isInteger(a))\n            throw TypeError(\"integer expected\");\n        if (typeof b === \"undefined\") {\n            b = 1;\n        } else {\n            if (!Integer.isInteger(b))\n                throw TypeError(\"integer expected\");\n            if (b == 0)\n                throw RangeError(\"division by zero\");\n            d = Integer.gcd(a, b);\n            if (d != 1) {\n                a = Integer.tdiv(a, d);\n                b = Integer.tdiv(b, d);\n            }\n\n            /* the fractions are normalized with den > 0 */\n            if (b < 0) {\n                a = -a;\n                b = -b;\n            }\n        }\n        obj = Object.create(Fraction.prototype);\n        obj.num = a;\n        obj.den = b;\n        return obj;\n    }\n\n    function fraction_add(a, b) {\n        a = Fraction(a);\n        b = Fraction(b);\n        return Fraction.toFraction(a.num * b.den + a.den * b.num, a.den * b.den);\n    }\n    function fraction_sub(a, b) {\n        a = Fraction(a);\n        b = Fraction(b);\n        return Fraction.toFraction(a.num * b.den - a.den * b.num, a.den * b.den);\n    }\n    function fraction_mul(a, b) {\n        a = Fraction(a);\n        b = Fraction(b);\n        return Fraction.toFraction(a.num * b.num, a.den * b.den);\n    }\n    function fraction_div(a, b) {\n        a = Fraction(a);\n        b = Fraction(b);\n        return Fraction.toFraction(a.num * b.den, a.den * b.num);\n    }\n    function fraction_mod(a, b) {\n        var a1 = Fraction(a);\n        var b1 = Fraction(b);\n        return a - Integer.ediv(a1.num * b1.den, a1.den * b1.num) * b;\n    }\n    function fraction_eq(a, b) {\n        a = Fraction(a);\n        b = Fraction(b);\n        /* we assume the fractions are normalized */\n        return (a.num == b.num && a.den == b.den);\n    }\n    function fraction_lt(a, b) {\n        a = Fraction(a);\n        b = Fraction(b);\n        return (a.num * b.den < b.num * a.den);\n    }\n\n    /* operators are needed for fractions */\n    function float_add(a, b) {\n        return Float(a) + Float(b);\n    }\n    function float_sub(a, b) {\n        return Float(a) - Float(b);\n    }\n    function float_mul(a, b) {\n        return Float(a) * Float(b);\n    }\n    function float_div(a, b) {\n        return Float(a) / Float(b);\n    }\n    function float_mod(a, b) {\n        return Float(a) % Float(b);\n    }\n    function float_pow(a, b) {\n        return Float(a) ** Float(b);\n    }\n    function float_eq(a, b) {\n        /* XXX: may be better to use infinite precision for the comparison */\n        return Float(a) === Float(b);\n    }\n    function float_lt(a, b) {\n        a = Float(a);\n        b = Float(b);\n        /* XXX: may be better to use infinite precision for the comparison */\n        if (Float.isNaN(a) || Float.isNaN(b))\n            return undefined;\n        else\n            return a < b;\n    }\n\n    operators_set(Fraction.prototype,\n        {\n            \"+\": fraction_add,\n            \"-\": fraction_sub,\n            \"*\": fraction_mul,\n            \"/\": fraction_div,\n            \"%\": fraction_mod,\n            \"**\": generic_pow,\n            \"==\": fraction_eq,\n            \"<\": fraction_lt,\n            \"pos\"(a) {\n                return a;\n            },\n            \"neg\"(a) {\n                return Fraction(-a.num, a.den);\n            },\n        },\n        {\n            left: [Number, BigInt],\n            right: [Number, BigInt],\n            \"+\": fraction_add,\n            \"-\": fraction_sub,\n            \"*\": fraction_mul,\n            \"/\": fraction_div,\n            \"%\": fraction_mod,\n            \"**\": generic_pow,\n            \"==\": fraction_eq,\n            \"<\": fraction_lt,\n        },\n        {\n            left: Float,\n            right: Float,\n            \"+\": float_add,\n            \"-\": float_sub,\n            \"*\": float_mul,\n            \"/\": float_div,\n            \"%\": float_mod,\n            \"**\": float_pow,\n            \"==\": float_eq,\n            \"<\": float_lt,\n        });\n\n    add_props(Fraction, {\n        /* (internal use) simplify 'a' to an integer when possible */\n        toFraction(a, b) {\n            var r = Fraction(a, b);\n            if (algebraicMode && r.den == 1)\n                return r.num;\n            else\n                return r;\n        },\n    });\n\n    add_props(Fraction.prototype, {\n        [Symbol.toPrimitive](hint) {\n            if (hint === \"string\") {\n                return this.toString();\n            } else {\n                return Float(this.num) / this.den;\n            }\n        },\n        inverse() {\n            return Fraction(this.den, this.num);\n        },\n        toString() {\n            return this.num + \"/\" + this.den;\n        },\n        norm2() {\n            return this * this;\n        },\n        abs() {\n            if (this.num < 0)\n                return -this;\n            else\n                return this;\n        },\n        conj() {\n            return this;\n        },\n        arg() {\n            if (this.num >= 0)\n                return 0;\n            else\n                return Float.PI;\n        },\n        exp() {\n            return Float.exp(Float(this));\n        },\n        log() {\n            return Float(this).log();\n        },\n    });\n\n    /* Number (Float64) */\n\n    add_props(Number.prototype, {\n        inverse() {\n            return 1 / this;\n        },\n        norm2() {\n            return this * this;\n        },\n        abs() {\n            return Math.abs(this);\n        },\n        conj() {\n            return this;\n        },\n        arg() {\n            if (this >= 0)\n                return 0;\n            else\n                return Float.PI;\n        },\n        exp() {\n            return Float.exp(this);\n        },\n        log() {\n            if (this < 0) {\n                return Complex(this).log();\n            } else {\n                return Float.log(this);\n            }\n        },\n    });\n\n    /* Float */\n\n    var const_tab = [];\n\n    /* we cache the constants for small precisions */\n    function get_const(n) {\n        var t, c, p;\n        t = const_tab[n];\n        p = BigFloatEnv.prec;\n        if (t && t.prec == p) {\n            return t.val;\n        } else {\n            switch(n) {\n            case 0: c = Float.exp(1); break;\n            case 1: c = Float.log(10); break;\n//            case 2: c = Float.log(2); break;\n            case 3: c = 1/Float.log(2); break;\n            case 4: c = 1/Float.log(10); break;\n//            case 5: c = Float.atan(1) * 4; break;\n            case 6: c = Float.sqrt(0.5); break;\n            case 7: c = Float.sqrt(2); break;\n            }\n            if (p <= 1024) {\n                const_tab[n] = { prec: p, val: c };\n            }\n            return c;\n        }\n    }\n\n    add_props(Float, {\n        isFloat(a) {\n            return typeof a === \"number\" || typeof a === \"bigfloat\";\n        },\n        bestappr(u, b) {\n            var num1, num0, den1, den0, u, num, den, n;\n\n            if (typeof b === \"undefined\")\n                throw TypeError(\"second argument expected\");\n            num1 = 1;\n            num0 = 0;\n            den1 = 0;\n            den0 = 1;\n            for(;;) {\n                n = Integer(Float.floor(u));\n                num = n * num1 + num0;\n                den = n * den1 + den0;\n                if (den > b)\n                    break;\n                u = 1.0 / (u - n);\n                num0 = num1;\n                num1 = num;\n                den0 = den1;\n                den1 = den;\n            }\n            return Fraction(num1, den1);\n        },\n        /* similar constants as Math.x */\n        get E() { return get_const(0); },\n        get LN10() { return get_const(1); },\n//        get LN2() { return get_const(2); },\n        get LOG2E() { return get_const(3); },\n        get LOG10E() { return get_const(4); },\n//        get PI() { return get_const(5); },\n        get SQRT1_2() { return get_const(6); },\n        get SQRT2() { return get_const(7); },\n    });\n\n    add_props(Float.prototype, {\n        inverse() {\n            return 1.0 / this;\n        },\n        norm2() {\n            return this * this;\n        },\n        abs() {\n            return Float.abs(this);\n        },\n        conj() {\n            return this;\n        },\n        arg() {\n            if (this >= 0)\n                return 0;\n            else\n                return Float.PI;\n        },\n        exp() {\n            return Float.exp(this);\n        },\n        log() {\n            if (this < 0) {\n                return Complex(this).log();\n            } else {\n                return Float.log(this);\n            }\n        },\n    });\n\n    /* Complex */\n\n    Complex = function Complex(re, im)\n    {\n        var obj;\n        if (new.target)\n            throw TypeError(\"not a constructor\");\n        if (re instanceof Complex)\n            return re;\n        if (typeof im === \"undefined\") {\n            im = 0;\n        }\n        obj = Object.create(Complex.prototype);\n        obj.re = re;\n        obj.im = im;\n        return obj;\n    }\n\n\n    function complex_add(a, b) {\n        a = Complex(a);\n        b = Complex(b);\n        return Complex.toComplex(a.re + b.re, a.im + b.im);\n    }\n    function complex_sub(a, b) {\n        a = Complex(a);\n        b = Complex(b);\n        return Complex.toComplex(a.re - b.re, a.im - b.im);\n    }\n    function complex_mul(a, b) {\n        a = Complex(a);\n        b = Complex(b);\n        return Complex.toComplex(a.re * b.re - a.im * b.im,\n                                 a.re * b.im + a.im * b.re);\n    }\n    function complex_div(a, b) {\n        a = Complex(a);\n        b = Complex(b);\n        return a * b.inverse();\n    }\n    function complex_eq(a, b) {\n        a = Complex(a);\n        b = Complex(b);\n        return a.re == b.re && a.im == b.im;\n    }\n\n    operators_set(Complex.prototype,\n        {\n            \"+\": complex_add,\n            \"-\": complex_sub,\n            \"*\": complex_mul,\n            \"/\": complex_div,\n            \"**\": generic_pow,\n            \"==\": complex_eq,\n            \"pos\"(a) {\n                return a;\n            },\n            \"neg\"(a) {\n                return Complex(-a.re, -a.im);\n            }\n        },\n        {\n            left: [Number, BigInt, Float, Fraction],\n            right: [Number, BigInt, Float, Fraction],\n            \"+\": complex_add,\n            \"-\": complex_sub,\n            \"*\": complex_mul,\n            \"/\": complex_div,\n            \"**\": generic_pow,\n            \"==\": complex_eq,\n        });\n\n    add_props(Complex, {\n        /* simplify to real number when possible */\n        toComplex(re, im) {\n            if (algebraicMode && im == 0)\n                return re;\n            else\n                return Complex(re, im);\n        },\n    });\n\n    add_props(Complex.prototype, {\n        inverse() {\n            var c = this.norm2();\n            return Complex(this.re / c, -this.im / c);\n        },\n        toString() {\n            var v, s = \"\", a = this;\n            if (a.re != 0)\n                s += a.re.toString();\n            if (a.im == 1) {\n                if (s != \"\")\n                    s += \"+\";\n                s += \"I\";\n            } else if (a.im == -1) {\n                s += \"-I\";\n            } else {\n                v = a.im.toString();\n                if (v[0] != \"-\" && s != \"\")\n                    s += \"+\";\n                s += v + \"*I\";\n            }\n            return s;\n        },\n        norm2() {\n            return this.re * this.re + this.im * this.im;\n        },\n        abs() {\n            return Float.sqrt(norm2(this));\n        },\n        conj() {\n            return Complex(this.re, -this.im);\n        },\n        arg() {\n            return Float.atan2(this.im, this.re);\n        },\n        exp() {\n            var arg = this.im, r = this.re.exp();\n            return Complex(r * cos(arg), r * sin(arg));\n        },\n        log() {\n            return Complex(abs(this).log(), atan2(this.im, this.re));\n        },\n    });\n\n    /* Mod */\n\n    Mod = function Mod(a, m) {\n        var obj, t;\n        if (new.target)\n            throw TypeError(\"not a constructor\");\n        obj = Object.create(Mod.prototype);\n        if (Integer.isInteger(m)) {\n            if (m <= 0)\n                throw RangeError(\"the modulo cannot be <= 0\");\n            if (Integer.isInteger(a)) {\n                a %= m;\n            } else if (a instanceof Fraction) {\n                return Mod(a.num, m) / a.den;\n            } else {\n                throw TypeError(\"invalid types\");\n            }\n        } else {\n            throw TypeError(\"invalid types\");\n        }\n        obj.res = a;\n        obj.mod = m;\n        return obj;\n    };\n\n    function mod_add(a, b) {\n        if (!(a instanceof Mod)) {\n            return Mod(a + b.res, b.mod);\n        } else if (!(b instanceof Mod)) {\n            return Mod(a.res + b, a.mod);\n        } else {\n            if (a.mod != b.mod)\n                throw TypeError(\"different modulo for binary operator\");\n            return Mod(a.res + b.res, a.mod);\n        }\n    }\n    function mod_sub(a, b) {\n        if (!(a instanceof Mod)) {\n            return Mod(a - b.res, b.mod);\n        } else if (!(b instanceof Mod)) {\n            return Mod(a.res - b, a.mod);\n        } else {\n            if (a.mod != b.mod)\n                throw TypeError(\"different modulo for binary operator\");\n            return Mod(a.res - b.res, a.mod);\n        }\n    }\n    function mod_mul(a, b) {\n        if (!(a instanceof Mod)) {\n            return Mod(a * b.res, b.mod);\n        } else if (!(b instanceof Mod)) {\n            return Mod(a.res * b, a.mod);\n        } else {\n            if (a.mod != b.mod)\n                throw TypeError(\"different modulo for binary operator\");\n            return Mod(a.res * b.res, a.mod);\n        }\n    }\n    function mod_div(a, b) {\n        if (!(b instanceof Mod))\n            b = Mod(b, a.mod);\n        return mod_mul(a, b.inverse());\n    }\n    function mod_eq(a, b) {\n        return (a.mod == b.mod && a.res == b.res);\n    }\n\n    operators_set(Mod.prototype,\n        {\n            \"+\": mod_add,\n            \"-\": mod_sub,\n            \"*\": mod_mul,\n            \"/\": mod_div,\n            \"**\": generic_pow,\n            \"==\": mod_eq,\n            \"pos\"(a) {\n                return a;\n            },\n            \"neg\"(a) {\n                return Mod(-a.res, a.mod);\n            }\n        },\n        {\n            left: [Number, BigInt, Float, Fraction],\n            right: [Number, BigInt, Float, Fraction],\n            \"+\": mod_add,\n            \"-\": mod_sub,\n            \"*\": mod_mul,\n            \"/\": mod_div,\n            \"**\": generic_pow,\n        });\n\n    add_props(Mod.prototype, {\n        inverse() {\n            var a = this, m = a.mod;\n            if (Integer.isInteger(m)) {\n                return Mod(Integer.invmod(a.res, m), m);\n            } else {\n                throw TypeError(\"unsupported type\");\n            }\n        },\n        toString() {\n            return \"Mod(\" + this.res + \",\" + this.mod + \")\";\n        },\n    });\n\n    /* Polynomial */\n\n    function polynomial_is_scalar(a)\n    {\n        if (typeof a === \"number\" ||\n            typeof a === \"bigint\" ||\n            typeof a === \"bigfloat\")\n            return true;\n        if (a instanceof Fraction ||\n            a instanceof Complex ||\n            a instanceof Mod)\n            return true;\n        return false;\n    }\n\n    Polynomial = function Polynomial(a)\n    {\n        if (new.target)\n            throw TypeError(\"not a constructor\");\n        if (a instanceof Polynomial) {\n            return a;\n        } else if (Array.isArray(a)) {\n            if (a.length == 0)\n                a = [ 0 ];\n            Object.setPrototypeOf(a, Polynomial.prototype);\n            return a.trim();\n        } else if (polynomial_is_scalar(a)) {\n            a = [a];\n            Object.setPrototypeOf(a, Polynomial.prototype);\n            return a;\n        } else {\n            throw TypeError(\"invalid type\");\n        }\n    }\n\n    function number_need_paren(c)\n    {\n        return !(Integer.isInteger(c) ||\n                 Float.isFloat(c) ||\n                 c instanceof Fraction ||\n                 (c instanceof Complex && c.re == 0));\n    }\n\n    /* string for c*X^i */\n    function monomial_toString(c, i)\n    {\n        var str1;\n        if (i == 0) {\n            str1 = c.toString();\n        } else {\n            if (c == 1) {\n                str1 = \"\";\n            } else if (c == -1) {\n                str1 = \"-\";\n            } else {\n                if (number_need_paren(c)) {\n                    str1 = \"(\" + c + \")\";\n                } else {\n                    str1 = String(c);\n                }\n                str1 += \"*\";\n            }\n            str1 += \"X\";\n            if (i != 1) {\n                str1 += \"^\" + i;\n            }\n        }\n        return str1;\n    }\n\n    /* find one complex root of 'p' starting from z at precision eps using\n       at most max_it iterations. Return null if could not find root. */\n    function poly_root_laguerre1(p, z, max_it)\n    {\n        var p1, p2, i, z0, z1, z2, d, t0, t1, d1, d2, e, el, zl;\n\n        d = p.deg();\n        if (d == 1) {\n            /* monomial case */\n            return -p[0] / p[1];\n        }\n        /* trivial zero */\n        if (p[0] == 0)\n            return 0.0;\n\n        p1 = p.deriv();\n        p2 = p1.deriv();\n        el = 0.0;\n        zl = 0.0;\n        for(i = 0; i < max_it; i++) {\n            z0 = p.apply(z);\n            if (z0 == 0)\n                return z; /* simple exit case */\n\n            /* Ward stopping criteria */\n            e = abs(z - zl);\n//            print(\"e\", i, e);\n            if (i >= 2 && e >= el) {\n                if (abs(zl) < 1e-4) {\n                    if (e < 1e-7)\n                        return zl;\n                } else {\n                    if (e < abs(zl) * 1e-3)\n                        return zl;\n                }\n            }\n            el = e;\n            zl = z;\n\n            z1 = p1.apply(z);\n            z2 = p2.apply(z);\n            t0 = (d - 1) * z1;\n            t0 = t0 * t0;\n            t1 = d * (d - 1) * z0 * z2;\n            t0 = sqrt(t0 - t1);\n            d1 = z1 + t0;\n            d2 = z1 - t0;\n            if (norm2(d2) > norm2(d1))\n                d1 = d2;\n            if (d1 == 0)\n                return null;\n            z = z - d * z0 / d1;\n        }\n        return null;\n    }\n\n    function poly_roots(p)\n    {\n        var d, i, roots, j, z, eps;\n        var start_points = [ 0.1, -1.4, 1.7 ];\n\n        if (!(p instanceof Polynomial))\n            throw TypeError(\"polynomial expected\");\n        d = p.deg();\n        if (d <= 0)\n            return [];\n        eps = 2.0 ^ (-BigFloatEnv.prec);\n        roots = [];\n        for(i = 0; i < d; i++) {\n            /* XXX: should select another start point if error */\n            for(j = 0; j < 3; j++) {\n                z = poly_root_laguerre1(p, start_points[j], 100);\n                if (z !== null)\n                    break;\n            }\n            if (j == 3)\n                throw RangeError(\"error in root finding algorithm\");\n            roots[i] = z;\n            p = Polynomial.divrem(p, X - z)[0];\n        }\n        return roots;\n    }\n\n    add_props(Polynomial.prototype, {\n        trim() {\n            var a = this, i;\n            i = a.length;\n            while (i > 1 && a[i - 1] == 0)\n                i--;\n            a.length = i;\n            return a;\n        },\n        conj() {\n            var r, i, n, a;\n            a = this;\n            n = a.length;\n            r = [];\n            for(i = 0; i < n; i++)\n                r[i] = a[i].conj();\n            return Polynomial(r);\n        },\n        inverse() {\n            return RationalFunction(Polynomial([1]), this);\n        },\n        toString() {\n            var i, str, str1, c, a = this;\n            if (a.length == 1) {\n                return a[0].toString();\n            }\n            str=\"\";\n            for(i = a.length - 1; i >= 0; i--) {\n                c = a[i];\n                if (c == 0 ||\n                    (c instanceof Mod) && c.res == 0)\n                    continue;\n                str1 = monomial_toString(c, i);\n                if (str1[0] != \"-\") {\n                    if (str != \"\")\n                        str += \"+\";\n                }\n                str += str1;\n            }\n            return str;\n        },\n        deg() {\n            if (this.length == 1 && this[0] == 0)\n                return -Infinity;\n            else\n                return this.length - 1;\n        },\n        apply(b) {\n            var i, n, r, a = this;\n            n = a.length - 1;\n            r = a[n];\n            while (n > 0) {\n                n--;\n                r = r * b + a[n];\n            }\n            return r;\n        },\n        deriv() {\n            var a = this, n, r, i;\n            n = a.length;\n            if (n == 1) {\n                return Polynomial(0);\n            } else {\n                r = [];\n                for(i = 1; i < n; i++) {\n                    r[i - 1] = i * a[i];\n                }\n                return Polynomial(r);\n            }\n        },\n        integ() {\n            var a = this, n, r, i;\n            n = a.length;\n            r = [0];\n            for(i = 0; i < n; i++) {\n                r[i + 1] = a[i] / (i + 1);\n            }\n            return Polynomial(r);\n        },\n        norm2() {\n            var a = this, n, r, i;\n            n = a.length;\n            r = 0;\n            for(i = 0; i < n; i++) {\n                r += a[i].norm2();\n            }\n            return r;\n        },\n    });\n\n\n    function polynomial_add(a, b) {\n        var tmp, r, i, n1, n2;\n        a = Polynomial(a);\n        b = Polynomial(b);\n        if (a.length < b.length) {\n            tmp = a;\n            a = b;\n            b = tmp;\n        }\n        n1 = b.length;\n        n2 = a.length;\n        r = [];\n        for(i = 0; i < n1; i++)\n            r[i] = a[i] + b[i];\n        for(i = n1; i < n2; i++)\n            r[i] = a[i];\n        return Polynomial(r);\n    }\n    function polynomial_sub(a, b) {\n        return polynomial_add(a, -b);\n    }\n    function polynomial_mul(a, b) {\n        var i, j, n1, n2, n, r;\n        a = Polynomial(a);\n        b = Polynomial(b);\n        n1 = a.length;\n        n2 = b.length;\n        n = n1 + n2 - 1;\n        r = [];\n        for(i = 0; i < n; i++)\n            r[i] = 0;\n        for(i = 0; i < n1; i++) {\n            for(j = 0; j < n2; j++) {\n                r[i + j] += a[i] * b[j];\n            }\n        }\n        return Polynomial(r);\n    }\n    function polynomial_div_scalar(a, b) {\n        return a * (1 / b);\n    }\n    function polynomial_div(a, b)\n    {\n        return RationalFunction(Polynomial(a),\n                                Polynomial(b));\n    }\n    function polynomial_mod(a, b) {\n        return Polynomial.divrem(a, b)[1];\n    }\n    function polynomial_eq(a, b) {\n        var n, i;\n        n = a.length;\n        if (n != b.length)\n            return false;\n        for(i = 0; i < n; i++) {\n            if (a[i] != b[i])\n                return false;\n        }\n        return true;\n    }\n\n    operators_set(Polynomial.prototype,\n        {\n            \"+\": polynomial_add,\n            \"-\": polynomial_sub,\n            \"*\": polynomial_mul,\n            \"/\": polynomial_div,\n            \"**\": generic_pow,\n            \"==\": polynomial_eq,\n            \"pos\"(a) {\n                return a;\n            },\n            \"neg\"(a) {\n                var r, i, n, a;\n                n = a.length;\n                r = [];\n                for(i = 0; i < n; i++)\n                r[i] = -a[i];\n                return Polynomial(r);\n            },\n        },\n        {\n            left: [Number, BigInt, Float, Fraction, Complex, Mod],\n            \"+\": polynomial_add,\n            \"-\": polynomial_sub,\n            \"*\": polynomial_mul,\n            \"/\": polynomial_div,\n            \"**\": generic_pow, /* XXX: only for integer */\n        },\n        {\n            right: [Number, BigInt, Float, Fraction, Complex, Mod],\n            \"+\": polynomial_add,\n            \"-\": polynomial_sub,\n            \"*\": polynomial_mul,\n            \"/\": polynomial_div_scalar,\n            \"**\": generic_pow, /* XXX: only for integer */\n        });\n\n    add_props(Polynomial, {\n        divrem(a, b) {\n            var n1, n2, i, j, q, r, n, c;\n            if (b.deg() < 0)\n                throw RangeError(\"division by zero\");\n            n1 = a.length;\n            n2 = b.length;\n            if (n1 < n2)\n                return [Polynomial([0]), a];\n            r = Array.prototype.dup.call(a);\n            q = [];\n            n2--;\n            n = n1 - n2;\n            for(i = 0; i < n; i++)\n                q[i] = 0;\n            for(i = n - 1; i >= 0; i--) {\n                c = r[i + n2];\n                if (c != 0) {\n                    c = c / b[n2];\n                    r[i + n2] = 0;\n                    for(j = 0; j < n2; j++) {\n                        r[i + j] -= b[j] * c;\n                    }\n                    q[i] = c;\n                }\n            }\n            return [Polynomial(q), Polynomial(r)];\n        },\n        gcd(a, b) {\n            var t;\n            while (b.deg() >= 0) {\n                t = Polynomial.divrem(a, b);\n                a = b;\n                b = t[1];\n            }\n            /* convert to monic form */\n            return a / a[a.length - 1];\n        },\n        invmod(x, y) {\n            var q, u, v, a, c, t;\n            u = x;\n            v = y;\n            c = Polynomial([1]);\n            a = Polynomial([0]);\n            while (u.deg() >= 0) {\n                t = Polynomial.divrem(v, u);\n                q = t[0];\n                v = u;\n                u = t[1];\n                t = c;\n                c = a - q * c;\n                a = t;\n            }\n            /* v = gcd(x, y) */\n            if (v.deg() > 0)\n                throw RangeError(\"not invertible\");\n            return Polynomial.divrem(a, y)[1];\n        },\n        roots(p) {\n            return poly_roots(p);\n        }\n    });\n\n    /* Polynomial Modulo Q */\n\n    PolyMod = function PolyMod(a, m) {\n        var obj, t;\n        if (new.target)\n            throw TypeError(\"not a constructor\");\n        obj = Object.create(PolyMod.prototype);\n        if (m instanceof Polynomial) {\n            if (m.deg() <= 0)\n                throw RangeError(\"the modulo cannot have a degree <= 0\");\n            if (a instanceof RationalFunction) {\n                return PolyMod(a.num, m) / a.den;\n            } else {\n                a = Polynomial(a);\n                t = Polynomial.divrem(a, m);\n                a = t[1];\n            }\n        } else {\n            throw TypeError(\"invalid types\");\n        }\n        obj.res = a;\n        obj.mod = m;\n        return obj;\n    };\n\n    function polymod_add(a, b) {\n        if (!(a instanceof PolyMod)) {\n            return PolyMod(a + b.res, b.mod);\n        } else if (!(b instanceof PolyMod)) {\n            return PolyMod(a.res + b, a.mod);\n        } else {\n            if (a.mod != b.mod)\n                throw TypeError(\"different modulo for binary operator\");\n            return PolyMod(a.res + b.res, a.mod);\n        }\n    }\n    function polymod_sub(a, b) {\n        return polymod_add(a, -b);\n    }\n    function polymod_mul(a, b) {\n        if (!(a instanceof PolyMod)) {\n            return PolyMod(a * b.res, b.mod);\n        } else if (!(b instanceof PolyMod)) {\n            return PolyMod(a.res * b, a.mod);\n        } else {\n            if (a.mod != b.mod)\n                    throw TypeError(\"different modulo for binary operator\");\n            return PolyMod(a.res * b.res, a.mod);\n        }\n    }\n    function polymod_div(a, b) {\n        if (!(b instanceof PolyMod))\n            b = PolyMod(b, a.mod);\n        return polymod_mul(a, b.inverse());\n    }\n    function polymod_eq(a, b) {\n        return (a.mod == b.mod && a.res == b.res);\n    }\n\n    operators_set(PolyMod.prototype,\n        {\n            \"+\": polymod_add,\n            \"-\": polymod_sub,\n            \"*\": polymod_mul,\n            \"/\": polymod_div,\n            \"**\": generic_pow,\n            \"==\": polymod_eq,\n            \"pos\"(a) {\n                return a;\n            },\n            \"neg\"(a) {\n                return PolyMod(-a.res, a.mod);\n            },\n        },\n        {\n            left: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],\n            right: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],\n            \"+\": polymod_add,\n            \"-\": polymod_sub,\n            \"*\": polymod_mul,\n            \"/\": polymod_div,\n            \"**\": generic_pow, /* XXX: only for integer */\n        });\n\n    add_props(PolyMod.prototype, {\n        inverse() {\n            var a = this, m = a.mod;\n            if (m instanceof Polynomial) {\n                return PolyMod(Polynomial.invmod(a.res, m), m);\n            } else {\n                throw TypeError(\"unsupported type\");\n            }\n        },\n        toString() {\n            return \"PolyMod(\" + this.res + \",\" + this.mod + \")\";\n        },\n    });\n\n    /* Rational function */\n\n    RationalFunction = function RationalFunction(a, b)\n    {\n        var t, r, d, obj;\n        if (new.target)\n            throw TypeError(\"not a constructor\");\n        if (!(a instanceof Polynomial) ||\n            !(b instanceof Polynomial))\n            throw TypeError(\"polynomial expected\");\n        t = Polynomial.divrem(a, b);\n        r = t[1];\n        if (r.deg() < 0)\n            return t[0]; /* no need for a fraction */\n        d = Polynomial.gcd(b, r);\n        if (d.deg() > 0) {\n            a = Polynomial.divrem(a, d)[0];\n            b = Polynomial.divrem(b, d)[0];\n        }\n        obj = Object.create(RationalFunction.prototype);\n        obj.num = a;\n        obj.den = b;\n        return obj;\n    }\n\n    add_props(RationalFunction.prototype, {\n        inverse() {\n            return RationalFunction(this.den, this.num);\n        },\n        conj() {\n            return RationalFunction(this.num.conj(), this.den.conj());\n        },\n        toString() {\n            var str;\n            if (this.num.deg() <= 0 &&\n                !number_need_paren(this.num[0]))\n                str = this.num.toString();\n            else\n                str = \"(\" + this.num.toString() + \")\";\n            str += \"/(\" + this.den.toString() + \")\"\n            return str;\n        },\n        apply(b) {\n            return this.num.apply(b) / this.den.apply(b);\n        },\n        deriv() {\n            var n = this.num, d = this.den;\n            return RationalFunction(n.deriv() * d - n * d.deriv(), d * d);\n        },\n    });\n\n    function ratfunc_add(a, b) {\n        a = RationalFunction.toRationalFunction(a);\n        b = RationalFunction.toRationalFunction(b);\n        return RationalFunction(a.num * b.den + a.den * b.num, a.den * b.den);\n    }\n    function ratfunc_sub(a, b) {\n        a = RationalFunction.toRationalFunction(a);\n        b = RationalFunction.toRationalFunction(b);\n        return RationalFunction(a.num * b.den - a.den * b.num, a.den * b.den);\n    }\n    function ratfunc_mul(a, b) {\n        a = RationalFunction.toRationalFunction(a);\n        b = RationalFunction.toRationalFunction(b);\n        return RationalFunction(a.num * b.num, a.den * b.den);\n    }\n    function ratfunc_div(a, b) {\n        a = RationalFunction.toRationalFunction(a);\n        b = RationalFunction.toRationalFunction(b);\n        return RationalFunction(a.num * b.den, a.den * b.num);\n    }\n    function ratfunc_eq(a, b) {\n        a = RationalFunction.toRationalFunction(a);\n        b = RationalFunction.toRationalFunction(b);\n        /* we assume the fractions are normalized */\n        return (a.num == b.num && a.den == b.den);\n    }\n\n    operators_set(RationalFunction.prototype,\n        {\n            \"+\": ratfunc_add,\n            \"-\": ratfunc_sub,\n            \"*\": ratfunc_mul,\n            \"/\": ratfunc_div,\n            \"**\": generic_pow,\n            \"==\": ratfunc_eq,\n            \"pos\"(a) {\n                return a;\n            },\n            \"neg\"(a) {\n                return RationalFunction(-this.num, this.den);\n            },\n        },\n        {\n            left: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],\n            right: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],\n            \"+\": ratfunc_add,\n            \"-\": ratfunc_sub,\n            \"*\": ratfunc_mul,\n            \"/\": ratfunc_div,\n            \"**\": generic_pow, /* should only be used with integers */\n        });\n\n    add_props(RationalFunction, {\n        /* This function always return a RationalFunction object even\n           if it could simplified to a polynomial, so it is not\n           equivalent to RationalFunction(a) */\n        toRationalFunction(a) {\n            var obj;\n            if (a instanceof RationalFunction) {\n                return a;\n            } else {\n                obj = Object.create(RationalFunction.prototype);\n                obj.num = Polynomial(a);\n                obj.den = Polynomial(1);\n                return obj;\n            }\n        },\n    });\n\n    /* Power series */\n\n    /* 'a' is an array */\n    function get_emin(a) {\n        var i, n;\n        n = a.length;\n        for(i = 0; i < n; i++) {\n            if (a[i] != 0)\n                return i;\n        }\n        return n;\n    };\n\n    function series_is_scalar_or_polynomial(a)\n    {\n        return polynomial_is_scalar(a) ||\n            (a instanceof Polynomial);\n    }\n\n    /* n is the maximum number of terms if 'a' is not a serie */\n    Series = function Series(a, n) {\n        var emin, r, i;\n\n        if (a instanceof Series) {\n            return a;\n        } else if (series_is_scalar_or_polynomial(a)) {\n            if (n <= 0) {\n                /* XXX: should still use the polynomial degree */\n                return Series.zero(0, 0);\n            } else {\n                a = Polynomial(a);\n                emin = get_emin(a);\n                r = Series.zero(n, emin);\n                n = Math.min(a.length - emin, n);\n                for(i = 0; i < n; i++)\n                    r[i] = a[i + emin];\n                return r;\n            }\n        } else if (a instanceof RationalFunction) {\n            return Series(a.num, n) / a.den;\n        } else {\n            throw TypeError(\"invalid type\");\n        }\n    };\n\n    function series_add(v1, v2) {\n        var tmp, d, emin, n, r, i, j, v2_emin, c1, c2;\n        if (!(v1 instanceof Series)) {\n            tmp = v1;\n            v1 = v2;\n            v2 = tmp;\n        }\n        d = v1.emin + v1.length;\n        if (series_is_scalar_or_polynomial(v2)) {\n            v2 = Polynomial(v2);\n            if (d <= 0)\n                return v1;\n            v2_emin = 0;\n        } else if (v2 instanceof RationalFunction) {\n            /* compute the emin of the rational fonction */\n            i = get_emin(v2.num) - get_emin(v2.den);\n            if (d <= i)\n                return v1;\n            /* compute the serie with the required terms */\n            v2 = Series(v2, d - i);\n            v2_emin = v2.emin;\n        } else {\n            v2_emin = v2.emin;\n            d = Math.min(d, v2_emin + v2.length);\n        }\n        emin = Math.min(v1.emin, v2_emin);\n        n = d - emin;\n        r = Series.zero(n, emin);\n        /* XXX: slow */\n        for(i = emin; i < d; i++) {\n            j = i - v1.emin;\n            if (j >= 0 && j < v1.length)\n                c1 = v1[j];\n            else\n                c1 = 0;\n            j = i - v2_emin;\n            if (j >= 0 && j < v2.length)\n                c2 = v2[j];\n            else\n                c2 = 0;\n            r[i - emin] = c1 + c2;\n        }\n        return r.trim();\n    }\n    function series_sub(a, b) {\n        return series_add(a, -b);\n    }\n    function series_mul(v1, v2) {\n        var n, i, j, r, n, emin, n1, n2, k;\n        if (!(v1 instanceof Series))\n            v1 = Series(v1, v2.length);\n        else if (!(v2 instanceof Series))\n            v2 = Series(v2, v1.length);\n        emin = v1.emin + v2.emin;\n        n = Math.min(v1.length, v2.length);\n        n1 = v1.length;\n        n2 = v2.length;\n        r = Series.zero(n, emin);\n        for(i = 0; i < n1; i++) {\n            k = Math.min(n2, n - i);\n            for(j = 0; j < k; j++) {\n                r[i + j] += v1[i] * v2[j];\n            }\n        }\n        return r.trim();\n    }\n    function series_div(v1, v2) {\n        if (!(v2 instanceof Series))\n            v2 = Series(v2, v1.length);\n        return series_mul(v1, v2.inverse());\n    }\n    function series_pow(a, b) {\n        if (Integer.isInteger(b)) {\n            return generic_pow(a, b);\n        } else {\n            if (!(a instanceof Series))\n                a = Series(a, b.length);\n            return exp(log(a) * b);\n        }\n    }\n    function series_eq(a, b) {\n        var n, i;\n        if (a.emin != b.emin)\n            return false;\n        n = a.length;\n        if (n != b.length)\n            return false;\n        for(i = 0; i < n; i++) {\n            if (a[i] != b[i])\n                return false;\n        }\n        return true;\n    }\n\n    operators_set(Series.prototype,\n        {\n            \"+\": series_add,\n            \"-\": series_sub,\n            \"*\": series_mul,\n            \"/\": series_div,\n            \"**\": series_pow,\n            \"==\": series_eq,\n            \"pos\"(a) {\n                return a;\n            },\n            \"neg\"(a) {\n                var obj, n, i;\n                n = a.length;\n                obj = Series.zero(a.length, a.emin);\n                for(i = 0; i < n; i++) {\n                    obj[i] = -a[i];\n                }\n                return obj;\n            },\n        },\n        {\n            left: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],\n            right: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],\n            \"+\": series_add,\n            \"-\": series_sub,\n            \"*\": series_mul,\n            \"/\": series_div,\n            \"**\": series_pow,\n        });\n\n    add_props(Series.prototype, {\n        conj() {\n            var obj, n, i;\n            n = this.length;\n            obj = Series.zero(this.length, this.emin);\n            for(i = 0; i < n; i++) {\n                obj[i] = this[i].conj();\n            }\n            return obj;\n        },\n        inverse() {\n            var r, n, i, j, sum, v1 = this;\n            n = v1.length;\n            if (n == 0)\n                throw RangeError(\"division by zero\");\n            r = Series.zero(n, -v1.emin);\n            r[0] = 1 / v1[0];\n            for(i = 1; i < n; i++) {\n                sum = 0;\n                for(j = 1; j <= i; j++) {\n                    sum += v1[j] * r[i - j];\n                }\n                r[i] = -sum * r[0];\n            }\n            return r;\n        },\n        /* remove leading zero terms */\n        trim() {\n            var i, j, n, r, v1 = this;\n            n = v1.length;\n            i = 0;\n            while (i < n && v1[i] == 0)\n                i++;\n            if (i == 0)\n                return v1;\n            for(j = i; j < n; j++)\n                v1[j - i] = v1[j];\n            v1.length = n - i;\n            v1.__proto__.emin += i;\n            return v1;\n        },\n        toString() {\n            var i, j, str, str1, c, a = this, emin, n;\n            str=\"\";\n            emin = this.emin;\n            n = this.length;\n            for(j = 0; j < n; j++) {\n                i = j + emin;\n                c = a[j];\n                if (c != 0) {\n                    str1 = monomial_toString(c, i);\n                    if (str1[0] != \"-\") {\n                        if (str != \"\")\n                            str += \"+\";\n                    }\n                    str += str1;\n                }\n            }\n            if (str != \"\")\n                str += \"+\";\n            str += \"O(\" + monomial_toString(1, n + emin) + \")\";\n            return str;\n        },\n        apply(b) {\n            var i, n, r, a = this;\n            n = a.length;\n            if (n == 0)\n                return 0;\n            r = a[--n];\n            while (n > 0) {\n                n--;\n                r = r * b + a[n];\n            }\n            if (a.emin != 0)\n                r *= b ^ a.emin;\n            return r;\n        },\n        deriv() {\n            var a = this, n = a.length, emin = a.emin, r, i, j;\n            if (n == 0 && emin == 0) {\n                return Series.zero(0, 0);\n            } else {\n                r = Series.zero(n, emin - 1);\n                for(i = 0; i < n; i++) {\n                    j = emin + i;\n                    if (j == 0)\n                        r[i] = 0;\n                    else\n                        r[i] = j * a[i];\n                }\n                return r.trim();\n            }\n        },\n        integ() {\n            var a = this, n = a.length, emin = a.emin, i, j, r;\n            r = Series.zero(n, emin + 1);\n            for(i = 0; i < n; i++) {\n                j = emin + i;\n                if (j == -1) {\n                    if (a[i] != 0)\n                        throw RangeError(\"cannot represent integ(1/X)\");\n                } else {\n                    r[i] = a[i] / (j + 1);\n                }\n            }\n            return r.trim();\n        },\n        exp() {\n            var c, i, r, n, a = this;\n            if (a.emin < 0)\n                throw RangeError(\"negative exponent in exp\");\n            n = a.emin + a.length;\n            if (a.emin > 0 || a[0] == 0) {\n                c = 1;\n            } else {\n                c = global.exp(a[0]);\n                a -= a[0];\n            }\n            r = Series.zero(n, 0);\n            for(i = 0; i < n; i++) {\n                r[i] = c / fact(i);\n            }\n            return r.apply(a);\n        },\n        log() {\n            var a = this, r;\n            if (a.emin != 0)\n                throw RangeError(\"log argument must have a non zero constant term\");\n            r = integ(deriv(a) / a);\n            /* add the constant term */\n            r += global.log(a[0]);\n            return r;\n        },\n    });\n\n    add_props(Series, {\n        /* new series of length n and first exponent emin */\n        zero(n, emin) {\n            var r, i, obj;\n\n            r = [];\n            for(i = 0; i < n; i++)\n                r[i] = 0;\n            /* we return an array and store emin in its prototype */\n            obj = Object.create(Series.prototype);\n            obj.emin = emin;\n            Object.setPrototypeOf(r, obj);\n            return r;\n        },\n        O(a) {\n            function ErrorO() {\n                return TypeError(\"invalid O() argument\");\n            }\n            var n;\n            if (series_is_scalar_or_polynomial(a)) {\n                a = Polynomial(a);\n                n = a.deg();\n                if (n < 0)\n                    throw ErrorO();\n            } else if (a instanceof RationalFunction) {\n                if (a.num.deg() != 0)\n                    throw ErrorO();\n                n = a.den.deg();\n                if (n < 0)\n                    throw ErrorO();\n                n = -n;\n            } else\n                throw ErrorO();\n            return Series.zero(0, n);\n        },\n    });\n\n    /* Array (Matrix) */\n\n    Matrix = function Matrix(h, w) {\n        var i, j, r, rl;\n        if (typeof w === \"undefined\")\n            w = h;\n        r = [];\n        for(i = 0; i < h; i++) {\n            rl = [];\n            for(j = 0; j < w; j++)\n                rl[j] = 0;\n            r[i] = rl;\n        }\n        return r;\n    };\n\n    add_props(Matrix, {\n        idn(n) {\n            var r, i;\n            r = Matrix(n, n);\n            for(i = 0; i < n; i++)\n                r[i][i] = 1;\n            return r;\n        },\n        diag(a) {\n            var r, i, n;\n            n = a.length;\n            r = Matrix(n, n);\n            for(i = 0; i < n; i++)\n                r[i][i] = a[i];\n            return r;\n        },\n        hilbert(n) {\n            var i, j, r;\n            r = Matrix(n);\n            for(i = 0; i < n; i++) {\n                for(j = 0; j < n; j++) {\n                    r[i][j] = 1 / (1 + i + j);\n                }\n            }\n            return r;\n        },\n        trans(a) {\n            var h, w, r, i, j;\n            if (!Array.isArray(a))\n                throw TypeError(\"matrix expected\");\n            h = a.length;\n            if (!Array.isArray(a[0])) {\n                w = 1;\n                r = Matrix(w, h);\n                for(i = 0; i < h; i++) {\n                    r[0][i] = a[i];\n                }\n            } else {\n                w = a[0].length;\n                r = Matrix(w, h);\n                for(i = 0; i < h; i++) {\n                    for(j = 0; j < w; j++) {\n                        r[j][i] = a[i][j];\n                    }\n                }\n            }\n            return r;\n        },\n        check_square(a) {\n            var a, n;\n            if (!Array.isArray(a))\n                throw TypeError(\"array expected\");\n            n = a.length;\n            if (!Array.isArray(a[0]) || n != a[0].length)\n                throw TypeError(\"square matrix expected\");\n            return n;\n        },\n        trace(a) {\n            var n, r, i;\n            n = Matrix.check_square(a);\n            r = a[0][0];\n            for(i = 1; i < n; i++) {\n                r += a[i][i];\n            }\n            return r;\n        },\n        charpoly(a) {\n            var n, p, c, i, j, coef;\n            n = Matrix.check_square(a);\n            p = [];\n            for(i = 0; i < n + 1; i++)\n                p[i] = 0;\n            p[n] = 1;\n            c = Matrix.idn(n);\n            for(i = 0; i < n; i++) {\n                c = c * a;\n                coef = -trace(c) / (i + 1);\n                p[n - i - 1] = coef;\n                for(j = 0; j < n; j++)\n                    c[j][j] += coef;\n            }\n            return Polynomial(p);\n        },\n        eigenvals(a) {\n            return Polynomial.roots(Matrix.charpoly(a));\n        },\n        det(a) {\n            var n, i, j, k, s, src, v, c;\n\n            n = Matrix.check_square(a);\n            s = 1;\n            src = a.dup();\n            for(i=0;i<n;i++) {\n                for(j = i; j < n; j++) {\n                    if (src[j][i] != 0)\n                        break;\n                }\n                if (j == n)\n                    return 0;\n                if (j != i) {\n                    for(k = 0;k < n; k++) {\n                        v = src[j][k];\n                        src[j][k] = src[i][k];\n                        src[i][k] = v;\n                    }\n                    s = -s;\n                }\n                c = src[i][i].inverse();\n                for(j = i + 1; j < n; j++) {\n                    v = c * src[j][i];\n                    for(k = 0;k < n; k++) {\n                        src[j][k] -= src[i][k] * v;\n                    }\n                }\n            }\n            c = s;\n            for(i=0;i<n;i++)\n                c *= src[i][i];\n            return c;\n        },\n        inverse(a) {\n            var n, dst, src, i, j, k, n2, r, c, v;\n            n = Matrix.check_square(a);\n            src = a.dup();\n            dst = Matrix.idn(n);\n            for(i=0;i<n;i++) {\n                for(j = i; j < n; j++) {\n                    if (src[j][i] != 0)\n                        break;\n                }\n                if (j == n)\n                    throw RangeError(\"matrix is not invertible\");\n                if (j != i) {\n                    /* swap lines in src and dst */\n                    v = src[j];\n                    src[j] = src[i];\n                    src[i] = v;\n                    v = dst[j];\n                    dst[j] = dst[i];\n                    dst[i] = v;\n                }\n\n                c = src[i][i].inverse();\n                for(k = 0; k < n; k++) {\n                    src[i][k] *= c;\n                    dst[i][k] *= c;\n                }\n\n                for(j = 0; j < n; j++) {\n                    if (j != i) {\n                        c = src[j][i];\n                        for(k = i; k < n; k++) {\n                            src[j][k] -= src[i][k] * c;\n                        }\n                        for(k = 0; k < n; k++) {\n                            dst[j][k] -= dst[i][k] * c;\n                        }\n                    }\n                }\n            }\n            return dst;\n        },\n        rank(a) {\n            var src, i, j, k, w, h, l, c;\n\n            if (!Array.isArray(a) ||\n                !Array.isArray(a[0]))\n                throw TypeError(\"matrix expected\");\n            h = a.length;\n            w = a[0].length;\n            src = a.dup();\n            l = 0;\n            for(i=0;i<w;i++) {\n                for(j = l; j < h; j++) {\n                    if (src[j][i] != 0)\n                        break;\n                }\n                if (j == h)\n                    continue;\n                if (j != l) {\n                    /* swap lines */\n                    for(k = 0; k < w; k++) {\n                        v = src[j][k];\n                        src[j][k] = src[l][k];\n                        src[l][k] = v;\n                    }\n                }\n\n                c = src[l][i].inverse();\n                for(k = 0; k < w; k++) {\n                    src[l][k] *= c;\n                }\n\n                for(j = l + 1; j < h; j++) {\n                    c = src[j][i];\n                    for(k = i; k < w; k++) {\n                        src[j][k] -= src[l][k] * c;\n                    }\n                }\n                l++;\n            }\n            return l;\n        },\n        ker(a) {\n            var src, i, j, k, w, h, l, m, r, im_cols, ker_dim, c;\n\n            if (!Array.isArray(a) ||\n                !Array.isArray(a[0]))\n                throw TypeError(\"matrix expected\");\n            h = a.length;\n            w = a[0].length;\n            src = a.dup();\n            im_cols = [];\n            l = 0;\n            for(i=0;i<w;i++) {\n                im_cols[i] = false;\n                for(j = l; j < h; j++) {\n                    if (src[j][i] != 0)\n                        break;\n                }\n                if (j == h)\n                    continue;\n                im_cols[i] = true;\n                if (j != l) {\n                    /* swap lines */\n                    for(k = 0; k < w; k++) {\n                        v = src[j][k];\n                        src[j][k] = src[l][k];\n                        src[l][k] = v;\n                    }\n                }\n\n                c = src[l][i].inverse();\n                for(k = 0; k < w; k++) {\n                    src[l][k] *= c;\n                }\n\n                for(j = 0; j < h; j++) {\n                    if (j != l) {\n                        c = src[j][i];\n                        for(k = i; k < w; k++) {\n                            src[j][k] -= src[l][k] * c;\n                        }\n                    }\n                }\n                l++;\n                //        log_str(\"m=\" + cval_toString(v1) + \"\\n\");\n            }\n            //    log_str(\"im cols=\"+im_cols+\"\\n\");\n\n            /* build the kernel vectors */\n            ker_dim = w - l;\n            r = Matrix(w, ker_dim);\n            k = 0;\n            for(i = 0; i < w; i++) {\n                if (!im_cols[i]) {\n                    /* select this column from the matrix */\n                    l = 0;\n                    m = 0;\n                    for(j = 0; j < w; j++) {\n                        if (im_cols[j]) {\n                            r[j][k] = -src[m][i];\n                            m++;\n                        } else {\n                            if (l == k) {\n                                r[j][k] = 1;\n                            } else {\n                                r[j][k] = 0;\n                            }\n                            l++;\n                        }\n                    }\n                    k++;\n                }\n            }\n            return r;\n        },\n        dp(a, b) {\n            var i, n, r;\n            n = a.length;\n            if (n != b.length)\n                throw TypeError(\"incompatible array length\");\n            /* XXX: could do complex product */\n            r = 0;\n            for(i = 0; i < n; i++) {\n                r += a[i] * b[i];\n            }\n            return r;\n        },\n        /* cross product */\n        cp(v1, v2) {\n            var r;\n            if (v1.length != 3 || v2.length != 3)\n                throw TypeError(\"vectors must have 3 elements\");\n            r = [];\n            r[0] = v1[1] * v2[2] - v1[2] * v2[1];\n            r[1] = v1[2] * v2[0] - v1[0] * v2[2];\n            r[2] = v1[0] * v2[1] - v1[1] * v2[0];\n            return r;\n        },\n    });\n\n    function array_add(a, b) {\n        var r, i, n;\n        n = a.length;\n        if (n != b.length)\n            throw TypeError(\"incompatible array size\");\n        r = [];\n        for(i = 0; i < n; i++)\n            r[i] = a[i] + b[i];\n        return r;\n    }\n    function array_sub(a, b) {\n        var r, i, n;\n        n = a.length;\n        if (n != b.length)\n            throw TypeError(\"incompatible array size\");\n        r = [];\n        for(i = 0; i < n; i++)\n            r[i] = a[i] - b[i];\n        return r;\n    }\n    function array_scalar_mul(a, b) {\n        var r, i, n;\n        n = a.length;\n        r = [];\n        for(i = 0; i < n; i++)\n            r[i] = a[i] * b;\n        return r;\n    }\n    function array_mul(a, b) {\n        var h, w, l, i, j, k, r, rl, sum, a_mat, b_mat;\n        h = a.length;\n        a_mat = Array.isArray(a[0]);\n        if (a_mat) {\n            l = a[0].length;\n        } else {\n            l = 1;\n        }\n        if (l != b.length)\n            throw RangeError(\"incompatible matrix size\");\n        b_mat = Array.isArray(b[0]);\n        if (b_mat)\n            w = b[0].length;\n        else\n            w = 1;\n        r = [];\n        if (a_mat && b_mat) {\n            for(i = 0; i < h; i++) {\n                rl = [];\n                for(j = 0; j < w; j++) {\n                    sum = 0;\n                    for(k = 0; k < l; k++) {\n                        sum += a[i][k] * b[k][j];\n                    }\n                    rl[j] = sum;\n                }\n                r[i] = rl;\n            }\n        } else if (a_mat && !b_mat) {\n            for(i = 0; i < h; i++) {\n                sum = 0;\n                for(k = 0; k < l; k++) {\n                    sum += a[i][k] * b[k];\n                }\n                r[i] = sum;\n            }\n        } else if (!a_mat && b_mat) {\n            for(i = 0; i < h; i++) {\n                rl = [];\n                for(j = 0; j < w; j++) {\n                    rl[j] = a[i] * b[0][j];\n                }\n                r[i] = rl;\n            }\n        } else {\n            for(i = 0; i < h; i++) {\n                r[i] = a[i] * b[0];\n            }\n        }\n        return r;\n    }\n    function array_div(a, b) {\n        return array_mul(a, b.inverse());\n    }\n    function array_element_wise_inverse(a) {\n        var r, i, n;\n        n = a.length;\n        r = [];\n        for(i = 0; i < n; i++)\n            r[i] = a[i].inverse();\n        return r;\n    }\n    function array_eq(a, b) {\n        var n, i;\n        n = a.length;\n        if (n != b.length)\n            return false;\n        for(i = 0; i < n; i++) {\n            if (a[i] != b[i])\n                return false;\n        }\n        return true;\n    }\n\n    operators_set(Array.prototype,\n        {\n            \"+\": array_add,\n            \"-\": array_sub,\n            \"*\": array_mul,\n            \"/\": array_div,\n            \"==\": array_eq,\n            \"pos\"(a) {\n                return a;\n            },\n            \"neg\"(a) {\n                var i, n, r;\n                n = a.length;\n                r = [];\n                for(i = 0; i < n; i++)\n                    r[i] = -a[i];\n                return r;\n            }\n        },\n        {\n            right: [Number, BigInt, Float, Fraction, Complex, Mod,\n                    Polynomial, PolyMod, RationalFunction, Series],\n            \"*\": array_scalar_mul,\n            \"/\"(a, b) { return a * b.inverse(); },\n            \"**\": generic_pow, /* XXX: only for integer */\n        },\n        {\n            left: [Number, BigInt, Float, Fraction, Complex, Mod,\n                   Polynomial, PolyMod, RationalFunction, Series],\n            \"*\"(a, b) { return array_scalar_mul(b, a); },\n            \"/\"(a, b) { return a * array_element_wise_inverse(b); },\n        });\n\n    add_props(Array.prototype, {\n        conj() {\n            var i, n, r;\n            n = this.length;\n            r = [];\n            for(i = 0; i < n; i++)\n                r[i] = this[i].conj();\n            return r;\n        },\n        dup() {\n            var r, i, n, el, a = this;\n            r = [];\n            n = a.length;\n            for(i = 0; i < n; i++) {\n                el = a[i];\n                if (Array.isArray(el))\n                    el = el.dup();\n                r[i] = el;\n            }\n            return r;\n        },\n        inverse() {\n            return Matrix.inverse(this);\n        },\n        norm2: Polynomial.prototype.norm2,\n    });\n\n})(this);\n\n/* global definitions */\nvar I = Complex(0, 1);\nvar X = Polynomial([0, 1]);\nvar O = Series.O;\n\nObject.defineProperty(this, \"PI\", { get: function () { return Float.PI } });\n\n/* put frequently used functions in the global context */\nvar gcd = Integer.gcd;\nvar fact = Integer.fact;\nvar comb = Integer.comb;\nvar pmod = Integer.pmod;\nvar invmod = Integer.invmod;\nvar factor = Integer.factor;\nvar isprime = Integer.isPrime;\nvar nextprime = Integer.nextPrime;\n\nfunction deriv(a)\n{\n    return a.deriv();\n}\n\nfunction integ(a)\n{\n    return a.integ();\n}\n\nfunction norm2(a)\n{\n    return a.norm2();\n}\n\nfunction abs(a)\n{\n    return a.abs();\n}\n\nfunction conj(a)\n{\n    return a.conj();\n}\n\nfunction arg(a)\n{\n    return a.arg();\n}\n\nfunction inverse(a)\n{\n    return a.inverse();\n}\n\nfunction trunc(a)\n{\n    if (Integer.isInteger(a)) {\n        return a;\n    } else if (a instanceof Fraction) {\n        return Integer.tdiv(a.num, a.den);\n    } else if (a instanceof Polynomial) {\n        return a;\n    } else if (a instanceof RationalFunction) {\n        return Polynomial.divrem(a.num, a.den)[0];\n    } else {\n        return Float.ceil(a);\n    }\n}\n\nfunction floor(a)\n{\n    if (Integer.isInteger(a)) {\n        return a;\n    } else if (a instanceof Fraction) {\n        return Integer.fdiv(a.num, a.den);\n    } else {\n        return Float.floor(a);\n    }\n}\n\nfunction ceil(a)\n{\n    if (Integer.isInteger(a)) {\n        return a;\n    } else if (a instanceof Fraction) {\n        return Integer.cdiv(a.num, a.den);\n    } else {\n        return Float.ceil(a);\n    }\n}\n\nfunction sqrt(a)\n{\n    var t, u, re, im;\n    if (a instanceof Series) {\n        return a ^ (1/2);\n    } else if (a instanceof Complex) {\n        t = abs(a);\n        u = a.re;\n        re = sqrt((t + u) / 2);\n        im = sqrt((t - u) / 2);\n        if (a.im < 0)\n            im = -im;\n        return Complex.toComplex(re, im);\n    } else {\n        a = Float(a);\n        if (a < 0) {\n            return Complex(0, Float.sqrt(-a));\n        } else {\n            return Float.sqrt(a);\n        }\n    }\n}\n\nfunction exp(a)\n{\n    return a.exp();\n}\n\nfunction log(a)\n{\n    return a.log();\n}\n\nfunction log2(a)\n{\n    return log(a) * Float.LOG2E;\n}\n\nfunction log10(a)\n{\n    return log(a) * Float.LOG10E;\n}\n\nfunction todb(a)\n{\n    return log10(a) * 10;\n}\n\nfunction fromdb(a)\n{\n    return 10 ^ (a / 10);\n}\n\nfunction sin(a)\n{\n    var t;\n    if (a instanceof Complex || a instanceof Series) {\n        t = exp(a * I);\n        return (t - 1/t) / (2 * I);\n    } else {\n        return Float.sin(Float(a));\n    }\n}\n\nfunction cos(a)\n{\n    var t;\n    if (a instanceof Complex || a instanceof Series) {\n        t = exp(a * I);\n        return (t + 1/t) / 2;\n    } else {\n        return Float.cos(Float(a));\n    }\n}\n\nfunction tan(a)\n{\n    if (a instanceof Complex || a instanceof Series) {\n        return sin(a) / cos(a);\n    } else {\n        return Float.tan(Float(a));\n    }\n}\n\nfunction asin(a)\n{\n    return Float.asin(Float(a));\n}\n\nfunction acos(a)\n{\n    return Float.acos(Float(a));\n}\n\nfunction atan(a)\n{\n    return Float.atan(Float(a));\n}\n\nfunction atan2(a, b)\n{\n    return Float.atan2(Float(a), Float(b));\n}\n\nfunction sinc(a)\n{\n    if (a == 0) {\n        return 1;\n    } else {\n        a *= Float.PI;\n        return sin(a) / a;\n    }\n}\n\nfunction todeg(a)\n{\n    return a * 180 / Float.PI;\n}\n\nfunction fromdeg(a)\n{\n    return a * Float.PI / 180;\n}\n\nfunction sinh(a)\n{\n    var e = Float.exp(Float(a));\n    return (e - 1/e) * 0.5;\n}\n\nfunction cosh(a)\n{\n    var e = Float.exp(Float(a));\n    return (e + 1/e) * 0.5;\n}\n\nfunction tanh(a)\n{\n    var e = Float.exp(Float(a) * 2);\n    return (e - 1) / (e + 1);\n}\n\nfunction asinh(a)\n{\n    var x = Float(a);\n    return log(sqrt(x * x + 1) + x);\n}\n\nfunction acosh(a)\n{\n    var x = Float(a);\n    return log(sqrt(x * x - 1) + x);\n}\n\nfunction atanh(a)\n{\n    var x = Float(a);\n    return 0.5 * log((1 + x) / (1 - x));\n}\n\nfunction sigmoid(x)\n{\n    x = Float(x);\n    return 1 / (1 + exp(-x));\n}\n\nfunction lerp(a, b, t)\n{\n    return a + (b - a) * t;\n}\n\nvar idn = Matrix.idn;\nvar diag = Matrix.diag;\nvar trans = Matrix.trans;\nvar trace = Matrix.trace;\nvar charpoly = Matrix.charpoly;\nvar eigenvals = Matrix.eigenvals;\nvar det = Matrix.det;\nvar rank = Matrix.rank;\nvar ker = Matrix.ker;\nvar cp = Matrix.cp;\nvar dp = Matrix.dp;\n\nvar polroots = Polynomial.roots;\nvar bestappr = Float.bestappr;\n"
        },
        {
          "name": "quickjs-atom.h",
          "type": "blob",
          "size": 7.7763671875,
          "content": "/*\n * QuickJS atom definitions\n *\n * Copyright (c) 2017-2018 Fabrice Bellard\n * Copyright (c) 2017-2018 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#ifdef DEF\n\n/* Note: first atoms are considered as keywords in the parser */\nDEF(null, \"null\") /* must be first */\nDEF(false, \"false\")\nDEF(true, \"true\")\nDEF(if, \"if\")\nDEF(else, \"else\")\nDEF(return, \"return\")\nDEF(var, \"var\")\nDEF(this, \"this\")\nDEF(delete, \"delete\")\nDEF(void, \"void\")\nDEF(typeof, \"typeof\")\nDEF(new, \"new\")\nDEF(in, \"in\")\nDEF(instanceof, \"instanceof\")\nDEF(do, \"do\")\nDEF(while, \"while\")\nDEF(for, \"for\")\nDEF(break, \"break\")\nDEF(continue, \"continue\")\nDEF(switch, \"switch\")\nDEF(case, \"case\")\nDEF(default, \"default\")\nDEF(throw, \"throw\")\nDEF(try, \"try\")\nDEF(catch, \"catch\")\nDEF(finally, \"finally\")\nDEF(function, \"function\")\nDEF(debugger, \"debugger\")\nDEF(with, \"with\")\n/* FutureReservedWord */\nDEF(class, \"class\")\nDEF(const, \"const\")\nDEF(enum, \"enum\")\nDEF(export, \"export\")\nDEF(extends, \"extends\")\nDEF(import, \"import\")\nDEF(super, \"super\")\n/* FutureReservedWords when parsing strict mode code */\nDEF(implements, \"implements\")\nDEF(interface, \"interface\")\nDEF(let, \"let\")\nDEF(package, \"package\")\nDEF(private, \"private\")\nDEF(protected, \"protected\")\nDEF(public, \"public\")\nDEF(static, \"static\")\nDEF(yield, \"yield\")\nDEF(await, \"await\")\n\n/* empty string */\nDEF(empty_string, \"\")\n/* identifiers */\nDEF(length, \"length\")\nDEF(fileName, \"fileName\")\nDEF(lineNumber, \"lineNumber\")\nDEF(message, \"message\")\nDEF(cause, \"cause\")\nDEF(errors, \"errors\")\nDEF(stack, \"stack\")\nDEF(name, \"name\")\nDEF(toString, \"toString\")\nDEF(toLocaleString, \"toLocaleString\")\nDEF(valueOf, \"valueOf\")\nDEF(eval, \"eval\")\nDEF(prototype, \"prototype\")\nDEF(constructor, \"constructor\")\nDEF(configurable, \"configurable\")\nDEF(writable, \"writable\")\nDEF(enumerable, \"enumerable\")\nDEF(value, \"value\")\nDEF(get, \"get\")\nDEF(set, \"set\")\nDEF(of, \"of\")\nDEF(__proto__, \"__proto__\")\nDEF(undefined, \"undefined\")\nDEF(number, \"number\")\nDEF(boolean, \"boolean\")\nDEF(string, \"string\")\nDEF(object, \"object\")\nDEF(symbol, \"symbol\")\nDEF(integer, \"integer\")\nDEF(unknown, \"unknown\")\nDEF(arguments, \"arguments\")\nDEF(callee, \"callee\")\nDEF(caller, \"caller\")\nDEF(_eval_, \"<eval>\")\nDEF(_ret_, \"<ret>\")\nDEF(_var_, \"<var>\")\nDEF(_arg_var_, \"<arg_var>\")\nDEF(_with_, \"<with>\")\nDEF(lastIndex, \"lastIndex\")\nDEF(target, \"target\")\nDEF(index, \"index\")\nDEF(input, \"input\")\nDEF(defineProperties, \"defineProperties\")\nDEF(apply, \"apply\")\nDEF(join, \"join\")\nDEF(concat, \"concat\")\nDEF(split, \"split\")\nDEF(construct, \"construct\")\nDEF(getPrototypeOf, \"getPrototypeOf\")\nDEF(setPrototypeOf, \"setPrototypeOf\")\nDEF(isExtensible, \"isExtensible\")\nDEF(preventExtensions, \"preventExtensions\")\nDEF(has, \"has\")\nDEF(deleteProperty, \"deleteProperty\")\nDEF(defineProperty, \"defineProperty\")\nDEF(getOwnPropertyDescriptor, \"getOwnPropertyDescriptor\")\nDEF(ownKeys, \"ownKeys\")\nDEF(add, \"add\")\nDEF(done, \"done\")\nDEF(next, \"next\")\nDEF(values, \"values\")\nDEF(source, \"source\")\nDEF(flags, \"flags\")\nDEF(global, \"global\")\nDEF(unicode, \"unicode\")\nDEF(raw, \"raw\")\nDEF(new_target, \"new.target\")\nDEF(this_active_func, \"this.active_func\")\nDEF(home_object, \"<home_object>\")\nDEF(computed_field, \"<computed_field>\")\nDEF(static_computed_field, \"<static_computed_field>\") /* must come after computed_fields */\nDEF(class_fields_init, \"<class_fields_init>\")\nDEF(brand, \"<brand>\")\nDEF(hash_constructor, \"#constructor\")\nDEF(as, \"as\")\nDEF(from, \"from\")\nDEF(meta, \"meta\")\nDEF(_default_, \"*default*\")\nDEF(_star_, \"*\")\nDEF(Module, \"Module\")\nDEF(then, \"then\")\nDEF(resolve, \"resolve\")\nDEF(reject, \"reject\")\nDEF(promise, \"promise\")\nDEF(proxy, \"proxy\")\nDEF(revoke, \"revoke\")\nDEF(async, \"async\")\nDEF(exec, \"exec\")\nDEF(groups, \"groups\")\nDEF(indices, \"indices\")\nDEF(status, \"status\")\nDEF(reason, \"reason\")\nDEF(globalThis, \"globalThis\")\nDEF(bigint, \"bigint\")\n#ifdef CONFIG_BIGNUM\nDEF(bigfloat, \"bigfloat\")\nDEF(bigdecimal, \"bigdecimal\")\nDEF(roundingMode, \"roundingMode\")\nDEF(maximumSignificantDigits, \"maximumSignificantDigits\")\nDEF(maximumFractionDigits, \"maximumFractionDigits\")\n#endif\n/* the following 3 atoms are only used with CONFIG_ATOMICS */\nDEF(not_equal, \"not-equal\")\nDEF(timed_out, \"timed-out\")\nDEF(ok, \"ok\")\n/* */\nDEF(toJSON, \"toJSON\")\n/* class names */\nDEF(Object, \"Object\")\nDEF(Array, \"Array\")\nDEF(Error, \"Error\")\nDEF(Number, \"Number\")\nDEF(String, \"String\")\nDEF(Boolean, \"Boolean\")\nDEF(Symbol, \"Symbol\")\nDEF(Arguments, \"Arguments\")\nDEF(Math, \"Math\")\nDEF(JSON, \"JSON\")\nDEF(Date, \"Date\")\nDEF(Function, \"Function\")\nDEF(GeneratorFunction, \"GeneratorFunction\")\nDEF(ForInIterator, \"ForInIterator\")\nDEF(RegExp, \"RegExp\")\nDEF(ArrayBuffer, \"ArrayBuffer\")\nDEF(SharedArrayBuffer, \"SharedArrayBuffer\")\n/* must keep same order as class IDs for typed arrays */\nDEF(Uint8ClampedArray, \"Uint8ClampedArray\")\nDEF(Int8Array, \"Int8Array\")\nDEF(Uint8Array, \"Uint8Array\")\nDEF(Int16Array, \"Int16Array\")\nDEF(Uint16Array, \"Uint16Array\")\nDEF(Int32Array, \"Int32Array\")\nDEF(Uint32Array, \"Uint32Array\")\nDEF(BigInt64Array, \"BigInt64Array\")\nDEF(BigUint64Array, \"BigUint64Array\")\nDEF(Float32Array, \"Float32Array\")\nDEF(Float64Array, \"Float64Array\")\nDEF(DataView, \"DataView\")\nDEF(BigInt, \"BigInt\")\n#ifdef CONFIG_BIGNUM\nDEF(BigFloat, \"BigFloat\")\nDEF(BigFloatEnv, \"BigFloatEnv\")\nDEF(BigDecimal, \"BigDecimal\")\nDEF(OperatorSet, \"OperatorSet\")\nDEF(Operators, \"Operators\")\n#endif\nDEF(Map, \"Map\")\nDEF(Set, \"Set\") /* Map + 1 */\nDEF(WeakMap, \"WeakMap\") /* Map + 2 */\nDEF(WeakSet, \"WeakSet\") /* Map + 3 */\nDEF(Map_Iterator, \"Map Iterator\")\nDEF(Set_Iterator, \"Set Iterator\")\nDEF(Array_Iterator, \"Array Iterator\")\nDEF(String_Iterator, \"String Iterator\")\nDEF(RegExp_String_Iterator, \"RegExp String Iterator\")\nDEF(Generator, \"Generator\")\nDEF(Proxy, \"Proxy\")\nDEF(Promise, \"Promise\")\nDEF(PromiseResolveFunction, \"PromiseResolveFunction\")\nDEF(PromiseRejectFunction, \"PromiseRejectFunction\")\nDEF(AsyncFunction, \"AsyncFunction\")\nDEF(AsyncFunctionResolve, \"AsyncFunctionResolve\")\nDEF(AsyncFunctionReject, \"AsyncFunctionReject\")\nDEF(AsyncGeneratorFunction, \"AsyncGeneratorFunction\")\nDEF(AsyncGenerator, \"AsyncGenerator\")\nDEF(EvalError, \"EvalError\")\nDEF(RangeError, \"RangeError\")\nDEF(ReferenceError, \"ReferenceError\")\nDEF(SyntaxError, \"SyntaxError\")\nDEF(TypeError, \"TypeError\")\nDEF(URIError, \"URIError\")\nDEF(InternalError, \"InternalError\")\n/* private symbols */\nDEF(Private_brand, \"<brand>\")\n/* symbols */\nDEF(Symbol_toPrimitive, \"Symbol.toPrimitive\")\nDEF(Symbol_iterator, \"Symbol.iterator\")\nDEF(Symbol_match, \"Symbol.match\")\nDEF(Symbol_matchAll, \"Symbol.matchAll\")\nDEF(Symbol_replace, \"Symbol.replace\")\nDEF(Symbol_search, \"Symbol.search\")\nDEF(Symbol_split, \"Symbol.split\")\nDEF(Symbol_toStringTag, \"Symbol.toStringTag\")\nDEF(Symbol_isConcatSpreadable, \"Symbol.isConcatSpreadable\")\nDEF(Symbol_hasInstance, \"Symbol.hasInstance\")\nDEF(Symbol_species, \"Symbol.species\")\nDEF(Symbol_unscopables, \"Symbol.unscopables\")\nDEF(Symbol_asyncIterator, \"Symbol.asyncIterator\")\n#ifdef CONFIG_BIGNUM\nDEF(Symbol_operatorSet, \"Symbol.operatorSet\")\n#endif\n\n#endif /* DEF */\n"
        },
        {
          "name": "quickjs-libc.c",
          "type": "blob",
          "size": 112.36328125,
          "content": "/*\n * QuickJS C library\n *\n * Copyright (c) 2017-2021 Fabrice Bellard\n * Copyright (c) 2017-2021 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <string.h>\n#include <assert.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <time.h>\n#include <signal.h>\n#include <limits.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#if defined(_WIN32)\n#include <windows.h>\n#include <conio.h>\n#include <utime.h>\n#else\n#include <dlfcn.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n\n#if defined(__FreeBSD__)\nextern char **environ;\n#endif\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\ntypedef sig_t sighandler_t;\n#endif\n\n#if defined(__APPLE__)\n#if !defined(environ)\n#include <crt_externs.h>\n#define environ (*_NSGetEnviron())\n#endif\n#endif /* __APPLE__ */\n\n#endif\n\n#if !defined(_WIN32)\n/* enable the os.Worker API. IT relies on POSIX threads */\n#define USE_WORKER\n#endif\n\n#ifdef USE_WORKER\n#include <pthread.h>\n#include <stdatomic.h>\n#endif\n\n#include \"cutils.h\"\n#include \"list.h\"\n#include \"quickjs-libc.h\"\n\n#if !defined(PATH_MAX)\n#define PATH_MAX 4096\n#endif\n\n/* TODO:\n   - add socket calls\n*/\n\ntypedef struct {\n    struct list_head link;\n    int fd;\n    JSValue rw_func[2];\n} JSOSRWHandler;\n\ntypedef struct {\n    struct list_head link;\n    int sig_num;\n    JSValue func;\n} JSOSSignalHandler;\n\ntypedef struct {\n    struct list_head link;\n    int timer_id;\n    int64_t timeout;\n    JSValue func;\n} JSOSTimer;\n\ntypedef struct {\n    struct list_head link;\n    uint8_t *data;\n    size_t data_len;\n    /* list of SharedArrayBuffers, necessary to free the message */\n    uint8_t **sab_tab;\n    size_t sab_tab_len;\n} JSWorkerMessage;\n\ntypedef struct {\n    int ref_count;\n#ifdef USE_WORKER\n    pthread_mutex_t mutex;\n#endif\n    struct list_head msg_queue; /* list of JSWorkerMessage.link */\n    int read_fd;\n    int write_fd;\n} JSWorkerMessagePipe;\n\ntypedef struct {\n    struct list_head link;\n    JSWorkerMessagePipe *recv_pipe;\n    JSValue on_message_func;\n} JSWorkerMessageHandler;\n\ntypedef struct JSThreadState {\n    struct list_head os_rw_handlers; /* list of JSOSRWHandler.link */\n    struct list_head os_signal_handlers; /* list JSOSSignalHandler.link */\n    struct list_head os_timers; /* list of JSOSTimer.link */\n    struct list_head port_list; /* list of JSWorkerMessageHandler.link */\n    int eval_script_recurse; /* only used in the main thread */\n    int next_timer_id; /* for setTimeout() */\n    /* not used in the main thread */\n    JSWorkerMessagePipe *recv_pipe, *send_pipe;\n} JSThreadState;\n\nstatic uint64_t os_pending_signals;\nstatic int (*os_poll_func)(JSContext *ctx);\n\nstatic void js_std_dbuf_init(JSContext *ctx, DynBuf *s)\n{\n    dbuf_init2(s, JS_GetRuntime(ctx), (DynBufReallocFunc *)js_realloc_rt);\n}\n\nstatic BOOL my_isdigit(int c)\n{\n    return (c >= '0' && c <= '9');\n}\n\nstatic JSValue js_printf_internal(JSContext *ctx,\n                                  int argc, JSValueConst *argv, FILE *fp)\n{\n    char fmtbuf[32];\n    uint8_t cbuf[UTF8_CHAR_LEN_MAX+1];\n    JSValue res;\n    DynBuf dbuf;\n    const char *fmt_str = NULL;\n    const uint8_t *fmt, *fmt_end;\n    const uint8_t *p;\n    char *q;\n    int i, c, len, mod;\n    size_t fmt_len;\n    int32_t int32_arg;\n    int64_t int64_arg;\n    double double_arg;\n    const char *string_arg;\n    /* Use indirect call to dbuf_printf to prevent gcc warning */\n    int (*dbuf_printf_fun)(DynBuf *s, const char *fmt, ...) = (void*)dbuf_printf;\n\n    js_std_dbuf_init(ctx, &dbuf);\n\n    if (argc > 0) {\n        fmt_str = JS_ToCStringLen(ctx, &fmt_len, argv[0]);\n        if (!fmt_str)\n            goto fail;\n\n        i = 1;\n        fmt = (const uint8_t *)fmt_str;\n        fmt_end = fmt + fmt_len;\n        while (fmt < fmt_end) {\n            for (p = fmt; fmt < fmt_end && *fmt != '%'; fmt++)\n                continue;\n            dbuf_put(&dbuf, p, fmt - p);\n            if (fmt >= fmt_end)\n                break;\n            q = fmtbuf;\n            *q++ = *fmt++;  /* copy '%' */\n\n            /* flags */\n            for(;;) {\n                c = *fmt;\n                if (c == '0' || c == '#' || c == '+' || c == '-' || c == ' ' ||\n                    c == '\\'') {\n                    if (q >= fmtbuf + sizeof(fmtbuf) - 1)\n                        goto invalid;\n                    *q++ = c;\n                    fmt++;\n                } else {\n                    break;\n                }\n            }\n            /* width */\n            if (*fmt == '*') {\n                if (i >= argc)\n                    goto missing;\n                if (JS_ToInt32(ctx, &int32_arg, argv[i++]))\n                    goto fail;\n                q += snprintf(q, fmtbuf + sizeof(fmtbuf) - q, \"%d\", int32_arg);\n                fmt++;\n            } else {\n                while (my_isdigit(*fmt)) {\n                    if (q >= fmtbuf + sizeof(fmtbuf) - 1)\n                        goto invalid;\n                    *q++ = *fmt++;\n                }\n            }\n            if (*fmt == '.') {\n                if (q >= fmtbuf + sizeof(fmtbuf) - 1)\n                    goto invalid;\n                *q++ = *fmt++;\n                if (*fmt == '*') {\n                    if (i >= argc)\n                        goto missing;\n                    if (JS_ToInt32(ctx, &int32_arg, argv[i++]))\n                        goto fail;\n                    q += snprintf(q, fmtbuf + sizeof(fmtbuf) - q, \"%d\", int32_arg);\n                    fmt++;\n                } else {\n                    while (my_isdigit(*fmt)) {\n                        if (q >= fmtbuf + sizeof(fmtbuf) - 1)\n                            goto invalid;\n                        *q++ = *fmt++;\n                    }\n                }\n            }\n\n            /* we only support the \"l\" modifier for 64 bit numbers */\n            mod = ' ';\n            if (*fmt == 'l') {\n                mod = *fmt++;\n            }\n\n            /* type */\n            c = *fmt++;\n            if (q >= fmtbuf + sizeof(fmtbuf) - 1)\n                goto invalid;\n            *q++ = c;\n            *q = '\\0';\n\n            switch (c) {\n            case 'c':\n                if (i >= argc)\n                    goto missing;\n                if (JS_IsString(argv[i])) {\n                    string_arg = JS_ToCString(ctx, argv[i++]);\n                    if (!string_arg)\n                        goto fail;\n                    int32_arg = unicode_from_utf8((const uint8_t *)string_arg, UTF8_CHAR_LEN_MAX, &p);\n                    JS_FreeCString(ctx, string_arg);\n                } else {\n                    if (JS_ToInt32(ctx, &int32_arg, argv[i++]))\n                        goto fail;\n                }\n                /* handle utf-8 encoding explicitly */\n                if ((unsigned)int32_arg > 0x10FFFF)\n                    int32_arg = 0xFFFD;\n                /* ignore conversion flags, width and precision */\n                len = unicode_to_utf8(cbuf, int32_arg);\n                dbuf_put(&dbuf, cbuf, len);\n                break;\n\n            case 'd':\n            case 'i':\n            case 'o':\n            case 'u':\n            case 'x':\n            case 'X':\n                if (i >= argc)\n                    goto missing;\n                if (JS_ToInt64Ext(ctx, &int64_arg, argv[i++]))\n                    goto fail;\n                if (mod == 'l') {\n                    /* 64 bit number */\n#if defined(_WIN32)\n                    if (q >= fmtbuf + sizeof(fmtbuf) - 3)\n                        goto invalid;\n                    q[2] = q[-1];\n                    q[-1] = 'I';\n                    q[0] = '6';\n                    q[1] = '4';\n                    q[3] = '\\0';\n                    dbuf_printf_fun(&dbuf, fmtbuf, (int64_t)int64_arg);\n#else\n                    if (q >= fmtbuf + sizeof(fmtbuf) - 2)\n                        goto invalid;\n                    q[1] = q[-1];\n                    q[-1] = q[0] = 'l';\n                    q[2] = '\\0';\n                    dbuf_printf_fun(&dbuf, fmtbuf, (long long)int64_arg);\n#endif\n                } else {\n                    dbuf_printf_fun(&dbuf, fmtbuf, (int)int64_arg);\n                }\n                break;\n\n            case 's':\n                if (i >= argc)\n                    goto missing;\n                /* XXX: handle strings containing null characters */\n                string_arg = JS_ToCString(ctx, argv[i++]);\n                if (!string_arg)\n                    goto fail;\n                dbuf_printf_fun(&dbuf, fmtbuf, string_arg);\n                JS_FreeCString(ctx, string_arg);\n                break;\n\n            case 'e':\n            case 'f':\n            case 'g':\n            case 'a':\n            case 'E':\n            case 'F':\n            case 'G':\n            case 'A':\n                if (i >= argc)\n                    goto missing;\n                if (JS_ToFloat64(ctx, &double_arg, argv[i++]))\n                    goto fail;\n                dbuf_printf_fun(&dbuf, fmtbuf, double_arg);\n                break;\n\n            case '%':\n                dbuf_putc(&dbuf, '%');\n                break;\n\n            default:\n                /* XXX: should support an extension mechanism */\n            invalid:\n                JS_ThrowTypeError(ctx, \"invalid conversion specifier in format string\");\n                goto fail;\n            missing:\n                JS_ThrowReferenceError(ctx, \"missing argument for conversion specifier\");\n                goto fail;\n            }\n        }\n        JS_FreeCString(ctx, fmt_str);\n    }\n    if (dbuf.error) {\n        res = JS_ThrowOutOfMemory(ctx);\n    } else {\n        if (fp) {\n            len = fwrite(dbuf.buf, 1, dbuf.size, fp);\n            res = JS_NewInt32(ctx, len);\n        } else {\n            res = JS_NewStringLen(ctx, (char *)dbuf.buf, dbuf.size);\n        }\n    }\n    dbuf_free(&dbuf);\n    return res;\n\nfail:\n    JS_FreeCString(ctx, fmt_str);\n    dbuf_free(&dbuf);\n    return JS_EXCEPTION;\n}\n\nuint8_t *js_load_file(JSContext *ctx, size_t *pbuf_len, const char *filename)\n{\n    FILE *f;\n    uint8_t *buf;\n    size_t buf_len;\n    long lret;\n\n    f = fopen(filename, \"rb\");\n    if (!f)\n        return NULL;\n    if (fseek(f, 0, SEEK_END) < 0)\n        goto fail;\n    lret = ftell(f);\n    if (lret < 0)\n        goto fail;\n    /* XXX: on Linux, ftell() return LONG_MAX for directories */\n    if (lret == LONG_MAX) {\n        errno = EISDIR;\n        goto fail;\n    }\n    buf_len = lret;\n    if (fseek(f, 0, SEEK_SET) < 0)\n        goto fail;\n    if (ctx)\n        buf = js_malloc(ctx, buf_len + 1);\n    else\n        buf = malloc(buf_len + 1);\n    if (!buf)\n        goto fail;\n    if (fread(buf, 1, buf_len, f) != buf_len) {\n        errno = EIO;\n        if (ctx)\n            js_free(ctx, buf);\n        else\n            free(buf);\n    fail:\n        fclose(f);\n        return NULL;\n    }\n    buf[buf_len] = '\\0';\n    fclose(f);\n    *pbuf_len = buf_len;\n    return buf;\n}\n\n/* load and evaluate a file */\nstatic JSValue js_loadScript(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    uint8_t *buf;\n    const char *filename;\n    JSValue ret;\n    size_t buf_len;\n\n    filename = JS_ToCString(ctx, argv[0]);\n    if (!filename)\n        return JS_EXCEPTION;\n    buf = js_load_file(ctx, &buf_len, filename);\n    if (!buf) {\n        JS_ThrowReferenceError(ctx, \"could not load '%s'\", filename);\n        JS_FreeCString(ctx, filename);\n        return JS_EXCEPTION;\n    }\n    ret = JS_Eval(ctx, (char *)buf, buf_len, filename,\n                  JS_EVAL_TYPE_GLOBAL);\n    js_free(ctx, buf);\n    JS_FreeCString(ctx, filename);\n    return ret;\n}\n\n/* load a file as a UTF-8 encoded string */\nstatic JSValue js_std_loadFile(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    uint8_t *buf;\n    const char *filename;\n    JSValue ret;\n    size_t buf_len;\n\n    filename = JS_ToCString(ctx, argv[0]);\n    if (!filename)\n        return JS_EXCEPTION;\n    buf = js_load_file(ctx, &buf_len, filename);\n    JS_FreeCString(ctx, filename);\n    if (!buf)\n        return JS_NULL;\n    ret = JS_NewStringLen(ctx, (char *)buf, buf_len);\n    js_free(ctx, buf);\n    return ret;\n}\n\ntypedef JSModuleDef *(JSInitModuleFunc)(JSContext *ctx,\n                                        const char *module_name);\n\n\n#if defined(_WIN32)\nstatic JSModuleDef *js_module_loader_so(JSContext *ctx,\n                                        const char *module_name)\n{\n    JS_ThrowReferenceError(ctx, \"shared library modules are not supported yet\");\n    return NULL;\n}\n#else\nstatic JSModuleDef *js_module_loader_so(JSContext *ctx,\n                                        const char *module_name)\n{\n    JSModuleDef *m;\n    void *hd;\n    JSInitModuleFunc *init;\n    char *filename;\n\n    if (!strchr(module_name, '/')) {\n        /* must add a '/' so that the DLL is not searched in the\n           system library paths */\n        filename = js_malloc(ctx, strlen(module_name) + 2 + 1);\n        if (!filename)\n            return NULL;\n        strcpy(filename, \"./\");\n        strcpy(filename + 2, module_name);\n    } else {\n        filename = (char *)module_name;\n    }\n\n    /* C module */\n    hd = dlopen(filename, RTLD_NOW | RTLD_LOCAL);\n    if (filename != module_name)\n        js_free(ctx, filename);\n    if (!hd) {\n        JS_ThrowReferenceError(ctx, \"could not load module filename '%s' as shared library\",\n                               module_name);\n        goto fail;\n    }\n\n    init = dlsym(hd, \"js_init_module\");\n    if (!init) {\n        JS_ThrowReferenceError(ctx, \"could not load module filename '%s': js_init_module not found\",\n                               module_name);\n        goto fail;\n    }\n\n    m = init(ctx, module_name);\n    if (!m) {\n        JS_ThrowReferenceError(ctx, \"could not load module filename '%s': initialization error\",\n                               module_name);\n    fail:\n        if (hd)\n            dlclose(hd);\n        return NULL;\n    }\n    return m;\n}\n#endif /* !_WIN32 */\n\nint js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,\n                              JS_BOOL use_realpath, JS_BOOL is_main)\n{\n    JSModuleDef *m;\n    char buf[PATH_MAX + 16];\n    JSValue meta_obj;\n    JSAtom module_name_atom;\n    const char *module_name;\n\n    assert(JS_VALUE_GET_TAG(func_val) == JS_TAG_MODULE);\n    m = JS_VALUE_GET_PTR(func_val);\n\n    module_name_atom = JS_GetModuleName(ctx, m);\n    module_name = JS_AtomToCString(ctx, module_name_atom);\n    JS_FreeAtom(ctx, module_name_atom);\n    if (!module_name)\n        return -1;\n    if (!strchr(module_name, ':')) {\n        strcpy(buf, \"file://\");\n#if !defined(_WIN32)\n        /* realpath() cannot be used with modules compiled with qjsc\n           because the corresponding module source code is not\n           necessarily present */\n        if (use_realpath) {\n            char *res = realpath(module_name, buf + strlen(buf));\n            if (!res) {\n                JS_ThrowTypeError(ctx, \"realpath failure\");\n                JS_FreeCString(ctx, module_name);\n                return -1;\n            }\n        } else\n#endif\n        {\n            pstrcat(buf, sizeof(buf), module_name);\n        }\n    } else {\n        pstrcpy(buf, sizeof(buf), module_name);\n    }\n    JS_FreeCString(ctx, module_name);\n\n    meta_obj = JS_GetImportMeta(ctx, m);\n    if (JS_IsException(meta_obj))\n        return -1;\n    JS_DefinePropertyValueStr(ctx, meta_obj, \"url\",\n                              JS_NewString(ctx, buf),\n                              JS_PROP_C_W_E);\n    JS_DefinePropertyValueStr(ctx, meta_obj, \"main\",\n                              JS_NewBool(ctx, is_main),\n                              JS_PROP_C_W_E);\n    JS_FreeValue(ctx, meta_obj);\n    return 0;\n}\n\nJSModuleDef *js_module_loader(JSContext *ctx,\n                              const char *module_name, void *opaque)\n{\n    JSModuleDef *m;\n\n    if (has_suffix(module_name, \".so\")) {\n        m = js_module_loader_so(ctx, module_name);\n    } else {\n        size_t buf_len;\n        uint8_t *buf;\n        JSValue func_val;\n\n        buf = js_load_file(ctx, &buf_len, module_name);\n        if (!buf) {\n            JS_ThrowReferenceError(ctx, \"could not load module filename '%s'\",\n                                   module_name);\n            return NULL;\n        }\n\n        /* compile the module */\n        func_val = JS_Eval(ctx, (char *)buf, buf_len, module_name,\n                           JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);\n        js_free(ctx, buf);\n        if (JS_IsException(func_val))\n            return NULL;\n        /* XXX: could propagate the exception */\n        js_module_set_import_meta(ctx, func_val, TRUE, FALSE);\n        /* the module is already referenced, so we must free it */\n        m = JS_VALUE_GET_PTR(func_val);\n        JS_FreeValue(ctx, func_val);\n    }\n    return m;\n}\n\nstatic JSValue js_std_exit(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    int status;\n    if (JS_ToInt32(ctx, &status, argv[0]))\n        status = -1;\n    exit(status);\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_std_getenv(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    const char *name, *str;\n    name = JS_ToCString(ctx, argv[0]);\n    if (!name)\n        return JS_EXCEPTION;\n    str = getenv(name);\n    JS_FreeCString(ctx, name);\n    if (!str)\n        return JS_UNDEFINED;\n    else\n        return JS_NewString(ctx, str);\n}\n\n#if defined(_WIN32)\nstatic void setenv(const char *name, const char *value, int overwrite)\n{\n    char *str;\n    size_t name_len, value_len;\n    name_len = strlen(name);\n    value_len = strlen(value);\n    str = malloc(name_len + 1 + value_len + 1);\n    memcpy(str, name, name_len);\n    str[name_len] = '=';\n    memcpy(str + name_len + 1, value, value_len);\n    str[name_len + 1 + value_len] = '\\0';\n    _putenv(str);\n    free(str);\n}\n\nstatic void unsetenv(const char *name)\n{\n    setenv(name, \"\", TRUE);\n}\n#endif /* _WIN32 */\n\nstatic JSValue js_std_setenv(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    const char *name, *value;\n    name = JS_ToCString(ctx, argv[0]);\n    if (!name)\n        return JS_EXCEPTION;\n    value = JS_ToCString(ctx, argv[1]);\n    if (!value) {\n        JS_FreeCString(ctx, name);\n        return JS_EXCEPTION;\n    }\n    setenv(name, value, TRUE);\n    JS_FreeCString(ctx, name);\n    JS_FreeCString(ctx, value);\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_std_unsetenv(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    const char *name;\n    name = JS_ToCString(ctx, argv[0]);\n    if (!name)\n        return JS_EXCEPTION;\n    unsetenv(name);\n    JS_FreeCString(ctx, name);\n    return JS_UNDEFINED;\n}\n\n/* return an object containing the list of the available environment\n   variables. */\nstatic JSValue js_std_getenviron(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    char **envp;\n    const char *name, *p, *value;\n    JSValue obj;\n    uint32_t idx;\n    size_t name_len;\n    JSAtom atom;\n    int ret;\n\n    obj = JS_NewObject(ctx);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    envp = environ;\n    for(idx = 0; envp[idx] != NULL; idx++) {\n        name = envp[idx];\n        p = strchr(name, '=');\n        name_len = p - name;\n        if (!p)\n            continue;\n        value = p + 1;\n        atom = JS_NewAtomLen(ctx, name, name_len);\n        if (atom == JS_ATOM_NULL)\n            goto fail;\n        ret = JS_DefinePropertyValue(ctx, obj, atom, JS_NewString(ctx, value),\n                                     JS_PROP_C_W_E);\n        JS_FreeAtom(ctx, atom);\n        if (ret < 0)\n            goto fail;\n    }\n    return obj;\n fail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_std_gc(JSContext *ctx, JSValueConst this_val,\n                         int argc, JSValueConst *argv)\n{\n    JS_RunGC(JS_GetRuntime(ctx));\n    return JS_UNDEFINED;\n}\n\nstatic int interrupt_handler(JSRuntime *rt, void *opaque)\n{\n    return (os_pending_signals >> SIGINT) & 1;\n}\n\nstatic int get_bool_option(JSContext *ctx, BOOL *pbool,\n                           JSValueConst obj,\n                           const char *option)\n{\n    JSValue val;\n    val = JS_GetPropertyStr(ctx, obj, option);\n    if (JS_IsException(val))\n        return -1;\n    if (!JS_IsUndefined(val)) {\n        *pbool = JS_ToBool(ctx, val);\n    }\n    JS_FreeValue(ctx, val);\n    return 0;\n}\n\nstatic JSValue js_evalScript(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    JSRuntime *rt = JS_GetRuntime(ctx);\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    const char *str;\n    size_t len;\n    JSValue ret;\n    JSValueConst options_obj;\n    BOOL backtrace_barrier = FALSE;\n    BOOL is_async = FALSE;\n    int flags;\n\n    if (argc >= 2) {\n        options_obj = argv[1];\n        if (get_bool_option(ctx, &backtrace_barrier, options_obj,\n                            \"backtrace_barrier\"))\n            return JS_EXCEPTION;\n        if (get_bool_option(ctx, &is_async, options_obj,\n                            \"async\"))\n            return JS_EXCEPTION;\n    }\n\n    str = JS_ToCStringLen(ctx, &len, argv[0]);\n    if (!str)\n        return JS_EXCEPTION;\n    if (!ts->recv_pipe && ++ts->eval_script_recurse == 1) {\n        /* install the interrupt handler */\n        JS_SetInterruptHandler(JS_GetRuntime(ctx), interrupt_handler, NULL);\n    }\n    flags = JS_EVAL_TYPE_GLOBAL;\n    if (backtrace_barrier)\n        flags |= JS_EVAL_FLAG_BACKTRACE_BARRIER;\n    if (is_async)\n        flags |= JS_EVAL_FLAG_ASYNC;\n    ret = JS_Eval(ctx, str, len, \"<evalScript>\", flags);\n    JS_FreeCString(ctx, str);\n    if (!ts->recv_pipe && --ts->eval_script_recurse == 0) {\n        /* remove the interrupt handler */\n        JS_SetInterruptHandler(JS_GetRuntime(ctx), NULL, NULL);\n        os_pending_signals &= ~((uint64_t)1 << SIGINT);\n        /* convert the uncatchable \"interrupted\" error into a normal error\n           so that it can be caught by the REPL */\n        if (JS_IsException(ret))\n            JS_ResetUncatchableError(ctx);\n    }\n    return ret;\n}\n\nstatic JSClassID js_std_file_class_id;\n\ntypedef struct {\n    FILE *f;\n    BOOL close_in_finalizer;\n    BOOL is_popen;\n} JSSTDFile;\n\nstatic void js_std_file_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSSTDFile *s = JS_GetOpaque(val, js_std_file_class_id);\n    if (s) {\n        if (s->f && s->close_in_finalizer) {\n            if (s->is_popen)\n                pclose(s->f);\n            else\n                fclose(s->f);\n        }\n        js_free_rt(rt, s);\n    }\n}\n\nstatic ssize_t js_get_errno(ssize_t ret)\n{\n    if (ret == -1)\n        ret = -errno;\n    return ret;\n}\n\nstatic JSValue js_std_strerror(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv)\n{\n    int err;\n    if (JS_ToInt32(ctx, &err, argv[0]))\n        return JS_EXCEPTION;\n    return JS_NewString(ctx, strerror(err));\n}\n\nstatic JSValue js_std_parseExtJSON(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    JSValue obj;\n    const char *str;\n    size_t len;\n\n    str = JS_ToCStringLen(ctx, &len, argv[0]);\n    if (!str)\n        return JS_EXCEPTION;\n    obj = JS_ParseJSON2(ctx, str, len, \"<input>\", JS_PARSE_JSON_EXT);\n    JS_FreeCString(ctx, str);\n    return obj;\n}\n\nstatic JSValue js_new_std_file(JSContext *ctx, FILE *f,\n                               BOOL close_in_finalizer,\n                               BOOL is_popen)\n{\n    JSSTDFile *s;\n    JSValue obj;\n    obj = JS_NewObjectClass(ctx, js_std_file_class_id);\n    if (JS_IsException(obj))\n        return obj;\n    s = js_mallocz(ctx, sizeof(*s));\n    if (!s) {\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    s->close_in_finalizer = close_in_finalizer;\n    s->is_popen = is_popen;\n    s->f = f;\n    JS_SetOpaque(obj, s);\n    return obj;\n}\n\nstatic void js_set_error_object(JSContext *ctx, JSValue obj, int err)\n{\n    if (!JS_IsUndefined(obj)) {\n        JS_SetPropertyStr(ctx, obj, \"errno\", JS_NewInt32(ctx, err));\n    }\n}\n\nstatic JSValue js_std_open(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    const char *filename, *mode = NULL;\n    FILE *f;\n    int err;\n\n    filename = JS_ToCString(ctx, argv[0]);\n    if (!filename)\n        goto fail;\n    mode = JS_ToCString(ctx, argv[1]);\n    if (!mode)\n        goto fail;\n    if (mode[strspn(mode, \"rwa+b\")] != '\\0') {\n        JS_ThrowTypeError(ctx, \"invalid file mode\");\n        goto fail;\n    }\n\n    f = fopen(filename, mode);\n    if (!f)\n        err = errno;\n    else\n        err = 0;\n    if (argc >= 3)\n        js_set_error_object(ctx, argv[2], err);\n    JS_FreeCString(ctx, filename);\n    JS_FreeCString(ctx, mode);\n    if (!f)\n        return JS_NULL;\n    return js_new_std_file(ctx, f, TRUE, FALSE);\n fail:\n    JS_FreeCString(ctx, filename);\n    JS_FreeCString(ctx, mode);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_std_popen(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)\n{\n    const char *filename, *mode = NULL;\n    FILE *f;\n    int err;\n\n    filename = JS_ToCString(ctx, argv[0]);\n    if (!filename)\n        goto fail;\n    mode = JS_ToCString(ctx, argv[1]);\n    if (!mode)\n        goto fail;\n    if (mode[strspn(mode, \"rw\")] != '\\0') {\n        JS_ThrowTypeError(ctx, \"invalid file mode\");\n        goto fail;\n    }\n\n    f = popen(filename, mode);\n    if (!f)\n        err = errno;\n    else\n        err = 0;\n    if (argc >= 3)\n        js_set_error_object(ctx, argv[2], err);\n    JS_FreeCString(ctx, filename);\n    JS_FreeCString(ctx, mode);\n    if (!f)\n        return JS_NULL;\n    return js_new_std_file(ctx, f, TRUE, TRUE);\n fail:\n    JS_FreeCString(ctx, filename);\n    JS_FreeCString(ctx, mode);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_std_fdopen(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    const char *mode;\n    FILE *f;\n    int fd, err;\n\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    mode = JS_ToCString(ctx, argv[1]);\n    if (!mode)\n        goto fail;\n    if (mode[strspn(mode, \"rwa+\")] != '\\0') {\n        JS_ThrowTypeError(ctx, \"invalid file mode\");\n        goto fail;\n    }\n\n    f = fdopen(fd, mode);\n    if (!f)\n        err = errno;\n    else\n        err = 0;\n    if (argc >= 3)\n        js_set_error_object(ctx, argv[2], err);\n    JS_FreeCString(ctx, mode);\n    if (!f)\n        return JS_NULL;\n    return js_new_std_file(ctx, f, TRUE, FALSE);\n fail:\n    JS_FreeCString(ctx, mode);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_std_tmpfile(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    FILE *f;\n    f = tmpfile();\n    if (argc >= 1)\n        js_set_error_object(ctx, argv[0], f ? 0 : errno);\n    if (!f)\n        return JS_NULL;\n    return js_new_std_file(ctx, f, TRUE, FALSE);\n}\n\nstatic JSValue js_std_sprintf(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv)\n{\n    return js_printf_internal(ctx, argc, argv, NULL);\n}\n\nstatic JSValue js_std_printf(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    return js_printf_internal(ctx, argc, argv, stdout);\n}\n\nstatic FILE *js_std_file_get(JSContext *ctx, JSValueConst obj)\n{\n    JSSTDFile *s = JS_GetOpaque2(ctx, obj, js_std_file_class_id);\n    if (!s)\n        return NULL;\n    if (!s->f) {\n        JS_ThrowTypeError(ctx, \"invalid file handle\");\n        return NULL;\n    }\n    return s->f;\n}\n\nstatic JSValue js_std_file_puts(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv, int magic)\n{\n    FILE *f;\n    int i;\n    const char *str;\n    size_t len;\n\n    if (magic == 0) {\n        f = stdout;\n    } else {\n        f = js_std_file_get(ctx, this_val);\n        if (!f)\n            return JS_EXCEPTION;\n    }\n\n    for(i = 0; i < argc; i++) {\n        str = JS_ToCStringLen(ctx, &len, argv[i]);\n        if (!str)\n            return JS_EXCEPTION;\n        fwrite(str, 1, len, f);\n        JS_FreeCString(ctx, str);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_std_file_close(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    JSSTDFile *s = JS_GetOpaque2(ctx, this_val, js_std_file_class_id);\n    int err;\n    if (!s)\n        return JS_EXCEPTION;\n    if (!s->f)\n        return JS_ThrowTypeError(ctx, \"invalid file handle\");\n    if (s->is_popen)\n        err = js_get_errno(pclose(s->f));\n    else\n        err = js_get_errno(fclose(s->f));\n    s->f = NULL;\n    return JS_NewInt32(ctx, err);\n}\n\nstatic JSValue js_std_file_printf(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    if (!f)\n        return JS_EXCEPTION;\n    return js_printf_internal(ctx, argc, argv, f);\n}\n\nstatic JSValue js_std_file_flush(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    if (!f)\n        return JS_EXCEPTION;\n    fflush(f);\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_std_file_tell(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv, int is_bigint)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    int64_t pos;\n    if (!f)\n        return JS_EXCEPTION;\n#if defined(__linux__) || defined(__GLIBC__)\n    pos = ftello(f);\n#else\n    pos = ftell(f);\n#endif\n    if (is_bigint)\n        return JS_NewBigInt64(ctx, pos);\n    else\n        return JS_NewInt64(ctx, pos);\n}\n\nstatic JSValue js_std_file_seek(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    int64_t pos;\n    int whence, ret;\n    if (!f)\n        return JS_EXCEPTION;\n    if (JS_ToInt64Ext(ctx, &pos, argv[0]))\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &whence, argv[1]))\n        return JS_EXCEPTION;\n#if defined(__linux__) || defined(__GLIBC__)\n    ret = fseeko(f, pos, whence);\n#else\n    ret = fseek(f, pos, whence);\n#endif\n    if (ret < 0)\n        ret = -errno;\n    return JS_NewInt32(ctx, ret);\n}\n\nstatic JSValue js_std_file_eof(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    if (!f)\n        return JS_EXCEPTION;\n    return JS_NewBool(ctx, feof(f));\n}\n\nstatic JSValue js_std_file_error(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    if (!f)\n        return JS_EXCEPTION;\n    return JS_NewBool(ctx, ferror(f));\n}\n\nstatic JSValue js_std_file_clearerr(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    if (!f)\n        return JS_EXCEPTION;\n    clearerr(f);\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_std_file_fileno(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    if (!f)\n        return JS_EXCEPTION;\n    return JS_NewInt32(ctx, fileno(f));\n}\n\nstatic JSValue js_std_file_read_write(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv, int magic)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    uint64_t pos, len;\n    size_t size, ret;\n    uint8_t *buf;\n\n    if (!f)\n        return JS_EXCEPTION;\n    if (JS_ToIndex(ctx, &pos, argv[1]))\n        return JS_EXCEPTION;\n    if (JS_ToIndex(ctx, &len, argv[2]))\n        return JS_EXCEPTION;\n    buf = JS_GetArrayBuffer(ctx, &size, argv[0]);\n    if (!buf)\n        return JS_EXCEPTION;\n    if (pos + len > size)\n        return JS_ThrowRangeError(ctx, \"read/write array buffer overflow\");\n    if (magic)\n        ret = fwrite(buf + pos, 1, len, f);\n    else\n        ret = fread(buf + pos, 1, len, f);\n    return JS_NewInt64(ctx, ret);\n}\n\n/* XXX: could use less memory and go faster */\nstatic JSValue js_std_file_getline(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    int c;\n    DynBuf dbuf;\n    JSValue obj;\n\n    if (!f)\n        return JS_EXCEPTION;\n\n    js_std_dbuf_init(ctx, &dbuf);\n    for(;;) {\n        c = fgetc(f);\n        if (c == EOF) {\n            if (dbuf.size == 0) {\n                /* EOF */\n                dbuf_free(&dbuf);\n                return JS_NULL;\n            } else {\n                break;\n            }\n        }\n        if (c == '\\n')\n            break;\n        if (dbuf_putc(&dbuf, c)) {\n            dbuf_free(&dbuf);\n            return JS_ThrowOutOfMemory(ctx);\n        }\n    }\n    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);\n    dbuf_free(&dbuf);\n    return obj;\n}\n\n/* XXX: could use less memory and go faster */\nstatic JSValue js_std_file_readAsString(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    int c;\n    DynBuf dbuf;\n    JSValue obj;\n    uint64_t max_size64;\n    size_t max_size;\n    JSValueConst max_size_val;\n\n    if (!f)\n        return JS_EXCEPTION;\n\n    if (argc >= 1)\n        max_size_val = argv[0];\n    else\n        max_size_val = JS_UNDEFINED;\n    max_size = (size_t)-1;\n    if (!JS_IsUndefined(max_size_val)) {\n        if (JS_ToIndex(ctx, &max_size64, max_size_val))\n            return JS_EXCEPTION;\n        if (max_size64 < max_size)\n            max_size = max_size64;\n    }\n\n    js_std_dbuf_init(ctx, &dbuf);\n    while (max_size != 0) {\n        c = fgetc(f);\n        if (c == EOF)\n            break;\n        if (dbuf_putc(&dbuf, c)) {\n            dbuf_free(&dbuf);\n            return JS_EXCEPTION;\n        }\n        max_size--;\n    }\n    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);\n    dbuf_free(&dbuf);\n    return obj;\n}\n\nstatic JSValue js_std_file_getByte(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    if (!f)\n        return JS_EXCEPTION;\n    return JS_NewInt32(ctx, fgetc(f));\n}\n\nstatic JSValue js_std_file_putByte(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    FILE *f = js_std_file_get(ctx, this_val);\n    int c;\n    if (!f)\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &c, argv[0]))\n        return JS_EXCEPTION;\n    c = fputc(c, f);\n    return JS_NewInt32(ctx, c);\n}\n\n/* urlGet */\n\n#define URL_GET_PROGRAM \"curl -s -i --\"\n#define URL_GET_BUF_SIZE 4096\n\nstatic int http_get_header_line(FILE *f, char *buf, size_t buf_size,\n                                DynBuf *dbuf)\n{\n    int c;\n    char *p;\n\n    p = buf;\n    for(;;) {\n        c = fgetc(f);\n        if (c < 0)\n            return -1;\n        if ((p - buf) < buf_size - 1)\n            *p++ = c;\n        if (dbuf)\n            dbuf_putc(dbuf, c);\n        if (c == '\\n')\n            break;\n    }\n    *p = '\\0';\n    return 0;\n}\n\nstatic int http_get_status(const char *buf)\n{\n    const char *p = buf;\n    while (*p != ' ' && *p != '\\0')\n        p++;\n    if (*p != ' ')\n        return 0;\n    while (*p == ' ')\n        p++;\n    return atoi(p);\n}\n\nstatic JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    const char *url;\n    DynBuf cmd_buf;\n    DynBuf data_buf_s, *data_buf = &data_buf_s;\n    DynBuf header_buf_s, *header_buf = &header_buf_s;\n    char *buf;\n    size_t i, len;\n    int status;\n    JSValue response = JS_UNDEFINED, ret_obj;\n    JSValueConst options_obj;\n    FILE *f;\n    BOOL binary_flag, full_flag;\n\n    url = JS_ToCString(ctx, argv[0]);\n    if (!url)\n        return JS_EXCEPTION;\n\n    binary_flag = FALSE;\n    full_flag = FALSE;\n\n    if (argc >= 2) {\n        options_obj = argv[1];\n\n        if (get_bool_option(ctx, &binary_flag, options_obj, \"binary\"))\n            goto fail_obj;\n\n        if (get_bool_option(ctx, &full_flag, options_obj, \"full\")) {\n        fail_obj:\n            JS_FreeCString(ctx, url);\n            return JS_EXCEPTION;\n        }\n    }\n\n    js_std_dbuf_init(ctx, &cmd_buf);\n    dbuf_printf(&cmd_buf, \"%s '\", URL_GET_PROGRAM);\n    for(i = 0; url[i] != '\\0'; i++) {\n        unsigned char c = url[i];\n        switch (c) {\n        case '\\'':\n            /* shell single quoted string does not support \\' */\n            dbuf_putstr(&cmd_buf, \"'\\\\''\");\n            break;\n        case '[': case ']': case '{': case '}': case '\\\\':\n            /* prevent interpretation by curl as range or set specification */\n            dbuf_putc(&cmd_buf, '\\\\');\n            /* FALLTHROUGH */\n        default:\n            dbuf_putc(&cmd_buf, c);\n            break;\n        }\n    }\n    JS_FreeCString(ctx, url);\n    dbuf_putstr(&cmd_buf, \"'\");\n    dbuf_putc(&cmd_buf, '\\0');\n    if (dbuf_error(&cmd_buf)) {\n        dbuf_free(&cmd_buf);\n        return JS_EXCEPTION;\n    }\n    //    printf(\"%s\\n\", (char *)cmd_buf.buf);\n    f = popen((char *)cmd_buf.buf, \"r\");\n    dbuf_free(&cmd_buf);\n    if (!f) {\n        return JS_ThrowTypeError(ctx, \"could not start curl\");\n    }\n\n    js_std_dbuf_init(ctx, data_buf);\n    js_std_dbuf_init(ctx, header_buf);\n\n    buf = js_malloc(ctx, URL_GET_BUF_SIZE);\n    if (!buf)\n        goto fail;\n\n    /* get the HTTP status */\n    if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, NULL) < 0) {\n        status = 0;\n        goto bad_header;\n    }\n    status = http_get_status(buf);\n    if (!full_flag && !(status >= 200 && status <= 299)) {\n        goto bad_header;\n    }\n\n    /* wait until there is an empty line */\n    for(;;) {\n        if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, header_buf) < 0) {\n        bad_header:\n            response = JS_NULL;\n            goto done;\n        }\n        if (!strcmp(buf, \"\\r\\n\"))\n            break;\n    }\n    if (dbuf_error(header_buf))\n        goto fail;\n    header_buf->size -= 2; /* remove the trailing CRLF */\n\n    /* download the data */\n    for(;;) {\n        len = fread(buf, 1, URL_GET_BUF_SIZE, f);\n        if (len == 0)\n            break;\n        dbuf_put(data_buf, (uint8_t *)buf, len);\n    }\n    if (dbuf_error(data_buf))\n        goto fail;\n    if (binary_flag) {\n        response = JS_NewArrayBufferCopy(ctx,\n                                         data_buf->buf, data_buf->size);\n    } else {\n        response = JS_NewStringLen(ctx, (char *)data_buf->buf, data_buf->size);\n    }\n    if (JS_IsException(response))\n        goto fail;\n done:\n    js_free(ctx, buf);\n    buf = NULL;\n    pclose(f);\n    f = NULL;\n    dbuf_free(data_buf);\n    data_buf = NULL;\n\n    if (full_flag) {\n        ret_obj = JS_NewObject(ctx);\n        if (JS_IsException(ret_obj))\n            goto fail;\n        JS_DefinePropertyValueStr(ctx, ret_obj, \"response\",\n                                  response,\n                                  JS_PROP_C_W_E);\n        if (!JS_IsNull(response)) {\n            JS_DefinePropertyValueStr(ctx, ret_obj, \"responseHeaders\",\n                                      JS_NewStringLen(ctx, (char *)header_buf->buf,\n                                                      header_buf->size),\n                                      JS_PROP_C_W_E);\n            JS_DefinePropertyValueStr(ctx, ret_obj, \"status\",\n                                      JS_NewInt32(ctx, status),\n                                      JS_PROP_C_W_E);\n        }\n    } else {\n        ret_obj = response;\n    }\n    dbuf_free(header_buf);\n    return ret_obj;\n fail:\n    if (f)\n        pclose(f);\n    js_free(ctx, buf);\n    if (data_buf)\n        dbuf_free(data_buf);\n    if (header_buf)\n        dbuf_free(header_buf);\n    JS_FreeValue(ctx, response);\n    return JS_EXCEPTION;\n}\n\nstatic JSClassDef js_std_file_class = {\n    \"FILE\",\n    .finalizer = js_std_file_finalizer,\n};\n\nstatic const JSCFunctionListEntry js_std_error_props[] = {\n    /* various errno values */\n#define DEF(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )\n    DEF(EINVAL),\n    DEF(EIO),\n    DEF(EACCES),\n    DEF(EEXIST),\n    DEF(ENOSPC),\n    DEF(ENOSYS),\n    DEF(EBUSY),\n    DEF(ENOENT),\n    DEF(EPERM),\n    DEF(EPIPE),\n    DEF(EBADF),\n#undef DEF\n};\n\nstatic const JSCFunctionListEntry js_std_funcs[] = {\n    JS_CFUNC_DEF(\"exit\", 1, js_std_exit ),\n    JS_CFUNC_DEF(\"gc\", 0, js_std_gc ),\n    JS_CFUNC_DEF(\"evalScript\", 1, js_evalScript ),\n    JS_CFUNC_DEF(\"loadScript\", 1, js_loadScript ),\n    JS_CFUNC_DEF(\"getenv\", 1, js_std_getenv ),\n    JS_CFUNC_DEF(\"setenv\", 1, js_std_setenv ),\n    JS_CFUNC_DEF(\"unsetenv\", 1, js_std_unsetenv ),\n    JS_CFUNC_DEF(\"getenviron\", 1, js_std_getenviron ),\n    JS_CFUNC_DEF(\"urlGet\", 1, js_std_urlGet ),\n    JS_CFUNC_DEF(\"loadFile\", 1, js_std_loadFile ),\n    JS_CFUNC_DEF(\"strerror\", 1, js_std_strerror ),\n    JS_CFUNC_DEF(\"parseExtJSON\", 1, js_std_parseExtJSON ),\n\n    /* FILE I/O */\n    JS_CFUNC_DEF(\"open\", 2, js_std_open ),\n    JS_CFUNC_DEF(\"popen\", 2, js_std_popen ),\n    JS_CFUNC_DEF(\"fdopen\", 2, js_std_fdopen ),\n    JS_CFUNC_DEF(\"tmpfile\", 0, js_std_tmpfile ),\n    JS_CFUNC_MAGIC_DEF(\"puts\", 1, js_std_file_puts, 0 ),\n    JS_CFUNC_DEF(\"printf\", 1, js_std_printf ),\n    JS_CFUNC_DEF(\"sprintf\", 1, js_std_sprintf ),\n    JS_PROP_INT32_DEF(\"SEEK_SET\", SEEK_SET, JS_PROP_CONFIGURABLE ),\n    JS_PROP_INT32_DEF(\"SEEK_CUR\", SEEK_CUR, JS_PROP_CONFIGURABLE ),\n    JS_PROP_INT32_DEF(\"SEEK_END\", SEEK_END, JS_PROP_CONFIGURABLE ),\n    JS_OBJECT_DEF(\"Error\", js_std_error_props, countof(js_std_error_props), JS_PROP_CONFIGURABLE),\n};\n\nstatic const JSCFunctionListEntry js_std_file_proto_funcs[] = {\n    JS_CFUNC_DEF(\"close\", 0, js_std_file_close ),\n    JS_CFUNC_MAGIC_DEF(\"puts\", 1, js_std_file_puts, 1 ),\n    JS_CFUNC_DEF(\"printf\", 1, js_std_file_printf ),\n    JS_CFUNC_DEF(\"flush\", 0, js_std_file_flush ),\n    JS_CFUNC_MAGIC_DEF(\"tell\", 0, js_std_file_tell, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"tello\", 0, js_std_file_tell, 1 ),\n    JS_CFUNC_DEF(\"seek\", 2, js_std_file_seek ),\n    JS_CFUNC_DEF(\"eof\", 0, js_std_file_eof ),\n    JS_CFUNC_DEF(\"fileno\", 0, js_std_file_fileno ),\n    JS_CFUNC_DEF(\"error\", 0, js_std_file_error ),\n    JS_CFUNC_DEF(\"clearerr\", 0, js_std_file_clearerr ),\n    JS_CFUNC_MAGIC_DEF(\"read\", 3, js_std_file_read_write, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"write\", 3, js_std_file_read_write, 1 ),\n    JS_CFUNC_DEF(\"getline\", 0, js_std_file_getline ),\n    JS_CFUNC_DEF(\"readAsString\", 0, js_std_file_readAsString ),\n    JS_CFUNC_DEF(\"getByte\", 0, js_std_file_getByte ),\n    JS_CFUNC_DEF(\"putByte\", 1, js_std_file_putByte ),\n    /* setvbuf, ...  */\n};\n\nstatic int js_std_init(JSContext *ctx, JSModuleDef *m)\n{\n    JSValue proto;\n\n    /* FILE class */\n    /* the class ID is created once */\n    JS_NewClassID(&js_std_file_class_id);\n    /* the class is created once per runtime */\n    JS_NewClass(JS_GetRuntime(ctx), js_std_file_class_id, &js_std_file_class);\n    proto = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, proto, js_std_file_proto_funcs,\n                               countof(js_std_file_proto_funcs));\n    JS_SetClassProto(ctx, js_std_file_class_id, proto);\n\n    JS_SetModuleExportList(ctx, m, js_std_funcs,\n                           countof(js_std_funcs));\n    JS_SetModuleExport(ctx, m, \"in\", js_new_std_file(ctx, stdin, FALSE, FALSE));\n    JS_SetModuleExport(ctx, m, \"out\", js_new_std_file(ctx, stdout, FALSE, FALSE));\n    JS_SetModuleExport(ctx, m, \"err\", js_new_std_file(ctx, stderr, FALSE, FALSE));\n    return 0;\n}\n\nJSModuleDef *js_init_module_std(JSContext *ctx, const char *module_name)\n{\n    JSModuleDef *m;\n    m = JS_NewCModule(ctx, module_name, js_std_init);\n    if (!m)\n        return NULL;\n    JS_AddModuleExportList(ctx, m, js_std_funcs, countof(js_std_funcs));\n    JS_AddModuleExport(ctx, m, \"in\");\n    JS_AddModuleExport(ctx, m, \"out\");\n    JS_AddModuleExport(ctx, m, \"err\");\n    return m;\n}\n\n/**********************************************************/\n/* 'os' object */\n\nstatic JSValue js_os_open(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv)\n{\n    const char *filename;\n    int flags, mode, ret;\n\n    filename = JS_ToCString(ctx, argv[0]);\n    if (!filename)\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &flags, argv[1]))\n        goto fail;\n    if (argc >= 3 && !JS_IsUndefined(argv[2])) {\n        if (JS_ToInt32(ctx, &mode, argv[2])) {\n        fail:\n            JS_FreeCString(ctx, filename);\n            return JS_EXCEPTION;\n        }\n    } else {\n        mode = 0666;\n    }\n#if defined(_WIN32)\n    /* force binary mode by default */\n    if (!(flags & O_TEXT))\n        flags |= O_BINARY;\n#endif\n    ret = js_get_errno(open(filename, flags, mode));\n    JS_FreeCString(ctx, filename);\n    return JS_NewInt32(ctx, ret);\n}\n\nstatic JSValue js_os_close(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    int fd, ret;\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    ret = js_get_errno(close(fd));\n    return JS_NewInt32(ctx, ret);\n}\n\nstatic JSValue js_os_seek(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv)\n{\n    int fd, whence;\n    int64_t pos, ret;\n    BOOL is_bigint;\n\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    is_bigint = JS_IsBigInt(ctx, argv[1]);\n    if (JS_ToInt64Ext(ctx, &pos, argv[1]))\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &whence, argv[2]))\n        return JS_EXCEPTION;\n    ret = lseek(fd, pos, whence);\n    if (ret == -1)\n        ret = -errno;\n    if (is_bigint)\n        return JS_NewBigInt64(ctx, ret);\n    else\n        return JS_NewInt64(ctx, ret);\n}\n\nstatic JSValue js_os_read_write(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv, int magic)\n{\n    int fd;\n    uint64_t pos, len;\n    size_t size;\n    ssize_t ret;\n    uint8_t *buf;\n\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    if (JS_ToIndex(ctx, &pos, argv[2]))\n        return JS_EXCEPTION;\n    if (JS_ToIndex(ctx, &len, argv[3]))\n        return JS_EXCEPTION;\n    buf = JS_GetArrayBuffer(ctx, &size, argv[1]);\n    if (!buf)\n        return JS_EXCEPTION;\n    if (pos + len > size)\n        return JS_ThrowRangeError(ctx, \"read/write array buffer overflow\");\n    if (magic)\n        ret = js_get_errno(write(fd, buf + pos, len));\n    else\n        ret = js_get_errno(read(fd, buf + pos, len));\n    return JS_NewInt64(ctx, ret);\n}\n\nstatic JSValue js_os_isatty(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)\n{\n    int fd;\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    return JS_NewBool(ctx, isatty(fd));\n}\n\n#if defined(_WIN32)\nstatic JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    int fd;\n    HANDLE handle;\n    CONSOLE_SCREEN_BUFFER_INFO info;\n    JSValue obj;\n\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    handle = (HANDLE)_get_osfhandle(fd);\n\n    if (!GetConsoleScreenBufferInfo(handle, &info))\n        return JS_NULL;\n    obj = JS_NewArray(ctx);\n    if (JS_IsException(obj))\n        return obj;\n    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, info.dwSize.X), JS_PROP_C_W_E);\n    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, info.dwSize.Y), JS_PROP_C_W_E);\n    return obj;\n}\n\n/* Windows 10 built-in VT100 emulation */\n#define __ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004\n#define __ENABLE_VIRTUAL_TERMINAL_INPUT 0x0200\n\nstatic JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    int fd;\n    HANDLE handle;\n\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    handle = (HANDLE)_get_osfhandle(fd);\n    SetConsoleMode(handle, ENABLE_WINDOW_INPUT | __ENABLE_VIRTUAL_TERMINAL_INPUT);\n    _setmode(fd, _O_BINARY);\n    if (fd == 0) {\n        handle = (HANDLE)_get_osfhandle(1); /* corresponding output */\n        SetConsoleMode(handle, ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT | __ENABLE_VIRTUAL_TERMINAL_PROCESSING);\n    }\n    return JS_UNDEFINED;\n}\n#else\nstatic JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    int fd;\n    struct winsize ws;\n    JSValue obj;\n\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    if (ioctl(fd, TIOCGWINSZ, &ws) == 0 &&\n        ws.ws_col >= 4 && ws.ws_row >= 4) {\n        obj = JS_NewArray(ctx);\n        if (JS_IsException(obj))\n            return obj;\n        JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, ws.ws_col), JS_PROP_C_W_E);\n        JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, ws.ws_row), JS_PROP_C_W_E);\n        return obj;\n    } else {\n        return JS_NULL;\n    }\n}\n\nstatic struct termios oldtty;\n\nstatic void term_exit(void)\n{\n    tcsetattr(0, TCSANOW, &oldtty);\n}\n\n/* XXX: should add a way to go back to normal mode */\nstatic JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv)\n{\n    struct termios tty;\n    int fd;\n\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n\n    memset(&tty, 0, sizeof(tty));\n    tcgetattr(fd, &tty);\n    oldtty = tty;\n\n    tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP\n                          |INLCR|IGNCR|ICRNL|IXON);\n    tty.c_oflag |= OPOST;\n    tty.c_lflag &= ~(ECHO|ECHONL|ICANON|IEXTEN);\n    tty.c_cflag &= ~(CSIZE|PARENB);\n    tty.c_cflag |= CS8;\n    tty.c_cc[VMIN] = 1;\n    tty.c_cc[VTIME] = 0;\n\n    tcsetattr(fd, TCSANOW, &tty);\n\n    atexit(term_exit);\n    return JS_UNDEFINED;\n}\n\n#endif /* !_WIN32 */\n\nstatic JSValue js_os_remove(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)\n{\n    const char *filename;\n    int ret;\n\n    filename = JS_ToCString(ctx, argv[0]);\n    if (!filename)\n        return JS_EXCEPTION;\n#if defined(_WIN32)\n    {\n        struct stat st;\n        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {\n            ret = rmdir(filename);\n        } else {\n            ret = unlink(filename);\n        }\n    }\n#else\n    ret = remove(filename);\n#endif\n    ret = js_get_errno(ret);\n    JS_FreeCString(ctx, filename);\n    return JS_NewInt32(ctx, ret);\n}\n\nstatic JSValue js_os_rename(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)\n{\n    const char *oldpath, *newpath;\n    int ret;\n\n    oldpath = JS_ToCString(ctx, argv[0]);\n    if (!oldpath)\n        return JS_EXCEPTION;\n    newpath = JS_ToCString(ctx, argv[1]);\n    if (!newpath) {\n        JS_FreeCString(ctx, oldpath);\n        return JS_EXCEPTION;\n    }\n    ret = js_get_errno(rename(oldpath, newpath));\n    JS_FreeCString(ctx, oldpath);\n    JS_FreeCString(ctx, newpath);\n    return JS_NewInt32(ctx, ret);\n}\n\nstatic BOOL is_main_thread(JSRuntime *rt)\n{\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    return !ts->recv_pipe;\n}\n\nstatic JSOSRWHandler *find_rh(JSThreadState *ts, int fd)\n{\n    JSOSRWHandler *rh;\n    struct list_head *el;\n\n    list_for_each(el, &ts->os_rw_handlers) {\n        rh = list_entry(el, JSOSRWHandler, link);\n        if (rh->fd == fd)\n            return rh;\n    }\n    return NULL;\n}\n\nstatic void free_rw_handler(JSRuntime *rt, JSOSRWHandler *rh)\n{\n    int i;\n    list_del(&rh->link);\n    for(i = 0; i < 2; i++) {\n        JS_FreeValueRT(rt, rh->rw_func[i]);\n    }\n    js_free_rt(rt, rh);\n}\n\nstatic JSValue js_os_setReadHandler(JSContext *ctx, JSValueConst this_val,\n                                    int argc, JSValueConst *argv, int magic)\n{\n    JSRuntime *rt = JS_GetRuntime(ctx);\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    JSOSRWHandler *rh;\n    int fd;\n    JSValueConst func;\n\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    func = argv[1];\n    if (JS_IsNull(func)) {\n        rh = find_rh(ts, fd);\n        if (rh) {\n            JS_FreeValue(ctx, rh->rw_func[magic]);\n            rh->rw_func[magic] = JS_NULL;\n            if (JS_IsNull(rh->rw_func[0]) &&\n                JS_IsNull(rh->rw_func[1])) {\n                /* remove the entry */\n                free_rw_handler(JS_GetRuntime(ctx), rh);\n            }\n        }\n    } else {\n        if (!JS_IsFunction(ctx, func))\n            return JS_ThrowTypeError(ctx, \"not a function\");\n        rh = find_rh(ts, fd);\n        if (!rh) {\n            rh = js_mallocz(ctx, sizeof(*rh));\n            if (!rh)\n                return JS_EXCEPTION;\n            rh->fd = fd;\n            rh->rw_func[0] = JS_NULL;\n            rh->rw_func[1] = JS_NULL;\n            list_add_tail(&rh->link, &ts->os_rw_handlers);\n        }\n        JS_FreeValue(ctx, rh->rw_func[magic]);\n        rh->rw_func[magic] = JS_DupValue(ctx, func);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSOSSignalHandler *find_sh(JSThreadState *ts, int sig_num)\n{\n    JSOSSignalHandler *sh;\n    struct list_head *el;\n    list_for_each(el, &ts->os_signal_handlers) {\n        sh = list_entry(el, JSOSSignalHandler, link);\n        if (sh->sig_num == sig_num)\n            return sh;\n    }\n    return NULL;\n}\n\nstatic void free_sh(JSRuntime *rt, JSOSSignalHandler *sh)\n{\n    list_del(&sh->link);\n    JS_FreeValueRT(rt, sh->func);\n    js_free_rt(rt, sh);\n}\n\nstatic void os_signal_handler(int sig_num)\n{\n    os_pending_signals |= ((uint64_t)1 << sig_num);\n}\n\n#if defined(_WIN32)\ntypedef void (*sighandler_t)(int sig_num);\n#endif\n\nstatic JSValue js_os_signal(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)\n{\n    JSRuntime *rt = JS_GetRuntime(ctx);\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    JSOSSignalHandler *sh;\n    uint32_t sig_num;\n    JSValueConst func;\n    sighandler_t handler;\n\n    if (!is_main_thread(rt))\n        return JS_ThrowTypeError(ctx, \"signal handler can only be set in the main thread\");\n\n    if (JS_ToUint32(ctx, &sig_num, argv[0]))\n        return JS_EXCEPTION;\n    if (sig_num >= 64)\n        return JS_ThrowRangeError(ctx, \"invalid signal number\");\n    func = argv[1];\n    /* func = null: SIG_DFL, func = undefined, SIG_IGN */\n    if (JS_IsNull(func) || JS_IsUndefined(func)) {\n        sh = find_sh(ts, sig_num);\n        if (sh) {\n            free_sh(JS_GetRuntime(ctx), sh);\n        }\n        if (JS_IsNull(func))\n            handler = SIG_DFL;\n        else\n            handler = SIG_IGN;\n        signal(sig_num, handler);\n    } else {\n        if (!JS_IsFunction(ctx, func))\n            return JS_ThrowTypeError(ctx, \"not a function\");\n        sh = find_sh(ts, sig_num);\n        if (!sh) {\n            sh = js_mallocz(ctx, sizeof(*sh));\n            if (!sh)\n                return JS_EXCEPTION;\n            sh->sig_num = sig_num;\n            list_add_tail(&sh->link, &ts->os_signal_handlers);\n        }\n        JS_FreeValue(ctx, sh->func);\n        sh->func = JS_DupValue(ctx, func);\n        signal(sig_num, os_signal_handler);\n    }\n    return JS_UNDEFINED;\n}\n\n#if defined(__linux__) || defined(__APPLE__)\nstatic int64_t get_time_ms(void)\n{\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return (uint64_t)ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);\n}\n\nstatic int64_t get_time_ns(void)\n{\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return (uint64_t)ts.tv_sec * 1000000000 + ts.tv_nsec;\n}\n#else\n/* more portable, but does not work if the date is updated */\nstatic int64_t get_time_ms(void)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);\n}\n\nstatic int64_t get_time_ns(void)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (int64_t)tv.tv_sec * 1000000000 + (tv.tv_usec * 1000);\n}\n#endif\n\nstatic JSValue js_os_now(JSContext *ctx, JSValue this_val,\n                         int argc, JSValue *argv)\n{\n    return JS_NewFloat64(ctx, (double)get_time_ns() / 1e6);\n}\n\nstatic void free_timer(JSRuntime *rt, JSOSTimer *th)\n{\n    list_del(&th->link);\n    JS_FreeValueRT(rt, th->func);\n    js_free_rt(rt, th);\n}\n\nstatic JSValue js_os_setTimeout(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSRuntime *rt = JS_GetRuntime(ctx);\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    int64_t delay;\n    JSValueConst func;\n    JSOSTimer *th;\n\n    func = argv[0];\n    if (!JS_IsFunction(ctx, func))\n        return JS_ThrowTypeError(ctx, \"not a function\");\n    if (JS_ToInt64(ctx, &delay, argv[1]))\n        return JS_EXCEPTION;\n    th = js_mallocz(ctx, sizeof(*th));\n    if (!th)\n        return JS_EXCEPTION;\n    th->timer_id = ts->next_timer_id;\n    if (ts->next_timer_id == INT32_MAX)\n        ts->next_timer_id = 1;\n    else\n        ts->next_timer_id++;\n    th->timeout = get_time_ms() + delay;\n    th->func = JS_DupValue(ctx, func);\n    list_add_tail(&th->link, &ts->os_timers);\n    return JS_NewInt32(ctx, th->timer_id);\n}\n\nstatic JSOSTimer *find_timer_by_id(JSThreadState *ts, int timer_id)\n{\n    struct list_head *el;\n    if (timer_id <= 0)\n        return NULL;\n    list_for_each(el, &ts->os_timers) {\n        JSOSTimer *th = list_entry(el, JSOSTimer, link);\n        if (th->timer_id == timer_id)\n            return th;\n    }\n    return NULL;\n}\n\nstatic JSValue js_os_clearTimeout(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv)\n{\n    JSRuntime *rt = JS_GetRuntime(ctx);\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    JSOSTimer *th;\n    int timer_id;\n\n    if (JS_ToInt32(ctx, &timer_id, argv[0]))\n        return JS_EXCEPTION;\n    th = find_timer_by_id(ts, timer_id);\n    if (!th)\n        return JS_UNDEFINED;\n    free_timer(rt, th);\n    return JS_UNDEFINED;\n}\n\n/* return a promise */\nstatic JSValue js_os_sleepAsync(JSContext *ctx, JSValueConst this_val,\n                                int argc, JSValueConst *argv)\n{\n    JSRuntime *rt = JS_GetRuntime(ctx);\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    int64_t delay;\n    JSOSTimer *th;\n    JSValue promise, resolving_funcs[2];\n\n    if (JS_ToInt64(ctx, &delay, argv[0]))\n        return JS_EXCEPTION;\n    promise = JS_NewPromiseCapability(ctx, resolving_funcs);\n    if (JS_IsException(promise))\n        return JS_EXCEPTION;\n\n    th = js_mallocz(ctx, sizeof(*th));\n    if (!th) {\n        JS_FreeValue(ctx, promise);\n        JS_FreeValue(ctx, resolving_funcs[0]);\n        JS_FreeValue(ctx, resolving_funcs[1]);\n        return JS_EXCEPTION;\n    }\n    th->timer_id = -1;\n    th->timeout = get_time_ms() + delay;\n    th->func = JS_DupValue(ctx, resolving_funcs[0]);\n    list_add_tail(&th->link, &ts->os_timers);\n    JS_FreeValue(ctx, resolving_funcs[0]);\n    JS_FreeValue(ctx, resolving_funcs[1]);\n    return promise;\n}\n\nstatic void call_handler(JSContext *ctx, JSValueConst func)\n{\n    JSValue ret, func1;\n    /* 'func' might be destroyed when calling itself (if it frees the\n       handler), so must take extra care */\n    func1 = JS_DupValue(ctx, func);\n    ret = JS_Call(ctx, func1, JS_UNDEFINED, 0, NULL);\n    JS_FreeValue(ctx, func1);\n    if (JS_IsException(ret))\n        js_std_dump_error(ctx);\n    JS_FreeValue(ctx, ret);\n}\n\n#if defined(_WIN32)\n\nstatic int js_os_poll(JSContext *ctx)\n{\n    JSRuntime *rt = JS_GetRuntime(ctx);\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    int min_delay, console_fd;\n    int64_t cur_time, delay;\n    JSOSRWHandler *rh;\n    struct list_head *el;\n\n    /* XXX: handle signals if useful */\n\n    if (list_empty(&ts->os_rw_handlers) && list_empty(&ts->os_timers))\n        return -1; /* no more events */\n\n    /* XXX: only timers and basic console input are supported */\n    if (!list_empty(&ts->os_timers)) {\n        cur_time = get_time_ms();\n        min_delay = 10000;\n        list_for_each(el, &ts->os_timers) {\n            JSOSTimer *th = list_entry(el, JSOSTimer, link);\n            delay = th->timeout - cur_time;\n            if (delay <= 0) {\n                JSValue func;\n                /* the timer expired */\n                func = th->func;\n                th->func = JS_UNDEFINED;\n                free_timer(rt, th);\n                call_handler(ctx, func);\n                JS_FreeValue(ctx, func);\n                return 0;\n            } else if (delay < min_delay) {\n                min_delay = delay;\n            }\n        }\n    } else {\n        min_delay = -1;\n    }\n\n    console_fd = -1;\n    list_for_each(el, &ts->os_rw_handlers) {\n        rh = list_entry(el, JSOSRWHandler, link);\n        if (rh->fd == 0 && !JS_IsNull(rh->rw_func[0])) {\n            console_fd = rh->fd;\n            break;\n        }\n    }\n\n    if (console_fd >= 0) {\n        DWORD ti, ret;\n        HANDLE handle;\n        if (min_delay == -1)\n            ti = INFINITE;\n        else\n            ti = min_delay;\n        handle = (HANDLE)_get_osfhandle(console_fd);\n        ret = WaitForSingleObject(handle, ti);\n        if (ret == WAIT_OBJECT_0) {\n            list_for_each(el, &ts->os_rw_handlers) {\n                rh = list_entry(el, JSOSRWHandler, link);\n                if (rh->fd == console_fd && !JS_IsNull(rh->rw_func[0])) {\n                    call_handler(ctx, rh->rw_func[0]);\n                    /* must stop because the list may have been modified */\n                    break;\n                }\n            }\n        }\n    } else {\n        Sleep(min_delay);\n    }\n    return 0;\n}\n#else\n\n#ifdef USE_WORKER\n\nstatic void js_free_message(JSWorkerMessage *msg);\n\n/* return 1 if a message was handled, 0 if no message */\nstatic int handle_posted_message(JSRuntime *rt, JSContext *ctx,\n                                 JSWorkerMessageHandler *port)\n{\n    JSWorkerMessagePipe *ps = port->recv_pipe;\n    int ret;\n    struct list_head *el;\n    JSWorkerMessage *msg;\n    JSValue obj, data_obj, func, retval;\n\n    pthread_mutex_lock(&ps->mutex);\n    if (!list_empty(&ps->msg_queue)) {\n        el = ps->msg_queue.next;\n        msg = list_entry(el, JSWorkerMessage, link);\n\n        /* remove the message from the queue */\n        list_del(&msg->link);\n\n        if (list_empty(&ps->msg_queue)) {\n            uint8_t buf[16];\n            int ret;\n            for(;;) {\n                ret = read(ps->read_fd, buf, sizeof(buf));\n                if (ret >= 0)\n                    break;\n                if (errno != EAGAIN && errno != EINTR)\n                    break;\n            }\n        }\n\n        pthread_mutex_unlock(&ps->mutex);\n\n        data_obj = JS_ReadObject(ctx, msg->data, msg->data_len,\n                                 JS_READ_OBJ_SAB | JS_READ_OBJ_REFERENCE);\n\n        js_free_message(msg);\n\n        if (JS_IsException(data_obj))\n            goto fail;\n        obj = JS_NewObject(ctx);\n        if (JS_IsException(obj)) {\n            JS_FreeValue(ctx, data_obj);\n            goto fail;\n        }\n        JS_DefinePropertyValueStr(ctx, obj, \"data\", data_obj, JS_PROP_C_W_E);\n\n        /* 'func' might be destroyed when calling itself (if it frees the\n           handler), so must take extra care */\n        func = JS_DupValue(ctx, port->on_message_func);\n        retval = JS_Call(ctx, func, JS_UNDEFINED, 1, (JSValueConst *)&obj);\n        JS_FreeValue(ctx, obj);\n        JS_FreeValue(ctx, func);\n        if (JS_IsException(retval)) {\n        fail:\n            js_std_dump_error(ctx);\n        } else {\n            JS_FreeValue(ctx, retval);\n        }\n        ret = 1;\n    } else {\n        pthread_mutex_unlock(&ps->mutex);\n        ret = 0;\n    }\n    return ret;\n}\n#else\nstatic int handle_posted_message(JSRuntime *rt, JSContext *ctx,\n                                 JSWorkerMessageHandler *port)\n{\n    return 0;\n}\n#endif\n\nstatic int js_os_poll(JSContext *ctx)\n{\n    JSRuntime *rt = JS_GetRuntime(ctx);\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    int ret, fd_max, min_delay;\n    int64_t cur_time, delay;\n    fd_set rfds, wfds;\n    JSOSRWHandler *rh;\n    struct list_head *el;\n    struct timeval tv, *tvp;\n\n    /* only check signals in the main thread */\n    if (!ts->recv_pipe &&\n        unlikely(os_pending_signals != 0)) {\n        JSOSSignalHandler *sh;\n        uint64_t mask;\n\n        list_for_each(el, &ts->os_signal_handlers) {\n            sh = list_entry(el, JSOSSignalHandler, link);\n            mask = (uint64_t)1 << sh->sig_num;\n            if (os_pending_signals & mask) {\n                os_pending_signals &= ~mask;\n                call_handler(ctx, sh->func);\n                return 0;\n            }\n        }\n    }\n\n    if (list_empty(&ts->os_rw_handlers) && list_empty(&ts->os_timers) &&\n        list_empty(&ts->port_list))\n        return -1; /* no more events */\n\n    if (!list_empty(&ts->os_timers)) {\n        cur_time = get_time_ms();\n        min_delay = 10000;\n        list_for_each(el, &ts->os_timers) {\n            JSOSTimer *th = list_entry(el, JSOSTimer, link);\n            delay = th->timeout - cur_time;\n            if (delay <= 0) {\n                JSValue func;\n                /* the timer expired */\n                func = th->func;\n                th->func = JS_UNDEFINED;\n                free_timer(rt, th);\n                call_handler(ctx, func);\n                JS_FreeValue(ctx, func);\n                return 0;\n            } else if (delay < min_delay) {\n                min_delay = delay;\n            }\n        }\n        tv.tv_sec = min_delay / 1000;\n        tv.tv_usec = (min_delay % 1000) * 1000;\n        tvp = &tv;\n    } else {\n        tvp = NULL;\n    }\n\n    FD_ZERO(&rfds);\n    FD_ZERO(&wfds);\n    fd_max = -1;\n    list_for_each(el, &ts->os_rw_handlers) {\n        rh = list_entry(el, JSOSRWHandler, link);\n        fd_max = max_int(fd_max, rh->fd);\n        if (!JS_IsNull(rh->rw_func[0]))\n            FD_SET(rh->fd, &rfds);\n        if (!JS_IsNull(rh->rw_func[1]))\n            FD_SET(rh->fd, &wfds);\n    }\n\n    list_for_each(el, &ts->port_list) {\n        JSWorkerMessageHandler *port = list_entry(el, JSWorkerMessageHandler, link);\n        if (!JS_IsNull(port->on_message_func)) {\n            JSWorkerMessagePipe *ps = port->recv_pipe;\n            fd_max = max_int(fd_max, ps->read_fd);\n            FD_SET(ps->read_fd, &rfds);\n        }\n    }\n\n    ret = select(fd_max + 1, &rfds, &wfds, NULL, tvp);\n    if (ret > 0) {\n        list_for_each(el, &ts->os_rw_handlers) {\n            rh = list_entry(el, JSOSRWHandler, link);\n            if (!JS_IsNull(rh->rw_func[0]) &&\n                FD_ISSET(rh->fd, &rfds)) {\n                call_handler(ctx, rh->rw_func[0]);\n                /* must stop because the list may have been modified */\n                goto done;\n            }\n            if (!JS_IsNull(rh->rw_func[1]) &&\n                FD_ISSET(rh->fd, &wfds)) {\n                call_handler(ctx, rh->rw_func[1]);\n                /* must stop because the list may have been modified */\n                goto done;\n            }\n        }\n\n        list_for_each(el, &ts->port_list) {\n            JSWorkerMessageHandler *port = list_entry(el, JSWorkerMessageHandler, link);\n            if (!JS_IsNull(port->on_message_func)) {\n                JSWorkerMessagePipe *ps = port->recv_pipe;\n                if (FD_ISSET(ps->read_fd, &rfds)) {\n                    if (handle_posted_message(rt, ctx, port))\n                        goto done;\n                }\n            }\n        }\n    }\n    done:\n    return 0;\n}\n#endif /* !_WIN32 */\n\nstatic JSValue make_obj_error(JSContext *ctx,\n                              JSValue obj,\n                              int err)\n{\n    JSValue arr;\n    if (JS_IsException(obj))\n        return obj;\n    arr = JS_NewArray(ctx);\n    if (JS_IsException(arr))\n        return JS_EXCEPTION;\n    JS_DefinePropertyValueUint32(ctx, arr, 0, obj,\n                                 JS_PROP_C_W_E);\n    JS_DefinePropertyValueUint32(ctx, arr, 1, JS_NewInt32(ctx, err),\n                                 JS_PROP_C_W_E);\n    return arr;\n}\n\nstatic JSValue make_string_error(JSContext *ctx,\n                                 const char *buf,\n                                 int err)\n{\n    return make_obj_error(ctx, JS_NewString(ctx, buf), err);\n}\n\n/* return [cwd, errorcode] */\nstatic JSValue js_os_getcwd(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)\n{\n    char buf[PATH_MAX];\n    int err;\n\n    if (!getcwd(buf, sizeof(buf))) {\n        buf[0] = '\\0';\n        err = errno;\n    } else {\n        err = 0;\n    }\n    return make_string_error(ctx, buf, err);\n}\n\nstatic JSValue js_os_chdir(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    const char *target;\n    int err;\n\n    target = JS_ToCString(ctx, argv[0]);\n    if (!target)\n        return JS_EXCEPTION;\n    err = js_get_errno(chdir(target));\n    JS_FreeCString(ctx, target);\n    return JS_NewInt32(ctx, err);\n}\n\nstatic JSValue js_os_mkdir(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    int mode, ret;\n    const char *path;\n\n    if (argc >= 2) {\n        if (JS_ToInt32(ctx, &mode, argv[1]))\n            return JS_EXCEPTION;\n    } else {\n        mode = 0777;\n    }\n    path = JS_ToCString(ctx, argv[0]);\n    if (!path)\n        return JS_EXCEPTION;\n#if defined(_WIN32)\n    (void)mode;\n    ret = js_get_errno(mkdir(path));\n#else\n    ret = js_get_errno(mkdir(path, mode));\n#endif\n    JS_FreeCString(ctx, path);\n    return JS_NewInt32(ctx, ret);\n}\n\n/* return [array, errorcode] */\nstatic JSValue js_os_readdir(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    const char *path;\n    DIR *f;\n    struct dirent *d;\n    JSValue obj;\n    int err;\n    uint32_t len;\n\n    path = JS_ToCString(ctx, argv[0]);\n    if (!path)\n        return JS_EXCEPTION;\n    obj = JS_NewArray(ctx);\n    if (JS_IsException(obj)) {\n        JS_FreeCString(ctx, path);\n        return JS_EXCEPTION;\n    }\n    f = opendir(path);\n    if (!f)\n        err = errno;\n    else\n        err = 0;\n    JS_FreeCString(ctx, path);\n    if (!f)\n        goto done;\n    len = 0;\n    for(;;) {\n        errno = 0;\n        d = readdir(f);\n        if (!d) {\n            err = errno;\n            break;\n        }\n        JS_DefinePropertyValueUint32(ctx, obj, len++,\n                                     JS_NewString(ctx, d->d_name),\n                                     JS_PROP_C_W_E);\n    }\n    closedir(f);\n done:\n    return make_obj_error(ctx, obj, err);\n}\n\n#if !defined(_WIN32)\nstatic int64_t timespec_to_ms(const struct timespec *tv)\n{\n    return (int64_t)tv->tv_sec * 1000 + (tv->tv_nsec / 1000000);\n}\n#endif\n\n/* return [obj, errcode] */\nstatic JSValue js_os_stat(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv, int is_lstat)\n{\n    const char *path;\n    int err, res;\n    struct stat st;\n    JSValue obj;\n\n    path = JS_ToCString(ctx, argv[0]);\n    if (!path)\n        return JS_EXCEPTION;\n#if defined(_WIN32)\n    res = stat(path, &st);\n#else\n    if (is_lstat)\n        res = lstat(path, &st);\n    else\n        res = stat(path, &st);\n#endif\n    if (res < 0)\n        err = errno;\n    else\n        err = 0;\n    JS_FreeCString(ctx, path);\n    if (res < 0) {\n        obj = JS_NULL;\n    } else {\n        obj = JS_NewObject(ctx);\n        if (JS_IsException(obj))\n            return JS_EXCEPTION;\n        JS_DefinePropertyValueStr(ctx, obj, \"dev\",\n                                  JS_NewInt64(ctx, st.st_dev),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"ino\",\n                                  JS_NewInt64(ctx, st.st_ino),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"mode\",\n                                  JS_NewInt32(ctx, st.st_mode),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"nlink\",\n                                  JS_NewInt64(ctx, st.st_nlink),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"uid\",\n                                  JS_NewInt64(ctx, st.st_uid),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"gid\",\n                                  JS_NewInt64(ctx, st.st_gid),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"rdev\",\n                                  JS_NewInt64(ctx, st.st_rdev),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"size\",\n                                  JS_NewInt64(ctx, st.st_size),\n                                  JS_PROP_C_W_E);\n#if !defined(_WIN32)\n        JS_DefinePropertyValueStr(ctx, obj, \"blocks\",\n                                  JS_NewInt64(ctx, st.st_blocks),\n                                  JS_PROP_C_W_E);\n#endif\n#if defined(_WIN32)\n        JS_DefinePropertyValueStr(ctx, obj, \"atime\",\n                                  JS_NewInt64(ctx, (int64_t)st.st_atime * 1000),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"mtime\",\n                                  JS_NewInt64(ctx, (int64_t)st.st_mtime * 1000),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"ctime\",\n                                  JS_NewInt64(ctx, (int64_t)st.st_ctime * 1000),\n                                  JS_PROP_C_W_E);\n#elif defined(__APPLE__)\n        JS_DefinePropertyValueStr(ctx, obj, \"atime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atimespec)),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"mtime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtimespec)),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"ctime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctimespec)),\n                                  JS_PROP_C_W_E);\n#else\n        JS_DefinePropertyValueStr(ctx, obj, \"atime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atim)),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"mtime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtim)),\n                                  JS_PROP_C_W_E);\n        JS_DefinePropertyValueStr(ctx, obj, \"ctime\",\n                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctim)),\n                                  JS_PROP_C_W_E);\n#endif\n    }\n    return make_obj_error(ctx, obj, err);\n}\n\n#if !defined(_WIN32)\nstatic void ms_to_timeval(struct timeval *tv, uint64_t v)\n{\n    tv->tv_sec = v / 1000;\n    tv->tv_usec = (v % 1000) * 1000;\n}\n#endif\n\nstatic JSValue js_os_utimes(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)\n{\n    const char *path;\n    int64_t atime, mtime;\n    int ret;\n\n    if (JS_ToInt64(ctx, &atime, argv[1]))\n        return JS_EXCEPTION;\n    if (JS_ToInt64(ctx, &mtime, argv[2]))\n        return JS_EXCEPTION;\n    path = JS_ToCString(ctx, argv[0]);\n    if (!path)\n        return JS_EXCEPTION;\n#if defined(_WIN32)\n    {\n        struct _utimbuf times;\n        times.actime = atime / 1000;\n        times.modtime = mtime / 1000;\n        ret = js_get_errno(_utime(path, &times));\n    }\n#else\n    {\n        struct timeval times[2];\n        ms_to_timeval(&times[0], atime);\n        ms_to_timeval(&times[1], mtime);\n        ret = js_get_errno(utimes(path, times));\n    }\n#endif\n    JS_FreeCString(ctx, path);\n    return JS_NewInt32(ctx, ret);\n}\n\n/* sleep(delay_ms) */\nstatic JSValue js_os_sleep(JSContext *ctx, JSValueConst this_val,\n                           int argc, JSValueConst *argv)\n{\n    int64_t delay;\n    int ret;\n\n    if (JS_ToInt64(ctx, &delay, argv[0]))\n        return JS_EXCEPTION;\n    if (delay < 0)\n        delay = 0;\n#if defined(_WIN32)\n    {\n        if (delay > INT32_MAX)\n            delay = INT32_MAX;\n        Sleep(delay);\n        ret = 0;\n    }\n#else\n    {\n        struct timespec ts;\n\n        ts.tv_sec = delay / 1000;\n        ts.tv_nsec = (delay % 1000) * 1000000;\n        ret = js_get_errno(nanosleep(&ts, NULL));\n    }\n#endif\n    return JS_NewInt32(ctx, ret);\n}\n\n#if defined(_WIN32)\nstatic char *realpath(const char *path, char *buf)\n{\n    if (!_fullpath(buf, path, PATH_MAX)) {\n        errno = ENOENT;\n        return NULL;\n    } else {\n        return buf;\n    }\n}\n#endif\n\n/* return [path, errorcode] */\nstatic JSValue js_os_realpath(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    const char *path;\n    char buf[PATH_MAX], *res;\n    int err;\n\n    path = JS_ToCString(ctx, argv[0]);\n    if (!path)\n        return JS_EXCEPTION;\n    res = realpath(path, buf);\n    JS_FreeCString(ctx, path);\n    if (!res) {\n        buf[0] = '\\0';\n        err = errno;\n    } else {\n        err = 0;\n    }\n    return make_string_error(ctx, buf, err);\n}\n\n#if !defined(_WIN32)\nstatic JSValue js_os_symlink(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    const char *target, *linkpath;\n    int err;\n\n    target = JS_ToCString(ctx, argv[0]);\n    if (!target)\n        return JS_EXCEPTION;\n    linkpath = JS_ToCString(ctx, argv[1]);\n    if (!linkpath) {\n        JS_FreeCString(ctx, target);\n        return JS_EXCEPTION;\n    }\n    err = js_get_errno(symlink(target, linkpath));\n    JS_FreeCString(ctx, target);\n    JS_FreeCString(ctx, linkpath);\n    return JS_NewInt32(ctx, err);\n}\n\n/* return [path, errorcode] */\nstatic JSValue js_os_readlink(JSContext *ctx, JSValueConst this_val,\n                              int argc, JSValueConst *argv)\n{\n    const char *path;\n    char buf[PATH_MAX];\n    int err;\n    ssize_t res;\n\n    path = JS_ToCString(ctx, argv[0]);\n    if (!path)\n        return JS_EXCEPTION;\n    res = readlink(path, buf, sizeof(buf) - 1);\n    if (res < 0) {\n        buf[0] = '\\0';\n        err = errno;\n    } else {\n        buf[res] = '\\0';\n        err = 0;\n    }\n    JS_FreeCString(ctx, path);\n    return make_string_error(ctx, buf, err);\n}\n\nstatic char **build_envp(JSContext *ctx, JSValueConst obj)\n{\n    uint32_t len, i;\n    JSPropertyEnum *tab;\n    char **envp, *pair;\n    const char *key, *str;\n    JSValue val;\n    size_t key_len, str_len;\n\n    if (JS_GetOwnPropertyNames(ctx, &tab, &len, obj,\n                               JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY) < 0)\n        return NULL;\n    envp = js_mallocz(ctx, sizeof(envp[0]) * ((size_t)len + 1));\n    if (!envp)\n        goto fail;\n    for(i = 0; i < len; i++) {\n        val = JS_GetProperty(ctx, obj, tab[i].atom);\n        if (JS_IsException(val))\n            goto fail;\n        str = JS_ToCString(ctx, val);\n        JS_FreeValue(ctx, val);\n        if (!str)\n            goto fail;\n        key = JS_AtomToCString(ctx, tab[i].atom);\n        if (!key) {\n            JS_FreeCString(ctx, str);\n            goto fail;\n        }\n        key_len = strlen(key);\n        str_len = strlen(str);\n        pair = js_malloc(ctx, key_len + str_len + 2);\n        if (!pair) {\n            JS_FreeCString(ctx, key);\n            JS_FreeCString(ctx, str);\n            goto fail;\n        }\n        memcpy(pair, key, key_len);\n        pair[key_len] = '=';\n        memcpy(pair + key_len + 1, str, str_len);\n        pair[key_len + 1 + str_len] = '\\0';\n        envp[i] = pair;\n        JS_FreeCString(ctx, key);\n        JS_FreeCString(ctx, str);\n    }\n done:\n    for(i = 0; i < len; i++)\n        JS_FreeAtom(ctx, tab[i].atom);\n    js_free(ctx, tab);\n    return envp;\n fail:\n    if (envp) {\n        for(i = 0; i < len; i++)\n            js_free(ctx, envp[i]);\n        js_free(ctx, envp);\n        envp = NULL;\n    }\n    goto done;\n}\n\n/* execvpe is not available on non GNU systems */\nstatic int my_execvpe(const char *filename, char **argv, char **envp)\n{\n    char *path, *p, *p_next, *p1;\n    char buf[PATH_MAX];\n    size_t filename_len, path_len;\n    BOOL eacces_error;\n\n    filename_len = strlen(filename);\n    if (filename_len == 0) {\n        errno = ENOENT;\n        return -1;\n    }\n    if (strchr(filename, '/'))\n        return execve(filename, argv, envp);\n\n    path = getenv(\"PATH\");\n    if (!path)\n        path = (char *)\"/bin:/usr/bin\";\n    eacces_error = FALSE;\n    p = path;\n    for(p = path; p != NULL; p = p_next) {\n        p1 = strchr(p, ':');\n        if (!p1) {\n            p_next = NULL;\n            path_len = strlen(p);\n        } else {\n            p_next = p1 + 1;\n            path_len = p1 - p;\n        }\n        /* path too long */\n        if ((path_len + 1 + filename_len + 1) > PATH_MAX)\n            continue;\n        memcpy(buf, p, path_len);\n        buf[path_len] = '/';\n        memcpy(buf + path_len + 1, filename, filename_len);\n        buf[path_len + 1 + filename_len] = '\\0';\n\n        execve(buf, argv, envp);\n\n        switch(errno) {\n        case EACCES:\n            eacces_error = TRUE;\n            break;\n        case ENOENT:\n        case ENOTDIR:\n            break;\n        default:\n            return -1;\n        }\n    }\n    if (eacces_error)\n        errno = EACCES;\n    return -1;\n}\n\n/* exec(args[, options]) -> exitcode */\nstatic JSValue js_os_exec(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv)\n{\n    JSValueConst options, args = argv[0];\n    JSValue val, ret_val;\n    const char **exec_argv, *file = NULL, *str, *cwd = NULL;\n    char **envp = environ;\n    uint32_t exec_argc, i;\n    int ret, pid, status;\n    BOOL block_flag = TRUE, use_path = TRUE;\n    static const char *std_name[3] = { \"stdin\", \"stdout\", \"stderr\" };\n    int std_fds[3];\n    uint32_t uid = -1, gid = -1;\n\n    val = JS_GetPropertyStr(ctx, args, \"length\");\n    if (JS_IsException(val))\n        return JS_EXCEPTION;\n    ret = JS_ToUint32(ctx, &exec_argc, val);\n    JS_FreeValue(ctx, val);\n    if (ret)\n        return JS_EXCEPTION;\n    /* arbitrary limit to avoid overflow */\n    if (exec_argc < 1 || exec_argc > 65535) {\n        return JS_ThrowTypeError(ctx, \"invalid number of arguments\");\n    }\n    exec_argv = js_mallocz(ctx, sizeof(exec_argv[0]) * (exec_argc + 1));\n    if (!exec_argv)\n        return JS_EXCEPTION;\n    for(i = 0; i < exec_argc; i++) {\n        val = JS_GetPropertyUint32(ctx, args, i);\n        if (JS_IsException(val))\n            goto exception;\n        str = JS_ToCString(ctx, val);\n        JS_FreeValue(ctx, val);\n        if (!str)\n            goto exception;\n        exec_argv[i] = str;\n    }\n    exec_argv[exec_argc] = NULL;\n\n    for(i = 0; i < 3; i++)\n        std_fds[i] = i;\n\n    /* get the options, if any */\n    if (argc >= 2) {\n        options = argv[1];\n\n        if (get_bool_option(ctx, &block_flag, options, \"block\"))\n            goto exception;\n        if (get_bool_option(ctx, &use_path, options, \"usePath\"))\n            goto exception;\n\n        val = JS_GetPropertyStr(ctx, options, \"file\");\n        if (JS_IsException(val))\n            goto exception;\n        if (!JS_IsUndefined(val)) {\n            file = JS_ToCString(ctx, val);\n            JS_FreeValue(ctx, val);\n            if (!file)\n                goto exception;\n        }\n\n        val = JS_GetPropertyStr(ctx, options, \"cwd\");\n        if (JS_IsException(val))\n            goto exception;\n        if (!JS_IsUndefined(val)) {\n            cwd = JS_ToCString(ctx, val);\n            JS_FreeValue(ctx, val);\n            if (!cwd)\n                goto exception;\n        }\n\n        /* stdin/stdout/stderr handles */\n        for(i = 0; i < 3; i++) {\n            val = JS_GetPropertyStr(ctx, options, std_name[i]);\n            if (JS_IsException(val))\n                goto exception;\n            if (!JS_IsUndefined(val)) {\n                int fd;\n                ret = JS_ToInt32(ctx, &fd, val);\n                JS_FreeValue(ctx, val);\n                if (ret)\n                    goto exception;\n                std_fds[i] = fd;\n            }\n        }\n\n        val = JS_GetPropertyStr(ctx, options, \"env\");\n        if (JS_IsException(val))\n            goto exception;\n        if (!JS_IsUndefined(val)) {\n            envp = build_envp(ctx, val);\n            JS_FreeValue(ctx, val);\n            if (!envp)\n                goto exception;\n        }\n\n        val = JS_GetPropertyStr(ctx, options, \"uid\");\n        if (JS_IsException(val))\n            goto exception;\n        if (!JS_IsUndefined(val)) {\n            ret = JS_ToUint32(ctx, &uid, val);\n            JS_FreeValue(ctx, val);\n            if (ret)\n                goto exception;\n        }\n\n        val = JS_GetPropertyStr(ctx, options, \"gid\");\n        if (JS_IsException(val))\n            goto exception;\n        if (!JS_IsUndefined(val)) {\n            ret = JS_ToUint32(ctx, &gid, val);\n            JS_FreeValue(ctx, val);\n            if (ret)\n                goto exception;\n        }\n    }\n\n    pid = fork();\n    if (pid < 0) {\n        JS_ThrowTypeError(ctx, \"fork error\");\n        goto exception;\n    }\n    if (pid == 0) {\n        /* child */\n\n        /* remap the stdin/stdout/stderr handles if necessary */\n        for(i = 0; i < 3; i++) {\n            if (std_fds[i] != i) {\n                if (dup2(std_fds[i], i) < 0)\n                    _exit(127);\n            }\n        }\n#if defined(HAVE_CLOSEFROM)\n        /* closefrom() is available on many recent unix systems:\n           Linux with glibc 2.34+, Solaris 9+, FreeBSD 7.3+,\n           NetBSD 3.0+, OpenBSD 3.5+.\n           Linux with the musl libc and macOS don't have it.\n         */\n\n        closefrom(3);\n#else\n        {\n            /* Close the file handles manually, limit to 1024 to avoid\n               costly loop on linux Alpine where sysconf(_SC_OPEN_MAX)\n               returns a huge value 1048576.\n               Patch inspired by nicolas-duteil-nova. See also:\n               https://stackoverflow.com/questions/73229353/\n               https://stackoverflow.com/questions/899038/#918469\n             */\n            int fd_max = min_int(sysconf(_SC_OPEN_MAX), 1024);\n            for(i = 3; i < fd_max; i++)\n                close(i);\n        }\n#endif\n        if (cwd) {\n            if (chdir(cwd) < 0)\n                _exit(127);\n        }\n        if (uid != -1) {\n            if (setuid(uid) < 0)\n                _exit(127);\n        }\n        if (gid != -1) {\n            if (setgid(gid) < 0)\n                _exit(127);\n        }\n\n        if (!file)\n            file = exec_argv[0];\n        if (use_path)\n            ret = my_execvpe(file, (char **)exec_argv, envp);\n        else\n            ret = execve(file, (char **)exec_argv, envp);\n        _exit(127);\n    }\n    /* parent */\n    if (block_flag) {\n        for(;;) {\n            ret = waitpid(pid, &status, 0);\n            if (ret == pid) {\n                if (WIFEXITED(status)) {\n                    ret = WEXITSTATUS(status);\n                    break;\n                } else if (WIFSIGNALED(status)) {\n                    ret = -WTERMSIG(status);\n                    break;\n                }\n            }\n        }\n    } else {\n        ret = pid;\n    }\n    ret_val = JS_NewInt32(ctx, ret);\n done:\n    JS_FreeCString(ctx, file);\n    JS_FreeCString(ctx, cwd);\n    for(i = 0; i < exec_argc; i++)\n        JS_FreeCString(ctx, exec_argv[i]);\n    js_free(ctx, exec_argv);\n    if (envp != environ) {\n        char **p;\n        p = envp;\n        while (*p != NULL) {\n            js_free(ctx, *p);\n            p++;\n        }\n        js_free(ctx, envp);\n    }\n    return ret_val;\n exception:\n    ret_val = JS_EXCEPTION;\n    goto done;\n}\n\n/* getpid() -> pid */\nstatic JSValue js_os_getpid(JSContext *ctx, JSValueConst this_val,\n                            int argc, JSValueConst *argv)\n{\n    return JS_NewInt32(ctx, getpid());\n}\n\n/* waitpid(pid, block) -> [pid, status] */\nstatic JSValue js_os_waitpid(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv)\n{\n    int pid, status, options, ret;\n    JSValue obj;\n\n    if (JS_ToInt32(ctx, &pid, argv[0]))\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &options, argv[1]))\n        return JS_EXCEPTION;\n\n    ret = waitpid(pid, &status, options);\n    if (ret < 0) {\n        ret = -errno;\n        status = 0;\n    }\n\n    obj = JS_NewArray(ctx);\n    if (JS_IsException(obj))\n        return obj;\n    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, ret),\n                                 JS_PROP_C_W_E);\n    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, status),\n                                 JS_PROP_C_W_E);\n    return obj;\n}\n\n/* pipe() -> [read_fd, write_fd] or null if error */\nstatic JSValue js_os_pipe(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv)\n{\n    int pipe_fds[2], ret;\n    JSValue obj;\n\n    ret = pipe(pipe_fds);\n    if (ret < 0)\n        return JS_NULL;\n    obj = JS_NewArray(ctx);\n    if (JS_IsException(obj))\n        return obj;\n    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, pipe_fds[0]),\n                                 JS_PROP_C_W_E);\n    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, pipe_fds[1]),\n                                 JS_PROP_C_W_E);\n    return obj;\n}\n\n/* kill(pid, sig) */\nstatic JSValue js_os_kill(JSContext *ctx, JSValueConst this_val,\n                          int argc, JSValueConst *argv)\n{\n    int pid, sig, ret;\n\n    if (JS_ToInt32(ctx, &pid, argv[0]))\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &sig, argv[1]))\n        return JS_EXCEPTION;\n    ret = js_get_errno(kill(pid, sig));\n    return JS_NewInt32(ctx, ret);\n}\n\n/* dup(fd) */\nstatic JSValue js_os_dup(JSContext *ctx, JSValueConst this_val,\n                         int argc, JSValueConst *argv)\n{\n    int fd, ret;\n\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    ret = js_get_errno(dup(fd));\n    return JS_NewInt32(ctx, ret);\n}\n\n/* dup2(fd) */\nstatic JSValue js_os_dup2(JSContext *ctx, JSValueConst this_val,\n                         int argc, JSValueConst *argv)\n{\n    int fd, fd2, ret;\n\n    if (JS_ToInt32(ctx, &fd, argv[0]))\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &fd2, argv[1]))\n        return JS_EXCEPTION;\n    ret = js_get_errno(dup2(fd, fd2));\n    return JS_NewInt32(ctx, ret);\n}\n\n#endif /* !_WIN32 */\n\n#ifdef USE_WORKER\n\n/* Worker */\n\ntypedef struct {\n    JSWorkerMessagePipe *recv_pipe;\n    JSWorkerMessagePipe *send_pipe;\n    JSWorkerMessageHandler *msg_handler;\n} JSWorkerData;\n\ntypedef struct {\n    char *filename; /* module filename */\n    char *basename; /* module base name */\n    JSWorkerMessagePipe *recv_pipe, *send_pipe;\n} WorkerFuncArgs;\n\ntypedef struct {\n    int ref_count;\n    uint64_t buf[0];\n} JSSABHeader;\n\nstatic JSClassID js_worker_class_id;\nstatic JSContext *(*js_worker_new_context_func)(JSRuntime *rt);\n\nstatic int atomic_add_int(int *ptr, int v)\n{\n    return atomic_fetch_add((_Atomic(uint32_t) *)ptr, v) + v;\n}\n\n/* shared array buffer allocator */\nstatic void *js_sab_alloc(void *opaque, size_t size)\n{\n    JSSABHeader *sab;\n    sab = malloc(sizeof(JSSABHeader) + size);\n    if (!sab)\n        return NULL;\n    sab->ref_count = 1;\n    return sab->buf;\n}\n\nstatic void js_sab_free(void *opaque, void *ptr)\n{\n    JSSABHeader *sab;\n    int ref_count;\n    sab = (JSSABHeader *)((uint8_t *)ptr - sizeof(JSSABHeader));\n    ref_count = atomic_add_int(&sab->ref_count, -1);\n    assert(ref_count >= 0);\n    if (ref_count == 0) {\n        free(sab);\n    }\n}\n\nstatic void js_sab_dup(void *opaque, void *ptr)\n{\n    JSSABHeader *sab;\n    sab = (JSSABHeader *)((uint8_t *)ptr - sizeof(JSSABHeader));\n    atomic_add_int(&sab->ref_count, 1);\n}\n\nstatic JSWorkerMessagePipe *js_new_message_pipe(void)\n{\n    JSWorkerMessagePipe *ps;\n    int pipe_fds[2];\n\n    if (pipe(pipe_fds) < 0)\n        return NULL;\n\n    ps = malloc(sizeof(*ps));\n    if (!ps) {\n        close(pipe_fds[0]);\n        close(pipe_fds[1]);\n        return NULL;\n    }\n    ps->ref_count = 1;\n    init_list_head(&ps->msg_queue);\n    pthread_mutex_init(&ps->mutex, NULL);\n    ps->read_fd = pipe_fds[0];\n    ps->write_fd = pipe_fds[1];\n    return ps;\n}\n\nstatic JSWorkerMessagePipe *js_dup_message_pipe(JSWorkerMessagePipe *ps)\n{\n    atomic_add_int(&ps->ref_count, 1);\n    return ps;\n}\n\nstatic void js_free_message(JSWorkerMessage *msg)\n{\n    size_t i;\n    /* free the SAB */\n    for(i = 0; i < msg->sab_tab_len; i++) {\n        js_sab_free(NULL, msg->sab_tab[i]);\n    }\n    free(msg->sab_tab);\n    free(msg->data);\n    free(msg);\n}\n\nstatic void js_free_message_pipe(JSWorkerMessagePipe *ps)\n{\n    struct list_head *el, *el1;\n    JSWorkerMessage *msg;\n    int ref_count;\n\n    if (!ps)\n        return;\n\n    ref_count = atomic_add_int(&ps->ref_count, -1);\n    assert(ref_count >= 0);\n    if (ref_count == 0) {\n        list_for_each_safe(el, el1, &ps->msg_queue) {\n            msg = list_entry(el, JSWorkerMessage, link);\n            js_free_message(msg);\n        }\n        pthread_mutex_destroy(&ps->mutex);\n        close(ps->read_fd);\n        close(ps->write_fd);\n        free(ps);\n    }\n}\n\nstatic void js_free_port(JSRuntime *rt, JSWorkerMessageHandler *port)\n{\n    if (port) {\n        js_free_message_pipe(port->recv_pipe);\n        JS_FreeValueRT(rt, port->on_message_func);\n        list_del(&port->link);\n        js_free_rt(rt, port);\n    }\n}\n\nstatic void js_worker_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSWorkerData *worker = JS_GetOpaque(val, js_worker_class_id);\n    if (worker) {\n        js_free_message_pipe(worker->recv_pipe);\n        js_free_message_pipe(worker->send_pipe);\n        js_free_port(rt, worker->msg_handler);\n        js_free_rt(rt, worker);\n    }\n}\n\nstatic JSClassDef js_worker_class = {\n    \"Worker\",\n    .finalizer = js_worker_finalizer,\n};\n\nstatic void *worker_func(void *opaque)\n{\n    WorkerFuncArgs *args = opaque;\n    JSRuntime *rt;\n    JSThreadState *ts;\n    JSContext *ctx;\n    JSValue val;\n\n    rt = JS_NewRuntime();\n    if (rt == NULL) {\n        fprintf(stderr, \"JS_NewRuntime failure\");\n        exit(1);\n    }\n    js_std_init_handlers(rt);\n\n    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);\n\n    /* set the pipe to communicate with the parent */\n    ts = JS_GetRuntimeOpaque(rt);\n    ts->recv_pipe = args->recv_pipe;\n    ts->send_pipe = args->send_pipe;\n\n    /* function pointer to avoid linking the whole JS_NewContext() if\n       not needed */\n    ctx = js_worker_new_context_func(rt);\n    if (ctx == NULL) {\n        fprintf(stderr, \"JS_NewContext failure\");\n    }\n\n    JS_SetCanBlock(rt, TRUE);\n\n    js_std_add_helpers(ctx, -1, NULL);\n\n    val = JS_LoadModule(ctx, args->basename, args->filename);\n    free(args->filename);\n    free(args->basename);\n    free(args);\n    val = js_std_await(ctx, val);\n    if (JS_IsException(val))\n        js_std_dump_error(ctx);\n    JS_FreeValue(ctx, val);\n\n    js_std_loop(ctx);\n\n    JS_FreeContext(ctx);\n    js_std_free_handlers(rt);\n    JS_FreeRuntime(rt);\n    return NULL;\n}\n\nstatic JSValue js_worker_ctor_internal(JSContext *ctx, JSValueConst new_target,\n                                       JSWorkerMessagePipe *recv_pipe,\n                                       JSWorkerMessagePipe *send_pipe)\n{\n    JSValue obj = JS_UNDEFINED, proto;\n    JSWorkerData *s;\n\n    /* create the object */\n    if (JS_IsUndefined(new_target)) {\n        proto = JS_GetClassProto(ctx, js_worker_class_id);\n    } else {\n        proto = JS_GetPropertyStr(ctx, new_target, \"prototype\");\n        if (JS_IsException(proto))\n            goto fail;\n    }\n    obj = JS_NewObjectProtoClass(ctx, proto, js_worker_class_id);\n    JS_FreeValue(ctx, proto);\n    if (JS_IsException(obj))\n        goto fail;\n    s = js_mallocz(ctx, sizeof(*s));\n    if (!s)\n        goto fail;\n    s->recv_pipe = js_dup_message_pipe(recv_pipe);\n    s->send_pipe = js_dup_message_pipe(send_pipe);\n\n    JS_SetOpaque(obj, s);\n    return obj;\n fail:\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_worker_ctor(JSContext *ctx, JSValueConst new_target,\n                              int argc, JSValueConst *argv)\n{\n    JSRuntime *rt = JS_GetRuntime(ctx);\n    WorkerFuncArgs *args = NULL;\n    pthread_t tid;\n    pthread_attr_t attr;\n    JSValue obj = JS_UNDEFINED;\n    int ret;\n    const char *filename = NULL, *basename;\n    JSAtom basename_atom;\n\n    /* XXX: in order to avoid problems with resource liberation, we\n       don't support creating workers inside workers */\n    if (!is_main_thread(rt))\n        return JS_ThrowTypeError(ctx, \"cannot create a worker inside a worker\");\n\n    /* base name, assuming the calling function is a normal JS\n       function */\n    basename_atom = JS_GetScriptOrModuleName(ctx, 1);\n    if (basename_atom == JS_ATOM_NULL) {\n        return JS_ThrowTypeError(ctx, \"could not determine calling script or module name\");\n    }\n    basename = JS_AtomToCString(ctx, basename_atom);\n    JS_FreeAtom(ctx, basename_atom);\n    if (!basename)\n        goto fail;\n\n    /* module name */\n    filename = JS_ToCString(ctx, argv[0]);\n    if (!filename)\n        goto fail;\n\n    args = malloc(sizeof(*args));\n    if (!args)\n        goto oom_fail;\n    memset(args, 0, sizeof(*args));\n    args->filename = strdup(filename);\n    args->basename = strdup(basename);\n\n    /* ports */\n    args->recv_pipe = js_new_message_pipe();\n    if (!args->recv_pipe)\n        goto oom_fail;\n    args->send_pipe = js_new_message_pipe();\n    if (!args->send_pipe)\n        goto oom_fail;\n\n    obj = js_worker_ctor_internal(ctx, new_target,\n                                  args->send_pipe, args->recv_pipe);\n    if (JS_IsException(obj))\n        goto fail;\n\n    pthread_attr_init(&attr);\n    /* no join at the end */\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    ret = pthread_create(&tid, &attr, worker_func, args);\n    pthread_attr_destroy(&attr);\n    if (ret != 0) {\n        JS_ThrowTypeError(ctx, \"could not create worker\");\n        goto fail;\n    }\n    JS_FreeCString(ctx, basename);\n    JS_FreeCString(ctx, filename);\n    return obj;\n oom_fail:\n    JS_ThrowOutOfMemory(ctx);\n fail:\n    JS_FreeCString(ctx, basename);\n    JS_FreeCString(ctx, filename);\n    if (args) {\n        free(args->filename);\n        free(args->basename);\n        js_free_message_pipe(args->recv_pipe);\n        js_free_message_pipe(args->send_pipe);\n        free(args);\n    }\n    JS_FreeValue(ctx, obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_worker_postMessage(JSContext *ctx, JSValueConst this_val,\n                                     int argc, JSValueConst *argv)\n{\n    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);\n    JSWorkerMessagePipe *ps;\n    size_t data_len, sab_tab_len, i;\n    uint8_t *data;\n    JSWorkerMessage *msg;\n    uint8_t **sab_tab;\n\n    if (!worker)\n        return JS_EXCEPTION;\n\n    data = JS_WriteObject2(ctx, &data_len, argv[0],\n                           JS_WRITE_OBJ_SAB | JS_WRITE_OBJ_REFERENCE,\n                           &sab_tab, &sab_tab_len);\n    if (!data)\n        return JS_EXCEPTION;\n\n    msg = malloc(sizeof(*msg));\n    if (!msg)\n        goto fail;\n    msg->data = NULL;\n    msg->sab_tab = NULL;\n\n    /* must reallocate because the allocator may be different */\n    msg->data = malloc(data_len);\n    if (!msg->data)\n        goto fail;\n    memcpy(msg->data, data, data_len);\n    msg->data_len = data_len;\n\n    if (sab_tab_len > 0) {\n        msg->sab_tab = malloc(sizeof(msg->sab_tab[0]) * sab_tab_len);\n        if (!msg->sab_tab)\n            goto fail;\n        memcpy(msg->sab_tab, sab_tab, sizeof(msg->sab_tab[0]) * sab_tab_len);\n    }\n    msg->sab_tab_len = sab_tab_len;\n\n    js_free(ctx, data);\n    js_free(ctx, sab_tab);\n\n    /* increment the SAB reference counts */\n    for(i = 0; i < msg->sab_tab_len; i++) {\n        js_sab_dup(NULL, msg->sab_tab[i]);\n    }\n\n    ps = worker->send_pipe;\n    pthread_mutex_lock(&ps->mutex);\n    /* indicate that data is present */\n    if (list_empty(&ps->msg_queue)) {\n        uint8_t ch = '\\0';\n        int ret;\n        for(;;) {\n            ret = write(ps->write_fd, &ch, 1);\n            if (ret == 1)\n                break;\n            if (ret < 0 && (errno != EAGAIN || errno != EINTR))\n                break;\n        }\n    }\n    list_add_tail(&msg->link, &ps->msg_queue);\n    pthread_mutex_unlock(&ps->mutex);\n    return JS_UNDEFINED;\n fail:\n    if (msg) {\n        free(msg->data);\n        free(msg->sab_tab);\n        free(msg);\n    }\n    js_free(ctx, data);\n    js_free(ctx, sab_tab);\n    return JS_EXCEPTION;\n\n}\n\nstatic JSValue js_worker_set_onmessage(JSContext *ctx, JSValueConst this_val,\n                                   JSValueConst func)\n{\n    JSRuntime *rt = JS_GetRuntime(ctx);\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);\n    JSWorkerMessageHandler *port;\n\n    if (!worker)\n        return JS_EXCEPTION;\n\n    port = worker->msg_handler;\n    if (JS_IsNull(func)) {\n        if (port) {\n            js_free_port(rt, port);\n            worker->msg_handler = NULL;\n        }\n    } else {\n        if (!JS_IsFunction(ctx, func))\n            return JS_ThrowTypeError(ctx, \"not a function\");\n        if (!port) {\n            port = js_mallocz(ctx, sizeof(*port));\n            if (!port)\n                return JS_EXCEPTION;\n            port->recv_pipe = js_dup_message_pipe(worker->recv_pipe);\n            port->on_message_func = JS_NULL;\n            list_add_tail(&port->link, &ts->port_list);\n            worker->msg_handler = port;\n        }\n        JS_FreeValue(ctx, port->on_message_func);\n        port->on_message_func = JS_DupValue(ctx, func);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_worker_get_onmessage(JSContext *ctx, JSValueConst this_val)\n{\n    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);\n    JSWorkerMessageHandler *port;\n    if (!worker)\n        return JS_EXCEPTION;\n    port = worker->msg_handler;\n    if (port) {\n        return JS_DupValue(ctx, port->on_message_func);\n    } else {\n        return JS_NULL;\n    }\n}\n\nstatic const JSCFunctionListEntry js_worker_proto_funcs[] = {\n    JS_CFUNC_DEF(\"postMessage\", 1, js_worker_postMessage ),\n    JS_CGETSET_DEF(\"onmessage\", js_worker_get_onmessage, js_worker_set_onmessage ),\n};\n\n#endif /* USE_WORKER */\n\nvoid js_std_set_worker_new_context_func(JSContext *(*func)(JSRuntime *rt))\n{\n#ifdef USE_WORKER\n    js_worker_new_context_func = func;\n#endif\n}\n\n#if defined(_WIN32)\n#define OS_PLATFORM \"win32\"\n#elif defined(__APPLE__)\n#define OS_PLATFORM \"darwin\"\n#elif defined(EMSCRIPTEN)\n#define OS_PLATFORM \"js\"\n#else\n#define OS_PLATFORM \"linux\"\n#endif\n\n#define OS_FLAG(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )\n\nstatic const JSCFunctionListEntry js_os_funcs[] = {\n    JS_CFUNC_DEF(\"open\", 2, js_os_open ),\n    OS_FLAG(O_RDONLY),\n    OS_FLAG(O_WRONLY),\n    OS_FLAG(O_RDWR),\n    OS_FLAG(O_APPEND),\n    OS_FLAG(O_CREAT),\n    OS_FLAG(O_EXCL),\n    OS_FLAG(O_TRUNC),\n#if defined(_WIN32)\n    OS_FLAG(O_BINARY),\n    OS_FLAG(O_TEXT),\n#endif\n    JS_CFUNC_DEF(\"close\", 1, js_os_close ),\n    JS_CFUNC_DEF(\"seek\", 3, js_os_seek ),\n    JS_CFUNC_MAGIC_DEF(\"read\", 4, js_os_read_write, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"write\", 4, js_os_read_write, 1 ),\n    JS_CFUNC_DEF(\"isatty\", 1, js_os_isatty ),\n    JS_CFUNC_DEF(\"ttyGetWinSize\", 1, js_os_ttyGetWinSize ),\n    JS_CFUNC_DEF(\"ttySetRaw\", 1, js_os_ttySetRaw ),\n    JS_CFUNC_DEF(\"remove\", 1, js_os_remove ),\n    JS_CFUNC_DEF(\"rename\", 2, js_os_rename ),\n    JS_CFUNC_MAGIC_DEF(\"setReadHandler\", 2, js_os_setReadHandler, 0 ),\n    JS_CFUNC_MAGIC_DEF(\"setWriteHandler\", 2, js_os_setReadHandler, 1 ),\n    JS_CFUNC_DEF(\"signal\", 2, js_os_signal ),\n    OS_FLAG(SIGINT),\n    OS_FLAG(SIGABRT),\n    OS_FLAG(SIGFPE),\n    OS_FLAG(SIGILL),\n    OS_FLAG(SIGSEGV),\n    OS_FLAG(SIGTERM),\n#if !defined(_WIN32)\n    OS_FLAG(SIGQUIT),\n    OS_FLAG(SIGPIPE),\n    OS_FLAG(SIGALRM),\n    OS_FLAG(SIGUSR1),\n    OS_FLAG(SIGUSR2),\n    OS_FLAG(SIGCHLD),\n    OS_FLAG(SIGCONT),\n    OS_FLAG(SIGSTOP),\n    OS_FLAG(SIGTSTP),\n    OS_FLAG(SIGTTIN),\n    OS_FLAG(SIGTTOU),\n#endif\n    JS_CFUNC_DEF(\"now\", 0, js_os_now ),\n    JS_CFUNC_DEF(\"setTimeout\", 2, js_os_setTimeout ),\n    JS_CFUNC_DEF(\"clearTimeout\", 1, js_os_clearTimeout ),\n    JS_CFUNC_DEF(\"sleepAsync\", 1, js_os_sleepAsync ),\n    JS_PROP_STRING_DEF(\"platform\", OS_PLATFORM, 0 ),\n    JS_CFUNC_DEF(\"getcwd\", 0, js_os_getcwd ),\n    JS_CFUNC_DEF(\"chdir\", 0, js_os_chdir ),\n    JS_CFUNC_DEF(\"mkdir\", 1, js_os_mkdir ),\n    JS_CFUNC_DEF(\"readdir\", 1, js_os_readdir ),\n    /* st_mode constants */\n    OS_FLAG(S_IFMT),\n    OS_FLAG(S_IFIFO),\n    OS_FLAG(S_IFCHR),\n    OS_FLAG(S_IFDIR),\n    OS_FLAG(S_IFBLK),\n    OS_FLAG(S_IFREG),\n#if !defined(_WIN32)\n    OS_FLAG(S_IFSOCK),\n    OS_FLAG(S_IFLNK),\n    OS_FLAG(S_ISGID),\n    OS_FLAG(S_ISUID),\n#endif\n    JS_CFUNC_MAGIC_DEF(\"stat\", 1, js_os_stat, 0 ),\n    JS_CFUNC_DEF(\"utimes\", 3, js_os_utimes ),\n    JS_CFUNC_DEF(\"sleep\", 1, js_os_sleep ),\n    JS_CFUNC_DEF(\"realpath\", 1, js_os_realpath ),\n#if !defined(_WIN32)\n    JS_CFUNC_MAGIC_DEF(\"lstat\", 1, js_os_stat, 1 ),\n    JS_CFUNC_DEF(\"symlink\", 2, js_os_symlink ),\n    JS_CFUNC_DEF(\"readlink\", 1, js_os_readlink ),\n    JS_CFUNC_DEF(\"exec\", 1, js_os_exec ),\n    JS_CFUNC_DEF(\"getpid\", 0, js_os_getpid ),\n    JS_CFUNC_DEF(\"waitpid\", 2, js_os_waitpid ),\n    OS_FLAG(WNOHANG),\n    JS_CFUNC_DEF(\"pipe\", 0, js_os_pipe ),\n    JS_CFUNC_DEF(\"kill\", 2, js_os_kill ),\n    JS_CFUNC_DEF(\"dup\", 1, js_os_dup ),\n    JS_CFUNC_DEF(\"dup2\", 2, js_os_dup2 ),\n#endif\n};\n\nstatic int js_os_init(JSContext *ctx, JSModuleDef *m)\n{\n    os_poll_func = js_os_poll;\n\n#ifdef USE_WORKER\n    {\n        JSRuntime *rt = JS_GetRuntime(ctx);\n        JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n        JSValue proto, obj;\n        /* Worker class */\n        JS_NewClassID(&js_worker_class_id);\n        JS_NewClass(JS_GetRuntime(ctx), js_worker_class_id, &js_worker_class);\n        proto = JS_NewObject(ctx);\n        JS_SetPropertyFunctionList(ctx, proto, js_worker_proto_funcs, countof(js_worker_proto_funcs));\n\n        obj = JS_NewCFunction2(ctx, js_worker_ctor, \"Worker\", 1,\n                               JS_CFUNC_constructor, 0);\n        JS_SetConstructor(ctx, obj, proto);\n\n        JS_SetClassProto(ctx, js_worker_class_id, proto);\n\n        /* set 'Worker.parent' if necessary */\n        if (ts->recv_pipe && ts->send_pipe) {\n            JS_DefinePropertyValueStr(ctx, obj, \"parent\",\n                                      js_worker_ctor_internal(ctx, JS_UNDEFINED, ts->recv_pipe, ts->send_pipe),\n                                      JS_PROP_C_W_E);\n        }\n\n        JS_SetModuleExport(ctx, m, \"Worker\", obj);\n    }\n#endif /* USE_WORKER */\n\n    return JS_SetModuleExportList(ctx, m, js_os_funcs,\n                                  countof(js_os_funcs));\n}\n\nJSModuleDef *js_init_module_os(JSContext *ctx, const char *module_name)\n{\n    JSModuleDef *m;\n    m = JS_NewCModule(ctx, module_name, js_os_init);\n    if (!m)\n        return NULL;\n    JS_AddModuleExportList(ctx, m, js_os_funcs, countof(js_os_funcs));\n#ifdef USE_WORKER\n    JS_AddModuleExport(ctx, m, \"Worker\");\n#endif\n    return m;\n}\n\n/**********************************************************/\n\nstatic JSValue js_print(JSContext *ctx, JSValueConst this_val,\n                        int argc, JSValueConst *argv)\n{\n    int i;\n    const char *str;\n    size_t len;\n\n    for(i = 0; i < argc; i++) {\n        if (i != 0)\n            putchar(' ');\n        str = JS_ToCStringLen(ctx, &len, argv[i]);\n        if (!str)\n            return JS_EXCEPTION;\n        fwrite(str, 1, len, stdout);\n        JS_FreeCString(ctx, str);\n    }\n    putchar('\\n');\n    return JS_UNDEFINED;\n}\n\nvoid js_std_add_helpers(JSContext *ctx, int argc, char **argv)\n{\n    JSValue global_obj, console, args;\n    int i;\n\n    /* XXX: should these global definitions be enumerable? */\n    global_obj = JS_GetGlobalObject(ctx);\n\n    console = JS_NewObject(ctx);\n    JS_SetPropertyStr(ctx, console, \"log\",\n                      JS_NewCFunction(ctx, js_print, \"log\", 1));\n    JS_SetPropertyStr(ctx, global_obj, \"console\", console);\n\n    /* same methods as the mozilla JS shell */\n    if (argc >= 0) {\n        args = JS_NewArray(ctx);\n        for(i = 0; i < argc; i++) {\n            JS_SetPropertyUint32(ctx, args, i, JS_NewString(ctx, argv[i]));\n        }\n        JS_SetPropertyStr(ctx, global_obj, \"scriptArgs\", args);\n    }\n\n    JS_SetPropertyStr(ctx, global_obj, \"print\",\n                      JS_NewCFunction(ctx, js_print, \"print\", 1));\n    JS_SetPropertyStr(ctx, global_obj, \"__loadScript\",\n                      JS_NewCFunction(ctx, js_loadScript, \"__loadScript\", 1));\n\n    JS_FreeValue(ctx, global_obj);\n}\n\nvoid js_std_init_handlers(JSRuntime *rt)\n{\n    JSThreadState *ts;\n\n    ts = malloc(sizeof(*ts));\n    if (!ts) {\n        fprintf(stderr, \"Could not allocate memory for the worker\");\n        exit(1);\n    }\n    memset(ts, 0, sizeof(*ts));\n    init_list_head(&ts->os_rw_handlers);\n    init_list_head(&ts->os_signal_handlers);\n    init_list_head(&ts->os_timers);\n    init_list_head(&ts->port_list);\n    ts->next_timer_id = 1;\n\n    JS_SetRuntimeOpaque(rt, ts);\n\n#ifdef USE_WORKER\n    /* set the SharedArrayBuffer memory handlers */\n    {\n        JSSharedArrayBufferFunctions sf;\n        memset(&sf, 0, sizeof(sf));\n        sf.sab_alloc = js_sab_alloc;\n        sf.sab_free = js_sab_free;\n        sf.sab_dup = js_sab_dup;\n        JS_SetSharedArrayBufferFunctions(rt, &sf);\n    }\n#endif\n}\n\nvoid js_std_free_handlers(JSRuntime *rt)\n{\n    JSThreadState *ts = JS_GetRuntimeOpaque(rt);\n    struct list_head *el, *el1;\n\n    list_for_each_safe(el, el1, &ts->os_rw_handlers) {\n        JSOSRWHandler *rh = list_entry(el, JSOSRWHandler, link);\n        free_rw_handler(rt, rh);\n    }\n\n    list_for_each_safe(el, el1, &ts->os_signal_handlers) {\n        JSOSSignalHandler *sh = list_entry(el, JSOSSignalHandler, link);\n        free_sh(rt, sh);\n    }\n\n    list_for_each_safe(el, el1, &ts->os_timers) {\n        JSOSTimer *th = list_entry(el, JSOSTimer, link);\n        free_timer(rt, th);\n    }\n\n#ifdef USE_WORKER\n    /* XXX: free port_list ? */\n    js_free_message_pipe(ts->recv_pipe);\n    js_free_message_pipe(ts->send_pipe);\n#endif\n\n    free(ts);\n    JS_SetRuntimeOpaque(rt, NULL); /* fail safe */\n}\n\nstatic void js_dump_obj(JSContext *ctx, FILE *f, JSValueConst val)\n{\n    const char *str;\n\n    str = JS_ToCString(ctx, val);\n    if (str) {\n        fprintf(f, \"%s\\n\", str);\n        JS_FreeCString(ctx, str);\n    } else {\n        fprintf(f, \"[exception]\\n\");\n    }\n}\n\nstatic void js_std_dump_error1(JSContext *ctx, JSValueConst exception_val)\n{\n    JSValue val;\n    BOOL is_error;\n\n    is_error = JS_IsError(ctx, exception_val);\n    js_dump_obj(ctx, stderr, exception_val);\n    if (is_error) {\n        val = JS_GetPropertyStr(ctx, exception_val, \"stack\");\n        if (!JS_IsUndefined(val)) {\n            js_dump_obj(ctx, stderr, val);\n        }\n        JS_FreeValue(ctx, val);\n    }\n}\n\nvoid js_std_dump_error(JSContext *ctx)\n{\n    JSValue exception_val;\n\n    exception_val = JS_GetException(ctx);\n    js_std_dump_error1(ctx, exception_val);\n    JS_FreeValue(ctx, exception_val);\n}\n\nvoid js_std_promise_rejection_tracker(JSContext *ctx, JSValueConst promise,\n                                      JSValueConst reason,\n                                      BOOL is_handled, void *opaque)\n{\n    if (!is_handled) {\n        fprintf(stderr, \"Possibly unhandled promise rejection: \");\n        js_std_dump_error1(ctx, reason);\n    }\n}\n\n/* main loop which calls the user JS callbacks */\nvoid js_std_loop(JSContext *ctx)\n{\n    JSContext *ctx1;\n    int err;\n\n    for(;;) {\n        /* execute the pending jobs */\n        for(;;) {\n            err = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);\n            if (err <= 0) {\n                if (err < 0) {\n                    js_std_dump_error(ctx1);\n                }\n                break;\n            }\n        }\n\n        if (!os_poll_func || os_poll_func(ctx))\n            break;\n    }\n}\n\n/* Wait for a promise and execute pending jobs while waiting for\n   it. Return the promise result or JS_EXCEPTION in case of promise\n   rejection. */\nJSValue js_std_await(JSContext *ctx, JSValue obj)\n{\n    JSValue ret;\n    int state;\n\n    for(;;) {\n        state = JS_PromiseState(ctx, obj);\n        if (state == JS_PROMISE_FULFILLED) {\n            ret = JS_PromiseResult(ctx, obj);\n            JS_FreeValue(ctx, obj);\n            break;\n        } else if (state == JS_PROMISE_REJECTED) {\n            ret = JS_Throw(ctx, JS_PromiseResult(ctx, obj));\n            JS_FreeValue(ctx, obj);\n            break;\n        } else if (state == JS_PROMISE_PENDING) {\n            JSContext *ctx1;\n            int err;\n            err = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);\n            if (err < 0) {\n                js_std_dump_error(ctx1);\n            }\n            if (os_poll_func)\n                os_poll_func(ctx);\n        } else {\n            /* not a promise */\n            ret = obj;\n            break;\n        }\n    }\n    return ret;\n}\n\nvoid js_std_eval_binary(JSContext *ctx, const uint8_t *buf, size_t buf_len,\n                        int load_only)\n{\n    JSValue obj, val;\n    obj = JS_ReadObject(ctx, buf, buf_len, JS_READ_OBJ_BYTECODE);\n    if (JS_IsException(obj))\n        goto exception;\n    if (load_only) {\n        if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {\n            js_module_set_import_meta(ctx, obj, FALSE, FALSE);\n        }\n    } else {\n        if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {\n            if (JS_ResolveModule(ctx, obj) < 0) {\n                JS_FreeValue(ctx, obj);\n                goto exception;\n            }\n            js_module_set_import_meta(ctx, obj, FALSE, TRUE);\n            val = JS_EvalFunction(ctx, obj);\n            val = js_std_await(ctx, val);\n        } else {\n            val = JS_EvalFunction(ctx, obj);\n        }\n        if (JS_IsException(val)) {\n        exception:\n            js_std_dump_error(ctx);\n            exit(1);\n        }\n        JS_FreeValue(ctx, val);\n    }\n}\n"
        },
        {
          "name": "quickjs-libc.h",
          "type": "blob",
          "size": 2.4658203125,
          "content": "/*\n * QuickJS C library\n *\n * Copyright (c) 2017-2018 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#ifndef QUICKJS_LIBC_H\n#define QUICKJS_LIBC_H\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"quickjs.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nJSModuleDef *js_init_module_std(JSContext *ctx, const char *module_name);\nJSModuleDef *js_init_module_os(JSContext *ctx, const char *module_name);\nvoid js_std_add_helpers(JSContext *ctx, int argc, char **argv);\nvoid js_std_loop(JSContext *ctx);\nJSValue js_std_await(JSContext *ctx, JSValue obj);\nvoid js_std_init_handlers(JSRuntime *rt);\nvoid js_std_free_handlers(JSRuntime *rt);\nvoid js_std_dump_error(JSContext *ctx);\nuint8_t *js_load_file(JSContext *ctx, size_t *pbuf_len, const char *filename);\nint js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,\n                              JS_BOOL use_realpath, JS_BOOL is_main);\nJSModuleDef *js_module_loader(JSContext *ctx,\n                              const char *module_name, void *opaque);\nvoid js_std_eval_binary(JSContext *ctx, const uint8_t *buf, size_t buf_len,\n                        int flags);\nvoid js_std_promise_rejection_tracker(JSContext *ctx, JSValueConst promise,\n                                      JSValueConst reason,\n                                      JS_BOOL is_handled, void *opaque);\nvoid js_std_set_worker_new_context_func(JSContext *(*func)(JSRuntime *rt));\n\n#ifdef __cplusplus\n} /* extern \"C\" { */\n#endif\n\n#endif /* QUICKJS_LIBC_H */\n"
        },
        {
          "name": "quickjs-opcode.h",
          "type": "blob",
          "size": 15.5029296875,
          "content": "/*\n * QuickJS opcode definitions\n *\n * Copyright (c) 2017-2018 Fabrice Bellard\n * Copyright (c) 2017-2018 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#ifdef FMT\nFMT(none)\nFMT(none_int)\nFMT(none_loc)\nFMT(none_arg)\nFMT(none_var_ref)\nFMT(u8)\nFMT(i8)\nFMT(loc8)\nFMT(const8)\nFMT(label8)\nFMT(u16)\nFMT(i16)\nFMT(label16)\nFMT(npop)\nFMT(npopx)\nFMT(npop_u16)\nFMT(loc)\nFMT(arg)\nFMT(var_ref)\nFMT(u32)\nFMT(i32)\nFMT(const)\nFMT(label)\nFMT(atom)\nFMT(atom_u8)\nFMT(atom_u16)\nFMT(atom_label_u8)\nFMT(atom_label_u16)\nFMT(label_u16)\n#undef FMT\n#endif /* FMT */\n\n#ifdef DEF\n\n#ifndef def\n#define def(id, size, n_pop, n_push, f) DEF(id, size, n_pop, n_push, f)\n#endif\n\nDEF(invalid, 1, 0, 0, none) /* never emitted */\n\n/* push values */\nDEF(       push_i32, 5, 0, 1, i32)\nDEF(     push_const, 5, 0, 1, const)\nDEF(       fclosure, 5, 0, 1, const) /* must follow push_const */\nDEF(push_atom_value, 5, 0, 1, atom)\nDEF( private_symbol, 5, 0, 1, atom)\nDEF(      undefined, 1, 0, 1, none)\nDEF(           null, 1, 0, 1, none)\nDEF(      push_this, 1, 0, 1, none) /* only used at the start of a function */\nDEF(     push_false, 1, 0, 1, none)\nDEF(      push_true, 1, 0, 1, none)\nDEF(         object, 1, 0, 1, none)\nDEF( special_object, 2, 0, 1, u8) /* only used at the start of a function */\nDEF(           rest, 3, 0, 1, u16) /* only used at the start of a function */\n\nDEF(           drop, 1, 1, 0, none) /* a -> */\nDEF(            nip, 1, 2, 1, none) /* a b -> b */\nDEF(           nip1, 1, 3, 2, none) /* a b c -> b c */\nDEF(            dup, 1, 1, 2, none) /* a -> a a */\nDEF(           dup1, 1, 2, 3, none) /* a b -> a a b */\nDEF(           dup2, 1, 2, 4, none) /* a b -> a b a b */\nDEF(           dup3, 1, 3, 6, none) /* a b c -> a b c a b c */\nDEF(        insert2, 1, 2, 3, none) /* obj a -> a obj a (dup_x1) */\nDEF(        insert3, 1, 3, 4, none) /* obj prop a -> a obj prop a (dup_x2) */\nDEF(        insert4, 1, 4, 5, none) /* this obj prop a -> a this obj prop a */\nDEF(          perm3, 1, 3, 3, none) /* obj a b -> a obj b */\nDEF(          perm4, 1, 4, 4, none) /* obj prop a b -> a obj prop b */\nDEF(          perm5, 1, 5, 5, none) /* this obj prop a b -> a this obj prop b */\nDEF(           swap, 1, 2, 2, none) /* a b -> b a */\nDEF(          swap2, 1, 4, 4, none) /* a b c d -> c d a b */\nDEF(          rot3l, 1, 3, 3, none) /* x a b -> a b x */\nDEF(          rot3r, 1, 3, 3, none) /* a b x -> x a b */\nDEF(          rot4l, 1, 4, 4, none) /* x a b c -> a b c x */\nDEF(          rot5l, 1, 5, 5, none) /* x a b c d -> a b c d x */\n\nDEF(call_constructor, 3, 2, 1, npop) /* func new.target args -> ret. arguments are not counted in n_pop */\nDEF(           call, 3, 1, 1, npop) /* arguments are not counted in n_pop */\nDEF(      tail_call, 3, 1, 0, npop) /* arguments are not counted in n_pop */\nDEF(    call_method, 3, 2, 1, npop) /* arguments are not counted in n_pop */\nDEF(tail_call_method, 3, 2, 0, npop) /* arguments are not counted in n_pop */\nDEF(     array_from, 3, 0, 1, npop) /* arguments are not counted in n_pop */\nDEF(          apply, 3, 3, 1, u16)\nDEF(         return, 1, 1, 0, none)\nDEF(   return_undef, 1, 0, 0, none)\nDEF(check_ctor_return, 1, 1, 2, none)\nDEF(     check_ctor, 1, 0, 0, none)\nDEF(    check_brand, 1, 2, 2, none) /* this_obj func -> this_obj func */\nDEF(      add_brand, 1, 2, 0, none) /* this_obj home_obj -> */\nDEF(   return_async, 1, 1, 0, none)\nDEF(          throw, 1, 1, 0, none)\nDEF(    throw_error, 6, 0, 0, atom_u8)\nDEF(           eval, 5, 1, 1, npop_u16) /* func args... -> ret_val */\nDEF(     apply_eval, 3, 2, 1, u16) /* func array -> ret_eval */\nDEF(         regexp, 1, 2, 1, none) /* create a RegExp object from the pattern and a\n                                       bytecode string */\nDEF(      get_super, 1, 1, 1, none)\nDEF(         import, 1, 1, 1, none) /* dynamic module import */\n\nDEF(      check_var, 5, 0, 1, atom) /* check if a variable exists */\nDEF(  get_var_undef, 5, 0, 1, atom) /* push undefined if the variable does not exist */\nDEF(        get_var, 5, 0, 1, atom) /* throw an exception if the variable does not exist */\nDEF(        put_var, 5, 1, 0, atom) /* must come after get_var */\nDEF(   put_var_init, 5, 1, 0, atom) /* must come after put_var. Used to initialize a global lexical variable */\nDEF( put_var_strict, 5, 2, 0, atom) /* for strict mode variable write */\n\nDEF(  get_ref_value, 1, 2, 3, none)\nDEF(  put_ref_value, 1, 3, 0, none)\n\nDEF(     define_var, 6, 0, 0, atom_u8)\nDEF(check_define_var, 6, 0, 0, atom_u8)\nDEF(    define_func, 6, 1, 0, atom_u8)\nDEF(      get_field, 5, 1, 1, atom)\nDEF(     get_field2, 5, 1, 2, atom)\nDEF(      put_field, 5, 2, 0, atom)\nDEF( get_private_field, 1, 2, 1, none) /* obj prop -> value */\nDEF( put_private_field, 1, 3, 0, none) /* obj value prop -> */\nDEF(define_private_field, 1, 3, 1, none) /* obj prop value -> obj */\nDEF(   get_array_el, 1, 2, 1, none)\nDEF(  get_array_el2, 1, 2, 2, none) /* obj prop -> obj value */\nDEF(   put_array_el, 1, 3, 0, none)\nDEF(get_super_value, 1, 3, 1, none) /* this obj prop -> value */\nDEF(put_super_value, 1, 4, 0, none) /* this obj prop value -> */\nDEF(   define_field, 5, 2, 1, atom)\nDEF(       set_name, 5, 1, 1, atom)\nDEF(set_name_computed, 1, 2, 2, none)\nDEF(      set_proto, 1, 2, 1, none)\nDEF(set_home_object, 1, 2, 2, none)\nDEF(define_array_el, 1, 3, 2, none)\nDEF(         append, 1, 3, 2, none) /* append enumerated object, update length */\nDEF(copy_data_properties, 2, 3, 3, u8)\nDEF(  define_method, 6, 2, 1, atom_u8)\nDEF(define_method_computed, 2, 3, 1, u8) /* must come after define_method */\nDEF(   define_class, 6, 2, 2, atom_u8) /* parent ctor -> ctor proto */\nDEF(   define_class_computed, 6, 3, 3, atom_u8) /* field_name parent ctor -> field_name ctor proto (class with computed name) */\n\nDEF(        get_loc, 3, 0, 1, loc)\nDEF(        put_loc, 3, 1, 0, loc) /* must come after get_loc */\nDEF(        set_loc, 3, 1, 1, loc) /* must come after put_loc */\nDEF(        get_arg, 3, 0, 1, arg)\nDEF(        put_arg, 3, 1, 0, arg) /* must come after get_arg */\nDEF(        set_arg, 3, 1, 1, arg) /* must come after put_arg */\nDEF(    get_var_ref, 3, 0, 1, var_ref)\nDEF(    put_var_ref, 3, 1, 0, var_ref) /* must come after get_var_ref */\nDEF(    set_var_ref, 3, 1, 1, var_ref) /* must come after put_var_ref */\nDEF(set_loc_uninitialized, 3, 0, 0, loc)\nDEF(  get_loc_check, 3, 0, 1, loc)\nDEF(  put_loc_check, 3, 1, 0, loc) /* must come after get_loc_check */\nDEF(  put_loc_check_init, 3, 1, 0, loc)\nDEF(get_loc_checkthis, 3, 0, 1, loc)\nDEF(get_var_ref_check, 3, 0, 1, var_ref)\nDEF(put_var_ref_check, 3, 1, 0, var_ref) /* must come after get_var_ref_check */\nDEF(put_var_ref_check_init, 3, 1, 0, var_ref)\nDEF(      close_loc, 3, 0, 0, loc)\nDEF(       if_false, 5, 1, 0, label)\nDEF(        if_true, 5, 1, 0, label) /* must come after if_false */\nDEF(           goto, 5, 0, 0, label) /* must come after if_true */\nDEF(          catch, 5, 0, 1, label)\nDEF(          gosub, 5, 0, 0, label) /* used to execute the finally block */\nDEF(            ret, 1, 1, 0, none) /* used to return from the finally block */\nDEF(      nip_catch, 1, 2, 1, none) /* catch ... a -> a */\n\nDEF(      to_object, 1, 1, 1, none)\n//DEF(      to_string, 1, 1, 1, none)\nDEF(     to_propkey, 1, 1, 1, none)\nDEF(    to_propkey2, 1, 2, 2, none)\n\nDEF(   with_get_var, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */\nDEF(   with_put_var, 10, 2, 1, atom_label_u8)     /* must be in the same order as scope_xxx */\nDEF(with_delete_var, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */\nDEF(  with_make_ref, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */\nDEF(   with_get_ref, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */\nDEF(with_get_ref_undef, 10, 1, 0, atom_label_u8)\n\nDEF(   make_loc_ref, 7, 0, 2, atom_u16)\nDEF(   make_arg_ref, 7, 0, 2, atom_u16)\nDEF(make_var_ref_ref, 7, 0, 2, atom_u16)\nDEF(   make_var_ref, 5, 0, 2, atom)\n\nDEF(   for_in_start, 1, 1, 1, none)\nDEF(   for_of_start, 1, 1, 3, none)\nDEF(for_await_of_start, 1, 1, 3, none)\nDEF(    for_in_next, 1, 1, 3, none)\nDEF(    for_of_next, 2, 3, 5, u8)\nDEF(iterator_check_object, 1, 1, 1, none)\nDEF(iterator_get_value_done, 1, 1, 2, none)\nDEF( iterator_close, 1, 3, 0, none)\nDEF(  iterator_next, 1, 4, 4, none)\nDEF(  iterator_call, 2, 4, 5, u8)\nDEF(  initial_yield, 1, 0, 0, none)\nDEF(          yield, 1, 1, 2, none)\nDEF(     yield_star, 1, 1, 2, none)\nDEF(async_yield_star, 1, 1, 2, none)\nDEF(          await, 1, 1, 1, none)\n\n/* arithmetic/logic operations */\nDEF(            neg, 1, 1, 1, none)\nDEF(           plus, 1, 1, 1, none)\nDEF(            dec, 1, 1, 1, none)\nDEF(            inc, 1, 1, 1, none)\nDEF(       post_dec, 1, 1, 2, none)\nDEF(       post_inc, 1, 1, 2, none)\nDEF(        dec_loc, 2, 0, 0, loc8)\nDEF(        inc_loc, 2, 0, 0, loc8)\nDEF(        add_loc, 2, 1, 0, loc8)\nDEF(            not, 1, 1, 1, none)\nDEF(           lnot, 1, 1, 1, none)\nDEF(         typeof, 1, 1, 1, none)\nDEF(         delete, 1, 2, 1, none)\nDEF(     delete_var, 5, 0, 1, atom)\n\nDEF(            mul, 1, 2, 1, none)\nDEF(            div, 1, 2, 1, none)\nDEF(            mod, 1, 2, 1, none)\nDEF(            add, 1, 2, 1, none)\nDEF(            sub, 1, 2, 1, none)\nDEF(            pow, 1, 2, 1, none)\nDEF(            shl, 1, 2, 1, none)\nDEF(            sar, 1, 2, 1, none)\nDEF(            shr, 1, 2, 1, none)\nDEF(             lt, 1, 2, 1, none)\nDEF(            lte, 1, 2, 1, none)\nDEF(             gt, 1, 2, 1, none)\nDEF(            gte, 1, 2, 1, none)\nDEF(     instanceof, 1, 2, 1, none)\nDEF(             in, 1, 2, 1, none)\nDEF(             eq, 1, 2, 1, none)\nDEF(            neq, 1, 2, 1, none)\nDEF(      strict_eq, 1, 2, 1, none)\nDEF(     strict_neq, 1, 2, 1, none)\nDEF(            and, 1, 2, 1, none)\nDEF(            xor, 1, 2, 1, none)\nDEF(             or, 1, 2, 1, none)\nDEF(is_undefined_or_null, 1, 1, 1, none)\nDEF(     private_in, 1, 2, 1, none)\n#ifdef CONFIG_BIGNUM\nDEF(      mul_pow10, 1, 2, 1, none)\nDEF(       math_mod, 1, 2, 1, none)\n#endif\n/* must be the last non short and non temporary opcode */\nDEF(            nop, 1, 0, 0, none)\n\n/* temporary opcodes: never emitted in the final bytecode */\n\ndef(    enter_scope, 3, 0, 0, u16)  /* emitted in phase 1, removed in phase 2 */\ndef(    leave_scope, 3, 0, 0, u16)  /* emitted in phase 1, removed in phase 2 */\n\ndef(          label, 5, 0, 0, label) /* emitted in phase 1, removed in phase 3 */\n\n/* the following opcodes must be in the same order as the 'with_x' and\n   get_var_undef, get_var and put_var opcodes */\ndef(scope_get_var_undef, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */\ndef(  scope_get_var, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */\ndef(  scope_put_var, 7, 1, 0, atom_u16) /* emitted in phase 1, removed in phase 2 */\ndef(scope_delete_var, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */\ndef( scope_make_ref, 11, 0, 2, atom_label_u16) /* emitted in phase 1, removed in phase 2 */\ndef(  scope_get_ref, 7, 0, 2, atom_u16) /* emitted in phase 1, removed in phase 2 */\ndef(scope_put_var_init, 7, 0, 2, atom_u16) /* emitted in phase 1, removed in phase 2 */\ndef(scope_get_var_checkthis, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2, only used to return 'this' in derived class constructors */\ndef(scope_get_private_field, 7, 1, 1, atom_u16) /* obj -> value, emitted in phase 1, removed in phase 2 */\ndef(scope_get_private_field2, 7, 1, 2, atom_u16) /* obj -> obj value, emitted in phase 1, removed in phase 2 */\ndef(scope_put_private_field, 7, 2, 0, atom_u16) /* obj value ->, emitted in phase 1, removed in phase 2 */\ndef(scope_in_private_field, 7, 1, 1, atom_u16) /* obj -> res emitted in phase 1, removed in phase 2 */\ndef(get_field_opt_chain, 5, 1, 1, atom) /* emitted in phase 1, removed in phase 2 */\ndef(get_array_el_opt_chain, 1, 2, 1, none) /* emitted in phase 1, removed in phase 2 */\ndef( set_class_name, 5, 1, 1, u32) /* emitted in phase 1, removed in phase 2 */\n\ndef(       line_num, 5, 0, 0, u32) /* emitted in phase 1, removed in phase 3 */\n\n#if SHORT_OPCODES\nDEF(    push_minus1, 1, 0, 1, none_int)\nDEF(         push_0, 1, 0, 1, none_int)\nDEF(         push_1, 1, 0, 1, none_int)\nDEF(         push_2, 1, 0, 1, none_int)\nDEF(         push_3, 1, 0, 1, none_int)\nDEF(         push_4, 1, 0, 1, none_int)\nDEF(         push_5, 1, 0, 1, none_int)\nDEF(         push_6, 1, 0, 1, none_int)\nDEF(         push_7, 1, 0, 1, none_int)\nDEF(        push_i8, 2, 0, 1, i8)\nDEF(       push_i16, 3, 0, 1, i16)\nDEF(    push_const8, 2, 0, 1, const8)\nDEF(      fclosure8, 2, 0, 1, const8) /* must follow push_const8 */\nDEF(push_empty_string, 1, 0, 1, none)\n\nDEF(       get_loc8, 2, 0, 1, loc8)\nDEF(       put_loc8, 2, 1, 0, loc8)\nDEF(       set_loc8, 2, 1, 1, loc8)\n\nDEF(       get_loc0, 1, 0, 1, none_loc)\nDEF(       get_loc1, 1, 0, 1, none_loc)\nDEF(       get_loc2, 1, 0, 1, none_loc)\nDEF(       get_loc3, 1, 0, 1, none_loc)\nDEF(       put_loc0, 1, 1, 0, none_loc)\nDEF(       put_loc1, 1, 1, 0, none_loc)\nDEF(       put_loc2, 1, 1, 0, none_loc)\nDEF(       put_loc3, 1, 1, 0, none_loc)\nDEF(       set_loc0, 1, 1, 1, none_loc)\nDEF(       set_loc1, 1, 1, 1, none_loc)\nDEF(       set_loc2, 1, 1, 1, none_loc)\nDEF(       set_loc3, 1, 1, 1, none_loc)\nDEF(       get_arg0, 1, 0, 1, none_arg)\nDEF(       get_arg1, 1, 0, 1, none_arg)\nDEF(       get_arg2, 1, 0, 1, none_arg)\nDEF(       get_arg3, 1, 0, 1, none_arg)\nDEF(       put_arg0, 1, 1, 0, none_arg)\nDEF(       put_arg1, 1, 1, 0, none_arg)\nDEF(       put_arg2, 1, 1, 0, none_arg)\nDEF(       put_arg3, 1, 1, 0, none_arg)\nDEF(       set_arg0, 1, 1, 1, none_arg)\nDEF(       set_arg1, 1, 1, 1, none_arg)\nDEF(       set_arg2, 1, 1, 1, none_arg)\nDEF(       set_arg3, 1, 1, 1, none_arg)\nDEF(   get_var_ref0, 1, 0, 1, none_var_ref)\nDEF(   get_var_ref1, 1, 0, 1, none_var_ref)\nDEF(   get_var_ref2, 1, 0, 1, none_var_ref)\nDEF(   get_var_ref3, 1, 0, 1, none_var_ref)\nDEF(   put_var_ref0, 1, 1, 0, none_var_ref)\nDEF(   put_var_ref1, 1, 1, 0, none_var_ref)\nDEF(   put_var_ref2, 1, 1, 0, none_var_ref)\nDEF(   put_var_ref3, 1, 1, 0, none_var_ref)\nDEF(   set_var_ref0, 1, 1, 1, none_var_ref)\nDEF(   set_var_ref1, 1, 1, 1, none_var_ref)\nDEF(   set_var_ref2, 1, 1, 1, none_var_ref)\nDEF(   set_var_ref3, 1, 1, 1, none_var_ref)\n\nDEF(     get_length, 1, 1, 1, none)\n\nDEF(      if_false8, 2, 1, 0, label8)\nDEF(       if_true8, 2, 1, 0, label8) /* must come after if_false8 */\nDEF(          goto8, 2, 0, 0, label8) /* must come after if_true8 */\nDEF(         goto16, 3, 0, 0, label16)\n\nDEF(          call0, 1, 1, 1, npopx)\nDEF(          call1, 1, 1, 1, npopx)\nDEF(          call2, 1, 1, 1, npopx)\nDEF(          call3, 1, 1, 1, npopx)\n\nDEF(   is_undefined, 1, 1, 1, none)\nDEF(        is_null, 1, 1, 1, none)\nDEF(typeof_is_undefined, 1, 1, 1, none)\nDEF( typeof_is_function, 1, 1, 1, none)\n#endif\n\n#undef DEF\n#undef def\n#endif  /* DEF */\n"
        },
        {
          "name": "quickjs.c",
          "type": "blob",
          "size": 1780.1083984375,
          "content": "/*\n * QuickJS Javascript Engine\n *\n * Copyright (c) 2017-2021 Fabrice Bellard\n * Copyright (c) 2017-2021 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <string.h>\n#include <assert.h>\n#include <sys/time.h>\n#include <time.h>\n#include <fenv.h>\n#include <math.h>\n#if defined(__APPLE__)\n#include <malloc/malloc.h>\n#elif defined(__linux__) || defined(__GLIBC__)\n#include <malloc.h>\n#elif defined(__FreeBSD__)\n#include <malloc_np.h>\n#endif\n\n#include \"cutils.h\"\n#include \"list.h\"\n#include \"quickjs.h\"\n#include \"libregexp.h\"\n#include \"libunicode.h\"\n#include \"libbf.h\"\n\n#define OPTIMIZE         1\n#define SHORT_OPCODES    1\n#if defined(EMSCRIPTEN)\n#define DIRECT_DISPATCH  0\n#else\n#define DIRECT_DISPATCH  1\n#endif\n\n#if defined(__APPLE__)\n#define MALLOC_OVERHEAD  0\n#else\n#define MALLOC_OVERHEAD  8\n#endif\n\n#if !defined(_WIN32)\n/* define it if printf uses the RNDN rounding mode instead of RNDNA */\n#define CONFIG_PRINTF_RNDN\n#endif\n\n/* define to include Atomics.* operations which depend on the OS\n   threads */\n#if !defined(EMSCRIPTEN)\n#define CONFIG_ATOMICS\n#endif\n\n#if !defined(EMSCRIPTEN)\n/* enable stack limitation */\n#define CONFIG_STACK_CHECK\n#endif\n\n\n/* dump object free */\n//#define DUMP_FREE\n//#define DUMP_CLOSURE\n/* dump the bytecode of the compiled functions: combination of bits\n   1: dump pass 3 final byte code\n   2: dump pass 2 code\n   4: dump pass 1 code\n   8: dump stdlib functions\n  16: dump bytecode in hex\n  32: dump line number table\n  64: dump compute_stack_size\n */\n//#define DUMP_BYTECODE  (1)\n/* dump the occurence of the automatic GC */\n//#define DUMP_GC\n/* dump objects freed by the garbage collector */\n//#define DUMP_GC_FREE\n/* dump objects leaking when freeing the runtime */\n//#define DUMP_LEAKS  1\n/* dump memory usage before running the garbage collector */\n//#define DUMP_MEM\n//#define DUMP_OBJECTS    /* dump objects in JS_FreeContext */\n//#define DUMP_ATOMS      /* dump atoms in JS_FreeContext */\n//#define DUMP_SHAPES     /* dump shapes in JS_FreeContext */\n//#define DUMP_MODULE_RESOLVE\n//#define DUMP_PROMISE\n//#define DUMP_READ_OBJECT\n\n/* test the GC by forcing it before each object allocation */\n//#define FORCE_GC_AT_MALLOC\n\n#ifdef CONFIG_ATOMICS\n#include <pthread.h>\n#include <stdatomic.h>\n#include <errno.h>\n#endif\n\nenum {\n    /* classid tag        */    /* union usage   | properties */\n    JS_CLASS_OBJECT = 1,        /* must be first */\n    JS_CLASS_ARRAY,             /* u.array       | length */\n    JS_CLASS_ERROR,\n    JS_CLASS_NUMBER,            /* u.object_data */\n    JS_CLASS_STRING,            /* u.object_data */\n    JS_CLASS_BOOLEAN,           /* u.object_data */\n    JS_CLASS_SYMBOL,            /* u.object_data */\n    JS_CLASS_ARGUMENTS,         /* u.array       | length */\n    JS_CLASS_MAPPED_ARGUMENTS,  /*               | length */\n    JS_CLASS_DATE,              /* u.object_data */\n    JS_CLASS_MODULE_NS,\n    JS_CLASS_C_FUNCTION,        /* u.cfunc */\n    JS_CLASS_BYTECODE_FUNCTION, /* u.func */\n    JS_CLASS_BOUND_FUNCTION,    /* u.bound_function */\n    JS_CLASS_C_FUNCTION_DATA,   /* u.c_function_data_record */\n    JS_CLASS_GENERATOR_FUNCTION, /* u.func */\n    JS_CLASS_FOR_IN_ITERATOR,   /* u.for_in_iterator */\n    JS_CLASS_REGEXP,            /* u.regexp */\n    JS_CLASS_ARRAY_BUFFER,      /* u.array_buffer */\n    JS_CLASS_SHARED_ARRAY_BUFFER, /* u.array_buffer */\n    JS_CLASS_UINT8C_ARRAY,      /* u.array (typed_array) */\n    JS_CLASS_INT8_ARRAY,        /* u.array (typed_array) */\n    JS_CLASS_UINT8_ARRAY,       /* u.array (typed_array) */\n    JS_CLASS_INT16_ARRAY,       /* u.array (typed_array) */\n    JS_CLASS_UINT16_ARRAY,      /* u.array (typed_array) */\n    JS_CLASS_INT32_ARRAY,       /* u.array (typed_array) */\n    JS_CLASS_UINT32_ARRAY,      /* u.array (typed_array) */\n    JS_CLASS_BIG_INT64_ARRAY,   /* u.array (typed_array) */\n    JS_CLASS_BIG_UINT64_ARRAY,  /* u.array (typed_array) */\n    JS_CLASS_FLOAT32_ARRAY,     /* u.array (typed_array) */\n    JS_CLASS_FLOAT64_ARRAY,     /* u.array (typed_array) */\n    JS_CLASS_DATAVIEW,          /* u.typed_array */\n    JS_CLASS_BIG_INT,           /* u.object_data */\n#ifdef CONFIG_BIGNUM\n    JS_CLASS_BIG_FLOAT,         /* u.object_data */\n    JS_CLASS_FLOAT_ENV,         /* u.float_env */\n    JS_CLASS_BIG_DECIMAL,       /* u.object_data */\n    JS_CLASS_OPERATOR_SET,      /* u.operator_set */\n#endif\n    JS_CLASS_MAP,               /* u.map_state */\n    JS_CLASS_SET,               /* u.map_state */\n    JS_CLASS_WEAKMAP,           /* u.map_state */\n    JS_CLASS_WEAKSET,           /* u.map_state */\n    JS_CLASS_MAP_ITERATOR,      /* u.map_iterator_data */\n    JS_CLASS_SET_ITERATOR,      /* u.map_iterator_data */\n    JS_CLASS_ARRAY_ITERATOR,    /* u.array_iterator_data */\n    JS_CLASS_STRING_ITERATOR,   /* u.array_iterator_data */\n    JS_CLASS_REGEXP_STRING_ITERATOR,   /* u.regexp_string_iterator_data */\n    JS_CLASS_GENERATOR,         /* u.generator_data */\n    JS_CLASS_PROXY,             /* u.proxy_data */\n    JS_CLASS_PROMISE,           /* u.promise_data */\n    JS_CLASS_PROMISE_RESOLVE_FUNCTION,  /* u.promise_function_data */\n    JS_CLASS_PROMISE_REJECT_FUNCTION,   /* u.promise_function_data */\n    JS_CLASS_ASYNC_FUNCTION,            /* u.func */\n    JS_CLASS_ASYNC_FUNCTION_RESOLVE,    /* u.async_function_data */\n    JS_CLASS_ASYNC_FUNCTION_REJECT,     /* u.async_function_data */\n    JS_CLASS_ASYNC_FROM_SYNC_ITERATOR,  /* u.async_from_sync_iterator_data */\n    JS_CLASS_ASYNC_GENERATOR_FUNCTION,  /* u.func */\n    JS_CLASS_ASYNC_GENERATOR,   /* u.async_generator_data */\n\n    JS_CLASS_INIT_COUNT, /* last entry for predefined classes */\n};\n\n/* number of typed array types */\n#define JS_TYPED_ARRAY_COUNT  (JS_CLASS_FLOAT64_ARRAY - JS_CLASS_UINT8C_ARRAY + 1)\nstatic uint8_t const typed_array_size_log2[JS_TYPED_ARRAY_COUNT];\n#define typed_array_size_log2(classid)  (typed_array_size_log2[(classid)- JS_CLASS_UINT8C_ARRAY])\n\ntypedef enum JSErrorEnum {\n    JS_EVAL_ERROR,\n    JS_RANGE_ERROR,\n    JS_REFERENCE_ERROR,\n    JS_SYNTAX_ERROR,\n    JS_TYPE_ERROR,\n    JS_URI_ERROR,\n    JS_INTERNAL_ERROR,\n    JS_AGGREGATE_ERROR,\n\n    JS_NATIVE_ERROR_COUNT, /* number of different NativeError objects */\n} JSErrorEnum;\n\n#define JS_MAX_LOCAL_VARS 65535\n#define JS_STACK_SIZE_MAX 65534\n#define JS_STRING_LEN_MAX ((1 << 30) - 1)\n\n#define __exception __attribute__((warn_unused_result))\n\ntypedef struct JSShape JSShape;\ntypedef struct JSString JSString;\ntypedef struct JSString JSAtomStruct;\n\ntypedef enum {\n    JS_GC_PHASE_NONE,\n    JS_GC_PHASE_DECREF,\n    JS_GC_PHASE_REMOVE_CYCLES,\n} JSGCPhaseEnum;\n\ntypedef enum OPCodeEnum OPCodeEnum;\n\n/* function pointers are used for numeric operations so that it is\n   possible to remove some numeric types */\ntypedef struct {\n    JSValue (*to_string)(JSContext *ctx, JSValueConst val);\n    JSValue (*from_string)(JSContext *ctx, const char *buf,\n                           int radix, int flags, slimb_t *pexponent);\n    int (*unary_arith)(JSContext *ctx,\n                       JSValue *pres, OPCodeEnum op, JSValue op1);\n    int (*binary_arith)(JSContext *ctx, OPCodeEnum op,\n                        JSValue *pres, JSValue op1, JSValue op2);\n    int (*compare)(JSContext *ctx, OPCodeEnum op,\n                   JSValue op1, JSValue op2);\n    /* only for bigfloat: */\n    JSValue (*mul_pow10_to_float64)(JSContext *ctx, const bf_t *a,\n                                    int64_t exponent);\n    int (*mul_pow10)(JSContext *ctx, JSValue *sp);\n} JSNumericOperations;\n\nstruct JSRuntime {\n    JSMallocFunctions mf;\n    JSMallocState malloc_state;\n    const char *rt_info;\n\n    int atom_hash_size; /* power of two */\n    int atom_count;\n    int atom_size;\n    int atom_count_resize; /* resize hash table at this count */\n    uint32_t *atom_hash;\n    JSAtomStruct **atom_array;\n    int atom_free_index; /* 0 = none */\n\n    int class_count;    /* size of class_array */\n    JSClass *class_array;\n\n    struct list_head context_list; /* list of JSContext.link */\n    /* list of JSGCObjectHeader.link. List of allocated GC objects (used\n       by the garbage collector) */\n    struct list_head gc_obj_list;\n    /* list of JSGCObjectHeader.link. Used during JS_FreeValueRT() */\n    struct list_head gc_zero_ref_count_list;\n    struct list_head tmp_obj_list; /* used during GC */\n    JSGCPhaseEnum gc_phase : 8;\n    size_t malloc_gc_threshold;\n#ifdef DUMP_LEAKS\n    struct list_head string_list; /* list of JSString.link */\n#endif\n    /* stack limitation */\n    uintptr_t stack_size; /* in bytes, 0 if no limit */\n    uintptr_t stack_top;\n    uintptr_t stack_limit; /* lower stack limit */\n\n    JSValue current_exception;\n    /* true if inside an out of memory error, to avoid recursing */\n    BOOL in_out_of_memory : 8;\n\n    struct JSStackFrame *current_stack_frame;\n\n    JSInterruptHandler *interrupt_handler;\n    void *interrupt_opaque;\n\n    JSHostPromiseRejectionTracker *host_promise_rejection_tracker;\n    void *host_promise_rejection_tracker_opaque;\n\n    struct list_head job_list; /* list of JSJobEntry.link */\n\n    JSModuleNormalizeFunc *module_normalize_func;\n    JSModuleLoaderFunc *module_loader_func;\n    void *module_loader_opaque;\n    /* timestamp for internal use in module evaluation */\n    int64_t module_async_evaluation_next_timestamp;\n\n    BOOL can_block : 8; /* TRUE if Atomics.wait can block */\n    /* used to allocate, free and clone SharedArrayBuffers */\n    JSSharedArrayBufferFunctions sab_funcs;\n\n    /* Shape hash table */\n    int shape_hash_bits;\n    int shape_hash_size;\n    int shape_hash_count; /* number of hashed shapes */\n    JSShape **shape_hash;\n    bf_context_t bf_ctx;\n    JSNumericOperations bigint_ops;\n#ifdef CONFIG_BIGNUM\n    JSNumericOperations bigfloat_ops;\n    JSNumericOperations bigdecimal_ops;\n    uint32_t operator_count;\n#endif\n    void *user_opaque;\n};\n\nstruct JSClass {\n    uint32_t class_id; /* 0 means free entry */\n    JSAtom class_name;\n    JSClassFinalizer *finalizer;\n    JSClassGCMark *gc_mark;\n    JSClassCall *call;\n    /* pointers for exotic behavior, can be NULL if none are present */\n    const JSClassExoticMethods *exotic;\n};\n\n#define JS_MODE_STRICT (1 << 0)\n#define JS_MODE_STRIP  (1 << 1)\n#define JS_MODE_MATH   (1 << 2)\n#define JS_MODE_ASYNC  (1 << 3) /* async function */\n\ntypedef struct JSStackFrame {\n    struct JSStackFrame *prev_frame; /* NULL if first stack frame */\n    JSValue cur_func; /* current function, JS_UNDEFINED if the frame is detached */\n    JSValue *arg_buf; /* arguments */\n    JSValue *var_buf; /* variables */\n    struct list_head var_ref_list; /* list of JSVarRef.var_ref_link */\n    const uint8_t *cur_pc; /* only used in bytecode functions : PC of the\n                        instruction after the call */\n    int arg_count;\n    int js_mode; /* for C functions, only JS_MODE_MATH may be set */\n    /* only used in generators. Current stack pointer value. NULL if\n       the function is running. */\n    JSValue *cur_sp;\n} JSStackFrame;\n\ntypedef enum {\n    JS_GC_OBJ_TYPE_JS_OBJECT,\n    JS_GC_OBJ_TYPE_FUNCTION_BYTECODE,\n    JS_GC_OBJ_TYPE_SHAPE,\n    JS_GC_OBJ_TYPE_VAR_REF,\n    JS_GC_OBJ_TYPE_ASYNC_FUNCTION,\n    JS_GC_OBJ_TYPE_JS_CONTEXT,\n} JSGCObjectTypeEnum;\n\n/* header for GC objects. GC objects are C data structures with a\n   reference count that can reference other GC objects. JS Objects are\n   a particular type of GC object. */\nstruct JSGCObjectHeader {\n    int ref_count; /* must come first, 32-bit */\n    JSGCObjectTypeEnum gc_obj_type : 4;\n    uint8_t mark : 4; /* used by the GC */\n    uint8_t dummy1; /* not used by the GC */\n    uint16_t dummy2; /* not used by the GC */\n    struct list_head link;\n};\n\ntypedef struct JSVarRef {\n    union {\n        JSGCObjectHeader header; /* must come first */\n        struct {\n            int __gc_ref_count; /* corresponds to header.ref_count */\n            uint8_t __gc_mark; /* corresponds to header.mark/gc_obj_type */\n            uint8_t is_detached : 1;\n            uint8_t is_arg : 1;\n            uint16_t var_idx; /* index of the corresponding function variable on\n                                 the stack */\n        };\n    };\n    JSValue *pvalue; /* pointer to the value, either on the stack or\n                        to 'value' */\n    union {\n        JSValue value; /* used when is_detached = TRUE */\n        struct {\n            struct list_head var_ref_link; /* JSStackFrame.var_ref_list list */\n            struct JSAsyncFunctionState *async_func; /* != NULL if async stack frame */\n        }; /* used when is_detached = FALSE */\n    };\n} JSVarRef;\n\n/* the same structure is used for big integers and big floats. Big\n   integers are never infinite or NaNs */\ntypedef struct JSBigFloat {\n    JSRefCountHeader header; /* must come first, 32-bit */\n    bf_t num;\n} JSBigFloat;\n\n#ifdef CONFIG_BIGNUM\ntypedef struct JSFloatEnv {\n    limb_t prec;\n    bf_flags_t flags;\n    unsigned int status;\n} JSFloatEnv;\n\ntypedef struct JSBigDecimal {\n    JSRefCountHeader header; /* must come first, 32-bit */\n    bfdec_t num;\n} JSBigDecimal;\n#endif\n\ntypedef enum {\n    JS_AUTOINIT_ID_PROTOTYPE,\n    JS_AUTOINIT_ID_MODULE_NS,\n    JS_AUTOINIT_ID_PROP,\n} JSAutoInitIDEnum;\n\n/* must be large enough to have a negligible runtime cost and small\n   enough to call the interrupt callback often. */\n#define JS_INTERRUPT_COUNTER_INIT 10000\n\nstruct JSContext {\n    JSGCObjectHeader header; /* must come first */\n    JSRuntime *rt;\n    struct list_head link;\n\n    uint16_t binary_object_count;\n    int binary_object_size;\n\n    JSShape *array_shape;   /* initial shape for Array objects */\n\n    JSValue *class_proto;\n    JSValue function_proto;\n    JSValue function_ctor;\n    JSValue array_ctor;\n    JSValue regexp_ctor;\n    JSValue promise_ctor;\n    JSValue native_error_proto[JS_NATIVE_ERROR_COUNT];\n    JSValue iterator_proto;\n    JSValue async_iterator_proto;\n    JSValue array_proto_values;\n    JSValue throw_type_error;\n    JSValue eval_obj;\n\n    JSValue global_obj; /* global object */\n    JSValue global_var_obj; /* contains the global let/const definitions */\n\n    uint64_t random_state;\n    bf_context_t *bf_ctx;   /* points to rt->bf_ctx, shared by all contexts */\n#ifdef CONFIG_BIGNUM\n    JSFloatEnv fp_env; /* global FP environment */\n    BOOL bignum_ext : 8; /* enable math mode */\n    BOOL allow_operator_overloading : 8;\n#endif\n    /* when the counter reaches zero, JSRutime.interrupt_handler is called */\n    int interrupt_counter;\n\n    struct list_head loaded_modules; /* list of JSModuleDef.link */\n\n    /* if NULL, RegExp compilation is not supported */\n    JSValue (*compile_regexp)(JSContext *ctx, JSValueConst pattern,\n                              JSValueConst flags);\n    /* if NULL, eval is not supported */\n    JSValue (*eval_internal)(JSContext *ctx, JSValueConst this_obj,\n                             const char *input, size_t input_len,\n                             const char *filename, int flags, int scope_idx);\n    void *user_opaque;\n};\n\ntypedef union JSFloat64Union {\n    double d;\n    uint64_t u64;\n    uint32_t u32[2];\n} JSFloat64Union;\n\nenum {\n    JS_ATOM_TYPE_STRING = 1,\n    JS_ATOM_TYPE_GLOBAL_SYMBOL,\n    JS_ATOM_TYPE_SYMBOL,\n    JS_ATOM_TYPE_PRIVATE,\n};\n\nenum {\n    JS_ATOM_HASH_SYMBOL,\n    JS_ATOM_HASH_PRIVATE,\n};\n\ntypedef enum {\n    JS_ATOM_KIND_STRING,\n    JS_ATOM_KIND_SYMBOL,\n    JS_ATOM_KIND_PRIVATE,\n} JSAtomKindEnum;\n\n#define JS_ATOM_HASH_MASK  ((1 << 30) - 1)\n\nstruct JSString {\n    JSRefCountHeader header; /* must come first, 32-bit */\n    uint32_t len : 31;\n    uint8_t is_wide_char : 1; /* 0 = 8 bits, 1 = 16 bits characters */\n    /* for JS_ATOM_TYPE_SYMBOL: hash = 0, atom_type = 3,\n       for JS_ATOM_TYPE_PRIVATE: hash = 1, atom_type = 3\n       XXX: could change encoding to have one more bit in hash */\n    uint32_t hash : 30;\n    uint8_t atom_type : 2; /* != 0 if atom, JS_ATOM_TYPE_x */\n    uint32_t hash_next; /* atom_index for JS_ATOM_TYPE_SYMBOL */\n#ifdef DUMP_LEAKS\n    struct list_head link; /* string list */\n#endif\n    union {\n        uint8_t str8[0]; /* 8 bit strings will get an extra null terminator */\n        uint16_t str16[0];\n    } u;\n};\n\ntypedef struct JSClosureVar {\n    uint8_t is_local : 1;\n    uint8_t is_arg : 1;\n    uint8_t is_const : 1;\n    uint8_t is_lexical : 1;\n    uint8_t var_kind : 4; /* see JSVarKindEnum */\n    /* 8 bits available */\n    uint16_t var_idx; /* is_local = TRUE: index to a normal variable of the\n                    parent function. otherwise: index to a closure\n                    variable of the parent function */\n    JSAtom var_name;\n} JSClosureVar;\n\n#define ARG_SCOPE_INDEX 1\n#define ARG_SCOPE_END (-2)\n\ntypedef struct JSVarScope {\n    int parent;  /* index into fd->scopes of the enclosing scope */\n    int first;   /* index into fd->vars of the last variable in this scope */\n} JSVarScope;\n\ntypedef enum {\n    /* XXX: add more variable kinds here instead of using bit fields */\n    JS_VAR_NORMAL,\n    JS_VAR_FUNCTION_DECL, /* lexical var with function declaration */\n    JS_VAR_NEW_FUNCTION_DECL, /* lexical var with async/generator\n                                 function declaration */\n    JS_VAR_CATCH,\n    JS_VAR_FUNCTION_NAME, /* function expression name */\n    JS_VAR_PRIVATE_FIELD,\n    JS_VAR_PRIVATE_METHOD,\n    JS_VAR_PRIVATE_GETTER,\n    JS_VAR_PRIVATE_SETTER, /* must come after JS_VAR_PRIVATE_GETTER */\n    JS_VAR_PRIVATE_GETTER_SETTER, /* must come after JS_VAR_PRIVATE_SETTER */\n} JSVarKindEnum;\n\n/* XXX: could use a different structure in bytecode functions to save\n   memory */\ntypedef struct JSVarDef {\n    JSAtom var_name;\n    /* index into fd->scopes of this variable lexical scope */\n    int scope_level;\n    /* during compilation:\n        - if scope_level = 0: scope in which the variable is defined\n        - if scope_level != 0: index into fd->vars of the next\n          variable in the same or enclosing lexical scope\n       in a bytecode function:\n       index into fd->vars of the next\n       variable in the same or enclosing lexical scope\n    */\n    int scope_next;\n    uint8_t is_const : 1;\n    uint8_t is_lexical : 1;\n    uint8_t is_captured : 1;\n    uint8_t is_static_private : 1; /* only used during private class field parsing */\n    uint8_t var_kind : 4; /* see JSVarKindEnum */\n    /* only used during compilation: function pool index for lexical\n       variables with var_kind =\n       JS_VAR_FUNCTION_DECL/JS_VAR_NEW_FUNCTION_DECL or scope level of\n       the definition of the 'var' variables (they have scope_level =\n       0) */\n    int func_pool_idx : 24; /* only used during compilation : index in\n                               the constant pool for hoisted function\n                               definition */\n} JSVarDef;\n\n/* for the encoding of the pc2line table */\n#define PC2LINE_BASE     (-1)\n#define PC2LINE_RANGE    5\n#define PC2LINE_OP_FIRST 1\n#define PC2LINE_DIFF_PC_MAX ((255 - PC2LINE_OP_FIRST) / PC2LINE_RANGE)\n\ntypedef enum JSFunctionKindEnum {\n    JS_FUNC_NORMAL = 0,\n    JS_FUNC_GENERATOR = (1 << 0),\n    JS_FUNC_ASYNC = (1 << 1),\n    JS_FUNC_ASYNC_GENERATOR = (JS_FUNC_GENERATOR | JS_FUNC_ASYNC),\n} JSFunctionKindEnum;\n\ntypedef struct JSFunctionBytecode {\n    JSGCObjectHeader header; /* must come first */\n    uint8_t js_mode;\n    uint8_t has_prototype : 1; /* true if a prototype field is necessary */\n    uint8_t has_simple_parameter_list : 1;\n    uint8_t is_derived_class_constructor : 1;\n    /* true if home_object needs to be initialized */\n    uint8_t need_home_object : 1;\n    uint8_t func_kind : 2;\n    uint8_t new_target_allowed : 1;\n    uint8_t super_call_allowed : 1;\n    uint8_t super_allowed : 1;\n    uint8_t arguments_allowed : 1;\n    uint8_t has_debug : 1;\n    uint8_t backtrace_barrier : 1; /* stop backtrace on this function */\n    uint8_t read_only_bytecode : 1;\n    uint8_t is_direct_or_indirect_eval : 1; /* used by JS_GetScriptOrModuleName() */\n    /* XXX: 10 bits available */\n    uint8_t *byte_code_buf; /* (self pointer) */\n    int byte_code_len;\n    JSAtom func_name;\n    JSVarDef *vardefs; /* arguments + local variables (arg_count + var_count) (self pointer) */\n    JSClosureVar *closure_var; /* list of variables in the closure (self pointer) */\n    uint16_t arg_count;\n    uint16_t var_count;\n    uint16_t defined_arg_count; /* for length function property */\n    uint16_t stack_size; /* maximum stack size */\n    JSContext *realm; /* function realm */\n    JSValue *cpool; /* constant pool (self pointer) */\n    int cpool_count;\n    int closure_var_count;\n    struct {\n        /* debug info, move to separate structure to save memory? */\n        JSAtom filename;\n        int line_num;\n        int source_len;\n        int pc2line_len;\n        uint8_t *pc2line_buf;\n        char *source;\n    } debug;\n} JSFunctionBytecode;\n\ntypedef struct JSBoundFunction {\n    JSValue func_obj;\n    JSValue this_val;\n    int argc;\n    JSValue argv[0];\n} JSBoundFunction;\n\ntypedef enum JSIteratorKindEnum {\n    JS_ITERATOR_KIND_KEY,\n    JS_ITERATOR_KIND_VALUE,\n    JS_ITERATOR_KIND_KEY_AND_VALUE,\n} JSIteratorKindEnum;\n\ntypedef struct JSForInIterator {\n    JSValue obj;\n    uint32_t idx;\n    uint32_t atom_count;\n    uint8_t in_prototype_chain;\n    uint8_t is_array;\n    JSPropertyEnum *tab_atom; /* is_array = FALSE */\n} JSForInIterator;\n\ntypedef struct JSRegExp {\n    JSString *pattern;\n    JSString *bytecode; /* also contains the flags */\n} JSRegExp;\n\ntypedef struct JSProxyData {\n    JSValue target;\n    JSValue handler;\n    uint8_t is_func;\n    uint8_t is_revoked;\n} JSProxyData;\n\ntypedef struct JSArrayBuffer {\n    int byte_length; /* 0 if detached */\n    uint8_t detached;\n    uint8_t shared; /* if shared, the array buffer cannot be detached */\n    uint8_t *data; /* NULL if detached */\n    struct list_head array_list;\n    void *opaque;\n    JSFreeArrayBufferDataFunc *free_func;\n} JSArrayBuffer;\n\ntypedef struct JSTypedArray {\n    struct list_head link; /* link to arraybuffer */\n    JSObject *obj; /* back pointer to the TypedArray/DataView object */\n    JSObject *buffer; /* based array buffer */\n    uint32_t offset; /* offset in the array buffer */\n    uint32_t length; /* length in the array buffer */\n} JSTypedArray;\n\ntypedef struct JSAsyncFunctionState {\n    JSGCObjectHeader header;\n    JSValue this_val; /* 'this' argument */\n    int argc; /* number of function arguments */\n    BOOL throw_flag; /* used to throw an exception in JS_CallInternal() */\n    BOOL is_completed; /* TRUE if the function has returned. The stack\n                          frame is no longer valid */\n    JSValue resolving_funcs[2]; /* only used in JS async functions */\n    JSStackFrame frame;\n} JSAsyncFunctionState;\n\ntypedef enum {\n   /* binary operators */\n   JS_OVOP_ADD,\n   JS_OVOP_SUB,\n   JS_OVOP_MUL,\n   JS_OVOP_DIV,\n   JS_OVOP_MOD,\n   JS_OVOP_POW,\n   JS_OVOP_OR,\n   JS_OVOP_AND,\n   JS_OVOP_XOR,\n   JS_OVOP_SHL,\n   JS_OVOP_SAR,\n   JS_OVOP_SHR,\n   JS_OVOP_EQ,\n   JS_OVOP_LESS,\n\n   JS_OVOP_BINARY_COUNT,\n   /* unary operators */\n   JS_OVOP_POS = JS_OVOP_BINARY_COUNT,\n   JS_OVOP_NEG,\n   JS_OVOP_INC,\n   JS_OVOP_DEC,\n   JS_OVOP_NOT,\n\n   JS_OVOP_COUNT,\n} JSOverloadableOperatorEnum;\n\ntypedef struct {\n    uint32_t operator_index;\n    JSObject *ops[JS_OVOP_BINARY_COUNT]; /* self operators */\n} JSBinaryOperatorDefEntry;\n\ntypedef struct {\n    int count;\n    JSBinaryOperatorDefEntry *tab;\n} JSBinaryOperatorDef;\n\ntypedef struct {\n    uint32_t operator_counter;\n    BOOL is_primitive; /* OperatorSet for a primitive type */\n    /* NULL if no operator is defined */\n    JSObject *self_ops[JS_OVOP_COUNT]; /* self operators */\n    JSBinaryOperatorDef left;\n    JSBinaryOperatorDef right;\n} JSOperatorSetData;\n\ntypedef struct JSReqModuleEntry {\n    JSAtom module_name;\n    JSModuleDef *module; /* used using resolution */\n} JSReqModuleEntry;\n\ntypedef enum JSExportTypeEnum {\n    JS_EXPORT_TYPE_LOCAL,\n    JS_EXPORT_TYPE_INDIRECT,\n} JSExportTypeEnum;\n\ntypedef struct JSExportEntry {\n    union {\n        struct {\n            int var_idx; /* closure variable index */\n            JSVarRef *var_ref; /* if != NULL, reference to the variable */\n        } local; /* for local export */\n        int req_module_idx; /* module for indirect export */\n    } u;\n    JSExportTypeEnum export_type;\n    JSAtom local_name; /* '*' if export ns from. not used for local\n                          export after compilation */\n    JSAtom export_name; /* exported variable name */\n} JSExportEntry;\n\ntypedef struct JSStarExportEntry {\n    int req_module_idx; /* in req_module_entries */\n} JSStarExportEntry;\n\ntypedef struct JSImportEntry {\n    int var_idx; /* closure variable index */\n    JSAtom import_name;\n    int req_module_idx; /* in req_module_entries */\n} JSImportEntry;\n\ntypedef enum {\n    JS_MODULE_STATUS_UNLINKED,\n    JS_MODULE_STATUS_LINKING,\n    JS_MODULE_STATUS_LINKED,\n    JS_MODULE_STATUS_EVALUATING,\n    JS_MODULE_STATUS_EVALUATING_ASYNC,\n    JS_MODULE_STATUS_EVALUATED,\n} JSModuleStatus;\n\nstruct JSModuleDef {\n    JSRefCountHeader header; /* must come first, 32-bit */\n    JSAtom module_name;\n    struct list_head link;\n\n    JSReqModuleEntry *req_module_entries;\n    int req_module_entries_count;\n    int req_module_entries_size;\n\n    JSExportEntry *export_entries;\n    int export_entries_count;\n    int export_entries_size;\n\n    JSStarExportEntry *star_export_entries;\n    int star_export_entries_count;\n    int star_export_entries_size;\n\n    JSImportEntry *import_entries;\n    int import_entries_count;\n    int import_entries_size;\n\n    JSValue module_ns;\n    JSValue func_obj; /* only used for JS modules */\n    JSModuleInitFunc *init_func; /* only used for C modules */\n    BOOL has_tla : 8; /* true if func_obj contains await */\n    BOOL resolved : 8;\n    BOOL func_created : 8;\n    JSModuleStatus status : 8;\n    /* temp use during js_module_link() & js_module_evaluate() */\n    int dfs_index, dfs_ancestor_index;\n    JSModuleDef *stack_prev;\n    /* temp use during js_module_evaluate() */\n    JSModuleDef **async_parent_modules;\n    int async_parent_modules_count;\n    int async_parent_modules_size;\n    int pending_async_dependencies;\n    BOOL async_evaluation;\n    int64_t async_evaluation_timestamp;\n    JSModuleDef *cycle_root;\n    JSValue promise; /* corresponds to spec field: capability */\n    JSValue resolving_funcs[2]; /* corresponds to spec field: capability */\n\n    /* true if evaluation yielded an exception. It is saved in\n       eval_exception */\n    BOOL eval_has_exception : 8;\n    JSValue eval_exception;\n    JSValue meta_obj; /* for import.meta */\n};\n\ntypedef struct JSJobEntry {\n    struct list_head link;\n    JSContext *ctx;\n    JSJobFunc *job_func;\n    int argc;\n    JSValue argv[0];\n} JSJobEntry;\n\ntypedef struct JSProperty {\n    union {\n        JSValue value;      /* JS_PROP_NORMAL */\n        struct {            /* JS_PROP_GETSET */\n            JSObject *getter; /* NULL if undefined */\n            JSObject *setter; /* NULL if undefined */\n        } getset;\n        JSVarRef *var_ref;  /* JS_PROP_VARREF */\n        struct {            /* JS_PROP_AUTOINIT */\n            /* in order to use only 2 pointers, we compress the realm\n               and the init function pointer */\n            uintptr_t realm_and_id; /* realm and init_id (JS_AUTOINIT_ID_x)\n                                       in the 2 low bits */\n            void *opaque;\n        } init;\n    } u;\n} JSProperty;\n\n#define JS_PROP_INITIAL_SIZE 2\n#define JS_PROP_INITIAL_HASH_SIZE 4 /* must be a power of two */\n#define JS_ARRAY_INITIAL_SIZE 2\n\ntypedef struct JSShapeProperty {\n    uint32_t hash_next : 26; /* 0 if last in list */\n    uint32_t flags : 6;   /* JS_PROP_XXX */\n    JSAtom atom; /* JS_ATOM_NULL = free property entry */\n} JSShapeProperty;\n\nstruct JSShape {\n    /* hash table of size hash_mask + 1 before the start of the\n       structure (see prop_hash_end()). */\n    JSGCObjectHeader header;\n    /* true if the shape is inserted in the shape hash table. If not,\n       JSShape.hash is not valid */\n    uint8_t is_hashed;\n    /* If true, the shape may have small array index properties 'n' with 0\n       <= n <= 2^31-1. If false, the shape is guaranteed not to have\n       small array index properties */\n    uint8_t has_small_array_index;\n    uint32_t hash; /* current hash value */\n    uint32_t prop_hash_mask;\n    int prop_size; /* allocated properties */\n    int prop_count; /* include deleted properties */\n    int deleted_prop_count;\n    JSShape *shape_hash_next; /* in JSRuntime.shape_hash[h] list */\n    JSObject *proto;\n    JSShapeProperty prop[0]; /* prop_size elements */\n};\n\nstruct JSObject {\n    union {\n        JSGCObjectHeader header;\n        struct {\n            int __gc_ref_count; /* corresponds to header.ref_count */\n            uint8_t __gc_mark; /* corresponds to header.mark/gc_obj_type */\n\n            uint8_t extensible : 1;\n            uint8_t free_mark : 1; /* only used when freeing objects with cycles */\n            uint8_t is_exotic : 1; /* TRUE if object has exotic property handlers */\n            uint8_t fast_array : 1; /* TRUE if u.array is used for get/put (for JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS and typed arrays) */\n            uint8_t is_constructor : 1; /* TRUE if object is a constructor function */\n            uint8_t is_uncatchable_error : 1; /* if TRUE, error is not catchable */\n            uint8_t tmp_mark : 1; /* used in JS_WriteObjectRec() */\n            uint8_t is_HTMLDDA : 1; /* specific annex B IsHtmlDDA behavior */\n            uint16_t class_id; /* see JS_CLASS_x */\n        };\n    };\n    /* byte offsets: 16/24 */\n    JSShape *shape; /* prototype and property names + flag */\n    JSProperty *prop; /* array of properties */\n    /* byte offsets: 24/40 */\n    struct JSMapRecord *first_weak_ref; /* XXX: use a bit and an external hash table? */\n    /* byte offsets: 28/48 */\n    union {\n        void *opaque;\n        struct JSBoundFunction *bound_function; /* JS_CLASS_BOUND_FUNCTION */\n        struct JSCFunctionDataRecord *c_function_data_record; /* JS_CLASS_C_FUNCTION_DATA */\n        struct JSForInIterator *for_in_iterator; /* JS_CLASS_FOR_IN_ITERATOR */\n        struct JSArrayBuffer *array_buffer; /* JS_CLASS_ARRAY_BUFFER, JS_CLASS_SHARED_ARRAY_BUFFER */\n        struct JSTypedArray *typed_array; /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_DATAVIEW */\n#ifdef CONFIG_BIGNUM\n        struct JSFloatEnv *float_env; /* JS_CLASS_FLOAT_ENV */\n        struct JSOperatorSetData *operator_set; /* JS_CLASS_OPERATOR_SET */\n#endif\n        struct JSMapState *map_state;   /* JS_CLASS_MAP..JS_CLASS_WEAKSET */\n        struct JSMapIteratorData *map_iterator_data; /* JS_CLASS_MAP_ITERATOR, JS_CLASS_SET_ITERATOR */\n        struct JSArrayIteratorData *array_iterator_data; /* JS_CLASS_ARRAY_ITERATOR, JS_CLASS_STRING_ITERATOR */\n        struct JSRegExpStringIteratorData *regexp_string_iterator_data; /* JS_CLASS_REGEXP_STRING_ITERATOR */\n        struct JSGeneratorData *generator_data; /* JS_CLASS_GENERATOR */\n        struct JSProxyData *proxy_data; /* JS_CLASS_PROXY */\n        struct JSPromiseData *promise_data; /* JS_CLASS_PROMISE */\n        struct JSPromiseFunctionData *promise_function_data; /* JS_CLASS_PROMISE_RESOLVE_FUNCTION, JS_CLASS_PROMISE_REJECT_FUNCTION */\n        struct JSAsyncFunctionState *async_function_data; /* JS_CLASS_ASYNC_FUNCTION_RESOLVE, JS_CLASS_ASYNC_FUNCTION_REJECT */\n        struct JSAsyncFromSyncIteratorData *async_from_sync_iterator_data; /* JS_CLASS_ASYNC_FROM_SYNC_ITERATOR */\n        struct JSAsyncGeneratorData *async_generator_data; /* JS_CLASS_ASYNC_GENERATOR */\n        struct { /* JS_CLASS_BYTECODE_FUNCTION: 12/24 bytes */\n            /* also used by JS_CLASS_GENERATOR_FUNCTION, JS_CLASS_ASYNC_FUNCTION and JS_CLASS_ASYNC_GENERATOR_FUNCTION */\n            struct JSFunctionBytecode *function_bytecode;\n            JSVarRef **var_refs;\n            JSObject *home_object; /* for 'super' access */\n        } func;\n        struct { /* JS_CLASS_C_FUNCTION: 12/20 bytes */\n            JSContext *realm;\n            JSCFunctionType c_function;\n            uint8_t length;\n            uint8_t cproto;\n            int16_t magic;\n        } cfunc;\n        /* array part for fast arrays and typed arrays */\n        struct { /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS, JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */\n            union {\n                uint32_t size;          /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS */\n                struct JSTypedArray *typed_array; /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */\n            } u1;\n            union {\n                JSValue *values;        /* JS_CLASS_ARRAY, JS_CLASS_ARGUMENTS */\n                void *ptr;              /* JS_CLASS_UINT8C_ARRAY..JS_CLASS_FLOAT64_ARRAY */\n                int8_t *int8_ptr;       /* JS_CLASS_INT8_ARRAY */\n                uint8_t *uint8_ptr;     /* JS_CLASS_UINT8_ARRAY, JS_CLASS_UINT8C_ARRAY */\n                int16_t *int16_ptr;     /* JS_CLASS_INT16_ARRAY */\n                uint16_t *uint16_ptr;   /* JS_CLASS_UINT16_ARRAY */\n                int32_t *int32_ptr;     /* JS_CLASS_INT32_ARRAY */\n                uint32_t *uint32_ptr;   /* JS_CLASS_UINT32_ARRAY */\n                int64_t *int64_ptr;     /* JS_CLASS_INT64_ARRAY */\n                uint64_t *uint64_ptr;   /* JS_CLASS_UINT64_ARRAY */\n                float *float_ptr;       /* JS_CLASS_FLOAT32_ARRAY */\n                double *double_ptr;     /* JS_CLASS_FLOAT64_ARRAY */\n            } u;\n            uint32_t count; /* <= 2^31-1. 0 for a detached typed array */\n        } array;    /* 12/20 bytes */\n        JSRegExp regexp;    /* JS_CLASS_REGEXP: 8/16 bytes */\n        JSValue object_data;    /* for JS_SetObjectData(): 8/16/16 bytes */\n    } u;\n    /* byte sizes: 40/48/72 */\n};\n\nenum {\n    __JS_ATOM_NULL = JS_ATOM_NULL,\n#define DEF(name, str) JS_ATOM_ ## name,\n#include \"quickjs-atom.h\"\n#undef DEF\n    JS_ATOM_END,\n};\n#define JS_ATOM_LAST_KEYWORD JS_ATOM_super\n#define JS_ATOM_LAST_STRICT_KEYWORD JS_ATOM_yield\n\nstatic const char js_atom_init[] =\n#define DEF(name, str) str \"\\0\"\n#include \"quickjs-atom.h\"\n#undef DEF\n;\n\ntypedef enum OPCodeFormat {\n#define FMT(f) OP_FMT_ ## f,\n#define DEF(id, size, n_pop, n_push, f)\n#include \"quickjs-opcode.h\"\n#undef DEF\n#undef FMT\n} OPCodeFormat;\n\nenum OPCodeEnum {\n#define FMT(f)\n#define DEF(id, size, n_pop, n_push, f) OP_ ## id,\n#define def(id, size, n_pop, n_push, f)\n#include \"quickjs-opcode.h\"\n#undef def\n#undef DEF\n#undef FMT\n    OP_COUNT, /* excluding temporary opcodes */\n    /* temporary opcodes : overlap with the short opcodes */\n    OP_TEMP_START = OP_nop + 1,\n    OP___dummy = OP_TEMP_START - 1,\n#define FMT(f)\n#define DEF(id, size, n_pop, n_push, f)\n#define def(id, size, n_pop, n_push, f) OP_ ## id,\n#include \"quickjs-opcode.h\"\n#undef def\n#undef DEF\n#undef FMT\n    OP_TEMP_END,\n};\n\nstatic int JS_InitAtoms(JSRuntime *rt);\nstatic JSAtom __JS_NewAtomInit(JSRuntime *rt, const char *str, int len,\n                               int atom_type);\nstatic void JS_FreeAtomStruct(JSRuntime *rt, JSAtomStruct *p);\nstatic void free_function_bytecode(JSRuntime *rt, JSFunctionBytecode *b);\nstatic JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,\n                                  JSValueConst this_obj,\n                                  int argc, JSValueConst *argv, int flags);\nstatic JSValue js_call_bound_function(JSContext *ctx, JSValueConst func_obj,\n                                      JSValueConst this_obj,\n                                      int argc, JSValueConst *argv, int flags);\nstatic JSValue JS_CallInternal(JSContext *ctx, JSValueConst func_obj,\n                               JSValueConst this_obj, JSValueConst new_target,\n                               int argc, JSValue *argv, int flags);\nstatic JSValue JS_CallConstructorInternal(JSContext *ctx,\n                                          JSValueConst func_obj,\n                                          JSValueConst new_target,\n                                          int argc, JSValue *argv, int flags);\nstatic JSValue JS_CallFree(JSContext *ctx, JSValue func_obj, JSValueConst this_obj,\n                           int argc, JSValueConst *argv);\nstatic JSValue JS_InvokeFree(JSContext *ctx, JSValue this_val, JSAtom atom,\n                             int argc, JSValueConst *argv);\nstatic __exception int JS_ToArrayLengthFree(JSContext *ctx, uint32_t *plen,\n                                            JSValue val, BOOL is_array_ctor);\nstatic JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,\n                             JSValueConst val, int flags, int scope_idx);\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);\nstatic __maybe_unused void JS_DumpAtoms(JSRuntime *rt);\nstatic __maybe_unused void JS_DumpString(JSRuntime *rt, const JSString *p);\nstatic __maybe_unused void JS_DumpObjectHeader(JSRuntime *rt);\nstatic __maybe_unused void JS_DumpObject(JSRuntime *rt, JSObject *p);\nstatic __maybe_unused void JS_DumpGCObject(JSRuntime *rt, JSGCObjectHeader *p);\nstatic __maybe_unused void JS_DumpValueShort(JSRuntime *rt, JSValueConst val);\nstatic __maybe_unused void JS_DumpValue(JSContext *ctx, JSValueConst val);\nstatic __maybe_unused void JS_PrintValue(JSContext *ctx,\n                                                  const char *str,\n                                                  JSValueConst val);\nstatic __maybe_unused void JS_DumpShapes(JSRuntime *rt);\nstatic JSValue js_function_apply(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv, int magic);\nstatic void js_array_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_array_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);\nstatic void js_object_data_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_object_data_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);\nstatic void js_c_function_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_c_function_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);\nstatic void js_bytecode_function_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_bytecode_function_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_bound_function_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_bound_function_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_for_in_iterator_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_for_in_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_regexp_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_array_buffer_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_typed_array_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_typed_array_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_proxy_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_proxy_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_map_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_map_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_map_iterator_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_map_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_array_iterator_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_array_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_regexp_string_iterator_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_regexp_string_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_generator_finalizer(JSRuntime *rt, JSValue obj);\nstatic void js_generator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_promise_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_promise_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\nstatic void js_promise_resolve_function_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_promise_resolve_function_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func);\n#ifdef CONFIG_BIGNUM\nstatic void js_operator_set_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_operator_set_mark(JSRuntime *rt, JSValueConst val,\n                                 JS_MarkFunc *mark_func);\n#endif\n\n#define HINT_STRING  0\n#define HINT_NUMBER  1\n#define HINT_NONE    2\n#define HINT_FORCE_ORDINARY (1 << 4) // don't try Symbol.toPrimitive\nstatic JSValue JS_ToPrimitiveFree(JSContext *ctx, JSValue val, int hint);\nstatic JSValue JS_ToStringFree(JSContext *ctx, JSValue val);\nstatic int JS_ToBoolFree(JSContext *ctx, JSValue val);\nstatic int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val);\nstatic int JS_ToFloat64Free(JSContext *ctx, double *pres, JSValue val);\nstatic int JS_ToUint8ClampFree(JSContext *ctx, int32_t *pres, JSValue val);\nstatic JSValue js_compile_regexp(JSContext *ctx, JSValueConst pattern,\n                                 JSValueConst flags);\nstatic JSValue js_regexp_constructor_internal(JSContext *ctx, JSValueConst ctor,\n                                              JSValue pattern, JSValue bc);\nstatic void gc_decref(JSRuntime *rt);\nstatic int JS_NewClass1(JSRuntime *rt, JSClassID class_id,\n                        const JSClassDef *class_def, JSAtom name);\n\ntypedef enum JSStrictEqModeEnum {\n    JS_EQ_STRICT,\n    JS_EQ_SAME_VALUE,\n    JS_EQ_SAME_VALUE_ZERO,\n} JSStrictEqModeEnum;\n\nstatic BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,\n                          JSStrictEqModeEnum eq_mode);\nstatic BOOL js_strict_eq(JSContext *ctx, JSValueConst op1, JSValueConst op2);\nstatic BOOL js_same_value(JSContext *ctx, JSValueConst op1, JSValueConst op2);\nstatic BOOL js_same_value_zero(JSContext *ctx, JSValueConst op1, JSValueConst op2);\nstatic JSValue JS_ToObject(JSContext *ctx, JSValueConst val);\nstatic JSValue JS_ToObjectFree(JSContext *ctx, JSValue val);\nstatic JSProperty *add_property(JSContext *ctx,\n                                JSObject *p, JSAtom prop, int prop_flags);\nstatic JSValue JS_NewBigInt(JSContext *ctx);\nstatic inline bf_t *JS_GetBigInt(JSValueConst val)\n{\n    JSBigFloat *p = JS_VALUE_GET_PTR(val);\n    return &p->num;\n}\nstatic JSValue JS_CompactBigInt1(JSContext *ctx, JSValue val,\n                                 BOOL convert_to_safe_integer);\nstatic JSValue JS_CompactBigInt(JSContext *ctx, JSValue val);\nstatic int JS_ToBigInt64Free(JSContext *ctx, int64_t *pres, JSValue val);\nstatic bf_t *JS_ToBigInt(JSContext *ctx, bf_t *buf, JSValueConst val);\nstatic void JS_FreeBigInt(JSContext *ctx, bf_t *a, bf_t *buf);\n#ifdef CONFIG_BIGNUM\nstatic void js_float_env_finalizer(JSRuntime *rt, JSValue val);\nstatic JSValue JS_NewBigFloat(JSContext *ctx);\nstatic inline bf_t *JS_GetBigFloat(JSValueConst val)\n{\n    JSBigFloat *p = JS_VALUE_GET_PTR(val);\n    return &p->num;\n}\nstatic JSValue JS_NewBigDecimal(JSContext *ctx);\nstatic inline bfdec_t *JS_GetBigDecimal(JSValueConst val)\n{\n    JSBigDecimal *p = JS_VALUE_GET_PTR(val);\n    return &p->num;\n}\nstatic bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val);\nstatic JSValue JS_ToBigDecimalFree(JSContext *ctx, JSValue val,\n                                   BOOL allow_null_or_undefined);\nstatic bfdec_t *JS_ToBigDecimal(JSContext *ctx, JSValueConst val);\n#endif\nJSValue JS_ThrowOutOfMemory(JSContext *ctx);\nstatic JSValue JS_ThrowTypeErrorRevokedProxy(JSContext *ctx);\nstatic JSValue js_proxy_getPrototypeOf(JSContext *ctx, JSValueConst obj);\nstatic int js_proxy_setPrototypeOf(JSContext *ctx, JSValueConst obj,\n                                   JSValueConst proto_val, BOOL throw_flag);\n\nstatic int js_resolve_proxy(JSContext *ctx, JSValueConst *pval, int throw_exception);\nstatic int js_proxy_isExtensible(JSContext *ctx, JSValueConst obj);\nstatic int js_proxy_preventExtensions(JSContext *ctx, JSValueConst obj);\nstatic int JS_CreateProperty(JSContext *ctx, JSObject *p,\n                             JSAtom prop, JSValueConst val,\n                             JSValueConst getter, JSValueConst setter,\n                             int flags);\nstatic int js_string_memcmp(const JSString *p1, const JSString *p2, int len);\nstatic void reset_weak_ref(JSRuntime *rt, JSObject *p);\nstatic JSValue js_array_buffer_constructor3(JSContext *ctx,\n                                            JSValueConst new_target,\n                                            uint64_t len, JSClassID class_id,\n                                            uint8_t *buf,\n                                            JSFreeArrayBufferDataFunc *free_func,\n                                            void *opaque, BOOL alloc_flag);\nstatic JSArrayBuffer *js_get_array_buffer(JSContext *ctx, JSValueConst obj);\nstatic JSValue js_typed_array_constructor(JSContext *ctx,\n                                          JSValueConst this_val,\n                                          int argc, JSValueConst *argv,\n                                          int classid);\nstatic JSValue js_typed_array_constructor_ta(JSContext *ctx,\n                                             JSValueConst new_target,\n                                             JSValueConst src_obj,\n                                             int classid);\nstatic BOOL typed_array_is_detached(JSContext *ctx, JSObject *p);\nstatic uint32_t typed_array_get_length(JSContext *ctx, JSObject *p);\nstatic JSValue JS_ThrowTypeErrorDetachedArrayBuffer(JSContext *ctx);\nstatic JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf, int var_idx,\n                             BOOL is_arg);\nstatic void __async_func_free(JSRuntime *rt, JSAsyncFunctionState *s);\nstatic void async_func_free(JSRuntime *rt, JSAsyncFunctionState *s);\nstatic JSValue js_generator_function_call(JSContext *ctx, JSValueConst func_obj,\n                                          JSValueConst this_obj,\n                                          int argc, JSValueConst *argv,\n                                          int flags);\nstatic void js_async_function_resolve_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_async_function_resolve_mark(JSRuntime *rt, JSValueConst val,\n                                           JS_MarkFunc *mark_func);\nstatic JSValue JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,\n                               const char *input, size_t input_len,\n                               const char *filename, int flags, int scope_idx);\nstatic void js_free_module_def(JSContext *ctx, JSModuleDef *m);\nstatic void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,\n                               JS_MarkFunc *mark_func);\nstatic JSValue js_import_meta(JSContext *ctx);\nstatic JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);\nstatic void free_var_ref(JSRuntime *rt, JSVarRef *var_ref);\nstatic JSValue js_new_promise_capability(JSContext *ctx,\n                                         JSValue *resolving_funcs,\n                                         JSValueConst ctor);\nstatic __exception int perform_promise_then(JSContext *ctx,\n                                            JSValueConst promise,\n                                            JSValueConst *resolve_reject,\n                                            JSValueConst *cap_resolving_funcs);\nstatic JSValue js_promise_resolve(JSContext *ctx, JSValueConst this_val,\n                                  int argc, JSValueConst *argv, int magic);\nstatic JSValue js_promise_then(JSContext *ctx, JSValueConst this_val,\n                               int argc, JSValueConst *argv);\nstatic int js_string_compare(JSContext *ctx,\n                             const JSString *p1, const JSString *p2);\nstatic JSValue JS_ToNumber(JSContext *ctx, JSValueConst val);\nstatic int JS_SetPropertyValue(JSContext *ctx, JSValueConst this_obj,\n                               JSValue prop, JSValue val, int flags);\nstatic int JS_NumberIsInteger(JSContext *ctx, JSValueConst val);\nstatic BOOL JS_NumberIsNegativeOrMinusZero(JSContext *ctx, JSValueConst val);\nstatic JSValue JS_ToNumberFree(JSContext *ctx, JSValue val);\nstatic int JS_GetOwnPropertyInternal(JSContext *ctx, JSPropertyDescriptor *desc,\n                                     JSObject *p, JSAtom prop);\nstatic void js_free_desc(JSContext *ctx, JSPropertyDescriptor *desc);\nstatic void JS_AddIntrinsicBasicObjects(JSContext *ctx);\nstatic void js_free_shape(JSRuntime *rt, JSShape *sh);\nstatic void js_free_shape_null(JSRuntime *rt, JSShape *sh);\nstatic int js_shape_prepare_update(JSContext *ctx, JSObject *p,\n                                   JSShapeProperty **pprs);\nstatic int init_shape_hash(JSRuntime *rt);\nstatic __exception int js_get_length32(JSContext *ctx, uint32_t *pres,\n                                       JSValueConst obj);\nstatic __exception int js_get_length64(JSContext *ctx, int64_t *pres,\n                                       JSValueConst obj);\nstatic void free_arg_list(JSContext *ctx, JSValue *tab, uint32_t len);\nstatic JSValue *build_arg_list(JSContext *ctx, uint32_t *plen,\n                               JSValueConst array_arg);\nstatic BOOL js_get_fast_array(JSContext *ctx, JSValueConst obj,\n                              JSValue **arrpp, uint32_t *countp);\nstatic JSValue JS_CreateAsyncFromSyncIterator(JSContext *ctx,\n                                              JSValueConst sync_iter);\nstatic void js_c_function_data_finalizer(JSRuntime *rt, JSValue val);\nstatic void js_c_function_data_mark(JSRuntime *rt, JSValueConst val,\n                                    JS_MarkFunc *mark_func);\nstatic JSValue js_c_function_data_call(JSContext *ctx, JSValueConst func_obj,\n                                       JSValueConst this_val,\n                                       int argc, JSValueConst *argv, int flags);\nstatic JSAtom js_symbol_to_atom(JSContext *ctx, JSValue val);\nstatic void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,\n                          JSGCObjectTypeEnum type);\nstatic void remove_gc_object(JSGCObjectHeader *h);\nstatic JSValue js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque);\nstatic JSValue js_module_ns_autoinit(JSContext *ctx, JSObject *p, JSAtom atom,\n                                 void *opaque);\nstatic JSValue JS_InstantiateFunctionListItem2(JSContext *ctx, JSObject *p,\n                                               JSAtom atom, void *opaque);\nstatic JSValue js_object_groupBy(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv, int is_map);\n\nstatic const JSClassExoticMethods js_arguments_exotic_methods;\nstatic const JSClassExoticMethods js_string_exotic_methods;\nstatic const JSClassExoticMethods js_proxy_exotic_methods;\nstatic const JSClassExoticMethods js_module_ns_exotic_methods;\nstatic JSClassID js_class_id_alloc = JS_CLASS_INIT_COUNT;\n\nstatic void js_trigger_gc(JSRuntime *rt, size_t size)\n{\n    BOOL force_gc;\n#ifdef FORCE_GC_AT_MALLOC\n    force_gc = TRUE;\n#else\n    force_gc = ((rt->malloc_state.malloc_size + size) >\n                rt->malloc_gc_threshold);\n#endif\n    if (force_gc) {\n#ifdef DUMP_GC\n        printf(\"GC: size=%\" PRIu64 \"\\n\",\n               (uint64_t)rt->malloc_state.malloc_size);\n#endif\n        JS_RunGC(rt);\n        rt->malloc_gc_threshold = rt->malloc_state.malloc_size +\n            (rt->malloc_state.malloc_size >> 1);\n    }\n}\n\nstatic size_t js_malloc_usable_size_unknown(const void *ptr)\n{\n    return 0;\n}\n\nvoid *js_malloc_rt(JSRuntime *rt, size_t size)\n{\n    return rt->mf.js_malloc(&rt->malloc_state, size);\n}\n\nvoid js_free_rt(JSRuntime *rt, void *ptr)\n{\n    rt->mf.js_free(&rt->malloc_state, ptr);\n}\n\nvoid *js_realloc_rt(JSRuntime *rt, void *ptr, size_t size)\n{\n    return rt->mf.js_realloc(&rt->malloc_state, ptr, size);\n}\n\nsize_t js_malloc_usable_size_rt(JSRuntime *rt, const void *ptr)\n{\n    return rt->mf.js_malloc_usable_size(ptr);\n}\n\nvoid *js_mallocz_rt(JSRuntime *rt, size_t size)\n{\n    void *ptr;\n    ptr = js_malloc_rt(rt, size);\n    if (!ptr)\n        return NULL;\n    return memset(ptr, 0, size);\n}\n\n/* called by libbf */\nstatic void *js_bf_realloc(void *opaque, void *ptr, size_t size)\n{\n    JSRuntime *rt = opaque;\n    return js_realloc_rt(rt, ptr, size);\n}\n\n/* Throw out of memory in case of error */\nvoid *js_malloc(JSContext *ctx, size_t size)\n{\n    void *ptr;\n    ptr = js_malloc_rt(ctx->rt, size);\n    if (unlikely(!ptr)) {\n        JS_ThrowOutOfMemory(ctx);\n        return NULL;\n    }\n    return ptr;\n}\n\n/* Throw out of memory in case of error */\nvoid *js_mallocz(JSContext *ctx, size_t size)\n{\n    void *ptr;\n    ptr = js_mallocz_rt(ctx->rt, size);\n    if (unlikely(!ptr)) {\n        JS_ThrowOutOfMemory(ctx);\n        return NULL;\n    }\n    return ptr;\n}\n\nvoid js_free(JSContext *ctx, void *ptr)\n{\n    js_free_rt(ctx->rt, ptr);\n}\n\n/* Throw out of memory in case of error */\nvoid *js_realloc(JSContext *ctx, void *ptr, size_t size)\n{\n    void *ret;\n    ret = js_realloc_rt(ctx->rt, ptr, size);\n    if (unlikely(!ret && size != 0)) {\n        JS_ThrowOutOfMemory(ctx);\n        return NULL;\n    }\n    return ret;\n}\n\n/* store extra allocated size in *pslack if successful */\nvoid *js_realloc2(JSContext *ctx, void *ptr, size_t size, size_t *pslack)\n{\n    void *ret;\n    ret = js_realloc_rt(ctx->rt, ptr, size);\n    if (unlikely(!ret && size != 0)) {\n        JS_ThrowOutOfMemory(ctx);\n        return NULL;\n    }\n    if (pslack) {\n        size_t new_size = js_malloc_usable_size_rt(ctx->rt, ret);\n        *pslack = (new_size > size) ? new_size - size : 0;\n    }\n    return ret;\n}\n\nsize_t js_malloc_usable_size(JSContext *ctx, const void *ptr)\n{\n    return js_malloc_usable_size_rt(ctx->rt, ptr);\n}\n\n/* Throw out of memory exception in case of error */\nchar *js_strndup(JSContext *ctx, const char *s, size_t n)\n{\n    char *ptr;\n    ptr = js_malloc(ctx, n + 1);\n    if (ptr) {\n        memcpy(ptr, s, n);\n        ptr[n] = '\\0';\n    }\n    return ptr;\n}\n\nchar *js_strdup(JSContext *ctx, const char *str)\n{\n    return js_strndup(ctx, str, strlen(str));\n}\n\nstatic no_inline int js_realloc_array(JSContext *ctx, void **parray,\n                                      int elem_size, int *psize, int req_size)\n{\n    int new_size;\n    size_t slack;\n    void *new_array;\n    /* XXX: potential arithmetic overflow */\n    new_size = max_int(req_size, *psize * 3 / 2);\n    new_array = js_realloc2(ctx, *parray, new_size * elem_size, &slack);\n    if (!new_array)\n        return -1;\n    new_size += slack / elem_size;\n    *psize = new_size;\n    *parray = new_array;\n    return 0;\n}\n\n/* resize the array and update its size if req_size > *psize */\nstatic inline int js_resize_array(JSContext *ctx, void **parray, int elem_size,\n                                  int *psize, int req_size)\n{\n    if (unlikely(req_size > *psize))\n        return js_realloc_array(ctx, parray, elem_size, psize, req_size);\n    else\n        return 0;\n}\n\nstatic inline void js_dbuf_init(JSContext *ctx, DynBuf *s)\n{\n    dbuf_init2(s, ctx->rt, (DynBufReallocFunc *)js_realloc_rt);\n}\n\nstatic inline int is_digit(int c) {\n    return c >= '0' && c <= '9';\n}\n\nstatic inline int string_get(const JSString *p, int idx) {\n    return p->is_wide_char ? p->u.str16[idx] : p->u.str8[idx];\n}\n\ntypedef struct JSClassShortDef {\n    JSAtom class_name;\n    JSClassFinalizer *finalizer;\n    JSClassGCMark *gc_mark;\n} JSClassShortDef;\n\nstatic JSClassShortDef const js_std_class_def[] = {\n    { JS_ATOM_Object, NULL, NULL },                             /* JS_CLASS_OBJECT */\n    { JS_ATOM_Array, js_array_finalizer, js_array_mark },       /* JS_CLASS_ARRAY */\n    { JS_ATOM_Error, NULL, NULL }, /* JS_CLASS_ERROR */\n    { JS_ATOM_Number, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_NUMBER */\n    { JS_ATOM_String, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_STRING */\n    { JS_ATOM_Boolean, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_BOOLEAN */\n    { JS_ATOM_Symbol, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_SYMBOL */\n    { JS_ATOM_Arguments, js_array_finalizer, js_array_mark },   /* JS_CLASS_ARGUMENTS */\n    { JS_ATOM_Arguments, NULL, NULL },                          /* JS_CLASS_MAPPED_ARGUMENTS */\n    { JS_ATOM_Date, js_object_data_finalizer, js_object_data_mark }, /* JS_CLASS_DATE */\n    { JS_ATOM_Object, NULL, NULL },                             /* JS_CLASS_MODULE_NS */\n    { JS_ATOM_Function, js_c_function_finalizer, js_c_function_mark }, /* JS_CLASS_C_FUNCTION */\n    { JS_ATOM_Function, js_bytecode_function_finalizer, js_bytecode_function_mark }, /* JS_CLASS_BYTECODE_FUNCTION */\n    { JS_ATOM_Function, js_bound_function_finalizer, js_bound_function_mark }, /* JS_CLASS_BOUND_FUNCTION */\n    { JS_ATOM_Function, js_c_function_data_finalizer, js_c_function_data_mark }, /* JS_CLASS_C_FUNCTION_DATA */\n    { JS_ATOM_GeneratorFunction, js_bytecode_function_finalizer, js_bytecode_function_mark },  /* JS_CLASS_GENERATOR_FUNCTION */\n    { JS_ATOM_ForInIterator, js_for_in_iterator_finalizer, js_for_in_iterator_mark },      /* JS_CLASS_FOR_IN_ITERATOR */\n    { JS_ATOM_RegExp, js_regexp_finalizer, NULL },                              /* JS_CLASS_REGEXP */\n    { JS_ATOM_ArrayBuffer, js_array_buffer_finalizer, NULL },                   /* JS_CLASS_ARRAY_BUFFER */\n    { JS_ATOM_SharedArrayBuffer, js_array_buffer_finalizer, NULL },             /* JS_CLASS_SHARED_ARRAY_BUFFER */\n    { JS_ATOM_Uint8ClampedArray, js_typed_array_finalizer, js_typed_array_mark }, /* JS_CLASS_UINT8C_ARRAY */\n    { JS_ATOM_Int8Array, js_typed_array_finalizer, js_typed_array_mark },       /* JS_CLASS_INT8_ARRAY */\n    { JS_ATOM_Uint8Array, js_typed_array_finalizer, js_typed_array_mark },      /* JS_CLASS_UINT8_ARRAY */\n    { JS_ATOM_Int16Array, js_typed_array_finalizer, js_typed_array_mark },      /* JS_CLASS_INT16_ARRAY */\n    { JS_ATOM_Uint16Array, js_typed_array_finalizer, js_typed_array_mark },     /* JS_CLASS_UINT16_ARRAY */\n    { JS_ATOM_Int32Array, js_typed_array_finalizer, js_typed_array_mark },      /* JS_CLASS_INT32_ARRAY */\n    { JS_ATOM_Uint32Array, js_typed_array_finalizer, js_typed_array_mark },     /* JS_CLASS_UINT32_ARRAY */\n    { JS_ATOM_BigInt64Array, js_typed_array_finalizer, js_typed_array_mark },   /* JS_CLASS_BIG_INT64_ARRAY */\n    { JS_ATOM_BigUint64Array, js_typed_array_finalizer, js_typed_array_mark },  /* JS_CLASS_BIG_UINT64_ARRAY */\n    { JS_ATOM_Float32Array, js_typed_array_finalizer, js_typed_array_mark },    /* JS_CLASS_FLOAT32_ARRAY */\n    { JS_ATOM_Float64Array, js_typed_array_finalizer, js_typed_array_mark },    /* JS_CLASS_FLOAT64_ARRAY */\n    { JS_ATOM_DataView, js_typed_array_finalizer, js_typed_array_mark },        /* JS_CLASS_DATAVIEW */\n    { JS_ATOM_BigInt, js_object_data_finalizer, js_object_data_mark },      /* JS_CLASS_BIG_INT */\n#ifdef CONFIG_BIGNUM\n    { JS_ATOM_BigFloat, js_object_data_finalizer, js_object_data_mark },    /* JS_CLASS_BIG_FLOAT */\n    { JS_ATOM_BigFloatEnv, js_float_env_finalizer, NULL },      /* JS_CLASS_FLOAT_ENV */\n    { JS_ATOM_BigDecimal, js_object_data_finalizer, js_object_data_mark },    /* JS_CLASS_BIG_DECIMAL */\n    { JS_ATOM_OperatorSet, js_operator_set_finalizer, js_operator_set_mark },    /* JS_CLASS_OPERATOR_SET */\n#endif\n    { JS_ATOM_Map, js_map_finalizer, js_map_mark },             /* JS_CLASS_MAP */\n    { JS_ATOM_Set, js_map_finalizer, js_map_mark },             /* JS_CLASS_SET */\n    { JS_ATOM_WeakMap, js_map_finalizer, js_map_mark },         /* JS_CLASS_WEAKMAP */\n    { JS_ATOM_WeakSet, js_map_finalizer, js_map_mark },         /* JS_CLASS_WEAKSET */\n    { JS_ATOM_Map_Iterator, js_map_iterator_finalizer, js_map_iterator_mark }, /* JS_CLASS_MAP_ITERATOR */\n    { JS_ATOM_Set_Iterator, js_map_iterator_finalizer, js_map_iterator_mark }, /* JS_CLASS_SET_ITERATOR */\n    { JS_ATOM_Array_Iterator, js_array_iterator_finalizer, js_array_iterator_mark }, /* JS_CLASS_ARRAY_ITERATOR */\n    { JS_ATOM_String_Iterator, js_array_iterator_finalizer, js_array_iterator_mark }, /* JS_CLASS_STRING_ITERATOR */\n    { JS_ATOM_RegExp_String_Iterator, js_regexp_string_iterator_finalizer, js_regexp_string_iterator_mark }, /* JS_CLASS_REGEXP_STRING_ITERATOR */\n    { JS_ATOM_Generator, js_generator_finalizer, js_generator_mark }, /* JS_CLASS_GENERATOR */\n};\n\nstatic int init_class_range(JSRuntime *rt, JSClassShortDef const *tab,\n                            int start, int count)\n{\n    JSClassDef cm_s, *cm = &cm_s;\n    int i, class_id;\n\n    for(i = 0; i < count; i++) {\n        class_id = i + start;\n        memset(cm, 0, sizeof(*cm));\n        cm->finalizer = tab[i].finalizer;\n        cm->gc_mark = tab[i].gc_mark;\n        if (JS_NewClass1(rt, class_id, cm, tab[i].class_name) < 0)\n            return -1;\n    }\n    return 0;\n}\n\nstatic JSValue JS_ThrowUnsupportedOperation(JSContext *ctx)\n{\n    return JS_ThrowTypeError(ctx, \"unsupported operation\");\n}\n\nstatic JSValue invalid_to_string(JSContext *ctx, JSValueConst val)\n{\n    return JS_ThrowUnsupportedOperation(ctx);\n}\n\nstatic JSValue invalid_from_string(JSContext *ctx, const char *buf,\n                                   int radix, int flags, slimb_t *pexponent)\n{\n    return JS_NAN;\n}\n\nstatic int invalid_unary_arith(JSContext *ctx,\n                               JSValue *pres, OPCodeEnum op, JSValue op1)\n{\n    JS_FreeValue(ctx, op1);\n    JS_ThrowUnsupportedOperation(ctx);\n    return -1;\n}\n\nstatic int invalid_binary_arith(JSContext *ctx, OPCodeEnum op,\n                                JSValue *pres, JSValue op1, JSValue op2)\n{\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    JS_ThrowUnsupportedOperation(ctx);\n    return -1;\n}\n\nstatic JSValue invalid_mul_pow10_to_float64(JSContext *ctx, const bf_t *a,\n                                            int64_t exponent)\n{\n    return JS_ThrowUnsupportedOperation(ctx);\n}\n\nstatic int invalid_mul_pow10(JSContext *ctx, JSValue *sp)\n{\n    JS_ThrowUnsupportedOperation(ctx);\n    return -1;\n}\n\nstatic void set_dummy_numeric_ops(JSNumericOperations *ops)\n{\n    ops->to_string = invalid_to_string;\n    ops->from_string = invalid_from_string;\n    ops->unary_arith = invalid_unary_arith;\n    ops->binary_arith = invalid_binary_arith;\n    ops->mul_pow10_to_float64 = invalid_mul_pow10_to_float64;\n    ops->mul_pow10 = invalid_mul_pow10;\n}\n\n#if !defined(CONFIG_STACK_CHECK)\n/* no stack limitation */\nstatic inline uintptr_t js_get_stack_pointer(void)\n{\n    return 0;\n}\n\nstatic inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)\n{\n    return FALSE;\n}\n#else\n/* Note: OS and CPU dependent */\nstatic inline uintptr_t js_get_stack_pointer(void)\n{\n    return (uintptr_t)__builtin_frame_address(0);\n}\n\nstatic inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)\n{\n    uintptr_t sp;\n    sp = js_get_stack_pointer() - alloca_size;\n    return unlikely(sp < rt->stack_limit);\n}\n#endif\n\nJSRuntime *JS_NewRuntime2(const JSMallocFunctions *mf, void *opaque)\n{\n    JSRuntime *rt;\n    JSMallocState ms;\n\n    memset(&ms, 0, sizeof(ms));\n    ms.opaque = opaque;\n    ms.malloc_limit = -1;\n\n    rt = mf->js_malloc(&ms, sizeof(JSRuntime));\n    if (!rt)\n        return NULL;\n    memset(rt, 0, sizeof(*rt));\n    rt->mf = *mf;\n    if (!rt->mf.js_malloc_usable_size) {\n        /* use dummy function if none provided */\n        rt->mf.js_malloc_usable_size = js_malloc_usable_size_unknown;\n    }\n    rt->malloc_state = ms;\n    rt->malloc_gc_threshold = 256 * 1024;\n\n    bf_context_init(&rt->bf_ctx, js_bf_realloc, rt);\n    set_dummy_numeric_ops(&rt->bigint_ops);\n#ifdef CONFIG_BIGNUM\n    set_dummy_numeric_ops(&rt->bigfloat_ops);\n    set_dummy_numeric_ops(&rt->bigdecimal_ops);\n#endif\n\n    init_list_head(&rt->context_list);\n    init_list_head(&rt->gc_obj_list);\n    init_list_head(&rt->gc_zero_ref_count_list);\n    rt->gc_phase = JS_GC_PHASE_NONE;\n\n#ifdef DUMP_LEAKS\n    init_list_head(&rt->string_list);\n#endif\n    init_list_head(&rt->job_list);\n\n    if (JS_InitAtoms(rt))\n        goto fail;\n\n    /* create the object, array and function classes */\n    if (init_class_range(rt, js_std_class_def, JS_CLASS_OBJECT,\n                         countof(js_std_class_def)) < 0)\n        goto fail;\n    rt->class_array[JS_CLASS_ARGUMENTS].exotic = &js_arguments_exotic_methods;\n    rt->class_array[JS_CLASS_STRING].exotic = &js_string_exotic_methods;\n    rt->class_array[JS_CLASS_MODULE_NS].exotic = &js_module_ns_exotic_methods;\n\n    rt->class_array[JS_CLASS_C_FUNCTION].call = js_call_c_function;\n    rt->class_array[JS_CLASS_C_FUNCTION_DATA].call = js_c_function_data_call;\n    rt->class_array[JS_CLASS_BOUND_FUNCTION].call = js_call_bound_function;\n    rt->class_array[JS_CLASS_GENERATOR_FUNCTION].call = js_generator_function_call;\n    if (init_shape_hash(rt))\n        goto fail;\n\n    rt->stack_size = JS_DEFAULT_STACK_SIZE;\n    JS_UpdateStackTop(rt);\n\n    rt->current_exception = JS_UNINITIALIZED;\n\n    return rt;\n fail:\n    JS_FreeRuntime(rt);\n    return NULL;\n}\n\nvoid *JS_GetRuntimeOpaque(JSRuntime *rt)\n{\n    return rt->user_opaque;\n}\n\nvoid JS_SetRuntimeOpaque(JSRuntime *rt, void *opaque)\n{\n    rt->user_opaque = opaque;\n}\n\n/* default memory allocation functions with memory limitation */\nstatic size_t js_def_malloc_usable_size(const void *ptr)\n{\n#if defined(__APPLE__)\n    return malloc_size(ptr);\n#elif defined(_WIN32)\n    return _msize((void *)ptr);\n#elif defined(EMSCRIPTEN)\n    return 0;\n#elif defined(__linux__) || defined(__GLIBC__)\n    return malloc_usable_size((void *)ptr);\n#else\n    /* change this to `return 0;` if compilation fails */\n    return malloc_usable_size((void *)ptr);\n#endif\n}\n\nstatic void *js_def_malloc(JSMallocState *s, size_t size)\n{\n    void *ptr;\n\n    /* Do not allocate zero bytes: behavior is platform dependent */\n    assert(size != 0);\n\n    if (unlikely(s->malloc_size + size > s->malloc_limit))\n        return NULL;\n\n    ptr = malloc(size);\n    if (!ptr)\n        return NULL;\n\n    s->malloc_count++;\n    s->malloc_size += js_def_malloc_usable_size(ptr) + MALLOC_OVERHEAD;\n    return ptr;\n}\n\nstatic void js_def_free(JSMallocState *s, void *ptr)\n{\n    if (!ptr)\n        return;\n\n    s->malloc_count--;\n    s->malloc_size -= js_def_malloc_usable_size(ptr) + MALLOC_OVERHEAD;\n    free(ptr);\n}\n\nstatic void *js_def_realloc(JSMallocState *s, void *ptr, size_t size)\n{\n    size_t old_size;\n\n    if (!ptr) {\n        if (size == 0)\n            return NULL;\n        return js_def_malloc(s, size);\n    }\n    old_size = js_def_malloc_usable_size(ptr);\n    if (size == 0) {\n        s->malloc_count--;\n        s->malloc_size -= old_size + MALLOC_OVERHEAD;\n        free(ptr);\n        return NULL;\n    }\n    if (s->malloc_size + size - old_size > s->malloc_limit)\n        return NULL;\n\n    ptr = realloc(ptr, size);\n    if (!ptr)\n        return NULL;\n\n    s->malloc_size += js_def_malloc_usable_size(ptr) - old_size;\n    return ptr;\n}\n\nstatic const JSMallocFunctions def_malloc_funcs = {\n    js_def_malloc,\n    js_def_free,\n    js_def_realloc,\n    js_def_malloc_usable_size,\n};\n\nJSRuntime *JS_NewRuntime(void)\n{\n    return JS_NewRuntime2(&def_malloc_funcs, NULL);\n}\n\nvoid JS_SetMemoryLimit(JSRuntime *rt, size_t limit)\n{\n    rt->malloc_state.malloc_limit = limit;\n}\n\n/* use -1 to disable automatic GC */\nvoid JS_SetGCThreshold(JSRuntime *rt, size_t gc_threshold)\n{\n    rt->malloc_gc_threshold = gc_threshold;\n}\n\n#define malloc(s) malloc_is_forbidden(s)\n#define free(p) free_is_forbidden(p)\n#define realloc(p,s) realloc_is_forbidden(p,s)\n\nvoid JS_SetInterruptHandler(JSRuntime *rt, JSInterruptHandler *cb, void *opaque)\n{\n    rt->interrupt_handler = cb;\n    rt->interrupt_opaque = opaque;\n}\n\nvoid JS_SetCanBlock(JSRuntime *rt, BOOL can_block)\n{\n    rt->can_block = can_block;\n}\n\nvoid JS_SetSharedArrayBufferFunctions(JSRuntime *rt,\n                                      const JSSharedArrayBufferFunctions *sf)\n{\n    rt->sab_funcs = *sf;\n}\n\n/* return 0 if OK, < 0 if exception */\nint JS_EnqueueJob(JSContext *ctx, JSJobFunc *job_func,\n                  int argc, JSValueConst *argv)\n{\n    JSRuntime *rt = ctx->rt;\n    JSJobEntry *e;\n    int i;\n\n    e = js_malloc(ctx, sizeof(*e) + argc * sizeof(JSValue));\n    if (!e)\n        return -1;\n    e->ctx = ctx;\n    e->job_func = job_func;\n    e->argc = argc;\n    for(i = 0; i < argc; i++) {\n        e->argv[i] = JS_DupValue(ctx, argv[i]);\n    }\n    list_add_tail(&e->link, &rt->job_list);\n    return 0;\n}\n\nBOOL JS_IsJobPending(JSRuntime *rt)\n{\n    return !list_empty(&rt->job_list);\n}\n\n/* return < 0 if exception, 0 if no job pending, 1 if a job was\n   executed successfully. the context of the job is stored in '*pctx' */\nint JS_ExecutePendingJob(JSRuntime *rt, JSContext **pctx)\n{\n    JSContext *ctx;\n    JSJobEntry *e;\n    JSValue res;\n    int i, ret;\n\n    if (list_empty(&rt->job_list)) {\n        *pctx = NULL;\n        return 0;\n    }\n\n    /* get the first pending job and execute it */\n    e = list_entry(rt->job_list.next, JSJobEntry, link);\n    list_del(&e->link);\n    ctx = e->ctx;\n    res = e->job_func(e->ctx, e->argc, (JSValueConst *)e->argv);\n    for(i = 0; i < e->argc; i++)\n        JS_FreeValue(ctx, e->argv[i]);\n    if (JS_IsException(res))\n        ret = -1;\n    else\n        ret = 1;\n    JS_FreeValue(ctx, res);\n    js_free(ctx, e);\n    *pctx = ctx;\n    return ret;\n}\n\nstatic inline uint32_t atom_get_free(const JSAtomStruct *p)\n{\n    return (uintptr_t)p >> 1;\n}\n\nstatic inline BOOL atom_is_free(const JSAtomStruct *p)\n{\n    return (uintptr_t)p & 1;\n}\n\nstatic inline JSAtomStruct *atom_set_free(uint32_t v)\n{\n    return (JSAtomStruct *)(((uintptr_t)v << 1) | 1);\n}\n\n/* Note: the string contents are uninitialized */\nstatic JSString *js_alloc_string_rt(JSRuntime *rt, int max_len, int is_wide_char)\n{\n    JSString *str;\n    str = js_malloc_rt(rt, sizeof(JSString) + (max_len << is_wide_char) + 1 - is_wide_char);\n    if (unlikely(!str))\n        return NULL;\n    str->header.ref_count = 1;\n    str->is_wide_char = is_wide_char;\n    str->len = max_len;\n    str->atom_type = 0;\n    str->hash = 0;          /* optional but costless */\n    str->hash_next = 0;     /* optional */\n#ifdef DUMP_LEAKS\n    list_add_tail(&str->link, &rt->string_list);\n#endif\n    return str;\n}\n\nstatic JSString *js_alloc_string(JSContext *ctx, int max_len, int is_wide_char)\n{\n    JSString *p;\n    p = js_alloc_string_rt(ctx->rt, max_len, is_wide_char);\n    if (unlikely(!p)) {\n        JS_ThrowOutOfMemory(ctx);\n        return NULL;\n    }\n    return p;\n}\n\n/* same as JS_FreeValueRT() but faster */\nstatic inline void js_free_string(JSRuntime *rt, JSString *str)\n{\n    if (--str->header.ref_count <= 0) {\n        if (str->atom_type) {\n            JS_FreeAtomStruct(rt, str);\n        } else {\n#ifdef DUMP_LEAKS\n            list_del(&str->link);\n#endif\n            js_free_rt(rt, str);\n        }\n    }\n}\n\nvoid JS_SetRuntimeInfo(JSRuntime *rt, const char *s)\n{\n    if (rt)\n        rt->rt_info = s;\n}\n\nvoid JS_FreeRuntime(JSRuntime *rt)\n{\n    struct list_head *el, *el1;\n    int i;\n\n    JS_FreeValueRT(rt, rt->current_exception);\n\n    list_for_each_safe(el, el1, &rt->job_list) {\n        JSJobEntry *e = list_entry(el, JSJobEntry, link);\n        for(i = 0; i < e->argc; i++)\n            JS_FreeValueRT(rt, e->argv[i]);\n        js_free_rt(rt, e);\n    }\n    init_list_head(&rt->job_list);\n\n    JS_RunGC(rt);\n\n#ifdef DUMP_LEAKS\n    /* leaking objects */\n    {\n        BOOL header_done;\n        JSGCObjectHeader *p;\n        int count;\n\n        /* remove the internal refcounts to display only the object\n           referenced externally */\n        list_for_each(el, &rt->gc_obj_list) {\n            p = list_entry(el, JSGCObjectHeader, link);\n            p->mark = 0;\n        }\n        gc_decref(rt);\n\n        header_done = FALSE;\n        list_for_each(el, &rt->gc_obj_list) {\n            p = list_entry(el, JSGCObjectHeader, link);\n            if (p->ref_count != 0) {\n                if (!header_done) {\n                    printf(\"Object leaks:\\n\");\n                    JS_DumpObjectHeader(rt);\n                    header_done = TRUE;\n                }\n                JS_DumpGCObject(rt, p);\n            }\n        }\n\n        count = 0;\n        list_for_each(el, &rt->gc_obj_list) {\n            p = list_entry(el, JSGCObjectHeader, link);\n            if (p->ref_count == 0) {\n                count++;\n            }\n        }\n        if (count != 0)\n            printf(\"Secondary object leaks: %d\\n\", count);\n    }\n#endif\n    assert(list_empty(&rt->gc_obj_list));\n\n    /* free the classes */\n    for(i = 0; i < rt->class_count; i++) {\n        JSClass *cl = &rt->class_array[i];\n        if (cl->class_id != 0) {\n            JS_FreeAtomRT(rt, cl->class_name);\n        }\n    }\n    js_free_rt(rt, rt->class_array);\n\n    bf_context_end(&rt->bf_ctx);\n\n#ifdef DUMP_LEAKS\n    /* only the atoms defined in JS_InitAtoms() should be left */\n    {\n        BOOL header_done = FALSE;\n\n        for(i = 0; i < rt->atom_size; i++) {\n            JSAtomStruct *p = rt->atom_array[i];\n            if (!atom_is_free(p) /* && p->str*/) {\n                if (i >= JS_ATOM_END || p->header.ref_count != 1) {\n                    if (!header_done) {\n                        header_done = TRUE;\n                        if (rt->rt_info) {\n                            printf(\"%s:1: atom leakage:\", rt->rt_info);\n                        } else {\n                            printf(\"Atom leaks:\\n\"\n                                   \"    %6s %6s %s\\n\",\n                                   \"ID\", \"REFCNT\", \"NAME\");\n                        }\n                    }\n                    if (rt->rt_info) {\n                        printf(\" \");\n                    } else {\n                        printf(\"    %6u %6u \", i, p->header.ref_count);\n                    }\n                    switch (p->atom_type) {\n                    case JS_ATOM_TYPE_STRING:\n                        JS_DumpString(rt, p);\n                        break;\n                    case JS_ATOM_TYPE_GLOBAL_SYMBOL:\n                        printf(\"Symbol.for(\");\n                        JS_DumpString(rt, p);\n                        printf(\")\");\n                        break;\n                    case JS_ATOM_TYPE_SYMBOL:\n                        if (p->hash == JS_ATOM_HASH_SYMBOL) {\n                            printf(\"Symbol(\");\n                            JS_DumpString(rt, p);\n                            printf(\")\");\n                        } else {\n                            printf(\"Private(\");\n                            JS_DumpString(rt, p);\n                            printf(\")\");\n                        }\n                        break;\n                    }\n                    if (rt->rt_info) {\n                        printf(\":%u\", p->header.ref_count);\n                    } else {\n                        printf(\"\\n\");\n                    }\n                }\n            }\n        }\n        if (rt->rt_info && header_done)\n            printf(\"\\n\");\n    }\n#endif\n\n    /* free the atoms */\n    for(i = 0; i < rt->atom_size; i++) {\n        JSAtomStruct *p = rt->atom_array[i];\n        if (!atom_is_free(p)) {\n#ifdef DUMP_LEAKS\n            list_del(&p->link);\n#endif\n            js_free_rt(rt, p);\n        }\n    }\n    js_free_rt(rt, rt->atom_array);\n    js_free_rt(rt, rt->atom_hash);\n    js_free_rt(rt, rt->shape_hash);\n#ifdef DUMP_LEAKS\n    if (!list_empty(&rt->string_list)) {\n        if (rt->rt_info) {\n            printf(\"%s:1: string leakage:\", rt->rt_info);\n        } else {\n            printf(\"String leaks:\\n\"\n                   \"    %6s %s\\n\",\n                   \"REFCNT\", \"VALUE\");\n        }\n        list_for_each_safe(el, el1, &rt->string_list) {\n            JSString *str = list_entry(el, JSString, link);\n            if (rt->rt_info) {\n                printf(\" \");\n            } else {\n                printf(\"    %6u \", str->header.ref_count);\n            }\n            JS_DumpString(rt, str);\n            if (rt->rt_info) {\n                printf(\":%u\", str->header.ref_count);\n            } else {\n                printf(\"\\n\");\n            }\n            list_del(&str->link);\n            js_free_rt(rt, str);\n        }\n        if (rt->rt_info)\n            printf(\"\\n\");\n    }\n    {\n        JSMallocState *s = &rt->malloc_state;\n        if (s->malloc_count > 1) {\n            if (rt->rt_info)\n                printf(\"%s:1: \", rt->rt_info);\n            printf(\"Memory leak: %\"PRIu64\" bytes lost in %\"PRIu64\" block%s\\n\",\n                   (uint64_t)(s->malloc_size - sizeof(JSRuntime)),\n                   (uint64_t)(s->malloc_count - 1), &\"s\"[s->malloc_count == 2]);\n        }\n    }\n#endif\n\n    {\n        JSMallocState ms = rt->malloc_state;\n        rt->mf.js_free(&ms, rt);\n    }\n}\n\nJSContext *JS_NewContextRaw(JSRuntime *rt)\n{\n    JSContext *ctx;\n    int i;\n\n    ctx = js_mallocz_rt(rt, sizeof(JSContext));\n    if (!ctx)\n        return NULL;\n    ctx->header.ref_count = 1;\n    add_gc_object(rt, &ctx->header, JS_GC_OBJ_TYPE_JS_CONTEXT);\n\n    ctx->class_proto = js_malloc_rt(rt, sizeof(ctx->class_proto[0]) *\n                                    rt->class_count);\n    if (!ctx->class_proto) {\n        js_free_rt(rt, ctx);\n        return NULL;\n    }\n    ctx->rt = rt;\n    list_add_tail(&ctx->link, &rt->context_list);\n    ctx->bf_ctx = &rt->bf_ctx;\n#ifdef CONFIG_BIGNUM\n    ctx->fp_env.prec = 113;\n    ctx->fp_env.flags = bf_set_exp_bits(15) | BF_RNDN | BF_FLAG_SUBNORMAL;\n#endif\n    for(i = 0; i < rt->class_count; i++)\n        ctx->class_proto[i] = JS_NULL;\n    ctx->array_ctor = JS_NULL;\n    ctx->regexp_ctor = JS_NULL;\n    ctx->promise_ctor = JS_NULL;\n    init_list_head(&ctx->loaded_modules);\n\n    JS_AddIntrinsicBasicObjects(ctx);\n    return ctx;\n}\n\nJSContext *JS_NewContext(JSRuntime *rt)\n{\n    JSContext *ctx;\n\n    ctx = JS_NewContextRaw(rt);\n    if (!ctx)\n        return NULL;\n\n    JS_AddIntrinsicBaseObjects(ctx);\n    JS_AddIntrinsicDate(ctx);\n    JS_AddIntrinsicEval(ctx);\n    JS_AddIntrinsicStringNormalize(ctx);\n    JS_AddIntrinsicRegExp(ctx);\n    JS_AddIntrinsicJSON(ctx);\n    JS_AddIntrinsicProxy(ctx);\n    JS_AddIntrinsicMapSet(ctx);\n    JS_AddIntrinsicTypedArrays(ctx);\n    JS_AddIntrinsicPromise(ctx);\n    JS_AddIntrinsicBigInt(ctx);\n    return ctx;\n}\n\nvoid *JS_GetContextOpaque(JSContext *ctx)\n{\n    return ctx->user_opaque;\n}\n\nvoid JS_SetContextOpaque(JSContext *ctx, void *opaque)\n{\n    ctx->user_opaque = opaque;\n}\n\n/* set the new value and free the old value after (freeing the value\n   can reallocate the object data) */\nstatic inline void set_value(JSContext *ctx, JSValue *pval, JSValue new_val)\n{\n    JSValue old_val;\n    old_val = *pval;\n    *pval = new_val;\n    JS_FreeValue(ctx, old_val);\n}\n\nvoid JS_SetClassProto(JSContext *ctx, JSClassID class_id, JSValue obj)\n{\n    JSRuntime *rt = ctx->rt;\n    assert(class_id < rt->class_count);\n    set_value(ctx, &ctx->class_proto[class_id], obj);\n}\n\nJSValue JS_GetClassProto(JSContext *ctx, JSClassID class_id)\n{\n    JSRuntime *rt = ctx->rt;\n    assert(class_id < rt->class_count);\n    return JS_DupValue(ctx, ctx->class_proto[class_id]);\n}\n\ntypedef enum JSFreeModuleEnum {\n    JS_FREE_MODULE_ALL,\n    JS_FREE_MODULE_NOT_RESOLVED,\n} JSFreeModuleEnum;\n\n/* XXX: would be more efficient with separate module lists */\nstatic void js_free_modules(JSContext *ctx, JSFreeModuleEnum flag)\n{\n    struct list_head *el, *el1;\n    list_for_each_safe(el, el1, &ctx->loaded_modules) {\n        JSModuleDef *m = list_entry(el, JSModuleDef, link);\n        if (flag == JS_FREE_MODULE_ALL ||\n            (flag == JS_FREE_MODULE_NOT_RESOLVED && !m->resolved)) {\n            js_free_module_def(ctx, m);\n        }\n    }\n}\n\nJSContext *JS_DupContext(JSContext *ctx)\n{\n    ctx->header.ref_count++;\n    return ctx;\n}\n\n/* used by the GC */\nstatic void JS_MarkContext(JSRuntime *rt, JSContext *ctx,\n                           JS_MarkFunc *mark_func)\n{\n    int i;\n    struct list_head *el;\n\n    /* modules are not seen by the GC, so we directly mark the objects\n       referenced by each module */\n    list_for_each(el, &ctx->loaded_modules) {\n        JSModuleDef *m = list_entry(el, JSModuleDef, link);\n        js_mark_module_def(rt, m, mark_func);\n    }\n\n    JS_MarkValue(rt, ctx->global_obj, mark_func);\n    JS_MarkValue(rt, ctx->global_var_obj, mark_func);\n\n    JS_MarkValue(rt, ctx->throw_type_error, mark_func);\n    JS_MarkValue(rt, ctx->eval_obj, mark_func);\n\n    JS_MarkValue(rt, ctx->array_proto_values, mark_func);\n    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {\n        JS_MarkValue(rt, ctx->native_error_proto[i], mark_func);\n    }\n    for(i = 0; i < rt->class_count; i++) {\n        JS_MarkValue(rt, ctx->class_proto[i], mark_func);\n    }\n    JS_MarkValue(rt, ctx->iterator_proto, mark_func);\n    JS_MarkValue(rt, ctx->async_iterator_proto, mark_func);\n    JS_MarkValue(rt, ctx->promise_ctor, mark_func);\n    JS_MarkValue(rt, ctx->array_ctor, mark_func);\n    JS_MarkValue(rt, ctx->regexp_ctor, mark_func);\n    JS_MarkValue(rt, ctx->function_ctor, mark_func);\n    JS_MarkValue(rt, ctx->function_proto, mark_func);\n\n    if (ctx->array_shape)\n        mark_func(rt, &ctx->array_shape->header);\n}\n\nvoid JS_FreeContext(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    int i;\n\n    if (--ctx->header.ref_count > 0)\n        return;\n    assert(ctx->header.ref_count == 0);\n\n#ifdef DUMP_ATOMS\n    JS_DumpAtoms(ctx->rt);\n#endif\n#ifdef DUMP_SHAPES\n    JS_DumpShapes(ctx->rt);\n#endif\n#ifdef DUMP_OBJECTS\n    {\n        struct list_head *el;\n        JSGCObjectHeader *p;\n        printf(\"JSObjects: {\\n\");\n        JS_DumpObjectHeader(ctx->rt);\n        list_for_each(el, &rt->gc_obj_list) {\n            p = list_entry(el, JSGCObjectHeader, link);\n            JS_DumpGCObject(rt, p);\n        }\n        printf(\"}\\n\");\n    }\n#endif\n#ifdef DUMP_MEM\n    {\n        JSMemoryUsage stats;\n        JS_ComputeMemoryUsage(rt, &stats);\n        JS_DumpMemoryUsage(stdout, &stats, rt);\n    }\n#endif\n\n    js_free_modules(ctx, JS_FREE_MODULE_ALL);\n\n    JS_FreeValue(ctx, ctx->global_obj);\n    JS_FreeValue(ctx, ctx->global_var_obj);\n\n    JS_FreeValue(ctx, ctx->throw_type_error);\n    JS_FreeValue(ctx, ctx->eval_obj);\n\n    JS_FreeValue(ctx, ctx->array_proto_values);\n    for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {\n        JS_FreeValue(ctx, ctx->native_error_proto[i]);\n    }\n    for(i = 0; i < rt->class_count; i++) {\n        JS_FreeValue(ctx, ctx->class_proto[i]);\n    }\n    js_free_rt(rt, ctx->class_proto);\n    JS_FreeValue(ctx, ctx->iterator_proto);\n    JS_FreeValue(ctx, ctx->async_iterator_proto);\n    JS_FreeValue(ctx, ctx->promise_ctor);\n    JS_FreeValue(ctx, ctx->array_ctor);\n    JS_FreeValue(ctx, ctx->regexp_ctor);\n    JS_FreeValue(ctx, ctx->function_ctor);\n    JS_FreeValue(ctx, ctx->function_proto);\n\n    js_free_shape_null(ctx->rt, ctx->array_shape);\n\n    list_del(&ctx->link);\n    remove_gc_object(&ctx->header);\n    js_free_rt(ctx->rt, ctx);\n}\n\nJSRuntime *JS_GetRuntime(JSContext *ctx)\n{\n    return ctx->rt;\n}\n\nstatic void update_stack_limit(JSRuntime *rt)\n{\n    if (rt->stack_size == 0) {\n        rt->stack_limit = 0; /* no limit */\n    } else {\n        rt->stack_limit = rt->stack_top - rt->stack_size;\n    }\n}\n\nvoid JS_SetMaxStackSize(JSRuntime *rt, size_t stack_size)\n{\n    rt->stack_size = stack_size;\n    update_stack_limit(rt);\n}\n\nvoid JS_UpdateStackTop(JSRuntime *rt)\n{\n    rt->stack_top = js_get_stack_pointer();\n    update_stack_limit(rt);\n}\n\nstatic inline BOOL is_strict_mode(JSContext *ctx)\n{\n    JSStackFrame *sf = ctx->rt->current_stack_frame;\n    return (sf && (sf->js_mode & JS_MODE_STRICT));\n}\n\n#ifdef CONFIG_BIGNUM\nstatic inline BOOL is_math_mode(JSContext *ctx)\n{\n    JSStackFrame *sf = ctx->rt->current_stack_frame;\n    return (sf && (sf->js_mode & JS_MODE_MATH));\n}\n#else\nstatic inline BOOL is_math_mode(JSContext *ctx)\n{\n    return FALSE;\n}\n#endif\n\n/* JSAtom support */\n\n#define JS_ATOM_TAG_INT (1U << 31)\n#define JS_ATOM_MAX_INT (JS_ATOM_TAG_INT - 1)\n#define JS_ATOM_MAX     ((1U << 30) - 1)\n\n/* return the max count from the hash size */\n#define JS_ATOM_COUNT_RESIZE(n) ((n) * 2)\n\nstatic inline BOOL __JS_AtomIsConst(JSAtom v)\n{\n#if defined(DUMP_LEAKS) && DUMP_LEAKS > 1\n        return (int32_t)v <= 0;\n#else\n        return (int32_t)v < JS_ATOM_END;\n#endif\n}\n\nstatic inline BOOL __JS_AtomIsTaggedInt(JSAtom v)\n{\n    return (v & JS_ATOM_TAG_INT) != 0;\n}\n\nstatic inline JSAtom __JS_AtomFromUInt32(uint32_t v)\n{\n    return v | JS_ATOM_TAG_INT;\n}\n\nstatic inline uint32_t __JS_AtomToUInt32(JSAtom atom)\n{\n    return atom & ~JS_ATOM_TAG_INT;\n}\n\nstatic inline int is_num(int c)\n{\n    return c >= '0' && c <= '9';\n}\n\n/* return TRUE if the string is a number n with 0 <= n <= 2^32-1 */\nstatic inline BOOL is_num_string(uint32_t *pval, const JSString *p)\n{\n    uint32_t n;\n    uint64_t n64;\n    int c, i, len;\n\n    len = p->len;\n    if (len == 0 || len > 10)\n        return FALSE;\n    c = string_get(p, 0);\n    if (is_num(c)) {\n        if (c == '0') {\n            if (len != 1)\n                return FALSE;\n            n = 0;\n        } else {\n            n = c - '0';\n            for(i = 1; i < len; i++) {\n                c = string_get(p, i);\n                if (!is_num(c))\n                    return FALSE;\n                n64 = (uint64_t)n * 10 + (c - '0');\n                if ((n64 >> 32) != 0)\n                    return FALSE;\n                n = n64;\n            }\n        }\n        *pval = n;\n        return TRUE;\n    } else {\n        return FALSE;\n    }\n}\n\n/* XXX: could use faster version ? */\nstatic inline uint32_t hash_string8(const uint8_t *str, size_t len, uint32_t h)\n{\n    size_t i;\n\n    for(i = 0; i < len; i++)\n        h = h * 263 + str[i];\n    return h;\n}\n\nstatic inline uint32_t hash_string16(const uint16_t *str,\n                                     size_t len, uint32_t h)\n{\n    size_t i;\n\n    for(i = 0; i < len; i++)\n        h = h * 263 + str[i];\n    return h;\n}\n\nstatic uint32_t hash_string(const JSString *str, uint32_t h)\n{\n    if (str->is_wide_char)\n        h = hash_string16(str->u.str16, str->len, h);\n    else\n        h = hash_string8(str->u.str8, str->len, h);\n    return h;\n}\n\nstatic __maybe_unused void JS_DumpChar(JSRuntime *rt, int c, int sep)\n{\n    if (c == sep || c == '\\\\') {\n        putchar('\\\\');\n        putchar(c);\n    } else if (c >= ' ' && c <= 126) {\n        putchar(c);\n    } else if (c == '\\n') {\n        putchar('\\\\');\n        putchar('n');\n    } else {\n        printf(\"\\\\u%04x\", c);\n    }\n}\n\nstatic __maybe_unused void JS_DumpString(JSRuntime *rt, const JSString *p)\n{\n    int i, sep;\n\n    if (p == NULL) {\n        printf(\"<null>\");\n        return;\n    }\n    printf(\"%d\", p->header.ref_count);\n    sep = (p->header.ref_count == 1) ? '\\\"' : '\\'';\n    putchar(sep);\n    for(i = 0; i < p->len; i++) {\n        JS_DumpChar(rt, string_get(p, i), sep);\n    }\n    putchar(sep);\n}\n\nstatic __maybe_unused void JS_DumpAtoms(JSRuntime *rt)\n{\n    JSAtomStruct *p;\n    int h, i;\n    /* This only dumps hashed atoms, not JS_ATOM_TYPE_SYMBOL atoms */\n    printf(\"JSAtom count=%d size=%d hash_size=%d:\\n\",\n           rt->atom_count, rt->atom_size, rt->atom_hash_size);\n    printf(\"JSAtom hash table: {\\n\");\n    for(i = 0; i < rt->atom_hash_size; i++) {\n        h = rt->atom_hash[i];\n        if (h) {\n            printf(\"  %d:\", i);\n            while (h) {\n                p = rt->atom_array[h];\n                printf(\" \");\n                JS_DumpString(rt, p);\n                h = p->hash_next;\n            }\n            printf(\"\\n\");\n        }\n    }\n    printf(\"}\\n\");\n    printf(\"JSAtom table: {\\n\");\n    for(i = 0; i < rt->atom_size; i++) {\n        p = rt->atom_array[i];\n        if (!atom_is_free(p)) {\n            printf(\"  %d: { %d %08x \", i, p->atom_type, p->hash);\n            if (!(p->len == 0 && p->is_wide_char != 0))\n                JS_DumpString(rt, p);\n            printf(\" %d }\\n\", p->hash_next);\n        }\n    }\n    printf(\"}\\n\");\n}\n\nstatic int JS_ResizeAtomHash(JSRuntime *rt, int new_hash_size)\n{\n    JSAtomStruct *p;\n    uint32_t new_hash_mask, h, i, hash_next1, j, *new_hash;\n\n    assert((new_hash_size & (new_hash_size - 1)) == 0); /* power of two */\n    new_hash_mask = new_hash_size - 1;\n    new_hash = js_mallocz_rt(rt, sizeof(rt->atom_hash[0]) * new_hash_size);\n    if (!new_hash)\n        return -1;\n    for(i = 0; i < rt->atom_hash_size; i++) {\n        h = rt->atom_hash[i];\n        while (h != 0) {\n            p = rt->atom_array[h];\n            hash_next1 = p->hash_next;\n            /* add in new hash table */\n            j = p->hash & new_hash_mask;\n            p->hash_next = new_hash[j];\n            new_hash[j] = h;\n            h = hash_next1;\n        }\n    }\n    js_free_rt(rt, rt->atom_hash);\n    rt->atom_hash = new_hash;\n    rt->atom_hash_size = new_hash_size;\n    rt->atom_count_resize = JS_ATOM_COUNT_RESIZE(new_hash_size);\n    //    JS_DumpAtoms(rt);\n    return 0;\n}\n\nstatic int JS_InitAtoms(JSRuntime *rt)\n{\n    int i, len, atom_type;\n    const char *p;\n\n    rt->atom_hash_size = 0;\n    rt->atom_hash = NULL;\n    rt->atom_count = 0;\n    rt->atom_size = 0;\n    rt->atom_free_index = 0;\n    if (JS_ResizeAtomHash(rt, 256))     /* there are at least 195 predefined atoms */\n        return -1;\n\n    p = js_atom_init;\n    for(i = 1; i < JS_ATOM_END; i++) {\n        if (i == JS_ATOM_Private_brand)\n            atom_type = JS_ATOM_TYPE_PRIVATE;\n        else if (i >= JS_ATOM_Symbol_toPrimitive)\n            atom_type = JS_ATOM_TYPE_SYMBOL;\n        else\n            atom_type = JS_ATOM_TYPE_STRING;\n        len = strlen(p);\n        if (__JS_NewAtomInit(rt, p, len, atom_type) == JS_ATOM_NULL)\n            return -1;\n        p = p + len + 1;\n    }\n    return 0;\n}\n\nstatic JSAtom JS_DupAtomRT(JSRuntime *rt, JSAtom v)\n{\n    JSAtomStruct *p;\n\n    if (!__JS_AtomIsConst(v)) {\n        p = rt->atom_array[v];\n        p->header.ref_count++;\n    }\n    return v;\n}\n\nJSAtom JS_DupAtom(JSContext *ctx, JSAtom v)\n{\n    JSRuntime *rt;\n    JSAtomStruct *p;\n\n    if (!__JS_AtomIsConst(v)) {\n        rt = ctx->rt;\n        p = rt->atom_array[v];\n        p->header.ref_count++;\n    }\n    return v;\n}\n\nstatic JSAtomKindEnum JS_AtomGetKind(JSContext *ctx, JSAtom v)\n{\n    JSRuntime *rt;\n    JSAtomStruct *p;\n\n    rt = ctx->rt;\n    if (__JS_AtomIsTaggedInt(v))\n        return JS_ATOM_KIND_STRING;\n    p = rt->atom_array[v];\n    switch(p->atom_type) {\n    case JS_ATOM_TYPE_STRING:\n        return JS_ATOM_KIND_STRING;\n    case JS_ATOM_TYPE_GLOBAL_SYMBOL:\n        return JS_ATOM_KIND_SYMBOL;\n    case JS_ATOM_TYPE_SYMBOL:\n        switch(p->hash) {\n        case JS_ATOM_HASH_SYMBOL:\n            return JS_ATOM_KIND_SYMBOL;\n        case JS_ATOM_HASH_PRIVATE:\n            return JS_ATOM_KIND_PRIVATE;\n        default:\n            abort();\n        }\n    default:\n        abort();\n    }\n}\n\nstatic BOOL JS_AtomIsString(JSContext *ctx, JSAtom v)\n{\n    return JS_AtomGetKind(ctx, v) == JS_ATOM_KIND_STRING;\n}\n\nstatic JSAtom js_get_atom_index(JSRuntime *rt, JSAtomStruct *p)\n{\n    uint32_t i = p->hash_next;  /* atom_index */\n    if (p->atom_type != JS_ATOM_TYPE_SYMBOL) {\n        JSAtomStruct *p1;\n\n        i = rt->atom_hash[p->hash & (rt->atom_hash_size - 1)];\n        p1 = rt->atom_array[i];\n        while (p1 != p) {\n            assert(i != 0);\n            i = p1->hash_next;\n            p1 = rt->atom_array[i];\n        }\n    }\n    return i;\n}\n\n/* string case (internal). Return JS_ATOM_NULL if error. 'str' is\n   freed. */\nstatic JSAtom __JS_NewAtom(JSRuntime *rt, JSString *str, int atom_type)\n{\n    uint32_t h, h1, i;\n    JSAtomStruct *p;\n    int len;\n\n#if 0\n    printf(\"__JS_NewAtom: \");  JS_DumpString(rt, str); printf(\"\\n\");\n#endif\n    if (atom_type < JS_ATOM_TYPE_SYMBOL) {\n        /* str is not NULL */\n        if (str->atom_type == atom_type) {\n            /* str is the atom, return its index */\n            i = js_get_atom_index(rt, str);\n            /* reduce string refcount and increase atom's unless constant */\n            if (__JS_AtomIsConst(i))\n                str->header.ref_count--;\n            return i;\n        }\n        /* try and locate an already registered atom */\n        len = str->len;\n        h = hash_string(str, atom_type);\n        h &= JS_ATOM_HASH_MASK;\n        h1 = h & (rt->atom_hash_size - 1);\n        i = rt->atom_hash[h1];\n        while (i != 0) {\n            p = rt->atom_array[i];\n            if (p->hash == h &&\n                p->atom_type == atom_type &&\n                p->len == len &&\n                js_string_memcmp(p, str, len) == 0) {\n                if (!__JS_AtomIsConst(i))\n                    p->header.ref_count++;\n                goto done;\n            }\n            i = p->hash_next;\n        }\n    } else {\n        h1 = 0; /* avoid warning */\n        if (atom_type == JS_ATOM_TYPE_SYMBOL) {\n            h = JS_ATOM_HASH_SYMBOL;\n        } else {\n            h = JS_ATOM_HASH_PRIVATE;\n            atom_type = JS_ATOM_TYPE_SYMBOL;\n        }\n    }\n\n    if (rt->atom_free_index == 0) {\n        /* allow new atom entries */\n        uint32_t new_size, start;\n        JSAtomStruct **new_array;\n\n        /* alloc new with size progression 3/2:\n           4 6 9 13 19 28 42 63 94 141 211 316 474 711 1066 1599 2398 3597 5395 8092\n           preallocating space for predefined atoms (at least 195).\n         */\n        new_size = max_int(211, rt->atom_size * 3 / 2);\n        if (new_size > JS_ATOM_MAX)\n            goto fail;\n        /* XXX: should use realloc2 to use slack space */\n        new_array = js_realloc_rt(rt, rt->atom_array, sizeof(*new_array) * new_size);\n        if (!new_array)\n            goto fail;\n        /* Note: the atom 0 is not used */\n        start = rt->atom_size;\n        if (start == 0) {\n            /* JS_ATOM_NULL entry */\n            p = js_mallocz_rt(rt, sizeof(JSAtomStruct));\n            if (!p) {\n                js_free_rt(rt, new_array);\n                goto fail;\n            }\n            p->header.ref_count = 1;  /* not refcounted */\n            p->atom_type = JS_ATOM_TYPE_SYMBOL;\n#ifdef DUMP_LEAKS\n            list_add_tail(&p->link, &rt->string_list);\n#endif\n            new_array[0] = p;\n            rt->atom_count++;\n            start = 1;\n        }\n        rt->atom_size = new_size;\n        rt->atom_array = new_array;\n        rt->atom_free_index = start;\n        for(i = start; i < new_size; i++) {\n            uint32_t next;\n            if (i == (new_size - 1))\n                next = 0;\n            else\n                next = i + 1;\n            rt->atom_array[i] = atom_set_free(next);\n        }\n    }\n\n    if (str) {\n        if (str->atom_type == 0) {\n            p = str;\n            p->atom_type = atom_type;\n        } else {\n            p = js_malloc_rt(rt, sizeof(JSString) +\n                             (str->len << str->is_wide_char) +\n                             1 - str->is_wide_char);\n            if (unlikely(!p))\n                goto fail;\n            p->header.ref_count = 1;\n            p->is_wide_char = str->is_wide_char;\n            p->len = str->len;\n#ifdef DUMP_LEAKS\n            list_add_tail(&p->link, &rt->string_list);\n#endif\n            memcpy(p->u.str8, str->u.str8, (str->len << str->is_wide_char) +\n                   1 - str->is_wide_char);\n            js_free_string(rt, str);\n        }\n    } else {\n        p = js_malloc_rt(rt, sizeof(JSAtomStruct)); /* empty wide string */\n        if (!p)\n            return JS_ATOM_NULL;\n        p->header.ref_count = 1;\n        p->is_wide_char = 1;    /* Hack to represent NULL as a JSString */\n        p->len = 0;\n#ifdef DUMP_LEAKS\n        list_add_tail(&p->link, &rt->string_list);\n#endif\n    }\n\n    /* use an already free entry */\n    i = rt->atom_free_index;\n    rt->atom_free_index = atom_get_free(rt->atom_array[i]);\n    rt->atom_array[i] = p;\n\n    p->hash = h;\n    p->hash_next = i;   /* atom_index */\n    p->atom_type = atom_type;\n\n    rt->atom_count++;\n\n    if (atom_type != JS_ATOM_TYPE_SYMBOL) {\n        p->hash_next = rt->atom_hash[h1];\n        rt->atom_hash[h1] = i;\n        if (unlikely(rt->atom_count >= rt->atom_count_resize))\n            JS_ResizeAtomHash(rt, rt->atom_hash_size * 2);\n    }\n\n    //    JS_DumpAtoms(rt);\n    return i;\n\n fail:\n    i = JS_ATOM_NULL;\n done:\n    if (str)\n        js_free_string(rt, str);\n    return i;\n}\n\n/* only works with zero terminated 8 bit strings */\nstatic JSAtom __JS_NewAtomInit(JSRuntime *rt, const char *str, int len,\n                               int atom_type)\n{\n    JSString *p;\n    p = js_alloc_string_rt(rt, len, 0);\n    if (!p)\n        return JS_ATOM_NULL;\n    memcpy(p->u.str8, str, len);\n    p->u.str8[len] = '\\0';\n    return __JS_NewAtom(rt, p, atom_type);\n}\n\n/* Warning: str must be ASCII only */\nstatic JSAtom __JS_FindAtom(JSRuntime *rt, const char *str, size_t len,\n                            int atom_type)\n{\n    uint32_t h, h1, i;\n    JSAtomStruct *p;\n\n    h = hash_string8((const uint8_t *)str, len, JS_ATOM_TYPE_STRING);\n    h &= JS_ATOM_HASH_MASK;\n    h1 = h & (rt->atom_hash_size - 1);\n    i = rt->atom_hash[h1];\n    while (i != 0) {\n        p = rt->atom_array[i];\n        if (p->hash == h &&\n            p->atom_type == JS_ATOM_TYPE_STRING &&\n            p->len == len &&\n            p->is_wide_char == 0 &&\n            memcmp(p->u.str8, str, len) == 0) {\n            if (!__JS_AtomIsConst(i))\n                p->header.ref_count++;\n            return i;\n        }\n        i = p->hash_next;\n    }\n    return JS_ATOM_NULL;\n}\n\nstatic void JS_FreeAtomStruct(JSRuntime *rt, JSAtomStruct *p)\n{\n#if 0   /* JS_ATOM_NULL is not refcounted: __JS_AtomIsConst() includes 0 */\n    if (unlikely(i == JS_ATOM_NULL)) {\n        p->header.ref_count = INT32_MAX / 2;\n        return;\n    }\n#endif\n    uint32_t i = p->hash_next;  /* atom_index */\n    if (p->atom_type != JS_ATOM_TYPE_SYMBOL) {\n        JSAtomStruct *p0, *p1;\n        uint32_t h0;\n\n        h0 = p->hash & (rt->atom_hash_size - 1);\n        i = rt->atom_hash[h0];\n        p1 = rt->atom_array[i];\n        if (p1 == p) {\n            rt->atom_hash[h0] = p1->hash_next;\n        } else {\n            for(;;) {\n                assert(i != 0);\n                p0 = p1;\n                i = p1->hash_next;\n                p1 = rt->atom_array[i];\n                if (p1 == p) {\n                    p0->hash_next = p1->hash_next;\n                    break;\n                }\n            }\n        }\n    }\n    /* insert in free atom list */\n    rt->atom_array[i] = atom_set_free(rt->atom_free_index);\n    rt->atom_free_index = i;\n    /* free the string structure */\n#ifdef DUMP_LEAKS\n    list_del(&p->link);\n#endif\n    js_free_rt(rt, p);\n    rt->atom_count--;\n    assert(rt->atom_count >= 0);\n}\n\nstatic void __JS_FreeAtom(JSRuntime *rt, uint32_t i)\n{\n    JSAtomStruct *p;\n\n    p = rt->atom_array[i];\n    if (--p->header.ref_count > 0)\n        return;\n    JS_FreeAtomStruct(rt, p);\n}\n\n/* Warning: 'p' is freed */\nstatic JSAtom JS_NewAtomStr(JSContext *ctx, JSString *p)\n{\n    JSRuntime *rt = ctx->rt;\n    uint32_t n;\n    if (is_num_string(&n, p)) {\n        if (n <= JS_ATOM_MAX_INT) {\n            js_free_string(rt, p);\n            return __JS_AtomFromUInt32(n);\n        }\n    }\n    /* XXX: should generate an exception */\n    return __JS_NewAtom(rt, p, JS_ATOM_TYPE_STRING);\n}\n\n/* str is UTF-8 encoded */\nJSAtom JS_NewAtomLen(JSContext *ctx, const char *str, size_t len)\n{\n    JSValue val;\n\n    if (len == 0 || !is_digit(*str)) {\n        // XXX: this will not work if UTF-8 encoded str contains non ASCII bytes\n        JSAtom atom = __JS_FindAtom(ctx->rt, str, len, JS_ATOM_TYPE_STRING);\n        if (atom)\n            return atom;\n    }\n    val = JS_NewStringLen(ctx, str, len);\n    if (JS_IsException(val))\n        return JS_ATOM_NULL;\n    return JS_NewAtomStr(ctx, JS_VALUE_GET_STRING(val));\n}\n\nJSAtom JS_NewAtom(JSContext *ctx, const char *str)\n{\n    return JS_NewAtomLen(ctx, str, strlen(str));\n}\n\nJSAtom JS_NewAtomUInt32(JSContext *ctx, uint32_t n)\n{\n    if (n <= JS_ATOM_MAX_INT) {\n        return __JS_AtomFromUInt32(n);\n    } else {\n        char buf[11];\n        JSValue val;\n        snprintf(buf, sizeof(buf), \"%u\", n);\n        val = JS_NewString(ctx, buf);\n        if (JS_IsException(val))\n            return JS_ATOM_NULL;\n        return __JS_NewAtom(ctx->rt, JS_VALUE_GET_STRING(val),\n                            JS_ATOM_TYPE_STRING);\n    }\n}\n\nstatic JSAtom JS_NewAtomInt64(JSContext *ctx, int64_t n)\n{\n    if ((uint64_t)n <= JS_ATOM_MAX_INT) {\n        return __JS_AtomFromUInt32((uint32_t)n);\n    } else {\n        char buf[24];\n        JSValue val;\n        snprintf(buf, sizeof(buf), \"%\" PRId64 , n);\n        val = JS_NewString(ctx, buf);\n        if (JS_IsException(val))\n            return JS_ATOM_NULL;\n        return __JS_NewAtom(ctx->rt, JS_VALUE_GET_STRING(val),\n                            JS_ATOM_TYPE_STRING);\n    }\n}\n\n/* 'p' is freed */\nstatic JSValue JS_NewSymbol(JSContext *ctx, JSString *p, int atom_type)\n{\n    JSRuntime *rt = ctx->rt;\n    JSAtom atom;\n    atom = __JS_NewAtom(rt, p, atom_type);\n    if (atom == JS_ATOM_NULL)\n        return JS_ThrowOutOfMemory(ctx);\n    return JS_MKPTR(JS_TAG_SYMBOL, rt->atom_array[atom]);\n}\n\n/* descr must be a non-numeric string atom */\nstatic JSValue JS_NewSymbolFromAtom(JSContext *ctx, JSAtom descr,\n                                    int atom_type)\n{\n    JSRuntime *rt = ctx->rt;\n    JSString *p;\n\n    assert(!__JS_AtomIsTaggedInt(descr));\n    assert(descr < rt->atom_size);\n    p = rt->atom_array[descr];\n    JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));\n    return JS_NewSymbol(ctx, p, atom_type);\n}\n\n#define ATOM_GET_STR_BUF_SIZE 64\n\n/* Should only be used for debug. */\nstatic const char *JS_AtomGetStrRT(JSRuntime *rt, char *buf, int buf_size,\n                                   JSAtom atom)\n{\n    if (__JS_AtomIsTaggedInt(atom)) {\n        snprintf(buf, buf_size, \"%u\", __JS_AtomToUInt32(atom));\n    } else {\n        JSAtomStruct *p;\n        assert(atom < rt->atom_size);\n        if (atom == JS_ATOM_NULL) {\n            snprintf(buf, buf_size, \"<null>\");\n        } else {\n            int i, c;\n            char *q;\n            JSString *str;\n\n            q = buf;\n            p = rt->atom_array[atom];\n            assert(!atom_is_free(p));\n            str = p;\n            if (str) {\n                if (!str->is_wide_char) {\n                    /* special case ASCII strings */\n                    c = 0;\n                    for(i = 0; i < str->len; i++) {\n                        c |= str->u.str8[i];\n                    }\n                    if (c < 0x80)\n                        return (const char *)str->u.str8;\n                }\n                for(i = 0; i < str->len; i++) {\n                    c = string_get(str, i);\n                    if ((q - buf) >= buf_size - UTF8_CHAR_LEN_MAX)\n                        break;\n                    if (c < 128) {\n                        *q++ = c;\n                    } else {\n                        q += unicode_to_utf8((uint8_t *)q, c);\n                    }\n                }\n            }\n            *q = '\\0';\n        }\n    }\n    return buf;\n}\n\nstatic const char *JS_AtomGetStr(JSContext *ctx, char *buf, int buf_size, JSAtom atom)\n{\n    return JS_AtomGetStrRT(ctx->rt, buf, buf_size, atom);\n}\n\nstatic JSValue __JS_AtomToValue(JSContext *ctx, JSAtom atom, BOOL force_string)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n\n    if (__JS_AtomIsTaggedInt(atom)) {\n        snprintf(buf, sizeof(buf), \"%u\", __JS_AtomToUInt32(atom));\n        return JS_NewString(ctx, buf);\n    } else {\n        JSRuntime *rt = ctx->rt;\n        JSAtomStruct *p;\n        assert(atom < rt->atom_size);\n        p = rt->atom_array[atom];\n        if (p->atom_type == JS_ATOM_TYPE_STRING) {\n            goto ret_string;\n        } else if (force_string) {\n            if (p->len == 0 && p->is_wide_char != 0) {\n                /* no description string */\n                p = rt->atom_array[JS_ATOM_empty_string];\n            }\n        ret_string:\n            return JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));\n        } else {\n            return JS_DupValue(ctx, JS_MKPTR(JS_TAG_SYMBOL, p));\n        }\n    }\n}\n\nJSValue JS_AtomToValue(JSContext *ctx, JSAtom atom)\n{\n    return __JS_AtomToValue(ctx, atom, FALSE);\n}\n\nJSValue JS_AtomToString(JSContext *ctx, JSAtom atom)\n{\n    return __JS_AtomToValue(ctx, atom, TRUE);\n}\n\n/* return TRUE if the atom is an array index (i.e. 0 <= index <=\n   2^32-2 and return its value */\nstatic BOOL JS_AtomIsArrayIndex(JSContext *ctx, uint32_t *pval, JSAtom atom)\n{\n    if (__JS_AtomIsTaggedInt(atom)) {\n        *pval = __JS_AtomToUInt32(atom);\n        return TRUE;\n    } else {\n        JSRuntime *rt = ctx->rt;\n        JSAtomStruct *p;\n        uint32_t val;\n\n        assert(atom < rt->atom_size);\n        p = rt->atom_array[atom];\n        if (p->atom_type == JS_ATOM_TYPE_STRING &&\n            is_num_string(&val, p) && val != -1) {\n            *pval = val;\n            return TRUE;\n        } else {\n            *pval = 0;\n            return FALSE;\n        }\n    }\n}\n\n/* This test must be fast if atom is not a numeric index (e.g. a\n   method name). Return JS_UNDEFINED if not a numeric\n   index. JS_EXCEPTION can also be returned. */\nstatic JSValue JS_AtomIsNumericIndex1(JSContext *ctx, JSAtom atom)\n{\n    JSRuntime *rt = ctx->rt;\n    JSAtomStruct *p1;\n    JSString *p;\n    int c, len, ret;\n    JSValue num, str;\n\n    if (__JS_AtomIsTaggedInt(atom))\n        return JS_NewInt32(ctx, __JS_AtomToUInt32(atom));\n    assert(atom < rt->atom_size);\n    p1 = rt->atom_array[atom];\n    if (p1->atom_type != JS_ATOM_TYPE_STRING)\n        return JS_UNDEFINED;\n    p = p1;\n    len = p->len;\n    if (p->is_wide_char) {\n        const uint16_t *r = p->u.str16, *r_end = p->u.str16 + len;\n        if (r >= r_end)\n            return JS_UNDEFINED;\n        c = *r;\n        if (c == '-') {\n            if (r >= r_end)\n                return JS_UNDEFINED;\n            r++;\n            c = *r;\n            /* -0 case is specific */\n            if (c == '0' && len == 2)\n                goto minus_zero;\n        }\n        /* XXX: should test NaN, but the tests do not check it */\n        if (!is_num(c)) {\n            /* XXX: String should be normalized, therefore 8-bit only */\n            const uint16_t nfinity16[7] = { 'n', 'f', 'i', 'n', 'i', 't', 'y' };\n            if (!(c =='I' && (r_end - r) == 8 &&\n                  !memcmp(r + 1, nfinity16, sizeof(nfinity16))))\n                return JS_UNDEFINED;\n        }\n    } else {\n        const uint8_t *r = p->u.str8, *r_end = p->u.str8 + len;\n        if (r >= r_end)\n            return JS_UNDEFINED;\n        c = *r;\n        if (c == '-') {\n            if (r >= r_end)\n                return JS_UNDEFINED;\n            r++;\n            c = *r;\n            /* -0 case is specific */\n            if (c == '0' && len == 2) {\n            minus_zero:\n                return __JS_NewFloat64(ctx, -0.0);\n            }\n        }\n        if (!is_num(c)) {\n            if (!(c =='I' && (r_end - r) == 8 &&\n                  !memcmp(r + 1, \"nfinity\", 7)))\n                return JS_UNDEFINED;\n        }\n    }\n    /* XXX: bignum: would be better to only accept integer to avoid\n       relying on current floating point precision */\n    /* this is ECMA CanonicalNumericIndexString primitive */\n    num = JS_ToNumber(ctx, JS_MKPTR(JS_TAG_STRING, p));\n    if (JS_IsException(num))\n        return num;\n    str = JS_ToString(ctx, num);\n    if (JS_IsException(str)) {\n        JS_FreeValue(ctx, num);\n        return str;\n    }\n    ret = js_string_compare(ctx, p, JS_VALUE_GET_STRING(str));\n    JS_FreeValue(ctx, str);\n    if (ret == 0) {\n        return num;\n    } else {\n        JS_FreeValue(ctx, num);\n        return JS_UNDEFINED;\n    }\n}\n\n/* return -1 if exception or TRUE/FALSE */\nstatic int JS_AtomIsNumericIndex(JSContext *ctx, JSAtom atom)\n{\n    JSValue num;\n    num = JS_AtomIsNumericIndex1(ctx, atom);\n    if (likely(JS_IsUndefined(num)))\n        return FALSE;\n    if (JS_IsException(num))\n        return -1;\n    JS_FreeValue(ctx, num);\n    return TRUE;\n}\n\nvoid JS_FreeAtom(JSContext *ctx, JSAtom v)\n{\n    if (!__JS_AtomIsConst(v))\n        __JS_FreeAtom(ctx->rt, v);\n}\n\nvoid JS_FreeAtomRT(JSRuntime *rt, JSAtom v)\n{\n    if (!__JS_AtomIsConst(v))\n        __JS_FreeAtom(rt, v);\n}\n\n/* return TRUE if 'v' is a symbol with a string description */\nstatic BOOL JS_AtomSymbolHasDescription(JSContext *ctx, JSAtom v)\n{\n    JSRuntime *rt;\n    JSAtomStruct *p;\n\n    rt = ctx->rt;\n    if (__JS_AtomIsTaggedInt(v))\n        return FALSE;\n    p = rt->atom_array[v];\n    return (((p->atom_type == JS_ATOM_TYPE_SYMBOL &&\n              p->hash == JS_ATOM_HASH_SYMBOL) ||\n             p->atom_type == JS_ATOM_TYPE_GLOBAL_SYMBOL) &&\n            !(p->len == 0 && p->is_wide_char != 0));\n}\n\nstatic __maybe_unused void print_atom(JSContext *ctx, JSAtom atom)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    const char *p;\n    int i;\n\n    /* XXX: should handle embedded null characters */\n    /* XXX: should move encoding code to JS_AtomGetStr */\n    p = JS_AtomGetStr(ctx, buf, sizeof(buf), atom);\n    for (i = 0; p[i]; i++) {\n        int c = (unsigned char)p[i];\n        if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||\n              (c == '_' || c == '$') || (c >= '0' && c <= '9' && i > 0)))\n            break;\n    }\n    if (i > 0 && p[i] == '\\0') {\n        printf(\"%s\", p);\n    } else {\n        putchar('\"');\n        printf(\"%.*s\", i, p);\n        for (; p[i]; i++) {\n            int c = (unsigned char)p[i];\n            if (c == '\\\"' || c == '\\\\') {\n                putchar('\\\\');\n                putchar(c);\n            } else if (c >= ' ' && c <= 126) {\n                putchar(c);\n            } else if (c == '\\n') {\n                putchar('\\\\');\n                putchar('n');\n            } else {\n                printf(\"\\\\u%04x\", c);\n            }\n        }\n        putchar('\\\"');\n    }\n}\n\n/* free with JS_FreeCString() */\nconst char *JS_AtomToCString(JSContext *ctx, JSAtom atom)\n{\n    JSValue str;\n    const char *cstr;\n\n    str = JS_AtomToString(ctx, atom);\n    if (JS_IsException(str))\n        return NULL;\n    cstr = JS_ToCString(ctx, str);\n    JS_FreeValue(ctx, str);\n    return cstr;\n}\n\n/* return a string atom containing name concatenated with str1 */\nstatic JSAtom js_atom_concat_str(JSContext *ctx, JSAtom name, const char *str1)\n{\n    JSValue str;\n    JSAtom atom;\n    const char *cstr;\n    char *cstr2;\n    size_t len, len1;\n\n    str = JS_AtomToString(ctx, name);\n    if (JS_IsException(str))\n        return JS_ATOM_NULL;\n    cstr = JS_ToCStringLen(ctx, &len, str);\n    if (!cstr)\n        goto fail;\n    len1 = strlen(str1);\n    cstr2 = js_malloc(ctx, len + len1 + 1);\n    if (!cstr2)\n        goto fail;\n    memcpy(cstr2, cstr, len);\n    memcpy(cstr2 + len, str1, len1);\n    cstr2[len + len1] = '\\0';\n    atom = JS_NewAtomLen(ctx, cstr2, len + len1);\n    js_free(ctx, cstr2);\n    JS_FreeCString(ctx, cstr);\n    JS_FreeValue(ctx, str);\n    return atom;\n fail:\n    JS_FreeCString(ctx, cstr);\n    JS_FreeValue(ctx, str);\n    return JS_ATOM_NULL;\n}\n\nstatic JSAtom js_atom_concat_num(JSContext *ctx, JSAtom name, uint32_t n)\n{\n    char buf[16];\n    snprintf(buf, sizeof(buf), \"%u\", n);\n    return js_atom_concat_str(ctx, name, buf);\n}\n\nstatic inline BOOL JS_IsEmptyString(JSValueConst v)\n{\n    return JS_VALUE_GET_TAG(v) == JS_TAG_STRING && JS_VALUE_GET_STRING(v)->len == 0;\n}\n\n/* JSClass support */\n\n#ifdef CONFIG_ATOMICS\nstatic pthread_mutex_t js_class_id_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\n/* a new class ID is allocated if *pclass_id != 0 */\nJSClassID JS_NewClassID(JSClassID *pclass_id)\n{\n    JSClassID class_id;\n#ifdef CONFIG_ATOMICS\n    pthread_mutex_lock(&js_class_id_mutex);\n#endif\n    class_id = *pclass_id;\n    if (class_id == 0) {\n        class_id = js_class_id_alloc++;\n        *pclass_id = class_id;\n    }\n#ifdef CONFIG_ATOMICS\n    pthread_mutex_unlock(&js_class_id_mutex);\n#endif\n    return class_id;\n}\n\nJSClassID JS_GetClassID(JSValue v)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(v) != JS_TAG_OBJECT)\n        return JS_INVALID_CLASS_ID;\n    p = JS_VALUE_GET_OBJ(v);\n    return p->class_id;\n}\n\nBOOL JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id)\n{\n    return (class_id < rt->class_count &&\n            rt->class_array[class_id].class_id != 0);\n}\n\n/* create a new object internal class. Return -1 if error, 0 if\n   OK. The finalizer can be NULL if none is needed. */\nstatic int JS_NewClass1(JSRuntime *rt, JSClassID class_id,\n                        const JSClassDef *class_def, JSAtom name)\n{\n    int new_size, i;\n    JSClass *cl, *new_class_array;\n    struct list_head *el;\n\n    if (class_id >= (1 << 16))\n        return -1;\n    if (class_id < rt->class_count &&\n        rt->class_array[class_id].class_id != 0)\n        return -1;\n\n    if (class_id >= rt->class_count) {\n        new_size = max_int(JS_CLASS_INIT_COUNT,\n                           max_int(class_id + 1, rt->class_count * 3 / 2));\n\n        /* reallocate the context class prototype array, if any */\n        list_for_each(el, &rt->context_list) {\n            JSContext *ctx = list_entry(el, JSContext, link);\n            JSValue *new_tab;\n            new_tab = js_realloc_rt(rt, ctx->class_proto,\n                                    sizeof(ctx->class_proto[0]) * new_size);\n            if (!new_tab)\n                return -1;\n            for(i = rt->class_count; i < new_size; i++)\n                new_tab[i] = JS_NULL;\n            ctx->class_proto = new_tab;\n        }\n        /* reallocate the class array */\n        new_class_array = js_realloc_rt(rt, rt->class_array,\n                                        sizeof(JSClass) * new_size);\n        if (!new_class_array)\n            return -1;\n        memset(new_class_array + rt->class_count, 0,\n               (new_size - rt->class_count) * sizeof(JSClass));\n        rt->class_array = new_class_array;\n        rt->class_count = new_size;\n    }\n    cl = &rt->class_array[class_id];\n    cl->class_id = class_id;\n    cl->class_name = JS_DupAtomRT(rt, name);\n    cl->finalizer = class_def->finalizer;\n    cl->gc_mark = class_def->gc_mark;\n    cl->call = class_def->call;\n    cl->exotic = class_def->exotic;\n    return 0;\n}\n\nint JS_NewClass(JSRuntime *rt, JSClassID class_id, const JSClassDef *class_def)\n{\n    int ret, len;\n    JSAtom name;\n\n    len = strlen(class_def->class_name);\n    name = __JS_FindAtom(rt, class_def->class_name, len, JS_ATOM_TYPE_STRING);\n    if (name == JS_ATOM_NULL) {\n        name = __JS_NewAtomInit(rt, class_def->class_name, len, JS_ATOM_TYPE_STRING);\n        if (name == JS_ATOM_NULL)\n            return -1;\n    }\n    ret = JS_NewClass1(rt, class_id, class_def, name);\n    JS_FreeAtomRT(rt, name);\n    return ret;\n}\n\nstatic JSValue js_new_string8(JSContext *ctx, const uint8_t *buf, int len)\n{\n    JSString *str;\n\n    if (len <= 0) {\n        return JS_AtomToString(ctx, JS_ATOM_empty_string);\n    }\n    str = js_alloc_string(ctx, len, 0);\n    if (!str)\n        return JS_EXCEPTION;\n    memcpy(str->u.str8, buf, len);\n    str->u.str8[len] = '\\0';\n    return JS_MKPTR(JS_TAG_STRING, str);\n}\n\nstatic JSValue js_new_string16(JSContext *ctx, const uint16_t *buf, int len)\n{\n    JSString *str;\n    str = js_alloc_string(ctx, len, 1);\n    if (!str)\n        return JS_EXCEPTION;\n    memcpy(str->u.str16, buf, len * 2);\n    return JS_MKPTR(JS_TAG_STRING, str);\n}\n\nstatic JSValue js_new_string_char(JSContext *ctx, uint16_t c)\n{\n    if (c < 0x100) {\n        uint8_t ch8 = c;\n        return js_new_string8(ctx, &ch8, 1);\n    } else {\n        uint16_t ch16 = c;\n        return js_new_string16(ctx, &ch16, 1);\n    }\n}\n\nstatic JSValue js_sub_string(JSContext *ctx, JSString *p, int start, int end)\n{\n    int len = end - start;\n    if (start == 0 && end == p->len) {\n        return JS_DupValue(ctx, JS_MKPTR(JS_TAG_STRING, p));\n    }\n    if (p->is_wide_char && len > 0) {\n        JSString *str;\n        int i;\n        uint16_t c = 0;\n        for (i = start; i < end; i++) {\n            c |= p->u.str16[i];\n        }\n        if (c > 0xFF)\n            return js_new_string16(ctx, p->u.str16 + start, len);\n\n        str = js_alloc_string(ctx, len, 0);\n        if (!str)\n            return JS_EXCEPTION;\n        for (i = 0; i < len; i++) {\n            str->u.str8[i] = p->u.str16[start + i];\n        }\n        str->u.str8[len] = '\\0';\n        return JS_MKPTR(JS_TAG_STRING, str);\n    } else {\n        return js_new_string8(ctx, p->u.str8 + start, len);\n    }\n}\n\ntypedef struct StringBuffer {\n    JSContext *ctx;\n    JSString *str;\n    int len;\n    int size;\n    int is_wide_char;\n    int error_status;\n} StringBuffer;\n\n/* It is valid to call string_buffer_end() and all string_buffer functions even\n   if string_buffer_init() or another string_buffer function returns an error.\n   If the error_status is set, string_buffer_end() returns JS_EXCEPTION.\n */\nstatic int string_buffer_init2(JSContext *ctx, StringBuffer *s, int size,\n                               int is_wide)\n{\n    s->ctx = ctx;\n    s->size = size;\n    s->len = 0;\n    s->is_wide_char = is_wide;\n    s->error_status = 0;\n    s->str = js_alloc_string(ctx, size, is_wide);\n    if (unlikely(!s->str)) {\n        s->size = 0;\n        return s->error_status = -1;\n    }\n#ifdef DUMP_LEAKS\n    /* the StringBuffer may reallocate the JSString, only link it at the end */\n    list_del(&s->str->link);\n#endif\n    return 0;\n}\n\nstatic inline int string_buffer_init(JSContext *ctx, StringBuffer *s, int size)\n{\n    return string_buffer_init2(ctx, s, size, 0);\n}\n\nstatic void string_buffer_free(StringBuffer *s)\n{\n    js_free(s->ctx, s->str);\n    s->str = NULL;\n}\n\nstatic int string_buffer_set_error(StringBuffer *s)\n{\n    js_free(s->ctx, s->str);\n    s->str = NULL;\n    s->size = 0;\n    s->len = 0;\n    return s->error_status = -1;\n}\n\nstatic no_inline int string_buffer_widen(StringBuffer *s, int size)\n{\n    JSString *str;\n    size_t slack;\n    int i;\n\n    if (s->error_status)\n        return -1;\n\n    str = js_realloc2(s->ctx, s->str, sizeof(JSString) + (size << 1), &slack);\n    if (!str)\n        return string_buffer_set_error(s);\n    size += slack >> 1;\n    for(i = s->len; i-- > 0;) {\n        str->u.str16[i] = str->u.str8[i];\n    }\n    s->is_wide_char = 1;\n    s->size = size;\n    s->str = str;\n    return 0;\n}\n\nstatic no_inline int string_buffer_realloc(StringBuffer *s, int new_len, int c)\n{\n    JSString *new_str;\n    int new_size;\n    size_t new_size_bytes, slack;\n\n    if (s->error_status)\n        return -1;\n\n    if (new_len > JS_STRING_LEN_MAX) {\n        JS_ThrowInternalError(s->ctx, \"string too long\");\n        return string_buffer_set_error(s);\n    }\n    new_size = min_int(max_int(new_len, s->size * 3 / 2), JS_STRING_LEN_MAX);\n    if (!s->is_wide_char && c >= 0x100) {\n        return string_buffer_widen(s, new_size);\n    }\n    new_size_bytes = sizeof(JSString) + (new_size << s->is_wide_char) + 1 - s->is_wide_char;\n    new_str = js_realloc2(s->ctx, s->str, new_size_bytes, &slack);\n    if (!new_str)\n        return string_buffer_set_error(s);\n    new_size = min_int(new_size + (slack >> s->is_wide_char), JS_STRING_LEN_MAX);\n    s->size = new_size;\n    s->str = new_str;\n    return 0;\n}\n\nstatic no_inline int string_buffer_putc_slow(StringBuffer *s, uint32_t c)\n{\n    if (unlikely(s->len >= s->size)) {\n        if (string_buffer_realloc(s, s->len + 1, c))\n            return -1;\n    }\n    if (s->is_wide_char) {\n        s->str->u.str16[s->len++] = c;\n    } else if (c < 0x100) {\n        s->str->u.str8[s->len++] = c;\n    } else {\n        if (string_buffer_widen(s, s->size))\n            return -1;\n        s->str->u.str16[s->len++] = c;\n    }\n    return 0;\n}\n\n/* 0 <= c <= 0xff */\nstatic int string_buffer_putc8(StringBuffer *s, uint32_t c)\n{\n    if (unlikely(s->len >= s->size)) {\n        if (string_buffer_realloc(s, s->len + 1, c))\n            return -1;\n    }\n    if (s->is_wide_char) {\n        s->str->u.str16[s->len++] = c;\n    } else {\n        s->str->u.str8[s->len++] = c;\n    }\n    return 0;\n}\n\n/* 0 <= c <= 0xffff */\nstatic int string_buffer_putc16(StringBuffer *s, uint32_t c)\n{\n    if (likely(s->len < s->size)) {\n        if (s->is_wide_char) {\n            s->str->u.str16[s->len++] = c;\n            return 0;\n        } else if (c < 0x100) {\n            s->str->u.str8[s->len++] = c;\n            return 0;\n        }\n    }\n    return string_buffer_putc_slow(s, c);\n}\n\n/* 0 <= c <= 0x10ffff */\nstatic int string_buffer_putc(StringBuffer *s, uint32_t c)\n{\n    if (unlikely(c >= 0x10000)) {\n        /* surrogate pair */\n        if (string_buffer_putc16(s, get_hi_surrogate(c)))\n            return -1;\n        c = get_lo_surrogate(c);\n    }\n    return string_buffer_putc16(s, c);\n}\n\nstatic int string_getc(const JSString *p, int *pidx)\n{\n    int idx, c, c1;\n    idx = *pidx;\n    if (p->is_wide_char) {\n        c = p->u.str16[idx++];\n        if (is_hi_surrogate(c) && idx < p->len) {\n            c1 = p->u.str16[idx];\n            if (is_lo_surrogate(c1)) {\n                c = from_surrogate(c, c1);\n                idx++;\n            }\n        }\n    } else {\n        c = p->u.str8[idx++];\n    }\n    *pidx = idx;\n    return c;\n}\n\nstatic int string_buffer_write8(StringBuffer *s, const uint8_t *p, int len)\n{\n    int i;\n\n    if (s->len + len > s->size) {\n        if (string_buffer_realloc(s, s->len + len, 0))\n            return -1;\n    }\n    if (s->is_wide_char) {\n        for (i = 0; i < len; i++) {\n            s->str->u.str16[s->len + i] = p[i];\n        }\n        s->len += len;\n    } else {\n        memcpy(&s->str->u.str8[s->len], p, len);\n        s->len += len;\n    }\n    return 0;\n}\n\nstatic int string_buffer_write16(StringBuffer *s, const uint16_t *p, int len)\n{\n    int c = 0, i;\n\n    for (i = 0; i < len; i++) {\n        c |= p[i];\n    }\n    if (s->len + len > s->size) {\n        if (string_buffer_realloc(s, s->len + len, c))\n            return -1;\n    } else if (!s->is_wide_char && c >= 0x100) {\n        if (string_buffer_widen(s, s->size))\n            return -1;\n    }\n    if (s->is_wide_char) {\n        memcpy(&s->str->u.str16[s->len], p, len << 1);\n        s->len += len;\n    } else {\n        for (i = 0; i < len; i++) {\n            s->str->u.str8[s->len + i] = p[i];\n        }\n        s->len += len;\n    }\n    return 0;\n}\n\n/* appending an ASCII string */\nstatic int string_buffer_puts8(StringBuffer *s, const char *str)\n{\n    return string_buffer_write8(s, (const uint8_t *)str, strlen(str));\n}\n\nstatic int string_buffer_concat(StringBuffer *s, const JSString *p,\n                                uint32_t from, uint32_t to)\n{\n    if (to <= from)\n        return 0;\n    if (p->is_wide_char)\n        return string_buffer_write16(s, p->u.str16 + from, to - from);\n    else\n        return string_buffer_write8(s, p->u.str8 + from, to - from);\n}\n\nstatic int string_buffer_concat_value(StringBuffer *s, JSValueConst v)\n{\n    JSString *p;\n    JSValue v1;\n    int res;\n\n    if (s->error_status) {\n        /* prevent exception overload */\n        return -1;\n    }\n    if (unlikely(JS_VALUE_GET_TAG(v) != JS_TAG_STRING)) {\n        v1 = JS_ToString(s->ctx, v);\n        if (JS_IsException(v1))\n            return string_buffer_set_error(s);\n        p = JS_VALUE_GET_STRING(v1);\n        res = string_buffer_concat(s, p, 0, p->len);\n        JS_FreeValue(s->ctx, v1);\n        return res;\n    }\n    p = JS_VALUE_GET_STRING(v);\n    return string_buffer_concat(s, p, 0, p->len);\n}\n\nstatic int string_buffer_concat_value_free(StringBuffer *s, JSValue v)\n{\n    JSString *p;\n    int res;\n\n    if (s->error_status) {\n        /* prevent exception overload */\n        JS_FreeValue(s->ctx, v);\n        return -1;\n    }\n    if (unlikely(JS_VALUE_GET_TAG(v) != JS_TAG_STRING)) {\n        v = JS_ToStringFree(s->ctx, v);\n        if (JS_IsException(v))\n            return string_buffer_set_error(s);\n    }\n    p = JS_VALUE_GET_STRING(v);\n    res = string_buffer_concat(s, p, 0, p->len);\n    JS_FreeValue(s->ctx, v);\n    return res;\n}\n\nstatic int string_buffer_fill(StringBuffer *s, int c, int count)\n{\n    /* XXX: optimize */\n    if (s->len + count > s->size) {\n        if (string_buffer_realloc(s, s->len + count, c))\n            return -1;\n    }\n    while (count-- > 0) {\n        if (string_buffer_putc16(s, c))\n            return -1;\n    }\n    return 0;\n}\n\nstatic JSValue string_buffer_end(StringBuffer *s)\n{\n    JSString *str;\n    str = s->str;\n    if (s->error_status)\n        return JS_EXCEPTION;\n    if (s->len == 0) {\n        js_free(s->ctx, str);\n        s->str = NULL;\n        return JS_AtomToString(s->ctx, JS_ATOM_empty_string);\n    }\n    if (s->len < s->size) {\n        /* smaller size so js_realloc should not fail, but OK if it does */\n        /* XXX: should add some slack to avoid unnecessary calls */\n        /* XXX: might need to use malloc+free to ensure smaller size */\n        str = js_realloc_rt(s->ctx->rt, str, sizeof(JSString) +\n                            (s->len << s->is_wide_char) + 1 - s->is_wide_char);\n        if (str == NULL)\n            str = s->str;\n        s->str = str;\n    }\n    if (!s->is_wide_char)\n        str->u.str8[s->len] = 0;\n#ifdef DUMP_LEAKS\n    list_add_tail(&str->link, &s->ctx->rt->string_list);\n#endif\n    str->is_wide_char = s->is_wide_char;\n    str->len = s->len;\n    s->str = NULL;\n    return JS_MKPTR(JS_TAG_STRING, str);\n}\n\n/* create a string from a UTF-8 buffer */\nJSValue JS_NewStringLen(JSContext *ctx, const char *buf, size_t buf_len)\n{\n    const uint8_t *p, *p_end, *p_start, *p_next;\n    uint32_t c;\n    StringBuffer b_s, *b = &b_s;\n    size_t len1;\n\n    p_start = (const uint8_t *)buf;\n    p_end = p_start + buf_len;\n    p = p_start;\n    while (p < p_end && *p < 128)\n        p++;\n    len1 = p - p_start;\n    if (len1 > JS_STRING_LEN_MAX)\n        return JS_ThrowInternalError(ctx, \"string too long\");\n    if (p == p_end) {\n        /* ASCII string */\n        return js_new_string8(ctx, (const uint8_t *)buf, buf_len);\n    } else {\n        if (string_buffer_init(ctx, b, buf_len))\n            goto fail;\n        string_buffer_write8(b, p_start, len1);\n        while (p < p_end) {\n            if (*p < 128) {\n                string_buffer_putc8(b, *p++);\n            } else {\n                /* parse utf-8 sequence, return 0xFFFFFFFF for error */\n                c = unicode_from_utf8(p, p_end - p, &p_next);\n                if (c < 0x10000) {\n                    p = p_next;\n                } else if (c <= 0x10FFFF) {\n                    p = p_next;\n                    /* surrogate pair */\n                    string_buffer_putc16(b, get_hi_surrogate(c));\n                    c = get_lo_surrogate(c);\n                } else {\n                    /* invalid char */\n                    c = 0xfffd;\n                    /* skip the invalid chars */\n                    /* XXX: seems incorrect. Why not just use c = *p++; ? */\n                    while (p < p_end && (*p >= 0x80 && *p < 0xc0))\n                        p++;\n                    if (p < p_end) {\n                        p++;\n                        while (p < p_end && (*p >= 0x80 && *p < 0xc0))\n                            p++;\n                    }\n                }\n                string_buffer_putc16(b, c);\n            }\n        }\n    }\n    return string_buffer_end(b);\n\n fail:\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ConcatString3(JSContext *ctx, const char *str1,\n                                JSValue str2, const char *str3)\n{\n    StringBuffer b_s, *b = &b_s;\n    int len1, len3;\n    JSString *p;\n\n    if (unlikely(JS_VALUE_GET_TAG(str2) != JS_TAG_STRING)) {\n        str2 = JS_ToStringFree(ctx, str2);\n        if (JS_IsException(str2))\n            goto fail;\n    }\n    p = JS_VALUE_GET_STRING(str2);\n    len1 = strlen(str1);\n    len3 = strlen(str3);\n\n    if (string_buffer_init2(ctx, b, len1 + p->len + len3, p->is_wide_char))\n        goto fail;\n\n    string_buffer_write8(b, (const uint8_t *)str1, len1);\n    string_buffer_concat(b, p, 0, p->len);\n    string_buffer_write8(b, (const uint8_t *)str3, len3);\n\n    JS_FreeValue(ctx, str2);\n    return string_buffer_end(b);\n\n fail:\n    JS_FreeValue(ctx, str2);\n    return JS_EXCEPTION;\n}\n\nJSValue JS_NewString(JSContext *ctx, const char *str)\n{\n    return JS_NewStringLen(ctx, str, strlen(str));\n}\n\nJSValue JS_NewAtomString(JSContext *ctx, const char *str)\n{\n    JSAtom atom = JS_NewAtom(ctx, str);\n    if (atom == JS_ATOM_NULL)\n        return JS_EXCEPTION;\n    JSValue val = JS_AtomToString(ctx, atom);\n    JS_FreeAtom(ctx, atom);\n    return val;\n}\n\n/* return (NULL, 0) if exception. */\n/* return pointer into a JSString with a live ref_count */\n/* cesu8 determines if non-BMP1 codepoints are encoded as 1 or 2 utf-8 sequences */\nconst char *JS_ToCStringLen2(JSContext *ctx, size_t *plen, JSValueConst val1, BOOL cesu8)\n{\n    JSValue val;\n    JSString *str, *str_new;\n    int pos, len, c, c1;\n    uint8_t *q;\n\n    if (JS_VALUE_GET_TAG(val1) != JS_TAG_STRING) {\n        val = JS_ToString(ctx, val1);\n        if (JS_IsException(val))\n            goto fail;\n    } else {\n        val = JS_DupValue(ctx, val1);\n    }\n\n    str = JS_VALUE_GET_STRING(val);\n    len = str->len;\n    if (!str->is_wide_char) {\n        const uint8_t *src = str->u.str8;\n        int count;\n\n        /* count the number of non-ASCII characters */\n        /* Scanning the whole string is required for ASCII strings,\n           and computing the number of non-ASCII bytes is less expensive\n           than testing each byte, hence this method is faster for ASCII\n           strings, which is the most common case.\n         */\n        count = 0;\n        for (pos = 0; pos < len; pos++) {\n            count += src[pos] >> 7;\n        }\n        if (count == 0) {\n            if (plen)\n                *plen = len;\n            return (const char *)src;\n        }\n        str_new = js_alloc_string(ctx, len + count, 0);\n        if (!str_new)\n            goto fail;\n        q = str_new->u.str8;\n        for (pos = 0; pos < len; pos++) {\n            c = src[pos];\n            if (c < 0x80) {\n                *q++ = c;\n            } else {\n                *q++ = (c >> 6) | 0xc0;\n                *q++ = (c & 0x3f) | 0x80;\n            }\n        }\n    } else {\n        const uint16_t *src = str->u.str16;\n        /* Allocate 3 bytes per 16 bit code point. Surrogate pairs may\n           produce 4 bytes but use 2 code points.\n         */\n        str_new = js_alloc_string(ctx, len * 3, 0);\n        if (!str_new)\n            goto fail;\n        q = str_new->u.str8;\n        pos = 0;\n        while (pos < len) {\n            c = src[pos++];\n            if (c < 0x80) {\n                *q++ = c;\n            } else {\n                if (is_hi_surrogate(c)) {\n                    if (pos < len && !cesu8) {\n                        c1 = src[pos];\n                        if (is_lo_surrogate(c1)) {\n                            pos++;\n                            c = from_surrogate(c, c1);\n                        } else {\n                            /* Keep unmatched surrogate code points */\n                            /* c = 0xfffd; */ /* error */\n                        }\n                    } else {\n                        /* Keep unmatched surrogate code points */\n                        /* c = 0xfffd; */ /* error */\n                    }\n                }\n                q += unicode_to_utf8(q, c);\n            }\n        }\n    }\n\n    *q = '\\0';\n    str_new->len = q - str_new->u.str8;\n    JS_FreeValue(ctx, val);\n    if (plen)\n        *plen = str_new->len;\n    return (const char *)str_new->u.str8;\n fail:\n    if (plen)\n        *plen = 0;\n    return NULL;\n}\n\nvoid JS_FreeCString(JSContext *ctx, const char *ptr)\n{\n    JSString *p;\n    if (!ptr)\n        return;\n    /* purposely removing constness */\n    p = container_of(ptr, JSString, u);\n    JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, p));\n}\n\nstatic int memcmp16_8(const uint16_t *src1, const uint8_t *src2, int len)\n{\n    int c, i;\n    for(i = 0; i < len; i++) {\n        c = src1[i] - src2[i];\n        if (c != 0)\n            return c;\n    }\n    return 0;\n}\n\nstatic int memcmp16(const uint16_t *src1, const uint16_t *src2, int len)\n{\n    int c, i;\n    for(i = 0; i < len; i++) {\n        c = src1[i] - src2[i];\n        if (c != 0)\n            return c;\n    }\n    return 0;\n}\n\nstatic int js_string_memcmp(const JSString *p1, const JSString *p2, int len)\n{\n    int res;\n\n    if (likely(!p1->is_wide_char)) {\n        if (likely(!p2->is_wide_char))\n            res = memcmp(p1->u.str8, p2->u.str8, len);\n        else\n            res = -memcmp16_8(p2->u.str16, p1->u.str8, len);\n    } else {\n        if (!p2->is_wide_char)\n            res = memcmp16_8(p1->u.str16, p2->u.str8, len);\n        else\n            res = memcmp16(p1->u.str16, p2->u.str16, len);\n    }\n    return res;\n}\n\n/* return < 0, 0 or > 0 */\nstatic int js_string_compare(JSContext *ctx,\n                             const JSString *p1, const JSString *p2)\n{\n    int res, len;\n    len = min_int(p1->len, p2->len);\n    res = js_string_memcmp(p1, p2, len);\n    if (res == 0) {\n        if (p1->len == p2->len)\n            res = 0;\n        else if (p1->len < p2->len)\n            res = -1;\n        else\n            res = 1;\n    }\n    return res;\n}\n\nstatic void copy_str16(uint16_t *dst, const JSString *p, int offset, int len)\n{\n    if (p->is_wide_char) {\n        memcpy(dst, p->u.str16 + offset, len * 2);\n    } else {\n        const uint8_t *src1 = p->u.str8 + offset;\n        int i;\n\n        for(i = 0; i < len; i++)\n            dst[i] = src1[i];\n    }\n}\n\nstatic JSValue JS_ConcatString1(JSContext *ctx,\n                                const JSString *p1, const JSString *p2)\n{\n    JSString *p;\n    uint32_t len;\n    int is_wide_char;\n\n    len = p1->len + p2->len;\n    if (len > JS_STRING_LEN_MAX)\n        return JS_ThrowInternalError(ctx, \"string too long\");\n    is_wide_char = p1->is_wide_char | p2->is_wide_char;\n    p = js_alloc_string(ctx, len, is_wide_char);\n    if (!p)\n        return JS_EXCEPTION;\n    if (!is_wide_char) {\n        memcpy(p->u.str8, p1->u.str8, p1->len);\n        memcpy(p->u.str8 + p1->len, p2->u.str8, p2->len);\n        p->u.str8[len] = '\\0';\n    } else {\n        copy_str16(p->u.str16, p1, 0, p1->len);\n        copy_str16(p->u.str16 + p1->len, p2, 0, p2->len);\n    }\n    return JS_MKPTR(JS_TAG_STRING, p);\n}\n\nstatic BOOL JS_ConcatStringInPlace(JSContext *ctx, JSString *p1, JSValueConst op2) {\n    if (JS_VALUE_GET_TAG(op2) == JS_TAG_STRING) {\n        JSString *p2 = JS_VALUE_GET_STRING(op2);\n        size_t size1;\n\n        if (p2->len == 0)\n            return TRUE;\n        if (p1->header.ref_count != 1)\n            return FALSE;\n        size1 = js_malloc_usable_size(ctx, p1);\n        if (p1->is_wide_char) {\n            if (size1 >= sizeof(*p1) + ((p1->len + p2->len) << 1)) {\n                if (p2->is_wide_char) {\n                    memcpy(p1->u.str16 + p1->len, p2->u.str16, p2->len << 1);\n                    p1->len += p2->len;\n                    return TRUE;\n                } else {\n                    size_t i;\n                    for (i = 0; i < p2->len; i++) {\n                        p1->u.str16[p1->len++] = p2->u.str8[i];\n                    }\n                    return TRUE;\n                }\n            }\n        } else if (!p2->is_wide_char) {\n            if (size1 >= sizeof(*p1) + p1->len + p2->len + 1) {\n                memcpy(p1->u.str8 + p1->len, p2->u.str8, p2->len);\n                p1->len += p2->len;\n                p1->u.str8[p1->len] = '\\0';\n                return TRUE;\n            }\n        }\n    }\n    return FALSE;\n}\n\n/* op1 and op2 are converted to strings. For convenience, op1 or op2 =\n   JS_EXCEPTION are accepted and return JS_EXCEPTION.  */\nstatic JSValue JS_ConcatString(JSContext *ctx, JSValue op1, JSValue op2)\n{\n    JSValue ret;\n    JSString *p1, *p2;\n\n    if (unlikely(JS_VALUE_GET_TAG(op1) != JS_TAG_STRING)) {\n        op1 = JS_ToStringFree(ctx, op1);\n        if (JS_IsException(op1)) {\n            JS_FreeValue(ctx, op2);\n            return JS_EXCEPTION;\n        }\n    }\n    if (unlikely(JS_VALUE_GET_TAG(op2) != JS_TAG_STRING)) {\n        op2 = JS_ToStringFree(ctx, op2);\n        if (JS_IsException(op2)) {\n            JS_FreeValue(ctx, op1);\n            return JS_EXCEPTION;\n        }\n    }\n    p1 = JS_VALUE_GET_STRING(op1);\n    if (JS_ConcatStringInPlace(ctx, p1, op2)) {\n        JS_FreeValue(ctx, op2);\n        return op1;\n    }\n    p2 = JS_VALUE_GET_STRING(op2);\n    ret = JS_ConcatString1(ctx, p1, p2);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return ret;\n}\n\n/* Shape support */\n\nstatic inline size_t get_shape_size(size_t hash_size, size_t prop_size)\n{\n    return hash_size * sizeof(uint32_t) + sizeof(JSShape) +\n        prop_size * sizeof(JSShapeProperty);\n}\n\nstatic inline JSShape *get_shape_from_alloc(void *sh_alloc, size_t hash_size)\n{\n    return (JSShape *)(void *)((uint32_t *)sh_alloc + hash_size);\n}\n\nstatic inline uint32_t *prop_hash_end(JSShape *sh)\n{\n    return (uint32_t *)sh;\n}\n\nstatic inline void *get_alloc_from_shape(JSShape *sh)\n{\n    return prop_hash_end(sh) - ((intptr_t)sh->prop_hash_mask + 1);\n}\n\nstatic inline JSShapeProperty *get_shape_prop(JSShape *sh)\n{\n    return sh->prop;\n}\n\nstatic int init_shape_hash(JSRuntime *rt)\n{\n    rt->shape_hash_bits = 4;   /* 16 shapes */\n    rt->shape_hash_size = 1 << rt->shape_hash_bits;\n    rt->shape_hash_count = 0;\n    rt->shape_hash = js_mallocz_rt(rt, sizeof(rt->shape_hash[0]) *\n                                   rt->shape_hash_size);\n    if (!rt->shape_hash)\n        return -1;\n    return 0;\n}\n\n/* same magic hash multiplier as the Linux kernel */\nstatic uint32_t shape_hash(uint32_t h, uint32_t val)\n{\n    return (h + val) * 0x9e370001;\n}\n\n/* truncate the shape hash to 'hash_bits' bits */\nstatic uint32_t get_shape_hash(uint32_t h, int hash_bits)\n{\n    return h >> (32 - hash_bits);\n}\n\nstatic uint32_t shape_initial_hash(JSObject *proto)\n{\n    uint32_t h;\n    h = shape_hash(1, (uintptr_t)proto);\n    if (sizeof(proto) > 4)\n        h = shape_hash(h, (uint64_t)(uintptr_t)proto >> 32);\n    return h;\n}\n\nstatic int resize_shape_hash(JSRuntime *rt, int new_shape_hash_bits)\n{\n    int new_shape_hash_size, i;\n    uint32_t h;\n    JSShape **new_shape_hash, *sh, *sh_next;\n\n    new_shape_hash_size = 1 << new_shape_hash_bits;\n    new_shape_hash = js_mallocz_rt(rt, sizeof(rt->shape_hash[0]) *\n                                   new_shape_hash_size);\n    if (!new_shape_hash)\n        return -1;\n    for(i = 0; i < rt->shape_hash_size; i++) {\n        for(sh = rt->shape_hash[i]; sh != NULL; sh = sh_next) {\n            sh_next = sh->shape_hash_next;\n            h = get_shape_hash(sh->hash, new_shape_hash_bits);\n            sh->shape_hash_next = new_shape_hash[h];\n            new_shape_hash[h] = sh;\n        }\n    }\n    js_free_rt(rt, rt->shape_hash);\n    rt->shape_hash_bits = new_shape_hash_bits;\n    rt->shape_hash_size = new_shape_hash_size;\n    rt->shape_hash = new_shape_hash;\n    return 0;\n}\n\nstatic void js_shape_hash_link(JSRuntime *rt, JSShape *sh)\n{\n    uint32_t h;\n    h = get_shape_hash(sh->hash, rt->shape_hash_bits);\n    sh->shape_hash_next = rt->shape_hash[h];\n    rt->shape_hash[h] = sh;\n    rt->shape_hash_count++;\n}\n\nstatic void js_shape_hash_unlink(JSRuntime *rt, JSShape *sh)\n{\n    uint32_t h;\n    JSShape **psh;\n\n    h = get_shape_hash(sh->hash, rt->shape_hash_bits);\n    psh = &rt->shape_hash[h];\n    while (*psh != sh)\n        psh = &(*psh)->shape_hash_next;\n    *psh = sh->shape_hash_next;\n    rt->shape_hash_count--;\n}\n\n/* create a new empty shape with prototype 'proto' */\nstatic no_inline JSShape *js_new_shape2(JSContext *ctx, JSObject *proto,\n                                        int hash_size, int prop_size)\n{\n    JSRuntime *rt = ctx->rt;\n    void *sh_alloc;\n    JSShape *sh;\n\n    /* resize the shape hash table if necessary */\n    if (2 * (rt->shape_hash_count + 1) > rt->shape_hash_size) {\n        resize_shape_hash(rt, rt->shape_hash_bits + 1);\n    }\n\n    sh_alloc = js_malloc(ctx, get_shape_size(hash_size, prop_size));\n    if (!sh_alloc)\n        return NULL;\n    sh = get_shape_from_alloc(sh_alloc, hash_size);\n    sh->header.ref_count = 1;\n    add_gc_object(rt, &sh->header, JS_GC_OBJ_TYPE_SHAPE);\n    if (proto)\n        JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, proto));\n    sh->proto = proto;\n    memset(prop_hash_end(sh) - hash_size, 0, sizeof(prop_hash_end(sh)[0]) *\n           hash_size);\n    sh->prop_hash_mask = hash_size - 1;\n    sh->prop_size = prop_size;\n    sh->prop_count = 0;\n    sh->deleted_prop_count = 0;\n\n    /* insert in the hash table */\n    sh->hash = shape_initial_hash(proto);\n    sh->is_hashed = TRUE;\n    sh->has_small_array_index = FALSE;\n    js_shape_hash_link(ctx->rt, sh);\n    return sh;\n}\n\nstatic JSShape *js_new_shape(JSContext *ctx, JSObject *proto)\n{\n    return js_new_shape2(ctx, proto, JS_PROP_INITIAL_HASH_SIZE,\n                         JS_PROP_INITIAL_SIZE);\n}\n\n/* The shape is cloned. The new shape is not inserted in the shape\n   hash table */\nstatic JSShape *js_clone_shape(JSContext *ctx, JSShape *sh1)\n{\n    JSShape *sh;\n    void *sh_alloc, *sh_alloc1;\n    size_t size;\n    JSShapeProperty *pr;\n    uint32_t i, hash_size;\n\n    hash_size = sh1->prop_hash_mask + 1;\n    size = get_shape_size(hash_size, sh1->prop_size);\n    sh_alloc = js_malloc(ctx, size);\n    if (!sh_alloc)\n        return NULL;\n    sh_alloc1 = get_alloc_from_shape(sh1);\n    memcpy(sh_alloc, sh_alloc1, size);\n    sh = get_shape_from_alloc(sh_alloc, hash_size);\n    sh->header.ref_count = 1;\n    add_gc_object(ctx->rt, &sh->header, JS_GC_OBJ_TYPE_SHAPE);\n    sh->is_hashed = FALSE;\n    if (sh->proto) {\n        JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, sh->proto));\n    }\n    for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {\n        JS_DupAtom(ctx, pr->atom);\n    }\n    return sh;\n}\n\nstatic JSShape *js_dup_shape(JSShape *sh)\n{\n    sh->header.ref_count++;\n    return sh;\n}\n\nstatic void js_free_shape0(JSRuntime *rt, JSShape *sh)\n{\n    uint32_t i;\n    JSShapeProperty *pr;\n\n    assert(sh->header.ref_count == 0);\n    if (sh->is_hashed)\n        js_shape_hash_unlink(rt, sh);\n    if (sh->proto != NULL) {\n        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, sh->proto));\n    }\n    pr = get_shape_prop(sh);\n    for(i = 0; i < sh->prop_count; i++) {\n        JS_FreeAtomRT(rt, pr->atom);\n        pr++;\n    }\n    remove_gc_object(&sh->header);\n    js_free_rt(rt, get_alloc_from_shape(sh));\n}\n\nstatic void js_free_shape(JSRuntime *rt, JSShape *sh)\n{\n    if (unlikely(--sh->header.ref_count <= 0)) {\n        js_free_shape0(rt, sh);\n    }\n}\n\nstatic void js_free_shape_null(JSRuntime *rt, JSShape *sh)\n{\n    if (sh)\n        js_free_shape(rt, sh);\n}\n\n/* make space to hold at least 'count' properties */\nstatic no_inline int resize_properties(JSContext *ctx, JSShape **psh,\n                                       JSObject *p, uint32_t count)\n{\n    JSShape *sh;\n    uint32_t new_size, new_hash_size, new_hash_mask, i;\n    JSShapeProperty *pr;\n    void *sh_alloc;\n    intptr_t h;\n    JSShape *old_sh;\n\n    sh = *psh;\n    new_size = max_int(count, sh->prop_size * 3 / 2);\n    /* Reallocate prop array first to avoid crash or size inconsistency\n       in case of memory allocation failure */\n    if (p) {\n        JSProperty *new_prop;\n        new_prop = js_realloc(ctx, p->prop, sizeof(new_prop[0]) * new_size);\n        if (unlikely(!new_prop))\n            return -1;\n        p->prop = new_prop;\n    }\n    new_hash_size = sh->prop_hash_mask + 1;\n    while (new_hash_size < new_size)\n        new_hash_size = 2 * new_hash_size;\n    /* resize the property shapes. Using js_realloc() is not possible in\n       case the GC runs during the allocation */\n    old_sh = sh;\n    sh_alloc = js_malloc(ctx, get_shape_size(new_hash_size, new_size));\n    if (!sh_alloc)\n        return -1;\n    sh = get_shape_from_alloc(sh_alloc, new_hash_size);\n    list_del(&old_sh->header.link);\n    /* copy all the shape properties */\n    memcpy(sh, old_sh,\n           sizeof(JSShape) + sizeof(sh->prop[0]) * old_sh->prop_count);\n    list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);\n\n    if (new_hash_size != (sh->prop_hash_mask + 1)) {\n        /* resize the hash table and the properties */\n        new_hash_mask = new_hash_size - 1;\n        sh->prop_hash_mask = new_hash_mask;\n        memset(prop_hash_end(sh) - new_hash_size, 0,\n               sizeof(prop_hash_end(sh)[0]) * new_hash_size);\n        for(i = 0, pr = sh->prop; i < sh->prop_count; i++, pr++) {\n            if (pr->atom != JS_ATOM_NULL) {\n                h = ((uintptr_t)pr->atom & new_hash_mask);\n                pr->hash_next = prop_hash_end(sh)[-h - 1];\n                prop_hash_end(sh)[-h - 1] = i + 1;\n            }\n        }\n    } else {\n        /* just copy the previous hash table */\n        memcpy(prop_hash_end(sh) - new_hash_size, prop_hash_end(old_sh) - new_hash_size,\n               sizeof(prop_hash_end(sh)[0]) * new_hash_size);\n    }\n    js_free(ctx, get_alloc_from_shape(old_sh));\n    *psh = sh;\n    sh->prop_size = new_size;\n    return 0;\n}\n\n/* remove the deleted properties. */\nstatic int compact_properties(JSContext *ctx, JSObject *p)\n{\n    JSShape *sh, *old_sh;\n    void *sh_alloc;\n    intptr_t h;\n    uint32_t new_hash_size, i, j, new_hash_mask, new_size;\n    JSShapeProperty *old_pr, *pr;\n    JSProperty *prop, *new_prop;\n\n    sh = p->shape;\n    assert(!sh->is_hashed);\n\n    new_size = max_int(JS_PROP_INITIAL_SIZE,\n                       sh->prop_count - sh->deleted_prop_count);\n    assert(new_size <= sh->prop_size);\n\n    new_hash_size = sh->prop_hash_mask + 1;\n    while ((new_hash_size / 2) >= new_size)\n        new_hash_size = new_hash_size / 2;\n    new_hash_mask = new_hash_size - 1;\n\n    /* resize the hash table and the properties */\n    old_sh = sh;\n    sh_alloc = js_malloc(ctx, get_shape_size(new_hash_size, new_size));\n    if (!sh_alloc)\n        return -1;\n    sh = get_shape_from_alloc(sh_alloc, new_hash_size);\n    list_del(&old_sh->header.link);\n    memcpy(sh, old_sh, sizeof(JSShape));\n    list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);\n\n    memset(prop_hash_end(sh) - new_hash_size, 0,\n           sizeof(prop_hash_end(sh)[0]) * new_hash_size);\n\n    j = 0;\n    old_pr = old_sh->prop;\n    pr = sh->prop;\n    prop = p->prop;\n    for(i = 0; i < sh->prop_count; i++) {\n        if (old_pr->atom != JS_ATOM_NULL) {\n            pr->atom = old_pr->atom;\n            pr->flags = old_pr->flags;\n            h = ((uintptr_t)old_pr->atom & new_hash_mask);\n            pr->hash_next = prop_hash_end(sh)[-h - 1];\n            prop_hash_end(sh)[-h - 1] = j + 1;\n            prop[j] = prop[i];\n            j++;\n            pr++;\n        }\n        old_pr++;\n    }\n    assert(j == (sh->prop_count - sh->deleted_prop_count));\n    sh->prop_hash_mask = new_hash_mask;\n    sh->prop_size = new_size;\n    sh->deleted_prop_count = 0;\n    sh->prop_count = j;\n\n    p->shape = sh;\n    js_free(ctx, get_alloc_from_shape(old_sh));\n\n    /* reduce the size of the object properties */\n    new_prop = js_realloc(ctx, p->prop, sizeof(new_prop[0]) * new_size);\n    if (new_prop)\n        p->prop = new_prop;\n    return 0;\n}\n\nstatic int add_shape_property(JSContext *ctx, JSShape **psh,\n                              JSObject *p, JSAtom atom, int prop_flags)\n{\n    JSRuntime *rt = ctx->rt;\n    JSShape *sh = *psh;\n    JSShapeProperty *pr, *prop;\n    uint32_t hash_mask, new_shape_hash = 0;\n    intptr_t h;\n\n    /* update the shape hash */\n    if (sh->is_hashed) {\n        js_shape_hash_unlink(rt, sh);\n        new_shape_hash = shape_hash(shape_hash(sh->hash, atom), prop_flags);\n    }\n\n    if (unlikely(sh->prop_count >= sh->prop_size)) {\n        if (resize_properties(ctx, psh, p, sh->prop_count + 1)) {\n            /* in case of error, reinsert in the hash table.\n               sh is still valid if resize_properties() failed */\n            if (sh->is_hashed)\n                js_shape_hash_link(rt, sh);\n            return -1;\n        }\n        sh = *psh;\n    }\n    if (sh->is_hashed) {\n        sh->hash = new_shape_hash;\n        js_shape_hash_link(rt, sh);\n    }\n    /* Initialize the new shape property.\n       The object property at p->prop[sh->prop_count] is uninitialized */\n    prop = get_shape_prop(sh);\n    pr = &prop[sh->prop_count++];\n    pr->atom = JS_DupAtom(ctx, atom);\n    pr->flags = prop_flags;\n    sh->has_small_array_index |= __JS_AtomIsTaggedInt(atom);\n    /* add in hash table */\n    hash_mask = sh->prop_hash_mask;\n    h = atom & hash_mask;\n    pr->hash_next = prop_hash_end(sh)[-h - 1];\n    prop_hash_end(sh)[-h - 1] = sh->prop_count;\n    return 0;\n}\n\n/* find a hashed empty shape matching the prototype. Return NULL if\n   not found */\nstatic JSShape *find_hashed_shape_proto(JSRuntime *rt, JSObject *proto)\n{\n    JSShape *sh1;\n    uint32_t h, h1;\n\n    h = shape_initial_hash(proto);\n    h1 = get_shape_hash(h, rt->shape_hash_bits);\n    for(sh1 = rt->shape_hash[h1]; sh1 != NULL; sh1 = sh1->shape_hash_next) {\n        if (sh1->hash == h &&\n            sh1->proto == proto &&\n            sh1->prop_count == 0) {\n            return sh1;\n        }\n    }\n    return NULL;\n}\n\n/* find a hashed shape matching sh + (prop, prop_flags). Return NULL if\n   not found */\nstatic JSShape *find_hashed_shape_prop(JSRuntime *rt, JSShape *sh,\n                                       JSAtom atom, int prop_flags)\n{\n    JSShape *sh1;\n    uint32_t h, h1, i, n;\n\n    h = sh->hash;\n    h = shape_hash(h, atom);\n    h = shape_hash(h, prop_flags);\n    h1 = get_shape_hash(h, rt->shape_hash_bits);\n    for(sh1 = rt->shape_hash[h1]; sh1 != NULL; sh1 = sh1->shape_hash_next) {\n        /* we test the hash first so that the rest is done only if the\n           shapes really match */\n        if (sh1->hash == h &&\n            sh1->proto == sh->proto &&\n            sh1->prop_count == ((n = sh->prop_count) + 1)) {\n            for(i = 0; i < n; i++) {\n                if (unlikely(sh1->prop[i].atom != sh->prop[i].atom) ||\n                    unlikely(sh1->prop[i].flags != sh->prop[i].flags))\n                    goto next;\n            }\n            if (unlikely(sh1->prop[n].atom != atom) ||\n                unlikely(sh1->prop[n].flags != prop_flags))\n                goto next;\n            return sh1;\n        }\n    next: ;\n    }\n    return NULL;\n}\n\nstatic __maybe_unused void JS_DumpShape(JSRuntime *rt, int i, JSShape *sh)\n{\n    char atom_buf[ATOM_GET_STR_BUF_SIZE];\n    int j;\n\n    /* XXX: should output readable class prototype */\n    printf(\"%5d %3d%c %14p %5d %5d\", i,\n           sh->header.ref_count, \" *\"[sh->is_hashed],\n           (void *)sh->proto, sh->prop_size, sh->prop_count);\n    for(j = 0; j < sh->prop_count; j++) {\n        printf(\" %s\", JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf),\n                                      sh->prop[j].atom));\n    }\n    printf(\"\\n\");\n}\n\nstatic __maybe_unused void JS_DumpShapes(JSRuntime *rt)\n{\n    int i;\n    JSShape *sh;\n    struct list_head *el;\n    JSObject *p;\n    JSGCObjectHeader *gp;\n\n    printf(\"JSShapes: {\\n\");\n    printf(\"%5s %4s %14s %5s %5s %s\\n\", \"SLOT\", \"REFS\", \"PROTO\", \"SIZE\", \"COUNT\", \"PROPS\");\n    for(i = 0; i < rt->shape_hash_size; i++) {\n        for(sh = rt->shape_hash[i]; sh != NULL; sh = sh->shape_hash_next) {\n            JS_DumpShape(rt, i, sh);\n            assert(sh->is_hashed);\n        }\n    }\n    /* dump non-hashed shapes */\n    list_for_each(el, &rt->gc_obj_list) {\n        gp = list_entry(el, JSGCObjectHeader, link);\n        if (gp->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {\n            p = (JSObject *)gp;\n            if (!p->shape->is_hashed) {\n                JS_DumpShape(rt, -1, p->shape);\n            }\n        }\n    }\n    printf(\"}\\n\");\n}\n\nstatic JSValue JS_NewObjectFromShape(JSContext *ctx, JSShape *sh, JSClassID class_id)\n{\n    JSObject *p;\n\n    js_trigger_gc(ctx->rt, sizeof(JSObject));\n    p = js_malloc(ctx, sizeof(JSObject));\n    if (unlikely(!p))\n        goto fail;\n    p->class_id = class_id;\n    p->extensible = TRUE;\n    p->free_mark = 0;\n    p->is_exotic = 0;\n    p->fast_array = 0;\n    p->is_constructor = 0;\n    p->is_uncatchable_error = 0;\n    p->tmp_mark = 0;\n    p->is_HTMLDDA = 0;\n    p->first_weak_ref = NULL;\n    p->u.opaque = NULL;\n    p->shape = sh;\n    p->prop = js_malloc(ctx, sizeof(JSProperty) * sh->prop_size);\n    if (unlikely(!p->prop)) {\n        js_free(ctx, p);\n    fail:\n        js_free_shape(ctx->rt, sh);\n        return JS_EXCEPTION;\n    }\n\n    switch(class_id) {\n    case JS_CLASS_OBJECT:\n        break;\n    case JS_CLASS_ARRAY:\n        {\n            JSProperty *pr;\n            p->is_exotic = 1;\n            p->fast_array = 1;\n            p->u.array.u.values = NULL;\n            p->u.array.count = 0;\n            p->u.array.u1.size = 0;\n            /* the length property is always the first one */\n            if (likely(sh == ctx->array_shape)) {\n                pr = &p->prop[0];\n            } else {\n                /* only used for the first array */\n                /* cannot fail */\n                pr = add_property(ctx, p, JS_ATOM_length,\n                                  JS_PROP_WRITABLE | JS_PROP_LENGTH);\n            }\n            pr->u.value = JS_NewInt32(ctx, 0);\n        }\n        break;\n    case JS_CLASS_C_FUNCTION:\n        p->prop[0].u.value = JS_UNDEFINED;\n        break;\n    case JS_CLASS_ARGUMENTS:\n    case JS_CLASS_UINT8C_ARRAY:\n    case JS_CLASS_INT8_ARRAY:\n    case JS_CLASS_UINT8_ARRAY:\n    case JS_CLASS_INT16_ARRAY:\n    case JS_CLASS_UINT16_ARRAY:\n    case JS_CLASS_INT32_ARRAY:\n    case JS_CLASS_UINT32_ARRAY:\n    case JS_CLASS_BIG_INT64_ARRAY:\n    case JS_CLASS_BIG_UINT64_ARRAY:\n    case JS_CLASS_FLOAT32_ARRAY:\n    case JS_CLASS_FLOAT64_ARRAY:\n        p->is_exotic = 1;\n        p->fast_array = 1;\n        p->u.array.u.ptr = NULL;\n        p->u.array.count = 0;\n        break;\n    case JS_CLASS_DATAVIEW:\n        p->u.array.u.ptr = NULL;\n        p->u.array.count = 0;\n        break;\n    case JS_CLASS_NUMBER:\n    case JS_CLASS_STRING:\n    case JS_CLASS_BOOLEAN:\n    case JS_CLASS_SYMBOL:\n    case JS_CLASS_DATE:\n    case JS_CLASS_BIG_INT:\n#ifdef CONFIG_BIGNUM\n    case JS_CLASS_BIG_FLOAT:\n    case JS_CLASS_BIG_DECIMAL:\n#endif\n        p->u.object_data = JS_UNDEFINED;\n        goto set_exotic;\n    case JS_CLASS_REGEXP:\n        p->u.regexp.pattern = NULL;\n        p->u.regexp.bytecode = NULL;\n        goto set_exotic;\n    default:\n    set_exotic:\n        if (ctx->rt->class_array[class_id].exotic) {\n            p->is_exotic = 1;\n        }\n        break;\n    }\n    p->header.ref_count = 1;\n    add_gc_object(ctx->rt, &p->header, JS_GC_OBJ_TYPE_JS_OBJECT);\n    return JS_MKPTR(JS_TAG_OBJECT, p);\n}\n\nstatic JSObject *get_proto_obj(JSValueConst proto_val)\n{\n    if (JS_VALUE_GET_TAG(proto_val) != JS_TAG_OBJECT)\n        return NULL;\n    else\n        return JS_VALUE_GET_OBJ(proto_val);\n}\n\n/* WARNING: proto must be an object or JS_NULL */\nJSValue JS_NewObjectProtoClass(JSContext *ctx, JSValueConst proto_val,\n                               JSClassID class_id)\n{\n    JSShape *sh;\n    JSObject *proto;\n\n    proto = get_proto_obj(proto_val);\n    sh = find_hashed_shape_proto(ctx->rt, proto);\n    if (likely(sh)) {\n        sh = js_dup_shape(sh);\n    } else {\n        sh = js_new_shape(ctx, proto);\n        if (!sh)\n            return JS_EXCEPTION;\n    }\n    return JS_NewObjectFromShape(ctx, sh, class_id);\n}\n\n#if 0\nstatic JSValue JS_GetObjectData(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        p = JS_VALUE_GET_OBJ(obj);\n        switch(p->class_id) {\n        case JS_CLASS_NUMBER:\n        case JS_CLASS_STRING:\n        case JS_CLASS_BOOLEAN:\n        case JS_CLASS_SYMBOL:\n        case JS_CLASS_DATE:\n        case JS_CLASS_BIG_INT:\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_BIG_FLOAT:\n        case JS_CLASS_BIG_DECIMAL:\n#endif\n            return JS_DupValue(ctx, p->u.object_data);\n        }\n    }\n    return JS_UNDEFINED;\n}\n#endif\n\nstatic int JS_SetObjectData(JSContext *ctx, JSValueConst obj, JSValue val)\n{\n    JSObject *p;\n\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        p = JS_VALUE_GET_OBJ(obj);\n        switch(p->class_id) {\n        case JS_CLASS_NUMBER:\n        case JS_CLASS_STRING:\n        case JS_CLASS_BOOLEAN:\n        case JS_CLASS_SYMBOL:\n        case JS_CLASS_DATE:\n        case JS_CLASS_BIG_INT:\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_BIG_FLOAT:\n        case JS_CLASS_BIG_DECIMAL:\n#endif\n            JS_FreeValue(ctx, p->u.object_data);\n            p->u.object_data = val;\n            return 0;\n        }\n    }\n    JS_FreeValue(ctx, val);\n    if (!JS_IsException(obj))\n        JS_ThrowTypeError(ctx, \"invalid object type\");\n    return -1;\n}\n\nJSValue JS_NewObjectClass(JSContext *ctx, int class_id)\n{\n    return JS_NewObjectProtoClass(ctx, ctx->class_proto[class_id], class_id);\n}\n\nJSValue JS_NewObjectProto(JSContext *ctx, JSValueConst proto)\n{\n    return JS_NewObjectProtoClass(ctx, proto, JS_CLASS_OBJECT);\n}\n\nJSValue JS_NewArray(JSContext *ctx)\n{\n    return JS_NewObjectFromShape(ctx, js_dup_shape(ctx->array_shape),\n                                 JS_CLASS_ARRAY);\n}\n\nJSValue JS_NewObject(JSContext *ctx)\n{\n    /* inline JS_NewObjectClass(ctx, JS_CLASS_OBJECT); */\n    return JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT], JS_CLASS_OBJECT);\n}\n\nstatic void js_function_set_properties(JSContext *ctx, JSValueConst func_obj,\n                                       JSAtom name, int len)\n{\n    /* ES6 feature non compatible with ES5.1: length is configurable */\n    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_length, JS_NewInt32(ctx, len),\n                           JS_PROP_CONFIGURABLE);\n    JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_name,\n                           JS_AtomToString(ctx, name), JS_PROP_CONFIGURABLE);\n}\n\nstatic BOOL js_class_has_bytecode(JSClassID class_id)\n{\n    return (class_id == JS_CLASS_BYTECODE_FUNCTION ||\n            class_id == JS_CLASS_GENERATOR_FUNCTION ||\n            class_id == JS_CLASS_ASYNC_FUNCTION ||\n            class_id == JS_CLASS_ASYNC_GENERATOR_FUNCTION);\n}\n\n/* return NULL without exception if not a function or no bytecode */\nstatic JSFunctionBytecode *JS_GetFunctionBytecode(JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return NULL;\n    p = JS_VALUE_GET_OBJ(val);\n    if (!js_class_has_bytecode(p->class_id))\n        return NULL;\n    return p->u.func.function_bytecode;\n}\n\nstatic void js_method_set_home_object(JSContext *ctx, JSValueConst func_obj,\n                                      JSValueConst home_obj)\n{\n    JSObject *p, *p1;\n    JSFunctionBytecode *b;\n\n    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)\n        return;\n    p = JS_VALUE_GET_OBJ(func_obj);\n    if (!js_class_has_bytecode(p->class_id))\n        return;\n    b = p->u.func.function_bytecode;\n    if (b->need_home_object) {\n        p1 = p->u.func.home_object;\n        if (p1) {\n            JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));\n        }\n        if (JS_VALUE_GET_TAG(home_obj) == JS_TAG_OBJECT)\n            p1 = JS_VALUE_GET_OBJ(JS_DupValue(ctx, home_obj));\n        else\n            p1 = NULL;\n        p->u.func.home_object = p1;\n    }\n}\n\nstatic JSValue js_get_function_name(JSContext *ctx, JSAtom name)\n{\n    JSValue name_str;\n\n    name_str = JS_AtomToString(ctx, name);\n    if (JS_AtomSymbolHasDescription(ctx, name)) {\n        name_str = JS_ConcatString3(ctx, \"[\", name_str, \"]\");\n    }\n    return name_str;\n}\n\n/* Modify the name of a method according to the atom and\n   'flags'. 'flags' is a bitmask of JS_PROP_HAS_GET and\n   JS_PROP_HAS_SET. Also set the home object of the method.\n   Return < 0 if exception. */\nstatic int js_method_set_properties(JSContext *ctx, JSValueConst func_obj,\n                                    JSAtom name, int flags, JSValueConst home_obj)\n{\n    JSValue name_str;\n\n    name_str = js_get_function_name(ctx, name);\n    if (flags & JS_PROP_HAS_GET) {\n        name_str = JS_ConcatString3(ctx, \"get \", name_str, \"\");\n    } else if (flags & JS_PROP_HAS_SET) {\n        name_str = JS_ConcatString3(ctx, \"set \", name_str, \"\");\n    }\n    if (JS_IsException(name_str))\n        return -1;\n    if (JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_name, name_str,\n                               JS_PROP_CONFIGURABLE) < 0)\n        return -1;\n    js_method_set_home_object(ctx, func_obj, home_obj);\n    return 0;\n}\n\n/* Note: at least 'length' arguments will be readable in 'argv' */\nstatic JSValue JS_NewCFunction3(JSContext *ctx, JSCFunction *func,\n                                const char *name,\n                                int length, JSCFunctionEnum cproto, int magic,\n                                JSValueConst proto_val)\n{\n    JSValue func_obj;\n    JSObject *p;\n    JSAtom name_atom;\n\n    func_obj = JS_NewObjectProtoClass(ctx, proto_val, JS_CLASS_C_FUNCTION);\n    if (JS_IsException(func_obj))\n        return func_obj;\n    p = JS_VALUE_GET_OBJ(func_obj);\n    p->u.cfunc.realm = JS_DupContext(ctx);\n    p->u.cfunc.c_function.generic = func;\n    p->u.cfunc.length = length;\n    p->u.cfunc.cproto = cproto;\n    p->u.cfunc.magic = magic;\n    p->is_constructor = (cproto == JS_CFUNC_constructor ||\n                         cproto == JS_CFUNC_constructor_magic ||\n                         cproto == JS_CFUNC_constructor_or_func ||\n                         cproto == JS_CFUNC_constructor_or_func_magic);\n    if (!name)\n        name = \"\";\n    name_atom = JS_NewAtom(ctx, name);\n    js_function_set_properties(ctx, func_obj, name_atom, length);\n    JS_FreeAtom(ctx, name_atom);\n    return func_obj;\n}\n\n/* Note: at least 'length' arguments will be readable in 'argv' */\nJSValue JS_NewCFunction2(JSContext *ctx, JSCFunction *func,\n                         const char *name,\n                         int length, JSCFunctionEnum cproto, int magic)\n{\n    return JS_NewCFunction3(ctx, func, name, length, cproto, magic,\n                            ctx->function_proto);\n}\n\ntypedef struct JSCFunctionDataRecord {\n    JSCFunctionData *func;\n    uint8_t length;\n    uint8_t data_len;\n    uint16_t magic;\n    JSValue data[0];\n} JSCFunctionDataRecord;\n\nstatic void js_c_function_data_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSCFunctionDataRecord *s = JS_GetOpaque(val, JS_CLASS_C_FUNCTION_DATA);\n    int i;\n\n    if (s) {\n        for(i = 0; i < s->data_len; i++) {\n            JS_FreeValueRT(rt, s->data[i]);\n        }\n        js_free_rt(rt, s);\n    }\n}\n\nstatic void js_c_function_data_mark(JSRuntime *rt, JSValueConst val,\n                                    JS_MarkFunc *mark_func)\n{\n    JSCFunctionDataRecord *s = JS_GetOpaque(val, JS_CLASS_C_FUNCTION_DATA);\n    int i;\n\n    if (s) {\n        for(i = 0; i < s->data_len; i++) {\n            JS_MarkValue(rt, s->data[i], mark_func);\n        }\n    }\n}\n\nstatic JSValue js_c_function_data_call(JSContext *ctx, JSValueConst func_obj,\n                                       JSValueConst this_val,\n                                       int argc, JSValueConst *argv, int flags)\n{\n    JSCFunctionDataRecord *s = JS_GetOpaque(func_obj, JS_CLASS_C_FUNCTION_DATA);\n    JSValueConst *arg_buf;\n    int i;\n\n    /* XXX: could add the function on the stack for debug */\n    if (unlikely(argc < s->length)) {\n        arg_buf = alloca(sizeof(arg_buf[0]) * s->length);\n        for(i = 0; i < argc; i++)\n            arg_buf[i] = argv[i];\n        for(i = argc; i < s->length; i++)\n            arg_buf[i] = JS_UNDEFINED;\n    } else {\n        arg_buf = argv;\n    }\n\n    return s->func(ctx, this_val, argc, arg_buf, s->magic, s->data);\n}\n\nJSValue JS_NewCFunctionData(JSContext *ctx, JSCFunctionData *func,\n                            int length, int magic, int data_len,\n                            JSValueConst *data)\n{\n    JSCFunctionDataRecord *s;\n    JSValue func_obj;\n    int i;\n\n    func_obj = JS_NewObjectProtoClass(ctx, ctx->function_proto,\n                                      JS_CLASS_C_FUNCTION_DATA);\n    if (JS_IsException(func_obj))\n        return func_obj;\n    s = js_malloc(ctx, sizeof(*s) + data_len * sizeof(JSValue));\n    if (!s) {\n        JS_FreeValue(ctx, func_obj);\n        return JS_EXCEPTION;\n    }\n    s->func = func;\n    s->length = length;\n    s->data_len = data_len;\n    s->magic = magic;\n    for(i = 0; i < data_len; i++)\n        s->data[i] = JS_DupValue(ctx, data[i]);\n    JS_SetOpaque(func_obj, s);\n    js_function_set_properties(ctx, func_obj,\n                               JS_ATOM_empty_string, length);\n    return func_obj;\n}\n\nstatic JSContext *js_autoinit_get_realm(JSProperty *pr)\n{\n    return (JSContext *)(pr->u.init.realm_and_id & ~3);\n}\n\nstatic JSAutoInitIDEnum js_autoinit_get_id(JSProperty *pr)\n{\n    return pr->u.init.realm_and_id & 3;\n}\n\nstatic void js_autoinit_free(JSRuntime *rt, JSProperty *pr)\n{\n    JS_FreeContext(js_autoinit_get_realm(pr));\n}\n\nstatic void js_autoinit_mark(JSRuntime *rt, JSProperty *pr,\n                             JS_MarkFunc *mark_func)\n{\n    mark_func(rt, &js_autoinit_get_realm(pr)->header);\n}\n\nstatic void free_property(JSRuntime *rt, JSProperty *pr, int prop_flags)\n{\n    if (unlikely(prop_flags & JS_PROP_TMASK)) {\n        if ((prop_flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n            if (pr->u.getset.getter)\n                JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));\n            if (pr->u.getset.setter)\n                JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));\n        } else if ((prop_flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n            free_var_ref(rt, pr->u.var_ref);\n        } else if ((prop_flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n            js_autoinit_free(rt, pr);\n        }\n    } else {\n        JS_FreeValueRT(rt, pr->u.value);\n    }\n}\n\nstatic force_inline JSShapeProperty *find_own_property1(JSObject *p,\n                                                        JSAtom atom)\n{\n    JSShape *sh;\n    JSShapeProperty *pr, *prop;\n    intptr_t h;\n    sh = p->shape;\n    h = (uintptr_t)atom & sh->prop_hash_mask;\n    h = prop_hash_end(sh)[-h - 1];\n    prop = get_shape_prop(sh);\n    while (h) {\n        pr = &prop[h - 1];\n        if (likely(pr->atom == atom)) {\n            return pr;\n        }\n        h = pr->hash_next;\n    }\n    return NULL;\n}\n\nstatic force_inline JSShapeProperty *find_own_property(JSProperty **ppr,\n                                                       JSObject *p,\n                                                       JSAtom atom)\n{\n    JSShape *sh;\n    JSShapeProperty *pr, *prop;\n    intptr_t h;\n    sh = p->shape;\n    h = (uintptr_t)atom & sh->prop_hash_mask;\n    h = prop_hash_end(sh)[-h - 1];\n    prop = get_shape_prop(sh);\n    while (h) {\n        pr = &prop[h - 1];\n        if (likely(pr->atom == atom)) {\n            *ppr = &p->prop[h - 1];\n            /* the compiler should be able to assume that pr != NULL here */\n            return pr;\n        }\n        h = pr->hash_next;\n    }\n    *ppr = NULL;\n    return NULL;\n}\n\n/* indicate that the object may be part of a function prototype cycle */\nstatic void set_cycle_flag(JSContext *ctx, JSValueConst obj)\n{\n}\n\nstatic void free_var_ref(JSRuntime *rt, JSVarRef *var_ref)\n{\n    if (var_ref) {\n        assert(var_ref->header.ref_count > 0);\n        if (--var_ref->header.ref_count == 0) {\n            if (var_ref->is_detached) {\n                JS_FreeValueRT(rt, var_ref->value);\n            } else {\n                list_del(&var_ref->var_ref_link); /* still on the stack */\n                if (var_ref->async_func)\n                    async_func_free(rt, var_ref->async_func);\n            }\n            remove_gc_object(&var_ref->header);\n            js_free_rt(rt, var_ref);\n        }\n    }\n}\n\nstatic void js_array_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    int i;\n\n    for(i = 0; i < p->u.array.count; i++) {\n        JS_FreeValueRT(rt, p->u.array.u.values[i]);\n    }\n    js_free_rt(rt, p->u.array.u.values);\n}\n\nstatic void js_array_mark(JSRuntime *rt, JSValueConst val,\n                          JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    int i;\n\n    for(i = 0; i < p->u.array.count; i++) {\n        JS_MarkValue(rt, p->u.array.u.values[i], mark_func);\n    }\n}\n\nstatic void js_object_data_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JS_FreeValueRT(rt, p->u.object_data);\n    p->u.object_data = JS_UNDEFINED;\n}\n\nstatic void js_object_data_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JS_MarkValue(rt, p->u.object_data, mark_func);\n}\n\nstatic void js_c_function_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n\n    if (p->u.cfunc.realm)\n        JS_FreeContext(p->u.cfunc.realm);\n}\n\nstatic void js_c_function_mark(JSRuntime *rt, JSValueConst val,\n                               JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n\n    if (p->u.cfunc.realm)\n        mark_func(rt, &p->u.cfunc.realm->header);\n}\n\nstatic void js_bytecode_function_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p1, *p = JS_VALUE_GET_OBJ(val);\n    JSFunctionBytecode *b;\n    JSVarRef **var_refs;\n    int i;\n\n    p1 = p->u.func.home_object;\n    if (p1) {\n        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, p1));\n    }\n    b = p->u.func.function_bytecode;\n    if (b) {\n        var_refs = p->u.func.var_refs;\n        if (var_refs) {\n            for(i = 0; i < b->closure_var_count; i++)\n                free_var_ref(rt, var_refs[i]);\n            js_free_rt(rt, var_refs);\n        }\n        JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b));\n    }\n}\n\nstatic void js_bytecode_function_mark(JSRuntime *rt, JSValueConst val,\n                                      JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSVarRef **var_refs = p->u.func.var_refs;\n    JSFunctionBytecode *b = p->u.func.function_bytecode;\n    int i;\n\n    if (p->u.func.home_object) {\n        JS_MarkValue(rt, JS_MKPTR(JS_TAG_OBJECT, p->u.func.home_object),\n                     mark_func);\n    }\n    if (b) {\n        if (var_refs) {\n            for(i = 0; i < b->closure_var_count; i++) {\n                JSVarRef *var_ref = var_refs[i];\n                if (var_ref) {\n                    mark_func(rt, &var_ref->header);\n                }\n            }\n        }\n        /* must mark the function bytecode because template objects may be\n           part of a cycle */\n        JS_MarkValue(rt, JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b), mark_func);\n    }\n}\n\nstatic void js_bound_function_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSBoundFunction *bf = p->u.bound_function;\n    int i;\n\n    JS_FreeValueRT(rt, bf->func_obj);\n    JS_FreeValueRT(rt, bf->this_val);\n    for(i = 0; i < bf->argc; i++) {\n        JS_FreeValueRT(rt, bf->argv[i]);\n    }\n    js_free_rt(rt, bf);\n}\n\nstatic void js_bound_function_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSBoundFunction *bf = p->u.bound_function;\n    int i;\n\n    JS_MarkValue(rt, bf->func_obj, mark_func);\n    JS_MarkValue(rt, bf->this_val, mark_func);\n    for(i = 0; i < bf->argc; i++)\n        JS_MarkValue(rt, bf->argv[i], mark_func);\n}\n\nstatic void js_for_in_iterator_finalizer(JSRuntime *rt, JSValue val)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSForInIterator *it = p->u.for_in_iterator;\n    int i;\n\n    JS_FreeValueRT(rt, it->obj);\n    if (!it->is_array) {\n        for(i = 0; i < it->atom_count; i++) {\n            JS_FreeAtomRT(rt, it->tab_atom[i].atom);\n        }\n        js_free_rt(rt, it->tab_atom);\n    }\n    js_free_rt(rt, it);\n}\n\nstatic void js_for_in_iterator_mark(JSRuntime *rt, JSValueConst val,\n                                JS_MarkFunc *mark_func)\n{\n    JSObject *p = JS_VALUE_GET_OBJ(val);\n    JSForInIterator *it = p->u.for_in_iterator;\n    JS_MarkValue(rt, it->obj, mark_func);\n}\n\nstatic void free_object(JSRuntime *rt, JSObject *p)\n{\n    int i;\n    JSClassFinalizer *finalizer;\n    JSShape *sh;\n    JSShapeProperty *pr;\n\n    p->free_mark = 1; /* used to tell the object is invalid when\n                         freeing cycles */\n    /* free all the fields */\n    sh = p->shape;\n    pr = get_shape_prop(sh);\n    for(i = 0; i < sh->prop_count; i++) {\n        free_property(rt, &p->prop[i], pr->flags);\n        pr++;\n    }\n    js_free_rt(rt, p->prop);\n    /* as an optimization we destroy the shape immediately without\n       putting it in gc_zero_ref_count_list */\n    js_free_shape(rt, sh);\n\n    /* fail safe */\n    p->shape = NULL;\n    p->prop = NULL;\n\n    if (unlikely(p->first_weak_ref)) {\n        reset_weak_ref(rt, p);\n    }\n\n    finalizer = rt->class_array[p->class_id].finalizer;\n    if (finalizer)\n        (*finalizer)(rt, JS_MKPTR(JS_TAG_OBJECT, p));\n\n    /* fail safe */\n    p->class_id = 0;\n    p->u.opaque = NULL;\n    p->u.func.var_refs = NULL;\n    p->u.func.home_object = NULL;\n\n    remove_gc_object(&p->header);\n    if (rt->gc_phase == JS_GC_PHASE_REMOVE_CYCLES && p->header.ref_count != 0) {\n        list_add_tail(&p->header.link, &rt->gc_zero_ref_count_list);\n    } else {\n        js_free_rt(rt, p);\n    }\n}\n\nstatic void free_gc_object(JSRuntime *rt, JSGCObjectHeader *gp)\n{\n    switch(gp->gc_obj_type) {\n    case JS_GC_OBJ_TYPE_JS_OBJECT:\n        free_object(rt, (JSObject *)gp);\n        break;\n    case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:\n        free_function_bytecode(rt, (JSFunctionBytecode *)gp);\n        break;\n    case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:\n        __async_func_free(rt, (JSAsyncFunctionState *)gp);\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void free_zero_refcount(JSRuntime *rt)\n{\n    struct list_head *el;\n    JSGCObjectHeader *p;\n\n    rt->gc_phase = JS_GC_PHASE_DECREF;\n    for(;;) {\n        el = rt->gc_zero_ref_count_list.next;\n        if (el == &rt->gc_zero_ref_count_list)\n            break;\n        p = list_entry(el, JSGCObjectHeader, link);\n        assert(p->ref_count == 0);\n        free_gc_object(rt, p);\n    }\n    rt->gc_phase = JS_GC_PHASE_NONE;\n}\n\n/* called with the ref_count of 'v' reaches zero. */\nvoid __JS_FreeValueRT(JSRuntime *rt, JSValue v)\n{\n    uint32_t tag = JS_VALUE_GET_TAG(v);\n\n#ifdef DUMP_FREE\n    {\n        printf(\"Freeing \");\n        if (tag == JS_TAG_OBJECT) {\n            JS_DumpObject(rt, JS_VALUE_GET_OBJ(v));\n        } else {\n            JS_DumpValueShort(rt, v);\n            printf(\"\\n\");\n        }\n    }\n#endif\n\n    switch(tag) {\n    case JS_TAG_STRING:\n        {\n            JSString *p = JS_VALUE_GET_STRING(v);\n            if (p->atom_type) {\n                JS_FreeAtomStruct(rt, p);\n            } else {\n#ifdef DUMP_LEAKS\n                list_del(&p->link);\n#endif\n                js_free_rt(rt, p);\n            }\n        }\n        break;\n    case JS_TAG_OBJECT:\n    case JS_TAG_FUNCTION_BYTECODE:\n        {\n            JSGCObjectHeader *p = JS_VALUE_GET_PTR(v);\n            if (rt->gc_phase != JS_GC_PHASE_REMOVE_CYCLES) {\n                list_del(&p->link);\n                list_add(&p->link, &rt->gc_zero_ref_count_list);\n                if (rt->gc_phase == JS_GC_PHASE_NONE) {\n                    free_zero_refcount(rt);\n                }\n            }\n        }\n        break;\n    case JS_TAG_MODULE:\n        abort(); /* never freed here */\n        break;\n    case JS_TAG_BIG_INT:\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n#endif\n        {\n            JSBigFloat *bf = JS_VALUE_GET_PTR(v);\n            bf_delete(&bf->num);\n            js_free_rt(rt, bf);\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_DECIMAL:\n        {\n            JSBigDecimal *bf = JS_VALUE_GET_PTR(v);\n            bfdec_delete(&bf->num);\n            js_free_rt(rt, bf);\n        }\n        break;\n#endif\n    case JS_TAG_SYMBOL:\n        {\n            JSAtomStruct *p = JS_VALUE_GET_PTR(v);\n            JS_FreeAtomStruct(rt, p);\n        }\n        break;\n    default:\n        printf(\"__JS_FreeValue: unknown tag=%d\\n\", tag);\n        abort();\n    }\n}\n\nvoid __JS_FreeValue(JSContext *ctx, JSValue v)\n{\n    __JS_FreeValueRT(ctx->rt, v);\n}\n\n/* garbage collection */\n\nstatic void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,\n                          JSGCObjectTypeEnum type)\n{\n    h->mark = 0;\n    h->gc_obj_type = type;\n    list_add_tail(&h->link, &rt->gc_obj_list);\n}\n\nstatic void remove_gc_object(JSGCObjectHeader *h)\n{\n    list_del(&h->link);\n}\n\nvoid JS_MarkValue(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func)\n{\n    if (JS_VALUE_HAS_REF_COUNT(val)) {\n        switch(JS_VALUE_GET_TAG(val)) {\n        case JS_TAG_OBJECT:\n        case JS_TAG_FUNCTION_BYTECODE:\n            mark_func(rt, JS_VALUE_GET_PTR(val));\n            break;\n        default:\n            break;\n        }\n    }\n}\n\nstatic void mark_children(JSRuntime *rt, JSGCObjectHeader *gp,\n                          JS_MarkFunc *mark_func)\n{\n    switch(gp->gc_obj_type) {\n    case JS_GC_OBJ_TYPE_JS_OBJECT:\n        {\n            JSObject *p = (JSObject *)gp;\n            JSShapeProperty *prs;\n            JSShape *sh;\n            int i;\n            sh = p->shape;\n            mark_func(rt, &sh->header);\n            /* mark all the fields */\n            prs = get_shape_prop(sh);\n            for(i = 0; i < sh->prop_count; i++) {\n                JSProperty *pr = &p->prop[i];\n                if (prs->atom != JS_ATOM_NULL) {\n                    if (prs->flags & JS_PROP_TMASK) {\n                        if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                            if (pr->u.getset.getter)\n                                mark_func(rt, &pr->u.getset.getter->header);\n                            if (pr->u.getset.setter)\n                                mark_func(rt, &pr->u.getset.setter->header);\n                        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                            /* Note: the tag does not matter\n                               provided it is a GC object */\n                            mark_func(rt, &pr->u.var_ref->header);\n                        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                            js_autoinit_mark(rt, pr, mark_func);\n                        }\n                    } else {\n                        JS_MarkValue(rt, pr->u.value, mark_func);\n                    }\n                }\n                prs++;\n            }\n\n            if (p->class_id != JS_CLASS_OBJECT) {\n                JSClassGCMark *gc_mark;\n                gc_mark = rt->class_array[p->class_id].gc_mark;\n                if (gc_mark)\n                    gc_mark(rt, JS_MKPTR(JS_TAG_OBJECT, p), mark_func);\n            }\n        }\n        break;\n    case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:\n        /* the template objects can be part of a cycle */\n        {\n            JSFunctionBytecode *b = (JSFunctionBytecode *)gp;\n            int i;\n            for(i = 0; i < b->cpool_count; i++) {\n                JS_MarkValue(rt, b->cpool[i], mark_func);\n            }\n            if (b->realm)\n                mark_func(rt, &b->realm->header);\n        }\n        break;\n    case JS_GC_OBJ_TYPE_VAR_REF:\n        {\n            JSVarRef *var_ref = (JSVarRef *)gp;\n            if (var_ref->is_detached) {\n                JS_MarkValue(rt, *var_ref->pvalue, mark_func);\n            } else if (var_ref->async_func) {\n                mark_func(rt, &var_ref->async_func->header);\n            }\n        }\n        break;\n    case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:\n        {\n            JSAsyncFunctionState *s = (JSAsyncFunctionState *)gp;\n            JSStackFrame *sf = &s->frame;\n            JSValue *sp;\n\n            if (!s->is_completed) {\n                JS_MarkValue(rt, sf->cur_func, mark_func);\n                JS_MarkValue(rt, s->this_val, mark_func);\n                /* sf->cur_sp = NULL if the function is running */\n                if (sf->cur_sp) {\n                    /* if the function is running, cur_sp is not known so we\n                       cannot mark the stack. Marking the variables is not needed\n                       because a running function cannot be part of a removable\n                       cycle */\n                    for(sp = sf->arg_buf; sp < sf->cur_sp; sp++)\n                        JS_MarkValue(rt, *sp, mark_func);\n                }\n            }\n            JS_MarkValue(rt, s->resolving_funcs[0], mark_func);\n            JS_MarkValue(rt, s->resolving_funcs[1], mark_func);\n        }\n        break;\n    case JS_GC_OBJ_TYPE_SHAPE:\n        {\n            JSShape *sh = (JSShape *)gp;\n            if (sh->proto != NULL) {\n                mark_func(rt, &sh->proto->header);\n            }\n        }\n        break;\n    case JS_GC_OBJ_TYPE_JS_CONTEXT:\n        {\n            JSContext *ctx = (JSContext *)gp;\n            JS_MarkContext(rt, ctx, mark_func);\n        }\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void gc_decref_child(JSRuntime *rt, JSGCObjectHeader *p)\n{\n    assert(p->ref_count > 0);\n    p->ref_count--;\n    if (p->ref_count == 0 && p->mark == 1) {\n        list_del(&p->link);\n        list_add_tail(&p->link, &rt->tmp_obj_list);\n    }\n}\n\nstatic void gc_decref(JSRuntime *rt)\n{\n    struct list_head *el, *el1;\n    JSGCObjectHeader *p;\n\n    init_list_head(&rt->tmp_obj_list);\n\n    /* decrement the refcount of all the children of all the GC\n       objects and move the GC objects with zero refcount to\n       tmp_obj_list */\n    list_for_each_safe(el, el1, &rt->gc_obj_list) {\n        p = list_entry(el, JSGCObjectHeader, link);\n        assert(p->mark == 0);\n        mark_children(rt, p, gc_decref_child);\n        p->mark = 1;\n        if (p->ref_count == 0) {\n            list_del(&p->link);\n            list_add_tail(&p->link, &rt->tmp_obj_list);\n        }\n    }\n}\n\nstatic void gc_scan_incref_child(JSRuntime *rt, JSGCObjectHeader *p)\n{\n    p->ref_count++;\n    if (p->ref_count == 1) {\n        /* ref_count was 0: remove from tmp_obj_list and add at the\n           end of gc_obj_list */\n        list_del(&p->link);\n        list_add_tail(&p->link, &rt->gc_obj_list);\n        p->mark = 0; /* reset the mark for the next GC call */\n    }\n}\n\nstatic void gc_scan_incref_child2(JSRuntime *rt, JSGCObjectHeader *p)\n{\n    p->ref_count++;\n}\n\nstatic void gc_scan(JSRuntime *rt)\n{\n    struct list_head *el;\n    JSGCObjectHeader *p;\n\n    /* keep the objects with a refcount > 0 and their children. */\n    list_for_each(el, &rt->gc_obj_list) {\n        p = list_entry(el, JSGCObjectHeader, link);\n        assert(p->ref_count > 0);\n        p->mark = 0; /* reset the mark for the next GC call */\n        mark_children(rt, p, gc_scan_incref_child);\n    }\n\n    /* restore the refcount of the objects to be deleted. */\n    list_for_each(el, &rt->tmp_obj_list) {\n        p = list_entry(el, JSGCObjectHeader, link);\n        mark_children(rt, p, gc_scan_incref_child2);\n    }\n}\n\nstatic void gc_free_cycles(JSRuntime *rt)\n{\n    struct list_head *el, *el1;\n    JSGCObjectHeader *p;\n#ifdef DUMP_GC_FREE\n    BOOL header_done = FALSE;\n#endif\n\n    rt->gc_phase = JS_GC_PHASE_REMOVE_CYCLES;\n\n    for(;;) {\n        el = rt->tmp_obj_list.next;\n        if (el == &rt->tmp_obj_list)\n            break;\n        p = list_entry(el, JSGCObjectHeader, link);\n        /* Only need to free the GC object associated with JS values\n           or async functions. The rest will be automatically removed\n           because they must be referenced by them. */\n        switch(p->gc_obj_type) {\n        case JS_GC_OBJ_TYPE_JS_OBJECT:\n        case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:\n        case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:\n#ifdef DUMP_GC_FREE\n            if (!header_done) {\n                printf(\"Freeing cycles:\\n\");\n                JS_DumpObjectHeader(rt);\n                header_done = TRUE;\n            }\n            JS_DumpGCObject(rt, p);\n#endif\n            free_gc_object(rt, p);\n            break;\n        default:\n            list_del(&p->link);\n            list_add_tail(&p->link, &rt->gc_zero_ref_count_list);\n            break;\n        }\n    }\n    rt->gc_phase = JS_GC_PHASE_NONE;\n\n    list_for_each_safe(el, el1, &rt->gc_zero_ref_count_list) {\n        p = list_entry(el, JSGCObjectHeader, link);\n        assert(p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT ||\n               p->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE ||\n               p->gc_obj_type == JS_GC_OBJ_TYPE_ASYNC_FUNCTION);\n        js_free_rt(rt, p);\n    }\n\n    init_list_head(&rt->gc_zero_ref_count_list);\n}\n\nvoid JS_RunGC(JSRuntime *rt)\n{\n    /* decrement the reference of the children of each object. mark =\n       1 after this pass. */\n    gc_decref(rt);\n\n    /* keep the GC objects with a non zero refcount and their childs */\n    gc_scan(rt);\n\n    /* free the GC objects in a cycle */\n    gc_free_cycles(rt);\n}\n\n/* Return false if not an object or if the object has already been\n   freed (zombie objects are visible in finalizers when freeing\n   cycles). */\nBOOL JS_IsLiveObject(JSRuntime *rt, JSValueConst obj)\n{\n    JSObject *p;\n    if (!JS_IsObject(obj))\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    return !p->free_mark;\n}\n\n/* Compute memory used by various object types */\n/* XXX: poor man's approach to handling multiply referenced objects */\ntypedef struct JSMemoryUsage_helper {\n    double memory_used_count;\n    double str_count;\n    double str_size;\n    int64_t js_func_count;\n    double js_func_size;\n    int64_t js_func_code_size;\n    int64_t js_func_pc2line_count;\n    int64_t js_func_pc2line_size;\n} JSMemoryUsage_helper;\n\nstatic void compute_value_size(JSValueConst val, JSMemoryUsage_helper *hp);\n\nstatic void compute_jsstring_size(JSString *str, JSMemoryUsage_helper *hp)\n{\n    if (!str->atom_type) {  /* atoms are handled separately */\n        double s_ref_count = str->header.ref_count;\n        hp->str_count += 1 / s_ref_count;\n        hp->str_size += ((sizeof(*str) + (str->len << str->is_wide_char) +\n                          1 - str->is_wide_char) / s_ref_count);\n    }\n}\n\nstatic void compute_bytecode_size(JSFunctionBytecode *b, JSMemoryUsage_helper *hp)\n{\n    int memory_used_count, js_func_size, i;\n\n    memory_used_count = 0;\n    js_func_size = offsetof(JSFunctionBytecode, debug);\n    if (b->vardefs) {\n        js_func_size += (b->arg_count + b->var_count) * sizeof(*b->vardefs);\n    }\n    if (b->cpool) {\n        js_func_size += b->cpool_count * sizeof(*b->cpool);\n        for (i = 0; i < b->cpool_count; i++) {\n            JSValueConst val = b->cpool[i];\n            compute_value_size(val, hp);\n        }\n    }\n    if (b->closure_var) {\n        js_func_size += b->closure_var_count * sizeof(*b->closure_var);\n    }\n    if (!b->read_only_bytecode && b->byte_code_buf) {\n        hp->js_func_code_size += b->byte_code_len;\n    }\n    if (b->has_debug) {\n        js_func_size += sizeof(*b) - offsetof(JSFunctionBytecode, debug);\n        if (b->debug.source) {\n            memory_used_count++;\n            js_func_size += b->debug.source_len + 1;\n        }\n        if (b->debug.pc2line_len) {\n            memory_used_count++;\n            hp->js_func_pc2line_count += 1;\n            hp->js_func_pc2line_size += b->debug.pc2line_len;\n        }\n    }\n    hp->js_func_size += js_func_size;\n    hp->js_func_count += 1;\n    hp->memory_used_count += memory_used_count;\n}\n\nstatic void compute_value_size(JSValueConst val, JSMemoryUsage_helper *hp)\n{\n    switch(JS_VALUE_GET_TAG(val)) {\n    case JS_TAG_STRING:\n        compute_jsstring_size(JS_VALUE_GET_STRING(val), hp);\n        break;\n    case JS_TAG_BIG_INT:\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n    case JS_TAG_BIG_DECIMAL:\n#endif\n        /* should track JSBigFloat usage */\n        break;\n    }\n}\n\nvoid JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s)\n{\n    struct list_head *el, *el1;\n    int i;\n    JSMemoryUsage_helper mem = { 0 }, *hp = &mem;\n\n    memset(s, 0, sizeof(*s));\n    s->malloc_count = rt->malloc_state.malloc_count;\n    s->malloc_size = rt->malloc_state.malloc_size;\n    s->malloc_limit = rt->malloc_state.malloc_limit;\n\n    s->memory_used_count = 2; /* rt + rt->class_array */\n    s->memory_used_size = sizeof(JSRuntime) + sizeof(JSValue) * rt->class_count;\n\n    list_for_each(el, &rt->context_list) {\n        JSContext *ctx = list_entry(el, JSContext, link);\n        JSShape *sh = ctx->array_shape;\n        s->memory_used_count += 2; /* ctx + ctx->class_proto */\n        s->memory_used_size += sizeof(JSContext) +\n            sizeof(JSValue) * rt->class_count;\n        s->binary_object_count += ctx->binary_object_count;\n        s->binary_object_size += ctx->binary_object_size;\n\n        /* the hashed shapes are counted separately */\n        if (sh && !sh->is_hashed) {\n            int hash_size = sh->prop_hash_mask + 1;\n            s->shape_count++;\n            s->shape_size += get_shape_size(hash_size, sh->prop_size);\n        }\n        list_for_each(el1, &ctx->loaded_modules) {\n            JSModuleDef *m = list_entry(el1, JSModuleDef, link);\n            s->memory_used_count += 1;\n            s->memory_used_size += sizeof(*m);\n            if (m->req_module_entries) {\n                s->memory_used_count += 1;\n                s->memory_used_size += m->req_module_entries_count * sizeof(*m->req_module_entries);\n            }\n            if (m->export_entries) {\n                s->memory_used_count += 1;\n                s->memory_used_size += m->export_entries_count * sizeof(*m->export_entries);\n                for (i = 0; i < m->export_entries_count; i++) {\n                    JSExportEntry *me = &m->export_entries[i];\n                    if (me->export_type == JS_EXPORT_TYPE_LOCAL && me->u.local.var_ref) {\n                        /* potential multiple count */\n                        s->memory_used_count += 1;\n                        compute_value_size(me->u.local.var_ref->value, hp);\n                    }\n                }\n            }\n            if (m->star_export_entries) {\n                s->memory_used_count += 1;\n                s->memory_used_size += m->star_export_entries_count * sizeof(*m->star_export_entries);\n            }\n            if (m->import_entries) {\n                s->memory_used_count += 1;\n                s->memory_used_size += m->import_entries_count * sizeof(*m->import_entries);\n            }\n            compute_value_size(m->module_ns, hp);\n            compute_value_size(m->func_obj, hp);\n        }\n    }\n\n    list_for_each(el, &rt->gc_obj_list) {\n        JSGCObjectHeader *gp = list_entry(el, JSGCObjectHeader, link);\n        JSObject *p;\n        JSShape *sh;\n        JSShapeProperty *prs;\n\n        /* XXX: could count the other GC object types too */\n        if (gp->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE) {\n            compute_bytecode_size((JSFunctionBytecode *)gp, hp);\n            continue;\n        } else if (gp->gc_obj_type != JS_GC_OBJ_TYPE_JS_OBJECT) {\n            continue;\n        }\n        p = (JSObject *)gp;\n        sh = p->shape;\n        s->obj_count++;\n        if (p->prop) {\n            s->memory_used_count++;\n            s->prop_size += sh->prop_size * sizeof(*p->prop);\n            s->prop_count += sh->prop_count;\n            prs = get_shape_prop(sh);\n            for(i = 0; i < sh->prop_count; i++) {\n                JSProperty *pr = &p->prop[i];\n                if (prs->atom != JS_ATOM_NULL && !(prs->flags & JS_PROP_TMASK)) {\n                    compute_value_size(pr->u.value, hp);\n                }\n                prs++;\n            }\n        }\n        /* the hashed shapes are counted separately */\n        if (!sh->is_hashed) {\n            int hash_size = sh->prop_hash_mask + 1;\n            s->shape_count++;\n            s->shape_size += get_shape_size(hash_size, sh->prop_size);\n        }\n\n        switch(p->class_id) {\n        case JS_CLASS_ARRAY:             /* u.array | length */\n        case JS_CLASS_ARGUMENTS:         /* u.array | length */\n            s->array_count++;\n            if (p->fast_array) {\n                s->fast_array_count++;\n                if (p->u.array.u.values) {\n                    s->memory_used_count++;\n                    s->memory_used_size += p->u.array.count *\n                        sizeof(*p->u.array.u.values);\n                    s->fast_array_elements += p->u.array.count;\n                    for (i = 0; i < p->u.array.count; i++) {\n                        compute_value_size(p->u.array.u.values[i], hp);\n                    }\n                }\n            }\n            break;\n        case JS_CLASS_NUMBER:            /* u.object_data */\n        case JS_CLASS_STRING:            /* u.object_data */\n        case JS_CLASS_BOOLEAN:           /* u.object_data */\n        case JS_CLASS_SYMBOL:            /* u.object_data */\n        case JS_CLASS_DATE:              /* u.object_data */\n        case JS_CLASS_BIG_INT:           /* u.object_data */\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_BIG_FLOAT:         /* u.object_data */\n        case JS_CLASS_BIG_DECIMAL:         /* u.object_data */\n#endif\n            compute_value_size(p->u.object_data, hp);\n            break;\n        case JS_CLASS_C_FUNCTION:        /* u.cfunc */\n            s->c_func_count++;\n            break;\n        case JS_CLASS_BYTECODE_FUNCTION: /* u.func */\n            {\n                JSFunctionBytecode *b = p->u.func.function_bytecode;\n                JSVarRef **var_refs = p->u.func.var_refs;\n                /* home_object: object will be accounted for in list scan */\n                if (var_refs) {\n                    s->memory_used_count++;\n                    s->js_func_size += b->closure_var_count * sizeof(*var_refs);\n                    for (i = 0; i < b->closure_var_count; i++) {\n                        if (var_refs[i]) {\n                            double ref_count = var_refs[i]->header.ref_count;\n                            s->memory_used_count += 1 / ref_count;\n                            s->js_func_size += sizeof(*var_refs[i]) / ref_count;\n                            /* handle non object closed values */\n                            if (var_refs[i]->pvalue == &var_refs[i]->value) {\n                                /* potential multiple count */\n                                compute_value_size(var_refs[i]->value, hp);\n                            }\n                        }\n                    }\n                }\n            }\n            break;\n        case JS_CLASS_BOUND_FUNCTION:    /* u.bound_function */\n            {\n                JSBoundFunction *bf = p->u.bound_function;\n                /* func_obj and this_val are objects */\n                for (i = 0; i < bf->argc; i++) {\n                    compute_value_size(bf->argv[i], hp);\n                }\n                s->memory_used_count += 1;\n                s->memory_used_size += sizeof(*bf) + bf->argc * sizeof(*bf->argv);\n            }\n            break;\n        case JS_CLASS_C_FUNCTION_DATA:   /* u.c_function_data_record */\n            {\n                JSCFunctionDataRecord *fd = p->u.c_function_data_record;\n                if (fd) {\n                    for (i = 0; i < fd->data_len; i++) {\n                        compute_value_size(fd->data[i], hp);\n                    }\n                    s->memory_used_count += 1;\n                    s->memory_used_size += sizeof(*fd) + fd->data_len * sizeof(*fd->data);\n                }\n            }\n            break;\n        case JS_CLASS_REGEXP:            /* u.regexp */\n            compute_jsstring_size(p->u.regexp.pattern, hp);\n            compute_jsstring_size(p->u.regexp.bytecode, hp);\n            break;\n\n        case JS_CLASS_FOR_IN_ITERATOR:   /* u.for_in_iterator */\n            {\n                JSForInIterator *it = p->u.for_in_iterator;\n                if (it) {\n                    compute_value_size(it->obj, hp);\n                    s->memory_used_count += 1;\n                    s->memory_used_size += sizeof(*it);\n                }\n            }\n            break;\n        case JS_CLASS_ARRAY_BUFFER:      /* u.array_buffer */\n        case JS_CLASS_SHARED_ARRAY_BUFFER: /* u.array_buffer */\n            {\n                JSArrayBuffer *abuf = p->u.array_buffer;\n                if (abuf) {\n                    s->memory_used_count += 1;\n                    s->memory_used_size += sizeof(*abuf);\n                    if (abuf->data) {\n                        s->memory_used_count += 1;\n                        s->memory_used_size += abuf->byte_length;\n                    }\n                }\n            }\n            break;\n        case JS_CLASS_GENERATOR:         /* u.generator_data */\n        case JS_CLASS_UINT8C_ARRAY:      /* u.typed_array / u.array */\n        case JS_CLASS_INT8_ARRAY:        /* u.typed_array / u.array */\n        case JS_CLASS_UINT8_ARRAY:       /* u.typed_array / u.array */\n        case JS_CLASS_INT16_ARRAY:       /* u.typed_array / u.array */\n        case JS_CLASS_UINT16_ARRAY:      /* u.typed_array / u.array */\n        case JS_CLASS_INT32_ARRAY:       /* u.typed_array / u.array */\n        case JS_CLASS_UINT32_ARRAY:      /* u.typed_array / u.array */\n        case JS_CLASS_BIG_INT64_ARRAY:   /* u.typed_array / u.array */\n        case JS_CLASS_BIG_UINT64_ARRAY:  /* u.typed_array / u.array */\n        case JS_CLASS_FLOAT32_ARRAY:     /* u.typed_array / u.array */\n        case JS_CLASS_FLOAT64_ARRAY:     /* u.typed_array / u.array */\n        case JS_CLASS_DATAVIEW:          /* u.typed_array */\n#ifdef CONFIG_BIGNUM\n        case JS_CLASS_FLOAT_ENV:         /* u.float_env */\n#endif\n        case JS_CLASS_MAP:               /* u.map_state */\n        case JS_CLASS_SET:               /* u.map_state */\n        case JS_CLASS_WEAKMAP:           /* u.map_state */\n        case JS_CLASS_WEAKSET:           /* u.map_state */\n        case JS_CLASS_MAP_ITERATOR:      /* u.map_iterator_data */\n        case JS_CLASS_SET_ITERATOR:      /* u.map_iterator_data */\n        case JS_CLASS_ARRAY_ITERATOR:    /* u.array_iterator_data */\n        case JS_CLASS_STRING_ITERATOR:   /* u.array_iterator_data */\n        case JS_CLASS_PROXY:             /* u.proxy_data */\n        case JS_CLASS_PROMISE:           /* u.promise_data */\n        case JS_CLASS_PROMISE_RESOLVE_FUNCTION:  /* u.promise_function_data */\n        case JS_CLASS_PROMISE_REJECT_FUNCTION:   /* u.promise_function_data */\n        case JS_CLASS_ASYNC_FUNCTION_RESOLVE:    /* u.async_function_data */\n        case JS_CLASS_ASYNC_FUNCTION_REJECT:     /* u.async_function_data */\n        case JS_CLASS_ASYNC_FROM_SYNC_ITERATOR:  /* u.async_from_sync_iterator_data */\n        case JS_CLASS_ASYNC_GENERATOR:   /* u.async_generator_data */\n            /* TODO */\n        default:\n            /* XXX: class definition should have an opaque block size */\n            if (p->u.opaque) {\n                s->memory_used_count += 1;\n            }\n            break;\n        }\n    }\n    s->obj_size += s->obj_count * sizeof(JSObject);\n\n    /* hashed shapes */\n    s->memory_used_count++; /* rt->shape_hash */\n    s->memory_used_size += sizeof(rt->shape_hash[0]) * rt->shape_hash_size;\n    for(i = 0; i < rt->shape_hash_size; i++) {\n        JSShape *sh;\n        for(sh = rt->shape_hash[i]; sh != NULL; sh = sh->shape_hash_next) {\n            int hash_size = sh->prop_hash_mask + 1;\n            s->shape_count++;\n            s->shape_size += get_shape_size(hash_size, sh->prop_size);\n        }\n    }\n\n    /* atoms */\n    s->memory_used_count += 2; /* rt->atom_array, rt->atom_hash */\n    s->atom_count = rt->atom_count;\n    s->atom_size = sizeof(rt->atom_array[0]) * rt->atom_size +\n        sizeof(rt->atom_hash[0]) * rt->atom_hash_size;\n    for(i = 0; i < rt->atom_size; i++) {\n        JSAtomStruct *p = rt->atom_array[i];\n        if (!atom_is_free(p)) {\n            s->atom_size += (sizeof(*p) + (p->len << p->is_wide_char) +\n                             1 - p->is_wide_char);\n        }\n    }\n    s->str_count = round(mem.str_count);\n    s->str_size = round(mem.str_size);\n    s->js_func_count = mem.js_func_count;\n    s->js_func_size = round(mem.js_func_size);\n    s->js_func_code_size = mem.js_func_code_size;\n    s->js_func_pc2line_count = mem.js_func_pc2line_count;\n    s->js_func_pc2line_size = mem.js_func_pc2line_size;\n    s->memory_used_count += round(mem.memory_used_count) +\n        s->atom_count + s->str_count +\n        s->obj_count + s->shape_count +\n        s->js_func_count + s->js_func_pc2line_count;\n    s->memory_used_size += s->atom_size + s->str_size +\n        s->obj_size + s->prop_size + s->shape_size +\n        s->js_func_size + s->js_func_code_size + s->js_func_pc2line_size;\n}\n\nvoid JS_DumpMemoryUsage(FILE *fp, const JSMemoryUsage *s, JSRuntime *rt)\n{\n    fprintf(fp, \"QuickJS memory usage -- \"\n#ifdef CONFIG_BIGNUM\n            \"BigNum \"\n#endif\n            CONFIG_VERSION \" version, %d-bit, malloc limit: %\"PRId64\"\\n\\n\",\n            (int)sizeof(void *) * 8, s->malloc_limit);\n#if 1\n    if (rt) {\n        static const struct {\n            const char *name;\n            size_t size;\n        } object_types[] = {\n            { \"JSRuntime\", sizeof(JSRuntime) },\n            { \"JSContext\", sizeof(JSContext) },\n            { \"JSObject\", sizeof(JSObject) },\n            { \"JSString\", sizeof(JSString) },\n            { \"JSFunctionBytecode\", sizeof(JSFunctionBytecode) },\n        };\n        int i, usage_size_ok = 0;\n        for(i = 0; i < countof(object_types); i++) {\n            unsigned int size = object_types[i].size;\n            void *p = js_malloc_rt(rt, size);\n            if (p) {\n                unsigned int size1 = js_malloc_usable_size_rt(rt, p);\n                if (size1 >= size) {\n                    usage_size_ok = 1;\n                    fprintf(fp, \"  %3u + %-2u  %s\\n\",\n                            size, size1 - size, object_types[i].name);\n                }\n                js_free_rt(rt, p);\n            }\n        }\n        if (!usage_size_ok) {\n            fprintf(fp, \"  malloc_usable_size unavailable\\n\");\n        }\n        {\n            int obj_classes[JS_CLASS_INIT_COUNT + 1] = { 0 };\n            int class_id;\n            struct list_head *el;\n            list_for_each(el, &rt->gc_obj_list) {\n                JSGCObjectHeader *gp = list_entry(el, JSGCObjectHeader, link);\n                JSObject *p;\n                if (gp->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {\n                    p = (JSObject *)gp;\n                    obj_classes[min_uint32(p->class_id, JS_CLASS_INIT_COUNT)]++;\n                }\n            }\n            fprintf(fp, \"\\n\" \"JSObject classes\\n\");\n            if (obj_classes[0])\n                fprintf(fp, \"  %5d  %2.0d %s\\n\", obj_classes[0], 0, \"none\");\n            for (class_id = 1; class_id < JS_CLASS_INIT_COUNT; class_id++) {\n                if (obj_classes[class_id] && class_id < rt->class_count) {\n                    char buf[ATOM_GET_STR_BUF_SIZE];\n                    fprintf(fp, \"  %5d  %2.0d %s\\n\", obj_classes[class_id], class_id,\n                            JS_AtomGetStrRT(rt, buf, sizeof(buf), rt->class_array[class_id].class_name));\n                }\n            }\n            if (obj_classes[JS_CLASS_INIT_COUNT])\n                fprintf(fp, \"  %5d  %2.0d %s\\n\", obj_classes[JS_CLASS_INIT_COUNT], 0, \"other\");\n        }\n        fprintf(fp, \"\\n\");\n    }\n#endif\n    fprintf(fp, \"%-20s %8s %8s\\n\", \"NAME\", \"COUNT\", \"SIZE\");\n\n    if (s->malloc_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per block)\\n\",\n                \"memory allocated\", s->malloc_count, s->malloc_size,\n                (double)s->malloc_size / s->malloc_count);\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%d overhead, %0.1f average slack)\\n\",\n                \"memory used\", s->memory_used_count, s->memory_used_size,\n                MALLOC_OVERHEAD, ((double)(s->malloc_size - s->memory_used_size) /\n                                  s->memory_used_count));\n    }\n    if (s->atom_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per atom)\\n\",\n                \"atoms\", s->atom_count, s->atom_size,\n                (double)s->atom_size / s->atom_count);\n    }\n    if (s->str_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per string)\\n\",\n                \"strings\", s->str_count, s->str_size,\n                (double)s->str_size / s->str_count);\n    }\n    if (s->obj_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per object)\\n\",\n                \"objects\", s->obj_count, s->obj_size,\n                (double)s->obj_size / s->obj_count);\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per object)\\n\",\n                \"  properties\", s->prop_count, s->prop_size,\n                (double)s->prop_count / s->obj_count);\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per shape)\\n\",\n                \"  shapes\", s->shape_count, s->shape_size,\n                (double)s->shape_size / s->shape_count);\n    }\n    if (s->js_func_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"\\n\",\n                \"bytecode functions\", s->js_func_count, s->js_func_size);\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per function)\\n\",\n                \"  bytecode\", s->js_func_count, s->js_func_code_size,\n                (double)s->js_func_code_size / s->js_func_count);\n        if (s->js_func_pc2line_count) {\n            fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per function)\\n\",\n                    \"  pc2line\", s->js_func_pc2line_count,\n                    s->js_func_pc2line_size,\n                    (double)s->js_func_pc2line_size / s->js_func_pc2line_count);\n        }\n    }\n    if (s->c_func_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\"\\n\", \"C functions\", s->c_func_count);\n    }\n    if (s->array_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\"\\n\", \"arrays\", s->array_count);\n        if (s->fast_array_count) {\n            fprintf(fp, \"%-20s %8\"PRId64\"\\n\", \"  fast arrays\", s->fast_array_count);\n            fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"  (%0.1f per fast array)\\n\",\n                    \"  elements\", s->fast_array_elements,\n                    s->fast_array_elements * (int)sizeof(JSValue),\n                    (double)s->fast_array_elements / s->fast_array_count);\n        }\n    }\n    if (s->binary_object_count) {\n        fprintf(fp, \"%-20s %8\"PRId64\" %8\"PRId64\"\\n\",\n                \"binary objects\", s->binary_object_count, s->binary_object_size);\n    }\n}\n\nJSValue JS_GetGlobalObject(JSContext *ctx)\n{\n    return JS_DupValue(ctx, ctx->global_obj);\n}\n\n/* WARNING: obj is freed */\nJSValue JS_Throw(JSContext *ctx, JSValue obj)\n{\n    JSRuntime *rt = ctx->rt;\n    JS_FreeValue(ctx, rt->current_exception);\n    rt->current_exception = obj;\n    return JS_EXCEPTION;\n}\n\n/* return the pending exception (cannot be called twice). */\nJSValue JS_GetException(JSContext *ctx)\n{\n    JSValue val;\n    JSRuntime *rt = ctx->rt;\n    val = rt->current_exception;\n    rt->current_exception = JS_UNINITIALIZED;\n    return val;\n}\n\nJS_BOOL JS_HasException(JSContext *ctx)\n{\n    return !JS_IsUninitialized(ctx->rt->current_exception);\n}\n\nstatic void dbuf_put_leb128(DynBuf *s, uint32_t v)\n{\n    uint32_t a;\n    for(;;) {\n        a = v & 0x7f;\n        v >>= 7;\n        if (v != 0) {\n            dbuf_putc(s, a | 0x80);\n        } else {\n            dbuf_putc(s, a);\n            break;\n        }\n    }\n}\n\nstatic void dbuf_put_sleb128(DynBuf *s, int32_t v1)\n{\n    uint32_t v = v1;\n    dbuf_put_leb128(s, (2 * v) ^ -(v >> 31));\n}\n\nstatic int get_leb128(uint32_t *pval, const uint8_t *buf,\n                      const uint8_t *buf_end)\n{\n    const uint8_t *ptr = buf;\n    uint32_t v, a, i;\n    v = 0;\n    for(i = 0; i < 5; i++) {\n        if (unlikely(ptr >= buf_end))\n            break;\n        a = *ptr++;\n        v |= (a & 0x7f) << (i * 7);\n        if (!(a & 0x80)) {\n            *pval = v;\n            return ptr - buf;\n        }\n    }\n    *pval = 0;\n    return -1;\n}\n\nstatic int get_sleb128(int32_t *pval, const uint8_t *buf,\n                       const uint8_t *buf_end)\n{\n    int ret;\n    uint32_t val;\n    ret = get_leb128(&val, buf, buf_end);\n    if (ret < 0) {\n        *pval = 0;\n        return -1;\n    }\n    *pval = (val >> 1) ^ -(val & 1);\n    return ret;\n}\n\nstatic int find_line_num(JSContext *ctx, JSFunctionBytecode *b,\n                         uint32_t pc_value)\n{\n    const uint8_t *p_end, *p;\n    int new_line_num, line_num, pc, v, ret;\n    unsigned int op;\n\n    if (!b->has_debug || !b->debug.pc2line_buf) {\n        /* function was stripped */\n        return -1;\n    }\n\n    p = b->debug.pc2line_buf;\n    p_end = p + b->debug.pc2line_len;\n    pc = 0;\n    line_num = b->debug.line_num;\n    while (p < p_end) {\n        op = *p++;\n        if (op == 0) {\n            uint32_t val;\n            ret = get_leb128(&val, p, p_end);\n            if (ret < 0)\n                goto fail;\n            pc += val;\n            p += ret;\n            ret = get_sleb128(&v, p, p_end);\n            if (ret < 0) {\n            fail:\n                /* should never happen */\n                return b->debug.line_num;\n            }\n            p += ret;\n            new_line_num = line_num + v;\n        } else {\n            op -= PC2LINE_OP_FIRST;\n            pc += (op / PC2LINE_RANGE);\n            new_line_num = line_num + (op % PC2LINE_RANGE) + PC2LINE_BASE;\n        }\n        if (pc_value < pc)\n            return line_num;\n        line_num = new_line_num;\n    }\n    return line_num;\n}\n\n/* in order to avoid executing arbitrary code during the stack trace\n   generation, we only look at simple 'name' properties containing a\n   string. */\nstatic const char *get_func_name(JSContext *ctx, JSValueConst func)\n{\n    JSProperty *pr;\n    JSShapeProperty *prs;\n    JSValueConst val;\n\n    if (JS_VALUE_GET_TAG(func) != JS_TAG_OBJECT)\n        return NULL;\n    prs = find_own_property(&pr, JS_VALUE_GET_OBJ(func), JS_ATOM_name);\n    if (!prs)\n        return NULL;\n    if ((prs->flags & JS_PROP_TMASK) != JS_PROP_NORMAL)\n        return NULL;\n    val = pr->u.value;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_STRING)\n        return NULL;\n    return JS_ToCString(ctx, val);\n}\n\n#define JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL (1 << 0)\n/* only taken into account if filename is provided */\n#define JS_BACKTRACE_FLAG_SINGLE_LEVEL     (1 << 1)\n\n/* if filename != NULL, an additional level is added with the filename\n   and line number information (used for parse error). */\nstatic void build_backtrace(JSContext *ctx, JSValueConst error_obj,\n                            const char *filename, int line_num,\n                            int backtrace_flags)\n{\n    JSStackFrame *sf;\n    JSValue str;\n    DynBuf dbuf;\n    const char *func_name_str;\n    const char *str1;\n    JSObject *p;\n    BOOL backtrace_barrier;\n\n    js_dbuf_init(ctx, &dbuf);\n    if (filename) {\n        dbuf_printf(&dbuf, \"    at %s\", filename);\n        if (line_num != -1)\n            dbuf_printf(&dbuf, \":%d\", line_num);\n        dbuf_putc(&dbuf, '\\n');\n        str = JS_NewString(ctx, filename);\n        JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_fileName, str,\n                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n        JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_lineNumber, JS_NewInt32(ctx, line_num),\n                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n        if (backtrace_flags & JS_BACKTRACE_FLAG_SINGLE_LEVEL)\n            goto done;\n    }\n    for(sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {\n        if (backtrace_flags & JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL) {\n            backtrace_flags &= ~JS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL;\n            continue;\n        }\n        func_name_str = get_func_name(ctx, sf->cur_func);\n        if (!func_name_str || func_name_str[0] == '\\0')\n            str1 = \"<anonymous>\";\n        else\n            str1 = func_name_str;\n        dbuf_printf(&dbuf, \"    at %s\", str1);\n        JS_FreeCString(ctx, func_name_str);\n\n        p = JS_VALUE_GET_OBJ(sf->cur_func);\n        backtrace_barrier = FALSE;\n        if (js_class_has_bytecode(p->class_id)) {\n            JSFunctionBytecode *b;\n            const char *atom_str;\n            int line_num1;\n\n            b = p->u.func.function_bytecode;\n            backtrace_barrier = b->backtrace_barrier;\n            if (b->has_debug) {\n                line_num1 = find_line_num(ctx, b,\n                                          sf->cur_pc - b->byte_code_buf - 1);\n                atom_str = JS_AtomToCString(ctx, b->debug.filename);\n                dbuf_printf(&dbuf, \" (%s\",\n                            atom_str ? atom_str : \"<null>\");\n                JS_FreeCString(ctx, atom_str);\n                if (line_num1 != -1)\n                    dbuf_printf(&dbuf, \":%d\", line_num1);\n                dbuf_putc(&dbuf, ')');\n            }\n        } else {\n            dbuf_printf(&dbuf, \" (native)\");\n        }\n        dbuf_putc(&dbuf, '\\n');\n        /* stop backtrace if JS_EVAL_FLAG_BACKTRACE_BARRIER was used */\n        if (backtrace_barrier)\n            break;\n    }\n done:\n    dbuf_putc(&dbuf, '\\0');\n    if (dbuf_error(&dbuf))\n        str = JS_NULL;\n    else\n        str = JS_NewString(ctx, (char *)dbuf.buf);\n    dbuf_free(&dbuf);\n    JS_DefinePropertyValue(ctx, error_obj, JS_ATOM_stack, str,\n                           JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n}\n\n/* Note: it is important that no exception is returned by this function */\nstatic BOOL is_backtrace_needed(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (p->class_id != JS_CLASS_ERROR)\n        return FALSE;\n    if (find_own_property1(p, JS_ATOM_stack))\n        return FALSE;\n    return TRUE;\n}\n\nJSValue JS_NewError(JSContext *ctx)\n{\n    return JS_NewObjectClass(ctx, JS_CLASS_ERROR);\n}\n\nstatic JSValue JS_ThrowError2(JSContext *ctx, JSErrorEnum error_num,\n                              const char *fmt, va_list ap, BOOL add_backtrace)\n{\n    char buf[256];\n    JSValue obj, ret;\n\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n    obj = JS_NewObjectProtoClass(ctx, ctx->native_error_proto[error_num],\n                                 JS_CLASS_ERROR);\n    if (unlikely(JS_IsException(obj))) {\n        /* out of memory: throw JS_NULL to avoid recursing */\n        obj = JS_NULL;\n    } else {\n        JS_DefinePropertyValue(ctx, obj, JS_ATOM_message,\n                               JS_NewString(ctx, buf),\n                               JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    }\n    if (add_backtrace) {\n        build_backtrace(ctx, obj, NULL, 0, 0);\n    }\n    ret = JS_Throw(ctx, obj);\n    return ret;\n}\n\nstatic JSValue JS_ThrowError(JSContext *ctx, JSErrorEnum error_num,\n                             const char *fmt, va_list ap)\n{\n    JSRuntime *rt = ctx->rt;\n    JSStackFrame *sf;\n    BOOL add_backtrace;\n\n    /* the backtrace is added later if called from a bytecode function */\n    sf = rt->current_stack_frame;\n    add_backtrace = !rt->in_out_of_memory &&\n        (!sf || (JS_GetFunctionBytecode(sf->cur_func) == NULL));\n    return JS_ThrowError2(ctx, error_num, fmt, ap, add_backtrace);\n}\n\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)\n{\n    JSValue val;\n    va_list ap;\n\n    va_start(ap, fmt);\n    val = JS_ThrowError(ctx, JS_SYNTAX_ERROR, fmt, ap);\n    va_end(ap);\n    return val;\n}\n\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)\n{\n    JSValue val;\n    va_list ap;\n\n    va_start(ap, fmt);\n    val = JS_ThrowError(ctx, JS_TYPE_ERROR, fmt, ap);\n    va_end(ap);\n    return val;\n}\n\nstatic int __attribute__((format(printf, 3, 4))) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)\n{\n    va_list ap;\n\n    if ((flags & JS_PROP_THROW) ||\n        ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {\n        va_start(ap, fmt);\n        JS_ThrowError(ctx, JS_TYPE_ERROR, fmt, ap);\n        va_end(ap);\n        return -1;\n    } else {\n        return FALSE;\n    }\n}\n\n/* never use it directly */\nstatic JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    return JS_ThrowTypeError(ctx, fmt,\n                             JS_AtomGetStr(ctx, buf, sizeof(buf), atom));\n}\n\n/* never use it directly */\nstatic JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    return JS_ThrowSyntaxError(ctx, fmt,\n                             JS_AtomGetStr(ctx, buf, sizeof(buf), atom));\n}\n\n/* %s is replaced by 'atom'. The macro is used so that gcc can check\n    the format string. */\n#define JS_ThrowTypeErrorAtom(ctx, fmt, atom) __JS_ThrowTypeErrorAtom(ctx, atom, fmt, \"\")\n#define JS_ThrowSyntaxErrorAtom(ctx, fmt, atom) __JS_ThrowSyntaxErrorAtom(ctx, atom, fmt, \"\")\n\nstatic int JS_ThrowTypeErrorReadOnly(JSContext *ctx, int flags, JSAtom atom)\n{\n    if ((flags & JS_PROP_THROW) ||\n        ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {\n        JS_ThrowTypeErrorAtom(ctx, \"'%s' is read-only\", atom);\n        return -1;\n    } else {\n        return FALSE;\n    }\n}\n\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)\n{\n    JSValue val;\n    va_list ap;\n\n    va_start(ap, fmt);\n    val = JS_ThrowError(ctx, JS_REFERENCE_ERROR, fmt, ap);\n    va_end(ap);\n    return val;\n}\n\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)\n{\n    JSValue val;\n    va_list ap;\n\n    va_start(ap, fmt);\n    val = JS_ThrowError(ctx, JS_RANGE_ERROR, fmt, ap);\n    va_end(ap);\n    return val;\n}\n\nJSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)\n{\n    JSValue val;\n    va_list ap;\n\n    va_start(ap, fmt);\n    val = JS_ThrowError(ctx, JS_INTERNAL_ERROR, fmt, ap);\n    va_end(ap);\n    return val;\n}\n\nJSValue JS_ThrowOutOfMemory(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    if (!rt->in_out_of_memory) {\n        rt->in_out_of_memory = TRUE;\n        JS_ThrowInternalError(ctx, \"out of memory\");\n        rt->in_out_of_memory = FALSE;\n    }\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ThrowStackOverflow(JSContext *ctx)\n{\n    return JS_ThrowInternalError(ctx, \"stack overflow\");\n}\n\nstatic JSValue JS_ThrowTypeErrorNotAnObject(JSContext *ctx)\n{\n    return JS_ThrowTypeError(ctx, \"not an object\");\n}\n\nstatic JSValue JS_ThrowTypeErrorNotASymbol(JSContext *ctx)\n{\n    return JS_ThrowTypeError(ctx, \"not a symbol\");\n}\n\nstatic JSValue JS_ThrowReferenceErrorNotDefined(JSContext *ctx, JSAtom name)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    return JS_ThrowReferenceError(ctx, \"'%s' is not defined\",\n                                  JS_AtomGetStr(ctx, buf, sizeof(buf), name));\n}\n\nstatic JSValue JS_ThrowReferenceErrorUninitialized(JSContext *ctx, JSAtom name)\n{\n    char buf[ATOM_GET_STR_BUF_SIZE];\n    return JS_ThrowReferenceError(ctx, \"%s is not initialized\",\n                                  name == JS_ATOM_NULL ? \"lexical variable\" :\n                                  JS_AtomGetStr(ctx, buf, sizeof(buf), name));\n}\n\nstatic JSValue JS_ThrowReferenceErrorUninitialized2(JSContext *ctx,\n                                                    JSFunctionBytecode *b,\n                                                    int idx, BOOL is_ref)\n{\n    JSAtom atom = JS_ATOM_NULL;\n    if (is_ref) {\n        atom = b->closure_var[idx].var_name;\n    } else {\n        /* not present if the function is stripped and contains no eval() */\n        if (b->vardefs)\n            atom = b->vardefs[b->arg_count + idx].var_name;\n    }\n    return JS_ThrowReferenceErrorUninitialized(ctx, atom);\n}\n\nstatic JSValue JS_ThrowTypeErrorInvalidClass(JSContext *ctx, int class_id)\n{\n    JSRuntime *rt = ctx->rt;\n    JSAtom name;\n    name = rt->class_array[class_id].class_name;\n    return JS_ThrowTypeErrorAtom(ctx, \"%s object expected\", name);\n}\n\nstatic no_inline __exception int __js_poll_interrupts(JSContext *ctx)\n{\n    JSRuntime *rt = ctx->rt;\n    ctx->interrupt_counter = JS_INTERRUPT_COUNTER_INIT;\n    if (rt->interrupt_handler) {\n        if (rt->interrupt_handler(rt, rt->interrupt_opaque)) {\n            /* XXX: should set a specific flag to avoid catching */\n            JS_ThrowInternalError(ctx, \"interrupted\");\n            JS_SetUncatchableError(ctx, ctx->rt->current_exception, TRUE);\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic inline __exception int js_poll_interrupts(JSContext *ctx)\n{\n    if (unlikely(--ctx->interrupt_counter <= 0)) {\n        return __js_poll_interrupts(ctx);\n    } else {\n        return 0;\n    }\n}\n\n/* return -1 (exception) or TRUE/FALSE */\nstatic int JS_SetPrototypeInternal(JSContext *ctx, JSValueConst obj,\n                                   JSValueConst proto_val,\n                                   BOOL throw_flag)\n{\n    JSObject *proto, *p, *p1;\n    JSShape *sh;\n\n    if (throw_flag) {\n        if (JS_VALUE_GET_TAG(obj) == JS_TAG_NULL ||\n            JS_VALUE_GET_TAG(obj) == JS_TAG_UNDEFINED)\n            goto not_obj;\n    } else {\n        if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n            goto not_obj;\n    }\n    p = JS_VALUE_GET_OBJ(obj);\n    if (JS_VALUE_GET_TAG(proto_val) != JS_TAG_OBJECT) {\n        if (JS_VALUE_GET_TAG(proto_val) != JS_TAG_NULL) {\n        not_obj:\n            JS_ThrowTypeErrorNotAnObject(ctx);\n            return -1;\n        }\n        proto = NULL;\n    } else {\n        proto = JS_VALUE_GET_OBJ(proto_val);\n    }\n\n    if (throw_flag && JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return TRUE;\n\n    if (unlikely(p->class_id == JS_CLASS_PROXY))\n        return js_proxy_setPrototypeOf(ctx, obj, proto_val, throw_flag);\n    sh = p->shape;\n    if (sh->proto == proto)\n        return TRUE;\n    if (!p->extensible) {\n        if (throw_flag) {\n            JS_ThrowTypeError(ctx, \"object is not extensible\");\n            return -1;\n        } else {\n            return FALSE;\n        }\n    }\n    if (proto) {\n        /* check if there is a cycle */\n        p1 = proto;\n        do {\n            if (p1 == p) {\n                if (throw_flag) {\n                    JS_ThrowTypeError(ctx, \"circular prototype chain\");\n                    return -1;\n                } else {\n                    return FALSE;\n                }\n            }\n            /* Note: for Proxy objects, proto is NULL */\n            p1 = p1->shape->proto;\n        } while (p1 != NULL);\n        JS_DupValue(ctx, proto_val);\n    }\n\n    if (js_shape_prepare_update(ctx, p, NULL))\n        return -1;\n    sh = p->shape;\n    if (sh->proto)\n        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, sh->proto));\n    sh->proto = proto;\n    return TRUE;\n}\n\n/* return -1 (exception) or TRUE/FALSE */\nint JS_SetPrototype(JSContext *ctx, JSValueConst obj, JSValueConst proto_val)\n{\n    return JS_SetPrototypeInternal(ctx, obj, proto_val, TRUE);\n}\n\n/* Only works for primitive types, otherwise return JS_NULL. */\nstatic JSValueConst JS_GetPrototypePrimitive(JSContext *ctx, JSValueConst val)\n{\n    switch(JS_VALUE_GET_NORM_TAG(val)) {\n    case JS_TAG_BIG_INT:\n        val = ctx->class_proto[JS_CLASS_BIG_INT];\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        val = ctx->class_proto[JS_CLASS_BIG_FLOAT];\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        val = ctx->class_proto[JS_CLASS_BIG_DECIMAL];\n        break;\n#endif\n    case JS_TAG_INT:\n    case JS_TAG_FLOAT64:\n        val = ctx->class_proto[JS_CLASS_NUMBER];\n        break;\n    case JS_TAG_BOOL:\n        val = ctx->class_proto[JS_CLASS_BOOLEAN];\n        break;\n    case JS_TAG_STRING:\n        val = ctx->class_proto[JS_CLASS_STRING];\n        break;\n    case JS_TAG_SYMBOL:\n        val = ctx->class_proto[JS_CLASS_SYMBOL];\n        break;\n    case JS_TAG_OBJECT:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n    default:\n        val = JS_NULL;\n        break;\n    }\n    return val;\n}\n\n/* Return an Object, JS_NULL or JS_EXCEPTION in case of Proxy object. */\nJSValue JS_GetPrototype(JSContext *ctx, JSValueConst obj)\n{\n    JSValue val;\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        JSObject *p;\n        p = JS_VALUE_GET_OBJ(obj);\n        if (unlikely(p->class_id == JS_CLASS_PROXY)) {\n            val = js_proxy_getPrototypeOf(ctx, obj);\n        } else {\n            p = p->shape->proto;\n            if (!p)\n                val = JS_NULL;\n            else\n                val = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n        }\n    } else {\n        val = JS_DupValue(ctx, JS_GetPrototypePrimitive(ctx, obj));\n    }\n    return val;\n}\n\nstatic JSValue JS_GetPrototypeFree(JSContext *ctx, JSValue obj)\n{\n    JSValue obj1;\n    obj1 = JS_GetPrototype(ctx, obj);\n    JS_FreeValue(ctx, obj);\n    return obj1;\n}\n\n/* return TRUE, FALSE or (-1) in case of exception */\nstatic int JS_OrdinaryIsInstanceOf(JSContext *ctx, JSValueConst val,\n                                   JSValueConst obj)\n{\n    JSValue obj_proto;\n    JSObject *proto;\n    const JSObject *p, *proto1;\n    BOOL ret;\n\n    if (!JS_IsFunction(ctx, obj))\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (p->class_id == JS_CLASS_BOUND_FUNCTION) {\n        JSBoundFunction *s = p->u.bound_function;\n        return JS_IsInstanceOf(ctx, val, s->func_obj);\n    }\n\n    /* Only explicitly boxed values are instances of constructors */\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    obj_proto = JS_GetProperty(ctx, obj, JS_ATOM_prototype);\n    if (JS_VALUE_GET_TAG(obj_proto) != JS_TAG_OBJECT) {\n        if (!JS_IsException(obj_proto))\n            JS_ThrowTypeError(ctx, \"operand 'prototype' property is not an object\");\n        ret = -1;\n        goto done;\n    }\n    proto = JS_VALUE_GET_OBJ(obj_proto);\n    p = JS_VALUE_GET_OBJ(val);\n    for(;;) {\n        proto1 = p->shape->proto;\n        if (!proto1) {\n            /* slow case if proxy in the prototype chain */\n            if (unlikely(p->class_id == JS_CLASS_PROXY)) {\n                JSValue obj1;\n                obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, (JSObject *)p));\n                for(;;) {\n                    obj1 = JS_GetPrototypeFree(ctx, obj1);\n                    if (JS_IsException(obj1)) {\n                        ret = -1;\n                        break;\n                    }\n                    if (JS_IsNull(obj1)) {\n                        ret = FALSE;\n                        break;\n                    }\n                    if (proto == JS_VALUE_GET_OBJ(obj1)) {\n                        JS_FreeValue(ctx, obj1);\n                        ret = TRUE;\n                        break;\n                    }\n                    /* must check for timeout to avoid infinite loop */\n                    if (js_poll_interrupts(ctx)) {\n                        JS_FreeValue(ctx, obj1);\n                        ret = -1;\n                        break;\n                    }\n                }\n            } else {\n                ret = FALSE;\n            }\n            break;\n        }\n        p = proto1;\n        if (proto == p) {\n            ret = TRUE;\n            break;\n        }\n    }\ndone:\n    JS_FreeValue(ctx, obj_proto);\n    return ret;\n}\n\n/* return TRUE, FALSE or (-1) in case of exception */\nint JS_IsInstanceOf(JSContext *ctx, JSValueConst val, JSValueConst obj)\n{\n    JSValue method;\n\n    if (!JS_IsObject(obj))\n        goto fail;\n    method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_hasInstance);\n    if (JS_IsException(method))\n        return -1;\n    if (!JS_IsNull(method) && !JS_IsUndefined(method)) {\n        JSValue ret;\n        ret = JS_CallFree(ctx, method, obj, 1, &val);\n        return JS_ToBoolFree(ctx, ret);\n    }\n\n    /* legacy case */\n    if (!JS_IsFunction(ctx, obj)) {\n    fail:\n        JS_ThrowTypeError(ctx, \"invalid 'instanceof' right operand\");\n        return -1;\n    }\n    return JS_OrdinaryIsInstanceOf(ctx, val, obj);\n}\n\n/* return the value associated to the autoinit property or an exception */\ntypedef JSValue JSAutoInitFunc(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque);\n\nstatic JSAutoInitFunc *js_autoinit_func_table[] = {\n    js_instantiate_prototype, /* JS_AUTOINIT_ID_PROTOTYPE */\n    js_module_ns_autoinit, /* JS_AUTOINIT_ID_MODULE_NS */\n    JS_InstantiateFunctionListItem2, /* JS_AUTOINIT_ID_PROP */\n};\n\n/* warning: 'prs' is reallocated after it */\nstatic int JS_AutoInitProperty(JSContext *ctx, JSObject *p, JSAtom prop,\n                               JSProperty *pr, JSShapeProperty *prs)\n{\n    JSValue val;\n    JSContext *realm;\n    JSAutoInitFunc *func;\n\n    if (js_shape_prepare_update(ctx, p, &prs))\n        return -1;\n\n    realm = js_autoinit_get_realm(pr);\n    func = js_autoinit_func_table[js_autoinit_get_id(pr)];\n    /* 'func' shall not modify the object properties 'pr' */\n    val = func(realm, p, prop, pr->u.init.opaque);\n    js_autoinit_free(ctx->rt, pr);\n    prs->flags &= ~JS_PROP_TMASK;\n    pr->u.value = JS_UNDEFINED;\n    if (JS_IsException(val))\n        return -1;\n    pr->u.value = val;\n    return 0;\n}\n\nJSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,\n                               JSAtom prop, JSValueConst this_obj,\n                               BOOL throw_ref_error)\n{\n    JSObject *p;\n    JSProperty *pr;\n    JSShapeProperty *prs;\n    uint32_t tag;\n\n    tag = JS_VALUE_GET_TAG(obj);\n    if (unlikely(tag != JS_TAG_OBJECT)) {\n        switch(tag) {\n        case JS_TAG_NULL:\n            return JS_ThrowTypeErrorAtom(ctx, \"cannot read property '%s' of null\", prop);\n        case JS_TAG_UNDEFINED:\n            return JS_ThrowTypeErrorAtom(ctx, \"cannot read property '%s' of undefined\", prop);\n        case JS_TAG_EXCEPTION:\n            return JS_EXCEPTION;\n        case JS_TAG_STRING:\n            {\n                JSString *p1 = JS_VALUE_GET_STRING(obj);\n                if (__JS_AtomIsTaggedInt(prop)) {\n                    uint32_t idx, ch;\n                    idx = __JS_AtomToUInt32(prop);\n                    if (idx < p1->len) {\n                        if (p1->is_wide_char)\n                            ch = p1->u.str16[idx];\n                        else\n                            ch = p1->u.str8[idx];\n                        return js_new_string_char(ctx, ch);\n                    }\n                } else if (prop == JS_ATOM_length) {\n                    return JS_NewInt32(ctx, p1->len);\n                }\n            }\n            break;\n        default:\n            break;\n        }\n        /* cannot raise an exception */\n        p = JS_VALUE_GET_OBJ(JS_GetPrototypePrimitive(ctx, obj));\n        if (!p)\n            return JS_UNDEFINED;\n    } else {\n        p = JS_VALUE_GET_OBJ(obj);\n    }\n\n    for(;;) {\n        prs = find_own_property(&pr, p, prop);\n        if (prs) {\n            /* found */\n            if (unlikely(prs->flags & JS_PROP_TMASK)) {\n                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                    if (unlikely(!pr->u.getset.getter)) {\n                        return JS_UNDEFINED;\n                    } else {\n                        JSValue func = JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter);\n                        /* Note: the field could be removed in the getter */\n                        func = JS_DupValue(ctx, func);\n                        return JS_CallFree(ctx, func, this_obj, 0, NULL);\n                    }\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                    JSValue val = *pr->u.var_ref->pvalue;\n                    if (unlikely(JS_IsUninitialized(val)))\n                        return JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n                    return JS_DupValue(ctx, val);\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                    /* Instantiate property and retry */\n                    if (JS_AutoInitProperty(ctx, p, prop, pr, prs))\n                        return JS_EXCEPTION;\n                    continue;\n                }\n            } else {\n                return JS_DupValue(ctx, pr->u.value);\n            }\n        }\n        if (unlikely(p->is_exotic)) {\n            /* exotic behaviors */\n            if (p->fast_array) {\n                if (__JS_AtomIsTaggedInt(prop)) {\n                    uint32_t idx = __JS_AtomToUInt32(prop);\n                    if (idx < p->u.array.count) {\n                        /* we avoid duplicating the code */\n                        return JS_GetPropertyUint32(ctx, JS_MKPTR(JS_TAG_OBJECT, p), idx);\n                    } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                               p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n                        return JS_UNDEFINED;\n                    }\n                } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                           p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n                    int ret;\n                    ret = JS_AtomIsNumericIndex(ctx, prop);\n                    if (ret != 0) {\n                        if (ret < 0)\n                            return JS_EXCEPTION;\n                        return JS_UNDEFINED;\n                    }\n                }\n            } else {\n                const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n                if (em) {\n                    if (em->get_property) {\n                        JSValue obj1, retval;\n                        /* XXX: should pass throw_ref_error */\n                        /* Note: if 'p' is a prototype, it can be\n                           freed in the called function */\n                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n                        retval = em->get_property(ctx, obj1, prop, this_obj);\n                        JS_FreeValue(ctx, obj1);\n                        return retval;\n                    }\n                    if (em->get_own_property) {\n                        JSPropertyDescriptor desc;\n                        int ret;\n                        JSValue obj1;\n\n                        /* Note: if 'p' is a prototype, it can be\n                           freed in the called function */\n                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n                        ret = em->get_own_property(ctx, &desc, obj1, prop);\n                        JS_FreeValue(ctx, obj1);\n                        if (ret < 0)\n                            return JS_EXCEPTION;\n                        if (ret) {\n                            if (desc.flags & JS_PROP_GETSET) {\n                                JS_FreeValue(ctx, desc.setter);\n                                return JS_CallFree(ctx, desc.getter, this_obj, 0, NULL);\n                            } else {\n                                return desc.value;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        p = p->shape->proto;\n        if (!p)\n            break;\n    }\n    if (unlikely(throw_ref_error)) {\n        return JS_ThrowReferenceErrorNotDefined(ctx, prop);\n    } else {\n        return JS_UNDEFINED;\n    }\n}\n\nstatic JSValue JS_ThrowTypeErrorPrivateNotFound(JSContext *ctx, JSAtom atom)\n{\n    return JS_ThrowTypeErrorAtom(ctx, \"private class field '%s' does not exist\",\n                                 atom);\n}\n\n/* Private fields can be added even on non extensible objects or\n   Proxies */\nstatic int JS_DefinePrivateField(JSContext *ctx, JSValueConst obj,\n                                 JSValueConst name, JSValue val)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSAtom prop;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        goto fail;\n    }\n    /* safety check */\n    if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL)) {\n        JS_ThrowTypeErrorNotASymbol(ctx);\n        goto fail;\n    }\n    prop = js_symbol_to_atom(ctx, (JSValue)name);\n    p = JS_VALUE_GET_OBJ(obj);\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        JS_ThrowTypeErrorAtom(ctx, \"private class field '%s' already exists\",\n                              prop);\n        goto fail;\n    }\n    pr = add_property(ctx, p, prop, JS_PROP_C_W_E);\n    if (unlikely(!pr)) {\n    fail:\n        JS_FreeValue(ctx, val);\n        return -1;\n    }\n    pr->u.value = val;\n    return 0;\n}\n\nstatic JSValue JS_GetPrivateField(JSContext *ctx, JSValueConst obj,\n                                  JSValueConst name)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSAtom prop;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    /* safety check */\n    if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL))\n        return JS_ThrowTypeErrorNotASymbol(ctx);\n    prop = js_symbol_to_atom(ctx, (JSValue)name);\n    p = JS_VALUE_GET_OBJ(obj);\n    prs = find_own_property(&pr, p, prop);\n    if (!prs) {\n        JS_ThrowTypeErrorPrivateNotFound(ctx, prop);\n        return JS_EXCEPTION;\n    }\n    return JS_DupValue(ctx, pr->u.value);\n}\n\nstatic int JS_SetPrivateField(JSContext *ctx, JSValueConst obj,\n                              JSValueConst name, JSValue val)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSAtom prop;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        goto fail;\n    }\n    /* safety check */\n    if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL)) {\n        JS_ThrowTypeErrorNotASymbol(ctx);\n        goto fail;\n    }\n    prop = js_symbol_to_atom(ctx, (JSValue)name);\n    p = JS_VALUE_GET_OBJ(obj);\n    prs = find_own_property(&pr, p, prop);\n    if (!prs) {\n        JS_ThrowTypeErrorPrivateNotFound(ctx, prop);\n    fail:\n        JS_FreeValue(ctx, val);\n        return -1;\n    }\n    set_value(ctx, &pr->u.value, val);\n    return 0;\n}\n\n/* add a private brand field to 'home_obj' if not already present and\n   if obj is != null add a private brand to it */\nstatic int JS_AddBrand(JSContext *ctx, JSValueConst obj, JSValueConst home_obj)\n{\n    JSObject *p, *p1;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSValue brand;\n    JSAtom brand_atom;\n\n    if (unlikely(JS_VALUE_GET_TAG(home_obj) != JS_TAG_OBJECT)) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    p = JS_VALUE_GET_OBJ(home_obj);\n    prs = find_own_property(&pr, p, JS_ATOM_Private_brand);\n    if (!prs) {\n        /* if the brand is not present, add it */\n        brand = JS_NewSymbolFromAtom(ctx, JS_ATOM_brand, JS_ATOM_TYPE_PRIVATE);\n        if (JS_IsException(brand))\n            return -1;\n        pr = add_property(ctx, p, JS_ATOM_Private_brand, JS_PROP_C_W_E);\n        if (!pr) {\n            JS_FreeValue(ctx, brand);\n            return -1;\n        }\n        pr->u.value = JS_DupValue(ctx, brand);\n    } else {\n        brand = JS_DupValue(ctx, pr->u.value);\n    }\n    brand_atom = js_symbol_to_atom(ctx, brand);\n\n    if (JS_IsObject(obj)) {\n        p1 = JS_VALUE_GET_OBJ(obj);\n        prs = find_own_property(&pr, p1, brand_atom);\n        if (unlikely(prs)) {\n            JS_FreeAtom(ctx, brand_atom);\n            JS_ThrowTypeError(ctx, \"private method is already present\");\n            return -1;\n        }\n        pr = add_property(ctx, p1, brand_atom, JS_PROP_C_W_E);\n        JS_FreeAtom(ctx, brand_atom);\n        if (!pr)\n            return -1;\n        pr->u.value = JS_UNDEFINED;\n    } else {\n        JS_FreeAtom(ctx, brand_atom);\n    }\n    return 0;\n}\n\n/* return a boolean telling if the brand of the home object of 'func'\n   is present on 'obj' or -1 in case of exception */\nstatic int JS_CheckBrand(JSContext *ctx, JSValueConst obj, JSValueConst func)\n{\n    JSObject *p, *p1, *home_obj;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSValueConst brand;\n\n    /* get the home object of 'func' */\n    if (unlikely(JS_VALUE_GET_TAG(func) != JS_TAG_OBJECT))\n        goto not_obj;\n    p1 = JS_VALUE_GET_OBJ(func);\n    if (!js_class_has_bytecode(p1->class_id))\n        goto not_obj;\n    home_obj = p1->u.func.home_object;\n    if (!home_obj)\n        goto not_obj;\n    prs = find_own_property(&pr, home_obj, JS_ATOM_Private_brand);\n    if (!prs) {\n        JS_ThrowTypeError(ctx, \"expecting <brand> private field\");\n        return -1;\n    }\n    brand = pr->u.value;\n    /* safety check */\n    if (unlikely(JS_VALUE_GET_TAG(brand) != JS_TAG_SYMBOL))\n        goto not_obj;\n\n    /* get the brand array of 'obj' */\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {\n    not_obj:\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    p = JS_VALUE_GET_OBJ(obj);\n    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, (JSValue)brand));\n    return (prs != NULL);\n}\n\nstatic uint32_t js_string_obj_get_length(JSContext *ctx,\n                                         JSValueConst obj)\n{\n    JSObject *p;\n    JSString *p1;\n    uint32_t len = 0;\n\n    /* This is a class exotic method: obj class_id is JS_CLASS_STRING */\n    p = JS_VALUE_GET_OBJ(obj);\n    if (JS_VALUE_GET_TAG(p->u.object_data) == JS_TAG_STRING) {\n        p1 = JS_VALUE_GET_STRING(p->u.object_data);\n        len = p1->len;\n    }\n    return len;\n}\n\nstatic int num_keys_cmp(const void *p1, const void *p2, void *opaque)\n{\n    JSContext *ctx = opaque;\n    JSAtom atom1 = ((const JSPropertyEnum *)p1)->atom;\n    JSAtom atom2 = ((const JSPropertyEnum *)p2)->atom;\n    uint32_t v1, v2;\n    BOOL atom1_is_integer, atom2_is_integer;\n\n    atom1_is_integer = JS_AtomIsArrayIndex(ctx, &v1, atom1);\n    atom2_is_integer = JS_AtomIsArrayIndex(ctx, &v2, atom2);\n    assert(atom1_is_integer && atom2_is_integer);\n    if (v1 < v2)\n        return -1;\n    else if (v1 == v2)\n        return 0;\n    else\n        return 1;\n}\n\nstatic void js_free_prop_enum(JSContext *ctx, JSPropertyEnum *tab, uint32_t len)\n{\n    uint32_t i;\n    if (tab) {\n        for(i = 0; i < len; i++)\n            JS_FreeAtom(ctx, tab[i].atom);\n        js_free(ctx, tab);\n    }\n}\n\n/* return < 0 in case if exception, 0 if OK. ptab and its atoms must\n   be freed by the user. */\nstatic int __exception JS_GetOwnPropertyNamesInternal(JSContext *ctx,\n                                                      JSPropertyEnum **ptab,\n                                                      uint32_t *plen,\n                                                      JSObject *p, int flags)\n{\n    int i, j;\n    JSShape *sh;\n    JSShapeProperty *prs;\n    JSPropertyEnum *tab_atom, *tab_exotic;\n    JSAtom atom;\n    uint32_t num_keys_count, str_keys_count, sym_keys_count, atom_count;\n    uint32_t num_index, str_index, sym_index, exotic_count, exotic_keys_count;\n    BOOL is_enumerable, num_sorted;\n    uint32_t num_key;\n    JSAtomKindEnum kind;\n\n    /* clear pointer for consistency in case of failure */\n    *ptab = NULL;\n    *plen = 0;\n\n    /* compute the number of returned properties */\n    num_keys_count = 0;\n    str_keys_count = 0;\n    sym_keys_count = 0;\n    exotic_keys_count = 0;\n    exotic_count = 0;\n    tab_exotic = NULL;\n    sh = p->shape;\n    for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {\n        atom = prs->atom;\n        if (atom != JS_ATOM_NULL) {\n            is_enumerable = ((prs->flags & JS_PROP_ENUMERABLE) != 0);\n            kind = JS_AtomGetKind(ctx, atom);\n            if ((!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) &&\n                ((flags >> kind) & 1) != 0) {\n                /* need to raise an exception in case of the module\n                   name space (implicit GetOwnProperty) */\n                if (unlikely((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) &&\n                    (flags & (JS_GPN_SET_ENUM | JS_GPN_ENUM_ONLY))) {\n                    JSVarRef *var_ref = p->prop[i].u.var_ref;\n                    if (unlikely(JS_IsUninitialized(*var_ref->pvalue))) {\n                        JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n                        return -1;\n                    }\n                }\n                if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {\n                    num_keys_count++;\n                } else if (kind == JS_ATOM_KIND_STRING) {\n                    str_keys_count++;\n                } else {\n                    sym_keys_count++;\n                }\n            }\n        }\n    }\n\n    if (p->is_exotic) {\n        if (p->fast_array) {\n            if (flags & JS_GPN_STRING_MASK) {\n                num_keys_count += p->u.array.count;\n            }\n        } else if (p->class_id == JS_CLASS_STRING) {\n            if (flags & JS_GPN_STRING_MASK) {\n                num_keys_count += js_string_obj_get_length(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n            }\n        } else {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em && em->get_own_property_names) {\n                if (em->get_own_property_names(ctx, &tab_exotic, &exotic_count,\n                                               JS_MKPTR(JS_TAG_OBJECT, p)))\n                    return -1;\n                for(i = 0; i < exotic_count; i++) {\n                    atom = tab_exotic[i].atom;\n                    kind = JS_AtomGetKind(ctx, atom);\n                    if (((flags >> kind) & 1) != 0) {\n                        is_enumerable = FALSE;\n                        if (flags & (JS_GPN_SET_ENUM | JS_GPN_ENUM_ONLY)) {\n                            JSPropertyDescriptor desc;\n                            int res;\n                            /* set the \"is_enumerable\" field if necessary */\n                            res = JS_GetOwnPropertyInternal(ctx, &desc, p, atom);\n                            if (res < 0) {\n                                js_free_prop_enum(ctx, tab_exotic, exotic_count);\n                                return -1;\n                            }\n                            if (res) {\n                                is_enumerable =\n                                    ((desc.flags & JS_PROP_ENUMERABLE) != 0);\n                                js_free_desc(ctx, &desc);\n                            }\n                            tab_exotic[i].is_enumerable = is_enumerable;\n                        }\n                        if (!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) {\n                            exotic_keys_count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /* fill them */\n\n    atom_count = num_keys_count + str_keys_count + sym_keys_count + exotic_keys_count;\n    /* avoid allocating 0 bytes */\n    tab_atom = js_malloc(ctx, sizeof(tab_atom[0]) * max_int(atom_count, 1));\n    if (!tab_atom) {\n        js_free_prop_enum(ctx, tab_exotic, exotic_count);\n        return -1;\n    }\n\n    num_index = 0;\n    str_index = num_keys_count;\n    sym_index = str_index + str_keys_count;\n\n    num_sorted = TRUE;\n    sh = p->shape;\n    for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {\n        atom = prs->atom;\n        if (atom != JS_ATOM_NULL) {\n            is_enumerable = ((prs->flags & JS_PROP_ENUMERABLE) != 0);\n            kind = JS_AtomGetKind(ctx, atom);\n            if ((!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) &&\n                ((flags >> kind) & 1) != 0) {\n                if (JS_AtomIsArrayIndex(ctx, &num_key, atom)) {\n                    j = num_index++;\n                    num_sorted = FALSE;\n                } else if (kind == JS_ATOM_KIND_STRING) {\n                    j = str_index++;\n                } else {\n                    j = sym_index++;\n                }\n                tab_atom[j].atom = JS_DupAtom(ctx, atom);\n                tab_atom[j].is_enumerable = is_enumerable;\n            }\n        }\n    }\n\n    if (p->is_exotic) {\n        int len;\n        if (p->fast_array) {\n            if (flags & JS_GPN_STRING_MASK) {\n                len = p->u.array.count;\n                goto add_array_keys;\n            }\n        } else if (p->class_id == JS_CLASS_STRING) {\n            if (flags & JS_GPN_STRING_MASK) {\n                len = js_string_obj_get_length(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n            add_array_keys:\n                for(i = 0; i < len; i++) {\n                    tab_atom[num_index].atom = __JS_AtomFromUInt32(i);\n                    if (tab_atom[num_index].atom == JS_ATOM_NULL) {\n                        js_free_prop_enum(ctx, tab_atom, num_index);\n                        return -1;\n                    }\n                    tab_atom[num_index].is_enumerable = TRUE;\n                    num_index++;\n                }\n            }\n        } else {\n            /* Note: exotic keys are not reordered and comes after the object own properties. */\n            for(i = 0; i < exotic_count; i++) {\n                atom = tab_exotic[i].atom;\n                is_enumerable = tab_exotic[i].is_enumerable;\n                kind = JS_AtomGetKind(ctx, atom);\n                if ((!(flags & JS_GPN_ENUM_ONLY) || is_enumerable) &&\n                    ((flags >> kind) & 1) != 0) {\n                    tab_atom[sym_index].atom = atom;\n                    tab_atom[sym_index].is_enumerable = is_enumerable;\n                    sym_index++;\n                } else {\n                    JS_FreeAtom(ctx, atom);\n                }\n            }\n            js_free(ctx, tab_exotic);\n        }\n    }\n\n    assert(num_index == num_keys_count);\n    assert(str_index == num_keys_count + str_keys_count);\n    assert(sym_index == atom_count);\n\n    if (num_keys_count != 0 && !num_sorted) {\n        rqsort(tab_atom, num_keys_count, sizeof(tab_atom[0]), num_keys_cmp,\n               ctx);\n    }\n    *ptab = tab_atom;\n    *plen = atom_count;\n    return 0;\n}\n\nint JS_GetOwnPropertyNames(JSContext *ctx, JSPropertyEnum **ptab,\n                           uint32_t *plen, JSValueConst obj, int flags)\n{\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    return JS_GetOwnPropertyNamesInternal(ctx, ptab, plen,\n                                          JS_VALUE_GET_OBJ(obj), flags);\n}\n\n/* Return -1 if exception,\n   FALSE if the property does not exist, TRUE if it exists. If TRUE is\n   returned, the property descriptor 'desc' is filled present. */\nstatic int JS_GetOwnPropertyInternal(JSContext *ctx, JSPropertyDescriptor *desc,\n                                     JSObject *p, JSAtom prop)\n{\n    JSShapeProperty *prs;\n    JSProperty *pr;\n\nretry:\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        if (desc) {\n            desc->flags = prs->flags & JS_PROP_C_W_E;\n            desc->getter = JS_UNDEFINED;\n            desc->setter = JS_UNDEFINED;\n            desc->value = JS_UNDEFINED;\n            if (unlikely(prs->flags & JS_PROP_TMASK)) {\n                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                    desc->flags |= JS_PROP_GETSET;\n                    if (pr->u.getset.getter)\n                        desc->getter = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));\n                    if (pr->u.getset.setter)\n                        desc->setter = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                    JSValue val = *pr->u.var_ref->pvalue;\n                    if (unlikely(JS_IsUninitialized(val))) {\n                        JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n                        return -1;\n                    }\n                    desc->value = JS_DupValue(ctx, val);\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                    /* Instantiate property and retry */\n                    if (JS_AutoInitProperty(ctx, p, prop, pr, prs))\n                        return -1;\n                    goto retry;\n                }\n            } else {\n                desc->value = JS_DupValue(ctx, pr->u.value);\n            }\n        } else {\n            /* for consistency, send the exception even if desc is NULL */\n            if (unlikely((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF)) {\n                if (unlikely(JS_IsUninitialized(*pr->u.var_ref->pvalue))) {\n                    JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n                    return -1;\n                }\n            } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                /* nothing to do: delay instantiation until actual value and/or attributes are read */\n            }\n        }\n        return TRUE;\n    }\n    if (p->is_exotic) {\n        if (p->fast_array) {\n            /* specific case for fast arrays */\n            if (__JS_AtomIsTaggedInt(prop)) {\n                uint32_t idx;\n                idx = __JS_AtomToUInt32(prop);\n                if (idx < p->u.array.count) {\n                    if (desc) {\n                        desc->flags = JS_PROP_WRITABLE | JS_PROP_ENUMERABLE |\n                            JS_PROP_CONFIGURABLE;\n                        desc->getter = JS_UNDEFINED;\n                        desc->setter = JS_UNDEFINED;\n                        desc->value = JS_GetPropertyUint32(ctx, JS_MKPTR(JS_TAG_OBJECT, p), idx);\n                    }\n                    return TRUE;\n                }\n            }\n        } else {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em && em->get_own_property) {\n                return em->get_own_property(ctx, desc,\n                                            JS_MKPTR(JS_TAG_OBJECT, p), prop);\n            }\n        }\n    }\n    return FALSE;\n}\n\nint JS_GetOwnProperty(JSContext *ctx, JSPropertyDescriptor *desc,\n                      JSValueConst obj, JSAtom prop)\n{\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    return JS_GetOwnPropertyInternal(ctx, desc, JS_VALUE_GET_OBJ(obj), prop);\n}\n\n/* return -1 if exception (Proxy object only) or TRUE/FALSE */\nint JS_IsExtensible(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (unlikely(p->class_id == JS_CLASS_PROXY))\n        return js_proxy_isExtensible(ctx, obj);\n    else\n        return p->extensible;\n}\n\n/* return -1 if exception (Proxy object only) or TRUE/FALSE */\nint JS_PreventExtensions(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (unlikely(p->class_id == JS_CLASS_PROXY))\n        return js_proxy_preventExtensions(ctx, obj);\n    p->extensible = FALSE;\n    return TRUE;\n}\n\n/* return -1 if exception otherwise TRUE or FALSE */\nint JS_HasProperty(JSContext *ctx, JSValueConst obj, JSAtom prop)\n{\n    JSObject *p;\n    int ret;\n    JSValue obj1;\n\n    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    for(;;) {\n        if (p->is_exotic) {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em && em->has_property) {\n                /* has_property can free the prototype */\n                obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n                ret = em->has_property(ctx, obj1, prop);\n                JS_FreeValue(ctx, obj1);\n                return ret;\n            }\n        }\n        /* JS_GetOwnPropertyInternal can free the prototype */\n        JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n        ret = JS_GetOwnPropertyInternal(ctx, NULL, p, prop);\n        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n        if (ret != 0)\n            return ret;\n        if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n            p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n            ret = JS_AtomIsNumericIndex(ctx, prop);\n            if (ret != 0) {\n                if (ret < 0)\n                    return -1;\n                return FALSE;\n            }\n        }\n        p = p->shape->proto;\n        if (!p)\n            break;\n    }\n    return FALSE;\n}\n\n/* val must be a symbol */\nstatic JSAtom js_symbol_to_atom(JSContext *ctx, JSValue val)\n{\n    JSAtomStruct *p = JS_VALUE_GET_PTR(val);\n    return js_get_atom_index(ctx->rt, p);\n}\n\n/* return JS_ATOM_NULL in case of exception */\nJSAtom JS_ValueToAtom(JSContext *ctx, JSValueConst val)\n{\n    JSAtom atom;\n    uint32_t tag;\n    tag = JS_VALUE_GET_TAG(val);\n    if (tag == JS_TAG_INT &&\n        (uint32_t)JS_VALUE_GET_INT(val) <= JS_ATOM_MAX_INT) {\n        /* fast path for integer values */\n        atom = __JS_AtomFromUInt32(JS_VALUE_GET_INT(val));\n    } else if (tag == JS_TAG_SYMBOL) {\n        JSAtomStruct *p = JS_VALUE_GET_PTR(val);\n        atom = JS_DupAtom(ctx, js_get_atom_index(ctx->rt, p));\n    } else {\n        JSValue str;\n        str = JS_ToPropertyKey(ctx, val);\n        if (JS_IsException(str))\n            return JS_ATOM_NULL;\n        if (JS_VALUE_GET_TAG(str) == JS_TAG_SYMBOL) {\n            atom = js_symbol_to_atom(ctx, str);\n        } else {\n            atom = JS_NewAtomStr(ctx, JS_VALUE_GET_STRING(str));\n        }\n    }\n    return atom;\n}\n\nstatic JSValue JS_GetPropertyValue(JSContext *ctx, JSValueConst this_obj,\n                                   JSValue prop)\n{\n    JSAtom atom;\n    JSValue ret;\n\n    if (likely(JS_VALUE_GET_TAG(this_obj) == JS_TAG_OBJECT &&\n               JS_VALUE_GET_TAG(prop) == JS_TAG_INT)) {\n        JSObject *p;\n        uint32_t idx;\n        /* fast path for array access */\n        p = JS_VALUE_GET_OBJ(this_obj);\n        idx = JS_VALUE_GET_INT(prop);\n        switch(p->class_id) {\n        case JS_CLASS_ARRAY:\n        case JS_CLASS_ARGUMENTS:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return JS_DupValue(ctx, p->u.array.u.values[idx]);\n        case JS_CLASS_INT8_ARRAY:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return JS_NewInt32(ctx, p->u.array.u.int8_ptr[idx]);\n        case JS_CLASS_UINT8C_ARRAY:\n        case JS_CLASS_UINT8_ARRAY:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return JS_NewInt32(ctx, p->u.array.u.uint8_ptr[idx]);\n        case JS_CLASS_INT16_ARRAY:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return JS_NewInt32(ctx, p->u.array.u.int16_ptr[idx]);\n        case JS_CLASS_UINT16_ARRAY:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return JS_NewInt32(ctx, p->u.array.u.uint16_ptr[idx]);\n        case JS_CLASS_INT32_ARRAY:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return JS_NewInt32(ctx, p->u.array.u.int32_ptr[idx]);\n        case JS_CLASS_UINT32_ARRAY:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return JS_NewUint32(ctx, p->u.array.u.uint32_ptr[idx]);\n        case JS_CLASS_BIG_INT64_ARRAY:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return JS_NewBigInt64(ctx, p->u.array.u.int64_ptr[idx]);\n        case JS_CLASS_BIG_UINT64_ARRAY:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return JS_NewBigUint64(ctx, p->u.array.u.uint64_ptr[idx]);\n        case JS_CLASS_FLOAT32_ARRAY:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return __JS_NewFloat64(ctx, p->u.array.u.float_ptr[idx]);\n        case JS_CLASS_FLOAT64_ARRAY:\n            if (unlikely(idx >= p->u.array.count)) goto slow_path;\n            return __JS_NewFloat64(ctx, p->u.array.u.double_ptr[idx]);\n        default:\n            goto slow_path;\n        }\n    } else {\n    slow_path:\n        atom = JS_ValueToAtom(ctx, prop);\n        JS_FreeValue(ctx, prop);\n        if (unlikely(atom == JS_ATOM_NULL))\n            return JS_EXCEPTION;\n        ret = JS_GetProperty(ctx, this_obj, atom);\n        JS_FreeAtom(ctx, atom);\n        return ret;\n    }\n}\n\nJSValue JS_GetPropertyUint32(JSContext *ctx, JSValueConst this_obj,\n                             uint32_t idx)\n{\n    return JS_GetPropertyValue(ctx, this_obj, JS_NewUint32(ctx, idx));\n}\n\n/* Check if an object has a generalized numeric property. Return value:\n   -1 for exception,\n   TRUE if property exists, stored into *pval,\n   FALSE if proprty does not exist.\n */\nstatic int JS_TryGetPropertyInt64(JSContext *ctx, JSValueConst obj, int64_t idx, JSValue *pval)\n{\n    JSValue val = JS_UNDEFINED;\n    JSAtom prop;\n    int present;\n\n    if (likely((uint64_t)idx <= JS_ATOM_MAX_INT)) {\n        /* fast path */\n        present = JS_HasProperty(ctx, obj, __JS_AtomFromUInt32(idx));\n        if (present > 0) {\n            val = JS_GetPropertyValue(ctx, obj, JS_NewInt32(ctx, idx));\n            if (unlikely(JS_IsException(val)))\n                present = -1;\n        }\n    } else {\n        prop = JS_NewAtomInt64(ctx, idx);\n        present = -1;\n        if (likely(prop != JS_ATOM_NULL)) {\n            present = JS_HasProperty(ctx, obj, prop);\n            if (present > 0) {\n                val = JS_GetProperty(ctx, obj, prop);\n                if (unlikely(JS_IsException(val)))\n                    present = -1;\n            }\n            JS_FreeAtom(ctx, prop);\n        }\n    }\n    *pval = val;\n    return present;\n}\n\nstatic JSValue JS_GetPropertyInt64(JSContext *ctx, JSValueConst obj, int64_t idx)\n{\n    JSAtom prop;\n    JSValue val;\n\n    if ((uint64_t)idx <= INT32_MAX) {\n        /* fast path for fast arrays */\n        return JS_GetPropertyValue(ctx, obj, JS_NewInt32(ctx, idx));\n    }\n    prop = JS_NewAtomInt64(ctx, idx);\n    if (prop == JS_ATOM_NULL)\n        return JS_EXCEPTION;\n\n    val = JS_GetProperty(ctx, obj, prop);\n    JS_FreeAtom(ctx, prop);\n    return val;\n}\n\nJSValue JS_GetPropertyStr(JSContext *ctx, JSValueConst this_obj,\n                          const char *prop)\n{\n    JSAtom atom;\n    JSValue ret;\n    atom = JS_NewAtom(ctx, prop);\n    ret = JS_GetProperty(ctx, this_obj, atom);\n    JS_FreeAtom(ctx, atom);\n    return ret;\n}\n\n/* Note: the property value is not initialized. Return NULL if memory\n   error. */\nstatic JSProperty *add_property(JSContext *ctx,\n                                JSObject *p, JSAtom prop, int prop_flags)\n{\n    JSShape *sh, *new_sh;\n\n    sh = p->shape;\n    if (sh->is_hashed) {\n        /* try to find an existing shape */\n        new_sh = find_hashed_shape_prop(ctx->rt, sh, prop, prop_flags);\n        if (new_sh) {\n            /* matching shape found: use it */\n            /*  the property array may need to be resized */\n            if (new_sh->prop_size != sh->prop_size) {\n                JSProperty *new_prop;\n                new_prop = js_realloc(ctx, p->prop, sizeof(p->prop[0]) *\n                                      new_sh->prop_size);\n                if (!new_prop)\n                    return NULL;\n                p->prop = new_prop;\n            }\n            p->shape = js_dup_shape(new_sh);\n            js_free_shape(ctx->rt, sh);\n            return &p->prop[new_sh->prop_count - 1];\n        } else if (sh->header.ref_count != 1) {\n            /* if the shape is shared, clone it */\n            new_sh = js_clone_shape(ctx, sh);\n            if (!new_sh)\n                return NULL;\n            /* hash the cloned shape */\n            new_sh->is_hashed = TRUE;\n            js_shape_hash_link(ctx->rt, new_sh);\n            js_free_shape(ctx->rt, p->shape);\n            p->shape = new_sh;\n        }\n    }\n    assert(p->shape->header.ref_count == 1);\n    if (add_shape_property(ctx, &p->shape, p, prop, prop_flags))\n        return NULL;\n    return &p->prop[p->shape->prop_count - 1];\n}\n\n/* can be called on Array or Arguments objects. return < 0 if\n   memory alloc error. */\nstatic no_inline __exception int convert_fast_array_to_array(JSContext *ctx,\n                                                             JSObject *p)\n{\n    JSProperty *pr;\n    JSShape *sh;\n    JSValue *tab;\n    uint32_t i, len, new_count;\n\n    if (js_shape_prepare_update(ctx, p, NULL))\n        return -1;\n    len = p->u.array.count;\n    /* resize the properties once to simplify the error handling */\n    sh = p->shape;\n    new_count = sh->prop_count + len;\n    if (new_count > sh->prop_size) {\n        if (resize_properties(ctx, &p->shape, p, new_count))\n            return -1;\n    }\n\n    tab = p->u.array.u.values;\n    for(i = 0; i < len; i++) {\n        /* add_property cannot fail here but\n           __JS_AtomFromUInt32(i) fails for i > INT32_MAX */\n        pr = add_property(ctx, p, __JS_AtomFromUInt32(i), JS_PROP_C_W_E);\n        pr->u.value = *tab++;\n    }\n    js_free(ctx, p->u.array.u.values);\n    p->u.array.count = 0;\n    p->u.array.u.values = NULL; /* fail safe */\n    p->u.array.u1.size = 0;\n    p->fast_array = 0;\n    return 0;\n}\n\nstatic int delete_property(JSContext *ctx, JSObject *p, JSAtom atom)\n{\n    JSShape *sh;\n    JSShapeProperty *pr, *lpr, *prop;\n    JSProperty *pr1;\n    uint32_t lpr_idx;\n    intptr_t h, h1;\n\n redo:\n    sh = p->shape;\n    h1 = atom & sh->prop_hash_mask;\n    h = prop_hash_end(sh)[-h1 - 1];\n    prop = get_shape_prop(sh);\n    lpr = NULL;\n    lpr_idx = 0;   /* prevent warning */\n    while (h != 0) {\n        pr = &prop[h - 1];\n        if (likely(pr->atom == atom)) {\n            /* found ! */\n            if (!(pr->flags & JS_PROP_CONFIGURABLE))\n                return FALSE;\n            /* realloc the shape if needed */\n            if (lpr)\n                lpr_idx = lpr - get_shape_prop(sh);\n            if (js_shape_prepare_update(ctx, p, &pr))\n                return -1;\n            sh = p->shape;\n            /* remove property */\n            if (lpr) {\n                lpr = get_shape_prop(sh) + lpr_idx;\n                lpr->hash_next = pr->hash_next;\n            } else {\n                prop_hash_end(sh)[-h1 - 1] = pr->hash_next;\n            }\n            sh->deleted_prop_count++;\n            /* free the entry */\n            pr1 = &p->prop[h - 1];\n            free_property(ctx->rt, pr1, pr->flags);\n            JS_FreeAtom(ctx, pr->atom);\n            /* put default values */\n            pr->flags = 0;\n            pr->atom = JS_ATOM_NULL;\n            pr1->u.value = JS_UNDEFINED;\n\n            /* compact the properties if too many deleted properties */\n            if (sh->deleted_prop_count >= 8 &&\n                sh->deleted_prop_count >= ((unsigned)sh->prop_count / 2)) {\n                compact_properties(ctx, p);\n            }\n            return TRUE;\n        }\n        lpr = pr;\n        h = pr->hash_next;\n    }\n\n    if (p->is_exotic) {\n        if (p->fast_array) {\n            uint32_t idx;\n            if (JS_AtomIsArrayIndex(ctx, &idx, atom) &&\n                idx < p->u.array.count) {\n                if (p->class_id == JS_CLASS_ARRAY ||\n                    p->class_id == JS_CLASS_ARGUMENTS) {\n                    /* Special case deleting the last element of a fast Array */\n                    if (idx == p->u.array.count - 1) {\n                        JS_FreeValue(ctx, p->u.array.u.values[idx]);\n                        p->u.array.count = idx;\n                        return TRUE;\n                    }\n                    if (convert_fast_array_to_array(ctx, p))\n                        return -1;\n                    goto redo;\n                } else {\n                    return FALSE;\n                }\n            }\n        } else {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em && em->delete_property) {\n                return em->delete_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p), atom);\n            }\n        }\n    }\n    /* not found */\n    return TRUE;\n}\n\nstatic int call_setter(JSContext *ctx, JSObject *setter,\n                       JSValueConst this_obj, JSValue val, int flags)\n{\n    JSValue ret, func;\n    if (likely(setter)) {\n        func = JS_MKPTR(JS_TAG_OBJECT, setter);\n        /* Note: the field could be removed in the setter */\n        func = JS_DupValue(ctx, func);\n        ret = JS_CallFree(ctx, func, this_obj, 1, (JSValueConst *)&val);\n        JS_FreeValue(ctx, val);\n        if (JS_IsException(ret))\n            return -1;\n        JS_FreeValue(ctx, ret);\n        return TRUE;\n    } else {\n        JS_FreeValue(ctx, val);\n        if ((flags & JS_PROP_THROW) ||\n            ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {\n            JS_ThrowTypeError(ctx, \"no setter for property\");\n            return -1;\n        }\n        return FALSE;\n    }\n}\n\n/* set the array length and remove the array elements if necessary. */\nstatic int set_array_length(JSContext *ctx, JSObject *p, JSValue val,\n                            int flags)\n{\n    uint32_t len, idx, cur_len;\n    int i, ret;\n\n    /* Note: this call can reallocate the properties of 'p' */\n    ret = JS_ToArrayLengthFree(ctx, &len, val, FALSE);\n    if (ret)\n        return -1;\n    /* JS_ToArrayLengthFree() must be done before the read-only test */\n    if (unlikely(!(p->shape->prop[0].flags & JS_PROP_WRITABLE)))\n        return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);\n\n    if (likely(p->fast_array)) {\n        uint32_t old_len = p->u.array.count;\n        if (len < old_len) {\n            for(i = len; i < old_len; i++) {\n                JS_FreeValue(ctx, p->u.array.u.values[i]);\n            }\n            p->u.array.count = len;\n        }\n        p->prop[0].u.value = JS_NewUint32(ctx, len);\n    } else {\n        /* Note: length is always a uint32 because the object is an\n           array */\n        JS_ToUint32(ctx, &cur_len, p->prop[0].u.value);\n        if (len < cur_len) {\n            uint32_t d;\n            JSShape *sh;\n            JSShapeProperty *pr;\n\n            d = cur_len - len;\n            sh = p->shape;\n            if (d <= sh->prop_count) {\n                JSAtom atom;\n\n                /* faster to iterate */\n                while (cur_len > len) {\n                    atom = JS_NewAtomUInt32(ctx, cur_len - 1);\n                    ret = delete_property(ctx, p, atom);\n                    JS_FreeAtom(ctx, atom);\n                    if (unlikely(!ret)) {\n                        /* unlikely case: property is not\n                           configurable */\n                        break;\n                    }\n                    cur_len--;\n                }\n            } else {\n                /* faster to iterate thru all the properties. Need two\n                   passes in case one of the property is not\n                   configurable */\n                cur_len = len;\n                for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count;\n                    i++, pr++) {\n                    if (pr->atom != JS_ATOM_NULL &&\n                        JS_AtomIsArrayIndex(ctx, &idx, pr->atom)) {\n                        if (idx >= cur_len &&\n                            !(pr->flags & JS_PROP_CONFIGURABLE)) {\n                            cur_len = idx + 1;\n                        }\n                    }\n                }\n\n                for(i = 0, pr = get_shape_prop(sh); i < sh->prop_count;\n                    i++, pr++) {\n                    if (pr->atom != JS_ATOM_NULL &&\n                        JS_AtomIsArrayIndex(ctx, &idx, pr->atom)) {\n                        if (idx >= cur_len) {\n                            /* remove the property */\n                            delete_property(ctx, p, pr->atom);\n                            /* WARNING: the shape may have been modified */\n                            sh = p->shape;\n                            pr = get_shape_prop(sh) + i;\n                        }\n                    }\n                }\n            }\n        } else {\n            cur_len = len;\n        }\n        set_value(ctx, &p->prop[0].u.value, JS_NewUint32(ctx, cur_len));\n        if (unlikely(cur_len > len)) {\n            return JS_ThrowTypeErrorOrFalse(ctx, flags, \"not configurable\");\n        }\n    }\n    return TRUE;\n}\n\n/* return -1 if exception */\nstatic int expand_fast_array(JSContext *ctx, JSObject *p, uint32_t new_len)\n{\n    uint32_t new_size;\n    size_t slack;\n    JSValue *new_array_prop;\n    /* XXX: potential arithmetic overflow */\n    new_size = max_int(new_len, p->u.array.u1.size * 3 / 2);\n    new_array_prop = js_realloc2(ctx, p->u.array.u.values, sizeof(JSValue) * new_size, &slack);\n    if (!new_array_prop)\n        return -1;\n    new_size += slack / sizeof(*new_array_prop);\n    p->u.array.u.values = new_array_prop;\n    p->u.array.u1.size = new_size;\n    return 0;\n}\n\n/* Preconditions: 'p' must be of class JS_CLASS_ARRAY, p->fast_array =\n   TRUE and p->extensible = TRUE */\nstatic int add_fast_array_element(JSContext *ctx, JSObject *p,\n                                  JSValue val, int flags)\n{\n    uint32_t new_len, array_len;\n    /* extend the array by one */\n    /* XXX: convert to slow array if new_len > 2^31-1 elements */\n    new_len = p->u.array.count + 1;\n    /* update the length if necessary. We assume that if the length is\n       not an integer, then if it >= 2^31.  */\n    if (likely(JS_VALUE_GET_TAG(p->prop[0].u.value) == JS_TAG_INT)) {\n        array_len = JS_VALUE_GET_INT(p->prop[0].u.value);\n        if (new_len > array_len) {\n            if (unlikely(!(get_shape_prop(p->shape)->flags & JS_PROP_WRITABLE))) {\n                JS_FreeValue(ctx, val);\n                return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);\n            }\n            p->prop[0].u.value = JS_NewInt32(ctx, new_len);\n        }\n    }\n    if (unlikely(new_len > p->u.array.u1.size)) {\n        if (expand_fast_array(ctx, p, new_len)) {\n            JS_FreeValue(ctx, val);\n            return -1;\n        }\n    }\n    p->u.array.u.values[new_len - 1] = val;\n    p->u.array.count = new_len;\n    return TRUE;\n}\n\n/* Allocate a new fast array. Its 'length' property is set to zero. It\n   maximum size is 2^31-1 elements. For convenience, 'len' is a 64 bit\n   integer. WARNING: the content of the array is not initialized. */\nstatic JSValue js_allocate_fast_array(JSContext *ctx, int64_t len)\n{\n    JSValue arr;\n    JSObject *p;\n\n    if (len > INT32_MAX)\n        return JS_ThrowRangeError(ctx, \"invalid array length\");\n    arr = JS_NewArray(ctx);\n    if (JS_IsException(arr))\n        return arr;\n    if (len > 0) {\n        p = JS_VALUE_GET_OBJ(arr);\n        if (expand_fast_array(ctx, p, len) < 0) {\n            JS_FreeValue(ctx, arr);\n            return JS_EXCEPTION;\n        }\n        p->u.array.count = len;\n    }\n    return arr;\n}\n\nstatic void js_free_desc(JSContext *ctx, JSPropertyDescriptor *desc)\n{\n    JS_FreeValue(ctx, desc->getter);\n    JS_FreeValue(ctx, desc->setter);\n    JS_FreeValue(ctx, desc->value);\n}\n\n/* return -1 in case of exception or TRUE or FALSE. Warning: 'val' is\n   freed by the function. 'flags' is a bitmask of JS_PROP_NO_ADD,\n   JS_PROP_THROW or JS_PROP_THROW_STRICT. If JS_PROP_NO_ADD is set,\n   the new property is not added and an error is raised. 'this_obj' is\n   the receiver. If obj != this_obj, then obj must be an object\n   (Reflect.set case). */\nint JS_SetPropertyInternal(JSContext *ctx, JSValueConst obj,\n                           JSAtom prop, JSValue val, JSValueConst this_obj, int flags)\n{\n    JSObject *p, *p1;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    uint32_t tag;\n    JSPropertyDescriptor desc;\n    int ret;\n#if 0\n    printf(\"JS_SetPropertyInternal: \"); print_atom(ctx, prop); printf(\"\\n\");\n#endif\n    tag = JS_VALUE_GET_TAG(this_obj);\n    if (unlikely(tag != JS_TAG_OBJECT)) {\n        if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n            p = NULL;\n            p1 = JS_VALUE_GET_OBJ(obj);\n            goto prototype_lookup;\n        } else {\n            switch(tag) {\n            case JS_TAG_NULL:\n                JS_FreeValue(ctx, val);\n                JS_ThrowTypeErrorAtom(ctx, \"cannot set property '%s' of null\", prop);\n                return -1;\n            case JS_TAG_UNDEFINED:\n                JS_FreeValue(ctx, val);\n                JS_ThrowTypeErrorAtom(ctx, \"cannot set property '%s' of undefined\", prop);\n                return -1;\n            default:\n                /* even on a primitive type we can have setters on the prototype */\n                p = NULL;\n                p1 = JS_VALUE_GET_OBJ(JS_GetPrototypePrimitive(ctx, obj));\n                goto prototype_lookup;\n            }\n        }\n    } else {\n        p = JS_VALUE_GET_OBJ(this_obj);\n        p1 = JS_VALUE_GET_OBJ(obj);\n        if (unlikely(p != p1))\n            goto retry2;\n    }\n\n    /* fast path if obj == this_obj */\n retry:\n    prs = find_own_property(&pr, p1, prop);\n    if (prs) {\n        if (likely((prs->flags & (JS_PROP_TMASK | JS_PROP_WRITABLE |\n                                  JS_PROP_LENGTH)) == JS_PROP_WRITABLE)) {\n            /* fast case */\n            set_value(ctx, &pr->u.value, val);\n            return TRUE;\n        } else if (prs->flags & JS_PROP_LENGTH) {\n            assert(p->class_id == JS_CLASS_ARRAY);\n            assert(prop == JS_ATOM_length);\n            return set_array_length(ctx, p, val, flags);\n        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n            return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);\n        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n            /* JS_PROP_WRITABLE is always true for variable\n               references, but they are write protected in module name\n               spaces. */\n            if (p->class_id == JS_CLASS_MODULE_NS)\n                goto read_only_prop;\n            set_value(ctx, pr->u.var_ref->pvalue, val);\n            return TRUE;\n        } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n            /* Instantiate property and retry (potentially useless) */\n            if (JS_AutoInitProperty(ctx, p, prop, pr, prs)) {\n                JS_FreeValue(ctx, val);\n                return -1;\n            }\n            goto retry;\n        } else {\n            goto read_only_prop;\n        }\n    }\n\n    for(;;) {\n        if (p1->is_exotic) {\n            if (p1->fast_array) {\n                if (__JS_AtomIsTaggedInt(prop)) {\n                    uint32_t idx = __JS_AtomToUInt32(prop);\n                    if (idx < p1->u.array.count) {\n                        if (unlikely(p == p1))\n                            return JS_SetPropertyValue(ctx, this_obj, JS_NewInt32(ctx, idx), val, flags);\n                        else\n                            break;\n                    } else if (p1->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                               p1->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n                        goto typed_array_oob;\n                    }\n                } else if (p1->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                           p1->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n                    ret = JS_AtomIsNumericIndex(ctx, prop);\n                    if (ret != 0) {\n                        if (ret < 0) {\n                            JS_FreeValue(ctx, val);\n                            return -1;\n                        }\n                    typed_array_oob:\n                        /* must convert the argument even if out of bound access */\n                        if (p1->class_id == JS_CLASS_BIG_INT64_ARRAY ||\n                            p1->class_id == JS_CLASS_BIG_UINT64_ARRAY) {\n                            int64_t v;\n                            if (JS_ToBigInt64Free(ctx, &v, val))\n                                return -1;\n                        } else {\n                            val = JS_ToNumberFree(ctx, val);\n                            JS_FreeValue(ctx, val);\n                            if (JS_IsException(val))\n                                return -1;\n                        }\n                        return TRUE;\n                    }\n                }\n            } else {\n                const JSClassExoticMethods *em = ctx->rt->class_array[p1->class_id].exotic;\n                if (em) {\n                    JSValue obj1;\n                    if (em->set_property) {\n                        /* set_property can free the prototype */\n                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));\n                        ret = em->set_property(ctx, obj1, prop,\n                                               val, this_obj, flags);\n                        JS_FreeValue(ctx, obj1);\n                        JS_FreeValue(ctx, val);\n                        return ret;\n                    }\n                    if (em->get_own_property) {\n                        /* get_own_property can free the prototype */\n                        obj1 = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p1));\n                        ret = em->get_own_property(ctx, &desc,\n                                                   obj1, prop);\n                        JS_FreeValue(ctx, obj1);\n                        if (ret < 0) {\n                            JS_FreeValue(ctx, val);\n                            return ret;\n                        }\n                        if (ret) {\n                            if (desc.flags & JS_PROP_GETSET) {\n                                JSObject *setter;\n                                if (JS_IsUndefined(desc.setter))\n                                    setter = NULL;\n                                else\n                                    setter = JS_VALUE_GET_OBJ(desc.setter);\n                                ret = call_setter(ctx, setter, this_obj, val, flags);\n                                JS_FreeValue(ctx, desc.getter);\n                                JS_FreeValue(ctx, desc.setter);\n                                return ret;\n                            } else {\n                                JS_FreeValue(ctx, desc.value);\n                                if (!(desc.flags & JS_PROP_WRITABLE))\n                                    goto read_only_prop;\n                                if (likely(p == p1)) {\n                                    ret = JS_DefineProperty(ctx, this_obj, prop, val,\n                                                            JS_UNDEFINED, JS_UNDEFINED,\n                                                            JS_PROP_HAS_VALUE);\n                                    JS_FreeValue(ctx, val);\n                                    return ret;\n                                } else {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        p1 = p1->shape->proto;\n    prototype_lookup:\n        if (!p1)\n            break;\n\n    retry2:\n        prs = find_own_property(&pr, p1, prop);\n        if (prs) {\n            if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);\n            } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                /* Instantiate property and retry (potentially useless) */\n                if (JS_AutoInitProperty(ctx, p1, prop, pr, prs))\n                    return -1;\n                goto retry2;\n            } else if (!(prs->flags & JS_PROP_WRITABLE)) {\n                goto read_only_prop;\n            }\n        }\n    }\n\n    if (unlikely(flags & JS_PROP_NO_ADD)) {\n        JS_FreeValue(ctx, val);\n        JS_ThrowReferenceErrorNotDefined(ctx, prop);\n        return -1;\n    }\n\n    if (unlikely(!p)) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowTypeErrorOrFalse(ctx, flags, \"not an object\");\n    }\n\n    if (unlikely(!p->extensible)) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowTypeErrorOrFalse(ctx, flags, \"object is not extensible\");\n    }\n\n    if (likely(p == JS_VALUE_GET_OBJ(obj))) {\n        if (p->is_exotic) {\n            if (p->class_id == JS_CLASS_ARRAY && p->fast_array &&\n                __JS_AtomIsTaggedInt(prop)) {\n                uint32_t idx = __JS_AtomToUInt32(prop);\n                if (idx == p->u.array.count) {\n                    /* fast case */\n                    return add_fast_array_element(ctx, p, val, flags);\n                } else {\n                    goto generic_create_prop;\n                }\n            } else {\n                goto generic_create_prop;\n            }\n        } else {\n            pr = add_property(ctx, p, prop, JS_PROP_C_W_E);\n            if (unlikely(!pr)) {\n                JS_FreeValue(ctx, val);\n                return -1;\n            }\n            pr->u.value = val;\n            return TRUE;\n        }\n    } else {\n        /* generic case: modify the property in this_obj if it already exists */\n        ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);\n        if (ret < 0) {\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n        if (ret) {\n            if (desc.flags & JS_PROP_GETSET) {\n                JS_FreeValue(ctx, desc.getter);\n                JS_FreeValue(ctx, desc.setter);\n                JS_FreeValue(ctx, val);\n                return JS_ThrowTypeErrorOrFalse(ctx, flags, \"setter is forbidden\");\n            } else {\n                JS_FreeValue(ctx, desc.value);\n                if (!(desc.flags & JS_PROP_WRITABLE) ||\n                    p->class_id == JS_CLASS_MODULE_NS) {\n                read_only_prop:\n                    JS_FreeValue(ctx, val);\n                    return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);\n                }\n            }\n            ret = JS_DefineProperty(ctx, this_obj, prop, val,\n                                    JS_UNDEFINED, JS_UNDEFINED,\n                                    JS_PROP_HAS_VALUE);\n            JS_FreeValue(ctx, val);\n            return ret;\n        } else {\n        generic_create_prop:\n            ret = JS_CreateProperty(ctx, p, prop, val, JS_UNDEFINED, JS_UNDEFINED,\n                                    flags |\n                                    JS_PROP_HAS_VALUE |\n                                    JS_PROP_HAS_ENUMERABLE |\n                                    JS_PROP_HAS_WRITABLE |\n                                    JS_PROP_HAS_CONFIGURABLE |\n                                    JS_PROP_C_W_E);\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n    }\n}\n\n/* flags can be JS_PROP_THROW or JS_PROP_THROW_STRICT */\nstatic int JS_SetPropertyValue(JSContext *ctx, JSValueConst this_obj,\n                               JSValue prop, JSValue val, int flags)\n{\n    if (likely(JS_VALUE_GET_TAG(this_obj) == JS_TAG_OBJECT &&\n               JS_VALUE_GET_TAG(prop) == JS_TAG_INT)) {\n        JSObject *p;\n        uint32_t idx;\n        double d;\n        int32_t v;\n\n        /* fast path for array access */\n        p = JS_VALUE_GET_OBJ(this_obj);\n        idx = JS_VALUE_GET_INT(prop);\n        switch(p->class_id) {\n        case JS_CLASS_ARRAY:\n            if (unlikely(idx >= (uint32_t)p->u.array.count)) {\n                JSObject *p1;\n                JSShape *sh1;\n\n                /* fast path to add an element to the array */\n                if (idx != (uint32_t)p->u.array.count ||\n                    !p->fast_array || !p->extensible)\n                    goto slow_path;\n                /* check if prototype chain has a numeric property */\n                p1 = p->shape->proto;\n                while (p1 != NULL) {\n                    sh1 = p1->shape;\n                    if (p1->class_id == JS_CLASS_ARRAY) {\n                        if (unlikely(!p1->fast_array))\n                            goto slow_path;\n                    } else if (p1->class_id == JS_CLASS_OBJECT) {\n                        if (unlikely(sh1->has_small_array_index))\n                            goto slow_path;\n                    } else {\n                        goto slow_path;\n                    }\n                    p1 = sh1->proto;\n                }\n                /* add element */\n                return add_fast_array_element(ctx, p, val, flags);\n            }\n            set_value(ctx, &p->u.array.u.values[idx], val);\n            break;\n        case JS_CLASS_ARGUMENTS:\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto slow_path;\n            set_value(ctx, &p->u.array.u.values[idx], val);\n            break;\n        case JS_CLASS_UINT8C_ARRAY:\n            if (JS_ToUint8ClampFree(ctx, &v, val))\n                return -1;\n            /* Note: the conversion can detach the typed array, so the\n               array bound check must be done after */\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto ta_out_of_bound;\n            p->u.array.u.uint8_ptr[idx] = v;\n            break;\n        case JS_CLASS_INT8_ARRAY:\n        case JS_CLASS_UINT8_ARRAY:\n            if (JS_ToInt32Free(ctx, &v, val))\n                return -1;\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto ta_out_of_bound;\n            p->u.array.u.uint8_ptr[idx] = v;\n            break;\n        case JS_CLASS_INT16_ARRAY:\n        case JS_CLASS_UINT16_ARRAY:\n            if (JS_ToInt32Free(ctx, &v, val))\n                return -1;\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto ta_out_of_bound;\n            p->u.array.u.uint16_ptr[idx] = v;\n            break;\n        case JS_CLASS_INT32_ARRAY:\n        case JS_CLASS_UINT32_ARRAY:\n            if (JS_ToInt32Free(ctx, &v, val))\n                return -1;\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto ta_out_of_bound;\n            p->u.array.u.uint32_ptr[idx] = v;\n            break;\n        case JS_CLASS_BIG_INT64_ARRAY:\n        case JS_CLASS_BIG_UINT64_ARRAY:\n            /* XXX: need specific conversion function */\n            {\n                int64_t v;\n                if (JS_ToBigInt64Free(ctx, &v, val))\n                    return -1;\n                if (unlikely(idx >= (uint32_t)p->u.array.count))\n                    goto ta_out_of_bound;\n                p->u.array.u.uint64_ptr[idx] = v;\n            }\n            break;\n        case JS_CLASS_FLOAT32_ARRAY:\n            if (JS_ToFloat64Free(ctx, &d, val))\n                return -1;\n            if (unlikely(idx >= (uint32_t)p->u.array.count))\n                goto ta_out_of_bound;\n            p->u.array.u.float_ptr[idx] = d;\n            break;\n        case JS_CLASS_FLOAT64_ARRAY:\n            if (JS_ToFloat64Free(ctx, &d, val))\n                return -1;\n            if (unlikely(idx >= (uint32_t)p->u.array.count)) {\n            ta_out_of_bound:\n                return TRUE;\n            }\n            p->u.array.u.double_ptr[idx] = d;\n            break;\n        default:\n            goto slow_path;\n        }\n        return TRUE;\n    } else {\n        JSAtom atom;\n        int ret;\n    slow_path:\n        atom = JS_ValueToAtom(ctx, prop);\n        JS_FreeValue(ctx, prop);\n        if (unlikely(atom == JS_ATOM_NULL)) {\n            JS_FreeValue(ctx, val);\n            return -1;\n        }\n        ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, this_obj, flags);\n        JS_FreeAtom(ctx, atom);\n        return ret;\n    }\n}\n\nint JS_SetPropertyUint32(JSContext *ctx, JSValueConst this_obj,\n                         uint32_t idx, JSValue val)\n{\n    return JS_SetPropertyValue(ctx, this_obj, JS_NewUint32(ctx, idx), val,\n                               JS_PROP_THROW);\n}\n\nint JS_SetPropertyInt64(JSContext *ctx, JSValueConst this_obj,\n                        int64_t idx, JSValue val)\n{\n    JSAtom prop;\n    int res;\n\n    if ((uint64_t)idx <= INT32_MAX) {\n        /* fast path for fast arrays */\n        return JS_SetPropertyValue(ctx, this_obj, JS_NewInt32(ctx, idx), val,\n                                   JS_PROP_THROW);\n    }\n    prop = JS_NewAtomInt64(ctx, idx);\n    if (prop == JS_ATOM_NULL) {\n        JS_FreeValue(ctx, val);\n        return -1;\n    }\n    res = JS_SetProperty(ctx, this_obj, prop, val);\n    JS_FreeAtom(ctx, prop);\n    return res;\n}\n\nint JS_SetPropertyStr(JSContext *ctx, JSValueConst this_obj,\n                      const char *prop, JSValue val)\n{\n    JSAtom atom;\n    int ret;\n    atom = JS_NewAtom(ctx, prop);\n    ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, this_obj, JS_PROP_THROW);\n    JS_FreeAtom(ctx, atom);\n    return ret;\n}\n\n/* compute the property flags. For each flag: (JS_PROP_HAS_x forces\n   it, otherwise def_flags is used)\n   Note: makes assumption about the bit pattern of the flags\n*/\nstatic int get_prop_flags(int flags, int def_flags)\n{\n    int mask;\n    mask = (flags >> JS_PROP_HAS_SHIFT) & JS_PROP_C_W_E;\n    return (flags & mask) | (def_flags & ~mask);\n}\n\nstatic int JS_CreateProperty(JSContext *ctx, JSObject *p,\n                             JSAtom prop, JSValueConst val,\n                             JSValueConst getter, JSValueConst setter,\n                             int flags)\n{\n    JSProperty *pr;\n    int ret, prop_flags;\n\n    /* add a new property or modify an existing exotic one */\n    if (p->is_exotic) {\n        if (p->class_id == JS_CLASS_ARRAY) {\n            uint32_t idx, len;\n\n            if (p->fast_array) {\n                if (__JS_AtomIsTaggedInt(prop)) {\n                    idx = __JS_AtomToUInt32(prop);\n                    if (idx == p->u.array.count) {\n                        if (!p->extensible)\n                            goto not_extensible;\n                        if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET))\n                            goto convert_to_array;\n                        prop_flags = get_prop_flags(flags, 0);\n                        if (prop_flags != JS_PROP_C_W_E)\n                            goto convert_to_array;\n                        return add_fast_array_element(ctx, p,\n                                                      JS_DupValue(ctx, val), flags);\n                    } else {\n                        goto convert_to_array;\n                    }\n                } else if (JS_AtomIsArrayIndex(ctx, &idx, prop)) {\n                    /* convert the fast array to normal array */\n                convert_to_array:\n                    if (convert_fast_array_to_array(ctx, p))\n                        return -1;\n                    goto generic_array;\n                }\n            } else if (JS_AtomIsArrayIndex(ctx, &idx, prop)) {\n                JSProperty *plen;\n                JSShapeProperty *pslen;\n            generic_array:\n                /* update the length field */\n                plen = &p->prop[0];\n                JS_ToUint32(ctx, &len, plen->u.value);\n                if ((idx + 1) > len) {\n                    pslen = get_shape_prop(p->shape);\n                    if (unlikely(!(pslen->flags & JS_PROP_WRITABLE)))\n                        return JS_ThrowTypeErrorReadOnly(ctx, flags, JS_ATOM_length);\n                    /* XXX: should update the length after defining\n                       the property */\n                    len = idx + 1;\n                    set_value(ctx, &plen->u.value, JS_NewUint32(ctx, len));\n                }\n            }\n        } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                   p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n            ret = JS_AtomIsNumericIndex(ctx, prop);\n            if (ret != 0) {\n                if (ret < 0)\n                    return -1;\n                return JS_ThrowTypeErrorOrFalse(ctx, flags, \"cannot create numeric index in typed array\");\n            }\n        } else if (!(flags & JS_PROP_NO_EXOTIC)) {\n            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n            if (em) {\n                if (em->define_own_property) {\n                    return em->define_own_property(ctx, JS_MKPTR(JS_TAG_OBJECT, p),\n                                                   prop, val, getter, setter, flags);\n                }\n                ret = JS_IsExtensible(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n                if (ret < 0)\n                    return -1;\n                if (!ret)\n                    goto not_extensible;\n            }\n        }\n    }\n\n    if (!p->extensible) {\n    not_extensible:\n        return JS_ThrowTypeErrorOrFalse(ctx, flags, \"object is not extensible\");\n    }\n\n    if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n        prop_flags = (flags & (JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE)) |\n            JS_PROP_GETSET;\n    } else {\n        prop_flags = flags & JS_PROP_C_W_E;\n    }\n    pr = add_property(ctx, p, prop, prop_flags);\n    if (unlikely(!pr))\n        return -1;\n    if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n        pr->u.getset.getter = NULL;\n        if ((flags & JS_PROP_HAS_GET) && JS_IsFunction(ctx, getter)) {\n            pr->u.getset.getter =\n                JS_VALUE_GET_OBJ(JS_DupValue(ctx, getter));\n        }\n        pr->u.getset.setter = NULL;\n        if ((flags & JS_PROP_HAS_SET) && JS_IsFunction(ctx, setter)) {\n            pr->u.getset.setter =\n                JS_VALUE_GET_OBJ(JS_DupValue(ctx, setter));\n        }\n    } else {\n        if (flags & JS_PROP_HAS_VALUE) {\n            pr->u.value = JS_DupValue(ctx, val);\n        } else {\n            pr->u.value = JS_UNDEFINED;\n        }\n    }\n    return TRUE;\n}\n\n/* return FALSE if not OK */\nstatic BOOL check_define_prop_flags(int prop_flags, int flags)\n{\n    BOOL has_accessor, is_getset;\n\n    if (!(prop_flags & JS_PROP_CONFIGURABLE)) {\n        if ((flags & (JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE)) ==\n            (JS_PROP_HAS_CONFIGURABLE | JS_PROP_CONFIGURABLE)) {\n            return FALSE;\n        }\n        if ((flags & JS_PROP_HAS_ENUMERABLE) &&\n            (flags & JS_PROP_ENUMERABLE) != (prop_flags & JS_PROP_ENUMERABLE))\n            return FALSE;\n    }\n    if (flags & (JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE |\n                 JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n        if (!(prop_flags & JS_PROP_CONFIGURABLE)) {\n            has_accessor = ((flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) != 0);\n            is_getset = ((prop_flags & JS_PROP_TMASK) == JS_PROP_GETSET);\n            if (has_accessor != is_getset)\n                return FALSE;\n            if (!has_accessor && !is_getset && !(prop_flags & JS_PROP_WRITABLE)) {\n                /* not writable: cannot set the writable bit */\n                if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) ==\n                    (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE))\n                    return FALSE;\n            }\n        }\n    }\n    return TRUE;\n}\n\n/* ensure that the shape can be safely modified */\nstatic int js_shape_prepare_update(JSContext *ctx, JSObject *p,\n                                   JSShapeProperty **pprs)\n{\n    JSShape *sh;\n    uint32_t idx = 0;    /* prevent warning */\n\n    sh = p->shape;\n    if (sh->is_hashed) {\n        if (sh->header.ref_count != 1) {\n            if (pprs)\n                idx = *pprs - get_shape_prop(sh);\n            /* clone the shape (the resulting one is no longer hashed) */\n            sh = js_clone_shape(ctx, sh);\n            if (!sh)\n                return -1;\n            js_free_shape(ctx->rt, p->shape);\n            p->shape = sh;\n            if (pprs)\n                *pprs = get_shape_prop(sh) + idx;\n        } else {\n            js_shape_hash_unlink(ctx->rt, sh);\n            sh->is_hashed = FALSE;\n        }\n    }\n    return 0;\n}\n\nstatic int js_update_property_flags(JSContext *ctx, JSObject *p,\n                                    JSShapeProperty **pprs, int flags)\n{\n    if (flags != (*pprs)->flags) {\n        if (js_shape_prepare_update(ctx, p, pprs))\n            return -1;\n        (*pprs)->flags = flags;\n    }\n    return 0;\n}\n\n/* allowed flags:\n   JS_PROP_CONFIGURABLE, JS_PROP_WRITABLE, JS_PROP_ENUMERABLE\n   JS_PROP_HAS_GET, JS_PROP_HAS_SET, JS_PROP_HAS_VALUE,\n   JS_PROP_HAS_CONFIGURABLE, JS_PROP_HAS_WRITABLE, JS_PROP_HAS_ENUMERABLE,\n   JS_PROP_THROW, JS_PROP_NO_EXOTIC.\n   If JS_PROP_THROW is set, return an exception instead of FALSE.\n   if JS_PROP_NO_EXOTIC is set, do not call the exotic\n   define_own_property callback.\n   return -1 (exception), FALSE or TRUE.\n*/\nint JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,\n                      JSAtom prop, JSValueConst val,\n                      JSValueConst getter, JSValueConst setter, int flags)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    int mask, res;\n\n    if (JS_VALUE_GET_TAG(this_obj) != JS_TAG_OBJECT) {\n        JS_ThrowTypeErrorNotAnObject(ctx);\n        return -1;\n    }\n    p = JS_VALUE_GET_OBJ(this_obj);\n\n redo_prop_update:\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        /* the range of the Array length property is always tested before */\n        if ((prs->flags & JS_PROP_LENGTH) && (flags & JS_PROP_HAS_VALUE)) {\n            uint32_t array_length;\n            if (JS_ToArrayLengthFree(ctx, &array_length,\n                                     JS_DupValue(ctx, val), FALSE)) {\n                return -1;\n            }\n            /* this code relies on the fact that Uint32 are never allocated */\n            val = (JSValueConst)JS_NewUint32(ctx, array_length);\n            /* prs may have been modified */\n            prs = find_own_property(&pr, p, prop);\n            assert(prs != NULL);\n        }\n        /* property already exists */\n        if (!check_define_prop_flags(prs->flags, flags)) {\n        not_configurable:\n            return JS_ThrowTypeErrorOrFalse(ctx, flags, \"property is not configurable\");\n        }\n\n        if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n            /* Instantiate property and retry */\n            if (JS_AutoInitProperty(ctx, p, prop, pr, prs))\n                return -1;\n            goto redo_prop_update;\n        }\n\n        if (flags & (JS_PROP_HAS_VALUE | JS_PROP_HAS_WRITABLE |\n                     JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n            if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n                JSObject *new_getter, *new_setter;\n\n                if (JS_IsFunction(ctx, getter)) {\n                    new_getter = JS_VALUE_GET_OBJ(getter);\n                } else {\n                    new_getter = NULL;\n                }\n                if (JS_IsFunction(ctx, setter)) {\n                    new_setter = JS_VALUE_GET_OBJ(setter);\n                } else {\n                    new_setter = NULL;\n                }\n\n                if ((prs->flags & JS_PROP_TMASK) != JS_PROP_GETSET) {\n                    if (js_shape_prepare_update(ctx, p, &prs))\n                        return -1;\n                    /* convert to getset */\n                    if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                        free_var_ref(ctx->rt, pr->u.var_ref);\n                    } else {\n                        JS_FreeValue(ctx, pr->u.value);\n                    }\n                    prs->flags = (prs->flags &\n                                  (JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE)) |\n                        JS_PROP_GETSET;\n                    pr->u.getset.getter = NULL;\n                    pr->u.getset.setter = NULL;\n                } else {\n                    if (!(prs->flags & JS_PROP_CONFIGURABLE)) {\n                        if ((flags & JS_PROP_HAS_GET) &&\n                            new_getter != pr->u.getset.getter) {\n                            goto not_configurable;\n                        }\n                        if ((flags & JS_PROP_HAS_SET) &&\n                            new_setter != pr->u.getset.setter) {\n                            goto not_configurable;\n                        }\n                    }\n                }\n                if (flags & JS_PROP_HAS_GET) {\n                    if (pr->u.getset.getter)\n                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));\n                    if (new_getter)\n                        JS_DupValue(ctx, getter);\n                    pr->u.getset.getter = new_getter;\n                }\n                if (flags & JS_PROP_HAS_SET) {\n                    if (pr->u.getset.setter)\n                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));\n                    if (new_setter)\n                        JS_DupValue(ctx, setter);\n                    pr->u.getset.setter = new_setter;\n                }\n            } else {\n                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                    /* convert to data descriptor */\n                    if (js_shape_prepare_update(ctx, p, &prs))\n                        return -1;\n                    if (pr->u.getset.getter)\n                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.getter));\n                    if (pr->u.getset.setter)\n                        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_OBJECT, pr->u.getset.setter));\n                    prs->flags &= ~(JS_PROP_TMASK | JS_PROP_WRITABLE);\n                    pr->u.value = JS_UNDEFINED;\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                    /* Note: JS_PROP_VARREF is always writable */\n                } else {\n                    if ((prs->flags & (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE)) == 0 &&\n                        (flags & JS_PROP_HAS_VALUE)) {\n                        if (!js_same_value(ctx, val, pr->u.value)) {\n                            goto not_configurable;\n                        } else {\n                            return TRUE;\n                        }\n                    }\n                }\n                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                    if (flags & JS_PROP_HAS_VALUE) {\n                        if (p->class_id == JS_CLASS_MODULE_NS) {\n                            /* JS_PROP_WRITABLE is always true for variable\n                               references, but they are write protected in module name\n                               spaces. */\n                            if (!js_same_value(ctx, val, *pr->u.var_ref->pvalue))\n                                goto not_configurable;\n                        } else {\n                            /* update the reference */\n                            set_value(ctx, pr->u.var_ref->pvalue,\n                                      JS_DupValue(ctx, val));\n                        }\n                    }\n                    /* if writable is set to false, no longer a\n                       reference (for mapped arguments) */\n                    if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) == JS_PROP_HAS_WRITABLE) {\n                        JSValue val1;\n                        if (p->class_id == JS_CLASS_MODULE_NS) {\n                            return JS_ThrowTypeErrorOrFalse(ctx, flags, \"module namespace properties have writable = false\");\n                        }\n                        if (js_shape_prepare_update(ctx, p, &prs))\n                            return -1;\n                        val1 = JS_DupValue(ctx, *pr->u.var_ref->pvalue);\n                        free_var_ref(ctx->rt, pr->u.var_ref);\n                        pr->u.value = val1;\n                        prs->flags &= ~(JS_PROP_TMASK | JS_PROP_WRITABLE);\n                    }\n                } else if (prs->flags & JS_PROP_LENGTH) {\n                    if (flags & JS_PROP_HAS_VALUE) {\n                        /* Note: no JS code is executable because\n                           'val' is guaranted to be a Uint32 */\n                        res = set_array_length(ctx, p, JS_DupValue(ctx, val),\n                                               flags);\n                    } else {\n                        res = TRUE;\n                    }\n                    /* still need to reset the writable flag if\n                       needed.  The JS_PROP_LENGTH is kept because the\n                       Uint32 test is still done if the length\n                       property is read-only. */\n                    if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) ==\n                        JS_PROP_HAS_WRITABLE) {\n                        prs = get_shape_prop(p->shape);\n                        if (js_update_property_flags(ctx, p, &prs,\n                                                     prs->flags & ~JS_PROP_WRITABLE))\n                            return -1;\n                    }\n                    return res;\n                } else {\n                    if (flags & JS_PROP_HAS_VALUE) {\n                        JS_FreeValue(ctx, pr->u.value);\n                        pr->u.value = JS_DupValue(ctx, val);\n                    }\n                    if (flags & JS_PROP_HAS_WRITABLE) {\n                        if (js_update_property_flags(ctx, p, &prs,\n                                                     (prs->flags & ~JS_PROP_WRITABLE) |\n                                                     (flags & JS_PROP_WRITABLE)))\n                            return -1;\n                    }\n                }\n            }\n        }\n        mask = 0;\n        if (flags & JS_PROP_HAS_CONFIGURABLE)\n            mask |= JS_PROP_CONFIGURABLE;\n        if (flags & JS_PROP_HAS_ENUMERABLE)\n            mask |= JS_PROP_ENUMERABLE;\n        if (js_update_property_flags(ctx, p, &prs,\n                                     (prs->flags & ~mask) | (flags & mask)))\n            return -1;\n        return TRUE;\n    }\n\n    /* handle modification of fast array elements */\n    if (p->fast_array) {\n        uint32_t idx;\n        uint32_t prop_flags;\n        if (p->class_id == JS_CLASS_ARRAY) {\n            if (__JS_AtomIsTaggedInt(prop)) {\n                idx = __JS_AtomToUInt32(prop);\n                if (idx < p->u.array.count) {\n                    prop_flags = get_prop_flags(flags, JS_PROP_C_W_E);\n                    if (prop_flags != JS_PROP_C_W_E)\n                        goto convert_to_slow_array;\n                    if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET)) {\n                    convert_to_slow_array:\n                        if (convert_fast_array_to_array(ctx, p))\n                            return -1;\n                        else\n                            goto redo_prop_update;\n                    }\n                    if (flags & JS_PROP_HAS_VALUE) {\n                        set_value(ctx, &p->u.array.u.values[idx], JS_DupValue(ctx, val));\n                    }\n                    return TRUE;\n                }\n            }\n        } else if (p->class_id >= JS_CLASS_UINT8C_ARRAY &&\n                   p->class_id <= JS_CLASS_FLOAT64_ARRAY) {\n            JSValue num;\n            int ret;\n\n            if (!__JS_AtomIsTaggedInt(prop)) {\n                /* slow path with to handle all numeric indexes */\n                num = JS_AtomIsNumericIndex1(ctx, prop);\n                if (JS_IsUndefined(num))\n                    goto typed_array_done;\n                if (JS_IsException(num))\n                    return -1;\n                ret = JS_NumberIsInteger(ctx, num);\n                if (ret < 0) {\n                    JS_FreeValue(ctx, num);\n                    return -1;\n                }\n                if (!ret) {\n                    JS_FreeValue(ctx, num);\n                    return JS_ThrowTypeErrorOrFalse(ctx, flags, \"non integer index in typed array\");\n                }\n                ret = JS_NumberIsNegativeOrMinusZero(ctx, num);\n                JS_FreeValue(ctx, num);\n                if (ret) {\n                    return JS_ThrowTypeErrorOrFalse(ctx, flags, \"negative index in typed array\");\n                }\n                if (!__JS_AtomIsTaggedInt(prop))\n                    goto typed_array_oob;\n            }\n            idx = __JS_AtomToUInt32(prop);\n            /* if the typed array is detached, p->u.array.count = 0 */\n            if (idx >= p->u.array.count) {\n            typed_array_oob:\n                return JS_ThrowTypeErrorOrFalse(ctx, flags, \"out-of-bound index in typed array\");\n            }\n            prop_flags = get_prop_flags(flags, JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n            if (flags & (JS_PROP_HAS_GET | JS_PROP_HAS_SET) ||\n                prop_flags != (JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE)) {\n                return JS_ThrowTypeErrorOrFalse(ctx, flags, \"invalid descriptor flags\");\n            }\n            if (flags & JS_PROP_HAS_VALUE) {\n                return JS_SetPropertyValue(ctx, this_obj, JS_NewInt32(ctx, idx), JS_DupValue(ctx, val), flags);\n            }\n            return TRUE;\n        typed_array_done: ;\n        }\n    }\n\n    return JS_CreateProperty(ctx, p, prop, val, getter, setter, flags);\n}\n\nstatic int JS_DefineAutoInitProperty(JSContext *ctx, JSValueConst this_obj,\n                                     JSAtom prop, JSAutoInitIDEnum id,\n                                     void *opaque, int flags)\n{\n    JSObject *p;\n    JSProperty *pr;\n\n    if (JS_VALUE_GET_TAG(this_obj) != JS_TAG_OBJECT)\n        return FALSE;\n\n    p = JS_VALUE_GET_OBJ(this_obj);\n\n    if (find_own_property(&pr, p, prop)) {\n        /* property already exists */\n        abort();\n        return FALSE;\n    }\n\n    /* Specialized CreateProperty */\n    pr = add_property(ctx, p, prop, (flags & JS_PROP_C_W_E) | JS_PROP_AUTOINIT);\n    if (unlikely(!pr))\n        return -1;\n    pr->u.init.realm_and_id = (uintptr_t)JS_DupContext(ctx);\n    assert((pr->u.init.realm_and_id & 3) == 0);\n    assert(id <= 3);\n    pr->u.init.realm_and_id |= id;\n    pr->u.init.opaque = opaque;\n    return TRUE;\n}\n\n/* shortcut to add or redefine a new property value */\nint JS_DefinePropertyValue(JSContext *ctx, JSValueConst this_obj,\n                           JSAtom prop, JSValue val, int flags)\n{\n    int ret;\n    ret = JS_DefineProperty(ctx, this_obj, prop, val, JS_UNDEFINED, JS_UNDEFINED,\n                            flags | JS_PROP_HAS_VALUE | JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_WRITABLE | JS_PROP_HAS_ENUMERABLE);\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nint JS_DefinePropertyValueValue(JSContext *ctx, JSValueConst this_obj,\n                                JSValue prop, JSValue val, int flags)\n{\n    JSAtom atom;\n    int ret;\n    atom = JS_ValueToAtom(ctx, prop);\n    JS_FreeValue(ctx, prop);\n    if (unlikely(atom == JS_ATOM_NULL)) {\n        JS_FreeValue(ctx, val);\n        return -1;\n    }\n    ret = JS_DefinePropertyValue(ctx, this_obj, atom, val, flags);\n    JS_FreeAtom(ctx, atom);\n    return ret;\n}\n\nint JS_DefinePropertyValueUint32(JSContext *ctx, JSValueConst this_obj,\n                                 uint32_t idx, JSValue val, int flags)\n{\n    return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewUint32(ctx, idx),\n                                       val, flags);\n}\n\nint JS_DefinePropertyValueInt64(JSContext *ctx, JSValueConst this_obj,\n                                int64_t idx, JSValue val, int flags)\n{\n    return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewInt64(ctx, idx),\n                                       val, flags);\n}\n\nint JS_DefinePropertyValueStr(JSContext *ctx, JSValueConst this_obj,\n                              const char *prop, JSValue val, int flags)\n{\n    JSAtom atom;\n    int ret;\n    atom = JS_NewAtom(ctx, prop);\n    ret = JS_DefinePropertyValue(ctx, this_obj, atom, val, flags);\n    JS_FreeAtom(ctx, atom);\n    return ret;\n}\n\n/* shortcut to add getter & setter */\nint JS_DefinePropertyGetSet(JSContext *ctx, JSValueConst this_obj,\n                            JSAtom prop, JSValue getter, JSValue setter,\n                            int flags)\n{\n    int ret;\n    ret = JS_DefineProperty(ctx, this_obj, prop, JS_UNDEFINED, getter, setter,\n                            flags | JS_PROP_HAS_GET | JS_PROP_HAS_SET |\n                            JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_ENUMERABLE);\n    JS_FreeValue(ctx, getter);\n    JS_FreeValue(ctx, setter);\n    return ret;\n}\n\nstatic int JS_CreateDataPropertyUint32(JSContext *ctx, JSValueConst this_obj,\n                                       int64_t idx, JSValue val, int flags)\n{\n    return JS_DefinePropertyValueValue(ctx, this_obj, JS_NewInt64(ctx, idx),\n                                       val, flags | JS_PROP_CONFIGURABLE |\n                                       JS_PROP_ENUMERABLE | JS_PROP_WRITABLE);\n}\n\n\n/* return TRUE if 'obj' has a non empty 'name' string */\nstatic BOOL js_object_has_name(JSContext *ctx, JSValueConst obj)\n{\n    JSProperty *pr;\n    JSShapeProperty *prs;\n    JSValueConst val;\n    JSString *p;\n\n    prs = find_own_property(&pr, JS_VALUE_GET_OBJ(obj), JS_ATOM_name);\n    if (!prs)\n        return FALSE;\n    if ((prs->flags & JS_PROP_TMASK) != JS_PROP_NORMAL)\n        return TRUE;\n    val = pr->u.value;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_STRING)\n        return TRUE;\n    p = JS_VALUE_GET_STRING(val);\n    return (p->len != 0);\n}\n\nstatic int JS_DefineObjectName(JSContext *ctx, JSValueConst obj,\n                               JSAtom name, int flags)\n{\n    if (name != JS_ATOM_NULL\n    &&  JS_IsObject(obj)\n    &&  !js_object_has_name(ctx, obj)\n    &&  JS_DefinePropertyValue(ctx, obj, JS_ATOM_name, JS_AtomToString(ctx, name), flags) < 0) {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int JS_DefineObjectNameComputed(JSContext *ctx, JSValueConst obj,\n                                       JSValueConst str, int flags)\n{\n    if (JS_IsObject(obj) &&\n        !js_object_has_name(ctx, obj)) {\n        JSAtom prop;\n        JSValue name_str;\n        prop = JS_ValueToAtom(ctx, str);\n        if (prop == JS_ATOM_NULL)\n            return -1;\n        name_str = js_get_function_name(ctx, prop);\n        JS_FreeAtom(ctx, prop);\n        if (JS_IsException(name_str))\n            return -1;\n        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_name, name_str, flags) < 0)\n            return -1;\n    }\n    return 0;\n}\n\n#define DEFINE_GLOBAL_LEX_VAR (1 << 7)\n#define DEFINE_GLOBAL_FUNC_VAR (1 << 6)\n\nstatic JSValue JS_ThrowSyntaxErrorVarRedeclaration(JSContext *ctx, JSAtom prop)\n{\n    return JS_ThrowSyntaxErrorAtom(ctx, \"redeclaration of '%s'\", prop);\n}\n\n/* flags is 0, DEFINE_GLOBAL_LEX_VAR or DEFINE_GLOBAL_FUNC_VAR */\n/* XXX: could support exotic global object. */\nstatic int JS_CheckDefineGlobalVar(JSContext *ctx, JSAtom prop, int flags)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n\n    p = JS_VALUE_GET_OBJ(ctx->global_obj);\n    prs = find_own_property1(p, prop);\n    /* XXX: should handle JS_PROP_AUTOINIT */\n    if (flags & DEFINE_GLOBAL_LEX_VAR) {\n        if (prs && !(prs->flags & JS_PROP_CONFIGURABLE))\n            goto fail_redeclaration;\n    } else {\n        if (!prs && !p->extensible)\n            goto define_error;\n        if (flags & DEFINE_GLOBAL_FUNC_VAR) {\n            if (prs) {\n                if (!(prs->flags & JS_PROP_CONFIGURABLE) &&\n                    ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET ||\n                     ((prs->flags & (JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)) !=\n                      (JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)))) {\n                define_error:\n                    JS_ThrowTypeErrorAtom(ctx, \"cannot define variable '%s'\",\n                                          prop);\n                    return -1;\n                }\n            }\n        }\n    }\n    /* check if there already is a lexical declaration */\n    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n    prs = find_own_property1(p, prop);\n    if (prs) {\n    fail_redeclaration:\n        JS_ThrowSyntaxErrorVarRedeclaration(ctx, prop);\n        return -1;\n    }\n    return 0;\n}\n\n/* def_flags is (0, DEFINE_GLOBAL_LEX_VAR) |\n   JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE */\n/* XXX: could support exotic global object. */\nstatic int JS_DefineGlobalVar(JSContext *ctx, JSAtom prop, int def_flags)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    JSValue val;\n    int flags;\n\n    if (def_flags & DEFINE_GLOBAL_LEX_VAR) {\n        p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n        flags = JS_PROP_ENUMERABLE | (def_flags & JS_PROP_WRITABLE) |\n            JS_PROP_CONFIGURABLE;\n        val = JS_UNINITIALIZED;\n    } else {\n        p = JS_VALUE_GET_OBJ(ctx->global_obj);\n        flags = JS_PROP_ENUMERABLE | JS_PROP_WRITABLE |\n            (def_flags & JS_PROP_CONFIGURABLE);\n        val = JS_UNDEFINED;\n    }\n    prs = find_own_property1(p, prop);\n    if (prs)\n        return 0;\n    if (!p->extensible)\n        return 0;\n    pr = add_property(ctx, p, prop, flags);\n    if (unlikely(!pr))\n        return -1;\n    pr->u.value = val;\n    return 0;\n}\n\n/* 'def_flags' is 0 or JS_PROP_CONFIGURABLE. */\n/* XXX: could support exotic global object. */\nstatic int JS_DefineGlobalFunction(JSContext *ctx, JSAtom prop,\n                                   JSValueConst func, int def_flags)\n{\n\n    JSObject *p;\n    JSShapeProperty *prs;\n    int flags;\n\n    p = JS_VALUE_GET_OBJ(ctx->global_obj);\n    prs = find_own_property1(p, prop);\n    flags = JS_PROP_HAS_VALUE | JS_PROP_THROW;\n    if (!prs || (prs->flags & JS_PROP_CONFIGURABLE)) {\n        flags |= JS_PROP_ENUMERABLE | JS_PROP_WRITABLE | def_flags |\n            JS_PROP_HAS_CONFIGURABLE | JS_PROP_HAS_WRITABLE | JS_PROP_HAS_ENUMERABLE;\n    }\n    if (JS_DefineProperty(ctx, ctx->global_obj, prop, func,\n                          JS_UNDEFINED, JS_UNDEFINED, flags) < 0)\n        return -1;\n    return 0;\n}\n\nstatic JSValue JS_GetGlobalVar(JSContext *ctx, JSAtom prop,\n                               BOOL throw_ref_error)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n\n    /* no exotic behavior is possible in global_var_obj */\n    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        /* XXX: should handle JS_PROP_TMASK properties */\n        if (unlikely(JS_IsUninitialized(pr->u.value)))\n            return JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n        return JS_DupValue(ctx, pr->u.value);\n    }\n    return JS_GetPropertyInternal(ctx, ctx->global_obj, prop,\n                                 ctx->global_obj, throw_ref_error);\n}\n\n/* construct a reference to a global variable */\nstatic int JS_GetGlobalVarRef(JSContext *ctx, JSAtom prop, JSValue *sp)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n\n    /* no exotic behavior is possible in global_var_obj */\n    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        /* XXX: should handle JS_PROP_AUTOINIT properties? */\n        /* XXX: conformance: do these tests in\n           OP_put_var_ref/OP_get_var_ref ? */\n        if (unlikely(JS_IsUninitialized(pr->u.value))) {\n            JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n            return -1;\n        }\n        if (unlikely(!(prs->flags & JS_PROP_WRITABLE))) {\n            return JS_ThrowTypeErrorReadOnly(ctx, JS_PROP_THROW, prop);\n        }\n        sp[0] = JS_DupValue(ctx, ctx->global_var_obj);\n    } else {\n        int ret;\n        ret = JS_HasProperty(ctx, ctx->global_obj, prop);\n        if (ret < 0)\n            return -1;\n        if (ret) {\n            sp[0] = JS_DupValue(ctx, ctx->global_obj);\n        } else {\n            sp[0] = JS_UNDEFINED;\n        }\n    }\n    sp[1] = JS_AtomToValue(ctx, prop);\n    return 0;\n}\n\n/* use for strict variable access: test if the variable exists */\nstatic int JS_CheckGlobalVar(JSContext *ctx, JSAtom prop)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    int ret;\n\n    /* no exotic behavior is possible in global_var_obj */\n    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n    prs = find_own_property1(p, prop);\n    if (prs) {\n        ret = TRUE;\n    } else {\n        ret = JS_HasProperty(ctx, ctx->global_obj, prop);\n        if (ret < 0)\n            return -1;\n    }\n    return ret;\n}\n\n/* flag = 0: normal variable write\n   flag = 1: initialize lexical variable\n   flag = 2: normal variable write, strict check was done before\n*/\nstatic int JS_SetGlobalVar(JSContext *ctx, JSAtom prop, JSValue val,\n                           int flag)\n{\n    JSObject *p;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    int flags;\n\n    /* no exotic behavior is possible in global_var_obj */\n    p = JS_VALUE_GET_OBJ(ctx->global_var_obj);\n    prs = find_own_property(&pr, p, prop);\n    if (prs) {\n        /* XXX: should handle JS_PROP_AUTOINIT properties? */\n        if (flag != 1) {\n            if (unlikely(JS_IsUninitialized(pr->u.value))) {\n                JS_FreeValue(ctx, val);\n                JS_ThrowReferenceErrorUninitialized(ctx, prs->atom);\n                return -1;\n            }\n            if (unlikely(!(prs->flags & JS_PROP_WRITABLE))) {\n                JS_FreeValue(ctx, val);\n                return JS_ThrowTypeErrorReadOnly(ctx, JS_PROP_THROW, prop);\n            }\n        }\n        set_value(ctx, &pr->u.value, val);\n        return 0;\n    }\n    flags = JS_PROP_THROW_STRICT;\n    if (is_strict_mode(ctx))\n        flags |= JS_PROP_NO_ADD;\n    return JS_SetPropertyInternal(ctx, ctx->global_obj, prop, val, ctx->global_obj, flags);\n}\n\n/* return -1, FALSE or TRUE. return FALSE if not configurable or\n   invalid object. return -1 in case of exception.\n   flags can be 0, JS_PROP_THROW or JS_PROP_THROW_STRICT */\nint JS_DeleteProperty(JSContext *ctx, JSValueConst obj, JSAtom prop, int flags)\n{\n    JSValue obj1;\n    JSObject *p;\n    int res;\n\n    obj1 = JS_ToObject(ctx, obj);\n    if (JS_IsException(obj1))\n        return -1;\n    p = JS_VALUE_GET_OBJ(obj1);\n    res = delete_property(ctx, p, prop);\n    JS_FreeValue(ctx, obj1);\n    if (res != FALSE)\n        return res;\n    if ((flags & JS_PROP_THROW) ||\n        ((flags & JS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {\n        JS_ThrowTypeError(ctx, \"could not delete property\");\n        return -1;\n    }\n    return FALSE;\n}\n\nint JS_DeletePropertyInt64(JSContext *ctx, JSValueConst obj, int64_t idx, int flags)\n{\n    JSAtom prop;\n    int res;\n\n    if ((uint64_t)idx <= JS_ATOM_MAX_INT) {\n        /* fast path for fast arrays */\n        return JS_DeleteProperty(ctx, obj, __JS_AtomFromUInt32(idx), flags);\n    }\n    prop = JS_NewAtomInt64(ctx, idx);\n    if (prop == JS_ATOM_NULL)\n        return -1;\n    res = JS_DeleteProperty(ctx, obj, prop, flags);\n    JS_FreeAtom(ctx, prop);\n    return res;\n}\n\nBOOL JS_IsFunction(JSContext *ctx, JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(val);\n    switch(p->class_id) {\n    case JS_CLASS_BYTECODE_FUNCTION:\n        return TRUE;\n    case JS_CLASS_PROXY:\n        return p->u.proxy_data->is_func;\n    default:\n        return (ctx->rt->class_array[p->class_id].call != NULL);\n    }\n}\n\nBOOL JS_IsCFunction(JSContext *ctx, JSValueConst val, JSCFunction *func, int magic)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(val);\n    if (p->class_id == JS_CLASS_C_FUNCTION)\n        return (p->u.cfunc.c_function.generic == func && p->u.cfunc.magic == magic);\n    else\n        return FALSE;\n}\n\nBOOL JS_IsConstructor(JSContext *ctx, JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(val);\n    return p->is_constructor;\n}\n\nBOOL JS_SetConstructorBit(JSContext *ctx, JSValueConst func_obj, BOOL val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(func_obj);\n    p->is_constructor = val;\n    return TRUE;\n}\n\nBOOL JS_IsError(JSContext *ctx, JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(val);\n    return (p->class_id == JS_CLASS_ERROR);\n}\n\n/* used to avoid catching interrupt exceptions */\nBOOL JS_IsUncatchableError(JSContext *ctx, JSValueConst val)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(val);\n    return p->class_id == JS_CLASS_ERROR && p->is_uncatchable_error;\n}\n\nvoid JS_SetUncatchableError(JSContext *ctx, JSValueConst val, BOOL flag)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return;\n    p = JS_VALUE_GET_OBJ(val);\n    if (p->class_id == JS_CLASS_ERROR)\n        p->is_uncatchable_error = flag;\n}\n\nvoid JS_ResetUncatchableError(JSContext *ctx)\n{\n    JS_SetUncatchableError(ctx, ctx->rt->current_exception, FALSE);\n}\n\nvoid JS_SetOpaque(JSValue obj, void *opaque)\n{\n   JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        p = JS_VALUE_GET_OBJ(obj);\n        p->u.opaque = opaque;\n    }\n}\n\n/* return NULL if not an object of class class_id */\nvoid *JS_GetOpaque(JSValueConst obj, JSClassID class_id)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return NULL;\n    p = JS_VALUE_GET_OBJ(obj);\n    if (p->class_id != class_id)\n        return NULL;\n    return p->u.opaque;\n}\n\nvoid *JS_GetOpaque2(JSContext *ctx, JSValueConst obj, JSClassID class_id)\n{\n    void *p = JS_GetOpaque(obj, class_id);\n    if (unlikely(!p)) {\n        JS_ThrowTypeErrorInvalidClass(ctx, class_id);\n    }\n    return p;\n}\n\nstatic JSValue JS_ToPrimitiveFree(JSContext *ctx, JSValue val, int hint)\n{\n    int i;\n    BOOL force_ordinary;\n\n    JSAtom method_name;\n    JSValue method, ret;\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_OBJECT)\n        return val;\n    force_ordinary = hint & HINT_FORCE_ORDINARY;\n    hint &= ~HINT_FORCE_ORDINARY;\n    if (!force_ordinary) {\n        method = JS_GetProperty(ctx, val, JS_ATOM_Symbol_toPrimitive);\n        if (JS_IsException(method))\n            goto exception;\n        /* ECMA says *If exoticToPrim is not undefined* but tests in\n           test262 use null as a non callable converter */\n        if (!JS_IsUndefined(method) && !JS_IsNull(method)) {\n            JSAtom atom;\n            JSValue arg;\n            switch(hint) {\n            case HINT_STRING:\n                atom = JS_ATOM_string;\n                break;\n            case HINT_NUMBER:\n                atom = JS_ATOM_number;\n                break;\n            default:\n            case HINT_NONE:\n                atom = JS_ATOM_default;\n                break;\n            }\n            arg = JS_AtomToString(ctx, atom);\n            ret = JS_CallFree(ctx, method, val, 1, (JSValueConst *)&arg);\n            JS_FreeValue(ctx, arg);\n            if (JS_IsException(ret))\n                goto exception;\n            JS_FreeValue(ctx, val);\n            if (JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT)\n                return ret;\n            JS_FreeValue(ctx, ret);\n            return JS_ThrowTypeError(ctx, \"toPrimitive\");\n        }\n    }\n    if (hint != HINT_STRING)\n        hint = HINT_NUMBER;\n    for(i = 0; i < 2; i++) {\n        if ((i ^ hint) == 0) {\n            method_name = JS_ATOM_toString;\n        } else {\n            method_name = JS_ATOM_valueOf;\n        }\n        method = JS_GetProperty(ctx, val, method_name);\n        if (JS_IsException(method))\n            goto exception;\n        if (JS_IsFunction(ctx, method)) {\n            ret = JS_CallFree(ctx, method, val, 0, NULL);\n            if (JS_IsException(ret))\n                goto exception;\n            if (JS_VALUE_GET_TAG(ret) != JS_TAG_OBJECT) {\n                JS_FreeValue(ctx, val);\n                return ret;\n            }\n            JS_FreeValue(ctx, ret);\n        } else {\n            JS_FreeValue(ctx, method);\n        }\n    }\n    JS_ThrowTypeError(ctx, \"toPrimitive\");\nexception:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_ToPrimitive(JSContext *ctx, JSValueConst val, int hint)\n{\n    return JS_ToPrimitiveFree(ctx, JS_DupValue(ctx, val), hint);\n}\n\nvoid JS_SetIsHTMLDDA(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return;\n    p = JS_VALUE_GET_OBJ(obj);\n    p->is_HTMLDDA = TRUE;\n}\n\nstatic inline BOOL JS_IsHTMLDDA(JSContext *ctx, JSValueConst obj)\n{\n    JSObject *p;\n    if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)\n        return FALSE;\n    p = JS_VALUE_GET_OBJ(obj);\n    return p->is_HTMLDDA;\n}\n\nstatic int JS_ToBoolFree(JSContext *ctx, JSValue val)\n{\n    uint32_t tag = JS_VALUE_GET_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n        return JS_VALUE_GET_INT(val) != 0;\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        return JS_VALUE_GET_INT(val);\n    case JS_TAG_EXCEPTION:\n        return -1;\n    case JS_TAG_STRING:\n        {\n            BOOL ret = JS_VALUE_GET_STRING(val)->len != 0;\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n    case JS_TAG_BIG_INT:\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n#endif\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            BOOL ret;\n            ret = p->num.expn != BF_EXP_ZERO && p->num.expn != BF_EXP_NAN;\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_DECIMAL:\n        {\n            JSBigDecimal *p = JS_VALUE_GET_PTR(val);\n            BOOL ret;\n            ret = p->num.expn != BF_EXP_ZERO && p->num.expn != BF_EXP_NAN;\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n#endif\n    case JS_TAG_OBJECT:\n        {\n            JSObject *p = JS_VALUE_GET_OBJ(val);\n            BOOL ret;\n            ret = !p->is_HTMLDDA;\n            JS_FreeValue(ctx, val);\n            return ret;\n        }\n        break;\n    default:\n        if (JS_TAG_IS_FLOAT64(tag)) {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            return !isnan(d) && d != 0;\n        } else {\n            JS_FreeValue(ctx, val);\n            return TRUE;\n        }\n    }\n}\n\nint JS_ToBool(JSContext *ctx, JSValueConst val)\n{\n    return JS_ToBoolFree(ctx, JS_DupValue(ctx, val));\n}\n\nstatic int skip_spaces(const char *pc)\n{\n    const uint8_t *p, *p_next, *p_start;\n    uint32_t c;\n\n    p = p_start = (const uint8_t *)pc;\n    for (;;) {\n        c = *p;\n        if (c < 128) {\n            if (!((c >= 0x09 && c <= 0x0d) || (c == 0x20)))\n                break;\n            p++;\n        } else {\n            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);\n            if (!lre_is_space(c))\n                break;\n            p = p_next;\n        }\n    }\n    return p - p_start;\n}\n\nstatic inline int to_digit(int c)\n{\n    if (c >= '0' && c <= '9')\n        return c - '0';\n    else if (c >= 'A' && c <= 'Z')\n        return c - 'A' + 10;\n    else if (c >= 'a' && c <= 'z')\n        return c - 'a' + 10;\n    else\n        return 36;\n}\n\n/* XXX: remove */\nstatic double js_strtod(const char *str, int radix, BOOL is_float)\n{\n    double d;\n    int c;\n\n    if (!is_float || radix != 10) {\n        const char *p = str;\n        uint64_t n_max, n;\n        int int_exp, is_neg;\n\n        is_neg = 0;\n        if (*p == '-') {\n            is_neg = 1;\n            p++;\n        }\n\n        /* skip leading zeros */\n        while (*p == '0')\n            p++;\n        n = 0;\n        if (radix == 10)\n            n_max = ((uint64_t)-1 - 9) / 10; /* most common case */\n        else\n            n_max = ((uint64_t)-1 - (radix - 1)) / radix;\n        /* XXX: could be more precise */\n        int_exp = 0;\n        while (*p != '\\0') {\n            c = to_digit((uint8_t)*p);\n            if (c >= radix)\n                break;\n            if (n <= n_max) {\n                n = n * radix + c;\n            } else {\n                if (radix == 10)\n                    goto strtod_case;\n                int_exp++;\n            }\n            p++;\n        }\n        d = n;\n        if (int_exp != 0) {\n            d *= pow(radix, int_exp);\n        }\n        if (is_neg)\n            d = -d;\n    } else {\n    strtod_case:\n        d = strtod(str, NULL);\n    }\n    return d;\n}\n\n#define ATOD_INT_ONLY        (1 << 0)\n/* accept Oo and Ob prefixes in addition to 0x prefix if radix = 0 */\n#define ATOD_ACCEPT_BIN_OCT  (1 << 2)\n/* accept O prefix as octal if radix == 0 and properly formed (Annex B) */\n#define ATOD_ACCEPT_LEGACY_OCTAL  (1 << 4)\n/* accept _ between digits as a digit separator */\n#define ATOD_ACCEPT_UNDERSCORES  (1 << 5)\n/* allow a suffix to override the type */\n#define ATOD_ACCEPT_SUFFIX    (1 << 6)\n/* default type */\n#define ATOD_TYPE_MASK        (3 << 7)\n#define ATOD_TYPE_FLOAT64     (0 << 7)\n#define ATOD_TYPE_BIG_INT     (1 << 7)\n#ifdef CONFIG_BIGNUM\n#define ATOD_TYPE_BIG_FLOAT   (2 << 7)\n#define ATOD_TYPE_BIG_DECIMAL (3 << 7)\n/* assume bigint mode: floats are parsed as integers if no decimal\n   point nor exponent */\n#define ATOD_MODE_BIGINT      (1 << 9)\n#endif\n/* accept -0x1 */\n#define ATOD_ACCEPT_PREFIX_AFTER_SIGN (1 << 10)\n\nstatic JSValue js_string_to_bigint(JSContext *ctx, const char *buf,\n                                   int radix, int flags, slimb_t *pexponent)\n{\n    bf_t a_s, *a = &a_s;\n    int ret;\n    JSValue val;\n    val = JS_NewBigInt(ctx);\n    if (JS_IsException(val))\n        return val;\n    a = JS_GetBigInt(val);\n    ret = bf_atof(a, buf, NULL, radix, BF_PREC_INF, BF_RNDZ);\n    if (ret & BF_ST_MEM_ERROR) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowOutOfMemory(ctx);\n    }\n#ifdef CONFIG_BIGNUM\n    val = JS_CompactBigInt1(ctx, val, (flags & ATOD_MODE_BIGINT) != 0);\n#else\n    val = JS_CompactBigInt1(ctx, val, FALSE);\n#endif\n    return val;\n}\n\n#ifdef CONFIG_BIGNUM\nstatic JSValue js_string_to_bigfloat(JSContext *ctx, const char *buf,\n                                     int radix, int flags, slimb_t *pexponent)\n{\n    bf_t *a;\n    int ret;\n    JSValue val;\n\n    val = JS_NewBigFloat(ctx);\n    if (JS_IsException(val))\n        return val;\n    a = JS_GetBigFloat(val);\n    if (flags & ATOD_ACCEPT_SUFFIX) {\n        /* return the exponent to get infinite precision */\n        ret = bf_atof2(a, pexponent, buf, NULL, radix, BF_PREC_INF,\n                       BF_RNDZ | BF_ATOF_EXPONENT);\n    } else {\n        ret = bf_atof(a, buf, NULL, radix, ctx->fp_env.prec,\n                      ctx->fp_env.flags);\n    }\n    if (ret & BF_ST_MEM_ERROR) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowOutOfMemory(ctx);\n    }\n    return val;\n}\n\nstatic JSValue js_string_to_bigdecimal(JSContext *ctx, const char *buf,\n                                       int radix, int flags, slimb_t *pexponent)\n{\n    bfdec_t *a;\n    int ret;\n    JSValue val;\n\n    val = JS_NewBigDecimal(ctx);\n    if (JS_IsException(val))\n        return val;\n    a = JS_GetBigDecimal(val);\n    ret = bfdec_atof(a, buf, NULL, BF_PREC_INF,\n                     BF_RNDZ | BF_ATOF_NO_NAN_INF);\n    if (ret & BF_ST_MEM_ERROR) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowOutOfMemory(ctx);\n    }\n    return val;\n}\n#endif\n\n/* return an exception in case of memory error. Return JS_NAN if\n   invalid syntax */\n#ifdef CONFIG_BIGNUM\nstatic JSValue js_atof2(JSContext *ctx, const char *str, const char **pp,\n                        int radix, int flags, slimb_t *pexponent)\n#else\nstatic JSValue js_atof(JSContext *ctx, const char *str, const char **pp,\n                       int radix, int flags)\n#endif\n{\n    const char *p, *p_start;\n    int sep, is_neg;\n    BOOL is_float, has_legacy_octal;\n    int atod_type = flags & ATOD_TYPE_MASK;\n    char buf1[64], *buf;\n    int i, j, len;\n    BOOL buf_allocated = FALSE;\n    JSValue val;\n\n    /* optional separator between digits */\n    sep = (flags & ATOD_ACCEPT_UNDERSCORES) ? '_' : 256;\n    has_legacy_octal = FALSE;\n\n    p = str;\n    p_start = p;\n    is_neg = 0;\n    if (p[0] == '+') {\n        p++;\n        p_start++;\n        if (!(flags & ATOD_ACCEPT_PREFIX_AFTER_SIGN))\n            goto no_radix_prefix;\n    } else if (p[0] == '-') {\n        p++;\n        p_start++;\n        is_neg = 1;\n        if (!(flags & ATOD_ACCEPT_PREFIX_AFTER_SIGN))\n            goto no_radix_prefix;\n    }\n    if (p[0] == '0') {\n        if ((p[1] == 'x' || p[1] == 'X') &&\n            (radix == 0 || radix == 16)) {\n            p += 2;\n            radix = 16;\n        } else if ((p[1] == 'o' || p[1] == 'O') &&\n                   radix == 0 && (flags & ATOD_ACCEPT_BIN_OCT)) {\n            p += 2;\n            radix = 8;\n        } else if ((p[1] == 'b' || p[1] == 'B') &&\n                   radix == 0 && (flags & ATOD_ACCEPT_BIN_OCT)) {\n            p += 2;\n            radix = 2;\n        } else if ((p[1] >= '0' && p[1] <= '9') &&\n                   radix == 0 && (flags & ATOD_ACCEPT_LEGACY_OCTAL)) {\n            int i;\n            has_legacy_octal = TRUE;\n            sep = 256;\n            for (i = 1; (p[i] >= '0' && p[i] <= '7'); i++)\n                continue;\n            if (p[i] == '8' || p[i] == '9')\n                goto no_prefix;\n            p += 1;\n            radix = 8;\n        } else {\n            goto no_prefix;\n        }\n        /* there must be a digit after the prefix */\n        if (to_digit((uint8_t)*p) >= radix)\n            goto fail;\n    no_prefix: ;\n    } else {\n no_radix_prefix:\n        if (!(flags & ATOD_INT_ONLY) &&\n            (atod_type == ATOD_TYPE_FLOAT64\n#ifdef CONFIG_BIGNUM\n             || atod_type == ATOD_TYPE_BIG_FLOAT\n#endif\n             ) &&\n            strstart(p, \"Infinity\", &p)) {\n#ifdef CONFIG_BIGNUM\n            if (atod_type == ATOD_TYPE_BIG_FLOAT) {\n                bf_t *a;\n                val = JS_NewBigFloat(ctx);\n                if (JS_IsException(val))\n                    goto done;\n                a = JS_GetBigFloat(val);\n                bf_set_inf(a, is_neg);\n            } else\n#endif\n            {\n                double d = 1.0 / 0.0;\n                if (is_neg)\n                    d = -d;\n                val = JS_NewFloat64(ctx, d);\n            }\n            goto done;\n        }\n    }\n    if (radix == 0)\n        radix = 10;\n    is_float = FALSE;\n    p_start = p;\n    while (to_digit((uint8_t)*p) < radix\n           ||  (*p == sep && (radix != 10 ||\n                              p != p_start + 1 || p[-1] != '0') &&\n                to_digit((uint8_t)p[1]) < radix)) {\n        p++;\n    }\n    if (!(flags & ATOD_INT_ONLY)) {\n        if (*p == '.' && (p > p_start || to_digit((uint8_t)p[1]) < radix)) {\n            is_float = TRUE;\n            p++;\n            if (*p == sep)\n                goto fail;\n            while (to_digit((uint8_t)*p) < radix ||\n                   (*p == sep && to_digit((uint8_t)p[1]) < radix))\n                p++;\n        }\n        if (p > p_start &&\n            (((*p == 'e' || *p == 'E') && radix == 10) ||\n             ((*p == 'p' || *p == 'P') && (radix == 2 || radix == 8 || radix == 16)))) {\n            const char *p1 = p + 1;\n            is_float = TRUE;\n            if (*p1 == '+') {\n                p1++;\n            } else if (*p1 == '-') {\n                p1++;\n            }\n            if (is_digit((uint8_t)*p1)) {\n                p = p1 + 1;\n                while (is_digit((uint8_t)*p) || (*p == sep && is_digit((uint8_t)p[1])))\n                    p++;\n            }\n        }\n    }\n    if (p == p_start)\n        goto fail;\n\n    buf = buf1;\n    buf_allocated = FALSE;\n    len = p - p_start;\n    if (unlikely((len + 2) > sizeof(buf1))) {\n        buf = js_malloc_rt(ctx->rt, len + 2); /* no exception raised */\n        if (!buf)\n            goto mem_error;\n        buf_allocated = TRUE;\n    }\n    /* remove the separators and the radix prefixes */\n    j = 0;\n    if (is_neg)\n        buf[j++] = '-';\n    for (i = 0; i < len; i++) {\n        if (p_start[i] != '_')\n            buf[j++] = p_start[i];\n    }\n    buf[j] = '\\0';\n\n    if (flags & ATOD_ACCEPT_SUFFIX) {\n        if (*p == 'n') {\n            p++;\n            atod_type = ATOD_TYPE_BIG_INT;\n        } else\n#ifdef CONFIG_BIGNUM\n        if (*p == 'l') {\n            p++;\n            atod_type = ATOD_TYPE_BIG_FLOAT;\n        } else if (*p == 'm') {\n            p++;\n            atod_type = ATOD_TYPE_BIG_DECIMAL;\n        } else if (flags & ATOD_MODE_BIGINT) {\n            if (!is_float)\n                atod_type = ATOD_TYPE_BIG_INT;\n            if (has_legacy_octal)\n                goto fail;\n        } else\n#endif\n        {\n            if (is_float && radix != 10)\n                goto fail;\n        }\n    } else {\n        if (atod_type == ATOD_TYPE_FLOAT64) {\n#ifdef CONFIG_BIGNUM\n            if (flags & ATOD_MODE_BIGINT) {\n                if (!is_float)\n                    atod_type = ATOD_TYPE_BIG_INT;\n                if (has_legacy_octal)\n                    goto fail;\n            } else\n#endif\n            {\n                if (is_float && radix != 10)\n                    goto fail;\n            }\n        }\n    }\n\n    switch(atod_type) {\n    case ATOD_TYPE_FLOAT64:\n        {\n            double d;\n            d = js_strtod(buf, radix, is_float);\n            /* return int or float64 */\n            val = JS_NewFloat64(ctx, d);\n        }\n        break;\n    case ATOD_TYPE_BIG_INT:\n        if (has_legacy_octal || is_float)\n            goto fail;\n        val = ctx->rt->bigint_ops.from_string(ctx, buf, radix, flags, NULL);\n        break;\n#ifdef CONFIG_BIGNUM\n    case ATOD_TYPE_BIG_FLOAT:\n        if (has_legacy_octal)\n            goto fail;\n        val = ctx->rt->bigfloat_ops.from_string(ctx, buf, radix, flags,\n                                                pexponent);\n        break;\n    case ATOD_TYPE_BIG_DECIMAL:\n        if (radix != 10)\n            goto fail;\n        val = ctx->rt->bigdecimal_ops.from_string(ctx, buf, radix, flags, NULL);\n        break;\n#endif\n    default:\n        abort();\n    }\n\ndone:\n    if (buf_allocated)\n        js_free_rt(ctx->rt, buf);\n    if (pp)\n        *pp = p;\n    return val;\n fail:\n    val = JS_NAN;\n    goto done;\n mem_error:\n    val = JS_ThrowOutOfMemory(ctx);\n    goto done;\n}\n\n#ifdef CONFIG_BIGNUM\nstatic JSValue js_atof(JSContext *ctx, const char *str, const char **pp,\n                       int radix, int flags)\n{\n    return js_atof2(ctx, str, pp, radix, flags, NULL);\n}\n#endif\n\ntypedef enum JSToNumberHintEnum {\n    TON_FLAG_NUMBER,\n    TON_FLAG_NUMERIC,\n} JSToNumberHintEnum;\n\nstatic JSValue JS_ToNumberHintFree(JSContext *ctx, JSValue val,\n                                   JSToNumberHintEnum flag)\n{\n    uint32_t tag;\n    JSValue ret;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_BIG_INT:\n        if (flag != TON_FLAG_NUMERIC) {\n            JS_FreeValue(ctx, val);\n            return JS_ThrowTypeError(ctx, \"cannot convert bigint to number\");\n        }\n        ret = val;\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_DECIMAL:\n        if (flag != TON_FLAG_NUMERIC) {\n            JS_FreeValue(ctx, val);\n            return JS_ThrowTypeError(ctx, \"cannot convert bigdecimal to number\");\n        }\n        ret = val;\n        break;\n    case JS_TAG_BIG_FLOAT:\n        if (flag != TON_FLAG_NUMERIC) {\n            JS_FreeValue(ctx, val);\n            return JS_ThrowTypeError(ctx, \"cannot convert bigfloat to number\");\n        }\n        ret = val;\n        break;\n#endif\n    case JS_TAG_FLOAT64:\n    case JS_TAG_INT:\n    case JS_TAG_EXCEPTION:\n        ret = val;\n        break;\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n        ret = JS_NewInt32(ctx, JS_VALUE_GET_INT(val));\n        break;\n    case JS_TAG_UNDEFINED:\n        ret = JS_NAN;\n        break;\n    case JS_TAG_OBJECT:\n        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);\n        if (JS_IsException(val))\n            return JS_EXCEPTION;\n        goto redo;\n    case JS_TAG_STRING:\n        {\n            const char *str;\n            const char *p;\n            size_t len;\n\n            str = JS_ToCStringLen(ctx, &len, val);\n            JS_FreeValue(ctx, val);\n            if (!str)\n                return JS_EXCEPTION;\n            p = str;\n            p += skip_spaces(p);\n            if ((p - str) == len) {\n                ret = JS_NewInt32(ctx, 0);\n            } else {\n                int flags = ATOD_ACCEPT_BIN_OCT;\n                ret = js_atof(ctx, p, &p, 0, flags);\n                if (!JS_IsException(ret)) {\n                    p += skip_spaces(p);\n                    if ((p - str) != len) {\n                        JS_FreeValue(ctx, ret);\n                        ret = JS_NAN;\n                    }\n                }\n            }\n            JS_FreeCString(ctx, str);\n        }\n        break;\n    case JS_TAG_SYMBOL:\n        JS_FreeValue(ctx, val);\n        return JS_ThrowTypeError(ctx, \"cannot convert symbol to number\");\n    default:\n        JS_FreeValue(ctx, val);\n        ret = JS_NAN;\n        break;\n    }\n    return ret;\n}\n\nstatic JSValue JS_ToNumberFree(JSContext *ctx, JSValue val)\n{\n    return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMBER);\n}\n\nstatic JSValue JS_ToNumericFree(JSContext *ctx, JSValue val)\n{\n    return JS_ToNumberHintFree(ctx, val, TON_FLAG_NUMERIC);\n}\n\nstatic JSValue JS_ToNumeric(JSContext *ctx, JSValueConst val)\n{\n    return JS_ToNumericFree(ctx, JS_DupValue(ctx, val));\n}\n\nstatic __exception int __JS_ToFloat64Free(JSContext *ctx, double *pres,\n                                          JSValue val)\n{\n    double d;\n    uint32_t tag;\n\n    val = JS_ToNumberFree(ctx, val);\n    if (JS_IsException(val)) {\n        *pres = JS_FLOAT64_NAN;\n        return -1;\n    }\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n        d = JS_VALUE_GET_INT(val);\n        break;\n    case JS_TAG_FLOAT64:\n        d = JS_VALUE_GET_FLOAT64(val);\n        break;\n    case JS_TAG_BIG_INT:\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n#endif\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            /* XXX: there can be a double rounding issue with some\n               primitives (such as JS_ToUint8ClampFree()), but it is\n               not critical to fix it. */\n            bf_get_float64(&p->num, &d, BF_RNDN);\n            JS_FreeValue(ctx, val);\n        }\n        break;\n    default:\n        abort();\n    }\n    *pres = d;\n    return 0;\n}\n\nstatic inline int JS_ToFloat64Free(JSContext *ctx, double *pres, JSValue val)\n{\n    uint32_t tag;\n\n    tag = JS_VALUE_GET_TAG(val);\n    if (tag <= JS_TAG_NULL) {\n        *pres = JS_VALUE_GET_INT(val);\n        return 0;\n    } else if (JS_TAG_IS_FLOAT64(tag)) {\n        *pres = JS_VALUE_GET_FLOAT64(val);\n        return 0;\n    } else {\n        return __JS_ToFloat64Free(ctx, pres, val);\n    }\n}\n\nint JS_ToFloat64(JSContext *ctx, double *pres, JSValueConst val)\n{\n    return JS_ToFloat64Free(ctx, pres, JS_DupValue(ctx, val));\n}\n\nstatic JSValue JS_ToNumber(JSContext *ctx, JSValueConst val)\n{\n    return JS_ToNumberFree(ctx, JS_DupValue(ctx, val));\n}\n\n/* same as JS_ToNumber() but return 0 in case of NaN/Undefined */\nstatic __maybe_unused JSValue JS_ToIntegerFree(JSContext *ctx, JSValue val)\n{\n    uint32_t tag;\n    JSValue ret;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        ret = JS_NewInt32(ctx, JS_VALUE_GET_INT(val));\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            if (isnan(d)) {\n                ret = JS_NewInt32(ctx, 0);\n            } else {\n                /* convert -0 to +0 */\n                d = trunc(d) + 0.0;\n                ret = JS_NewFloat64(ctx, d);\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            bf_t a_s, *a, r_s, *r = &r_s;\n            BOOL is_nan;\n\n            a = JS_ToBigFloat(ctx, &a_s, val);\n            if (!a) {\n                JS_FreeValue(ctx, val);\n                return JS_EXCEPTION;\n            }\n            if (!bf_is_finite(a)) {\n                is_nan = bf_is_nan(a);\n                if (is_nan)\n                    ret = JS_NewInt32(ctx, 0);\n                else\n                    ret = JS_DupValue(ctx, val);\n            } else {\n                ret = JS_NewBigInt(ctx);\n                if (!JS_IsException(ret)) {\n                    r = JS_GetBigInt(ret);\n                    bf_set(r, a);\n                    bf_rint(r, BF_RNDZ);\n                    ret = JS_CompactBigInt(ctx, ret);\n                }\n            }\n            if (a == &a_s)\n                bf_delete(a);\n            JS_FreeValue(ctx, val);\n        }\n        break;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val))\n            return val;\n        goto redo;\n    }\n    return ret;\n}\n\n/* Note: the integer value is satured to 32 bits */\nstatic int JS_ToInt32SatFree(JSContext *ctx, int *pres, JSValue val)\n{\n    uint32_t tag;\n    int ret;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        ret = JS_VALUE_GET_INT(val);\n        break;\n    case JS_TAG_EXCEPTION:\n        *pres = 0;\n        return -1;\n    case JS_TAG_FLOAT64:\n        {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            if (isnan(d)) {\n                ret = 0;\n            } else {\n                if (d < INT32_MIN)\n                    ret = INT32_MIN;\n                else if (d > INT32_MAX)\n                    ret = INT32_MAX;\n                else\n                    ret = (int)d;\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_get_int32(&ret, &p->num, 0);\n            JS_FreeValue(ctx, val);\n        }\n        break;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val)) {\n            *pres = 0;\n            return -1;\n        }\n        goto redo;\n    }\n    *pres = ret;\n    return 0;\n}\n\nint JS_ToInt32Sat(JSContext *ctx, int *pres, JSValueConst val)\n{\n    return JS_ToInt32SatFree(ctx, pres, JS_DupValue(ctx, val));\n}\n\nint JS_ToInt32Clamp(JSContext *ctx, int *pres, JSValueConst val,\n                    int min, int max, int min_offset)\n{\n    int res = JS_ToInt32SatFree(ctx, pres, JS_DupValue(ctx, val));\n    if (res == 0) {\n        if (*pres < min) {\n            *pres += min_offset;\n            if (*pres < min)\n                *pres = min;\n        } else {\n            if (*pres > max)\n                *pres = max;\n        }\n    }\n    return res;\n}\n\nstatic int JS_ToInt64SatFree(JSContext *ctx, int64_t *pres, JSValue val)\n{\n    uint32_t tag;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        *pres = JS_VALUE_GET_INT(val);\n        return 0;\n    case JS_TAG_EXCEPTION:\n        *pres = 0;\n        return -1;\n    case JS_TAG_FLOAT64:\n        {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            if (isnan(d)) {\n                *pres = 0;\n            } else {\n                if (d < INT64_MIN)\n                    *pres = INT64_MIN;\n                else if (d >= 0x1p63) /* must use INT64_MAX + 1 because INT64_MAX cannot be exactly represented as a double */\n                    *pres = INT64_MAX;\n                else\n                    *pres = (int64_t)d;\n            }\n        }\n        return 0;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_get_int64(pres, &p->num, 0);\n            JS_FreeValue(ctx, val);\n        }\n        return 0;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val)) {\n            *pres = 0;\n            return -1;\n        }\n        goto redo;\n    }\n}\n\nint JS_ToInt64Sat(JSContext *ctx, int64_t *pres, JSValueConst val)\n{\n    return JS_ToInt64SatFree(ctx, pres, JS_DupValue(ctx, val));\n}\n\nint JS_ToInt64Clamp(JSContext *ctx, int64_t *pres, JSValueConst val,\n                    int64_t min, int64_t max, int64_t neg_offset)\n{\n    int res = JS_ToInt64SatFree(ctx, pres, JS_DupValue(ctx, val));\n    if (res == 0) {\n        if (*pres < 0)\n            *pres += neg_offset;\n        if (*pres < min)\n            *pres = min;\n        else if (*pres > max)\n            *pres = max;\n    }\n    return res;\n}\n\n/* Same as JS_ToInt32Free() but with a 64 bit result. Return (<0, 0)\n   in case of exception */\nstatic int JS_ToInt64Free(JSContext *ctx, int64_t *pres, JSValue val)\n{\n    uint32_t tag;\n    int64_t ret;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        ret = JS_VALUE_GET_INT(val);\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            JSFloat64Union u;\n            double d;\n            int e;\n            d = JS_VALUE_GET_FLOAT64(val);\n            u.d = d;\n            /* we avoid doing fmod(x, 2^64) */\n            e = (u.u64 >> 52) & 0x7ff;\n            if (likely(e <= (1023 + 62))) {\n                /* fast case */\n                ret = (int64_t)d;\n            } else if (e <= (1023 + 62 + 53)) {\n                uint64_t v;\n                /* remainder modulo 2^64 */\n                v = (u.u64 & (((uint64_t)1 << 52) - 1)) | ((uint64_t)1 << 52);\n                ret = v << ((e - 1023) - 52);\n                /* take the sign into account */\n                if (u.u64 >> 63)\n                    ret = -ret;\n            } else {\n                ret = 0; /* also handles NaN and +inf */\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_get_int64(&ret, &p->num, BF_GET_INT_MOD);\n            JS_FreeValue(ctx, val);\n        }\n        break;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val)) {\n            *pres = 0;\n            return -1;\n        }\n        goto redo;\n    }\n    *pres = ret;\n    return 0;\n}\n\nint JS_ToInt64(JSContext *ctx, int64_t *pres, JSValueConst val)\n{\n    return JS_ToInt64Free(ctx, pres, JS_DupValue(ctx, val));\n}\n\nint JS_ToInt64Ext(JSContext *ctx, int64_t *pres, JSValueConst val)\n{\n    if (JS_IsBigInt(ctx, val))\n        return JS_ToBigInt64(ctx, pres, val);\n    else\n        return JS_ToInt64(ctx, pres, val);\n}\n\n/* return (<0, 0) in case of exception */\nstatic int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val)\n{\n    uint32_t tag;\n    int32_t ret;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        ret = JS_VALUE_GET_INT(val);\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            JSFloat64Union u;\n            double d;\n            int e;\n            d = JS_VALUE_GET_FLOAT64(val);\n            u.d = d;\n            /* we avoid doing fmod(x, 2^32) */\n            e = (u.u64 >> 52) & 0x7ff;\n            if (likely(e <= (1023 + 30))) {\n                /* fast case */\n                ret = (int32_t)d;\n            } else if (e <= (1023 + 30 + 53)) {\n                uint64_t v;\n                /* remainder modulo 2^32 */\n                v = (u.u64 & (((uint64_t)1 << 52) - 1)) | ((uint64_t)1 << 52);\n                v = v << ((e - 1023) - 52 + 32);\n                ret = v >> 32;\n                /* take the sign into account */\n                if (u.u64 >> 63)\n                    ret = -ret;\n            } else {\n                ret = 0; /* also handles NaN and +inf */\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_get_int32(&ret, &p->num, BF_GET_INT_MOD);\n            JS_FreeValue(ctx, val);\n        }\n        break;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val)) {\n            *pres = 0;\n            return -1;\n        }\n        goto redo;\n    }\n    *pres = ret;\n    return 0;\n}\n\nint JS_ToInt32(JSContext *ctx, int32_t *pres, JSValueConst val)\n{\n    return JS_ToInt32Free(ctx, pres, JS_DupValue(ctx, val));\n}\n\nstatic inline int JS_ToUint32Free(JSContext *ctx, uint32_t *pres, JSValue val)\n{\n    return JS_ToInt32Free(ctx, (int32_t *)pres, val);\n}\n\nstatic int JS_ToUint8ClampFree(JSContext *ctx, int32_t *pres, JSValue val)\n{\n    uint32_t tag;\n    int res;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        res = JS_VALUE_GET_INT(val);\n#ifdef CONFIG_BIGNUM\n    int_clamp:\n#endif\n        res = max_int(0, min_int(255, res));\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            if (isnan(d)) {\n                res = 0;\n            } else {\n                if (d < 0)\n                    res = 0;\n                else if (d > 255)\n                    res = 255;\n                else\n                    res = lrint(d);\n            }\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_t r_s, *r = &r_s;\n            bf_init(ctx->bf_ctx, r);\n            bf_set(r, &p->num);\n            bf_rint(r, BF_RNDN);\n            bf_get_int32(&res, r, 0);\n            bf_delete(r);\n            JS_FreeValue(ctx, val);\n        }\n        goto int_clamp;\n#endif\n    default:\n        val = JS_ToNumberFree(ctx, val);\n        if (JS_IsException(val)) {\n            *pres = 0;\n            return -1;\n        }\n        goto redo;\n    }\n    *pres = res;\n    return 0;\n}\n\nstatic __exception int JS_ToArrayLengthFree(JSContext *ctx, uint32_t *plen,\n                                            JSValue val, BOOL is_array_ctor)\n{\n    uint32_t tag, len;\n\n    tag = JS_VALUE_GET_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n        {\n            int v;\n            v = JS_VALUE_GET_INT(val);\n            if (v < 0)\n                goto fail;\n            len = v;\n        }\n        break;\n    case JS_TAG_BIG_INT:\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n#endif\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            bf_t a;\n            BOOL res;\n            bf_get_int32((int32_t *)&len, &p->num, BF_GET_INT_MOD);\n            bf_init(ctx->bf_ctx, &a);\n            bf_set_ui(&a, len);\n            res = bf_cmp_eq(&a, &p->num);\n            bf_delete(&a);\n            JS_FreeValue(ctx, val);\n            if (!res)\n                goto fail;\n        }\n        break;\n    default:\n        if (JS_TAG_IS_FLOAT64(tag)) {\n            double d;\n            d = JS_VALUE_GET_FLOAT64(val);\n            if (!(d >= 0 && d <= UINT32_MAX))\n                goto fail;\n            len = (uint32_t)d;\n            if (len != d)\n                goto fail;\n        } else {\n            uint32_t len1;\n\n            if (is_array_ctor) {\n                val = JS_ToNumberFree(ctx, val);\n                if (JS_IsException(val))\n                    return -1;\n                /* cannot recurse because val is a number */\n                if (JS_ToArrayLengthFree(ctx, &len, val, TRUE))\n                    return -1;\n            } else {\n                /* legacy behavior: must do the conversion twice and compare */\n                if (JS_ToUint32(ctx, &len, val)) {\n                    JS_FreeValue(ctx, val);\n                    return -1;\n                }\n                val = JS_ToNumberFree(ctx, val);\n                if (JS_IsException(val))\n                    return -1;\n                /* cannot recurse because val is a number */\n                if (JS_ToArrayLengthFree(ctx, &len1, val, FALSE))\n                    return -1;\n                if (len1 != len) {\n                fail:\n                    JS_ThrowRangeError(ctx, \"invalid array length\");\n                    return -1;\n                }\n            }\n        }\n        break;\n    }\n    *plen = len;\n    return 0;\n}\n\n#define MAX_SAFE_INTEGER (((int64_t)1 << 53) - 1)\n\nstatic BOOL is_safe_integer(double d)\n{\n    return isfinite(d) && floor(d) == d &&\n        fabs(d) <= (double)MAX_SAFE_INTEGER;\n}\n\nint JS_ToIndex(JSContext *ctx, uint64_t *plen, JSValueConst val)\n{\n    int64_t v;\n    if (JS_ToInt64Sat(ctx, &v, val))\n        return -1;\n    if (v < 0 || v > MAX_SAFE_INTEGER) {\n        JS_ThrowRangeError(ctx, \"invalid array index\");\n        *plen = 0;\n        return -1;\n    }\n    *plen = v;\n    return 0;\n}\n\n/* convert a value to a length between 0 and MAX_SAFE_INTEGER.\n   return -1 for exception */\nstatic __exception int JS_ToLengthFree(JSContext *ctx, int64_t *plen,\n                                       JSValue val)\n{\n    int res = JS_ToInt64Clamp(ctx, plen, val, 0, MAX_SAFE_INTEGER, 0);\n    JS_FreeValue(ctx, val);\n    return res;\n}\n\n/* Note: can return an exception */\nstatic int JS_NumberIsInteger(JSContext *ctx, JSValueConst val)\n{\n    double d;\n    if (!JS_IsNumber(val))\n        return FALSE;\n    if (unlikely(JS_ToFloat64(ctx, &d, val)))\n        return -1;\n    return isfinite(d) && floor(d) == d;\n}\n\nstatic BOOL JS_NumberIsNegativeOrMinusZero(JSContext *ctx, JSValueConst val)\n{\n    uint32_t tag;\n\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n        {\n            int v;\n            v = JS_VALUE_GET_INT(val);\n            return (v < 0);\n        }\n    case JS_TAG_FLOAT64:\n        {\n            JSFloat64Union u;\n            u.d = JS_VALUE_GET_FLOAT64(val);\n            return (u.u64 >> 63);\n        }\n    case JS_TAG_BIG_INT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            /* Note: integer zeros are not necessarily positive */\n            return p->num.sign && !bf_is_zero(&p->num);\n        }\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            return p->num.sign;\n        }\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        {\n            JSBigDecimal *p = JS_VALUE_GET_PTR(val);\n            return p->num.sign;\n        }\n        break;\n#endif\n    default:\n        return FALSE;\n    }\n}\n\nstatic JSValue js_bigint_to_string1(JSContext *ctx, JSValueConst val, int radix)\n{\n    JSValue ret;\n    bf_t a_s, *a;\n    char *str;\n    int saved_sign;\n\n    a = JS_ToBigInt(ctx, &a_s, val);\n    if (!a)\n        return JS_EXCEPTION;\n    saved_sign = a->sign;\n    if (a->expn == BF_EXP_ZERO)\n        a->sign = 0;\n    str = bf_ftoa(NULL, a, radix, 0, BF_RNDZ | BF_FTOA_FORMAT_FRAC |\n                  BF_FTOA_JS_QUIRKS);\n    a->sign = saved_sign;\n    JS_FreeBigInt(ctx, a, &a_s);\n    if (!str)\n        return JS_ThrowOutOfMemory(ctx);\n    ret = JS_NewString(ctx, str);\n    bf_free(ctx->bf_ctx, str);\n    return ret;\n}\n\nstatic JSValue js_bigint_to_string(JSContext *ctx, JSValueConst val)\n{\n    return js_bigint_to_string1(ctx, val, 10);\n}\n\n#ifdef CONFIG_BIGNUM\n\nstatic JSValue js_ftoa(JSContext *ctx, JSValueConst val1, int radix,\n                       limb_t prec, bf_flags_t flags)\n{\n    JSValue val, ret;\n    bf_t a_s, *a;\n    char *str;\n    int saved_sign;\n\n    val = JS_ToNumeric(ctx, val1);\n    if (JS_IsException(val))\n        return val;\n    a = JS_ToBigFloat(ctx, &a_s, val);\n    if (!a) {\n        JS_FreeValue(ctx, val);\n        return JS_EXCEPTION;\n    }\n    saved_sign = a->sign;\n    if (a->expn == BF_EXP_ZERO)\n        a->sign = 0;\n    flags |= BF_FTOA_JS_QUIRKS;\n    if ((flags & BF_FTOA_FORMAT_MASK) == BF_FTOA_FORMAT_FREE_MIN) {\n        /* Note: for floating point numbers with a radix which is not\n           a power of two, the current precision is used to compute\n           the number of digits. */\n        if ((radix & (radix - 1)) != 0) {\n            bf_t r_s, *r = &r_s;\n            int prec, flags1;\n            /* must round first */\n            if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_FLOAT) {\n                prec = ctx->fp_env.prec;\n                flags1 = ctx->fp_env.flags &\n                    (BF_FLAG_SUBNORMAL | (BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT));\n            } else {\n                prec = 53;\n                flags1 = bf_set_exp_bits(11) | BF_FLAG_SUBNORMAL;\n            }\n            bf_init(ctx->bf_ctx, r);\n            bf_set(r, a);\n            bf_round(r, prec, flags1 | BF_RNDN);\n            str = bf_ftoa(NULL, r, radix, prec, flags1 | flags);\n            bf_delete(r);\n        } else {\n            str = bf_ftoa(NULL, a, radix, BF_PREC_INF, flags);\n        }\n    } else {\n        str = bf_ftoa(NULL, a, radix, prec, flags);\n    }\n    a->sign = saved_sign;\n    if (a == &a_s)\n        bf_delete(a);\n    JS_FreeValue(ctx, val);\n    if (!str)\n        return JS_ThrowOutOfMemory(ctx);\n    ret = JS_NewString(ctx, str);\n    bf_free(ctx->bf_ctx, str);\n    return ret;\n}\n\nstatic JSValue js_bigfloat_to_string(JSContext *ctx, JSValueConst val)\n{\n    return js_ftoa(ctx, val, 10, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);\n}\n\nstatic JSValue js_bigdecimal_to_string1(JSContext *ctx, JSValueConst val,\n                                        limb_t prec, int flags)\n{\n    JSValue ret;\n    bfdec_t *a;\n    char *str;\n    int saved_sign;\n\n    a = JS_ToBigDecimal(ctx, val);\n    if (!a)\n        return JS_EXCEPTION;\n    saved_sign = a->sign;\n    if (a->expn == BF_EXP_ZERO)\n        a->sign = 0;\n    str = bfdec_ftoa(NULL, a, prec, flags | BF_FTOA_JS_QUIRKS);\n    a->sign = saved_sign;\n    if (!str)\n        return JS_ThrowOutOfMemory(ctx);\n    ret = JS_NewString(ctx, str);\n    bf_free(ctx->bf_ctx, str);\n    return ret;\n}\n\nstatic JSValue js_bigdecimal_to_string(JSContext *ctx, JSValueConst val)\n{\n    return js_bigdecimal_to_string1(ctx, val, 0,\n                                    BF_RNDZ | BF_FTOA_FORMAT_FREE);\n}\n\n#endif /* CONFIG_BIGNUM */\n\n/* 2 <= base <= 36 */\nstatic char const digits[36] = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\nstatic char *i64toa(char *buf_end, int64_t n, unsigned int base)\n{\n    char *q = buf_end;\n    int digit, is_neg;\n\n    is_neg = 0;\n    if (n < 0) {\n        is_neg = 1;\n        n = -n;\n    }\n    *--q = '\\0';\n    if (base == 10) {\n        /* division by known base uses multiplication */\n        do {\n            digit = (uint64_t)n % 10;\n            n = (uint64_t)n / 10;\n            *--q = '0' + digit;\n        } while (n != 0);\n    } else {\n        do {\n            digit = (uint64_t)n % base;\n            n = (uint64_t)n / base;\n            *--q = digits[digit];\n        } while (n != 0);\n    }\n    if (is_neg)\n        *--q = '-';\n    return q;\n}\n\n/* buf1 contains the printf result */\nstatic void js_ecvt1(double d, int n_digits, int *decpt, int *sign, char *buf,\n                     int rounding_mode, char *buf1, int buf1_size)\n{\n    if (rounding_mode != FE_TONEAREST)\n        fesetround(rounding_mode);\n    snprintf(buf1, buf1_size, \"%+.*e\", n_digits - 1, d);\n    if (rounding_mode != FE_TONEAREST)\n        fesetround(FE_TONEAREST);\n    *sign = (buf1[0] == '-');\n    /* mantissa */\n    buf[0] = buf1[1];\n    if (n_digits > 1)\n        memcpy(buf + 1, buf1 + 3, n_digits - 1);\n    buf[n_digits] = '\\0';\n    /* exponent */\n    *decpt = atoi(buf1 + n_digits + 2 + (n_digits > 1)) + 1;\n}\n\n/* maximum buffer size for js_dtoa */\n#define JS_DTOA_BUF_SIZE 128\n\n/* needed because ecvt usually limits the number of digits to\n   17. Return the number of digits. */\nstatic int js_ecvt(double d, int n_digits, int *decpt, int *sign, char *buf,\n                   BOOL is_fixed)\n{\n    int rounding_mode;\n    char buf_tmp[JS_DTOA_BUF_SIZE];\n\n    if (!is_fixed) {\n        unsigned int n_digits_min, n_digits_max;\n        /* find the minimum amount of digits (XXX: inefficient but simple) */\n        n_digits_min = 1;\n        n_digits_max = 17;\n        while (n_digits_min < n_digits_max) {\n            n_digits = (n_digits_min + n_digits_max) / 2;\n            js_ecvt1(d, n_digits, decpt, sign, buf, FE_TONEAREST,\n                     buf_tmp, sizeof(buf_tmp));\n            if (strtod(buf_tmp, NULL) == d) {\n                /* no need to keep the trailing zeros */\n                while (n_digits >= 2 && buf[n_digits - 1] == '0')\n                    n_digits--;\n                n_digits_max = n_digits;\n            } else {\n                n_digits_min = n_digits + 1;\n            }\n        }\n        n_digits = n_digits_max;\n        rounding_mode = FE_TONEAREST;\n    } else {\n        rounding_mode = FE_TONEAREST;\n#ifdef CONFIG_PRINTF_RNDN\n        {\n            char buf1[JS_DTOA_BUF_SIZE], buf2[JS_DTOA_BUF_SIZE];\n            int decpt1, sign1, decpt2, sign2;\n            /* The JS rounding is specified as round to nearest ties away\n               from zero (RNDNA), but in printf the \"ties\" case is not\n               specified (for example it is RNDN for glibc, RNDNA for\n               Windows), so we must round manually. */\n            js_ecvt1(d, n_digits + 1, &decpt1, &sign1, buf1, FE_TONEAREST,\n                     buf_tmp, sizeof(buf_tmp));\n            /* XXX: could use 2 digits to reduce the average running time */\n            if (buf1[n_digits] == '5') {\n                js_ecvt1(d, n_digits + 1, &decpt1, &sign1, buf1, FE_DOWNWARD,\n                         buf_tmp, sizeof(buf_tmp));\n                js_ecvt1(d, n_digits + 1, &decpt2, &sign2, buf2, FE_UPWARD,\n                         buf_tmp, sizeof(buf_tmp));\n                if (memcmp(buf1, buf2, n_digits + 1) == 0 && decpt1 == decpt2) {\n                    /* exact result: round away from zero */\n                    if (sign1)\n                        rounding_mode = FE_DOWNWARD;\n                    else\n                        rounding_mode = FE_UPWARD;\n                }\n            }\n        }\n#endif /* CONFIG_PRINTF_RNDN */\n    }\n    js_ecvt1(d, n_digits, decpt, sign, buf, rounding_mode,\n             buf_tmp, sizeof(buf_tmp));\n    return n_digits;\n}\n\nstatic int js_fcvt1(char (*buf)[JS_DTOA_BUF_SIZE], double d, int n_digits,\n                    int rounding_mode)\n{\n    int n;\n    if (rounding_mode != FE_TONEAREST)\n        fesetround(rounding_mode);\n    n = snprintf(*buf, sizeof(*buf), \"%.*f\", n_digits, d);\n    if (rounding_mode != FE_TONEAREST)\n        fesetround(FE_TONEAREST);\n    assert(n < sizeof(*buf));\n    return n;\n}\n\nstatic void js_fcvt(char (*buf)[JS_DTOA_BUF_SIZE], double d, int n_digits)\n{\n    int rounding_mode;\n    rounding_mode = FE_TONEAREST;\n#ifdef CONFIG_PRINTF_RNDN\n    {\n        int n1, n2;\n        char buf1[JS_DTOA_BUF_SIZE];\n        char buf2[JS_DTOA_BUF_SIZE];\n\n        /* The JS rounding is specified as round to nearest ties away from\n           zero (RNDNA), but in printf the \"ties\" case is not specified\n           (for example it is RNDN for glibc, RNDNA for Windows), so we\n           must round manually. */\n        n1 = js_fcvt1(&buf1, d, n_digits + 1, FE_TONEAREST);\n        rounding_mode = FE_TONEAREST;\n        /* XXX: could use 2 digits to reduce the average running time */\n        if (buf1[n1 - 1] == '5') {\n            n1 = js_fcvt1(&buf1, d, n_digits + 1, FE_DOWNWARD);\n            n2 = js_fcvt1(&buf2, d, n_digits + 1, FE_UPWARD);\n            if (n1 == n2 && memcmp(buf1, buf2, n1) == 0) {\n                /* exact result: round away from zero */\n                if (buf1[0] == '-')\n                    rounding_mode = FE_DOWNWARD;\n                else\n                    rounding_mode = FE_UPWARD;\n            }\n        }\n    }\n#endif /* CONFIG_PRINTF_RNDN */\n    js_fcvt1(buf, d, n_digits, rounding_mode);\n}\n\n/* radix != 10 is only supported with flags = JS_DTOA_VAR_FORMAT */\n/* use as many digits as necessary */\n#define JS_DTOA_VAR_FORMAT   (0 << 0)\n/* use n_digits significant digits (1 <= n_digits <= 101) */\n#define JS_DTOA_FIXED_FORMAT (1 << 0)\n/* force fractional format: [-]dd.dd with n_digits fractional digits */\n#define JS_DTOA_FRAC_FORMAT  (2 << 0)\n/* force exponential notation either in fixed or variable format */\n#define JS_DTOA_FORCE_EXP    (1 << 2)\n\n/* XXX: slow and maybe not fully correct. Use libbf when it is fast enough.\n   XXX: radix != 10 is only supported for small integers\n*/\nstatic void js_dtoa1(char (*buf)[JS_DTOA_BUF_SIZE], double d,\n                     int radix, int n_digits, int flags)\n{\n    char *q;\n\n    if (!isfinite(d)) {\n        if (isnan(d)) {\n            pstrcpy(*buf, sizeof(*buf), \"NaN\");\n        } else if (d < 0) {\n            pstrcpy(*buf, sizeof(*buf), \"-Infinity\");\n        } else {\n            pstrcpy(*buf, sizeof(*buf), \"Infinity\");\n        }\n    } else if (flags == JS_DTOA_VAR_FORMAT) {\n        int64_t i64;\n        char buf1[70], *ptr;\n        if (d > (double)MAX_SAFE_INTEGER || d < (double)-MAX_SAFE_INTEGER)\n            goto generic_conv;\n        i64 = (int64_t)d;\n        if (d != i64)\n            goto generic_conv;\n        /* fast path for integers */\n        ptr = i64toa(buf1 + sizeof(buf1), i64, radix);\n        pstrcpy(*buf, sizeof(*buf), ptr);\n    } else {\n        if (d == 0.0)\n            d = 0.0; /* convert -0 to 0 */\n        if (flags == JS_DTOA_FRAC_FORMAT) {\n            js_fcvt(buf, d, n_digits);\n        } else {\n            char buf1[JS_DTOA_BUF_SIZE];\n            int sign, decpt, k, n, i, p, n_max;\n            BOOL is_fixed;\n        generic_conv:\n            is_fixed = ((flags & 3) == JS_DTOA_FIXED_FORMAT);\n            if (is_fixed) {\n                n_max = n_digits;\n            } else {\n                n_max = 21;\n            }\n            /* the number has k digits (k >= 1) */\n            k = js_ecvt(d, n_digits, &decpt, &sign, buf1, is_fixed);\n            n = decpt; /* d=10^(n-k)*(buf1) i.e. d= < x.yyyy 10^(n-1) */\n            q = *buf;\n            if (sign)\n                *q++ = '-';\n            if (flags & JS_DTOA_FORCE_EXP)\n                goto force_exp;\n            if (n >= 1 && n <= n_max) {\n                if (k <= n) {\n                    memcpy(q, buf1, k);\n                    q += k;\n                    for(i = 0; i < (n - k); i++)\n                        *q++ = '0';\n                    *q = '\\0';\n                } else {\n                    /* k > n */\n                    memcpy(q, buf1, n);\n                    q += n;\n                    *q++ = '.';\n                    for(i = 0; i < (k - n); i++)\n                        *q++ = buf1[n + i];\n                    *q = '\\0';\n                }\n            } else if (n >= -5 && n <= 0) {\n                *q++ = '0';\n                *q++ = '.';\n                for(i = 0; i < -n; i++)\n                    *q++ = '0';\n                memcpy(q, buf1, k);\n                q += k;\n                *q = '\\0';\n            } else {\n            force_exp:\n                /* exponential notation */\n                *q++ = buf1[0];\n                if (k > 1) {\n                    *q++ = '.';\n                    for(i = 1; i < k; i++)\n                        *q++ = buf1[i];\n                }\n                *q++ = 'e';\n                p = n - 1;\n                if (p >= 0)\n                    *q++ = '+';\n                snprintf(q, *buf + sizeof(*buf) - q, \"%d\", p);\n            }\n        }\n    }\n}\n\nstatic JSValue js_dtoa(JSContext *ctx,\n                       double d, int radix, int n_digits, int flags)\n{\n    char buf[JS_DTOA_BUF_SIZE];\n    js_dtoa1(&buf, d, radix, n_digits, flags);\n    return JS_NewString(ctx, buf);\n}\n\nstatic JSValue js_dtoa_radix(JSContext *ctx, double d, int radix)\n{\n    char buf[2200], *ptr, *ptr2;\n    /* d is finite */\n    int sign = d < 0;\n    int digit;\n    double frac, d0;\n    int64_t n0 = 0;\n    d = fabs(d);\n    d0 = trunc(d);\n    frac = d - d0;\n    ptr = buf + 1100;\n    *ptr = '\\0';\n    if (d0 <= MAX_SAFE_INTEGER) {\n        int64_t n = n0 = (int64_t)d0;\n        while (n >= radix) {\n            digit = n % radix;\n            n = n / radix;\n            *--ptr = digits[digit];\n        }\n        *--ptr = digits[(int)n];\n    } else {\n        /* no decimals */\n        while (d0 >= radix) {\n            digit = fmod(d0, radix);\n            d0 = trunc(d0 / radix);\n            if (d0 >= MAX_SAFE_INTEGER)\n                digit = 0;\n            *--ptr = digits[digit];\n        }\n        *--ptr = digits[(int)d0];\n        goto done;\n    }\n    if (frac != 0) {\n        double log2_radix = log2(radix);\n        double prec = 1023 + 51;  // handle subnormals\n        ptr2 = buf + 1100;\n        *ptr2++ = '.';\n        while (frac != 0 && n0 <= MAX_SAFE_INTEGER/2 && prec > 0) {\n            frac *= radix;\n            digit = trunc(frac);\n            frac -= digit;\n            *ptr2++ = digits[digit];\n            n0 = n0 * radix + digit;\n            prec -= log2_radix;\n        }\n        *ptr2 = '\\0';\n        if (frac * radix >= radix / 2) {\n            char nine = digits[radix - 1];\n            // round to closest\n            while (ptr2[-1] == nine)\n                *--ptr2 = '\\0';\n            if (ptr2[-1] == '.') {\n                *--ptr2 = '\\0';\n                while (ptr2[-1] == nine)\n                    *--ptr2 = '0';\n            }\n            if (ptr2 - 1 == ptr)\n                *--ptr = '1';\n            else\n                ptr2[-1] += 1;\n        } else {\n            while (ptr2[-1] == '0')\n                *--ptr2 = '\\0';\n            if (ptr2[-1] == '.')\n                *--ptr2 = '\\0';\n        }\n    }\ndone:\n    ptr[-1] = '-';\n    ptr -= sign;\n    return JS_NewString(ctx, ptr);\n}\n\nJSValue JS_ToStringInternal(JSContext *ctx, JSValueConst val, BOOL is_ToPropertyKey)\n{\n    uint32_t tag;\n    const char *str;\n    char buf[32];\n\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_STRING:\n        return JS_DupValue(ctx, val);\n    case JS_TAG_INT:\n        snprintf(buf, sizeof(buf), \"%d\", JS_VALUE_GET_INT(val));\n        str = buf;\n        goto new_string;\n    case JS_TAG_BOOL:\n        return JS_AtomToString(ctx, JS_VALUE_GET_BOOL(val) ?\n                          JS_ATOM_true : JS_ATOM_false);\n    case JS_TAG_NULL:\n        return JS_AtomToString(ctx, JS_ATOM_null);\n    case JS_TAG_UNDEFINED:\n        return JS_AtomToString(ctx, JS_ATOM_undefined);\n    case JS_TAG_EXCEPTION:\n        return JS_EXCEPTION;\n    case JS_TAG_OBJECT:\n        {\n            JSValue val1, ret;\n            val1 = JS_ToPrimitive(ctx, val, HINT_STRING);\n            if (JS_IsException(val1))\n                return val1;\n            ret = JS_ToStringInternal(ctx, val1, is_ToPropertyKey);\n            JS_FreeValue(ctx, val1);\n            return ret;\n        }\n        break;\n    case JS_TAG_FUNCTION_BYTECODE:\n        str = \"[function bytecode]\";\n        goto new_string;\n    case JS_TAG_SYMBOL:\n        if (is_ToPropertyKey) {\n            return JS_DupValue(ctx, val);\n        } else {\n            return JS_ThrowTypeError(ctx, \"cannot convert symbol to string\");\n        }\n    case JS_TAG_FLOAT64:\n        return js_dtoa(ctx, JS_VALUE_GET_FLOAT64(val), 10, 0,\n                       JS_DTOA_VAR_FORMAT);\n    case JS_TAG_BIG_INT:\n        return ctx->rt->bigint_ops.to_string(ctx, val);\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        return ctx->rt->bigfloat_ops.to_string(ctx, val);\n    case JS_TAG_BIG_DECIMAL:\n        return ctx->rt->bigdecimal_ops.to_string(ctx, val);\n#endif\n    default:\n        str = \"[unsupported type]\";\n    new_string:\n        return JS_NewString(ctx, str);\n    }\n}\n\nJSValue JS_ToString(JSContext *ctx, JSValueConst val)\n{\n    return JS_ToStringInternal(ctx, val, FALSE);\n}\n\nstatic JSValue JS_ToStringFree(JSContext *ctx, JSValue val)\n{\n    JSValue ret;\n    ret = JS_ToString(ctx, val);\n    JS_FreeValue(ctx, val);\n    return ret;\n}\n\nstatic JSValue JS_ToLocaleStringFree(JSContext *ctx, JSValue val)\n{\n    if (JS_IsUndefined(val) || JS_IsNull(val))\n        return JS_ToStringFree(ctx, val);\n    return JS_InvokeFree(ctx, val, JS_ATOM_toLocaleString, 0, NULL);\n}\n\nJSValue JS_ToPropertyKey(JSContext *ctx, JSValueConst val)\n{\n    return JS_ToStringInternal(ctx, val, TRUE);\n}\n\nstatic JSValue JS_ToStringCheckObject(JSContext *ctx, JSValueConst val)\n{\n    uint32_t tag = JS_VALUE_GET_TAG(val);\n    if (tag == JS_TAG_NULL || tag == JS_TAG_UNDEFINED)\n        return JS_ThrowTypeError(ctx, \"null or undefined are forbidden\");\n    return JS_ToString(ctx, val);\n}\n\nstatic JSValue JS_ToQuotedString(JSContext *ctx, JSValueConst val1)\n{\n    JSValue val;\n    JSString *p;\n    int i;\n    uint32_t c;\n    StringBuffer b_s, *b = &b_s;\n    char buf[16];\n\n    val = JS_ToStringCheckObject(ctx, val1);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_STRING(val);\n\n    if (string_buffer_init(ctx, b, p->len + 2))\n        goto fail;\n\n    if (string_buffer_putc8(b, '\\\"'))\n        goto fail;\n    for(i = 0; i < p->len; ) {\n        c = string_getc(p, &i);\n        switch(c) {\n        case '\\t':\n            c = 't';\n            goto quote;\n        case '\\r':\n            c = 'r';\n            goto quote;\n        case '\\n':\n            c = 'n';\n            goto quote;\n        case '\\b':\n            c = 'b';\n            goto quote;\n        case '\\f':\n            c = 'f';\n            goto quote;\n        case '\\\"':\n        case '\\\\':\n        quote:\n            if (string_buffer_putc8(b, '\\\\'))\n                goto fail;\n            if (string_buffer_putc8(b, c))\n                goto fail;\n            break;\n        default:\n            if (c < 32 || is_surrogate(c)) {\n                snprintf(buf, sizeof(buf), \"\\\\u%04x\", c);\n                if (string_buffer_puts8(b, buf))\n                    goto fail;\n            } else {\n                if (string_buffer_putc(b, c))\n                    goto fail;\n            }\n            break;\n        }\n    }\n    if (string_buffer_putc8(b, '\\\"'))\n        goto fail;\n    JS_FreeValue(ctx, val);\n    return string_buffer_end(b);\n fail:\n    JS_FreeValue(ctx, val);\n    string_buffer_free(b);\n    return JS_EXCEPTION;\n}\n\nstatic __maybe_unused void JS_DumpObjectHeader(JSRuntime *rt)\n{\n    printf(\"%14s %4s %4s %14s %10s %s\\n\",\n           \"ADDRESS\", \"REFS\", \"SHRF\", \"PROTO\", \"CLASS\", \"PROPS\");\n}\n\n/* for debug only: dump an object without side effect */\nstatic __maybe_unused void JS_DumpObject(JSRuntime *rt, JSObject *p)\n{\n    uint32_t i;\n    char atom_buf[ATOM_GET_STR_BUF_SIZE];\n    JSShape *sh;\n    JSShapeProperty *prs;\n    JSProperty *pr;\n    BOOL is_first = TRUE;\n\n    /* XXX: should encode atoms with special characters */\n    sh = p->shape; /* the shape can be NULL while freeing an object */\n    printf(\"%14p %4d \",\n           (void *)p,\n           p->header.ref_count);\n    if (sh) {\n        printf(\"%3d%c %14p \",\n               sh->header.ref_count,\n               \" *\"[sh->is_hashed],\n               (void *)sh->proto);\n    } else {\n        printf(\"%3s  %14s \", \"-\", \"-\");\n    }\n    printf(\"%10s \",\n           JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), rt->class_array[p->class_id].class_name));\n    if (p->is_exotic && p->fast_array) {\n        printf(\"[ \");\n        for(i = 0; i < p->u.array.count; i++) {\n            if (i != 0)\n                printf(\", \");\n            switch (p->class_id) {\n            case JS_CLASS_ARRAY:\n            case JS_CLASS_ARGUMENTS:\n                JS_DumpValueShort(rt, p->u.array.u.values[i]);\n                break;\n            case JS_CLASS_UINT8C_ARRAY:\n            case JS_CLASS_INT8_ARRAY:\n            case JS_CLASS_UINT8_ARRAY:\n            case JS_CLASS_INT16_ARRAY:\n            case JS_CLASS_UINT16_ARRAY:\n            case JS_CLASS_INT32_ARRAY:\n            case JS_CLASS_UINT32_ARRAY:\n            case JS_CLASS_BIG_INT64_ARRAY:\n            case JS_CLASS_BIG_UINT64_ARRAY:\n            case JS_CLASS_FLOAT32_ARRAY:\n            case JS_CLASS_FLOAT64_ARRAY:\n                {\n                    int size = 1 << typed_array_size_log2(p->class_id);\n                    const uint8_t *b = p->u.array.u.uint8_ptr + i * size;\n                    while (size-- > 0)\n                        printf(\"%02X\", *b++);\n                }\n                break;\n            }\n        }\n        printf(\" ] \");\n    }\n\n    if (sh) {\n        printf(\"{ \");\n        for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {\n            if (prs->atom != JS_ATOM_NULL) {\n                pr = &p->prop[i];\n                if (!is_first)\n                    printf(\", \");\n                printf(\"%s: \",\n                       JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), prs->atom));\n                if ((prs->flags & JS_PROP_TMASK) == JS_PROP_GETSET) {\n                    printf(\"[getset %p %p]\", (void *)pr->u.getset.getter,\n                           (void *)pr->u.getset.setter);\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {\n                    printf(\"[varref %p]\", (void *)pr->u.var_ref);\n                } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {\n                    printf(\"[autoinit %p %d %p]\",\n                           (void *)js_autoinit_get_realm(pr),\n                           js_autoinit_get_id(pr),\n                           (void *)pr->u.init.opaque);\n                } else {\n                    JS_DumpValueShort(rt, pr->u.value);\n                }\n                is_first = FALSE;\n            }\n        }\n        printf(\" }\");\n    }\n\n    if (js_class_has_bytecode(p->class_id)) {\n        JSFunctionBytecode *b = p->u.func.function_bytecode;\n        JSVarRef **var_refs;\n        if (b->closure_var_count) {\n            var_refs = p->u.func.var_refs;\n            printf(\" Closure:\");\n            for(i = 0; i < b->closure_var_count; i++) {\n                printf(\" \");\n                JS_DumpValueShort(rt, var_refs[i]->value);\n            }\n            if (p->u.func.home_object) {\n                printf(\" HomeObject: \");\n                JS_DumpValueShort(rt, JS_MKPTR(JS_TAG_OBJECT, p->u.func.home_object));\n            }\n        }\n    }\n    printf(\"\\n\");\n}\n\nstatic __maybe_unused void JS_DumpGCObject(JSRuntime *rt, JSGCObjectHeader *p)\n{\n    if (p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT) {\n        JS_DumpObject(rt, (JSObject *)p);\n    } else {\n        printf(\"%14p %4d \",\n               (void *)p,\n               p->ref_count);\n        switch(p->gc_obj_type) {\n        case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:\n            printf(\"[function bytecode]\");\n            break;\n        case JS_GC_OBJ_TYPE_SHAPE:\n            printf(\"[shape]\");\n            break;\n        case JS_GC_OBJ_TYPE_VAR_REF:\n            printf(\"[var_ref]\");\n            break;\n        case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:\n            printf(\"[async_function]\");\n            break;\n        case JS_GC_OBJ_TYPE_JS_CONTEXT:\n            printf(\"[js_context]\");\n            break;\n        default:\n            printf(\"[unknown %d]\", p->gc_obj_type);\n            break;\n        }\n        printf(\"\\n\");\n    }\n}\n\nstatic __maybe_unused void JS_DumpValueShort(JSRuntime *rt,\n                                                      JSValueConst val)\n{\n    uint32_t tag = JS_VALUE_GET_NORM_TAG(val);\n    const char *str;\n\n    switch(tag) {\n    case JS_TAG_INT:\n        printf(\"%d\", JS_VALUE_GET_INT(val));\n        break;\n    case JS_TAG_BOOL:\n        if (JS_VALUE_GET_BOOL(val))\n            str = \"true\";\n        else\n            str = \"false\";\n        goto print_str;\n    case JS_TAG_NULL:\n        str = \"null\";\n        goto print_str;\n    case JS_TAG_EXCEPTION:\n        str = \"exception\";\n        goto print_str;\n    case JS_TAG_UNINITIALIZED:\n        str = \"uninitialized\";\n        goto print_str;\n    case JS_TAG_UNDEFINED:\n        str = \"undefined\";\n    print_str:\n        printf(\"%s\", str);\n        break;\n    case JS_TAG_FLOAT64:\n        printf(\"%.14g\", JS_VALUE_GET_FLOAT64(val));\n        break;\n    case JS_TAG_BIG_INT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            char *str;\n            str = bf_ftoa(NULL, &p->num, 10, 0,\n                          BF_RNDZ | BF_FTOA_FORMAT_FRAC);\n            printf(\"%sn\", str);\n            bf_realloc(&rt->bf_ctx, str, 0);\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p = JS_VALUE_GET_PTR(val);\n            char *str;\n            str = bf_ftoa(NULL, &p->num, 16, BF_PREC_INF,\n                          BF_RNDZ | BF_FTOA_FORMAT_FREE | BF_FTOA_ADD_PREFIX);\n            printf(\"%sl\", str);\n            bf_free(&rt->bf_ctx, str);\n        }\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        {\n            JSBigDecimal *p = JS_VALUE_GET_PTR(val);\n            char *str;\n            str = bfdec_ftoa(NULL, &p->num, BF_PREC_INF,\n                             BF_RNDZ | BF_FTOA_FORMAT_FREE);\n            printf(\"%sm\", str);\n            bf_free(&rt->bf_ctx, str);\n        }\n        break;\n#endif\n    case JS_TAG_STRING:\n        {\n            JSString *p;\n            p = JS_VALUE_GET_STRING(val);\n            JS_DumpString(rt, p);\n        }\n        break;\n    case JS_TAG_FUNCTION_BYTECODE:\n        {\n            JSFunctionBytecode *b = JS_VALUE_GET_PTR(val);\n            char buf[ATOM_GET_STR_BUF_SIZE];\n            printf(\"[bytecode %s]\", JS_AtomGetStrRT(rt, buf, sizeof(buf), b->func_name));\n        }\n        break;\n    case JS_TAG_OBJECT:\n        {\n            JSObject *p = JS_VALUE_GET_OBJ(val);\n            JSAtom atom = rt->class_array[p->class_id].class_name;\n            char atom_buf[ATOM_GET_STR_BUF_SIZE];\n            printf(\"[%s %p]\",\n                   JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), atom), (void *)p);\n        }\n        break;\n    case JS_TAG_SYMBOL:\n        {\n            JSAtomStruct *p = JS_VALUE_GET_PTR(val);\n            char atom_buf[ATOM_GET_STR_BUF_SIZE];\n            printf(\"Symbol(%s)\",\n                   JS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), js_get_atom_index(rt, p)));\n        }\n        break;\n    case JS_TAG_MODULE:\n        printf(\"[module]\");\n        break;\n    default:\n        printf(\"[unknown tag %d]\", tag);\n        break;\n    }\n}\n\nstatic __maybe_unused void JS_DumpValue(JSContext *ctx,\n                                                 JSValueConst val)\n{\n    JS_DumpValueShort(ctx->rt, val);\n}\n\nstatic __maybe_unused void JS_PrintValue(JSContext *ctx,\n                                                  const char *str,\n                                                  JSValueConst val)\n{\n    printf(\"%s=\", str);\n    JS_DumpValueShort(ctx->rt, val);\n    printf(\"\\n\");\n}\n\n/* return -1 if exception (proxy case) or TRUE/FALSE */\n// TODO: should take flags to make proxy resolution and exceptions optional\nint JS_IsArray(JSContext *ctx, JSValueConst val)\n{\n    if (js_resolve_proxy(ctx, &val, TRUE))\n        return -1;\n    if (JS_VALUE_GET_TAG(val) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(val);\n        return p->class_id == JS_CLASS_ARRAY;\n    } else {\n        return FALSE;\n    }\n}\n\nstatic double js_pow(double a, double b)\n{\n    if (unlikely(!isfinite(b)) && fabs(a) == 1) {\n        /* not compatible with IEEE 754 */\n        return JS_FLOAT64_NAN;\n    } else {\n        return pow(a, b);\n    }\n}\n\nJSValue JS_NewBigInt64_1(JSContext *ctx, int64_t v)\n{\n    JSValue val;\n    bf_t *a;\n    val = JS_NewBigInt(ctx);\n    if (JS_IsException(val))\n        return val;\n    a = JS_GetBigInt(val);\n    if (bf_set_si(a, v)) {\n        JS_FreeValue(ctx, val);\n        return JS_ThrowOutOfMemory(ctx);\n    }\n    return val;\n}\n\nJSValue JS_NewBigInt64(JSContext *ctx, int64_t v)\n{\n    if (is_math_mode(ctx) &&\n        v >= -MAX_SAFE_INTEGER && v <= MAX_SAFE_INTEGER) {\n        return JS_NewInt64(ctx, v);\n    } else {\n        return JS_NewBigInt64_1(ctx, v);\n    }\n}\n\nJSValue JS_NewBigUint64(JSContext *ctx, uint64_t v)\n{\n    JSValue val;\n    if (is_math_mode(ctx) && v <= MAX_SAFE_INTEGER) {\n        val = JS_NewInt64(ctx, v);\n    } else {\n        bf_t *a;\n        val = JS_NewBigInt(ctx);\n        if (JS_IsException(val))\n            return val;\n        a = JS_GetBigInt(val);\n        if (bf_set_ui(a, v)) {\n            JS_FreeValue(ctx, val);\n            return JS_ThrowOutOfMemory(ctx);\n        }\n    }\n    return val;\n}\n\n/* return NaN if bad bigint literal */\nstatic JSValue JS_StringToBigInt(JSContext *ctx, JSValue val)\n{\n    const char *str, *p;\n    size_t len;\n    int flags;\n\n    str = JS_ToCStringLen(ctx, &len, val);\n    JS_FreeValue(ctx, val);\n    if (!str)\n        return JS_EXCEPTION;\n    p = str;\n    p += skip_spaces(p);\n    if ((p - str) == len) {\n        val = JS_NewBigInt64(ctx, 0);\n    } else {\n        flags = ATOD_INT_ONLY | ATOD_ACCEPT_BIN_OCT | ATOD_TYPE_BIG_INT;\n#ifdef CONFIG_BIGNUM\n        if (is_math_mode(ctx))\n            flags |= ATOD_MODE_BIGINT;\n#endif\n        val = js_atof(ctx, p, &p, 0, flags);\n        p += skip_spaces(p);\n        if (!JS_IsException(val)) {\n            if ((p - str) != len) {\n                JS_FreeValue(ctx, val);\n                val = JS_NAN;\n            }\n        }\n    }\n    JS_FreeCString(ctx, str);\n    return val;\n}\n\nstatic JSValue JS_StringToBigIntErr(JSContext *ctx, JSValue val)\n{\n    val = JS_StringToBigInt(ctx, val);\n    if (JS_VALUE_IS_NAN(val))\n        return JS_ThrowSyntaxError(ctx, \"invalid bigint literal\");\n    return val;\n}\n\n/* if the returned bigfloat is allocated it is equal to\n   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. */\nstatic bf_t *JS_ToBigIntFree(JSContext *ctx, bf_t *buf, JSValue val)\n{\n    uint32_t tag;\n    bf_t *r;\n    JSBigFloat *p;\n\n redo:\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        if (!is_math_mode(ctx))\n            goto fail;\n        /* fall tru */\n    case JS_TAG_BOOL:\n        r = buf;\n        bf_init(ctx->bf_ctx, r);\n        bf_set_si(r, JS_VALUE_GET_INT(val));\n        break;\n    case JS_TAG_FLOAT64:\n        {\n            double d = JS_VALUE_GET_FLOAT64(val);\n            if (!is_math_mode(ctx))\n                goto fail;\n            if (!isfinite(d))\n                goto fail;\n            r = buf;\n            bf_init(ctx->bf_ctx, r);\n            d = trunc(d);\n            bf_set_float64(r, d);\n        }\n        break;\n    case JS_TAG_BIG_INT:\n        p = JS_VALUE_GET_PTR(val);\n        r = &p->num;\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        if (!is_math_mode(ctx))\n            goto fail;\n        p = JS_VALUE_GET_PTR(val);\n        if (!bf_is_finite(&p->num))\n            goto fail;\n        r = buf;\n        bf_init(ctx->bf_ctx, r);\n        bf_set(r, &p->num);\n        bf_rint(r, BF_RNDZ);\n        JS_FreeValue(ctx, val);\n        break;\n#endif\n    case JS_TAG_STRING:\n        val = JS_StringToBigIntErr(ctx, val);\n        if (JS_IsException(val))\n            return NULL;\n        goto redo;\n    case JS_TAG_OBJECT:\n        val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);\n        if (JS_IsException(val))\n            return NULL;\n        goto redo;\n    default:\n    fail:\n        JS_FreeValue(ctx, val);\n        JS_ThrowTypeError(ctx, \"cannot convert to bigint\");\n        return NULL;\n    }\n    return r;\n}\n\nstatic bf_t *JS_ToBigInt(JSContext *ctx, bf_t *buf, JSValueConst val)\n{\n    return JS_ToBigIntFree(ctx, buf, JS_DupValue(ctx, val));\n}\n\nstatic __maybe_unused JSValue JS_ToBigIntValueFree(JSContext *ctx, JSValue val)\n{\n    if (JS_VALUE_GET_TAG(val) == JS_TAG_BIG_INT) {\n        return val;\n    } else {\n        bf_t a_s, *a, *r;\n        int ret;\n        JSValue res;\n\n        res = JS_NewBigInt(ctx);\n        if (JS_IsException(res))\n            return JS_EXCEPTION;\n        a = JS_ToBigIntFree(ctx, &a_s, val);\n        if (!a) {\n            JS_FreeValue(ctx, res);\n            return JS_EXCEPTION;\n        }\n        r = JS_GetBigInt(res);\n        ret = bf_set(r, a);\n        JS_FreeBigInt(ctx, a, &a_s);\n        if (ret) {\n            JS_FreeValue(ctx, res);\n            return JS_ThrowOutOfMemory(ctx);\n        }\n        return JS_CompactBigInt(ctx, res);\n    }\n}\n\n/* free the bf_t allocated by JS_ToBigInt */\nstatic void JS_FreeBigInt(JSContext *ctx, bf_t *a, bf_t *buf)\n{\n    if (a == buf) {\n        bf_delete(a);\n    } else {\n        JSBigFloat *p = (JSBigFloat *)((uint8_t *)a -\n                                       offsetof(JSBigFloat, num));\n        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_BIG_INT, p));\n    }\n}\n\n/* XXX: merge with JS_ToInt64Free with a specific flag */\nstatic int JS_ToBigInt64Free(JSContext *ctx, int64_t *pres, JSValue val)\n{\n    bf_t a_s, *a;\n\n    a = JS_ToBigIntFree(ctx, &a_s, val);\n    if (!a) {\n        *pres = 0;\n        return -1;\n    }\n    bf_get_int64(pres, a, BF_GET_INT_MOD);\n    JS_FreeBigInt(ctx, a, &a_s);\n    return 0;\n}\n\nint JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val)\n{\n    return JS_ToBigInt64Free(ctx, pres, JS_DupValue(ctx, val));\n}\n\nstatic JSBigFloat *js_new_bf(JSContext *ctx)\n{\n    JSBigFloat *p;\n    p = js_malloc(ctx, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->header.ref_count = 1;\n    bf_init(ctx->bf_ctx, &p->num);\n    return p;\n}\n\nstatic JSValue JS_NewBigInt(JSContext *ctx)\n{\n    JSBigFloat *p;\n    p = js_malloc(ctx, sizeof(*p));\n    if (!p)\n        return JS_EXCEPTION;\n    p->header.ref_count = 1;\n    bf_init(ctx->bf_ctx, &p->num);\n    return JS_MKPTR(JS_TAG_BIG_INT, p);\n}\n\nstatic JSValue JS_CompactBigInt1(JSContext *ctx, JSValue val,\n                                 BOOL convert_to_safe_integer)\n{\n    int64_t v;\n    bf_t *a;\n\n    if (JS_VALUE_GET_TAG(val) != JS_TAG_BIG_INT)\n        return val; /* fail safe */\n    a = JS_GetBigInt(val);\n    if (convert_to_safe_integer && bf_get_int64(&v, a, 0) == 0 &&\n        v >= -MAX_SAFE_INTEGER && v <= MAX_SAFE_INTEGER) {\n        JS_FreeValue(ctx, val);\n        return JS_NewInt64(ctx, v);\n    } else if (a->expn == BF_EXP_ZERO && a->sign) {\n        JSBigFloat *p = JS_VALUE_GET_PTR(val);\n        assert(p->header.ref_count == 1);\n        a->sign = 0;\n    }\n    return val;\n}\n\n/* Convert the big int to a safe integer if in math mode. normalize\n   the zero representation. Could also be used to convert the bigint\n   to a short bigint value. The reference count of the value must be\n   1. Cannot fail */\nstatic JSValue JS_CompactBigInt(JSContext *ctx, JSValue val)\n{\n    return JS_CompactBigInt1(ctx, val, is_math_mode(ctx));\n}\n\nstatic JSValue throw_bf_exception(JSContext *ctx, int status)\n{\n    const char *str;\n    if (status & BF_ST_MEM_ERROR)\n        return JS_ThrowOutOfMemory(ctx);\n    if (status & BF_ST_DIVIDE_ZERO) {\n        str = \"division by zero\";\n    } else if (status & BF_ST_INVALID_OP) {\n        str = \"invalid operation\";\n    } else {\n        str = \"integer overflow\";\n    }\n    return JS_ThrowRangeError(ctx, \"%s\", str);\n}\n\n/* if the returned bigfloat is allocated it is equal to\n   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. Return\n   NULL in case of error. */\nstatic bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val)\n{\n    uint32_t tag;\n    bf_t *r;\n    JSBigFloat *p;\n\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_INT:\n    case JS_TAG_BOOL:\n    case JS_TAG_NULL:\n        r = buf;\n        bf_init(ctx->bf_ctx, r);\n        if (bf_set_si(r, JS_VALUE_GET_INT(val)))\n            goto fail;\n        break;\n    case JS_TAG_FLOAT64:\n        r = buf;\n        bf_init(ctx->bf_ctx, r);\n        if (bf_set_float64(r, JS_VALUE_GET_FLOAT64(val))) {\n        fail:\n            bf_delete(r);\n            return NULL;\n        }\n        break;\n    case JS_TAG_BIG_INT:\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n#endif\n        p = JS_VALUE_GET_PTR(val);\n        r = &p->num;\n        break;\n    case JS_TAG_UNDEFINED:\n    default:\n        r = buf;\n        bf_init(ctx->bf_ctx, r);\n        bf_set_nan(r);\n        break;\n    }\n    return r;\n}\n\n#ifdef CONFIG_BIGNUM\n/* return NULL if invalid type */\nstatic bfdec_t *JS_ToBigDecimal(JSContext *ctx, JSValueConst val)\n{\n    uint32_t tag;\n    JSBigDecimal *p;\n    bfdec_t *r;\n\n    tag = JS_VALUE_GET_NORM_TAG(val);\n    switch(tag) {\n    case JS_TAG_BIG_DECIMAL:\n        p = JS_VALUE_GET_PTR(val);\n        r = &p->num;\n        break;\n    default:\n        JS_ThrowTypeError(ctx, \"bigdecimal expected\");\n        r = NULL;\n        break;\n    }\n    return r;\n}\n\nstatic JSValue JS_NewBigFloat(JSContext *ctx)\n{\n    JSBigFloat *p;\n    p = js_malloc(ctx, sizeof(*p));\n    if (!p)\n        return JS_EXCEPTION;\n    p->header.ref_count = 1;\n    bf_init(ctx->bf_ctx, &p->num);\n    return JS_MKPTR(JS_TAG_BIG_FLOAT, p);\n}\n\nstatic JSValue JS_NewBigDecimal(JSContext *ctx)\n{\n    JSBigDecimal *p;\n    p = js_malloc(ctx, sizeof(*p));\n    if (!p)\n        return JS_EXCEPTION;\n    p->header.ref_count = 1;\n    bfdec_init(ctx->bf_ctx, &p->num);\n    return JS_MKPTR(JS_TAG_BIG_DECIMAL, p);\n}\n\n/* must be kept in sync with JSOverloadableOperatorEnum */\n/* XXX: use atoms ? */\nstatic const char js_overloadable_operator_names[JS_OVOP_COUNT][4] = {\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"**\",\n    \"|\",\n    \"&\",\n    \"^\",\n    \"<<\",\n    \">>\",\n    \">>>\",\n    \"==\",\n    \"<\",\n    \"pos\",\n    \"neg\",\n    \"++\",\n    \"--\",\n    \"~\",\n};\n\nstatic int get_ovop_from_opcode(OPCodeEnum op)\n{\n    switch(op) {\n    case OP_add:\n        return JS_OVOP_ADD;\n    case OP_sub:\n        return JS_OVOP_SUB;\n    case OP_mul:\n        return JS_OVOP_MUL;\n    case OP_div:\n        return JS_OVOP_DIV;\n    case OP_mod:\n    case OP_math_mod:\n        return JS_OVOP_MOD;\n    case OP_pow:\n        return JS_OVOP_POW;\n    case OP_or:\n        return JS_OVOP_OR;\n    case OP_and:\n        return JS_OVOP_AND;\n    case OP_xor:\n        return JS_OVOP_XOR;\n    case OP_shl:\n        return JS_OVOP_SHL;\n    case OP_sar:\n        return JS_OVOP_SAR;\n    case OP_shr:\n        return JS_OVOP_SHR;\n    case OP_eq:\n    case OP_neq:\n        return JS_OVOP_EQ;\n    case OP_lt:\n    case OP_lte:\n    case OP_gt:\n    case OP_gte:\n        return JS_OVOP_LESS;\n    case OP_plus:\n        return JS_OVOP_POS;\n    case OP_neg:\n        return JS_OVOP_NEG;\n    case OP_inc:\n        return JS_OVOP_INC;\n    case OP_dec:\n        return JS_OVOP_DEC;\n    default:\n        abort();\n    }\n}\n\n/* return NULL if not present */\nstatic JSObject *find_binary_op(JSBinaryOperatorDef *def,\n                                uint32_t operator_index,\n                                JSOverloadableOperatorEnum op)\n{\n    JSBinaryOperatorDefEntry *ent;\n    int i;\n    for(i = 0; i < def->count; i++) {\n        ent = &def->tab[i];\n        if (ent->operator_index == operator_index)\n            return ent->ops[op];\n    }\n    return NULL;\n}\n\n/* return -1 if exception, 0 if no operator overloading, 1 if\n   overloaded operator called */\nstatic __exception int js_call_binary_op_fallback(JSContext *ctx,\n                                                  JSValue *pret,\n                                                  JSValueConst op1,\n                                                  JSValueConst op2,\n                                                  OPCodeEnum op,\n                                                  BOOL is_numeric,\n                                                  int hint)\n{\n    JSValue opset1_obj, opset2_obj, method, ret, new_op1, new_op2;\n    JSOperatorSetData *opset1, *opset2;\n    JSOverloadableOperatorEnum ovop;\n    JSObject *p;\n    JSValueConst args[2];\n\n    if (!ctx->allow_operator_overloading)\n        return 0;\n\n    opset2_obj = JS_UNDEFINED;\n    opset1_obj = JS_GetProperty(ctx, op1, JS_ATOM_Symbol_operatorSet);\n    if (JS_IsException(opset1_obj))\n        goto exception;\n    if (JS_IsUndefined(opset1_obj))\n        return 0;\n    opset1 = JS_GetOpaque2(ctx, opset1_obj, JS_CLASS_OPERATOR_SET);\n    if (!opset1)\n        goto exception;\n\n    opset2_obj = JS_GetProperty(ctx, op2, JS_ATOM_Symbol_operatorSet);\n    if (JS_IsException(opset2_obj))\n        goto exception;\n    if (JS_IsUndefined(opset2_obj)) {\n        JS_FreeValue(ctx, opset1_obj);\n        return 0;\n    }\n    opset2 = JS_GetOpaque2(ctx, opset2_obj, JS_CLASS_OPERATOR_SET);\n    if (!opset2)\n        goto exception;\n\n    if (opset1->is_primitive && opset2->is_primitive) {\n        JS_FreeValue(ctx, opset1_obj);\n        JS_FreeValue(ctx, opset2_obj);\n        return 0;\n    }\n\n    ovop = get_ovop_from_opcode(op);\n\n    if (opset1->operator_counter == opset2->operator_counter) {\n        p = opset1->self_ops[ovop];\n    } else if (opset1->operator_counter > opset2->operator_counter) {\n        p = find_binary_op(&opset1->left, opset2->operator_counter, ovop);\n    } else {\n        p = find_binary_op(&opset2->right, opset1->operator_counter, ovop);\n    }\n    if (!p) {\n        JS_ThrowTypeError(ctx, \"operator %s: no function defined\",\n                          js_overloadable_operator_names[ovop]);\n        goto exception;\n    }\n\n    if (opset1->is_primitive) {\n        if (is_numeric) {\n            new_op1 = JS_ToNumeric(ctx, op1);\n        } else {\n            new_op1 = JS_ToPrimitive(ctx, op1, hint);\n        }\n        if (JS_IsException(new_op1))\n            goto exception;\n    } else {\n        new_op1 = JS_DupValue(ctx, op1);\n    }\n\n    if (opset2->is_primitive) {\n        if (is_numeric) {\n            new_op2 = JS_ToNumeric(ctx, op2);\n        } else {\n            new_op2 = JS_ToPrimitive(ctx, op2, hint);\n        }\n        if (JS_IsException(new_op2)) {\n            JS_FreeValue(ctx, new_op1);\n            goto exception;\n        }\n    } else {\n        new_op2 = JS_DupValue(ctx, op2);\n    }\n\n    /* XXX: could apply JS_ToPrimitive() if primitive type so that the\n       operator function does not get a value object */\n\n    method = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n    if (ovop == JS_OVOP_LESS && (op == OP_lte || op == OP_gt)) {\n        args[0] = new_op2;\n        args[1] = new_op1;\n    } else {\n        args[0] = new_op1;\n        args[1] = new_op2;\n    }\n    ret = JS_CallFree(ctx, method, JS_UNDEFINED, 2, args);\n    JS_FreeValue(ctx, new_op1);\n    JS_FreeValue(ctx, new_op2);\n    if (JS_IsException(ret))\n        goto exception;\n    if (ovop == JS_OVOP_EQ) {\n        BOOL res = JS_ToBoolFree(ctx, ret);\n        if (op == OP_neq)\n            res ^= 1;\n        ret = JS_NewBool(ctx, res);\n    } else if (ovop == JS_OVOP_LESS) {\n        if (JS_IsUndefined(ret)) {\n            ret = JS_FALSE;\n        } else {\n            BOOL res = JS_ToBoolFree(ctx, ret);\n            if (op == OP_lte || op == OP_gte)\n                res ^= 1;\n            ret = JS_NewBool(ctx, res);\n        }\n    }\n    JS_FreeValue(ctx, opset1_obj);\n    JS_FreeValue(ctx, opset2_obj);\n    *pret = ret;\n    return 1;\n exception:\n    JS_FreeValue(ctx, opset1_obj);\n    JS_FreeValue(ctx, opset2_obj);\n    *pret = JS_UNDEFINED;\n    return -1;\n}\n\n/* try to call the operation on the operatorSet field of 'obj'. Only\n   used for \"/\" and \"**\" on the BigInt prototype in math mode */\nstatic __exception int js_call_binary_op_simple(JSContext *ctx,\n                                                JSValue *pret,\n                                                JSValueConst obj,\n                                                JSValueConst op1,\n                                                JSValueConst op2,\n                                                OPCodeEnum op)\n{\n    JSValue opset1_obj, method, ret, new_op1, new_op2;\n    JSOperatorSetData *opset1;\n    JSOverloadableOperatorEnum ovop;\n    JSObject *p;\n    JSValueConst args[2];\n\n    opset1_obj = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_operatorSet);\n    if (JS_IsException(opset1_obj))\n        goto exception;\n    if (JS_IsUndefined(opset1_obj))\n        return 0;\n    opset1 = JS_GetOpaque2(ctx, opset1_obj, JS_CLASS_OPERATOR_SET);\n    if (!opset1)\n        goto exception;\n    ovop = get_ovop_from_opcode(op);\n\n    p = opset1->self_ops[ovop];\n    if (!p) {\n        JS_FreeValue(ctx, opset1_obj);\n        return 0;\n    }\n\n    new_op1 = JS_ToNumeric(ctx, op1);\n    if (JS_IsException(new_op1))\n        goto exception;\n    new_op2 = JS_ToNumeric(ctx, op2);\n    if (JS_IsException(new_op2)) {\n        JS_FreeValue(ctx, new_op1);\n        goto exception;\n    }\n\n    method = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n    args[0] = new_op1;\n    args[1] = new_op2;\n    ret = JS_CallFree(ctx, method, JS_UNDEFINED, 2, args);\n    JS_FreeValue(ctx, new_op1);\n    JS_FreeValue(ctx, new_op2);\n    if (JS_IsException(ret))\n        goto exception;\n    JS_FreeValue(ctx, opset1_obj);\n    *pret = ret;\n    return 1;\n exception:\n    JS_FreeValue(ctx, opset1_obj);\n    *pret = JS_UNDEFINED;\n    return -1;\n}\n\n/* return -1 if exception, 0 if no operator overloading, 1 if\n   overloaded operator called */\nstatic __exception int js_call_unary_op_fallback(JSContext *ctx,\n                                                 JSValue *pret,\n                                                 JSValueConst op1,\n                                                 OPCodeEnum op)\n{\n    JSValue opset1_obj, method, ret;\n    JSOperatorSetData *opset1;\n    JSOverloadableOperatorEnum ovop;\n    JSObject *p;\n\n    if (!ctx->allow_operator_overloading)\n        return 0;\n\n    opset1_obj = JS_GetProperty(ctx, op1, JS_ATOM_Symbol_operatorSet);\n    if (JS_IsException(opset1_obj))\n        goto exception;\n    if (JS_IsUndefined(opset1_obj))\n        return 0;\n    opset1 = JS_GetOpaque2(ctx, opset1_obj, JS_CLASS_OPERATOR_SET);\n    if (!opset1)\n        goto exception;\n    if (opset1->is_primitive) {\n        JS_FreeValue(ctx, opset1_obj);\n        return 0;\n    }\n\n    ovop = get_ovop_from_opcode(op);\n\n    p = opset1->self_ops[ovop];\n    if (!p) {\n        JS_ThrowTypeError(ctx, \"no overloaded operator %s\",\n                          js_overloadable_operator_names[ovop]);\n        goto exception;\n    }\n    method = JS_DupValue(ctx, JS_MKPTR(JS_TAG_OBJECT, p));\n    ret = JS_CallFree(ctx, method, JS_UNDEFINED, 1, &op1);\n    if (JS_IsException(ret))\n        goto exception;\n    JS_FreeValue(ctx, opset1_obj);\n    *pret = ret;\n    return 1;\n exception:\n    JS_FreeValue(ctx, opset1_obj);\n    *pret = JS_UNDEFINED;\n    return -1;\n}\n\nstatic int js_unary_arith_bigfloat(JSContext *ctx,\n                                   JSValue *pres, OPCodeEnum op, JSValue op1)\n{\n    bf_t a_s, *r, *a;\n    int ret, v;\n    JSValue res;\n\n    if (op == OP_plus && !is_math_mode(ctx)) {\n        JS_ThrowTypeError(ctx, \"bigfloat argument with unary +\");\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n\n    res = JS_NewBigFloat(ctx);\n    if (JS_IsException(res)) {\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    r = JS_GetBigFloat(res);\n    a = JS_ToBigFloat(ctx, &a_s, op1);\n    if (!a) {\n        JS_FreeValue(ctx, res);\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    ret = 0;\n    switch(op) {\n    case OP_inc:\n    case OP_dec:\n        v = 2 * (op - OP_dec) - 1;\n        ret = bf_add_si(r, a, v, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case OP_plus:\n        ret = bf_set(r, a);\n        break;\n    case OP_neg:\n        ret = bf_set(r, a);\n        bf_neg(r);\n        break;\n    default:\n        abort();\n    }\n    if (a == &a_s)\n        bf_delete(a);\n    JS_FreeValue(ctx, op1);\n    if (unlikely(ret & BF_ST_MEM_ERROR)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    *pres = res;\n    return 0;\n}\n\nstatic int js_unary_arith_bigdecimal(JSContext *ctx,\n                                     JSValue *pres, OPCodeEnum op, JSValue op1)\n{\n    bfdec_t *r, *a;\n    int ret, v;\n    JSValue res;\n\n    if (op == OP_plus && !is_math_mode(ctx)) {\n        JS_ThrowTypeError(ctx, \"bigdecimal argument with unary +\");\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n\n    res = JS_NewBigDecimal(ctx);\n    if (JS_IsException(res)) {\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    r = JS_GetBigDecimal(res);\n    a = JS_ToBigDecimal(ctx, op1);\n    if (!a) {\n        JS_FreeValue(ctx, res);\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    ret = 0;\n    switch(op) {\n    case OP_inc:\n    case OP_dec:\n        v = 2 * (op - OP_dec) - 1;\n        ret = bfdec_add_si(r, a, v, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_plus:\n        ret = bfdec_set(r, a);\n        break;\n    case OP_neg:\n        ret = bfdec_set(r, a);\n        bfdec_neg(r);\n        break;\n    default:\n        abort();\n    }\n    JS_FreeValue(ctx, op1);\n    if (unlikely(ret)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    *pres = res;\n    return 0;\n}\n\n#endif /* CONFIG_BIGNUM */\n\nstatic int js_unary_arith_bigint(JSContext *ctx,\n                                 JSValue *pres, OPCodeEnum op, JSValue op1)\n{\n    bf_t a_s, *r, *a;\n    int ret, v;\n    JSValue res;\n\n    if (op == OP_plus && !is_math_mode(ctx)) {\n        JS_ThrowTypeError(ctx, \"bigint argument with unary +\");\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    res = JS_NewBigInt(ctx);\n    if (JS_IsException(res)) {\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    r = JS_GetBigInt(res);\n    a = JS_ToBigInt(ctx, &a_s, op1);\n    if (!a) {\n        JS_FreeValue(ctx, res);\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    ret = 0;\n    switch(op) {\n    case OP_inc:\n    case OP_dec:\n        v = 2 * (op - OP_dec) - 1;\n        ret = bf_add_si(r, a, v, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_plus:\n        ret = bf_set(r, a);\n        break;\n    case OP_neg:\n        ret = bf_set(r, a);\n        bf_neg(r);\n        break;\n    case OP_not:\n        ret = bf_add_si(r, a, 1, BF_PREC_INF, BF_RNDZ);\n        bf_neg(r);\n        break;\n    default:\n        abort();\n    }\n    JS_FreeBigInt(ctx, a, &a_s);\n    JS_FreeValue(ctx, op1);\n    if (unlikely(ret)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    res = JS_CompactBigInt(ctx, res);\n    *pres = res;\n    return 0;\n}\n\nstatic no_inline __exception int js_unary_arith_slow(JSContext *ctx,\n                                                     JSValue *sp,\n                                                     OPCodeEnum op)\n{\n    JSValue op1;\n    int v;\n    uint32_t tag;\n\n    op1 = sp[-1];\n    /* fast path for float64 */\n    if (JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(op1)))\n        goto handle_float64;\n#ifdef CONFIG_BIGNUM\n    if (JS_IsObject(op1)) {\n        JSValue val;\n        int ret = js_call_unary_op_fallback(ctx, &val, op1, op);\n        if (ret < 0)\n            return -1;\n        if (ret) {\n            JS_FreeValue(ctx, op1);\n            sp[-1] = val;\n            return 0;\n        }\n    }\n#endif\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1))\n        goto exception;\n    tag = JS_VALUE_GET_TAG(op1);\n    switch(tag) {\n    case JS_TAG_INT:\n        {\n            int64_t v64;\n            v64 = JS_VALUE_GET_INT(op1);\n            switch(op) {\n            case OP_inc:\n            case OP_dec:\n                v = 2 * (op - OP_dec) - 1;\n                v64 += v;\n                break;\n            case OP_plus:\n                break;\n            case OP_neg:\n                if (v64 == 0) {\n                    sp[-1] = __JS_NewFloat64(ctx, -0.0);\n                    return 0;\n                } else {\n                    v64 = -v64;\n                }\n                break;\n            default:\n                abort();\n            }\n            sp[-1] = JS_NewInt64(ctx, v64);\n        }\n        break;\n    case JS_TAG_BIG_INT:\n    handle_bigint:\n        if (ctx->rt->bigint_ops.unary_arith(ctx, sp - 1, op, op1))\n            goto exception;\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        if (ctx->rt->bigfloat_ops.unary_arith(ctx, sp - 1, op, op1))\n            goto exception;\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        if (ctx->rt->bigdecimal_ops.unary_arith(ctx, sp - 1, op, op1))\n            goto exception;\n        break;\n#endif\n    default:\n    handle_float64:\n        {\n            double d;\n            if (is_math_mode(ctx))\n                goto handle_bigint;\n            d = JS_VALUE_GET_FLOAT64(op1);\n            switch(op) {\n            case OP_inc:\n            case OP_dec:\n                v = 2 * (op - OP_dec) - 1;\n                d += v;\n                break;\n            case OP_plus:\n                break;\n            case OP_neg:\n                d = -d;\n                break;\n            default:\n                abort();\n            }\n            sp[-1] = __JS_NewFloat64(ctx, d);\n        }\n        break;\n    }\n    return 0;\n exception:\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic __exception int js_post_inc_slow(JSContext *ctx,\n                                        JSValue *sp, OPCodeEnum op)\n{\n    JSValue op1;\n\n    /* XXX: allow custom operators */\n    op1 = sp[-1];\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1)) {\n        sp[-1] = JS_UNDEFINED;\n        return -1;\n    }\n    sp[-1] = op1;\n    sp[0] = JS_DupValue(ctx, op1);\n    return js_unary_arith_slow(ctx, sp + 1, op - OP_post_dec + OP_dec);\n}\n\nstatic no_inline int js_not_slow(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1;\n\n    op1 = sp[-1];\n#ifdef CONFIG_BIGNUM\n    if (JS_IsObject(op1)) {\n        JSValue val;\n        int ret = js_call_unary_op_fallback(ctx, &val, op1, OP_not);\n        if (ret < 0)\n            return -1;\n        if (ret) {\n            JS_FreeValue(ctx, op1);\n            sp[-1] = val;\n            return 0;\n        }\n    }\n#endif\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1))\n        goto exception;\n    if (is_math_mode(ctx) || JS_VALUE_GET_TAG(op1) == JS_TAG_BIG_INT) {\n        if (ctx->rt->bigint_ops.unary_arith(ctx, sp - 1, OP_not, op1))\n            goto exception;\n    } else {\n        int32_t v1;\n        if (unlikely(JS_ToInt32Free(ctx, &v1, op1)))\n            goto exception;\n        sp[-1] = JS_NewInt32(ctx, ~v1);\n    }\n    return 0;\n exception:\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic int js_binary_arith_bigint(JSContext *ctx, OPCodeEnum op,\n                                  JSValue *pres, JSValue op1, JSValue op2)\n{\n    bf_t a_s, b_s, *r, *a, *b;\n    int ret;\n    JSValue res;\n\n    res = JS_NewBigInt(ctx);\n    if (JS_IsException(res))\n        goto fail;\n    a = JS_ToBigInt(ctx, &a_s, op1);\n    if (!a)\n        goto fail;\n    b = JS_ToBigInt(ctx, &b_s, op2);\n    if (!b) {\n        JS_FreeBigInt(ctx, a, &a_s);\n        goto fail;\n    }\n    r = JS_GetBigInt(res);\n    ret = 0;\n    switch(op) {\n    case OP_add:\n        ret = bf_add(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_sub:\n        ret = bf_sub(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_mul:\n        ret = bf_mul(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_div:\n        if (!is_math_mode(ctx)) {\n            bf_t rem_s, *rem = &rem_s;\n            bf_init(ctx->bf_ctx, rem);\n            ret = bf_divrem(r, rem, a, b, BF_PREC_INF, BF_RNDZ,\n                            BF_RNDZ);\n            bf_delete(rem);\n        } else {\n            goto math_mode_div_pow;\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case OP_math_mod:\n        /* Euclidian remainder */\n        ret = bf_rem(r, a, b, BF_PREC_INF, BF_RNDZ,\n                     BF_DIVREM_EUCLIDIAN) & BF_ST_INVALID_OP;\n        break;\n#endif\n    case OP_mod:\n        ret = bf_rem(r, a, b, BF_PREC_INF, BF_RNDZ,\n                     BF_RNDZ) & BF_ST_INVALID_OP;\n        break;\n    case OP_pow:\n        if (b->sign) {\n            if (!is_math_mode(ctx)) {\n                ret = BF_ST_INVALID_OP;\n            } else {\n            math_mode_div_pow:\n#ifdef CONFIG_BIGNUM\n                JS_FreeValue(ctx, res);\n                ret = js_call_binary_op_simple(ctx, &res, ctx->class_proto[JS_CLASS_BIG_INT], op1, op2, op);\n                if (ret != 0) {\n                    JS_FreeBigInt(ctx, a, &a_s);\n                    JS_FreeBigInt(ctx, b, &b_s);\n                    JS_FreeValue(ctx, op1);\n                    JS_FreeValue(ctx, op2);\n                    if (ret < 0) {\n                        return -1;\n                    } else {\n                        *pres = res;\n                        return 0;\n                    }\n                }\n                /* if no BigInt power operator defined, return a\n                   bigfloat */\n                res = JS_NewBigFloat(ctx);\n                if (JS_IsException(res)) {\n                    JS_FreeBigInt(ctx, a, &a_s);\n                    JS_FreeBigInt(ctx, b, &b_s);\n                    goto fail;\n                }\n                r = JS_GetBigFloat(res);\n                if (op == OP_div) {\n                    ret = bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags) & BF_ST_MEM_ERROR;\n                } else {\n                    ret = bf_pow(r, a, b, ctx->fp_env.prec,\n                                 ctx->fp_env.flags | BF_POW_JS_QUIRKS) & BF_ST_MEM_ERROR;\n                }\n                JS_FreeBigInt(ctx, a, &a_s);\n                JS_FreeBigInt(ctx, b, &b_s);\n                JS_FreeValue(ctx, op1);\n                JS_FreeValue(ctx, op2);\n                if (unlikely(ret)) {\n                    JS_FreeValue(ctx, res);\n                    throw_bf_exception(ctx, ret);\n                    return -1;\n                }\n                *pres = res;\n                return 0;\n#else\n                abort();\n#endif\n            }\n        } else {\n            ret = bf_pow(r, a, b, BF_PREC_INF, BF_RNDZ | BF_POW_JS_QUIRKS);\n        }\n        break;\n\n        /* logical operations */\n    case OP_shl:\n    case OP_sar:\n        {\n            slimb_t v2;\n#if LIMB_BITS == 32\n            bf_get_int32(&v2, b, 0);\n            if (v2 == INT32_MIN)\n                v2 = INT32_MIN + 1;\n#else\n            bf_get_int64(&v2, b, 0);\n            if (v2 == INT64_MIN)\n                v2 = INT64_MIN + 1;\n#endif\n            if (op == OP_sar)\n                v2 = -v2;\n            ret = bf_set(r, a);\n            ret |= bf_mul_2exp(r, v2, BF_PREC_INF, BF_RNDZ);\n            if (v2 < 0) {\n                ret |= bf_rint(r, BF_RNDD) & (BF_ST_OVERFLOW | BF_ST_MEM_ERROR);\n            }\n        }\n        break;\n    case OP_and:\n        ret = bf_logic_and(r, a, b);\n        break;\n    case OP_or:\n        ret = bf_logic_or(r, a, b);\n        break;\n    case OP_xor:\n        ret = bf_logic_xor(r, a, b);\n        break;\n    default:\n        abort();\n    }\n    JS_FreeBigInt(ctx, a, &a_s);\n    JS_FreeBigInt(ctx, b, &b_s);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    if (unlikely(ret)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    *pres = JS_CompactBigInt(ctx, res);\n    return 0;\n fail:\n    JS_FreeValue(ctx, res);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return -1;\n}\n\n#ifdef CONFIG_BIGNUM\nstatic int js_binary_arith_bigfloat(JSContext *ctx, OPCodeEnum op,\n                                    JSValue *pres, JSValue op1, JSValue op2)\n{\n    bf_t a_s, b_s, *r, *a, *b;\n    int ret;\n    JSValue res;\n\n    res = JS_NewBigFloat(ctx);\n    if (JS_IsException(res))\n        goto fail;\n    r = JS_GetBigFloat(res);\n    a = JS_ToBigFloat(ctx, &a_s, op1);\n    if (!a) {\n        JS_FreeValue(ctx, res);\n        goto fail;\n    }\n    b = JS_ToBigFloat(ctx, &b_s, op2);\n    if (!b) {\n        if (a == &a_s)\n            bf_delete(a);\n        JS_FreeValue(ctx, res);\n        goto fail;\n    }\n    bf_init(ctx->bf_ctx, r);\n    switch(op) {\n    case OP_add:\n        ret = bf_add(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case OP_sub:\n        ret = bf_sub(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case OP_mul:\n        ret = bf_mul(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case OP_div:\n        ret = bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);\n        break;\n    case OP_math_mod:\n        /* Euclidian remainder */\n        ret = bf_rem(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,\n                     BF_DIVREM_EUCLIDIAN);\n        break;\n    case OP_mod:\n        ret = bf_rem(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,\n                     BF_RNDZ);\n        break;\n    case OP_pow:\n        ret = bf_pow(r, a, b, ctx->fp_env.prec,\n                     ctx->fp_env.flags | BF_POW_JS_QUIRKS);\n        break;\n    default:\n        abort();\n    }\n    if (a == &a_s)\n        bf_delete(a);\n    if (b == &b_s)\n        bf_delete(b);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    if (unlikely(ret & BF_ST_MEM_ERROR)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    *pres = res;\n    return 0;\n fail:\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return -1;\n}\n\n/* b must be a positive integer */\nstatic int js_bfdec_pow(bfdec_t *r, const bfdec_t *a, const bfdec_t *b)\n{\n    bfdec_t b1;\n    int32_t b2;\n    int ret;\n\n    bfdec_init(b->ctx, &b1);\n    ret = bfdec_set(&b1, b);\n    if (ret) {\n        bfdec_delete(&b1);\n        return ret;\n    }\n    ret = bfdec_rint(&b1, BF_RNDZ);\n    if (ret) {\n        bfdec_delete(&b1);\n        return BF_ST_INVALID_OP; /* must be an integer */\n    }\n    ret = bfdec_get_int32(&b2, &b1);\n    bfdec_delete(&b1);\n    if (ret)\n        return ret; /* overflow */\n    if (b2 < 0)\n        return BF_ST_INVALID_OP; /* must be positive */\n    return bfdec_pow_ui(r, a, b2);\n}\n\nstatic int js_binary_arith_bigdecimal(JSContext *ctx, OPCodeEnum op,\n                                      JSValue *pres, JSValue op1, JSValue op2)\n{\n    bfdec_t *r, *a, *b;\n    int ret;\n    JSValue res;\n\n    res = JS_NewBigDecimal(ctx);\n    if (JS_IsException(res))\n        goto fail;\n    r = JS_GetBigDecimal(res);\n\n    a = JS_ToBigDecimal(ctx, op1);\n    if (!a)\n        goto fail;\n    b = JS_ToBigDecimal(ctx, op2);\n    if (!b)\n        goto fail;\n    switch(op) {\n    case OP_add:\n        ret = bfdec_add(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_sub:\n        ret = bfdec_sub(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_mul:\n        ret = bfdec_mul(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_div:\n        ret = bfdec_div(r, a, b, BF_PREC_INF, BF_RNDZ);\n        break;\n    case OP_math_mod:\n        /* Euclidian remainder */\n        ret = bfdec_rem(r, a, b, BF_PREC_INF, BF_RNDZ, BF_DIVREM_EUCLIDIAN);\n        break;\n    case OP_mod:\n        ret = bfdec_rem(r, a, b, BF_PREC_INF, BF_RNDZ, BF_RNDZ);\n        break;\n    case OP_pow:\n        ret = js_bfdec_pow(r, a, b);\n        break;\n    default:\n        abort();\n    }\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    if (unlikely(ret)) {\n        JS_FreeValue(ctx, res);\n        throw_bf_exception(ctx, ret);\n        return -1;\n    }\n    *pres = res;\n    return 0;\n fail:\n    JS_FreeValue(ctx, res);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return -1;\n}\n#endif /* CONFIG_BIGNUM */\n\nstatic no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *sp,\n                                                      OPCodeEnum op)\n{\n    JSValue op1, op2;\n    uint32_t tag1, tag2;\n    double d1, d2;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    /* fast path for float operations */\n    if (tag1 == JS_TAG_FLOAT64 && tag2 == JS_TAG_FLOAT64) {\n        d1 = JS_VALUE_GET_FLOAT64(op1);\n        d2 = JS_VALUE_GET_FLOAT64(op2);\n        goto handle_float64;\n    }\n\n#ifdef CONFIG_BIGNUM\n    /* try to call an overloaded operator */\n    if ((tag1 == JS_TAG_OBJECT &&\n         (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||\n        (tag2 == JS_TAG_OBJECT &&\n         (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {\n        JSValue res;\n        int ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op, TRUE, 0);\n        if (ret != 0) {\n            JS_FreeValue(ctx, op1);\n            JS_FreeValue(ctx, op2);\n            if (ret < 0) {\n                goto exception;\n            } else {\n                sp[-2] = res;\n                return 0;\n            }\n        }\n    }\n#endif\n\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToNumericFree(ctx, op2);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n\n    if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {\n        int32_t v1, v2;\n        int64_t v;\n        v1 = JS_VALUE_GET_INT(op1);\n        v2 = JS_VALUE_GET_INT(op2);\n        switch(op) {\n        case OP_sub:\n            v = (int64_t)v1 - (int64_t)v2;\n            break;\n        case OP_mul:\n            v = (int64_t)v1 * (int64_t)v2;\n            if (is_math_mode(ctx) &&\n                (v < -MAX_SAFE_INTEGER || v > MAX_SAFE_INTEGER))\n                goto handle_bigint;\n            if (v == 0 && (v1 | v2) < 0) {\n                sp[-2] = __JS_NewFloat64(ctx, -0.0);\n                return 0;\n            }\n            break;\n        case OP_div:\n            if (is_math_mode(ctx))\n                goto handle_bigint;\n            sp[-2] = __JS_NewFloat64(ctx, (double)v1 / (double)v2);\n            return 0;\n#ifdef CONFIG_BIGNUM\n        case OP_math_mod:\n            if (unlikely(v2 == 0)) {\n                throw_bf_exception(ctx, BF_ST_DIVIDE_ZERO);\n                goto exception;\n            }\n            v = (int64_t)v1 % (int64_t)v2;\n            if (v < 0) {\n                if (v2 < 0)\n                    v -= v2;\n                else\n                    v += v2;\n            }\n            break;\n#endif\n        case OP_mod:\n            if (v1 < 0 || v2 <= 0) {\n                sp[-2] = JS_NewFloat64(ctx, fmod(v1, v2));\n                return 0;\n            } else {\n                v = (int64_t)v1 % (int64_t)v2;\n            }\n            break;\n        case OP_pow:\n            if (!is_math_mode(ctx)) {\n                sp[-2] = JS_NewFloat64(ctx, js_pow(v1, v2));\n                return 0;\n            } else {\n                goto handle_bigint;\n            }\n            break;\n        default:\n            abort();\n        }\n        sp[-2] = JS_NewInt64(ctx, v);\n    } else\n#ifdef CONFIG_BIGNUM\n    if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {\n        if (ctx->rt->bigdecimal_ops.binary_arith(ctx, op, sp - 2, op1, op2))\n            goto exception;\n    } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {\n        if (ctx->rt->bigfloat_ops.binary_arith(ctx, op, sp - 2, op1, op2))\n            goto exception;\n    } else\n#endif\n    if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {\n    handle_bigint:\n        if (ctx->rt->bigint_ops.binary_arith(ctx, op, sp - 2, op1, op2))\n            goto exception;\n    } else {\n        double dr;\n        /* float64 result */\n        if (JS_ToFloat64Free(ctx, &d1, op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        if (JS_ToFloat64Free(ctx, &d2, op2))\n            goto exception;\n    handle_float64:\n        if (is_math_mode(ctx) && is_safe_integer(d1) && is_safe_integer(d2))\n            goto handle_bigint;\n        switch(op) {\n        case OP_sub:\n            dr = d1 - d2;\n            break;\n        case OP_mul:\n            dr = d1 * d2;\n            break;\n        case OP_div:\n            dr = d1 / d2;\n            break;\n        case OP_mod:\n            dr = fmod(d1, d2);\n            break;\n#ifdef CONFIG_BIGNUM\n        case OP_math_mod:\n            d2 = fabs(d2);\n            dr = fmod(d1, d2);\n            /* XXX: loss of accuracy if dr < 0 */\n            if (dr < 0)\n                dr += d2;\n            break;\n#endif\n        case OP_pow:\n            dr = js_pow(d1, d2);\n            break;\n        default:\n            abort();\n        }\n        sp[-2] = __JS_NewFloat64(ctx, dr);\n    }\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline __exception int js_add_slow(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    uint32_t tag1, tag2;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    /* fast path for float64 */\n    if (tag1 == JS_TAG_FLOAT64 && tag2 == JS_TAG_FLOAT64) {\n        double d1, d2;\n        d1 = JS_VALUE_GET_FLOAT64(op1);\n        d2 = JS_VALUE_GET_FLOAT64(op2);\n        sp[-2] = __JS_NewFloat64(ctx, d1 + d2);\n        return 0;\n    }\n\n    if (tag1 == JS_TAG_OBJECT || tag2 == JS_TAG_OBJECT) {\n#ifdef CONFIG_BIGNUM\n        /* try to call an overloaded operator */\n        if ((tag1 == JS_TAG_OBJECT &&\n             (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED &&\n              tag2 != JS_TAG_STRING)) ||\n            (tag2 == JS_TAG_OBJECT &&\n             (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED &&\n              tag1 != JS_TAG_STRING))) {\n            JSValue res;\n            int ret = js_call_binary_op_fallback(ctx, &res, op1, op2, OP_add,\n                                                 FALSE, HINT_NONE);\n            if (ret != 0) {\n                JS_FreeValue(ctx, op1);\n                JS_FreeValue(ctx, op2);\n                if (ret < 0) {\n                    goto exception;\n                } else {\n                    sp[-2] = res;\n                    return 0;\n                }\n            }\n        }\n#endif\n        op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);\n        if (JS_IsException(op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n\n        op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);\n        if (JS_IsException(op2)) {\n            JS_FreeValue(ctx, op1);\n            goto exception;\n        }\n        tag1 = JS_VALUE_GET_NORM_TAG(op1);\n        tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    }\n\n    if (tag1 == JS_TAG_STRING || tag2 == JS_TAG_STRING) {\n        sp[-2] = JS_ConcatString(ctx, op1, op2);\n        if (JS_IsException(sp[-2]))\n            goto exception;\n        return 0;\n    }\n\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToNumericFree(ctx, op2);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n\n    if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {\n        int32_t v1, v2;\n        int64_t v;\n        v1 = JS_VALUE_GET_INT(op1);\n        v2 = JS_VALUE_GET_INT(op2);\n        v = (int64_t)v1 + (int64_t)v2;\n        sp[-2] = JS_NewInt64(ctx, v);\n    } else\n#ifdef CONFIG_BIGNUM\n    if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {\n        if (ctx->rt->bigdecimal_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))\n            goto exception;\n    } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {\n        if (ctx->rt->bigfloat_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))\n            goto exception;\n    } else\n#endif\n    if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {\n    handle_bigint:\n        if (ctx->rt->bigint_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))\n            goto exception;\n    } else {\n        double d1, d2;\n        /* float64 result */\n        if (JS_ToFloat64Free(ctx, &d1, op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        if (JS_ToFloat64Free(ctx, &d2, op2))\n            goto exception;\n        if (is_math_mode(ctx) && is_safe_integer(d1) && is_safe_integer(d2))\n            goto handle_bigint;\n        sp[-2] = __JS_NewFloat64(ctx, d1 + d2);\n    }\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline __exception int js_binary_logic_slow(JSContext *ctx,\n                                                      JSValue *sp,\n                                                      OPCodeEnum op)\n{\n    JSValue op1, op2;\n    uint32_t tag1, tag2;\n    uint32_t v1, v2, r;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n\n#ifdef CONFIG_BIGNUM\n    /* try to call an overloaded operator */\n    if ((tag1 == JS_TAG_OBJECT &&\n         (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||\n        (tag2 == JS_TAG_OBJECT &&\n         (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {\n        JSValue res;\n        int ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op, TRUE, 0);\n        if (ret != 0) {\n            JS_FreeValue(ctx, op1);\n            JS_FreeValue(ctx, op2);\n            if (ret < 0) {\n                goto exception;\n            } else {\n                sp[-2] = res;\n                return 0;\n            }\n        }\n    }\n#endif\n\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToNumericFree(ctx, op2);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n\n    if (is_math_mode(ctx))\n        goto bigint_op;\n\n    tag1 = JS_VALUE_GET_TAG(op1);\n    tag2 = JS_VALUE_GET_TAG(op2);\n    if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {\n        if (tag1 != tag2) {\n            JS_FreeValue(ctx, op1);\n            JS_FreeValue(ctx, op2);\n            JS_ThrowTypeError(ctx, \"both operands must be bigint\");\n            goto exception;\n        } else {\n        bigint_op:\n            if (ctx->rt->bigint_ops.binary_arith(ctx, op, sp - 2, op1, op2))\n                goto exception;\n        }\n    } else {\n        if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v2, op2)))\n            goto exception;\n        switch(op) {\n        case OP_shl:\n            r = v1 << (v2 & 0x1f);\n            break;\n        case OP_sar:\n            r = (int)v1 >> (v2 & 0x1f);\n            break;\n        case OP_and:\n            r = v1 & v2;\n            break;\n        case OP_or:\n            r = v1 | v2;\n            break;\n        case OP_xor:\n            r = v1 ^ v2;\n            break;\n        default:\n            abort();\n        }\n        sp[-2] = JS_NewInt32(ctx, r);\n    }\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\n/* Note: also used for bigint */\nstatic int js_compare_bigfloat(JSContext *ctx, OPCodeEnum op,\n                               JSValue op1, JSValue op2)\n{\n    bf_t a_s, b_s, *a, *b;\n    int res;\n\n    a = JS_ToBigFloat(ctx, &a_s, op1);\n    if (!a) {\n        JS_FreeValue(ctx, op2);\n        return -1;\n    }\n    b = JS_ToBigFloat(ctx, &b_s, op2);\n    if (!b) {\n        if (a == &a_s)\n            bf_delete(a);\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    switch(op) {\n    case OP_lt:\n        res = bf_cmp_lt(a, b); /* if NaN return false */\n        break;\n    case OP_lte:\n        res = bf_cmp_le(a, b); /* if NaN return false */\n        break;\n    case OP_gt:\n        res = bf_cmp_lt(b, a); /* if NaN return false */\n        break;\n    case OP_gte:\n        res = bf_cmp_le(b, a); /* if NaN return false */\n        break;\n    case OP_eq:\n        res = bf_cmp_eq(a, b); /* if NaN return false */\n        break;\n    default:\n        abort();\n    }\n    if (a == &a_s)\n        bf_delete(a);\n    if (b == &b_s)\n        bf_delete(b);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return res;\n}\n\n#ifdef CONFIG_BIGNUM\nstatic int js_compare_bigdecimal(JSContext *ctx, OPCodeEnum op,\n                                 JSValue op1, JSValue op2)\n{\n    bfdec_t *a, *b;\n    int res;\n\n    /* Note: binary floats are converted to bigdecimal with\n       toString(). It is not mathematically correct but is consistent\n       with the BigDecimal() constructor behavior */\n    op1 = JS_ToBigDecimalFree(ctx, op1, TRUE);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        return -1;\n    }\n    op2 = JS_ToBigDecimalFree(ctx, op2, TRUE);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        return -1;\n    }\n    a = JS_ToBigDecimal(ctx, op1); /* cannot fail */\n    b = JS_ToBigDecimal(ctx, op2); /* cannot fail */\n\n    switch(op) {\n    case OP_lt:\n        res = bfdec_cmp_lt(a, b); /* if NaN return false */\n        break;\n    case OP_lte:\n        res = bfdec_cmp_le(a, b); /* if NaN return false */\n        break;\n    case OP_gt:\n        res = bfdec_cmp_lt(b, a); /* if NaN return false */\n        break;\n    case OP_gte:\n        res = bfdec_cmp_le(b, a); /* if NaN return false */\n        break;\n    case OP_eq:\n        res = bfdec_cmp_eq(a, b); /* if NaN return false */\n        break;\n    default:\n        abort();\n    }\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    return res;\n}\n#endif /* !CONFIG_BIGNUM */\n\nstatic no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,\n                                        OPCodeEnum op)\n{\n    JSValue op1, op2;\n    int res;\n    uint32_t tag1, tag2;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n#ifdef CONFIG_BIGNUM\n    /* try to call an overloaded operator */\n    if ((tag1 == JS_TAG_OBJECT &&\n         (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||\n        (tag2 == JS_TAG_OBJECT &&\n         (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {\n        JSValue ret;\n        res = js_call_binary_op_fallback(ctx, &ret, op1, op2, op,\n                                         FALSE, HINT_NUMBER);\n        if (res != 0) {\n            JS_FreeValue(ctx, op1);\n            JS_FreeValue(ctx, op2);\n            if (res < 0) {\n                goto exception;\n            } else {\n                sp[-2] = ret;\n                return 0;\n            }\n        }\n    }\n#endif\n    op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NUMBER);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NUMBER);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n\n    if (tag1 == JS_TAG_STRING && tag2 == JS_TAG_STRING) {\n        JSString *p1, *p2;\n        p1 = JS_VALUE_GET_STRING(op1);\n        p2 = JS_VALUE_GET_STRING(op2);\n        res = js_string_compare(ctx, p1, p2);\n        switch(op) {\n        case OP_lt:\n            res = (res < 0);\n            break;\n        case OP_lte:\n            res = (res <= 0);\n            break;\n        case OP_gt:\n            res = (res > 0);\n            break;\n        default:\n        case OP_gte:\n            res = (res >= 0);\n            break;\n        }\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n    } else if ((tag1 <= JS_TAG_NULL || tag1 == JS_TAG_FLOAT64) &&\n               (tag2 <= JS_TAG_NULL || tag2 == JS_TAG_FLOAT64)) {\n        /* fast path for float64/int */\n        goto float64_compare;\n    } else {\n        if (((tag1 == JS_TAG_BIG_INT && tag2 == JS_TAG_STRING) ||\n             (tag2 == JS_TAG_BIG_INT && tag1 == JS_TAG_STRING)) &&\n            !is_math_mode(ctx)) {\n            if (tag1 == JS_TAG_STRING) {\n                op1 = JS_StringToBigInt(ctx, op1);\n                if (JS_VALUE_GET_TAG(op1) != JS_TAG_BIG_INT)\n                    goto invalid_bigint_string;\n            }\n            if (tag2 == JS_TAG_STRING) {\n                op2 = JS_StringToBigInt(ctx, op2);\n                if (JS_VALUE_GET_TAG(op2) != JS_TAG_BIG_INT) {\n                invalid_bigint_string:\n                    JS_FreeValue(ctx, op1);\n                    JS_FreeValue(ctx, op2);\n                    res = FALSE;\n                    goto done;\n                }\n            }\n        } else {\n            op1 = JS_ToNumericFree(ctx, op1);\n            if (JS_IsException(op1)) {\n                JS_FreeValue(ctx, op2);\n                goto exception;\n            }\n            op2 = JS_ToNumericFree(ctx, op2);\n            if (JS_IsException(op2)) {\n                JS_FreeValue(ctx, op1);\n                goto exception;\n            }\n        }\n\n        tag1 = JS_VALUE_GET_NORM_TAG(op1);\n        tag2 = JS_VALUE_GET_NORM_TAG(op2);\n\n#ifdef CONFIG_BIGNUM\n        if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {\n            res = ctx->rt->bigdecimal_ops.compare(ctx, op, op1, op2);\n            if (res < 0)\n                goto exception;\n        } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {\n            res = ctx->rt->bigfloat_ops.compare(ctx, op, op1, op2);\n            if (res < 0)\n                goto exception;\n        } else\n#endif\n        if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {\n            res = ctx->rt->bigint_ops.compare(ctx, op, op1, op2);\n            if (res < 0)\n                goto exception;\n        } else {\n            double d1, d2;\n\n        float64_compare:\n            /* can use floating point comparison */\n            if (tag1 == JS_TAG_FLOAT64) {\n                d1 = JS_VALUE_GET_FLOAT64(op1);\n            } else {\n                d1 = JS_VALUE_GET_INT(op1);\n            }\n            if (tag2 == JS_TAG_FLOAT64) {\n                d2 = JS_VALUE_GET_FLOAT64(op2);\n            } else {\n                d2 = JS_VALUE_GET_INT(op2);\n            }\n            switch(op) {\n            case OP_lt:\n                res = (d1 < d2); /* if NaN return false */\n                break;\n            case OP_lte:\n                res = (d1 <= d2); /* if NaN return false */\n                break;\n            case OP_gt:\n                res = (d1 > d2); /* if NaN return false */\n                break;\n            default:\n            case OP_gte:\n                res = (d1 >= d2); /* if NaN return false */\n                break;\n            }\n        }\n    }\n done:\n    sp[-2] = JS_NewBool(ctx, res);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic BOOL tag_is_number(uint32_t tag)\n{\n    return (tag == JS_TAG_INT || tag == JS_TAG_BIG_INT ||\n            tag == JS_TAG_FLOAT64\n#ifdef CONFIG_BIGNUM\n            || tag == JS_TAG_BIG_FLOAT || tag == JS_TAG_BIG_DECIMAL\n#endif\n            );\n}\n\nstatic no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,\n                                            BOOL is_neq)\n{\n    JSValue op1, op2;\n#ifdef CONFIG_BIGNUM\n    JSValue ret;\n#endif\n    int res;\n    uint32_t tag1, tag2;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n redo:\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    if (tag_is_number(tag1) && tag_is_number(tag2)) {\n        if (tag1 == JS_TAG_INT && tag2 == JS_TAG_INT) {\n            res = JS_VALUE_GET_INT(op1) == JS_VALUE_GET_INT(op2);\n        } else if ((tag1 == JS_TAG_FLOAT64 &&\n                    (tag2 == JS_TAG_INT || tag2 == JS_TAG_FLOAT64)) ||\n                   (tag2 == JS_TAG_FLOAT64 &&\n                    (tag1 == JS_TAG_INT || tag1 == JS_TAG_FLOAT64))) {\n            double d1, d2;\n            if (tag1 == JS_TAG_FLOAT64) {\n                d1 = JS_VALUE_GET_FLOAT64(op1);\n            } else {\n                d1 = JS_VALUE_GET_INT(op1);\n            }\n            if (tag2 == JS_TAG_FLOAT64) {\n                d2 = JS_VALUE_GET_FLOAT64(op2);\n            } else {\n                d2 = JS_VALUE_GET_INT(op2);\n            }\n            res = (d1 == d2);\n        } else\n#ifdef CONFIG_BIGNUM\n        if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {\n            res = ctx->rt->bigdecimal_ops.compare(ctx, OP_eq, op1, op2);\n            if (res < 0)\n                goto exception;\n        } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {\n            res = ctx->rt->bigfloat_ops.compare(ctx, OP_eq, op1, op2);\n            if (res < 0)\n                goto exception;\n        } else\n#endif\n        {\n            res = ctx->rt->bigint_ops.compare(ctx, OP_eq, op1, op2);\n            if (res < 0)\n                goto exception;\n        }\n    } else if (tag1 == tag2) {\n#ifdef CONFIG_BIGNUM\n        if (tag1 == JS_TAG_OBJECT) {\n            /* try the fallback operator */\n            res = js_call_binary_op_fallback(ctx, &ret, op1, op2,\n                                             is_neq ? OP_neq : OP_eq,\n                                             FALSE, HINT_NONE);\n            if (res != 0) {\n                JS_FreeValue(ctx, op1);\n                JS_FreeValue(ctx, op2);\n                if (res < 0) {\n                    goto exception;\n                } else {\n                    sp[-2] = ret;\n                    return 0;\n                }\n            }\n        }\n#endif\n        res = js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);\n    } else if ((tag1 == JS_TAG_NULL && tag2 == JS_TAG_UNDEFINED) ||\n               (tag2 == JS_TAG_NULL && tag1 == JS_TAG_UNDEFINED)) {\n        res = TRUE;\n    } else if ((tag1 == JS_TAG_STRING && tag_is_number(tag2)) ||\n               (tag2 == JS_TAG_STRING && tag_is_number(tag1))) {\n\n        if ((tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) &&\n            !is_math_mode(ctx)) {\n            if (tag1 == JS_TAG_STRING) {\n                op1 = JS_StringToBigInt(ctx, op1);\n                if (JS_VALUE_GET_TAG(op1) != JS_TAG_BIG_INT)\n                    goto invalid_bigint_string;\n            }\n            if (tag2 == JS_TAG_STRING) {\n                op2 = JS_StringToBigInt(ctx, op2);\n                if (JS_VALUE_GET_TAG(op2) != JS_TAG_BIG_INT) {\n                invalid_bigint_string:\n                    JS_FreeValue(ctx, op1);\n                    JS_FreeValue(ctx, op2);\n                    res = FALSE;\n                    goto done;\n                }\n            }\n        } else {\n            op1 = JS_ToNumericFree(ctx, op1);\n            if (JS_IsException(op1)) {\n                JS_FreeValue(ctx, op2);\n                goto exception;\n            }\n            op2 = JS_ToNumericFree(ctx, op2);\n            if (JS_IsException(op2)) {\n                JS_FreeValue(ctx, op1);\n                goto exception;\n            }\n        }\n        res = js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);\n    } else if (tag1 == JS_TAG_BOOL) {\n        op1 = JS_NewInt32(ctx, JS_VALUE_GET_INT(op1));\n        goto redo;\n    } else if (tag2 == JS_TAG_BOOL) {\n        op2 = JS_NewInt32(ctx, JS_VALUE_GET_INT(op2));\n        goto redo;\n    } else if ((tag1 == JS_TAG_OBJECT &&\n                (tag_is_number(tag2) || tag2 == JS_TAG_STRING || tag2 == JS_TAG_SYMBOL)) ||\n               (tag2 == JS_TAG_OBJECT &&\n                (tag_is_number(tag1) || tag1 == JS_TAG_STRING || tag1 == JS_TAG_SYMBOL))) {\n#ifdef CONFIG_BIGNUM\n        /* try the fallback operator */\n        res = js_call_binary_op_fallback(ctx, &ret, op1, op2,\n                                         is_neq ? OP_neq : OP_eq,\n                                         FALSE, HINT_NONE);\n        if (res != 0) {\n            JS_FreeValue(ctx, op1);\n            JS_FreeValue(ctx, op2);\n            if (res < 0) {\n                goto exception;\n            } else {\n                sp[-2] = ret;\n                return 0;\n            }\n        }\n#endif\n        op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);\n        if (JS_IsException(op1)) {\n            JS_FreeValue(ctx, op2);\n            goto exception;\n        }\n        op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);\n        if (JS_IsException(op2)) {\n            JS_FreeValue(ctx, op1);\n            goto exception;\n        }\n        goto redo;\n    } else {\n        /* IsHTMLDDA object is equivalent to undefined for '==' and '!=' */\n        if ((JS_IsHTMLDDA(ctx, op1) &&\n             (tag2 == JS_TAG_NULL || tag2 == JS_TAG_UNDEFINED)) ||\n            (JS_IsHTMLDDA(ctx, op2) &&\n             (tag1 == JS_TAG_NULL || tag1 == JS_TAG_UNDEFINED))) {\n            res = TRUE;\n        } else {\n            res = FALSE;\n        }\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n    }\n done:\n    sp[-2] = JS_NewBool(ctx, res ^ is_neq);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic no_inline int js_shr_slow(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    uint32_t v1, v2, r;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    op1 = JS_ToNumericFree(ctx, op1);\n    if (JS_IsException(op1)) {\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    op2 = JS_ToNumericFree(ctx, op2);\n    if (JS_IsException(op2)) {\n        JS_FreeValue(ctx, op1);\n        goto exception;\n    }\n    /* XXX: could forbid >>> in bignum mode */\n    if (!is_math_mode(ctx) &&\n        (JS_VALUE_GET_TAG(op1) == JS_TAG_BIG_INT ||\n         JS_VALUE_GET_TAG(op2) == JS_TAG_BIG_INT)) {\n        JS_ThrowTypeError(ctx, \"bigint operands are forbidden for >>>\");\n        JS_FreeValue(ctx, op1);\n        JS_FreeValue(ctx, op2);\n        goto exception;\n    }\n    /* cannot give an exception */\n    JS_ToUint32Free(ctx, &v1, op1);\n    JS_ToUint32Free(ctx, &v2, op2);\n    r = v1 >> (v2 & 0x1f);\n    sp[-2] = JS_NewUint32(ctx, r);\n    return 0;\n exception:\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\n#ifdef CONFIG_BIGNUM\nstatic JSValue js_mul_pow10_to_float64(JSContext *ctx, const bf_t *a,\n                                       int64_t exponent)\n{\n    bf_t r_s, *r = &r_s;\n    double d;\n    int ret;\n\n    /* always convert to Float64 */\n    bf_init(ctx->bf_ctx, r);\n    ret = bf_mul_pow_radix(r, a, 10, exponent,\n                           53, bf_set_exp_bits(11) | BF_RNDN |\n                           BF_FLAG_SUBNORMAL);\n    bf_get_float64(r, &d, BF_RNDN);\n    bf_delete(r);\n    if (ret & BF_ST_MEM_ERROR)\n        return JS_ThrowOutOfMemory(ctx);\n    else\n        return __JS_NewFloat64(ctx, d);\n}\n\nstatic no_inline int js_mul_pow10(JSContext *ctx, JSValue *sp)\n{\n    bf_t a_s, *a, *r;\n    JSValue op1, op2, res;\n    int64_t e;\n    int ret;\n\n    res = JS_NewBigFloat(ctx);\n    if (JS_IsException(res))\n        return -1;\n    r = JS_GetBigFloat(res);\n    op1 = sp[-2];\n    op2 = sp[-1];\n    a = JS_ToBigFloat(ctx, &a_s, op1);\n    if (!a) {\n        JS_FreeValue(ctx, res);\n        return -1;\n    }\n    if (JS_IsBigInt(ctx, op2)) {\n        ret = JS_ToBigInt64(ctx, &e, op2);\n    } else {\n        ret = JS_ToInt64(ctx, &e, op2);\n    }\n    if (ret) {\n        if (a == &a_s)\n            bf_delete(a);\n        JS_FreeValue(ctx, res);\n        return -1;\n    }\n\n    bf_mul_pow_radix(r, a, 10, e, ctx->fp_env.prec, ctx->fp_env.flags);\n    if (a == &a_s)\n        bf_delete(a);\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    sp[-2] = res;\n    return 0;\n}\n#endif\n\n/* XXX: Should take JSValueConst arguments */\nstatic BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,\n                          JSStrictEqModeEnum eq_mode)\n{\n    BOOL res;\n    int tag1, tag2;\n    double d1, d2;\n\n    tag1 = JS_VALUE_GET_NORM_TAG(op1);\n    tag2 = JS_VALUE_GET_NORM_TAG(op2);\n    switch(tag1) {\n    case JS_TAG_BOOL:\n        if (tag1 != tag2) {\n            res = FALSE;\n        } else {\n            res = JS_VALUE_GET_INT(op1) == JS_VALUE_GET_INT(op2);\n            goto done_no_free;\n        }\n        break;\n    case JS_TAG_NULL:\n    case JS_TAG_UNDEFINED:\n        res = (tag1 == tag2);\n        break;\n    case JS_TAG_STRING:\n        {\n            JSString *p1, *p2;\n            if (tag1 != tag2) {\n                res = FALSE;\n            } else {\n                p1 = JS_VALUE_GET_STRING(op1);\n                p2 = JS_VALUE_GET_STRING(op2);\n                res = (js_string_compare(ctx, p1, p2) == 0);\n            }\n        }\n        break;\n    case JS_TAG_SYMBOL:\n        {\n            JSAtomStruct *p1, *p2;\n            if (tag1 != tag2) {\n                res = FALSE;\n            } else {\n                p1 = JS_VALUE_GET_PTR(op1);\n                p2 = JS_VALUE_GET_PTR(op2);\n                res = (p1 == p2);\n            }\n        }\n        break;\n    case JS_TAG_OBJECT:\n        if (tag1 != tag2)\n            res = FALSE;\n        else\n            res = JS_VALUE_GET_OBJ(op1) == JS_VALUE_GET_OBJ(op2);\n        break;\n    case JS_TAG_INT:\n        d1 = JS_VALUE_GET_INT(op1);\n        if (tag2 == JS_TAG_INT) {\n            d2 = JS_VALUE_GET_INT(op2);\n            goto number_test;\n        } else if (tag2 == JS_TAG_FLOAT64) {\n            d2 = JS_VALUE_GET_FLOAT64(op2);\n            goto number_test;\n        } else {\n            res = FALSE;\n        }\n        break;\n    case JS_TAG_FLOAT64:\n        d1 = JS_VALUE_GET_FLOAT64(op1);\n        if (tag2 == JS_TAG_FLOAT64) {\n            d2 = JS_VALUE_GET_FLOAT64(op2);\n        } else if (tag2 == JS_TAG_INT) {\n            d2 = JS_VALUE_GET_INT(op2);\n        } else {\n            res = FALSE;\n            break;\n        }\n    number_test:\n        if (unlikely(eq_mode >= JS_EQ_SAME_VALUE)) {\n            JSFloat64Union u1, u2;\n            /* NaN is not always normalized, so this test is necessary */\n            if (isnan(d1) || isnan(d2)) {\n                res = isnan(d1) == isnan(d2);\n            } else if (eq_mode == JS_EQ_SAME_VALUE_ZERO) {\n                res = (d1 == d2); /* +0 == -0 */\n            } else {\n                u1.d = d1;\n                u2.d = d2;\n                res = (u1.u64 == u2.u64); /* +0 != -0 */\n            }\n        } else {\n            res = (d1 == d2); /* if NaN return false and +0 == -0 */\n        }\n        goto done_no_free;\n    case JS_TAG_BIG_INT:\n        {\n            bf_t a_s, *a, b_s, *b;\n            if (tag1 != tag2) {\n                res = FALSE;\n                break;\n            }\n            a = JS_ToBigFloat(ctx, &a_s, op1); /* cannot fail */\n            b = JS_ToBigFloat(ctx, &b_s, op2); /* cannot fail */\n            res = bf_cmp_eq(a, b);\n            if (a == &a_s)\n                bf_delete(a);\n            if (b == &b_s)\n                bf_delete(b);\n        }\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        {\n            JSBigFloat *p1, *p2;\n            const bf_t *a, *b;\n            if (tag1 != tag2) {\n                res = FALSE;\n                break;\n            }\n            p1 = JS_VALUE_GET_PTR(op1);\n            p2 = JS_VALUE_GET_PTR(op2);\n            a = &p1->num;\n            b = &p2->num;\n            if (unlikely(eq_mode >= JS_EQ_SAME_VALUE)) {\n                if (eq_mode == JS_EQ_SAME_VALUE_ZERO &&\n                           a->expn == BF_EXP_ZERO && b->expn == BF_EXP_ZERO) {\n                    res = TRUE;\n                } else {\n                    res = (bf_cmp_full(a, b) == 0);\n                }\n            } else {\n                res = bf_cmp_eq(a, b);\n            }\n        }\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        {\n            JSBigDecimal *p1, *p2;\n            const bfdec_t *a, *b;\n            if (tag1 != tag2) {\n                res = FALSE;\n                break;\n            }\n            p1 = JS_VALUE_GET_PTR(op1);\n            p2 = JS_VALUE_GET_PTR(op2);\n            a = &p1->num;\n            b = &p2->num;\n            res = bfdec_cmp_eq(a, b);\n        }\n        break;\n#endif\n    default:\n        res = FALSE;\n        break;\n    }\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n done_no_free:\n    return res;\n}\n\nstatic BOOL js_strict_eq(JSContext *ctx, JSValueConst op1, JSValueConst op2)\n{\n    return js_strict_eq2(ctx,\n                         JS_DupValue(ctx, op1), JS_DupValue(ctx, op2),\n                         JS_EQ_STRICT);\n}\n\nBOOL JS_StrictEq(JSContext *ctx, JSValueConst op1, JSValueConst op2)\n{\n    return js_strict_eq(ctx, op1, op2);\n}\n\nstatic BOOL js_same_value(JSContext *ctx, JSValueConst op1, JSValueConst op2)\n{\n    return js_strict_eq2(ctx,\n                         JS_DupValue(ctx, op1), JS_DupValue(ctx, op2),\n                         JS_EQ_SAME_VALUE);\n}\n\nBOOL JS_SameValue(JSContext *ctx, JSValueConst op1, JSValueConst op2)\n{\n    return js_same_value(ctx, op1, op2);\n}\n\nstatic BOOL js_same_value_zero(JSContext *ctx, JSValueConst op1, JSValueConst op2)\n{\n    return js_strict_eq2(ctx,\n                         JS_DupValue(ctx, op1), JS_DupValue(ctx, op2),\n                         JS_EQ_SAME_VALUE_ZERO);\n}\n\nBOOL JS_SameValueZero(JSContext *ctx, JSValueConst op1, JSValueConst op2)\n{\n    return js_same_value_zero(ctx, op1, op2);\n}\n\nstatic no_inline int js_strict_eq_slow(JSContext *ctx, JSValue *sp,\n                                       BOOL is_neq)\n{\n    BOOL res;\n    res = js_strict_eq2(ctx, sp[-2], sp[-1], JS_EQ_STRICT);\n    sp[-2] = JS_NewBool(ctx, res ^ is_neq);\n    return 0;\n}\n\nstatic __exception int js_operator_in(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    JSAtom atom;\n    int ret;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n\n    if (JS_VALUE_GET_TAG(op2) != JS_TAG_OBJECT) {\n        JS_ThrowTypeError(ctx, \"invalid 'in' operand\");\n        return -1;\n    }\n    atom = JS_ValueToAtom(ctx, op1);\n    if (unlikely(atom == JS_ATOM_NULL))\n        return -1;\n    ret = JS_HasProperty(ctx, op2, atom);\n    JS_FreeAtom(ctx, atom);\n    if (ret < 0)\n        return -1;\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    sp[-2] = JS_NewBool(ctx, ret);\n    return 0;\n}\n\nstatic __exception int js_operator_private_in(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    int ret;\n\n    op1 = sp[-2]; /* object */\n    op2 = sp[-1]; /* field name or method function */\n\n    if (JS_VALUE_GET_TAG(op1) != JS_TAG_OBJECT) {\n        JS_ThrowTypeError(ctx, \"invalid 'in' operand\");\n        return -1;\n    }\n    if (JS_IsObject(op2)) {\n        /* method: use the brand */\n        ret = JS_CheckBrand(ctx, op1, op2);\n        if (ret < 0)\n            return -1;\n    } else {\n        JSAtom atom;\n        JSObject *p;\n        JSShapeProperty *prs;\n        JSProperty *pr;\n        /* field */\n        atom = JS_ValueToAtom(ctx, op2);\n        if (unlikely(atom == JS_ATOM_NULL))\n            return -1;\n        p = JS_VALUE_GET_OBJ(op1);\n        prs = find_own_property(&pr, p, atom);\n        JS_FreeAtom(ctx, atom);\n        ret = (prs != NULL);\n    }\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    sp[-2] = JS_NewBool(ctx, ret);\n    return 0;\n}\n\nstatic __exception int js_has_unscopable(JSContext *ctx, JSValueConst obj,\n                                         JSAtom atom)\n{\n    JSValue arr, val;\n    int ret;\n\n    arr = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_unscopables);\n    if (JS_IsException(arr))\n        return -1;\n    ret = 0;\n    if (JS_IsObject(arr)) {\n        val = JS_GetProperty(ctx, arr, atom);\n        ret = JS_ToBoolFree(ctx, val);\n    }\n    JS_FreeValue(ctx, arr);\n    return ret;\n}\n\nstatic __exception int js_operator_instanceof(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    BOOL ret;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    ret = JS_IsInstanceOf(ctx, op1, op2);\n    if (ret < 0)\n        return ret;\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    sp[-2] = JS_NewBool(ctx, ret);\n    return 0;\n}\n\nstatic __exception int js_operator_typeof(JSContext *ctx, JSValueConst op1)\n{\n    JSAtom atom;\n    uint32_t tag;\n\n    tag = JS_VALUE_GET_NORM_TAG(op1);\n    switch(tag) {\n    case JS_TAG_BIG_INT:\n        atom = JS_ATOM_bigint;\n        break;\n#ifdef CONFIG_BIGNUM\n    case JS_TAG_BIG_FLOAT:\n        atom = JS_ATOM_bigfloat;\n        break;\n    case JS_TAG_BIG_DECIMAL:\n        atom = JS_ATOM_bigdecimal;\n        break;\n#endif\n    case JS_TAG_INT:\n    case JS_TAG_FLOAT64:\n        atom = JS_ATOM_number;\n        break;\n    case JS_TAG_UNDEFINED:\n        atom = JS_ATOM_undefined;\n        break;\n    case JS_TAG_BOOL:\n        atom = JS_ATOM_boolean;\n        break;\n    case JS_TAG_STRING:\n        atom = JS_ATOM_string;\n        break;\n    case JS_TAG_OBJECT:\n        {\n            JSObject *p;\n            p = JS_VALUE_GET_OBJ(op1);\n            if (unlikely(p->is_HTMLDDA))\n                atom = JS_ATOM_undefined;\n            else if (JS_IsFunction(ctx, op1))\n                atom = JS_ATOM_function;\n            else\n                goto obj_type;\n        }\n        break;\n    case JS_TAG_NULL:\n    obj_type:\n        atom = JS_ATOM_object;\n        break;\n    case JS_TAG_SYMBOL:\n        atom = JS_ATOM_symbol;\n        break;\n    default:\n        atom = JS_ATOM_unknown;\n        break;\n    }\n    return atom;\n}\n\nstatic __exception int js_operator_delete(JSContext *ctx, JSValue *sp)\n{\n    JSValue op1, op2;\n    JSAtom atom;\n    int ret;\n\n    op1 = sp[-2];\n    op2 = sp[-1];\n    atom = JS_ValueToAtom(ctx, op2);\n    if (unlikely(atom == JS_ATOM_NULL))\n        return -1;\n    ret = JS_DeleteProperty(ctx, op1, atom, JS_PROP_THROW_STRICT);\n    JS_FreeAtom(ctx, atom);\n    if (unlikely(ret < 0))\n        return -1;\n    JS_FreeValue(ctx, op1);\n    JS_FreeValue(ctx, op2);\n    sp[-2] = JS_NewBool(ctx, ret);\n    return 0;\n}\n\nstatic JSValue js_throw_type_error(JSContext *ctx, JSValueConst this_val,\n                                   int argc, JSValueConst *argv)\n{\n    return JS_ThrowTypeError(ctx, \"invalid property access\");\n}\n\n/* XXX: not 100% compatible, but mozilla seems to use a similar\n   implementation to ensure that caller in non strict mode does not\n   throw (ES5 compatibility) */\nstatic JSValue js_function_proto_caller(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv)\n{\n    JSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);\n    if (!b || (b->js_mode & JS_MODE_STRICT) || !b->has_prototype) {\n        return js_throw_type_error(ctx, this_val, 0, NULL);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_function_proto_fileName(JSContext *ctx,\n                                          JSValueConst this_val)\n{\n    JSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);\n    if (b && b->has_debug) {\n        return JS_AtomToString(ctx, b->debug.filename);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_function_proto_lineNumber(JSContext *ctx,\n                                            JSValueConst this_val)\n{\n    JSFunctionBytecode *b = JS_GetFunctionBytecode(this_val);\n    if (b && b->has_debug) {\n        return JS_NewInt32(ctx, b->debug.line_num);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic int js_arguments_define_own_property(JSContext *ctx,\n                                            JSValueConst this_obj,\n                                            JSAtom prop, JSValueConst val,\n                                            JSValueConst getter, JSValueConst setter, int flags)\n{\n    JSObject *p;\n    uint32_t idx;\n    p = JS_VALUE_GET_OBJ(this_obj);\n    /* convert to normal array when redefining an existing numeric field */\n    if (p->fast_array && JS_AtomIsArrayIndex(ctx, &idx, prop) &&\n        idx < p->u.array.count) {\n        if (convert_fast_array_to_array(ctx, p))\n            return -1;\n    }\n    /* run the default define own property */\n    return JS_DefineProperty(ctx, this_obj, prop, val, getter, setter,\n                             flags | JS_PROP_NO_EXOTIC);\n}\n\nstatic const JSClassExoticMethods js_arguments_exotic_methods = {\n    .define_own_property = js_arguments_define_own_property,\n};\n\nstatic JSValue js_build_arguments(JSContext *ctx, int argc, JSValueConst *argv)\n{\n    JSValue val, *tab;\n    JSProperty *pr;\n    JSObject *p;\n    int i;\n\n    val = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],\n                                 JS_CLASS_ARGUMENTS);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_OBJ(val);\n\n    /* add the length field (cannot fail) */\n    pr = add_property(ctx, p, JS_ATOM_length,\n                      JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    pr->u.value = JS_NewInt32(ctx, argc);\n\n    /* initialize the fast array part */\n    tab = NULL;\n    if (argc > 0) {\n        tab = js_malloc(ctx, sizeof(tab[0]) * argc);\n        if (!tab) {\n            JS_FreeValue(ctx, val);\n            return JS_EXCEPTION;\n        }\n        for(i = 0; i < argc; i++) {\n            tab[i] = JS_DupValue(ctx, argv[i]);\n        }\n    }\n    p->u.array.u.values = tab;\n    p->u.array.count = argc;\n\n    JS_DefinePropertyValue(ctx, val, JS_ATOM_Symbol_iterator,\n                           JS_DupValue(ctx, ctx->array_proto_values),\n                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);\n    /* add callee property to throw a TypeError in strict mode */\n    JS_DefineProperty(ctx, val, JS_ATOM_callee, JS_UNDEFINED,\n                      ctx->throw_type_error, ctx->throw_type_error,\n                      JS_PROP_HAS_GET | JS_PROP_HAS_SET);\n    return val;\n}\n\n#define GLOBAL_VAR_OFFSET 0x40000000\n#define ARGUMENT_VAR_OFFSET 0x20000000\n\n/* legacy arguments object: add references to the function arguments */\nstatic JSValue js_build_mapped_arguments(JSContext *ctx, int argc,\n                                         JSValueConst *argv,\n                                         JSStackFrame *sf, int arg_count)\n{\n    JSValue val;\n    JSProperty *pr;\n    JSObject *p;\n    int i;\n\n    val = JS_NewObjectProtoClass(ctx, ctx->class_proto[JS_CLASS_OBJECT],\n                                 JS_CLASS_MAPPED_ARGUMENTS);\n    if (JS_IsException(val))\n        return val;\n    p = JS_VALUE_GET_OBJ(val);\n\n    /* add the length field (cannot fail) */\n    pr = add_property(ctx, p, JS_ATOM_length,\n                      JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    pr->u.value = JS_NewInt32(ctx, argc);\n\n    for(i = 0; i < arg_count; i++) {\n        JSVarRef *var_ref;\n        var_ref = get_var_ref(ctx, sf, i, TRUE);\n        if (!var_ref)\n            goto fail;\n        pr = add_property(ctx, p, __JS_AtomFromUInt32(i), JS_PROP_C_W_E | JS_PROP_VARREF);\n        if (!pr) {\n            free_var_ref(ctx->rt, var_ref);\n            goto fail;\n        }\n        pr->u.var_ref = var_ref;\n    }\n\n    /* the arguments not mapped to the arguments of the function can\n       be normal properties */\n    for(i = arg_count; i < argc; i++) {\n        if (JS_DefinePropertyValueUint32(ctx, val, i,\n                                         JS_DupValue(ctx, argv[i]),\n                                         JS_PROP_C_W_E) < 0)\n            goto fail;\n    }\n\n    JS_DefinePropertyValue(ctx, val, JS_ATOM_Symbol_iterator,\n                           JS_DupValue(ctx, ctx->array_proto_values),\n                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);\n    /* callee returns this function in non strict mode */\n    JS_DefinePropertyValue(ctx, val, JS_ATOM_callee,\n                           JS_DupValue(ctx, ctx->rt->current_stack_frame->cur_func),\n                           JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);\n    return val;\n fail:\n    JS_FreeValue(ctx, val);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_build_rest(JSContext *ctx, int first, int argc, JSValueConst *argv)\n{\n    JSValue val;\n    int i, ret;\n\n    val = JS_NewArray(ctx);\n    if (JS_IsException(val))\n        return val;\n    for (i = first; i < argc; i++) {\n        ret = JS_DefinePropertyValueUint32(ctx, val, i - first,\n                                           JS_DupValue(ctx, argv[i]),\n                                           JS_PROP_C_W_E);\n        if (ret < 0) {\n            JS_FreeValue(ctx, val);\n            return JS_EXCEPTION;\n        }\n    }\n    return val;\n}\n\nstatic JSValue build_for_in_iterator(JSContext *ctx, JSValue obj)\n{\n    JSObject *p, *p1;\n    JSPropertyEnum *tab_atom;\n    int i;\n    JSValue enum_obj;\n    JSForInIterator *it;\n    uint32_t tag, tab_atom_count;\n\n    tag = JS_VALUE_GET_TAG(obj);\n    if (tag != JS_TAG_OBJECT && tag != JS_TAG_NULL && tag != JS_TAG_UNDEFINED) {\n        obj = JS_ToObjectFree(ctx, obj);\n    }\n\n    it = js_malloc(ctx, sizeof(*it));\n    if (!it) {\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    enum_obj = JS_NewObjectProtoClass(ctx, JS_NULL, JS_CLASS_FOR_IN_ITERATOR);\n    if (JS_IsException(enum_obj)) {\n        js_free(ctx, it);\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    it->is_array = FALSE;\n    it->obj = obj;\n    it->idx = 0;\n    it->tab_atom = NULL;\n    it->atom_count = 0;\n    it->in_prototype_chain = FALSE;\n    p1 = JS_VALUE_GET_OBJ(enum_obj);\n    p1->u.for_in_iterator = it;\n\n    if (tag == JS_TAG_NULL || tag == JS_TAG_UNDEFINED)\n        return enum_obj;\n\n    p = JS_VALUE_GET_OBJ(obj);\n    if (p->fast_array) {\n        JSShape *sh;\n        JSShapeProperty *prs;\n        /* check that there are no enumerable normal fields */\n        sh = p->shape;\n        for(i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {\n            if (prs->flags & JS_PROP_ENUMERABLE)\n                goto normal_case;\n        }\n        /* for fast arrays, we only store the number of elements */\n        it->is_array = TRUE;\n        it->atom_count = p->u.array.count;\n    } else {\n    normal_case:\n        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,\n                                           JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {\n            JS_FreeValue(ctx, enum_obj);\n            return JS_EXCEPTION;\n        }\n        it->tab_atom = tab_atom;\n        it->atom_count = tab_atom_count;\n    }\n    return enum_obj;\n}\n\n/* obj -> enum_obj */\nstatic __exception int js_for_in_start(JSContext *ctx, JSValue *sp)\n{\n    sp[-1] = build_for_in_iterator(ctx, sp[-1]);\n    if (JS_IsException(sp[-1]))\n        return -1;\n    return 0;\n}\n\n/* return -1 if exception, 0 if slow case, 1 if the enumeration is finished */\nstatic __exception int js_for_in_prepare_prototype_chain_enum(JSContext *ctx,\n                                                              JSValueConst enum_obj)\n{\n    JSObject *p;\n    JSForInIterator *it;\n    JSPropertyEnum *tab_atom;\n    uint32_t tab_atom_count, i;\n    JSValue obj1;\n\n    p = JS_VALUE_GET_OBJ(enum_obj);\n    it = p->u.for_in_iterator;\n\n    /* check if there are enumerable properties in the prototype chain (fast path) */\n    obj1 = JS_DupValue(ctx, it->obj);\n    for(;;) {\n        obj1 = JS_GetPrototypeFree(ctx, obj1);\n        if (JS_IsNull(obj1))\n            break;\n        if (JS_IsException(obj1))\n            goto fail;\n        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,\n                                           JS_VALUE_GET_OBJ(obj1),\n                                           JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY)) {\n            JS_FreeValue(ctx, obj1);\n            goto fail;\n        }\n        js_free_prop_enum(ctx, tab_atom, tab_atom_count);\n        if (tab_atom_count != 0) {\n            JS_FreeValue(ctx, obj1);\n            goto slow_path;\n        }\n        /* must check for timeout to avoid infinite loop */\n        if (js_poll_interrupts(ctx)) {\n            JS_FreeValue(ctx, obj1);\n            goto fail;\n        }\n    }\n    JS_FreeValue(ctx, obj1);\n    return 1;\n\n slow_path:\n    /* add the visited properties, even if they are not enumerable */\n    if (it->is_array) {\n        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,\n                                           JS_VALUE_GET_OBJ(it->obj),\n                                           JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {\n            goto fail;\n        }\n        it->is_array = FALSE;\n        it->tab_atom = tab_atom;\n        it->atom_count = tab_atom_count;\n    }\n\n    for(i = 0; i < it->atom_count; i++) {\n        if (JS_DefinePropertyValue(ctx, enum_obj, it->tab_atom[i].atom, JS_NULL, JS_PROP_ENUMERABLE) < 0)\n            goto fail;\n    }\n    return 0;\n fail:\n    return -1;\n}\n\n/* enum_obj -> enum_obj value done */\nstatic __exception int js_for_in_next(JSContext *ctx, JSValue *sp)\n{\n    JSValueConst enum_obj;\n    JSObject *p;\n    JSAtom prop;\n    JSForInIterator *it;\n    JSPropertyEnum *tab_atom;\n    uint32_t tab_atom_count;\n    int ret;\n\n    enum_obj = sp[-1];\n    /* fail safe */\n    if (JS_VALUE_GET_TAG(enum_obj) != JS_TAG_OBJECT)\n        goto done;\n    p = JS_VALUE_GET_OBJ(enum_obj);\n    if (p->class_id != JS_CLASS_FOR_IN_ITERATOR)\n        goto done;\n    it = p->u.for_in_iterator;\n\n    for(;;) {\n        if (it->idx >= it->atom_count) {\n            if (JS_IsNull(it->obj) || JS_IsUndefined(it->obj))\n                goto done; /* not an object */\n            /* no more property in the current object: look in the prototype */\n            if (!it->in_prototype_chain) {\n                ret = js_for_in_prepare_prototype_chain_enum(ctx, enum_obj);\n                if (ret < 0)\n                    return -1;\n                if (ret)\n                    goto done;\n                it->in_prototype_chain = TRUE;\n            }\n            it->obj = JS_GetPrototypeFree(ctx, it->obj);\n            if (JS_IsException(it->obj))\n                return -1;\n            if (JS_IsNull(it->obj))\n                goto done; /* no more prototype */\n\n            /* must check for timeout to avoid infinite loop */\n            if (js_poll_interrupts(ctx))\n                return -1;\n\n            if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,\n                                               JS_VALUE_GET_OBJ(it->obj),\n                                               JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {\n                return -1;\n            }\n            js_free_prop_enum(ctx, it->tab_atom, it->atom_count);\n            it->tab_atom = tab_atom;\n            it->atom_count = tab_atom_count;\n            it->idx = 0;\n        } else {\n            if (it->is_array) {\n                prop = __JS_AtomFromUInt32(it->idx);\n                it->idx++;\n            } else {\n                BOOL is_enumerable;\n                prop = it->tab_atom[it->idx].atom;\n                is_enumerable = it->tab_atom[it->idx].is_enumerable;\n                it->idx++;\n                if (it->in_prototype_chain) {\n                    /* slow case: we are in the prototype chain */\n                    ret = JS_GetOwnPropertyInternal(ctx, NULL, JS_VALUE_GET_OBJ(enum_obj), prop);\n                    if (ret < 0)\n                        return ret;\n                    if (ret)\n                        continue; /* already visited */\n                    /* add to the visited property list */\n                    if (JS_DefinePropertyValue(ctx, enum_obj, prop, JS_NULL,\n                                               JS_PROP_ENUMERABLE) < 0)\n                        return -1;\n                }\n                if (!is_enumerable)\n                    continue;\n            }\n            /* check if the property was deleted */\n            ret = JS_GetOwnPropertyInternal(ctx, NULL, JS_VALUE_GET_OBJ(it->obj), prop);\n            if (ret < 0)\n                return ret;\n            if (ret)\n                break;\n        }\n    }\n    /* return the property */\n    sp[0] = JS_AtomToValue(ctx, prop);\n    sp[1] = JS_FALSE;\n    return 0;\n done:\n    /* return the end */\n    sp[0] = JS_UNDEFINED;\n    sp[1] = JS_TRUE;\n    return 0;\n}\n\nstatic JSValue JS_GetIterator2(JSContext *ctx, JSValueConst obj,\n                               JSValueConst method)\n{\n    JSValue enum_obj;\n\n    enum_obj = JS_Call(ctx, method, obj, 0, NULL);\n    if (JS_IsException(enum_obj))\n        return enum_obj;\n    if (!JS_IsObject(enum_obj)) {\n        JS_FreeValue(ctx, enum_obj);\n        return JS_ThrowTypeErrorNotAnObject(ctx);\n    }\n    return enum_obj;\n}\n\nstatic JSValue JS_GetIterator(JSContext *ctx, JSValueConst obj, BOOL is_async)\n{\n    JSValue method, ret, sync_iter;\n\n    if (is_async) {\n        method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_asyncIterator);\n        if (JS_IsException(method))\n            return method;\n        if (JS_IsUndefined(method) || JS_IsNull(method)) {\n            method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_iterator);\n            if (JS_IsException(method))\n                return method;\n            sync_iter = JS_GetIterator2(ctx, obj, method);\n            JS_FreeValue(ctx, method);\n            if (JS_IsException(sync_iter))\n                return sync_iter;\n            ret = JS_CreateAsyncFromSyncIterator(ctx, sync_iter);\n            JS_FreeValue(ctx, sync_iter);\n            return ret;\n        }\n    } else {\n        method = JS_GetProperty(ctx, obj, JS_ATOM_Symbol_iterator);\n        if (JS_IsException(method))\n            return method;\n    }\n    if (!JS_IsFunction(ctx, method)) {\n        JS_FreeValue(ctx, method);\n        return JS_ThrowTypeError(ctx, \"value is not iterable\");\n    }\n    ret = JS_GetIterator2(ctx, obj, method);\n    JS_FreeValue(ctx, method);\n    return ret;\n}\n\n/* return *pdone = 2 if the iterator object is not parsed */\nstatic JSValue JS_IteratorNext2(JSContext *ctx, JSValueConst enum_obj,\n                                JSValueConst method,\n                                int argc, JSValueConst *argv, int *pdone)\n{\n    JSValue obj;\n\n    /* fast path for the built-in iterators (avoid creating the\n       intermediate result object) */\n    if (JS_IsObject(method)) {\n        JSObject *p = JS_VALUE_GET_OBJ(method);\n        if (p->class_id == JS_CLASS_C_FUNCTION &&\n            p->u.cfunc.cproto == JS_CFUNC_iterator_next) {\n            JSCFunctionType func;\n            JSValueConst args[1];\n\n            /* in case the function expects one argument */\n            if (argc == 0) {\n                args[0] = JS_UNDEFINED;\n                argv = args;\n            }\n            func = p->u.cfunc.c_function;\n            return func.iterator_next(ctx, enum_obj, argc, argv,\n                                      pdone, p->u.cfunc.magic);\n        }\n    }\n    obj = JS_Call(ctx, method, enum_obj, argc, argv);\n    if (JS_IsException(obj))\n        goto fail;\n    if (!JS_IsObject(obj)) {\n        JS_FreeValue(ctx, obj);\n        JS_ThrowTypeError(ctx, \"iterator must return an object\");\n        goto fail;\n    }\n    *pdone = 2;\n    return obj;\n fail:\n    *pdone = FALSE;\n    return JS_EXCEPTION;\n}\n\nstatic JSValue JS_IteratorNext(JSContext *ctx, JSValueConst enum_obj,\n                               JSValueConst method,\n                               int argc, JSValueConst *argv, BOOL *pdone)\n{\n    JSValue obj, value, done_val;\n    int done;\n\n    obj = JS_IteratorNext2(ctx, enum_obj, method, argc, argv, &done);\n    if (JS_IsException(obj))\n        goto fail;\n    if (done != 2) {\n        *pdone = done;\n        return obj;\n    } else {\n        done_val = JS_GetProperty(ctx, obj, JS_ATOM_done);\n        if (JS_IsException(done_val))\n            goto fail;\n        *pdone = JS_ToBoolFree(ctx, done_val);\n        value = JS_UNDEFINED;\n        if (!*pdone) {\n            value = JS_GetProperty(ctx, obj, JS_ATOM_value);\n        }\n        JS_FreeValue(ctx, obj);\n        return value;\n    }\n fail:\n    JS_FreeValue(ctx, obj);\n    *pdone = FALSE;\n    return JS_EXCEPTION;\n}\n\n/* return < 0 in case of exception */\nstatic int JS_IteratorClose(JSContext *ctx, JSValueConst enum_obj,\n                            BOOL is_exception_pending)\n{\n    JSValue method, ret, ex_obj;\n    int res;\n\n    if (is_exception_pending) {\n        ex_obj = ctx->rt->current_exception;\n        ctx->rt->current_exception = JS_UNINITIALIZED;\n        res = -1;\n    } else {\n        ex_obj = JS_UNDEFINED;\n        res = 0;\n    }\n    method = JS_GetProperty(ctx, enum_obj, JS_ATOM_return);\n    if (JS_IsException(method)) {\n        res = -1;\n        goto done;\n    }\n    if (JS_IsUndefined(method) || JS_IsNull(method)) {\n        goto done;\n    }\n    ret = JS_CallFree(ctx, method, enum_obj, 0, NULL);\n    if (!is_exception_pending) {\n        if (JS_IsException(ret)) {\n            res = -1;\n        } else if (!JS_IsObject(ret)) {\n            JS_ThrowTypeErrorNotAnObject(ctx);\n            res = -1;\n        }\n    }\n    JS_FreeValue(ctx, ret);\n done:\n    if (is_exception_pending) {\n        JS_Throw(ctx, ex_obj);\n    }\n    return res;\n}\n\n/* obj -> enum_rec (3 slots) */\nstatic __exception int js_for_of_start(JSContext *ctx, JSValue *sp,\n                                       BOOL is_async)\n{\n    JSValue op1, obj, method;\n    op1 = sp[-1];\n    obj = JS_GetIterator(ctx, op1, is_async);\n    if (JS_IsException(obj))\n        return -1;\n    JS_FreeValue(ctx, op1);\n    sp[-1] = obj;\n    method = JS_GetProperty(ctx, obj, JS_ATOM_next);\n    if (JS_IsException(method))\n        return -1;\n    sp[0] = method;\n    return 0;\n}\n\n/* enum_rec [objs] -> enum_rec [objs] value done. There are 'offset'\n   objs. If 'done' is true or in case of exception, 'enum_rec' is set\n   to undefined. If 'done' is true, 'value' is always set to\n   undefined. */\nstatic __exception int js_for_of_next(JSContext *ctx, JSValue *sp, int offset)\n{\n    JSValue value = JS_UNDEFINED;\n    int done = 1;\n\n    if (likely(!JS_IsUndefined(sp[offset]))) {\n        value = JS_IteratorNext(ctx, sp[offset], sp[offset + 1], 0, NULL, &done);\n        if (JS_IsException(value))\n            done = -1;\n        if (done) {\n            /* value is JS_UNDEFINED or JS_EXCEPTION */\n            /* replace the iteration object with undefined */\n            JS_FreeValue(ctx, sp[offset]);\n            sp[offset] = JS_UNDEFINED;\n            if (done < 0) {\n                return -1;\n            } else {\n                JS_FreeValue(ctx, value);\n                value = JS_UNDEFINED;\n            }\n        }\n    }\n    sp[0] = value;\n    sp[1] = JS_NewBool(ctx, done);\n    return 0;\n}\n\nstatic JSValue JS_IteratorGetCompleteValue(JSContext *ctx, JSValueConst obj,\n                                           BOOL *pdone)\n{\n    JSValue done_val, value;\n    BOOL done;\n    done_val = JS_GetProperty(ctx, obj, JS_ATOM_done);\n    if (JS_IsException(done_val))\n        goto fail;\n    done = JS_ToBoolFree(ctx, done_val);\n    value = JS_GetProperty(ctx, obj, JS_ATOM_value);\n    if (JS_IsException(value))\n        goto fail;\n    *pdone = done;\n    return value;\n fail:\n    *pdone = FALSE;\n    return JS_EXCEPTION;\n}\n\nstatic __exception int js_iterator_get_value_done(JSContext *ctx, JSValue *sp)\n{\n    JSValue obj, value;\n    BOOL done;\n    obj = sp[-1];\n    if (!JS_IsObject(obj)) {\n        JS_ThrowTypeError(ctx, \"iterator must return an object\");\n        return -1;\n    }\n    value = JS_IteratorGetCompleteValue(ctx, obj, &done);\n    if (JS_IsException(value))\n        return -1;\n    JS_FreeValue(ctx, obj);\n    sp[-1] = value;\n    sp[0] = JS_NewBool(ctx, done);\n    return 0;\n}\n\nstatic JSValue js_create_iterator_result(JSContext *ctx,\n                                         JSValue val,\n                                         BOOL done)\n{\n    JSValue obj;\n    obj = JS_NewObject(ctx);\n    if (JS_IsException(obj)) {\n        JS_FreeValue(ctx, val);\n        return obj;\n    }\n    if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_value,\n                               val, JS_PROP_C_W_E) < 0) {\n        goto fail;\n    }\n    if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_done,\n                               JS_NewBool(ctx, done), JS_PROP_C_W_E) < 0) {\n    fail:\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    return obj;\n}\n\nstatic JSValue js_array_iterator_next(JSContext *ctx, JSValueConst this_val,\n                                      int argc, JSValueConst *argv,\n                                      BOOL *pdone, int magic);\n\nstatic JSValue js_create_array_iterator(JSContext *ctx, JSValueConst this_val,\n                                        int argc, JSValueConst *argv, int magic);\n\nstatic BOOL js_is_fast_array(JSContext *ctx, JSValueConst obj)\n{\n    /* Try and handle fast arrays explicitly */\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(obj);\n        if (p->class_id == JS_CLASS_ARRAY && p->fast_array) {\n            return TRUE;\n        }\n    }\n    return FALSE;\n}\n\n/* Access an Array's internal JSValue array if available */\nstatic BOOL js_get_fast_array(JSContext *ctx, JSValueConst obj,\n                              JSValue **arrpp, uint32_t *countp)\n{\n    /* Try and handle fast arrays explicitly */\n    if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {\n        JSObject *p = JS_VALUE_GET_OBJ(obj);\n        if (p->class_id == JS_CLASS_ARRAY && p->fast_array) {\n            *countp = p->u.array.count;\n            *arrpp = p->u.array.u.values;\n            return TRUE;\n        }\n    }\n    return FALSE;\n}\n\nstatic __exception int js_append_enumerate(JSContext *ctx, JSValue *sp)\n{\n    JSValue iterator, enumobj, method, value;\n    int is_array_iterator;\n    JSValue *arrp;\n    uint32_t i, count32, pos;\n\n    if (JS_VALUE_GET_TAG(sp[-2]) != JS_TAG_INT) {\n        JS_ThrowInternalError(ctx, \"invalid index for append\");\n        return -1;\n    }\n\n    pos = JS_VALUE_GET_INT(sp[-2]);\n\n    /* XXX: further optimisations:\n       - use ctx->array_proto_values?\n       - check if array_iterator_prototype next method is built-in and\n         avoid constructing actual iterator object?\n       - build this into js_for_of_start and use in all `for (x of o)` loops\n     */\n    iterator = JS_GetProperty(ctx, sp[-1], JS_ATOM_Symbol_iterator);\n    if (JS_IsException(iterator))\n        return -1;\n    is_array_iterator = JS_IsCFunction(ctx, iterator,\n                                       (JSCFunction *)js_create_array_iterator,\n                                       JS_ITERATOR_KIND_VALUE);\n    JS_FreeValue(ctx, iterator);\n\n    enumobj = JS_GetIterator(ctx, sp[-1], FALSE);\n    if (JS_IsException(enumobj))\n        return -1;\n    method = JS_GetProperty(ctx, enumobj, JS_ATOM_next);\n    if (JS_IsException(method)) {\n        JS_FreeValue(ctx, enumobj);\n        return -1;\n    }\n    if (is_array_iterator\n    &&  JS_IsCFunction(ctx, method, (JSCFunction *)js_array_iterator_next, 0)\n    &&  js_get_fast_array(ctx, sp[-1], &arrp, &count32)) {\n        uint32_t len;\n        if (js_get_length32(ctx, &len, sp[-1]))\n            goto exception;\n        /* if len > count32, the elements >= count32 might be read in\n           the prototypes and might have side effects */\n        if (len != count32)\n            goto general_case;\n        /* Handle fast arrays explicitly */\n        for (i = 0; i < count32; i++) {\n            if (JS_DefinePropertyValueUint32(ctx, sp[-3], pos++,\n                                             JS_DupValue(ctx, arrp[i]), JS_PROP_C_W_E) < 0)\n                goto exception;\n        }\n    } else {\n    general_case:\n        for (;;) {\n            BOOL done;\n            value = JS_IteratorNext(ctx, enumobj, method, 0, NULL, &done);\n            if (JS_IsException(value))\n                goto exception;\n            if (done) {\n                /* value is JS_UNDEFINED */\n                break;\n            }\n            if (JS_DefinePropertyValueUint32(ctx, sp[-3], pos++, value, JS_PROP_C_W_E) < 0)\n                goto exception;\n        }\n    }\n    /* Note: could raise an error if too many elements */\n    sp[-2] = JS_NewInt32(ctx, pos);\n    JS_FreeValue(ctx, enumobj);\n    JS_FreeValue(ctx, method);\n    return 0;\n\nexception:\n    JS_IteratorClose(ctx, enumobj, TRUE);\n    JS_FreeValue(ctx, enumobj);\n    JS_FreeValue(ctx, method);\n    return -1;\n}\n\nstatic __exception int JS_CopyDataProperties(JSContext *ctx,\n                                             JSValueConst target,\n                                             JSValueConst source,\n                                             JSValueConst excluded,\n                                             BOOL setprop)\n{\n    JSPropertyEnum *tab_atom;\n    JSValue val;\n    uint32_t i, tab_atom_count;\n    JSObject *p;\n    JSObject *pexcl = NULL;\n    int ret, gpn_flags;\n    JSPropertyDescriptor desc;\n    BOOL is_enumerable;\n\n    if (JS_VALUE_GET_TAG(source) != JS_TAG_OBJECT)\n        return 0;\n\n    if (JS_VALUE_GET_TAG(excluded) == JS_TAG_OBJECT)\n        pexcl = JS_VALUE_GET_OBJ(excluded);\n\n    p = JS_VALUE_GET_OBJ(source);\n\n    gpn_flags = JS_GPN_STRING_MASK | JS_GPN_SYMBOL_MASK | JS_GPN_ENUM_ONLY;\n    if (p->is_exotic) {\n        const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;\n        /* cannot use JS_GPN_ENUM_ONLY with e.g. proxies because it\n           introduces a visible change */\n        if (em && em->get_own_property_names) {\n            gpn_flags &= ~JS_GPN_ENUM_ONLY;\n        }\n    }\n    if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,\n                                       gpn_flags))\n        return -1;\n\n    for (i = 0; i < tab_atom_count; i++) {\n        if (pexcl) {\n            ret = JS_GetOwnPropertyInternal(ctx, NULL, pexcl, tab_atom[i].atom);\n            if (ret) {\n                if (ret < 0)\n                    goto exception;\n                continue;\n            }\n        }\n        if (!(gpn_flags & JS_GPN_ENUM_ONLY)) {\n            /* test if the property is enumerable */\n            ret = JS_GetOwnPropertyInternal(ctx, &desc, p, tab_atom[i].atom);\n            if (ret < 0)\n                goto exception;\n            if (!ret)\n                continue;\n            is_enumerable = (desc.flags & JS_PROP_ENUMERABLE) != 0;\n            js_free_desc(ctx, &desc);\n            if (!is_enumerable)\n                continue;\n        }\n        val = JS_GetProperty(ctx, source, tab_atom[i].atom);\n        if (JS_IsException(val))\n            goto exception;\n        if (setprop)\n            ret = JS_SetProperty(ctx, target, tab_atom[i].atom, val);\n        else\n            ret = JS_DefinePropertyValue(ctx, target, tab_atom[i].atom, val,\n                                         JS_PROP_C_W_E);\n        if (ret < 0)\n            goto exception;\n    }\n    js_free_prop_enum(ctx, tab_atom, tab_atom_count);\n    return 0;\n exception:\n    js_free_prop_enum(ctx, tab_atom, tab_atom_count);\n    return -1;\n}\n\n/* only valid inside C functions */\nstatic JSValueConst JS_GetActiveFunction(JSContext *ctx)\n{\n    return ctx->rt->current_stack_frame->cur_func;\n}\n\nstatic JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf,\n                             int var_idx, BOOL is_arg)\n{\n    JSVarRef *var_ref;\n    struct list_head *el;\n\n    list_for_each(el, &sf->var_ref_list) {\n        var_ref = list_entry(el, JSVarRef, var_ref_link);\n        if (var_ref->var_idx == var_idx && var_ref->is_arg == is_arg) {\n            var_ref->header.ref_count++;\n            return var_ref;\n        }\n    }\n    /* create a new one */\n    var_ref = js_malloc(ctx, sizeof(JSVarRef));\n    if (!var_ref)\n        return NULL;\n    var_ref->header.ref_count = 1;\n    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);\n    var_ref->is_detached = FALSE;\n    var_ref->is_arg = is_arg;\n    var_ref->var_idx = var_idx;\n    list_add_tail(&var_ref->var_ref_link, &sf->var_ref_list);\n    if (sf->js_mode & JS_MODE_ASYNC) {\n        /* The stack frame is detached and may be destroyed at any\n           time so its reference count must be increased. Calling\n           close_var_refs() when destroying the stack frame is not\n           possible because it would change the graph between the GC\n           objects. Another solution could be to temporarily detach\n           the JSVarRef of async functions during the GC. It would\n           have the advantage of allowing the release of unused stack\n           frames in a cycle. */\n        var_ref->async_func = container_of(sf, JSAsyncFunctionState, frame);\n        var_ref->async_func->header.ref_count++;\n    } else {\n        var_ref->async_func = NULL;\n    }\n    if (is_arg)\n        var_ref->pvalue = &sf->arg_buf[var_idx];\n    else\n        var_ref->pvalue = &sf->var_buf[var_idx];\n    return var_ref;\n}\n\nstatic JSValue js_closure2(JSContext *ctx, JSValue func_obj,\n                           JSFunctionBytecode *b,\n                           JSVarRef **cur_var_refs,\n                           JSStackFrame *sf)\n{\n    JSObject *p;\n    JSVarRef **var_refs;\n    int i;\n\n    p = JS_VALUE_GET_OBJ(func_obj);\n    p->u.func.function_bytecode = b;\n    p->u.func.home_object = NULL;\n    p->u.func.var_refs = NULL;\n    if (b->closure_var_count) {\n        var_refs = js_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count);\n        if (!var_refs)\n            goto fail;\n        p->u.func.var_refs = var_refs;\n        for(i = 0; i < b->closure_var_count; i++) {\n            JSClosureVar *cv = &b->closure_var[i];\n            JSVarRef *var_ref;\n            if (cv->is_local) {\n                /* reuse the existing variable reference if it already exists */\n                var_ref = get_var_ref(ctx, sf, cv->var_idx, cv->is_arg);\n                if (!var_ref)\n                    goto fail;\n            } else {\n                var_ref = cur_var_refs[cv->var_idx];\n                var_ref->header.ref_count++;\n            }\n            var_refs[i] = var_ref;\n        }\n    }\n    return func_obj;\n fail:\n    /* bfunc is freed when func_obj is freed */\n    JS_FreeValue(ctx, func_obj);\n    return JS_EXCEPTION;\n}\n\nstatic JSValue js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque)\n{\n    JSValue obj, this_val;\n    int ret;\n\n    this_val = JS_MKPTR(JS_TAG_OBJECT, p);\n    obj = JS_NewObject(ctx);\n    if (JS_IsException(obj))\n        return JS_EXCEPTION;\n    set_cycle_flag(ctx, obj);\n    set_cycle_flag(ctx, this_val);\n    ret = JS_DefinePropertyValue(ctx, obj, JS_ATOM_constructor,\n                                 JS_DupValue(ctx, this_val),\n                                 JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);\n    if (ret < 0) {\n        JS_FreeValue(ctx, obj);\n        return JS_EXCEPTION;\n    }\n    return obj;\n}\n\nstatic const uint16_t func_kind_to_class_id[] = {\n    [JS_FUNC_NORMAL] = JS_CLASS_BYTECODE_FUNCTION,\n    [JS_FUNC_GENERATOR] = JS_CLASS_GENERATOR_FUNCTION,\n    [JS_FUNC_ASYNC] = JS_CLASS_ASYNC_FUNCTION,\n    [JS_FUNC_ASYNC_GENERATOR] = JS_CLASS_ASYNC_GENERATOR_FUNCTION,\n};\n\nstatic JSValue js_closure(JSContext *ctx, JSValue bfunc,\n                          JSVarRef **cur_var_refs,\n                          JSStackFrame *sf)\n{\n    JSFunctionBytecode *b;\n    JSValue func_obj;\n    JSAtom name_atom;\n\n    b = JS_VALUE_GET_PTR(bfunc);\n    func_obj = JS_NewObjectClass(ctx, func_kind_to_class_id[b->func_kind]);\n    if (JS_IsException(func_obj)) {\n        JS_FreeValue(ctx, bfunc);\n        return JS_EXCEPTION;\n    }\n    func_obj = js_closure2(ctx, func_obj, b, cur_var_refs, sf);\n    if (JS_IsException(func_obj)) {\n        /* bfunc has been freed */\n        goto fail;\n    }\n    name_atom = b->func_name;\n    if (name_atom == JS_ATOM_NULL)\n        name_atom = JS_ATOM_empty_string;\n    js_function_set_properties(ctx, func_obj, name_atom,\n                               b->defined_arg_count);\n\n    if (b->func_kind & JS_FUNC_GENERATOR) {\n        JSValue proto;\n        int proto_class_id;\n        /* generators have a prototype field which is used as\n           prototype for the generator object */\n        if (b->func_kind == JS_FUNC_ASYNC_GENERATOR)\n            proto_class_id = JS_CLASS_ASYNC_GENERATOR;\n        else\n            proto_class_id = JS_CLASS_GENERATOR;\n        proto = JS_NewObjectProto(ctx, ctx->class_proto[proto_class_id]);\n        if (JS_IsException(proto))\n            goto fail;\n        JS_DefinePropertyValue(ctx, func_obj, JS_ATOM_prototype, proto,\n                               JS_PROP_WRITABLE);\n    } else if (b->has_prototype) {\n        /* add the 'prototype' property: delay instantiation to avoid\n           creating cycles for every javascript function. The prototype\n           object is created on the fly when first accessed */\n        JS_SetConstructorBit(ctx, func_obj, TRUE);\n        JS_DefineAutoInitProperty(ctx, func_obj, JS_ATOM_prototype,\n                                  JS_AUTOINIT_ID_PROTOTYPE, NULL,\n                                  JS_PROP_WRITABLE);\n    }\n    return func_obj;\n fail:\n    /* bfunc is freed when func_obj is freed */\n    JS_FreeValue(ctx, func_obj);\n    return JS_EXCEPTION;\n}\n\n#define JS_DEFINE_CLASS_HAS_HERITAGE     (1 << 0)\n\nstatic int js_op_define_class(JSContext *ctx, JSValue *sp,\n                              JSAtom class_name, int class_flags,\n                              JSVarRef **cur_var_refs,\n                              JSStackFrame *sf, BOOL is_computed_name)\n{\n    JSValue bfunc, parent_class, proto = JS_UNDEFINED;\n    JSValue ctor = JS_UNDEFINED, parent_proto = JS_UNDEFINED;\n    JSFunctionBytecode *b;\n\n    parent_class = sp[-2];\n    bfunc = sp[-1];\n\n    if (class_flags & JS_DEFINE_CLASS_HAS_HERITAGE) {\n        if (JS_IsNull(parent_class)) {\n            parent_proto = JS_NULL;\n            parent_class = JS_DupValue(ctx, ctx->function_proto);\n        } else {\n            if (!JS_IsConstructor(ctx, parent_class)) {\n                JS_ThrowTypeError(ctx, \"parent class must be constructor\");\n                goto fail;\n            }\n            parent_proto = JS_GetProperty(ctx, parent_class, JS_ATOM_prototype);\n            if (JS_IsException(parent_proto))\n                goto fail;\n            if (!JS_IsNull(parent_proto) && !JS_IsObject(parent_proto)) {\n                JS_ThrowTypeError(ctx, \"parent prototype must be an object or null\");\n                goto fail;\n            }\n        }\n    } else {\n        /* parent_class is JS_UNDEFINED in this case */\n        parent_proto = JS_DupValue(ctx, ctx->class_proto[JS_CLASS_OBJECT]);\n        parent_class = JS_DupValue(ctx, ctx->function_proto);\n    }\n    proto = JS_NewObjectProto(ctx, parent_proto);\n    if (JS_IsException(proto))\n        goto fail;\n\n    b = JS_VALUE_GET_PTR(bfunc);\n    assert(b->func_kind == JS_FUNC_NORMAL);\n    ctor = JS_NewObjectProtoClass(ctx, parent_class,\n                                  JS_CLASS_BYTECODE_FUNCTION);\n    if (JS_IsException(ctor))\n        goto fail;\n    ctor = js_closure2(ctx, ctor, b, cur_var_refs, sf);\n    bfunc = JS_UNDEFINED;\n    if (JS_IsException(ctor))\n        goto fail;\n    js_method_set_home_object(ctx, ctor, proto);\n    JS_SetConstructorBit(ctx, ctor, TRUE);\n\n    JS_DefinePropertyValue(ctx, ctor, JS_ATOM_length,\n                           JS_NewInt32(ctx, b->defined_arg_count),\n                           JS_PROP_CONFIGURABLE);\n\n    if (is_computed_name) {\n        if (JS_DefineObjectNameComputed(ctx, ctor, sp[-3],\n                                        JS_PROP_CONFIGURABLE) < 0)\n            goto fail;\n    } else {\n        if (JS_DefineObjectName(ctx, ctor, class_name, JS_PROP_CONFIGURABLE) < 0)\n            goto fail;\n    }\n\n    /* the constructor property must be first. It can be overriden by\n       computed property names */\n    if (JS_DefinePropertyValue(ctx, proto, JS_ATOM_constructor,\n                               JS_DupValue(ctx, ctor),\n                               JS_PROP_CONFIGURABLE |\n                               JS_PROP_WRITABLE | JS_PROP_THROW) < 0)\n        goto fail;\n    /* set the prototype property */\n    if (JS_DefinePropertyValue(ctx, ctor, JS_ATOM_prototype,\n                               JS_DupValue(ctx, proto), JS_PROP_THROW) < 0)\n        goto fail;\n    set_cycle_flag(ctx, ctor);\n    set_cycle_flag(ctx, proto);\n\n    JS_FreeValue(ctx, parent_proto);\n    JS_FreeValue(ctx, parent_class);\n\n    sp[-2] = ctor;\n    sp[-1] = proto;\n    return 0;\n fail:\n    JS_FreeValue(ctx, parent_class);\n    JS_FreeValue(ctx, parent_proto);\n    JS_FreeValue(ctx, bfunc);\n    JS_FreeValue(ctx, proto);\n    JS_FreeValue(ctx, ctor);\n    sp[-2] = JS_UNDEFINED;\n    sp[-1] = JS_UNDEFINED;\n    return -1;\n}\n\nstatic void close_var_refs(JSRuntime *rt, JSStackFrame *sf)\n{\n    struct list_head *el, *el1;\n    JSVarRef *var_ref;\n    int var_idx;\n\n    list_for_each_safe(el, el1, &sf->var_ref_list) {\n        var_ref = list_entry(el, JSVarRef, var_ref_link);\n        /* no need to unlink var_ref->var_ref_link as the list is never used afterwards */\n        if (var_ref->async_func)\n            async_func_free(rt, var_ref->async_func);\n        var_idx = var_ref->var_idx;\n        if (var_ref->is_arg)\n            var_ref->value = JS_DupValueRT(rt, sf->arg_buf[var_idx]);\n        else\n            var_ref->value = JS_DupValueRT(rt, sf->var_buf[var_idx]);\n        var_ref->pvalue = &var_ref->value;\n        /* the reference is no longer to a local variable */\n        var_ref->is_detached = TRUE;\n    }\n}\n\nstatic void close_lexical_var(JSContext *ctx, JSStackFrame *sf, int idx, int is_arg)\n{\n    struct list_head *el, *el1;\n    JSVarRef *var_ref;\n    int var_idx = idx;\n\n    list_for_each_safe(el, el1, &sf->var_ref_list) {\n        var_ref = list_entry(el, JSVarRef, var_ref_link);\n        if (var_idx == var_ref->var_idx && var_ref->is_arg == is_arg) {\n            list_del(&var_ref->var_ref_link);\n            if (var_ref->async_func)\n                async_func_free(ctx->rt, var_ref->async_func);\n            var_ref->value = JS_DupValue(ctx, sf->var_buf[var_idx]);\n            var_ref->pvalue = &var_ref->value;\n            /* the reference is no longer to a local variable */\n            var_ref->is_detached = TRUE;\n        }\n    }\n}\n\n#define JS_CALL_FLAG_COPY_ARGV   (1 << 1)\n#define JS_CALL_FLAG_GENERATOR   (1 << 2)\n\nstatic JSValue js_call_c_function(JSContext *ctx, JSValueConst func_obj,\n                                  JSValueConst this_obj,\n                                  int argc, JSValueConst *argv, int flags)\n{\n    JSRuntime *rt = ctx->rt;\n    JSCFunctionType func;\n    JSObject *p;\n    JSStackFrame sf_s, *sf = &sf_s, *prev_sf;\n    JSValue ret_val;\n    JSValueConst *arg_buf;\n    int arg_count, i;\n    JSCFunctionEnum cproto;\n\n    p = JS_VALUE_GET_OBJ(func_obj);\n    cproto = p->u.cfunc.cproto;\n    arg_count = p->u.cfunc.length;\n\n    /* better to always check stack overflow */\n    if (js_check_stack_overflow(rt, sizeof(arg_buf[0]) * arg_count))\n        return JS_ThrowStackOverflow(ctx);\n\n    prev_sf = rt->current_stack_frame;\n    sf->prev_frame = prev_sf;\n    rt->current_stack_frame = sf;\n    ctx = p->u.cfunc.realm; /* change the current realm */\n\n#ifdef CONFIG_BIGNUM\n    /* we only propagate the bignum mode as some runtime functions\n       test it */\n    if (prev_sf)\n        sf->js_mode = prev_sf->js_mode & JS_MODE_MATH;\n    else\n        sf->js_mode = 0;\n#else\n    sf->js_mode = 0;\n#endif\n    sf->cur_func = (JSValue)func_obj;\n    sf->arg_count = argc;\n    arg_buf = argv;\n\n    if (unlikely(argc < arg_count)) {\n        /* ensure that at least argc_count arguments are readable */\n        arg_buf = alloca(sizeof(arg_buf[0]) * arg_count);\n        for(i = 0; i < argc; i++)\n            arg_buf[i] = argv[i];\n        for(i = argc; i < arg_count; i++)\n            arg_buf[i] = JS_UNDEFINED;\n        sf->arg_count = arg_count;\n    }\n    sf->arg_buf = (JSValue*)arg_buf;\n\n    func = p->u.cfunc.c_function;\n    switch(cproto) {\n    case JS_CFUNC_constructor:\n    case JS_CFUNC_constructor_or_func:\n        if (!(flags & JS_CALL_FLAG_CONSTRUCTOR)) {\n            if (cproto == JS_CFUNC_constructor) {\n            not_a_constructor:\n                ret_val = JS_ThrowTypeError(ctx, \"must be called with new\");\n                break;\n            } else {\n                this_obj = JS_UNDEFINED;\n            }\n        }\n        /* here this_obj is new_target */\n        /* fall thru */\n    case JS_CFUNC_generic:\n        ret_val = func.generic(ctx, this_obj, argc, arg_buf);\n        break;\n    case JS_CFUNC_constructor_magic:\n    case JS_CFUNC_constructor_or_func_magic:\n        if (!(flags & JS_CALL_FLAG_CONSTRUCTOR)) {\n            if (cproto == JS_CFUNC_constructor_magic) {\n                goto not_a_constructor;\n            } else {\n                this_obj = JS_UNDEFINED;\n            }\n        }\n        /* fall thru */\n    case JS_CFUNC_generic_magic:\n        ret_val = func.generic_magic(ctx, this_obj, argc, arg_buf,\n                                     p->u.cfunc.magic);\n        break;\n    case JS_CFUNC_getter:\n        ret_val = func.getter(ctx, this_obj);\n        break;\n    case JS_CFUNC_setter:\n        ret_val = func.setter(ctx, this_obj, arg_buf[0]);\n        break;\n    case JS_CFUNC_getter_magic:\n        ret_val = func.getter_magic(ctx, this_obj, p->u.cfunc.magic);\n        break;\n    case JS_CFUNC_setter_magic:\n        ret_val = func.setter_magic(ctx, this_obj, arg_buf[0], p->u.cfunc.magic);\n        break;\n    case JS_CFUNC_f_f:\n        {\n            double d1;\n\n            if (unlikely(JS_ToFloat64(ctx, &d1, arg_buf[0]))) {\n                ret_val = JS_EXCEPTION;\n                break;\n            }\n            ret_val = JS_NewFloat64(ctx, func.f_f(d1));\n        }\n        break;\n    case JS_CFUNC_f_f_f:\n        {\n            double d1, d2;\n\n            if (unlikely(JS_ToFloat64(ctx, &d1, arg_buf[0]))) {\n                ret_val = JS_EXCEPTION;\n                break;\n            }\n            if (unlikely(JS_ToFloat64(ctx, &d2, arg_buf[1]))) {\n                ret_val = JS_EXCEPTION;\n                break;\n            }\n            ret_val = JS_NewFloat64(ctx, func.f_f_f(d1, d2));\n        }\n        break;\n    case JS_CFUNC_iterator_next:\n        {\n            int done;\n            ret_val = func.iterator_next(ctx, this_obj, argc, arg_buf,\n                                         &done, p->u.cfunc.magic);\n            if (!JS_IsException(ret_val) && done != 2) {\n                ret_val = js_create_iterator_result(ctx, ret_val, done);\n            }\n        }\n        break;\n    default:\n        abort();\n    }\n\n    rt->current_stack_frame = sf->prev_frame;\n    return ret_val;\n}\n\nstatic JSValue js_call_bound_function(JSContext *ctx, JSValueConst func_obj,\n                                      JSValueConst this_obj,\n                                      int argc, JSValueConst *argv, int flags)\n{\n    JSObject *p;\n    JSBoundFunction *bf;\n    JSValueConst *arg_buf, new_target;\n    int arg_count, i;\n\n    p = JS_VALUE_GET_OBJ(func_obj);\n    bf = p->u.bound_function;\n    arg_count = bf->argc + argc;\n    if (js_check_stack_overflow(ctx->rt, sizeof(JSValue) * arg_count))\n        return JS_ThrowStackOverflow(ctx);\n    arg_buf = alloca(sizeof(JSValue) * arg_count);\n    for(i = 0; i < bf->argc; i++) {\n        arg_buf[i] = bf->argv[i];\n    }\n    for(i = 0; i < argc; i++) {\n        arg_buf[bf->argc + i] = argv[i];\n    }\n    if (flags & JS_CALL_FLAG_CONSTRUCTOR) {\n        new_target = this_obj;\n        if (js_same_value(ctx, func_obj, new_target))\n            new_target = bf->func_obj;\n        return JS_CallConstructor2(ctx, bf->func_obj, new_target,\n                                   arg_count, arg_buf);\n    } else {\n        return JS_Call(ctx, bf->func_obj, bf->this_val,\n                       arg_count, arg_buf);\n    }\n}\n\n/* argument of OP_special_object */\ntypedef enum {\n    OP_SPECIAL_OBJECT_ARGUMENTS,\n    OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS,\n    OP_SPECIAL_OBJECT_THIS_FUNC,\n    OP_SPECIAL_OBJECT_NEW_TARGET,\n    OP_SPECIAL_OBJECT_HOME_OBJECT,\n    OP_SPECIAL_OBJECT_VAR_OBJECT,\n    OP_SPECIAL_OBJECT_IMPORT_META,\n} OPSpecialObjectEnum;\n\n#define FUNC_RET_AWAIT         0\n#define FUNC_RET_YIELD         1\n#define FUNC_RET_YIELD_STAR    2\n#define FUNC_RET_INITIAL_YIELD 3\n\n/* argv[] is modified if (flags & JS_CALL_FLAG_COPY_ARGV) = 0. */\nstatic JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,\n                               JSValueConst this_obj, JSValueConst new_target,\n                               int argc, JSValue *argv, int flags)\n{\n    JSRuntime *rt = caller_ctx->rt;\n    JSContext *ctx;\n    JSObject *p;\n    JSFunctionBytecode *b;\n    JSStackFrame sf_s"
        },
        {
          "name": "quickjs.h",
          "type": "blob",
          "size": 42.04296875,
          "content": "/*\n * QuickJS Javascript Engine\n *\n * Copyright (c) 2017-2021 Fabrice Bellard\n * Copyright (c) 2017-2021 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#ifndef QUICKJS_H\n#define QUICKJS_H\n\n#include <stdio.h>\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(__GNUC__) || defined(__clang__)\n#define js_likely(x)          __builtin_expect(!!(x), 1)\n#define js_unlikely(x)        __builtin_expect(!!(x), 0)\n#define js_force_inline       inline __attribute__((always_inline))\n#define __js_printf_like(f, a)   __attribute__((format(printf, f, a)))\n#else\n#define js_likely(x)     (x)\n#define js_unlikely(x)   (x)\n#define js_force_inline  inline\n#define __js_printf_like(a, b)\n#endif\n\n#define JS_BOOL int\n\ntypedef struct JSRuntime JSRuntime;\ntypedef struct JSContext JSContext;\ntypedef struct JSObject JSObject;\ntypedef struct JSClass JSClass;\ntypedef uint32_t JSClassID;\ntypedef uint32_t JSAtom;\n\n#if INTPTR_MAX >= INT64_MAX\n#define JS_PTR64\n#define JS_PTR64_DEF(a) a\n#else\n#define JS_PTR64_DEF(a)\n#endif\n\n#ifndef JS_PTR64\n#define JS_NAN_BOXING\n#endif\n\nenum {\n    /* all tags with a reference count are negative */\n    JS_TAG_FIRST       = -11, /* first negative tag */\n    JS_TAG_BIG_DECIMAL = -11,\n    JS_TAG_BIG_INT     = -10,\n    JS_TAG_BIG_FLOAT   = -9,\n    JS_TAG_SYMBOL      = -8,\n    JS_TAG_STRING      = -7,\n    JS_TAG_MODULE      = -3, /* used internally */\n    JS_TAG_FUNCTION_BYTECODE = -2, /* used internally */\n    JS_TAG_OBJECT      = -1,\n\n    JS_TAG_INT         = 0,\n    JS_TAG_BOOL        = 1,\n    JS_TAG_NULL        = 2,\n    JS_TAG_UNDEFINED   = 3,\n    JS_TAG_UNINITIALIZED = 4,\n    JS_TAG_CATCH_OFFSET = 5,\n    JS_TAG_EXCEPTION   = 6,\n    JS_TAG_FLOAT64     = 7,\n    /* any larger tag is FLOAT64 if JS_NAN_BOXING */\n};\n\ntypedef struct JSRefCountHeader {\n    int ref_count;\n} JSRefCountHeader;\n\n#define JS_FLOAT64_NAN NAN\n\n#ifdef CONFIG_CHECK_JSVALUE\n/* JSValue consistency : it is not possible to run the code in this\n   mode, but it is useful to detect simple reference counting\n   errors. It would be interesting to modify a static C analyzer to\n   handle specific annotations (clang has such annotations but only\n   for objective C) */\ntypedef struct __JSValue *JSValue;\ntypedef const struct __JSValue *JSValueConst;\n\n#define JS_VALUE_GET_TAG(v) (int)((uintptr_t)(v) & 0xf)\n/* same as JS_VALUE_GET_TAG, but return JS_TAG_FLOAT64 with NaN boxing */\n#define JS_VALUE_GET_NORM_TAG(v) JS_VALUE_GET_TAG(v)\n#define JS_VALUE_GET_INT(v) (int)((intptr_t)(v) >> 4)\n#define JS_VALUE_GET_BOOL(v) JS_VALUE_GET_INT(v)\n#define JS_VALUE_GET_FLOAT64(v) (double)JS_VALUE_GET_INT(v)\n#define JS_VALUE_GET_PTR(v) (void *)((intptr_t)(v) & ~0xf)\n\n#define JS_MKVAL(tag, val) (JSValue)(intptr_t)(((val) << 4) | (tag))\n#define JS_MKPTR(tag, p) (JSValue)((intptr_t)(p) | (tag))\n\n#define JS_TAG_IS_FLOAT64(tag) ((unsigned)(tag) == JS_TAG_FLOAT64)\n\n#define JS_NAN JS_MKVAL(JS_TAG_FLOAT64, 1)\n\nstatic inline JSValue __JS_NewFloat64(JSContext *ctx, double d)\n{\n    return JS_MKVAL(JS_TAG_FLOAT64, (int)d);\n}\n\nstatic inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)\n{\n    return 0;\n}\n\n#elif defined(JS_NAN_BOXING)\n\ntypedef uint64_t JSValue;\n\n#define JSValueConst JSValue\n\n#define JS_VALUE_GET_TAG(v) (int)((v) >> 32)\n#define JS_VALUE_GET_INT(v) (int)(v)\n#define JS_VALUE_GET_BOOL(v) (int)(v)\n#define JS_VALUE_GET_PTR(v) (void *)(intptr_t)(v)\n\n#define JS_MKVAL(tag, val) (((uint64_t)(tag) << 32) | (uint32_t)(val))\n#define JS_MKPTR(tag, ptr) (((uint64_t)(tag) << 32) | (uintptr_t)(ptr))\n\n#define JS_FLOAT64_TAG_ADDEND (0x7ff80000 - JS_TAG_FIRST + 1) /* quiet NaN encoding */\n\nstatic inline double JS_VALUE_GET_FLOAT64(JSValue v)\n{\n    union {\n        JSValue v;\n        double d;\n    } u;\n    u.v = v;\n    u.v += (uint64_t)JS_FLOAT64_TAG_ADDEND << 32;\n    return u.d;\n}\n\n#define JS_NAN (0x7ff8000000000000 - ((uint64_t)JS_FLOAT64_TAG_ADDEND << 32))\n\nstatic inline JSValue __JS_NewFloat64(JSContext *ctx, double d)\n{\n    union {\n        double d;\n        uint64_t u64;\n    } u;\n    JSValue v;\n    u.d = d;\n    /* normalize NaN */\n    if (js_unlikely((u.u64 & 0x7fffffffffffffff) > 0x7ff0000000000000))\n        v = JS_NAN;\n    else\n        v = u.u64 - ((uint64_t)JS_FLOAT64_TAG_ADDEND << 32);\n    return v;\n}\n\n#define JS_TAG_IS_FLOAT64(tag) ((unsigned)((tag) - JS_TAG_FIRST) >= (JS_TAG_FLOAT64 - JS_TAG_FIRST))\n\n/* same as JS_VALUE_GET_TAG, but return JS_TAG_FLOAT64 with NaN boxing */\nstatic inline int JS_VALUE_GET_NORM_TAG(JSValue v)\n{\n    uint32_t tag;\n    tag = JS_VALUE_GET_TAG(v);\n    if (JS_TAG_IS_FLOAT64(tag))\n        return JS_TAG_FLOAT64;\n    else\n        return tag;\n}\n\nstatic inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)\n{\n    uint32_t tag;\n    tag = JS_VALUE_GET_TAG(v);\n    return tag == (JS_NAN >> 32);\n}\n\n#else /* !JS_NAN_BOXING */\n\ntypedef union JSValueUnion {\n    int32_t int32;\n    double float64;\n    void *ptr;\n} JSValueUnion;\n\ntypedef struct JSValue {\n    JSValueUnion u;\n    int64_t tag;\n} JSValue;\n\n#define JSValueConst JSValue\n\n#define JS_VALUE_GET_TAG(v) ((int32_t)(v).tag)\n/* same as JS_VALUE_GET_TAG, but return JS_TAG_FLOAT64 with NaN boxing */\n#define JS_VALUE_GET_NORM_TAG(v) JS_VALUE_GET_TAG(v)\n#define JS_VALUE_GET_INT(v) ((v).u.int32)\n#define JS_VALUE_GET_BOOL(v) ((v).u.int32)\n#define JS_VALUE_GET_FLOAT64(v) ((v).u.float64)\n#define JS_VALUE_GET_PTR(v) ((v).u.ptr)\n\n#define JS_MKVAL(tag, val) (JSValue){ (JSValueUnion){ .int32 = val }, tag }\n#define JS_MKPTR(tag, p) (JSValue){ (JSValueUnion){ .ptr = p }, tag }\n\n#define JS_TAG_IS_FLOAT64(tag) ((unsigned)(tag) == JS_TAG_FLOAT64)\n\n#define JS_NAN (JSValue){ .u.float64 = JS_FLOAT64_NAN, JS_TAG_FLOAT64 }\n\nstatic inline JSValue __JS_NewFloat64(JSContext *ctx, double d)\n{\n    JSValue v;\n    v.tag = JS_TAG_FLOAT64;\n    v.u.float64 = d;\n    return v;\n}\n\nstatic inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)\n{\n    union {\n        double d;\n        uint64_t u64;\n    } u;\n    if (v.tag != JS_TAG_FLOAT64)\n        return 0;\n    u.d = v.u.float64;\n    return (u.u64 & 0x7fffffffffffffff) > 0x7ff0000000000000;\n}\n\n#endif /* !JS_NAN_BOXING */\n\n#define JS_VALUE_IS_BOTH_INT(v1, v2) ((JS_VALUE_GET_TAG(v1) | JS_VALUE_GET_TAG(v2)) == 0)\n#define JS_VALUE_IS_BOTH_FLOAT(v1, v2) (JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(v1)) && JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(v2)))\n\n#define JS_VALUE_GET_OBJ(v) ((JSObject *)JS_VALUE_GET_PTR(v))\n#define JS_VALUE_GET_STRING(v) ((JSString *)JS_VALUE_GET_PTR(v))\n#define JS_VALUE_HAS_REF_COUNT(v) ((unsigned)JS_VALUE_GET_TAG(v) >= (unsigned)JS_TAG_FIRST)\n\n/* special values */\n#define JS_NULL      JS_MKVAL(JS_TAG_NULL, 0)\n#define JS_UNDEFINED JS_MKVAL(JS_TAG_UNDEFINED, 0)\n#define JS_FALSE     JS_MKVAL(JS_TAG_BOOL, 0)\n#define JS_TRUE      JS_MKVAL(JS_TAG_BOOL, 1)\n#define JS_EXCEPTION JS_MKVAL(JS_TAG_EXCEPTION, 0)\n#define JS_UNINITIALIZED JS_MKVAL(JS_TAG_UNINITIALIZED, 0)\n\n/* flags for object properties */\n#define JS_PROP_CONFIGURABLE  (1 << 0)\n#define JS_PROP_WRITABLE      (1 << 1)\n#define JS_PROP_ENUMERABLE    (1 << 2)\n#define JS_PROP_C_W_E         (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)\n#define JS_PROP_LENGTH        (1 << 3) /* used internally in Arrays */\n#define JS_PROP_TMASK         (3 << 4) /* mask for NORMAL, GETSET, VARREF, AUTOINIT */\n#define JS_PROP_NORMAL         (0 << 4)\n#define JS_PROP_GETSET         (1 << 4)\n#define JS_PROP_VARREF         (2 << 4) /* used internally */\n#define JS_PROP_AUTOINIT       (3 << 4) /* used internally */\n\n/* flags for JS_DefineProperty */\n#define JS_PROP_HAS_SHIFT        8\n#define JS_PROP_HAS_CONFIGURABLE (1 << 8)\n#define JS_PROP_HAS_WRITABLE     (1 << 9)\n#define JS_PROP_HAS_ENUMERABLE   (1 << 10)\n#define JS_PROP_HAS_GET          (1 << 11)\n#define JS_PROP_HAS_SET          (1 << 12)\n#define JS_PROP_HAS_VALUE        (1 << 13)\n\n/* throw an exception if false would be returned\n   (JS_DefineProperty/JS_SetProperty) */\n#define JS_PROP_THROW            (1 << 14)\n/* throw an exception if false would be returned in strict mode\n   (JS_SetProperty) */\n#define JS_PROP_THROW_STRICT     (1 << 15)\n\n#define JS_PROP_NO_ADD           (1 << 16) /* internal use */\n#define JS_PROP_NO_EXOTIC        (1 << 17) /* internal use */\n\n#define JS_DEFAULT_STACK_SIZE (256 * 1024)\n\n/* JS_Eval() flags */\n#define JS_EVAL_TYPE_GLOBAL   (0 << 0) /* global code (default) */\n#define JS_EVAL_TYPE_MODULE   (1 << 0) /* module code */\n#define JS_EVAL_TYPE_DIRECT   (2 << 0) /* direct call (internal use) */\n#define JS_EVAL_TYPE_INDIRECT (3 << 0) /* indirect call (internal use) */\n#define JS_EVAL_TYPE_MASK     (3 << 0)\n\n#define JS_EVAL_FLAG_STRICT   (1 << 3) /* force 'strict' mode */\n#define JS_EVAL_FLAG_STRIP    (1 << 4) /* force 'strip' mode */\n/* compile but do not run. The result is an object with a\n   JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed\n   with JS_EvalFunction(). */\n#define JS_EVAL_FLAG_COMPILE_ONLY (1 << 5)\n/* don't include the stack frames before this eval in the Error() backtraces */\n#define JS_EVAL_FLAG_BACKTRACE_BARRIER (1 << 6)\n/* allow top-level await in normal script. JS_Eval() returns a\n   promise. Only allowed with JS_EVAL_TYPE_GLOBAL */\n#define JS_EVAL_FLAG_ASYNC (1 << 7)\n\ntypedef JSValue JSCFunction(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);\ntypedef JSValue JSCFunctionMagic(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic);\ntypedef JSValue JSCFunctionData(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic, JSValue *func_data);\n\ntypedef struct JSMallocState {\n    size_t malloc_count;\n    size_t malloc_size;\n    size_t malloc_limit;\n    void *opaque; /* user opaque */\n} JSMallocState;\n\ntypedef struct JSMallocFunctions {\n    void *(*js_malloc)(JSMallocState *s, size_t size);\n    void (*js_free)(JSMallocState *s, void *ptr);\n    void *(*js_realloc)(JSMallocState *s, void *ptr, size_t size);\n    size_t (*js_malloc_usable_size)(const void *ptr);\n} JSMallocFunctions;\n\ntypedef struct JSGCObjectHeader JSGCObjectHeader;\n\nJSRuntime *JS_NewRuntime(void);\n/* info lifetime must exceed that of rt */\nvoid JS_SetRuntimeInfo(JSRuntime *rt, const char *info);\nvoid JS_SetMemoryLimit(JSRuntime *rt, size_t limit);\nvoid JS_SetGCThreshold(JSRuntime *rt, size_t gc_threshold);\n/* use 0 to disable maximum stack size check */\nvoid JS_SetMaxStackSize(JSRuntime *rt, size_t stack_size);\n/* should be called when changing thread to update the stack top value\n   used to check stack overflow. */\nvoid JS_UpdateStackTop(JSRuntime *rt);\nJSRuntime *JS_NewRuntime2(const JSMallocFunctions *mf, void *opaque);\nvoid JS_FreeRuntime(JSRuntime *rt);\nvoid *JS_GetRuntimeOpaque(JSRuntime *rt);\nvoid JS_SetRuntimeOpaque(JSRuntime *rt, void *opaque);\ntypedef void JS_MarkFunc(JSRuntime *rt, JSGCObjectHeader *gp);\nvoid JS_MarkValue(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);\nvoid JS_RunGC(JSRuntime *rt);\nJS_BOOL JS_IsLiveObject(JSRuntime *rt, JSValueConst obj);\n\nJSContext *JS_NewContext(JSRuntime *rt);\nvoid JS_FreeContext(JSContext *s);\nJSContext *JS_DupContext(JSContext *ctx);\nvoid *JS_GetContextOpaque(JSContext *ctx);\nvoid JS_SetContextOpaque(JSContext *ctx, void *opaque);\nJSRuntime *JS_GetRuntime(JSContext *ctx);\nvoid JS_SetClassProto(JSContext *ctx, JSClassID class_id, JSValue obj);\nJSValue JS_GetClassProto(JSContext *ctx, JSClassID class_id);\n\n/* the following functions are used to select the intrinsic object to\n   save memory */\nJSContext *JS_NewContextRaw(JSRuntime *rt);\nvoid JS_AddIntrinsicBaseObjects(JSContext *ctx);\nvoid JS_AddIntrinsicDate(JSContext *ctx);\nvoid JS_AddIntrinsicEval(JSContext *ctx);\nvoid JS_AddIntrinsicStringNormalize(JSContext *ctx);\nvoid JS_AddIntrinsicRegExpCompiler(JSContext *ctx);\nvoid JS_AddIntrinsicRegExp(JSContext *ctx);\nvoid JS_AddIntrinsicJSON(JSContext *ctx);\nvoid JS_AddIntrinsicProxy(JSContext *ctx);\nvoid JS_AddIntrinsicMapSet(JSContext *ctx);\nvoid JS_AddIntrinsicTypedArrays(JSContext *ctx);\nvoid JS_AddIntrinsicPromise(JSContext *ctx);\nvoid JS_AddIntrinsicBigInt(JSContext *ctx);\nvoid JS_AddIntrinsicBigFloat(JSContext *ctx);\nvoid JS_AddIntrinsicBigDecimal(JSContext *ctx);\n/* enable operator overloading */\nvoid JS_AddIntrinsicOperators(JSContext *ctx);\n/* enable \"use math\" */\nvoid JS_EnableBignumExt(JSContext *ctx, JS_BOOL enable);\n\nJSValue js_string_codePointRange(JSContext *ctx, JSValueConst this_val,\n                                 int argc, JSValueConst *argv);\n\nvoid *js_malloc_rt(JSRuntime *rt, size_t size);\nvoid js_free_rt(JSRuntime *rt, void *ptr);\nvoid *js_realloc_rt(JSRuntime *rt, void *ptr, size_t size);\nsize_t js_malloc_usable_size_rt(JSRuntime *rt, const void *ptr);\nvoid *js_mallocz_rt(JSRuntime *rt, size_t size);\n\nvoid *js_malloc(JSContext *ctx, size_t size);\nvoid js_free(JSContext *ctx, void *ptr);\nvoid *js_realloc(JSContext *ctx, void *ptr, size_t size);\nsize_t js_malloc_usable_size(JSContext *ctx, const void *ptr);\nvoid *js_realloc2(JSContext *ctx, void *ptr, size_t size, size_t *pslack);\nvoid *js_mallocz(JSContext *ctx, size_t size);\nchar *js_strdup(JSContext *ctx, const char *str);\nchar *js_strndup(JSContext *ctx, const char *s, size_t n);\n\ntypedef struct JSMemoryUsage {\n    int64_t malloc_size, malloc_limit, memory_used_size;\n    int64_t malloc_count;\n    int64_t memory_used_count;\n    int64_t atom_count, atom_size;\n    int64_t str_count, str_size;\n    int64_t obj_count, obj_size;\n    int64_t prop_count, prop_size;\n    int64_t shape_count, shape_size;\n    int64_t js_func_count, js_func_size, js_func_code_size;\n    int64_t js_func_pc2line_count, js_func_pc2line_size;\n    int64_t c_func_count, array_count;\n    int64_t fast_array_count, fast_array_elements;\n    int64_t binary_object_count, binary_object_size;\n} JSMemoryUsage;\n\nvoid JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s);\nvoid JS_DumpMemoryUsage(FILE *fp, const JSMemoryUsage *s, JSRuntime *rt);\n\n/* atom support */\n#define JS_ATOM_NULL 0\n\nJSAtom JS_NewAtomLen(JSContext *ctx, const char *str, size_t len);\nJSAtom JS_NewAtom(JSContext *ctx, const char *str);\nJSAtom JS_NewAtomUInt32(JSContext *ctx, uint32_t n);\nJSAtom JS_DupAtom(JSContext *ctx, JSAtom v);\nvoid JS_FreeAtom(JSContext *ctx, JSAtom v);\nvoid JS_FreeAtomRT(JSRuntime *rt, JSAtom v);\nJSValue JS_AtomToValue(JSContext *ctx, JSAtom atom);\nJSValue JS_AtomToString(JSContext *ctx, JSAtom atom);\nconst char *JS_AtomToCString(JSContext *ctx, JSAtom atom);\nJSAtom JS_ValueToAtom(JSContext *ctx, JSValueConst val);\n\n/* object class support */\n\ntypedef struct JSPropertyEnum {\n    JS_BOOL is_enumerable;\n    JSAtom atom;\n} JSPropertyEnum;\n\ntypedef struct JSPropertyDescriptor {\n    int flags;\n    JSValue value;\n    JSValue getter;\n    JSValue setter;\n} JSPropertyDescriptor;\n\ntypedef struct JSClassExoticMethods {\n    /* Return -1 if exception (can only happen in case of Proxy object),\n       FALSE if the property does not exists, TRUE if it exists. If 1 is\n       returned, the property descriptor 'desc' is filled if != NULL. */\n    int (*get_own_property)(JSContext *ctx, JSPropertyDescriptor *desc,\n                             JSValueConst obj, JSAtom prop);\n    /* '*ptab' should hold the '*plen' property keys. Return 0 if OK,\n       -1 if exception. The 'is_enumerable' field is ignored.\n    */\n    int (*get_own_property_names)(JSContext *ctx, JSPropertyEnum **ptab,\n                                  uint32_t *plen,\n                                  JSValueConst obj);\n    /* return < 0 if exception, or TRUE/FALSE */\n    int (*delete_property)(JSContext *ctx, JSValueConst obj, JSAtom prop);\n    /* return < 0 if exception or TRUE/FALSE */\n    int (*define_own_property)(JSContext *ctx, JSValueConst this_obj,\n                               JSAtom prop, JSValueConst val,\n                               JSValueConst getter, JSValueConst setter,\n                               int flags);\n    /* The following methods can be emulated with the previous ones,\n       so they are usually not needed */\n    /* return < 0 if exception or TRUE/FALSE */\n    int (*has_property)(JSContext *ctx, JSValueConst obj, JSAtom atom);\n    JSValue (*get_property)(JSContext *ctx, JSValueConst obj, JSAtom atom,\n                            JSValueConst receiver);\n    /* return < 0 if exception or TRUE/FALSE */\n    int (*set_property)(JSContext *ctx, JSValueConst obj, JSAtom atom,\n                        JSValueConst value, JSValueConst receiver, int flags);\n} JSClassExoticMethods;\n\ntypedef void JSClassFinalizer(JSRuntime *rt, JSValue val);\ntypedef void JSClassGCMark(JSRuntime *rt, JSValueConst val,\n                           JS_MarkFunc *mark_func);\n#define JS_CALL_FLAG_CONSTRUCTOR (1 << 0)\ntypedef JSValue JSClassCall(JSContext *ctx, JSValueConst func_obj,\n                            JSValueConst this_val, int argc, JSValueConst *argv,\n                            int flags);\n\ntypedef struct JSClassDef {\n    const char *class_name;\n    JSClassFinalizer *finalizer;\n    JSClassGCMark *gc_mark;\n    /* if call != NULL, the object is a function. If (flags &\n       JS_CALL_FLAG_CONSTRUCTOR) != 0, the function is called as a\n       constructor. In this case, 'this_val' is new.target. A\n       constructor call only happens if the object constructor bit is\n       set (see JS_SetConstructorBit()). */\n    JSClassCall *call;\n    /* XXX: suppress this indirection ? It is here only to save memory\n       because only a few classes need these methods */\n    JSClassExoticMethods *exotic;\n} JSClassDef;\n\n#define JS_INVALID_CLASS_ID 0\nJSClassID JS_NewClassID(JSClassID *pclass_id);\n/* Returns the class ID if `v` is an object, otherwise returns JS_INVALID_CLASS_ID. */\nJSClassID JS_GetClassID(JSValue v);\nint JS_NewClass(JSRuntime *rt, JSClassID class_id, const JSClassDef *class_def);\nint JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id);\n\n/* value handling */\n\nstatic js_force_inline JSValue JS_NewBool(JSContext *ctx, JS_BOOL val)\n{\n    return JS_MKVAL(JS_TAG_BOOL, (val != 0));\n}\n\nstatic js_force_inline JSValue JS_NewInt32(JSContext *ctx, int32_t val)\n{\n    return JS_MKVAL(JS_TAG_INT, val);\n}\n\nstatic js_force_inline JSValue JS_NewCatchOffset(JSContext *ctx, int32_t val)\n{\n    return JS_MKVAL(JS_TAG_CATCH_OFFSET, val);\n}\n\nstatic js_force_inline JSValue JS_NewInt64(JSContext *ctx, int64_t val)\n{\n    JSValue v;\n    if (val == (int32_t)val) {\n        v = JS_NewInt32(ctx, val);\n    } else {\n        v = __JS_NewFloat64(ctx, val);\n    }\n    return v;\n}\n\nstatic js_force_inline JSValue JS_NewUint32(JSContext *ctx, uint32_t val)\n{\n    JSValue v;\n    if (val <= 0x7fffffff) {\n        v = JS_NewInt32(ctx, val);\n    } else {\n        v = __JS_NewFloat64(ctx, val);\n    }\n    return v;\n}\n\nJSValue JS_NewBigInt64(JSContext *ctx, int64_t v);\nJSValue JS_NewBigUint64(JSContext *ctx, uint64_t v);\n\nstatic js_force_inline JSValue JS_NewFloat64(JSContext *ctx, double d)\n{\n    int32_t val;\n    union {\n        double d;\n        uint64_t u;\n    } u, t;\n    if (d >= INT32_MIN && d <= INT32_MAX) {\n        u.d = d;\n        val = (int32_t)d;\n        t.d = val;\n        /* -0 cannot be represented as integer, so we compare the bit\n           representation */\n        if (u.u == t.u)\n            return JS_MKVAL(JS_TAG_INT, val);\n    }\n    return __JS_NewFloat64(ctx, d);\n}\n\nstatic inline JS_BOOL JS_IsNumber(JSValueConst v)\n{\n    int tag = JS_VALUE_GET_TAG(v);\n    return tag == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag);\n}\n\nstatic inline JS_BOOL JS_IsBigInt(JSContext *ctx, JSValueConst v)\n{\n    int tag = JS_VALUE_GET_TAG(v);\n    return tag == JS_TAG_BIG_INT;\n}\n\nstatic inline JS_BOOL JS_IsBigFloat(JSValueConst v)\n{\n    int tag = JS_VALUE_GET_TAG(v);\n    return tag == JS_TAG_BIG_FLOAT;\n}\n\nstatic inline JS_BOOL JS_IsBigDecimal(JSValueConst v)\n{\n    int tag = JS_VALUE_GET_TAG(v);\n    return tag == JS_TAG_BIG_DECIMAL;\n}\n\nstatic inline JS_BOOL JS_IsBool(JSValueConst v)\n{\n    return JS_VALUE_GET_TAG(v) == JS_TAG_BOOL;\n}\n\nstatic inline JS_BOOL JS_IsNull(JSValueConst v)\n{\n    return JS_VALUE_GET_TAG(v) == JS_TAG_NULL;\n}\n\nstatic inline JS_BOOL JS_IsUndefined(JSValueConst v)\n{\n    return JS_VALUE_GET_TAG(v) == JS_TAG_UNDEFINED;\n}\n\nstatic inline JS_BOOL JS_IsException(JSValueConst v)\n{\n    return js_unlikely(JS_VALUE_GET_TAG(v) == JS_TAG_EXCEPTION);\n}\n\nstatic inline JS_BOOL JS_IsUninitialized(JSValueConst v)\n{\n    return js_unlikely(JS_VALUE_GET_TAG(v) == JS_TAG_UNINITIALIZED);\n}\n\nstatic inline JS_BOOL JS_IsString(JSValueConst v)\n{\n    return JS_VALUE_GET_TAG(v) == JS_TAG_STRING;\n}\n\nstatic inline JS_BOOL JS_IsSymbol(JSValueConst v)\n{\n    return JS_VALUE_GET_TAG(v) == JS_TAG_SYMBOL;\n}\n\nstatic inline JS_BOOL JS_IsObject(JSValueConst v)\n{\n    return JS_VALUE_GET_TAG(v) == JS_TAG_OBJECT;\n}\n\nJSValue JS_Throw(JSContext *ctx, JSValue obj);\nJSValue JS_GetException(JSContext *ctx);\nJS_BOOL JS_HasException(JSContext *ctx);\nJS_BOOL JS_IsError(JSContext *ctx, JSValueConst val);\nvoid JS_SetUncatchableError(JSContext *ctx, JSValueConst val, JS_BOOL flag);\nvoid JS_ResetUncatchableError(JSContext *ctx);\nJSValue JS_NewError(JSContext *ctx);\nJSValue __js_printf_like(2, 3) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...);\nJSValue __js_printf_like(2, 3) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...);\nJSValue __js_printf_like(2, 3) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...);\nJSValue __js_printf_like(2, 3) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...);\nJSValue __js_printf_like(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);\nJSValue JS_ThrowOutOfMemory(JSContext *ctx);\n\nvoid __JS_FreeValue(JSContext *ctx, JSValue v);\nstatic inline void JS_FreeValue(JSContext *ctx, JSValue v)\n{\n    if (JS_VALUE_HAS_REF_COUNT(v)) {\n        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);\n        if (--p->ref_count <= 0) {\n            __JS_FreeValue(ctx, v);\n        }\n    }\n}\nvoid __JS_FreeValueRT(JSRuntime *rt, JSValue v);\nstatic inline void JS_FreeValueRT(JSRuntime *rt, JSValue v)\n{\n    if (JS_VALUE_HAS_REF_COUNT(v)) {\n        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);\n        if (--p->ref_count <= 0) {\n            __JS_FreeValueRT(rt, v);\n        }\n    }\n}\n\nstatic inline JSValue JS_DupValue(JSContext *ctx, JSValueConst v)\n{\n    if (JS_VALUE_HAS_REF_COUNT(v)) {\n        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);\n        p->ref_count++;\n    }\n    return (JSValue)v;\n}\n\nstatic inline JSValue JS_DupValueRT(JSRuntime *rt, JSValueConst v)\n{\n    if (JS_VALUE_HAS_REF_COUNT(v)) {\n        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);\n        p->ref_count++;\n    }\n    return (JSValue)v;\n}\n\nJS_BOOL JS_StrictEq(JSContext *ctx, JSValueConst op1, JSValueConst op2);\nJS_BOOL JS_SameValue(JSContext *ctx, JSValueConst op1, JSValueConst op2);\nJS_BOOL JS_SameValueZero(JSContext *ctx, JSValueConst op1, JSValueConst op2);\n\nint JS_ToBool(JSContext *ctx, JSValueConst val); /* return -1 for JS_EXCEPTION */\nint JS_ToInt32(JSContext *ctx, int32_t *pres, JSValueConst val);\nstatic inline int JS_ToUint32(JSContext *ctx, uint32_t *pres, JSValueConst val)\n{\n    return JS_ToInt32(ctx, (int32_t*)pres, val);\n}\nint JS_ToInt64(JSContext *ctx, int64_t *pres, JSValueConst val);\nint JS_ToIndex(JSContext *ctx, uint64_t *plen, JSValueConst val);\nint JS_ToFloat64(JSContext *ctx, double *pres, JSValueConst val);\n/* return an exception if 'val' is a Number */\nint JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val);\n/* same as JS_ToInt64() but allow BigInt */\nint JS_ToInt64Ext(JSContext *ctx, int64_t *pres, JSValueConst val);\n\nJSValue JS_NewStringLen(JSContext *ctx, const char *str1, size_t len1);\nJSValue JS_NewString(JSContext *ctx, const char *str);\nJSValue JS_NewAtomString(JSContext *ctx, const char *str);\nJSValue JS_ToString(JSContext *ctx, JSValueConst val);\nJSValue JS_ToPropertyKey(JSContext *ctx, JSValueConst val);\nconst char *JS_ToCStringLen2(JSContext *ctx, size_t *plen, JSValueConst val1, JS_BOOL cesu8);\nstatic inline const char *JS_ToCStringLen(JSContext *ctx, size_t *plen, JSValueConst val1)\n{\n    return JS_ToCStringLen2(ctx, plen, val1, 0);\n}\nstatic inline const char *JS_ToCString(JSContext *ctx, JSValueConst val1)\n{\n    return JS_ToCStringLen2(ctx, NULL, val1, 0);\n}\nvoid JS_FreeCString(JSContext *ctx, const char *ptr);\n\nJSValue JS_NewObjectProtoClass(JSContext *ctx, JSValueConst proto, JSClassID class_id);\nJSValue JS_NewObjectClass(JSContext *ctx, int class_id);\nJSValue JS_NewObjectProto(JSContext *ctx, JSValueConst proto);\nJSValue JS_NewObject(JSContext *ctx);\n\nJS_BOOL JS_IsFunction(JSContext* ctx, JSValueConst val);\nJS_BOOL JS_IsConstructor(JSContext* ctx, JSValueConst val);\nJS_BOOL JS_SetConstructorBit(JSContext *ctx, JSValueConst func_obj, JS_BOOL val);\n\nJSValue JS_NewArray(JSContext *ctx);\nint JS_IsArray(JSContext *ctx, JSValueConst val);\n\nJSValue JS_NewDate(JSContext *ctx, double epoch_ms);\n\nJSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,\n                               JSAtom prop, JSValueConst receiver,\n                               JS_BOOL throw_ref_error);\nstatic js_force_inline JSValue JS_GetProperty(JSContext *ctx, JSValueConst this_obj,\n                                              JSAtom prop)\n{\n    return JS_GetPropertyInternal(ctx, this_obj, prop, this_obj, 0);\n}\nJSValue JS_GetPropertyStr(JSContext *ctx, JSValueConst this_obj,\n                          const char *prop);\nJSValue JS_GetPropertyUint32(JSContext *ctx, JSValueConst this_obj,\n                             uint32_t idx);\n\nint JS_SetPropertyInternal(JSContext *ctx, JSValueConst obj,\n                           JSAtom prop, JSValue val, JSValueConst this_obj,\n                           int flags);\nstatic inline int JS_SetProperty(JSContext *ctx, JSValueConst this_obj,\n                                 JSAtom prop, JSValue val)\n{\n    return JS_SetPropertyInternal(ctx, this_obj, prop, val, this_obj, JS_PROP_THROW);\n}\nint JS_SetPropertyUint32(JSContext *ctx, JSValueConst this_obj,\n                         uint32_t idx, JSValue val);\nint JS_SetPropertyInt64(JSContext *ctx, JSValueConst this_obj,\n                        int64_t idx, JSValue val);\nint JS_SetPropertyStr(JSContext *ctx, JSValueConst this_obj,\n                      const char *prop, JSValue val);\nint JS_HasProperty(JSContext *ctx, JSValueConst this_obj, JSAtom prop);\nint JS_IsExtensible(JSContext *ctx, JSValueConst obj);\nint JS_PreventExtensions(JSContext *ctx, JSValueConst obj);\nint JS_DeleteProperty(JSContext *ctx, JSValueConst obj, JSAtom prop, int flags);\nint JS_SetPrototype(JSContext *ctx, JSValueConst obj, JSValueConst proto_val);\nJSValue JS_GetPrototype(JSContext *ctx, JSValueConst val);\n\n#define JS_GPN_STRING_MASK  (1 << 0)\n#define JS_GPN_SYMBOL_MASK  (1 << 1)\n#define JS_GPN_PRIVATE_MASK (1 << 2)\n/* only include the enumerable properties */\n#define JS_GPN_ENUM_ONLY    (1 << 4)\n/* set theJSPropertyEnum.is_enumerable field */\n#define JS_GPN_SET_ENUM     (1 << 5)\n\nint JS_GetOwnPropertyNames(JSContext *ctx, JSPropertyEnum **ptab,\n                           uint32_t *plen, JSValueConst obj, int flags);\nint JS_GetOwnProperty(JSContext *ctx, JSPropertyDescriptor *desc,\n                      JSValueConst obj, JSAtom prop);\n\nJSValue JS_Call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,\n                int argc, JSValueConst *argv);\nJSValue JS_Invoke(JSContext *ctx, JSValueConst this_val, JSAtom atom,\n                  int argc, JSValueConst *argv);\nJSValue JS_CallConstructor(JSContext *ctx, JSValueConst func_obj,\n                           int argc, JSValueConst *argv);\nJSValue JS_CallConstructor2(JSContext *ctx, JSValueConst func_obj,\n                            JSValueConst new_target,\n                            int argc, JSValueConst *argv);\nJS_BOOL JS_DetectModule(const char *input, size_t input_len);\n/* 'input' must be zero terminated i.e. input[input_len] = '\\0'. */\nJSValue JS_Eval(JSContext *ctx, const char *input, size_t input_len,\n                const char *filename, int eval_flags);\n/* same as JS_Eval() but with an explicit 'this_obj' parameter */\nJSValue JS_EvalThis(JSContext *ctx, JSValueConst this_obj,\n                    const char *input, size_t input_len,\n                    const char *filename, int eval_flags);\nJSValue JS_GetGlobalObject(JSContext *ctx);\nint JS_IsInstanceOf(JSContext *ctx, JSValueConst val, JSValueConst obj);\nint JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,\n                      JSAtom prop, JSValueConst val,\n                      JSValueConst getter, JSValueConst setter, int flags);\nint JS_DefinePropertyValue(JSContext *ctx, JSValueConst this_obj,\n                           JSAtom prop, JSValue val, int flags);\nint JS_DefinePropertyValueUint32(JSContext *ctx, JSValueConst this_obj,\n                                 uint32_t idx, JSValue val, int flags);\nint JS_DefinePropertyValueStr(JSContext *ctx, JSValueConst this_obj,\n                              const char *prop, JSValue val, int flags);\nint JS_DefinePropertyGetSet(JSContext *ctx, JSValueConst this_obj,\n                            JSAtom prop, JSValue getter, JSValue setter,\n                            int flags);\nvoid JS_SetOpaque(JSValue obj, void *opaque);\nvoid *JS_GetOpaque(JSValueConst obj, JSClassID class_id);\nvoid *JS_GetOpaque2(JSContext *ctx, JSValueConst obj, JSClassID class_id);\n\n/* 'buf' must be zero terminated i.e. buf[buf_len] = '\\0'. */\nJSValue JS_ParseJSON(JSContext *ctx, const char *buf, size_t buf_len,\n                     const char *filename);\n#define JS_PARSE_JSON_EXT (1 << 0) /* allow extended JSON */\nJSValue JS_ParseJSON2(JSContext *ctx, const char *buf, size_t buf_len,\n                      const char *filename, int flags);\nJSValue JS_JSONStringify(JSContext *ctx, JSValueConst obj,\n                         JSValueConst replacer, JSValueConst space0);\n\ntypedef void JSFreeArrayBufferDataFunc(JSRuntime *rt, void *opaque, void *ptr);\nJSValue JS_NewArrayBuffer(JSContext *ctx, uint8_t *buf, size_t len,\n                          JSFreeArrayBufferDataFunc *free_func, void *opaque,\n                          JS_BOOL is_shared);\nJSValue JS_NewArrayBufferCopy(JSContext *ctx, const uint8_t *buf, size_t len);\nvoid JS_DetachArrayBuffer(JSContext *ctx, JSValueConst obj);\nuint8_t *JS_GetArrayBuffer(JSContext *ctx, size_t *psize, JSValueConst obj);\n\ntypedef enum JSTypedArrayEnum {\n    JS_TYPED_ARRAY_UINT8C = 0,\n    JS_TYPED_ARRAY_INT8,\n    JS_TYPED_ARRAY_UINT8,\n    JS_TYPED_ARRAY_INT16,\n    JS_TYPED_ARRAY_UINT16,\n    JS_TYPED_ARRAY_INT32,\n    JS_TYPED_ARRAY_UINT32,\n    JS_TYPED_ARRAY_BIG_INT64,\n    JS_TYPED_ARRAY_BIG_UINT64,\n    JS_TYPED_ARRAY_FLOAT32,\n    JS_TYPED_ARRAY_FLOAT64,\n} JSTypedArrayEnum;\n\nJSValue JS_NewTypedArray(JSContext *ctx, int argc, JSValueConst *argv,\n                         JSTypedArrayEnum array_type);\nJSValue JS_GetTypedArrayBuffer(JSContext *ctx, JSValueConst obj,\n                               size_t *pbyte_offset,\n                               size_t *pbyte_length,\n                               size_t *pbytes_per_element);\ntypedef struct {\n    void *(*sab_alloc)(void *opaque, size_t size);\n    void (*sab_free)(void *opaque, void *ptr);\n    void (*sab_dup)(void *opaque, void *ptr);\n    void *sab_opaque;\n} JSSharedArrayBufferFunctions;\nvoid JS_SetSharedArrayBufferFunctions(JSRuntime *rt,\n                                      const JSSharedArrayBufferFunctions *sf);\n\ntypedef enum JSPromiseStateEnum {\n    JS_PROMISE_PENDING,\n    JS_PROMISE_FULFILLED,\n    JS_PROMISE_REJECTED,\n} JSPromiseStateEnum;\n\nJSValue JS_NewPromiseCapability(JSContext *ctx, JSValue *resolving_funcs);\nJSPromiseStateEnum JS_PromiseState(JSContext *ctx, JSValue promise);\nJSValue JS_PromiseResult(JSContext *ctx, JSValue promise);\n\n/* is_handled = TRUE means that the rejection is handled */\ntypedef void JSHostPromiseRejectionTracker(JSContext *ctx, JSValueConst promise,\n                                           JSValueConst reason,\n                                           JS_BOOL is_handled, void *opaque);\nvoid JS_SetHostPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);\n\n/* return != 0 if the JS code needs to be interrupted */\ntypedef int JSInterruptHandler(JSRuntime *rt, void *opaque);\nvoid JS_SetInterruptHandler(JSRuntime *rt, JSInterruptHandler *cb, void *opaque);\n/* if can_block is TRUE, Atomics.wait() can be used */\nvoid JS_SetCanBlock(JSRuntime *rt, JS_BOOL can_block);\n/* set the [IsHTMLDDA] internal slot */\nvoid JS_SetIsHTMLDDA(JSContext *ctx, JSValueConst obj);\n\ntypedef struct JSModuleDef JSModuleDef;\n\n/* return the module specifier (allocated with js_malloc()) or NULL if\n   exception */\ntypedef char *JSModuleNormalizeFunc(JSContext *ctx,\n                                    const char *module_base_name,\n                                    const char *module_name, void *opaque);\ntypedef JSModuleDef *JSModuleLoaderFunc(JSContext *ctx,\n                                        const char *module_name, void *opaque);\n\n/* module_normalize = NULL is allowed and invokes the default module\n   filename normalizer */\nvoid JS_SetModuleLoaderFunc(JSRuntime *rt,\n                            JSModuleNormalizeFunc *module_normalize,\n                            JSModuleLoaderFunc *module_loader, void *opaque);\n/* return the import.meta object of a module */\nJSValue JS_GetImportMeta(JSContext *ctx, JSModuleDef *m);\nJSAtom JS_GetModuleName(JSContext *ctx, JSModuleDef *m);\nJSValue JS_GetModuleNamespace(JSContext *ctx, JSModuleDef *m);\n\n/* JS Job support */\n\ntypedef JSValue JSJobFunc(JSContext *ctx, int argc, JSValueConst *argv);\nint JS_EnqueueJob(JSContext *ctx, JSJobFunc *job_func, int argc, JSValueConst *argv);\n\nJS_BOOL JS_IsJobPending(JSRuntime *rt);\nint JS_ExecutePendingJob(JSRuntime *rt, JSContext **pctx);\n\n/* Object Writer/Reader (currently only used to handle precompiled code) */\n#define JS_WRITE_OBJ_BYTECODE  (1 << 0) /* allow function/module */\n#define JS_WRITE_OBJ_BSWAP     (1 << 1) /* byte swapped output */\n#define JS_WRITE_OBJ_SAB       (1 << 2) /* allow SharedArrayBuffer */\n#define JS_WRITE_OBJ_REFERENCE (1 << 3) /* allow object references to\n                                           encode arbitrary object\n                                           graph */\nuint8_t *JS_WriteObject(JSContext *ctx, size_t *psize, JSValueConst obj,\n                        int flags);\nuint8_t *JS_WriteObject2(JSContext *ctx, size_t *psize, JSValueConst obj,\n                         int flags, uint8_t ***psab_tab, size_t *psab_tab_len);\n\n#define JS_READ_OBJ_BYTECODE  (1 << 0) /* allow function/module */\n#define JS_READ_OBJ_ROM_DATA  (1 << 1) /* avoid duplicating 'buf' data */\n#define JS_READ_OBJ_SAB       (1 << 2) /* allow SharedArrayBuffer */\n#define JS_READ_OBJ_REFERENCE (1 << 3) /* allow object references */\nJSValue JS_ReadObject(JSContext *ctx, const uint8_t *buf, size_t buf_len,\n                      int flags);\n/* instantiate and evaluate a bytecode function. Only used when\n   reading a script or module with JS_ReadObject() */\nJSValue JS_EvalFunction(JSContext *ctx, JSValue fun_obj);\n/* load the dependencies of the module 'obj'. Useful when JS_ReadObject()\n   returns a module. */\nint JS_ResolveModule(JSContext *ctx, JSValueConst obj);\n\n/* only exported for os.Worker() */\nJSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels);\n/* only exported for os.Worker() */\nJSValue JS_LoadModule(JSContext *ctx, const char *basename,\n                      const char *filename);\n\n/* C function definition */\ntypedef enum JSCFunctionEnum {  /* XXX: should rename for namespace isolation */\n    JS_CFUNC_generic,\n    JS_CFUNC_generic_magic,\n    JS_CFUNC_constructor,\n    JS_CFUNC_constructor_magic,\n    JS_CFUNC_constructor_or_func,\n    JS_CFUNC_constructor_or_func_magic,\n    JS_CFUNC_f_f,\n    JS_CFUNC_f_f_f,\n    JS_CFUNC_getter,\n    JS_CFUNC_setter,\n    JS_CFUNC_getter_magic,\n    JS_CFUNC_setter_magic,\n    JS_CFUNC_iterator_next,\n} JSCFunctionEnum;\n\ntypedef union JSCFunctionType {\n    JSCFunction *generic;\n    JSValue (*generic_magic)(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic);\n    JSCFunction *constructor;\n    JSValue (*constructor_magic)(JSContext *ctx, JSValueConst new_target, int argc, JSValueConst *argv, int magic);\n    JSCFunction *constructor_or_func;\n    double (*f_f)(double);\n    double (*f_f_f)(double, double);\n    JSValue (*getter)(JSContext *ctx, JSValueConst this_val);\n    JSValue (*setter)(JSContext *ctx, JSValueConst this_val, JSValueConst val);\n    JSValue (*getter_magic)(JSContext *ctx, JSValueConst this_val, int magic);\n    JSValue (*setter_magic)(JSContext *ctx, JSValueConst this_val, JSValueConst val, int magic);\n    JSValue (*iterator_next)(JSContext *ctx, JSValueConst this_val,\n                             int argc, JSValueConst *argv, int *pdone, int magic);\n} JSCFunctionType;\n\nJSValue JS_NewCFunction2(JSContext *ctx, JSCFunction *func,\n                         const char *name,\n                         int length, JSCFunctionEnum cproto, int magic);\nJSValue JS_NewCFunctionData(JSContext *ctx, JSCFunctionData *func,\n                            int length, int magic, int data_len,\n                            JSValueConst *data);\n\nstatic inline JSValue JS_NewCFunction(JSContext *ctx, JSCFunction *func, const char *name,\n                                      int length)\n{\n    return JS_NewCFunction2(ctx, func, name, length, JS_CFUNC_generic, 0);\n}\n\nstatic inline JSValue JS_NewCFunctionMagic(JSContext *ctx, JSCFunctionMagic *func,\n                                           const char *name,\n                                           int length, JSCFunctionEnum cproto, int magic)\n{\n    return JS_NewCFunction2(ctx, (JSCFunction *)func, name, length, cproto, magic);\n}\nvoid JS_SetConstructor(JSContext *ctx, JSValueConst func_obj,\n                       JSValueConst proto);\n\n/* C property definition */\n\ntypedef struct JSCFunctionListEntry {\n    const char *name;\n    uint8_t prop_flags;\n    uint8_t def_type;\n    int16_t magic;\n    union {\n        struct {\n            uint8_t length; /* XXX: should move outside union */\n            uint8_t cproto; /* XXX: should move outside union */\n            JSCFunctionType cfunc;\n        } func;\n        struct {\n            JSCFunctionType get;\n            JSCFunctionType set;\n        } getset;\n        struct {\n            const char *name;\n            int base;\n        } alias;\n        struct {\n            const struct JSCFunctionListEntry *tab;\n            int len;\n        } prop_list;\n        const char *str;\n        int32_t i32;\n        int64_t i64;\n        double f64;\n    } u;\n} JSCFunctionListEntry;\n\n#define JS_DEF_CFUNC          0\n#define JS_DEF_CGETSET        1\n#define JS_DEF_CGETSET_MAGIC  2\n#define JS_DEF_PROP_STRING    3\n#define JS_DEF_PROP_INT32     4\n#define JS_DEF_PROP_INT64     5\n#define JS_DEF_PROP_DOUBLE    6\n#define JS_DEF_PROP_UNDEFINED 7\n#define JS_DEF_OBJECT         8\n#define JS_DEF_ALIAS          9\n\n/* Note: c++ does not like nested designators */\n#define JS_CFUNC_DEF(name, length, func1) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, 0, .u = { .func = { length, JS_CFUNC_generic, { .generic = func1 } } } }\n#define JS_CFUNC_MAGIC_DEF(name, length, func1, magic) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, magic, .u = { .func = { length, JS_CFUNC_generic_magic, { .generic_magic = func1 } } } }\n#define JS_CFUNC_SPECIAL_DEF(name, length, cproto, func1) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, 0, .u = { .func = { length, JS_CFUNC_ ## cproto, { .cproto = func1 } } } }\n#define JS_ITERATOR_NEXT_DEF(name, length, func1, magic) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, magic, .u = { .func = { length, JS_CFUNC_iterator_next, { .iterator_next = func1 } } } }\n#define JS_CGETSET_DEF(name, fgetter, fsetter) { name, JS_PROP_CONFIGURABLE, JS_DEF_CGETSET, 0, .u = { .getset = { .get = { .getter = fgetter }, .set = { .setter = fsetter } } } }\n#define JS_CGETSET_MAGIC_DEF(name, fgetter, fsetter, magic) { name, JS_PROP_CONFIGURABLE, JS_DEF_CGETSET_MAGIC, magic, .u = { .getset = { .get = { .getter_magic = fgetter }, .set = { .setter_magic = fsetter } } } }\n#define JS_PROP_STRING_DEF(name, cstr, prop_flags) { name, prop_flags, JS_DEF_PROP_STRING, 0, .u = { .str = cstr } }\n#define JS_PROP_INT32_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_INT32, 0, .u = { .i32 = val } }\n#define JS_PROP_INT64_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_INT64, 0, .u = { .i64 = val } }\n#define JS_PROP_DOUBLE_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_DOUBLE, 0, .u = { .f64 = val } }\n#define JS_PROP_UNDEFINED_DEF(name, prop_flags) { name, prop_flags, JS_DEF_PROP_UNDEFINED, 0, .u = { .i32 = 0 } }\n#define JS_OBJECT_DEF(name, tab, len, prop_flags) { name, prop_flags, JS_DEF_OBJECT, 0, .u = { .prop_list = { tab, len } } }\n#define JS_ALIAS_DEF(name, from) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_ALIAS, 0, .u = { .alias = { from, -1 } } }\n#define JS_ALIAS_BASE_DEF(name, from, base) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_ALIAS, 0, .u = { .alias = { from, base } } }\n\nvoid JS_SetPropertyFunctionList(JSContext *ctx, JSValueConst obj,\n                                const JSCFunctionListEntry *tab,\n                                int len);\n\n/* C module definition */\n\ntypedef int JSModuleInitFunc(JSContext *ctx, JSModuleDef *m);\n\nJSModuleDef *JS_NewCModule(JSContext *ctx, const char *name_str,\n                           JSModuleInitFunc *func);\n/* can only be called before the module is instantiated */\nint JS_AddModuleExport(JSContext *ctx, JSModuleDef *m, const char *name_str);\nint JS_AddModuleExportList(JSContext *ctx, JSModuleDef *m,\n                           const JSCFunctionListEntry *tab, int len);\n/* can only be called after the module is instantiated */\nint JS_SetModuleExport(JSContext *ctx, JSModuleDef *m, const char *export_name,\n                       JSValue val);\nint JS_SetModuleExportList(JSContext *ctx, JSModuleDef *m,\n                           const JSCFunctionListEntry *tab, int len);\n\n#undef js_unlikely\n#undef js_force_inline\n\n#ifdef __cplusplus\n} /* extern \"C\" { */\n#endif\n\n#endif /* QUICKJS_H */\n"
        },
        {
          "name": "readme.txt",
          "type": "blob",
          "size": 0.064453125,
          "content": "The main documentation is in doc/quickjs.pdf or doc/quickjs.html.\n"
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 3.259765625,
          "content": "#!/bin/sh\n# Release the QuickJS source code\n\nset -e\n\nversion=`cat VERSION`\n\nif [ \"$1\" = \"-h\" ] ; then\n    echo \"release.sh [release_list]\"\n    echo \"\"\n    echo \"release_list: extras binary win_binary quickjs\"\n\n    exit 1\nfi\n\nrelease_list=\"extras binary win_binary quickjs\"\n\nif [ \"$1\" != \"\" ] ; then\n    release_list=\"$1\"\nfi\n\n#################################################\"\n# extras\n\nif echo $release_list | grep -w -q extras ; then\n\nd=\"quickjs-${version}\"\nname=\"quickjs-extras-${version}\"\noutdir=\"/tmp/${d}\"\n\nrm -rf $outdir\nmkdir -p $outdir $outdir/unicode $outdir/tests\n\ncp unicode/* $outdir/unicode\ncp -a tests/bench-v8 $outdir/tests\n\n( cd /tmp && tar Jcvf /tmp/${name}.tar.xz ${d} )\n\nfi\n\n#################################################\"\n# Windows binary release\n\nif echo $release_list | grep -w -q win_binary ; then\n\n# win64\n\ndlldir=/usr/x86_64-w64-mingw32/sys-root/mingw/bin\ncross_prefix=\"x86_64-w64-mingw32-\"\nd=\"quickjs-win-x86_64-${version}\"\noutdir=\"/tmp/${d}\"\n\nrm -rf $outdir\nmkdir -p $outdir\n\nmake CONFIG_WIN32=y qjs.exe\ncp qjs.exe $outdir\n${cross_prefix}strip $outdir/qjs.exe\ncp $dlldir/libwinpthread-1.dll $outdir\n\n( cd /tmp/$d && rm -f ../${d}.zip && zip -r ../${d}.zip . )\n\nmake CONFIG_WIN32=y clean\n\n# win32\n\ndlldir=/usr/i686-w64-mingw32/sys-root/mingw/bin\ncross_prefix=\"i686-w64-mingw32-\"\nd=\"quickjs-win-i686-${version}\"\noutdir=\"/tmp/${d}\"\n\nrm -rf $outdir\nmkdir -p $outdir\n\nmake clean\nmake CONFIG_WIN32=y clean\n\nmake CONFIG_WIN32=y CONFIG_M32=y qjs.exe\ncp qjs.exe $outdir\n${cross_prefix}strip $outdir/qjs.exe\ncp $dlldir/libwinpthread-1.dll $outdir\n\n( cd /tmp/$d && rm -f ../${d}.zip && zip -r ../${d}.zip . )\n\nfi\n\n#################################################\"\n# Linux binary release\n\nif echo $release_list | grep -w -q binary ; then\n\nmake clean\nmake CONFIG_WIN32=y clean\nmake -j4 qjs run-test262\nmake -j4 CONFIG_M32=y qjs32 run-test262-32\nstrip qjs run-test262 qjs32 run-test262-32\n\nd=\"quickjs-linux-x86_64-${version}\"\noutdir=\"/tmp/${d}\"\n\nrm -rf $outdir\nmkdir -p $outdir\n\ncp qjs run-test262 $outdir\n\n( cd /tmp/$d && rm -f ../${d}.zip && zip -r ../${d}.zip . )\n\nd=\"quickjs-linux-i686-${version}\"\noutdir=\"/tmp/${d}\"\n\nrm -rf $outdir\nmkdir -p $outdir\n\ncp qjs32 $outdir/qjs\ncp run-test262-32 $outdir/run-test262\n\n( cd /tmp/$d && rm -f ../${d}.zip && zip -r ../${d}.zip . )\n\nfi\n\n#################################################\"\n# quickjs\n\nif echo $release_list | grep -w -q quickjs ; then\n\nmake build_doc\n\nd=\"quickjs-${version}\"\noutdir=\"/tmp/${d}\"\n\nrm -rf $outdir\nmkdir -p $outdir $outdir/doc $outdir/tests $outdir/examples\n\ncp Makefile VERSION TODO Changelog readme.txt LICENSE \\\n   release.sh unicode_download.sh \\\n   qjs.c qjsc.c qjscalc.js repl.js \\\n   quickjs.c quickjs.h quickjs-atom.h \\\n   quickjs-libc.c quickjs-libc.h quickjs-opcode.h \\\n   cutils.c cutils.h list.h \\\n   libregexp.c libregexp.h libregexp-opcode.h \\\n   libunicode.c libunicode.h libunicode-table.h \\\n   libbf.c libbf.h \\\n   unicode_gen.c unicode_gen_def.h \\\n   run-test262.c test262o.conf test262.conf \\\n   test262o_errors.txt test262_errors.txt \\\n   $outdir\n\ncp tests/*.js tests/*.patch tests/bjson.c $outdir/tests\n\ncp examples/*.js examples/*.c $outdir/examples\n\ncp doc/quickjs.texi doc/quickjs.pdf doc/quickjs.html \\\n   doc/jsbignum.texi doc/jsbignum.html doc/jsbignum.pdf \\\n   $outdir/doc\n\n( cd /tmp && tar Jcvf /tmp/${d}.tar.xz ${d} )\n\nfi\n"
        },
        {
          "name": "repl.js",
          "type": "blob",
          "size": 48.6630859375,
          "content": "/*\n * QuickJS Read Eval Print Loop\n *\n * Copyright (c) 2017-2020 Fabrice Bellard\n * Copyright (c) 2017-2020 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\"use strip\";\n\nimport * as std from \"std\";\nimport * as os from \"os\";\n\n(function(g) {\n    /* add 'os' and 'std' bindings */\n    g.os = os;\n    g.std = std;\n\n    /* close global objects */\n    var Object = g.Object;\n    var String = g.String;\n    var Array = g.Array;\n    var Date = g.Date;\n    var Math = g.Math;\n    var isFinite = g.isFinite;\n    var parseFloat = g.parseFloat;\n\n    /* XXX: use preprocessor ? */\n    var config_numcalc = (typeof os.open === \"undefined\");\n    var has_jscalc = (typeof Fraction === \"function\");\n    var has_bignum = (typeof BigFloat === \"function\");\n\n    var colors = {\n        none:    \"\\x1b[0m\",\n        black:   \"\\x1b[30m\",\n        red:     \"\\x1b[31m\",\n        green:   \"\\x1b[32m\",\n        yellow:  \"\\x1b[33m\",\n        blue:    \"\\x1b[34m\",\n        magenta: \"\\x1b[35m\",\n        cyan:    \"\\x1b[36m\",\n        white:   \"\\x1b[37m\",\n        gray:    \"\\x1b[30;1m\",\n        grey:    \"\\x1b[30;1m\",\n        bright_red:     \"\\x1b[31;1m\",\n        bright_green:   \"\\x1b[32;1m\",\n        bright_yellow:  \"\\x1b[33;1m\",\n        bright_blue:    \"\\x1b[34;1m\",\n        bright_magenta: \"\\x1b[35;1m\",\n        bright_cyan:    \"\\x1b[36;1m\",\n        bright_white:   \"\\x1b[37;1m\",\n    };\n\n    var styles = {\n        'default':    'bright_green',\n        'comment':    'white',\n        'string':     'bright_cyan',\n        'regex':      'cyan',\n        'number':     'green',\n        'keyword':    'bright_white',\n        'function':   'bright_yellow',\n        'type':       'bright_magenta',\n        'identifier': 'bright_green',\n        'error':      'red',\n        'result':     'bright_white',\n        'error_msg':  'bright_red',\n    };\n\n    var history = [];\n    var clip_board = \"\";\n    var prec;\n    var expBits;\n    var log2_10;\n\n    var pstate = \"\";\n    var prompt = \"\";\n    var plen = 0;\n    var ps1 = \"qjs > \";\n    var ps2 = \"  ... \";\n    var utf8 = true;\n    var show_time = false;\n    var show_colors = true;\n    var eval_start_time;\n    var eval_time = 0;\n\n    var mexpr = \"\";\n    var level = 0;\n    var cmd = \"\";\n    var cursor_pos = 0;\n    var last_cmd = \"\";\n    var last_cursor_pos = 0;\n    var history_index;\n    var this_fun, last_fun;\n    var quote_flag = false;\n\n    var utf8_state = 0;\n    var utf8_val = 0;\n\n    var term_fd;\n    var term_read_buf;\n    var term_width;\n    /* current X position of the cursor in the terminal */\n    var term_cursor_x = 0;\n\n    function termInit() {\n        var tab;\n        term_fd = std.in.fileno();\n\n        /* get the terminal size */\n        term_width = 80;\n        if (os.isatty(term_fd)) {\n            if (os.ttyGetWinSize) {\n                tab = os.ttyGetWinSize(term_fd);\n                if (tab)\n                    term_width = tab[0];\n            }\n            if (os.ttySetRaw) {\n                /* set the TTY to raw mode */\n                os.ttySetRaw(term_fd);\n            }\n        }\n\n        /* install a Ctrl-C signal handler */\n        os.signal(os.SIGINT, sigint_handler);\n\n        /* install a handler to read stdin */\n        term_read_buf = new Uint8Array(64);\n        os.setReadHandler(term_fd, term_read_handler);\n    }\n\n    function sigint_handler() {\n        /* send Ctrl-C to readline */\n        handle_byte(3);\n    }\n\n    function term_read_handler() {\n        var l, i;\n        l = os.read(term_fd, term_read_buf.buffer, 0, term_read_buf.length);\n        for(i = 0; i < l; i++)\n            handle_byte(term_read_buf[i]);\n    }\n\n    function handle_byte(c) {\n        if (!utf8) {\n            handle_char(c);\n        } else if (utf8_state !== 0 && (c >= 0x80 && c < 0xc0)) {\n            utf8_val = (utf8_val << 6) | (c & 0x3F);\n            utf8_state--;\n            if (utf8_state === 0) {\n                handle_char(utf8_val);\n            }\n        } else if (c >= 0xc0 && c < 0xf8) {\n            utf8_state = 1 + (c >= 0xe0) + (c >= 0xf0);\n            utf8_val = c & ((1 << (6 - utf8_state)) - 1);\n        } else {\n            utf8_state = 0;\n            handle_char(c);\n        }\n    }\n\n    function is_alpha(c) {\n        return typeof c === \"string\" &&\n            ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n    }\n\n    function is_digit(c) {\n        return typeof c === \"string\" && (c >= '0' && c <= '9');\n    }\n\n    function is_word(c) {\n        return typeof c === \"string\" &&\n            (is_alpha(c) || is_digit(c) || c == '_' || c == '$');\n    }\n\n    function ucs_length(str) {\n        var len, c, i, str_len = str.length;\n        len = 0;\n        /* we never count the trailing surrogate to have the\n         following property: ucs_length(str) =\n         ucs_length(str.substring(0, a)) + ucs_length(str.substring(a,\n         str.length)) for 0 <= a <= str.length */\n        for(i = 0; i < str_len; i++) {\n            c = str.charCodeAt(i);\n            if (c < 0xdc00 || c >= 0xe000)\n                len++;\n        }\n        return len;\n    }\n\n    function is_trailing_surrogate(c)  {\n        var d;\n        if (typeof c !== \"string\")\n            return false;\n        d = c.codePointAt(0); /* can be NaN if empty string */\n        return d >= 0xdc00 && d < 0xe000;\n    }\n\n    function is_balanced(a, b) {\n        switch (a + b) {\n        case \"()\":\n        case \"[]\":\n        case \"{}\":\n            return true;\n        }\n        return false;\n    }\n\n    function print_color_text(str, start, style_names) {\n        var i, j;\n        for (j = start; j < str.length;) {\n            var style = style_names[i = j];\n            while (++j < str.length && style_names[j] == style)\n                continue;\n            std.puts(colors[styles[style] || 'default']);\n            std.puts(str.substring(i, j));\n            std.puts(colors['none']);\n        }\n    }\n\n    function print_csi(n, code) {\n        std.puts(\"\\x1b[\" + ((n != 1) ? n : \"\") + code);\n    }\n\n    /* XXX: handle double-width characters */\n    function move_cursor(delta) {\n        var i, l;\n        if (delta > 0) {\n            while (delta != 0) {\n                if (term_cursor_x == (term_width - 1)) {\n                    std.puts(\"\\n\"); /* translated to CRLF */\n                    term_cursor_x = 0;\n                    delta--;\n                } else {\n                    l = Math.min(term_width - 1 - term_cursor_x, delta);\n                    print_csi(l, \"C\"); /* right */\n                    delta -= l;\n                    term_cursor_x += l;\n                }\n            }\n        } else {\n            delta = -delta;\n            while (delta != 0) {\n                if (term_cursor_x == 0) {\n                    print_csi(1, \"A\"); /* up */\n                    print_csi(term_width - 1, \"C\"); /* right */\n                    delta--;\n                    term_cursor_x = term_width - 1;\n                } else {\n                    l = Math.min(delta, term_cursor_x);\n                    print_csi(l, \"D\"); /* left */\n                    delta -= l;\n                    term_cursor_x -= l;\n                }\n            }\n        }\n    }\n\n    function update() {\n        var i, cmd_len;\n        /* cursor_pos is the position in 16 bit characters inside the\n           UTF-16 string 'cmd' */\n        if (cmd != last_cmd) {\n            if (!show_colors && last_cmd.substring(0, last_cursor_pos) == cmd.substring(0, last_cursor_pos)) {\n                /* optimize common case */\n                std.puts(cmd.substring(last_cursor_pos));\n            } else {\n                /* goto the start of the line */\n                move_cursor(-ucs_length(last_cmd.substring(0, last_cursor_pos)));\n                if (show_colors) {\n                    var str = mexpr ? mexpr + '\\n' + cmd : cmd;\n                    var start = str.length - cmd.length;\n                    var colorstate = colorize_js(str);\n                    print_color_text(str, start, colorstate[2]);\n                } else {\n                    std.puts(cmd);\n                }\n            }\n            term_cursor_x = (term_cursor_x + ucs_length(cmd)) % term_width;\n            if (term_cursor_x == 0) {\n                /* show the cursor on the next line */\n                std.puts(\" \\x08\");\n            }\n            /* remove the trailing characters */\n            std.puts(\"\\x1b[J\");\n            last_cmd = cmd;\n            last_cursor_pos = cmd.length;\n        }\n        if (cursor_pos > last_cursor_pos) {\n            move_cursor(ucs_length(cmd.substring(last_cursor_pos, cursor_pos)));\n        } else if (cursor_pos < last_cursor_pos) {\n            move_cursor(-ucs_length(cmd.substring(cursor_pos, last_cursor_pos)));\n        }\n        last_cursor_pos = cursor_pos;\n        std.out.flush();\n    }\n\n    /* editing commands */\n    function insert(str) {\n        if (str) {\n            cmd = cmd.substring(0, cursor_pos) + str + cmd.substring(cursor_pos);\n            cursor_pos += str.length;\n        }\n    }\n\n    function quoted_insert() {\n        quote_flag = true;\n    }\n\n    function abort() {\n        cmd = \"\";\n        cursor_pos = 0;\n        return -2;\n    }\n\n    function alert() {\n    }\n\n    function beginning_of_line() {\n        cursor_pos = 0;\n    }\n\n    function end_of_line() {\n        cursor_pos = cmd.length;\n    }\n\n    function forward_char() {\n        if (cursor_pos < cmd.length) {\n            cursor_pos++;\n            while (is_trailing_surrogate(cmd.charAt(cursor_pos)))\n                cursor_pos++;\n        }\n    }\n\n    function backward_char() {\n        if (cursor_pos > 0) {\n            cursor_pos--;\n            while (is_trailing_surrogate(cmd.charAt(cursor_pos)))\n                cursor_pos--;\n        }\n    }\n\n    function skip_word_forward(pos) {\n        while (pos < cmd.length && !is_word(cmd.charAt(pos)))\n            pos++;\n        while (pos < cmd.length && is_word(cmd.charAt(pos)))\n            pos++;\n        return pos;\n    }\n\n    function skip_word_backward(pos) {\n        while (pos > 0 && !is_word(cmd.charAt(pos - 1)))\n            pos--;\n        while (pos > 0 && is_word(cmd.charAt(pos - 1)))\n            pos--;\n        return pos;\n    }\n\n    function forward_word() {\n        cursor_pos = skip_word_forward(cursor_pos);\n    }\n\n    function backward_word() {\n        cursor_pos = skip_word_backward(cursor_pos);\n    }\n\n    function accept_line() {\n        std.puts(\"\\n\");\n        history_add(cmd);\n        return -1;\n    }\n\n    function history_add(str) {\n        if (str) {\n            history.push(str);\n        }\n        history_index = history.length;\n    }\n\n    function previous_history() {\n        if (history_index > 0) {\n            if (history_index == history.length) {\n                history.push(cmd);\n            }\n            history_index--;\n            cmd = history[history_index];\n            cursor_pos = cmd.length;\n        }\n    }\n\n    function next_history() {\n        if (history_index < history.length - 1) {\n            history_index++;\n            cmd = history[history_index];\n            cursor_pos = cmd.length;\n        }\n    }\n\n    function history_search(dir) {\n        var pos = cursor_pos;\n        for (var i = 1; i <= history.length; i++) {\n            var index = (history.length + i * dir + history_index) % history.length;\n            if (history[index].substring(0, pos) == cmd.substring(0, pos)) {\n                history_index = index;\n                cmd = history[index];\n                return;\n            }\n        }\n    }\n\n    function history_search_backward() {\n        return history_search(-1);\n    }\n\n    function history_search_forward() {\n        return history_search(1);\n    }\n\n    function delete_char_dir(dir) {\n        var start, end;\n\n        start = cursor_pos;\n        if (dir < 0) {\n            start--;\n            while (is_trailing_surrogate(cmd.charAt(start)))\n                start--;\n        }\n        end = start + 1;\n        while (is_trailing_surrogate(cmd.charAt(end)))\n            end++;\n\n        if (start >= 0 && start < cmd.length) {\n            if (last_fun === kill_region) {\n                kill_region(start, end, dir);\n            } else {\n                cmd = cmd.substring(0, start) + cmd.substring(end);\n                cursor_pos = start;\n            }\n        }\n    }\n\n    function delete_char() {\n        delete_char_dir(1);\n    }\n\n    function control_d() {\n        if (cmd.length == 0) {\n            std.puts(\"\\n\");\n            return -3; /* exit read eval print loop */\n        } else {\n            delete_char_dir(1);\n        }\n    }\n\n    function backward_delete_char() {\n        delete_char_dir(-1);\n    }\n\n    function transpose_chars() {\n        var pos = cursor_pos;\n        if (cmd.length > 1 && pos > 0) {\n            if (pos == cmd.length)\n                pos--;\n            cmd = cmd.substring(0, pos - 1) + cmd.substring(pos, pos + 1) +\n                cmd.substring(pos - 1, pos) + cmd.substring(pos + 1);\n            cursor_pos = pos + 1;\n        }\n    }\n\n    function transpose_words() {\n        var p1 = skip_word_backward(cursor_pos);\n        var p2 = skip_word_forward(p1);\n        var p4 = skip_word_forward(cursor_pos);\n        var p3 = skip_word_backward(p4);\n\n        if (p1 < p2 && p2 <= cursor_pos && cursor_pos <= p3 && p3 < p4) {\n            cmd = cmd.substring(0, p1) + cmd.substring(p3, p4) +\n            cmd.substring(p2, p3) + cmd.substring(p1, p2);\n            cursor_pos = p4;\n        }\n    }\n\n    function upcase_word() {\n        var end = skip_word_forward(cursor_pos);\n        cmd = cmd.substring(0, cursor_pos) +\n            cmd.substring(cursor_pos, end).toUpperCase() +\n            cmd.substring(end);\n    }\n\n    function downcase_word() {\n        var end = skip_word_forward(cursor_pos);\n        cmd = cmd.substring(0, cursor_pos) +\n            cmd.substring(cursor_pos, end).toLowerCase() +\n            cmd.substring(end);\n    }\n\n    function kill_region(start, end, dir) {\n        var s = cmd.substring(start, end);\n        if (last_fun !== kill_region)\n            clip_board = s;\n        else if (dir < 0)\n            clip_board = s + clip_board;\n        else\n            clip_board = clip_board + s;\n\n        cmd = cmd.substring(0, start) + cmd.substring(end);\n        if (cursor_pos > end)\n            cursor_pos -= end - start;\n        else if (cursor_pos > start)\n            cursor_pos = start;\n        this_fun = kill_region;\n    }\n\n    function kill_line() {\n        kill_region(cursor_pos, cmd.length, 1);\n    }\n\n    function backward_kill_line() {\n        kill_region(0, cursor_pos, -1);\n    }\n\n    function kill_word() {\n        kill_region(cursor_pos, skip_word_forward(cursor_pos), 1);\n    }\n\n    function backward_kill_word() {\n        kill_region(skip_word_backward(cursor_pos), cursor_pos, -1);\n    }\n\n    function yank() {\n        insert(clip_board);\n    }\n\n    function control_c() {\n        if (last_fun === control_c) {\n            std.puts(\"\\n\");\n            std.exit(0);\n        } else {\n            std.puts(\"\\n(Press Ctrl-C again to quit)\\n\");\n            readline_print_prompt();\n        }\n    }\n\n    function reset() {\n        cmd = \"\";\n        cursor_pos = 0;\n    }\n\n    function get_context_word(line, pos) {\n        var s = \"\";\n        while (pos > 0 && is_word(line[pos - 1])) {\n            pos--;\n            s = line[pos] + s;\n        }\n        return s;\n    }\n    function get_context_object(line, pos) {\n        var obj, base, c;\n        if (pos <= 0 || \" ~!%^&*(-+={[|:;,<>?/\".indexOf(line[pos - 1]) >= 0)\n            return g;\n        if (pos >= 2 && line[pos - 1] === \".\") {\n            pos--;\n            obj = {};\n            switch (c = line[pos - 1]) {\n            case '\\'':\n            case '\\\"':\n                return \"a\";\n            case ']':\n                return [];\n            case '}':\n                return {};\n            case '/':\n                return / /;\n            default:\n                if (is_word(c)) {\n                    base = get_context_word(line, pos);\n                    if ([\"true\", \"false\", \"null\", \"this\"].includes(base) || !isNaN(+base))\n                        return eval(base);\n                    // Check if `base` is a set of regexp flags\n                    if (pos - base.length >= 3 && line[pos - base.length - 1] === '/')\n                        return new RegExp('', base);\n                    obj = get_context_object(line, pos - base.length);\n                    if (obj === null || obj === void 0)\n                        return obj;\n                    if (obj === g && obj[base] === void 0)\n                        return eval(base);\n                    else\n                        return obj[base];\n                }\n                return {};\n            }\n        }\n        return void 0;\n    }\n\n    function get_completions(line, pos) {\n        var s, obj, ctx_obj, r, i, j, paren;\n\n        s = get_context_word(line, pos);\n        ctx_obj = get_context_object(line, pos - s.length);\n        r = [];\n        /* enumerate properties from object and its prototype chain,\n           add non-numeric regular properties with s as e prefix\n         */\n        for (i = 0, obj = ctx_obj; i < 10 && obj !== null && obj !== void 0; i++) {\n            var props = Object.getOwnPropertyNames(obj);\n            /* add non-numeric regular properties */\n            for (j = 0; j < props.length; j++) {\n                var prop = props[j];\n                if (typeof prop == \"string\" && \"\"+(+prop) != prop && prop.startsWith(s))\n                    r.push(prop);\n            }\n            obj = Object.getPrototypeOf(obj);\n        }\n        if (r.length > 1) {\n            /* sort list with internal names last and remove duplicates */\n            function symcmp(a, b) {\n                if (a[0] != b[0]) {\n                    if (a[0] == '_')\n                        return 1;\n                    if (b[0] == '_')\n                        return -1;\n                }\n                if (a < b)\n                    return -1;\n                if (a > b)\n                    return +1;\n                return 0;\n            }\n            r.sort(symcmp);\n            for(i = j = 1; i < r.length; i++) {\n                if (r[i] != r[i - 1])\n                    r[j++] = r[i];\n            }\n            r.length = j;\n        }\n        /* 'tab' = list of completions, 'pos' = cursor position inside\n           the completions */\n        return { tab: r, pos: s.length, ctx: ctx_obj };\n    }\n\n    function completion() {\n        var tab, res, s, i, j, len, t, max_width, col, n_cols, row, n_rows;\n        res = get_completions(cmd, cursor_pos);\n        tab = res.tab;\n        if (tab.length === 0)\n            return;\n        s = tab[0];\n        len = s.length;\n        /* add the chars which are identical in all the completions */\n        for(i = 1; i < tab.length; i++) {\n            t = tab[i];\n            for(j = 0; j < len; j++) {\n                if (t[j] !== s[j]) {\n                    len = j;\n                    break;\n                }\n            }\n        }\n        for(i = res.pos; i < len; i++) {\n            insert(s[i]);\n        }\n        if (last_fun === completion && tab.length == 1) {\n            /* append parentheses to function names */\n            var m = res.ctx[tab[0]];\n            if (typeof m == \"function\") {\n                insert('(');\n                if (m.length == 0)\n                    insert(')');\n            } else if (typeof m == \"object\") {\n                insert('.');\n            }\n        }\n        /* show the possible completions */\n        if (last_fun === completion && tab.length >= 2) {\n            max_width = 0;\n            for(i = 0; i < tab.length; i++)\n                max_width = Math.max(max_width, tab[i].length);\n            max_width += 2;\n            n_cols = Math.max(1, Math.floor((term_width + 1) / max_width));\n            n_rows = Math.ceil(tab.length / n_cols);\n            std.puts(\"\\n\");\n            /* display the sorted list column-wise */\n            for (row = 0; row < n_rows; row++) {\n                for (col = 0; col < n_cols; col++) {\n                    i = col * n_rows + row;\n                    if (i >= tab.length)\n                        break;\n                    s = tab[i];\n                    if (col != n_cols - 1)\n                        s = s.padEnd(max_width);\n                    std.puts(s);\n                }\n                std.puts(\"\\n\");\n            }\n            /* show a new prompt */\n            readline_print_prompt();\n        }\n    }\n\n    var commands = {        /* command table */\n        \"\\x01\":     beginning_of_line,      /* ^A - bol */\n        \"\\x02\":     backward_char,          /* ^B - backward-char */\n        \"\\x03\":     control_c,              /* ^C - abort */\n        \"\\x04\":     control_d,              /* ^D - delete-char or exit */\n        \"\\x05\":     end_of_line,            /* ^E - eol */\n        \"\\x06\":     forward_char,           /* ^F - forward-char */\n        \"\\x07\":     abort,                  /* ^G - bell */\n        \"\\x08\":     backward_delete_char,   /* ^H - backspace */\n        \"\\x09\":     completion,             /* ^I - history-search-backward */\n        \"\\x0a\":     accept_line,            /* ^J - newline */\n        \"\\x0b\":     kill_line,              /* ^K - delete to end of line */\n        \"\\x0d\":     accept_line,            /* ^M - enter */\n        \"\\x0e\":     next_history,           /* ^N - down */\n        \"\\x10\":     previous_history,       /* ^P - up */\n        \"\\x11\":     quoted_insert,          /* ^Q - quoted-insert */\n        \"\\x12\":     alert,                  /* ^R - reverse-search */\n        \"\\x13\":     alert,                  /* ^S - search */\n        \"\\x14\":     transpose_chars,        /* ^T - transpose */\n        \"\\x18\":     reset,                  /* ^X - cancel */\n        \"\\x19\":     yank,                   /* ^Y - yank */\n        \"\\x1bOA\":   previous_history,       /* ^[OA - up */\n        \"\\x1bOB\":   next_history,           /* ^[OB - down */\n        \"\\x1bOC\":   forward_char,           /* ^[OC - right */\n        \"\\x1bOD\":   backward_char,          /* ^[OD - left */\n        \"\\x1bOF\":   forward_word,           /* ^[OF - ctrl-right */\n        \"\\x1bOH\":   backward_word,          /* ^[OH - ctrl-left */\n        \"\\x1b[1;5C\": forward_word,          /* ^[[1;5C - ctrl-right */\n        \"\\x1b[1;5D\": backward_word,         /* ^[[1;5D - ctrl-left */\n        \"\\x1b[1~\":  beginning_of_line,      /* ^[[1~ - bol */\n        \"\\x1b[3~\":  delete_char,            /* ^[[3~ - delete */\n        \"\\x1b[4~\":  end_of_line,            /* ^[[4~ - eol */\n        \"\\x1b[5~\":  history_search_backward,/* ^[[5~ - page up */\n        \"\\x1b[6~\":  history_search_forward, /* ^[[5~ - page down */\n        \"\\x1b[A\":   previous_history,       /* ^[[A - up */\n        \"\\x1b[B\":   next_history,           /* ^[[B - down */\n        \"\\x1b[C\":   forward_char,           /* ^[[C - right */\n        \"\\x1b[D\":   backward_char,          /* ^[[D - left */\n        \"\\x1b[F\":   end_of_line,            /* ^[[F - end */\n        \"\\x1b[H\":   beginning_of_line,      /* ^[[H - home */\n        \"\\x1b\\x7f\": backward_kill_word,     /* M-C-? - backward_kill_word */\n        \"\\x1bb\":    backward_word,          /* M-b - backward_word */\n        \"\\x1bd\":    kill_word,              /* M-d - kill_word */\n        \"\\x1bf\":    forward_word,           /* M-f - backward_word */\n        \"\\x1bk\":    backward_kill_line,     /* M-k - backward_kill_line */\n        \"\\x1bl\":    downcase_word,          /* M-l - downcase_word */\n        \"\\x1bt\":    transpose_words,        /* M-t - transpose_words */\n        \"\\x1bu\":    upcase_word,            /* M-u - upcase_word */\n        \"\\x7f\":     backward_delete_char,   /* ^? - delete */\n    };\n\n    function dupstr(str, count) {\n        var res = \"\";\n        while (count-- > 0)\n            res += str;\n        return res;\n    }\n\n    var readline_keys;\n    var readline_state;\n    var readline_cb;\n\n    function readline_print_prompt()\n    {\n        std.puts(prompt);\n        term_cursor_x = ucs_length(prompt) % term_width;\n        last_cmd = \"\";\n        last_cursor_pos = 0;\n    }\n\n    function readline_start(defstr, cb) {\n        cmd = defstr || \"\";\n        cursor_pos = cmd.length;\n        history_index = history.length;\n        readline_cb = cb;\n\n        prompt = pstate;\n\n        if (mexpr) {\n            prompt += dupstr(\" \", plen - prompt.length);\n            prompt += ps2;\n        } else {\n            if (show_time) {\n                var t = eval_time / 1000;\n                prompt += t.toFixed(6) + \" \";\n            }\n            plen = prompt.length;\n            prompt += ps1;\n        }\n        readline_print_prompt();\n        update();\n        readline_state = 0;\n    }\n\n    function handle_char(c1) {\n        var c;\n        c = String.fromCodePoint(c1);\n        switch(readline_state) {\n        case 0:\n            if (c == '\\x1b') {  /* '^[' - ESC */\n                readline_keys = c;\n                readline_state = 1;\n            } else {\n                handle_key(c);\n            }\n            break;\n        case 1: /* '^[ */\n            readline_keys += c;\n            if (c == '[') {\n                readline_state = 2;\n            } else if (c == 'O') {\n                readline_state = 3;\n            } else {\n                handle_key(readline_keys);\n                readline_state = 0;\n            }\n            break;\n        case 2: /* '^[[' - CSI */\n            readline_keys += c;\n            if (!(c == ';' || (c >= '0' && c <= '9'))) {\n                handle_key(readline_keys);\n                readline_state = 0;\n            }\n            break;\n        case 3: /* '^[O' - ESC2 */\n            readline_keys += c;\n            handle_key(readline_keys);\n            readline_state = 0;\n            break;\n        }\n    }\n\n    function handle_key(keys) {\n        var fun;\n\n        if (quote_flag) {\n            if (ucs_length(keys) === 1)\n                insert(keys);\n            quote_flag = false;\n        } else if (fun = commands[keys]) {\n            this_fun = fun;\n            switch (fun(keys)) {\n            case -1:\n                readline_cb(cmd);\n                return;\n            case -2:\n                readline_cb(null);\n                return;\n            case -3:\n                /* uninstall a Ctrl-C signal handler */\n                os.signal(os.SIGINT, null);\n                /* uninstall the stdin read handler */\n                os.setReadHandler(term_fd, null);\n                return;\n            }\n            last_fun = this_fun;\n        } else if (ucs_length(keys) === 1 && keys >= ' ') {\n            insert(keys);\n            last_fun = insert;\n        } else {\n            alert(); /* beep! */\n        }\n\n        cursor_pos = (cursor_pos < 0) ? 0 :\n            (cursor_pos > cmd.length) ? cmd.length : cursor_pos;\n        update();\n    }\n\n    var hex_mode = false;\n    var eval_mode = \"std\";\n\n    function number_to_string(a, radix) {\n        var s;\n        if (!isFinite(a)) {\n            /* NaN, Infinite */\n            return a.toString();\n        } else {\n            if (a == 0) {\n                if (1 / a < 0)\n                    s = \"-0\";\n                else\n                    s = \"0\";\n            } else {\n                if (radix == 16 && a === Math.floor(a)) {\n                    var s;\n                    if (a < 0) {\n                        a = -a;\n                        s = \"-\";\n                    } else {\n                        s = \"\";\n                    }\n                    s += \"0x\" + a.toString(16);\n                } else {\n                    s = a.toString();\n                }\n            }\n            return s;\n        }\n    }\n\n    function bigfloat_to_string(a, radix) {\n        var s;\n        if (!BigFloat.isFinite(a)) {\n            /* NaN, Infinite */\n            if (eval_mode !== \"math\") {\n                return \"BigFloat(\" + a.toString() + \")\";\n            } else {\n                return a.toString();\n            }\n        } else {\n            if (a == 0) {\n                if (1 / a < 0)\n                    s = \"-0\";\n                else\n                    s = \"0\";\n            } else {\n                if (radix == 16) {\n                    var s;\n                    if (a < 0) {\n                        a = -a;\n                        s = \"-\";\n                    } else {\n                        s = \"\";\n                    }\n                    s += \"0x\" + a.toString(16);\n                } else {\n                    s = a.toString();\n                }\n            }\n            if (typeof a === \"bigfloat\" && eval_mode !== \"math\") {\n                s += \"l\";\n            } else if (eval_mode !== \"std\" && s.indexOf(\".\") < 0 &&\n                ((radix == 16 && s.indexOf(\"p\") < 0) ||\n                 (radix == 10 && s.indexOf(\"e\") < 0))) {\n                /* add a decimal point so that the floating point type\n                   is visible */\n                s += \".0\";\n            }\n            return s;\n        }\n    }\n\n    function bigint_to_string(a, radix) {\n        var s;\n        if (radix == 16) {\n            var s;\n            if (a < 0) {\n                a = -a;\n                s = \"-\";\n            } else {\n                s = \"\";\n            }\n            s += \"0x\" + a.toString(16);\n        } else {\n            s = a.toString();\n        }\n        if (eval_mode === \"std\")\n            s += \"n\";\n        return s;\n    }\n\n    function print(a) {\n        var stack = [];\n\n        function print_rec(a) {\n            var n, i, keys, key, type, s;\n\n            type = typeof(a);\n            if (type === \"object\") {\n                if (a === null) {\n                    std.puts(a);\n                } else if (stack.indexOf(a) >= 0) {\n                    std.puts(\"[circular]\");\n                } else if (a instanceof Date) {\n                    std.puts(\"Date \" + a.toGMTString().__quote());\n                } else if (has_jscalc && (a instanceof Fraction ||\n                                        a instanceof Complex ||\n                                        a instanceof Mod ||\n                                        a instanceof Polynomial ||\n                                        a instanceof PolyMod ||\n                                        a instanceof RationalFunction ||\n                                        a instanceof Series)) {\n                    std.puts(a.toString());\n                } else {\n                    stack.push(a);\n                    if (Array.isArray(a)) {\n                        n = a.length;\n                        std.puts(\"[ \");\n                        for(i = 0; i < n; i++) {\n                            if (i !== 0)\n                                std.puts(\", \");\n                            if (i in a) {\n                                print_rec(a[i]);\n                            } else {\n                                std.puts(\"<empty>\");\n                            }\n                            if (i > 20) {\n                                std.puts(\"...\");\n                                break;\n                            }\n                        }\n                        std.puts(\" ]\");\n                    } else if (Object.__getClass(a) === \"RegExp\") {\n                        std.puts(a.toString());\n                    } else {\n                        keys = Object.keys(a);\n                        n = keys.length;\n                        std.puts(\"{ \");\n                        for(i = 0; i < n; i++) {\n                            if (i !== 0)\n                                std.puts(\", \");\n                            key = keys[i];\n                            std.puts(key, \": \");\n                            print_rec(a[key]);\n                        }\n                        std.puts(\" }\");\n                    }\n                    stack.pop(a);\n                }\n            } else if (type === \"string\") {\n                s = a.__quote();\n                if (s.length > 79)\n                    s = s.substring(0, 75) + \"...\\\"\";\n                std.puts(s);\n            } else if (type === \"number\") {\n                std.puts(number_to_string(a, hex_mode ? 16 : 10));\n            } else if (type === \"bigint\") {\n                std.puts(bigint_to_string(a, hex_mode ? 16 : 10));\n            } else if (type === \"bigfloat\") {\n                std.puts(bigfloat_to_string(a, hex_mode ? 16 : 10));\n            } else if (type === \"bigdecimal\") {\n                std.puts(a.toString() + \"m\");\n            } else if (type === \"symbol\") {\n                std.puts(String(a));\n            } else if (type === \"function\") {\n                std.puts(\"function \" + a.name + \"()\");\n            } else {\n                std.puts(a);\n            }\n        }\n        print_rec(a);\n    }\n\n    function extract_directive(a) {\n        var pos;\n        if (a[0] !== '\\\\')\n            return \"\";\n        for (pos = 1; pos < a.length; pos++) {\n            if (!is_alpha(a[pos]))\n                break;\n        }\n        return a.substring(1, pos);\n    }\n\n    /* return true if the string after cmd can be evaluted as JS */\n    function handle_directive(cmd, expr) {\n        var param, prec1, expBits1;\n\n        if (cmd === \"h\" || cmd === \"?\" || cmd == \"help\") {\n            help();\n        } else if (cmd === \"load\") {\n            var filename = expr.substring(cmd.length + 1).trim();\n            if (filename.lastIndexOf(\".\") <= filename.lastIndexOf(\"/\"))\n                filename += \".js\";\n            std.loadScript(filename);\n            return false;\n        } else if (cmd === \"x\") {\n            hex_mode = true;\n        } else if (cmd === \"d\") {\n            hex_mode = false;\n        } else if (cmd === \"t\") {\n            show_time = !show_time;\n        } else if (has_bignum && cmd === \"p\") {\n            param = expr.substring(cmd.length + 1).trim().split(\" \");\n            if (param.length === 1 && param[0] === \"\") {\n                std.puts(\"BigFloat precision=\" + prec + \" bits (~\" +\n                          Math.floor(prec / log2_10) +\n                          \" digits), exponent size=\" + expBits + \" bits\\n\");\n            } else if (param[0] === \"f16\") {\n                prec = 11;\n                expBits = 5;\n            } else if (param[0] === \"f32\") {\n                prec = 24;\n                expBits = 8;\n            } else if (param[0] === \"f64\") {\n                prec = 53;\n                expBits = 11;\n            } else if (param[0] === \"f128\") {\n                prec = 113;\n                expBits = 15;\n            } else {\n                prec1 = parseInt(param[0]);\n                if (param.length >= 2)\n                    expBits1 = parseInt(param[1]);\n                else\n                    expBits1 = BigFloatEnv.expBitsMax;\n                if (Number.isNaN(prec1) ||\n                    prec1 < BigFloatEnv.precMin ||\n                    prec1 > BigFloatEnv.precMax) {\n                    std.puts(\"Invalid precision\\n\");\n                    return false;\n                }\n                if (Number.isNaN(expBits1) ||\n                    expBits1 < BigFloatEnv.expBitsMin ||\n                    expBits1 > BigFloatEnv.expBitsMax) {\n                    std.puts(\"Invalid exponent bits\\n\");\n                    return false;\n                }\n                prec = prec1;\n                expBits = expBits1;\n            }\n            return false;\n        } else if (has_bignum && cmd === \"digits\") {\n            param = expr.substring(cmd.length + 1).trim();\n            prec1 = Math.ceil(parseFloat(param) * log2_10);\n            if (prec1 < BigFloatEnv.precMin ||\n                prec1 > BigFloatEnv.precMax) {\n                std.puts(\"Invalid precision\\n\");\n                return false;\n            }\n            prec = prec1;\n            expBits = BigFloatEnv.expBitsMax;\n            return false;\n        } else if (has_bignum && cmd === \"mode\") {\n            param = expr.substring(cmd.length + 1).trim();\n            if (param === \"\") {\n                std.puts(\"Running mode=\" + eval_mode + \"\\n\");\n            } else if (param === \"std\" || param === \"math\") {\n                eval_mode = param;\n            } else {\n                std.puts(\"Invalid mode\\n\");\n            }\n            return false;\n        } else if (cmd === \"clear\") {\n            std.puts(\"\\x1b[H\\x1b[J\");\n        } else if (cmd === \"q\") {\n            std.exit(0);\n        } else if (has_jscalc && cmd === \"a\") {\n            algebraicMode = true;\n        } else if (has_jscalc && cmd === \"n\") {\n            algebraicMode = false;\n        } else {\n            std.puts(\"Unknown directive: \" + cmd + \"\\n\");\n            return false;\n        }\n        return true;\n    }\n\n    if (config_numcalc) {\n        styles = {\n            'default':    'black',\n            'comment':    'white',\n            'string':     'green',\n            'regex':      'cyan',\n            'number':     'green',\n            'keyword':    'blue',\n            'function':   'gray',\n            'type':       'bright_magenta',\n            'identifier': 'yellow',\n            'error':      'bright_red',\n            'result':     'black',\n            'error_msg':  'bright_red',\n        };\n\n        ps1 = \"> \";\n\n        /* called by the GUI */\n        g.execCmd = function (cmd) {\n            switch(cmd) {\n            case \"dec\":\n                hex_mode = false;\n                break;\n            case \"hex\":\n                hex_mode = true;\n                break;\n            case \"num\":\n                algebraicMode = false;\n                break;\n            case \"alg\":\n                algebraicMode = true;\n                break;\n            }\n        }\n    }\n\n    function help() {\n        function sel(n) {\n            return n ? \"*\": \" \";\n        }\n        std.puts(\"\\\\h          this help\\n\" +\n                 \"\\\\x         \" + sel(hex_mode) + \"hexadecimal number display\\n\" +\n                 \"\\\\d         \" + sel(!hex_mode) + \"decimal number display\\n\" +\n                 \"\\\\t         \" + sel(show_time) + \"toggle timing display\\n\" +\n                  \"\\\\clear      clear the terminal\\n\");\n        if (has_jscalc) {\n            std.puts(\"\\\\a         \" + sel(algebraicMode) + \"algebraic mode\\n\" +\n                     \"\\\\n         \" + sel(!algebraicMode) + \"numeric mode\\n\");\n        }\n        if (has_bignum) {\n            std.puts(\"\\\\p [m [e]]  set the BigFloat precision to 'm' bits\\n\" +\n                     \"\\\\digits n   set the BigFloat precision to 'ceil(n*log2(10))' bits\\n\");\n            if (!has_jscalc) {\n                std.puts(\"\\\\mode [std|math] change the running mode (current = \" + eval_mode + \")\\n\");\n            }\n        }\n        if (!config_numcalc) {\n            std.puts(\"\\\\q          exit\\n\");\n        }\n    }\n\n    function cmd_start() {\n        if (!config_numcalc) {\n            if (has_jscalc)\n                std.puts('QJSCalc - Type \"\\\\h\" for help\\n');\n            else\n                std.puts('QuickJS - Type \"\\\\h\" for help\\n');\n        }\n        if (has_bignum) {\n            log2_10 = Math.log(10) / Math.log(2);\n            prec = 113;\n            expBits = 15;\n            if (has_jscalc) {\n                eval_mode = \"math\";\n                /* XXX: numeric mode should always be the default ? */\n                g.algebraicMode = config_numcalc;\n            }\n        }\n\n        cmd_readline_start();\n    }\n\n    function cmd_readline_start() {\n        readline_start(dupstr(\"    \", level), readline_handle_cmd);\n    }\n\n    function readline_handle_cmd(expr) {\n        if (!handle_cmd(expr)) {\n            cmd_readline_start();\n        }\n    }\n\n    /* return true if async termination */\n    function handle_cmd(expr) {\n        var colorstate, cmd;\n\n        if (expr === null) {\n            expr = \"\";\n            return false;\n        }\n        if (expr === \"?\") {\n            help();\n            return false;\n        }\n        cmd = extract_directive(expr);\n        if (cmd.length > 0) {\n            if (!handle_directive(cmd, expr)) {\n                return false;\n            }\n            expr = expr.substring(cmd.length + 1);\n        }\n        if (expr === \"\")\n            return false;\n\n        if (mexpr)\n            expr = mexpr + '\\n' + expr;\n        colorstate = colorize_js(expr);\n        pstate = colorstate[0];\n        level = colorstate[1];\n        if (pstate) {\n            mexpr = expr;\n            return false;\n        }\n        mexpr = \"\";\n\n        if (has_bignum) {\n            /* XXX: async is not supported in this case */\n            BigFloatEnv.setPrec(eval_and_print_start.bind(null, expr, false),\n                                prec, expBits);\n        } else {\n            eval_and_print_start(expr, true);\n        }\n        return true;\n    }\n\n    function eval_and_print_start(expr, is_async) {\n        var result;\n\n        try {\n            if (eval_mode === \"math\")\n                expr = '\"use math\"; void 0;' + expr;\n            eval_start_time = os.now();\n            /* eval as a script */\n            result = std.evalScript(expr, { backtrace_barrier: true, async: is_async });\n            if (is_async) {\n                /* result is a promise */\n                result.then(print_eval_result, print_eval_error);\n            } else {\n                print_eval_result({ value: result });\n            }\n        } catch (error) {\n            print_eval_error(error);\n        }\n    }\n\n    function print_eval_result(result) {\n        result = result.value;\n        eval_time = os.now() - eval_start_time;\n        std.puts(colors[styles.result]);\n        print(result);\n        std.puts(\"\\n\");\n        std.puts(colors.none);\n        /* set the last result */\n        g._ = result;\n\n        handle_cmd_end();\n    }\n\n    function print_eval_error(error) {\n        std.puts(colors[styles.error_msg]);\n        if (error instanceof Error) {\n            console.log(error);\n            if (error.stack) {\n                std.puts(error.stack);\n            }\n        } else {\n            std.puts(\"Throw: \");\n            console.log(error);\n        }\n        std.puts(colors.none);\n\n        handle_cmd_end();\n    }\n\n    function handle_cmd_end() {\n        level = 0;\n        /* run the garbage collector after each command */\n        std.gc();\n        cmd_readline_start();\n    }\n\n    function colorize_js(str) {\n        var i, c, start, n = str.length;\n        var style, state = \"\", level = 0;\n        var primary, can_regex = 1;\n        var r = [];\n\n        function push_state(c) { state += c; }\n        function last_state(c) { return state.substring(state.length - 1); }\n        function pop_state(c) {\n            var c = last_state();\n            state = state.substring(0, state.length - 1);\n            return c;\n        }\n\n        function parse_block_comment() {\n            style = 'comment';\n            push_state('/');\n            for (i++; i < n - 1; i++) {\n                if (str[i] == '*' && str[i + 1] == '/') {\n                    i += 2;\n                    pop_state('/');\n                    break;\n                }\n            }\n        }\n\n        function parse_line_comment() {\n            style = 'comment';\n            for (i++; i < n; i++) {\n                if (str[i] == '\\n') {\n                    break;\n                }\n            }\n        }\n\n        function parse_string(delim) {\n            style = 'string';\n            push_state(delim);\n            while (i < n) {\n                c = str[i++];\n                if (c == '\\n') {\n                    style = 'error';\n                    continue;\n                }\n                if (c == '\\\\') {\n                    if (i >= n)\n                        break;\n                    i++;\n                } else\n                if (c == delim) {\n                    pop_state();\n                    break;\n                }\n            }\n        }\n\n        function parse_regex() {\n            style = 'regex';\n            push_state('/');\n            while (i < n) {\n                c = str[i++];\n                if (c == '\\n') {\n                    style = 'error';\n                    continue;\n                }\n                if (c == '\\\\') {\n                    if (i < n) {\n                        i++;\n                    }\n                    continue;\n                }\n                if (last_state() == '[') {\n                    if (c == ']') {\n                        pop_state()\n                    }\n                    // ECMA 5: ignore '/' inside char classes\n                    continue;\n                }\n                if (c == '[') {\n                    push_state('[');\n                    if (str[i] == '[' || str[i] == ']')\n                        i++;\n                    continue;\n                }\n                if (c == '/') {\n                    pop_state();\n                    while (i < n && is_word(str[i]))\n                        i++;\n                    break;\n                }\n            }\n        }\n\n        function parse_number() {\n            style = 'number';\n            while (i < n && (is_word(str[i]) || (str[i] == '.' && (i == n - 1 || str[i + 1] != '.')))) {\n                i++;\n            }\n        }\n\n        var js_keywords = \"|\" +\n            \"break|case|catch|continue|debugger|default|delete|do|\" +\n            \"else|finally|for|function|if|in|instanceof|new|\" +\n            \"return|switch|this|throw|try|typeof|while|with|\" +\n            \"class|const|enum|import|export|extends|super|\" +\n            \"implements|interface|let|package|private|protected|\" +\n            \"public|static|yield|\" +\n            \"undefined|null|true|false|Infinity|NaN|\" +\n            \"eval|arguments|\" +\n            \"await|\";\n\n        var js_no_regex = \"|this|super|undefined|null|true|false|Infinity|NaN|arguments|\";\n        var js_types = \"|void|var|\";\n\n        function parse_identifier() {\n            can_regex = 1;\n\n            while (i < n && is_word(str[i]))\n                i++;\n\n            var w = '|' + str.substring(start, i) + '|';\n\n            if (js_keywords.indexOf(w) >= 0) {\n                style = 'keyword';\n                if (js_no_regex.indexOf(w) >= 0)\n                    can_regex = 0;\n                return;\n            }\n\n            var i1 = i;\n            while (i1 < n && str[i1] == ' ')\n                i1++;\n\n            if (i1 < n && str[i1] == '(') {\n                style = 'function';\n                return;\n            }\n\n            if (js_types.indexOf(w) >= 0) {\n                style = 'type';\n                return;\n            }\n\n            style = 'identifier';\n            can_regex = 0;\n        }\n\n        function set_style(from, to) {\n            while (r.length < from)\n                r.push('default');\n            while (r.length < to)\n                r.push(style);\n        }\n\n        for (i = 0; i < n;) {\n            style = null;\n            start = i;\n            switch (c = str[i++]) {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n                continue;\n            case '+':\n            case '-':\n                if (i < n && str[i] == c) {\n                    i++;\n                    continue;\n                }\n                can_regex = 1;\n                continue;\n            case '/':\n                if (i < n && str[i] == '*') { // block comment\n                    parse_block_comment();\n                    break;\n                }\n                if (i < n && str[i] == '/') { // line comment\n                    parse_line_comment();\n                    break;\n                }\n                if (can_regex) {\n                    parse_regex();\n                    can_regex = 0;\n                    break;\n                }\n                can_regex = 1;\n                continue;\n            case '\\'':\n            case '\\\"':\n            case '`':\n                parse_string(c);\n                can_regex = 0;\n                break;\n            case '(':\n            case '[':\n            case '{':\n                can_regex = 1;\n                level++;\n                push_state(c);\n                continue;\n            case ')':\n            case ']':\n            case '}':\n                can_regex = 0;\n                if (level > 0 && is_balanced(last_state(), c)) {\n                    level--;\n                    pop_state();\n                    continue;\n                }\n                style = 'error';\n                break;\n            default:\n                if (is_digit(c)) {\n                    parse_number();\n                    can_regex = 0;\n                    break;\n                }\n                if (is_word(c) || c == '$') {\n                    parse_identifier();\n                    break;\n                }\n                can_regex = 1;\n                continue;\n            }\n            if (style)\n                set_style(start, i);\n        }\n        set_style(n, n);\n        return [ state, level, r ];\n    }\n\n    termInit();\n\n    cmd_start();\n\n})(globalThis);\n"
        },
        {
          "name": "run-test262.c",
          "type": "blob",
          "size": 64.986328125,
          "content": "/*\n * ECMA Test 262 Runner for QuickJS\n *\n * Copyright (c) 2017-2021 Fabrice Bellard\n * Copyright (c) 2017-2021 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <string.h>\n#include <assert.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <errno.h>\n#include <time.h>\n#include <dirent.h>\n#include <ftw.h>\n\n#include \"cutils.h\"\n#include \"list.h\"\n#include \"quickjs-libc.h\"\n\n/* enable test262 thread support to test SharedArrayBuffer and Atomics */\n#define CONFIG_AGENT\n\n#define CMD_NAME \"run-test262\"\n\ntypedef struct namelist_t {\n    char **array;\n    int count;\n    int size;\n    unsigned int sorted : 1;\n} namelist_t;\n\nnamelist_t test_list;\nnamelist_t exclude_list;\nnamelist_t exclude_dir_list;\n\nFILE *outfile;\nenum test_mode_t {\n    TEST_DEFAULT_NOSTRICT, /* run tests as nostrict unless test is flagged as strictonly */\n    TEST_DEFAULT_STRICT,   /* run tests as strict unless test is flagged as nostrict */\n    TEST_NOSTRICT,         /* run tests as nostrict, skip strictonly tests */\n    TEST_STRICT,           /* run tests as strict, skip nostrict tests */\n    TEST_ALL,              /* run tests in both strict and nostrict, unless restricted by spec */\n} test_mode = TEST_DEFAULT_NOSTRICT;\nint compact;\nint show_timings;\nint skip_async;\nint skip_module;\nint new_style;\nint dump_memory;\nint stats_count;\nJSMemoryUsage stats_all, stats_avg, stats_min, stats_max;\nchar *stats_min_filename;\nchar *stats_max_filename;\nint verbose;\nchar *harness_dir;\nchar *harness_exclude;\nchar *harness_features;\nchar *harness_skip_features;\nchar *error_filename;\nchar *error_file;\nFILE *error_out;\nchar *report_filename;\nint update_errors;\nint test_count, test_failed, test_index, test_skipped, test_excluded;\nint new_errors, changed_errors, fixed_errors;\nint async_done;\n\nvoid warning(const char *, ...) __attribute__((__format__(__printf__, 1, 2)));\nvoid fatal(int, const char *, ...) __attribute__((__format__(__printf__, 2, 3)));\n\nvoid warning(const char *fmt, ...)\n{\n    va_list ap;\n\n    fflush(stdout);\n    fprintf(stderr, \"%s: \", CMD_NAME);\n    va_start(ap, fmt);\n    vfprintf(stderr, fmt, ap);\n    va_end(ap);\n    fputc('\\n', stderr);\n}\n\nvoid fatal(int errcode, const char *fmt, ...)\n{\n    va_list ap;\n\n    fflush(stdout);\n    fprintf(stderr, \"%s: \", CMD_NAME);\n    va_start(ap, fmt);\n    vfprintf(stderr, fmt, ap);\n    va_end(ap);\n    fputc('\\n', stderr);\n\n    exit(errcode);\n}\n\nvoid perror_exit(int errcode, const char *s)\n{\n    fflush(stdout);\n    fprintf(stderr, \"%s: \", CMD_NAME);\n    perror(s);\n    exit(errcode);\n}\n\nchar *strdup_len(const char *str, int len)\n{\n    char *p = malloc(len + 1);\n    memcpy(p, str, len);\n    p[len] = '\\0';\n    return p;\n}\n\nstatic inline int str_equal(const char *a, const char *b) {\n    return !strcmp(a, b);\n}\n\nchar *str_append(char **pp, const char *sep, const char *str) {\n    char *res, *p;\n    size_t len = 0;\n    p = *pp;\n    if (p) {\n        len = strlen(p) + strlen(sep);\n    }\n    res = malloc(len + strlen(str) + 1);\n    if (p) {\n        strcpy(res, p);\n        strcat(res, sep);\n    }\n    strcpy(res + len, str);\n    free(p);\n    return *pp = res;\n}\n\nchar *str_strip(char *p)\n{\n    size_t len = strlen(p);\n    while (len > 0 && isspace((unsigned char)p[len - 1]))\n        p[--len] = '\\0';\n    while (isspace((unsigned char)*p))\n        p++;\n    return p;\n}\n\nint has_prefix(const char *str, const char *prefix)\n{\n    return !strncmp(str, prefix, strlen(prefix));\n}\n\nchar *skip_prefix(const char *str, const char *prefix)\n{\n    int i;\n    for (i = 0;; i++) {\n        if (prefix[i] == '\\0') {  /* skip the prefix */\n            str += i;\n            break;\n        }\n        if (str[i] != prefix[i])\n            break;\n    }\n    return (char *)str;\n}\n\nchar *get_basename(const char *filename)\n{\n    char *p;\n\n    p = strrchr(filename, '/');\n    if (!p)\n        return NULL;\n    return strdup_len(filename, p - filename);\n}\n\nchar *compose_path(const char *path, const char *name)\n{\n    int path_len, name_len;\n    char *d, *q;\n\n    if (!path || path[0] == '\\0' || *name == '/') {\n        d = strdup(name);\n    } else {\n        path_len = strlen(path);\n        name_len = strlen(name);\n        d = malloc(path_len + 1 + name_len + 1);\n        if (d) {\n            q = d;\n            memcpy(q, path, path_len);\n            q += path_len;\n            if (path[path_len - 1] != '/')\n                *q++ = '/';\n            memcpy(q, name, name_len + 1);\n        }\n    }\n    return d;\n}\n\nint namelist_cmp(const char *a, const char *b)\n{\n    /* compare strings in modified lexicographical order */\n    for (;;) {\n        int ca = (unsigned char)*a++;\n        int cb = (unsigned char)*b++;\n        if (isdigit(ca) && isdigit(cb)) {\n            int na = ca - '0';\n            int nb = cb - '0';\n            while (isdigit(ca = (unsigned char)*a++))\n                na = na * 10 + ca - '0';\n            while (isdigit(cb = (unsigned char)*b++))\n                nb = nb * 10 + cb - '0';\n            if (na < nb)\n                return -1;\n            if (na > nb)\n                return +1;\n        }\n        if (ca < cb)\n            return -1;\n        if (ca > cb)\n            return +1;\n        if (ca == '\\0')\n            return 0;\n    }\n}\n\nint namelist_cmp_indirect(const void *a, const void *b)\n{\n    return namelist_cmp(*(const char **)a, *(const char **)b);\n}\n\nvoid namelist_sort(namelist_t *lp)\n{\n    int i, count;\n    if (lp->count > 1) {\n        qsort(lp->array, lp->count, sizeof(*lp->array), namelist_cmp_indirect);\n        /* remove duplicates */\n        for (count = i = 1; i < lp->count; i++) {\n            if (namelist_cmp(lp->array[count - 1], lp->array[i]) == 0) {\n                free(lp->array[i]);\n            } else {\n                lp->array[count++] = lp->array[i];\n            }\n        }\n        lp->count = count;\n    }\n    lp->sorted = 1;\n}\n\nint namelist_find(namelist_t *lp, const char *name)\n{\n    int a, b, m, cmp;\n\n    if (!lp->sorted) {\n        namelist_sort(lp);\n    }\n    for (a = 0, b = lp->count; a < b;) {\n        m = a + (b - a) / 2;\n        cmp = namelist_cmp(lp->array[m], name);\n        if (cmp < 0)\n            a = m + 1;\n        else if (cmp > 0)\n            b = m;\n        else\n            return m;\n    }\n    return -1;\n}\n\nvoid namelist_add(namelist_t *lp, const char *base, const char *name)\n{\n    char *s;\n\n    s = compose_path(base, name);\n    if (!s)\n        goto fail;\n    if (lp->count == lp->size) {\n        size_t newsize = lp->size + (lp->size >> 1) + 4;\n        char **a = realloc(lp->array, sizeof(lp->array[0]) * newsize);\n        if (!a)\n            goto fail;\n        lp->array = a;\n        lp->size = newsize;\n    }\n    lp->array[lp->count] = s;\n    lp->count++;\n    return;\nfail:\n    fatal(1, \"allocation failure\\n\");\n}\n\nvoid namelist_load(namelist_t *lp, const char *filename)\n{\n    char buf[1024];\n    char *base_name;\n    FILE *f;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror_exit(1, filename);\n    }\n    base_name = get_basename(filename);\n\n    while (fgets(buf, sizeof(buf), f) != NULL) {\n        char *p = str_strip(buf);\n        if (*p == '#' || *p == ';' || *p == '\\0')\n            continue;  /* line comment */\n\n        namelist_add(lp, base_name, p);\n    }\n    free(base_name);\n    fclose(f);\n}\n\nvoid namelist_add_from_error_file(namelist_t *lp, const char *file)\n{\n    const char *p, *p0;\n    char *pp;\n\n    for (p = file; (p = strstr(p, \".js:\")) != NULL; p++) {\n        for (p0 = p; p0 > file && p0[-1] != '\\n'; p0--)\n            continue;\n        pp = strdup_len(p0, p + 3 - p0);\n        namelist_add(lp, NULL, pp);\n        free(pp);\n    }\n}\n\nvoid namelist_free(namelist_t *lp)\n{\n    while (lp->count > 0) {\n        free(lp->array[--lp->count]);\n    }\n    free(lp->array);\n    lp->array = NULL;\n    lp->size = 0;\n}\n\nstatic int add_test_file(const char *filename, const struct stat *ptr, int flag)\n{\n    namelist_t *lp = &test_list;\n    if (has_suffix(filename, \".js\") && !has_suffix(filename, \"_FIXTURE.js\"))\n        namelist_add(lp, NULL, filename);\n    return 0;\n}\n\n/* find js files from the directory tree and sort the list */\nstatic void enumerate_tests(const char *path)\n{\n    namelist_t *lp = &test_list;\n    int start = lp->count;\n    ftw(path, add_test_file, 100);\n    qsort(lp->array + start, lp->count - start, sizeof(*lp->array),\n          namelist_cmp_indirect);\n}\n\nstatic JSValue js_print(JSContext *ctx, JSValueConst this_val,\n                        int argc, JSValueConst *argv)\n{\n    int i;\n    const char *str;\n\n    if (outfile) {\n        for (i = 0; i < argc; i++) {\n            if (i != 0)\n                fputc(' ', outfile);\n            str = JS_ToCString(ctx, argv[i]);\n            if (!str)\n                return JS_EXCEPTION;\n            if (!strcmp(str, \"Test262:AsyncTestComplete\")) {\n                async_done++;\n            } else if (strstart(str, \"Test262:AsyncTestFailure\", NULL)) {\n                async_done = 2; /* force an error */\n            }\n            fputs(str, outfile);\n            JS_FreeCString(ctx, str);\n        }\n        fputc('\\n', outfile);\n    }\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_detachArrayBuffer(JSContext *ctx, JSValue this_val,\n                                    int argc, JSValue *argv)\n{\n    JS_DetachArrayBuffer(ctx, argv[0]);\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_evalScript(JSContext *ctx, JSValue this_val,\n                             int argc, JSValue *argv)\n{\n    const char *str;\n    size_t len;\n    JSValue ret;\n    str = JS_ToCStringLen(ctx, &len, argv[0]);\n    if (!str)\n        return JS_EXCEPTION;\n    ret = JS_Eval(ctx, str, len, \"<evalScript>\", JS_EVAL_TYPE_GLOBAL);\n    JS_FreeCString(ctx, str);\n    return ret;\n}\n\n#ifdef CONFIG_AGENT\n\n#include <pthread.h>\n\ntypedef struct {\n    struct list_head link;\n    pthread_t tid;\n    char *script;\n    JSValue broadcast_func;\n    BOOL broadcast_pending;\n    JSValue broadcast_sab; /* in the main context */\n    uint8_t *broadcast_sab_buf;\n    size_t broadcast_sab_size;\n    int32_t broadcast_val;\n} Test262Agent;\n\ntypedef struct {\n    struct list_head link;\n    char *str;\n} AgentReport;\n\nstatic JSValue add_helpers1(JSContext *ctx);\nstatic void add_helpers(JSContext *ctx);\n\nstatic pthread_mutex_t agent_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t agent_cond = PTHREAD_COND_INITIALIZER;\n/* list of Test262Agent.link */\nstatic struct list_head agent_list = LIST_HEAD_INIT(agent_list);\n\nstatic pthread_mutex_t report_mutex = PTHREAD_MUTEX_INITIALIZER;\n/* list of AgentReport.link */\nstatic struct list_head report_list = LIST_HEAD_INIT(report_list);\n\nstatic void *agent_start(void *arg)\n{\n    Test262Agent *agent = arg;\n    JSRuntime *rt;\n    JSContext *ctx;\n    JSValue ret_val;\n    int ret;\n\n    rt = JS_NewRuntime();\n    if (rt == NULL) {\n        fatal(1, \"JS_NewRuntime failure\");\n    }\n    ctx = JS_NewContext(rt);\n    if (ctx == NULL) {\n        JS_FreeRuntime(rt);\n        fatal(1, \"JS_NewContext failure\");\n    }\n    JS_SetContextOpaque(ctx, agent);\n    JS_SetRuntimeInfo(rt, \"agent\");\n    JS_SetCanBlock(rt, TRUE);\n\n    add_helpers(ctx);\n    ret_val = JS_Eval(ctx, agent->script, strlen(agent->script),\n                      \"<evalScript>\", JS_EVAL_TYPE_GLOBAL);\n    free(agent->script);\n    agent->script = NULL;\n    if (JS_IsException(ret_val))\n        js_std_dump_error(ctx);\n    JS_FreeValue(ctx, ret_val);\n\n    for(;;) {\n        JSContext *ctx1;\n        ret = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);\n        if (ret < 0) {\n            js_std_dump_error(ctx);\n            break;\n        } else if (ret == 0) {\n            if (JS_IsUndefined(agent->broadcast_func)) {\n                break;\n            } else {\n                JSValue args[2];\n\n                pthread_mutex_lock(&agent_mutex);\n                while (!agent->broadcast_pending) {\n                    pthread_cond_wait(&agent_cond, &agent_mutex);\n                }\n\n                agent->broadcast_pending = FALSE;\n                pthread_cond_signal(&agent_cond);\n\n                pthread_mutex_unlock(&agent_mutex);\n\n                args[0] = JS_NewArrayBuffer(ctx, agent->broadcast_sab_buf,\n                                            agent->broadcast_sab_size,\n                                            NULL, NULL, TRUE);\n                args[1] = JS_NewInt32(ctx, agent->broadcast_val);\n                ret_val = JS_Call(ctx, agent->broadcast_func, JS_UNDEFINED,\n                                  2, (JSValueConst *)args);\n                JS_FreeValue(ctx, args[0]);\n                JS_FreeValue(ctx, args[1]);\n                if (JS_IsException(ret_val))\n                    js_std_dump_error(ctx);\n                JS_FreeValue(ctx, ret_val);\n                JS_FreeValue(ctx, agent->broadcast_func);\n                agent->broadcast_func = JS_UNDEFINED;\n            }\n        }\n    }\n    JS_FreeValue(ctx, agent->broadcast_func);\n\n    JS_FreeContext(ctx);\n    JS_FreeRuntime(rt);\n    return NULL;\n}\n\nstatic JSValue js_agent_start(JSContext *ctx, JSValue this_val,\n                              int argc, JSValue *argv)\n{\n    const char *script;\n    Test262Agent *agent;\n    pthread_attr_t attr;\n\n    if (JS_GetContextOpaque(ctx) != NULL)\n        return JS_ThrowTypeError(ctx, \"cannot be called inside an agent\");\n\n    script = JS_ToCString(ctx, argv[0]);\n    if (!script)\n        return JS_EXCEPTION;\n    agent = malloc(sizeof(*agent));\n    memset(agent, 0, sizeof(*agent));\n    agent->broadcast_func = JS_UNDEFINED;\n    agent->broadcast_sab = JS_UNDEFINED;\n    agent->script = strdup(script);\n    JS_FreeCString(ctx, script);\n    list_add_tail(&agent->link, &agent_list);\n    pthread_attr_init(&attr);\n    // musl libc gives threads 80 kb stacks, much smaller than\n    // JS_DEFAULT_STACK_SIZE (256 kb)\n    pthread_attr_setstacksize(&attr, 2 << 20); // 2 MB, glibc default\n    pthread_create(&agent->tid, &attr, agent_start, agent);\n    pthread_attr_destroy(&attr);\n    return JS_UNDEFINED;\n}\n\nstatic void js_agent_free(JSContext *ctx)\n{\n    struct list_head *el, *el1;\n    Test262Agent *agent;\n\n    list_for_each_safe(el, el1, &agent_list) {\n        agent = list_entry(el, Test262Agent, link);\n        pthread_join(agent->tid, NULL);\n        JS_FreeValue(ctx, agent->broadcast_sab);\n        list_del(&agent->link);\n        free(agent);\n    }\n}\n\nstatic JSValue js_agent_leaving(JSContext *ctx, JSValue this_val,\n                                int argc, JSValue *argv)\n{\n    Test262Agent *agent = JS_GetContextOpaque(ctx);\n    if (!agent)\n        return JS_ThrowTypeError(ctx, \"must be called inside an agent\");\n    /* nothing to do */\n    return JS_UNDEFINED;\n}\n\nstatic BOOL is_broadcast_pending(void)\n{\n    struct list_head *el;\n    Test262Agent *agent;\n    list_for_each(el, &agent_list) {\n        agent = list_entry(el, Test262Agent, link);\n        if (agent->broadcast_pending)\n            return TRUE;\n    }\n    return FALSE;\n}\n\nstatic JSValue js_agent_broadcast(JSContext *ctx, JSValue this_val,\n                                  int argc, JSValue *argv)\n{\n    JSValueConst sab = argv[0];\n    struct list_head *el;\n    Test262Agent *agent;\n    uint8_t *buf;\n    size_t buf_size;\n    int32_t val;\n\n    if (JS_GetContextOpaque(ctx) != NULL)\n        return JS_ThrowTypeError(ctx, \"cannot be called inside an agent\");\n\n    buf = JS_GetArrayBuffer(ctx, &buf_size, sab);\n    if (!buf)\n        return JS_EXCEPTION;\n    if (JS_ToInt32(ctx, &val, argv[1]))\n        return JS_EXCEPTION;\n\n    /* broadcast the values and wait until all agents have started\n       calling their callbacks */\n    pthread_mutex_lock(&agent_mutex);\n    list_for_each(el, &agent_list) {\n        agent = list_entry(el, Test262Agent, link);\n        agent->broadcast_pending = TRUE;\n        /* the shared array buffer is used by the thread, so increment\n           its refcount */\n        agent->broadcast_sab = JS_DupValue(ctx, sab);\n        agent->broadcast_sab_buf = buf;\n        agent->broadcast_sab_size = buf_size;\n        agent->broadcast_val = val;\n    }\n    pthread_cond_broadcast(&agent_cond);\n\n    while (is_broadcast_pending()) {\n        pthread_cond_wait(&agent_cond, &agent_mutex);\n    }\n    pthread_mutex_unlock(&agent_mutex);\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_agent_receiveBroadcast(JSContext *ctx, JSValue this_val,\n                                         int argc, JSValue *argv)\n{\n    Test262Agent *agent = JS_GetContextOpaque(ctx);\n    if (!agent)\n        return JS_ThrowTypeError(ctx, \"must be called inside an agent\");\n    if (!JS_IsFunction(ctx, argv[0]))\n        return JS_ThrowTypeError(ctx, \"expecting function\");\n    JS_FreeValue(ctx, agent->broadcast_func);\n    agent->broadcast_func = JS_DupValue(ctx, argv[0]);\n    return JS_UNDEFINED;\n}\n\nstatic JSValue js_agent_sleep(JSContext *ctx, JSValue this_val,\n                              int argc, JSValue *argv)\n{\n    uint32_t duration;\n    if (JS_ToUint32(ctx, &duration, argv[0]))\n        return JS_EXCEPTION;\n    usleep(duration * 1000);\n    return JS_UNDEFINED;\n}\n\nstatic int64_t get_clock_ms(void)\n{\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return (uint64_t)ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);\n}\n\nstatic JSValue js_agent_monotonicNow(JSContext *ctx, JSValue this_val,\n                                     int argc, JSValue *argv)\n{\n    return JS_NewInt64(ctx, get_clock_ms());\n}\n\nstatic JSValue js_agent_getReport(JSContext *ctx, JSValue this_val,\n                                  int argc, JSValue *argv)\n{\n    AgentReport *rep;\n    JSValue ret;\n\n    pthread_mutex_lock(&report_mutex);\n    if (list_empty(&report_list)) {\n        rep = NULL;\n    } else {\n        rep = list_entry(report_list.next, AgentReport, link);\n        list_del(&rep->link);\n    }\n    pthread_mutex_unlock(&report_mutex);\n    if (rep) {\n        ret = JS_NewString(ctx, rep->str);\n        free(rep->str);\n        free(rep);\n    } else {\n        ret = JS_NULL;\n    }\n    return ret;\n}\n\nstatic JSValue js_agent_report(JSContext *ctx, JSValue this_val,\n                               int argc, JSValue *argv)\n{\n    const char *str;\n    AgentReport *rep;\n\n    str = JS_ToCString(ctx, argv[0]);\n    if (!str)\n        return JS_EXCEPTION;\n    rep = malloc(sizeof(*rep));\n    rep->str = strdup(str);\n    JS_FreeCString(ctx, str);\n\n    pthread_mutex_lock(&report_mutex);\n    list_add_tail(&rep->link, &report_list);\n    pthread_mutex_unlock(&report_mutex);\n    return JS_UNDEFINED;\n}\n\nstatic const JSCFunctionListEntry js_agent_funcs[] = {\n    /* only in main */\n    JS_CFUNC_DEF(\"start\", 1, js_agent_start ),\n    JS_CFUNC_DEF(\"getReport\", 0, js_agent_getReport ),\n    JS_CFUNC_DEF(\"broadcast\", 2, js_agent_broadcast ),\n    /* only in agent */\n    JS_CFUNC_DEF(\"report\", 1, js_agent_report ),\n    JS_CFUNC_DEF(\"leaving\", 0, js_agent_leaving ),\n    JS_CFUNC_DEF(\"receiveBroadcast\", 1, js_agent_receiveBroadcast ),\n    /* in both */\n    JS_CFUNC_DEF(\"sleep\", 1, js_agent_sleep ),\n    JS_CFUNC_DEF(\"monotonicNow\", 0, js_agent_monotonicNow ),\n};\n\nstatic JSValue js_new_agent(JSContext *ctx)\n{\n    JSValue agent;\n    agent = JS_NewObject(ctx);\n    JS_SetPropertyFunctionList(ctx, agent, js_agent_funcs,\n                               countof(js_agent_funcs));\n    return agent;\n}\n#endif\n\nstatic JSValue js_createRealm(JSContext *ctx, JSValue this_val,\n                              int argc, JSValue *argv)\n{\n    JSContext *ctx1;\n    JSValue ret;\n\n    ctx1 = JS_NewContext(JS_GetRuntime(ctx));\n    if (!ctx1)\n        return JS_ThrowOutOfMemory(ctx);\n    ret = add_helpers1(ctx1);\n    /* ctx1 has a refcount so it stays alive */\n    JS_FreeContext(ctx1);\n    return ret;\n}\n\nstatic JSValue js_IsHTMLDDA(JSContext *ctx, JSValue this_val,\n                            int argc, JSValue *argv)\n{\n    return JS_NULL;\n}\n\nstatic JSValue add_helpers1(JSContext *ctx)\n{\n    JSValue global_obj;\n    JSValue obj262, obj;\n\n    global_obj = JS_GetGlobalObject(ctx);\n\n    JS_SetPropertyStr(ctx, global_obj, \"print\",\n                      JS_NewCFunction(ctx, js_print, \"print\", 1));\n\n    /* $262 special object used by the tests */\n    obj262 = JS_NewObject(ctx);\n    JS_SetPropertyStr(ctx, obj262, \"detachArrayBuffer\",\n                      JS_NewCFunction(ctx, js_detachArrayBuffer,\n                                      \"detachArrayBuffer\", 1));\n    JS_SetPropertyStr(ctx, obj262, \"evalScript\",\n                      JS_NewCFunction(ctx, js_evalScript,\n                                      \"evalScript\", 1));\n    JS_SetPropertyStr(ctx, obj262, \"codePointRange\",\n                      JS_NewCFunction(ctx, js_string_codePointRange,\n                                      \"codePointRange\", 2));\n#ifdef CONFIG_AGENT\n    JS_SetPropertyStr(ctx, obj262, \"agent\", js_new_agent(ctx));\n#endif\n\n    JS_SetPropertyStr(ctx, obj262, \"global\",\n                      JS_DupValue(ctx, global_obj));\n    JS_SetPropertyStr(ctx, obj262, \"createRealm\",\n                      JS_NewCFunction(ctx, js_createRealm,\n                                      \"createRealm\", 0));\n    obj = JS_NewCFunction(ctx, js_IsHTMLDDA, \"IsHTMLDDA\", 0);\n    JS_SetIsHTMLDDA(ctx, obj);\n    JS_SetPropertyStr(ctx, obj262, \"IsHTMLDDA\", obj);\n\n    JS_SetPropertyStr(ctx, global_obj, \"$262\", JS_DupValue(ctx, obj262));\n\n    JS_FreeValue(ctx, global_obj);\n    return obj262;\n}\n\nstatic void add_helpers(JSContext *ctx)\n{\n    JS_FreeValue(ctx, add_helpers1(ctx));\n}\n\nstatic char *load_file(const char *filename, size_t *lenp)\n{\n    char *buf;\n    size_t buf_len;\n    buf = (char *)js_load_file(NULL, &buf_len, filename);\n    if (!buf)\n        perror_exit(1, filename);\n    if (lenp)\n        *lenp = buf_len;\n    return buf;\n}\n\nstatic JSModuleDef *js_module_loader_test(JSContext *ctx,\n                                          const char *module_name, void *opaque)\n{\n    size_t buf_len;\n    uint8_t *buf;\n    JSModuleDef *m;\n    JSValue func_val;\n    char *filename, *slash, path[1024];\n\n    // interpret import(\"bar.js\") from path/to/foo.js as\n    // import(\"path/to/bar.js\") but leave import(\"./bar.js\") untouched\n    filename = opaque;\n    if (!strchr(module_name, '/')) {\n        slash = strrchr(filename, '/');\n        if (slash) {\n            snprintf(path, sizeof(path), \"%.*s/%s\",\n                     (int)(slash - filename), filename, module_name);\n            module_name = path;\n        }\n    }\n\n    buf = js_load_file(ctx, &buf_len, module_name);\n    if (!buf) {\n        JS_ThrowReferenceError(ctx, \"could not load module filename '%s'\",\n                               module_name);\n        return NULL;\n    }\n\n    /* compile the module */\n    func_val = JS_Eval(ctx, (char *)buf, buf_len, module_name,\n                       JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);\n    js_free(ctx, buf);\n    if (JS_IsException(func_val))\n        return NULL;\n    /* the module is already referenced, so we must free it */\n    m = JS_VALUE_GET_PTR(func_val);\n    JS_FreeValue(ctx, func_val);\n    return m;\n}\n\nint is_line_sep(char c)\n{\n    return (c == '\\0' || c == '\\n' || c == '\\r');\n}\n\nchar *find_line(const char *str, const char *line)\n{\n    if (str) {\n        const char *p;\n        int len = strlen(line);\n        for (p = str; (p = strstr(p, line)) != NULL; p += len + 1) {\n            if ((p == str || is_line_sep(p[-1])) && is_line_sep(p[len]))\n                return (char *)p;\n        }\n    }\n    return NULL;\n}\n\nint is_word_sep(char c)\n{\n    return (c == '\\0' || isspace((unsigned char)c) || c == ',');\n}\n\nchar *find_word(const char *str, const char *word)\n{\n    const char *p;\n    int len = strlen(word);\n    if (str && len) {\n        for (p = str; (p = strstr(p, word)) != NULL; p += len) {\n            if ((p == str || is_word_sep(p[-1])) && is_word_sep(p[len]))\n                return (char *)p;\n        }\n    }\n    return NULL;\n}\n\n/* handle exclude directories */\nvoid update_exclude_dirs(void)\n{\n    namelist_t *lp = &test_list;\n    namelist_t *ep = &exclude_list;\n    namelist_t *dp = &exclude_dir_list;\n    char *name;\n    int i, j, count;\n\n    /* split directpries from exclude_list */\n    for (count = i = 0; i < ep->count; i++) {\n        name = ep->array[i];\n        if (has_suffix(name, \"/\")) {\n            namelist_add(dp, NULL, name);\n            free(name);\n        } else {\n            ep->array[count++] = name;\n        }\n    }\n    ep->count = count;\n\n    namelist_sort(dp);\n\n    /* filter out excluded directories */\n    for (count = i = 0; i < lp->count; i++) {\n        name = lp->array[i];\n        for (j = 0; j < dp->count; j++) {\n            if (has_prefix(name, dp->array[j])) {\n                test_excluded++;\n                free(name);\n                name = NULL;\n                break;\n            }\n        }\n        if (name) {\n            lp->array[count++] = name;\n        }\n    }\n    lp->count = count;\n}\n\nvoid load_config(const char *filename, const char *ignore)\n{\n    char buf[1024];\n    FILE *f;\n    char *base_name;\n    enum {\n        SECTION_NONE = 0,\n        SECTION_CONFIG,\n        SECTION_EXCLUDE,\n        SECTION_FEATURES,\n        SECTION_TESTS,\n    } section = SECTION_NONE;\n    int lineno = 0;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror_exit(1, filename);\n    }\n    base_name = get_basename(filename);\n\n    while (fgets(buf, sizeof(buf), f) != NULL) {\n        char *p, *q;\n        lineno++;\n        p = str_strip(buf);\n        if (*p == '#' || *p == ';' || *p == '\\0')\n            continue;  /* line comment */\n\n        if (*p == \"[]\"[0]) {\n            /* new section */\n            p++;\n            p[strcspn(p, \"]\")] = '\\0';\n            if (str_equal(p, \"config\"))\n                section = SECTION_CONFIG;\n            else if (str_equal(p, \"exclude\"))\n                section = SECTION_EXCLUDE;\n            else if (str_equal(p, \"features\"))\n                section = SECTION_FEATURES;\n            else if (str_equal(p, \"tests\"))\n                section = SECTION_TESTS;\n            else\n                section = SECTION_NONE;\n            continue;\n        }\n        q = strchr(p, '=');\n        if (q) {\n            /* setting: name=value */\n            *q++ = '\\0';\n            q = str_strip(q);\n        }\n        switch (section) {\n        case SECTION_CONFIG:\n            if (!q) {\n                printf(\"%s:%d: syntax error\\n\", filename, lineno);\n                continue;\n            }\n            if (strstr(ignore, p)) {\n                printf(\"%s:%d: ignoring %s=%s\\n\", filename, lineno, p, q);\n                continue;\n            }\n            if (str_equal(p, \"style\")) {\n                new_style = str_equal(q, \"new\");\n                continue;\n            }\n            if (str_equal(p, \"testdir\")) {\n                char *testdir = compose_path(base_name, q);\n                enumerate_tests(testdir);\n                free(testdir);\n                continue;\n            }\n            if (str_equal(p, \"harnessdir\")) {\n                harness_dir = compose_path(base_name, q);\n                continue;\n            }\n            if (str_equal(p, \"harnessexclude\")) {\n                str_append(&harness_exclude, \" \", q);\n                continue;\n            }\n            if (str_equal(p, \"features\")) {\n                str_append(&harness_features, \" \", q);\n                continue;\n            }\n            if (str_equal(p, \"skip-features\")) {\n                str_append(&harness_skip_features, \" \", q);\n                continue;\n            }\n            if (str_equal(p, \"mode\")) {\n                if (str_equal(q, \"default\") || str_equal(q, \"default-nostrict\"))\n                    test_mode = TEST_DEFAULT_NOSTRICT;\n                else if (str_equal(q, \"default-strict\"))\n                    test_mode = TEST_DEFAULT_STRICT;\n                else if (str_equal(q, \"nostrict\"))\n                    test_mode = TEST_NOSTRICT;\n                else if (str_equal(q, \"strict\"))\n                    test_mode = TEST_STRICT;\n                else if (str_equal(q, \"all\") || str_equal(q, \"both\"))\n                    test_mode = TEST_ALL;\n                else\n                    fatal(2, \"unknown test mode: %s\", q);\n                continue;\n            }\n            if (str_equal(p, \"strict\")) {\n                if (str_equal(q, \"skip\") || str_equal(q, \"no\"))\n                    test_mode = TEST_NOSTRICT;\n                continue;\n            }\n            if (str_equal(p, \"nostrict\")) {\n                if (str_equal(q, \"skip\") || str_equal(q, \"no\"))\n                    test_mode = TEST_STRICT;\n                continue;\n            }\n            if (str_equal(p, \"async\")) {\n                skip_async = !str_equal(q, \"yes\");\n                continue;\n            }\n            if (str_equal(p, \"module\")) {\n                skip_module = !str_equal(q, \"yes\");\n                continue;\n            }\n            if (str_equal(p, \"verbose\")) {\n                verbose = str_equal(q, \"yes\");\n                continue;\n            }\n            if (str_equal(p, \"errorfile\")) {\n                error_filename = compose_path(base_name, q);\n                continue;\n            }\n            if (str_equal(p, \"excludefile\")) {\n                char *path = compose_path(base_name, q);\n                namelist_load(&exclude_list, path);\n                free(path);\n                continue;\n            }\n            if (str_equal(p, \"reportfile\")) {\n                report_filename = compose_path(base_name, q);\n                continue;\n            }\n        case SECTION_EXCLUDE:\n            namelist_add(&exclude_list, base_name, p);\n            break;\n        case SECTION_FEATURES:\n            if (!q || str_equal(q, \"yes\"))\n                str_append(&harness_features, \" \", p);\n            else\n                str_append(&harness_skip_features, \" \", p);\n            break;\n        case SECTION_TESTS:\n            namelist_add(&test_list, base_name, p);\n            break;\n        default:\n            /* ignore settings in other sections */\n            break;\n        }\n    }\n    fclose(f);\n    free(base_name);\n}\n\nchar *find_error(const char *filename, int *pline, int is_strict)\n{\n    if (error_file) {\n        size_t len = strlen(filename);\n        const char *p, *q, *r;\n        int line;\n\n        for (p = error_file; (p = strstr(p, filename)) != NULL; p += len) {\n            if ((p == error_file || p[-1] == '\\n' || p[-1] == '(') && p[len] == ':') {\n                q = p + len;\n                line = 1;\n                if (*q == ':') {\n                    line = strtol(q + 1, (char**)&q, 10);\n                    if (*q == ':')\n                        q++;\n                }\n                while (*q == ' ') {\n                    q++;\n                }\n                /* check strict mode indicator */\n                if (!strstart(q, \"strict mode: \", &q) != !is_strict)\n                    continue;\n                r = q = skip_prefix(q, \"unexpected error: \");\n                r += strcspn(r, \"\\n\");\n                while (r[0] == '\\n' && r[1] && strncmp(r + 1, filename, 8)) {\n                    r++;\n                    r += strcspn(r, \"\\n\");\n                }\n                if (pline)\n                    *pline = line;\n                return strdup_len(q, r - q);\n            }\n        }\n    }\n    return NULL;\n}\n\nint skip_comments(const char *str, int line, int *pline)\n{\n    const char *p;\n    int c;\n\n    p = str;\n    while ((c = (unsigned char)*p++) != '\\0') {\n        if (isspace(c)) {\n            if (c == '\\n')\n                line++;\n            continue;\n        }\n        if (c == '/' && *p == '/') {\n            while (*++p && *p != '\\n')\n                continue;\n            continue;\n        }\n        if (c == '/' && *p == '*') {\n            for (p += 1; *p; p++) {\n                if (*p == '\\n') {\n                    line++;\n                    continue;\n                }\n                if (*p == '*' && p[1] == '/') {\n                    p += 2;\n                    break;\n                }\n            }\n            continue;\n        }\n        break;\n    }\n    if (pline)\n        *pline = line;\n\n    return p - str;\n}\n\nint longest_match(const char *str, const char *find, int pos, int *ppos, int line, int *pline)\n{\n    int len, maxlen;\n\n    maxlen = 0;\n\n    if (*find) {\n        const char *p;\n        for (p = str + pos; *p; p++) {\n            if (*p == *find) {\n                for (len = 1; p[len] && p[len] == find[len]; len++)\n                    continue;\n                if (len > maxlen) {\n                    maxlen = len;\n                    if (ppos)\n                        *ppos = p - str;\n                    if (pline)\n                        *pline = line;\n                    if (!find[len])\n                        break;\n                }\n            }\n            if (*p == '\\n')\n                line++;\n        }\n    }\n    return maxlen;\n}\n\nstatic int eval_buf(JSContext *ctx, const char *buf, size_t buf_len,\n                    const char *filename, int is_test, int is_negative,\n                    const char *error_type, FILE *outfile, int eval_flags,\n                    int is_async)\n{\n    JSValue res_val, exception_val;\n    int ret, error_line, pos, pos_line;\n    BOOL is_error, has_error_line, ret_promise;\n    const char *error_name;\n\n    pos = skip_comments(buf, 1, &pos_line);\n    error_line = pos_line;\n    has_error_line = FALSE;\n    exception_val = JS_UNDEFINED;\n    error_name = NULL;\n\n    /* a module evaluation returns a promise */\n    ret_promise = ((eval_flags & JS_EVAL_TYPE_MODULE) != 0);\n    async_done = 0; /* counter of \"Test262:AsyncTestComplete\" messages */\n\n    res_val = JS_Eval(ctx, buf, buf_len, filename, eval_flags);\n\n    if ((is_async || ret_promise) && !JS_IsException(res_val)) {\n        JSValue promise = JS_UNDEFINED;\n        if (ret_promise) {\n            promise = res_val;\n        } else {\n            JS_FreeValue(ctx, res_val);\n        }\n        for(;;) {\n            JSContext *ctx1;\n            ret = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);\n            if (ret < 0) {\n                res_val = JS_EXCEPTION;\n                break;\n            } else if (ret == 0) {\n                if (is_async) {\n                    /* test if the test called $DONE() once */\n                    if (async_done != 1) {\n                        res_val = JS_ThrowTypeError(ctx, \"$DONE() not called\");\n                    } else {\n                        res_val = JS_UNDEFINED;\n                    }\n                } else {\n                    /* check that the returned promise is fulfilled */\n                    JSPromiseStateEnum state = JS_PromiseState(ctx, promise);\n                    if (state == JS_PROMISE_FULFILLED)\n                        res_val = JS_UNDEFINED;\n                    else if (state == JS_PROMISE_REJECTED)\n                        res_val = JS_Throw(ctx, JS_PromiseResult(ctx, promise));\n                    else\n                        res_val = JS_ThrowTypeError(ctx, \"promise is pending\");\n                }\n                break;\n            }\n        }\n        JS_FreeValue(ctx, promise);\n    }\n\n    if (JS_IsException(res_val)) {\n        exception_val = JS_GetException(ctx);\n        is_error = JS_IsError(ctx, exception_val);\n        /* XXX: should get the filename and line number */\n        if (outfile) {\n            if (!is_error)\n                fprintf(outfile, \"%sThrow: \", (eval_flags & JS_EVAL_FLAG_STRICT) ?\n                        \"strict mode: \" : \"\");\n            js_print(ctx, JS_NULL, 1, &exception_val);\n        }\n        if (is_error) {\n            JSValue name, stack;\n            const char *stack_str;\n\n            name = JS_GetPropertyStr(ctx, exception_val, \"name\");\n            error_name = JS_ToCString(ctx, name);\n            stack = JS_GetPropertyStr(ctx, exception_val, \"stack\");\n            if (!JS_IsUndefined(stack)) {\n                stack_str = JS_ToCString(ctx, stack);\n                if (stack_str) {\n                    const char *p;\n                    int len;\n\n                    if (outfile)\n                        fprintf(outfile, \"%s\", stack_str);\n\n                    len = strlen(filename);\n                    p = strstr(stack_str, filename);\n                    if (p != NULL && p[len] == ':') {\n                        error_line = atoi(p + len + 1);\n                        has_error_line = TRUE;\n                    }\n                    JS_FreeCString(ctx, stack_str);\n                }\n            }\n            JS_FreeValue(ctx, stack);\n            JS_FreeValue(ctx, name);\n        }\n        if (is_negative) {\n            ret = 0;\n            if (error_type) {\n                char *error_class;\n                const char *msg;\n\n                msg = JS_ToCString(ctx, exception_val);\n                error_class = strdup_len(msg, strcspn(msg, \":\"));\n                if (!str_equal(error_class, error_type))\n                    ret = -1;\n                free(error_class);\n                JS_FreeCString(ctx, msg);\n            }\n        } else {\n            ret = -1;\n        }\n    } else {\n        if (is_negative)\n            ret = -1;\n        else\n            ret = 0;\n    }\n\n    if (verbose && is_test) {\n        JSValue msg_val = JS_UNDEFINED;\n        const char *msg = NULL;\n        int s_line;\n        char *s = find_error(filename, &s_line, eval_flags & JS_EVAL_FLAG_STRICT);\n        const char *strict_mode = (eval_flags & JS_EVAL_FLAG_STRICT) ? \"strict mode: \" : \"\";\n\n        if (!JS_IsUndefined(exception_val)) {\n            msg_val = JS_ToString(ctx, exception_val);\n            msg = JS_ToCString(ctx, msg_val);\n        }\n        if (is_negative) {  // expect error\n            if (ret == 0) {\n                if (msg && s &&\n                    (str_equal(s, \"expected error\") ||\n                     strstart(s, \"unexpected error type:\", NULL) ||\n                     str_equal(s, msg))) {     // did not have error yet\n                    if (!has_error_line) {\n                        longest_match(buf, msg, pos, &pos, pos_line, &error_line);\n                    }\n                    printf(\"%s:%d: %sOK, now has error %s\\n\",\n                           filename, error_line, strict_mode, msg);\n                    fixed_errors++;\n                }\n            } else {\n                if (!s) {   // not yet reported\n                    if (msg) {\n                        fprintf(error_out, \"%s:%d: %sunexpected error type: %s\\n\",\n                                filename, error_line, strict_mode, msg);\n                    } else {\n                        fprintf(error_out, \"%s:%d: %sexpected error\\n\",\n                                filename, error_line, strict_mode);\n                    }\n                    new_errors++;\n                }\n            }\n        } else {            // should not have error\n            if (msg) {\n                if (!s || !str_equal(s, msg)) {\n                    if (!has_error_line) {\n                        char *p = skip_prefix(msg, \"Test262 Error: \");\n                        if (strstr(p, \"Test case returned non-true value!\")) {\n                            longest_match(buf, \"runTestCase\", pos, &pos, pos_line, &error_line);\n                        } else {\n                            longest_match(buf, p, pos, &pos, pos_line, &error_line);\n                        }\n                    }\n                    fprintf(error_out, \"%s:%d: %s%s%s\\n\", filename, error_line, strict_mode,\n                            error_file ? \"unexpected error: \" : \"\", msg);\n\n                    if (s && (!str_equal(s, msg) || error_line != s_line)) {\n                        printf(\"%s:%d: %sprevious error: %s\\n\", filename, s_line, strict_mode, s);\n                        changed_errors++;\n                    } else {\n                        new_errors++;\n                    }\n                }\n            } else {\n                if (s) {\n                    printf(\"%s:%d: %sOK, fixed error: %s\\n\", filename, s_line, strict_mode, s);\n                    fixed_errors++;\n                }\n            }\n        }\n        JS_FreeValue(ctx, msg_val);\n        JS_FreeCString(ctx, msg);\n        free(s);\n    }\n    JS_FreeCString(ctx, error_name);\n    JS_FreeValue(ctx, exception_val);\n    JS_FreeValue(ctx, res_val);\n    return ret;\n}\n\nstatic int eval_file(JSContext *ctx, const char *base, const char *p,\n                     int eval_flags)\n{\n    char *buf;\n    size_t buf_len;\n    char *filename = compose_path(base, p);\n\n    buf = load_file(filename, &buf_len);\n    if (!buf) {\n        warning(\"cannot load %s\", filename);\n        goto fail;\n    }\n    if (eval_buf(ctx, buf, buf_len, filename, FALSE, FALSE, NULL, stderr,\n                 eval_flags, FALSE)) {\n        warning(\"error evaluating %s\", filename);\n        goto fail;\n    }\n    free(buf);\n    free(filename);\n    return 0;\n\nfail:\n    free(buf);\n    free(filename);\n    return 1;\n}\n\nchar *extract_desc(const char *buf, char style)\n{\n    const char *p, *desc_start;\n    char *desc;\n    int len;\n\n    p = buf;\n    while (*p != '\\0') {\n        if (p[0] == '/' && p[1] == '*' && p[2] == style && p[3] != '/') {\n            p += 3;\n            desc_start = p;\n            while (*p != '\\0' && (p[0] != '*' || p[1] != '/'))\n                p++;\n            if (*p == '\\0') {\n                warning(\"Expecting end of desc comment\");\n                return NULL;\n            }\n            len = p - desc_start;\n            desc = malloc(len + 1);\n            memcpy(desc, desc_start, len);\n            desc[len] = '\\0';\n            return desc;\n        } else {\n            p++;\n        }\n    }\n    return NULL;\n}\n\nstatic char *find_tag(char *desc, const char *tag, int *state)\n{\n    char *p;\n    p = strstr(desc, tag);\n    if (p) {\n        p += strlen(tag);\n        *state = 0;\n    }\n    return p;\n}\n\nstatic char *get_option(char **pp, int *state)\n{\n    char *p, *p0, *option = NULL;\n    if (*pp) {\n        for (p = *pp;; p++) {\n            switch (*p) {\n            case '[':\n                *state += 1;\n                continue;\n            case ']':\n                *state -= 1;\n                if (*state > 0)\n                    continue;\n                p = NULL;\n                break;\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case ',':\n            case '-':\n                continue;\n            case '\\n':\n                if (*state > 0 || p[1] == ' ')\n                    continue;\n                p = NULL;\n                break;\n            case '\\0':\n                p = NULL;\n                break;\n            default:\n                p0 = p;\n                p += strcspn(p0, \" \\t\\r\\n,]\");\n                option = strdup_len(p0, p - p0);\n                break;\n            }\n            break;\n        }\n        *pp = p;\n    }\n    return option;\n}\n\nvoid update_stats(JSRuntime *rt, const char *filename) {\n    JSMemoryUsage stats;\n    JS_ComputeMemoryUsage(rt, &stats);\n    if (stats_count++ == 0) {\n        stats_avg = stats_all = stats_min = stats_max = stats;\n        stats_min_filename = strdup(filename);\n        stats_max_filename = strdup(filename);\n    } else {\n        if (stats_max.malloc_size < stats.malloc_size) {\n            stats_max = stats;\n            free(stats_max_filename);\n            stats_max_filename = strdup(filename);\n        }\n        if (stats_min.malloc_size > stats.malloc_size) {\n            stats_min = stats;\n            free(stats_min_filename);\n            stats_min_filename = strdup(filename);\n        }\n\n#define update(f)  stats_avg.f = (stats_all.f += stats.f) / stats_count\n        update(malloc_count);\n        update(malloc_size);\n        update(memory_used_count);\n        update(memory_used_size);\n        update(atom_count);\n        update(atom_size);\n        update(str_count);\n        update(str_size);\n        update(obj_count);\n        update(obj_size);\n        update(prop_count);\n        update(prop_size);\n        update(shape_count);\n        update(shape_size);\n        update(js_func_count);\n        update(js_func_size);\n        update(js_func_code_size);\n        update(js_func_pc2line_count);\n        update(js_func_pc2line_size);\n        update(c_func_count);\n        update(array_count);\n        update(fast_array_count);\n        update(fast_array_elements);\n    }\n#undef update\n}\n\nint run_test_buf(const char *filename, const char *harness, namelist_t *ip,\n                 char *buf, size_t buf_len, const char* error_type,\n                 int eval_flags, BOOL is_negative, BOOL is_async,\n                 BOOL can_block)\n{\n    JSRuntime *rt;\n    JSContext *ctx;\n    int i, ret;\n\n    rt = JS_NewRuntime();\n    if (rt == NULL) {\n        fatal(1, \"JS_NewRuntime failure\");\n    }\n    ctx = JS_NewContext(rt);\n    if (ctx == NULL) {\n        JS_FreeRuntime(rt);\n        fatal(1, \"JS_NewContext failure\");\n    }\n    JS_SetRuntimeInfo(rt, filename);\n\n    JS_SetCanBlock(rt, can_block);\n\n    /* loader for ES6 modules */\n    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader_test, (void *)filename);\n\n    add_helpers(ctx);\n\n    for (i = 0; i < ip->count; i++) {\n        if (eval_file(ctx, harness, ip->array[i],\n                      JS_EVAL_TYPE_GLOBAL | JS_EVAL_FLAG_STRIP)) {\n            fatal(1, \"error including %s for %s\", ip->array[i], filename);\n        }\n    }\n\n    ret = eval_buf(ctx, buf, buf_len, filename, TRUE, is_negative,\n                   error_type, outfile, eval_flags, is_async);\n    ret = (ret != 0);\n\n    if (dump_memory) {\n        update_stats(rt, filename);\n    }\n#ifdef CONFIG_AGENT\n    js_agent_free(ctx);\n#endif\n    JS_FreeContext(ctx);\n    JS_FreeRuntime(rt);\n\n    test_count++;\n    if (ret) {\n        test_failed++;\n        if (outfile) {\n            /* do not output a failure number to minimize diff */\n            fprintf(outfile, \"  FAILED\\n\");\n        }\n    }\n    return ret;\n}\n\nint run_test(const char *filename, int index)\n{\n    char harnessbuf[1024];\n    char *harness;\n    char *buf;\n    size_t buf_len;\n    char *desc, *p;\n    char *error_type;\n    int ret, eval_flags, use_strict, use_nostrict;\n    BOOL is_negative, is_nostrict, is_onlystrict, is_async, is_module, skip;\n    BOOL can_block;\n    namelist_t include_list = { 0 }, *ip = &include_list;\n\n    is_nostrict = is_onlystrict = is_negative = is_async = is_module = skip = FALSE;\n    can_block = TRUE;\n    error_type = NULL;\n    buf = load_file(filename, &buf_len);\n\n    harness = harness_dir;\n\n    if (new_style) {\n        if (!harness) {\n            p = strstr(filename, \"test/\");\n            if (p) {\n                snprintf(harnessbuf, sizeof(harnessbuf), \"%.*s%s\",\n                         (int)(p - filename), filename, \"harness\");\n            } else {\n                pstrcpy(harnessbuf, sizeof(harnessbuf), \"\");\n            }\n            harness = harnessbuf;\n        }\n        namelist_add(ip, NULL, \"sta.js\");\n        namelist_add(ip, NULL, \"assert.js\");\n        /* extract the YAML frontmatter */\n        desc = extract_desc(buf, '-');\n        if (desc) {\n            char *ifile, *option;\n            int state;\n            p = find_tag(desc, \"includes:\", &state);\n            if (p) {\n                while ((ifile = get_option(&p, &state)) != NULL) {\n                    // skip unsupported harness files\n                    if (find_word(harness_exclude, ifile)) {\n                        skip |= 1;\n                    } else {\n                        namelist_add(ip, NULL, ifile);\n                    }\n                    free(ifile);\n                }\n            }\n            p = find_tag(desc, \"flags:\", &state);\n            if (p) {\n                while ((option = get_option(&p, &state)) != NULL) {\n                    if (str_equal(option, \"noStrict\") ||\n                        str_equal(option, \"raw\")) {\n                        is_nostrict = TRUE;\n                        skip |= (test_mode == TEST_STRICT);\n                    }\n                    else if (str_equal(option, \"onlyStrict\")) {\n                        is_onlystrict = TRUE;\n                        skip |= (test_mode == TEST_NOSTRICT);\n                    }\n                    else if (str_equal(option, \"async\")) {\n                        is_async = TRUE;\n                        skip |= skip_async;\n                    }\n                    else if (str_equal(option, \"module\")) {\n                        is_module = TRUE;\n                        skip |= skip_module;\n                    }\n                    else if (str_equal(option, \"CanBlockIsFalse\")) {\n                        can_block = FALSE;\n                    }\n                    free(option);\n                }\n            }\n            p = find_tag(desc, \"negative:\", &state);\n            if (p) {\n                /* XXX: should extract the phase */\n                char *q = find_tag(p, \"type:\", &state);\n                if (q) {\n                    while (isspace((unsigned char)*q))\n                        q++;\n                    error_type = strdup_len(q, strcspn(q, \" \\n\"));\n                }\n                is_negative = TRUE;\n            }\n            p = find_tag(desc, \"features:\", &state);\n            if (p) {\n                while ((option = get_option(&p, &state)) != NULL) {\n                    if (find_word(harness_features, option)) {\n                        /* feature is enabled */\n                    } else if (find_word(harness_skip_features, option)) {\n                        /* skip disabled feature */\n                        skip |= 1;\n                    } else {\n                        /* feature is not listed: skip and warn */\n                        printf(\"%s:%d: unknown feature: %s\\n\", filename, 1, option);\n                        skip |= 1;\n                    }\n                    free(option);\n                }\n            }\n            free(desc);\n        }\n        if (is_async)\n            namelist_add(ip, NULL, \"doneprintHandle.js\");\n    } else {\n        char *ifile;\n\n        if (!harness) {\n            p = strstr(filename, \"test/\");\n            if (p) {\n                snprintf(harnessbuf, sizeof(harnessbuf), \"%.*s%s\",\n                         (int)(p - filename), filename, \"test/harness\");\n            } else {\n                pstrcpy(harnessbuf, sizeof(harnessbuf), \"\");\n            }\n            harness = harnessbuf;\n        }\n\n        namelist_add(ip, NULL, \"sta.js\");\n\n        /* include extra harness files */\n        for (p = buf; (p = strstr(p, \"$INCLUDE(\\\"\")) != NULL; p++) {\n            p += 10;\n            ifile = strdup_len(p, strcspn(p, \"\\\"\"));\n            // skip unsupported harness files\n            if (find_word(harness_exclude, ifile)) {\n                skip |= 1;\n            } else {\n                namelist_add(ip, NULL, ifile);\n            }\n            free(ifile);\n        }\n\n        /* locate the old style configuration comment */\n        desc = extract_desc(buf, '*');\n        if (desc) {\n            if (strstr(desc, \"@noStrict\")) {\n                is_nostrict = TRUE;\n                skip |= (test_mode == TEST_STRICT);\n            }\n            if (strstr(desc, \"@onlyStrict\")) {\n                is_onlystrict = TRUE;\n                skip |= (test_mode == TEST_NOSTRICT);\n            }\n            if (strstr(desc, \"@negative\")) {\n                /* XXX: should extract the regex to check error type */\n                is_negative = TRUE;\n            }\n            free(desc);\n        }\n    }\n\n    if (outfile && index >= 0) {\n        fprintf(outfile, \"%d: %s%s%s%s%s%s%s\\n\", index, filename,\n                is_nostrict ? \"  @noStrict\" : \"\",\n                is_onlystrict ? \"  @onlyStrict\" : \"\",\n                is_async ? \"  async\" : \"\",\n                is_module ? \"  module\" : \"\",\n                is_negative ? \"  @negative\" : \"\",\n                skip ? \"  SKIPPED\" : \"\");\n        fflush(outfile);\n    }\n\n    use_strict = use_nostrict = 0;\n    /* XXX: should remove 'test_mode' or simplify it just to force\n       strict or non strict mode for single file tests */\n    switch (test_mode) {\n    case TEST_DEFAULT_NOSTRICT:\n        if (is_onlystrict)\n            use_strict = 1;\n        else\n            use_nostrict = 1;\n        break;\n    case TEST_DEFAULT_STRICT:\n        if (is_nostrict)\n            use_nostrict = 1;\n        else\n            use_strict = 1;\n        break;\n    case TEST_NOSTRICT:\n        if (!is_onlystrict)\n            use_nostrict = 1;\n        break;\n    case TEST_STRICT:\n        if (!is_nostrict)\n            use_strict = 1;\n        break;\n    case TEST_ALL:\n        if (is_module) {\n            use_nostrict = 1;\n        } else {\n            if (!is_nostrict)\n                use_strict = 1;\n            if (!is_onlystrict)\n                use_nostrict = 1;\n        }\n        break;\n    }\n\n    if (skip || use_strict + use_nostrict == 0) {\n        test_skipped++;\n        ret = -2;\n    } else {\n        clock_t clocks;\n\n        if (is_module) {\n            eval_flags = JS_EVAL_TYPE_MODULE;\n        } else {\n            eval_flags = JS_EVAL_TYPE_GLOBAL;\n        }\n        clocks = clock();\n        ret = 0;\n        if (use_nostrict) {\n            ret = run_test_buf(filename, harness, ip, buf, buf_len,\n                               error_type, eval_flags, is_negative, is_async,\n                               can_block);\n        }\n        if (use_strict) {\n            ret |= run_test_buf(filename, harness, ip, buf, buf_len,\n                                error_type, eval_flags | JS_EVAL_FLAG_STRICT,\n                                is_negative, is_async, can_block);\n        }\n        clocks = clock() - clocks;\n        if (outfile && index >= 0 && clocks >= CLOCKS_PER_SEC / 10) {\n            /* output timings for tests that take more than 100 ms */\n            fprintf(outfile, \" time: %d ms\\n\", (int)(clocks * 1000LL / CLOCKS_PER_SEC));\n        }\n    }\n    namelist_free(&include_list);\n    free(error_type);\n    free(buf);\n\n    return ret;\n}\n\n/* run a test when called by test262-harness+eshost */\nint run_test262_harness_test(const char *filename, BOOL is_module)\n{\n    JSRuntime *rt;\n    JSContext *ctx;\n    char *buf;\n    size_t buf_len;\n    int eval_flags, ret_code, ret;\n    JSValue res_val;\n    BOOL can_block;\n\n    outfile = stdout; /* for js_print */\n\n    rt = JS_NewRuntime();\n    if (rt == NULL) {\n        fatal(1, \"JS_NewRuntime failure\");\n    }\n    ctx = JS_NewContext(rt);\n    if (ctx == NULL) {\n        JS_FreeRuntime(rt);\n        fatal(1, \"JS_NewContext failure\");\n    }\n    JS_SetRuntimeInfo(rt, filename);\n\n    can_block = TRUE;\n    JS_SetCanBlock(rt, can_block);\n\n    /* loader for ES6 modules */\n    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader_test, (void *)filename);\n\n    add_helpers(ctx);\n\n    buf = load_file(filename, &buf_len);\n\n    if (is_module) {\n      eval_flags = JS_EVAL_TYPE_MODULE;\n    } else {\n      eval_flags = JS_EVAL_TYPE_GLOBAL;\n    }\n    res_val = JS_Eval(ctx, buf, buf_len, filename, eval_flags);\n    ret_code = 0;\n    if (JS_IsException(res_val)) {\n       js_std_dump_error(ctx);\n       ret_code = 1;\n    } else {\n        JSValue promise = JS_UNDEFINED;\n        if (is_module) {\n            promise = res_val;\n        } else {\n            JS_FreeValue(ctx, res_val);\n        }\n        for(;;) {\n            JSContext *ctx1;\n            ret = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);\n            if (ret < 0) {\n                js_std_dump_error(ctx1);\n                ret_code = 1;\n            } else if (ret == 0) {\n                break;\n            }\n        }\n        /* dump the error if the module returned an error. */\n        if (is_module) {\n            JSPromiseStateEnum state = JS_PromiseState(ctx, promise);\n            if (state == JS_PROMISE_REJECTED) {\n                JS_Throw(ctx, JS_PromiseResult(ctx, promise));\n                js_std_dump_error(ctx);\n                ret_code = 1;\n            }\n        }\n        JS_FreeValue(ctx, promise);\n    }\n    free(buf);\n#ifdef CONFIG_AGENT\n    js_agent_free(ctx);\n#endif\n    JS_FreeContext(ctx);\n    JS_FreeRuntime(rt);\n    return ret_code;\n}\n\nclock_t last_clock;\n\nvoid show_progress(int force) {\n    clock_t t = clock();\n    if (force || !last_clock || (t - last_clock) > CLOCKS_PER_SEC / 20) {\n        last_clock = t;\n        if (compact) {\n            static int last_test_skipped;\n            static int last_test_failed;\n            static int dots;\n            char c = '.';\n            if (test_skipped > last_test_skipped)\n                c = '-';\n            if (test_failed > last_test_failed)\n                c = '!';\n            last_test_skipped = test_skipped;\n            last_test_failed = test_failed;\n            fputc(c, stderr);\n            if (force || ++dots % 60 == 0) {\n                fprintf(stderr, \" %d/%d/%d\\n\",\n                        test_failed, test_count, test_skipped);\n            }\n        } else {\n            /* output progress indicator: erase end of line and return to col 0 */\n            fprintf(stderr, \"%d/%d/%d\\033[K\\r\",\n                    test_failed, test_count, test_skipped);\n        }\n        fflush(stderr);\n    }\n}\n\nstatic int slow_test_threshold;\n\nvoid run_test_dir_list(namelist_t *lp, int start_index, int stop_index)\n{\n    int i;\n\n    namelist_sort(lp);\n    for (i = 0; i < lp->count; i++) {\n        const char *p = lp->array[i];\n        if (namelist_find(&exclude_list, p) >= 0) {\n            test_excluded++;\n        } else if (test_index < start_index) {\n            test_skipped++;\n        } else if (stop_index >= 0 && test_index > stop_index) {\n            test_skipped++;\n        } else {\n            int ti;\n            if (slow_test_threshold != 0) {\n                ti = get_clock_ms();\n            } else {\n                ti = 0;\n            }\n            run_test(p, test_index);\n            if (slow_test_threshold != 0) {\n                ti = get_clock_ms() - ti;\n                if (ti >= slow_test_threshold)\n                    fprintf(stderr, \"\\n%s (%d ms)\\n\", p, ti);\n            }\n            show_progress(FALSE);\n        }\n        test_index++;\n    }\n    show_progress(TRUE);\n}\n\nvoid help(void)\n{\n    printf(\"run-test262 version \" CONFIG_VERSION \"\\n\"\n           \"usage: run-test262 [options] {-f file ... | [dir_list] [index range]}\\n\"\n           \"-h             help\\n\"\n           \"-a             run tests in strict and nostrict modes\\n\"\n           \"-m             print memory usage summary\\n\"\n           \"-n             use new style harness\\n\"\n           \"-N             run test prepared by test262-harness+eshost\\n\"\n           \"-s             run tests in strict mode, skip @nostrict tests\\n\"\n           \"-E             only run tests from the error file\\n\"\n           \"-C             use compact progress indicator\\n\"\n           \"-t             show timings\\n\"\n           \"-u             update error file\\n\"\n           \"-v             verbose: output error messages\\n\"\n           \"-T duration    display tests taking more than 'duration' ms\\n\"\n           \"-c file        read configuration from 'file'\\n\"\n           \"-d dir         run all test files in directory tree 'dir'\\n\"\n           \"-e file        load the known errors from 'file'\\n\"\n           \"-f file        execute single test from 'file'\\n\"\n           \"-r file        set the report file name (default=none)\\n\"\n           \"-x file        exclude tests listed in 'file'\\n\");\n    exit(1);\n}\n\nchar *get_opt_arg(const char *option, char *arg)\n{\n    if (!arg) {\n        fatal(2, \"missing argument for option %s\", option);\n    }\n    return arg;\n}\n\nint main(int argc, char **argv)\n{\n    int optind, start_index, stop_index;\n    BOOL is_dir_list;\n    BOOL only_check_errors = FALSE;\n    const char *filename;\n    const char *ignore = \"\";\n    BOOL is_test262_harness = FALSE;\n    BOOL is_module = FALSE;\n    clock_t clocks;\n\n#if !defined(_WIN32)\n    compact = !isatty(STDERR_FILENO);\n    /* Date tests assume California local time */\n    setenv(\"TZ\", \"America/Los_Angeles\", 1);\n#endif\n\n    optind = 1;\n    while (optind < argc) {\n        char *arg = argv[optind];\n        if (*arg != '-')\n            break;\n        optind++;\n        if (strstr(\"-c -d -e -x -f -r -E -T\", arg))\n            optind++;\n        if (strstr(\"-d -f\", arg))\n            ignore = \"testdir\"; // run only the tests from -d or -f\n    }\n\n    /* cannot use getopt because we want to pass the command line to\n       the script */\n    optind = 1;\n    is_dir_list = TRUE;\n    while (optind < argc) {\n        char *arg = argv[optind];\n        if (*arg != '-')\n            break;\n        optind++;\n        if (str_equal(arg, \"-h\")) {\n            help();\n        } else if (str_equal(arg, \"-m\")) {\n            dump_memory++;\n        } else if (str_equal(arg, \"-n\")) {\n            new_style++;\n        } else if (str_equal(arg, \"-s\")) {\n            test_mode = TEST_STRICT;\n        } else if (str_equal(arg, \"-a\")) {\n            test_mode = TEST_ALL;\n        } else if (str_equal(arg, \"-t\")) {\n            show_timings++;\n        } else if (str_equal(arg, \"-u\")) {\n            update_errors++;\n        } else if (str_equal(arg, \"-v\")) {\n            verbose++;\n        } else if (str_equal(arg, \"-C\")) {\n            compact = 1;\n        } else if (str_equal(arg, \"-c\")) {\n            load_config(get_opt_arg(arg, argv[optind++]), ignore);\n        } else if (str_equal(arg, \"-d\")) {\n            enumerate_tests(get_opt_arg(arg, argv[optind++]));\n        } else if (str_equal(arg, \"-e\")) {\n            error_filename = get_opt_arg(arg, argv[optind++]);\n        } else if (str_equal(arg, \"-x\")) {\n            namelist_load(&exclude_list, get_opt_arg(arg, argv[optind++]));\n        } else if (str_equal(arg, \"-f\")) {\n            is_dir_list = FALSE;\n        } else if (str_equal(arg, \"-r\")) {\n            report_filename = get_opt_arg(arg, argv[optind++]);\n        } else if (str_equal(arg, \"-E\")) {\n            only_check_errors = TRUE;\n        } else if (str_equal(arg, \"-T\")) {\n            slow_test_threshold = atoi(get_opt_arg(arg, argv[optind++]));\n        } else if (str_equal(arg, \"-N\")) {\n            is_test262_harness = TRUE;\n        } else if (str_equal(arg, \"--module\")) {\n            is_module = TRUE;\n        } else {\n            fatal(1, \"unknown option: %s\", arg);\n            break;\n        }\n    }\n\n    if (optind >= argc && !test_list.count)\n        help();\n\n    if (is_test262_harness) {\n        return run_test262_harness_test(argv[optind], is_module);\n    }\n\n    error_out = stdout;\n    if (error_filename) {\n        error_file = load_file(error_filename, NULL);\n        if (only_check_errors && error_file) {\n            namelist_free(&test_list);\n            namelist_add_from_error_file(&test_list, error_file);\n        }\n        if (update_errors) {\n            free(error_file);\n            error_file = NULL;\n            error_out = fopen(error_filename, \"w\");\n            if (!error_out) {\n                perror_exit(1, error_filename);\n            }\n        }\n    }\n\n    update_exclude_dirs();\n\n    clocks = clock();\n\n    if (is_dir_list) {\n        if (optind < argc && !isdigit((unsigned char)argv[optind][0])) {\n            filename = argv[optind++];\n            namelist_load(&test_list, filename);\n        }\n        start_index = 0;\n        stop_index = -1;\n        if (optind < argc) {\n            start_index = atoi(argv[optind++]);\n            if (optind < argc) {\n                stop_index = atoi(argv[optind++]);\n            }\n        }\n        if (!report_filename || str_equal(report_filename, \"none\")) {\n            outfile = NULL;\n        } else if (str_equal(report_filename, \"-\")) {\n            outfile = stdout;\n        } else {\n            outfile = fopen(report_filename, \"wb\");\n            if (!outfile) {\n                perror_exit(1, report_filename);\n            }\n        }\n        run_test_dir_list(&test_list, start_index, stop_index);\n\n        if (outfile && outfile != stdout) {\n            fclose(outfile);\n            outfile = NULL;\n        }\n    } else {\n        outfile = stdout;\n        while (optind < argc) {\n            run_test(argv[optind++], -1);\n        }\n    }\n\n    clocks = clock() - clocks;\n\n    if (dump_memory) {\n        if (dump_memory > 1 && stats_count > 1) {\n            printf(\"\\nMininum memory statistics for %s:\\n\\n\", stats_min_filename);\n            JS_DumpMemoryUsage(stdout, &stats_min, NULL);\n            printf(\"\\nMaximum memory statistics for %s:\\n\\n\", stats_max_filename);\n            JS_DumpMemoryUsage(stdout, &stats_max, NULL);\n        }\n        printf(\"\\nAverage memory statistics for %d tests:\\n\\n\", stats_count);\n        JS_DumpMemoryUsage(stdout, &stats_avg, NULL);\n        printf(\"\\n\");\n    }\n\n    if (is_dir_list) {\n        fprintf(stderr, \"Result: %d/%d error%s\",\n                test_failed, test_count, test_count != 1 ? \"s\" : \"\");\n        if (test_excluded)\n            fprintf(stderr, \", %d excluded\", test_excluded);\n        if (test_skipped)\n            fprintf(stderr, \", %d skipped\", test_skipped);\n        if (error_file) {\n            if (new_errors)\n                fprintf(stderr, \", %d new\", new_errors);\n            if (changed_errors)\n                fprintf(stderr, \", %d changed\", changed_errors);\n            if (fixed_errors)\n                fprintf(stderr, \", %d fixed\", fixed_errors);\n        }\n        fprintf(stderr, \"\\n\");\n        if (show_timings)\n            fprintf(stderr, \"Total time: %.3fs\\n\", (double)clocks / CLOCKS_PER_SEC);\n    }\n\n    if (error_out && error_out != stdout) {\n        fclose(error_out);\n        error_out = NULL;\n    }\n\n    namelist_free(&test_list);\n    namelist_free(&exclude_list);\n    namelist_free(&exclude_dir_list);\n    free(harness_dir);\n    free(harness_features);\n    free(harness_exclude);\n    free(error_file);\n\n    /* Signal that the error file is out of date. */\n    return new_errors || changed_errors || fixed_errors;\n}\n"
        },
        {
          "name": "test262.conf",
          "type": "blob",
          "size": 4.6455078125,
          "content": "[config]\n# general settings for test262 ES6 version\n\n# framework style: old, new\nstyle=new\n\n# handle tests tagged as [noStrict]: yes, no, skip\nnostrict=yes\n\n# handle tests tagged as [strictOnly]: yes, no, skip\nstrict=yes\n\n# test mode: default, default-nostrict, default-strict, strict, nostrict, both, all\nmode=default\n\n# handle tests flagged as [async]: yes, no, skip\n# for these, load 'harness/doneprintHandle.js' prior to test\n# and expect `print('Test262:AsyncTestComplete')` to be called for\n# successful termination\nasync=yes\n\n# handle tests flagged as [module]: yes, no, skip\nmodule=yes\n\n# output error messages: yes, no\nverbose=yes\n\n# load harness files from this directory\nharnessdir=test262/harness\n\n# names of harness include files to skip\n#harnessexclude=\n\n# name of the error file for known errors\nerrorfile=test262_errors.txt\n\n# exclude tests enumerated in this file (see also [exclude] section)\n#excludefile=test262_exclude.txt\n\n# report test results to this file\nreportfile=test262_report.txt\n\n# enumerate tests from this directory\ntestdir=test262/test\n\n[features]\n# Standard language features and proposed extensions\n# list the features that are included\n# skipped features are tagged as such to avoid warnings\n# Keep this list alpha-sorted (:sort i in vim)\n\n__getter__\n__proto__\n__setter__\nAggregateError\nalign-detached-buffer-semantics-with-web-reality\narbitrary-module-namespace-names=skip\narray-find-from-last\narray-grouping\nArray.fromAsync=skip\nArray.prototype.at\nArray.prototype.flat\nArray.prototype.flatMap\nArray.prototype.flatten\nArray.prototype.includes\nArray.prototype.values\nArrayBuffer\narraybuffer-transfer=skip\narrow-function\nasync-functions\nasync-iteration\nAtomics\nAtomics.waitAsync=skip\nBigInt\ncaller\nchange-array-by-copy\nclass\nclass-fields-private\nclass-fields-private-in\nclass-fields-public\nclass-methods-private\nclass-static-block\nclass-static-fields-private\nclass-static-fields-public\nclass-static-methods-private\ncleanupSome=skip\ncoalesce-expression\ncomputed-property-names\nconst\ncross-realm\nDataView\nDataView.prototype.getFloat32\nDataView.prototype.getFloat64\nDataView.prototype.getInt16\nDataView.prototype.getInt32\nDataView.prototype.getInt8\nDataView.prototype.getUint16\nDataView.prototype.getUint32\nDataView.prototype.setUint8\ndecorators=skip\ndefault-parameters\ndestructuring-assignment\ndestructuring-binding\ndynamic-import\nerror-cause\nexponentiation\nexport-star-as-namespace-from-module\nFinalizationGroup=skip\nFinalizationRegistry.prototype.cleanupSome=skip\nFinalizationRegistry=skip\nFloat32Array\nFloat64Array\nfor-in-order\nfor-of\ngenerators\nglobalThis\nhashbang\nhost-gc-required=skip\nimport-assertions=skip\nimport-attributes=skip\nimport.meta\nInt16Array\nInt32Array\nInt8Array\nIsHTMLDDA\niterator-helpers=skip\njson-modules=skip\njson-parse-with-source=skip\njson-superset\nlegacy-regexp=skip\nlet\nlogical-assignment-operators\nMap\nnew.target\nnumeric-separator-literal\nobject-rest\nobject-spread\nObject.fromEntries\nObject.hasOwn\nObject.is\noptional-catch-binding\noptional-chaining\nPromise\npromise-with-resolvers\nPromise.allSettled\nPromise.any\nPromise.prototype.finally\nProxy\nproxy-missing-checks\nReflect\nReflect.construct\nReflect.set\nReflect.setPrototypeOf\nregexp-dotall\nregexp-duplicate-named-groups=skip\nregexp-lookbehind\nregexp-match-indices\nregexp-named-groups\nregexp-unicode-property-escapes\nregexp-v-flag=skip\nresizable-arraybuffer=skip\nrest-parameters\nSet\nset-methods=skip\nShadowRealm=skip\nSharedArrayBuffer\nstring-trimming\nString.fromCodePoint\nString.prototype.at\nString.prototype.endsWith\nString.prototype.includes\nString.prototype.isWellFormed\nString.prototype.matchAll\nString.prototype.replaceAll\nString.prototype.toWellFormed\nString.prototype.trimEnd\nString.prototype.trimStart\nsuper\nSymbol\nSymbol.asyncIterator\nSymbol.hasInstance\nSymbol.isConcatSpreadable\nSymbol.iterator\nSymbol.match\nSymbol.matchAll\nSymbol.prototype.description\nSymbol.replace\nSymbol.search\nSymbol.species\nSymbol.split\nSymbol.toPrimitive\nSymbol.toStringTag\nSymbol.unscopables\nsymbols-as-weakmap-keys=skip\ntail-call-optimization=skip\ntemplate\nTemporal=skip\ntop-level-await\nTypedArray\nTypedArray.prototype.at\nu180e\nUint16Array\nUint32Array\nUint8Array\nUint8ClampedArray\nWeakMap\nWeakRef=skip\nWeakSet\nwell-formed-json-stringify\n\n[exclude]\n# list excluded tests and directories here\n\n# intl not supported\ntest262/test/intl402/\n\n# incompatible with the \"caller\" feature\ntest262/test/built-ins/Function/prototype/restricted-property-caller.js\ntest262/test/built-ins/Function/prototype/restricted-property-arguments.js\ntest262/test/built-ins/ThrowTypeError/unique-per-realm-function-proto.js\n\n# slow tests\n#test262/test/built-ins/RegExp/CharacterClassEscapes/\n#test262/test/built-ins/RegExp/property-escapes/\n\n[tests]\n# list test files or use config.testdir\n"
        },
        {
          "name": "test262_errors.txt",
          "type": "blob",
          "size": 1.2734375,
          "content": "test262/test/annexB/language/eval-code/direct/script-decl-lex-collision-in-sloppy-mode.js:13: Test262Error: Expected a SyntaxError to be thrown but no exception was thrown at all\ntest262/test/language/expressions/assignment/target-member-computed-reference-null.js:32: Test262Error: Expected a DummyError but got a TypeError\ntest262/test/language/expressions/assignment/target-member-computed-reference-null.js:32: strict mode: Test262Error: Expected a DummyError but got a TypeError\ntest262/test/language/expressions/assignment/target-member-computed-reference-undefined.js:32: Test262Error: Expected a DummyError but got a TypeError\ntest262/test/language/expressions/assignment/target-member-computed-reference-undefined.js:32: strict mode: Test262Error: Expected a DummyError but got a TypeError\ntest262/test/language/expressions/in/private-field-invalid-assignment-target.js:23: unexpected error type: Test262: This statement should not be evaluated.\ntest262/test/language/expressions/in/private-field-invalid-assignment-target.js:23: strict mode: unexpected error type: Test262: This statement should not be evaluated.\ntest262/test/language/global-code/script-decl-lex-var-declared-via-eval-sloppy.js:13: Test262Error: variable Expected a SyntaxError to be thrown but no exception was thrown at all\n"
        },
        {
          "name": "test262o.conf",
          "type": "blob",
          "size": 21.353515625,
          "content": "[config]\n# general settings for test262 ES5 version\n\n# framework style: old, new\nstyle=old\n\n# handle tests tagged as @noStrict: yes, no, skip\nnostrict=yes\n\n# handle tests tagged as @strictOnly: yes, no, skip\nstrict=yes\n\n# test mode: default, default-nostrict, default-strict, strict, nostrict, both, all\nmode=default\n\n# output error messages: yes, no\nverbose=yes\n\n# load harness files this directory\nharnessdir=test262o/test/harness\n\n# name of the error file for known errors\nerrorfile=test262o_errors.txt\n\n# exclude tests enumerated in this file\n#excludefile=test262o_excluded.txt\n\n# report test results to this file\nreportfile=test262o_report.txt\n\n# enumerate tests from this directory\ntestdir=test262o/test/suite\n\n[exclude]\n# list excluded tests and directories here\n\n# intl not supported\ntest262o/test/suite/intl402/\n\n# ES6 != ES5: block scoped function definitions allowed in strict mode\ntest262o/test/suite/bestPractice/Sbp_A1_T1.js\ntest262o/test/suite/bestPractice/Sbp_A2_T1.js\ntest262o/test/suite/bestPractice/Sbp_A2_T2.js\ntest262o/test/suite/bestPractice/Sbp_A3_T1.js\ntest262o/test/suite/bestPractice/Sbp_A3_T2.js\ntest262o/test/suite/bestPractice/Sbp_A4_T1.js\ntest262o/test/suite/bestPractice/Sbp_A4_T2.js\ntest262o/test/suite/bestPractice/Sbp_A5_T2.js\n\n# ES6 != ES5: `y={x};` is shorthand for `y={x:x}`\ntest262o/test/suite/ch12/12.1/S12.1_A4_T2.js\ntest262o/test/suite/ch12/12.6/12.6.4/S12.6.4_A15.js\n\n# ES6 != ES5: function length property is configurable\ntest262o/test/suite/ch11/11.4/11.4.1/11.4.1-5-a-28-s.js\ntest262o/test/suite/ch13/13.2/13.2-15-1.js\ntest262o/test/suite/ch15/15.1/15.1.2/15.1.2.1/S15.1.2.1_A4.2.js\ntest262o/test/suite/ch15/15.1/15.1.2/15.1.2.2/S15.1.2.2_A9.2.js\ntest262o/test/suite/ch15/15.1/15.1.2/15.1.2.3/S15.1.2.3_A7.2.js\ntest262o/test/suite/ch15/15.1/15.1.2/15.1.2.4/S15.1.2.4_A2.2.js\ntest262o/test/suite/ch15/15.1/15.1.2/15.1.2.5/S15.1.2.5_A2.2.js\ntest262o/test/suite/ch15/15.1/15.1.3/15.1.3.1/S15.1.3.1_A5.2.js\ntest262o/test/suite/ch15/15.1/15.1.3/15.1.3.2/S15.1.3.2_A5.2.js\ntest262o/test/suite/ch15/15.1/15.1.3/15.1.3.3/S15.1.3.3_A5.2.js\ntest262o/test/suite/ch15/15.1/15.1.3/15.1.3.4/S15.1.3.4_A5.2.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-4-186.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-4-187.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-4-191.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-4-194.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-4-201.js\ntest262o/test/suite/ch15/15.2/15.2.4/15.2.4.2/S15.2.4.2_A9.js\ntest262o/test/suite/ch15/15.2/15.2.4/15.2.4.3/S15.2.4.3_A9.js\ntest262o/test/suite/ch15/15.2/15.2.4/15.2.4.4/S15.2.4.4_A9.js\ntest262o/test/suite/ch15/15.2/15.2.4/15.2.4.5/S15.2.4.5_A9.js\ntest262o/test/suite/ch15/15.2/15.2.4/15.2.4.6/S15.2.4.6_A9.js\ntest262o/test/suite/ch15/15.2/15.2.4/15.2.4.7/S15.2.4.7_A9.js\ntest262o/test/suite/ch15/15.3/15.3.3/15.3.3.2/15.3.3.2-1.js\ntest262o/test/suite/ch15/15.3/15.3.4/15.3.4.2/S15.3.4.2_A9.js\ntest262o/test/suite/ch15/15.3/15.3.4/15.3.4.3/S15.3.4.3_A9.js\ntest262o/test/suite/ch15/15.3/15.3.4/15.3.4.4/S15.3.4.4_A9.js\ntest262o/test/suite/ch15/15.3/15.3.4/15.3.4.5/15.3.4.5-15-2.js\ntest262o/test/suite/ch15/15.3/15.3.5/S15.3.5.1_A2_T1.js\ntest262o/test/suite/ch15/15.3/15.3.5/S15.3.5.1_A2_T2.js\ntest262o/test/suite/ch15/15.3/15.3.5/S15.3.5.1_A2_T3.js\ntest262o/test/suite/ch15/15.4/15.4.3/S15.4.3_A2.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.2/S15.4.4.2_A4.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.3/S15.4.4.3_A4.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.4/S15.4.4.4_A4.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.5/S15.4.4.5_A6.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.6/S15.4.4.6_A5.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.7/S15.4.4.7_A6.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.8/S15.4.4.8_A5.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.9/S15.4.4.9_A5.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.10/S15.4.4.10_A5.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.11/S15.4.4.11_A7.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.12/S15.4.4.12_A5.2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.13/S15.4.4.13_A5.2.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.4/S15.5.4.4_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.5/S15.5.4.5_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.6/S15.5.4.6_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.7/S15.5.4.7_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.8/S15.5.4.8_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.9/S15.5.4.9_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.10/S15.5.4.10_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.11/S15.5.4.11_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.12/S15.5.4.12_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.13/S15.5.4.13_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.14/S15.5.4.14_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.15/S15.5.4.15_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.16/S15.5.4.16_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.17/S15.5.4.17_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.18/S15.5.4.18_A9.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.19/S15.5.4.19_A9.js\ntest262o/test/suite/ch15/15.9/15.9.4/15.9.4.2/S15.9.4.2_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.4/15.9.4.3/S15.9.4.3_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.1/S15.9.5.1_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.2/S15.9.5.2_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.3/S15.9.5.3_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.4/S15.9.5.4_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.5/S15.9.5.5_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.6/S15.9.5.6_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.7/S15.9.5.7_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.8/S15.9.5.8_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.9/S15.9.5.9_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.10/S15.9.5.10_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.11/S15.9.5.11_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.12/S15.9.5.12_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.13/S15.9.5.13_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.14/S15.9.5.14_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.15/S15.9.5.15_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.16/S15.9.5.16_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.17/S15.9.5.17_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.18/S15.9.5.18_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.19/S15.9.5.19_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.20/S15.9.5.20_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.21/S15.9.5.21_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.22/S15.9.5.22_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.23/S15.9.5.23_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.24/S15.9.5.24_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.25/S15.9.5.25_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.26/S15.9.5.26_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.27/S15.9.5.27_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.28/S15.9.5.28_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.29/S15.9.5.29_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.30/S15.9.5.30_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.31/S15.9.5.31_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.32/S15.9.5.32_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.33/S15.9.5.33_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.34/S15.9.5.34_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.35/S15.9.5.35_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.36/S15.9.5.36_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.37/S15.9.5.37_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.38/S15.9.5.38_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.39/S15.9.5.39_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.40/S15.9.5.40_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.41/S15.9.5.41_A3_T2.js\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.42/S15.9.5.42_A3_T2.js\ntest262o/test/suite/ch15/15.10/15.10.6/15.10.6.2/S15.10.6.2_A9.js\ntest262o/test/suite/ch15/15.10/15.10.6/15.10.6.3/S15.10.6.3_A9.js\ntest262o/test/suite/ch15/15.10/15.10.6/15.10.6.4/S15.10.6.4_A9.js\n\n# ES6 != ES5: object literals may have duplicates\ntest262o/test/suite/ch11/11.1/11.1.5/11.1.5-4-4-a-1-s.js\ntest262o/test/suite/ch11/11.1/11.1.5/11.1.5_4-4-b-1.js\ntest262o/test/suite/ch11/11.1/11.1.5/11.1.5_4-4-b-2.js\ntest262o/test/suite/ch11/11.1/11.1.5/11.1.5_4-4-c-1.js\ntest262o/test/suite/ch11/11.1/11.1.5/11.1.5_4-4-c-2.js\ntest262o/test/suite/ch11/11.1/11.1.5/11.1.5_4-4-d-1.js\ntest262o/test/suite/ch11/11.1/11.1.5/11.1.5_4-4-d-2.js\ntest262o/test/suite/ch11/11.1/11.1.5/11.1.5_4-4-d-3.js\ntest262o/test/suite/ch11/11.1/11.1.5/11.1.5_4-4-d-4.js\n\n# ES6 != ES5: Date.prototype is no longer an instance of Date\ntest262o/test/suite/ch15/15.9/15.9.5/15.9.5.40/15.9.5.40_1.js\n\n# ES6 != ES5: Object.getPrototypeOf converts argument to object\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.2/15.2.3.2-1-3.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.2/15.2.3.2-1-4.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.2/15.2.3.2-1.js\n\n# ES6 != ES5: Object.getPrototypeOf(NativeError)\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.2/15.2.3.2-2-12.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.2/15.2.3.2-2-13.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.2/15.2.3.2-2-14.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.2/15.2.3.2-2-15.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.2/15.2.3.2-2-16.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.2/15.2.3.2-2-17.js\n\n# ES6 != ES5: Object.getOwnPropertyDescriptor converts argument to object\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-1-3.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-1-4.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-1.js\n\n# ES6 != ES5: Object.getOwnPropertyNames converts argument to object\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.4/15.2.3.4-1-4.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.4/15.2.3.4-1-5.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.4/15.2.3.4-1.js\n\n# ES6 != ES5: Object.seal accepts all types\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.8/15.2.3.8-1-1.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.8/15.2.3.8-1-2.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.8/15.2.3.8-1-3.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.8/15.2.3.8-1-4.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.8/15.2.3.8-1.js\n\n# ES6 != ES5: Object.freeze accepts all types\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.9/15.2.3.9-1-1.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.9/15.2.3.9-1-2.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.9/15.2.3.9-1-3.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.9/15.2.3.9-1-4.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.9/15.2.3.9-1.js\n\n# ES6 != ES5: Object.preventExtensions accepts all types\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.10/15.2.3.10-1-1.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.10/15.2.3.10-1-2.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.10/15.2.3.10-1-3.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.10/15.2.3.10-1-4.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.10/15.2.3.10-1.js\n\n# ES6 != ES5: Object.isSealed accepts all types\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.11/15.2.3.11-1.js\n\n# ES6 != ES5: Object.isFrozen accepts all types\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.12/15.2.3.12-1-1.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.12/15.2.3.12-1-2.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.12/15.2.3.12-1-3.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.12/15.2.3.12-1-4.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.12/15.2.3.12-1.js\n\n# ES6 != ES5: Object.isExtensible accepts all types\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.13/15.2.3.13-1-1.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.13/15.2.3.13-1-2.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.13/15.2.3.13-1-3.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.13/15.2.3.13-1-4.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.13/15.2.3.13-1.js\n\n# ES6 != ES5: Object.keys converts argument to object\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.14/15.2.3.14-1-1.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.14/15.2.3.14-1-2.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.14/15.2.3.14-1-3.js\n\n# ES6 != ES5: source and other properties of RegExp.prototype are not own properties\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-4-212.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-4-213.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-4-214.js\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.3/15.2.3.3-4-215.js\n\n# ES6 != ES5: String numeric object properties are enumerated first\ntest262o/test/suite/ch15/15.2/15.2.3/15.2.3.4/15.2.3.4-4-44.js\n\n# ES6: new RegExp(regex, flags) is valid\ntest262o/test/suite/ch15/15.10/15.10.3/S15.10.3.1_A2_T1.js\ntest262o/test/suite/ch15/15.10/15.10.3/S15.10.3.1_A2_T2.js\ntest262o/test/suite/ch15/15.10/15.10.4/15.10.4.1/15.10.4.1-1.js\ntest262o/test/suite/ch15/15.10/15.10.4/S15.10.4.1_A2_T1.js\ntest262o/test/suite/ch15/15.10/15.10.4/S15.10.4.1_A2_T2.js\n\n# ES6 != ES5: RegExp.prototype.test behavior\ntest262o/test/suite/ch15/15.10/15.10.6/15.10.6.2/S15.10.6.2_A5_T3.js\n\n# ES6 != ES5: source, global, ignoreCase, multiline, lastIndex are not data properties\n# of RegExp objects and RegExp.prototype is not a RegExp object\ntest262o/test/suite/ch15/15.10/15.10.6/15.10.6.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.1/15.10.7.1-1.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.1/15.10.7.1-2.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.1/S15.10.7.1_A8.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.1/S15.10.7.1_A9.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.1/S15.10.7.1_A10.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.2/15.10.7.2-1.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.2/15.10.7.2-2.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.2/S15.10.7.2_A8.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.2/S15.10.7.2_A9.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.2/S15.10.7.2_A10.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.3/15.10.7.3-1.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.3/15.10.7.3-2.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.3/S15.10.7.3_A8.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.3/S15.10.7.3_A9.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.3/S15.10.7.3_A10.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.4/15.10.7.4-1.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.4/15.10.7.4-2.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.4/S15.10.7.4_A8.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.4/S15.10.7.4_A9.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.4/S15.10.7.4_A10.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.5/15.10.7.5-1.js\ntest262o/test/suite/ch15/15.10/15.10.7/15.10.7.5/15.10.7.5-2.js\n\n# ES6 != ES5: Error.prototype is a normal object\ntest262o/test/suite/ch15/15.11/15.11.4/S15.11.4_A2.js\n\n# ES6 different ToLength() semantics\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.5/S15.4.4.5_A4_T3.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.6/S15.4.4.6_A2_T2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.6/S15.4.4.6_A3_T1.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.6/S15.4.4.6_A3_T2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.6/S15.4.4.6_A3_T3.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.7/S15.4.4.7_A2_T2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.7/S15.4.4.7_A4_T1.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.7/S15.4.4.7_A4_T3.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.8/S15.4.4.8_A3_T3.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.9/S15.4.4.9_A3_T3.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.10/S15.4.4.10_A3_T1.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.10/S15.4.4.10_A3_T2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.10/S15.4.4.10_A3_T3.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.11/S15.4.4.11_A4_T3.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.12/S15.4.4.12_A3_T1.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.12/S15.4.4.12_A3_T3.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.13/S15.4.4.13_A3_T2.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.14/15.4.4.14-3-7.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.14/15.4.4.14-3-8.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.14/15.4.4.14-3-12.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.14/15.4.4.14-3-14.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.14/15.4.4.14-3-25.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.14/15.4.4.14-3-28.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.14/15.4.4.14-3-29.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.15/15.4.4.15-3-7.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.15/15.4.4.15-3-12.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.15/15.4.4.15-3-25.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.15/15.4.4.15-3-28.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.16/15.4.4.16-3-7.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.16/15.4.4.16-3-8.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.16/15.4.4.16-3-12.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.16/15.4.4.16-3-14.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.16/15.4.4.16-3-25.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.16/15.4.4.16-3-29.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.17/15.4.4.17-3-7.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.17/15.4.4.17-3-8.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.17/15.4.4.17-3-12.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.17/15.4.4.17-3-14.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.17/15.4.4.17-3-25.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.17/15.4.4.17-3-28.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.17/15.4.4.17-3-29.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.18/15.4.4.18-3-7.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.18/15.4.4.18-3-12.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.18/15.4.4.18-3-25.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.19/15.4.4.19-3-7.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.19/15.4.4.19-3-8.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.19/15.4.4.19-3-12.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.19/15.4.4.19-3-14.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.19/15.4.4.19-3-25.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.19/15.4.4.19-3-28.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.19/15.4.4.19-3-29.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.20/15.4.4.20-3-7.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.20/15.4.4.20-3-12.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.20/15.4.4.20-3-25.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.21/15.4.4.21-3-7.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.21/15.4.4.21-3-12.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.21/15.4.4.21-3-25.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.22/15.4.4.22-3-7.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.22/15.4.4.22-3-12.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.22/15.4.4.22-3-25.js\n\n# ES6 different ToLength() semantics causes near infinite runtime\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.15/15.4.4.15-3-14.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.18/15.4.4.18-3-14.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.20/15.4.4.20-3-14.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.21/15.4.4.21-3-14.js\ntest262o/test/suite/ch15/15.4/15.4.4/15.4.4.22/15.4.4.22-3-14.js\n\n# ES6 arguments/caller changes\ntest262o/test/suite/ch10/10.6/10.6-13-b-1-s.js\ntest262o/test/suite/ch10/10.6/10.6-13-b-2-s.js\ntest262o/test/suite/ch10/10.6/10.6-13-b-3-s.js\ntest262o/test/suite/ch10/10.6/10.6-14-1-s.js\ntest262o/test/suite/ch10/10.6/10.6-14-b-1-s.js\ntest262o/test/suite/ch10/10.6/10.6-14-b-4-s.js\ntest262o/test/suite/ch13/13.2/13.2-29-s.js\ntest262o/test/suite/ch13/13.2/13.2-30-s.js\ntest262o/test/suite/ch13/13.2/13.2-31-s.js\ntest262o/test/suite/ch13/13.2/13.2-32-s.js\ntest262o/test/suite/ch13/13.2/13.2-33-s.js\ntest262o/test/suite/ch13/13.2/13.2-34-s.js\ntest262o/test/suite/ch13/13.2/13.2-35-s.js\ntest262o/test/suite/ch13/13.2/13.2-36-s.js\ntest262o/test/suite/ch13/13.2/S13.2.3_A1.js\ntest262o/test/suite/ch15/15.3/15.3.4/15.3.4.5/15.3.4.5-20-1.js\ntest262o/test/suite/ch15/15.3/15.3.4/15.3.4.5/15.3.4.5-20-4.js\ntest262o/test/suite/ch15/15.3/15.3.4/15.3.4.5/15.3.4.5-20-5.js\ntest262o/test/suite/ch15/15.3/15.3.4/15.3.4.5/15.3.4.5-21-1.js\ntest262o/test/suite/ch15/15.3/15.3.4/15.3.4.5/15.3.4.5-21-4.js\ntest262o/test/suite/ch15/15.3/15.3.4/15.3.4.5/15.3.4.5-21-5.js\n\n# u180e is no longer considered as a space\ntest262o/test/suite/ch09/9.3/9.3.1/S9.3.1_A2.js\ntest262o/test/suite/ch09/9.3/9.3.1/S9.3.1_A3_T1.js\ntest262o/test/suite/ch09/9.3/9.3.1/S9.3.1_A3_T2.js\ntest262o/test/suite/ch15/15.1/15.1.2/15.1.2.2/S15.1.2.2_A2_T10.js\ntest262o/test/suite/ch15/15.1/15.1.2/15.1.2.3/S15.1.2.3_A2_T10.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.20/15.5.4.20-3-2.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.20/15.5.4.20-3-3.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.20/15.5.4.20-3-4.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.20/15.5.4.20-3-5.js\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.20/15.5.4.20-3-6.js\ntest262o/test/suite/ch15/15.10/15.10.2/15.10.2.12/S15.10.2.12_A1_T1.js\ntest262o/test/suite/ch15/15.10/15.10.2/15.10.2.12/S15.10.2.12_A2_T1.js\n\n# E6 eval return value is different\ntest262o/test/suite/ch12/12.6/12.6.3/S12.6.3_A9.js\ntest262o/test/suite/ch12/12.6/12.6.3/S12.6.3_A9.1.js\n\n# ECMA 2019 optional-catch-binding feature allows try{}catch{}\ntest262o/test/suite/ch12/12.14/S12.14_A16_T4.js\n\n# Syntax error instead of ReferenceError in ES2020\ntest262o/test/suite/ch11/11.13/11.13.1/11.13.1-1-1.js\ntest262o/test/suite/ch11/11.13/11.13.1/11.13.1-1-2.js\ntest262o/test/suite/ch11/11.13/11.13.1/11.13.1-1-3.js\ntest262o/test/suite/ch11/11.13/11.13.1/11.13.1-1-4.js\n\n# String.prototype.localeCompare special cases\ntest262o/test/suite/ch15/15.5/15.5.4/15.5.4.9/15.5.4.9_CE.js\n\n[tests]\n# list test files or use config.testdir\n"
        },
        {
          "name": "test262o_errors.txt",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "unicode_download.sh",
          "type": "blob",
          "size": 0.4658203125,
          "content": "#!/bin/sh\nset -e\n\nurl=\"ftp://ftp.unicode.org/Public/15.0.0/ucd\"\nemoji_url=\"${url}/emoji/emoji-data.txt\"\n\nfiles=\"CaseFolding.txt DerivedNormalizationProps.txt PropList.txt \\\nSpecialCasing.txt CompositionExclusions.txt ScriptExtensions.txt \\\nUnicodeData.txt DerivedCoreProperties.txt NormalizationTest.txt Scripts.txt \\\nPropertyValueAliases.txt\"\n\nmkdir -p unicode\n\nfor f in $files; do\n    g=\"${url}/${f}\"\n    wget $g -O unicode/$f\ndone\n\nwget $emoji_url -O unicode/emoji-data.txt\n"
        },
        {
          "name": "unicode_gen.c",
          "type": "blob",
          "size": 86.8896484375,
          "content": "/*\n * Generation of Unicode tables\n *\n * Copyright (c) 2017-2018 Fabrice Bellard\n * Copyright (c) 2017-2018 Charlie Gordon\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <string.h>\n#include <assert.h>\n#include <ctype.h>\n#include <time.h>\n\n#include \"cutils.h\"\n\nuint32_t total_tables;\nuint32_t total_table_bytes;\nuint32_t total_index;\nuint32_t total_index_bytes;\n\n/* define it to be able to test unicode.c */\n//#define USE_TEST\n/* profile tests */\n//#define PROFILE\n\n//#define DUMP_CASE_CONV_TABLE\n//#define DUMP_TABLE_SIZE\n//#define DUMP_CC_TABLE\n//#define DUMP_DECOMP_TABLE\n//#define DUMP_CASE_FOLDING_SPECIAL_CASES\n\n/* Ideas:\n   - Generalize run length encoding + index for all tables\n   - remove redundant tables for ID_start, ID_continue, Case_Ignorable, Cased\n\n   Case conversion:\n   - use a single entry for consecutive U/LF runs\n   - allow EXT runs of length > 1\n\n   Decomposition:\n   - Greek lower case (+1f10/1f10) ?\n   - allow holes in B runs\n   - suppress more upper / lower case redundancy\n*/\n\n#ifdef USE_TEST\n#include \"libunicode.c\"\n#endif\n\n#define CHARCODE_MAX 0x10ffff\n#define CC_LEN_MAX 3\n\nvoid *mallocz(size_t size)\n{\n    void *ptr;\n    ptr = malloc(size);\n    memset(ptr, 0, size);\n    return ptr;\n}\n\nconst char *get_field(const char *p, int n)\n{\n    int i;\n    for(i = 0; i < n; i++) {\n        while (*p != ';' && *p != '\\0')\n            p++;\n        if (*p == '\\0')\n            return NULL;\n        p++;\n    }\n    return p;\n}\n\nconst char *get_field_buf(char *buf, size_t buf_size, const char *p, int n)\n{\n    char *q;\n    p = get_field(p, n);\n    q = buf;\n    while (*p != ';' && *p != '\\0') {\n        if ((q - buf) < buf_size - 1)\n            *q++ = *p;\n        p++;\n    }\n    *q = '\\0';\n    return buf;\n}\n\nvoid add_char(int **pbuf, int *psize, int *plen, int c)\n{\n    int len, size, *buf;\n    buf = *pbuf;\n    size = *psize;\n    len = *plen;\n    if (len >= size) {\n        size = *psize;\n        size = max_int(len + 1, size * 3 / 2);\n        buf = realloc(buf, sizeof(buf[0]) * size);\n        *pbuf = buf;\n        *psize = size;\n    }\n    buf[len++] = c;\n    *plen = len;\n}\n\nint *get_field_str(int *plen, const char *str, int n)\n{\n    const char *p;\n    int *buf, len, size;\n    p = get_field(str, n);\n    if (!p) {\n        *plen = 0;\n        return NULL;\n    }\n    len = 0;\n    size = 0;\n    buf = NULL;\n    for(;;) {\n        while (isspace(*p))\n            p++;\n        if (!isxdigit(*p))\n            break;\n        add_char(&buf, &size, &len, strtoul(p, (char **)&p, 16));\n    }\n    *plen = len;\n    return buf;\n}\n\nchar *get_line(char *buf, int buf_size, FILE *f)\n{\n    int len;\n    if (!fgets(buf, buf_size, f))\n        return NULL;\n    len = strlen(buf);\n    if (len > 0 && buf[len - 1] == '\\n')\n        buf[len - 1] = '\\0';\n    return buf;\n}\n\n#define UNICODE_GENERAL_CATEGORY\n\ntypedef enum {\n#define DEF(id, str) GCAT_ ## id,\n#include \"unicode_gen_def.h\"\n#undef DEF\n    GCAT_COUNT,\n} UnicodeGCEnum1;\n\nstatic const char *unicode_gc_name[] = {\n#define DEF(id, str) #id,\n#include \"unicode_gen_def.h\"\n#undef DEF\n};\n\nstatic const char *unicode_gc_short_name[] = {\n#define DEF(id, str) str,\n#include \"unicode_gen_def.h\"\n#undef DEF\n};\n\n#undef UNICODE_GENERAL_CATEGORY\n\n#define UNICODE_SCRIPT\n\ntypedef enum {\n#define DEF(id, str) SCRIPT_ ## id,\n#include \"unicode_gen_def.h\"\n#undef DEF\n    SCRIPT_COUNT,\n} UnicodeScriptEnum1;\n\nstatic const char *unicode_script_name[] = {\n#define DEF(id, str) #id,\n#include \"unicode_gen_def.h\"\n#undef DEF\n};\n\nconst char *unicode_script_short_name[] = {\n#define DEF(id, str) str,\n#include \"unicode_gen_def.h\"\n#undef DEF\n};\n\n#undef UNICODE_SCRIPT\n\n#define UNICODE_PROP_LIST\n\ntypedef enum {\n#define DEF(id, str) PROP_ ## id,\n#include \"unicode_gen_def.h\"\n#undef DEF\n    PROP_COUNT,\n} UnicodePropEnum1;\n\nstatic const char *unicode_prop_name[] = {\n#define DEF(id, str) #id,\n#include \"unicode_gen_def.h\"\n#undef DEF\n};\n\nstatic const char *unicode_prop_short_name[] = {\n#define DEF(id, str) str,\n#include \"unicode_gen_def.h\"\n#undef DEF\n};\n\n#undef UNICODE_PROP_LIST\n\ntypedef struct {\n    /* case conv */\n    uint8_t u_len;\n    uint8_t l_len;\n    uint8_t f_len;\n    int u_data[CC_LEN_MAX]; /* to upper case */\n    int l_data[CC_LEN_MAX]; /* to lower case */\n    int f_data[CC_LEN_MAX]; /* to case folding */\n\n    uint8_t combining_class;\n    uint8_t is_compat:1;\n    uint8_t is_excluded:1;\n    uint8_t general_category;\n    uint8_t script;\n    uint8_t script_ext_len;\n    uint8_t *script_ext;\n    uint32_t prop_bitmap_tab[3];\n    /* decomposition */\n    int decomp_len;\n    int *decomp_data;\n} CCInfo;\n\nCCInfo *unicode_db;\n\nint find_name(const char **tab, int tab_len, const char *name)\n{\n    int i, len, name_len;\n    const char *p, *r;\n\n    name_len = strlen(name);\n    for(i = 0; i < tab_len; i++) {\n        p = tab[i];\n        for(;;) {\n            r = strchr(p, ',');\n            if (!r)\n                len = strlen(p);\n            else\n                len = r - p;\n            if (len == name_len && memcmp(p, name, len) == 0)\n                return i;\n            if (!r)\n                break;\n            p = r + 1;\n        }\n    }\n    return -1;\n}\n\nstatic BOOL get_prop(uint32_t c, int prop_idx)\n{\n    return (unicode_db[c].prop_bitmap_tab[prop_idx >> 5] >> (prop_idx & 0x1f)) & 1;\n}\n\nstatic void set_prop(uint32_t c, int prop_idx, int val)\n{\n    uint32_t mask;\n    mask = 1U << (prop_idx & 0x1f);\n    if (val)\n        unicode_db[c].prop_bitmap_tab[prop_idx >> 5] |= mask;\n    else\n        unicode_db[c].prop_bitmap_tab[prop_idx >> 5]  &= ~mask;\n}\n\nvoid parse_unicode_data(const char *filename)\n{\n    FILE *f;\n    char line[1024];\n    char buf1[256];\n    const char *p;\n    int code, lc, uc, last_code;\n    CCInfo *ci, *tab = unicode_db;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror(filename);\n        exit(1);\n    }\n\n    last_code = 0;\n    for(;;) {\n        if (!get_line(line, sizeof(line), f))\n            break;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '#')\n            continue;\n\n        p = get_field(line, 0);\n        if (!p)\n            continue;\n        code = strtoul(p, NULL, 16);\n        lc = 0;\n        uc = 0;\n\n        p = get_field(line, 12);\n        if (p && *p != ';') {\n            uc = strtoul(p, NULL, 16);\n        }\n\n        p = get_field(line, 13);\n        if (p && *p != ';') {\n            lc = strtoul(p, NULL, 16);\n        }\n        ci = &tab[code];\n        if (uc > 0 || lc > 0) {\n            assert(code <= CHARCODE_MAX);\n            if (uc > 0) {\n                assert(ci->u_len == 0);\n                ci->u_len = 1;\n                ci->u_data[0] = uc;\n            }\n            if (lc > 0) {\n                assert(ci->l_len == 0);\n                ci->l_len = 1;\n                ci->l_data[0] = lc;\n            }\n        }\n\n        {\n            int i;\n            get_field_buf(buf1, sizeof(buf1), line, 2);\n            i = find_name(unicode_gc_name, countof(unicode_gc_name), buf1);\n            if (i < 0) {\n                fprintf(stderr, \"General category '%s' not found\\n\",\n                        buf1);\n                exit(1);\n            }\n            ci->general_category = i;\n        }\n\n        p = get_field(line, 3);\n        if (p && *p != ';' && *p != '\\0') {\n            int cc;\n            cc = strtoul(p, NULL, 0);\n            if (cc != 0) {\n                assert(code <= CHARCODE_MAX);\n                ci->combining_class = cc;\n                //                printf(\"%05x: %d\\n\", code, ci->combining_class);\n            }\n        }\n\n        p = get_field(line, 5);\n        if (p && *p != ';' && *p != '\\0') {\n            int size;\n            assert(code <= CHARCODE_MAX);\n            ci->is_compat = 0;\n            if (*p == '<') {\n                while (*p != '\\0' && *p != '>')\n                    p++;\n                if (*p == '>')\n                    p++;\n                ci->is_compat = 1;\n            }\n            size = 0;\n            for(;;) {\n                while (isspace(*p))\n                    p++;\n                if (!isxdigit(*p))\n                    break;\n                add_char(&ci->decomp_data, &size, &ci->decomp_len, strtoul(p, (char **)&p, 16));\n            }\n#if 0\n            {\n                int i;\n                static int count, d_count;\n\n                printf(\"%05x: %c\", code, ci->is_compat ? 'C': ' ');\n                for(i = 0; i < ci->decomp_len; i++)\n                    printf(\" %05x\", ci->decomp_data[i]);\n                printf(\"\\n\");\n                count++;\n                d_count += ci->decomp_len;\n                //                printf(\"%d %d\\n\", count, d_count);\n            }\n#endif\n        }\n\n        p = get_field(line, 9);\n        if (p && *p == 'Y') {\n            set_prop(code, PROP_Bidi_Mirrored, 1);\n        }\n\n        /* handle ranges */\n        get_field_buf(buf1, sizeof(buf1), line, 1);\n        if (strstr(buf1, \" Last>\")) {\n            int i;\n            //            printf(\"range: 0x%x-%0x\\n\", last_code, code);\n            assert(ci->decomp_len == 0);\n            assert(ci->script_ext_len == 0);\n            for(i = last_code + 1; i < code; i++) {\n                unicode_db[i] = *ci;\n            }\n        }\n        last_code = code;\n    }\n\n    fclose(f);\n}\n\nvoid parse_special_casing(CCInfo *tab, const char *filename)\n{\n    FILE *f;\n    char line[1024];\n    const char *p;\n    int code;\n    CCInfo *ci;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror(filename);\n        exit(1);\n    }\n\n    for(;;) {\n        if (!get_line(line, sizeof(line), f))\n            break;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '#')\n            continue;\n\n        p = get_field(line, 0);\n        if (!p)\n            continue;\n        code = strtoul(p, NULL, 16);\n        assert(code <= CHARCODE_MAX);\n        ci = &tab[code];\n\n        p = get_field(line, 4);\n        if (p) {\n            /* locale dependent casing */\n            while (isspace(*p))\n                p++;\n            if (*p != '#' && *p != '\\0')\n                continue;\n        }\n\n\n        p = get_field(line, 1);\n        if (p && *p != ';') {\n            ci->l_len = 0;\n            for(;;) {\n                while (isspace(*p))\n                    p++;\n                if (*p == ';')\n                    break;\n                assert(ci->l_len < CC_LEN_MAX);\n                ci->l_data[ci->l_len++] = strtoul(p, (char **)&p, 16);\n            }\n\n            if (ci->l_len == 1 && ci->l_data[0] == code)\n                ci->l_len = 0;\n        }\n\n        p = get_field(line, 3);\n        if (p && *p != ';') {\n            ci->u_len = 0;\n            for(;;) {\n                while (isspace(*p))\n                    p++;\n                if (*p == ';')\n                    break;\n                assert(ci->u_len < CC_LEN_MAX);\n                ci->u_data[ci->u_len++] = strtoul(p, (char **)&p, 16);\n            }\n\n            if (ci->u_len == 1 && ci->u_data[0] == code)\n                ci->u_len = 0;\n        }\n    }\n\n    fclose(f);\n}\n\nvoid parse_case_folding(CCInfo *tab, const char *filename)\n{\n    FILE *f;\n    char line[1024];\n    const char *p;\n    int code, status;\n    CCInfo *ci;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror(filename);\n        exit(1);\n    }\n\n    for(;;) {\n        if (!get_line(line, sizeof(line), f))\n            break;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '#')\n            continue;\n\n        p = get_field(line, 0);\n        if (!p)\n            continue;\n        code = strtoul(p, NULL, 16);\n        assert(code <= CHARCODE_MAX);\n        ci = &tab[code];\n\n        p = get_field(line, 1);\n        if (!p)\n            continue;\n        /* locale dependent casing */\n        while (isspace(*p))\n            p++;\n        status = *p;\n        if (status != 'C' && status != 'S' && status != 'F')\n            continue;\n\n        p = get_field(line, 2);\n        assert(p != NULL);\n        if (status == 'S') {\n            /* we always select the simple case folding and assume it\n             * comes after the full case folding case */\n            assert(ci->f_len >= 2);\n            ci->f_len = 0;\n        } else {\n            assert(ci->f_len == 0);\n        }\n        for(;;) {\n            while (isspace(*p))\n                p++;\n            if (*p == ';')\n                break;\n            assert(ci->l_len < CC_LEN_MAX);\n            ci->f_data[ci->f_len++] = strtoul(p, (char **)&p, 16);\n        }\n    }\n\n    fclose(f);\n}\n\nvoid parse_composition_exclusions(const char *filename)\n{\n    FILE *f;\n    char line[4096], *p;\n    uint32_t c0;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror(filename);\n        exit(1);\n    }\n\n    for(;;) {\n        if (!get_line(line, sizeof(line), f))\n            break;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '#' || *p == '@' || *p == '\\0')\n            continue;\n        c0 = strtoul(p, (char **)&p, 16);\n        assert(c0 > 0 && c0 <= CHARCODE_MAX);\n        unicode_db[c0].is_excluded = TRUE;\n    }\n    fclose(f);\n}\n\nvoid parse_derived_core_properties(const char *filename)\n{\n    FILE *f;\n    char line[4096], *p, buf[256], *q;\n    uint32_t c0, c1, c;\n    int i;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror(filename);\n        exit(1);\n    }\n\n    for(;;) {\n        if (!get_line(line, sizeof(line), f))\n            break;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '#' || *p == '@' || *p == '\\0')\n            continue;\n        c0 = strtoul(p, (char **)&p, 16);\n        if (*p == '.' && p[1] == '.') {\n            p += 2;\n            c1 = strtoul(p, (char **)&p, 16);\n        } else {\n            c1 = c0;\n        }\n        assert(c1 <= CHARCODE_MAX);\n        p += strspn(p, \" \\t\");\n        if (*p == ';') {\n            p++;\n            p += strspn(p, \" \\t\");\n            q = buf;\n            while (*p != '\\0' && *p != ' ' && *p != '#' && *p != '\\t') {\n                if ((q - buf) < sizeof(buf) - 1)\n                    *q++ = *p;\n                p++;\n            }\n            *q = '\\0';\n            i = find_name(unicode_prop_name,\n                          countof(unicode_prop_name), buf);\n            if (i < 0) {\n                if (!strcmp(buf, \"Grapheme_Link\"))\n                    goto next;\n                fprintf(stderr, \"Property not found: %s\\n\", buf);\n                exit(1);\n            }\n            for(c = c0; c <= c1; c++) {\n                set_prop(c, i, 1);\n            }\nnext: ;\n        }\n    }\n    fclose(f);\n}\n\nvoid parse_derived_norm_properties(const char *filename)\n{\n    FILE *f;\n    char line[4096], *p, buf[256], *q;\n    uint32_t c0, c1, c;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror(filename);\n        exit(1);\n    }\n\n    for(;;) {\n        if (!get_line(line, sizeof(line), f))\n            break;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '#' || *p == '@' || *p == '\\0')\n            continue;\n        c0 = strtoul(p, (char **)&p, 16);\n        if (*p == '.' && p[1] == '.') {\n            p += 2;\n            c1 = strtoul(p, (char **)&p, 16);\n        } else {\n            c1 = c0;\n        }\n        assert(c1 <= CHARCODE_MAX);\n        p += strspn(p, \" \\t\");\n        if (*p == ';') {\n            p++;\n            p += strspn(p, \" \\t\");\n            q = buf;\n            while (*p != '\\0' && *p != ' ' && *p != '#' && *p != '\\t') {\n                if ((q - buf) < sizeof(buf) - 1)\n                    *q++ = *p;\n                p++;\n            }\n            *q = '\\0';\n            if (!strcmp(buf, \"Changes_When_NFKC_Casefolded\")) {\n                for(c = c0; c <= c1; c++) {\n                    set_prop(c, PROP_Changes_When_NFKC_Casefolded, 1);\n                }\n            }\n        }\n    }\n    fclose(f);\n}\n\nvoid parse_prop_list(const char *filename)\n{\n    FILE *f;\n    char line[4096], *p, buf[256], *q;\n    uint32_t c0, c1, c;\n    int i;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror(filename);\n        exit(1);\n    }\n\n    for(;;) {\n        if (!get_line(line, sizeof(line), f))\n            break;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '#' || *p == '@' || *p == '\\0')\n            continue;\n        c0 = strtoul(p, (char **)&p, 16);\n        if (*p == '.' && p[1] == '.') {\n            p += 2;\n            c1 = strtoul(p, (char **)&p, 16);\n        } else {\n            c1 = c0;\n        }\n        assert(c1 <= CHARCODE_MAX);\n        p += strspn(p, \" \\t\");\n        if (*p == ';') {\n            p++;\n            p += strspn(p, \" \\t\");\n            q = buf;\n            while (*p != '\\0' && *p != ' ' && *p != '#' && *p != '\\t') {\n                if ((q - buf) < sizeof(buf) - 1)\n                    *q++ = *p;\n                p++;\n            }\n            *q = '\\0';\n            i = find_name(unicode_prop_name,\n                          countof(unicode_prop_name), buf);\n            if (i < 0) {\n                fprintf(stderr, \"Property not found: %s\\n\", buf);\n                exit(1);\n            }\n            for(c = c0; c <= c1; c++) {\n                set_prop(c, i, 1);\n            }\n        }\n    }\n    fclose(f);\n}\n\nvoid parse_scripts(const char *filename)\n{\n    FILE *f;\n    char line[4096], *p, buf[256], *q;\n    uint32_t c0, c1, c;\n    int i;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror(filename);\n        exit(1);\n    }\n\n    for(;;) {\n        if (!get_line(line, sizeof(line), f))\n            break;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '#' || *p == '@' || *p == '\\0')\n            continue;\n        c0 = strtoul(p, (char **)&p, 16);\n        if (*p == '.' && p[1] == '.') {\n            p += 2;\n            c1 = strtoul(p, (char **)&p, 16);\n        } else {\n            c1 = c0;\n        }\n        assert(c1 <= CHARCODE_MAX);\n        p += strspn(p, \" \\t\");\n        if (*p == ';') {\n            p++;\n            p += strspn(p, \" \\t\");\n            q = buf;\n            while (*p != '\\0' && *p != ' ' && *p != '#' && *p != '\\t') {\n                if ((q - buf) < sizeof(buf) - 1)\n                    *q++ = *p;\n                p++;\n            }\n            *q = '\\0';\n            i = find_name(unicode_script_name,\n                          countof(unicode_script_name), buf);\n            if (i < 0) {\n                fprintf(stderr, \"Unknown script: '%s'\\n\", buf);\n                exit(1);\n            }\n            for(c = c0; c <= c1; c++)\n                unicode_db[c].script = i;\n        }\n    }\n    fclose(f);\n}\n\nvoid parse_script_extensions(const char *filename)\n{\n    FILE *f;\n    char line[4096], *p, buf[256], *q;\n    uint32_t c0, c1, c;\n    int i;\n    uint8_t script_ext[255];\n    int script_ext_len;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror(filename);\n        exit(1);\n    }\n\n    for(;;) {\n        if (!get_line(line, sizeof(line), f))\n            break;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '#' || *p == '@' || *p == '\\0')\n            continue;\n        c0 = strtoul(p, (char **)&p, 16);\n        if (*p == '.' && p[1] == '.') {\n            p += 2;\n            c1 = strtoul(p, (char **)&p, 16);\n        } else {\n            c1 = c0;\n        }\n        assert(c1 <= CHARCODE_MAX);\n        p += strspn(p, \" \\t\");\n        script_ext_len = 0;\n        if (*p == ';') {\n            p++;\n            for(;;) {\n                p += strspn(p, \" \\t\");\n                q = buf;\n                while (*p != '\\0' && *p != ' ' && *p != '#' && *p != '\\t') {\n                    if ((q - buf) < sizeof(buf) - 1)\n                        *q++ = *p;\n                    p++;\n                }\n                *q = '\\0';\n                if (buf[0] == '\\0')\n                    break;\n                i = find_name(unicode_script_short_name,\n                              countof(unicode_script_short_name), buf);\n                if (i < 0) {\n                    fprintf(stderr, \"Script not found: %s\\n\", buf);\n                    exit(1);\n                }\n                assert(script_ext_len < sizeof(script_ext));\n                script_ext[script_ext_len++] = i;\n            }\n            for(c = c0; c <= c1; c++) {\n                CCInfo *ci = &unicode_db[c];\n                ci->script_ext_len = script_ext_len;\n                ci->script_ext = malloc(sizeof(ci->script_ext[0]) * script_ext_len);\n                for(i = 0; i < script_ext_len; i++)\n                    ci->script_ext[i] = script_ext[i];\n            }\n        }\n    }\n    fclose(f);\n}\n\nvoid dump_cc_info(CCInfo *ci, int i)\n{\n    int j;\n    printf(\"%05x:\", i);\n    if (ci->u_len != 0) {\n        printf(\" U:\");\n        for(j = 0; j < ci->u_len; j++)\n            printf(\" %05x\", ci->u_data[j]);\n    }\n    if (ci->l_len != 0) {\n        printf(\" L:\");\n        for(j = 0; j < ci->l_len; j++)\n            printf(\" %05x\", ci->l_data[j]);\n    }\n    if (ci->f_len != 0) {\n        printf(\" F:\");\n        for(j = 0; j < ci->f_len; j++)\n            printf(\" %05x\", ci->f_data[j]);\n    }\n    printf(\"\\n\");\n}\n\nvoid dump_unicode_data(CCInfo *tab)\n{\n    int i;\n    CCInfo *ci;\n    for(i = 0; i <= CHARCODE_MAX; i++) {\n        ci = &tab[i];\n        if (ci->u_len != 0 || ci->l_len != 0 || ci->f_len != 0) {\n            dump_cc_info(ci, i);\n        }\n    }\n}\n\nBOOL is_complicated_case(const CCInfo *ci)\n{\n    return (ci->u_len > 1 || ci->l_len > 1 ||\n            (ci->u_len > 0 && ci->l_len > 0) ||\n            (ci->f_len != ci->l_len) ||\n            (memcmp(ci->f_data, ci->l_data, ci->f_len * sizeof(ci->f_data[0])) != 0));\n}\n\n#ifndef USE_TEST\nenum {\n    RUN_TYPE_U,\n    RUN_TYPE_L,\n    RUN_TYPE_UF,\n    RUN_TYPE_LF,\n    RUN_TYPE_UL,\n    RUN_TYPE_LSU,\n    RUN_TYPE_U2L_399_EXT2,\n    RUN_TYPE_UF_D20,\n    RUN_TYPE_UF_D1_EXT,\n    RUN_TYPE_U_EXT,\n    RUN_TYPE_LF_EXT,\n    RUN_TYPE_UF_EXT2,\n    RUN_TYPE_LF_EXT2,\n    RUN_TYPE_UF_EXT3,\n};\n#endif\n\nconst char *run_type_str[] = {\n    \"U\",\n    \"L\",\n    \"UF\",\n    \"LF\",\n    \"UL\",\n    \"LSU\",\n    \"U2L_399_EXT2\",\n    \"UF_D20\",\n    \"UF_D1_EXT\",\n    \"U_EXT\",\n    \"LF_EXT\",\n    \"UF_EXT2\",\n    \"LF_EXT2\",\n    \"UF_EXT3\",\n};\n\ntypedef struct {\n    int code;\n    int len;\n    int type;\n    int data;\n    int ext_len;\n    int ext_data[3];\n    int data_index; /* 'data' coming from the table */\n} TableEntry;\n\nstatic int simple_to_lower(CCInfo *tab, int c)\n{\n    if (tab[c].l_len != 1)\n        return c;\n    return tab[c].l_data[0];\n}\n\n/* code (17), len (7), type (4) */\n\nvoid find_run_type(TableEntry *te, CCInfo *tab, int code)\n{\n    int is_lower, len;\n    CCInfo *ci, *ci1, *ci2;\n\n    ci = &tab[code];\n    ci1 = &tab[code + 1];\n    ci2 = &tab[code + 2];\n    te->code = code;\n\n    if (ci->l_len == 1 && ci->l_data[0] == code + 2 &&\n        ci->f_len == 1 && ci->f_data[0] == ci->l_data[0] &&\n        ci->u_len == 0 &&\n\n        ci1->l_len == 1 && ci1->l_data[0] == code + 2 &&\n        ci1->f_len == 1 && ci1->f_data[0] == ci1->l_data[0] &&\n        ci1->u_len == 1 && ci1->u_data[0] == code &&\n\n        ci2->l_len == 0 &&\n        ci2->f_len == 0 &&\n        ci2->u_len == 1 && ci2->u_data[0] == code) {\n        te->len = 3;\n        te->data = 0;\n        te->type = RUN_TYPE_LSU;\n        return;\n    }\n\n    if (is_complicated_case(ci)) {\n        len = 1;\n        while (code + len <= CHARCODE_MAX) {\n            ci1 = &tab[code + len];\n            if (ci1->u_len != 1 ||\n                ci1->u_data[0] != ci->u_data[0] + len ||\n                ci1->l_len != 0 ||\n                ci1->f_len != 1 || ci1->f_data[0] != ci1->u_data[0])\n                break;\n            len++;\n        }\n        if (len > 1) {\n            te->len = len;\n            te->type = RUN_TYPE_UF;\n            te->data = ci->u_data[0];\n            return;\n        }\n\n        if (ci->l_len == 0 &&\n            ci->u_len == 2 && ci->u_data[1] == 0x399 &&\n            ci->f_len == 2 && ci->f_data[1] == 0x3B9 &&\n            ci->f_data[0] == simple_to_lower(tab, ci->u_data[0])) {\n            len = 1;\n            while (code + len <= CHARCODE_MAX) {\n                ci1 = &tab[code + len];\n                if (!(ci1->u_len == 2 &&\n                      ci1->u_data[1] == ci->u_data[1] &&\n                      ci1->u_data[0] == ci->u_data[0] + len &&\n                      ci1->f_len == 2 &&\n                      ci1->f_data[1] == ci->f_data[1] &&\n                      ci1->f_data[0] == ci->f_data[0] + len &&\n                      ci1->l_len == 0))\n                    break;\n                len++;\n            }\n            te->len = len;\n            te->type = RUN_TYPE_UF_EXT2;\n            te->ext_data[0] = ci->u_data[0];\n            te->ext_data[1] = ci->u_data[1];\n            te->ext_len = 2;\n            return;\n        }\n\n        if (ci->u_len == 2 && ci->u_data[1] == 0x399 &&\n            ci->l_len == 1 &&\n            ci->f_len == 1 && ci->f_data[0] == ci->l_data[0]) {\n            len = 1;\n            while (code + len <= CHARCODE_MAX) {\n                ci1 = &tab[code + len];\n                if (!(ci1->u_len == 2 &&\n                      ci1->u_data[1] == 0x399 &&\n                      ci1->u_data[0] == ci->u_data[0] + len &&\n                      ci1->l_len == 1 &&\n                      ci1->l_data[0] == ci->l_data[0] + len &&\n                      ci1->f_len == 1 && ci1->f_data[0] == ci1->l_data[0]))\n                    break;\n                len++;\n            }\n            te->len = len;\n            te->type = RUN_TYPE_U2L_399_EXT2;\n            te->ext_data[0] = ci->u_data[0];\n            te->ext_data[1] = ci->l_data[0];\n            te->ext_len = 2;\n            return;\n        }\n\n        if (ci->l_len == 1 && ci->u_len == 0 && ci->f_len == 0) {\n            len = 1;\n            while (code + len <= CHARCODE_MAX) {\n                ci1 = &tab[code + len];\n                if (!(ci1->l_len == 1 &&\n                      ci1->l_data[0] == ci->l_data[0] + len &&\n                      ci1->u_len == 0 && ci1->f_len == 0))\n                    break;\n                len++;\n            }\n            te->len = len;\n            te->type = RUN_TYPE_L;\n            te->data = ci->l_data[0];\n            return;\n        }\n\n        if (ci->l_len == 0 &&\n            ci->u_len == 1 &&\n            ci->u_data[0] < 0x1000 &&\n            ci->f_len == 1 && ci->f_data[0] == ci->u_data[0] + 0x20) {\n            te->len = 1;\n            te->type = RUN_TYPE_UF_D20;\n            te->data = ci->u_data[0];\n        } else if (ci->l_len == 0 &&\n                   ci->u_len == 1 &&\n                   ci->f_len == 1 && ci->f_data[0] == ci->u_data[0] + 1) {\n            te->len = 1;\n            te->type = RUN_TYPE_UF_D1_EXT;\n            te->ext_data[0] = ci->u_data[0];\n            te->ext_len = 1;\n        } else if (ci->l_len == 2 && ci->u_len == 0 && ci->f_len == 2 &&\n                   ci->l_data[0] == ci->f_data[0] &&\n                   ci->l_data[1] == ci->f_data[1]) {\n            te->len = 1;\n            te->type = RUN_TYPE_LF_EXT2;\n            te->ext_data[0] = ci->l_data[0];\n            te->ext_data[1] = ci->l_data[1];\n            te->ext_len = 2;\n        } else if (ci->u_len == 2 && ci->l_len == 0 && ci->f_len == 2 &&\n                   ci->f_data[0] == simple_to_lower(tab, ci->u_data[0]) &&\n                   ci->f_data[1] == simple_to_lower(tab, ci->u_data[1])) {\n            te->len = 1;\n            te->type = RUN_TYPE_UF_EXT2;\n            te->ext_data[0] = ci->u_data[0];\n            te->ext_data[1] = ci->u_data[1];\n            te->ext_len = 2;\n        } else if (ci->u_len == 3 && ci->l_len == 0 && ci->f_len == 3 &&\n                   ci->f_data[0] == simple_to_lower(tab, ci->u_data[0]) &&\n                   ci->f_data[1] == simple_to_lower(tab, ci->u_data[1]) &&\n                   ci->f_data[2] == simple_to_lower(tab, ci->u_data[2])) {\n            te->len = 1;\n            te->type = RUN_TYPE_UF_EXT3;\n            te->ext_data[0] = ci->u_data[0];\n            te->ext_data[1] = ci->u_data[1];\n            te->ext_data[2] = ci->u_data[2];\n            te->ext_len = 3;\n        } else {\n            printf(\"unsupported encoding case:\\n\");\n            dump_cc_info(ci, code);\n            abort();\n        }\n    } else {\n        /* look for a run of identical conversions */\n        len = 0;\n        for(;;) {\n            if (code >= CHARCODE_MAX || len >= 126)\n                break;\n            ci = &tab[code + len];\n            ci1 = &tab[code + len + 1];\n            if (is_complicated_case(ci) || is_complicated_case(ci1)) {\n                break;\n            }\n            if (ci->l_len != 1 || ci->l_data[0] != code + len + 1)\n                break;\n            if (ci1->u_len != 1 || ci1->u_data[0] != code + len)\n                break;\n            len += 2;\n        }\n        if (len > 0) {\n            te->len = len;\n            te->type = RUN_TYPE_UL;\n            te->data = 0;\n            return;\n        }\n\n        ci = &tab[code];\n        is_lower = ci->l_len > 0;\n        len = 1;\n        while (code + len <= CHARCODE_MAX) {\n            ci1 = &tab[code + len];\n            if (is_complicated_case(ci1))\n                break;\n            if (is_lower) {\n                if (ci1->l_len != 1 ||\n                    ci1->l_data[0] != ci->l_data[0] + len)\n                    break;\n            } else {\n                if (ci1->u_len != 1 ||\n                    ci1->u_data[0] != ci->u_data[0] + len)\n                    break;\n            }\n            len++;\n        }\n        te->len = len;\n        if (is_lower) {\n            te->type = RUN_TYPE_LF;\n            te->data = ci->l_data[0];\n        } else {\n            te->type = RUN_TYPE_U;\n            te->data = ci->u_data[0];\n        }\n    }\n}\n\nTableEntry conv_table[1000];\nint conv_table_len;\nint ext_data[1000];\nint ext_data_len;\n\nvoid dump_case_conv_table1(void)\n{\n    int i, j;\n    const TableEntry *te;\n\n    for(i = 0; i < conv_table_len; i++) {\n        te = &conv_table[i];\n        printf(\"%05x %02x %-10s %05x\",\n               te->code, te->len, run_type_str[te->type], te->data);\n        for(j = 0; j < te->ext_len; j++) {\n            printf(\" %05x\", te->ext_data[j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"table_len=%d ext_len=%d\\n\", conv_table_len, ext_data_len);\n}\n\nint find_data_index(const TableEntry *conv_table, int len, int data)\n{\n    int i;\n    const TableEntry *te;\n    for(i = 0; i < len; i++) {\n        te = &conv_table[i];\n        if (te->code == data)\n            return i;\n    }\n    return -1;\n}\n\nint find_ext_data_index(int data)\n{\n    int i;\n    for(i = 0; i < ext_data_len; i++) {\n        if (ext_data[i] == data)\n            return i;\n    }\n    assert(ext_data_len < countof(ext_data));\n    ext_data[ext_data_len++] = data;\n    return ext_data_len - 1;\n}\n\nvoid build_conv_table(CCInfo *tab)\n{\n    int code, i, j;\n    CCInfo *ci;\n    TableEntry *te;\n\n    te = conv_table;\n    for(code = 0; code <= CHARCODE_MAX; code++) {\n        ci = &tab[code];\n        if (ci->u_len == 0 && ci->l_len == 0 && ci->f_len == 0)\n            continue;\n        assert(te - conv_table < countof(conv_table));\n        find_run_type(te, tab, code);\n#if 0\n        if (te->type == RUN_TYPE_TODO) {\n            printf(\"TODO: \");\n            dump_cc_info(ci, code);\n        }\n#endif\n        assert(te->len <= 127);\n        code += te->len - 1;\n        te++;\n    }\n    conv_table_len = te - conv_table;\n\n    /* find the data index */\n    for(i = 0; i < conv_table_len; i++) {\n        int data_index;\n        te = &conv_table[i];\n\n        switch(te->type) {\n        case RUN_TYPE_U:\n        case RUN_TYPE_L:\n        case RUN_TYPE_UF:\n        case RUN_TYPE_LF:\n            data_index = find_data_index(conv_table, conv_table_len, te->data);\n            if (data_index < 0) {\n                switch(te->type) {\n                case RUN_TYPE_U:\n                    te->type = RUN_TYPE_U_EXT;\n                    te->ext_len = 1;\n                    te->ext_data[0] = te->data;\n                    break;\n                case RUN_TYPE_LF:\n                    te->type = RUN_TYPE_LF_EXT;\n                    te->ext_len = 1;\n                    te->ext_data[0] = te->data;\n                    break;\n                default:\n                    printf(\"%05x: index not found\\n\", te->code);\n                    exit(1);\n                }\n            } else {\n                te->data_index = data_index;\n            }\n            break;\n        case RUN_TYPE_UF_D20:\n            te->data_index = te->data;\n            break;\n        }\n    }\n\n    /* find the data index for ext_data */\n    for(i = 0; i < conv_table_len; i++) {\n        te = &conv_table[i];\n        if (te->type == RUN_TYPE_UF_EXT3) {\n            int p, v;\n            v = 0;\n            for(j = 0; j < 3; j++) {\n                p = find_ext_data_index(te->ext_data[j]);\n                assert(p < 16);\n                v = (v << 4) | p;\n            }\n            te->data_index = v;\n        }\n    }\n\n    for(i = 0; i < conv_table_len; i++) {\n        te = &conv_table[i];\n        if (te->type == RUN_TYPE_LF_EXT2 ||\n            te->type == RUN_TYPE_UF_EXT2 ||\n            te->type == RUN_TYPE_U2L_399_EXT2) {\n            int p, v;\n            v = 0;\n            for(j = 0; j < 2; j++) {\n                p = find_ext_data_index(te->ext_data[j]);\n                assert(p < 64);\n                v = (v << 6) | p;\n            }\n            te->data_index = v;\n        }\n    }\n\n    for(i = 0; i < conv_table_len; i++) {\n        te = &conv_table[i];\n        if (te->type == RUN_TYPE_UF_D1_EXT ||\n            te->type == RUN_TYPE_U_EXT ||\n            te->type == RUN_TYPE_LF_EXT) {\n            te->data_index = find_ext_data_index(te->ext_data[0]);\n        }\n    }\n#ifdef DUMP_CASE_CONV_TABLE\n    dump_case_conv_table1();\n#endif\n}\n\nvoid dump_case_conv_table(FILE *f)\n{\n    int i;\n    uint32_t v;\n    const TableEntry *te;\n\n    total_tables++;\n    total_table_bytes += conv_table_len * sizeof(uint32_t);\n    fprintf(f, \"static const uint32_t case_conv_table1[%d] = {\", conv_table_len);\n    for(i = 0; i < conv_table_len; i++) {\n        if (i % 4 == 0)\n            fprintf(f, \"\\n   \");\n        te = &conv_table[i];\n        v = te->code << (32 - 17);\n        v |= te->len << (32 - 17 - 7);\n        v |= te->type << (32 - 17 - 7 - 4);\n        v |= te->data_index >> 8;\n        fprintf(f, \" 0x%08x,\", v);\n    }\n    fprintf(f, \"\\n};\\n\\n\");\n\n    total_tables++;\n    total_table_bytes += conv_table_len;\n    fprintf(f, \"static const uint8_t case_conv_table2[%d] = {\", conv_table_len);\n    for(i = 0; i < conv_table_len; i++) {\n        if (i % 8 == 0)\n            fprintf(f, \"\\n   \");\n        te = &conv_table[i];\n        fprintf(f, \" 0x%02x,\", te->data_index & 0xff);\n    }\n    fprintf(f, \"\\n};\\n\\n\");\n\n    total_tables++;\n    total_table_bytes += ext_data_len * sizeof(uint16_t);\n    fprintf(f, \"static const uint16_t case_conv_ext[%d] = {\", ext_data_len);\n    for(i = 0; i < ext_data_len; i++) {\n        if (i % 8 == 0)\n            fprintf(f, \"\\n   \");\n        fprintf(f, \" 0x%04x,\", ext_data[i]);\n    }\n    fprintf(f, \"\\n};\\n\\n\");\n}\n\n\nstatic CCInfo *global_tab;\n\nstatic int sp_cc_cmp(const void *p1, const void *p2)\n{\n    CCInfo *c1 = &global_tab[*(const int *)p1];\n    CCInfo *c2 = &global_tab[*(const int *)p2];\n    if (c1->f_len < c2->f_len) {\n        return -1;\n    } else if (c2->f_len < c1->f_len) {\n        return 1;\n    } else {\n        return memcmp(c1->f_data, c2->f_data, sizeof(c1->f_data[0]) * c1->f_len);\n    }\n}\n\n/* dump the case special cases (multi character results which are\n   identical and need specific handling in lre_canonicalize() */\nvoid dump_case_folding_special_cases(CCInfo *tab)\n{\n    int i, len, j;\n    int *perm;\n\n    perm = malloc(sizeof(perm[0]) * (CHARCODE_MAX + 1));\n    for(i = 0; i <= CHARCODE_MAX; i++)\n        perm[i] = i;\n    global_tab = tab;\n    qsort(perm, CHARCODE_MAX + 1, sizeof(perm[0]), sp_cc_cmp);\n    for(i = 0; i <= CHARCODE_MAX;) {\n        if (tab[perm[i]].f_len <= 1) {\n            i++;\n        } else {\n            len = 1;\n            while ((i + len) <= CHARCODE_MAX && !sp_cc_cmp(&perm[i], &perm[i + len]))\n                len++;\n\n            if (len > 1) {\n                for(j = i; j < i + len; j++)\n                    dump_cc_info(&tab[perm[j]], perm[j]);\n            }\n            i += len;\n        }\n    }\n    free(perm);\n    global_tab = NULL;\n}\n\n\nint tabcmp(const int *tab1, const int *tab2, int n)\n{\n    int i;\n    for(i = 0; i < n; i++) {\n        if (tab1[i] != tab2[i])\n            return -1;\n    }\n    return 0;\n}\n\nvoid dump_str(const char *str, const int *buf, int len)\n{\n    int i;\n    printf(\"%s=\", str);\n    for(i = 0; i < len; i++)\n        printf(\" %05x\", buf[i]);\n    printf(\"\\n\");\n}\n\nvoid compute_internal_props(void)\n{\n    int i;\n    BOOL has_ul;\n\n    for(i = 0; i <= CHARCODE_MAX; i++) {\n        CCInfo *ci = &unicode_db[i];\n        has_ul = (ci->u_len != 0 || ci->l_len != 0 || ci->f_len != 0);\n        if (has_ul) {\n            assert(get_prop(i, PROP_Cased));\n        } else {\n            set_prop(i, PROP_Cased1, get_prop(i, PROP_Cased));\n        }\n        set_prop(i, PROP_ID_Continue1,\n                 get_prop(i, PROP_ID_Continue) & (get_prop(i, PROP_ID_Start) ^ 1));\n        set_prop(i, PROP_XID_Start1,\n                 get_prop(i, PROP_ID_Start) ^ get_prop(i, PROP_XID_Start));\n        set_prop(i, PROP_XID_Continue1,\n                 get_prop(i, PROP_ID_Continue) ^ get_prop(i, PROP_XID_Continue));\n        set_prop(i, PROP_Changes_When_Titlecased1,\n                 get_prop(i, PROP_Changes_When_Titlecased) ^ (ci->u_len != 0));\n        set_prop(i, PROP_Changes_When_Casefolded1,\n                 get_prop(i, PROP_Changes_When_Casefolded) ^ (ci->f_len != 0));\n        /* XXX: reduce table size (438 bytes) */\n        set_prop(i, PROP_Changes_When_NFKC_Casefolded1,\n                 get_prop(i, PROP_Changes_When_NFKC_Casefolded) ^ (ci->f_len != 0));\n#if 0\n        /* TEST */\n#define M(x) (1U << GCAT_ ## x)\n        {\n            int b;\n            b = ((M(Mn) | M(Cf) | M(Lm) | M(Sk)) >>\n                 unicode_db[i].general_category) & 1;\n            set_prop(i, PROP_Cased1,\n                     get_prop(i, PROP_Case_Ignorable) ^ b);\n        }\n#undef M\n#endif\n    }\n}\n\nvoid dump_byte_table(FILE *f, const char *cname, const uint8_t *tab, int len)\n{\n    int i;\n\n    total_tables++;\n    total_table_bytes += len;\n    fprintf(f, \"static const uint8_t %s[%d] = {\", cname, len);\n    for(i = 0; i < len; i++) {\n        if (i % 8 == 0)\n            fprintf(f, \"\\n   \");\n        fprintf(f, \" 0x%02x,\", tab[i]);\n    }\n    fprintf(f, \"\\n};\\n\\n\");\n}\n\nvoid dump_index_table(FILE *f, const char *cname, const uint8_t *tab, int len)\n{\n    int i, code, offset;\n\n    total_index++;\n    total_index_bytes += len;\n    fprintf(f, \"static const uint8_t %s[%d] = {\\n\", cname, len);\n    for(i = 0; i < len; i += 3) {\n        code = tab[i] + (tab[i+1] << 8) + ((tab[i+2] & 0x1f) << 16);\n        offset = ((i / 3) + 1) * 32 + (tab[i+2] >> 5);\n        fprintf(f, \"    0x%02x, 0x%02x, 0x%02x,\", tab[i], tab[i+1], tab[i+2]);\n        fprintf(f, \"  // %6.5X at %d%s\\n\", code, offset,\n                i == len - 3 ? \" (upper bound)\" : \"\");\n    }\n    fprintf(f, \"};\\n\\n\");\n}\n\n#define PROP_BLOCK_LEN 32\n\nvoid build_prop_table(FILE *f, const char *name, int prop_index, BOOL add_index)\n{\n    int i, j, n, v, offset, code;\n    DynBuf dbuf_s, *dbuf = &dbuf_s;\n    DynBuf dbuf1_s, *dbuf1 = &dbuf1_s;\n    DynBuf dbuf2_s, *dbuf2 = &dbuf2_s;\n    const uint32_t *buf;\n    int buf_len, block_end_pos, bit;\n    char cname[128];\n\n    dbuf_init(dbuf1);\n\n    for(i = 0; i <= CHARCODE_MAX;) {\n        v = get_prop(i, prop_index);\n        j = i + 1;\n        while (j <= CHARCODE_MAX && get_prop(j, prop_index) == v) {\n            j++;\n        }\n        n = j - i;\n        if (j == (CHARCODE_MAX + 1) && v == 0)\n            break; /* no need to encode last zero run */\n        //printf(\"%05x: %d %d\\n\", i, n, v);\n        dbuf_put_u32(dbuf1, n - 1);\n        i += n;\n    }\n\n    dbuf_init(dbuf);\n    dbuf_init(dbuf2);\n    buf = (uint32_t *)dbuf1->buf;\n    buf_len = dbuf1->size / sizeof(buf[0]);\n\n    /* the first value is assumed to be 0 */\n    assert(get_prop(0, prop_index) == 0);\n\n    block_end_pos = PROP_BLOCK_LEN;\n    i = 0;\n    code = 0;\n    bit = 0;\n    while (i < buf_len) {\n        if (add_index && dbuf->size >= block_end_pos && bit == 0) {\n            offset = (dbuf->size - block_end_pos);\n            /* XXX: offset could be larger in case of runs of small\n               lengths. Could add code to change the encoding to\n               prevent it at the expense of one byte loss */\n            assert(offset <= 7);\n            v = code | (offset << 21);\n            dbuf_putc(dbuf2, v);\n            dbuf_putc(dbuf2, v >> 8);\n            dbuf_putc(dbuf2, v >> 16);\n            block_end_pos += PROP_BLOCK_LEN;\n        }\n\n        /* Compressed byte encoding:\n           00..3F: 2 packed lengths: 3-bit + 3-bit\n           40..5F: 5-bits plus extra byte for length\n           60..7F: 5-bits plus 2 extra bytes for length\n           80..FF: 7-bit length\n           lengths must be incremented to get character count\n           Ranges alternate between false and true return value.\n         */\n        v = buf[i];\n        code += v + 1;\n        bit ^= 1;\n        if (v < 8 && (i + 1) < buf_len && buf[i + 1] < 8) {\n            code += buf[i + 1] + 1;\n            bit ^= 1;\n            dbuf_putc(dbuf, (v << 3) | buf[i + 1]);\n            i += 2;\n        } else if (v < 128) {\n            dbuf_putc(dbuf, 0x80 + v);\n            i++;\n        } else if (v < (1 << 13)) {\n            dbuf_putc(dbuf, 0x40 + (v >> 8));\n            dbuf_putc(dbuf, v);\n            i++;\n        } else {\n            assert(v < (1 << 21));\n            dbuf_putc(dbuf, 0x60 + (v >> 16));\n            dbuf_putc(dbuf, v >> 8);\n            dbuf_putc(dbuf, v);\n            i++;\n        }\n    }\n\n    if (add_index) {\n        /* last index entry */\n        v = code;\n        dbuf_putc(dbuf2, v);\n        dbuf_putc(dbuf2, v >> 8);\n        dbuf_putc(dbuf2, v >> 16);\n    }\n\n#ifdef DUMP_TABLE_SIZE\n    printf(\"prop %s: length=%d bytes\\n\", unicode_prop_name[prop_index],\n           (int)(dbuf->size + dbuf2->size));\n#endif\n    snprintf(cname, sizeof(cname), \"unicode_prop_%s_table\", unicode_prop_name[prop_index]);\n    dump_byte_table(f, cname, dbuf->buf, dbuf->size);\n    if (add_index) {\n        snprintf(cname, sizeof(cname), \"unicode_prop_%s_index\", unicode_prop_name[prop_index]);\n        dump_index_table(f, cname, dbuf2->buf, dbuf2->size);\n    }\n\n    dbuf_free(dbuf);\n    dbuf_free(dbuf1);\n    dbuf_free(dbuf2);\n}\n\nvoid build_flags_tables(FILE *f)\n{\n    build_prop_table(f, \"Cased1\", PROP_Cased1, TRUE);\n    build_prop_table(f, \"Case_Ignorable\", PROP_Case_Ignorable, TRUE);\n    build_prop_table(f, \"ID_Start\", PROP_ID_Start, TRUE);\n    build_prop_table(f, \"ID_Continue1\", PROP_ID_Continue1, TRUE);\n}\n\nvoid dump_name_table(FILE *f, const char *cname, const char **tab_name, int len,\n                     const char **tab_short_name)\n{\n    int i, w, maxw;\n\n    maxw = 0;\n    for(i = 0; i < len; i++) {\n        w = strlen(tab_name[i]);\n        if (tab_short_name[i][0] != '\\0') {\n            w += 1 + strlen(tab_short_name[i]);\n        }\n        if (maxw < w)\n            maxw = w;\n    }\n\n    /* generate a sequence of strings terminated by an empty string */\n    fprintf(f, \"static const char %s[] =\\n\", cname);\n    for(i = 0; i < len; i++) {\n        fprintf(f, \"    \\\"\");\n        w = fprintf(f, \"%s\", tab_name[i]);\n        if (tab_short_name[i][0] != '\\0') {\n            w += fprintf(f, \",%s\", tab_short_name[i]);\n        }\n        fprintf(f, \"\\\"%*s\\\"\\\\0\\\"\\n\", 1 + maxw - w, \"\");\n    }\n    fprintf(f, \";\\n\\n\");\n}\n\nvoid build_general_category_table(FILE *f)\n{\n    int i, v, j, n, n1;\n    DynBuf dbuf_s, *dbuf = &dbuf_s;\n#ifdef DUMP_TABLE_SIZE\n    int cw_count, cw_len_count[4], cw_start;\n#endif\n\n    fprintf(f, \"typedef enum {\\n\");\n    for(i = 0; i < GCAT_COUNT; i++)\n        fprintf(f, \"    UNICODE_GC_%s,\\n\", unicode_gc_name[i]);\n    fprintf(f, \"    UNICODE_GC_COUNT,\\n\");\n    fprintf(f, \"} UnicodeGCEnum;\\n\\n\");\n\n    dump_name_table(f, \"unicode_gc_name_table\",\n                    unicode_gc_name, GCAT_COUNT,\n                    unicode_gc_short_name);\n\n\n    dbuf_init(dbuf);\n#ifdef DUMP_TABLE_SIZE\n    cw_count = 0;\n    for(i = 0; i < 4; i++)\n        cw_len_count[i] = 0;\n#endif\n    for(i = 0; i <= CHARCODE_MAX;) {\n        v = unicode_db[i].general_category;\n        j = i + 1;\n        while (j <= CHARCODE_MAX && unicode_db[j].general_category == v)\n            j++;\n        n = j - i;\n        /* compress Lu/Ll runs */\n        if (v == GCAT_Lu) {\n            n1 = 1;\n            while ((i + n1) <= CHARCODE_MAX && unicode_db[i + n1].general_category == (v + (n1 & 1))) {\n                n1++;\n            }\n            if (n1 > n) {\n                v = 31;\n                n = n1;\n            }\n        }\n        //        printf(\"%05x %05x %d\\n\", i, n, v);\n        n--;\n#ifdef DUMP_TABLE_SIZE\n        cw_count++;\n        cw_start = dbuf->size;\n#endif\n        if (n < 7) {\n            dbuf_putc(dbuf, (n << 5) | v);\n        } else if (n < 7 + 128) {\n            n1 = n - 7;\n            assert(n1 < 128);\n            dbuf_putc(dbuf, (0xf << 5) | v);\n            dbuf_putc(dbuf, n1);\n        } else if (n < 7 + 128 + (1 << 14)) {\n            n1 = n - (7 + 128);\n            assert(n1 < (1 << 14));\n            dbuf_putc(dbuf, (0xf << 5) | v);\n            dbuf_putc(dbuf, (n1 >> 8) + 128);\n            dbuf_putc(dbuf, n1);\n        } else {\n            n1 = n - (7 + 128 + (1 << 14));\n            assert(n1 < (1 << 22));\n            dbuf_putc(dbuf, (0xf << 5) | v);\n            dbuf_putc(dbuf, (n1 >> 16) + 128 + 64);\n            dbuf_putc(dbuf, n1 >> 8);\n            dbuf_putc(dbuf, n1);\n        }\n#ifdef DUMP_TABLE_SIZE\n        cw_len_count[dbuf->size - cw_start - 1]++;\n#endif\n        i += n + 1;\n    }\n#ifdef DUMP_TABLE_SIZE\n    printf(\"general category: %d entries [\", cw_count);\n    for(i = 0; i < 4; i++)\n        printf(\" %d\", cw_len_count[i]);\n    printf(\" ], length=%d bytes\\n\", (int)dbuf->size);\n#endif\n\n    dump_byte_table(f, \"unicode_gc_table\", dbuf->buf, dbuf->size);\n\n    dbuf_free(dbuf);\n}\n\nvoid build_script_table(FILE *f)\n{\n    int i, v, j, n, n1, type;\n    DynBuf dbuf_s, *dbuf = &dbuf_s;\n#ifdef DUMP_TABLE_SIZE\n    int cw_count, cw_len_count[4], cw_start;\n#endif\n\n    fprintf(f, \"typedef enum {\\n\");\n    for(i = 0; i < SCRIPT_COUNT; i++)\n        fprintf(f, \"    UNICODE_SCRIPT_%s,\\n\", unicode_script_name[i]);\n    fprintf(f, \"    UNICODE_SCRIPT_COUNT,\\n\");\n    fprintf(f, \"} UnicodeScriptEnum;\\n\\n\");\n\n    i = 1;\n    dump_name_table(f, \"unicode_script_name_table\",\n                    unicode_script_name + i, SCRIPT_COUNT - i,\n                    unicode_script_short_name + i);\n\n    dbuf_init(dbuf);\n#ifdef DUMP_TABLE_SIZE\n    cw_count = 0;\n    for(i = 0; i < 4; i++)\n        cw_len_count[i] = 0;\n#endif\n    for(i = 0; i <= CHARCODE_MAX;) {\n        v = unicode_db[i].script;\n        j = i + 1;\n        while (j <= CHARCODE_MAX && unicode_db[j].script == v)\n            j++;\n        n = j - i;\n        if (v == 0 && j == (CHARCODE_MAX + 1))\n            break;\n        //        printf(\"%05x %05x %d\\n\", i, n, v);\n        n--;\n#ifdef DUMP_TABLE_SIZE\n        cw_count++;\n        cw_start = dbuf->size;\n#endif\n        if (v == 0)\n            type = 0;\n        else\n            type = 1;\n        if (n < 96) {\n            dbuf_putc(dbuf, n | (type << 7));\n        } else if (n < 96 + (1 << 12)) {\n            n1 = n - 96;\n            assert(n1 < (1 << 12));\n            dbuf_putc(dbuf, ((n1 >> 8) + 96) | (type << 7));\n            dbuf_putc(dbuf, n1);\n        } else {\n            n1 = n - (96 + (1 << 12));\n            assert(n1 < (1 << 20));\n            dbuf_putc(dbuf, ((n1 >> 16) + 112) | (type << 7));\n            dbuf_putc(dbuf, n1 >> 8);\n            dbuf_putc(dbuf, n1);\n        }\n        if (type != 0)\n            dbuf_putc(dbuf, v);\n\n#ifdef DUMP_TABLE_SIZE\n        cw_len_count[dbuf->size - cw_start - 1]++;\n#endif\n        i += n + 1;\n    }\n#ifdef DUMP_TABLE_SIZE\n    printf(\"script: %d entries [\", cw_count);\n    for(i = 0; i < 4; i++)\n        printf(\" %d\", cw_len_count[i]);\n    printf(\" ], length=%d bytes\\n\", (int)dbuf->size);\n#endif\n\n    dump_byte_table(f, \"unicode_script_table\", dbuf->buf, dbuf->size);\n\n    dbuf_free(dbuf);\n}\n\nvoid build_script_ext_table(FILE *f)\n{\n    int i, j, n, n1, script_ext_len;\n    DynBuf dbuf_s, *dbuf = &dbuf_s;\n#if defined(DUMP_TABLE_SIZE)\n    int cw_count = 0;\n#endif\n\n    dbuf_init(dbuf);\n    for(i = 0; i <= CHARCODE_MAX;) {\n        script_ext_len = unicode_db[i].script_ext_len;\n        j = i + 1;\n        while (j <= CHARCODE_MAX &&\n               unicode_db[j].script_ext_len == script_ext_len &&\n               !memcmp(unicode_db[j].script_ext, unicode_db[i].script_ext,\n                       script_ext_len)) {\n            j++;\n        }\n        n = j - i;\n#if defined(DUMP_TABLE_SIZE)\n        cw_count++;\n#endif\n        n--;\n        if (n < 128) {\n            dbuf_putc(dbuf, n);\n        } else if (n < 128 + (1 << 14)) {\n            n1 = n - 128;\n            assert(n1 < (1 << 14));\n            dbuf_putc(dbuf, (n1 >> 8) + 128);\n            dbuf_putc(dbuf, n1);\n        } else {\n            n1 = n - (128 + (1 << 14));\n            assert(n1 < (1 << 22));\n            dbuf_putc(dbuf, (n1 >> 16) + 128 + 64);\n            dbuf_putc(dbuf, n1 >> 8);\n            dbuf_putc(dbuf, n1);\n        }\n        dbuf_putc(dbuf, script_ext_len);\n        for(j = 0; j < script_ext_len; j++)\n            dbuf_putc(dbuf, unicode_db[i].script_ext[j]);\n        i += n + 1;\n    }\n#ifdef DUMP_TABLE_SIZE\n    printf(\"script_ext: %d entries\", cw_count);\n    printf(\", length=%d bytes\\n\", (int)dbuf->size);\n#endif\n\n    dump_byte_table(f, \"unicode_script_ext_table\", dbuf->buf, dbuf->size);\n\n    dbuf_free(dbuf);\n}\n\n/* the following properties are synthetized so no table is necessary */\n#define PROP_TABLE_COUNT PROP_ASCII\n\nvoid build_prop_list_table(FILE *f)\n{\n    int i;\n\n    for(i = 0; i < PROP_TABLE_COUNT; i++) {\n        if (i == PROP_ID_Start ||\n            i == PROP_Case_Ignorable ||\n            i == PROP_ID_Continue1) {\n            /* already generated */\n        } else {\n            build_prop_table(f, unicode_prop_name[i], i, FALSE);\n        }\n    }\n\n    fprintf(f, \"typedef enum {\\n\");\n    for(i = 0; i < PROP_COUNT; i++)\n        fprintf(f, \"    UNICODE_PROP_%s,\\n\", unicode_prop_name[i]);\n    fprintf(f, \"    UNICODE_PROP_COUNT,\\n\");\n    fprintf(f, \"} UnicodePropertyEnum;\\n\\n\");\n\n    i = PROP_ASCII_Hex_Digit;\n    dump_name_table(f, \"unicode_prop_name_table\",\n                    unicode_prop_name + i, PROP_XID_Start - i + 1,\n                    unicode_prop_short_name + i);\n\n    fprintf(f, \"static const uint8_t * const unicode_prop_table[] = {\\n\");\n    for(i = 0; i < PROP_TABLE_COUNT; i++) {\n        fprintf(f, \"    unicode_prop_%s_table,\\n\", unicode_prop_name[i]);\n    }\n    fprintf(f, \"};\\n\\n\");\n\n    fprintf(f, \"static const uint16_t unicode_prop_len_table[] = {\\n\");\n    for(i = 0; i < PROP_TABLE_COUNT; i++) {\n        fprintf(f, \"    countof(unicode_prop_%s_table),\\n\", unicode_prop_name[i]);\n    }\n    fprintf(f, \"};\\n\\n\");\n}\n\n#ifdef USE_TEST\nint check_conv(uint32_t *res, uint32_t c, int conv_type)\n{\n    return lre_case_conv(res, c, conv_type);\n}\n\nvoid check_case_conv(void)\n{\n    CCInfo *tab = unicode_db;\n    uint32_t res[3];\n    int l, error;\n    CCInfo ci_s, *ci1, *ci = &ci_s;\n    int code;\n\n    for(code = 0; code <= CHARCODE_MAX; code++) {\n        ci1 = &tab[code];\n        *ci = *ci1;\n        if (ci->l_len == 0) {\n            ci->l_len = 1;\n            ci->l_data[0] = code;\n        }\n        if (ci->u_len == 0) {\n            ci->u_len = 1;\n            ci->u_data[0] = code;\n        }\n        if (ci->f_len == 0) {\n            ci->f_len = 1;\n            ci->f_data[0] = code;\n        }\n\n        error = 0;\n        l = check_conv(res, code, 0);\n        if (l != ci->u_len || tabcmp((int *)res, ci->u_data, l)) {\n            printf(\"ERROR: L\\n\");\n            error++;\n        }\n        l = check_conv(res, code, 1);\n        if (l != ci->l_len || tabcmp((int *)res, ci->l_data, l)) {\n            printf(\"ERROR: U\\n\");\n            error++;\n        }\n        l = check_conv(res, code, 2);\n        if (l != ci->f_len || tabcmp((int *)res, ci->f_data, l)) {\n            printf(\"ERROR: F\\n\");\n            error++;\n        }\n        if (error) {\n            dump_cc_info(ci, code);\n            exit(1);\n        }\n    }\n}\n\n#ifdef PROFILE\nstatic int64_t get_time_ns(void)\n{\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return (int64_t)ts.tv_sec * 1000000000 + ts.tv_nsec;\n}\n#endif\n\n\nvoid check_flags(void)\n{\n    int c;\n    BOOL flag_ref, flag;\n    for(c = 0; c <= CHARCODE_MAX; c++) {\n        flag_ref = get_prop(c, PROP_Cased);\n        flag = !!lre_is_cased(c);\n        if (flag != flag_ref) {\n            printf(\"ERROR: c=%05x cased=%d ref=%d\\n\",\n                   c, flag, flag_ref);\n            exit(1);\n        }\n\n        flag_ref = get_prop(c, PROP_Case_Ignorable);\n        flag = !!lre_is_case_ignorable(c);\n        if (flag != flag_ref) {\n            printf(\"ERROR: c=%05x case_ignorable=%d ref=%d\\n\",\n                   c, flag, flag_ref);\n            exit(1);\n        }\n\n        flag_ref = get_prop(c, PROP_ID_Start);\n        flag = !!lre_is_id_start(c);\n        if (flag != flag_ref) {\n            printf(\"ERROR: c=%05x id_start=%d ref=%d\\n\",\n                   c, flag, flag_ref);\n            exit(1);\n        }\n\n        flag_ref = get_prop(c, PROP_ID_Continue);\n        flag = !!lre_is_id_continue(c);\n        if (flag != flag_ref) {\n            printf(\"ERROR: c=%05x id_cont=%d ref=%d\\n\",\n                   c, flag, flag_ref);\n            exit(1);\n        }\n    }\n#ifdef PROFILE\n    {\n        int64_t ti, count;\n        ti = get_time_ns();\n        count = 0;\n        for(c = 0x20; c <= 0xffff; c++) {\n            flag_ref = get_prop(c, PROP_ID_Start);\n            flag = !!lre_is_id_start(c);\n            assert(flag == flag_ref);\n            count++;\n        }\n        ti = get_time_ns() - ti;\n        printf(\"flags time=%0.1f ns/char\\n\",\n               (double)ti / count);\n    }\n#endif\n}\n\n#endif\n\n#define CC_BLOCK_LEN 32\n\nvoid build_cc_table(FILE *f)\n{\n    // Compress combining class table\n    // see: https://www.unicode.org/reports/tr44/#Canonical_Combining_Class_Values\n    int i, cc, n, type, n1, block_end_pos;\n    DynBuf dbuf_s, *dbuf = &dbuf_s;\n    DynBuf dbuf1_s, *dbuf1 = &dbuf1_s;\n#if defined(DUMP_CC_TABLE) || defined(DUMP_TABLE_SIZE)\n    int cw_len_tab[3], cw_start, cc_table_len;\n#endif\n    uint32_t v;\n\n    dbuf_init(dbuf);\n    dbuf_init(dbuf1);\n#if defined(DUMP_CC_TABLE) || defined(DUMP_TABLE_SIZE)\n    cc_table_len = 0;\n    for(i = 0; i < countof(cw_len_tab); i++)\n        cw_len_tab[i] = 0;\n#endif\n    block_end_pos = CC_BLOCK_LEN;\n    for(i = 0; i <= CHARCODE_MAX;) {\n        cc = unicode_db[i].combining_class;\n        assert(cc <= 255);\n        /* check increasing values */\n        n = 1;\n        while ((i + n) <= CHARCODE_MAX &&\n               unicode_db[i + n].combining_class == (cc + n))\n            n++;\n        if (n >= 2) {\n            type = 1;\n        } else {\n            type = 0;\n            n = 1;\n            while ((i + n) <= CHARCODE_MAX &&\n                   unicode_db[i + n].combining_class == cc)\n                n++;\n        }\n        /* no need to encode the last run */\n        if (cc == 0 && (i + n - 1) == CHARCODE_MAX)\n            break;\n#ifdef DUMP_CC_TABLE\n        printf(\"%05x %6d %d %d\\n\", i, n, type, cc);\n#endif\n        if (type == 0) {\n            if (cc == 0)\n                type = 2;\n            else if (cc == 230)\n                type = 3;\n        }\n        n1 = n - 1;\n\n        /* add an entry to the index if necessary */\n        if (dbuf->size >= block_end_pos) {\n            v = i | ((dbuf->size - block_end_pos) << 21);\n            dbuf_putc(dbuf1, v);\n            dbuf_putc(dbuf1, v >> 8);\n            dbuf_putc(dbuf1, v >> 16);\n            block_end_pos += CC_BLOCK_LEN;\n        }\n#if defined(DUMP_CC_TABLE) || defined(DUMP_TABLE_SIZE)\n        cw_start = dbuf->size;\n#endif\n        /* Compressed run length encoding:\n           - 2 high order bits are combining class type\n           -         0:0, 1:230, 2:extra byte linear progression, 3:extra byte\n           - 00..2F: range length (add 1)\n           - 30..37: 3-bit range-length + 1 extra byte\n           - 38..3F: 3-bit range-length + 2 extra byte\n         */\n        if (n1 < 48) {\n            dbuf_putc(dbuf, n1 | (type << 6));\n        } else if (n1 < 48 + (1 << 11)) {\n            n1 -= 48;\n            dbuf_putc(dbuf, ((n1 >> 8) + 48) | (type << 6));\n            dbuf_putc(dbuf, n1);\n        } else {\n            n1 -= 48 + (1 << 11);\n            assert(n1 < (1 << 20));\n            dbuf_putc(dbuf, ((n1 >> 16) + 56) | (type << 6));\n            dbuf_putc(dbuf, n1 >> 8);\n            dbuf_putc(dbuf, n1);\n        }\n#if defined(DUMP_CC_TABLE) || defined(DUMP_TABLE_SIZE)\n        cw_len_tab[dbuf->size - cw_start - 1]++;\n        cc_table_len++;\n#endif\n        if (type == 0 || type == 1)\n            dbuf_putc(dbuf, cc);\n        i += n;\n    }\n\n    /* last index entry */\n    v = i;\n    dbuf_putc(dbuf1, v);\n    dbuf_putc(dbuf1, v >> 8);\n    dbuf_putc(dbuf1, v >> 16);\n\n    dump_byte_table(f, \"unicode_cc_table\", dbuf->buf, dbuf->size);\n    dump_index_table(f, \"unicode_cc_index\", dbuf1->buf, dbuf1->size);\n\n#if defined(DUMP_CC_TABLE) || defined(DUMP_TABLE_SIZE)\n    printf(\"CC table: size=%d (%d entries) [\",\n           (int)(dbuf->size + dbuf1->size),\n           cc_table_len);\n    for(i = 0; i < countof(cw_len_tab); i++)\n        printf(\" %d\", cw_len_tab[i]);\n    printf(\" ]\\n\");\n#endif\n    dbuf_free(dbuf);\n    dbuf_free(dbuf1);\n}\n\n/* maximum length of decomposition: 18 chars (1), then 8 */\n#ifndef USE_TEST\ntypedef enum {\n    DECOMP_TYPE_C1, /* 16 bit char */\n    DECOMP_TYPE_L1, /* 16 bit char table */\n    DECOMP_TYPE_L2,\n    DECOMP_TYPE_L3,\n    DECOMP_TYPE_L4,\n    DECOMP_TYPE_L5, /* XXX: not used */\n    DECOMP_TYPE_L6, /* XXX: could remove */\n    DECOMP_TYPE_L7, /* XXX: could remove */\n    DECOMP_TYPE_LL1, /* 18 bit char table */\n    DECOMP_TYPE_LL2,\n    DECOMP_TYPE_S1, /* 8 bit char table */\n    DECOMP_TYPE_S2,\n    DECOMP_TYPE_S3,\n    DECOMP_TYPE_S4,\n    DECOMP_TYPE_S5,\n    DECOMP_TYPE_I1, /* increment 16 bit char value */\n    DECOMP_TYPE_I2_0,\n    DECOMP_TYPE_I2_1,\n    DECOMP_TYPE_I3_1,\n    DECOMP_TYPE_I3_2,\n    DECOMP_TYPE_I4_1,\n    DECOMP_TYPE_I4_2,\n    DECOMP_TYPE_B1, /* 16 bit base + 8 bit offset */\n    DECOMP_TYPE_B2,\n    DECOMP_TYPE_B3,\n    DECOMP_TYPE_B4,\n    DECOMP_TYPE_B5,\n    DECOMP_TYPE_B6,\n    DECOMP_TYPE_B7,\n    DECOMP_TYPE_B8,\n    DECOMP_TYPE_B18,\n    DECOMP_TYPE_LS2,\n    DECOMP_TYPE_PAT3,\n    DECOMP_TYPE_S2_UL,\n    DECOMP_TYPE_LS2_UL,\n} DecompTypeEnum;\n#endif\n\nconst char *decomp_type_str[] = {\n    \"C1\",\n    \"L1\",\n    \"L2\",\n    \"L3\",\n    \"L4\",\n    \"L5\",\n    \"L6\",\n    \"L7\",\n    \"LL1\",\n    \"LL2\",\n    \"S1\",\n    \"S2\",\n    \"S3\",\n    \"S4\",\n    \"S5\",\n    \"I1\",\n    \"I2_0\",\n    \"I2_1\",\n    \"I3_1\",\n    \"I3_2\",\n    \"I4_1\",\n    \"I4_2\",\n    \"B1\",\n    \"B2\",\n    \"B3\",\n    \"B4\",\n    \"B5\",\n    \"B6\",\n    \"B7\",\n    \"B8\",\n    \"B18\",\n    \"LS2\",\n    \"PAT3\",\n    \"S2_UL\",\n    \"LS2_UL\",\n};\n\nconst int decomp_incr_tab[4][4] = {\n    { DECOMP_TYPE_I1, 0, -1 },\n    { DECOMP_TYPE_I2_0, 0, 1, -1 },\n    { DECOMP_TYPE_I3_1, 1, 2, -1 },\n    { DECOMP_TYPE_I4_1, 1, 2, -1 },\n};\n\n/*\n  entry size:\n  type   bits\n  code   18\n  len    7\n  compat 1\n  type   5\n  index  16\n  total  47\n*/\n\ntypedef struct {\n    int code;\n    uint8_t len;\n    uint8_t type;\n    uint8_t c_len;\n    uint16_t c_min;\n    uint16_t data_index;\n    int cost; /* size in bytes from this entry to the end */\n} DecompEntry;\n\nint get_decomp_run_size(const DecompEntry *de)\n{\n    int s;\n    s = 6;\n    if (de->type <= DECOMP_TYPE_C1) {\n        /* nothing more */\n    } else if (de->type <= DECOMP_TYPE_L7) {\n        s += de->len * de->c_len * 2;\n    } else if (de->type <= DECOMP_TYPE_LL2) {\n        /* 18 bits per char */\n        s += (de->len * de->c_len * 18 + 7) / 8;\n    } else if (de->type <= DECOMP_TYPE_S5) {\n        s += de->len * de->c_len;\n    } else if (de->type <= DECOMP_TYPE_I4_2) {\n        s += de->c_len * 2;\n    } else if (de->type <= DECOMP_TYPE_B18) {\n        s += 2 + de->len * de->c_len;\n    } else if (de->type <= DECOMP_TYPE_LS2) {\n        s += de->len * 3;\n    } else if (de->type <= DECOMP_TYPE_PAT3) {\n        s += 4 + de->len * 2;\n    } else if (de->type <= DECOMP_TYPE_S2_UL) {\n        s += de->len;\n    } else if (de->type <= DECOMP_TYPE_LS2_UL) {\n        s += (de->len / 2) * 3;\n    } else {\n        abort();\n    }\n    return s;\n}\n\nstatic const uint16_t unicode_short_table[2] = { 0x2044, 0x2215 };\n\n/* return -1 if not found */\nint get_short_code(int c)\n{\n    int i;\n    if (c < 0x80) {\n        return c;\n    } else if (c >= 0x300 && c < 0x350) {\n        return c - 0x300 + 0x80;\n    } else {\n        for(i = 0; i < countof(unicode_short_table); i++) {\n            if (c == unicode_short_table[i])\n                return i + 0x80 + 0x50;\n        }\n        return -1;\n    }\n}\n\nstatic BOOL is_short(int code)\n{\n    return get_short_code(code) >= 0;\n}\n\nstatic BOOL is_short_tab(const int *tab, int len)\n{\n    int i;\n    for(i = 0; i < len; i++) {\n        if (!is_short(tab[i]))\n            return FALSE;\n    }\n    return TRUE;\n}\n\nstatic BOOL is_16bit(const int *tab, int len)\n{\n    int i;\n    for(i = 0; i < len; i++) {\n        if (tab[i] > 0xffff)\n            return FALSE;\n    }\n    return TRUE;\n}\n\nstatic uint32_t to_lower_simple(uint32_t c)\n{\n    /* Latin1 and Cyrillic */\n    if (c < 0x100 || (c >= 0x410 && c <= 0x42f))\n        c += 0x20;\n    else\n        c++;\n    return c;\n}\n\n/* select best encoding with dynamic programming */\nvoid find_decomp_run(DecompEntry *tab_de, int i)\n{\n    DecompEntry de_s, *de = &de_s;\n    CCInfo *ci, *ci1, *ci2;\n    int l, j, n, len_max;\n\n    ci = &unicode_db[i];\n    l = ci->decomp_len;\n    if (l == 0) {\n        tab_de[i].cost = tab_de[i + 1].cost;\n        return;\n    }\n\n    /* the offset for the compose table has only 6 bits, so we must\n       limit if it can be used by the compose table */\n    if (!ci->is_compat && !ci->is_excluded && l == 2)\n        len_max = 64;\n    else\n        len_max = 127;\n\n    tab_de[i].cost = 0x7fffffff;\n\n    if (!is_16bit(ci->decomp_data, l)) {\n        assert(l <= 2);\n\n        n = 1;\n        for(;;) {\n            de->code = i;\n            de->len = n;\n            de->type = DECOMP_TYPE_LL1 + l - 1;\n            de->c_len = l;\n            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;\n            if (de->cost < tab_de[i].cost) {\n                tab_de[i] = *de;\n            }\n            if (!((i + n) <= CHARCODE_MAX && n < len_max))\n                break;\n            ci1 = &unicode_db[i + n];\n            /* Note: we accept a hole */\n            if (!(ci1->decomp_len == 0 ||\n                  (ci1->decomp_len == l &&\n                   ci1->is_compat == ci->is_compat)))\n                break;\n            n++;\n        }\n        return;\n    }\n\n    if (l <= 7) {\n        n = 1;\n        for(;;) {\n            de->code = i;\n            de->len = n;\n            if (l == 1 && n == 1) {\n                de->type = DECOMP_TYPE_C1;\n            } else {\n                assert(l <= 8);\n                de->type = DECOMP_TYPE_L1 + l - 1;\n            }\n            de->c_len = l;\n            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;\n            if (de->cost < tab_de[i].cost) {\n                tab_de[i] = *de;\n            }\n\n            if (!((i + n) <= CHARCODE_MAX && n < len_max))\n                break;\n            ci1 = &unicode_db[i + n];\n            /* Note: we accept a hole */\n            if (!(ci1->decomp_len == 0 ||\n                  (ci1->decomp_len == l &&\n                   ci1->is_compat == ci->is_compat &&\n                   is_16bit(ci1->decomp_data, l))))\n                break;\n            n++;\n        }\n    }\n\n    if (l <= 8 || l == 18) {\n        int c_min, c_max, c;\n        c_min = c_max = -1;\n        n = 1;\n        for(;;) {\n            ci1 = &unicode_db[i + n - 1];\n            for(j = 0; j < l; j++) {\n                c = ci1->decomp_data[j];\n                if (c == 0x20) {\n                    /* we accept space for Arabic */\n                } else if (c_min == -1) {\n                    c_min = c_max = c;\n                } else {\n                    c_min = min_int(c_min, c);\n                    c_max = max_int(c_max, c);\n                }\n            }\n            if ((c_max - c_min) > 254)\n                break;\n            de->code = i;\n            de->len = n;\n            if (l == 18)\n                de->type = DECOMP_TYPE_B18;\n            else\n                de->type = DECOMP_TYPE_B1 + l - 1;\n            de->c_len = l;\n            de->c_min = c_min;\n            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;\n            if (de->cost < tab_de[i].cost) {\n                tab_de[i] = *de;\n            }\n            if (!((i + n) <= CHARCODE_MAX && n < len_max))\n                break;\n            ci1 = &unicode_db[i + n];\n            if (!(ci1->decomp_len == l &&\n                  ci1->is_compat == ci->is_compat))\n                break;\n            n++;\n        }\n    }\n\n    /* find an ascii run */\n    if (l <= 5 && is_short_tab(ci->decomp_data, l)) {\n        n = 1;\n        for(;;) {\n            de->code = i;\n            de->len = n;\n            de->type = DECOMP_TYPE_S1 + l - 1;\n            de->c_len = l;\n            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;\n            if (de->cost < tab_de[i].cost) {\n                tab_de[i] = *de;\n            }\n\n            if (!((i + n) <= CHARCODE_MAX && n < len_max))\n                break;\n            ci1 = &unicode_db[i + n];\n            /* Note: we accept a hole */\n            if (!(ci1->decomp_len == 0 ||\n                  (ci1->decomp_len == l &&\n                   ci1->is_compat == ci->is_compat &&\n                   is_short_tab(ci1->decomp_data, l))))\n                break;\n            n++;\n        }\n    }\n\n    /* check if a single char is increasing */\n    if (l <= 4) {\n        int idx1, idx;\n\n        for(idx1 = 1; (idx = decomp_incr_tab[l - 1][idx1]) >= 0; idx1++) {\n            n = 1;\n            for(;;) {\n                de->code = i;\n                de->len = n;\n                de->type = decomp_incr_tab[l - 1][0] + idx1 - 1;\n                de->c_len = l;\n                de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;\n                if (de->cost < tab_de[i].cost) {\n                    tab_de[i] = *de;\n                }\n\n                if (!((i + n) <= CHARCODE_MAX && n < len_max))\n                    break;\n                ci1 = &unicode_db[i + n];\n                if (!(ci1->decomp_len == l &&\n                      ci1->is_compat == ci->is_compat))\n                    goto next1;\n                for(j = 0; j < l; j++) {\n                    if (j == idx) {\n                        if (ci1->decomp_data[j] != ci->decomp_data[j] + n)\n                            goto next1;\n                    } else {\n                        if (ci1->decomp_data[j] != ci->decomp_data[j])\n                            goto next1;\n                    }\n                }\n                n++;\n            }\n        next1: ;\n        }\n    }\n\n    if (l == 3) {\n        n = 1;\n        for(;;) {\n            de->code = i;\n            de->len = n;\n            de->type = DECOMP_TYPE_PAT3;\n            de->c_len = l;\n            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;\n            if (de->cost < tab_de[i].cost) {\n                tab_de[i] = *de;\n            }\n            if (!((i + n) <= CHARCODE_MAX && n < len_max))\n                break;\n            ci1 = &unicode_db[i + n];\n            if (!(ci1->decomp_len == l &&\n                  ci1->is_compat == ci->is_compat &&\n                  ci1->decomp_data[1] <= 0xffff &&\n                  ci1->decomp_data[0] == ci->decomp_data[0] &&\n                  ci1->decomp_data[l - 1] == ci->decomp_data[l - 1]))\n                break;\n            n++;\n        }\n    }\n\n    if (l == 2 && is_short(ci->decomp_data[1])) {\n        n = 1;\n        for(;;) {\n            de->code = i;\n            de->len = n;\n            de->type = DECOMP_TYPE_LS2;\n            de->c_len = l;\n            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;\n            if (de->cost < tab_de[i].cost) {\n                tab_de[i] = *de;\n            }\n            if (!((i + n) <= CHARCODE_MAX && n < len_max))\n                break;\n            ci1 = &unicode_db[i + n];\n            if (!(ci1->decomp_len == 0 ||\n                  (ci1->decomp_len == l &&\n                   ci1->is_compat == ci->is_compat &&\n                   ci1->decomp_data[0] <= 0xffff &&\n                   is_short(ci1->decomp_data[1]))))\n                break;\n            n++;\n        }\n    }\n\n    if (l == 2) {\n        BOOL is_16bit;\n\n        n = 0;\n        is_16bit = FALSE;\n        for(;;) {\n            if (!((i + n + 1) <= CHARCODE_MAX && n + 2 <= len_max))\n                break;\n            ci1 = &unicode_db[i + n];\n            if (!(ci1->decomp_len == l &&\n                  ci1->is_compat == ci->is_compat &&\n                  is_short(ci1->decomp_data[1])))\n                break;\n            if (!is_16bit && !is_short(ci1->decomp_data[0]))\n                is_16bit = TRUE;\n            ci2 = &unicode_db[i + n + 1];\n            if (!(ci2->decomp_len == l &&\n                  ci2->is_compat == ci->is_compat &&\n                  ci2->decomp_data[0] == to_lower_simple(ci1->decomp_data[0])  &&\n                  ci2->decomp_data[1] == ci1->decomp_data[1]))\n                break;\n            n += 2;\n            de->code = i;\n            de->len = n;\n            de->type = DECOMP_TYPE_S2_UL + is_16bit;\n            de->c_len = l;\n            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;\n            if (de->cost < tab_de[i].cost) {\n                tab_de[i] = *de;\n            }\n        }\n    }\n}\n\nvoid put16(uint8_t *data_buf, int *pidx, uint16_t c)\n{\n    int idx;\n    idx = *pidx;\n    data_buf[idx++] = c;\n    data_buf[idx++] = c >> 8;\n    *pidx = idx;\n}\n\nvoid add_decomp_data(uint8_t *data_buf, int *pidx, DecompEntry *de)\n{\n    int i, j, idx, c;\n    CCInfo *ci;\n\n    idx = *pidx;\n    de->data_index = idx;\n    if (de->type <= DECOMP_TYPE_C1) {\n        ci = &unicode_db[de->code];\n        assert(ci->decomp_len == 1);\n        de->data_index = ci->decomp_data[0];\n    } else if (de->type <= DECOMP_TYPE_L7) {\n        for(i = 0; i < de->len; i++) {\n            ci = &unicode_db[de->code + i];\n            for(j = 0; j < de->c_len; j++) {\n                if (ci->decomp_len == 0)\n                    c = 0;\n                else\n                    c = ci->decomp_data[j];\n                put16(data_buf, &idx,  c);\n            }\n        }\n    } else if (de->type <= DECOMP_TYPE_LL2) {\n        int n, p, k;\n        n = (de->len * de->c_len * 18 + 7) / 8;\n        p = de->len * de->c_len * 2;\n        memset(data_buf + idx, 0, n);\n        k = 0;\n        for(i = 0; i < de->len; i++) {\n            ci = &unicode_db[de->code + i];\n            for(j = 0; j < de->c_len; j++) {\n                if (ci->decomp_len == 0)\n                    c = 0;\n                else\n                    c = ci->decomp_data[j];\n                data_buf[idx + k * 2] = c;\n                data_buf[idx + k * 2 + 1] = c >> 8;\n                data_buf[idx + p + (k / 4)] |= (c >> 16) << ((k % 4) * 2);\n                k++;\n            }\n        }\n        idx += n;\n    } else if (de->type <= DECOMP_TYPE_S5) {\n        for(i = 0; i < de->len; i++) {\n            ci = &unicode_db[de->code + i];\n            for(j = 0; j < de->c_len; j++) {\n                if (ci->decomp_len == 0)\n                    c = 0;\n                else\n                    c = ci->decomp_data[j];\n                c = get_short_code(c);\n                assert(c >= 0);\n                data_buf[idx++] = c;\n            }\n        }\n    } else if (de->type <= DECOMP_TYPE_I4_2) {\n        ci = &unicode_db[de->code];\n        assert(ci->decomp_len == de->c_len);\n        for(j = 0; j < de->c_len; j++)\n            put16(data_buf, &idx, ci->decomp_data[j]);\n    } else if (de->type <= DECOMP_TYPE_B18) {\n        c = de->c_min;\n        data_buf[idx++] = c;\n        data_buf[idx++] = c >> 8;\n        for(i = 0; i < de->len; i++) {\n            ci = &unicode_db[de->code + i];\n            for(j = 0; j < de->c_len; j++) {\n                assert(ci->decomp_len == de->c_len);\n                c = ci->decomp_data[j];\n                if (c == 0x20) {\n                    c = 0xff;\n                } else {\n                    c -= de->c_min;\n                    assert((uint32_t)c <= 254);\n                }\n                data_buf[idx++] = c;\n            }\n        }\n    } else if (de->type <= DECOMP_TYPE_LS2) {\n        assert(de->c_len == 2);\n        for(i = 0; i < de->len; i++) {\n            ci = &unicode_db[de->code + i];\n            if (ci->decomp_len == 0)\n                c = 0;\n            else\n                c = ci->decomp_data[0];\n            put16(data_buf, &idx,  c);\n\n            if (ci->decomp_len == 0)\n                c = 0;\n            else\n                c = ci->decomp_data[1];\n            c = get_short_code(c);\n            assert(c >= 0);\n            data_buf[idx++] = c;\n        }\n    } else if (de->type <= DECOMP_TYPE_PAT3) {\n        ci = &unicode_db[de->code];\n        assert(ci->decomp_len == 3);\n        put16(data_buf, &idx,  ci->decomp_data[0]);\n        put16(data_buf, &idx,  ci->decomp_data[2]);\n        for(i = 0; i < de->len; i++) {\n            ci = &unicode_db[de->code + i];\n            assert(ci->decomp_len == 3);\n            put16(data_buf, &idx,  ci->decomp_data[1]);\n        }\n    } else if (de->type <= DECOMP_TYPE_S2_UL) {\n        for(i = 0; i < de->len; i += 2) {\n            ci = &unicode_db[de->code + i];\n            c = ci->decomp_data[0];\n            c = get_short_code(c);\n            assert(c >= 0);\n            data_buf[idx++] = c;\n            c = ci->decomp_data[1];\n            c = get_short_code(c);\n            assert(c >= 0);\n            data_buf[idx++] = c;\n        }\n    } else if (de->type <= DECOMP_TYPE_LS2_UL) {\n        for(i = 0; i < de->len; i += 2) {\n            ci = &unicode_db[de->code + i];\n            c = ci->decomp_data[0];\n            put16(data_buf, &idx,  c);\n            c = ci->decomp_data[1];\n            c = get_short_code(c);\n            assert(c >= 0);\n            data_buf[idx++] = c;\n        }\n    } else {\n        abort();\n    }\n    *pidx = idx;\n}\n\n#if 0\nvoid dump_large_char(void)\n{\n    int i, j;\n    for(i = 0; i <= CHARCODE_MAX; i++) {\n        CCInfo *ci = &unicode_db[i];\n        for(j = 0; j < ci->decomp_len; j++) {\n            if (ci->decomp_data[j] > 0xffff)\n                printf(\"%05x\\n\", ci->decomp_data[j]);\n        }\n    }\n}\n#endif\n\nvoid build_compose_table(FILE *f, const DecompEntry *tab_de);\n\nvoid build_decompose_table(FILE *f)\n{\n    int i, array_len, code_max, data_len, count;\n    DecompEntry *tab_de, de_s, *de = &de_s;\n    uint8_t *data_buf;\n\n    code_max = CHARCODE_MAX;\n\n    tab_de = mallocz((code_max + 2) * sizeof(*tab_de));\n\n    for(i = code_max; i >= 0; i--) {\n        find_decomp_run(tab_de, i);\n    }\n\n    /* build the data buffer */\n    data_buf = malloc(100000);\n    data_len = 0;\n    array_len = 0;\n    for(i = 0; i <= code_max; i++) {\n        de = &tab_de[i];\n        if (de->len != 0) {\n            add_decomp_data(data_buf, &data_len, de);\n            i += de->len - 1;\n            array_len++;\n        }\n    }\n\n#ifdef DUMP_DECOMP_TABLE\n    /* dump */\n    {\n        int size, size1;\n\n        printf(\"START LEN   TYPE  L C SIZE\\n\");\n        size = 0;\n        for(i = 0; i <= code_max; i++) {\n            de = &tab_de[i];\n            if (de->len != 0) {\n                size1 = get_decomp_run_size(de);\n                printf(\"%05x %3d %6s %2d %1d %4d\\n\", i, de->len,\n                       decomp_type_str[de->type], de->c_len,\n                       unicode_db[i].is_compat, size1);\n                i += de->len - 1;\n                size += size1;\n            }\n        }\n\n        printf(\"array_len=%d estimated size=%d bytes actual=%d bytes\\n\",\n               array_len, size, array_len * 6 + data_len);\n    }\n#endif\n\n    total_tables++;\n    total_table_bytes += array_len * sizeof(uint32_t);\n    fprintf(f, \"static const uint32_t unicode_decomp_table1[%d] = {\", array_len);\n    count = 0;\n    for(i = 0; i <= code_max; i++) {\n        de = &tab_de[i];\n        if (de->len != 0) {\n            uint32_t v;\n            if (count++ % 4 == 0)\n                fprintf(f, \"\\n   \");\n            v = (de->code << (32 - 18)) |\n                (de->len << (32 - 18 - 7)) |\n                (de->type << (32 - 18 - 7 - 6)) |\n                unicode_db[de->code].is_compat;\n            fprintf(f, \" 0x%08x,\", v);\n            i += de->len - 1;\n        }\n    }\n    fprintf(f, \"\\n};\\n\\n\");\n\n    total_tables++;\n    total_table_bytes += array_len * sizeof(uint16_t);\n    fprintf(f, \"static const uint16_t unicode_decomp_table2[%d] = {\", array_len);\n    count = 0;\n    for(i = 0; i <= code_max; i++) {\n        de = &tab_de[i];\n        if (de->len != 0) {\n            if (count++ % 8 == 0)\n                fprintf(f, \"\\n   \");\n            fprintf(f, \" 0x%04x,\", de->data_index);\n            i += de->len - 1;\n        }\n    }\n    fprintf(f, \"\\n};\\n\\n\");\n\n    total_tables++;\n    total_table_bytes += data_len;\n    fprintf(f, \"static const uint8_t unicode_decomp_data[%d] = {\", data_len);\n    for(i = 0; i < data_len; i++) {\n        if (i % 8 == 0)\n            fprintf(f, \"\\n   \");\n        fprintf(f, \" 0x%02x,\", data_buf[i]);\n    }\n    fprintf(f, \"\\n};\\n\\n\");\n\n    build_compose_table(f, tab_de);\n\n    free(data_buf);\n\n    free(tab_de);\n}\n\ntypedef struct {\n    uint32_t c[2];\n    uint32_t p;\n} ComposeEntry;\n\n#define COMPOSE_LEN_MAX 10000\n\nstatic int ce_cmp(const void *p1, const void *p2)\n{\n    const ComposeEntry *ce1 = p1;\n    const ComposeEntry *ce2 = p2;\n    int i;\n\n    for(i = 0; i < 2; i++) {\n        if (ce1->c[i] < ce2->c[i])\n            return -1;\n        else if (ce1->c[i] > ce2->c[i])\n            return 1;\n    }\n    return 0;\n}\n\n\nstatic int get_decomp_pos(const DecompEntry *tab_de, int c)\n{\n    int i, v, k;\n    const DecompEntry *de;\n\n    k = 0;\n    for(i = 0; i <= CHARCODE_MAX; i++) {\n        de = &tab_de[i];\n        if (de->len != 0) {\n            if (c >= de->code && c < de->code + de->len) {\n                v = c - de->code;\n                assert(v < 64);\n                v |= k << 6;\n                assert(v < 65536);\n                return v;\n            }\n            i += de->len - 1;\n            k++;\n        }\n    }\n    return -1;\n}\n\nvoid build_compose_table(FILE *f, const DecompEntry *tab_de)\n{\n    int i, v, tab_ce_len;\n    ComposeEntry *ce, *tab_ce;\n\n    tab_ce = malloc(sizeof(*tab_ce) * COMPOSE_LEN_MAX);\n    tab_ce_len = 0;\n    for(i = 0; i <= CHARCODE_MAX; i++) {\n        CCInfo *ci = &unicode_db[i];\n        if (ci->decomp_len == 2 && !ci->is_compat &&\n            !ci->is_excluded) {\n            assert(tab_ce_len < COMPOSE_LEN_MAX);\n            ce = &tab_ce[tab_ce_len++];\n            ce->c[0] = ci->decomp_data[0];\n            ce->c[1] = ci->decomp_data[1];\n            ce->p = i;\n        }\n    }\n    qsort(tab_ce, tab_ce_len, sizeof(*tab_ce), ce_cmp);\n\n#if 0\n    {\n        printf(\"tab_ce_len=%d\\n\", tab_ce_len);\n        for(i = 0; i < tab_ce_len; i++) {\n            ce = &tab_ce[i];\n            printf(\"%05x %05x %05x\\n\", ce->c[0], ce->c[1], ce->p);\n        }\n    }\n#endif\n\n    total_tables++;\n    total_table_bytes += tab_ce_len * sizeof(uint16_t);\n    fprintf(f, \"static const uint16_t unicode_comp_table[%u] = {\", tab_ce_len);\n    for(i = 0; i < tab_ce_len; i++) {\n        if (i % 8 == 0)\n            fprintf(f, \"\\n   \");\n        v = get_decomp_pos(tab_de, tab_ce[i].p);\n        if (v < 0) {\n            printf(\"ERROR: entry for c=%04x not found\\n\",\n                   tab_ce[i].p);\n            exit(1);\n        }\n        fprintf(f, \" 0x%04x,\", v);\n    }\n    fprintf(f, \"\\n};\\n\\n\");\n\n    free(tab_ce);\n}\n\n#ifdef USE_TEST\nvoid check_decompose_table(void)\n{\n    int c;\n    CCInfo *ci;\n    int res[UNICODE_DECOMP_LEN_MAX], *ref;\n    int len, ref_len, is_compat;\n\n    for(is_compat = 0; is_compat <= 1; is_compat++) {\n        for(c = 0; c < CHARCODE_MAX; c++) {\n            ci = &unicode_db[c];\n            ref_len = ci->decomp_len;\n            ref = ci->decomp_data;\n            if (!is_compat && ci->is_compat) {\n                ref_len = 0;\n            }\n            len = unicode_decomp_char((uint32_t *)res, c, is_compat);\n            if (len != ref_len ||\n                tabcmp(res, ref, ref_len) != 0) {\n                printf(\"ERROR c=%05x compat=%d\\n\", c, is_compat);\n                dump_str(\"res\", res, len);\n                dump_str(\"ref\", ref, ref_len);\n                exit(1);\n            }\n        }\n    }\n}\n\nvoid check_compose_table(void)\n{\n    int i, p;\n    /* XXX: we don't test all the cases */\n\n    for(i = 0; i <= CHARCODE_MAX; i++) {\n        CCInfo *ci = &unicode_db[i];\n        if (ci->decomp_len == 2 && !ci->is_compat &&\n            !ci->is_excluded) {\n            p = unicode_compose_pair(ci->decomp_data[0], ci->decomp_data[1]);\n            if (p != i) {\n                printf(\"ERROR compose: c=%05x %05x -> %05x ref=%05x\\n\",\n                       ci->decomp_data[0], ci->decomp_data[1], p, i);\n                exit(1);\n            }\n        }\n    }\n\n\n\n}\n\n#endif\n\n\n\n#ifdef USE_TEST\n\nvoid check_str(const char *msg, int num, const int *in_buf, int in_len,\n               const int *buf1, int len1,\n               const int *buf2, int len2)\n{\n    if (len1 != len2 || tabcmp(buf1, buf2, len1) != 0) {\n        printf(\"%d: ERROR %s:\\n\", num, msg);\n        dump_str(\" in\", in_buf, in_len);\n        dump_str(\"res\", buf1, len1);\n        dump_str(\"ref\", buf2, len2);\n        exit(1);\n    }\n}\n\nvoid check_cc_table(void)\n{\n    int cc, cc_ref, c;\n\n    for(c = 0; c <= CHARCODE_MAX; c++) {\n        cc_ref = unicode_db[c].combining_class;\n        cc = unicode_get_cc(c);\n        if (cc != cc_ref) {\n            printf(\"ERROR: c=%04x cc=%d cc_ref=%d\\n\",\n                   c, cc, cc_ref);\n            exit(1);\n        }\n    }\n#ifdef PROFILE\n    {\n        int64_t ti, count;\n\n        ti = get_time_ns();\n        count = 0;\n        /* only do it on meaningful chars */\n        for(c = 0x20; c <= 0xffff; c++) {\n            cc_ref = unicode_db[c].combining_class;\n            cc = unicode_get_cc(c);\n            count++;\n        }\n        ti = get_time_ns() - ti;\n        printf(\"cc time=%0.1f ns/char\\n\",\n               (double)ti / count);\n    }\n#endif\n}\n\nvoid normalization_test(const char *filename)\n{\n    FILE *f;\n    char line[4096], *p;\n    int *in_str, *nfc_str, *nfd_str, *nfkc_str, *nfkd_str;\n    int in_len, nfc_len, nfd_len, nfkc_len, nfkd_len;\n    int *buf, buf_len, pos;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        perror(filename);\n        exit(1);\n    }\n    pos = 0;\n    for(;;) {\n        if (!get_line(line, sizeof(line), f))\n            break;\n        pos++;\n        p = line;\n        while (isspace(*p))\n            p++;\n        if (*p == '#' || *p == '@')\n            continue;\n        in_str = get_field_str(&in_len, p, 0);\n        nfc_str = get_field_str(&nfc_len, p, 1);\n        nfd_str = get_field_str(&nfd_len, p, 2);\n        nfkc_str = get_field_str(&nfkc_len, p, 3);\n        nfkd_str = get_field_str(&nfkd_len, p, 4);\n\n        //        dump_str(\"in\", in_str, in_len);\n\n        buf_len = unicode_normalize((uint32_t **)&buf, (uint32_t *)in_str, in_len, UNICODE_NFD, NULL, NULL);\n        check_str(\"nfd\", pos, in_str, in_len, buf, buf_len, nfd_str, nfd_len);\n        free(buf);\n\n        buf_len = unicode_normalize((uint32_t **)&buf, (uint32_t *)in_str, in_len, UNICODE_NFKD, NULL, NULL);\n        check_str(\"nfkd\", pos, in_str, in_len, buf, buf_len, nfkd_str, nfkd_len);\n        free(buf);\n\n        buf_len = unicode_normalize((uint32_t **)&buf, (uint32_t *)in_str, in_len, UNICODE_NFC, NULL, NULL);\n        check_str(\"nfc\", pos, in_str, in_len, buf, buf_len, nfc_str, nfc_len);\n        free(buf);\n\n        buf_len = unicode_normalize((uint32_t **)&buf, (uint32_t *)in_str, in_len, UNICODE_NFKC, NULL, NULL);\n        check_str(\"nfkc\", pos, in_str, in_len, buf, buf_len, nfkc_str, nfkc_len);\n        free(buf);\n\n        free(in_str);\n        free(nfc_str);\n        free(nfd_str);\n        free(nfkc_str);\n        free(nfkd_str);\n    }\n    fclose(f);\n}\n#endif\n\nint main(int argc, char *argv[])\n{\n    const char *unicode_db_path, *outfilename;\n    char filename[1024];\n    int arg = 1;\n\n    if (arg >= argc || (!strcmp(argv[arg], \"-h\") || !strcmp(argv[arg], \"--help\"))) {\n        printf(\"usage: %s PATH [OUTPUT]\\n\"\n               \"  PATH    path to the Unicode database directory\\n\"\n               \"  OUTPUT  name of the output file.  If omitted, a self test is performed\\n\"\n               \"          using the files from the Unicode library\\n\"\n               , argv[0]);\n        return 1;\n    }\n    unicode_db_path = argv[arg++];\n    outfilename = NULL;\n    if (arg < argc)\n        outfilename = argv[arg++];\n\n    unicode_db = mallocz(sizeof(unicode_db[0]) * (CHARCODE_MAX + 1));\n\n    snprintf(filename, sizeof(filename), \"%s/UnicodeData.txt\", unicode_db_path);\n\n    parse_unicode_data(filename);\n\n    snprintf(filename, sizeof(filename), \"%s/SpecialCasing.txt\", unicode_db_path);\n    parse_special_casing(unicode_db, filename);\n\n    snprintf(filename, sizeof(filename), \"%s/CaseFolding.txt\", unicode_db_path);\n    parse_case_folding(unicode_db, filename);\n\n    snprintf(filename, sizeof(filename), \"%s/CompositionExclusions.txt\", unicode_db_path);\n    parse_composition_exclusions(filename);\n\n    snprintf(filename, sizeof(filename), \"%s/DerivedCoreProperties.txt\", unicode_db_path);\n    parse_derived_core_properties(filename);\n\n    snprintf(filename, sizeof(filename), \"%s/DerivedNormalizationProps.txt\", unicode_db_path);\n    parse_derived_norm_properties(filename);\n\n    snprintf(filename, sizeof(filename), \"%s/PropList.txt\", unicode_db_path);\n    parse_prop_list(filename);\n\n    snprintf(filename, sizeof(filename), \"%s/Scripts.txt\", unicode_db_path);\n    parse_scripts(filename);\n\n    snprintf(filename, sizeof(filename), \"%s/ScriptExtensions.txt\",\n             unicode_db_path);\n    parse_script_extensions(filename);\n\n    snprintf(filename, sizeof(filename), \"%s/emoji-data.txt\",\n             unicode_db_path);\n    parse_prop_list(filename);\n\n    //    dump_unicode_data(unicode_db);\n    build_conv_table(unicode_db);\n\n#ifdef DUMP_CASE_FOLDING_SPECIAL_CASES\n    dump_case_folding_special_cases(unicode_db);\n#endif\n\n    if (!outfilename) {\n#ifdef USE_TEST\n        check_case_conv();\n        check_flags();\n        check_decompose_table();\n        check_compose_table();\n        check_cc_table();\n        snprintf(filename, sizeof(filename), \"%s/NormalizationTest.txt\", unicode_db_path);\n        normalization_test(filename);\n#else\n        fprintf(stderr, \"Tests are not compiled\\n\");\n        exit(1);\n#endif\n    } else\n    {\n        FILE *fo = fopen(outfilename, \"wb\");\n\n        if (!fo) {\n            perror(outfilename);\n            exit(1);\n        }\n        fprintf(fo,\n                \"/* Compressed unicode tables */\\n\"\n                \"/* Automatically generated file - do not edit */\\n\"\n                \"\\n\"\n                \"#include <stdint.h>\\n\"\n                \"\\n\");\n        dump_case_conv_table(fo);\n        compute_internal_props();\n        build_flags_tables(fo);\n        fprintf(fo, \"#ifdef CONFIG_ALL_UNICODE\\n\\n\");\n        build_cc_table(fo);\n        build_decompose_table(fo);\n        build_general_category_table(fo);\n        build_script_table(fo);\n        build_script_ext_table(fo);\n        build_prop_list_table(fo);\n        fprintf(fo, \"#endif /* CONFIG_ALL_UNICODE */\\n\");\n        fprintf(fo, \"/* %u tables / %u bytes, %u index / %u bytes */\\n\",\n                total_tables, total_table_bytes, total_index, total_index_bytes);\n        fclose(fo);\n    }\n    return 0;\n}\n"
        },
        {
          "name": "unicode_gen_def.h",
          "type": "blob",
          "size": 6.8291015625,
          "content": "#ifdef UNICODE_GENERAL_CATEGORY\nDEF(Cn, \"Unassigned\") /* must be zero */\nDEF(Lu, \"Uppercase_Letter\")\nDEF(Ll, \"Lowercase_Letter\")\nDEF(Lt, \"Titlecase_Letter\")\nDEF(Lm, \"Modifier_Letter\")\nDEF(Lo, \"Other_Letter\")\nDEF(Mn, \"Nonspacing_Mark\")\nDEF(Mc, \"Spacing_Mark\")\nDEF(Me, \"Enclosing_Mark\")\nDEF(Nd, \"Decimal_Number,digit\")\nDEF(Nl, \"Letter_Number\")\nDEF(No, \"Other_Number\")\nDEF(Sm, \"Math_Symbol\")\nDEF(Sc, \"Currency_Symbol\")\nDEF(Sk, \"Modifier_Symbol\")\nDEF(So, \"Other_Symbol\")\nDEF(Pc, \"Connector_Punctuation\")\nDEF(Pd, \"Dash_Punctuation\")\nDEF(Ps, \"Open_Punctuation\")\nDEF(Pe, \"Close_Punctuation\")\nDEF(Pi, \"Initial_Punctuation\")\nDEF(Pf, \"Final_Punctuation\")\nDEF(Po, \"Other_Punctuation\")\nDEF(Zs, \"Space_Separator\")\nDEF(Zl, \"Line_Separator\")\nDEF(Zp, \"Paragraph_Separator\")\nDEF(Cc, \"Control,cntrl\")\nDEF(Cf, \"Format\")\nDEF(Cs, \"Surrogate\")\nDEF(Co, \"Private_Use\")\n/* synthetic properties */\nDEF(LC, \"Cased_Letter\")\nDEF(L, \"Letter\")\nDEF(M, \"Mark,Combining_Mark\")\nDEF(N, \"Number\")\nDEF(S, \"Symbol\")\nDEF(P, \"Punctuation,punct\")\nDEF(Z, \"Separator\")\nDEF(C, \"Other\")\n#endif\n\n#ifdef UNICODE_SCRIPT\n/* scripts aliases names in PropertyValueAliases.txt */\nDEF(Unknown, \"Zzzz\")\nDEF(Adlam, \"Adlm\")\nDEF(Ahom, \"Ahom\")\nDEF(Anatolian_Hieroglyphs, \"Hluw\")\nDEF(Arabic, \"Arab\")\nDEF(Armenian, \"Armn\")\nDEF(Avestan, \"Avst\")\nDEF(Balinese, \"Bali\")\nDEF(Bamum, \"Bamu\")\nDEF(Bassa_Vah, \"Bass\")\nDEF(Batak, \"Batk\")\nDEF(Bengali, \"Beng\")\nDEF(Bhaiksuki, \"Bhks\")\nDEF(Bopomofo, \"Bopo\")\nDEF(Brahmi, \"Brah\")\nDEF(Braille, \"Brai\")\nDEF(Buginese, \"Bugi\")\nDEF(Buhid, \"Buhd\")\nDEF(Canadian_Aboriginal, \"Cans\")\nDEF(Carian, \"Cari\")\nDEF(Caucasian_Albanian, \"Aghb\")\nDEF(Chakma, \"Cakm\")\nDEF(Cham, \"Cham\")\nDEF(Cherokee, \"Cher\")\nDEF(Chorasmian, \"Chrs\")\nDEF(Common, \"Zyyy\")\nDEF(Coptic, \"Copt,Qaac\")\nDEF(Cuneiform, \"Xsux\")\nDEF(Cypriot, \"Cprt\")\nDEF(Cyrillic, \"Cyrl\")\nDEF(Cypro_Minoan, \"Cpmn\")\nDEF(Deseret, \"Dsrt\")\nDEF(Devanagari, \"Deva\")\nDEF(Dives_Akuru, \"Diak\")\nDEF(Dogra, \"Dogr\")\nDEF(Duployan, \"Dupl\")\nDEF(Egyptian_Hieroglyphs, \"Egyp\")\nDEF(Elbasan, \"Elba\")\nDEF(Elymaic, \"Elym\")\nDEF(Ethiopic, \"Ethi\")\nDEF(Georgian, \"Geor\")\nDEF(Glagolitic, \"Glag\")\nDEF(Gothic, \"Goth\")\nDEF(Grantha, \"Gran\")\nDEF(Greek, \"Grek\")\nDEF(Gujarati, \"Gujr\")\nDEF(Gunjala_Gondi, \"Gong\")\nDEF(Gurmukhi, \"Guru\")\nDEF(Han, \"Hani\")\nDEF(Hangul, \"Hang\")\nDEF(Hanifi_Rohingya, \"Rohg\")\nDEF(Hanunoo, \"Hano\")\nDEF(Hatran, \"Hatr\")\nDEF(Hebrew, \"Hebr\")\nDEF(Hiragana, \"Hira\")\nDEF(Imperial_Aramaic, \"Armi\")\nDEF(Inherited, \"Zinh,Qaai\")\nDEF(Inscriptional_Pahlavi, \"Phli\")\nDEF(Inscriptional_Parthian, \"Prti\")\nDEF(Javanese, \"Java\")\nDEF(Kaithi, \"Kthi\")\nDEF(Kannada, \"Knda\")\nDEF(Katakana, \"Kana\")\nDEF(Kawi, \"Kawi\")\nDEF(Kayah_Li, \"Kali\")\nDEF(Kharoshthi, \"Khar\")\nDEF(Khmer, \"Khmr\")\nDEF(Khojki, \"Khoj\")\nDEF(Khitan_Small_Script, \"Kits\")\nDEF(Khudawadi, \"Sind\")\nDEF(Lao, \"Laoo\")\nDEF(Latin, \"Latn\")\nDEF(Lepcha, \"Lepc\")\nDEF(Limbu, \"Limb\")\nDEF(Linear_A, \"Lina\")\nDEF(Linear_B, \"Linb\")\nDEF(Lisu, \"Lisu\")\nDEF(Lycian, \"Lyci\")\nDEF(Lydian, \"Lydi\")\nDEF(Makasar, \"Maka\")\nDEF(Mahajani, \"Mahj\")\nDEF(Malayalam, \"Mlym\")\nDEF(Mandaic, \"Mand\")\nDEF(Manichaean, \"Mani\")\nDEF(Marchen, \"Marc\")\nDEF(Masaram_Gondi, \"Gonm\")\nDEF(Medefaidrin, \"Medf\")\nDEF(Meetei_Mayek, \"Mtei\")\nDEF(Mende_Kikakui, \"Mend\")\nDEF(Meroitic_Cursive, \"Merc\")\nDEF(Meroitic_Hieroglyphs, \"Mero\")\nDEF(Miao, \"Plrd\")\nDEF(Modi, \"Modi\")\nDEF(Mongolian, \"Mong\")\nDEF(Mro, \"Mroo\")\nDEF(Multani, \"Mult\")\nDEF(Myanmar, \"Mymr\")\nDEF(Nabataean, \"Nbat\")\nDEF(Nag_Mundari, \"Nagm\")\nDEF(Nandinagari, \"Nand\")\nDEF(New_Tai_Lue, \"Talu\")\nDEF(Newa, \"Newa\")\nDEF(Nko, \"Nkoo\")\nDEF(Nushu, \"Nshu\")\nDEF(Nyiakeng_Puachue_Hmong, \"Hmnp\")\nDEF(Ogham, \"Ogam\")\nDEF(Ol_Chiki, \"Olck\")\nDEF(Old_Hungarian, \"Hung\")\nDEF(Old_Italic, \"Ital\")\nDEF(Old_North_Arabian, \"Narb\")\nDEF(Old_Permic, \"Perm\")\nDEF(Old_Persian, \"Xpeo\")\nDEF(Old_Sogdian, \"Sogo\")\nDEF(Old_South_Arabian, \"Sarb\")\nDEF(Old_Turkic, \"Orkh\")\nDEF(Old_Uyghur, \"Ougr\")\nDEF(Oriya, \"Orya\")\nDEF(Osage, \"Osge\")\nDEF(Osmanya, \"Osma\")\nDEF(Pahawh_Hmong, \"Hmng\")\nDEF(Palmyrene, \"Palm\")\nDEF(Pau_Cin_Hau, \"Pauc\")\nDEF(Phags_Pa, \"Phag\")\nDEF(Phoenician, \"Phnx\")\nDEF(Psalter_Pahlavi, \"Phlp\")\nDEF(Rejang, \"Rjng\")\nDEF(Runic, \"Runr\")\nDEF(Samaritan, \"Samr\")\nDEF(Saurashtra, \"Saur\")\nDEF(Sharada, \"Shrd\")\nDEF(Shavian, \"Shaw\")\nDEF(Siddham, \"Sidd\")\nDEF(SignWriting, \"Sgnw\")\nDEF(Sinhala, \"Sinh\")\nDEF(Sogdian, \"Sogd\")\nDEF(Sora_Sompeng, \"Sora\")\nDEF(Soyombo, \"Soyo\")\nDEF(Sundanese, \"Sund\")\nDEF(Syloti_Nagri, \"Sylo\")\nDEF(Syriac, \"Syrc\")\nDEF(Tagalog, \"Tglg\")\nDEF(Tagbanwa, \"Tagb\")\nDEF(Tai_Le, \"Tale\")\nDEF(Tai_Tham, \"Lana\")\nDEF(Tai_Viet, \"Tavt\")\nDEF(Takri, \"Takr\")\nDEF(Tamil, \"Taml\")\nDEF(Tangut, \"Tang\")\nDEF(Telugu, \"Telu\")\nDEF(Thaana, \"Thaa\")\nDEF(Thai, \"Thai\")\nDEF(Tibetan, \"Tibt\")\nDEF(Tifinagh, \"Tfng\")\nDEF(Tirhuta, \"Tirh\")\nDEF(Tangsa, \"Tnsa\")\nDEF(Toto, \"Toto\")\nDEF(Ugaritic, \"Ugar\")\nDEF(Vai, \"Vaii\")\nDEF(Vithkuqi, \"Vith\")\nDEF(Wancho, \"Wcho\")\nDEF(Warang_Citi, \"Wara\")\nDEF(Yezidi, \"Yezi\")\nDEF(Yi, \"Yiii\")\nDEF(Zanabazar_Square, \"Zanb\")\n#endif\n\n#ifdef UNICODE_PROP_LIST\n/* Prop list not exported to regexp */\nDEF(Hyphen, \"\")\nDEF(Other_Math, \"\")\nDEF(Other_Alphabetic, \"\")\nDEF(Other_Lowercase, \"\")\nDEF(Other_Uppercase, \"\")\nDEF(Other_Grapheme_Extend, \"\")\nDEF(Other_Default_Ignorable_Code_Point, \"\")\nDEF(Other_ID_Start, \"\")\nDEF(Other_ID_Continue, \"\")\nDEF(Prepended_Concatenation_Mark, \"\")\n/* additional computed properties for smaller tables */\nDEF(ID_Continue1, \"\")\nDEF(XID_Start1, \"\")\nDEF(XID_Continue1, \"\")\nDEF(Changes_When_Titlecased1, \"\")\nDEF(Changes_When_Casefolded1, \"\")\nDEF(Changes_When_NFKC_Casefolded1, \"\")\n\n/* Prop list exported to JS */\nDEF(ASCII_Hex_Digit, \"AHex\")\nDEF(Bidi_Control, \"Bidi_C\")\nDEF(Dash, \"\")\nDEF(Deprecated, \"Dep\")\nDEF(Diacritic, \"Dia\")\nDEF(Extender, \"Ext\")\nDEF(Hex_Digit, \"Hex\")\nDEF(IDS_Binary_Operator, \"IDSB\")\nDEF(IDS_Trinary_Operator, \"IDST\")\nDEF(Ideographic, \"Ideo\")\nDEF(Join_Control, \"Join_C\")\nDEF(Logical_Order_Exception, \"LOE\")\nDEF(Noncharacter_Code_Point, \"NChar\")\nDEF(Pattern_Syntax, \"Pat_Syn\")\nDEF(Pattern_White_Space, \"Pat_WS\")\nDEF(Quotation_Mark, \"QMark\")\nDEF(Radical, \"\")\nDEF(Regional_Indicator, \"RI\")\nDEF(Sentence_Terminal, \"STerm\")\nDEF(Soft_Dotted, \"SD\")\nDEF(Terminal_Punctuation, \"Term\")\nDEF(Unified_Ideograph, \"UIdeo\")\nDEF(Variation_Selector, \"VS\")\nDEF(White_Space, \"space\")\nDEF(Bidi_Mirrored, \"Bidi_M\")\nDEF(Emoji, \"\")\nDEF(Emoji_Component, \"EComp\")\nDEF(Emoji_Modifier, \"EMod\")\nDEF(Emoji_Modifier_Base, \"EBase\")\nDEF(Emoji_Presentation, \"EPres\")\nDEF(Extended_Pictographic, \"ExtPict\")\nDEF(Default_Ignorable_Code_Point, \"DI\")\nDEF(ID_Start, \"IDS\")\nDEF(Case_Ignorable, \"CI\")\n\n/* other binary properties */\nDEF(ASCII,\"\")\nDEF(Alphabetic, \"Alpha\")\nDEF(Any, \"\")\nDEF(Assigned,\"\")\nDEF(Cased, \"\")\nDEF(Changes_When_Casefolded, \"CWCF\")\nDEF(Changes_When_Casemapped, \"CWCM\")\nDEF(Changes_When_Lowercased, \"CWL\")\nDEF(Changes_When_NFKC_Casefolded, \"CWKCF\")\nDEF(Changes_When_Titlecased, \"CWT\")\nDEF(Changes_When_Uppercased, \"CWU\")\nDEF(Grapheme_Base, \"Gr_Base\")\nDEF(Grapheme_Extend, \"Gr_Ext\")\nDEF(ID_Continue, \"IDC\")\nDEF(Lowercase, \"Lower\")\nDEF(Math, \"\")\nDEF(Uppercase, \"Upper\")\nDEF(XID_Continue, \"XIDC\")\nDEF(XID_Start, \"XIDS\")\n\n/* internal tables with index */\nDEF(Cased1, \"\")\n\n#endif\n"
        }
      ]
    }
  ]
}